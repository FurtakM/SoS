// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 88110 0 0
// InitMacro ;
  23: CALL 17929 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81918 0 9
// PrepareAmerican ;
  81: CALL 663 0 0
// PrepareArabian ;
  85: CALL 2614 0 0
// MC_Start ( ) ;
  89: CALL 20094 0 0
// Action ;
  93: CALL 8559 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: LD_INT 235200
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: ST_TO_ADDR
// powell_warn := false ;
 245: LD_ADDR_EXP 16
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// loses_counter := 0 ;
 253: LD_ADDR_EXP 17
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// artifact_oncargo := false ;
 261: LD_ADDR_EXP 14
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 269: LD_ADDR_EXP 18
 273: PUSH
 274: LD_STRING 10_GensherEscape_1
 276: PPUSH
 277: LD_EXP 1
 281: PPUSH
 282: CALL_OW 30
 286: ST_TO_ADDR
// can_kamikazed := false ;
 287: LD_ADDR_EXP 10
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// am_veh_consturcted := false ;
 295: LD_ADDR_EXP 20
 299: PUSH
 300: LD_INT 0
 302: ST_TO_ADDR
// end ;
 303: LD_VAR 0 1
 307: RET
// export function CustomInitMacro ; var i ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 312: LD_ADDR_EXP 74
 316: PUSH
 317: LD_INT 20
 319: PUSH
 320: LD_INT 21
 322: PUSH
 323: LD_INT 22
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 331: LD_ADDR_EXP 75
 335: PUSH
 336: LD_INT 28
 338: PUSH
 339: LD_INT 24
 341: PUSH
 342: LD_INT 26
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: LIST
 349: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PUSH
 356: LD_INT 6
 358: PUSH
 359: LD_INT 8
 361: PUSH
 362: LD_INT 9
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_OWVAR 67
 375: ARRAY
 376: PPUSH
 377: LD_INT 3
 379: PPUSH
 380: CALL 41783 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 384: LD_INT 2
 386: PPUSH
 387: LD_INT 4
 389: PUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 8
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: PUSH
 405: LD_OWVAR 67
 409: ARRAY
 410: PPUSH
 411: LD_INT 2
 413: PPUSH
 414: CALL 41783 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 418: LD_INT 3
 420: PPUSH
 421: LD_INT 4
 423: PUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 8
 429: PUSH
 430: LD_INT 9
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_OWVAR 67
 443: ARRAY
 444: PPUSH
 445: LD_INT 1
 447: PPUSH
 448: CALL 41783 0 3
// for i = 1 to mc_bases do
 452: LD_ADDR_VAR 0 2
 456: PUSH
 457: DOUBLE
 458: LD_INT 1
 460: DEC
 461: ST_TO_ADDR
 462: LD_EXP 50
 466: PUSH
 467: FOR_TO
 468: IFFALSE 492
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 470: LD_VAR 0 2
 474: PPUSH
 475: LD_EXP 43
 479: PUSH
 480: LD_VAR 0 2
 484: ARRAY
 485: PPUSH
 486: CALL 42209 0 2
 490: GO 467
 492: POP
 493: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 494: LD_INT 1
 496: PPUSH
 497: LD_INT 14
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_EXP 100
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: PUSH
 517: LD_INT 14
 519: PUSH
 520: LD_INT 1
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: LD_EXP 100
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL 42101 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 545: LD_INT 2
 547: PPUSH
 548: LD_INT 14
 550: PUSH
 551: LD_INT 1
 553: PUSH
 554: LD_INT 2
 556: PUSH
 557: LD_EXP 100
 561: PUSH
 562: EMPTY
 563: LIST
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: EMPTY
 569: LIST
 570: PPUSH
 571: CALL 42101 0 2
// end ;
 575: LD_VAR 0 1
 579: RET
// function Debuger ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// if not debug then
 584: LD_EXP 1
 588: NOT
 589: IFFALSE 593
// exit ;
 591: GO 629
// game_speed := 5 ;
 593: LD_ADDR_OWVAR 65
 597: PUSH
 598: LD_INT 5
 600: ST_TO_ADDR
// uc_side := 1 ;
 601: LD_ADDR_OWVAR 20
 605: PUSH
 606: LD_INT 1
 608: ST_TO_ADDR
// uc_nation := 1 ;
 609: LD_ADDR_OWVAR 21
 613: PUSH
 614: LD_INT 1
 616: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 617: LD_EXP 36
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 235
// end ;
 629: LD_VAR 0 1
 633: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 634: LD_INT 94
 636: PPUSH
 637: CALL_OW 301
 641: PUSH
 642: LD_INT 45
 644: PPUSH
 645: CALL_OW 302
 649: AND
 650: IFFALSE 662
 652: GO 654
 654: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 655: LD_STRING ACH_EAST
 657: PPUSH
 658: CALL_OW 543
 662: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 663: LD_INT 0
 665: PPUSH
 666: PPUSH
 667: PPUSH
 668: PPUSH
 669: PPUSH
 670: PPUSH
 671: PPUSH
 672: PPUSH
// uc_side := 4 ;
 673: LD_ADDR_OWVAR 20
 677: PUSH
 678: LD_INT 4
 680: ST_TO_ADDR
// uc_nation := 1 ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 1
 688: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 689: LD_ADDR_EXP 30
 693: PUSH
 694: LD_STRING Powell
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: LD_STRING 
 702: PPUSH
 703: CALL 48555 0 3
 707: ST_TO_ADDR
// uc_side := 1 ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 716: LD_ADDR_EXP 21
 720: PUSH
 721: LD_STRING JMM
 723: PPUSH
 724: LD_EXP 1
 728: NOT
 729: PPUSH
 730: LD_EXP 4
 734: PPUSH
 735: CALL 48555 0 3
 739: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 740: LD_EXP 21
 744: PPUSH
 745: CALL_OW 257
 749: PUSH
 750: LD_INT 4
 752: GREATER
 753: IFFALSE 767
// SetClass ( JMM , 1 ) ;
 755: LD_EXP 21
 759: PPUSH
 760: LD_INT 1
 762: PPUSH
 763: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 767: LD_ADDR_EXP 22
 771: PUSH
 772: LD_STRING Lisa
 774: PPUSH
 775: LD_EXP 1
 779: NOT
 780: PPUSH
 781: LD_EXP 4
 785: PPUSH
 786: CALL 48555 0 3
 790: ST_TO_ADDR
// if not Lisa then
 791: LD_EXP 22
 795: NOT
 796: IFFALSE 811
// Lisa := CreateCharacter ( 10_Lisa ) ;
 798: LD_ADDR_EXP 22
 802: PUSH
 803: LD_STRING 10_Lisa
 805: PPUSH
 806: CALL_OW 34
 810: ST_TO_ADDR
// if not Lisa then
 811: LD_EXP 22
 815: NOT
 816: IFFALSE 831
// Lisa := CreateCharacter ( 09_Lisa ) ;
 818: LD_ADDR_EXP 22
 822: PUSH
 823: LD_STRING 09_Lisa
 825: PPUSH
 826: CALL_OW 34
 830: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 831: LD_ADDR_EXP 31
 835: PUSH
 836: LD_STRING Cornel
 838: PPUSH
 839: LD_EXP 1
 843: NOT
 844: PPUSH
 845: LD_EXP 4
 849: PPUSH
 850: CALL 48555 0 3
 854: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_STRING Donaldson
 862: PPUSH
 863: LD_EXP 1
 867: NOT
 868: PPUSH
 869: LD_EXP 4
 873: PPUSH
 874: CALL 48555 0 3
 878: ST_TO_ADDR
// if not Donaldson then
 879: LD_EXP 23
 883: NOT
 884: IFFALSE 899
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 886: LD_ADDR_EXP 23
 890: PUSH
 891: LD_STRING 10_Donaldson
 893: PPUSH
 894: CALL_OW 34
 898: ST_TO_ADDR
// if not Donaldson then
 899: LD_EXP 23
 903: NOT
 904: IFFALSE 919
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 906: LD_ADDR_EXP 23
 910: PUSH
 911: LD_STRING 09_Donaldson
 913: PPUSH
 914: CALL_OW 34
 918: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 919: LD_ADDR_EXP 24
 923: PUSH
 924: LD_STRING Bobby
 926: PPUSH
 927: LD_EXP 1
 931: NOT
 932: PPUSH
 933: LD_EXP 4
 937: PPUSH
 938: CALL 48555 0 3
 942: ST_TO_ADDR
// if not Bobby then
 943: LD_EXP 24
 947: NOT
 948: IFFALSE 963
// Bobby := CreateCharacter ( 10_Bobby ) ;
 950: LD_ADDR_EXP 24
 954: PUSH
 955: LD_STRING 10_Bobby
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// if not Bobby then
 963: LD_EXP 24
 967: NOT
 968: IFFALSE 983
// Bobby := CreateCharacter ( 09_Bobby ) ;
 970: LD_ADDR_EXP 24
 974: PUSH
 975: LD_STRING 09_Bobby
 977: PPUSH
 978: CALL_OW 34
 982: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 983: LD_ADDR_EXP 25
 987: PUSH
 988: LD_STRING Cyrus
 990: PPUSH
 991: LD_EXP 1
 995: NOT
 996: PPUSH
 997: LD_EXP 4
1001: PPUSH
1002: CALL 48555 0 3
1006: ST_TO_ADDR
// if not Cyrus then
1007: LD_EXP 25
1011: NOT
1012: IFFALSE 1027
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1014: LD_ADDR_EXP 25
1018: PUSH
1019: LD_STRING 10_Cyrus
1021: PPUSH
1022: CALL_OW 34
1026: ST_TO_ADDR
// if not Cyrus then
1027: LD_EXP 25
1031: NOT
1032: IFFALSE 1047
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1034: LD_ADDR_EXP 25
1038: PUSH
1039: LD_STRING 09_Cyrus
1041: PPUSH
1042: CALL_OW 34
1046: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1047: LD_ADDR_EXP 26
1051: PUSH
1052: LD_STRING Denis
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_EXP 4
1065: PPUSH
1066: CALL 48555 0 3
1070: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1071: LD_ADDR_EXP 27
1075: PUSH
1076: LD_STRING Brown
1078: PPUSH
1079: LD_EXP 1
1083: NOT
1084: PPUSH
1085: LD_EXP 4
1089: PPUSH
1090: CALL 48555 0 3
1094: ST_TO_ADDR
// if not Brown then
1095: LD_EXP 27
1099: NOT
1100: IFFALSE 1115
// Brown := CreateCharacter ( 10_Brown ) ;
1102: LD_ADDR_EXP 27
1106: PUSH
1107: LD_STRING 10_Brown
1109: PPUSH
1110: CALL_OW 34
1114: ST_TO_ADDR
// if not Brown then
1115: LD_EXP 27
1119: NOT
1120: IFFALSE 1135
// Brown := CreateCharacter ( 08_Brown ) ;
1122: LD_ADDR_EXP 27
1126: PUSH
1127: LD_STRING 08_Brown
1129: PPUSH
1130: CALL_OW 34
1134: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1135: LD_ADDR_EXP 28
1139: PUSH
1140: LD_STRING Gladstone
1142: PPUSH
1143: LD_EXP 1
1147: NOT
1148: PPUSH
1149: LD_EXP 4
1153: PPUSH
1154: CALL 48555 0 3
1158: ST_TO_ADDR
// if not Gladstone then
1159: LD_EXP 28
1163: NOT
1164: IFFALSE 1179
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1166: LD_ADDR_EXP 28
1170: PUSH
1171: LD_STRING 10_Gladstone
1173: PPUSH
1174: CALL_OW 34
1178: ST_TO_ADDR
// if not Gladstone then
1179: LD_EXP 28
1183: NOT
1184: IFFALSE 1199
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1186: LD_ADDR_EXP 28
1190: PUSH
1191: LD_STRING 08_Gladstone
1193: PPUSH
1194: CALL_OW 34
1198: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1199: LD_ADDR_EXP 29
1203: PUSH
1204: LD_STRING Houten
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_EXP 4
1217: PPUSH
1218: CALL 48555 0 3
1222: ST_TO_ADDR
// if not Houten then
1223: LD_EXP 29
1227: NOT
1228: IFFALSE 1243
// Houten := CreateCharacter ( 10_Houten ) ;
1230: LD_ADDR_EXP 29
1234: PUSH
1235: LD_STRING 10_Houten
1237: PPUSH
1238: CALL_OW 34
1242: ST_TO_ADDR
// if not Houten then
1243: LD_EXP 29
1247: NOT
1248: IFFALSE 1263
// Houten := CreateCharacter ( 09_Houten ) ;
1250: LD_ADDR_EXP 29
1254: PUSH
1255: LD_STRING 09_Houten
1257: PPUSH
1258: CALL_OW 34
1262: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1263: LD_ADDR_EXP 31
1267: PUSH
1268: LD_STRING Cornell
1270: PPUSH
1271: LD_EXP 1
1275: NOT
1276: PPUSH
1277: LD_EXP 4
1281: PPUSH
1282: CALL 48555 0 3
1286: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1287: LD_ADDR_EXP 32
1291: PUSH
1292: LD_STRING Gary
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: LD_EXP 4
1305: PPUSH
1306: CALL 48555 0 3
1310: ST_TO_ADDR
// if not Gary then
1311: LD_EXP 32
1315: NOT
1316: IFFALSE 1331
// Gary := CreateCharacter ( 10_Gary ) ;
1318: LD_ADDR_EXP 32
1322: PUSH
1323: LD_STRING 10_Gary
1325: PPUSH
1326: CALL_OW 34
1330: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1331: LD_ADDR_EXP 33
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: LD_EXP 4
1349: PPUSH
1350: CALL 48555 0 3
1354: ST_TO_ADDR
// if not Frank then
1355: LD_EXP 33
1359: NOT
1360: IFFALSE 1375
// Frank := CreateCharacter ( 08_Frank ) ;
1362: LD_ADDR_EXP 33
1366: PUSH
1367: LD_STRING 08_Frank
1369: PPUSH
1370: CALL_OW 34
1374: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1375: LD_ADDR_EXP 34
1379: PUSH
1380: LD_STRING Kikuchi
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_EXP 4
1393: PPUSH
1394: CALL 48555 0 3
1398: ST_TO_ADDR
// if not Kikuchi then
1399: LD_EXP 34
1403: NOT
1404: IFFALSE 1419
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1406: LD_ADDR_EXP 34
1410: PUSH
1411: LD_STRING 08_Kikuchi
1413: PPUSH
1414: CALL_OW 34
1418: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1419: LD_ADDR_VAR 0 5
1423: PUSH
1424: LD_EXP 22
1428: PUSH
1429: LD_EXP 23
1433: PUSH
1434: LD_EXP 24
1438: PUSH
1439: LD_EXP 25
1443: PUSH
1444: LD_EXP 26
1448: PUSH
1449: LD_EXP 27
1453: PUSH
1454: LD_EXP 28
1458: PUSH
1459: LD_EXP 29
1463: PUSH
1464: LD_EXP 31
1468: PUSH
1469: LD_EXP 32
1473: PUSH
1474: LD_EXP 33
1478: PUSH
1479: LD_EXP 34
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: ST_TO_ADDR
// tmp := tmp diff 0 ;
1498: LD_ADDR_VAR 0 5
1502: PUSH
1503: LD_VAR 0 5
1507: PUSH
1508: LD_INT 0
1510: DIFF
1511: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1512: LD_ADDR_VAR 0 5
1516: PUSH
1517: LD_VAR 0 5
1521: PUSH
1522: LD_STRING 10_lock
1524: PPUSH
1525: CALL_OW 31
1529: UNION
1530: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1531: LD_ADDR_VAR 0 5
1535: PUSH
1536: LD_VAR 0 5
1540: PUSH
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 31
1548: UNION
1549: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1550: LD_STRING 10_lock
1552: PPUSH
1553: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1557: LD_STRING 10c_lock
1559: PPUSH
1560: CALL_OW 40
// for i in tmp do
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: LD_VAR 0 5
1573: PUSH
1574: FOR_IN
1575: IFFALSE 1613
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1577: LD_VAR 0 2
1581: PPUSH
1582: CALL_OW 257
1586: PUSH
1587: LD_INT 8
1589: PUSH
1590: LD_INT 2
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: IN
1597: IFFALSE 1611
// SetClass ( i , class_soldier ) ;
1599: LD_VAR 0 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: CALL_OW 336
1611: GO 1574
1613: POP
1614: POP
// if tmp < 12 then
1615: LD_VAR 0 5
1619: PUSH
1620: LD_INT 12
1622: LESS
1623: IFFALSE 1717
// begin k := 16 - tmp ;
1625: LD_ADDR_VAR 0 3
1629: PUSH
1630: LD_INT 16
1632: PUSH
1633: LD_VAR 0 5
1637: MINUS
1638: ST_TO_ADDR
// for i = 1 to k do
1639: LD_ADDR_VAR 0 2
1643: PUSH
1644: DOUBLE
1645: LD_INT 1
1647: DEC
1648: ST_TO_ADDR
1649: LD_VAR 0 3
1653: PUSH
1654: FOR_TO
1655: IFFALSE 1715
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1657: LD_INT 0
1659: PPUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 1
1665: PUSH
1666: LD_INT 3
1668: PUSH
1669: LD_INT 4
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 1
1680: PPUSH
1681: LD_INT 4
1683: PPUSH
1684: CALL_OW 12
1688: ARRAY
1689: PPUSH
1690: LD_INT 6
1692: PPUSH
1693: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_VAR 0 5
1706: PUSH
1707: CALL_OW 44
1711: ADD
1712: ST_TO_ADDR
// end ;
1713: GO 1654
1715: POP
1716: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1717: LD_ADDR_EXP 19
1721: PUSH
1722: LD_STRING 1
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 12
1730: PPUSH
1731: LD_INT -5
1733: PUSH
1734: LD_EXP 21
1738: PUSH
1739: LD_INT -2
1741: PUSH
1742: LD_INT -3
1744: PUSH
1745: LD_INT -5
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PUSH
1755: LD_VAR 0 5
1759: ADD
1760: PUSH
1761: LD_INT -6
1763: PUSH
1764: LD_INT -4
1766: PUSH
1767: LD_EXP 30
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: LIST
1776: ADD
1777: PPUSH
1778: LD_INT 1
1780: PUSH
1781: LD_INT 4
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 3
1790: PUSH
1791: LD_INT 0
1793: PUSH
1794: LD_INT 5
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: PUSH
1802: LD_INT 4
1804: PUSH
1805: LD_INT 0
1807: PUSH
1808: LD_INT 3
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: LIST
1815: PUSH
1816: LD_INT 5
1818: PUSH
1819: LD_INT 0
1821: PUSH
1822: LD_INT 2
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL_OW 42
1840: ST_TO_ADDR
// others := tmp diff selected ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 5
1850: PUSH
1851: LD_EXP 19
1855: DIFF
1856: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1857: LD_ADDR_VAR 0 8
1861: PUSH
1862: LD_VAR 0 8
1866: PUSH
1867: LD_EXP 22
1871: PUSH
1872: LD_EXP 23
1876: PUSH
1877: LD_EXP 24
1881: PUSH
1882: LD_EXP 25
1886: PUSH
1887: LD_EXP 26
1891: PUSH
1892: LD_EXP 27
1896: PUSH
1897: LD_EXP 28
1901: PUSH
1902: LD_EXP 29
1906: PUSH
1907: LD_EXP 31
1911: PUSH
1912: LD_EXP 32
1916: PUSH
1917: LD_EXP 33
1921: PUSH
1922: LD_EXP 34
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: DIFF
1941: ST_TO_ADDR
// if others then
1942: LD_VAR 0 8
1946: IFFALSE 1960
// SaveCharacters ( others , 11_others ) ;
1948: LD_VAR 0 8
1952: PPUSH
1953: LD_STRING 11_others
1955: PPUSH
1956: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1960: LD_ADDR_VAR 0 6
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 1
1970: PUSH
1971: LD_INT 1
1973: PUSH
1974: LD_INT 4
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: PUSH
1983: LD_INT 2
1985: PUSH
1986: LD_INT 2
1988: PUSH
1989: LD_INT 1
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 1
2006: PUSH
2007: LD_INT 1
2009: PUSH
2010: LD_INT 5
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 2
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 1
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: PUSH
2037: LD_INT 3
2039: PUSH
2040: LD_INT 2
2042: PUSH
2043: LD_INT 1
2045: PUSH
2046: LD_INT 7
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: ST_TO_ADDR
// for i in JMM ^ selected do
2062: LD_ADDR_VAR 0 2
2066: PUSH
2067: LD_EXP 21
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: PUSH
2078: FOR_IN
2079: IFFALSE 2268
// begin if GetClass ( i ) = 3 then
2081: LD_VAR 0 2
2085: PPUSH
2086: CALL_OW 257
2090: PUSH
2091: LD_INT 3
2093: EQUAL
2094: IFFALSE 2251
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2096: LD_ADDR_OWVAR 37
2100: PUSH
2101: LD_VAR 0 6
2105: PUSH
2106: LD_INT 1
2108: ARRAY
2109: PUSH
2110: LD_INT 1
2112: ARRAY
2113: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2114: LD_ADDR_OWVAR 39
2118: PUSH
2119: LD_VAR 0 6
2123: PUSH
2124: LD_INT 1
2126: ARRAY
2127: PUSH
2128: LD_INT 2
2130: ARRAY
2131: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2132: LD_ADDR_OWVAR 38
2136: PUSH
2137: LD_VAR 0 6
2141: PUSH
2142: LD_INT 1
2144: ARRAY
2145: PUSH
2146: LD_INT 3
2148: ARRAY
2149: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2150: LD_ADDR_OWVAR 40
2154: PUSH
2155: LD_VAR 0 6
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2168: LD_ADDR_VAR 0 6
2172: PUSH
2173: LD_VAR 0 6
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: CALL_OW 3
2185: ST_TO_ADDR
// veh := CreateVehicle ;
2186: LD_ADDR_VAR 0 7
2190: PUSH
2191: CALL_OW 45
2195: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2196: LD_VAR 0 7
2200: PPUSH
2201: LD_INT 8
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_VAR 0 7
2220: PPUSH
2221: CALL_OW 52
// if i = JMM then
2225: LD_VAR 0 2
2229: PUSH
2230: LD_EXP 21
2234: EQUAL
2235: IFFALSE 2249
// SetMark ( veh , 1 ) ;
2237: LD_VAR 0 7
2241: PPUSH
2242: LD_INT 1
2244: PPUSH
2245: CALL_OW 242
// end else
2249: GO 2266
// PlaceUnitArea ( i , am_hum_start , false ) ;
2251: LD_VAR 0 2
2255: PPUSH
2256: LD_INT 9
2258: PPUSH
2259: LD_INT 0
2261: PPUSH
2262: CALL_OW 49
// end ;
2266: GO 2078
2268: POP
2269: POP
// vc_chassis := us_medium_tracked ;
2270: LD_ADDR_OWVAR 37
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_engine := engine_solar ;
2278: LD_ADDR_OWVAR 39
2282: PUSH
2283: LD_INT 2
2285: ST_TO_ADDR
// vc_control := control_computer ;
2286: LD_ADDR_OWVAR 38
2290: PUSH
2291: LD_INT 3
2293: ST_TO_ADDR
// vc_weapon := us_radar ;
2294: LD_ADDR_OWVAR 40
2298: PUSH
2299: LD_INT 11
2301: ST_TO_ADDR
// veh := CreateVehicle ;
2302: LD_ADDR_VAR 0 7
2306: PUSH
2307: CALL_OW 45
2311: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2312: LD_VAR 0 7
2316: PPUSH
2317: LD_INT 87
2319: PPUSH
2320: LD_INT 142
2322: PPUSH
2323: LD_INT 0
2325: PPUSH
2326: CALL_OW 48
// end ;
2330: LD_VAR 0 1
2334: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2335: LD_INT 0
2337: PPUSH
2338: PPUSH
2339: PPUSH
2340: PPUSH
// uc_side := 1 ;
2341: LD_ADDR_OWVAR 20
2345: PUSH
2346: LD_INT 1
2348: ST_TO_ADDR
// uc_nation := 1 ;
2349: LD_ADDR_OWVAR 21
2353: PUSH
2354: LD_INT 1
2356: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2357: LD_ADDR_VAR 0 3
2361: PUSH
2362: LD_INT 3
2364: PUSH
2365: LD_INT 1
2367: PUSH
2368: LD_INT 3
2370: PUSH
2371: LD_INT 5
2373: PUSH
2374: EMPTY
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: PUSH
2380: LD_INT 3
2382: PUSH
2383: LD_INT 1
2385: PUSH
2386: LD_INT 3
2388: PUSH
2389: LD_INT 7
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: PUSH
2398: LD_INT 3
2400: PUSH
2401: LD_INT 1
2403: PUSH
2404: LD_INT 3
2406: PUSH
2407: LD_INT 7
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: LD_INT 3
2424: PUSH
2425: LD_INT 11
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: PUSH
2434: LD_INT 4
2436: PUSH
2437: LD_INT 1
2439: PUSH
2440: LD_INT 3
2442: PUSH
2443: LD_INT 6
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: LIST
2450: LIST
2451: PUSH
2452: LD_INT 4
2454: PUSH
2455: LD_INT 1
2457: PUSH
2458: LD_INT 3
2460: PUSH
2461: LD_INT 5
2463: PUSH
2464: EMPTY
2465: LIST
2466: LIST
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2478: LD_ADDR_VAR 0 2
2482: PUSH
2483: DOUBLE
2484: LD_INT 1
2486: DEC
2487: ST_TO_ADDR
2488: LD_INT 7
2490: PUSH
2491: LD_OWVAR 67
2495: MINUS
2496: PUSH
2497: FOR_TO
2498: IFFALSE 2607
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2500: LD_ADDR_OWVAR 37
2504: PUSH
2505: LD_VAR 0 3
2509: PUSH
2510: LD_VAR 0 2
2514: ARRAY
2515: PUSH
2516: LD_INT 1
2518: ARRAY
2519: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2520: LD_ADDR_OWVAR 39
2524: PUSH
2525: LD_VAR 0 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2540: LD_ADDR_OWVAR 38
2544: PUSH
2545: LD_VAR 0 3
2549: PUSH
2550: LD_VAR 0 2
2554: ARRAY
2555: PUSH
2556: LD_INT 3
2558: ARRAY
2559: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2560: LD_ADDR_OWVAR 40
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: LD_VAR 0 2
2574: ARRAY
2575: PUSH
2576: LD_INT 4
2578: ARRAY
2579: ST_TO_ADDR
// veh := CreateVehicle ;
2580: LD_ADDR_VAR 0 4
2584: PUSH
2585: CALL_OW 45
2589: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2590: LD_VAR 0 4
2594: PPUSH
2595: LD_INT 8
2597: PPUSH
2598: LD_INT 0
2600: PPUSH
2601: CALL_OW 49
// end ;
2605: GO 2497
2607: POP
2608: POP
// end ; end_of_file
2609: LD_VAR 0 1
2613: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2614: LD_INT 0
2616: PPUSH
2617: PPUSH
2618: PPUSH
2619: PPUSH
2620: PPUSH
2621: PPUSH
// if Difficulty = 1 then
2622: LD_OWVAR 67
2626: PUSH
2627: LD_INT 1
2629: EQUAL
2630: IFFALSE 2727
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2632: LD_ADDR_VAR 0 6
2636: PUSH
2637: LD_INT 129
2639: PUSH
2640: LD_INT 45
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: PUSH
2647: LD_INT 143
2649: PUSH
2650: LD_INT 58
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 184
2659: PUSH
2660: LD_INT 113
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 163
2669: PUSH
2670: LD_INT 107
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: LIST
2681: LIST
2682: ST_TO_ADDR
// for i in tmp do
2683: LD_ADDR_VAR 0 2
2687: PUSH
2688: LD_VAR 0 6
2692: PUSH
2693: FOR_IN
2694: IFFALSE 2725
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 1
2703: ARRAY
2704: PPUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_INT 2
2712: ARRAY
2713: PPUSH
2714: CALL_OW 428
2718: PPUSH
2719: CALL_OW 64
2723: GO 2693
2725: POP
2726: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2727: LD_ADDR_VAR 0 2
2731: PUSH
2732: LD_INT 21
2734: PUSH
2735: LD_INT 3
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PPUSH
2742: CALL_OW 69
2746: PUSH
2747: FOR_IN
2748: IFFALSE 2785
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2750: LD_VAR 0 2
2754: PPUSH
2755: LD_INT 5
2757: PUSH
2758: LD_INT 6
2760: PUSH
2761: LD_INT 7
2763: PUSH
2764: LD_INT 8
2766: PUSH
2767: EMPTY
2768: LIST
2769: LIST
2770: LIST
2771: LIST
2772: PUSH
2773: LD_OWVAR 67
2777: ARRAY
2778: PPUSH
2779: CALL_OW 241
2783: GO 2747
2785: POP
2786: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2787: LD_ADDR_VAR 0 5
2791: PUSH
2792: LD_INT 5
2794: PUSH
2795: LD_INT 6
2797: PUSH
2798: LD_INT 7
2800: PUSH
2801: LD_INT 8
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: PUSH
2810: LD_OWVAR 67
2814: ARRAY
2815: ST_TO_ADDR
// uc_side := 2 ;
2816: LD_ADDR_OWVAR 20
2820: PUSH
2821: LD_INT 2
2823: ST_TO_ADDR
// uc_nation := 2 ;
2824: LD_ADDR_OWVAR 21
2828: PUSH
2829: LD_INT 2
2831: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2832: LD_ADDR_OWVAR 37
2836: PUSH
2837: LD_INT 14
2839: ST_TO_ADDR
// vc_engine := engine_siberite ;
2840: LD_ADDR_OWVAR 39
2844: PUSH
2845: LD_INT 3
2847: ST_TO_ADDR
// vc_control := control_manual ;
2848: LD_ADDR_OWVAR 38
2852: PUSH
2853: LD_INT 1
2855: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2856: LD_ADDR_OWVAR 40
2860: PUSH
2861: LD_INT 31
2863: ST_TO_ADDR
// for i = 1 to 3 do
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: DOUBLE
2870: LD_INT 1
2872: DEC
2873: ST_TO_ADDR
2874: LD_INT 3
2876: PUSH
2877: FOR_TO
2878: IFFALSE 2962
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2880: LD_INT 0
2882: PPUSH
2883: LD_INT 3
2885: PPUSH
2886: LD_VAR 0 5
2890: PPUSH
2891: CALL_OW 380
// un := CreateVehicle ;
2895: LD_ADDR_VAR 0 4
2899: PUSH
2900: CALL_OW 45
2904: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2905: LD_VAR 0 4
2909: PPUSH
2910: LD_INT 0
2912: PPUSH
2913: LD_INT 5
2915: PPUSH
2916: CALL_OW 12
2920: PPUSH
2921: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2925: LD_VAR 0 4
2929: PPUSH
2930: LD_INT 156
2932: PPUSH
2933: LD_INT 15
2935: PPUSH
2936: LD_INT 6
2938: PPUSH
2939: LD_INT 0
2941: PPUSH
2942: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2946: CALL_OW 44
2950: PPUSH
2951: LD_VAR 0 4
2955: PPUSH
2956: CALL_OW 52
// end ;
2960: GO 2877
2962: POP
2963: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2964: LD_ADDR_EXP 37
2968: PUSH
2969: LD_INT 94
2971: PPUSH
2972: LD_INT 28
2974: PPUSH
2975: LD_STRING dammam
2977: PPUSH
2978: LD_VAR 0 5
2982: PPUSH
2983: LD_INT 10000
2985: PUSH
2986: LD_INT 1000
2988: PUSH
2989: LD_INT 300
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: LIST
2996: PPUSH
2997: LD_INT 12
2999: PUSH
3000: LD_INT 2
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 4
3008: PUSH
3009: LD_INT 4
3011: PUSH
3012: EMPTY
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: PUSH
3018: LD_OWVAR 67
3022: ARRAY
3023: PUSH
3024: LD_INT 1
3026: NEG
3027: PUSH
3028: LD_INT 4
3030: PUSH
3031: EMPTY
3032: LIST
3033: LIST
3034: LIST
3035: LIST
3036: PPUSH
3037: CALL 56865 0 6
3041: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3042: LD_ADDR_EXP 37
3046: PUSH
3047: LD_EXP 37
3051: PUSH
3052: LD_INT 122
3054: PPUSH
3055: LD_INT 25
3057: PPUSH
3058: LD_STRING 
3060: PPUSH
3061: LD_VAR 0 5
3065: PPUSH
3066: LD_INT 500
3068: PUSH
3069: LD_INT 60
3071: PUSH
3072: LD_INT 0
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: LIST
3079: PPUSH
3080: LD_INT 8
3082: PUSH
3083: LD_INT 2
3085: PUSH
3086: LD_INT 3
3088: PUSH
3089: LD_INT 4
3091: PUSH
3092: LD_INT 5
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PUSH
3107: LD_INT 2
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: PPUSH
3119: CALL 56865 0 6
3123: UNION
3124: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3125: LD_ADDR_EXP 35
3129: PUSH
3130: LD_INT 45
3132: PPUSH
3133: LD_INT 24
3135: PPUSH
3136: LD_STRING jeddah
3138: PPUSH
3139: LD_VAR 0 5
3143: PPUSH
3144: LD_INT 700
3146: PUSH
3147: LD_INT 300
3149: PUSH
3150: LD_INT 10
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: LIST
3157: PPUSH
3158: LD_INT 9
3160: PUSH
3161: LD_INT 4
3163: PUSH
3164: LD_INT 3
3166: PUSH
3167: LD_INT 2
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL 56865 0 6
3180: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3181: LD_ADDR_EXP 36
3185: PUSH
3186: LD_INT 7
3188: PPUSH
3189: LD_INT 27
3191: PPUSH
3192: LD_STRING riyadh
3194: PPUSH
3195: LD_VAR 0 5
3199: PPUSH
3200: LD_INT 500
3202: PUSH
3203: LD_INT 60
3205: PUSH
3206: LD_INT 0
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: LIST
3213: PPUSH
3214: LD_INT 4
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 3
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: PPUSH
3232: CALL 56865 0 6
3236: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3237: LD_ADDR_EXP 39
3241: PUSH
3242: LD_INT 204
3244: PPUSH
3245: LD_INT 26
3247: PPUSH
3248: LD_STRING 
3250: PPUSH
3251: LD_VAR 0 5
3255: PPUSH
3256: LD_INT 500
3258: PUSH
3259: LD_INT 50
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: PPUSH
3270: LD_INT 9
3272: PUSH
3273: LD_INT 2
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: LD_INT 1
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL 56865 0 6
3292: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3293: LD_ADDR_EXP 50
3297: PUSH
3298: LD_EXP 37
3302: PUSH
3303: LD_EXP 35
3307: PUSH
3308: LD_EXP 39
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: LIST
3317: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3318: LD_ADDR_VAR 0 2
3322: PUSH
3323: LD_INT 22
3325: PUSH
3326: LD_INT 2
3328: PUSH
3329: EMPTY
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 30
3335: PUSH
3336: LD_INT 31
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 58
3345: PUSH
3346: EMPTY
3347: LIST
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: PPUSH
3354: CALL_OW 69
3358: PUSH
3359: FOR_IN
3360: IFFALSE 3485
// begin if GetBase ( i ) then
3362: LD_VAR 0 2
3366: PPUSH
3367: CALL_OW 274
3371: IFFALSE 3375
// continue ;
3373: GO 3359
// d := GetDir ( i ) ;
3375: LD_ADDR_VAR 0 3
3379: PUSH
3380: LD_VAR 0 2
3384: PPUSH
3385: CALL_OW 254
3389: ST_TO_ADDR
// if d < 3 then
3390: LD_VAR 0 3
3394: PUSH
3395: LD_INT 3
3397: LESS
3398: IFFALSE 3416
// d := d + 3 else
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: LD_VAR 0 3
3409: PUSH
3410: LD_INT 3
3412: PLUS
3413: ST_TO_ADDR
3414: GO 3430
// d := d - 3 ;
3416: LD_ADDR_VAR 0 3
3420: PUSH
3421: LD_VAR 0 3
3425: PUSH
3426: LD_INT 3
3428: MINUS
3429: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3430: LD_INT 0
3432: PPUSH
3433: LD_INT 8
3435: PPUSH
3436: LD_VAR 0 5
3440: PPUSH
3441: CALL_OW 380
// un := CreateHuman ;
3445: LD_ADDR_VAR 0 4
3449: PUSH
3450: CALL_OW 44
3454: ST_TO_ADDR
// SetDir ( un , d ) ;
3455: LD_VAR 0 4
3459: PPUSH
3460: LD_VAR 0 3
3464: PPUSH
3465: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3469: LD_VAR 0 4
3473: PPUSH
3474: LD_VAR 0 2
3478: PPUSH
3479: CALL_OW 52
// end ;
3483: GO 3359
3485: POP
3486: POP
// if Difficulty > 1 then
3487: LD_OWVAR 67
3491: PUSH
3492: LD_INT 1
3494: GREATER
3495: IFFALSE 3866
// begin ar_kamikadze := [ ] ;
3497: LD_ADDR_EXP 42
3501: PUSH
3502: EMPTY
3503: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3504: LD_INT 0
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_VAR 0 5
3514: PPUSH
3515: CALL_OW 380
// un := CreateHuman ;
3519: LD_ADDR_VAR 0 4
3523: PUSH
3524: CALL_OW 44
3528: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3529: LD_VAR 0 4
3533: PPUSH
3534: LD_INT 3
3536: PPUSH
3537: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3541: LD_VAR 0 4
3545: PPUSH
3546: LD_INT 23
3548: PPUSH
3549: LD_INT 44
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// ComCrawl ( un ) ;
3559: LD_VAR 0 4
3563: PPUSH
3564: CALL_OW 137
// un := CreateHuman ;
3568: LD_ADDR_VAR 0 4
3572: PUSH
3573: CALL_OW 44
3577: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3578: LD_VAR 0 4
3582: PPUSH
3583: LD_INT 3
3585: PPUSH
3586: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3590: LD_VAR 0 4
3594: PPUSH
3595: LD_INT 30
3597: PPUSH
3598: LD_INT 39
3600: PPUSH
3601: LD_INT 0
3603: PPUSH
3604: CALL_OW 48
// ComCrawl ( un ) ;
3608: LD_VAR 0 4
3612: PPUSH
3613: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3617: LD_INT 0
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: LD_VAR 0 5
3627: PPUSH
3628: CALL_OW 380
// un := CreateHuman ;
3632: LD_ADDR_VAR 0 4
3636: PUSH
3637: CALL_OW 44
3641: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3642: LD_VAR 0 4
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3654: LD_VAR 0 4
3658: PPUSH
3659: LD_INT 45
3661: PPUSH
3662: LD_INT 86
3664: PPUSH
3665: LD_INT 0
3667: PPUSH
3668: CALL_OW 48
// ComHold ( un ) ;
3672: LD_VAR 0 4
3676: PPUSH
3677: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3681: LD_ADDR_EXP 42
3685: PUSH
3686: LD_EXP 42
3690: PPUSH
3691: LD_EXP 42
3695: PUSH
3696: LD_INT 1
3698: PLUS
3699: PPUSH
3700: LD_VAR 0 4
3704: PPUSH
3705: CALL_OW 1
3709: ST_TO_ADDR
// un := CreateHuman ;
3710: LD_ADDR_VAR 0 4
3714: PUSH
3715: CALL_OW 44
3719: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3720: LD_VAR 0 4
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3732: LD_VAR 0 4
3736: PPUSH
3737: LD_INT 60
3739: PPUSH
3740: LD_INT 85
3742: PPUSH
3743: LD_INT 0
3745: PPUSH
3746: CALL_OW 48
// ComHold ( un ) ;
3750: LD_VAR 0 4
3754: PPUSH
3755: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3759: LD_ADDR_EXP 42
3763: PUSH
3764: LD_EXP 42
3768: PPUSH
3769: LD_EXP 42
3773: PUSH
3774: LD_INT 1
3776: PLUS
3777: PPUSH
3778: LD_VAR 0 4
3782: PPUSH
3783: CALL_OW 1
3787: ST_TO_ADDR
// un := CreateHuman ;
3788: LD_ADDR_VAR 0 4
3792: PUSH
3793: CALL_OW 44
3797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3798: LD_VAR 0 4
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3810: LD_VAR 0 4
3814: PPUSH
3815: LD_INT 222
3817: PPUSH
3818: LD_INT 166
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 48
// ComHold ( un ) ;
3828: LD_VAR 0 4
3832: PPUSH
3833: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3837: LD_ADDR_EXP 42
3841: PUSH
3842: LD_EXP 42
3846: PPUSH
3847: LD_EXP 42
3851: PUSH
3852: LD_INT 1
3854: PLUS
3855: PPUSH
3856: LD_VAR 0 4
3860: PPUSH
3861: CALL_OW 1
3865: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3866: LD_ADDR_EXP 40
3870: PUSH
3871: EMPTY
3872: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3873: LD_INT 1
3875: PPUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_VAR 0 5
3883: PPUSH
3884: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3888: LD_ADDR_OWVAR 26
3892: PUSH
3893: LD_STRING Pavel Grigorovic
3895: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3896: LD_ADDR_OWVAR 33
3900: PUSH
3901: LD_STRING SecondCharsGal
3903: ST_TO_ADDR
// hc_face_number := 4 ;
3904: LD_ADDR_OWVAR 34
3908: PUSH
3909: LD_INT 4
3911: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3912: LD_ADDR_EXP 40
3916: PUSH
3917: LD_EXP 40
3921: PPUSH
3922: LD_INT 1
3924: PPUSH
3925: CALL_OW 44
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3935: LD_INT 2
3937: PPUSH
3938: LD_INT 4
3940: PPUSH
3941: LD_INT 2
3943: PPUSH
3944: CALL_OW 380
// hc_name := Lucy Sebel ;
3948: LD_ADDR_OWVAR 26
3952: PUSH
3953: LD_STRING Lucy Sebel
3955: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3956: LD_ADDR_OWVAR 33
3960: PUSH
3961: LD_STRING SecondCharsGal
3963: ST_TO_ADDR
// hc_face_number := 15 ;
3964: LD_ADDR_OWVAR 34
3968: PUSH
3969: LD_INT 15
3971: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3972: LD_ADDR_EXP 40
3976: PUSH
3977: LD_EXP 40
3981: PPUSH
3982: LD_INT 2
3984: PPUSH
3985: CALL_OW 44
3989: PPUSH
3990: CALL_OW 1
3994: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3995: LD_INT 2
3997: PPUSH
3998: LD_INT 4
4000: PPUSH
4001: LD_INT 2
4003: PPUSH
4004: CALL_OW 380
// hc_gallery :=  ;
4008: LD_ADDR_OWVAR 33
4012: PUSH
4013: LD_STRING 
4015: ST_TO_ADDR
// hc_name :=  ;
4016: LD_ADDR_OWVAR 26
4020: PUSH
4021: LD_STRING 
4023: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4024: LD_ADDR_EXP 40
4028: PUSH
4029: LD_EXP 40
4033: PPUSH
4034: LD_INT 3
4036: PPUSH
4037: CALL_OW 44
4041: PPUSH
4042: CALL_OW 1
4046: ST_TO_ADDR
// hc_sex := sex_male ;
4047: LD_ADDR_OWVAR 27
4051: PUSH
4052: LD_INT 1
4054: ST_TO_ADDR
// hc_class = 11 ;
4055: LD_ADDR_OWVAR 28
4059: PUSH
4060: LD_INT 11
4062: ST_TO_ADDR
// hc_gallery = sandar ;
4063: LD_ADDR_OWVAR 33
4067: PUSH
4068: LD_STRING sandar
4070: ST_TO_ADDR
// hc_face_number = 33 ;
4071: LD_ADDR_OWVAR 34
4075: PUSH
4076: LD_INT 33
4078: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4079: LD_ADDR_OWVAR 26
4083: PUSH
4084: LD_STRING Thabit Muhair Saliba
4086: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4087: LD_ADDR_OWVAR 31
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: LD_INT 0
4097: PUSH
4098: LD_INT 0
4100: PUSH
4101: LD_INT 0
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: ST_TO_ADDR
// Saliba = CreateHuman ;
4110: LD_ADDR_EXP 44
4114: PUSH
4115: CALL_OW 44
4119: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4120: LD_EXP 44
4124: PPUSH
4125: LD_INT 7
4127: PPUSH
4128: CALL_OW 52
// if gensher_active then
4132: LD_EXP 18
4136: IFFALSE 4163
// begin Gensher = NewCharacter ( Dietrich ) ;
4138: LD_ADDR_EXP 45
4142: PUSH
4143: LD_STRING Dietrich
4145: PPUSH
4146: CALL_OW 25
4150: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4151: LD_EXP 45
4155: PPUSH
4156: LD_INT 94
4158: PPUSH
4159: CALL_OW 52
// end ; InitHc ;
4163: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4167: LD_ADDR_EXP 41
4171: PUSH
4172: EMPTY
4173: ST_TO_ADDR
// for i = 1 to 5 do
4174: LD_ADDR_VAR 0 2
4178: PUSH
4179: DOUBLE
4180: LD_INT 1
4182: DEC
4183: ST_TO_ADDR
4184: LD_INT 5
4186: PUSH
4187: FOR_TO
4188: IFFALSE 4360
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4190: LD_INT 13
4192: PUSH
4193: LD_INT 14
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 2
4205: PPUSH
4206: CALL_OW 12
4210: ARRAY
4211: PPUSH
4212: LD_INT 1
4214: PUSH
4215: LD_INT 2
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 2
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: PPUSH
4234: LD_INT 1
4236: PPUSH
4237: LD_INT 25
4239: PUSH
4240: LD_INT 27
4242: PUSH
4243: LD_INT 26
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_INT 1
4253: PPUSH
4254: LD_INT 3
4256: PPUSH
4257: CALL_OW 12
4261: ARRAY
4262: PPUSH
4263: LD_INT 60
4265: PPUSH
4266: LD_INT 100
4268: PPUSH
4269: CALL_OW 12
4273: PPUSH
4274: CALL 53419 0 5
// un := CreateVehicle ;
4278: LD_ADDR_VAR 0 4
4282: PUSH
4283: CALL_OW 45
4287: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4288: LD_ADDR_EXP 41
4292: PUSH
4293: LD_EXP 41
4297: PPUSH
4298: LD_EXP 41
4302: PUSH
4303: LD_INT 1
4305: PLUS
4306: PPUSH
4307: LD_VAR 0 4
4311: PPUSH
4312: CALL_OW 1
4316: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4317: LD_VAR 0 4
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: LD_INT 5
4327: PPUSH
4328: CALL_OW 12
4332: PPUSH
4333: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4337: LD_VAR 0 4
4341: PPUSH
4342: LD_INT 124
4344: PPUSH
4345: LD_INT 141
4347: PPUSH
4348: LD_INT 8
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 50
// end ;
4358: GO 4187
4360: POP
4361: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4362: LD_ADDR_EXP 43
4366: PUSH
4367: EMPTY
4368: PUSH
4369: EMPTY
4370: PUSH
4371: EMPTY
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: LIST
4377: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: DOUBLE
4384: LD_INT 1
4386: DEC
4387: ST_TO_ADDR
4388: LD_INT 3
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: LD_INT 4
4396: PUSH
4397: LD_INT 4
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: LIST
4405: PUSH
4406: LD_OWVAR 67
4410: ARRAY
4411: PUSH
4412: FOR_TO
4413: IFFALSE 4627
// for i = 1 to 3 do
4415: LD_ADDR_VAR 0 2
4419: PUSH
4420: DOUBLE
4421: LD_INT 1
4423: DEC
4424: ST_TO_ADDR
4425: LD_INT 3
4427: PUSH
4428: FOR_TO
4429: IFFALSE 4623
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4431: LD_INT 14
4433: PPUSH
4434: LD_INT 3
4436: PUSH
4437: LD_INT 2
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 1
4446: PPUSH
4447: LD_INT 2
4449: PPUSH
4450: CALL_OW 12
4454: ARRAY
4455: PPUSH
4456: LD_INT 1
4458: PUSH
4459: LD_INT 5
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 2
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: LD_INT 25
4480: PUSH
4481: LD_INT 27
4483: PUSH
4484: LD_INT 26
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 1
4498: PPUSH
4499: LD_INT 4
4501: PPUSH
4502: CALL_OW 12
4506: ARRAY
4507: PPUSH
4508: LD_INT 100
4510: PPUSH
4511: CALL 53419 0 5
// un := CreateVehicle ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 45
4524: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4525: LD_ADDR_EXP 43
4529: PUSH
4530: LD_EXP 43
4534: PPUSH
4535: LD_VAR 0 2
4539: PUSH
4540: LD_EXP 43
4544: PUSH
4545: LD_VAR 0 2
4549: ARRAY
4550: PUSH
4551: LD_INT 1
4553: PLUS
4554: PUSH
4555: EMPTY
4556: LIST
4557: LIST
4558: PPUSH
4559: LD_VAR 0 4
4563: PPUSH
4564: CALL 53541 0 3
4568: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4569: LD_VAR 0 4
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: LD_INT 5
4579: PPUSH
4580: CALL_OW 12
4584: PPUSH
4585: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_INT 20
4596: PUSH
4597: LD_INT 21
4599: PUSH
4600: LD_INT 22
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: PUSH
4608: LD_VAR 0 2
4612: ARRAY
4613: PPUSH
4614: LD_INT 0
4616: PPUSH
4617: CALL_OW 49
// end ;
4621: GO 4428
4623: POP
4624: POP
4625: GO 4412
4627: POP
4628: POP
// InitHc ;
4629: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4633: LD_INT 4
4635: PPUSH
4636: LD_INT 5
4638: PPUSH
4639: LD_INT 10
4641: PPUSH
4642: LD_INT 5
4644: PPUSH
4645: LD_INT 0
4647: PPUSH
4648: CALL_OW 58
// end ;
4652: LD_VAR 0 1
4656: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4657: LD_EXP 42
4661: IFFALSE 4735
4663: GO 4665
4665: DISABLE
4666: LD_INT 0
4668: PPUSH
// begin enable ;
4669: ENABLE
// for i in ar_kamikadze do
4670: LD_ADDR_VAR 0 1
4674: PUSH
4675: LD_EXP 42
4679: PUSH
4680: FOR_IN
4681: IFFALSE 4733
// if See ( 1 , i ) then
4683: LD_INT 1
4685: PPUSH
4686: LD_VAR 0 1
4690: PPUSH
4691: CALL_OW 292
4695: IFFALSE 4731
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 81
4704: PUSH
4705: LD_INT 2
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PPUSH
4712: CALL_OW 69
4716: PPUSH
4717: LD_VAR 0 1
4721: PPUSH
4722: CALL_OW 74
4726: PPUSH
4727: CALL_OW 115
4731: GO 4680
4733: POP
4734: POP
// end ;
4735: PPOPN 1
4737: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4738: LD_EXP 13
4742: IFFALSE 5059
4744: GO 4746
4746: DISABLE
4747: LD_INT 0
4749: PPUSH
4750: PPUSH
4751: PPUSH
4752: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4753: LD_INT 35
4755: PPUSH
4756: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4760: LD_INT 1
4762: PPUSH
4763: CALL 42497 0 1
4767: PUSH
4768: LD_INT 0
4770: EQUAL
4771: IFFALSE 4753
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 14
4778: PUSH
4779: LD_INT 3
4781: PUSH
4782: LD_INT 2
4784: PUSH
4785: LD_INT 32
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: PPUSH
4797: CALL 42101 0 2
// repeat wait ( 0 0$1 ) ;
4801: LD_INT 35
4803: PPUSH
4804: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4808: LD_EXP 69
4812: PUSH
4813: LD_INT 1
4815: ARRAY
4816: PPUSH
4817: LD_INT 33
4819: PUSH
4820: LD_INT 2
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: LD_INT 34
4829: PUSH
4830: LD_INT 32
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PPUSH
4841: CALL_OW 72
4845: IFFALSE 4801
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4847: LD_ADDR_VAR 0 2
4851: PUSH
4852: LD_EXP 69
4856: PUSH
4857: LD_INT 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 33
4863: PUSH
4864: LD_INT 2
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PUSH
4871: LD_INT 34
4873: PUSH
4874: LD_INT 32
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PPUSH
4885: CALL_OW 72
4889: PUSH
4890: LD_INT 1
4892: ARRAY
4893: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4894: LD_ADDR_VAR 0 4
4898: PUSH
4899: LD_INT 5
4901: PPUSH
4902: CALL_OW 469
4906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4907: LD_INT 35
4909: PPUSH
4910: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4914: LD_ADDR_VAR 0 4
4918: PUSH
4919: LD_INT 5
4921: PPUSH
4922: CALL_OW 469
4926: ST_TO_ADDR
// tmp := 100 ;
4927: LD_ADDR_VAR 0 3
4931: PUSH
4932: LD_INT 100
4934: ST_TO_ADDR
// if pos then
4935: LD_VAR 0 4
4939: IFFALSE 4979
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_INT 2
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 1
4956: ARRAY
4957: PPUSH
4958: LD_VAR 0 4
4962: PUSH
4963: LD_INT 2
4965: ARRAY
4966: PPUSH
4967: LD_INT 20
4969: PPUSH
4970: CALL 54437 0 4
4974: PUSH
4975: LD_INT 4
4977: ARRAY
4978: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4979: LD_VAR 0 4
4983: PUSH
4984: LD_EXP 14
4988: NOT
4989: AND
4990: PUSH
4991: LD_VAR 0 3
4995: PUSH
4996: LD_INT 10
4998: LESS
4999: AND
5000: IFFALSE 4907
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5002: LD_VAR 0 2
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 1
5014: ARRAY
5015: PPUSH
5016: LD_VAR 0 4
5020: PUSH
5021: LD_INT 2
5023: ARRAY
5024: PPUSH
5025: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5029: LD_VAR 0 2
5033: PPUSH
5034: LD_INT 198
5036: PPUSH
5037: LD_INT 113
5039: PPUSH
5040: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5044: LD_VAR 0 2
5048: PPUSH
5049: LD_INT 124
5051: PPUSH
5052: LD_INT 7
5054: PPUSH
5055: CALL_OW 171
// end ;
5059: PPOPN 4
5061: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5062: LD_EXP 6
5066: IFFALSE 7935
5068: GO 5070
5070: DISABLE
5071: LD_INT 0
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
5079: PPUSH
5080: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5081: LD_ADDR_VAR 0 4
5085: PUSH
5086: LD_INT 5
5088: PUSH
5089: LD_INT 6
5091: PUSH
5092: LD_INT 7
5094: PUSH
5095: LD_INT 8
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PUSH
5104: LD_OWVAR 67
5108: ARRAY
5109: ST_TO_ADDR
// coords := [ ] ;
5110: LD_ADDR_VAR 0 5
5114: PUSH
5115: EMPTY
5116: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5117: LD_ADDR_VAR 0 6
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 0
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 1
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 0
5145: PUSH
5146: LD_INT 1
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5164: LD_INT 1
5166: PPUSH
5167: LD_INT 14
5169: PUSH
5170: LD_INT 1
5172: PUSH
5173: LD_INT 2
5175: PUSH
5176: LD_INT 28
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 14
5187: PUSH
5188: LD_INT 1
5190: PUSH
5191: LD_INT 2
5193: PUSH
5194: LD_INT 25
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: LD_INT 14
5205: PUSH
5206: LD_INT 1
5208: PUSH
5209: LD_INT 2
5211: PUSH
5212: LD_INT 28
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: PUSH
5221: LD_INT 14
5223: PUSH
5224: LD_INT 1
5226: PUSH
5227: LD_INT 2
5229: PUSH
5230: LD_INT 29
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: CALL 42101 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5249: LD_INT 21000
5251: PUSH
5252: LD_INT 19950
5254: PUSH
5255: LD_INT 18900
5257: PUSH
5258: LD_INT 18200
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: PUSH
5267: LD_OWVAR 67
5271: ARRAY
5272: PPUSH
5273: CALL_OW 67
// InitHc ;
5277: CALL_OW 19
// InitUc ;
5281: CALL_OW 18
// uc_side := 2 ;
5285: LD_ADDR_OWVAR 20
5289: PUSH
5290: LD_INT 2
5292: ST_TO_ADDR
// uc_nation := 2 ;
5293: LD_ADDR_OWVAR 21
5297: PUSH
5298: LD_INT 2
5300: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5301: LD_ADDR_VAR 0 3
5305: PUSH
5306: EMPTY
5307: PUSH
5308: EMPTY
5309: PUSH
5310: EMPTY
5311: PUSH
5312: EMPTY
5313: PUSH
5314: EMPTY
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5323: LD_ADDR_VAR 0 3
5327: PUSH
5328: LD_VAR 0 3
5332: PPUSH
5333: LD_INT 1
5335: PPUSH
5336: LD_EXP 69
5340: PUSH
5341: LD_INT 1
5343: ARRAY
5344: PUSH
5345: LD_INT 2
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_EXP 100
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 34
5362: PUSH
5363: LD_INT 32
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: PPUSH
5375: CALL_OW 69
5379: DIFF
5380: PPUSH
5381: CALL_OW 1
5385: ST_TO_ADDR
// for i = 1 to Difficulty do
5386: LD_ADDR_VAR 0 1
5390: PUSH
5391: DOUBLE
5392: LD_INT 1
5394: DEC
5395: ST_TO_ADDR
5396: LD_OWVAR 67
5400: PUSH
5401: FOR_TO
5402: IFFALSE 5540
// begin uc_side := 2 ;
5404: LD_ADDR_OWVAR 20
5408: PUSH
5409: LD_INT 2
5411: ST_TO_ADDR
// uc_nation := 2 ;
5412: LD_ADDR_OWVAR 21
5416: PUSH
5417: LD_INT 2
5419: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5420: LD_INT 13
5422: PPUSH
5423: LD_INT 3
5425: PPUSH
5426: LD_INT 5
5428: PPUSH
5429: LD_INT 29
5431: PPUSH
5432: LD_INT 100
5434: PPUSH
5435: CALL 53419 0 5
// un := CreateVehicle ;
5439: LD_ADDR_VAR 0 2
5443: PUSH
5444: CALL_OW 45
5448: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5449: LD_ADDR_VAR 0 3
5453: PUSH
5454: LD_VAR 0 3
5458: PPUSH
5459: LD_INT 1
5461: PUSH
5462: LD_VAR 0 3
5466: PUSH
5467: LD_INT 1
5469: ARRAY
5470: PUSH
5471: LD_INT 1
5473: PLUS
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: LD_VAR 0 2
5483: PPUSH
5484: CALL 53541 0 3
5488: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 3
5496: PPUSH
5497: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5501: LD_VAR 0 2
5505: PPUSH
5506: LD_INT 16
5508: PPUSH
5509: LD_INT 0
5511: PPUSH
5512: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5516: LD_VAR 0 2
5520: PPUSH
5521: LD_INT 51
5523: PPUSH
5524: LD_INT 10
5526: PPUSH
5527: CALL_OW 111
// wait ( 0 0$2 ) ;
5531: LD_INT 70
5533: PPUSH
5534: CALL_OW 67
// end ;
5538: GO 5401
5540: POP
5541: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5542: LD_ADDR_VAR 0 5
5546: PUSH
5547: LD_INT 51
5549: PUSH
5550: LD_INT 24
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 75
5559: PUSH
5560: LD_INT 90
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5571: LD_INT 1
5573: PPUSH
5574: LD_VAR 0 3
5578: PUSH
5579: LD_INT 1
5581: ARRAY
5582: PPUSH
5583: LD_VAR 0 5
5587: PPUSH
5588: LD_VAR 0 6
5592: PPUSH
5593: CALL 42334 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5597: LD_ADDR_VAR 0 1
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_INT 1
5609: PUSH
5610: LD_INT 3
5612: PUSH
5613: LD_INT 3
5615: PUSH
5616: LD_INT 3
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_OWVAR 67
5629: ARRAY
5630: PUSH
5631: FOR_TO
5632: IFFALSE 5732
// begin uc_side := 2 ;
5634: LD_ADDR_OWVAR 20
5638: PUSH
5639: LD_INT 2
5641: ST_TO_ADDR
// uc_nation := 2 ;
5642: LD_ADDR_OWVAR 21
5646: PUSH
5647: LD_INT 2
5649: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5650: LD_INT 0
5652: PPUSH
5653: LD_INT 17
5655: PPUSH
5656: LD_VAR 0 4
5660: PPUSH
5661: CALL_OW 380
// un := CreateHuman ;
5665: LD_ADDR_VAR 0 2
5669: PUSH
5670: CALL_OW 44
5674: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5675: LD_ADDR_VAR 0 3
5679: PUSH
5680: LD_VAR 0 3
5684: PPUSH
5685: LD_INT 2
5687: PUSH
5688: LD_VAR 0 3
5692: PUSH
5693: LD_INT 2
5695: ARRAY
5696: PUSH
5697: LD_INT 1
5699: PLUS
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: LD_VAR 0 2
5709: PPUSH
5710: CALL 53541 0 3
5714: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5715: LD_VAR 0 2
5719: PPUSH
5720: LD_INT 13
5722: PPUSH
5723: LD_INT 0
5725: PPUSH
5726: CALL_OW 49
// end ;
5730: GO 5631
5732: POP
5733: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: DOUBLE
5740: LD_INT 1
5742: DEC
5743: ST_TO_ADDR
5744: LD_INT 3
5746: PUSH
5747: LD_INT 4
5749: PUSH
5750: LD_INT 4
5752: PUSH
5753: LD_INT 4
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_OWVAR 67
5766: ARRAY
5767: PUSH
5768: FOR_TO
5769: IFFALSE 5890
// begin uc_side := 2 ;
5771: LD_ADDR_OWVAR 20
5775: PUSH
5776: LD_INT 2
5778: ST_TO_ADDR
// uc_nation := 2 ;
5779: LD_ADDR_OWVAR 21
5783: PUSH
5784: LD_INT 2
5786: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5787: LD_INT 0
5789: PPUSH
5790: LD_INT 1
5792: PUSH
5793: LD_INT 8
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: LD_VAR 0 1
5804: PUSH
5805: LD_INT 2
5807: MOD
5808: PUSH
5809: LD_INT 1
5811: PLUS
5812: ARRAY
5813: PPUSH
5814: LD_VAR 0 4
5818: PPUSH
5819: CALL_OW 380
// un := CreateHuman ;
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: CALL_OW 44
5832: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5833: LD_ADDR_VAR 0 3
5837: PUSH
5838: LD_VAR 0 3
5842: PPUSH
5843: LD_INT 2
5845: PUSH
5846: LD_VAR 0 3
5850: PUSH
5851: LD_INT 2
5853: ARRAY
5854: PUSH
5855: LD_INT 1
5857: PLUS
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: LD_VAR 0 2
5867: PPUSH
5868: CALL 53541 0 3
5872: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5873: LD_VAR 0 2
5877: PPUSH
5878: LD_INT 13
5880: PPUSH
5881: LD_INT 0
5883: PPUSH
5884: CALL_OW 49
// end ;
5888: GO 5768
5890: POP
5891: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5892: LD_ADDR_VAR 0 5
5896: PUSH
5897: LD_INT 67
5899: PUSH
5900: LD_INT 112
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 85
5909: PUSH
5910: LD_INT 130
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5921: LD_INT 2
5923: PPUSH
5924: LD_VAR 0 3
5928: PUSH
5929: LD_INT 2
5931: ARRAY
5932: PPUSH
5933: LD_VAR 0 5
5937: PPUSH
5938: LD_VAR 0 6
5942: PPUSH
5943: CALL 42334 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5947: LD_ADDR_VAR 0 1
5951: PUSH
5952: DOUBLE
5953: LD_INT 1
5955: DEC
5956: ST_TO_ADDR
5957: LD_INT 1
5959: PUSH
5960: LD_INT 2
5962: PUSH
5963: LD_INT 3
5965: PUSH
5966: LD_INT 4
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: LD_OWVAR 67
5979: ARRAY
5980: PUSH
5981: FOR_TO
5982: IFFALSE 6082
// begin uc_side := 2 ;
5984: LD_ADDR_OWVAR 20
5988: PUSH
5989: LD_INT 2
5991: ST_TO_ADDR
// uc_nation := 2 ;
5992: LD_ADDR_OWVAR 21
5996: PUSH
5997: LD_INT 2
5999: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6000: LD_INT 0
6002: PPUSH
6003: LD_INT 17
6005: PPUSH
6006: LD_VAR 0 4
6010: PPUSH
6011: CALL_OW 380
// un := CreateHuman ;
6015: LD_ADDR_VAR 0 2
6019: PUSH
6020: CALL_OW 44
6024: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6025: LD_ADDR_VAR 0 3
6029: PUSH
6030: LD_VAR 0 3
6034: PPUSH
6035: LD_INT 3
6037: PUSH
6038: LD_VAR 0 3
6042: PUSH
6043: LD_INT 3
6045: ARRAY
6046: PUSH
6047: LD_INT 1
6049: PLUS
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: PPUSH
6055: LD_VAR 0 2
6059: PPUSH
6060: CALL 53541 0 3
6064: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6065: LD_VAR 0 2
6069: PPUSH
6070: LD_INT 14
6072: PPUSH
6073: LD_INT 0
6075: PPUSH
6076: CALL_OW 49
// end ;
6080: GO 5981
6082: POP
6083: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 148
6091: PUSH
6092: LD_INT 158
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: LD_INT 148
6101: PUSH
6102: LD_INT 158
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6113: LD_INT 3
6115: PPUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_INT 3
6123: ARRAY
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: LD_VAR 0 6
6134: PPUSH
6135: CALL 42334 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6139: LD_ADDR_VAR 0 1
6143: PUSH
6144: DOUBLE
6145: LD_INT 1
6147: DEC
6148: ST_TO_ADDR
6149: LD_INT 2
6151: PUSH
6152: LD_INT 3
6154: PUSH
6155: LD_INT 4
6157: PUSH
6158: LD_INT 4
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: LD_OWVAR 67
6171: ARRAY
6172: PUSH
6173: FOR_TO
6174: IFFALSE 6398
// begin uc_side := 2 ;
6176: LD_ADDR_OWVAR 20
6180: PUSH
6181: LD_INT 2
6183: ST_TO_ADDR
// uc_nation := 2 ;
6184: LD_ADDR_OWVAR 21
6188: PUSH
6189: LD_INT 2
6191: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6192: LD_INT 14
6194: PPUSH
6195: LD_INT 3
6197: PPUSH
6198: LD_INT 1
6200: PUSH
6201: LD_INT 5
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 1
6210: PPUSH
6211: LD_INT 2
6213: PPUSH
6214: CALL_OW 12
6218: ARRAY
6219: PPUSH
6220: LD_INT 27
6222: PUSH
6223: LD_INT 26
6225: PUSH
6226: LD_INT 28
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 1
6236: PPUSH
6237: LD_INT 3
6239: PPUSH
6240: CALL_OW 12
6244: ARRAY
6245: PPUSH
6246: LD_INT 100
6248: PPUSH
6249: CALL 53419 0 5
// un := CreateVehicle ;
6253: LD_ADDR_VAR 0 2
6257: PUSH
6258: CALL_OW 45
6262: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6263: LD_ADDR_VAR 0 3
6267: PUSH
6268: LD_VAR 0 3
6272: PPUSH
6273: LD_INT 4
6275: PUSH
6276: LD_VAR 0 3
6280: PUSH
6281: LD_INT 4
6283: ARRAY
6284: PUSH
6285: LD_INT 1
6287: PLUS
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PPUSH
6293: LD_VAR 0 2
6297: PPUSH
6298: CALL 53541 0 3
6302: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 5
6310: PPUSH
6311: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6315: LD_VAR 0 2
6319: PPUSH
6320: LD_INT 15
6322: PPUSH
6323: LD_INT 0
6325: PPUSH
6326: CALL_OW 49
// if GetControl ( un ) = control_manual then
6330: LD_VAR 0 2
6334: PPUSH
6335: CALL_OW 263
6339: PUSH
6340: LD_INT 1
6342: EQUAL
6343: IFFALSE 6374
// begin PrepareHuman ( false , 3 , skill ) ;
6345: LD_INT 0
6347: PPUSH
6348: LD_INT 3
6350: PPUSH
6351: LD_VAR 0 4
6355: PPUSH
6356: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6360: CALL_OW 44
6364: PPUSH
6365: LD_VAR 0 2
6369: PPUSH
6370: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6374: LD_VAR 0 2
6378: PPUSH
6379: LD_INT 179
6381: PPUSH
6382: LD_INT 135
6384: PPUSH
6385: CALL_OW 111
// wait ( 0 0$2 ) ;
6389: LD_INT 70
6391: PPUSH
6392: CALL_OW 67
// end ;
6396: GO 6173
6398: POP
6399: POP
// vc_chassis := 15 ;
6400: LD_ADDR_OWVAR 37
6404: PUSH
6405: LD_INT 15
6407: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: LD_VAR 0 3
6417: PPUSH
6418: LD_INT 4
6420: PUSH
6421: LD_VAR 0 3
6425: PUSH
6426: LD_INT 4
6428: ARRAY
6429: PUSH
6430: LD_INT 1
6432: PLUS
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PPUSH
6438: CALL_OW 45
6442: PPUSH
6443: CALL 53541 0 3
6447: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6448: LD_VAR 0 3
6452: PUSH
6453: LD_INT 4
6455: ARRAY
6456: PUSH
6457: LD_VAR 0 3
6461: PUSH
6462: LD_INT 4
6464: ARRAY
6465: ARRAY
6466: PPUSH
6467: LD_INT 15
6469: PPUSH
6470: LD_INT 0
6472: PPUSH
6473: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6477: LD_INT 0
6479: PPUSH
6480: LD_INT 11
6482: PPUSH
6483: LD_VAR 0 4
6487: PPUSH
6488: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6492: LD_ADDR_VAR 0 3
6496: PUSH
6497: LD_VAR 0 3
6501: PPUSH
6502: LD_INT 4
6504: PUSH
6505: LD_VAR 0 3
6509: PUSH
6510: LD_INT 4
6512: ARRAY
6513: PUSH
6514: LD_INT 1
6516: PLUS
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PPUSH
6522: CALL_OW 44
6526: PPUSH
6527: CALL 53541 0 3
6531: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6532: LD_VAR 0 3
6536: PUSH
6537: LD_INT 4
6539: ARRAY
6540: PUSH
6541: LD_VAR 0 3
6545: PUSH
6546: LD_INT 4
6548: ARRAY
6549: ARRAY
6550: PPUSH
6551: LD_VAR 0 3
6555: PUSH
6556: LD_INT 4
6558: ARRAY
6559: PUSH
6560: LD_VAR 0 3
6564: PUSH
6565: LD_INT 4
6567: ARRAY
6568: PUSH
6569: LD_INT 1
6571: MINUS
6572: ARRAY
6573: PPUSH
6574: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6578: LD_ADDR_VAR 0 5
6582: PUSH
6583: LD_INT 148
6585: PUSH
6586: LD_INT 140
6588: PUSH
6589: EMPTY
6590: LIST
6591: LIST
6592: PUSH
6593: EMPTY
6594: LIST
6595: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6596: LD_INT 1
6598: PPUSH
6599: LD_VAR 0 3
6603: PUSH
6604: LD_INT 4
6606: ARRAY
6607: PPUSH
6608: LD_VAR 0 5
6612: PPUSH
6613: LD_VAR 0 6
6617: PPUSH
6618: CALL 42334 0 4
// if gensher_active then
6622: LD_EXP 18
6626: IFFALSE 7032
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6628: LD_EXP 45
6632: PPUSH
6633: LD_STRING D10-Diet-1
6635: PPUSH
6636: CALL_OW 94
// for i = 1 to 2 do
6640: LD_ADDR_VAR 0 1
6644: PUSH
6645: DOUBLE
6646: LD_INT 1
6648: DEC
6649: ST_TO_ADDR
6650: LD_INT 2
6652: PUSH
6653: FOR_TO
6654: IFFALSE 6792
// begin uc_side := 2 ;
6656: LD_ADDR_OWVAR 20
6660: PUSH
6661: LD_INT 2
6663: ST_TO_ADDR
// uc_nation := 2 ;
6664: LD_ADDR_OWVAR 21
6668: PUSH
6669: LD_INT 2
6671: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6672: LD_INT 13
6674: PPUSH
6675: LD_INT 3
6677: PPUSH
6678: LD_INT 5
6680: PPUSH
6681: LD_INT 29
6683: PPUSH
6684: LD_INT 100
6686: PPUSH
6687: CALL 53419 0 5
// un := CreateVehicle ;
6691: LD_ADDR_VAR 0 2
6695: PUSH
6696: CALL_OW 45
6700: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6701: LD_ADDR_VAR 0 3
6705: PUSH
6706: LD_VAR 0 3
6710: PPUSH
6711: LD_INT 5
6713: PUSH
6714: LD_VAR 0 3
6718: PUSH
6719: LD_INT 5
6721: ARRAY
6722: PUSH
6723: LD_INT 1
6725: PLUS
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PPUSH
6731: LD_VAR 0 2
6735: PPUSH
6736: CALL 53541 0 3
6740: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 0
6748: PPUSH
6749: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6753: LD_VAR 0 2
6757: PPUSH
6758: LD_INT 23
6760: PPUSH
6761: LD_INT 0
6763: PPUSH
6764: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6768: LD_VAR 0 2
6772: PPUSH
6773: LD_INT 85
6775: PPUSH
6776: LD_INT 152
6778: PPUSH
6779: CALL_OW 111
// wait ( 0 0$2 ) ;
6783: LD_INT 70
6785: PPUSH
6786: CALL_OW 67
// end ;
6790: GO 6653
6792: POP
6793: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6794: LD_ADDR_VAR 0 1
6798: PUSH
6799: DOUBLE
6800: LD_INT 1
6802: DEC
6803: ST_TO_ADDR
6804: LD_INT 2
6806: PUSH
6807: LD_INT 3
6809: PUSH
6810: LD_INT 3
6812: PUSH
6813: LD_INT 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: PUSH
6822: LD_OWVAR 67
6826: ARRAY
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6986
// begin uc_side := 2 ;
6831: LD_ADDR_OWVAR 20
6835: PUSH
6836: LD_INT 2
6838: ST_TO_ADDR
// uc_nation := 2 ;
6839: LD_ADDR_OWVAR 21
6843: PUSH
6844: LD_INT 2
6846: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6847: LD_INT 14
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 5
6855: PPUSH
6856: LD_INT 27
6858: PUSH
6859: LD_INT 28
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: LD_INT 1
6868: PPUSH
6869: LD_INT 2
6871: PPUSH
6872: CALL_OW 12
6876: ARRAY
6877: PPUSH
6878: LD_INT 100
6880: PPUSH
6881: CALL 53419 0 5
// un := CreateVehicle ;
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: CALL_OW 45
6894: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6895: LD_ADDR_VAR 0 3
6899: PUSH
6900: LD_VAR 0 3
6904: PPUSH
6905: LD_INT 5
6907: PUSH
6908: LD_VAR 0 3
6912: PUSH
6913: LD_INT 5
6915: ARRAY
6916: PUSH
6917: LD_INT 1
6919: PLUS
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: LD_VAR 0 2
6929: PPUSH
6930: CALL 53541 0 3
6934: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 0
6942: PPUSH
6943: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6947: LD_VAR 0 2
6951: PPUSH
6952: LD_INT 23
6954: PPUSH
6955: LD_INT 0
6957: PPUSH
6958: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6962: LD_VAR 0 2
6966: PPUSH
6967: LD_INT 85
6969: PPUSH
6970: LD_INT 152
6972: PPUSH
6973: CALL_OW 111
// wait ( 0 0$2 ) ;
6977: LD_INT 70
6979: PPUSH
6980: CALL_OW 67
// end ;
6984: GO 6828
6986: POP
6987: POP
// coords := [ [ 97 , 143 ] ] ;
6988: LD_ADDR_VAR 0 5
6992: PUSH
6993: LD_INT 97
6995: PUSH
6996: LD_INT 143
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7006: LD_INT 1
7008: PPUSH
7009: LD_VAR 0 3
7013: PUSH
7014: LD_INT 5
7016: ARRAY
7017: PPUSH
7018: LD_VAR 0 5
7022: PPUSH
7023: LD_VAR 0 6
7027: PPUSH
7028: CALL 42334 0 4
// end ; Wait ( 13 13$00 ) ;
7032: LD_INT 27300
7034: PPUSH
7035: CALL_OW 67
// tmp := [ ] ;
7039: LD_ADDR_VAR 0 3
7043: PUSH
7044: EMPTY
7045: ST_TO_ADDR
// w := 1 ;
7046: LD_ADDR_VAR 0 7
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// repeat tmp := [ ] ;
7054: LD_ADDR_VAR 0 3
7058: PUSH
7059: EMPTY
7060: ST_TO_ADDR
// if w mod 4 = 0 then
7061: LD_VAR 0 7
7065: PUSH
7066: LD_INT 4
7068: MOD
7069: PUSH
7070: LD_INT 0
7072: EQUAL
7073: IFFALSE 7160
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7075: LD_ADDR_VAR 0 8
7079: PUSH
7080: LD_INT 11
7082: PUSH
7083: LD_INT 1
7085: PUSH
7086: LD_INT 2
7088: PUSH
7089: LD_INT 24
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 11
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 24
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: PUSH
7116: LD_INT 11
7118: PUSH
7119: LD_INT 1
7121: PUSH
7122: LD_INT 2
7124: PUSH
7125: LD_INT 24
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 11
7136: PUSH
7137: LD_INT 1
7139: PUSH
7140: LD_INT 2
7142: PUSH
7143: LD_INT 24
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: LIST
7156: LIST
7157: ST_TO_ADDR
7158: GO 7262
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7160: LD_ADDR_VAR 0 8
7164: PUSH
7165: LD_INT 14
7167: PUSH
7168: LD_INT 1
7170: PUSH
7171: LD_INT 2
7173: PUSH
7174: LD_INT 28
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: PUSH
7183: LD_INT 14
7185: PUSH
7186: LD_INT 1
7188: PUSH
7189: LD_INT 2
7191: PUSH
7192: LD_INT 25
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 14
7203: PUSH
7204: LD_INT 1
7206: PUSH
7207: LD_INT 2
7209: PUSH
7210: LD_INT 28
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 14
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: LD_INT 2
7227: PUSH
7228: LD_INT 29
7230: PUSH
7231: EMPTY
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 11
7239: PUSH
7240: LD_INT 1
7242: PUSH
7243: LD_INT 2
7245: PUSH
7246: LD_INT 24
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: LIST
7253: LIST
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: ST_TO_ADDR
// if w mod 3 = 0 then
7262: LD_VAR 0 7
7266: PUSH
7267: LD_INT 3
7269: MOD
7270: PUSH
7271: LD_INT 0
7273: EQUAL
7274: IFFALSE 7350
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7276: LD_ADDR_VAR 0 8
7280: PUSH
7281: LD_VAR 0 8
7285: PPUSH
7286: LD_INT 1
7288: PUSH
7289: LD_VAR 0 8
7293: PUSH
7294: LD_VAR 0 1
7298: ARRAY
7299: PUSH
7300: LD_INT 1
7302: PLUS
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 14
7310: PUSH
7311: LD_INT 1
7313: PUSH
7314: LD_INT 2
7316: PUSH
7317: LD_INT 25
7319: PUSH
7320: LD_INT 28
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PUSH
7327: LD_INT 1
7329: PPUSH
7330: LD_INT 2
7332: PPUSH
7333: CALL_OW 12
7337: ARRAY
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL 53541 0 3
7349: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7350: LD_INT 1
7352: PPUSH
7353: LD_VAR 0 8
7357: PPUSH
7358: CALL 42101 0 2
// if GetSide ( ar_dep_w ) = 2 then
7362: LD_INT 45
7364: PPUSH
7365: CALL_OW 255
7369: PUSH
7370: LD_INT 2
7372: EQUAL
7373: IFFALSE 7458
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7375: LD_ADDR_VAR 0 8
7379: PUSH
7380: LD_INT 14
7382: PUSH
7383: LD_INT 1
7385: PUSH
7386: LD_INT 2
7388: PUSH
7389: LD_INT 28
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 14
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: LD_INT 2
7406: PUSH
7407: LD_INT 27
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 14
7418: PUSH
7419: LD_INT 1
7421: PUSH
7422: LD_INT 2
7424: PUSH
7425: LD_INT 27
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: LIST
7438: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7439: LD_INT 2
7441: PPUSH
7442: LD_VAR 0 8
7446: PPUSH
7447: CALL 42101 0 2
// wait ( 0 0$50 ) ;
7451: LD_INT 1750
7453: PPUSH
7454: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7458: LD_INT 35
7460: PPUSH
7461: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7465: LD_EXP 69
7469: PUSH
7470: LD_INT 1
7472: ARRAY
7473: PPUSH
7474: LD_INT 3
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 34
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 34
7492: PUSH
7493: LD_EXP 100
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: EMPTY
7508: LIST
7509: LIST
7510: PPUSH
7511: CALL_OW 72
7515: PUSH
7516: LD_INT 4
7518: GREATEREQUAL
7519: IFFALSE 7458
// wait ( 0 0$10 ) ;
7521: LD_INT 350
7523: PPUSH
7524: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: LD_EXP 69
7537: PUSH
7538: LD_INT 1
7540: ARRAY
7541: PPUSH
7542: LD_INT 3
7544: PUSH
7545: LD_INT 2
7547: PUSH
7548: LD_INT 34
7550: PUSH
7551: LD_INT 32
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 34
7560: PUSH
7561: LD_EXP 100
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PPUSH
7579: CALL_OW 72
7583: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7584: LD_INT 100
7586: PPUSH
7587: CALL_OW 13
7591: PUSH
7592: LD_INT 50
7594: LESS
7595: IFFALSE 7628
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7597: LD_ADDR_VAR 0 5
7601: PUSH
7602: LD_INT 55
7604: PUSH
7605: LD_INT 7
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 75
7614: PUSH
7615: LD_INT 90
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: ST_TO_ADDR
7626: GO 7657
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7628: LD_ADDR_VAR 0 5
7632: PUSH
7633: LD_INT 128
7635: PUSH
7636: LD_INT 94
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 180
7645: PUSH
7646: LD_INT 135
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: ST_TO_ADDR
// if w mod 4 = 0 then
7657: LD_VAR 0 7
7661: PUSH
7662: LD_INT 4
7664: MOD
7665: PUSH
7666: LD_INT 0
7668: EQUAL
7669: IFFALSE 7700
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7671: LD_ADDR_VAR 0 5
7675: PUSH
7676: LD_INT 91
7678: PUSH
7679: LD_INT 58
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 117
7688: PUSH
7689: LD_INT 107
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_VAR 0 5
7709: PUSH
7710: LD_INT 1
7712: ARRAY
7713: PPUSH
7714: LD_VAR 0 5
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7734: LD_VAR 0 3
7738: PPUSH
7739: LD_INT 60
7741: PUSH
7742: EMPTY
7743: LIST
7744: PPUSH
7745: CALL_OW 72
7749: PUSH
7750: LD_INT 0
7752: EQUAL
7753: IFFALSE 7727
// repeat wait ( 0 0$2 ) ;
7755: LD_INT 70
7757: PPUSH
7758: CALL_OW 67
// for i in tmp do
7762: LD_ADDR_VAR 0 1
7766: PUSH
7767: LD_VAR 0 3
7771: PUSH
7772: FOR_IN
7773: IFFALSE 7862
// if GetChassis ( i ) = ar_hovercraft then
7775: LD_VAR 0 1
7779: PPUSH
7780: CALL_OW 265
7784: PUSH
7785: LD_INT 11
7787: EQUAL
7788: IFFALSE 7826
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7790: LD_VAR 0 1
7794: PPUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 1
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 69
7809: PPUSH
7810: LD_VAR 0 1
7814: PPUSH
7815: CALL_OW 74
7819: PPUSH
7820: CALL 81437 0 2
7824: GO 7860
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7826: LD_VAR 0 1
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: PPUSH
7846: LD_VAR 0 1
7850: PPUSH
7851: CALL_OW 74
7855: PPUSH
7856: CALL_OW 115
7860: GO 7772
7862: POP
7863: POP
// until not tmp ;
7864: LD_VAR 0 3
7868: NOT
7869: IFFALSE 7755
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7871: LD_INT 22050
7873: PPUSH
7874: LD_INT 28350
7876: PPUSH
7877: CALL_OW 12
7881: PPUSH
7882: CALL_OW 67
// w := w + 1 ;
7886: LD_ADDR_VAR 0 7
7890: PUSH
7891: LD_VAR 0 7
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7900: LD_INT 94
7902: PPUSH
7903: CALL_OW 301
7907: PUSH
7908: LD_EXP 50
7912: PUSH
7913: LD_INT 1
7915: ARRAY
7916: PPUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PPUSH
7927: CALL_OW 72
7931: NOT
7932: OR
7933: IFFALSE 7054
// end ;
7935: PPOPN 8
7937: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7938: LD_INT 204
7940: IFFALSE 8406
7942: GO 7944
7944: DISABLE
7945: LD_INT 0
7947: PPUSH
7948: PPUSH
7949: PPUSH
7950: PPUSH
// begin enable ;
7951: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7952: LD_INT 35
7954: PPUSH
7955: LD_INT 1190
7957: PPUSH
7958: CALL_OW 12
7962: PPUSH
7963: CALL_OW 67
// tmp := [ ] ;
7967: LD_ADDR_VAR 0 2
7971: PUSH
7972: EMPTY
7973: ST_TO_ADDR
// uc_side := 8 ;
7974: LD_ADDR_OWVAR 20
7978: PUSH
7979: LD_INT 8
7981: ST_TO_ADDR
// uc_nation := 2 ;
7982: LD_ADDR_OWVAR 21
7986: PUSH
7987: LD_INT 2
7989: ST_TO_ADDR
// InitHc ;
7990: CALL_OW 19
// for i = 1 to 3 do
7994: LD_ADDR_VAR 0 1
7998: PUSH
7999: DOUBLE
8000: LD_INT 1
8002: DEC
8003: ST_TO_ADDR
8004: LD_INT 3
8006: PUSH
8007: FOR_TO
8008: IFFALSE 8135
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8010: LD_INT 13
8012: PUSH
8013: LD_INT 14
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PUSH
8020: LD_INT 1
8022: PPUSH
8023: LD_INT 2
8025: PPUSH
8026: CALL_OW 12
8030: ARRAY
8031: PPUSH
8032: LD_INT 3
8034: PPUSH
8035: LD_INT 5
8037: PPUSH
8038: LD_INT 27
8040: PUSH
8041: LD_INT 28
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 1
8050: PPUSH
8051: LD_INT 2
8053: PPUSH
8054: CALL_OW 12
8058: ARRAY
8059: PPUSH
8060: LD_INT 100
8062: PPUSH
8063: CALL 53419 0 5
// un := CreateVehicle ;
8067: LD_ADDR_VAR 0 3
8071: PUSH
8072: CALL_OW 45
8076: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8077: LD_VAR 0 3
8081: PPUSH
8082: LD_INT 4
8084: PPUSH
8085: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8089: LD_VAR 0 3
8093: PPUSH
8094: LD_INT 15
8096: PPUSH
8097: LD_INT 0
8099: PPUSH
8100: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8104: LD_ADDR_VAR 0 2
8108: PUSH
8109: LD_VAR 0 2
8113: PPUSH
8114: LD_VAR 0 2
8118: PUSH
8119: LD_INT 1
8121: PLUS
8122: PPUSH
8123: LD_VAR 0 3
8127: PPUSH
8128: CALL_OW 1
8132: ST_TO_ADDR
// end ;
8133: GO 8007
8135: POP
8136: POP
// for i = 1 to 4 do
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: DOUBLE
8143: LD_INT 1
8145: DEC
8146: ST_TO_ADDR
8147: LD_INT 4
8149: PUSH
8150: FOR_TO
8151: IFFALSE 8222
// begin PrepareHuman ( false , 1 , 6 ) ;
8153: LD_INT 0
8155: PPUSH
8156: LD_INT 1
8158: PPUSH
8159: LD_INT 6
8161: PPUSH
8162: CALL_OW 380
// un := CreateHuman ;
8166: LD_ADDR_VAR 0 3
8170: PUSH
8171: CALL_OW 44
8175: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8176: LD_VAR 0 3
8180: PPUSH
8181: LD_INT 15
8183: PPUSH
8184: LD_INT 0
8186: PPUSH
8187: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8191: LD_ADDR_VAR 0 2
8195: PUSH
8196: LD_VAR 0 2
8200: PPUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 1
8208: PLUS
8209: PPUSH
8210: LD_VAR 0 3
8214: PPUSH
8215: CALL_OW 1
8219: ST_TO_ADDR
// end ;
8220: GO 8150
8222: POP
8223: POP
// wait ( 0 0$3 ) ;
8224: LD_INT 105
8226: PPUSH
8227: CALL_OW 67
// for i in tmp do
8231: LD_ADDR_VAR 0 1
8235: PUSH
8236: LD_VAR 0 2
8240: PUSH
8241: FOR_IN
8242: IFFALSE 8310
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8244: LD_VAR 0 1
8248: PPUSH
8249: CALL_OW 257
8253: PUSH
8254: LD_INT 1
8256: EQUAL
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 247
8267: PUSH
8268: LD_INT 2
8270: EQUAL
8271: OR
8272: IFFALSE 8308
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8274: LD_VAR 0 1
8278: PPUSH
8279: LD_INT 81
8281: PUSH
8282: LD_INT 8
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PPUSH
8289: CALL_OW 69
8293: PPUSH
8294: LD_VAR 0 1
8298: PPUSH
8299: CALL_OW 74
8303: PPUSH
8304: CALL_OW 115
8308: GO 8241
8310: POP
8311: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8312: LD_VAR 0 2
8316: PPUSH
8317: LD_INT 210
8319: PPUSH
8320: LD_INT 178
8322: PPUSH
8323: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8327: LD_ADDR_VAR 0 4
8331: PUSH
8332: LD_INT 10
8334: PPUSH
8335: LD_INT 22
8337: PUSH
8338: LD_INT 8
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PPUSH
8345: CALL_OW 70
8349: ST_TO_ADDR
// if x then
8350: LD_VAR 0 4
8354: IFFALSE 8382
// for i in x do
8356: LD_ADDR_VAR 0 1
8360: PUSH
8361: LD_VAR 0 4
8365: PUSH
8366: FOR_IN
8367: IFFALSE 8380
// RemoveUnit ( i ) ;
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 64
8378: GO 8366
8380: POP
8381: POP
// wait ( 0 0$1 ) ;
8382: LD_INT 35
8384: PPUSH
8385: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8389: LD_INT 22
8391: PUSH
8392: LD_INT 8
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PPUSH
8399: CALL_OW 69
8403: NOT
8404: IFFALSE 8312
// end ;
8406: PPOPN 4
8408: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8409: LD_INT 22
8411: PUSH
8412: LD_INT 2
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PUSH
8419: LD_INT 34
8421: PUSH
8422: LD_INT 31
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: PUSH
8429: LD_INT 3
8431: PUSH
8432: LD_INT 24
8434: PUSH
8435: LD_INT 1000
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: PPUSH
8451: CALL_OW 69
8455: IFFALSE 8558
8457: GO 8459
8459: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8460: LD_INT 45
8462: PPUSH
8463: CALL_OW 302
8467: PUSH
8468: LD_INT 45
8470: PPUSH
8471: CALL_OW 255
8475: AND
8476: IFFALSE 8519
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 34
8490: PUSH
8491: LD_INT 31
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: PPUSH
8507: LD_INT 18
8509: PPUSH
8510: LD_INT 8
8512: PPUSH
8513: CALL_OW 111
8517: GO 8558
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8519: LD_INT 22
8521: PUSH
8522: LD_INT 2
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 34
8531: PUSH
8532: LD_INT 31
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: PPUSH
8548: LD_INT 106
8550: PPUSH
8551: LD_INT 14
8553: PPUSH
8554: CALL_OW 111
// end ; end_of_file
8558: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8559: LD_INT 0
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
// InGameOn ;
8567: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8571: LD_EXP 21
8575: PPUSH
8576: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8580: LD_INT 2
8582: PPUSH
8583: LD_INT 1
8585: PPUSH
8586: LD_INT 1
8588: PPUSH
8589: LD_INT 1
8591: PPUSH
8592: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_INT 22
8603: PUSH
8604: LD_INT 1
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 1
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: PPUSH
8625: CALL_OW 69
8629: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8630: LD_ADDR_VAR 0 4
8634: PUSH
8635: LD_INT 22
8637: PUSH
8638: LD_INT 1
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: PUSH
8645: LD_INT 34
8647: PUSH
8648: LD_INT 11
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: PPUSH
8659: CALL_OW 69
8663: PUSH
8664: LD_INT 1
8666: ARRAY
8667: ST_TO_ADDR
// for i = 1 to tmp do
8668: LD_ADDR_VAR 0 6
8672: PUSH
8673: DOUBLE
8674: LD_INT 1
8676: DEC
8677: ST_TO_ADDR
8678: LD_VAR 0 2
8682: PUSH
8683: FOR_TO
8684: IFFALSE 8731
// begin if i = 5 then
8686: LD_VAR 0 6
8690: PUSH
8691: LD_INT 5
8693: EQUAL
8694: IFFALSE 8698
// break ;
8696: GO 8731
// sols := Replace ( sols , i , tmp [ i ] ) ;
8698: LD_ADDR_VAR 0 5
8702: PUSH
8703: LD_VAR 0 5
8707: PPUSH
8708: LD_VAR 0 6
8712: PPUSH
8713: LD_VAR 0 2
8717: PUSH
8718: LD_VAR 0 6
8722: ARRAY
8723: PPUSH
8724: CALL_OW 1
8728: ST_TO_ADDR
// end ;
8729: GO 8683
8731: POP
8732: POP
// tmp := ar_force_tmp ;
8733: LD_ADDR_VAR 0 2
8737: PUSH
8738: LD_EXP 40
8742: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8743: LD_VAR 0 2
8747: PUSH
8748: LD_INT 1
8750: ARRAY
8751: PPUSH
8752: LD_INT 108
8754: PPUSH
8755: LD_INT 139
8757: PPUSH
8758: LD_INT 0
8760: PPUSH
8761: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8765: LD_VAR 0 2
8769: PUSH
8770: LD_INT 1
8772: ARRAY
8773: PPUSH
8774: LD_EXP 21
8778: PPUSH
8779: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8783: LD_VAR 0 2
8787: PUSH
8788: LD_INT 2
8790: ARRAY
8791: PPUSH
8792: LD_INT 114
8794: PPUSH
8795: LD_INT 132
8797: PPUSH
8798: LD_INT 0
8800: PPUSH
8801: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8805: LD_VAR 0 2
8809: PUSH
8810: LD_INT 3
8812: ARRAY
8813: PPUSH
8814: LD_INT 115
8816: PPUSH
8817: LD_INT 132
8819: PPUSH
8820: LD_INT 0
8822: PPUSH
8823: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8827: LD_VAR 0 2
8831: PUSH
8832: LD_INT 2
8834: ARRAY
8835: PUSH
8836: LD_VAR 0 2
8840: PUSH
8841: LD_INT 3
8843: ARRAY
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PPUSH
8849: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_INT 83
8860: PPUSH
8861: LD_INT 123
8863: PPUSH
8864: CALL_OW 111
// Wait ( 0 0$01 ) ;
8868: LD_INT 35
8870: PPUSH
8871: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8875: LD_INT 90
8877: PPUSH
8878: LD_INT 144
8880: PPUSH
8881: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8885: LD_VAR 0 5
8889: PPUSH
8890: LD_INT 88
8892: PPUSH
8893: LD_INT 129
8895: PPUSH
8896: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8900: LD_ADDR_VAR 0 3
8904: PUSH
8905: LD_INT 92
8907: PUSH
8908: LD_INT 131
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 88
8917: PUSH
8918: LD_INT 127
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 91
8927: PUSH
8928: LD_INT 132
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: LD_INT 92
8937: PUSH
8938: LD_INT 134
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: ST_TO_ADDR
// for i = 1 to sols do
8951: LD_ADDR_VAR 0 6
8955: PUSH
8956: DOUBLE
8957: LD_INT 1
8959: DEC
8960: ST_TO_ADDR
8961: LD_VAR 0 5
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9040
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8969: LD_VAR 0 5
8973: PUSH
8974: LD_VAR 0 6
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_VAR 0 3
8999: PUSH
9000: LD_VAR 0 6
9004: ARRAY
9005: PUSH
9006: LD_INT 2
9008: ARRAY
9009: PPUSH
9010: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9014: LD_VAR 0 5
9018: PUSH
9019: LD_VAR 0 6
9023: ARRAY
9024: PPUSH
9025: CALL_OW 197
// AddComHold ( sols ) ;
9029: LD_VAR 0 5
9033: PPUSH
9034: CALL_OW 200
// end ;
9038: GO 8966
9040: POP
9041: POP
// repeat wait ( 0 0$1 ) ;
9042: LD_INT 35
9044: PPUSH
9045: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9049: LD_VAR 0 5
9053: PUSH
9054: LD_INT 1
9056: ARRAY
9057: PPUSH
9058: LD_INT 92
9060: PPUSH
9061: LD_INT 131
9063: PPUSH
9064: CALL_OW 297
9068: PUSH
9069: LD_INT 4
9071: LESS
9072: IFFALSE 9042
// CenterOnXY ( 96 , 139 ) ;
9074: LD_INT 96
9076: PPUSH
9077: LD_INT 139
9079: PPUSH
9080: CALL_OW 84
// wait ( 0 0$3 ) ;
9084: LD_INT 105
9086: PPUSH
9087: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9091: LD_INT 111
9093: PPUSH
9094: LD_INT 135
9096: PPUSH
9097: LD_INT 1
9099: PPUSH
9100: LD_INT 25
9102: NEG
9103: PPUSH
9104: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9108: LD_VAR 0 2
9112: PUSH
9113: LD_INT 2
9115: ARRAY
9116: PPUSH
9117: LD_VAR 0 2
9121: PUSH
9122: LD_INT 1
9124: ARRAY
9125: PPUSH
9126: CALL_OW 250
9130: PUSH
9131: LD_INT 3
9133: PLUS
9134: PPUSH
9135: LD_VAR 0 2
9139: PUSH
9140: LD_INT 1
9142: ARRAY
9143: PPUSH
9144: CALL_OW 251
9148: PPUSH
9149: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9153: LD_VAR 0 2
9157: PUSH
9158: LD_INT 3
9160: ARRAY
9161: PPUSH
9162: LD_INT 7
9164: PPUSH
9165: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9169: LD_VAR 0 2
9173: PUSH
9174: LD_INT 2
9176: ARRAY
9177: PPUSH
9178: LD_VAR 0 2
9182: PUSH
9183: LD_INT 1
9185: ARRAY
9186: PPUSH
9187: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9191: LD_INT 35
9193: PPUSH
9194: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9198: LD_VAR 0 2
9202: PUSH
9203: LD_INT 1
9205: ARRAY
9206: PPUSH
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 2
9214: ARRAY
9215: PPUSH
9216: CALL_OW 296
9220: PUSH
9221: LD_INT 5
9223: LESS
9224: IFFALSE 9191
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9226: LD_VAR 0 2
9230: PUSH
9231: LD_INT 1
9233: ARRAY
9234: PPUSH
9235: LD_VAR 0 2
9239: PUSH
9240: LD_INT 2
9242: ARRAY
9243: PPUSH
9244: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9248: LD_VAR 0 2
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: LD_STRING D1a-Merc1-1
9259: PPUSH
9260: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9264: LD_VAR 0 2
9268: PUSH
9269: LD_INT 2
9271: ARRAY
9272: PPUSH
9273: LD_STRING D1a-FMerc2-1
9275: PPUSH
9276: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9280: LD_VAR 0 2
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_VAR 0 2
9293: PUSH
9294: LD_INT 1
9296: ARRAY
9297: PPUSH
9298: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9302: LD_VAR 0 2
9306: PUSH
9307: LD_INT 1
9309: ARRAY
9310: PPUSH
9311: LD_INT 500
9313: PPUSH
9314: CALL_OW 234
// wait ( 0 0$2 ) ;
9318: LD_INT 70
9320: PPUSH
9321: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: LD_INT 2
9336: PPUSH
9337: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9341: LD_INT 10
9343: PPUSH
9344: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9348: LD_VAR 0 2
9352: PUSH
9353: LD_INT 1
9355: ARRAY
9356: PPUSH
9357: LD_STRING D1a-Merc1-2
9359: PPUSH
9360: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9364: LD_INT 7
9366: PPUSH
9367: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9371: LD_VAR 0 2
9375: PUSH
9376: LD_INT 1
9378: ARRAY
9379: PPUSH
9380: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9384: LD_VAR 0 2
9388: PUSH
9389: LD_INT 2
9391: ARRAY
9392: PPUSH
9393: LD_INT 10
9395: PPUSH
9396: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9400: LD_VAR 0 2
9404: PUSH
9405: LD_INT 2
9407: ARRAY
9408: PPUSH
9409: LD_STRING D1a-FMerc2-2
9411: PPUSH
9412: CALL_OW 88
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9423: LD_INT 7
9425: PPUSH
9426: CALL_OW 85
// wait ( 0 0$2 ) ;
9430: LD_INT 70
9432: PPUSH
9433: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9437: LD_EXP 44
9441: PPUSH
9442: LD_STRING D1a-Saliba-1
9444: PPUSH
9445: CALL_OW 91
// KillUnit ( Saliba ) ;
9449: LD_EXP 44
9453: PPUSH
9454: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9458: LD_VAR 0 2
9462: PUSH
9463: LD_INT 3
9465: ARRAY
9466: PPUSH
9467: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9471: LD_EXP 21
9475: PPUSH
9476: CALL_OW 85
// wait ( 0 0$1 ) ;
9480: LD_INT 35
9482: PPUSH
9483: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 88
9494: PPUSH
9495: LD_INT 141
9497: PPUSH
9498: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9502: LD_VAR 0 5
9506: PPUSH
9507: LD_INT 70
9509: PPUSH
9510: CALL_OW 202
// wait ( 0 0$2 ) ;
9514: LD_INT 70
9516: PPUSH
9517: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9521: LD_INT 2
9523: PPUSH
9524: LD_INT 1
9526: PPUSH
9527: LD_INT 2
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: CALL_OW 80
// InGameOff ;
9537: CALL_OW 9
// ComWalk ( sols ) ;
9541: LD_VAR 0 5
9545: PPUSH
9546: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9550: LD_STRING M1
9552: PPUSH
9553: CALL_OW 337
// game_speed := 4 ;
9557: LD_ADDR_OWVAR 65
9561: PUSH
9562: LD_INT 4
9564: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9565: LD_INT 111
9567: PPUSH
9568: LD_INT 135
9570: PPUSH
9571: LD_INT 1
9573: PPUSH
9574: CALL_OW 331
// SaveForQuickRestart ;
9578: CALL_OW 22
// ar_run := true ;
9582: LD_ADDR_EXP 5
9586: PUSH
9587: LD_INT 1
9589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9590: LD_INT 35
9592: PPUSH
9593: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9597: LD_INT 22
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 91
9609: PUSH
9610: LD_INT 7
9612: PUSH
9613: LD_INT 10
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: PPUSH
9625: CALL_OW 69
9629: PUSH
9630: LD_INT 7
9632: PPUSH
9633: CALL_OW 256
9637: PUSH
9638: LD_INT 999
9640: LESS
9641: OR
9642: IFFALSE 9590
// if GetSide ( ar_dep_s ) = 2 then
9644: LD_INT 7
9646: PPUSH
9647: CALL_OW 255
9651: PUSH
9652: LD_INT 2
9654: EQUAL
9655: IFFALSE 9667
// SetSide ( ar_dep_s , 1 ) ;
9657: LD_INT 7
9659: PPUSH
9660: LD_INT 1
9662: PPUSH
9663: CALL_OW 235
// end ;
9667: LD_VAR 0 1
9671: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9672: LD_EXP 5
9676: IFFALSE 10036
9678: GO 9680
9680: DISABLE
9681: LD_INT 0
9683: PPUSH
9684: PPUSH
9685: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_EXP 40
9695: PUSH
9696: LD_EXP 36
9700: PPUSH
9701: LD_INT 2
9703: PUSH
9704: LD_INT 21
9706: PUSH
9707: LD_INT 2
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: LD_INT 21
9716: PUSH
9717: LD_INT 1
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: PPUSH
9729: CALL_OW 72
9733: ADD
9734: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_INT 5
9742: PPUSH
9743: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9747: LD_INT 5
9749: PPUSH
9750: LD_INT 1
9752: PPUSH
9753: CALL_OW 343
// k := 1 ;
9757: LD_ADDR_VAR 0 3
9761: PUSH
9762: LD_INT 1
9764: ST_TO_ADDR
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 9861
// begin if IsInUnit ( i ) then
9778: LD_VAR 0 1
9782: PPUSH
9783: CALL_OW 310
9787: IFFALSE 9798
// ComExitBuilding ( i ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: CALL_OW 122
// if GetClass ( i ) = 3 then
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 257
9807: PUSH
9808: LD_INT 3
9810: EQUAL
9811: IFFALSE 9847
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9813: LD_VAR 0 1
9817: PPUSH
9818: LD_EXP 41
9822: PUSH
9823: LD_VAR 0 3
9827: ARRAY
9828: PPUSH
9829: CALL_OW 180
// k := k + 1 ;
9833: LD_ADDR_VAR 0 3
9837: PUSH
9838: LD_VAR 0 3
9842: PUSH
9843: LD_INT 1
9845: PLUS
9846: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9847: LD_VAR 0 1
9851: PPUSH
9852: LD_INT 10
9854: PPUSH
9855: CALL_OW 173
// end ;
9859: GO 9775
9861: POP
9862: POP
// ar_patrol := true ;
9863: LD_ADDR_EXP 7
9867: PUSH
9868: LD_INT 1
9870: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9871: LD_INT 10
9873: PPUSH
9874: CALL_OW 67
// for i in tmp do
9878: LD_ADDR_VAR 0 1
9882: PUSH
9883: LD_VAR 0 2
9887: PUSH
9888: FOR_IN
9889: IFFALSE 9917
// if not HasTask ( i ) then
9891: LD_VAR 0 1
9895: PPUSH
9896: CALL_OW 314
9900: NOT
9901: IFFALSE 9915
// ComMoveToArea ( i , escape_area ) ;
9903: LD_VAR 0 1
9907: PPUSH
9908: LD_INT 10
9910: PPUSH
9911: CALL_OW 113
9915: GO 9888
9917: POP
9918: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9919: LD_ADDR_VAR 0 3
9923: PUSH
9924: LD_VAR 0 2
9928: PPUSH
9929: LD_INT 95
9931: PUSH
9932: LD_INT 10
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: PPUSH
9939: CALL_OW 72
9943: ST_TO_ADDR
// if k then
9944: LD_VAR 0 3
9948: IFFALSE 10017
// for i in k do
9950: LD_ADDR_VAR 0 1
9954: PUSH
9955: LD_VAR 0 3
9959: PUSH
9960: FOR_IN
9961: IFFALSE 10015
// begin if IsInUnit ( i ) then
9963: LD_VAR 0 1
9967: PPUSH
9968: CALL_OW 310
9972: IFFALSE 9988
// RemoveUnit ( IsInUnit ( i ) ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: CALL_OW 310
9983: PPUSH
9984: CALL_OW 64
// RemoveUnit ( i ) ;
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 64
// tmp := tmp diff i ;
9997: LD_ADDR_VAR 0 2
10001: PUSH
10002: LD_VAR 0 2
10006: PUSH
10007: LD_VAR 0 1
10011: DIFF
10012: ST_TO_ADDR
// end ;
10013: GO 9960
10015: POP
10016: POP
// until tmp = [ ] ;
10017: LD_VAR 0 2
10021: PUSH
10022: EMPTY
10023: EQUAL
10024: IFFALSE 9871
// ChangeSideFog ( 5 , 5 ) ;
10026: LD_INT 5
10028: PPUSH
10029: LD_INT 5
10031: PPUSH
10032: CALL_OW 343
// end ;
10036: PPOPN 3
10038: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10039: LD_EXP 7
10043: IFFALSE 10333
10045: GO 10047
10047: DISABLE
10048: LD_INT 0
10050: PPUSH
10051: PPUSH
10052: PPUSH
// begin uc_side := 2 ;
10053: LD_ADDR_OWVAR 20
10057: PUSH
10058: LD_INT 2
10060: ST_TO_ADDR
// uc_nation := 2 ;
10061: LD_ADDR_OWVAR 21
10065: PUSH
10066: LD_INT 2
10068: ST_TO_ADDR
// InitHc ;
10069: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10073: LD_INT 1
10075: PPUSH
10076: LD_INT 1
10078: PPUSH
10079: LD_INT 6
10081: PPUSH
10082: CALL_OW 380
// un := CreateHuman ;
10086: LD_ADDR_VAR 0 2
10090: PUSH
10091: CALL_OW 44
10095: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10096: LD_INT 14
10098: PPUSH
10099: LD_INT 1
10101: PPUSH
10102: LD_INT 1
10104: PPUSH
10105: LD_INT 27
10107: PPUSH
10108: LD_INT 98
10110: PPUSH
10111: CALL 53419 0 5
// veh := CreateVehicle ;
10115: LD_ADDR_VAR 0 3
10119: PUSH
10120: CALL_OW 45
10124: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_INT 4
10132: PPUSH
10133: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10137: LD_VAR 0 3
10141: PPUSH
10142: LD_INT 179
10144: PPUSH
10145: LD_INT 135
10147: PPUSH
10148: LD_INT 0
10150: PPUSH
10151: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10155: LD_VAR 0 2
10159: PPUSH
10160: LD_VAR 0 3
10164: PPUSH
10165: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10169: LD_VAR 0 2
10173: PPUSH
10174: LD_INT 126
10176: PPUSH
10177: LD_INT 133
10179: PPUSH
10180: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10184: LD_INT 10
10186: PPUSH
10187: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10191: LD_INT 1
10193: PPUSH
10194: LD_VAR 0 3
10198: PPUSH
10199: CALL_OW 292
10203: PUSH
10204: LD_VAR 0 3
10208: PPUSH
10209: LD_INT 7
10211: PPUSH
10212: CALL_OW 296
10216: PUSH
10217: LD_INT 9
10219: LESS
10220: OR
10221: IFFALSE 10184
// ComHold ( veh ) ;
10223: LD_VAR 0 3
10227: PPUSH
10228: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10232: LD_VAR 0 2
10236: PPUSH
10237: LD_STRING D2aa-Ar1-1
10239: PPUSH
10240: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: LD_INT 177
10251: PPUSH
10252: LD_INT 96
10254: PPUSH
10255: CALL_OW 111
// AddComExitVehicle ( un ) ;
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10268: LD_INT 35
10270: PPUSH
10271: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10275: LD_VAR 0 2
10279: PPUSH
10280: LD_INT 204
10282: PPUSH
10283: CALL_OW 296
10287: PUSH
10288: LD_INT 15
10290: LESS
10291: IFFALSE 10268
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10293: LD_ADDR_EXP 50
10297: PUSH
10298: LD_EXP 50
10302: PPUSH
10303: LD_INT 3
10305: PUSH
10306: LD_EXP 50
10310: PUSH
10311: LD_INT 3
10313: ARRAY
10314: PUSH
10315: LD_INT 1
10317: PLUS
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PPUSH
10323: LD_VAR 0 2
10327: PPUSH
10328: CALL 53541 0 3
10332: ST_TO_ADDR
// end ;
10333: PPOPN 3
10335: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10336: LD_INT 7
10338: PPUSH
10339: CALL_OW 255
10343: PUSH
10344: LD_INT 1
10346: EQUAL
10347: PUSH
10348: LD_INT 7
10350: PPUSH
10351: CALL_OW 301
10355: OR
10356: IFFALSE 12764
10358: GO 10360
10360: DISABLE
10361: LD_INT 0
10363: PPUSH
10364: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_EXP 36
10374: PPUSH
10375: LD_INT 21
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PPUSH
10385: CALL_OW 72
10389: PUSH
10390: FOR_IN
10391: IFFALSE 10407
// SetSide ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 235
10405: GO 10390
10407: POP
10408: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10409: LD_ADDR_VAR 0 2
10413: PUSH
10414: LD_INT 46
10416: PUSH
10417: LD_INT 41
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PUSH
10424: LD_INT 50
10426: PUSH
10427: LD_INT 25
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 57
10436: PUSH
10437: LD_INT 75
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 75
10446: PUSH
10447: LD_INT 89
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: PUSH
10454: LD_INT 51
10456: PUSH
10457: LD_INT 45
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: LD_INT 95
10466: PUSH
10467: LD_INT 95
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PUSH
10474: LD_INT 84
10476: PUSH
10477: LD_INT 77
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 101
10486: PUSH
10487: LD_INT 76
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 118
10496: PUSH
10497: LD_INT 81
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: PUSH
10504: LD_INT 139
10506: PUSH
10507: LD_INT 97
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: PUSH
10514: LD_INT 129
10516: PUSH
10517: LD_INT 114
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 154
10526: PUSH
10527: LD_INT 111
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: ST_TO_ADDR
// base_captured := true ;
10548: LD_ADDR_EXP 6
10552: PUSH
10553: LD_INT 1
10555: ST_TO_ADDR
// DialogueOn ;
10556: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10560: LD_EXP 21
10564: PPUSH
10565: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10569: LD_EXP 21
10573: PPUSH
10574: LD_STRING D2-JMM-1
10576: PPUSH
10577: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10581: LD_EXP 30
10585: PPUSH
10586: LD_STRING D2-Pow-1
10588: PPUSH
10589: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10593: LD_EXP 21
10597: PPUSH
10598: LD_STRING D2-JMM-2
10600: PPUSH
10601: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10605: LD_EXP 30
10609: PPUSH
10610: LD_STRING D2-Pow-2
10612: PPUSH
10613: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10617: LD_EXP 21
10621: PPUSH
10622: LD_STRING D2-JMM-3
10624: PPUSH
10625: CALL_OW 88
// DialogueOff ;
10629: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10633: LD_STRING M2
10635: PPUSH
10636: CALL_OW 337
// Wait ( 0 0$2 ) ;
10640: LD_INT 70
10642: PPUSH
10643: CALL_OW 67
// if IsOk ( Gary ) then
10647: LD_EXP 32
10651: PPUSH
10652: CALL_OW 302
10656: IFFALSE 10670
// Say ( Gary , D2a-Gary-1 ) ;
10658: LD_EXP 32
10662: PPUSH
10663: LD_STRING D2a-Gary-1
10665: PPUSH
10666: CALL_OW 88
// if IsOk ( Bobby ) then
10670: LD_EXP 24
10674: PPUSH
10675: CALL_OW 302
10679: IFFALSE 10693
// Say ( Bobby , D2a-Bobby-1 ) ;
10681: LD_EXP 24
10685: PPUSH
10686: LD_STRING D2a-Bobby-1
10688: PPUSH
10689: CALL_OW 88
// if IsOk ( Cyrus ) then
10693: LD_EXP 25
10697: PPUSH
10698: CALL_OW 302
10702: IFFALSE 10716
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10704: LD_EXP 25
10708: PPUSH
10709: LD_STRING D2a-Cyrus-1
10711: PPUSH
10712: CALL_OW 88
// if IsOk ( Lisa ) then
10716: LD_EXP 22
10720: PPUSH
10721: CALL_OW 302
10725: IFFALSE 10739
// Say ( Lisa , D2a-Lisa-1 ) ;
10727: LD_EXP 22
10731: PPUSH
10732: LD_STRING D2a-Lisa-1
10734: PPUSH
10735: CALL_OW 88
// if IsOk ( Frank ) then
10739: LD_EXP 33
10743: PPUSH
10744: CALL_OW 302
10748: IFFALSE 10762
// Say ( Frank , D2a-Frank-1 ) ;
10750: LD_EXP 33
10754: PPUSH
10755: LD_STRING D2a-Frank-1
10757: PPUSH
10758: CALL_OW 88
// if IsOk ( Cornel ) then
10762: LD_EXP 31
10766: PPUSH
10767: CALL_OW 302
10771: IFFALSE 10785
// Say ( Cornel , D2a-Corn-1 ) ;
10773: LD_EXP 31
10777: PPUSH
10778: LD_STRING D2a-Corn-1
10780: PPUSH
10781: CALL_OW 88
// if IsOk ( Donaldson ) then
10785: LD_EXP 23
10789: PPUSH
10790: CALL_OW 302
10794: IFFALSE 10808
// Say ( Donaldson , D2a-Don-1 ) ;
10796: LD_EXP 23
10800: PPUSH
10801: LD_STRING D2a-Don-1
10803: PPUSH
10804: CALL_OW 88
// if IsOk ( Brown ) then
10808: LD_EXP 27
10812: PPUSH
10813: CALL_OW 302
10817: IFFALSE 10831
// Say ( Brown , D2a-Brown-1 ) ;
10819: LD_EXP 27
10823: PPUSH
10824: LD_STRING D2a-Brown-1
10826: PPUSH
10827: CALL_OW 88
// Wait ( 0 0$30 ) ;
10831: LD_INT 1050
10833: PPUSH
10834: CALL_OW 67
// if IsOk ( Frank ) then
10838: LD_EXP 33
10842: PPUSH
10843: CALL_OW 302
10847: IFFALSE 11113
// begin DialogueOn ;
10849: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10853: LD_EXP 21
10857: PUSH
10858: LD_EXP 33
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PPUSH
10867: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10871: LD_EXP 33
10875: PPUSH
10876: LD_STRING D3F-Frank-1
10878: PPUSH
10879: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10883: LD_EXP 21
10887: PPUSH
10888: LD_STRING D3F-JMM-1
10890: PPUSH
10891: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10895: LD_EXP 33
10899: PPUSH
10900: LD_STRING D3F-Frank-2
10902: PPUSH
10903: CALL_OW 88
// case Query ( QFrank ) of 1 :
10907: LD_STRING QFrank
10909: PPUSH
10910: CALL_OW 97
10914: PUSH
10915: LD_INT 1
10917: DOUBLE
10918: EQUAL
10919: IFTRUE 10923
10921: GO 10946
10923: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10924: LD_EXP 21
10928: PPUSH
10929: LD_STRING D3Fa-JMM-1
10931: PPUSH
10932: CALL_OW 88
// us_scout := 1 ;
10936: LD_ADDR_EXP 8
10940: PUSH
10941: LD_INT 1
10943: ST_TO_ADDR
// end ; 2 :
10944: GO 11109
10946: LD_INT 2
10948: DOUBLE
10949: EQUAL
10950: IFTRUE 10954
10952: GO 11076
10954: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10955: LD_EXP 21
10959: PPUSH
10960: LD_STRING D3Fb-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10967: LD_EXP 33
10971: PPUSH
10972: LD_STRING D3Fb-Frank-1
10974: PPUSH
10975: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10979: LD_STRING QFrank2
10981: PPUSH
10982: CALL_OW 97
10986: PUSH
10987: LD_INT 1
10989: DOUBLE
10990: EQUAL
10991: IFTRUE 10995
10993: GO 11042
10995: POP
// begin us_scout := 2 ;
10996: LD_ADDR_EXP 8
11000: PUSH
11001: LD_INT 2
11003: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11004: LD_EXP 21
11008: PPUSH
11009: LD_STRING D3Fba-JMM-1
11011: PPUSH
11012: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11016: LD_EXP 33
11020: PPUSH
11021: LD_STRING D3Fba-Frank-1
11023: PPUSH
11024: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11028: LD_EXP 21
11032: PPUSH
11033: LD_STRING D3Fba-JMM-2
11035: PPUSH
11036: CALL_OW 88
// end ; 2 :
11040: GO 11074
11042: LD_INT 2
11044: DOUBLE
11045: EQUAL
11046: IFTRUE 11050
11048: GO 11073
11050: POP
// begin us_scout := 0 ;
11051: LD_ADDR_EXP 8
11055: PUSH
11056: LD_INT 0
11058: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11059: LD_EXP 21
11063: PPUSH
11064: LD_STRING D3Fbb-JMM-1
11066: PPUSH
11067: CALL_OW 88
// end ; end ;
11071: GO 11074
11073: POP
// end ; 3 :
11074: GO 11109
11076: LD_INT 3
11078: DOUBLE
11079: EQUAL
11080: IFTRUE 11084
11082: GO 11108
11084: POP
// begin us_scout := - 1 ;
11085: LD_ADDR_EXP 8
11089: PUSH
11090: LD_INT 1
11092: NEG
11093: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11094: LD_EXP 21
11098: PPUSH
11099: LD_STRING D3Fc-JMM-1
11101: PPUSH
11102: CALL_OW 88
// end ; end ;
11106: GO 11109
11108: POP
// DialogueOff ;
11109: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11113: LD_EXP 8
11117: PUSH
11118: LD_INT 1
11120: NEG
11121: PUSH
11122: LD_INT 0
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: IN
11129: IFFALSE 11133
// exit ;
11131: GO 12764
// if us_scout in [ 1 , 2 ] then
11133: LD_EXP 8
11137: PUSH
11138: LD_INT 1
11140: PUSH
11141: LD_INT 2
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: IN
11148: IFFALSE 11827
// begin if IsInUnit ( Frank ) then
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 310
11159: IFFALSE 11170
// ComExit ( Frank ) ;
11161: LD_EXP 33
11165: PPUSH
11166: CALL 85680 0 1
// SetSide ( Frank , 4 ) ;
11170: LD_EXP 33
11174: PPUSH
11175: LD_INT 4
11177: PPUSH
11178: CALL_OW 235
// wait ( 0 0$1 ) ;
11182: LD_INT 35
11184: PPUSH
11185: CALL_OW 67
// if us_scout = 2 then
11189: LD_EXP 8
11193: PUSH
11194: LD_INT 2
11196: EQUAL
11197: IFFALSE 11565
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11199: LD_EXP 33
11203: PPUSH
11204: LD_INT 75
11206: PPUSH
11207: LD_INT 63
11209: PPUSH
11210: CALL_OW 111
// AddComHold ( Frank ) ;
11214: LD_EXP 33
11218: PPUSH
11219: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11223: LD_EXP 33
11227: PPUSH
11228: LD_INT 770
11230: PPUSH
11231: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 100
11242: PPUSH
11243: LD_INT 75
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 123
11257: PPUSH
11258: LD_INT 103
11260: PPUSH
11261: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11265: LD_EXP 33
11269: PPUSH
11270: LD_INT 138
11272: PPUSH
11273: LD_INT 108
11275: PPUSH
11276: CALL_OW 171
// AddComHold ( Frank ) ;
11280: LD_EXP 33
11284: PPUSH
11285: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11289: LD_INT 35
11291: PPUSH
11292: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11296: LD_EXP 33
11300: PPUSH
11301: LD_INT 138
11303: PPUSH
11304: LD_INT 108
11306: PPUSH
11307: CALL_OW 307
11311: IFFALSE 11289
// AddComMoveXY ( Frank , 125 , 132 ) ;
11313: LD_EXP 33
11317: PPUSH
11318: LD_INT 125
11320: PPUSH
11321: LD_INT 132
11323: PPUSH
11324: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11328: LD_INT 35
11330: PPUSH
11331: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11335: LD_INT 1
11337: PPUSH
11338: LD_EXP 33
11342: PPUSH
11343: CALL_OW 292
11347: PUSH
11348: LD_EXP 33
11352: PPUSH
11353: LD_INT 7
11355: PPUSH
11356: CALL_OW 296
11360: PUSH
11361: LD_INT 7
11363: LESS
11364: OR
11365: IFFALSE 11328
// DialogueOn ;
11367: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11371: LD_EXP 33
11375: PPUSH
11376: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11380: LD_INT 10
11382: PPUSH
11383: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11387: LD_EXP 21
11391: PPUSH
11392: LD_STRING D4Fa-JMM-1
11394: PPUSH
11395: CALL_OW 88
// for i in points do
11399: LD_ADDR_VAR 0 1
11403: PUSH
11404: LD_VAR 0 2
11408: PUSH
11409: FOR_IN
11410: IFFALSE 11468
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11412: LD_VAR 0 1
11416: PUSH
11417: LD_INT 1
11419: ARRAY
11420: PPUSH
11421: LD_VAR 0 1
11425: PUSH
11426: LD_INT 2
11428: ARRAY
11429: PPUSH
11430: LD_INT 1
11432: PPUSH
11433: LD_INT 20
11435: NEG
11436: PPUSH
11437: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11441: LD_VAR 0 1
11445: PUSH
11446: LD_INT 1
11448: ARRAY
11449: PPUSH
11450: LD_VAR 0 1
11454: PUSH
11455: LD_INT 2
11457: ARRAY
11458: PPUSH
11459: LD_INT 1
11461: PPUSH
11462: CALL_OW 331
// end ;
11466: GO 11409
11468: POP
11469: POP
// dwait ( 0 0$0.5 ) ;
11470: LD_INT 18
11472: PPUSH
11473: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11477: LD_INT 42
11479: PPUSH
11480: LD_INT 27
11482: PPUSH
11483: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_STRING D4Fa-Frank-1
11494: PPUSH
11495: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11499: LD_INT 18
11501: PPUSH
11502: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11506: LD_EXP 21
11510: PPUSH
11511: LD_STRING D4Fa-JMM-2
11513: PPUSH
11514: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11518: LD_INT 118
11520: PPUSH
11521: LD_INT 80
11523: PPUSH
11524: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11528: LD_EXP 33
11532: PPUSH
11533: LD_STRING D4Fa-Frank-2
11535: PPUSH
11536: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11540: LD_INT 10
11542: PPUSH
11543: CALL_OW 68
// DialogueOff ;
11547: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11551: LD_EXP 33
11555: PPUSH
11556: LD_INT 1
11558: PPUSH
11559: CALL_OW 235
// end else
11563: GO 11827
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11565: LD_INT 2
11567: PPUSH
11568: LD_INT 4
11570: PPUSH
11571: LD_INT 2
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 75
11588: PPUSH
11589: LD_INT 63
11591: PPUSH
11592: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11596: LD_EXP 33
11600: PPUSH
11601: LD_INT 175
11603: PPUSH
11604: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 102
11615: PPUSH
11616: LD_INT 76
11618: PPUSH
11619: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11623: LD_EXP 33
11627: PPUSH
11628: LD_INT 108
11630: PPUSH
11631: LD_INT 70
11633: PPUSH
11634: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11638: LD_INT 35
11640: PPUSH
11641: CALL_OW 67
// until See ( 2 , Frank ) ;
11645: LD_INT 2
11647: PPUSH
11648: LD_EXP 33
11652: PPUSH
11653: CALL_OW 292
11657: IFFALSE 11638
// ComMoveXY ( Frank , 112 , 118 ) ;
11659: LD_EXP 33
11663: PPUSH
11664: LD_INT 112
11666: PPUSH
11667: LD_INT 118
11669: PPUSH
11670: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11674: LD_EXP 33
11678: PPUSH
11679: CALL_OW 256
11683: PUSH
11684: LD_INT 750
11686: GREATEREQUAL
11687: IFFALSE 11701
// SetLives ( Frank , 700 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_INT 700
11696: PPUSH
11697: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11701: LD_INT 35
11703: PPUSH
11704: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11708: LD_INT 1
11710: PPUSH
11711: LD_EXP 33
11715: PPUSH
11716: CALL_OW 292
11720: PUSH
11721: LD_EXP 33
11725: PPUSH
11726: LD_INT 7
11728: PPUSH
11729: CALL_OW 296
11733: PUSH
11734: LD_INT 17
11736: LESS
11737: OR
11738: IFFALSE 11701
// DialogueOn ;
11740: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11744: LD_EXP 33
11748: PPUSH
11749: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11753: LD_EXP 33
11757: PPUSH
11758: LD_STRING D4Fb-Frank-1
11760: PPUSH
11761: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11765: LD_EXP 21
11769: PPUSH
11770: LD_STRING D4Fb-JMM-1
11772: PPUSH
11773: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11777: LD_INT 2
11779: PPUSH
11780: LD_STRING D4Fb-FSci1-1
11782: PPUSH
11783: CALL 16687 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11787: LD_EXP 33
11791: PPUSH
11792: LD_STRING D4Fb-Frank-2
11794: PPUSH
11795: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11799: LD_EXP 21
11803: PPUSH
11804: LD_STRING D4Fb-JMM-2
11806: PPUSH
11807: CALL_OW 88
// DialogueOff ;
11811: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11815: LD_EXP 33
11819: PPUSH
11820: LD_INT 1
11822: PPUSH
11823: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11827: LD_EXP 34
11831: PPUSH
11832: CALL_OW 302
11836: PUSH
11837: LD_EXP 33
11841: NOT
11842: AND
11843: IFFALSE 11991
// begin DialogueOn ;
11845: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11849: LD_EXP 21
11853: PUSH
11854: LD_EXP 34
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PPUSH
11863: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11867: LD_EXP 34
11871: PPUSH
11872: LD_STRING D3Y-Yam-1
11874: PPUSH
11875: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11879: LD_EXP 21
11883: PPUSH
11884: LD_STRING D3Y-JMM-1
11886: PPUSH
11887: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11891: LD_EXP 34
11895: PPUSH
11896: LD_STRING D3Y-Yam-2
11898: PPUSH
11899: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11903: LD_STRING QYamoko
11905: PPUSH
11906: CALL_OW 97
11910: PUSH
11911: LD_INT 1
11913: DOUBLE
11914: EQUAL
11915: IFTRUE 11919
11917: GO 11954
11919: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11920: LD_EXP 21
11924: PPUSH
11925: LD_STRING D3Ya-JMM-1
11927: PPUSH
11928: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11932: LD_EXP 34
11936: PPUSH
11937: LD_STRING D3Ya-Yam-1
11939: PPUSH
11940: CALL_OW 88
// us_scout := 1 ;
11944: LD_ADDR_EXP 8
11948: PUSH
11949: LD_INT 1
11951: ST_TO_ADDR
// end ; 2 :
11952: GO 11987
11954: LD_INT 2
11956: DOUBLE
11957: EQUAL
11958: IFTRUE 11962
11960: GO 11986
11962: POP
// begin us_scout := - 1 ;
11963: LD_ADDR_EXP 8
11967: PUSH
11968: LD_INT 1
11970: NEG
11971: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11972: LD_EXP 21
11976: PPUSH
11977: LD_STRING D3Yb-JMM-1
11979: PPUSH
11980: CALL_OW 88
// end ; end ;
11984: GO 11987
11986: POP
// DialogueOff ;
11987: CALL_OW 7
// end ; if Frank then
11991: LD_EXP 33
11995: IFFALSE 11999
// exit ;
11997: GO 12764
// if us_scout in [ - 1 , 0 ] then
11999: LD_EXP 8
12003: PUSH
12004: LD_INT 1
12006: NEG
12007: PUSH
12008: LD_INT 0
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: IN
12015: IFFALSE 12019
// exit ;
12017: GO 12764
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12019: LD_ADDR_EXP 8
12023: PUSH
12024: LD_INT 2
12026: PUSH
12027: LD_INT 2
12029: PUSH
12030: LD_INT 1
12032: PUSH
12033: LD_INT 1
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: PUSH
12042: LD_OWVAR 67
12046: ARRAY
12047: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12048: LD_EXP 8
12052: PUSH
12053: LD_INT 1
12055: PUSH
12056: LD_INT 2
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: IN
12063: IFFALSE 12764
// begin if IsInUnit ( Kikuchi ) then
12065: LD_EXP 34
12069: PPUSH
12070: CALL_OW 310
12074: IFFALSE 12085
// ComExitBuilding ( Kikuchi ) ;
12076: LD_EXP 34
12080: PPUSH
12081: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12085: LD_EXP 34
12089: PPUSH
12090: CALL_OW 311
12094: IFFALSE 12105
// ComExitVehicle ( Kikuchi ) ;
12096: LD_EXP 34
12100: PPUSH
12101: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_INT 4
12112: PPUSH
12113: CALL_OW 235
// wait ( 0 0$1 ) ;
12117: LD_INT 35
12119: PPUSH
12120: CALL_OW 67
// if us_scout = 2 then
12124: LD_EXP 8
12128: PUSH
12129: LD_INT 2
12131: EQUAL
12132: IFFALSE 12512
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12134: LD_EXP 34
12138: PPUSH
12139: LD_INT 75
12141: PPUSH
12142: LD_INT 63
12144: PPUSH
12145: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12149: LD_EXP 34
12153: PPUSH
12154: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12158: LD_EXP 34
12162: PPUSH
12163: LD_INT 770
12165: PPUSH
12166: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12170: LD_EXP 34
12174: PPUSH
12175: LD_INT 100
12177: PPUSH
12178: LD_INT 75
12180: PPUSH
12181: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12185: LD_EXP 34
12189: PPUSH
12190: LD_INT 123
12192: PPUSH
12193: LD_INT 103
12195: PPUSH
12196: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12200: LD_EXP 34
12204: PPUSH
12205: LD_INT 138
12207: PPUSH
12208: LD_INT 108
12210: PPUSH
12211: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12215: LD_EXP 34
12219: PPUSH
12220: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12224: LD_INT 35
12226: PPUSH
12227: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12231: LD_EXP 34
12235: PPUSH
12236: LD_INT 138
12238: PPUSH
12239: LD_INT 108
12241: PPUSH
12242: CALL_OW 307
12246: IFFALSE 12224
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12248: LD_EXP 34
12252: PPUSH
12253: LD_INT 125
12255: PPUSH
12256: LD_INT 132
12258: PPUSH
12259: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12263: LD_INT 35
12265: PPUSH
12266: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12270: LD_INT 1
12272: PPUSH
12273: LD_EXP 34
12277: PPUSH
12278: CALL_OW 292
12282: PUSH
12283: LD_EXP 34
12287: PPUSH
12288: LD_INT 7
12290: PPUSH
12291: CALL_OW 296
12295: PUSH
12296: LD_INT 7
12298: LESS
12299: OR
12300: IFFALSE 12263
// DialogueOn ;
12302: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12306: LD_EXP 34
12310: PPUSH
12311: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12315: LD_INT 10
12317: PPUSH
12318: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12322: LD_EXP 34
12326: PPUSH
12327: LD_STRING D4Ya-Yam-1
12329: PPUSH
12330: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12334: LD_EXP 21
12338: PPUSH
12339: LD_STRING D4Ya-JMM-1
12341: PPUSH
12342: CALL_OW 88
// for i in points do
12346: LD_ADDR_VAR 0 1
12350: PUSH
12351: LD_VAR 0 2
12355: PUSH
12356: FOR_IN
12357: IFFALSE 12415
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12359: LD_VAR 0 1
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 1
12372: PUSH
12373: LD_INT 2
12375: ARRAY
12376: PPUSH
12377: LD_INT 1
12379: PPUSH
12380: LD_INT 20
12382: NEG
12383: PPUSH
12384: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12388: LD_VAR 0 1
12392: PUSH
12393: LD_INT 1
12395: ARRAY
12396: PPUSH
12397: LD_VAR 0 1
12401: PUSH
12402: LD_INT 2
12404: ARRAY
12405: PPUSH
12406: LD_INT 1
12408: PPUSH
12409: CALL_OW 331
// end ;
12413: GO 12356
12415: POP
12416: POP
// dwait ( 0 0$0.5 ) ;
12417: LD_INT 18
12419: PPUSH
12420: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12424: LD_INT 42
12426: PPUSH
12427: LD_INT 27
12429: PPUSH
12430: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12434: LD_EXP 34
12438: PPUSH
12439: LD_STRING D4Ya-Yam-2
12441: PPUSH
12442: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12446: LD_INT 18
12448: PPUSH
12449: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12453: LD_INT 118
12455: PPUSH
12456: LD_INT 80
12458: PPUSH
12459: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12463: LD_EXP 21
12467: PPUSH
12468: LD_STRING D4Ya-JMM-2
12470: PPUSH
12471: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_STRING D4Ya-Yam-3
12482: PPUSH
12483: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12487: LD_INT 10
12489: PPUSH
12490: CALL_OW 68
// DialogueOff ;
12494: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12498: LD_EXP 34
12502: PPUSH
12503: LD_INT 1
12505: PPUSH
12506: CALL_OW 235
// end else
12510: GO 12764
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12512: LD_INT 2
12514: PPUSH
12515: LD_INT 4
12517: PPUSH
12518: LD_INT 2
12520: PPUSH
12521: LD_INT 1
12523: PPUSH
12524: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_INT 75
12535: PPUSH
12536: LD_INT 63
12538: PPUSH
12539: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12543: LD_EXP 34
12547: PPUSH
12548: LD_INT 175
12550: PPUSH
12551: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12555: LD_EXP 34
12559: PPUSH
12560: LD_INT 102
12562: PPUSH
12563: LD_INT 76
12565: PPUSH
12566: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12570: LD_EXP 34
12574: PPUSH
12575: LD_INT 108
12577: PPUSH
12578: LD_INT 70
12580: PPUSH
12581: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12585: LD_INT 35
12587: PPUSH
12588: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12592: LD_INT 2
12594: PPUSH
12595: LD_EXP 34
12599: PPUSH
12600: CALL_OW 292
12604: IFFALSE 12585
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12606: LD_EXP 34
12610: PPUSH
12611: LD_INT 112
12613: PPUSH
12614: LD_INT 118
12616: PPUSH
12617: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12621: LD_EXP 34
12625: PPUSH
12626: CALL_OW 256
12630: PUSH
12631: LD_INT 750
12633: GREATEREQUAL
12634: IFFALSE 12648
// SetLives ( Kikuchi , 700 ) ;
12636: LD_EXP 34
12640: PPUSH
12641: LD_INT 700
12643: PPUSH
12644: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12648: LD_INT 35
12650: PPUSH
12651: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12655: LD_INT 1
12657: PPUSH
12658: LD_EXP 34
12662: PPUSH
12663: CALL_OW 292
12667: PUSH
12668: LD_EXP 34
12672: PPUSH
12673: LD_INT 7
12675: PPUSH
12676: CALL_OW 296
12680: PUSH
12681: LD_INT 17
12683: LESS
12684: OR
12685: IFFALSE 12648
// DialogueOn ;
12687: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12691: LD_EXP 34
12695: PPUSH
12696: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12700: LD_EXP 34
12704: PPUSH
12705: LD_STRING D4Yb-Yam-1
12707: PPUSH
12708: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12712: LD_EXP 21
12716: PPUSH
12717: LD_STRING D4Yb-JMM-1
12719: PPUSH
12720: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12724: LD_EXP 34
12728: PPUSH
12729: LD_STRING D4Yb-Yam-2
12731: PPUSH
12732: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12736: LD_EXP 21
12740: PPUSH
12741: LD_STRING D4Yb-JMM-2
12743: PPUSH
12744: CALL_OW 88
// DialogueOff ;
12748: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12752: LD_EXP 34
12756: PPUSH
12757: LD_INT 1
12759: PPUSH
12760: CALL_OW 235
// end ; end ; end ;
12764: PPOPN 2
12766: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12767: LD_EXP 6
12771: IFFALSE 13804
12773: GO 12775
12775: DISABLE
12776: LD_INT 0
12778: PPUSH
12779: PPUSH
12780: PPUSH
12781: PPUSH
// begin enable ;
12782: ENABLE
// if not seen [ 1 ] then
12783: LD_EXP 9
12787: PUSH
12788: LD_INT 1
12790: ARRAY
12791: NOT
12792: IFFALSE 12972
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12794: LD_ADDR_VAR 0 2
12798: PUSH
12799: LD_INT 22
12801: PUSH
12802: LD_INT 2
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: LD_INT 2
12811: PUSH
12812: LD_INT 25
12814: PUSH
12815: LD_INT 11
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 33
12824: PUSH
12825: LD_INT 4
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: LIST
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PPUSH
12841: CALL_OW 69
12845: ST_TO_ADDR
// if tmp then
12846: LD_VAR 0 2
12850: IFFALSE 12972
// for i in tmp do
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: LD_VAR 0 2
12861: PUSH
12862: FOR_IN
12863: IFFALSE 12970
// if See ( 1 , i ) then
12865: LD_INT 1
12867: PPUSH
12868: LD_VAR 0 1
12872: PPUSH
12873: CALL_OW 292
12877: IFFALSE 12968
// begin seen := Replace ( seen , 1 , true ) ;
12879: LD_ADDR_EXP 9
12883: PUSH
12884: LD_EXP 9
12888: PPUSH
12889: LD_INT 1
12891: PPUSH
12892: LD_INT 1
12894: PPUSH
12895: CALL_OW 1
12899: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12900: LD_INT 1
12902: PPUSH
12903: CALL 16509 0 1
12907: IFFALSE 12968
// begin DialogueOn ;
12909: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12913: LD_VAR 0 1
12917: PPUSH
12918: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12922: LD_INT 10
12924: PPUSH
12925: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12929: LD_ADDR_VAR 0 3
12933: PUSH
12934: LD_INT 1
12936: PPUSH
12937: LD_STRING D5a-Sol2-1
12939: PPUSH
12940: CALL 16687 0 2
12944: ST_TO_ADDR
// if not un then
12945: LD_VAR 0 3
12949: NOT
12950: IFFALSE 12962
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12952: LD_INT 2
12954: PPUSH
12955: LD_STRING D5a-FSol2-1
12957: PPUSH
12958: CALL 16687 0 2
// DialogueOff ;
12962: CALL_OW 7
// break ;
12966: GO 12970
// end ; end ;
12968: GO 12862
12970: POP
12971: POP
// end ; if not seen [ 2 ] then
12972: LD_EXP 9
12976: PUSH
12977: LD_INT 2
12979: ARRAY
12980: NOT
12981: IFFALSE 13206
// begin can_kamikazed := true ;
12983: LD_ADDR_EXP 10
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12991: LD_ADDR_VAR 0 2
12995: PUSH
12996: LD_INT 22
12998: PUSH
12999: LD_INT 2
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: LD_INT 25
13008: PUSH
13009: LD_INT 17
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: ST_TO_ADDR
// if tmp then
13025: LD_VAR 0 2
13029: IFFALSE 13206
// for i in tmp do
13031: LD_ADDR_VAR 0 1
13035: PUSH
13036: LD_VAR 0 2
13040: PUSH
13041: FOR_IN
13042: IFFALSE 13204
// if See ( 1 , i ) then
13044: LD_INT 1
13046: PPUSH
13047: LD_VAR 0 1
13051: PPUSH
13052: CALL_OW 292
13056: IFFALSE 13202
// begin seen := Replace ( seen , 2 , true ) ;
13058: LD_ADDR_EXP 9
13062: PUSH
13063: LD_EXP 9
13067: PPUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 1
13078: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13079: LD_INT 1
13081: PPUSH
13082: CALL 16509 0 1
13086: IFFALSE 13202
// begin DialogueOn ;
13088: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13092: LD_VAR 0 1
13096: PPUSH
13097: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13101: LD_INT 10
13103: PPUSH
13104: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13108: LD_ADDR_VAR 0 3
13112: PUSH
13113: LD_INT 1
13115: PPUSH
13116: LD_STRING D5b-Sol1-1
13118: PPUSH
13119: CALL 16687 0 2
13123: ST_TO_ADDR
// if not un then
13124: LD_VAR 0 3
13128: NOT
13129: IFFALSE 13147
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13131: LD_ADDR_VAR 0 3
13135: PUSH
13136: LD_INT 2
13138: PPUSH
13139: LD_STRING D5b-FSol1-1
13141: PPUSH
13142: CALL 16687 0 2
13146: ST_TO_ADDR
// if un then
13147: LD_VAR 0 3
13151: IFFALSE 13196
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13153: LD_ADDR_VAR 0 4
13157: PUSH
13158: LD_INT 1
13160: PPUSH
13161: LD_STRING D5b-Sol2-1
13163: PPUSH
13164: LD_VAR 0 3
13168: PPUSH
13169: CALL 16913 0 3
13173: ST_TO_ADDR
// if not un2 then
13174: LD_VAR 0 4
13178: NOT
13179: IFFALSE 13196
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13181: LD_INT 2
13183: PPUSH
13184: LD_STRING D5b-FSol2-1
13186: PPUSH
13187: LD_VAR 0 3
13191: PPUSH
13192: CALL 16913 0 3
// end ; DialogueOff ;
13196: CALL_OW 7
// break ;
13200: GO 13204
// end ; end ;
13202: GO 13041
13204: POP
13205: POP
// end ; if not seen [ 3 ] then
13206: LD_EXP 9
13210: PUSH
13211: LD_INT 3
13213: ARRAY
13214: NOT
13215: IFFALSE 13389
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13217: LD_ADDR_VAR 0 2
13221: PUSH
13222: LD_INT 22
13224: PUSH
13225: LD_INT 2
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 33
13234: PUSH
13235: LD_INT 2
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PPUSH
13246: CALL_OW 69
13250: ST_TO_ADDR
// if tmp then
13251: LD_VAR 0 2
13255: IFFALSE 13389
// for i in tmp do
13257: LD_ADDR_VAR 0 1
13261: PUSH
13262: LD_VAR 0 2
13266: PUSH
13267: FOR_IN
13268: IFFALSE 13387
// if See ( 1 , i ) then
13270: LD_INT 1
13272: PPUSH
13273: LD_VAR 0 1
13277: PPUSH
13278: CALL_OW 292
13282: IFFALSE 13385
// begin seen := Replace ( seen , 3 , true ) ;
13284: LD_ADDR_EXP 9
13288: PUSH
13289: LD_EXP 9
13293: PPUSH
13294: LD_INT 3
13296: PPUSH
13297: LD_INT 1
13299: PPUSH
13300: CALL_OW 1
13304: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13305: LD_INT 1
13307: PPUSH
13308: CALL 16509 0 1
13312: IFFALSE 13385
// begin DialogueOn ;
13314: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13318: LD_VAR 0 1
13322: PPUSH
13323: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13327: LD_INT 10
13329: PPUSH
13330: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13334: LD_ADDR_VAR 0 3
13338: PUSH
13339: LD_INT 1
13341: PPUSH
13342: LD_STRING D8-Sol1-1
13344: PPUSH
13345: CALL 16687 0 2
13349: ST_TO_ADDR
// if not un then
13350: LD_VAR 0 3
13354: NOT
13355: IFFALSE 13367
// SayRand ( sex_female , D8-FSol1-1 ) ;
13357: LD_INT 2
13359: PPUSH
13360: LD_STRING D8-FSol1-1
13362: PPUSH
13363: CALL 16687 0 2
// Say ( JMM , D8-JMM-1 ) ;
13367: LD_EXP 21
13371: PPUSH
13372: LD_STRING D8-JMM-1
13374: PPUSH
13375: CALL_OW 88
// DialogueOff ;
13379: CALL_OW 7
// break ;
13383: GO 13387
// end ; end ;
13385: GO 13267
13387: POP
13388: POP
// end ; if not seen [ 4 ] then
13389: LD_EXP 9
13393: PUSH
13394: LD_INT 4
13396: ARRAY
13397: NOT
13398: IFFALSE 13560
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13400: LD_ADDR_VAR 0 2
13404: PUSH
13405: LD_INT 22
13407: PUSH
13408: LD_INT 2
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PUSH
13415: LD_INT 33
13417: PUSH
13418: LD_INT 5
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PPUSH
13429: CALL_OW 69
13433: ST_TO_ADDR
// if tmp then
13434: LD_VAR 0 2
13438: IFFALSE 13560
// for i in tmp do
13440: LD_ADDR_VAR 0 1
13444: PUSH
13445: LD_VAR 0 2
13449: PUSH
13450: FOR_IN
13451: IFFALSE 13558
// if See ( 1 , i ) then
13453: LD_INT 1
13455: PPUSH
13456: LD_VAR 0 1
13460: PPUSH
13461: CALL_OW 292
13465: IFFALSE 13556
// begin seen := Replace ( seen , 4 , true ) ;
13467: LD_ADDR_EXP 9
13471: PUSH
13472: LD_EXP 9
13476: PPUSH
13477: LD_INT 4
13479: PPUSH
13480: LD_INT 1
13482: PPUSH
13483: CALL_OW 1
13487: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13488: LD_INT 1
13490: PPUSH
13491: CALL 16509 0 1
13495: IFFALSE 13556
// begin DialogueOn ;
13497: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13501: LD_VAR 0 1
13505: PPUSH
13506: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13510: LD_INT 10
13512: PPUSH
13513: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13517: LD_ADDR_VAR 0 3
13521: PUSH
13522: LD_INT 1
13524: PPUSH
13525: LD_STRING D5a-Sol1-1
13527: PPUSH
13528: CALL 16687 0 2
13532: ST_TO_ADDR
// if not un then
13533: LD_VAR 0 3
13537: NOT
13538: IFFALSE 13550
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13540: LD_INT 2
13542: PPUSH
13543: LD_STRING D5a-FSol1-1
13545: PPUSH
13546: CALL 16687 0 2
// DialogueOff ;
13550: CALL_OW 7
// break ;
13554: GO 13558
// end ; end ;
13556: GO 13450
13558: POP
13559: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13560: LD_EXP 9
13564: PUSH
13565: LD_INT 5
13567: ARRAY
13568: NOT
13569: PUSH
13570: LD_EXP 9
13574: PUSH
13575: LD_INT 3
13577: ARRAY
13578: AND
13579: IFFALSE 13753
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13581: LD_ADDR_VAR 0 2
13585: PUSH
13586: LD_INT 22
13588: PUSH
13589: LD_INT 2
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 34
13598: PUSH
13599: LD_INT 31
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: PPUSH
13610: CALL_OW 69
13614: ST_TO_ADDR
// if tmp then
13615: LD_VAR 0 2
13619: IFFALSE 13753
// for i in tmp do
13621: LD_ADDR_VAR 0 1
13625: PUSH
13626: LD_VAR 0 2
13630: PUSH
13631: FOR_IN
13632: IFFALSE 13751
// if See ( 1 , i ) then
13634: LD_INT 1
13636: PPUSH
13637: LD_VAR 0 1
13641: PPUSH
13642: CALL_OW 292
13646: IFFALSE 13749
// begin seen := Replace ( seen , 5 , true ) ;
13648: LD_ADDR_EXP 9
13652: PUSH
13653: LD_EXP 9
13657: PPUSH
13658: LD_INT 5
13660: PPUSH
13661: LD_INT 1
13663: PPUSH
13664: CALL_OW 1
13668: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13669: LD_INT 1
13671: PPUSH
13672: CALL 16509 0 1
13676: IFFALSE 13749
// begin DialogueOn ;
13678: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13691: LD_INT 10
13693: PPUSH
13694: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13698: LD_ADDR_VAR 0 3
13702: PUSH
13703: LD_INT 1
13705: PPUSH
13706: LD_STRING D8a-Sol2-1
13708: PPUSH
13709: CALL 16687 0 2
13713: ST_TO_ADDR
// if not un then
13714: LD_VAR 0 3
13718: NOT
13719: IFFALSE 13731
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13721: LD_INT 2
13723: PPUSH
13724: LD_STRING D8a-FSol2-1
13726: PPUSH
13727: CALL 16687 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13731: LD_EXP 21
13735: PPUSH
13736: LD_STRING D8a-JMM-1
13738: PPUSH
13739: CALL_OW 88
// DialogueOff ;
13743: CALL_OW 7
// break ;
13747: GO 13751
// end ; end ;
13749: GO 13631
13751: POP
13752: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13753: LD_EXP 9
13757: PUSH
13758: LD_INT 1
13760: ARRAY
13761: PUSH
13762: LD_EXP 9
13766: PUSH
13767: LD_INT 2
13769: ARRAY
13770: AND
13771: PUSH
13772: LD_EXP 9
13776: PUSH
13777: LD_INT 3
13779: ARRAY
13780: AND
13781: PUSH
13782: LD_EXP 9
13786: PUSH
13787: LD_INT 4
13789: ARRAY
13790: AND
13791: PUSH
13792: LD_EXP 9
13796: PUSH
13797: LD_INT 5
13799: ARRAY
13800: AND
13801: IFFALSE 13804
// disable ;
13803: DISABLE
// end ;
13804: PPOPN 4
13806: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13807: LD_EXP 10
13811: PUSH
13812: LD_EXP 11
13816: AND
13817: IFFALSE 14015
13819: GO 13821
13821: DISABLE
13822: LD_INT 0
13824: PPUSH
// begin DialogueOn ;
13825: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13829: LD_EXP 11
13833: PPUSH
13834: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_INT 1
13845: PPUSH
13846: LD_STRING D5c-Sol1-1
13848: PPUSH
13849: CALL 16687 0 2
13853: ST_TO_ADDR
// if not un then
13854: LD_VAR 0 1
13858: NOT
13859: IFFALSE 13877
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13861: LD_ADDR_VAR 0 1
13865: PUSH
13866: LD_INT 2
13868: PPUSH
13869: LD_STRING D5c-FSol1-1
13871: PPUSH
13872: CALL 16687 0 2
13876: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13877: LD_EXP 21
13881: PPUSH
13882: LD_STRING D5c-JMM-1
13884: PPUSH
13885: CALL_OW 88
// if IsOk ( Lisa ) then
13889: LD_EXP 22
13893: PPUSH
13894: CALL_OW 302
13898: IFFALSE 13914
// Say ( Lisa , D5d-Lisa-1 ) else
13900: LD_EXP 22
13904: PPUSH
13905: LD_STRING D5d-Lisa-1
13907: PPUSH
13908: CALL_OW 88
13912: GO 13999
// if IsOk ( Cyrus ) then
13914: LD_EXP 25
13918: PPUSH
13919: CALL_OW 302
13923: IFFALSE 13939
// Say ( Cyrus , D5d-Cyrus-1 ) else
13925: LD_EXP 25
13929: PPUSH
13930: LD_STRING D5d-Cyrus-1
13932: PPUSH
13933: CALL_OW 88
13937: GO 13999
// if IsOk ( Gary ) then
13939: LD_EXP 32
13943: PPUSH
13944: CALL_OW 302
13948: IFFALSE 13964
// Say ( Gary , D5d-Gary-1 ) else
13950: LD_EXP 32
13954: PPUSH
13955: LD_STRING D5d-Gary-1
13957: PPUSH
13958: CALL_OW 88
13962: GO 13999
// if GetSex ( un ) = sex_male then
13964: LD_VAR 0 1
13968: PPUSH
13969: CALL_OW 258
13973: PUSH
13974: LD_INT 1
13976: EQUAL
13977: IFFALSE 13993
// Say ( un , D5d-Sol1-1 ) else
13979: LD_VAR 0 1
13983: PPUSH
13984: LD_STRING D5d-Sol1-1
13986: PPUSH
13987: CALL_OW 88
13991: GO 13999
// begin DialogueOff ;
13993: CALL_OW 7
// exit ;
13997: GO 14015
// end ; Say ( JMM , D5d-JMM-1 ) ;
13999: LD_EXP 21
14003: PPUSH
14004: LD_STRING D5d-JMM-1
14006: PPUSH
14007: CALL_OW 88
// DialogueOff ;
14011: CALL_OW 7
// end ;
14015: PPOPN 1
14017: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14018: LD_INT 1
14020: PPUSH
14021: LD_INT 17
14023: PPUSH
14024: CALL_OW 294
14028: PUSH
14029: LD_INT 2
14031: GREATEREQUAL
14032: IFFALSE 14164
14034: GO 14036
14036: DISABLE
14037: LD_INT 0
14039: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14040: LD_INT 10
14042: PPUSH
14043: LD_INT 5
14045: PPUSH
14046: LD_INT 1
14048: PPUSH
14049: LD_INT 10
14051: NEG
14052: PPUSH
14053: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14057: LD_INT 10
14059: PPUSH
14060: LD_INT 5
14062: PPUSH
14063: LD_INT 1
14065: PPUSH
14066: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14070: LD_INT 10
14072: PPUSH
14073: LD_INT 5
14075: PPUSH
14076: CALL_OW 86
// DialogueOn ;
14080: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14084: LD_ADDR_VAR 0 1
14088: PUSH
14089: LD_INT 1
14091: PPUSH
14092: LD_STRING D6-Sci1-1
14094: PPUSH
14095: CALL 16687 0 2
14099: ST_TO_ADDR
// if un then
14100: LD_VAR 0 1
14104: IFFALSE 14142
// begin Say ( JMM , D6-JMM-1 ) ;
14106: LD_EXP 21
14110: PPUSH
14111: LD_STRING D6-JMM-1
14113: PPUSH
14114: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_STRING D6-Sci1-2
14125: PPUSH
14126: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14130: LD_EXP 21
14134: PPUSH
14135: LD_STRING D6-JMM-2
14137: PPUSH
14138: CALL_OW 88
// end ; DialogueOff ;
14142: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14146: LD_STRING M3
14148: PPUSH
14149: CALL_OW 337
// wait ( 0 0$30 ) ;
14153: LD_INT 1050
14155: PPUSH
14156: CALL_OW 67
// AmericanReinforcements ;
14160: CALL 2335 0 0
// end ;
14164: PPOPN 1
14166: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14167: LD_OWVAR 1
14171: PUSH
14172: LD_INT 42000
14174: GREATEREQUAL
14175: PUSH
14176: LD_INT 2
14178: PPUSH
14179: LD_INT 169
14181: PPUSH
14182: LD_INT 90
14184: PPUSH
14185: LD_INT 10
14187: PPUSH
14188: CALL 54437 0 4
14192: PUSH
14193: LD_INT 4
14195: ARRAY
14196: PUSH
14197: LD_INT 0
14199: EQUAL
14200: PUSH
14201: LD_INT 45
14203: PPUSH
14204: CALL_OW 301
14208: OR
14209: PUSH
14210: LD_INT 45
14212: PPUSH
14213: CALL_OW 255
14217: PUSH
14218: LD_INT 1
14220: EQUAL
14221: OR
14222: AND
14223: PUSH
14224: LD_INT 94
14226: PPUSH
14227: CALL_OW 301
14231: NOT
14232: AND
14233: IFFALSE 15438
14235: GO 14237
14237: DISABLE
14238: LD_INT 0
14240: PPUSH
14241: PPUSH
14242: PPUSH
14243: PPUSH
14244: PPUSH
// begin uc_side := 5 ;
14245: LD_ADDR_OWVAR 20
14249: PUSH
14250: LD_INT 5
14252: ST_TO_ADDR
// uc_nation := 2 ;
14253: LD_ADDR_OWVAR 21
14257: PUSH
14258: LD_INT 2
14260: ST_TO_ADDR
// InitHc ;
14261: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14265: LD_INT 1
14267: PPUSH
14268: LD_INT 3
14270: PPUSH
14271: LD_INT 8
14273: PPUSH
14274: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14278: LD_ADDR_OWVAR 29
14282: PUSH
14283: LD_INT 12
14285: PUSH
14286: LD_INT 12
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: ST_TO_ADDR
// hc_name := Hans Fliege ;
14293: LD_ADDR_OWVAR 26
14297: PUSH
14298: LD_STRING Hans Fliege
14300: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14301: LD_ADDR_OWVAR 33
14305: PUSH
14306: LD_STRING SecondCharsGal
14308: ST_TO_ADDR
// hc_face_number := 7 ;
14309: LD_ADDR_OWVAR 34
14313: PUSH
14314: LD_INT 7
14316: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14317: LD_ADDR_EXP 46
14321: PUSH
14322: CALL_OW 44
14326: ST_TO_ADDR
// InitHc ;
14327: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14331: LD_INT 1
14333: PPUSH
14334: LD_INT 16
14336: PPUSH
14337: LD_INT 2
14339: PPUSH
14340: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14344: LD_ADDR_OWVAR 29
14348: PUSH
14349: LD_INT 12
14351: PUSH
14352: LD_INT 12
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: ST_TO_ADDR
// hc_name :=  ;
14359: LD_ADDR_OWVAR 26
14363: PUSH
14364: LD_STRING 
14366: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14367: LD_ADDR_EXP 47
14371: PUSH
14372: CALL_OW 44
14376: ST_TO_ADDR
// InitHc ;
14377: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14381: LD_INT 35
14383: PPUSH
14384: CALL_OW 67
// until not InBattle ( 1 ) ;
14388: LD_INT 1
14390: PPUSH
14391: CALL_OW 463
14395: NOT
14396: IFFALSE 14381
// wait ( 0 0$5 ) ;
14398: LD_INT 175
14400: PPUSH
14401: CALL_OW 67
// DialogueOn ;
14405: CALL_OW 6
// InGameOn ;
14409: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14413: LD_ADDR_VAR 0 1
14417: PUSH
14418: LD_INT 22
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: LD_INT 2
14430: PUSH
14431: LD_INT 25
14433: PUSH
14434: LD_INT 1
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: LD_INT 25
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 25
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: LD_INT 25
14463: PUSH
14464: LD_INT 4
14466: PUSH
14467: EMPTY
14468: LIST
14469: LIST
14470: PUSH
14471: LD_INT 25
14473: PUSH
14474: LD_INT 5
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 25
14483: PUSH
14484: LD_INT 8
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: EMPTY
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: PPUSH
14504: CALL_OW 69
14508: PUSH
14509: LD_EXP 21
14513: PUSH
14514: LD_EXP 22
14518: PUSH
14519: LD_EXP 23
14523: PUSH
14524: LD_EXP 24
14528: PUSH
14529: LD_EXP 25
14533: PUSH
14534: LD_EXP 26
14538: PUSH
14539: LD_EXP 27
14543: PUSH
14544: LD_EXP 28
14548: PUSH
14549: LD_EXP 29
14553: PUSH
14554: LD_EXP 31
14558: PUSH
14559: LD_EXP 32
14563: PUSH
14564: LD_EXP 33
14568: PUSH
14569: LD_EXP 34
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: DIFF
14589: PPUSH
14590: LD_INT 26
14592: PUSH
14593: LD_INT 1
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: PPUSH
14600: CALL_OW 72
14604: PUSH
14605: LD_INT 1
14607: ARRAY
14608: ST_TO_ADDR
// if Brown then
14609: LD_EXP 27
14613: IFFALSE 14625
// un := Brown ;
14615: LD_ADDR_VAR 0 1
14619: PUSH
14620: LD_EXP 27
14624: ST_TO_ADDR
// if un then
14625: LD_VAR 0 1
14629: IFFALSE 14655
// begin Say ( un , D7-Sol1-1 ) ;
14631: LD_VAR 0 1
14635: PPUSH
14636: LD_STRING D7-Sol1-1
14638: PPUSH
14639: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14643: LD_EXP 21
14647: PPUSH
14648: LD_STRING D7-JMM-1
14650: PPUSH
14651: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14655: LD_EXP 46
14659: PPUSH
14660: LD_STRING D7-Ar1-1
14662: PPUSH
14663: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14667: LD_EXP 21
14671: PPUSH
14672: LD_STRING D7-JMM-2
14674: PPUSH
14675: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14679: LD_EXP 46
14683: PPUSH
14684: LD_STRING D7-Ar1-2
14686: PPUSH
14687: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14691: LD_EXP 21
14695: PPUSH
14696: LD_STRING D7-JMM-3
14698: PPUSH
14699: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14703: LD_EXP 46
14707: PPUSH
14708: LD_STRING D7-Ar1-3
14710: PPUSH
14711: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14715: LD_EXP 21
14719: PPUSH
14720: LD_STRING D7-JMM-4
14722: PPUSH
14723: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14727: LD_EXP 46
14731: PPUSH
14732: LD_STRING D7-Ar1-4
14734: PPUSH
14735: CALL_OW 94
// InGameOff ;
14739: CALL_OW 9
// DialogueOff ;
14743: CALL_OW 7
// case Query ( QCameras ) of 1 :
14747: LD_STRING QCameras
14749: PPUSH
14750: CALL_OW 97
14754: PUSH
14755: LD_INT 1
14757: DOUBLE
14758: EQUAL
14759: IFTRUE 14763
14761: GO 14766
14763: POP
// ; 2 :
14764: GO 14780
14766: LD_INT 2
14768: DOUBLE
14769: EQUAL
14770: IFTRUE 14774
14772: GO 14779
14774: POP
// exit ; end ;
14775: GO 15438
14777: GO 14780
14779: POP
// ChangeMissionObjectives ( MCar ) ;
14780: LD_STRING MCar
14782: PPUSH
14783: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14787: LD_INT 124
14789: PPUSH
14790: LD_INT 90
14792: PPUSH
14793: LD_INT 1
14795: PPUSH
14796: LD_INT 6
14798: NEG
14799: PPUSH
14800: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14804: LD_INT 124
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 1
14812: PPUSH
14813: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14817: LD_INT 12
14819: PPUSH
14820: LD_INT 1
14822: PPUSH
14823: CALL_OW 424
// wait ( 3 ) ;
14827: LD_INT 3
14829: PPUSH
14830: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14834: LD_INT 124
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 86
// cargo := false ;
14844: LD_ADDR_VAR 0 3
14848: PUSH
14849: LD_INT 0
14851: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14852: LD_INT 35
14854: PPUSH
14855: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14859: LD_ADDR_VAR 0 3
14863: PUSH
14864: LD_INT 12
14866: PPUSH
14867: LD_INT 32
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PUSH
14877: LD_INT 34
14879: PUSH
14880: LD_INT 32
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PUSH
14887: LD_INT 58
14889: PUSH
14890: EMPTY
14891: LIST
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: LIST
14897: PPUSH
14898: CALL_OW 70
14902: ST_TO_ADDR
// until cargo ;
14903: LD_VAR 0 3
14907: IFFALSE 14852
// cargo := cargo [ 1 ] ;
14909: LD_ADDR_VAR 0 3
14913: PUSH
14914: LD_VAR 0 3
14918: PUSH
14919: LD_INT 1
14921: ARRAY
14922: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14923: LD_VAR 0 3
14927: PPUSH
14928: LD_INT 5
14930: PPUSH
14931: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14935: LD_INT 12
14937: PPUSH
14938: LD_INT 0
14940: PPUSH
14941: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14945: LD_EXP 46
14949: PPUSH
14950: LD_INT 11
14952: PPUSH
14953: LD_INT 0
14955: PPUSH
14956: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14960: LD_EXP 47
14964: PPUSH
14965: LD_INT 11
14967: PPUSH
14968: LD_INT 0
14970: PPUSH
14971: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14975: LD_EXP 46
14979: PUSH
14980: LD_EXP 47
14984: PUSH
14985: EMPTY
14986: LIST
14987: LIST
14988: PPUSH
14989: LD_INT 12
14991: PPUSH
14992: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14996: LD_EXP 46
15000: PPUSH
15001: LD_VAR 0 3
15005: PPUSH
15006: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15010: LD_EXP 46
15014: PUSH
15015: LD_EXP 47
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PPUSH
15024: LD_INT 209
15026: PPUSH
15027: LD_INT 178
15029: PPUSH
15030: CALL_OW 171
// escaped := 0 ;
15034: LD_ADDR_VAR 0 5
15038: PUSH
15039: LD_INT 0
15041: ST_TO_ADDR
// while ( true ) do
15042: LD_INT 1
15044: IFFALSE 15260
// begin wait ( 0 0$1 ) ;
15046: LD_INT 35
15048: PPUSH
15049: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15053: LD_EXP 46
15057: PPUSH
15058: CALL_OW 314
15062: NOT
15063: PUSH
15064: LD_EXP 47
15068: PPUSH
15069: CALL_OW 314
15073: NOT
15074: OR
15075: IFFALSE 15101
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15077: LD_EXP 46
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: PPUSH
15091: LD_INT 209
15093: PPUSH
15094: LD_INT 178
15096: PPUSH
15097: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15101: LD_EXP 46
15105: PPUSH
15106: LD_INT 10
15108: PPUSH
15109: CALL_OW 308
15113: IFFALSE 15138
// begin RemoveUnit ( ar_mechanic ) ;
15115: LD_EXP 46
15119: PPUSH
15120: CALL_OW 64
// escaped := escaped + 1 ;
15124: LD_ADDR_VAR 0 5
15128: PUSH
15129: LD_VAR 0 5
15133: PUSH
15134: LD_INT 1
15136: PLUS
15137: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15138: LD_EXP 47
15142: PPUSH
15143: LD_INT 10
15145: PPUSH
15146: CALL_OW 308
15150: IFFALSE 15175
// begin RemoveUnit ( ar_mechanic_friend ) ;
15152: LD_EXP 47
15156: PPUSH
15157: CALL_OW 64
// escaped := escaped + 1 ;
15161: LD_ADDR_VAR 0 5
15165: PUSH
15166: LD_VAR 0 5
15170: PUSH
15171: LD_INT 1
15173: PLUS
15174: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15175: LD_VAR 0 3
15179: PPUSH
15180: LD_INT 10
15182: PPUSH
15183: CALL_OW 308
15187: IFFALSE 15198
// RemoveUnit ( cargo ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15198: LD_EXP 46
15202: PPUSH
15203: CALL_OW 305
15207: NOT
15208: PUSH
15209: LD_VAR 0 5
15213: PUSH
15214: LD_INT 2
15216: GREATEREQUAL
15217: AND
15218: IFFALSE 15222
// break ;
15220: GO 15260
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15222: LD_EXP 46
15226: PPUSH
15227: CALL_OW 305
15231: NOT
15232: PUSH
15233: LD_EXP 47
15237: PPUSH
15238: CALL_OW 305
15242: NOT
15243: AND
15244: PUSH
15245: LD_VAR 0 5
15249: PUSH
15250: LD_INT 2
15252: LESS
15253: AND
15254: IFFALSE 15258
// exit ;
15256: GO 15438
// end ;
15258: GO 15042
// wait ( 0 0$2 ) ;
15260: LD_INT 70
15262: PPUSH
15263: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15267: LD_EXP 46
15271: PPUSH
15272: LD_STRING D7a-Ar1-1
15274: PPUSH
15275: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15279: LD_ADDR_VAR 0 4
15283: PUSH
15284: LD_INT 129
15286: PUSH
15287: LD_INT 10
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PUSH
15294: LD_INT 103
15296: PUSH
15297: LD_INT 6
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PUSH
15304: LD_INT 148
15306: PUSH
15307: LD_INT 47
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 155
15316: PUSH
15317: LD_INT 16
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: ST_TO_ADDR
// if Difficulty = 1 then
15330: LD_OWVAR 67
15334: PUSH
15335: LD_INT 1
15337: EQUAL
15338: IFFALSE 15375
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15340: LD_ADDR_VAR 0 4
15344: PUSH
15345: LD_VAR 0 4
15349: PUSH
15350: LD_INT 78
15352: PUSH
15353: LD_INT 7
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PUSH
15360: LD_INT 104
15362: PUSH
15363: LD_INT 43
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: ADD
15374: ST_TO_ADDR
// for i in tmp do
15375: LD_ADDR_VAR 0 2
15379: PUSH
15380: LD_VAR 0 4
15384: PUSH
15385: FOR_IN
15386: IFFALSE 15419
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15388: LD_VAR 0 2
15392: PUSH
15393: LD_INT 1
15395: ARRAY
15396: PPUSH
15397: LD_VAR 0 2
15401: PUSH
15402: LD_INT 2
15404: ARRAY
15405: PPUSH
15406: LD_INT 1
15408: PPUSH
15409: LD_INT 9
15411: NEG
15412: PPUSH
15413: CALL_OW 330
15417: GO 15385
15419: POP
15420: POP
// SetAchievement ( ACH_FRIEND ) ;
15421: LD_STRING ACH_FRIEND
15423: PPUSH
15424: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15428: LD_INT 129
15430: PPUSH
15431: LD_INT 10
15433: PPUSH
15434: CALL_OW 84
// end ;
15438: PPOPN 5
15440: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15441: LD_EXP 15
15445: PUSH
15446: LD_INT 21000
15448: MINUS
15449: PUSH
15450: LD_OWVAR 1
15454: LESSEQUAL
15455: IFFALSE 15495
15457: GO 15459
15459: DISABLE
// begin powell_warn := true ;
15460: LD_ADDR_EXP 16
15464: PUSH
15465: LD_INT 1
15467: ST_TO_ADDR
// DialogueOn ;
15468: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15472: LD_EXP 30
15476: PPUSH
15477: LD_STRING D9-Pow-1
15479: PPUSH
15480: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15484: LD_INT 10
15486: PPUSH
15487: CALL_OW 68
// DialogueOff ;
15491: CALL_OW 7
// end ;
15495: END
// every 0 0$1 trigger game_time <= tick do
15496: LD_EXP 15
15500: PUSH
15501: LD_OWVAR 1
15505: LESSEQUAL
15506: IFFALSE 15545
15508: GO 15510
15510: DISABLE
// begin DialogueOn ;
15511: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15515: LD_EXP 30
15519: PPUSH
15520: LD_STRING D9a-Pow-1
15522: PPUSH
15523: CALL_OW 94
// dwait ( 0 0$2 ) ;
15527: LD_INT 70
15529: PPUSH
15530: CALL_OW 68
// DialogueOff ;
15534: CALL_OW 7
// YouLost ( Command ) ;
15538: LD_STRING Command
15540: PPUSH
15541: CALL_OW 104
// end ;
15545: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15546: LD_INT 22
15548: PUSH
15549: LD_INT 2
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PUSH
15556: LD_INT 30
15558: PUSH
15559: LD_INT 1
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PPUSH
15570: CALL_OW 69
15574: PUSH
15575: LD_INT 0
15577: EQUAL
15578: PUSH
15579: LD_EXP 21
15583: PPUSH
15584: CALL_OW 302
15588: AND
15589: IFFALSE 16506
15591: GO 15593
15593: DISABLE
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// begin m1 := false ;
15600: LD_ADDR_VAR 0 2
15604: PUSH
15605: LD_INT 0
15607: ST_TO_ADDR
// m2 := false ;
15608: LD_ADDR_VAR 0 3
15612: PUSH
15613: LD_INT 0
15615: ST_TO_ADDR
// m3 := false ;
15616: LD_ADDR_VAR 0 4
15620: PUSH
15621: LD_INT 0
15623: ST_TO_ADDR
// if not am_veh_consturcted then
15624: LD_EXP 20
15628: NOT
15629: IFFALSE 15638
// SetAchievement ( ACH_ARABTECH ) ;
15631: LD_STRING ACH_ARABTECH
15633: PPUSH
15634: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15638: LD_OWVAR 1
15642: PUSH
15643: LD_INT 252000
15645: PUSH
15646: LD_INT 210000
15648: PUSH
15649: LD_INT 199500
15651: PUSH
15652: LD_INT 193200
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: LIST
15659: LIST
15660: PUSH
15661: LD_OWVAR 67
15665: ARRAY
15666: LESS
15667: IFFALSE 15689
// begin m3 := true ;
15669: LD_ADDR_VAR 0 4
15673: PUSH
15674: LD_INT 1
15676: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15677: LD_STRING Time1
15679: PPUSH
15680: LD_INT 1
15682: PPUSH
15683: CALL_OW 101
// end else
15687: GO 15720
// if not powell_warn then
15689: LD_EXP 16
15693: NOT
15694: IFFALSE 15709
// AddMedal ( Time1 , - 1 ) else
15696: LD_STRING Time1
15698: PPUSH
15699: LD_INT 1
15701: NEG
15702: PPUSH
15703: CALL_OW 101
15707: GO 15720
// AddMedal ( Time1 , - 2 ) ;
15709: LD_STRING Time1
15711: PPUSH
15712: LD_INT 2
15714: NEG
15715: PPUSH
15716: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15720: LD_EXP 17
15724: PUSH
15725: LD_INT 5
15727: PUSH
15728: LD_INT 4
15730: PUSH
15731: LD_INT 3
15733: PUSH
15734: LD_INT 3
15736: PUSH
15737: EMPTY
15738: LIST
15739: LIST
15740: LIST
15741: LIST
15742: PUSH
15743: LD_OWVAR 67
15747: ARRAY
15748: GREATEREQUAL
15749: IFFALSE 15764
// AddMedal ( Destroy , - 2 ) else
15751: LD_STRING Destroy
15753: PPUSH
15754: LD_INT 2
15756: NEG
15757: PPUSH
15758: CALL_OW 101
15762: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15764: LD_INT 22
15766: PUSH
15767: LD_INT 2
15769: PUSH
15770: EMPTY
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 21
15776: PUSH
15777: LD_INT 3
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PUSH
15784: LD_INT 50
15786: PUSH
15787: EMPTY
15788: LIST
15789: PUSH
15790: EMPTY
15791: LIST
15792: LIST
15793: LIST
15794: PPUSH
15795: CALL_OW 69
15799: PUSH
15800: LD_INT 25
15802: GREATEREQUAL
15803: IFFALSE 15818
// AddMedal ( Destroy , - 1 ) else
15805: LD_STRING Destroy
15807: PPUSH
15808: LD_INT 1
15810: NEG
15811: PPUSH
15812: CALL_OW 101
15816: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15818: LD_INT 22
15820: PUSH
15821: LD_INT 2
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: PUSH
15828: LD_INT 21
15830: PUSH
15831: LD_INT 3
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 50
15840: PUSH
15841: EMPTY
15842: LIST
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: LIST
15848: PPUSH
15849: CALL_OW 69
15853: PUSH
15854: LD_INT 15
15856: GREATEREQUAL
15857: IFFALSE 15879
// begin m1 := true ;
15859: LD_ADDR_VAR 0 2
15863: PUSH
15864: LD_INT 1
15866: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15867: LD_STRING Destroy
15869: PPUSH
15870: LD_INT 1
15872: PPUSH
15873: CALL_OW 101
// end else
15877: GO 15897
// begin m1 := true ;
15879: LD_ADDR_VAR 0 2
15883: PUSH
15884: LD_INT 1
15886: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15887: LD_STRING Destroy
15889: PPUSH
15890: LD_INT 2
15892: PPUSH
15893: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15897: LD_EXP 13
15901: PPUSH
15902: LD_STRING 11_artifact_captured
15904: PPUSH
15905: CALL_OW 39
// if artifact_get then
15909: LD_EXP 13
15913: IFFALSE 15935
// begin m2 := true ;
15915: LD_ADDR_VAR 0 3
15919: PUSH
15920: LD_INT 1
15922: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15923: LD_STRING Artefact
15925: PPUSH
15926: LD_INT 1
15928: PPUSH
15929: CALL_OW 101
// end else
15933: GO 15946
// AddMedal ( Artefact , - 1 ) ;
15935: LD_STRING Artefact
15937: PPUSH
15938: LD_INT 1
15940: NEG
15941: PPUSH
15942: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15946: LD_VAR 0 2
15950: PUSH
15951: LD_VAR 0 3
15955: AND
15956: PUSH
15957: LD_VAR 0 4
15961: AND
15962: PUSH
15963: LD_OWVAR 67
15967: PUSH
15968: LD_INT 3
15970: GREATEREQUAL
15971: AND
15972: IFFALSE 15984
// SetAchievementEX ( ACH_AMER , 11 ) ;
15974: LD_STRING ACH_AMER
15976: PPUSH
15977: LD_INT 11
15979: PPUSH
15980: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15984: LD_VAR 0 2
15988: PUSH
15989: LD_VAR 0 3
15993: AND
15994: PUSH
15995: LD_VAR 0 4
15999: AND
16000: PUSH
16001: LD_EXP 17
16005: PUSH
16006: LD_INT 0
16008: EQUAL
16009: AND
16010: IFFALSE 16026
// begin wait ( 3 ) ;
16012: LD_INT 3
16014: PPUSH
16015: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16019: LD_STRING ACH_GENERAL
16021: PPUSH
16022: CALL_OW 543
// end ; if tick <= 100 100$00 then
16026: LD_OWVAR 1
16030: PUSH
16031: LD_INT 210000
16033: LESSEQUAL
16034: IFFALSE 16050
// begin wait ( 3 ) ;
16036: LD_INT 3
16038: PPUSH
16039: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16043: LD_STRING ACH_ASPEED_11
16045: PPUSH
16046: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16050: LD_STRING MAIN
16052: PPUSH
16053: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16057: LD_ADDR_EXP 19
16061: PUSH
16062: LD_EXP 19
16066: PPUSH
16067: LD_INT 51
16069: PUSH
16070: EMPTY
16071: LIST
16072: PPUSH
16073: CALL_OW 72
16077: ST_TO_ADDR
// tmp := JMM ^ selected ;
16078: LD_ADDR_VAR 0 1
16082: PUSH
16083: LD_EXP 21
16087: PUSH
16088: LD_EXP 19
16092: ADD
16093: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16094: LD_VAR 0 1
16098: PPUSH
16099: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16103: LD_VAR 0 1
16107: PUSH
16108: LD_EXP 21
16112: PUSH
16113: LD_EXP 22
16117: PUSH
16118: LD_EXP 23
16122: PUSH
16123: LD_EXP 24
16127: PUSH
16128: LD_EXP 25
16132: PUSH
16133: LD_EXP 26
16137: PUSH
16138: LD_EXP 27
16142: PUSH
16143: LD_EXP 28
16147: PUSH
16148: LD_EXP 29
16152: PUSH
16153: LD_EXP 31
16157: PUSH
16158: LD_EXP 32
16162: PUSH
16163: LD_EXP 33
16167: PUSH
16168: LD_EXP 34
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: DIFF
16188: PPUSH
16189: LD_STRING 11c_others
16191: PPUSH
16192: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16196: LD_EXP 21
16200: PPUSH
16201: LD_EXP 3
16205: PUSH
16206: LD_STRING JMM
16208: STR
16209: PPUSH
16210: CALL_OW 38
// if Lisa then
16214: LD_EXP 22
16218: IFFALSE 16238
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16220: LD_EXP 22
16224: PPUSH
16225: LD_EXP 3
16229: PUSH
16230: LD_STRING Lisa
16232: STR
16233: PPUSH
16234: CALL_OW 38
// if Donaldson then
16238: LD_EXP 23
16242: IFFALSE 16262
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16244: LD_EXP 23
16248: PPUSH
16249: LD_EXP 3
16253: PUSH
16254: LD_STRING Donaldson
16256: STR
16257: PPUSH
16258: CALL_OW 38
// if Bobby then
16262: LD_EXP 24
16266: IFFALSE 16286
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16268: LD_EXP 24
16272: PPUSH
16273: LD_EXP 3
16277: PUSH
16278: LD_STRING Bobby
16280: STR
16281: PPUSH
16282: CALL_OW 38
// if Cyrus then
16286: LD_EXP 25
16290: IFFALSE 16310
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16292: LD_EXP 25
16296: PPUSH
16297: LD_EXP 3
16301: PUSH
16302: LD_STRING Cyrus
16304: STR
16305: PPUSH
16306: CALL_OW 38
// if Denis then
16310: LD_EXP 26
16314: IFFALSE 16334
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16316: LD_EXP 26
16320: PPUSH
16321: LD_EXP 3
16325: PUSH
16326: LD_STRING Denis
16328: STR
16329: PPUSH
16330: CALL_OW 38
// if Brown then
16334: LD_EXP 27
16338: IFFALSE 16358
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16340: LD_EXP 27
16344: PPUSH
16345: LD_EXP 3
16349: PUSH
16350: LD_STRING Brown
16352: STR
16353: PPUSH
16354: CALL_OW 38
// if Gladstone then
16358: LD_EXP 28
16362: IFFALSE 16382
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16364: LD_EXP 28
16368: PPUSH
16369: LD_EXP 3
16373: PUSH
16374: LD_STRING Gladstone
16376: STR
16377: PPUSH
16378: CALL_OW 38
// if Houten then
16382: LD_EXP 29
16386: IFFALSE 16406
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16388: LD_EXP 29
16392: PPUSH
16393: LD_EXP 3
16397: PUSH
16398: LD_STRING Houten
16400: STR
16401: PPUSH
16402: CALL_OW 38
// if Cornel then
16406: LD_EXP 31
16410: IFFALSE 16430
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16412: LD_EXP 31
16416: PPUSH
16417: LD_EXP 3
16421: PUSH
16422: LD_STRING Cornell
16424: STR
16425: PPUSH
16426: CALL_OW 38
// if Gary then
16430: LD_EXP 32
16434: IFFALSE 16454
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16436: LD_EXP 32
16440: PPUSH
16441: LD_EXP 3
16445: PUSH
16446: LD_STRING Gary
16448: STR
16449: PPUSH
16450: CALL_OW 38
// if Frank then
16454: LD_EXP 33
16458: IFFALSE 16478
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16460: LD_EXP 33
16464: PPUSH
16465: LD_EXP 3
16469: PUSH
16470: LD_STRING Frank
16472: STR
16473: PPUSH
16474: CALL_OW 38
// if Kikuchi then
16478: LD_EXP 34
16482: IFFALSE 16502
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16484: LD_EXP 34
16488: PPUSH
16489: LD_EXP 3
16493: PUSH
16494: LD_STRING Kikuchi
16496: STR
16497: PPUSH
16498: CALL_OW 38
// YouWin ;
16502: CALL_OW 103
// end ;
16506: PPOPN 4
16508: END
// export function CanSayRand ( side ) ; begin
16509: LD_INT 0
16511: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16512: LD_ADDR_VAR 0 2
16516: PUSH
16517: LD_INT 52
16519: PUSH
16520: EMPTY
16521: LIST
16522: PUSH
16523: LD_INT 22
16525: PUSH
16526: LD_VAR 0 1
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: PUSH
16535: LD_INT 2
16537: PUSH
16538: LD_INT 25
16540: PUSH
16541: LD_INT 1
16543: PUSH
16544: EMPTY
16545: LIST
16546: LIST
16547: PUSH
16548: LD_INT 25
16550: PUSH
16551: LD_INT 2
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: PUSH
16558: LD_INT 25
16560: PUSH
16561: LD_INT 3
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PUSH
16568: LD_INT 25
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: LIST
16582: LIST
16583: LIST
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: LIST
16589: PPUSH
16590: CALL_OW 69
16594: PUSH
16595: LD_EXP 21
16599: PUSH
16600: LD_EXP 33
16604: PUSH
16605: LD_EXP 22
16609: PUSH
16610: LD_EXP 23
16614: PUSH
16615: LD_EXP 24
16619: PUSH
16620: LD_EXP 25
16624: PUSH
16625: LD_EXP 26
16629: PUSH
16630: LD_EXP 27
16634: PUSH
16635: LD_EXP 28
16639: PUSH
16640: LD_EXP 29
16644: PUSH
16645: LD_EXP 30
16649: PUSH
16650: LD_EXP 31
16654: PUSH
16655: LD_EXP 32
16659: PUSH
16660: LD_EXP 34
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: LIST
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: LIST
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: LIST
16680: DIFF
16681: ST_TO_ADDR
// end ;
16682: LD_VAR 0 2
16686: RET
// export function SayRand ( sex , dial ) ; begin
16687: LD_INT 0
16689: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16690: LD_ADDR_VAR 0 3
16694: PUSH
16695: LD_INT 52
16697: PUSH
16698: EMPTY
16699: LIST
16700: PUSH
16701: LD_INT 22
16703: PUSH
16704: LD_INT 1
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PUSH
16711: LD_INT 26
16713: PUSH
16714: LD_VAR 0 1
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 2
16725: PUSH
16726: LD_INT 25
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: LD_INT 25
16738: PUSH
16739: LD_INT 2
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 3
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: LD_INT 25
16758: PUSH
16759: LD_INT 4
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: LIST
16777: LIST
16778: PPUSH
16779: CALL_OW 69
16783: PUSH
16784: LD_EXP 21
16788: PUSH
16789: LD_EXP 33
16793: PUSH
16794: LD_EXP 22
16798: PUSH
16799: LD_EXP 23
16803: PUSH
16804: LD_EXP 24
16808: PUSH
16809: LD_EXP 25
16813: PUSH
16814: LD_EXP 26
16818: PUSH
16819: LD_EXP 27
16823: PUSH
16824: LD_EXP 28
16828: PUSH
16829: LD_EXP 29
16833: PUSH
16834: LD_EXP 30
16838: PUSH
16839: LD_EXP 31
16843: PUSH
16844: LD_EXP 32
16848: PUSH
16849: LD_EXP 34
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: LIST
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: DIFF
16870: ST_TO_ADDR
// if not result then
16871: LD_VAR 0 3
16875: NOT
16876: IFFALSE 16880
// exit ;
16878: GO 16908
// result := result [ 1 ] ;
16880: LD_ADDR_VAR 0 3
16884: PUSH
16885: LD_VAR 0 3
16889: PUSH
16890: LD_INT 1
16892: ARRAY
16893: ST_TO_ADDR
// Say ( result , dial ) ;
16894: LD_VAR 0 3
16898: PPUSH
16899: LD_VAR 0 2
16903: PPUSH
16904: CALL_OW 88
// end ;
16908: LD_VAR 0 3
16912: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16913: LD_INT 0
16915: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16916: LD_ADDR_VAR 0 4
16920: PUSH
16921: LD_INT 22
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: LD_INT 26
16933: PUSH
16934: LD_VAR 0 1
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: PUSH
16943: LD_INT 2
16945: PUSH
16946: LD_INT 25
16948: PUSH
16949: LD_INT 1
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: PUSH
16956: LD_INT 25
16958: PUSH
16959: LD_INT 2
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: PUSH
16966: LD_INT 25
16968: PUSH
16969: LD_INT 3
16971: PUSH
16972: EMPTY
16973: LIST
16974: LIST
16975: PUSH
16976: LD_INT 25
16978: PUSH
16979: LD_INT 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: PPUSH
16998: CALL_OW 69
17002: PUSH
17003: LD_EXP 21
17007: PUSH
17008: LD_EXP 33
17012: PUSH
17013: LD_EXP 22
17017: PUSH
17018: LD_EXP 23
17022: PUSH
17023: LD_EXP 24
17027: PUSH
17028: LD_EXP 25
17032: PUSH
17033: LD_EXP 26
17037: PUSH
17038: LD_EXP 27
17042: PUSH
17043: LD_EXP 28
17047: PUSH
17048: LD_EXP 29
17052: PUSH
17053: LD_EXP 30
17057: PUSH
17058: LD_EXP 31
17062: PUSH
17063: LD_EXP 32
17067: PUSH
17068: LD_EXP 34
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: PUSH
17089: LD_VAR 0 3
17093: ADD
17094: DIFF
17095: ST_TO_ADDR
// if not result then
17096: LD_VAR 0 4
17100: NOT
17101: IFFALSE 17105
// exit ;
17103: GO 17133
// result := result [ 1 ] ;
17105: LD_ADDR_VAR 0 4
17109: PUSH
17110: LD_VAR 0 4
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// Say ( result , dial ) ;
17119: LD_VAR 0 4
17123: PPUSH
17124: LD_VAR 0 2
17128: PPUSH
17129: CALL_OW 88
// end ; end_of_file
17133: LD_VAR 0 4
17137: RET
// export function CustomEvent ( event ) ; begin
17138: LD_INT 0
17140: PPUSH
// end ;
17141: LD_VAR 0 2
17145: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL_OW 255
17155: PUSH
17156: LD_INT 1
17158: EQUAL
17159: IFFALSE 17169
// artifact_get := true ;
17161: LD_ADDR_EXP 13
17165: PUSH
17166: LD_INT 1
17168: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17169: LD_VAR 0 1
17173: PPUSH
17174: CALL_OW 255
17178: PUSH
17179: LD_INT 2
17181: EQUAL
17182: IFFALSE 17200
// begin artifact_get := false ;
17184: LD_ADDR_EXP 13
17188: PUSH
17189: LD_INT 0
17191: ST_TO_ADDR
// artifact_stolen := true ;
17192: LD_ADDR_EXP 12
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17200: LD_ADDR_EXP 14
17204: PUSH
17205: LD_INT 1
17207: ST_TO_ADDR
// end ;
17208: PPOPN 2
17210: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17211: LD_ADDR_EXP 14
17215: PUSH
17216: LD_INT 0
17218: ST_TO_ADDR
// end ;
17219: PPOPN 2
17221: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17222: LD_VAR 0 1
17226: PUSH
17227: LD_EXP 21
17231: EQUAL
17232: IFFALSE 17243
// begin YouLost ( JMM ) ;
17234: LD_STRING JMM
17236: PPUSH
17237: CALL_OW 104
// exit ;
17241: GO 17375
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17243: LD_VAR 0 1
17247: PUSH
17248: LD_INT 22
17250: PUSH
17251: LD_INT 1
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: PUSH
17258: LD_INT 21
17260: PUSH
17261: LD_INT 1
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: PUSH
17268: LD_INT 2
17270: PUSH
17271: LD_INT 25
17273: PUSH
17274: LD_INT 1
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: PUSH
17281: LD_INT 25
17283: PUSH
17284: LD_INT 2
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 25
17293: PUSH
17294: LD_INT 3
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 4
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 25
17313: PUSH
17314: LD_INT 5
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: LD_INT 25
17323: PUSH
17324: LD_INT 8
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: LIST
17344: PPUSH
17345: CALL_OW 69
17349: IN
17350: IFFALSE 17366
// loses_counter := loses_counter + 1 ;
17352: LD_ADDR_EXP 17
17356: PUSH
17357: LD_EXP 17
17361: PUSH
17362: LD_INT 1
17364: PLUS
17365: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17366: LD_VAR 0 1
17370: PPUSH
17371: CALL 45569 0 1
// end ;
17375: PPOPN 1
17377: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17378: LD_VAR 0 1
17382: PPUSH
17383: LD_VAR 0 2
17387: PPUSH
17388: CALL 47903 0 2
// end ;
17392: PPOPN 2
17394: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17395: LD_VAR 0 1
17399: PPUSH
17400: CALL 47212 0 1
// end ;
17404: PPOPN 1
17406: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17407: LD_VAR 0 1
17411: PPUSH
17412: LD_VAR 0 2
17416: PPUSH
17417: LD_VAR 0 3
17421: PPUSH
17422: LD_VAR 0 4
17426: PPUSH
17427: LD_VAR 0 5
17431: PPUSH
17432: CALL 44885 0 5
// end ;
17436: PPOPN 5
17438: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17439: LD_VAR 0 1
17443: PPUSH
17444: CALL_OW 248
17448: PUSH
17449: LD_INT 1
17451: EQUAL
17452: IFFALSE 17462
// am_veh_consturcted := true ;
17454: LD_ADDR_EXP 20
17458: PUSH
17459: LD_INT 1
17461: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17462: LD_VAR 0 1
17466: PPUSH
17467: LD_VAR 0 2
17471: PPUSH
17472: CALL 44466 0 2
// end ;
17476: PPOPN 2
17478: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17479: LD_VAR 0 1
17483: PPUSH
17484: CALL_OW 247
17488: PUSH
17489: LD_INT 2
17491: EQUAL
17492: IFFALSE 17496
// exit ;
17494: GO 17513
// if not kamikazed then
17496: LD_EXP 11
17500: NOT
17501: IFFALSE 17513
// kamikazed := unit ;
17503: LD_ADDR_EXP 11
17507: PUSH
17508: LD_VAR 0 1
17512: ST_TO_ADDR
// end ;
17513: PPOPN 1
17515: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17516: LD_INT 0
17518: PPUSH
17519: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17520: LD_VAR 0 1
17524: PPUSH
17525: LD_VAR 0 2
17529: PPUSH
17530: LD_VAR 0 3
17534: PPUSH
17535: LD_VAR 0 4
17539: PPUSH
17540: CALL 44304 0 4
// end ;
17544: PPOPN 6
17546: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17547: LD_VAR 0 1
17551: PPUSH
17552: LD_VAR 0 2
17556: PPUSH
17557: LD_VAR 0 3
17561: PPUSH
17562: CALL 44079 0 3
// end ;
17566: PPOPN 3
17568: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17569: LD_VAR 0 1
17573: PPUSH
17574: LD_VAR 0 2
17578: PPUSH
17579: CALL 45265 0 2
// end ;
17583: PPOPN 2
17585: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17586: LD_VAR 0 1
17590: PPUSH
17591: LD_VAR 0 2
17595: PPUSH
17596: CALL 43773 0 2
// end ;
17600: PPOPN 2
17602: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17603: LD_VAR 0 1
17607: PPUSH
17608: LD_VAR 0 2
17612: PPUSH
17613: CALL 43964 0 2
// end ;
17617: PPOPN 2
17619: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17620: LD_VAR 0 1
17624: PPUSH
17625: CALL 46971 0 1
// end ;
17629: PPOPN 1
17631: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17632: LD_VAR 0 1
17636: PPUSH
17637: LD_VAR 0 2
17641: PPUSH
17642: CALL 48198 0 2
// end ;
17646: PPOPN 2
17648: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17649: LD_VAR 0 1
17653: PPUSH
17654: LD_VAR 0 2
17658: PPUSH
17659: LD_VAR 0 3
17663: PPUSH
17664: LD_VAR 0 4
17668: PPUSH
17669: CALL 48414 0 4
// end ;
17673: PPOPN 4
17675: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: CALL 102169 0 1
// end ; end_of_file
17685: PPOPN 1
17687: END
// every 0 0$1 trigger game do
17688: LD_EXP 2
17692: IFFALSE 17722
17694: GO 17696
17696: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17697: LD_INT 7
17699: PUSH
17700: LD_INT 6
17702: PUSH
17703: LD_INT 4
17705: PUSH
17706: LD_INT 6
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: LIST
17714: PPUSH
17715: LD_INT 1750
17717: PPUSH
17718: CALL 17723 0 2
17722: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17723: LD_INT 0
17725: PPUSH
17726: PPUSH
17727: PPUSH
// if not areas then
17728: LD_VAR 0 1
17732: NOT
17733: IFFALSE 17737
// exit ;
17735: GO 17867
// repeat wait ( time ) ;
17737: LD_VAR 0 2
17741: PPUSH
17742: CALL_OW 67
// for i in areas do
17746: LD_ADDR_VAR 0 4
17750: PUSH
17751: LD_VAR 0 1
17755: PUSH
17756: FOR_IN
17757: IFFALSE 17826
// begin p := rand ( 1 , 90 ) ;
17759: LD_ADDR_VAR 0 5
17763: PUSH
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 90
17769: PPUSH
17770: CALL_OW 12
17774: ST_TO_ADDR
// if Prob ( p ) then
17775: LD_VAR 0 5
17779: PPUSH
17780: CALL_OW 13
17784: IFFALSE 17824
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17786: LD_INT 2
17788: PPUSH
17789: LD_INT 5
17791: PPUSH
17792: CALL_OW 12
17796: PPUSH
17797: LD_VAR 0 4
17801: PPUSH
17802: LD_INT 1
17804: PPUSH
17805: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17809: LD_INT 735
17811: PPUSH
17812: LD_INT 1295
17814: PPUSH
17815: CALL_OW 12
17819: PPUSH
17820: CALL_OW 67
// end ; end ;
17824: GO 17756
17826: POP
17827: POP
// time := time + 0 0$3 ;
17828: LD_ADDR_VAR 0 2
17832: PUSH
17833: LD_VAR 0 2
17837: PUSH
17838: LD_INT 105
17840: PLUS
17841: ST_TO_ADDR
// if time > 6 6$00 then
17842: LD_VAR 0 2
17846: PUSH
17847: LD_INT 12600
17849: GREATER
17850: IFFALSE 17860
// time := 0 0$40 ;
17852: LD_ADDR_VAR 0 2
17856: PUSH
17857: LD_INT 1400
17859: ST_TO_ADDR
// until not game ;
17860: LD_EXP 2
17864: NOT
17865: IFFALSE 17737
// end ;
17867: LD_VAR 0 3
17871: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17872: LD_OWVAR 1
17876: PUSH
17877: LD_INT 84000
17879: PUSH
17880: LD_INT 73500
17882: PUSH
17883: LD_INT 63000
17885: PUSH
17886: LD_INT 52500
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: PUSH
17895: LD_OWVAR 67
17899: ARRAY
17900: LESS
17901: IFFALSE 17928
17903: GO 17905
17905: DISABLE
// begin enable ;
17906: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17907: LD_INT 1
17909: PPUSH
17910: LD_INT 5
17912: PPUSH
17913: CALL_OW 12
17917: PPUSH
17918: LD_INT 7
17920: PPUSH
17921: LD_INT 1
17923: PPUSH
17924: CALL_OW 55
// end ; end_of_file
17928: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17929: LD_INT 0
17931: PPUSH
17932: PPUSH
// skirmish := false ;
17933: LD_ADDR_EXP 48
17937: PUSH
17938: LD_INT 0
17940: ST_TO_ADDR
// debug_mc := false ;
17941: LD_ADDR_EXP 49
17945: PUSH
17946: LD_INT 0
17948: ST_TO_ADDR
// mc_bases := [ ] ;
17949: LD_ADDR_EXP 50
17953: PUSH
17954: EMPTY
17955: ST_TO_ADDR
// mc_sides := [ ] ;
17956: LD_ADDR_EXP 76
17960: PUSH
17961: EMPTY
17962: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17963: LD_ADDR_EXP 51
17967: PUSH
17968: EMPTY
17969: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17970: LD_ADDR_EXP 52
17974: PUSH
17975: EMPTY
17976: ST_TO_ADDR
// mc_need_heal := [ ] ;
17977: LD_ADDR_EXP 53
17981: PUSH
17982: EMPTY
17983: ST_TO_ADDR
// mc_healers := [ ] ;
17984: LD_ADDR_EXP 54
17988: PUSH
17989: EMPTY
17990: ST_TO_ADDR
// mc_build_list := [ ] ;
17991: LD_ADDR_EXP 55
17995: PUSH
17996: EMPTY
17997: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17998: LD_ADDR_EXP 82
18002: PUSH
18003: EMPTY
18004: ST_TO_ADDR
// mc_builders := [ ] ;
18005: LD_ADDR_EXP 56
18009: PUSH
18010: EMPTY
18011: ST_TO_ADDR
// mc_construct_list := [ ] ;
18012: LD_ADDR_EXP 57
18016: PUSH
18017: EMPTY
18018: ST_TO_ADDR
// mc_turret_list := [ ] ;
18019: LD_ADDR_EXP 58
18023: PUSH
18024: EMPTY
18025: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18026: LD_ADDR_EXP 59
18030: PUSH
18031: EMPTY
18032: ST_TO_ADDR
// mc_miners := [ ] ;
18033: LD_ADDR_EXP 64
18037: PUSH
18038: EMPTY
18039: ST_TO_ADDR
// mc_mines := [ ] ;
18040: LD_ADDR_EXP 63
18044: PUSH
18045: EMPTY
18046: ST_TO_ADDR
// mc_minefields := [ ] ;
18047: LD_ADDR_EXP 65
18051: PUSH
18052: EMPTY
18053: ST_TO_ADDR
// mc_crates := [ ] ;
18054: LD_ADDR_EXP 66
18058: PUSH
18059: EMPTY
18060: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18061: LD_ADDR_EXP 67
18065: PUSH
18066: EMPTY
18067: ST_TO_ADDR
// mc_crates_area := [ ] ;
18068: LD_ADDR_EXP 68
18072: PUSH
18073: EMPTY
18074: ST_TO_ADDR
// mc_vehicles := [ ] ;
18075: LD_ADDR_EXP 69
18079: PUSH
18080: EMPTY
18081: ST_TO_ADDR
// mc_attack := [ ] ;
18082: LD_ADDR_EXP 70
18086: PUSH
18087: EMPTY
18088: ST_TO_ADDR
// mc_produce := [ ] ;
18089: LD_ADDR_EXP 71
18093: PUSH
18094: EMPTY
18095: ST_TO_ADDR
// mc_defender := [ ] ;
18096: LD_ADDR_EXP 72
18100: PUSH
18101: EMPTY
18102: ST_TO_ADDR
// mc_parking := [ ] ;
18103: LD_ADDR_EXP 74
18107: PUSH
18108: EMPTY
18109: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18110: LD_ADDR_EXP 60
18114: PUSH
18115: EMPTY
18116: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18117: LD_ADDR_EXP 62
18121: PUSH
18122: EMPTY
18123: ST_TO_ADDR
// mc_scan := [ ] ;
18124: LD_ADDR_EXP 73
18128: PUSH
18129: EMPTY
18130: ST_TO_ADDR
// mc_scan_area := [ ] ;
18131: LD_ADDR_EXP 75
18135: PUSH
18136: EMPTY
18137: ST_TO_ADDR
// mc_tech := [ ] ;
18138: LD_ADDR_EXP 77
18142: PUSH
18143: EMPTY
18144: ST_TO_ADDR
// mc_class := [ ] ;
18145: LD_ADDR_EXP 91
18149: PUSH
18150: EMPTY
18151: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18152: LD_ADDR_EXP 92
18156: PUSH
18157: EMPTY
18158: ST_TO_ADDR
// mc_is_defending := [ ] ;
18159: LD_ADDR_EXP 93
18163: PUSH
18164: EMPTY
18165: ST_TO_ADDR
// end ;
18166: LD_VAR 0 1
18170: RET
// export function MC_Kill ( base ) ; begin
18171: LD_INT 0
18173: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18174: LD_ADDR_EXP 50
18178: PUSH
18179: LD_EXP 50
18183: PPUSH
18184: LD_VAR 0 1
18188: PPUSH
18189: EMPTY
18190: PPUSH
18191: CALL_OW 1
18195: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18196: LD_ADDR_EXP 51
18200: PUSH
18201: LD_EXP 51
18205: PPUSH
18206: LD_VAR 0 1
18210: PPUSH
18211: EMPTY
18212: PPUSH
18213: CALL_OW 1
18217: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18218: LD_ADDR_EXP 52
18222: PUSH
18223: LD_EXP 52
18227: PPUSH
18228: LD_VAR 0 1
18232: PPUSH
18233: EMPTY
18234: PPUSH
18235: CALL_OW 1
18239: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18240: LD_ADDR_EXP 53
18244: PUSH
18245: LD_EXP 53
18249: PPUSH
18250: LD_VAR 0 1
18254: PPUSH
18255: EMPTY
18256: PPUSH
18257: CALL_OW 1
18261: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18262: LD_ADDR_EXP 54
18266: PUSH
18267: LD_EXP 54
18271: PPUSH
18272: LD_VAR 0 1
18276: PPUSH
18277: EMPTY
18278: PPUSH
18279: CALL_OW 1
18283: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18284: LD_ADDR_EXP 55
18288: PUSH
18289: LD_EXP 55
18293: PPUSH
18294: LD_VAR 0 1
18298: PPUSH
18299: EMPTY
18300: PPUSH
18301: CALL_OW 1
18305: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18306: LD_ADDR_EXP 56
18310: PUSH
18311: LD_EXP 56
18315: PPUSH
18316: LD_VAR 0 1
18320: PPUSH
18321: EMPTY
18322: PPUSH
18323: CALL_OW 1
18327: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18328: LD_ADDR_EXP 57
18332: PUSH
18333: LD_EXP 57
18337: PPUSH
18338: LD_VAR 0 1
18342: PPUSH
18343: EMPTY
18344: PPUSH
18345: CALL_OW 1
18349: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18350: LD_ADDR_EXP 58
18354: PUSH
18355: LD_EXP 58
18359: PPUSH
18360: LD_VAR 0 1
18364: PPUSH
18365: EMPTY
18366: PPUSH
18367: CALL_OW 1
18371: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18372: LD_ADDR_EXP 59
18376: PUSH
18377: LD_EXP 59
18381: PPUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: EMPTY
18388: PPUSH
18389: CALL_OW 1
18393: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18394: LD_ADDR_EXP 60
18398: PUSH
18399: LD_EXP 60
18403: PPUSH
18404: LD_VAR 0 1
18408: PPUSH
18409: EMPTY
18410: PPUSH
18411: CALL_OW 1
18415: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18416: LD_ADDR_EXP 61
18420: PUSH
18421: LD_EXP 61
18425: PPUSH
18426: LD_VAR 0 1
18430: PPUSH
18431: LD_INT 0
18433: PPUSH
18434: CALL_OW 1
18438: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18439: LD_ADDR_EXP 62
18443: PUSH
18444: LD_EXP 62
18448: PPUSH
18449: LD_VAR 0 1
18453: PPUSH
18454: EMPTY
18455: PPUSH
18456: CALL_OW 1
18460: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18461: LD_ADDR_EXP 63
18465: PUSH
18466: LD_EXP 63
18470: PPUSH
18471: LD_VAR 0 1
18475: PPUSH
18476: EMPTY
18477: PPUSH
18478: CALL_OW 1
18482: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18483: LD_ADDR_EXP 64
18487: PUSH
18488: LD_EXP 64
18492: PPUSH
18493: LD_VAR 0 1
18497: PPUSH
18498: EMPTY
18499: PPUSH
18500: CALL_OW 1
18504: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18505: LD_ADDR_EXP 65
18509: PUSH
18510: LD_EXP 65
18514: PPUSH
18515: LD_VAR 0 1
18519: PPUSH
18520: EMPTY
18521: PPUSH
18522: CALL_OW 1
18526: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18527: LD_ADDR_EXP 66
18531: PUSH
18532: LD_EXP 66
18536: PPUSH
18537: LD_VAR 0 1
18541: PPUSH
18542: EMPTY
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18549: LD_ADDR_EXP 67
18553: PUSH
18554: LD_EXP 67
18558: PPUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: EMPTY
18565: PPUSH
18566: CALL_OW 1
18570: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18571: LD_ADDR_EXP 68
18575: PUSH
18576: LD_EXP 68
18580: PPUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: EMPTY
18587: PPUSH
18588: CALL_OW 1
18592: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18593: LD_ADDR_EXP 69
18597: PUSH
18598: LD_EXP 69
18602: PPUSH
18603: LD_VAR 0 1
18607: PPUSH
18608: EMPTY
18609: PPUSH
18610: CALL_OW 1
18614: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18615: LD_ADDR_EXP 70
18619: PUSH
18620: LD_EXP 70
18624: PPUSH
18625: LD_VAR 0 1
18629: PPUSH
18630: EMPTY
18631: PPUSH
18632: CALL_OW 1
18636: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18637: LD_ADDR_EXP 71
18641: PUSH
18642: LD_EXP 71
18646: PPUSH
18647: LD_VAR 0 1
18651: PPUSH
18652: EMPTY
18653: PPUSH
18654: CALL_OW 1
18658: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18659: LD_ADDR_EXP 72
18663: PUSH
18664: LD_EXP 72
18668: PPUSH
18669: LD_VAR 0 1
18673: PPUSH
18674: EMPTY
18675: PPUSH
18676: CALL_OW 1
18680: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18681: LD_ADDR_EXP 73
18685: PUSH
18686: LD_EXP 73
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: EMPTY
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18703: LD_ADDR_EXP 74
18707: PUSH
18708: LD_EXP 74
18712: PPUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: EMPTY
18719: PPUSH
18720: CALL_OW 1
18724: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18725: LD_ADDR_EXP 75
18729: PUSH
18730: LD_EXP 75
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: EMPTY
18741: PPUSH
18742: CALL_OW 1
18746: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18747: LD_ADDR_EXP 77
18751: PUSH
18752: LD_EXP 77
18756: PPUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: EMPTY
18763: PPUSH
18764: CALL_OW 1
18768: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18769: LD_ADDR_EXP 79
18773: PUSH
18774: LD_EXP 79
18778: PPUSH
18779: LD_VAR 0 1
18783: PPUSH
18784: EMPTY
18785: PPUSH
18786: CALL_OW 1
18790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18791: LD_ADDR_EXP 80
18795: PUSH
18796: LD_EXP 80
18800: PPUSH
18801: LD_VAR 0 1
18805: PPUSH
18806: EMPTY
18807: PPUSH
18808: CALL_OW 1
18812: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18813: LD_ADDR_EXP 81
18817: PUSH
18818: LD_EXP 81
18822: PPUSH
18823: LD_VAR 0 1
18827: PPUSH
18828: EMPTY
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18835: LD_ADDR_EXP 82
18839: PUSH
18840: LD_EXP 82
18844: PPUSH
18845: LD_VAR 0 1
18849: PPUSH
18850: EMPTY
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18857: LD_ADDR_EXP 83
18861: PUSH
18862: LD_EXP 83
18866: PPUSH
18867: LD_VAR 0 1
18871: PPUSH
18872: EMPTY
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18879: LD_ADDR_EXP 84
18883: PUSH
18884: LD_EXP 84
18888: PPUSH
18889: LD_VAR 0 1
18893: PPUSH
18894: EMPTY
18895: PPUSH
18896: CALL_OW 1
18900: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18901: LD_ADDR_EXP 85
18905: PUSH
18906: LD_EXP 85
18910: PPUSH
18911: LD_VAR 0 1
18915: PPUSH
18916: EMPTY
18917: PPUSH
18918: CALL_OW 1
18922: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18923: LD_ADDR_EXP 86
18927: PUSH
18928: LD_EXP 86
18932: PPUSH
18933: LD_VAR 0 1
18937: PPUSH
18938: EMPTY
18939: PPUSH
18940: CALL_OW 1
18944: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18945: LD_ADDR_EXP 87
18949: PUSH
18950: LD_EXP 87
18954: PPUSH
18955: LD_VAR 0 1
18959: PPUSH
18960: EMPTY
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18967: LD_ADDR_EXP 88
18971: PUSH
18972: LD_EXP 88
18976: PPUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: EMPTY
18983: PPUSH
18984: CALL_OW 1
18988: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18989: LD_ADDR_EXP 89
18993: PUSH
18994: LD_EXP 89
18998: PPUSH
18999: LD_VAR 0 1
19003: PPUSH
19004: EMPTY
19005: PPUSH
19006: CALL_OW 1
19010: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19011: LD_ADDR_EXP 90
19015: PUSH
19016: LD_EXP 90
19020: PPUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: EMPTY
19027: PPUSH
19028: CALL_OW 1
19032: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19033: LD_ADDR_EXP 91
19037: PUSH
19038: LD_EXP 91
19042: PPUSH
19043: LD_VAR 0 1
19047: PPUSH
19048: EMPTY
19049: PPUSH
19050: CALL_OW 1
19054: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19055: LD_ADDR_EXP 92
19059: PUSH
19060: LD_EXP 92
19064: PPUSH
19065: LD_VAR 0 1
19069: PPUSH
19070: LD_INT 0
19072: PPUSH
19073: CALL_OW 1
19077: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19078: LD_ADDR_EXP 93
19082: PUSH
19083: LD_EXP 93
19087: PPUSH
19088: LD_VAR 0 1
19092: PPUSH
19093: LD_INT 0
19095: PPUSH
19096: CALL_OW 1
19100: ST_TO_ADDR
// end ;
19101: LD_VAR 0 2
19105: RET
// export function MC_Add ( side , units ) ; var base ; begin
19106: LD_INT 0
19108: PPUSH
19109: PPUSH
// base := mc_bases + 1 ;
19110: LD_ADDR_VAR 0 4
19114: PUSH
19115: LD_EXP 50
19119: PUSH
19120: LD_INT 1
19122: PLUS
19123: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19124: LD_ADDR_EXP 76
19128: PUSH
19129: LD_EXP 76
19133: PPUSH
19134: LD_VAR 0 4
19138: PPUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL_OW 1
19148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19149: LD_ADDR_EXP 50
19153: PUSH
19154: LD_EXP 50
19158: PPUSH
19159: LD_VAR 0 4
19163: PPUSH
19164: LD_VAR 0 2
19168: PPUSH
19169: CALL_OW 1
19173: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19174: LD_ADDR_EXP 51
19178: PUSH
19179: LD_EXP 51
19183: PPUSH
19184: LD_VAR 0 4
19188: PPUSH
19189: EMPTY
19190: PPUSH
19191: CALL_OW 1
19195: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19196: LD_ADDR_EXP 52
19200: PUSH
19201: LD_EXP 52
19205: PPUSH
19206: LD_VAR 0 4
19210: PPUSH
19211: EMPTY
19212: PPUSH
19213: CALL_OW 1
19217: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19218: LD_ADDR_EXP 53
19222: PUSH
19223: LD_EXP 53
19227: PPUSH
19228: LD_VAR 0 4
19232: PPUSH
19233: EMPTY
19234: PPUSH
19235: CALL_OW 1
19239: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19240: LD_ADDR_EXP 54
19244: PUSH
19245: LD_EXP 54
19249: PPUSH
19250: LD_VAR 0 4
19254: PPUSH
19255: EMPTY
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19262: LD_ADDR_EXP 55
19266: PUSH
19267: LD_EXP 55
19271: PPUSH
19272: LD_VAR 0 4
19276: PPUSH
19277: EMPTY
19278: PPUSH
19279: CALL_OW 1
19283: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19284: LD_ADDR_EXP 56
19288: PUSH
19289: LD_EXP 56
19293: PPUSH
19294: LD_VAR 0 4
19298: PPUSH
19299: EMPTY
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19306: LD_ADDR_EXP 57
19310: PUSH
19311: LD_EXP 57
19315: PPUSH
19316: LD_VAR 0 4
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19328: LD_ADDR_EXP 58
19332: PUSH
19333: LD_EXP 58
19337: PPUSH
19338: LD_VAR 0 4
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19350: LD_ADDR_EXP 59
19354: PUSH
19355: LD_EXP 59
19359: PPUSH
19360: LD_VAR 0 4
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19372: LD_ADDR_EXP 60
19376: PUSH
19377: LD_EXP 60
19381: PPUSH
19382: LD_VAR 0 4
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19394: LD_ADDR_EXP 61
19398: PUSH
19399: LD_EXP 61
19403: PPUSH
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 1
19416: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19417: LD_ADDR_EXP 62
19421: PUSH
19422: LD_EXP 62
19426: PPUSH
19427: LD_VAR 0 4
19431: PPUSH
19432: EMPTY
19433: PPUSH
19434: CALL_OW 1
19438: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19439: LD_ADDR_EXP 63
19443: PUSH
19444: LD_EXP 63
19448: PPUSH
19449: LD_VAR 0 4
19453: PPUSH
19454: EMPTY
19455: PPUSH
19456: CALL_OW 1
19460: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19461: LD_ADDR_EXP 64
19465: PUSH
19466: LD_EXP 64
19470: PPUSH
19471: LD_VAR 0 4
19475: PPUSH
19476: EMPTY
19477: PPUSH
19478: CALL_OW 1
19482: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19483: LD_ADDR_EXP 65
19487: PUSH
19488: LD_EXP 65
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: EMPTY
19499: PPUSH
19500: CALL_OW 1
19504: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19505: LD_ADDR_EXP 66
19509: PUSH
19510: LD_EXP 66
19514: PPUSH
19515: LD_VAR 0 4
19519: PPUSH
19520: EMPTY
19521: PPUSH
19522: CALL_OW 1
19526: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19527: LD_ADDR_EXP 67
19531: PUSH
19532: LD_EXP 67
19536: PPUSH
19537: LD_VAR 0 4
19541: PPUSH
19542: EMPTY
19543: PPUSH
19544: CALL_OW 1
19548: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19549: LD_ADDR_EXP 68
19553: PUSH
19554: LD_EXP 68
19558: PPUSH
19559: LD_VAR 0 4
19563: PPUSH
19564: EMPTY
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19571: LD_ADDR_EXP 69
19575: PUSH
19576: LD_EXP 69
19580: PPUSH
19581: LD_VAR 0 4
19585: PPUSH
19586: EMPTY
19587: PPUSH
19588: CALL_OW 1
19592: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19593: LD_ADDR_EXP 70
19597: PUSH
19598: LD_EXP 70
19602: PPUSH
19603: LD_VAR 0 4
19607: PPUSH
19608: EMPTY
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19615: LD_ADDR_EXP 71
19619: PUSH
19620: LD_EXP 71
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: EMPTY
19631: PPUSH
19632: CALL_OW 1
19636: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19637: LD_ADDR_EXP 72
19641: PUSH
19642: LD_EXP 72
19646: PPUSH
19647: LD_VAR 0 4
19651: PPUSH
19652: EMPTY
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19659: LD_ADDR_EXP 73
19663: PUSH
19664: LD_EXP 73
19668: PPUSH
19669: LD_VAR 0 4
19673: PPUSH
19674: EMPTY
19675: PPUSH
19676: CALL_OW 1
19680: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19681: LD_ADDR_EXP 74
19685: PUSH
19686: LD_EXP 74
19690: PPUSH
19691: LD_VAR 0 4
19695: PPUSH
19696: EMPTY
19697: PPUSH
19698: CALL_OW 1
19702: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19703: LD_ADDR_EXP 75
19707: PUSH
19708: LD_EXP 75
19712: PPUSH
19713: LD_VAR 0 4
19717: PPUSH
19718: EMPTY
19719: PPUSH
19720: CALL_OW 1
19724: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19725: LD_ADDR_EXP 77
19729: PUSH
19730: LD_EXP 77
19734: PPUSH
19735: LD_VAR 0 4
19739: PPUSH
19740: EMPTY
19741: PPUSH
19742: CALL_OW 1
19746: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19747: LD_ADDR_EXP 79
19751: PUSH
19752: LD_EXP 79
19756: PPUSH
19757: LD_VAR 0 4
19761: PPUSH
19762: EMPTY
19763: PPUSH
19764: CALL_OW 1
19768: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19769: LD_ADDR_EXP 80
19773: PUSH
19774: LD_EXP 80
19778: PPUSH
19779: LD_VAR 0 4
19783: PPUSH
19784: EMPTY
19785: PPUSH
19786: CALL_OW 1
19790: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19791: LD_ADDR_EXP 81
19795: PUSH
19796: LD_EXP 81
19800: PPUSH
19801: LD_VAR 0 4
19805: PPUSH
19806: EMPTY
19807: PPUSH
19808: CALL_OW 1
19812: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19813: LD_ADDR_EXP 82
19817: PUSH
19818: LD_EXP 82
19822: PPUSH
19823: LD_VAR 0 4
19827: PPUSH
19828: EMPTY
19829: PPUSH
19830: CALL_OW 1
19834: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19835: LD_ADDR_EXP 83
19839: PUSH
19840: LD_EXP 83
19844: PPUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: EMPTY
19851: PPUSH
19852: CALL_OW 1
19856: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19857: LD_ADDR_EXP 84
19861: PUSH
19862: LD_EXP 84
19866: PPUSH
19867: LD_VAR 0 4
19871: PPUSH
19872: EMPTY
19873: PPUSH
19874: CALL_OW 1
19878: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19879: LD_ADDR_EXP 85
19883: PUSH
19884: LD_EXP 85
19888: PPUSH
19889: LD_VAR 0 4
19893: PPUSH
19894: EMPTY
19895: PPUSH
19896: CALL_OW 1
19900: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19901: LD_ADDR_EXP 86
19905: PUSH
19906: LD_EXP 86
19910: PPUSH
19911: LD_VAR 0 4
19915: PPUSH
19916: EMPTY
19917: PPUSH
19918: CALL_OW 1
19922: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19923: LD_ADDR_EXP 87
19927: PUSH
19928: LD_EXP 87
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: EMPTY
19939: PPUSH
19940: CALL_OW 1
19944: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19945: LD_ADDR_EXP 88
19949: PUSH
19950: LD_EXP 88
19954: PPUSH
19955: LD_VAR 0 4
19959: PPUSH
19960: EMPTY
19961: PPUSH
19962: CALL_OW 1
19966: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19967: LD_ADDR_EXP 89
19971: PUSH
19972: LD_EXP 89
19976: PPUSH
19977: LD_VAR 0 4
19981: PPUSH
19982: EMPTY
19983: PPUSH
19984: CALL_OW 1
19988: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19989: LD_ADDR_EXP 90
19993: PUSH
19994: LD_EXP 90
19998: PPUSH
19999: LD_VAR 0 4
20003: PPUSH
20004: EMPTY
20005: PPUSH
20006: CALL_OW 1
20010: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20011: LD_ADDR_EXP 91
20015: PUSH
20016: LD_EXP 91
20020: PPUSH
20021: LD_VAR 0 4
20025: PPUSH
20026: EMPTY
20027: PPUSH
20028: CALL_OW 1
20032: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20033: LD_ADDR_EXP 92
20037: PUSH
20038: LD_EXP 92
20042: PPUSH
20043: LD_VAR 0 4
20047: PPUSH
20048: LD_INT 0
20050: PPUSH
20051: CALL_OW 1
20055: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20056: LD_ADDR_EXP 93
20060: PUSH
20061: LD_EXP 93
20065: PPUSH
20066: LD_VAR 0 4
20070: PPUSH
20071: LD_INT 0
20073: PPUSH
20074: CALL_OW 1
20078: ST_TO_ADDR
// result := base ;
20079: LD_ADDR_VAR 0 3
20083: PUSH
20084: LD_VAR 0 4
20088: ST_TO_ADDR
// end ;
20089: LD_VAR 0 3
20093: RET
// export function MC_Start ( ) ; var i ; begin
20094: LD_INT 0
20096: PPUSH
20097: PPUSH
// for i = 1 to mc_bases do
20098: LD_ADDR_VAR 0 2
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_EXP 50
20112: PUSH
20113: FOR_TO
20114: IFFALSE 21214
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20116: LD_ADDR_EXP 50
20120: PUSH
20121: LD_EXP 50
20125: PPUSH
20126: LD_VAR 0 2
20130: PPUSH
20131: LD_EXP 50
20135: PUSH
20136: LD_VAR 0 2
20140: ARRAY
20141: PUSH
20142: LD_INT 0
20144: DIFF
20145: PPUSH
20146: CALL_OW 1
20150: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20151: LD_ADDR_EXP 51
20155: PUSH
20156: LD_EXP 51
20160: PPUSH
20161: LD_VAR 0 2
20165: PPUSH
20166: EMPTY
20167: PPUSH
20168: CALL_OW 1
20172: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20173: LD_ADDR_EXP 52
20177: PUSH
20178: LD_EXP 52
20182: PPUSH
20183: LD_VAR 0 2
20187: PPUSH
20188: EMPTY
20189: PPUSH
20190: CALL_OW 1
20194: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20195: LD_ADDR_EXP 53
20199: PUSH
20200: LD_EXP 53
20204: PPUSH
20205: LD_VAR 0 2
20209: PPUSH
20210: EMPTY
20211: PPUSH
20212: CALL_OW 1
20216: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20217: LD_ADDR_EXP 54
20221: PUSH
20222: LD_EXP 54
20226: PPUSH
20227: LD_VAR 0 2
20231: PPUSH
20232: EMPTY
20233: PUSH
20234: EMPTY
20235: PUSH
20236: EMPTY
20237: LIST
20238: LIST
20239: PPUSH
20240: CALL_OW 1
20244: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20245: LD_ADDR_EXP 55
20249: PUSH
20250: LD_EXP 55
20254: PPUSH
20255: LD_VAR 0 2
20259: PPUSH
20260: EMPTY
20261: PPUSH
20262: CALL_OW 1
20266: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20267: LD_ADDR_EXP 82
20271: PUSH
20272: LD_EXP 82
20276: PPUSH
20277: LD_VAR 0 2
20281: PPUSH
20282: EMPTY
20283: PPUSH
20284: CALL_OW 1
20288: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20289: LD_ADDR_EXP 56
20293: PUSH
20294: LD_EXP 56
20298: PPUSH
20299: LD_VAR 0 2
20303: PPUSH
20304: EMPTY
20305: PPUSH
20306: CALL_OW 1
20310: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20311: LD_ADDR_EXP 57
20315: PUSH
20316: LD_EXP 57
20320: PPUSH
20321: LD_VAR 0 2
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL_OW 1
20332: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20333: LD_ADDR_EXP 58
20337: PUSH
20338: LD_EXP 58
20342: PPUSH
20343: LD_VAR 0 2
20347: PPUSH
20348: LD_EXP 50
20352: PUSH
20353: LD_VAR 0 2
20357: ARRAY
20358: PPUSH
20359: LD_INT 2
20361: PUSH
20362: LD_INT 30
20364: PUSH
20365: LD_INT 32
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: LD_INT 30
20374: PUSH
20375: LD_INT 33
20377: PUSH
20378: EMPTY
20379: LIST
20380: LIST
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: LIST
20386: PPUSH
20387: CALL_OW 72
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20397: LD_ADDR_EXP 59
20401: PUSH
20402: LD_EXP 59
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: LD_EXP 50
20416: PUSH
20417: LD_VAR 0 2
20421: ARRAY
20422: PPUSH
20423: LD_INT 2
20425: PUSH
20426: LD_INT 30
20428: PUSH
20429: LD_INT 32
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PUSH
20436: LD_INT 30
20438: PUSH
20439: LD_INT 31
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: LIST
20450: PUSH
20451: LD_INT 58
20453: PUSH
20454: EMPTY
20455: LIST
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PPUSH
20461: CALL_OW 72
20465: PPUSH
20466: CALL_OW 1
20470: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20471: LD_ADDR_EXP 60
20475: PUSH
20476: LD_EXP 60
20480: PPUSH
20481: LD_VAR 0 2
20485: PPUSH
20486: EMPTY
20487: PPUSH
20488: CALL_OW 1
20492: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20493: LD_ADDR_EXP 64
20497: PUSH
20498: LD_EXP 64
20502: PPUSH
20503: LD_VAR 0 2
20507: PPUSH
20508: EMPTY
20509: PPUSH
20510: CALL_OW 1
20514: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20515: LD_ADDR_EXP 63
20519: PUSH
20520: LD_EXP 63
20524: PPUSH
20525: LD_VAR 0 2
20529: PPUSH
20530: EMPTY
20531: PPUSH
20532: CALL_OW 1
20536: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20537: LD_ADDR_EXP 65
20541: PUSH
20542: LD_EXP 65
20546: PPUSH
20547: LD_VAR 0 2
20551: PPUSH
20552: EMPTY
20553: PPUSH
20554: CALL_OW 1
20558: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20559: LD_ADDR_EXP 66
20563: PUSH
20564: LD_EXP 66
20568: PPUSH
20569: LD_VAR 0 2
20573: PPUSH
20574: EMPTY
20575: PPUSH
20576: CALL_OW 1
20580: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20581: LD_ADDR_EXP 67
20585: PUSH
20586: LD_EXP 67
20590: PPUSH
20591: LD_VAR 0 2
20595: PPUSH
20596: EMPTY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20603: LD_ADDR_EXP 68
20607: PUSH
20608: LD_EXP 68
20612: PPUSH
20613: LD_VAR 0 2
20617: PPUSH
20618: EMPTY
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20625: LD_ADDR_EXP 69
20629: PUSH
20630: LD_EXP 69
20634: PPUSH
20635: LD_VAR 0 2
20639: PPUSH
20640: EMPTY
20641: PPUSH
20642: CALL_OW 1
20646: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20647: LD_ADDR_EXP 70
20651: PUSH
20652: LD_EXP 70
20656: PPUSH
20657: LD_VAR 0 2
20661: PPUSH
20662: EMPTY
20663: PPUSH
20664: CALL_OW 1
20668: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20669: LD_ADDR_EXP 71
20673: PUSH
20674: LD_EXP 71
20678: PPUSH
20679: LD_VAR 0 2
20683: PPUSH
20684: EMPTY
20685: PPUSH
20686: CALL_OW 1
20690: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20691: LD_ADDR_EXP 72
20695: PUSH
20696: LD_EXP 72
20700: PPUSH
20701: LD_VAR 0 2
20705: PPUSH
20706: EMPTY
20707: PPUSH
20708: CALL_OW 1
20712: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20713: LD_ADDR_EXP 61
20717: PUSH
20718: LD_EXP 61
20722: PPUSH
20723: LD_VAR 0 2
20727: PPUSH
20728: LD_INT 0
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20736: LD_ADDR_EXP 74
20740: PUSH
20741: LD_EXP 74
20745: PPUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: LD_INT 0
20753: PPUSH
20754: CALL_OW 1
20758: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20759: LD_ADDR_EXP 62
20763: PUSH
20764: LD_EXP 62
20768: PPUSH
20769: LD_VAR 0 2
20773: PPUSH
20774: EMPTY
20775: PPUSH
20776: CALL_OW 1
20780: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20781: LD_ADDR_EXP 73
20785: PUSH
20786: LD_EXP 73
20790: PPUSH
20791: LD_VAR 0 2
20795: PPUSH
20796: LD_INT 0
20798: PPUSH
20799: CALL_OW 1
20803: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20804: LD_ADDR_EXP 75
20808: PUSH
20809: LD_EXP 75
20813: PPUSH
20814: LD_VAR 0 2
20818: PPUSH
20819: EMPTY
20820: PPUSH
20821: CALL_OW 1
20825: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20826: LD_ADDR_EXP 78
20830: PUSH
20831: LD_EXP 78
20835: PPUSH
20836: LD_VAR 0 2
20840: PPUSH
20841: LD_INT 0
20843: PPUSH
20844: CALL_OW 1
20848: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20849: LD_ADDR_EXP 79
20853: PUSH
20854: LD_EXP 79
20858: PPUSH
20859: LD_VAR 0 2
20863: PPUSH
20864: EMPTY
20865: PPUSH
20866: CALL_OW 1
20870: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20871: LD_ADDR_EXP 80
20875: PUSH
20876: LD_EXP 80
20880: PPUSH
20881: LD_VAR 0 2
20885: PPUSH
20886: EMPTY
20887: PPUSH
20888: CALL_OW 1
20892: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20893: LD_ADDR_EXP 81
20897: PUSH
20898: LD_EXP 81
20902: PPUSH
20903: LD_VAR 0 2
20907: PPUSH
20908: EMPTY
20909: PPUSH
20910: CALL_OW 1
20914: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20915: LD_ADDR_EXP 83
20919: PUSH
20920: LD_EXP 83
20924: PPUSH
20925: LD_VAR 0 2
20929: PPUSH
20930: LD_EXP 50
20934: PUSH
20935: LD_VAR 0 2
20939: ARRAY
20940: PPUSH
20941: LD_INT 2
20943: PUSH
20944: LD_INT 30
20946: PUSH
20947: LD_INT 6
20949: PUSH
20950: EMPTY
20951: LIST
20952: LIST
20953: PUSH
20954: LD_INT 30
20956: PUSH
20957: LD_INT 7
20959: PUSH
20960: EMPTY
20961: LIST
20962: LIST
20963: PUSH
20964: LD_INT 30
20966: PUSH
20967: LD_INT 8
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: LIST
20978: LIST
20979: PPUSH
20980: CALL_OW 72
20984: PPUSH
20985: CALL_OW 1
20989: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20990: LD_ADDR_EXP 84
20994: PUSH
20995: LD_EXP 84
20999: PPUSH
21000: LD_VAR 0 2
21004: PPUSH
21005: EMPTY
21006: PPUSH
21007: CALL_OW 1
21011: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21012: LD_ADDR_EXP 85
21016: PUSH
21017: LD_EXP 85
21021: PPUSH
21022: LD_VAR 0 2
21026: PPUSH
21027: EMPTY
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21034: LD_ADDR_EXP 86
21038: PUSH
21039: LD_EXP 86
21043: PPUSH
21044: LD_VAR 0 2
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21056: LD_ADDR_EXP 87
21060: PUSH
21061: LD_EXP 87
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21078: LD_ADDR_EXP 88
21082: PUSH
21083: LD_EXP 88
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21100: LD_ADDR_EXP 89
21104: PUSH
21105: LD_EXP 89
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21122: LD_ADDR_EXP 90
21126: PUSH
21127: LD_EXP 90
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21144: LD_ADDR_EXP 91
21148: PUSH
21149: LD_EXP 91
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21166: LD_ADDR_EXP 92
21170: PUSH
21171: LD_EXP 92
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: LD_INT 0
21183: PPUSH
21184: CALL_OW 1
21188: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21189: LD_ADDR_EXP 93
21193: PUSH
21194: LD_EXP 93
21198: PPUSH
21199: LD_VAR 0 2
21203: PPUSH
21204: LD_INT 0
21206: PPUSH
21207: CALL_OW 1
21211: ST_TO_ADDR
// end ;
21212: GO 20113
21214: POP
21215: POP
// MC_InitSides ( ) ;
21216: CALL 21502 0 0
// MC_InitResearch ( ) ;
21220: CALL 21241 0 0
// CustomInitMacro ( ) ;
21224: CALL 308 0 0
// skirmish := true ;
21228: LD_ADDR_EXP 48
21232: PUSH
21233: LD_INT 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 1
21240: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21241: LD_INT 0
21243: PPUSH
21244: PPUSH
21245: PPUSH
21246: PPUSH
21247: PPUSH
21248: PPUSH
// if not mc_bases then
21249: LD_EXP 50
21253: NOT
21254: IFFALSE 21258
// exit ;
21256: GO 21497
// for i = 1 to 8 do
21258: LD_ADDR_VAR 0 2
21262: PUSH
21263: DOUBLE
21264: LD_INT 1
21266: DEC
21267: ST_TO_ADDR
21268: LD_INT 8
21270: PUSH
21271: FOR_TO
21272: IFFALSE 21298
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21274: LD_ADDR_EXP 77
21278: PUSH
21279: LD_EXP 77
21283: PPUSH
21284: LD_VAR 0 2
21288: PPUSH
21289: EMPTY
21290: PPUSH
21291: CALL_OW 1
21295: ST_TO_ADDR
21296: GO 21271
21298: POP
21299: POP
// tmp := [ ] ;
21300: LD_ADDR_VAR 0 5
21304: PUSH
21305: EMPTY
21306: ST_TO_ADDR
// for i = 1 to mc_sides do
21307: LD_ADDR_VAR 0 2
21311: PUSH
21312: DOUBLE
21313: LD_INT 1
21315: DEC
21316: ST_TO_ADDR
21317: LD_EXP 76
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21381
// if not mc_sides [ i ] in tmp then
21325: LD_EXP 76
21329: PUSH
21330: LD_VAR 0 2
21334: ARRAY
21335: PUSH
21336: LD_VAR 0 5
21340: IN
21341: NOT
21342: IFFALSE 21379
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21344: LD_ADDR_VAR 0 5
21348: PUSH
21349: LD_VAR 0 5
21353: PPUSH
21354: LD_VAR 0 5
21358: PUSH
21359: LD_INT 1
21361: PLUS
21362: PPUSH
21363: LD_EXP 76
21367: PUSH
21368: LD_VAR 0 2
21372: ARRAY
21373: PPUSH
21374: CALL_OW 2
21378: ST_TO_ADDR
21379: GO 21322
21381: POP
21382: POP
// if not tmp then
21383: LD_VAR 0 5
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21497
// for j in tmp do
21392: LD_ADDR_VAR 0 3
21396: PUSH
21397: LD_VAR 0 5
21401: PUSH
21402: FOR_IN
21403: IFFALSE 21495
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21405: LD_ADDR_VAR 0 6
21409: PUSH
21410: LD_INT 22
21412: PUSH
21413: LD_VAR 0 3
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PPUSH
21422: CALL_OW 69
21426: ST_TO_ADDR
// if not un then
21427: LD_VAR 0 6
21431: NOT
21432: IFFALSE 21436
// continue ;
21434: GO 21402
// nation := GetNation ( un [ 1 ] ) ;
21436: LD_ADDR_VAR 0 4
21440: PUSH
21441: LD_VAR 0 6
21445: PUSH
21446: LD_INT 1
21448: ARRAY
21449: PPUSH
21450: CALL_OW 248
21454: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21455: LD_ADDR_EXP 77
21459: PUSH
21460: LD_EXP 77
21464: PPUSH
21465: LD_VAR 0 3
21469: PPUSH
21470: LD_VAR 0 3
21474: PPUSH
21475: LD_VAR 0 4
21479: PPUSH
21480: LD_INT 1
21482: PPUSH
21483: CALL 48618 0 3
21487: PPUSH
21488: CALL_OW 1
21492: ST_TO_ADDR
// end ;
21493: GO 21402
21495: POP
21496: POP
// end ;
21497: LD_VAR 0 1
21501: RET
// export function MC_InitSides ( ) ; var i ; begin
21502: LD_INT 0
21504: PPUSH
21505: PPUSH
// if not mc_bases then
21506: LD_EXP 50
21510: NOT
21511: IFFALSE 21515
// exit ;
21513: GO 21589
// for i = 1 to mc_bases do
21515: LD_ADDR_VAR 0 2
21519: PUSH
21520: DOUBLE
21521: LD_INT 1
21523: DEC
21524: ST_TO_ADDR
21525: LD_EXP 50
21529: PUSH
21530: FOR_TO
21531: IFFALSE 21587
// if mc_bases [ i ] then
21533: LD_EXP 50
21537: PUSH
21538: LD_VAR 0 2
21542: ARRAY
21543: IFFALSE 21585
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21545: LD_ADDR_EXP 76
21549: PUSH
21550: LD_EXP 76
21554: PPUSH
21555: LD_VAR 0 2
21559: PPUSH
21560: LD_EXP 50
21564: PUSH
21565: LD_VAR 0 2
21569: ARRAY
21570: PUSH
21571: LD_INT 1
21573: ARRAY
21574: PPUSH
21575: CALL_OW 255
21579: PPUSH
21580: CALL_OW 1
21584: ST_TO_ADDR
21585: GO 21530
21587: POP
21588: POP
// end ;
21589: LD_VAR 0 1
21593: RET
// every 0 0$03 trigger skirmish do
21594: LD_EXP 48
21598: IFFALSE 21752
21600: GO 21602
21602: DISABLE
// begin enable ;
21603: ENABLE
// MC_CheckBuildings ( ) ;
21604: CALL 26250 0 0
// MC_CheckPeopleLife ( ) ;
21608: CALL 26411 0 0
// RaiseSailEvent ( 100 ) ;
21612: LD_INT 100
21614: PPUSH
21615: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21619: LD_INT 103
21621: PPUSH
21622: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21626: LD_INT 104
21628: PPUSH
21629: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21633: LD_INT 105
21635: PPUSH
21636: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21640: LD_INT 106
21642: PPUSH
21643: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21647: LD_INT 107
21649: PPUSH
21650: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21654: LD_INT 108
21656: PPUSH
21657: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21661: LD_INT 109
21663: PPUSH
21664: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21668: LD_INT 110
21670: PPUSH
21671: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21675: LD_INT 111
21677: PPUSH
21678: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21682: LD_INT 112
21684: PPUSH
21685: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21689: LD_INT 113
21691: PPUSH
21692: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21696: LD_INT 120
21698: PPUSH
21699: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21703: LD_INT 121
21705: PPUSH
21706: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21710: LD_INT 122
21712: PPUSH
21713: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21717: LD_INT 123
21719: PPUSH
21720: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21724: LD_INT 124
21726: PPUSH
21727: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21731: LD_INT 125
21733: PPUSH
21734: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21738: LD_INT 126
21740: PPUSH
21741: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21745: LD_INT 200
21747: PPUSH
21748: CALL_OW 427
// end ;
21752: END
// on SailEvent ( event ) do begin if event < 100 then
21753: LD_VAR 0 1
21757: PUSH
21758: LD_INT 100
21760: LESS
21761: IFFALSE 21772
// CustomEvent ( event ) ;
21763: LD_VAR 0 1
21767: PPUSH
21768: CALL 17138 0 1
// if event = 100 then
21772: LD_VAR 0 1
21776: PUSH
21777: LD_INT 100
21779: EQUAL
21780: IFFALSE 21786
// MC_ClassManager ( ) ;
21782: CALL 22178 0 0
// if event = 101 then
21786: LD_VAR 0 1
21790: PUSH
21791: LD_INT 101
21793: EQUAL
21794: IFFALSE 21800
// MC_RepairBuildings ( ) ;
21796: CALL 26996 0 0
// if event = 102 then
21800: LD_VAR 0 1
21804: PUSH
21805: LD_INT 102
21807: EQUAL
21808: IFFALSE 21814
// MC_Heal ( ) ;
21810: CALL 27903 0 0
// if event = 103 then
21814: LD_VAR 0 1
21818: PUSH
21819: LD_INT 103
21821: EQUAL
21822: IFFALSE 21828
// MC_Build ( ) ;
21824: CALL 28325 0 0
// if event = 104 then
21828: LD_VAR 0 1
21832: PUSH
21833: LD_INT 104
21835: EQUAL
21836: IFFALSE 21842
// MC_TurretWeapon ( ) ;
21838: CALL 29966 0 0
// if event = 105 then
21842: LD_VAR 0 1
21846: PUSH
21847: LD_INT 105
21849: EQUAL
21850: IFFALSE 21856
// MC_BuildUpgrade ( ) ;
21852: CALL 29517 0 0
// if event = 106 then
21856: LD_VAR 0 1
21860: PUSH
21861: LD_INT 106
21863: EQUAL
21864: IFFALSE 21870
// MC_PlantMines ( ) ;
21866: CALL 30396 0 0
// if event = 107 then
21870: LD_VAR 0 1
21874: PUSH
21875: LD_INT 107
21877: EQUAL
21878: IFFALSE 21884
// MC_CollectCrates ( ) ;
21880: CALL 31187 0 0
// if event = 108 then
21884: LD_VAR 0 1
21888: PUSH
21889: LD_INT 108
21891: EQUAL
21892: IFFALSE 21898
// MC_LinkRemoteControl ( ) ;
21894: CALL 33037 0 0
// if event = 109 then
21898: LD_VAR 0 1
21902: PUSH
21903: LD_INT 109
21905: EQUAL
21906: IFFALSE 21912
// MC_ProduceVehicle ( ) ;
21908: CALL 33218 0 0
// if event = 110 then
21912: LD_VAR 0 1
21916: PUSH
21917: LD_INT 110
21919: EQUAL
21920: IFFALSE 21926
// MC_SendAttack ( ) ;
21922: CALL 33684 0 0
// if event = 111 then
21926: LD_VAR 0 1
21930: PUSH
21931: LD_INT 111
21933: EQUAL
21934: IFFALSE 21940
// MC_Defend ( ) ;
21936: CALL 33792 0 0
// if event = 112 then
21940: LD_VAR 0 1
21944: PUSH
21945: LD_INT 112
21947: EQUAL
21948: IFFALSE 21954
// MC_Research ( ) ;
21950: CALL 34672 0 0
// if event = 113 then
21954: LD_VAR 0 1
21958: PUSH
21959: LD_INT 113
21961: EQUAL
21962: IFFALSE 21968
// MC_MinesTrigger ( ) ;
21964: CALL 35786 0 0
// if event = 120 then
21968: LD_VAR 0 1
21972: PUSH
21973: LD_INT 120
21975: EQUAL
21976: IFFALSE 21982
// MC_RepairVehicle ( ) ;
21978: CALL 35885 0 0
// if event = 121 then
21982: LD_VAR 0 1
21986: PUSH
21987: LD_INT 121
21989: EQUAL
21990: IFFALSE 21996
// MC_TameApe ( ) ;
21992: CALL 36626 0 0
// if event = 122 then
21996: LD_VAR 0 1
22000: PUSH
22001: LD_INT 122
22003: EQUAL
22004: IFFALSE 22010
// MC_ChangeApeClass ( ) ;
22006: CALL 37455 0 0
// if event = 123 then
22010: LD_VAR 0 1
22014: PUSH
22015: LD_INT 123
22017: EQUAL
22018: IFFALSE 22024
// MC_Bazooka ( ) ;
22020: CALL 38105 0 0
// if event = 124 then
22024: LD_VAR 0 1
22028: PUSH
22029: LD_INT 124
22031: EQUAL
22032: IFFALSE 22038
// MC_TeleportExit ( ) ;
22034: CALL 38303 0 0
// if event = 125 then
22038: LD_VAR 0 1
22042: PUSH
22043: LD_INT 125
22045: EQUAL
22046: IFFALSE 22052
// MC_Deposits ( ) ;
22048: CALL 38950 0 0
// if event = 126 then
22052: LD_VAR 0 1
22056: PUSH
22057: LD_INT 126
22059: EQUAL
22060: IFFALSE 22066
// MC_RemoteDriver ( ) ;
22062: CALL 39575 0 0
// if event = 200 then
22066: LD_VAR 0 1
22070: PUSH
22071: LD_INT 200
22073: EQUAL
22074: IFFALSE 22080
// MC_Idle ( ) ;
22076: CALL 41524 0 0
// end ;
22080: PPOPN 1
22082: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22083: LD_INT 0
22085: PPUSH
22086: PPUSH
// if not mc_bases [ base ] or not tag then
22087: LD_EXP 50
22091: PUSH
22092: LD_VAR 0 1
22096: ARRAY
22097: NOT
22098: PUSH
22099: LD_VAR 0 2
22103: NOT
22104: OR
22105: IFFALSE 22109
// exit ;
22107: GO 22173
// for i in mc_bases [ base ] union mc_ape [ base ] do
22109: LD_ADDR_VAR 0 4
22113: PUSH
22114: LD_EXP 50
22118: PUSH
22119: LD_VAR 0 1
22123: ARRAY
22124: PUSH
22125: LD_EXP 79
22129: PUSH
22130: LD_VAR 0 1
22134: ARRAY
22135: UNION
22136: PUSH
22137: FOR_IN
22138: IFFALSE 22171
// if GetTag ( i ) = tag then
22140: LD_VAR 0 4
22144: PPUSH
22145: CALL_OW 110
22149: PUSH
22150: LD_VAR 0 2
22154: EQUAL
22155: IFFALSE 22169
// SetTag ( i , 0 ) ;
22157: LD_VAR 0 4
22161: PPUSH
22162: LD_INT 0
22164: PPUSH
22165: CALL_OW 109
22169: GO 22137
22171: POP
22172: POP
// end ;
22173: LD_VAR 0 3
22177: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22178: LD_INT 0
22180: PPUSH
22181: PPUSH
22182: PPUSH
22183: PPUSH
22184: PPUSH
22185: PPUSH
22186: PPUSH
22187: PPUSH
// if not mc_bases then
22188: LD_EXP 50
22192: NOT
22193: IFFALSE 22197
// exit ;
22195: GO 22655
// for i = 1 to mc_bases do
22197: LD_ADDR_VAR 0 2
22201: PUSH
22202: DOUBLE
22203: LD_INT 1
22205: DEC
22206: ST_TO_ADDR
22207: LD_EXP 50
22211: PUSH
22212: FOR_TO
22213: IFFALSE 22653
// begin tmp := MC_ClassCheckReq ( i ) ;
22215: LD_ADDR_VAR 0 4
22219: PUSH
22220: LD_VAR 0 2
22224: PPUSH
22225: CALL 22660 0 1
22229: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22230: LD_ADDR_EXP 91
22234: PUSH
22235: LD_EXP 91
22239: PPUSH
22240: LD_VAR 0 2
22244: PPUSH
22245: LD_VAR 0 4
22249: PPUSH
22250: CALL_OW 1
22254: ST_TO_ADDR
// if not tmp then
22255: LD_VAR 0 4
22259: NOT
22260: IFFALSE 22264
// continue ;
22262: GO 22212
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22264: LD_ADDR_VAR 0 6
22268: PUSH
22269: LD_EXP 50
22273: PUSH
22274: LD_VAR 0 2
22278: ARRAY
22279: PPUSH
22280: LD_INT 2
22282: PUSH
22283: LD_INT 30
22285: PUSH
22286: LD_INT 4
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: PUSH
22293: LD_INT 30
22295: PUSH
22296: LD_INT 5
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: LIST
22307: PPUSH
22308: CALL_OW 72
22312: PUSH
22313: LD_EXP 50
22317: PUSH
22318: LD_VAR 0 2
22322: ARRAY
22323: PPUSH
22324: LD_INT 2
22326: PUSH
22327: LD_INT 30
22329: PUSH
22330: LD_INT 0
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 30
22339: PUSH
22340: LD_INT 1
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: LIST
22351: PPUSH
22352: CALL_OW 72
22356: PUSH
22357: LD_EXP 50
22361: PUSH
22362: LD_VAR 0 2
22366: ARRAY
22367: PPUSH
22368: LD_INT 30
22370: PUSH
22371: LD_INT 3
22373: PUSH
22374: EMPTY
22375: LIST
22376: LIST
22377: PPUSH
22378: CALL_OW 72
22382: PUSH
22383: LD_EXP 50
22387: PUSH
22388: LD_VAR 0 2
22392: ARRAY
22393: PPUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 30
22399: PUSH
22400: LD_INT 6
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 30
22409: PUSH
22410: LD_INT 7
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: PUSH
22417: LD_INT 30
22419: PUSH
22420: LD_INT 8
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: LIST
22431: LIST
22432: PPUSH
22433: CALL_OW 72
22437: PUSH
22438: EMPTY
22439: LIST
22440: LIST
22441: LIST
22442: LIST
22443: ST_TO_ADDR
// for j = 1 to 4 do
22444: LD_ADDR_VAR 0 3
22448: PUSH
22449: DOUBLE
22450: LD_INT 1
22452: DEC
22453: ST_TO_ADDR
22454: LD_INT 4
22456: PUSH
22457: FOR_TO
22458: IFFALSE 22649
// begin if not tmp [ j ] then
22460: LD_VAR 0 4
22464: PUSH
22465: LD_VAR 0 3
22469: ARRAY
22470: NOT
22471: IFFALSE 22475
// continue ;
22473: GO 22457
// for p in tmp [ j ] do
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_VAR 0 4
22484: PUSH
22485: LD_VAR 0 3
22489: ARRAY
22490: PUSH
22491: FOR_IN
22492: IFFALSE 22645
// begin if not b [ j ] then
22494: LD_VAR 0 6
22498: PUSH
22499: LD_VAR 0 3
22503: ARRAY
22504: NOT
22505: IFFALSE 22509
// break ;
22507: GO 22645
// e := 0 ;
22509: LD_ADDR_VAR 0 7
22513: PUSH
22514: LD_INT 0
22516: ST_TO_ADDR
// for k in b [ j ] do
22517: LD_ADDR_VAR 0 8
22521: PUSH
22522: LD_VAR 0 6
22526: PUSH
22527: LD_VAR 0 3
22531: ARRAY
22532: PUSH
22533: FOR_IN
22534: IFFALSE 22561
// if IsNotFull ( k ) then
22536: LD_VAR 0 8
22540: PPUSH
22541: CALL 50771 0 1
22545: IFFALSE 22559
// begin e := k ;
22547: LD_ADDR_VAR 0 7
22551: PUSH
22552: LD_VAR 0 8
22556: ST_TO_ADDR
// break ;
22557: GO 22561
// end ;
22559: GO 22533
22561: POP
22562: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22563: LD_VAR 0 7
22567: PUSH
22568: LD_VAR 0 5
22572: PPUSH
22573: LD_VAR 0 7
22577: PPUSH
22578: CALL 83935 0 2
22582: NOT
22583: AND
22584: IFFALSE 22643
// begin if IsInUnit ( p ) then
22586: LD_VAR 0 5
22590: PPUSH
22591: CALL_OW 310
22595: IFFALSE 22606
// ComExitBuilding ( p ) ;
22597: LD_VAR 0 5
22601: PPUSH
22602: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22606: LD_VAR 0 5
22610: PPUSH
22611: LD_VAR 0 7
22615: PPUSH
22616: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22620: LD_VAR 0 5
22624: PPUSH
22625: LD_VAR 0 3
22629: PPUSH
22630: CALL_OW 183
// AddComExitBuilding ( p ) ;
22634: LD_VAR 0 5
22638: PPUSH
22639: CALL_OW 182
// end ; end ;
22643: GO 22491
22645: POP
22646: POP
// end ;
22647: GO 22457
22649: POP
22650: POP
// end ;
22651: GO 22212
22653: POP
22654: POP
// end ;
22655: LD_VAR 0 1
22659: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22660: LD_INT 0
22662: PPUSH
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
22669: PPUSH
22670: PPUSH
22671: PPUSH
22672: PPUSH
22673: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22674: LD_VAR 0 1
22678: NOT
22679: PUSH
22680: LD_EXP 50
22684: PUSH
22685: LD_VAR 0 1
22689: ARRAY
22690: NOT
22691: OR
22692: PUSH
22693: LD_EXP 50
22697: PUSH
22698: LD_VAR 0 1
22702: ARRAY
22703: PPUSH
22704: LD_INT 2
22706: PUSH
22707: LD_INT 30
22709: PUSH
22710: LD_INT 0
22712: PUSH
22713: EMPTY
22714: LIST
22715: LIST
22716: PUSH
22717: LD_INT 30
22719: PUSH
22720: LD_INT 1
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: LIST
22731: PPUSH
22732: CALL_OW 72
22736: NOT
22737: OR
22738: IFFALSE 22742
// exit ;
22740: GO 26245
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22742: LD_ADDR_VAR 0 4
22746: PUSH
22747: LD_EXP 50
22751: PUSH
22752: LD_VAR 0 1
22756: ARRAY
22757: PPUSH
22758: LD_INT 2
22760: PUSH
22761: LD_INT 25
22763: PUSH
22764: LD_INT 1
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: PUSH
22771: LD_INT 25
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: PUSH
22781: LD_INT 25
22783: PUSH
22784: LD_INT 3
22786: PUSH
22787: EMPTY
22788: LIST
22789: LIST
22790: PUSH
22791: LD_INT 25
22793: PUSH
22794: LD_INT 4
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PUSH
22801: LD_INT 25
22803: PUSH
22804: LD_INT 5
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: LD_INT 25
22813: PUSH
22814: LD_INT 8
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: LD_INT 25
22823: PUSH
22824: LD_INT 9
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: PPUSH
22841: CALL_OW 72
22845: ST_TO_ADDR
// if not tmp then
22846: LD_VAR 0 4
22850: NOT
22851: IFFALSE 22855
// exit ;
22853: GO 26245
// for i in tmp do
22855: LD_ADDR_VAR 0 3
22859: PUSH
22860: LD_VAR 0 4
22864: PUSH
22865: FOR_IN
22866: IFFALSE 22897
// if GetTag ( i ) then
22868: LD_VAR 0 3
22872: PPUSH
22873: CALL_OW 110
22877: IFFALSE 22895
// tmp := tmp diff i ;
22879: LD_ADDR_VAR 0 4
22883: PUSH
22884: LD_VAR 0 4
22888: PUSH
22889: LD_VAR 0 3
22893: DIFF
22894: ST_TO_ADDR
22895: GO 22865
22897: POP
22898: POP
// if not tmp then
22899: LD_VAR 0 4
22903: NOT
22904: IFFALSE 22908
// exit ;
22906: GO 26245
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22908: LD_ADDR_VAR 0 5
22912: PUSH
22913: LD_EXP 50
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: PPUSH
22924: LD_INT 2
22926: PUSH
22927: LD_INT 25
22929: PUSH
22930: LD_INT 1
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: PUSH
22937: LD_INT 25
22939: PUSH
22940: LD_INT 5
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: PUSH
22947: LD_INT 25
22949: PUSH
22950: LD_INT 8
22952: PUSH
22953: EMPTY
22954: LIST
22955: LIST
22956: PUSH
22957: LD_INT 25
22959: PUSH
22960: LD_INT 9
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: LIST
22973: PPUSH
22974: CALL_OW 72
22978: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22979: LD_ADDR_VAR 0 6
22983: PUSH
22984: LD_EXP 50
22988: PUSH
22989: LD_VAR 0 1
22993: ARRAY
22994: PPUSH
22995: LD_INT 25
22997: PUSH
22998: LD_INT 2
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: PPUSH
23005: CALL_OW 72
23009: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23010: LD_ADDR_VAR 0 7
23014: PUSH
23015: LD_EXP 50
23019: PUSH
23020: LD_VAR 0 1
23024: ARRAY
23025: PPUSH
23026: LD_INT 25
23028: PUSH
23029: LD_INT 3
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PPUSH
23036: CALL_OW 72
23040: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23041: LD_ADDR_VAR 0 8
23045: PUSH
23046: LD_EXP 50
23050: PUSH
23051: LD_VAR 0 1
23055: ARRAY
23056: PPUSH
23057: LD_INT 25
23059: PUSH
23060: LD_INT 4
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: LD_INT 24
23069: PUSH
23070: LD_INT 251
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: PUSH
23077: EMPTY
23078: LIST
23079: LIST
23080: PPUSH
23081: CALL_OW 72
23085: ST_TO_ADDR
// if mc_is_defending [ base ] then
23086: LD_EXP 93
23090: PUSH
23091: LD_VAR 0 1
23095: ARRAY
23096: IFFALSE 23557
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23098: LD_ADDR_EXP 92
23102: PUSH
23103: LD_EXP 92
23107: PPUSH
23108: LD_VAR 0 1
23112: PPUSH
23113: LD_INT 4
23115: PPUSH
23116: CALL_OW 1
23120: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23121: LD_ADDR_VAR 0 12
23125: PUSH
23126: LD_EXP 50
23130: PUSH
23131: LD_VAR 0 1
23135: ARRAY
23136: PPUSH
23137: LD_INT 2
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 4
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: LD_INT 30
23152: PUSH
23153: LD_INT 5
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: LIST
23164: PPUSH
23165: CALL_OW 72
23169: ST_TO_ADDR
// if not b then
23170: LD_VAR 0 12
23174: NOT
23175: IFFALSE 23179
// exit ;
23177: GO 26245
// p := [ ] ;
23179: LD_ADDR_VAR 0 11
23183: PUSH
23184: EMPTY
23185: ST_TO_ADDR
// if sci >= 2 then
23186: LD_VAR 0 8
23190: PUSH
23191: LD_INT 2
23193: GREATEREQUAL
23194: IFFALSE 23225
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23196: LD_ADDR_VAR 0 8
23200: PUSH
23201: LD_VAR 0 8
23205: PUSH
23206: LD_INT 1
23208: ARRAY
23209: PUSH
23210: LD_VAR 0 8
23214: PUSH
23215: LD_INT 2
23217: ARRAY
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: ST_TO_ADDR
23223: GO 23286
// if sci = 1 then
23225: LD_VAR 0 8
23229: PUSH
23230: LD_INT 1
23232: EQUAL
23233: IFFALSE 23254
// sci := [ sci [ 1 ] ] else
23235: LD_ADDR_VAR 0 8
23239: PUSH
23240: LD_VAR 0 8
23244: PUSH
23245: LD_INT 1
23247: ARRAY
23248: PUSH
23249: EMPTY
23250: LIST
23251: ST_TO_ADDR
23252: GO 23286
// if sci = 0 then
23254: LD_VAR 0 8
23258: PUSH
23259: LD_INT 0
23261: EQUAL
23262: IFFALSE 23286
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23264: LD_ADDR_VAR 0 11
23268: PUSH
23269: LD_VAR 0 4
23273: PPUSH
23274: LD_INT 4
23276: PPUSH
23277: CALL 83798 0 2
23281: PUSH
23282: LD_INT 1
23284: ARRAY
23285: ST_TO_ADDR
// if eng > 4 then
23286: LD_VAR 0 6
23290: PUSH
23291: LD_INT 4
23293: GREATER
23294: IFFALSE 23340
// for i = eng downto 4 do
23296: LD_ADDR_VAR 0 3
23300: PUSH
23301: DOUBLE
23302: LD_VAR 0 6
23306: INC
23307: ST_TO_ADDR
23308: LD_INT 4
23310: PUSH
23311: FOR_DOWNTO
23312: IFFALSE 23338
// eng := eng diff eng [ i ] ;
23314: LD_ADDR_VAR 0 6
23318: PUSH
23319: LD_VAR 0 6
23323: PUSH
23324: LD_VAR 0 6
23328: PUSH
23329: LD_VAR 0 3
23333: ARRAY
23334: DIFF
23335: ST_TO_ADDR
23336: GO 23311
23338: POP
23339: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23340: LD_ADDR_VAR 0 4
23344: PUSH
23345: LD_VAR 0 4
23349: PUSH
23350: LD_VAR 0 5
23354: PUSH
23355: LD_VAR 0 6
23359: UNION
23360: PUSH
23361: LD_VAR 0 7
23365: UNION
23366: PUSH
23367: LD_VAR 0 8
23371: UNION
23372: DIFF
23373: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23374: LD_ADDR_VAR 0 13
23378: PUSH
23379: LD_EXP 50
23383: PUSH
23384: LD_VAR 0 1
23388: ARRAY
23389: PPUSH
23390: LD_INT 2
23392: PUSH
23393: LD_INT 30
23395: PUSH
23396: LD_INT 32
23398: PUSH
23399: EMPTY
23400: LIST
23401: LIST
23402: PUSH
23403: LD_INT 30
23405: PUSH
23406: LD_INT 31
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: PUSH
23413: EMPTY
23414: LIST
23415: LIST
23416: LIST
23417: PPUSH
23418: CALL_OW 72
23422: PUSH
23423: LD_EXP 50
23427: PUSH
23428: LD_VAR 0 1
23432: ARRAY
23433: PPUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 30
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 30
23449: PUSH
23450: LD_INT 5
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: PPUSH
23462: CALL_OW 72
23466: PUSH
23467: LD_INT 6
23469: MUL
23470: PLUS
23471: ST_TO_ADDR
// if bcount < tmp then
23472: LD_VAR 0 13
23476: PUSH
23477: LD_VAR 0 4
23481: LESS
23482: IFFALSE 23528
// for i = tmp downto bcount do
23484: LD_ADDR_VAR 0 3
23488: PUSH
23489: DOUBLE
23490: LD_VAR 0 4
23494: INC
23495: ST_TO_ADDR
23496: LD_VAR 0 13
23500: PUSH
23501: FOR_DOWNTO
23502: IFFALSE 23526
// tmp := Delete ( tmp , tmp ) ;
23504: LD_ADDR_VAR 0 4
23508: PUSH
23509: LD_VAR 0 4
23513: PPUSH
23514: LD_VAR 0 4
23518: PPUSH
23519: CALL_OW 3
23523: ST_TO_ADDR
23524: GO 23501
23526: POP
23527: POP
// result := [ tmp , 0 , 0 , p ] ;
23528: LD_ADDR_VAR 0 2
23532: PUSH
23533: LD_VAR 0 4
23537: PUSH
23538: LD_INT 0
23540: PUSH
23541: LD_INT 0
23543: PUSH
23544: LD_VAR 0 11
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: LIST
23553: LIST
23554: ST_TO_ADDR
// exit ;
23555: GO 26245
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23557: LD_EXP 50
23561: PUSH
23562: LD_VAR 0 1
23566: ARRAY
23567: PPUSH
23568: LD_INT 2
23570: PUSH
23571: LD_INT 30
23573: PUSH
23574: LD_INT 6
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: PUSH
23581: LD_INT 30
23583: PUSH
23584: LD_INT 7
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: PUSH
23591: LD_INT 30
23593: PUSH
23594: LD_INT 8
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: PPUSH
23607: CALL_OW 72
23611: NOT
23612: PUSH
23613: LD_EXP 50
23617: PUSH
23618: LD_VAR 0 1
23622: ARRAY
23623: PPUSH
23624: LD_INT 30
23626: PUSH
23627: LD_INT 3
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: PPUSH
23634: CALL_OW 72
23638: NOT
23639: AND
23640: IFFALSE 23712
// begin if eng = tmp then
23642: LD_VAR 0 6
23646: PUSH
23647: LD_VAR 0 4
23651: EQUAL
23652: IFFALSE 23656
// exit ;
23654: GO 26245
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23656: LD_ADDR_EXP 92
23660: PUSH
23661: LD_EXP 92
23665: PPUSH
23666: LD_VAR 0 1
23670: PPUSH
23671: LD_INT 1
23673: PPUSH
23674: CALL_OW 1
23678: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23679: LD_ADDR_VAR 0 2
23683: PUSH
23684: LD_INT 0
23686: PUSH
23687: LD_VAR 0 4
23691: PUSH
23692: LD_VAR 0 6
23696: DIFF
23697: PUSH
23698: LD_INT 0
23700: PUSH
23701: LD_INT 0
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: LIST
23708: LIST
23709: ST_TO_ADDR
// exit ;
23710: GO 26245
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23712: LD_EXP 77
23716: PUSH
23717: LD_EXP 76
23721: PUSH
23722: LD_VAR 0 1
23726: ARRAY
23727: ARRAY
23728: PUSH
23729: LD_EXP 50
23733: PUSH
23734: LD_VAR 0 1
23738: ARRAY
23739: PPUSH
23740: LD_INT 2
23742: PUSH
23743: LD_INT 30
23745: PUSH
23746: LD_INT 6
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PUSH
23753: LD_INT 30
23755: PUSH
23756: LD_INT 7
23758: PUSH
23759: EMPTY
23760: LIST
23761: LIST
23762: PUSH
23763: LD_INT 30
23765: PUSH
23766: LD_INT 8
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: LIST
23777: LIST
23778: PPUSH
23779: CALL_OW 72
23783: AND
23784: PUSH
23785: LD_EXP 50
23789: PUSH
23790: LD_VAR 0 1
23794: ARRAY
23795: PPUSH
23796: LD_INT 30
23798: PUSH
23799: LD_INT 3
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: PPUSH
23806: CALL_OW 72
23810: NOT
23811: AND
23812: IFFALSE 24026
// begin if sci >= 6 then
23814: LD_VAR 0 8
23818: PUSH
23819: LD_INT 6
23821: GREATEREQUAL
23822: IFFALSE 23826
// exit ;
23824: GO 26245
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23826: LD_ADDR_EXP 92
23830: PUSH
23831: LD_EXP 92
23835: PPUSH
23836: LD_VAR 0 1
23840: PPUSH
23841: LD_INT 2
23843: PPUSH
23844: CALL_OW 1
23848: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23849: LD_ADDR_VAR 0 9
23853: PUSH
23854: LD_VAR 0 4
23858: PUSH
23859: LD_VAR 0 8
23863: DIFF
23864: PPUSH
23865: LD_INT 4
23867: PPUSH
23868: CALL 83798 0 2
23872: ST_TO_ADDR
// p := [ ] ;
23873: LD_ADDR_VAR 0 11
23877: PUSH
23878: EMPTY
23879: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23880: LD_VAR 0 8
23884: PUSH
23885: LD_INT 6
23887: LESS
23888: PUSH
23889: LD_VAR 0 9
23893: PUSH
23894: LD_INT 6
23896: GREATER
23897: AND
23898: IFFALSE 23979
// begin for i = 1 to 6 - sci do
23900: LD_ADDR_VAR 0 3
23904: PUSH
23905: DOUBLE
23906: LD_INT 1
23908: DEC
23909: ST_TO_ADDR
23910: LD_INT 6
23912: PUSH
23913: LD_VAR 0 8
23917: MINUS
23918: PUSH
23919: FOR_TO
23920: IFFALSE 23975
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23922: LD_ADDR_VAR 0 11
23926: PUSH
23927: LD_VAR 0 11
23931: PPUSH
23932: LD_VAR 0 11
23936: PUSH
23937: LD_INT 1
23939: PLUS
23940: PPUSH
23941: LD_VAR 0 9
23945: PUSH
23946: LD_INT 1
23948: ARRAY
23949: PPUSH
23950: CALL_OW 2
23954: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23955: LD_ADDR_VAR 0 9
23959: PUSH
23960: LD_VAR 0 9
23964: PPUSH
23965: LD_INT 1
23967: PPUSH
23968: CALL_OW 3
23972: ST_TO_ADDR
// end ;
23973: GO 23919
23975: POP
23976: POP
// end else
23977: GO 23999
// if sort then
23979: LD_VAR 0 9
23983: IFFALSE 23999
// p := sort [ 1 ] ;
23985: LD_ADDR_VAR 0 11
23989: PUSH
23990: LD_VAR 0 9
23994: PUSH
23995: LD_INT 1
23997: ARRAY
23998: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23999: LD_ADDR_VAR 0 2
24003: PUSH
24004: LD_INT 0
24006: PUSH
24007: LD_INT 0
24009: PUSH
24010: LD_INT 0
24012: PUSH
24013: LD_VAR 0 11
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: LIST
24022: LIST
24023: ST_TO_ADDR
// exit ;
24024: GO 26245
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24026: LD_EXP 77
24030: PUSH
24031: LD_EXP 76
24035: PUSH
24036: LD_VAR 0 1
24040: ARRAY
24041: ARRAY
24042: PUSH
24043: LD_EXP 50
24047: PUSH
24048: LD_VAR 0 1
24052: ARRAY
24053: PPUSH
24054: LD_INT 2
24056: PUSH
24057: LD_INT 30
24059: PUSH
24060: LD_INT 6
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: PUSH
24067: LD_INT 30
24069: PUSH
24070: LD_INT 7
24072: PUSH
24073: EMPTY
24074: LIST
24075: LIST
24076: PUSH
24077: LD_INT 30
24079: PUSH
24080: LD_INT 8
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: PPUSH
24093: CALL_OW 72
24097: AND
24098: PUSH
24099: LD_EXP 50
24103: PUSH
24104: LD_VAR 0 1
24108: ARRAY
24109: PPUSH
24110: LD_INT 30
24112: PUSH
24113: LD_INT 3
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PPUSH
24120: CALL_OW 72
24124: AND
24125: IFFALSE 24859
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24127: LD_ADDR_EXP 92
24131: PUSH
24132: LD_EXP 92
24136: PPUSH
24137: LD_VAR 0 1
24141: PPUSH
24142: LD_INT 3
24144: PPUSH
24145: CALL_OW 1
24149: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: LD_INT 0
24160: PUSH
24161: LD_INT 0
24163: PUSH
24164: LD_INT 0
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: LIST
24171: LIST
24172: ST_TO_ADDR
// if not eng then
24173: LD_VAR 0 6
24177: NOT
24178: IFFALSE 24241
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24180: LD_ADDR_VAR 0 11
24184: PUSH
24185: LD_VAR 0 4
24189: PPUSH
24190: LD_INT 2
24192: PPUSH
24193: CALL 83798 0 2
24197: PUSH
24198: LD_INT 1
24200: ARRAY
24201: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24202: LD_ADDR_VAR 0 2
24206: PUSH
24207: LD_VAR 0 2
24211: PPUSH
24212: LD_INT 2
24214: PPUSH
24215: LD_VAR 0 11
24219: PPUSH
24220: CALL_OW 1
24224: ST_TO_ADDR
// tmp := tmp diff p ;
24225: LD_ADDR_VAR 0 4
24229: PUSH
24230: LD_VAR 0 4
24234: PUSH
24235: LD_VAR 0 11
24239: DIFF
24240: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24241: LD_VAR 0 4
24245: PUSH
24246: LD_VAR 0 8
24250: PUSH
24251: LD_INT 6
24253: LESS
24254: AND
24255: IFFALSE 24443
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24257: LD_ADDR_VAR 0 9
24261: PUSH
24262: LD_VAR 0 4
24266: PUSH
24267: LD_VAR 0 8
24271: PUSH
24272: LD_VAR 0 7
24276: UNION
24277: DIFF
24278: PPUSH
24279: LD_INT 4
24281: PPUSH
24282: CALL 83798 0 2
24286: ST_TO_ADDR
// p := [ ] ;
24287: LD_ADDR_VAR 0 11
24291: PUSH
24292: EMPTY
24293: ST_TO_ADDR
// if sort then
24294: LD_VAR 0 9
24298: IFFALSE 24414
// for i = 1 to 6 - sci do
24300: LD_ADDR_VAR 0 3
24304: PUSH
24305: DOUBLE
24306: LD_INT 1
24308: DEC
24309: ST_TO_ADDR
24310: LD_INT 6
24312: PUSH
24313: LD_VAR 0 8
24317: MINUS
24318: PUSH
24319: FOR_TO
24320: IFFALSE 24412
// begin if i = sort then
24322: LD_VAR 0 3
24326: PUSH
24327: LD_VAR 0 9
24331: EQUAL
24332: IFFALSE 24336
// break ;
24334: GO 24412
// if GetClass ( i ) = 4 then
24336: LD_VAR 0 3
24340: PPUSH
24341: CALL_OW 257
24345: PUSH
24346: LD_INT 4
24348: EQUAL
24349: IFFALSE 24353
// continue ;
24351: GO 24319
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24353: LD_ADDR_VAR 0 11
24357: PUSH
24358: LD_VAR 0 11
24362: PPUSH
24363: LD_VAR 0 11
24367: PUSH
24368: LD_INT 1
24370: PLUS
24371: PPUSH
24372: LD_VAR 0 9
24376: PUSH
24377: LD_VAR 0 3
24381: ARRAY
24382: PPUSH
24383: CALL_OW 2
24387: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24388: LD_ADDR_VAR 0 4
24392: PUSH
24393: LD_VAR 0 4
24397: PUSH
24398: LD_VAR 0 9
24402: PUSH
24403: LD_VAR 0 3
24407: ARRAY
24408: DIFF
24409: ST_TO_ADDR
// end ;
24410: GO 24319
24412: POP
24413: POP
// if p then
24414: LD_VAR 0 11
24418: IFFALSE 24443
// result := Replace ( result , 4 , p ) ;
24420: LD_ADDR_VAR 0 2
24424: PUSH
24425: LD_VAR 0 2
24429: PPUSH
24430: LD_INT 4
24432: PPUSH
24433: LD_VAR 0 11
24437: PPUSH
24438: CALL_OW 1
24442: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24443: LD_VAR 0 4
24447: PUSH
24448: LD_VAR 0 7
24452: PUSH
24453: LD_INT 6
24455: LESS
24456: AND
24457: IFFALSE 24645
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24459: LD_ADDR_VAR 0 9
24463: PUSH
24464: LD_VAR 0 4
24468: PUSH
24469: LD_VAR 0 8
24473: PUSH
24474: LD_VAR 0 7
24478: UNION
24479: DIFF
24480: PPUSH
24481: LD_INT 3
24483: PPUSH
24484: CALL 83798 0 2
24488: ST_TO_ADDR
// p := [ ] ;
24489: LD_ADDR_VAR 0 11
24493: PUSH
24494: EMPTY
24495: ST_TO_ADDR
// if sort then
24496: LD_VAR 0 9
24500: IFFALSE 24616
// for i = 1 to 6 - mech do
24502: LD_ADDR_VAR 0 3
24506: PUSH
24507: DOUBLE
24508: LD_INT 1
24510: DEC
24511: ST_TO_ADDR
24512: LD_INT 6
24514: PUSH
24515: LD_VAR 0 7
24519: MINUS
24520: PUSH
24521: FOR_TO
24522: IFFALSE 24614
// begin if i = sort then
24524: LD_VAR 0 3
24528: PUSH
24529: LD_VAR 0 9
24533: EQUAL
24534: IFFALSE 24538
// break ;
24536: GO 24614
// if GetClass ( i ) = 3 then
24538: LD_VAR 0 3
24542: PPUSH
24543: CALL_OW 257
24547: PUSH
24548: LD_INT 3
24550: EQUAL
24551: IFFALSE 24555
// continue ;
24553: GO 24521
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: LD_VAR 0 11
24564: PPUSH
24565: LD_VAR 0 11
24569: PUSH
24570: LD_INT 1
24572: PLUS
24573: PPUSH
24574: LD_VAR 0 9
24578: PUSH
24579: LD_VAR 0 3
24583: ARRAY
24584: PPUSH
24585: CALL_OW 2
24589: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24590: LD_ADDR_VAR 0 4
24594: PUSH
24595: LD_VAR 0 4
24599: PUSH
24600: LD_VAR 0 9
24604: PUSH
24605: LD_VAR 0 3
24609: ARRAY
24610: DIFF
24611: ST_TO_ADDR
// end ;
24612: GO 24521
24614: POP
24615: POP
// if p then
24616: LD_VAR 0 11
24620: IFFALSE 24645
// result := Replace ( result , 3 , p ) ;
24622: LD_ADDR_VAR 0 2
24626: PUSH
24627: LD_VAR 0 2
24631: PPUSH
24632: LD_INT 3
24634: PPUSH
24635: LD_VAR 0 11
24639: PPUSH
24640: CALL_OW 1
24644: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24645: LD_VAR 0 4
24649: PUSH
24650: LD_INT 6
24652: GREATER
24653: PUSH
24654: LD_VAR 0 6
24658: PUSH
24659: LD_INT 6
24661: LESS
24662: AND
24663: IFFALSE 24857
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24665: LD_ADDR_VAR 0 9
24669: PUSH
24670: LD_VAR 0 4
24674: PUSH
24675: LD_VAR 0 8
24679: PUSH
24680: LD_VAR 0 7
24684: UNION
24685: PUSH
24686: LD_VAR 0 6
24690: UNION
24691: DIFF
24692: PPUSH
24693: LD_INT 2
24695: PPUSH
24696: CALL 83798 0 2
24700: ST_TO_ADDR
// p := [ ] ;
24701: LD_ADDR_VAR 0 11
24705: PUSH
24706: EMPTY
24707: ST_TO_ADDR
// if sort then
24708: LD_VAR 0 9
24712: IFFALSE 24828
// for i = 1 to 6 - eng do
24714: LD_ADDR_VAR 0 3
24718: PUSH
24719: DOUBLE
24720: LD_INT 1
24722: DEC
24723: ST_TO_ADDR
24724: LD_INT 6
24726: PUSH
24727: LD_VAR 0 6
24731: MINUS
24732: PUSH
24733: FOR_TO
24734: IFFALSE 24826
// begin if i = sort then
24736: LD_VAR 0 3
24740: PUSH
24741: LD_VAR 0 9
24745: EQUAL
24746: IFFALSE 24750
// break ;
24748: GO 24826
// if GetClass ( i ) = 2 then
24750: LD_VAR 0 3
24754: PPUSH
24755: CALL_OW 257
24759: PUSH
24760: LD_INT 2
24762: EQUAL
24763: IFFALSE 24767
// continue ;
24765: GO 24733
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24767: LD_ADDR_VAR 0 11
24771: PUSH
24772: LD_VAR 0 11
24776: PPUSH
24777: LD_VAR 0 11
24781: PUSH
24782: LD_INT 1
24784: PLUS
24785: PPUSH
24786: LD_VAR 0 9
24790: PUSH
24791: LD_VAR 0 3
24795: ARRAY
24796: PPUSH
24797: CALL_OW 2
24801: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24802: LD_ADDR_VAR 0 4
24806: PUSH
24807: LD_VAR 0 4
24811: PUSH
24812: LD_VAR 0 9
24816: PUSH
24817: LD_VAR 0 3
24821: ARRAY
24822: DIFF
24823: ST_TO_ADDR
// end ;
24824: GO 24733
24826: POP
24827: POP
// if p then
24828: LD_VAR 0 11
24832: IFFALSE 24857
// result := Replace ( result , 2 , p ) ;
24834: LD_ADDR_VAR 0 2
24838: PUSH
24839: LD_VAR 0 2
24843: PPUSH
24844: LD_INT 2
24846: PPUSH
24847: LD_VAR 0 11
24851: PPUSH
24852: CALL_OW 1
24856: ST_TO_ADDR
// end ; exit ;
24857: GO 26245
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24859: LD_EXP 77
24863: PUSH
24864: LD_EXP 76
24868: PUSH
24869: LD_VAR 0 1
24873: ARRAY
24874: ARRAY
24875: NOT
24876: PUSH
24877: LD_EXP 50
24881: PUSH
24882: LD_VAR 0 1
24886: ARRAY
24887: PPUSH
24888: LD_INT 30
24890: PUSH
24891: LD_INT 3
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PPUSH
24898: CALL_OW 72
24902: AND
24903: PUSH
24904: LD_EXP 55
24908: PUSH
24909: LD_VAR 0 1
24913: ARRAY
24914: AND
24915: IFFALSE 25523
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24917: LD_ADDR_EXP 92
24921: PUSH
24922: LD_EXP 92
24926: PPUSH
24927: LD_VAR 0 1
24931: PPUSH
24932: LD_INT 5
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24940: LD_ADDR_VAR 0 2
24944: PUSH
24945: LD_INT 0
24947: PUSH
24948: LD_INT 0
24950: PUSH
24951: LD_INT 0
24953: PUSH
24954: LD_INT 0
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: ST_TO_ADDR
// if sci > 1 then
24963: LD_VAR 0 8
24967: PUSH
24968: LD_INT 1
24970: GREATER
24971: IFFALSE 24999
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24973: LD_ADDR_VAR 0 4
24977: PUSH
24978: LD_VAR 0 4
24982: PUSH
24983: LD_VAR 0 8
24987: PUSH
24988: LD_VAR 0 8
24992: PUSH
24993: LD_INT 1
24995: ARRAY
24996: DIFF
24997: DIFF
24998: ST_TO_ADDR
// if tmp and not sci then
24999: LD_VAR 0 4
25003: PUSH
25004: LD_VAR 0 8
25008: NOT
25009: AND
25010: IFFALSE 25079
// begin sort := SortBySkill ( tmp , 4 ) ;
25012: LD_ADDR_VAR 0 9
25016: PUSH
25017: LD_VAR 0 4
25021: PPUSH
25022: LD_INT 4
25024: PPUSH
25025: CALL 83798 0 2
25029: ST_TO_ADDR
// if sort then
25030: LD_VAR 0 9
25034: IFFALSE 25050
// p := sort [ 1 ] ;
25036: LD_ADDR_VAR 0 11
25040: PUSH
25041: LD_VAR 0 9
25045: PUSH
25046: LD_INT 1
25048: ARRAY
25049: ST_TO_ADDR
// if p then
25050: LD_VAR 0 11
25054: IFFALSE 25079
// result := Replace ( result , 4 , p ) ;
25056: LD_ADDR_VAR 0 2
25060: PUSH
25061: LD_VAR 0 2
25065: PPUSH
25066: LD_INT 4
25068: PPUSH
25069: LD_VAR 0 11
25073: PPUSH
25074: CALL_OW 1
25078: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25079: LD_ADDR_VAR 0 4
25083: PUSH
25084: LD_VAR 0 4
25088: PUSH
25089: LD_VAR 0 7
25093: DIFF
25094: ST_TO_ADDR
// if tmp and mech < 6 then
25095: LD_VAR 0 4
25099: PUSH
25100: LD_VAR 0 7
25104: PUSH
25105: LD_INT 6
25107: LESS
25108: AND
25109: IFFALSE 25297
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25111: LD_ADDR_VAR 0 9
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_VAR 0 8
25125: PUSH
25126: LD_VAR 0 7
25130: UNION
25131: DIFF
25132: PPUSH
25133: LD_INT 3
25135: PPUSH
25136: CALL 83798 0 2
25140: ST_TO_ADDR
// p := [ ] ;
25141: LD_ADDR_VAR 0 11
25145: PUSH
25146: EMPTY
25147: ST_TO_ADDR
// if sort then
25148: LD_VAR 0 9
25152: IFFALSE 25268
// for i = 1 to 6 - mech do
25154: LD_ADDR_VAR 0 3
25158: PUSH
25159: DOUBLE
25160: LD_INT 1
25162: DEC
25163: ST_TO_ADDR
25164: LD_INT 6
25166: PUSH
25167: LD_VAR 0 7
25171: MINUS
25172: PUSH
25173: FOR_TO
25174: IFFALSE 25266
// begin if i = sort then
25176: LD_VAR 0 3
25180: PUSH
25181: LD_VAR 0 9
25185: EQUAL
25186: IFFALSE 25190
// break ;
25188: GO 25266
// if GetClass ( i ) = 3 then
25190: LD_VAR 0 3
25194: PPUSH
25195: CALL_OW 257
25199: PUSH
25200: LD_INT 3
25202: EQUAL
25203: IFFALSE 25207
// continue ;
25205: GO 25173
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25207: LD_ADDR_VAR 0 11
25211: PUSH
25212: LD_VAR 0 11
25216: PPUSH
25217: LD_VAR 0 11
25221: PUSH
25222: LD_INT 1
25224: PLUS
25225: PPUSH
25226: LD_VAR 0 9
25230: PUSH
25231: LD_VAR 0 3
25235: ARRAY
25236: PPUSH
25237: CALL_OW 2
25241: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25242: LD_ADDR_VAR 0 4
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_VAR 0 9
25256: PUSH
25257: LD_VAR 0 3
25261: ARRAY
25262: DIFF
25263: ST_TO_ADDR
// end ;
25264: GO 25173
25266: POP
25267: POP
// if p then
25268: LD_VAR 0 11
25272: IFFALSE 25297
// result := Replace ( result , 3 , p ) ;
25274: LD_ADDR_VAR 0 2
25278: PUSH
25279: LD_VAR 0 2
25283: PPUSH
25284: LD_INT 3
25286: PPUSH
25287: LD_VAR 0 11
25291: PPUSH
25292: CALL_OW 1
25296: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25297: LD_ADDR_VAR 0 4
25301: PUSH
25302: LD_VAR 0 4
25306: PUSH
25307: LD_VAR 0 6
25311: DIFF
25312: ST_TO_ADDR
// if tmp and eng < 6 then
25313: LD_VAR 0 4
25317: PUSH
25318: LD_VAR 0 6
25322: PUSH
25323: LD_INT 6
25325: LESS
25326: AND
25327: IFFALSE 25521
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25329: LD_ADDR_VAR 0 9
25333: PUSH
25334: LD_VAR 0 4
25338: PUSH
25339: LD_VAR 0 8
25343: PUSH
25344: LD_VAR 0 7
25348: UNION
25349: PUSH
25350: LD_VAR 0 6
25354: UNION
25355: DIFF
25356: PPUSH
25357: LD_INT 2
25359: PPUSH
25360: CALL 83798 0 2
25364: ST_TO_ADDR
// p := [ ] ;
25365: LD_ADDR_VAR 0 11
25369: PUSH
25370: EMPTY
25371: ST_TO_ADDR
// if sort then
25372: LD_VAR 0 9
25376: IFFALSE 25492
// for i = 1 to 6 - eng do
25378: LD_ADDR_VAR 0 3
25382: PUSH
25383: DOUBLE
25384: LD_INT 1
25386: DEC
25387: ST_TO_ADDR
25388: LD_INT 6
25390: PUSH
25391: LD_VAR 0 6
25395: MINUS
25396: PUSH
25397: FOR_TO
25398: IFFALSE 25490
// begin if i = sort then
25400: LD_VAR 0 3
25404: PUSH
25405: LD_VAR 0 9
25409: EQUAL
25410: IFFALSE 25414
// break ;
25412: GO 25490
// if GetClass ( i ) = 2 then
25414: LD_VAR 0 3
25418: PPUSH
25419: CALL_OW 257
25423: PUSH
25424: LD_INT 2
25426: EQUAL
25427: IFFALSE 25431
// continue ;
25429: GO 25397
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25431: LD_ADDR_VAR 0 11
25435: PUSH
25436: LD_VAR 0 11
25440: PPUSH
25441: LD_VAR 0 11
25445: PUSH
25446: LD_INT 1
25448: PLUS
25449: PPUSH
25450: LD_VAR 0 9
25454: PUSH
25455: LD_VAR 0 3
25459: ARRAY
25460: PPUSH
25461: CALL_OW 2
25465: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25466: LD_ADDR_VAR 0 4
25470: PUSH
25471: LD_VAR 0 4
25475: PUSH
25476: LD_VAR 0 9
25480: PUSH
25481: LD_VAR 0 3
25485: ARRAY
25486: DIFF
25487: ST_TO_ADDR
// end ;
25488: GO 25397
25490: POP
25491: POP
// if p then
25492: LD_VAR 0 11
25496: IFFALSE 25521
// result := Replace ( result , 2 , p ) ;
25498: LD_ADDR_VAR 0 2
25502: PUSH
25503: LD_VAR 0 2
25507: PPUSH
25508: LD_INT 2
25510: PPUSH
25511: LD_VAR 0 11
25515: PPUSH
25516: CALL_OW 1
25520: ST_TO_ADDR
// end ; exit ;
25521: GO 26245
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25523: LD_EXP 77
25527: PUSH
25528: LD_EXP 76
25532: PUSH
25533: LD_VAR 0 1
25537: ARRAY
25538: ARRAY
25539: NOT
25540: PUSH
25541: LD_EXP 50
25545: PUSH
25546: LD_VAR 0 1
25550: ARRAY
25551: PPUSH
25552: LD_INT 30
25554: PUSH
25555: LD_INT 3
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PPUSH
25562: CALL_OW 72
25566: AND
25567: PUSH
25568: LD_EXP 55
25572: PUSH
25573: LD_VAR 0 1
25577: ARRAY
25578: NOT
25579: AND
25580: IFFALSE 26245
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25582: LD_ADDR_EXP 92
25586: PUSH
25587: LD_EXP 92
25591: PPUSH
25592: LD_VAR 0 1
25596: PPUSH
25597: LD_INT 6
25599: PPUSH
25600: CALL_OW 1
25604: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25605: LD_ADDR_VAR 0 2
25609: PUSH
25610: LD_INT 0
25612: PUSH
25613: LD_INT 0
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: ST_TO_ADDR
// if sci >= 1 then
25628: LD_VAR 0 8
25632: PUSH
25633: LD_INT 1
25635: GREATEREQUAL
25636: IFFALSE 25658
// tmp := tmp diff sci [ 1 ] ;
25638: LD_ADDR_VAR 0 4
25642: PUSH
25643: LD_VAR 0 4
25647: PUSH
25648: LD_VAR 0 8
25652: PUSH
25653: LD_INT 1
25655: ARRAY
25656: DIFF
25657: ST_TO_ADDR
// if tmp and not sci then
25658: LD_VAR 0 4
25662: PUSH
25663: LD_VAR 0 8
25667: NOT
25668: AND
25669: IFFALSE 25738
// begin sort := SortBySkill ( tmp , 4 ) ;
25671: LD_ADDR_VAR 0 9
25675: PUSH
25676: LD_VAR 0 4
25680: PPUSH
25681: LD_INT 4
25683: PPUSH
25684: CALL 83798 0 2
25688: ST_TO_ADDR
// if sort then
25689: LD_VAR 0 9
25693: IFFALSE 25709
// p := sort [ 1 ] ;
25695: LD_ADDR_VAR 0 11
25699: PUSH
25700: LD_VAR 0 9
25704: PUSH
25705: LD_INT 1
25707: ARRAY
25708: ST_TO_ADDR
// if p then
25709: LD_VAR 0 11
25713: IFFALSE 25738
// result := Replace ( result , 4 , p ) ;
25715: LD_ADDR_VAR 0 2
25719: PUSH
25720: LD_VAR 0 2
25724: PPUSH
25725: LD_INT 4
25727: PPUSH
25728: LD_VAR 0 11
25732: PPUSH
25733: CALL_OW 1
25737: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25738: LD_ADDR_VAR 0 4
25742: PUSH
25743: LD_VAR 0 4
25747: PUSH
25748: LD_VAR 0 7
25752: DIFF
25753: ST_TO_ADDR
// if tmp and mech < 6 then
25754: LD_VAR 0 4
25758: PUSH
25759: LD_VAR 0 7
25763: PUSH
25764: LD_INT 6
25766: LESS
25767: AND
25768: IFFALSE 25950
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25770: LD_ADDR_VAR 0 9
25774: PUSH
25775: LD_VAR 0 4
25779: PUSH
25780: LD_VAR 0 7
25784: DIFF
25785: PPUSH
25786: LD_INT 3
25788: PPUSH
25789: CALL 83798 0 2
25793: ST_TO_ADDR
// p := [ ] ;
25794: LD_ADDR_VAR 0 11
25798: PUSH
25799: EMPTY
25800: ST_TO_ADDR
// if sort then
25801: LD_VAR 0 9
25805: IFFALSE 25921
// for i = 1 to 6 - mech do
25807: LD_ADDR_VAR 0 3
25811: PUSH
25812: DOUBLE
25813: LD_INT 1
25815: DEC
25816: ST_TO_ADDR
25817: LD_INT 6
25819: PUSH
25820: LD_VAR 0 7
25824: MINUS
25825: PUSH
25826: FOR_TO
25827: IFFALSE 25919
// begin if i = sort then
25829: LD_VAR 0 3
25833: PUSH
25834: LD_VAR 0 9
25838: EQUAL
25839: IFFALSE 25843
// break ;
25841: GO 25919
// if GetClass ( i ) = 3 then
25843: LD_VAR 0 3
25847: PPUSH
25848: CALL_OW 257
25852: PUSH
25853: LD_INT 3
25855: EQUAL
25856: IFFALSE 25860
// continue ;
25858: GO 25826
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25860: LD_ADDR_VAR 0 11
25864: PUSH
25865: LD_VAR 0 11
25869: PPUSH
25870: LD_VAR 0 11
25874: PUSH
25875: LD_INT 1
25877: PLUS
25878: PPUSH
25879: LD_VAR 0 9
25883: PUSH
25884: LD_VAR 0 3
25888: ARRAY
25889: PPUSH
25890: CALL_OW 2
25894: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25895: LD_ADDR_VAR 0 4
25899: PUSH
25900: LD_VAR 0 4
25904: PUSH
25905: LD_VAR 0 9
25909: PUSH
25910: LD_VAR 0 3
25914: ARRAY
25915: DIFF
25916: ST_TO_ADDR
// end ;
25917: GO 25826
25919: POP
25920: POP
// if p then
25921: LD_VAR 0 11
25925: IFFALSE 25950
// result := Replace ( result , 3 , p ) ;
25927: LD_ADDR_VAR 0 2
25931: PUSH
25932: LD_VAR 0 2
25936: PPUSH
25937: LD_INT 3
25939: PPUSH
25940: LD_VAR 0 11
25944: PPUSH
25945: CALL_OW 1
25949: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25950: LD_ADDR_VAR 0 4
25954: PUSH
25955: LD_VAR 0 4
25959: PUSH
25960: LD_VAR 0 6
25964: DIFF
25965: ST_TO_ADDR
// if tmp and eng < 4 then
25966: LD_VAR 0 4
25970: PUSH
25971: LD_VAR 0 6
25975: PUSH
25976: LD_INT 4
25978: LESS
25979: AND
25980: IFFALSE 26170
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25982: LD_ADDR_VAR 0 9
25986: PUSH
25987: LD_VAR 0 4
25991: PUSH
25992: LD_VAR 0 7
25996: PUSH
25997: LD_VAR 0 6
26001: UNION
26002: DIFF
26003: PPUSH
26004: LD_INT 2
26006: PPUSH
26007: CALL 83798 0 2
26011: ST_TO_ADDR
// p := [ ] ;
26012: LD_ADDR_VAR 0 11
26016: PUSH
26017: EMPTY
26018: ST_TO_ADDR
// if sort then
26019: LD_VAR 0 9
26023: IFFALSE 26139
// for i = 1 to 4 - eng do
26025: LD_ADDR_VAR 0 3
26029: PUSH
26030: DOUBLE
26031: LD_INT 1
26033: DEC
26034: ST_TO_ADDR
26035: LD_INT 4
26037: PUSH
26038: LD_VAR 0 6
26042: MINUS
26043: PUSH
26044: FOR_TO
26045: IFFALSE 26137
// begin if i = sort then
26047: LD_VAR 0 3
26051: PUSH
26052: LD_VAR 0 9
26056: EQUAL
26057: IFFALSE 26061
// break ;
26059: GO 26137
// if GetClass ( i ) = 2 then
26061: LD_VAR 0 3
26065: PPUSH
26066: CALL_OW 257
26070: PUSH
26071: LD_INT 2
26073: EQUAL
26074: IFFALSE 26078
// continue ;
26076: GO 26044
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26078: LD_ADDR_VAR 0 11
26082: PUSH
26083: LD_VAR 0 11
26087: PPUSH
26088: LD_VAR 0 11
26092: PUSH
26093: LD_INT 1
26095: PLUS
26096: PPUSH
26097: LD_VAR 0 9
26101: PUSH
26102: LD_VAR 0 3
26106: ARRAY
26107: PPUSH
26108: CALL_OW 2
26112: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26113: LD_ADDR_VAR 0 4
26117: PUSH
26118: LD_VAR 0 4
26122: PUSH
26123: LD_VAR 0 9
26127: PUSH
26128: LD_VAR 0 3
26132: ARRAY
26133: DIFF
26134: ST_TO_ADDR
// end ;
26135: GO 26044
26137: POP
26138: POP
// if p then
26139: LD_VAR 0 11
26143: IFFALSE 26168
// result := Replace ( result , 2 , p ) ;
26145: LD_ADDR_VAR 0 2
26149: PUSH
26150: LD_VAR 0 2
26154: PPUSH
26155: LD_INT 2
26157: PPUSH
26158: LD_VAR 0 11
26162: PPUSH
26163: CALL_OW 1
26167: ST_TO_ADDR
// end else
26168: GO 26214
// for i = eng downto 5 do
26170: LD_ADDR_VAR 0 3
26174: PUSH
26175: DOUBLE
26176: LD_VAR 0 6
26180: INC
26181: ST_TO_ADDR
26182: LD_INT 5
26184: PUSH
26185: FOR_DOWNTO
26186: IFFALSE 26212
// tmp := tmp union eng [ i ] ;
26188: LD_ADDR_VAR 0 4
26192: PUSH
26193: LD_VAR 0 4
26197: PUSH
26198: LD_VAR 0 6
26202: PUSH
26203: LD_VAR 0 3
26207: ARRAY
26208: UNION
26209: ST_TO_ADDR
26210: GO 26185
26212: POP
26213: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26214: LD_ADDR_VAR 0 2
26218: PUSH
26219: LD_VAR 0 2
26223: PPUSH
26224: LD_INT 1
26226: PPUSH
26227: LD_VAR 0 4
26231: PUSH
26232: LD_VAR 0 5
26236: DIFF
26237: PPUSH
26238: CALL_OW 1
26242: ST_TO_ADDR
// exit ;
26243: GO 26245
// end ; end ;
26245: LD_VAR 0 2
26249: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26250: LD_INT 0
26252: PPUSH
26253: PPUSH
26254: PPUSH
// if not mc_bases then
26255: LD_EXP 50
26259: NOT
26260: IFFALSE 26264
// exit ;
26262: GO 26406
// for i = 1 to mc_bases do
26264: LD_ADDR_VAR 0 2
26268: PUSH
26269: DOUBLE
26270: LD_INT 1
26272: DEC
26273: ST_TO_ADDR
26274: LD_EXP 50
26278: PUSH
26279: FOR_TO
26280: IFFALSE 26397
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26282: LD_ADDR_VAR 0 3
26286: PUSH
26287: LD_EXP 50
26291: PUSH
26292: LD_VAR 0 2
26296: ARRAY
26297: PPUSH
26298: LD_INT 21
26300: PUSH
26301: LD_INT 3
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PUSH
26308: LD_INT 3
26310: PUSH
26311: LD_INT 2
26313: PUSH
26314: LD_INT 30
26316: PUSH
26317: LD_INT 29
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: PUSH
26324: LD_INT 30
26326: PUSH
26327: LD_INT 30
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: LIST
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 3
26345: PUSH
26346: LD_INT 24
26348: PUSH
26349: LD_INT 1000
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: LIST
26364: PPUSH
26365: CALL_OW 72
26369: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26370: LD_ADDR_EXP 51
26374: PUSH
26375: LD_EXP 51
26379: PPUSH
26380: LD_VAR 0 2
26384: PPUSH
26385: LD_VAR 0 3
26389: PPUSH
26390: CALL_OW 1
26394: ST_TO_ADDR
// end ;
26395: GO 26279
26397: POP
26398: POP
// RaiseSailEvent ( 101 ) ;
26399: LD_INT 101
26401: PPUSH
26402: CALL_OW 427
// end ;
26406: LD_VAR 0 1
26410: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26411: LD_INT 0
26413: PPUSH
26414: PPUSH
26415: PPUSH
26416: PPUSH
26417: PPUSH
26418: PPUSH
26419: PPUSH
// if not mc_bases then
26420: LD_EXP 50
26424: NOT
26425: IFFALSE 26429
// exit ;
26427: GO 26991
// for i = 1 to mc_bases do
26429: LD_ADDR_VAR 0 2
26433: PUSH
26434: DOUBLE
26435: LD_INT 1
26437: DEC
26438: ST_TO_ADDR
26439: LD_EXP 50
26443: PUSH
26444: FOR_TO
26445: IFFALSE 26982
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26447: LD_ADDR_VAR 0 5
26451: PUSH
26452: LD_EXP 50
26456: PUSH
26457: LD_VAR 0 2
26461: ARRAY
26462: PUSH
26463: LD_EXP 79
26467: PUSH
26468: LD_VAR 0 2
26472: ARRAY
26473: UNION
26474: PPUSH
26475: LD_INT 21
26477: PUSH
26478: LD_INT 1
26480: PUSH
26481: EMPTY
26482: LIST
26483: LIST
26484: PUSH
26485: LD_INT 1
26487: PUSH
26488: LD_INT 3
26490: PUSH
26491: LD_INT 54
26493: PUSH
26494: EMPTY
26495: LIST
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PUSH
26501: LD_INT 3
26503: PUSH
26504: LD_INT 24
26506: PUSH
26507: LD_INT 1000
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: EMPTY
26515: LIST
26516: LIST
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: LIST
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 72
26531: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26532: LD_ADDR_VAR 0 6
26536: PUSH
26537: LD_EXP 50
26541: PUSH
26542: LD_VAR 0 2
26546: ARRAY
26547: PPUSH
26548: LD_INT 21
26550: PUSH
26551: LD_INT 1
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 1
26560: PUSH
26561: LD_INT 3
26563: PUSH
26564: LD_INT 54
26566: PUSH
26567: EMPTY
26568: LIST
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 3
26576: PUSH
26577: LD_INT 24
26579: PUSH
26580: LD_INT 250
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: LIST
26595: PUSH
26596: EMPTY
26597: LIST
26598: LIST
26599: PPUSH
26600: CALL_OW 72
26604: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26605: LD_ADDR_VAR 0 7
26609: PUSH
26610: LD_VAR 0 5
26614: PUSH
26615: LD_VAR 0 6
26619: DIFF
26620: ST_TO_ADDR
// if not need_heal_1 then
26621: LD_VAR 0 6
26625: NOT
26626: IFFALSE 26659
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26628: LD_ADDR_EXP 53
26632: PUSH
26633: LD_EXP 53
26637: PPUSH
26638: LD_VAR 0 2
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PPUSH
26650: EMPTY
26651: PPUSH
26652: CALL 53541 0 3
26656: ST_TO_ADDR
26657: GO 26729
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26659: LD_ADDR_EXP 53
26663: PUSH
26664: LD_EXP 53
26668: PPUSH
26669: LD_VAR 0 2
26673: PUSH
26674: LD_INT 1
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PPUSH
26681: LD_EXP 53
26685: PUSH
26686: LD_VAR 0 2
26690: ARRAY
26691: PUSH
26692: LD_INT 1
26694: ARRAY
26695: PPUSH
26696: LD_INT 3
26698: PUSH
26699: LD_INT 24
26701: PUSH
26702: LD_INT 1000
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PPUSH
26713: CALL_OW 72
26717: PUSH
26718: LD_VAR 0 6
26722: UNION
26723: PPUSH
26724: CALL 53541 0 3
26728: ST_TO_ADDR
// if not need_heal_2 then
26729: LD_VAR 0 7
26733: NOT
26734: IFFALSE 26767
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26736: LD_ADDR_EXP 53
26740: PUSH
26741: LD_EXP 53
26745: PPUSH
26746: LD_VAR 0 2
26750: PUSH
26751: LD_INT 2
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: PPUSH
26758: EMPTY
26759: PPUSH
26760: CALL 53541 0 3
26764: ST_TO_ADDR
26765: GO 26799
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26767: LD_ADDR_EXP 53
26771: PUSH
26772: LD_EXP 53
26776: PPUSH
26777: LD_VAR 0 2
26781: PUSH
26782: LD_INT 2
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PPUSH
26789: LD_VAR 0 7
26793: PPUSH
26794: CALL 53541 0 3
26798: ST_TO_ADDR
// if need_heal_2 then
26799: LD_VAR 0 7
26803: IFFALSE 26964
// for j in need_heal_2 do
26805: LD_ADDR_VAR 0 3
26809: PUSH
26810: LD_VAR 0 7
26814: PUSH
26815: FOR_IN
26816: IFFALSE 26962
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26818: LD_ADDR_VAR 0 5
26822: PUSH
26823: LD_EXP 50
26827: PUSH
26828: LD_VAR 0 2
26832: ARRAY
26833: PPUSH
26834: LD_INT 2
26836: PUSH
26837: LD_INT 30
26839: PUSH
26840: LD_INT 6
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 30
26849: PUSH
26850: LD_INT 7
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 30
26859: PUSH
26860: LD_INT 8
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 30
26869: PUSH
26870: LD_INT 0
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 30
26879: PUSH
26880: LD_INT 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: LIST
26891: LIST
26892: LIST
26893: LIST
26894: PPUSH
26895: CALL_OW 72
26899: ST_TO_ADDR
// if tmp then
26900: LD_VAR 0 5
26904: IFFALSE 26960
// begin k := NearestUnitToUnit ( tmp , j ) ;
26906: LD_ADDR_VAR 0 4
26910: PUSH
26911: LD_VAR 0 5
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: CALL_OW 74
26925: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26926: LD_VAR 0 3
26930: PPUSH
26931: LD_VAR 0 4
26935: PPUSH
26936: CALL_OW 296
26940: PUSH
26941: LD_INT 5
26943: GREATER
26944: IFFALSE 26960
// ComMoveToNearbyEntrance ( j , k ) ;
26946: LD_VAR 0 3
26950: PPUSH
26951: LD_VAR 0 4
26955: PPUSH
26956: CALL 86159 0 2
// end ; end ;
26960: GO 26815
26962: POP
26963: POP
// if not need_heal_1 and not need_heal_2 then
26964: LD_VAR 0 6
26968: NOT
26969: PUSH
26970: LD_VAR 0 7
26974: NOT
26975: AND
26976: IFFALSE 26980
// continue ;
26978: GO 26444
// end ;
26980: GO 26444
26982: POP
26983: POP
// RaiseSailEvent ( 102 ) ;
26984: LD_INT 102
26986: PPUSH
26987: CALL_OW 427
// end ;
26991: LD_VAR 0 1
26995: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26996: LD_INT 0
26998: PPUSH
26999: PPUSH
27000: PPUSH
27001: PPUSH
27002: PPUSH
27003: PPUSH
27004: PPUSH
27005: PPUSH
// if not mc_bases then
27006: LD_EXP 50
27010: NOT
27011: IFFALSE 27015
// exit ;
27013: GO 27898
// for i = 1 to mc_bases do
27015: LD_ADDR_VAR 0 2
27019: PUSH
27020: DOUBLE
27021: LD_INT 1
27023: DEC
27024: ST_TO_ADDR
27025: LD_EXP 50
27029: PUSH
27030: FOR_TO
27031: IFFALSE 27896
// begin if not mc_building_need_repair [ i ] then
27033: LD_EXP 51
27037: PUSH
27038: LD_VAR 0 2
27042: ARRAY
27043: NOT
27044: IFFALSE 27231
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27046: LD_ADDR_VAR 0 6
27050: PUSH
27051: LD_EXP 69
27055: PUSH
27056: LD_VAR 0 2
27060: ARRAY
27061: PPUSH
27062: LD_INT 3
27064: PUSH
27065: LD_INT 24
27067: PUSH
27068: LD_INT 1000
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: PUSH
27079: LD_INT 2
27081: PUSH
27082: LD_INT 34
27084: PUSH
27085: LD_INT 13
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: LD_INT 34
27094: PUSH
27095: LD_INT 52
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 34
27104: PUSH
27105: LD_EXP 100
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: LIST
27118: LIST
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PPUSH
27124: CALL_OW 72
27128: ST_TO_ADDR
// if cranes then
27129: LD_VAR 0 6
27133: IFFALSE 27195
// for j in cranes do
27135: LD_ADDR_VAR 0 3
27139: PUSH
27140: LD_VAR 0 6
27144: PUSH
27145: FOR_IN
27146: IFFALSE 27193
// if not IsInArea ( j , mc_parking [ i ] ) then
27148: LD_VAR 0 3
27152: PPUSH
27153: LD_EXP 74
27157: PUSH
27158: LD_VAR 0 2
27162: ARRAY
27163: PPUSH
27164: CALL_OW 308
27168: NOT
27169: IFFALSE 27191
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27171: LD_VAR 0 3
27175: PPUSH
27176: LD_EXP 74
27180: PUSH
27181: LD_VAR 0 2
27185: ARRAY
27186: PPUSH
27187: CALL_OW 113
27191: GO 27145
27193: POP
27194: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27195: LD_ADDR_EXP 52
27199: PUSH
27200: LD_EXP 52
27204: PPUSH
27205: LD_VAR 0 2
27209: PPUSH
27210: EMPTY
27211: PPUSH
27212: CALL_OW 1
27216: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27217: LD_VAR 0 2
27221: PPUSH
27222: LD_INT 101
27224: PPUSH
27225: CALL 22083 0 2
// continue ;
27229: GO 27030
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27231: LD_ADDR_EXP 56
27235: PUSH
27236: LD_EXP 56
27240: PPUSH
27241: LD_VAR 0 2
27245: PPUSH
27246: EMPTY
27247: PPUSH
27248: CALL_OW 1
27252: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27253: LD_VAR 0 2
27257: PPUSH
27258: LD_INT 103
27260: PPUSH
27261: CALL 22083 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27265: LD_ADDR_VAR 0 5
27269: PUSH
27270: LD_EXP 50
27274: PUSH
27275: LD_VAR 0 2
27279: ARRAY
27280: PUSH
27281: LD_EXP 79
27285: PUSH
27286: LD_VAR 0 2
27290: ARRAY
27291: UNION
27292: PPUSH
27293: LD_INT 2
27295: PUSH
27296: LD_INT 25
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 25
27308: PUSH
27309: LD_INT 16
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: LIST
27320: PUSH
27321: EMPTY
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: ST_TO_ADDR
// if mc_need_heal [ i ] then
27329: LD_EXP 53
27333: PUSH
27334: LD_VAR 0 2
27338: ARRAY
27339: IFFALSE 27383
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27341: LD_ADDR_VAR 0 5
27345: PUSH
27346: LD_VAR 0 5
27350: PUSH
27351: LD_EXP 53
27355: PUSH
27356: LD_VAR 0 2
27360: ARRAY
27361: PUSH
27362: LD_INT 1
27364: ARRAY
27365: PUSH
27366: LD_EXP 53
27370: PUSH
27371: LD_VAR 0 2
27375: ARRAY
27376: PUSH
27377: LD_INT 2
27379: ARRAY
27380: UNION
27381: DIFF
27382: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27383: LD_ADDR_VAR 0 6
27387: PUSH
27388: LD_EXP 69
27392: PUSH
27393: LD_VAR 0 2
27397: ARRAY
27398: PPUSH
27399: LD_INT 2
27401: PUSH
27402: LD_INT 34
27404: PUSH
27405: LD_INT 13
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: LD_INT 34
27414: PUSH
27415: LD_INT 52
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 34
27424: PUSH
27425: LD_EXP 100
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: PPUSH
27440: CALL_OW 72
27444: ST_TO_ADDR
// if cranes then
27445: LD_VAR 0 6
27449: IFFALSE 27585
// begin for j in cranes do
27451: LD_ADDR_VAR 0 3
27455: PUSH
27456: LD_VAR 0 6
27460: PUSH
27461: FOR_IN
27462: IFFALSE 27583
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27464: LD_VAR 0 3
27468: PPUSH
27469: CALL_OW 256
27473: PUSH
27474: LD_INT 1000
27476: EQUAL
27477: PUSH
27478: LD_VAR 0 3
27482: PPUSH
27483: CALL_OW 314
27487: NOT
27488: AND
27489: IFFALSE 27523
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27491: LD_VAR 0 3
27495: PPUSH
27496: LD_EXP 51
27500: PUSH
27501: LD_VAR 0 2
27505: ARRAY
27506: PPUSH
27507: LD_VAR 0 3
27511: PPUSH
27512: CALL_OW 74
27516: PPUSH
27517: CALL_OW 130
27521: GO 27581
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27523: LD_VAR 0 3
27527: PPUSH
27528: CALL_OW 256
27532: PUSH
27533: LD_INT 500
27535: LESS
27536: PUSH
27537: LD_VAR 0 3
27541: PPUSH
27542: LD_EXP 74
27546: PUSH
27547: LD_VAR 0 2
27551: ARRAY
27552: PPUSH
27553: CALL_OW 308
27557: NOT
27558: AND
27559: IFFALSE 27581
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27561: LD_VAR 0 3
27565: PPUSH
27566: LD_EXP 74
27570: PUSH
27571: LD_VAR 0 2
27575: ARRAY
27576: PPUSH
27577: CALL_OW 113
// end ;
27581: GO 27461
27583: POP
27584: POP
// end ; if tmp > 3 then
27585: LD_VAR 0 5
27589: PUSH
27590: LD_INT 3
27592: GREATER
27593: IFFALSE 27613
// tmp := ShrinkArray ( tmp , 4 ) ;
27595: LD_ADDR_VAR 0 5
27599: PUSH
27600: LD_VAR 0 5
27604: PPUSH
27605: LD_INT 4
27607: PPUSH
27608: CALL 85607 0 2
27612: ST_TO_ADDR
// if not tmp then
27613: LD_VAR 0 5
27617: NOT
27618: IFFALSE 27622
// continue ;
27620: GO 27030
// for j in tmp do
27622: LD_ADDR_VAR 0 3
27626: PUSH
27627: LD_VAR 0 5
27631: PUSH
27632: FOR_IN
27633: IFFALSE 27892
// begin if IsInUnit ( j ) then
27635: LD_VAR 0 3
27639: PPUSH
27640: CALL_OW 310
27644: IFFALSE 27655
// ComExitBuilding ( j ) ;
27646: LD_VAR 0 3
27650: PPUSH
27651: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27655: LD_VAR 0 3
27659: PUSH
27660: LD_EXP 52
27664: PUSH
27665: LD_VAR 0 2
27669: ARRAY
27670: IN
27671: NOT
27672: IFFALSE 27730
// begin SetTag ( j , 101 ) ;
27674: LD_VAR 0 3
27678: PPUSH
27679: LD_INT 101
27681: PPUSH
27682: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27686: LD_ADDR_EXP 52
27690: PUSH
27691: LD_EXP 52
27695: PPUSH
27696: LD_VAR 0 2
27700: PUSH
27701: LD_EXP 52
27705: PUSH
27706: LD_VAR 0 2
27710: ARRAY
27711: PUSH
27712: LD_INT 1
27714: PLUS
27715: PUSH
27716: EMPTY
27717: LIST
27718: LIST
27719: PPUSH
27720: LD_VAR 0 3
27724: PPUSH
27725: CALL 53541 0 3
27729: ST_TO_ADDR
// end ; wait ( 1 ) ;
27730: LD_INT 1
27732: PPUSH
27733: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27737: LD_ADDR_VAR 0 7
27741: PUSH
27742: LD_EXP 51
27746: PUSH
27747: LD_VAR 0 2
27751: ARRAY
27752: ST_TO_ADDR
// if mc_scan [ i ] then
27753: LD_EXP 73
27757: PUSH
27758: LD_VAR 0 2
27762: ARRAY
27763: IFFALSE 27825
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27765: LD_ADDR_VAR 0 7
27769: PUSH
27770: LD_EXP 51
27774: PUSH
27775: LD_VAR 0 2
27779: ARRAY
27780: PPUSH
27781: LD_INT 3
27783: PUSH
27784: LD_INT 30
27786: PUSH
27787: LD_INT 32
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 30
27796: PUSH
27797: LD_INT 33
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 30
27806: PUSH
27807: LD_INT 31
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: PPUSH
27820: CALL_OW 72
27824: ST_TO_ADDR
// if not to_repair_tmp then
27825: LD_VAR 0 7
27829: NOT
27830: IFFALSE 27834
// continue ;
27832: GO 27632
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27834: LD_ADDR_VAR 0 8
27838: PUSH
27839: LD_VAR 0 7
27843: PPUSH
27844: LD_VAR 0 3
27848: PPUSH
27849: CALL_OW 74
27853: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27854: LD_VAR 0 8
27858: PPUSH
27859: LD_INT 16
27861: PPUSH
27862: CALL 56140 0 2
27866: PUSH
27867: LD_INT 4
27869: ARRAY
27870: PUSH
27871: LD_INT 10
27873: LESS
27874: IFFALSE 27890
// ComRepairBuilding ( j , to_repair ) ;
27876: LD_VAR 0 3
27880: PPUSH
27881: LD_VAR 0 8
27885: PPUSH
27886: CALL_OW 130
// end ;
27890: GO 27632
27892: POP
27893: POP
// end ;
27894: GO 27030
27896: POP
27897: POP
// end ;
27898: LD_VAR 0 1
27902: RET
// export function MC_Heal ; var i , j , tmp ; begin
27903: LD_INT 0
27905: PPUSH
27906: PPUSH
27907: PPUSH
27908: PPUSH
// if not mc_bases then
27909: LD_EXP 50
27913: NOT
27914: IFFALSE 27918
// exit ;
27916: GO 28320
// for i = 1 to mc_bases do
27918: LD_ADDR_VAR 0 2
27922: PUSH
27923: DOUBLE
27924: LD_INT 1
27926: DEC
27927: ST_TO_ADDR
27928: LD_EXP 50
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28318
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27936: LD_EXP 53
27940: PUSH
27941: LD_VAR 0 2
27945: ARRAY
27946: PUSH
27947: LD_INT 1
27949: ARRAY
27950: NOT
27951: PUSH
27952: LD_EXP 53
27956: PUSH
27957: LD_VAR 0 2
27961: ARRAY
27962: PUSH
27963: LD_INT 2
27965: ARRAY
27966: NOT
27967: AND
27968: IFFALSE 28006
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27970: LD_ADDR_EXP 54
27974: PUSH
27975: LD_EXP 54
27979: PPUSH
27980: LD_VAR 0 2
27984: PPUSH
27985: EMPTY
27986: PPUSH
27987: CALL_OW 1
27991: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27992: LD_VAR 0 2
27996: PPUSH
27997: LD_INT 102
27999: PPUSH
28000: CALL 22083 0 2
// continue ;
28004: GO 27933
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28006: LD_ADDR_VAR 0 4
28010: PUSH
28011: LD_EXP 50
28015: PUSH
28016: LD_VAR 0 2
28020: ARRAY
28021: PPUSH
28022: LD_INT 25
28024: PUSH
28025: LD_INT 4
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PPUSH
28032: CALL_OW 72
28036: ST_TO_ADDR
// if not tmp then
28037: LD_VAR 0 4
28041: NOT
28042: IFFALSE 28046
// continue ;
28044: GO 27933
// if mc_taming [ i ] then
28046: LD_EXP 81
28050: PUSH
28051: LD_VAR 0 2
28055: ARRAY
28056: IFFALSE 28080
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28058: LD_ADDR_EXP 81
28062: PUSH
28063: LD_EXP 81
28067: PPUSH
28068: LD_VAR 0 2
28072: PPUSH
28073: EMPTY
28074: PPUSH
28075: CALL_OW 1
28079: ST_TO_ADDR
// for j in tmp do
28080: LD_ADDR_VAR 0 3
28084: PUSH
28085: LD_VAR 0 4
28089: PUSH
28090: FOR_IN
28091: IFFALSE 28314
// begin if IsInUnit ( j ) then
28093: LD_VAR 0 3
28097: PPUSH
28098: CALL_OW 310
28102: IFFALSE 28113
// ComExitBuilding ( j ) ;
28104: LD_VAR 0 3
28108: PPUSH
28109: CALL_OW 122
// if not j in mc_healers [ i ] then
28113: LD_VAR 0 3
28117: PUSH
28118: LD_EXP 54
28122: PUSH
28123: LD_VAR 0 2
28127: ARRAY
28128: IN
28129: NOT
28130: IFFALSE 28176
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28132: LD_ADDR_EXP 54
28136: PUSH
28137: LD_EXP 54
28141: PPUSH
28142: LD_VAR 0 2
28146: PUSH
28147: LD_EXP 54
28151: PUSH
28152: LD_VAR 0 2
28156: ARRAY
28157: PUSH
28158: LD_INT 1
28160: PLUS
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PPUSH
28166: LD_VAR 0 3
28170: PPUSH
28171: CALL 53541 0 3
28175: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28176: LD_VAR 0 3
28180: PPUSH
28181: CALL_OW 110
28185: PUSH
28186: LD_INT 102
28188: NONEQUAL
28189: IFFALSE 28203
// SetTag ( j , 102 ) ;
28191: LD_VAR 0 3
28195: PPUSH
28196: LD_INT 102
28198: PPUSH
28199: CALL_OW 109
// Wait ( 3 ) ;
28203: LD_INT 3
28205: PPUSH
28206: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28210: LD_EXP 53
28214: PUSH
28215: LD_VAR 0 2
28219: ARRAY
28220: PUSH
28221: LD_INT 1
28223: ARRAY
28224: IFFALSE 28256
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28226: LD_VAR 0 3
28230: PPUSH
28231: LD_EXP 53
28235: PUSH
28236: LD_VAR 0 2
28240: ARRAY
28241: PUSH
28242: LD_INT 1
28244: ARRAY
28245: PUSH
28246: LD_INT 1
28248: ARRAY
28249: PPUSH
28250: CALL_OW 128
28254: GO 28312
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28256: LD_VAR 0 3
28260: PPUSH
28261: CALL_OW 314
28265: NOT
28266: PUSH
28267: LD_EXP 53
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: PUSH
28278: LD_INT 2
28280: ARRAY
28281: AND
28282: IFFALSE 28312
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28284: LD_VAR 0 3
28288: PPUSH
28289: LD_EXP 53
28293: PUSH
28294: LD_VAR 0 2
28298: ARRAY
28299: PUSH
28300: LD_INT 2
28302: ARRAY
28303: PUSH
28304: LD_INT 1
28306: ARRAY
28307: PPUSH
28308: CALL_OW 128
// end ;
28312: GO 28090
28314: POP
28315: POP
// end ;
28316: GO 27933
28318: POP
28319: POP
// end ;
28320: LD_VAR 0 1
28324: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28325: LD_INT 0
28327: PPUSH
28328: PPUSH
28329: PPUSH
28330: PPUSH
28331: PPUSH
// if not mc_bases then
28332: LD_EXP 50
28336: NOT
28337: IFFALSE 28341
// exit ;
28339: GO 29512
// for i = 1 to mc_bases do
28341: LD_ADDR_VAR 0 2
28345: PUSH
28346: DOUBLE
28347: LD_INT 1
28349: DEC
28350: ST_TO_ADDR
28351: LD_EXP 50
28355: PUSH
28356: FOR_TO
28357: IFFALSE 29510
// begin if mc_scan [ i ] then
28359: LD_EXP 73
28363: PUSH
28364: LD_VAR 0 2
28368: ARRAY
28369: IFFALSE 28373
// continue ;
28371: GO 28356
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28373: LD_EXP 55
28377: PUSH
28378: LD_VAR 0 2
28382: ARRAY
28383: NOT
28384: PUSH
28385: LD_EXP 57
28389: PUSH
28390: LD_VAR 0 2
28394: ARRAY
28395: NOT
28396: AND
28397: PUSH
28398: LD_EXP 56
28402: PUSH
28403: LD_VAR 0 2
28407: ARRAY
28408: AND
28409: IFFALSE 28447
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28411: LD_ADDR_EXP 56
28415: PUSH
28416: LD_EXP 56
28420: PPUSH
28421: LD_VAR 0 2
28425: PPUSH
28426: EMPTY
28427: PPUSH
28428: CALL_OW 1
28432: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28433: LD_VAR 0 2
28437: PPUSH
28438: LD_INT 103
28440: PPUSH
28441: CALL 22083 0 2
// continue ;
28445: GO 28356
// end ; if mc_construct_list [ i ] then
28447: LD_EXP 57
28451: PUSH
28452: LD_VAR 0 2
28456: ARRAY
28457: IFFALSE 28677
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28459: LD_ADDR_VAR 0 4
28463: PUSH
28464: LD_EXP 50
28468: PUSH
28469: LD_VAR 0 2
28473: ARRAY
28474: PPUSH
28475: LD_INT 25
28477: PUSH
28478: LD_INT 2
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PPUSH
28485: CALL_OW 72
28489: PUSH
28490: LD_EXP 52
28494: PUSH
28495: LD_VAR 0 2
28499: ARRAY
28500: DIFF
28501: ST_TO_ADDR
// if not tmp then
28502: LD_VAR 0 4
28506: NOT
28507: IFFALSE 28511
// continue ;
28509: GO 28356
// for j in tmp do
28511: LD_ADDR_VAR 0 3
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: FOR_IN
28522: IFFALSE 28673
// begin if not mc_builders [ i ] then
28524: LD_EXP 56
28528: PUSH
28529: LD_VAR 0 2
28533: ARRAY
28534: NOT
28535: IFFALSE 28593
// begin SetTag ( j , 103 ) ;
28537: LD_VAR 0 3
28541: PPUSH
28542: LD_INT 103
28544: PPUSH
28545: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28549: LD_ADDR_EXP 56
28553: PUSH
28554: LD_EXP 56
28558: PPUSH
28559: LD_VAR 0 2
28563: PUSH
28564: LD_EXP 56
28568: PUSH
28569: LD_VAR 0 2
28573: ARRAY
28574: PUSH
28575: LD_INT 1
28577: PLUS
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PPUSH
28583: LD_VAR 0 3
28587: PPUSH
28588: CALL 53541 0 3
28592: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28593: LD_VAR 0 3
28597: PPUSH
28598: CALL_OW 310
28602: IFFALSE 28613
// ComExitBuilding ( j ) ;
28604: LD_VAR 0 3
28608: PPUSH
28609: CALL_OW 122
// wait ( 3 ) ;
28613: LD_INT 3
28615: PPUSH
28616: CALL_OW 67
// if not mc_construct_list [ i ] then
28620: LD_EXP 57
28624: PUSH
28625: LD_VAR 0 2
28629: ARRAY
28630: NOT
28631: IFFALSE 28635
// break ;
28633: GO 28673
// if not HasTask ( j ) then
28635: LD_VAR 0 3
28639: PPUSH
28640: CALL_OW 314
28644: NOT
28645: IFFALSE 28671
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28647: LD_VAR 0 3
28651: PPUSH
28652: LD_EXP 57
28656: PUSH
28657: LD_VAR 0 2
28661: ARRAY
28662: PUSH
28663: LD_INT 1
28665: ARRAY
28666: PPUSH
28667: CALL 56404 0 2
// end ;
28671: GO 28521
28673: POP
28674: POP
// end else
28675: GO 29508
// if mc_build_list [ i ] then
28677: LD_EXP 55
28681: PUSH
28682: LD_VAR 0 2
28686: ARRAY
28687: IFFALSE 29508
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28689: LD_ADDR_VAR 0 5
28693: PUSH
28694: LD_EXP 50
28698: PUSH
28699: LD_VAR 0 2
28703: ARRAY
28704: PPUSH
28705: LD_INT 2
28707: PUSH
28708: LD_INT 30
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 30
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: LIST
28732: PPUSH
28733: CALL_OW 72
28737: ST_TO_ADDR
// if depot then
28738: LD_VAR 0 5
28742: IFFALSE 28760
// depot := depot [ 1 ] else
28744: LD_ADDR_VAR 0 5
28748: PUSH
28749: LD_VAR 0 5
28753: PUSH
28754: LD_INT 1
28756: ARRAY
28757: ST_TO_ADDR
28758: GO 28768
// depot := 0 ;
28760: LD_ADDR_VAR 0 5
28764: PUSH
28765: LD_INT 0
28767: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28768: LD_EXP 55
28772: PUSH
28773: LD_VAR 0 2
28777: ARRAY
28778: PUSH
28779: LD_INT 1
28781: ARRAY
28782: PUSH
28783: LD_INT 1
28785: ARRAY
28786: PPUSH
28787: CALL 56228 0 1
28791: PUSH
28792: LD_EXP 50
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PPUSH
28803: LD_INT 2
28805: PUSH
28806: LD_INT 30
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 30
28818: PUSH
28819: LD_INT 3
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: LIST
28830: PPUSH
28831: CALL_OW 72
28835: NOT
28836: AND
28837: IFFALSE 28942
// begin for j = 1 to mc_build_list [ i ] do
28839: LD_ADDR_VAR 0 3
28843: PUSH
28844: DOUBLE
28845: LD_INT 1
28847: DEC
28848: ST_TO_ADDR
28849: LD_EXP 55
28853: PUSH
28854: LD_VAR 0 2
28858: ARRAY
28859: PUSH
28860: FOR_TO
28861: IFFALSE 28940
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28863: LD_EXP 55
28867: PUSH
28868: LD_VAR 0 2
28872: ARRAY
28873: PUSH
28874: LD_VAR 0 3
28878: ARRAY
28879: PUSH
28880: LD_INT 1
28882: ARRAY
28883: PUSH
28884: LD_INT 2
28886: EQUAL
28887: IFFALSE 28938
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28889: LD_ADDR_EXP 55
28893: PUSH
28894: LD_EXP 55
28898: PPUSH
28899: LD_VAR 0 2
28903: PPUSH
28904: LD_EXP 55
28908: PUSH
28909: LD_VAR 0 2
28913: ARRAY
28914: PPUSH
28915: LD_VAR 0 3
28919: PPUSH
28920: LD_INT 1
28922: PPUSH
28923: LD_INT 0
28925: PPUSH
28926: CALL 52959 0 4
28930: PPUSH
28931: CALL_OW 1
28935: ST_TO_ADDR
// break ;
28936: GO 28940
// end ;
28938: GO 28860
28940: POP
28941: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28942: LD_EXP 55
28946: PUSH
28947: LD_VAR 0 2
28951: ARRAY
28952: PUSH
28953: LD_INT 1
28955: ARRAY
28956: PUSH
28957: LD_INT 1
28959: ARRAY
28960: PUSH
28961: LD_INT 0
28963: EQUAL
28964: PUSH
28965: LD_VAR 0 5
28969: PUSH
28970: LD_VAR 0 5
28974: PPUSH
28975: LD_EXP 55
28979: PUSH
28980: LD_VAR 0 2
28984: ARRAY
28985: PUSH
28986: LD_INT 1
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: PPUSH
28994: LD_EXP 55
28998: PUSH
28999: LD_VAR 0 2
29003: ARRAY
29004: PUSH
29005: LD_INT 1
29007: ARRAY
29008: PUSH
29009: LD_INT 2
29011: ARRAY
29012: PPUSH
29013: LD_EXP 55
29017: PUSH
29018: LD_VAR 0 2
29022: ARRAY
29023: PUSH
29024: LD_INT 1
29026: ARRAY
29027: PUSH
29028: LD_INT 3
29030: ARRAY
29031: PPUSH
29032: LD_EXP 55
29036: PUSH
29037: LD_VAR 0 2
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: PUSH
29047: LD_INT 4
29049: ARRAY
29050: PPUSH
29051: CALL 61644 0 5
29055: AND
29056: OR
29057: IFFALSE 29338
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29059: LD_ADDR_VAR 0 4
29063: PUSH
29064: LD_EXP 50
29068: PUSH
29069: LD_VAR 0 2
29073: ARRAY
29074: PPUSH
29075: LD_INT 25
29077: PUSH
29078: LD_INT 2
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PPUSH
29085: CALL_OW 72
29089: PUSH
29090: LD_EXP 52
29094: PUSH
29095: LD_VAR 0 2
29099: ARRAY
29100: DIFF
29101: ST_TO_ADDR
// if not tmp then
29102: LD_VAR 0 4
29106: NOT
29107: IFFALSE 29111
// continue ;
29109: GO 28356
// for j in tmp do
29111: LD_ADDR_VAR 0 3
29115: PUSH
29116: LD_VAR 0 4
29120: PUSH
29121: FOR_IN
29122: IFFALSE 29334
// begin if not mc_builders [ i ] then
29124: LD_EXP 56
29128: PUSH
29129: LD_VAR 0 2
29133: ARRAY
29134: NOT
29135: IFFALSE 29193
// begin SetTag ( j , 103 ) ;
29137: LD_VAR 0 3
29141: PPUSH
29142: LD_INT 103
29144: PPUSH
29145: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29149: LD_ADDR_EXP 56
29153: PUSH
29154: LD_EXP 56
29158: PPUSH
29159: LD_VAR 0 2
29163: PUSH
29164: LD_EXP 56
29168: PUSH
29169: LD_VAR 0 2
29173: ARRAY
29174: PUSH
29175: LD_INT 1
29177: PLUS
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PPUSH
29183: LD_VAR 0 3
29187: PPUSH
29188: CALL 53541 0 3
29192: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29193: LD_VAR 0 3
29197: PPUSH
29198: CALL_OW 310
29202: IFFALSE 29213
// ComExitBuilding ( j ) ;
29204: LD_VAR 0 3
29208: PPUSH
29209: CALL_OW 122
// wait ( 3 ) ;
29213: LD_INT 3
29215: PPUSH
29216: CALL_OW 67
// if not mc_build_list [ i ] then
29220: LD_EXP 55
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: NOT
29231: IFFALSE 29235
// break ;
29233: GO 29334
// if not HasTask ( j ) then
29235: LD_VAR 0 3
29239: PPUSH
29240: CALL_OW 314
29244: NOT
29245: IFFALSE 29332
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29247: LD_VAR 0 3
29251: PPUSH
29252: LD_EXP 55
29256: PUSH
29257: LD_VAR 0 2
29261: ARRAY
29262: PUSH
29263: LD_INT 1
29265: ARRAY
29266: PUSH
29267: LD_INT 1
29269: ARRAY
29270: PPUSH
29271: LD_EXP 55
29275: PUSH
29276: LD_VAR 0 2
29280: ARRAY
29281: PUSH
29282: LD_INT 1
29284: ARRAY
29285: PUSH
29286: LD_INT 2
29288: ARRAY
29289: PPUSH
29290: LD_EXP 55
29294: PUSH
29295: LD_VAR 0 2
29299: ARRAY
29300: PUSH
29301: LD_INT 1
29303: ARRAY
29304: PUSH
29305: LD_INT 3
29307: ARRAY
29308: PPUSH
29309: LD_EXP 55
29313: PUSH
29314: LD_VAR 0 2
29318: ARRAY
29319: PUSH
29320: LD_INT 1
29322: ARRAY
29323: PUSH
29324: LD_INT 4
29326: ARRAY
29327: PPUSH
29328: CALL_OW 145
// end ;
29332: GO 29121
29334: POP
29335: POP
// end else
29336: GO 29508
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29338: LD_EXP 50
29342: PUSH
29343: LD_VAR 0 2
29347: ARRAY
29348: PPUSH
29349: LD_EXP 55
29353: PUSH
29354: LD_VAR 0 2
29358: ARRAY
29359: PUSH
29360: LD_INT 1
29362: ARRAY
29363: PUSH
29364: LD_INT 1
29366: ARRAY
29367: PPUSH
29368: LD_EXP 55
29372: PUSH
29373: LD_VAR 0 2
29377: ARRAY
29378: PUSH
29379: LD_INT 1
29381: ARRAY
29382: PUSH
29383: LD_INT 2
29385: ARRAY
29386: PPUSH
29387: LD_EXP 55
29391: PUSH
29392: LD_VAR 0 2
29396: ARRAY
29397: PUSH
29398: LD_INT 1
29400: ARRAY
29401: PUSH
29402: LD_INT 3
29404: ARRAY
29405: PPUSH
29406: LD_EXP 55
29410: PUSH
29411: LD_VAR 0 2
29415: ARRAY
29416: PUSH
29417: LD_INT 1
29419: ARRAY
29420: PUSH
29421: LD_INT 4
29423: ARRAY
29424: PPUSH
29425: LD_EXP 50
29429: PUSH
29430: LD_VAR 0 2
29434: ARRAY
29435: PPUSH
29436: LD_INT 21
29438: PUSH
29439: LD_INT 3
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PPUSH
29446: CALL_OW 72
29450: PPUSH
29451: EMPTY
29452: PPUSH
29453: CALL 60394 0 7
29457: NOT
29458: IFFALSE 29508
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29460: LD_ADDR_EXP 55
29464: PUSH
29465: LD_EXP 55
29469: PPUSH
29470: LD_VAR 0 2
29474: PPUSH
29475: LD_EXP 55
29479: PUSH
29480: LD_VAR 0 2
29484: ARRAY
29485: PPUSH
29486: LD_INT 1
29488: PPUSH
29489: LD_INT 1
29491: NEG
29492: PPUSH
29493: LD_INT 0
29495: PPUSH
29496: CALL 52959 0 4
29500: PPUSH
29501: CALL_OW 1
29505: ST_TO_ADDR
// continue ;
29506: GO 28356
// end ; end ; end ;
29508: GO 28356
29510: POP
29511: POP
// end ;
29512: LD_VAR 0 1
29516: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29517: LD_INT 0
29519: PPUSH
29520: PPUSH
29521: PPUSH
29522: PPUSH
29523: PPUSH
29524: PPUSH
// if not mc_bases then
29525: LD_EXP 50
29529: NOT
29530: IFFALSE 29534
// exit ;
29532: GO 29961
// for i = 1 to mc_bases do
29534: LD_ADDR_VAR 0 2
29538: PUSH
29539: DOUBLE
29540: LD_INT 1
29542: DEC
29543: ST_TO_ADDR
29544: LD_EXP 50
29548: PUSH
29549: FOR_TO
29550: IFFALSE 29959
// begin tmp := mc_build_upgrade [ i ] ;
29552: LD_ADDR_VAR 0 4
29556: PUSH
29557: LD_EXP 82
29561: PUSH
29562: LD_VAR 0 2
29566: ARRAY
29567: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29568: LD_ADDR_VAR 0 6
29572: PUSH
29573: LD_EXP 83
29577: PUSH
29578: LD_VAR 0 2
29582: ARRAY
29583: PPUSH
29584: LD_INT 2
29586: PUSH
29587: LD_INT 30
29589: PUSH
29590: LD_INT 6
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 30
29599: PUSH
29600: LD_INT 7
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL_OW 72
29616: ST_TO_ADDR
// if not tmp and not lab then
29617: LD_VAR 0 4
29621: NOT
29622: PUSH
29623: LD_VAR 0 6
29627: NOT
29628: AND
29629: IFFALSE 29633
// continue ;
29631: GO 29549
// if tmp then
29633: LD_VAR 0 4
29637: IFFALSE 29757
// for j in tmp do
29639: LD_ADDR_VAR 0 3
29643: PUSH
29644: LD_VAR 0 4
29648: PUSH
29649: FOR_IN
29650: IFFALSE 29755
// begin if UpgradeCost ( j ) then
29652: LD_VAR 0 3
29656: PPUSH
29657: CALL 60054 0 1
29661: IFFALSE 29753
// begin ComUpgrade ( j ) ;
29663: LD_VAR 0 3
29667: PPUSH
29668: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29672: LD_ADDR_EXP 82
29676: PUSH
29677: LD_EXP 82
29681: PPUSH
29682: LD_VAR 0 2
29686: PPUSH
29687: LD_EXP 82
29691: PUSH
29692: LD_VAR 0 2
29696: ARRAY
29697: PUSH
29698: LD_VAR 0 3
29702: DIFF
29703: PPUSH
29704: CALL_OW 1
29708: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29709: LD_ADDR_EXP 57
29713: PUSH
29714: LD_EXP 57
29718: PPUSH
29719: LD_VAR 0 2
29723: PUSH
29724: LD_EXP 57
29728: PUSH
29729: LD_VAR 0 2
29733: ARRAY
29734: PUSH
29735: LD_INT 1
29737: PLUS
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PPUSH
29743: LD_VAR 0 3
29747: PPUSH
29748: CALL 53541 0 3
29752: ST_TO_ADDR
// end ; end ;
29753: GO 29649
29755: POP
29756: POP
// if not lab or not mc_lab_upgrade [ i ] then
29757: LD_VAR 0 6
29761: NOT
29762: PUSH
29763: LD_EXP 84
29767: PUSH
29768: LD_VAR 0 2
29772: ARRAY
29773: NOT
29774: OR
29775: IFFALSE 29779
// continue ;
29777: GO 29549
// for j in lab do
29779: LD_ADDR_VAR 0 3
29783: PUSH
29784: LD_VAR 0 6
29788: PUSH
29789: FOR_IN
29790: IFFALSE 29955
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29792: LD_VAR 0 3
29796: PPUSH
29797: CALL_OW 266
29801: PUSH
29802: LD_INT 6
29804: PUSH
29805: LD_INT 7
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: IN
29812: PUSH
29813: LD_VAR 0 3
29817: PPUSH
29818: CALL_OW 461
29822: PUSH
29823: LD_INT 1
29825: NONEQUAL
29826: AND
29827: IFFALSE 29953
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29829: LD_VAR 0 3
29833: PPUSH
29834: LD_EXP 84
29838: PUSH
29839: LD_VAR 0 2
29843: ARRAY
29844: PUSH
29845: LD_INT 1
29847: ARRAY
29848: PPUSH
29849: CALL 60259 0 2
29853: IFFALSE 29953
// begin ComCancel ( j ) ;
29855: LD_VAR 0 3
29859: PPUSH
29860: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29864: LD_VAR 0 3
29868: PPUSH
29869: LD_EXP 84
29873: PUSH
29874: LD_VAR 0 2
29878: ARRAY
29879: PUSH
29880: LD_INT 1
29882: ARRAY
29883: PPUSH
29884: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29888: LD_VAR 0 3
29892: PUSH
29893: LD_EXP 57
29897: PUSH
29898: LD_VAR 0 2
29902: ARRAY
29903: IN
29904: NOT
29905: IFFALSE 29951
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29907: LD_ADDR_EXP 57
29911: PUSH
29912: LD_EXP 57
29916: PPUSH
29917: LD_VAR 0 2
29921: PUSH
29922: LD_EXP 57
29926: PUSH
29927: LD_VAR 0 2
29931: ARRAY
29932: PUSH
29933: LD_INT 1
29935: PLUS
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PPUSH
29941: LD_VAR 0 3
29945: PPUSH
29946: CALL 53541 0 3
29950: ST_TO_ADDR
// break ;
29951: GO 29955
// end ; end ; end ;
29953: GO 29789
29955: POP
29956: POP
// end ;
29957: GO 29549
29959: POP
29960: POP
// end ;
29961: LD_VAR 0 1
29965: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29966: LD_INT 0
29968: PPUSH
29969: PPUSH
29970: PPUSH
29971: PPUSH
29972: PPUSH
29973: PPUSH
29974: PPUSH
29975: PPUSH
29976: PPUSH
// if not mc_bases then
29977: LD_EXP 50
29981: NOT
29982: IFFALSE 29986
// exit ;
29984: GO 30391
// for i = 1 to mc_bases do
29986: LD_ADDR_VAR 0 2
29990: PUSH
29991: DOUBLE
29992: LD_INT 1
29994: DEC
29995: ST_TO_ADDR
29996: LD_EXP 50
30000: PUSH
30001: FOR_TO
30002: IFFALSE 30389
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30004: LD_EXP 58
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: NOT
30015: PUSH
30016: LD_EXP 50
30020: PUSH
30021: LD_VAR 0 2
30025: ARRAY
30026: PPUSH
30027: LD_INT 30
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PPUSH
30037: CALL_OW 72
30041: NOT
30042: OR
30043: IFFALSE 30047
// continue ;
30045: GO 30001
// busy := false ;
30047: LD_ADDR_VAR 0 8
30051: PUSH
30052: LD_INT 0
30054: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30055: LD_ADDR_VAR 0 4
30059: PUSH
30060: LD_EXP 50
30064: PUSH
30065: LD_VAR 0 2
30069: ARRAY
30070: PPUSH
30071: LD_INT 30
30073: PUSH
30074: LD_INT 3
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PPUSH
30081: CALL_OW 72
30085: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30086: LD_ADDR_VAR 0 6
30090: PUSH
30091: LD_EXP 58
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PPUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 30
30107: PUSH
30108: LD_INT 32
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 30
30117: PUSH
30118: LD_INT 33
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ST_TO_ADDR
// if not t then
30135: LD_VAR 0 6
30139: NOT
30140: IFFALSE 30144
// continue ;
30142: GO 30001
// for j in tmp do
30144: LD_ADDR_VAR 0 3
30148: PUSH
30149: LD_VAR 0 4
30153: PUSH
30154: FOR_IN
30155: IFFALSE 30185
// if not BuildingStatus ( j ) = bs_idle then
30157: LD_VAR 0 3
30161: PPUSH
30162: CALL_OW 461
30166: PUSH
30167: LD_INT 2
30169: EQUAL
30170: NOT
30171: IFFALSE 30183
// begin busy := true ;
30173: LD_ADDR_VAR 0 8
30177: PUSH
30178: LD_INT 1
30180: ST_TO_ADDR
// break ;
30181: GO 30185
// end ;
30183: GO 30154
30185: POP
30186: POP
// if busy then
30187: LD_VAR 0 8
30191: IFFALSE 30195
// continue ;
30193: GO 30001
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30195: LD_ADDR_VAR 0 7
30199: PUSH
30200: LD_VAR 0 6
30204: PPUSH
30205: LD_INT 35
30207: PUSH
30208: LD_INT 0
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PPUSH
30215: CALL_OW 72
30219: ST_TO_ADDR
// if tw then
30220: LD_VAR 0 7
30224: IFFALSE 30301
// begin tw := tw [ 1 ] ;
30226: LD_ADDR_VAR 0 7
30230: PUSH
30231: LD_VAR 0 7
30235: PUSH
30236: LD_INT 1
30238: ARRAY
30239: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30240: LD_ADDR_VAR 0 9
30244: PUSH
30245: LD_VAR 0 7
30249: PPUSH
30250: LD_EXP 75
30254: PUSH
30255: LD_VAR 0 2
30259: ARRAY
30260: PPUSH
30261: CALL 58551 0 2
30265: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30266: LD_EXP 89
30270: PUSH
30271: LD_VAR 0 2
30275: ARRAY
30276: IFFALSE 30299
// if not weapon in mc_allowed_tower_weapons [ i ] then
30278: LD_VAR 0 9
30282: PUSH
30283: LD_EXP 89
30287: PUSH
30288: LD_VAR 0 2
30292: ARRAY
30293: IN
30294: NOT
30295: IFFALSE 30299
// continue ;
30297: GO 30001
// end else
30299: GO 30364
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30301: LD_ADDR_VAR 0 5
30305: PUSH
30306: LD_EXP 58
30310: PUSH
30311: LD_VAR 0 2
30315: ARRAY
30316: PPUSH
30317: LD_VAR 0 4
30321: PPUSH
30322: CALL 84840 0 2
30326: ST_TO_ADDR
// if not tmp2 then
30327: LD_VAR 0 5
30331: NOT
30332: IFFALSE 30336
// continue ;
30334: GO 30001
// tw := tmp2 [ 1 ] ;
30336: LD_ADDR_VAR 0 7
30340: PUSH
30341: LD_VAR 0 5
30345: PUSH
30346: LD_INT 1
30348: ARRAY
30349: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30350: LD_ADDR_VAR 0 9
30354: PUSH
30355: LD_VAR 0 5
30359: PUSH
30360: LD_INT 2
30362: ARRAY
30363: ST_TO_ADDR
// end ; if not weapon then
30364: LD_VAR 0 9
30368: NOT
30369: IFFALSE 30373
// continue ;
30371: GO 30001
// ComPlaceWeapon ( tw , weapon ) ;
30373: LD_VAR 0 7
30377: PPUSH
30378: LD_VAR 0 9
30382: PPUSH
30383: CALL_OW 148
// end ;
30387: GO 30001
30389: POP
30390: POP
// end ;
30391: LD_VAR 0 1
30395: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30396: LD_INT 0
30398: PPUSH
30399: PPUSH
30400: PPUSH
30401: PPUSH
30402: PPUSH
30403: PPUSH
30404: PPUSH
// if not mc_bases then
30405: LD_EXP 50
30409: NOT
30410: IFFALSE 30414
// exit ;
30412: GO 31182
// for i = 1 to mc_bases do
30414: LD_ADDR_VAR 0 2
30418: PUSH
30419: DOUBLE
30420: LD_INT 1
30422: DEC
30423: ST_TO_ADDR
30424: LD_EXP 50
30428: PUSH
30429: FOR_TO
30430: IFFALSE 31180
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30432: LD_EXP 63
30436: PUSH
30437: LD_VAR 0 2
30441: ARRAY
30442: NOT
30443: PUSH
30444: LD_EXP 63
30448: PUSH
30449: LD_VAR 0 2
30453: ARRAY
30454: PUSH
30455: LD_EXP 64
30459: PUSH
30460: LD_VAR 0 2
30464: ARRAY
30465: EQUAL
30466: OR
30467: PUSH
30468: LD_EXP 73
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: OR
30479: IFFALSE 30483
// continue ;
30481: GO 30429
// if mc_miners [ i ] then
30483: LD_EXP 64
30487: PUSH
30488: LD_VAR 0 2
30492: ARRAY
30493: IFFALSE 30867
// begin for j = mc_miners [ i ] downto 1 do
30495: LD_ADDR_VAR 0 3
30499: PUSH
30500: DOUBLE
30501: LD_EXP 64
30505: PUSH
30506: LD_VAR 0 2
30510: ARRAY
30511: INC
30512: ST_TO_ADDR
30513: LD_INT 1
30515: PUSH
30516: FOR_DOWNTO
30517: IFFALSE 30865
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30519: LD_EXP 64
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: PUSH
30530: LD_VAR 0 3
30534: ARRAY
30535: PPUSH
30536: CALL_OW 301
30540: PUSH
30541: LD_EXP 64
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: PUSH
30552: LD_VAR 0 3
30556: ARRAY
30557: PPUSH
30558: CALL_OW 257
30562: PUSH
30563: LD_INT 1
30565: NONEQUAL
30566: OR
30567: IFFALSE 30630
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30569: LD_ADDR_VAR 0 5
30573: PUSH
30574: LD_EXP 64
30578: PUSH
30579: LD_VAR 0 2
30583: ARRAY
30584: PUSH
30585: LD_EXP 64
30589: PUSH
30590: LD_VAR 0 2
30594: ARRAY
30595: PUSH
30596: LD_VAR 0 3
30600: ARRAY
30601: DIFF
30602: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30603: LD_ADDR_EXP 64
30607: PUSH
30608: LD_EXP 64
30612: PPUSH
30613: LD_VAR 0 2
30617: PPUSH
30618: LD_VAR 0 5
30622: PPUSH
30623: CALL_OW 1
30627: ST_TO_ADDR
// continue ;
30628: GO 30516
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30630: LD_EXP 64
30634: PUSH
30635: LD_VAR 0 2
30639: ARRAY
30640: PUSH
30641: LD_VAR 0 3
30645: ARRAY
30646: PPUSH
30647: CALL_OW 257
30651: PUSH
30652: LD_INT 1
30654: EQUAL
30655: PUSH
30656: LD_EXP 64
30660: PUSH
30661: LD_VAR 0 2
30665: ARRAY
30666: PUSH
30667: LD_VAR 0 3
30671: ARRAY
30672: PPUSH
30673: CALL_OW 459
30677: NOT
30678: AND
30679: PUSH
30680: LD_EXP 64
30684: PUSH
30685: LD_VAR 0 2
30689: ARRAY
30690: PUSH
30691: LD_VAR 0 3
30695: ARRAY
30696: PPUSH
30697: CALL_OW 314
30701: NOT
30702: AND
30703: IFFALSE 30863
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30705: LD_EXP 64
30709: PUSH
30710: LD_VAR 0 2
30714: ARRAY
30715: PUSH
30716: LD_VAR 0 3
30720: ARRAY
30721: PPUSH
30722: CALL_OW 310
30726: IFFALSE 30749
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30728: LD_EXP 64
30732: PUSH
30733: LD_VAR 0 2
30737: ARRAY
30738: PUSH
30739: LD_VAR 0 3
30743: ARRAY
30744: PPUSH
30745: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30749: LD_EXP 64
30753: PUSH
30754: LD_VAR 0 2
30758: ARRAY
30759: PUSH
30760: LD_VAR 0 3
30764: ARRAY
30765: PPUSH
30766: CALL_OW 314
30770: NOT
30771: IFFALSE 30863
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30773: LD_ADDR_VAR 0 7
30777: PUSH
30778: LD_INT 1
30780: PPUSH
30781: LD_EXP 63
30785: PUSH
30786: LD_VAR 0 2
30790: ARRAY
30791: PPUSH
30792: CALL_OW 12
30796: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30797: LD_EXP 64
30801: PUSH
30802: LD_VAR 0 2
30806: ARRAY
30807: PUSH
30808: LD_VAR 0 3
30812: ARRAY
30813: PPUSH
30814: LD_EXP 63
30818: PUSH
30819: LD_VAR 0 2
30823: ARRAY
30824: PUSH
30825: LD_VAR 0 7
30829: ARRAY
30830: PUSH
30831: LD_INT 1
30833: ARRAY
30834: PPUSH
30835: LD_EXP 63
30839: PUSH
30840: LD_VAR 0 2
30844: ARRAY
30845: PUSH
30846: LD_VAR 0 7
30850: ARRAY
30851: PUSH
30852: LD_INT 2
30854: ARRAY
30855: PPUSH
30856: LD_INT 0
30858: PPUSH
30859: CALL_OW 193
// end ; end ; end ;
30863: GO 30516
30865: POP
30866: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30867: LD_ADDR_VAR 0 5
30871: PUSH
30872: LD_EXP 50
30876: PUSH
30877: LD_VAR 0 2
30881: ARRAY
30882: PPUSH
30883: LD_INT 2
30885: PUSH
30886: LD_INT 30
30888: PUSH
30889: LD_INT 4
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 30
30898: PUSH
30899: LD_INT 5
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 30
30908: PUSH
30909: LD_INT 32
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: PPUSH
30922: CALL_OW 72
30926: ST_TO_ADDR
// if not tmp then
30927: LD_VAR 0 5
30931: NOT
30932: IFFALSE 30936
// continue ;
30934: GO 30429
// list := [ ] ;
30936: LD_ADDR_VAR 0 6
30940: PUSH
30941: EMPTY
30942: ST_TO_ADDR
// for j in tmp do
30943: LD_ADDR_VAR 0 3
30947: PUSH
30948: LD_VAR 0 5
30952: PUSH
30953: FOR_IN
30954: IFFALSE 31023
// begin for k in UnitsInside ( j ) do
30956: LD_ADDR_VAR 0 4
30960: PUSH
30961: LD_VAR 0 3
30965: PPUSH
30966: CALL_OW 313
30970: PUSH
30971: FOR_IN
30972: IFFALSE 31019
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30974: LD_VAR 0 4
30978: PPUSH
30979: CALL_OW 257
30983: PUSH
30984: LD_INT 1
30986: EQUAL
30987: PUSH
30988: LD_VAR 0 4
30992: PPUSH
30993: CALL_OW 459
30997: NOT
30998: AND
30999: IFFALSE 31017
// list := list ^ k ;
31001: LD_ADDR_VAR 0 6
31005: PUSH
31006: LD_VAR 0 6
31010: PUSH
31011: LD_VAR 0 4
31015: ADD
31016: ST_TO_ADDR
31017: GO 30971
31019: POP
31020: POP
// end ;
31021: GO 30953
31023: POP
31024: POP
// list := list diff mc_miners [ i ] ;
31025: LD_ADDR_VAR 0 6
31029: PUSH
31030: LD_VAR 0 6
31034: PUSH
31035: LD_EXP 64
31039: PUSH
31040: LD_VAR 0 2
31044: ARRAY
31045: DIFF
31046: ST_TO_ADDR
// if not list then
31047: LD_VAR 0 6
31051: NOT
31052: IFFALSE 31056
// continue ;
31054: GO 30429
// k := mc_mines [ i ] - mc_miners [ i ] ;
31056: LD_ADDR_VAR 0 4
31060: PUSH
31061: LD_EXP 63
31065: PUSH
31066: LD_VAR 0 2
31070: ARRAY
31071: PUSH
31072: LD_EXP 64
31076: PUSH
31077: LD_VAR 0 2
31081: ARRAY
31082: MINUS
31083: ST_TO_ADDR
// if k > list then
31084: LD_VAR 0 4
31088: PUSH
31089: LD_VAR 0 6
31093: GREATER
31094: IFFALSE 31106
// k := list ;
31096: LD_ADDR_VAR 0 4
31100: PUSH
31101: LD_VAR 0 6
31105: ST_TO_ADDR
// for j = 1 to k do
31106: LD_ADDR_VAR 0 3
31110: PUSH
31111: DOUBLE
31112: LD_INT 1
31114: DEC
31115: ST_TO_ADDR
31116: LD_VAR 0 4
31120: PUSH
31121: FOR_TO
31122: IFFALSE 31176
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31124: LD_ADDR_EXP 64
31128: PUSH
31129: LD_EXP 64
31133: PPUSH
31134: LD_VAR 0 2
31138: PUSH
31139: LD_EXP 64
31143: PUSH
31144: LD_VAR 0 2
31148: ARRAY
31149: PUSH
31150: LD_INT 1
31152: PLUS
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PPUSH
31158: LD_VAR 0 6
31162: PUSH
31163: LD_VAR 0 3
31167: ARRAY
31168: PPUSH
31169: CALL 53541 0 3
31173: ST_TO_ADDR
31174: GO 31121
31176: POP
31177: POP
// end ;
31178: GO 30429
31180: POP
31181: POP
// end ;
31182: LD_VAR 0 1
31186: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31187: LD_INT 0
31189: PPUSH
31190: PPUSH
31191: PPUSH
31192: PPUSH
31193: PPUSH
31194: PPUSH
31195: PPUSH
31196: PPUSH
31197: PPUSH
31198: PPUSH
31199: PPUSH
// if not mc_bases then
31200: LD_EXP 50
31204: NOT
31205: IFFALSE 31209
// exit ;
31207: GO 33032
// for i = 1 to mc_bases do
31209: LD_ADDR_VAR 0 2
31213: PUSH
31214: DOUBLE
31215: LD_INT 1
31217: DEC
31218: ST_TO_ADDR
31219: LD_EXP 50
31223: PUSH
31224: FOR_TO
31225: IFFALSE 33030
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31227: LD_EXP 50
31231: PUSH
31232: LD_VAR 0 2
31236: ARRAY
31237: NOT
31238: PUSH
31239: LD_EXP 57
31243: PUSH
31244: LD_VAR 0 2
31248: ARRAY
31249: OR
31250: IFFALSE 31254
// continue ;
31252: GO 31224
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31254: LD_EXP 66
31258: PUSH
31259: LD_VAR 0 2
31263: ARRAY
31264: NOT
31265: PUSH
31266: LD_EXP 67
31270: PUSH
31271: LD_VAR 0 2
31275: ARRAY
31276: AND
31277: IFFALSE 31315
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31279: LD_ADDR_EXP 67
31283: PUSH
31284: LD_EXP 67
31288: PPUSH
31289: LD_VAR 0 2
31293: PPUSH
31294: EMPTY
31295: PPUSH
31296: CALL_OW 1
31300: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31301: LD_VAR 0 2
31305: PPUSH
31306: LD_INT 107
31308: PPUSH
31309: CALL 22083 0 2
// continue ;
31313: GO 31224
// end ; target := [ ] ;
31315: LD_ADDR_VAR 0 7
31319: PUSH
31320: EMPTY
31321: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31322: LD_ADDR_VAR 0 6
31326: PUSH
31327: LD_EXP 50
31331: PUSH
31332: LD_VAR 0 2
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PPUSH
31342: CALL_OW 255
31346: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31347: LD_ADDR_VAR 0 9
31351: PUSH
31352: LD_EXP 50
31356: PUSH
31357: LD_VAR 0 2
31361: ARRAY
31362: PPUSH
31363: LD_INT 2
31365: PUSH
31366: LD_INT 30
31368: PUSH
31369: LD_INT 0
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 30
31378: PUSH
31379: LD_INT 1
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: PPUSH
31391: CALL_OW 72
31395: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31396: LD_ADDR_VAR 0 3
31400: PUSH
31401: DOUBLE
31402: LD_EXP 66
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: INC
31413: ST_TO_ADDR
31414: LD_INT 1
31416: PUSH
31417: FOR_DOWNTO
31418: IFFALSE 31663
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31420: LD_EXP 66
31424: PUSH
31425: LD_VAR 0 2
31429: ARRAY
31430: PUSH
31431: LD_VAR 0 3
31435: ARRAY
31436: PUSH
31437: LD_INT 2
31439: ARRAY
31440: PPUSH
31441: LD_EXP 66
31445: PUSH
31446: LD_VAR 0 2
31450: ARRAY
31451: PUSH
31452: LD_VAR 0 3
31456: ARRAY
31457: PUSH
31458: LD_INT 3
31460: ARRAY
31461: PPUSH
31462: CALL_OW 488
31466: PUSH
31467: LD_EXP 66
31471: PUSH
31472: LD_VAR 0 2
31476: ARRAY
31477: PUSH
31478: LD_VAR 0 3
31482: ARRAY
31483: PUSH
31484: LD_INT 2
31486: ARRAY
31487: PPUSH
31488: LD_EXP 66
31492: PUSH
31493: LD_VAR 0 2
31497: ARRAY
31498: PUSH
31499: LD_VAR 0 3
31503: ARRAY
31504: PUSH
31505: LD_INT 3
31507: ARRAY
31508: PPUSH
31509: CALL_OW 284
31513: PUSH
31514: LD_INT 0
31516: EQUAL
31517: AND
31518: IFFALSE 31573
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31520: LD_ADDR_VAR 0 5
31524: PUSH
31525: LD_EXP 66
31529: PUSH
31530: LD_VAR 0 2
31534: ARRAY
31535: PPUSH
31536: LD_VAR 0 3
31540: PPUSH
31541: CALL_OW 3
31545: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31546: LD_ADDR_EXP 66
31550: PUSH
31551: LD_EXP 66
31555: PPUSH
31556: LD_VAR 0 2
31560: PPUSH
31561: LD_VAR 0 5
31565: PPUSH
31566: CALL_OW 1
31570: ST_TO_ADDR
// continue ;
31571: GO 31417
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31573: LD_VAR 0 6
31577: PPUSH
31578: LD_EXP 66
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_VAR 0 3
31593: ARRAY
31594: PUSH
31595: LD_INT 2
31597: ARRAY
31598: PPUSH
31599: LD_EXP 66
31603: PUSH
31604: LD_VAR 0 2
31608: ARRAY
31609: PUSH
31610: LD_VAR 0 3
31614: ARRAY
31615: PUSH
31616: LD_INT 3
31618: ARRAY
31619: PPUSH
31620: LD_INT 30
31622: PPUSH
31623: CALL 54437 0 4
31627: PUSH
31628: LD_INT 4
31630: ARRAY
31631: PUSH
31632: LD_INT 0
31634: EQUAL
31635: IFFALSE 31661
// begin target := mc_crates [ i ] [ j ] ;
31637: LD_ADDR_VAR 0 7
31641: PUSH
31642: LD_EXP 66
31646: PUSH
31647: LD_VAR 0 2
31651: ARRAY
31652: PUSH
31653: LD_VAR 0 3
31657: ARRAY
31658: ST_TO_ADDR
// break ;
31659: GO 31663
// end ; end ;
31661: GO 31417
31663: POP
31664: POP
// if not target then
31665: LD_VAR 0 7
31669: NOT
31670: IFFALSE 31674
// continue ;
31672: GO 31224
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31674: LD_ADDR_VAR 0 8
31678: PUSH
31679: LD_EXP 69
31683: PUSH
31684: LD_VAR 0 2
31688: ARRAY
31689: PPUSH
31690: LD_INT 2
31692: PUSH
31693: LD_INT 3
31695: PUSH
31696: LD_INT 58
31698: PUSH
31699: EMPTY
31700: LIST
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 61
31708: PUSH
31709: EMPTY
31710: LIST
31711: PUSH
31712: LD_INT 33
31714: PUSH
31715: LD_INT 5
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 33
31724: PUSH
31725: LD_INT 3
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 2
31741: PUSH
31742: LD_INT 34
31744: PUSH
31745: LD_INT 32
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 34
31754: PUSH
31755: LD_INT 51
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 34
31764: PUSH
31765: LD_INT 12
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PPUSH
31782: CALL_OW 72
31786: ST_TO_ADDR
// if not cargo then
31787: LD_VAR 0 8
31791: NOT
31792: IFFALSE 32498
// begin if mc_crates_collector [ i ] < 5 then
31794: LD_EXP 67
31798: PUSH
31799: LD_VAR 0 2
31803: ARRAY
31804: PUSH
31805: LD_INT 5
31807: LESS
31808: IFFALSE 32174
// begin if mc_ape [ i ] then
31810: LD_EXP 79
31814: PUSH
31815: LD_VAR 0 2
31819: ARRAY
31820: IFFALSE 31867
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31822: LD_ADDR_VAR 0 5
31826: PUSH
31827: LD_EXP 79
31831: PUSH
31832: LD_VAR 0 2
31836: ARRAY
31837: PPUSH
31838: LD_INT 25
31840: PUSH
31841: LD_INT 16
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 24
31850: PUSH
31851: LD_INT 750
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PPUSH
31862: CALL_OW 72
31866: ST_TO_ADDR
// if not tmp then
31867: LD_VAR 0 5
31871: NOT
31872: IFFALSE 31919
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31874: LD_ADDR_VAR 0 5
31878: PUSH
31879: LD_EXP 50
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PPUSH
31890: LD_INT 25
31892: PUSH
31893: LD_INT 2
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 24
31902: PUSH
31903: LD_INT 750
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PPUSH
31914: CALL_OW 72
31918: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31919: LD_EXP 79
31923: PUSH
31924: LD_VAR 0 2
31928: ARRAY
31929: PUSH
31930: LD_EXP 50
31934: PUSH
31935: LD_VAR 0 2
31939: ARRAY
31940: PPUSH
31941: LD_INT 25
31943: PUSH
31944: LD_INT 2
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 24
31953: PUSH
31954: LD_INT 750
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PPUSH
31965: CALL_OW 72
31969: AND
31970: PUSH
31971: LD_VAR 0 5
31975: PUSH
31976: LD_INT 5
31978: LESS
31979: AND
31980: IFFALSE 32062
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31982: LD_ADDR_VAR 0 3
31986: PUSH
31987: LD_EXP 50
31991: PUSH
31992: LD_VAR 0 2
31996: ARRAY
31997: PPUSH
31998: LD_INT 25
32000: PUSH
32001: LD_INT 2
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: PUSH
32008: LD_INT 24
32010: PUSH
32011: LD_INT 750
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PPUSH
32022: CALL_OW 72
32026: PUSH
32027: FOR_IN
32028: IFFALSE 32060
// begin tmp := tmp union j ;
32030: LD_ADDR_VAR 0 5
32034: PUSH
32035: LD_VAR 0 5
32039: PUSH
32040: LD_VAR 0 3
32044: UNION
32045: ST_TO_ADDR
// if tmp >= 5 then
32046: LD_VAR 0 5
32050: PUSH
32051: LD_INT 5
32053: GREATEREQUAL
32054: IFFALSE 32058
// break ;
32056: GO 32060
// end ;
32058: GO 32027
32060: POP
32061: POP
// end ; if not tmp then
32062: LD_VAR 0 5
32066: NOT
32067: IFFALSE 32071
// continue ;
32069: GO 31224
// for j in tmp do
32071: LD_ADDR_VAR 0 3
32075: PUSH
32076: LD_VAR 0 5
32080: PUSH
32081: FOR_IN
32082: IFFALSE 32172
// if not GetTag ( j ) then
32084: LD_VAR 0 3
32088: PPUSH
32089: CALL_OW 110
32093: NOT
32094: IFFALSE 32170
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32096: LD_ADDR_EXP 67
32100: PUSH
32101: LD_EXP 67
32105: PPUSH
32106: LD_VAR 0 2
32110: PUSH
32111: LD_EXP 67
32115: PUSH
32116: LD_VAR 0 2
32120: ARRAY
32121: PUSH
32122: LD_INT 1
32124: PLUS
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PPUSH
32130: LD_VAR 0 3
32134: PPUSH
32135: CALL 53541 0 3
32139: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32140: LD_VAR 0 3
32144: PPUSH
32145: LD_INT 107
32147: PPUSH
32148: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32152: LD_EXP 67
32156: PUSH
32157: LD_VAR 0 2
32161: ARRAY
32162: PUSH
32163: LD_INT 5
32165: GREATEREQUAL
32166: IFFALSE 32170
// break ;
32168: GO 32172
// end ;
32170: GO 32081
32172: POP
32173: POP
// end ; if mc_crates_collector [ i ] and target then
32174: LD_EXP 67
32178: PUSH
32179: LD_VAR 0 2
32183: ARRAY
32184: PUSH
32185: LD_VAR 0 7
32189: AND
32190: IFFALSE 32496
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32192: LD_EXP 67
32196: PUSH
32197: LD_VAR 0 2
32201: ARRAY
32202: PUSH
32203: LD_VAR 0 7
32207: PUSH
32208: LD_INT 1
32210: ARRAY
32211: LESS
32212: IFFALSE 32232
// tmp := mc_crates_collector [ i ] else
32214: LD_ADDR_VAR 0 5
32218: PUSH
32219: LD_EXP 67
32223: PUSH
32224: LD_VAR 0 2
32228: ARRAY
32229: ST_TO_ADDR
32230: GO 32246
// tmp := target [ 1 ] ;
32232: LD_ADDR_VAR 0 5
32236: PUSH
32237: LD_VAR 0 7
32241: PUSH
32242: LD_INT 1
32244: ARRAY
32245: ST_TO_ADDR
// k := 0 ;
32246: LD_ADDR_VAR 0 4
32250: PUSH
32251: LD_INT 0
32253: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32254: LD_ADDR_VAR 0 3
32258: PUSH
32259: LD_EXP 67
32263: PUSH
32264: LD_VAR 0 2
32268: ARRAY
32269: PUSH
32270: FOR_IN
32271: IFFALSE 32494
// begin k := k + 1 ;
32273: LD_ADDR_VAR 0 4
32277: PUSH
32278: LD_VAR 0 4
32282: PUSH
32283: LD_INT 1
32285: PLUS
32286: ST_TO_ADDR
// if k > tmp then
32287: LD_VAR 0 4
32291: PUSH
32292: LD_VAR 0 5
32296: GREATER
32297: IFFALSE 32301
// break ;
32299: GO 32494
// if not GetClass ( j ) in [ 2 , 16 ] then
32301: LD_VAR 0 3
32305: PPUSH
32306: CALL_OW 257
32310: PUSH
32311: LD_INT 2
32313: PUSH
32314: LD_INT 16
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: IN
32321: NOT
32322: IFFALSE 32375
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32324: LD_ADDR_EXP 67
32328: PUSH
32329: LD_EXP 67
32333: PPUSH
32334: LD_VAR 0 2
32338: PPUSH
32339: LD_EXP 67
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_VAR 0 3
32354: DIFF
32355: PPUSH
32356: CALL_OW 1
32360: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32361: LD_VAR 0 3
32365: PPUSH
32366: LD_INT 0
32368: PPUSH
32369: CALL_OW 109
// continue ;
32373: GO 32270
// end ; if IsInUnit ( j ) then
32375: LD_VAR 0 3
32379: PPUSH
32380: CALL_OW 310
32384: IFFALSE 32395
// ComExitBuilding ( j ) ;
32386: LD_VAR 0 3
32390: PPUSH
32391: CALL_OW 122
// wait ( 3 ) ;
32395: LD_INT 3
32397: PPUSH
32398: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32402: LD_VAR 0 3
32406: PPUSH
32407: CALL_OW 314
32411: PUSH
32412: LD_VAR 0 6
32416: PPUSH
32417: LD_VAR 0 7
32421: PUSH
32422: LD_INT 2
32424: ARRAY
32425: PPUSH
32426: LD_VAR 0 7
32430: PUSH
32431: LD_INT 3
32433: ARRAY
32434: PPUSH
32435: LD_INT 30
32437: PPUSH
32438: CALL 54437 0 4
32442: PUSH
32443: LD_INT 4
32445: ARRAY
32446: AND
32447: IFFALSE 32465
// ComStandNearbyBuilding ( j , depot ) else
32449: LD_VAR 0 3
32453: PPUSH
32454: LD_VAR 0 9
32458: PPUSH
32459: CALL 50119 0 2
32463: GO 32492
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32465: LD_VAR 0 3
32469: PPUSH
32470: LD_VAR 0 7
32474: PUSH
32475: LD_INT 2
32477: ARRAY
32478: PPUSH
32479: LD_VAR 0 7
32483: PUSH
32484: LD_INT 3
32486: ARRAY
32487: PPUSH
32488: CALL_OW 117
// end ;
32492: GO 32270
32494: POP
32495: POP
// end ; end else
32496: GO 33028
// begin for j in cargo do
32498: LD_ADDR_VAR 0 3
32502: PUSH
32503: LD_VAR 0 8
32507: PUSH
32508: FOR_IN
32509: IFFALSE 33026
// begin if GetTag ( j ) <> 0 then
32511: LD_VAR 0 3
32515: PPUSH
32516: CALL_OW 110
32520: PUSH
32521: LD_INT 0
32523: NONEQUAL
32524: IFFALSE 32528
// continue ;
32526: GO 32508
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32528: LD_VAR 0 3
32532: PPUSH
32533: CALL_OW 256
32537: PUSH
32538: LD_INT 1000
32540: LESS
32541: PUSH
32542: LD_VAR 0 3
32546: PPUSH
32547: LD_EXP 74
32551: PUSH
32552: LD_VAR 0 2
32556: ARRAY
32557: PPUSH
32558: CALL_OW 308
32562: NOT
32563: AND
32564: IFFALSE 32586
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32566: LD_VAR 0 3
32570: PPUSH
32571: LD_EXP 74
32575: PUSH
32576: LD_VAR 0 2
32580: ARRAY
32581: PPUSH
32582: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32586: LD_VAR 0 3
32590: PPUSH
32591: CALL_OW 256
32595: PUSH
32596: LD_INT 1000
32598: LESS
32599: PUSH
32600: LD_VAR 0 3
32604: PPUSH
32605: LD_EXP 74
32609: PUSH
32610: LD_VAR 0 2
32614: ARRAY
32615: PPUSH
32616: CALL_OW 308
32620: AND
32621: IFFALSE 32625
// continue ;
32623: GO 32508
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32625: LD_VAR 0 3
32629: PPUSH
32630: CALL_OW 262
32634: PUSH
32635: LD_INT 2
32637: EQUAL
32638: PUSH
32639: LD_VAR 0 3
32643: PPUSH
32644: CALL_OW 261
32648: PUSH
32649: LD_INT 15
32651: LESS
32652: AND
32653: IFFALSE 32657
// continue ;
32655: GO 32508
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32657: LD_VAR 0 3
32661: PPUSH
32662: CALL_OW 262
32666: PUSH
32667: LD_INT 1
32669: EQUAL
32670: PUSH
32671: LD_VAR 0 3
32675: PPUSH
32676: CALL_OW 261
32680: PUSH
32681: LD_INT 10
32683: LESS
32684: AND
32685: IFFALSE 32965
// begin if not depot then
32687: LD_VAR 0 9
32691: NOT
32692: IFFALSE 32696
// continue ;
32694: GO 32508
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32696: LD_VAR 0 3
32700: PPUSH
32701: LD_VAR 0 9
32705: PPUSH
32706: LD_VAR 0 3
32710: PPUSH
32711: CALL_OW 74
32715: PPUSH
32716: CALL_OW 296
32720: PUSH
32721: LD_INT 6
32723: LESS
32724: IFFALSE 32740
// SetFuel ( j , 100 ) else
32726: LD_VAR 0 3
32730: PPUSH
32731: LD_INT 100
32733: PPUSH
32734: CALL_OW 240
32738: GO 32965
// if GetFuel ( j ) = 0 then
32740: LD_VAR 0 3
32744: PPUSH
32745: CALL_OW 261
32749: PUSH
32750: LD_INT 0
32752: EQUAL
32753: IFFALSE 32965
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32755: LD_ADDR_EXP 69
32759: PUSH
32760: LD_EXP 69
32764: PPUSH
32765: LD_VAR 0 2
32769: PPUSH
32770: LD_EXP 69
32774: PUSH
32775: LD_VAR 0 2
32779: ARRAY
32780: PUSH
32781: LD_VAR 0 3
32785: DIFF
32786: PPUSH
32787: CALL_OW 1
32791: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32792: LD_VAR 0 3
32796: PPUSH
32797: CALL_OW 263
32801: PUSH
32802: LD_INT 1
32804: EQUAL
32805: IFFALSE 32821
// ComExitVehicle ( IsInUnit ( j ) ) ;
32807: LD_VAR 0 3
32811: PPUSH
32812: CALL_OW 310
32816: PPUSH
32817: CALL_OW 121
// if GetControl ( j ) = control_remote then
32821: LD_VAR 0 3
32825: PPUSH
32826: CALL_OW 263
32830: PUSH
32831: LD_INT 2
32833: EQUAL
32834: IFFALSE 32845
// ComUnlink ( j ) ;
32836: LD_VAR 0 3
32840: PPUSH
32841: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32845: LD_ADDR_VAR 0 10
32849: PUSH
32850: LD_VAR 0 2
32854: PPUSH
32855: LD_INT 3
32857: PPUSH
32858: CALL 42604 0 2
32862: ST_TO_ADDR
// if fac then
32863: LD_VAR 0 10
32867: IFFALSE 32963
// begin for k in fac do
32869: LD_ADDR_VAR 0 4
32873: PUSH
32874: LD_VAR 0 10
32878: PUSH
32879: FOR_IN
32880: IFFALSE 32961
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32882: LD_ADDR_VAR 0 11
32886: PUSH
32887: LD_VAR 0 10
32891: PPUSH
32892: LD_VAR 0 3
32896: PPUSH
32897: CALL_OW 265
32901: PPUSH
32902: LD_VAR 0 3
32906: PPUSH
32907: CALL_OW 262
32911: PPUSH
32912: LD_VAR 0 3
32916: PPUSH
32917: CALL_OW 263
32921: PPUSH
32922: LD_VAR 0 3
32926: PPUSH
32927: CALL_OW 264
32931: PPUSH
32932: CALL 51037 0 5
32936: ST_TO_ADDR
// if components then
32937: LD_VAR 0 11
32941: IFFALSE 32959
// begin MC_InsertProduceList ( i , components ) ;
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 11
32952: PPUSH
32953: CALL 42149 0 2
// break ;
32957: GO 32961
// end ; end ;
32959: GO 32879
32961: POP
32962: POP
// end ; continue ;
32963: GO 32508
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32965: LD_VAR 0 3
32969: PPUSH
32970: LD_INT 1
32972: PPUSH
32973: CALL_OW 289
32977: PUSH
32978: LD_INT 100
32980: LESS
32981: PUSH
32982: LD_VAR 0 3
32986: PPUSH
32987: CALL_OW 314
32991: NOT
32992: AND
32993: IFFALSE 33022
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32995: LD_VAR 0 3
32999: PPUSH
33000: LD_VAR 0 7
33004: PUSH
33005: LD_INT 2
33007: ARRAY
33008: PPUSH
33009: LD_VAR 0 7
33013: PUSH
33014: LD_INT 3
33016: ARRAY
33017: PPUSH
33018: CALL_OW 117
// break ;
33022: GO 33026
// end ;
33024: GO 32508
33026: POP
33027: POP
// end ; end ;
33028: GO 31224
33030: POP
33031: POP
// end ;
33032: LD_VAR 0 1
33036: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33037: LD_INT 0
33039: PPUSH
33040: PPUSH
33041: PPUSH
33042: PPUSH
// if not mc_bases then
33043: LD_EXP 50
33047: NOT
33048: IFFALSE 33052
// exit ;
33050: GO 33213
// for i = 1 to mc_bases do
33052: LD_ADDR_VAR 0 2
33056: PUSH
33057: DOUBLE
33058: LD_INT 1
33060: DEC
33061: ST_TO_ADDR
33062: LD_EXP 50
33066: PUSH
33067: FOR_TO
33068: IFFALSE 33211
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33070: LD_ADDR_VAR 0 4
33074: PUSH
33075: LD_EXP 69
33079: PUSH
33080: LD_VAR 0 2
33084: ARRAY
33085: PUSH
33086: LD_EXP 72
33090: PUSH
33091: LD_VAR 0 2
33095: ARRAY
33096: UNION
33097: PPUSH
33098: LD_INT 33
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PPUSH
33108: CALL_OW 72
33112: ST_TO_ADDR
// if tmp then
33113: LD_VAR 0 4
33117: IFFALSE 33209
// for j in tmp do
33119: LD_ADDR_VAR 0 3
33123: PUSH
33124: LD_VAR 0 4
33128: PUSH
33129: FOR_IN
33130: IFFALSE 33207
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33132: LD_VAR 0 3
33136: PPUSH
33137: CALL_OW 312
33141: NOT
33142: PUSH
33143: LD_VAR 0 3
33147: PPUSH
33148: CALL_OW 256
33152: PUSH
33153: LD_INT 250
33155: GREATEREQUAL
33156: AND
33157: IFFALSE 33170
// Connect ( j ) else
33159: LD_VAR 0 3
33163: PPUSH
33164: CALL 56512 0 1
33168: GO 33205
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33170: LD_VAR 0 3
33174: PPUSH
33175: CALL_OW 256
33179: PUSH
33180: LD_INT 250
33182: LESS
33183: PUSH
33184: LD_VAR 0 3
33188: PPUSH
33189: CALL_OW 312
33193: AND
33194: IFFALSE 33205
// ComUnlink ( j ) ;
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 136
33205: GO 33129
33207: POP
33208: POP
// end ;
33209: GO 33067
33211: POP
33212: POP
// end ;
33213: LD_VAR 0 1
33217: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33218: LD_INT 0
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
33224: PPUSH
// if not mc_bases then
33225: LD_EXP 50
33229: NOT
33230: IFFALSE 33234
// exit ;
33232: GO 33679
// for i = 1 to mc_bases do
33234: LD_ADDR_VAR 0 2
33238: PUSH
33239: DOUBLE
33240: LD_INT 1
33242: DEC
33243: ST_TO_ADDR
33244: LD_EXP 50
33248: PUSH
33249: FOR_TO
33250: IFFALSE 33677
// begin if not mc_produce [ i ] then
33252: LD_EXP 71
33256: PUSH
33257: LD_VAR 0 2
33261: ARRAY
33262: NOT
33263: IFFALSE 33267
// continue ;
33265: GO 33249
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33267: LD_ADDR_VAR 0 5
33271: PUSH
33272: LD_EXP 50
33276: PUSH
33277: LD_VAR 0 2
33281: ARRAY
33282: PPUSH
33283: LD_INT 30
33285: PUSH
33286: LD_INT 3
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PPUSH
33293: CALL_OW 72
33297: ST_TO_ADDR
// if not fac then
33298: LD_VAR 0 5
33302: NOT
33303: IFFALSE 33307
// continue ;
33305: GO 33249
// for j in fac do
33307: LD_ADDR_VAR 0 3
33311: PUSH
33312: LD_VAR 0 5
33316: PUSH
33317: FOR_IN
33318: IFFALSE 33673
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33320: LD_VAR 0 3
33324: PPUSH
33325: CALL_OW 461
33329: PUSH
33330: LD_INT 2
33332: NONEQUAL
33333: PUSH
33334: LD_VAR 0 3
33338: PPUSH
33339: LD_INT 15
33341: PPUSH
33342: CALL 56140 0 2
33346: PUSH
33347: LD_INT 4
33349: ARRAY
33350: OR
33351: IFFALSE 33355
// continue ;
33353: GO 33317
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33355: LD_VAR 0 3
33359: PPUSH
33360: LD_EXP 71
33364: PUSH
33365: LD_VAR 0 2
33369: ARRAY
33370: PUSH
33371: LD_INT 1
33373: ARRAY
33374: PUSH
33375: LD_INT 1
33377: ARRAY
33378: PPUSH
33379: LD_EXP 71
33383: PUSH
33384: LD_VAR 0 2
33388: ARRAY
33389: PUSH
33390: LD_INT 1
33392: ARRAY
33393: PUSH
33394: LD_INT 2
33396: ARRAY
33397: PPUSH
33398: LD_EXP 71
33402: PUSH
33403: LD_VAR 0 2
33407: ARRAY
33408: PUSH
33409: LD_INT 1
33411: ARRAY
33412: PUSH
33413: LD_INT 3
33415: ARRAY
33416: PPUSH
33417: LD_EXP 71
33421: PUSH
33422: LD_VAR 0 2
33426: ARRAY
33427: PUSH
33428: LD_INT 1
33430: ARRAY
33431: PUSH
33432: LD_INT 4
33434: ARRAY
33435: PPUSH
33436: CALL_OW 448
33440: PUSH
33441: LD_VAR 0 3
33445: PPUSH
33446: LD_EXP 71
33450: PUSH
33451: LD_VAR 0 2
33455: ARRAY
33456: PUSH
33457: LD_INT 1
33459: ARRAY
33460: PUSH
33461: LD_INT 1
33463: ARRAY
33464: PUSH
33465: LD_EXP 71
33469: PUSH
33470: LD_VAR 0 2
33474: ARRAY
33475: PUSH
33476: LD_INT 1
33478: ARRAY
33479: PUSH
33480: LD_INT 2
33482: ARRAY
33483: PUSH
33484: LD_EXP 71
33488: PUSH
33489: LD_VAR 0 2
33493: ARRAY
33494: PUSH
33495: LD_INT 1
33497: ARRAY
33498: PUSH
33499: LD_INT 3
33501: ARRAY
33502: PUSH
33503: LD_EXP 71
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: PUSH
33514: LD_INT 1
33516: ARRAY
33517: PUSH
33518: LD_INT 4
33520: ARRAY
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: LIST
33526: LIST
33527: PPUSH
33528: CALL 59907 0 2
33532: AND
33533: IFFALSE 33671
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33535: LD_VAR 0 3
33539: PPUSH
33540: LD_EXP 71
33544: PUSH
33545: LD_VAR 0 2
33549: ARRAY
33550: PUSH
33551: LD_INT 1
33553: ARRAY
33554: PUSH
33555: LD_INT 1
33557: ARRAY
33558: PPUSH
33559: LD_EXP 71
33563: PUSH
33564: LD_VAR 0 2
33568: ARRAY
33569: PUSH
33570: LD_INT 1
33572: ARRAY
33573: PUSH
33574: LD_INT 2
33576: ARRAY
33577: PPUSH
33578: LD_EXP 71
33582: PUSH
33583: LD_VAR 0 2
33587: ARRAY
33588: PUSH
33589: LD_INT 1
33591: ARRAY
33592: PUSH
33593: LD_INT 3
33595: ARRAY
33596: PPUSH
33597: LD_EXP 71
33601: PUSH
33602: LD_VAR 0 2
33606: ARRAY
33607: PUSH
33608: LD_INT 1
33610: ARRAY
33611: PUSH
33612: LD_INT 4
33614: ARRAY
33615: PPUSH
33616: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33620: LD_ADDR_VAR 0 4
33624: PUSH
33625: LD_EXP 71
33629: PUSH
33630: LD_VAR 0 2
33634: ARRAY
33635: PPUSH
33636: LD_INT 1
33638: PPUSH
33639: CALL_OW 3
33643: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33644: LD_ADDR_EXP 71
33648: PUSH
33649: LD_EXP 71
33653: PPUSH
33654: LD_VAR 0 2
33658: PPUSH
33659: LD_VAR 0 4
33663: PPUSH
33664: CALL_OW 1
33668: ST_TO_ADDR
// break ;
33669: GO 33673
// end ; end ;
33671: GO 33317
33673: POP
33674: POP
// end ;
33675: GO 33249
33677: POP
33678: POP
// end ;
33679: LD_VAR 0 1
33683: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33684: LD_INT 0
33686: PPUSH
33687: PPUSH
33688: PPUSH
// if not mc_bases then
33689: LD_EXP 50
33693: NOT
33694: IFFALSE 33698
// exit ;
33696: GO 33787
// for i = 1 to mc_bases do
33698: LD_ADDR_VAR 0 2
33702: PUSH
33703: DOUBLE
33704: LD_INT 1
33706: DEC
33707: ST_TO_ADDR
33708: LD_EXP 50
33712: PUSH
33713: FOR_TO
33714: IFFALSE 33785
// begin if mc_attack [ i ] then
33716: LD_EXP 70
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: IFFALSE 33783
// begin tmp := mc_attack [ i ] [ 1 ] ;
33728: LD_ADDR_VAR 0 3
33732: PUSH
33733: LD_EXP 70
33737: PUSH
33738: LD_VAR 0 2
33742: ARRAY
33743: PUSH
33744: LD_INT 1
33746: ARRAY
33747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33748: LD_ADDR_EXP 70
33752: PUSH
33753: LD_EXP 70
33757: PPUSH
33758: LD_VAR 0 2
33762: PPUSH
33763: EMPTY
33764: PPUSH
33765: CALL_OW 1
33769: ST_TO_ADDR
// Attack ( tmp ) ;
33770: LD_VAR 0 3
33774: PPUSH
33775: CALL 106068 0 1
// exit ;
33779: POP
33780: POP
33781: GO 33787
// end ; end ;
33783: GO 33713
33785: POP
33786: POP
// end ;
33787: LD_VAR 0 1
33791: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33792: LD_INT 0
33794: PPUSH
33795: PPUSH
33796: PPUSH
33797: PPUSH
33798: PPUSH
33799: PPUSH
33800: PPUSH
// if not mc_bases then
33801: LD_EXP 50
33805: NOT
33806: IFFALSE 33810
// exit ;
33808: GO 34667
// for i = 1 to mc_bases do
33810: LD_ADDR_VAR 0 2
33814: PUSH
33815: DOUBLE
33816: LD_INT 1
33818: DEC
33819: ST_TO_ADDR
33820: LD_EXP 50
33824: PUSH
33825: FOR_TO
33826: IFFALSE 34665
// begin if not mc_bases [ i ] then
33828: LD_EXP 50
33832: PUSH
33833: LD_VAR 0 2
33837: ARRAY
33838: NOT
33839: IFFALSE 33843
// continue ;
33841: GO 33825
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33843: LD_ADDR_VAR 0 7
33847: PUSH
33848: LD_EXP 50
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: PUSH
33859: LD_INT 1
33861: ARRAY
33862: PPUSH
33863: CALL 50341 0 1
33867: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33868: LD_ADDR_EXP 73
33872: PUSH
33873: LD_EXP 73
33877: PPUSH
33878: LD_VAR 0 2
33882: PPUSH
33883: LD_EXP 50
33887: PUSH
33888: LD_VAR 0 2
33892: ARRAY
33893: PUSH
33894: LD_INT 1
33896: ARRAY
33897: PPUSH
33898: CALL_OW 255
33902: PPUSH
33903: LD_EXP 75
33907: PUSH
33908: LD_VAR 0 2
33912: ARRAY
33913: PPUSH
33914: CALL 50306 0 2
33918: PPUSH
33919: CALL_OW 1
33923: ST_TO_ADDR
// if not mc_scan [ i ] then
33924: LD_EXP 73
33928: PUSH
33929: LD_VAR 0 2
33933: ARRAY
33934: NOT
33935: IFFALSE 34113
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33937: LD_ADDR_EXP 93
33941: PUSH
33942: LD_EXP 93
33946: PPUSH
33947: LD_VAR 0 2
33951: PPUSH
33952: LD_INT 0
33954: PPUSH
33955: CALL_OW 1
33959: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33960: LD_ADDR_VAR 0 4
33964: PUSH
33965: LD_EXP 50
33969: PUSH
33970: LD_VAR 0 2
33974: ARRAY
33975: PPUSH
33976: LD_INT 2
33978: PUSH
33979: LD_INT 25
33981: PUSH
33982: LD_INT 5
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 25
33991: PUSH
33992: LD_INT 8
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 25
34001: PUSH
34002: LD_INT 9
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: LIST
34013: LIST
34014: PPUSH
34015: CALL_OW 72
34019: ST_TO_ADDR
// if not tmp then
34020: LD_VAR 0 4
34024: NOT
34025: IFFALSE 34029
// continue ;
34027: GO 33825
// for j in tmp do
34029: LD_ADDR_VAR 0 3
34033: PUSH
34034: LD_VAR 0 4
34038: PUSH
34039: FOR_IN
34040: IFFALSE 34111
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34042: LD_VAR 0 3
34046: PPUSH
34047: CALL_OW 310
34051: PPUSH
34052: CALL_OW 266
34056: PUSH
34057: LD_INT 5
34059: EQUAL
34060: PUSH
34061: LD_VAR 0 3
34065: PPUSH
34066: CALL_OW 257
34070: PUSH
34071: LD_INT 1
34073: EQUAL
34074: AND
34075: PUSH
34076: LD_VAR 0 3
34080: PPUSH
34081: CALL_OW 459
34085: NOT
34086: AND
34087: PUSH
34088: LD_VAR 0 7
34092: AND
34093: IFFALSE 34109
// ComChangeProfession ( j , class ) ;
34095: LD_VAR 0 3
34099: PPUSH
34100: LD_VAR 0 7
34104: PPUSH
34105: CALL_OW 123
34109: GO 34039
34111: POP
34112: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34113: LD_EXP 73
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_EXP 93
34128: PUSH
34129: LD_VAR 0 2
34133: ARRAY
34134: NOT
34135: AND
34136: PUSH
34137: LD_EXP 72
34141: PUSH
34142: LD_VAR 0 2
34146: ARRAY
34147: NOT
34148: AND
34149: PUSH
34150: LD_EXP 50
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PPUSH
34161: LD_INT 50
34163: PUSH
34164: EMPTY
34165: LIST
34166: PUSH
34167: LD_INT 2
34169: PUSH
34170: LD_INT 30
34172: PUSH
34173: LD_INT 32
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 30
34182: PUSH
34183: LD_INT 33
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 30
34192: PUSH
34193: LD_INT 4
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: LD_INT 30
34202: PUSH
34203: LD_INT 5
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PPUSH
34221: CALL_OW 72
34225: PUSH
34226: LD_INT 4
34228: LESS
34229: PUSH
34230: LD_EXP 50
34234: PUSH
34235: LD_VAR 0 2
34239: ARRAY
34240: PPUSH
34241: LD_INT 3
34243: PUSH
34244: LD_INT 24
34246: PUSH
34247: LD_INT 1000
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 2
34260: PUSH
34261: LD_INT 30
34263: PUSH
34264: LD_INT 0
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 30
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: LIST
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PPUSH
34290: CALL_OW 72
34294: OR
34295: AND
34296: IFFALSE 34547
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34298: LD_ADDR_EXP 93
34302: PUSH
34303: LD_EXP 93
34307: PPUSH
34308: LD_VAR 0 2
34312: PPUSH
34313: LD_INT 1
34315: PPUSH
34316: CALL_OW 1
34320: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34321: LD_ADDR_VAR 0 4
34325: PUSH
34326: LD_EXP 50
34330: PUSH
34331: LD_VAR 0 2
34335: ARRAY
34336: PPUSH
34337: LD_INT 2
34339: PUSH
34340: LD_INT 25
34342: PUSH
34343: LD_INT 1
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 25
34352: PUSH
34353: LD_INT 5
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 25
34362: PUSH
34363: LD_INT 8
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 25
34372: PUSH
34373: LD_INT 9
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: PPUSH
34387: CALL_OW 72
34391: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34392: LD_ADDR_VAR 0 4
34396: PUSH
34397: LD_VAR 0 4
34401: PUSH
34402: LD_VAR 0 4
34406: PPUSH
34407: LD_INT 18
34409: PPUSH
34410: CALL 82810 0 2
34414: DIFF
34415: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34416: LD_VAR 0 4
34420: NOT
34421: PUSH
34422: LD_EXP 50
34426: PUSH
34427: LD_VAR 0 2
34431: ARRAY
34432: PPUSH
34433: LD_INT 2
34435: PUSH
34436: LD_INT 30
34438: PUSH
34439: LD_INT 4
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 30
34448: PUSH
34449: LD_INT 5
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: LIST
34460: PPUSH
34461: CALL_OW 72
34465: NOT
34466: AND
34467: IFFALSE 34529
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34469: LD_ADDR_VAR 0 4
34473: PUSH
34474: LD_EXP 50
34478: PUSH
34479: LD_VAR 0 2
34483: ARRAY
34484: PPUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 25
34490: PUSH
34491: LD_INT 2
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 25
34500: PUSH
34501: LD_INT 3
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 25
34510: PUSH
34511: LD_INT 4
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: PPUSH
34524: CALL_OW 72
34528: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34529: LD_VAR 0 2
34533: PPUSH
34534: LD_VAR 0 4
34538: PPUSH
34539: CALL 110777 0 2
// exit ;
34543: POP
34544: POP
34545: GO 34667
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34547: LD_EXP 73
34551: PUSH
34552: LD_VAR 0 2
34556: ARRAY
34557: PUSH
34558: LD_EXP 93
34562: PUSH
34563: LD_VAR 0 2
34567: ARRAY
34568: NOT
34569: AND
34570: PUSH
34571: LD_EXP 72
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: AND
34582: IFFALSE 34663
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34584: LD_ADDR_EXP 93
34588: PUSH
34589: LD_EXP 93
34593: PPUSH
34594: LD_VAR 0 2
34598: PPUSH
34599: LD_INT 1
34601: PPUSH
34602: CALL_OW 1
34606: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34607: LD_ADDR_VAR 0 4
34611: PUSH
34612: LD_EXP 72
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34623: LD_ADDR_EXP 72
34627: PUSH
34628: LD_EXP 72
34632: PPUSH
34633: LD_VAR 0 2
34637: PPUSH
34638: EMPTY
34639: PPUSH
34640: CALL_OW 1
34644: ST_TO_ADDR
// Defend ( i , tmp ) ;
34645: LD_VAR 0 2
34649: PPUSH
34650: LD_VAR 0 4
34654: PPUSH
34655: CALL 111373 0 2
// exit ;
34659: POP
34660: POP
34661: GO 34667
// end ; end ;
34663: GO 33825
34665: POP
34666: POP
// end ;
34667: LD_VAR 0 1
34671: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34672: LD_INT 0
34674: PPUSH
34675: PPUSH
34676: PPUSH
34677: PPUSH
34678: PPUSH
34679: PPUSH
34680: PPUSH
34681: PPUSH
34682: PPUSH
34683: PPUSH
34684: PPUSH
// if not mc_bases then
34685: LD_EXP 50
34689: NOT
34690: IFFALSE 34694
// exit ;
34692: GO 35781
// for i = 1 to mc_bases do
34694: LD_ADDR_VAR 0 2
34698: PUSH
34699: DOUBLE
34700: LD_INT 1
34702: DEC
34703: ST_TO_ADDR
34704: LD_EXP 50
34708: PUSH
34709: FOR_TO
34710: IFFALSE 35779
// begin tmp := mc_lab [ i ] ;
34712: LD_ADDR_VAR 0 6
34716: PUSH
34717: LD_EXP 83
34721: PUSH
34722: LD_VAR 0 2
34726: ARRAY
34727: ST_TO_ADDR
// if not tmp then
34728: LD_VAR 0 6
34732: NOT
34733: IFFALSE 34737
// continue ;
34735: GO 34709
// idle_lab := 0 ;
34737: LD_ADDR_VAR 0 11
34741: PUSH
34742: LD_INT 0
34744: ST_TO_ADDR
// for j in tmp do
34745: LD_ADDR_VAR 0 3
34749: PUSH
34750: LD_VAR 0 6
34754: PUSH
34755: FOR_IN
34756: IFFALSE 35775
// begin researching := false ;
34758: LD_ADDR_VAR 0 10
34762: PUSH
34763: LD_INT 0
34765: ST_TO_ADDR
// side := GetSide ( j ) ;
34766: LD_ADDR_VAR 0 4
34770: PUSH
34771: LD_VAR 0 3
34775: PPUSH
34776: CALL_OW 255
34780: ST_TO_ADDR
// if not mc_tech [ side ] then
34781: LD_EXP 77
34785: PUSH
34786: LD_VAR 0 4
34790: ARRAY
34791: NOT
34792: IFFALSE 34796
// continue ;
34794: GO 34755
// if BuildingStatus ( j ) = bs_idle then
34796: LD_VAR 0 3
34800: PPUSH
34801: CALL_OW 461
34805: PUSH
34806: LD_INT 2
34808: EQUAL
34809: IFFALSE 34997
// begin if idle_lab and UnitsInside ( j ) < 6 then
34811: LD_VAR 0 11
34815: PUSH
34816: LD_VAR 0 3
34820: PPUSH
34821: CALL_OW 313
34825: PUSH
34826: LD_INT 6
34828: LESS
34829: AND
34830: IFFALSE 34901
// begin tmp2 := UnitsInside ( idle_lab ) ;
34832: LD_ADDR_VAR 0 9
34836: PUSH
34837: LD_VAR 0 11
34841: PPUSH
34842: CALL_OW 313
34846: ST_TO_ADDR
// if tmp2 then
34847: LD_VAR 0 9
34851: IFFALSE 34893
// for x in tmp2 do
34853: LD_ADDR_VAR 0 7
34857: PUSH
34858: LD_VAR 0 9
34862: PUSH
34863: FOR_IN
34864: IFFALSE 34891
// begin ComExitBuilding ( x ) ;
34866: LD_VAR 0 7
34870: PPUSH
34871: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34875: LD_VAR 0 7
34879: PPUSH
34880: LD_VAR 0 3
34884: PPUSH
34885: CALL_OW 180
// end ;
34889: GO 34863
34891: POP
34892: POP
// idle_lab := 0 ;
34893: LD_ADDR_VAR 0 11
34897: PUSH
34898: LD_INT 0
34900: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34901: LD_ADDR_VAR 0 5
34905: PUSH
34906: LD_EXP 77
34910: PUSH
34911: LD_VAR 0 4
34915: ARRAY
34916: PUSH
34917: FOR_IN
34918: IFFALSE 34978
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34920: LD_VAR 0 3
34924: PPUSH
34925: LD_VAR 0 5
34929: PPUSH
34930: CALL_OW 430
34934: PUSH
34935: LD_VAR 0 4
34939: PPUSH
34940: LD_VAR 0 5
34944: PPUSH
34945: CALL 49411 0 2
34949: AND
34950: IFFALSE 34976
// begin researching := true ;
34952: LD_ADDR_VAR 0 10
34956: PUSH
34957: LD_INT 1
34959: ST_TO_ADDR
// ComResearch ( j , t ) ;
34960: LD_VAR 0 3
34964: PPUSH
34965: LD_VAR 0 5
34969: PPUSH
34970: CALL_OW 124
// break ;
34974: GO 34978
// end ;
34976: GO 34917
34978: POP
34979: POP
// if not researching then
34980: LD_VAR 0 10
34984: NOT
34985: IFFALSE 34997
// idle_lab := j ;
34987: LD_ADDR_VAR 0 11
34991: PUSH
34992: LD_VAR 0 3
34996: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34997: LD_VAR 0 3
35001: PPUSH
35002: CALL_OW 461
35006: PUSH
35007: LD_INT 10
35009: EQUAL
35010: IFFALSE 35598
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35012: LD_EXP 79
35016: PUSH
35017: LD_VAR 0 2
35021: ARRAY
35022: NOT
35023: PUSH
35024: LD_EXP 80
35028: PUSH
35029: LD_VAR 0 2
35033: ARRAY
35034: NOT
35035: AND
35036: PUSH
35037: LD_EXP 77
35041: PUSH
35042: LD_VAR 0 4
35046: ARRAY
35047: PUSH
35048: LD_INT 1
35050: GREATER
35051: AND
35052: IFFALSE 35183
// begin ComCancel ( j ) ;
35054: LD_VAR 0 3
35058: PPUSH
35059: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35063: LD_ADDR_EXP 77
35067: PUSH
35068: LD_EXP 77
35072: PPUSH
35073: LD_VAR 0 4
35077: PPUSH
35078: LD_EXP 77
35082: PUSH
35083: LD_VAR 0 4
35087: ARRAY
35088: PPUSH
35089: LD_EXP 77
35093: PUSH
35094: LD_VAR 0 4
35098: ARRAY
35099: PUSH
35100: LD_INT 1
35102: MINUS
35103: PPUSH
35104: LD_EXP 77
35108: PUSH
35109: LD_VAR 0 4
35113: ARRAY
35114: PPUSH
35115: LD_INT 0
35117: PPUSH
35118: CALL 52959 0 4
35122: PPUSH
35123: CALL_OW 1
35127: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35128: LD_ADDR_EXP 77
35132: PUSH
35133: LD_EXP 77
35137: PPUSH
35138: LD_VAR 0 4
35142: PPUSH
35143: LD_EXP 77
35147: PUSH
35148: LD_VAR 0 4
35152: ARRAY
35153: PPUSH
35154: LD_EXP 77
35158: PUSH
35159: LD_VAR 0 4
35163: ARRAY
35164: PPUSH
35165: LD_INT 1
35167: PPUSH
35168: LD_INT 0
35170: PPUSH
35171: CALL 52959 0 4
35175: PPUSH
35176: CALL_OW 1
35180: ST_TO_ADDR
// continue ;
35181: GO 34755
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35183: LD_EXP 79
35187: PUSH
35188: LD_VAR 0 2
35192: ARRAY
35193: PUSH
35194: LD_EXP 80
35198: PUSH
35199: LD_VAR 0 2
35203: ARRAY
35204: NOT
35205: AND
35206: IFFALSE 35333
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35208: LD_ADDR_EXP 80
35212: PUSH
35213: LD_EXP 80
35217: PPUSH
35218: LD_VAR 0 2
35222: PUSH
35223: LD_EXP 80
35227: PUSH
35228: LD_VAR 0 2
35232: ARRAY
35233: PUSH
35234: LD_INT 1
35236: PLUS
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PPUSH
35242: LD_EXP 79
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: PUSH
35253: LD_INT 1
35255: ARRAY
35256: PPUSH
35257: CALL 53541 0 3
35261: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35262: LD_EXP 79
35266: PUSH
35267: LD_VAR 0 2
35271: ARRAY
35272: PUSH
35273: LD_INT 1
35275: ARRAY
35276: PPUSH
35277: LD_INT 112
35279: PPUSH
35280: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35284: LD_ADDR_VAR 0 9
35288: PUSH
35289: LD_EXP 79
35293: PUSH
35294: LD_VAR 0 2
35298: ARRAY
35299: PPUSH
35300: LD_INT 1
35302: PPUSH
35303: CALL_OW 3
35307: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35308: LD_ADDR_EXP 79
35312: PUSH
35313: LD_EXP 79
35317: PPUSH
35318: LD_VAR 0 2
35322: PPUSH
35323: LD_VAR 0 9
35327: PPUSH
35328: CALL_OW 1
35332: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35333: LD_EXP 79
35337: PUSH
35338: LD_VAR 0 2
35342: ARRAY
35343: PUSH
35344: LD_EXP 80
35348: PUSH
35349: LD_VAR 0 2
35353: ARRAY
35354: AND
35355: PUSH
35356: LD_EXP 80
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 1
35369: ARRAY
35370: PPUSH
35371: CALL_OW 310
35375: NOT
35376: AND
35377: PUSH
35378: LD_VAR 0 3
35382: PPUSH
35383: CALL_OW 313
35387: PUSH
35388: LD_INT 6
35390: EQUAL
35391: AND
35392: IFFALSE 35448
// begin tmp2 := UnitsInside ( j ) ;
35394: LD_ADDR_VAR 0 9
35398: PUSH
35399: LD_VAR 0 3
35403: PPUSH
35404: CALL_OW 313
35408: ST_TO_ADDR
// if tmp2 = 6 then
35409: LD_VAR 0 9
35413: PUSH
35414: LD_INT 6
35416: EQUAL
35417: IFFALSE 35448
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35419: LD_VAR 0 9
35423: PUSH
35424: LD_INT 1
35426: ARRAY
35427: PPUSH
35428: LD_INT 112
35430: PPUSH
35431: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35435: LD_VAR 0 9
35439: PUSH
35440: LD_INT 1
35442: ARRAY
35443: PPUSH
35444: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35448: LD_EXP 80
35452: PUSH
35453: LD_VAR 0 2
35457: ARRAY
35458: PUSH
35459: LD_EXP 80
35463: PUSH
35464: LD_VAR 0 2
35468: ARRAY
35469: PUSH
35470: LD_INT 1
35472: ARRAY
35473: PPUSH
35474: CALL_OW 314
35478: NOT
35479: AND
35480: PUSH
35481: LD_EXP 80
35485: PUSH
35486: LD_VAR 0 2
35490: ARRAY
35491: PUSH
35492: LD_INT 1
35494: ARRAY
35495: PPUSH
35496: CALL_OW 310
35500: NOT
35501: AND
35502: IFFALSE 35528
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35504: LD_EXP 80
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PPUSH
35519: LD_VAR 0 3
35523: PPUSH
35524: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35528: LD_EXP 80
35532: PUSH
35533: LD_VAR 0 2
35537: ARRAY
35538: PUSH
35539: LD_INT 1
35541: ARRAY
35542: PPUSH
35543: CALL_OW 310
35547: PUSH
35548: LD_EXP 80
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: PUSH
35559: LD_INT 1
35561: ARRAY
35562: PPUSH
35563: CALL_OW 310
35567: PPUSH
35568: CALL_OW 461
35572: PUSH
35573: LD_INT 3
35575: NONEQUAL
35576: AND
35577: IFFALSE 35598
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35579: LD_EXP 80
35583: PUSH
35584: LD_VAR 0 2
35588: ARRAY
35589: PUSH
35590: LD_INT 1
35592: ARRAY
35593: PPUSH
35594: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35598: LD_VAR 0 3
35602: PPUSH
35603: CALL_OW 461
35607: PUSH
35608: LD_INT 6
35610: EQUAL
35611: PUSH
35612: LD_VAR 0 6
35616: PUSH
35617: LD_INT 1
35619: GREATER
35620: AND
35621: IFFALSE 35773
// begin sci := [ ] ;
35623: LD_ADDR_VAR 0 8
35627: PUSH
35628: EMPTY
35629: ST_TO_ADDR
// for x in ( tmp diff j ) do
35630: LD_ADDR_VAR 0 7
35634: PUSH
35635: LD_VAR 0 6
35639: PUSH
35640: LD_VAR 0 3
35644: DIFF
35645: PUSH
35646: FOR_IN
35647: IFFALSE 35699
// begin if sci = 6 then
35649: LD_VAR 0 8
35653: PUSH
35654: LD_INT 6
35656: EQUAL
35657: IFFALSE 35661
// break ;
35659: GO 35699
// if BuildingStatus ( x ) = bs_idle then
35661: LD_VAR 0 7
35665: PPUSH
35666: CALL_OW 461
35670: PUSH
35671: LD_INT 2
35673: EQUAL
35674: IFFALSE 35697
// sci := sci ^ UnitsInside ( x ) ;
35676: LD_ADDR_VAR 0 8
35680: PUSH
35681: LD_VAR 0 8
35685: PUSH
35686: LD_VAR 0 7
35690: PPUSH
35691: CALL_OW 313
35695: ADD
35696: ST_TO_ADDR
// end ;
35697: GO 35646
35699: POP
35700: POP
// if not sci then
35701: LD_VAR 0 8
35705: NOT
35706: IFFALSE 35710
// continue ;
35708: GO 34755
// for x in sci do
35710: LD_ADDR_VAR 0 7
35714: PUSH
35715: LD_VAR 0 8
35719: PUSH
35720: FOR_IN
35721: IFFALSE 35771
// if IsInUnit ( x ) and not HasTask ( x ) then
35723: LD_VAR 0 7
35727: PPUSH
35728: CALL_OW 310
35732: PUSH
35733: LD_VAR 0 7
35737: PPUSH
35738: CALL_OW 314
35742: NOT
35743: AND
35744: IFFALSE 35769
// begin ComExitBuilding ( x ) ;
35746: LD_VAR 0 7
35750: PPUSH
35751: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35755: LD_VAR 0 7
35759: PPUSH
35760: LD_VAR 0 3
35764: PPUSH
35765: CALL_OW 180
// end ;
35769: GO 35720
35771: POP
35772: POP
// end ; end ;
35773: GO 34755
35775: POP
35776: POP
// end ;
35777: GO 34709
35779: POP
35780: POP
// end ;
35781: LD_VAR 0 1
35785: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35786: LD_INT 0
35788: PPUSH
35789: PPUSH
// if not mc_bases then
35790: LD_EXP 50
35794: NOT
35795: IFFALSE 35799
// exit ;
35797: GO 35880
// for i = 1 to mc_bases do
35799: LD_ADDR_VAR 0 2
35803: PUSH
35804: DOUBLE
35805: LD_INT 1
35807: DEC
35808: ST_TO_ADDR
35809: LD_EXP 50
35813: PUSH
35814: FOR_TO
35815: IFFALSE 35878
// if mc_mines [ i ] and mc_miners [ i ] then
35817: LD_EXP 63
35821: PUSH
35822: LD_VAR 0 2
35826: ARRAY
35827: PUSH
35828: LD_EXP 64
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: AND
35839: IFFALSE 35876
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35841: LD_EXP 64
35845: PUSH
35846: LD_VAR 0 2
35850: ARRAY
35851: PUSH
35852: LD_INT 1
35854: ARRAY
35855: PPUSH
35856: CALL_OW 255
35860: PPUSH
35861: LD_EXP 63
35865: PUSH
35866: LD_VAR 0 2
35870: ARRAY
35871: PPUSH
35872: CALL 50494 0 2
35876: GO 35814
35878: POP
35879: POP
// end ;
35880: LD_VAR 0 1
35884: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35885: LD_INT 0
35887: PPUSH
35888: PPUSH
35889: PPUSH
35890: PPUSH
35891: PPUSH
35892: PPUSH
35893: PPUSH
35894: PPUSH
// if not mc_bases or not mc_parking then
35895: LD_EXP 50
35899: NOT
35900: PUSH
35901: LD_EXP 74
35905: NOT
35906: OR
35907: IFFALSE 35911
// exit ;
35909: GO 36621
// for i = 1 to mc_bases do
35911: LD_ADDR_VAR 0 2
35915: PUSH
35916: DOUBLE
35917: LD_INT 1
35919: DEC
35920: ST_TO_ADDR
35921: LD_EXP 50
35925: PUSH
35926: FOR_TO
35927: IFFALSE 36619
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35929: LD_EXP 50
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: NOT
35940: PUSH
35941: LD_EXP 74
35945: PUSH
35946: LD_VAR 0 2
35950: ARRAY
35951: NOT
35952: OR
35953: IFFALSE 35957
// continue ;
35955: GO 35926
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35957: LD_ADDR_VAR 0 5
35961: PUSH
35962: LD_EXP 50
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 1
35975: ARRAY
35976: PPUSH
35977: CALL_OW 255
35981: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35982: LD_ADDR_VAR 0 6
35986: PUSH
35987: LD_EXP 50
35991: PUSH
35992: LD_VAR 0 2
35996: ARRAY
35997: PPUSH
35998: LD_INT 30
36000: PUSH
36001: LD_INT 3
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PPUSH
36008: CALL_OW 72
36012: ST_TO_ADDR
// if not fac then
36013: LD_VAR 0 6
36017: NOT
36018: IFFALSE 36069
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36020: LD_ADDR_VAR 0 6
36024: PUSH
36025: LD_EXP 50
36029: PUSH
36030: LD_VAR 0 2
36034: ARRAY
36035: PPUSH
36036: LD_INT 2
36038: PUSH
36039: LD_INT 30
36041: PUSH
36042: LD_INT 0
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 30
36051: PUSH
36052: LD_INT 1
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: LIST
36063: PPUSH
36064: CALL_OW 72
36068: ST_TO_ADDR
// if not fac then
36069: LD_VAR 0 6
36073: NOT
36074: IFFALSE 36078
// continue ;
36076: GO 35926
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36078: LD_ADDR_VAR 0 7
36082: PUSH
36083: LD_EXP 74
36087: PUSH
36088: LD_VAR 0 2
36092: ARRAY
36093: PPUSH
36094: LD_INT 22
36096: PUSH
36097: LD_VAR 0 5
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 21
36108: PUSH
36109: LD_INT 2
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 3
36118: PUSH
36119: LD_INT 24
36121: PUSH
36122: LD_INT 1000
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: EMPTY
36134: LIST
36135: LIST
36136: LIST
36137: PPUSH
36138: CALL_OW 70
36142: ST_TO_ADDR
// for j in fac do
36143: LD_ADDR_VAR 0 3
36147: PUSH
36148: LD_VAR 0 6
36152: PUSH
36153: FOR_IN
36154: IFFALSE 36235
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36156: LD_ADDR_VAR 0 7
36160: PUSH
36161: LD_VAR 0 7
36165: PUSH
36166: LD_INT 22
36168: PUSH
36169: LD_VAR 0 5
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 91
36180: PUSH
36181: LD_VAR 0 3
36185: PUSH
36186: LD_INT 15
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 21
36196: PUSH
36197: LD_INT 2
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 3
36206: PUSH
36207: LD_INT 24
36209: PUSH
36210: LD_INT 1000
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: PPUSH
36227: CALL_OW 69
36231: UNION
36232: ST_TO_ADDR
36233: GO 36153
36235: POP
36236: POP
// if not vehs then
36237: LD_VAR 0 7
36241: NOT
36242: IFFALSE 36268
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36244: LD_ADDR_EXP 62
36248: PUSH
36249: LD_EXP 62
36253: PPUSH
36254: LD_VAR 0 2
36258: PPUSH
36259: EMPTY
36260: PPUSH
36261: CALL_OW 1
36265: ST_TO_ADDR
// continue ;
36266: GO 35926
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36268: LD_ADDR_VAR 0 8
36272: PUSH
36273: LD_EXP 50
36277: PUSH
36278: LD_VAR 0 2
36282: ARRAY
36283: PPUSH
36284: LD_INT 30
36286: PUSH
36287: LD_INT 3
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PPUSH
36294: CALL_OW 72
36298: ST_TO_ADDR
// if tmp then
36299: LD_VAR 0 8
36303: IFFALSE 36406
// begin for j in tmp do
36305: LD_ADDR_VAR 0 3
36309: PUSH
36310: LD_VAR 0 8
36314: PUSH
36315: FOR_IN
36316: IFFALSE 36404
// for k in UnitsInside ( j ) do
36318: LD_ADDR_VAR 0 4
36322: PUSH
36323: LD_VAR 0 3
36327: PPUSH
36328: CALL_OW 313
36332: PUSH
36333: FOR_IN
36334: IFFALSE 36400
// if k then
36336: LD_VAR 0 4
36340: IFFALSE 36398
// if not k in mc_repair_vehicle [ i ] then
36342: LD_VAR 0 4
36346: PUSH
36347: LD_EXP 62
36351: PUSH
36352: LD_VAR 0 2
36356: ARRAY
36357: IN
36358: NOT
36359: IFFALSE 36398
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36361: LD_ADDR_EXP 62
36365: PUSH
36366: LD_EXP 62
36370: PPUSH
36371: LD_VAR 0 2
36375: PPUSH
36376: LD_EXP 62
36380: PUSH
36381: LD_VAR 0 2
36385: ARRAY
36386: PUSH
36387: LD_VAR 0 4
36391: UNION
36392: PPUSH
36393: CALL_OW 1
36397: ST_TO_ADDR
36398: GO 36333
36400: POP
36401: POP
36402: GO 36315
36404: POP
36405: POP
// end ; if not mc_repair_vehicle [ i ] then
36406: LD_EXP 62
36410: PUSH
36411: LD_VAR 0 2
36415: ARRAY
36416: NOT
36417: IFFALSE 36421
// continue ;
36419: GO 35926
// for j in mc_repair_vehicle [ i ] do
36421: LD_ADDR_VAR 0 3
36425: PUSH
36426: LD_EXP 62
36430: PUSH
36431: LD_VAR 0 2
36435: ARRAY
36436: PUSH
36437: FOR_IN
36438: IFFALSE 36615
// begin if GetClass ( j ) <> 3 then
36440: LD_VAR 0 3
36444: PPUSH
36445: CALL_OW 257
36449: PUSH
36450: LD_INT 3
36452: NONEQUAL
36453: IFFALSE 36494
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36455: LD_ADDR_EXP 62
36459: PUSH
36460: LD_EXP 62
36464: PPUSH
36465: LD_VAR 0 2
36469: PPUSH
36470: LD_EXP 62
36474: PUSH
36475: LD_VAR 0 2
36479: ARRAY
36480: PUSH
36481: LD_VAR 0 3
36485: DIFF
36486: PPUSH
36487: CALL_OW 1
36491: ST_TO_ADDR
// continue ;
36492: GO 36437
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36494: LD_VAR 0 3
36498: PPUSH
36499: CALL_OW 311
36503: NOT
36504: PUSH
36505: LD_VAR 0 3
36509: PUSH
36510: LD_EXP 53
36514: PUSH
36515: LD_VAR 0 2
36519: ARRAY
36520: PUSH
36521: LD_INT 1
36523: ARRAY
36524: IN
36525: NOT
36526: AND
36527: PUSH
36528: LD_VAR 0 3
36532: PUSH
36533: LD_EXP 53
36537: PUSH
36538: LD_VAR 0 2
36542: ARRAY
36543: PUSH
36544: LD_INT 2
36546: ARRAY
36547: IN
36548: NOT
36549: AND
36550: IFFALSE 36613
// begin if IsInUnit ( j ) then
36552: LD_VAR 0 3
36556: PPUSH
36557: CALL_OW 310
36561: IFFALSE 36574
// ComExitBuilding ( j ) else
36563: LD_VAR 0 3
36567: PPUSH
36568: CALL_OW 122
36572: GO 36613
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36574: LD_VAR 0 3
36578: PPUSH
36579: LD_VAR 0 7
36583: PUSH
36584: LD_INT 1
36586: ARRAY
36587: PPUSH
36588: CALL 87148 0 2
36592: NOT
36593: IFFALSE 36613
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36595: LD_VAR 0 3
36599: PPUSH
36600: LD_VAR 0 7
36604: PUSH
36605: LD_INT 1
36607: ARRAY
36608: PPUSH
36609: CALL_OW 129
// end ; end ;
36613: GO 36437
36615: POP
36616: POP
// end ;
36617: GO 35926
36619: POP
36620: POP
// end ;
36621: LD_VAR 0 1
36625: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36626: LD_INT 0
36628: PPUSH
36629: PPUSH
36630: PPUSH
36631: PPUSH
36632: PPUSH
36633: PPUSH
36634: PPUSH
36635: PPUSH
36636: PPUSH
36637: PPUSH
36638: PPUSH
// if not mc_bases then
36639: LD_EXP 50
36643: NOT
36644: IFFALSE 36648
// exit ;
36646: GO 37450
// for i = 1 to mc_bases do
36648: LD_ADDR_VAR 0 2
36652: PUSH
36653: DOUBLE
36654: LD_INT 1
36656: DEC
36657: ST_TO_ADDR
36658: LD_EXP 50
36662: PUSH
36663: FOR_TO
36664: IFFALSE 37448
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36666: LD_EXP 78
36670: PUSH
36671: LD_VAR 0 2
36675: ARRAY
36676: NOT
36677: PUSH
36678: LD_EXP 53
36682: PUSH
36683: LD_VAR 0 2
36687: ARRAY
36688: PUSH
36689: LD_INT 1
36691: ARRAY
36692: OR
36693: PUSH
36694: LD_EXP 53
36698: PUSH
36699: LD_VAR 0 2
36703: ARRAY
36704: PUSH
36705: LD_INT 2
36707: ARRAY
36708: OR
36709: PUSH
36710: LD_EXP 76
36714: PUSH
36715: LD_VAR 0 2
36719: ARRAY
36720: PPUSH
36721: LD_INT 1
36723: PPUSH
36724: CALL_OW 325
36728: NOT
36729: OR
36730: PUSH
36731: LD_EXP 73
36735: PUSH
36736: LD_VAR 0 2
36740: ARRAY
36741: OR
36742: IFFALSE 36746
// continue ;
36744: GO 36663
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36746: LD_ADDR_VAR 0 8
36750: PUSH
36751: LD_EXP 50
36755: PUSH
36756: LD_VAR 0 2
36760: ARRAY
36761: PPUSH
36762: LD_INT 25
36764: PUSH
36765: LD_INT 4
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 50
36774: PUSH
36775: EMPTY
36776: LIST
36777: PUSH
36778: LD_INT 3
36780: PUSH
36781: LD_INT 60
36783: PUSH
36784: EMPTY
36785: LIST
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: LIST
36795: PPUSH
36796: CALL_OW 72
36800: PUSH
36801: LD_EXP 54
36805: PUSH
36806: LD_VAR 0 2
36810: ARRAY
36811: DIFF
36812: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36813: LD_ADDR_VAR 0 9
36817: PUSH
36818: LD_EXP 50
36822: PUSH
36823: LD_VAR 0 2
36827: ARRAY
36828: PPUSH
36829: LD_INT 2
36831: PUSH
36832: LD_INT 30
36834: PUSH
36835: LD_INT 0
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 30
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: LIST
36856: PPUSH
36857: CALL_OW 72
36861: ST_TO_ADDR
// if not tmp or not dep then
36862: LD_VAR 0 8
36866: NOT
36867: PUSH
36868: LD_VAR 0 9
36872: NOT
36873: OR
36874: IFFALSE 36878
// continue ;
36876: GO 36663
// side := GetSide ( tmp [ 1 ] ) ;
36878: LD_ADDR_VAR 0 11
36882: PUSH
36883: LD_VAR 0 8
36887: PUSH
36888: LD_INT 1
36890: ARRAY
36891: PPUSH
36892: CALL_OW 255
36896: ST_TO_ADDR
// dep := dep [ 1 ] ;
36897: LD_ADDR_VAR 0 9
36901: PUSH
36902: LD_VAR 0 9
36906: PUSH
36907: LD_INT 1
36909: ARRAY
36910: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36911: LD_ADDR_VAR 0 7
36915: PUSH
36916: LD_EXP 78
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: PPUSH
36927: LD_INT 22
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 25
36939: PUSH
36940: LD_INT 12
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PPUSH
36951: CALL_OW 70
36955: PUSH
36956: LD_INT 22
36958: PUSH
36959: LD_INT 0
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 25
36968: PUSH
36969: LD_INT 12
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 91
36978: PUSH
36979: LD_VAR 0 9
36983: PUSH
36984: LD_INT 20
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: LIST
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: LIST
36996: PPUSH
36997: CALL_OW 69
37001: UNION
37002: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37003: LD_ADDR_VAR 0 10
37007: PUSH
37008: LD_EXP 78
37012: PUSH
37013: LD_VAR 0 2
37017: ARRAY
37018: PPUSH
37019: LD_INT 81
37021: PUSH
37022: LD_VAR 0 11
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PPUSH
37031: CALL_OW 70
37035: ST_TO_ADDR
// if not apes or danger_at_area then
37036: LD_VAR 0 7
37040: NOT
37041: PUSH
37042: LD_VAR 0 10
37046: OR
37047: IFFALSE 37097
// begin if mc_taming [ i ] then
37049: LD_EXP 81
37053: PUSH
37054: LD_VAR 0 2
37058: ARRAY
37059: IFFALSE 37095
// begin MC_Reset ( i , 121 ) ;
37061: LD_VAR 0 2
37065: PPUSH
37066: LD_INT 121
37068: PPUSH
37069: CALL 22083 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37073: LD_ADDR_EXP 81
37077: PUSH
37078: LD_EXP 81
37082: PPUSH
37083: LD_VAR 0 2
37087: PPUSH
37088: EMPTY
37089: PPUSH
37090: CALL_OW 1
37094: ST_TO_ADDR
// end ; continue ;
37095: GO 36663
// end ; for j in tmp do
37097: LD_ADDR_VAR 0 3
37101: PUSH
37102: LD_VAR 0 8
37106: PUSH
37107: FOR_IN
37108: IFFALSE 37444
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37110: LD_VAR 0 3
37114: PUSH
37115: LD_EXP 81
37119: PUSH
37120: LD_VAR 0 2
37124: ARRAY
37125: IN
37126: NOT
37127: PUSH
37128: LD_EXP 81
37132: PUSH
37133: LD_VAR 0 2
37137: ARRAY
37138: PUSH
37139: LD_INT 3
37141: LESS
37142: AND
37143: IFFALSE 37201
// begin SetTag ( j , 121 ) ;
37145: LD_VAR 0 3
37149: PPUSH
37150: LD_INT 121
37152: PPUSH
37153: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37157: LD_ADDR_EXP 81
37161: PUSH
37162: LD_EXP 81
37166: PPUSH
37167: LD_VAR 0 2
37171: PUSH
37172: LD_EXP 81
37176: PUSH
37177: LD_VAR 0 2
37181: ARRAY
37182: PUSH
37183: LD_INT 1
37185: PLUS
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PPUSH
37191: LD_VAR 0 3
37195: PPUSH
37196: CALL 53541 0 3
37200: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37201: LD_VAR 0 3
37205: PUSH
37206: LD_EXP 81
37210: PUSH
37211: LD_VAR 0 2
37215: ARRAY
37216: IN
37217: IFFALSE 37442
// begin if GetClass ( j ) <> 4 then
37219: LD_VAR 0 3
37223: PPUSH
37224: CALL_OW 257
37228: PUSH
37229: LD_INT 4
37231: NONEQUAL
37232: IFFALSE 37285
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37234: LD_ADDR_EXP 81
37238: PUSH
37239: LD_EXP 81
37243: PPUSH
37244: LD_VAR 0 2
37248: PPUSH
37249: LD_EXP 81
37253: PUSH
37254: LD_VAR 0 2
37258: ARRAY
37259: PUSH
37260: LD_VAR 0 3
37264: DIFF
37265: PPUSH
37266: CALL_OW 1
37270: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37271: LD_VAR 0 3
37275: PPUSH
37276: LD_INT 0
37278: PPUSH
37279: CALL_OW 109
// continue ;
37283: GO 37107
// end ; if IsInUnit ( j ) then
37285: LD_VAR 0 3
37289: PPUSH
37290: CALL_OW 310
37294: IFFALSE 37305
// ComExitBuilding ( j ) ;
37296: LD_VAR 0 3
37300: PPUSH
37301: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37305: LD_ADDR_VAR 0 6
37309: PUSH
37310: LD_VAR 0 7
37314: PPUSH
37315: LD_VAR 0 3
37319: PPUSH
37320: CALL_OW 74
37324: ST_TO_ADDR
// if not ape then
37325: LD_VAR 0 6
37329: NOT
37330: IFFALSE 37334
// break ;
37332: GO 37444
// x := GetX ( ape ) ;
37334: LD_ADDR_VAR 0 4
37338: PUSH
37339: LD_VAR 0 6
37343: PPUSH
37344: CALL_OW 250
37348: ST_TO_ADDR
// y := GetY ( ape ) ;
37349: LD_ADDR_VAR 0 5
37353: PUSH
37354: LD_VAR 0 6
37358: PPUSH
37359: CALL_OW 251
37363: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37364: LD_VAR 0 4
37368: PPUSH
37369: LD_VAR 0 5
37373: PPUSH
37374: CALL_OW 488
37378: NOT
37379: PUSH
37380: LD_VAR 0 11
37384: PPUSH
37385: LD_VAR 0 4
37389: PPUSH
37390: LD_VAR 0 5
37394: PPUSH
37395: LD_INT 20
37397: PPUSH
37398: CALL 54437 0 4
37402: PUSH
37403: LD_INT 4
37405: ARRAY
37406: OR
37407: IFFALSE 37411
// break ;
37409: GO 37444
// if not HasTask ( j ) then
37411: LD_VAR 0 3
37415: PPUSH
37416: CALL_OW 314
37420: NOT
37421: IFFALSE 37442
// ComTameXY ( j , x , y ) ;
37423: LD_VAR 0 3
37427: PPUSH
37428: LD_VAR 0 4
37432: PPUSH
37433: LD_VAR 0 5
37437: PPUSH
37438: CALL_OW 131
// end ; end ;
37442: GO 37107
37444: POP
37445: POP
// end ;
37446: GO 36663
37448: POP
37449: POP
// end ;
37450: LD_VAR 0 1
37454: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37455: LD_INT 0
37457: PPUSH
37458: PPUSH
37459: PPUSH
37460: PPUSH
37461: PPUSH
37462: PPUSH
37463: PPUSH
37464: PPUSH
// if not mc_bases then
37465: LD_EXP 50
37469: NOT
37470: IFFALSE 37474
// exit ;
37472: GO 38100
// for i = 1 to mc_bases do
37474: LD_ADDR_VAR 0 2
37478: PUSH
37479: DOUBLE
37480: LD_INT 1
37482: DEC
37483: ST_TO_ADDR
37484: LD_EXP 50
37488: PUSH
37489: FOR_TO
37490: IFFALSE 38098
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37492: LD_EXP 79
37496: PUSH
37497: LD_VAR 0 2
37501: ARRAY
37502: NOT
37503: PUSH
37504: LD_EXP 79
37508: PUSH
37509: LD_VAR 0 2
37513: ARRAY
37514: PPUSH
37515: LD_INT 25
37517: PUSH
37518: LD_INT 12
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PPUSH
37525: CALL_OW 72
37529: NOT
37530: OR
37531: IFFALSE 37535
// continue ;
37533: GO 37489
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37535: LD_ADDR_VAR 0 5
37539: PUSH
37540: LD_EXP 79
37544: PUSH
37545: LD_VAR 0 2
37549: ARRAY
37550: PUSH
37551: LD_INT 1
37553: ARRAY
37554: PPUSH
37555: CALL_OW 255
37559: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37560: LD_VAR 0 5
37564: PPUSH
37565: LD_INT 2
37567: PPUSH
37568: CALL_OW 325
37572: IFFALSE 37825
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37574: LD_ADDR_VAR 0 4
37578: PUSH
37579: LD_EXP 79
37583: PUSH
37584: LD_VAR 0 2
37588: ARRAY
37589: PPUSH
37590: LD_INT 25
37592: PUSH
37593: LD_INT 16
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PPUSH
37600: CALL_OW 72
37604: ST_TO_ADDR
// if tmp < 6 then
37605: LD_VAR 0 4
37609: PUSH
37610: LD_INT 6
37612: LESS
37613: IFFALSE 37825
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37615: LD_ADDR_VAR 0 6
37619: PUSH
37620: LD_EXP 50
37624: PUSH
37625: LD_VAR 0 2
37629: ARRAY
37630: PPUSH
37631: LD_INT 2
37633: PUSH
37634: LD_INT 30
37636: PUSH
37637: LD_INT 0
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 30
37646: PUSH
37647: LD_INT 1
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: LIST
37658: PPUSH
37659: CALL_OW 72
37663: ST_TO_ADDR
// if depot then
37664: LD_VAR 0 6
37668: IFFALSE 37825
// begin selected := 0 ;
37670: LD_ADDR_VAR 0 7
37674: PUSH
37675: LD_INT 0
37677: ST_TO_ADDR
// for j in depot do
37678: LD_ADDR_VAR 0 3
37682: PUSH
37683: LD_VAR 0 6
37687: PUSH
37688: FOR_IN
37689: IFFALSE 37720
// begin if UnitsInside ( j ) < 6 then
37691: LD_VAR 0 3
37695: PPUSH
37696: CALL_OW 313
37700: PUSH
37701: LD_INT 6
37703: LESS
37704: IFFALSE 37718
// begin selected := j ;
37706: LD_ADDR_VAR 0 7
37710: PUSH
37711: LD_VAR 0 3
37715: ST_TO_ADDR
// break ;
37716: GO 37720
// end ; end ;
37718: GO 37688
37720: POP
37721: POP
// if selected then
37722: LD_VAR 0 7
37726: IFFALSE 37825
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37728: LD_ADDR_VAR 0 3
37732: PUSH
37733: LD_EXP 79
37737: PUSH
37738: LD_VAR 0 2
37742: ARRAY
37743: PPUSH
37744: LD_INT 25
37746: PUSH
37747: LD_INT 12
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PPUSH
37754: CALL_OW 72
37758: PUSH
37759: FOR_IN
37760: IFFALSE 37823
// if not HasTask ( j ) then
37762: LD_VAR 0 3
37766: PPUSH
37767: CALL_OW 314
37771: NOT
37772: IFFALSE 37821
// begin if not IsInUnit ( j ) then
37774: LD_VAR 0 3
37778: PPUSH
37779: CALL_OW 310
37783: NOT
37784: IFFALSE 37800
// ComEnterUnit ( j , selected ) ;
37786: LD_VAR 0 3
37790: PPUSH
37791: LD_VAR 0 7
37795: PPUSH
37796: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37800: LD_VAR 0 3
37804: PPUSH
37805: LD_INT 16
37807: PPUSH
37808: CALL_OW 183
// AddComExitBuilding ( j ) ;
37812: LD_VAR 0 3
37816: PPUSH
37817: CALL_OW 182
// end ;
37821: GO 37759
37823: POP
37824: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37825: LD_VAR 0 5
37829: PPUSH
37830: LD_INT 11
37832: PPUSH
37833: CALL_OW 325
37837: IFFALSE 38096
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37839: LD_ADDR_VAR 0 4
37843: PUSH
37844: LD_EXP 79
37848: PUSH
37849: LD_VAR 0 2
37853: ARRAY
37854: PPUSH
37855: LD_INT 25
37857: PUSH
37858: LD_INT 16
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PPUSH
37865: CALL_OW 72
37869: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37870: LD_VAR 0 4
37874: PUSH
37875: LD_INT 6
37877: GREATEREQUAL
37878: PUSH
37879: LD_VAR 0 5
37883: PPUSH
37884: LD_INT 2
37886: PPUSH
37887: CALL_OW 325
37891: NOT
37892: OR
37893: IFFALSE 38096
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_EXP 50
37904: PUSH
37905: LD_VAR 0 2
37909: ARRAY
37910: PPUSH
37911: LD_INT 2
37913: PUSH
37914: LD_INT 30
37916: PUSH
37917: LD_INT 4
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 30
37926: PUSH
37927: LD_INT 5
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: LIST
37938: PPUSH
37939: CALL_OW 72
37943: ST_TO_ADDR
// if barracks then
37944: LD_VAR 0 8
37948: IFFALSE 38096
// begin selected := 0 ;
37950: LD_ADDR_VAR 0 7
37954: PUSH
37955: LD_INT 0
37957: ST_TO_ADDR
// for j in barracks do
37958: LD_ADDR_VAR 0 3
37962: PUSH
37963: LD_VAR 0 8
37967: PUSH
37968: FOR_IN
37969: IFFALSE 38000
// begin if UnitsInside ( j ) < 6 then
37971: LD_VAR 0 3
37975: PPUSH
37976: CALL_OW 313
37980: PUSH
37981: LD_INT 6
37983: LESS
37984: IFFALSE 37998
// begin selected := j ;
37986: LD_ADDR_VAR 0 7
37990: PUSH
37991: LD_VAR 0 3
37995: ST_TO_ADDR
// break ;
37996: GO 38000
// end ; end ;
37998: GO 37968
38000: POP
38001: POP
// if selected then
38002: LD_VAR 0 7
38006: IFFALSE 38096
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38008: LD_ADDR_VAR 0 3
38012: PUSH
38013: LD_EXP 79
38017: PUSH
38018: LD_VAR 0 2
38022: ARRAY
38023: PPUSH
38024: LD_INT 25
38026: PUSH
38027: LD_INT 12
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PPUSH
38034: CALL_OW 72
38038: PUSH
38039: FOR_IN
38040: IFFALSE 38094
// if not IsInUnit ( j ) and not HasTask ( j ) then
38042: LD_VAR 0 3
38046: PPUSH
38047: CALL_OW 310
38051: NOT
38052: PUSH
38053: LD_VAR 0 3
38057: PPUSH
38058: CALL_OW 314
38062: NOT
38063: AND
38064: IFFALSE 38092
// begin ComEnterUnit ( j , selected ) ;
38066: LD_VAR 0 3
38070: PPUSH
38071: LD_VAR 0 7
38075: PPUSH
38076: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38080: LD_VAR 0 3
38084: PPUSH
38085: LD_INT 15
38087: PPUSH
38088: CALL_OW 183
// end ;
38092: GO 38039
38094: POP
38095: POP
// end ; end ; end ; end ; end ;
38096: GO 37489
38098: POP
38099: POP
// end ;
38100: LD_VAR 0 1
38104: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38105: LD_INT 0
38107: PPUSH
38108: PPUSH
38109: PPUSH
38110: PPUSH
// if not mc_bases then
38111: LD_EXP 50
38115: NOT
38116: IFFALSE 38120
// exit ;
38118: GO 38298
// for i = 1 to mc_bases do
38120: LD_ADDR_VAR 0 2
38124: PUSH
38125: DOUBLE
38126: LD_INT 1
38128: DEC
38129: ST_TO_ADDR
38130: LD_EXP 50
38134: PUSH
38135: FOR_TO
38136: IFFALSE 38296
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38138: LD_ADDR_VAR 0 4
38142: PUSH
38143: LD_EXP 50
38147: PUSH
38148: LD_VAR 0 2
38152: ARRAY
38153: PPUSH
38154: LD_INT 25
38156: PUSH
38157: LD_INT 9
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PPUSH
38164: CALL_OW 72
38168: ST_TO_ADDR
// if not tmp then
38169: LD_VAR 0 4
38173: NOT
38174: IFFALSE 38178
// continue ;
38176: GO 38135
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38178: LD_EXP 76
38182: PUSH
38183: LD_VAR 0 2
38187: ARRAY
38188: PPUSH
38189: LD_INT 29
38191: PPUSH
38192: CALL_OW 325
38196: NOT
38197: PUSH
38198: LD_EXP 76
38202: PUSH
38203: LD_VAR 0 2
38207: ARRAY
38208: PPUSH
38209: LD_INT 28
38211: PPUSH
38212: CALL_OW 325
38216: NOT
38217: AND
38218: IFFALSE 38222
// continue ;
38220: GO 38135
// for j in tmp do
38222: LD_ADDR_VAR 0 3
38226: PUSH
38227: LD_VAR 0 4
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38292
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38235: LD_VAR 0 3
38239: PUSH
38240: LD_EXP 53
38244: PUSH
38245: LD_VAR 0 2
38249: ARRAY
38250: PUSH
38251: LD_INT 1
38253: ARRAY
38254: IN
38255: NOT
38256: PUSH
38257: LD_VAR 0 3
38261: PUSH
38262: LD_EXP 53
38266: PUSH
38267: LD_VAR 0 2
38271: ARRAY
38272: PUSH
38273: LD_INT 2
38275: ARRAY
38276: IN
38277: NOT
38278: AND
38279: IFFALSE 38290
// ComSpaceTimeShoot ( j ) ;
38281: LD_VAR 0 3
38285: PPUSH
38286: CALL 49502 0 1
38290: GO 38232
38292: POP
38293: POP
// end ;
38294: GO 38135
38296: POP
38297: POP
// end ;
38298: LD_VAR 0 1
38302: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38303: LD_INT 0
38305: PPUSH
38306: PPUSH
38307: PPUSH
38308: PPUSH
38309: PPUSH
38310: PPUSH
38311: PPUSH
38312: PPUSH
38313: PPUSH
// if not mc_bases then
38314: LD_EXP 50
38318: NOT
38319: IFFALSE 38323
// exit ;
38321: GO 38945
// for i = 1 to mc_bases do
38323: LD_ADDR_VAR 0 2
38327: PUSH
38328: DOUBLE
38329: LD_INT 1
38331: DEC
38332: ST_TO_ADDR
38333: LD_EXP 50
38337: PUSH
38338: FOR_TO
38339: IFFALSE 38943
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38341: LD_EXP 85
38345: PUSH
38346: LD_VAR 0 2
38350: ARRAY
38351: NOT
38352: PUSH
38353: LD_INT 38
38355: PPUSH
38356: LD_EXP 76
38360: PUSH
38361: LD_VAR 0 2
38365: ARRAY
38366: PPUSH
38367: CALL_OW 321
38371: PUSH
38372: LD_INT 2
38374: NONEQUAL
38375: OR
38376: IFFALSE 38380
// continue ;
38378: GO 38338
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38380: LD_ADDR_VAR 0 8
38384: PUSH
38385: LD_EXP 50
38389: PUSH
38390: LD_VAR 0 2
38394: ARRAY
38395: PPUSH
38396: LD_INT 30
38398: PUSH
38399: LD_INT 34
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PPUSH
38406: CALL_OW 72
38410: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38411: LD_ADDR_VAR 0 9
38415: PUSH
38416: LD_EXP 50
38420: PUSH
38421: LD_VAR 0 2
38425: ARRAY
38426: PPUSH
38427: LD_INT 25
38429: PUSH
38430: LD_INT 4
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PPUSH
38437: CALL_OW 72
38441: PPUSH
38442: LD_INT 0
38444: PPUSH
38445: CALL 82810 0 2
38449: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38450: LD_VAR 0 9
38454: NOT
38455: PUSH
38456: LD_VAR 0 8
38460: NOT
38461: OR
38462: PUSH
38463: LD_EXP 50
38467: PUSH
38468: LD_VAR 0 2
38472: ARRAY
38473: PPUSH
38474: LD_INT 124
38476: PPUSH
38477: CALL 82810 0 2
38481: OR
38482: IFFALSE 38486
// continue ;
38484: GO 38338
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38486: LD_EXP 86
38490: PUSH
38491: LD_VAR 0 2
38495: ARRAY
38496: PUSH
38497: LD_EXP 85
38501: PUSH
38502: LD_VAR 0 2
38506: ARRAY
38507: LESS
38508: PUSH
38509: LD_EXP 86
38513: PUSH
38514: LD_VAR 0 2
38518: ARRAY
38519: PUSH
38520: LD_VAR 0 8
38524: LESS
38525: AND
38526: IFFALSE 38941
// begin tmp := sci [ 1 ] ;
38528: LD_ADDR_VAR 0 7
38532: PUSH
38533: LD_VAR 0 9
38537: PUSH
38538: LD_INT 1
38540: ARRAY
38541: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38542: LD_VAR 0 7
38546: PPUSH
38547: LD_INT 124
38549: PPUSH
38550: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38554: LD_ADDR_VAR 0 3
38558: PUSH
38559: DOUBLE
38560: LD_EXP 85
38564: PUSH
38565: LD_VAR 0 2
38569: ARRAY
38570: INC
38571: ST_TO_ADDR
38572: LD_EXP 85
38576: PUSH
38577: LD_VAR 0 2
38581: ARRAY
38582: PUSH
38583: FOR_DOWNTO
38584: IFFALSE 38927
// begin if IsInUnit ( tmp ) then
38586: LD_VAR 0 7
38590: PPUSH
38591: CALL_OW 310
38595: IFFALSE 38606
// ComExitBuilding ( tmp ) ;
38597: LD_VAR 0 7
38601: PPUSH
38602: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38606: LD_INT 35
38608: PPUSH
38609: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38613: LD_VAR 0 7
38617: PPUSH
38618: CALL_OW 310
38622: NOT
38623: PUSH
38624: LD_VAR 0 7
38628: PPUSH
38629: CALL_OW 314
38633: NOT
38634: AND
38635: IFFALSE 38606
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38637: LD_ADDR_VAR 0 6
38641: PUSH
38642: LD_VAR 0 7
38646: PPUSH
38647: CALL_OW 250
38651: PUSH
38652: LD_VAR 0 7
38656: PPUSH
38657: CALL_OW 251
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38666: LD_INT 35
38668: PPUSH
38669: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38673: LD_ADDR_VAR 0 4
38677: PUSH
38678: LD_EXP 85
38682: PUSH
38683: LD_VAR 0 2
38687: ARRAY
38688: PUSH
38689: LD_VAR 0 3
38693: ARRAY
38694: PUSH
38695: LD_INT 1
38697: ARRAY
38698: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38699: LD_ADDR_VAR 0 5
38703: PUSH
38704: LD_EXP 85
38708: PUSH
38709: LD_VAR 0 2
38713: ARRAY
38714: PUSH
38715: LD_VAR 0 3
38719: ARRAY
38720: PUSH
38721: LD_INT 2
38723: ARRAY
38724: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38725: LD_VAR 0 7
38729: PPUSH
38730: LD_INT 10
38732: PPUSH
38733: CALL 56140 0 2
38737: PUSH
38738: LD_INT 4
38740: ARRAY
38741: IFFALSE 38779
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38743: LD_VAR 0 7
38747: PPUSH
38748: LD_VAR 0 6
38752: PUSH
38753: LD_INT 1
38755: ARRAY
38756: PPUSH
38757: LD_VAR 0 6
38761: PUSH
38762: LD_INT 2
38764: ARRAY
38765: PPUSH
38766: CALL_OW 111
// wait ( 0 0$10 ) ;
38770: LD_INT 350
38772: PPUSH
38773: CALL_OW 67
// end else
38777: GO 38805
// begin ComMoveXY ( tmp , x , y ) ;
38779: LD_VAR 0 7
38783: PPUSH
38784: LD_VAR 0 4
38788: PPUSH
38789: LD_VAR 0 5
38793: PPUSH
38794: CALL_OW 111
// wait ( 0 0$3 ) ;
38798: LD_INT 105
38800: PPUSH
38801: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38805: LD_VAR 0 7
38809: PPUSH
38810: LD_VAR 0 4
38814: PPUSH
38815: LD_VAR 0 5
38819: PPUSH
38820: CALL_OW 307
38824: IFFALSE 38666
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38826: LD_VAR 0 7
38830: PPUSH
38831: LD_VAR 0 4
38835: PPUSH
38836: LD_VAR 0 5
38840: PPUSH
38841: LD_VAR 0 8
38845: PUSH
38846: LD_VAR 0 3
38850: ARRAY
38851: PPUSH
38852: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38856: LD_INT 35
38858: PPUSH
38859: CALL_OW 67
// until not HasTask ( tmp ) ;
38863: LD_VAR 0 7
38867: PPUSH
38868: CALL_OW 314
38872: NOT
38873: IFFALSE 38856
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38875: LD_ADDR_EXP 86
38879: PUSH
38880: LD_EXP 86
38884: PPUSH
38885: LD_VAR 0 2
38889: PUSH
38890: LD_EXP 86
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 1
38903: PLUS
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PPUSH
38909: LD_VAR 0 8
38913: PUSH
38914: LD_VAR 0 3
38918: ARRAY
38919: PPUSH
38920: CALL 53541 0 3
38924: ST_TO_ADDR
// end ;
38925: GO 38583
38927: POP
38928: POP
// MC_Reset ( i , 124 ) ;
38929: LD_VAR 0 2
38933: PPUSH
38934: LD_INT 124
38936: PPUSH
38937: CALL 22083 0 2
// end ; end ;
38941: GO 38338
38943: POP
38944: POP
// end ;
38945: LD_VAR 0 1
38949: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38950: LD_INT 0
38952: PPUSH
38953: PPUSH
38954: PPUSH
// if not mc_bases then
38955: LD_EXP 50
38959: NOT
38960: IFFALSE 38964
// exit ;
38962: GO 39570
// for i = 1 to mc_bases do
38964: LD_ADDR_VAR 0 2
38968: PUSH
38969: DOUBLE
38970: LD_INT 1
38972: DEC
38973: ST_TO_ADDR
38974: LD_EXP 50
38978: PUSH
38979: FOR_TO
38980: IFFALSE 39568
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38982: LD_ADDR_VAR 0 3
38986: PUSH
38987: LD_EXP 50
38991: PUSH
38992: LD_VAR 0 2
38996: ARRAY
38997: PPUSH
38998: LD_INT 25
39000: PUSH
39001: LD_INT 4
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PPUSH
39008: CALL_OW 72
39012: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39013: LD_VAR 0 3
39017: NOT
39018: PUSH
39019: LD_EXP 87
39023: PUSH
39024: LD_VAR 0 2
39028: ARRAY
39029: NOT
39030: OR
39031: PUSH
39032: LD_EXP 50
39036: PUSH
39037: LD_VAR 0 2
39041: ARRAY
39042: PPUSH
39043: LD_INT 2
39045: PUSH
39046: LD_INT 30
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 30
39058: PUSH
39059: LD_INT 1
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: LIST
39070: PPUSH
39071: CALL_OW 72
39075: NOT
39076: OR
39077: IFFALSE 39127
// begin if mc_deposits_finder [ i ] then
39079: LD_EXP 88
39083: PUSH
39084: LD_VAR 0 2
39088: ARRAY
39089: IFFALSE 39125
// begin MC_Reset ( i , 125 ) ;
39091: LD_VAR 0 2
39095: PPUSH
39096: LD_INT 125
39098: PPUSH
39099: CALL 22083 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39103: LD_ADDR_EXP 88
39107: PUSH
39108: LD_EXP 88
39112: PPUSH
39113: LD_VAR 0 2
39117: PPUSH
39118: EMPTY
39119: PPUSH
39120: CALL_OW 1
39124: ST_TO_ADDR
// end ; continue ;
39125: GO 38979
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39127: LD_EXP 87
39131: PUSH
39132: LD_VAR 0 2
39136: ARRAY
39137: PUSH
39138: LD_INT 1
39140: ARRAY
39141: PUSH
39142: LD_INT 3
39144: ARRAY
39145: PUSH
39146: LD_INT 1
39148: EQUAL
39149: PUSH
39150: LD_INT 20
39152: PPUSH
39153: LD_EXP 76
39157: PUSH
39158: LD_VAR 0 2
39162: ARRAY
39163: PPUSH
39164: CALL_OW 321
39168: PUSH
39169: LD_INT 2
39171: NONEQUAL
39172: AND
39173: IFFALSE 39223
// begin if mc_deposits_finder [ i ] then
39175: LD_EXP 88
39179: PUSH
39180: LD_VAR 0 2
39184: ARRAY
39185: IFFALSE 39221
// begin MC_Reset ( i , 125 ) ;
39187: LD_VAR 0 2
39191: PPUSH
39192: LD_INT 125
39194: PPUSH
39195: CALL 22083 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39199: LD_ADDR_EXP 88
39203: PUSH
39204: LD_EXP 88
39208: PPUSH
39209: LD_VAR 0 2
39213: PPUSH
39214: EMPTY
39215: PPUSH
39216: CALL_OW 1
39220: ST_TO_ADDR
// end ; continue ;
39221: GO 38979
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39223: LD_EXP 87
39227: PUSH
39228: LD_VAR 0 2
39232: ARRAY
39233: PUSH
39234: LD_INT 1
39236: ARRAY
39237: PUSH
39238: LD_INT 1
39240: ARRAY
39241: PPUSH
39242: LD_EXP 87
39246: PUSH
39247: LD_VAR 0 2
39251: ARRAY
39252: PUSH
39253: LD_INT 1
39255: ARRAY
39256: PUSH
39257: LD_INT 2
39259: ARRAY
39260: PPUSH
39261: LD_EXP 76
39265: PUSH
39266: LD_VAR 0 2
39270: ARRAY
39271: PPUSH
39272: CALL_OW 440
39276: IFFALSE 39319
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39278: LD_ADDR_EXP 87
39282: PUSH
39283: LD_EXP 87
39287: PPUSH
39288: LD_VAR 0 2
39292: PPUSH
39293: LD_EXP 87
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: PPUSH
39304: LD_INT 1
39306: PPUSH
39307: CALL_OW 3
39311: PPUSH
39312: CALL_OW 1
39316: ST_TO_ADDR
39317: GO 39566
// begin if not mc_deposits_finder [ i ] then
39319: LD_EXP 88
39323: PUSH
39324: LD_VAR 0 2
39328: ARRAY
39329: NOT
39330: IFFALSE 39382
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39332: LD_ADDR_EXP 88
39336: PUSH
39337: LD_EXP 88
39341: PPUSH
39342: LD_VAR 0 2
39346: PPUSH
39347: LD_VAR 0 3
39351: PUSH
39352: LD_INT 1
39354: ARRAY
39355: PUSH
39356: EMPTY
39357: LIST
39358: PPUSH
39359: CALL_OW 1
39363: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39364: LD_VAR 0 3
39368: PUSH
39369: LD_INT 1
39371: ARRAY
39372: PPUSH
39373: LD_INT 125
39375: PPUSH
39376: CALL_OW 109
// end else
39380: GO 39566
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39382: LD_EXP 88
39386: PUSH
39387: LD_VAR 0 2
39391: ARRAY
39392: PUSH
39393: LD_INT 1
39395: ARRAY
39396: PPUSH
39397: CALL_OW 310
39401: IFFALSE 39424
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39403: LD_EXP 88
39407: PUSH
39408: LD_VAR 0 2
39412: ARRAY
39413: PUSH
39414: LD_INT 1
39416: ARRAY
39417: PPUSH
39418: CALL_OW 122
39422: GO 39566
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39424: LD_EXP 88
39428: PUSH
39429: LD_VAR 0 2
39433: ARRAY
39434: PUSH
39435: LD_INT 1
39437: ARRAY
39438: PPUSH
39439: CALL_OW 314
39443: NOT
39444: PUSH
39445: LD_EXP 88
39449: PUSH
39450: LD_VAR 0 2
39454: ARRAY
39455: PUSH
39456: LD_INT 1
39458: ARRAY
39459: PPUSH
39460: LD_EXP 87
39464: PUSH
39465: LD_VAR 0 2
39469: ARRAY
39470: PUSH
39471: LD_INT 1
39473: ARRAY
39474: PUSH
39475: LD_INT 1
39477: ARRAY
39478: PPUSH
39479: LD_EXP 87
39483: PUSH
39484: LD_VAR 0 2
39488: ARRAY
39489: PUSH
39490: LD_INT 1
39492: ARRAY
39493: PUSH
39494: LD_INT 2
39496: ARRAY
39497: PPUSH
39498: CALL_OW 297
39502: PUSH
39503: LD_INT 6
39505: GREATER
39506: AND
39507: IFFALSE 39566
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39509: LD_EXP 88
39513: PUSH
39514: LD_VAR 0 2
39518: ARRAY
39519: PUSH
39520: LD_INT 1
39522: ARRAY
39523: PPUSH
39524: LD_EXP 87
39528: PUSH
39529: LD_VAR 0 2
39533: ARRAY
39534: PUSH
39535: LD_INT 1
39537: ARRAY
39538: PUSH
39539: LD_INT 1
39541: ARRAY
39542: PPUSH
39543: LD_EXP 87
39547: PUSH
39548: LD_VAR 0 2
39552: ARRAY
39553: PUSH
39554: LD_INT 1
39556: ARRAY
39557: PUSH
39558: LD_INT 2
39560: ARRAY
39561: PPUSH
39562: CALL_OW 111
// end ; end ; end ;
39566: GO 38979
39568: POP
39569: POP
// end ;
39570: LD_VAR 0 1
39574: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39575: LD_INT 0
39577: PPUSH
39578: PPUSH
39579: PPUSH
39580: PPUSH
39581: PPUSH
39582: PPUSH
39583: PPUSH
39584: PPUSH
39585: PPUSH
39586: PPUSH
39587: PPUSH
// if not mc_bases then
39588: LD_EXP 50
39592: NOT
39593: IFFALSE 39597
// exit ;
39595: GO 40537
// for i = 1 to mc_bases do
39597: LD_ADDR_VAR 0 2
39601: PUSH
39602: DOUBLE
39603: LD_INT 1
39605: DEC
39606: ST_TO_ADDR
39607: LD_EXP 50
39611: PUSH
39612: FOR_TO
39613: IFFALSE 40535
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39615: LD_EXP 50
39619: PUSH
39620: LD_VAR 0 2
39624: ARRAY
39625: NOT
39626: PUSH
39627: LD_EXP 73
39631: PUSH
39632: LD_VAR 0 2
39636: ARRAY
39637: OR
39638: IFFALSE 39642
// continue ;
39640: GO 39612
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39642: LD_ADDR_VAR 0 7
39646: PUSH
39647: LD_EXP 50
39651: PUSH
39652: LD_VAR 0 2
39656: ARRAY
39657: PUSH
39658: LD_INT 1
39660: ARRAY
39661: PPUSH
39662: CALL_OW 248
39666: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39667: LD_VAR 0 7
39671: PUSH
39672: LD_INT 3
39674: EQUAL
39675: PUSH
39676: LD_EXP 69
39680: PUSH
39681: LD_VAR 0 2
39685: ARRAY
39686: PUSH
39687: LD_EXP 72
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: UNION
39698: PPUSH
39699: LD_INT 33
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PPUSH
39709: CALL_OW 72
39713: NOT
39714: OR
39715: IFFALSE 39719
// continue ;
39717: GO 39612
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39719: LD_ADDR_VAR 0 9
39723: PUSH
39724: LD_EXP 50
39728: PUSH
39729: LD_VAR 0 2
39733: ARRAY
39734: PPUSH
39735: LD_INT 30
39737: PUSH
39738: LD_INT 36
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PPUSH
39745: CALL_OW 72
39749: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39750: LD_ADDR_VAR 0 10
39754: PUSH
39755: LD_EXP 69
39759: PUSH
39760: LD_VAR 0 2
39764: ARRAY
39765: PPUSH
39766: LD_INT 34
39768: PUSH
39769: LD_INT 31
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PPUSH
39776: CALL_OW 72
39780: ST_TO_ADDR
// if not cts and not mcts then
39781: LD_VAR 0 9
39785: NOT
39786: PUSH
39787: LD_VAR 0 10
39791: NOT
39792: AND
39793: IFFALSE 39797
// continue ;
39795: GO 39612
// x := cts ;
39797: LD_ADDR_VAR 0 11
39801: PUSH
39802: LD_VAR 0 9
39806: ST_TO_ADDR
// if not x then
39807: LD_VAR 0 11
39811: NOT
39812: IFFALSE 39824
// x := mcts ;
39814: LD_ADDR_VAR 0 11
39818: PUSH
39819: LD_VAR 0 10
39823: ST_TO_ADDR
// if not x then
39824: LD_VAR 0 11
39828: NOT
39829: IFFALSE 39833
// continue ;
39831: GO 39612
// if mc_remote_driver [ i ] then
39833: LD_EXP 90
39837: PUSH
39838: LD_VAR 0 2
39842: ARRAY
39843: IFFALSE 40230
// for j in mc_remote_driver [ i ] do
39845: LD_ADDR_VAR 0 3
39849: PUSH
39850: LD_EXP 90
39854: PUSH
39855: LD_VAR 0 2
39859: ARRAY
39860: PUSH
39861: FOR_IN
39862: IFFALSE 40228
// begin if GetClass ( j ) <> 3 then
39864: LD_VAR 0 3
39868: PPUSH
39869: CALL_OW 257
39873: PUSH
39874: LD_INT 3
39876: NONEQUAL
39877: IFFALSE 39930
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39879: LD_ADDR_EXP 90
39883: PUSH
39884: LD_EXP 90
39888: PPUSH
39889: LD_VAR 0 2
39893: PPUSH
39894: LD_EXP 90
39898: PUSH
39899: LD_VAR 0 2
39903: ARRAY
39904: PUSH
39905: LD_VAR 0 3
39909: DIFF
39910: PPUSH
39911: CALL_OW 1
39915: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39916: LD_VAR 0 3
39920: PPUSH
39921: LD_INT 0
39923: PPUSH
39924: CALL_OW 109
// continue ;
39928: GO 39861
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39930: LD_EXP 69
39934: PUSH
39935: LD_VAR 0 2
39939: ARRAY
39940: PPUSH
39941: LD_INT 34
39943: PUSH
39944: LD_INT 31
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 58
39953: PUSH
39954: EMPTY
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PPUSH
39961: CALL_OW 72
39965: PUSH
39966: LD_VAR 0 3
39970: PPUSH
39971: CALL 82898 0 1
39975: NOT
39976: AND
39977: IFFALSE 40048
// begin if IsInUnit ( j ) then
39979: LD_VAR 0 3
39983: PPUSH
39984: CALL_OW 310
39988: IFFALSE 39999
// ComExitBuilding ( j ) ;
39990: LD_VAR 0 3
39994: PPUSH
39995: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39999: LD_VAR 0 3
40003: PPUSH
40004: LD_EXP 69
40008: PUSH
40009: LD_VAR 0 2
40013: ARRAY
40014: PPUSH
40015: LD_INT 34
40017: PUSH
40018: LD_INT 31
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 58
40027: PUSH
40028: EMPTY
40029: LIST
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PPUSH
40035: CALL_OW 72
40039: PUSH
40040: LD_INT 1
40042: ARRAY
40043: PPUSH
40044: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40048: LD_VAR 0 3
40052: PPUSH
40053: CALL_OW 310
40057: NOT
40058: PUSH
40059: LD_VAR 0 3
40063: PPUSH
40064: CALL_OW 310
40068: PPUSH
40069: CALL_OW 266
40073: PUSH
40074: LD_INT 36
40076: NONEQUAL
40077: PUSH
40078: LD_VAR 0 3
40082: PPUSH
40083: CALL 82898 0 1
40087: NOT
40088: AND
40089: OR
40090: IFFALSE 40226
// begin if IsInUnit ( j ) then
40092: LD_VAR 0 3
40096: PPUSH
40097: CALL_OW 310
40101: IFFALSE 40112
// ComExitBuilding ( j ) ;
40103: LD_VAR 0 3
40107: PPUSH
40108: CALL_OW 122
// ct := 0 ;
40112: LD_ADDR_VAR 0 8
40116: PUSH
40117: LD_INT 0
40119: ST_TO_ADDR
// for k in x do
40120: LD_ADDR_VAR 0 4
40124: PUSH
40125: LD_VAR 0 11
40129: PUSH
40130: FOR_IN
40131: IFFALSE 40204
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40133: LD_VAR 0 4
40137: PPUSH
40138: CALL_OW 264
40142: PUSH
40143: LD_INT 31
40145: EQUAL
40146: PUSH
40147: LD_VAR 0 4
40151: PPUSH
40152: CALL_OW 311
40156: NOT
40157: AND
40158: PUSH
40159: LD_VAR 0 4
40163: PPUSH
40164: CALL_OW 266
40168: PUSH
40169: LD_INT 36
40171: EQUAL
40172: PUSH
40173: LD_VAR 0 4
40177: PPUSH
40178: CALL_OW 313
40182: PUSH
40183: LD_INT 3
40185: LESS
40186: AND
40187: OR
40188: IFFALSE 40202
// begin ct := k ;
40190: LD_ADDR_VAR 0 8
40194: PUSH
40195: LD_VAR 0 4
40199: ST_TO_ADDR
// break ;
40200: GO 40204
// end ;
40202: GO 40130
40204: POP
40205: POP
// if ct then
40206: LD_VAR 0 8
40210: IFFALSE 40226
// ComEnterUnit ( j , ct ) ;
40212: LD_VAR 0 3
40216: PPUSH
40217: LD_VAR 0 8
40221: PPUSH
40222: CALL_OW 120
// end ; end ;
40226: GO 39861
40228: POP
40229: POP
// places := 0 ;
40230: LD_ADDR_VAR 0 5
40234: PUSH
40235: LD_INT 0
40237: ST_TO_ADDR
// for j = 1 to x do
40238: LD_ADDR_VAR 0 3
40242: PUSH
40243: DOUBLE
40244: LD_INT 1
40246: DEC
40247: ST_TO_ADDR
40248: LD_VAR 0 11
40252: PUSH
40253: FOR_TO
40254: IFFALSE 40330
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40256: LD_VAR 0 11
40260: PUSH
40261: LD_VAR 0 3
40265: ARRAY
40266: PPUSH
40267: CALL_OW 264
40271: PUSH
40272: LD_INT 31
40274: EQUAL
40275: IFFALSE 40293
// places := places + 1 else
40277: LD_ADDR_VAR 0 5
40281: PUSH
40282: LD_VAR 0 5
40286: PUSH
40287: LD_INT 1
40289: PLUS
40290: ST_TO_ADDR
40291: GO 40328
// if GetBType ( x [ j ] ) = b_control_tower then
40293: LD_VAR 0 11
40297: PUSH
40298: LD_VAR 0 3
40302: ARRAY
40303: PPUSH
40304: CALL_OW 266
40308: PUSH
40309: LD_INT 36
40311: EQUAL
40312: IFFALSE 40328
// places := places + 3 ;
40314: LD_ADDR_VAR 0 5
40318: PUSH
40319: LD_VAR 0 5
40323: PUSH
40324: LD_INT 3
40326: PLUS
40327: ST_TO_ADDR
40328: GO 40253
40330: POP
40331: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40332: LD_VAR 0 5
40336: PUSH
40337: LD_INT 0
40339: EQUAL
40340: PUSH
40341: LD_VAR 0 5
40345: PUSH
40346: LD_EXP 90
40350: PUSH
40351: LD_VAR 0 2
40355: ARRAY
40356: LESSEQUAL
40357: OR
40358: IFFALSE 40362
// continue ;
40360: GO 39612
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40362: LD_ADDR_VAR 0 6
40366: PUSH
40367: LD_EXP 50
40371: PUSH
40372: LD_VAR 0 2
40376: ARRAY
40377: PPUSH
40378: LD_INT 25
40380: PUSH
40381: LD_INT 3
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PPUSH
40388: CALL_OW 72
40392: PUSH
40393: LD_EXP 90
40397: PUSH
40398: LD_VAR 0 2
40402: ARRAY
40403: DIFF
40404: PPUSH
40405: LD_INT 3
40407: PPUSH
40408: CALL 83798 0 2
40412: ST_TO_ADDR
// for j in tmp do
40413: LD_ADDR_VAR 0 3
40417: PUSH
40418: LD_VAR 0 6
40422: PUSH
40423: FOR_IN
40424: IFFALSE 40459
// if GetTag ( j ) > 0 then
40426: LD_VAR 0 3
40430: PPUSH
40431: CALL_OW 110
40435: PUSH
40436: LD_INT 0
40438: GREATER
40439: IFFALSE 40457
// tmp := tmp diff j ;
40441: LD_ADDR_VAR 0 6
40445: PUSH
40446: LD_VAR 0 6
40450: PUSH
40451: LD_VAR 0 3
40455: DIFF
40456: ST_TO_ADDR
40457: GO 40423
40459: POP
40460: POP
// if not tmp then
40461: LD_VAR 0 6
40465: NOT
40466: IFFALSE 40470
// continue ;
40468: GO 39612
// if places then
40470: LD_VAR 0 5
40474: IFFALSE 40533
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40476: LD_ADDR_EXP 90
40480: PUSH
40481: LD_EXP 90
40485: PPUSH
40486: LD_VAR 0 2
40490: PPUSH
40491: LD_EXP 90
40495: PUSH
40496: LD_VAR 0 2
40500: ARRAY
40501: PUSH
40502: LD_VAR 0 6
40506: PUSH
40507: LD_INT 1
40509: ARRAY
40510: UNION
40511: PPUSH
40512: CALL_OW 1
40516: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40517: LD_VAR 0 6
40521: PUSH
40522: LD_INT 1
40524: ARRAY
40525: PPUSH
40526: LD_INT 126
40528: PPUSH
40529: CALL_OW 109
// end ; end ;
40533: GO 39612
40535: POP
40536: POP
// end ;
40537: LD_VAR 0 1
40541: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40542: LD_INT 0
40544: PPUSH
40545: PPUSH
40546: PPUSH
40547: PPUSH
40548: PPUSH
40549: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40550: LD_VAR 0 1
40554: NOT
40555: PUSH
40556: LD_VAR 0 2
40560: NOT
40561: OR
40562: PUSH
40563: LD_VAR 0 3
40567: NOT
40568: OR
40569: PUSH
40570: LD_VAR 0 4
40574: PUSH
40575: LD_INT 1
40577: PUSH
40578: LD_INT 2
40580: PUSH
40581: LD_INT 3
40583: PUSH
40584: LD_INT 4
40586: PUSH
40587: LD_INT 5
40589: PUSH
40590: LD_INT 8
40592: PUSH
40593: LD_INT 9
40595: PUSH
40596: LD_INT 15
40598: PUSH
40599: LD_INT 16
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: IN
40613: NOT
40614: OR
40615: IFFALSE 40619
// exit ;
40617: GO 41519
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40619: LD_ADDR_VAR 0 2
40623: PUSH
40624: LD_VAR 0 2
40628: PPUSH
40629: LD_INT 21
40631: PUSH
40632: LD_INT 3
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 24
40641: PUSH
40642: LD_INT 250
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: PPUSH
40653: CALL_OW 72
40657: ST_TO_ADDR
// case class of 1 , 15 :
40658: LD_VAR 0 4
40662: PUSH
40663: LD_INT 1
40665: DOUBLE
40666: EQUAL
40667: IFTRUE 40677
40669: LD_INT 15
40671: DOUBLE
40672: EQUAL
40673: IFTRUE 40677
40675: GO 40762
40677: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40678: LD_ADDR_VAR 0 8
40682: PUSH
40683: LD_VAR 0 2
40687: PPUSH
40688: LD_INT 2
40690: PUSH
40691: LD_INT 30
40693: PUSH
40694: LD_INT 32
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 30
40703: PUSH
40704: LD_INT 31
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: LIST
40715: PPUSH
40716: CALL_OW 72
40720: PUSH
40721: LD_VAR 0 2
40725: PPUSH
40726: LD_INT 2
40728: PUSH
40729: LD_INT 30
40731: PUSH
40732: LD_INT 4
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 30
40741: PUSH
40742: LD_INT 5
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: LIST
40753: PPUSH
40754: CALL_OW 72
40758: ADD
40759: ST_TO_ADDR
40760: GO 41008
40762: LD_INT 2
40764: DOUBLE
40765: EQUAL
40766: IFTRUE 40776
40768: LD_INT 16
40770: DOUBLE
40771: EQUAL
40772: IFTRUE 40776
40774: GO 40822
40776: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40777: LD_ADDR_VAR 0 8
40781: PUSH
40782: LD_VAR 0 2
40786: PPUSH
40787: LD_INT 2
40789: PUSH
40790: LD_INT 30
40792: PUSH
40793: LD_INT 0
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 30
40802: PUSH
40803: LD_INT 1
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: LIST
40814: PPUSH
40815: CALL_OW 72
40819: ST_TO_ADDR
40820: GO 41008
40822: LD_INT 3
40824: DOUBLE
40825: EQUAL
40826: IFTRUE 40830
40828: GO 40876
40830: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40831: LD_ADDR_VAR 0 8
40835: PUSH
40836: LD_VAR 0 2
40840: PPUSH
40841: LD_INT 2
40843: PUSH
40844: LD_INT 30
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 30
40856: PUSH
40857: LD_INT 3
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: LIST
40868: PPUSH
40869: CALL_OW 72
40873: ST_TO_ADDR
40874: GO 41008
40876: LD_INT 4
40878: DOUBLE
40879: EQUAL
40880: IFTRUE 40884
40882: GO 40941
40884: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40885: LD_ADDR_VAR 0 8
40889: PUSH
40890: LD_VAR 0 2
40894: PPUSH
40895: LD_INT 2
40897: PUSH
40898: LD_INT 30
40900: PUSH
40901: LD_INT 6
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 30
40910: PUSH
40911: LD_INT 7
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 30
40920: PUSH
40921: LD_INT 8
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: PPUSH
40934: CALL_OW 72
40938: ST_TO_ADDR
40939: GO 41008
40941: LD_INT 5
40943: DOUBLE
40944: EQUAL
40945: IFTRUE 40961
40947: LD_INT 8
40949: DOUBLE
40950: EQUAL
40951: IFTRUE 40961
40953: LD_INT 9
40955: DOUBLE
40956: EQUAL
40957: IFTRUE 40961
40959: GO 41007
40961: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40962: LD_ADDR_VAR 0 8
40966: PUSH
40967: LD_VAR 0 2
40971: PPUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 30
40977: PUSH
40978: LD_INT 4
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 30
40987: PUSH
40988: LD_INT 5
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: LIST
40999: PPUSH
41000: CALL_OW 72
41004: ST_TO_ADDR
41005: GO 41008
41007: POP
// if not tmp then
41008: LD_VAR 0 8
41012: NOT
41013: IFFALSE 41017
// exit ;
41015: GO 41519
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41017: LD_VAR 0 4
41021: PUSH
41022: LD_INT 1
41024: PUSH
41025: LD_INT 15
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: IN
41032: PUSH
41033: LD_EXP 59
41037: PUSH
41038: LD_VAR 0 1
41042: ARRAY
41043: AND
41044: IFFALSE 41200
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41046: LD_ADDR_VAR 0 9
41050: PUSH
41051: LD_EXP 59
41055: PUSH
41056: LD_VAR 0 1
41060: ARRAY
41061: PUSH
41062: LD_INT 1
41064: ARRAY
41065: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41066: LD_VAR 0 9
41070: PUSH
41071: LD_EXP 60
41075: PUSH
41076: LD_VAR 0 1
41080: ARRAY
41081: IN
41082: NOT
41083: IFFALSE 41198
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41085: LD_ADDR_EXP 60
41089: PUSH
41090: LD_EXP 60
41094: PPUSH
41095: LD_VAR 0 1
41099: PUSH
41100: LD_EXP 60
41104: PUSH
41105: LD_VAR 0 1
41109: ARRAY
41110: PUSH
41111: LD_INT 1
41113: PLUS
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PPUSH
41119: LD_VAR 0 9
41123: PPUSH
41124: CALL 53541 0 3
41128: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41129: LD_ADDR_EXP 59
41133: PUSH
41134: LD_EXP 59
41138: PPUSH
41139: LD_VAR 0 1
41143: PPUSH
41144: LD_EXP 59
41148: PUSH
41149: LD_VAR 0 1
41153: ARRAY
41154: PUSH
41155: LD_VAR 0 9
41159: DIFF
41160: PPUSH
41161: CALL_OW 1
41165: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41166: LD_VAR 0 3
41170: PPUSH
41171: LD_EXP 60
41175: PUSH
41176: LD_VAR 0 1
41180: ARRAY
41181: PUSH
41182: LD_EXP 60
41186: PUSH
41187: LD_VAR 0 1
41191: ARRAY
41192: ARRAY
41193: PPUSH
41194: CALL_OW 120
// end ; exit ;
41198: GO 41519
// end ; if tmp > 1 then
41200: LD_VAR 0 8
41204: PUSH
41205: LD_INT 1
41207: GREATER
41208: IFFALSE 41312
// for i = 2 to tmp do
41210: LD_ADDR_VAR 0 6
41214: PUSH
41215: DOUBLE
41216: LD_INT 2
41218: DEC
41219: ST_TO_ADDR
41220: LD_VAR 0 8
41224: PUSH
41225: FOR_TO
41226: IFFALSE 41310
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41228: LD_VAR 0 8
41232: PUSH
41233: LD_VAR 0 6
41237: ARRAY
41238: PPUSH
41239: CALL_OW 461
41243: PUSH
41244: LD_INT 6
41246: EQUAL
41247: IFFALSE 41308
// begin x := tmp [ i ] ;
41249: LD_ADDR_VAR 0 9
41253: PUSH
41254: LD_VAR 0 8
41258: PUSH
41259: LD_VAR 0 6
41263: ARRAY
41264: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41265: LD_ADDR_VAR 0 8
41269: PUSH
41270: LD_VAR 0 8
41274: PPUSH
41275: LD_VAR 0 6
41279: PPUSH
41280: CALL_OW 3
41284: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41285: LD_ADDR_VAR 0 8
41289: PUSH
41290: LD_VAR 0 8
41294: PPUSH
41295: LD_INT 1
41297: PPUSH
41298: LD_VAR 0 9
41302: PPUSH
41303: CALL_OW 2
41307: ST_TO_ADDR
// end ;
41308: GO 41225
41310: POP
41311: POP
// for i in tmp do
41312: LD_ADDR_VAR 0 6
41316: PUSH
41317: LD_VAR 0 8
41321: PUSH
41322: FOR_IN
41323: IFFALSE 41392
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41325: LD_VAR 0 6
41329: PPUSH
41330: CALL_OW 313
41334: PUSH
41335: LD_INT 6
41337: LESS
41338: PUSH
41339: LD_VAR 0 6
41343: PPUSH
41344: CALL_OW 266
41348: PUSH
41349: LD_INT 31
41351: PUSH
41352: LD_INT 32
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: IN
41359: NOT
41360: AND
41361: PUSH
41362: LD_VAR 0 6
41366: PPUSH
41367: CALL_OW 313
41371: PUSH
41372: LD_INT 0
41374: EQUAL
41375: OR
41376: IFFALSE 41390
// begin j := i ;
41378: LD_ADDR_VAR 0 7
41382: PUSH
41383: LD_VAR 0 6
41387: ST_TO_ADDR
// break ;
41388: GO 41392
// end ; end ;
41390: GO 41322
41392: POP
41393: POP
// if j then
41394: LD_VAR 0 7
41398: IFFALSE 41416
// ComEnterUnit ( unit , j ) else
41400: LD_VAR 0 3
41404: PPUSH
41405: LD_VAR 0 7
41409: PPUSH
41410: CALL_OW 120
41414: GO 41519
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41416: LD_ADDR_VAR 0 10
41420: PUSH
41421: LD_VAR 0 2
41425: PPUSH
41426: LD_INT 2
41428: PUSH
41429: LD_INT 30
41431: PUSH
41432: LD_INT 0
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 30
41441: PUSH
41442: LD_INT 1
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: LIST
41453: PPUSH
41454: CALL_OW 72
41458: ST_TO_ADDR
// if depot then
41459: LD_VAR 0 10
41463: IFFALSE 41519
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41465: LD_ADDR_VAR 0 10
41469: PUSH
41470: LD_VAR 0 10
41474: PPUSH
41475: LD_VAR 0 3
41479: PPUSH
41480: CALL_OW 74
41484: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41485: LD_VAR 0 3
41489: PPUSH
41490: LD_VAR 0 10
41494: PPUSH
41495: CALL_OW 296
41499: PUSH
41500: LD_INT 10
41502: GREATER
41503: IFFALSE 41519
// ComStandNearbyBuilding ( unit , depot ) ;
41505: LD_VAR 0 3
41509: PPUSH
41510: LD_VAR 0 10
41514: PPUSH
41515: CALL 50119 0 2
// end ; end ; end ;
41519: LD_VAR 0 5
41523: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41524: LD_INT 0
41526: PPUSH
41527: PPUSH
41528: PPUSH
41529: PPUSH
// if not mc_bases then
41530: LD_EXP 50
41534: NOT
41535: IFFALSE 41539
// exit ;
41537: GO 41778
// for i = 1 to mc_bases do
41539: LD_ADDR_VAR 0 2
41543: PUSH
41544: DOUBLE
41545: LD_INT 1
41547: DEC
41548: ST_TO_ADDR
41549: LD_EXP 50
41553: PUSH
41554: FOR_TO
41555: IFFALSE 41776
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41557: LD_ADDR_VAR 0 4
41561: PUSH
41562: LD_EXP 50
41566: PUSH
41567: LD_VAR 0 2
41571: ARRAY
41572: PPUSH
41573: LD_INT 21
41575: PUSH
41576: LD_INT 1
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: PPUSH
41583: CALL_OW 72
41587: PUSH
41588: LD_EXP 79
41592: PUSH
41593: LD_VAR 0 2
41597: ARRAY
41598: UNION
41599: ST_TO_ADDR
// if not tmp then
41600: LD_VAR 0 4
41604: NOT
41605: IFFALSE 41609
// continue ;
41607: GO 41554
// for j in tmp do
41609: LD_ADDR_VAR 0 3
41613: PUSH
41614: LD_VAR 0 4
41618: PUSH
41619: FOR_IN
41620: IFFALSE 41772
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41622: LD_VAR 0 3
41626: PPUSH
41627: CALL_OW 110
41631: NOT
41632: PUSH
41633: LD_VAR 0 3
41637: PPUSH
41638: CALL_OW 314
41642: NOT
41643: AND
41644: PUSH
41645: LD_VAR 0 3
41649: PPUSH
41650: CALL_OW 311
41654: NOT
41655: AND
41656: PUSH
41657: LD_VAR 0 3
41661: PPUSH
41662: CALL_OW 310
41666: NOT
41667: AND
41668: PUSH
41669: LD_VAR 0 3
41673: PUSH
41674: LD_EXP 53
41678: PUSH
41679: LD_VAR 0 2
41683: ARRAY
41684: PUSH
41685: LD_INT 1
41687: ARRAY
41688: IN
41689: NOT
41690: AND
41691: PUSH
41692: LD_VAR 0 3
41696: PUSH
41697: LD_EXP 53
41701: PUSH
41702: LD_VAR 0 2
41706: ARRAY
41707: PUSH
41708: LD_INT 2
41710: ARRAY
41711: IN
41712: NOT
41713: AND
41714: PUSH
41715: LD_VAR 0 3
41719: PUSH
41720: LD_EXP 62
41724: PUSH
41725: LD_VAR 0 2
41729: ARRAY
41730: IN
41731: NOT
41732: AND
41733: IFFALSE 41770
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41735: LD_VAR 0 2
41739: PPUSH
41740: LD_EXP 50
41744: PUSH
41745: LD_VAR 0 2
41749: ARRAY
41750: PPUSH
41751: LD_VAR 0 3
41755: PPUSH
41756: LD_VAR 0 3
41760: PPUSH
41761: CALL_OW 257
41765: PPUSH
41766: CALL 40542 0 4
// end ;
41770: GO 41619
41772: POP
41773: POP
// end ;
41774: GO 41554
41776: POP
41777: POP
// end ;
41778: LD_VAR 0 1
41782: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41783: LD_INT 0
41785: PPUSH
41786: PPUSH
41787: PPUSH
41788: PPUSH
41789: PPUSH
41790: PPUSH
// if not mc_bases [ base ] then
41791: LD_EXP 50
41795: PUSH
41796: LD_VAR 0 1
41800: ARRAY
41801: NOT
41802: IFFALSE 41806
// exit ;
41804: GO 41988
// tmp := [ ] ;
41806: LD_ADDR_VAR 0 6
41810: PUSH
41811: EMPTY
41812: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41813: LD_ADDR_VAR 0 7
41817: PUSH
41818: LD_VAR 0 3
41822: PPUSH
41823: LD_INT 0
41825: PPUSH
41826: CALL_OW 517
41830: ST_TO_ADDR
// if not list then
41831: LD_VAR 0 7
41835: NOT
41836: IFFALSE 41840
// exit ;
41838: GO 41988
// for i = 1 to amount do
41840: LD_ADDR_VAR 0 5
41844: PUSH
41845: DOUBLE
41846: LD_INT 1
41848: DEC
41849: ST_TO_ADDR
41850: LD_VAR 0 2
41854: PUSH
41855: FOR_TO
41856: IFFALSE 41936
// begin x := rand ( 1 , list [ 1 ] ) ;
41858: LD_ADDR_VAR 0 8
41862: PUSH
41863: LD_INT 1
41865: PPUSH
41866: LD_VAR 0 7
41870: PUSH
41871: LD_INT 1
41873: ARRAY
41874: PPUSH
41875: CALL_OW 12
41879: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41880: LD_ADDR_VAR 0 6
41884: PUSH
41885: LD_VAR 0 6
41889: PPUSH
41890: LD_VAR 0 5
41894: PPUSH
41895: LD_VAR 0 7
41899: PUSH
41900: LD_INT 1
41902: ARRAY
41903: PUSH
41904: LD_VAR 0 8
41908: ARRAY
41909: PUSH
41910: LD_VAR 0 7
41914: PUSH
41915: LD_INT 2
41917: ARRAY
41918: PUSH
41919: LD_VAR 0 8
41923: ARRAY
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PPUSH
41929: CALL_OW 1
41933: ST_TO_ADDR
// end ;
41934: GO 41855
41936: POP
41937: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41938: LD_ADDR_EXP 63
41942: PUSH
41943: LD_EXP 63
41947: PPUSH
41948: LD_VAR 0 1
41952: PPUSH
41953: LD_VAR 0 6
41957: PPUSH
41958: CALL_OW 1
41962: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41963: LD_ADDR_EXP 65
41967: PUSH
41968: LD_EXP 65
41972: PPUSH
41973: LD_VAR 0 1
41977: PPUSH
41978: LD_VAR 0 3
41982: PPUSH
41983: CALL_OW 1
41987: ST_TO_ADDR
// end ;
41988: LD_VAR 0 4
41992: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41993: LD_INT 0
41995: PPUSH
// if not mc_bases [ base ] then
41996: LD_EXP 50
42000: PUSH
42001: LD_VAR 0 1
42005: ARRAY
42006: NOT
42007: IFFALSE 42011
// exit ;
42009: GO 42036
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42011: LD_ADDR_EXP 55
42015: PUSH
42016: LD_EXP 55
42020: PPUSH
42021: LD_VAR 0 1
42025: PPUSH
42026: LD_VAR 0 2
42030: PPUSH
42031: CALL_OW 1
42035: ST_TO_ADDR
// end ;
42036: LD_VAR 0 3
42040: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42041: LD_INT 0
42043: PPUSH
// if not mc_bases [ base ] then
42044: LD_EXP 50
42048: PUSH
42049: LD_VAR 0 1
42053: ARRAY
42054: NOT
42055: IFFALSE 42059
// exit ;
42057: GO 42096
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42059: LD_ADDR_EXP 55
42063: PUSH
42064: LD_EXP 55
42068: PPUSH
42069: LD_VAR 0 1
42073: PPUSH
42074: LD_EXP 55
42078: PUSH
42079: LD_VAR 0 1
42083: ARRAY
42084: PUSH
42085: LD_VAR 0 2
42089: UNION
42090: PPUSH
42091: CALL_OW 1
42095: ST_TO_ADDR
// end ;
42096: LD_VAR 0 3
42100: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42101: LD_INT 0
42103: PPUSH
// if not mc_bases [ base ] then
42104: LD_EXP 50
42108: PUSH
42109: LD_VAR 0 1
42113: ARRAY
42114: NOT
42115: IFFALSE 42119
// exit ;
42117: GO 42144
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42119: LD_ADDR_EXP 71
42123: PUSH
42124: LD_EXP 71
42128: PPUSH
42129: LD_VAR 0 1
42133: PPUSH
42134: LD_VAR 0 2
42138: PPUSH
42139: CALL_OW 1
42143: ST_TO_ADDR
// end ;
42144: LD_VAR 0 3
42148: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42149: LD_INT 0
42151: PPUSH
// if not mc_bases [ base ] then
42152: LD_EXP 50
42156: PUSH
42157: LD_VAR 0 1
42161: ARRAY
42162: NOT
42163: IFFALSE 42167
// exit ;
42165: GO 42204
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42167: LD_ADDR_EXP 71
42171: PUSH
42172: LD_EXP 71
42176: PPUSH
42177: LD_VAR 0 1
42181: PPUSH
42182: LD_EXP 71
42186: PUSH
42187: LD_VAR 0 1
42191: ARRAY
42192: PUSH
42193: LD_VAR 0 2
42197: ADD
42198: PPUSH
42199: CALL_OW 1
42203: ST_TO_ADDR
// end ;
42204: LD_VAR 0 3
42208: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42209: LD_INT 0
42211: PPUSH
// if not mc_bases [ base ] then
42212: LD_EXP 50
42216: PUSH
42217: LD_VAR 0 1
42221: ARRAY
42222: NOT
42223: IFFALSE 42227
// exit ;
42225: GO 42281
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42227: LD_ADDR_EXP 72
42231: PUSH
42232: LD_EXP 72
42236: PPUSH
42237: LD_VAR 0 1
42241: PPUSH
42242: LD_VAR 0 2
42246: PPUSH
42247: CALL_OW 1
42251: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42252: LD_ADDR_EXP 61
42256: PUSH
42257: LD_EXP 61
42261: PPUSH
42262: LD_VAR 0 1
42266: PPUSH
42267: LD_VAR 0 2
42271: PUSH
42272: LD_INT 0
42274: PLUS
42275: PPUSH
42276: CALL_OW 1
42280: ST_TO_ADDR
// end ;
42281: LD_VAR 0 3
42285: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42286: LD_INT 0
42288: PPUSH
// if not mc_bases [ base ] then
42289: LD_EXP 50
42293: PUSH
42294: LD_VAR 0 1
42298: ARRAY
42299: NOT
42300: IFFALSE 42304
// exit ;
42302: GO 42329
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42304: LD_ADDR_EXP 61
42308: PUSH
42309: LD_EXP 61
42313: PPUSH
42314: LD_VAR 0 1
42318: PPUSH
42319: LD_VAR 0 2
42323: PPUSH
42324: CALL_OW 1
42328: ST_TO_ADDR
// end ;
42329: LD_VAR 0 3
42333: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42334: LD_INT 0
42336: PPUSH
42337: PPUSH
42338: PPUSH
42339: PPUSH
// if not mc_bases [ base ] then
42340: LD_EXP 50
42344: PUSH
42345: LD_VAR 0 1
42349: ARRAY
42350: NOT
42351: IFFALSE 42355
// exit ;
42353: GO 42420
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42355: LD_ADDR_EXP 70
42359: PUSH
42360: LD_EXP 70
42364: PPUSH
42365: LD_VAR 0 1
42369: PUSH
42370: LD_EXP 70
42374: PUSH
42375: LD_VAR 0 1
42379: ARRAY
42380: PUSH
42381: LD_INT 1
42383: PLUS
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PPUSH
42389: LD_VAR 0 1
42393: PUSH
42394: LD_VAR 0 2
42398: PUSH
42399: LD_VAR 0 3
42403: PUSH
42404: LD_VAR 0 4
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: PPUSH
42415: CALL 53541 0 3
42419: ST_TO_ADDR
// end ;
42420: LD_VAR 0 5
42424: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42425: LD_INT 0
42427: PPUSH
// if not mc_bases [ base ] then
42428: LD_EXP 50
42432: PUSH
42433: LD_VAR 0 1
42437: ARRAY
42438: NOT
42439: IFFALSE 42443
// exit ;
42441: GO 42468
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42443: LD_ADDR_EXP 87
42447: PUSH
42448: LD_EXP 87
42452: PPUSH
42453: LD_VAR 0 1
42457: PPUSH
42458: LD_VAR 0 2
42462: PPUSH
42463: CALL_OW 1
42467: ST_TO_ADDR
// end ;
42468: LD_VAR 0 3
42472: RET
// export function MC_GetMinesField ( base ) ; begin
42473: LD_INT 0
42475: PPUSH
// result := mc_mines [ base ] ;
42476: LD_ADDR_VAR 0 2
42480: PUSH
42481: LD_EXP 63
42485: PUSH
42486: LD_VAR 0 1
42490: ARRAY
42491: ST_TO_ADDR
// end ;
42492: LD_VAR 0 2
42496: RET
// export function MC_GetProduceList ( base ) ; begin
42497: LD_INT 0
42499: PPUSH
// result := mc_produce [ base ] ;
42500: LD_ADDR_VAR 0 2
42504: PUSH
42505: LD_EXP 71
42509: PUSH
42510: LD_VAR 0 1
42514: ARRAY
42515: ST_TO_ADDR
// end ;
42516: LD_VAR 0 2
42520: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42521: LD_INT 0
42523: PPUSH
42524: PPUSH
// if not mc_bases then
42525: LD_EXP 50
42529: NOT
42530: IFFALSE 42534
// exit ;
42532: GO 42599
// if mc_bases [ base ] then
42534: LD_EXP 50
42538: PUSH
42539: LD_VAR 0 1
42543: ARRAY
42544: IFFALSE 42599
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42546: LD_ADDR_VAR 0 3
42550: PUSH
42551: LD_EXP 50
42555: PUSH
42556: LD_VAR 0 1
42560: ARRAY
42561: PPUSH
42562: LD_INT 30
42564: PUSH
42565: LD_VAR 0 2
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PPUSH
42574: CALL_OW 72
42578: ST_TO_ADDR
// if result then
42579: LD_VAR 0 3
42583: IFFALSE 42599
// result := result [ 1 ] ;
42585: LD_ADDR_VAR 0 3
42589: PUSH
42590: LD_VAR 0 3
42594: PUSH
42595: LD_INT 1
42597: ARRAY
42598: ST_TO_ADDR
// end ; end ;
42599: LD_VAR 0 3
42603: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42604: LD_INT 0
42606: PPUSH
42607: PPUSH
// if not mc_bases then
42608: LD_EXP 50
42612: NOT
42613: IFFALSE 42617
// exit ;
42615: GO 42662
// if mc_bases [ base ] then
42617: LD_EXP 50
42621: PUSH
42622: LD_VAR 0 1
42626: ARRAY
42627: IFFALSE 42662
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42629: LD_ADDR_VAR 0 3
42633: PUSH
42634: LD_EXP 50
42638: PUSH
42639: LD_VAR 0 1
42643: ARRAY
42644: PPUSH
42645: LD_INT 30
42647: PUSH
42648: LD_VAR 0 2
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PPUSH
42657: CALL_OW 72
42661: ST_TO_ADDR
// end ;
42662: LD_VAR 0 3
42666: RET
// export function MC_SetTame ( base , area ) ; begin
42667: LD_INT 0
42669: PPUSH
// if not mc_bases or not base then
42670: LD_EXP 50
42674: NOT
42675: PUSH
42676: LD_VAR 0 1
42680: NOT
42681: OR
42682: IFFALSE 42686
// exit ;
42684: GO 42711
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42686: LD_ADDR_EXP 78
42690: PUSH
42691: LD_EXP 78
42695: PPUSH
42696: LD_VAR 0 1
42700: PPUSH
42701: LD_VAR 0 2
42705: PPUSH
42706: CALL_OW 1
42710: ST_TO_ADDR
// end ;
42711: LD_VAR 0 3
42715: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42716: LD_INT 0
42718: PPUSH
42719: PPUSH
// if not mc_bases or not base then
42720: LD_EXP 50
42724: NOT
42725: PUSH
42726: LD_VAR 0 1
42730: NOT
42731: OR
42732: IFFALSE 42736
// exit ;
42734: GO 42838
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42736: LD_ADDR_VAR 0 4
42740: PUSH
42741: LD_EXP 50
42745: PUSH
42746: LD_VAR 0 1
42750: ARRAY
42751: PPUSH
42752: LD_INT 30
42754: PUSH
42755: LD_VAR 0 2
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PPUSH
42764: CALL_OW 72
42768: ST_TO_ADDR
// if not tmp then
42769: LD_VAR 0 4
42773: NOT
42774: IFFALSE 42778
// exit ;
42776: GO 42838
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42778: LD_ADDR_EXP 82
42782: PUSH
42783: LD_EXP 82
42787: PPUSH
42788: LD_VAR 0 1
42792: PPUSH
42793: LD_EXP 82
42797: PUSH
42798: LD_VAR 0 1
42802: ARRAY
42803: PPUSH
42804: LD_EXP 82
42808: PUSH
42809: LD_VAR 0 1
42813: ARRAY
42814: PUSH
42815: LD_INT 1
42817: PLUS
42818: PPUSH
42819: LD_VAR 0 4
42823: PUSH
42824: LD_INT 1
42826: ARRAY
42827: PPUSH
42828: CALL_OW 2
42832: PPUSH
42833: CALL_OW 1
42837: ST_TO_ADDR
// end ;
42838: LD_VAR 0 3
42842: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42843: LD_INT 0
42845: PPUSH
42846: PPUSH
// if not mc_bases or not base or not kinds then
42847: LD_EXP 50
42851: NOT
42852: PUSH
42853: LD_VAR 0 1
42857: NOT
42858: OR
42859: PUSH
42860: LD_VAR 0 2
42864: NOT
42865: OR
42866: IFFALSE 42870
// exit ;
42868: GO 42931
// for i in kinds do
42870: LD_ADDR_VAR 0 4
42874: PUSH
42875: LD_VAR 0 2
42879: PUSH
42880: FOR_IN
42881: IFFALSE 42929
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42883: LD_ADDR_EXP 84
42887: PUSH
42888: LD_EXP 84
42892: PPUSH
42893: LD_VAR 0 1
42897: PUSH
42898: LD_EXP 84
42902: PUSH
42903: LD_VAR 0 1
42907: ARRAY
42908: PUSH
42909: LD_INT 1
42911: PLUS
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PPUSH
42917: LD_VAR 0 4
42921: PPUSH
42922: CALL 53541 0 3
42926: ST_TO_ADDR
42927: GO 42880
42929: POP
42930: POP
// end ;
42931: LD_VAR 0 3
42935: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42936: LD_INT 0
42938: PPUSH
// if not mc_bases or not base or not areas then
42939: LD_EXP 50
42943: NOT
42944: PUSH
42945: LD_VAR 0 1
42949: NOT
42950: OR
42951: PUSH
42952: LD_VAR 0 2
42956: NOT
42957: OR
42958: IFFALSE 42962
// exit ;
42960: GO 42987
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42962: LD_ADDR_EXP 68
42966: PUSH
42967: LD_EXP 68
42971: PPUSH
42972: LD_VAR 0 1
42976: PPUSH
42977: LD_VAR 0 2
42981: PPUSH
42982: CALL_OW 1
42986: ST_TO_ADDR
// end ;
42987: LD_VAR 0 3
42991: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42992: LD_INT 0
42994: PPUSH
// if not mc_bases or not base or not teleports_exit then
42995: LD_EXP 50
42999: NOT
43000: PUSH
43001: LD_VAR 0 1
43005: NOT
43006: OR
43007: PUSH
43008: LD_VAR 0 2
43012: NOT
43013: OR
43014: IFFALSE 43018
// exit ;
43016: GO 43043
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43018: LD_ADDR_EXP 85
43022: PUSH
43023: LD_EXP 85
43027: PPUSH
43028: LD_VAR 0 1
43032: PPUSH
43033: LD_VAR 0 2
43037: PPUSH
43038: CALL_OW 1
43042: ST_TO_ADDR
// end ;
43043: LD_VAR 0 3
43047: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43048: LD_INT 0
43050: PPUSH
43051: PPUSH
43052: PPUSH
// if not mc_bases or not base or not ext_list then
43053: LD_EXP 50
43057: NOT
43058: PUSH
43059: LD_VAR 0 1
43063: NOT
43064: OR
43065: PUSH
43066: LD_VAR 0 5
43070: NOT
43071: OR
43072: IFFALSE 43076
// exit ;
43074: GO 43249
// tmp := GetFacExtXYD ( x , y , d ) ;
43076: LD_ADDR_VAR 0 8
43080: PUSH
43081: LD_VAR 0 2
43085: PPUSH
43086: LD_VAR 0 3
43090: PPUSH
43091: LD_VAR 0 4
43095: PPUSH
43096: CALL 82928 0 3
43100: ST_TO_ADDR
// if not tmp then
43101: LD_VAR 0 8
43105: NOT
43106: IFFALSE 43110
// exit ;
43108: GO 43249
// for i in tmp do
43110: LD_ADDR_VAR 0 7
43114: PUSH
43115: LD_VAR 0 8
43119: PUSH
43120: FOR_IN
43121: IFFALSE 43247
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43123: LD_ADDR_EXP 55
43127: PUSH
43128: LD_EXP 55
43132: PPUSH
43133: LD_VAR 0 1
43137: PPUSH
43138: LD_EXP 55
43142: PUSH
43143: LD_VAR 0 1
43147: ARRAY
43148: PPUSH
43149: LD_EXP 55
43153: PUSH
43154: LD_VAR 0 1
43158: ARRAY
43159: PUSH
43160: LD_INT 1
43162: PLUS
43163: PPUSH
43164: LD_VAR 0 5
43168: PUSH
43169: LD_INT 1
43171: ARRAY
43172: PUSH
43173: LD_VAR 0 7
43177: PUSH
43178: LD_INT 1
43180: ARRAY
43181: PUSH
43182: LD_VAR 0 7
43186: PUSH
43187: LD_INT 2
43189: ARRAY
43190: PUSH
43191: LD_VAR 0 7
43195: PUSH
43196: LD_INT 3
43198: ARRAY
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: PPUSH
43206: CALL_OW 2
43210: PPUSH
43211: CALL_OW 1
43215: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43216: LD_ADDR_VAR 0 5
43220: PUSH
43221: LD_VAR 0 5
43225: PPUSH
43226: LD_INT 1
43228: PPUSH
43229: CALL_OW 3
43233: ST_TO_ADDR
// if not ext_list then
43234: LD_VAR 0 5
43238: NOT
43239: IFFALSE 43245
// exit ;
43241: POP
43242: POP
43243: GO 43249
// end ;
43245: GO 43120
43247: POP
43248: POP
// end ;
43249: LD_VAR 0 6
43253: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43254: LD_INT 0
43256: PPUSH
// if not mc_bases or not base or not weapon_list then
43257: LD_EXP 50
43261: NOT
43262: PUSH
43263: LD_VAR 0 1
43267: NOT
43268: OR
43269: PUSH
43270: LD_VAR 0 2
43274: NOT
43275: OR
43276: IFFALSE 43280
// exit ;
43278: GO 43305
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43280: LD_ADDR_EXP 89
43284: PUSH
43285: LD_EXP 89
43289: PPUSH
43290: LD_VAR 0 1
43294: PPUSH
43295: LD_VAR 0 2
43299: PPUSH
43300: CALL_OW 1
43304: ST_TO_ADDR
// end ;
43305: LD_VAR 0 3
43309: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43310: LD_INT 0
43312: PPUSH
// if not mc_bases or not base or not tech_list then
43313: LD_EXP 50
43317: NOT
43318: PUSH
43319: LD_VAR 0 1
43323: NOT
43324: OR
43325: PUSH
43326: LD_VAR 0 2
43330: NOT
43331: OR
43332: IFFALSE 43336
// exit ;
43334: GO 43361
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43336: LD_ADDR_EXP 77
43340: PUSH
43341: LD_EXP 77
43345: PPUSH
43346: LD_VAR 0 1
43350: PPUSH
43351: LD_VAR 0 2
43355: PPUSH
43356: CALL_OW 1
43360: ST_TO_ADDR
// end ;
43361: LD_VAR 0 3
43365: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43366: LD_INT 0
43368: PPUSH
// if not mc_bases or not parking_area or not base then
43369: LD_EXP 50
43373: NOT
43374: PUSH
43375: LD_VAR 0 2
43379: NOT
43380: OR
43381: PUSH
43382: LD_VAR 0 1
43386: NOT
43387: OR
43388: IFFALSE 43392
// exit ;
43390: GO 43417
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43392: LD_ADDR_EXP 74
43396: PUSH
43397: LD_EXP 74
43401: PPUSH
43402: LD_VAR 0 1
43406: PPUSH
43407: LD_VAR 0 2
43411: PPUSH
43412: CALL_OW 1
43416: ST_TO_ADDR
// end ;
43417: LD_VAR 0 3
43421: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43422: LD_INT 0
43424: PPUSH
// if not mc_bases or not base or not scan_area then
43425: LD_EXP 50
43429: NOT
43430: PUSH
43431: LD_VAR 0 1
43435: NOT
43436: OR
43437: PUSH
43438: LD_VAR 0 2
43442: NOT
43443: OR
43444: IFFALSE 43448
// exit ;
43446: GO 43473
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43448: LD_ADDR_EXP 75
43452: PUSH
43453: LD_EXP 75
43457: PPUSH
43458: LD_VAR 0 1
43462: PPUSH
43463: LD_VAR 0 2
43467: PPUSH
43468: CALL_OW 1
43472: ST_TO_ADDR
// end ;
43473: LD_VAR 0 3
43477: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43478: LD_INT 0
43480: PPUSH
43481: PPUSH
// if not mc_bases or not base then
43482: LD_EXP 50
43486: NOT
43487: PUSH
43488: LD_VAR 0 1
43492: NOT
43493: OR
43494: IFFALSE 43498
// exit ;
43496: GO 43562
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43498: LD_ADDR_VAR 0 3
43502: PUSH
43503: LD_INT 1
43505: PUSH
43506: LD_INT 2
43508: PUSH
43509: LD_INT 3
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 11
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43525: LD_ADDR_EXP 77
43529: PUSH
43530: LD_EXP 77
43534: PPUSH
43535: LD_VAR 0 1
43539: PPUSH
43540: LD_EXP 77
43544: PUSH
43545: LD_VAR 0 1
43549: ARRAY
43550: PUSH
43551: LD_VAR 0 3
43555: DIFF
43556: PPUSH
43557: CALL_OW 1
43561: ST_TO_ADDR
// end ;
43562: LD_VAR 0 2
43566: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43567: LD_INT 0
43569: PPUSH
// result := mc_vehicles [ base ] ;
43570: LD_ADDR_VAR 0 3
43574: PUSH
43575: LD_EXP 69
43579: PUSH
43580: LD_VAR 0 1
43584: ARRAY
43585: ST_TO_ADDR
// if onlyCombat then
43586: LD_VAR 0 2
43590: IFFALSE 43768
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43592: LD_ADDR_VAR 0 3
43596: PUSH
43597: LD_VAR 0 3
43601: PUSH
43602: LD_VAR 0 3
43606: PPUSH
43607: LD_INT 2
43609: PUSH
43610: LD_INT 34
43612: PUSH
43613: LD_INT 12
43615: PUSH
43616: EMPTY
43617: LIST
43618: LIST
43619: PUSH
43620: LD_INT 34
43622: PUSH
43623: LD_INT 51
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 34
43632: PUSH
43633: LD_EXP 95
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PUSH
43642: LD_INT 34
43644: PUSH
43645: LD_INT 32
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 34
43654: PUSH
43655: LD_INT 13
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 34
43664: PUSH
43665: LD_INT 52
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 34
43674: PUSH
43675: LD_EXP 100
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 34
43686: PUSH
43687: LD_INT 14
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 34
43696: PUSH
43697: LD_INT 53
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 34
43706: PUSH
43707: LD_EXP 94
43711: PUSH
43712: EMPTY
43713: LIST
43714: LIST
43715: PUSH
43716: LD_INT 34
43718: PUSH
43719: LD_INT 31
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 34
43728: PUSH
43729: LD_INT 48
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 34
43738: PUSH
43739: LD_INT 8
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: LIST
43753: LIST
43754: LIST
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: PPUSH
43762: CALL_OW 72
43766: DIFF
43767: ST_TO_ADDR
// end ; end_of_file
43768: LD_VAR 0 3
43772: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43773: LD_INT 0
43775: PPUSH
43776: PPUSH
43777: PPUSH
// if not mc_bases or not skirmish then
43778: LD_EXP 50
43782: NOT
43783: PUSH
43784: LD_EXP 48
43788: NOT
43789: OR
43790: IFFALSE 43794
// exit ;
43792: GO 43959
// for i = 1 to mc_bases do
43794: LD_ADDR_VAR 0 4
43798: PUSH
43799: DOUBLE
43800: LD_INT 1
43802: DEC
43803: ST_TO_ADDR
43804: LD_EXP 50
43808: PUSH
43809: FOR_TO
43810: IFFALSE 43957
// begin if sci in mc_bases [ i ] then
43812: LD_VAR 0 2
43816: PUSH
43817: LD_EXP 50
43821: PUSH
43822: LD_VAR 0 4
43826: ARRAY
43827: IN
43828: IFFALSE 43955
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43830: LD_ADDR_EXP 79
43834: PUSH
43835: LD_EXP 79
43839: PPUSH
43840: LD_VAR 0 4
43844: PUSH
43845: LD_EXP 79
43849: PUSH
43850: LD_VAR 0 4
43854: ARRAY
43855: PUSH
43856: LD_INT 1
43858: PLUS
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PPUSH
43864: LD_VAR 0 1
43868: PPUSH
43869: CALL 53541 0 3
43873: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43874: LD_ADDR_VAR 0 5
43878: PUSH
43879: LD_EXP 50
43883: PUSH
43884: LD_VAR 0 4
43888: ARRAY
43889: PPUSH
43890: LD_INT 2
43892: PUSH
43893: LD_INT 30
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 30
43905: PUSH
43906: LD_INT 1
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: LIST
43917: PPUSH
43918: CALL_OW 72
43922: PPUSH
43923: LD_VAR 0 1
43927: PPUSH
43928: CALL_OW 74
43932: ST_TO_ADDR
// if tmp then
43933: LD_VAR 0 5
43937: IFFALSE 43953
// ComStandNearbyBuilding ( ape , tmp ) ;
43939: LD_VAR 0 1
43943: PPUSH
43944: LD_VAR 0 5
43948: PPUSH
43949: CALL 50119 0 2
// break ;
43953: GO 43957
// end ; end ;
43955: GO 43809
43957: POP
43958: POP
// end ;
43959: LD_VAR 0 3
43963: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43964: LD_INT 0
43966: PPUSH
43967: PPUSH
43968: PPUSH
// if not mc_bases or not skirmish then
43969: LD_EXP 50
43973: NOT
43974: PUSH
43975: LD_EXP 48
43979: NOT
43980: OR
43981: IFFALSE 43985
// exit ;
43983: GO 44074
// for i = 1 to mc_bases do
43985: LD_ADDR_VAR 0 4
43989: PUSH
43990: DOUBLE
43991: LD_INT 1
43993: DEC
43994: ST_TO_ADDR
43995: LD_EXP 50
43999: PUSH
44000: FOR_TO
44001: IFFALSE 44072
// begin if building in mc_busy_turret_list [ i ] then
44003: LD_VAR 0 1
44007: PUSH
44008: LD_EXP 60
44012: PUSH
44013: LD_VAR 0 4
44017: ARRAY
44018: IN
44019: IFFALSE 44070
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44021: LD_ADDR_VAR 0 5
44025: PUSH
44026: LD_EXP 60
44030: PUSH
44031: LD_VAR 0 4
44035: ARRAY
44036: PUSH
44037: LD_VAR 0 1
44041: DIFF
44042: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44043: LD_ADDR_EXP 60
44047: PUSH
44048: LD_EXP 60
44052: PPUSH
44053: LD_VAR 0 4
44057: PPUSH
44058: LD_VAR 0 5
44062: PPUSH
44063: CALL_OW 1
44067: ST_TO_ADDR
// break ;
44068: GO 44072
// end ; end ;
44070: GO 44000
44072: POP
44073: POP
// end ;
44074: LD_VAR 0 3
44078: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44079: LD_INT 0
44081: PPUSH
44082: PPUSH
44083: PPUSH
// if not mc_bases or not skirmish then
44084: LD_EXP 50
44088: NOT
44089: PUSH
44090: LD_EXP 48
44094: NOT
44095: OR
44096: IFFALSE 44100
// exit ;
44098: GO 44299
// for i = 1 to mc_bases do
44100: LD_ADDR_VAR 0 5
44104: PUSH
44105: DOUBLE
44106: LD_INT 1
44108: DEC
44109: ST_TO_ADDR
44110: LD_EXP 50
44114: PUSH
44115: FOR_TO
44116: IFFALSE 44297
// if building in mc_bases [ i ] then
44118: LD_VAR 0 1
44122: PUSH
44123: LD_EXP 50
44127: PUSH
44128: LD_VAR 0 5
44132: ARRAY
44133: IN
44134: IFFALSE 44295
// begin tmp := mc_bases [ i ] diff building ;
44136: LD_ADDR_VAR 0 6
44140: PUSH
44141: LD_EXP 50
44145: PUSH
44146: LD_VAR 0 5
44150: ARRAY
44151: PUSH
44152: LD_VAR 0 1
44156: DIFF
44157: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44158: LD_ADDR_EXP 50
44162: PUSH
44163: LD_EXP 50
44167: PPUSH
44168: LD_VAR 0 5
44172: PPUSH
44173: LD_VAR 0 6
44177: PPUSH
44178: CALL_OW 1
44182: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44183: LD_VAR 0 1
44187: PUSH
44188: LD_EXP 58
44192: PUSH
44193: LD_VAR 0 5
44197: ARRAY
44198: IN
44199: IFFALSE 44238
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44201: LD_ADDR_EXP 58
44205: PUSH
44206: LD_EXP 58
44210: PPUSH
44211: LD_VAR 0 5
44215: PPUSH
44216: LD_EXP 58
44220: PUSH
44221: LD_VAR 0 5
44225: ARRAY
44226: PUSH
44227: LD_VAR 0 1
44231: DIFF
44232: PPUSH
44233: CALL_OW 1
44237: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44238: LD_VAR 0 1
44242: PUSH
44243: LD_EXP 59
44247: PUSH
44248: LD_VAR 0 5
44252: ARRAY
44253: IN
44254: IFFALSE 44293
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44256: LD_ADDR_EXP 59
44260: PUSH
44261: LD_EXP 59
44265: PPUSH
44266: LD_VAR 0 5
44270: PPUSH
44271: LD_EXP 59
44275: PUSH
44276: LD_VAR 0 5
44280: ARRAY
44281: PUSH
44282: LD_VAR 0 1
44286: DIFF
44287: PPUSH
44288: CALL_OW 1
44292: ST_TO_ADDR
// break ;
44293: GO 44297
// end ;
44295: GO 44115
44297: POP
44298: POP
// end ;
44299: LD_VAR 0 4
44303: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44304: LD_INT 0
44306: PPUSH
44307: PPUSH
44308: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44309: LD_EXP 50
44313: NOT
44314: PUSH
44315: LD_EXP 48
44319: NOT
44320: OR
44321: PUSH
44322: LD_VAR 0 3
44326: PUSH
44327: LD_EXP 76
44331: IN
44332: NOT
44333: OR
44334: IFFALSE 44338
// exit ;
44336: GO 44461
// for i = 1 to mc_vehicles do
44338: LD_ADDR_VAR 0 6
44342: PUSH
44343: DOUBLE
44344: LD_INT 1
44346: DEC
44347: ST_TO_ADDR
44348: LD_EXP 69
44352: PUSH
44353: FOR_TO
44354: IFFALSE 44459
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44356: LD_VAR 0 2
44360: PUSH
44361: LD_EXP 69
44365: PUSH
44366: LD_VAR 0 6
44370: ARRAY
44371: IN
44372: PUSH
44373: LD_VAR 0 1
44377: PUSH
44378: LD_EXP 69
44382: PUSH
44383: LD_VAR 0 6
44387: ARRAY
44388: IN
44389: OR
44390: IFFALSE 44457
// begin tmp := mc_vehicles [ i ] diff old ;
44392: LD_ADDR_VAR 0 7
44396: PUSH
44397: LD_EXP 69
44401: PUSH
44402: LD_VAR 0 6
44406: ARRAY
44407: PUSH
44408: LD_VAR 0 2
44412: DIFF
44413: ST_TO_ADDR
// tmp := tmp diff new ;
44414: LD_ADDR_VAR 0 7
44418: PUSH
44419: LD_VAR 0 7
44423: PUSH
44424: LD_VAR 0 1
44428: DIFF
44429: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44430: LD_ADDR_EXP 69
44434: PUSH
44435: LD_EXP 69
44439: PPUSH
44440: LD_VAR 0 6
44444: PPUSH
44445: LD_VAR 0 7
44449: PPUSH
44450: CALL_OW 1
44454: ST_TO_ADDR
// break ;
44455: GO 44459
// end ;
44457: GO 44353
44459: POP
44460: POP
// end ;
44461: LD_VAR 0 5
44465: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44466: LD_INT 0
44468: PPUSH
44469: PPUSH
44470: PPUSH
44471: PPUSH
// if not mc_bases or not skirmish then
44472: LD_EXP 50
44476: NOT
44477: PUSH
44478: LD_EXP 48
44482: NOT
44483: OR
44484: IFFALSE 44488
// exit ;
44486: GO 44880
// side := GetSide ( vehicle ) ;
44488: LD_ADDR_VAR 0 5
44492: PUSH
44493: LD_VAR 0 1
44497: PPUSH
44498: CALL_OW 255
44502: ST_TO_ADDR
// for i = 1 to mc_bases do
44503: LD_ADDR_VAR 0 4
44507: PUSH
44508: DOUBLE
44509: LD_INT 1
44511: DEC
44512: ST_TO_ADDR
44513: LD_EXP 50
44517: PUSH
44518: FOR_TO
44519: IFFALSE 44878
// begin if factory in mc_bases [ i ] then
44521: LD_VAR 0 2
44525: PUSH
44526: LD_EXP 50
44530: PUSH
44531: LD_VAR 0 4
44535: ARRAY
44536: IN
44537: IFFALSE 44876
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44539: LD_EXP 72
44543: PUSH
44544: LD_VAR 0 4
44548: ARRAY
44549: PUSH
44550: LD_EXP 61
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: LESS
44561: PUSH
44562: LD_VAR 0 1
44566: PPUSH
44567: CALL_OW 264
44571: PUSH
44572: LD_INT 31
44574: PUSH
44575: LD_INT 32
44577: PUSH
44578: LD_INT 51
44580: PUSH
44581: LD_EXP 95
44585: PUSH
44586: LD_INT 12
44588: PUSH
44589: LD_INT 30
44591: PUSH
44592: LD_EXP 94
44596: PUSH
44597: LD_INT 11
44599: PUSH
44600: LD_INT 53
44602: PUSH
44603: LD_INT 14
44605: PUSH
44606: LD_EXP 98
44610: PUSH
44611: LD_INT 29
44613: PUSH
44614: LD_EXP 96
44618: PUSH
44619: LD_INT 13
44621: PUSH
44622: LD_INT 52
44624: PUSH
44625: LD_EXP 100
44629: PUSH
44630: LD_INT 48
44632: PUSH
44633: LD_INT 8
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: LIST
44640: LIST
44641: LIST
44642: LIST
44643: LIST
44644: LIST
44645: LIST
44646: LIST
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: IN
44656: NOT
44657: AND
44658: IFFALSE 44706
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44660: LD_ADDR_EXP 72
44664: PUSH
44665: LD_EXP 72
44669: PPUSH
44670: LD_VAR 0 4
44674: PUSH
44675: LD_EXP 72
44679: PUSH
44680: LD_VAR 0 4
44684: ARRAY
44685: PUSH
44686: LD_INT 1
44688: PLUS
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: PPUSH
44694: LD_VAR 0 1
44698: PPUSH
44699: CALL 53541 0 3
44703: ST_TO_ADDR
44704: GO 44750
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44706: LD_ADDR_EXP 69
44710: PUSH
44711: LD_EXP 69
44715: PPUSH
44716: LD_VAR 0 4
44720: PUSH
44721: LD_EXP 69
44725: PUSH
44726: LD_VAR 0 4
44730: ARRAY
44731: PUSH
44732: LD_INT 1
44734: PLUS
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PPUSH
44740: LD_VAR 0 1
44744: PPUSH
44745: CALL 53541 0 3
44749: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44750: LD_VAR 0 1
44754: PPUSH
44755: CALL_OW 263
44759: PUSH
44760: LD_INT 2
44762: EQUAL
44763: IFFALSE 44792
// begin repeat wait ( 0 0$3 ) ;
44765: LD_INT 105
44767: PPUSH
44768: CALL_OW 67
// Connect ( vehicle ) ;
44772: LD_VAR 0 1
44776: PPUSH
44777: CALL 56512 0 1
// until IsControledBy ( vehicle ) ;
44781: LD_VAR 0 1
44785: PPUSH
44786: CALL_OW 312
44790: IFFALSE 44765
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44792: LD_VAR 0 1
44796: PPUSH
44797: LD_EXP 74
44801: PUSH
44802: LD_VAR 0 4
44806: ARRAY
44807: PPUSH
44808: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44812: LD_VAR 0 1
44816: PPUSH
44817: CALL_OW 263
44821: PUSH
44822: LD_INT 1
44824: NONEQUAL
44825: IFFALSE 44829
// break ;
44827: GO 44878
// repeat wait ( 0 0$1 ) ;
44829: LD_INT 35
44831: PPUSH
44832: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44836: LD_VAR 0 1
44840: PPUSH
44841: LD_EXP 74
44845: PUSH
44846: LD_VAR 0 4
44850: ARRAY
44851: PPUSH
44852: CALL_OW 308
44856: IFFALSE 44829
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44858: LD_VAR 0 1
44862: PPUSH
44863: CALL_OW 311
44867: PPUSH
44868: CALL_OW 121
// exit ;
44872: POP
44873: POP
44874: GO 44880
// end ; end ;
44876: GO 44518
44878: POP
44879: POP
// end ;
44880: LD_VAR 0 3
44884: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44885: LD_INT 0
44887: PPUSH
44888: PPUSH
44889: PPUSH
44890: PPUSH
// if not mc_bases or not skirmish then
44891: LD_EXP 50
44895: NOT
44896: PUSH
44897: LD_EXP 48
44901: NOT
44902: OR
44903: IFFALSE 44907
// exit ;
44905: GO 45260
// repeat wait ( 0 0$1 ) ;
44907: LD_INT 35
44909: PPUSH
44910: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44914: LD_VAR 0 2
44918: PPUSH
44919: LD_VAR 0 3
44923: PPUSH
44924: CALL_OW 284
44928: IFFALSE 44907
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44930: LD_VAR 0 2
44934: PPUSH
44935: LD_VAR 0 3
44939: PPUSH
44940: CALL_OW 283
44944: PUSH
44945: LD_INT 4
44947: EQUAL
44948: IFFALSE 44952
// exit ;
44950: GO 45260
// for i = 1 to mc_bases do
44952: LD_ADDR_VAR 0 7
44956: PUSH
44957: DOUBLE
44958: LD_INT 1
44960: DEC
44961: ST_TO_ADDR
44962: LD_EXP 50
44966: PUSH
44967: FOR_TO
44968: IFFALSE 45258
// begin if mc_crates_area [ i ] then
44970: LD_EXP 68
44974: PUSH
44975: LD_VAR 0 7
44979: ARRAY
44980: IFFALSE 45091
// for j in mc_crates_area [ i ] do
44982: LD_ADDR_VAR 0 8
44986: PUSH
44987: LD_EXP 68
44991: PUSH
44992: LD_VAR 0 7
44996: ARRAY
44997: PUSH
44998: FOR_IN
44999: IFFALSE 45089
// if InArea ( x , y , j ) then
45001: LD_VAR 0 2
45005: PPUSH
45006: LD_VAR 0 3
45010: PPUSH
45011: LD_VAR 0 8
45015: PPUSH
45016: CALL_OW 309
45020: IFFALSE 45087
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45022: LD_ADDR_EXP 66
45026: PUSH
45027: LD_EXP 66
45031: PPUSH
45032: LD_VAR 0 7
45036: PUSH
45037: LD_EXP 66
45041: PUSH
45042: LD_VAR 0 7
45046: ARRAY
45047: PUSH
45048: LD_INT 1
45050: PLUS
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PPUSH
45056: LD_VAR 0 4
45060: PUSH
45061: LD_VAR 0 2
45065: PUSH
45066: LD_VAR 0 3
45070: PUSH
45071: EMPTY
45072: LIST
45073: LIST
45074: LIST
45075: PPUSH
45076: CALL 53541 0 3
45080: ST_TO_ADDR
// exit ;
45081: POP
45082: POP
45083: POP
45084: POP
45085: GO 45260
// end ;
45087: GO 44998
45089: POP
45090: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45091: LD_ADDR_VAR 0 9
45095: PUSH
45096: LD_EXP 50
45100: PUSH
45101: LD_VAR 0 7
45105: ARRAY
45106: PPUSH
45107: LD_INT 2
45109: PUSH
45110: LD_INT 30
45112: PUSH
45113: LD_INT 0
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: LD_INT 30
45122: PUSH
45123: LD_INT 1
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: LIST
45134: PPUSH
45135: CALL_OW 72
45139: ST_TO_ADDR
// if not depot then
45140: LD_VAR 0 9
45144: NOT
45145: IFFALSE 45149
// continue ;
45147: GO 44967
// for j in depot do
45149: LD_ADDR_VAR 0 8
45153: PUSH
45154: LD_VAR 0 9
45158: PUSH
45159: FOR_IN
45160: IFFALSE 45254
// if GetDistUnitXY ( j , x , y ) < 30 then
45162: LD_VAR 0 8
45166: PPUSH
45167: LD_VAR 0 2
45171: PPUSH
45172: LD_VAR 0 3
45176: PPUSH
45177: CALL_OW 297
45181: PUSH
45182: LD_INT 30
45184: LESS
45185: IFFALSE 45252
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45187: LD_ADDR_EXP 66
45191: PUSH
45192: LD_EXP 66
45196: PPUSH
45197: LD_VAR 0 7
45201: PUSH
45202: LD_EXP 66
45206: PUSH
45207: LD_VAR 0 7
45211: ARRAY
45212: PUSH
45213: LD_INT 1
45215: PLUS
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PPUSH
45221: LD_VAR 0 4
45225: PUSH
45226: LD_VAR 0 2
45230: PUSH
45231: LD_VAR 0 3
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: LIST
45240: PPUSH
45241: CALL 53541 0 3
45245: ST_TO_ADDR
// exit ;
45246: POP
45247: POP
45248: POP
45249: POP
45250: GO 45260
// end ;
45252: GO 45159
45254: POP
45255: POP
// end ;
45256: GO 44967
45258: POP
45259: POP
// end ;
45260: LD_VAR 0 6
45264: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45265: LD_INT 0
45267: PPUSH
45268: PPUSH
45269: PPUSH
45270: PPUSH
// if not mc_bases or not skirmish then
45271: LD_EXP 50
45275: NOT
45276: PUSH
45277: LD_EXP 48
45281: NOT
45282: OR
45283: IFFALSE 45287
// exit ;
45285: GO 45564
// side := GetSide ( lab ) ;
45287: LD_ADDR_VAR 0 4
45291: PUSH
45292: LD_VAR 0 2
45296: PPUSH
45297: CALL_OW 255
45301: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45302: LD_VAR 0 4
45306: PUSH
45307: LD_EXP 76
45311: IN
45312: NOT
45313: PUSH
45314: LD_EXP 77
45318: NOT
45319: OR
45320: PUSH
45321: LD_EXP 50
45325: NOT
45326: OR
45327: IFFALSE 45331
// exit ;
45329: GO 45564
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45331: LD_ADDR_EXP 77
45335: PUSH
45336: LD_EXP 77
45340: PPUSH
45341: LD_VAR 0 4
45345: PPUSH
45346: LD_EXP 77
45350: PUSH
45351: LD_VAR 0 4
45355: ARRAY
45356: PUSH
45357: LD_VAR 0 1
45361: DIFF
45362: PPUSH
45363: CALL_OW 1
45367: ST_TO_ADDR
// for i = 1 to mc_bases do
45368: LD_ADDR_VAR 0 5
45372: PUSH
45373: DOUBLE
45374: LD_INT 1
45376: DEC
45377: ST_TO_ADDR
45378: LD_EXP 50
45382: PUSH
45383: FOR_TO
45384: IFFALSE 45562
// begin if lab in mc_bases [ i ] then
45386: LD_VAR 0 2
45390: PUSH
45391: LD_EXP 50
45395: PUSH
45396: LD_VAR 0 5
45400: ARRAY
45401: IN
45402: IFFALSE 45560
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45404: LD_VAR 0 1
45408: PUSH
45409: LD_INT 11
45411: PUSH
45412: LD_INT 4
45414: PUSH
45415: LD_INT 3
45417: PUSH
45418: LD_INT 2
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: IN
45427: PUSH
45428: LD_EXP 80
45432: PUSH
45433: LD_VAR 0 5
45437: ARRAY
45438: AND
45439: IFFALSE 45560
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45441: LD_ADDR_VAR 0 6
45445: PUSH
45446: LD_EXP 80
45450: PUSH
45451: LD_VAR 0 5
45455: ARRAY
45456: PUSH
45457: LD_INT 1
45459: ARRAY
45460: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45461: LD_ADDR_EXP 80
45465: PUSH
45466: LD_EXP 80
45470: PPUSH
45471: LD_VAR 0 5
45475: PPUSH
45476: EMPTY
45477: PPUSH
45478: CALL_OW 1
45482: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45483: LD_VAR 0 6
45487: PPUSH
45488: LD_INT 0
45490: PPUSH
45491: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45495: LD_VAR 0 6
45499: PPUSH
45500: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45504: LD_ADDR_EXP 79
45508: PUSH
45509: LD_EXP 79
45513: PPUSH
45514: LD_VAR 0 5
45518: PPUSH
45519: LD_EXP 79
45523: PUSH
45524: LD_VAR 0 5
45528: ARRAY
45529: PPUSH
45530: LD_INT 1
45532: PPUSH
45533: LD_VAR 0 6
45537: PPUSH
45538: CALL_OW 2
45542: PPUSH
45543: CALL_OW 1
45547: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45548: LD_VAR 0 5
45552: PPUSH
45553: LD_INT 112
45555: PPUSH
45556: CALL 22083 0 2
// end ; end ; end ;
45560: GO 45383
45562: POP
45563: POP
// end ;
45564: LD_VAR 0 3
45568: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45569: LD_INT 0
45571: PPUSH
45572: PPUSH
45573: PPUSH
45574: PPUSH
45575: PPUSH
45576: PPUSH
45577: PPUSH
45578: PPUSH
// if not mc_bases or not skirmish then
45579: LD_EXP 50
45583: NOT
45584: PUSH
45585: LD_EXP 48
45589: NOT
45590: OR
45591: IFFALSE 45595
// exit ;
45593: GO 46966
// for i = 1 to mc_bases do
45595: LD_ADDR_VAR 0 3
45599: PUSH
45600: DOUBLE
45601: LD_INT 1
45603: DEC
45604: ST_TO_ADDR
45605: LD_EXP 50
45609: PUSH
45610: FOR_TO
45611: IFFALSE 46964
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45613: LD_VAR 0 1
45617: PUSH
45618: LD_EXP 50
45622: PUSH
45623: LD_VAR 0 3
45627: ARRAY
45628: IN
45629: PUSH
45630: LD_VAR 0 1
45634: PUSH
45635: LD_EXP 57
45639: PUSH
45640: LD_VAR 0 3
45644: ARRAY
45645: IN
45646: OR
45647: PUSH
45648: LD_VAR 0 1
45652: PUSH
45653: LD_EXP 72
45657: PUSH
45658: LD_VAR 0 3
45662: ARRAY
45663: IN
45664: OR
45665: PUSH
45666: LD_VAR 0 1
45670: PUSH
45671: LD_EXP 69
45675: PUSH
45676: LD_VAR 0 3
45680: ARRAY
45681: IN
45682: OR
45683: PUSH
45684: LD_VAR 0 1
45688: PUSH
45689: LD_EXP 79
45693: PUSH
45694: LD_VAR 0 3
45698: ARRAY
45699: IN
45700: OR
45701: PUSH
45702: LD_VAR 0 1
45706: PUSH
45707: LD_EXP 80
45711: PUSH
45712: LD_VAR 0 3
45716: ARRAY
45717: IN
45718: OR
45719: IFFALSE 46962
// begin if un in mc_ape [ i ] then
45721: LD_VAR 0 1
45725: PUSH
45726: LD_EXP 79
45730: PUSH
45731: LD_VAR 0 3
45735: ARRAY
45736: IN
45737: IFFALSE 45776
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45739: LD_ADDR_EXP 79
45743: PUSH
45744: LD_EXP 79
45748: PPUSH
45749: LD_VAR 0 3
45753: PPUSH
45754: LD_EXP 79
45758: PUSH
45759: LD_VAR 0 3
45763: ARRAY
45764: PUSH
45765: LD_VAR 0 1
45769: DIFF
45770: PPUSH
45771: CALL_OW 1
45775: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45776: LD_VAR 0 1
45780: PUSH
45781: LD_EXP 80
45785: PUSH
45786: LD_VAR 0 3
45790: ARRAY
45791: IN
45792: IFFALSE 45816
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45794: LD_ADDR_EXP 80
45798: PUSH
45799: LD_EXP 80
45803: PPUSH
45804: LD_VAR 0 3
45808: PPUSH
45809: EMPTY
45810: PPUSH
45811: CALL_OW 1
45815: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45816: LD_VAR 0 1
45820: PPUSH
45821: CALL_OW 247
45825: PUSH
45826: LD_INT 2
45828: EQUAL
45829: PUSH
45830: LD_VAR 0 1
45834: PPUSH
45835: CALL_OW 110
45839: PUSH
45840: LD_INT 20
45842: EQUAL
45843: PUSH
45844: LD_VAR 0 1
45848: PUSH
45849: LD_EXP 72
45853: PUSH
45854: LD_VAR 0 3
45858: ARRAY
45859: IN
45860: OR
45861: PUSH
45862: LD_VAR 0 1
45866: PPUSH
45867: CALL_OW 264
45871: PUSH
45872: LD_INT 12
45874: PUSH
45875: LD_INT 51
45877: PUSH
45878: LD_EXP 95
45882: PUSH
45883: LD_INT 32
45885: PUSH
45886: LD_INT 13
45888: PUSH
45889: LD_INT 52
45891: PUSH
45892: LD_INT 31
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: IN
45904: OR
45905: AND
45906: IFFALSE 46214
// begin if un in mc_defender [ i ] then
45908: LD_VAR 0 1
45912: PUSH
45913: LD_EXP 72
45917: PUSH
45918: LD_VAR 0 3
45922: ARRAY
45923: IN
45924: IFFALSE 45963
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45926: LD_ADDR_EXP 72
45930: PUSH
45931: LD_EXP 72
45935: PPUSH
45936: LD_VAR 0 3
45940: PPUSH
45941: LD_EXP 72
45945: PUSH
45946: LD_VAR 0 3
45950: ARRAY
45951: PUSH
45952: LD_VAR 0 1
45956: DIFF
45957: PPUSH
45958: CALL_OW 1
45962: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45963: LD_ADDR_VAR 0 8
45967: PUSH
45968: LD_VAR 0 3
45972: PPUSH
45973: LD_INT 3
45975: PPUSH
45976: CALL 42604 0 2
45980: ST_TO_ADDR
// if fac then
45981: LD_VAR 0 8
45985: IFFALSE 46214
// begin for j in fac do
45987: LD_ADDR_VAR 0 4
45991: PUSH
45992: LD_VAR 0 8
45996: PUSH
45997: FOR_IN
45998: IFFALSE 46212
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46000: LD_ADDR_VAR 0 9
46004: PUSH
46005: LD_VAR 0 8
46009: PPUSH
46010: LD_VAR 0 1
46014: PPUSH
46015: CALL_OW 265
46019: PPUSH
46020: LD_VAR 0 1
46024: PPUSH
46025: CALL_OW 262
46029: PPUSH
46030: LD_VAR 0 1
46034: PPUSH
46035: CALL_OW 263
46039: PPUSH
46040: LD_VAR 0 1
46044: PPUSH
46045: CALL_OW 264
46049: PPUSH
46050: CALL 51037 0 5
46054: ST_TO_ADDR
// if components then
46055: LD_VAR 0 9
46059: IFFALSE 46210
// begin if GetWeapon ( un ) = ar_control_tower then
46061: LD_VAR 0 1
46065: PPUSH
46066: CALL_OW 264
46070: PUSH
46071: LD_INT 31
46073: EQUAL
46074: IFFALSE 46191
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46076: LD_VAR 0 1
46080: PPUSH
46081: CALL_OW 311
46085: PPUSH
46086: LD_INT 0
46088: PPUSH
46089: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46093: LD_ADDR_EXP 90
46097: PUSH
46098: LD_EXP 90
46102: PPUSH
46103: LD_VAR 0 3
46107: PPUSH
46108: LD_EXP 90
46112: PUSH
46113: LD_VAR 0 3
46117: ARRAY
46118: PUSH
46119: LD_VAR 0 1
46123: PPUSH
46124: CALL_OW 311
46128: DIFF
46129: PPUSH
46130: CALL_OW 1
46134: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46135: LD_ADDR_VAR 0 7
46139: PUSH
46140: LD_EXP 71
46144: PUSH
46145: LD_VAR 0 3
46149: ARRAY
46150: PPUSH
46151: LD_INT 1
46153: PPUSH
46154: LD_VAR 0 9
46158: PPUSH
46159: CALL_OW 2
46163: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46164: LD_ADDR_EXP 71
46168: PUSH
46169: LD_EXP 71
46173: PPUSH
46174: LD_VAR 0 3
46178: PPUSH
46179: LD_VAR 0 7
46183: PPUSH
46184: CALL_OW 1
46188: ST_TO_ADDR
// end else
46189: GO 46208
// MC_InsertProduceList ( i , [ components ] ) ;
46191: LD_VAR 0 3
46195: PPUSH
46196: LD_VAR 0 9
46200: PUSH
46201: EMPTY
46202: LIST
46203: PPUSH
46204: CALL 42149 0 2
// break ;
46208: GO 46212
// end ; end ;
46210: GO 45997
46212: POP
46213: POP
// end ; end ; if GetType ( un ) = unit_building then
46214: LD_VAR 0 1
46218: PPUSH
46219: CALL_OW 247
46223: PUSH
46224: LD_INT 3
46226: EQUAL
46227: IFFALSE 46630
// begin btype := GetBType ( un ) ;
46229: LD_ADDR_VAR 0 5
46233: PUSH
46234: LD_VAR 0 1
46238: PPUSH
46239: CALL_OW 266
46243: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46244: LD_VAR 0 5
46248: PUSH
46249: LD_INT 29
46251: PUSH
46252: LD_INT 30
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: IN
46259: IFFALSE 46332
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46261: LD_VAR 0 1
46265: PPUSH
46266: CALL_OW 250
46270: PPUSH
46271: LD_VAR 0 1
46275: PPUSH
46276: CALL_OW 251
46280: PPUSH
46281: LD_VAR 0 1
46285: PPUSH
46286: CALL_OW 255
46290: PPUSH
46291: CALL_OW 440
46295: NOT
46296: IFFALSE 46332
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46298: LD_VAR 0 1
46302: PPUSH
46303: CALL_OW 250
46307: PPUSH
46308: LD_VAR 0 1
46312: PPUSH
46313: CALL_OW 251
46317: PPUSH
46318: LD_VAR 0 1
46322: PPUSH
46323: CALL_OW 255
46327: PPUSH
46328: CALL_OW 441
// end ; if btype = b_warehouse then
46332: LD_VAR 0 5
46336: PUSH
46337: LD_INT 1
46339: EQUAL
46340: IFFALSE 46358
// begin btype := b_depot ;
46342: LD_ADDR_VAR 0 5
46346: PUSH
46347: LD_INT 0
46349: ST_TO_ADDR
// pos := 1 ;
46350: LD_ADDR_VAR 0 6
46354: PUSH
46355: LD_INT 1
46357: ST_TO_ADDR
// end ; if btype = b_factory then
46358: LD_VAR 0 5
46362: PUSH
46363: LD_INT 3
46365: EQUAL
46366: IFFALSE 46384
// begin btype := b_workshop ;
46368: LD_ADDR_VAR 0 5
46372: PUSH
46373: LD_INT 2
46375: ST_TO_ADDR
// pos := 1 ;
46376: LD_ADDR_VAR 0 6
46380: PUSH
46381: LD_INT 1
46383: ST_TO_ADDR
// end ; if btype = b_barracks then
46384: LD_VAR 0 5
46388: PUSH
46389: LD_INT 5
46391: EQUAL
46392: IFFALSE 46402
// btype := b_armoury ;
46394: LD_ADDR_VAR 0 5
46398: PUSH
46399: LD_INT 4
46401: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46402: LD_VAR 0 5
46406: PUSH
46407: LD_INT 7
46409: PUSH
46410: LD_INT 8
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: IN
46417: IFFALSE 46427
// btype := b_lab ;
46419: LD_ADDR_VAR 0 5
46423: PUSH
46424: LD_INT 6
46426: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46427: LD_ADDR_EXP 55
46431: PUSH
46432: LD_EXP 55
46436: PPUSH
46437: LD_VAR 0 3
46441: PUSH
46442: LD_EXP 55
46446: PUSH
46447: LD_VAR 0 3
46451: ARRAY
46452: PUSH
46453: LD_INT 1
46455: PLUS
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PPUSH
46461: LD_VAR 0 5
46465: PUSH
46466: LD_VAR 0 1
46470: PPUSH
46471: CALL_OW 250
46475: PUSH
46476: LD_VAR 0 1
46480: PPUSH
46481: CALL_OW 251
46485: PUSH
46486: LD_VAR 0 1
46490: PPUSH
46491: CALL_OW 254
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: PPUSH
46502: CALL 53541 0 3
46506: ST_TO_ADDR
// if pos = 1 then
46507: LD_VAR 0 6
46511: PUSH
46512: LD_INT 1
46514: EQUAL
46515: IFFALSE 46630
// begin tmp := mc_build_list [ i ] ;
46517: LD_ADDR_VAR 0 7
46521: PUSH
46522: LD_EXP 55
46526: PUSH
46527: LD_VAR 0 3
46531: ARRAY
46532: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46533: LD_VAR 0 7
46537: PPUSH
46538: LD_INT 2
46540: PUSH
46541: LD_INT 30
46543: PUSH
46544: LD_INT 0
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: PUSH
46551: LD_INT 30
46553: PUSH
46554: LD_INT 1
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: LIST
46565: PPUSH
46566: CALL_OW 72
46570: IFFALSE 46580
// pos := 2 ;
46572: LD_ADDR_VAR 0 6
46576: PUSH
46577: LD_INT 2
46579: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46580: LD_ADDR_VAR 0 7
46584: PUSH
46585: LD_VAR 0 7
46589: PPUSH
46590: LD_VAR 0 6
46594: PPUSH
46595: LD_VAR 0 7
46599: PPUSH
46600: CALL 53867 0 3
46604: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46605: LD_ADDR_EXP 55
46609: PUSH
46610: LD_EXP 55
46614: PPUSH
46615: LD_VAR 0 3
46619: PPUSH
46620: LD_VAR 0 7
46624: PPUSH
46625: CALL_OW 1
46629: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46630: LD_VAR 0 1
46634: PUSH
46635: LD_EXP 50
46639: PUSH
46640: LD_VAR 0 3
46644: ARRAY
46645: IN
46646: IFFALSE 46685
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46648: LD_ADDR_EXP 50
46652: PUSH
46653: LD_EXP 50
46657: PPUSH
46658: LD_VAR 0 3
46662: PPUSH
46663: LD_EXP 50
46667: PUSH
46668: LD_VAR 0 3
46672: ARRAY
46673: PUSH
46674: LD_VAR 0 1
46678: DIFF
46679: PPUSH
46680: CALL_OW 1
46684: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46685: LD_VAR 0 1
46689: PUSH
46690: LD_EXP 57
46694: PUSH
46695: LD_VAR 0 3
46699: ARRAY
46700: IN
46701: IFFALSE 46740
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46703: LD_ADDR_EXP 57
46707: PUSH
46708: LD_EXP 57
46712: PPUSH
46713: LD_VAR 0 3
46717: PPUSH
46718: LD_EXP 57
46722: PUSH
46723: LD_VAR 0 3
46727: ARRAY
46728: PUSH
46729: LD_VAR 0 1
46733: DIFF
46734: PPUSH
46735: CALL_OW 1
46739: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46740: LD_VAR 0 1
46744: PUSH
46745: LD_EXP 69
46749: PUSH
46750: LD_VAR 0 3
46754: ARRAY
46755: IN
46756: IFFALSE 46795
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46758: LD_ADDR_EXP 69
46762: PUSH
46763: LD_EXP 69
46767: PPUSH
46768: LD_VAR 0 3
46772: PPUSH
46773: LD_EXP 69
46777: PUSH
46778: LD_VAR 0 3
46782: ARRAY
46783: PUSH
46784: LD_VAR 0 1
46788: DIFF
46789: PPUSH
46790: CALL_OW 1
46794: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46795: LD_VAR 0 1
46799: PUSH
46800: LD_EXP 72
46804: PUSH
46805: LD_VAR 0 3
46809: ARRAY
46810: IN
46811: IFFALSE 46850
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46813: LD_ADDR_EXP 72
46817: PUSH
46818: LD_EXP 72
46822: PPUSH
46823: LD_VAR 0 3
46827: PPUSH
46828: LD_EXP 72
46832: PUSH
46833: LD_VAR 0 3
46837: ARRAY
46838: PUSH
46839: LD_VAR 0 1
46843: DIFF
46844: PPUSH
46845: CALL_OW 1
46849: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46850: LD_VAR 0 1
46854: PUSH
46855: LD_EXP 59
46859: PUSH
46860: LD_VAR 0 3
46864: ARRAY
46865: IN
46866: IFFALSE 46905
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46868: LD_ADDR_EXP 59
46872: PUSH
46873: LD_EXP 59
46877: PPUSH
46878: LD_VAR 0 3
46882: PPUSH
46883: LD_EXP 59
46887: PUSH
46888: LD_VAR 0 3
46892: ARRAY
46893: PUSH
46894: LD_VAR 0 1
46898: DIFF
46899: PPUSH
46900: CALL_OW 1
46904: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46905: LD_VAR 0 1
46909: PUSH
46910: LD_EXP 58
46914: PUSH
46915: LD_VAR 0 3
46919: ARRAY
46920: IN
46921: IFFALSE 46960
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46923: LD_ADDR_EXP 58
46927: PUSH
46928: LD_EXP 58
46932: PPUSH
46933: LD_VAR 0 3
46937: PPUSH
46938: LD_EXP 58
46942: PUSH
46943: LD_VAR 0 3
46947: ARRAY
46948: PUSH
46949: LD_VAR 0 1
46953: DIFF
46954: PPUSH
46955: CALL_OW 1
46959: ST_TO_ADDR
// end ; break ;
46960: GO 46964
// end ;
46962: GO 45610
46964: POP
46965: POP
// end ;
46966: LD_VAR 0 2
46970: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46971: LD_INT 0
46973: PPUSH
46974: PPUSH
46975: PPUSH
// if not mc_bases or not skirmish then
46976: LD_EXP 50
46980: NOT
46981: PUSH
46982: LD_EXP 48
46986: NOT
46987: OR
46988: IFFALSE 46992
// exit ;
46990: GO 47207
// for i = 1 to mc_bases do
46992: LD_ADDR_VAR 0 3
46996: PUSH
46997: DOUBLE
46998: LD_INT 1
47000: DEC
47001: ST_TO_ADDR
47002: LD_EXP 50
47006: PUSH
47007: FOR_TO
47008: IFFALSE 47205
// begin if building in mc_construct_list [ i ] then
47010: LD_VAR 0 1
47014: PUSH
47015: LD_EXP 57
47019: PUSH
47020: LD_VAR 0 3
47024: ARRAY
47025: IN
47026: IFFALSE 47203
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47028: LD_ADDR_EXP 57
47032: PUSH
47033: LD_EXP 57
47037: PPUSH
47038: LD_VAR 0 3
47042: PPUSH
47043: LD_EXP 57
47047: PUSH
47048: LD_VAR 0 3
47052: ARRAY
47053: PUSH
47054: LD_VAR 0 1
47058: DIFF
47059: PPUSH
47060: CALL_OW 1
47064: ST_TO_ADDR
// if building in mc_lab [ i ] then
47065: LD_VAR 0 1
47069: PUSH
47070: LD_EXP 83
47074: PUSH
47075: LD_VAR 0 3
47079: ARRAY
47080: IN
47081: IFFALSE 47136
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47083: LD_ADDR_EXP 84
47087: PUSH
47088: LD_EXP 84
47092: PPUSH
47093: LD_VAR 0 3
47097: PPUSH
47098: LD_EXP 84
47102: PUSH
47103: LD_VAR 0 3
47107: ARRAY
47108: PPUSH
47109: LD_INT 1
47111: PPUSH
47112: LD_EXP 84
47116: PUSH
47117: LD_VAR 0 3
47121: ARRAY
47122: PPUSH
47123: LD_INT 0
47125: PPUSH
47126: CALL 52959 0 4
47130: PPUSH
47131: CALL_OW 1
47135: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47136: LD_VAR 0 1
47140: PUSH
47141: LD_EXP 50
47145: PUSH
47146: LD_VAR 0 3
47150: ARRAY
47151: IN
47152: NOT
47153: IFFALSE 47199
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47155: LD_ADDR_EXP 50
47159: PUSH
47160: LD_EXP 50
47164: PPUSH
47165: LD_VAR 0 3
47169: PUSH
47170: LD_EXP 50
47174: PUSH
47175: LD_VAR 0 3
47179: ARRAY
47180: PUSH
47181: LD_INT 1
47183: PLUS
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PPUSH
47189: LD_VAR 0 1
47193: PPUSH
47194: CALL 53541 0 3
47198: ST_TO_ADDR
// exit ;
47199: POP
47200: POP
47201: GO 47207
// end ; end ;
47203: GO 47007
47205: POP
47206: POP
// end ;
47207: LD_VAR 0 2
47211: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47212: LD_INT 0
47214: PPUSH
47215: PPUSH
47216: PPUSH
47217: PPUSH
47218: PPUSH
47219: PPUSH
47220: PPUSH
// if not mc_bases or not skirmish then
47221: LD_EXP 50
47225: NOT
47226: PUSH
47227: LD_EXP 48
47231: NOT
47232: OR
47233: IFFALSE 47237
// exit ;
47235: GO 47898
// for i = 1 to mc_bases do
47237: LD_ADDR_VAR 0 3
47241: PUSH
47242: DOUBLE
47243: LD_INT 1
47245: DEC
47246: ST_TO_ADDR
47247: LD_EXP 50
47251: PUSH
47252: FOR_TO
47253: IFFALSE 47896
// begin if building in mc_construct_list [ i ] then
47255: LD_VAR 0 1
47259: PUSH
47260: LD_EXP 57
47264: PUSH
47265: LD_VAR 0 3
47269: ARRAY
47270: IN
47271: IFFALSE 47894
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47273: LD_ADDR_EXP 57
47277: PUSH
47278: LD_EXP 57
47282: PPUSH
47283: LD_VAR 0 3
47287: PPUSH
47288: LD_EXP 57
47292: PUSH
47293: LD_VAR 0 3
47297: ARRAY
47298: PUSH
47299: LD_VAR 0 1
47303: DIFF
47304: PPUSH
47305: CALL_OW 1
47309: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47310: LD_ADDR_EXP 50
47314: PUSH
47315: LD_EXP 50
47319: PPUSH
47320: LD_VAR 0 3
47324: PUSH
47325: LD_EXP 50
47329: PUSH
47330: LD_VAR 0 3
47334: ARRAY
47335: PUSH
47336: LD_INT 1
47338: PLUS
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PPUSH
47344: LD_VAR 0 1
47348: PPUSH
47349: CALL 53541 0 3
47353: ST_TO_ADDR
// btype := GetBType ( building ) ;
47354: LD_ADDR_VAR 0 5
47358: PUSH
47359: LD_VAR 0 1
47363: PPUSH
47364: CALL_OW 266
47368: ST_TO_ADDR
// side := GetSide ( building ) ;
47369: LD_ADDR_VAR 0 8
47373: PUSH
47374: LD_VAR 0 1
47378: PPUSH
47379: CALL_OW 255
47383: ST_TO_ADDR
// if btype = b_lab then
47384: LD_VAR 0 5
47388: PUSH
47389: LD_INT 6
47391: EQUAL
47392: IFFALSE 47442
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47394: LD_ADDR_EXP 83
47398: PUSH
47399: LD_EXP 83
47403: PPUSH
47404: LD_VAR 0 3
47408: PUSH
47409: LD_EXP 83
47413: PUSH
47414: LD_VAR 0 3
47418: ARRAY
47419: PUSH
47420: LD_INT 1
47422: PLUS
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PPUSH
47428: LD_VAR 0 1
47432: PPUSH
47433: CALL 53541 0 3
47437: ST_TO_ADDR
// exit ;
47438: POP
47439: POP
47440: GO 47898
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47442: LD_VAR 0 5
47446: PUSH
47447: LD_INT 0
47449: PUSH
47450: LD_INT 2
47452: PUSH
47453: LD_INT 4
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: LIST
47460: IN
47461: IFFALSE 47585
// begin if btype = b_armoury then
47463: LD_VAR 0 5
47467: PUSH
47468: LD_INT 4
47470: EQUAL
47471: IFFALSE 47481
// btype := b_barracks ;
47473: LD_ADDR_VAR 0 5
47477: PUSH
47478: LD_INT 5
47480: ST_TO_ADDR
// if btype = b_depot then
47481: LD_VAR 0 5
47485: PUSH
47486: LD_INT 0
47488: EQUAL
47489: IFFALSE 47499
// btype := b_warehouse ;
47491: LD_ADDR_VAR 0 5
47495: PUSH
47496: LD_INT 1
47498: ST_TO_ADDR
// if btype = b_workshop then
47499: LD_VAR 0 5
47503: PUSH
47504: LD_INT 2
47506: EQUAL
47507: IFFALSE 47517
// btype := b_factory ;
47509: LD_ADDR_VAR 0 5
47513: PUSH
47514: LD_INT 3
47516: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47517: LD_VAR 0 5
47521: PPUSH
47522: LD_VAR 0 8
47526: PPUSH
47527: CALL_OW 323
47531: PUSH
47532: LD_INT 1
47534: EQUAL
47535: IFFALSE 47581
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47537: LD_ADDR_EXP 82
47541: PUSH
47542: LD_EXP 82
47546: PPUSH
47547: LD_VAR 0 3
47551: PUSH
47552: LD_EXP 82
47556: PUSH
47557: LD_VAR 0 3
47561: ARRAY
47562: PUSH
47563: LD_INT 1
47565: PLUS
47566: PUSH
47567: EMPTY
47568: LIST
47569: LIST
47570: PPUSH
47571: LD_VAR 0 1
47575: PPUSH
47576: CALL 53541 0 3
47580: ST_TO_ADDR
// exit ;
47581: POP
47582: POP
47583: GO 47898
// end ; if btype in [ b_bunker , b_turret ] then
47585: LD_VAR 0 5
47589: PUSH
47590: LD_INT 32
47592: PUSH
47593: LD_INT 33
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: IN
47600: IFFALSE 47890
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47602: LD_ADDR_EXP 58
47606: PUSH
47607: LD_EXP 58
47611: PPUSH
47612: LD_VAR 0 3
47616: PUSH
47617: LD_EXP 58
47621: PUSH
47622: LD_VAR 0 3
47626: ARRAY
47627: PUSH
47628: LD_INT 1
47630: PLUS
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: PPUSH
47636: LD_VAR 0 1
47640: PPUSH
47641: CALL 53541 0 3
47645: ST_TO_ADDR
// if btype = b_bunker then
47646: LD_VAR 0 5
47650: PUSH
47651: LD_INT 32
47653: EQUAL
47654: IFFALSE 47890
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47656: LD_ADDR_EXP 59
47660: PUSH
47661: LD_EXP 59
47665: PPUSH
47666: LD_VAR 0 3
47670: PUSH
47671: LD_EXP 59
47675: PUSH
47676: LD_VAR 0 3
47680: ARRAY
47681: PUSH
47682: LD_INT 1
47684: PLUS
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: PPUSH
47690: LD_VAR 0 1
47694: PPUSH
47695: CALL 53541 0 3
47699: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47700: LD_ADDR_VAR 0 6
47704: PUSH
47705: LD_EXP 50
47709: PUSH
47710: LD_VAR 0 3
47714: ARRAY
47715: PPUSH
47716: LD_INT 25
47718: PUSH
47719: LD_INT 1
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PUSH
47726: LD_INT 3
47728: PUSH
47729: LD_INT 54
47731: PUSH
47732: EMPTY
47733: LIST
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PPUSH
47743: CALL_OW 72
47747: ST_TO_ADDR
// if tmp then
47748: LD_VAR 0 6
47752: IFFALSE 47758
// exit ;
47754: POP
47755: POP
47756: GO 47898
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47758: LD_ADDR_VAR 0 6
47762: PUSH
47763: LD_EXP 50
47767: PUSH
47768: LD_VAR 0 3
47772: ARRAY
47773: PPUSH
47774: LD_INT 2
47776: PUSH
47777: LD_INT 30
47779: PUSH
47780: LD_INT 4
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PUSH
47787: LD_INT 30
47789: PUSH
47790: LD_INT 5
47792: PUSH
47793: EMPTY
47794: LIST
47795: LIST
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: LIST
47801: PPUSH
47802: CALL_OW 72
47806: ST_TO_ADDR
// if not tmp then
47807: LD_VAR 0 6
47811: NOT
47812: IFFALSE 47818
// exit ;
47814: POP
47815: POP
47816: GO 47898
// for j in tmp do
47818: LD_ADDR_VAR 0 4
47822: PUSH
47823: LD_VAR 0 6
47827: PUSH
47828: FOR_IN
47829: IFFALSE 47888
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47831: LD_ADDR_VAR 0 7
47835: PUSH
47836: LD_VAR 0 4
47840: PPUSH
47841: CALL_OW 313
47845: PPUSH
47846: LD_INT 25
47848: PUSH
47849: LD_INT 1
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: PPUSH
47856: CALL_OW 72
47860: ST_TO_ADDR
// if units then
47861: LD_VAR 0 7
47865: IFFALSE 47886
// begin ComExitBuilding ( units [ 1 ] ) ;
47867: LD_VAR 0 7
47871: PUSH
47872: LD_INT 1
47874: ARRAY
47875: PPUSH
47876: CALL_OW 122
// exit ;
47880: POP
47881: POP
47882: POP
47883: POP
47884: GO 47898
// end ; end ;
47886: GO 47828
47888: POP
47889: POP
// end ; end ; exit ;
47890: POP
47891: POP
47892: GO 47898
// end ; end ;
47894: GO 47252
47896: POP
47897: POP
// end ;
47898: LD_VAR 0 2
47902: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47903: LD_INT 0
47905: PPUSH
47906: PPUSH
47907: PPUSH
47908: PPUSH
47909: PPUSH
47910: PPUSH
47911: PPUSH
// if not mc_bases or not skirmish then
47912: LD_EXP 50
47916: NOT
47917: PUSH
47918: LD_EXP 48
47922: NOT
47923: OR
47924: IFFALSE 47928
// exit ;
47926: GO 48193
// btype := GetBType ( building ) ;
47928: LD_ADDR_VAR 0 6
47932: PUSH
47933: LD_VAR 0 1
47937: PPUSH
47938: CALL_OW 266
47942: ST_TO_ADDR
// x := GetX ( building ) ;
47943: LD_ADDR_VAR 0 7
47947: PUSH
47948: LD_VAR 0 1
47952: PPUSH
47953: CALL_OW 250
47957: ST_TO_ADDR
// y := GetY ( building ) ;
47958: LD_ADDR_VAR 0 8
47962: PUSH
47963: LD_VAR 0 1
47967: PPUSH
47968: CALL_OW 251
47972: ST_TO_ADDR
// d := GetDir ( building ) ;
47973: LD_ADDR_VAR 0 9
47977: PUSH
47978: LD_VAR 0 1
47982: PPUSH
47983: CALL_OW 254
47987: ST_TO_ADDR
// for i = 1 to mc_bases do
47988: LD_ADDR_VAR 0 4
47992: PUSH
47993: DOUBLE
47994: LD_INT 1
47996: DEC
47997: ST_TO_ADDR
47998: LD_EXP 50
48002: PUSH
48003: FOR_TO
48004: IFFALSE 48191
// begin if not mc_build_list [ i ] then
48006: LD_EXP 55
48010: PUSH
48011: LD_VAR 0 4
48015: ARRAY
48016: NOT
48017: IFFALSE 48021
// continue ;
48019: GO 48003
// for j := 1 to mc_build_list [ i ] do
48021: LD_ADDR_VAR 0 5
48025: PUSH
48026: DOUBLE
48027: LD_INT 1
48029: DEC
48030: ST_TO_ADDR
48031: LD_EXP 55
48035: PUSH
48036: LD_VAR 0 4
48040: ARRAY
48041: PUSH
48042: FOR_TO
48043: IFFALSE 48187
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48045: LD_VAR 0 6
48049: PUSH
48050: LD_VAR 0 7
48054: PUSH
48055: LD_VAR 0 8
48059: PUSH
48060: LD_VAR 0 9
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: PPUSH
48071: LD_EXP 55
48075: PUSH
48076: LD_VAR 0 4
48080: ARRAY
48081: PUSH
48082: LD_VAR 0 5
48086: ARRAY
48087: PPUSH
48088: CALL 59723 0 2
48092: IFFALSE 48185
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48094: LD_ADDR_EXP 55
48098: PUSH
48099: LD_EXP 55
48103: PPUSH
48104: LD_VAR 0 4
48108: PPUSH
48109: LD_EXP 55
48113: PUSH
48114: LD_VAR 0 4
48118: ARRAY
48119: PPUSH
48120: LD_VAR 0 5
48124: PPUSH
48125: CALL_OW 3
48129: PPUSH
48130: CALL_OW 1
48134: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48135: LD_ADDR_EXP 57
48139: PUSH
48140: LD_EXP 57
48144: PPUSH
48145: LD_VAR 0 4
48149: PUSH
48150: LD_EXP 57
48154: PUSH
48155: LD_VAR 0 4
48159: ARRAY
48160: PUSH
48161: LD_INT 1
48163: PLUS
48164: PUSH
48165: EMPTY
48166: LIST
48167: LIST
48168: PPUSH
48169: LD_VAR 0 1
48173: PPUSH
48174: CALL 53541 0 3
48178: ST_TO_ADDR
// exit ;
48179: POP
48180: POP
48181: POP
48182: POP
48183: GO 48193
// end ;
48185: GO 48042
48187: POP
48188: POP
// end ;
48189: GO 48003
48191: POP
48192: POP
// end ;
48193: LD_VAR 0 3
48197: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48198: LD_INT 0
48200: PPUSH
48201: PPUSH
48202: PPUSH
// if not mc_bases or not skirmish then
48203: LD_EXP 50
48207: NOT
48208: PUSH
48209: LD_EXP 48
48213: NOT
48214: OR
48215: IFFALSE 48219
// exit ;
48217: GO 48409
// for i = 1 to mc_bases do
48219: LD_ADDR_VAR 0 4
48223: PUSH
48224: DOUBLE
48225: LD_INT 1
48227: DEC
48228: ST_TO_ADDR
48229: LD_EXP 50
48233: PUSH
48234: FOR_TO
48235: IFFALSE 48322
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48237: LD_VAR 0 1
48241: PUSH
48242: LD_EXP 58
48246: PUSH
48247: LD_VAR 0 4
48251: ARRAY
48252: IN
48253: PUSH
48254: LD_VAR 0 1
48258: PUSH
48259: LD_EXP 59
48263: PUSH
48264: LD_VAR 0 4
48268: ARRAY
48269: IN
48270: NOT
48271: AND
48272: IFFALSE 48320
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48274: LD_ADDR_EXP 59
48278: PUSH
48279: LD_EXP 59
48283: PPUSH
48284: LD_VAR 0 4
48288: PUSH
48289: LD_EXP 59
48293: PUSH
48294: LD_VAR 0 4
48298: ARRAY
48299: PUSH
48300: LD_INT 1
48302: PLUS
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: PPUSH
48308: LD_VAR 0 1
48312: PPUSH
48313: CALL 53541 0 3
48317: ST_TO_ADDR
// break ;
48318: GO 48322
// end ; end ;
48320: GO 48234
48322: POP
48323: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48324: LD_VAR 0 1
48328: PPUSH
48329: CALL_OW 257
48333: PUSH
48334: LD_EXP 76
48338: IN
48339: PUSH
48340: LD_VAR 0 1
48344: PPUSH
48345: CALL_OW 266
48349: PUSH
48350: LD_INT 5
48352: EQUAL
48353: AND
48354: PUSH
48355: LD_VAR 0 2
48359: PPUSH
48360: CALL_OW 110
48364: PUSH
48365: LD_INT 18
48367: NONEQUAL
48368: AND
48369: IFFALSE 48409
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48371: LD_VAR 0 2
48375: PPUSH
48376: CALL_OW 257
48380: PUSH
48381: LD_INT 5
48383: PUSH
48384: LD_INT 8
48386: PUSH
48387: LD_INT 9
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: LIST
48394: IN
48395: IFFALSE 48409
// SetClass ( unit , 1 ) ;
48397: LD_VAR 0 2
48401: PPUSH
48402: LD_INT 1
48404: PPUSH
48405: CALL_OW 336
// end ;
48409: LD_VAR 0 3
48413: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48414: LD_INT 0
48416: PPUSH
48417: PPUSH
// if not mc_bases or not skirmish then
48418: LD_EXP 50
48422: NOT
48423: PUSH
48424: LD_EXP 48
48428: NOT
48429: OR
48430: IFFALSE 48434
// exit ;
48432: GO 48550
// if GetLives ( abandoned_vehicle ) > 250 then
48434: LD_VAR 0 2
48438: PPUSH
48439: CALL_OW 256
48443: PUSH
48444: LD_INT 250
48446: GREATER
48447: IFFALSE 48451
// exit ;
48449: GO 48550
// for i = 1 to mc_bases do
48451: LD_ADDR_VAR 0 6
48455: PUSH
48456: DOUBLE
48457: LD_INT 1
48459: DEC
48460: ST_TO_ADDR
48461: LD_EXP 50
48465: PUSH
48466: FOR_TO
48467: IFFALSE 48548
// begin if driver in mc_bases [ i ] then
48469: LD_VAR 0 1
48473: PUSH
48474: LD_EXP 50
48478: PUSH
48479: LD_VAR 0 6
48483: ARRAY
48484: IN
48485: IFFALSE 48546
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48487: LD_VAR 0 1
48491: PPUSH
48492: LD_EXP 50
48496: PUSH
48497: LD_VAR 0 6
48501: ARRAY
48502: PPUSH
48503: LD_INT 2
48505: PUSH
48506: LD_INT 30
48508: PUSH
48509: LD_INT 0
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: PUSH
48516: LD_INT 30
48518: PUSH
48519: LD_INT 1
48521: PUSH
48522: EMPTY
48523: LIST
48524: LIST
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: LIST
48530: PPUSH
48531: CALL_OW 72
48535: PUSH
48536: LD_INT 1
48538: ARRAY
48539: PPUSH
48540: CALL 86159 0 2
// break ;
48544: GO 48548
// end ; end ;
48546: GO 48466
48548: POP
48549: POP
// end ; end_of_file
48550: LD_VAR 0 5
48554: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48555: LD_INT 0
48557: PPUSH
48558: PPUSH
// if exist_mode then
48559: LD_VAR 0 2
48563: IFFALSE 48588
// unit := CreateCharacter ( prefix & ident ) else
48565: LD_ADDR_VAR 0 5
48569: PUSH
48570: LD_VAR 0 3
48574: PUSH
48575: LD_VAR 0 1
48579: STR
48580: PPUSH
48581: CALL_OW 34
48585: ST_TO_ADDR
48586: GO 48603
// unit := NewCharacter ( ident ) ;
48588: LD_ADDR_VAR 0 5
48592: PUSH
48593: LD_VAR 0 1
48597: PPUSH
48598: CALL_OW 25
48602: ST_TO_ADDR
// result := unit ;
48603: LD_ADDR_VAR 0 4
48607: PUSH
48608: LD_VAR 0 5
48612: ST_TO_ADDR
// end ;
48613: LD_VAR 0 4
48617: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48618: LD_INT 0
48620: PPUSH
48621: PPUSH
// if not side or not nation then
48622: LD_VAR 0 1
48626: NOT
48627: PUSH
48628: LD_VAR 0 2
48632: NOT
48633: OR
48634: IFFALSE 48638
// exit ;
48636: GO 49406
// case nation of nation_american :
48638: LD_VAR 0 2
48642: PUSH
48643: LD_INT 1
48645: DOUBLE
48646: EQUAL
48647: IFTRUE 48651
48649: GO 48865
48651: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48652: LD_ADDR_VAR 0 4
48656: PUSH
48657: LD_INT 35
48659: PUSH
48660: LD_INT 45
48662: PUSH
48663: LD_INT 46
48665: PUSH
48666: LD_INT 47
48668: PUSH
48669: LD_INT 82
48671: PUSH
48672: LD_INT 83
48674: PUSH
48675: LD_INT 84
48677: PUSH
48678: LD_INT 85
48680: PUSH
48681: LD_INT 86
48683: PUSH
48684: LD_INT 1
48686: PUSH
48687: LD_INT 2
48689: PUSH
48690: LD_INT 6
48692: PUSH
48693: LD_INT 15
48695: PUSH
48696: LD_INT 16
48698: PUSH
48699: LD_INT 7
48701: PUSH
48702: LD_INT 12
48704: PUSH
48705: LD_INT 13
48707: PUSH
48708: LD_INT 10
48710: PUSH
48711: LD_INT 14
48713: PUSH
48714: LD_INT 20
48716: PUSH
48717: LD_INT 21
48719: PUSH
48720: LD_INT 22
48722: PUSH
48723: LD_INT 25
48725: PUSH
48726: LD_INT 32
48728: PUSH
48729: LD_INT 27
48731: PUSH
48732: LD_INT 36
48734: PUSH
48735: LD_INT 69
48737: PUSH
48738: LD_INT 39
48740: PUSH
48741: LD_INT 34
48743: PUSH
48744: LD_INT 40
48746: PUSH
48747: LD_INT 48
48749: PUSH
48750: LD_INT 49
48752: PUSH
48753: LD_INT 50
48755: PUSH
48756: LD_INT 51
48758: PUSH
48759: LD_INT 52
48761: PUSH
48762: LD_INT 53
48764: PUSH
48765: LD_INT 54
48767: PUSH
48768: LD_INT 55
48770: PUSH
48771: LD_INT 56
48773: PUSH
48774: LD_INT 57
48776: PUSH
48777: LD_INT 58
48779: PUSH
48780: LD_INT 59
48782: PUSH
48783: LD_INT 60
48785: PUSH
48786: LD_INT 61
48788: PUSH
48789: LD_INT 62
48791: PUSH
48792: LD_INT 80
48794: PUSH
48795: LD_INT 82
48797: PUSH
48798: LD_INT 83
48800: PUSH
48801: LD_INT 84
48803: PUSH
48804: LD_INT 85
48806: PUSH
48807: LD_INT 86
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: LIST
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: LIST
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: ST_TO_ADDR
48863: GO 49330
48865: LD_INT 2
48867: DOUBLE
48868: EQUAL
48869: IFTRUE 48873
48871: GO 49099
48873: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48874: LD_ADDR_VAR 0 4
48878: PUSH
48879: LD_INT 35
48881: PUSH
48882: LD_INT 45
48884: PUSH
48885: LD_INT 46
48887: PUSH
48888: LD_INT 47
48890: PUSH
48891: LD_INT 82
48893: PUSH
48894: LD_INT 83
48896: PUSH
48897: LD_INT 84
48899: PUSH
48900: LD_INT 85
48902: PUSH
48903: LD_INT 87
48905: PUSH
48906: LD_INT 70
48908: PUSH
48909: LD_INT 1
48911: PUSH
48912: LD_INT 11
48914: PUSH
48915: LD_INT 3
48917: PUSH
48918: LD_INT 4
48920: PUSH
48921: LD_INT 5
48923: PUSH
48924: LD_INT 6
48926: PUSH
48927: LD_INT 15
48929: PUSH
48930: LD_INT 18
48932: PUSH
48933: LD_INT 7
48935: PUSH
48936: LD_INT 17
48938: PUSH
48939: LD_INT 8
48941: PUSH
48942: LD_INT 20
48944: PUSH
48945: LD_INT 21
48947: PUSH
48948: LD_INT 22
48950: PUSH
48951: LD_INT 72
48953: PUSH
48954: LD_INT 26
48956: PUSH
48957: LD_INT 69
48959: PUSH
48960: LD_INT 39
48962: PUSH
48963: LD_INT 40
48965: PUSH
48966: LD_INT 41
48968: PUSH
48969: LD_INT 42
48971: PUSH
48972: LD_INT 43
48974: PUSH
48975: LD_INT 48
48977: PUSH
48978: LD_INT 49
48980: PUSH
48981: LD_INT 50
48983: PUSH
48984: LD_INT 51
48986: PUSH
48987: LD_INT 52
48989: PUSH
48990: LD_INT 53
48992: PUSH
48993: LD_INT 54
48995: PUSH
48996: LD_INT 55
48998: PUSH
48999: LD_INT 56
49001: PUSH
49002: LD_INT 60
49004: PUSH
49005: LD_INT 61
49007: PUSH
49008: LD_INT 62
49010: PUSH
49011: LD_INT 66
49013: PUSH
49014: LD_INT 67
49016: PUSH
49017: LD_INT 68
49019: PUSH
49020: LD_INT 81
49022: PUSH
49023: LD_INT 82
49025: PUSH
49026: LD_INT 83
49028: PUSH
49029: LD_INT 84
49031: PUSH
49032: LD_INT 85
49034: PUSH
49035: LD_INT 87
49037: PUSH
49038: LD_INT 88
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: LIST
49045: LIST
49046: LIST
49047: LIST
49048: LIST
49049: LIST
49050: LIST
49051: LIST
49052: LIST
49053: LIST
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: ST_TO_ADDR
49097: GO 49330
49099: LD_INT 3
49101: DOUBLE
49102: EQUAL
49103: IFTRUE 49107
49105: GO 49329
49107: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49108: LD_ADDR_VAR 0 4
49112: PUSH
49113: LD_INT 46
49115: PUSH
49116: LD_INT 47
49118: PUSH
49119: LD_INT 1
49121: PUSH
49122: LD_INT 2
49124: PUSH
49125: LD_INT 82
49127: PUSH
49128: LD_INT 83
49130: PUSH
49131: LD_INT 84
49133: PUSH
49134: LD_INT 85
49136: PUSH
49137: LD_INT 86
49139: PUSH
49140: LD_INT 11
49142: PUSH
49143: LD_INT 9
49145: PUSH
49146: LD_INT 20
49148: PUSH
49149: LD_INT 19
49151: PUSH
49152: LD_INT 21
49154: PUSH
49155: LD_INT 24
49157: PUSH
49158: LD_INT 22
49160: PUSH
49161: LD_INT 25
49163: PUSH
49164: LD_INT 28
49166: PUSH
49167: LD_INT 29
49169: PUSH
49170: LD_INT 30
49172: PUSH
49173: LD_INT 31
49175: PUSH
49176: LD_INT 37
49178: PUSH
49179: LD_INT 38
49181: PUSH
49182: LD_INT 32
49184: PUSH
49185: LD_INT 27
49187: PUSH
49188: LD_INT 33
49190: PUSH
49191: LD_INT 69
49193: PUSH
49194: LD_INT 39
49196: PUSH
49197: LD_INT 34
49199: PUSH
49200: LD_INT 40
49202: PUSH
49203: LD_INT 71
49205: PUSH
49206: LD_INT 23
49208: PUSH
49209: LD_INT 44
49211: PUSH
49212: LD_INT 48
49214: PUSH
49215: LD_INT 49
49217: PUSH
49218: LD_INT 50
49220: PUSH
49221: LD_INT 51
49223: PUSH
49224: LD_INT 52
49226: PUSH
49227: LD_INT 53
49229: PUSH
49230: LD_INT 54
49232: PUSH
49233: LD_INT 55
49235: PUSH
49236: LD_INT 56
49238: PUSH
49239: LD_INT 57
49241: PUSH
49242: LD_INT 58
49244: PUSH
49245: LD_INT 59
49247: PUSH
49248: LD_INT 63
49250: PUSH
49251: LD_INT 64
49253: PUSH
49254: LD_INT 65
49256: PUSH
49257: LD_INT 82
49259: PUSH
49260: LD_INT 83
49262: PUSH
49263: LD_INT 84
49265: PUSH
49266: LD_INT 85
49268: PUSH
49269: LD_INT 86
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: LIST
49280: LIST
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: LIST
49288: LIST
49289: LIST
49290: LIST
49291: LIST
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: ST_TO_ADDR
49327: GO 49330
49329: POP
// if state > - 1 and state < 3 then
49330: LD_VAR 0 3
49334: PUSH
49335: LD_INT 1
49337: NEG
49338: GREATER
49339: PUSH
49340: LD_VAR 0 3
49344: PUSH
49345: LD_INT 3
49347: LESS
49348: AND
49349: IFFALSE 49406
// for i in result do
49351: LD_ADDR_VAR 0 5
49355: PUSH
49356: LD_VAR 0 4
49360: PUSH
49361: FOR_IN
49362: IFFALSE 49404
// if GetTech ( i , side ) <> state then
49364: LD_VAR 0 5
49368: PPUSH
49369: LD_VAR 0 1
49373: PPUSH
49374: CALL_OW 321
49378: PUSH
49379: LD_VAR 0 3
49383: NONEQUAL
49384: IFFALSE 49402
// result := result diff i ;
49386: LD_ADDR_VAR 0 4
49390: PUSH
49391: LD_VAR 0 4
49395: PUSH
49396: LD_VAR 0 5
49400: DIFF
49401: ST_TO_ADDR
49402: GO 49361
49404: POP
49405: POP
// end ;
49406: LD_VAR 0 4
49410: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49411: LD_INT 0
49413: PPUSH
49414: PPUSH
49415: PPUSH
// result := true ;
49416: LD_ADDR_VAR 0 3
49420: PUSH
49421: LD_INT 1
49423: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49424: LD_ADDR_VAR 0 5
49428: PUSH
49429: LD_VAR 0 2
49433: PPUSH
49434: CALL_OW 480
49438: ST_TO_ADDR
// if not tmp then
49439: LD_VAR 0 5
49443: NOT
49444: IFFALSE 49448
// exit ;
49446: GO 49497
// for i in tmp do
49448: LD_ADDR_VAR 0 4
49452: PUSH
49453: LD_VAR 0 5
49457: PUSH
49458: FOR_IN
49459: IFFALSE 49495
// if GetTech ( i , side ) <> state_researched then
49461: LD_VAR 0 4
49465: PPUSH
49466: LD_VAR 0 1
49470: PPUSH
49471: CALL_OW 321
49475: PUSH
49476: LD_INT 2
49478: NONEQUAL
49479: IFFALSE 49493
// begin result := false ;
49481: LD_ADDR_VAR 0 3
49485: PUSH
49486: LD_INT 0
49488: ST_TO_ADDR
// exit ;
49489: POP
49490: POP
49491: GO 49497
// end ;
49493: GO 49458
49495: POP
49496: POP
// end ;
49497: LD_VAR 0 3
49501: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49502: LD_INT 0
49504: PPUSH
49505: PPUSH
49506: PPUSH
49507: PPUSH
49508: PPUSH
49509: PPUSH
49510: PPUSH
49511: PPUSH
49512: PPUSH
49513: PPUSH
49514: PPUSH
49515: PPUSH
49516: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49517: LD_VAR 0 1
49521: NOT
49522: PUSH
49523: LD_VAR 0 1
49527: PPUSH
49528: CALL_OW 257
49532: PUSH
49533: LD_INT 9
49535: NONEQUAL
49536: OR
49537: IFFALSE 49541
// exit ;
49539: GO 50114
// side := GetSide ( unit ) ;
49541: LD_ADDR_VAR 0 9
49545: PUSH
49546: LD_VAR 0 1
49550: PPUSH
49551: CALL_OW 255
49555: ST_TO_ADDR
// tech_space := tech_spacanom ;
49556: LD_ADDR_VAR 0 12
49560: PUSH
49561: LD_INT 29
49563: ST_TO_ADDR
// tech_time := tech_taurad ;
49564: LD_ADDR_VAR 0 13
49568: PUSH
49569: LD_INT 28
49571: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49572: LD_ADDR_VAR 0 11
49576: PUSH
49577: LD_VAR 0 1
49581: PPUSH
49582: CALL_OW 310
49586: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49587: LD_VAR 0 11
49591: PPUSH
49592: CALL_OW 247
49596: PUSH
49597: LD_INT 2
49599: EQUAL
49600: IFFALSE 49604
// exit ;
49602: GO 50114
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49604: LD_ADDR_VAR 0 8
49608: PUSH
49609: LD_INT 81
49611: PUSH
49612: LD_VAR 0 9
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PUSH
49621: LD_INT 3
49623: PUSH
49624: LD_INT 21
49626: PUSH
49627: LD_INT 3
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PUSH
49634: EMPTY
49635: LIST
49636: LIST
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PPUSH
49642: CALL_OW 69
49646: ST_TO_ADDR
// if not tmp then
49647: LD_VAR 0 8
49651: NOT
49652: IFFALSE 49656
// exit ;
49654: GO 50114
// if in_unit then
49656: LD_VAR 0 11
49660: IFFALSE 49684
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49662: LD_ADDR_VAR 0 10
49666: PUSH
49667: LD_VAR 0 8
49671: PPUSH
49672: LD_VAR 0 11
49676: PPUSH
49677: CALL_OW 74
49681: ST_TO_ADDR
49682: GO 49704
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49684: LD_ADDR_VAR 0 10
49688: PUSH
49689: LD_VAR 0 8
49693: PPUSH
49694: LD_VAR 0 1
49698: PPUSH
49699: CALL_OW 74
49703: ST_TO_ADDR
// if not enemy then
49704: LD_VAR 0 10
49708: NOT
49709: IFFALSE 49713
// exit ;
49711: GO 50114
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49713: LD_VAR 0 11
49717: PUSH
49718: LD_VAR 0 11
49722: PPUSH
49723: LD_VAR 0 10
49727: PPUSH
49728: CALL_OW 296
49732: PUSH
49733: LD_INT 13
49735: GREATER
49736: AND
49737: PUSH
49738: LD_VAR 0 1
49742: PPUSH
49743: LD_VAR 0 10
49747: PPUSH
49748: CALL_OW 296
49752: PUSH
49753: LD_INT 12
49755: GREATER
49756: OR
49757: IFFALSE 49761
// exit ;
49759: GO 50114
// missile := [ 1 ] ;
49761: LD_ADDR_VAR 0 14
49765: PUSH
49766: LD_INT 1
49768: PUSH
49769: EMPTY
49770: LIST
49771: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49772: LD_VAR 0 9
49776: PPUSH
49777: LD_VAR 0 12
49781: PPUSH
49782: CALL_OW 325
49786: IFFALSE 49815
// missile := Insert ( missile , missile + 1 , 2 ) ;
49788: LD_ADDR_VAR 0 14
49792: PUSH
49793: LD_VAR 0 14
49797: PPUSH
49798: LD_VAR 0 14
49802: PUSH
49803: LD_INT 1
49805: PLUS
49806: PPUSH
49807: LD_INT 2
49809: PPUSH
49810: CALL_OW 2
49814: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49815: LD_VAR 0 9
49819: PPUSH
49820: LD_VAR 0 13
49824: PPUSH
49825: CALL_OW 325
49829: PUSH
49830: LD_VAR 0 10
49834: PPUSH
49835: CALL_OW 255
49839: PPUSH
49840: LD_VAR 0 13
49844: PPUSH
49845: CALL_OW 325
49849: NOT
49850: AND
49851: IFFALSE 49880
// missile := Insert ( missile , missile + 1 , 3 ) ;
49853: LD_ADDR_VAR 0 14
49857: PUSH
49858: LD_VAR 0 14
49862: PPUSH
49863: LD_VAR 0 14
49867: PUSH
49868: LD_INT 1
49870: PLUS
49871: PPUSH
49872: LD_INT 3
49874: PPUSH
49875: CALL_OW 2
49879: ST_TO_ADDR
// if missile < 2 then
49880: LD_VAR 0 14
49884: PUSH
49885: LD_INT 2
49887: LESS
49888: IFFALSE 49892
// exit ;
49890: GO 50114
// x := GetX ( enemy ) ;
49892: LD_ADDR_VAR 0 4
49896: PUSH
49897: LD_VAR 0 10
49901: PPUSH
49902: CALL_OW 250
49906: ST_TO_ADDR
// y := GetY ( enemy ) ;
49907: LD_ADDR_VAR 0 5
49911: PUSH
49912: LD_VAR 0 10
49916: PPUSH
49917: CALL_OW 251
49921: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49922: LD_ADDR_VAR 0 6
49926: PUSH
49927: LD_VAR 0 4
49931: PUSH
49932: LD_INT 1
49934: NEG
49935: PPUSH
49936: LD_INT 1
49938: PPUSH
49939: CALL_OW 12
49943: PLUS
49944: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49945: LD_ADDR_VAR 0 7
49949: PUSH
49950: LD_VAR 0 5
49954: PUSH
49955: LD_INT 1
49957: NEG
49958: PPUSH
49959: LD_INT 1
49961: PPUSH
49962: CALL_OW 12
49966: PLUS
49967: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49968: LD_VAR 0 6
49972: PPUSH
49973: LD_VAR 0 7
49977: PPUSH
49978: CALL_OW 488
49982: NOT
49983: IFFALSE 50005
// begin _x := x ;
49985: LD_ADDR_VAR 0 6
49989: PUSH
49990: LD_VAR 0 4
49994: ST_TO_ADDR
// _y := y ;
49995: LD_ADDR_VAR 0 7
49999: PUSH
50000: LD_VAR 0 5
50004: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50005: LD_ADDR_VAR 0 3
50009: PUSH
50010: LD_INT 1
50012: PPUSH
50013: LD_VAR 0 14
50017: PPUSH
50018: CALL_OW 12
50022: ST_TO_ADDR
// case i of 1 :
50023: LD_VAR 0 3
50027: PUSH
50028: LD_INT 1
50030: DOUBLE
50031: EQUAL
50032: IFTRUE 50036
50034: GO 50053
50036: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50037: LD_VAR 0 1
50041: PPUSH
50042: LD_VAR 0 10
50046: PPUSH
50047: CALL_OW 115
50051: GO 50114
50053: LD_INT 2
50055: DOUBLE
50056: EQUAL
50057: IFTRUE 50061
50059: GO 50083
50061: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50062: LD_VAR 0 1
50066: PPUSH
50067: LD_VAR 0 6
50071: PPUSH
50072: LD_VAR 0 7
50076: PPUSH
50077: CALL_OW 153
50081: GO 50114
50083: LD_INT 3
50085: DOUBLE
50086: EQUAL
50087: IFTRUE 50091
50089: GO 50113
50091: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50092: LD_VAR 0 1
50096: PPUSH
50097: LD_VAR 0 6
50101: PPUSH
50102: LD_VAR 0 7
50106: PPUSH
50107: CALL_OW 154
50111: GO 50114
50113: POP
// end ;
50114: LD_VAR 0 2
50118: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50119: LD_INT 0
50121: PPUSH
50122: PPUSH
50123: PPUSH
50124: PPUSH
50125: PPUSH
50126: PPUSH
// if not unit or not building then
50127: LD_VAR 0 1
50131: NOT
50132: PUSH
50133: LD_VAR 0 2
50137: NOT
50138: OR
50139: IFFALSE 50143
// exit ;
50141: GO 50301
// x := GetX ( building ) ;
50143: LD_ADDR_VAR 0 5
50147: PUSH
50148: LD_VAR 0 2
50152: PPUSH
50153: CALL_OW 250
50157: ST_TO_ADDR
// y := GetY ( building ) ;
50158: LD_ADDR_VAR 0 6
50162: PUSH
50163: LD_VAR 0 2
50167: PPUSH
50168: CALL_OW 251
50172: ST_TO_ADDR
// for i = 0 to 5 do
50173: LD_ADDR_VAR 0 4
50177: PUSH
50178: DOUBLE
50179: LD_INT 0
50181: DEC
50182: ST_TO_ADDR
50183: LD_INT 5
50185: PUSH
50186: FOR_TO
50187: IFFALSE 50299
// begin _x := ShiftX ( x , i , 3 ) ;
50189: LD_ADDR_VAR 0 7
50193: PUSH
50194: LD_VAR 0 5
50198: PPUSH
50199: LD_VAR 0 4
50203: PPUSH
50204: LD_INT 3
50206: PPUSH
50207: CALL_OW 272
50211: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50212: LD_ADDR_VAR 0 8
50216: PUSH
50217: LD_VAR 0 6
50221: PPUSH
50222: LD_VAR 0 4
50226: PPUSH
50227: LD_INT 3
50229: PPUSH
50230: CALL_OW 273
50234: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50235: LD_VAR 0 7
50239: PPUSH
50240: LD_VAR 0 8
50244: PPUSH
50245: CALL_OW 488
50249: NOT
50250: IFFALSE 50254
// continue ;
50252: GO 50186
// if HexInfo ( _x , _y ) = 0 then
50254: LD_VAR 0 7
50258: PPUSH
50259: LD_VAR 0 8
50263: PPUSH
50264: CALL_OW 428
50268: PUSH
50269: LD_INT 0
50271: EQUAL
50272: IFFALSE 50297
// begin ComMoveXY ( unit , _x , _y ) ;
50274: LD_VAR 0 1
50278: PPUSH
50279: LD_VAR 0 7
50283: PPUSH
50284: LD_VAR 0 8
50288: PPUSH
50289: CALL_OW 111
// exit ;
50293: POP
50294: POP
50295: GO 50301
// end ; end ;
50297: GO 50186
50299: POP
50300: POP
// end ;
50301: LD_VAR 0 3
50305: RET
// export function ScanBase ( side , base_area ) ; begin
50306: LD_INT 0
50308: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50309: LD_ADDR_VAR 0 3
50313: PUSH
50314: LD_VAR 0 2
50318: PPUSH
50319: LD_INT 81
50321: PUSH
50322: LD_VAR 0 1
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PPUSH
50331: CALL_OW 70
50335: ST_TO_ADDR
// end ;
50336: LD_VAR 0 3
50340: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50341: LD_INT 0
50343: PPUSH
50344: PPUSH
50345: PPUSH
50346: PPUSH
// result := false ;
50347: LD_ADDR_VAR 0 2
50351: PUSH
50352: LD_INT 0
50354: ST_TO_ADDR
// side := GetSide ( unit ) ;
50355: LD_ADDR_VAR 0 3
50359: PUSH
50360: LD_VAR 0 1
50364: PPUSH
50365: CALL_OW 255
50369: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50370: LD_ADDR_VAR 0 4
50374: PUSH
50375: LD_VAR 0 1
50379: PPUSH
50380: CALL_OW 248
50384: ST_TO_ADDR
// case nat of 1 :
50385: LD_VAR 0 4
50389: PUSH
50390: LD_INT 1
50392: DOUBLE
50393: EQUAL
50394: IFTRUE 50398
50396: GO 50409
50398: POP
// tech := tech_lassight ; 2 :
50399: LD_ADDR_VAR 0 5
50403: PUSH
50404: LD_INT 12
50406: ST_TO_ADDR
50407: GO 50448
50409: LD_INT 2
50411: DOUBLE
50412: EQUAL
50413: IFTRUE 50417
50415: GO 50428
50417: POP
// tech := tech_mortar ; 3 :
50418: LD_ADDR_VAR 0 5
50422: PUSH
50423: LD_INT 41
50425: ST_TO_ADDR
50426: GO 50448
50428: LD_INT 3
50430: DOUBLE
50431: EQUAL
50432: IFTRUE 50436
50434: GO 50447
50436: POP
// tech := tech_bazooka ; end ;
50437: LD_ADDR_VAR 0 5
50441: PUSH
50442: LD_INT 44
50444: ST_TO_ADDR
50445: GO 50448
50447: POP
// if Researched ( side , tech ) then
50448: LD_VAR 0 3
50452: PPUSH
50453: LD_VAR 0 5
50457: PPUSH
50458: CALL_OW 325
50462: IFFALSE 50489
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50464: LD_ADDR_VAR 0 2
50468: PUSH
50469: LD_INT 5
50471: PUSH
50472: LD_INT 8
50474: PUSH
50475: LD_INT 9
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: LIST
50482: PUSH
50483: LD_VAR 0 4
50487: ARRAY
50488: ST_TO_ADDR
// end ;
50489: LD_VAR 0 2
50493: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50494: LD_INT 0
50496: PPUSH
50497: PPUSH
50498: PPUSH
// if not mines then
50499: LD_VAR 0 2
50503: NOT
50504: IFFALSE 50508
// exit ;
50506: GO 50652
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50508: LD_ADDR_VAR 0 5
50512: PUSH
50513: LD_INT 81
50515: PUSH
50516: LD_VAR 0 1
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 3
50527: PUSH
50528: LD_INT 21
50530: PUSH
50531: LD_INT 3
50533: PUSH
50534: EMPTY
50535: LIST
50536: LIST
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: PUSH
50542: EMPTY
50543: LIST
50544: LIST
50545: PPUSH
50546: CALL_OW 69
50550: ST_TO_ADDR
// for i in mines do
50551: LD_ADDR_VAR 0 4
50555: PUSH
50556: LD_VAR 0 2
50560: PUSH
50561: FOR_IN
50562: IFFALSE 50650
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50564: LD_VAR 0 4
50568: PUSH
50569: LD_INT 1
50571: ARRAY
50572: PPUSH
50573: LD_VAR 0 4
50577: PUSH
50578: LD_INT 2
50580: ARRAY
50581: PPUSH
50582: CALL_OW 458
50586: NOT
50587: IFFALSE 50591
// continue ;
50589: GO 50561
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50591: LD_VAR 0 4
50595: PUSH
50596: LD_INT 1
50598: ARRAY
50599: PPUSH
50600: LD_VAR 0 4
50604: PUSH
50605: LD_INT 2
50607: ARRAY
50608: PPUSH
50609: CALL_OW 428
50613: PUSH
50614: LD_VAR 0 5
50618: IN
50619: IFFALSE 50648
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50621: LD_VAR 0 4
50625: PUSH
50626: LD_INT 1
50628: ARRAY
50629: PPUSH
50630: LD_VAR 0 4
50634: PUSH
50635: LD_INT 2
50637: ARRAY
50638: PPUSH
50639: LD_VAR 0 1
50643: PPUSH
50644: CALL_OW 456
// end ;
50648: GO 50561
50650: POP
50651: POP
// end ;
50652: LD_VAR 0 3
50656: RET
// export function Count ( array ) ; var i ; begin
50657: LD_INT 0
50659: PPUSH
50660: PPUSH
// result := 0 ;
50661: LD_ADDR_VAR 0 2
50665: PUSH
50666: LD_INT 0
50668: ST_TO_ADDR
// for i in array do
50669: LD_ADDR_VAR 0 3
50673: PUSH
50674: LD_VAR 0 1
50678: PUSH
50679: FOR_IN
50680: IFFALSE 50704
// if i then
50682: LD_VAR 0 3
50686: IFFALSE 50702
// result := result + 1 ;
50688: LD_ADDR_VAR 0 2
50692: PUSH
50693: LD_VAR 0 2
50697: PUSH
50698: LD_INT 1
50700: PLUS
50701: ST_TO_ADDR
50702: GO 50679
50704: POP
50705: POP
// end ;
50706: LD_VAR 0 2
50710: RET
// export function IsEmpty ( building ) ; begin
50711: LD_INT 0
50713: PPUSH
// if not building then
50714: LD_VAR 0 1
50718: NOT
50719: IFFALSE 50723
// exit ;
50721: GO 50766
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50723: LD_ADDR_VAR 0 2
50727: PUSH
50728: LD_VAR 0 1
50732: PUSH
50733: LD_INT 22
50735: PUSH
50736: LD_VAR 0 1
50740: PPUSH
50741: CALL_OW 255
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 58
50752: PUSH
50753: EMPTY
50754: LIST
50755: PUSH
50756: EMPTY
50757: LIST
50758: LIST
50759: PPUSH
50760: CALL_OW 69
50764: IN
50765: ST_TO_ADDR
// end ;
50766: LD_VAR 0 2
50770: RET
// export function IsNotFull ( building ) ; begin
50771: LD_INT 0
50773: PPUSH
// if not building then
50774: LD_VAR 0 1
50778: NOT
50779: IFFALSE 50783
// exit ;
50781: GO 50802
// result := UnitsInside ( building ) < 6 ;
50783: LD_ADDR_VAR 0 2
50787: PUSH
50788: LD_VAR 0 1
50792: PPUSH
50793: CALL_OW 313
50797: PUSH
50798: LD_INT 6
50800: LESS
50801: ST_TO_ADDR
// end ;
50802: LD_VAR 0 2
50806: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50807: LD_INT 0
50809: PPUSH
50810: PPUSH
50811: PPUSH
50812: PPUSH
// tmp := [ ] ;
50813: LD_ADDR_VAR 0 3
50817: PUSH
50818: EMPTY
50819: ST_TO_ADDR
// list := [ ] ;
50820: LD_ADDR_VAR 0 5
50824: PUSH
50825: EMPTY
50826: ST_TO_ADDR
// for i = 16 to 25 do
50827: LD_ADDR_VAR 0 4
50831: PUSH
50832: DOUBLE
50833: LD_INT 16
50835: DEC
50836: ST_TO_ADDR
50837: LD_INT 25
50839: PUSH
50840: FOR_TO
50841: IFFALSE 50914
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50843: LD_ADDR_VAR 0 3
50847: PUSH
50848: LD_VAR 0 3
50852: PUSH
50853: LD_INT 22
50855: PUSH
50856: LD_VAR 0 1
50860: PPUSH
50861: CALL_OW 255
50865: PUSH
50866: EMPTY
50867: LIST
50868: LIST
50869: PUSH
50870: LD_INT 91
50872: PUSH
50873: LD_VAR 0 1
50877: PUSH
50878: LD_INT 6
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: LIST
50885: PUSH
50886: LD_INT 30
50888: PUSH
50889: LD_VAR 0 4
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: EMPTY
50899: LIST
50900: LIST
50901: LIST
50902: PUSH
50903: EMPTY
50904: LIST
50905: PPUSH
50906: CALL_OW 69
50910: ADD
50911: ST_TO_ADDR
50912: GO 50840
50914: POP
50915: POP
// for i = 1 to tmp do
50916: LD_ADDR_VAR 0 4
50920: PUSH
50921: DOUBLE
50922: LD_INT 1
50924: DEC
50925: ST_TO_ADDR
50926: LD_VAR 0 3
50930: PUSH
50931: FOR_TO
50932: IFFALSE 51020
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50934: LD_ADDR_VAR 0 5
50938: PUSH
50939: LD_VAR 0 5
50943: PUSH
50944: LD_VAR 0 3
50948: PUSH
50949: LD_VAR 0 4
50953: ARRAY
50954: PPUSH
50955: CALL_OW 266
50959: PUSH
50960: LD_VAR 0 3
50964: PUSH
50965: LD_VAR 0 4
50969: ARRAY
50970: PPUSH
50971: CALL_OW 250
50975: PUSH
50976: LD_VAR 0 3
50980: PUSH
50981: LD_VAR 0 4
50985: ARRAY
50986: PPUSH
50987: CALL_OW 251
50991: PUSH
50992: LD_VAR 0 3
50996: PUSH
50997: LD_VAR 0 4
51001: ARRAY
51002: PPUSH
51003: CALL_OW 254
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: LIST
51012: LIST
51013: PUSH
51014: EMPTY
51015: LIST
51016: ADD
51017: ST_TO_ADDR
51018: GO 50931
51020: POP
51021: POP
// result := list ;
51022: LD_ADDR_VAR 0 2
51026: PUSH
51027: LD_VAR 0 5
51031: ST_TO_ADDR
// end ;
51032: LD_VAR 0 2
51036: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51037: LD_INT 0
51039: PPUSH
51040: PPUSH
51041: PPUSH
51042: PPUSH
51043: PPUSH
51044: PPUSH
51045: PPUSH
// if not factory then
51046: LD_VAR 0 1
51050: NOT
51051: IFFALSE 51055
// exit ;
51053: GO 51648
// if control = control_apeman then
51055: LD_VAR 0 4
51059: PUSH
51060: LD_INT 5
51062: EQUAL
51063: IFFALSE 51172
// begin tmp := UnitsInside ( factory ) ;
51065: LD_ADDR_VAR 0 8
51069: PUSH
51070: LD_VAR 0 1
51074: PPUSH
51075: CALL_OW 313
51079: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51080: LD_VAR 0 8
51084: PPUSH
51085: LD_INT 25
51087: PUSH
51088: LD_INT 12
51090: PUSH
51091: EMPTY
51092: LIST
51093: LIST
51094: PPUSH
51095: CALL_OW 72
51099: NOT
51100: IFFALSE 51110
// control := control_manual ;
51102: LD_ADDR_VAR 0 4
51106: PUSH
51107: LD_INT 1
51109: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51110: LD_ADDR_VAR 0 8
51114: PUSH
51115: LD_VAR 0 1
51119: PPUSH
51120: CALL 50807 0 1
51124: ST_TO_ADDR
// if tmp then
51125: LD_VAR 0 8
51129: IFFALSE 51172
// begin for i in tmp do
51131: LD_ADDR_VAR 0 7
51135: PUSH
51136: LD_VAR 0 8
51140: PUSH
51141: FOR_IN
51142: IFFALSE 51170
// if i [ 1 ] = b_ext_radio then
51144: LD_VAR 0 7
51148: PUSH
51149: LD_INT 1
51151: ARRAY
51152: PUSH
51153: LD_INT 22
51155: EQUAL
51156: IFFALSE 51168
// begin control := control_remote ;
51158: LD_ADDR_VAR 0 4
51162: PUSH
51163: LD_INT 2
51165: ST_TO_ADDR
// break ;
51166: GO 51170
// end ;
51168: GO 51141
51170: POP
51171: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51172: LD_VAR 0 1
51176: PPUSH
51177: LD_VAR 0 2
51181: PPUSH
51182: LD_VAR 0 3
51186: PPUSH
51187: LD_VAR 0 4
51191: PPUSH
51192: LD_VAR 0 5
51196: PPUSH
51197: CALL_OW 448
51201: IFFALSE 51236
// begin result := [ chassis , engine , control , weapon ] ;
51203: LD_ADDR_VAR 0 6
51207: PUSH
51208: LD_VAR 0 2
51212: PUSH
51213: LD_VAR 0 3
51217: PUSH
51218: LD_VAR 0 4
51222: PUSH
51223: LD_VAR 0 5
51227: PUSH
51228: EMPTY
51229: LIST
51230: LIST
51231: LIST
51232: LIST
51233: ST_TO_ADDR
// exit ;
51234: GO 51648
// end ; _chassis := AvailableChassisList ( factory ) ;
51236: LD_ADDR_VAR 0 9
51240: PUSH
51241: LD_VAR 0 1
51245: PPUSH
51246: CALL_OW 475
51250: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51251: LD_ADDR_VAR 0 11
51255: PUSH
51256: LD_VAR 0 1
51260: PPUSH
51261: CALL_OW 476
51265: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51266: LD_ADDR_VAR 0 12
51270: PUSH
51271: LD_VAR 0 1
51275: PPUSH
51276: CALL_OW 477
51280: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51281: LD_ADDR_VAR 0 10
51285: PUSH
51286: LD_VAR 0 1
51290: PPUSH
51291: CALL_OW 478
51295: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51296: LD_VAR 0 9
51300: NOT
51301: PUSH
51302: LD_VAR 0 11
51306: NOT
51307: OR
51308: PUSH
51309: LD_VAR 0 12
51313: NOT
51314: OR
51315: PUSH
51316: LD_VAR 0 10
51320: NOT
51321: OR
51322: IFFALSE 51357
// begin result := [ chassis , engine , control , weapon ] ;
51324: LD_ADDR_VAR 0 6
51328: PUSH
51329: LD_VAR 0 2
51333: PUSH
51334: LD_VAR 0 3
51338: PUSH
51339: LD_VAR 0 4
51343: PUSH
51344: LD_VAR 0 5
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: ST_TO_ADDR
// exit ;
51355: GO 51648
// end ; if not chassis in _chassis then
51357: LD_VAR 0 2
51361: PUSH
51362: LD_VAR 0 9
51366: IN
51367: NOT
51368: IFFALSE 51394
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51370: LD_ADDR_VAR 0 2
51374: PUSH
51375: LD_VAR 0 9
51379: PUSH
51380: LD_INT 1
51382: PPUSH
51383: LD_VAR 0 9
51387: PPUSH
51388: CALL_OW 12
51392: ARRAY
51393: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51394: LD_VAR 0 2
51398: PPUSH
51399: LD_VAR 0 3
51403: PPUSH
51404: CALL 51653 0 2
51408: NOT
51409: IFFALSE 51468
// repeat engine := _engine [ 1 ] ;
51411: LD_ADDR_VAR 0 3
51415: PUSH
51416: LD_VAR 0 11
51420: PUSH
51421: LD_INT 1
51423: ARRAY
51424: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51425: LD_ADDR_VAR 0 11
51429: PUSH
51430: LD_VAR 0 11
51434: PPUSH
51435: LD_INT 1
51437: PPUSH
51438: CALL_OW 3
51442: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51443: LD_VAR 0 2
51447: PPUSH
51448: LD_VAR 0 3
51452: PPUSH
51453: CALL 51653 0 2
51457: PUSH
51458: LD_VAR 0 11
51462: PUSH
51463: EMPTY
51464: EQUAL
51465: OR
51466: IFFALSE 51411
// if not control in _control then
51468: LD_VAR 0 4
51472: PUSH
51473: LD_VAR 0 12
51477: IN
51478: NOT
51479: IFFALSE 51505
// control := _control [ rand ( 1 , _control ) ] ;
51481: LD_ADDR_VAR 0 4
51485: PUSH
51486: LD_VAR 0 12
51490: PUSH
51491: LD_INT 1
51493: PPUSH
51494: LD_VAR 0 12
51498: PPUSH
51499: CALL_OW 12
51503: ARRAY
51504: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51505: LD_VAR 0 2
51509: PPUSH
51510: LD_VAR 0 5
51514: PPUSH
51515: CALL 51873 0 2
51519: NOT
51520: IFFALSE 51579
// repeat weapon := _weapon [ 1 ] ;
51522: LD_ADDR_VAR 0 5
51526: PUSH
51527: LD_VAR 0 10
51531: PUSH
51532: LD_INT 1
51534: ARRAY
51535: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51536: LD_ADDR_VAR 0 10
51540: PUSH
51541: LD_VAR 0 10
51545: PPUSH
51546: LD_INT 1
51548: PPUSH
51549: CALL_OW 3
51553: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51554: LD_VAR 0 2
51558: PPUSH
51559: LD_VAR 0 5
51563: PPUSH
51564: CALL 51873 0 2
51568: PUSH
51569: LD_VAR 0 10
51573: PUSH
51574: EMPTY
51575: EQUAL
51576: OR
51577: IFFALSE 51522
// result := [ ] ;
51579: LD_ADDR_VAR 0 6
51583: PUSH
51584: EMPTY
51585: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51586: LD_VAR 0 1
51590: PPUSH
51591: LD_VAR 0 2
51595: PPUSH
51596: LD_VAR 0 3
51600: PPUSH
51601: LD_VAR 0 4
51605: PPUSH
51606: LD_VAR 0 5
51610: PPUSH
51611: CALL_OW 448
51615: IFFALSE 51648
// result := [ chassis , engine , control , weapon ] ;
51617: LD_ADDR_VAR 0 6
51621: PUSH
51622: LD_VAR 0 2
51626: PUSH
51627: LD_VAR 0 3
51631: PUSH
51632: LD_VAR 0 4
51636: PUSH
51637: LD_VAR 0 5
51641: PUSH
51642: EMPTY
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: ST_TO_ADDR
// end ;
51648: LD_VAR 0 6
51652: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51653: LD_INT 0
51655: PPUSH
// if not chassis or not engine then
51656: LD_VAR 0 1
51660: NOT
51661: PUSH
51662: LD_VAR 0 2
51666: NOT
51667: OR
51668: IFFALSE 51672
// exit ;
51670: GO 51868
// case engine of engine_solar :
51672: LD_VAR 0 2
51676: PUSH
51677: LD_INT 2
51679: DOUBLE
51680: EQUAL
51681: IFTRUE 51685
51683: GO 51723
51685: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51686: LD_ADDR_VAR 0 3
51690: PUSH
51691: LD_INT 11
51693: PUSH
51694: LD_INT 12
51696: PUSH
51697: LD_INT 13
51699: PUSH
51700: LD_INT 14
51702: PUSH
51703: LD_INT 1
51705: PUSH
51706: LD_INT 2
51708: PUSH
51709: LD_INT 3
51711: PUSH
51712: EMPTY
51713: LIST
51714: LIST
51715: LIST
51716: LIST
51717: LIST
51718: LIST
51719: LIST
51720: ST_TO_ADDR
51721: GO 51852
51723: LD_INT 1
51725: DOUBLE
51726: EQUAL
51727: IFTRUE 51731
51729: GO 51793
51731: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51732: LD_ADDR_VAR 0 3
51736: PUSH
51737: LD_INT 11
51739: PUSH
51740: LD_INT 12
51742: PUSH
51743: LD_INT 13
51745: PUSH
51746: LD_INT 14
51748: PUSH
51749: LD_INT 1
51751: PUSH
51752: LD_INT 2
51754: PUSH
51755: LD_INT 3
51757: PUSH
51758: LD_INT 4
51760: PUSH
51761: LD_INT 5
51763: PUSH
51764: LD_INT 21
51766: PUSH
51767: LD_INT 23
51769: PUSH
51770: LD_INT 22
51772: PUSH
51773: LD_INT 24
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: LIST
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: LIST
51789: LIST
51790: ST_TO_ADDR
51791: GO 51852
51793: LD_INT 3
51795: DOUBLE
51796: EQUAL
51797: IFTRUE 51801
51799: GO 51851
51801: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51802: LD_ADDR_VAR 0 3
51806: PUSH
51807: LD_INT 13
51809: PUSH
51810: LD_INT 14
51812: PUSH
51813: LD_INT 2
51815: PUSH
51816: LD_INT 3
51818: PUSH
51819: LD_INT 4
51821: PUSH
51822: LD_INT 5
51824: PUSH
51825: LD_INT 21
51827: PUSH
51828: LD_INT 22
51830: PUSH
51831: LD_INT 23
51833: PUSH
51834: LD_INT 24
51836: PUSH
51837: EMPTY
51838: LIST
51839: LIST
51840: LIST
51841: LIST
51842: LIST
51843: LIST
51844: LIST
51845: LIST
51846: LIST
51847: LIST
51848: ST_TO_ADDR
51849: GO 51852
51851: POP
// result := ( chassis in result ) ;
51852: LD_ADDR_VAR 0 3
51856: PUSH
51857: LD_VAR 0 1
51861: PUSH
51862: LD_VAR 0 3
51866: IN
51867: ST_TO_ADDR
// end ;
51868: LD_VAR 0 3
51872: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51873: LD_INT 0
51875: PPUSH
// if not chassis or not weapon then
51876: LD_VAR 0 1
51880: NOT
51881: PUSH
51882: LD_VAR 0 2
51886: NOT
51887: OR
51888: IFFALSE 51892
// exit ;
51890: GO 52954
// case weapon of us_machine_gun :
51892: LD_VAR 0 2
51896: PUSH
51897: LD_INT 2
51899: DOUBLE
51900: EQUAL
51901: IFTRUE 51905
51903: GO 51935
51905: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51906: LD_ADDR_VAR 0 3
51910: PUSH
51911: LD_INT 1
51913: PUSH
51914: LD_INT 2
51916: PUSH
51917: LD_INT 3
51919: PUSH
51920: LD_INT 4
51922: PUSH
51923: LD_INT 5
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: ST_TO_ADDR
51933: GO 52938
51935: LD_INT 3
51937: DOUBLE
51938: EQUAL
51939: IFTRUE 51943
51941: GO 51973
51943: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51944: LD_ADDR_VAR 0 3
51948: PUSH
51949: LD_INT 1
51951: PUSH
51952: LD_INT 2
51954: PUSH
51955: LD_INT 3
51957: PUSH
51958: LD_INT 4
51960: PUSH
51961: LD_INT 5
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: ST_TO_ADDR
51971: GO 52938
51973: LD_INT 11
51975: DOUBLE
51976: EQUAL
51977: IFTRUE 51981
51979: GO 52011
51981: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51982: LD_ADDR_VAR 0 3
51986: PUSH
51987: LD_INT 1
51989: PUSH
51990: LD_INT 2
51992: PUSH
51993: LD_INT 3
51995: PUSH
51996: LD_INT 4
51998: PUSH
51999: LD_INT 5
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: LIST
52006: LIST
52007: LIST
52008: ST_TO_ADDR
52009: GO 52938
52011: LD_INT 4
52013: DOUBLE
52014: EQUAL
52015: IFTRUE 52019
52017: GO 52045
52019: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52020: LD_ADDR_VAR 0 3
52024: PUSH
52025: LD_INT 2
52027: PUSH
52028: LD_INT 3
52030: PUSH
52031: LD_INT 4
52033: PUSH
52034: LD_INT 5
52036: PUSH
52037: EMPTY
52038: LIST
52039: LIST
52040: LIST
52041: LIST
52042: ST_TO_ADDR
52043: GO 52938
52045: LD_INT 5
52047: DOUBLE
52048: EQUAL
52049: IFTRUE 52053
52051: GO 52079
52053: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52054: LD_ADDR_VAR 0 3
52058: PUSH
52059: LD_INT 2
52061: PUSH
52062: LD_INT 3
52064: PUSH
52065: LD_INT 4
52067: PUSH
52068: LD_INT 5
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: LIST
52075: LIST
52076: ST_TO_ADDR
52077: GO 52938
52079: LD_INT 9
52081: DOUBLE
52082: EQUAL
52083: IFTRUE 52087
52085: GO 52113
52087: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52088: LD_ADDR_VAR 0 3
52092: PUSH
52093: LD_INT 2
52095: PUSH
52096: LD_INT 3
52098: PUSH
52099: LD_INT 4
52101: PUSH
52102: LD_INT 5
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: LIST
52109: LIST
52110: ST_TO_ADDR
52111: GO 52938
52113: LD_INT 7
52115: DOUBLE
52116: EQUAL
52117: IFTRUE 52121
52119: GO 52147
52121: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52122: LD_ADDR_VAR 0 3
52126: PUSH
52127: LD_INT 2
52129: PUSH
52130: LD_INT 3
52132: PUSH
52133: LD_INT 4
52135: PUSH
52136: LD_INT 5
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: LIST
52143: LIST
52144: ST_TO_ADDR
52145: GO 52938
52147: LD_INT 12
52149: DOUBLE
52150: EQUAL
52151: IFTRUE 52155
52153: GO 52181
52155: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52156: LD_ADDR_VAR 0 3
52160: PUSH
52161: LD_INT 2
52163: PUSH
52164: LD_INT 3
52166: PUSH
52167: LD_INT 4
52169: PUSH
52170: LD_INT 5
52172: PUSH
52173: EMPTY
52174: LIST
52175: LIST
52176: LIST
52177: LIST
52178: ST_TO_ADDR
52179: GO 52938
52181: LD_INT 13
52183: DOUBLE
52184: EQUAL
52185: IFTRUE 52189
52187: GO 52215
52189: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52190: LD_ADDR_VAR 0 3
52194: PUSH
52195: LD_INT 2
52197: PUSH
52198: LD_INT 3
52200: PUSH
52201: LD_INT 4
52203: PUSH
52204: LD_INT 5
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: ST_TO_ADDR
52213: GO 52938
52215: LD_INT 14
52217: DOUBLE
52218: EQUAL
52219: IFTRUE 52223
52221: GO 52241
52223: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52224: LD_ADDR_VAR 0 3
52228: PUSH
52229: LD_INT 4
52231: PUSH
52232: LD_INT 5
52234: PUSH
52235: EMPTY
52236: LIST
52237: LIST
52238: ST_TO_ADDR
52239: GO 52938
52241: LD_INT 6
52243: DOUBLE
52244: EQUAL
52245: IFTRUE 52249
52247: GO 52267
52249: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52250: LD_ADDR_VAR 0 3
52254: PUSH
52255: LD_INT 4
52257: PUSH
52258: LD_INT 5
52260: PUSH
52261: EMPTY
52262: LIST
52263: LIST
52264: ST_TO_ADDR
52265: GO 52938
52267: LD_INT 10
52269: DOUBLE
52270: EQUAL
52271: IFTRUE 52275
52273: GO 52293
52275: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52276: LD_ADDR_VAR 0 3
52280: PUSH
52281: LD_INT 4
52283: PUSH
52284: LD_INT 5
52286: PUSH
52287: EMPTY
52288: LIST
52289: LIST
52290: ST_TO_ADDR
52291: GO 52938
52293: LD_INT 22
52295: DOUBLE
52296: EQUAL
52297: IFTRUE 52301
52299: GO 52327
52301: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52302: LD_ADDR_VAR 0 3
52306: PUSH
52307: LD_INT 11
52309: PUSH
52310: LD_INT 12
52312: PUSH
52313: LD_INT 13
52315: PUSH
52316: LD_INT 14
52318: PUSH
52319: EMPTY
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: ST_TO_ADDR
52325: GO 52938
52327: LD_INT 23
52329: DOUBLE
52330: EQUAL
52331: IFTRUE 52335
52333: GO 52361
52335: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52336: LD_ADDR_VAR 0 3
52340: PUSH
52341: LD_INT 11
52343: PUSH
52344: LD_INT 12
52346: PUSH
52347: LD_INT 13
52349: PUSH
52350: LD_INT 14
52352: PUSH
52353: EMPTY
52354: LIST
52355: LIST
52356: LIST
52357: LIST
52358: ST_TO_ADDR
52359: GO 52938
52361: LD_INT 24
52363: DOUBLE
52364: EQUAL
52365: IFTRUE 52369
52367: GO 52395
52369: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52370: LD_ADDR_VAR 0 3
52374: PUSH
52375: LD_INT 11
52377: PUSH
52378: LD_INT 12
52380: PUSH
52381: LD_INT 13
52383: PUSH
52384: LD_INT 14
52386: PUSH
52387: EMPTY
52388: LIST
52389: LIST
52390: LIST
52391: LIST
52392: ST_TO_ADDR
52393: GO 52938
52395: LD_INT 30
52397: DOUBLE
52398: EQUAL
52399: IFTRUE 52403
52401: GO 52429
52403: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52404: LD_ADDR_VAR 0 3
52408: PUSH
52409: LD_INT 11
52411: PUSH
52412: LD_INT 12
52414: PUSH
52415: LD_INT 13
52417: PUSH
52418: LD_INT 14
52420: PUSH
52421: EMPTY
52422: LIST
52423: LIST
52424: LIST
52425: LIST
52426: ST_TO_ADDR
52427: GO 52938
52429: LD_INT 25
52431: DOUBLE
52432: EQUAL
52433: IFTRUE 52437
52435: GO 52455
52437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52438: LD_ADDR_VAR 0 3
52442: PUSH
52443: LD_INT 13
52445: PUSH
52446: LD_INT 14
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: ST_TO_ADDR
52453: GO 52938
52455: LD_INT 27
52457: DOUBLE
52458: EQUAL
52459: IFTRUE 52463
52461: GO 52481
52463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52464: LD_ADDR_VAR 0 3
52468: PUSH
52469: LD_INT 13
52471: PUSH
52472: LD_INT 14
52474: PUSH
52475: EMPTY
52476: LIST
52477: LIST
52478: ST_TO_ADDR
52479: GO 52938
52481: LD_EXP 99
52485: DOUBLE
52486: EQUAL
52487: IFTRUE 52491
52489: GO 52517
52491: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52492: LD_ADDR_VAR 0 3
52496: PUSH
52497: LD_INT 11
52499: PUSH
52500: LD_INT 12
52502: PUSH
52503: LD_INT 13
52505: PUSH
52506: LD_INT 14
52508: PUSH
52509: EMPTY
52510: LIST
52511: LIST
52512: LIST
52513: LIST
52514: ST_TO_ADDR
52515: GO 52938
52517: LD_INT 28
52519: DOUBLE
52520: EQUAL
52521: IFTRUE 52525
52523: GO 52543
52525: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52526: LD_ADDR_VAR 0 3
52530: PUSH
52531: LD_INT 13
52533: PUSH
52534: LD_INT 14
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: ST_TO_ADDR
52541: GO 52938
52543: LD_INT 29
52545: DOUBLE
52546: EQUAL
52547: IFTRUE 52551
52549: GO 52569
52551: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52552: LD_ADDR_VAR 0 3
52556: PUSH
52557: LD_INT 13
52559: PUSH
52560: LD_INT 14
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: ST_TO_ADDR
52567: GO 52938
52569: LD_INT 31
52571: DOUBLE
52572: EQUAL
52573: IFTRUE 52577
52575: GO 52595
52577: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52578: LD_ADDR_VAR 0 3
52582: PUSH
52583: LD_INT 13
52585: PUSH
52586: LD_INT 14
52588: PUSH
52589: EMPTY
52590: LIST
52591: LIST
52592: ST_TO_ADDR
52593: GO 52938
52595: LD_INT 26
52597: DOUBLE
52598: EQUAL
52599: IFTRUE 52603
52601: GO 52621
52603: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52604: LD_ADDR_VAR 0 3
52608: PUSH
52609: LD_INT 13
52611: PUSH
52612: LD_INT 14
52614: PUSH
52615: EMPTY
52616: LIST
52617: LIST
52618: ST_TO_ADDR
52619: GO 52938
52621: LD_INT 42
52623: DOUBLE
52624: EQUAL
52625: IFTRUE 52629
52627: GO 52655
52629: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52630: LD_ADDR_VAR 0 3
52634: PUSH
52635: LD_INT 21
52637: PUSH
52638: LD_INT 22
52640: PUSH
52641: LD_INT 23
52643: PUSH
52644: LD_INT 24
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: LIST
52651: LIST
52652: ST_TO_ADDR
52653: GO 52938
52655: LD_INT 43
52657: DOUBLE
52658: EQUAL
52659: IFTRUE 52663
52661: GO 52689
52663: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52664: LD_ADDR_VAR 0 3
52668: PUSH
52669: LD_INT 21
52671: PUSH
52672: LD_INT 22
52674: PUSH
52675: LD_INT 23
52677: PUSH
52678: LD_INT 24
52680: PUSH
52681: EMPTY
52682: LIST
52683: LIST
52684: LIST
52685: LIST
52686: ST_TO_ADDR
52687: GO 52938
52689: LD_INT 44
52691: DOUBLE
52692: EQUAL
52693: IFTRUE 52697
52695: GO 52723
52697: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52698: LD_ADDR_VAR 0 3
52702: PUSH
52703: LD_INT 21
52705: PUSH
52706: LD_INT 22
52708: PUSH
52709: LD_INT 23
52711: PUSH
52712: LD_INT 24
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: LIST
52719: LIST
52720: ST_TO_ADDR
52721: GO 52938
52723: LD_INT 45
52725: DOUBLE
52726: EQUAL
52727: IFTRUE 52731
52729: GO 52757
52731: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52732: LD_ADDR_VAR 0 3
52736: PUSH
52737: LD_INT 21
52739: PUSH
52740: LD_INT 22
52742: PUSH
52743: LD_INT 23
52745: PUSH
52746: LD_INT 24
52748: PUSH
52749: EMPTY
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: ST_TO_ADDR
52755: GO 52938
52757: LD_INT 49
52759: DOUBLE
52760: EQUAL
52761: IFTRUE 52765
52763: GO 52791
52765: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52766: LD_ADDR_VAR 0 3
52770: PUSH
52771: LD_INT 21
52773: PUSH
52774: LD_INT 22
52776: PUSH
52777: LD_INT 23
52779: PUSH
52780: LD_INT 24
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: ST_TO_ADDR
52789: GO 52938
52791: LD_INT 51
52793: DOUBLE
52794: EQUAL
52795: IFTRUE 52799
52797: GO 52825
52799: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52800: LD_ADDR_VAR 0 3
52804: PUSH
52805: LD_INT 21
52807: PUSH
52808: LD_INT 22
52810: PUSH
52811: LD_INT 23
52813: PUSH
52814: LD_INT 24
52816: PUSH
52817: EMPTY
52818: LIST
52819: LIST
52820: LIST
52821: LIST
52822: ST_TO_ADDR
52823: GO 52938
52825: LD_INT 52
52827: DOUBLE
52828: EQUAL
52829: IFTRUE 52833
52831: GO 52859
52833: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52834: LD_ADDR_VAR 0 3
52838: PUSH
52839: LD_INT 21
52841: PUSH
52842: LD_INT 22
52844: PUSH
52845: LD_INT 23
52847: PUSH
52848: LD_INT 24
52850: PUSH
52851: EMPTY
52852: LIST
52853: LIST
52854: LIST
52855: LIST
52856: ST_TO_ADDR
52857: GO 52938
52859: LD_INT 53
52861: DOUBLE
52862: EQUAL
52863: IFTRUE 52867
52865: GO 52885
52867: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52868: LD_ADDR_VAR 0 3
52872: PUSH
52873: LD_INT 23
52875: PUSH
52876: LD_INT 24
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: ST_TO_ADDR
52883: GO 52938
52885: LD_INT 46
52887: DOUBLE
52888: EQUAL
52889: IFTRUE 52893
52891: GO 52911
52893: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52894: LD_ADDR_VAR 0 3
52898: PUSH
52899: LD_INT 23
52901: PUSH
52902: LD_INT 24
52904: PUSH
52905: EMPTY
52906: LIST
52907: LIST
52908: ST_TO_ADDR
52909: GO 52938
52911: LD_INT 47
52913: DOUBLE
52914: EQUAL
52915: IFTRUE 52919
52917: GO 52937
52919: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52920: LD_ADDR_VAR 0 3
52924: PUSH
52925: LD_INT 23
52927: PUSH
52928: LD_INT 24
52930: PUSH
52931: EMPTY
52932: LIST
52933: LIST
52934: ST_TO_ADDR
52935: GO 52938
52937: POP
// result := ( chassis in result ) ;
52938: LD_ADDR_VAR 0 3
52942: PUSH
52943: LD_VAR 0 1
52947: PUSH
52948: LD_VAR 0 3
52952: IN
52953: ST_TO_ADDR
// end ;
52954: LD_VAR 0 3
52958: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52959: LD_INT 0
52961: PPUSH
52962: PPUSH
52963: PPUSH
52964: PPUSH
52965: PPUSH
52966: PPUSH
52967: PPUSH
// result := array ;
52968: LD_ADDR_VAR 0 5
52972: PUSH
52973: LD_VAR 0 1
52977: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52978: LD_VAR 0 1
52982: NOT
52983: PUSH
52984: LD_VAR 0 2
52988: NOT
52989: OR
52990: PUSH
52991: LD_VAR 0 3
52995: NOT
52996: OR
52997: PUSH
52998: LD_VAR 0 2
53002: PUSH
53003: LD_VAR 0 1
53007: GREATER
53008: OR
53009: PUSH
53010: LD_VAR 0 3
53014: PUSH
53015: LD_VAR 0 1
53019: GREATER
53020: OR
53021: IFFALSE 53025
// exit ;
53023: GO 53321
// if direction then
53025: LD_VAR 0 4
53029: IFFALSE 53093
// begin d := 1 ;
53031: LD_ADDR_VAR 0 9
53035: PUSH
53036: LD_INT 1
53038: ST_TO_ADDR
// if i_from > i_to then
53039: LD_VAR 0 2
53043: PUSH
53044: LD_VAR 0 3
53048: GREATER
53049: IFFALSE 53075
// length := ( array - i_from ) + i_to else
53051: LD_ADDR_VAR 0 11
53055: PUSH
53056: LD_VAR 0 1
53060: PUSH
53061: LD_VAR 0 2
53065: MINUS
53066: PUSH
53067: LD_VAR 0 3
53071: PLUS
53072: ST_TO_ADDR
53073: GO 53091
// length := i_to - i_from ;
53075: LD_ADDR_VAR 0 11
53079: PUSH
53080: LD_VAR 0 3
53084: PUSH
53085: LD_VAR 0 2
53089: MINUS
53090: ST_TO_ADDR
// end else
53091: GO 53154
// begin d := - 1 ;
53093: LD_ADDR_VAR 0 9
53097: PUSH
53098: LD_INT 1
53100: NEG
53101: ST_TO_ADDR
// if i_from > i_to then
53102: LD_VAR 0 2
53106: PUSH
53107: LD_VAR 0 3
53111: GREATER
53112: IFFALSE 53132
// length := i_from - i_to else
53114: LD_ADDR_VAR 0 11
53118: PUSH
53119: LD_VAR 0 2
53123: PUSH
53124: LD_VAR 0 3
53128: MINUS
53129: ST_TO_ADDR
53130: GO 53154
// length := ( array - i_to ) + i_from ;
53132: LD_ADDR_VAR 0 11
53136: PUSH
53137: LD_VAR 0 1
53141: PUSH
53142: LD_VAR 0 3
53146: MINUS
53147: PUSH
53148: LD_VAR 0 2
53152: PLUS
53153: ST_TO_ADDR
// end ; if not length then
53154: LD_VAR 0 11
53158: NOT
53159: IFFALSE 53163
// exit ;
53161: GO 53321
// tmp := array ;
53163: LD_ADDR_VAR 0 10
53167: PUSH
53168: LD_VAR 0 1
53172: ST_TO_ADDR
// for i = 1 to length do
53173: LD_ADDR_VAR 0 6
53177: PUSH
53178: DOUBLE
53179: LD_INT 1
53181: DEC
53182: ST_TO_ADDR
53183: LD_VAR 0 11
53187: PUSH
53188: FOR_TO
53189: IFFALSE 53309
// begin for j = 1 to array do
53191: LD_ADDR_VAR 0 7
53195: PUSH
53196: DOUBLE
53197: LD_INT 1
53199: DEC
53200: ST_TO_ADDR
53201: LD_VAR 0 1
53205: PUSH
53206: FOR_TO
53207: IFFALSE 53295
// begin k := j + d ;
53209: LD_ADDR_VAR 0 8
53213: PUSH
53214: LD_VAR 0 7
53218: PUSH
53219: LD_VAR 0 9
53223: PLUS
53224: ST_TO_ADDR
// if k > array then
53225: LD_VAR 0 8
53229: PUSH
53230: LD_VAR 0 1
53234: GREATER
53235: IFFALSE 53245
// k := 1 ;
53237: LD_ADDR_VAR 0 8
53241: PUSH
53242: LD_INT 1
53244: ST_TO_ADDR
// if not k then
53245: LD_VAR 0 8
53249: NOT
53250: IFFALSE 53262
// k := array ;
53252: LD_ADDR_VAR 0 8
53256: PUSH
53257: LD_VAR 0 1
53261: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53262: LD_ADDR_VAR 0 10
53266: PUSH
53267: LD_VAR 0 10
53271: PPUSH
53272: LD_VAR 0 8
53276: PPUSH
53277: LD_VAR 0 1
53281: PUSH
53282: LD_VAR 0 7
53286: ARRAY
53287: PPUSH
53288: CALL_OW 1
53292: ST_TO_ADDR
// end ;
53293: GO 53206
53295: POP
53296: POP
// array := tmp ;
53297: LD_ADDR_VAR 0 1
53301: PUSH
53302: LD_VAR 0 10
53306: ST_TO_ADDR
// end ;
53307: GO 53188
53309: POP
53310: POP
// result := array ;
53311: LD_ADDR_VAR 0 5
53315: PUSH
53316: LD_VAR 0 1
53320: ST_TO_ADDR
// end ;
53321: LD_VAR 0 5
53325: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53326: LD_INT 0
53328: PPUSH
53329: PPUSH
// result := 0 ;
53330: LD_ADDR_VAR 0 3
53334: PUSH
53335: LD_INT 0
53337: ST_TO_ADDR
// if not array or not value in array then
53338: LD_VAR 0 1
53342: NOT
53343: PUSH
53344: LD_VAR 0 2
53348: PUSH
53349: LD_VAR 0 1
53353: IN
53354: NOT
53355: OR
53356: IFFALSE 53360
// exit ;
53358: GO 53414
// for i = 1 to array do
53360: LD_ADDR_VAR 0 4
53364: PUSH
53365: DOUBLE
53366: LD_INT 1
53368: DEC
53369: ST_TO_ADDR
53370: LD_VAR 0 1
53374: PUSH
53375: FOR_TO
53376: IFFALSE 53412
// if value = array [ i ] then
53378: LD_VAR 0 2
53382: PUSH
53383: LD_VAR 0 1
53387: PUSH
53388: LD_VAR 0 4
53392: ARRAY
53393: EQUAL
53394: IFFALSE 53410
// begin result := i ;
53396: LD_ADDR_VAR 0 3
53400: PUSH
53401: LD_VAR 0 4
53405: ST_TO_ADDR
// exit ;
53406: POP
53407: POP
53408: GO 53414
// end ;
53410: GO 53375
53412: POP
53413: POP
// end ;
53414: LD_VAR 0 3
53418: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53419: LD_INT 0
53421: PPUSH
// vc_chassis := chassis ;
53422: LD_ADDR_OWVAR 37
53426: PUSH
53427: LD_VAR 0 1
53431: ST_TO_ADDR
// vc_engine := engine ;
53432: LD_ADDR_OWVAR 39
53436: PUSH
53437: LD_VAR 0 2
53441: ST_TO_ADDR
// vc_control := control ;
53442: LD_ADDR_OWVAR 38
53446: PUSH
53447: LD_VAR 0 3
53451: ST_TO_ADDR
// vc_weapon := weapon ;
53452: LD_ADDR_OWVAR 40
53456: PUSH
53457: LD_VAR 0 4
53461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53462: LD_ADDR_OWVAR 41
53466: PUSH
53467: LD_VAR 0 5
53471: ST_TO_ADDR
// end ;
53472: LD_VAR 0 6
53476: RET
// export function WantPlant ( unit ) ; var task ; begin
53477: LD_INT 0
53479: PPUSH
53480: PPUSH
// result := false ;
53481: LD_ADDR_VAR 0 2
53485: PUSH
53486: LD_INT 0
53488: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53489: LD_ADDR_VAR 0 3
53493: PUSH
53494: LD_VAR 0 1
53498: PPUSH
53499: CALL_OW 437
53503: ST_TO_ADDR
// if task then
53504: LD_VAR 0 3
53508: IFFALSE 53536
// if task [ 1 ] [ 1 ] = p then
53510: LD_VAR 0 3
53514: PUSH
53515: LD_INT 1
53517: ARRAY
53518: PUSH
53519: LD_INT 1
53521: ARRAY
53522: PUSH
53523: LD_STRING p
53525: EQUAL
53526: IFFALSE 53536
// result := true ;
53528: LD_ADDR_VAR 0 2
53532: PUSH
53533: LD_INT 1
53535: ST_TO_ADDR
// end ;
53536: LD_VAR 0 2
53540: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53541: LD_INT 0
53543: PPUSH
53544: PPUSH
53545: PPUSH
53546: PPUSH
// if pos < 1 then
53547: LD_VAR 0 2
53551: PUSH
53552: LD_INT 1
53554: LESS
53555: IFFALSE 53559
// exit ;
53557: GO 53862
// if pos = 1 then
53559: LD_VAR 0 2
53563: PUSH
53564: LD_INT 1
53566: EQUAL
53567: IFFALSE 53600
// result := Replace ( arr , pos [ 1 ] , value ) else
53569: LD_ADDR_VAR 0 4
53573: PUSH
53574: LD_VAR 0 1
53578: PPUSH
53579: LD_VAR 0 2
53583: PUSH
53584: LD_INT 1
53586: ARRAY
53587: PPUSH
53588: LD_VAR 0 3
53592: PPUSH
53593: CALL_OW 1
53597: ST_TO_ADDR
53598: GO 53862
// begin tmp := arr ;
53600: LD_ADDR_VAR 0 6
53604: PUSH
53605: LD_VAR 0 1
53609: ST_TO_ADDR
// s_arr := [ tmp ] ;
53610: LD_ADDR_VAR 0 7
53614: PUSH
53615: LD_VAR 0 6
53619: PUSH
53620: EMPTY
53621: LIST
53622: ST_TO_ADDR
// for i = 1 to pos - 1 do
53623: LD_ADDR_VAR 0 5
53627: PUSH
53628: DOUBLE
53629: LD_INT 1
53631: DEC
53632: ST_TO_ADDR
53633: LD_VAR 0 2
53637: PUSH
53638: LD_INT 1
53640: MINUS
53641: PUSH
53642: FOR_TO
53643: IFFALSE 53688
// begin tmp := tmp [ pos [ i ] ] ;
53645: LD_ADDR_VAR 0 6
53649: PUSH
53650: LD_VAR 0 6
53654: PUSH
53655: LD_VAR 0 2
53659: PUSH
53660: LD_VAR 0 5
53664: ARRAY
53665: ARRAY
53666: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53667: LD_ADDR_VAR 0 7
53671: PUSH
53672: LD_VAR 0 7
53676: PUSH
53677: LD_VAR 0 6
53681: PUSH
53682: EMPTY
53683: LIST
53684: ADD
53685: ST_TO_ADDR
// end ;
53686: GO 53642
53688: POP
53689: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53690: LD_ADDR_VAR 0 6
53694: PUSH
53695: LD_VAR 0 6
53699: PPUSH
53700: LD_VAR 0 2
53704: PUSH
53705: LD_VAR 0 2
53709: ARRAY
53710: PPUSH
53711: LD_VAR 0 3
53715: PPUSH
53716: CALL_OW 1
53720: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53721: LD_ADDR_VAR 0 7
53725: PUSH
53726: LD_VAR 0 7
53730: PPUSH
53731: LD_VAR 0 7
53735: PPUSH
53736: LD_VAR 0 6
53740: PPUSH
53741: CALL_OW 1
53745: ST_TO_ADDR
// for i = s_arr downto 2 do
53746: LD_ADDR_VAR 0 5
53750: PUSH
53751: DOUBLE
53752: LD_VAR 0 7
53756: INC
53757: ST_TO_ADDR
53758: LD_INT 2
53760: PUSH
53761: FOR_DOWNTO
53762: IFFALSE 53846
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53764: LD_ADDR_VAR 0 6
53768: PUSH
53769: LD_VAR 0 7
53773: PUSH
53774: LD_VAR 0 5
53778: PUSH
53779: LD_INT 1
53781: MINUS
53782: ARRAY
53783: PPUSH
53784: LD_VAR 0 2
53788: PUSH
53789: LD_VAR 0 5
53793: PUSH
53794: LD_INT 1
53796: MINUS
53797: ARRAY
53798: PPUSH
53799: LD_VAR 0 7
53803: PUSH
53804: LD_VAR 0 5
53808: ARRAY
53809: PPUSH
53810: CALL_OW 1
53814: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53815: LD_ADDR_VAR 0 7
53819: PUSH
53820: LD_VAR 0 7
53824: PPUSH
53825: LD_VAR 0 5
53829: PUSH
53830: LD_INT 1
53832: MINUS
53833: PPUSH
53834: LD_VAR 0 6
53838: PPUSH
53839: CALL_OW 1
53843: ST_TO_ADDR
// end ;
53844: GO 53761
53846: POP
53847: POP
// result := s_arr [ 1 ] ;
53848: LD_ADDR_VAR 0 4
53852: PUSH
53853: LD_VAR 0 7
53857: PUSH
53858: LD_INT 1
53860: ARRAY
53861: ST_TO_ADDR
// end ; end ;
53862: LD_VAR 0 4
53866: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53867: LD_INT 0
53869: PPUSH
53870: PPUSH
// if not list then
53871: LD_VAR 0 1
53875: NOT
53876: IFFALSE 53880
// exit ;
53878: GO 53971
// i := list [ pos1 ] ;
53880: LD_ADDR_VAR 0 5
53884: PUSH
53885: LD_VAR 0 1
53889: PUSH
53890: LD_VAR 0 2
53894: ARRAY
53895: ST_TO_ADDR
// if not i then
53896: LD_VAR 0 5
53900: NOT
53901: IFFALSE 53905
// exit ;
53903: GO 53971
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53905: LD_ADDR_VAR 0 1
53909: PUSH
53910: LD_VAR 0 1
53914: PPUSH
53915: LD_VAR 0 2
53919: PPUSH
53920: LD_VAR 0 1
53924: PUSH
53925: LD_VAR 0 3
53929: ARRAY
53930: PPUSH
53931: CALL_OW 1
53935: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53936: LD_ADDR_VAR 0 1
53940: PUSH
53941: LD_VAR 0 1
53945: PPUSH
53946: LD_VAR 0 3
53950: PPUSH
53951: LD_VAR 0 5
53955: PPUSH
53956: CALL_OW 1
53960: ST_TO_ADDR
// result := list ;
53961: LD_ADDR_VAR 0 4
53965: PUSH
53966: LD_VAR 0 1
53970: ST_TO_ADDR
// end ;
53971: LD_VAR 0 4
53975: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53976: LD_INT 0
53978: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53979: LD_ADDR_VAR 0 5
53983: PUSH
53984: LD_VAR 0 1
53988: PPUSH
53989: CALL_OW 250
53993: PPUSH
53994: LD_VAR 0 1
53998: PPUSH
53999: CALL_OW 251
54003: PPUSH
54004: LD_VAR 0 2
54008: PPUSH
54009: LD_VAR 0 3
54013: PPUSH
54014: LD_VAR 0 4
54018: PPUSH
54019: CALL 54029 0 5
54023: ST_TO_ADDR
// end ;
54024: LD_VAR 0 5
54028: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54029: LD_INT 0
54031: PPUSH
54032: PPUSH
54033: PPUSH
54034: PPUSH
// if not list then
54035: LD_VAR 0 3
54039: NOT
54040: IFFALSE 54044
// exit ;
54042: GO 54432
// result := [ ] ;
54044: LD_ADDR_VAR 0 6
54048: PUSH
54049: EMPTY
54050: ST_TO_ADDR
// for i in list do
54051: LD_ADDR_VAR 0 7
54055: PUSH
54056: LD_VAR 0 3
54060: PUSH
54061: FOR_IN
54062: IFFALSE 54264
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54064: LD_ADDR_VAR 0 9
54068: PUSH
54069: LD_VAR 0 7
54073: PPUSH
54074: LD_VAR 0 1
54078: PPUSH
54079: LD_VAR 0 2
54083: PPUSH
54084: CALL_OW 297
54088: ST_TO_ADDR
// if not result then
54089: LD_VAR 0 6
54093: NOT
54094: IFFALSE 54120
// result := [ [ i , tmp ] ] else
54096: LD_ADDR_VAR 0 6
54100: PUSH
54101: LD_VAR 0 7
54105: PUSH
54106: LD_VAR 0 9
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: PUSH
54115: EMPTY
54116: LIST
54117: ST_TO_ADDR
54118: GO 54262
// begin if result [ result ] [ 2 ] < tmp then
54120: LD_VAR 0 6
54124: PUSH
54125: LD_VAR 0 6
54129: ARRAY
54130: PUSH
54131: LD_INT 2
54133: ARRAY
54134: PUSH
54135: LD_VAR 0 9
54139: LESS
54140: IFFALSE 54182
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54142: LD_ADDR_VAR 0 6
54146: PUSH
54147: LD_VAR 0 6
54151: PPUSH
54152: LD_VAR 0 6
54156: PUSH
54157: LD_INT 1
54159: PLUS
54160: PPUSH
54161: LD_VAR 0 7
54165: PUSH
54166: LD_VAR 0 9
54170: PUSH
54171: EMPTY
54172: LIST
54173: LIST
54174: PPUSH
54175: CALL_OW 2
54179: ST_TO_ADDR
54180: GO 54262
// for j = 1 to result do
54182: LD_ADDR_VAR 0 8
54186: PUSH
54187: DOUBLE
54188: LD_INT 1
54190: DEC
54191: ST_TO_ADDR
54192: LD_VAR 0 6
54196: PUSH
54197: FOR_TO
54198: IFFALSE 54260
// begin if tmp < result [ j ] [ 2 ] then
54200: LD_VAR 0 9
54204: PUSH
54205: LD_VAR 0 6
54209: PUSH
54210: LD_VAR 0 8
54214: ARRAY
54215: PUSH
54216: LD_INT 2
54218: ARRAY
54219: LESS
54220: IFFALSE 54258
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54222: LD_ADDR_VAR 0 6
54226: PUSH
54227: LD_VAR 0 6
54231: PPUSH
54232: LD_VAR 0 8
54236: PPUSH
54237: LD_VAR 0 7
54241: PUSH
54242: LD_VAR 0 9
54246: PUSH
54247: EMPTY
54248: LIST
54249: LIST
54250: PPUSH
54251: CALL_OW 2
54255: ST_TO_ADDR
// break ;
54256: GO 54260
// end ; end ;
54258: GO 54197
54260: POP
54261: POP
// end ; end ;
54262: GO 54061
54264: POP
54265: POP
// if result and not asc then
54266: LD_VAR 0 6
54270: PUSH
54271: LD_VAR 0 4
54275: NOT
54276: AND
54277: IFFALSE 54352
// begin tmp := result ;
54279: LD_ADDR_VAR 0 9
54283: PUSH
54284: LD_VAR 0 6
54288: ST_TO_ADDR
// for i = tmp downto 1 do
54289: LD_ADDR_VAR 0 7
54293: PUSH
54294: DOUBLE
54295: LD_VAR 0 9
54299: INC
54300: ST_TO_ADDR
54301: LD_INT 1
54303: PUSH
54304: FOR_DOWNTO
54305: IFFALSE 54350
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54307: LD_ADDR_VAR 0 6
54311: PUSH
54312: LD_VAR 0 6
54316: PPUSH
54317: LD_VAR 0 9
54321: PUSH
54322: LD_VAR 0 7
54326: MINUS
54327: PUSH
54328: LD_INT 1
54330: PLUS
54331: PPUSH
54332: LD_VAR 0 9
54336: PUSH
54337: LD_VAR 0 7
54341: ARRAY
54342: PPUSH
54343: CALL_OW 1
54347: ST_TO_ADDR
54348: GO 54304
54350: POP
54351: POP
// end ; tmp := [ ] ;
54352: LD_ADDR_VAR 0 9
54356: PUSH
54357: EMPTY
54358: ST_TO_ADDR
// if mode then
54359: LD_VAR 0 5
54363: IFFALSE 54432
// begin for i = 1 to result do
54365: LD_ADDR_VAR 0 7
54369: PUSH
54370: DOUBLE
54371: LD_INT 1
54373: DEC
54374: ST_TO_ADDR
54375: LD_VAR 0 6
54379: PUSH
54380: FOR_TO
54381: IFFALSE 54420
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54383: LD_ADDR_VAR 0 9
54387: PUSH
54388: LD_VAR 0 9
54392: PPUSH
54393: LD_VAR 0 7
54397: PPUSH
54398: LD_VAR 0 6
54402: PUSH
54403: LD_VAR 0 7
54407: ARRAY
54408: PUSH
54409: LD_INT 1
54411: ARRAY
54412: PPUSH
54413: CALL_OW 1
54417: ST_TO_ADDR
54418: GO 54380
54420: POP
54421: POP
// result := tmp ;
54422: LD_ADDR_VAR 0 6
54426: PUSH
54427: LD_VAR 0 9
54431: ST_TO_ADDR
// end ; end ;
54432: LD_VAR 0 6
54436: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54437: LD_INT 0
54439: PPUSH
54440: PPUSH
54441: PPUSH
54442: PPUSH
54443: PPUSH
54444: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54445: LD_ADDR_VAR 0 5
54449: PUSH
54450: LD_INT 0
54452: PUSH
54453: LD_INT 0
54455: PUSH
54456: LD_INT 0
54458: PUSH
54459: EMPTY
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: LIST
54465: LIST
54466: ST_TO_ADDR
// if not x or not y then
54467: LD_VAR 0 2
54471: NOT
54472: PUSH
54473: LD_VAR 0 3
54477: NOT
54478: OR
54479: IFFALSE 54483
// exit ;
54481: GO 56135
// if not range then
54483: LD_VAR 0 4
54487: NOT
54488: IFFALSE 54498
// range := 10 ;
54490: LD_ADDR_VAR 0 4
54494: PUSH
54495: LD_INT 10
54497: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54498: LD_ADDR_VAR 0 8
54502: PUSH
54503: LD_INT 81
54505: PUSH
54506: LD_VAR 0 1
54510: PUSH
54511: EMPTY
54512: LIST
54513: LIST
54514: PUSH
54515: LD_INT 92
54517: PUSH
54518: LD_VAR 0 2
54522: PUSH
54523: LD_VAR 0 3
54527: PUSH
54528: LD_VAR 0 4
54532: PUSH
54533: EMPTY
54534: LIST
54535: LIST
54536: LIST
54537: LIST
54538: PUSH
54539: LD_INT 3
54541: PUSH
54542: LD_INT 21
54544: PUSH
54545: LD_INT 3
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: PUSH
54556: EMPTY
54557: LIST
54558: LIST
54559: LIST
54560: PPUSH
54561: CALL_OW 69
54565: ST_TO_ADDR
// if not tmp then
54566: LD_VAR 0 8
54570: NOT
54571: IFFALSE 54575
// exit ;
54573: GO 56135
// for i in tmp do
54575: LD_ADDR_VAR 0 6
54579: PUSH
54580: LD_VAR 0 8
54584: PUSH
54585: FOR_IN
54586: IFFALSE 56110
// begin points := [ 0 , 0 , 0 ] ;
54588: LD_ADDR_VAR 0 9
54592: PUSH
54593: LD_INT 0
54595: PUSH
54596: LD_INT 0
54598: PUSH
54599: LD_INT 0
54601: PUSH
54602: EMPTY
54603: LIST
54604: LIST
54605: LIST
54606: ST_TO_ADDR
// bpoints := 1 ;
54607: LD_ADDR_VAR 0 10
54611: PUSH
54612: LD_INT 1
54614: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54615: LD_VAR 0 6
54619: PPUSH
54620: CALL_OW 247
54624: PUSH
54625: LD_INT 1
54627: DOUBLE
54628: EQUAL
54629: IFTRUE 54633
54631: GO 55211
54633: POP
// begin if GetClass ( i ) = 1 then
54634: LD_VAR 0 6
54638: PPUSH
54639: CALL_OW 257
54643: PUSH
54644: LD_INT 1
54646: EQUAL
54647: IFFALSE 54668
// points := [ 10 , 5 , 3 ] ;
54649: LD_ADDR_VAR 0 9
54653: PUSH
54654: LD_INT 10
54656: PUSH
54657: LD_INT 5
54659: PUSH
54660: LD_INT 3
54662: PUSH
54663: EMPTY
54664: LIST
54665: LIST
54666: LIST
54667: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54668: LD_VAR 0 6
54672: PPUSH
54673: CALL_OW 257
54677: PUSH
54678: LD_INT 2
54680: PUSH
54681: LD_INT 3
54683: PUSH
54684: LD_INT 4
54686: PUSH
54687: EMPTY
54688: LIST
54689: LIST
54690: LIST
54691: IN
54692: IFFALSE 54713
// points := [ 3 , 2 , 1 ] ;
54694: LD_ADDR_VAR 0 9
54698: PUSH
54699: LD_INT 3
54701: PUSH
54702: LD_INT 2
54704: PUSH
54705: LD_INT 1
54707: PUSH
54708: EMPTY
54709: LIST
54710: LIST
54711: LIST
54712: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54713: LD_VAR 0 6
54717: PPUSH
54718: CALL_OW 257
54722: PUSH
54723: LD_INT 5
54725: EQUAL
54726: IFFALSE 54747
// points := [ 130 , 5 , 2 ] ;
54728: LD_ADDR_VAR 0 9
54732: PUSH
54733: LD_INT 130
54735: PUSH
54736: LD_INT 5
54738: PUSH
54739: LD_INT 2
54741: PUSH
54742: EMPTY
54743: LIST
54744: LIST
54745: LIST
54746: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54747: LD_VAR 0 6
54751: PPUSH
54752: CALL_OW 257
54756: PUSH
54757: LD_INT 8
54759: EQUAL
54760: IFFALSE 54781
// points := [ 35 , 35 , 30 ] ;
54762: LD_ADDR_VAR 0 9
54766: PUSH
54767: LD_INT 35
54769: PUSH
54770: LD_INT 35
54772: PUSH
54773: LD_INT 30
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54781: LD_VAR 0 6
54785: PPUSH
54786: CALL_OW 257
54790: PUSH
54791: LD_INT 9
54793: EQUAL
54794: IFFALSE 54815
// points := [ 20 , 55 , 40 ] ;
54796: LD_ADDR_VAR 0 9
54800: PUSH
54801: LD_INT 20
54803: PUSH
54804: LD_INT 55
54806: PUSH
54807: LD_INT 40
54809: PUSH
54810: EMPTY
54811: LIST
54812: LIST
54813: LIST
54814: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54815: LD_VAR 0 6
54819: PPUSH
54820: CALL_OW 257
54824: PUSH
54825: LD_INT 12
54827: PUSH
54828: LD_INT 16
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: IN
54835: IFFALSE 54856
// points := [ 5 , 3 , 2 ] ;
54837: LD_ADDR_VAR 0 9
54841: PUSH
54842: LD_INT 5
54844: PUSH
54845: LD_INT 3
54847: PUSH
54848: LD_INT 2
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: LIST
54855: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54856: LD_VAR 0 6
54860: PPUSH
54861: CALL_OW 257
54865: PUSH
54866: LD_INT 17
54868: EQUAL
54869: IFFALSE 54890
// points := [ 100 , 50 , 75 ] ;
54871: LD_ADDR_VAR 0 9
54875: PUSH
54876: LD_INT 100
54878: PUSH
54879: LD_INT 50
54881: PUSH
54882: LD_INT 75
54884: PUSH
54885: EMPTY
54886: LIST
54887: LIST
54888: LIST
54889: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54890: LD_VAR 0 6
54894: PPUSH
54895: CALL_OW 257
54899: PUSH
54900: LD_INT 15
54902: EQUAL
54903: IFFALSE 54924
// points := [ 10 , 5 , 3 ] ;
54905: LD_ADDR_VAR 0 9
54909: PUSH
54910: LD_INT 10
54912: PUSH
54913: LD_INT 5
54915: PUSH
54916: LD_INT 3
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54924: LD_VAR 0 6
54928: PPUSH
54929: CALL_OW 257
54933: PUSH
54934: LD_INT 14
54936: EQUAL
54937: IFFALSE 54958
// points := [ 10 , 0 , 0 ] ;
54939: LD_ADDR_VAR 0 9
54943: PUSH
54944: LD_INT 10
54946: PUSH
54947: LD_INT 0
54949: PUSH
54950: LD_INT 0
54952: PUSH
54953: EMPTY
54954: LIST
54955: LIST
54956: LIST
54957: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54958: LD_VAR 0 6
54962: PPUSH
54963: CALL_OW 257
54967: PUSH
54968: LD_INT 11
54970: EQUAL
54971: IFFALSE 54992
// points := [ 30 , 10 , 5 ] ;
54973: LD_ADDR_VAR 0 9
54977: PUSH
54978: LD_INT 30
54980: PUSH
54981: LD_INT 10
54983: PUSH
54984: LD_INT 5
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: LIST
54991: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54992: LD_VAR 0 1
54996: PPUSH
54997: LD_INT 5
54999: PPUSH
55000: CALL_OW 321
55004: PUSH
55005: LD_INT 2
55007: EQUAL
55008: IFFALSE 55025
// bpoints := bpoints * 1.8 ;
55010: LD_ADDR_VAR 0 10
55014: PUSH
55015: LD_VAR 0 10
55019: PUSH
55020: LD_REAL  1.80000000000000E+0000
55023: MUL
55024: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55025: LD_VAR 0 6
55029: PPUSH
55030: CALL_OW 257
55034: PUSH
55035: LD_INT 1
55037: PUSH
55038: LD_INT 2
55040: PUSH
55041: LD_INT 3
55043: PUSH
55044: LD_INT 4
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: LIST
55051: LIST
55052: IN
55053: PUSH
55054: LD_VAR 0 1
55058: PPUSH
55059: LD_INT 51
55061: PPUSH
55062: CALL_OW 321
55066: PUSH
55067: LD_INT 2
55069: EQUAL
55070: AND
55071: IFFALSE 55088
// bpoints := bpoints * 1.2 ;
55073: LD_ADDR_VAR 0 10
55077: PUSH
55078: LD_VAR 0 10
55082: PUSH
55083: LD_REAL  1.20000000000000E+0000
55086: MUL
55087: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55088: LD_VAR 0 6
55092: PPUSH
55093: CALL_OW 257
55097: PUSH
55098: LD_INT 5
55100: PUSH
55101: LD_INT 7
55103: PUSH
55104: LD_INT 9
55106: PUSH
55107: EMPTY
55108: LIST
55109: LIST
55110: LIST
55111: IN
55112: PUSH
55113: LD_VAR 0 1
55117: PPUSH
55118: LD_INT 52
55120: PPUSH
55121: CALL_OW 321
55125: PUSH
55126: LD_INT 2
55128: EQUAL
55129: AND
55130: IFFALSE 55147
// bpoints := bpoints * 1.5 ;
55132: LD_ADDR_VAR 0 10
55136: PUSH
55137: LD_VAR 0 10
55141: PUSH
55142: LD_REAL  1.50000000000000E+0000
55145: MUL
55146: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55147: LD_VAR 0 1
55151: PPUSH
55152: LD_INT 66
55154: PPUSH
55155: CALL_OW 321
55159: PUSH
55160: LD_INT 2
55162: EQUAL
55163: IFFALSE 55180
// bpoints := bpoints * 1.1 ;
55165: LD_ADDR_VAR 0 10
55169: PUSH
55170: LD_VAR 0 10
55174: PUSH
55175: LD_REAL  1.10000000000000E+0000
55178: MUL
55179: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55180: LD_ADDR_VAR 0 10
55184: PUSH
55185: LD_VAR 0 10
55189: PUSH
55190: LD_VAR 0 6
55194: PPUSH
55195: LD_INT 1
55197: PPUSH
55198: CALL_OW 259
55202: PUSH
55203: LD_REAL  1.15000000000000E+0000
55206: MUL
55207: MUL
55208: ST_TO_ADDR
// end ; unit_vehicle :
55209: GO 56039
55211: LD_INT 2
55213: DOUBLE
55214: EQUAL
55215: IFTRUE 55219
55217: GO 56027
55219: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55220: LD_VAR 0 6
55224: PPUSH
55225: CALL_OW 264
55229: PUSH
55230: LD_INT 2
55232: PUSH
55233: LD_INT 42
55235: PUSH
55236: LD_INT 24
55238: PUSH
55239: EMPTY
55240: LIST
55241: LIST
55242: LIST
55243: IN
55244: IFFALSE 55265
// points := [ 25 , 5 , 3 ] ;
55246: LD_ADDR_VAR 0 9
55250: PUSH
55251: LD_INT 25
55253: PUSH
55254: LD_INT 5
55256: PUSH
55257: LD_INT 3
55259: PUSH
55260: EMPTY
55261: LIST
55262: LIST
55263: LIST
55264: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55265: LD_VAR 0 6
55269: PPUSH
55270: CALL_OW 264
55274: PUSH
55275: LD_INT 4
55277: PUSH
55278: LD_INT 43
55280: PUSH
55281: LD_INT 25
55283: PUSH
55284: EMPTY
55285: LIST
55286: LIST
55287: LIST
55288: IN
55289: IFFALSE 55310
// points := [ 40 , 15 , 5 ] ;
55291: LD_ADDR_VAR 0 9
55295: PUSH
55296: LD_INT 40
55298: PUSH
55299: LD_INT 15
55301: PUSH
55302: LD_INT 5
55304: PUSH
55305: EMPTY
55306: LIST
55307: LIST
55308: LIST
55309: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55310: LD_VAR 0 6
55314: PPUSH
55315: CALL_OW 264
55319: PUSH
55320: LD_INT 3
55322: PUSH
55323: LD_INT 23
55325: PUSH
55326: EMPTY
55327: LIST
55328: LIST
55329: IN
55330: IFFALSE 55351
// points := [ 7 , 25 , 8 ] ;
55332: LD_ADDR_VAR 0 9
55336: PUSH
55337: LD_INT 7
55339: PUSH
55340: LD_INT 25
55342: PUSH
55343: LD_INT 8
55345: PUSH
55346: EMPTY
55347: LIST
55348: LIST
55349: LIST
55350: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55351: LD_VAR 0 6
55355: PPUSH
55356: CALL_OW 264
55360: PUSH
55361: LD_INT 5
55363: PUSH
55364: LD_INT 27
55366: PUSH
55367: LD_INT 44
55369: PUSH
55370: EMPTY
55371: LIST
55372: LIST
55373: LIST
55374: IN
55375: IFFALSE 55396
// points := [ 14 , 50 , 16 ] ;
55377: LD_ADDR_VAR 0 9
55381: PUSH
55382: LD_INT 14
55384: PUSH
55385: LD_INT 50
55387: PUSH
55388: LD_INT 16
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: LIST
55395: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55396: LD_VAR 0 6
55400: PPUSH
55401: CALL_OW 264
55405: PUSH
55406: LD_INT 6
55408: PUSH
55409: LD_INT 46
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: IN
55416: IFFALSE 55437
// points := [ 32 , 120 , 70 ] ;
55418: LD_ADDR_VAR 0 9
55422: PUSH
55423: LD_INT 32
55425: PUSH
55426: LD_INT 120
55428: PUSH
55429: LD_INT 70
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: LIST
55436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55437: LD_VAR 0 6
55441: PPUSH
55442: CALL_OW 264
55446: PUSH
55447: LD_INT 7
55449: PUSH
55450: LD_INT 28
55452: PUSH
55453: LD_INT 45
55455: PUSH
55456: LD_EXP 99
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: LIST
55465: LIST
55466: IN
55467: IFFALSE 55488
// points := [ 35 , 20 , 45 ] ;
55469: LD_ADDR_VAR 0 9
55473: PUSH
55474: LD_INT 35
55476: PUSH
55477: LD_INT 20
55479: PUSH
55480: LD_INT 45
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: LIST
55487: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55488: LD_VAR 0 6
55492: PPUSH
55493: CALL_OW 264
55497: PUSH
55498: LD_INT 47
55500: PUSH
55501: EMPTY
55502: LIST
55503: IN
55504: IFFALSE 55525
// points := [ 67 , 45 , 75 ] ;
55506: LD_ADDR_VAR 0 9
55510: PUSH
55511: LD_INT 67
55513: PUSH
55514: LD_INT 45
55516: PUSH
55517: LD_INT 75
55519: PUSH
55520: EMPTY
55521: LIST
55522: LIST
55523: LIST
55524: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55525: LD_VAR 0 6
55529: PPUSH
55530: CALL_OW 264
55534: PUSH
55535: LD_INT 26
55537: PUSH
55538: EMPTY
55539: LIST
55540: IN
55541: IFFALSE 55562
// points := [ 120 , 30 , 80 ] ;
55543: LD_ADDR_VAR 0 9
55547: PUSH
55548: LD_INT 120
55550: PUSH
55551: LD_INT 30
55553: PUSH
55554: LD_INT 80
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: LIST
55561: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55562: LD_VAR 0 6
55566: PPUSH
55567: CALL_OW 264
55571: PUSH
55572: LD_INT 22
55574: PUSH
55575: EMPTY
55576: LIST
55577: IN
55578: IFFALSE 55599
// points := [ 40 , 1 , 1 ] ;
55580: LD_ADDR_VAR 0 9
55584: PUSH
55585: LD_INT 40
55587: PUSH
55588: LD_INT 1
55590: PUSH
55591: LD_INT 1
55593: PUSH
55594: EMPTY
55595: LIST
55596: LIST
55597: LIST
55598: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55599: LD_VAR 0 6
55603: PPUSH
55604: CALL_OW 264
55608: PUSH
55609: LD_INT 29
55611: PUSH
55612: EMPTY
55613: LIST
55614: IN
55615: IFFALSE 55636
// points := [ 70 , 200 , 400 ] ;
55617: LD_ADDR_VAR 0 9
55621: PUSH
55622: LD_INT 70
55624: PUSH
55625: LD_INT 200
55627: PUSH
55628: LD_INT 400
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: LIST
55635: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55636: LD_VAR 0 6
55640: PPUSH
55641: CALL_OW 264
55645: PUSH
55646: LD_INT 14
55648: PUSH
55649: LD_INT 53
55651: PUSH
55652: EMPTY
55653: LIST
55654: LIST
55655: IN
55656: IFFALSE 55677
// points := [ 40 , 10 , 20 ] ;
55658: LD_ADDR_VAR 0 9
55662: PUSH
55663: LD_INT 40
55665: PUSH
55666: LD_INT 10
55668: PUSH
55669: LD_INT 20
55671: PUSH
55672: EMPTY
55673: LIST
55674: LIST
55675: LIST
55676: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55677: LD_VAR 0 6
55681: PPUSH
55682: CALL_OW 264
55686: PUSH
55687: LD_INT 9
55689: PUSH
55690: EMPTY
55691: LIST
55692: IN
55693: IFFALSE 55714
// points := [ 5 , 70 , 20 ] ;
55695: LD_ADDR_VAR 0 9
55699: PUSH
55700: LD_INT 5
55702: PUSH
55703: LD_INT 70
55705: PUSH
55706: LD_INT 20
55708: PUSH
55709: EMPTY
55710: LIST
55711: LIST
55712: LIST
55713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55714: LD_VAR 0 6
55718: PPUSH
55719: CALL_OW 264
55723: PUSH
55724: LD_INT 10
55726: PUSH
55727: EMPTY
55728: LIST
55729: IN
55730: IFFALSE 55751
// points := [ 35 , 110 , 70 ] ;
55732: LD_ADDR_VAR 0 9
55736: PUSH
55737: LD_INT 35
55739: PUSH
55740: LD_INT 110
55742: PUSH
55743: LD_INT 70
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: LIST
55750: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55751: LD_VAR 0 6
55755: PPUSH
55756: CALL_OW 265
55760: PUSH
55761: LD_INT 25
55763: EQUAL
55764: IFFALSE 55785
// points := [ 80 , 65 , 100 ] ;
55766: LD_ADDR_VAR 0 9
55770: PUSH
55771: LD_INT 80
55773: PUSH
55774: LD_INT 65
55776: PUSH
55777: LD_INT 100
55779: PUSH
55780: EMPTY
55781: LIST
55782: LIST
55783: LIST
55784: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55785: LD_VAR 0 6
55789: PPUSH
55790: CALL_OW 263
55794: PUSH
55795: LD_INT 1
55797: EQUAL
55798: IFFALSE 55833
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55800: LD_ADDR_VAR 0 10
55804: PUSH
55805: LD_VAR 0 10
55809: PUSH
55810: LD_VAR 0 6
55814: PPUSH
55815: CALL_OW 311
55819: PPUSH
55820: LD_INT 3
55822: PPUSH
55823: CALL_OW 259
55827: PUSH
55828: LD_INT 4
55830: MUL
55831: MUL
55832: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55833: LD_VAR 0 6
55837: PPUSH
55838: CALL_OW 263
55842: PUSH
55843: LD_INT 2
55845: EQUAL
55846: IFFALSE 55897
// begin j := IsControledBy ( i ) ;
55848: LD_ADDR_VAR 0 7
55852: PUSH
55853: LD_VAR 0 6
55857: PPUSH
55858: CALL_OW 312
55862: ST_TO_ADDR
// if j then
55863: LD_VAR 0 7
55867: IFFALSE 55897
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55869: LD_ADDR_VAR 0 10
55873: PUSH
55874: LD_VAR 0 10
55878: PUSH
55879: LD_VAR 0 7
55883: PPUSH
55884: LD_INT 3
55886: PPUSH
55887: CALL_OW 259
55891: PUSH
55892: LD_INT 3
55894: MUL
55895: MUL
55896: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55897: LD_VAR 0 6
55901: PPUSH
55902: CALL_OW 264
55906: PUSH
55907: LD_INT 5
55909: PUSH
55910: LD_INT 6
55912: PUSH
55913: LD_INT 46
55915: PUSH
55916: LD_INT 44
55918: PUSH
55919: LD_INT 47
55921: PUSH
55922: LD_INT 45
55924: PUSH
55925: LD_INT 28
55927: PUSH
55928: LD_INT 7
55930: PUSH
55931: LD_INT 27
55933: PUSH
55934: LD_INT 29
55936: PUSH
55937: EMPTY
55938: LIST
55939: LIST
55940: LIST
55941: LIST
55942: LIST
55943: LIST
55944: LIST
55945: LIST
55946: LIST
55947: LIST
55948: IN
55949: PUSH
55950: LD_VAR 0 1
55954: PPUSH
55955: LD_INT 52
55957: PPUSH
55958: CALL_OW 321
55962: PUSH
55963: LD_INT 2
55965: EQUAL
55966: AND
55967: IFFALSE 55984
// bpoints := bpoints * 1.2 ;
55969: LD_ADDR_VAR 0 10
55973: PUSH
55974: LD_VAR 0 10
55978: PUSH
55979: LD_REAL  1.20000000000000E+0000
55982: MUL
55983: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55984: LD_VAR 0 6
55988: PPUSH
55989: CALL_OW 264
55993: PUSH
55994: LD_INT 6
55996: PUSH
55997: LD_INT 46
55999: PUSH
56000: LD_INT 47
56002: PUSH
56003: EMPTY
56004: LIST
56005: LIST
56006: LIST
56007: IN
56008: IFFALSE 56025
// bpoints := bpoints * 1.2 ;
56010: LD_ADDR_VAR 0 10
56014: PUSH
56015: LD_VAR 0 10
56019: PUSH
56020: LD_REAL  1.20000000000000E+0000
56023: MUL
56024: ST_TO_ADDR
// end ; unit_building :
56025: GO 56039
56027: LD_INT 3
56029: DOUBLE
56030: EQUAL
56031: IFTRUE 56035
56033: GO 56038
56035: POP
// ; end ;
56036: GO 56039
56038: POP
// for j = 1 to 3 do
56039: LD_ADDR_VAR 0 7
56043: PUSH
56044: DOUBLE
56045: LD_INT 1
56047: DEC
56048: ST_TO_ADDR
56049: LD_INT 3
56051: PUSH
56052: FOR_TO
56053: IFFALSE 56106
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56055: LD_ADDR_VAR 0 5
56059: PUSH
56060: LD_VAR 0 5
56064: PPUSH
56065: LD_VAR 0 7
56069: PPUSH
56070: LD_VAR 0 5
56074: PUSH
56075: LD_VAR 0 7
56079: ARRAY
56080: PUSH
56081: LD_VAR 0 9
56085: PUSH
56086: LD_VAR 0 7
56090: ARRAY
56091: PUSH
56092: LD_VAR 0 10
56096: MUL
56097: PLUS
56098: PPUSH
56099: CALL_OW 1
56103: ST_TO_ADDR
56104: GO 56052
56106: POP
56107: POP
// end ;
56108: GO 54585
56110: POP
56111: POP
// result := Replace ( result , 4 , tmp ) ;
56112: LD_ADDR_VAR 0 5
56116: PUSH
56117: LD_VAR 0 5
56121: PPUSH
56122: LD_INT 4
56124: PPUSH
56125: LD_VAR 0 8
56129: PPUSH
56130: CALL_OW 1
56134: ST_TO_ADDR
// end ;
56135: LD_VAR 0 5
56139: RET
// export function DangerAtRange ( unit , range ) ; begin
56140: LD_INT 0
56142: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56143: LD_ADDR_VAR 0 3
56147: PUSH
56148: LD_VAR 0 1
56152: PPUSH
56153: CALL_OW 255
56157: PPUSH
56158: LD_VAR 0 1
56162: PPUSH
56163: CALL_OW 250
56167: PPUSH
56168: LD_VAR 0 1
56172: PPUSH
56173: CALL_OW 251
56177: PPUSH
56178: LD_VAR 0 2
56182: PPUSH
56183: CALL 54437 0 4
56187: ST_TO_ADDR
// end ;
56188: LD_VAR 0 3
56192: RET
// export function DangerInArea ( side , area ) ; begin
56193: LD_INT 0
56195: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56196: LD_ADDR_VAR 0 3
56200: PUSH
56201: LD_VAR 0 2
56205: PPUSH
56206: LD_INT 81
56208: PUSH
56209: LD_VAR 0 1
56213: PUSH
56214: EMPTY
56215: LIST
56216: LIST
56217: PPUSH
56218: CALL_OW 70
56222: ST_TO_ADDR
// end ;
56223: LD_VAR 0 3
56227: RET
// export function IsExtension ( b ) ; begin
56228: LD_INT 0
56230: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56231: LD_ADDR_VAR 0 2
56235: PUSH
56236: LD_VAR 0 1
56240: PUSH
56241: LD_INT 23
56243: PUSH
56244: LD_INT 20
56246: PUSH
56247: LD_INT 22
56249: PUSH
56250: LD_INT 17
56252: PUSH
56253: LD_INT 24
56255: PUSH
56256: LD_INT 21
56258: PUSH
56259: LD_INT 19
56261: PUSH
56262: LD_INT 16
56264: PUSH
56265: LD_INT 25
56267: PUSH
56268: LD_INT 18
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: LIST
56275: LIST
56276: LIST
56277: LIST
56278: LIST
56279: LIST
56280: LIST
56281: LIST
56282: IN
56283: ST_TO_ADDR
// end ;
56284: LD_VAR 0 2
56288: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56289: LD_INT 0
56291: PPUSH
56292: PPUSH
56293: PPUSH
// result := [ ] ;
56294: LD_ADDR_VAR 0 4
56298: PUSH
56299: EMPTY
56300: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56301: LD_ADDR_VAR 0 5
56305: PUSH
56306: LD_VAR 0 2
56310: PPUSH
56311: LD_INT 21
56313: PUSH
56314: LD_INT 3
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: PPUSH
56321: CALL_OW 70
56325: ST_TO_ADDR
// if not tmp then
56326: LD_VAR 0 5
56330: NOT
56331: IFFALSE 56335
// exit ;
56333: GO 56399
// if checkLink then
56335: LD_VAR 0 3
56339: IFFALSE 56389
// begin for i in tmp do
56341: LD_ADDR_VAR 0 6
56345: PUSH
56346: LD_VAR 0 5
56350: PUSH
56351: FOR_IN
56352: IFFALSE 56387
// if GetBase ( i ) <> base then
56354: LD_VAR 0 6
56358: PPUSH
56359: CALL_OW 274
56363: PUSH
56364: LD_VAR 0 1
56368: NONEQUAL
56369: IFFALSE 56385
// ComLinkToBase ( base , i ) ;
56371: LD_VAR 0 1
56375: PPUSH
56376: LD_VAR 0 6
56380: PPUSH
56381: CALL_OW 169
56385: GO 56351
56387: POP
56388: POP
// end ; result := tmp ;
56389: LD_ADDR_VAR 0 4
56393: PUSH
56394: LD_VAR 0 5
56398: ST_TO_ADDR
// end ;
56399: LD_VAR 0 4
56403: RET
// export function ComComplete ( units , b ) ; var i ; begin
56404: LD_INT 0
56406: PPUSH
56407: PPUSH
// if not units then
56408: LD_VAR 0 1
56412: NOT
56413: IFFALSE 56417
// exit ;
56415: GO 56507
// for i in units do
56417: LD_ADDR_VAR 0 4
56421: PUSH
56422: LD_VAR 0 1
56426: PUSH
56427: FOR_IN
56428: IFFALSE 56505
// if BuildingStatus ( b ) = bs_build then
56430: LD_VAR 0 2
56434: PPUSH
56435: CALL_OW 461
56439: PUSH
56440: LD_INT 1
56442: EQUAL
56443: IFFALSE 56503
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56445: LD_VAR 0 4
56449: PPUSH
56450: LD_STRING h
56452: PUSH
56453: LD_VAR 0 2
56457: PPUSH
56458: CALL_OW 250
56462: PUSH
56463: LD_VAR 0 2
56467: PPUSH
56468: CALL_OW 251
56472: PUSH
56473: LD_VAR 0 2
56477: PUSH
56478: LD_INT 0
56480: PUSH
56481: LD_INT 0
56483: PUSH
56484: LD_INT 0
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: LIST
56491: LIST
56492: LIST
56493: LIST
56494: LIST
56495: PUSH
56496: EMPTY
56497: LIST
56498: PPUSH
56499: CALL_OW 446
56503: GO 56427
56505: POP
56506: POP
// end ;
56507: LD_VAR 0 3
56511: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56512: LD_INT 0
56514: PPUSH
56515: PPUSH
56516: PPUSH
56517: PPUSH
56518: PPUSH
56519: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56520: LD_VAR 0 1
56524: NOT
56525: PUSH
56526: LD_VAR 0 1
56530: PPUSH
56531: CALL_OW 263
56535: PUSH
56536: LD_INT 2
56538: NONEQUAL
56539: OR
56540: IFFALSE 56544
// exit ;
56542: GO 56860
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56544: LD_ADDR_VAR 0 6
56548: PUSH
56549: LD_INT 22
56551: PUSH
56552: LD_VAR 0 1
56556: PPUSH
56557: CALL_OW 255
56561: PUSH
56562: EMPTY
56563: LIST
56564: LIST
56565: PUSH
56566: LD_INT 2
56568: PUSH
56569: LD_INT 30
56571: PUSH
56572: LD_INT 36
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: PUSH
56579: LD_INT 34
56581: PUSH
56582: LD_INT 31
56584: PUSH
56585: EMPTY
56586: LIST
56587: LIST
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: LIST
56593: PUSH
56594: EMPTY
56595: LIST
56596: LIST
56597: PPUSH
56598: CALL_OW 69
56602: ST_TO_ADDR
// if not tmp then
56603: LD_VAR 0 6
56607: NOT
56608: IFFALSE 56612
// exit ;
56610: GO 56860
// result := [ ] ;
56612: LD_ADDR_VAR 0 2
56616: PUSH
56617: EMPTY
56618: ST_TO_ADDR
// for i in tmp do
56619: LD_ADDR_VAR 0 3
56623: PUSH
56624: LD_VAR 0 6
56628: PUSH
56629: FOR_IN
56630: IFFALSE 56701
// begin t := UnitsInside ( i ) ;
56632: LD_ADDR_VAR 0 4
56636: PUSH
56637: LD_VAR 0 3
56641: PPUSH
56642: CALL_OW 313
56646: ST_TO_ADDR
// if t then
56647: LD_VAR 0 4
56651: IFFALSE 56699
// for j in t do
56653: LD_ADDR_VAR 0 7
56657: PUSH
56658: LD_VAR 0 4
56662: PUSH
56663: FOR_IN
56664: IFFALSE 56697
// result := Replace ( result , result + 1 , j ) ;
56666: LD_ADDR_VAR 0 2
56670: PUSH
56671: LD_VAR 0 2
56675: PPUSH
56676: LD_VAR 0 2
56680: PUSH
56681: LD_INT 1
56683: PLUS
56684: PPUSH
56685: LD_VAR 0 7
56689: PPUSH
56690: CALL_OW 1
56694: ST_TO_ADDR
56695: GO 56663
56697: POP
56698: POP
// end ;
56699: GO 56629
56701: POP
56702: POP
// if not result then
56703: LD_VAR 0 2
56707: NOT
56708: IFFALSE 56712
// exit ;
56710: GO 56860
// mech := result [ 1 ] ;
56712: LD_ADDR_VAR 0 5
56716: PUSH
56717: LD_VAR 0 2
56721: PUSH
56722: LD_INT 1
56724: ARRAY
56725: ST_TO_ADDR
// if result > 1 then
56726: LD_VAR 0 2
56730: PUSH
56731: LD_INT 1
56733: GREATER
56734: IFFALSE 56846
// begin for i = 2 to result do
56736: LD_ADDR_VAR 0 3
56740: PUSH
56741: DOUBLE
56742: LD_INT 2
56744: DEC
56745: ST_TO_ADDR
56746: LD_VAR 0 2
56750: PUSH
56751: FOR_TO
56752: IFFALSE 56844
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56754: LD_ADDR_VAR 0 4
56758: PUSH
56759: LD_VAR 0 2
56763: PUSH
56764: LD_VAR 0 3
56768: ARRAY
56769: PPUSH
56770: LD_INT 3
56772: PPUSH
56773: CALL_OW 259
56777: PUSH
56778: LD_VAR 0 2
56782: PUSH
56783: LD_VAR 0 3
56787: ARRAY
56788: PPUSH
56789: CALL_OW 432
56793: MINUS
56794: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56795: LD_VAR 0 4
56799: PUSH
56800: LD_VAR 0 5
56804: PPUSH
56805: LD_INT 3
56807: PPUSH
56808: CALL_OW 259
56812: PUSH
56813: LD_VAR 0 5
56817: PPUSH
56818: CALL_OW 432
56822: MINUS
56823: GREATEREQUAL
56824: IFFALSE 56842
// mech := result [ i ] ;
56826: LD_ADDR_VAR 0 5
56830: PUSH
56831: LD_VAR 0 2
56835: PUSH
56836: LD_VAR 0 3
56840: ARRAY
56841: ST_TO_ADDR
// end ;
56842: GO 56751
56844: POP
56845: POP
// end ; ComLinkTo ( vehicle , mech ) ;
56846: LD_VAR 0 1
56850: PPUSH
56851: LD_VAR 0 5
56855: PPUSH
56856: CALL_OW 135
// end ;
56860: LD_VAR 0 2
56864: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56865: LD_INT 0
56867: PPUSH
56868: PPUSH
56869: PPUSH
56870: PPUSH
56871: PPUSH
56872: PPUSH
56873: PPUSH
56874: PPUSH
56875: PPUSH
56876: PPUSH
56877: PPUSH
56878: PPUSH
56879: PPUSH
// result := [ ] ;
56880: LD_ADDR_VAR 0 7
56884: PUSH
56885: EMPTY
56886: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56887: LD_VAR 0 1
56891: PPUSH
56892: CALL_OW 266
56896: PUSH
56897: LD_INT 0
56899: PUSH
56900: LD_INT 1
56902: PUSH
56903: EMPTY
56904: LIST
56905: LIST
56906: IN
56907: NOT
56908: IFFALSE 56912
// exit ;
56910: GO 58546
// if name then
56912: LD_VAR 0 3
56916: IFFALSE 56932
// SetBName ( base_dep , name ) ;
56918: LD_VAR 0 1
56922: PPUSH
56923: LD_VAR 0 3
56927: PPUSH
56928: CALL_OW 500
// base := GetBase ( base_dep ) ;
56932: LD_ADDR_VAR 0 15
56936: PUSH
56937: LD_VAR 0 1
56941: PPUSH
56942: CALL_OW 274
56946: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56947: LD_ADDR_VAR 0 16
56951: PUSH
56952: LD_VAR 0 1
56956: PPUSH
56957: CALL_OW 255
56961: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56962: LD_ADDR_VAR 0 17
56966: PUSH
56967: LD_VAR 0 1
56971: PPUSH
56972: CALL_OW 248
56976: ST_TO_ADDR
// if sources then
56977: LD_VAR 0 5
56981: IFFALSE 57028
// for i = 1 to 3 do
56983: LD_ADDR_VAR 0 8
56987: PUSH
56988: DOUBLE
56989: LD_INT 1
56991: DEC
56992: ST_TO_ADDR
56993: LD_INT 3
56995: PUSH
56996: FOR_TO
56997: IFFALSE 57026
// AddResourceType ( base , i , sources [ i ] ) ;
56999: LD_VAR 0 15
57003: PPUSH
57004: LD_VAR 0 8
57008: PPUSH
57009: LD_VAR 0 5
57013: PUSH
57014: LD_VAR 0 8
57018: ARRAY
57019: PPUSH
57020: CALL_OW 276
57024: GO 56996
57026: POP
57027: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57028: LD_ADDR_VAR 0 18
57032: PUSH
57033: LD_VAR 0 15
57037: PPUSH
57038: LD_VAR 0 2
57042: PPUSH
57043: LD_INT 1
57045: PPUSH
57046: CALL 56289 0 3
57050: ST_TO_ADDR
// InitHc ;
57051: CALL_OW 19
// InitUc ;
57055: CALL_OW 18
// uc_side := side ;
57059: LD_ADDR_OWVAR 20
57063: PUSH
57064: LD_VAR 0 16
57068: ST_TO_ADDR
// uc_nation := nation ;
57069: LD_ADDR_OWVAR 21
57073: PUSH
57074: LD_VAR 0 17
57078: ST_TO_ADDR
// if buildings then
57079: LD_VAR 0 18
57083: IFFALSE 58405
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57085: LD_ADDR_VAR 0 19
57089: PUSH
57090: LD_VAR 0 18
57094: PPUSH
57095: LD_INT 2
57097: PUSH
57098: LD_INT 30
57100: PUSH
57101: LD_INT 29
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PUSH
57108: LD_INT 30
57110: PUSH
57111: LD_INT 30
57113: PUSH
57114: EMPTY
57115: LIST
57116: LIST
57117: PUSH
57118: EMPTY
57119: LIST
57120: LIST
57121: LIST
57122: PPUSH
57123: CALL_OW 72
57127: ST_TO_ADDR
// if tmp then
57128: LD_VAR 0 19
57132: IFFALSE 57180
// for i in tmp do
57134: LD_ADDR_VAR 0 8
57138: PUSH
57139: LD_VAR 0 19
57143: PUSH
57144: FOR_IN
57145: IFFALSE 57178
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57147: LD_VAR 0 8
57151: PPUSH
57152: CALL_OW 250
57156: PPUSH
57157: LD_VAR 0 8
57161: PPUSH
57162: CALL_OW 251
57166: PPUSH
57167: LD_VAR 0 16
57171: PPUSH
57172: CALL_OW 441
57176: GO 57144
57178: POP
57179: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57180: LD_VAR 0 18
57184: PPUSH
57185: LD_INT 2
57187: PUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 32
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: LD_INT 30
57200: PUSH
57201: LD_INT 33
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: EMPTY
57209: LIST
57210: LIST
57211: LIST
57212: PPUSH
57213: CALL_OW 72
57217: IFFALSE 57305
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57219: LD_ADDR_VAR 0 8
57223: PUSH
57224: LD_VAR 0 18
57228: PPUSH
57229: LD_INT 2
57231: PUSH
57232: LD_INT 30
57234: PUSH
57235: LD_INT 32
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: PUSH
57242: LD_INT 30
57244: PUSH
57245: LD_INT 33
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: LIST
57256: PPUSH
57257: CALL_OW 72
57261: PUSH
57262: FOR_IN
57263: IFFALSE 57303
// begin if not GetBWeapon ( i ) then
57265: LD_VAR 0 8
57269: PPUSH
57270: CALL_OW 269
57274: NOT
57275: IFFALSE 57301
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57277: LD_VAR 0 8
57281: PPUSH
57282: LD_VAR 0 8
57286: PPUSH
57287: LD_VAR 0 2
57291: PPUSH
57292: CALL 58551 0 2
57296: PPUSH
57297: CALL_OW 431
// end ;
57301: GO 57262
57303: POP
57304: POP
// end ; for i = 1 to personel do
57305: LD_ADDR_VAR 0 8
57309: PUSH
57310: DOUBLE
57311: LD_INT 1
57313: DEC
57314: ST_TO_ADDR
57315: LD_VAR 0 6
57319: PUSH
57320: FOR_TO
57321: IFFALSE 58385
// begin if i > 4 then
57323: LD_VAR 0 8
57327: PUSH
57328: LD_INT 4
57330: GREATER
57331: IFFALSE 57335
// break ;
57333: GO 58385
// case i of 1 :
57335: LD_VAR 0 8
57339: PUSH
57340: LD_INT 1
57342: DOUBLE
57343: EQUAL
57344: IFTRUE 57348
57346: GO 57428
57348: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57349: LD_ADDR_VAR 0 12
57353: PUSH
57354: LD_VAR 0 18
57358: PPUSH
57359: LD_INT 22
57361: PUSH
57362: LD_VAR 0 16
57366: PUSH
57367: EMPTY
57368: LIST
57369: LIST
57370: PUSH
57371: LD_INT 58
57373: PUSH
57374: EMPTY
57375: LIST
57376: PUSH
57377: LD_INT 2
57379: PUSH
57380: LD_INT 30
57382: PUSH
57383: LD_INT 32
57385: PUSH
57386: EMPTY
57387: LIST
57388: LIST
57389: PUSH
57390: LD_INT 30
57392: PUSH
57393: LD_INT 4
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: PUSH
57400: LD_INT 30
57402: PUSH
57403: LD_INT 5
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: LIST
57414: LIST
57415: PUSH
57416: EMPTY
57417: LIST
57418: LIST
57419: LIST
57420: PPUSH
57421: CALL_OW 72
57425: ST_TO_ADDR
57426: GO 57650
57428: LD_INT 2
57430: DOUBLE
57431: EQUAL
57432: IFTRUE 57436
57434: GO 57498
57436: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57437: LD_ADDR_VAR 0 12
57441: PUSH
57442: LD_VAR 0 18
57446: PPUSH
57447: LD_INT 22
57449: PUSH
57450: LD_VAR 0 16
57454: PUSH
57455: EMPTY
57456: LIST
57457: LIST
57458: PUSH
57459: LD_INT 2
57461: PUSH
57462: LD_INT 30
57464: PUSH
57465: LD_INT 0
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: PUSH
57472: LD_INT 30
57474: PUSH
57475: LD_INT 1
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: PUSH
57482: EMPTY
57483: LIST
57484: LIST
57485: LIST
57486: PUSH
57487: EMPTY
57488: LIST
57489: LIST
57490: PPUSH
57491: CALL_OW 72
57495: ST_TO_ADDR
57496: GO 57650
57498: LD_INT 3
57500: DOUBLE
57501: EQUAL
57502: IFTRUE 57506
57504: GO 57568
57506: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57507: LD_ADDR_VAR 0 12
57511: PUSH
57512: LD_VAR 0 18
57516: PPUSH
57517: LD_INT 22
57519: PUSH
57520: LD_VAR 0 16
57524: PUSH
57525: EMPTY
57526: LIST
57527: LIST
57528: PUSH
57529: LD_INT 2
57531: PUSH
57532: LD_INT 30
57534: PUSH
57535: LD_INT 2
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: PUSH
57542: LD_INT 30
57544: PUSH
57545: LD_INT 3
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: LIST
57556: PUSH
57557: EMPTY
57558: LIST
57559: LIST
57560: PPUSH
57561: CALL_OW 72
57565: ST_TO_ADDR
57566: GO 57650
57568: LD_INT 4
57570: DOUBLE
57571: EQUAL
57572: IFTRUE 57576
57574: GO 57649
57576: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57577: LD_ADDR_VAR 0 12
57581: PUSH
57582: LD_VAR 0 18
57586: PPUSH
57587: LD_INT 22
57589: PUSH
57590: LD_VAR 0 16
57594: PUSH
57595: EMPTY
57596: LIST
57597: LIST
57598: PUSH
57599: LD_INT 2
57601: PUSH
57602: LD_INT 30
57604: PUSH
57605: LD_INT 6
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: PUSH
57612: LD_INT 30
57614: PUSH
57615: LD_INT 7
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PUSH
57622: LD_INT 30
57624: PUSH
57625: LD_INT 8
57627: PUSH
57628: EMPTY
57629: LIST
57630: LIST
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: LIST
57636: LIST
57637: PUSH
57638: EMPTY
57639: LIST
57640: LIST
57641: PPUSH
57642: CALL_OW 72
57646: ST_TO_ADDR
57647: GO 57650
57649: POP
// if i = 1 then
57650: LD_VAR 0 8
57654: PUSH
57655: LD_INT 1
57657: EQUAL
57658: IFFALSE 57769
// begin tmp := [ ] ;
57660: LD_ADDR_VAR 0 19
57664: PUSH
57665: EMPTY
57666: ST_TO_ADDR
// for j in f do
57667: LD_ADDR_VAR 0 9
57671: PUSH
57672: LD_VAR 0 12
57676: PUSH
57677: FOR_IN
57678: IFFALSE 57751
// if GetBType ( j ) = b_bunker then
57680: LD_VAR 0 9
57684: PPUSH
57685: CALL_OW 266
57689: PUSH
57690: LD_INT 32
57692: EQUAL
57693: IFFALSE 57720
// tmp := Insert ( tmp , 1 , j ) else
57695: LD_ADDR_VAR 0 19
57699: PUSH
57700: LD_VAR 0 19
57704: PPUSH
57705: LD_INT 1
57707: PPUSH
57708: LD_VAR 0 9
57712: PPUSH
57713: CALL_OW 2
57717: ST_TO_ADDR
57718: GO 57749
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57720: LD_ADDR_VAR 0 19
57724: PUSH
57725: LD_VAR 0 19
57729: PPUSH
57730: LD_VAR 0 19
57734: PUSH
57735: LD_INT 1
57737: PLUS
57738: PPUSH
57739: LD_VAR 0 9
57743: PPUSH
57744: CALL_OW 2
57748: ST_TO_ADDR
57749: GO 57677
57751: POP
57752: POP
// if tmp then
57753: LD_VAR 0 19
57757: IFFALSE 57769
// f := tmp ;
57759: LD_ADDR_VAR 0 12
57763: PUSH
57764: LD_VAR 0 19
57768: ST_TO_ADDR
// end ; x := personel [ i ] ;
57769: LD_ADDR_VAR 0 13
57773: PUSH
57774: LD_VAR 0 6
57778: PUSH
57779: LD_VAR 0 8
57783: ARRAY
57784: ST_TO_ADDR
// if x = - 1 then
57785: LD_VAR 0 13
57789: PUSH
57790: LD_INT 1
57792: NEG
57793: EQUAL
57794: IFFALSE 58003
// begin for j in f do
57796: LD_ADDR_VAR 0 9
57800: PUSH
57801: LD_VAR 0 12
57805: PUSH
57806: FOR_IN
57807: IFFALSE 57999
// repeat InitHc ;
57809: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57813: LD_VAR 0 9
57817: PPUSH
57818: CALL_OW 266
57822: PUSH
57823: LD_INT 5
57825: EQUAL
57826: IFFALSE 57896
// begin if UnitsInside ( j ) < 3 then
57828: LD_VAR 0 9
57832: PPUSH
57833: CALL_OW 313
57837: PUSH
57838: LD_INT 3
57840: LESS
57841: IFFALSE 57877
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57843: LD_INT 0
57845: PPUSH
57846: LD_INT 5
57848: PUSH
57849: LD_INT 8
57851: PUSH
57852: LD_INT 9
57854: PUSH
57855: EMPTY
57856: LIST
57857: LIST
57858: LIST
57859: PUSH
57860: LD_VAR 0 17
57864: ARRAY
57865: PPUSH
57866: LD_VAR 0 4
57870: PPUSH
57871: CALL_OW 380
57875: GO 57894
// PrepareHuman ( false , i , skill ) ;
57877: LD_INT 0
57879: PPUSH
57880: LD_VAR 0 8
57884: PPUSH
57885: LD_VAR 0 4
57889: PPUSH
57890: CALL_OW 380
// end else
57894: GO 57913
// PrepareHuman ( false , i , skill ) ;
57896: LD_INT 0
57898: PPUSH
57899: LD_VAR 0 8
57903: PPUSH
57904: LD_VAR 0 4
57908: PPUSH
57909: CALL_OW 380
// un := CreateHuman ;
57913: LD_ADDR_VAR 0 14
57917: PUSH
57918: CALL_OW 44
57922: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57923: LD_ADDR_VAR 0 7
57927: PUSH
57928: LD_VAR 0 7
57932: PPUSH
57933: LD_INT 1
57935: PPUSH
57936: LD_VAR 0 14
57940: PPUSH
57941: CALL_OW 2
57945: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57946: LD_VAR 0 14
57950: PPUSH
57951: LD_VAR 0 9
57955: PPUSH
57956: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57960: LD_VAR 0 9
57964: PPUSH
57965: CALL_OW 313
57969: PUSH
57970: LD_INT 6
57972: EQUAL
57973: PUSH
57974: LD_VAR 0 9
57978: PPUSH
57979: CALL_OW 266
57983: PUSH
57984: LD_INT 32
57986: PUSH
57987: LD_INT 31
57989: PUSH
57990: EMPTY
57991: LIST
57992: LIST
57993: IN
57994: OR
57995: IFFALSE 57809
57997: GO 57806
57999: POP
58000: POP
// end else
58001: GO 58383
// for j = 1 to x do
58003: LD_ADDR_VAR 0 9
58007: PUSH
58008: DOUBLE
58009: LD_INT 1
58011: DEC
58012: ST_TO_ADDR
58013: LD_VAR 0 13
58017: PUSH
58018: FOR_TO
58019: IFFALSE 58381
// begin InitHc ;
58021: CALL_OW 19
// if not f then
58025: LD_VAR 0 12
58029: NOT
58030: IFFALSE 58119
// begin PrepareHuman ( false , i , skill ) ;
58032: LD_INT 0
58034: PPUSH
58035: LD_VAR 0 8
58039: PPUSH
58040: LD_VAR 0 4
58044: PPUSH
58045: CALL_OW 380
// un := CreateHuman ;
58049: LD_ADDR_VAR 0 14
58053: PUSH
58054: CALL_OW 44
58058: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58059: LD_ADDR_VAR 0 7
58063: PUSH
58064: LD_VAR 0 7
58068: PPUSH
58069: LD_INT 1
58071: PPUSH
58072: LD_VAR 0 14
58076: PPUSH
58077: CALL_OW 2
58081: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58082: LD_VAR 0 14
58086: PPUSH
58087: LD_VAR 0 1
58091: PPUSH
58092: CALL_OW 250
58096: PPUSH
58097: LD_VAR 0 1
58101: PPUSH
58102: CALL_OW 251
58106: PPUSH
58107: LD_INT 10
58109: PPUSH
58110: LD_INT 0
58112: PPUSH
58113: CALL_OW 50
// continue ;
58117: GO 58018
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58119: LD_VAR 0 12
58123: PUSH
58124: LD_INT 1
58126: ARRAY
58127: PPUSH
58128: CALL_OW 313
58132: PUSH
58133: LD_VAR 0 12
58137: PUSH
58138: LD_INT 1
58140: ARRAY
58141: PPUSH
58142: CALL_OW 266
58146: PUSH
58147: LD_INT 32
58149: PUSH
58150: LD_INT 31
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: IN
58157: AND
58158: PUSH
58159: LD_VAR 0 12
58163: PUSH
58164: LD_INT 1
58166: ARRAY
58167: PPUSH
58168: CALL_OW 313
58172: PUSH
58173: LD_INT 6
58175: EQUAL
58176: OR
58177: IFFALSE 58197
// f := Delete ( f , 1 ) ;
58179: LD_ADDR_VAR 0 12
58183: PUSH
58184: LD_VAR 0 12
58188: PPUSH
58189: LD_INT 1
58191: PPUSH
58192: CALL_OW 3
58196: ST_TO_ADDR
// if not f then
58197: LD_VAR 0 12
58201: NOT
58202: IFFALSE 58220
// begin x := x + 2 ;
58204: LD_ADDR_VAR 0 13
58208: PUSH
58209: LD_VAR 0 13
58213: PUSH
58214: LD_INT 2
58216: PLUS
58217: ST_TO_ADDR
// continue ;
58218: GO 58018
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58220: LD_VAR 0 12
58224: PUSH
58225: LD_INT 1
58227: ARRAY
58228: PPUSH
58229: CALL_OW 266
58233: PUSH
58234: LD_INT 5
58236: EQUAL
58237: IFFALSE 58311
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58239: LD_VAR 0 12
58243: PUSH
58244: LD_INT 1
58246: ARRAY
58247: PPUSH
58248: CALL_OW 313
58252: PUSH
58253: LD_INT 3
58255: LESS
58256: IFFALSE 58292
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58258: LD_INT 0
58260: PPUSH
58261: LD_INT 5
58263: PUSH
58264: LD_INT 8
58266: PUSH
58267: LD_INT 9
58269: PUSH
58270: EMPTY
58271: LIST
58272: LIST
58273: LIST
58274: PUSH
58275: LD_VAR 0 17
58279: ARRAY
58280: PPUSH
58281: LD_VAR 0 4
58285: PPUSH
58286: CALL_OW 380
58290: GO 58309
// PrepareHuman ( false , i , skill ) ;
58292: LD_INT 0
58294: PPUSH
58295: LD_VAR 0 8
58299: PPUSH
58300: LD_VAR 0 4
58304: PPUSH
58305: CALL_OW 380
// end else
58309: GO 58328
// PrepareHuman ( false , i , skill ) ;
58311: LD_INT 0
58313: PPUSH
58314: LD_VAR 0 8
58318: PPUSH
58319: LD_VAR 0 4
58323: PPUSH
58324: CALL_OW 380
// un := CreateHuman ;
58328: LD_ADDR_VAR 0 14
58332: PUSH
58333: CALL_OW 44
58337: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58338: LD_ADDR_VAR 0 7
58342: PUSH
58343: LD_VAR 0 7
58347: PPUSH
58348: LD_INT 1
58350: PPUSH
58351: LD_VAR 0 14
58355: PPUSH
58356: CALL_OW 2
58360: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58361: LD_VAR 0 14
58365: PPUSH
58366: LD_VAR 0 12
58370: PUSH
58371: LD_INT 1
58373: ARRAY
58374: PPUSH
58375: CALL_OW 52
// end ;
58379: GO 58018
58381: POP
58382: POP
// end ;
58383: GO 57320
58385: POP
58386: POP
// result := result ^ buildings ;
58387: LD_ADDR_VAR 0 7
58391: PUSH
58392: LD_VAR 0 7
58396: PUSH
58397: LD_VAR 0 18
58401: ADD
58402: ST_TO_ADDR
// end else
58403: GO 58546
// begin for i = 1 to personel do
58405: LD_ADDR_VAR 0 8
58409: PUSH
58410: DOUBLE
58411: LD_INT 1
58413: DEC
58414: ST_TO_ADDR
58415: LD_VAR 0 6
58419: PUSH
58420: FOR_TO
58421: IFFALSE 58544
// begin if i > 4 then
58423: LD_VAR 0 8
58427: PUSH
58428: LD_INT 4
58430: GREATER
58431: IFFALSE 58435
// break ;
58433: GO 58544
// x := personel [ i ] ;
58435: LD_ADDR_VAR 0 13
58439: PUSH
58440: LD_VAR 0 6
58444: PUSH
58445: LD_VAR 0 8
58449: ARRAY
58450: ST_TO_ADDR
// if x = - 1 then
58451: LD_VAR 0 13
58455: PUSH
58456: LD_INT 1
58458: NEG
58459: EQUAL
58460: IFFALSE 58464
// continue ;
58462: GO 58420
// PrepareHuman ( false , i , skill ) ;
58464: LD_INT 0
58466: PPUSH
58467: LD_VAR 0 8
58471: PPUSH
58472: LD_VAR 0 4
58476: PPUSH
58477: CALL_OW 380
// un := CreateHuman ;
58481: LD_ADDR_VAR 0 14
58485: PUSH
58486: CALL_OW 44
58490: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58491: LD_VAR 0 14
58495: PPUSH
58496: LD_VAR 0 1
58500: PPUSH
58501: CALL_OW 250
58505: PPUSH
58506: LD_VAR 0 1
58510: PPUSH
58511: CALL_OW 251
58515: PPUSH
58516: LD_INT 10
58518: PPUSH
58519: LD_INT 0
58521: PPUSH
58522: CALL_OW 50
// result := result ^ un ;
58526: LD_ADDR_VAR 0 7
58530: PUSH
58531: LD_VAR 0 7
58535: PUSH
58536: LD_VAR 0 14
58540: ADD
58541: ST_TO_ADDR
// end ;
58542: GO 58420
58544: POP
58545: POP
// end ; end ;
58546: LD_VAR 0 7
58550: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58551: LD_INT 0
58553: PPUSH
58554: PPUSH
58555: PPUSH
58556: PPUSH
58557: PPUSH
58558: PPUSH
58559: PPUSH
58560: PPUSH
58561: PPUSH
58562: PPUSH
58563: PPUSH
58564: PPUSH
58565: PPUSH
58566: PPUSH
58567: PPUSH
58568: PPUSH
// result := false ;
58569: LD_ADDR_VAR 0 3
58573: PUSH
58574: LD_INT 0
58576: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58577: LD_VAR 0 1
58581: NOT
58582: PUSH
58583: LD_VAR 0 1
58587: PPUSH
58588: CALL_OW 266
58592: PUSH
58593: LD_INT 32
58595: PUSH
58596: LD_INT 33
58598: PUSH
58599: EMPTY
58600: LIST
58601: LIST
58602: IN
58603: NOT
58604: OR
58605: IFFALSE 58609
// exit ;
58607: GO 59718
// nat := GetNation ( tower ) ;
58609: LD_ADDR_VAR 0 12
58613: PUSH
58614: LD_VAR 0 1
58618: PPUSH
58619: CALL_OW 248
58623: ST_TO_ADDR
// side := GetSide ( tower ) ;
58624: LD_ADDR_VAR 0 16
58628: PUSH
58629: LD_VAR 0 1
58633: PPUSH
58634: CALL_OW 255
58638: ST_TO_ADDR
// x := GetX ( tower ) ;
58639: LD_ADDR_VAR 0 10
58643: PUSH
58644: LD_VAR 0 1
58648: PPUSH
58649: CALL_OW 250
58653: ST_TO_ADDR
// y := GetY ( tower ) ;
58654: LD_ADDR_VAR 0 11
58658: PUSH
58659: LD_VAR 0 1
58663: PPUSH
58664: CALL_OW 251
58668: ST_TO_ADDR
// if not x or not y then
58669: LD_VAR 0 10
58673: NOT
58674: PUSH
58675: LD_VAR 0 11
58679: NOT
58680: OR
58681: IFFALSE 58685
// exit ;
58683: GO 59718
// weapon := 0 ;
58685: LD_ADDR_VAR 0 18
58689: PUSH
58690: LD_INT 0
58692: ST_TO_ADDR
// fac_list := [ ] ;
58693: LD_ADDR_VAR 0 17
58697: PUSH
58698: EMPTY
58699: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58700: LD_ADDR_VAR 0 6
58704: PUSH
58705: LD_VAR 0 1
58709: PPUSH
58710: CALL_OW 274
58714: PPUSH
58715: LD_VAR 0 2
58719: PPUSH
58720: LD_INT 0
58722: PPUSH
58723: CALL 56289 0 3
58727: PPUSH
58728: LD_INT 30
58730: PUSH
58731: LD_INT 3
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PPUSH
58738: CALL_OW 72
58742: ST_TO_ADDR
// if not factories then
58743: LD_VAR 0 6
58747: NOT
58748: IFFALSE 58752
// exit ;
58750: GO 59718
// for i in factories do
58752: LD_ADDR_VAR 0 8
58756: PUSH
58757: LD_VAR 0 6
58761: PUSH
58762: FOR_IN
58763: IFFALSE 58788
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58765: LD_ADDR_VAR 0 17
58769: PUSH
58770: LD_VAR 0 17
58774: PUSH
58775: LD_VAR 0 8
58779: PPUSH
58780: CALL_OW 478
58784: UNION
58785: ST_TO_ADDR
58786: GO 58762
58788: POP
58789: POP
// if not fac_list then
58790: LD_VAR 0 17
58794: NOT
58795: IFFALSE 58799
// exit ;
58797: GO 59718
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58799: LD_ADDR_VAR 0 5
58803: PUSH
58804: LD_INT 4
58806: PUSH
58807: LD_INT 5
58809: PUSH
58810: LD_INT 9
58812: PUSH
58813: LD_INT 10
58815: PUSH
58816: LD_INT 6
58818: PUSH
58819: LD_INT 7
58821: PUSH
58822: LD_INT 11
58824: PUSH
58825: EMPTY
58826: LIST
58827: LIST
58828: LIST
58829: LIST
58830: LIST
58831: LIST
58832: LIST
58833: PUSH
58834: LD_INT 27
58836: PUSH
58837: LD_INT 28
58839: PUSH
58840: LD_INT 26
58842: PUSH
58843: LD_INT 30
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: LIST
58850: LIST
58851: PUSH
58852: LD_INT 43
58854: PUSH
58855: LD_INT 44
58857: PUSH
58858: LD_INT 46
58860: PUSH
58861: LD_INT 45
58863: PUSH
58864: LD_INT 47
58866: PUSH
58867: LD_INT 49
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: LIST
58876: LIST
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: LIST
58882: PUSH
58883: LD_VAR 0 12
58887: ARRAY
58888: ST_TO_ADDR
// list := list isect fac_list ;
58889: LD_ADDR_VAR 0 5
58893: PUSH
58894: LD_VAR 0 5
58898: PUSH
58899: LD_VAR 0 17
58903: ISECT
58904: ST_TO_ADDR
// if not list then
58905: LD_VAR 0 5
58909: NOT
58910: IFFALSE 58914
// exit ;
58912: GO 59718
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58914: LD_VAR 0 12
58918: PUSH
58919: LD_INT 3
58921: EQUAL
58922: PUSH
58923: LD_INT 49
58925: PUSH
58926: LD_VAR 0 5
58930: IN
58931: AND
58932: PUSH
58933: LD_INT 31
58935: PPUSH
58936: LD_VAR 0 16
58940: PPUSH
58941: CALL_OW 321
58945: PUSH
58946: LD_INT 2
58948: EQUAL
58949: AND
58950: IFFALSE 59010
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58952: LD_INT 22
58954: PUSH
58955: LD_VAR 0 16
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: PUSH
58964: LD_INT 35
58966: PUSH
58967: LD_INT 49
58969: PUSH
58970: EMPTY
58971: LIST
58972: LIST
58973: PUSH
58974: LD_INT 91
58976: PUSH
58977: LD_VAR 0 1
58981: PUSH
58982: LD_INT 10
58984: PUSH
58985: EMPTY
58986: LIST
58987: LIST
58988: LIST
58989: PUSH
58990: EMPTY
58991: LIST
58992: LIST
58993: LIST
58994: PPUSH
58995: CALL_OW 69
58999: NOT
59000: IFFALSE 59010
// weapon := ru_time_lapser ;
59002: LD_ADDR_VAR 0 18
59006: PUSH
59007: LD_INT 49
59009: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59010: LD_VAR 0 12
59014: PUSH
59015: LD_INT 1
59017: PUSH
59018: LD_INT 2
59020: PUSH
59021: EMPTY
59022: LIST
59023: LIST
59024: IN
59025: PUSH
59026: LD_INT 11
59028: PUSH
59029: LD_VAR 0 5
59033: IN
59034: PUSH
59035: LD_INT 30
59037: PUSH
59038: LD_VAR 0 5
59042: IN
59043: OR
59044: AND
59045: PUSH
59046: LD_INT 6
59048: PPUSH
59049: LD_VAR 0 16
59053: PPUSH
59054: CALL_OW 321
59058: PUSH
59059: LD_INT 2
59061: EQUAL
59062: AND
59063: IFFALSE 59228
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59065: LD_INT 22
59067: PUSH
59068: LD_VAR 0 16
59072: PUSH
59073: EMPTY
59074: LIST
59075: LIST
59076: PUSH
59077: LD_INT 2
59079: PUSH
59080: LD_INT 35
59082: PUSH
59083: LD_INT 11
59085: PUSH
59086: EMPTY
59087: LIST
59088: LIST
59089: PUSH
59090: LD_INT 35
59092: PUSH
59093: LD_INT 30
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: LIST
59104: PUSH
59105: LD_INT 91
59107: PUSH
59108: LD_VAR 0 1
59112: PUSH
59113: LD_INT 18
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: LIST
59120: PUSH
59121: EMPTY
59122: LIST
59123: LIST
59124: LIST
59125: PPUSH
59126: CALL_OW 69
59130: NOT
59131: PUSH
59132: LD_INT 22
59134: PUSH
59135: LD_VAR 0 16
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PUSH
59144: LD_INT 2
59146: PUSH
59147: LD_INT 30
59149: PUSH
59150: LD_INT 32
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PUSH
59157: LD_INT 30
59159: PUSH
59160: LD_INT 33
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: PUSH
59167: EMPTY
59168: LIST
59169: LIST
59170: LIST
59171: PUSH
59172: LD_INT 91
59174: PUSH
59175: LD_VAR 0 1
59179: PUSH
59180: LD_INT 12
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: LIST
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: LIST
59192: PUSH
59193: EMPTY
59194: LIST
59195: PPUSH
59196: CALL_OW 69
59200: PUSH
59201: LD_INT 2
59203: GREATER
59204: AND
59205: IFFALSE 59228
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59207: LD_ADDR_VAR 0 18
59211: PUSH
59212: LD_INT 11
59214: PUSH
59215: LD_INT 30
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: PUSH
59222: LD_VAR 0 12
59226: ARRAY
59227: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59228: LD_VAR 0 18
59232: NOT
59233: PUSH
59234: LD_INT 40
59236: PPUSH
59237: LD_VAR 0 16
59241: PPUSH
59242: CALL_OW 321
59246: PUSH
59247: LD_INT 2
59249: EQUAL
59250: AND
59251: PUSH
59252: LD_INT 7
59254: PUSH
59255: LD_VAR 0 5
59259: IN
59260: PUSH
59261: LD_INT 28
59263: PUSH
59264: LD_VAR 0 5
59268: IN
59269: OR
59270: PUSH
59271: LD_INT 45
59273: PUSH
59274: LD_VAR 0 5
59278: IN
59279: OR
59280: AND
59281: IFFALSE 59535
// begin hex := GetHexInfo ( x , y ) ;
59283: LD_ADDR_VAR 0 4
59287: PUSH
59288: LD_VAR 0 10
59292: PPUSH
59293: LD_VAR 0 11
59297: PPUSH
59298: CALL_OW 546
59302: ST_TO_ADDR
// if hex [ 1 ] then
59303: LD_VAR 0 4
59307: PUSH
59308: LD_INT 1
59310: ARRAY
59311: IFFALSE 59315
// exit ;
59313: GO 59718
// height := hex [ 2 ] ;
59315: LD_ADDR_VAR 0 15
59319: PUSH
59320: LD_VAR 0 4
59324: PUSH
59325: LD_INT 2
59327: ARRAY
59328: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59329: LD_ADDR_VAR 0 14
59333: PUSH
59334: LD_INT 0
59336: PUSH
59337: LD_INT 2
59339: PUSH
59340: LD_INT 3
59342: PUSH
59343: LD_INT 5
59345: PUSH
59346: EMPTY
59347: LIST
59348: LIST
59349: LIST
59350: LIST
59351: ST_TO_ADDR
// for i in tmp do
59352: LD_ADDR_VAR 0 8
59356: PUSH
59357: LD_VAR 0 14
59361: PUSH
59362: FOR_IN
59363: IFFALSE 59533
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59365: LD_ADDR_VAR 0 9
59369: PUSH
59370: LD_VAR 0 10
59374: PPUSH
59375: LD_VAR 0 8
59379: PPUSH
59380: LD_INT 5
59382: PPUSH
59383: CALL_OW 272
59387: PUSH
59388: LD_VAR 0 11
59392: PPUSH
59393: LD_VAR 0 8
59397: PPUSH
59398: LD_INT 5
59400: PPUSH
59401: CALL_OW 273
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59410: LD_VAR 0 9
59414: PUSH
59415: LD_INT 1
59417: ARRAY
59418: PPUSH
59419: LD_VAR 0 9
59423: PUSH
59424: LD_INT 2
59426: ARRAY
59427: PPUSH
59428: CALL_OW 488
59432: IFFALSE 59531
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59434: LD_ADDR_VAR 0 4
59438: PUSH
59439: LD_VAR 0 9
59443: PUSH
59444: LD_INT 1
59446: ARRAY
59447: PPUSH
59448: LD_VAR 0 9
59452: PUSH
59453: LD_INT 2
59455: ARRAY
59456: PPUSH
59457: CALL_OW 546
59461: ST_TO_ADDR
// if hex [ 1 ] then
59462: LD_VAR 0 4
59466: PUSH
59467: LD_INT 1
59469: ARRAY
59470: IFFALSE 59474
// continue ;
59472: GO 59362
// h := hex [ 2 ] ;
59474: LD_ADDR_VAR 0 13
59478: PUSH
59479: LD_VAR 0 4
59483: PUSH
59484: LD_INT 2
59486: ARRAY
59487: ST_TO_ADDR
// if h + 7 < height then
59488: LD_VAR 0 13
59492: PUSH
59493: LD_INT 7
59495: PLUS
59496: PUSH
59497: LD_VAR 0 15
59501: LESS
59502: IFFALSE 59531
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59504: LD_ADDR_VAR 0 18
59508: PUSH
59509: LD_INT 7
59511: PUSH
59512: LD_INT 28
59514: PUSH
59515: LD_INT 45
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: LIST
59522: PUSH
59523: LD_VAR 0 12
59527: ARRAY
59528: ST_TO_ADDR
// break ;
59529: GO 59533
// end ; end ; end ;
59531: GO 59362
59533: POP
59534: POP
// end ; if not weapon then
59535: LD_VAR 0 18
59539: NOT
59540: IFFALSE 59600
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59542: LD_ADDR_VAR 0 5
59546: PUSH
59547: LD_VAR 0 5
59551: PUSH
59552: LD_INT 11
59554: PUSH
59555: LD_INT 30
59557: PUSH
59558: LD_INT 49
59560: PUSH
59561: EMPTY
59562: LIST
59563: LIST
59564: LIST
59565: DIFF
59566: ST_TO_ADDR
// if not list then
59567: LD_VAR 0 5
59571: NOT
59572: IFFALSE 59576
// exit ;
59574: GO 59718
// weapon := list [ rand ( 1 , list ) ] ;
59576: LD_ADDR_VAR 0 18
59580: PUSH
59581: LD_VAR 0 5
59585: PUSH
59586: LD_INT 1
59588: PPUSH
59589: LD_VAR 0 5
59593: PPUSH
59594: CALL_OW 12
59598: ARRAY
59599: ST_TO_ADDR
// end ; if weapon then
59600: LD_VAR 0 18
59604: IFFALSE 59718
// begin tmp := CostOfWeapon ( weapon ) ;
59606: LD_ADDR_VAR 0 14
59610: PUSH
59611: LD_VAR 0 18
59615: PPUSH
59616: CALL_OW 451
59620: ST_TO_ADDR
// j := GetBase ( tower ) ;
59621: LD_ADDR_VAR 0 9
59625: PUSH
59626: LD_VAR 0 1
59630: PPUSH
59631: CALL_OW 274
59635: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59636: LD_VAR 0 9
59640: PPUSH
59641: LD_INT 1
59643: PPUSH
59644: CALL_OW 275
59648: PUSH
59649: LD_VAR 0 14
59653: PUSH
59654: LD_INT 1
59656: ARRAY
59657: GREATEREQUAL
59658: PUSH
59659: LD_VAR 0 9
59663: PPUSH
59664: LD_INT 2
59666: PPUSH
59667: CALL_OW 275
59671: PUSH
59672: LD_VAR 0 14
59676: PUSH
59677: LD_INT 2
59679: ARRAY
59680: GREATEREQUAL
59681: AND
59682: PUSH
59683: LD_VAR 0 9
59687: PPUSH
59688: LD_INT 3
59690: PPUSH
59691: CALL_OW 275
59695: PUSH
59696: LD_VAR 0 14
59700: PUSH
59701: LD_INT 3
59703: ARRAY
59704: GREATEREQUAL
59705: AND
59706: IFFALSE 59718
// result := weapon ;
59708: LD_ADDR_VAR 0 3
59712: PUSH
59713: LD_VAR 0 18
59717: ST_TO_ADDR
// end ; end ;
59718: LD_VAR 0 3
59722: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59723: LD_INT 0
59725: PPUSH
59726: PPUSH
// result := true ;
59727: LD_ADDR_VAR 0 3
59731: PUSH
59732: LD_INT 1
59734: ST_TO_ADDR
// if array1 = array2 then
59735: LD_VAR 0 1
59739: PUSH
59740: LD_VAR 0 2
59744: EQUAL
59745: IFFALSE 59805
// begin for i = 1 to array1 do
59747: LD_ADDR_VAR 0 4
59751: PUSH
59752: DOUBLE
59753: LD_INT 1
59755: DEC
59756: ST_TO_ADDR
59757: LD_VAR 0 1
59761: PUSH
59762: FOR_TO
59763: IFFALSE 59801
// if array1 [ i ] <> array2 [ i ] then
59765: LD_VAR 0 1
59769: PUSH
59770: LD_VAR 0 4
59774: ARRAY
59775: PUSH
59776: LD_VAR 0 2
59780: PUSH
59781: LD_VAR 0 4
59785: ARRAY
59786: NONEQUAL
59787: IFFALSE 59799
// begin result := false ;
59789: LD_ADDR_VAR 0 3
59793: PUSH
59794: LD_INT 0
59796: ST_TO_ADDR
// break ;
59797: GO 59801
// end ;
59799: GO 59762
59801: POP
59802: POP
// end else
59803: GO 59813
// result := false ;
59805: LD_ADDR_VAR 0 3
59809: PUSH
59810: LD_INT 0
59812: ST_TO_ADDR
// end ;
59813: LD_VAR 0 3
59817: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59818: LD_INT 0
59820: PPUSH
59821: PPUSH
// if not array1 or not array2 then
59822: LD_VAR 0 1
59826: NOT
59827: PUSH
59828: LD_VAR 0 2
59832: NOT
59833: OR
59834: IFFALSE 59838
// exit ;
59836: GO 59902
// result := true ;
59838: LD_ADDR_VAR 0 3
59842: PUSH
59843: LD_INT 1
59845: ST_TO_ADDR
// for i = 1 to array1 do
59846: LD_ADDR_VAR 0 4
59850: PUSH
59851: DOUBLE
59852: LD_INT 1
59854: DEC
59855: ST_TO_ADDR
59856: LD_VAR 0 1
59860: PUSH
59861: FOR_TO
59862: IFFALSE 59900
// if array1 [ i ] <> array2 [ i ] then
59864: LD_VAR 0 1
59868: PUSH
59869: LD_VAR 0 4
59873: ARRAY
59874: PUSH
59875: LD_VAR 0 2
59879: PUSH
59880: LD_VAR 0 4
59884: ARRAY
59885: NONEQUAL
59886: IFFALSE 59898
// begin result := false ;
59888: LD_ADDR_VAR 0 3
59892: PUSH
59893: LD_INT 0
59895: ST_TO_ADDR
// break ;
59896: GO 59900
// end ;
59898: GO 59861
59900: POP
59901: POP
// end ;
59902: LD_VAR 0 3
59906: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59907: LD_INT 0
59909: PPUSH
59910: PPUSH
59911: PPUSH
// pom := GetBase ( fac ) ;
59912: LD_ADDR_VAR 0 5
59916: PUSH
59917: LD_VAR 0 1
59921: PPUSH
59922: CALL_OW 274
59926: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59927: LD_ADDR_VAR 0 4
59931: PUSH
59932: LD_VAR 0 2
59936: PUSH
59937: LD_INT 1
59939: ARRAY
59940: PPUSH
59941: LD_VAR 0 2
59945: PUSH
59946: LD_INT 2
59948: ARRAY
59949: PPUSH
59950: LD_VAR 0 2
59954: PUSH
59955: LD_INT 3
59957: ARRAY
59958: PPUSH
59959: LD_VAR 0 2
59963: PUSH
59964: LD_INT 4
59966: ARRAY
59967: PPUSH
59968: CALL_OW 449
59972: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59973: LD_ADDR_VAR 0 3
59977: PUSH
59978: LD_VAR 0 5
59982: PPUSH
59983: LD_INT 1
59985: PPUSH
59986: CALL_OW 275
59990: PUSH
59991: LD_VAR 0 4
59995: PUSH
59996: LD_INT 1
59998: ARRAY
59999: GREATEREQUAL
60000: PUSH
60001: LD_VAR 0 5
60005: PPUSH
60006: LD_INT 2
60008: PPUSH
60009: CALL_OW 275
60013: PUSH
60014: LD_VAR 0 4
60018: PUSH
60019: LD_INT 2
60021: ARRAY
60022: GREATEREQUAL
60023: AND
60024: PUSH
60025: LD_VAR 0 5
60029: PPUSH
60030: LD_INT 3
60032: PPUSH
60033: CALL_OW 275
60037: PUSH
60038: LD_VAR 0 4
60042: PUSH
60043: LD_INT 3
60045: ARRAY
60046: GREATEREQUAL
60047: AND
60048: ST_TO_ADDR
// end ;
60049: LD_VAR 0 3
60053: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60054: LD_INT 0
60056: PPUSH
60057: PPUSH
60058: PPUSH
60059: PPUSH
// pom := GetBase ( building ) ;
60060: LD_ADDR_VAR 0 3
60064: PUSH
60065: LD_VAR 0 1
60069: PPUSH
60070: CALL_OW 274
60074: ST_TO_ADDR
// if not pom then
60075: LD_VAR 0 3
60079: NOT
60080: IFFALSE 60084
// exit ;
60082: GO 60254
// btype := GetBType ( building ) ;
60084: LD_ADDR_VAR 0 5
60088: PUSH
60089: LD_VAR 0 1
60093: PPUSH
60094: CALL_OW 266
60098: ST_TO_ADDR
// if btype = b_armoury then
60099: LD_VAR 0 5
60103: PUSH
60104: LD_INT 4
60106: EQUAL
60107: IFFALSE 60117
// btype := b_barracks ;
60109: LD_ADDR_VAR 0 5
60113: PUSH
60114: LD_INT 5
60116: ST_TO_ADDR
// if btype = b_depot then
60117: LD_VAR 0 5
60121: PUSH
60122: LD_INT 0
60124: EQUAL
60125: IFFALSE 60135
// btype := b_warehouse ;
60127: LD_ADDR_VAR 0 5
60131: PUSH
60132: LD_INT 1
60134: ST_TO_ADDR
// if btype = b_workshop then
60135: LD_VAR 0 5
60139: PUSH
60140: LD_INT 2
60142: EQUAL
60143: IFFALSE 60153
// btype := b_factory ;
60145: LD_ADDR_VAR 0 5
60149: PUSH
60150: LD_INT 3
60152: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60153: LD_ADDR_VAR 0 4
60157: PUSH
60158: LD_VAR 0 5
60162: PPUSH
60163: LD_VAR 0 1
60167: PPUSH
60168: CALL_OW 248
60172: PPUSH
60173: CALL_OW 450
60177: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60178: LD_ADDR_VAR 0 2
60182: PUSH
60183: LD_VAR 0 3
60187: PPUSH
60188: LD_INT 1
60190: PPUSH
60191: CALL_OW 275
60195: PUSH
60196: LD_VAR 0 4
60200: PUSH
60201: LD_INT 1
60203: ARRAY
60204: GREATEREQUAL
60205: PUSH
60206: LD_VAR 0 3
60210: PPUSH
60211: LD_INT 2
60213: PPUSH
60214: CALL_OW 275
60218: PUSH
60219: LD_VAR 0 4
60223: PUSH
60224: LD_INT 2
60226: ARRAY
60227: GREATEREQUAL
60228: AND
60229: PUSH
60230: LD_VAR 0 3
60234: PPUSH
60235: LD_INT 3
60237: PPUSH
60238: CALL_OW 275
60242: PUSH
60243: LD_VAR 0 4
60247: PUSH
60248: LD_INT 3
60250: ARRAY
60251: GREATEREQUAL
60252: AND
60253: ST_TO_ADDR
// end ;
60254: LD_VAR 0 2
60258: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60259: LD_INT 0
60261: PPUSH
60262: PPUSH
60263: PPUSH
// pom := GetBase ( building ) ;
60264: LD_ADDR_VAR 0 4
60268: PUSH
60269: LD_VAR 0 1
60273: PPUSH
60274: CALL_OW 274
60278: ST_TO_ADDR
// if not pom then
60279: LD_VAR 0 4
60283: NOT
60284: IFFALSE 60288
// exit ;
60286: GO 60389
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60288: LD_ADDR_VAR 0 5
60292: PUSH
60293: LD_VAR 0 2
60297: PPUSH
60298: LD_VAR 0 1
60302: PPUSH
60303: CALL_OW 248
60307: PPUSH
60308: CALL_OW 450
60312: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60313: LD_ADDR_VAR 0 3
60317: PUSH
60318: LD_VAR 0 4
60322: PPUSH
60323: LD_INT 1
60325: PPUSH
60326: CALL_OW 275
60330: PUSH
60331: LD_VAR 0 5
60335: PUSH
60336: LD_INT 1
60338: ARRAY
60339: GREATEREQUAL
60340: PUSH
60341: LD_VAR 0 4
60345: PPUSH
60346: LD_INT 2
60348: PPUSH
60349: CALL_OW 275
60353: PUSH
60354: LD_VAR 0 5
60358: PUSH
60359: LD_INT 2
60361: ARRAY
60362: GREATEREQUAL
60363: AND
60364: PUSH
60365: LD_VAR 0 4
60369: PPUSH
60370: LD_INT 3
60372: PPUSH
60373: CALL_OW 275
60377: PUSH
60378: LD_VAR 0 5
60382: PUSH
60383: LD_INT 3
60385: ARRAY
60386: GREATEREQUAL
60387: AND
60388: ST_TO_ADDR
// end ;
60389: LD_VAR 0 3
60393: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60394: LD_INT 0
60396: PPUSH
60397: PPUSH
60398: PPUSH
60399: PPUSH
60400: PPUSH
60401: PPUSH
60402: PPUSH
60403: PPUSH
60404: PPUSH
60405: PPUSH
60406: PPUSH
// result := false ;
60407: LD_ADDR_VAR 0 8
60411: PUSH
60412: LD_INT 0
60414: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60415: LD_VAR 0 5
60419: NOT
60420: PUSH
60421: LD_VAR 0 1
60425: NOT
60426: OR
60427: PUSH
60428: LD_VAR 0 2
60432: NOT
60433: OR
60434: PUSH
60435: LD_VAR 0 3
60439: NOT
60440: OR
60441: IFFALSE 60445
// exit ;
60443: GO 61259
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60445: LD_ADDR_VAR 0 14
60449: PUSH
60450: LD_VAR 0 1
60454: PPUSH
60455: LD_VAR 0 2
60459: PPUSH
60460: LD_VAR 0 3
60464: PPUSH
60465: LD_VAR 0 4
60469: PPUSH
60470: LD_VAR 0 5
60474: PUSH
60475: LD_INT 1
60477: ARRAY
60478: PPUSH
60479: CALL_OW 248
60483: PPUSH
60484: LD_INT 0
60486: PPUSH
60487: CALL 62496 0 6
60491: ST_TO_ADDR
// if not hexes then
60492: LD_VAR 0 14
60496: NOT
60497: IFFALSE 60501
// exit ;
60499: GO 61259
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60501: LD_ADDR_VAR 0 17
60505: PUSH
60506: LD_VAR 0 5
60510: PPUSH
60511: LD_INT 22
60513: PUSH
60514: LD_VAR 0 13
60518: PPUSH
60519: CALL_OW 255
60523: PUSH
60524: EMPTY
60525: LIST
60526: LIST
60527: PUSH
60528: LD_INT 2
60530: PUSH
60531: LD_INT 30
60533: PUSH
60534: LD_INT 0
60536: PUSH
60537: EMPTY
60538: LIST
60539: LIST
60540: PUSH
60541: LD_INT 30
60543: PUSH
60544: LD_INT 1
60546: PUSH
60547: EMPTY
60548: LIST
60549: LIST
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: LIST
60555: PUSH
60556: EMPTY
60557: LIST
60558: LIST
60559: PPUSH
60560: CALL_OW 72
60564: ST_TO_ADDR
// for i = 1 to hexes do
60565: LD_ADDR_VAR 0 9
60569: PUSH
60570: DOUBLE
60571: LD_INT 1
60573: DEC
60574: ST_TO_ADDR
60575: LD_VAR 0 14
60579: PUSH
60580: FOR_TO
60581: IFFALSE 61257
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60583: LD_ADDR_VAR 0 13
60587: PUSH
60588: LD_VAR 0 14
60592: PUSH
60593: LD_VAR 0 9
60597: ARRAY
60598: PUSH
60599: LD_INT 1
60601: ARRAY
60602: PPUSH
60603: LD_VAR 0 14
60607: PUSH
60608: LD_VAR 0 9
60612: ARRAY
60613: PUSH
60614: LD_INT 2
60616: ARRAY
60617: PPUSH
60618: CALL_OW 428
60622: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60623: LD_VAR 0 14
60627: PUSH
60628: LD_VAR 0 9
60632: ARRAY
60633: PUSH
60634: LD_INT 1
60636: ARRAY
60637: PPUSH
60638: LD_VAR 0 14
60642: PUSH
60643: LD_VAR 0 9
60647: ARRAY
60648: PUSH
60649: LD_INT 2
60651: ARRAY
60652: PPUSH
60653: CALL_OW 351
60657: PUSH
60658: LD_VAR 0 14
60662: PUSH
60663: LD_VAR 0 9
60667: ARRAY
60668: PUSH
60669: LD_INT 1
60671: ARRAY
60672: PPUSH
60673: LD_VAR 0 14
60677: PUSH
60678: LD_VAR 0 9
60682: ARRAY
60683: PUSH
60684: LD_INT 2
60686: ARRAY
60687: PPUSH
60688: CALL_OW 488
60692: NOT
60693: OR
60694: PUSH
60695: LD_VAR 0 13
60699: PPUSH
60700: CALL_OW 247
60704: PUSH
60705: LD_INT 3
60707: EQUAL
60708: OR
60709: IFFALSE 60715
// exit ;
60711: POP
60712: POP
60713: GO 61259
// if not tmp then
60715: LD_VAR 0 13
60719: NOT
60720: IFFALSE 60724
// continue ;
60722: GO 60580
// result := true ;
60724: LD_ADDR_VAR 0 8
60728: PUSH
60729: LD_INT 1
60731: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60732: LD_VAR 0 6
60736: PUSH
60737: LD_VAR 0 13
60741: PPUSH
60742: CALL_OW 247
60746: PUSH
60747: LD_INT 2
60749: EQUAL
60750: AND
60751: PUSH
60752: LD_VAR 0 13
60756: PPUSH
60757: CALL_OW 263
60761: PUSH
60762: LD_INT 1
60764: EQUAL
60765: AND
60766: IFFALSE 60930
// begin if IsDrivenBy ( tmp ) then
60768: LD_VAR 0 13
60772: PPUSH
60773: CALL_OW 311
60777: IFFALSE 60781
// continue ;
60779: GO 60580
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60781: LD_VAR 0 6
60785: PPUSH
60786: LD_INT 3
60788: PUSH
60789: LD_INT 60
60791: PUSH
60792: EMPTY
60793: LIST
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: PUSH
60799: LD_INT 3
60801: PUSH
60802: LD_INT 55
60804: PUSH
60805: EMPTY
60806: LIST
60807: PUSH
60808: EMPTY
60809: LIST
60810: LIST
60811: PUSH
60812: EMPTY
60813: LIST
60814: LIST
60815: PPUSH
60816: CALL_OW 72
60820: IFFALSE 60928
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60822: LD_ADDR_VAR 0 18
60826: PUSH
60827: LD_VAR 0 6
60831: PPUSH
60832: LD_INT 3
60834: PUSH
60835: LD_INT 60
60837: PUSH
60838: EMPTY
60839: LIST
60840: PUSH
60841: EMPTY
60842: LIST
60843: LIST
60844: PUSH
60845: LD_INT 3
60847: PUSH
60848: LD_INT 55
60850: PUSH
60851: EMPTY
60852: LIST
60853: PUSH
60854: EMPTY
60855: LIST
60856: LIST
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: PPUSH
60862: CALL_OW 72
60866: PUSH
60867: LD_INT 1
60869: ARRAY
60870: ST_TO_ADDR
// if IsInUnit ( driver ) then
60871: LD_VAR 0 18
60875: PPUSH
60876: CALL_OW 310
60880: IFFALSE 60891
// ComExit ( driver ) ;
60882: LD_VAR 0 18
60886: PPUSH
60887: CALL 85680 0 1
// AddComEnterUnit ( driver , tmp ) ;
60891: LD_VAR 0 18
60895: PPUSH
60896: LD_VAR 0 13
60900: PPUSH
60901: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60905: LD_VAR 0 18
60909: PPUSH
60910: LD_VAR 0 7
60914: PPUSH
60915: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60919: LD_VAR 0 18
60923: PPUSH
60924: CALL_OW 181
// end ; continue ;
60928: GO 60580
// end ; if not cleaners or not tmp in cleaners then
60930: LD_VAR 0 6
60934: NOT
60935: PUSH
60936: LD_VAR 0 13
60940: PUSH
60941: LD_VAR 0 6
60945: IN
60946: NOT
60947: OR
60948: IFFALSE 61255
// begin if dep then
60950: LD_VAR 0 17
60954: IFFALSE 61090
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60956: LD_ADDR_VAR 0 16
60960: PUSH
60961: LD_VAR 0 17
60965: PUSH
60966: LD_INT 1
60968: ARRAY
60969: PPUSH
60970: CALL_OW 250
60974: PPUSH
60975: LD_VAR 0 17
60979: PUSH
60980: LD_INT 1
60982: ARRAY
60983: PPUSH
60984: CALL_OW 254
60988: PPUSH
60989: LD_INT 5
60991: PPUSH
60992: CALL_OW 272
60996: PUSH
60997: LD_VAR 0 17
61001: PUSH
61002: LD_INT 1
61004: ARRAY
61005: PPUSH
61006: CALL_OW 251
61010: PPUSH
61011: LD_VAR 0 17
61015: PUSH
61016: LD_INT 1
61018: ARRAY
61019: PPUSH
61020: CALL_OW 254
61024: PPUSH
61025: LD_INT 5
61027: PPUSH
61028: CALL_OW 273
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61037: LD_VAR 0 16
61041: PUSH
61042: LD_INT 1
61044: ARRAY
61045: PPUSH
61046: LD_VAR 0 16
61050: PUSH
61051: LD_INT 2
61053: ARRAY
61054: PPUSH
61055: CALL_OW 488
61059: IFFALSE 61090
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61061: LD_VAR 0 13
61065: PPUSH
61066: LD_VAR 0 16
61070: PUSH
61071: LD_INT 1
61073: ARRAY
61074: PPUSH
61075: LD_VAR 0 16
61079: PUSH
61080: LD_INT 2
61082: ARRAY
61083: PPUSH
61084: CALL_OW 111
// continue ;
61088: GO 60580
// end ; end ; r := GetDir ( tmp ) ;
61090: LD_ADDR_VAR 0 15
61094: PUSH
61095: LD_VAR 0 13
61099: PPUSH
61100: CALL_OW 254
61104: ST_TO_ADDR
// if r = 5 then
61105: LD_VAR 0 15
61109: PUSH
61110: LD_INT 5
61112: EQUAL
61113: IFFALSE 61123
// r := 0 ;
61115: LD_ADDR_VAR 0 15
61119: PUSH
61120: LD_INT 0
61122: ST_TO_ADDR
// for j = r to 5 do
61123: LD_ADDR_VAR 0 10
61127: PUSH
61128: DOUBLE
61129: LD_VAR 0 15
61133: DEC
61134: ST_TO_ADDR
61135: LD_INT 5
61137: PUSH
61138: FOR_TO
61139: IFFALSE 61253
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61141: LD_ADDR_VAR 0 11
61145: PUSH
61146: LD_VAR 0 13
61150: PPUSH
61151: CALL_OW 250
61155: PPUSH
61156: LD_VAR 0 10
61160: PPUSH
61161: LD_INT 2
61163: PPUSH
61164: CALL_OW 272
61168: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61169: LD_ADDR_VAR 0 12
61173: PUSH
61174: LD_VAR 0 13
61178: PPUSH
61179: CALL_OW 251
61183: PPUSH
61184: LD_VAR 0 10
61188: PPUSH
61189: LD_INT 2
61191: PPUSH
61192: CALL_OW 273
61196: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61197: LD_VAR 0 11
61201: PPUSH
61202: LD_VAR 0 12
61206: PPUSH
61207: CALL_OW 488
61211: PUSH
61212: LD_VAR 0 11
61216: PPUSH
61217: LD_VAR 0 12
61221: PPUSH
61222: CALL_OW 428
61226: NOT
61227: AND
61228: IFFALSE 61251
// begin ComMoveXY ( tmp , _x , _y ) ;
61230: LD_VAR 0 13
61234: PPUSH
61235: LD_VAR 0 11
61239: PPUSH
61240: LD_VAR 0 12
61244: PPUSH
61245: CALL_OW 111
// break ;
61249: GO 61253
// end ; end ;
61251: GO 61138
61253: POP
61254: POP
// end ; end ;
61255: GO 60580
61257: POP
61258: POP
// end ;
61259: LD_VAR 0 8
61263: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61264: LD_INT 0
61266: PPUSH
// result := true ;
61267: LD_ADDR_VAR 0 3
61271: PUSH
61272: LD_INT 1
61274: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61275: LD_VAR 0 2
61279: PUSH
61280: LD_INT 24
61282: DOUBLE
61283: EQUAL
61284: IFTRUE 61294
61286: LD_INT 33
61288: DOUBLE
61289: EQUAL
61290: IFTRUE 61294
61292: GO 61319
61294: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61295: LD_ADDR_VAR 0 3
61299: PUSH
61300: LD_INT 32
61302: PPUSH
61303: LD_VAR 0 1
61307: PPUSH
61308: CALL_OW 321
61312: PUSH
61313: LD_INT 2
61315: EQUAL
61316: ST_TO_ADDR
61317: GO 61639
61319: LD_INT 20
61321: DOUBLE
61322: EQUAL
61323: IFTRUE 61327
61325: GO 61352
61327: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61328: LD_ADDR_VAR 0 3
61332: PUSH
61333: LD_INT 6
61335: PPUSH
61336: LD_VAR 0 1
61340: PPUSH
61341: CALL_OW 321
61345: PUSH
61346: LD_INT 2
61348: EQUAL
61349: ST_TO_ADDR
61350: GO 61639
61352: LD_INT 22
61354: DOUBLE
61355: EQUAL
61356: IFTRUE 61366
61358: LD_INT 36
61360: DOUBLE
61361: EQUAL
61362: IFTRUE 61366
61364: GO 61391
61366: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61367: LD_ADDR_VAR 0 3
61371: PUSH
61372: LD_INT 15
61374: PPUSH
61375: LD_VAR 0 1
61379: PPUSH
61380: CALL_OW 321
61384: PUSH
61385: LD_INT 2
61387: EQUAL
61388: ST_TO_ADDR
61389: GO 61639
61391: LD_INT 30
61393: DOUBLE
61394: EQUAL
61395: IFTRUE 61399
61397: GO 61424
61399: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61400: LD_ADDR_VAR 0 3
61404: PUSH
61405: LD_INT 20
61407: PPUSH
61408: LD_VAR 0 1
61412: PPUSH
61413: CALL_OW 321
61417: PUSH
61418: LD_INT 2
61420: EQUAL
61421: ST_TO_ADDR
61422: GO 61639
61424: LD_INT 28
61426: DOUBLE
61427: EQUAL
61428: IFTRUE 61438
61430: LD_INT 21
61432: DOUBLE
61433: EQUAL
61434: IFTRUE 61438
61436: GO 61463
61438: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61439: LD_ADDR_VAR 0 3
61443: PUSH
61444: LD_INT 21
61446: PPUSH
61447: LD_VAR 0 1
61451: PPUSH
61452: CALL_OW 321
61456: PUSH
61457: LD_INT 2
61459: EQUAL
61460: ST_TO_ADDR
61461: GO 61639
61463: LD_INT 16
61465: DOUBLE
61466: EQUAL
61467: IFTRUE 61471
61469: GO 61498
61471: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61472: LD_ADDR_VAR 0 3
61476: PUSH
61477: LD_EXP 106
61481: PPUSH
61482: LD_VAR 0 1
61486: PPUSH
61487: CALL_OW 321
61491: PUSH
61492: LD_INT 2
61494: EQUAL
61495: ST_TO_ADDR
61496: GO 61639
61498: LD_INT 19
61500: DOUBLE
61501: EQUAL
61502: IFTRUE 61512
61504: LD_INT 23
61506: DOUBLE
61507: EQUAL
61508: IFTRUE 61512
61510: GO 61539
61512: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61513: LD_ADDR_VAR 0 3
61517: PUSH
61518: LD_EXP 105
61522: PPUSH
61523: LD_VAR 0 1
61527: PPUSH
61528: CALL_OW 321
61532: PUSH
61533: LD_INT 2
61535: EQUAL
61536: ST_TO_ADDR
61537: GO 61639
61539: LD_INT 17
61541: DOUBLE
61542: EQUAL
61543: IFTRUE 61547
61545: GO 61572
61547: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61548: LD_ADDR_VAR 0 3
61552: PUSH
61553: LD_INT 39
61555: PPUSH
61556: LD_VAR 0 1
61560: PPUSH
61561: CALL_OW 321
61565: PUSH
61566: LD_INT 2
61568: EQUAL
61569: ST_TO_ADDR
61570: GO 61639
61572: LD_INT 18
61574: DOUBLE
61575: EQUAL
61576: IFTRUE 61580
61578: GO 61605
61580: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61581: LD_ADDR_VAR 0 3
61585: PUSH
61586: LD_INT 40
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: CALL_OW 321
61598: PUSH
61599: LD_INT 2
61601: EQUAL
61602: ST_TO_ADDR
61603: GO 61639
61605: LD_INT 27
61607: DOUBLE
61608: EQUAL
61609: IFTRUE 61613
61611: GO 61638
61613: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61614: LD_ADDR_VAR 0 3
61618: PUSH
61619: LD_INT 35
61621: PPUSH
61622: LD_VAR 0 1
61626: PPUSH
61627: CALL_OW 321
61631: PUSH
61632: LD_INT 2
61634: EQUAL
61635: ST_TO_ADDR
61636: GO 61639
61638: POP
// end ;
61639: LD_VAR 0 3
61643: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61644: LD_INT 0
61646: PPUSH
61647: PPUSH
61648: PPUSH
61649: PPUSH
61650: PPUSH
61651: PPUSH
61652: PPUSH
61653: PPUSH
61654: PPUSH
61655: PPUSH
61656: PPUSH
// result := false ;
61657: LD_ADDR_VAR 0 6
61661: PUSH
61662: LD_INT 0
61664: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61665: LD_VAR 0 1
61669: NOT
61670: PUSH
61671: LD_VAR 0 1
61675: PPUSH
61676: CALL_OW 266
61680: PUSH
61681: LD_INT 0
61683: PUSH
61684: LD_INT 1
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: IN
61691: NOT
61692: OR
61693: PUSH
61694: LD_VAR 0 2
61698: NOT
61699: OR
61700: PUSH
61701: LD_VAR 0 5
61705: PUSH
61706: LD_INT 0
61708: PUSH
61709: LD_INT 1
61711: PUSH
61712: LD_INT 2
61714: PUSH
61715: LD_INT 3
61717: PUSH
61718: LD_INT 4
61720: PUSH
61721: LD_INT 5
61723: PUSH
61724: EMPTY
61725: LIST
61726: LIST
61727: LIST
61728: LIST
61729: LIST
61730: LIST
61731: IN
61732: NOT
61733: OR
61734: PUSH
61735: LD_VAR 0 3
61739: PPUSH
61740: LD_VAR 0 4
61744: PPUSH
61745: CALL_OW 488
61749: NOT
61750: OR
61751: IFFALSE 61755
// exit ;
61753: GO 62491
// side := GetSide ( depot ) ;
61755: LD_ADDR_VAR 0 9
61759: PUSH
61760: LD_VAR 0 1
61764: PPUSH
61765: CALL_OW 255
61769: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61770: LD_VAR 0 9
61774: PPUSH
61775: LD_VAR 0 2
61779: PPUSH
61780: CALL 61264 0 2
61784: NOT
61785: IFFALSE 61789
// exit ;
61787: GO 62491
// pom := GetBase ( depot ) ;
61789: LD_ADDR_VAR 0 10
61793: PUSH
61794: LD_VAR 0 1
61798: PPUSH
61799: CALL_OW 274
61803: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61804: LD_ADDR_VAR 0 11
61808: PUSH
61809: LD_VAR 0 2
61813: PPUSH
61814: LD_VAR 0 1
61818: PPUSH
61819: CALL_OW 248
61823: PPUSH
61824: CALL_OW 450
61828: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61829: LD_VAR 0 10
61833: PPUSH
61834: LD_INT 1
61836: PPUSH
61837: CALL_OW 275
61841: PUSH
61842: LD_VAR 0 11
61846: PUSH
61847: LD_INT 1
61849: ARRAY
61850: GREATEREQUAL
61851: PUSH
61852: LD_VAR 0 10
61856: PPUSH
61857: LD_INT 2
61859: PPUSH
61860: CALL_OW 275
61864: PUSH
61865: LD_VAR 0 11
61869: PUSH
61870: LD_INT 2
61872: ARRAY
61873: GREATEREQUAL
61874: AND
61875: PUSH
61876: LD_VAR 0 10
61880: PPUSH
61881: LD_INT 3
61883: PPUSH
61884: CALL_OW 275
61888: PUSH
61889: LD_VAR 0 11
61893: PUSH
61894: LD_INT 3
61896: ARRAY
61897: GREATEREQUAL
61898: AND
61899: NOT
61900: IFFALSE 61904
// exit ;
61902: GO 62491
// if GetBType ( depot ) = b_depot then
61904: LD_VAR 0 1
61908: PPUSH
61909: CALL_OW 266
61913: PUSH
61914: LD_INT 0
61916: EQUAL
61917: IFFALSE 61929
// dist := 28 else
61919: LD_ADDR_VAR 0 14
61923: PUSH
61924: LD_INT 28
61926: ST_TO_ADDR
61927: GO 61937
// dist := 36 ;
61929: LD_ADDR_VAR 0 14
61933: PUSH
61934: LD_INT 36
61936: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61937: LD_VAR 0 1
61941: PPUSH
61942: LD_VAR 0 3
61946: PPUSH
61947: LD_VAR 0 4
61951: PPUSH
61952: CALL_OW 297
61956: PUSH
61957: LD_VAR 0 14
61961: GREATER
61962: IFFALSE 61966
// exit ;
61964: GO 62491
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61966: LD_ADDR_VAR 0 12
61970: PUSH
61971: LD_VAR 0 2
61975: PPUSH
61976: LD_VAR 0 3
61980: PPUSH
61981: LD_VAR 0 4
61985: PPUSH
61986: LD_VAR 0 5
61990: PPUSH
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL_OW 248
62000: PPUSH
62001: LD_INT 0
62003: PPUSH
62004: CALL 62496 0 6
62008: ST_TO_ADDR
// if not hexes then
62009: LD_VAR 0 12
62013: NOT
62014: IFFALSE 62018
// exit ;
62016: GO 62491
// hex := GetHexInfo ( x , y ) ;
62018: LD_ADDR_VAR 0 15
62022: PUSH
62023: LD_VAR 0 3
62027: PPUSH
62028: LD_VAR 0 4
62032: PPUSH
62033: CALL_OW 546
62037: ST_TO_ADDR
// if hex [ 1 ] then
62038: LD_VAR 0 15
62042: PUSH
62043: LD_INT 1
62045: ARRAY
62046: IFFALSE 62050
// exit ;
62048: GO 62491
// height := hex [ 2 ] ;
62050: LD_ADDR_VAR 0 13
62054: PUSH
62055: LD_VAR 0 15
62059: PUSH
62060: LD_INT 2
62062: ARRAY
62063: ST_TO_ADDR
// for i = 1 to hexes do
62064: LD_ADDR_VAR 0 7
62068: PUSH
62069: DOUBLE
62070: LD_INT 1
62072: DEC
62073: ST_TO_ADDR
62074: LD_VAR 0 12
62078: PUSH
62079: FOR_TO
62080: IFFALSE 62410
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62082: LD_VAR 0 12
62086: PUSH
62087: LD_VAR 0 7
62091: ARRAY
62092: PUSH
62093: LD_INT 1
62095: ARRAY
62096: PPUSH
62097: LD_VAR 0 12
62101: PUSH
62102: LD_VAR 0 7
62106: ARRAY
62107: PUSH
62108: LD_INT 2
62110: ARRAY
62111: PPUSH
62112: CALL_OW 488
62116: NOT
62117: PUSH
62118: LD_VAR 0 12
62122: PUSH
62123: LD_VAR 0 7
62127: ARRAY
62128: PUSH
62129: LD_INT 1
62131: ARRAY
62132: PPUSH
62133: LD_VAR 0 12
62137: PUSH
62138: LD_VAR 0 7
62142: ARRAY
62143: PUSH
62144: LD_INT 2
62146: ARRAY
62147: PPUSH
62148: CALL_OW 428
62152: PUSH
62153: LD_INT 0
62155: GREATER
62156: OR
62157: PUSH
62158: LD_VAR 0 12
62162: PUSH
62163: LD_VAR 0 7
62167: ARRAY
62168: PUSH
62169: LD_INT 1
62171: ARRAY
62172: PPUSH
62173: LD_VAR 0 12
62177: PUSH
62178: LD_VAR 0 7
62182: ARRAY
62183: PUSH
62184: LD_INT 2
62186: ARRAY
62187: PPUSH
62188: CALL_OW 351
62192: OR
62193: IFFALSE 62199
// exit ;
62195: POP
62196: POP
62197: GO 62491
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62199: LD_ADDR_VAR 0 8
62203: PUSH
62204: LD_VAR 0 12
62208: PUSH
62209: LD_VAR 0 7
62213: ARRAY
62214: PUSH
62215: LD_INT 1
62217: ARRAY
62218: PPUSH
62219: LD_VAR 0 12
62223: PUSH
62224: LD_VAR 0 7
62228: ARRAY
62229: PUSH
62230: LD_INT 2
62232: ARRAY
62233: PPUSH
62234: CALL_OW 546
62238: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62239: LD_VAR 0 8
62243: PUSH
62244: LD_INT 1
62246: ARRAY
62247: PUSH
62248: LD_VAR 0 8
62252: PUSH
62253: LD_INT 2
62255: ARRAY
62256: PUSH
62257: LD_VAR 0 13
62261: PUSH
62262: LD_INT 2
62264: PLUS
62265: GREATER
62266: OR
62267: PUSH
62268: LD_VAR 0 8
62272: PUSH
62273: LD_INT 2
62275: ARRAY
62276: PUSH
62277: LD_VAR 0 13
62281: PUSH
62282: LD_INT 2
62284: MINUS
62285: LESS
62286: OR
62287: PUSH
62288: LD_VAR 0 8
62292: PUSH
62293: LD_INT 3
62295: ARRAY
62296: PUSH
62297: LD_INT 0
62299: PUSH
62300: LD_INT 8
62302: PUSH
62303: LD_INT 9
62305: PUSH
62306: LD_INT 10
62308: PUSH
62309: LD_INT 11
62311: PUSH
62312: LD_INT 12
62314: PUSH
62315: LD_INT 13
62317: PUSH
62318: LD_INT 16
62320: PUSH
62321: LD_INT 17
62323: PUSH
62324: LD_INT 18
62326: PUSH
62327: LD_INT 19
62329: PUSH
62330: LD_INT 20
62332: PUSH
62333: LD_INT 21
62335: PUSH
62336: EMPTY
62337: LIST
62338: LIST
62339: LIST
62340: LIST
62341: LIST
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: LIST
62349: LIST
62350: IN
62351: NOT
62352: OR
62353: PUSH
62354: LD_VAR 0 8
62358: PUSH
62359: LD_INT 5
62361: ARRAY
62362: NOT
62363: OR
62364: PUSH
62365: LD_VAR 0 8
62369: PUSH
62370: LD_INT 6
62372: ARRAY
62373: PUSH
62374: LD_INT 1
62376: PUSH
62377: LD_INT 2
62379: PUSH
62380: LD_INT 7
62382: PUSH
62383: LD_INT 9
62385: PUSH
62386: LD_INT 10
62388: PUSH
62389: LD_INT 11
62391: PUSH
62392: EMPTY
62393: LIST
62394: LIST
62395: LIST
62396: LIST
62397: LIST
62398: LIST
62399: IN
62400: NOT
62401: OR
62402: IFFALSE 62408
// exit ;
62404: POP
62405: POP
62406: GO 62491
// end ;
62408: GO 62079
62410: POP
62411: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62412: LD_VAR 0 9
62416: PPUSH
62417: LD_VAR 0 3
62421: PPUSH
62422: LD_VAR 0 4
62426: PPUSH
62427: LD_INT 20
62429: PPUSH
62430: CALL 54437 0 4
62434: PUSH
62435: LD_INT 4
62437: ARRAY
62438: IFFALSE 62442
// exit ;
62440: GO 62491
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62442: LD_VAR 0 2
62446: PUSH
62447: LD_INT 29
62449: PUSH
62450: LD_INT 30
62452: PUSH
62453: EMPTY
62454: LIST
62455: LIST
62456: IN
62457: PUSH
62458: LD_VAR 0 3
62462: PPUSH
62463: LD_VAR 0 4
62467: PPUSH
62468: LD_VAR 0 9
62472: PPUSH
62473: CALL_OW 440
62477: NOT
62478: AND
62479: IFFALSE 62483
// exit ;
62481: GO 62491
// result := true ;
62483: LD_ADDR_VAR 0 6
62487: PUSH
62488: LD_INT 1
62490: ST_TO_ADDR
// end ;
62491: LD_VAR 0 6
62495: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62496: LD_INT 0
62498: PPUSH
62499: PPUSH
62500: PPUSH
62501: PPUSH
62502: PPUSH
62503: PPUSH
62504: PPUSH
62505: PPUSH
62506: PPUSH
62507: PPUSH
62508: PPUSH
62509: PPUSH
62510: PPUSH
62511: PPUSH
62512: PPUSH
62513: PPUSH
62514: PPUSH
62515: PPUSH
62516: PPUSH
62517: PPUSH
62518: PPUSH
62519: PPUSH
62520: PPUSH
62521: PPUSH
62522: PPUSH
62523: PPUSH
62524: PPUSH
62525: PPUSH
62526: PPUSH
62527: PPUSH
62528: PPUSH
62529: PPUSH
62530: PPUSH
62531: PPUSH
62532: PPUSH
62533: PPUSH
62534: PPUSH
62535: PPUSH
62536: PPUSH
62537: PPUSH
62538: PPUSH
62539: PPUSH
62540: PPUSH
62541: PPUSH
62542: PPUSH
62543: PPUSH
62544: PPUSH
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
62551: PPUSH
62552: PPUSH
62553: PPUSH
62554: PPUSH
62555: PPUSH
// result = [ ] ;
62556: LD_ADDR_VAR 0 7
62560: PUSH
62561: EMPTY
62562: ST_TO_ADDR
// temp_list = [ ] ;
62563: LD_ADDR_VAR 0 9
62567: PUSH
62568: EMPTY
62569: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62570: LD_VAR 0 4
62574: PUSH
62575: LD_INT 0
62577: PUSH
62578: LD_INT 1
62580: PUSH
62581: LD_INT 2
62583: PUSH
62584: LD_INT 3
62586: PUSH
62587: LD_INT 4
62589: PUSH
62590: LD_INT 5
62592: PUSH
62593: EMPTY
62594: LIST
62595: LIST
62596: LIST
62597: LIST
62598: LIST
62599: LIST
62600: IN
62601: NOT
62602: PUSH
62603: LD_VAR 0 1
62607: PUSH
62608: LD_INT 0
62610: PUSH
62611: LD_INT 1
62613: PUSH
62614: EMPTY
62615: LIST
62616: LIST
62617: IN
62618: PUSH
62619: LD_VAR 0 5
62623: PUSH
62624: LD_INT 1
62626: PUSH
62627: LD_INT 2
62629: PUSH
62630: LD_INT 3
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: LIST
62637: IN
62638: NOT
62639: AND
62640: OR
62641: IFFALSE 62645
// exit ;
62643: GO 81036
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62645: LD_VAR 0 1
62649: PUSH
62650: LD_INT 6
62652: PUSH
62653: LD_INT 7
62655: PUSH
62656: LD_INT 8
62658: PUSH
62659: LD_INT 13
62661: PUSH
62662: LD_INT 12
62664: PUSH
62665: LD_INT 15
62667: PUSH
62668: LD_INT 11
62670: PUSH
62671: LD_INT 14
62673: PUSH
62674: LD_INT 10
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: LIST
62686: LIST
62687: IN
62688: IFFALSE 62698
// btype = b_lab ;
62690: LD_ADDR_VAR 0 1
62694: PUSH
62695: LD_INT 6
62697: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62698: LD_VAR 0 6
62702: PUSH
62703: LD_INT 0
62705: PUSH
62706: LD_INT 1
62708: PUSH
62709: LD_INT 2
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: LIST
62716: IN
62717: NOT
62718: PUSH
62719: LD_VAR 0 1
62723: PUSH
62724: LD_INT 0
62726: PUSH
62727: LD_INT 1
62729: PUSH
62730: LD_INT 2
62732: PUSH
62733: LD_INT 3
62735: PUSH
62736: LD_INT 6
62738: PUSH
62739: LD_INT 36
62741: PUSH
62742: LD_INT 4
62744: PUSH
62745: LD_INT 5
62747: PUSH
62748: LD_INT 31
62750: PUSH
62751: LD_INT 32
62753: PUSH
62754: LD_INT 33
62756: PUSH
62757: EMPTY
62758: LIST
62759: LIST
62760: LIST
62761: LIST
62762: LIST
62763: LIST
62764: LIST
62765: LIST
62766: LIST
62767: LIST
62768: LIST
62769: IN
62770: NOT
62771: PUSH
62772: LD_VAR 0 6
62776: PUSH
62777: LD_INT 1
62779: EQUAL
62780: AND
62781: OR
62782: PUSH
62783: LD_VAR 0 1
62787: PUSH
62788: LD_INT 2
62790: PUSH
62791: LD_INT 3
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: IN
62798: NOT
62799: PUSH
62800: LD_VAR 0 6
62804: PUSH
62805: LD_INT 2
62807: EQUAL
62808: AND
62809: OR
62810: IFFALSE 62820
// mode = 0 ;
62812: LD_ADDR_VAR 0 6
62816: PUSH
62817: LD_INT 0
62819: ST_TO_ADDR
// case mode of 0 :
62820: LD_VAR 0 6
62824: PUSH
62825: LD_INT 0
62827: DOUBLE
62828: EQUAL
62829: IFTRUE 62833
62831: GO 74286
62833: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62834: LD_ADDR_VAR 0 11
62838: PUSH
62839: LD_INT 0
62841: PUSH
62842: LD_INT 0
62844: PUSH
62845: EMPTY
62846: LIST
62847: LIST
62848: PUSH
62849: LD_INT 0
62851: PUSH
62852: LD_INT 1
62854: NEG
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: PUSH
62860: LD_INT 1
62862: PUSH
62863: LD_INT 0
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 1
62872: PUSH
62873: LD_INT 1
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 0
62882: PUSH
62883: LD_INT 1
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PUSH
62890: LD_INT 1
62892: NEG
62893: PUSH
62894: LD_INT 0
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 1
62903: NEG
62904: PUSH
62905: LD_INT 1
62907: NEG
62908: PUSH
62909: EMPTY
62910: LIST
62911: LIST
62912: PUSH
62913: LD_INT 1
62915: NEG
62916: PUSH
62917: LD_INT 2
62919: NEG
62920: PUSH
62921: EMPTY
62922: LIST
62923: LIST
62924: PUSH
62925: LD_INT 0
62927: PUSH
62928: LD_INT 2
62930: NEG
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 1
62938: PUSH
62939: LD_INT 1
62941: NEG
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PUSH
62947: LD_INT 1
62949: PUSH
62950: LD_INT 2
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PUSH
62957: LD_INT 0
62959: PUSH
62960: LD_INT 2
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: PUSH
62967: LD_INT 1
62969: NEG
62970: PUSH
62971: LD_INT 1
62973: PUSH
62974: EMPTY
62975: LIST
62976: LIST
62977: PUSH
62978: LD_INT 1
62980: PUSH
62981: LD_INT 3
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: PUSH
62988: LD_INT 0
62990: PUSH
62991: LD_INT 3
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: PUSH
62998: LD_INT 1
63000: NEG
63001: PUSH
63002: LD_INT 2
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: PUSH
63009: EMPTY
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: LIST
63025: LIST
63026: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63027: LD_ADDR_VAR 0 12
63031: PUSH
63032: LD_INT 0
63034: PUSH
63035: LD_INT 0
63037: PUSH
63038: EMPTY
63039: LIST
63040: LIST
63041: PUSH
63042: LD_INT 0
63044: PUSH
63045: LD_INT 1
63047: NEG
63048: PUSH
63049: EMPTY
63050: LIST
63051: LIST
63052: PUSH
63053: LD_INT 1
63055: PUSH
63056: LD_INT 0
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: PUSH
63063: LD_INT 1
63065: PUSH
63066: LD_INT 1
63068: PUSH
63069: EMPTY
63070: LIST
63071: LIST
63072: PUSH
63073: LD_INT 0
63075: PUSH
63076: LD_INT 1
63078: PUSH
63079: EMPTY
63080: LIST
63081: LIST
63082: PUSH
63083: LD_INT 1
63085: NEG
63086: PUSH
63087: LD_INT 0
63089: PUSH
63090: EMPTY
63091: LIST
63092: LIST
63093: PUSH
63094: LD_INT 1
63096: NEG
63097: PUSH
63098: LD_INT 1
63100: NEG
63101: PUSH
63102: EMPTY
63103: LIST
63104: LIST
63105: PUSH
63106: LD_INT 1
63108: PUSH
63109: LD_INT 1
63111: NEG
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 2
63119: PUSH
63120: LD_INT 0
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: LD_INT 2
63129: PUSH
63130: LD_INT 1
63132: PUSH
63133: EMPTY
63134: LIST
63135: LIST
63136: PUSH
63137: LD_INT 1
63139: NEG
63140: PUSH
63141: LD_INT 1
63143: PUSH
63144: EMPTY
63145: LIST
63146: LIST
63147: PUSH
63148: LD_INT 2
63150: NEG
63151: PUSH
63152: LD_INT 0
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: LD_INT 2
63161: NEG
63162: PUSH
63163: LD_INT 1
63165: NEG
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 2
63173: NEG
63174: PUSH
63175: LD_INT 1
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PUSH
63182: LD_INT 3
63184: NEG
63185: PUSH
63186: LD_INT 0
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 3
63195: NEG
63196: PUSH
63197: LD_INT 1
63199: NEG
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63223: LD_ADDR_VAR 0 13
63227: PUSH
63228: LD_INT 0
63230: PUSH
63231: LD_INT 0
63233: PUSH
63234: EMPTY
63235: LIST
63236: LIST
63237: PUSH
63238: LD_INT 0
63240: PUSH
63241: LD_INT 1
63243: NEG
63244: PUSH
63245: EMPTY
63246: LIST
63247: LIST
63248: PUSH
63249: LD_INT 1
63251: PUSH
63252: LD_INT 0
63254: PUSH
63255: EMPTY
63256: LIST
63257: LIST
63258: PUSH
63259: LD_INT 1
63261: PUSH
63262: LD_INT 1
63264: PUSH
63265: EMPTY
63266: LIST
63267: LIST
63268: PUSH
63269: LD_INT 0
63271: PUSH
63272: LD_INT 1
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PUSH
63279: LD_INT 1
63281: NEG
63282: PUSH
63283: LD_INT 0
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: PUSH
63290: LD_INT 1
63292: NEG
63293: PUSH
63294: LD_INT 1
63296: NEG
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 1
63304: NEG
63305: PUSH
63306: LD_INT 2
63308: NEG
63309: PUSH
63310: EMPTY
63311: LIST
63312: LIST
63313: PUSH
63314: LD_INT 2
63316: PUSH
63317: LD_INT 1
63319: PUSH
63320: EMPTY
63321: LIST
63322: LIST
63323: PUSH
63324: LD_INT 2
63326: PUSH
63327: LD_INT 2
63329: PUSH
63330: EMPTY
63331: LIST
63332: LIST
63333: PUSH
63334: LD_INT 1
63336: PUSH
63337: LD_INT 2
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 2
63346: NEG
63347: PUSH
63348: LD_INT 1
63350: NEG
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: LD_INT 2
63358: NEG
63359: PUSH
63360: LD_INT 2
63362: NEG
63363: PUSH
63364: EMPTY
63365: LIST
63366: LIST
63367: PUSH
63368: LD_INT 2
63370: NEG
63371: PUSH
63372: LD_INT 3
63374: NEG
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PUSH
63380: LD_INT 3
63382: NEG
63383: PUSH
63384: LD_INT 2
63386: NEG
63387: PUSH
63388: EMPTY
63389: LIST
63390: LIST
63391: PUSH
63392: LD_INT 3
63394: NEG
63395: PUSH
63396: LD_INT 3
63398: NEG
63399: PUSH
63400: EMPTY
63401: LIST
63402: LIST
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: LIST
63408: LIST
63409: LIST
63410: LIST
63411: LIST
63412: LIST
63413: LIST
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63422: LD_ADDR_VAR 0 14
63426: PUSH
63427: LD_INT 0
63429: PUSH
63430: LD_INT 0
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 0
63439: PUSH
63440: LD_INT 1
63442: NEG
63443: PUSH
63444: EMPTY
63445: LIST
63446: LIST
63447: PUSH
63448: LD_INT 1
63450: PUSH
63451: LD_INT 0
63453: PUSH
63454: EMPTY
63455: LIST
63456: LIST
63457: PUSH
63458: LD_INT 1
63460: PUSH
63461: LD_INT 1
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PUSH
63468: LD_INT 0
63470: PUSH
63471: LD_INT 1
63473: PUSH
63474: EMPTY
63475: LIST
63476: LIST
63477: PUSH
63478: LD_INT 1
63480: NEG
63481: PUSH
63482: LD_INT 0
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PUSH
63489: LD_INT 1
63491: NEG
63492: PUSH
63493: LD_INT 1
63495: NEG
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: NEG
63504: PUSH
63505: LD_INT 2
63507: NEG
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PUSH
63513: LD_INT 0
63515: PUSH
63516: LD_INT 2
63518: NEG
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 1
63526: PUSH
63527: LD_INT 1
63529: NEG
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: LD_INT 1
63537: PUSH
63538: LD_INT 2
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 0
63547: PUSH
63548: LD_INT 2
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 1
63557: NEG
63558: PUSH
63559: LD_INT 1
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: PUSH
63566: LD_INT 1
63568: NEG
63569: PUSH
63570: LD_INT 3
63572: NEG
63573: PUSH
63574: EMPTY
63575: LIST
63576: LIST
63577: PUSH
63578: LD_INT 0
63580: PUSH
63581: LD_INT 3
63583: NEG
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: PUSH
63589: LD_INT 1
63591: PUSH
63592: LD_INT 2
63594: NEG
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63618: LD_ADDR_VAR 0 15
63622: PUSH
63623: LD_INT 0
63625: PUSH
63626: LD_INT 0
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: PUSH
63633: LD_INT 0
63635: PUSH
63636: LD_INT 1
63638: NEG
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: PUSH
63644: LD_INT 1
63646: PUSH
63647: LD_INT 0
63649: PUSH
63650: EMPTY
63651: LIST
63652: LIST
63653: PUSH
63654: LD_INT 1
63656: PUSH
63657: LD_INT 1
63659: PUSH
63660: EMPTY
63661: LIST
63662: LIST
63663: PUSH
63664: LD_INT 0
63666: PUSH
63667: LD_INT 1
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 1
63676: NEG
63677: PUSH
63678: LD_INT 0
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: PUSH
63685: LD_INT 1
63687: NEG
63688: PUSH
63689: LD_INT 1
63691: NEG
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: LD_INT 1
63702: NEG
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PUSH
63708: LD_INT 2
63710: PUSH
63711: LD_INT 0
63713: PUSH
63714: EMPTY
63715: LIST
63716: LIST
63717: PUSH
63718: LD_INT 2
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 1
63730: NEG
63731: PUSH
63732: LD_INT 1
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PUSH
63739: LD_INT 2
63741: NEG
63742: PUSH
63743: LD_INT 0
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: PUSH
63750: LD_INT 2
63752: NEG
63753: PUSH
63754: LD_INT 1
63756: NEG
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 2
63764: PUSH
63765: LD_INT 1
63767: NEG
63768: PUSH
63769: EMPTY
63770: LIST
63771: LIST
63772: PUSH
63773: LD_INT 3
63775: PUSH
63776: LD_INT 0
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: PUSH
63783: LD_INT 3
63785: PUSH
63786: LD_INT 1
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: LIST
63797: LIST
63798: LIST
63799: LIST
63800: LIST
63801: LIST
63802: LIST
63803: LIST
63804: LIST
63805: LIST
63806: LIST
63807: LIST
63808: LIST
63809: LIST
63810: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63811: LD_ADDR_VAR 0 16
63815: PUSH
63816: LD_INT 0
63818: PUSH
63819: LD_INT 0
63821: PUSH
63822: EMPTY
63823: LIST
63824: LIST
63825: PUSH
63826: LD_INT 0
63828: PUSH
63829: LD_INT 1
63831: NEG
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: PUSH
63837: LD_INT 1
63839: PUSH
63840: LD_INT 0
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PUSH
63847: LD_INT 1
63849: PUSH
63850: LD_INT 1
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: PUSH
63857: LD_INT 0
63859: PUSH
63860: LD_INT 1
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PUSH
63867: LD_INT 1
63869: NEG
63870: PUSH
63871: LD_INT 0
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 1
63880: NEG
63881: PUSH
63882: LD_INT 1
63884: NEG
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 1
63892: NEG
63893: PUSH
63894: LD_INT 2
63896: NEG
63897: PUSH
63898: EMPTY
63899: LIST
63900: LIST
63901: PUSH
63902: LD_INT 2
63904: PUSH
63905: LD_INT 1
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: PUSH
63912: LD_INT 2
63914: PUSH
63915: LD_INT 2
63917: PUSH
63918: EMPTY
63919: LIST
63920: LIST
63921: PUSH
63922: LD_INT 1
63924: PUSH
63925: LD_INT 2
63927: PUSH
63928: EMPTY
63929: LIST
63930: LIST
63931: PUSH
63932: LD_INT 2
63934: NEG
63935: PUSH
63936: LD_INT 1
63938: NEG
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PUSH
63944: LD_INT 2
63946: NEG
63947: PUSH
63948: LD_INT 2
63950: NEG
63951: PUSH
63952: EMPTY
63953: LIST
63954: LIST
63955: PUSH
63956: LD_INT 3
63958: PUSH
63959: LD_INT 2
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PUSH
63966: LD_INT 3
63968: PUSH
63969: LD_INT 3
63971: PUSH
63972: EMPTY
63973: LIST
63974: LIST
63975: PUSH
63976: LD_INT 2
63978: PUSH
63979: LD_INT 3
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: LIST
63990: LIST
63991: LIST
63992: LIST
63993: LIST
63994: LIST
63995: LIST
63996: LIST
63997: LIST
63998: LIST
63999: LIST
64000: LIST
64001: LIST
64002: LIST
64003: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64004: LD_ADDR_VAR 0 17
64008: PUSH
64009: LD_INT 0
64011: PUSH
64012: LD_INT 0
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PUSH
64019: LD_INT 0
64021: PUSH
64022: LD_INT 1
64024: NEG
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PUSH
64030: LD_INT 1
64032: PUSH
64033: LD_INT 0
64035: PUSH
64036: EMPTY
64037: LIST
64038: LIST
64039: PUSH
64040: LD_INT 1
64042: PUSH
64043: LD_INT 1
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PUSH
64050: LD_INT 0
64052: PUSH
64053: LD_INT 1
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 1
64062: NEG
64063: PUSH
64064: LD_INT 0
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: LD_INT 1
64077: NEG
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: PUSH
64083: LD_INT 1
64085: NEG
64086: PUSH
64087: LD_INT 2
64089: NEG
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PUSH
64095: LD_INT 0
64097: PUSH
64098: LD_INT 2
64100: NEG
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: PUSH
64106: LD_INT 1
64108: PUSH
64109: LD_INT 1
64111: NEG
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 2
64119: PUSH
64120: LD_INT 0
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 2
64129: PUSH
64130: LD_INT 1
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: LD_INT 2
64139: PUSH
64140: LD_INT 2
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: PUSH
64147: LD_INT 1
64149: PUSH
64150: LD_INT 2
64152: PUSH
64153: EMPTY
64154: LIST
64155: LIST
64156: PUSH
64157: LD_INT 0
64159: PUSH
64160: LD_INT 2
64162: PUSH
64163: EMPTY
64164: LIST
64165: LIST
64166: PUSH
64167: LD_INT 1
64169: NEG
64170: PUSH
64171: LD_INT 1
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: PUSH
64178: LD_INT 2
64180: NEG
64181: PUSH
64182: LD_INT 0
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 2
64191: NEG
64192: PUSH
64193: LD_INT 1
64195: NEG
64196: PUSH
64197: EMPTY
64198: LIST
64199: LIST
64200: PUSH
64201: LD_INT 2
64203: NEG
64204: PUSH
64205: LD_INT 2
64207: NEG
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64234: LD_ADDR_VAR 0 18
64238: PUSH
64239: LD_INT 0
64241: PUSH
64242: LD_INT 0
64244: PUSH
64245: EMPTY
64246: LIST
64247: LIST
64248: PUSH
64249: LD_INT 0
64251: PUSH
64252: LD_INT 1
64254: NEG
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 1
64262: PUSH
64263: LD_INT 0
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: LD_INT 1
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PUSH
64280: LD_INT 0
64282: PUSH
64283: LD_INT 1
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: PUSH
64290: LD_INT 1
64292: NEG
64293: PUSH
64294: LD_INT 0
64296: PUSH
64297: EMPTY
64298: LIST
64299: LIST
64300: PUSH
64301: LD_INT 1
64303: NEG
64304: PUSH
64305: LD_INT 1
64307: NEG
64308: PUSH
64309: EMPTY
64310: LIST
64311: LIST
64312: PUSH
64313: LD_INT 1
64315: NEG
64316: PUSH
64317: LD_INT 2
64319: NEG
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: LD_INT 2
64330: NEG
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: LD_INT 1
64338: PUSH
64339: LD_INT 1
64341: NEG
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: PUSH
64347: LD_INT 2
64349: PUSH
64350: LD_INT 0
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PUSH
64357: LD_INT 2
64359: PUSH
64360: LD_INT 1
64362: PUSH
64363: EMPTY
64364: LIST
64365: LIST
64366: PUSH
64367: LD_INT 2
64369: PUSH
64370: LD_INT 2
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 1
64379: PUSH
64380: LD_INT 2
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 0
64389: PUSH
64390: LD_INT 2
64392: PUSH
64393: EMPTY
64394: LIST
64395: LIST
64396: PUSH
64397: LD_INT 1
64399: NEG
64400: PUSH
64401: LD_INT 1
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: PUSH
64408: LD_INT 2
64410: NEG
64411: PUSH
64412: LD_INT 0
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 2
64421: NEG
64422: PUSH
64423: LD_INT 1
64425: NEG
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 2
64433: NEG
64434: PUSH
64435: LD_INT 2
64437: NEG
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: LIST
64447: LIST
64448: LIST
64449: LIST
64450: LIST
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64464: LD_ADDR_VAR 0 19
64468: PUSH
64469: LD_INT 0
64471: PUSH
64472: LD_INT 0
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: PUSH
64479: LD_INT 0
64481: PUSH
64482: LD_INT 1
64484: NEG
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: LD_INT 1
64492: PUSH
64493: LD_INT 0
64495: PUSH
64496: EMPTY
64497: LIST
64498: LIST
64499: PUSH
64500: LD_INT 1
64502: PUSH
64503: LD_INT 1
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: PUSH
64510: LD_INT 0
64512: PUSH
64513: LD_INT 1
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 1
64522: NEG
64523: PUSH
64524: LD_INT 0
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: LD_INT 1
64533: NEG
64534: PUSH
64535: LD_INT 1
64537: NEG
64538: PUSH
64539: EMPTY
64540: LIST
64541: LIST
64542: PUSH
64543: LD_INT 1
64545: NEG
64546: PUSH
64547: LD_INT 2
64549: NEG
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 0
64557: PUSH
64558: LD_INT 2
64560: NEG
64561: PUSH
64562: EMPTY
64563: LIST
64564: LIST
64565: PUSH
64566: LD_INT 1
64568: PUSH
64569: LD_INT 1
64571: NEG
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: PUSH
64577: LD_INT 2
64579: PUSH
64580: LD_INT 0
64582: PUSH
64583: EMPTY
64584: LIST
64585: LIST
64586: PUSH
64587: LD_INT 2
64589: PUSH
64590: LD_INT 1
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: LD_INT 2
64599: PUSH
64600: LD_INT 2
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 1
64609: PUSH
64610: LD_INT 2
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 0
64619: PUSH
64620: LD_INT 2
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 1
64629: NEG
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PUSH
64638: LD_INT 2
64640: NEG
64641: PUSH
64642: LD_INT 0
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 2
64651: NEG
64652: PUSH
64653: LD_INT 1
64655: NEG
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 2
64663: NEG
64664: PUSH
64665: LD_INT 2
64667: NEG
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: EMPTY
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64694: LD_ADDR_VAR 0 20
64698: PUSH
64699: LD_INT 0
64701: PUSH
64702: LD_INT 0
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: PUSH
64709: LD_INT 0
64711: PUSH
64712: LD_INT 1
64714: NEG
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: PUSH
64720: LD_INT 1
64722: PUSH
64723: LD_INT 0
64725: PUSH
64726: EMPTY
64727: LIST
64728: LIST
64729: PUSH
64730: LD_INT 1
64732: PUSH
64733: LD_INT 1
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PUSH
64740: LD_INT 0
64742: PUSH
64743: LD_INT 1
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 1
64752: NEG
64753: PUSH
64754: LD_INT 0
64756: PUSH
64757: EMPTY
64758: LIST
64759: LIST
64760: PUSH
64761: LD_INT 1
64763: NEG
64764: PUSH
64765: LD_INT 1
64767: NEG
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 1
64775: NEG
64776: PUSH
64777: LD_INT 2
64779: NEG
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 0
64787: PUSH
64788: LD_INT 2
64790: NEG
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PUSH
64796: LD_INT 1
64798: PUSH
64799: LD_INT 1
64801: NEG
64802: PUSH
64803: EMPTY
64804: LIST
64805: LIST
64806: PUSH
64807: LD_INT 2
64809: PUSH
64810: LD_INT 0
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: LD_INT 2
64819: PUSH
64820: LD_INT 1
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: LD_INT 2
64829: PUSH
64830: LD_INT 2
64832: PUSH
64833: EMPTY
64834: LIST
64835: LIST
64836: PUSH
64837: LD_INT 1
64839: PUSH
64840: LD_INT 2
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 0
64849: PUSH
64850: LD_INT 2
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 1
64859: NEG
64860: PUSH
64861: LD_INT 1
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: LD_INT 2
64870: NEG
64871: PUSH
64872: LD_INT 0
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PUSH
64879: LD_INT 2
64881: NEG
64882: PUSH
64883: LD_INT 1
64885: NEG
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 2
64893: NEG
64894: PUSH
64895: LD_INT 2
64897: NEG
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64924: LD_ADDR_VAR 0 21
64928: PUSH
64929: LD_INT 0
64931: PUSH
64932: LD_INT 0
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: PUSH
64939: LD_INT 0
64941: PUSH
64942: LD_INT 1
64944: NEG
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: LD_INT 1
64952: PUSH
64953: LD_INT 0
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: PUSH
64960: LD_INT 1
64962: PUSH
64963: LD_INT 1
64965: PUSH
64966: EMPTY
64967: LIST
64968: LIST
64969: PUSH
64970: LD_INT 0
64972: PUSH
64973: LD_INT 1
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: PUSH
64980: LD_INT 1
64982: NEG
64983: PUSH
64984: LD_INT 0
64986: PUSH
64987: EMPTY
64988: LIST
64989: LIST
64990: PUSH
64991: LD_INT 1
64993: NEG
64994: PUSH
64995: LD_INT 1
64997: NEG
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 1
65005: NEG
65006: PUSH
65007: LD_INT 2
65009: NEG
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 0
65017: PUSH
65018: LD_INT 2
65020: NEG
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 1
65028: PUSH
65029: LD_INT 1
65031: NEG
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 2
65039: PUSH
65040: LD_INT 0
65042: PUSH
65043: EMPTY
65044: LIST
65045: LIST
65046: PUSH
65047: LD_INT 2
65049: PUSH
65050: LD_INT 1
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PUSH
65057: LD_INT 2
65059: PUSH
65060: LD_INT 2
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 1
65069: PUSH
65070: LD_INT 2
65072: PUSH
65073: EMPTY
65074: LIST
65075: LIST
65076: PUSH
65077: LD_INT 0
65079: PUSH
65080: LD_INT 2
65082: PUSH
65083: EMPTY
65084: LIST
65085: LIST
65086: PUSH
65087: LD_INT 1
65089: NEG
65090: PUSH
65091: LD_INT 1
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 2
65100: NEG
65101: PUSH
65102: LD_INT 0
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: LD_INT 2
65111: NEG
65112: PUSH
65113: LD_INT 1
65115: NEG
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 2
65123: NEG
65124: PUSH
65125: LD_INT 2
65127: NEG
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: EMPTY
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65154: LD_ADDR_VAR 0 22
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: LD_INT 0
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 0
65171: PUSH
65172: LD_INT 1
65174: NEG
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: LD_INT 0
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PUSH
65190: LD_INT 1
65192: PUSH
65193: LD_INT 1
65195: PUSH
65196: EMPTY
65197: LIST
65198: LIST
65199: PUSH
65200: LD_INT 0
65202: PUSH
65203: LD_INT 1
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 1
65212: NEG
65213: PUSH
65214: LD_INT 0
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PUSH
65221: LD_INT 1
65223: NEG
65224: PUSH
65225: LD_INT 1
65227: NEG
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: LD_INT 2
65239: NEG
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 0
65247: PUSH
65248: LD_INT 2
65250: NEG
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 1
65258: PUSH
65259: LD_INT 1
65261: NEG
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 2
65269: PUSH
65270: LD_INT 0
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: PUSH
65277: LD_INT 2
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 2
65289: PUSH
65290: LD_INT 2
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 1
65299: PUSH
65300: LD_INT 2
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 0
65309: PUSH
65310: LD_INT 2
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 1
65319: NEG
65320: PUSH
65321: LD_INT 1
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 2
65330: NEG
65331: PUSH
65332: LD_INT 0
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: PUSH
65339: LD_INT 2
65341: NEG
65342: PUSH
65343: LD_INT 1
65345: NEG
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 2
65353: NEG
65354: PUSH
65355: LD_INT 2
65357: NEG
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65384: LD_ADDR_VAR 0 23
65388: PUSH
65389: LD_INT 0
65391: PUSH
65392: LD_INT 0
65394: PUSH
65395: EMPTY
65396: LIST
65397: LIST
65398: PUSH
65399: LD_INT 0
65401: PUSH
65402: LD_INT 1
65404: NEG
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 1
65412: PUSH
65413: LD_INT 0
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: PUSH
65420: LD_INT 1
65422: PUSH
65423: LD_INT 1
65425: PUSH
65426: EMPTY
65427: LIST
65428: LIST
65429: PUSH
65430: LD_INT 0
65432: PUSH
65433: LD_INT 1
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: PUSH
65440: LD_INT 1
65442: NEG
65443: PUSH
65444: LD_INT 0
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 1
65453: NEG
65454: PUSH
65455: LD_INT 1
65457: NEG
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 1
65465: NEG
65466: PUSH
65467: LD_INT 2
65469: NEG
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 0
65477: PUSH
65478: LD_INT 2
65480: NEG
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: LD_INT 1
65488: PUSH
65489: LD_INT 1
65491: NEG
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 2
65499: PUSH
65500: LD_INT 0
65502: PUSH
65503: EMPTY
65504: LIST
65505: LIST
65506: PUSH
65507: LD_INT 2
65509: PUSH
65510: LD_INT 1
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: LD_INT 2
65519: PUSH
65520: LD_INT 2
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 1
65529: PUSH
65530: LD_INT 2
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: LD_INT 2
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 1
65549: NEG
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 2
65560: NEG
65561: PUSH
65562: LD_INT 0
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: NEG
65572: PUSH
65573: LD_INT 1
65575: NEG
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 2
65583: NEG
65584: PUSH
65585: LD_INT 2
65587: NEG
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: NEG
65596: PUSH
65597: LD_INT 3
65599: NEG
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 1
65607: NEG
65608: PUSH
65609: LD_INT 3
65611: NEG
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 1
65619: PUSH
65620: LD_INT 2
65622: NEG
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 2
65630: PUSH
65631: LD_INT 1
65633: NEG
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: LIST
65643: LIST
65644: LIST
65645: LIST
65646: LIST
65647: LIST
65648: LIST
65649: LIST
65650: LIST
65651: LIST
65652: LIST
65653: LIST
65654: LIST
65655: LIST
65656: LIST
65657: LIST
65658: LIST
65659: LIST
65660: LIST
65661: LIST
65662: LIST
65663: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65664: LD_ADDR_VAR 0 24
65668: PUSH
65669: LD_INT 0
65671: PUSH
65672: LD_INT 0
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PUSH
65679: LD_INT 0
65681: PUSH
65682: LD_INT 1
65684: NEG
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 1
65692: PUSH
65693: LD_INT 0
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: LD_INT 1
65702: PUSH
65703: LD_INT 1
65705: PUSH
65706: EMPTY
65707: LIST
65708: LIST
65709: PUSH
65710: LD_INT 0
65712: PUSH
65713: LD_INT 1
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: PUSH
65720: LD_INT 1
65722: NEG
65723: PUSH
65724: LD_INT 0
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: LD_INT 1
65733: NEG
65734: PUSH
65735: LD_INT 1
65737: NEG
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 1
65745: NEG
65746: PUSH
65747: LD_INT 2
65749: NEG
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: PUSH
65755: LD_INT 0
65757: PUSH
65758: LD_INT 2
65760: NEG
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PUSH
65766: LD_INT 1
65768: PUSH
65769: LD_INT 1
65771: NEG
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 2
65779: PUSH
65780: LD_INT 0
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 2
65789: PUSH
65790: LD_INT 1
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PUSH
65797: LD_INT 2
65799: PUSH
65800: LD_INT 2
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: PUSH
65807: LD_INT 1
65809: PUSH
65810: LD_INT 2
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 0
65819: PUSH
65820: LD_INT 2
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 1
65829: NEG
65830: PUSH
65831: LD_INT 1
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: PUSH
65838: LD_INT 2
65840: NEG
65841: PUSH
65842: LD_INT 0
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 2
65851: NEG
65852: PUSH
65853: LD_INT 1
65855: NEG
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: PUSH
65861: LD_INT 2
65863: NEG
65864: PUSH
65865: LD_INT 2
65867: NEG
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PUSH
65873: LD_INT 1
65875: PUSH
65876: LD_INT 2
65878: NEG
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: LD_INT 2
65886: PUSH
65887: LD_INT 1
65889: NEG
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 3
65897: PUSH
65898: LD_INT 1
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: PUSH
65905: LD_INT 3
65907: PUSH
65908: LD_INT 2
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65940: LD_ADDR_VAR 0 25
65944: PUSH
65945: LD_INT 0
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 0
65957: PUSH
65958: LD_INT 1
65960: NEG
65961: PUSH
65962: EMPTY
65963: LIST
65964: LIST
65965: PUSH
65966: LD_INT 1
65968: PUSH
65969: LD_INT 0
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: PUSH
65976: LD_INT 1
65978: PUSH
65979: LD_INT 1
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: LD_INT 0
65988: PUSH
65989: LD_INT 1
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 1
65998: NEG
65999: PUSH
66000: LD_INT 0
66002: PUSH
66003: EMPTY
66004: LIST
66005: LIST
66006: PUSH
66007: LD_INT 1
66009: NEG
66010: PUSH
66011: LD_INT 1
66013: NEG
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 1
66021: NEG
66022: PUSH
66023: LD_INT 2
66025: NEG
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 0
66033: PUSH
66034: LD_INT 2
66036: NEG
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 1
66044: PUSH
66045: LD_INT 1
66047: NEG
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PUSH
66053: LD_INT 2
66055: PUSH
66056: LD_INT 0
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PUSH
66063: LD_INT 2
66065: PUSH
66066: LD_INT 1
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: PUSH
66073: LD_INT 2
66075: PUSH
66076: LD_INT 2
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 1
66085: PUSH
66086: LD_INT 2
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 0
66095: PUSH
66096: LD_INT 2
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 1
66105: NEG
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: PUSH
66114: LD_INT 2
66116: NEG
66117: PUSH
66118: LD_INT 0
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: LD_INT 2
66127: NEG
66128: PUSH
66129: LD_INT 1
66131: NEG
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 2
66139: NEG
66140: PUSH
66141: LD_INT 2
66143: NEG
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 3
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: LD_INT 3
66161: PUSH
66162: LD_INT 2
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: LD_INT 2
66171: PUSH
66172: LD_INT 3
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 1
66181: PUSH
66182: LD_INT 3
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66214: LD_ADDR_VAR 0 26
66218: PUSH
66219: LD_INT 0
66221: PUSH
66222: LD_INT 0
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PUSH
66229: LD_INT 0
66231: PUSH
66232: LD_INT 1
66234: NEG
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 1
66242: PUSH
66243: LD_INT 0
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: LD_INT 1
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 0
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 1
66272: NEG
66273: PUSH
66274: LD_INT 0
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: LD_INT 1
66287: NEG
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: NEG
66296: PUSH
66297: LD_INT 2
66299: NEG
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 0
66307: PUSH
66308: LD_INT 2
66310: NEG
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: LD_INT 1
66321: NEG
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 2
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 2
66339: PUSH
66340: LD_INT 1
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 2
66349: PUSH
66350: LD_INT 2
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 1
66359: PUSH
66360: LD_INT 2
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: LD_INT 2
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 2
66390: NEG
66391: PUSH
66392: LD_INT 0
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 2
66401: NEG
66402: PUSH
66403: LD_INT 1
66405: NEG
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: LD_INT 2
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 2
66425: PUSH
66426: LD_INT 3
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 1
66435: PUSH
66436: LD_INT 3
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 1
66445: NEG
66446: PUSH
66447: LD_INT 2
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 2
66456: NEG
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66490: LD_ADDR_VAR 0 27
66494: PUSH
66495: LD_INT 0
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 0
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: LD_INT 1
66518: PUSH
66519: LD_INT 0
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 1
66528: PUSH
66529: LD_INT 1
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 0
66538: PUSH
66539: LD_INT 1
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 1
66548: NEG
66549: PUSH
66550: LD_INT 0
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: LD_INT 1
66563: NEG
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: LD_INT 2
66575: NEG
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 0
66583: PUSH
66584: LD_INT 2
66586: NEG
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 1
66594: PUSH
66595: LD_INT 1
66597: NEG
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: PUSH
66603: LD_INT 2
66605: PUSH
66606: LD_INT 0
66608: PUSH
66609: EMPTY
66610: LIST
66611: LIST
66612: PUSH
66613: LD_INT 2
66615: PUSH
66616: LD_INT 1
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PUSH
66623: LD_INT 2
66625: PUSH
66626: LD_INT 2
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 1
66635: PUSH
66636: LD_INT 2
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 0
66645: PUSH
66646: LD_INT 2
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 1
66655: NEG
66656: PUSH
66657: LD_INT 1
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 2
66666: NEG
66667: PUSH
66668: LD_INT 0
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 2
66677: NEG
66678: PUSH
66679: LD_INT 1
66681: NEG
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 2
66689: NEG
66690: PUSH
66691: LD_INT 2
66693: NEG
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 1
66701: NEG
66702: PUSH
66703: LD_INT 2
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 2
66712: NEG
66713: PUSH
66714: LD_INT 1
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 3
66723: NEG
66724: PUSH
66725: LD_INT 1
66727: NEG
66728: PUSH
66729: EMPTY
66730: LIST
66731: LIST
66732: PUSH
66733: LD_INT 3
66735: NEG
66736: PUSH
66737: LD_INT 2
66739: NEG
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66770: LD_ADDR_VAR 0 28
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: LD_INT 0
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 0
66787: PUSH
66788: LD_INT 1
66790: NEG
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 1
66798: PUSH
66799: LD_INT 0
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: LD_INT 1
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 0
66818: PUSH
66819: LD_INT 1
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 1
66828: NEG
66829: PUSH
66830: LD_INT 0
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: LD_INT 1
66839: NEG
66840: PUSH
66841: LD_INT 1
66843: NEG
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: LD_INT 2
66855: NEG
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: LD_INT 2
66866: NEG
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 1
66874: PUSH
66875: LD_INT 1
66877: NEG
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 2
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 2
66895: PUSH
66896: LD_INT 1
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 2
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 1
66915: PUSH
66916: LD_INT 2
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 0
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 1
66935: NEG
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 2
66946: NEG
66947: PUSH
66948: LD_INT 0
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: PUSH
66955: LD_INT 2
66957: NEG
66958: PUSH
66959: LD_INT 1
66961: NEG
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 2
66969: NEG
66970: PUSH
66971: LD_INT 2
66973: NEG
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: PUSH
66979: LD_INT 2
66981: NEG
66982: PUSH
66983: LD_INT 3
66985: NEG
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 1
66993: NEG
66994: PUSH
66995: LD_INT 3
66997: NEG
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 3
67005: NEG
67006: PUSH
67007: LD_INT 1
67009: NEG
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 3
67017: NEG
67018: PUSH
67019: LD_INT 2
67021: NEG
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67052: LD_ADDR_VAR 0 29
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: LD_INT 0
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: LD_INT 0
67069: PUSH
67070: LD_INT 1
67072: NEG
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PUSH
67078: LD_INT 1
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: LD_INT 1
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 0
67100: PUSH
67101: LD_INT 1
67103: PUSH
67104: EMPTY
67105: LIST
67106: LIST
67107: PUSH
67108: LD_INT 1
67110: NEG
67111: PUSH
67112: LD_INT 0
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: LD_INT 1
67121: NEG
67122: PUSH
67123: LD_INT 1
67125: NEG
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 1
67133: NEG
67134: PUSH
67135: LD_INT 2
67137: NEG
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 0
67145: PUSH
67146: LD_INT 2
67148: NEG
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: PUSH
67154: LD_INT 1
67156: PUSH
67157: LD_INT 1
67159: NEG
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 2
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 2
67177: PUSH
67178: LD_INT 1
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 1
67187: PUSH
67188: LD_INT 2
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 0
67197: PUSH
67198: LD_INT 2
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 1
67207: NEG
67208: PUSH
67209: LD_INT 1
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 2
67218: NEG
67219: PUSH
67220: LD_INT 1
67222: NEG
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: PUSH
67228: LD_INT 2
67230: NEG
67231: PUSH
67232: LD_INT 2
67234: NEG
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: PUSH
67240: LD_INT 2
67242: NEG
67243: PUSH
67244: LD_INT 3
67246: NEG
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: LD_INT 1
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 3
67265: PUSH
67266: LD_INT 1
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 1
67275: PUSH
67276: LD_INT 3
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PUSH
67283: LD_INT 1
67285: NEG
67286: PUSH
67287: LD_INT 2
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 3
67296: NEG
67297: PUSH
67298: LD_INT 2
67300: NEG
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: LIST
67317: LIST
67318: LIST
67319: LIST
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: LIST
67329: LIST
67330: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67331: LD_ADDR_VAR 0 30
67335: PUSH
67336: LD_INT 0
67338: PUSH
67339: LD_INT 0
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 0
67348: PUSH
67349: LD_INT 1
67351: NEG
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 1
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: LD_INT 1
67369: PUSH
67370: LD_INT 1
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: PUSH
67377: LD_INT 0
67379: PUSH
67380: LD_INT 1
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: LD_INT 1
67389: NEG
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 1
67400: NEG
67401: PUSH
67402: LD_INT 1
67404: NEG
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 1
67412: NEG
67413: PUSH
67414: LD_INT 2
67416: NEG
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 0
67424: PUSH
67425: LD_INT 2
67427: NEG
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: LD_INT 1
67438: NEG
67439: PUSH
67440: EMPTY
67441: LIST
67442: LIST
67443: PUSH
67444: LD_INT 2
67446: PUSH
67447: LD_INT 0
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 2
67456: PUSH
67457: LD_INT 1
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 2
67466: PUSH
67467: LD_INT 2
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: PUSH
67477: LD_INT 2
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 1
67486: NEG
67487: PUSH
67488: LD_INT 1
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PUSH
67495: LD_INT 2
67497: NEG
67498: PUSH
67499: LD_INT 0
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 2
67508: NEG
67509: PUSH
67510: LD_INT 1
67512: NEG
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 1
67520: NEG
67521: PUSH
67522: LD_INT 3
67524: NEG
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 1
67532: PUSH
67533: LD_INT 2
67535: NEG
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 3
67543: PUSH
67544: LD_INT 2
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 2
67553: PUSH
67554: LD_INT 3
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 2
67563: NEG
67564: PUSH
67565: LD_INT 1
67567: PUSH
67568: EMPTY
67569: LIST
67570: LIST
67571: PUSH
67572: LD_INT 3
67574: NEG
67575: PUSH
67576: LD_INT 1
67578: NEG
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67609: LD_ADDR_VAR 0 31
67613: PUSH
67614: LD_INT 0
67616: PUSH
67617: LD_INT 0
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PUSH
67624: LD_INT 0
67626: PUSH
67627: LD_INT 1
67629: NEG
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 1
67637: PUSH
67638: LD_INT 0
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: LD_INT 1
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: LD_INT 1
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 1
67667: NEG
67668: PUSH
67669: LD_INT 0
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 1
67678: NEG
67679: PUSH
67680: LD_INT 1
67682: NEG
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PUSH
67688: LD_INT 1
67690: NEG
67691: PUSH
67692: LD_INT 2
67694: NEG
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 1
67702: PUSH
67703: LD_INT 1
67705: NEG
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 2
67713: PUSH
67714: LD_INT 0
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PUSH
67721: LD_INT 2
67723: PUSH
67724: LD_INT 1
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 2
67733: PUSH
67734: LD_INT 2
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 1
67743: PUSH
67744: LD_INT 2
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 0
67753: PUSH
67754: LD_INT 2
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 1
67763: NEG
67764: PUSH
67765: LD_INT 1
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 2
67774: NEG
67775: PUSH
67776: LD_INT 1
67778: NEG
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 2
67786: NEG
67787: PUSH
67788: LD_INT 2
67790: NEG
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 2
67798: NEG
67799: PUSH
67800: LD_INT 3
67802: NEG
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: PUSH
67808: LD_INT 2
67810: PUSH
67811: LD_INT 1
67813: NEG
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 3
67821: PUSH
67822: LD_INT 1
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: PUSH
67829: LD_INT 1
67831: PUSH
67832: LD_INT 3
67834: PUSH
67835: EMPTY
67836: LIST
67837: LIST
67838: PUSH
67839: LD_INT 1
67841: NEG
67842: PUSH
67843: LD_INT 2
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 3
67852: NEG
67853: PUSH
67854: LD_INT 2
67856: NEG
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67887: LD_ADDR_VAR 0 32
67891: PUSH
67892: LD_INT 0
67894: PUSH
67895: LD_INT 0
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 0
67904: PUSH
67905: LD_INT 1
67907: NEG
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: LD_INT 1
67915: PUSH
67916: LD_INT 0
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: PUSH
67923: LD_INT 1
67925: PUSH
67926: LD_INT 1
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 0
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 1
67945: NEG
67946: PUSH
67947: LD_INT 0
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PUSH
67954: LD_INT 1
67956: NEG
67957: PUSH
67958: LD_INT 1
67960: NEG
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 1
67968: NEG
67969: PUSH
67970: LD_INT 2
67972: NEG
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 0
67980: PUSH
67981: LD_INT 2
67983: NEG
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 1
67991: PUSH
67992: LD_INT 1
67994: NEG
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 2
68002: PUSH
68003: LD_INT 1
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 2
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 1
68022: PUSH
68023: LD_INT 2
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 0
68032: PUSH
68033: LD_INT 2
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 1
68042: NEG
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: LD_INT 2
68053: NEG
68054: PUSH
68055: LD_INT 0
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 2
68064: NEG
68065: PUSH
68066: LD_INT 1
68068: NEG
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: LD_INT 3
68080: NEG
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: PUSH
68086: LD_INT 1
68088: PUSH
68089: LD_INT 2
68091: NEG
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 3
68099: PUSH
68100: LD_INT 2
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: LD_INT 2
68109: PUSH
68110: LD_INT 3
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 2
68119: NEG
68120: PUSH
68121: LD_INT 1
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PUSH
68128: LD_INT 3
68130: NEG
68131: PUSH
68132: LD_INT 1
68134: NEG
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: LIST
68144: LIST
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68165: LD_ADDR_VAR 0 33
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: LD_INT 0
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 0
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 1
68193: PUSH
68194: LD_INT 0
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 1
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: LD_INT 0
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 1
68234: NEG
68235: PUSH
68236: LD_INT 1
68238: NEG
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 2
68250: NEG
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 2
68269: PUSH
68270: LD_INT 0
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 1
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: PUSH
68287: LD_INT 1
68289: PUSH
68290: LD_INT 2
68292: PUSH
68293: EMPTY
68294: LIST
68295: LIST
68296: PUSH
68297: LD_INT 0
68299: PUSH
68300: LD_INT 2
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 1
68309: NEG
68310: PUSH
68311: LD_INT 1
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 2
68320: NEG
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 2
68331: NEG
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 2
68343: NEG
68344: PUSH
68345: LD_INT 2
68347: NEG
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 2
68355: NEG
68356: PUSH
68357: LD_INT 3
68359: NEG
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 2
68367: PUSH
68368: LD_INT 1
68370: NEG
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 3
68378: PUSH
68379: LD_INT 1
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 1
68388: PUSH
68389: LD_INT 3
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: LD_INT 2
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 3
68409: NEG
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: LIST
68439: LIST
68440: LIST
68441: LIST
68442: LIST
68443: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68444: LD_ADDR_VAR 0 34
68448: PUSH
68449: LD_INT 0
68451: PUSH
68452: LD_INT 0
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 0
68461: PUSH
68462: LD_INT 1
68464: NEG
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 1
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 1
68482: PUSH
68483: LD_INT 1
68485: PUSH
68486: EMPTY
68487: LIST
68488: LIST
68489: PUSH
68490: LD_INT 0
68492: PUSH
68493: LD_INT 1
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 1
68502: NEG
68503: PUSH
68504: LD_INT 0
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 1
68513: NEG
68514: PUSH
68515: LD_INT 1
68517: NEG
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 1
68525: NEG
68526: PUSH
68527: LD_INT 2
68529: NEG
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 0
68537: PUSH
68538: LD_INT 2
68540: NEG
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 1
68548: PUSH
68549: LD_INT 1
68551: NEG
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: PUSH
68557: LD_INT 2
68559: PUSH
68560: LD_INT 1
68562: PUSH
68563: EMPTY
68564: LIST
68565: LIST
68566: PUSH
68567: LD_INT 2
68569: PUSH
68570: LD_INT 2
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 1
68579: PUSH
68580: LD_INT 2
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PUSH
68587: LD_INT 1
68589: NEG
68590: PUSH
68591: LD_INT 1
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 2
68600: NEG
68601: PUSH
68602: LD_INT 0
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 2
68623: NEG
68624: PUSH
68625: LD_INT 2
68627: NEG
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 1
68635: NEG
68636: PUSH
68637: LD_INT 3
68639: NEG
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 1
68647: PUSH
68648: LD_INT 2
68650: NEG
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 3
68658: PUSH
68659: LD_INT 2
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 2
68668: PUSH
68669: LD_INT 3
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 2
68678: NEG
68679: PUSH
68680: LD_INT 1
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 3
68689: NEG
68690: PUSH
68691: LD_INT 1
68693: NEG
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68724: LD_ADDR_VAR 0 35
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 0
68741: PUSH
68742: LD_INT 1
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: LD_INT 0
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 1
68762: PUSH
68763: LD_INT 1
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 0
68772: PUSH
68773: LD_INT 1
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 1
68782: NEG
68783: PUSH
68784: LD_INT 0
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 1
68793: NEG
68794: PUSH
68795: LD_INT 1
68797: NEG
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 2
68805: PUSH
68806: LD_INT 1
68808: PUSH
68809: EMPTY
68810: LIST
68811: LIST
68812: PUSH
68813: LD_INT 2
68815: NEG
68816: PUSH
68817: LD_INT 1
68819: NEG
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68836: LD_ADDR_VAR 0 36
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: LD_INT 0
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 0
68853: PUSH
68854: LD_INT 1
68856: NEG
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 1
68864: PUSH
68865: LD_INT 0
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 1
68874: PUSH
68875: LD_INT 1
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 0
68884: PUSH
68885: LD_INT 1
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 1
68894: NEG
68895: PUSH
68896: LD_INT 0
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 1
68905: NEG
68906: PUSH
68907: LD_INT 1
68909: NEG
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 1
68917: NEG
68918: PUSH
68919: LD_INT 2
68921: NEG
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 1
68929: PUSH
68930: LD_INT 2
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68948: LD_ADDR_VAR 0 37
68952: PUSH
68953: LD_INT 0
68955: PUSH
68956: LD_INT 0
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 0
68965: PUSH
68966: LD_INT 1
68968: NEG
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: PUSH
68977: LD_INT 0
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 1
68986: PUSH
68987: LD_INT 1
68989: PUSH
68990: EMPTY
68991: LIST
68992: LIST
68993: PUSH
68994: LD_INT 0
68996: PUSH
68997: LD_INT 1
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 1
69006: NEG
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 1
69017: NEG
69018: PUSH
69019: LD_INT 1
69021: NEG
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: LD_INT 1
69032: NEG
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: LD_INT 1
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69060: LD_ADDR_VAR 0 38
69064: PUSH
69065: LD_INT 0
69067: PUSH
69068: LD_INT 0
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: LD_INT 0
69077: PUSH
69078: LD_INT 1
69080: NEG
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 1
69088: PUSH
69089: LD_INT 0
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 1
69098: PUSH
69099: LD_INT 1
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 0
69108: PUSH
69109: LD_INT 1
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 1
69118: NEG
69119: PUSH
69120: LD_INT 0
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 1
69129: NEG
69130: PUSH
69131: LD_INT 1
69133: NEG
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: LD_INT 2
69141: PUSH
69142: LD_INT 1
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 2
69151: NEG
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69172: LD_ADDR_VAR 0 39
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: LD_INT 0
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 0
69189: PUSH
69190: LD_INT 1
69192: NEG
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 1
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 1
69210: PUSH
69211: LD_INT 1
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 0
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 1
69230: NEG
69231: PUSH
69232: LD_INT 0
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 1
69241: NEG
69242: PUSH
69243: LD_INT 1
69245: NEG
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 1
69253: NEG
69254: PUSH
69255: LD_INT 2
69257: NEG
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 1
69265: PUSH
69266: LD_INT 2
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69284: LD_ADDR_VAR 0 40
69288: PUSH
69289: LD_INT 0
69291: PUSH
69292: LD_INT 0
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 0
69301: PUSH
69302: LD_INT 1
69304: NEG
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 1
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 1
69322: PUSH
69323: LD_INT 1
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 0
69332: PUSH
69333: LD_INT 1
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 1
69342: NEG
69343: PUSH
69344: LD_INT 0
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 1
69353: NEG
69354: PUSH
69355: LD_INT 1
69357: NEG
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 1
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 1
69376: NEG
69377: PUSH
69378: LD_INT 1
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69396: LD_ADDR_VAR 0 41
69400: PUSH
69401: LD_INT 0
69403: PUSH
69404: LD_INT 0
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 0
69413: PUSH
69414: LD_INT 1
69416: NEG
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 1
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PUSH
69432: LD_INT 1
69434: PUSH
69435: LD_INT 1
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: PUSH
69442: LD_INT 0
69444: PUSH
69445: LD_INT 1
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: LD_INT 0
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 1
69465: NEG
69466: PUSH
69467: LD_INT 1
69469: NEG
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 1
69477: NEG
69478: PUSH
69479: LD_INT 2
69481: NEG
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 1
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 2
69500: PUSH
69501: LD_INT 0
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 2
69510: PUSH
69511: LD_INT 1
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 2
69520: PUSH
69521: LD_INT 2
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: PUSH
69528: LD_INT 1
69530: PUSH
69531: LD_INT 2
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 1
69540: NEG
69541: PUSH
69542: LD_INT 1
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: LD_INT 2
69551: NEG
69552: PUSH
69553: LD_INT 0
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 2
69562: NEG
69563: PUSH
69564: LD_INT 1
69566: NEG
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 2
69574: NEG
69575: PUSH
69576: LD_INT 2
69578: NEG
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: LD_INT 2
69586: NEG
69587: PUSH
69588: LD_INT 3
69590: NEG
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 2
69598: PUSH
69599: LD_INT 1
69601: NEG
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 3
69609: PUSH
69610: LD_INT 0
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 3
69619: PUSH
69620: LD_INT 1
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 3
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 3
69639: PUSH
69640: LD_INT 3
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 2
69649: PUSH
69650: LD_INT 3
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 2
69659: NEG
69660: PUSH
69661: LD_INT 1
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: LD_INT 3
69670: NEG
69671: PUSH
69672: LD_INT 0
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 3
69681: NEG
69682: PUSH
69683: LD_INT 1
69685: NEG
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 3
69693: NEG
69694: PUSH
69695: LD_INT 2
69697: NEG
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 3
69705: NEG
69706: PUSH
69707: LD_INT 3
69709: NEG
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69746: LD_ADDR_VAR 0 42
69750: PUSH
69751: LD_INT 0
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 1
69774: PUSH
69775: LD_INT 0
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: PUSH
69785: LD_INT 1
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 0
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 1
69804: NEG
69805: PUSH
69806: LD_INT 0
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 1
69815: NEG
69816: PUSH
69817: LD_INT 1
69819: NEG
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 1
69827: NEG
69828: PUSH
69829: LD_INT 2
69831: NEG
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: LD_INT 0
69839: PUSH
69840: LD_INT 2
69842: NEG
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: PUSH
69851: LD_INT 1
69853: NEG
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 2
69861: PUSH
69862: LD_INT 1
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 2
69871: PUSH
69872: LD_INT 2
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 1
69881: PUSH
69882: LD_INT 2
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 0
69891: PUSH
69892: LD_INT 2
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 1
69901: NEG
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 2
69912: NEG
69913: PUSH
69914: LD_INT 1
69916: NEG
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 2
69924: NEG
69925: PUSH
69926: LD_INT 2
69928: NEG
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 2
69936: NEG
69937: PUSH
69938: LD_INT 3
69940: NEG
69941: PUSH
69942: EMPTY
69943: LIST
69944: LIST
69945: PUSH
69946: LD_INT 1
69948: NEG
69949: PUSH
69950: LD_INT 3
69952: NEG
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 0
69960: PUSH
69961: LD_INT 3
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 1
69971: PUSH
69972: LD_INT 2
69974: NEG
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: LD_INT 3
69982: PUSH
69983: LD_INT 2
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 3
69992: PUSH
69993: LD_INT 3
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 2
70002: PUSH
70003: LD_INT 3
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: LD_INT 3
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 0
70022: PUSH
70023: LD_INT 3
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 1
70032: NEG
70033: PUSH
70034: LD_INT 2
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: LD_INT 3
70043: NEG
70044: PUSH
70045: LD_INT 2
70047: NEG
70048: PUSH
70049: EMPTY
70050: LIST
70051: LIST
70052: PUSH
70053: LD_INT 3
70055: NEG
70056: PUSH
70057: LD_INT 3
70059: NEG
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70096: LD_ADDR_VAR 0 43
70100: PUSH
70101: LD_INT 0
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 0
70113: PUSH
70114: LD_INT 1
70116: NEG
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 1
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 1
70134: PUSH
70135: LD_INT 1
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 0
70144: PUSH
70145: LD_INT 1
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 1
70154: NEG
70155: PUSH
70156: LD_INT 0
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: LD_INT 1
70169: NEG
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 1
70177: NEG
70178: PUSH
70179: LD_INT 2
70181: NEG
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 0
70189: PUSH
70190: LD_INT 2
70192: NEG
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 1
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 2
70211: PUSH
70212: LD_INT 0
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 2
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: LD_INT 1
70231: PUSH
70232: LD_INT 2
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 0
70241: PUSH
70242: LD_INT 2
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 1
70251: NEG
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 2
70262: NEG
70263: PUSH
70264: LD_INT 0
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: PUSH
70271: LD_INT 2
70273: NEG
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 1
70285: NEG
70286: PUSH
70287: LD_INT 3
70289: NEG
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: LD_INT 3
70300: NEG
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 1
70308: PUSH
70309: LD_INT 2
70311: NEG
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 2
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 3
70330: PUSH
70331: LD_INT 0
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: LD_INT 3
70340: PUSH
70341: LD_INT 1
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 1
70350: PUSH
70351: LD_INT 3
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PUSH
70358: LD_INT 0
70360: PUSH
70361: LD_INT 3
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PUSH
70368: LD_INT 1
70370: NEG
70371: PUSH
70372: LD_INT 2
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 2
70381: NEG
70382: PUSH
70383: LD_INT 1
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 3
70392: NEG
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 3
70403: NEG
70404: PUSH
70405: LD_INT 1
70407: NEG
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70444: LD_ADDR_VAR 0 44
70448: PUSH
70449: LD_INT 0
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 0
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 1
70472: PUSH
70473: LD_INT 0
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 1
70482: PUSH
70483: LD_INT 1
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 0
70492: PUSH
70493: LD_INT 1
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 1
70502: NEG
70503: PUSH
70504: LD_INT 0
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 1
70513: NEG
70514: PUSH
70515: LD_INT 1
70517: NEG
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 1
70525: NEG
70526: PUSH
70527: LD_INT 2
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 2
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 2
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 2
70568: PUSH
70569: LD_INT 2
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: PUSH
70579: LD_INT 2
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 1
70588: NEG
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 2
70599: NEG
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 2
70610: NEG
70611: PUSH
70612: LD_INT 1
70614: NEG
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 2
70622: NEG
70623: PUSH
70624: LD_INT 2
70626: NEG
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 2
70634: NEG
70635: PUSH
70636: LD_INT 3
70638: NEG
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 2
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 3
70657: PUSH
70658: LD_INT 0
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 3
70667: PUSH
70668: LD_INT 1
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 3
70677: PUSH
70678: LD_INT 2
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 3
70687: PUSH
70688: LD_INT 3
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: LD_INT 2
70697: PUSH
70698: LD_INT 3
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 2
70707: NEG
70708: PUSH
70709: LD_INT 1
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 3
70718: NEG
70719: PUSH
70720: LD_INT 0
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: LD_INT 3
70729: NEG
70730: PUSH
70731: LD_INT 1
70733: NEG
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 3
70741: NEG
70742: PUSH
70743: LD_INT 2
70745: NEG
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 3
70753: NEG
70754: PUSH
70755: LD_INT 3
70757: NEG
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70794: LD_ADDR_VAR 0 45
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: LD_INT 0
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 0
70811: PUSH
70812: LD_INT 1
70814: NEG
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: LD_INT 0
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: LD_INT 1
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 0
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 1
70852: NEG
70853: PUSH
70854: LD_INT 0
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 1
70863: NEG
70864: PUSH
70865: LD_INT 1
70867: NEG
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: LD_INT 2
70879: NEG
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: LD_INT 2
70890: NEG
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: LD_INT 1
70901: NEG
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 2
70909: PUSH
70910: LD_INT 1
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: PUSH
70920: LD_INT 2
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: LD_INT 2
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 1
70949: NEG
70950: PUSH
70951: LD_INT 1
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 2
70960: NEG
70961: PUSH
70962: LD_INT 1
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 2
70972: NEG
70973: PUSH
70974: LD_INT 2
70976: NEG
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 2
70984: NEG
70985: PUSH
70986: LD_INT 3
70988: NEG
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 1
70996: NEG
70997: PUSH
70998: LD_INT 3
71000: NEG
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 0
71008: PUSH
71009: LD_INT 3
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 1
71019: PUSH
71020: LD_INT 2
71022: NEG
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 3
71030: PUSH
71031: LD_INT 2
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 3
71040: PUSH
71041: LD_INT 3
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 2
71050: PUSH
71051: LD_INT 3
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: PUSH
71058: LD_INT 1
71060: PUSH
71061: LD_INT 3
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: LD_INT 3
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PUSH
71078: LD_INT 1
71080: NEG
71081: PUSH
71082: LD_INT 2
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 3
71091: NEG
71092: PUSH
71093: LD_INT 2
71095: NEG
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 3
71103: NEG
71104: PUSH
71105: LD_INT 3
71107: NEG
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: LIST
71117: LIST
71118: LIST
71119: LIST
71120: LIST
71121: LIST
71122: LIST
71123: LIST
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71144: LD_ADDR_VAR 0 46
71148: PUSH
71149: LD_INT 0
71151: PUSH
71152: LD_INT 0
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 0
71161: PUSH
71162: LD_INT 1
71164: NEG
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: PUSH
71173: LD_INT 0
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: LD_INT 1
71182: PUSH
71183: LD_INT 1
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 0
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 1
71202: NEG
71203: PUSH
71204: LD_INT 0
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 1
71213: NEG
71214: PUSH
71215: LD_INT 1
71217: NEG
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 1
71225: NEG
71226: PUSH
71227: LD_INT 2
71229: NEG
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 0
71237: PUSH
71238: LD_INT 2
71240: NEG
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 1
71248: PUSH
71249: LD_INT 1
71251: NEG
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 2
71259: PUSH
71260: LD_INT 0
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 2
71269: PUSH
71270: LD_INT 1
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 1
71279: PUSH
71280: LD_INT 2
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: LD_INT 0
71289: PUSH
71290: LD_INT 2
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 1
71299: NEG
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 2
71310: NEG
71311: PUSH
71312: LD_INT 0
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: PUSH
71319: LD_INT 2
71321: NEG
71322: PUSH
71323: LD_INT 1
71325: NEG
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: NEG
71334: PUSH
71335: LD_INT 3
71337: NEG
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 0
71345: PUSH
71346: LD_INT 3
71348: NEG
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 1
71356: PUSH
71357: LD_INT 2
71359: NEG
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 2
71367: PUSH
71368: LD_INT 1
71370: NEG
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 3
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 3
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 1
71398: PUSH
71399: LD_INT 3
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: LD_INT 3
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PUSH
71416: LD_INT 1
71418: NEG
71419: PUSH
71420: LD_INT 2
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 2
71429: NEG
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 3
71440: NEG
71441: PUSH
71442: LD_INT 0
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 3
71451: NEG
71452: PUSH
71453: LD_INT 1
71455: NEG
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: LIST
71465: LIST
71466: LIST
71467: LIST
71468: LIST
71469: LIST
71470: LIST
71471: LIST
71472: LIST
71473: LIST
71474: LIST
71475: LIST
71476: LIST
71477: LIST
71478: LIST
71479: LIST
71480: LIST
71481: LIST
71482: LIST
71483: LIST
71484: LIST
71485: LIST
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71492: LD_ADDR_VAR 0 47
71496: PUSH
71497: LD_INT 0
71499: PUSH
71500: LD_INT 0
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 0
71509: PUSH
71510: LD_INT 1
71512: NEG
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: PUSH
71521: LD_INT 0
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 1
71530: PUSH
71531: LD_INT 1
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 0
71540: PUSH
71541: LD_INT 1
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 1
71550: NEG
71551: PUSH
71552: LD_INT 0
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: LD_INT 1
71561: NEG
71562: PUSH
71563: LD_INT 1
71565: NEG
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: NEG
71574: PUSH
71575: LD_INT 2
71577: NEG
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 0
71585: PUSH
71586: LD_INT 2
71588: NEG
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: LD_INT 1
71599: NEG
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 2
71607: NEG
71608: PUSH
71609: LD_INT 1
71611: NEG
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 2
71619: NEG
71620: PUSH
71621: LD_INT 2
71623: NEG
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71643: LD_ADDR_VAR 0 48
71647: PUSH
71648: LD_INT 0
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 0
71660: PUSH
71661: LD_INT 1
71663: NEG
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 1
71681: PUSH
71682: LD_INT 1
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: LD_INT 1
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 1
71701: NEG
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: LD_INT 1
71716: NEG
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: NEG
71725: PUSH
71726: LD_INT 2
71728: NEG
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 0
71736: PUSH
71737: LD_INT 2
71739: NEG
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: PUSH
71748: LD_INT 1
71750: NEG
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 2
71758: PUSH
71759: LD_INT 0
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: PUSH
71766: LD_INT 2
71768: PUSH
71769: LD_INT 1
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71790: LD_ADDR_VAR 0 49
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 0
71807: PUSH
71808: LD_INT 1
71810: NEG
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 1
71818: PUSH
71819: LD_INT 0
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 1
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 0
71838: PUSH
71839: LD_INT 1
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 1
71848: NEG
71849: PUSH
71850: LD_INT 0
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: LD_INT 1
71863: NEG
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 1
71871: PUSH
71872: LD_INT 1
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 2
71882: PUSH
71883: LD_INT 0
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: LD_INT 2
71892: PUSH
71893: LD_INT 1
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 2
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PUSH
71910: LD_INT 1
71912: PUSH
71913: LD_INT 2
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: LIST
71930: LIST
71931: LIST
71932: LIST
71933: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71934: LD_ADDR_VAR 0 50
71938: PUSH
71939: LD_INT 0
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 0
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 1
71962: PUSH
71963: LD_INT 0
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: LD_INT 1
71972: PUSH
71973: LD_INT 1
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 0
71982: PUSH
71983: LD_INT 1
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: LD_INT 1
71992: NEG
71993: PUSH
71994: LD_INT 0
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 1
72003: NEG
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 2
72015: PUSH
72016: LD_INT 1
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 2
72025: PUSH
72026: LD_INT 2
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 1
72035: PUSH
72036: LD_INT 2
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 0
72045: PUSH
72046: LD_INT 2
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 1
72055: NEG
72056: PUSH
72057: LD_INT 1
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72078: LD_ADDR_VAR 0 51
72082: PUSH
72083: LD_INT 0
72085: PUSH
72086: LD_INT 0
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: LD_INT 0
72095: PUSH
72096: LD_INT 1
72098: NEG
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: LD_INT 1
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: PUSH
72124: LD_INT 0
72126: PUSH
72127: LD_INT 1
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 1
72136: NEG
72137: PUSH
72138: LD_INT 0
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 1
72147: NEG
72148: PUSH
72149: LD_INT 1
72151: NEG
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 1
72159: PUSH
72160: LD_INT 2
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: LD_INT 2
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 1
72179: NEG
72180: PUSH
72181: LD_INT 1
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 2
72190: NEG
72191: PUSH
72192: LD_INT 0
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 2
72201: NEG
72202: PUSH
72203: LD_INT 1
72205: NEG
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: LIST
72223: LIST
72224: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72225: LD_ADDR_VAR 0 52
72229: PUSH
72230: LD_INT 0
72232: PUSH
72233: LD_INT 0
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 0
72242: PUSH
72243: LD_INT 1
72245: NEG
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 1
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 1
72263: PUSH
72264: LD_INT 1
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 0
72273: PUSH
72274: LD_INT 1
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: NEG
72284: PUSH
72285: LD_INT 0
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 1
72294: NEG
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 1
72306: NEG
72307: PUSH
72308: LD_INT 2
72310: NEG
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 1
72318: NEG
72319: PUSH
72320: LD_INT 1
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 2
72329: NEG
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 2
72340: NEG
72341: PUSH
72342: LD_INT 1
72344: NEG
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 2
72352: NEG
72353: PUSH
72354: LD_INT 2
72356: NEG
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72376: LD_ADDR_VAR 0 53
72380: PUSH
72381: LD_INT 0
72383: PUSH
72384: LD_INT 0
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 0
72393: PUSH
72394: LD_INT 1
72396: NEG
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: LD_INT 1
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 0
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 1
72434: NEG
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 1
72445: NEG
72446: PUSH
72447: LD_INT 1
72449: NEG
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 1
72457: NEG
72458: PUSH
72459: LD_INT 2
72461: NEG
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 0
72469: PUSH
72470: LD_INT 2
72472: NEG
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 1
72480: PUSH
72481: LD_INT 1
72483: NEG
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 2
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: PUSH
72499: LD_INT 2
72501: PUSH
72502: LD_INT 1
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 2
72511: PUSH
72512: LD_INT 2
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: PUSH
72522: LD_INT 2
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: LD_INT 2
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 1
72541: NEG
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 2
72552: NEG
72553: PUSH
72554: LD_INT 0
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 2
72563: NEG
72564: PUSH
72565: LD_INT 1
72567: NEG
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 2
72575: NEG
72576: PUSH
72577: LD_INT 2
72579: NEG
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: LIST
72600: LIST
72601: LIST
72602: LIST
72603: LIST
72604: LIST
72605: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72606: LD_ADDR_VAR 0 54
72610: PUSH
72611: LD_INT 0
72613: PUSH
72614: LD_INT 0
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 0
72623: PUSH
72624: LD_INT 1
72626: NEG
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 1
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 1
72644: PUSH
72645: LD_INT 1
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 0
72654: PUSH
72655: LD_INT 1
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 1
72664: NEG
72665: PUSH
72666: LD_INT 0
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 1
72675: NEG
72676: PUSH
72677: LD_INT 1
72679: NEG
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: LD_INT 2
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 0
72699: PUSH
72700: LD_INT 2
72702: NEG
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 1
72710: PUSH
72711: LD_INT 1
72713: NEG
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 2
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 2
72731: PUSH
72732: LD_INT 1
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 2
72741: PUSH
72742: LD_INT 2
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: PUSH
72752: LD_INT 2
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 0
72761: PUSH
72762: LD_INT 2
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 1
72771: NEG
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 2
72782: NEG
72783: PUSH
72784: LD_INT 0
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 2
72793: NEG
72794: PUSH
72795: LD_INT 1
72797: NEG
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: LD_INT 2
72809: NEG
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72836: LD_ADDR_VAR 0 55
72840: PUSH
72841: LD_INT 0
72843: PUSH
72844: LD_INT 0
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 0
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 1
72864: PUSH
72865: LD_INT 0
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 1
72874: PUSH
72875: LD_INT 1
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 0
72884: PUSH
72885: LD_INT 1
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 1
72894: NEG
72895: PUSH
72896: LD_INT 0
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: NEG
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: LD_INT 2
72921: NEG
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: LD_INT 2
72932: NEG
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 1
72940: PUSH
72941: LD_INT 1
72943: NEG
72944: PUSH
72945: EMPTY
72946: LIST
72947: LIST
72948: PUSH
72949: LD_INT 2
72951: PUSH
72952: LD_INT 0
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 2
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 2
72971: PUSH
72972: LD_INT 2
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 1
72981: PUSH
72982: LD_INT 2
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 0
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 1
73001: NEG
73002: PUSH
73003: LD_INT 1
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 2
73012: NEG
73013: PUSH
73014: LD_INT 0
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 2
73023: NEG
73024: PUSH
73025: LD_INT 1
73027: NEG
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 2
73035: NEG
73036: PUSH
73037: LD_INT 2
73039: NEG
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: LIST
73049: LIST
73050: LIST
73051: LIST
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73066: LD_ADDR_VAR 0 56
73070: PUSH
73071: LD_INT 0
73073: PUSH
73074: LD_INT 0
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: LD_INT 1
73086: NEG
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: LD_INT 0
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 1
73104: PUSH
73105: LD_INT 1
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 0
73114: PUSH
73115: LD_INT 1
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 1
73124: NEG
73125: PUSH
73126: LD_INT 0
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 1
73135: NEG
73136: PUSH
73137: LD_INT 1
73139: NEG
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 1
73147: NEG
73148: PUSH
73149: LD_INT 2
73151: NEG
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: LD_INT 2
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: PUSH
73171: LD_INT 1
73173: NEG
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 2
73181: PUSH
73182: LD_INT 0
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 2
73191: PUSH
73192: LD_INT 1
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: LD_INT 2
73201: PUSH
73202: LD_INT 2
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: PUSH
73212: LD_INT 2
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: LD_INT 0
73221: PUSH
73222: LD_INT 2
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 1
73231: NEG
73232: PUSH
73233: LD_INT 1
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 2
73242: NEG
73243: PUSH
73244: LD_INT 0
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 2
73253: NEG
73254: PUSH
73255: LD_INT 1
73257: NEG
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 2
73265: NEG
73266: PUSH
73267: LD_INT 2
73269: NEG
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73296: LD_ADDR_VAR 0 57
73300: PUSH
73301: LD_INT 0
73303: PUSH
73304: LD_INT 0
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 0
73313: PUSH
73314: LD_INT 1
73316: NEG
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 1
73324: PUSH
73325: LD_INT 0
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 1
73334: PUSH
73335: LD_INT 1
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 0
73344: PUSH
73345: LD_INT 1
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 1
73354: NEG
73355: PUSH
73356: LD_INT 0
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: PUSH
73363: LD_INT 1
73365: NEG
73366: PUSH
73367: LD_INT 1
73369: NEG
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: LD_INT 2
73381: NEG
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: LD_INT 2
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 1
73400: PUSH
73401: LD_INT 1
73403: NEG
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 2
73411: PUSH
73412: LD_INT 0
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 2
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 2
73431: PUSH
73432: LD_INT 2
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 1
73441: PUSH
73442: LD_INT 2
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 0
73451: PUSH
73452: LD_INT 2
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: LD_INT 1
73461: NEG
73462: PUSH
73463: LD_INT 1
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 2
73472: NEG
73473: PUSH
73474: LD_INT 0
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 2
73483: NEG
73484: PUSH
73485: LD_INT 1
73487: NEG
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 2
73495: NEG
73496: PUSH
73497: LD_INT 2
73499: NEG
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73526: LD_ADDR_VAR 0 58
73530: PUSH
73531: LD_INT 0
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: LD_INT 1
73546: NEG
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: LD_INT 0
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: LD_INT 1
73564: PUSH
73565: LD_INT 1
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: LD_INT 1
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 1
73584: NEG
73585: PUSH
73586: LD_INT 0
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: LD_INT 1
73599: NEG
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: LD_INT 2
73611: NEG
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 0
73619: PUSH
73620: LD_INT 2
73622: NEG
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 1
73630: PUSH
73631: LD_INT 1
73633: NEG
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 2
73641: PUSH
73642: LD_INT 0
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 2
73651: PUSH
73652: LD_INT 1
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 2
73661: PUSH
73662: LD_INT 2
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: LD_INT 2
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 0
73681: PUSH
73682: LD_INT 2
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 1
73691: NEG
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 2
73702: NEG
73703: PUSH
73704: LD_INT 0
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: PUSH
73711: LD_INT 2
73713: NEG
73714: PUSH
73715: LD_INT 1
73717: NEG
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 2
73725: NEG
73726: PUSH
73727: LD_INT 2
73729: NEG
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73756: LD_ADDR_VAR 0 59
73760: PUSH
73761: LD_INT 0
73763: PUSH
73764: LD_INT 0
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 0
73773: PUSH
73774: LD_INT 1
73776: NEG
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 1
73784: PUSH
73785: LD_INT 0
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 1
73794: PUSH
73795: LD_INT 1
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: LD_INT 1
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 1
73814: NEG
73815: PUSH
73816: LD_INT 0
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 1
73825: NEG
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73844: LD_ADDR_VAR 0 60
73848: PUSH
73849: LD_INT 0
73851: PUSH
73852: LD_INT 0
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: LD_INT 1
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: LD_INT 0
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: LD_INT 1
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 0
73892: PUSH
73893: LD_INT 1
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 1
73902: NEG
73903: PUSH
73904: LD_INT 0
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 1
73913: NEG
73914: PUSH
73915: LD_INT 1
73917: NEG
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73932: LD_ADDR_VAR 0 61
73936: PUSH
73937: LD_INT 0
73939: PUSH
73940: LD_INT 0
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: LD_INT 1
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 1
73970: PUSH
73971: LD_INT 1
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 0
73980: PUSH
73981: LD_INT 1
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 1
73990: NEG
73991: PUSH
73992: LD_INT 0
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 1
74001: NEG
74002: PUSH
74003: LD_INT 1
74005: NEG
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: LIST
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74020: LD_ADDR_VAR 0 62
74024: PUSH
74025: LD_INT 0
74027: PUSH
74028: LD_INT 0
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 0
74037: PUSH
74038: LD_INT 1
74040: NEG
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 1
74048: PUSH
74049: LD_INT 0
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 1
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 0
74068: PUSH
74069: LD_INT 1
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: NEG
74079: PUSH
74080: LD_INT 0
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: PUSH
74087: LD_INT 1
74089: NEG
74090: PUSH
74091: LD_INT 1
74093: NEG
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: LIST
74103: LIST
74104: LIST
74105: LIST
74106: LIST
74107: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74108: LD_ADDR_VAR 0 63
74112: PUSH
74113: LD_INT 0
74115: PUSH
74116: LD_INT 0
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 1
74136: PUSH
74137: LD_INT 0
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 1
74146: PUSH
74147: LD_INT 1
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 0
74156: PUSH
74157: LD_INT 1
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: PUSH
74164: LD_INT 1
74166: NEG
74167: PUSH
74168: LD_INT 0
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 1
74177: NEG
74178: PUSH
74179: LD_INT 1
74181: NEG
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74196: LD_ADDR_VAR 0 64
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: EMPTY
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: ST_TO_ADDR
// end ; 1 :
74284: GO 80181
74286: LD_INT 1
74288: DOUBLE
74289: EQUAL
74290: IFTRUE 74294
74292: GO 76917
74294: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74295: LD_ADDR_VAR 0 11
74299: PUSH
74300: LD_INT 1
74302: NEG
74303: PUSH
74304: LD_INT 3
74306: NEG
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 0
74314: PUSH
74315: LD_INT 3
74317: NEG
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: LD_INT 1
74325: PUSH
74326: LD_INT 2
74328: NEG
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: LIST
74338: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74339: LD_ADDR_VAR 0 12
74343: PUSH
74344: LD_INT 2
74346: PUSH
74347: LD_INT 1
74349: NEG
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 3
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 3
74367: PUSH
74368: LD_INT 1
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: LIST
74379: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74380: LD_ADDR_VAR 0 13
74384: PUSH
74385: LD_INT 3
74387: PUSH
74388: LD_INT 2
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 3
74397: PUSH
74398: LD_INT 3
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 2
74407: PUSH
74408: LD_INT 3
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74420: LD_ADDR_VAR 0 14
74424: PUSH
74425: LD_INT 1
74427: PUSH
74428: LD_INT 3
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: LD_INT 3
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 1
74447: NEG
74448: PUSH
74449: LD_INT 2
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: LIST
74460: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74461: LD_ADDR_VAR 0 15
74465: PUSH
74466: LD_INT 2
74468: NEG
74469: PUSH
74470: LD_INT 1
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 3
74479: NEG
74480: PUSH
74481: LD_INT 0
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 3
74490: NEG
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74505: LD_ADDR_VAR 0 16
74509: PUSH
74510: LD_INT 2
74512: NEG
74513: PUSH
74514: LD_INT 3
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 3
74524: NEG
74525: PUSH
74526: LD_INT 2
74528: NEG
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 3
74536: NEG
74537: PUSH
74538: LD_INT 3
74540: NEG
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: LIST
74550: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74551: LD_ADDR_VAR 0 17
74555: PUSH
74556: LD_INT 1
74558: NEG
74559: PUSH
74560: LD_INT 3
74562: NEG
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 0
74570: PUSH
74571: LD_INT 3
74573: NEG
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 1
74581: PUSH
74582: LD_INT 2
74584: NEG
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: LIST
74594: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74595: LD_ADDR_VAR 0 18
74599: PUSH
74600: LD_INT 2
74602: PUSH
74603: LD_INT 1
74605: NEG
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 3
74613: PUSH
74614: LD_INT 0
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 3
74623: PUSH
74624: LD_INT 1
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: LIST
74635: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74636: LD_ADDR_VAR 0 19
74640: PUSH
74641: LD_INT 3
74643: PUSH
74644: LD_INT 2
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 3
74653: PUSH
74654: LD_INT 3
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 2
74663: PUSH
74664: LD_INT 3
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: LIST
74675: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74676: LD_ADDR_VAR 0 20
74680: PUSH
74681: LD_INT 1
74683: PUSH
74684: LD_INT 3
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: PUSH
74691: LD_INT 0
74693: PUSH
74694: LD_INT 3
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 1
74703: NEG
74704: PUSH
74705: LD_INT 2
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: LIST
74716: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74717: LD_ADDR_VAR 0 21
74721: PUSH
74722: LD_INT 2
74724: NEG
74725: PUSH
74726: LD_INT 1
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 3
74735: NEG
74736: PUSH
74737: LD_INT 0
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: PUSH
74744: LD_INT 3
74746: NEG
74747: PUSH
74748: LD_INT 1
74750: NEG
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: LIST
74760: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74761: LD_ADDR_VAR 0 22
74765: PUSH
74766: LD_INT 2
74768: NEG
74769: PUSH
74770: LD_INT 3
74772: NEG
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: PUSH
74778: LD_INT 3
74780: NEG
74781: PUSH
74782: LD_INT 2
74784: NEG
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 3
74792: NEG
74793: PUSH
74794: LD_INT 3
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: LIST
74806: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74807: LD_ADDR_VAR 0 23
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: LD_INT 3
74817: NEG
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 1
74825: NEG
74826: PUSH
74827: LD_INT 4
74829: NEG
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: LD_INT 3
74840: NEG
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: LIST
74850: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74851: LD_ADDR_VAR 0 24
74855: PUSH
74856: LD_INT 3
74858: PUSH
74859: LD_INT 0
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: LD_INT 3
74868: PUSH
74869: LD_INT 1
74871: NEG
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 4
74879: PUSH
74880: LD_INT 1
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: LIST
74891: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74892: LD_ADDR_VAR 0 25
74896: PUSH
74897: LD_INT 3
74899: PUSH
74900: LD_INT 3
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 4
74909: PUSH
74910: LD_INT 3
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 3
74919: PUSH
74920: LD_INT 4
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: LIST
74931: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74932: LD_ADDR_VAR 0 26
74936: PUSH
74937: LD_INT 0
74939: PUSH
74940: LD_INT 3
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 1
74949: PUSH
74950: LD_INT 4
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 1
74959: NEG
74960: PUSH
74961: LD_INT 3
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: LIST
74972: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74973: LD_ADDR_VAR 0 27
74977: PUSH
74978: LD_INT 3
74980: NEG
74981: PUSH
74982: LD_INT 0
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 3
74991: NEG
74992: PUSH
74993: LD_INT 1
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 4
75002: NEG
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: LIST
75016: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75017: LD_ADDR_VAR 0 28
75021: PUSH
75022: LD_INT 3
75024: NEG
75025: PUSH
75026: LD_INT 3
75028: NEG
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: LD_INT 3
75036: NEG
75037: PUSH
75038: LD_INT 4
75040: NEG
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 4
75048: NEG
75049: PUSH
75050: LD_INT 3
75052: NEG
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: LIST
75062: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75063: LD_ADDR_VAR 0 29
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: LD_INT 3
75074: NEG
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 0
75082: PUSH
75083: LD_INT 3
75085: NEG
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 1
75093: PUSH
75094: LD_INT 2
75096: NEG
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: LD_INT 1
75104: NEG
75105: PUSH
75106: LD_INT 4
75108: NEG
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 0
75116: PUSH
75117: LD_INT 4
75119: NEG
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 1
75127: PUSH
75128: LD_INT 3
75130: NEG
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: LD_INT 5
75142: NEG
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: LD_INT 5
75153: NEG
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 1
75161: PUSH
75162: LD_INT 4
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: NEG
75173: PUSH
75174: LD_INT 6
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 0
75184: PUSH
75185: LD_INT 6
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: LD_INT 5
75198: NEG
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: LIST
75217: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75218: LD_ADDR_VAR 0 30
75222: PUSH
75223: LD_INT 2
75225: PUSH
75226: LD_INT 1
75228: NEG
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 3
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 3
75246: PUSH
75247: LD_INT 1
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 3
75256: PUSH
75257: LD_INT 1
75259: NEG
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 4
75267: PUSH
75268: LD_INT 0
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 4
75277: PUSH
75278: LD_INT 1
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 4
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 5
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 5
75308: PUSH
75309: LD_INT 1
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 5
75318: PUSH
75319: LD_INT 1
75321: NEG
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: LD_INT 6
75329: PUSH
75330: LD_INT 0
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 6
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75361: LD_ADDR_VAR 0 31
75365: PUSH
75366: LD_INT 3
75368: PUSH
75369: LD_INT 2
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 3
75378: PUSH
75379: LD_INT 3
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 2
75388: PUSH
75389: LD_INT 3
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 4
75398: PUSH
75399: LD_INT 3
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 4
75408: PUSH
75409: LD_INT 4
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: LD_INT 3
75418: PUSH
75419: LD_INT 4
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 5
75428: PUSH
75429: LD_INT 4
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: LD_INT 5
75438: PUSH
75439: LD_INT 5
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 4
75448: PUSH
75449: LD_INT 5
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PUSH
75456: LD_INT 6
75458: PUSH
75459: LD_INT 5
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 6
75468: PUSH
75469: LD_INT 6
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 5
75478: PUSH
75479: LD_INT 6
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75500: LD_ADDR_VAR 0 32
75504: PUSH
75505: LD_INT 1
75507: PUSH
75508: LD_INT 3
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 0
75517: PUSH
75518: LD_INT 3
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 1
75527: NEG
75528: PUSH
75529: LD_INT 2
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: PUSH
75536: LD_INT 1
75538: PUSH
75539: LD_INT 4
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 0
75548: PUSH
75549: LD_INT 4
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: LD_INT 1
75558: NEG
75559: PUSH
75560: LD_INT 3
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 1
75569: PUSH
75570: LD_INT 5
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 0
75579: PUSH
75580: LD_INT 5
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 1
75589: NEG
75590: PUSH
75591: LD_INT 4
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: LD_INT 6
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: LD_INT 6
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: NEG
75621: PUSH
75622: LD_INT 5
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: LIST
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: LIST
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75643: LD_ADDR_VAR 0 33
75647: PUSH
75648: LD_INT 2
75650: NEG
75651: PUSH
75652: LD_INT 1
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 3
75661: NEG
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 3
75672: NEG
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 3
75684: NEG
75685: PUSH
75686: LD_INT 1
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 4
75695: NEG
75696: PUSH
75697: LD_INT 0
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 4
75706: NEG
75707: PUSH
75708: LD_INT 1
75710: NEG
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 4
75718: NEG
75719: PUSH
75720: LD_INT 1
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 5
75729: NEG
75730: PUSH
75731: LD_INT 0
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 5
75740: NEG
75741: PUSH
75742: LD_INT 1
75744: NEG
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 5
75752: NEG
75753: PUSH
75754: LD_INT 1
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 6
75763: NEG
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 6
75774: NEG
75775: PUSH
75776: LD_INT 1
75778: NEG
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75798: LD_ADDR_VAR 0 34
75802: PUSH
75803: LD_INT 2
75805: NEG
75806: PUSH
75807: LD_INT 3
75809: NEG
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 3
75817: NEG
75818: PUSH
75819: LD_INT 2
75821: NEG
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 3
75829: NEG
75830: PUSH
75831: LD_INT 3
75833: NEG
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 3
75841: NEG
75842: PUSH
75843: LD_INT 4
75845: NEG
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 4
75853: NEG
75854: PUSH
75855: LD_INT 3
75857: NEG
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 4
75865: NEG
75866: PUSH
75867: LD_INT 4
75869: NEG
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 4
75877: NEG
75878: PUSH
75879: LD_INT 5
75881: NEG
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 5
75889: NEG
75890: PUSH
75891: LD_INT 4
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 5
75901: NEG
75902: PUSH
75903: LD_INT 5
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 5
75913: NEG
75914: PUSH
75915: LD_INT 6
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 6
75925: NEG
75926: PUSH
75927: LD_INT 5
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 6
75937: NEG
75938: PUSH
75939: LD_INT 6
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: LIST
75951: LIST
75952: LIST
75953: LIST
75954: LIST
75955: LIST
75956: LIST
75957: LIST
75958: LIST
75959: LIST
75960: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75961: LD_ADDR_VAR 0 41
75965: PUSH
75966: LD_INT 0
75968: PUSH
75969: LD_INT 2
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 1
75979: NEG
75980: PUSH
75981: LD_INT 3
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 1
75991: PUSH
75992: LD_INT 2
75994: NEG
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: LIST
76004: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76005: LD_ADDR_VAR 0 42
76009: PUSH
76010: LD_INT 2
76012: PUSH
76013: LD_INT 0
76015: PUSH
76016: EMPTY
76017: LIST
76018: LIST
76019: PUSH
76020: LD_INT 2
76022: PUSH
76023: LD_INT 1
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 3
76033: PUSH
76034: LD_INT 1
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: LIST
76045: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76046: LD_ADDR_VAR 0 43
76050: PUSH
76051: LD_INT 2
76053: PUSH
76054: LD_INT 2
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 3
76063: PUSH
76064: LD_INT 2
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: PUSH
76071: LD_INT 2
76073: PUSH
76074: LD_INT 3
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: LIST
76085: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76086: LD_ADDR_VAR 0 44
76090: PUSH
76091: LD_INT 0
76093: PUSH
76094: LD_INT 2
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 1
76103: PUSH
76104: LD_INT 3
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 1
76113: NEG
76114: PUSH
76115: LD_INT 2
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: LIST
76126: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76127: LD_ADDR_VAR 0 45
76131: PUSH
76132: LD_INT 2
76134: NEG
76135: PUSH
76136: LD_INT 0
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 2
76145: NEG
76146: PUSH
76147: LD_INT 1
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 3
76156: NEG
76157: PUSH
76158: LD_INT 1
76160: NEG
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: LIST
76170: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76171: LD_ADDR_VAR 0 46
76175: PUSH
76176: LD_INT 2
76178: NEG
76179: PUSH
76180: LD_INT 2
76182: NEG
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 2
76190: NEG
76191: PUSH
76192: LD_INT 3
76194: NEG
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 3
76202: NEG
76203: PUSH
76204: LD_INT 2
76206: NEG
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: LIST
76216: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76217: LD_ADDR_VAR 0 47
76221: PUSH
76222: LD_INT 2
76224: NEG
76225: PUSH
76226: LD_INT 3
76228: NEG
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 1
76236: NEG
76237: PUSH
76238: LD_INT 3
76240: NEG
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76250: LD_ADDR_VAR 0 48
76254: PUSH
76255: LD_INT 1
76257: PUSH
76258: LD_INT 2
76260: NEG
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 2
76268: PUSH
76269: LD_INT 1
76271: NEG
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: EMPTY
76278: LIST
76279: LIST
76280: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76281: LD_ADDR_VAR 0 49
76285: PUSH
76286: LD_INT 3
76288: PUSH
76289: LD_INT 1
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 3
76298: PUSH
76299: LD_INT 2
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76310: LD_ADDR_VAR 0 50
76314: PUSH
76315: LD_INT 2
76317: PUSH
76318: LD_INT 3
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 1
76327: PUSH
76328: LD_INT 3
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76339: LD_ADDR_VAR 0 51
76343: PUSH
76344: LD_INT 1
76346: NEG
76347: PUSH
76348: LD_INT 2
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 2
76357: NEG
76358: PUSH
76359: LD_INT 1
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76370: LD_ADDR_VAR 0 52
76374: PUSH
76375: LD_INT 3
76377: NEG
76378: PUSH
76379: LD_INT 1
76381: NEG
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 3
76389: NEG
76390: PUSH
76391: LD_INT 2
76393: NEG
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76403: LD_ADDR_VAR 0 53
76407: PUSH
76408: LD_INT 1
76410: NEG
76411: PUSH
76412: LD_INT 3
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 0
76422: PUSH
76423: LD_INT 3
76425: NEG
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 1
76433: PUSH
76434: LD_INT 2
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: LIST
76446: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76447: LD_ADDR_VAR 0 54
76451: PUSH
76452: LD_INT 2
76454: PUSH
76455: LD_INT 1
76457: NEG
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 3
76465: PUSH
76466: LD_INT 0
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 3
76475: PUSH
76476: LD_INT 1
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: LIST
76487: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76488: LD_ADDR_VAR 0 55
76492: PUSH
76493: LD_INT 3
76495: PUSH
76496: LD_INT 2
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 3
76505: PUSH
76506: LD_INT 3
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 2
76515: PUSH
76516: LD_INT 3
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: LIST
76527: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76528: LD_ADDR_VAR 0 56
76532: PUSH
76533: LD_INT 1
76535: PUSH
76536: LD_INT 3
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 0
76545: PUSH
76546: LD_INT 3
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 1
76555: NEG
76556: PUSH
76557: LD_INT 2
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: LIST
76568: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76569: LD_ADDR_VAR 0 57
76573: PUSH
76574: LD_INT 2
76576: NEG
76577: PUSH
76578: LD_INT 1
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 3
76587: NEG
76588: PUSH
76589: LD_INT 0
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 3
76598: NEG
76599: PUSH
76600: LD_INT 1
76602: NEG
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: LIST
76612: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76613: LD_ADDR_VAR 0 58
76617: PUSH
76618: LD_INT 2
76620: NEG
76621: PUSH
76622: LD_INT 3
76624: NEG
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 3
76632: NEG
76633: PUSH
76634: LD_INT 2
76636: NEG
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 3
76644: NEG
76645: PUSH
76646: LD_INT 3
76648: NEG
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: LIST
76658: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76659: LD_ADDR_VAR 0 59
76663: PUSH
76664: LD_INT 1
76666: NEG
76667: PUSH
76668: LD_INT 2
76670: NEG
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 0
76678: PUSH
76679: LD_INT 2
76681: NEG
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 1
76689: PUSH
76690: LD_INT 1
76692: NEG
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: LIST
76702: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76703: LD_ADDR_VAR 0 60
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: LD_INT 1
76713: NEG
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 2
76721: PUSH
76722: LD_INT 0
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 2
76731: PUSH
76732: LD_INT 1
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: LIST
76743: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76744: LD_ADDR_VAR 0 61
76748: PUSH
76749: LD_INT 2
76751: PUSH
76752: LD_INT 1
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: PUSH
76759: LD_INT 2
76761: PUSH
76762: LD_INT 2
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 1
76771: PUSH
76772: LD_INT 2
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: LIST
76783: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76784: LD_ADDR_VAR 0 62
76788: PUSH
76789: LD_INT 1
76791: PUSH
76792: LD_INT 2
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: LD_INT 0
76801: PUSH
76802: LD_INT 2
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 1
76811: NEG
76812: PUSH
76813: LD_INT 1
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: LIST
76824: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76825: LD_ADDR_VAR 0 63
76829: PUSH
76830: LD_INT 1
76832: NEG
76833: PUSH
76834: LD_INT 1
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 2
76843: NEG
76844: PUSH
76845: LD_INT 0
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 2
76854: NEG
76855: PUSH
76856: LD_INT 1
76858: NEG
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: LIST
76868: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76869: LD_ADDR_VAR 0 64
76873: PUSH
76874: LD_INT 1
76876: NEG
76877: PUSH
76878: LD_INT 2
76880: NEG
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PUSH
76886: LD_INT 2
76888: NEG
76889: PUSH
76890: LD_INT 1
76892: NEG
76893: PUSH
76894: EMPTY
76895: LIST
76896: LIST
76897: PUSH
76898: LD_INT 2
76900: NEG
76901: PUSH
76902: LD_INT 2
76904: NEG
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: LIST
76914: ST_TO_ADDR
// end ; 2 :
76915: GO 80181
76917: LD_INT 2
76919: DOUBLE
76920: EQUAL
76921: IFTRUE 76925
76923: GO 80180
76925: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76926: LD_ADDR_VAR 0 29
76930: PUSH
76931: LD_INT 4
76933: PUSH
76934: LD_INT 0
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 4
76943: PUSH
76944: LD_INT 1
76946: NEG
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 5
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 5
76964: PUSH
76965: LD_INT 1
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 4
76974: PUSH
76975: LD_INT 1
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 3
76984: PUSH
76985: LD_INT 0
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 3
76994: PUSH
76995: LD_INT 1
76997: NEG
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 3
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 5
77016: PUSH
77017: LD_INT 2
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 3
77026: PUSH
77027: LD_INT 3
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 3
77036: PUSH
77037: LD_INT 2
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 4
77046: PUSH
77047: LD_INT 3
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 4
77056: PUSH
77057: LD_INT 4
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: LD_INT 3
77066: PUSH
77067: LD_INT 4
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: PUSH
77074: LD_INT 2
77076: PUSH
77077: LD_INT 3
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 2
77086: PUSH
77087: LD_INT 2
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 4
77096: PUSH
77097: LD_INT 2
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PUSH
77104: LD_INT 2
77106: PUSH
77107: LD_INT 4
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 0
77116: PUSH
77117: LD_INT 4
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: LD_INT 0
77126: PUSH
77127: LD_INT 3
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 1
77136: PUSH
77137: LD_INT 4
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 1
77146: PUSH
77147: LD_INT 5
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: LD_INT 0
77156: PUSH
77157: LD_INT 5
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: PUSH
77164: LD_INT 1
77166: NEG
77167: PUSH
77168: LD_INT 4
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 1
77177: NEG
77178: PUSH
77179: LD_INT 3
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: LD_INT 2
77188: PUSH
77189: LD_INT 5
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: LD_INT 2
77198: NEG
77199: PUSH
77200: LD_INT 3
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 3
77209: NEG
77210: PUSH
77211: LD_INT 0
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 3
77220: NEG
77221: PUSH
77222: LD_INT 1
77224: NEG
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 2
77232: NEG
77233: PUSH
77234: LD_INT 0
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 2
77243: NEG
77244: PUSH
77245: LD_INT 1
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 3
77254: NEG
77255: PUSH
77256: LD_INT 1
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 4
77265: NEG
77266: PUSH
77267: LD_INT 0
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 4
77276: NEG
77277: PUSH
77278: LD_INT 1
77280: NEG
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 4
77288: NEG
77289: PUSH
77290: LD_INT 2
77292: NEG
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 2
77300: NEG
77301: PUSH
77302: LD_INT 2
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 4
77311: NEG
77312: PUSH
77313: LD_INT 4
77315: NEG
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 4
77323: NEG
77324: PUSH
77325: LD_INT 5
77327: NEG
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: LD_INT 3
77335: NEG
77336: PUSH
77337: LD_INT 4
77339: NEG
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 3
77347: NEG
77348: PUSH
77349: LD_INT 3
77351: NEG
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 4
77359: NEG
77360: PUSH
77361: LD_INT 3
77363: NEG
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 5
77371: NEG
77372: PUSH
77373: LD_INT 4
77375: NEG
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: LD_INT 5
77383: NEG
77384: PUSH
77385: LD_INT 5
77387: NEG
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 3
77395: NEG
77396: PUSH
77397: LD_INT 5
77399: NEG
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 5
77407: NEG
77408: PUSH
77409: LD_INT 3
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: LIST
77422: LIST
77423: LIST
77424: LIST
77425: LIST
77426: LIST
77427: LIST
77428: LIST
77429: LIST
77430: LIST
77431: LIST
77432: LIST
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: LIST
77443: LIST
77444: LIST
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77464: LD_ADDR_VAR 0 30
77468: PUSH
77469: LD_INT 4
77471: PUSH
77472: LD_INT 4
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 4
77481: PUSH
77482: LD_INT 3
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 5
77491: PUSH
77492: LD_INT 4
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 5
77501: PUSH
77502: LD_INT 5
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 4
77511: PUSH
77512: LD_INT 5
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 3
77521: PUSH
77522: LD_INT 4
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 3
77531: PUSH
77532: LD_INT 3
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 5
77541: PUSH
77542: LD_INT 3
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 3
77551: PUSH
77552: LD_INT 5
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 0
77561: PUSH
77562: LD_INT 3
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 0
77571: PUSH
77572: LD_INT 2
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 1
77581: PUSH
77582: LD_INT 3
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: LD_INT 1
77591: PUSH
77592: LD_INT 4
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: LD_INT 4
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 1
77611: NEG
77612: PUSH
77613: LD_INT 3
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 1
77622: NEG
77623: PUSH
77624: LD_INT 2
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 2
77633: PUSH
77634: LD_INT 4
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 2
77643: NEG
77644: PUSH
77645: LD_INT 2
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 4
77654: NEG
77655: PUSH
77656: LD_INT 0
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 4
77665: NEG
77666: PUSH
77667: LD_INT 1
77669: NEG
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 3
77677: NEG
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 3
77688: NEG
77689: PUSH
77690: LD_INT 1
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 4
77699: NEG
77700: PUSH
77701: LD_INT 1
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 5
77710: NEG
77711: PUSH
77712: LD_INT 0
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 5
77721: NEG
77722: PUSH
77723: LD_INT 1
77725: NEG
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 5
77733: NEG
77734: PUSH
77735: LD_INT 2
77737: NEG
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 3
77745: NEG
77746: PUSH
77747: LD_INT 2
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 3
77756: NEG
77757: PUSH
77758: LD_INT 3
77760: NEG
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 3
77768: NEG
77769: PUSH
77770: LD_INT 4
77772: NEG
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 2
77780: NEG
77781: PUSH
77782: LD_INT 3
77784: NEG
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 2
77792: NEG
77793: PUSH
77794: LD_INT 2
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 3
77804: NEG
77805: PUSH
77806: LD_INT 2
77808: NEG
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: PUSH
77814: LD_INT 4
77816: NEG
77817: PUSH
77818: LD_INT 3
77820: NEG
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 4
77828: NEG
77829: PUSH
77830: LD_INT 4
77832: NEG
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 2
77840: NEG
77841: PUSH
77842: LD_INT 4
77844: NEG
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 4
77852: NEG
77853: PUSH
77854: LD_INT 2
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 0
77864: PUSH
77865: LD_INT 4
77867: NEG
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 0
77875: PUSH
77876: LD_INT 5
77878: NEG
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: LD_INT 4
77889: NEG
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 1
77897: PUSH
77898: LD_INT 3
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: LD_INT 3
77911: NEG
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 1
77919: NEG
77920: PUSH
77921: LD_INT 4
77923: NEG
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 1
77931: NEG
77932: PUSH
77933: LD_INT 5
77935: NEG
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 2
77943: PUSH
77944: LD_INT 3
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 2
77954: NEG
77955: PUSH
77956: LD_INT 5
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: LIST
77972: LIST
77973: LIST
77974: LIST
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78011: LD_ADDR_VAR 0 31
78015: PUSH
78016: LD_INT 0
78018: PUSH
78019: LD_INT 4
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 0
78028: PUSH
78029: LD_INT 3
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 1
78038: PUSH
78039: LD_INT 4
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 1
78048: PUSH
78049: LD_INT 5
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 0
78058: PUSH
78059: LD_INT 5
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 1
78068: NEG
78069: PUSH
78070: LD_INT 4
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 1
78079: NEG
78080: PUSH
78081: LD_INT 3
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 2
78090: PUSH
78091: LD_INT 5
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 2
78100: NEG
78101: PUSH
78102: LD_INT 3
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 3
78111: NEG
78112: PUSH
78113: LD_INT 0
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 3
78122: NEG
78123: PUSH
78124: LD_INT 1
78126: NEG
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 2
78134: NEG
78135: PUSH
78136: LD_INT 0
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 2
78145: NEG
78146: PUSH
78147: LD_INT 1
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 3
78156: NEG
78157: PUSH
78158: LD_INT 1
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 4
78167: NEG
78168: PUSH
78169: LD_INT 0
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 4
78178: NEG
78179: PUSH
78180: LD_INT 1
78182: NEG
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 4
78190: NEG
78191: PUSH
78192: LD_INT 2
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 2
78202: NEG
78203: PUSH
78204: LD_INT 2
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 4
78213: NEG
78214: PUSH
78215: LD_INT 4
78217: NEG
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 4
78225: NEG
78226: PUSH
78227: LD_INT 5
78229: NEG
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 3
78237: NEG
78238: PUSH
78239: LD_INT 4
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 3
78249: NEG
78250: PUSH
78251: LD_INT 3
78253: NEG
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 4
78261: NEG
78262: PUSH
78263: LD_INT 3
78265: NEG
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 5
78273: NEG
78274: PUSH
78275: LD_INT 4
78277: NEG
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 5
78285: NEG
78286: PUSH
78287: LD_INT 5
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 3
78297: NEG
78298: PUSH
78299: LD_INT 5
78301: NEG
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: LD_INT 5
78309: NEG
78310: PUSH
78311: LD_INT 3
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 0
78321: PUSH
78322: LD_INT 3
78324: NEG
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: LD_INT 4
78335: NEG
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: LD_INT 1
78343: PUSH
78344: LD_INT 3
78346: NEG
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 1
78354: PUSH
78355: LD_INT 2
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 0
78365: PUSH
78366: LD_INT 2
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: LD_INT 3
78380: NEG
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 1
78388: NEG
78389: PUSH
78390: LD_INT 4
78392: NEG
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 2
78400: PUSH
78401: LD_INT 2
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 2
78411: NEG
78412: PUSH
78413: LD_INT 4
78415: NEG
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 4
78423: PUSH
78424: LD_INT 0
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 4
78433: PUSH
78434: LD_INT 1
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 5
78444: PUSH
78445: LD_INT 0
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: PUSH
78452: LD_INT 5
78454: PUSH
78455: LD_INT 1
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 4
78464: PUSH
78465: LD_INT 1
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 3
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 3
78484: PUSH
78485: LD_INT 1
78487: NEG
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: LD_INT 2
78498: NEG
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 5
78506: PUSH
78507: LD_INT 2
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78561: LD_ADDR_VAR 0 32
78565: PUSH
78566: LD_INT 4
78568: NEG
78569: PUSH
78570: LD_INT 0
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 4
78579: NEG
78580: PUSH
78581: LD_INT 1
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 3
78591: NEG
78592: PUSH
78593: LD_INT 0
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 3
78602: NEG
78603: PUSH
78604: LD_INT 1
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 4
78613: NEG
78614: PUSH
78615: LD_INT 1
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 5
78624: NEG
78625: PUSH
78626: LD_INT 0
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PUSH
78633: LD_INT 5
78635: NEG
78636: PUSH
78637: LD_INT 1
78639: NEG
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 5
78647: NEG
78648: PUSH
78649: LD_INT 2
78651: NEG
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 3
78659: NEG
78660: PUSH
78661: LD_INT 2
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 3
78670: NEG
78671: PUSH
78672: LD_INT 3
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 3
78682: NEG
78683: PUSH
78684: LD_INT 4
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 2
78694: NEG
78695: PUSH
78696: LD_INT 3
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 2
78706: NEG
78707: PUSH
78708: LD_INT 2
78710: NEG
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 3
78718: NEG
78719: PUSH
78720: LD_INT 2
78722: NEG
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 4
78730: NEG
78731: PUSH
78732: LD_INT 3
78734: NEG
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 4
78742: NEG
78743: PUSH
78744: LD_INT 4
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 2
78754: NEG
78755: PUSH
78756: LD_INT 4
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 4
78766: NEG
78767: PUSH
78768: LD_INT 2
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 0
78778: PUSH
78779: LD_INT 4
78781: NEG
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 0
78789: PUSH
78790: LD_INT 5
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 1
78800: PUSH
78801: LD_INT 4
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 1
78811: PUSH
78812: LD_INT 3
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 0
78822: PUSH
78823: LD_INT 3
78825: NEG
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 1
78833: NEG
78834: PUSH
78835: LD_INT 4
78837: NEG
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 1
78845: NEG
78846: PUSH
78847: LD_INT 5
78849: NEG
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: LD_INT 2
78857: PUSH
78858: LD_INT 3
78860: NEG
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 2
78868: NEG
78869: PUSH
78870: LD_INT 5
78872: NEG
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 3
78880: PUSH
78881: LD_INT 0
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: LD_INT 3
78890: PUSH
78891: LD_INT 1
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 4
78901: PUSH
78902: LD_INT 0
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 4
78911: PUSH
78912: LD_INT 1
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: LD_INT 3
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: PUSH
78932: LD_INT 0
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 2
78941: PUSH
78942: LD_INT 1
78944: NEG
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 2
78952: PUSH
78953: LD_INT 2
78955: NEG
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 4
78963: PUSH
78964: LD_INT 2
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 4
78973: PUSH
78974: LD_INT 4
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 4
78983: PUSH
78984: LD_INT 3
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 5
78993: PUSH
78994: LD_INT 4
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 5
79003: PUSH
79004: LD_INT 5
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 4
79013: PUSH
79014: LD_INT 5
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 3
79023: PUSH
79024: LD_INT 4
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: LD_INT 3
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 5
79043: PUSH
79044: LD_INT 3
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 3
79053: PUSH
79054: LD_INT 5
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79108: LD_ADDR_VAR 0 33
79112: PUSH
79113: LD_INT 4
79115: NEG
79116: PUSH
79117: LD_INT 4
79119: NEG
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 4
79127: NEG
79128: PUSH
79129: LD_INT 5
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 3
79139: NEG
79140: PUSH
79141: LD_INT 4
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 3
79151: NEG
79152: PUSH
79153: LD_INT 3
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 4
79163: NEG
79164: PUSH
79165: LD_INT 3
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 5
79175: NEG
79176: PUSH
79177: LD_INT 4
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 5
79187: NEG
79188: PUSH
79189: LD_INT 5
79191: NEG
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 3
79199: NEG
79200: PUSH
79201: LD_INT 5
79203: NEG
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 5
79211: NEG
79212: PUSH
79213: LD_INT 3
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 0
79223: PUSH
79224: LD_INT 3
79226: NEG
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 0
79234: PUSH
79235: LD_INT 4
79237: NEG
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 1
79245: PUSH
79246: LD_INT 3
79248: NEG
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 1
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 0
79267: PUSH
79268: LD_INT 2
79270: NEG
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: LD_INT 1
79278: NEG
79279: PUSH
79280: LD_INT 3
79282: NEG
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 1
79290: NEG
79291: PUSH
79292: LD_INT 4
79294: NEG
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 2
79302: PUSH
79303: LD_INT 2
79305: NEG
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 2
79313: NEG
79314: PUSH
79315: LD_INT 4
79317: NEG
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 4
79325: PUSH
79326: LD_INT 0
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 4
79335: PUSH
79336: LD_INT 1
79338: NEG
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 5
79346: PUSH
79347: LD_INT 0
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 5
79356: PUSH
79357: LD_INT 1
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 4
79366: PUSH
79367: LD_INT 1
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 3
79376: PUSH
79377: LD_INT 0
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 3
79386: PUSH
79387: LD_INT 1
79389: NEG
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 3
79397: PUSH
79398: LD_INT 2
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 5
79408: PUSH
79409: LD_INT 2
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 3
79418: PUSH
79419: LD_INT 3
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 3
79428: PUSH
79429: LD_INT 2
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 4
79438: PUSH
79439: LD_INT 3
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 4
79448: PUSH
79449: LD_INT 4
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 3
79458: PUSH
79459: LD_INT 4
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 2
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 2
79478: PUSH
79479: LD_INT 2
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 4
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 2
79498: PUSH
79499: LD_INT 4
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 0
79508: PUSH
79509: LD_INT 4
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: PUSH
79516: LD_INT 0
79518: PUSH
79519: LD_INT 3
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 1
79528: PUSH
79529: LD_INT 4
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 1
79538: PUSH
79539: LD_INT 5
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: LD_INT 0
79548: PUSH
79549: LD_INT 5
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 1
79558: NEG
79559: PUSH
79560: LD_INT 4
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 1
79569: NEG
79570: PUSH
79571: LD_INT 3
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: PUSH
79578: LD_INT 2
79580: PUSH
79581: LD_INT 5
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 2
79590: NEG
79591: PUSH
79592: LD_INT 3
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79646: LD_ADDR_VAR 0 34
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: LD_INT 4
79656: NEG
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 0
79664: PUSH
79665: LD_INT 5
79667: NEG
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 1
79675: PUSH
79676: LD_INT 4
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 1
79686: PUSH
79687: LD_INT 3
79689: NEG
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 0
79697: PUSH
79698: LD_INT 3
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 1
79708: NEG
79709: PUSH
79710: LD_INT 4
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 1
79720: NEG
79721: PUSH
79722: LD_INT 5
79724: NEG
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 2
79732: PUSH
79733: LD_INT 3
79735: NEG
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 2
79743: NEG
79744: PUSH
79745: LD_INT 5
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 3
79755: PUSH
79756: LD_INT 0
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 3
79765: PUSH
79766: LD_INT 1
79768: NEG
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 4
79776: PUSH
79777: LD_INT 0
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 4
79786: PUSH
79787: LD_INT 1
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 3
79796: PUSH
79797: LD_INT 1
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 2
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 2
79816: PUSH
79817: LD_INT 1
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 2
79827: PUSH
79828: LD_INT 2
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 4
79838: PUSH
79839: LD_INT 2
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 4
79848: PUSH
79849: LD_INT 4
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 4
79858: PUSH
79859: LD_INT 3
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 5
79868: PUSH
79869: LD_INT 4
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 5
79878: PUSH
79879: LD_INT 5
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 4
79888: PUSH
79889: LD_INT 5
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 3
79898: PUSH
79899: LD_INT 4
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 3
79908: PUSH
79909: LD_INT 3
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 5
79918: PUSH
79919: LD_INT 3
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 3
79928: PUSH
79929: LD_INT 5
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 0
79938: PUSH
79939: LD_INT 3
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 0
79948: PUSH
79949: LD_INT 2
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 1
79958: PUSH
79959: LD_INT 3
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 1
79968: PUSH
79969: LD_INT 4
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 0
79978: PUSH
79979: LD_INT 4
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 1
79988: NEG
79989: PUSH
79990: LD_INT 3
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 1
79999: NEG
80000: PUSH
80001: LD_INT 2
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 2
80010: PUSH
80011: LD_INT 4
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 2
80020: NEG
80021: PUSH
80022: LD_INT 2
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 4
80031: NEG
80032: PUSH
80033: LD_INT 0
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 4
80042: NEG
80043: PUSH
80044: LD_INT 1
80046: NEG
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 3
80054: NEG
80055: PUSH
80056: LD_INT 0
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 3
80065: NEG
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 4
80076: NEG
80077: PUSH
80078: LD_INT 1
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 5
80087: NEG
80088: PUSH
80089: LD_INT 0
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 5
80098: NEG
80099: PUSH
80100: LD_INT 1
80102: NEG
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 5
80110: NEG
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 3
80122: NEG
80123: PUSH
80124: LD_INT 2
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: ST_TO_ADDR
// end ; end ;
80178: GO 80181
80180: POP
// case btype of b_depot , b_warehouse :
80181: LD_VAR 0 1
80185: PUSH
80186: LD_INT 0
80188: DOUBLE
80189: EQUAL
80190: IFTRUE 80200
80192: LD_INT 1
80194: DOUBLE
80195: EQUAL
80196: IFTRUE 80200
80198: GO 80401
80200: POP
// case nation of nation_american :
80201: LD_VAR 0 5
80205: PUSH
80206: LD_INT 1
80208: DOUBLE
80209: EQUAL
80210: IFTRUE 80214
80212: GO 80270
80214: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80215: LD_ADDR_VAR 0 9
80219: PUSH
80220: LD_VAR 0 11
80224: PUSH
80225: LD_VAR 0 12
80229: PUSH
80230: LD_VAR 0 13
80234: PUSH
80235: LD_VAR 0 14
80239: PUSH
80240: LD_VAR 0 15
80244: PUSH
80245: LD_VAR 0 16
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: PUSH
80258: LD_VAR 0 4
80262: PUSH
80263: LD_INT 1
80265: PLUS
80266: ARRAY
80267: ST_TO_ADDR
80268: GO 80399
80270: LD_INT 2
80272: DOUBLE
80273: EQUAL
80274: IFTRUE 80278
80276: GO 80334
80278: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80279: LD_ADDR_VAR 0 9
80283: PUSH
80284: LD_VAR 0 17
80288: PUSH
80289: LD_VAR 0 18
80293: PUSH
80294: LD_VAR 0 19
80298: PUSH
80299: LD_VAR 0 20
80303: PUSH
80304: LD_VAR 0 21
80308: PUSH
80309: LD_VAR 0 22
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: LIST
80321: PUSH
80322: LD_VAR 0 4
80326: PUSH
80327: LD_INT 1
80329: PLUS
80330: ARRAY
80331: ST_TO_ADDR
80332: GO 80399
80334: LD_INT 3
80336: DOUBLE
80337: EQUAL
80338: IFTRUE 80342
80340: GO 80398
80342: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80343: LD_ADDR_VAR 0 9
80347: PUSH
80348: LD_VAR 0 23
80352: PUSH
80353: LD_VAR 0 24
80357: PUSH
80358: LD_VAR 0 25
80362: PUSH
80363: LD_VAR 0 26
80367: PUSH
80368: LD_VAR 0 27
80372: PUSH
80373: LD_VAR 0 28
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: PUSH
80386: LD_VAR 0 4
80390: PUSH
80391: LD_INT 1
80393: PLUS
80394: ARRAY
80395: ST_TO_ADDR
80396: GO 80399
80398: POP
80399: GO 80954
80401: LD_INT 2
80403: DOUBLE
80404: EQUAL
80405: IFTRUE 80415
80407: LD_INT 3
80409: DOUBLE
80410: EQUAL
80411: IFTRUE 80415
80413: GO 80471
80415: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80416: LD_ADDR_VAR 0 9
80420: PUSH
80421: LD_VAR 0 29
80425: PUSH
80426: LD_VAR 0 30
80430: PUSH
80431: LD_VAR 0 31
80435: PUSH
80436: LD_VAR 0 32
80440: PUSH
80441: LD_VAR 0 33
80445: PUSH
80446: LD_VAR 0 34
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: PUSH
80459: LD_VAR 0 4
80463: PUSH
80464: LD_INT 1
80466: PLUS
80467: ARRAY
80468: ST_TO_ADDR
80469: GO 80954
80471: LD_INT 16
80473: DOUBLE
80474: EQUAL
80475: IFTRUE 80533
80477: LD_INT 17
80479: DOUBLE
80480: EQUAL
80481: IFTRUE 80533
80483: LD_INT 18
80485: DOUBLE
80486: EQUAL
80487: IFTRUE 80533
80489: LD_INT 19
80491: DOUBLE
80492: EQUAL
80493: IFTRUE 80533
80495: LD_INT 22
80497: DOUBLE
80498: EQUAL
80499: IFTRUE 80533
80501: LD_INT 20
80503: DOUBLE
80504: EQUAL
80505: IFTRUE 80533
80507: LD_INT 21
80509: DOUBLE
80510: EQUAL
80511: IFTRUE 80533
80513: LD_INT 23
80515: DOUBLE
80516: EQUAL
80517: IFTRUE 80533
80519: LD_INT 24
80521: DOUBLE
80522: EQUAL
80523: IFTRUE 80533
80525: LD_INT 25
80527: DOUBLE
80528: EQUAL
80529: IFTRUE 80533
80531: GO 80589
80533: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80534: LD_ADDR_VAR 0 9
80538: PUSH
80539: LD_VAR 0 35
80543: PUSH
80544: LD_VAR 0 36
80548: PUSH
80549: LD_VAR 0 37
80553: PUSH
80554: LD_VAR 0 38
80558: PUSH
80559: LD_VAR 0 39
80563: PUSH
80564: LD_VAR 0 40
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: PUSH
80577: LD_VAR 0 4
80581: PUSH
80582: LD_INT 1
80584: PLUS
80585: ARRAY
80586: ST_TO_ADDR
80587: GO 80954
80589: LD_INT 6
80591: DOUBLE
80592: EQUAL
80593: IFTRUE 80645
80595: LD_INT 7
80597: DOUBLE
80598: EQUAL
80599: IFTRUE 80645
80601: LD_INT 8
80603: DOUBLE
80604: EQUAL
80605: IFTRUE 80645
80607: LD_INT 13
80609: DOUBLE
80610: EQUAL
80611: IFTRUE 80645
80613: LD_INT 12
80615: DOUBLE
80616: EQUAL
80617: IFTRUE 80645
80619: LD_INT 15
80621: DOUBLE
80622: EQUAL
80623: IFTRUE 80645
80625: LD_INT 11
80627: DOUBLE
80628: EQUAL
80629: IFTRUE 80645
80631: LD_INT 14
80633: DOUBLE
80634: EQUAL
80635: IFTRUE 80645
80637: LD_INT 10
80639: DOUBLE
80640: EQUAL
80641: IFTRUE 80645
80643: GO 80701
80645: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80646: LD_ADDR_VAR 0 9
80650: PUSH
80651: LD_VAR 0 41
80655: PUSH
80656: LD_VAR 0 42
80660: PUSH
80661: LD_VAR 0 43
80665: PUSH
80666: LD_VAR 0 44
80670: PUSH
80671: LD_VAR 0 45
80675: PUSH
80676: LD_VAR 0 46
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: PUSH
80689: LD_VAR 0 4
80693: PUSH
80694: LD_INT 1
80696: PLUS
80697: ARRAY
80698: ST_TO_ADDR
80699: GO 80954
80701: LD_INT 36
80703: DOUBLE
80704: EQUAL
80705: IFTRUE 80709
80707: GO 80765
80709: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80710: LD_ADDR_VAR 0 9
80714: PUSH
80715: LD_VAR 0 47
80719: PUSH
80720: LD_VAR 0 48
80724: PUSH
80725: LD_VAR 0 49
80729: PUSH
80730: LD_VAR 0 50
80734: PUSH
80735: LD_VAR 0 51
80739: PUSH
80740: LD_VAR 0 52
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: PUSH
80753: LD_VAR 0 4
80757: PUSH
80758: LD_INT 1
80760: PLUS
80761: ARRAY
80762: ST_TO_ADDR
80763: GO 80954
80765: LD_INT 4
80767: DOUBLE
80768: EQUAL
80769: IFTRUE 80791
80771: LD_INT 5
80773: DOUBLE
80774: EQUAL
80775: IFTRUE 80791
80777: LD_INT 34
80779: DOUBLE
80780: EQUAL
80781: IFTRUE 80791
80783: LD_INT 37
80785: DOUBLE
80786: EQUAL
80787: IFTRUE 80791
80789: GO 80847
80791: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80792: LD_ADDR_VAR 0 9
80796: PUSH
80797: LD_VAR 0 53
80801: PUSH
80802: LD_VAR 0 54
80806: PUSH
80807: LD_VAR 0 55
80811: PUSH
80812: LD_VAR 0 56
80816: PUSH
80817: LD_VAR 0 57
80821: PUSH
80822: LD_VAR 0 58
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: PUSH
80835: LD_VAR 0 4
80839: PUSH
80840: LD_INT 1
80842: PLUS
80843: ARRAY
80844: ST_TO_ADDR
80845: GO 80954
80847: LD_INT 31
80849: DOUBLE
80850: EQUAL
80851: IFTRUE 80897
80853: LD_INT 32
80855: DOUBLE
80856: EQUAL
80857: IFTRUE 80897
80859: LD_INT 33
80861: DOUBLE
80862: EQUAL
80863: IFTRUE 80897
80865: LD_INT 27
80867: DOUBLE
80868: EQUAL
80869: IFTRUE 80897
80871: LD_INT 26
80873: DOUBLE
80874: EQUAL
80875: IFTRUE 80897
80877: LD_INT 28
80879: DOUBLE
80880: EQUAL
80881: IFTRUE 80897
80883: LD_INT 29
80885: DOUBLE
80886: EQUAL
80887: IFTRUE 80897
80889: LD_INT 30
80891: DOUBLE
80892: EQUAL
80893: IFTRUE 80897
80895: GO 80953
80897: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80898: LD_ADDR_VAR 0 9
80902: PUSH
80903: LD_VAR 0 59
80907: PUSH
80908: LD_VAR 0 60
80912: PUSH
80913: LD_VAR 0 61
80917: PUSH
80918: LD_VAR 0 62
80922: PUSH
80923: LD_VAR 0 63
80927: PUSH
80928: LD_VAR 0 64
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: PUSH
80941: LD_VAR 0 4
80945: PUSH
80946: LD_INT 1
80948: PLUS
80949: ARRAY
80950: ST_TO_ADDR
80951: GO 80954
80953: POP
// temp_list2 = [ ] ;
80954: LD_ADDR_VAR 0 10
80958: PUSH
80959: EMPTY
80960: ST_TO_ADDR
// for i in temp_list do
80961: LD_ADDR_VAR 0 8
80965: PUSH
80966: LD_VAR 0 9
80970: PUSH
80971: FOR_IN
80972: IFFALSE 81024
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80974: LD_ADDR_VAR 0 10
80978: PUSH
80979: LD_VAR 0 10
80983: PUSH
80984: LD_VAR 0 8
80988: PUSH
80989: LD_INT 1
80991: ARRAY
80992: PUSH
80993: LD_VAR 0 2
80997: PLUS
80998: PUSH
80999: LD_VAR 0 8
81003: PUSH
81004: LD_INT 2
81006: ARRAY
81007: PUSH
81008: LD_VAR 0 3
81012: PLUS
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: EMPTY
81019: LIST
81020: ADD
81021: ST_TO_ADDR
81022: GO 80971
81024: POP
81025: POP
// result = temp_list2 ;
81026: LD_ADDR_VAR 0 7
81030: PUSH
81031: LD_VAR 0 10
81035: ST_TO_ADDR
// end ;
81036: LD_VAR 0 7
81040: RET
// export function EnemyInRange ( unit , dist ) ; begin
81041: LD_INT 0
81043: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81044: LD_ADDR_VAR 0 3
81048: PUSH
81049: LD_VAR 0 1
81053: PPUSH
81054: CALL_OW 255
81058: PPUSH
81059: LD_VAR 0 1
81063: PPUSH
81064: CALL_OW 250
81068: PPUSH
81069: LD_VAR 0 1
81073: PPUSH
81074: CALL_OW 251
81078: PPUSH
81079: LD_VAR 0 2
81083: PPUSH
81084: CALL 54437 0 4
81088: PUSH
81089: LD_INT 4
81091: ARRAY
81092: ST_TO_ADDR
// end ;
81093: LD_VAR 0 3
81097: RET
// export function PlayerSeeMe ( unit ) ; begin
81098: LD_INT 0
81100: PPUSH
// result := See ( your_side , unit ) ;
81101: LD_ADDR_VAR 0 2
81105: PUSH
81106: LD_OWVAR 2
81110: PPUSH
81111: LD_VAR 0 1
81115: PPUSH
81116: CALL_OW 292
81120: ST_TO_ADDR
// end ;
81121: LD_VAR 0 2
81125: RET
// export function ReverseDir ( unit ) ; begin
81126: LD_INT 0
81128: PPUSH
// if not unit then
81129: LD_VAR 0 1
81133: NOT
81134: IFFALSE 81138
// exit ;
81136: GO 81161
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81138: LD_ADDR_VAR 0 2
81142: PUSH
81143: LD_VAR 0 1
81147: PPUSH
81148: CALL_OW 254
81152: PUSH
81153: LD_INT 3
81155: PLUS
81156: PUSH
81157: LD_INT 6
81159: MOD
81160: ST_TO_ADDR
// end ;
81161: LD_VAR 0 2
81165: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81166: LD_INT 0
81168: PPUSH
81169: PPUSH
81170: PPUSH
81171: PPUSH
81172: PPUSH
// if not hexes then
81173: LD_VAR 0 2
81177: NOT
81178: IFFALSE 81182
// exit ;
81180: GO 81330
// dist := 9999 ;
81182: LD_ADDR_VAR 0 5
81186: PUSH
81187: LD_INT 9999
81189: ST_TO_ADDR
// for i = 1 to hexes do
81190: LD_ADDR_VAR 0 4
81194: PUSH
81195: DOUBLE
81196: LD_INT 1
81198: DEC
81199: ST_TO_ADDR
81200: LD_VAR 0 2
81204: PUSH
81205: FOR_TO
81206: IFFALSE 81318
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81208: LD_VAR 0 1
81212: PPUSH
81213: LD_VAR 0 2
81217: PUSH
81218: LD_VAR 0 4
81222: ARRAY
81223: PUSH
81224: LD_INT 1
81226: ARRAY
81227: PPUSH
81228: LD_VAR 0 2
81232: PUSH
81233: LD_VAR 0 4
81237: ARRAY
81238: PUSH
81239: LD_INT 2
81241: ARRAY
81242: PPUSH
81243: CALL_OW 297
81247: PUSH
81248: LD_VAR 0 5
81252: LESS
81253: IFFALSE 81316
// begin hex := hexes [ i ] ;
81255: LD_ADDR_VAR 0 7
81259: PUSH
81260: LD_VAR 0 2
81264: PUSH
81265: LD_VAR 0 4
81269: ARRAY
81270: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81271: LD_ADDR_VAR 0 5
81275: PUSH
81276: LD_VAR 0 1
81280: PPUSH
81281: LD_VAR 0 2
81285: PUSH
81286: LD_VAR 0 4
81290: ARRAY
81291: PUSH
81292: LD_INT 1
81294: ARRAY
81295: PPUSH
81296: LD_VAR 0 2
81300: PUSH
81301: LD_VAR 0 4
81305: ARRAY
81306: PUSH
81307: LD_INT 2
81309: ARRAY
81310: PPUSH
81311: CALL_OW 297
81315: ST_TO_ADDR
// end ; end ;
81316: GO 81205
81318: POP
81319: POP
// result := hex ;
81320: LD_ADDR_VAR 0 3
81324: PUSH
81325: LD_VAR 0 7
81329: ST_TO_ADDR
// end ;
81330: LD_VAR 0 3
81334: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81335: LD_INT 0
81337: PPUSH
81338: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81339: LD_VAR 0 1
81343: NOT
81344: PUSH
81345: LD_VAR 0 1
81349: PUSH
81350: LD_INT 21
81352: PUSH
81353: LD_INT 2
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 23
81362: PUSH
81363: LD_INT 2
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PPUSH
81374: CALL_OW 69
81378: IN
81379: NOT
81380: OR
81381: IFFALSE 81385
// exit ;
81383: GO 81432
// for i = 1 to 3 do
81385: LD_ADDR_VAR 0 3
81389: PUSH
81390: DOUBLE
81391: LD_INT 1
81393: DEC
81394: ST_TO_ADDR
81395: LD_INT 3
81397: PUSH
81398: FOR_TO
81399: IFFALSE 81430
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81401: LD_VAR 0 1
81405: PPUSH
81406: CALL_OW 250
81410: PPUSH
81411: LD_VAR 0 1
81415: PPUSH
81416: CALL_OW 251
81420: PPUSH
81421: LD_INT 1
81423: PPUSH
81424: CALL_OW 453
81428: GO 81398
81430: POP
81431: POP
// end ;
81432: LD_VAR 0 2
81436: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81437: LD_INT 0
81439: PPUSH
81440: PPUSH
81441: PPUSH
81442: PPUSH
81443: PPUSH
81444: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81445: LD_VAR 0 1
81449: NOT
81450: PUSH
81451: LD_VAR 0 2
81455: NOT
81456: OR
81457: PUSH
81458: LD_VAR 0 1
81462: PPUSH
81463: CALL_OW 314
81467: OR
81468: IFFALSE 81472
// exit ;
81470: GO 81913
// x := GetX ( enemy_unit ) ;
81472: LD_ADDR_VAR 0 7
81476: PUSH
81477: LD_VAR 0 2
81481: PPUSH
81482: CALL_OW 250
81486: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81487: LD_ADDR_VAR 0 8
81491: PUSH
81492: LD_VAR 0 2
81496: PPUSH
81497: CALL_OW 251
81501: ST_TO_ADDR
// if not x or not y then
81502: LD_VAR 0 7
81506: NOT
81507: PUSH
81508: LD_VAR 0 8
81512: NOT
81513: OR
81514: IFFALSE 81518
// exit ;
81516: GO 81913
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81518: LD_ADDR_VAR 0 6
81522: PUSH
81523: LD_VAR 0 7
81527: PPUSH
81528: LD_INT 0
81530: PPUSH
81531: LD_INT 4
81533: PPUSH
81534: CALL_OW 272
81538: PUSH
81539: LD_VAR 0 8
81543: PPUSH
81544: LD_INT 0
81546: PPUSH
81547: LD_INT 4
81549: PPUSH
81550: CALL_OW 273
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_VAR 0 7
81563: PPUSH
81564: LD_INT 1
81566: PPUSH
81567: LD_INT 4
81569: PPUSH
81570: CALL_OW 272
81574: PUSH
81575: LD_VAR 0 8
81579: PPUSH
81580: LD_INT 1
81582: PPUSH
81583: LD_INT 4
81585: PPUSH
81586: CALL_OW 273
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_VAR 0 7
81599: PPUSH
81600: LD_INT 2
81602: PPUSH
81603: LD_INT 4
81605: PPUSH
81606: CALL_OW 272
81610: PUSH
81611: LD_VAR 0 8
81615: PPUSH
81616: LD_INT 2
81618: PPUSH
81619: LD_INT 4
81621: PPUSH
81622: CALL_OW 273
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_VAR 0 7
81635: PPUSH
81636: LD_INT 3
81638: PPUSH
81639: LD_INT 4
81641: PPUSH
81642: CALL_OW 272
81646: PUSH
81647: LD_VAR 0 8
81651: PPUSH
81652: LD_INT 3
81654: PPUSH
81655: LD_INT 4
81657: PPUSH
81658: CALL_OW 273
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_VAR 0 7
81671: PPUSH
81672: LD_INT 4
81674: PPUSH
81675: LD_INT 4
81677: PPUSH
81678: CALL_OW 272
81682: PUSH
81683: LD_VAR 0 8
81687: PPUSH
81688: LD_INT 4
81690: PPUSH
81691: LD_INT 4
81693: PPUSH
81694: CALL_OW 273
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: LD_VAR 0 7
81707: PPUSH
81708: LD_INT 5
81710: PPUSH
81711: LD_INT 4
81713: PPUSH
81714: CALL_OW 272
81718: PUSH
81719: LD_VAR 0 8
81723: PPUSH
81724: LD_INT 5
81726: PPUSH
81727: LD_INT 4
81729: PPUSH
81730: CALL_OW 273
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: ST_TO_ADDR
// for i = tmp downto 1 do
81747: LD_ADDR_VAR 0 4
81751: PUSH
81752: DOUBLE
81753: LD_VAR 0 6
81757: INC
81758: ST_TO_ADDR
81759: LD_INT 1
81761: PUSH
81762: FOR_DOWNTO
81763: IFFALSE 81864
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81765: LD_VAR 0 6
81769: PUSH
81770: LD_VAR 0 4
81774: ARRAY
81775: PUSH
81776: LD_INT 1
81778: ARRAY
81779: PPUSH
81780: LD_VAR 0 6
81784: PUSH
81785: LD_VAR 0 4
81789: ARRAY
81790: PUSH
81791: LD_INT 2
81793: ARRAY
81794: PPUSH
81795: CALL_OW 488
81799: NOT
81800: PUSH
81801: LD_VAR 0 6
81805: PUSH
81806: LD_VAR 0 4
81810: ARRAY
81811: PUSH
81812: LD_INT 1
81814: ARRAY
81815: PPUSH
81816: LD_VAR 0 6
81820: PUSH
81821: LD_VAR 0 4
81825: ARRAY
81826: PUSH
81827: LD_INT 2
81829: ARRAY
81830: PPUSH
81831: CALL_OW 428
81835: PUSH
81836: LD_INT 0
81838: NONEQUAL
81839: OR
81840: IFFALSE 81862
// tmp := Delete ( tmp , i ) ;
81842: LD_ADDR_VAR 0 6
81846: PUSH
81847: LD_VAR 0 6
81851: PPUSH
81852: LD_VAR 0 4
81856: PPUSH
81857: CALL_OW 3
81861: ST_TO_ADDR
81862: GO 81762
81864: POP
81865: POP
// j := GetClosestHex ( unit , tmp ) ;
81866: LD_ADDR_VAR 0 5
81870: PUSH
81871: LD_VAR 0 1
81875: PPUSH
81876: LD_VAR 0 6
81880: PPUSH
81881: CALL 81166 0 2
81885: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81886: LD_VAR 0 1
81890: PPUSH
81891: LD_VAR 0 5
81895: PUSH
81896: LD_INT 1
81898: ARRAY
81899: PPUSH
81900: LD_VAR 0 5
81904: PUSH
81905: LD_INT 2
81907: ARRAY
81908: PPUSH
81909: CALL_OW 111
// end ;
81913: LD_VAR 0 3
81917: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81918: LD_INT 0
81920: PPUSH
81921: PPUSH
81922: PPUSH
// uc_side = 0 ;
81923: LD_ADDR_OWVAR 20
81927: PUSH
81928: LD_INT 0
81930: ST_TO_ADDR
// uc_nation = 0 ;
81931: LD_ADDR_OWVAR 21
81935: PUSH
81936: LD_INT 0
81938: ST_TO_ADDR
// InitHc_All ( ) ;
81939: CALL_OW 584
// InitVc ;
81943: CALL_OW 20
// if mastodonts then
81947: LD_VAR 0 6
81951: IFFALSE 82018
// for i = 1 to mastodonts do
81953: LD_ADDR_VAR 0 11
81957: PUSH
81958: DOUBLE
81959: LD_INT 1
81961: DEC
81962: ST_TO_ADDR
81963: LD_VAR 0 6
81967: PUSH
81968: FOR_TO
81969: IFFALSE 82016
// begin vc_chassis := 31 ;
81971: LD_ADDR_OWVAR 37
81975: PUSH
81976: LD_INT 31
81978: ST_TO_ADDR
// vc_control := control_rider ;
81979: LD_ADDR_OWVAR 38
81983: PUSH
81984: LD_INT 4
81986: ST_TO_ADDR
// animal := CreateVehicle ;
81987: LD_ADDR_VAR 0 12
81991: PUSH
81992: CALL_OW 45
81996: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81997: LD_VAR 0 12
82001: PPUSH
82002: LD_VAR 0 8
82006: PPUSH
82007: LD_INT 0
82009: PPUSH
82010: CALL 84206 0 3
// end ;
82014: GO 81968
82016: POP
82017: POP
// if horses then
82018: LD_VAR 0 5
82022: IFFALSE 82089
// for i = 1 to horses do
82024: LD_ADDR_VAR 0 11
82028: PUSH
82029: DOUBLE
82030: LD_INT 1
82032: DEC
82033: ST_TO_ADDR
82034: LD_VAR 0 5
82038: PUSH
82039: FOR_TO
82040: IFFALSE 82087
// begin hc_class := 21 ;
82042: LD_ADDR_OWVAR 28
82046: PUSH
82047: LD_INT 21
82049: ST_TO_ADDR
// hc_gallery :=  ;
82050: LD_ADDR_OWVAR 33
82054: PUSH
82055: LD_STRING 
82057: ST_TO_ADDR
// animal := CreateHuman ;
82058: LD_ADDR_VAR 0 12
82062: PUSH
82063: CALL_OW 44
82067: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82068: LD_VAR 0 12
82072: PPUSH
82073: LD_VAR 0 8
82077: PPUSH
82078: LD_INT 0
82080: PPUSH
82081: CALL 84206 0 3
// end ;
82085: GO 82039
82087: POP
82088: POP
// if birds then
82089: LD_VAR 0 1
82093: IFFALSE 82160
// for i = 1 to birds do
82095: LD_ADDR_VAR 0 11
82099: PUSH
82100: DOUBLE
82101: LD_INT 1
82103: DEC
82104: ST_TO_ADDR
82105: LD_VAR 0 1
82109: PUSH
82110: FOR_TO
82111: IFFALSE 82158
// begin hc_class = 18 ;
82113: LD_ADDR_OWVAR 28
82117: PUSH
82118: LD_INT 18
82120: ST_TO_ADDR
// hc_gallery =  ;
82121: LD_ADDR_OWVAR 33
82125: PUSH
82126: LD_STRING 
82128: ST_TO_ADDR
// animal := CreateHuman ;
82129: LD_ADDR_VAR 0 12
82133: PUSH
82134: CALL_OW 44
82138: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82139: LD_VAR 0 12
82143: PPUSH
82144: LD_VAR 0 8
82148: PPUSH
82149: LD_INT 0
82151: PPUSH
82152: CALL 84206 0 3
// end ;
82156: GO 82110
82158: POP
82159: POP
// if tigers then
82160: LD_VAR 0 2
82164: IFFALSE 82248
// for i = 1 to tigers do
82166: LD_ADDR_VAR 0 11
82170: PUSH
82171: DOUBLE
82172: LD_INT 1
82174: DEC
82175: ST_TO_ADDR
82176: LD_VAR 0 2
82180: PUSH
82181: FOR_TO
82182: IFFALSE 82246
// begin hc_class = class_tiger ;
82184: LD_ADDR_OWVAR 28
82188: PUSH
82189: LD_INT 14
82191: ST_TO_ADDR
// hc_gallery =  ;
82192: LD_ADDR_OWVAR 33
82196: PUSH
82197: LD_STRING 
82199: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82200: LD_ADDR_OWVAR 35
82204: PUSH
82205: LD_INT 7
82207: NEG
82208: PPUSH
82209: LD_INT 7
82211: PPUSH
82212: CALL_OW 12
82216: ST_TO_ADDR
// animal := CreateHuman ;
82217: LD_ADDR_VAR 0 12
82221: PUSH
82222: CALL_OW 44
82226: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82227: LD_VAR 0 12
82231: PPUSH
82232: LD_VAR 0 8
82236: PPUSH
82237: LD_INT 0
82239: PPUSH
82240: CALL 84206 0 3
// end ;
82244: GO 82181
82246: POP
82247: POP
// if apemans then
82248: LD_VAR 0 3
82252: IFFALSE 82375
// for i = 1 to apemans do
82254: LD_ADDR_VAR 0 11
82258: PUSH
82259: DOUBLE
82260: LD_INT 1
82262: DEC
82263: ST_TO_ADDR
82264: LD_VAR 0 3
82268: PUSH
82269: FOR_TO
82270: IFFALSE 82373
// begin hc_class = class_apeman ;
82272: LD_ADDR_OWVAR 28
82276: PUSH
82277: LD_INT 12
82279: ST_TO_ADDR
// hc_gallery =  ;
82280: LD_ADDR_OWVAR 33
82284: PUSH
82285: LD_STRING 
82287: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
82288: LD_ADDR_OWVAR 35
82292: PUSH
82293: LD_INT 2
82295: NEG
82296: PPUSH
82297: LD_INT 2
82299: PPUSH
82300: CALL_OW 12
82304: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82305: LD_ADDR_OWVAR 31
82309: PUSH
82310: LD_INT 1
82312: PPUSH
82313: LD_INT 3
82315: PPUSH
82316: CALL_OW 12
82320: PUSH
82321: LD_INT 1
82323: PPUSH
82324: LD_INT 3
82326: PPUSH
82327: CALL_OW 12
82331: PUSH
82332: LD_INT 0
82334: PUSH
82335: LD_INT 0
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: ST_TO_ADDR
// animal := CreateHuman ;
82344: LD_ADDR_VAR 0 12
82348: PUSH
82349: CALL_OW 44
82353: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82354: LD_VAR 0 12
82358: PPUSH
82359: LD_VAR 0 8
82363: PPUSH
82364: LD_INT 0
82366: PPUSH
82367: CALL 84206 0 3
// end ;
82371: GO 82269
82373: POP
82374: POP
// if enchidnas then
82375: LD_VAR 0 4
82379: IFFALSE 82446
// for i = 1 to enchidnas do
82381: LD_ADDR_VAR 0 11
82385: PUSH
82386: DOUBLE
82387: LD_INT 1
82389: DEC
82390: ST_TO_ADDR
82391: LD_VAR 0 4
82395: PUSH
82396: FOR_TO
82397: IFFALSE 82444
// begin hc_class = 13 ;
82399: LD_ADDR_OWVAR 28
82403: PUSH
82404: LD_INT 13
82406: ST_TO_ADDR
// hc_gallery =  ;
82407: LD_ADDR_OWVAR 33
82411: PUSH
82412: LD_STRING 
82414: ST_TO_ADDR
// animal := CreateHuman ;
82415: LD_ADDR_VAR 0 12
82419: PUSH
82420: CALL_OW 44
82424: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82425: LD_VAR 0 12
82429: PPUSH
82430: LD_VAR 0 8
82434: PPUSH
82435: LD_INT 0
82437: PPUSH
82438: CALL 84206 0 3
// end ;
82442: GO 82396
82444: POP
82445: POP
// if fishes then
82446: LD_VAR 0 7
82450: IFFALSE 82517
// for i = 1 to fishes do
82452: LD_ADDR_VAR 0 11
82456: PUSH
82457: DOUBLE
82458: LD_INT 1
82460: DEC
82461: ST_TO_ADDR
82462: LD_VAR 0 7
82466: PUSH
82467: FOR_TO
82468: IFFALSE 82515
// begin hc_class = 20 ;
82470: LD_ADDR_OWVAR 28
82474: PUSH
82475: LD_INT 20
82477: ST_TO_ADDR
// hc_gallery =  ;
82478: LD_ADDR_OWVAR 33
82482: PUSH
82483: LD_STRING 
82485: ST_TO_ADDR
// animal := CreateHuman ;
82486: LD_ADDR_VAR 0 12
82490: PUSH
82491: CALL_OW 44
82495: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82496: LD_VAR 0 12
82500: PPUSH
82501: LD_VAR 0 9
82505: PPUSH
82506: LD_INT 0
82508: PPUSH
82509: CALL 84206 0 3
// end ;
82513: GO 82467
82515: POP
82516: POP
// end ;
82517: LD_VAR 0 10
82521: RET
// export function WantHeal ( sci , unit ) ; begin
82522: LD_INT 0
82524: PPUSH
// if GetTaskList ( sci ) > 0 then
82525: LD_VAR 0 1
82529: PPUSH
82530: CALL_OW 437
82534: PUSH
82535: LD_INT 0
82537: GREATER
82538: IFFALSE 82608
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82540: LD_VAR 0 1
82544: PPUSH
82545: CALL_OW 437
82549: PUSH
82550: LD_INT 1
82552: ARRAY
82553: PUSH
82554: LD_INT 1
82556: ARRAY
82557: PUSH
82558: LD_STRING l
82560: EQUAL
82561: PUSH
82562: LD_VAR 0 1
82566: PPUSH
82567: CALL_OW 437
82571: PUSH
82572: LD_INT 1
82574: ARRAY
82575: PUSH
82576: LD_INT 4
82578: ARRAY
82579: PUSH
82580: LD_VAR 0 2
82584: EQUAL
82585: AND
82586: IFFALSE 82598
// result := true else
82588: LD_ADDR_VAR 0 3
82592: PUSH
82593: LD_INT 1
82595: ST_TO_ADDR
82596: GO 82606
// result := false ;
82598: LD_ADDR_VAR 0 3
82602: PUSH
82603: LD_INT 0
82605: ST_TO_ADDR
// end else
82606: GO 82616
// result := false ;
82608: LD_ADDR_VAR 0 3
82612: PUSH
82613: LD_INT 0
82615: ST_TO_ADDR
// end ;
82616: LD_VAR 0 3
82620: RET
// export function HealTarget ( sci ) ; begin
82621: LD_INT 0
82623: PPUSH
// if not sci then
82624: LD_VAR 0 1
82628: NOT
82629: IFFALSE 82633
// exit ;
82631: GO 82698
// result := 0 ;
82633: LD_ADDR_VAR 0 2
82637: PUSH
82638: LD_INT 0
82640: ST_TO_ADDR
// if GetTaskList ( sci ) then
82641: LD_VAR 0 1
82645: PPUSH
82646: CALL_OW 437
82650: IFFALSE 82698
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82652: LD_VAR 0 1
82656: PPUSH
82657: CALL_OW 437
82661: PUSH
82662: LD_INT 1
82664: ARRAY
82665: PUSH
82666: LD_INT 1
82668: ARRAY
82669: PUSH
82670: LD_STRING l
82672: EQUAL
82673: IFFALSE 82698
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82675: LD_ADDR_VAR 0 2
82679: PUSH
82680: LD_VAR 0 1
82684: PPUSH
82685: CALL_OW 437
82689: PUSH
82690: LD_INT 1
82692: ARRAY
82693: PUSH
82694: LD_INT 4
82696: ARRAY
82697: ST_TO_ADDR
// end ;
82698: LD_VAR 0 2
82702: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82703: LD_INT 0
82705: PPUSH
82706: PPUSH
82707: PPUSH
82708: PPUSH
// if not base_units then
82709: LD_VAR 0 1
82713: NOT
82714: IFFALSE 82718
// exit ;
82716: GO 82805
// result := false ;
82718: LD_ADDR_VAR 0 2
82722: PUSH
82723: LD_INT 0
82725: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82726: LD_ADDR_VAR 0 5
82730: PUSH
82731: LD_VAR 0 1
82735: PPUSH
82736: LD_INT 21
82738: PUSH
82739: LD_INT 3
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PPUSH
82746: CALL_OW 72
82750: ST_TO_ADDR
// if not tmp then
82751: LD_VAR 0 5
82755: NOT
82756: IFFALSE 82760
// exit ;
82758: GO 82805
// for i in tmp do
82760: LD_ADDR_VAR 0 3
82764: PUSH
82765: LD_VAR 0 5
82769: PUSH
82770: FOR_IN
82771: IFFALSE 82803
// begin result := EnemyInRange ( i , 22 ) ;
82773: LD_ADDR_VAR 0 2
82777: PUSH
82778: LD_VAR 0 3
82782: PPUSH
82783: LD_INT 22
82785: PPUSH
82786: CALL 81041 0 2
82790: ST_TO_ADDR
// if result then
82791: LD_VAR 0 2
82795: IFFALSE 82801
// exit ;
82797: POP
82798: POP
82799: GO 82805
// end ;
82801: GO 82770
82803: POP
82804: POP
// end ;
82805: LD_VAR 0 2
82809: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
82810: LD_INT 0
82812: PPUSH
82813: PPUSH
// if not units then
82814: LD_VAR 0 1
82818: NOT
82819: IFFALSE 82823
// exit ;
82821: GO 82893
// result := [ ] ;
82823: LD_ADDR_VAR 0 3
82827: PUSH
82828: EMPTY
82829: ST_TO_ADDR
// for i in units do
82830: LD_ADDR_VAR 0 4
82834: PUSH
82835: LD_VAR 0 1
82839: PUSH
82840: FOR_IN
82841: IFFALSE 82891
// if GetTag ( i ) = tag then
82843: LD_VAR 0 4
82847: PPUSH
82848: CALL_OW 110
82852: PUSH
82853: LD_VAR 0 2
82857: EQUAL
82858: IFFALSE 82889
// result := Replace ( result , result + 1 , i ) ;
82860: LD_ADDR_VAR 0 3
82864: PUSH
82865: LD_VAR 0 3
82869: PPUSH
82870: LD_VAR 0 3
82874: PUSH
82875: LD_INT 1
82877: PLUS
82878: PPUSH
82879: LD_VAR 0 4
82883: PPUSH
82884: CALL_OW 1
82888: ST_TO_ADDR
82889: GO 82840
82891: POP
82892: POP
// end ;
82893: LD_VAR 0 3
82897: RET
// export function IsDriver ( un ) ; begin
82898: LD_INT 0
82900: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82901: LD_ADDR_VAR 0 2
82905: PUSH
82906: LD_VAR 0 1
82910: PUSH
82911: LD_INT 55
82913: PUSH
82914: EMPTY
82915: LIST
82916: PPUSH
82917: CALL_OW 69
82921: IN
82922: ST_TO_ADDR
// end ;
82923: LD_VAR 0 2
82927: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82928: LD_INT 0
82930: PPUSH
82931: PPUSH
// list := [ ] ;
82932: LD_ADDR_VAR 0 5
82936: PUSH
82937: EMPTY
82938: ST_TO_ADDR
// case d of 0 :
82939: LD_VAR 0 3
82943: PUSH
82944: LD_INT 0
82946: DOUBLE
82947: EQUAL
82948: IFTRUE 82952
82950: GO 83085
82952: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82953: LD_ADDR_VAR 0 5
82957: PUSH
82958: LD_VAR 0 1
82962: PUSH
82963: LD_INT 4
82965: MINUS
82966: PUSH
82967: LD_VAR 0 2
82971: PUSH
82972: LD_INT 4
82974: MINUS
82975: PUSH
82976: LD_INT 2
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: LIST
82983: PUSH
82984: LD_VAR 0 1
82988: PUSH
82989: LD_INT 3
82991: MINUS
82992: PUSH
82993: LD_VAR 0 2
82997: PUSH
82998: LD_INT 1
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: LIST
83005: PUSH
83006: LD_VAR 0 1
83010: PUSH
83011: LD_INT 4
83013: PLUS
83014: PUSH
83015: LD_VAR 0 2
83019: PUSH
83020: LD_INT 4
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: LIST
83027: PUSH
83028: LD_VAR 0 1
83032: PUSH
83033: LD_INT 3
83035: PLUS
83036: PUSH
83037: LD_VAR 0 2
83041: PUSH
83042: LD_INT 3
83044: PLUS
83045: PUSH
83046: LD_INT 5
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: LIST
83053: PUSH
83054: LD_VAR 0 1
83058: PUSH
83059: LD_VAR 0 2
83063: PUSH
83064: LD_INT 4
83066: PLUS
83067: PUSH
83068: LD_INT 0
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: LIST
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: ST_TO_ADDR
// end ; 1 :
83083: GO 83783
83085: LD_INT 1
83087: DOUBLE
83088: EQUAL
83089: IFTRUE 83093
83091: GO 83226
83093: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83094: LD_ADDR_VAR 0 5
83098: PUSH
83099: LD_VAR 0 1
83103: PUSH
83104: LD_VAR 0 2
83108: PUSH
83109: LD_INT 4
83111: MINUS
83112: PUSH
83113: LD_INT 3
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: LIST
83120: PUSH
83121: LD_VAR 0 1
83125: PUSH
83126: LD_INT 3
83128: MINUS
83129: PUSH
83130: LD_VAR 0 2
83134: PUSH
83135: LD_INT 3
83137: MINUS
83138: PUSH
83139: LD_INT 2
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: LIST
83146: PUSH
83147: LD_VAR 0 1
83151: PUSH
83152: LD_INT 4
83154: MINUS
83155: PUSH
83156: LD_VAR 0 2
83160: PUSH
83161: LD_INT 1
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: LIST
83168: PUSH
83169: LD_VAR 0 1
83173: PUSH
83174: LD_VAR 0 2
83178: PUSH
83179: LD_INT 3
83181: PLUS
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: LIST
83190: PUSH
83191: LD_VAR 0 1
83195: PUSH
83196: LD_INT 4
83198: PLUS
83199: PUSH
83200: LD_VAR 0 2
83204: PUSH
83205: LD_INT 4
83207: PLUS
83208: PUSH
83209: LD_INT 5
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: LIST
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: ST_TO_ADDR
// end ; 2 :
83224: GO 83783
83226: LD_INT 2
83228: DOUBLE
83229: EQUAL
83230: IFTRUE 83234
83232: GO 83363
83234: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83235: LD_ADDR_VAR 0 5
83239: PUSH
83240: LD_VAR 0 1
83244: PUSH
83245: LD_VAR 0 2
83249: PUSH
83250: LD_INT 3
83252: MINUS
83253: PUSH
83254: LD_INT 3
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: LIST
83261: PUSH
83262: LD_VAR 0 1
83266: PUSH
83267: LD_INT 4
83269: PLUS
83270: PUSH
83271: LD_VAR 0 2
83275: PUSH
83276: LD_INT 4
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: LIST
83283: PUSH
83284: LD_VAR 0 1
83288: PUSH
83289: LD_VAR 0 2
83293: PUSH
83294: LD_INT 4
83296: PLUS
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: LIST
83305: PUSH
83306: LD_VAR 0 1
83310: PUSH
83311: LD_INT 3
83313: MINUS
83314: PUSH
83315: LD_VAR 0 2
83319: PUSH
83320: LD_INT 1
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: LIST
83327: PUSH
83328: LD_VAR 0 1
83332: PUSH
83333: LD_INT 4
83335: MINUS
83336: PUSH
83337: LD_VAR 0 2
83341: PUSH
83342: LD_INT 4
83344: MINUS
83345: PUSH
83346: LD_INT 2
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: LIST
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: ST_TO_ADDR
// end ; 3 :
83361: GO 83783
83363: LD_INT 3
83365: DOUBLE
83366: EQUAL
83367: IFTRUE 83371
83369: GO 83504
83371: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
83372: LD_ADDR_VAR 0 5
83376: PUSH
83377: LD_VAR 0 1
83381: PUSH
83382: LD_INT 3
83384: PLUS
83385: PUSH
83386: LD_VAR 0 2
83390: PUSH
83391: LD_INT 4
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: LIST
83398: PUSH
83399: LD_VAR 0 1
83403: PUSH
83404: LD_INT 4
83406: PLUS
83407: PUSH
83408: LD_VAR 0 2
83412: PUSH
83413: LD_INT 4
83415: PLUS
83416: PUSH
83417: LD_INT 5
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: LIST
83424: PUSH
83425: LD_VAR 0 1
83429: PUSH
83430: LD_INT 4
83432: MINUS
83433: PUSH
83434: LD_VAR 0 2
83438: PUSH
83439: LD_INT 1
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: LIST
83446: PUSH
83447: LD_VAR 0 1
83451: PUSH
83452: LD_VAR 0 2
83456: PUSH
83457: LD_INT 4
83459: MINUS
83460: PUSH
83461: LD_INT 3
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: LIST
83468: PUSH
83469: LD_VAR 0 1
83473: PUSH
83474: LD_INT 3
83476: MINUS
83477: PUSH
83478: LD_VAR 0 2
83482: PUSH
83483: LD_INT 3
83485: MINUS
83486: PUSH
83487: LD_INT 2
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: LIST
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: ST_TO_ADDR
// end ; 4 :
83502: GO 83783
83504: LD_INT 4
83506: DOUBLE
83507: EQUAL
83508: IFTRUE 83512
83510: GO 83645
83512: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83513: LD_ADDR_VAR 0 5
83517: PUSH
83518: LD_VAR 0 1
83522: PUSH
83523: LD_VAR 0 2
83527: PUSH
83528: LD_INT 4
83530: PLUS
83531: PUSH
83532: LD_INT 0
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: LIST
83539: PUSH
83540: LD_VAR 0 1
83544: PUSH
83545: LD_INT 3
83547: PLUS
83548: PUSH
83549: LD_VAR 0 2
83553: PUSH
83554: LD_INT 3
83556: PLUS
83557: PUSH
83558: LD_INT 5
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: LIST
83565: PUSH
83566: LD_VAR 0 1
83570: PUSH
83571: LD_INT 4
83573: PLUS
83574: PUSH
83575: LD_VAR 0 2
83579: PUSH
83580: LD_INT 4
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: LIST
83587: PUSH
83588: LD_VAR 0 1
83592: PUSH
83593: LD_VAR 0 2
83597: PUSH
83598: LD_INT 3
83600: MINUS
83601: PUSH
83602: LD_INT 3
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: LIST
83609: PUSH
83610: LD_VAR 0 1
83614: PUSH
83615: LD_INT 4
83617: MINUS
83618: PUSH
83619: LD_VAR 0 2
83623: PUSH
83624: LD_INT 4
83626: MINUS
83627: PUSH
83628: LD_INT 2
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: LIST
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: ST_TO_ADDR
// end ; 5 :
83643: GO 83783
83645: LD_INT 5
83647: DOUBLE
83648: EQUAL
83649: IFTRUE 83653
83651: GO 83782
83653: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83654: LD_ADDR_VAR 0 5
83658: PUSH
83659: LD_VAR 0 1
83663: PUSH
83664: LD_INT 4
83666: MINUS
83667: PUSH
83668: LD_VAR 0 2
83672: PUSH
83673: LD_INT 1
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: LIST
83680: PUSH
83681: LD_VAR 0 1
83685: PUSH
83686: LD_VAR 0 2
83690: PUSH
83691: LD_INT 4
83693: MINUS
83694: PUSH
83695: LD_INT 3
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: LIST
83702: PUSH
83703: LD_VAR 0 1
83707: PUSH
83708: LD_INT 4
83710: PLUS
83711: PUSH
83712: LD_VAR 0 2
83716: PUSH
83717: LD_INT 4
83719: PLUS
83720: PUSH
83721: LD_INT 5
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: LIST
83728: PUSH
83729: LD_VAR 0 1
83733: PUSH
83734: LD_INT 3
83736: PLUS
83737: PUSH
83738: LD_VAR 0 2
83742: PUSH
83743: LD_INT 4
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: LIST
83750: PUSH
83751: LD_VAR 0 1
83755: PUSH
83756: LD_VAR 0 2
83760: PUSH
83761: LD_INT 3
83763: PLUS
83764: PUSH
83765: LD_INT 0
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: LIST
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: ST_TO_ADDR
// end ; end ;
83780: GO 83783
83782: POP
// result := list ;
83783: LD_ADDR_VAR 0 4
83787: PUSH
83788: LD_VAR 0 5
83792: ST_TO_ADDR
// end ;
83793: LD_VAR 0 4
83797: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83798: LD_INT 0
83800: PPUSH
83801: PPUSH
83802: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83803: LD_VAR 0 1
83807: NOT
83808: PUSH
83809: LD_VAR 0 2
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 2
83819: PUSH
83820: LD_INT 3
83822: PUSH
83823: LD_INT 4
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: IN
83832: NOT
83833: OR
83834: IFFALSE 83838
// exit ;
83836: GO 83930
// tmp := [ ] ;
83838: LD_ADDR_VAR 0 5
83842: PUSH
83843: EMPTY
83844: ST_TO_ADDR
// for i in units do
83845: LD_ADDR_VAR 0 4
83849: PUSH
83850: LD_VAR 0 1
83854: PUSH
83855: FOR_IN
83856: IFFALSE 83899
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83858: LD_ADDR_VAR 0 5
83862: PUSH
83863: LD_VAR 0 5
83867: PPUSH
83868: LD_VAR 0 5
83872: PUSH
83873: LD_INT 1
83875: PLUS
83876: PPUSH
83877: LD_VAR 0 4
83881: PPUSH
83882: LD_VAR 0 2
83886: PPUSH
83887: CALL_OW 259
83891: PPUSH
83892: CALL_OW 2
83896: ST_TO_ADDR
83897: GO 83855
83899: POP
83900: POP
// if not tmp then
83901: LD_VAR 0 5
83905: NOT
83906: IFFALSE 83910
// exit ;
83908: GO 83930
// result := SortListByListDesc ( units , tmp ) ;
83910: LD_ADDR_VAR 0 3
83914: PUSH
83915: LD_VAR 0 1
83919: PPUSH
83920: LD_VAR 0 5
83924: PPUSH
83925: CALL_OW 77
83929: ST_TO_ADDR
// end ;
83930: LD_VAR 0 3
83934: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83935: LD_INT 0
83937: PPUSH
83938: PPUSH
83939: PPUSH
// result := false ;
83940: LD_ADDR_VAR 0 3
83944: PUSH
83945: LD_INT 0
83947: ST_TO_ADDR
// x := GetX ( building ) ;
83948: LD_ADDR_VAR 0 4
83952: PUSH
83953: LD_VAR 0 2
83957: PPUSH
83958: CALL_OW 250
83962: ST_TO_ADDR
// y := GetY ( building ) ;
83963: LD_ADDR_VAR 0 5
83967: PUSH
83968: LD_VAR 0 2
83972: PPUSH
83973: CALL_OW 251
83977: ST_TO_ADDR
// if not building or not x or not y then
83978: LD_VAR 0 2
83982: NOT
83983: PUSH
83984: LD_VAR 0 4
83988: NOT
83989: OR
83990: PUSH
83991: LD_VAR 0 5
83995: NOT
83996: OR
83997: IFFALSE 84001
// exit ;
83999: GO 84093
// if GetTaskList ( unit ) then
84001: LD_VAR 0 1
84005: PPUSH
84006: CALL_OW 437
84010: IFFALSE 84093
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84012: LD_STRING e
84014: PUSH
84015: LD_VAR 0 1
84019: PPUSH
84020: CALL_OW 437
84024: PUSH
84025: LD_INT 1
84027: ARRAY
84028: PUSH
84029: LD_INT 1
84031: ARRAY
84032: EQUAL
84033: PUSH
84034: LD_VAR 0 4
84038: PUSH
84039: LD_VAR 0 1
84043: PPUSH
84044: CALL_OW 437
84048: PUSH
84049: LD_INT 1
84051: ARRAY
84052: PUSH
84053: LD_INT 2
84055: ARRAY
84056: EQUAL
84057: AND
84058: PUSH
84059: LD_VAR 0 5
84063: PUSH
84064: LD_VAR 0 1
84068: PPUSH
84069: CALL_OW 437
84073: PUSH
84074: LD_INT 1
84076: ARRAY
84077: PUSH
84078: LD_INT 3
84080: ARRAY
84081: EQUAL
84082: AND
84083: IFFALSE 84093
// result := true end ;
84085: LD_ADDR_VAR 0 3
84089: PUSH
84090: LD_INT 1
84092: ST_TO_ADDR
// end ;
84093: LD_VAR 0 3
84097: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84098: LD_INT 0
84100: PPUSH
// result := false ;
84101: LD_ADDR_VAR 0 4
84105: PUSH
84106: LD_INT 0
84108: ST_TO_ADDR
// if GetTaskList ( unit ) then
84109: LD_VAR 0 1
84113: PPUSH
84114: CALL_OW 437
84118: IFFALSE 84201
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84120: LD_STRING M
84122: PUSH
84123: LD_VAR 0 1
84127: PPUSH
84128: CALL_OW 437
84132: PUSH
84133: LD_INT 1
84135: ARRAY
84136: PUSH
84137: LD_INT 1
84139: ARRAY
84140: EQUAL
84141: PUSH
84142: LD_VAR 0 2
84146: PUSH
84147: LD_VAR 0 1
84151: PPUSH
84152: CALL_OW 437
84156: PUSH
84157: LD_INT 1
84159: ARRAY
84160: PUSH
84161: LD_INT 2
84163: ARRAY
84164: EQUAL
84165: AND
84166: PUSH
84167: LD_VAR 0 3
84171: PUSH
84172: LD_VAR 0 1
84176: PPUSH
84177: CALL_OW 437
84181: PUSH
84182: LD_INT 1
84184: ARRAY
84185: PUSH
84186: LD_INT 3
84188: ARRAY
84189: EQUAL
84190: AND
84191: IFFALSE 84201
// result := true ;
84193: LD_ADDR_VAR 0 4
84197: PUSH
84198: LD_INT 1
84200: ST_TO_ADDR
// end ; end ;
84201: LD_VAR 0 4
84205: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84206: LD_INT 0
84208: PPUSH
84209: PPUSH
84210: PPUSH
84211: PPUSH
// if not unit or not area then
84212: LD_VAR 0 1
84216: NOT
84217: PUSH
84218: LD_VAR 0 2
84222: NOT
84223: OR
84224: IFFALSE 84228
// exit ;
84226: GO 84392
// tmp := AreaToList ( area , i ) ;
84228: LD_ADDR_VAR 0 6
84232: PUSH
84233: LD_VAR 0 2
84237: PPUSH
84238: LD_VAR 0 5
84242: PPUSH
84243: CALL_OW 517
84247: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84248: LD_ADDR_VAR 0 5
84252: PUSH
84253: DOUBLE
84254: LD_INT 1
84256: DEC
84257: ST_TO_ADDR
84258: LD_VAR 0 6
84262: PUSH
84263: LD_INT 1
84265: ARRAY
84266: PUSH
84267: FOR_TO
84268: IFFALSE 84390
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84270: LD_ADDR_VAR 0 7
84274: PUSH
84275: LD_VAR 0 6
84279: PUSH
84280: LD_INT 1
84282: ARRAY
84283: PUSH
84284: LD_VAR 0 5
84288: ARRAY
84289: PUSH
84290: LD_VAR 0 6
84294: PUSH
84295: LD_INT 2
84297: ARRAY
84298: PUSH
84299: LD_VAR 0 5
84303: ARRAY
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84309: LD_VAR 0 7
84313: PUSH
84314: LD_INT 1
84316: ARRAY
84317: PPUSH
84318: LD_VAR 0 7
84322: PUSH
84323: LD_INT 2
84325: ARRAY
84326: PPUSH
84327: CALL_OW 428
84331: PUSH
84332: LD_INT 0
84334: EQUAL
84335: IFFALSE 84388
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84337: LD_VAR 0 1
84341: PPUSH
84342: LD_VAR 0 7
84346: PUSH
84347: LD_INT 1
84349: ARRAY
84350: PPUSH
84351: LD_VAR 0 7
84355: PUSH
84356: LD_INT 2
84358: ARRAY
84359: PPUSH
84360: LD_VAR 0 3
84364: PPUSH
84365: CALL_OW 48
// result := IsPlaced ( unit ) ;
84369: LD_ADDR_VAR 0 4
84373: PUSH
84374: LD_VAR 0 1
84378: PPUSH
84379: CALL_OW 305
84383: ST_TO_ADDR
// exit ;
84384: POP
84385: POP
84386: GO 84392
// end ; end ;
84388: GO 84267
84390: POP
84391: POP
// end ;
84392: LD_VAR 0 4
84396: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84397: LD_INT 0
84399: PPUSH
84400: PPUSH
84401: PPUSH
// if not side or side > 8 then
84402: LD_VAR 0 1
84406: NOT
84407: PUSH
84408: LD_VAR 0 1
84412: PUSH
84413: LD_INT 8
84415: GREATER
84416: OR
84417: IFFALSE 84421
// exit ;
84419: GO 84608
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84421: LD_ADDR_VAR 0 4
84425: PUSH
84426: LD_INT 22
84428: PUSH
84429: LD_VAR 0 1
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 21
84440: PUSH
84441: LD_INT 3
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: PPUSH
84452: CALL_OW 69
84456: ST_TO_ADDR
// if not tmp then
84457: LD_VAR 0 4
84461: NOT
84462: IFFALSE 84466
// exit ;
84464: GO 84608
// enable_addtolog := true ;
84466: LD_ADDR_OWVAR 81
84470: PUSH
84471: LD_INT 1
84473: ST_TO_ADDR
// AddToLog ( [ ) ;
84474: LD_STRING [
84476: PPUSH
84477: CALL_OW 561
// for i in tmp do
84481: LD_ADDR_VAR 0 3
84485: PUSH
84486: LD_VAR 0 4
84490: PUSH
84491: FOR_IN
84492: IFFALSE 84599
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
84494: LD_STRING [
84496: PUSH
84497: LD_VAR 0 3
84501: PPUSH
84502: CALL_OW 266
84506: STR
84507: PUSH
84508: LD_STRING , 
84510: STR
84511: PUSH
84512: LD_VAR 0 3
84516: PPUSH
84517: CALL_OW 250
84521: STR
84522: PUSH
84523: LD_STRING , 
84525: STR
84526: PUSH
84527: LD_VAR 0 3
84531: PPUSH
84532: CALL_OW 251
84536: STR
84537: PUSH
84538: LD_STRING , 
84540: STR
84541: PUSH
84542: LD_VAR 0 3
84546: PPUSH
84547: CALL_OW 254
84551: STR
84552: PUSH
84553: LD_STRING , 
84555: STR
84556: PUSH
84557: LD_VAR 0 3
84561: PPUSH
84562: LD_INT 1
84564: PPUSH
84565: CALL_OW 268
84569: STR
84570: PUSH
84571: LD_STRING , 
84573: STR
84574: PUSH
84575: LD_VAR 0 3
84579: PPUSH
84580: LD_INT 2
84582: PPUSH
84583: CALL_OW 268
84587: STR
84588: PUSH
84589: LD_STRING ],
84591: STR
84592: PPUSH
84593: CALL_OW 561
// end ;
84597: GO 84491
84599: POP
84600: POP
// AddToLog ( ]; ) ;
84601: LD_STRING ];
84603: PPUSH
84604: CALL_OW 561
// end ;
84608: LD_VAR 0 2
84612: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84613: LD_INT 0
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
// if not area or not rate or not max then
84620: LD_VAR 0 1
84624: NOT
84625: PUSH
84626: LD_VAR 0 2
84630: NOT
84631: OR
84632: PUSH
84633: LD_VAR 0 4
84637: NOT
84638: OR
84639: IFFALSE 84643
// exit ;
84641: GO 84835
// while 1 do
84643: LD_INT 1
84645: IFFALSE 84835
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84647: LD_ADDR_VAR 0 9
84651: PUSH
84652: LD_VAR 0 1
84656: PPUSH
84657: LD_INT 1
84659: PPUSH
84660: CALL_OW 287
84664: PUSH
84665: LD_INT 10
84667: MUL
84668: ST_TO_ADDR
// r := rate / 10 ;
84669: LD_ADDR_VAR 0 7
84673: PUSH
84674: LD_VAR 0 2
84678: PUSH
84679: LD_INT 10
84681: DIVREAL
84682: ST_TO_ADDR
// time := 1 1$00 ;
84683: LD_ADDR_VAR 0 8
84687: PUSH
84688: LD_INT 2100
84690: ST_TO_ADDR
// if amount < min then
84691: LD_VAR 0 9
84695: PUSH
84696: LD_VAR 0 3
84700: LESS
84701: IFFALSE 84719
// r := r * 2 else
84703: LD_ADDR_VAR 0 7
84707: PUSH
84708: LD_VAR 0 7
84712: PUSH
84713: LD_INT 2
84715: MUL
84716: ST_TO_ADDR
84717: GO 84745
// if amount > max then
84719: LD_VAR 0 9
84723: PUSH
84724: LD_VAR 0 4
84728: GREATER
84729: IFFALSE 84745
// r := r / 2 ;
84731: LD_ADDR_VAR 0 7
84735: PUSH
84736: LD_VAR 0 7
84740: PUSH
84741: LD_INT 2
84743: DIVREAL
84744: ST_TO_ADDR
// time := time / r ;
84745: LD_ADDR_VAR 0 8
84749: PUSH
84750: LD_VAR 0 8
84754: PUSH
84755: LD_VAR 0 7
84759: DIVREAL
84760: ST_TO_ADDR
// if time < 0 then
84761: LD_VAR 0 8
84765: PUSH
84766: LD_INT 0
84768: LESS
84769: IFFALSE 84786
// time := time * - 1 ;
84771: LD_ADDR_VAR 0 8
84775: PUSH
84776: LD_VAR 0 8
84780: PUSH
84781: LD_INT 1
84783: NEG
84784: MUL
84785: ST_TO_ADDR
// wait ( time ) ;
84786: LD_VAR 0 8
84790: PPUSH
84791: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
84795: LD_INT 35
84797: PPUSH
84798: LD_INT 875
84800: PPUSH
84801: CALL_OW 12
84805: PPUSH
84806: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84810: LD_INT 1
84812: PPUSH
84813: LD_INT 5
84815: PPUSH
84816: CALL_OW 12
84820: PPUSH
84821: LD_VAR 0 1
84825: PPUSH
84826: LD_INT 1
84828: PPUSH
84829: CALL_OW 55
// end ;
84833: GO 84643
// end ;
84835: LD_VAR 0 5
84839: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84840: LD_INT 0
84842: PPUSH
84843: PPUSH
84844: PPUSH
84845: PPUSH
84846: PPUSH
84847: PPUSH
84848: PPUSH
84849: PPUSH
// if not turrets or not factories then
84850: LD_VAR 0 1
84854: NOT
84855: PUSH
84856: LD_VAR 0 2
84860: NOT
84861: OR
84862: IFFALSE 84866
// exit ;
84864: GO 85173
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84866: LD_ADDR_VAR 0 10
84870: PUSH
84871: LD_INT 5
84873: PUSH
84874: LD_INT 6
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 2
84883: PUSH
84884: LD_INT 4
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 3
84893: PUSH
84894: LD_INT 5
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 24
84908: PUSH
84909: LD_INT 25
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 23
84918: PUSH
84919: LD_INT 27
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 42
84932: PUSH
84933: LD_INT 43
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 44
84942: PUSH
84943: LD_INT 46
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 45
84952: PUSH
84953: LD_INT 47
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: LIST
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: LIST
84969: ST_TO_ADDR
// result := [ ] ;
84970: LD_ADDR_VAR 0 3
84974: PUSH
84975: EMPTY
84976: ST_TO_ADDR
// for i in turrets do
84977: LD_ADDR_VAR 0 4
84981: PUSH
84982: LD_VAR 0 1
84986: PUSH
84987: FOR_IN
84988: IFFALSE 85171
// begin nat := GetNation ( i ) ;
84990: LD_ADDR_VAR 0 7
84994: PUSH
84995: LD_VAR 0 4
84999: PPUSH
85000: CALL_OW 248
85004: ST_TO_ADDR
// weapon := 0 ;
85005: LD_ADDR_VAR 0 8
85009: PUSH
85010: LD_INT 0
85012: ST_TO_ADDR
// if not nat then
85013: LD_VAR 0 7
85017: NOT
85018: IFFALSE 85022
// continue ;
85020: GO 84987
// for j in list [ nat ] do
85022: LD_ADDR_VAR 0 5
85026: PUSH
85027: LD_VAR 0 10
85031: PUSH
85032: LD_VAR 0 7
85036: ARRAY
85037: PUSH
85038: FOR_IN
85039: IFFALSE 85080
// if GetBWeapon ( i ) = j [ 1 ] then
85041: LD_VAR 0 4
85045: PPUSH
85046: CALL_OW 269
85050: PUSH
85051: LD_VAR 0 5
85055: PUSH
85056: LD_INT 1
85058: ARRAY
85059: EQUAL
85060: IFFALSE 85078
// begin weapon := j [ 2 ] ;
85062: LD_ADDR_VAR 0 8
85066: PUSH
85067: LD_VAR 0 5
85071: PUSH
85072: LD_INT 2
85074: ARRAY
85075: ST_TO_ADDR
// break ;
85076: GO 85080
// end ;
85078: GO 85038
85080: POP
85081: POP
// if not weapon then
85082: LD_VAR 0 8
85086: NOT
85087: IFFALSE 85091
// continue ;
85089: GO 84987
// for k in factories do
85091: LD_ADDR_VAR 0 6
85095: PUSH
85096: LD_VAR 0 2
85100: PUSH
85101: FOR_IN
85102: IFFALSE 85167
// begin weapons := AvailableWeaponList ( k ) ;
85104: LD_ADDR_VAR 0 9
85108: PUSH
85109: LD_VAR 0 6
85113: PPUSH
85114: CALL_OW 478
85118: ST_TO_ADDR
// if not weapons then
85119: LD_VAR 0 9
85123: NOT
85124: IFFALSE 85128
// continue ;
85126: GO 85101
// if weapon in weapons then
85128: LD_VAR 0 8
85132: PUSH
85133: LD_VAR 0 9
85137: IN
85138: IFFALSE 85165
// begin result := [ i , weapon ] ;
85140: LD_ADDR_VAR 0 3
85144: PUSH
85145: LD_VAR 0 4
85149: PUSH
85150: LD_VAR 0 8
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: ST_TO_ADDR
// exit ;
85159: POP
85160: POP
85161: POP
85162: POP
85163: GO 85173
// end ; end ;
85165: GO 85101
85167: POP
85168: POP
// end ;
85169: GO 84987
85171: POP
85172: POP
// end ;
85173: LD_VAR 0 3
85177: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85178: LD_INT 0
85180: PPUSH
// if not side or side > 8 then
85181: LD_VAR 0 3
85185: NOT
85186: PUSH
85187: LD_VAR 0 3
85191: PUSH
85192: LD_INT 8
85194: GREATER
85195: OR
85196: IFFALSE 85200
// exit ;
85198: GO 85259
// if not range then
85200: LD_VAR 0 4
85204: NOT
85205: IFFALSE 85216
// range := - 12 ;
85207: LD_ADDR_VAR 0 4
85211: PUSH
85212: LD_INT 12
85214: NEG
85215: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
85216: LD_VAR 0 1
85220: PPUSH
85221: LD_VAR 0 2
85225: PPUSH
85226: LD_VAR 0 3
85230: PPUSH
85231: LD_VAR 0 4
85235: PPUSH
85236: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85240: LD_VAR 0 1
85244: PPUSH
85245: LD_VAR 0 2
85249: PPUSH
85250: LD_VAR 0 3
85254: PPUSH
85255: CALL_OW 331
// end ;
85259: LD_VAR 0 5
85263: RET
// export function Video ( mode ) ; begin
85264: LD_INT 0
85266: PPUSH
// ingame_video = mode ;
85267: LD_ADDR_OWVAR 52
85271: PUSH
85272: LD_VAR 0 1
85276: ST_TO_ADDR
// interface_hidden = mode ;
85277: LD_ADDR_OWVAR 54
85281: PUSH
85282: LD_VAR 0 1
85286: ST_TO_ADDR
// end ;
85287: LD_VAR 0 2
85291: RET
// export function Join ( array , element ) ; begin
85292: LD_INT 0
85294: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85295: LD_ADDR_VAR 0 3
85299: PUSH
85300: LD_VAR 0 1
85304: PPUSH
85305: LD_VAR 0 1
85309: PUSH
85310: LD_INT 1
85312: PLUS
85313: PPUSH
85314: LD_VAR 0 2
85318: PPUSH
85319: CALL_OW 1
85323: ST_TO_ADDR
// end ;
85324: LD_VAR 0 3
85328: RET
// export function JoinUnion ( array , element ) ; begin
85329: LD_INT 0
85331: PPUSH
// result := array union element ;
85332: LD_ADDR_VAR 0 3
85336: PUSH
85337: LD_VAR 0 1
85341: PUSH
85342: LD_VAR 0 2
85346: UNION
85347: ST_TO_ADDR
// end ;
85348: LD_VAR 0 3
85352: RET
// export function GetBehemoths ( side ) ; begin
85353: LD_INT 0
85355: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
85356: LD_ADDR_VAR 0 2
85360: PUSH
85361: LD_INT 22
85363: PUSH
85364: LD_VAR 0 1
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 31
85375: PUSH
85376: LD_INT 25
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PPUSH
85387: CALL_OW 69
85391: ST_TO_ADDR
// end ;
85392: LD_VAR 0 2
85396: RET
// export function Shuffle ( array ) ; var i , index ; begin
85397: LD_INT 0
85399: PPUSH
85400: PPUSH
85401: PPUSH
// result := [ ] ;
85402: LD_ADDR_VAR 0 2
85406: PUSH
85407: EMPTY
85408: ST_TO_ADDR
// if not array then
85409: LD_VAR 0 1
85413: NOT
85414: IFFALSE 85418
// exit ;
85416: GO 85517
// Randomize ;
85418: CALL_OW 10
// for i = array downto 1 do
85422: LD_ADDR_VAR 0 3
85426: PUSH
85427: DOUBLE
85428: LD_VAR 0 1
85432: INC
85433: ST_TO_ADDR
85434: LD_INT 1
85436: PUSH
85437: FOR_DOWNTO
85438: IFFALSE 85515
// begin index := rand ( 1 , array ) ;
85440: LD_ADDR_VAR 0 4
85444: PUSH
85445: LD_INT 1
85447: PPUSH
85448: LD_VAR 0 1
85452: PPUSH
85453: CALL_OW 12
85457: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
85458: LD_ADDR_VAR 0 2
85462: PUSH
85463: LD_VAR 0 2
85467: PPUSH
85468: LD_VAR 0 2
85472: PUSH
85473: LD_INT 1
85475: PLUS
85476: PPUSH
85477: LD_VAR 0 1
85481: PUSH
85482: LD_VAR 0 4
85486: ARRAY
85487: PPUSH
85488: CALL_OW 2
85492: ST_TO_ADDR
// array := Delete ( array , index ) ;
85493: LD_ADDR_VAR 0 1
85497: PUSH
85498: LD_VAR 0 1
85502: PPUSH
85503: LD_VAR 0 4
85507: PPUSH
85508: CALL_OW 3
85512: ST_TO_ADDR
// end ;
85513: GO 85437
85515: POP
85516: POP
// end ;
85517: LD_VAR 0 2
85521: RET
// export function GetBaseMaterials ( base ) ; begin
85522: LD_INT 0
85524: PPUSH
// result := [ 0 , 0 , 0 ] ;
85525: LD_ADDR_VAR 0 2
85529: PUSH
85530: LD_INT 0
85532: PUSH
85533: LD_INT 0
85535: PUSH
85536: LD_INT 0
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: LIST
85543: ST_TO_ADDR
// if not base then
85544: LD_VAR 0 1
85548: NOT
85549: IFFALSE 85553
// exit ;
85551: GO 85602
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
85553: LD_ADDR_VAR 0 2
85557: PUSH
85558: LD_VAR 0 1
85562: PPUSH
85563: LD_INT 1
85565: PPUSH
85566: CALL_OW 275
85570: PUSH
85571: LD_VAR 0 1
85575: PPUSH
85576: LD_INT 2
85578: PPUSH
85579: CALL_OW 275
85583: PUSH
85584: LD_VAR 0 1
85588: PPUSH
85589: LD_INT 3
85591: PPUSH
85592: CALL_OW 275
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: LIST
85601: ST_TO_ADDR
// end ;
85602: LD_VAR 0 2
85606: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
85607: LD_INT 0
85609: PPUSH
85610: PPUSH
// result := array ;
85611: LD_ADDR_VAR 0 3
85615: PUSH
85616: LD_VAR 0 1
85620: ST_TO_ADDR
// if size > 0 then
85621: LD_VAR 0 2
85625: PUSH
85626: LD_INT 0
85628: GREATER
85629: IFFALSE 85675
// for i := array downto size do
85631: LD_ADDR_VAR 0 4
85635: PUSH
85636: DOUBLE
85637: LD_VAR 0 1
85641: INC
85642: ST_TO_ADDR
85643: LD_VAR 0 2
85647: PUSH
85648: FOR_DOWNTO
85649: IFFALSE 85673
// result := Delete ( result , result ) ;
85651: LD_ADDR_VAR 0 3
85655: PUSH
85656: LD_VAR 0 3
85660: PPUSH
85661: LD_VAR 0 3
85665: PPUSH
85666: CALL_OW 3
85670: ST_TO_ADDR
85671: GO 85648
85673: POP
85674: POP
// end ;
85675: LD_VAR 0 3
85679: RET
// export function ComExit ( unit ) ; var tmp ; begin
85680: LD_INT 0
85682: PPUSH
85683: PPUSH
// if not IsInUnit ( unit ) then
85684: LD_VAR 0 1
85688: PPUSH
85689: CALL_OW 310
85693: NOT
85694: IFFALSE 85698
// exit ;
85696: GO 85758
// tmp := IsInUnit ( unit ) ;
85698: LD_ADDR_VAR 0 3
85702: PUSH
85703: LD_VAR 0 1
85707: PPUSH
85708: CALL_OW 310
85712: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
85713: LD_VAR 0 3
85717: PPUSH
85718: CALL_OW 247
85722: PUSH
85723: LD_INT 2
85725: EQUAL
85726: IFFALSE 85739
// ComExitVehicle ( unit ) else
85728: LD_VAR 0 1
85732: PPUSH
85733: CALL_OW 121
85737: GO 85748
// ComExitBuilding ( unit ) ;
85739: LD_VAR 0 1
85743: PPUSH
85744: CALL_OW 122
// result := tmp ;
85748: LD_ADDR_VAR 0 2
85752: PUSH
85753: LD_VAR 0 3
85757: ST_TO_ADDR
// end ;
85758: LD_VAR 0 2
85762: RET
// export function ComExitAll ( units ) ; var i ; begin
85763: LD_INT 0
85765: PPUSH
85766: PPUSH
// if not units then
85767: LD_VAR 0 1
85771: NOT
85772: IFFALSE 85776
// exit ;
85774: GO 85802
// for i in units do
85776: LD_ADDR_VAR 0 3
85780: PUSH
85781: LD_VAR 0 1
85785: PUSH
85786: FOR_IN
85787: IFFALSE 85800
// ComExit ( i ) ;
85789: LD_VAR 0 3
85793: PPUSH
85794: CALL 85680 0 1
85798: GO 85786
85800: POP
85801: POP
// end ;
85802: LD_VAR 0 2
85806: RET
// export function ResetHc ; begin
85807: LD_INT 0
85809: PPUSH
// InitHc ;
85810: CALL_OW 19
// hc_importance := 0 ;
85814: LD_ADDR_OWVAR 32
85818: PUSH
85819: LD_INT 0
85821: ST_TO_ADDR
// end ;
85822: LD_VAR 0 1
85826: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
85827: LD_INT 0
85829: PPUSH
85830: PPUSH
85831: PPUSH
// _x := ( x1 + x2 ) div 2 ;
85832: LD_ADDR_VAR 0 6
85836: PUSH
85837: LD_VAR 0 1
85841: PUSH
85842: LD_VAR 0 3
85846: PLUS
85847: PUSH
85848: LD_INT 2
85850: DIV
85851: ST_TO_ADDR
// if _x < 0 then
85852: LD_VAR 0 6
85856: PUSH
85857: LD_INT 0
85859: LESS
85860: IFFALSE 85877
// _x := _x * - 1 ;
85862: LD_ADDR_VAR 0 6
85866: PUSH
85867: LD_VAR 0 6
85871: PUSH
85872: LD_INT 1
85874: NEG
85875: MUL
85876: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85877: LD_ADDR_VAR 0 7
85881: PUSH
85882: LD_VAR 0 2
85886: PUSH
85887: LD_VAR 0 4
85891: PLUS
85892: PUSH
85893: LD_INT 2
85895: DIV
85896: ST_TO_ADDR
// if _y < 0 then
85897: LD_VAR 0 7
85901: PUSH
85902: LD_INT 0
85904: LESS
85905: IFFALSE 85922
// _y := _y * - 1 ;
85907: LD_ADDR_VAR 0 7
85911: PUSH
85912: LD_VAR 0 7
85916: PUSH
85917: LD_INT 1
85919: NEG
85920: MUL
85921: ST_TO_ADDR
// result := [ _x , _y ] ;
85922: LD_ADDR_VAR 0 5
85926: PUSH
85927: LD_VAR 0 6
85931: PUSH
85932: LD_VAR 0 7
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: ST_TO_ADDR
// end ;
85941: LD_VAR 0 5
85945: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85946: LD_INT 0
85948: PPUSH
85949: PPUSH
85950: PPUSH
85951: PPUSH
// task := GetTaskList ( unit ) ;
85952: LD_ADDR_VAR 0 7
85956: PUSH
85957: LD_VAR 0 1
85961: PPUSH
85962: CALL_OW 437
85966: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85967: LD_VAR 0 7
85971: NOT
85972: PUSH
85973: LD_VAR 0 1
85977: PPUSH
85978: LD_VAR 0 2
85982: PPUSH
85983: CALL_OW 308
85987: NOT
85988: AND
85989: IFFALSE 85993
// exit ;
85991: GO 86111
// if IsInArea ( unit , area ) then
85993: LD_VAR 0 1
85997: PPUSH
85998: LD_VAR 0 2
86002: PPUSH
86003: CALL_OW 308
86007: IFFALSE 86025
// begin ComMoveToArea ( unit , goAway ) ;
86009: LD_VAR 0 1
86013: PPUSH
86014: LD_VAR 0 3
86018: PPUSH
86019: CALL_OW 113
// exit ;
86023: GO 86111
// end ; if task [ 1 ] [ 1 ] <> M then
86025: LD_VAR 0 7
86029: PUSH
86030: LD_INT 1
86032: ARRAY
86033: PUSH
86034: LD_INT 1
86036: ARRAY
86037: PUSH
86038: LD_STRING M
86040: NONEQUAL
86041: IFFALSE 86045
// exit ;
86043: GO 86111
// x := task [ 1 ] [ 2 ] ;
86045: LD_ADDR_VAR 0 5
86049: PUSH
86050: LD_VAR 0 7
86054: PUSH
86055: LD_INT 1
86057: ARRAY
86058: PUSH
86059: LD_INT 2
86061: ARRAY
86062: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86063: LD_ADDR_VAR 0 6
86067: PUSH
86068: LD_VAR 0 7
86072: PUSH
86073: LD_INT 1
86075: ARRAY
86076: PUSH
86077: LD_INT 3
86079: ARRAY
86080: ST_TO_ADDR
// if InArea ( x , y , area ) then
86081: LD_VAR 0 5
86085: PPUSH
86086: LD_VAR 0 6
86090: PPUSH
86091: LD_VAR 0 2
86095: PPUSH
86096: CALL_OW 309
86100: IFFALSE 86111
// ComStop ( unit ) ;
86102: LD_VAR 0 1
86106: PPUSH
86107: CALL_OW 141
// end ;
86111: LD_VAR 0 4
86115: RET
// export function Abs ( value ) ; begin
86116: LD_INT 0
86118: PPUSH
// result := value ;
86119: LD_ADDR_VAR 0 2
86123: PUSH
86124: LD_VAR 0 1
86128: ST_TO_ADDR
// if value < 0 then
86129: LD_VAR 0 1
86133: PUSH
86134: LD_INT 0
86136: LESS
86137: IFFALSE 86154
// result := value * - 1 ;
86139: LD_ADDR_VAR 0 2
86143: PUSH
86144: LD_VAR 0 1
86148: PUSH
86149: LD_INT 1
86151: NEG
86152: MUL
86153: ST_TO_ADDR
// end ;
86154: LD_VAR 0 2
86158: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86159: LD_INT 0
86161: PPUSH
86162: PPUSH
86163: PPUSH
86164: PPUSH
86165: PPUSH
86166: PPUSH
86167: PPUSH
86168: PPUSH
// if not unit or not building then
86169: LD_VAR 0 1
86173: NOT
86174: PUSH
86175: LD_VAR 0 2
86179: NOT
86180: OR
86181: IFFALSE 86185
// exit ;
86183: GO 86411
// x := GetX ( building ) ;
86185: LD_ADDR_VAR 0 4
86189: PUSH
86190: LD_VAR 0 2
86194: PPUSH
86195: CALL_OW 250
86199: ST_TO_ADDR
// y := GetY ( building ) ;
86200: LD_ADDR_VAR 0 6
86204: PUSH
86205: LD_VAR 0 2
86209: PPUSH
86210: CALL_OW 251
86214: ST_TO_ADDR
// d := GetDir ( building ) ;
86215: LD_ADDR_VAR 0 8
86219: PUSH
86220: LD_VAR 0 2
86224: PPUSH
86225: CALL_OW 254
86229: ST_TO_ADDR
// r := 4 ;
86230: LD_ADDR_VAR 0 9
86234: PUSH
86235: LD_INT 4
86237: ST_TO_ADDR
// for i := 1 to 5 do
86238: LD_ADDR_VAR 0 10
86242: PUSH
86243: DOUBLE
86244: LD_INT 1
86246: DEC
86247: ST_TO_ADDR
86248: LD_INT 5
86250: PUSH
86251: FOR_TO
86252: IFFALSE 86409
// begin _x := ShiftX ( x , d , r + i ) ;
86254: LD_ADDR_VAR 0 5
86258: PUSH
86259: LD_VAR 0 4
86263: PPUSH
86264: LD_VAR 0 8
86268: PPUSH
86269: LD_VAR 0 9
86273: PUSH
86274: LD_VAR 0 10
86278: PLUS
86279: PPUSH
86280: CALL_OW 272
86284: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86285: LD_ADDR_VAR 0 7
86289: PUSH
86290: LD_VAR 0 6
86294: PPUSH
86295: LD_VAR 0 8
86299: PPUSH
86300: LD_VAR 0 9
86304: PUSH
86305: LD_VAR 0 10
86309: PLUS
86310: PPUSH
86311: CALL_OW 273
86315: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
86316: LD_VAR 0 5
86320: PPUSH
86321: LD_VAR 0 7
86325: PPUSH
86326: CALL_OW 488
86330: PUSH
86331: LD_VAR 0 5
86335: PPUSH
86336: LD_VAR 0 7
86340: PPUSH
86341: CALL_OW 428
86345: PPUSH
86346: CALL_OW 247
86350: PUSH
86351: LD_INT 3
86353: PUSH
86354: LD_INT 2
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: IN
86361: NOT
86362: AND
86363: IFFALSE 86407
// begin ComMoveXY ( unit , _x , _y ) ;
86365: LD_VAR 0 1
86369: PPUSH
86370: LD_VAR 0 5
86374: PPUSH
86375: LD_VAR 0 7
86379: PPUSH
86380: CALL_OW 111
// result := [ _x , _y ] ;
86384: LD_ADDR_VAR 0 3
86388: PUSH
86389: LD_VAR 0 5
86393: PUSH
86394: LD_VAR 0 7
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: ST_TO_ADDR
// exit ;
86403: POP
86404: POP
86405: GO 86411
// end ; end ;
86407: GO 86251
86409: POP
86410: POP
// end ;
86411: LD_VAR 0 3
86415: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
86416: LD_INT 0
86418: PPUSH
86419: PPUSH
86420: PPUSH
// result := 0 ;
86421: LD_ADDR_VAR 0 3
86425: PUSH
86426: LD_INT 0
86428: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
86429: LD_VAR 0 1
86433: PUSH
86434: LD_INT 0
86436: LESS
86437: PUSH
86438: LD_VAR 0 1
86442: PUSH
86443: LD_INT 8
86445: GREATER
86446: OR
86447: PUSH
86448: LD_VAR 0 2
86452: PUSH
86453: LD_INT 0
86455: LESS
86456: OR
86457: PUSH
86458: LD_VAR 0 2
86462: PUSH
86463: LD_INT 8
86465: GREATER
86466: OR
86467: IFFALSE 86471
// exit ;
86469: GO 86546
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
86471: LD_ADDR_VAR 0 4
86475: PUSH
86476: LD_INT 22
86478: PUSH
86479: LD_VAR 0 2
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PPUSH
86488: CALL_OW 69
86492: PUSH
86493: FOR_IN
86494: IFFALSE 86544
// begin un := UnitShoot ( i ) ;
86496: LD_ADDR_VAR 0 5
86500: PUSH
86501: LD_VAR 0 4
86505: PPUSH
86506: CALL_OW 504
86510: ST_TO_ADDR
// if GetSide ( un ) = side1 then
86511: LD_VAR 0 5
86515: PPUSH
86516: CALL_OW 255
86520: PUSH
86521: LD_VAR 0 1
86525: EQUAL
86526: IFFALSE 86542
// begin result := un ;
86528: LD_ADDR_VAR 0 3
86532: PUSH
86533: LD_VAR 0 5
86537: ST_TO_ADDR
// exit ;
86538: POP
86539: POP
86540: GO 86546
// end ; end ;
86542: GO 86493
86544: POP
86545: POP
// end ;
86546: LD_VAR 0 3
86550: RET
// export function GetCargoBay ( units ) ; begin
86551: LD_INT 0
86553: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
86554: LD_ADDR_VAR 0 2
86558: PUSH
86559: LD_VAR 0 1
86563: PPUSH
86564: LD_INT 2
86566: PUSH
86567: LD_INT 34
86569: PUSH
86570: LD_INT 12
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 34
86579: PUSH
86580: LD_INT 51
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 34
86589: PUSH
86590: LD_INT 32
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 34
86599: PUSH
86600: LD_EXP 95
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: LIST
86613: LIST
86614: LIST
86615: PPUSH
86616: CALL_OW 72
86620: ST_TO_ADDR
// end ;
86621: LD_VAR 0 2
86625: RET
// export function Negate ( value ) ; begin
86626: LD_INT 0
86628: PPUSH
// result := not value ;
86629: LD_ADDR_VAR 0 2
86633: PUSH
86634: LD_VAR 0 1
86638: NOT
86639: ST_TO_ADDR
// end ;
86640: LD_VAR 0 2
86644: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
86645: LD_INT 0
86647: PPUSH
// if x1 = x2 then
86648: LD_VAR 0 1
86652: PUSH
86653: LD_VAR 0 3
86657: EQUAL
86658: IFFALSE 86692
// begin if y1 > y2 then
86660: LD_VAR 0 2
86664: PUSH
86665: LD_VAR 0 4
86669: GREATER
86670: IFFALSE 86682
// result := 0 else
86672: LD_ADDR_VAR 0 5
86676: PUSH
86677: LD_INT 0
86679: ST_TO_ADDR
86680: GO 86690
// result := 3 ;
86682: LD_ADDR_VAR 0 5
86686: PUSH
86687: LD_INT 3
86689: ST_TO_ADDR
// exit ;
86690: GO 86778
// end ; if y1 = y2 then
86692: LD_VAR 0 2
86696: PUSH
86697: LD_VAR 0 4
86701: EQUAL
86702: IFFALSE 86736
// begin if x1 > x2 then
86704: LD_VAR 0 1
86708: PUSH
86709: LD_VAR 0 3
86713: GREATER
86714: IFFALSE 86726
// result := 1 else
86716: LD_ADDR_VAR 0 5
86720: PUSH
86721: LD_INT 1
86723: ST_TO_ADDR
86724: GO 86734
// result := 4 ;
86726: LD_ADDR_VAR 0 5
86730: PUSH
86731: LD_INT 4
86733: ST_TO_ADDR
// exit ;
86734: GO 86778
// end ; if x1 > x2 and y1 > y2 then
86736: LD_VAR 0 1
86740: PUSH
86741: LD_VAR 0 3
86745: GREATER
86746: PUSH
86747: LD_VAR 0 2
86751: PUSH
86752: LD_VAR 0 4
86756: GREATER
86757: AND
86758: IFFALSE 86770
// result := 2 else
86760: LD_ADDR_VAR 0 5
86764: PUSH
86765: LD_INT 2
86767: ST_TO_ADDR
86768: GO 86778
// result := 5 ;
86770: LD_ADDR_VAR 0 5
86774: PUSH
86775: LD_INT 5
86777: ST_TO_ADDR
// end ;
86778: LD_VAR 0 5
86782: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86783: LD_INT 0
86785: PPUSH
86786: PPUSH
// if not driver or not IsInUnit ( driver ) then
86787: LD_VAR 0 1
86791: NOT
86792: PUSH
86793: LD_VAR 0 1
86797: PPUSH
86798: CALL_OW 310
86802: NOT
86803: OR
86804: IFFALSE 86808
// exit ;
86806: GO 86898
// vehicle := IsInUnit ( driver ) ;
86808: LD_ADDR_VAR 0 3
86812: PUSH
86813: LD_VAR 0 1
86817: PPUSH
86818: CALL_OW 310
86822: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86823: LD_VAR 0 1
86827: PPUSH
86828: LD_STRING \
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: LD_INT 0
86836: PUSH
86837: LD_INT 0
86839: PUSH
86840: LD_INT 0
86842: PUSH
86843: LD_INT 0
86845: PUSH
86846: LD_INT 0
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: PUSH
86858: LD_STRING E
86860: PUSH
86861: LD_INT 0
86863: PUSH
86864: LD_INT 0
86866: PUSH
86867: LD_VAR 0 3
86871: PUSH
86872: LD_INT 0
86874: PUSH
86875: LD_INT 0
86877: PUSH
86878: LD_INT 0
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PPUSH
86894: CALL_OW 446
// end ;
86898: LD_VAR 0 2
86902: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86903: LD_INT 0
86905: PPUSH
86906: PPUSH
// if not driver or not IsInUnit ( driver ) then
86907: LD_VAR 0 1
86911: NOT
86912: PUSH
86913: LD_VAR 0 1
86917: PPUSH
86918: CALL_OW 310
86922: NOT
86923: OR
86924: IFFALSE 86928
// exit ;
86926: GO 87018
// vehicle := IsInUnit ( driver ) ;
86928: LD_ADDR_VAR 0 3
86932: PUSH
86933: LD_VAR 0 1
86937: PPUSH
86938: CALL_OW 310
86942: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86943: LD_VAR 0 1
86947: PPUSH
86948: LD_STRING \
86950: PUSH
86951: LD_INT 0
86953: PUSH
86954: LD_INT 0
86956: PUSH
86957: LD_INT 0
86959: PUSH
86960: LD_INT 0
86962: PUSH
86963: LD_INT 0
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: PUSH
86978: LD_STRING E
86980: PUSH
86981: LD_INT 0
86983: PUSH
86984: LD_INT 0
86986: PUSH
86987: LD_VAR 0 3
86991: PUSH
86992: LD_INT 0
86994: PUSH
86995: LD_INT 0
86997: PUSH
86998: LD_INT 0
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PPUSH
87014: CALL_OW 447
// end ;
87018: LD_VAR 0 2
87022: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
87023: LD_INT 0
87025: PPUSH
87026: PPUSH
87027: PPUSH
// tmp := [ ] ;
87028: LD_ADDR_VAR 0 5
87032: PUSH
87033: EMPTY
87034: ST_TO_ADDR
// for i in units do
87035: LD_ADDR_VAR 0 4
87039: PUSH
87040: LD_VAR 0 1
87044: PUSH
87045: FOR_IN
87046: IFFALSE 87084
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
87048: LD_ADDR_VAR 0 5
87052: PUSH
87053: LD_VAR 0 5
87057: PPUSH
87058: LD_VAR 0 5
87062: PUSH
87063: LD_INT 1
87065: PLUS
87066: PPUSH
87067: LD_VAR 0 4
87071: PPUSH
87072: CALL_OW 256
87076: PPUSH
87077: CALL_OW 2
87081: ST_TO_ADDR
87082: GO 87045
87084: POP
87085: POP
// if not tmp then
87086: LD_VAR 0 5
87090: NOT
87091: IFFALSE 87095
// exit ;
87093: GO 87143
// if asc then
87095: LD_VAR 0 2
87099: IFFALSE 87123
// result := SortListByListAsc ( units , tmp ) else
87101: LD_ADDR_VAR 0 3
87105: PUSH
87106: LD_VAR 0 1
87110: PPUSH
87111: LD_VAR 0 5
87115: PPUSH
87116: CALL_OW 76
87120: ST_TO_ADDR
87121: GO 87143
// result := SortListByListDesc ( units , tmp ) ;
87123: LD_ADDR_VAR 0 3
87127: PUSH
87128: LD_VAR 0 1
87132: PPUSH
87133: LD_VAR 0 5
87137: PPUSH
87138: CALL_OW 77
87142: ST_TO_ADDR
// end ;
87143: LD_VAR 0 3
87147: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
87148: LD_INT 0
87150: PPUSH
87151: PPUSH
// task := GetTaskList ( mech ) ;
87152: LD_ADDR_VAR 0 4
87156: PUSH
87157: LD_VAR 0 1
87161: PPUSH
87162: CALL_OW 437
87166: ST_TO_ADDR
// if not task then
87167: LD_VAR 0 4
87171: NOT
87172: IFFALSE 87176
// exit ;
87174: GO 87218
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
87176: LD_ADDR_VAR 0 3
87180: PUSH
87181: LD_VAR 0 4
87185: PUSH
87186: LD_INT 1
87188: ARRAY
87189: PUSH
87190: LD_INT 1
87192: ARRAY
87193: PUSH
87194: LD_STRING r
87196: EQUAL
87197: PUSH
87198: LD_VAR 0 4
87202: PUSH
87203: LD_INT 1
87205: ARRAY
87206: PUSH
87207: LD_INT 4
87209: ARRAY
87210: PUSH
87211: LD_VAR 0 2
87215: EQUAL
87216: AND
87217: ST_TO_ADDR
// end ;
87218: LD_VAR 0 3
87222: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
87223: LD_INT 0
87225: PPUSH
// SetDir ( unit , d ) ;
87226: LD_VAR 0 1
87230: PPUSH
87231: LD_VAR 0 4
87235: PPUSH
87236: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
87240: LD_VAR 0 1
87244: PPUSH
87245: LD_VAR 0 2
87249: PPUSH
87250: LD_VAR 0 3
87254: PPUSH
87255: LD_VAR 0 5
87259: PPUSH
87260: CALL_OW 48
// end ;
87264: LD_VAR 0 6
87268: RET
// export function ToNaturalNumber ( number ) ; begin
87269: LD_INT 0
87271: PPUSH
// result := number div 1 ;
87272: LD_ADDR_VAR 0 2
87276: PUSH
87277: LD_VAR 0 1
87281: PUSH
87282: LD_INT 1
87284: DIV
87285: ST_TO_ADDR
// if number < 0 then
87286: LD_VAR 0 1
87290: PUSH
87291: LD_INT 0
87293: LESS
87294: IFFALSE 87304
// result := 0 ;
87296: LD_ADDR_VAR 0 2
87300: PUSH
87301: LD_INT 0
87303: ST_TO_ADDR
// end ;
87304: LD_VAR 0 2
87308: RET
// export function SortByClass ( units , class ) ; var un ; begin
87309: LD_INT 0
87311: PPUSH
87312: PPUSH
// if not units or not class then
87313: LD_VAR 0 1
87317: NOT
87318: PUSH
87319: LD_VAR 0 2
87323: NOT
87324: OR
87325: IFFALSE 87329
// exit ;
87327: GO 87424
// result := [ ] ;
87329: LD_ADDR_VAR 0 3
87333: PUSH
87334: EMPTY
87335: ST_TO_ADDR
// for un in units do
87336: LD_ADDR_VAR 0 4
87340: PUSH
87341: LD_VAR 0 1
87345: PUSH
87346: FOR_IN
87347: IFFALSE 87422
// if GetClass ( un ) = class then
87349: LD_VAR 0 4
87353: PPUSH
87354: CALL_OW 257
87358: PUSH
87359: LD_VAR 0 2
87363: EQUAL
87364: IFFALSE 87391
// result := Insert ( result , 1 , un ) else
87366: LD_ADDR_VAR 0 3
87370: PUSH
87371: LD_VAR 0 3
87375: PPUSH
87376: LD_INT 1
87378: PPUSH
87379: LD_VAR 0 4
87383: PPUSH
87384: CALL_OW 2
87388: ST_TO_ADDR
87389: GO 87420
// result := Replace ( result , result + 1 , un ) ;
87391: LD_ADDR_VAR 0 3
87395: PUSH
87396: LD_VAR 0 3
87400: PPUSH
87401: LD_VAR 0 3
87405: PUSH
87406: LD_INT 1
87408: PLUS
87409: PPUSH
87410: LD_VAR 0 4
87414: PPUSH
87415: CALL_OW 1
87419: ST_TO_ADDR
87420: GO 87346
87422: POP
87423: POP
// end ;
87424: LD_VAR 0 3
87428: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
87429: LD_INT 0
87431: PPUSH
87432: PPUSH
87433: PPUSH
87434: PPUSH
87435: PPUSH
87436: PPUSH
87437: PPUSH
// result := [ ] ;
87438: LD_ADDR_VAR 0 4
87442: PUSH
87443: EMPTY
87444: ST_TO_ADDR
// if x - r < 0 then
87445: LD_VAR 0 1
87449: PUSH
87450: LD_VAR 0 3
87454: MINUS
87455: PUSH
87456: LD_INT 0
87458: LESS
87459: IFFALSE 87471
// min_x := 0 else
87461: LD_ADDR_VAR 0 8
87465: PUSH
87466: LD_INT 0
87468: ST_TO_ADDR
87469: GO 87487
// min_x := x - r ;
87471: LD_ADDR_VAR 0 8
87475: PUSH
87476: LD_VAR 0 1
87480: PUSH
87481: LD_VAR 0 3
87485: MINUS
87486: ST_TO_ADDR
// if y - r < 0 then
87487: LD_VAR 0 2
87491: PUSH
87492: LD_VAR 0 3
87496: MINUS
87497: PUSH
87498: LD_INT 0
87500: LESS
87501: IFFALSE 87513
// min_y := 0 else
87503: LD_ADDR_VAR 0 7
87507: PUSH
87508: LD_INT 0
87510: ST_TO_ADDR
87511: GO 87529
// min_y := y - r ;
87513: LD_ADDR_VAR 0 7
87517: PUSH
87518: LD_VAR 0 2
87522: PUSH
87523: LD_VAR 0 3
87527: MINUS
87528: ST_TO_ADDR
// max_x := x + r ;
87529: LD_ADDR_VAR 0 9
87533: PUSH
87534: LD_VAR 0 1
87538: PUSH
87539: LD_VAR 0 3
87543: PLUS
87544: ST_TO_ADDR
// max_y := y + r ;
87545: LD_ADDR_VAR 0 10
87549: PUSH
87550: LD_VAR 0 2
87554: PUSH
87555: LD_VAR 0 3
87559: PLUS
87560: ST_TO_ADDR
// for _x = min_x to max_x do
87561: LD_ADDR_VAR 0 5
87565: PUSH
87566: DOUBLE
87567: LD_VAR 0 8
87571: DEC
87572: ST_TO_ADDR
87573: LD_VAR 0 9
87577: PUSH
87578: FOR_TO
87579: IFFALSE 87680
// for _y = min_y to max_y do
87581: LD_ADDR_VAR 0 6
87585: PUSH
87586: DOUBLE
87587: LD_VAR 0 7
87591: DEC
87592: ST_TO_ADDR
87593: LD_VAR 0 10
87597: PUSH
87598: FOR_TO
87599: IFFALSE 87676
// begin if not ValidHex ( _x , _y ) then
87601: LD_VAR 0 5
87605: PPUSH
87606: LD_VAR 0 6
87610: PPUSH
87611: CALL_OW 488
87615: NOT
87616: IFFALSE 87620
// continue ;
87618: GO 87598
// if GetResourceTypeXY ( _x , _y ) then
87620: LD_VAR 0 5
87624: PPUSH
87625: LD_VAR 0 6
87629: PPUSH
87630: CALL_OW 283
87634: IFFALSE 87674
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
87636: LD_ADDR_VAR 0 4
87640: PUSH
87641: LD_VAR 0 4
87645: PPUSH
87646: LD_VAR 0 4
87650: PUSH
87651: LD_INT 1
87653: PLUS
87654: PPUSH
87655: LD_VAR 0 5
87659: PUSH
87660: LD_VAR 0 6
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PPUSH
87669: CALL_OW 1
87673: ST_TO_ADDR
// end ;
87674: GO 87598
87676: POP
87677: POP
87678: GO 87578
87680: POP
87681: POP
// end ;
87682: LD_VAR 0 4
87686: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
87687: LD_INT 0
87689: PPUSH
87690: PPUSH
87691: PPUSH
87692: PPUSH
87693: PPUSH
87694: PPUSH
// if not units then
87695: LD_VAR 0 1
87699: NOT
87700: IFFALSE 87704
// exit ;
87702: GO 88105
// result := UnitFilter ( units , [ f_ok ] ) ;
87704: LD_ADDR_VAR 0 3
87708: PUSH
87709: LD_VAR 0 1
87713: PPUSH
87714: LD_INT 50
87716: PUSH
87717: EMPTY
87718: LIST
87719: PPUSH
87720: CALL_OW 72
87724: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
87725: LD_ADDR_VAR 0 7
87729: PUSH
87730: LD_VAR 0 1
87734: PUSH
87735: LD_INT 1
87737: ARRAY
87738: PPUSH
87739: CALL_OW 255
87743: ST_TO_ADDR
// if not result then
87744: LD_VAR 0 3
87748: NOT
87749: IFFALSE 87753
// exit ;
87751: GO 88105
// for i in result do
87753: LD_ADDR_VAR 0 4
87757: PUSH
87758: LD_VAR 0 3
87762: PUSH
87763: FOR_IN
87764: IFFALSE 88103
// begin tag := GetTag ( i ) + 1 ;
87766: LD_ADDR_VAR 0 8
87770: PUSH
87771: LD_VAR 0 4
87775: PPUSH
87776: CALL_OW 110
87780: PUSH
87781: LD_INT 1
87783: PLUS
87784: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
87785: LD_ADDR_VAR 0 6
87789: PUSH
87790: LD_VAR 0 4
87794: PPUSH
87795: CALL_OW 250
87799: PPUSH
87800: LD_VAR 0 4
87804: PPUSH
87805: CALL_OW 251
87809: PPUSH
87810: LD_INT 6
87812: PPUSH
87813: CALL 87429 0 3
87817: ST_TO_ADDR
// if cr then
87818: LD_VAR 0 6
87822: IFFALSE 87861
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
87824: LD_VAR 0 4
87828: PPUSH
87829: LD_VAR 0 6
87833: PUSH
87834: LD_INT 1
87836: ARRAY
87837: PUSH
87838: LD_INT 1
87840: ARRAY
87841: PPUSH
87842: LD_VAR 0 6
87846: PUSH
87847: LD_INT 1
87849: ARRAY
87850: PUSH
87851: LD_INT 2
87853: ARRAY
87854: PPUSH
87855: CALL_OW 116
87859: GO 88101
// if path > tag then
87861: LD_VAR 0 2
87865: PUSH
87866: LD_VAR 0 8
87870: GREATER
87871: IFFALSE 88049
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
87873: LD_ADDR_VAR 0 5
87877: PUSH
87878: LD_INT 81
87880: PUSH
87881: LD_VAR 0 7
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: PUSH
87890: LD_INT 91
87892: PUSH
87893: LD_VAR 0 4
87897: PUSH
87898: LD_INT 12
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: LIST
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PPUSH
87910: CALL_OW 69
87914: ST_TO_ADDR
// if enemy then
87915: LD_VAR 0 5
87919: IFFALSE 87947
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
87921: LD_VAR 0 4
87925: PPUSH
87926: LD_VAR 0 5
87930: PPUSH
87931: LD_VAR 0 4
87935: PPUSH
87936: CALL_OW 74
87940: PPUSH
87941: CALL_OW 115
87945: GO 88047
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
87947: LD_VAR 0 4
87951: PPUSH
87952: LD_VAR 0 2
87956: PUSH
87957: LD_VAR 0 8
87961: ARRAY
87962: PUSH
87963: LD_INT 1
87965: ARRAY
87966: PPUSH
87967: LD_VAR 0 2
87971: PUSH
87972: LD_VAR 0 8
87976: ARRAY
87977: PUSH
87978: LD_INT 2
87980: ARRAY
87981: PPUSH
87982: CALL_OW 297
87986: PUSH
87987: LD_INT 6
87989: GREATER
87990: IFFALSE 88033
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
87992: LD_VAR 0 4
87996: PPUSH
87997: LD_VAR 0 2
88001: PUSH
88002: LD_VAR 0 8
88006: ARRAY
88007: PUSH
88008: LD_INT 1
88010: ARRAY
88011: PPUSH
88012: LD_VAR 0 2
88016: PUSH
88017: LD_VAR 0 8
88021: ARRAY
88022: PUSH
88023: LD_INT 2
88025: ARRAY
88026: PPUSH
88027: CALL_OW 114
88031: GO 88047
// SetTag ( i , tag ) ;
88033: LD_VAR 0 4
88037: PPUSH
88038: LD_VAR 0 8
88042: PPUSH
88043: CALL_OW 109
// end else
88047: GO 88101
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88049: LD_ADDR_VAR 0 5
88053: PUSH
88054: LD_INT 81
88056: PUSH
88057: LD_VAR 0 7
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PPUSH
88066: CALL_OW 69
88070: ST_TO_ADDR
// if enemy then
88071: LD_VAR 0 5
88075: IFFALSE 88101
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
88077: LD_VAR 0 4
88081: PPUSH
88082: LD_VAR 0 5
88086: PPUSH
88087: LD_VAR 0 4
88091: PPUSH
88092: CALL_OW 74
88096: PPUSH
88097: CALL_OW 115
// end ; end ;
88101: GO 87763
88103: POP
88104: POP
// end ; end_of_file
88105: LD_VAR 0 3
88109: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
88110: LD_INT 0
88112: PPUSH
// ar_miner := 81 ;
88113: LD_ADDR_EXP 101
88117: PUSH
88118: LD_INT 81
88120: ST_TO_ADDR
// ar_crane := 88 ;
88121: LD_ADDR_EXP 100
88125: PUSH
88126: LD_INT 88
88128: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
88129: LD_ADDR_EXP 95
88133: PUSH
88134: LD_INT 89
88136: ST_TO_ADDR
// us_hack := 99 ;
88137: LD_ADDR_EXP 96
88141: PUSH
88142: LD_INT 99
88144: ST_TO_ADDR
// us_artillery := 97 ;
88145: LD_ADDR_EXP 97
88149: PUSH
88150: LD_INT 97
88152: ST_TO_ADDR
// ar_bio_bomb := 91 ;
88153: LD_ADDR_EXP 98
88157: PUSH
88158: LD_INT 91
88160: ST_TO_ADDR
// ar_mortar := 92 ;
88161: LD_ADDR_EXP 99
88165: PUSH
88166: LD_INT 92
88168: ST_TO_ADDR
// ru_radar := 98 ;
88169: LD_ADDR_EXP 94
88173: PUSH
88174: LD_INT 98
88176: ST_TO_ADDR
// tech_Artillery := 80 ;
88177: LD_ADDR_EXP 102
88181: PUSH
88182: LD_INT 80
88184: ST_TO_ADDR
// tech_RadMat := 81 ;
88185: LD_ADDR_EXP 103
88189: PUSH
88190: LD_INT 81
88192: ST_TO_ADDR
// tech_BasicTools := 82 ;
88193: LD_ADDR_EXP 104
88197: PUSH
88198: LD_INT 82
88200: ST_TO_ADDR
// tech_Cargo := 83 ;
88201: LD_ADDR_EXP 105
88205: PUSH
88206: LD_INT 83
88208: ST_TO_ADDR
// tech_Track := 84 ;
88209: LD_ADDR_EXP 106
88213: PUSH
88214: LD_INT 84
88216: ST_TO_ADDR
// tech_Crane := 85 ;
88217: LD_ADDR_EXP 107
88221: PUSH
88222: LD_INT 85
88224: ST_TO_ADDR
// tech_Bulldozer := 86 ;
88225: LD_ADDR_EXP 108
88229: PUSH
88230: LD_INT 86
88232: ST_TO_ADDR
// tech_Hovercraft := 87 ;
88233: LD_ADDR_EXP 109
88237: PUSH
88238: LD_INT 87
88240: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
88241: LD_ADDR_EXP 110
88245: PUSH
88246: LD_INT 88
88248: ST_TO_ADDR
// class_mastodont := 31 ;
88249: LD_ADDR_EXP 111
88253: PUSH
88254: LD_INT 31
88256: ST_TO_ADDR
// class_horse := 21 ;
88257: LD_ADDR_EXP 112
88261: PUSH
88262: LD_INT 21
88264: ST_TO_ADDR
// end ;
88265: LD_VAR 0 1
88269: RET
// every 1 do
88270: GO 88272
88272: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
88273: CALL 88110 0 0
88277: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
88278: LD_INT 0
88280: PPUSH
// if p2 = 100 then
88281: LD_VAR 0 2
88285: PUSH
88286: LD_INT 100
88288: EQUAL
88289: IFFALSE 89292
// begin if not StreamModeActive then
88291: LD_EXP 113
88295: NOT
88296: IFFALSE 88306
// StreamModeActive := true ;
88298: LD_ADDR_EXP 113
88302: PUSH
88303: LD_INT 1
88305: ST_TO_ADDR
// if p3 = 0 then
88306: LD_VAR 0 3
88310: PUSH
88311: LD_INT 0
88313: EQUAL
88314: IFFALSE 88320
// InitStreamMode ;
88316: CALL 89452 0 0
// if p3 = 1 then
88320: LD_VAR 0 3
88324: PUSH
88325: LD_INT 1
88327: EQUAL
88328: IFFALSE 88338
// sRocket := true ;
88330: LD_ADDR_EXP 118
88334: PUSH
88335: LD_INT 1
88337: ST_TO_ADDR
// if p3 = 2 then
88338: LD_VAR 0 3
88342: PUSH
88343: LD_INT 2
88345: EQUAL
88346: IFFALSE 88356
// sSpeed := true ;
88348: LD_ADDR_EXP 117
88352: PUSH
88353: LD_INT 1
88355: ST_TO_ADDR
// if p3 = 3 then
88356: LD_VAR 0 3
88360: PUSH
88361: LD_INT 3
88363: EQUAL
88364: IFFALSE 88374
// sEngine := true ;
88366: LD_ADDR_EXP 119
88370: PUSH
88371: LD_INT 1
88373: ST_TO_ADDR
// if p3 = 4 then
88374: LD_VAR 0 3
88378: PUSH
88379: LD_INT 4
88381: EQUAL
88382: IFFALSE 88392
// sSpec := true ;
88384: LD_ADDR_EXP 116
88388: PUSH
88389: LD_INT 1
88391: ST_TO_ADDR
// if p3 = 5 then
88392: LD_VAR 0 3
88396: PUSH
88397: LD_INT 5
88399: EQUAL
88400: IFFALSE 88410
// sLevel := true ;
88402: LD_ADDR_EXP 120
88406: PUSH
88407: LD_INT 1
88409: ST_TO_ADDR
// if p3 = 6 then
88410: LD_VAR 0 3
88414: PUSH
88415: LD_INT 6
88417: EQUAL
88418: IFFALSE 88428
// sArmoury := true ;
88420: LD_ADDR_EXP 121
88424: PUSH
88425: LD_INT 1
88427: ST_TO_ADDR
// if p3 = 7 then
88428: LD_VAR 0 3
88432: PUSH
88433: LD_INT 7
88435: EQUAL
88436: IFFALSE 88446
// sRadar := true ;
88438: LD_ADDR_EXP 122
88442: PUSH
88443: LD_INT 1
88445: ST_TO_ADDR
// if p3 = 8 then
88446: LD_VAR 0 3
88450: PUSH
88451: LD_INT 8
88453: EQUAL
88454: IFFALSE 88464
// sBunker := true ;
88456: LD_ADDR_EXP 123
88460: PUSH
88461: LD_INT 1
88463: ST_TO_ADDR
// if p3 = 9 then
88464: LD_VAR 0 3
88468: PUSH
88469: LD_INT 9
88471: EQUAL
88472: IFFALSE 88482
// sHack := true ;
88474: LD_ADDR_EXP 124
88478: PUSH
88479: LD_INT 1
88481: ST_TO_ADDR
// if p3 = 10 then
88482: LD_VAR 0 3
88486: PUSH
88487: LD_INT 10
88489: EQUAL
88490: IFFALSE 88500
// sFire := true ;
88492: LD_ADDR_EXP 125
88496: PUSH
88497: LD_INT 1
88499: ST_TO_ADDR
// if p3 = 11 then
88500: LD_VAR 0 3
88504: PUSH
88505: LD_INT 11
88507: EQUAL
88508: IFFALSE 88518
// sRefresh := true ;
88510: LD_ADDR_EXP 126
88514: PUSH
88515: LD_INT 1
88517: ST_TO_ADDR
// if p3 = 12 then
88518: LD_VAR 0 3
88522: PUSH
88523: LD_INT 12
88525: EQUAL
88526: IFFALSE 88536
// sExp := true ;
88528: LD_ADDR_EXP 127
88532: PUSH
88533: LD_INT 1
88535: ST_TO_ADDR
// if p3 = 13 then
88536: LD_VAR 0 3
88540: PUSH
88541: LD_INT 13
88543: EQUAL
88544: IFFALSE 88554
// sDepot := true ;
88546: LD_ADDR_EXP 128
88550: PUSH
88551: LD_INT 1
88553: ST_TO_ADDR
// if p3 = 14 then
88554: LD_VAR 0 3
88558: PUSH
88559: LD_INT 14
88561: EQUAL
88562: IFFALSE 88572
// sFlag := true ;
88564: LD_ADDR_EXP 129
88568: PUSH
88569: LD_INT 1
88571: ST_TO_ADDR
// if p3 = 15 then
88572: LD_VAR 0 3
88576: PUSH
88577: LD_INT 15
88579: EQUAL
88580: IFFALSE 88590
// sKamikadze := true ;
88582: LD_ADDR_EXP 137
88586: PUSH
88587: LD_INT 1
88589: ST_TO_ADDR
// if p3 = 16 then
88590: LD_VAR 0 3
88594: PUSH
88595: LD_INT 16
88597: EQUAL
88598: IFFALSE 88608
// sTroll := true ;
88600: LD_ADDR_EXP 138
88604: PUSH
88605: LD_INT 1
88607: ST_TO_ADDR
// if p3 = 17 then
88608: LD_VAR 0 3
88612: PUSH
88613: LD_INT 17
88615: EQUAL
88616: IFFALSE 88626
// sSlow := true ;
88618: LD_ADDR_EXP 139
88622: PUSH
88623: LD_INT 1
88625: ST_TO_ADDR
// if p3 = 18 then
88626: LD_VAR 0 3
88630: PUSH
88631: LD_INT 18
88633: EQUAL
88634: IFFALSE 88644
// sLack := true ;
88636: LD_ADDR_EXP 140
88640: PUSH
88641: LD_INT 1
88643: ST_TO_ADDR
// if p3 = 19 then
88644: LD_VAR 0 3
88648: PUSH
88649: LD_INT 19
88651: EQUAL
88652: IFFALSE 88662
// sTank := true ;
88654: LD_ADDR_EXP 142
88658: PUSH
88659: LD_INT 1
88661: ST_TO_ADDR
// if p3 = 20 then
88662: LD_VAR 0 3
88666: PUSH
88667: LD_INT 20
88669: EQUAL
88670: IFFALSE 88680
// sRemote := true ;
88672: LD_ADDR_EXP 143
88676: PUSH
88677: LD_INT 1
88679: ST_TO_ADDR
// if p3 = 21 then
88680: LD_VAR 0 3
88684: PUSH
88685: LD_INT 21
88687: EQUAL
88688: IFFALSE 88698
// sPowell := true ;
88690: LD_ADDR_EXP 144
88694: PUSH
88695: LD_INT 1
88697: ST_TO_ADDR
// if p3 = 22 then
88698: LD_VAR 0 3
88702: PUSH
88703: LD_INT 22
88705: EQUAL
88706: IFFALSE 88716
// sTeleport := true ;
88708: LD_ADDR_EXP 147
88712: PUSH
88713: LD_INT 1
88715: ST_TO_ADDR
// if p3 = 23 then
88716: LD_VAR 0 3
88720: PUSH
88721: LD_INT 23
88723: EQUAL
88724: IFFALSE 88734
// sOilTower := true ;
88726: LD_ADDR_EXP 149
88730: PUSH
88731: LD_INT 1
88733: ST_TO_ADDR
// if p3 = 24 then
88734: LD_VAR 0 3
88738: PUSH
88739: LD_INT 24
88741: EQUAL
88742: IFFALSE 88752
// sShovel := true ;
88744: LD_ADDR_EXP 150
88748: PUSH
88749: LD_INT 1
88751: ST_TO_ADDR
// if p3 = 25 then
88752: LD_VAR 0 3
88756: PUSH
88757: LD_INT 25
88759: EQUAL
88760: IFFALSE 88770
// sSheik := true ;
88762: LD_ADDR_EXP 151
88766: PUSH
88767: LD_INT 1
88769: ST_TO_ADDR
// if p3 = 26 then
88770: LD_VAR 0 3
88774: PUSH
88775: LD_INT 26
88777: EQUAL
88778: IFFALSE 88788
// sEarthquake := true ;
88780: LD_ADDR_EXP 153
88784: PUSH
88785: LD_INT 1
88787: ST_TO_ADDR
// if p3 = 27 then
88788: LD_VAR 0 3
88792: PUSH
88793: LD_INT 27
88795: EQUAL
88796: IFFALSE 88806
// sAI := true ;
88798: LD_ADDR_EXP 154
88802: PUSH
88803: LD_INT 1
88805: ST_TO_ADDR
// if p3 = 28 then
88806: LD_VAR 0 3
88810: PUSH
88811: LD_INT 28
88813: EQUAL
88814: IFFALSE 88824
// sCargo := true ;
88816: LD_ADDR_EXP 157
88820: PUSH
88821: LD_INT 1
88823: ST_TO_ADDR
// if p3 = 29 then
88824: LD_VAR 0 3
88828: PUSH
88829: LD_INT 29
88831: EQUAL
88832: IFFALSE 88842
// sDLaser := true ;
88834: LD_ADDR_EXP 158
88838: PUSH
88839: LD_INT 1
88841: ST_TO_ADDR
// if p3 = 30 then
88842: LD_VAR 0 3
88846: PUSH
88847: LD_INT 30
88849: EQUAL
88850: IFFALSE 88860
// sExchange := true ;
88852: LD_ADDR_EXP 159
88856: PUSH
88857: LD_INT 1
88859: ST_TO_ADDR
// if p3 = 31 then
88860: LD_VAR 0 3
88864: PUSH
88865: LD_INT 31
88867: EQUAL
88868: IFFALSE 88878
// sFac := true ;
88870: LD_ADDR_EXP 160
88874: PUSH
88875: LD_INT 1
88877: ST_TO_ADDR
// if p3 = 32 then
88878: LD_VAR 0 3
88882: PUSH
88883: LD_INT 32
88885: EQUAL
88886: IFFALSE 88896
// sPower := true ;
88888: LD_ADDR_EXP 161
88892: PUSH
88893: LD_INT 1
88895: ST_TO_ADDR
// if p3 = 33 then
88896: LD_VAR 0 3
88900: PUSH
88901: LD_INT 33
88903: EQUAL
88904: IFFALSE 88914
// sRandom := true ;
88906: LD_ADDR_EXP 162
88910: PUSH
88911: LD_INT 1
88913: ST_TO_ADDR
// if p3 = 34 then
88914: LD_VAR 0 3
88918: PUSH
88919: LD_INT 34
88921: EQUAL
88922: IFFALSE 88932
// sShield := true ;
88924: LD_ADDR_EXP 163
88928: PUSH
88929: LD_INT 1
88931: ST_TO_ADDR
// if p3 = 35 then
88932: LD_VAR 0 3
88936: PUSH
88937: LD_INT 35
88939: EQUAL
88940: IFFALSE 88950
// sTime := true ;
88942: LD_ADDR_EXP 164
88946: PUSH
88947: LD_INT 1
88949: ST_TO_ADDR
// if p3 = 36 then
88950: LD_VAR 0 3
88954: PUSH
88955: LD_INT 36
88957: EQUAL
88958: IFFALSE 88968
// sTools := true ;
88960: LD_ADDR_EXP 165
88964: PUSH
88965: LD_INT 1
88967: ST_TO_ADDR
// if p3 = 101 then
88968: LD_VAR 0 3
88972: PUSH
88973: LD_INT 101
88975: EQUAL
88976: IFFALSE 88986
// sSold := true ;
88978: LD_ADDR_EXP 130
88982: PUSH
88983: LD_INT 1
88985: ST_TO_ADDR
// if p3 = 102 then
88986: LD_VAR 0 3
88990: PUSH
88991: LD_INT 102
88993: EQUAL
88994: IFFALSE 89004
// sDiff := true ;
88996: LD_ADDR_EXP 131
89000: PUSH
89001: LD_INT 1
89003: ST_TO_ADDR
// if p3 = 103 then
89004: LD_VAR 0 3
89008: PUSH
89009: LD_INT 103
89011: EQUAL
89012: IFFALSE 89022
// sFog := true ;
89014: LD_ADDR_EXP 134
89018: PUSH
89019: LD_INT 1
89021: ST_TO_ADDR
// if p3 = 104 then
89022: LD_VAR 0 3
89026: PUSH
89027: LD_INT 104
89029: EQUAL
89030: IFFALSE 89040
// sReset := true ;
89032: LD_ADDR_EXP 135
89036: PUSH
89037: LD_INT 1
89039: ST_TO_ADDR
// if p3 = 105 then
89040: LD_VAR 0 3
89044: PUSH
89045: LD_INT 105
89047: EQUAL
89048: IFFALSE 89058
// sSun := true ;
89050: LD_ADDR_EXP 136
89054: PUSH
89055: LD_INT 1
89057: ST_TO_ADDR
// if p3 = 106 then
89058: LD_VAR 0 3
89062: PUSH
89063: LD_INT 106
89065: EQUAL
89066: IFFALSE 89076
// sTiger := true ;
89068: LD_ADDR_EXP 132
89072: PUSH
89073: LD_INT 1
89075: ST_TO_ADDR
// if p3 = 107 then
89076: LD_VAR 0 3
89080: PUSH
89081: LD_INT 107
89083: EQUAL
89084: IFFALSE 89094
// sBomb := true ;
89086: LD_ADDR_EXP 133
89090: PUSH
89091: LD_INT 1
89093: ST_TO_ADDR
// if p3 = 108 then
89094: LD_VAR 0 3
89098: PUSH
89099: LD_INT 108
89101: EQUAL
89102: IFFALSE 89112
// sWound := true ;
89104: LD_ADDR_EXP 141
89108: PUSH
89109: LD_INT 1
89111: ST_TO_ADDR
// if p3 = 109 then
89112: LD_VAR 0 3
89116: PUSH
89117: LD_INT 109
89119: EQUAL
89120: IFFALSE 89130
// sBetray := true ;
89122: LD_ADDR_EXP 145
89126: PUSH
89127: LD_INT 1
89129: ST_TO_ADDR
// if p3 = 110 then
89130: LD_VAR 0 3
89134: PUSH
89135: LD_INT 110
89137: EQUAL
89138: IFFALSE 89148
// sContamin := true ;
89140: LD_ADDR_EXP 146
89144: PUSH
89145: LD_INT 1
89147: ST_TO_ADDR
// if p3 = 111 then
89148: LD_VAR 0 3
89152: PUSH
89153: LD_INT 111
89155: EQUAL
89156: IFFALSE 89166
// sOil := true ;
89158: LD_ADDR_EXP 148
89162: PUSH
89163: LD_INT 1
89165: ST_TO_ADDR
// if p3 = 112 then
89166: LD_VAR 0 3
89170: PUSH
89171: LD_INT 112
89173: EQUAL
89174: IFFALSE 89184
// sStu := true ;
89176: LD_ADDR_EXP 152
89180: PUSH
89181: LD_INT 1
89183: ST_TO_ADDR
// if p3 = 113 then
89184: LD_VAR 0 3
89188: PUSH
89189: LD_INT 113
89191: EQUAL
89192: IFFALSE 89202
// sBazooka := true ;
89194: LD_ADDR_EXP 155
89198: PUSH
89199: LD_INT 1
89201: ST_TO_ADDR
// if p3 = 114 then
89202: LD_VAR 0 3
89206: PUSH
89207: LD_INT 114
89209: EQUAL
89210: IFFALSE 89220
// sMortar := true ;
89212: LD_ADDR_EXP 156
89216: PUSH
89217: LD_INT 1
89219: ST_TO_ADDR
// if p3 = 115 then
89220: LD_VAR 0 3
89224: PUSH
89225: LD_INT 115
89227: EQUAL
89228: IFFALSE 89238
// sRanger := true ;
89230: LD_ADDR_EXP 166
89234: PUSH
89235: LD_INT 1
89237: ST_TO_ADDR
// if p3 = 116 then
89238: LD_VAR 0 3
89242: PUSH
89243: LD_INT 116
89245: EQUAL
89246: IFFALSE 89256
// sComputer := true ;
89248: LD_ADDR_EXP 167
89252: PUSH
89253: LD_INT 1
89255: ST_TO_ADDR
// if p3 = 117 then
89256: LD_VAR 0 3
89260: PUSH
89261: LD_INT 117
89263: EQUAL
89264: IFFALSE 89274
// s30 := true ;
89266: LD_ADDR_EXP 168
89270: PUSH
89271: LD_INT 1
89273: ST_TO_ADDR
// if p3 = 118 then
89274: LD_VAR 0 3
89278: PUSH
89279: LD_INT 118
89281: EQUAL
89282: IFFALSE 89292
// s60 := true ;
89284: LD_ADDR_EXP 169
89288: PUSH
89289: LD_INT 1
89291: ST_TO_ADDR
// end ; if p2 = 101 then
89292: LD_VAR 0 2
89296: PUSH
89297: LD_INT 101
89299: EQUAL
89300: IFFALSE 89428
// begin case p3 of 1 :
89302: LD_VAR 0 3
89306: PUSH
89307: LD_INT 1
89309: DOUBLE
89310: EQUAL
89311: IFTRUE 89315
89313: GO 89322
89315: POP
// hHackUnlimitedResources ; 2 :
89316: CALL 101024 0 0
89320: GO 89428
89322: LD_INT 2
89324: DOUBLE
89325: EQUAL
89326: IFTRUE 89330
89328: GO 89337
89330: POP
// hHackSetLevel10 ; 3 :
89331: CALL 101157 0 0
89335: GO 89428
89337: LD_INT 3
89339: DOUBLE
89340: EQUAL
89341: IFTRUE 89345
89343: GO 89352
89345: POP
// hHackSetLevel10YourUnits ; 4 :
89346: CALL 101242 0 0
89350: GO 89428
89352: LD_INT 4
89354: DOUBLE
89355: EQUAL
89356: IFTRUE 89360
89358: GO 89367
89360: POP
// hHackInvincible ; 5 :
89361: CALL 101690 0 0
89365: GO 89428
89367: LD_INT 5
89369: DOUBLE
89370: EQUAL
89371: IFTRUE 89375
89373: GO 89382
89375: POP
// hHackInvisible ; 6 :
89376: CALL 101801 0 0
89380: GO 89428
89382: LD_INT 6
89384: DOUBLE
89385: EQUAL
89386: IFTRUE 89390
89388: GO 89397
89390: POP
// hHackChangeYourSide ; 7 :
89391: CALL 101858 0 0
89395: GO 89428
89397: LD_INT 7
89399: DOUBLE
89400: EQUAL
89401: IFTRUE 89405
89403: GO 89412
89405: POP
// hHackChangeUnitSide ; 8 :
89406: CALL 101900 0 0
89410: GO 89428
89412: LD_INT 8
89414: DOUBLE
89415: EQUAL
89416: IFTRUE 89420
89418: GO 89427
89420: POP
// hHackFog ; end ;
89421: CALL 102001 0 0
89425: GO 89428
89427: POP
// end ; end ;
89428: LD_VAR 0 7
89432: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
89433: GO 89435
89435: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89436: LD_STRING initStreamRollete();
89438: PPUSH
89439: CALL_OW 559
// InitStreamMode ;
89443: CALL 89452 0 0
// DefineStreamItems ( ) ;
89447: CALL 89916 0 0
// end ;
89451: END
// function InitStreamMode ; begin
89452: LD_INT 0
89454: PPUSH
// streamModeActive := false ;
89455: LD_ADDR_EXP 113
89459: PUSH
89460: LD_INT 0
89462: ST_TO_ADDR
// normalCounter := 36 ;
89463: LD_ADDR_EXP 114
89467: PUSH
89468: LD_INT 36
89470: ST_TO_ADDR
// hardcoreCounter := 16 ;
89471: LD_ADDR_EXP 115
89475: PUSH
89476: LD_INT 16
89478: ST_TO_ADDR
// sRocket := false ;
89479: LD_ADDR_EXP 118
89483: PUSH
89484: LD_INT 0
89486: ST_TO_ADDR
// sSpeed := false ;
89487: LD_ADDR_EXP 117
89491: PUSH
89492: LD_INT 0
89494: ST_TO_ADDR
// sEngine := false ;
89495: LD_ADDR_EXP 119
89499: PUSH
89500: LD_INT 0
89502: ST_TO_ADDR
// sSpec := false ;
89503: LD_ADDR_EXP 116
89507: PUSH
89508: LD_INT 0
89510: ST_TO_ADDR
// sLevel := false ;
89511: LD_ADDR_EXP 120
89515: PUSH
89516: LD_INT 0
89518: ST_TO_ADDR
// sArmoury := false ;
89519: LD_ADDR_EXP 121
89523: PUSH
89524: LD_INT 0
89526: ST_TO_ADDR
// sRadar := false ;
89527: LD_ADDR_EXP 122
89531: PUSH
89532: LD_INT 0
89534: ST_TO_ADDR
// sBunker := false ;
89535: LD_ADDR_EXP 123
89539: PUSH
89540: LD_INT 0
89542: ST_TO_ADDR
// sHack := false ;
89543: LD_ADDR_EXP 124
89547: PUSH
89548: LD_INT 0
89550: ST_TO_ADDR
// sFire := false ;
89551: LD_ADDR_EXP 125
89555: PUSH
89556: LD_INT 0
89558: ST_TO_ADDR
// sRefresh := false ;
89559: LD_ADDR_EXP 126
89563: PUSH
89564: LD_INT 0
89566: ST_TO_ADDR
// sExp := false ;
89567: LD_ADDR_EXP 127
89571: PUSH
89572: LD_INT 0
89574: ST_TO_ADDR
// sDepot := false ;
89575: LD_ADDR_EXP 128
89579: PUSH
89580: LD_INT 0
89582: ST_TO_ADDR
// sFlag := false ;
89583: LD_ADDR_EXP 129
89587: PUSH
89588: LD_INT 0
89590: ST_TO_ADDR
// sKamikadze := false ;
89591: LD_ADDR_EXP 137
89595: PUSH
89596: LD_INT 0
89598: ST_TO_ADDR
// sTroll := false ;
89599: LD_ADDR_EXP 138
89603: PUSH
89604: LD_INT 0
89606: ST_TO_ADDR
// sSlow := false ;
89607: LD_ADDR_EXP 139
89611: PUSH
89612: LD_INT 0
89614: ST_TO_ADDR
// sLack := false ;
89615: LD_ADDR_EXP 140
89619: PUSH
89620: LD_INT 0
89622: ST_TO_ADDR
// sTank := false ;
89623: LD_ADDR_EXP 142
89627: PUSH
89628: LD_INT 0
89630: ST_TO_ADDR
// sRemote := false ;
89631: LD_ADDR_EXP 143
89635: PUSH
89636: LD_INT 0
89638: ST_TO_ADDR
// sPowell := false ;
89639: LD_ADDR_EXP 144
89643: PUSH
89644: LD_INT 0
89646: ST_TO_ADDR
// sTeleport := false ;
89647: LD_ADDR_EXP 147
89651: PUSH
89652: LD_INT 0
89654: ST_TO_ADDR
// sOilTower := false ;
89655: LD_ADDR_EXP 149
89659: PUSH
89660: LD_INT 0
89662: ST_TO_ADDR
// sShovel := false ;
89663: LD_ADDR_EXP 150
89667: PUSH
89668: LD_INT 0
89670: ST_TO_ADDR
// sSheik := false ;
89671: LD_ADDR_EXP 151
89675: PUSH
89676: LD_INT 0
89678: ST_TO_ADDR
// sEarthquake := false ;
89679: LD_ADDR_EXP 153
89683: PUSH
89684: LD_INT 0
89686: ST_TO_ADDR
// sAI := false ;
89687: LD_ADDR_EXP 154
89691: PUSH
89692: LD_INT 0
89694: ST_TO_ADDR
// sCargo := false ;
89695: LD_ADDR_EXP 157
89699: PUSH
89700: LD_INT 0
89702: ST_TO_ADDR
// sDLaser := false ;
89703: LD_ADDR_EXP 158
89707: PUSH
89708: LD_INT 0
89710: ST_TO_ADDR
// sExchange := false ;
89711: LD_ADDR_EXP 159
89715: PUSH
89716: LD_INT 0
89718: ST_TO_ADDR
// sFac := false ;
89719: LD_ADDR_EXP 160
89723: PUSH
89724: LD_INT 0
89726: ST_TO_ADDR
// sPower := false ;
89727: LD_ADDR_EXP 161
89731: PUSH
89732: LD_INT 0
89734: ST_TO_ADDR
// sRandom := false ;
89735: LD_ADDR_EXP 162
89739: PUSH
89740: LD_INT 0
89742: ST_TO_ADDR
// sShield := false ;
89743: LD_ADDR_EXP 163
89747: PUSH
89748: LD_INT 0
89750: ST_TO_ADDR
// sTime := false ;
89751: LD_ADDR_EXP 164
89755: PUSH
89756: LD_INT 0
89758: ST_TO_ADDR
// sTools := false ;
89759: LD_ADDR_EXP 165
89763: PUSH
89764: LD_INT 0
89766: ST_TO_ADDR
// sSold := false ;
89767: LD_ADDR_EXP 130
89771: PUSH
89772: LD_INT 0
89774: ST_TO_ADDR
// sDiff := false ;
89775: LD_ADDR_EXP 131
89779: PUSH
89780: LD_INT 0
89782: ST_TO_ADDR
// sFog := false ;
89783: LD_ADDR_EXP 134
89787: PUSH
89788: LD_INT 0
89790: ST_TO_ADDR
// sReset := false ;
89791: LD_ADDR_EXP 135
89795: PUSH
89796: LD_INT 0
89798: ST_TO_ADDR
// sSun := false ;
89799: LD_ADDR_EXP 136
89803: PUSH
89804: LD_INT 0
89806: ST_TO_ADDR
// sTiger := false ;
89807: LD_ADDR_EXP 132
89811: PUSH
89812: LD_INT 0
89814: ST_TO_ADDR
// sBomb := false ;
89815: LD_ADDR_EXP 133
89819: PUSH
89820: LD_INT 0
89822: ST_TO_ADDR
// sWound := false ;
89823: LD_ADDR_EXP 141
89827: PUSH
89828: LD_INT 0
89830: ST_TO_ADDR
// sBetray := false ;
89831: LD_ADDR_EXP 145
89835: PUSH
89836: LD_INT 0
89838: ST_TO_ADDR
// sContamin := false ;
89839: LD_ADDR_EXP 146
89843: PUSH
89844: LD_INT 0
89846: ST_TO_ADDR
// sOil := false ;
89847: LD_ADDR_EXP 148
89851: PUSH
89852: LD_INT 0
89854: ST_TO_ADDR
// sStu := false ;
89855: LD_ADDR_EXP 152
89859: PUSH
89860: LD_INT 0
89862: ST_TO_ADDR
// sBazooka := false ;
89863: LD_ADDR_EXP 155
89867: PUSH
89868: LD_INT 0
89870: ST_TO_ADDR
// sMortar := false ;
89871: LD_ADDR_EXP 156
89875: PUSH
89876: LD_INT 0
89878: ST_TO_ADDR
// sRanger := false ;
89879: LD_ADDR_EXP 166
89883: PUSH
89884: LD_INT 0
89886: ST_TO_ADDR
// sComputer := false ;
89887: LD_ADDR_EXP 167
89891: PUSH
89892: LD_INT 0
89894: ST_TO_ADDR
// s30 := false ;
89895: LD_ADDR_EXP 168
89899: PUSH
89900: LD_INT 0
89902: ST_TO_ADDR
// s60 := false ;
89903: LD_ADDR_EXP 169
89907: PUSH
89908: LD_INT 0
89910: ST_TO_ADDR
// end ;
89911: LD_VAR 0 1
89915: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
89916: LD_INT 0
89918: PPUSH
89919: PPUSH
89920: PPUSH
89921: PPUSH
89922: PPUSH
// result := [ ] ;
89923: LD_ADDR_VAR 0 1
89927: PUSH
89928: EMPTY
89929: ST_TO_ADDR
// if campaign_id = 1 then
89930: LD_OWVAR 69
89934: PUSH
89935: LD_INT 1
89937: EQUAL
89938: IFFALSE 93104
// begin case mission_number of 1 :
89940: LD_OWVAR 70
89944: PUSH
89945: LD_INT 1
89947: DOUBLE
89948: EQUAL
89949: IFTRUE 89953
89951: GO 90029
89953: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
89954: LD_ADDR_VAR 0 1
89958: PUSH
89959: LD_INT 2
89961: PUSH
89962: LD_INT 4
89964: PUSH
89965: LD_INT 11
89967: PUSH
89968: LD_INT 12
89970: PUSH
89971: LD_INT 15
89973: PUSH
89974: LD_INT 16
89976: PUSH
89977: LD_INT 22
89979: PUSH
89980: LD_INT 23
89982: PUSH
89983: LD_INT 26
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 101
89999: PUSH
90000: LD_INT 102
90002: PUSH
90003: LD_INT 106
90005: PUSH
90006: LD_INT 116
90008: PUSH
90009: LD_INT 117
90011: PUSH
90012: LD_INT 118
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: ST_TO_ADDR
90027: GO 93102
90029: LD_INT 2
90031: DOUBLE
90032: EQUAL
90033: IFTRUE 90037
90035: GO 90121
90037: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
90038: LD_ADDR_VAR 0 1
90042: PUSH
90043: LD_INT 2
90045: PUSH
90046: LD_INT 4
90048: PUSH
90049: LD_INT 11
90051: PUSH
90052: LD_INT 12
90054: PUSH
90055: LD_INT 15
90057: PUSH
90058: LD_INT 16
90060: PUSH
90061: LD_INT 22
90063: PUSH
90064: LD_INT 23
90066: PUSH
90067: LD_INT 26
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 101
90083: PUSH
90084: LD_INT 102
90086: PUSH
90087: LD_INT 105
90089: PUSH
90090: LD_INT 106
90092: PUSH
90093: LD_INT 108
90095: PUSH
90096: LD_INT 116
90098: PUSH
90099: LD_INT 117
90101: PUSH
90102: LD_INT 118
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: ST_TO_ADDR
90119: GO 93102
90121: LD_INT 3
90123: DOUBLE
90124: EQUAL
90125: IFTRUE 90129
90127: GO 90217
90129: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
90130: LD_ADDR_VAR 0 1
90134: PUSH
90135: LD_INT 2
90137: PUSH
90138: LD_INT 4
90140: PUSH
90141: LD_INT 5
90143: PUSH
90144: LD_INT 11
90146: PUSH
90147: LD_INT 12
90149: PUSH
90150: LD_INT 15
90152: PUSH
90153: LD_INT 16
90155: PUSH
90156: LD_INT 22
90158: PUSH
90159: LD_INT 26
90161: PUSH
90162: LD_INT 36
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: PUSH
90177: LD_INT 101
90179: PUSH
90180: LD_INT 102
90182: PUSH
90183: LD_INT 105
90185: PUSH
90186: LD_INT 106
90188: PUSH
90189: LD_INT 108
90191: PUSH
90192: LD_INT 116
90194: PUSH
90195: LD_INT 117
90197: PUSH
90198: LD_INT 118
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: ST_TO_ADDR
90215: GO 93102
90217: LD_INT 4
90219: DOUBLE
90220: EQUAL
90221: IFTRUE 90225
90223: GO 90321
90225: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
90226: LD_ADDR_VAR 0 1
90230: PUSH
90231: LD_INT 2
90233: PUSH
90234: LD_INT 4
90236: PUSH
90237: LD_INT 5
90239: PUSH
90240: LD_INT 8
90242: PUSH
90243: LD_INT 11
90245: PUSH
90246: LD_INT 12
90248: PUSH
90249: LD_INT 15
90251: PUSH
90252: LD_INT 16
90254: PUSH
90255: LD_INT 22
90257: PUSH
90258: LD_INT 23
90260: PUSH
90261: LD_INT 26
90263: PUSH
90264: LD_INT 36
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 101
90283: PUSH
90284: LD_INT 102
90286: PUSH
90287: LD_INT 105
90289: PUSH
90290: LD_INT 106
90292: PUSH
90293: LD_INT 108
90295: PUSH
90296: LD_INT 116
90298: PUSH
90299: LD_INT 117
90301: PUSH
90302: LD_INT 118
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: ST_TO_ADDR
90319: GO 93102
90321: LD_INT 5
90323: DOUBLE
90324: EQUAL
90325: IFTRUE 90329
90327: GO 90441
90329: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
90330: LD_ADDR_VAR 0 1
90334: PUSH
90335: LD_INT 2
90337: PUSH
90338: LD_INT 4
90340: PUSH
90341: LD_INT 5
90343: PUSH
90344: LD_INT 6
90346: PUSH
90347: LD_INT 8
90349: PUSH
90350: LD_INT 11
90352: PUSH
90353: LD_INT 12
90355: PUSH
90356: LD_INT 15
90358: PUSH
90359: LD_INT 16
90361: PUSH
90362: LD_INT 22
90364: PUSH
90365: LD_INT 23
90367: PUSH
90368: LD_INT 25
90370: PUSH
90371: LD_INT 26
90373: PUSH
90374: LD_INT 36
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 101
90395: PUSH
90396: LD_INT 102
90398: PUSH
90399: LD_INT 105
90401: PUSH
90402: LD_INT 106
90404: PUSH
90405: LD_INT 108
90407: PUSH
90408: LD_INT 109
90410: PUSH
90411: LD_INT 112
90413: PUSH
90414: LD_INT 116
90416: PUSH
90417: LD_INT 117
90419: PUSH
90420: LD_INT 118
90422: PUSH
90423: EMPTY
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: ST_TO_ADDR
90439: GO 93102
90441: LD_INT 6
90443: DOUBLE
90444: EQUAL
90445: IFTRUE 90449
90447: GO 90581
90449: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
90450: LD_ADDR_VAR 0 1
90454: PUSH
90455: LD_INT 2
90457: PUSH
90458: LD_INT 4
90460: PUSH
90461: LD_INT 5
90463: PUSH
90464: LD_INT 6
90466: PUSH
90467: LD_INT 8
90469: PUSH
90470: LD_INT 11
90472: PUSH
90473: LD_INT 12
90475: PUSH
90476: LD_INT 15
90478: PUSH
90479: LD_INT 16
90481: PUSH
90482: LD_INT 20
90484: PUSH
90485: LD_INT 21
90487: PUSH
90488: LD_INT 22
90490: PUSH
90491: LD_INT 23
90493: PUSH
90494: LD_INT 25
90496: PUSH
90497: LD_INT 26
90499: PUSH
90500: LD_INT 30
90502: PUSH
90503: LD_INT 31
90505: PUSH
90506: LD_INT 32
90508: PUSH
90509: LD_INT 36
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: PUSH
90533: LD_INT 101
90535: PUSH
90536: LD_INT 102
90538: PUSH
90539: LD_INT 105
90541: PUSH
90542: LD_INT 106
90544: PUSH
90545: LD_INT 108
90547: PUSH
90548: LD_INT 109
90550: PUSH
90551: LD_INT 112
90553: PUSH
90554: LD_INT 116
90556: PUSH
90557: LD_INT 117
90559: PUSH
90560: LD_INT 118
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: ST_TO_ADDR
90579: GO 93102
90581: LD_INT 7
90583: DOUBLE
90584: EQUAL
90585: IFTRUE 90589
90587: GO 90701
90589: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
90590: LD_ADDR_VAR 0 1
90594: PUSH
90595: LD_INT 2
90597: PUSH
90598: LD_INT 4
90600: PUSH
90601: LD_INT 5
90603: PUSH
90604: LD_INT 7
90606: PUSH
90607: LD_INT 11
90609: PUSH
90610: LD_INT 12
90612: PUSH
90613: LD_INT 15
90615: PUSH
90616: LD_INT 16
90618: PUSH
90619: LD_INT 20
90621: PUSH
90622: LD_INT 21
90624: PUSH
90625: LD_INT 22
90627: PUSH
90628: LD_INT 23
90630: PUSH
90631: LD_INT 25
90633: PUSH
90634: LD_INT 26
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 101
90655: PUSH
90656: LD_INT 102
90658: PUSH
90659: LD_INT 103
90661: PUSH
90662: LD_INT 105
90664: PUSH
90665: LD_INT 106
90667: PUSH
90668: LD_INT 108
90670: PUSH
90671: LD_INT 112
90673: PUSH
90674: LD_INT 116
90676: PUSH
90677: LD_INT 117
90679: PUSH
90680: LD_INT 118
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: PUSH
90695: EMPTY
90696: LIST
90697: LIST
90698: ST_TO_ADDR
90699: GO 93102
90701: LD_INT 8
90703: DOUBLE
90704: EQUAL
90705: IFTRUE 90709
90707: GO 90849
90709: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
90710: LD_ADDR_VAR 0 1
90714: PUSH
90715: LD_INT 2
90717: PUSH
90718: LD_INT 4
90720: PUSH
90721: LD_INT 5
90723: PUSH
90724: LD_INT 6
90726: PUSH
90727: LD_INT 7
90729: PUSH
90730: LD_INT 8
90732: PUSH
90733: LD_INT 11
90735: PUSH
90736: LD_INT 12
90738: PUSH
90739: LD_INT 15
90741: PUSH
90742: LD_INT 16
90744: PUSH
90745: LD_INT 20
90747: PUSH
90748: LD_INT 21
90750: PUSH
90751: LD_INT 22
90753: PUSH
90754: LD_INT 23
90756: PUSH
90757: LD_INT 25
90759: PUSH
90760: LD_INT 26
90762: PUSH
90763: LD_INT 30
90765: PUSH
90766: LD_INT 31
90768: PUSH
90769: LD_INT 32
90771: PUSH
90772: LD_INT 36
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: PUSH
90797: LD_INT 101
90799: PUSH
90800: LD_INT 102
90802: PUSH
90803: LD_INT 103
90805: PUSH
90806: LD_INT 105
90808: PUSH
90809: LD_INT 106
90811: PUSH
90812: LD_INT 108
90814: PUSH
90815: LD_INT 109
90817: PUSH
90818: LD_INT 112
90820: PUSH
90821: LD_INT 116
90823: PUSH
90824: LD_INT 117
90826: PUSH
90827: LD_INT 118
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: ST_TO_ADDR
90847: GO 93102
90849: LD_INT 9
90851: DOUBLE
90852: EQUAL
90853: IFTRUE 90857
90855: GO 91005
90857: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
90858: LD_ADDR_VAR 0 1
90862: PUSH
90863: LD_INT 2
90865: PUSH
90866: LD_INT 4
90868: PUSH
90869: LD_INT 5
90871: PUSH
90872: LD_INT 6
90874: PUSH
90875: LD_INT 7
90877: PUSH
90878: LD_INT 8
90880: PUSH
90881: LD_INT 11
90883: PUSH
90884: LD_INT 12
90886: PUSH
90887: LD_INT 15
90889: PUSH
90890: LD_INT 16
90892: PUSH
90893: LD_INT 20
90895: PUSH
90896: LD_INT 21
90898: PUSH
90899: LD_INT 22
90901: PUSH
90902: LD_INT 23
90904: PUSH
90905: LD_INT 25
90907: PUSH
90908: LD_INT 26
90910: PUSH
90911: LD_INT 28
90913: PUSH
90914: LD_INT 30
90916: PUSH
90917: LD_INT 31
90919: PUSH
90920: LD_INT 32
90922: PUSH
90923: LD_INT 36
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 101
90951: PUSH
90952: LD_INT 102
90954: PUSH
90955: LD_INT 103
90957: PUSH
90958: LD_INT 105
90960: PUSH
90961: LD_INT 106
90963: PUSH
90964: LD_INT 108
90966: PUSH
90967: LD_INT 109
90969: PUSH
90970: LD_INT 112
90972: PUSH
90973: LD_INT 114
90975: PUSH
90976: LD_INT 116
90978: PUSH
90979: LD_INT 117
90981: PUSH
90982: LD_INT 118
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: ST_TO_ADDR
91003: GO 93102
91005: LD_INT 10
91007: DOUBLE
91008: EQUAL
91009: IFTRUE 91013
91011: GO 91209
91013: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
91014: LD_ADDR_VAR 0 1
91018: PUSH
91019: LD_INT 2
91021: PUSH
91022: LD_INT 4
91024: PUSH
91025: LD_INT 5
91027: PUSH
91028: LD_INT 6
91030: PUSH
91031: LD_INT 7
91033: PUSH
91034: LD_INT 8
91036: PUSH
91037: LD_INT 9
91039: PUSH
91040: LD_INT 10
91042: PUSH
91043: LD_INT 11
91045: PUSH
91046: LD_INT 12
91048: PUSH
91049: LD_INT 13
91051: PUSH
91052: LD_INT 14
91054: PUSH
91055: LD_INT 15
91057: PUSH
91058: LD_INT 16
91060: PUSH
91061: LD_INT 17
91063: PUSH
91064: LD_INT 18
91066: PUSH
91067: LD_INT 19
91069: PUSH
91070: LD_INT 20
91072: PUSH
91073: LD_INT 21
91075: PUSH
91076: LD_INT 22
91078: PUSH
91079: LD_INT 23
91081: PUSH
91082: LD_INT 24
91084: PUSH
91085: LD_INT 25
91087: PUSH
91088: LD_INT 26
91090: PUSH
91091: LD_INT 28
91093: PUSH
91094: LD_INT 30
91096: PUSH
91097: LD_INT 31
91099: PUSH
91100: LD_INT 32
91102: PUSH
91103: LD_INT 36
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: LIST
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: PUSH
91137: LD_INT 101
91139: PUSH
91140: LD_INT 102
91142: PUSH
91143: LD_INT 103
91145: PUSH
91146: LD_INT 104
91148: PUSH
91149: LD_INT 105
91151: PUSH
91152: LD_INT 106
91154: PUSH
91155: LD_INT 107
91157: PUSH
91158: LD_INT 108
91160: PUSH
91161: LD_INT 109
91163: PUSH
91164: LD_INT 110
91166: PUSH
91167: LD_INT 111
91169: PUSH
91170: LD_INT 112
91172: PUSH
91173: LD_INT 114
91175: PUSH
91176: LD_INT 116
91178: PUSH
91179: LD_INT 117
91181: PUSH
91182: LD_INT 118
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: ST_TO_ADDR
91207: GO 93102
91209: LD_INT 11
91211: DOUBLE
91212: EQUAL
91213: IFTRUE 91217
91215: GO 91421
91217: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
91218: LD_ADDR_VAR 0 1
91222: PUSH
91223: LD_INT 2
91225: PUSH
91226: LD_INT 3
91228: PUSH
91229: LD_INT 4
91231: PUSH
91232: LD_INT 5
91234: PUSH
91235: LD_INT 6
91237: PUSH
91238: LD_INT 7
91240: PUSH
91241: LD_INT 8
91243: PUSH
91244: LD_INT 9
91246: PUSH
91247: LD_INT 10
91249: PUSH
91250: LD_INT 11
91252: PUSH
91253: LD_INT 12
91255: PUSH
91256: LD_INT 13
91258: PUSH
91259: LD_INT 14
91261: PUSH
91262: LD_INT 15
91264: PUSH
91265: LD_INT 16
91267: PUSH
91268: LD_INT 17
91270: PUSH
91271: LD_INT 18
91273: PUSH
91274: LD_INT 19
91276: PUSH
91277: LD_INT 20
91279: PUSH
91280: LD_INT 21
91282: PUSH
91283: LD_INT 22
91285: PUSH
91286: LD_INT 23
91288: PUSH
91289: LD_INT 24
91291: PUSH
91292: LD_INT 25
91294: PUSH
91295: LD_INT 26
91297: PUSH
91298: LD_INT 28
91300: PUSH
91301: LD_INT 30
91303: PUSH
91304: LD_INT 31
91306: PUSH
91307: LD_INT 32
91309: PUSH
91310: LD_INT 34
91312: PUSH
91313: LD_INT 36
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 101
91351: PUSH
91352: LD_INT 102
91354: PUSH
91355: LD_INT 103
91357: PUSH
91358: LD_INT 104
91360: PUSH
91361: LD_INT 105
91363: PUSH
91364: LD_INT 106
91366: PUSH
91367: LD_INT 107
91369: PUSH
91370: LD_INT 108
91372: PUSH
91373: LD_INT 109
91375: PUSH
91376: LD_INT 110
91378: PUSH
91379: LD_INT 111
91381: PUSH
91382: LD_INT 112
91384: PUSH
91385: LD_INT 114
91387: PUSH
91388: LD_INT 116
91390: PUSH
91391: LD_INT 117
91393: PUSH
91394: LD_INT 118
91396: PUSH
91397: EMPTY
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: ST_TO_ADDR
91419: GO 93102
91421: LD_INT 12
91423: DOUBLE
91424: EQUAL
91425: IFTRUE 91429
91427: GO 91649
91429: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
91430: LD_ADDR_VAR 0 1
91434: PUSH
91435: LD_INT 1
91437: PUSH
91438: LD_INT 2
91440: PUSH
91441: LD_INT 3
91443: PUSH
91444: LD_INT 4
91446: PUSH
91447: LD_INT 5
91449: PUSH
91450: LD_INT 6
91452: PUSH
91453: LD_INT 7
91455: PUSH
91456: LD_INT 8
91458: PUSH
91459: LD_INT 9
91461: PUSH
91462: LD_INT 10
91464: PUSH
91465: LD_INT 11
91467: PUSH
91468: LD_INT 12
91470: PUSH
91471: LD_INT 13
91473: PUSH
91474: LD_INT 14
91476: PUSH
91477: LD_INT 15
91479: PUSH
91480: LD_INT 16
91482: PUSH
91483: LD_INT 17
91485: PUSH
91486: LD_INT 18
91488: PUSH
91489: LD_INT 19
91491: PUSH
91492: LD_INT 20
91494: PUSH
91495: LD_INT 21
91497: PUSH
91498: LD_INT 22
91500: PUSH
91501: LD_INT 23
91503: PUSH
91504: LD_INT 24
91506: PUSH
91507: LD_INT 25
91509: PUSH
91510: LD_INT 26
91512: PUSH
91513: LD_INT 27
91515: PUSH
91516: LD_INT 28
91518: PUSH
91519: LD_INT 30
91521: PUSH
91522: LD_INT 31
91524: PUSH
91525: LD_INT 32
91527: PUSH
91528: LD_INT 33
91530: PUSH
91531: LD_INT 34
91533: PUSH
91534: LD_INT 36
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: PUSH
91573: LD_INT 101
91575: PUSH
91576: LD_INT 102
91578: PUSH
91579: LD_INT 103
91581: PUSH
91582: LD_INT 104
91584: PUSH
91585: LD_INT 105
91587: PUSH
91588: LD_INT 106
91590: PUSH
91591: LD_INT 107
91593: PUSH
91594: LD_INT 108
91596: PUSH
91597: LD_INT 109
91599: PUSH
91600: LD_INT 110
91602: PUSH
91603: LD_INT 111
91605: PUSH
91606: LD_INT 112
91608: PUSH
91609: LD_INT 113
91611: PUSH
91612: LD_INT 114
91614: PUSH
91615: LD_INT 116
91617: PUSH
91618: LD_INT 117
91620: PUSH
91621: LD_INT 118
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: ST_TO_ADDR
91647: GO 93102
91649: LD_INT 13
91651: DOUBLE
91652: EQUAL
91653: IFTRUE 91657
91655: GO 91865
91657: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
91658: LD_ADDR_VAR 0 1
91662: PUSH
91663: LD_INT 1
91665: PUSH
91666: LD_INT 2
91668: PUSH
91669: LD_INT 3
91671: PUSH
91672: LD_INT 4
91674: PUSH
91675: LD_INT 5
91677: PUSH
91678: LD_INT 8
91680: PUSH
91681: LD_INT 9
91683: PUSH
91684: LD_INT 10
91686: PUSH
91687: LD_INT 11
91689: PUSH
91690: LD_INT 12
91692: PUSH
91693: LD_INT 14
91695: PUSH
91696: LD_INT 15
91698: PUSH
91699: LD_INT 16
91701: PUSH
91702: LD_INT 17
91704: PUSH
91705: LD_INT 18
91707: PUSH
91708: LD_INT 19
91710: PUSH
91711: LD_INT 20
91713: PUSH
91714: LD_INT 21
91716: PUSH
91717: LD_INT 22
91719: PUSH
91720: LD_INT 23
91722: PUSH
91723: LD_INT 24
91725: PUSH
91726: LD_INT 25
91728: PUSH
91729: LD_INT 26
91731: PUSH
91732: LD_INT 27
91734: PUSH
91735: LD_INT 28
91737: PUSH
91738: LD_INT 30
91740: PUSH
91741: LD_INT 31
91743: PUSH
91744: LD_INT 32
91746: PUSH
91747: LD_INT 33
91749: PUSH
91750: LD_INT 34
91752: PUSH
91753: LD_INT 36
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 101
91791: PUSH
91792: LD_INT 102
91794: PUSH
91795: LD_INT 103
91797: PUSH
91798: LD_INT 104
91800: PUSH
91801: LD_INT 105
91803: PUSH
91804: LD_INT 106
91806: PUSH
91807: LD_INT 107
91809: PUSH
91810: LD_INT 108
91812: PUSH
91813: LD_INT 109
91815: PUSH
91816: LD_INT 110
91818: PUSH
91819: LD_INT 111
91821: PUSH
91822: LD_INT 112
91824: PUSH
91825: LD_INT 113
91827: PUSH
91828: LD_INT 114
91830: PUSH
91831: LD_INT 116
91833: PUSH
91834: LD_INT 117
91836: PUSH
91837: LD_INT 118
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: ST_TO_ADDR
91863: GO 93102
91865: LD_INT 14
91867: DOUBLE
91868: EQUAL
91869: IFTRUE 91873
91871: GO 92097
91873: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
91874: LD_ADDR_VAR 0 1
91878: PUSH
91879: LD_INT 1
91881: PUSH
91882: LD_INT 2
91884: PUSH
91885: LD_INT 3
91887: PUSH
91888: LD_INT 4
91890: PUSH
91891: LD_INT 5
91893: PUSH
91894: LD_INT 6
91896: PUSH
91897: LD_INT 7
91899: PUSH
91900: LD_INT 8
91902: PUSH
91903: LD_INT 9
91905: PUSH
91906: LD_INT 10
91908: PUSH
91909: LD_INT 11
91911: PUSH
91912: LD_INT 12
91914: PUSH
91915: LD_INT 13
91917: PUSH
91918: LD_INT 14
91920: PUSH
91921: LD_INT 15
91923: PUSH
91924: LD_INT 16
91926: PUSH
91927: LD_INT 17
91929: PUSH
91930: LD_INT 18
91932: PUSH
91933: LD_INT 19
91935: PUSH
91936: LD_INT 20
91938: PUSH
91939: LD_INT 21
91941: PUSH
91942: LD_INT 22
91944: PUSH
91945: LD_INT 23
91947: PUSH
91948: LD_INT 24
91950: PUSH
91951: LD_INT 25
91953: PUSH
91954: LD_INT 26
91956: PUSH
91957: LD_INT 27
91959: PUSH
91960: LD_INT 28
91962: PUSH
91963: LD_INT 29
91965: PUSH
91966: LD_INT 30
91968: PUSH
91969: LD_INT 31
91971: PUSH
91972: LD_INT 32
91974: PUSH
91975: LD_INT 33
91977: PUSH
91978: LD_INT 34
91980: PUSH
91981: LD_INT 36
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 101
92023: PUSH
92024: LD_INT 102
92026: PUSH
92027: LD_INT 103
92029: PUSH
92030: LD_INT 104
92032: PUSH
92033: LD_INT 105
92035: PUSH
92036: LD_INT 106
92038: PUSH
92039: LD_INT 107
92041: PUSH
92042: LD_INT 108
92044: PUSH
92045: LD_INT 109
92047: PUSH
92048: LD_INT 110
92050: PUSH
92051: LD_INT 111
92053: PUSH
92054: LD_INT 112
92056: PUSH
92057: LD_INT 113
92059: PUSH
92060: LD_INT 114
92062: PUSH
92063: LD_INT 116
92065: PUSH
92066: LD_INT 117
92068: PUSH
92069: LD_INT 118
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: ST_TO_ADDR
92095: GO 93102
92097: LD_INT 15
92099: DOUBLE
92100: EQUAL
92101: IFTRUE 92105
92103: GO 92329
92105: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
92106: LD_ADDR_VAR 0 1
92110: PUSH
92111: LD_INT 1
92113: PUSH
92114: LD_INT 2
92116: PUSH
92117: LD_INT 3
92119: PUSH
92120: LD_INT 4
92122: PUSH
92123: LD_INT 5
92125: PUSH
92126: LD_INT 6
92128: PUSH
92129: LD_INT 7
92131: PUSH
92132: LD_INT 8
92134: PUSH
92135: LD_INT 9
92137: PUSH
92138: LD_INT 10
92140: PUSH
92141: LD_INT 11
92143: PUSH
92144: LD_INT 12
92146: PUSH
92147: LD_INT 13
92149: PUSH
92150: LD_INT 14
92152: PUSH
92153: LD_INT 15
92155: PUSH
92156: LD_INT 16
92158: PUSH
92159: LD_INT 17
92161: PUSH
92162: LD_INT 18
92164: PUSH
92165: LD_INT 19
92167: PUSH
92168: LD_INT 20
92170: PUSH
92171: LD_INT 21
92173: PUSH
92174: LD_INT 22
92176: PUSH
92177: LD_INT 23
92179: PUSH
92180: LD_INT 24
92182: PUSH
92183: LD_INT 25
92185: PUSH
92186: LD_INT 26
92188: PUSH
92189: LD_INT 27
92191: PUSH
92192: LD_INT 28
92194: PUSH
92195: LD_INT 29
92197: PUSH
92198: LD_INT 30
92200: PUSH
92201: LD_INT 31
92203: PUSH
92204: LD_INT 32
92206: PUSH
92207: LD_INT 33
92209: PUSH
92210: LD_INT 34
92212: PUSH
92213: LD_INT 36
92215: PUSH
92216: EMPTY
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 101
92255: PUSH
92256: LD_INT 102
92258: PUSH
92259: LD_INT 103
92261: PUSH
92262: LD_INT 104
92264: PUSH
92265: LD_INT 105
92267: PUSH
92268: LD_INT 106
92270: PUSH
92271: LD_INT 107
92273: PUSH
92274: LD_INT 108
92276: PUSH
92277: LD_INT 109
92279: PUSH
92280: LD_INT 110
92282: PUSH
92283: LD_INT 111
92285: PUSH
92286: LD_INT 112
92288: PUSH
92289: LD_INT 113
92291: PUSH
92292: LD_INT 114
92294: PUSH
92295: LD_INT 116
92297: PUSH
92298: LD_INT 117
92300: PUSH
92301: LD_INT 118
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: ST_TO_ADDR
92327: GO 93102
92329: LD_INT 16
92331: DOUBLE
92332: EQUAL
92333: IFTRUE 92337
92335: GO 92473
92337: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
92338: LD_ADDR_VAR 0 1
92342: PUSH
92343: LD_INT 2
92345: PUSH
92346: LD_INT 4
92348: PUSH
92349: LD_INT 5
92351: PUSH
92352: LD_INT 7
92354: PUSH
92355: LD_INT 11
92357: PUSH
92358: LD_INT 12
92360: PUSH
92361: LD_INT 15
92363: PUSH
92364: LD_INT 16
92366: PUSH
92367: LD_INT 20
92369: PUSH
92370: LD_INT 21
92372: PUSH
92373: LD_INT 22
92375: PUSH
92376: LD_INT 23
92378: PUSH
92379: LD_INT 25
92381: PUSH
92382: LD_INT 26
92384: PUSH
92385: LD_INT 30
92387: PUSH
92388: LD_INT 31
92390: PUSH
92391: LD_INT 32
92393: PUSH
92394: LD_INT 33
92396: PUSH
92397: LD_INT 34
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 101
92423: PUSH
92424: LD_INT 102
92426: PUSH
92427: LD_INT 103
92429: PUSH
92430: LD_INT 106
92432: PUSH
92433: LD_INT 108
92435: PUSH
92436: LD_INT 112
92438: PUSH
92439: LD_INT 113
92441: PUSH
92442: LD_INT 114
92444: PUSH
92445: LD_INT 116
92447: PUSH
92448: LD_INT 117
92450: PUSH
92451: LD_INT 118
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: ST_TO_ADDR
92471: GO 93102
92473: LD_INT 17
92475: DOUBLE
92476: EQUAL
92477: IFTRUE 92481
92479: GO 92705
92481: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
92482: LD_ADDR_VAR 0 1
92486: PUSH
92487: LD_INT 1
92489: PUSH
92490: LD_INT 2
92492: PUSH
92493: LD_INT 3
92495: PUSH
92496: LD_INT 4
92498: PUSH
92499: LD_INT 5
92501: PUSH
92502: LD_INT 6
92504: PUSH
92505: LD_INT 7
92507: PUSH
92508: LD_INT 8
92510: PUSH
92511: LD_INT 9
92513: PUSH
92514: LD_INT 10
92516: PUSH
92517: LD_INT 11
92519: PUSH
92520: LD_INT 12
92522: PUSH
92523: LD_INT 13
92525: PUSH
92526: LD_INT 14
92528: PUSH
92529: LD_INT 15
92531: PUSH
92532: LD_INT 16
92534: PUSH
92535: LD_INT 17
92537: PUSH
92538: LD_INT 18
92540: PUSH
92541: LD_INT 19
92543: PUSH
92544: LD_INT 20
92546: PUSH
92547: LD_INT 21
92549: PUSH
92550: LD_INT 22
92552: PUSH
92553: LD_INT 23
92555: PUSH
92556: LD_INT 24
92558: PUSH
92559: LD_INT 25
92561: PUSH
92562: LD_INT 26
92564: PUSH
92565: LD_INT 27
92567: PUSH
92568: LD_INT 28
92570: PUSH
92571: LD_INT 29
92573: PUSH
92574: LD_INT 30
92576: PUSH
92577: LD_INT 31
92579: PUSH
92580: LD_INT 32
92582: PUSH
92583: LD_INT 33
92585: PUSH
92586: LD_INT 34
92588: PUSH
92589: LD_INT 36
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 101
92631: PUSH
92632: LD_INT 102
92634: PUSH
92635: LD_INT 103
92637: PUSH
92638: LD_INT 104
92640: PUSH
92641: LD_INT 105
92643: PUSH
92644: LD_INT 106
92646: PUSH
92647: LD_INT 107
92649: PUSH
92650: LD_INT 108
92652: PUSH
92653: LD_INT 109
92655: PUSH
92656: LD_INT 110
92658: PUSH
92659: LD_INT 111
92661: PUSH
92662: LD_INT 112
92664: PUSH
92665: LD_INT 113
92667: PUSH
92668: LD_INT 114
92670: PUSH
92671: LD_INT 116
92673: PUSH
92674: LD_INT 117
92676: PUSH
92677: LD_INT 118
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: ST_TO_ADDR
92703: GO 93102
92705: LD_INT 18
92707: DOUBLE
92708: EQUAL
92709: IFTRUE 92713
92711: GO 92861
92713: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
92714: LD_ADDR_VAR 0 1
92718: PUSH
92719: LD_INT 2
92721: PUSH
92722: LD_INT 4
92724: PUSH
92725: LD_INT 5
92727: PUSH
92728: LD_INT 7
92730: PUSH
92731: LD_INT 11
92733: PUSH
92734: LD_INT 12
92736: PUSH
92737: LD_INT 15
92739: PUSH
92740: LD_INT 16
92742: PUSH
92743: LD_INT 20
92745: PUSH
92746: LD_INT 21
92748: PUSH
92749: LD_INT 22
92751: PUSH
92752: LD_INT 23
92754: PUSH
92755: LD_INT 25
92757: PUSH
92758: LD_INT 26
92760: PUSH
92761: LD_INT 30
92763: PUSH
92764: LD_INT 31
92766: PUSH
92767: LD_INT 32
92769: PUSH
92770: LD_INT 33
92772: PUSH
92773: LD_INT 34
92775: PUSH
92776: LD_INT 35
92778: PUSH
92779: LD_INT 36
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 101
92807: PUSH
92808: LD_INT 102
92810: PUSH
92811: LD_INT 103
92813: PUSH
92814: LD_INT 106
92816: PUSH
92817: LD_INT 108
92819: PUSH
92820: LD_INT 112
92822: PUSH
92823: LD_INT 113
92825: PUSH
92826: LD_INT 114
92828: PUSH
92829: LD_INT 115
92831: PUSH
92832: LD_INT 116
92834: PUSH
92835: LD_INT 117
92837: PUSH
92838: LD_INT 118
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: ST_TO_ADDR
92859: GO 93102
92861: LD_INT 19
92863: DOUBLE
92864: EQUAL
92865: IFTRUE 92869
92867: GO 93101
92869: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
92870: LD_ADDR_VAR 0 1
92874: PUSH
92875: LD_INT 1
92877: PUSH
92878: LD_INT 2
92880: PUSH
92881: LD_INT 3
92883: PUSH
92884: LD_INT 4
92886: PUSH
92887: LD_INT 5
92889: PUSH
92890: LD_INT 6
92892: PUSH
92893: LD_INT 7
92895: PUSH
92896: LD_INT 8
92898: PUSH
92899: LD_INT 9
92901: PUSH
92902: LD_INT 10
92904: PUSH
92905: LD_INT 11
92907: PUSH
92908: LD_INT 12
92910: PUSH
92911: LD_INT 13
92913: PUSH
92914: LD_INT 14
92916: PUSH
92917: LD_INT 15
92919: PUSH
92920: LD_INT 16
92922: PUSH
92923: LD_INT 17
92925: PUSH
92926: LD_INT 18
92928: PUSH
92929: LD_INT 19
92931: PUSH
92932: LD_INT 20
92934: PUSH
92935: LD_INT 21
92937: PUSH
92938: LD_INT 22
92940: PUSH
92941: LD_INT 23
92943: PUSH
92944: LD_INT 24
92946: PUSH
92947: LD_INT 25
92949: PUSH
92950: LD_INT 26
92952: PUSH
92953: LD_INT 27
92955: PUSH
92956: LD_INT 28
92958: PUSH
92959: LD_INT 29
92961: PUSH
92962: LD_INT 30
92964: PUSH
92965: LD_INT 31
92967: PUSH
92968: LD_INT 32
92970: PUSH
92971: LD_INT 33
92973: PUSH
92974: LD_INT 34
92976: PUSH
92977: LD_INT 35
92979: PUSH
92980: LD_INT 36
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 101
93023: PUSH
93024: LD_INT 102
93026: PUSH
93027: LD_INT 103
93029: PUSH
93030: LD_INT 104
93032: PUSH
93033: LD_INT 105
93035: PUSH
93036: LD_INT 106
93038: PUSH
93039: LD_INT 107
93041: PUSH
93042: LD_INT 108
93044: PUSH
93045: LD_INT 109
93047: PUSH
93048: LD_INT 110
93050: PUSH
93051: LD_INT 111
93053: PUSH
93054: LD_INT 112
93056: PUSH
93057: LD_INT 113
93059: PUSH
93060: LD_INT 114
93062: PUSH
93063: LD_INT 115
93065: PUSH
93066: LD_INT 116
93068: PUSH
93069: LD_INT 117
93071: PUSH
93072: LD_INT 118
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: ST_TO_ADDR
93099: GO 93102
93101: POP
// end else
93102: GO 93333
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
93104: LD_ADDR_VAR 0 1
93108: PUSH
93109: LD_INT 1
93111: PUSH
93112: LD_INT 2
93114: PUSH
93115: LD_INT 3
93117: PUSH
93118: LD_INT 4
93120: PUSH
93121: LD_INT 5
93123: PUSH
93124: LD_INT 6
93126: PUSH
93127: LD_INT 7
93129: PUSH
93130: LD_INT 8
93132: PUSH
93133: LD_INT 9
93135: PUSH
93136: LD_INT 10
93138: PUSH
93139: LD_INT 11
93141: PUSH
93142: LD_INT 12
93144: PUSH
93145: LD_INT 13
93147: PUSH
93148: LD_INT 14
93150: PUSH
93151: LD_INT 15
93153: PUSH
93154: LD_INT 16
93156: PUSH
93157: LD_INT 17
93159: PUSH
93160: LD_INT 18
93162: PUSH
93163: LD_INT 19
93165: PUSH
93166: LD_INT 20
93168: PUSH
93169: LD_INT 21
93171: PUSH
93172: LD_INT 22
93174: PUSH
93175: LD_INT 23
93177: PUSH
93178: LD_INT 24
93180: PUSH
93181: LD_INT 25
93183: PUSH
93184: LD_INT 26
93186: PUSH
93187: LD_INT 27
93189: PUSH
93190: LD_INT 28
93192: PUSH
93193: LD_INT 29
93195: PUSH
93196: LD_INT 30
93198: PUSH
93199: LD_INT 31
93201: PUSH
93202: LD_INT 32
93204: PUSH
93205: LD_INT 33
93207: PUSH
93208: LD_INT 34
93210: PUSH
93211: LD_INT 35
93213: PUSH
93214: LD_INT 36
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: PUSH
93255: LD_INT 101
93257: PUSH
93258: LD_INT 102
93260: PUSH
93261: LD_INT 103
93263: PUSH
93264: LD_INT 104
93266: PUSH
93267: LD_INT 105
93269: PUSH
93270: LD_INT 106
93272: PUSH
93273: LD_INT 107
93275: PUSH
93276: LD_INT 108
93278: PUSH
93279: LD_INT 109
93281: PUSH
93282: LD_INT 110
93284: PUSH
93285: LD_INT 111
93287: PUSH
93288: LD_INT 112
93290: PUSH
93291: LD_INT 113
93293: PUSH
93294: LD_INT 114
93296: PUSH
93297: LD_INT 115
93299: PUSH
93300: LD_INT 116
93302: PUSH
93303: LD_INT 117
93305: PUSH
93306: LD_INT 118
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: ST_TO_ADDR
// if result then
93333: LD_VAR 0 1
93337: IFFALSE 93626
// begin normal :=  ;
93339: LD_ADDR_VAR 0 3
93343: PUSH
93344: LD_STRING 
93346: ST_TO_ADDR
// hardcore :=  ;
93347: LD_ADDR_VAR 0 4
93351: PUSH
93352: LD_STRING 
93354: ST_TO_ADDR
// for i = 1 to normalCounter do
93355: LD_ADDR_VAR 0 5
93359: PUSH
93360: DOUBLE
93361: LD_INT 1
93363: DEC
93364: ST_TO_ADDR
93365: LD_EXP 114
93369: PUSH
93370: FOR_TO
93371: IFFALSE 93472
// begin tmp := 0 ;
93373: LD_ADDR_VAR 0 2
93377: PUSH
93378: LD_STRING 0
93380: ST_TO_ADDR
// if result [ 1 ] then
93381: LD_VAR 0 1
93385: PUSH
93386: LD_INT 1
93388: ARRAY
93389: IFFALSE 93454
// if result [ 1 ] [ 1 ] = i then
93391: LD_VAR 0 1
93395: PUSH
93396: LD_INT 1
93398: ARRAY
93399: PUSH
93400: LD_INT 1
93402: ARRAY
93403: PUSH
93404: LD_VAR 0 5
93408: EQUAL
93409: IFFALSE 93454
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93411: LD_ADDR_VAR 0 1
93415: PUSH
93416: LD_VAR 0 1
93420: PPUSH
93421: LD_INT 1
93423: PPUSH
93424: LD_VAR 0 1
93428: PUSH
93429: LD_INT 1
93431: ARRAY
93432: PPUSH
93433: LD_INT 1
93435: PPUSH
93436: CALL_OW 3
93440: PPUSH
93441: CALL_OW 1
93445: ST_TO_ADDR
// tmp := 1 ;
93446: LD_ADDR_VAR 0 2
93450: PUSH
93451: LD_STRING 1
93453: ST_TO_ADDR
// end ; normal := normal & tmp ;
93454: LD_ADDR_VAR 0 3
93458: PUSH
93459: LD_VAR 0 3
93463: PUSH
93464: LD_VAR 0 2
93468: STR
93469: ST_TO_ADDR
// end ;
93470: GO 93370
93472: POP
93473: POP
// for i = 1 to hardcoreCounter do
93474: LD_ADDR_VAR 0 5
93478: PUSH
93479: DOUBLE
93480: LD_INT 1
93482: DEC
93483: ST_TO_ADDR
93484: LD_EXP 115
93488: PUSH
93489: FOR_TO
93490: IFFALSE 93595
// begin tmp := 0 ;
93492: LD_ADDR_VAR 0 2
93496: PUSH
93497: LD_STRING 0
93499: ST_TO_ADDR
// if result [ 2 ] then
93500: LD_VAR 0 1
93504: PUSH
93505: LD_INT 2
93507: ARRAY
93508: IFFALSE 93577
// if result [ 2 ] [ 1 ] = 100 + i then
93510: LD_VAR 0 1
93514: PUSH
93515: LD_INT 2
93517: ARRAY
93518: PUSH
93519: LD_INT 1
93521: ARRAY
93522: PUSH
93523: LD_INT 100
93525: PUSH
93526: LD_VAR 0 5
93530: PLUS
93531: EQUAL
93532: IFFALSE 93577
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93534: LD_ADDR_VAR 0 1
93538: PUSH
93539: LD_VAR 0 1
93543: PPUSH
93544: LD_INT 2
93546: PPUSH
93547: LD_VAR 0 1
93551: PUSH
93552: LD_INT 2
93554: ARRAY
93555: PPUSH
93556: LD_INT 1
93558: PPUSH
93559: CALL_OW 3
93563: PPUSH
93564: CALL_OW 1
93568: ST_TO_ADDR
// tmp := 1 ;
93569: LD_ADDR_VAR 0 2
93573: PUSH
93574: LD_STRING 1
93576: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93577: LD_ADDR_VAR 0 4
93581: PUSH
93582: LD_VAR 0 4
93586: PUSH
93587: LD_VAR 0 2
93591: STR
93592: ST_TO_ADDR
// end ;
93593: GO 93489
93595: POP
93596: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
93597: LD_STRING getStreamItemsFromMission("
93599: PUSH
93600: LD_VAR 0 3
93604: STR
93605: PUSH
93606: LD_STRING ","
93608: STR
93609: PUSH
93610: LD_VAR 0 4
93614: STR
93615: PUSH
93616: LD_STRING ")
93618: STR
93619: PPUSH
93620: CALL_OW 559
// end else
93624: GO 93633
// ToLua ( getStreamItemsFromMission("","") ) ;
93626: LD_STRING getStreamItemsFromMission("","")
93628: PPUSH
93629: CALL_OW 559
// end ;
93633: LD_VAR 0 1
93637: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93638: LD_EXP 113
93642: PUSH
93643: LD_EXP 118
93647: AND
93648: IFFALSE 93772
93650: GO 93652
93652: DISABLE
93653: LD_INT 0
93655: PPUSH
93656: PPUSH
// begin enable ;
93657: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93658: LD_ADDR_VAR 0 2
93662: PUSH
93663: LD_INT 22
93665: PUSH
93666: LD_OWVAR 2
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: LD_INT 2
93677: PUSH
93678: LD_INT 34
93680: PUSH
93681: LD_INT 7
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: LD_INT 34
93690: PUSH
93691: LD_INT 45
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: PUSH
93698: LD_INT 34
93700: PUSH
93701: LD_INT 28
93703: PUSH
93704: EMPTY
93705: LIST
93706: LIST
93707: PUSH
93708: LD_INT 34
93710: PUSH
93711: LD_INT 47
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PPUSH
93729: CALL_OW 69
93733: ST_TO_ADDR
// if not tmp then
93734: LD_VAR 0 2
93738: NOT
93739: IFFALSE 93743
// exit ;
93741: GO 93772
// for i in tmp do
93743: LD_ADDR_VAR 0 1
93747: PUSH
93748: LD_VAR 0 2
93752: PUSH
93753: FOR_IN
93754: IFFALSE 93770
// begin SetLives ( i , 0 ) ;
93756: LD_VAR 0 1
93760: PPUSH
93761: LD_INT 0
93763: PPUSH
93764: CALL_OW 234
// end ;
93768: GO 93753
93770: POP
93771: POP
// end ;
93772: PPOPN 2
93774: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93775: LD_EXP 113
93779: PUSH
93780: LD_EXP 119
93784: AND
93785: IFFALSE 93869
93787: GO 93789
93789: DISABLE
93790: LD_INT 0
93792: PPUSH
93793: PPUSH
// begin enable ;
93794: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93795: LD_ADDR_VAR 0 2
93799: PUSH
93800: LD_INT 22
93802: PUSH
93803: LD_OWVAR 2
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: PUSH
93812: LD_INT 32
93814: PUSH
93815: LD_INT 3
93817: PUSH
93818: EMPTY
93819: LIST
93820: LIST
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PPUSH
93826: CALL_OW 69
93830: ST_TO_ADDR
// if not tmp then
93831: LD_VAR 0 2
93835: NOT
93836: IFFALSE 93840
// exit ;
93838: GO 93869
// for i in tmp do
93840: LD_ADDR_VAR 0 1
93844: PUSH
93845: LD_VAR 0 2
93849: PUSH
93850: FOR_IN
93851: IFFALSE 93867
// begin SetLives ( i , 0 ) ;
93853: LD_VAR 0 1
93857: PPUSH
93858: LD_INT 0
93860: PPUSH
93861: CALL_OW 234
// end ;
93865: GO 93850
93867: POP
93868: POP
// end ;
93869: PPOPN 2
93871: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93872: LD_EXP 113
93876: PUSH
93877: LD_EXP 116
93881: AND
93882: IFFALSE 93975
93884: GO 93886
93886: DISABLE
93887: LD_INT 0
93889: PPUSH
// begin enable ;
93890: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93891: LD_ADDR_VAR 0 1
93895: PUSH
93896: LD_INT 22
93898: PUSH
93899: LD_OWVAR 2
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PUSH
93908: LD_INT 2
93910: PUSH
93911: LD_INT 25
93913: PUSH
93914: LD_INT 5
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 25
93923: PUSH
93924: LD_INT 9
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: LD_INT 25
93933: PUSH
93934: LD_INT 8
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PPUSH
93951: CALL_OW 69
93955: PUSH
93956: FOR_IN
93957: IFFALSE 93973
// begin SetClass ( i , 1 ) ;
93959: LD_VAR 0 1
93963: PPUSH
93964: LD_INT 1
93966: PPUSH
93967: CALL_OW 336
// end ;
93971: GO 93956
93973: POP
93974: POP
// end ;
93975: PPOPN 1
93977: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93978: LD_EXP 113
93982: PUSH
93983: LD_EXP 117
93987: AND
93988: PUSH
93989: LD_OWVAR 65
93993: PUSH
93994: LD_INT 7
93996: LESS
93997: AND
93998: IFFALSE 94012
94000: GO 94002
94002: DISABLE
// begin enable ;
94003: ENABLE
// game_speed := 7 ;
94004: LD_ADDR_OWVAR 65
94008: PUSH
94009: LD_INT 7
94011: ST_TO_ADDR
// end ;
94012: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94013: LD_EXP 113
94017: PUSH
94018: LD_EXP 120
94022: AND
94023: IFFALSE 94225
94025: GO 94027
94027: DISABLE
94028: LD_INT 0
94030: PPUSH
94031: PPUSH
94032: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94033: LD_ADDR_VAR 0 3
94037: PUSH
94038: LD_INT 81
94040: PUSH
94041: LD_OWVAR 2
94045: PUSH
94046: EMPTY
94047: LIST
94048: LIST
94049: PUSH
94050: LD_INT 21
94052: PUSH
94053: LD_INT 1
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PPUSH
94064: CALL_OW 69
94068: ST_TO_ADDR
// if not tmp then
94069: LD_VAR 0 3
94073: NOT
94074: IFFALSE 94078
// exit ;
94076: GO 94225
// if tmp > 5 then
94078: LD_VAR 0 3
94082: PUSH
94083: LD_INT 5
94085: GREATER
94086: IFFALSE 94098
// k := 5 else
94088: LD_ADDR_VAR 0 2
94092: PUSH
94093: LD_INT 5
94095: ST_TO_ADDR
94096: GO 94108
// k := tmp ;
94098: LD_ADDR_VAR 0 2
94102: PUSH
94103: LD_VAR 0 3
94107: ST_TO_ADDR
// for i := 1 to k do
94108: LD_ADDR_VAR 0 1
94112: PUSH
94113: DOUBLE
94114: LD_INT 1
94116: DEC
94117: ST_TO_ADDR
94118: LD_VAR 0 2
94122: PUSH
94123: FOR_TO
94124: IFFALSE 94223
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94126: LD_VAR 0 3
94130: PUSH
94131: LD_VAR 0 1
94135: ARRAY
94136: PPUSH
94137: LD_VAR 0 1
94141: PUSH
94142: LD_INT 4
94144: MOD
94145: PUSH
94146: LD_INT 1
94148: PLUS
94149: PPUSH
94150: CALL_OW 259
94154: PUSH
94155: LD_INT 10
94157: LESS
94158: IFFALSE 94221
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94160: LD_VAR 0 3
94164: PUSH
94165: LD_VAR 0 1
94169: ARRAY
94170: PPUSH
94171: LD_VAR 0 1
94175: PUSH
94176: LD_INT 4
94178: MOD
94179: PUSH
94180: LD_INT 1
94182: PLUS
94183: PPUSH
94184: LD_VAR 0 3
94188: PUSH
94189: LD_VAR 0 1
94193: ARRAY
94194: PPUSH
94195: LD_VAR 0 1
94199: PUSH
94200: LD_INT 4
94202: MOD
94203: PUSH
94204: LD_INT 1
94206: PLUS
94207: PPUSH
94208: CALL_OW 259
94212: PUSH
94213: LD_INT 1
94215: PLUS
94216: PPUSH
94217: CALL_OW 237
94221: GO 94123
94223: POP
94224: POP
// end ;
94225: PPOPN 3
94227: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94228: LD_EXP 113
94232: PUSH
94233: LD_EXP 121
94237: AND
94238: IFFALSE 94258
94240: GO 94242
94242: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94243: LD_INT 4
94245: PPUSH
94246: LD_OWVAR 2
94250: PPUSH
94251: LD_INT 0
94253: PPUSH
94254: CALL_OW 324
94258: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94259: LD_EXP 113
94263: PUSH
94264: LD_EXP 150
94268: AND
94269: IFFALSE 94289
94271: GO 94273
94273: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94274: LD_INT 19
94276: PPUSH
94277: LD_OWVAR 2
94281: PPUSH
94282: LD_INT 0
94284: PPUSH
94285: CALL_OW 324
94289: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94290: LD_EXP 113
94294: PUSH
94295: LD_EXP 122
94299: AND
94300: IFFALSE 94402
94302: GO 94304
94304: DISABLE
94305: LD_INT 0
94307: PPUSH
94308: PPUSH
// begin enable ;
94309: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94310: LD_ADDR_VAR 0 2
94314: PUSH
94315: LD_INT 22
94317: PUSH
94318: LD_OWVAR 2
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: PUSH
94327: LD_INT 2
94329: PUSH
94330: LD_INT 34
94332: PUSH
94333: LD_INT 11
94335: PUSH
94336: EMPTY
94337: LIST
94338: LIST
94339: PUSH
94340: LD_INT 34
94342: PUSH
94343: LD_INT 30
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: LIST
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PPUSH
94359: CALL_OW 69
94363: ST_TO_ADDR
// if not tmp then
94364: LD_VAR 0 2
94368: NOT
94369: IFFALSE 94373
// exit ;
94371: GO 94402
// for i in tmp do
94373: LD_ADDR_VAR 0 1
94377: PUSH
94378: LD_VAR 0 2
94382: PUSH
94383: FOR_IN
94384: IFFALSE 94400
// begin SetLives ( i , 0 ) ;
94386: LD_VAR 0 1
94390: PPUSH
94391: LD_INT 0
94393: PPUSH
94394: CALL_OW 234
// end ;
94398: GO 94383
94400: POP
94401: POP
// end ;
94402: PPOPN 2
94404: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94405: LD_EXP 113
94409: PUSH
94410: LD_EXP 123
94414: AND
94415: IFFALSE 94435
94417: GO 94419
94419: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94420: LD_INT 32
94422: PPUSH
94423: LD_OWVAR 2
94427: PPUSH
94428: LD_INT 0
94430: PPUSH
94431: CALL_OW 324
94435: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94436: LD_EXP 113
94440: PUSH
94441: LD_EXP 124
94445: AND
94446: IFFALSE 94627
94448: GO 94450
94450: DISABLE
94451: LD_INT 0
94453: PPUSH
94454: PPUSH
94455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94456: LD_ADDR_VAR 0 2
94460: PUSH
94461: LD_INT 22
94463: PUSH
94464: LD_OWVAR 2
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 33
94475: PUSH
94476: LD_INT 3
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: EMPTY
94484: LIST
94485: LIST
94486: PPUSH
94487: CALL_OW 69
94491: ST_TO_ADDR
// if not tmp then
94492: LD_VAR 0 2
94496: NOT
94497: IFFALSE 94501
// exit ;
94499: GO 94627
// side := 0 ;
94501: LD_ADDR_VAR 0 3
94505: PUSH
94506: LD_INT 0
94508: ST_TO_ADDR
// for i := 1 to 8 do
94509: LD_ADDR_VAR 0 1
94513: PUSH
94514: DOUBLE
94515: LD_INT 1
94517: DEC
94518: ST_TO_ADDR
94519: LD_INT 8
94521: PUSH
94522: FOR_TO
94523: IFFALSE 94571
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94525: LD_OWVAR 2
94529: PUSH
94530: LD_VAR 0 1
94534: NONEQUAL
94535: PUSH
94536: LD_OWVAR 2
94540: PPUSH
94541: LD_VAR 0 1
94545: PPUSH
94546: CALL_OW 81
94550: PUSH
94551: LD_INT 2
94553: EQUAL
94554: AND
94555: IFFALSE 94569
// begin side := i ;
94557: LD_ADDR_VAR 0 3
94561: PUSH
94562: LD_VAR 0 1
94566: ST_TO_ADDR
// break ;
94567: GO 94571
// end ;
94569: GO 94522
94571: POP
94572: POP
// if not side then
94573: LD_VAR 0 3
94577: NOT
94578: IFFALSE 94582
// exit ;
94580: GO 94627
// for i := 1 to tmp do
94582: LD_ADDR_VAR 0 1
94586: PUSH
94587: DOUBLE
94588: LD_INT 1
94590: DEC
94591: ST_TO_ADDR
94592: LD_VAR 0 2
94596: PUSH
94597: FOR_TO
94598: IFFALSE 94625
// if Prob ( 60 ) then
94600: LD_INT 60
94602: PPUSH
94603: CALL_OW 13
94607: IFFALSE 94623
// SetSide ( i , side ) ;
94609: LD_VAR 0 1
94613: PPUSH
94614: LD_VAR 0 3
94618: PPUSH
94619: CALL_OW 235
94623: GO 94597
94625: POP
94626: POP
// end ;
94627: PPOPN 3
94629: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94630: LD_EXP 113
94634: PUSH
94635: LD_EXP 126
94639: AND
94640: IFFALSE 94759
94642: GO 94644
94644: DISABLE
94645: LD_INT 0
94647: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94648: LD_ADDR_VAR 0 1
94652: PUSH
94653: LD_INT 22
94655: PUSH
94656: LD_OWVAR 2
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: PUSH
94665: LD_INT 21
94667: PUSH
94668: LD_INT 1
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 3
94677: PUSH
94678: LD_INT 23
94680: PUSH
94681: LD_INT 0
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: EMPTY
94689: LIST
94690: LIST
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: LIST
94696: PPUSH
94697: CALL_OW 69
94701: PUSH
94702: FOR_IN
94703: IFFALSE 94757
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94705: LD_VAR 0 1
94709: PPUSH
94710: CALL_OW 257
94714: PUSH
94715: LD_INT 1
94717: PUSH
94718: LD_INT 2
94720: PUSH
94721: LD_INT 3
94723: PUSH
94724: LD_INT 4
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: IN
94733: IFFALSE 94755
// SetClass ( un , rand ( 1 , 4 ) ) ;
94735: LD_VAR 0 1
94739: PPUSH
94740: LD_INT 1
94742: PPUSH
94743: LD_INT 4
94745: PPUSH
94746: CALL_OW 12
94750: PPUSH
94751: CALL_OW 336
94755: GO 94702
94757: POP
94758: POP
// end ;
94759: PPOPN 1
94761: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94762: LD_EXP 113
94766: PUSH
94767: LD_EXP 125
94771: AND
94772: IFFALSE 94851
94774: GO 94776
94776: DISABLE
94777: LD_INT 0
94779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94780: LD_ADDR_VAR 0 1
94784: PUSH
94785: LD_INT 22
94787: PUSH
94788: LD_OWVAR 2
94792: PUSH
94793: EMPTY
94794: LIST
94795: LIST
94796: PUSH
94797: LD_INT 21
94799: PUSH
94800: LD_INT 3
94802: PUSH
94803: EMPTY
94804: LIST
94805: LIST
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PPUSH
94811: CALL_OW 69
94815: ST_TO_ADDR
// if not tmp then
94816: LD_VAR 0 1
94820: NOT
94821: IFFALSE 94825
// exit ;
94823: GO 94851
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94825: LD_VAR 0 1
94829: PUSH
94830: LD_INT 1
94832: PPUSH
94833: LD_VAR 0 1
94837: PPUSH
94838: CALL_OW 12
94842: ARRAY
94843: PPUSH
94844: LD_INT 100
94846: PPUSH
94847: CALL_OW 234
// end ;
94851: PPOPN 1
94853: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94854: LD_EXP 113
94858: PUSH
94859: LD_EXP 127
94863: AND
94864: IFFALSE 94962
94866: GO 94868
94868: DISABLE
94869: LD_INT 0
94871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94872: LD_ADDR_VAR 0 1
94876: PUSH
94877: LD_INT 22
94879: PUSH
94880: LD_OWVAR 2
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 21
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: PPUSH
94903: CALL_OW 69
94907: ST_TO_ADDR
// if not tmp then
94908: LD_VAR 0 1
94912: NOT
94913: IFFALSE 94917
// exit ;
94915: GO 94962
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94917: LD_VAR 0 1
94921: PUSH
94922: LD_INT 1
94924: PPUSH
94925: LD_VAR 0 1
94929: PPUSH
94930: CALL_OW 12
94934: ARRAY
94935: PPUSH
94936: LD_INT 1
94938: PPUSH
94939: LD_INT 4
94941: PPUSH
94942: CALL_OW 12
94946: PPUSH
94947: LD_INT 3000
94949: PPUSH
94950: LD_INT 9000
94952: PPUSH
94953: CALL_OW 12
94957: PPUSH
94958: CALL_OW 492
// end ;
94962: PPOPN 1
94964: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94965: LD_EXP 113
94969: PUSH
94970: LD_EXP 128
94974: AND
94975: IFFALSE 94995
94977: GO 94979
94979: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94980: LD_INT 1
94982: PPUSH
94983: LD_OWVAR 2
94987: PPUSH
94988: LD_INT 0
94990: PPUSH
94991: CALL_OW 324
94995: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94996: LD_EXP 113
95000: PUSH
95001: LD_EXP 129
95005: AND
95006: IFFALSE 95089
95008: GO 95010
95010: DISABLE
95011: LD_INT 0
95013: PPUSH
95014: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95015: LD_ADDR_VAR 0 2
95019: PUSH
95020: LD_INT 22
95022: PUSH
95023: LD_OWVAR 2
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 21
95034: PUSH
95035: LD_INT 3
95037: PUSH
95038: EMPTY
95039: LIST
95040: LIST
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PPUSH
95046: CALL_OW 69
95050: ST_TO_ADDR
// if not tmp then
95051: LD_VAR 0 2
95055: NOT
95056: IFFALSE 95060
// exit ;
95058: GO 95089
// for i in tmp do
95060: LD_ADDR_VAR 0 1
95064: PUSH
95065: LD_VAR 0 2
95069: PUSH
95070: FOR_IN
95071: IFFALSE 95087
// SetBLevel ( i , 10 ) ;
95073: LD_VAR 0 1
95077: PPUSH
95078: LD_INT 10
95080: PPUSH
95081: CALL_OW 241
95085: GO 95070
95087: POP
95088: POP
// end ;
95089: PPOPN 2
95091: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95092: LD_EXP 113
95096: PUSH
95097: LD_EXP 130
95101: AND
95102: IFFALSE 95213
95104: GO 95106
95106: DISABLE
95107: LD_INT 0
95109: PPUSH
95110: PPUSH
95111: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95112: LD_ADDR_VAR 0 3
95116: PUSH
95117: LD_INT 22
95119: PUSH
95120: LD_OWVAR 2
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 25
95131: PUSH
95132: LD_INT 1
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PPUSH
95143: CALL_OW 69
95147: ST_TO_ADDR
// if not tmp then
95148: LD_VAR 0 3
95152: NOT
95153: IFFALSE 95157
// exit ;
95155: GO 95213
// un := tmp [ rand ( 1 , tmp ) ] ;
95157: LD_ADDR_VAR 0 2
95161: PUSH
95162: LD_VAR 0 3
95166: PUSH
95167: LD_INT 1
95169: PPUSH
95170: LD_VAR 0 3
95174: PPUSH
95175: CALL_OW 12
95179: ARRAY
95180: ST_TO_ADDR
// if Crawls ( un ) then
95181: LD_VAR 0 2
95185: PPUSH
95186: CALL_OW 318
95190: IFFALSE 95201
// ComWalk ( un ) ;
95192: LD_VAR 0 2
95196: PPUSH
95197: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95201: LD_VAR 0 2
95205: PPUSH
95206: LD_INT 5
95208: PPUSH
95209: CALL_OW 336
// end ;
95213: PPOPN 3
95215: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
95216: LD_EXP 113
95220: PUSH
95221: LD_EXP 131
95225: AND
95226: PUSH
95227: LD_OWVAR 67
95231: PUSH
95232: LD_INT 4
95234: LESS
95235: AND
95236: IFFALSE 95255
95238: GO 95240
95240: DISABLE
// begin Difficulty := Difficulty + 1 ;
95241: LD_ADDR_OWVAR 67
95245: PUSH
95246: LD_OWVAR 67
95250: PUSH
95251: LD_INT 1
95253: PLUS
95254: ST_TO_ADDR
// end ;
95255: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95256: LD_EXP 113
95260: PUSH
95261: LD_EXP 132
95265: AND
95266: IFFALSE 95369
95268: GO 95270
95270: DISABLE
95271: LD_INT 0
95273: PPUSH
// begin for i := 1 to 5 do
95274: LD_ADDR_VAR 0 1
95278: PUSH
95279: DOUBLE
95280: LD_INT 1
95282: DEC
95283: ST_TO_ADDR
95284: LD_INT 5
95286: PUSH
95287: FOR_TO
95288: IFFALSE 95367
// begin uc_nation := nation_nature ;
95290: LD_ADDR_OWVAR 21
95294: PUSH
95295: LD_INT 0
95297: ST_TO_ADDR
// uc_side := 0 ;
95298: LD_ADDR_OWVAR 20
95302: PUSH
95303: LD_INT 0
95305: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95306: LD_ADDR_OWVAR 29
95310: PUSH
95311: LD_INT 12
95313: PUSH
95314: LD_INT 12
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: ST_TO_ADDR
// hc_agressivity := 20 ;
95321: LD_ADDR_OWVAR 35
95325: PUSH
95326: LD_INT 20
95328: ST_TO_ADDR
// hc_class := class_tiger ;
95329: LD_ADDR_OWVAR 28
95333: PUSH
95334: LD_INT 14
95336: ST_TO_ADDR
// hc_gallery :=  ;
95337: LD_ADDR_OWVAR 33
95341: PUSH
95342: LD_STRING 
95344: ST_TO_ADDR
// hc_name :=  ;
95345: LD_ADDR_OWVAR 26
95349: PUSH
95350: LD_STRING 
95352: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95353: CALL_OW 44
95357: PPUSH
95358: LD_INT 0
95360: PPUSH
95361: CALL_OW 51
// end ;
95365: GO 95287
95367: POP
95368: POP
// end ;
95369: PPOPN 1
95371: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95372: LD_EXP 113
95376: PUSH
95377: LD_EXP 133
95381: AND
95382: IFFALSE 95391
95384: GO 95386
95386: DISABLE
// StreamSibBomb ;
95387: CALL 95392 0 0
95391: END
// export function StreamSibBomb ; var i , x , y ; begin
95392: LD_INT 0
95394: PPUSH
95395: PPUSH
95396: PPUSH
95397: PPUSH
// result := false ;
95398: LD_ADDR_VAR 0 1
95402: PUSH
95403: LD_INT 0
95405: ST_TO_ADDR
// for i := 1 to 16 do
95406: LD_ADDR_VAR 0 2
95410: PUSH
95411: DOUBLE
95412: LD_INT 1
95414: DEC
95415: ST_TO_ADDR
95416: LD_INT 16
95418: PUSH
95419: FOR_TO
95420: IFFALSE 95619
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95422: LD_ADDR_VAR 0 3
95426: PUSH
95427: LD_INT 10
95429: PUSH
95430: LD_INT 20
95432: PUSH
95433: LD_INT 30
95435: PUSH
95436: LD_INT 40
95438: PUSH
95439: LD_INT 50
95441: PUSH
95442: LD_INT 60
95444: PUSH
95445: LD_INT 70
95447: PUSH
95448: LD_INT 80
95450: PUSH
95451: LD_INT 90
95453: PUSH
95454: LD_INT 100
95456: PUSH
95457: LD_INT 110
95459: PUSH
95460: LD_INT 120
95462: PUSH
95463: LD_INT 130
95465: PUSH
95466: LD_INT 140
95468: PUSH
95469: LD_INT 150
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: PUSH
95489: LD_INT 1
95491: PPUSH
95492: LD_INT 15
95494: PPUSH
95495: CALL_OW 12
95499: ARRAY
95500: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95501: LD_ADDR_VAR 0 4
95505: PUSH
95506: LD_INT 10
95508: PUSH
95509: LD_INT 20
95511: PUSH
95512: LD_INT 30
95514: PUSH
95515: LD_INT 40
95517: PUSH
95518: LD_INT 50
95520: PUSH
95521: LD_INT 60
95523: PUSH
95524: LD_INT 70
95526: PUSH
95527: LD_INT 80
95529: PUSH
95530: LD_INT 90
95532: PUSH
95533: LD_INT 100
95535: PUSH
95536: LD_INT 110
95538: PUSH
95539: LD_INT 120
95541: PUSH
95542: LD_INT 130
95544: PUSH
95545: LD_INT 140
95547: PUSH
95548: LD_INT 150
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 1
95570: PPUSH
95571: LD_INT 15
95573: PPUSH
95574: CALL_OW 12
95578: ARRAY
95579: ST_TO_ADDR
// if ValidHex ( x , y ) then
95580: LD_VAR 0 3
95584: PPUSH
95585: LD_VAR 0 4
95589: PPUSH
95590: CALL_OW 488
95594: IFFALSE 95617
// begin result := [ x , y ] ;
95596: LD_ADDR_VAR 0 1
95600: PUSH
95601: LD_VAR 0 3
95605: PUSH
95606: LD_VAR 0 4
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: ST_TO_ADDR
// break ;
95615: GO 95619
// end ; end ;
95617: GO 95419
95619: POP
95620: POP
// if result then
95621: LD_VAR 0 1
95625: IFFALSE 95685
// begin ToLua ( playSibBomb() ) ;
95627: LD_STRING playSibBomb()
95629: PPUSH
95630: CALL_OW 559
// wait ( 0 0$14 ) ;
95634: LD_INT 490
95636: PPUSH
95637: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95641: LD_VAR 0 1
95645: PUSH
95646: LD_INT 1
95648: ARRAY
95649: PPUSH
95650: LD_VAR 0 1
95654: PUSH
95655: LD_INT 2
95657: ARRAY
95658: PPUSH
95659: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95663: LD_VAR 0 1
95667: PUSH
95668: LD_INT 1
95670: ARRAY
95671: PPUSH
95672: LD_VAR 0 1
95676: PUSH
95677: LD_INT 2
95679: ARRAY
95680: PPUSH
95681: CALL_OW 429
// end ; end ;
95685: LD_VAR 0 1
95689: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95690: LD_EXP 113
95694: PUSH
95695: LD_EXP 135
95699: AND
95700: IFFALSE 95712
95702: GO 95704
95704: DISABLE
// YouLost (  ) ;
95705: LD_STRING 
95707: PPUSH
95708: CALL_OW 104
95712: END
// every 0 0$1 trigger StreamModeActive and sFog do
95713: LD_EXP 113
95717: PUSH
95718: LD_EXP 134
95722: AND
95723: IFFALSE 95737
95725: GO 95727
95727: DISABLE
// FogOff ( your_side ) ;
95728: LD_OWVAR 2
95732: PPUSH
95733: CALL_OW 344
95737: END
// every 0 0$1 trigger StreamModeActive and sSun do
95738: LD_EXP 113
95742: PUSH
95743: LD_EXP 136
95747: AND
95748: IFFALSE 95776
95750: GO 95752
95752: DISABLE
// begin solar_recharge_percent := 0 ;
95753: LD_ADDR_OWVAR 79
95757: PUSH
95758: LD_INT 0
95760: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95761: LD_INT 10500
95763: PPUSH
95764: CALL_OW 67
// solar_recharge_percent := 100 ;
95768: LD_ADDR_OWVAR 79
95772: PUSH
95773: LD_INT 100
95775: ST_TO_ADDR
// end ;
95776: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95777: LD_EXP 113
95781: PUSH
95782: LD_EXP 137
95786: AND
95787: IFFALSE 96026
95789: GO 95791
95791: DISABLE
95792: LD_INT 0
95794: PPUSH
95795: PPUSH
95796: PPUSH
// begin tmp := [ ] ;
95797: LD_ADDR_VAR 0 3
95801: PUSH
95802: EMPTY
95803: ST_TO_ADDR
// for i := 1 to 6 do
95804: LD_ADDR_VAR 0 1
95808: PUSH
95809: DOUBLE
95810: LD_INT 1
95812: DEC
95813: ST_TO_ADDR
95814: LD_INT 6
95816: PUSH
95817: FOR_TO
95818: IFFALSE 95923
// begin uc_nation := nation_nature ;
95820: LD_ADDR_OWVAR 21
95824: PUSH
95825: LD_INT 0
95827: ST_TO_ADDR
// uc_side := 0 ;
95828: LD_ADDR_OWVAR 20
95832: PUSH
95833: LD_INT 0
95835: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95836: LD_ADDR_OWVAR 29
95840: PUSH
95841: LD_INT 12
95843: PUSH
95844: LD_INT 12
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: ST_TO_ADDR
// hc_agressivity := 20 ;
95851: LD_ADDR_OWVAR 35
95855: PUSH
95856: LD_INT 20
95858: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95859: LD_ADDR_OWVAR 28
95863: PUSH
95864: LD_INT 17
95866: ST_TO_ADDR
// hc_gallery :=  ;
95867: LD_ADDR_OWVAR 33
95871: PUSH
95872: LD_STRING 
95874: ST_TO_ADDR
// hc_name :=  ;
95875: LD_ADDR_OWVAR 26
95879: PUSH
95880: LD_STRING 
95882: ST_TO_ADDR
// un := CreateHuman ;
95883: LD_ADDR_VAR 0 2
95887: PUSH
95888: CALL_OW 44
95892: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95893: LD_VAR 0 2
95897: PPUSH
95898: LD_INT 1
95900: PPUSH
95901: CALL_OW 51
// tmp := tmp ^ un ;
95905: LD_ADDR_VAR 0 3
95909: PUSH
95910: LD_VAR 0 3
95914: PUSH
95915: LD_VAR 0 2
95919: ADD
95920: ST_TO_ADDR
// end ;
95921: GO 95817
95923: POP
95924: POP
// repeat wait ( 0 0$1 ) ;
95925: LD_INT 35
95927: PPUSH
95928: CALL_OW 67
// for un in tmp do
95932: LD_ADDR_VAR 0 2
95936: PUSH
95937: LD_VAR 0 3
95941: PUSH
95942: FOR_IN
95943: IFFALSE 96017
// begin if IsDead ( un ) then
95945: LD_VAR 0 2
95949: PPUSH
95950: CALL_OW 301
95954: IFFALSE 95974
// begin tmp := tmp diff un ;
95956: LD_ADDR_VAR 0 3
95960: PUSH
95961: LD_VAR 0 3
95965: PUSH
95966: LD_VAR 0 2
95970: DIFF
95971: ST_TO_ADDR
// continue ;
95972: GO 95942
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95974: LD_VAR 0 2
95978: PPUSH
95979: LD_INT 3
95981: PUSH
95982: LD_INT 22
95984: PUSH
95985: LD_INT 0
95987: PUSH
95988: EMPTY
95989: LIST
95990: LIST
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: PPUSH
95996: CALL_OW 69
96000: PPUSH
96001: LD_VAR 0 2
96005: PPUSH
96006: CALL_OW 74
96010: PPUSH
96011: CALL_OW 115
// end ;
96015: GO 95942
96017: POP
96018: POP
// until not tmp ;
96019: LD_VAR 0 3
96023: NOT
96024: IFFALSE 95925
// end ;
96026: PPOPN 3
96028: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96029: LD_EXP 113
96033: PUSH
96034: LD_EXP 138
96038: AND
96039: IFFALSE 96093
96041: GO 96043
96043: DISABLE
// begin ToLua ( displayTroll(); ) ;
96044: LD_STRING displayTroll();
96046: PPUSH
96047: CALL_OW 559
// wait ( 3 3$00 ) ;
96051: LD_INT 6300
96053: PPUSH
96054: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96058: LD_STRING hideTroll();
96060: PPUSH
96061: CALL_OW 559
// wait ( 1 1$00 ) ;
96065: LD_INT 2100
96067: PPUSH
96068: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96072: LD_STRING displayTroll();
96074: PPUSH
96075: CALL_OW 559
// wait ( 1 1$00 ) ;
96079: LD_INT 2100
96081: PPUSH
96082: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96086: LD_STRING hideTroll();
96088: PPUSH
96089: CALL_OW 559
// end ;
96093: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96094: LD_EXP 113
96098: PUSH
96099: LD_EXP 139
96103: AND
96104: IFFALSE 96167
96106: GO 96108
96108: DISABLE
96109: LD_INT 0
96111: PPUSH
// begin p := 0 ;
96112: LD_ADDR_VAR 0 1
96116: PUSH
96117: LD_INT 0
96119: ST_TO_ADDR
// repeat game_speed := 1 ;
96120: LD_ADDR_OWVAR 65
96124: PUSH
96125: LD_INT 1
96127: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96128: LD_INT 35
96130: PPUSH
96131: CALL_OW 67
// p := p + 1 ;
96135: LD_ADDR_VAR 0 1
96139: PUSH
96140: LD_VAR 0 1
96144: PUSH
96145: LD_INT 1
96147: PLUS
96148: ST_TO_ADDR
// until p >= 60 ;
96149: LD_VAR 0 1
96153: PUSH
96154: LD_INT 60
96156: GREATEREQUAL
96157: IFFALSE 96120
// game_speed := 4 ;
96159: LD_ADDR_OWVAR 65
96163: PUSH
96164: LD_INT 4
96166: ST_TO_ADDR
// end ;
96167: PPOPN 1
96169: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96170: LD_EXP 113
96174: PUSH
96175: LD_EXP 140
96179: AND
96180: IFFALSE 96326
96182: GO 96184
96184: DISABLE
96185: LD_INT 0
96187: PPUSH
96188: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96189: LD_ADDR_VAR 0 1
96193: PUSH
96194: LD_INT 22
96196: PUSH
96197: LD_OWVAR 2
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PUSH
96206: LD_INT 2
96208: PUSH
96209: LD_INT 30
96211: PUSH
96212: LD_INT 0
96214: PUSH
96215: EMPTY
96216: LIST
96217: LIST
96218: PUSH
96219: LD_INT 30
96221: PUSH
96222: LD_INT 1
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PUSH
96229: EMPTY
96230: LIST
96231: LIST
96232: LIST
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PPUSH
96238: CALL_OW 69
96242: ST_TO_ADDR
// if not depot then
96243: LD_VAR 0 1
96247: NOT
96248: IFFALSE 96252
// exit ;
96250: GO 96326
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96252: LD_ADDR_VAR 0 2
96256: PUSH
96257: LD_VAR 0 1
96261: PUSH
96262: LD_INT 1
96264: PPUSH
96265: LD_VAR 0 1
96269: PPUSH
96270: CALL_OW 12
96274: ARRAY
96275: PPUSH
96276: CALL_OW 274
96280: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96281: LD_VAR 0 2
96285: PPUSH
96286: LD_INT 1
96288: PPUSH
96289: LD_INT 0
96291: PPUSH
96292: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96296: LD_VAR 0 2
96300: PPUSH
96301: LD_INT 2
96303: PPUSH
96304: LD_INT 0
96306: PPUSH
96307: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96311: LD_VAR 0 2
96315: PPUSH
96316: LD_INT 3
96318: PPUSH
96319: LD_INT 0
96321: PPUSH
96322: CALL_OW 277
// end ;
96326: PPOPN 2
96328: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96329: LD_EXP 113
96333: PUSH
96334: LD_EXP 141
96338: AND
96339: IFFALSE 96436
96341: GO 96343
96343: DISABLE
96344: LD_INT 0
96346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96347: LD_ADDR_VAR 0 1
96351: PUSH
96352: LD_INT 22
96354: PUSH
96355: LD_OWVAR 2
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 21
96366: PUSH
96367: LD_INT 1
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 3
96376: PUSH
96377: LD_INT 23
96379: PUSH
96380: LD_INT 0
96382: PUSH
96383: EMPTY
96384: LIST
96385: LIST
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: LIST
96395: PPUSH
96396: CALL_OW 69
96400: ST_TO_ADDR
// if not tmp then
96401: LD_VAR 0 1
96405: NOT
96406: IFFALSE 96410
// exit ;
96408: GO 96436
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96410: LD_VAR 0 1
96414: PUSH
96415: LD_INT 1
96417: PPUSH
96418: LD_VAR 0 1
96422: PPUSH
96423: CALL_OW 12
96427: ARRAY
96428: PPUSH
96429: LD_INT 200
96431: PPUSH
96432: CALL_OW 234
// end ;
96436: PPOPN 1
96438: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96439: LD_EXP 113
96443: PUSH
96444: LD_EXP 142
96448: AND
96449: IFFALSE 96528
96451: GO 96453
96453: DISABLE
96454: LD_INT 0
96456: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96457: LD_ADDR_VAR 0 1
96461: PUSH
96462: LD_INT 22
96464: PUSH
96465: LD_OWVAR 2
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: PUSH
96474: LD_INT 21
96476: PUSH
96477: LD_INT 2
96479: PUSH
96480: EMPTY
96481: LIST
96482: LIST
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PPUSH
96488: CALL_OW 69
96492: ST_TO_ADDR
// if not tmp then
96493: LD_VAR 0 1
96497: NOT
96498: IFFALSE 96502
// exit ;
96500: GO 96528
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96502: LD_VAR 0 1
96506: PUSH
96507: LD_INT 1
96509: PPUSH
96510: LD_VAR 0 1
96514: PPUSH
96515: CALL_OW 12
96519: ARRAY
96520: PPUSH
96521: LD_INT 60
96523: PPUSH
96524: CALL_OW 234
// end ;
96528: PPOPN 1
96530: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96531: LD_EXP 113
96535: PUSH
96536: LD_EXP 143
96540: AND
96541: IFFALSE 96640
96543: GO 96545
96545: DISABLE
96546: LD_INT 0
96548: PPUSH
96549: PPUSH
// begin enable ;
96550: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96551: LD_ADDR_VAR 0 1
96555: PUSH
96556: LD_INT 22
96558: PUSH
96559: LD_OWVAR 2
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: PUSH
96568: LD_INT 61
96570: PUSH
96571: EMPTY
96572: LIST
96573: PUSH
96574: LD_INT 33
96576: PUSH
96577: LD_INT 2
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: LIST
96588: PPUSH
96589: CALL_OW 69
96593: ST_TO_ADDR
// if not tmp then
96594: LD_VAR 0 1
96598: NOT
96599: IFFALSE 96603
// exit ;
96601: GO 96640
// for i in tmp do
96603: LD_ADDR_VAR 0 2
96607: PUSH
96608: LD_VAR 0 1
96612: PUSH
96613: FOR_IN
96614: IFFALSE 96638
// if IsControledBy ( i ) then
96616: LD_VAR 0 2
96620: PPUSH
96621: CALL_OW 312
96625: IFFALSE 96636
// ComUnlink ( i ) ;
96627: LD_VAR 0 2
96631: PPUSH
96632: CALL_OW 136
96636: GO 96613
96638: POP
96639: POP
// end ;
96640: PPOPN 2
96642: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96643: LD_EXP 113
96647: PUSH
96648: LD_EXP 144
96652: AND
96653: IFFALSE 96793
96655: GO 96657
96657: DISABLE
96658: LD_INT 0
96660: PPUSH
96661: PPUSH
// begin ToLua ( displayPowell(); ) ;
96662: LD_STRING displayPowell();
96664: PPUSH
96665: CALL_OW 559
// uc_side := 0 ;
96669: LD_ADDR_OWVAR 20
96673: PUSH
96674: LD_INT 0
96676: ST_TO_ADDR
// uc_nation := 2 ;
96677: LD_ADDR_OWVAR 21
96681: PUSH
96682: LD_INT 2
96684: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96685: LD_ADDR_OWVAR 37
96689: PUSH
96690: LD_INT 14
96692: ST_TO_ADDR
// vc_engine := engine_siberite ;
96693: LD_ADDR_OWVAR 39
96697: PUSH
96698: LD_INT 3
96700: ST_TO_ADDR
// vc_control := control_apeman ;
96701: LD_ADDR_OWVAR 38
96705: PUSH
96706: LD_INT 5
96708: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96709: LD_ADDR_OWVAR 40
96713: PUSH
96714: LD_INT 29
96716: ST_TO_ADDR
// un := CreateVehicle ;
96717: LD_ADDR_VAR 0 2
96721: PUSH
96722: CALL_OW 45
96726: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96727: LD_VAR 0 2
96731: PPUSH
96732: LD_INT 1
96734: PPUSH
96735: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96739: LD_INT 35
96741: PPUSH
96742: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96746: LD_VAR 0 2
96750: PPUSH
96751: LD_INT 22
96753: PUSH
96754: LD_OWVAR 2
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: PPUSH
96763: CALL_OW 69
96767: PPUSH
96768: LD_VAR 0 2
96772: PPUSH
96773: CALL_OW 74
96777: PPUSH
96778: CALL_OW 115
// until IsDead ( un ) ;
96782: LD_VAR 0 2
96786: PPUSH
96787: CALL_OW 301
96791: IFFALSE 96739
// end ;
96793: PPOPN 2
96795: END
// every 0 0$1 trigger StreamModeActive and sStu do
96796: LD_EXP 113
96800: PUSH
96801: LD_EXP 152
96805: AND
96806: IFFALSE 96822
96808: GO 96810
96810: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96811: LD_STRING displayStucuk();
96813: PPUSH
96814: CALL_OW 559
// ResetFog ;
96818: CALL_OW 335
// end ;
96822: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96823: LD_EXP 113
96827: PUSH
96828: LD_EXP 145
96832: AND
96833: IFFALSE 96974
96835: GO 96837
96837: DISABLE
96838: LD_INT 0
96840: PPUSH
96841: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96842: LD_ADDR_VAR 0 2
96846: PUSH
96847: LD_INT 22
96849: PUSH
96850: LD_OWVAR 2
96854: PUSH
96855: EMPTY
96856: LIST
96857: LIST
96858: PUSH
96859: LD_INT 21
96861: PUSH
96862: LD_INT 1
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PPUSH
96873: CALL_OW 69
96877: ST_TO_ADDR
// if not tmp then
96878: LD_VAR 0 2
96882: NOT
96883: IFFALSE 96887
// exit ;
96885: GO 96974
// un := tmp [ rand ( 1 , tmp ) ] ;
96887: LD_ADDR_VAR 0 1
96891: PUSH
96892: LD_VAR 0 2
96896: PUSH
96897: LD_INT 1
96899: PPUSH
96900: LD_VAR 0 2
96904: PPUSH
96905: CALL_OW 12
96909: ARRAY
96910: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96911: LD_VAR 0 1
96915: PPUSH
96916: LD_INT 0
96918: PPUSH
96919: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96923: LD_VAR 0 1
96927: PPUSH
96928: LD_OWVAR 3
96932: PUSH
96933: LD_VAR 0 1
96937: DIFF
96938: PPUSH
96939: LD_VAR 0 1
96943: PPUSH
96944: CALL_OW 74
96948: PPUSH
96949: CALL_OW 115
// wait ( 0 0$20 ) ;
96953: LD_INT 700
96955: PPUSH
96956: CALL_OW 67
// SetSide ( un , your_side ) ;
96960: LD_VAR 0 1
96964: PPUSH
96965: LD_OWVAR 2
96969: PPUSH
96970: CALL_OW 235
// end ;
96974: PPOPN 2
96976: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96977: LD_EXP 113
96981: PUSH
96982: LD_EXP 146
96986: AND
96987: IFFALSE 97093
96989: GO 96991
96991: DISABLE
96992: LD_INT 0
96994: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96995: LD_ADDR_VAR 0 1
96999: PUSH
97000: LD_INT 22
97002: PUSH
97003: LD_OWVAR 2
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: PUSH
97012: LD_INT 2
97014: PUSH
97015: LD_INT 30
97017: PUSH
97018: LD_INT 0
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: PUSH
97025: LD_INT 30
97027: PUSH
97028: LD_INT 1
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: LIST
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: PPUSH
97044: CALL_OW 69
97048: ST_TO_ADDR
// if not depot then
97049: LD_VAR 0 1
97053: NOT
97054: IFFALSE 97058
// exit ;
97056: GO 97093
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97058: LD_VAR 0 1
97062: PUSH
97063: LD_INT 1
97065: ARRAY
97066: PPUSH
97067: CALL_OW 250
97071: PPUSH
97072: LD_VAR 0 1
97076: PUSH
97077: LD_INT 1
97079: ARRAY
97080: PPUSH
97081: CALL_OW 251
97085: PPUSH
97086: LD_INT 70
97088: PPUSH
97089: CALL_OW 495
// end ;
97093: PPOPN 1
97095: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97096: LD_EXP 113
97100: PUSH
97101: LD_EXP 147
97105: AND
97106: IFFALSE 97317
97108: GO 97110
97110: DISABLE
97111: LD_INT 0
97113: PPUSH
97114: PPUSH
97115: PPUSH
97116: PPUSH
97117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97118: LD_ADDR_VAR 0 5
97122: PUSH
97123: LD_INT 22
97125: PUSH
97126: LD_OWVAR 2
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: LD_INT 21
97137: PUSH
97138: LD_INT 1
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: PPUSH
97149: CALL_OW 69
97153: ST_TO_ADDR
// if not tmp then
97154: LD_VAR 0 5
97158: NOT
97159: IFFALSE 97163
// exit ;
97161: GO 97317
// for i in tmp do
97163: LD_ADDR_VAR 0 1
97167: PUSH
97168: LD_VAR 0 5
97172: PUSH
97173: FOR_IN
97174: IFFALSE 97315
// begin d := rand ( 0 , 5 ) ;
97176: LD_ADDR_VAR 0 4
97180: PUSH
97181: LD_INT 0
97183: PPUSH
97184: LD_INT 5
97186: PPUSH
97187: CALL_OW 12
97191: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97192: LD_ADDR_VAR 0 2
97196: PUSH
97197: LD_VAR 0 1
97201: PPUSH
97202: CALL_OW 250
97206: PPUSH
97207: LD_VAR 0 4
97211: PPUSH
97212: LD_INT 3
97214: PPUSH
97215: LD_INT 12
97217: PPUSH
97218: CALL_OW 12
97222: PPUSH
97223: CALL_OW 272
97227: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97228: LD_ADDR_VAR 0 3
97232: PUSH
97233: LD_VAR 0 1
97237: PPUSH
97238: CALL_OW 251
97242: PPUSH
97243: LD_VAR 0 4
97247: PPUSH
97248: LD_INT 3
97250: PPUSH
97251: LD_INT 12
97253: PPUSH
97254: CALL_OW 12
97258: PPUSH
97259: CALL_OW 273
97263: ST_TO_ADDR
// if ValidHex ( x , y ) then
97264: LD_VAR 0 2
97268: PPUSH
97269: LD_VAR 0 3
97273: PPUSH
97274: CALL_OW 488
97278: IFFALSE 97313
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97280: LD_VAR 0 1
97284: PPUSH
97285: LD_VAR 0 2
97289: PPUSH
97290: LD_VAR 0 3
97294: PPUSH
97295: LD_INT 3
97297: PPUSH
97298: LD_INT 6
97300: PPUSH
97301: CALL_OW 12
97305: PPUSH
97306: LD_INT 1
97308: PPUSH
97309: CALL_OW 483
// end ;
97313: GO 97173
97315: POP
97316: POP
// end ;
97317: PPOPN 5
97319: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97320: LD_EXP 113
97324: PUSH
97325: LD_EXP 148
97329: AND
97330: IFFALSE 97424
97332: GO 97334
97334: DISABLE
97335: LD_INT 0
97337: PPUSH
97338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97339: LD_ADDR_VAR 0 2
97343: PUSH
97344: LD_INT 22
97346: PUSH
97347: LD_OWVAR 2
97351: PUSH
97352: EMPTY
97353: LIST
97354: LIST
97355: PUSH
97356: LD_INT 32
97358: PUSH
97359: LD_INT 1
97361: PUSH
97362: EMPTY
97363: LIST
97364: LIST
97365: PUSH
97366: LD_INT 21
97368: PUSH
97369: LD_INT 2
97371: PUSH
97372: EMPTY
97373: LIST
97374: LIST
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: LIST
97380: PPUSH
97381: CALL_OW 69
97385: ST_TO_ADDR
// if not tmp then
97386: LD_VAR 0 2
97390: NOT
97391: IFFALSE 97395
// exit ;
97393: GO 97424
// for i in tmp do
97395: LD_ADDR_VAR 0 1
97399: PUSH
97400: LD_VAR 0 2
97404: PUSH
97405: FOR_IN
97406: IFFALSE 97422
// SetFuel ( i , 0 ) ;
97408: LD_VAR 0 1
97412: PPUSH
97413: LD_INT 0
97415: PPUSH
97416: CALL_OW 240
97420: GO 97405
97422: POP
97423: POP
// end ;
97424: PPOPN 2
97426: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97427: LD_EXP 113
97431: PUSH
97432: LD_EXP 149
97436: AND
97437: IFFALSE 97503
97439: GO 97441
97441: DISABLE
97442: LD_INT 0
97444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97445: LD_ADDR_VAR 0 1
97449: PUSH
97450: LD_INT 22
97452: PUSH
97453: LD_OWVAR 2
97457: PUSH
97458: EMPTY
97459: LIST
97460: LIST
97461: PUSH
97462: LD_INT 30
97464: PUSH
97465: LD_INT 29
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: PUSH
97472: EMPTY
97473: LIST
97474: LIST
97475: PPUSH
97476: CALL_OW 69
97480: ST_TO_ADDR
// if not tmp then
97481: LD_VAR 0 1
97485: NOT
97486: IFFALSE 97490
// exit ;
97488: GO 97503
// DestroyUnit ( tmp [ 1 ] ) ;
97490: LD_VAR 0 1
97494: PUSH
97495: LD_INT 1
97497: ARRAY
97498: PPUSH
97499: CALL_OW 65
// end ;
97503: PPOPN 1
97505: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97506: LD_EXP 113
97510: PUSH
97511: LD_EXP 151
97515: AND
97516: IFFALSE 97645
97518: GO 97520
97520: DISABLE
97521: LD_INT 0
97523: PPUSH
// begin uc_side := 0 ;
97524: LD_ADDR_OWVAR 20
97528: PUSH
97529: LD_INT 0
97531: ST_TO_ADDR
// uc_nation := nation_arabian ;
97532: LD_ADDR_OWVAR 21
97536: PUSH
97537: LD_INT 2
97539: ST_TO_ADDR
// hc_gallery :=  ;
97540: LD_ADDR_OWVAR 33
97544: PUSH
97545: LD_STRING 
97547: ST_TO_ADDR
// hc_name :=  ;
97548: LD_ADDR_OWVAR 26
97552: PUSH
97553: LD_STRING 
97555: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97556: LD_INT 1
97558: PPUSH
97559: LD_INT 11
97561: PPUSH
97562: LD_INT 10
97564: PPUSH
97565: CALL_OW 380
// un := CreateHuman ;
97569: LD_ADDR_VAR 0 1
97573: PUSH
97574: CALL_OW 44
97578: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97579: LD_VAR 0 1
97583: PPUSH
97584: LD_INT 1
97586: PPUSH
97587: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97591: LD_INT 35
97593: PPUSH
97594: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97598: LD_VAR 0 1
97602: PPUSH
97603: LD_INT 22
97605: PUSH
97606: LD_OWVAR 2
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: PPUSH
97615: CALL_OW 69
97619: PPUSH
97620: LD_VAR 0 1
97624: PPUSH
97625: CALL_OW 74
97629: PPUSH
97630: CALL_OW 115
// until IsDead ( un ) ;
97634: LD_VAR 0 1
97638: PPUSH
97639: CALL_OW 301
97643: IFFALSE 97591
// end ;
97645: PPOPN 1
97647: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97648: LD_EXP 113
97652: PUSH
97653: LD_EXP 153
97657: AND
97658: IFFALSE 97670
97660: GO 97662
97662: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97663: LD_STRING earthquake(getX(game), 0, 32)
97665: PPUSH
97666: CALL_OW 559
97670: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97671: LD_EXP 113
97675: PUSH
97676: LD_EXP 154
97680: AND
97681: IFFALSE 97772
97683: GO 97685
97685: DISABLE
97686: LD_INT 0
97688: PPUSH
// begin enable ;
97689: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97690: LD_ADDR_VAR 0 1
97694: PUSH
97695: LD_INT 22
97697: PUSH
97698: LD_OWVAR 2
97702: PUSH
97703: EMPTY
97704: LIST
97705: LIST
97706: PUSH
97707: LD_INT 21
97709: PUSH
97710: LD_INT 2
97712: PUSH
97713: EMPTY
97714: LIST
97715: LIST
97716: PUSH
97717: LD_INT 33
97719: PUSH
97720: LD_INT 3
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: PUSH
97727: EMPTY
97728: LIST
97729: LIST
97730: LIST
97731: PPUSH
97732: CALL_OW 69
97736: ST_TO_ADDR
// if not tmp then
97737: LD_VAR 0 1
97741: NOT
97742: IFFALSE 97746
// exit ;
97744: GO 97772
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97746: LD_VAR 0 1
97750: PUSH
97751: LD_INT 1
97753: PPUSH
97754: LD_VAR 0 1
97758: PPUSH
97759: CALL_OW 12
97763: ARRAY
97764: PPUSH
97765: LD_INT 1
97767: PPUSH
97768: CALL_OW 234
// end ;
97772: PPOPN 1
97774: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97775: LD_EXP 113
97779: PUSH
97780: LD_EXP 155
97784: AND
97785: IFFALSE 97926
97787: GO 97789
97789: DISABLE
97790: LD_INT 0
97792: PPUSH
97793: PPUSH
97794: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97795: LD_ADDR_VAR 0 3
97799: PUSH
97800: LD_INT 22
97802: PUSH
97803: LD_OWVAR 2
97807: PUSH
97808: EMPTY
97809: LIST
97810: LIST
97811: PUSH
97812: LD_INT 25
97814: PUSH
97815: LD_INT 1
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: PUSH
97822: EMPTY
97823: LIST
97824: LIST
97825: PPUSH
97826: CALL_OW 69
97830: ST_TO_ADDR
// if not tmp then
97831: LD_VAR 0 3
97835: NOT
97836: IFFALSE 97840
// exit ;
97838: GO 97926
// un := tmp [ rand ( 1 , tmp ) ] ;
97840: LD_ADDR_VAR 0 2
97844: PUSH
97845: LD_VAR 0 3
97849: PUSH
97850: LD_INT 1
97852: PPUSH
97853: LD_VAR 0 3
97857: PPUSH
97858: CALL_OW 12
97862: ARRAY
97863: ST_TO_ADDR
// if Crawls ( un ) then
97864: LD_VAR 0 2
97868: PPUSH
97869: CALL_OW 318
97873: IFFALSE 97884
// ComWalk ( un ) ;
97875: LD_VAR 0 2
97879: PPUSH
97880: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97884: LD_VAR 0 2
97888: PPUSH
97889: LD_INT 9
97891: PPUSH
97892: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97896: LD_INT 28
97898: PPUSH
97899: LD_OWVAR 2
97903: PPUSH
97904: LD_INT 2
97906: PPUSH
97907: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97911: LD_INT 29
97913: PPUSH
97914: LD_OWVAR 2
97918: PPUSH
97919: LD_INT 2
97921: PPUSH
97922: CALL_OW 322
// end ;
97926: PPOPN 3
97928: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97929: LD_EXP 113
97933: PUSH
97934: LD_EXP 156
97938: AND
97939: IFFALSE 98050
97941: GO 97943
97943: DISABLE
97944: LD_INT 0
97946: PPUSH
97947: PPUSH
97948: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97949: LD_ADDR_VAR 0 3
97953: PUSH
97954: LD_INT 22
97956: PUSH
97957: LD_OWVAR 2
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: PUSH
97966: LD_INT 25
97968: PUSH
97969: LD_INT 1
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: PPUSH
97980: CALL_OW 69
97984: ST_TO_ADDR
// if not tmp then
97985: LD_VAR 0 3
97989: NOT
97990: IFFALSE 97994
// exit ;
97992: GO 98050
// un := tmp [ rand ( 1 , tmp ) ] ;
97994: LD_ADDR_VAR 0 2
97998: PUSH
97999: LD_VAR 0 3
98003: PUSH
98004: LD_INT 1
98006: PPUSH
98007: LD_VAR 0 3
98011: PPUSH
98012: CALL_OW 12
98016: ARRAY
98017: ST_TO_ADDR
// if Crawls ( un ) then
98018: LD_VAR 0 2
98022: PPUSH
98023: CALL_OW 318
98027: IFFALSE 98038
// ComWalk ( un ) ;
98029: LD_VAR 0 2
98033: PPUSH
98034: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98038: LD_VAR 0 2
98042: PPUSH
98043: LD_INT 8
98045: PPUSH
98046: CALL_OW 336
// end ;
98050: PPOPN 3
98052: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98053: LD_EXP 113
98057: PUSH
98058: LD_EXP 157
98062: AND
98063: IFFALSE 98207
98065: GO 98067
98067: DISABLE
98068: LD_INT 0
98070: PPUSH
98071: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98072: LD_ADDR_VAR 0 2
98076: PUSH
98077: LD_INT 22
98079: PUSH
98080: LD_OWVAR 2
98084: PUSH
98085: EMPTY
98086: LIST
98087: LIST
98088: PUSH
98089: LD_INT 21
98091: PUSH
98092: LD_INT 2
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PUSH
98099: LD_INT 2
98101: PUSH
98102: LD_INT 34
98104: PUSH
98105: LD_INT 12
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PUSH
98112: LD_INT 34
98114: PUSH
98115: LD_INT 51
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PUSH
98122: LD_INT 34
98124: PUSH
98125: LD_INT 32
98127: PUSH
98128: EMPTY
98129: LIST
98130: LIST
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: LIST
98142: PPUSH
98143: CALL_OW 69
98147: ST_TO_ADDR
// if not tmp then
98148: LD_VAR 0 2
98152: NOT
98153: IFFALSE 98157
// exit ;
98155: GO 98207
// for i in tmp do
98157: LD_ADDR_VAR 0 1
98161: PUSH
98162: LD_VAR 0 2
98166: PUSH
98167: FOR_IN
98168: IFFALSE 98205
// if GetCargo ( i , mat_artifact ) = 0 then
98170: LD_VAR 0 1
98174: PPUSH
98175: LD_INT 4
98177: PPUSH
98178: CALL_OW 289
98182: PUSH
98183: LD_INT 0
98185: EQUAL
98186: IFFALSE 98203
// SetCargo ( i , mat_siberit , 100 ) ;
98188: LD_VAR 0 1
98192: PPUSH
98193: LD_INT 3
98195: PPUSH
98196: LD_INT 100
98198: PPUSH
98199: CALL_OW 290
98203: GO 98167
98205: POP
98206: POP
// end ;
98207: PPOPN 2
98209: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98210: LD_EXP 113
98214: PUSH
98215: LD_EXP 158
98219: AND
98220: IFFALSE 98403
98222: GO 98224
98224: DISABLE
98225: LD_INT 0
98227: PPUSH
98228: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98229: LD_ADDR_VAR 0 2
98233: PUSH
98234: LD_INT 22
98236: PUSH
98237: LD_OWVAR 2
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PPUSH
98246: CALL_OW 69
98250: ST_TO_ADDR
// if not tmp then
98251: LD_VAR 0 2
98255: NOT
98256: IFFALSE 98260
// exit ;
98258: GO 98403
// for i := 1 to 2 do
98260: LD_ADDR_VAR 0 1
98264: PUSH
98265: DOUBLE
98266: LD_INT 1
98268: DEC
98269: ST_TO_ADDR
98270: LD_INT 2
98272: PUSH
98273: FOR_TO
98274: IFFALSE 98401
// begin uc_side := your_side ;
98276: LD_ADDR_OWVAR 20
98280: PUSH
98281: LD_OWVAR 2
98285: ST_TO_ADDR
// uc_nation := nation_american ;
98286: LD_ADDR_OWVAR 21
98290: PUSH
98291: LD_INT 1
98293: ST_TO_ADDR
// vc_chassis := us_morphling ;
98294: LD_ADDR_OWVAR 37
98298: PUSH
98299: LD_INT 5
98301: ST_TO_ADDR
// vc_engine := engine_siberite ;
98302: LD_ADDR_OWVAR 39
98306: PUSH
98307: LD_INT 3
98309: ST_TO_ADDR
// vc_control := control_computer ;
98310: LD_ADDR_OWVAR 38
98314: PUSH
98315: LD_INT 3
98317: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98318: LD_ADDR_OWVAR 40
98322: PUSH
98323: LD_INT 10
98325: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98326: LD_VAR 0 2
98330: PUSH
98331: LD_INT 1
98333: ARRAY
98334: PPUSH
98335: CALL_OW 310
98339: NOT
98340: IFFALSE 98387
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98342: CALL_OW 45
98346: PPUSH
98347: LD_VAR 0 2
98351: PUSH
98352: LD_INT 1
98354: ARRAY
98355: PPUSH
98356: CALL_OW 250
98360: PPUSH
98361: LD_VAR 0 2
98365: PUSH
98366: LD_INT 1
98368: ARRAY
98369: PPUSH
98370: CALL_OW 251
98374: PPUSH
98375: LD_INT 12
98377: PPUSH
98378: LD_INT 1
98380: PPUSH
98381: CALL_OW 50
98385: GO 98399
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98387: CALL_OW 45
98391: PPUSH
98392: LD_INT 1
98394: PPUSH
98395: CALL_OW 51
// end ;
98399: GO 98273
98401: POP
98402: POP
// end ;
98403: PPOPN 2
98405: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98406: LD_EXP 113
98410: PUSH
98411: LD_EXP 159
98415: AND
98416: IFFALSE 98638
98418: GO 98420
98420: DISABLE
98421: LD_INT 0
98423: PPUSH
98424: PPUSH
98425: PPUSH
98426: PPUSH
98427: PPUSH
98428: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98429: LD_ADDR_VAR 0 6
98433: PUSH
98434: LD_INT 22
98436: PUSH
98437: LD_OWVAR 2
98441: PUSH
98442: EMPTY
98443: LIST
98444: LIST
98445: PUSH
98446: LD_INT 21
98448: PUSH
98449: LD_INT 1
98451: PUSH
98452: EMPTY
98453: LIST
98454: LIST
98455: PUSH
98456: LD_INT 3
98458: PUSH
98459: LD_INT 23
98461: PUSH
98462: LD_INT 0
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: EMPTY
98470: LIST
98471: LIST
98472: PUSH
98473: EMPTY
98474: LIST
98475: LIST
98476: LIST
98477: PPUSH
98478: CALL_OW 69
98482: ST_TO_ADDR
// if not tmp then
98483: LD_VAR 0 6
98487: NOT
98488: IFFALSE 98492
// exit ;
98490: GO 98638
// s1 := rand ( 1 , 4 ) ;
98492: LD_ADDR_VAR 0 2
98496: PUSH
98497: LD_INT 1
98499: PPUSH
98500: LD_INT 4
98502: PPUSH
98503: CALL_OW 12
98507: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98508: LD_ADDR_VAR 0 4
98512: PUSH
98513: LD_VAR 0 6
98517: PUSH
98518: LD_INT 1
98520: ARRAY
98521: PPUSH
98522: LD_VAR 0 2
98526: PPUSH
98527: CALL_OW 259
98531: ST_TO_ADDR
// if s1 = 1 then
98532: LD_VAR 0 2
98536: PUSH
98537: LD_INT 1
98539: EQUAL
98540: IFFALSE 98560
// s2 := rand ( 2 , 4 ) else
98542: LD_ADDR_VAR 0 3
98546: PUSH
98547: LD_INT 2
98549: PPUSH
98550: LD_INT 4
98552: PPUSH
98553: CALL_OW 12
98557: ST_TO_ADDR
98558: GO 98568
// s2 := 1 ;
98560: LD_ADDR_VAR 0 3
98564: PUSH
98565: LD_INT 1
98567: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98568: LD_ADDR_VAR 0 5
98572: PUSH
98573: LD_VAR 0 6
98577: PUSH
98578: LD_INT 1
98580: ARRAY
98581: PPUSH
98582: LD_VAR 0 3
98586: PPUSH
98587: CALL_OW 259
98591: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98592: LD_VAR 0 6
98596: PUSH
98597: LD_INT 1
98599: ARRAY
98600: PPUSH
98601: LD_VAR 0 2
98605: PPUSH
98606: LD_VAR 0 5
98610: PPUSH
98611: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98615: LD_VAR 0 6
98619: PUSH
98620: LD_INT 1
98622: ARRAY
98623: PPUSH
98624: LD_VAR 0 3
98628: PPUSH
98629: LD_VAR 0 4
98633: PPUSH
98634: CALL_OW 237
// end ;
98638: PPOPN 6
98640: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98641: LD_EXP 113
98645: PUSH
98646: LD_EXP 160
98650: AND
98651: IFFALSE 98730
98653: GO 98655
98655: DISABLE
98656: LD_INT 0
98658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98659: LD_ADDR_VAR 0 1
98663: PUSH
98664: LD_INT 22
98666: PUSH
98667: LD_OWVAR 2
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: LD_INT 30
98678: PUSH
98679: LD_INT 3
98681: PUSH
98682: EMPTY
98683: LIST
98684: LIST
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: PPUSH
98690: CALL_OW 69
98694: ST_TO_ADDR
// if not tmp then
98695: LD_VAR 0 1
98699: NOT
98700: IFFALSE 98704
// exit ;
98702: GO 98730
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98704: LD_VAR 0 1
98708: PUSH
98709: LD_INT 1
98711: PPUSH
98712: LD_VAR 0 1
98716: PPUSH
98717: CALL_OW 12
98721: ARRAY
98722: PPUSH
98723: LD_INT 1
98725: PPUSH
98726: CALL_OW 234
// end ;
98730: PPOPN 1
98732: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98733: LD_EXP 113
98737: PUSH
98738: LD_EXP 161
98742: AND
98743: IFFALSE 98855
98745: GO 98747
98747: DISABLE
98748: LD_INT 0
98750: PPUSH
98751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98752: LD_ADDR_VAR 0 2
98756: PUSH
98757: LD_INT 22
98759: PUSH
98760: LD_OWVAR 2
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PUSH
98769: LD_INT 2
98771: PUSH
98772: LD_INT 30
98774: PUSH
98775: LD_INT 27
98777: PUSH
98778: EMPTY
98779: LIST
98780: LIST
98781: PUSH
98782: LD_INT 30
98784: PUSH
98785: LD_INT 26
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: PUSH
98792: LD_INT 30
98794: PUSH
98795: LD_INT 28
98797: PUSH
98798: EMPTY
98799: LIST
98800: LIST
98801: PUSH
98802: EMPTY
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: PUSH
98808: EMPTY
98809: LIST
98810: LIST
98811: PPUSH
98812: CALL_OW 69
98816: ST_TO_ADDR
// if not tmp then
98817: LD_VAR 0 2
98821: NOT
98822: IFFALSE 98826
// exit ;
98824: GO 98855
// for i in tmp do
98826: LD_ADDR_VAR 0 1
98830: PUSH
98831: LD_VAR 0 2
98835: PUSH
98836: FOR_IN
98837: IFFALSE 98853
// SetLives ( i , 1 ) ;
98839: LD_VAR 0 1
98843: PPUSH
98844: LD_INT 1
98846: PPUSH
98847: CALL_OW 234
98851: GO 98836
98853: POP
98854: POP
// end ;
98855: PPOPN 2
98857: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98858: LD_EXP 113
98862: PUSH
98863: LD_EXP 162
98867: AND
98868: IFFALSE 99155
98870: GO 98872
98872: DISABLE
98873: LD_INT 0
98875: PPUSH
98876: PPUSH
98877: PPUSH
// begin i := rand ( 1 , 7 ) ;
98878: LD_ADDR_VAR 0 1
98882: PUSH
98883: LD_INT 1
98885: PPUSH
98886: LD_INT 7
98888: PPUSH
98889: CALL_OW 12
98893: ST_TO_ADDR
// case i of 1 :
98894: LD_VAR 0 1
98898: PUSH
98899: LD_INT 1
98901: DOUBLE
98902: EQUAL
98903: IFTRUE 98907
98905: GO 98917
98907: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98908: LD_STRING earthquake(getX(game), 0, 32)
98910: PPUSH
98911: CALL_OW 559
98915: GO 99155
98917: LD_INT 2
98919: DOUBLE
98920: EQUAL
98921: IFTRUE 98925
98923: GO 98939
98925: POP
// begin ToLua ( displayStucuk(); ) ;
98926: LD_STRING displayStucuk();
98928: PPUSH
98929: CALL_OW 559
// ResetFog ;
98933: CALL_OW 335
// end ; 3 :
98937: GO 99155
98939: LD_INT 3
98941: DOUBLE
98942: EQUAL
98943: IFTRUE 98947
98945: GO 99051
98947: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98948: LD_ADDR_VAR 0 2
98952: PUSH
98953: LD_INT 22
98955: PUSH
98956: LD_OWVAR 2
98960: PUSH
98961: EMPTY
98962: LIST
98963: LIST
98964: PUSH
98965: LD_INT 25
98967: PUSH
98968: LD_INT 1
98970: PUSH
98971: EMPTY
98972: LIST
98973: LIST
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: PPUSH
98979: CALL_OW 69
98983: ST_TO_ADDR
// if not tmp then
98984: LD_VAR 0 2
98988: NOT
98989: IFFALSE 98993
// exit ;
98991: GO 99155
// un := tmp [ rand ( 1 , tmp ) ] ;
98993: LD_ADDR_VAR 0 3
98997: PUSH
98998: LD_VAR 0 2
99002: PUSH
99003: LD_INT 1
99005: PPUSH
99006: LD_VAR 0 2
99010: PPUSH
99011: CALL_OW 12
99015: ARRAY
99016: ST_TO_ADDR
// if Crawls ( un ) then
99017: LD_VAR 0 3
99021: PPUSH
99022: CALL_OW 318
99026: IFFALSE 99037
// ComWalk ( un ) ;
99028: LD_VAR 0 3
99032: PPUSH
99033: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99037: LD_VAR 0 3
99041: PPUSH
99042: LD_INT 8
99044: PPUSH
99045: CALL_OW 336
// end ; 4 :
99049: GO 99155
99051: LD_INT 4
99053: DOUBLE
99054: EQUAL
99055: IFTRUE 99059
99057: GO 99133
99059: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99060: LD_ADDR_VAR 0 2
99064: PUSH
99065: LD_INT 22
99067: PUSH
99068: LD_OWVAR 2
99072: PUSH
99073: EMPTY
99074: LIST
99075: LIST
99076: PUSH
99077: LD_INT 30
99079: PUSH
99080: LD_INT 29
99082: PUSH
99083: EMPTY
99084: LIST
99085: LIST
99086: PUSH
99087: EMPTY
99088: LIST
99089: LIST
99090: PPUSH
99091: CALL_OW 69
99095: ST_TO_ADDR
// if not tmp then
99096: LD_VAR 0 2
99100: NOT
99101: IFFALSE 99105
// exit ;
99103: GO 99155
// CenterNowOnUnits ( tmp [ 1 ] ) ;
99105: LD_VAR 0 2
99109: PUSH
99110: LD_INT 1
99112: ARRAY
99113: PPUSH
99114: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
99118: LD_VAR 0 2
99122: PUSH
99123: LD_INT 1
99125: ARRAY
99126: PPUSH
99127: CALL_OW 65
// end ; 5 .. 7 :
99131: GO 99155
99133: LD_INT 5
99135: DOUBLE
99136: GREATEREQUAL
99137: IFFALSE 99145
99139: LD_INT 7
99141: DOUBLE
99142: LESSEQUAL
99143: IFTRUE 99147
99145: GO 99154
99147: POP
// StreamSibBomb ; end ;
99148: CALL 95392 0 0
99152: GO 99155
99154: POP
// end ;
99155: PPOPN 3
99157: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99158: LD_EXP 113
99162: PUSH
99163: LD_EXP 163
99167: AND
99168: IFFALSE 99324
99170: GO 99172
99172: DISABLE
99173: LD_INT 0
99175: PPUSH
99176: PPUSH
99177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99178: LD_ADDR_VAR 0 2
99182: PUSH
99183: LD_INT 81
99185: PUSH
99186: LD_OWVAR 2
99190: PUSH
99191: EMPTY
99192: LIST
99193: LIST
99194: PUSH
99195: LD_INT 2
99197: PUSH
99198: LD_INT 21
99200: PUSH
99201: LD_INT 1
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: PUSH
99208: LD_INT 21
99210: PUSH
99211: LD_INT 2
99213: PUSH
99214: EMPTY
99215: LIST
99216: LIST
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: LIST
99222: PUSH
99223: EMPTY
99224: LIST
99225: LIST
99226: PPUSH
99227: CALL_OW 69
99231: ST_TO_ADDR
// if not tmp then
99232: LD_VAR 0 2
99236: NOT
99237: IFFALSE 99241
// exit ;
99239: GO 99324
// p := 0 ;
99241: LD_ADDR_VAR 0 3
99245: PUSH
99246: LD_INT 0
99248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99249: LD_INT 35
99251: PPUSH
99252: CALL_OW 67
// p := p + 1 ;
99256: LD_ADDR_VAR 0 3
99260: PUSH
99261: LD_VAR 0 3
99265: PUSH
99266: LD_INT 1
99268: PLUS
99269: ST_TO_ADDR
// for i in tmp do
99270: LD_ADDR_VAR 0 1
99274: PUSH
99275: LD_VAR 0 2
99279: PUSH
99280: FOR_IN
99281: IFFALSE 99312
// if GetLives ( i ) < 1000 then
99283: LD_VAR 0 1
99287: PPUSH
99288: CALL_OW 256
99292: PUSH
99293: LD_INT 1000
99295: LESS
99296: IFFALSE 99310
// SetLives ( i , 1000 ) ;
99298: LD_VAR 0 1
99302: PPUSH
99303: LD_INT 1000
99305: PPUSH
99306: CALL_OW 234
99310: GO 99280
99312: POP
99313: POP
// until p > 20 ;
99314: LD_VAR 0 3
99318: PUSH
99319: LD_INT 20
99321: GREATER
99322: IFFALSE 99249
// end ;
99324: PPOPN 3
99326: END
// every 0 0$1 trigger StreamModeActive and sTime do
99327: LD_EXP 113
99331: PUSH
99332: LD_EXP 164
99336: AND
99337: IFFALSE 99372
99339: GO 99341
99341: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99342: LD_INT 28
99344: PPUSH
99345: LD_OWVAR 2
99349: PPUSH
99350: LD_INT 2
99352: PPUSH
99353: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99357: LD_INT 30
99359: PPUSH
99360: LD_OWVAR 2
99364: PPUSH
99365: LD_INT 2
99367: PPUSH
99368: CALL_OW 322
// end ;
99372: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99373: LD_EXP 113
99377: PUSH
99378: LD_EXP 165
99382: AND
99383: IFFALSE 99504
99385: GO 99387
99387: DISABLE
99388: LD_INT 0
99390: PPUSH
99391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99392: LD_ADDR_VAR 0 2
99396: PUSH
99397: LD_INT 22
99399: PUSH
99400: LD_OWVAR 2
99404: PUSH
99405: EMPTY
99406: LIST
99407: LIST
99408: PUSH
99409: LD_INT 21
99411: PUSH
99412: LD_INT 1
99414: PUSH
99415: EMPTY
99416: LIST
99417: LIST
99418: PUSH
99419: LD_INT 3
99421: PUSH
99422: LD_INT 23
99424: PUSH
99425: LD_INT 0
99427: PUSH
99428: EMPTY
99429: LIST
99430: LIST
99431: PUSH
99432: EMPTY
99433: LIST
99434: LIST
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: LIST
99440: PPUSH
99441: CALL_OW 69
99445: ST_TO_ADDR
// if not tmp then
99446: LD_VAR 0 2
99450: NOT
99451: IFFALSE 99455
// exit ;
99453: GO 99504
// for i in tmp do
99455: LD_ADDR_VAR 0 1
99459: PUSH
99460: LD_VAR 0 2
99464: PUSH
99465: FOR_IN
99466: IFFALSE 99502
// begin if Crawls ( i ) then
99468: LD_VAR 0 1
99472: PPUSH
99473: CALL_OW 318
99477: IFFALSE 99488
// ComWalk ( i ) ;
99479: LD_VAR 0 1
99483: PPUSH
99484: CALL_OW 138
// SetClass ( i , 2 ) ;
99488: LD_VAR 0 1
99492: PPUSH
99493: LD_INT 2
99495: PPUSH
99496: CALL_OW 336
// end ;
99500: GO 99465
99502: POP
99503: POP
// end ;
99504: PPOPN 2
99506: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99507: LD_EXP 113
99511: PUSH
99512: LD_EXP 166
99516: AND
99517: IFFALSE 99805
99519: GO 99521
99521: DISABLE
99522: LD_INT 0
99524: PPUSH
99525: PPUSH
99526: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99527: LD_OWVAR 2
99531: PPUSH
99532: LD_INT 9
99534: PPUSH
99535: LD_INT 1
99537: PPUSH
99538: LD_INT 1
99540: PPUSH
99541: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99545: LD_INT 9
99547: PPUSH
99548: LD_OWVAR 2
99552: PPUSH
99553: CALL_OW 343
// uc_side := 9 ;
99557: LD_ADDR_OWVAR 20
99561: PUSH
99562: LD_INT 9
99564: ST_TO_ADDR
// uc_nation := 2 ;
99565: LD_ADDR_OWVAR 21
99569: PUSH
99570: LD_INT 2
99572: ST_TO_ADDR
// hc_name := Dark Warrior ;
99573: LD_ADDR_OWVAR 26
99577: PUSH
99578: LD_STRING Dark Warrior
99580: ST_TO_ADDR
// hc_gallery :=  ;
99581: LD_ADDR_OWVAR 33
99585: PUSH
99586: LD_STRING 
99588: ST_TO_ADDR
// hc_noskilllimit := true ;
99589: LD_ADDR_OWVAR 76
99593: PUSH
99594: LD_INT 1
99596: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99597: LD_ADDR_OWVAR 31
99601: PUSH
99602: LD_INT 30
99604: PUSH
99605: LD_INT 30
99607: PUSH
99608: LD_INT 30
99610: PUSH
99611: LD_INT 30
99613: PUSH
99614: EMPTY
99615: LIST
99616: LIST
99617: LIST
99618: LIST
99619: ST_TO_ADDR
// un := CreateHuman ;
99620: LD_ADDR_VAR 0 3
99624: PUSH
99625: CALL_OW 44
99629: ST_TO_ADDR
// hc_noskilllimit := false ;
99630: LD_ADDR_OWVAR 76
99634: PUSH
99635: LD_INT 0
99637: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99638: LD_VAR 0 3
99642: PPUSH
99643: LD_INT 1
99645: PPUSH
99646: CALL_OW 51
// ToLua ( playRanger() ) ;
99650: LD_STRING playRanger()
99652: PPUSH
99653: CALL_OW 559
// p := 0 ;
99657: LD_ADDR_VAR 0 2
99661: PUSH
99662: LD_INT 0
99664: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99665: LD_INT 35
99667: PPUSH
99668: CALL_OW 67
// p := p + 1 ;
99672: LD_ADDR_VAR 0 2
99676: PUSH
99677: LD_VAR 0 2
99681: PUSH
99682: LD_INT 1
99684: PLUS
99685: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99686: LD_VAR 0 3
99690: PPUSH
99691: CALL_OW 256
99695: PUSH
99696: LD_INT 1000
99698: LESS
99699: IFFALSE 99713
// SetLives ( un , 1000 ) ;
99701: LD_VAR 0 3
99705: PPUSH
99706: LD_INT 1000
99708: PPUSH
99709: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99713: LD_VAR 0 3
99717: PPUSH
99718: LD_INT 81
99720: PUSH
99721: LD_OWVAR 2
99725: PUSH
99726: EMPTY
99727: LIST
99728: LIST
99729: PUSH
99730: LD_INT 91
99732: PUSH
99733: LD_VAR 0 3
99737: PUSH
99738: LD_INT 30
99740: PUSH
99741: EMPTY
99742: LIST
99743: LIST
99744: LIST
99745: PUSH
99746: EMPTY
99747: LIST
99748: LIST
99749: PPUSH
99750: CALL_OW 69
99754: PPUSH
99755: LD_VAR 0 3
99759: PPUSH
99760: CALL_OW 74
99764: PPUSH
99765: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99769: LD_VAR 0 2
99773: PUSH
99774: LD_INT 80
99776: GREATER
99777: PUSH
99778: LD_VAR 0 3
99782: PPUSH
99783: CALL_OW 301
99787: OR
99788: IFFALSE 99665
// if un then
99790: LD_VAR 0 3
99794: IFFALSE 99805
// RemoveUnit ( un ) ;
99796: LD_VAR 0 3
99800: PPUSH
99801: CALL_OW 64
// end ;
99805: PPOPN 3
99807: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99808: LD_EXP 167
99812: IFFALSE 99928
99814: GO 99816
99816: DISABLE
99817: LD_INT 0
99819: PPUSH
99820: PPUSH
99821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99822: LD_ADDR_VAR 0 2
99826: PUSH
99827: LD_INT 81
99829: PUSH
99830: LD_OWVAR 2
99834: PUSH
99835: EMPTY
99836: LIST
99837: LIST
99838: PUSH
99839: LD_INT 21
99841: PUSH
99842: LD_INT 1
99844: PUSH
99845: EMPTY
99846: LIST
99847: LIST
99848: PUSH
99849: EMPTY
99850: LIST
99851: LIST
99852: PPUSH
99853: CALL_OW 69
99857: ST_TO_ADDR
// ToLua ( playComputer() ) ;
99858: LD_STRING playComputer()
99860: PPUSH
99861: CALL_OW 559
// if not tmp then
99865: LD_VAR 0 2
99869: NOT
99870: IFFALSE 99874
// exit ;
99872: GO 99928
// for i in tmp do
99874: LD_ADDR_VAR 0 1
99878: PUSH
99879: LD_VAR 0 2
99883: PUSH
99884: FOR_IN
99885: IFFALSE 99926
// for j := 1 to 4 do
99887: LD_ADDR_VAR 0 3
99891: PUSH
99892: DOUBLE
99893: LD_INT 1
99895: DEC
99896: ST_TO_ADDR
99897: LD_INT 4
99899: PUSH
99900: FOR_TO
99901: IFFALSE 99922
// SetSkill ( i , j , 10 ) ;
99903: LD_VAR 0 1
99907: PPUSH
99908: LD_VAR 0 3
99912: PPUSH
99913: LD_INT 10
99915: PPUSH
99916: CALL_OW 237
99920: GO 99900
99922: POP
99923: POP
99924: GO 99884
99926: POP
99927: POP
// end ;
99928: PPOPN 3
99930: END
// every 0 0$1 trigger s30 do var i , tmp ;
99931: LD_EXP 168
99935: IFFALSE 100004
99937: GO 99939
99939: DISABLE
99940: LD_INT 0
99942: PPUSH
99943: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99944: LD_ADDR_VAR 0 2
99948: PUSH
99949: LD_INT 22
99951: PUSH
99952: LD_OWVAR 2
99956: PUSH
99957: EMPTY
99958: LIST
99959: LIST
99960: PPUSH
99961: CALL_OW 69
99965: ST_TO_ADDR
// if not tmp then
99966: LD_VAR 0 2
99970: NOT
99971: IFFALSE 99975
// exit ;
99973: GO 100004
// for i in tmp do
99975: LD_ADDR_VAR 0 1
99979: PUSH
99980: LD_VAR 0 2
99984: PUSH
99985: FOR_IN
99986: IFFALSE 100002
// SetLives ( i , 300 ) ;
99988: LD_VAR 0 1
99992: PPUSH
99993: LD_INT 300
99995: PPUSH
99996: CALL_OW 234
100000: GO 99985
100002: POP
100003: POP
// end ;
100004: PPOPN 2
100006: END
// every 0 0$1 trigger s60 do var i , tmp ;
100007: LD_EXP 169
100011: IFFALSE 100080
100013: GO 100015
100015: DISABLE
100016: LD_INT 0
100018: PPUSH
100019: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100020: LD_ADDR_VAR 0 2
100024: PUSH
100025: LD_INT 22
100027: PUSH
100028: LD_OWVAR 2
100032: PUSH
100033: EMPTY
100034: LIST
100035: LIST
100036: PPUSH
100037: CALL_OW 69
100041: ST_TO_ADDR
// if not tmp then
100042: LD_VAR 0 2
100046: NOT
100047: IFFALSE 100051
// exit ;
100049: GO 100080
// for i in tmp do
100051: LD_ADDR_VAR 0 1
100055: PUSH
100056: LD_VAR 0 2
100060: PUSH
100061: FOR_IN
100062: IFFALSE 100078
// SetLives ( i , 600 ) ;
100064: LD_VAR 0 1
100068: PPUSH
100069: LD_INT 600
100071: PPUSH
100072: CALL_OW 234
100076: GO 100061
100078: POP
100079: POP
// end ;
100080: PPOPN 2
100082: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100083: LD_INT 0
100085: PPUSH
// case cmd of 301 :
100086: LD_VAR 0 1
100090: PUSH
100091: LD_INT 301
100093: DOUBLE
100094: EQUAL
100095: IFTRUE 100099
100097: GO 100131
100099: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100100: LD_VAR 0 6
100104: PPUSH
100105: LD_VAR 0 7
100109: PPUSH
100110: LD_VAR 0 8
100114: PPUSH
100115: LD_VAR 0 4
100119: PPUSH
100120: LD_VAR 0 5
100124: PPUSH
100125: CALL 101332 0 5
100129: GO 100252
100131: LD_INT 302
100133: DOUBLE
100134: EQUAL
100135: IFTRUE 100139
100137: GO 100176
100139: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100140: LD_VAR 0 6
100144: PPUSH
100145: LD_VAR 0 7
100149: PPUSH
100150: LD_VAR 0 8
100154: PPUSH
100155: LD_VAR 0 9
100159: PPUSH
100160: LD_VAR 0 4
100164: PPUSH
100165: LD_VAR 0 5
100169: PPUSH
100170: CALL 101423 0 6
100174: GO 100252
100176: LD_INT 303
100178: DOUBLE
100179: EQUAL
100180: IFTRUE 100184
100182: GO 100221
100184: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100185: LD_VAR 0 6
100189: PPUSH
100190: LD_VAR 0 7
100194: PPUSH
100195: LD_VAR 0 8
100199: PPUSH
100200: LD_VAR 0 9
100204: PPUSH
100205: LD_VAR 0 4
100209: PPUSH
100210: LD_VAR 0 5
100214: PPUSH
100215: CALL 100257 0 6
100219: GO 100252
100221: LD_INT 304
100223: DOUBLE
100224: EQUAL
100225: IFTRUE 100229
100227: GO 100251
100229: POP
// hHackTeleport ( unit , x , y ) ; end ;
100230: LD_VAR 0 2
100234: PPUSH
100235: LD_VAR 0 4
100239: PPUSH
100240: LD_VAR 0 5
100244: PPUSH
100245: CALL 102016 0 3
100249: GO 100252
100251: POP
// end ;
100252: LD_VAR 0 12
100256: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100257: LD_INT 0
100259: PPUSH
100260: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100261: LD_VAR 0 1
100265: PUSH
100266: LD_INT 1
100268: LESS
100269: PUSH
100270: LD_VAR 0 1
100274: PUSH
100275: LD_INT 3
100277: GREATER
100278: OR
100279: PUSH
100280: LD_VAR 0 5
100284: PPUSH
100285: LD_VAR 0 6
100289: PPUSH
100290: CALL_OW 428
100294: OR
100295: IFFALSE 100299
// exit ;
100297: GO 101019
// uc_side := your_side ;
100299: LD_ADDR_OWVAR 20
100303: PUSH
100304: LD_OWVAR 2
100308: ST_TO_ADDR
// uc_nation := nation ;
100309: LD_ADDR_OWVAR 21
100313: PUSH
100314: LD_VAR 0 1
100318: ST_TO_ADDR
// bc_level = 1 ;
100319: LD_ADDR_OWVAR 43
100323: PUSH
100324: LD_INT 1
100326: ST_TO_ADDR
// case btype of 1 :
100327: LD_VAR 0 2
100331: PUSH
100332: LD_INT 1
100334: DOUBLE
100335: EQUAL
100336: IFTRUE 100340
100338: GO 100351
100340: POP
// bc_type := b_depot ; 2 :
100341: LD_ADDR_OWVAR 42
100345: PUSH
100346: LD_INT 0
100348: ST_TO_ADDR
100349: GO 100963
100351: LD_INT 2
100353: DOUBLE
100354: EQUAL
100355: IFTRUE 100359
100357: GO 100370
100359: POP
// bc_type := b_warehouse ; 3 :
100360: LD_ADDR_OWVAR 42
100364: PUSH
100365: LD_INT 1
100367: ST_TO_ADDR
100368: GO 100963
100370: LD_INT 3
100372: DOUBLE
100373: EQUAL
100374: IFTRUE 100378
100376: GO 100389
100378: POP
// bc_type := b_lab ; 4 .. 9 :
100379: LD_ADDR_OWVAR 42
100383: PUSH
100384: LD_INT 6
100386: ST_TO_ADDR
100387: GO 100963
100389: LD_INT 4
100391: DOUBLE
100392: GREATEREQUAL
100393: IFFALSE 100401
100395: LD_INT 9
100397: DOUBLE
100398: LESSEQUAL
100399: IFTRUE 100403
100401: GO 100455
100403: POP
// begin bc_type := b_lab_half ;
100404: LD_ADDR_OWVAR 42
100408: PUSH
100409: LD_INT 7
100411: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100412: LD_ADDR_OWVAR 44
100416: PUSH
100417: LD_INT 10
100419: PUSH
100420: LD_INT 11
100422: PUSH
100423: LD_INT 12
100425: PUSH
100426: LD_INT 15
100428: PUSH
100429: LD_INT 14
100431: PUSH
100432: LD_INT 13
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: LIST
100442: PUSH
100443: LD_VAR 0 2
100447: PUSH
100448: LD_INT 3
100450: MINUS
100451: ARRAY
100452: ST_TO_ADDR
// end ; 10 .. 13 :
100453: GO 100963
100455: LD_INT 10
100457: DOUBLE
100458: GREATEREQUAL
100459: IFFALSE 100467
100461: LD_INT 13
100463: DOUBLE
100464: LESSEQUAL
100465: IFTRUE 100469
100467: GO 100546
100469: POP
// begin bc_type := b_lab_full ;
100470: LD_ADDR_OWVAR 42
100474: PUSH
100475: LD_INT 8
100477: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100478: LD_ADDR_OWVAR 44
100482: PUSH
100483: LD_INT 10
100485: PUSH
100486: LD_INT 12
100488: PUSH
100489: LD_INT 14
100491: PUSH
100492: LD_INT 13
100494: PUSH
100495: EMPTY
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: PUSH
100501: LD_VAR 0 2
100505: PUSH
100506: LD_INT 9
100508: MINUS
100509: ARRAY
100510: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100511: LD_ADDR_OWVAR 45
100515: PUSH
100516: LD_INT 11
100518: PUSH
100519: LD_INT 15
100521: PUSH
100522: LD_INT 12
100524: PUSH
100525: LD_INT 15
100527: PUSH
100528: EMPTY
100529: LIST
100530: LIST
100531: LIST
100532: LIST
100533: PUSH
100534: LD_VAR 0 2
100538: PUSH
100539: LD_INT 9
100541: MINUS
100542: ARRAY
100543: ST_TO_ADDR
// end ; 14 :
100544: GO 100963
100546: LD_INT 14
100548: DOUBLE
100549: EQUAL
100550: IFTRUE 100554
100552: GO 100565
100554: POP
// bc_type := b_workshop ; 15 :
100555: LD_ADDR_OWVAR 42
100559: PUSH
100560: LD_INT 2
100562: ST_TO_ADDR
100563: GO 100963
100565: LD_INT 15
100567: DOUBLE
100568: EQUAL
100569: IFTRUE 100573
100571: GO 100584
100573: POP
// bc_type := b_factory ; 16 :
100574: LD_ADDR_OWVAR 42
100578: PUSH
100579: LD_INT 3
100581: ST_TO_ADDR
100582: GO 100963
100584: LD_INT 16
100586: DOUBLE
100587: EQUAL
100588: IFTRUE 100592
100590: GO 100603
100592: POP
// bc_type := b_ext_gun ; 17 :
100593: LD_ADDR_OWVAR 42
100597: PUSH
100598: LD_INT 17
100600: ST_TO_ADDR
100601: GO 100963
100603: LD_INT 17
100605: DOUBLE
100606: EQUAL
100607: IFTRUE 100611
100609: GO 100639
100611: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100612: LD_ADDR_OWVAR 42
100616: PUSH
100617: LD_INT 19
100619: PUSH
100620: LD_INT 23
100622: PUSH
100623: LD_INT 19
100625: PUSH
100626: EMPTY
100627: LIST
100628: LIST
100629: LIST
100630: PUSH
100631: LD_VAR 0 1
100635: ARRAY
100636: ST_TO_ADDR
100637: GO 100963
100639: LD_INT 18
100641: DOUBLE
100642: EQUAL
100643: IFTRUE 100647
100645: GO 100658
100647: POP
// bc_type := b_ext_radar ; 19 :
100648: LD_ADDR_OWVAR 42
100652: PUSH
100653: LD_INT 20
100655: ST_TO_ADDR
100656: GO 100963
100658: LD_INT 19
100660: DOUBLE
100661: EQUAL
100662: IFTRUE 100666
100664: GO 100677
100666: POP
// bc_type := b_ext_radio ; 20 :
100667: LD_ADDR_OWVAR 42
100671: PUSH
100672: LD_INT 22
100674: ST_TO_ADDR
100675: GO 100963
100677: LD_INT 20
100679: DOUBLE
100680: EQUAL
100681: IFTRUE 100685
100683: GO 100696
100685: POP
// bc_type := b_ext_siberium ; 21 :
100686: LD_ADDR_OWVAR 42
100690: PUSH
100691: LD_INT 21
100693: ST_TO_ADDR
100694: GO 100963
100696: LD_INT 21
100698: DOUBLE
100699: EQUAL
100700: IFTRUE 100704
100702: GO 100715
100704: POP
// bc_type := b_ext_computer ; 22 :
100705: LD_ADDR_OWVAR 42
100709: PUSH
100710: LD_INT 24
100712: ST_TO_ADDR
100713: GO 100963
100715: LD_INT 22
100717: DOUBLE
100718: EQUAL
100719: IFTRUE 100723
100721: GO 100734
100723: POP
// bc_type := b_ext_track ; 23 :
100724: LD_ADDR_OWVAR 42
100728: PUSH
100729: LD_INT 16
100731: ST_TO_ADDR
100732: GO 100963
100734: LD_INT 23
100736: DOUBLE
100737: EQUAL
100738: IFTRUE 100742
100740: GO 100753
100742: POP
// bc_type := b_ext_laser ; 24 :
100743: LD_ADDR_OWVAR 42
100747: PUSH
100748: LD_INT 25
100750: ST_TO_ADDR
100751: GO 100963
100753: LD_INT 24
100755: DOUBLE
100756: EQUAL
100757: IFTRUE 100761
100759: GO 100772
100761: POP
// bc_type := b_control_tower ; 25 :
100762: LD_ADDR_OWVAR 42
100766: PUSH
100767: LD_INT 36
100769: ST_TO_ADDR
100770: GO 100963
100772: LD_INT 25
100774: DOUBLE
100775: EQUAL
100776: IFTRUE 100780
100778: GO 100791
100780: POP
// bc_type := b_breastwork ; 26 :
100781: LD_ADDR_OWVAR 42
100785: PUSH
100786: LD_INT 31
100788: ST_TO_ADDR
100789: GO 100963
100791: LD_INT 26
100793: DOUBLE
100794: EQUAL
100795: IFTRUE 100799
100797: GO 100810
100799: POP
// bc_type := b_bunker ; 27 :
100800: LD_ADDR_OWVAR 42
100804: PUSH
100805: LD_INT 32
100807: ST_TO_ADDR
100808: GO 100963
100810: LD_INT 27
100812: DOUBLE
100813: EQUAL
100814: IFTRUE 100818
100816: GO 100829
100818: POP
// bc_type := b_turret ; 28 :
100819: LD_ADDR_OWVAR 42
100823: PUSH
100824: LD_INT 33
100826: ST_TO_ADDR
100827: GO 100963
100829: LD_INT 28
100831: DOUBLE
100832: EQUAL
100833: IFTRUE 100837
100835: GO 100848
100837: POP
// bc_type := b_armoury ; 29 :
100838: LD_ADDR_OWVAR 42
100842: PUSH
100843: LD_INT 4
100845: ST_TO_ADDR
100846: GO 100963
100848: LD_INT 29
100850: DOUBLE
100851: EQUAL
100852: IFTRUE 100856
100854: GO 100867
100856: POP
// bc_type := b_barracks ; 30 :
100857: LD_ADDR_OWVAR 42
100861: PUSH
100862: LD_INT 5
100864: ST_TO_ADDR
100865: GO 100963
100867: LD_INT 30
100869: DOUBLE
100870: EQUAL
100871: IFTRUE 100875
100873: GO 100886
100875: POP
// bc_type := b_solar_power ; 31 :
100876: LD_ADDR_OWVAR 42
100880: PUSH
100881: LD_INT 27
100883: ST_TO_ADDR
100884: GO 100963
100886: LD_INT 31
100888: DOUBLE
100889: EQUAL
100890: IFTRUE 100894
100892: GO 100905
100894: POP
// bc_type := b_oil_power ; 32 :
100895: LD_ADDR_OWVAR 42
100899: PUSH
100900: LD_INT 26
100902: ST_TO_ADDR
100903: GO 100963
100905: LD_INT 32
100907: DOUBLE
100908: EQUAL
100909: IFTRUE 100913
100911: GO 100924
100913: POP
// bc_type := b_siberite_power ; 33 :
100914: LD_ADDR_OWVAR 42
100918: PUSH
100919: LD_INT 28
100921: ST_TO_ADDR
100922: GO 100963
100924: LD_INT 33
100926: DOUBLE
100927: EQUAL
100928: IFTRUE 100932
100930: GO 100943
100932: POP
// bc_type := b_oil_mine ; 34 :
100933: LD_ADDR_OWVAR 42
100937: PUSH
100938: LD_INT 29
100940: ST_TO_ADDR
100941: GO 100963
100943: LD_INT 34
100945: DOUBLE
100946: EQUAL
100947: IFTRUE 100951
100949: GO 100962
100951: POP
// bc_type := b_siberite_mine ; end ;
100952: LD_ADDR_OWVAR 42
100956: PUSH
100957: LD_INT 30
100959: ST_TO_ADDR
100960: GO 100963
100962: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100963: LD_ADDR_VAR 0 8
100967: PUSH
100968: LD_VAR 0 5
100972: PPUSH
100973: LD_VAR 0 6
100977: PPUSH
100978: LD_VAR 0 3
100982: PPUSH
100983: CALL_OW 47
100987: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100988: LD_OWVAR 42
100992: PUSH
100993: LD_INT 32
100995: PUSH
100996: LD_INT 33
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: IN
101003: IFFALSE 101019
// PlaceWeaponTurret ( b , weapon ) ;
101005: LD_VAR 0 8
101009: PPUSH
101010: LD_VAR 0 4
101014: PPUSH
101015: CALL_OW 431
// end ;
101019: LD_VAR 0 7
101023: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101024: LD_INT 0
101026: PPUSH
101027: PPUSH
101028: PPUSH
101029: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101030: LD_ADDR_VAR 0 4
101034: PUSH
101035: LD_INT 22
101037: PUSH
101038: LD_OWVAR 2
101042: PUSH
101043: EMPTY
101044: LIST
101045: LIST
101046: PUSH
101047: LD_INT 2
101049: PUSH
101050: LD_INT 30
101052: PUSH
101053: LD_INT 0
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: PUSH
101060: LD_INT 30
101062: PUSH
101063: LD_INT 1
101065: PUSH
101066: EMPTY
101067: LIST
101068: LIST
101069: PUSH
101070: EMPTY
101071: LIST
101072: LIST
101073: LIST
101074: PUSH
101075: EMPTY
101076: LIST
101077: LIST
101078: PPUSH
101079: CALL_OW 69
101083: ST_TO_ADDR
// if not tmp then
101084: LD_VAR 0 4
101088: NOT
101089: IFFALSE 101093
// exit ;
101091: GO 101152
// for i in tmp do
101093: LD_ADDR_VAR 0 2
101097: PUSH
101098: LD_VAR 0 4
101102: PUSH
101103: FOR_IN
101104: IFFALSE 101150
// for j = 1 to 3 do
101106: LD_ADDR_VAR 0 3
101110: PUSH
101111: DOUBLE
101112: LD_INT 1
101114: DEC
101115: ST_TO_ADDR
101116: LD_INT 3
101118: PUSH
101119: FOR_TO
101120: IFFALSE 101146
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101122: LD_VAR 0 2
101126: PPUSH
101127: CALL_OW 274
101131: PPUSH
101132: LD_VAR 0 3
101136: PPUSH
101137: LD_INT 99999
101139: PPUSH
101140: CALL_OW 277
101144: GO 101119
101146: POP
101147: POP
101148: GO 101103
101150: POP
101151: POP
// end ;
101152: LD_VAR 0 1
101156: RET
// export function hHackSetLevel10 ; var i , j ; begin
101157: LD_INT 0
101159: PPUSH
101160: PPUSH
101161: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101162: LD_ADDR_VAR 0 2
101166: PUSH
101167: LD_INT 21
101169: PUSH
101170: LD_INT 1
101172: PUSH
101173: EMPTY
101174: LIST
101175: LIST
101176: PPUSH
101177: CALL_OW 69
101181: PUSH
101182: FOR_IN
101183: IFFALSE 101235
// if IsSelected ( i ) then
101185: LD_VAR 0 2
101189: PPUSH
101190: CALL_OW 306
101194: IFFALSE 101233
// begin for j := 1 to 4 do
101196: LD_ADDR_VAR 0 3
101200: PUSH
101201: DOUBLE
101202: LD_INT 1
101204: DEC
101205: ST_TO_ADDR
101206: LD_INT 4
101208: PUSH
101209: FOR_TO
101210: IFFALSE 101231
// SetSkill ( i , j , 10 ) ;
101212: LD_VAR 0 2
101216: PPUSH
101217: LD_VAR 0 3
101221: PPUSH
101222: LD_INT 10
101224: PPUSH
101225: CALL_OW 237
101229: GO 101209
101231: POP
101232: POP
// end ;
101233: GO 101182
101235: POP
101236: POP
// end ;
101237: LD_VAR 0 1
101241: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101242: LD_INT 0
101244: PPUSH
101245: PPUSH
101246: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101247: LD_ADDR_VAR 0 2
101251: PUSH
101252: LD_INT 22
101254: PUSH
101255: LD_OWVAR 2
101259: PUSH
101260: EMPTY
101261: LIST
101262: LIST
101263: PUSH
101264: LD_INT 21
101266: PUSH
101267: LD_INT 1
101269: PUSH
101270: EMPTY
101271: LIST
101272: LIST
101273: PUSH
101274: EMPTY
101275: LIST
101276: LIST
101277: PPUSH
101278: CALL_OW 69
101282: PUSH
101283: FOR_IN
101284: IFFALSE 101325
// begin for j := 1 to 4 do
101286: LD_ADDR_VAR 0 3
101290: PUSH
101291: DOUBLE
101292: LD_INT 1
101294: DEC
101295: ST_TO_ADDR
101296: LD_INT 4
101298: PUSH
101299: FOR_TO
101300: IFFALSE 101321
// SetSkill ( i , j , 10 ) ;
101302: LD_VAR 0 2
101306: PPUSH
101307: LD_VAR 0 3
101311: PPUSH
101312: LD_INT 10
101314: PPUSH
101315: CALL_OW 237
101319: GO 101299
101321: POP
101322: POP
// end ;
101323: GO 101283
101325: POP
101326: POP
// end ;
101327: LD_VAR 0 1
101331: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101332: LD_INT 0
101334: PPUSH
// uc_side := your_side ;
101335: LD_ADDR_OWVAR 20
101339: PUSH
101340: LD_OWVAR 2
101344: ST_TO_ADDR
// uc_nation := nation ;
101345: LD_ADDR_OWVAR 21
101349: PUSH
101350: LD_VAR 0 1
101354: ST_TO_ADDR
// InitHc ;
101355: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101359: LD_INT 0
101361: PPUSH
101362: LD_VAR 0 2
101366: PPUSH
101367: LD_VAR 0 3
101371: PPUSH
101372: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101376: LD_VAR 0 4
101380: PPUSH
101381: LD_VAR 0 5
101385: PPUSH
101386: CALL_OW 428
101390: PUSH
101391: LD_INT 0
101393: EQUAL
101394: IFFALSE 101418
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101396: CALL_OW 44
101400: PPUSH
101401: LD_VAR 0 4
101405: PPUSH
101406: LD_VAR 0 5
101410: PPUSH
101411: LD_INT 1
101413: PPUSH
101414: CALL_OW 48
// end ;
101418: LD_VAR 0 6
101422: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101423: LD_INT 0
101425: PPUSH
101426: PPUSH
// uc_side := your_side ;
101427: LD_ADDR_OWVAR 20
101431: PUSH
101432: LD_OWVAR 2
101436: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101437: LD_VAR 0 1
101441: PUSH
101442: LD_INT 1
101444: PUSH
101445: LD_INT 2
101447: PUSH
101448: LD_INT 3
101450: PUSH
101451: LD_INT 4
101453: PUSH
101454: LD_INT 5
101456: PUSH
101457: EMPTY
101458: LIST
101459: LIST
101460: LIST
101461: LIST
101462: LIST
101463: IN
101464: IFFALSE 101476
// uc_nation := nation_american else
101466: LD_ADDR_OWVAR 21
101470: PUSH
101471: LD_INT 1
101473: ST_TO_ADDR
101474: GO 101519
// if chassis in [ 11 , 12 , 13 , 14 ] then
101476: LD_VAR 0 1
101480: PUSH
101481: LD_INT 11
101483: PUSH
101484: LD_INT 12
101486: PUSH
101487: LD_INT 13
101489: PUSH
101490: LD_INT 14
101492: PUSH
101493: EMPTY
101494: LIST
101495: LIST
101496: LIST
101497: LIST
101498: IN
101499: IFFALSE 101511
// uc_nation := nation_arabian else
101501: LD_ADDR_OWVAR 21
101505: PUSH
101506: LD_INT 2
101508: ST_TO_ADDR
101509: GO 101519
// uc_nation := nation_russian ;
101511: LD_ADDR_OWVAR 21
101515: PUSH
101516: LD_INT 3
101518: ST_TO_ADDR
// vc_chassis := chassis ;
101519: LD_ADDR_OWVAR 37
101523: PUSH
101524: LD_VAR 0 1
101528: ST_TO_ADDR
// vc_engine := engine ;
101529: LD_ADDR_OWVAR 39
101533: PUSH
101534: LD_VAR 0 2
101538: ST_TO_ADDR
// vc_control := control ;
101539: LD_ADDR_OWVAR 38
101543: PUSH
101544: LD_VAR 0 3
101548: ST_TO_ADDR
// vc_weapon := weapon ;
101549: LD_ADDR_OWVAR 40
101553: PUSH
101554: LD_VAR 0 4
101558: ST_TO_ADDR
// un := CreateVehicle ;
101559: LD_ADDR_VAR 0 8
101563: PUSH
101564: CALL_OW 45
101568: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101569: LD_VAR 0 8
101573: PPUSH
101574: LD_INT 0
101576: PPUSH
101577: LD_INT 5
101579: PPUSH
101580: CALL_OW 12
101584: PPUSH
101585: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101589: LD_VAR 0 8
101593: PPUSH
101594: LD_VAR 0 5
101598: PPUSH
101599: LD_VAR 0 6
101603: PPUSH
101604: LD_INT 1
101606: PPUSH
101607: CALL_OW 48
// end ;
101611: LD_VAR 0 7
101615: RET
// export hInvincible ; every 1 do
101616: GO 101618
101618: DISABLE
// hInvincible := [ ] ;
101619: LD_ADDR_EXP 170
101623: PUSH
101624: EMPTY
101625: ST_TO_ADDR
101626: END
// every 10 do var i ;
101627: GO 101629
101629: DISABLE
101630: LD_INT 0
101632: PPUSH
// begin enable ;
101633: ENABLE
// if not hInvincible then
101634: LD_EXP 170
101638: NOT
101639: IFFALSE 101643
// exit ;
101641: GO 101687
// for i in hInvincible do
101643: LD_ADDR_VAR 0 1
101647: PUSH
101648: LD_EXP 170
101652: PUSH
101653: FOR_IN
101654: IFFALSE 101685
// if GetLives ( i ) < 1000 then
101656: LD_VAR 0 1
101660: PPUSH
101661: CALL_OW 256
101665: PUSH
101666: LD_INT 1000
101668: LESS
101669: IFFALSE 101683
// SetLives ( i , 1000 ) ;
101671: LD_VAR 0 1
101675: PPUSH
101676: LD_INT 1000
101678: PPUSH
101679: CALL_OW 234
101683: GO 101653
101685: POP
101686: POP
// end ;
101687: PPOPN 1
101689: END
// export function hHackInvincible ; var i ; begin
101690: LD_INT 0
101692: PPUSH
101693: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101694: LD_ADDR_VAR 0 2
101698: PUSH
101699: LD_INT 2
101701: PUSH
101702: LD_INT 21
101704: PUSH
101705: LD_INT 1
101707: PUSH
101708: EMPTY
101709: LIST
101710: LIST
101711: PUSH
101712: LD_INT 21
101714: PUSH
101715: LD_INT 2
101717: PUSH
101718: EMPTY
101719: LIST
101720: LIST
101721: PUSH
101722: EMPTY
101723: LIST
101724: LIST
101725: LIST
101726: PPUSH
101727: CALL_OW 69
101731: PUSH
101732: FOR_IN
101733: IFFALSE 101794
// if IsSelected ( i ) then
101735: LD_VAR 0 2
101739: PPUSH
101740: CALL_OW 306
101744: IFFALSE 101792
// begin if i in hInvincible then
101746: LD_VAR 0 2
101750: PUSH
101751: LD_EXP 170
101755: IN
101756: IFFALSE 101776
// hInvincible := hInvincible diff i else
101758: LD_ADDR_EXP 170
101762: PUSH
101763: LD_EXP 170
101767: PUSH
101768: LD_VAR 0 2
101772: DIFF
101773: ST_TO_ADDR
101774: GO 101792
// hInvincible := hInvincible union i ;
101776: LD_ADDR_EXP 170
101780: PUSH
101781: LD_EXP 170
101785: PUSH
101786: LD_VAR 0 2
101790: UNION
101791: ST_TO_ADDR
// end ;
101792: GO 101732
101794: POP
101795: POP
// end ;
101796: LD_VAR 0 1
101800: RET
// export function hHackInvisible ; var i , j ; begin
101801: LD_INT 0
101803: PPUSH
101804: PPUSH
101805: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101806: LD_ADDR_VAR 0 2
101810: PUSH
101811: LD_INT 21
101813: PUSH
101814: LD_INT 1
101816: PUSH
101817: EMPTY
101818: LIST
101819: LIST
101820: PPUSH
101821: CALL_OW 69
101825: PUSH
101826: FOR_IN
101827: IFFALSE 101851
// if IsSelected ( i ) then
101829: LD_VAR 0 2
101833: PPUSH
101834: CALL_OW 306
101838: IFFALSE 101849
// ComForceInvisible ( i ) ;
101840: LD_VAR 0 2
101844: PPUSH
101845: CALL_OW 496
101849: GO 101826
101851: POP
101852: POP
// end ;
101853: LD_VAR 0 1
101857: RET
// export function hHackChangeYourSide ; begin
101858: LD_INT 0
101860: PPUSH
// if your_side = 8 then
101861: LD_OWVAR 2
101865: PUSH
101866: LD_INT 8
101868: EQUAL
101869: IFFALSE 101881
// your_side := 0 else
101871: LD_ADDR_OWVAR 2
101875: PUSH
101876: LD_INT 0
101878: ST_TO_ADDR
101879: GO 101895
// your_side := your_side + 1 ;
101881: LD_ADDR_OWVAR 2
101885: PUSH
101886: LD_OWVAR 2
101890: PUSH
101891: LD_INT 1
101893: PLUS
101894: ST_TO_ADDR
// end ;
101895: LD_VAR 0 1
101899: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101900: LD_INT 0
101902: PPUSH
101903: PPUSH
101904: PPUSH
// for i in all_units do
101905: LD_ADDR_VAR 0 2
101909: PUSH
101910: LD_OWVAR 3
101914: PUSH
101915: FOR_IN
101916: IFFALSE 101994
// if IsSelected ( i ) then
101918: LD_VAR 0 2
101922: PPUSH
101923: CALL_OW 306
101927: IFFALSE 101992
// begin j := GetSide ( i ) ;
101929: LD_ADDR_VAR 0 3
101933: PUSH
101934: LD_VAR 0 2
101938: PPUSH
101939: CALL_OW 255
101943: ST_TO_ADDR
// if j = 8 then
101944: LD_VAR 0 3
101948: PUSH
101949: LD_INT 8
101951: EQUAL
101952: IFFALSE 101964
// j := 0 else
101954: LD_ADDR_VAR 0 3
101958: PUSH
101959: LD_INT 0
101961: ST_TO_ADDR
101962: GO 101978
// j := j + 1 ;
101964: LD_ADDR_VAR 0 3
101968: PUSH
101969: LD_VAR 0 3
101973: PUSH
101974: LD_INT 1
101976: PLUS
101977: ST_TO_ADDR
// SetSide ( i , j ) ;
101978: LD_VAR 0 2
101982: PPUSH
101983: LD_VAR 0 3
101987: PPUSH
101988: CALL_OW 235
// end ;
101992: GO 101915
101994: POP
101995: POP
// end ;
101996: LD_VAR 0 1
102000: RET
// export function hHackFog ; begin
102001: LD_INT 0
102003: PPUSH
// FogOff ( true ) ;
102004: LD_INT 1
102006: PPUSH
102007: CALL_OW 344
// end ;
102011: LD_VAR 0 1
102015: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102016: LD_INT 0
102018: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102019: LD_VAR 0 1
102023: PPUSH
102024: LD_VAR 0 2
102028: PPUSH
102029: LD_VAR 0 3
102033: PPUSH
102034: LD_INT 1
102036: PPUSH
102037: LD_INT 1
102039: PPUSH
102040: CALL_OW 483
// CenterOnXY ( x , y ) ;
102044: LD_VAR 0 2
102048: PPUSH
102049: LD_VAR 0 3
102053: PPUSH
102054: CALL_OW 84
// end ; end_of_file
102058: LD_VAR 0 4
102062: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102063: LD_INT 0
102065: PPUSH
102066: PPUSH
102067: PPUSH
102068: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102069: LD_VAR 0 1
102073: PPUSH
102074: CALL_OW 264
102078: PUSH
102079: LD_EXP 98
102083: EQUAL
102084: IFFALSE 102156
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102086: LD_INT 68
102088: PPUSH
102089: LD_VAR 0 1
102093: PPUSH
102094: CALL_OW 255
102098: PPUSH
102099: CALL_OW 321
102103: PUSH
102104: LD_INT 2
102106: EQUAL
102107: IFFALSE 102119
// eff := 70 else
102109: LD_ADDR_VAR 0 4
102113: PUSH
102114: LD_INT 70
102116: ST_TO_ADDR
102117: GO 102127
// eff := 30 ;
102119: LD_ADDR_VAR 0 4
102123: PUSH
102124: LD_INT 30
102126: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102127: LD_VAR 0 1
102131: PPUSH
102132: CALL_OW 250
102136: PPUSH
102137: LD_VAR 0 1
102141: PPUSH
102142: CALL_OW 251
102146: PPUSH
102147: LD_VAR 0 4
102151: PPUSH
102152: CALL_OW 495
// end ; end ;
102156: LD_VAR 0 2
102160: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102161: LD_INT 0
102163: PPUSH
// end ;
102164: LD_VAR 0 4
102168: RET
// export function SOS_Command ( cmd ) ; begin
102169: LD_INT 0
102171: PPUSH
// end ;
102172: LD_VAR 0 2
102176: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102177: LD_INT 0
102179: PPUSH
// end ;
102180: LD_VAR 0 6
102184: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
102185: LD_INT 0
102187: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
102188: LD_VAR 0 1
102192: PUSH
102193: LD_INT 250
102195: EQUAL
102196: PUSH
102197: LD_VAR 0 2
102201: PPUSH
102202: CALL_OW 264
102206: PUSH
102207: LD_EXP 101
102211: EQUAL
102212: AND
102213: IFFALSE 102234
// MinerPlaceMine ( unit , x , y ) ;
102215: LD_VAR 0 2
102219: PPUSH
102220: LD_VAR 0 4
102224: PPUSH
102225: LD_VAR 0 5
102229: PPUSH
102230: CALL 104583 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
102234: LD_VAR 0 1
102238: PUSH
102239: LD_INT 251
102241: EQUAL
102242: PUSH
102243: LD_VAR 0 2
102247: PPUSH
102248: CALL_OW 264
102252: PUSH
102253: LD_EXP 101
102257: EQUAL
102258: AND
102259: IFFALSE 102280
// MinerDetonateMine ( unit , x , y ) ;
102261: LD_VAR 0 2
102265: PPUSH
102266: LD_VAR 0 4
102270: PPUSH
102271: LD_VAR 0 5
102275: PPUSH
102276: CALL 104860 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
102280: LD_VAR 0 1
102284: PUSH
102285: LD_INT 252
102287: EQUAL
102288: PUSH
102289: LD_VAR 0 2
102293: PPUSH
102294: CALL_OW 264
102298: PUSH
102299: LD_EXP 101
102303: EQUAL
102304: AND
102305: IFFALSE 102326
// MinerCreateMinefield ( unit , x , y ) ;
102307: LD_VAR 0 2
102311: PPUSH
102312: LD_VAR 0 4
102316: PPUSH
102317: LD_VAR 0 5
102321: PPUSH
102322: CALL 105277 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
102326: LD_VAR 0 1
102330: PUSH
102331: LD_INT 253
102333: EQUAL
102334: PUSH
102335: LD_VAR 0 2
102339: PPUSH
102340: CALL_OW 257
102344: PUSH
102345: LD_INT 5
102347: EQUAL
102348: AND
102349: IFFALSE 102370
// ComBinocular ( unit , x , y ) ;
102351: LD_VAR 0 2
102355: PPUSH
102356: LD_VAR 0 4
102360: PPUSH
102361: LD_VAR 0 5
102365: PPUSH
102366: CALL 105648 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
102370: LD_VAR 0 1
102374: PUSH
102375: LD_INT 254
102377: EQUAL
102378: PUSH
102379: LD_VAR 0 2
102383: PPUSH
102384: CALL_OW 264
102388: PUSH
102389: LD_EXP 96
102393: EQUAL
102394: AND
102395: PUSH
102396: LD_VAR 0 3
102400: PPUSH
102401: CALL_OW 263
102405: PUSH
102406: LD_INT 3
102408: EQUAL
102409: AND
102410: IFFALSE 102426
// HackDestroyVehicle ( unit , selectedUnit ) ;
102412: LD_VAR 0 2
102416: PPUSH
102417: LD_VAR 0 3
102421: PPUSH
102422: CALL 103943 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
102426: LD_VAR 0 1
102430: PUSH
102431: LD_INT 255
102433: EQUAL
102434: PUSH
102435: LD_VAR 0 2
102439: PPUSH
102440: CALL_OW 264
102444: PUSH
102445: LD_INT 14
102447: PUSH
102448: LD_INT 53
102450: PUSH
102451: EMPTY
102452: LIST
102453: LIST
102454: IN
102455: AND
102456: PUSH
102457: LD_VAR 0 4
102461: PPUSH
102462: LD_VAR 0 5
102466: PPUSH
102467: CALL_OW 488
102471: AND
102472: IFFALSE 102496
// CutTreeXYR ( unit , x , y , 12 ) ;
102474: LD_VAR 0 2
102478: PPUSH
102479: LD_VAR 0 4
102483: PPUSH
102484: LD_VAR 0 5
102488: PPUSH
102489: LD_INT 12
102491: PPUSH
102492: CALL 102509 0 4
// end ;
102496: LD_VAR 0 6
102500: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
102501: LD_INT 0
102503: PPUSH
// end ;
102504: LD_VAR 0 4
102508: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
102509: LD_INT 0
102511: PPUSH
102512: PPUSH
102513: PPUSH
102514: PPUSH
102515: PPUSH
102516: PPUSH
102517: PPUSH
102518: PPUSH
102519: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
102520: LD_VAR 0 1
102524: NOT
102525: PUSH
102526: LD_VAR 0 2
102530: PPUSH
102531: LD_VAR 0 3
102535: PPUSH
102536: CALL_OW 488
102540: NOT
102541: OR
102542: PUSH
102543: LD_VAR 0 4
102547: NOT
102548: OR
102549: IFFALSE 102553
// exit ;
102551: GO 102893
// list := [ ] ;
102553: LD_ADDR_VAR 0 13
102557: PUSH
102558: EMPTY
102559: ST_TO_ADDR
// if x - r < 0 then
102560: LD_VAR 0 2
102564: PUSH
102565: LD_VAR 0 4
102569: MINUS
102570: PUSH
102571: LD_INT 0
102573: LESS
102574: IFFALSE 102586
// min_x := 0 else
102576: LD_ADDR_VAR 0 7
102580: PUSH
102581: LD_INT 0
102583: ST_TO_ADDR
102584: GO 102602
// min_x := x - r ;
102586: LD_ADDR_VAR 0 7
102590: PUSH
102591: LD_VAR 0 2
102595: PUSH
102596: LD_VAR 0 4
102600: MINUS
102601: ST_TO_ADDR
// if y - r < 0 then
102602: LD_VAR 0 3
102606: PUSH
102607: LD_VAR 0 4
102611: MINUS
102612: PUSH
102613: LD_INT 0
102615: LESS
102616: IFFALSE 102628
// min_y := 0 else
102618: LD_ADDR_VAR 0 8
102622: PUSH
102623: LD_INT 0
102625: ST_TO_ADDR
102626: GO 102644
// min_y := y - r ;
102628: LD_ADDR_VAR 0 8
102632: PUSH
102633: LD_VAR 0 3
102637: PUSH
102638: LD_VAR 0 4
102642: MINUS
102643: ST_TO_ADDR
// max_x := x + r ;
102644: LD_ADDR_VAR 0 9
102648: PUSH
102649: LD_VAR 0 2
102653: PUSH
102654: LD_VAR 0 4
102658: PLUS
102659: ST_TO_ADDR
// max_y := y + r ;
102660: LD_ADDR_VAR 0 10
102664: PUSH
102665: LD_VAR 0 3
102669: PUSH
102670: LD_VAR 0 4
102674: PLUS
102675: ST_TO_ADDR
// for _x = min_x to max_x do
102676: LD_ADDR_VAR 0 11
102680: PUSH
102681: DOUBLE
102682: LD_VAR 0 7
102686: DEC
102687: ST_TO_ADDR
102688: LD_VAR 0 9
102692: PUSH
102693: FOR_TO
102694: IFFALSE 102811
// for _y = min_y to max_y do
102696: LD_ADDR_VAR 0 12
102700: PUSH
102701: DOUBLE
102702: LD_VAR 0 8
102706: DEC
102707: ST_TO_ADDR
102708: LD_VAR 0 10
102712: PUSH
102713: FOR_TO
102714: IFFALSE 102807
// begin if not ValidHex ( _x , _y ) then
102716: LD_VAR 0 11
102720: PPUSH
102721: LD_VAR 0 12
102725: PPUSH
102726: CALL_OW 488
102730: NOT
102731: IFFALSE 102735
// continue ;
102733: GO 102713
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
102735: LD_VAR 0 11
102739: PPUSH
102740: LD_VAR 0 12
102744: PPUSH
102745: CALL_OW 351
102749: PUSH
102750: LD_VAR 0 11
102754: PPUSH
102755: LD_VAR 0 12
102759: PPUSH
102760: CALL_OW 554
102764: AND
102765: IFFALSE 102805
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102767: LD_ADDR_VAR 0 13
102771: PUSH
102772: LD_VAR 0 13
102776: PPUSH
102777: LD_VAR 0 13
102781: PUSH
102782: LD_INT 1
102784: PLUS
102785: PPUSH
102786: LD_VAR 0 11
102790: PUSH
102791: LD_VAR 0 12
102795: PUSH
102796: EMPTY
102797: LIST
102798: LIST
102799: PPUSH
102800: CALL_OW 2
102804: ST_TO_ADDR
// end ;
102805: GO 102713
102807: POP
102808: POP
102809: GO 102693
102811: POP
102812: POP
// if not list then
102813: LD_VAR 0 13
102817: NOT
102818: IFFALSE 102822
// exit ;
102820: GO 102893
// for i in list do
102822: LD_ADDR_VAR 0 6
102826: PUSH
102827: LD_VAR 0 13
102831: PUSH
102832: FOR_IN
102833: IFFALSE 102891
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102835: LD_VAR 0 1
102839: PPUSH
102840: LD_STRING M
102842: PUSH
102843: LD_VAR 0 6
102847: PUSH
102848: LD_INT 1
102850: ARRAY
102851: PUSH
102852: LD_VAR 0 6
102856: PUSH
102857: LD_INT 2
102859: ARRAY
102860: PUSH
102861: LD_INT 0
102863: PUSH
102864: LD_INT 0
102866: PUSH
102867: LD_INT 0
102869: PUSH
102870: LD_INT 0
102872: PUSH
102873: EMPTY
102874: LIST
102875: LIST
102876: LIST
102877: LIST
102878: LIST
102879: LIST
102880: LIST
102881: PUSH
102882: EMPTY
102883: LIST
102884: PPUSH
102885: CALL_OW 447
102889: GO 102832
102891: POP
102892: POP
// end ;
102893: LD_VAR 0 5
102897: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102898: LD_EXP 173
102902: NOT
102903: IFFALSE 102953
102905: GO 102907
102907: DISABLE
// begin initHack := true ;
102908: LD_ADDR_EXP 173
102912: PUSH
102913: LD_INT 1
102915: ST_TO_ADDR
// hackTanks := [ ] ;
102916: LD_ADDR_EXP 174
102920: PUSH
102921: EMPTY
102922: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102923: LD_ADDR_EXP 175
102927: PUSH
102928: EMPTY
102929: ST_TO_ADDR
// hackLimit := 3 ;
102930: LD_ADDR_EXP 176
102934: PUSH
102935: LD_INT 3
102937: ST_TO_ADDR
// hackDist := 12 ;
102938: LD_ADDR_EXP 177
102942: PUSH
102943: LD_INT 12
102945: ST_TO_ADDR
// hackCounter := [ ] ;
102946: LD_ADDR_EXP 178
102950: PUSH
102951: EMPTY
102952: ST_TO_ADDR
// end ;
102953: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102954: LD_EXP 173
102958: PUSH
102959: LD_INT 34
102961: PUSH
102962: LD_EXP 96
102966: PUSH
102967: EMPTY
102968: LIST
102969: LIST
102970: PPUSH
102971: CALL_OW 69
102975: AND
102976: IFFALSE 103231
102978: GO 102980
102980: DISABLE
102981: LD_INT 0
102983: PPUSH
102984: PPUSH
// begin enable ;
102985: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102986: LD_ADDR_VAR 0 1
102990: PUSH
102991: LD_INT 34
102993: PUSH
102994: LD_EXP 96
102998: PUSH
102999: EMPTY
103000: LIST
103001: LIST
103002: PPUSH
103003: CALL_OW 69
103007: PUSH
103008: FOR_IN
103009: IFFALSE 103229
// begin if not i in hackTanks then
103011: LD_VAR 0 1
103015: PUSH
103016: LD_EXP 174
103020: IN
103021: NOT
103022: IFFALSE 103105
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
103024: LD_ADDR_EXP 174
103028: PUSH
103029: LD_EXP 174
103033: PPUSH
103034: LD_EXP 174
103038: PUSH
103039: LD_INT 1
103041: PLUS
103042: PPUSH
103043: LD_VAR 0 1
103047: PPUSH
103048: CALL_OW 1
103052: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
103053: LD_ADDR_EXP 175
103057: PUSH
103058: LD_EXP 175
103062: PPUSH
103063: LD_EXP 175
103067: PUSH
103068: LD_INT 1
103070: PLUS
103071: PPUSH
103072: EMPTY
103073: PPUSH
103074: CALL_OW 1
103078: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
103079: LD_ADDR_EXP 178
103083: PUSH
103084: LD_EXP 178
103088: PPUSH
103089: LD_EXP 178
103093: PUSH
103094: LD_INT 1
103096: PLUS
103097: PPUSH
103098: EMPTY
103099: PPUSH
103100: CALL_OW 1
103104: ST_TO_ADDR
// end ; if not IsOk ( i ) then
103105: LD_VAR 0 1
103109: PPUSH
103110: CALL_OW 302
103114: NOT
103115: IFFALSE 103128
// begin HackUnlinkAll ( i ) ;
103117: LD_VAR 0 1
103121: PPUSH
103122: CALL 103234 0 1
// continue ;
103126: GO 103008
// end ; HackCheckCapturedStatus ( i ) ;
103128: LD_VAR 0 1
103132: PPUSH
103133: CALL 103677 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
103137: LD_ADDR_VAR 0 2
103141: PUSH
103142: LD_INT 81
103144: PUSH
103145: LD_VAR 0 1
103149: PPUSH
103150: CALL_OW 255
103154: PUSH
103155: EMPTY
103156: LIST
103157: LIST
103158: PUSH
103159: LD_INT 33
103161: PUSH
103162: LD_INT 3
103164: PUSH
103165: EMPTY
103166: LIST
103167: LIST
103168: PUSH
103169: LD_INT 91
103171: PUSH
103172: LD_VAR 0 1
103176: PUSH
103177: LD_EXP 177
103181: PUSH
103182: EMPTY
103183: LIST
103184: LIST
103185: LIST
103186: PUSH
103187: LD_INT 50
103189: PUSH
103190: EMPTY
103191: LIST
103192: PUSH
103193: EMPTY
103194: LIST
103195: LIST
103196: LIST
103197: LIST
103198: PPUSH
103199: CALL_OW 69
103203: ST_TO_ADDR
// if not tmp then
103204: LD_VAR 0 2
103208: NOT
103209: IFFALSE 103213
// continue ;
103211: GO 103008
// HackLink ( i , tmp ) ;
103213: LD_VAR 0 1
103217: PPUSH
103218: LD_VAR 0 2
103222: PPUSH
103223: CALL 103370 0 2
// end ;
103227: GO 103008
103229: POP
103230: POP
// end ;
103231: PPOPN 2
103233: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
103234: LD_INT 0
103236: PPUSH
103237: PPUSH
103238: PPUSH
// if not hack in hackTanks then
103239: LD_VAR 0 1
103243: PUSH
103244: LD_EXP 174
103248: IN
103249: NOT
103250: IFFALSE 103254
// exit ;
103252: GO 103365
// index := GetElementIndex ( hackTanks , hack ) ;
103254: LD_ADDR_VAR 0 4
103258: PUSH
103259: LD_EXP 174
103263: PPUSH
103264: LD_VAR 0 1
103268: PPUSH
103269: CALL 53326 0 2
103273: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
103274: LD_EXP 175
103278: PUSH
103279: LD_VAR 0 4
103283: ARRAY
103284: IFFALSE 103365
// begin for i in hackTanksCaptured [ index ] do
103286: LD_ADDR_VAR 0 3
103290: PUSH
103291: LD_EXP 175
103295: PUSH
103296: LD_VAR 0 4
103300: ARRAY
103301: PUSH
103302: FOR_IN
103303: IFFALSE 103329
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
103305: LD_VAR 0 3
103309: PUSH
103310: LD_INT 1
103312: ARRAY
103313: PPUSH
103314: LD_VAR 0 3
103318: PUSH
103319: LD_INT 2
103321: ARRAY
103322: PPUSH
103323: CALL_OW 235
103327: GO 103302
103329: POP
103330: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
103331: LD_ADDR_EXP 175
103335: PUSH
103336: LD_EXP 175
103340: PPUSH
103341: LD_VAR 0 4
103345: PPUSH
103346: EMPTY
103347: PPUSH
103348: CALL_OW 1
103352: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
103353: LD_VAR 0 1
103357: PPUSH
103358: LD_INT 0
103360: PPUSH
103361: CALL_OW 505
// end ; end ;
103365: LD_VAR 0 2
103369: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
103370: LD_INT 0
103372: PPUSH
103373: PPUSH
103374: PPUSH
// if not hack in hackTanks or not vehicles then
103375: LD_VAR 0 1
103379: PUSH
103380: LD_EXP 174
103384: IN
103385: NOT
103386: PUSH
103387: LD_VAR 0 2
103391: NOT
103392: OR
103393: IFFALSE 103397
// exit ;
103395: GO 103672
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
103397: LD_ADDR_VAR 0 2
103401: PUSH
103402: LD_VAR 0 1
103406: PPUSH
103407: LD_VAR 0 2
103411: PPUSH
103412: LD_INT 1
103414: PPUSH
103415: LD_INT 1
103417: PPUSH
103418: CALL 53976 0 4
103422: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
103423: LD_ADDR_VAR 0 5
103427: PUSH
103428: LD_EXP 174
103432: PPUSH
103433: LD_VAR 0 1
103437: PPUSH
103438: CALL 53326 0 2
103442: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
103443: LD_EXP 175
103447: PUSH
103448: LD_VAR 0 5
103452: ARRAY
103453: PUSH
103454: LD_EXP 176
103458: LESS
103459: IFFALSE 103648
// begin for i := 1 to vehicles do
103461: LD_ADDR_VAR 0 4
103465: PUSH
103466: DOUBLE
103467: LD_INT 1
103469: DEC
103470: ST_TO_ADDR
103471: LD_VAR 0 2
103475: PUSH
103476: FOR_TO
103477: IFFALSE 103646
// begin if hackTanksCaptured [ index ] = hackLimit then
103479: LD_EXP 175
103483: PUSH
103484: LD_VAR 0 5
103488: ARRAY
103489: PUSH
103490: LD_EXP 176
103494: EQUAL
103495: IFFALSE 103499
// break ;
103497: GO 103646
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
103499: LD_ADDR_EXP 178
103503: PUSH
103504: LD_EXP 178
103508: PPUSH
103509: LD_VAR 0 5
103513: PPUSH
103514: LD_EXP 178
103518: PUSH
103519: LD_VAR 0 5
103523: ARRAY
103524: PUSH
103525: LD_INT 1
103527: PLUS
103528: PPUSH
103529: CALL_OW 1
103533: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
103534: LD_ADDR_EXP 175
103538: PUSH
103539: LD_EXP 175
103543: PPUSH
103544: LD_VAR 0 5
103548: PUSH
103549: LD_EXP 175
103553: PUSH
103554: LD_VAR 0 5
103558: ARRAY
103559: PUSH
103560: LD_INT 1
103562: PLUS
103563: PUSH
103564: EMPTY
103565: LIST
103566: LIST
103567: PPUSH
103568: LD_VAR 0 2
103572: PUSH
103573: LD_VAR 0 4
103577: ARRAY
103578: PUSH
103579: LD_VAR 0 2
103583: PUSH
103584: LD_VAR 0 4
103588: ARRAY
103589: PPUSH
103590: CALL_OW 255
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: PPUSH
103599: CALL 53541 0 3
103603: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
103604: LD_VAR 0 2
103608: PUSH
103609: LD_VAR 0 4
103613: ARRAY
103614: PPUSH
103615: LD_VAR 0 1
103619: PPUSH
103620: CALL_OW 255
103624: PPUSH
103625: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
103629: LD_VAR 0 2
103633: PUSH
103634: LD_VAR 0 4
103638: ARRAY
103639: PPUSH
103640: CALL_OW 141
// end ;
103644: GO 103476
103646: POP
103647: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103648: LD_VAR 0 1
103652: PPUSH
103653: LD_EXP 175
103657: PUSH
103658: LD_VAR 0 5
103662: ARRAY
103663: PUSH
103664: LD_INT 0
103666: PLUS
103667: PPUSH
103668: CALL_OW 505
// end ;
103672: LD_VAR 0 3
103676: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
103677: LD_INT 0
103679: PPUSH
103680: PPUSH
103681: PPUSH
103682: PPUSH
// if not hack in hackTanks then
103683: LD_VAR 0 1
103687: PUSH
103688: LD_EXP 174
103692: IN
103693: NOT
103694: IFFALSE 103698
// exit ;
103696: GO 103938
// index := GetElementIndex ( hackTanks , hack ) ;
103698: LD_ADDR_VAR 0 4
103702: PUSH
103703: LD_EXP 174
103707: PPUSH
103708: LD_VAR 0 1
103712: PPUSH
103713: CALL 53326 0 2
103717: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
103718: LD_ADDR_VAR 0 3
103722: PUSH
103723: DOUBLE
103724: LD_EXP 175
103728: PUSH
103729: LD_VAR 0 4
103733: ARRAY
103734: INC
103735: ST_TO_ADDR
103736: LD_INT 1
103738: PUSH
103739: FOR_DOWNTO
103740: IFFALSE 103912
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
103742: LD_ADDR_VAR 0 5
103746: PUSH
103747: LD_EXP 175
103751: PUSH
103752: LD_VAR 0 4
103756: ARRAY
103757: PUSH
103758: LD_VAR 0 3
103762: ARRAY
103763: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103764: LD_VAR 0 5
103768: PUSH
103769: LD_INT 1
103771: ARRAY
103772: PPUSH
103773: CALL_OW 302
103777: NOT
103778: PUSH
103779: LD_VAR 0 5
103783: PUSH
103784: LD_INT 1
103786: ARRAY
103787: PPUSH
103788: CALL_OW 255
103792: PUSH
103793: LD_VAR 0 1
103797: PPUSH
103798: CALL_OW 255
103802: NONEQUAL
103803: OR
103804: IFFALSE 103910
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103806: LD_VAR 0 5
103810: PUSH
103811: LD_INT 1
103813: ARRAY
103814: PPUSH
103815: CALL_OW 305
103819: PUSH
103820: LD_VAR 0 5
103824: PUSH
103825: LD_INT 1
103827: ARRAY
103828: PPUSH
103829: CALL_OW 255
103833: PUSH
103834: LD_VAR 0 1
103838: PPUSH
103839: CALL_OW 255
103843: EQUAL
103844: AND
103845: IFFALSE 103869
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103847: LD_VAR 0 5
103851: PUSH
103852: LD_INT 1
103854: ARRAY
103855: PPUSH
103856: LD_VAR 0 5
103860: PUSH
103861: LD_INT 2
103863: ARRAY
103864: PPUSH
103865: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103869: LD_ADDR_EXP 175
103873: PUSH
103874: LD_EXP 175
103878: PPUSH
103879: LD_VAR 0 4
103883: PPUSH
103884: LD_EXP 175
103888: PUSH
103889: LD_VAR 0 4
103893: ARRAY
103894: PPUSH
103895: LD_VAR 0 3
103899: PPUSH
103900: CALL_OW 3
103904: PPUSH
103905: CALL_OW 1
103909: ST_TO_ADDR
// end ; end ;
103910: GO 103739
103912: POP
103913: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103914: LD_VAR 0 1
103918: PPUSH
103919: LD_EXP 175
103923: PUSH
103924: LD_VAR 0 4
103928: ARRAY
103929: PUSH
103930: LD_INT 0
103932: PLUS
103933: PPUSH
103934: CALL_OW 505
// end ;
103938: LD_VAR 0 2
103942: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103943: LD_INT 0
103945: PPUSH
103946: PPUSH
103947: PPUSH
103948: PPUSH
// if not hack in hackTanks then
103949: LD_VAR 0 1
103953: PUSH
103954: LD_EXP 174
103958: IN
103959: NOT
103960: IFFALSE 103964
// exit ;
103962: GO 104049
// index := GetElementIndex ( hackTanks , hack ) ;
103964: LD_ADDR_VAR 0 5
103968: PUSH
103969: LD_EXP 174
103973: PPUSH
103974: LD_VAR 0 1
103978: PPUSH
103979: CALL 53326 0 2
103983: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103984: LD_ADDR_VAR 0 4
103988: PUSH
103989: DOUBLE
103990: LD_INT 1
103992: DEC
103993: ST_TO_ADDR
103994: LD_EXP 175
103998: PUSH
103999: LD_VAR 0 5
104003: ARRAY
104004: PUSH
104005: FOR_TO
104006: IFFALSE 104047
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
104008: LD_EXP 175
104012: PUSH
104013: LD_VAR 0 5
104017: ARRAY
104018: PUSH
104019: LD_VAR 0 4
104023: ARRAY
104024: PUSH
104025: LD_INT 1
104027: ARRAY
104028: PUSH
104029: LD_VAR 0 2
104033: EQUAL
104034: IFFALSE 104045
// KillUnit ( vehicle ) ;
104036: LD_VAR 0 2
104040: PPUSH
104041: CALL_OW 66
104045: GO 104005
104047: POP
104048: POP
// end ;
104049: LD_VAR 0 3
104053: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
104054: LD_EXP 179
104058: NOT
104059: IFFALSE 104094
104061: GO 104063
104063: DISABLE
// begin initMiner := true ;
104064: LD_ADDR_EXP 179
104068: PUSH
104069: LD_INT 1
104071: ST_TO_ADDR
// minersList := [ ] ;
104072: LD_ADDR_EXP 180
104076: PUSH
104077: EMPTY
104078: ST_TO_ADDR
// minerMinesList := [ ] ;
104079: LD_ADDR_EXP 181
104083: PUSH
104084: EMPTY
104085: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
104086: LD_ADDR_EXP 182
104090: PUSH
104091: LD_INT 5
104093: ST_TO_ADDR
// end ;
104094: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
104095: LD_EXP 179
104099: PUSH
104100: LD_INT 34
104102: PUSH
104103: LD_EXP 101
104107: PUSH
104108: EMPTY
104109: LIST
104110: LIST
104111: PPUSH
104112: CALL_OW 69
104116: AND
104117: IFFALSE 104580
104119: GO 104121
104121: DISABLE
104122: LD_INT 0
104124: PPUSH
104125: PPUSH
104126: PPUSH
104127: PPUSH
// begin enable ;
104128: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
104129: LD_ADDR_VAR 0 1
104133: PUSH
104134: LD_INT 34
104136: PUSH
104137: LD_EXP 101
104141: PUSH
104142: EMPTY
104143: LIST
104144: LIST
104145: PPUSH
104146: CALL_OW 69
104150: PUSH
104151: FOR_IN
104152: IFFALSE 104224
// begin if not i in minersList then
104154: LD_VAR 0 1
104158: PUSH
104159: LD_EXP 180
104163: IN
104164: NOT
104165: IFFALSE 104222
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
104167: LD_ADDR_EXP 180
104171: PUSH
104172: LD_EXP 180
104176: PPUSH
104177: LD_EXP 180
104181: PUSH
104182: LD_INT 1
104184: PLUS
104185: PPUSH
104186: LD_VAR 0 1
104190: PPUSH
104191: CALL_OW 1
104195: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
104196: LD_ADDR_EXP 181
104200: PUSH
104201: LD_EXP 181
104205: PPUSH
104206: LD_EXP 181
104210: PUSH
104211: LD_INT 1
104213: PLUS
104214: PPUSH
104215: EMPTY
104216: PPUSH
104217: CALL_OW 1
104221: ST_TO_ADDR
// end end ;
104222: GO 104151
104224: POP
104225: POP
// for i := minerMinesList downto 1 do
104226: LD_ADDR_VAR 0 1
104230: PUSH
104231: DOUBLE
104232: LD_EXP 181
104236: INC
104237: ST_TO_ADDR
104238: LD_INT 1
104240: PUSH
104241: FOR_DOWNTO
104242: IFFALSE 104578
// begin if IsLive ( minersList [ i ] ) then
104244: LD_EXP 180
104248: PUSH
104249: LD_VAR 0 1
104253: ARRAY
104254: PPUSH
104255: CALL_OW 300
104259: IFFALSE 104287
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
104261: LD_EXP 180
104265: PUSH
104266: LD_VAR 0 1
104270: ARRAY
104271: PPUSH
104272: LD_EXP 181
104276: PUSH
104277: LD_VAR 0 1
104281: ARRAY
104282: PPUSH
104283: CALL_OW 505
// if not minerMinesList [ i ] then
104287: LD_EXP 181
104291: PUSH
104292: LD_VAR 0 1
104296: ARRAY
104297: NOT
104298: IFFALSE 104302
// continue ;
104300: GO 104241
// for j := minerMinesList [ i ] downto 1 do
104302: LD_ADDR_VAR 0 2
104306: PUSH
104307: DOUBLE
104308: LD_EXP 181
104312: PUSH
104313: LD_VAR 0 1
104317: ARRAY
104318: INC
104319: ST_TO_ADDR
104320: LD_INT 1
104322: PUSH
104323: FOR_DOWNTO
104324: IFFALSE 104574
// begin side := GetSide ( minersList [ i ] ) ;
104326: LD_ADDR_VAR 0 3
104330: PUSH
104331: LD_EXP 180
104335: PUSH
104336: LD_VAR 0 1
104340: ARRAY
104341: PPUSH
104342: CALL_OW 255
104346: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
104347: LD_ADDR_VAR 0 4
104351: PUSH
104352: LD_EXP 181
104356: PUSH
104357: LD_VAR 0 1
104361: ARRAY
104362: PUSH
104363: LD_VAR 0 2
104367: ARRAY
104368: PUSH
104369: LD_INT 1
104371: ARRAY
104372: PPUSH
104373: LD_EXP 181
104377: PUSH
104378: LD_VAR 0 1
104382: ARRAY
104383: PUSH
104384: LD_VAR 0 2
104388: ARRAY
104389: PUSH
104390: LD_INT 2
104392: ARRAY
104393: PPUSH
104394: CALL_OW 428
104398: ST_TO_ADDR
// if not tmp then
104399: LD_VAR 0 4
104403: NOT
104404: IFFALSE 104408
// continue ;
104406: GO 104323
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
104408: LD_VAR 0 4
104412: PUSH
104413: LD_INT 81
104415: PUSH
104416: LD_VAR 0 3
104420: PUSH
104421: EMPTY
104422: LIST
104423: LIST
104424: PPUSH
104425: CALL_OW 69
104429: IN
104430: PUSH
104431: LD_EXP 181
104435: PUSH
104436: LD_VAR 0 1
104440: ARRAY
104441: PUSH
104442: LD_VAR 0 2
104446: ARRAY
104447: PUSH
104448: LD_INT 1
104450: ARRAY
104451: PPUSH
104452: LD_EXP 181
104456: PUSH
104457: LD_VAR 0 1
104461: ARRAY
104462: PUSH
104463: LD_VAR 0 2
104467: ARRAY
104468: PUSH
104469: LD_INT 2
104471: ARRAY
104472: PPUSH
104473: CALL_OW 458
104477: AND
104478: IFFALSE 104572
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
104480: LD_EXP 181
104484: PUSH
104485: LD_VAR 0 1
104489: ARRAY
104490: PUSH
104491: LD_VAR 0 2
104495: ARRAY
104496: PUSH
104497: LD_INT 1
104499: ARRAY
104500: PPUSH
104501: LD_EXP 181
104505: PUSH
104506: LD_VAR 0 1
104510: ARRAY
104511: PUSH
104512: LD_VAR 0 2
104516: ARRAY
104517: PUSH
104518: LD_INT 2
104520: ARRAY
104521: PPUSH
104522: LD_VAR 0 3
104526: PPUSH
104527: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
104531: LD_ADDR_EXP 181
104535: PUSH
104536: LD_EXP 181
104540: PPUSH
104541: LD_VAR 0 1
104545: PPUSH
104546: LD_EXP 181
104550: PUSH
104551: LD_VAR 0 1
104555: ARRAY
104556: PPUSH
104557: LD_VAR 0 2
104561: PPUSH
104562: CALL_OW 3
104566: PPUSH
104567: CALL_OW 1
104571: ST_TO_ADDR
// end ; end ;
104572: GO 104323
104574: POP
104575: POP
// end ;
104576: GO 104241
104578: POP
104579: POP
// end ;
104580: PPOPN 4
104582: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
104583: LD_INT 0
104585: PPUSH
104586: PPUSH
// result := false ;
104587: LD_ADDR_VAR 0 4
104591: PUSH
104592: LD_INT 0
104594: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
104595: LD_VAR 0 1
104599: PPUSH
104600: CALL_OW 264
104604: PUSH
104605: LD_EXP 101
104609: EQUAL
104610: NOT
104611: IFFALSE 104615
// exit ;
104613: GO 104855
// index := GetElementIndex ( minersList , unit ) ;
104615: LD_ADDR_VAR 0 5
104619: PUSH
104620: LD_EXP 180
104624: PPUSH
104625: LD_VAR 0 1
104629: PPUSH
104630: CALL 53326 0 2
104634: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
104635: LD_EXP 181
104639: PUSH
104640: LD_VAR 0 5
104644: ARRAY
104645: PUSH
104646: LD_EXP 182
104650: GREATEREQUAL
104651: IFFALSE 104655
// exit ;
104653: GO 104855
// ComMoveXY ( unit , x , y ) ;
104655: LD_VAR 0 1
104659: PPUSH
104660: LD_VAR 0 2
104664: PPUSH
104665: LD_VAR 0 3
104669: PPUSH
104670: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104674: LD_INT 35
104676: PPUSH
104677: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
104681: LD_VAR 0 1
104685: PPUSH
104686: LD_VAR 0 2
104690: PPUSH
104691: LD_VAR 0 3
104695: PPUSH
104696: CALL 84098 0 3
104700: NOT
104701: PUSH
104702: LD_VAR 0 1
104706: PPUSH
104707: CALL_OW 314
104711: AND
104712: IFFALSE 104716
// exit ;
104714: GO 104855
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
104716: LD_VAR 0 2
104720: PPUSH
104721: LD_VAR 0 3
104725: PPUSH
104726: CALL_OW 428
104730: PUSH
104731: LD_VAR 0 1
104735: EQUAL
104736: PUSH
104737: LD_VAR 0 1
104741: PPUSH
104742: CALL_OW 314
104746: NOT
104747: AND
104748: IFFALSE 104674
// PlaySoundXY ( x , y , PlantMine ) ;
104750: LD_VAR 0 2
104754: PPUSH
104755: LD_VAR 0 3
104759: PPUSH
104760: LD_STRING PlantMine
104762: PPUSH
104763: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104767: LD_VAR 0 2
104771: PPUSH
104772: LD_VAR 0 3
104776: PPUSH
104777: LD_VAR 0 1
104781: PPUSH
104782: CALL_OW 255
104786: PPUSH
104787: LD_INT 0
104789: PPUSH
104790: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104794: LD_ADDR_EXP 181
104798: PUSH
104799: LD_EXP 181
104803: PPUSH
104804: LD_VAR 0 5
104808: PUSH
104809: LD_EXP 181
104813: PUSH
104814: LD_VAR 0 5
104818: ARRAY
104819: PUSH
104820: LD_INT 1
104822: PLUS
104823: PUSH
104824: EMPTY
104825: LIST
104826: LIST
104827: PPUSH
104828: LD_VAR 0 2
104832: PUSH
104833: LD_VAR 0 3
104837: PUSH
104838: EMPTY
104839: LIST
104840: LIST
104841: PPUSH
104842: CALL 53541 0 3
104846: ST_TO_ADDR
// result := true ;
104847: LD_ADDR_VAR 0 4
104851: PUSH
104852: LD_INT 1
104854: ST_TO_ADDR
// end ;
104855: LD_VAR 0 4
104859: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104860: LD_INT 0
104862: PPUSH
104863: PPUSH
104864: PPUSH
// if not unit in minersList then
104865: LD_VAR 0 1
104869: PUSH
104870: LD_EXP 180
104874: IN
104875: NOT
104876: IFFALSE 104880
// exit ;
104878: GO 105272
// index := GetElementIndex ( minersList , unit ) ;
104880: LD_ADDR_VAR 0 6
104884: PUSH
104885: LD_EXP 180
104889: PPUSH
104890: LD_VAR 0 1
104894: PPUSH
104895: CALL 53326 0 2
104899: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104900: LD_ADDR_VAR 0 5
104904: PUSH
104905: DOUBLE
104906: LD_EXP 181
104910: PUSH
104911: LD_VAR 0 6
104915: ARRAY
104916: INC
104917: ST_TO_ADDR
104918: LD_INT 1
104920: PUSH
104921: FOR_DOWNTO
104922: IFFALSE 105083
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104924: LD_EXP 181
104928: PUSH
104929: LD_VAR 0 6
104933: ARRAY
104934: PUSH
104935: LD_VAR 0 5
104939: ARRAY
104940: PUSH
104941: LD_INT 1
104943: ARRAY
104944: PUSH
104945: LD_VAR 0 2
104949: EQUAL
104950: PUSH
104951: LD_EXP 181
104955: PUSH
104956: LD_VAR 0 6
104960: ARRAY
104961: PUSH
104962: LD_VAR 0 5
104966: ARRAY
104967: PUSH
104968: LD_INT 2
104970: ARRAY
104971: PUSH
104972: LD_VAR 0 3
104976: EQUAL
104977: AND
104978: IFFALSE 105081
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104980: LD_EXP 181
104984: PUSH
104985: LD_VAR 0 6
104989: ARRAY
104990: PUSH
104991: LD_VAR 0 5
104995: ARRAY
104996: PUSH
104997: LD_INT 1
104999: ARRAY
105000: PPUSH
105001: LD_EXP 181
105005: PUSH
105006: LD_VAR 0 6
105010: ARRAY
105011: PUSH
105012: LD_VAR 0 5
105016: ARRAY
105017: PUSH
105018: LD_INT 2
105020: ARRAY
105021: PPUSH
105022: LD_VAR 0 1
105026: PPUSH
105027: CALL_OW 255
105031: PPUSH
105032: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105036: LD_ADDR_EXP 181
105040: PUSH
105041: LD_EXP 181
105045: PPUSH
105046: LD_VAR 0 6
105050: PPUSH
105051: LD_EXP 181
105055: PUSH
105056: LD_VAR 0 6
105060: ARRAY
105061: PPUSH
105062: LD_VAR 0 5
105066: PPUSH
105067: CALL_OW 3
105071: PPUSH
105072: CALL_OW 1
105076: ST_TO_ADDR
// exit ;
105077: POP
105078: POP
105079: GO 105272
// end ; end ;
105081: GO 104921
105083: POP
105084: POP
// for i := minerMinesList [ index ] downto 1 do
105085: LD_ADDR_VAR 0 5
105089: PUSH
105090: DOUBLE
105091: LD_EXP 181
105095: PUSH
105096: LD_VAR 0 6
105100: ARRAY
105101: INC
105102: ST_TO_ADDR
105103: LD_INT 1
105105: PUSH
105106: FOR_DOWNTO
105107: IFFALSE 105270
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
105109: LD_EXP 181
105113: PUSH
105114: LD_VAR 0 6
105118: ARRAY
105119: PUSH
105120: LD_VAR 0 5
105124: ARRAY
105125: PUSH
105126: LD_INT 1
105128: ARRAY
105129: PPUSH
105130: LD_EXP 181
105134: PUSH
105135: LD_VAR 0 6
105139: ARRAY
105140: PUSH
105141: LD_VAR 0 5
105145: ARRAY
105146: PUSH
105147: LD_INT 2
105149: ARRAY
105150: PPUSH
105151: LD_VAR 0 2
105155: PPUSH
105156: LD_VAR 0 3
105160: PPUSH
105161: CALL_OW 298
105165: PUSH
105166: LD_INT 6
105168: LESS
105169: IFFALSE 105268
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105171: LD_EXP 181
105175: PUSH
105176: LD_VAR 0 6
105180: ARRAY
105181: PUSH
105182: LD_VAR 0 5
105186: ARRAY
105187: PUSH
105188: LD_INT 1
105190: ARRAY
105191: PPUSH
105192: LD_EXP 181
105196: PUSH
105197: LD_VAR 0 6
105201: ARRAY
105202: PUSH
105203: LD_VAR 0 5
105207: ARRAY
105208: PUSH
105209: LD_INT 2
105211: ARRAY
105212: PPUSH
105213: LD_VAR 0 1
105217: PPUSH
105218: CALL_OW 255
105222: PPUSH
105223: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105227: LD_ADDR_EXP 181
105231: PUSH
105232: LD_EXP 181
105236: PPUSH
105237: LD_VAR 0 6
105241: PPUSH
105242: LD_EXP 181
105246: PUSH
105247: LD_VAR 0 6
105251: ARRAY
105252: PPUSH
105253: LD_VAR 0 5
105257: PPUSH
105258: CALL_OW 3
105262: PPUSH
105263: CALL_OW 1
105267: ST_TO_ADDR
// end ; end ;
105268: GO 105106
105270: POP
105271: POP
// end ;
105272: LD_VAR 0 4
105276: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
105277: LD_INT 0
105279: PPUSH
105280: PPUSH
105281: PPUSH
105282: PPUSH
105283: PPUSH
105284: PPUSH
105285: PPUSH
105286: PPUSH
105287: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
105288: LD_VAR 0 1
105292: PPUSH
105293: CALL_OW 264
105297: PUSH
105298: LD_EXP 101
105302: EQUAL
105303: NOT
105304: PUSH
105305: LD_VAR 0 1
105309: PUSH
105310: LD_EXP 180
105314: IN
105315: NOT
105316: OR
105317: IFFALSE 105321
// exit ;
105319: GO 105643
// index := GetElementIndex ( minersList , unit ) ;
105321: LD_ADDR_VAR 0 6
105325: PUSH
105326: LD_EXP 180
105330: PPUSH
105331: LD_VAR 0 1
105335: PPUSH
105336: CALL 53326 0 2
105340: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
105341: LD_ADDR_VAR 0 8
105345: PUSH
105346: LD_EXP 182
105350: PUSH
105351: LD_EXP 181
105355: PUSH
105356: LD_VAR 0 6
105360: ARRAY
105361: MINUS
105362: ST_TO_ADDR
// if not minesFreeAmount then
105363: LD_VAR 0 8
105367: NOT
105368: IFFALSE 105372
// exit ;
105370: GO 105643
// tmp := [ ] ;
105372: LD_ADDR_VAR 0 7
105376: PUSH
105377: EMPTY
105378: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
105379: LD_ADDR_VAR 0 5
105383: PUSH
105384: DOUBLE
105385: LD_INT 1
105387: DEC
105388: ST_TO_ADDR
105389: LD_VAR 0 8
105393: PUSH
105394: FOR_TO
105395: IFFALSE 105590
// begin _d := rand ( 0 , 5 ) ;
105397: LD_ADDR_VAR 0 11
105401: PUSH
105402: LD_INT 0
105404: PPUSH
105405: LD_INT 5
105407: PPUSH
105408: CALL_OW 12
105412: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
105413: LD_ADDR_VAR 0 12
105417: PUSH
105418: LD_INT 2
105420: PPUSH
105421: LD_INT 6
105423: PPUSH
105424: CALL_OW 12
105428: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
105429: LD_ADDR_VAR 0 9
105433: PUSH
105434: LD_VAR 0 2
105438: PPUSH
105439: LD_VAR 0 11
105443: PPUSH
105444: LD_VAR 0 12
105448: PPUSH
105449: CALL_OW 272
105453: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
105454: LD_ADDR_VAR 0 10
105458: PUSH
105459: LD_VAR 0 3
105463: PPUSH
105464: LD_VAR 0 11
105468: PPUSH
105469: LD_VAR 0 12
105473: PPUSH
105474: CALL_OW 273
105478: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
105479: LD_VAR 0 9
105483: PPUSH
105484: LD_VAR 0 10
105488: PPUSH
105489: CALL_OW 488
105493: PUSH
105494: LD_VAR 0 9
105498: PUSH
105499: LD_VAR 0 10
105503: PUSH
105504: EMPTY
105505: LIST
105506: LIST
105507: PUSH
105508: LD_VAR 0 7
105512: IN
105513: NOT
105514: AND
105515: PUSH
105516: LD_VAR 0 9
105520: PPUSH
105521: LD_VAR 0 10
105525: PPUSH
105526: CALL_OW 458
105530: NOT
105531: AND
105532: IFFALSE 105574
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
105534: LD_ADDR_VAR 0 7
105538: PUSH
105539: LD_VAR 0 7
105543: PPUSH
105544: LD_VAR 0 7
105548: PUSH
105549: LD_INT 1
105551: PLUS
105552: PPUSH
105553: LD_VAR 0 9
105557: PUSH
105558: LD_VAR 0 10
105562: PUSH
105563: EMPTY
105564: LIST
105565: LIST
105566: PPUSH
105567: CALL_OW 1
105571: ST_TO_ADDR
105572: GO 105588
// i := i - 1 ;
105574: LD_ADDR_VAR 0 5
105578: PUSH
105579: LD_VAR 0 5
105583: PUSH
105584: LD_INT 1
105586: MINUS
105587: ST_TO_ADDR
// end ;
105588: GO 105394
105590: POP
105591: POP
// for i in tmp do
105592: LD_ADDR_VAR 0 5
105596: PUSH
105597: LD_VAR 0 7
105601: PUSH
105602: FOR_IN
105603: IFFALSE 105641
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
105605: LD_VAR 0 1
105609: PPUSH
105610: LD_VAR 0 5
105614: PUSH
105615: LD_INT 1
105617: ARRAY
105618: PPUSH
105619: LD_VAR 0 5
105623: PUSH
105624: LD_INT 2
105626: ARRAY
105627: PPUSH
105628: CALL 104583 0 3
105632: NOT
105633: IFFALSE 105639
// exit ;
105635: POP
105636: POP
105637: GO 105643
105639: GO 105602
105641: POP
105642: POP
// end ;
105643: LD_VAR 0 4
105647: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
105648: LD_INT 0
105650: PPUSH
105651: PPUSH
105652: PPUSH
105653: PPUSH
105654: PPUSH
105655: PPUSH
105656: PPUSH
// if not GetClass ( unit ) = class_sniper then
105657: LD_VAR 0 1
105661: PPUSH
105662: CALL_OW 257
105666: PUSH
105667: LD_INT 5
105669: EQUAL
105670: NOT
105671: IFFALSE 105675
// exit ;
105673: GO 106063
// dist := 8 ;
105675: LD_ADDR_VAR 0 5
105679: PUSH
105680: LD_INT 8
105682: ST_TO_ADDR
// viewRange := 12 ;
105683: LD_ADDR_VAR 0 7
105687: PUSH
105688: LD_INT 12
105690: ST_TO_ADDR
// side := GetSide ( unit ) ;
105691: LD_ADDR_VAR 0 6
105695: PUSH
105696: LD_VAR 0 1
105700: PPUSH
105701: CALL_OW 255
105705: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
105706: LD_INT 61
105708: PPUSH
105709: LD_VAR 0 6
105713: PPUSH
105714: CALL_OW 321
105718: PUSH
105719: LD_INT 2
105721: EQUAL
105722: IFFALSE 105732
// viewRange := 16 ;
105724: LD_ADDR_VAR 0 7
105728: PUSH
105729: LD_INT 16
105731: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
105732: LD_VAR 0 1
105736: PPUSH
105737: LD_VAR 0 2
105741: PPUSH
105742: LD_VAR 0 3
105746: PPUSH
105747: CALL_OW 297
105751: PUSH
105752: LD_VAR 0 5
105756: GREATER
105757: IFFALSE 105836
// begin ComMoveXY ( unit , x , y ) ;
105759: LD_VAR 0 1
105763: PPUSH
105764: LD_VAR 0 2
105768: PPUSH
105769: LD_VAR 0 3
105773: PPUSH
105774: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105778: LD_INT 35
105780: PPUSH
105781: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105785: LD_VAR 0 1
105789: PPUSH
105790: LD_VAR 0 2
105794: PPUSH
105795: LD_VAR 0 3
105799: PPUSH
105800: CALL 84098 0 3
105804: NOT
105805: IFFALSE 105809
// exit ;
105807: GO 106063
// until GetDistUnitXY ( unit , x , y ) < dist ;
105809: LD_VAR 0 1
105813: PPUSH
105814: LD_VAR 0 2
105818: PPUSH
105819: LD_VAR 0 3
105823: PPUSH
105824: CALL_OW 297
105828: PUSH
105829: LD_VAR 0 5
105833: LESS
105834: IFFALSE 105778
// end ; ComTurnXY ( unit , x , y ) ;
105836: LD_VAR 0 1
105840: PPUSH
105841: LD_VAR 0 2
105845: PPUSH
105846: LD_VAR 0 3
105850: PPUSH
105851: CALL_OW 118
// wait ( 5 ) ;
105855: LD_INT 5
105857: PPUSH
105858: CALL_OW 67
// _d := GetDir ( unit ) ;
105862: LD_ADDR_VAR 0 10
105866: PUSH
105867: LD_VAR 0 1
105871: PPUSH
105872: CALL_OW 254
105876: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105877: LD_ADDR_VAR 0 8
105881: PUSH
105882: LD_VAR 0 1
105886: PPUSH
105887: CALL_OW 250
105891: PPUSH
105892: LD_VAR 0 10
105896: PPUSH
105897: LD_VAR 0 5
105901: PPUSH
105902: CALL_OW 272
105906: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105907: LD_ADDR_VAR 0 9
105911: PUSH
105912: LD_VAR 0 1
105916: PPUSH
105917: CALL_OW 251
105921: PPUSH
105922: LD_VAR 0 10
105926: PPUSH
105927: LD_VAR 0 5
105931: PPUSH
105932: CALL_OW 273
105936: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105937: LD_VAR 0 8
105941: PPUSH
105942: LD_VAR 0 9
105946: PPUSH
105947: CALL_OW 488
105951: NOT
105952: IFFALSE 105956
// exit ;
105954: GO 106063
// ComAnimCustom ( unit , 1 ) ;
105956: LD_VAR 0 1
105960: PPUSH
105961: LD_INT 1
105963: PPUSH
105964: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105968: LD_VAR 0 8
105972: PPUSH
105973: LD_VAR 0 9
105977: PPUSH
105978: LD_VAR 0 6
105982: PPUSH
105983: LD_VAR 0 7
105987: PPUSH
105988: CALL_OW 330
// repeat wait ( 1 ) ;
105992: LD_INT 1
105994: PPUSH
105995: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105999: LD_VAR 0 1
106003: PPUSH
106004: CALL_OW 316
106008: PUSH
106009: LD_VAR 0 1
106013: PPUSH
106014: CALL_OW 314
106018: OR
106019: PUSH
106020: LD_VAR 0 1
106024: PPUSH
106025: CALL_OW 302
106029: NOT
106030: OR
106031: PUSH
106032: LD_VAR 0 1
106036: PPUSH
106037: CALL_OW 301
106041: OR
106042: IFFALSE 105992
// RemoveSeeing ( _x , _y , side ) ;
106044: LD_VAR 0 8
106048: PPUSH
106049: LD_VAR 0 9
106053: PPUSH
106054: LD_VAR 0 6
106058: PPUSH
106059: CALL_OW 331
// end ; end_of_file
106063: LD_VAR 0 4
106067: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
106068: LD_INT 0
106070: PPUSH
106071: PPUSH
106072: PPUSH
106073: PPUSH
106074: PPUSH
106075: PPUSH
106076: PPUSH
106077: PPUSH
106078: PPUSH
106079: PPUSH
106080: PPUSH
106081: PPUSH
106082: PPUSH
106083: PPUSH
106084: PPUSH
106085: PPUSH
106086: PPUSH
106087: PPUSH
106088: PPUSH
106089: PPUSH
106090: PPUSH
106091: PPUSH
106092: PPUSH
106093: PPUSH
106094: PPUSH
106095: PPUSH
106096: PPUSH
106097: PPUSH
106098: PPUSH
106099: PPUSH
106100: PPUSH
106101: PPUSH
106102: PPUSH
106103: PPUSH
// if not list then
106104: LD_VAR 0 1
106108: NOT
106109: IFFALSE 106113
// exit ;
106111: GO 110772
// base := list [ 1 ] ;
106113: LD_ADDR_VAR 0 3
106117: PUSH
106118: LD_VAR 0 1
106122: PUSH
106123: LD_INT 1
106125: ARRAY
106126: ST_TO_ADDR
// group := list [ 2 ] ;
106127: LD_ADDR_VAR 0 4
106131: PUSH
106132: LD_VAR 0 1
106136: PUSH
106137: LD_INT 2
106139: ARRAY
106140: ST_TO_ADDR
// path := list [ 3 ] ;
106141: LD_ADDR_VAR 0 5
106145: PUSH
106146: LD_VAR 0 1
106150: PUSH
106151: LD_INT 3
106153: ARRAY
106154: ST_TO_ADDR
// flags := list [ 4 ] ;
106155: LD_ADDR_VAR 0 6
106159: PUSH
106160: LD_VAR 0 1
106164: PUSH
106165: LD_INT 4
106167: ARRAY
106168: ST_TO_ADDR
// mined := [ ] ;
106169: LD_ADDR_VAR 0 27
106173: PUSH
106174: EMPTY
106175: ST_TO_ADDR
// bombed := [ ] ;
106176: LD_ADDR_VAR 0 28
106180: PUSH
106181: EMPTY
106182: ST_TO_ADDR
// healers := [ ] ;
106183: LD_ADDR_VAR 0 31
106187: PUSH
106188: EMPTY
106189: ST_TO_ADDR
// to_heal := [ ] ;
106190: LD_ADDR_VAR 0 30
106194: PUSH
106195: EMPTY
106196: ST_TO_ADDR
// repairs := [ ] ;
106197: LD_ADDR_VAR 0 33
106201: PUSH
106202: EMPTY
106203: ST_TO_ADDR
// to_repair := [ ] ;
106204: LD_ADDR_VAR 0 32
106208: PUSH
106209: EMPTY
106210: ST_TO_ADDR
// if not group or not path then
106211: LD_VAR 0 4
106215: NOT
106216: PUSH
106217: LD_VAR 0 5
106221: NOT
106222: OR
106223: IFFALSE 106227
// exit ;
106225: GO 110772
// side := GetSide ( group [ 1 ] ) ;
106227: LD_ADDR_VAR 0 35
106231: PUSH
106232: LD_VAR 0 4
106236: PUSH
106237: LD_INT 1
106239: ARRAY
106240: PPUSH
106241: CALL_OW 255
106245: ST_TO_ADDR
// if flags then
106246: LD_VAR 0 6
106250: IFFALSE 106394
// begin f_ignore_area := flags [ 1 ] ;
106252: LD_ADDR_VAR 0 17
106256: PUSH
106257: LD_VAR 0 6
106261: PUSH
106262: LD_INT 1
106264: ARRAY
106265: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
106266: LD_ADDR_VAR 0 18
106270: PUSH
106271: LD_VAR 0 6
106275: PUSH
106276: LD_INT 2
106278: ARRAY
106279: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
106280: LD_ADDR_VAR 0 19
106284: PUSH
106285: LD_VAR 0 6
106289: PUSH
106290: LD_INT 3
106292: ARRAY
106293: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
106294: LD_ADDR_VAR 0 20
106298: PUSH
106299: LD_VAR 0 6
106303: PUSH
106304: LD_INT 4
106306: ARRAY
106307: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
106308: LD_ADDR_VAR 0 21
106312: PUSH
106313: LD_VAR 0 6
106317: PUSH
106318: LD_INT 5
106320: ARRAY
106321: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
106322: LD_ADDR_VAR 0 22
106326: PUSH
106327: LD_VAR 0 6
106331: PUSH
106332: LD_INT 6
106334: ARRAY
106335: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
106336: LD_ADDR_VAR 0 23
106340: PUSH
106341: LD_VAR 0 6
106345: PUSH
106346: LD_INT 7
106348: ARRAY
106349: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
106350: LD_ADDR_VAR 0 24
106354: PUSH
106355: LD_VAR 0 6
106359: PUSH
106360: LD_INT 8
106362: ARRAY
106363: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
106364: LD_ADDR_VAR 0 25
106368: PUSH
106369: LD_VAR 0 6
106373: PUSH
106374: LD_INT 9
106376: ARRAY
106377: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
106378: LD_ADDR_VAR 0 26
106382: PUSH
106383: LD_VAR 0 6
106387: PUSH
106388: LD_INT 10
106390: ARRAY
106391: ST_TO_ADDR
// end else
106392: GO 106474
// begin f_ignore_area := false ;
106394: LD_ADDR_VAR 0 17
106398: PUSH
106399: LD_INT 0
106401: ST_TO_ADDR
// f_capture := false ;
106402: LD_ADDR_VAR 0 18
106406: PUSH
106407: LD_INT 0
106409: ST_TO_ADDR
// f_ignore_civ := false ;
106410: LD_ADDR_VAR 0 19
106414: PUSH
106415: LD_INT 0
106417: ST_TO_ADDR
// f_murder := false ;
106418: LD_ADDR_VAR 0 20
106422: PUSH
106423: LD_INT 0
106425: ST_TO_ADDR
// f_mines := false ;
106426: LD_ADDR_VAR 0 21
106430: PUSH
106431: LD_INT 0
106433: ST_TO_ADDR
// f_repair := false ;
106434: LD_ADDR_VAR 0 22
106438: PUSH
106439: LD_INT 0
106441: ST_TO_ADDR
// f_heal := false ;
106442: LD_ADDR_VAR 0 23
106446: PUSH
106447: LD_INT 0
106449: ST_TO_ADDR
// f_spacetime := false ;
106450: LD_ADDR_VAR 0 24
106454: PUSH
106455: LD_INT 0
106457: ST_TO_ADDR
// f_attack_depot := false ;
106458: LD_ADDR_VAR 0 25
106462: PUSH
106463: LD_INT 0
106465: ST_TO_ADDR
// f_crawl := false ;
106466: LD_ADDR_VAR 0 26
106470: PUSH
106471: LD_INT 0
106473: ST_TO_ADDR
// end ; if f_heal then
106474: LD_VAR 0 23
106478: IFFALSE 106505
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
106480: LD_ADDR_VAR 0 31
106484: PUSH
106485: LD_VAR 0 4
106489: PPUSH
106490: LD_INT 25
106492: PUSH
106493: LD_INT 4
106495: PUSH
106496: EMPTY
106497: LIST
106498: LIST
106499: PPUSH
106500: CALL_OW 72
106504: ST_TO_ADDR
// if f_repair then
106505: LD_VAR 0 22
106509: IFFALSE 106536
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
106511: LD_ADDR_VAR 0 33
106515: PUSH
106516: LD_VAR 0 4
106520: PPUSH
106521: LD_INT 25
106523: PUSH
106524: LD_INT 3
106526: PUSH
106527: EMPTY
106528: LIST
106529: LIST
106530: PPUSH
106531: CALL_OW 72
106535: ST_TO_ADDR
// units_path := [ ] ;
106536: LD_ADDR_VAR 0 16
106540: PUSH
106541: EMPTY
106542: ST_TO_ADDR
// for i = 1 to group do
106543: LD_ADDR_VAR 0 7
106547: PUSH
106548: DOUBLE
106549: LD_INT 1
106551: DEC
106552: ST_TO_ADDR
106553: LD_VAR 0 4
106557: PUSH
106558: FOR_TO
106559: IFFALSE 106588
// units_path := Replace ( units_path , i , path ) ;
106561: LD_ADDR_VAR 0 16
106565: PUSH
106566: LD_VAR 0 16
106570: PPUSH
106571: LD_VAR 0 7
106575: PPUSH
106576: LD_VAR 0 5
106580: PPUSH
106581: CALL_OW 1
106585: ST_TO_ADDR
106586: GO 106558
106588: POP
106589: POP
// repeat for i = group downto 1 do
106590: LD_ADDR_VAR 0 7
106594: PUSH
106595: DOUBLE
106596: LD_VAR 0 4
106600: INC
106601: ST_TO_ADDR
106602: LD_INT 1
106604: PUSH
106605: FOR_DOWNTO
106606: IFFALSE 110728
// begin wait ( 5 ) ;
106608: LD_INT 5
106610: PPUSH
106611: CALL_OW 67
// tmp := [ ] ;
106615: LD_ADDR_VAR 0 14
106619: PUSH
106620: EMPTY
106621: ST_TO_ADDR
// attacking := false ;
106622: LD_ADDR_VAR 0 29
106626: PUSH
106627: LD_INT 0
106629: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
106630: LD_VAR 0 4
106634: PUSH
106635: LD_VAR 0 7
106639: ARRAY
106640: PPUSH
106641: CALL_OW 301
106645: PUSH
106646: LD_VAR 0 4
106650: PUSH
106651: LD_VAR 0 7
106655: ARRAY
106656: NOT
106657: OR
106658: IFFALSE 106767
// begin if GetType ( group [ i ] ) = unit_human then
106660: LD_VAR 0 4
106664: PUSH
106665: LD_VAR 0 7
106669: ARRAY
106670: PPUSH
106671: CALL_OW 247
106675: PUSH
106676: LD_INT 1
106678: EQUAL
106679: IFFALSE 106725
// begin to_heal := to_heal diff group [ i ] ;
106681: LD_ADDR_VAR 0 30
106685: PUSH
106686: LD_VAR 0 30
106690: PUSH
106691: LD_VAR 0 4
106695: PUSH
106696: LD_VAR 0 7
106700: ARRAY
106701: DIFF
106702: ST_TO_ADDR
// healers := healers diff group [ i ] ;
106703: LD_ADDR_VAR 0 31
106707: PUSH
106708: LD_VAR 0 31
106712: PUSH
106713: LD_VAR 0 4
106717: PUSH
106718: LD_VAR 0 7
106722: ARRAY
106723: DIFF
106724: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
106725: LD_ADDR_VAR 0 4
106729: PUSH
106730: LD_VAR 0 4
106734: PPUSH
106735: LD_VAR 0 7
106739: PPUSH
106740: CALL_OW 3
106744: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
106745: LD_ADDR_VAR 0 16
106749: PUSH
106750: LD_VAR 0 16
106754: PPUSH
106755: LD_VAR 0 7
106759: PPUSH
106760: CALL_OW 3
106764: ST_TO_ADDR
// continue ;
106765: GO 106605
// end ; if f_repair then
106767: LD_VAR 0 22
106771: IFFALSE 107260
// begin if GetType ( group [ i ] ) = unit_vehicle then
106773: LD_VAR 0 4
106777: PUSH
106778: LD_VAR 0 7
106782: ARRAY
106783: PPUSH
106784: CALL_OW 247
106788: PUSH
106789: LD_INT 2
106791: EQUAL
106792: IFFALSE 106982
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106794: LD_VAR 0 4
106798: PUSH
106799: LD_VAR 0 7
106803: ARRAY
106804: PPUSH
106805: CALL_OW 256
106809: PUSH
106810: LD_INT 700
106812: LESS
106813: PUSH
106814: LD_VAR 0 4
106818: PUSH
106819: LD_VAR 0 7
106823: ARRAY
106824: PUSH
106825: LD_VAR 0 32
106829: IN
106830: NOT
106831: AND
106832: IFFALSE 106856
// to_repair := to_repair union group [ i ] ;
106834: LD_ADDR_VAR 0 32
106838: PUSH
106839: LD_VAR 0 32
106843: PUSH
106844: LD_VAR 0 4
106848: PUSH
106849: LD_VAR 0 7
106853: ARRAY
106854: UNION
106855: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106856: LD_VAR 0 4
106860: PUSH
106861: LD_VAR 0 7
106865: ARRAY
106866: PPUSH
106867: CALL_OW 256
106871: PUSH
106872: LD_INT 1000
106874: EQUAL
106875: PUSH
106876: LD_VAR 0 4
106880: PUSH
106881: LD_VAR 0 7
106885: ARRAY
106886: PUSH
106887: LD_VAR 0 32
106891: IN
106892: AND
106893: IFFALSE 106917
// to_repair := to_repair diff group [ i ] ;
106895: LD_ADDR_VAR 0 32
106899: PUSH
106900: LD_VAR 0 32
106904: PUSH
106905: LD_VAR 0 4
106909: PUSH
106910: LD_VAR 0 7
106914: ARRAY
106915: DIFF
106916: ST_TO_ADDR
// if group [ i ] in to_repair then
106917: LD_VAR 0 4
106921: PUSH
106922: LD_VAR 0 7
106926: ARRAY
106927: PUSH
106928: LD_VAR 0 32
106932: IN
106933: IFFALSE 106980
// begin if not IsInArea ( group [ i ] , f_repair ) then
106935: LD_VAR 0 4
106939: PUSH
106940: LD_VAR 0 7
106944: ARRAY
106945: PPUSH
106946: LD_VAR 0 22
106950: PPUSH
106951: CALL_OW 308
106955: NOT
106956: IFFALSE 106978
// ComMoveToArea ( group [ i ] , f_repair ) ;
106958: LD_VAR 0 4
106962: PUSH
106963: LD_VAR 0 7
106967: ARRAY
106968: PPUSH
106969: LD_VAR 0 22
106973: PPUSH
106974: CALL_OW 113
// continue ;
106978: GO 106605
// end ; end else
106980: GO 107260
// if group [ i ] in repairs then
106982: LD_VAR 0 4
106986: PUSH
106987: LD_VAR 0 7
106991: ARRAY
106992: PUSH
106993: LD_VAR 0 33
106997: IN
106998: IFFALSE 107260
// begin if IsInUnit ( group [ i ] ) then
107000: LD_VAR 0 4
107004: PUSH
107005: LD_VAR 0 7
107009: ARRAY
107010: PPUSH
107011: CALL_OW 310
107015: IFFALSE 107083
// begin z := IsInUnit ( group [ i ] ) ;
107017: LD_ADDR_VAR 0 13
107021: PUSH
107022: LD_VAR 0 4
107026: PUSH
107027: LD_VAR 0 7
107031: ARRAY
107032: PPUSH
107033: CALL_OW 310
107037: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
107038: LD_VAR 0 13
107042: PUSH
107043: LD_VAR 0 32
107047: IN
107048: PUSH
107049: LD_VAR 0 13
107053: PPUSH
107054: LD_VAR 0 22
107058: PPUSH
107059: CALL_OW 308
107063: AND
107064: IFFALSE 107081
// ComExitVehicle ( group [ i ] ) ;
107066: LD_VAR 0 4
107070: PUSH
107071: LD_VAR 0 7
107075: ARRAY
107076: PPUSH
107077: CALL_OW 121
// end else
107081: GO 107260
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
107083: LD_ADDR_VAR 0 13
107087: PUSH
107088: LD_VAR 0 4
107092: PPUSH
107093: LD_INT 95
107095: PUSH
107096: LD_VAR 0 22
107100: PUSH
107101: EMPTY
107102: LIST
107103: LIST
107104: PUSH
107105: LD_INT 58
107107: PUSH
107108: EMPTY
107109: LIST
107110: PUSH
107111: EMPTY
107112: LIST
107113: LIST
107114: PPUSH
107115: CALL_OW 72
107119: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
107120: LD_VAR 0 4
107124: PUSH
107125: LD_VAR 0 7
107129: ARRAY
107130: PPUSH
107131: CALL_OW 314
107135: NOT
107136: IFFALSE 107258
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
107138: LD_ADDR_VAR 0 10
107142: PUSH
107143: LD_VAR 0 13
107147: PPUSH
107148: LD_VAR 0 4
107152: PUSH
107153: LD_VAR 0 7
107157: ARRAY
107158: PPUSH
107159: CALL_OW 74
107163: ST_TO_ADDR
// if not x then
107164: LD_VAR 0 10
107168: NOT
107169: IFFALSE 107173
// continue ;
107171: GO 106605
// if GetLives ( x ) < 1000 then
107173: LD_VAR 0 10
107177: PPUSH
107178: CALL_OW 256
107182: PUSH
107183: LD_INT 1000
107185: LESS
107186: IFFALSE 107210
// ComRepairVehicle ( group [ i ] , x ) else
107188: LD_VAR 0 4
107192: PUSH
107193: LD_VAR 0 7
107197: ARRAY
107198: PPUSH
107199: LD_VAR 0 10
107203: PPUSH
107204: CALL_OW 129
107208: GO 107258
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
107210: LD_VAR 0 23
107214: PUSH
107215: LD_VAR 0 4
107219: PUSH
107220: LD_VAR 0 7
107224: ARRAY
107225: PPUSH
107226: CALL_OW 256
107230: PUSH
107231: LD_INT 1000
107233: LESS
107234: AND
107235: NOT
107236: IFFALSE 107258
// ComEnterUnit ( group [ i ] , x ) ;
107238: LD_VAR 0 4
107242: PUSH
107243: LD_VAR 0 7
107247: ARRAY
107248: PPUSH
107249: LD_VAR 0 10
107253: PPUSH
107254: CALL_OW 120
// end ; continue ;
107258: GO 106605
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
107260: LD_VAR 0 23
107264: PUSH
107265: LD_VAR 0 4
107269: PUSH
107270: LD_VAR 0 7
107274: ARRAY
107275: PPUSH
107276: CALL_OW 247
107280: PUSH
107281: LD_INT 1
107283: EQUAL
107284: AND
107285: IFFALSE 107763
// begin if group [ i ] in healers then
107287: LD_VAR 0 4
107291: PUSH
107292: LD_VAR 0 7
107296: ARRAY
107297: PUSH
107298: LD_VAR 0 31
107302: IN
107303: IFFALSE 107576
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
107305: LD_VAR 0 4
107309: PUSH
107310: LD_VAR 0 7
107314: ARRAY
107315: PPUSH
107316: LD_VAR 0 23
107320: PPUSH
107321: CALL_OW 308
107325: NOT
107326: PUSH
107327: LD_VAR 0 4
107331: PUSH
107332: LD_VAR 0 7
107336: ARRAY
107337: PPUSH
107338: CALL_OW 314
107342: NOT
107343: AND
107344: IFFALSE 107368
// ComMoveToArea ( group [ i ] , f_heal ) else
107346: LD_VAR 0 4
107350: PUSH
107351: LD_VAR 0 7
107355: ARRAY
107356: PPUSH
107357: LD_VAR 0 23
107361: PPUSH
107362: CALL_OW 113
107366: GO 107574
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
107368: LD_VAR 0 4
107372: PUSH
107373: LD_VAR 0 7
107377: ARRAY
107378: PPUSH
107379: CALL 82621 0 1
107383: PPUSH
107384: CALL_OW 256
107388: PUSH
107389: LD_INT 1000
107391: EQUAL
107392: IFFALSE 107411
// ComStop ( group [ i ] ) else
107394: LD_VAR 0 4
107398: PUSH
107399: LD_VAR 0 7
107403: ARRAY
107404: PPUSH
107405: CALL_OW 141
107409: GO 107574
// if not HasTask ( group [ i ] ) and to_heal then
107411: LD_VAR 0 4
107415: PUSH
107416: LD_VAR 0 7
107420: ARRAY
107421: PPUSH
107422: CALL_OW 314
107426: NOT
107427: PUSH
107428: LD_VAR 0 30
107432: AND
107433: IFFALSE 107574
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
107435: LD_ADDR_VAR 0 13
107439: PUSH
107440: LD_VAR 0 30
107444: PPUSH
107445: LD_INT 3
107447: PUSH
107448: LD_INT 54
107450: PUSH
107451: EMPTY
107452: LIST
107453: PUSH
107454: EMPTY
107455: LIST
107456: LIST
107457: PPUSH
107458: CALL_OW 72
107462: PPUSH
107463: LD_VAR 0 4
107467: PUSH
107468: LD_VAR 0 7
107472: ARRAY
107473: PPUSH
107474: CALL_OW 74
107478: ST_TO_ADDR
// if z then
107479: LD_VAR 0 13
107483: IFFALSE 107574
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
107485: LD_INT 91
107487: PUSH
107488: LD_VAR 0 13
107492: PUSH
107493: LD_INT 10
107495: PUSH
107496: EMPTY
107497: LIST
107498: LIST
107499: LIST
107500: PUSH
107501: LD_INT 81
107503: PUSH
107504: LD_VAR 0 13
107508: PPUSH
107509: CALL_OW 255
107513: PUSH
107514: EMPTY
107515: LIST
107516: LIST
107517: PUSH
107518: EMPTY
107519: LIST
107520: LIST
107521: PPUSH
107522: CALL_OW 69
107526: PUSH
107527: LD_INT 0
107529: EQUAL
107530: IFFALSE 107554
// ComHeal ( group [ i ] , z ) else
107532: LD_VAR 0 4
107536: PUSH
107537: LD_VAR 0 7
107541: ARRAY
107542: PPUSH
107543: LD_VAR 0 13
107547: PPUSH
107548: CALL_OW 128
107552: GO 107574
// ComMoveToArea ( group [ i ] , f_heal ) ;
107554: LD_VAR 0 4
107558: PUSH
107559: LD_VAR 0 7
107563: ARRAY
107564: PPUSH
107565: LD_VAR 0 23
107569: PPUSH
107570: CALL_OW 113
// end ; continue ;
107574: GO 106605
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
107576: LD_VAR 0 4
107580: PUSH
107581: LD_VAR 0 7
107585: ARRAY
107586: PPUSH
107587: CALL_OW 256
107591: PUSH
107592: LD_INT 700
107594: LESS
107595: PUSH
107596: LD_VAR 0 4
107600: PUSH
107601: LD_VAR 0 7
107605: ARRAY
107606: PUSH
107607: LD_VAR 0 30
107611: IN
107612: NOT
107613: AND
107614: IFFALSE 107638
// to_heal := to_heal union group [ i ] ;
107616: LD_ADDR_VAR 0 30
107620: PUSH
107621: LD_VAR 0 30
107625: PUSH
107626: LD_VAR 0 4
107630: PUSH
107631: LD_VAR 0 7
107635: ARRAY
107636: UNION
107637: ST_TO_ADDR
// if group [ i ] in to_heal then
107638: LD_VAR 0 4
107642: PUSH
107643: LD_VAR 0 7
107647: ARRAY
107648: PUSH
107649: LD_VAR 0 30
107653: IN
107654: IFFALSE 107763
// begin if GetLives ( group [ i ] ) = 1000 then
107656: LD_VAR 0 4
107660: PUSH
107661: LD_VAR 0 7
107665: ARRAY
107666: PPUSH
107667: CALL_OW 256
107671: PUSH
107672: LD_INT 1000
107674: EQUAL
107675: IFFALSE 107701
// to_heal := to_heal diff group [ i ] else
107677: LD_ADDR_VAR 0 30
107681: PUSH
107682: LD_VAR 0 30
107686: PUSH
107687: LD_VAR 0 4
107691: PUSH
107692: LD_VAR 0 7
107696: ARRAY
107697: DIFF
107698: ST_TO_ADDR
107699: GO 107763
// begin if not IsInArea ( group [ i ] , to_heal ) then
107701: LD_VAR 0 4
107705: PUSH
107706: LD_VAR 0 7
107710: ARRAY
107711: PPUSH
107712: LD_VAR 0 30
107716: PPUSH
107717: CALL_OW 308
107721: NOT
107722: IFFALSE 107746
// ComMoveToArea ( group [ i ] , f_heal ) else
107724: LD_VAR 0 4
107728: PUSH
107729: LD_VAR 0 7
107733: ARRAY
107734: PPUSH
107735: LD_VAR 0 23
107739: PPUSH
107740: CALL_OW 113
107744: GO 107761
// ComHold ( group [ i ] ) ;
107746: LD_VAR 0 4
107750: PUSH
107751: LD_VAR 0 7
107755: ARRAY
107756: PPUSH
107757: CALL_OW 140
// continue ;
107761: GO 106605
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107763: LD_VAR 0 4
107767: PUSH
107768: LD_VAR 0 7
107772: ARRAY
107773: PPUSH
107774: LD_INT 10
107776: PPUSH
107777: CALL 81041 0 2
107781: NOT
107782: PUSH
107783: LD_VAR 0 16
107787: PUSH
107788: LD_VAR 0 7
107792: ARRAY
107793: PUSH
107794: EMPTY
107795: EQUAL
107796: NOT
107797: AND
107798: IFFALSE 108064
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107800: LD_VAR 0 4
107804: PUSH
107805: LD_VAR 0 7
107809: ARRAY
107810: PPUSH
107811: CALL_OW 262
107815: PUSH
107816: LD_INT 1
107818: PUSH
107819: LD_INT 2
107821: PUSH
107822: EMPTY
107823: LIST
107824: LIST
107825: IN
107826: IFFALSE 107867
// if GetFuel ( group [ i ] ) < 10 then
107828: LD_VAR 0 4
107832: PUSH
107833: LD_VAR 0 7
107837: ARRAY
107838: PPUSH
107839: CALL_OW 261
107843: PUSH
107844: LD_INT 10
107846: LESS
107847: IFFALSE 107867
// SetFuel ( group [ i ] , 12 ) ;
107849: LD_VAR 0 4
107853: PUSH
107854: LD_VAR 0 7
107858: ARRAY
107859: PPUSH
107860: LD_INT 12
107862: PPUSH
107863: CALL_OW 240
// if units_path [ i ] then
107867: LD_VAR 0 16
107871: PUSH
107872: LD_VAR 0 7
107876: ARRAY
107877: IFFALSE 108062
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107879: LD_VAR 0 4
107883: PUSH
107884: LD_VAR 0 7
107888: ARRAY
107889: PPUSH
107890: LD_VAR 0 16
107894: PUSH
107895: LD_VAR 0 7
107899: ARRAY
107900: PUSH
107901: LD_INT 1
107903: ARRAY
107904: PUSH
107905: LD_INT 1
107907: ARRAY
107908: PPUSH
107909: LD_VAR 0 16
107913: PUSH
107914: LD_VAR 0 7
107918: ARRAY
107919: PUSH
107920: LD_INT 1
107922: ARRAY
107923: PUSH
107924: LD_INT 2
107926: ARRAY
107927: PPUSH
107928: CALL_OW 297
107932: PUSH
107933: LD_INT 6
107935: GREATER
107936: IFFALSE 108011
// begin if not HasTask ( group [ i ] ) then
107938: LD_VAR 0 4
107942: PUSH
107943: LD_VAR 0 7
107947: ARRAY
107948: PPUSH
107949: CALL_OW 314
107953: NOT
107954: IFFALSE 108009
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107956: LD_VAR 0 4
107960: PUSH
107961: LD_VAR 0 7
107965: ARRAY
107966: PPUSH
107967: LD_VAR 0 16
107971: PUSH
107972: LD_VAR 0 7
107976: ARRAY
107977: PUSH
107978: LD_INT 1
107980: ARRAY
107981: PUSH
107982: LD_INT 1
107984: ARRAY
107985: PPUSH
107986: LD_VAR 0 16
107990: PUSH
107991: LD_VAR 0 7
107995: ARRAY
107996: PUSH
107997: LD_INT 1
107999: ARRAY
108000: PUSH
108001: LD_INT 2
108003: ARRAY
108004: PPUSH
108005: CALL_OW 114
// end else
108009: GO 108062
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
108011: LD_ADDR_VAR 0 15
108015: PUSH
108016: LD_VAR 0 16
108020: PUSH
108021: LD_VAR 0 7
108025: ARRAY
108026: PPUSH
108027: LD_INT 1
108029: PPUSH
108030: CALL_OW 3
108034: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
108035: LD_ADDR_VAR 0 16
108039: PUSH
108040: LD_VAR 0 16
108044: PPUSH
108045: LD_VAR 0 7
108049: PPUSH
108050: LD_VAR 0 15
108054: PPUSH
108055: CALL_OW 1
108059: ST_TO_ADDR
// continue ;
108060: GO 106605
// end ; end ; end else
108062: GO 110726
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
108064: LD_ADDR_VAR 0 14
108068: PUSH
108069: LD_INT 81
108071: PUSH
108072: LD_VAR 0 4
108076: PUSH
108077: LD_VAR 0 7
108081: ARRAY
108082: PPUSH
108083: CALL_OW 255
108087: PUSH
108088: EMPTY
108089: LIST
108090: LIST
108091: PPUSH
108092: CALL_OW 69
108096: ST_TO_ADDR
// if not tmp then
108097: LD_VAR 0 14
108101: NOT
108102: IFFALSE 108106
// continue ;
108104: GO 106605
// if f_ignore_area then
108106: LD_VAR 0 17
108110: IFFALSE 108198
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
108112: LD_ADDR_VAR 0 15
108116: PUSH
108117: LD_VAR 0 14
108121: PPUSH
108122: LD_INT 3
108124: PUSH
108125: LD_INT 92
108127: PUSH
108128: LD_VAR 0 17
108132: PUSH
108133: LD_INT 1
108135: ARRAY
108136: PUSH
108137: LD_VAR 0 17
108141: PUSH
108142: LD_INT 2
108144: ARRAY
108145: PUSH
108146: LD_VAR 0 17
108150: PUSH
108151: LD_INT 3
108153: ARRAY
108154: PUSH
108155: EMPTY
108156: LIST
108157: LIST
108158: LIST
108159: LIST
108160: PUSH
108161: EMPTY
108162: LIST
108163: LIST
108164: PPUSH
108165: CALL_OW 72
108169: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108170: LD_VAR 0 14
108174: PUSH
108175: LD_VAR 0 15
108179: DIFF
108180: IFFALSE 108198
// tmp := tmp diff tmp2 ;
108182: LD_ADDR_VAR 0 14
108186: PUSH
108187: LD_VAR 0 14
108191: PUSH
108192: LD_VAR 0 15
108196: DIFF
108197: ST_TO_ADDR
// end ; if not f_murder then
108198: LD_VAR 0 20
108202: NOT
108203: IFFALSE 108261
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
108205: LD_ADDR_VAR 0 15
108209: PUSH
108210: LD_VAR 0 14
108214: PPUSH
108215: LD_INT 3
108217: PUSH
108218: LD_INT 50
108220: PUSH
108221: EMPTY
108222: LIST
108223: PUSH
108224: EMPTY
108225: LIST
108226: LIST
108227: PPUSH
108228: CALL_OW 72
108232: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108233: LD_VAR 0 14
108237: PUSH
108238: LD_VAR 0 15
108242: DIFF
108243: IFFALSE 108261
// tmp := tmp diff tmp2 ;
108245: LD_ADDR_VAR 0 14
108249: PUSH
108250: LD_VAR 0 14
108254: PUSH
108255: LD_VAR 0 15
108259: DIFF
108260: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
108261: LD_ADDR_VAR 0 14
108265: PUSH
108266: LD_VAR 0 4
108270: PUSH
108271: LD_VAR 0 7
108275: ARRAY
108276: PPUSH
108277: LD_VAR 0 14
108281: PPUSH
108282: LD_INT 1
108284: PPUSH
108285: LD_INT 1
108287: PPUSH
108288: CALL 53976 0 4
108292: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
108293: LD_VAR 0 4
108297: PUSH
108298: LD_VAR 0 7
108302: ARRAY
108303: PPUSH
108304: CALL_OW 257
108308: PUSH
108309: LD_INT 1
108311: EQUAL
108312: IFFALSE 108760
// begin if WantPlant ( group [ i ] ) then
108314: LD_VAR 0 4
108318: PUSH
108319: LD_VAR 0 7
108323: ARRAY
108324: PPUSH
108325: CALL 53477 0 1
108329: IFFALSE 108333
// continue ;
108331: GO 106605
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
108333: LD_VAR 0 18
108337: PUSH
108338: LD_VAR 0 4
108342: PUSH
108343: LD_VAR 0 7
108347: ARRAY
108348: PPUSH
108349: CALL_OW 310
108353: NOT
108354: AND
108355: PUSH
108356: LD_VAR 0 14
108360: PUSH
108361: LD_INT 1
108363: ARRAY
108364: PUSH
108365: LD_VAR 0 14
108369: PPUSH
108370: LD_INT 21
108372: PUSH
108373: LD_INT 2
108375: PUSH
108376: EMPTY
108377: LIST
108378: LIST
108379: PUSH
108380: LD_INT 58
108382: PUSH
108383: EMPTY
108384: LIST
108385: PUSH
108386: EMPTY
108387: LIST
108388: LIST
108389: PPUSH
108390: CALL_OW 72
108394: IN
108395: AND
108396: IFFALSE 108432
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
108398: LD_VAR 0 4
108402: PUSH
108403: LD_VAR 0 7
108407: ARRAY
108408: PPUSH
108409: LD_VAR 0 14
108413: PUSH
108414: LD_INT 1
108416: ARRAY
108417: PPUSH
108418: CALL_OW 120
// attacking := true ;
108422: LD_ADDR_VAR 0 29
108426: PUSH
108427: LD_INT 1
108429: ST_TO_ADDR
// continue ;
108430: GO 106605
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
108432: LD_VAR 0 26
108436: PUSH
108437: LD_VAR 0 4
108441: PUSH
108442: LD_VAR 0 7
108446: ARRAY
108447: PPUSH
108448: CALL_OW 257
108452: PUSH
108453: LD_INT 1
108455: EQUAL
108456: AND
108457: PUSH
108458: LD_VAR 0 4
108462: PUSH
108463: LD_VAR 0 7
108467: ARRAY
108468: PPUSH
108469: CALL_OW 256
108473: PUSH
108474: LD_INT 800
108476: LESS
108477: AND
108478: PUSH
108479: LD_VAR 0 4
108483: PUSH
108484: LD_VAR 0 7
108488: ARRAY
108489: PPUSH
108490: CALL_OW 318
108494: NOT
108495: AND
108496: IFFALSE 108513
// ComCrawl ( group [ i ] ) ;
108498: LD_VAR 0 4
108502: PUSH
108503: LD_VAR 0 7
108507: ARRAY
108508: PPUSH
108509: CALL_OW 137
// if f_mines then
108513: LD_VAR 0 21
108517: IFFALSE 108760
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
108519: LD_VAR 0 14
108523: PUSH
108524: LD_INT 1
108526: ARRAY
108527: PPUSH
108528: CALL_OW 247
108532: PUSH
108533: LD_INT 3
108535: EQUAL
108536: PUSH
108537: LD_VAR 0 14
108541: PUSH
108542: LD_INT 1
108544: ARRAY
108545: PUSH
108546: LD_VAR 0 27
108550: IN
108551: NOT
108552: AND
108553: IFFALSE 108760
// begin x := GetX ( tmp [ 1 ] ) ;
108555: LD_ADDR_VAR 0 10
108559: PUSH
108560: LD_VAR 0 14
108564: PUSH
108565: LD_INT 1
108567: ARRAY
108568: PPUSH
108569: CALL_OW 250
108573: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
108574: LD_ADDR_VAR 0 11
108578: PUSH
108579: LD_VAR 0 14
108583: PUSH
108584: LD_INT 1
108586: ARRAY
108587: PPUSH
108588: CALL_OW 251
108592: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
108593: LD_ADDR_VAR 0 12
108597: PUSH
108598: LD_VAR 0 4
108602: PUSH
108603: LD_VAR 0 7
108607: ARRAY
108608: PPUSH
108609: CALL 81126 0 1
108613: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
108614: LD_VAR 0 4
108618: PUSH
108619: LD_VAR 0 7
108623: ARRAY
108624: PPUSH
108625: LD_VAR 0 10
108629: PPUSH
108630: LD_VAR 0 11
108634: PPUSH
108635: LD_VAR 0 14
108639: PUSH
108640: LD_INT 1
108642: ARRAY
108643: PPUSH
108644: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
108648: LD_VAR 0 4
108652: PUSH
108653: LD_VAR 0 7
108657: ARRAY
108658: PPUSH
108659: LD_VAR 0 10
108663: PPUSH
108664: LD_VAR 0 12
108668: PPUSH
108669: LD_INT 7
108671: PPUSH
108672: CALL_OW 272
108676: PPUSH
108677: LD_VAR 0 11
108681: PPUSH
108682: LD_VAR 0 12
108686: PPUSH
108687: LD_INT 7
108689: PPUSH
108690: CALL_OW 273
108694: PPUSH
108695: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
108699: LD_VAR 0 4
108703: PUSH
108704: LD_VAR 0 7
108708: ARRAY
108709: PPUSH
108710: LD_INT 71
108712: PPUSH
108713: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
108717: LD_ADDR_VAR 0 27
108721: PUSH
108722: LD_VAR 0 27
108726: PPUSH
108727: LD_VAR 0 27
108731: PUSH
108732: LD_INT 1
108734: PLUS
108735: PPUSH
108736: LD_VAR 0 14
108740: PUSH
108741: LD_INT 1
108743: ARRAY
108744: PPUSH
108745: CALL_OW 1
108749: ST_TO_ADDR
// attacking := true ;
108750: LD_ADDR_VAR 0 29
108754: PUSH
108755: LD_INT 1
108757: ST_TO_ADDR
// continue ;
108758: GO 106605
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108760: LD_VAR 0 4
108764: PUSH
108765: LD_VAR 0 7
108769: ARRAY
108770: PPUSH
108771: CALL_OW 257
108775: PUSH
108776: LD_INT 17
108778: EQUAL
108779: PUSH
108780: LD_VAR 0 4
108784: PUSH
108785: LD_VAR 0 7
108789: ARRAY
108790: PPUSH
108791: CALL_OW 110
108795: PUSH
108796: LD_INT 71
108798: EQUAL
108799: NOT
108800: AND
108801: IFFALSE 108947
// begin attacking := false ;
108803: LD_ADDR_VAR 0 29
108807: PUSH
108808: LD_INT 0
108810: ST_TO_ADDR
// k := 5 ;
108811: LD_ADDR_VAR 0 9
108815: PUSH
108816: LD_INT 5
108818: ST_TO_ADDR
// if tmp < k then
108819: LD_VAR 0 14
108823: PUSH
108824: LD_VAR 0 9
108828: LESS
108829: IFFALSE 108841
// k := tmp ;
108831: LD_ADDR_VAR 0 9
108835: PUSH
108836: LD_VAR 0 14
108840: ST_TO_ADDR
// for j = 1 to k do
108841: LD_ADDR_VAR 0 8
108845: PUSH
108846: DOUBLE
108847: LD_INT 1
108849: DEC
108850: ST_TO_ADDR
108851: LD_VAR 0 9
108855: PUSH
108856: FOR_TO
108857: IFFALSE 108945
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108859: LD_VAR 0 14
108863: PUSH
108864: LD_VAR 0 8
108868: ARRAY
108869: PUSH
108870: LD_VAR 0 14
108874: PPUSH
108875: LD_INT 58
108877: PUSH
108878: EMPTY
108879: LIST
108880: PPUSH
108881: CALL_OW 72
108885: IN
108886: NOT
108887: IFFALSE 108943
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108889: LD_VAR 0 4
108893: PUSH
108894: LD_VAR 0 7
108898: ARRAY
108899: PPUSH
108900: LD_VAR 0 14
108904: PUSH
108905: LD_VAR 0 8
108909: ARRAY
108910: PPUSH
108911: CALL_OW 115
// attacking := true ;
108915: LD_ADDR_VAR 0 29
108919: PUSH
108920: LD_INT 1
108922: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108923: LD_VAR 0 4
108927: PUSH
108928: LD_VAR 0 7
108932: ARRAY
108933: PPUSH
108934: LD_INT 71
108936: PPUSH
108937: CALL_OW 109
// continue ;
108941: GO 108856
// end ; end ;
108943: GO 108856
108945: POP
108946: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108947: LD_VAR 0 4
108951: PUSH
108952: LD_VAR 0 7
108956: ARRAY
108957: PPUSH
108958: CALL_OW 257
108962: PUSH
108963: LD_INT 8
108965: EQUAL
108966: PUSH
108967: LD_VAR 0 4
108971: PUSH
108972: LD_VAR 0 7
108976: ARRAY
108977: PPUSH
108978: CALL_OW 264
108982: PUSH
108983: LD_INT 28
108985: PUSH
108986: LD_INT 45
108988: PUSH
108989: LD_INT 7
108991: PUSH
108992: LD_INT 47
108994: PUSH
108995: EMPTY
108996: LIST
108997: LIST
108998: LIST
108999: LIST
109000: IN
109001: OR
109002: IFFALSE 109258
// begin attacking := false ;
109004: LD_ADDR_VAR 0 29
109008: PUSH
109009: LD_INT 0
109011: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
109012: LD_VAR 0 14
109016: PUSH
109017: LD_INT 1
109019: ARRAY
109020: PPUSH
109021: CALL_OW 266
109025: PUSH
109026: LD_INT 32
109028: PUSH
109029: LD_INT 31
109031: PUSH
109032: LD_INT 33
109034: PUSH
109035: LD_INT 4
109037: PUSH
109038: LD_INT 5
109040: PUSH
109041: EMPTY
109042: LIST
109043: LIST
109044: LIST
109045: LIST
109046: LIST
109047: IN
109048: IFFALSE 109234
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
109050: LD_ADDR_VAR 0 9
109054: PUSH
109055: LD_VAR 0 14
109059: PUSH
109060: LD_INT 1
109062: ARRAY
109063: PPUSH
109064: CALL_OW 266
109068: PPUSH
109069: LD_VAR 0 14
109073: PUSH
109074: LD_INT 1
109076: ARRAY
109077: PPUSH
109078: CALL_OW 250
109082: PPUSH
109083: LD_VAR 0 14
109087: PUSH
109088: LD_INT 1
109090: ARRAY
109091: PPUSH
109092: CALL_OW 251
109096: PPUSH
109097: LD_VAR 0 14
109101: PUSH
109102: LD_INT 1
109104: ARRAY
109105: PPUSH
109106: CALL_OW 254
109110: PPUSH
109111: LD_VAR 0 14
109115: PUSH
109116: LD_INT 1
109118: ARRAY
109119: PPUSH
109120: CALL_OW 248
109124: PPUSH
109125: LD_INT 0
109127: PPUSH
109128: CALL 62496 0 6
109132: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
109133: LD_ADDR_VAR 0 8
109137: PUSH
109138: LD_VAR 0 4
109142: PUSH
109143: LD_VAR 0 7
109147: ARRAY
109148: PPUSH
109149: LD_VAR 0 9
109153: PPUSH
109154: CALL 81166 0 2
109158: ST_TO_ADDR
// if j then
109159: LD_VAR 0 8
109163: IFFALSE 109232
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
109165: LD_VAR 0 8
109169: PUSH
109170: LD_INT 1
109172: ARRAY
109173: PPUSH
109174: LD_VAR 0 8
109178: PUSH
109179: LD_INT 2
109181: ARRAY
109182: PPUSH
109183: CALL_OW 488
109187: IFFALSE 109232
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
109189: LD_VAR 0 4
109193: PUSH
109194: LD_VAR 0 7
109198: ARRAY
109199: PPUSH
109200: LD_VAR 0 8
109204: PUSH
109205: LD_INT 1
109207: ARRAY
109208: PPUSH
109209: LD_VAR 0 8
109213: PUSH
109214: LD_INT 2
109216: ARRAY
109217: PPUSH
109218: CALL_OW 116
// attacking := true ;
109222: LD_ADDR_VAR 0 29
109226: PUSH
109227: LD_INT 1
109229: ST_TO_ADDR
// continue ;
109230: GO 106605
// end ; end else
109232: GO 109258
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109234: LD_VAR 0 4
109238: PUSH
109239: LD_VAR 0 7
109243: ARRAY
109244: PPUSH
109245: LD_VAR 0 14
109249: PUSH
109250: LD_INT 1
109252: ARRAY
109253: PPUSH
109254: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
109258: LD_VAR 0 4
109262: PUSH
109263: LD_VAR 0 7
109267: ARRAY
109268: PPUSH
109269: CALL_OW 265
109273: PUSH
109274: LD_INT 11
109276: EQUAL
109277: IFFALSE 109555
// begin k := 10 ;
109279: LD_ADDR_VAR 0 9
109283: PUSH
109284: LD_INT 10
109286: ST_TO_ADDR
// x := 0 ;
109287: LD_ADDR_VAR 0 10
109291: PUSH
109292: LD_INT 0
109294: ST_TO_ADDR
// if tmp < k then
109295: LD_VAR 0 14
109299: PUSH
109300: LD_VAR 0 9
109304: LESS
109305: IFFALSE 109317
// k := tmp ;
109307: LD_ADDR_VAR 0 9
109311: PUSH
109312: LD_VAR 0 14
109316: ST_TO_ADDR
// for j = k downto 1 do
109317: LD_ADDR_VAR 0 8
109321: PUSH
109322: DOUBLE
109323: LD_VAR 0 9
109327: INC
109328: ST_TO_ADDR
109329: LD_INT 1
109331: PUSH
109332: FOR_DOWNTO
109333: IFFALSE 109408
// begin if GetType ( tmp [ j ] ) = unit_human then
109335: LD_VAR 0 14
109339: PUSH
109340: LD_VAR 0 8
109344: ARRAY
109345: PPUSH
109346: CALL_OW 247
109350: PUSH
109351: LD_INT 1
109353: EQUAL
109354: IFFALSE 109406
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
109356: LD_VAR 0 4
109360: PUSH
109361: LD_VAR 0 7
109365: ARRAY
109366: PPUSH
109367: LD_VAR 0 14
109371: PUSH
109372: LD_VAR 0 8
109376: ARRAY
109377: PPUSH
109378: CALL 81437 0 2
// x := tmp [ j ] ;
109382: LD_ADDR_VAR 0 10
109386: PUSH
109387: LD_VAR 0 14
109391: PUSH
109392: LD_VAR 0 8
109396: ARRAY
109397: ST_TO_ADDR
// attacking := true ;
109398: LD_ADDR_VAR 0 29
109402: PUSH
109403: LD_INT 1
109405: ST_TO_ADDR
// end ; end ;
109406: GO 109332
109408: POP
109409: POP
// if not x then
109410: LD_VAR 0 10
109414: NOT
109415: IFFALSE 109555
// begin attacking := true ;
109417: LD_ADDR_VAR 0 29
109421: PUSH
109422: LD_INT 1
109424: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
109425: LD_VAR 0 4
109429: PUSH
109430: LD_VAR 0 7
109434: ARRAY
109435: PPUSH
109436: CALL_OW 250
109440: PPUSH
109441: LD_VAR 0 4
109445: PUSH
109446: LD_VAR 0 7
109450: ARRAY
109451: PPUSH
109452: CALL_OW 251
109456: PPUSH
109457: CALL_OW 546
109461: PUSH
109462: LD_INT 2
109464: ARRAY
109465: PUSH
109466: LD_VAR 0 14
109470: PUSH
109471: LD_INT 1
109473: ARRAY
109474: PPUSH
109475: CALL_OW 250
109479: PPUSH
109480: LD_VAR 0 14
109484: PUSH
109485: LD_INT 1
109487: ARRAY
109488: PPUSH
109489: CALL_OW 251
109493: PPUSH
109494: CALL_OW 546
109498: PUSH
109499: LD_INT 2
109501: ARRAY
109502: EQUAL
109503: IFFALSE 109531
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
109505: LD_VAR 0 4
109509: PUSH
109510: LD_VAR 0 7
109514: ARRAY
109515: PPUSH
109516: LD_VAR 0 14
109520: PUSH
109521: LD_INT 1
109523: ARRAY
109524: PPUSH
109525: CALL 81437 0 2
109529: GO 109555
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109531: LD_VAR 0 4
109535: PUSH
109536: LD_VAR 0 7
109540: ARRAY
109541: PPUSH
109542: LD_VAR 0 14
109546: PUSH
109547: LD_INT 1
109549: ARRAY
109550: PPUSH
109551: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
109555: LD_VAR 0 4
109559: PUSH
109560: LD_VAR 0 7
109564: ARRAY
109565: PPUSH
109566: CALL_OW 264
109570: PUSH
109571: LD_INT 29
109573: EQUAL
109574: IFFALSE 109940
// begin if WantsToAttack ( group [ i ] ) in bombed then
109576: LD_VAR 0 4
109580: PUSH
109581: LD_VAR 0 7
109585: ARRAY
109586: PPUSH
109587: CALL_OW 319
109591: PUSH
109592: LD_VAR 0 28
109596: IN
109597: IFFALSE 109601
// continue ;
109599: GO 106605
// k := 8 ;
109601: LD_ADDR_VAR 0 9
109605: PUSH
109606: LD_INT 8
109608: ST_TO_ADDR
// x := 0 ;
109609: LD_ADDR_VAR 0 10
109613: PUSH
109614: LD_INT 0
109616: ST_TO_ADDR
// if tmp < k then
109617: LD_VAR 0 14
109621: PUSH
109622: LD_VAR 0 9
109626: LESS
109627: IFFALSE 109639
// k := tmp ;
109629: LD_ADDR_VAR 0 9
109633: PUSH
109634: LD_VAR 0 14
109638: ST_TO_ADDR
// for j = 1 to k do
109639: LD_ADDR_VAR 0 8
109643: PUSH
109644: DOUBLE
109645: LD_INT 1
109647: DEC
109648: ST_TO_ADDR
109649: LD_VAR 0 9
109653: PUSH
109654: FOR_TO
109655: IFFALSE 109787
// begin if GetType ( tmp [ j ] ) = unit_building then
109657: LD_VAR 0 14
109661: PUSH
109662: LD_VAR 0 8
109666: ARRAY
109667: PPUSH
109668: CALL_OW 247
109672: PUSH
109673: LD_INT 3
109675: EQUAL
109676: IFFALSE 109785
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
109678: LD_VAR 0 14
109682: PUSH
109683: LD_VAR 0 8
109687: ARRAY
109688: PUSH
109689: LD_VAR 0 28
109693: IN
109694: NOT
109695: PUSH
109696: LD_VAR 0 14
109700: PUSH
109701: LD_VAR 0 8
109705: ARRAY
109706: PPUSH
109707: CALL_OW 313
109711: AND
109712: IFFALSE 109785
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109714: LD_VAR 0 4
109718: PUSH
109719: LD_VAR 0 7
109723: ARRAY
109724: PPUSH
109725: LD_VAR 0 14
109729: PUSH
109730: LD_VAR 0 8
109734: ARRAY
109735: PPUSH
109736: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
109740: LD_ADDR_VAR 0 28
109744: PUSH
109745: LD_VAR 0 28
109749: PPUSH
109750: LD_VAR 0 28
109754: PUSH
109755: LD_INT 1
109757: PLUS
109758: PPUSH
109759: LD_VAR 0 14
109763: PUSH
109764: LD_VAR 0 8
109768: ARRAY
109769: PPUSH
109770: CALL_OW 1
109774: ST_TO_ADDR
// attacking := true ;
109775: LD_ADDR_VAR 0 29
109779: PUSH
109780: LD_INT 1
109782: ST_TO_ADDR
// break ;
109783: GO 109787
// end ; end ;
109785: GO 109654
109787: POP
109788: POP
// if not attacking and f_attack_depot then
109789: LD_VAR 0 29
109793: NOT
109794: PUSH
109795: LD_VAR 0 25
109799: AND
109800: IFFALSE 109895
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109802: LD_ADDR_VAR 0 13
109806: PUSH
109807: LD_VAR 0 14
109811: PPUSH
109812: LD_INT 2
109814: PUSH
109815: LD_INT 30
109817: PUSH
109818: LD_INT 0
109820: PUSH
109821: EMPTY
109822: LIST
109823: LIST
109824: PUSH
109825: LD_INT 30
109827: PUSH
109828: LD_INT 1
109830: PUSH
109831: EMPTY
109832: LIST
109833: LIST
109834: PUSH
109835: EMPTY
109836: LIST
109837: LIST
109838: LIST
109839: PPUSH
109840: CALL_OW 72
109844: ST_TO_ADDR
// if z then
109845: LD_VAR 0 13
109849: IFFALSE 109895
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109851: LD_VAR 0 4
109855: PUSH
109856: LD_VAR 0 7
109860: ARRAY
109861: PPUSH
109862: LD_VAR 0 13
109866: PPUSH
109867: LD_VAR 0 4
109871: PUSH
109872: LD_VAR 0 7
109876: ARRAY
109877: PPUSH
109878: CALL_OW 74
109882: PPUSH
109883: CALL_OW 115
// attacking := true ;
109887: LD_ADDR_VAR 0 29
109891: PUSH
109892: LD_INT 1
109894: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109895: LD_VAR 0 4
109899: PUSH
109900: LD_VAR 0 7
109904: ARRAY
109905: PPUSH
109906: CALL_OW 256
109910: PUSH
109911: LD_INT 500
109913: LESS
109914: IFFALSE 109940
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109916: LD_VAR 0 4
109920: PUSH
109921: LD_VAR 0 7
109925: ARRAY
109926: PPUSH
109927: LD_VAR 0 14
109931: PUSH
109932: LD_INT 1
109934: ARRAY
109935: PPUSH
109936: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109940: LD_VAR 0 4
109944: PUSH
109945: LD_VAR 0 7
109949: ARRAY
109950: PPUSH
109951: CALL_OW 264
109955: PUSH
109956: LD_INT 49
109958: EQUAL
109959: IFFALSE 110080
// begin if not HasTask ( group [ i ] ) then
109961: LD_VAR 0 4
109965: PUSH
109966: LD_VAR 0 7
109970: ARRAY
109971: PPUSH
109972: CALL_OW 314
109976: NOT
109977: IFFALSE 110080
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109979: LD_ADDR_VAR 0 9
109983: PUSH
109984: LD_INT 81
109986: PUSH
109987: LD_VAR 0 4
109991: PUSH
109992: LD_VAR 0 7
109996: ARRAY
109997: PPUSH
109998: CALL_OW 255
110002: PUSH
110003: EMPTY
110004: LIST
110005: LIST
110006: PPUSH
110007: CALL_OW 69
110011: PPUSH
110012: LD_VAR 0 4
110016: PUSH
110017: LD_VAR 0 7
110021: ARRAY
110022: PPUSH
110023: CALL_OW 74
110027: ST_TO_ADDR
// if k then
110028: LD_VAR 0 9
110032: IFFALSE 110080
// if GetDistUnits ( group [ i ] , k ) > 10 then
110034: LD_VAR 0 4
110038: PUSH
110039: LD_VAR 0 7
110043: ARRAY
110044: PPUSH
110045: LD_VAR 0 9
110049: PPUSH
110050: CALL_OW 296
110054: PUSH
110055: LD_INT 10
110057: GREATER
110058: IFFALSE 110080
// ComMoveUnit ( group [ i ] , k ) ;
110060: LD_VAR 0 4
110064: PUSH
110065: LD_VAR 0 7
110069: ARRAY
110070: PPUSH
110071: LD_VAR 0 9
110075: PPUSH
110076: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
110080: LD_VAR 0 4
110084: PUSH
110085: LD_VAR 0 7
110089: ARRAY
110090: PPUSH
110091: CALL_OW 256
110095: PUSH
110096: LD_INT 250
110098: LESS
110099: PUSH
110100: LD_VAR 0 4
110104: PUSH
110105: LD_VAR 0 7
110109: ARRAY
110110: PUSH
110111: LD_INT 21
110113: PUSH
110114: LD_INT 2
110116: PUSH
110117: EMPTY
110118: LIST
110119: LIST
110120: PUSH
110121: LD_INT 23
110123: PUSH
110124: LD_INT 2
110126: PUSH
110127: EMPTY
110128: LIST
110129: LIST
110130: PUSH
110131: EMPTY
110132: LIST
110133: LIST
110134: PPUSH
110135: CALL_OW 69
110139: IN
110140: AND
110141: IFFALSE 110266
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
110143: LD_ADDR_VAR 0 9
110147: PUSH
110148: LD_OWVAR 3
110152: PUSH
110153: LD_VAR 0 4
110157: PUSH
110158: LD_VAR 0 7
110162: ARRAY
110163: DIFF
110164: PPUSH
110165: LD_VAR 0 4
110169: PUSH
110170: LD_VAR 0 7
110174: ARRAY
110175: PPUSH
110176: CALL_OW 74
110180: ST_TO_ADDR
// if not k then
110181: LD_VAR 0 9
110185: NOT
110186: IFFALSE 110190
// continue ;
110188: GO 106605
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
110190: LD_VAR 0 9
110194: PUSH
110195: LD_INT 81
110197: PUSH
110198: LD_VAR 0 4
110202: PUSH
110203: LD_VAR 0 7
110207: ARRAY
110208: PPUSH
110209: CALL_OW 255
110213: PUSH
110214: EMPTY
110215: LIST
110216: LIST
110217: PPUSH
110218: CALL_OW 69
110222: IN
110223: PUSH
110224: LD_VAR 0 9
110228: PPUSH
110229: LD_VAR 0 4
110233: PUSH
110234: LD_VAR 0 7
110238: ARRAY
110239: PPUSH
110240: CALL_OW 296
110244: PUSH
110245: LD_INT 5
110247: LESS
110248: AND
110249: IFFALSE 110266
// ComAutodestruct ( group [ i ] ) ;
110251: LD_VAR 0 4
110255: PUSH
110256: LD_VAR 0 7
110260: ARRAY
110261: PPUSH
110262: CALL 81335 0 1
// end ; if f_attack_depot then
110266: LD_VAR 0 25
110270: IFFALSE 110382
// begin k := 6 ;
110272: LD_ADDR_VAR 0 9
110276: PUSH
110277: LD_INT 6
110279: ST_TO_ADDR
// if tmp < k then
110280: LD_VAR 0 14
110284: PUSH
110285: LD_VAR 0 9
110289: LESS
110290: IFFALSE 110302
// k := tmp ;
110292: LD_ADDR_VAR 0 9
110296: PUSH
110297: LD_VAR 0 14
110301: ST_TO_ADDR
// for j = 1 to k do
110302: LD_ADDR_VAR 0 8
110306: PUSH
110307: DOUBLE
110308: LD_INT 1
110310: DEC
110311: ST_TO_ADDR
110312: LD_VAR 0 9
110316: PUSH
110317: FOR_TO
110318: IFFALSE 110380
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
110320: LD_VAR 0 8
110324: PPUSH
110325: CALL_OW 266
110329: PUSH
110330: LD_INT 0
110332: PUSH
110333: LD_INT 1
110335: PUSH
110336: EMPTY
110337: LIST
110338: LIST
110339: IN
110340: IFFALSE 110378
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110342: LD_VAR 0 4
110346: PUSH
110347: LD_VAR 0 7
110351: ARRAY
110352: PPUSH
110353: LD_VAR 0 14
110357: PUSH
110358: LD_VAR 0 8
110362: ARRAY
110363: PPUSH
110364: CALL_OW 115
// attacking := true ;
110368: LD_ADDR_VAR 0 29
110372: PUSH
110373: LD_INT 1
110375: ST_TO_ADDR
// break ;
110376: GO 110380
// end ;
110378: GO 110317
110380: POP
110381: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
110382: LD_VAR 0 4
110386: PUSH
110387: LD_VAR 0 7
110391: ARRAY
110392: PPUSH
110393: CALL_OW 302
110397: PUSH
110398: LD_VAR 0 29
110402: NOT
110403: AND
110404: IFFALSE 110726
// begin if GetTag ( group [ i ] ) = 71 then
110406: LD_VAR 0 4
110410: PUSH
110411: LD_VAR 0 7
110415: ARRAY
110416: PPUSH
110417: CALL_OW 110
110421: PUSH
110422: LD_INT 71
110424: EQUAL
110425: IFFALSE 110466
// begin if HasTask ( group [ i ] ) then
110427: LD_VAR 0 4
110431: PUSH
110432: LD_VAR 0 7
110436: ARRAY
110437: PPUSH
110438: CALL_OW 314
110442: IFFALSE 110448
// continue else
110444: GO 106605
110446: GO 110466
// SetTag ( group [ i ] , 0 ) ;
110448: LD_VAR 0 4
110452: PUSH
110453: LD_VAR 0 7
110457: ARRAY
110458: PPUSH
110459: LD_INT 0
110461: PPUSH
110462: CALL_OW 109
// end ; k := 8 ;
110466: LD_ADDR_VAR 0 9
110470: PUSH
110471: LD_INT 8
110473: ST_TO_ADDR
// x := 0 ;
110474: LD_ADDR_VAR 0 10
110478: PUSH
110479: LD_INT 0
110481: ST_TO_ADDR
// if tmp < k then
110482: LD_VAR 0 14
110486: PUSH
110487: LD_VAR 0 9
110491: LESS
110492: IFFALSE 110504
// k := tmp ;
110494: LD_ADDR_VAR 0 9
110498: PUSH
110499: LD_VAR 0 14
110503: ST_TO_ADDR
// for j = 1 to k do
110504: LD_ADDR_VAR 0 8
110508: PUSH
110509: DOUBLE
110510: LD_INT 1
110512: DEC
110513: ST_TO_ADDR
110514: LD_VAR 0 9
110518: PUSH
110519: FOR_TO
110520: IFFALSE 110618
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
110522: LD_VAR 0 14
110526: PUSH
110527: LD_VAR 0 8
110531: ARRAY
110532: PPUSH
110533: CALL_OW 247
110537: PUSH
110538: LD_INT 1
110540: EQUAL
110541: PUSH
110542: LD_VAR 0 14
110546: PUSH
110547: LD_VAR 0 8
110551: ARRAY
110552: PPUSH
110553: CALL_OW 256
110557: PUSH
110558: LD_INT 250
110560: LESS
110561: PUSH
110562: LD_VAR 0 20
110566: AND
110567: PUSH
110568: LD_VAR 0 20
110572: NOT
110573: PUSH
110574: LD_VAR 0 14
110578: PUSH
110579: LD_VAR 0 8
110583: ARRAY
110584: PPUSH
110585: CALL_OW 256
110589: PUSH
110590: LD_INT 250
110592: GREATEREQUAL
110593: AND
110594: OR
110595: AND
110596: IFFALSE 110616
// begin x := tmp [ j ] ;
110598: LD_ADDR_VAR 0 10
110602: PUSH
110603: LD_VAR 0 14
110607: PUSH
110608: LD_VAR 0 8
110612: ARRAY
110613: ST_TO_ADDR
// break ;
110614: GO 110618
// end ;
110616: GO 110519
110618: POP
110619: POP
// if x then
110620: LD_VAR 0 10
110624: IFFALSE 110648
// ComAttackUnit ( group [ i ] , x ) else
110626: LD_VAR 0 4
110630: PUSH
110631: LD_VAR 0 7
110635: ARRAY
110636: PPUSH
110637: LD_VAR 0 10
110641: PPUSH
110642: CALL_OW 115
110646: GO 110672
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110648: LD_VAR 0 4
110652: PUSH
110653: LD_VAR 0 7
110657: ARRAY
110658: PPUSH
110659: LD_VAR 0 14
110663: PUSH
110664: LD_INT 1
110666: ARRAY
110667: PPUSH
110668: CALL_OW 115
// if not HasTask ( group [ i ] ) then
110672: LD_VAR 0 4
110676: PUSH
110677: LD_VAR 0 7
110681: ARRAY
110682: PPUSH
110683: CALL_OW 314
110687: NOT
110688: IFFALSE 110726
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
110690: LD_VAR 0 4
110694: PUSH
110695: LD_VAR 0 7
110699: ARRAY
110700: PPUSH
110701: LD_VAR 0 14
110705: PPUSH
110706: LD_VAR 0 4
110710: PUSH
110711: LD_VAR 0 7
110715: ARRAY
110716: PPUSH
110717: CALL_OW 74
110721: PPUSH
110722: CALL_OW 115
// end ; end ; end ;
110726: GO 106605
110728: POP
110729: POP
// wait ( 0 0$2 ) ;
110730: LD_INT 70
110732: PPUSH
110733: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
110737: LD_VAR 0 4
110741: NOT
110742: PUSH
110743: LD_VAR 0 4
110747: PUSH
110748: EMPTY
110749: EQUAL
110750: OR
110751: PUSH
110752: LD_INT 81
110754: PUSH
110755: LD_VAR 0 35
110759: PUSH
110760: EMPTY
110761: LIST
110762: LIST
110763: PPUSH
110764: CALL_OW 69
110768: NOT
110769: OR
110770: IFFALSE 106590
// end ;
110772: LD_VAR 0 2
110776: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
110777: LD_INT 0
110779: PPUSH
110780: PPUSH
110781: PPUSH
110782: PPUSH
110783: PPUSH
110784: PPUSH
// if not base or not mc_bases [ base ] or not solds then
110785: LD_VAR 0 1
110789: NOT
110790: PUSH
110791: LD_EXP 50
110795: PUSH
110796: LD_VAR 0 1
110800: ARRAY
110801: NOT
110802: OR
110803: PUSH
110804: LD_VAR 0 2
110808: NOT
110809: OR
110810: IFFALSE 110814
// exit ;
110812: GO 111368
// side := mc_sides [ base ] ;
110814: LD_ADDR_VAR 0 6
110818: PUSH
110819: LD_EXP 76
110823: PUSH
110824: LD_VAR 0 1
110828: ARRAY
110829: ST_TO_ADDR
// if not side then
110830: LD_VAR 0 6
110834: NOT
110835: IFFALSE 110839
// exit ;
110837: GO 111368
// for i in solds do
110839: LD_ADDR_VAR 0 7
110843: PUSH
110844: LD_VAR 0 2
110848: PUSH
110849: FOR_IN
110850: IFFALSE 110911
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110852: LD_VAR 0 7
110856: PPUSH
110857: CALL_OW 310
110861: PPUSH
110862: CALL_OW 266
110866: PUSH
110867: LD_INT 32
110869: PUSH
110870: LD_INT 31
110872: PUSH
110873: EMPTY
110874: LIST
110875: LIST
110876: IN
110877: IFFALSE 110897
// solds := solds diff i else
110879: LD_ADDR_VAR 0 2
110883: PUSH
110884: LD_VAR 0 2
110888: PUSH
110889: LD_VAR 0 7
110893: DIFF
110894: ST_TO_ADDR
110895: GO 110909
// SetTag ( i , 18 ) ;
110897: LD_VAR 0 7
110901: PPUSH
110902: LD_INT 18
110904: PPUSH
110905: CALL_OW 109
110909: GO 110849
110911: POP
110912: POP
// if not solds then
110913: LD_VAR 0 2
110917: NOT
110918: IFFALSE 110922
// exit ;
110920: GO 111368
// repeat wait ( 0 0$2 ) ;
110922: LD_INT 70
110924: PPUSH
110925: CALL_OW 67
// enemy := mc_scan [ base ] ;
110929: LD_ADDR_VAR 0 4
110933: PUSH
110934: LD_EXP 73
110938: PUSH
110939: LD_VAR 0 1
110943: ARRAY
110944: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110945: LD_EXP 50
110949: PUSH
110950: LD_VAR 0 1
110954: ARRAY
110955: NOT
110956: PUSH
110957: LD_EXP 50
110961: PUSH
110962: LD_VAR 0 1
110966: ARRAY
110967: PUSH
110968: EMPTY
110969: EQUAL
110970: OR
110971: IFFALSE 111008
// begin for i in solds do
110973: LD_ADDR_VAR 0 7
110977: PUSH
110978: LD_VAR 0 2
110982: PUSH
110983: FOR_IN
110984: IFFALSE 110997
// ComStop ( i ) ;
110986: LD_VAR 0 7
110990: PPUSH
110991: CALL_OW 141
110995: GO 110983
110997: POP
110998: POP
// solds := [ ] ;
110999: LD_ADDR_VAR 0 2
111003: PUSH
111004: EMPTY
111005: ST_TO_ADDR
// exit ;
111006: GO 111368
// end ; for i in solds do
111008: LD_ADDR_VAR 0 7
111012: PUSH
111013: LD_VAR 0 2
111017: PUSH
111018: FOR_IN
111019: IFFALSE 111340
// begin if IsInUnit ( i ) then
111021: LD_VAR 0 7
111025: PPUSH
111026: CALL_OW 310
111030: IFFALSE 111041
// ComExitBuilding ( i ) ;
111032: LD_VAR 0 7
111036: PPUSH
111037: CALL_OW 122
// if GetLives ( i ) > 500 then
111041: LD_VAR 0 7
111045: PPUSH
111046: CALL_OW 256
111050: PUSH
111051: LD_INT 500
111053: GREATER
111054: IFFALSE 111107
// begin e := NearestUnitToUnit ( enemy , i ) ;
111056: LD_ADDR_VAR 0 5
111060: PUSH
111061: LD_VAR 0 4
111065: PPUSH
111066: LD_VAR 0 7
111070: PPUSH
111071: CALL_OW 74
111075: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
111076: LD_VAR 0 7
111080: PPUSH
111081: LD_VAR 0 5
111085: PPUSH
111086: CALL_OW 250
111090: PPUSH
111091: LD_VAR 0 5
111095: PPUSH
111096: CALL_OW 251
111100: PPUSH
111101: CALL_OW 114
// end else
111105: GO 111338
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
111107: LD_VAR 0 7
111111: PPUSH
111112: LD_EXP 50
111116: PUSH
111117: LD_VAR 0 1
111121: ARRAY
111122: PPUSH
111123: LD_INT 2
111125: PUSH
111126: LD_INT 30
111128: PUSH
111129: LD_INT 0
111131: PUSH
111132: EMPTY
111133: LIST
111134: LIST
111135: PUSH
111136: LD_INT 30
111138: PUSH
111139: LD_INT 1
111141: PUSH
111142: EMPTY
111143: LIST
111144: LIST
111145: PUSH
111146: LD_INT 30
111148: PUSH
111149: LD_INT 6
111151: PUSH
111152: EMPTY
111153: LIST
111154: LIST
111155: PUSH
111156: EMPTY
111157: LIST
111158: LIST
111159: LIST
111160: LIST
111161: PPUSH
111162: CALL_OW 72
111166: PPUSH
111167: LD_VAR 0 7
111171: PPUSH
111172: CALL_OW 74
111176: PPUSH
111177: CALL_OW 296
111181: PUSH
111182: LD_INT 10
111184: GREATER
111185: IFFALSE 111338
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
111187: LD_ADDR_VAR 0 8
111191: PUSH
111192: LD_EXP 50
111196: PUSH
111197: LD_VAR 0 1
111201: ARRAY
111202: PPUSH
111203: LD_INT 2
111205: PUSH
111206: LD_INT 30
111208: PUSH
111209: LD_INT 0
111211: PUSH
111212: EMPTY
111213: LIST
111214: LIST
111215: PUSH
111216: LD_INT 30
111218: PUSH
111219: LD_INT 1
111221: PUSH
111222: EMPTY
111223: LIST
111224: LIST
111225: PUSH
111226: LD_INT 30
111228: PUSH
111229: LD_INT 6
111231: PUSH
111232: EMPTY
111233: LIST
111234: LIST
111235: PUSH
111236: EMPTY
111237: LIST
111238: LIST
111239: LIST
111240: LIST
111241: PPUSH
111242: CALL_OW 72
111246: PPUSH
111247: LD_VAR 0 7
111251: PPUSH
111252: CALL_OW 74
111256: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
111257: LD_VAR 0 7
111261: PPUSH
111262: LD_VAR 0 8
111266: PPUSH
111267: CALL_OW 250
111271: PPUSH
111272: LD_INT 3
111274: PPUSH
111275: LD_INT 5
111277: PPUSH
111278: CALL_OW 272
111282: PPUSH
111283: LD_VAR 0 8
111287: PPUSH
111288: CALL_OW 251
111292: PPUSH
111293: LD_INT 3
111295: PPUSH
111296: LD_INT 5
111298: PPUSH
111299: CALL_OW 273
111303: PPUSH
111304: CALL_OW 111
// SetTag ( i , 0 ) ;
111308: LD_VAR 0 7
111312: PPUSH
111313: LD_INT 0
111315: PPUSH
111316: CALL_OW 109
// solds := solds diff i ;
111320: LD_ADDR_VAR 0 2
111324: PUSH
111325: LD_VAR 0 2
111329: PUSH
111330: LD_VAR 0 7
111334: DIFF
111335: ST_TO_ADDR
// continue ;
111336: GO 111018
// end ; end ;
111338: GO 111018
111340: POP
111341: POP
// until not solds or not enemy ;
111342: LD_VAR 0 2
111346: NOT
111347: PUSH
111348: LD_VAR 0 4
111352: NOT
111353: OR
111354: IFFALSE 110922
// MC_Reset ( base , 18 ) ;
111356: LD_VAR 0 1
111360: PPUSH
111361: LD_INT 18
111363: PPUSH
111364: CALL 22083 0 2
// end ;
111368: LD_VAR 0 3
111372: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
111373: LD_INT 0
111375: PPUSH
111376: PPUSH
111377: PPUSH
111378: PPUSH
111379: PPUSH
111380: PPUSH
111381: PPUSH
111382: PPUSH
111383: PPUSH
111384: PPUSH
111385: PPUSH
111386: PPUSH
111387: PPUSH
111388: PPUSH
111389: PPUSH
111390: PPUSH
111391: PPUSH
111392: PPUSH
111393: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
111394: LD_ADDR_VAR 0 12
111398: PUSH
111399: LD_EXP 50
111403: PUSH
111404: LD_VAR 0 1
111408: ARRAY
111409: PPUSH
111410: LD_INT 25
111412: PUSH
111413: LD_INT 3
111415: PUSH
111416: EMPTY
111417: LIST
111418: LIST
111419: PPUSH
111420: CALL_OW 72
111424: ST_TO_ADDR
// if mc_remote_driver [ base ] then
111425: LD_EXP 90
111429: PUSH
111430: LD_VAR 0 1
111434: ARRAY
111435: IFFALSE 111459
// mechs := mechs diff mc_remote_driver [ base ] ;
111437: LD_ADDR_VAR 0 12
111441: PUSH
111442: LD_VAR 0 12
111446: PUSH
111447: LD_EXP 90
111451: PUSH
111452: LD_VAR 0 1
111456: ARRAY
111457: DIFF
111458: ST_TO_ADDR
// for i in mechs do
111459: LD_ADDR_VAR 0 4
111463: PUSH
111464: LD_VAR 0 12
111468: PUSH
111469: FOR_IN
111470: IFFALSE 111505
// if GetTag ( i ) > 0 then
111472: LD_VAR 0 4
111476: PPUSH
111477: CALL_OW 110
111481: PUSH
111482: LD_INT 0
111484: GREATER
111485: IFFALSE 111503
// mechs := mechs diff i ;
111487: LD_ADDR_VAR 0 12
111491: PUSH
111492: LD_VAR 0 12
111496: PUSH
111497: LD_VAR 0 4
111501: DIFF
111502: ST_TO_ADDR
111503: GO 111469
111505: POP
111506: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111507: LD_ADDR_VAR 0 8
111511: PUSH
111512: LD_EXP 50
111516: PUSH
111517: LD_VAR 0 1
111521: ARRAY
111522: PPUSH
111523: LD_INT 2
111525: PUSH
111526: LD_INT 25
111528: PUSH
111529: LD_INT 1
111531: PUSH
111532: EMPTY
111533: LIST
111534: LIST
111535: PUSH
111536: LD_INT 25
111538: PUSH
111539: LD_INT 5
111541: PUSH
111542: EMPTY
111543: LIST
111544: LIST
111545: PUSH
111546: LD_INT 25
111548: PUSH
111549: LD_INT 8
111551: PUSH
111552: EMPTY
111553: LIST
111554: LIST
111555: PUSH
111556: LD_INT 25
111558: PUSH
111559: LD_INT 9
111561: PUSH
111562: EMPTY
111563: LIST
111564: LIST
111565: PUSH
111566: EMPTY
111567: LIST
111568: LIST
111569: LIST
111570: LIST
111571: LIST
111572: PPUSH
111573: CALL_OW 72
111577: ST_TO_ADDR
// if not defenders and not solds then
111578: LD_VAR 0 2
111582: NOT
111583: PUSH
111584: LD_VAR 0 8
111588: NOT
111589: AND
111590: IFFALSE 111594
// exit ;
111592: GO 113364
// depot_under_attack := false ;
111594: LD_ADDR_VAR 0 16
111598: PUSH
111599: LD_INT 0
111601: ST_TO_ADDR
// sold_defenders := [ ] ;
111602: LD_ADDR_VAR 0 17
111606: PUSH
111607: EMPTY
111608: ST_TO_ADDR
// if mechs then
111609: LD_VAR 0 12
111613: IFFALSE 111766
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
111615: LD_ADDR_VAR 0 4
111619: PUSH
111620: LD_VAR 0 2
111624: PPUSH
111625: LD_INT 21
111627: PUSH
111628: LD_INT 2
111630: PUSH
111631: EMPTY
111632: LIST
111633: LIST
111634: PPUSH
111635: CALL_OW 72
111639: PUSH
111640: FOR_IN
111641: IFFALSE 111764
// begin if GetTag ( i ) <> 20 then
111643: LD_VAR 0 4
111647: PPUSH
111648: CALL_OW 110
111652: PUSH
111653: LD_INT 20
111655: NONEQUAL
111656: IFFALSE 111670
// SetTag ( i , 20 ) ;
111658: LD_VAR 0 4
111662: PPUSH
111663: LD_INT 20
111665: PPUSH
111666: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
111670: LD_VAR 0 4
111674: PPUSH
111675: CALL_OW 263
111679: PUSH
111680: LD_INT 1
111682: EQUAL
111683: PUSH
111684: LD_VAR 0 4
111688: PPUSH
111689: CALL_OW 311
111693: NOT
111694: AND
111695: IFFALSE 111762
// begin un := mechs [ 1 ] ;
111697: LD_ADDR_VAR 0 10
111701: PUSH
111702: LD_VAR 0 12
111706: PUSH
111707: LD_INT 1
111709: ARRAY
111710: ST_TO_ADDR
// ComExit ( un ) ;
111711: LD_VAR 0 10
111715: PPUSH
111716: CALL 85680 0 1
// AddComEnterUnit ( un , i ) ;
111720: LD_VAR 0 10
111724: PPUSH
111725: LD_VAR 0 4
111729: PPUSH
111730: CALL_OW 180
// SetTag ( un , 19 ) ;
111734: LD_VAR 0 10
111738: PPUSH
111739: LD_INT 19
111741: PPUSH
111742: CALL_OW 109
// mechs := mechs diff un ;
111746: LD_ADDR_VAR 0 12
111750: PUSH
111751: LD_VAR 0 12
111755: PUSH
111756: LD_VAR 0 10
111760: DIFF
111761: ST_TO_ADDR
// end ; end ;
111762: GO 111640
111764: POP
111765: POP
// if solds then
111766: LD_VAR 0 8
111770: IFFALSE 111829
// for i in solds do
111772: LD_ADDR_VAR 0 4
111776: PUSH
111777: LD_VAR 0 8
111781: PUSH
111782: FOR_IN
111783: IFFALSE 111827
// if not GetTag ( i ) then
111785: LD_VAR 0 4
111789: PPUSH
111790: CALL_OW 110
111794: NOT
111795: IFFALSE 111825
// begin defenders := defenders union i ;
111797: LD_ADDR_VAR 0 2
111801: PUSH
111802: LD_VAR 0 2
111806: PUSH
111807: LD_VAR 0 4
111811: UNION
111812: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111813: LD_VAR 0 4
111817: PPUSH
111818: LD_INT 18
111820: PPUSH
111821: CALL_OW 109
// end ;
111825: GO 111782
111827: POP
111828: POP
// repeat wait ( 0 0$2 ) ;
111829: LD_INT 70
111831: PPUSH
111832: CALL_OW 67
// enemy := mc_scan [ base ] ;
111836: LD_ADDR_VAR 0 21
111840: PUSH
111841: LD_EXP 73
111845: PUSH
111846: LD_VAR 0 1
111850: ARRAY
111851: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111852: LD_EXP 50
111856: PUSH
111857: LD_VAR 0 1
111861: ARRAY
111862: NOT
111863: PUSH
111864: LD_EXP 50
111868: PUSH
111869: LD_VAR 0 1
111873: ARRAY
111874: PUSH
111875: EMPTY
111876: EQUAL
111877: OR
111878: IFFALSE 111915
// begin for i in defenders do
111880: LD_ADDR_VAR 0 4
111884: PUSH
111885: LD_VAR 0 2
111889: PUSH
111890: FOR_IN
111891: IFFALSE 111904
// ComStop ( i ) ;
111893: LD_VAR 0 4
111897: PPUSH
111898: CALL_OW 141
111902: GO 111890
111904: POP
111905: POP
// defenders := [ ] ;
111906: LD_ADDR_VAR 0 2
111910: PUSH
111911: EMPTY
111912: ST_TO_ADDR
// exit ;
111913: GO 113364
// end ; for i in defenders do
111915: LD_ADDR_VAR 0 4
111919: PUSH
111920: LD_VAR 0 2
111924: PUSH
111925: FOR_IN
111926: IFFALSE 112824
// begin e := NearestUnitToUnit ( enemy , i ) ;
111928: LD_ADDR_VAR 0 13
111932: PUSH
111933: LD_VAR 0 21
111937: PPUSH
111938: LD_VAR 0 4
111942: PPUSH
111943: CALL_OW 74
111947: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111948: LD_ADDR_VAR 0 7
111952: PUSH
111953: LD_EXP 50
111957: PUSH
111958: LD_VAR 0 1
111962: ARRAY
111963: PPUSH
111964: LD_INT 2
111966: PUSH
111967: LD_INT 30
111969: PUSH
111970: LD_INT 0
111972: PUSH
111973: EMPTY
111974: LIST
111975: LIST
111976: PUSH
111977: LD_INT 30
111979: PUSH
111980: LD_INT 1
111982: PUSH
111983: EMPTY
111984: LIST
111985: LIST
111986: PUSH
111987: EMPTY
111988: LIST
111989: LIST
111990: LIST
111991: PPUSH
111992: CALL_OW 72
111996: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111997: LD_ADDR_VAR 0 16
112001: PUSH
112002: LD_VAR 0 7
112006: NOT
112007: PUSH
112008: LD_VAR 0 7
112012: PPUSH
112013: LD_INT 3
112015: PUSH
112016: LD_INT 24
112018: PUSH
112019: LD_INT 600
112021: PUSH
112022: EMPTY
112023: LIST
112024: LIST
112025: PUSH
112026: EMPTY
112027: LIST
112028: LIST
112029: PPUSH
112030: CALL_OW 72
112034: OR
112035: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
112036: LD_VAR 0 4
112040: PPUSH
112041: CALL_OW 247
112045: PUSH
112046: LD_INT 2
112048: DOUBLE
112049: EQUAL
112050: IFTRUE 112054
112052: GO 112450
112054: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
112055: LD_VAR 0 4
112059: PPUSH
112060: CALL_OW 256
112064: PUSH
112065: LD_INT 1000
112067: EQUAL
112068: PUSH
112069: LD_VAR 0 4
112073: PPUSH
112074: LD_VAR 0 13
112078: PPUSH
112079: CALL_OW 296
112083: PUSH
112084: LD_INT 40
112086: LESS
112087: PUSH
112088: LD_VAR 0 13
112092: PPUSH
112093: LD_EXP 75
112097: PUSH
112098: LD_VAR 0 1
112102: ARRAY
112103: PPUSH
112104: CALL_OW 308
112108: OR
112109: AND
112110: IFFALSE 112232
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
112112: LD_VAR 0 4
112116: PPUSH
112117: CALL_OW 262
112121: PUSH
112122: LD_INT 1
112124: EQUAL
112125: PUSH
112126: LD_VAR 0 4
112130: PPUSH
112131: CALL_OW 261
112135: PUSH
112136: LD_INT 30
112138: LESS
112139: AND
112140: PUSH
112141: LD_VAR 0 7
112145: AND
112146: IFFALSE 112216
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
112148: LD_VAR 0 4
112152: PPUSH
112153: LD_VAR 0 7
112157: PPUSH
112158: LD_VAR 0 4
112162: PPUSH
112163: CALL_OW 74
112167: PPUSH
112168: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
112172: LD_VAR 0 4
112176: PPUSH
112177: LD_VAR 0 7
112181: PPUSH
112182: LD_VAR 0 4
112186: PPUSH
112187: CALL_OW 74
112191: PPUSH
112192: CALL_OW 296
112196: PUSH
112197: LD_INT 6
112199: LESS
112200: IFFALSE 112214
// SetFuel ( i , 100 ) ;
112202: LD_VAR 0 4
112206: PPUSH
112207: LD_INT 100
112209: PPUSH
112210: CALL_OW 240
// end else
112214: GO 112230
// ComAttackUnit ( i , e ) ;
112216: LD_VAR 0 4
112220: PPUSH
112221: LD_VAR 0 13
112225: PPUSH
112226: CALL_OW 115
// end else
112230: GO 112333
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
112232: LD_VAR 0 13
112236: PPUSH
112237: LD_EXP 75
112241: PUSH
112242: LD_VAR 0 1
112246: ARRAY
112247: PPUSH
112248: CALL_OW 308
112252: NOT
112253: PUSH
112254: LD_VAR 0 4
112258: PPUSH
112259: LD_VAR 0 13
112263: PPUSH
112264: CALL_OW 296
112268: PUSH
112269: LD_INT 40
112271: GREATEREQUAL
112272: AND
112273: PUSH
112274: LD_VAR 0 4
112278: PPUSH
112279: CALL_OW 256
112283: PUSH
112284: LD_INT 650
112286: LESSEQUAL
112287: OR
112288: PUSH
112289: LD_VAR 0 4
112293: PPUSH
112294: LD_EXP 74
112298: PUSH
112299: LD_VAR 0 1
112303: ARRAY
112304: PPUSH
112305: CALL_OW 308
112309: NOT
112310: AND
112311: IFFALSE 112333
// ComMoveToArea ( i , mc_parking [ base ] ) ;
112313: LD_VAR 0 4
112317: PPUSH
112318: LD_EXP 74
112322: PUSH
112323: LD_VAR 0 1
112327: ARRAY
112328: PPUSH
112329: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
112333: LD_VAR 0 4
112337: PPUSH
112338: CALL_OW 256
112342: PUSH
112343: LD_INT 1000
112345: LESS
112346: PUSH
112347: LD_VAR 0 4
112351: PPUSH
112352: CALL_OW 263
112356: PUSH
112357: LD_INT 1
112359: EQUAL
112360: AND
112361: PUSH
112362: LD_VAR 0 4
112366: PPUSH
112367: CALL_OW 311
112371: AND
112372: PUSH
112373: LD_VAR 0 4
112377: PPUSH
112378: LD_EXP 74
112382: PUSH
112383: LD_VAR 0 1
112387: ARRAY
112388: PPUSH
112389: CALL_OW 308
112393: AND
112394: IFFALSE 112448
// begin mech := IsDrivenBy ( i ) ;
112396: LD_ADDR_VAR 0 9
112400: PUSH
112401: LD_VAR 0 4
112405: PPUSH
112406: CALL_OW 311
112410: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
112411: LD_VAR 0 9
112415: PPUSH
112416: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
112420: LD_VAR 0 9
112424: PPUSH
112425: LD_VAR 0 4
112429: PPUSH
112430: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
112434: LD_VAR 0 9
112438: PPUSH
112439: LD_VAR 0 4
112443: PPUSH
112444: CALL_OW 180
// end ; end ; unit_human :
112448: GO 112795
112450: LD_INT 1
112452: DOUBLE
112453: EQUAL
112454: IFTRUE 112458
112456: GO 112794
112458: POP
// begin b := IsInUnit ( i ) ;
112459: LD_ADDR_VAR 0 18
112463: PUSH
112464: LD_VAR 0 4
112468: PPUSH
112469: CALL_OW 310
112473: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
112474: LD_ADDR_VAR 0 19
112478: PUSH
112479: LD_VAR 0 18
112483: NOT
112484: PUSH
112485: LD_VAR 0 18
112489: PPUSH
112490: CALL_OW 266
112494: PUSH
112495: LD_INT 32
112497: PUSH
112498: LD_INT 31
112500: PUSH
112501: EMPTY
112502: LIST
112503: LIST
112504: IN
112505: OR
112506: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
112507: LD_VAR 0 18
112511: PPUSH
112512: CALL_OW 266
112516: PUSH
112517: LD_INT 5
112519: EQUAL
112520: PUSH
112521: LD_VAR 0 4
112525: PPUSH
112526: CALL_OW 257
112530: PUSH
112531: LD_INT 1
112533: PUSH
112534: LD_INT 2
112536: PUSH
112537: LD_INT 3
112539: PUSH
112540: LD_INT 4
112542: PUSH
112543: EMPTY
112544: LIST
112545: LIST
112546: LIST
112547: LIST
112548: IN
112549: AND
112550: IFFALSE 112587
// begin class := AllowSpecClass ( i ) ;
112552: LD_ADDR_VAR 0 20
112556: PUSH
112557: LD_VAR 0 4
112561: PPUSH
112562: CALL 50341 0 1
112566: ST_TO_ADDR
// if class then
112567: LD_VAR 0 20
112571: IFFALSE 112587
// ComChangeProfession ( i , class ) ;
112573: LD_VAR 0 4
112577: PPUSH
112578: LD_VAR 0 20
112582: PPUSH
112583: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
112587: LD_VAR 0 16
112591: PUSH
112592: LD_VAR 0 2
112596: PPUSH
112597: LD_INT 21
112599: PUSH
112600: LD_INT 2
112602: PUSH
112603: EMPTY
112604: LIST
112605: LIST
112606: PPUSH
112607: CALL_OW 72
112611: PUSH
112612: LD_INT 1
112614: LESSEQUAL
112615: OR
112616: PUSH
112617: LD_VAR 0 19
112621: AND
112622: PUSH
112623: LD_VAR 0 4
112627: PUSH
112628: LD_VAR 0 17
112632: IN
112633: NOT
112634: AND
112635: IFFALSE 112728
// begin if b then
112637: LD_VAR 0 18
112641: IFFALSE 112690
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
112643: LD_VAR 0 18
112647: PPUSH
112648: LD_VAR 0 21
112652: PPUSH
112653: LD_VAR 0 18
112657: PPUSH
112658: CALL_OW 74
112662: PPUSH
112663: CALL_OW 296
112667: PUSH
112668: LD_INT 10
112670: LESS
112671: PUSH
112672: LD_VAR 0 18
112676: PPUSH
112677: CALL_OW 461
112681: PUSH
112682: LD_INT 7
112684: NONEQUAL
112685: AND
112686: IFFALSE 112690
// continue ;
112688: GO 111925
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
112690: LD_ADDR_VAR 0 17
112694: PUSH
112695: LD_VAR 0 17
112699: PPUSH
112700: LD_VAR 0 17
112704: PUSH
112705: LD_INT 1
112707: PLUS
112708: PPUSH
112709: LD_VAR 0 4
112713: PPUSH
112714: CALL_OW 1
112718: ST_TO_ADDR
// ComExitBuilding ( i ) ;
112719: LD_VAR 0 4
112723: PPUSH
112724: CALL_OW 122
// end ; if sold_defenders then
112728: LD_VAR 0 17
112732: IFFALSE 112792
// if i in sold_defenders then
112734: LD_VAR 0 4
112738: PUSH
112739: LD_VAR 0 17
112743: IN
112744: IFFALSE 112792
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
112746: LD_VAR 0 4
112750: PPUSH
112751: CALL_OW 314
112755: NOT
112756: PUSH
112757: LD_VAR 0 4
112761: PPUSH
112762: LD_VAR 0 13
112766: PPUSH
112767: CALL_OW 296
112771: PUSH
112772: LD_INT 30
112774: LESS
112775: AND
112776: IFFALSE 112792
// ComAttackUnit ( i , e ) ;
112778: LD_VAR 0 4
112782: PPUSH
112783: LD_VAR 0 13
112787: PPUSH
112788: CALL_OW 115
// end ; end ; end ;
112792: GO 112795
112794: POP
// if IsDead ( i ) then
112795: LD_VAR 0 4
112799: PPUSH
112800: CALL_OW 301
112804: IFFALSE 112822
// defenders := defenders diff i ;
112806: LD_ADDR_VAR 0 2
112810: PUSH
112811: LD_VAR 0 2
112815: PUSH
112816: LD_VAR 0 4
112820: DIFF
112821: ST_TO_ADDR
// end ;
112822: GO 111925
112824: POP
112825: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112826: LD_VAR 0 21
112830: NOT
112831: PUSH
112832: LD_VAR 0 2
112836: NOT
112837: OR
112838: PUSH
112839: LD_EXP 50
112843: PUSH
112844: LD_VAR 0 1
112848: ARRAY
112849: NOT
112850: OR
112851: IFFALSE 111829
// MC_Reset ( base , 18 ) ;
112853: LD_VAR 0 1
112857: PPUSH
112858: LD_INT 18
112860: PPUSH
112861: CALL 22083 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112865: LD_ADDR_VAR 0 2
112869: PUSH
112870: LD_VAR 0 2
112874: PUSH
112875: LD_VAR 0 2
112879: PPUSH
112880: LD_INT 2
112882: PUSH
112883: LD_INT 25
112885: PUSH
112886: LD_INT 1
112888: PUSH
112889: EMPTY
112890: LIST
112891: LIST
112892: PUSH
112893: LD_INT 25
112895: PUSH
112896: LD_INT 5
112898: PUSH
112899: EMPTY
112900: LIST
112901: LIST
112902: PUSH
112903: LD_INT 25
112905: PUSH
112906: LD_INT 8
112908: PUSH
112909: EMPTY
112910: LIST
112911: LIST
112912: PUSH
112913: LD_INT 25
112915: PUSH
112916: LD_INT 9
112918: PUSH
112919: EMPTY
112920: LIST
112921: LIST
112922: PUSH
112923: EMPTY
112924: LIST
112925: LIST
112926: LIST
112927: LIST
112928: LIST
112929: PPUSH
112930: CALL_OW 72
112934: DIFF
112935: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112936: LD_VAR 0 21
112940: NOT
112941: PUSH
112942: LD_VAR 0 2
112946: PPUSH
112947: LD_INT 21
112949: PUSH
112950: LD_INT 2
112952: PUSH
112953: EMPTY
112954: LIST
112955: LIST
112956: PPUSH
112957: CALL_OW 72
112961: AND
112962: IFFALSE 113300
// begin tmp := FilterByTag ( defenders , 19 ) ;
112964: LD_ADDR_VAR 0 11
112968: PUSH
112969: LD_VAR 0 2
112973: PPUSH
112974: LD_INT 19
112976: PPUSH
112977: CALL 82810 0 2
112981: ST_TO_ADDR
// if tmp then
112982: LD_VAR 0 11
112986: IFFALSE 113056
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112988: LD_ADDR_VAR 0 11
112992: PUSH
112993: LD_VAR 0 11
112997: PPUSH
112998: LD_INT 25
113000: PUSH
113001: LD_INT 3
113003: PUSH
113004: EMPTY
113005: LIST
113006: LIST
113007: PPUSH
113008: CALL_OW 72
113012: ST_TO_ADDR
// if tmp then
113013: LD_VAR 0 11
113017: IFFALSE 113056
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
113019: LD_ADDR_EXP 62
113023: PUSH
113024: LD_EXP 62
113028: PPUSH
113029: LD_VAR 0 1
113033: PPUSH
113034: LD_EXP 62
113038: PUSH
113039: LD_VAR 0 1
113043: ARRAY
113044: PUSH
113045: LD_VAR 0 11
113049: UNION
113050: PPUSH
113051: CALL_OW 1
113055: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
113056: LD_VAR 0 1
113060: PPUSH
113061: LD_INT 19
113063: PPUSH
113064: CALL 22083 0 2
// repeat wait ( 0 0$1 ) ;
113068: LD_INT 35
113070: PPUSH
113071: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113075: LD_EXP 50
113079: PUSH
113080: LD_VAR 0 1
113084: ARRAY
113085: NOT
113086: PUSH
113087: LD_EXP 50
113091: PUSH
113092: LD_VAR 0 1
113096: ARRAY
113097: PUSH
113098: EMPTY
113099: EQUAL
113100: OR
113101: IFFALSE 113138
// begin for i in defenders do
113103: LD_ADDR_VAR 0 4
113107: PUSH
113108: LD_VAR 0 2
113112: PUSH
113113: FOR_IN
113114: IFFALSE 113127
// ComStop ( i ) ;
113116: LD_VAR 0 4
113120: PPUSH
113121: CALL_OW 141
113125: GO 113113
113127: POP
113128: POP
// defenders := [ ] ;
113129: LD_ADDR_VAR 0 2
113133: PUSH
113134: EMPTY
113135: ST_TO_ADDR
// exit ;
113136: GO 113364
// end ; for i in defenders do
113138: LD_ADDR_VAR 0 4
113142: PUSH
113143: LD_VAR 0 2
113147: PUSH
113148: FOR_IN
113149: IFFALSE 113238
// begin if not IsInArea ( i , mc_parking [ base ] ) then
113151: LD_VAR 0 4
113155: PPUSH
113156: LD_EXP 74
113160: PUSH
113161: LD_VAR 0 1
113165: ARRAY
113166: PPUSH
113167: CALL_OW 308
113171: NOT
113172: IFFALSE 113196
// ComMoveToArea ( i , mc_parking [ base ] ) else
113174: LD_VAR 0 4
113178: PPUSH
113179: LD_EXP 74
113183: PUSH
113184: LD_VAR 0 1
113188: ARRAY
113189: PPUSH
113190: CALL_OW 113
113194: GO 113236
// if GetControl ( i ) = control_manual then
113196: LD_VAR 0 4
113200: PPUSH
113201: CALL_OW 263
113205: PUSH
113206: LD_INT 1
113208: EQUAL
113209: IFFALSE 113236
// if IsDrivenBy ( i ) then
113211: LD_VAR 0 4
113215: PPUSH
113216: CALL_OW 311
113220: IFFALSE 113236
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
113222: LD_VAR 0 4
113226: PPUSH
113227: CALL_OW 311
113231: PPUSH
113232: CALL_OW 121
// end ;
113236: GO 113148
113238: POP
113239: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
113240: LD_VAR 0 2
113244: PPUSH
113245: LD_INT 95
113247: PUSH
113248: LD_EXP 74
113252: PUSH
113253: LD_VAR 0 1
113257: ARRAY
113258: PUSH
113259: EMPTY
113260: LIST
113261: LIST
113262: PPUSH
113263: CALL_OW 72
113267: PUSH
113268: LD_VAR 0 2
113272: EQUAL
113273: PUSH
113274: LD_EXP 73
113278: PUSH
113279: LD_VAR 0 1
113283: ARRAY
113284: OR
113285: PUSH
113286: LD_EXP 50
113290: PUSH
113291: LD_VAR 0 1
113295: ARRAY
113296: NOT
113297: OR
113298: IFFALSE 113068
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
113300: LD_ADDR_EXP 72
113304: PUSH
113305: LD_EXP 72
113309: PPUSH
113310: LD_VAR 0 1
113314: PPUSH
113315: LD_VAR 0 2
113319: PPUSH
113320: LD_INT 21
113322: PUSH
113323: LD_INT 2
113325: PUSH
113326: EMPTY
113327: LIST
113328: LIST
113329: PPUSH
113330: CALL_OW 72
113334: PPUSH
113335: CALL_OW 1
113339: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
113340: LD_VAR 0 1
113344: PPUSH
113345: LD_INT 19
113347: PPUSH
113348: CALL 22083 0 2
// MC_Reset ( base , 20 ) ;
113352: LD_VAR 0 1
113356: PPUSH
113357: LD_INT 20
113359: PPUSH
113360: CALL 22083 0 2
// end ; end_of_file
113364: LD_VAR 0 3
113368: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
113369: LD_VAR 0 1
113373: PUSH
113374: LD_INT 200
113376: DOUBLE
113377: GREATEREQUAL
113378: IFFALSE 113386
113380: LD_INT 299
113382: DOUBLE
113383: LESSEQUAL
113384: IFTRUE 113388
113386: GO 113420
113388: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
113389: LD_VAR 0 1
113393: PPUSH
113394: LD_VAR 0 2
113398: PPUSH
113399: LD_VAR 0 3
113403: PPUSH
113404: LD_VAR 0 4
113408: PPUSH
113409: LD_VAR 0 5
113413: PPUSH
113414: CALL 102185 0 5
113418: GO 113497
113420: LD_INT 300
113422: DOUBLE
113423: GREATEREQUAL
113424: IFFALSE 113432
113426: LD_INT 399
113428: DOUBLE
113429: LESSEQUAL
113430: IFTRUE 113434
113432: GO 113496
113434: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
113435: LD_VAR 0 1
113439: PPUSH
113440: LD_VAR 0 2
113444: PPUSH
113445: LD_VAR 0 3
113449: PPUSH
113450: LD_VAR 0 4
113454: PPUSH
113455: LD_VAR 0 5
113459: PPUSH
113460: LD_VAR 0 6
113464: PPUSH
113465: LD_VAR 0 7
113469: PPUSH
113470: LD_VAR 0 8
113474: PPUSH
113475: LD_VAR 0 9
113479: PPUSH
113480: LD_VAR 0 10
113484: PPUSH
113485: LD_VAR 0 11
113489: PPUSH
113490: CALL 100083 0 11
113494: GO 113497
113496: POP
// end ;
113497: PPOPN 11
113499: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
113500: LD_VAR 0 1
113504: PPUSH
113505: LD_VAR 0 2
113509: PPUSH
113510: LD_VAR 0 3
113514: PPUSH
113515: LD_VAR 0 4
113519: PPUSH
113520: LD_VAR 0 5
113524: PPUSH
113525: CALL 102177 0 5
// end ; end_of_file
113529: PPOPN 5
113531: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
113532: LD_VAR 0 1
113536: PPUSH
113537: LD_VAR 0 2
113541: PPUSH
113542: LD_VAR 0 3
113546: PPUSH
113547: LD_VAR 0 4
113551: PPUSH
113552: LD_VAR 0 5
113556: PPUSH
113557: LD_VAR 0 6
113561: PPUSH
113562: CALL 88278 0 6
// end ;
113566: PPOPN 6
113568: END
