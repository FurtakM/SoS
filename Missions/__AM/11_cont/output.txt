// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17937 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82599 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20102 0 0
// Action ;
  89: CALL 8544 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 41787 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 41787 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 41787 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42213 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42105 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42105 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 48541 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 48541 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 48541 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 48541 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 48541 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 48541 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 48541 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 48541 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 48541 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 48541 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 48541 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 48541 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 48541 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 48541 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 48541 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 2
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57000 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57000 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57000 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57000 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57000 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 53556 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 53556 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 53678 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42501 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42105 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 54574 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5053: LD_EXP 6
5057: IFFALSE 7920
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
5071: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5072: LD_ADDR_VAR 0 4
5076: PUSH
5077: LD_INT 5
5079: PUSH
5080: LD_INT 6
5082: PUSH
5083: LD_INT 7
5085: PUSH
5086: LD_INT 8
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: ST_TO_ADDR
// coords := [ ] ;
5101: LD_ADDR_VAR 0 5
5105: PUSH
5106: EMPTY
5107: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5108: LD_ADDR_VAR 0 6
5112: PUSH
5113: LD_INT 0
5115: PUSH
5116: LD_INT 0
5118: PUSH
5119: LD_INT 0
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 1
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: LIST
5154: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5155: LD_INT 1
5157: PPUSH
5158: LD_INT 14
5160: PUSH
5161: LD_INT 1
5163: PUSH
5164: LD_INT 2
5166: PUSH
5167: LD_INT 28
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 25
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 28
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 29
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: PPUSH
5236: CALL 42105 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5240: LD_INT 21000
5242: PUSH
5243: LD_INT 19950
5245: PUSH
5246: LD_INT 18900
5248: PUSH
5249: LD_INT 18200
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: PUSH
5258: LD_OWVAR 67
5262: ARRAY
5263: PPUSH
5264: CALL_OW 67
// InitHc ;
5268: CALL_OW 19
// InitUc ;
5272: CALL_OW 18
// uc_side := 2 ;
5276: LD_ADDR_OWVAR 20
5280: PUSH
5281: LD_INT 2
5283: ST_TO_ADDR
// uc_nation := 2 ;
5284: LD_ADDR_OWVAR 21
5288: PUSH
5289: LD_INT 2
5291: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5292: LD_ADDR_VAR 0 3
5296: PUSH
5297: EMPTY
5298: PUSH
5299: EMPTY
5300: PUSH
5301: EMPTY
5302: PUSH
5303: EMPTY
5304: PUSH
5305: EMPTY
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: LIST
5313: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5314: LD_ADDR_VAR 0 3
5318: PUSH
5319: LD_VAR 0 3
5323: PPUSH
5324: LD_INT 1
5326: PPUSH
5327: LD_EXP 69
5331: PUSH
5332: LD_INT 1
5334: ARRAY
5335: PUSH
5336: LD_INT 2
5338: PUSH
5339: LD_INT 34
5341: PUSH
5342: LD_INT 88
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PUSH
5349: LD_INT 34
5351: PUSH
5352: LD_INT 32
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL_OW 69
5368: DIFF
5369: PPUSH
5370: CALL_OW 1
5374: ST_TO_ADDR
// for i = 1 to Difficulty do
5375: LD_ADDR_VAR 0 1
5379: PUSH
5380: DOUBLE
5381: LD_INT 1
5383: DEC
5384: ST_TO_ADDR
5385: LD_OWVAR 67
5389: PUSH
5390: FOR_TO
5391: IFFALSE 5529
// begin uc_side := 2 ;
5393: LD_ADDR_OWVAR 20
5397: PUSH
5398: LD_INT 2
5400: ST_TO_ADDR
// uc_nation := 2 ;
5401: LD_ADDR_OWVAR 21
5405: PUSH
5406: LD_INT 2
5408: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5409: LD_INT 13
5411: PPUSH
5412: LD_INT 3
5414: PPUSH
5415: LD_INT 5
5417: PPUSH
5418: LD_INT 29
5420: PPUSH
5421: LD_INT 100
5423: PPUSH
5424: CALL 53556 0 5
// un := CreateVehicle ;
5428: LD_ADDR_VAR 0 2
5432: PUSH
5433: CALL_OW 45
5437: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5438: LD_ADDR_VAR 0 3
5442: PUSH
5443: LD_VAR 0 3
5447: PPUSH
5448: LD_INT 1
5450: PUSH
5451: LD_VAR 0 3
5455: PUSH
5456: LD_INT 1
5458: ARRAY
5459: PUSH
5460: LD_INT 1
5462: PLUS
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PPUSH
5468: LD_VAR 0 2
5472: PPUSH
5473: CALL 53678 0 3
5477: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5478: LD_VAR 0 2
5482: PPUSH
5483: LD_INT 3
5485: PPUSH
5486: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5490: LD_VAR 0 2
5494: PPUSH
5495: LD_INT 16
5497: PPUSH
5498: LD_INT 0
5500: PPUSH
5501: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5505: LD_VAR 0 2
5509: PPUSH
5510: LD_INT 51
5512: PPUSH
5513: LD_INT 10
5515: PPUSH
5516: CALL_OW 111
// wait ( 0 0$2 ) ;
5520: LD_INT 70
5522: PPUSH
5523: CALL_OW 67
// end ;
5527: GO 5390
5529: POP
5530: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5531: LD_ADDR_VAR 0 5
5535: PUSH
5536: LD_INT 51
5538: PUSH
5539: LD_INT 24
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: PUSH
5546: LD_INT 75
5548: PUSH
5549: LD_INT 90
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5560: LD_INT 1
5562: PPUSH
5563: LD_VAR 0 3
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PPUSH
5572: LD_VAR 0 5
5576: PPUSH
5577: LD_VAR 0 6
5581: PPUSH
5582: CALL 42338 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5586: LD_ADDR_VAR 0 1
5590: PUSH
5591: DOUBLE
5592: LD_INT 1
5594: DEC
5595: ST_TO_ADDR
5596: LD_INT 1
5598: PUSH
5599: LD_INT 3
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: LD_INT 3
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_OWVAR 67
5618: ARRAY
5619: PUSH
5620: FOR_TO
5621: IFFALSE 5721
// begin uc_side := 2 ;
5623: LD_ADDR_OWVAR 20
5627: PUSH
5628: LD_INT 2
5630: ST_TO_ADDR
// uc_nation := 2 ;
5631: LD_ADDR_OWVAR 21
5635: PUSH
5636: LD_INT 2
5638: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5639: LD_INT 0
5641: PPUSH
5642: LD_INT 17
5644: PPUSH
5645: LD_VAR 0 4
5649: PPUSH
5650: CALL_OW 380
// un := CreateHuman ;
5654: LD_ADDR_VAR 0 2
5658: PUSH
5659: CALL_OW 44
5663: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5664: LD_ADDR_VAR 0 3
5668: PUSH
5669: LD_VAR 0 3
5673: PPUSH
5674: LD_INT 2
5676: PUSH
5677: LD_VAR 0 3
5681: PUSH
5682: LD_INT 2
5684: ARRAY
5685: PUSH
5686: LD_INT 1
5688: PLUS
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: PPUSH
5694: LD_VAR 0 2
5698: PPUSH
5699: CALL 53678 0 3
5703: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5704: LD_VAR 0 2
5708: PPUSH
5709: LD_INT 13
5711: PPUSH
5712: LD_INT 0
5714: PPUSH
5715: CALL_OW 49
// end ;
5719: GO 5620
5721: POP
5722: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5723: LD_ADDR_VAR 0 1
5727: PUSH
5728: DOUBLE
5729: LD_INT 1
5731: DEC
5732: ST_TO_ADDR
5733: LD_INT 3
5735: PUSH
5736: LD_INT 4
5738: PUSH
5739: LD_INT 4
5741: PUSH
5742: LD_INT 4
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: ARRAY
5756: PUSH
5757: FOR_TO
5758: IFFALSE 5879
// begin uc_side := 2 ;
5760: LD_ADDR_OWVAR 20
5764: PUSH
5765: LD_INT 2
5767: ST_TO_ADDR
// uc_nation := 2 ;
5768: LD_ADDR_OWVAR 21
5772: PUSH
5773: LD_INT 2
5775: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5776: LD_INT 0
5778: PPUSH
5779: LD_INT 1
5781: PUSH
5782: LD_INT 8
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: LD_VAR 0 1
5793: PUSH
5794: LD_INT 2
5796: MOD
5797: PUSH
5798: LD_INT 1
5800: PLUS
5801: ARRAY
5802: PPUSH
5803: LD_VAR 0 4
5807: PPUSH
5808: CALL_OW 380
// un := CreateHuman ;
5812: LD_ADDR_VAR 0 2
5816: PUSH
5817: CALL_OW 44
5821: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5822: LD_ADDR_VAR 0 3
5826: PUSH
5827: LD_VAR 0 3
5831: PPUSH
5832: LD_INT 2
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_INT 2
5842: ARRAY
5843: PUSH
5844: LD_INT 1
5846: PLUS
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: LD_VAR 0 2
5856: PPUSH
5857: CALL 53678 0 3
5861: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5862: LD_VAR 0 2
5866: PPUSH
5867: LD_INT 13
5869: PPUSH
5870: LD_INT 0
5872: PPUSH
5873: CALL_OW 49
// end ;
5877: GO 5757
5879: POP
5880: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5881: LD_ADDR_VAR 0 5
5885: PUSH
5886: LD_INT 67
5888: PUSH
5889: LD_INT 112
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: LD_INT 85
5898: PUSH
5899: LD_INT 130
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5910: LD_INT 2
5912: PPUSH
5913: LD_VAR 0 3
5917: PUSH
5918: LD_INT 2
5920: ARRAY
5921: PPUSH
5922: LD_VAR 0 5
5926: PPUSH
5927: LD_VAR 0 6
5931: PPUSH
5932: CALL 42338 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5936: LD_ADDR_VAR 0 1
5940: PUSH
5941: DOUBLE
5942: LD_INT 1
5944: DEC
5945: ST_TO_ADDR
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 3
5954: PUSH
5955: LD_INT 4
5957: PUSH
5958: EMPTY
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: PUSH
5964: LD_OWVAR 67
5968: ARRAY
5969: PUSH
5970: FOR_TO
5971: IFFALSE 6071
// begin uc_side := 2 ;
5973: LD_ADDR_OWVAR 20
5977: PUSH
5978: LD_INT 2
5980: ST_TO_ADDR
// uc_nation := 2 ;
5981: LD_ADDR_OWVAR 21
5985: PUSH
5986: LD_INT 2
5988: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5989: LD_INT 0
5991: PPUSH
5992: LD_INT 17
5994: PPUSH
5995: LD_VAR 0 4
5999: PPUSH
6000: CALL_OW 380
// un := CreateHuman ;
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: CALL_OW 44
6013: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6014: LD_ADDR_VAR 0 3
6018: PUSH
6019: LD_VAR 0 3
6023: PPUSH
6024: LD_INT 3
6026: PUSH
6027: LD_VAR 0 3
6031: PUSH
6032: LD_INT 3
6034: ARRAY
6035: PUSH
6036: LD_INT 1
6038: PLUS
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PPUSH
6044: LD_VAR 0 2
6048: PPUSH
6049: CALL 53678 0 3
6053: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 14
6061: PPUSH
6062: LD_INT 0
6064: PPUSH
6065: CALL_OW 49
// end ;
6069: GO 5970
6071: POP
6072: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6073: LD_ADDR_VAR 0 5
6077: PUSH
6078: LD_INT 148
6080: PUSH
6081: LD_INT 158
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: PUSH
6088: LD_INT 148
6090: PUSH
6091: LD_INT 158
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6102: LD_INT 3
6104: PPUSH
6105: LD_VAR 0 3
6109: PUSH
6110: LD_INT 3
6112: ARRAY
6113: PPUSH
6114: LD_VAR 0 5
6118: PPUSH
6119: LD_VAR 0 6
6123: PPUSH
6124: CALL 42338 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: DOUBLE
6134: LD_INT 1
6136: DEC
6137: ST_TO_ADDR
6138: LD_INT 2
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 4
6146: PUSH
6147: LD_INT 4
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_OWVAR 67
6160: ARRAY
6161: PUSH
6162: FOR_TO
6163: IFFALSE 6387
// begin uc_side := 2 ;
6165: LD_ADDR_OWVAR 20
6169: PUSH
6170: LD_INT 2
6172: ST_TO_ADDR
// uc_nation := 2 ;
6173: LD_ADDR_OWVAR 21
6177: PUSH
6178: LD_INT 2
6180: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6181: LD_INT 14
6183: PPUSH
6184: LD_INT 3
6186: PPUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 5
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 1
6199: PPUSH
6200: LD_INT 2
6202: PPUSH
6203: CALL_OW 12
6207: ARRAY
6208: PPUSH
6209: LD_INT 27
6211: PUSH
6212: LD_INT 26
6214: PUSH
6215: LD_INT 28
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: LIST
6222: PUSH
6223: LD_INT 1
6225: PPUSH
6226: LD_INT 3
6228: PPUSH
6229: CALL_OW 12
6233: ARRAY
6234: PPUSH
6235: LD_INT 100
6237: PPUSH
6238: CALL 53556 0 5
// un := CreateVehicle ;
6242: LD_ADDR_VAR 0 2
6246: PUSH
6247: CALL_OW 45
6251: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6252: LD_ADDR_VAR 0 3
6256: PUSH
6257: LD_VAR 0 3
6261: PPUSH
6262: LD_INT 4
6264: PUSH
6265: LD_VAR 0 3
6269: PUSH
6270: LD_INT 4
6272: ARRAY
6273: PUSH
6274: LD_INT 1
6276: PLUS
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PPUSH
6282: LD_VAR 0 2
6286: PPUSH
6287: CALL 53678 0 3
6291: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6292: LD_VAR 0 2
6296: PPUSH
6297: LD_INT 5
6299: PPUSH
6300: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6304: LD_VAR 0 2
6308: PPUSH
6309: LD_INT 15
6311: PPUSH
6312: LD_INT 0
6314: PPUSH
6315: CALL_OW 49
// if GetControl ( un ) = control_manual then
6319: LD_VAR 0 2
6323: PPUSH
6324: CALL_OW 263
6328: PUSH
6329: LD_INT 1
6331: EQUAL
6332: IFFALSE 6363
// begin PrepareHuman ( false , 3 , skill ) ;
6334: LD_INT 0
6336: PPUSH
6337: LD_INT 3
6339: PPUSH
6340: LD_VAR 0 4
6344: PPUSH
6345: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6349: CALL_OW 44
6353: PPUSH
6354: LD_VAR 0 2
6358: PPUSH
6359: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6363: LD_VAR 0 2
6367: PPUSH
6368: LD_INT 179
6370: PPUSH
6371: LD_INT 135
6373: PPUSH
6374: CALL_OW 111
// wait ( 0 0$2 ) ;
6378: LD_INT 70
6380: PPUSH
6381: CALL_OW 67
// end ;
6385: GO 6162
6387: POP
6388: POP
// vc_chassis := 15 ;
6389: LD_ADDR_OWVAR 37
6393: PUSH
6394: LD_INT 15
6396: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6397: LD_ADDR_VAR 0 3
6401: PUSH
6402: LD_VAR 0 3
6406: PPUSH
6407: LD_INT 4
6409: PUSH
6410: LD_VAR 0 3
6414: PUSH
6415: LD_INT 4
6417: ARRAY
6418: PUSH
6419: LD_INT 1
6421: PLUS
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PPUSH
6427: CALL_OW 45
6431: PPUSH
6432: CALL 53678 0 3
6436: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6437: LD_VAR 0 3
6441: PUSH
6442: LD_INT 4
6444: ARRAY
6445: PUSH
6446: LD_VAR 0 3
6450: PUSH
6451: LD_INT 4
6453: ARRAY
6454: ARRAY
6455: PPUSH
6456: LD_INT 15
6458: PPUSH
6459: LD_INT 0
6461: PPUSH
6462: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6466: LD_INT 0
6468: PPUSH
6469: LD_INT 11
6471: PPUSH
6472: LD_VAR 0 4
6476: PPUSH
6477: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6481: LD_ADDR_VAR 0 3
6485: PUSH
6486: LD_VAR 0 3
6490: PPUSH
6491: LD_INT 4
6493: PUSH
6494: LD_VAR 0 3
6498: PUSH
6499: LD_INT 4
6501: ARRAY
6502: PUSH
6503: LD_INT 1
6505: PLUS
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PPUSH
6511: CALL_OW 44
6515: PPUSH
6516: CALL 53678 0 3
6520: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6521: LD_VAR 0 3
6525: PUSH
6526: LD_INT 4
6528: ARRAY
6529: PUSH
6530: LD_VAR 0 3
6534: PUSH
6535: LD_INT 4
6537: ARRAY
6538: ARRAY
6539: PPUSH
6540: LD_VAR 0 3
6544: PUSH
6545: LD_INT 4
6547: ARRAY
6548: PUSH
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 4
6556: ARRAY
6557: PUSH
6558: LD_INT 1
6560: MINUS
6561: ARRAY
6562: PPUSH
6563: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6567: LD_ADDR_VAR 0 5
6571: PUSH
6572: LD_INT 148
6574: PUSH
6575: LD_INT 140
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: PUSH
6582: EMPTY
6583: LIST
6584: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6585: LD_INT 1
6587: PPUSH
6588: LD_VAR 0 3
6592: PUSH
6593: LD_INT 4
6595: ARRAY
6596: PPUSH
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 6
6606: PPUSH
6607: CALL 42338 0 4
// if gensher_active then
6611: LD_EXP 18
6615: IFFALSE 7021
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6617: LD_EXP 45
6621: PPUSH
6622: LD_STRING D10-Diet-1
6624: PPUSH
6625: CALL_OW 94
// for i = 1 to 2 do
6629: LD_ADDR_VAR 0 1
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_INT 2
6641: PUSH
6642: FOR_TO
6643: IFFALSE 6781
// begin uc_side := 2 ;
6645: LD_ADDR_OWVAR 20
6649: PUSH
6650: LD_INT 2
6652: ST_TO_ADDR
// uc_nation := 2 ;
6653: LD_ADDR_OWVAR 21
6657: PUSH
6658: LD_INT 2
6660: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6661: LD_INT 13
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: LD_INT 5
6669: PPUSH
6670: LD_INT 29
6672: PPUSH
6673: LD_INT 100
6675: PPUSH
6676: CALL 53556 0 5
// un := CreateVehicle ;
6680: LD_ADDR_VAR 0 2
6684: PUSH
6685: CALL_OW 45
6689: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6690: LD_ADDR_VAR 0 3
6694: PUSH
6695: LD_VAR 0 3
6699: PPUSH
6700: LD_INT 5
6702: PUSH
6703: LD_VAR 0 3
6707: PUSH
6708: LD_INT 5
6710: ARRAY
6711: PUSH
6712: LD_INT 1
6714: PLUS
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: PPUSH
6720: LD_VAR 0 2
6724: PPUSH
6725: CALL 53678 0 3
6729: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6730: LD_VAR 0 2
6734: PPUSH
6735: LD_INT 0
6737: PPUSH
6738: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6742: LD_VAR 0 2
6746: PPUSH
6747: LD_INT 23
6749: PPUSH
6750: LD_INT 0
6752: PPUSH
6753: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6757: LD_VAR 0 2
6761: PPUSH
6762: LD_INT 85
6764: PPUSH
6765: LD_INT 152
6767: PPUSH
6768: CALL_OW 111
// wait ( 0 0$2 ) ;
6772: LD_INT 70
6774: PPUSH
6775: CALL_OW 67
// end ;
6779: GO 6642
6781: POP
6782: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6783: LD_ADDR_VAR 0 1
6787: PUSH
6788: DOUBLE
6789: LD_INT 1
6791: DEC
6792: ST_TO_ADDR
6793: LD_INT 2
6795: PUSH
6796: LD_INT 3
6798: PUSH
6799: LD_INT 3
6801: PUSH
6802: LD_INT 4
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: LIST
6809: LIST
6810: PUSH
6811: LD_OWVAR 67
6815: ARRAY
6816: PUSH
6817: FOR_TO
6818: IFFALSE 6975
// begin uc_side := 2 ;
6820: LD_ADDR_OWVAR 20
6824: PUSH
6825: LD_INT 2
6827: ST_TO_ADDR
// uc_nation := 2 ;
6828: LD_ADDR_OWVAR 21
6832: PUSH
6833: LD_INT 2
6835: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6836: LD_INT 14
6838: PPUSH
6839: LD_INT 3
6841: PPUSH
6842: LD_INT 5
6844: PPUSH
6845: LD_INT 27
6847: PUSH
6848: LD_INT 28
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 1
6857: PPUSH
6858: LD_INT 2
6860: PPUSH
6861: CALL_OW 12
6865: ARRAY
6866: PPUSH
6867: LD_INT 100
6869: PPUSH
6870: CALL 53556 0 5
// un := CreateVehicle ;
6874: LD_ADDR_VAR 0 2
6878: PUSH
6879: CALL_OW 45
6883: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6884: LD_ADDR_VAR 0 3
6888: PUSH
6889: LD_VAR 0 3
6893: PPUSH
6894: LD_INT 5
6896: PUSH
6897: LD_VAR 0 3
6901: PUSH
6902: LD_INT 5
6904: ARRAY
6905: PUSH
6906: LD_INT 1
6908: PLUS
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PPUSH
6914: LD_VAR 0 2
6918: PPUSH
6919: CALL 53678 0 3
6923: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6924: LD_VAR 0 2
6928: PPUSH
6929: LD_INT 0
6931: PPUSH
6932: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6936: LD_VAR 0 2
6940: PPUSH
6941: LD_INT 23
6943: PPUSH
6944: LD_INT 0
6946: PPUSH
6947: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6951: LD_VAR 0 2
6955: PPUSH
6956: LD_INT 85
6958: PPUSH
6959: LD_INT 152
6961: PPUSH
6962: CALL_OW 111
// wait ( 0 0$2 ) ;
6966: LD_INT 70
6968: PPUSH
6969: CALL_OW 67
// end ;
6973: GO 6817
6975: POP
6976: POP
// coords := [ [ 97 , 143 ] ] ;
6977: LD_ADDR_VAR 0 5
6981: PUSH
6982: LD_INT 97
6984: PUSH
6985: LD_INT 143
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PUSH
6992: EMPTY
6993: LIST
6994: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6995: LD_INT 1
6997: PPUSH
6998: LD_VAR 0 3
7002: PUSH
7003: LD_INT 5
7005: ARRAY
7006: PPUSH
7007: LD_VAR 0 5
7011: PPUSH
7012: LD_VAR 0 6
7016: PPUSH
7017: CALL 42338 0 4
// end ; Wait ( 13 13$00 ) ;
7021: LD_INT 27300
7023: PPUSH
7024: CALL_OW 67
// tmp := [ ] ;
7028: LD_ADDR_VAR 0 3
7032: PUSH
7033: EMPTY
7034: ST_TO_ADDR
// w := 1 ;
7035: LD_ADDR_VAR 0 7
7039: PUSH
7040: LD_INT 1
7042: ST_TO_ADDR
// repeat tmp := [ ] ;
7043: LD_ADDR_VAR 0 3
7047: PUSH
7048: EMPTY
7049: ST_TO_ADDR
// if w mod 4 = 0 then
7050: LD_VAR 0 7
7054: PUSH
7055: LD_INT 4
7057: MOD
7058: PUSH
7059: LD_INT 0
7061: EQUAL
7062: IFFALSE 7149
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7064: LD_ADDR_VAR 0 8
7068: PUSH
7069: LD_INT 11
7071: PUSH
7072: LD_INT 1
7074: PUSH
7075: LD_INT 2
7077: PUSH
7078: LD_INT 24
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_INT 11
7089: PUSH
7090: LD_INT 1
7092: PUSH
7093: LD_INT 2
7095: PUSH
7096: LD_INT 24
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: LIST
7103: LIST
7104: PUSH
7105: LD_INT 11
7107: PUSH
7108: LD_INT 1
7110: PUSH
7111: LD_INT 2
7113: PUSH
7114: LD_INT 24
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 11
7125: PUSH
7126: LD_INT 1
7128: PUSH
7129: LD_INT 2
7131: PUSH
7132: LD_INT 24
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: ST_TO_ADDR
7147: GO 7251
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7149: LD_ADDR_VAR 0 8
7153: PUSH
7154: LD_INT 14
7156: PUSH
7157: LD_INT 1
7159: PUSH
7160: LD_INT 2
7162: PUSH
7163: LD_INT 28
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: PUSH
7172: LD_INT 14
7174: PUSH
7175: LD_INT 1
7177: PUSH
7178: LD_INT 2
7180: PUSH
7181: LD_INT 25
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: PUSH
7190: LD_INT 14
7192: PUSH
7193: LD_INT 1
7195: PUSH
7196: LD_INT 2
7198: PUSH
7199: LD_INT 28
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: LIST
7206: LIST
7207: PUSH
7208: LD_INT 14
7210: PUSH
7211: LD_INT 1
7213: PUSH
7214: LD_INT 2
7216: PUSH
7217: LD_INT 29
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: PUSH
7226: LD_INT 11
7228: PUSH
7229: LD_INT 1
7231: PUSH
7232: LD_INT 2
7234: PUSH
7235: LD_INT 24
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: LIST
7250: ST_TO_ADDR
// if w mod 3 = 0 then
7251: LD_VAR 0 7
7255: PUSH
7256: LD_INT 3
7258: MOD
7259: PUSH
7260: LD_INT 0
7262: EQUAL
7263: IFFALSE 7339
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7265: LD_ADDR_VAR 0 8
7269: PUSH
7270: LD_VAR 0 8
7274: PPUSH
7275: LD_INT 1
7277: PUSH
7278: LD_VAR 0 8
7282: PUSH
7283: LD_VAR 0 1
7287: ARRAY
7288: PUSH
7289: LD_INT 1
7291: PLUS
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PPUSH
7297: LD_INT 14
7299: PUSH
7300: LD_INT 1
7302: PUSH
7303: LD_INT 2
7305: PUSH
7306: LD_INT 25
7308: PUSH
7309: LD_INT 28
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 1
7318: PPUSH
7319: LD_INT 2
7321: PPUSH
7322: CALL_OW 12
7326: ARRAY
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PPUSH
7334: CALL 53678 0 3
7338: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7339: LD_INT 1
7341: PPUSH
7342: LD_VAR 0 8
7346: PPUSH
7347: CALL 42105 0 2
// if GetSide ( ar_dep_w ) = 2 then
7351: LD_INT 45
7353: PPUSH
7354: CALL_OW 255
7358: PUSH
7359: LD_INT 2
7361: EQUAL
7362: IFFALSE 7447
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7364: LD_ADDR_VAR 0 8
7368: PUSH
7369: LD_INT 14
7371: PUSH
7372: LD_INT 1
7374: PUSH
7375: LD_INT 2
7377: PUSH
7378: LD_INT 28
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: PUSH
7387: LD_INT 14
7389: PUSH
7390: LD_INT 1
7392: PUSH
7393: LD_INT 2
7395: PUSH
7396: LD_INT 27
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 14
7407: PUSH
7408: LD_INT 1
7410: PUSH
7411: LD_INT 2
7413: PUSH
7414: LD_INT 27
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: LIST
7421: LIST
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7428: LD_INT 2
7430: PPUSH
7431: LD_VAR 0 8
7435: PPUSH
7436: CALL 42105 0 2
// wait ( 0 0$50 ) ;
7440: LD_INT 1750
7442: PPUSH
7443: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7447: LD_INT 35
7449: PPUSH
7450: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7454: LD_EXP 69
7458: PUSH
7459: LD_INT 1
7461: ARRAY
7462: PPUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 2
7468: PUSH
7469: LD_INT 34
7471: PUSH
7472: LD_INT 32
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PUSH
7479: LD_INT 34
7481: PUSH
7482: LD_INT 88
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: LIST
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PPUSH
7498: CALL_OW 72
7502: PUSH
7503: LD_INT 4
7505: GREATEREQUAL
7506: IFFALSE 7447
// wait ( 0 0$10 ) ;
7508: LD_INT 350
7510: PPUSH
7511: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7515: LD_ADDR_VAR 0 3
7519: PUSH
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7569: LD_INT 100
7571: PPUSH
7572: CALL_OW 13
7576: PUSH
7577: LD_INT 50
7579: LESS
7580: IFFALSE 7613
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7582: LD_ADDR_VAR 0 5
7586: PUSH
7587: LD_INT 55
7589: PUSH
7590: LD_INT 7
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: PUSH
7597: LD_INT 75
7599: PUSH
7600: LD_INT 90
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: ST_TO_ADDR
7611: GO 7642
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7613: LD_ADDR_VAR 0 5
7617: PUSH
7618: LD_INT 128
7620: PUSH
7621: LD_INT 94
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 180
7630: PUSH
7631: LD_INT 135
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: ST_TO_ADDR
// if w mod 4 = 0 then
7642: LD_VAR 0 7
7646: PUSH
7647: LD_INT 4
7649: MOD
7650: PUSH
7651: LD_INT 0
7653: EQUAL
7654: IFFALSE 7685
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7656: LD_ADDR_VAR 0 5
7660: PUSH
7661: LD_INT 91
7663: PUSH
7664: LD_INT 58
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 117
7673: PUSH
7674: LD_INT 107
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_VAR 0 5
7694: PUSH
7695: LD_INT 1
7697: ARRAY
7698: PPUSH
7699: LD_VAR 0 5
7703: PUSH
7704: LD_INT 2
7706: ARRAY
7707: PPUSH
7708: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7712: LD_INT 35
7714: PPUSH
7715: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7719: LD_VAR 0 3
7723: PPUSH
7724: LD_INT 60
7726: PUSH
7727: EMPTY
7728: LIST
7729: PPUSH
7730: CALL_OW 72
7734: PUSH
7735: LD_INT 0
7737: EQUAL
7738: IFFALSE 7712
// repeat wait ( 0 0$2 ) ;
7740: LD_INT 70
7742: PPUSH
7743: CALL_OW 67
// for i in tmp do
7747: LD_ADDR_VAR 0 1
7751: PUSH
7752: LD_VAR 0 3
7756: PUSH
7757: FOR_IN
7758: IFFALSE 7847
// if GetChassis ( i ) = ar_hovercraft then
7760: LD_VAR 0 1
7764: PPUSH
7765: CALL_OW 265
7769: PUSH
7770: LD_INT 11
7772: EQUAL
7773: IFFALSE 7811
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7775: LD_VAR 0 1
7779: PPUSH
7780: LD_INT 22
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: PPUSH
7795: LD_VAR 0 1
7799: PPUSH
7800: CALL_OW 74
7804: PPUSH
7805: CALL 81551 0 2
7809: GO 7845
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7811: LD_VAR 0 1
7815: PPUSH
7816: LD_INT 22
7818: PUSH
7819: LD_INT 1
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PPUSH
7826: CALL_OW 69
7830: PPUSH
7831: LD_VAR 0 1
7835: PPUSH
7836: CALL_OW 74
7840: PPUSH
7841: CALL_OW 115
7845: GO 7757
7847: POP
7848: POP
// until not tmp ;
7849: LD_VAR 0 3
7853: NOT
7854: IFFALSE 7740
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7856: LD_INT 22050
7858: PPUSH
7859: LD_INT 28350
7861: PPUSH
7862: CALL_OW 12
7866: PPUSH
7867: CALL_OW 67
// w := w + 1 ;
7871: LD_ADDR_VAR 0 7
7875: PUSH
7876: LD_VAR 0 7
7880: PUSH
7881: LD_INT 1
7883: PLUS
7884: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7885: LD_INT 94
7887: PPUSH
7888: CALL_OW 301
7892: PUSH
7893: LD_EXP 50
7897: PUSH
7898: LD_INT 1
7900: ARRAY
7901: PPUSH
7902: LD_INT 30
7904: PUSH
7905: LD_INT 3
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 72
7916: NOT
7917: OR
7918: IFFALSE 7043
// end ;
7920: PPOPN 8
7922: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7923: LD_INT 204
7925: IFFALSE 8391
7927: GO 7929
7929: DISABLE
7930: LD_INT 0
7932: PPUSH
7933: PPUSH
7934: PPUSH
7935: PPUSH
// begin enable ;
7936: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7937: LD_INT 35
7939: PPUSH
7940: LD_INT 1190
7942: PPUSH
7943: CALL_OW 12
7947: PPUSH
7948: CALL_OW 67
// tmp := [ ] ;
7952: LD_ADDR_VAR 0 2
7956: PUSH
7957: EMPTY
7958: ST_TO_ADDR
// uc_side := 8 ;
7959: LD_ADDR_OWVAR 20
7963: PUSH
7964: LD_INT 8
7966: ST_TO_ADDR
// uc_nation := 2 ;
7967: LD_ADDR_OWVAR 21
7971: PUSH
7972: LD_INT 2
7974: ST_TO_ADDR
// InitHc ;
7975: CALL_OW 19
// for i = 1 to 3 do
7979: LD_ADDR_VAR 0 1
7983: PUSH
7984: DOUBLE
7985: LD_INT 1
7987: DEC
7988: ST_TO_ADDR
7989: LD_INT 3
7991: PUSH
7992: FOR_TO
7993: IFFALSE 8120
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7995: LD_INT 13
7997: PUSH
7998: LD_INT 14
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PUSH
8005: LD_INT 1
8007: PPUSH
8008: LD_INT 2
8010: PPUSH
8011: CALL_OW 12
8015: ARRAY
8016: PPUSH
8017: LD_INT 3
8019: PPUSH
8020: LD_INT 5
8022: PPUSH
8023: LD_INT 27
8025: PUSH
8026: LD_INT 28
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 1
8035: PPUSH
8036: LD_INT 2
8038: PPUSH
8039: CALL_OW 12
8043: ARRAY
8044: PPUSH
8045: LD_INT 100
8047: PPUSH
8048: CALL 53556 0 5
// un := CreateVehicle ;
8052: LD_ADDR_VAR 0 3
8056: PUSH
8057: CALL_OW 45
8061: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8062: LD_VAR 0 3
8066: PPUSH
8067: LD_INT 4
8069: PPUSH
8070: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8074: LD_VAR 0 3
8078: PPUSH
8079: LD_INT 15
8081: PPUSH
8082: LD_INT 0
8084: PPUSH
8085: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8089: LD_ADDR_VAR 0 2
8093: PUSH
8094: LD_VAR 0 2
8098: PPUSH
8099: LD_VAR 0 2
8103: PUSH
8104: LD_INT 1
8106: PLUS
8107: PPUSH
8108: LD_VAR 0 3
8112: PPUSH
8113: CALL_OW 1
8117: ST_TO_ADDR
// end ;
8118: GO 7992
8120: POP
8121: POP
// for i = 1 to 4 do
8122: LD_ADDR_VAR 0 1
8126: PUSH
8127: DOUBLE
8128: LD_INT 1
8130: DEC
8131: ST_TO_ADDR
8132: LD_INT 4
8134: PUSH
8135: FOR_TO
8136: IFFALSE 8207
// begin PrepareHuman ( false , 1 , 6 ) ;
8138: LD_INT 0
8140: PPUSH
8141: LD_INT 1
8143: PPUSH
8144: LD_INT 6
8146: PPUSH
8147: CALL_OW 380
// un := CreateHuman ;
8151: LD_ADDR_VAR 0 3
8155: PUSH
8156: CALL_OW 44
8160: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8161: LD_VAR 0 3
8165: PPUSH
8166: LD_INT 15
8168: PPUSH
8169: LD_INT 0
8171: PPUSH
8172: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8176: LD_ADDR_VAR 0 2
8180: PUSH
8181: LD_VAR 0 2
8185: PPUSH
8186: LD_VAR 0 2
8190: PUSH
8191: LD_INT 1
8193: PLUS
8194: PPUSH
8195: LD_VAR 0 3
8199: PPUSH
8200: CALL_OW 1
8204: ST_TO_ADDR
// end ;
8205: GO 8135
8207: POP
8208: POP
// wait ( 0 0$3 ) ;
8209: LD_INT 105
8211: PPUSH
8212: CALL_OW 67
// for i in tmp do
8216: LD_ADDR_VAR 0 1
8220: PUSH
8221: LD_VAR 0 2
8225: PUSH
8226: FOR_IN
8227: IFFALSE 8295
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 257
8238: PUSH
8239: LD_INT 1
8241: EQUAL
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 247
8252: PUSH
8253: LD_INT 2
8255: EQUAL
8256: OR
8257: IFFALSE 8293
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8259: LD_VAR 0 1
8263: PPUSH
8264: LD_INT 81
8266: PUSH
8267: LD_INT 8
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: PPUSH
8274: CALL_OW 69
8278: PPUSH
8279: LD_VAR 0 1
8283: PPUSH
8284: CALL_OW 74
8288: PPUSH
8289: CALL_OW 115
8293: GO 8226
8295: POP
8296: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8297: LD_VAR 0 2
8301: PPUSH
8302: LD_INT 210
8304: PPUSH
8305: LD_INT 178
8307: PPUSH
8308: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 10
8319: PPUSH
8320: LD_INT 22
8322: PUSH
8323: LD_INT 8
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PPUSH
8330: CALL_OW 70
8334: ST_TO_ADDR
// if x then
8335: LD_VAR 0 4
8339: IFFALSE 8367
// for i in x do
8341: LD_ADDR_VAR 0 1
8345: PUSH
8346: LD_VAR 0 4
8350: PUSH
8351: FOR_IN
8352: IFFALSE 8365
// RemoveUnit ( i ) ;
8354: LD_VAR 0 1
8358: PPUSH
8359: CALL_OW 64
8363: GO 8351
8365: POP
8366: POP
// wait ( 0 0$1 ) ;
8367: LD_INT 35
8369: PPUSH
8370: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8374: LD_INT 22
8376: PUSH
8377: LD_INT 8
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 69
8388: NOT
8389: IFFALSE 8297
// end ;
8391: PPOPN 4
8393: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8394: LD_INT 22
8396: PUSH
8397: LD_INT 2
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PUSH
8404: LD_INT 34
8406: PUSH
8407: LD_INT 31
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 3
8416: PUSH
8417: LD_INT 24
8419: PUSH
8420: LD_INT 1000
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: IFFALSE 8543
8442: GO 8444
8444: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8445: LD_INT 45
8447: PPUSH
8448: CALL_OW 302
8452: PUSH
8453: LD_INT 45
8455: PPUSH
8456: CALL_OW 255
8460: AND
8461: IFFALSE 8504
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8463: LD_INT 22
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 34
8475: PUSH
8476: LD_INT 31
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PPUSH
8487: CALL_OW 69
8491: PPUSH
8492: LD_INT 18
8494: PPUSH
8495: LD_INT 8
8497: PPUSH
8498: CALL_OW 111
8502: GO 8543
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8504: LD_INT 22
8506: PUSH
8507: LD_INT 2
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 34
8516: PUSH
8517: LD_INT 31
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PPUSH
8528: CALL_OW 69
8532: PPUSH
8533: LD_INT 106
8535: PPUSH
8536: LD_INT 14
8538: PPUSH
8539: CALL_OW 111
// end ; end_of_file
8543: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8544: LD_INT 0
8546: PPUSH
8547: PPUSH
8548: PPUSH
8549: PPUSH
8550: PPUSH
8551: PPUSH
// InGameOn ;
8552: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8556: LD_EXP 21
8560: PPUSH
8561: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8565: LD_INT 2
8567: PPUSH
8568: LD_INT 1
8570: PPUSH
8571: LD_INT 1
8573: PPUSH
8574: LD_INT 1
8576: PPUSH
8577: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8581: LD_ADDR_VAR 0 2
8585: PUSH
8586: LD_INT 22
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PUSH
8596: LD_INT 25
8598: PUSH
8599: LD_INT 1
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PPUSH
8610: CALL_OW 69
8614: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8615: LD_ADDR_VAR 0 4
8619: PUSH
8620: LD_INT 22
8622: PUSH
8623: LD_INT 1
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 34
8632: PUSH
8633: LD_INT 11
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 69
8648: PUSH
8649: LD_INT 1
8651: ARRAY
8652: ST_TO_ADDR
// for i = 1 to tmp do
8653: LD_ADDR_VAR 0 6
8657: PUSH
8658: DOUBLE
8659: LD_INT 1
8661: DEC
8662: ST_TO_ADDR
8663: LD_VAR 0 2
8667: PUSH
8668: FOR_TO
8669: IFFALSE 8716
// begin if i = 5 then
8671: LD_VAR 0 6
8675: PUSH
8676: LD_INT 5
8678: EQUAL
8679: IFFALSE 8683
// break ;
8681: GO 8716
// sols := Replace ( sols , i , tmp [ i ] ) ;
8683: LD_ADDR_VAR 0 5
8687: PUSH
8688: LD_VAR 0 5
8692: PPUSH
8693: LD_VAR 0 6
8697: PPUSH
8698: LD_VAR 0 2
8702: PUSH
8703: LD_VAR 0 6
8707: ARRAY
8708: PPUSH
8709: CALL_OW 1
8713: ST_TO_ADDR
// end ;
8714: GO 8668
8716: POP
8717: POP
// tmp := ar_force_tmp ;
8718: LD_ADDR_VAR 0 2
8722: PUSH
8723: LD_EXP 40
8727: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8728: LD_VAR 0 2
8732: PUSH
8733: LD_INT 1
8735: ARRAY
8736: PPUSH
8737: LD_INT 108
8739: PPUSH
8740: LD_INT 139
8742: PPUSH
8743: LD_INT 0
8745: PPUSH
8746: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8750: LD_VAR 0 2
8754: PUSH
8755: LD_INT 1
8757: ARRAY
8758: PPUSH
8759: LD_EXP 21
8763: PPUSH
8764: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8768: LD_VAR 0 2
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: PPUSH
8777: LD_INT 114
8779: PPUSH
8780: LD_INT 132
8782: PPUSH
8783: LD_INT 0
8785: PPUSH
8786: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8790: LD_VAR 0 2
8794: PUSH
8795: LD_INT 3
8797: ARRAY
8798: PPUSH
8799: LD_INT 115
8801: PPUSH
8802: LD_INT 132
8804: PPUSH
8805: LD_INT 0
8807: PPUSH
8808: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8812: LD_VAR 0 2
8816: PUSH
8817: LD_INT 2
8819: ARRAY
8820: PUSH
8821: LD_VAR 0 2
8825: PUSH
8826: LD_INT 3
8828: ARRAY
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8838: LD_VAR 0 4
8842: PPUSH
8843: LD_INT 83
8845: PPUSH
8846: LD_INT 123
8848: PPUSH
8849: CALL_OW 111
// Wait ( 0 0$01 ) ;
8853: LD_INT 35
8855: PPUSH
8856: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8860: LD_INT 90
8862: PPUSH
8863: LD_INT 144
8865: PPUSH
8866: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8870: LD_VAR 0 5
8874: PPUSH
8875: LD_INT 88
8877: PPUSH
8878: LD_INT 129
8880: PPUSH
8881: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_INT 92
8892: PUSH
8893: LD_INT 131
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: LD_INT 88
8902: PUSH
8903: LD_INT 127
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: LD_INT 91
8912: PUSH
8913: LD_INT 132
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PUSH
8920: LD_INT 92
8922: PUSH
8923: LD_INT 134
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: ST_TO_ADDR
// for i = 1 to sols do
8936: LD_ADDR_VAR 0 6
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_VAR 0 5
8950: PUSH
8951: FOR_TO
8952: IFFALSE 9025
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8954: LD_VAR 0 5
8958: PUSH
8959: LD_VAR 0 6
8963: ARRAY
8964: PPUSH
8965: LD_VAR 0 3
8969: PUSH
8970: LD_VAR 0 6
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 2
8993: ARRAY
8994: PPUSH
8995: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8999: LD_VAR 0 5
9003: PUSH
9004: LD_VAR 0 6
9008: ARRAY
9009: PPUSH
9010: CALL_OW 197
// AddComHold ( sols ) ;
9014: LD_VAR 0 5
9018: PPUSH
9019: CALL_OW 200
// end ;
9023: GO 8951
9025: POP
9026: POP
// repeat wait ( 0 0$1 ) ;
9027: LD_INT 35
9029: PPUSH
9030: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9034: LD_VAR 0 5
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 92
9045: PPUSH
9046: LD_INT 131
9048: PPUSH
9049: CALL_OW 297
9053: PUSH
9054: LD_INT 4
9056: LESS
9057: IFFALSE 9027
// CenterOnXY ( 96 , 139 ) ;
9059: LD_INT 96
9061: PPUSH
9062: LD_INT 139
9064: PPUSH
9065: CALL_OW 84
// wait ( 0 0$3 ) ;
9069: LD_INT 105
9071: PPUSH
9072: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9076: LD_INT 111
9078: PPUSH
9079: LD_INT 135
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: LD_INT 25
9087: NEG
9088: PPUSH
9089: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9093: LD_VAR 0 2
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_VAR 0 2
9106: PUSH
9107: LD_INT 1
9109: ARRAY
9110: PPUSH
9111: CALL_OW 250
9115: PUSH
9116: LD_INT 3
9118: PLUS
9119: PPUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_INT 1
9127: ARRAY
9128: PPUSH
9129: CALL_OW 251
9133: PPUSH
9134: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9138: LD_VAR 0 2
9142: PUSH
9143: LD_INT 3
9145: ARRAY
9146: PPUSH
9147: LD_INT 7
9149: PPUSH
9150: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9154: LD_VAR 0 2
9158: PUSH
9159: LD_INT 2
9161: ARRAY
9162: PPUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_INT 1
9170: ARRAY
9171: PPUSH
9172: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9176: LD_INT 35
9178: PPUSH
9179: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9183: LD_VAR 0 2
9187: PUSH
9188: LD_INT 1
9190: ARRAY
9191: PPUSH
9192: LD_VAR 0 2
9196: PUSH
9197: LD_INT 2
9199: ARRAY
9200: PPUSH
9201: CALL_OW 296
9205: PUSH
9206: LD_INT 5
9208: LESS
9209: IFFALSE 9176
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9211: LD_VAR 0 2
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 2
9224: PUSH
9225: LD_INT 2
9227: ARRAY
9228: PPUSH
9229: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9233: LD_VAR 0 2
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: LD_STRING D1a-Merc1-1
9244: PPUSH
9245: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9249: LD_VAR 0 2
9253: PUSH
9254: LD_INT 2
9256: ARRAY
9257: PPUSH
9258: LD_STRING D1a-FMerc2-1
9260: PPUSH
9261: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9265: LD_VAR 0 2
9269: PUSH
9270: LD_INT 2
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 2
9278: PUSH
9279: LD_INT 1
9281: ARRAY
9282: PPUSH
9283: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9287: LD_VAR 0 2
9291: PUSH
9292: LD_INT 1
9294: ARRAY
9295: PPUSH
9296: LD_INT 500
9298: PPUSH
9299: CALL_OW 234
// wait ( 0 0$2 ) ;
9303: LD_INT 70
9305: PPUSH
9306: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9310: LD_VAR 0 2
9314: PUSH
9315: LD_INT 1
9317: ARRAY
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9326: LD_INT 10
9328: PPUSH
9329: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9333: LD_VAR 0 2
9337: PUSH
9338: LD_INT 1
9340: ARRAY
9341: PPUSH
9342: LD_STRING D1a-Merc1-2
9344: PPUSH
9345: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9349: LD_INT 7
9351: PPUSH
9352: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9356: LD_VAR 0 2
9360: PUSH
9361: LD_INT 1
9363: ARRAY
9364: PPUSH
9365: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9369: LD_VAR 0 2
9373: PUSH
9374: LD_INT 2
9376: ARRAY
9377: PPUSH
9378: LD_INT 10
9380: PPUSH
9381: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9385: LD_VAR 0 2
9389: PUSH
9390: LD_INT 2
9392: ARRAY
9393: PPUSH
9394: LD_STRING D1a-FMerc2-2
9396: PPUSH
9397: CALL_OW 88
// wait ( 0 0$1 ) ;
9401: LD_INT 35
9403: PPUSH
9404: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9408: LD_INT 7
9410: PPUSH
9411: CALL_OW 85
// wait ( 0 0$2 ) ;
9415: LD_INT 70
9417: PPUSH
9418: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9422: LD_EXP 44
9426: PPUSH
9427: LD_STRING D1a-Saliba-1
9429: PPUSH
9430: CALL_OW 91
// KillUnit ( Saliba ) ;
9434: LD_EXP 44
9438: PPUSH
9439: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9443: LD_VAR 0 2
9447: PUSH
9448: LD_INT 3
9450: ARRAY
9451: PPUSH
9452: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9456: LD_EXP 21
9460: PPUSH
9461: CALL_OW 85
// wait ( 0 0$1 ) ;
9465: LD_INT 35
9467: PPUSH
9468: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9472: LD_VAR 0 5
9476: PPUSH
9477: LD_INT 88
9479: PPUSH
9480: LD_INT 141
9482: PPUSH
9483: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 70
9494: PPUSH
9495: CALL_OW 202
// wait ( 0 0$2 ) ;
9499: LD_INT 70
9501: PPUSH
9502: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9506: LD_INT 2
9508: PPUSH
9509: LD_INT 1
9511: PPUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 1
9517: PPUSH
9518: CALL_OW 80
// InGameOff ;
9522: CALL_OW 9
// ComWalk ( sols ) ;
9526: LD_VAR 0 5
9530: PPUSH
9531: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9535: LD_STRING M1
9537: PPUSH
9538: CALL_OW 337
// game_speed := 4 ;
9542: LD_ADDR_OWVAR 65
9546: PUSH
9547: LD_INT 4
9549: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9550: LD_INT 111
9552: PPUSH
9553: LD_INT 135
9555: PPUSH
9556: LD_INT 1
9558: PPUSH
9559: CALL_OW 331
// SaveForQuickRestart ;
9563: CALL_OW 22
// ar_run := true ;
9567: LD_ADDR_EXP 5
9571: PUSH
9572: LD_INT 1
9574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9575: LD_INT 35
9577: PPUSH
9578: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9582: LD_INT 22
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: LD_INT 91
9594: PUSH
9595: LD_INT 7
9597: PUSH
9598: LD_INT 10
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: LIST
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: PUSH
9615: LD_INT 7
9617: PPUSH
9618: CALL_OW 256
9622: PUSH
9623: LD_INT 999
9625: LESS
9626: OR
9627: IFFALSE 9575
// if GetSide ( ar_dep_s ) = 2 then
9629: LD_INT 7
9631: PPUSH
9632: CALL_OW 255
9636: PUSH
9637: LD_INT 2
9639: EQUAL
9640: IFFALSE 9652
// SetSide ( ar_dep_s , 1 ) ;
9642: LD_INT 7
9644: PPUSH
9645: LD_INT 1
9647: PPUSH
9648: CALL_OW 235
// end ;
9652: LD_VAR 0 1
9656: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9657: LD_EXP 5
9661: IFFALSE 10021
9663: GO 9665
9665: DISABLE
9666: LD_INT 0
9668: PPUSH
9669: PPUSH
9670: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_EXP 40
9680: PUSH
9681: LD_EXP 36
9685: PPUSH
9686: LD_INT 2
9688: PUSH
9689: LD_INT 21
9691: PUSH
9692: LD_INT 2
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: PUSH
9699: LD_INT 21
9701: PUSH
9702: LD_INT 1
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: PPUSH
9714: CALL_OW 72
9718: ADD
9719: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9720: LD_VAR 0 2
9724: PPUSH
9725: LD_INT 5
9727: PPUSH
9728: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9732: LD_INT 5
9734: PPUSH
9735: LD_INT 1
9737: PPUSH
9738: CALL_OW 343
// k := 1 ;
9742: LD_ADDR_VAR 0 3
9746: PUSH
9747: LD_INT 1
9749: ST_TO_ADDR
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 9846
// begin if IsInUnit ( i ) then
9763: LD_VAR 0 1
9767: PPUSH
9768: CALL_OW 310
9772: IFFALSE 9783
// ComExitBuilding ( i ) ;
9774: LD_VAR 0 1
9778: PPUSH
9779: CALL_OW 122
// if GetClass ( i ) = 3 then
9783: LD_VAR 0 1
9787: PPUSH
9788: CALL_OW 257
9792: PUSH
9793: LD_INT 3
9795: EQUAL
9796: IFFALSE 9832
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9798: LD_VAR 0 1
9802: PPUSH
9803: LD_EXP 41
9807: PUSH
9808: LD_VAR 0 3
9812: ARRAY
9813: PPUSH
9814: CALL_OW 180
// k := k + 1 ;
9818: LD_ADDR_VAR 0 3
9822: PUSH
9823: LD_VAR 0 3
9827: PUSH
9828: LD_INT 1
9830: PLUS
9831: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9832: LD_VAR 0 1
9836: PPUSH
9837: LD_INT 10
9839: PPUSH
9840: CALL_OW 173
// end ;
9844: GO 9760
9846: POP
9847: POP
// ar_patrol := true ;
9848: LD_ADDR_EXP 7
9852: PUSH
9853: LD_INT 1
9855: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9856: LD_INT 10
9858: PPUSH
9859: CALL_OW 67
// for i in tmp do
9863: LD_ADDR_VAR 0 1
9867: PUSH
9868: LD_VAR 0 2
9872: PUSH
9873: FOR_IN
9874: IFFALSE 9902
// if not HasTask ( i ) then
9876: LD_VAR 0 1
9880: PPUSH
9881: CALL_OW 314
9885: NOT
9886: IFFALSE 9900
// ComMoveToArea ( i , escape_area ) ;
9888: LD_VAR 0 1
9892: PPUSH
9893: LD_INT 10
9895: PPUSH
9896: CALL_OW 113
9900: GO 9873
9902: POP
9903: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9904: LD_ADDR_VAR 0 3
9908: PUSH
9909: LD_VAR 0 2
9913: PPUSH
9914: LD_INT 95
9916: PUSH
9917: LD_INT 10
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PPUSH
9924: CALL_OW 72
9928: ST_TO_ADDR
// if k then
9929: LD_VAR 0 3
9933: IFFALSE 10002
// for i in k do
9935: LD_ADDR_VAR 0 1
9939: PUSH
9940: LD_VAR 0 3
9944: PUSH
9945: FOR_IN
9946: IFFALSE 10000
// begin if IsInUnit ( i ) then
9948: LD_VAR 0 1
9952: PPUSH
9953: CALL_OW 310
9957: IFFALSE 9973
// RemoveUnit ( IsInUnit ( i ) ) ;
9959: LD_VAR 0 1
9963: PPUSH
9964: CALL_OW 310
9968: PPUSH
9969: CALL_OW 64
// RemoveUnit ( i ) ;
9973: LD_VAR 0 1
9977: PPUSH
9978: CALL_OW 64
// tmp := tmp diff i ;
9982: LD_ADDR_VAR 0 2
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_VAR 0 1
9996: DIFF
9997: ST_TO_ADDR
// end ;
9998: GO 9945
10000: POP
10001: POP
// until tmp = [ ] ;
10002: LD_VAR 0 2
10006: PUSH
10007: EMPTY
10008: EQUAL
10009: IFFALSE 9856
// ChangeSideFog ( 5 , 5 ) ;
10011: LD_INT 5
10013: PPUSH
10014: LD_INT 5
10016: PPUSH
10017: CALL_OW 343
// end ;
10021: PPOPN 3
10023: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10024: LD_EXP 7
10028: IFFALSE 10318
10030: GO 10032
10032: DISABLE
10033: LD_INT 0
10035: PPUSH
10036: PPUSH
10037: PPUSH
// begin uc_side := 2 ;
10038: LD_ADDR_OWVAR 20
10042: PUSH
10043: LD_INT 2
10045: ST_TO_ADDR
// uc_nation := 2 ;
10046: LD_ADDR_OWVAR 21
10050: PUSH
10051: LD_INT 2
10053: ST_TO_ADDR
// InitHc ;
10054: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10058: LD_INT 1
10060: PPUSH
10061: LD_INT 1
10063: PPUSH
10064: LD_INT 6
10066: PPUSH
10067: CALL_OW 380
// un := CreateHuman ;
10071: LD_ADDR_VAR 0 2
10075: PUSH
10076: CALL_OW 44
10080: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10081: LD_INT 14
10083: PPUSH
10084: LD_INT 1
10086: PPUSH
10087: LD_INT 1
10089: PPUSH
10090: LD_INT 27
10092: PPUSH
10093: LD_INT 98
10095: PPUSH
10096: CALL 53556 0 5
// veh := CreateVehicle ;
10100: LD_ADDR_VAR 0 3
10104: PUSH
10105: CALL_OW 45
10109: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10110: LD_VAR 0 3
10114: PPUSH
10115: LD_INT 4
10117: PPUSH
10118: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10122: LD_VAR 0 3
10126: PPUSH
10127: LD_INT 179
10129: PPUSH
10130: LD_INT 135
10132: PPUSH
10133: LD_INT 0
10135: PPUSH
10136: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10140: LD_VAR 0 2
10144: PPUSH
10145: LD_VAR 0 3
10149: PPUSH
10150: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: LD_INT 126
10161: PPUSH
10162: LD_INT 133
10164: PPUSH
10165: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10169: LD_INT 10
10171: PPUSH
10172: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10176: LD_INT 1
10178: PPUSH
10179: LD_VAR 0 3
10183: PPUSH
10184: CALL_OW 292
10188: PUSH
10189: LD_VAR 0 3
10193: PPUSH
10194: LD_INT 7
10196: PPUSH
10197: CALL_OW 296
10201: PUSH
10202: LD_INT 9
10204: LESS
10205: OR
10206: IFFALSE 10169
// ComHold ( veh ) ;
10208: LD_VAR 0 3
10212: PPUSH
10213: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10217: LD_VAR 0 2
10221: PPUSH
10222: LD_STRING D2aa-Ar1-1
10224: PPUSH
10225: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10229: LD_VAR 0 2
10233: PPUSH
10234: LD_INT 177
10236: PPUSH
10237: LD_INT 96
10239: PPUSH
10240: CALL_OW 111
// AddComExitVehicle ( un ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10253: LD_INT 35
10255: PPUSH
10256: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10260: LD_VAR 0 2
10264: PPUSH
10265: LD_INT 204
10267: PPUSH
10268: CALL_OW 296
10272: PUSH
10273: LD_INT 15
10275: LESS
10276: IFFALSE 10253
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10278: LD_ADDR_EXP 50
10282: PUSH
10283: LD_EXP 50
10287: PPUSH
10288: LD_INT 3
10290: PUSH
10291: LD_EXP 50
10295: PUSH
10296: LD_INT 3
10298: ARRAY
10299: PUSH
10300: LD_INT 1
10302: PLUS
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PPUSH
10308: LD_VAR 0 2
10312: PPUSH
10313: CALL 53678 0 3
10317: ST_TO_ADDR
// end ;
10318: PPOPN 3
10320: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10321: LD_INT 7
10323: PPUSH
10324: CALL_OW 255
10328: PUSH
10329: LD_INT 1
10331: EQUAL
10332: PUSH
10333: LD_INT 7
10335: PPUSH
10336: CALL_OW 301
10340: OR
10341: IFFALSE 12749
10343: GO 10345
10345: DISABLE
10346: LD_INT 0
10348: PPUSH
10349: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_EXP 36
10359: PPUSH
10360: LD_INT 21
10362: PUSH
10363: LD_INT 3
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PPUSH
10370: CALL_OW 72
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10392
// SetSide ( i , 1 ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL_OW 235
10390: GO 10375
10392: POP
10393: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10394: LD_ADDR_VAR 0 2
10398: PUSH
10399: LD_INT 46
10401: PUSH
10402: LD_INT 41
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PUSH
10409: LD_INT 50
10411: PUSH
10412: LD_INT 25
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 57
10421: PUSH
10422: LD_INT 75
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: LD_INT 75
10431: PUSH
10432: LD_INT 89
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 51
10441: PUSH
10442: LD_INT 45
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 95
10451: PUSH
10452: LD_INT 95
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 84
10461: PUSH
10462: LD_INT 77
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: LD_INT 101
10471: PUSH
10472: LD_INT 76
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PUSH
10479: LD_INT 118
10481: PUSH
10482: LD_INT 81
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PUSH
10489: LD_INT 139
10491: PUSH
10492: LD_INT 97
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PUSH
10499: LD_INT 129
10501: PUSH
10502: LD_INT 114
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: PUSH
10509: LD_INT 154
10511: PUSH
10512: LD_INT 111
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: ST_TO_ADDR
// base_captured := true ;
10533: LD_ADDR_EXP 6
10537: PUSH
10538: LD_INT 1
10540: ST_TO_ADDR
// DialogueOn ;
10541: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10545: LD_EXP 21
10549: PPUSH
10550: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10554: LD_EXP 21
10558: PPUSH
10559: LD_STRING D2-JMM-1
10561: PPUSH
10562: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10566: LD_EXP 30
10570: PPUSH
10571: LD_STRING D2-Pow-1
10573: PPUSH
10574: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10578: LD_EXP 21
10582: PPUSH
10583: LD_STRING D2-JMM-2
10585: PPUSH
10586: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10590: LD_EXP 30
10594: PPUSH
10595: LD_STRING D2-Pow-2
10597: PPUSH
10598: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10602: LD_EXP 21
10606: PPUSH
10607: LD_STRING D2-JMM-3
10609: PPUSH
10610: CALL_OW 88
// DialogueOff ;
10614: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10618: LD_STRING M2
10620: PPUSH
10621: CALL_OW 337
// Wait ( 0 0$2 ) ;
10625: LD_INT 70
10627: PPUSH
10628: CALL_OW 67
// if IsOk ( Gary ) then
10632: LD_EXP 32
10636: PPUSH
10637: CALL_OW 302
10641: IFFALSE 10655
// Say ( Gary , D2a-Gary-1 ) ;
10643: LD_EXP 32
10647: PPUSH
10648: LD_STRING D2a-Gary-1
10650: PPUSH
10651: CALL_OW 88
// if IsOk ( Bobby ) then
10655: LD_EXP 24
10659: PPUSH
10660: CALL_OW 302
10664: IFFALSE 10678
// Say ( Bobby , D2a-Bobby-1 ) ;
10666: LD_EXP 24
10670: PPUSH
10671: LD_STRING D2a-Bobby-1
10673: PPUSH
10674: CALL_OW 88
// if IsOk ( Cyrus ) then
10678: LD_EXP 25
10682: PPUSH
10683: CALL_OW 302
10687: IFFALSE 10701
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10689: LD_EXP 25
10693: PPUSH
10694: LD_STRING D2a-Cyrus-1
10696: PPUSH
10697: CALL_OW 88
// if IsOk ( Lisa ) then
10701: LD_EXP 22
10705: PPUSH
10706: CALL_OW 302
10710: IFFALSE 10724
// Say ( Lisa , D2a-Lisa-1 ) ;
10712: LD_EXP 22
10716: PPUSH
10717: LD_STRING D2a-Lisa-1
10719: PPUSH
10720: CALL_OW 88
// if IsOk ( Frank ) then
10724: LD_EXP 33
10728: PPUSH
10729: CALL_OW 302
10733: IFFALSE 10747
// Say ( Frank , D2a-Frank-1 ) ;
10735: LD_EXP 33
10739: PPUSH
10740: LD_STRING D2a-Frank-1
10742: PPUSH
10743: CALL_OW 88
// if IsOk ( Cornel ) then
10747: LD_EXP 31
10751: PPUSH
10752: CALL_OW 302
10756: IFFALSE 10770
// Say ( Cornel , D2a-Corn-1 ) ;
10758: LD_EXP 31
10762: PPUSH
10763: LD_STRING D2a-Corn-1
10765: PPUSH
10766: CALL_OW 88
// if IsOk ( Donaldson ) then
10770: LD_EXP 23
10774: PPUSH
10775: CALL_OW 302
10779: IFFALSE 10793
// Say ( Donaldson , D2a-Don-1 ) ;
10781: LD_EXP 23
10785: PPUSH
10786: LD_STRING D2a-Don-1
10788: PPUSH
10789: CALL_OW 88
// if IsOk ( Brown ) then
10793: LD_EXP 27
10797: PPUSH
10798: CALL_OW 302
10802: IFFALSE 10816
// Say ( Brown , D2a-Brown-1 ) ;
10804: LD_EXP 27
10808: PPUSH
10809: LD_STRING D2a-Brown-1
10811: PPUSH
10812: CALL_OW 88
// Wait ( 0 0$30 ) ;
10816: LD_INT 1050
10818: PPUSH
10819: CALL_OW 67
// if IsOk ( Frank ) then
10823: LD_EXP 33
10827: PPUSH
10828: CALL_OW 302
10832: IFFALSE 11098
// begin DialogueOn ;
10834: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10838: LD_EXP 21
10842: PUSH
10843: LD_EXP 33
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PPUSH
10852: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10856: LD_EXP 33
10860: PPUSH
10861: LD_STRING D3F-Frank-1
10863: PPUSH
10864: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10868: LD_EXP 21
10872: PPUSH
10873: LD_STRING D3F-JMM-1
10875: PPUSH
10876: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10880: LD_EXP 33
10884: PPUSH
10885: LD_STRING D3F-Frank-2
10887: PPUSH
10888: CALL_OW 88
// case Query ( QFrank ) of 1 :
10892: LD_STRING QFrank
10894: PPUSH
10895: CALL_OW 97
10899: PUSH
10900: LD_INT 1
10902: DOUBLE
10903: EQUAL
10904: IFTRUE 10908
10906: GO 10931
10908: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10909: LD_EXP 21
10913: PPUSH
10914: LD_STRING D3Fa-JMM-1
10916: PPUSH
10917: CALL_OW 88
// us_scout := 1 ;
10921: LD_ADDR_EXP 8
10925: PUSH
10926: LD_INT 1
10928: ST_TO_ADDR
// end ; 2 :
10929: GO 11094
10931: LD_INT 2
10933: DOUBLE
10934: EQUAL
10935: IFTRUE 10939
10937: GO 11061
10939: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fb-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fb-Frank-1
10959: PPUSH
10960: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10964: LD_STRING QFrank2
10966: PPUSH
10967: CALL_OW 97
10971: PUSH
10972: LD_INT 1
10974: DOUBLE
10975: EQUAL
10976: IFTRUE 10980
10978: GO 11027
10980: POP
// begin us_scout := 2 ;
10981: LD_ADDR_EXP 8
10985: PUSH
10986: LD_INT 2
10988: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10989: LD_EXP 21
10993: PPUSH
10994: LD_STRING D3Fba-JMM-1
10996: PPUSH
10997: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11001: LD_EXP 33
11005: PPUSH
11006: LD_STRING D3Fba-Frank-1
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11013: LD_EXP 21
11017: PPUSH
11018: LD_STRING D3Fba-JMM-2
11020: PPUSH
11021: CALL_OW 88
// end ; 2 :
11025: GO 11059
11027: LD_INT 2
11029: DOUBLE
11030: EQUAL
11031: IFTRUE 11035
11033: GO 11058
11035: POP
// begin us_scout := 0 ;
11036: LD_ADDR_EXP 8
11040: PUSH
11041: LD_INT 0
11043: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11044: LD_EXP 21
11048: PPUSH
11049: LD_STRING D3Fbb-JMM-1
11051: PPUSH
11052: CALL_OW 88
// end ; end ;
11056: GO 11059
11058: POP
// end ; 3 :
11059: GO 11094
11061: LD_INT 3
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11093
11069: POP
// begin us_scout := - 1 ;
11070: LD_ADDR_EXP 8
11074: PUSH
11075: LD_INT 1
11077: NEG
11078: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11079: LD_EXP 21
11083: PPUSH
11084: LD_STRING D3Fc-JMM-1
11086: PPUSH
11087: CALL_OW 88
// end ; end ;
11091: GO 11094
11093: POP
// DialogueOff ;
11094: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11098: LD_EXP 8
11102: PUSH
11103: LD_INT 1
11105: NEG
11106: PUSH
11107: LD_INT 0
11109: PUSH
11110: EMPTY
11111: LIST
11112: LIST
11113: IN
11114: IFFALSE 11118
// exit ;
11116: GO 12749
// if us_scout in [ 1 , 2 ] then
11118: LD_EXP 8
11122: PUSH
11123: LD_INT 1
11125: PUSH
11126: LD_INT 2
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: IN
11133: IFFALSE 11812
// begin if IsInUnit ( Frank ) then
11135: LD_EXP 33
11139: PPUSH
11140: CALL_OW 310
11144: IFFALSE 11155
// ComExit ( Frank ) ;
11146: LD_EXP 33
11150: PPUSH
11151: CALL 86315 0 1
// SetSide ( Frank , 4 ) ;
11155: LD_EXP 33
11159: PPUSH
11160: LD_INT 4
11162: PPUSH
11163: CALL_OW 235
// wait ( 0 0$1 ) ;
11167: LD_INT 35
11169: PPUSH
11170: CALL_OW 67
// if us_scout = 2 then
11174: LD_EXP 8
11178: PUSH
11179: LD_INT 2
11181: EQUAL
11182: IFFALSE 11550
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11184: LD_EXP 33
11188: PPUSH
11189: LD_INT 75
11191: PPUSH
11192: LD_INT 63
11194: PPUSH
11195: CALL_OW 111
// AddComHold ( Frank ) ;
11199: LD_EXP 33
11203: PPUSH
11204: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11208: LD_EXP 33
11212: PPUSH
11213: LD_INT 770
11215: PPUSH
11216: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11220: LD_EXP 33
11224: PPUSH
11225: LD_INT 100
11227: PPUSH
11228: LD_INT 75
11230: PPUSH
11231: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 123
11242: PPUSH
11243: LD_INT 103
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 138
11257: PPUSH
11258: LD_INT 108
11260: PPUSH
11261: CALL_OW 171
// AddComHold ( Frank ) ;
11265: LD_EXP 33
11269: PPUSH
11270: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11274: LD_INT 35
11276: PPUSH
11277: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11281: LD_EXP 33
11285: PPUSH
11286: LD_INT 138
11288: PPUSH
11289: LD_INT 108
11291: PPUSH
11292: CALL_OW 307
11296: IFFALSE 11274
// AddComMoveXY ( Frank , 125 , 132 ) ;
11298: LD_EXP 33
11302: PPUSH
11303: LD_INT 125
11305: PPUSH
11306: LD_INT 132
11308: PPUSH
11309: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11313: LD_INT 35
11315: PPUSH
11316: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11320: LD_INT 1
11322: PPUSH
11323: LD_EXP 33
11327: PPUSH
11328: CALL_OW 292
11332: PUSH
11333: LD_EXP 33
11337: PPUSH
11338: LD_INT 7
11340: PPUSH
11341: CALL_OW 296
11345: PUSH
11346: LD_INT 7
11348: LESS
11349: OR
11350: IFFALSE 11313
// DialogueOn ;
11352: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11356: LD_EXP 33
11360: PPUSH
11361: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11365: LD_INT 10
11367: PPUSH
11368: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11372: LD_EXP 21
11376: PPUSH
11377: LD_STRING D4Fa-JMM-1
11379: PPUSH
11380: CALL_OW 88
// for i in points do
11384: LD_ADDR_VAR 0 1
11388: PUSH
11389: LD_VAR 0 2
11393: PUSH
11394: FOR_IN
11395: IFFALSE 11453
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11397: LD_VAR 0 1
11401: PUSH
11402: LD_INT 1
11404: ARRAY
11405: PPUSH
11406: LD_VAR 0 1
11410: PUSH
11411: LD_INT 2
11413: ARRAY
11414: PPUSH
11415: LD_INT 1
11417: PPUSH
11418: LD_INT 20
11420: NEG
11421: PPUSH
11422: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11426: LD_VAR 0 1
11430: PUSH
11431: LD_INT 1
11433: ARRAY
11434: PPUSH
11435: LD_VAR 0 1
11439: PUSH
11440: LD_INT 2
11442: ARRAY
11443: PPUSH
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 331
// end ;
11451: GO 11394
11453: POP
11454: POP
// dwait ( 0 0$0.5 ) ;
11455: LD_INT 18
11457: PPUSH
11458: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11462: LD_INT 42
11464: PPUSH
11465: LD_INT 27
11467: PPUSH
11468: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11472: LD_EXP 33
11476: PPUSH
11477: LD_STRING D4Fa-Frank-1
11479: PPUSH
11480: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11484: LD_INT 18
11486: PPUSH
11487: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11491: LD_EXP 21
11495: PPUSH
11496: LD_STRING D4Fa-JMM-2
11498: PPUSH
11499: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11503: LD_INT 118
11505: PPUSH
11506: LD_INT 80
11508: PPUSH
11509: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11513: LD_EXP 33
11517: PPUSH
11518: LD_STRING D4Fa-Frank-2
11520: PPUSH
11521: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11525: LD_INT 10
11527: PPUSH
11528: CALL_OW 68
// DialogueOff ;
11532: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11536: LD_EXP 33
11540: PPUSH
11541: LD_INT 1
11543: PPUSH
11544: CALL_OW 235
// end else
11548: GO 11812
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11550: LD_INT 2
11552: PPUSH
11553: LD_INT 4
11555: PPUSH
11556: LD_INT 2
11558: PPUSH
11559: LD_INT 1
11561: PPUSH
11562: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11566: LD_EXP 33
11570: PPUSH
11571: LD_INT 75
11573: PPUSH
11574: LD_INT 63
11576: PPUSH
11577: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 175
11588: PPUSH
11589: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11593: LD_EXP 33
11597: PPUSH
11598: LD_INT 102
11600: PPUSH
11601: LD_INT 76
11603: PPUSH
11604: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 108
11615: PPUSH
11616: LD_INT 70
11618: PPUSH
11619: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11623: LD_INT 35
11625: PPUSH
11626: CALL_OW 67
// until See ( 2 , Frank ) ;
11630: LD_INT 2
11632: PPUSH
11633: LD_EXP 33
11637: PPUSH
11638: CALL_OW 292
11642: IFFALSE 11623
// ComMoveXY ( Frank , 112 , 118 ) ;
11644: LD_EXP 33
11648: PPUSH
11649: LD_INT 112
11651: PPUSH
11652: LD_INT 118
11654: PPUSH
11655: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11659: LD_EXP 33
11663: PPUSH
11664: CALL_OW 256
11668: PUSH
11669: LD_INT 750
11671: GREATEREQUAL
11672: IFFALSE 11686
// SetLives ( Frank , 700 ) ;
11674: LD_EXP 33
11678: PPUSH
11679: LD_INT 700
11681: PPUSH
11682: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11686: LD_INT 35
11688: PPUSH
11689: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11693: LD_INT 1
11695: PPUSH
11696: LD_EXP 33
11700: PPUSH
11701: CALL_OW 292
11705: PUSH
11706: LD_EXP 33
11710: PPUSH
11711: LD_INT 7
11713: PPUSH
11714: CALL_OW 296
11718: PUSH
11719: LD_INT 17
11721: LESS
11722: OR
11723: IFFALSE 11686
// DialogueOn ;
11725: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11729: LD_EXP 33
11733: PPUSH
11734: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11738: LD_EXP 33
11742: PPUSH
11743: LD_STRING D4Fb-Frank-1
11745: PPUSH
11746: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11750: LD_EXP 21
11754: PPUSH
11755: LD_STRING D4Fb-JMM-1
11757: PPUSH
11758: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11762: LD_INT 2
11764: PPUSH
11765: LD_STRING D4Fb-FSci1-1
11767: PPUSH
11768: CALL 16672 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11772: LD_EXP 33
11776: PPUSH
11777: LD_STRING D4Fb-Frank-2
11779: PPUSH
11780: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11784: LD_EXP 21
11788: PPUSH
11789: LD_STRING D4Fb-JMM-2
11791: PPUSH
11792: CALL_OW 88
// DialogueOff ;
11796: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11800: LD_EXP 33
11804: PPUSH
11805: LD_INT 1
11807: PPUSH
11808: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11812: LD_EXP 34
11816: PPUSH
11817: CALL_OW 302
11821: PUSH
11822: LD_EXP 33
11826: NOT
11827: AND
11828: IFFALSE 11976
// begin DialogueOn ;
11830: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11834: LD_EXP 21
11838: PUSH
11839: LD_EXP 34
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PPUSH
11848: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11852: LD_EXP 34
11856: PPUSH
11857: LD_STRING D3Y-Yam-1
11859: PPUSH
11860: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11864: LD_EXP 21
11868: PPUSH
11869: LD_STRING D3Y-JMM-1
11871: PPUSH
11872: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11876: LD_EXP 34
11880: PPUSH
11881: LD_STRING D3Y-Yam-2
11883: PPUSH
11884: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11888: LD_STRING QYamoko
11890: PPUSH
11891: CALL_OW 97
11895: PUSH
11896: LD_INT 1
11898: DOUBLE
11899: EQUAL
11900: IFTRUE 11904
11902: GO 11939
11904: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11905: LD_EXP 21
11909: PPUSH
11910: LD_STRING D3Ya-JMM-1
11912: PPUSH
11913: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11917: LD_EXP 34
11921: PPUSH
11922: LD_STRING D3Ya-Yam-1
11924: PPUSH
11925: CALL_OW 88
// us_scout := 1 ;
11929: LD_ADDR_EXP 8
11933: PUSH
11934: LD_INT 1
11936: ST_TO_ADDR
// end ; 2 :
11937: GO 11972
11939: LD_INT 2
11941: DOUBLE
11942: EQUAL
11943: IFTRUE 11947
11945: GO 11971
11947: POP
// begin us_scout := - 1 ;
11948: LD_ADDR_EXP 8
11952: PUSH
11953: LD_INT 1
11955: NEG
11956: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11957: LD_EXP 21
11961: PPUSH
11962: LD_STRING D3Yb-JMM-1
11964: PPUSH
11965: CALL_OW 88
// end ; end ;
11969: GO 11972
11971: POP
// DialogueOff ;
11972: CALL_OW 7
// end ; if Frank then
11976: LD_EXP 33
11980: IFFALSE 11984
// exit ;
11982: GO 12749
// if us_scout in [ - 1 , 0 ] then
11984: LD_EXP 8
11988: PUSH
11989: LD_INT 1
11991: NEG
11992: PUSH
11993: LD_INT 0
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12749
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12004: LD_ADDR_EXP 8
12008: PUSH
12009: LD_INT 2
12011: PUSH
12012: LD_INT 2
12014: PUSH
12015: LD_INT 1
12017: PUSH
12018: LD_INT 1
12020: PUSH
12021: EMPTY
12022: LIST
12023: LIST
12024: LIST
12025: LIST
12026: PUSH
12027: LD_OWVAR 67
12031: ARRAY
12032: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12033: LD_EXP 8
12037: PUSH
12038: LD_INT 1
12040: PUSH
12041: LD_INT 2
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: IN
12048: IFFALSE 12749
// begin if IsInUnit ( Kikuchi ) then
12050: LD_EXP 34
12054: PPUSH
12055: CALL_OW 310
12059: IFFALSE 12070
// ComExitBuilding ( Kikuchi ) ;
12061: LD_EXP 34
12065: PPUSH
12066: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12070: LD_EXP 34
12074: PPUSH
12075: CALL_OW 311
12079: IFFALSE 12090
// ComExitVehicle ( Kikuchi ) ;
12081: LD_EXP 34
12085: PPUSH
12086: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12090: LD_EXP 34
12094: PPUSH
12095: LD_INT 4
12097: PPUSH
12098: CALL_OW 235
// wait ( 0 0$1 ) ;
12102: LD_INT 35
12104: PPUSH
12105: CALL_OW 67
// if us_scout = 2 then
12109: LD_EXP 8
12113: PUSH
12114: LD_INT 2
12116: EQUAL
12117: IFFALSE 12497
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12119: LD_EXP 34
12123: PPUSH
12124: LD_INT 75
12126: PPUSH
12127: LD_INT 63
12129: PPUSH
12130: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12134: LD_EXP 34
12138: PPUSH
12139: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12143: LD_EXP 34
12147: PPUSH
12148: LD_INT 770
12150: PPUSH
12151: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12155: LD_EXP 34
12159: PPUSH
12160: LD_INT 100
12162: PPUSH
12163: LD_INT 75
12165: PPUSH
12166: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12170: LD_EXP 34
12174: PPUSH
12175: LD_INT 123
12177: PPUSH
12178: LD_INT 103
12180: PPUSH
12181: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12185: LD_EXP 34
12189: PPUSH
12190: LD_INT 138
12192: PPUSH
12193: LD_INT 108
12195: PPUSH
12196: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12200: LD_EXP 34
12204: PPUSH
12205: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12209: LD_INT 35
12211: PPUSH
12212: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12216: LD_EXP 34
12220: PPUSH
12221: LD_INT 138
12223: PPUSH
12224: LD_INT 108
12226: PPUSH
12227: CALL_OW 307
12231: IFFALSE 12209
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12233: LD_EXP 34
12237: PPUSH
12238: LD_INT 125
12240: PPUSH
12241: LD_INT 132
12243: PPUSH
12244: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12248: LD_INT 35
12250: PPUSH
12251: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12255: LD_INT 1
12257: PPUSH
12258: LD_EXP 34
12262: PPUSH
12263: CALL_OW 292
12267: PUSH
12268: LD_EXP 34
12272: PPUSH
12273: LD_INT 7
12275: PPUSH
12276: CALL_OW 296
12280: PUSH
12281: LD_INT 7
12283: LESS
12284: OR
12285: IFFALSE 12248
// DialogueOn ;
12287: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12300: LD_INT 10
12302: PPUSH
12303: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12307: LD_EXP 34
12311: PPUSH
12312: LD_STRING D4Ya-Yam-1
12314: PPUSH
12315: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12319: LD_EXP 21
12323: PPUSH
12324: LD_STRING D4Ya-JMM-1
12326: PPUSH
12327: CALL_OW 88
// for i in points do
12331: LD_ADDR_VAR 0 1
12335: PUSH
12336: LD_VAR 0 2
12340: PUSH
12341: FOR_IN
12342: IFFALSE 12400
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12344: LD_VAR 0 1
12348: PUSH
12349: LD_INT 1
12351: ARRAY
12352: PPUSH
12353: LD_VAR 0 1
12357: PUSH
12358: LD_INT 2
12360: ARRAY
12361: PPUSH
12362: LD_INT 1
12364: PPUSH
12365: LD_INT 20
12367: NEG
12368: PPUSH
12369: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12373: LD_VAR 0 1
12377: PUSH
12378: LD_INT 1
12380: ARRAY
12381: PPUSH
12382: LD_VAR 0 1
12386: PUSH
12387: LD_INT 2
12389: ARRAY
12390: PPUSH
12391: LD_INT 1
12393: PPUSH
12394: CALL_OW 331
// end ;
12398: GO 12341
12400: POP
12401: POP
// dwait ( 0 0$0.5 ) ;
12402: LD_INT 18
12404: PPUSH
12405: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12409: LD_INT 42
12411: PPUSH
12412: LD_INT 27
12414: PPUSH
12415: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12419: LD_EXP 34
12423: PPUSH
12424: LD_STRING D4Ya-Yam-2
12426: PPUSH
12427: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12431: LD_INT 18
12433: PPUSH
12434: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12438: LD_INT 118
12440: PPUSH
12441: LD_INT 80
12443: PPUSH
12444: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12448: LD_EXP 21
12452: PPUSH
12453: LD_STRING D4Ya-JMM-2
12455: PPUSH
12456: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12460: LD_EXP 34
12464: PPUSH
12465: LD_STRING D4Ya-Yam-3
12467: PPUSH
12468: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12472: LD_INT 10
12474: PPUSH
12475: CALL_OW 68
// DialogueOff ;
12479: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12483: LD_EXP 34
12487: PPUSH
12488: LD_INT 1
12490: PPUSH
12491: CALL_OW 235
// end else
12495: GO 12749
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12497: LD_INT 2
12499: PPUSH
12500: LD_INT 4
12502: PPUSH
12503: LD_INT 2
12505: PPUSH
12506: LD_INT 1
12508: PPUSH
12509: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12513: LD_EXP 34
12517: PPUSH
12518: LD_INT 75
12520: PPUSH
12521: LD_INT 63
12523: PPUSH
12524: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_INT 175
12535: PPUSH
12536: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12540: LD_EXP 34
12544: PPUSH
12545: LD_INT 102
12547: PPUSH
12548: LD_INT 76
12550: PPUSH
12551: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12555: LD_EXP 34
12559: PPUSH
12560: LD_INT 108
12562: PPUSH
12563: LD_INT 70
12565: PPUSH
12566: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12570: LD_INT 35
12572: PPUSH
12573: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12577: LD_INT 2
12579: PPUSH
12580: LD_EXP 34
12584: PPUSH
12585: CALL_OW 292
12589: IFFALSE 12570
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12591: LD_EXP 34
12595: PPUSH
12596: LD_INT 112
12598: PPUSH
12599: LD_INT 118
12601: PPUSH
12602: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12606: LD_EXP 34
12610: PPUSH
12611: CALL_OW 256
12615: PUSH
12616: LD_INT 750
12618: GREATEREQUAL
12619: IFFALSE 12633
// SetLives ( Kikuchi , 700 ) ;
12621: LD_EXP 34
12625: PPUSH
12626: LD_INT 700
12628: PPUSH
12629: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12633: LD_INT 35
12635: PPUSH
12636: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12640: LD_INT 1
12642: PPUSH
12643: LD_EXP 34
12647: PPUSH
12648: CALL_OW 292
12652: PUSH
12653: LD_EXP 34
12657: PPUSH
12658: LD_INT 7
12660: PPUSH
12661: CALL_OW 296
12665: PUSH
12666: LD_INT 17
12668: LESS
12669: OR
12670: IFFALSE 12633
// DialogueOn ;
12672: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12676: LD_EXP 34
12680: PPUSH
12681: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12685: LD_EXP 34
12689: PPUSH
12690: LD_STRING D4Yb-Yam-1
12692: PPUSH
12693: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12697: LD_EXP 21
12701: PPUSH
12702: LD_STRING D4Yb-JMM-1
12704: PPUSH
12705: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12709: LD_EXP 34
12713: PPUSH
12714: LD_STRING D4Yb-Yam-2
12716: PPUSH
12717: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12721: LD_EXP 21
12725: PPUSH
12726: LD_STRING D4Yb-JMM-2
12728: PPUSH
12729: CALL_OW 88
// DialogueOff ;
12733: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12737: LD_EXP 34
12741: PPUSH
12742: LD_INT 1
12744: PPUSH
12745: CALL_OW 235
// end ; end ; end ;
12749: PPOPN 2
12751: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12752: LD_EXP 6
12756: IFFALSE 13789
12758: GO 12760
12760: DISABLE
12761: LD_INT 0
12763: PPUSH
12764: PPUSH
12765: PPUSH
12766: PPUSH
// begin enable ;
12767: ENABLE
// if not seen [ 1 ] then
12768: LD_EXP 9
12772: PUSH
12773: LD_INT 1
12775: ARRAY
12776: NOT
12777: IFFALSE 12957
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 2
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 2
12796: PUSH
12797: LD_INT 25
12799: PUSH
12800: LD_INT 11
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: LD_INT 33
12809: PUSH
12810: LD_INT 4
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: LIST
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 69
12830: ST_TO_ADDR
// if tmp then
12831: LD_VAR 0 2
12835: IFFALSE 12957
// for i in tmp do
12837: LD_ADDR_VAR 0 1
12841: PUSH
12842: LD_VAR 0 2
12846: PUSH
12847: FOR_IN
12848: IFFALSE 12955
// if See ( 1 , i ) then
12850: LD_INT 1
12852: PPUSH
12853: LD_VAR 0 1
12857: PPUSH
12858: CALL_OW 292
12862: IFFALSE 12953
// begin seen := Replace ( seen , 1 , true ) ;
12864: LD_ADDR_EXP 9
12868: PUSH
12869: LD_EXP 9
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 1
12879: PPUSH
12880: CALL_OW 1
12884: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12885: LD_INT 1
12887: PPUSH
12888: CALL 16494 0 1
12892: IFFALSE 12953
// begin DialogueOn ;
12894: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12898: LD_VAR 0 1
12902: PPUSH
12903: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12907: LD_INT 10
12909: PPUSH
12910: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: LD_INT 1
12921: PPUSH
12922: LD_STRING D5a-Sol2-1
12924: PPUSH
12925: CALL 16672 0 2
12929: ST_TO_ADDR
// if not un then
12930: LD_VAR 0 3
12934: NOT
12935: IFFALSE 12947
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12937: LD_INT 2
12939: PPUSH
12940: LD_STRING D5a-FSol2-1
12942: PPUSH
12943: CALL 16672 0 2
// DialogueOff ;
12947: CALL_OW 7
// break ;
12951: GO 12955
// end ; end ;
12953: GO 12847
12955: POP
12956: POP
// end ; if not seen [ 2 ] then
12957: LD_EXP 9
12961: PUSH
12962: LD_INT 2
12964: ARRAY
12965: NOT
12966: IFFALSE 13191
// begin can_kamikazed := true ;
12968: LD_ADDR_EXP 10
12972: PUSH
12973: LD_INT 1
12975: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12976: LD_ADDR_VAR 0 2
12980: PUSH
12981: LD_INT 22
12983: PUSH
12984: LD_INT 2
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PUSH
12991: LD_INT 25
12993: PUSH
12994: LD_INT 17
12996: PUSH
12997: EMPTY
12998: LIST
12999: LIST
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PPUSH
13005: CALL_OW 69
13009: ST_TO_ADDR
// if tmp then
13010: LD_VAR 0 2
13014: IFFALSE 13191
// for i in tmp do
13016: LD_ADDR_VAR 0 1
13020: PUSH
13021: LD_VAR 0 2
13025: PUSH
13026: FOR_IN
13027: IFFALSE 13189
// if See ( 1 , i ) then
13029: LD_INT 1
13031: PPUSH
13032: LD_VAR 0 1
13036: PPUSH
13037: CALL_OW 292
13041: IFFALSE 13187
// begin seen := Replace ( seen , 2 , true ) ;
13043: LD_ADDR_EXP 9
13047: PUSH
13048: LD_EXP 9
13052: PPUSH
13053: LD_INT 2
13055: PPUSH
13056: LD_INT 1
13058: PPUSH
13059: CALL_OW 1
13063: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13064: LD_INT 1
13066: PPUSH
13067: CALL 16494 0 1
13071: IFFALSE 13187
// begin DialogueOn ;
13073: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13077: LD_VAR 0 1
13081: PPUSH
13082: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13086: LD_INT 10
13088: PPUSH
13089: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13093: LD_ADDR_VAR 0 3
13097: PUSH
13098: LD_INT 1
13100: PPUSH
13101: LD_STRING D5b-Sol1-1
13103: PPUSH
13104: CALL 16672 0 2
13108: ST_TO_ADDR
// if not un then
13109: LD_VAR 0 3
13113: NOT
13114: IFFALSE 13132
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13116: LD_ADDR_VAR 0 3
13120: PUSH
13121: LD_INT 2
13123: PPUSH
13124: LD_STRING D5b-FSol1-1
13126: PPUSH
13127: CALL 16672 0 2
13131: ST_TO_ADDR
// if un then
13132: LD_VAR 0 3
13136: IFFALSE 13181
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13138: LD_ADDR_VAR 0 4
13142: PUSH
13143: LD_INT 1
13145: PPUSH
13146: LD_STRING D5b-Sol2-1
13148: PPUSH
13149: LD_VAR 0 3
13153: PPUSH
13154: CALL 16898 0 3
13158: ST_TO_ADDR
// if not un2 then
13159: LD_VAR 0 4
13163: NOT
13164: IFFALSE 13181
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13166: LD_INT 2
13168: PPUSH
13169: LD_STRING D5b-FSol2-1
13171: PPUSH
13172: LD_VAR 0 3
13176: PPUSH
13177: CALL 16898 0 3
// end ; DialogueOff ;
13181: CALL_OW 7
// break ;
13185: GO 13189
// end ; end ;
13187: GO 13026
13189: POP
13190: POP
// end ; if not seen [ 3 ] then
13191: LD_EXP 9
13195: PUSH
13196: LD_INT 3
13198: ARRAY
13199: NOT
13200: IFFALSE 13374
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13202: LD_ADDR_VAR 0 2
13206: PUSH
13207: LD_INT 22
13209: PUSH
13210: LD_INT 2
13212: PUSH
13213: EMPTY
13214: LIST
13215: LIST
13216: PUSH
13217: LD_INT 33
13219: PUSH
13220: LD_INT 2
13222: PUSH
13223: EMPTY
13224: LIST
13225: LIST
13226: PUSH
13227: EMPTY
13228: LIST
13229: LIST
13230: PPUSH
13231: CALL_OW 69
13235: ST_TO_ADDR
// if tmp then
13236: LD_VAR 0 2
13240: IFFALSE 13374
// for i in tmp do
13242: LD_ADDR_VAR 0 1
13246: PUSH
13247: LD_VAR 0 2
13251: PUSH
13252: FOR_IN
13253: IFFALSE 13372
// if See ( 1 , i ) then
13255: LD_INT 1
13257: PPUSH
13258: LD_VAR 0 1
13262: PPUSH
13263: CALL_OW 292
13267: IFFALSE 13370
// begin seen := Replace ( seen , 3 , true ) ;
13269: LD_ADDR_EXP 9
13273: PUSH
13274: LD_EXP 9
13278: PPUSH
13279: LD_INT 3
13281: PPUSH
13282: LD_INT 1
13284: PPUSH
13285: CALL_OW 1
13289: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13290: LD_INT 1
13292: PPUSH
13293: CALL 16494 0 1
13297: IFFALSE 13370
// begin DialogueOn ;
13299: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13303: LD_VAR 0 1
13307: PPUSH
13308: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13312: LD_INT 10
13314: PPUSH
13315: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_INT 1
13326: PPUSH
13327: LD_STRING D8-Sol1-1
13329: PPUSH
13330: CALL 16672 0 2
13334: ST_TO_ADDR
// if not un then
13335: LD_VAR 0 3
13339: NOT
13340: IFFALSE 13352
// SayRand ( sex_female , D8-FSol1-1 ) ;
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D8-FSol1-1
13347: PPUSH
13348: CALL 16672 0 2
// Say ( JMM , D8-JMM-1 ) ;
13352: LD_EXP 21
13356: PPUSH
13357: LD_STRING D8-JMM-1
13359: PPUSH
13360: CALL_OW 88
// DialogueOff ;
13364: CALL_OW 7
// break ;
13368: GO 13372
// end ; end ;
13370: GO 13252
13372: POP
13373: POP
// end ; if not seen [ 4 ] then
13374: LD_EXP 9
13378: PUSH
13379: LD_INT 4
13381: ARRAY
13382: NOT
13383: IFFALSE 13545
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13385: LD_ADDR_VAR 0 2
13389: PUSH
13390: LD_INT 22
13392: PUSH
13393: LD_INT 2
13395: PUSH
13396: EMPTY
13397: LIST
13398: LIST
13399: PUSH
13400: LD_INT 33
13402: PUSH
13403: LD_INT 5
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: PPUSH
13414: CALL_OW 69
13418: ST_TO_ADDR
// if tmp then
13419: LD_VAR 0 2
13423: IFFALSE 13545
// for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13543
// if See ( 1 , i ) then
13438: LD_INT 1
13440: PPUSH
13441: LD_VAR 0 1
13445: PPUSH
13446: CALL_OW 292
13450: IFFALSE 13541
// begin seen := Replace ( seen , 4 , true ) ;
13452: LD_ADDR_EXP 9
13456: PUSH
13457: LD_EXP 9
13461: PPUSH
13462: LD_INT 4
13464: PPUSH
13465: LD_INT 1
13467: PPUSH
13468: CALL_OW 1
13472: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13473: LD_INT 1
13475: PPUSH
13476: CALL 16494 0 1
13480: IFFALSE 13541
// begin DialogueOn ;
13482: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13486: LD_VAR 0 1
13490: PPUSH
13491: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13495: LD_INT 10
13497: PPUSH
13498: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13502: LD_ADDR_VAR 0 3
13506: PUSH
13507: LD_INT 1
13509: PPUSH
13510: LD_STRING D5a-Sol1-1
13512: PPUSH
13513: CALL 16672 0 2
13517: ST_TO_ADDR
// if not un then
13518: LD_VAR 0 3
13522: NOT
13523: IFFALSE 13535
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13525: LD_INT 2
13527: PPUSH
13528: LD_STRING D5a-FSol1-1
13530: PPUSH
13531: CALL 16672 0 2
// DialogueOff ;
13535: CALL_OW 7
// break ;
13539: GO 13543
// end ; end ;
13541: GO 13435
13543: POP
13544: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13545: LD_EXP 9
13549: PUSH
13550: LD_INT 5
13552: ARRAY
13553: NOT
13554: PUSH
13555: LD_EXP 9
13559: PUSH
13560: LD_INT 3
13562: ARRAY
13563: AND
13564: IFFALSE 13738
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13566: LD_ADDR_VAR 0 2
13570: PUSH
13571: LD_INT 22
13573: PUSH
13574: LD_INT 2
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: PUSH
13581: LD_INT 34
13583: PUSH
13584: LD_INT 31
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: PPUSH
13595: CALL_OW 69
13599: ST_TO_ADDR
// if tmp then
13600: LD_VAR 0 2
13604: IFFALSE 13738
// for i in tmp do
13606: LD_ADDR_VAR 0 1
13610: PUSH
13611: LD_VAR 0 2
13615: PUSH
13616: FOR_IN
13617: IFFALSE 13736
// if See ( 1 , i ) then
13619: LD_INT 1
13621: PPUSH
13622: LD_VAR 0 1
13626: PPUSH
13627: CALL_OW 292
13631: IFFALSE 13734
// begin seen := Replace ( seen , 5 , true ) ;
13633: LD_ADDR_EXP 9
13637: PUSH
13638: LD_EXP 9
13642: PPUSH
13643: LD_INT 5
13645: PPUSH
13646: LD_INT 1
13648: PPUSH
13649: CALL_OW 1
13653: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13654: LD_INT 1
13656: PPUSH
13657: CALL 16494 0 1
13661: IFFALSE 13734
// begin DialogueOn ;
13663: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13676: LD_INT 10
13678: PPUSH
13679: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13683: LD_ADDR_VAR 0 3
13687: PUSH
13688: LD_INT 1
13690: PPUSH
13691: LD_STRING D8a-Sol2-1
13693: PPUSH
13694: CALL 16672 0 2
13698: ST_TO_ADDR
// if not un then
13699: LD_VAR 0 3
13703: NOT
13704: IFFALSE 13716
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13706: LD_INT 2
13708: PPUSH
13709: LD_STRING D8a-FSol2-1
13711: PPUSH
13712: CALL 16672 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13716: LD_EXP 21
13720: PPUSH
13721: LD_STRING D8a-JMM-1
13723: PPUSH
13724: CALL_OW 88
// DialogueOff ;
13728: CALL_OW 7
// break ;
13732: GO 13736
// end ; end ;
13734: GO 13616
13736: POP
13737: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13738: LD_EXP 9
13742: PUSH
13743: LD_INT 1
13745: ARRAY
13746: PUSH
13747: LD_EXP 9
13751: PUSH
13752: LD_INT 2
13754: ARRAY
13755: AND
13756: PUSH
13757: LD_EXP 9
13761: PUSH
13762: LD_INT 3
13764: ARRAY
13765: AND
13766: PUSH
13767: LD_EXP 9
13771: PUSH
13772: LD_INT 4
13774: ARRAY
13775: AND
13776: PUSH
13777: LD_EXP 9
13781: PUSH
13782: LD_INT 5
13784: ARRAY
13785: AND
13786: IFFALSE 13789
// disable ;
13788: DISABLE
// end ;
13789: PPOPN 4
13791: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13792: LD_EXP 10
13796: PUSH
13797: LD_EXP 11
13801: AND
13802: IFFALSE 14000
13804: GO 13806
13806: DISABLE
13807: LD_INT 0
13809: PPUSH
// begin DialogueOn ;
13810: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13814: LD_EXP 11
13818: PPUSH
13819: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13823: LD_ADDR_VAR 0 1
13827: PUSH
13828: LD_INT 1
13830: PPUSH
13831: LD_STRING D5c-Sol1-1
13833: PPUSH
13834: CALL 16672 0 2
13838: ST_TO_ADDR
// if not un then
13839: LD_VAR 0 1
13843: NOT
13844: IFFALSE 13862
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13846: LD_ADDR_VAR 0 1
13850: PUSH
13851: LD_INT 2
13853: PPUSH
13854: LD_STRING D5c-FSol1-1
13856: PPUSH
13857: CALL 16672 0 2
13861: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13862: LD_EXP 21
13866: PPUSH
13867: LD_STRING D5c-JMM-1
13869: PPUSH
13870: CALL_OW 88
// if IsOk ( Lisa ) then
13874: LD_EXP 22
13878: PPUSH
13879: CALL_OW 302
13883: IFFALSE 13899
// Say ( Lisa , D5d-Lisa-1 ) else
13885: LD_EXP 22
13889: PPUSH
13890: LD_STRING D5d-Lisa-1
13892: PPUSH
13893: CALL_OW 88
13897: GO 13984
// if IsOk ( Cyrus ) then
13899: LD_EXP 25
13903: PPUSH
13904: CALL_OW 302
13908: IFFALSE 13924
// Say ( Cyrus , D5d-Cyrus-1 ) else
13910: LD_EXP 25
13914: PPUSH
13915: LD_STRING D5d-Cyrus-1
13917: PPUSH
13918: CALL_OW 88
13922: GO 13984
// if IsOk ( Gary ) then
13924: LD_EXP 32
13928: PPUSH
13929: CALL_OW 302
13933: IFFALSE 13949
// Say ( Gary , D5d-Gary-1 ) else
13935: LD_EXP 32
13939: PPUSH
13940: LD_STRING D5d-Gary-1
13942: PPUSH
13943: CALL_OW 88
13947: GO 13984
// if GetSex ( un ) = sex_male then
13949: LD_VAR 0 1
13953: PPUSH
13954: CALL_OW 258
13958: PUSH
13959: LD_INT 1
13961: EQUAL
13962: IFFALSE 13978
// Say ( un , D5d-Sol1-1 ) else
13964: LD_VAR 0 1
13968: PPUSH
13969: LD_STRING D5d-Sol1-1
13971: PPUSH
13972: CALL_OW 88
13976: GO 13984
// begin DialogueOff ;
13978: CALL_OW 7
// exit ;
13982: GO 14000
// end ; Say ( JMM , D5d-JMM-1 ) ;
13984: LD_EXP 21
13988: PPUSH
13989: LD_STRING D5d-JMM-1
13991: PPUSH
13992: CALL_OW 88
// DialogueOff ;
13996: CALL_OW 7
// end ;
14000: PPOPN 1
14002: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14003: LD_INT 1
14005: PPUSH
14006: LD_INT 17
14008: PPUSH
14009: CALL_OW 294
14013: PUSH
14014: LD_INT 2
14016: GREATEREQUAL
14017: IFFALSE 14149
14019: GO 14021
14021: DISABLE
14022: LD_INT 0
14024: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14025: LD_INT 10
14027: PPUSH
14028: LD_INT 5
14030: PPUSH
14031: LD_INT 1
14033: PPUSH
14034: LD_INT 10
14036: NEG
14037: PPUSH
14038: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14042: LD_INT 10
14044: PPUSH
14045: LD_INT 5
14047: PPUSH
14048: LD_INT 1
14050: PPUSH
14051: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14055: LD_INT 10
14057: PPUSH
14058: LD_INT 5
14060: PPUSH
14061: CALL_OW 86
// DialogueOn ;
14065: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14069: LD_ADDR_VAR 0 1
14073: PUSH
14074: LD_INT 1
14076: PPUSH
14077: LD_STRING D6-Sci1-1
14079: PPUSH
14080: CALL 16672 0 2
14084: ST_TO_ADDR
// if un then
14085: LD_VAR 0 1
14089: IFFALSE 14127
// begin Say ( JMM , D6-JMM-1 ) ;
14091: LD_EXP 21
14095: PPUSH
14096: LD_STRING D6-JMM-1
14098: PPUSH
14099: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_STRING D6-Sci1-2
14110: PPUSH
14111: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14115: LD_EXP 21
14119: PPUSH
14120: LD_STRING D6-JMM-2
14122: PPUSH
14123: CALL_OW 88
// end ; DialogueOff ;
14127: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14131: LD_STRING M3
14133: PPUSH
14134: CALL_OW 337
// wait ( 0 0$30 ) ;
14138: LD_INT 1050
14140: PPUSH
14141: CALL_OW 67
// AmericanReinforcements ;
14145: CALL 2326 0 0
// end ;
14149: PPOPN 1
14151: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14152: LD_OWVAR 1
14156: PUSH
14157: LD_INT 42000
14159: GREATEREQUAL
14160: PUSH
14161: LD_INT 2
14163: PPUSH
14164: LD_INT 169
14166: PPUSH
14167: LD_INT 90
14169: PPUSH
14170: LD_INT 10
14172: PPUSH
14173: CALL 54574 0 4
14177: PUSH
14178: LD_INT 4
14180: ARRAY
14181: PUSH
14182: LD_INT 0
14184: EQUAL
14185: PUSH
14186: LD_INT 45
14188: PPUSH
14189: CALL_OW 301
14193: OR
14194: PUSH
14195: LD_INT 45
14197: PPUSH
14198: CALL_OW 255
14202: PUSH
14203: LD_INT 1
14205: EQUAL
14206: OR
14207: AND
14208: PUSH
14209: LD_INT 94
14211: PPUSH
14212: CALL_OW 301
14216: NOT
14217: AND
14218: IFFALSE 15423
14220: GO 14222
14222: DISABLE
14223: LD_INT 0
14225: PPUSH
14226: PPUSH
14227: PPUSH
14228: PPUSH
14229: PPUSH
// begin uc_side := 5 ;
14230: LD_ADDR_OWVAR 20
14234: PUSH
14235: LD_INT 5
14237: ST_TO_ADDR
// uc_nation := 2 ;
14238: LD_ADDR_OWVAR 21
14242: PUSH
14243: LD_INT 2
14245: ST_TO_ADDR
// InitHc ;
14246: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14250: LD_INT 1
14252: PPUSH
14253: LD_INT 3
14255: PPUSH
14256: LD_INT 8
14258: PPUSH
14259: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14263: LD_ADDR_OWVAR 29
14267: PUSH
14268: LD_INT 12
14270: PUSH
14271: LD_INT 12
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: ST_TO_ADDR
// hc_name := Hans Fliege ;
14278: LD_ADDR_OWVAR 26
14282: PUSH
14283: LD_STRING Hans Fliege
14285: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14286: LD_ADDR_OWVAR 33
14290: PUSH
14291: LD_STRING SecondCharsGal
14293: ST_TO_ADDR
// hc_face_number := 7 ;
14294: LD_ADDR_OWVAR 34
14298: PUSH
14299: LD_INT 7
14301: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14302: LD_ADDR_EXP 46
14306: PUSH
14307: CALL_OW 44
14311: ST_TO_ADDR
// InitHc ;
14312: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14316: LD_INT 1
14318: PPUSH
14319: LD_INT 16
14321: PPUSH
14322: LD_INT 2
14324: PPUSH
14325: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14329: LD_ADDR_OWVAR 29
14333: PUSH
14334: LD_INT 12
14336: PUSH
14337: LD_INT 12
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: ST_TO_ADDR
// hc_name :=  ;
14344: LD_ADDR_OWVAR 26
14348: PUSH
14349: LD_STRING 
14351: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14352: LD_ADDR_EXP 47
14356: PUSH
14357: CALL_OW 44
14361: ST_TO_ADDR
// InitHc ;
14362: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14366: LD_INT 35
14368: PPUSH
14369: CALL_OW 67
// until not InBattle ( 1 ) ;
14373: LD_INT 1
14375: PPUSH
14376: CALL_OW 463
14380: NOT
14381: IFFALSE 14366
// wait ( 0 0$5 ) ;
14383: LD_INT 175
14385: PPUSH
14386: CALL_OW 67
// DialogueOn ;
14390: CALL_OW 6
// InGameOn ;
14394: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14398: LD_ADDR_VAR 0 1
14402: PUSH
14403: LD_INT 22
14405: PUSH
14406: LD_INT 1
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: LD_INT 2
14415: PUSH
14416: LD_INT 25
14418: PUSH
14419: LD_INT 1
14421: PUSH
14422: EMPTY
14423: LIST
14424: LIST
14425: PUSH
14426: LD_INT 25
14428: PUSH
14429: LD_INT 2
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PUSH
14436: LD_INT 25
14438: PUSH
14439: LD_INT 3
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: PUSH
14446: LD_INT 25
14448: PUSH
14449: LD_INT 4
14451: PUSH
14452: EMPTY
14453: LIST
14454: LIST
14455: PUSH
14456: LD_INT 25
14458: PUSH
14459: LD_INT 5
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: LD_INT 25
14468: PUSH
14469: LD_INT 8
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: LIST
14482: LIST
14483: LIST
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PPUSH
14489: CALL_OW 69
14493: PUSH
14494: LD_EXP 21
14498: PUSH
14499: LD_EXP 22
14503: PUSH
14504: LD_EXP 23
14508: PUSH
14509: LD_EXP 24
14513: PUSH
14514: LD_EXP 25
14518: PUSH
14519: LD_EXP 26
14523: PUSH
14524: LD_EXP 27
14528: PUSH
14529: LD_EXP 28
14533: PUSH
14534: LD_EXP 29
14538: PUSH
14539: LD_EXP 31
14543: PUSH
14544: LD_EXP 32
14548: PUSH
14549: LD_EXP 33
14553: PUSH
14554: LD_EXP 34
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: DIFF
14574: PPUSH
14575: LD_INT 26
14577: PUSH
14578: LD_INT 1
14580: PUSH
14581: EMPTY
14582: LIST
14583: LIST
14584: PPUSH
14585: CALL_OW 72
14589: PUSH
14590: LD_INT 1
14592: ARRAY
14593: ST_TO_ADDR
// if Brown then
14594: LD_EXP 27
14598: IFFALSE 14610
// un := Brown ;
14600: LD_ADDR_VAR 0 1
14604: PUSH
14605: LD_EXP 27
14609: ST_TO_ADDR
// if un then
14610: LD_VAR 0 1
14614: IFFALSE 14640
// begin Say ( un , D7-Sol1-1 ) ;
14616: LD_VAR 0 1
14620: PPUSH
14621: LD_STRING D7-Sol1-1
14623: PPUSH
14624: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14628: LD_EXP 21
14632: PPUSH
14633: LD_STRING D7-JMM-1
14635: PPUSH
14636: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14640: LD_EXP 46
14644: PPUSH
14645: LD_STRING D7-Ar1-1
14647: PPUSH
14648: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14652: LD_EXP 21
14656: PPUSH
14657: LD_STRING D7-JMM-2
14659: PPUSH
14660: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14664: LD_EXP 46
14668: PPUSH
14669: LD_STRING D7-Ar1-2
14671: PPUSH
14672: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14676: LD_EXP 21
14680: PPUSH
14681: LD_STRING D7-JMM-3
14683: PPUSH
14684: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14688: LD_EXP 46
14692: PPUSH
14693: LD_STRING D7-Ar1-3
14695: PPUSH
14696: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14700: LD_EXP 21
14704: PPUSH
14705: LD_STRING D7-JMM-4
14707: PPUSH
14708: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14712: LD_EXP 46
14716: PPUSH
14717: LD_STRING D7-Ar1-4
14719: PPUSH
14720: CALL_OW 94
// InGameOff ;
14724: CALL_OW 9
// DialogueOff ;
14728: CALL_OW 7
// case Query ( QCameras ) of 1 :
14732: LD_STRING QCameras
14734: PPUSH
14735: CALL_OW 97
14739: PUSH
14740: LD_INT 1
14742: DOUBLE
14743: EQUAL
14744: IFTRUE 14748
14746: GO 14751
14748: POP
// ; 2 :
14749: GO 14765
14751: LD_INT 2
14753: DOUBLE
14754: EQUAL
14755: IFTRUE 14759
14757: GO 14764
14759: POP
// exit ; end ;
14760: GO 15423
14762: GO 14765
14764: POP
// ChangeMissionObjectives ( MCar ) ;
14765: LD_STRING MCar
14767: PPUSH
14768: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14772: LD_INT 124
14774: PPUSH
14775: LD_INT 90
14777: PPUSH
14778: LD_INT 1
14780: PPUSH
14781: LD_INT 6
14783: NEG
14784: PPUSH
14785: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14789: LD_INT 124
14791: PPUSH
14792: LD_INT 90
14794: PPUSH
14795: LD_INT 1
14797: PPUSH
14798: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14802: LD_INT 12
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 424
// wait ( 3 ) ;
14812: LD_INT 3
14814: PPUSH
14815: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14819: LD_INT 124
14821: PPUSH
14822: LD_INT 90
14824: PPUSH
14825: CALL_OW 86
// cargo := false ;
14829: LD_ADDR_VAR 0 3
14833: PUSH
14834: LD_INT 0
14836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14837: LD_INT 35
14839: PPUSH
14840: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14844: LD_ADDR_VAR 0 3
14848: PUSH
14849: LD_INT 12
14851: PPUSH
14852: LD_INT 32
14854: PUSH
14855: LD_INT 3
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: LD_INT 34
14864: PUSH
14865: LD_INT 32
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: LD_INT 58
14874: PUSH
14875: EMPTY
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: LIST
14882: PPUSH
14883: CALL_OW 70
14887: ST_TO_ADDR
// until cargo ;
14888: LD_VAR 0 3
14892: IFFALSE 14837
// cargo := cargo [ 1 ] ;
14894: LD_ADDR_VAR 0 3
14898: PUSH
14899: LD_VAR 0 3
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14908: LD_VAR 0 3
14912: PPUSH
14913: LD_INT 5
14915: PPUSH
14916: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14920: LD_INT 12
14922: PPUSH
14923: LD_INT 0
14925: PPUSH
14926: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14930: LD_EXP 46
14934: PPUSH
14935: LD_INT 11
14937: PPUSH
14938: LD_INT 0
14940: PPUSH
14941: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14945: LD_EXP 47
14949: PPUSH
14950: LD_INT 11
14952: PPUSH
14953: LD_INT 0
14955: PPUSH
14956: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14960: LD_EXP 46
14964: PUSH
14965: LD_EXP 47
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PPUSH
14974: LD_INT 12
14976: PPUSH
14977: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14981: LD_EXP 46
14985: PPUSH
14986: LD_VAR 0 3
14990: PPUSH
14991: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14995: LD_EXP 46
14999: PUSH
15000: LD_EXP 47
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: PPUSH
15009: LD_INT 209
15011: PPUSH
15012: LD_INT 178
15014: PPUSH
15015: CALL_OW 171
// escaped := 0 ;
15019: LD_ADDR_VAR 0 5
15023: PUSH
15024: LD_INT 0
15026: ST_TO_ADDR
// while ( true ) do
15027: LD_INT 1
15029: IFFALSE 15245
// begin wait ( 0 0$1 ) ;
15031: LD_INT 35
15033: PPUSH
15034: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15038: LD_EXP 46
15042: PPUSH
15043: CALL_OW 314
15047: NOT
15048: PUSH
15049: LD_EXP 47
15053: PPUSH
15054: CALL_OW 314
15058: NOT
15059: OR
15060: IFFALSE 15086
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15062: LD_EXP 46
15066: PUSH
15067: LD_EXP 47
15071: PUSH
15072: EMPTY
15073: LIST
15074: LIST
15075: PPUSH
15076: LD_INT 209
15078: PPUSH
15079: LD_INT 178
15081: PPUSH
15082: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15086: LD_EXP 46
15090: PPUSH
15091: LD_INT 10
15093: PPUSH
15094: CALL_OW 308
15098: IFFALSE 15123
// begin RemoveUnit ( ar_mechanic ) ;
15100: LD_EXP 46
15104: PPUSH
15105: CALL_OW 64
// escaped := escaped + 1 ;
15109: LD_ADDR_VAR 0 5
15113: PUSH
15114: LD_VAR 0 5
15118: PUSH
15119: LD_INT 1
15121: PLUS
15122: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15123: LD_EXP 47
15127: PPUSH
15128: LD_INT 10
15130: PPUSH
15131: CALL_OW 308
15135: IFFALSE 15160
// begin RemoveUnit ( ar_mechanic_friend ) ;
15137: LD_EXP 47
15141: PPUSH
15142: CALL_OW 64
// escaped := escaped + 1 ;
15146: LD_ADDR_VAR 0 5
15150: PUSH
15151: LD_VAR 0 5
15155: PUSH
15156: LD_INT 1
15158: PLUS
15159: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15160: LD_VAR 0 3
15164: PPUSH
15165: LD_INT 10
15167: PPUSH
15168: CALL_OW 308
15172: IFFALSE 15183
// RemoveUnit ( cargo ) ;
15174: LD_VAR 0 3
15178: PPUSH
15179: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15183: LD_EXP 46
15187: PPUSH
15188: CALL_OW 305
15192: NOT
15193: PUSH
15194: LD_VAR 0 5
15198: PUSH
15199: LD_INT 2
15201: GREATEREQUAL
15202: AND
15203: IFFALSE 15207
// break ;
15205: GO 15245
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15207: LD_EXP 46
15211: PPUSH
15212: CALL_OW 305
15216: NOT
15217: PUSH
15218: LD_EXP 47
15222: PPUSH
15223: CALL_OW 305
15227: NOT
15228: AND
15229: PUSH
15230: LD_VAR 0 5
15234: PUSH
15235: LD_INT 2
15237: LESS
15238: AND
15239: IFFALSE 15243
// exit ;
15241: GO 15423
// end ;
15243: GO 15027
// wait ( 0 0$2 ) ;
15245: LD_INT 70
15247: PPUSH
15248: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15252: LD_EXP 46
15256: PPUSH
15257: LD_STRING D7a-Ar1-1
15259: PPUSH
15260: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15264: LD_ADDR_VAR 0 4
15268: PUSH
15269: LD_INT 129
15271: PUSH
15272: LD_INT 10
15274: PUSH
15275: EMPTY
15276: LIST
15277: LIST
15278: PUSH
15279: LD_INT 103
15281: PUSH
15282: LD_INT 6
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: PUSH
15289: LD_INT 148
15291: PUSH
15292: LD_INT 47
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: PUSH
15299: LD_INT 155
15301: PUSH
15302: LD_INT 16
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: PUSH
15309: EMPTY
15310: LIST
15311: LIST
15312: LIST
15313: LIST
15314: ST_TO_ADDR
// if Difficulty = 1 then
15315: LD_OWVAR 67
15319: PUSH
15320: LD_INT 1
15322: EQUAL
15323: IFFALSE 15360
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15325: LD_ADDR_VAR 0 4
15329: PUSH
15330: LD_VAR 0 4
15334: PUSH
15335: LD_INT 78
15337: PUSH
15338: LD_INT 7
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: PUSH
15345: LD_INT 104
15347: PUSH
15348: LD_INT 43
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: PUSH
15355: EMPTY
15356: LIST
15357: LIST
15358: ADD
15359: ST_TO_ADDR
// for i in tmp do
15360: LD_ADDR_VAR 0 2
15364: PUSH
15365: LD_VAR 0 4
15369: PUSH
15370: FOR_IN
15371: IFFALSE 15404
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15373: LD_VAR 0 2
15377: PUSH
15378: LD_INT 1
15380: ARRAY
15381: PPUSH
15382: LD_VAR 0 2
15386: PUSH
15387: LD_INT 2
15389: ARRAY
15390: PPUSH
15391: LD_INT 1
15393: PPUSH
15394: LD_INT 9
15396: NEG
15397: PPUSH
15398: CALL_OW 330
15402: GO 15370
15404: POP
15405: POP
// SetAchievement ( ACH_FRIEND ) ;
15406: LD_STRING ACH_FRIEND
15408: PPUSH
15409: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15413: LD_INT 129
15415: PPUSH
15416: LD_INT 10
15418: PPUSH
15419: CALL_OW 84
// end ;
15423: PPOPN 5
15425: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15426: LD_EXP 15
15430: PUSH
15431: LD_INT 21000
15433: MINUS
15434: PUSH
15435: LD_OWVAR 1
15439: LESSEQUAL
15440: IFFALSE 15480
15442: GO 15444
15444: DISABLE
// begin powell_warn := true ;
15445: LD_ADDR_EXP 16
15449: PUSH
15450: LD_INT 1
15452: ST_TO_ADDR
// DialogueOn ;
15453: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15457: LD_EXP 30
15461: PPUSH
15462: LD_STRING D9-Pow-1
15464: PPUSH
15465: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15469: LD_INT 10
15471: PPUSH
15472: CALL_OW 68
// DialogueOff ;
15476: CALL_OW 7
// end ;
15480: END
// every 0 0$1 trigger game_time <= tick do
15481: LD_EXP 15
15485: PUSH
15486: LD_OWVAR 1
15490: LESSEQUAL
15491: IFFALSE 15530
15493: GO 15495
15495: DISABLE
// begin DialogueOn ;
15496: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15500: LD_EXP 30
15504: PPUSH
15505: LD_STRING D9a-Pow-1
15507: PPUSH
15508: CALL_OW 94
// dwait ( 0 0$2 ) ;
15512: LD_INT 70
15514: PPUSH
15515: CALL_OW 68
// DialogueOff ;
15519: CALL_OW 7
// YouLost ( Command ) ;
15523: LD_STRING Command
15525: PPUSH
15526: CALL_OW 104
// end ;
15530: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15531: LD_INT 22
15533: PUSH
15534: LD_INT 2
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: LD_INT 30
15543: PUSH
15544: LD_INT 1
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PUSH
15551: EMPTY
15552: LIST
15553: LIST
15554: PPUSH
15555: CALL_OW 69
15559: PUSH
15560: LD_INT 0
15562: EQUAL
15563: PUSH
15564: LD_EXP 21
15568: PPUSH
15569: CALL_OW 302
15573: AND
15574: IFFALSE 16491
15576: GO 15578
15578: DISABLE
15579: LD_INT 0
15581: PPUSH
15582: PPUSH
15583: PPUSH
15584: PPUSH
// begin m1 := false ;
15585: LD_ADDR_VAR 0 2
15589: PUSH
15590: LD_INT 0
15592: ST_TO_ADDR
// m2 := false ;
15593: LD_ADDR_VAR 0 3
15597: PUSH
15598: LD_INT 0
15600: ST_TO_ADDR
// m3 := false ;
15601: LD_ADDR_VAR 0 4
15605: PUSH
15606: LD_INT 0
15608: ST_TO_ADDR
// if not am_veh_consturcted then
15609: LD_EXP 20
15613: NOT
15614: IFFALSE 15623
// SetAchievement ( ACH_ARABTECH ) ;
15616: LD_STRING ACH_ARABTECH
15618: PPUSH
15619: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15623: LD_OWVAR 1
15627: PUSH
15628: LD_INT 252000
15630: PUSH
15631: LD_INT 210000
15633: PUSH
15634: LD_INT 199500
15636: PUSH
15637: LD_INT 193200
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: PUSH
15646: LD_OWVAR 67
15650: ARRAY
15651: LESS
15652: IFFALSE 15674
// begin m3 := true ;
15654: LD_ADDR_VAR 0 4
15658: PUSH
15659: LD_INT 1
15661: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15662: LD_STRING Time1
15664: PPUSH
15665: LD_INT 1
15667: PPUSH
15668: CALL_OW 101
// end else
15672: GO 15705
// if not powell_warn then
15674: LD_EXP 16
15678: NOT
15679: IFFALSE 15694
// AddMedal ( Time1 , - 1 ) else
15681: LD_STRING Time1
15683: PPUSH
15684: LD_INT 1
15686: NEG
15687: PPUSH
15688: CALL_OW 101
15692: GO 15705
// AddMedal ( Time1 , - 2 ) ;
15694: LD_STRING Time1
15696: PPUSH
15697: LD_INT 2
15699: NEG
15700: PPUSH
15701: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15705: LD_EXP 17
15709: PUSH
15710: LD_INT 5
15712: PUSH
15713: LD_INT 4
15715: PUSH
15716: LD_INT 3
15718: PUSH
15719: LD_INT 3
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: LIST
15726: LIST
15727: PUSH
15728: LD_OWVAR 67
15732: ARRAY
15733: GREATEREQUAL
15734: IFFALSE 15749
// AddMedal ( Destroy , - 2 ) else
15736: LD_STRING Destroy
15738: PPUSH
15739: LD_INT 2
15741: NEG
15742: PPUSH
15743: CALL_OW 101
15747: GO 15882
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15749: LD_INT 22
15751: PUSH
15752: LD_INT 2
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PUSH
15759: LD_INT 21
15761: PUSH
15762: LD_INT 3
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: PUSH
15769: LD_INT 50
15771: PUSH
15772: EMPTY
15773: LIST
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: LIST
15779: PPUSH
15780: CALL_OW 69
15784: PUSH
15785: LD_INT 25
15787: GREATEREQUAL
15788: IFFALSE 15803
// AddMedal ( Destroy , - 1 ) else
15790: LD_STRING Destroy
15792: PPUSH
15793: LD_INT 1
15795: NEG
15796: PPUSH
15797: CALL_OW 101
15801: GO 15882
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15803: LD_INT 22
15805: PUSH
15806: LD_INT 2
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: LD_INT 21
15815: PUSH
15816: LD_INT 3
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: PUSH
15823: LD_INT 50
15825: PUSH
15826: EMPTY
15827: LIST
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: PPUSH
15834: CALL_OW 69
15838: PUSH
15839: LD_INT 15
15841: GREATEREQUAL
15842: IFFALSE 15864
// begin m1 := true ;
15844: LD_ADDR_VAR 0 2
15848: PUSH
15849: LD_INT 1
15851: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15852: LD_STRING Destroy
15854: PPUSH
15855: LD_INT 1
15857: PPUSH
15858: CALL_OW 101
// end else
15862: GO 15882
// begin m1 := true ;
15864: LD_ADDR_VAR 0 2
15868: PUSH
15869: LD_INT 1
15871: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15872: LD_STRING Destroy
15874: PPUSH
15875: LD_INT 2
15877: PPUSH
15878: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15882: LD_EXP 13
15886: PPUSH
15887: LD_STRING 11_artifact_captured
15889: PPUSH
15890: CALL_OW 39
// if artifact_get then
15894: LD_EXP 13
15898: IFFALSE 15920
// begin m2 := true ;
15900: LD_ADDR_VAR 0 3
15904: PUSH
15905: LD_INT 1
15907: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15908: LD_STRING Artefact
15910: PPUSH
15911: LD_INT 1
15913: PPUSH
15914: CALL_OW 101
// end else
15918: GO 15931
// AddMedal ( Artefact , - 1 ) ;
15920: LD_STRING Artefact
15922: PPUSH
15923: LD_INT 1
15925: NEG
15926: PPUSH
15927: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15931: LD_VAR 0 2
15935: PUSH
15936: LD_VAR 0 3
15940: AND
15941: PUSH
15942: LD_VAR 0 4
15946: AND
15947: PUSH
15948: LD_OWVAR 67
15952: PUSH
15953: LD_INT 3
15955: GREATEREQUAL
15956: AND
15957: IFFALSE 15969
// SetAchievementEX ( ACH_AMER , 11 ) ;
15959: LD_STRING ACH_AMER
15961: PPUSH
15962: LD_INT 11
15964: PPUSH
15965: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 3
15978: AND
15979: PUSH
15980: LD_VAR 0 4
15984: AND
15985: PUSH
15986: LD_EXP 17
15990: PUSH
15991: LD_INT 0
15993: EQUAL
15994: AND
15995: IFFALSE 16011
// begin wait ( 3 ) ;
15997: LD_INT 3
15999: PPUSH
16000: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16004: LD_STRING ACH_GENERAL
16006: PPUSH
16007: CALL_OW 543
// end ; if tick <= 100 100$00 then
16011: LD_OWVAR 1
16015: PUSH
16016: LD_INT 210000
16018: LESSEQUAL
16019: IFFALSE 16035
// begin wait ( 3 ) ;
16021: LD_INT 3
16023: PPUSH
16024: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16028: LD_STRING ACH_ASPEED_11
16030: PPUSH
16031: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16035: LD_STRING MAIN
16037: PPUSH
16038: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16042: LD_ADDR_EXP 19
16046: PUSH
16047: LD_EXP 19
16051: PPUSH
16052: LD_INT 51
16054: PUSH
16055: EMPTY
16056: LIST
16057: PPUSH
16058: CALL_OW 72
16062: ST_TO_ADDR
// tmp := JMM ^ selected ;
16063: LD_ADDR_VAR 0 1
16067: PUSH
16068: LD_EXP 21
16072: PUSH
16073: LD_EXP 19
16077: ADD
16078: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16079: LD_VAR 0 1
16083: PPUSH
16084: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16088: LD_VAR 0 1
16092: PUSH
16093: LD_EXP 21
16097: PUSH
16098: LD_EXP 22
16102: PUSH
16103: LD_EXP 23
16107: PUSH
16108: LD_EXP 24
16112: PUSH
16113: LD_EXP 25
16117: PUSH
16118: LD_EXP 26
16122: PUSH
16123: LD_EXP 27
16127: PUSH
16128: LD_EXP 28
16132: PUSH
16133: LD_EXP 29
16137: PUSH
16138: LD_EXP 31
16142: PUSH
16143: LD_EXP 32
16147: PUSH
16148: LD_EXP 33
16152: PUSH
16153: LD_EXP 34
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: LIST
16162: LIST
16163: LIST
16164: LIST
16165: LIST
16166: LIST
16167: LIST
16168: LIST
16169: LIST
16170: LIST
16171: LIST
16172: DIFF
16173: PPUSH
16174: LD_STRING 11c_others
16176: PPUSH
16177: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16181: LD_EXP 21
16185: PPUSH
16186: LD_EXP 3
16190: PUSH
16191: LD_STRING JMM
16193: STR
16194: PPUSH
16195: CALL_OW 38
// if Lisa then
16199: LD_EXP 22
16203: IFFALSE 16223
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16205: LD_EXP 22
16209: PPUSH
16210: LD_EXP 3
16214: PUSH
16215: LD_STRING Lisa
16217: STR
16218: PPUSH
16219: CALL_OW 38
// if Donaldson then
16223: LD_EXP 23
16227: IFFALSE 16247
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16229: LD_EXP 23
16233: PPUSH
16234: LD_EXP 3
16238: PUSH
16239: LD_STRING Donaldson
16241: STR
16242: PPUSH
16243: CALL_OW 38
// if Bobby then
16247: LD_EXP 24
16251: IFFALSE 16271
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16253: LD_EXP 24
16257: PPUSH
16258: LD_EXP 3
16262: PUSH
16263: LD_STRING Bobby
16265: STR
16266: PPUSH
16267: CALL_OW 38
// if Cyrus then
16271: LD_EXP 25
16275: IFFALSE 16295
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16277: LD_EXP 25
16281: PPUSH
16282: LD_EXP 3
16286: PUSH
16287: LD_STRING Cyrus
16289: STR
16290: PPUSH
16291: CALL_OW 38
// if Denis then
16295: LD_EXP 26
16299: IFFALSE 16319
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16301: LD_EXP 26
16305: PPUSH
16306: LD_EXP 3
16310: PUSH
16311: LD_STRING Denis
16313: STR
16314: PPUSH
16315: CALL_OW 38
// if Brown then
16319: LD_EXP 27
16323: IFFALSE 16343
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16325: LD_EXP 27
16329: PPUSH
16330: LD_EXP 3
16334: PUSH
16335: LD_STRING Brown
16337: STR
16338: PPUSH
16339: CALL_OW 38
// if Gladstone then
16343: LD_EXP 28
16347: IFFALSE 16367
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16349: LD_EXP 28
16353: PPUSH
16354: LD_EXP 3
16358: PUSH
16359: LD_STRING Gladstone
16361: STR
16362: PPUSH
16363: CALL_OW 38
// if Houten then
16367: LD_EXP 29
16371: IFFALSE 16391
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16373: LD_EXP 29
16377: PPUSH
16378: LD_EXP 3
16382: PUSH
16383: LD_STRING Houten
16385: STR
16386: PPUSH
16387: CALL_OW 38
// if Cornel then
16391: LD_EXP 31
16395: IFFALSE 16415
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16397: LD_EXP 31
16401: PPUSH
16402: LD_EXP 3
16406: PUSH
16407: LD_STRING Cornell
16409: STR
16410: PPUSH
16411: CALL_OW 38
// if Gary then
16415: LD_EXP 32
16419: IFFALSE 16439
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16421: LD_EXP 32
16425: PPUSH
16426: LD_EXP 3
16430: PUSH
16431: LD_STRING Gary
16433: STR
16434: PPUSH
16435: CALL_OW 38
// if Frank then
16439: LD_EXP 33
16443: IFFALSE 16463
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16445: LD_EXP 33
16449: PPUSH
16450: LD_EXP 3
16454: PUSH
16455: LD_STRING Frank
16457: STR
16458: PPUSH
16459: CALL_OW 38
// if Kikuchi then
16463: LD_EXP 34
16467: IFFALSE 16487
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16469: LD_EXP 34
16473: PPUSH
16474: LD_EXP 3
16478: PUSH
16479: LD_STRING Kikuchi
16481: STR
16482: PPUSH
16483: CALL_OW 38
// YouWin ;
16487: CALL_OW 103
// end ;
16491: PPOPN 4
16493: END
// export function CanSayRand ( side ) ; begin
16494: LD_INT 0
16496: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_INT 52
16504: PUSH
16505: EMPTY
16506: LIST
16507: PUSH
16508: LD_INT 22
16510: PUSH
16511: LD_VAR 0 1
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: PUSH
16520: LD_INT 2
16522: PUSH
16523: LD_INT 25
16525: PUSH
16526: LD_INT 1
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: PUSH
16533: LD_INT 25
16535: PUSH
16536: LD_INT 2
16538: PUSH
16539: EMPTY
16540: LIST
16541: LIST
16542: PUSH
16543: LD_INT 25
16545: PUSH
16546: LD_INT 3
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: PUSH
16553: LD_INT 25
16555: PUSH
16556: LD_INT 4
16558: PUSH
16559: EMPTY
16560: LIST
16561: LIST
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: LIST
16567: LIST
16568: LIST
16569: PUSH
16570: EMPTY
16571: LIST
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 69
16579: PUSH
16580: LD_EXP 21
16584: PUSH
16585: LD_EXP 33
16589: PUSH
16590: LD_EXP 22
16594: PUSH
16595: LD_EXP 23
16599: PUSH
16600: LD_EXP 24
16604: PUSH
16605: LD_EXP 25
16609: PUSH
16610: LD_EXP 26
16614: PUSH
16615: LD_EXP 27
16619: PUSH
16620: LD_EXP 28
16624: PUSH
16625: LD_EXP 29
16629: PUSH
16630: LD_EXP 30
16634: PUSH
16635: LD_EXP 31
16639: PUSH
16640: LD_EXP 32
16644: PUSH
16645: LD_EXP 34
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: LIST
16654: LIST
16655: LIST
16656: LIST
16657: LIST
16658: LIST
16659: LIST
16660: LIST
16661: LIST
16662: LIST
16663: LIST
16664: LIST
16665: DIFF
16666: ST_TO_ADDR
// end ;
16667: LD_VAR 0 2
16671: RET
// export function SayRand ( sex , dial ) ; begin
16672: LD_INT 0
16674: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16675: LD_ADDR_VAR 0 3
16679: PUSH
16680: LD_INT 52
16682: PUSH
16683: EMPTY
16684: LIST
16685: PUSH
16686: LD_INT 22
16688: PUSH
16689: LD_INT 1
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: PUSH
16696: LD_INT 26
16698: PUSH
16699: LD_VAR 0 1
16703: PUSH
16704: EMPTY
16705: LIST
16706: LIST
16707: PUSH
16708: LD_INT 2
16710: PUSH
16711: LD_INT 25
16713: PUSH
16714: LD_INT 1
16716: PUSH
16717: EMPTY
16718: LIST
16719: LIST
16720: PUSH
16721: LD_INT 25
16723: PUSH
16724: LD_INT 2
16726: PUSH
16727: EMPTY
16728: LIST
16729: LIST
16730: PUSH
16731: LD_INT 25
16733: PUSH
16734: LD_INT 3
16736: PUSH
16737: EMPTY
16738: LIST
16739: LIST
16740: PUSH
16741: LD_INT 25
16743: PUSH
16744: LD_INT 4
16746: PUSH
16747: EMPTY
16748: LIST
16749: LIST
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: LIST
16755: LIST
16756: LIST
16757: PUSH
16758: EMPTY
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: PPUSH
16764: CALL_OW 69
16768: PUSH
16769: LD_EXP 21
16773: PUSH
16774: LD_EXP 33
16778: PUSH
16779: LD_EXP 22
16783: PUSH
16784: LD_EXP 23
16788: PUSH
16789: LD_EXP 24
16793: PUSH
16794: LD_EXP 25
16798: PUSH
16799: LD_EXP 26
16803: PUSH
16804: LD_EXP 27
16808: PUSH
16809: LD_EXP 28
16813: PUSH
16814: LD_EXP 29
16818: PUSH
16819: LD_EXP 30
16823: PUSH
16824: LD_EXP 31
16828: PUSH
16829: LD_EXP 32
16833: PUSH
16834: LD_EXP 34
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: LIST
16847: LIST
16848: LIST
16849: LIST
16850: LIST
16851: LIST
16852: LIST
16853: LIST
16854: DIFF
16855: ST_TO_ADDR
// if not result then
16856: LD_VAR 0 3
16860: NOT
16861: IFFALSE 16865
// exit ;
16863: GO 16893
// result := result [ 1 ] ;
16865: LD_ADDR_VAR 0 3
16869: PUSH
16870: LD_VAR 0 3
16874: PUSH
16875: LD_INT 1
16877: ARRAY
16878: ST_TO_ADDR
// Say ( result , dial ) ;
16879: LD_VAR 0 3
16883: PPUSH
16884: LD_VAR 0 2
16888: PPUSH
16889: CALL_OW 88
// end ;
16893: LD_VAR 0 3
16897: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16898: LD_INT 0
16900: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16901: LD_ADDR_VAR 0 4
16905: PUSH
16906: LD_INT 22
16908: PUSH
16909: LD_INT 1
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: PUSH
16916: LD_INT 26
16918: PUSH
16919: LD_VAR 0 1
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 2
16930: PUSH
16931: LD_INT 25
16933: PUSH
16934: LD_INT 1
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: PUSH
16941: LD_INT 25
16943: PUSH
16944: LD_INT 2
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PUSH
16951: LD_INT 25
16953: PUSH
16954: LD_INT 3
16956: PUSH
16957: EMPTY
16958: LIST
16959: LIST
16960: PUSH
16961: LD_INT 25
16963: PUSH
16964: LD_INT 4
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: LIST
16977: PUSH
16978: EMPTY
16979: LIST
16980: LIST
16981: LIST
16982: PPUSH
16983: CALL_OW 69
16987: PUSH
16988: LD_EXP 21
16992: PUSH
16993: LD_EXP 33
16997: PUSH
16998: LD_EXP 22
17002: PUSH
17003: LD_EXP 23
17007: PUSH
17008: LD_EXP 24
17012: PUSH
17013: LD_EXP 25
17017: PUSH
17018: LD_EXP 26
17022: PUSH
17023: LD_EXP 27
17027: PUSH
17028: LD_EXP 28
17032: PUSH
17033: LD_EXP 29
17037: PUSH
17038: LD_EXP 30
17042: PUSH
17043: LD_EXP 31
17047: PUSH
17048: LD_EXP 32
17052: PUSH
17053: LD_EXP 34
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: LIST
17066: LIST
17067: LIST
17068: LIST
17069: LIST
17070: LIST
17071: LIST
17072: LIST
17073: PUSH
17074: LD_VAR 0 3
17078: ADD
17079: DIFF
17080: ST_TO_ADDR
// if not result then
17081: LD_VAR 0 4
17085: NOT
17086: IFFALSE 17090
// exit ;
17088: GO 17118
// result := result [ 1 ] ;
17090: LD_ADDR_VAR 0 4
17094: PUSH
17095: LD_VAR 0 4
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// Say ( result , dial ) ;
17104: LD_VAR 0 4
17108: PPUSH
17109: LD_VAR 0 2
17113: PPUSH
17114: CALL_OW 88
// end ; end_of_file
17118: LD_VAR 0 4
17122: RET
// export function CustomEvent ( event ) ; begin
17123: LD_INT 0
17125: PPUSH
// end ;
17126: LD_VAR 0 2
17130: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17131: LD_VAR 0 1
17135: PPUSH
17136: CALL_OW 255
17140: PUSH
17141: LD_INT 1
17143: EQUAL
17144: IFFALSE 17154
// artifact_get := true ;
17146: LD_ADDR_EXP 13
17150: PUSH
17151: LD_INT 1
17153: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17154: LD_VAR 0 1
17158: PPUSH
17159: CALL_OW 255
17163: PUSH
17164: LD_INT 2
17166: EQUAL
17167: IFFALSE 17185
// begin artifact_get := false ;
17169: LD_ADDR_EXP 13
17173: PUSH
17174: LD_INT 0
17176: ST_TO_ADDR
// artifact_stolen := true ;
17177: LD_ADDR_EXP 12
17181: PUSH
17182: LD_INT 1
17184: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17185: LD_ADDR_EXP 14
17189: PUSH
17190: LD_INT 1
17192: ST_TO_ADDR
// end ;
17193: PPOPN 2
17195: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17196: LD_ADDR_EXP 14
17200: PUSH
17201: LD_INT 0
17203: ST_TO_ADDR
// end ;
17204: PPOPN 2
17206: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17207: LD_VAR 0 1
17211: PPUSH
17212: CALL 105375 0 1
// if un = JMM then
17216: LD_VAR 0 1
17220: PUSH
17221: LD_EXP 21
17225: EQUAL
17226: IFFALSE 17237
// begin YouLost ( JMM ) ;
17228: LD_STRING JMM
17230: PPUSH
17231: CALL_OW 104
// exit ;
17235: GO 17369
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17237: LD_VAR 0 1
17241: PUSH
17242: LD_INT 22
17244: PUSH
17245: LD_INT 1
17247: PUSH
17248: EMPTY
17249: LIST
17250: LIST
17251: PUSH
17252: LD_INT 21
17254: PUSH
17255: LD_INT 1
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: PUSH
17262: LD_INT 2
17264: PUSH
17265: LD_INT 25
17267: PUSH
17268: LD_INT 1
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: PUSH
17275: LD_INT 25
17277: PUSH
17278: LD_INT 2
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: PUSH
17285: LD_INT 25
17287: PUSH
17288: LD_INT 3
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: PUSH
17295: LD_INT 25
17297: PUSH
17298: LD_INT 4
17300: PUSH
17301: EMPTY
17302: LIST
17303: LIST
17304: PUSH
17305: LD_INT 25
17307: PUSH
17308: LD_INT 5
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: PUSH
17315: LD_INT 25
17317: PUSH
17318: LD_INT 8
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: PUSH
17325: EMPTY
17326: LIST
17327: LIST
17328: LIST
17329: LIST
17330: LIST
17331: LIST
17332: LIST
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: LIST
17338: PPUSH
17339: CALL_OW 69
17343: IN
17344: IFFALSE 17360
// loses_counter := loses_counter + 1 ;
17346: LD_ADDR_EXP 17
17350: PUSH
17351: LD_EXP 17
17355: PUSH
17356: LD_INT 1
17358: PLUS
17359: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17360: LD_VAR 0 1
17364: PPUSH
17365: CALL 45557 0 1
// end ;
17369: PPOPN 1
17371: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17372: LD_VAR 0 1
17376: PPUSH
17377: LD_VAR 0 2
17381: PPUSH
17382: CALL 47889 0 2
// end ;
17386: PPOPN 2
17388: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17389: LD_VAR 0 1
17393: PPUSH
17394: CALL 47198 0 1
// end ;
17398: PPOPN 1
17400: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_VAR 0 2
17410: PPUSH
17411: LD_VAR 0 3
17415: PPUSH
17416: LD_VAR 0 4
17420: PPUSH
17421: LD_VAR 0 5
17425: PPUSH
17426: CALL 44873 0 5
// end ;
17430: PPOPN 5
17432: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17433: LD_VAR 0 1
17437: PPUSH
17438: LD_VAR 0 2
17442: PPUSH
17443: CALL 105495 0 2
// if GetNation ( vehicle ) = nation_american then
17447: LD_VAR 0 1
17451: PPUSH
17452: CALL_OW 248
17456: PUSH
17457: LD_INT 1
17459: EQUAL
17460: IFFALSE 17470
// am_veh_consturcted := true ;
17462: LD_ADDR_EXP 20
17466: PUSH
17467: LD_INT 1
17469: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17470: LD_VAR 0 1
17474: PPUSH
17475: LD_VAR 0 2
17479: PPUSH
17480: CALL 44464 0 2
// end ;
17484: PPOPN 2
17486: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17487: LD_VAR 0 1
17491: PPUSH
17492: CALL_OW 247
17496: PUSH
17497: LD_INT 2
17499: EQUAL
17500: IFFALSE 17504
// exit ;
17502: GO 17521
// if not kamikazed then
17504: LD_EXP 11
17508: NOT
17509: IFFALSE 17521
// kamikazed := unit ;
17511: LD_ADDR_EXP 11
17515: PUSH
17516: LD_VAR 0 1
17520: ST_TO_ADDR
// end ;
17521: PPOPN 1
17523: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17524: LD_INT 0
17526: PPUSH
17527: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17528: LD_VAR 0 1
17532: PPUSH
17533: LD_VAR 0 2
17537: PPUSH
17538: LD_VAR 0 3
17542: PPUSH
17543: LD_VAR 0 4
17547: PPUSH
17548: CALL 44302 0 4
// end ;
17552: PPOPN 6
17554: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17555: LD_VAR 0 1
17559: PPUSH
17560: LD_VAR 0 2
17564: PPUSH
17565: LD_VAR 0 3
17569: PPUSH
17570: CALL 44077 0 3
// end ;
17574: PPOPN 3
17576: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17577: LD_VAR 0 1
17581: PPUSH
17582: LD_VAR 0 2
17586: PPUSH
17587: CALL 45253 0 2
// end ;
17591: PPOPN 2
17593: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17594: LD_VAR 0 1
17598: PPUSH
17599: LD_VAR 0 2
17603: PPUSH
17604: CALL 43771 0 2
// end ;
17608: PPOPN 2
17610: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17611: LD_VAR 0 1
17615: PPUSH
17616: LD_VAR 0 2
17620: PPUSH
17621: CALL 43962 0 2
// end ;
17625: PPOPN 2
17627: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17628: LD_VAR 0 1
17632: PPUSH
17633: CALL 46957 0 1
// end ;
17637: PPOPN 1
17639: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17640: LD_VAR 0 1
17644: PPUSH
17645: LD_VAR 0 2
17649: PPUSH
17650: CALL 48184 0 2
// end ;
17654: PPOPN 2
17656: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17657: LD_VAR 0 1
17661: PPUSH
17662: LD_VAR 0 2
17666: PPUSH
17667: LD_VAR 0 3
17671: PPUSH
17672: LD_VAR 0 4
17676: PPUSH
17677: CALL 48400 0 4
// end ;
17681: PPOPN 4
17683: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17684: LD_VAR 0 1
17688: PPUSH
17689: CALL 105479 0 1
// end ; end_of_file
17693: PPOPN 1
17695: END
// every 0 0$1 trigger game do
17696: LD_EXP 2
17700: IFFALSE 17730
17702: GO 17704
17704: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17705: LD_INT 7
17707: PUSH
17708: LD_INT 6
17710: PUSH
17711: LD_INT 4
17713: PUSH
17714: LD_INT 6
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: PPUSH
17723: LD_INT 1750
17725: PPUSH
17726: CALL 17731 0 2
17730: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17731: LD_INT 0
17733: PPUSH
17734: PPUSH
17735: PPUSH
// if not areas then
17736: LD_VAR 0 1
17740: NOT
17741: IFFALSE 17745
// exit ;
17743: GO 17875
// repeat wait ( time ) ;
17745: LD_VAR 0 2
17749: PPUSH
17750: CALL_OW 67
// for i in areas do
17754: LD_ADDR_VAR 0 4
17758: PUSH
17759: LD_VAR 0 1
17763: PUSH
17764: FOR_IN
17765: IFFALSE 17834
// begin p := rand ( 1 , 90 ) ;
17767: LD_ADDR_VAR 0 5
17771: PUSH
17772: LD_INT 1
17774: PPUSH
17775: LD_INT 90
17777: PPUSH
17778: CALL_OW 12
17782: ST_TO_ADDR
// if Prob ( p ) then
17783: LD_VAR 0 5
17787: PPUSH
17788: CALL_OW 13
17792: IFFALSE 17832
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17794: LD_INT 2
17796: PPUSH
17797: LD_INT 5
17799: PPUSH
17800: CALL_OW 12
17804: PPUSH
17805: LD_VAR 0 4
17809: PPUSH
17810: LD_INT 1
17812: PPUSH
17813: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17817: LD_INT 735
17819: PPUSH
17820: LD_INT 1295
17822: PPUSH
17823: CALL_OW 12
17827: PPUSH
17828: CALL_OW 67
// end ; end ;
17832: GO 17764
17834: POP
17835: POP
// time := time + 0 0$3 ;
17836: LD_ADDR_VAR 0 2
17840: PUSH
17841: LD_VAR 0 2
17845: PUSH
17846: LD_INT 105
17848: PLUS
17849: ST_TO_ADDR
// if time > 6 6$00 then
17850: LD_VAR 0 2
17854: PUSH
17855: LD_INT 12600
17857: GREATER
17858: IFFALSE 17868
// time := 0 0$40 ;
17860: LD_ADDR_VAR 0 2
17864: PUSH
17865: LD_INT 1400
17867: ST_TO_ADDR
// until not game ;
17868: LD_EXP 2
17872: NOT
17873: IFFALSE 17745
// end ;
17875: LD_VAR 0 3
17879: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17880: LD_OWVAR 1
17884: PUSH
17885: LD_INT 84000
17887: PUSH
17888: LD_INT 73500
17890: PUSH
17891: LD_INT 63000
17893: PUSH
17894: LD_INT 52500
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: PUSH
17903: LD_OWVAR 67
17907: ARRAY
17908: LESS
17909: IFFALSE 17936
17911: GO 17913
17913: DISABLE
// begin enable ;
17914: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17915: LD_INT 1
17917: PPUSH
17918: LD_INT 5
17920: PPUSH
17921: CALL_OW 12
17925: PPUSH
17926: LD_INT 7
17928: PPUSH
17929: LD_INT 1
17931: PPUSH
17932: CALL_OW 55
// end ; end_of_file
17936: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17937: LD_INT 0
17939: PPUSH
17940: PPUSH
// skirmish := false ;
17941: LD_ADDR_EXP 48
17945: PUSH
17946: LD_INT 0
17948: ST_TO_ADDR
// debug_mc := false ;
17949: LD_ADDR_EXP 49
17953: PUSH
17954: LD_INT 0
17956: ST_TO_ADDR
// mc_bases := [ ] ;
17957: LD_ADDR_EXP 50
17961: PUSH
17962: EMPTY
17963: ST_TO_ADDR
// mc_sides := [ ] ;
17964: LD_ADDR_EXP 76
17968: PUSH
17969: EMPTY
17970: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17971: LD_ADDR_EXP 51
17975: PUSH
17976: EMPTY
17977: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17978: LD_ADDR_EXP 52
17982: PUSH
17983: EMPTY
17984: ST_TO_ADDR
// mc_need_heal := [ ] ;
17985: LD_ADDR_EXP 53
17989: PUSH
17990: EMPTY
17991: ST_TO_ADDR
// mc_healers := [ ] ;
17992: LD_ADDR_EXP 54
17996: PUSH
17997: EMPTY
17998: ST_TO_ADDR
// mc_build_list := [ ] ;
17999: LD_ADDR_EXP 55
18003: PUSH
18004: EMPTY
18005: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18006: LD_ADDR_EXP 82
18010: PUSH
18011: EMPTY
18012: ST_TO_ADDR
// mc_builders := [ ] ;
18013: LD_ADDR_EXP 56
18017: PUSH
18018: EMPTY
18019: ST_TO_ADDR
// mc_construct_list := [ ] ;
18020: LD_ADDR_EXP 57
18024: PUSH
18025: EMPTY
18026: ST_TO_ADDR
// mc_turret_list := [ ] ;
18027: LD_ADDR_EXP 58
18031: PUSH
18032: EMPTY
18033: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18034: LD_ADDR_EXP 59
18038: PUSH
18039: EMPTY
18040: ST_TO_ADDR
// mc_miners := [ ] ;
18041: LD_ADDR_EXP 64
18045: PUSH
18046: EMPTY
18047: ST_TO_ADDR
// mc_mines := [ ] ;
18048: LD_ADDR_EXP 63
18052: PUSH
18053: EMPTY
18054: ST_TO_ADDR
// mc_minefields := [ ] ;
18055: LD_ADDR_EXP 65
18059: PUSH
18060: EMPTY
18061: ST_TO_ADDR
// mc_crates := [ ] ;
18062: LD_ADDR_EXP 66
18066: PUSH
18067: EMPTY
18068: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18069: LD_ADDR_EXP 67
18073: PUSH
18074: EMPTY
18075: ST_TO_ADDR
// mc_crates_area := [ ] ;
18076: LD_ADDR_EXP 68
18080: PUSH
18081: EMPTY
18082: ST_TO_ADDR
// mc_vehicles := [ ] ;
18083: LD_ADDR_EXP 69
18087: PUSH
18088: EMPTY
18089: ST_TO_ADDR
// mc_attack := [ ] ;
18090: LD_ADDR_EXP 70
18094: PUSH
18095: EMPTY
18096: ST_TO_ADDR
// mc_produce := [ ] ;
18097: LD_ADDR_EXP 71
18101: PUSH
18102: EMPTY
18103: ST_TO_ADDR
// mc_defender := [ ] ;
18104: LD_ADDR_EXP 72
18108: PUSH
18109: EMPTY
18110: ST_TO_ADDR
// mc_parking := [ ] ;
18111: LD_ADDR_EXP 74
18115: PUSH
18116: EMPTY
18117: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18118: LD_ADDR_EXP 60
18122: PUSH
18123: EMPTY
18124: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18125: LD_ADDR_EXP 62
18129: PUSH
18130: EMPTY
18131: ST_TO_ADDR
// mc_scan := [ ] ;
18132: LD_ADDR_EXP 73
18136: PUSH
18137: EMPTY
18138: ST_TO_ADDR
// mc_scan_area := [ ] ;
18139: LD_ADDR_EXP 75
18143: PUSH
18144: EMPTY
18145: ST_TO_ADDR
// mc_tech := [ ] ;
18146: LD_ADDR_EXP 77
18150: PUSH
18151: EMPTY
18152: ST_TO_ADDR
// mc_class := [ ] ;
18153: LD_ADDR_EXP 91
18157: PUSH
18158: EMPTY
18159: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18160: LD_ADDR_EXP 92
18164: PUSH
18165: EMPTY
18166: ST_TO_ADDR
// mc_is_defending := [ ] ;
18167: LD_ADDR_EXP 93
18171: PUSH
18172: EMPTY
18173: ST_TO_ADDR
// end ;
18174: LD_VAR 0 1
18178: RET
// export function MC_Kill ( base ) ; begin
18179: LD_INT 0
18181: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18182: LD_ADDR_EXP 50
18186: PUSH
18187: LD_EXP 50
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: EMPTY
18198: PPUSH
18199: CALL_OW 1
18203: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18204: LD_ADDR_EXP 51
18208: PUSH
18209: LD_EXP 51
18213: PPUSH
18214: LD_VAR 0 1
18218: PPUSH
18219: EMPTY
18220: PPUSH
18221: CALL_OW 1
18225: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18226: LD_ADDR_EXP 52
18230: PUSH
18231: LD_EXP 52
18235: PPUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: EMPTY
18242: PPUSH
18243: CALL_OW 1
18247: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18248: LD_ADDR_EXP 53
18252: PUSH
18253: LD_EXP 53
18257: PPUSH
18258: LD_VAR 0 1
18262: PPUSH
18263: EMPTY
18264: PPUSH
18265: CALL_OW 1
18269: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18270: LD_ADDR_EXP 54
18274: PUSH
18275: LD_EXP 54
18279: PPUSH
18280: LD_VAR 0 1
18284: PPUSH
18285: EMPTY
18286: PPUSH
18287: CALL_OW 1
18291: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18292: LD_ADDR_EXP 55
18296: PUSH
18297: LD_EXP 55
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: EMPTY
18308: PPUSH
18309: CALL_OW 1
18313: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18314: LD_ADDR_EXP 56
18318: PUSH
18319: LD_EXP 56
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: EMPTY
18330: PPUSH
18331: CALL_OW 1
18335: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18336: LD_ADDR_EXP 57
18340: PUSH
18341: LD_EXP 57
18345: PPUSH
18346: LD_VAR 0 1
18350: PPUSH
18351: EMPTY
18352: PPUSH
18353: CALL_OW 1
18357: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18358: LD_ADDR_EXP 58
18362: PUSH
18363: LD_EXP 58
18367: PPUSH
18368: LD_VAR 0 1
18372: PPUSH
18373: EMPTY
18374: PPUSH
18375: CALL_OW 1
18379: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18380: LD_ADDR_EXP 59
18384: PUSH
18385: LD_EXP 59
18389: PPUSH
18390: LD_VAR 0 1
18394: PPUSH
18395: EMPTY
18396: PPUSH
18397: CALL_OW 1
18401: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18402: LD_ADDR_EXP 60
18406: PUSH
18407: LD_EXP 60
18411: PPUSH
18412: LD_VAR 0 1
18416: PPUSH
18417: EMPTY
18418: PPUSH
18419: CALL_OW 1
18423: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18424: LD_ADDR_EXP 61
18428: PUSH
18429: LD_EXP 61
18433: PPUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: LD_INT 0
18441: PPUSH
18442: CALL_OW 1
18446: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18447: LD_ADDR_EXP 62
18451: PUSH
18452: LD_EXP 62
18456: PPUSH
18457: LD_VAR 0 1
18461: PPUSH
18462: EMPTY
18463: PPUSH
18464: CALL_OW 1
18468: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18469: LD_ADDR_EXP 63
18473: PUSH
18474: LD_EXP 63
18478: PPUSH
18479: LD_VAR 0 1
18483: PPUSH
18484: EMPTY
18485: PPUSH
18486: CALL_OW 1
18490: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18491: LD_ADDR_EXP 64
18495: PUSH
18496: LD_EXP 64
18500: PPUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: EMPTY
18507: PPUSH
18508: CALL_OW 1
18512: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18513: LD_ADDR_EXP 65
18517: PUSH
18518: LD_EXP 65
18522: PPUSH
18523: LD_VAR 0 1
18527: PPUSH
18528: EMPTY
18529: PPUSH
18530: CALL_OW 1
18534: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18535: LD_ADDR_EXP 66
18539: PUSH
18540: LD_EXP 66
18544: PPUSH
18545: LD_VAR 0 1
18549: PPUSH
18550: EMPTY
18551: PPUSH
18552: CALL_OW 1
18556: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18557: LD_ADDR_EXP 67
18561: PUSH
18562: LD_EXP 67
18566: PPUSH
18567: LD_VAR 0 1
18571: PPUSH
18572: EMPTY
18573: PPUSH
18574: CALL_OW 1
18578: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18579: LD_ADDR_EXP 68
18583: PUSH
18584: LD_EXP 68
18588: PPUSH
18589: LD_VAR 0 1
18593: PPUSH
18594: EMPTY
18595: PPUSH
18596: CALL_OW 1
18600: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18601: LD_ADDR_EXP 69
18605: PUSH
18606: LD_EXP 69
18610: PPUSH
18611: LD_VAR 0 1
18615: PPUSH
18616: EMPTY
18617: PPUSH
18618: CALL_OW 1
18622: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18623: LD_ADDR_EXP 70
18627: PUSH
18628: LD_EXP 70
18632: PPUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: EMPTY
18639: PPUSH
18640: CALL_OW 1
18644: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18645: LD_ADDR_EXP 71
18649: PUSH
18650: LD_EXP 71
18654: PPUSH
18655: LD_VAR 0 1
18659: PPUSH
18660: EMPTY
18661: PPUSH
18662: CALL_OW 1
18666: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18667: LD_ADDR_EXP 72
18671: PUSH
18672: LD_EXP 72
18676: PPUSH
18677: LD_VAR 0 1
18681: PPUSH
18682: EMPTY
18683: PPUSH
18684: CALL_OW 1
18688: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18689: LD_ADDR_EXP 73
18693: PUSH
18694: LD_EXP 73
18698: PPUSH
18699: LD_VAR 0 1
18703: PPUSH
18704: EMPTY
18705: PPUSH
18706: CALL_OW 1
18710: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18711: LD_ADDR_EXP 74
18715: PUSH
18716: LD_EXP 74
18720: PPUSH
18721: LD_VAR 0 1
18725: PPUSH
18726: EMPTY
18727: PPUSH
18728: CALL_OW 1
18732: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18733: LD_ADDR_EXP 75
18737: PUSH
18738: LD_EXP 75
18742: PPUSH
18743: LD_VAR 0 1
18747: PPUSH
18748: EMPTY
18749: PPUSH
18750: CALL_OW 1
18754: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18755: LD_ADDR_EXP 77
18759: PUSH
18760: LD_EXP 77
18764: PPUSH
18765: LD_VAR 0 1
18769: PPUSH
18770: EMPTY
18771: PPUSH
18772: CALL_OW 1
18776: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18777: LD_ADDR_EXP 79
18781: PUSH
18782: LD_EXP 79
18786: PPUSH
18787: LD_VAR 0 1
18791: PPUSH
18792: EMPTY
18793: PPUSH
18794: CALL_OW 1
18798: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18799: LD_ADDR_EXP 80
18803: PUSH
18804: LD_EXP 80
18808: PPUSH
18809: LD_VAR 0 1
18813: PPUSH
18814: EMPTY
18815: PPUSH
18816: CALL_OW 1
18820: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18821: LD_ADDR_EXP 81
18825: PUSH
18826: LD_EXP 81
18830: PPUSH
18831: LD_VAR 0 1
18835: PPUSH
18836: EMPTY
18837: PPUSH
18838: CALL_OW 1
18842: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18843: LD_ADDR_EXP 82
18847: PUSH
18848: LD_EXP 82
18852: PPUSH
18853: LD_VAR 0 1
18857: PPUSH
18858: EMPTY
18859: PPUSH
18860: CALL_OW 1
18864: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18865: LD_ADDR_EXP 83
18869: PUSH
18870: LD_EXP 83
18874: PPUSH
18875: LD_VAR 0 1
18879: PPUSH
18880: EMPTY
18881: PPUSH
18882: CALL_OW 1
18886: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18887: LD_ADDR_EXP 84
18891: PUSH
18892: LD_EXP 84
18896: PPUSH
18897: LD_VAR 0 1
18901: PPUSH
18902: EMPTY
18903: PPUSH
18904: CALL_OW 1
18908: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18909: LD_ADDR_EXP 85
18913: PUSH
18914: LD_EXP 85
18918: PPUSH
18919: LD_VAR 0 1
18923: PPUSH
18924: EMPTY
18925: PPUSH
18926: CALL_OW 1
18930: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18931: LD_ADDR_EXP 86
18935: PUSH
18936: LD_EXP 86
18940: PPUSH
18941: LD_VAR 0 1
18945: PPUSH
18946: EMPTY
18947: PPUSH
18948: CALL_OW 1
18952: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18953: LD_ADDR_EXP 87
18957: PUSH
18958: LD_EXP 87
18962: PPUSH
18963: LD_VAR 0 1
18967: PPUSH
18968: EMPTY
18969: PPUSH
18970: CALL_OW 1
18974: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18975: LD_ADDR_EXP 88
18979: PUSH
18980: LD_EXP 88
18984: PPUSH
18985: LD_VAR 0 1
18989: PPUSH
18990: EMPTY
18991: PPUSH
18992: CALL_OW 1
18996: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18997: LD_ADDR_EXP 89
19001: PUSH
19002: LD_EXP 89
19006: PPUSH
19007: LD_VAR 0 1
19011: PPUSH
19012: EMPTY
19013: PPUSH
19014: CALL_OW 1
19018: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19019: LD_ADDR_EXP 90
19023: PUSH
19024: LD_EXP 90
19028: PPUSH
19029: LD_VAR 0 1
19033: PPUSH
19034: EMPTY
19035: PPUSH
19036: CALL_OW 1
19040: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19041: LD_ADDR_EXP 91
19045: PUSH
19046: LD_EXP 91
19050: PPUSH
19051: LD_VAR 0 1
19055: PPUSH
19056: EMPTY
19057: PPUSH
19058: CALL_OW 1
19062: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19063: LD_ADDR_EXP 92
19067: PUSH
19068: LD_EXP 92
19072: PPUSH
19073: LD_VAR 0 1
19077: PPUSH
19078: LD_INT 0
19080: PPUSH
19081: CALL_OW 1
19085: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19086: LD_ADDR_EXP 93
19090: PUSH
19091: LD_EXP 93
19095: PPUSH
19096: LD_VAR 0 1
19100: PPUSH
19101: LD_INT 0
19103: PPUSH
19104: CALL_OW 1
19108: ST_TO_ADDR
// end ;
19109: LD_VAR 0 2
19113: RET
// export function MC_Add ( side , units ) ; var base ; begin
19114: LD_INT 0
19116: PPUSH
19117: PPUSH
// base := mc_bases + 1 ;
19118: LD_ADDR_VAR 0 4
19122: PUSH
19123: LD_EXP 50
19127: PUSH
19128: LD_INT 1
19130: PLUS
19131: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19132: LD_ADDR_EXP 76
19136: PUSH
19137: LD_EXP 76
19141: PPUSH
19142: LD_VAR 0 4
19146: PPUSH
19147: LD_VAR 0 1
19151: PPUSH
19152: CALL_OW 1
19156: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19157: LD_ADDR_EXP 50
19161: PUSH
19162: LD_EXP 50
19166: PPUSH
19167: LD_VAR 0 4
19171: PPUSH
19172: LD_VAR 0 2
19176: PPUSH
19177: CALL_OW 1
19181: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19182: LD_ADDR_EXP 51
19186: PUSH
19187: LD_EXP 51
19191: PPUSH
19192: LD_VAR 0 4
19196: PPUSH
19197: EMPTY
19198: PPUSH
19199: CALL_OW 1
19203: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19204: LD_ADDR_EXP 52
19208: PUSH
19209: LD_EXP 52
19213: PPUSH
19214: LD_VAR 0 4
19218: PPUSH
19219: EMPTY
19220: PPUSH
19221: CALL_OW 1
19225: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19226: LD_ADDR_EXP 53
19230: PUSH
19231: LD_EXP 53
19235: PPUSH
19236: LD_VAR 0 4
19240: PPUSH
19241: EMPTY
19242: PPUSH
19243: CALL_OW 1
19247: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19248: LD_ADDR_EXP 54
19252: PUSH
19253: LD_EXP 54
19257: PPUSH
19258: LD_VAR 0 4
19262: PPUSH
19263: EMPTY
19264: PPUSH
19265: CALL_OW 1
19269: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19270: LD_ADDR_EXP 55
19274: PUSH
19275: LD_EXP 55
19279: PPUSH
19280: LD_VAR 0 4
19284: PPUSH
19285: EMPTY
19286: PPUSH
19287: CALL_OW 1
19291: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19292: LD_ADDR_EXP 56
19296: PUSH
19297: LD_EXP 56
19301: PPUSH
19302: LD_VAR 0 4
19306: PPUSH
19307: EMPTY
19308: PPUSH
19309: CALL_OW 1
19313: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19314: LD_ADDR_EXP 57
19318: PUSH
19319: LD_EXP 57
19323: PPUSH
19324: LD_VAR 0 4
19328: PPUSH
19329: EMPTY
19330: PPUSH
19331: CALL_OW 1
19335: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19336: LD_ADDR_EXP 58
19340: PUSH
19341: LD_EXP 58
19345: PPUSH
19346: LD_VAR 0 4
19350: PPUSH
19351: EMPTY
19352: PPUSH
19353: CALL_OW 1
19357: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19358: LD_ADDR_EXP 59
19362: PUSH
19363: LD_EXP 59
19367: PPUSH
19368: LD_VAR 0 4
19372: PPUSH
19373: EMPTY
19374: PPUSH
19375: CALL_OW 1
19379: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19380: LD_ADDR_EXP 60
19384: PUSH
19385: LD_EXP 60
19389: PPUSH
19390: LD_VAR 0 4
19394: PPUSH
19395: EMPTY
19396: PPUSH
19397: CALL_OW 1
19401: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19402: LD_ADDR_EXP 61
19406: PUSH
19407: LD_EXP 61
19411: PPUSH
19412: LD_VAR 0 4
19416: PPUSH
19417: LD_INT 0
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19425: LD_ADDR_EXP 62
19429: PUSH
19430: LD_EXP 62
19434: PPUSH
19435: LD_VAR 0 4
19439: PPUSH
19440: EMPTY
19441: PPUSH
19442: CALL_OW 1
19446: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19447: LD_ADDR_EXP 63
19451: PUSH
19452: LD_EXP 63
19456: PPUSH
19457: LD_VAR 0 4
19461: PPUSH
19462: EMPTY
19463: PPUSH
19464: CALL_OW 1
19468: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19469: LD_ADDR_EXP 64
19473: PUSH
19474: LD_EXP 64
19478: PPUSH
19479: LD_VAR 0 4
19483: PPUSH
19484: EMPTY
19485: PPUSH
19486: CALL_OW 1
19490: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19491: LD_ADDR_EXP 65
19495: PUSH
19496: LD_EXP 65
19500: PPUSH
19501: LD_VAR 0 4
19505: PPUSH
19506: EMPTY
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19513: LD_ADDR_EXP 66
19517: PUSH
19518: LD_EXP 66
19522: PPUSH
19523: LD_VAR 0 4
19527: PPUSH
19528: EMPTY
19529: PPUSH
19530: CALL_OW 1
19534: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19535: LD_ADDR_EXP 67
19539: PUSH
19540: LD_EXP 67
19544: PPUSH
19545: LD_VAR 0 4
19549: PPUSH
19550: EMPTY
19551: PPUSH
19552: CALL_OW 1
19556: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19557: LD_ADDR_EXP 68
19561: PUSH
19562: LD_EXP 68
19566: PPUSH
19567: LD_VAR 0 4
19571: PPUSH
19572: EMPTY
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19579: LD_ADDR_EXP 69
19583: PUSH
19584: LD_EXP 69
19588: PPUSH
19589: LD_VAR 0 4
19593: PPUSH
19594: EMPTY
19595: PPUSH
19596: CALL_OW 1
19600: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19601: LD_ADDR_EXP 70
19605: PUSH
19606: LD_EXP 70
19610: PPUSH
19611: LD_VAR 0 4
19615: PPUSH
19616: EMPTY
19617: PPUSH
19618: CALL_OW 1
19622: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19623: LD_ADDR_EXP 71
19627: PUSH
19628: LD_EXP 71
19632: PPUSH
19633: LD_VAR 0 4
19637: PPUSH
19638: EMPTY
19639: PPUSH
19640: CALL_OW 1
19644: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19645: LD_ADDR_EXP 72
19649: PUSH
19650: LD_EXP 72
19654: PPUSH
19655: LD_VAR 0 4
19659: PPUSH
19660: EMPTY
19661: PPUSH
19662: CALL_OW 1
19666: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19667: LD_ADDR_EXP 73
19671: PUSH
19672: LD_EXP 73
19676: PPUSH
19677: LD_VAR 0 4
19681: PPUSH
19682: EMPTY
19683: PPUSH
19684: CALL_OW 1
19688: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19689: LD_ADDR_EXP 74
19693: PUSH
19694: LD_EXP 74
19698: PPUSH
19699: LD_VAR 0 4
19703: PPUSH
19704: EMPTY
19705: PPUSH
19706: CALL_OW 1
19710: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19711: LD_ADDR_EXP 75
19715: PUSH
19716: LD_EXP 75
19720: PPUSH
19721: LD_VAR 0 4
19725: PPUSH
19726: EMPTY
19727: PPUSH
19728: CALL_OW 1
19732: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19733: LD_ADDR_EXP 77
19737: PUSH
19738: LD_EXP 77
19742: PPUSH
19743: LD_VAR 0 4
19747: PPUSH
19748: EMPTY
19749: PPUSH
19750: CALL_OW 1
19754: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19755: LD_ADDR_EXP 79
19759: PUSH
19760: LD_EXP 79
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: EMPTY
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19777: LD_ADDR_EXP 80
19781: PUSH
19782: LD_EXP 80
19786: PPUSH
19787: LD_VAR 0 4
19791: PPUSH
19792: EMPTY
19793: PPUSH
19794: CALL_OW 1
19798: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19799: LD_ADDR_EXP 81
19803: PUSH
19804: LD_EXP 81
19808: PPUSH
19809: LD_VAR 0 4
19813: PPUSH
19814: EMPTY
19815: PPUSH
19816: CALL_OW 1
19820: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19821: LD_ADDR_EXP 82
19825: PUSH
19826: LD_EXP 82
19830: PPUSH
19831: LD_VAR 0 4
19835: PPUSH
19836: EMPTY
19837: PPUSH
19838: CALL_OW 1
19842: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19843: LD_ADDR_EXP 83
19847: PUSH
19848: LD_EXP 83
19852: PPUSH
19853: LD_VAR 0 4
19857: PPUSH
19858: EMPTY
19859: PPUSH
19860: CALL_OW 1
19864: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19865: LD_ADDR_EXP 84
19869: PUSH
19870: LD_EXP 84
19874: PPUSH
19875: LD_VAR 0 4
19879: PPUSH
19880: EMPTY
19881: PPUSH
19882: CALL_OW 1
19886: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19887: LD_ADDR_EXP 85
19891: PUSH
19892: LD_EXP 85
19896: PPUSH
19897: LD_VAR 0 4
19901: PPUSH
19902: EMPTY
19903: PPUSH
19904: CALL_OW 1
19908: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19909: LD_ADDR_EXP 86
19913: PUSH
19914: LD_EXP 86
19918: PPUSH
19919: LD_VAR 0 4
19923: PPUSH
19924: EMPTY
19925: PPUSH
19926: CALL_OW 1
19930: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19931: LD_ADDR_EXP 87
19935: PUSH
19936: LD_EXP 87
19940: PPUSH
19941: LD_VAR 0 4
19945: PPUSH
19946: EMPTY
19947: PPUSH
19948: CALL_OW 1
19952: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19953: LD_ADDR_EXP 88
19957: PUSH
19958: LD_EXP 88
19962: PPUSH
19963: LD_VAR 0 4
19967: PPUSH
19968: EMPTY
19969: PPUSH
19970: CALL_OW 1
19974: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19975: LD_ADDR_EXP 89
19979: PUSH
19980: LD_EXP 89
19984: PPUSH
19985: LD_VAR 0 4
19989: PPUSH
19990: EMPTY
19991: PPUSH
19992: CALL_OW 1
19996: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19997: LD_ADDR_EXP 90
20001: PUSH
20002: LD_EXP 90
20006: PPUSH
20007: LD_VAR 0 4
20011: PPUSH
20012: EMPTY
20013: PPUSH
20014: CALL_OW 1
20018: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20019: LD_ADDR_EXP 91
20023: PUSH
20024: LD_EXP 91
20028: PPUSH
20029: LD_VAR 0 4
20033: PPUSH
20034: EMPTY
20035: PPUSH
20036: CALL_OW 1
20040: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20041: LD_ADDR_EXP 92
20045: PUSH
20046: LD_EXP 92
20050: PPUSH
20051: LD_VAR 0 4
20055: PPUSH
20056: LD_INT 0
20058: PPUSH
20059: CALL_OW 1
20063: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20064: LD_ADDR_EXP 93
20068: PUSH
20069: LD_EXP 93
20073: PPUSH
20074: LD_VAR 0 4
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// result := base ;
20087: LD_ADDR_VAR 0 3
20091: PUSH
20092: LD_VAR 0 4
20096: ST_TO_ADDR
// end ;
20097: LD_VAR 0 3
20101: RET
// export function MC_Start ( ) ; var i ; begin
20102: LD_INT 0
20104: PPUSH
20105: PPUSH
// for i = 1 to mc_bases do
20106: LD_ADDR_VAR 0 2
20110: PUSH
20111: DOUBLE
20112: LD_INT 1
20114: DEC
20115: ST_TO_ADDR
20116: LD_EXP 50
20120: PUSH
20121: FOR_TO
20122: IFFALSE 21222
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20124: LD_ADDR_EXP 50
20128: PUSH
20129: LD_EXP 50
20133: PPUSH
20134: LD_VAR 0 2
20138: PPUSH
20139: LD_EXP 50
20143: PUSH
20144: LD_VAR 0 2
20148: ARRAY
20149: PUSH
20150: LD_INT 0
20152: DIFF
20153: PPUSH
20154: CALL_OW 1
20158: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20159: LD_ADDR_EXP 51
20163: PUSH
20164: LD_EXP 51
20168: PPUSH
20169: LD_VAR 0 2
20173: PPUSH
20174: EMPTY
20175: PPUSH
20176: CALL_OW 1
20180: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20181: LD_ADDR_EXP 52
20185: PUSH
20186: LD_EXP 52
20190: PPUSH
20191: LD_VAR 0 2
20195: PPUSH
20196: EMPTY
20197: PPUSH
20198: CALL_OW 1
20202: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20203: LD_ADDR_EXP 53
20207: PUSH
20208: LD_EXP 53
20212: PPUSH
20213: LD_VAR 0 2
20217: PPUSH
20218: EMPTY
20219: PPUSH
20220: CALL_OW 1
20224: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20225: LD_ADDR_EXP 54
20229: PUSH
20230: LD_EXP 54
20234: PPUSH
20235: LD_VAR 0 2
20239: PPUSH
20240: EMPTY
20241: PUSH
20242: EMPTY
20243: PUSH
20244: EMPTY
20245: LIST
20246: LIST
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20253: LD_ADDR_EXP 55
20257: PUSH
20258: LD_EXP 55
20262: PPUSH
20263: LD_VAR 0 2
20267: PPUSH
20268: EMPTY
20269: PPUSH
20270: CALL_OW 1
20274: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20275: LD_ADDR_EXP 82
20279: PUSH
20280: LD_EXP 82
20284: PPUSH
20285: LD_VAR 0 2
20289: PPUSH
20290: EMPTY
20291: PPUSH
20292: CALL_OW 1
20296: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20297: LD_ADDR_EXP 56
20301: PUSH
20302: LD_EXP 56
20306: PPUSH
20307: LD_VAR 0 2
20311: PPUSH
20312: EMPTY
20313: PPUSH
20314: CALL_OW 1
20318: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20319: LD_ADDR_EXP 57
20323: PUSH
20324: LD_EXP 57
20328: PPUSH
20329: LD_VAR 0 2
20333: PPUSH
20334: EMPTY
20335: PPUSH
20336: CALL_OW 1
20340: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20341: LD_ADDR_EXP 58
20345: PUSH
20346: LD_EXP 58
20350: PPUSH
20351: LD_VAR 0 2
20355: PPUSH
20356: LD_EXP 50
20360: PUSH
20361: LD_VAR 0 2
20365: ARRAY
20366: PPUSH
20367: LD_INT 2
20369: PUSH
20370: LD_INT 30
20372: PUSH
20373: LD_INT 32
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: PUSH
20380: LD_INT 30
20382: PUSH
20383: LD_INT 33
20385: PUSH
20386: EMPTY
20387: LIST
20388: LIST
20389: PUSH
20390: EMPTY
20391: LIST
20392: LIST
20393: LIST
20394: PPUSH
20395: CALL_OW 72
20399: PPUSH
20400: CALL_OW 1
20404: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20405: LD_ADDR_EXP 59
20409: PUSH
20410: LD_EXP 59
20414: PPUSH
20415: LD_VAR 0 2
20419: PPUSH
20420: LD_EXP 50
20424: PUSH
20425: LD_VAR 0 2
20429: ARRAY
20430: PPUSH
20431: LD_INT 2
20433: PUSH
20434: LD_INT 30
20436: PUSH
20437: LD_INT 32
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: PUSH
20444: LD_INT 30
20446: PUSH
20447: LD_INT 31
20449: PUSH
20450: EMPTY
20451: LIST
20452: LIST
20453: PUSH
20454: EMPTY
20455: LIST
20456: LIST
20457: LIST
20458: PUSH
20459: LD_INT 58
20461: PUSH
20462: EMPTY
20463: LIST
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: PPUSH
20469: CALL_OW 72
20473: PPUSH
20474: CALL_OW 1
20478: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20479: LD_ADDR_EXP 60
20483: PUSH
20484: LD_EXP 60
20488: PPUSH
20489: LD_VAR 0 2
20493: PPUSH
20494: EMPTY
20495: PPUSH
20496: CALL_OW 1
20500: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20501: LD_ADDR_EXP 64
20505: PUSH
20506: LD_EXP 64
20510: PPUSH
20511: LD_VAR 0 2
20515: PPUSH
20516: EMPTY
20517: PPUSH
20518: CALL_OW 1
20522: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20523: LD_ADDR_EXP 63
20527: PUSH
20528: LD_EXP 63
20532: PPUSH
20533: LD_VAR 0 2
20537: PPUSH
20538: EMPTY
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20545: LD_ADDR_EXP 65
20549: PUSH
20550: LD_EXP 65
20554: PPUSH
20555: LD_VAR 0 2
20559: PPUSH
20560: EMPTY
20561: PPUSH
20562: CALL_OW 1
20566: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20567: LD_ADDR_EXP 66
20571: PUSH
20572: LD_EXP 66
20576: PPUSH
20577: LD_VAR 0 2
20581: PPUSH
20582: EMPTY
20583: PPUSH
20584: CALL_OW 1
20588: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20589: LD_ADDR_EXP 67
20593: PUSH
20594: LD_EXP 67
20598: PPUSH
20599: LD_VAR 0 2
20603: PPUSH
20604: EMPTY
20605: PPUSH
20606: CALL_OW 1
20610: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20611: LD_ADDR_EXP 68
20615: PUSH
20616: LD_EXP 68
20620: PPUSH
20621: LD_VAR 0 2
20625: PPUSH
20626: EMPTY
20627: PPUSH
20628: CALL_OW 1
20632: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20633: LD_ADDR_EXP 69
20637: PUSH
20638: LD_EXP 69
20642: PPUSH
20643: LD_VAR 0 2
20647: PPUSH
20648: EMPTY
20649: PPUSH
20650: CALL_OW 1
20654: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20655: LD_ADDR_EXP 70
20659: PUSH
20660: LD_EXP 70
20664: PPUSH
20665: LD_VAR 0 2
20669: PPUSH
20670: EMPTY
20671: PPUSH
20672: CALL_OW 1
20676: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20677: LD_ADDR_EXP 71
20681: PUSH
20682: LD_EXP 71
20686: PPUSH
20687: LD_VAR 0 2
20691: PPUSH
20692: EMPTY
20693: PPUSH
20694: CALL_OW 1
20698: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20699: LD_ADDR_EXP 72
20703: PUSH
20704: LD_EXP 72
20708: PPUSH
20709: LD_VAR 0 2
20713: PPUSH
20714: EMPTY
20715: PPUSH
20716: CALL_OW 1
20720: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20721: LD_ADDR_EXP 61
20725: PUSH
20726: LD_EXP 61
20730: PPUSH
20731: LD_VAR 0 2
20735: PPUSH
20736: LD_INT 0
20738: PPUSH
20739: CALL_OW 1
20743: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20744: LD_ADDR_EXP 74
20748: PUSH
20749: LD_EXP 74
20753: PPUSH
20754: LD_VAR 0 2
20758: PPUSH
20759: LD_INT 0
20761: PPUSH
20762: CALL_OW 1
20766: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20767: LD_ADDR_EXP 62
20771: PUSH
20772: LD_EXP 62
20776: PPUSH
20777: LD_VAR 0 2
20781: PPUSH
20782: EMPTY
20783: PPUSH
20784: CALL_OW 1
20788: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20789: LD_ADDR_EXP 73
20793: PUSH
20794: LD_EXP 73
20798: PPUSH
20799: LD_VAR 0 2
20803: PPUSH
20804: LD_INT 0
20806: PPUSH
20807: CALL_OW 1
20811: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20812: LD_ADDR_EXP 75
20816: PUSH
20817: LD_EXP 75
20821: PPUSH
20822: LD_VAR 0 2
20826: PPUSH
20827: EMPTY
20828: PPUSH
20829: CALL_OW 1
20833: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20834: LD_ADDR_EXP 78
20838: PUSH
20839: LD_EXP 78
20843: PPUSH
20844: LD_VAR 0 2
20848: PPUSH
20849: LD_INT 0
20851: PPUSH
20852: CALL_OW 1
20856: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20857: LD_ADDR_EXP 79
20861: PUSH
20862: LD_EXP 79
20866: PPUSH
20867: LD_VAR 0 2
20871: PPUSH
20872: EMPTY
20873: PPUSH
20874: CALL_OW 1
20878: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20879: LD_ADDR_EXP 80
20883: PUSH
20884: LD_EXP 80
20888: PPUSH
20889: LD_VAR 0 2
20893: PPUSH
20894: EMPTY
20895: PPUSH
20896: CALL_OW 1
20900: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20901: LD_ADDR_EXP 81
20905: PUSH
20906: LD_EXP 81
20910: PPUSH
20911: LD_VAR 0 2
20915: PPUSH
20916: EMPTY
20917: PPUSH
20918: CALL_OW 1
20922: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20923: LD_ADDR_EXP 83
20927: PUSH
20928: LD_EXP 83
20932: PPUSH
20933: LD_VAR 0 2
20937: PPUSH
20938: LD_EXP 50
20942: PUSH
20943: LD_VAR 0 2
20947: ARRAY
20948: PPUSH
20949: LD_INT 2
20951: PUSH
20952: LD_INT 30
20954: PUSH
20955: LD_INT 6
20957: PUSH
20958: EMPTY
20959: LIST
20960: LIST
20961: PUSH
20962: LD_INT 30
20964: PUSH
20965: LD_INT 7
20967: PUSH
20968: EMPTY
20969: LIST
20970: LIST
20971: PUSH
20972: LD_INT 30
20974: PUSH
20975: LD_INT 8
20977: PUSH
20978: EMPTY
20979: LIST
20980: LIST
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: LIST
20986: LIST
20987: PPUSH
20988: CALL_OW 72
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20998: LD_ADDR_EXP 84
21002: PUSH
21003: LD_EXP 84
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21020: LD_ADDR_EXP 85
21024: PUSH
21025: LD_EXP 85
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21042: LD_ADDR_EXP 86
21046: PUSH
21047: LD_EXP 86
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21064: LD_ADDR_EXP 87
21068: PUSH
21069: LD_EXP 87
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21086: LD_ADDR_EXP 88
21090: PUSH
21091: LD_EXP 88
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: EMPTY
21102: PPUSH
21103: CALL_OW 1
21107: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21108: LD_ADDR_EXP 89
21112: PUSH
21113: LD_EXP 89
21117: PPUSH
21118: LD_VAR 0 2
21122: PPUSH
21123: EMPTY
21124: PPUSH
21125: CALL_OW 1
21129: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21130: LD_ADDR_EXP 90
21134: PUSH
21135: LD_EXP 90
21139: PPUSH
21140: LD_VAR 0 2
21144: PPUSH
21145: EMPTY
21146: PPUSH
21147: CALL_OW 1
21151: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21152: LD_ADDR_EXP 91
21156: PUSH
21157: LD_EXP 91
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: EMPTY
21168: PPUSH
21169: CALL_OW 1
21173: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21174: LD_ADDR_EXP 92
21178: PUSH
21179: LD_EXP 92
21183: PPUSH
21184: LD_VAR 0 2
21188: PPUSH
21189: LD_INT 0
21191: PPUSH
21192: CALL_OW 1
21196: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21197: LD_ADDR_EXP 93
21201: PUSH
21202: LD_EXP 93
21206: PPUSH
21207: LD_VAR 0 2
21211: PPUSH
21212: LD_INT 0
21214: PPUSH
21215: CALL_OW 1
21219: ST_TO_ADDR
// end ;
21220: GO 20121
21222: POP
21223: POP
// MC_InitSides ( ) ;
21224: CALL 21510 0 0
// MC_InitResearch ( ) ;
21228: CALL 21249 0 0
// CustomInitMacro ( ) ;
21232: CALL 304 0 0
// skirmish := true ;
21236: LD_ADDR_EXP 48
21240: PUSH
21241: LD_INT 1
21243: ST_TO_ADDR
// end ;
21244: LD_VAR 0 1
21248: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21249: LD_INT 0
21251: PPUSH
21252: PPUSH
21253: PPUSH
21254: PPUSH
21255: PPUSH
21256: PPUSH
// if not mc_bases then
21257: LD_EXP 50
21261: NOT
21262: IFFALSE 21266
// exit ;
21264: GO 21505
// for i = 1 to 8 do
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: DOUBLE
21272: LD_INT 1
21274: DEC
21275: ST_TO_ADDR
21276: LD_INT 8
21278: PUSH
21279: FOR_TO
21280: IFFALSE 21306
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21282: LD_ADDR_EXP 77
21286: PUSH
21287: LD_EXP 77
21291: PPUSH
21292: LD_VAR 0 2
21296: PPUSH
21297: EMPTY
21298: PPUSH
21299: CALL_OW 1
21303: ST_TO_ADDR
21304: GO 21279
21306: POP
21307: POP
// tmp := [ ] ;
21308: LD_ADDR_VAR 0 5
21312: PUSH
21313: EMPTY
21314: ST_TO_ADDR
// for i = 1 to mc_sides do
21315: LD_ADDR_VAR 0 2
21319: PUSH
21320: DOUBLE
21321: LD_INT 1
21323: DEC
21324: ST_TO_ADDR
21325: LD_EXP 76
21329: PUSH
21330: FOR_TO
21331: IFFALSE 21389
// if not mc_sides [ i ] in tmp then
21333: LD_EXP 76
21337: PUSH
21338: LD_VAR 0 2
21342: ARRAY
21343: PUSH
21344: LD_VAR 0 5
21348: IN
21349: NOT
21350: IFFALSE 21387
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21352: LD_ADDR_VAR 0 5
21356: PUSH
21357: LD_VAR 0 5
21361: PPUSH
21362: LD_VAR 0 5
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: PPUSH
21371: LD_EXP 76
21375: PUSH
21376: LD_VAR 0 2
21380: ARRAY
21381: PPUSH
21382: CALL_OW 2
21386: ST_TO_ADDR
21387: GO 21330
21389: POP
21390: POP
// if not tmp then
21391: LD_VAR 0 5
21395: NOT
21396: IFFALSE 21400
// exit ;
21398: GO 21505
// for j in tmp do
21400: LD_ADDR_VAR 0 3
21404: PUSH
21405: LD_VAR 0 5
21409: PUSH
21410: FOR_IN
21411: IFFALSE 21503
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21413: LD_ADDR_VAR 0 6
21417: PUSH
21418: LD_INT 22
21420: PUSH
21421: LD_VAR 0 3
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: PPUSH
21430: CALL_OW 69
21434: ST_TO_ADDR
// if not un then
21435: LD_VAR 0 6
21439: NOT
21440: IFFALSE 21444
// continue ;
21442: GO 21410
// nation := GetNation ( un [ 1 ] ) ;
21444: LD_ADDR_VAR 0 4
21448: PUSH
21449: LD_VAR 0 6
21453: PUSH
21454: LD_INT 1
21456: ARRAY
21457: PPUSH
21458: CALL_OW 248
21462: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21463: LD_ADDR_EXP 77
21467: PUSH
21468: LD_EXP 77
21472: PPUSH
21473: LD_VAR 0 3
21477: PPUSH
21478: LD_VAR 0 3
21482: PPUSH
21483: LD_VAR 0 4
21487: PPUSH
21488: LD_INT 1
21490: PPUSH
21491: CALL 48604 0 3
21495: PPUSH
21496: CALL_OW 1
21500: ST_TO_ADDR
// end ;
21501: GO 21410
21503: POP
21504: POP
// end ;
21505: LD_VAR 0 1
21509: RET
// export function MC_InitSides ( ) ; var i ; begin
21510: LD_INT 0
21512: PPUSH
21513: PPUSH
// if not mc_bases then
21514: LD_EXP 50
21518: NOT
21519: IFFALSE 21523
// exit ;
21521: GO 21597
// for i = 1 to mc_bases do
21523: LD_ADDR_VAR 0 2
21527: PUSH
21528: DOUBLE
21529: LD_INT 1
21531: DEC
21532: ST_TO_ADDR
21533: LD_EXP 50
21537: PUSH
21538: FOR_TO
21539: IFFALSE 21595
// if mc_bases [ i ] then
21541: LD_EXP 50
21545: PUSH
21546: LD_VAR 0 2
21550: ARRAY
21551: IFFALSE 21593
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21553: LD_ADDR_EXP 76
21557: PUSH
21558: LD_EXP 76
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: LD_EXP 50
21572: PUSH
21573: LD_VAR 0 2
21577: ARRAY
21578: PUSH
21579: LD_INT 1
21581: ARRAY
21582: PPUSH
21583: CALL_OW 255
21587: PPUSH
21588: CALL_OW 1
21592: ST_TO_ADDR
21593: GO 21538
21595: POP
21596: POP
// end ;
21597: LD_VAR 0 1
21601: RET
// every 0 0$03 trigger skirmish do
21602: LD_EXP 48
21606: IFFALSE 21760
21608: GO 21610
21610: DISABLE
// begin enable ;
21611: ENABLE
// MC_CheckBuildings ( ) ;
21612: CALL 26258 0 0
// MC_CheckPeopleLife ( ) ;
21616: CALL 26419 0 0
// RaiseSailEvent ( 100 ) ;
21620: LD_INT 100
21622: PPUSH
21623: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21627: LD_INT 103
21629: PPUSH
21630: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21634: LD_INT 104
21636: PPUSH
21637: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21641: LD_INT 105
21643: PPUSH
21644: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21648: LD_INT 106
21650: PPUSH
21651: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21655: LD_INT 107
21657: PPUSH
21658: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21662: LD_INT 108
21664: PPUSH
21665: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21669: LD_INT 109
21671: PPUSH
21672: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21676: LD_INT 110
21678: PPUSH
21679: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21683: LD_INT 111
21685: PPUSH
21686: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21690: LD_INT 112
21692: PPUSH
21693: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21697: LD_INT 113
21699: PPUSH
21700: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21704: LD_INT 120
21706: PPUSH
21707: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21711: LD_INT 121
21713: PPUSH
21714: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21718: LD_INT 122
21720: PPUSH
21721: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21725: LD_INT 123
21727: PPUSH
21728: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21732: LD_INT 124
21734: PPUSH
21735: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21739: LD_INT 125
21741: PPUSH
21742: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21746: LD_INT 126
21748: PPUSH
21749: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21753: LD_INT 200
21755: PPUSH
21756: CALL_OW 427
// end ;
21760: END
// on SailEvent ( event ) do begin if event < 100 then
21761: LD_VAR 0 1
21765: PUSH
21766: LD_INT 100
21768: LESS
21769: IFFALSE 21780
// CustomEvent ( event ) ;
21771: LD_VAR 0 1
21775: PPUSH
21776: CALL 17123 0 1
// if event = 100 then
21780: LD_VAR 0 1
21784: PUSH
21785: LD_INT 100
21787: EQUAL
21788: IFFALSE 21794
// MC_ClassManager ( ) ;
21790: CALL 22186 0 0
// if event = 101 then
21794: LD_VAR 0 1
21798: PUSH
21799: LD_INT 101
21801: EQUAL
21802: IFFALSE 21808
// MC_RepairBuildings ( ) ;
21804: CALL 27004 0 0
// if event = 102 then
21808: LD_VAR 0 1
21812: PUSH
21813: LD_INT 102
21815: EQUAL
21816: IFFALSE 21822
// MC_Heal ( ) ;
21818: CALL 27907 0 0
// if event = 103 then
21822: LD_VAR 0 1
21826: PUSH
21827: LD_INT 103
21829: EQUAL
21830: IFFALSE 21836
// MC_Build ( ) ;
21832: CALL 28329 0 0
// if event = 104 then
21836: LD_VAR 0 1
21840: PUSH
21841: LD_INT 104
21843: EQUAL
21844: IFFALSE 21850
// MC_TurretWeapon ( ) ;
21846: CALL 29970 0 0
// if event = 105 then
21850: LD_VAR 0 1
21854: PUSH
21855: LD_INT 105
21857: EQUAL
21858: IFFALSE 21864
// MC_BuildUpgrade ( ) ;
21860: CALL 29521 0 0
// if event = 106 then
21864: LD_VAR 0 1
21868: PUSH
21869: LD_INT 106
21871: EQUAL
21872: IFFALSE 21878
// MC_PlantMines ( ) ;
21874: CALL 30400 0 0
// if event = 107 then
21878: LD_VAR 0 1
21882: PUSH
21883: LD_INT 107
21885: EQUAL
21886: IFFALSE 21892
// MC_CollectCrates ( ) ;
21888: CALL 31191 0 0
// if event = 108 then
21892: LD_VAR 0 1
21896: PUSH
21897: LD_INT 108
21899: EQUAL
21900: IFFALSE 21906
// MC_LinkRemoteControl ( ) ;
21902: CALL 33041 0 0
// if event = 109 then
21906: LD_VAR 0 1
21910: PUSH
21911: LD_INT 109
21913: EQUAL
21914: IFFALSE 21920
// MC_ProduceVehicle ( ) ;
21916: CALL 33222 0 0
// if event = 110 then
21920: LD_VAR 0 1
21924: PUSH
21925: LD_INT 110
21927: EQUAL
21928: IFFALSE 21934
// MC_SendAttack ( ) ;
21930: CALL 33688 0 0
// if event = 111 then
21934: LD_VAR 0 1
21938: PUSH
21939: LD_INT 111
21941: EQUAL
21942: IFFALSE 21948
// MC_Defend ( ) ;
21944: CALL 33796 0 0
// if event = 112 then
21948: LD_VAR 0 1
21952: PUSH
21953: LD_INT 112
21955: EQUAL
21956: IFFALSE 21962
// MC_Research ( ) ;
21958: CALL 34676 0 0
// if event = 113 then
21962: LD_VAR 0 1
21966: PUSH
21967: LD_INT 113
21969: EQUAL
21970: IFFALSE 21976
// MC_MinesTrigger ( ) ;
21972: CALL 35790 0 0
// if event = 120 then
21976: LD_VAR 0 1
21980: PUSH
21981: LD_INT 120
21983: EQUAL
21984: IFFALSE 21990
// MC_RepairVehicle ( ) ;
21986: CALL 35889 0 0
// if event = 121 then
21990: LD_VAR 0 1
21994: PUSH
21995: LD_INT 121
21997: EQUAL
21998: IFFALSE 22004
// MC_TameApe ( ) ;
22000: CALL 36630 0 0
// if event = 122 then
22004: LD_VAR 0 1
22008: PUSH
22009: LD_INT 122
22011: EQUAL
22012: IFFALSE 22018
// MC_ChangeApeClass ( ) ;
22014: CALL 37459 0 0
// if event = 123 then
22018: LD_VAR 0 1
22022: PUSH
22023: LD_INT 123
22025: EQUAL
22026: IFFALSE 22032
// MC_Bazooka ( ) ;
22028: CALL 38109 0 0
// if event = 124 then
22032: LD_VAR 0 1
22036: PUSH
22037: LD_INT 124
22039: EQUAL
22040: IFFALSE 22046
// MC_TeleportExit ( ) ;
22042: CALL 38307 0 0
// if event = 125 then
22046: LD_VAR 0 1
22050: PUSH
22051: LD_INT 125
22053: EQUAL
22054: IFFALSE 22060
// MC_Deposits ( ) ;
22056: CALL 38954 0 0
// if event = 126 then
22060: LD_VAR 0 1
22064: PUSH
22065: LD_INT 126
22067: EQUAL
22068: IFFALSE 22074
// MC_RemoteDriver ( ) ;
22070: CALL 39579 0 0
// if event = 200 then
22074: LD_VAR 0 1
22078: PUSH
22079: LD_INT 200
22081: EQUAL
22082: IFFALSE 22088
// MC_Idle ( ) ;
22084: CALL 41528 0 0
// end ;
22088: PPOPN 1
22090: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22091: LD_INT 0
22093: PPUSH
22094: PPUSH
// if not mc_bases [ base ] or not tag then
22095: LD_EXP 50
22099: PUSH
22100: LD_VAR 0 1
22104: ARRAY
22105: NOT
22106: PUSH
22107: LD_VAR 0 2
22111: NOT
22112: OR
22113: IFFALSE 22117
// exit ;
22115: GO 22181
// for i in mc_bases [ base ] union mc_ape [ base ] do
22117: LD_ADDR_VAR 0 4
22121: PUSH
22122: LD_EXP 50
22126: PUSH
22127: LD_VAR 0 1
22131: ARRAY
22132: PUSH
22133: LD_EXP 79
22137: PUSH
22138: LD_VAR 0 1
22142: ARRAY
22143: UNION
22144: PUSH
22145: FOR_IN
22146: IFFALSE 22179
// if GetTag ( i ) = tag then
22148: LD_VAR 0 4
22152: PPUSH
22153: CALL_OW 110
22157: PUSH
22158: LD_VAR 0 2
22162: EQUAL
22163: IFFALSE 22177
// SetTag ( i , 0 ) ;
22165: LD_VAR 0 4
22169: PPUSH
22170: LD_INT 0
22172: PPUSH
22173: CALL_OW 109
22177: GO 22145
22179: POP
22180: POP
// end ;
22181: LD_VAR 0 3
22185: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22186: LD_INT 0
22188: PPUSH
22189: PPUSH
22190: PPUSH
22191: PPUSH
22192: PPUSH
22193: PPUSH
22194: PPUSH
22195: PPUSH
// if not mc_bases then
22196: LD_EXP 50
22200: NOT
22201: IFFALSE 22205
// exit ;
22203: GO 22663
// for i = 1 to mc_bases do
22205: LD_ADDR_VAR 0 2
22209: PUSH
22210: DOUBLE
22211: LD_INT 1
22213: DEC
22214: ST_TO_ADDR
22215: LD_EXP 50
22219: PUSH
22220: FOR_TO
22221: IFFALSE 22661
// begin tmp := MC_ClassCheckReq ( i ) ;
22223: LD_ADDR_VAR 0 4
22227: PUSH
22228: LD_VAR 0 2
22232: PPUSH
22233: CALL 22668 0 1
22237: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22238: LD_ADDR_EXP 91
22242: PUSH
22243: LD_EXP 91
22247: PPUSH
22248: LD_VAR 0 2
22252: PPUSH
22253: LD_VAR 0 4
22257: PPUSH
22258: CALL_OW 1
22262: ST_TO_ADDR
// if not tmp then
22263: LD_VAR 0 4
22267: NOT
22268: IFFALSE 22272
// continue ;
22270: GO 22220
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22272: LD_ADDR_VAR 0 6
22276: PUSH
22277: LD_EXP 50
22281: PUSH
22282: LD_VAR 0 2
22286: ARRAY
22287: PPUSH
22288: LD_INT 2
22290: PUSH
22291: LD_INT 30
22293: PUSH
22294: LD_INT 4
22296: PUSH
22297: EMPTY
22298: LIST
22299: LIST
22300: PUSH
22301: LD_INT 30
22303: PUSH
22304: LD_INT 5
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: PUSH
22311: EMPTY
22312: LIST
22313: LIST
22314: LIST
22315: PPUSH
22316: CALL_OW 72
22320: PUSH
22321: LD_EXP 50
22325: PUSH
22326: LD_VAR 0 2
22330: ARRAY
22331: PPUSH
22332: LD_INT 2
22334: PUSH
22335: LD_INT 30
22337: PUSH
22338: LD_INT 0
22340: PUSH
22341: EMPTY
22342: LIST
22343: LIST
22344: PUSH
22345: LD_INT 30
22347: PUSH
22348: LD_INT 1
22350: PUSH
22351: EMPTY
22352: LIST
22353: LIST
22354: PUSH
22355: EMPTY
22356: LIST
22357: LIST
22358: LIST
22359: PPUSH
22360: CALL_OW 72
22364: PUSH
22365: LD_EXP 50
22369: PUSH
22370: LD_VAR 0 2
22374: ARRAY
22375: PPUSH
22376: LD_INT 30
22378: PUSH
22379: LD_INT 3
22381: PUSH
22382: EMPTY
22383: LIST
22384: LIST
22385: PPUSH
22386: CALL_OW 72
22390: PUSH
22391: LD_EXP 50
22395: PUSH
22396: LD_VAR 0 2
22400: ARRAY
22401: PPUSH
22402: LD_INT 2
22404: PUSH
22405: LD_INT 30
22407: PUSH
22408: LD_INT 6
22410: PUSH
22411: EMPTY
22412: LIST
22413: LIST
22414: PUSH
22415: LD_INT 30
22417: PUSH
22418: LD_INT 7
22420: PUSH
22421: EMPTY
22422: LIST
22423: LIST
22424: PUSH
22425: LD_INT 30
22427: PUSH
22428: LD_INT 8
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: LIST
22439: LIST
22440: PPUSH
22441: CALL_OW 72
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: ST_TO_ADDR
// for j = 1 to 4 do
22452: LD_ADDR_VAR 0 3
22456: PUSH
22457: DOUBLE
22458: LD_INT 1
22460: DEC
22461: ST_TO_ADDR
22462: LD_INT 4
22464: PUSH
22465: FOR_TO
22466: IFFALSE 22657
// begin if not tmp [ j ] then
22468: LD_VAR 0 4
22472: PUSH
22473: LD_VAR 0 3
22477: ARRAY
22478: NOT
22479: IFFALSE 22483
// continue ;
22481: GO 22465
// for p in tmp [ j ] do
22483: LD_ADDR_VAR 0 5
22487: PUSH
22488: LD_VAR 0 4
22492: PUSH
22493: LD_VAR 0 3
22497: ARRAY
22498: PUSH
22499: FOR_IN
22500: IFFALSE 22653
// begin if not b [ j ] then
22502: LD_VAR 0 6
22506: PUSH
22507: LD_VAR 0 3
22511: ARRAY
22512: NOT
22513: IFFALSE 22517
// break ;
22515: GO 22653
// e := 0 ;
22517: LD_ADDR_VAR 0 7
22521: PUSH
22522: LD_INT 0
22524: ST_TO_ADDR
// for k in b [ j ] do
22525: LD_ADDR_VAR 0 8
22529: PUSH
22530: LD_VAR 0 6
22534: PUSH
22535: LD_VAR 0 3
22539: ARRAY
22540: PUSH
22541: FOR_IN
22542: IFFALSE 22569
// if IsNotFull ( k ) then
22544: LD_VAR 0 8
22548: PPUSH
22549: CALL 50757 0 1
22553: IFFALSE 22567
// begin e := k ;
22555: LD_ADDR_VAR 0 7
22559: PUSH
22560: LD_VAR 0 8
22564: ST_TO_ADDR
// break ;
22565: GO 22569
// end ;
22567: GO 22541
22569: POP
22570: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22571: LD_VAR 0 7
22575: PUSH
22576: LD_VAR 0 5
22580: PPUSH
22581: LD_VAR 0 7
22585: PPUSH
22586: CALL 84563 0 2
22590: NOT
22591: AND
22592: IFFALSE 22651
// begin if IsInUnit ( p ) then
22594: LD_VAR 0 5
22598: PPUSH
22599: CALL_OW 310
22603: IFFALSE 22614
// ComExitBuilding ( p ) ;
22605: LD_VAR 0 5
22609: PPUSH
22610: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22614: LD_VAR 0 5
22618: PPUSH
22619: LD_VAR 0 7
22623: PPUSH
22624: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22628: LD_VAR 0 5
22632: PPUSH
22633: LD_VAR 0 3
22637: PPUSH
22638: CALL_OW 183
// AddComExitBuilding ( p ) ;
22642: LD_VAR 0 5
22646: PPUSH
22647: CALL_OW 182
// end ; end ;
22651: GO 22499
22653: POP
22654: POP
// end ;
22655: GO 22465
22657: POP
22658: POP
// end ;
22659: GO 22220
22661: POP
22662: POP
// end ;
22663: LD_VAR 0 1
22667: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22668: LD_INT 0
22670: PPUSH
22671: PPUSH
22672: PPUSH
22673: PPUSH
22674: PPUSH
22675: PPUSH
22676: PPUSH
22677: PPUSH
22678: PPUSH
22679: PPUSH
22680: PPUSH
22681: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22682: LD_VAR 0 1
22686: NOT
22687: PUSH
22688: LD_EXP 50
22692: PUSH
22693: LD_VAR 0 1
22697: ARRAY
22698: NOT
22699: OR
22700: PUSH
22701: LD_EXP 50
22705: PUSH
22706: LD_VAR 0 1
22710: ARRAY
22711: PPUSH
22712: LD_INT 2
22714: PUSH
22715: LD_INT 30
22717: PUSH
22718: LD_INT 0
22720: PUSH
22721: EMPTY
22722: LIST
22723: LIST
22724: PUSH
22725: LD_INT 30
22727: PUSH
22728: LD_INT 1
22730: PUSH
22731: EMPTY
22732: LIST
22733: LIST
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: LIST
22739: PPUSH
22740: CALL_OW 72
22744: NOT
22745: OR
22746: IFFALSE 22750
// exit ;
22748: GO 26253
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22750: LD_ADDR_VAR 0 4
22754: PUSH
22755: LD_EXP 50
22759: PUSH
22760: LD_VAR 0 1
22764: ARRAY
22765: PPUSH
22766: LD_INT 2
22768: PUSH
22769: LD_INT 25
22771: PUSH
22772: LD_INT 1
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: PUSH
22779: LD_INT 25
22781: PUSH
22782: LD_INT 2
22784: PUSH
22785: EMPTY
22786: LIST
22787: LIST
22788: PUSH
22789: LD_INT 25
22791: PUSH
22792: LD_INT 3
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: PUSH
22799: LD_INT 25
22801: PUSH
22802: LD_INT 4
22804: PUSH
22805: EMPTY
22806: LIST
22807: LIST
22808: PUSH
22809: LD_INT 25
22811: PUSH
22812: LD_INT 5
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PUSH
22819: LD_INT 25
22821: PUSH
22822: LD_INT 8
22824: PUSH
22825: EMPTY
22826: LIST
22827: LIST
22828: PUSH
22829: LD_INT 25
22831: PUSH
22832: LD_INT 9
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: LIST
22843: LIST
22844: LIST
22845: LIST
22846: LIST
22847: LIST
22848: PPUSH
22849: CALL_OW 72
22853: ST_TO_ADDR
// if not tmp then
22854: LD_VAR 0 4
22858: NOT
22859: IFFALSE 22863
// exit ;
22861: GO 26253
// for i in tmp do
22863: LD_ADDR_VAR 0 3
22867: PUSH
22868: LD_VAR 0 4
22872: PUSH
22873: FOR_IN
22874: IFFALSE 22905
// if GetTag ( i ) then
22876: LD_VAR 0 3
22880: PPUSH
22881: CALL_OW 110
22885: IFFALSE 22903
// tmp := tmp diff i ;
22887: LD_ADDR_VAR 0 4
22891: PUSH
22892: LD_VAR 0 4
22896: PUSH
22897: LD_VAR 0 3
22901: DIFF
22902: ST_TO_ADDR
22903: GO 22873
22905: POP
22906: POP
// if not tmp then
22907: LD_VAR 0 4
22911: NOT
22912: IFFALSE 22916
// exit ;
22914: GO 26253
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22916: LD_ADDR_VAR 0 5
22920: PUSH
22921: LD_EXP 50
22925: PUSH
22926: LD_VAR 0 1
22930: ARRAY
22931: PPUSH
22932: LD_INT 2
22934: PUSH
22935: LD_INT 25
22937: PUSH
22938: LD_INT 1
22940: PUSH
22941: EMPTY
22942: LIST
22943: LIST
22944: PUSH
22945: LD_INT 25
22947: PUSH
22948: LD_INT 5
22950: PUSH
22951: EMPTY
22952: LIST
22953: LIST
22954: PUSH
22955: LD_INT 25
22957: PUSH
22958: LD_INT 8
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: PUSH
22965: LD_INT 25
22967: PUSH
22968: LD_INT 9
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: LIST
22979: LIST
22980: LIST
22981: PPUSH
22982: CALL_OW 72
22986: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22987: LD_ADDR_VAR 0 6
22991: PUSH
22992: LD_EXP 50
22996: PUSH
22997: LD_VAR 0 1
23001: ARRAY
23002: PPUSH
23003: LD_INT 25
23005: PUSH
23006: LD_INT 2
23008: PUSH
23009: EMPTY
23010: LIST
23011: LIST
23012: PPUSH
23013: CALL_OW 72
23017: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23018: LD_ADDR_VAR 0 7
23022: PUSH
23023: LD_EXP 50
23027: PUSH
23028: LD_VAR 0 1
23032: ARRAY
23033: PPUSH
23034: LD_INT 25
23036: PUSH
23037: LD_INT 3
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: PPUSH
23044: CALL_OW 72
23048: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23049: LD_ADDR_VAR 0 8
23053: PUSH
23054: LD_EXP 50
23058: PUSH
23059: LD_VAR 0 1
23063: ARRAY
23064: PPUSH
23065: LD_INT 25
23067: PUSH
23068: LD_INT 4
23070: PUSH
23071: EMPTY
23072: LIST
23073: LIST
23074: PUSH
23075: LD_INT 24
23077: PUSH
23078: LD_INT 251
23080: PUSH
23081: EMPTY
23082: LIST
23083: LIST
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PPUSH
23089: CALL_OW 72
23093: ST_TO_ADDR
// if mc_is_defending [ base ] then
23094: LD_EXP 93
23098: PUSH
23099: LD_VAR 0 1
23103: ARRAY
23104: IFFALSE 23565
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23106: LD_ADDR_EXP 92
23110: PUSH
23111: LD_EXP 92
23115: PPUSH
23116: LD_VAR 0 1
23120: PPUSH
23121: LD_INT 4
23123: PPUSH
23124: CALL_OW 1
23128: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23129: LD_ADDR_VAR 0 12
23133: PUSH
23134: LD_EXP 50
23138: PUSH
23139: LD_VAR 0 1
23143: ARRAY
23144: PPUSH
23145: LD_INT 2
23147: PUSH
23148: LD_INT 30
23150: PUSH
23151: LD_INT 4
23153: PUSH
23154: EMPTY
23155: LIST
23156: LIST
23157: PUSH
23158: LD_INT 30
23160: PUSH
23161: LD_INT 5
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: PUSH
23168: EMPTY
23169: LIST
23170: LIST
23171: LIST
23172: PPUSH
23173: CALL_OW 72
23177: ST_TO_ADDR
// if not b then
23178: LD_VAR 0 12
23182: NOT
23183: IFFALSE 23187
// exit ;
23185: GO 26253
// p := [ ] ;
23187: LD_ADDR_VAR 0 11
23191: PUSH
23192: EMPTY
23193: ST_TO_ADDR
// if sci >= 2 then
23194: LD_VAR 0 8
23198: PUSH
23199: LD_INT 2
23201: GREATEREQUAL
23202: IFFALSE 23233
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23204: LD_ADDR_VAR 0 8
23208: PUSH
23209: LD_VAR 0 8
23213: PUSH
23214: LD_INT 1
23216: ARRAY
23217: PUSH
23218: LD_VAR 0 8
23222: PUSH
23223: LD_INT 2
23225: ARRAY
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: ST_TO_ADDR
23231: GO 23294
// if sci = 1 then
23233: LD_VAR 0 8
23237: PUSH
23238: LD_INT 1
23240: EQUAL
23241: IFFALSE 23262
// sci := [ sci [ 1 ] ] else
23243: LD_ADDR_VAR 0 8
23247: PUSH
23248: LD_VAR 0 8
23252: PUSH
23253: LD_INT 1
23255: ARRAY
23256: PUSH
23257: EMPTY
23258: LIST
23259: ST_TO_ADDR
23260: GO 23294
// if sci = 0 then
23262: LD_VAR 0 8
23266: PUSH
23267: LD_INT 0
23269: EQUAL
23270: IFFALSE 23294
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23272: LD_ADDR_VAR 0 11
23276: PUSH
23277: LD_VAR 0 4
23281: PPUSH
23282: LD_INT 4
23284: PPUSH
23285: CALL 84426 0 2
23289: PUSH
23290: LD_INT 1
23292: ARRAY
23293: ST_TO_ADDR
// if eng > 4 then
23294: LD_VAR 0 6
23298: PUSH
23299: LD_INT 4
23301: GREATER
23302: IFFALSE 23348
// for i = eng downto 4 do
23304: LD_ADDR_VAR 0 3
23308: PUSH
23309: DOUBLE
23310: LD_VAR 0 6
23314: INC
23315: ST_TO_ADDR
23316: LD_INT 4
23318: PUSH
23319: FOR_DOWNTO
23320: IFFALSE 23346
// eng := eng diff eng [ i ] ;
23322: LD_ADDR_VAR 0 6
23326: PUSH
23327: LD_VAR 0 6
23331: PUSH
23332: LD_VAR 0 6
23336: PUSH
23337: LD_VAR 0 3
23341: ARRAY
23342: DIFF
23343: ST_TO_ADDR
23344: GO 23319
23346: POP
23347: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23348: LD_ADDR_VAR 0 4
23352: PUSH
23353: LD_VAR 0 4
23357: PUSH
23358: LD_VAR 0 5
23362: PUSH
23363: LD_VAR 0 6
23367: UNION
23368: PUSH
23369: LD_VAR 0 7
23373: UNION
23374: PUSH
23375: LD_VAR 0 8
23379: UNION
23380: DIFF
23381: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23382: LD_ADDR_VAR 0 13
23386: PUSH
23387: LD_EXP 50
23391: PUSH
23392: LD_VAR 0 1
23396: ARRAY
23397: PPUSH
23398: LD_INT 2
23400: PUSH
23401: LD_INT 30
23403: PUSH
23404: LD_INT 32
23406: PUSH
23407: EMPTY
23408: LIST
23409: LIST
23410: PUSH
23411: LD_INT 30
23413: PUSH
23414: LD_INT 31
23416: PUSH
23417: EMPTY
23418: LIST
23419: LIST
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: LIST
23425: PPUSH
23426: CALL_OW 72
23430: PUSH
23431: LD_EXP 50
23435: PUSH
23436: LD_VAR 0 1
23440: ARRAY
23441: PPUSH
23442: LD_INT 2
23444: PUSH
23445: LD_INT 30
23447: PUSH
23448: LD_INT 4
23450: PUSH
23451: EMPTY
23452: LIST
23453: LIST
23454: PUSH
23455: LD_INT 30
23457: PUSH
23458: LD_INT 5
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: LIST
23469: PPUSH
23470: CALL_OW 72
23474: PUSH
23475: LD_INT 6
23477: MUL
23478: PLUS
23479: ST_TO_ADDR
// if bcount < tmp then
23480: LD_VAR 0 13
23484: PUSH
23485: LD_VAR 0 4
23489: LESS
23490: IFFALSE 23536
// for i = tmp downto bcount do
23492: LD_ADDR_VAR 0 3
23496: PUSH
23497: DOUBLE
23498: LD_VAR 0 4
23502: INC
23503: ST_TO_ADDR
23504: LD_VAR 0 13
23508: PUSH
23509: FOR_DOWNTO
23510: IFFALSE 23534
// tmp := Delete ( tmp , tmp ) ;
23512: LD_ADDR_VAR 0 4
23516: PUSH
23517: LD_VAR 0 4
23521: PPUSH
23522: LD_VAR 0 4
23526: PPUSH
23527: CALL_OW 3
23531: ST_TO_ADDR
23532: GO 23509
23534: POP
23535: POP
// result := [ tmp , 0 , 0 , p ] ;
23536: LD_ADDR_VAR 0 2
23540: PUSH
23541: LD_VAR 0 4
23545: PUSH
23546: LD_INT 0
23548: PUSH
23549: LD_INT 0
23551: PUSH
23552: LD_VAR 0 11
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: LIST
23561: LIST
23562: ST_TO_ADDR
// exit ;
23563: GO 26253
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23565: LD_EXP 50
23569: PUSH
23570: LD_VAR 0 1
23574: ARRAY
23575: PPUSH
23576: LD_INT 2
23578: PUSH
23579: LD_INT 30
23581: PUSH
23582: LD_INT 6
23584: PUSH
23585: EMPTY
23586: LIST
23587: LIST
23588: PUSH
23589: LD_INT 30
23591: PUSH
23592: LD_INT 7
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: PUSH
23599: LD_INT 30
23601: PUSH
23602: LD_INT 8
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: PUSH
23609: EMPTY
23610: LIST
23611: LIST
23612: LIST
23613: LIST
23614: PPUSH
23615: CALL_OW 72
23619: NOT
23620: PUSH
23621: LD_EXP 50
23625: PUSH
23626: LD_VAR 0 1
23630: ARRAY
23631: PPUSH
23632: LD_INT 30
23634: PUSH
23635: LD_INT 3
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PPUSH
23642: CALL_OW 72
23646: NOT
23647: AND
23648: IFFALSE 23720
// begin if eng = tmp then
23650: LD_VAR 0 6
23654: PUSH
23655: LD_VAR 0 4
23659: EQUAL
23660: IFFALSE 23664
// exit ;
23662: GO 26253
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23664: LD_ADDR_EXP 92
23668: PUSH
23669: LD_EXP 92
23673: PPUSH
23674: LD_VAR 0 1
23678: PPUSH
23679: LD_INT 1
23681: PPUSH
23682: CALL_OW 1
23686: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23687: LD_ADDR_VAR 0 2
23691: PUSH
23692: LD_INT 0
23694: PUSH
23695: LD_VAR 0 4
23699: PUSH
23700: LD_VAR 0 6
23704: DIFF
23705: PUSH
23706: LD_INT 0
23708: PUSH
23709: LD_INT 0
23711: PUSH
23712: EMPTY
23713: LIST
23714: LIST
23715: LIST
23716: LIST
23717: ST_TO_ADDR
// exit ;
23718: GO 26253
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23720: LD_EXP 77
23724: PUSH
23725: LD_EXP 76
23729: PUSH
23730: LD_VAR 0 1
23734: ARRAY
23735: ARRAY
23736: PUSH
23737: LD_EXP 50
23741: PUSH
23742: LD_VAR 0 1
23746: ARRAY
23747: PPUSH
23748: LD_INT 2
23750: PUSH
23751: LD_INT 30
23753: PUSH
23754: LD_INT 6
23756: PUSH
23757: EMPTY
23758: LIST
23759: LIST
23760: PUSH
23761: LD_INT 30
23763: PUSH
23764: LD_INT 7
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: PUSH
23771: LD_INT 30
23773: PUSH
23774: LD_INT 8
23776: PUSH
23777: EMPTY
23778: LIST
23779: LIST
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: LIST
23785: LIST
23786: PPUSH
23787: CALL_OW 72
23791: AND
23792: PUSH
23793: LD_EXP 50
23797: PUSH
23798: LD_VAR 0 1
23802: ARRAY
23803: PPUSH
23804: LD_INT 30
23806: PUSH
23807: LD_INT 3
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PPUSH
23814: CALL_OW 72
23818: NOT
23819: AND
23820: IFFALSE 24034
// begin if sci >= 6 then
23822: LD_VAR 0 8
23826: PUSH
23827: LD_INT 6
23829: GREATEREQUAL
23830: IFFALSE 23834
// exit ;
23832: GO 26253
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23834: LD_ADDR_EXP 92
23838: PUSH
23839: LD_EXP 92
23843: PPUSH
23844: LD_VAR 0 1
23848: PPUSH
23849: LD_INT 2
23851: PPUSH
23852: CALL_OW 1
23856: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23857: LD_ADDR_VAR 0 9
23861: PUSH
23862: LD_VAR 0 4
23866: PUSH
23867: LD_VAR 0 8
23871: DIFF
23872: PPUSH
23873: LD_INT 4
23875: PPUSH
23876: CALL 84426 0 2
23880: ST_TO_ADDR
// p := [ ] ;
23881: LD_ADDR_VAR 0 11
23885: PUSH
23886: EMPTY
23887: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23888: LD_VAR 0 8
23892: PUSH
23893: LD_INT 6
23895: LESS
23896: PUSH
23897: LD_VAR 0 9
23901: PUSH
23902: LD_INT 6
23904: GREATER
23905: AND
23906: IFFALSE 23987
// begin for i = 1 to 6 - sci do
23908: LD_ADDR_VAR 0 3
23912: PUSH
23913: DOUBLE
23914: LD_INT 1
23916: DEC
23917: ST_TO_ADDR
23918: LD_INT 6
23920: PUSH
23921: LD_VAR 0 8
23925: MINUS
23926: PUSH
23927: FOR_TO
23928: IFFALSE 23983
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23930: LD_ADDR_VAR 0 11
23934: PUSH
23935: LD_VAR 0 11
23939: PPUSH
23940: LD_VAR 0 11
23944: PUSH
23945: LD_INT 1
23947: PLUS
23948: PPUSH
23949: LD_VAR 0 9
23953: PUSH
23954: LD_INT 1
23956: ARRAY
23957: PPUSH
23958: CALL_OW 2
23962: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23963: LD_ADDR_VAR 0 9
23967: PUSH
23968: LD_VAR 0 9
23972: PPUSH
23973: LD_INT 1
23975: PPUSH
23976: CALL_OW 3
23980: ST_TO_ADDR
// end ;
23981: GO 23927
23983: POP
23984: POP
// end else
23985: GO 24007
// if sort then
23987: LD_VAR 0 9
23991: IFFALSE 24007
// p := sort [ 1 ] ;
23993: LD_ADDR_VAR 0 11
23997: PUSH
23998: LD_VAR 0 9
24002: PUSH
24003: LD_INT 1
24005: ARRAY
24006: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24007: LD_ADDR_VAR 0 2
24011: PUSH
24012: LD_INT 0
24014: PUSH
24015: LD_INT 0
24017: PUSH
24018: LD_INT 0
24020: PUSH
24021: LD_VAR 0 11
24025: PUSH
24026: EMPTY
24027: LIST
24028: LIST
24029: LIST
24030: LIST
24031: ST_TO_ADDR
// exit ;
24032: GO 26253
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24034: LD_EXP 77
24038: PUSH
24039: LD_EXP 76
24043: PUSH
24044: LD_VAR 0 1
24048: ARRAY
24049: ARRAY
24050: PUSH
24051: LD_EXP 50
24055: PUSH
24056: LD_VAR 0 1
24060: ARRAY
24061: PPUSH
24062: LD_INT 2
24064: PUSH
24065: LD_INT 30
24067: PUSH
24068: LD_INT 6
24070: PUSH
24071: EMPTY
24072: LIST
24073: LIST
24074: PUSH
24075: LD_INT 30
24077: PUSH
24078: LD_INT 7
24080: PUSH
24081: EMPTY
24082: LIST
24083: LIST
24084: PUSH
24085: LD_INT 30
24087: PUSH
24088: LD_INT 8
24090: PUSH
24091: EMPTY
24092: LIST
24093: LIST
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: LIST
24099: LIST
24100: PPUSH
24101: CALL_OW 72
24105: AND
24106: PUSH
24107: LD_EXP 50
24111: PUSH
24112: LD_VAR 0 1
24116: ARRAY
24117: PPUSH
24118: LD_INT 30
24120: PUSH
24121: LD_INT 3
24123: PUSH
24124: EMPTY
24125: LIST
24126: LIST
24127: PPUSH
24128: CALL_OW 72
24132: AND
24133: IFFALSE 24867
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24135: LD_ADDR_EXP 92
24139: PUSH
24140: LD_EXP 92
24144: PPUSH
24145: LD_VAR 0 1
24149: PPUSH
24150: LD_INT 3
24152: PPUSH
24153: CALL_OW 1
24157: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24158: LD_ADDR_VAR 0 2
24162: PUSH
24163: LD_INT 0
24165: PUSH
24166: LD_INT 0
24168: PUSH
24169: LD_INT 0
24171: PUSH
24172: LD_INT 0
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: ST_TO_ADDR
// if not eng then
24181: LD_VAR 0 6
24185: NOT
24186: IFFALSE 24249
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24188: LD_ADDR_VAR 0 11
24192: PUSH
24193: LD_VAR 0 4
24197: PPUSH
24198: LD_INT 2
24200: PPUSH
24201: CALL 84426 0 2
24205: PUSH
24206: LD_INT 1
24208: ARRAY
24209: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24210: LD_ADDR_VAR 0 2
24214: PUSH
24215: LD_VAR 0 2
24219: PPUSH
24220: LD_INT 2
24222: PPUSH
24223: LD_VAR 0 11
24227: PPUSH
24228: CALL_OW 1
24232: ST_TO_ADDR
// tmp := tmp diff p ;
24233: LD_ADDR_VAR 0 4
24237: PUSH
24238: LD_VAR 0 4
24242: PUSH
24243: LD_VAR 0 11
24247: DIFF
24248: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24249: LD_VAR 0 4
24253: PUSH
24254: LD_VAR 0 8
24258: PUSH
24259: LD_INT 6
24261: LESS
24262: AND
24263: IFFALSE 24451
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24265: LD_ADDR_VAR 0 9
24269: PUSH
24270: LD_VAR 0 4
24274: PUSH
24275: LD_VAR 0 8
24279: PUSH
24280: LD_VAR 0 7
24284: UNION
24285: DIFF
24286: PPUSH
24287: LD_INT 4
24289: PPUSH
24290: CALL 84426 0 2
24294: ST_TO_ADDR
// p := [ ] ;
24295: LD_ADDR_VAR 0 11
24299: PUSH
24300: EMPTY
24301: ST_TO_ADDR
// if sort then
24302: LD_VAR 0 9
24306: IFFALSE 24422
// for i = 1 to 6 - sci do
24308: LD_ADDR_VAR 0 3
24312: PUSH
24313: DOUBLE
24314: LD_INT 1
24316: DEC
24317: ST_TO_ADDR
24318: LD_INT 6
24320: PUSH
24321: LD_VAR 0 8
24325: MINUS
24326: PUSH
24327: FOR_TO
24328: IFFALSE 24420
// begin if i = sort then
24330: LD_VAR 0 3
24334: PUSH
24335: LD_VAR 0 9
24339: EQUAL
24340: IFFALSE 24344
// break ;
24342: GO 24420
// if GetClass ( i ) = 4 then
24344: LD_VAR 0 3
24348: PPUSH
24349: CALL_OW 257
24353: PUSH
24354: LD_INT 4
24356: EQUAL
24357: IFFALSE 24361
// continue ;
24359: GO 24327
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24361: LD_ADDR_VAR 0 11
24365: PUSH
24366: LD_VAR 0 11
24370: PPUSH
24371: LD_VAR 0 11
24375: PUSH
24376: LD_INT 1
24378: PLUS
24379: PPUSH
24380: LD_VAR 0 9
24384: PUSH
24385: LD_VAR 0 3
24389: ARRAY
24390: PPUSH
24391: CALL_OW 2
24395: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24396: LD_ADDR_VAR 0 4
24400: PUSH
24401: LD_VAR 0 4
24405: PUSH
24406: LD_VAR 0 9
24410: PUSH
24411: LD_VAR 0 3
24415: ARRAY
24416: DIFF
24417: ST_TO_ADDR
// end ;
24418: GO 24327
24420: POP
24421: POP
// if p then
24422: LD_VAR 0 11
24426: IFFALSE 24451
// result := Replace ( result , 4 , p ) ;
24428: LD_ADDR_VAR 0 2
24432: PUSH
24433: LD_VAR 0 2
24437: PPUSH
24438: LD_INT 4
24440: PPUSH
24441: LD_VAR 0 11
24445: PPUSH
24446: CALL_OW 1
24450: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24451: LD_VAR 0 4
24455: PUSH
24456: LD_VAR 0 7
24460: PUSH
24461: LD_INT 6
24463: LESS
24464: AND
24465: IFFALSE 24653
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24467: LD_ADDR_VAR 0 9
24471: PUSH
24472: LD_VAR 0 4
24476: PUSH
24477: LD_VAR 0 8
24481: PUSH
24482: LD_VAR 0 7
24486: UNION
24487: DIFF
24488: PPUSH
24489: LD_INT 3
24491: PPUSH
24492: CALL 84426 0 2
24496: ST_TO_ADDR
// p := [ ] ;
24497: LD_ADDR_VAR 0 11
24501: PUSH
24502: EMPTY
24503: ST_TO_ADDR
// if sort then
24504: LD_VAR 0 9
24508: IFFALSE 24624
// for i = 1 to 6 - mech do
24510: LD_ADDR_VAR 0 3
24514: PUSH
24515: DOUBLE
24516: LD_INT 1
24518: DEC
24519: ST_TO_ADDR
24520: LD_INT 6
24522: PUSH
24523: LD_VAR 0 7
24527: MINUS
24528: PUSH
24529: FOR_TO
24530: IFFALSE 24622
// begin if i = sort then
24532: LD_VAR 0 3
24536: PUSH
24537: LD_VAR 0 9
24541: EQUAL
24542: IFFALSE 24546
// break ;
24544: GO 24622
// if GetClass ( i ) = 3 then
24546: LD_VAR 0 3
24550: PPUSH
24551: CALL_OW 257
24555: PUSH
24556: LD_INT 3
24558: EQUAL
24559: IFFALSE 24563
// continue ;
24561: GO 24529
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24563: LD_ADDR_VAR 0 11
24567: PUSH
24568: LD_VAR 0 11
24572: PPUSH
24573: LD_VAR 0 11
24577: PUSH
24578: LD_INT 1
24580: PLUS
24581: PPUSH
24582: LD_VAR 0 9
24586: PUSH
24587: LD_VAR 0 3
24591: ARRAY
24592: PPUSH
24593: CALL_OW 2
24597: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24598: LD_ADDR_VAR 0 4
24602: PUSH
24603: LD_VAR 0 4
24607: PUSH
24608: LD_VAR 0 9
24612: PUSH
24613: LD_VAR 0 3
24617: ARRAY
24618: DIFF
24619: ST_TO_ADDR
// end ;
24620: GO 24529
24622: POP
24623: POP
// if p then
24624: LD_VAR 0 11
24628: IFFALSE 24653
// result := Replace ( result , 3 , p ) ;
24630: LD_ADDR_VAR 0 2
24634: PUSH
24635: LD_VAR 0 2
24639: PPUSH
24640: LD_INT 3
24642: PPUSH
24643: LD_VAR 0 11
24647: PPUSH
24648: CALL_OW 1
24652: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24653: LD_VAR 0 4
24657: PUSH
24658: LD_INT 6
24660: GREATER
24661: PUSH
24662: LD_VAR 0 6
24666: PUSH
24667: LD_INT 6
24669: LESS
24670: AND
24671: IFFALSE 24865
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24673: LD_ADDR_VAR 0 9
24677: PUSH
24678: LD_VAR 0 4
24682: PUSH
24683: LD_VAR 0 8
24687: PUSH
24688: LD_VAR 0 7
24692: UNION
24693: PUSH
24694: LD_VAR 0 6
24698: UNION
24699: DIFF
24700: PPUSH
24701: LD_INT 2
24703: PPUSH
24704: CALL 84426 0 2
24708: ST_TO_ADDR
// p := [ ] ;
24709: LD_ADDR_VAR 0 11
24713: PUSH
24714: EMPTY
24715: ST_TO_ADDR
// if sort then
24716: LD_VAR 0 9
24720: IFFALSE 24836
// for i = 1 to 6 - eng do
24722: LD_ADDR_VAR 0 3
24726: PUSH
24727: DOUBLE
24728: LD_INT 1
24730: DEC
24731: ST_TO_ADDR
24732: LD_INT 6
24734: PUSH
24735: LD_VAR 0 6
24739: MINUS
24740: PUSH
24741: FOR_TO
24742: IFFALSE 24834
// begin if i = sort then
24744: LD_VAR 0 3
24748: PUSH
24749: LD_VAR 0 9
24753: EQUAL
24754: IFFALSE 24758
// break ;
24756: GO 24834
// if GetClass ( i ) = 2 then
24758: LD_VAR 0 3
24762: PPUSH
24763: CALL_OW 257
24767: PUSH
24768: LD_INT 2
24770: EQUAL
24771: IFFALSE 24775
// continue ;
24773: GO 24741
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24775: LD_ADDR_VAR 0 11
24779: PUSH
24780: LD_VAR 0 11
24784: PPUSH
24785: LD_VAR 0 11
24789: PUSH
24790: LD_INT 1
24792: PLUS
24793: PPUSH
24794: LD_VAR 0 9
24798: PUSH
24799: LD_VAR 0 3
24803: ARRAY
24804: PPUSH
24805: CALL_OW 2
24809: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24810: LD_ADDR_VAR 0 4
24814: PUSH
24815: LD_VAR 0 4
24819: PUSH
24820: LD_VAR 0 9
24824: PUSH
24825: LD_VAR 0 3
24829: ARRAY
24830: DIFF
24831: ST_TO_ADDR
// end ;
24832: GO 24741
24834: POP
24835: POP
// if p then
24836: LD_VAR 0 11
24840: IFFALSE 24865
// result := Replace ( result , 2 , p ) ;
24842: LD_ADDR_VAR 0 2
24846: PUSH
24847: LD_VAR 0 2
24851: PPUSH
24852: LD_INT 2
24854: PPUSH
24855: LD_VAR 0 11
24859: PPUSH
24860: CALL_OW 1
24864: ST_TO_ADDR
// end ; exit ;
24865: GO 26253
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24867: LD_EXP 77
24871: PUSH
24872: LD_EXP 76
24876: PUSH
24877: LD_VAR 0 1
24881: ARRAY
24882: ARRAY
24883: NOT
24884: PUSH
24885: LD_EXP 50
24889: PUSH
24890: LD_VAR 0 1
24894: ARRAY
24895: PPUSH
24896: LD_INT 30
24898: PUSH
24899: LD_INT 3
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PPUSH
24906: CALL_OW 72
24910: AND
24911: PUSH
24912: LD_EXP 55
24916: PUSH
24917: LD_VAR 0 1
24921: ARRAY
24922: AND
24923: IFFALSE 25531
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24925: LD_ADDR_EXP 92
24929: PUSH
24930: LD_EXP 92
24934: PPUSH
24935: LD_VAR 0 1
24939: PPUSH
24940: LD_INT 5
24942: PPUSH
24943: CALL_OW 1
24947: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24948: LD_ADDR_VAR 0 2
24952: PUSH
24953: LD_INT 0
24955: PUSH
24956: LD_INT 0
24958: PUSH
24959: LD_INT 0
24961: PUSH
24962: LD_INT 0
24964: PUSH
24965: EMPTY
24966: LIST
24967: LIST
24968: LIST
24969: LIST
24970: ST_TO_ADDR
// if sci > 1 then
24971: LD_VAR 0 8
24975: PUSH
24976: LD_INT 1
24978: GREATER
24979: IFFALSE 25007
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24981: LD_ADDR_VAR 0 4
24985: PUSH
24986: LD_VAR 0 4
24990: PUSH
24991: LD_VAR 0 8
24995: PUSH
24996: LD_VAR 0 8
25000: PUSH
25001: LD_INT 1
25003: ARRAY
25004: DIFF
25005: DIFF
25006: ST_TO_ADDR
// if tmp and not sci then
25007: LD_VAR 0 4
25011: PUSH
25012: LD_VAR 0 8
25016: NOT
25017: AND
25018: IFFALSE 25087
// begin sort := SortBySkill ( tmp , 4 ) ;
25020: LD_ADDR_VAR 0 9
25024: PUSH
25025: LD_VAR 0 4
25029: PPUSH
25030: LD_INT 4
25032: PPUSH
25033: CALL 84426 0 2
25037: ST_TO_ADDR
// if sort then
25038: LD_VAR 0 9
25042: IFFALSE 25058
// p := sort [ 1 ] ;
25044: LD_ADDR_VAR 0 11
25048: PUSH
25049: LD_VAR 0 9
25053: PUSH
25054: LD_INT 1
25056: ARRAY
25057: ST_TO_ADDR
// if p then
25058: LD_VAR 0 11
25062: IFFALSE 25087
// result := Replace ( result , 4 , p ) ;
25064: LD_ADDR_VAR 0 2
25068: PUSH
25069: LD_VAR 0 2
25073: PPUSH
25074: LD_INT 4
25076: PPUSH
25077: LD_VAR 0 11
25081: PPUSH
25082: CALL_OW 1
25086: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_VAR 0 4
25096: PUSH
25097: LD_VAR 0 7
25101: DIFF
25102: ST_TO_ADDR
// if tmp and mech < 6 then
25103: LD_VAR 0 4
25107: PUSH
25108: LD_VAR 0 7
25112: PUSH
25113: LD_INT 6
25115: LESS
25116: AND
25117: IFFALSE 25305
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25119: LD_ADDR_VAR 0 9
25123: PUSH
25124: LD_VAR 0 4
25128: PUSH
25129: LD_VAR 0 8
25133: PUSH
25134: LD_VAR 0 7
25138: UNION
25139: DIFF
25140: PPUSH
25141: LD_INT 3
25143: PPUSH
25144: CALL 84426 0 2
25148: ST_TO_ADDR
// p := [ ] ;
25149: LD_ADDR_VAR 0 11
25153: PUSH
25154: EMPTY
25155: ST_TO_ADDR
// if sort then
25156: LD_VAR 0 9
25160: IFFALSE 25276
// for i = 1 to 6 - mech do
25162: LD_ADDR_VAR 0 3
25166: PUSH
25167: DOUBLE
25168: LD_INT 1
25170: DEC
25171: ST_TO_ADDR
25172: LD_INT 6
25174: PUSH
25175: LD_VAR 0 7
25179: MINUS
25180: PUSH
25181: FOR_TO
25182: IFFALSE 25274
// begin if i = sort then
25184: LD_VAR 0 3
25188: PUSH
25189: LD_VAR 0 9
25193: EQUAL
25194: IFFALSE 25198
// break ;
25196: GO 25274
// if GetClass ( i ) = 3 then
25198: LD_VAR 0 3
25202: PPUSH
25203: CALL_OW 257
25207: PUSH
25208: LD_INT 3
25210: EQUAL
25211: IFFALSE 25215
// continue ;
25213: GO 25181
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25215: LD_ADDR_VAR 0 11
25219: PUSH
25220: LD_VAR 0 11
25224: PPUSH
25225: LD_VAR 0 11
25229: PUSH
25230: LD_INT 1
25232: PLUS
25233: PPUSH
25234: LD_VAR 0 9
25238: PUSH
25239: LD_VAR 0 3
25243: ARRAY
25244: PPUSH
25245: CALL_OW 2
25249: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25250: LD_ADDR_VAR 0 4
25254: PUSH
25255: LD_VAR 0 4
25259: PUSH
25260: LD_VAR 0 9
25264: PUSH
25265: LD_VAR 0 3
25269: ARRAY
25270: DIFF
25271: ST_TO_ADDR
// end ;
25272: GO 25181
25274: POP
25275: POP
// if p then
25276: LD_VAR 0 11
25280: IFFALSE 25305
// result := Replace ( result , 3 , p ) ;
25282: LD_ADDR_VAR 0 2
25286: PUSH
25287: LD_VAR 0 2
25291: PPUSH
25292: LD_INT 3
25294: PPUSH
25295: LD_VAR 0 11
25299: PPUSH
25300: CALL_OW 1
25304: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25305: LD_ADDR_VAR 0 4
25309: PUSH
25310: LD_VAR 0 4
25314: PUSH
25315: LD_VAR 0 6
25319: DIFF
25320: ST_TO_ADDR
// if tmp and eng < 6 then
25321: LD_VAR 0 4
25325: PUSH
25326: LD_VAR 0 6
25330: PUSH
25331: LD_INT 6
25333: LESS
25334: AND
25335: IFFALSE 25529
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25337: LD_ADDR_VAR 0 9
25341: PUSH
25342: LD_VAR 0 4
25346: PUSH
25347: LD_VAR 0 8
25351: PUSH
25352: LD_VAR 0 7
25356: UNION
25357: PUSH
25358: LD_VAR 0 6
25362: UNION
25363: DIFF
25364: PPUSH
25365: LD_INT 2
25367: PPUSH
25368: CALL 84426 0 2
25372: ST_TO_ADDR
// p := [ ] ;
25373: LD_ADDR_VAR 0 11
25377: PUSH
25378: EMPTY
25379: ST_TO_ADDR
// if sort then
25380: LD_VAR 0 9
25384: IFFALSE 25500
// for i = 1 to 6 - eng do
25386: LD_ADDR_VAR 0 3
25390: PUSH
25391: DOUBLE
25392: LD_INT 1
25394: DEC
25395: ST_TO_ADDR
25396: LD_INT 6
25398: PUSH
25399: LD_VAR 0 6
25403: MINUS
25404: PUSH
25405: FOR_TO
25406: IFFALSE 25498
// begin if i = sort then
25408: LD_VAR 0 3
25412: PUSH
25413: LD_VAR 0 9
25417: EQUAL
25418: IFFALSE 25422
// break ;
25420: GO 25498
// if GetClass ( i ) = 2 then
25422: LD_VAR 0 3
25426: PPUSH
25427: CALL_OW 257
25431: PUSH
25432: LD_INT 2
25434: EQUAL
25435: IFFALSE 25439
// continue ;
25437: GO 25405
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25439: LD_ADDR_VAR 0 11
25443: PUSH
25444: LD_VAR 0 11
25448: PPUSH
25449: LD_VAR 0 11
25453: PUSH
25454: LD_INT 1
25456: PLUS
25457: PPUSH
25458: LD_VAR 0 9
25462: PUSH
25463: LD_VAR 0 3
25467: ARRAY
25468: PPUSH
25469: CALL_OW 2
25473: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25474: LD_ADDR_VAR 0 4
25478: PUSH
25479: LD_VAR 0 4
25483: PUSH
25484: LD_VAR 0 9
25488: PUSH
25489: LD_VAR 0 3
25493: ARRAY
25494: DIFF
25495: ST_TO_ADDR
// end ;
25496: GO 25405
25498: POP
25499: POP
// if p then
25500: LD_VAR 0 11
25504: IFFALSE 25529
// result := Replace ( result , 2 , p ) ;
25506: LD_ADDR_VAR 0 2
25510: PUSH
25511: LD_VAR 0 2
25515: PPUSH
25516: LD_INT 2
25518: PPUSH
25519: LD_VAR 0 11
25523: PPUSH
25524: CALL_OW 1
25528: ST_TO_ADDR
// end ; exit ;
25529: GO 26253
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25531: LD_EXP 77
25535: PUSH
25536: LD_EXP 76
25540: PUSH
25541: LD_VAR 0 1
25545: ARRAY
25546: ARRAY
25547: NOT
25548: PUSH
25549: LD_EXP 50
25553: PUSH
25554: LD_VAR 0 1
25558: ARRAY
25559: PPUSH
25560: LD_INT 30
25562: PUSH
25563: LD_INT 3
25565: PUSH
25566: EMPTY
25567: LIST
25568: LIST
25569: PPUSH
25570: CALL_OW 72
25574: AND
25575: PUSH
25576: LD_EXP 55
25580: PUSH
25581: LD_VAR 0 1
25585: ARRAY
25586: NOT
25587: AND
25588: IFFALSE 26253
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25590: LD_ADDR_EXP 92
25594: PUSH
25595: LD_EXP 92
25599: PPUSH
25600: LD_VAR 0 1
25604: PPUSH
25605: LD_INT 6
25607: PPUSH
25608: CALL_OW 1
25612: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25613: LD_ADDR_VAR 0 2
25617: PUSH
25618: LD_INT 0
25620: PUSH
25621: LD_INT 0
25623: PUSH
25624: LD_INT 0
25626: PUSH
25627: LD_INT 0
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: LIST
25634: LIST
25635: ST_TO_ADDR
// if sci >= 1 then
25636: LD_VAR 0 8
25640: PUSH
25641: LD_INT 1
25643: GREATEREQUAL
25644: IFFALSE 25666
// tmp := tmp diff sci [ 1 ] ;
25646: LD_ADDR_VAR 0 4
25650: PUSH
25651: LD_VAR 0 4
25655: PUSH
25656: LD_VAR 0 8
25660: PUSH
25661: LD_INT 1
25663: ARRAY
25664: DIFF
25665: ST_TO_ADDR
// if tmp and not sci then
25666: LD_VAR 0 4
25670: PUSH
25671: LD_VAR 0 8
25675: NOT
25676: AND
25677: IFFALSE 25746
// begin sort := SortBySkill ( tmp , 4 ) ;
25679: LD_ADDR_VAR 0 9
25683: PUSH
25684: LD_VAR 0 4
25688: PPUSH
25689: LD_INT 4
25691: PPUSH
25692: CALL 84426 0 2
25696: ST_TO_ADDR
// if sort then
25697: LD_VAR 0 9
25701: IFFALSE 25717
// p := sort [ 1 ] ;
25703: LD_ADDR_VAR 0 11
25707: PUSH
25708: LD_VAR 0 9
25712: PUSH
25713: LD_INT 1
25715: ARRAY
25716: ST_TO_ADDR
// if p then
25717: LD_VAR 0 11
25721: IFFALSE 25746
// result := Replace ( result , 4 , p ) ;
25723: LD_ADDR_VAR 0 2
25727: PUSH
25728: LD_VAR 0 2
25732: PPUSH
25733: LD_INT 4
25735: PPUSH
25736: LD_VAR 0 11
25740: PPUSH
25741: CALL_OW 1
25745: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25746: LD_ADDR_VAR 0 4
25750: PUSH
25751: LD_VAR 0 4
25755: PUSH
25756: LD_VAR 0 7
25760: DIFF
25761: ST_TO_ADDR
// if tmp and mech < 6 then
25762: LD_VAR 0 4
25766: PUSH
25767: LD_VAR 0 7
25771: PUSH
25772: LD_INT 6
25774: LESS
25775: AND
25776: IFFALSE 25958
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25778: LD_ADDR_VAR 0 9
25782: PUSH
25783: LD_VAR 0 4
25787: PUSH
25788: LD_VAR 0 7
25792: DIFF
25793: PPUSH
25794: LD_INT 3
25796: PPUSH
25797: CALL 84426 0 2
25801: ST_TO_ADDR
// p := [ ] ;
25802: LD_ADDR_VAR 0 11
25806: PUSH
25807: EMPTY
25808: ST_TO_ADDR
// if sort then
25809: LD_VAR 0 9
25813: IFFALSE 25929
// for i = 1 to 6 - mech do
25815: LD_ADDR_VAR 0 3
25819: PUSH
25820: DOUBLE
25821: LD_INT 1
25823: DEC
25824: ST_TO_ADDR
25825: LD_INT 6
25827: PUSH
25828: LD_VAR 0 7
25832: MINUS
25833: PUSH
25834: FOR_TO
25835: IFFALSE 25927
// begin if i = sort then
25837: LD_VAR 0 3
25841: PUSH
25842: LD_VAR 0 9
25846: EQUAL
25847: IFFALSE 25851
// break ;
25849: GO 25927
// if GetClass ( i ) = 3 then
25851: LD_VAR 0 3
25855: PPUSH
25856: CALL_OW 257
25860: PUSH
25861: LD_INT 3
25863: EQUAL
25864: IFFALSE 25868
// continue ;
25866: GO 25834
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25868: LD_ADDR_VAR 0 11
25872: PUSH
25873: LD_VAR 0 11
25877: PPUSH
25878: LD_VAR 0 11
25882: PUSH
25883: LD_INT 1
25885: PLUS
25886: PPUSH
25887: LD_VAR 0 9
25891: PUSH
25892: LD_VAR 0 3
25896: ARRAY
25897: PPUSH
25898: CALL_OW 2
25902: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25903: LD_ADDR_VAR 0 4
25907: PUSH
25908: LD_VAR 0 4
25912: PUSH
25913: LD_VAR 0 9
25917: PUSH
25918: LD_VAR 0 3
25922: ARRAY
25923: DIFF
25924: ST_TO_ADDR
// end ;
25925: GO 25834
25927: POP
25928: POP
// if p then
25929: LD_VAR 0 11
25933: IFFALSE 25958
// result := Replace ( result , 3 , p ) ;
25935: LD_ADDR_VAR 0 2
25939: PUSH
25940: LD_VAR 0 2
25944: PPUSH
25945: LD_INT 3
25947: PPUSH
25948: LD_VAR 0 11
25952: PPUSH
25953: CALL_OW 1
25957: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25958: LD_ADDR_VAR 0 4
25962: PUSH
25963: LD_VAR 0 4
25967: PUSH
25968: LD_VAR 0 6
25972: DIFF
25973: ST_TO_ADDR
// if tmp and eng < 4 then
25974: LD_VAR 0 4
25978: PUSH
25979: LD_VAR 0 6
25983: PUSH
25984: LD_INT 4
25986: LESS
25987: AND
25988: IFFALSE 26178
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25990: LD_ADDR_VAR 0 9
25994: PUSH
25995: LD_VAR 0 4
25999: PUSH
26000: LD_VAR 0 7
26004: PUSH
26005: LD_VAR 0 6
26009: UNION
26010: DIFF
26011: PPUSH
26012: LD_INT 2
26014: PPUSH
26015: CALL 84426 0 2
26019: ST_TO_ADDR
// p := [ ] ;
26020: LD_ADDR_VAR 0 11
26024: PUSH
26025: EMPTY
26026: ST_TO_ADDR
// if sort then
26027: LD_VAR 0 9
26031: IFFALSE 26147
// for i = 1 to 4 - eng do
26033: LD_ADDR_VAR 0 3
26037: PUSH
26038: DOUBLE
26039: LD_INT 1
26041: DEC
26042: ST_TO_ADDR
26043: LD_INT 4
26045: PUSH
26046: LD_VAR 0 6
26050: MINUS
26051: PUSH
26052: FOR_TO
26053: IFFALSE 26145
// begin if i = sort then
26055: LD_VAR 0 3
26059: PUSH
26060: LD_VAR 0 9
26064: EQUAL
26065: IFFALSE 26069
// break ;
26067: GO 26145
// if GetClass ( i ) = 2 then
26069: LD_VAR 0 3
26073: PPUSH
26074: CALL_OW 257
26078: PUSH
26079: LD_INT 2
26081: EQUAL
26082: IFFALSE 26086
// continue ;
26084: GO 26052
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26086: LD_ADDR_VAR 0 11
26090: PUSH
26091: LD_VAR 0 11
26095: PPUSH
26096: LD_VAR 0 11
26100: PUSH
26101: LD_INT 1
26103: PLUS
26104: PPUSH
26105: LD_VAR 0 9
26109: PUSH
26110: LD_VAR 0 3
26114: ARRAY
26115: PPUSH
26116: CALL_OW 2
26120: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26121: LD_ADDR_VAR 0 4
26125: PUSH
26126: LD_VAR 0 4
26130: PUSH
26131: LD_VAR 0 9
26135: PUSH
26136: LD_VAR 0 3
26140: ARRAY
26141: DIFF
26142: ST_TO_ADDR
// end ;
26143: GO 26052
26145: POP
26146: POP
// if p then
26147: LD_VAR 0 11
26151: IFFALSE 26176
// result := Replace ( result , 2 , p ) ;
26153: LD_ADDR_VAR 0 2
26157: PUSH
26158: LD_VAR 0 2
26162: PPUSH
26163: LD_INT 2
26165: PPUSH
26166: LD_VAR 0 11
26170: PPUSH
26171: CALL_OW 1
26175: ST_TO_ADDR
// end else
26176: GO 26222
// for i = eng downto 5 do
26178: LD_ADDR_VAR 0 3
26182: PUSH
26183: DOUBLE
26184: LD_VAR 0 6
26188: INC
26189: ST_TO_ADDR
26190: LD_INT 5
26192: PUSH
26193: FOR_DOWNTO
26194: IFFALSE 26220
// tmp := tmp union eng [ i ] ;
26196: LD_ADDR_VAR 0 4
26200: PUSH
26201: LD_VAR 0 4
26205: PUSH
26206: LD_VAR 0 6
26210: PUSH
26211: LD_VAR 0 3
26215: ARRAY
26216: UNION
26217: ST_TO_ADDR
26218: GO 26193
26220: POP
26221: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26222: LD_ADDR_VAR 0 2
26226: PUSH
26227: LD_VAR 0 2
26231: PPUSH
26232: LD_INT 1
26234: PPUSH
26235: LD_VAR 0 4
26239: PUSH
26240: LD_VAR 0 5
26244: DIFF
26245: PPUSH
26246: CALL_OW 1
26250: ST_TO_ADDR
// exit ;
26251: GO 26253
// end ; end ;
26253: LD_VAR 0 2
26257: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26258: LD_INT 0
26260: PPUSH
26261: PPUSH
26262: PPUSH
// if not mc_bases then
26263: LD_EXP 50
26267: NOT
26268: IFFALSE 26272
// exit ;
26270: GO 26414
// for i = 1 to mc_bases do
26272: LD_ADDR_VAR 0 2
26276: PUSH
26277: DOUBLE
26278: LD_INT 1
26280: DEC
26281: ST_TO_ADDR
26282: LD_EXP 50
26286: PUSH
26287: FOR_TO
26288: IFFALSE 26405
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26290: LD_ADDR_VAR 0 3
26294: PUSH
26295: LD_EXP 50
26299: PUSH
26300: LD_VAR 0 2
26304: ARRAY
26305: PPUSH
26306: LD_INT 21
26308: PUSH
26309: LD_INT 3
26311: PUSH
26312: EMPTY
26313: LIST
26314: LIST
26315: PUSH
26316: LD_INT 3
26318: PUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 29
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 30
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: LIST
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: LD_INT 24
26356: PUSH
26357: LD_INT 1000
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: PPUSH
26373: CALL_OW 72
26377: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26378: LD_ADDR_EXP 51
26382: PUSH
26383: LD_EXP 51
26387: PPUSH
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_VAR 0 3
26397: PPUSH
26398: CALL_OW 1
26402: ST_TO_ADDR
// end ;
26403: GO 26287
26405: POP
26406: POP
// RaiseSailEvent ( 101 ) ;
26407: LD_INT 101
26409: PPUSH
26410: CALL_OW 427
// end ;
26414: LD_VAR 0 1
26418: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26419: LD_INT 0
26421: PPUSH
26422: PPUSH
26423: PPUSH
26424: PPUSH
26425: PPUSH
26426: PPUSH
26427: PPUSH
// if not mc_bases then
26428: LD_EXP 50
26432: NOT
26433: IFFALSE 26437
// exit ;
26435: GO 26999
// for i = 1 to mc_bases do
26437: LD_ADDR_VAR 0 2
26441: PUSH
26442: DOUBLE
26443: LD_INT 1
26445: DEC
26446: ST_TO_ADDR
26447: LD_EXP 50
26451: PUSH
26452: FOR_TO
26453: IFFALSE 26990
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26455: LD_ADDR_VAR 0 5
26459: PUSH
26460: LD_EXP 50
26464: PUSH
26465: LD_VAR 0 2
26469: ARRAY
26470: PUSH
26471: LD_EXP 79
26475: PUSH
26476: LD_VAR 0 2
26480: ARRAY
26481: UNION
26482: PPUSH
26483: LD_INT 21
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: EMPTY
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 1
26495: PUSH
26496: LD_INT 3
26498: PUSH
26499: LD_INT 54
26501: PUSH
26502: EMPTY
26503: LIST
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 3
26511: PUSH
26512: LD_INT 24
26514: PUSH
26515: LD_INT 1000
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: EMPTY
26527: LIST
26528: LIST
26529: LIST
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: PPUSH
26535: CALL_OW 72
26539: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26540: LD_ADDR_VAR 0 6
26544: PUSH
26545: LD_EXP 50
26549: PUSH
26550: LD_VAR 0 2
26554: ARRAY
26555: PPUSH
26556: LD_INT 21
26558: PUSH
26559: LD_INT 1
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 1
26568: PUSH
26569: LD_INT 3
26571: PUSH
26572: LD_INT 54
26574: PUSH
26575: EMPTY
26576: LIST
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 3
26584: PUSH
26585: LD_INT 24
26587: PUSH
26588: LD_INT 250
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: LIST
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: PPUSH
26608: CALL_OW 72
26612: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26613: LD_ADDR_VAR 0 7
26617: PUSH
26618: LD_VAR 0 5
26622: PUSH
26623: LD_VAR 0 6
26627: DIFF
26628: ST_TO_ADDR
// if not need_heal_1 then
26629: LD_VAR 0 6
26633: NOT
26634: IFFALSE 26667
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26636: LD_ADDR_EXP 53
26640: PUSH
26641: LD_EXP 53
26645: PPUSH
26646: LD_VAR 0 2
26650: PUSH
26651: LD_INT 1
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PPUSH
26658: EMPTY
26659: PPUSH
26660: CALL 53678 0 3
26664: ST_TO_ADDR
26665: GO 26737
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26667: LD_ADDR_EXP 53
26671: PUSH
26672: LD_EXP 53
26676: PPUSH
26677: LD_VAR 0 2
26681: PUSH
26682: LD_INT 1
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: PPUSH
26689: LD_EXP 53
26693: PUSH
26694: LD_VAR 0 2
26698: ARRAY
26699: PUSH
26700: LD_INT 1
26702: ARRAY
26703: PPUSH
26704: LD_INT 3
26706: PUSH
26707: LD_INT 24
26709: PUSH
26710: LD_INT 1000
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: PPUSH
26721: CALL_OW 72
26725: PUSH
26726: LD_VAR 0 6
26730: UNION
26731: PPUSH
26732: CALL 53678 0 3
26736: ST_TO_ADDR
// if not need_heal_2 then
26737: LD_VAR 0 7
26741: NOT
26742: IFFALSE 26775
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26744: LD_ADDR_EXP 53
26748: PUSH
26749: LD_EXP 53
26753: PPUSH
26754: LD_VAR 0 2
26758: PUSH
26759: LD_INT 2
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: PPUSH
26766: EMPTY
26767: PPUSH
26768: CALL 53678 0 3
26772: ST_TO_ADDR
26773: GO 26807
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26775: LD_ADDR_EXP 53
26779: PUSH
26780: LD_EXP 53
26784: PPUSH
26785: LD_VAR 0 2
26789: PUSH
26790: LD_INT 2
26792: PUSH
26793: EMPTY
26794: LIST
26795: LIST
26796: PPUSH
26797: LD_VAR 0 7
26801: PPUSH
26802: CALL 53678 0 3
26806: ST_TO_ADDR
// if need_heal_2 then
26807: LD_VAR 0 7
26811: IFFALSE 26972
// for j in need_heal_2 do
26813: LD_ADDR_VAR 0 3
26817: PUSH
26818: LD_VAR 0 7
26822: PUSH
26823: FOR_IN
26824: IFFALSE 26970
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26826: LD_ADDR_VAR 0 5
26830: PUSH
26831: LD_EXP 50
26835: PUSH
26836: LD_VAR 0 2
26840: ARRAY
26841: PPUSH
26842: LD_INT 2
26844: PUSH
26845: LD_INT 30
26847: PUSH
26848: LD_INT 6
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: PUSH
26855: LD_INT 30
26857: PUSH
26858: LD_INT 7
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 30
26867: PUSH
26868: LD_INT 8
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PUSH
26875: LD_INT 30
26877: PUSH
26878: LD_INT 0
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 30
26887: PUSH
26888: LD_INT 1
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: PPUSH
26903: CALL_OW 72
26907: ST_TO_ADDR
// if tmp then
26908: LD_VAR 0 5
26912: IFFALSE 26968
// begin k := NearestUnitToUnit ( tmp , j ) ;
26914: LD_ADDR_VAR 0 4
26918: PUSH
26919: LD_VAR 0 5
26923: PPUSH
26924: LD_VAR 0 3
26928: PPUSH
26929: CALL_OW 74
26933: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26934: LD_VAR 0 3
26938: PPUSH
26939: LD_VAR 0 4
26943: PPUSH
26944: CALL_OW 296
26948: PUSH
26949: LD_INT 5
26951: GREATER
26952: IFFALSE 26968
// ComMoveToNearbyEntrance ( j , k ) ;
26954: LD_VAR 0 3
26958: PPUSH
26959: LD_VAR 0 4
26963: PPUSH
26964: CALL 86794 0 2
// end ; end ;
26968: GO 26823
26970: POP
26971: POP
// if not need_heal_1 and not need_heal_2 then
26972: LD_VAR 0 6
26976: NOT
26977: PUSH
26978: LD_VAR 0 7
26982: NOT
26983: AND
26984: IFFALSE 26988
// continue ;
26986: GO 26452
// end ;
26988: GO 26452
26990: POP
26991: POP
// RaiseSailEvent ( 102 ) ;
26992: LD_INT 102
26994: PPUSH
26995: CALL_OW 427
// end ;
26999: LD_VAR 0 1
27003: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27004: LD_INT 0
27006: PPUSH
27007: PPUSH
27008: PPUSH
27009: PPUSH
27010: PPUSH
27011: PPUSH
27012: PPUSH
27013: PPUSH
// if not mc_bases then
27014: LD_EXP 50
27018: NOT
27019: IFFALSE 27023
// exit ;
27021: GO 27902
// for i = 1 to mc_bases do
27023: LD_ADDR_VAR 0 2
27027: PUSH
27028: DOUBLE
27029: LD_INT 1
27031: DEC
27032: ST_TO_ADDR
27033: LD_EXP 50
27037: PUSH
27038: FOR_TO
27039: IFFALSE 27900
// begin if not mc_building_need_repair [ i ] then
27041: LD_EXP 51
27045: PUSH
27046: LD_VAR 0 2
27050: ARRAY
27051: NOT
27052: IFFALSE 27237
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27054: LD_ADDR_VAR 0 6
27058: PUSH
27059: LD_EXP 69
27063: PUSH
27064: LD_VAR 0 2
27068: ARRAY
27069: PPUSH
27070: LD_INT 3
27072: PUSH
27073: LD_INT 24
27075: PUSH
27076: LD_INT 1000
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 2
27089: PUSH
27090: LD_INT 34
27092: PUSH
27093: LD_INT 13
27095: PUSH
27096: EMPTY
27097: LIST
27098: LIST
27099: PUSH
27100: LD_INT 34
27102: PUSH
27103: LD_INT 52
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 34
27112: PUSH
27113: LD_INT 88
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: LIST
27124: LIST
27125: PUSH
27126: EMPTY
27127: LIST
27128: LIST
27129: PPUSH
27130: CALL_OW 72
27134: ST_TO_ADDR
// if cranes then
27135: LD_VAR 0 6
27139: IFFALSE 27201
// for j in cranes do
27141: LD_ADDR_VAR 0 3
27145: PUSH
27146: LD_VAR 0 6
27150: PUSH
27151: FOR_IN
27152: IFFALSE 27199
// if not IsInArea ( j , mc_parking [ i ] ) then
27154: LD_VAR 0 3
27158: PPUSH
27159: LD_EXP 74
27163: PUSH
27164: LD_VAR 0 2
27168: ARRAY
27169: PPUSH
27170: CALL_OW 308
27174: NOT
27175: IFFALSE 27197
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27177: LD_VAR 0 3
27181: PPUSH
27182: LD_EXP 74
27186: PUSH
27187: LD_VAR 0 2
27191: ARRAY
27192: PPUSH
27193: CALL_OW 113
27197: GO 27151
27199: POP
27200: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27201: LD_ADDR_EXP 52
27205: PUSH
27206: LD_EXP 52
27210: PPUSH
27211: LD_VAR 0 2
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL_OW 1
27222: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27223: LD_VAR 0 2
27227: PPUSH
27228: LD_INT 101
27230: PPUSH
27231: CALL 22091 0 2
// continue ;
27235: GO 27038
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27237: LD_ADDR_EXP 56
27241: PUSH
27242: LD_EXP 56
27246: PPUSH
27247: LD_VAR 0 2
27251: PPUSH
27252: EMPTY
27253: PPUSH
27254: CALL_OW 1
27258: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27259: LD_VAR 0 2
27263: PPUSH
27264: LD_INT 103
27266: PPUSH
27267: CALL 22091 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27271: LD_ADDR_VAR 0 5
27275: PUSH
27276: LD_EXP 50
27280: PUSH
27281: LD_VAR 0 2
27285: ARRAY
27286: PUSH
27287: LD_EXP 79
27291: PUSH
27292: LD_VAR 0 2
27296: ARRAY
27297: UNION
27298: PPUSH
27299: LD_INT 2
27301: PUSH
27302: LD_INT 25
27304: PUSH
27305: LD_INT 2
27307: PUSH
27308: EMPTY
27309: LIST
27310: LIST
27311: PUSH
27312: LD_INT 25
27314: PUSH
27315: LD_INT 16
27317: PUSH
27318: EMPTY
27319: LIST
27320: LIST
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: LIST
27326: PUSH
27327: EMPTY
27328: LIST
27329: PPUSH
27330: CALL_OW 72
27334: ST_TO_ADDR
// if mc_need_heal [ i ] then
27335: LD_EXP 53
27339: PUSH
27340: LD_VAR 0 2
27344: ARRAY
27345: IFFALSE 27389
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27347: LD_ADDR_VAR 0 5
27351: PUSH
27352: LD_VAR 0 5
27356: PUSH
27357: LD_EXP 53
27361: PUSH
27362: LD_VAR 0 2
27366: ARRAY
27367: PUSH
27368: LD_INT 1
27370: ARRAY
27371: PUSH
27372: LD_EXP 53
27376: PUSH
27377: LD_VAR 0 2
27381: ARRAY
27382: PUSH
27383: LD_INT 2
27385: ARRAY
27386: UNION
27387: DIFF
27388: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27389: LD_ADDR_VAR 0 6
27393: PUSH
27394: LD_EXP 69
27398: PUSH
27399: LD_VAR 0 2
27403: ARRAY
27404: PPUSH
27405: LD_INT 2
27407: PUSH
27408: LD_INT 34
27410: PUSH
27411: LD_INT 13
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: PUSH
27418: LD_INT 34
27420: PUSH
27421: LD_INT 52
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 34
27430: PUSH
27431: LD_INT 88
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: LIST
27442: LIST
27443: PPUSH
27444: CALL_OW 72
27448: ST_TO_ADDR
// if cranes then
27449: LD_VAR 0 6
27453: IFFALSE 27589
// begin for j in cranes do
27455: LD_ADDR_VAR 0 3
27459: PUSH
27460: LD_VAR 0 6
27464: PUSH
27465: FOR_IN
27466: IFFALSE 27587
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27468: LD_VAR 0 3
27472: PPUSH
27473: CALL_OW 256
27477: PUSH
27478: LD_INT 1000
27480: EQUAL
27481: PUSH
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 314
27491: NOT
27492: AND
27493: IFFALSE 27527
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27495: LD_VAR 0 3
27499: PPUSH
27500: LD_EXP 51
27504: PUSH
27505: LD_VAR 0 2
27509: ARRAY
27510: PPUSH
27511: LD_VAR 0 3
27515: PPUSH
27516: CALL_OW 74
27520: PPUSH
27521: CALL_OW 130
27525: GO 27585
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27527: LD_VAR 0 3
27531: PPUSH
27532: CALL_OW 256
27536: PUSH
27537: LD_INT 500
27539: LESS
27540: PUSH
27541: LD_VAR 0 3
27545: PPUSH
27546: LD_EXP 74
27550: PUSH
27551: LD_VAR 0 2
27555: ARRAY
27556: PPUSH
27557: CALL_OW 308
27561: NOT
27562: AND
27563: IFFALSE 27585
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27565: LD_VAR 0 3
27569: PPUSH
27570: LD_EXP 74
27574: PUSH
27575: LD_VAR 0 2
27579: ARRAY
27580: PPUSH
27581: CALL_OW 113
// end ;
27585: GO 27465
27587: POP
27588: POP
// end ; if tmp > 3 then
27589: LD_VAR 0 5
27593: PUSH
27594: LD_INT 3
27596: GREATER
27597: IFFALSE 27617
// tmp := ShrinkArray ( tmp , 4 ) ;
27599: LD_ADDR_VAR 0 5
27603: PUSH
27604: LD_VAR 0 5
27608: PPUSH
27609: LD_INT 4
27611: PPUSH
27612: CALL 86232 0 2
27616: ST_TO_ADDR
// if not tmp then
27617: LD_VAR 0 5
27621: NOT
27622: IFFALSE 27626
// continue ;
27624: GO 27038
// for j in tmp do
27626: LD_ADDR_VAR 0 3
27630: PUSH
27631: LD_VAR 0 5
27635: PUSH
27636: FOR_IN
27637: IFFALSE 27896
// begin if IsInUnit ( j ) then
27639: LD_VAR 0 3
27643: PPUSH
27644: CALL_OW 310
27648: IFFALSE 27659
// ComExitBuilding ( j ) ;
27650: LD_VAR 0 3
27654: PPUSH
27655: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27659: LD_VAR 0 3
27663: PUSH
27664: LD_EXP 52
27668: PUSH
27669: LD_VAR 0 2
27673: ARRAY
27674: IN
27675: NOT
27676: IFFALSE 27734
// begin SetTag ( j , 101 ) ;
27678: LD_VAR 0 3
27682: PPUSH
27683: LD_INT 101
27685: PPUSH
27686: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27690: LD_ADDR_EXP 52
27694: PUSH
27695: LD_EXP 52
27699: PPUSH
27700: LD_VAR 0 2
27704: PUSH
27705: LD_EXP 52
27709: PUSH
27710: LD_VAR 0 2
27714: ARRAY
27715: PUSH
27716: LD_INT 1
27718: PLUS
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PPUSH
27724: LD_VAR 0 3
27728: PPUSH
27729: CALL 53678 0 3
27733: ST_TO_ADDR
// end ; wait ( 1 ) ;
27734: LD_INT 1
27736: PPUSH
27737: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27741: LD_ADDR_VAR 0 7
27745: PUSH
27746: LD_EXP 51
27750: PUSH
27751: LD_VAR 0 2
27755: ARRAY
27756: ST_TO_ADDR
// if mc_scan [ i ] then
27757: LD_EXP 73
27761: PUSH
27762: LD_VAR 0 2
27766: ARRAY
27767: IFFALSE 27829
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27769: LD_ADDR_VAR 0 7
27773: PUSH
27774: LD_EXP 51
27778: PUSH
27779: LD_VAR 0 2
27783: ARRAY
27784: PPUSH
27785: LD_INT 3
27787: PUSH
27788: LD_INT 30
27790: PUSH
27791: LD_INT 32
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: PUSH
27798: LD_INT 30
27800: PUSH
27801: LD_INT 33
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: LD_INT 30
27810: PUSH
27811: LD_INT 31
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: EMPTY
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: PPUSH
27824: CALL_OW 72
27828: ST_TO_ADDR
// if not to_repair_tmp then
27829: LD_VAR 0 7
27833: NOT
27834: IFFALSE 27838
// continue ;
27836: GO 27636
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27838: LD_ADDR_VAR 0 8
27842: PUSH
27843: LD_VAR 0 7
27847: PPUSH
27848: LD_VAR 0 3
27852: PPUSH
27853: CALL_OW 74
27857: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27858: LD_VAR 0 8
27862: PPUSH
27863: LD_INT 16
27865: PPUSH
27866: CALL 56275 0 2
27870: PUSH
27871: LD_INT 4
27873: ARRAY
27874: PUSH
27875: LD_INT 10
27877: LESS
27878: IFFALSE 27894
// ComRepairBuilding ( j , to_repair ) ;
27880: LD_VAR 0 3
27884: PPUSH
27885: LD_VAR 0 8
27889: PPUSH
27890: CALL_OW 130
// end ;
27894: GO 27636
27896: POP
27897: POP
// end ;
27898: GO 27038
27900: POP
27901: POP
// end ;
27902: LD_VAR 0 1
27906: RET
// export function MC_Heal ; var i , j , tmp ; begin
27907: LD_INT 0
27909: PPUSH
27910: PPUSH
27911: PPUSH
27912: PPUSH
// if not mc_bases then
27913: LD_EXP 50
27917: NOT
27918: IFFALSE 27922
// exit ;
27920: GO 28324
// for i = 1 to mc_bases do
27922: LD_ADDR_VAR 0 2
27926: PUSH
27927: DOUBLE
27928: LD_INT 1
27930: DEC
27931: ST_TO_ADDR
27932: LD_EXP 50
27936: PUSH
27937: FOR_TO
27938: IFFALSE 28322
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27940: LD_EXP 53
27944: PUSH
27945: LD_VAR 0 2
27949: ARRAY
27950: PUSH
27951: LD_INT 1
27953: ARRAY
27954: NOT
27955: PUSH
27956: LD_EXP 53
27960: PUSH
27961: LD_VAR 0 2
27965: ARRAY
27966: PUSH
27967: LD_INT 2
27969: ARRAY
27970: NOT
27971: AND
27972: IFFALSE 28010
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27974: LD_ADDR_EXP 54
27978: PUSH
27979: LD_EXP 54
27983: PPUSH
27984: LD_VAR 0 2
27988: PPUSH
27989: EMPTY
27990: PPUSH
27991: CALL_OW 1
27995: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27996: LD_VAR 0 2
28000: PPUSH
28001: LD_INT 102
28003: PPUSH
28004: CALL 22091 0 2
// continue ;
28008: GO 27937
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28010: LD_ADDR_VAR 0 4
28014: PUSH
28015: LD_EXP 50
28019: PUSH
28020: LD_VAR 0 2
28024: ARRAY
28025: PPUSH
28026: LD_INT 25
28028: PUSH
28029: LD_INT 4
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PPUSH
28036: CALL_OW 72
28040: ST_TO_ADDR
// if not tmp then
28041: LD_VAR 0 4
28045: NOT
28046: IFFALSE 28050
// continue ;
28048: GO 27937
// if mc_taming [ i ] then
28050: LD_EXP 81
28054: PUSH
28055: LD_VAR 0 2
28059: ARRAY
28060: IFFALSE 28084
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28062: LD_ADDR_EXP 81
28066: PUSH
28067: LD_EXP 81
28071: PPUSH
28072: LD_VAR 0 2
28076: PPUSH
28077: EMPTY
28078: PPUSH
28079: CALL_OW 1
28083: ST_TO_ADDR
// for j in tmp do
28084: LD_ADDR_VAR 0 3
28088: PUSH
28089: LD_VAR 0 4
28093: PUSH
28094: FOR_IN
28095: IFFALSE 28318
// begin if IsInUnit ( j ) then
28097: LD_VAR 0 3
28101: PPUSH
28102: CALL_OW 310
28106: IFFALSE 28117
// ComExitBuilding ( j ) ;
28108: LD_VAR 0 3
28112: PPUSH
28113: CALL_OW 122
// if not j in mc_healers [ i ] then
28117: LD_VAR 0 3
28121: PUSH
28122: LD_EXP 54
28126: PUSH
28127: LD_VAR 0 2
28131: ARRAY
28132: IN
28133: NOT
28134: IFFALSE 28180
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28136: LD_ADDR_EXP 54
28140: PUSH
28141: LD_EXP 54
28145: PPUSH
28146: LD_VAR 0 2
28150: PUSH
28151: LD_EXP 54
28155: PUSH
28156: LD_VAR 0 2
28160: ARRAY
28161: PUSH
28162: LD_INT 1
28164: PLUS
28165: PUSH
28166: EMPTY
28167: LIST
28168: LIST
28169: PPUSH
28170: LD_VAR 0 3
28174: PPUSH
28175: CALL 53678 0 3
28179: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28180: LD_VAR 0 3
28184: PPUSH
28185: CALL_OW 110
28189: PUSH
28190: LD_INT 102
28192: NONEQUAL
28193: IFFALSE 28207
// SetTag ( j , 102 ) ;
28195: LD_VAR 0 3
28199: PPUSH
28200: LD_INT 102
28202: PPUSH
28203: CALL_OW 109
// Wait ( 3 ) ;
28207: LD_INT 3
28209: PPUSH
28210: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28214: LD_EXP 53
28218: PUSH
28219: LD_VAR 0 2
28223: ARRAY
28224: PUSH
28225: LD_INT 1
28227: ARRAY
28228: IFFALSE 28260
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28230: LD_VAR 0 3
28234: PPUSH
28235: LD_EXP 53
28239: PUSH
28240: LD_VAR 0 2
28244: ARRAY
28245: PUSH
28246: LD_INT 1
28248: ARRAY
28249: PUSH
28250: LD_INT 1
28252: ARRAY
28253: PPUSH
28254: CALL_OW 128
28258: GO 28316
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28260: LD_VAR 0 3
28264: PPUSH
28265: CALL_OW 314
28269: NOT
28270: PUSH
28271: LD_EXP 53
28275: PUSH
28276: LD_VAR 0 2
28280: ARRAY
28281: PUSH
28282: LD_INT 2
28284: ARRAY
28285: AND
28286: IFFALSE 28316
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28288: LD_VAR 0 3
28292: PPUSH
28293: LD_EXP 53
28297: PUSH
28298: LD_VAR 0 2
28302: ARRAY
28303: PUSH
28304: LD_INT 2
28306: ARRAY
28307: PUSH
28308: LD_INT 1
28310: ARRAY
28311: PPUSH
28312: CALL_OW 128
// end ;
28316: GO 28094
28318: POP
28319: POP
// end ;
28320: GO 27937
28322: POP
28323: POP
// end ;
28324: LD_VAR 0 1
28328: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28329: LD_INT 0
28331: PPUSH
28332: PPUSH
28333: PPUSH
28334: PPUSH
28335: PPUSH
// if not mc_bases then
28336: LD_EXP 50
28340: NOT
28341: IFFALSE 28345
// exit ;
28343: GO 29516
// for i = 1 to mc_bases do
28345: LD_ADDR_VAR 0 2
28349: PUSH
28350: DOUBLE
28351: LD_INT 1
28353: DEC
28354: ST_TO_ADDR
28355: LD_EXP 50
28359: PUSH
28360: FOR_TO
28361: IFFALSE 29514
// begin if mc_scan [ i ] then
28363: LD_EXP 73
28367: PUSH
28368: LD_VAR 0 2
28372: ARRAY
28373: IFFALSE 28377
// continue ;
28375: GO 28360
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28377: LD_EXP 55
28381: PUSH
28382: LD_VAR 0 2
28386: ARRAY
28387: NOT
28388: PUSH
28389: LD_EXP 57
28393: PUSH
28394: LD_VAR 0 2
28398: ARRAY
28399: NOT
28400: AND
28401: PUSH
28402: LD_EXP 56
28406: PUSH
28407: LD_VAR 0 2
28411: ARRAY
28412: AND
28413: IFFALSE 28451
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28415: LD_ADDR_EXP 56
28419: PUSH
28420: LD_EXP 56
28424: PPUSH
28425: LD_VAR 0 2
28429: PPUSH
28430: EMPTY
28431: PPUSH
28432: CALL_OW 1
28436: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28437: LD_VAR 0 2
28441: PPUSH
28442: LD_INT 103
28444: PPUSH
28445: CALL 22091 0 2
// continue ;
28449: GO 28360
// end ; if mc_construct_list [ i ] then
28451: LD_EXP 57
28455: PUSH
28456: LD_VAR 0 2
28460: ARRAY
28461: IFFALSE 28681
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28463: LD_ADDR_VAR 0 4
28467: PUSH
28468: LD_EXP 50
28472: PUSH
28473: LD_VAR 0 2
28477: ARRAY
28478: PPUSH
28479: LD_INT 25
28481: PUSH
28482: LD_INT 2
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PPUSH
28489: CALL_OW 72
28493: PUSH
28494: LD_EXP 52
28498: PUSH
28499: LD_VAR 0 2
28503: ARRAY
28504: DIFF
28505: ST_TO_ADDR
// if not tmp then
28506: LD_VAR 0 4
28510: NOT
28511: IFFALSE 28515
// continue ;
28513: GO 28360
// for j in tmp do
28515: LD_ADDR_VAR 0 3
28519: PUSH
28520: LD_VAR 0 4
28524: PUSH
28525: FOR_IN
28526: IFFALSE 28677
// begin if not mc_builders [ i ] then
28528: LD_EXP 56
28532: PUSH
28533: LD_VAR 0 2
28537: ARRAY
28538: NOT
28539: IFFALSE 28597
// begin SetTag ( j , 103 ) ;
28541: LD_VAR 0 3
28545: PPUSH
28546: LD_INT 103
28548: PPUSH
28549: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28553: LD_ADDR_EXP 56
28557: PUSH
28558: LD_EXP 56
28562: PPUSH
28563: LD_VAR 0 2
28567: PUSH
28568: LD_EXP 56
28572: PUSH
28573: LD_VAR 0 2
28577: ARRAY
28578: PUSH
28579: LD_INT 1
28581: PLUS
28582: PUSH
28583: EMPTY
28584: LIST
28585: LIST
28586: PPUSH
28587: LD_VAR 0 3
28591: PPUSH
28592: CALL 53678 0 3
28596: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28597: LD_VAR 0 3
28601: PPUSH
28602: CALL_OW 310
28606: IFFALSE 28617
// ComExitBuilding ( j ) ;
28608: LD_VAR 0 3
28612: PPUSH
28613: CALL_OW 122
// wait ( 3 ) ;
28617: LD_INT 3
28619: PPUSH
28620: CALL_OW 67
// if not mc_construct_list [ i ] then
28624: LD_EXP 57
28628: PUSH
28629: LD_VAR 0 2
28633: ARRAY
28634: NOT
28635: IFFALSE 28639
// break ;
28637: GO 28677
// if not HasTask ( j ) then
28639: LD_VAR 0 3
28643: PPUSH
28644: CALL_OW 314
28648: NOT
28649: IFFALSE 28675
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28651: LD_VAR 0 3
28655: PPUSH
28656: LD_EXP 57
28660: PUSH
28661: LD_VAR 0 2
28665: ARRAY
28666: PUSH
28667: LD_INT 1
28669: ARRAY
28670: PPUSH
28671: CALL 56539 0 2
// end ;
28675: GO 28525
28677: POP
28678: POP
// end else
28679: GO 29512
// if mc_build_list [ i ] then
28681: LD_EXP 55
28685: PUSH
28686: LD_VAR 0 2
28690: ARRAY
28691: IFFALSE 29512
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28693: LD_ADDR_VAR 0 5
28697: PUSH
28698: LD_EXP 50
28702: PUSH
28703: LD_VAR 0 2
28707: ARRAY
28708: PPUSH
28709: LD_INT 2
28711: PUSH
28712: LD_INT 30
28714: PUSH
28715: LD_INT 0
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 30
28724: PUSH
28725: LD_INT 1
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: LIST
28736: PPUSH
28737: CALL_OW 72
28741: ST_TO_ADDR
// if depot then
28742: LD_VAR 0 5
28746: IFFALSE 28764
// depot := depot [ 1 ] else
28748: LD_ADDR_VAR 0 5
28752: PUSH
28753: LD_VAR 0 5
28757: PUSH
28758: LD_INT 1
28760: ARRAY
28761: ST_TO_ADDR
28762: GO 28772
// depot := 0 ;
28764: LD_ADDR_VAR 0 5
28768: PUSH
28769: LD_INT 0
28771: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28772: LD_EXP 55
28776: PUSH
28777: LD_VAR 0 2
28781: ARRAY
28782: PUSH
28783: LD_INT 1
28785: ARRAY
28786: PUSH
28787: LD_INT 1
28789: ARRAY
28790: PPUSH
28791: CALL 56363 0 1
28795: PUSH
28796: LD_EXP 50
28800: PUSH
28801: LD_VAR 0 2
28805: ARRAY
28806: PPUSH
28807: LD_INT 2
28809: PUSH
28810: LD_INT 30
28812: PUSH
28813: LD_INT 2
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 30
28822: PUSH
28823: LD_INT 3
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: LIST
28834: PPUSH
28835: CALL_OW 72
28839: NOT
28840: AND
28841: IFFALSE 28946
// begin for j = 1 to mc_build_list [ i ] do
28843: LD_ADDR_VAR 0 3
28847: PUSH
28848: DOUBLE
28849: LD_INT 1
28851: DEC
28852: ST_TO_ADDR
28853: LD_EXP 55
28857: PUSH
28858: LD_VAR 0 2
28862: ARRAY
28863: PUSH
28864: FOR_TO
28865: IFFALSE 28944
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28867: LD_EXP 55
28871: PUSH
28872: LD_VAR 0 2
28876: ARRAY
28877: PUSH
28878: LD_VAR 0 3
28882: ARRAY
28883: PUSH
28884: LD_INT 1
28886: ARRAY
28887: PUSH
28888: LD_INT 2
28890: EQUAL
28891: IFFALSE 28942
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28893: LD_ADDR_EXP 55
28897: PUSH
28898: LD_EXP 55
28902: PPUSH
28903: LD_VAR 0 2
28907: PPUSH
28908: LD_EXP 55
28912: PUSH
28913: LD_VAR 0 2
28917: ARRAY
28918: PPUSH
28919: LD_VAR 0 3
28923: PPUSH
28924: LD_INT 1
28926: PPUSH
28927: LD_INT 0
28929: PPUSH
28930: CALL 53096 0 4
28934: PPUSH
28935: CALL_OW 1
28939: ST_TO_ADDR
// break ;
28940: GO 28944
// end ;
28942: GO 28864
28944: POP
28945: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28946: LD_EXP 55
28950: PUSH
28951: LD_VAR 0 2
28955: ARRAY
28956: PUSH
28957: LD_INT 1
28959: ARRAY
28960: PUSH
28961: LD_INT 1
28963: ARRAY
28964: PUSH
28965: LD_INT 0
28967: EQUAL
28968: PUSH
28969: LD_VAR 0 5
28973: PUSH
28974: LD_VAR 0 5
28978: PPUSH
28979: LD_EXP 55
28983: PUSH
28984: LD_VAR 0 2
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_EXP 55
29002: PUSH
29003: LD_VAR 0 2
29007: ARRAY
29008: PUSH
29009: LD_INT 1
29011: ARRAY
29012: PUSH
29013: LD_INT 2
29015: ARRAY
29016: PPUSH
29017: LD_EXP 55
29021: PUSH
29022: LD_VAR 0 2
29026: ARRAY
29027: PUSH
29028: LD_INT 1
29030: ARRAY
29031: PUSH
29032: LD_INT 3
29034: ARRAY
29035: PPUSH
29036: LD_EXP 55
29040: PUSH
29041: LD_VAR 0 2
29045: ARRAY
29046: PUSH
29047: LD_INT 1
29049: ARRAY
29050: PUSH
29051: LD_INT 4
29053: ARRAY
29054: PPUSH
29055: CALL 61775 0 5
29059: AND
29060: OR
29061: IFFALSE 29342
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29063: LD_ADDR_VAR 0 4
29067: PUSH
29068: LD_EXP 50
29072: PUSH
29073: LD_VAR 0 2
29077: ARRAY
29078: PPUSH
29079: LD_INT 25
29081: PUSH
29082: LD_INT 2
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PPUSH
29089: CALL_OW 72
29093: PUSH
29094: LD_EXP 52
29098: PUSH
29099: LD_VAR 0 2
29103: ARRAY
29104: DIFF
29105: ST_TO_ADDR
// if not tmp then
29106: LD_VAR 0 4
29110: NOT
29111: IFFALSE 29115
// continue ;
29113: GO 28360
// for j in tmp do
29115: LD_ADDR_VAR 0 3
29119: PUSH
29120: LD_VAR 0 4
29124: PUSH
29125: FOR_IN
29126: IFFALSE 29338
// begin if not mc_builders [ i ] then
29128: LD_EXP 56
29132: PUSH
29133: LD_VAR 0 2
29137: ARRAY
29138: NOT
29139: IFFALSE 29197
// begin SetTag ( j , 103 ) ;
29141: LD_VAR 0 3
29145: PPUSH
29146: LD_INT 103
29148: PPUSH
29149: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29153: LD_ADDR_EXP 56
29157: PUSH
29158: LD_EXP 56
29162: PPUSH
29163: LD_VAR 0 2
29167: PUSH
29168: LD_EXP 56
29172: PUSH
29173: LD_VAR 0 2
29177: ARRAY
29178: PUSH
29179: LD_INT 1
29181: PLUS
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PPUSH
29187: LD_VAR 0 3
29191: PPUSH
29192: CALL 53678 0 3
29196: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29197: LD_VAR 0 3
29201: PPUSH
29202: CALL_OW 310
29206: IFFALSE 29217
// ComExitBuilding ( j ) ;
29208: LD_VAR 0 3
29212: PPUSH
29213: CALL_OW 122
// wait ( 3 ) ;
29217: LD_INT 3
29219: PPUSH
29220: CALL_OW 67
// if not mc_build_list [ i ] then
29224: LD_EXP 55
29228: PUSH
29229: LD_VAR 0 2
29233: ARRAY
29234: NOT
29235: IFFALSE 29239
// break ;
29237: GO 29338
// if not HasTask ( j ) then
29239: LD_VAR 0 3
29243: PPUSH
29244: CALL_OW 314
29248: NOT
29249: IFFALSE 29336
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29251: LD_VAR 0 3
29255: PPUSH
29256: LD_EXP 55
29260: PUSH
29261: LD_VAR 0 2
29265: ARRAY
29266: PUSH
29267: LD_INT 1
29269: ARRAY
29270: PUSH
29271: LD_INT 1
29273: ARRAY
29274: PPUSH
29275: LD_EXP 55
29279: PUSH
29280: LD_VAR 0 2
29284: ARRAY
29285: PUSH
29286: LD_INT 1
29288: ARRAY
29289: PUSH
29290: LD_INT 2
29292: ARRAY
29293: PPUSH
29294: LD_EXP 55
29298: PUSH
29299: LD_VAR 0 2
29303: ARRAY
29304: PUSH
29305: LD_INT 1
29307: ARRAY
29308: PUSH
29309: LD_INT 3
29311: ARRAY
29312: PPUSH
29313: LD_EXP 55
29317: PUSH
29318: LD_VAR 0 2
29322: ARRAY
29323: PUSH
29324: LD_INT 1
29326: ARRAY
29327: PUSH
29328: LD_INT 4
29330: ARRAY
29331: PPUSH
29332: CALL_OW 145
// end ;
29336: GO 29125
29338: POP
29339: POP
// end else
29340: GO 29512
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29342: LD_EXP 50
29346: PUSH
29347: LD_VAR 0 2
29351: ARRAY
29352: PPUSH
29353: LD_EXP 55
29357: PUSH
29358: LD_VAR 0 2
29362: ARRAY
29363: PUSH
29364: LD_INT 1
29366: ARRAY
29367: PUSH
29368: LD_INT 1
29370: ARRAY
29371: PPUSH
29372: LD_EXP 55
29376: PUSH
29377: LD_VAR 0 2
29381: ARRAY
29382: PUSH
29383: LD_INT 1
29385: ARRAY
29386: PUSH
29387: LD_INT 2
29389: ARRAY
29390: PPUSH
29391: LD_EXP 55
29395: PUSH
29396: LD_VAR 0 2
29400: ARRAY
29401: PUSH
29402: LD_INT 1
29404: ARRAY
29405: PUSH
29406: LD_INT 3
29408: ARRAY
29409: PPUSH
29410: LD_EXP 55
29414: PUSH
29415: LD_VAR 0 2
29419: ARRAY
29420: PUSH
29421: LD_INT 1
29423: ARRAY
29424: PUSH
29425: LD_INT 4
29427: ARRAY
29428: PPUSH
29429: LD_EXP 50
29433: PUSH
29434: LD_VAR 0 2
29438: ARRAY
29439: PPUSH
29440: LD_INT 21
29442: PUSH
29443: LD_INT 3
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PPUSH
29450: CALL_OW 72
29454: PPUSH
29455: EMPTY
29456: PPUSH
29457: CALL 60529 0 7
29461: NOT
29462: IFFALSE 29512
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29464: LD_ADDR_EXP 55
29468: PUSH
29469: LD_EXP 55
29473: PPUSH
29474: LD_VAR 0 2
29478: PPUSH
29479: LD_EXP 55
29483: PUSH
29484: LD_VAR 0 2
29488: ARRAY
29489: PPUSH
29490: LD_INT 1
29492: PPUSH
29493: LD_INT 1
29495: NEG
29496: PPUSH
29497: LD_INT 0
29499: PPUSH
29500: CALL 53096 0 4
29504: PPUSH
29505: CALL_OW 1
29509: ST_TO_ADDR
// continue ;
29510: GO 28360
// end ; end ; end ;
29512: GO 28360
29514: POP
29515: POP
// end ;
29516: LD_VAR 0 1
29520: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29521: LD_INT 0
29523: PPUSH
29524: PPUSH
29525: PPUSH
29526: PPUSH
29527: PPUSH
29528: PPUSH
// if not mc_bases then
29529: LD_EXP 50
29533: NOT
29534: IFFALSE 29538
// exit ;
29536: GO 29965
// for i = 1 to mc_bases do
29538: LD_ADDR_VAR 0 2
29542: PUSH
29543: DOUBLE
29544: LD_INT 1
29546: DEC
29547: ST_TO_ADDR
29548: LD_EXP 50
29552: PUSH
29553: FOR_TO
29554: IFFALSE 29963
// begin tmp := mc_build_upgrade [ i ] ;
29556: LD_ADDR_VAR 0 4
29560: PUSH
29561: LD_EXP 82
29565: PUSH
29566: LD_VAR 0 2
29570: ARRAY
29571: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29572: LD_ADDR_VAR 0 6
29576: PUSH
29577: LD_EXP 83
29581: PUSH
29582: LD_VAR 0 2
29586: ARRAY
29587: PPUSH
29588: LD_INT 2
29590: PUSH
29591: LD_INT 30
29593: PUSH
29594: LD_INT 6
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PUSH
29601: LD_INT 30
29603: PUSH
29604: LD_INT 7
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: PUSH
29611: EMPTY
29612: LIST
29613: LIST
29614: LIST
29615: PPUSH
29616: CALL_OW 72
29620: ST_TO_ADDR
// if not tmp and not lab then
29621: LD_VAR 0 4
29625: NOT
29626: PUSH
29627: LD_VAR 0 6
29631: NOT
29632: AND
29633: IFFALSE 29637
// continue ;
29635: GO 29553
// if tmp then
29637: LD_VAR 0 4
29641: IFFALSE 29761
// for j in tmp do
29643: LD_ADDR_VAR 0 3
29647: PUSH
29648: LD_VAR 0 4
29652: PUSH
29653: FOR_IN
29654: IFFALSE 29759
// begin if UpgradeCost ( j ) then
29656: LD_VAR 0 3
29660: PPUSH
29661: CALL 60189 0 1
29665: IFFALSE 29757
// begin ComUpgrade ( j ) ;
29667: LD_VAR 0 3
29671: PPUSH
29672: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29676: LD_ADDR_EXP 82
29680: PUSH
29681: LD_EXP 82
29685: PPUSH
29686: LD_VAR 0 2
29690: PPUSH
29691: LD_EXP 82
29695: PUSH
29696: LD_VAR 0 2
29700: ARRAY
29701: PUSH
29702: LD_VAR 0 3
29706: DIFF
29707: PPUSH
29708: CALL_OW 1
29712: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29713: LD_ADDR_EXP 57
29717: PUSH
29718: LD_EXP 57
29722: PPUSH
29723: LD_VAR 0 2
29727: PUSH
29728: LD_EXP 57
29732: PUSH
29733: LD_VAR 0 2
29737: ARRAY
29738: PUSH
29739: LD_INT 1
29741: PLUS
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PPUSH
29747: LD_VAR 0 3
29751: PPUSH
29752: CALL 53678 0 3
29756: ST_TO_ADDR
// end ; end ;
29757: GO 29653
29759: POP
29760: POP
// if not lab or not mc_lab_upgrade [ i ] then
29761: LD_VAR 0 6
29765: NOT
29766: PUSH
29767: LD_EXP 84
29771: PUSH
29772: LD_VAR 0 2
29776: ARRAY
29777: NOT
29778: OR
29779: IFFALSE 29783
// continue ;
29781: GO 29553
// for j in lab do
29783: LD_ADDR_VAR 0 3
29787: PUSH
29788: LD_VAR 0 6
29792: PUSH
29793: FOR_IN
29794: IFFALSE 29959
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29796: LD_VAR 0 3
29800: PPUSH
29801: CALL_OW 266
29805: PUSH
29806: LD_INT 6
29808: PUSH
29809: LD_INT 7
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: IN
29816: PUSH
29817: LD_VAR 0 3
29821: PPUSH
29822: CALL_OW 461
29826: PUSH
29827: LD_INT 1
29829: NONEQUAL
29830: AND
29831: IFFALSE 29957
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29833: LD_VAR 0 3
29837: PPUSH
29838: LD_EXP 84
29842: PUSH
29843: LD_VAR 0 2
29847: ARRAY
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: PPUSH
29853: CALL 60394 0 2
29857: IFFALSE 29957
// begin ComCancel ( j ) ;
29859: LD_VAR 0 3
29863: PPUSH
29864: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29868: LD_VAR 0 3
29872: PPUSH
29873: LD_EXP 84
29877: PUSH
29878: LD_VAR 0 2
29882: ARRAY
29883: PUSH
29884: LD_INT 1
29886: ARRAY
29887: PPUSH
29888: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29892: LD_VAR 0 3
29896: PUSH
29897: LD_EXP 57
29901: PUSH
29902: LD_VAR 0 2
29906: ARRAY
29907: IN
29908: NOT
29909: IFFALSE 29955
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29911: LD_ADDR_EXP 57
29915: PUSH
29916: LD_EXP 57
29920: PPUSH
29921: LD_VAR 0 2
29925: PUSH
29926: LD_EXP 57
29930: PUSH
29931: LD_VAR 0 2
29935: ARRAY
29936: PUSH
29937: LD_INT 1
29939: PLUS
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PPUSH
29945: LD_VAR 0 3
29949: PPUSH
29950: CALL 53678 0 3
29954: ST_TO_ADDR
// break ;
29955: GO 29959
// end ; end ; end ;
29957: GO 29793
29959: POP
29960: POP
// end ;
29961: GO 29553
29963: POP
29964: POP
// end ;
29965: LD_VAR 0 1
29969: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29970: LD_INT 0
29972: PPUSH
29973: PPUSH
29974: PPUSH
29975: PPUSH
29976: PPUSH
29977: PPUSH
29978: PPUSH
29979: PPUSH
29980: PPUSH
// if not mc_bases then
29981: LD_EXP 50
29985: NOT
29986: IFFALSE 29990
// exit ;
29988: GO 30395
// for i = 1 to mc_bases do
29990: LD_ADDR_VAR 0 2
29994: PUSH
29995: DOUBLE
29996: LD_INT 1
29998: DEC
29999: ST_TO_ADDR
30000: LD_EXP 50
30004: PUSH
30005: FOR_TO
30006: IFFALSE 30393
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30008: LD_EXP 58
30012: PUSH
30013: LD_VAR 0 2
30017: ARRAY
30018: NOT
30019: PUSH
30020: LD_EXP 50
30024: PUSH
30025: LD_VAR 0 2
30029: ARRAY
30030: PPUSH
30031: LD_INT 30
30033: PUSH
30034: LD_INT 3
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PPUSH
30041: CALL_OW 72
30045: NOT
30046: OR
30047: IFFALSE 30051
// continue ;
30049: GO 30005
// busy := false ;
30051: LD_ADDR_VAR 0 8
30055: PUSH
30056: LD_INT 0
30058: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30059: LD_ADDR_VAR 0 4
30063: PUSH
30064: LD_EXP 50
30068: PUSH
30069: LD_VAR 0 2
30073: ARRAY
30074: PPUSH
30075: LD_INT 30
30077: PUSH
30078: LD_INT 3
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PPUSH
30085: CALL_OW 72
30089: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30090: LD_ADDR_VAR 0 6
30094: PUSH
30095: LD_EXP 58
30099: PUSH
30100: LD_VAR 0 2
30104: ARRAY
30105: PPUSH
30106: LD_INT 2
30108: PUSH
30109: LD_INT 30
30111: PUSH
30112: LD_INT 32
30114: PUSH
30115: EMPTY
30116: LIST
30117: LIST
30118: PUSH
30119: LD_INT 30
30121: PUSH
30122: LD_INT 33
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: LIST
30133: PPUSH
30134: CALL_OW 72
30138: ST_TO_ADDR
// if not t then
30139: LD_VAR 0 6
30143: NOT
30144: IFFALSE 30148
// continue ;
30146: GO 30005
// for j in tmp do
30148: LD_ADDR_VAR 0 3
30152: PUSH
30153: LD_VAR 0 4
30157: PUSH
30158: FOR_IN
30159: IFFALSE 30189
// if not BuildingStatus ( j ) = bs_idle then
30161: LD_VAR 0 3
30165: PPUSH
30166: CALL_OW 461
30170: PUSH
30171: LD_INT 2
30173: EQUAL
30174: NOT
30175: IFFALSE 30187
// begin busy := true ;
30177: LD_ADDR_VAR 0 8
30181: PUSH
30182: LD_INT 1
30184: ST_TO_ADDR
// break ;
30185: GO 30189
// end ;
30187: GO 30158
30189: POP
30190: POP
// if busy then
30191: LD_VAR 0 8
30195: IFFALSE 30199
// continue ;
30197: GO 30005
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30199: LD_ADDR_VAR 0 7
30203: PUSH
30204: LD_VAR 0 6
30208: PPUSH
30209: LD_INT 35
30211: PUSH
30212: LD_INT 0
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PPUSH
30219: CALL_OW 72
30223: ST_TO_ADDR
// if tw then
30224: LD_VAR 0 7
30228: IFFALSE 30305
// begin tw := tw [ 1 ] ;
30230: LD_ADDR_VAR 0 7
30234: PUSH
30235: LD_VAR 0 7
30239: PUSH
30240: LD_INT 1
30242: ARRAY
30243: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30244: LD_ADDR_VAR 0 9
30248: PUSH
30249: LD_VAR 0 7
30253: PPUSH
30254: LD_EXP 75
30258: PUSH
30259: LD_VAR 0 2
30263: ARRAY
30264: PPUSH
30265: CALL 58686 0 2
30269: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30270: LD_EXP 89
30274: PUSH
30275: LD_VAR 0 2
30279: ARRAY
30280: IFFALSE 30303
// if not weapon in mc_allowed_tower_weapons [ i ] then
30282: LD_VAR 0 9
30286: PUSH
30287: LD_EXP 89
30291: PUSH
30292: LD_VAR 0 2
30296: ARRAY
30297: IN
30298: NOT
30299: IFFALSE 30303
// continue ;
30301: GO 30005
// end else
30303: GO 30368
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30305: LD_ADDR_VAR 0 5
30309: PUSH
30310: LD_EXP 58
30314: PUSH
30315: LD_VAR 0 2
30319: ARRAY
30320: PPUSH
30321: LD_VAR 0 4
30325: PPUSH
30326: CALL 85465 0 2
30330: ST_TO_ADDR
// if not tmp2 then
30331: LD_VAR 0 5
30335: NOT
30336: IFFALSE 30340
// continue ;
30338: GO 30005
// tw := tmp2 [ 1 ] ;
30340: LD_ADDR_VAR 0 7
30344: PUSH
30345: LD_VAR 0 5
30349: PUSH
30350: LD_INT 1
30352: ARRAY
30353: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30354: LD_ADDR_VAR 0 9
30358: PUSH
30359: LD_VAR 0 5
30363: PUSH
30364: LD_INT 2
30366: ARRAY
30367: ST_TO_ADDR
// end ; if not weapon then
30368: LD_VAR 0 9
30372: NOT
30373: IFFALSE 30377
// continue ;
30375: GO 30005
// ComPlaceWeapon ( tw , weapon ) ;
30377: LD_VAR 0 7
30381: PPUSH
30382: LD_VAR 0 9
30386: PPUSH
30387: CALL_OW 148
// end ;
30391: GO 30005
30393: POP
30394: POP
// end ;
30395: LD_VAR 0 1
30399: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30400: LD_INT 0
30402: PPUSH
30403: PPUSH
30404: PPUSH
30405: PPUSH
30406: PPUSH
30407: PPUSH
30408: PPUSH
// if not mc_bases then
30409: LD_EXP 50
30413: NOT
30414: IFFALSE 30418
// exit ;
30416: GO 31186
// for i = 1 to mc_bases do
30418: LD_ADDR_VAR 0 2
30422: PUSH
30423: DOUBLE
30424: LD_INT 1
30426: DEC
30427: ST_TO_ADDR
30428: LD_EXP 50
30432: PUSH
30433: FOR_TO
30434: IFFALSE 31184
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30436: LD_EXP 63
30440: PUSH
30441: LD_VAR 0 2
30445: ARRAY
30446: NOT
30447: PUSH
30448: LD_EXP 63
30452: PUSH
30453: LD_VAR 0 2
30457: ARRAY
30458: PUSH
30459: LD_EXP 64
30463: PUSH
30464: LD_VAR 0 2
30468: ARRAY
30469: EQUAL
30470: OR
30471: PUSH
30472: LD_EXP 73
30476: PUSH
30477: LD_VAR 0 2
30481: ARRAY
30482: OR
30483: IFFALSE 30487
// continue ;
30485: GO 30433
// if mc_miners [ i ] then
30487: LD_EXP 64
30491: PUSH
30492: LD_VAR 0 2
30496: ARRAY
30497: IFFALSE 30871
// begin for j = mc_miners [ i ] downto 1 do
30499: LD_ADDR_VAR 0 3
30503: PUSH
30504: DOUBLE
30505: LD_EXP 64
30509: PUSH
30510: LD_VAR 0 2
30514: ARRAY
30515: INC
30516: ST_TO_ADDR
30517: LD_INT 1
30519: PUSH
30520: FOR_DOWNTO
30521: IFFALSE 30869
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30523: LD_EXP 64
30527: PUSH
30528: LD_VAR 0 2
30532: ARRAY
30533: PUSH
30534: LD_VAR 0 3
30538: ARRAY
30539: PPUSH
30540: CALL_OW 301
30544: PUSH
30545: LD_EXP 64
30549: PUSH
30550: LD_VAR 0 2
30554: ARRAY
30555: PUSH
30556: LD_VAR 0 3
30560: ARRAY
30561: PPUSH
30562: CALL_OW 257
30566: PUSH
30567: LD_INT 1
30569: NONEQUAL
30570: OR
30571: IFFALSE 30634
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30573: LD_ADDR_VAR 0 5
30577: PUSH
30578: LD_EXP 64
30582: PUSH
30583: LD_VAR 0 2
30587: ARRAY
30588: PUSH
30589: LD_EXP 64
30593: PUSH
30594: LD_VAR 0 2
30598: ARRAY
30599: PUSH
30600: LD_VAR 0 3
30604: ARRAY
30605: DIFF
30606: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30607: LD_ADDR_EXP 64
30611: PUSH
30612: LD_EXP 64
30616: PPUSH
30617: LD_VAR 0 2
30621: PPUSH
30622: LD_VAR 0 5
30626: PPUSH
30627: CALL_OW 1
30631: ST_TO_ADDR
// continue ;
30632: GO 30520
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30634: LD_EXP 64
30638: PUSH
30639: LD_VAR 0 2
30643: ARRAY
30644: PUSH
30645: LD_VAR 0 3
30649: ARRAY
30650: PPUSH
30651: CALL_OW 257
30655: PUSH
30656: LD_INT 1
30658: EQUAL
30659: PUSH
30660: LD_EXP 64
30664: PUSH
30665: LD_VAR 0 2
30669: ARRAY
30670: PUSH
30671: LD_VAR 0 3
30675: ARRAY
30676: PPUSH
30677: CALL_OW 459
30681: NOT
30682: AND
30683: PUSH
30684: LD_EXP 64
30688: PUSH
30689: LD_VAR 0 2
30693: ARRAY
30694: PUSH
30695: LD_VAR 0 3
30699: ARRAY
30700: PPUSH
30701: CALL_OW 314
30705: NOT
30706: AND
30707: IFFALSE 30867
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30709: LD_EXP 64
30713: PUSH
30714: LD_VAR 0 2
30718: ARRAY
30719: PUSH
30720: LD_VAR 0 3
30724: ARRAY
30725: PPUSH
30726: CALL_OW 310
30730: IFFALSE 30753
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30732: LD_EXP 64
30736: PUSH
30737: LD_VAR 0 2
30741: ARRAY
30742: PUSH
30743: LD_VAR 0 3
30747: ARRAY
30748: PPUSH
30749: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30753: LD_EXP 64
30757: PUSH
30758: LD_VAR 0 2
30762: ARRAY
30763: PUSH
30764: LD_VAR 0 3
30768: ARRAY
30769: PPUSH
30770: CALL_OW 314
30774: NOT
30775: IFFALSE 30867
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30777: LD_ADDR_VAR 0 7
30781: PUSH
30782: LD_INT 1
30784: PPUSH
30785: LD_EXP 63
30789: PUSH
30790: LD_VAR 0 2
30794: ARRAY
30795: PPUSH
30796: CALL_OW 12
30800: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30801: LD_EXP 64
30805: PUSH
30806: LD_VAR 0 2
30810: ARRAY
30811: PUSH
30812: LD_VAR 0 3
30816: ARRAY
30817: PPUSH
30818: LD_EXP 63
30822: PUSH
30823: LD_VAR 0 2
30827: ARRAY
30828: PUSH
30829: LD_VAR 0 7
30833: ARRAY
30834: PUSH
30835: LD_INT 1
30837: ARRAY
30838: PPUSH
30839: LD_EXP 63
30843: PUSH
30844: LD_VAR 0 2
30848: ARRAY
30849: PUSH
30850: LD_VAR 0 7
30854: ARRAY
30855: PUSH
30856: LD_INT 2
30858: ARRAY
30859: PPUSH
30860: LD_INT 0
30862: PPUSH
30863: CALL_OW 193
// end ; end ; end ;
30867: GO 30520
30869: POP
30870: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30871: LD_ADDR_VAR 0 5
30875: PUSH
30876: LD_EXP 50
30880: PUSH
30881: LD_VAR 0 2
30885: ARRAY
30886: PPUSH
30887: LD_INT 2
30889: PUSH
30890: LD_INT 30
30892: PUSH
30893: LD_INT 4
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 30
30902: PUSH
30903: LD_INT 5
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 30
30912: PUSH
30913: LD_INT 32
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: PPUSH
30926: CALL_OW 72
30930: ST_TO_ADDR
// if not tmp then
30931: LD_VAR 0 5
30935: NOT
30936: IFFALSE 30940
// continue ;
30938: GO 30433
// list := [ ] ;
30940: LD_ADDR_VAR 0 6
30944: PUSH
30945: EMPTY
30946: ST_TO_ADDR
// for j in tmp do
30947: LD_ADDR_VAR 0 3
30951: PUSH
30952: LD_VAR 0 5
30956: PUSH
30957: FOR_IN
30958: IFFALSE 31027
// begin for k in UnitsInside ( j ) do
30960: LD_ADDR_VAR 0 4
30964: PUSH
30965: LD_VAR 0 3
30969: PPUSH
30970: CALL_OW 313
30974: PUSH
30975: FOR_IN
30976: IFFALSE 31023
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30978: LD_VAR 0 4
30982: PPUSH
30983: CALL_OW 257
30987: PUSH
30988: LD_INT 1
30990: EQUAL
30991: PUSH
30992: LD_VAR 0 4
30996: PPUSH
30997: CALL_OW 459
31001: NOT
31002: AND
31003: IFFALSE 31021
// list := list ^ k ;
31005: LD_ADDR_VAR 0 6
31009: PUSH
31010: LD_VAR 0 6
31014: PUSH
31015: LD_VAR 0 4
31019: ADD
31020: ST_TO_ADDR
31021: GO 30975
31023: POP
31024: POP
// end ;
31025: GO 30957
31027: POP
31028: POP
// list := list diff mc_miners [ i ] ;
31029: LD_ADDR_VAR 0 6
31033: PUSH
31034: LD_VAR 0 6
31038: PUSH
31039: LD_EXP 64
31043: PUSH
31044: LD_VAR 0 2
31048: ARRAY
31049: DIFF
31050: ST_TO_ADDR
// if not list then
31051: LD_VAR 0 6
31055: NOT
31056: IFFALSE 31060
// continue ;
31058: GO 30433
// k := mc_mines [ i ] - mc_miners [ i ] ;
31060: LD_ADDR_VAR 0 4
31064: PUSH
31065: LD_EXP 63
31069: PUSH
31070: LD_VAR 0 2
31074: ARRAY
31075: PUSH
31076: LD_EXP 64
31080: PUSH
31081: LD_VAR 0 2
31085: ARRAY
31086: MINUS
31087: ST_TO_ADDR
// if k > list then
31088: LD_VAR 0 4
31092: PUSH
31093: LD_VAR 0 6
31097: GREATER
31098: IFFALSE 31110
// k := list ;
31100: LD_ADDR_VAR 0 4
31104: PUSH
31105: LD_VAR 0 6
31109: ST_TO_ADDR
// for j = 1 to k do
31110: LD_ADDR_VAR 0 3
31114: PUSH
31115: DOUBLE
31116: LD_INT 1
31118: DEC
31119: ST_TO_ADDR
31120: LD_VAR 0 4
31124: PUSH
31125: FOR_TO
31126: IFFALSE 31180
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31128: LD_ADDR_EXP 64
31132: PUSH
31133: LD_EXP 64
31137: PPUSH
31138: LD_VAR 0 2
31142: PUSH
31143: LD_EXP 64
31147: PUSH
31148: LD_VAR 0 2
31152: ARRAY
31153: PUSH
31154: LD_INT 1
31156: PLUS
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PPUSH
31162: LD_VAR 0 6
31166: PUSH
31167: LD_VAR 0 3
31171: ARRAY
31172: PPUSH
31173: CALL 53678 0 3
31177: ST_TO_ADDR
31178: GO 31125
31180: POP
31181: POP
// end ;
31182: GO 30433
31184: POP
31185: POP
// end ;
31186: LD_VAR 0 1
31190: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31191: LD_INT 0
31193: PPUSH
31194: PPUSH
31195: PPUSH
31196: PPUSH
31197: PPUSH
31198: PPUSH
31199: PPUSH
31200: PPUSH
31201: PPUSH
31202: PPUSH
31203: PPUSH
// if not mc_bases then
31204: LD_EXP 50
31208: NOT
31209: IFFALSE 31213
// exit ;
31211: GO 33036
// for i = 1 to mc_bases do
31213: LD_ADDR_VAR 0 2
31217: PUSH
31218: DOUBLE
31219: LD_INT 1
31221: DEC
31222: ST_TO_ADDR
31223: LD_EXP 50
31227: PUSH
31228: FOR_TO
31229: IFFALSE 33034
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31231: LD_EXP 50
31235: PUSH
31236: LD_VAR 0 2
31240: ARRAY
31241: NOT
31242: PUSH
31243: LD_EXP 57
31247: PUSH
31248: LD_VAR 0 2
31252: ARRAY
31253: OR
31254: IFFALSE 31258
// continue ;
31256: GO 31228
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31258: LD_EXP 66
31262: PUSH
31263: LD_VAR 0 2
31267: ARRAY
31268: NOT
31269: PUSH
31270: LD_EXP 67
31274: PUSH
31275: LD_VAR 0 2
31279: ARRAY
31280: AND
31281: IFFALSE 31319
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31283: LD_ADDR_EXP 67
31287: PUSH
31288: LD_EXP 67
31292: PPUSH
31293: LD_VAR 0 2
31297: PPUSH
31298: EMPTY
31299: PPUSH
31300: CALL_OW 1
31304: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31305: LD_VAR 0 2
31309: PPUSH
31310: LD_INT 107
31312: PPUSH
31313: CALL 22091 0 2
// continue ;
31317: GO 31228
// end ; target := [ ] ;
31319: LD_ADDR_VAR 0 7
31323: PUSH
31324: EMPTY
31325: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31326: LD_ADDR_VAR 0 6
31330: PUSH
31331: LD_EXP 50
31335: PUSH
31336: LD_VAR 0 2
31340: ARRAY
31341: PUSH
31342: LD_INT 1
31344: ARRAY
31345: PPUSH
31346: CALL_OW 255
31350: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31351: LD_ADDR_VAR 0 9
31355: PUSH
31356: LD_EXP 50
31360: PUSH
31361: LD_VAR 0 2
31365: ARRAY
31366: PPUSH
31367: LD_INT 2
31369: PUSH
31370: LD_INT 30
31372: PUSH
31373: LD_INT 0
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 30
31382: PUSH
31383: LD_INT 1
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: LIST
31394: PPUSH
31395: CALL_OW 72
31399: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31400: LD_ADDR_VAR 0 3
31404: PUSH
31405: DOUBLE
31406: LD_EXP 66
31410: PUSH
31411: LD_VAR 0 2
31415: ARRAY
31416: INC
31417: ST_TO_ADDR
31418: LD_INT 1
31420: PUSH
31421: FOR_DOWNTO
31422: IFFALSE 31667
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31424: LD_EXP 66
31428: PUSH
31429: LD_VAR 0 2
31433: ARRAY
31434: PUSH
31435: LD_VAR 0 3
31439: ARRAY
31440: PUSH
31441: LD_INT 2
31443: ARRAY
31444: PPUSH
31445: LD_EXP 66
31449: PUSH
31450: LD_VAR 0 2
31454: ARRAY
31455: PUSH
31456: LD_VAR 0 3
31460: ARRAY
31461: PUSH
31462: LD_INT 3
31464: ARRAY
31465: PPUSH
31466: CALL_OW 488
31470: PUSH
31471: LD_EXP 66
31475: PUSH
31476: LD_VAR 0 2
31480: ARRAY
31481: PUSH
31482: LD_VAR 0 3
31486: ARRAY
31487: PUSH
31488: LD_INT 2
31490: ARRAY
31491: PPUSH
31492: LD_EXP 66
31496: PUSH
31497: LD_VAR 0 2
31501: ARRAY
31502: PUSH
31503: LD_VAR 0 3
31507: ARRAY
31508: PUSH
31509: LD_INT 3
31511: ARRAY
31512: PPUSH
31513: CALL_OW 284
31517: PUSH
31518: LD_INT 0
31520: EQUAL
31521: AND
31522: IFFALSE 31577
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31524: LD_ADDR_VAR 0 5
31528: PUSH
31529: LD_EXP 66
31533: PUSH
31534: LD_VAR 0 2
31538: ARRAY
31539: PPUSH
31540: LD_VAR 0 3
31544: PPUSH
31545: CALL_OW 3
31549: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31550: LD_ADDR_EXP 66
31554: PUSH
31555: LD_EXP 66
31559: PPUSH
31560: LD_VAR 0 2
31564: PPUSH
31565: LD_VAR 0 5
31569: PPUSH
31570: CALL_OW 1
31574: ST_TO_ADDR
// continue ;
31575: GO 31421
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31577: LD_VAR 0 6
31581: PPUSH
31582: LD_EXP 66
31586: PUSH
31587: LD_VAR 0 2
31591: ARRAY
31592: PUSH
31593: LD_VAR 0 3
31597: ARRAY
31598: PUSH
31599: LD_INT 2
31601: ARRAY
31602: PPUSH
31603: LD_EXP 66
31607: PUSH
31608: LD_VAR 0 2
31612: ARRAY
31613: PUSH
31614: LD_VAR 0 3
31618: ARRAY
31619: PUSH
31620: LD_INT 3
31622: ARRAY
31623: PPUSH
31624: LD_INT 30
31626: PPUSH
31627: CALL 54574 0 4
31631: PUSH
31632: LD_INT 4
31634: ARRAY
31635: PUSH
31636: LD_INT 0
31638: EQUAL
31639: IFFALSE 31665
// begin target := mc_crates [ i ] [ j ] ;
31641: LD_ADDR_VAR 0 7
31645: PUSH
31646: LD_EXP 66
31650: PUSH
31651: LD_VAR 0 2
31655: ARRAY
31656: PUSH
31657: LD_VAR 0 3
31661: ARRAY
31662: ST_TO_ADDR
// break ;
31663: GO 31667
// end ; end ;
31665: GO 31421
31667: POP
31668: POP
// if not target then
31669: LD_VAR 0 7
31673: NOT
31674: IFFALSE 31678
// continue ;
31676: GO 31228
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31678: LD_ADDR_VAR 0 8
31682: PUSH
31683: LD_EXP 69
31687: PUSH
31688: LD_VAR 0 2
31692: ARRAY
31693: PPUSH
31694: LD_INT 2
31696: PUSH
31697: LD_INT 3
31699: PUSH
31700: LD_INT 58
31702: PUSH
31703: EMPTY
31704: LIST
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 61
31712: PUSH
31713: EMPTY
31714: LIST
31715: PUSH
31716: LD_INT 33
31718: PUSH
31719: LD_INT 5
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 33
31728: PUSH
31729: LD_INT 3
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 2
31745: PUSH
31746: LD_INT 34
31748: PUSH
31749: LD_INT 32
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 34
31758: PUSH
31759: LD_INT 51
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 34
31768: PUSH
31769: LD_INT 12
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PPUSH
31786: CALL_OW 72
31790: ST_TO_ADDR
// if not cargo then
31791: LD_VAR 0 8
31795: NOT
31796: IFFALSE 32502
// begin if mc_crates_collector [ i ] < 5 then
31798: LD_EXP 67
31802: PUSH
31803: LD_VAR 0 2
31807: ARRAY
31808: PUSH
31809: LD_INT 5
31811: LESS
31812: IFFALSE 32178
// begin if mc_ape [ i ] then
31814: LD_EXP 79
31818: PUSH
31819: LD_VAR 0 2
31823: ARRAY
31824: IFFALSE 31871
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31826: LD_ADDR_VAR 0 5
31830: PUSH
31831: LD_EXP 79
31835: PUSH
31836: LD_VAR 0 2
31840: ARRAY
31841: PPUSH
31842: LD_INT 25
31844: PUSH
31845: LD_INT 16
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 24
31854: PUSH
31855: LD_INT 750
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PPUSH
31866: CALL_OW 72
31870: ST_TO_ADDR
// if not tmp then
31871: LD_VAR 0 5
31875: NOT
31876: IFFALSE 31923
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31878: LD_ADDR_VAR 0 5
31882: PUSH
31883: LD_EXP 50
31887: PUSH
31888: LD_VAR 0 2
31892: ARRAY
31893: PPUSH
31894: LD_INT 25
31896: PUSH
31897: LD_INT 2
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 24
31906: PUSH
31907: LD_INT 750
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PPUSH
31918: CALL_OW 72
31922: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31923: LD_EXP 79
31927: PUSH
31928: LD_VAR 0 2
31932: ARRAY
31933: PUSH
31934: LD_EXP 50
31938: PUSH
31939: LD_VAR 0 2
31943: ARRAY
31944: PPUSH
31945: LD_INT 25
31947: PUSH
31948: LD_INT 2
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 24
31957: PUSH
31958: LD_INT 750
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PPUSH
31969: CALL_OW 72
31973: AND
31974: PUSH
31975: LD_VAR 0 5
31979: PUSH
31980: LD_INT 5
31982: LESS
31983: AND
31984: IFFALSE 32066
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31986: LD_ADDR_VAR 0 3
31990: PUSH
31991: LD_EXP 50
31995: PUSH
31996: LD_VAR 0 2
32000: ARRAY
32001: PPUSH
32002: LD_INT 25
32004: PUSH
32005: LD_INT 2
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 24
32014: PUSH
32015: LD_INT 750
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PPUSH
32026: CALL_OW 72
32030: PUSH
32031: FOR_IN
32032: IFFALSE 32064
// begin tmp := tmp union j ;
32034: LD_ADDR_VAR 0 5
32038: PUSH
32039: LD_VAR 0 5
32043: PUSH
32044: LD_VAR 0 3
32048: UNION
32049: ST_TO_ADDR
// if tmp >= 5 then
32050: LD_VAR 0 5
32054: PUSH
32055: LD_INT 5
32057: GREATEREQUAL
32058: IFFALSE 32062
// break ;
32060: GO 32064
// end ;
32062: GO 32031
32064: POP
32065: POP
// end ; if not tmp then
32066: LD_VAR 0 5
32070: NOT
32071: IFFALSE 32075
// continue ;
32073: GO 31228
// for j in tmp do
32075: LD_ADDR_VAR 0 3
32079: PUSH
32080: LD_VAR 0 5
32084: PUSH
32085: FOR_IN
32086: IFFALSE 32176
// if not GetTag ( j ) then
32088: LD_VAR 0 3
32092: PPUSH
32093: CALL_OW 110
32097: NOT
32098: IFFALSE 32174
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32100: LD_ADDR_EXP 67
32104: PUSH
32105: LD_EXP 67
32109: PPUSH
32110: LD_VAR 0 2
32114: PUSH
32115: LD_EXP 67
32119: PUSH
32120: LD_VAR 0 2
32124: ARRAY
32125: PUSH
32126: LD_INT 1
32128: PLUS
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PPUSH
32134: LD_VAR 0 3
32138: PPUSH
32139: CALL 53678 0 3
32143: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32144: LD_VAR 0 3
32148: PPUSH
32149: LD_INT 107
32151: PPUSH
32152: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32156: LD_EXP 67
32160: PUSH
32161: LD_VAR 0 2
32165: ARRAY
32166: PUSH
32167: LD_INT 5
32169: GREATEREQUAL
32170: IFFALSE 32174
// break ;
32172: GO 32176
// end ;
32174: GO 32085
32176: POP
32177: POP
// end ; if mc_crates_collector [ i ] and target then
32178: LD_EXP 67
32182: PUSH
32183: LD_VAR 0 2
32187: ARRAY
32188: PUSH
32189: LD_VAR 0 7
32193: AND
32194: IFFALSE 32500
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32196: LD_EXP 67
32200: PUSH
32201: LD_VAR 0 2
32205: ARRAY
32206: PUSH
32207: LD_VAR 0 7
32211: PUSH
32212: LD_INT 1
32214: ARRAY
32215: LESS
32216: IFFALSE 32236
// tmp := mc_crates_collector [ i ] else
32218: LD_ADDR_VAR 0 5
32222: PUSH
32223: LD_EXP 67
32227: PUSH
32228: LD_VAR 0 2
32232: ARRAY
32233: ST_TO_ADDR
32234: GO 32250
// tmp := target [ 1 ] ;
32236: LD_ADDR_VAR 0 5
32240: PUSH
32241: LD_VAR 0 7
32245: PUSH
32246: LD_INT 1
32248: ARRAY
32249: ST_TO_ADDR
// k := 0 ;
32250: LD_ADDR_VAR 0 4
32254: PUSH
32255: LD_INT 0
32257: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32258: LD_ADDR_VAR 0 3
32262: PUSH
32263: LD_EXP 67
32267: PUSH
32268: LD_VAR 0 2
32272: ARRAY
32273: PUSH
32274: FOR_IN
32275: IFFALSE 32498
// begin k := k + 1 ;
32277: LD_ADDR_VAR 0 4
32281: PUSH
32282: LD_VAR 0 4
32286: PUSH
32287: LD_INT 1
32289: PLUS
32290: ST_TO_ADDR
// if k > tmp then
32291: LD_VAR 0 4
32295: PUSH
32296: LD_VAR 0 5
32300: GREATER
32301: IFFALSE 32305
// break ;
32303: GO 32498
// if not GetClass ( j ) in [ 2 , 16 ] then
32305: LD_VAR 0 3
32309: PPUSH
32310: CALL_OW 257
32314: PUSH
32315: LD_INT 2
32317: PUSH
32318: LD_INT 16
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: IN
32325: NOT
32326: IFFALSE 32379
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32328: LD_ADDR_EXP 67
32332: PUSH
32333: LD_EXP 67
32337: PPUSH
32338: LD_VAR 0 2
32342: PPUSH
32343: LD_EXP 67
32347: PUSH
32348: LD_VAR 0 2
32352: ARRAY
32353: PUSH
32354: LD_VAR 0 3
32358: DIFF
32359: PPUSH
32360: CALL_OW 1
32364: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32365: LD_VAR 0 3
32369: PPUSH
32370: LD_INT 0
32372: PPUSH
32373: CALL_OW 109
// continue ;
32377: GO 32274
// end ; if IsInUnit ( j ) then
32379: LD_VAR 0 3
32383: PPUSH
32384: CALL_OW 310
32388: IFFALSE 32399
// ComExitBuilding ( j ) ;
32390: LD_VAR 0 3
32394: PPUSH
32395: CALL_OW 122
// wait ( 3 ) ;
32399: LD_INT 3
32401: PPUSH
32402: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32406: LD_VAR 0 3
32410: PPUSH
32411: CALL_OW 314
32415: PUSH
32416: LD_VAR 0 6
32420: PPUSH
32421: LD_VAR 0 7
32425: PUSH
32426: LD_INT 2
32428: ARRAY
32429: PPUSH
32430: LD_VAR 0 7
32434: PUSH
32435: LD_INT 3
32437: ARRAY
32438: PPUSH
32439: LD_INT 30
32441: PPUSH
32442: CALL 54574 0 4
32446: PUSH
32447: LD_INT 4
32449: ARRAY
32450: AND
32451: IFFALSE 32469
// ComStandNearbyBuilding ( j , depot ) else
32453: LD_VAR 0 3
32457: PPUSH
32458: LD_VAR 0 9
32462: PPUSH
32463: CALL 50105 0 2
32467: GO 32496
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32469: LD_VAR 0 3
32473: PPUSH
32474: LD_VAR 0 7
32478: PUSH
32479: LD_INT 2
32481: ARRAY
32482: PPUSH
32483: LD_VAR 0 7
32487: PUSH
32488: LD_INT 3
32490: ARRAY
32491: PPUSH
32492: CALL_OW 117
// end ;
32496: GO 32274
32498: POP
32499: POP
// end ; end else
32500: GO 33032
// begin for j in cargo do
32502: LD_ADDR_VAR 0 3
32506: PUSH
32507: LD_VAR 0 8
32511: PUSH
32512: FOR_IN
32513: IFFALSE 33030
// begin if GetTag ( j ) <> 0 then
32515: LD_VAR 0 3
32519: PPUSH
32520: CALL_OW 110
32524: PUSH
32525: LD_INT 0
32527: NONEQUAL
32528: IFFALSE 32532
// continue ;
32530: GO 32512
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32532: LD_VAR 0 3
32536: PPUSH
32537: CALL_OW 256
32541: PUSH
32542: LD_INT 1000
32544: LESS
32545: PUSH
32546: LD_VAR 0 3
32550: PPUSH
32551: LD_EXP 74
32555: PUSH
32556: LD_VAR 0 2
32560: ARRAY
32561: PPUSH
32562: CALL_OW 308
32566: NOT
32567: AND
32568: IFFALSE 32590
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32570: LD_VAR 0 3
32574: PPUSH
32575: LD_EXP 74
32579: PUSH
32580: LD_VAR 0 2
32584: ARRAY
32585: PPUSH
32586: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32590: LD_VAR 0 3
32594: PPUSH
32595: CALL_OW 256
32599: PUSH
32600: LD_INT 1000
32602: LESS
32603: PUSH
32604: LD_VAR 0 3
32608: PPUSH
32609: LD_EXP 74
32613: PUSH
32614: LD_VAR 0 2
32618: ARRAY
32619: PPUSH
32620: CALL_OW 308
32624: AND
32625: IFFALSE 32629
// continue ;
32627: GO 32512
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32629: LD_VAR 0 3
32633: PPUSH
32634: CALL_OW 262
32638: PUSH
32639: LD_INT 2
32641: EQUAL
32642: PUSH
32643: LD_VAR 0 3
32647: PPUSH
32648: CALL_OW 261
32652: PUSH
32653: LD_INT 15
32655: LESS
32656: AND
32657: IFFALSE 32661
// continue ;
32659: GO 32512
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32661: LD_VAR 0 3
32665: PPUSH
32666: CALL_OW 262
32670: PUSH
32671: LD_INT 1
32673: EQUAL
32674: PUSH
32675: LD_VAR 0 3
32679: PPUSH
32680: CALL_OW 261
32684: PUSH
32685: LD_INT 10
32687: LESS
32688: AND
32689: IFFALSE 32969
// begin if not depot then
32691: LD_VAR 0 9
32695: NOT
32696: IFFALSE 32700
// continue ;
32698: GO 32512
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32700: LD_VAR 0 3
32704: PPUSH
32705: LD_VAR 0 9
32709: PPUSH
32710: LD_VAR 0 3
32714: PPUSH
32715: CALL_OW 74
32719: PPUSH
32720: CALL_OW 296
32724: PUSH
32725: LD_INT 6
32727: LESS
32728: IFFALSE 32744
// SetFuel ( j , 100 ) else
32730: LD_VAR 0 3
32734: PPUSH
32735: LD_INT 100
32737: PPUSH
32738: CALL_OW 240
32742: GO 32969
// if GetFuel ( j ) = 0 then
32744: LD_VAR 0 3
32748: PPUSH
32749: CALL_OW 261
32753: PUSH
32754: LD_INT 0
32756: EQUAL
32757: IFFALSE 32969
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32759: LD_ADDR_EXP 69
32763: PUSH
32764: LD_EXP 69
32768: PPUSH
32769: LD_VAR 0 2
32773: PPUSH
32774: LD_EXP 69
32778: PUSH
32779: LD_VAR 0 2
32783: ARRAY
32784: PUSH
32785: LD_VAR 0 3
32789: DIFF
32790: PPUSH
32791: CALL_OW 1
32795: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32796: LD_VAR 0 3
32800: PPUSH
32801: CALL_OW 263
32805: PUSH
32806: LD_INT 1
32808: EQUAL
32809: IFFALSE 32825
// ComExitVehicle ( IsInUnit ( j ) ) ;
32811: LD_VAR 0 3
32815: PPUSH
32816: CALL_OW 310
32820: PPUSH
32821: CALL_OW 121
// if GetControl ( j ) = control_remote then
32825: LD_VAR 0 3
32829: PPUSH
32830: CALL_OW 263
32834: PUSH
32835: LD_INT 2
32837: EQUAL
32838: IFFALSE 32849
// ComUnlink ( j ) ;
32840: LD_VAR 0 3
32844: PPUSH
32845: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32849: LD_ADDR_VAR 0 10
32853: PUSH
32854: LD_VAR 0 2
32858: PPUSH
32859: LD_INT 3
32861: PPUSH
32862: CALL 42608 0 2
32866: ST_TO_ADDR
// if fac then
32867: LD_VAR 0 10
32871: IFFALSE 32967
// begin for k in fac do
32873: LD_ADDR_VAR 0 4
32877: PUSH
32878: LD_VAR 0 10
32882: PUSH
32883: FOR_IN
32884: IFFALSE 32965
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32886: LD_ADDR_VAR 0 11
32890: PUSH
32891: LD_VAR 0 10
32895: PPUSH
32896: LD_VAR 0 3
32900: PPUSH
32901: CALL_OW 265
32905: PPUSH
32906: LD_VAR 0 3
32910: PPUSH
32911: CALL_OW 262
32915: PPUSH
32916: LD_VAR 0 3
32920: PPUSH
32921: CALL_OW 263
32925: PPUSH
32926: LD_VAR 0 3
32930: PPUSH
32931: CALL_OW 264
32935: PPUSH
32936: CALL 51176 0 5
32940: ST_TO_ADDR
// if components then
32941: LD_VAR 0 11
32945: IFFALSE 32963
// begin MC_InsertProduceList ( i , components ) ;
32947: LD_VAR 0 2
32951: PPUSH
32952: LD_VAR 0 11
32956: PPUSH
32957: CALL 42153 0 2
// break ;
32961: GO 32965
// end ; end ;
32963: GO 32883
32965: POP
32966: POP
// end ; continue ;
32967: GO 32512
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32969: LD_VAR 0 3
32973: PPUSH
32974: LD_INT 1
32976: PPUSH
32977: CALL_OW 289
32981: PUSH
32982: LD_INT 100
32984: LESS
32985: PUSH
32986: LD_VAR 0 3
32990: PPUSH
32991: CALL_OW 314
32995: NOT
32996: AND
32997: IFFALSE 33026
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32999: LD_VAR 0 3
33003: PPUSH
33004: LD_VAR 0 7
33008: PUSH
33009: LD_INT 2
33011: ARRAY
33012: PPUSH
33013: LD_VAR 0 7
33017: PUSH
33018: LD_INT 3
33020: ARRAY
33021: PPUSH
33022: CALL_OW 117
// break ;
33026: GO 33030
// end ;
33028: GO 32512
33030: POP
33031: POP
// end ; end ;
33032: GO 31228
33034: POP
33035: POP
// end ;
33036: LD_VAR 0 1
33040: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33041: LD_INT 0
33043: PPUSH
33044: PPUSH
33045: PPUSH
33046: PPUSH
// if not mc_bases then
33047: LD_EXP 50
33051: NOT
33052: IFFALSE 33056
// exit ;
33054: GO 33217
// for i = 1 to mc_bases do
33056: LD_ADDR_VAR 0 2
33060: PUSH
33061: DOUBLE
33062: LD_INT 1
33064: DEC
33065: ST_TO_ADDR
33066: LD_EXP 50
33070: PUSH
33071: FOR_TO
33072: IFFALSE 33215
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33074: LD_ADDR_VAR 0 4
33078: PUSH
33079: LD_EXP 69
33083: PUSH
33084: LD_VAR 0 2
33088: ARRAY
33089: PUSH
33090: LD_EXP 72
33094: PUSH
33095: LD_VAR 0 2
33099: ARRAY
33100: UNION
33101: PPUSH
33102: LD_INT 33
33104: PUSH
33105: LD_INT 2
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PPUSH
33112: CALL_OW 72
33116: ST_TO_ADDR
// if tmp then
33117: LD_VAR 0 4
33121: IFFALSE 33213
// for j in tmp do
33123: LD_ADDR_VAR 0 3
33127: PUSH
33128: LD_VAR 0 4
33132: PUSH
33133: FOR_IN
33134: IFFALSE 33211
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33136: LD_VAR 0 3
33140: PPUSH
33141: CALL_OW 312
33145: NOT
33146: PUSH
33147: LD_VAR 0 3
33151: PPUSH
33152: CALL_OW 256
33156: PUSH
33157: LD_INT 250
33159: GREATEREQUAL
33160: AND
33161: IFFALSE 33174
// Connect ( j ) else
33163: LD_VAR 0 3
33167: PPUSH
33168: CALL 56647 0 1
33172: GO 33209
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33174: LD_VAR 0 3
33178: PPUSH
33179: CALL_OW 256
33183: PUSH
33184: LD_INT 250
33186: LESS
33187: PUSH
33188: LD_VAR 0 3
33192: PPUSH
33193: CALL_OW 312
33197: AND
33198: IFFALSE 33209
// ComUnlink ( j ) ;
33200: LD_VAR 0 3
33204: PPUSH
33205: CALL_OW 136
33209: GO 33133
33211: POP
33212: POP
// end ;
33213: GO 33071
33215: POP
33216: POP
// end ;
33217: LD_VAR 0 1
33221: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33222: LD_INT 0
33224: PPUSH
33225: PPUSH
33226: PPUSH
33227: PPUSH
33228: PPUSH
// if not mc_bases then
33229: LD_EXP 50
33233: NOT
33234: IFFALSE 33238
// exit ;
33236: GO 33683
// for i = 1 to mc_bases do
33238: LD_ADDR_VAR 0 2
33242: PUSH
33243: DOUBLE
33244: LD_INT 1
33246: DEC
33247: ST_TO_ADDR
33248: LD_EXP 50
33252: PUSH
33253: FOR_TO
33254: IFFALSE 33681
// begin if not mc_produce [ i ] then
33256: LD_EXP 71
33260: PUSH
33261: LD_VAR 0 2
33265: ARRAY
33266: NOT
33267: IFFALSE 33271
// continue ;
33269: GO 33253
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33271: LD_ADDR_VAR 0 5
33275: PUSH
33276: LD_EXP 50
33280: PUSH
33281: LD_VAR 0 2
33285: ARRAY
33286: PPUSH
33287: LD_INT 30
33289: PUSH
33290: LD_INT 3
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PPUSH
33297: CALL_OW 72
33301: ST_TO_ADDR
// if not fac then
33302: LD_VAR 0 5
33306: NOT
33307: IFFALSE 33311
// continue ;
33309: GO 33253
// for j in fac do
33311: LD_ADDR_VAR 0 3
33315: PUSH
33316: LD_VAR 0 5
33320: PUSH
33321: FOR_IN
33322: IFFALSE 33677
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33324: LD_VAR 0 3
33328: PPUSH
33329: CALL_OW 461
33333: PUSH
33334: LD_INT 2
33336: NONEQUAL
33337: PUSH
33338: LD_VAR 0 3
33342: PPUSH
33343: LD_INT 15
33345: PPUSH
33346: CALL 56275 0 2
33350: PUSH
33351: LD_INT 4
33353: ARRAY
33354: OR
33355: IFFALSE 33359
// continue ;
33357: GO 33321
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33359: LD_VAR 0 3
33363: PPUSH
33364: LD_EXP 71
33368: PUSH
33369: LD_VAR 0 2
33373: ARRAY
33374: PUSH
33375: LD_INT 1
33377: ARRAY
33378: PUSH
33379: LD_INT 1
33381: ARRAY
33382: PPUSH
33383: LD_EXP 71
33387: PUSH
33388: LD_VAR 0 2
33392: ARRAY
33393: PUSH
33394: LD_INT 1
33396: ARRAY
33397: PUSH
33398: LD_INT 2
33400: ARRAY
33401: PPUSH
33402: LD_EXP 71
33406: PUSH
33407: LD_VAR 0 2
33411: ARRAY
33412: PUSH
33413: LD_INT 1
33415: ARRAY
33416: PUSH
33417: LD_INT 3
33419: ARRAY
33420: PPUSH
33421: LD_EXP 71
33425: PUSH
33426: LD_VAR 0 2
33430: ARRAY
33431: PUSH
33432: LD_INT 1
33434: ARRAY
33435: PUSH
33436: LD_INT 4
33438: ARRAY
33439: PPUSH
33440: CALL_OW 448
33444: PUSH
33445: LD_VAR 0 3
33449: PPUSH
33450: LD_EXP 71
33454: PUSH
33455: LD_VAR 0 2
33459: ARRAY
33460: PUSH
33461: LD_INT 1
33463: ARRAY
33464: PUSH
33465: LD_INT 1
33467: ARRAY
33468: PUSH
33469: LD_EXP 71
33473: PUSH
33474: LD_VAR 0 2
33478: ARRAY
33479: PUSH
33480: LD_INT 1
33482: ARRAY
33483: PUSH
33484: LD_INT 2
33486: ARRAY
33487: PUSH
33488: LD_EXP 71
33492: PUSH
33493: LD_VAR 0 2
33497: ARRAY
33498: PUSH
33499: LD_INT 1
33501: ARRAY
33502: PUSH
33503: LD_INT 3
33505: ARRAY
33506: PUSH
33507: LD_EXP 71
33511: PUSH
33512: LD_VAR 0 2
33516: ARRAY
33517: PUSH
33518: LD_INT 1
33520: ARRAY
33521: PUSH
33522: LD_INT 4
33524: ARRAY
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: LIST
33530: LIST
33531: PPUSH
33532: CALL 60042 0 2
33536: AND
33537: IFFALSE 33675
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33539: LD_VAR 0 3
33543: PPUSH
33544: LD_EXP 71
33548: PUSH
33549: LD_VAR 0 2
33553: ARRAY
33554: PUSH
33555: LD_INT 1
33557: ARRAY
33558: PUSH
33559: LD_INT 1
33561: ARRAY
33562: PPUSH
33563: LD_EXP 71
33567: PUSH
33568: LD_VAR 0 2
33572: ARRAY
33573: PUSH
33574: LD_INT 1
33576: ARRAY
33577: PUSH
33578: LD_INT 2
33580: ARRAY
33581: PPUSH
33582: LD_EXP 71
33586: PUSH
33587: LD_VAR 0 2
33591: ARRAY
33592: PUSH
33593: LD_INT 1
33595: ARRAY
33596: PUSH
33597: LD_INT 3
33599: ARRAY
33600: PPUSH
33601: LD_EXP 71
33605: PUSH
33606: LD_VAR 0 2
33610: ARRAY
33611: PUSH
33612: LD_INT 1
33614: ARRAY
33615: PUSH
33616: LD_INT 4
33618: ARRAY
33619: PPUSH
33620: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33624: LD_ADDR_VAR 0 4
33628: PUSH
33629: LD_EXP 71
33633: PUSH
33634: LD_VAR 0 2
33638: ARRAY
33639: PPUSH
33640: LD_INT 1
33642: PPUSH
33643: CALL_OW 3
33647: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33648: LD_ADDR_EXP 71
33652: PUSH
33653: LD_EXP 71
33657: PPUSH
33658: LD_VAR 0 2
33662: PPUSH
33663: LD_VAR 0 4
33667: PPUSH
33668: CALL_OW 1
33672: ST_TO_ADDR
// break ;
33673: GO 33677
// end ; end ;
33675: GO 33321
33677: POP
33678: POP
// end ;
33679: GO 33253
33681: POP
33682: POP
// end ;
33683: LD_VAR 0 1
33687: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33688: LD_INT 0
33690: PPUSH
33691: PPUSH
33692: PPUSH
// if not mc_bases then
33693: LD_EXP 50
33697: NOT
33698: IFFALSE 33702
// exit ;
33700: GO 33791
// for i = 1 to mc_bases do
33702: LD_ADDR_VAR 0 2
33706: PUSH
33707: DOUBLE
33708: LD_INT 1
33710: DEC
33711: ST_TO_ADDR
33712: LD_EXP 50
33716: PUSH
33717: FOR_TO
33718: IFFALSE 33789
// begin if mc_attack [ i ] then
33720: LD_EXP 70
33724: PUSH
33725: LD_VAR 0 2
33729: ARRAY
33730: IFFALSE 33787
// begin tmp := mc_attack [ i ] [ 1 ] ;
33732: LD_ADDR_VAR 0 3
33736: PUSH
33737: LD_EXP 70
33741: PUSH
33742: LD_VAR 0 2
33746: ARRAY
33747: PUSH
33748: LD_INT 1
33750: ARRAY
33751: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33752: LD_ADDR_EXP 70
33756: PUSH
33757: LD_EXP 70
33761: PPUSH
33762: LD_VAR 0 2
33766: PPUSH
33767: EMPTY
33768: PPUSH
33769: CALL_OW 1
33773: ST_TO_ADDR
// Attack ( tmp ) ;
33774: LD_VAR 0 3
33778: PPUSH
33779: CALL 109664 0 1
// exit ;
33783: POP
33784: POP
33785: GO 33791
// end ; end ;
33787: GO 33717
33789: POP
33790: POP
// end ;
33791: LD_VAR 0 1
33795: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33796: LD_INT 0
33798: PPUSH
33799: PPUSH
33800: PPUSH
33801: PPUSH
33802: PPUSH
33803: PPUSH
33804: PPUSH
// if not mc_bases then
33805: LD_EXP 50
33809: NOT
33810: IFFALSE 33814
// exit ;
33812: GO 34671
// for i = 1 to mc_bases do
33814: LD_ADDR_VAR 0 2
33818: PUSH
33819: DOUBLE
33820: LD_INT 1
33822: DEC
33823: ST_TO_ADDR
33824: LD_EXP 50
33828: PUSH
33829: FOR_TO
33830: IFFALSE 34669
// begin if not mc_bases [ i ] then
33832: LD_EXP 50
33836: PUSH
33837: LD_VAR 0 2
33841: ARRAY
33842: NOT
33843: IFFALSE 33847
// continue ;
33845: GO 33829
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33847: LD_ADDR_VAR 0 7
33851: PUSH
33852: LD_EXP 50
33856: PUSH
33857: LD_VAR 0 2
33861: ARRAY
33862: PUSH
33863: LD_INT 1
33865: ARRAY
33866: PPUSH
33867: CALL 50327 0 1
33871: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33872: LD_ADDR_EXP 73
33876: PUSH
33877: LD_EXP 73
33881: PPUSH
33882: LD_VAR 0 2
33886: PPUSH
33887: LD_EXP 50
33891: PUSH
33892: LD_VAR 0 2
33896: ARRAY
33897: PUSH
33898: LD_INT 1
33900: ARRAY
33901: PPUSH
33902: CALL_OW 255
33906: PPUSH
33907: LD_EXP 75
33911: PUSH
33912: LD_VAR 0 2
33916: ARRAY
33917: PPUSH
33918: CALL 50292 0 2
33922: PPUSH
33923: CALL_OW 1
33927: ST_TO_ADDR
// if not mc_scan [ i ] then
33928: LD_EXP 73
33932: PUSH
33933: LD_VAR 0 2
33937: ARRAY
33938: NOT
33939: IFFALSE 34117
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33941: LD_ADDR_EXP 93
33945: PUSH
33946: LD_EXP 93
33950: PPUSH
33951: LD_VAR 0 2
33955: PPUSH
33956: LD_INT 0
33958: PPUSH
33959: CALL_OW 1
33963: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33964: LD_ADDR_VAR 0 4
33968: PUSH
33969: LD_EXP 50
33973: PUSH
33974: LD_VAR 0 2
33978: ARRAY
33979: PPUSH
33980: LD_INT 2
33982: PUSH
33983: LD_INT 25
33985: PUSH
33986: LD_INT 5
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 25
33995: PUSH
33996: LD_INT 8
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 25
34005: PUSH
34006: LD_INT 9
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: LIST
34017: LIST
34018: PPUSH
34019: CALL_OW 72
34023: ST_TO_ADDR
// if not tmp then
34024: LD_VAR 0 4
34028: NOT
34029: IFFALSE 34033
// continue ;
34031: GO 33829
// for j in tmp do
34033: LD_ADDR_VAR 0 3
34037: PUSH
34038: LD_VAR 0 4
34042: PUSH
34043: FOR_IN
34044: IFFALSE 34115
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34046: LD_VAR 0 3
34050: PPUSH
34051: CALL_OW 310
34055: PPUSH
34056: CALL_OW 266
34060: PUSH
34061: LD_INT 5
34063: EQUAL
34064: PUSH
34065: LD_VAR 0 3
34069: PPUSH
34070: CALL_OW 257
34074: PUSH
34075: LD_INT 1
34077: EQUAL
34078: AND
34079: PUSH
34080: LD_VAR 0 3
34084: PPUSH
34085: CALL_OW 459
34089: NOT
34090: AND
34091: PUSH
34092: LD_VAR 0 7
34096: AND
34097: IFFALSE 34113
// ComChangeProfession ( j , class ) ;
34099: LD_VAR 0 3
34103: PPUSH
34104: LD_VAR 0 7
34108: PPUSH
34109: CALL_OW 123
34113: GO 34043
34115: POP
34116: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34117: LD_EXP 73
34121: PUSH
34122: LD_VAR 0 2
34126: ARRAY
34127: PUSH
34128: LD_EXP 93
34132: PUSH
34133: LD_VAR 0 2
34137: ARRAY
34138: NOT
34139: AND
34140: PUSH
34141: LD_EXP 72
34145: PUSH
34146: LD_VAR 0 2
34150: ARRAY
34151: NOT
34152: AND
34153: PUSH
34154: LD_EXP 50
34158: PUSH
34159: LD_VAR 0 2
34163: ARRAY
34164: PPUSH
34165: LD_INT 50
34167: PUSH
34168: EMPTY
34169: LIST
34170: PUSH
34171: LD_INT 2
34173: PUSH
34174: LD_INT 30
34176: PUSH
34177: LD_INT 32
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 30
34186: PUSH
34187: LD_INT 33
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 30
34196: PUSH
34197: LD_INT 4
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 30
34206: PUSH
34207: LD_INT 5
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: LIST
34218: LIST
34219: LIST
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PPUSH
34225: CALL_OW 72
34229: PUSH
34230: LD_INT 4
34232: LESS
34233: PUSH
34234: LD_EXP 50
34238: PUSH
34239: LD_VAR 0 2
34243: ARRAY
34244: PPUSH
34245: LD_INT 3
34247: PUSH
34248: LD_INT 24
34250: PUSH
34251: LD_INT 1000
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: LD_INT 30
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 30
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: LIST
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PPUSH
34294: CALL_OW 72
34298: OR
34299: AND
34300: IFFALSE 34551
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34302: LD_ADDR_EXP 93
34306: PUSH
34307: LD_EXP 93
34311: PPUSH
34312: LD_VAR 0 2
34316: PPUSH
34317: LD_INT 1
34319: PPUSH
34320: CALL_OW 1
34324: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34325: LD_ADDR_VAR 0 4
34329: PUSH
34330: LD_EXP 50
34334: PUSH
34335: LD_VAR 0 2
34339: ARRAY
34340: PPUSH
34341: LD_INT 2
34343: PUSH
34344: LD_INT 25
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 25
34356: PUSH
34357: LD_INT 5
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 25
34366: PUSH
34367: LD_INT 8
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 25
34376: PUSH
34377: LD_INT 9
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: PPUSH
34391: CALL_OW 72
34395: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34396: LD_ADDR_VAR 0 4
34400: PUSH
34401: LD_VAR 0 4
34405: PUSH
34406: LD_VAR 0 4
34410: PPUSH
34411: LD_INT 18
34413: PPUSH
34414: CALL 83491 0 2
34418: DIFF
34419: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34420: LD_VAR 0 4
34424: NOT
34425: PUSH
34426: LD_EXP 50
34430: PUSH
34431: LD_VAR 0 2
34435: ARRAY
34436: PPUSH
34437: LD_INT 2
34439: PUSH
34440: LD_INT 30
34442: PUSH
34443: LD_INT 4
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 30
34452: PUSH
34453: LD_INT 5
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: LIST
34464: PPUSH
34465: CALL_OW 72
34469: NOT
34470: AND
34471: IFFALSE 34533
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34473: LD_ADDR_VAR 0 4
34477: PUSH
34478: LD_EXP 50
34482: PUSH
34483: LD_VAR 0 2
34487: ARRAY
34488: PPUSH
34489: LD_INT 2
34491: PUSH
34492: LD_INT 25
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 25
34504: PUSH
34505: LD_INT 3
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 25
34514: PUSH
34515: LD_INT 4
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: LIST
34526: LIST
34527: PPUSH
34528: CALL_OW 72
34532: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34533: LD_VAR 0 2
34537: PPUSH
34538: LD_VAR 0 4
34542: PPUSH
34543: CALL 114373 0 2
// exit ;
34547: POP
34548: POP
34549: GO 34671
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34551: LD_EXP 73
34555: PUSH
34556: LD_VAR 0 2
34560: ARRAY
34561: PUSH
34562: LD_EXP 93
34566: PUSH
34567: LD_VAR 0 2
34571: ARRAY
34572: NOT
34573: AND
34574: PUSH
34575: LD_EXP 72
34579: PUSH
34580: LD_VAR 0 2
34584: ARRAY
34585: AND
34586: IFFALSE 34667
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34588: LD_ADDR_EXP 93
34592: PUSH
34593: LD_EXP 93
34597: PPUSH
34598: LD_VAR 0 2
34602: PPUSH
34603: LD_INT 1
34605: PPUSH
34606: CALL_OW 1
34610: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34611: LD_ADDR_VAR 0 4
34615: PUSH
34616: LD_EXP 72
34620: PUSH
34621: LD_VAR 0 2
34625: ARRAY
34626: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34627: LD_ADDR_EXP 72
34631: PUSH
34632: LD_EXP 72
34636: PPUSH
34637: LD_VAR 0 2
34641: PPUSH
34642: EMPTY
34643: PPUSH
34644: CALL_OW 1
34648: ST_TO_ADDR
// Defend ( i , tmp ) ;
34649: LD_VAR 0 2
34653: PPUSH
34654: LD_VAR 0 4
34658: PPUSH
34659: CALL 114969 0 2
// exit ;
34663: POP
34664: POP
34665: GO 34671
// end ; end ;
34667: GO 33829
34669: POP
34670: POP
// end ;
34671: LD_VAR 0 1
34675: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34676: LD_INT 0
34678: PPUSH
34679: PPUSH
34680: PPUSH
34681: PPUSH
34682: PPUSH
34683: PPUSH
34684: PPUSH
34685: PPUSH
34686: PPUSH
34687: PPUSH
34688: PPUSH
// if not mc_bases then
34689: LD_EXP 50
34693: NOT
34694: IFFALSE 34698
// exit ;
34696: GO 35785
// for i = 1 to mc_bases do
34698: LD_ADDR_VAR 0 2
34702: PUSH
34703: DOUBLE
34704: LD_INT 1
34706: DEC
34707: ST_TO_ADDR
34708: LD_EXP 50
34712: PUSH
34713: FOR_TO
34714: IFFALSE 35783
// begin tmp := mc_lab [ i ] ;
34716: LD_ADDR_VAR 0 6
34720: PUSH
34721: LD_EXP 83
34725: PUSH
34726: LD_VAR 0 2
34730: ARRAY
34731: ST_TO_ADDR
// if not tmp then
34732: LD_VAR 0 6
34736: NOT
34737: IFFALSE 34741
// continue ;
34739: GO 34713
// idle_lab := 0 ;
34741: LD_ADDR_VAR 0 11
34745: PUSH
34746: LD_INT 0
34748: ST_TO_ADDR
// for j in tmp do
34749: LD_ADDR_VAR 0 3
34753: PUSH
34754: LD_VAR 0 6
34758: PUSH
34759: FOR_IN
34760: IFFALSE 35779
// begin researching := false ;
34762: LD_ADDR_VAR 0 10
34766: PUSH
34767: LD_INT 0
34769: ST_TO_ADDR
// side := GetSide ( j ) ;
34770: LD_ADDR_VAR 0 4
34774: PUSH
34775: LD_VAR 0 3
34779: PPUSH
34780: CALL_OW 255
34784: ST_TO_ADDR
// if not mc_tech [ side ] then
34785: LD_EXP 77
34789: PUSH
34790: LD_VAR 0 4
34794: ARRAY
34795: NOT
34796: IFFALSE 34800
// continue ;
34798: GO 34759
// if BuildingStatus ( j ) = bs_idle then
34800: LD_VAR 0 3
34804: PPUSH
34805: CALL_OW 461
34809: PUSH
34810: LD_INT 2
34812: EQUAL
34813: IFFALSE 35001
// begin if idle_lab and UnitsInside ( j ) < 6 then
34815: LD_VAR 0 11
34819: PUSH
34820: LD_VAR 0 3
34824: PPUSH
34825: CALL_OW 313
34829: PUSH
34830: LD_INT 6
34832: LESS
34833: AND
34834: IFFALSE 34905
// begin tmp2 := UnitsInside ( idle_lab ) ;
34836: LD_ADDR_VAR 0 9
34840: PUSH
34841: LD_VAR 0 11
34845: PPUSH
34846: CALL_OW 313
34850: ST_TO_ADDR
// if tmp2 then
34851: LD_VAR 0 9
34855: IFFALSE 34897
// for x in tmp2 do
34857: LD_ADDR_VAR 0 7
34861: PUSH
34862: LD_VAR 0 9
34866: PUSH
34867: FOR_IN
34868: IFFALSE 34895
// begin ComExitBuilding ( x ) ;
34870: LD_VAR 0 7
34874: PPUSH
34875: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34879: LD_VAR 0 7
34883: PPUSH
34884: LD_VAR 0 3
34888: PPUSH
34889: CALL_OW 180
// end ;
34893: GO 34867
34895: POP
34896: POP
// idle_lab := 0 ;
34897: LD_ADDR_VAR 0 11
34901: PUSH
34902: LD_INT 0
34904: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34905: LD_ADDR_VAR 0 5
34909: PUSH
34910: LD_EXP 77
34914: PUSH
34915: LD_VAR 0 4
34919: ARRAY
34920: PUSH
34921: FOR_IN
34922: IFFALSE 34982
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34924: LD_VAR 0 3
34928: PPUSH
34929: LD_VAR 0 5
34933: PPUSH
34934: CALL_OW 430
34938: PUSH
34939: LD_VAR 0 4
34943: PPUSH
34944: LD_VAR 0 5
34948: PPUSH
34949: CALL 49397 0 2
34953: AND
34954: IFFALSE 34980
// begin researching := true ;
34956: LD_ADDR_VAR 0 10
34960: PUSH
34961: LD_INT 1
34963: ST_TO_ADDR
// ComResearch ( j , t ) ;
34964: LD_VAR 0 3
34968: PPUSH
34969: LD_VAR 0 5
34973: PPUSH
34974: CALL_OW 124
// break ;
34978: GO 34982
// end ;
34980: GO 34921
34982: POP
34983: POP
// if not researching then
34984: LD_VAR 0 10
34988: NOT
34989: IFFALSE 35001
// idle_lab := j ;
34991: LD_ADDR_VAR 0 11
34995: PUSH
34996: LD_VAR 0 3
35000: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35001: LD_VAR 0 3
35005: PPUSH
35006: CALL_OW 461
35010: PUSH
35011: LD_INT 10
35013: EQUAL
35014: IFFALSE 35602
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35016: LD_EXP 79
35020: PUSH
35021: LD_VAR 0 2
35025: ARRAY
35026: NOT
35027: PUSH
35028: LD_EXP 80
35032: PUSH
35033: LD_VAR 0 2
35037: ARRAY
35038: NOT
35039: AND
35040: PUSH
35041: LD_EXP 77
35045: PUSH
35046: LD_VAR 0 4
35050: ARRAY
35051: PUSH
35052: LD_INT 1
35054: GREATER
35055: AND
35056: IFFALSE 35187
// begin ComCancel ( j ) ;
35058: LD_VAR 0 3
35062: PPUSH
35063: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35067: LD_ADDR_EXP 77
35071: PUSH
35072: LD_EXP 77
35076: PPUSH
35077: LD_VAR 0 4
35081: PPUSH
35082: LD_EXP 77
35086: PUSH
35087: LD_VAR 0 4
35091: ARRAY
35092: PPUSH
35093: LD_EXP 77
35097: PUSH
35098: LD_VAR 0 4
35102: ARRAY
35103: PUSH
35104: LD_INT 1
35106: MINUS
35107: PPUSH
35108: LD_EXP 77
35112: PUSH
35113: LD_VAR 0 4
35117: ARRAY
35118: PPUSH
35119: LD_INT 0
35121: PPUSH
35122: CALL 53096 0 4
35126: PPUSH
35127: CALL_OW 1
35131: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35132: LD_ADDR_EXP 77
35136: PUSH
35137: LD_EXP 77
35141: PPUSH
35142: LD_VAR 0 4
35146: PPUSH
35147: LD_EXP 77
35151: PUSH
35152: LD_VAR 0 4
35156: ARRAY
35157: PPUSH
35158: LD_EXP 77
35162: PUSH
35163: LD_VAR 0 4
35167: ARRAY
35168: PPUSH
35169: LD_INT 1
35171: PPUSH
35172: LD_INT 0
35174: PPUSH
35175: CALL 53096 0 4
35179: PPUSH
35180: CALL_OW 1
35184: ST_TO_ADDR
// continue ;
35185: GO 34759
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35187: LD_EXP 79
35191: PUSH
35192: LD_VAR 0 2
35196: ARRAY
35197: PUSH
35198: LD_EXP 80
35202: PUSH
35203: LD_VAR 0 2
35207: ARRAY
35208: NOT
35209: AND
35210: IFFALSE 35337
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35212: LD_ADDR_EXP 80
35216: PUSH
35217: LD_EXP 80
35221: PPUSH
35222: LD_VAR 0 2
35226: PUSH
35227: LD_EXP 80
35231: PUSH
35232: LD_VAR 0 2
35236: ARRAY
35237: PUSH
35238: LD_INT 1
35240: PLUS
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PPUSH
35246: LD_EXP 79
35250: PUSH
35251: LD_VAR 0 2
35255: ARRAY
35256: PUSH
35257: LD_INT 1
35259: ARRAY
35260: PPUSH
35261: CALL 53678 0 3
35265: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35266: LD_EXP 79
35270: PUSH
35271: LD_VAR 0 2
35275: ARRAY
35276: PUSH
35277: LD_INT 1
35279: ARRAY
35280: PPUSH
35281: LD_INT 112
35283: PPUSH
35284: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35288: LD_ADDR_VAR 0 9
35292: PUSH
35293: LD_EXP 79
35297: PUSH
35298: LD_VAR 0 2
35302: ARRAY
35303: PPUSH
35304: LD_INT 1
35306: PPUSH
35307: CALL_OW 3
35311: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35312: LD_ADDR_EXP 79
35316: PUSH
35317: LD_EXP 79
35321: PPUSH
35322: LD_VAR 0 2
35326: PPUSH
35327: LD_VAR 0 9
35331: PPUSH
35332: CALL_OW 1
35336: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35337: LD_EXP 79
35341: PUSH
35342: LD_VAR 0 2
35346: ARRAY
35347: PUSH
35348: LD_EXP 80
35352: PUSH
35353: LD_VAR 0 2
35357: ARRAY
35358: AND
35359: PUSH
35360: LD_EXP 80
35364: PUSH
35365: LD_VAR 0 2
35369: ARRAY
35370: PUSH
35371: LD_INT 1
35373: ARRAY
35374: PPUSH
35375: CALL_OW 310
35379: NOT
35380: AND
35381: PUSH
35382: LD_VAR 0 3
35386: PPUSH
35387: CALL_OW 313
35391: PUSH
35392: LD_INT 6
35394: EQUAL
35395: AND
35396: IFFALSE 35452
// begin tmp2 := UnitsInside ( j ) ;
35398: LD_ADDR_VAR 0 9
35402: PUSH
35403: LD_VAR 0 3
35407: PPUSH
35408: CALL_OW 313
35412: ST_TO_ADDR
// if tmp2 = 6 then
35413: LD_VAR 0 9
35417: PUSH
35418: LD_INT 6
35420: EQUAL
35421: IFFALSE 35452
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35423: LD_VAR 0 9
35427: PUSH
35428: LD_INT 1
35430: ARRAY
35431: PPUSH
35432: LD_INT 112
35434: PPUSH
35435: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35439: LD_VAR 0 9
35443: PUSH
35444: LD_INT 1
35446: ARRAY
35447: PPUSH
35448: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35452: LD_EXP 80
35456: PUSH
35457: LD_VAR 0 2
35461: ARRAY
35462: PUSH
35463: LD_EXP 80
35467: PUSH
35468: LD_VAR 0 2
35472: ARRAY
35473: PUSH
35474: LD_INT 1
35476: ARRAY
35477: PPUSH
35478: CALL_OW 314
35482: NOT
35483: AND
35484: PUSH
35485: LD_EXP 80
35489: PUSH
35490: LD_VAR 0 2
35494: ARRAY
35495: PUSH
35496: LD_INT 1
35498: ARRAY
35499: PPUSH
35500: CALL_OW 310
35504: NOT
35505: AND
35506: IFFALSE 35532
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35508: LD_EXP 80
35512: PUSH
35513: LD_VAR 0 2
35517: ARRAY
35518: PUSH
35519: LD_INT 1
35521: ARRAY
35522: PPUSH
35523: LD_VAR 0 3
35527: PPUSH
35528: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35532: LD_EXP 80
35536: PUSH
35537: LD_VAR 0 2
35541: ARRAY
35542: PUSH
35543: LD_INT 1
35545: ARRAY
35546: PPUSH
35547: CALL_OW 310
35551: PUSH
35552: LD_EXP 80
35556: PUSH
35557: LD_VAR 0 2
35561: ARRAY
35562: PUSH
35563: LD_INT 1
35565: ARRAY
35566: PPUSH
35567: CALL_OW 310
35571: PPUSH
35572: CALL_OW 461
35576: PUSH
35577: LD_INT 3
35579: NONEQUAL
35580: AND
35581: IFFALSE 35602
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35583: LD_EXP 80
35587: PUSH
35588: LD_VAR 0 2
35592: ARRAY
35593: PUSH
35594: LD_INT 1
35596: ARRAY
35597: PPUSH
35598: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35602: LD_VAR 0 3
35606: PPUSH
35607: CALL_OW 461
35611: PUSH
35612: LD_INT 6
35614: EQUAL
35615: PUSH
35616: LD_VAR 0 6
35620: PUSH
35621: LD_INT 1
35623: GREATER
35624: AND
35625: IFFALSE 35777
// begin sci := [ ] ;
35627: LD_ADDR_VAR 0 8
35631: PUSH
35632: EMPTY
35633: ST_TO_ADDR
// for x in ( tmp diff j ) do
35634: LD_ADDR_VAR 0 7
35638: PUSH
35639: LD_VAR 0 6
35643: PUSH
35644: LD_VAR 0 3
35648: DIFF
35649: PUSH
35650: FOR_IN
35651: IFFALSE 35703
// begin if sci = 6 then
35653: LD_VAR 0 8
35657: PUSH
35658: LD_INT 6
35660: EQUAL
35661: IFFALSE 35665
// break ;
35663: GO 35703
// if BuildingStatus ( x ) = bs_idle then
35665: LD_VAR 0 7
35669: PPUSH
35670: CALL_OW 461
35674: PUSH
35675: LD_INT 2
35677: EQUAL
35678: IFFALSE 35701
// sci := sci ^ UnitsInside ( x ) ;
35680: LD_ADDR_VAR 0 8
35684: PUSH
35685: LD_VAR 0 8
35689: PUSH
35690: LD_VAR 0 7
35694: PPUSH
35695: CALL_OW 313
35699: ADD
35700: ST_TO_ADDR
// end ;
35701: GO 35650
35703: POP
35704: POP
// if not sci then
35705: LD_VAR 0 8
35709: NOT
35710: IFFALSE 35714
// continue ;
35712: GO 34759
// for x in sci do
35714: LD_ADDR_VAR 0 7
35718: PUSH
35719: LD_VAR 0 8
35723: PUSH
35724: FOR_IN
35725: IFFALSE 35775
// if IsInUnit ( x ) and not HasTask ( x ) then
35727: LD_VAR 0 7
35731: PPUSH
35732: CALL_OW 310
35736: PUSH
35737: LD_VAR 0 7
35741: PPUSH
35742: CALL_OW 314
35746: NOT
35747: AND
35748: IFFALSE 35773
// begin ComExitBuilding ( x ) ;
35750: LD_VAR 0 7
35754: PPUSH
35755: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35759: LD_VAR 0 7
35763: PPUSH
35764: LD_VAR 0 3
35768: PPUSH
35769: CALL_OW 180
// end ;
35773: GO 35724
35775: POP
35776: POP
// end ; end ;
35777: GO 34759
35779: POP
35780: POP
// end ;
35781: GO 34713
35783: POP
35784: POP
// end ;
35785: LD_VAR 0 1
35789: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35790: LD_INT 0
35792: PPUSH
35793: PPUSH
// if not mc_bases then
35794: LD_EXP 50
35798: NOT
35799: IFFALSE 35803
// exit ;
35801: GO 35884
// for i = 1 to mc_bases do
35803: LD_ADDR_VAR 0 2
35807: PUSH
35808: DOUBLE
35809: LD_INT 1
35811: DEC
35812: ST_TO_ADDR
35813: LD_EXP 50
35817: PUSH
35818: FOR_TO
35819: IFFALSE 35882
// if mc_mines [ i ] and mc_miners [ i ] then
35821: LD_EXP 63
35825: PUSH
35826: LD_VAR 0 2
35830: ARRAY
35831: PUSH
35832: LD_EXP 64
35836: PUSH
35837: LD_VAR 0 2
35841: ARRAY
35842: AND
35843: IFFALSE 35880
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35845: LD_EXP 64
35849: PUSH
35850: LD_VAR 0 2
35854: ARRAY
35855: PUSH
35856: LD_INT 1
35858: ARRAY
35859: PPUSH
35860: CALL_OW 255
35864: PPUSH
35865: LD_EXP 63
35869: PUSH
35870: LD_VAR 0 2
35874: ARRAY
35875: PPUSH
35876: CALL 50480 0 2
35880: GO 35818
35882: POP
35883: POP
// end ;
35884: LD_VAR 0 1
35888: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35889: LD_INT 0
35891: PPUSH
35892: PPUSH
35893: PPUSH
35894: PPUSH
35895: PPUSH
35896: PPUSH
35897: PPUSH
35898: PPUSH
// if not mc_bases or not mc_parking then
35899: LD_EXP 50
35903: NOT
35904: PUSH
35905: LD_EXP 74
35909: NOT
35910: OR
35911: IFFALSE 35915
// exit ;
35913: GO 36625
// for i = 1 to mc_bases do
35915: LD_ADDR_VAR 0 2
35919: PUSH
35920: DOUBLE
35921: LD_INT 1
35923: DEC
35924: ST_TO_ADDR
35925: LD_EXP 50
35929: PUSH
35930: FOR_TO
35931: IFFALSE 36623
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35933: LD_EXP 50
35937: PUSH
35938: LD_VAR 0 2
35942: ARRAY
35943: NOT
35944: PUSH
35945: LD_EXP 74
35949: PUSH
35950: LD_VAR 0 2
35954: ARRAY
35955: NOT
35956: OR
35957: IFFALSE 35961
// continue ;
35959: GO 35930
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35961: LD_ADDR_VAR 0 5
35965: PUSH
35966: LD_EXP 50
35970: PUSH
35971: LD_VAR 0 2
35975: ARRAY
35976: PUSH
35977: LD_INT 1
35979: ARRAY
35980: PPUSH
35981: CALL_OW 255
35985: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35986: LD_ADDR_VAR 0 6
35990: PUSH
35991: LD_EXP 50
35995: PUSH
35996: LD_VAR 0 2
36000: ARRAY
36001: PPUSH
36002: LD_INT 30
36004: PUSH
36005: LD_INT 3
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PPUSH
36012: CALL_OW 72
36016: ST_TO_ADDR
// if not fac then
36017: LD_VAR 0 6
36021: NOT
36022: IFFALSE 36073
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36024: LD_ADDR_VAR 0 6
36028: PUSH
36029: LD_EXP 50
36033: PUSH
36034: LD_VAR 0 2
36038: ARRAY
36039: PPUSH
36040: LD_INT 2
36042: PUSH
36043: LD_INT 30
36045: PUSH
36046: LD_INT 0
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 30
36055: PUSH
36056: LD_INT 1
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: LIST
36067: PPUSH
36068: CALL_OW 72
36072: ST_TO_ADDR
// if not fac then
36073: LD_VAR 0 6
36077: NOT
36078: IFFALSE 36082
// continue ;
36080: GO 35930
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36082: LD_ADDR_VAR 0 7
36086: PUSH
36087: LD_EXP 74
36091: PUSH
36092: LD_VAR 0 2
36096: ARRAY
36097: PPUSH
36098: LD_INT 22
36100: PUSH
36101: LD_VAR 0 5
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 21
36112: PUSH
36113: LD_INT 2
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 3
36122: PUSH
36123: LD_INT 24
36125: PUSH
36126: LD_INT 1000
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: EMPTY
36134: LIST
36135: LIST
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: LIST
36141: PPUSH
36142: CALL_OW 70
36146: ST_TO_ADDR
// for j in fac do
36147: LD_ADDR_VAR 0 3
36151: PUSH
36152: LD_VAR 0 6
36156: PUSH
36157: FOR_IN
36158: IFFALSE 36239
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36160: LD_ADDR_VAR 0 7
36164: PUSH
36165: LD_VAR 0 7
36169: PUSH
36170: LD_INT 22
36172: PUSH
36173: LD_VAR 0 5
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 91
36184: PUSH
36185: LD_VAR 0 3
36189: PUSH
36190: LD_INT 15
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: LIST
36197: PUSH
36198: LD_INT 21
36200: PUSH
36201: LD_INT 2
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 3
36210: PUSH
36211: LD_INT 24
36213: PUSH
36214: LD_INT 1000
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: PPUSH
36231: CALL_OW 69
36235: UNION
36236: ST_TO_ADDR
36237: GO 36157
36239: POP
36240: POP
// if not vehs then
36241: LD_VAR 0 7
36245: NOT
36246: IFFALSE 36272
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36248: LD_ADDR_EXP 62
36252: PUSH
36253: LD_EXP 62
36257: PPUSH
36258: LD_VAR 0 2
36262: PPUSH
36263: EMPTY
36264: PPUSH
36265: CALL_OW 1
36269: ST_TO_ADDR
// continue ;
36270: GO 35930
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36272: LD_ADDR_VAR 0 8
36276: PUSH
36277: LD_EXP 50
36281: PUSH
36282: LD_VAR 0 2
36286: ARRAY
36287: PPUSH
36288: LD_INT 30
36290: PUSH
36291: LD_INT 3
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PPUSH
36298: CALL_OW 72
36302: ST_TO_ADDR
// if tmp then
36303: LD_VAR 0 8
36307: IFFALSE 36410
// begin for j in tmp do
36309: LD_ADDR_VAR 0 3
36313: PUSH
36314: LD_VAR 0 8
36318: PUSH
36319: FOR_IN
36320: IFFALSE 36408
// for k in UnitsInside ( j ) do
36322: LD_ADDR_VAR 0 4
36326: PUSH
36327: LD_VAR 0 3
36331: PPUSH
36332: CALL_OW 313
36336: PUSH
36337: FOR_IN
36338: IFFALSE 36404
// if k then
36340: LD_VAR 0 4
36344: IFFALSE 36402
// if not k in mc_repair_vehicle [ i ] then
36346: LD_VAR 0 4
36350: PUSH
36351: LD_EXP 62
36355: PUSH
36356: LD_VAR 0 2
36360: ARRAY
36361: IN
36362: NOT
36363: IFFALSE 36402
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36365: LD_ADDR_EXP 62
36369: PUSH
36370: LD_EXP 62
36374: PPUSH
36375: LD_VAR 0 2
36379: PPUSH
36380: LD_EXP 62
36384: PUSH
36385: LD_VAR 0 2
36389: ARRAY
36390: PUSH
36391: LD_VAR 0 4
36395: UNION
36396: PPUSH
36397: CALL_OW 1
36401: ST_TO_ADDR
36402: GO 36337
36404: POP
36405: POP
36406: GO 36319
36408: POP
36409: POP
// end ; if not mc_repair_vehicle [ i ] then
36410: LD_EXP 62
36414: PUSH
36415: LD_VAR 0 2
36419: ARRAY
36420: NOT
36421: IFFALSE 36425
// continue ;
36423: GO 35930
// for j in mc_repair_vehicle [ i ] do
36425: LD_ADDR_VAR 0 3
36429: PUSH
36430: LD_EXP 62
36434: PUSH
36435: LD_VAR 0 2
36439: ARRAY
36440: PUSH
36441: FOR_IN
36442: IFFALSE 36619
// begin if GetClass ( j ) <> 3 then
36444: LD_VAR 0 3
36448: PPUSH
36449: CALL_OW 257
36453: PUSH
36454: LD_INT 3
36456: NONEQUAL
36457: IFFALSE 36498
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36459: LD_ADDR_EXP 62
36463: PUSH
36464: LD_EXP 62
36468: PPUSH
36469: LD_VAR 0 2
36473: PPUSH
36474: LD_EXP 62
36478: PUSH
36479: LD_VAR 0 2
36483: ARRAY
36484: PUSH
36485: LD_VAR 0 3
36489: DIFF
36490: PPUSH
36491: CALL_OW 1
36495: ST_TO_ADDR
// continue ;
36496: GO 36441
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36498: LD_VAR 0 3
36502: PPUSH
36503: CALL_OW 311
36507: NOT
36508: PUSH
36509: LD_VAR 0 3
36513: PUSH
36514: LD_EXP 53
36518: PUSH
36519: LD_VAR 0 2
36523: ARRAY
36524: PUSH
36525: LD_INT 1
36527: ARRAY
36528: IN
36529: NOT
36530: AND
36531: PUSH
36532: LD_VAR 0 3
36536: PUSH
36537: LD_EXP 53
36541: PUSH
36542: LD_VAR 0 2
36546: ARRAY
36547: PUSH
36548: LD_INT 2
36550: ARRAY
36551: IN
36552: NOT
36553: AND
36554: IFFALSE 36617
// begin if IsInUnit ( j ) then
36556: LD_VAR 0 3
36560: PPUSH
36561: CALL_OW 310
36565: IFFALSE 36578
// ComExitBuilding ( j ) else
36567: LD_VAR 0 3
36571: PPUSH
36572: CALL_OW 122
36576: GO 36617
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36578: LD_VAR 0 3
36582: PPUSH
36583: LD_VAR 0 7
36587: PUSH
36588: LD_INT 1
36590: ARRAY
36591: PPUSH
36592: CALL 87982 0 2
36596: NOT
36597: IFFALSE 36617
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36599: LD_VAR 0 3
36603: PPUSH
36604: LD_VAR 0 7
36608: PUSH
36609: LD_INT 1
36611: ARRAY
36612: PPUSH
36613: CALL_OW 129
// end ; end ;
36617: GO 36441
36619: POP
36620: POP
// end ;
36621: GO 35930
36623: POP
36624: POP
// end ;
36625: LD_VAR 0 1
36629: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36630: LD_INT 0
36632: PPUSH
36633: PPUSH
36634: PPUSH
36635: PPUSH
36636: PPUSH
36637: PPUSH
36638: PPUSH
36639: PPUSH
36640: PPUSH
36641: PPUSH
36642: PPUSH
// if not mc_bases then
36643: LD_EXP 50
36647: NOT
36648: IFFALSE 36652
// exit ;
36650: GO 37454
// for i = 1 to mc_bases do
36652: LD_ADDR_VAR 0 2
36656: PUSH
36657: DOUBLE
36658: LD_INT 1
36660: DEC
36661: ST_TO_ADDR
36662: LD_EXP 50
36666: PUSH
36667: FOR_TO
36668: IFFALSE 37452
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36670: LD_EXP 78
36674: PUSH
36675: LD_VAR 0 2
36679: ARRAY
36680: NOT
36681: PUSH
36682: LD_EXP 53
36686: PUSH
36687: LD_VAR 0 2
36691: ARRAY
36692: PUSH
36693: LD_INT 1
36695: ARRAY
36696: OR
36697: PUSH
36698: LD_EXP 53
36702: PUSH
36703: LD_VAR 0 2
36707: ARRAY
36708: PUSH
36709: LD_INT 2
36711: ARRAY
36712: OR
36713: PUSH
36714: LD_EXP 76
36718: PUSH
36719: LD_VAR 0 2
36723: ARRAY
36724: PPUSH
36725: LD_INT 1
36727: PPUSH
36728: CALL_OW 325
36732: NOT
36733: OR
36734: PUSH
36735: LD_EXP 73
36739: PUSH
36740: LD_VAR 0 2
36744: ARRAY
36745: OR
36746: IFFALSE 36750
// continue ;
36748: GO 36667
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36750: LD_ADDR_VAR 0 8
36754: PUSH
36755: LD_EXP 50
36759: PUSH
36760: LD_VAR 0 2
36764: ARRAY
36765: PPUSH
36766: LD_INT 25
36768: PUSH
36769: LD_INT 4
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 50
36778: PUSH
36779: EMPTY
36780: LIST
36781: PUSH
36782: LD_INT 3
36784: PUSH
36785: LD_INT 60
36787: PUSH
36788: EMPTY
36789: LIST
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: LIST
36799: PPUSH
36800: CALL_OW 72
36804: PUSH
36805: LD_EXP 54
36809: PUSH
36810: LD_VAR 0 2
36814: ARRAY
36815: DIFF
36816: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36817: LD_ADDR_VAR 0 9
36821: PUSH
36822: LD_EXP 50
36826: PUSH
36827: LD_VAR 0 2
36831: ARRAY
36832: PPUSH
36833: LD_INT 2
36835: PUSH
36836: LD_INT 30
36838: PUSH
36839: LD_INT 0
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 30
36848: PUSH
36849: LD_INT 1
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: LIST
36860: PPUSH
36861: CALL_OW 72
36865: ST_TO_ADDR
// if not tmp or not dep then
36866: LD_VAR 0 8
36870: NOT
36871: PUSH
36872: LD_VAR 0 9
36876: NOT
36877: OR
36878: IFFALSE 36882
// continue ;
36880: GO 36667
// side := GetSide ( tmp [ 1 ] ) ;
36882: LD_ADDR_VAR 0 11
36886: PUSH
36887: LD_VAR 0 8
36891: PUSH
36892: LD_INT 1
36894: ARRAY
36895: PPUSH
36896: CALL_OW 255
36900: ST_TO_ADDR
// dep := dep [ 1 ] ;
36901: LD_ADDR_VAR 0 9
36905: PUSH
36906: LD_VAR 0 9
36910: PUSH
36911: LD_INT 1
36913: ARRAY
36914: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36915: LD_ADDR_VAR 0 7
36919: PUSH
36920: LD_EXP 78
36924: PUSH
36925: LD_VAR 0 2
36929: ARRAY
36930: PPUSH
36931: LD_INT 22
36933: PUSH
36934: LD_INT 0
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 25
36943: PUSH
36944: LD_INT 12
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PPUSH
36955: CALL_OW 70
36959: PUSH
36960: LD_INT 22
36962: PUSH
36963: LD_INT 0
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 25
36972: PUSH
36973: LD_INT 12
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 91
36982: PUSH
36983: LD_VAR 0 9
36987: PUSH
36988: LD_INT 20
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: LIST
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: LIST
37000: PPUSH
37001: CALL_OW 69
37005: UNION
37006: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37007: LD_ADDR_VAR 0 10
37011: PUSH
37012: LD_EXP 78
37016: PUSH
37017: LD_VAR 0 2
37021: ARRAY
37022: PPUSH
37023: LD_INT 81
37025: PUSH
37026: LD_VAR 0 11
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PPUSH
37035: CALL_OW 70
37039: ST_TO_ADDR
// if not apes or danger_at_area then
37040: LD_VAR 0 7
37044: NOT
37045: PUSH
37046: LD_VAR 0 10
37050: OR
37051: IFFALSE 37101
// begin if mc_taming [ i ] then
37053: LD_EXP 81
37057: PUSH
37058: LD_VAR 0 2
37062: ARRAY
37063: IFFALSE 37099
// begin MC_Reset ( i , 121 ) ;
37065: LD_VAR 0 2
37069: PPUSH
37070: LD_INT 121
37072: PPUSH
37073: CALL 22091 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37077: LD_ADDR_EXP 81
37081: PUSH
37082: LD_EXP 81
37086: PPUSH
37087: LD_VAR 0 2
37091: PPUSH
37092: EMPTY
37093: PPUSH
37094: CALL_OW 1
37098: ST_TO_ADDR
// end ; continue ;
37099: GO 36667
// end ; for j in tmp do
37101: LD_ADDR_VAR 0 3
37105: PUSH
37106: LD_VAR 0 8
37110: PUSH
37111: FOR_IN
37112: IFFALSE 37448
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37114: LD_VAR 0 3
37118: PUSH
37119: LD_EXP 81
37123: PUSH
37124: LD_VAR 0 2
37128: ARRAY
37129: IN
37130: NOT
37131: PUSH
37132: LD_EXP 81
37136: PUSH
37137: LD_VAR 0 2
37141: ARRAY
37142: PUSH
37143: LD_INT 3
37145: LESS
37146: AND
37147: IFFALSE 37205
// begin SetTag ( j , 121 ) ;
37149: LD_VAR 0 3
37153: PPUSH
37154: LD_INT 121
37156: PPUSH
37157: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37161: LD_ADDR_EXP 81
37165: PUSH
37166: LD_EXP 81
37170: PPUSH
37171: LD_VAR 0 2
37175: PUSH
37176: LD_EXP 81
37180: PUSH
37181: LD_VAR 0 2
37185: ARRAY
37186: PUSH
37187: LD_INT 1
37189: PLUS
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PPUSH
37195: LD_VAR 0 3
37199: PPUSH
37200: CALL 53678 0 3
37204: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37205: LD_VAR 0 3
37209: PUSH
37210: LD_EXP 81
37214: PUSH
37215: LD_VAR 0 2
37219: ARRAY
37220: IN
37221: IFFALSE 37446
// begin if GetClass ( j ) <> 4 then
37223: LD_VAR 0 3
37227: PPUSH
37228: CALL_OW 257
37232: PUSH
37233: LD_INT 4
37235: NONEQUAL
37236: IFFALSE 37289
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37238: LD_ADDR_EXP 81
37242: PUSH
37243: LD_EXP 81
37247: PPUSH
37248: LD_VAR 0 2
37252: PPUSH
37253: LD_EXP 81
37257: PUSH
37258: LD_VAR 0 2
37262: ARRAY
37263: PUSH
37264: LD_VAR 0 3
37268: DIFF
37269: PPUSH
37270: CALL_OW 1
37274: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37275: LD_VAR 0 3
37279: PPUSH
37280: LD_INT 0
37282: PPUSH
37283: CALL_OW 109
// continue ;
37287: GO 37111
// end ; if IsInUnit ( j ) then
37289: LD_VAR 0 3
37293: PPUSH
37294: CALL_OW 310
37298: IFFALSE 37309
// ComExitBuilding ( j ) ;
37300: LD_VAR 0 3
37304: PPUSH
37305: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37309: LD_ADDR_VAR 0 6
37313: PUSH
37314: LD_VAR 0 7
37318: PPUSH
37319: LD_VAR 0 3
37323: PPUSH
37324: CALL_OW 74
37328: ST_TO_ADDR
// if not ape then
37329: LD_VAR 0 6
37333: NOT
37334: IFFALSE 37338
// break ;
37336: GO 37448
// x := GetX ( ape ) ;
37338: LD_ADDR_VAR 0 4
37342: PUSH
37343: LD_VAR 0 6
37347: PPUSH
37348: CALL_OW 250
37352: ST_TO_ADDR
// y := GetY ( ape ) ;
37353: LD_ADDR_VAR 0 5
37357: PUSH
37358: LD_VAR 0 6
37362: PPUSH
37363: CALL_OW 251
37367: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37368: LD_VAR 0 4
37372: PPUSH
37373: LD_VAR 0 5
37377: PPUSH
37378: CALL_OW 488
37382: NOT
37383: PUSH
37384: LD_VAR 0 11
37388: PPUSH
37389: LD_VAR 0 4
37393: PPUSH
37394: LD_VAR 0 5
37398: PPUSH
37399: LD_INT 20
37401: PPUSH
37402: CALL 54574 0 4
37406: PUSH
37407: LD_INT 4
37409: ARRAY
37410: OR
37411: IFFALSE 37415
// break ;
37413: GO 37448
// if not HasTask ( j ) then
37415: LD_VAR 0 3
37419: PPUSH
37420: CALL_OW 314
37424: NOT
37425: IFFALSE 37446
// ComTameXY ( j , x , y ) ;
37427: LD_VAR 0 3
37431: PPUSH
37432: LD_VAR 0 4
37436: PPUSH
37437: LD_VAR 0 5
37441: PPUSH
37442: CALL_OW 131
// end ; end ;
37446: GO 37111
37448: POP
37449: POP
// end ;
37450: GO 36667
37452: POP
37453: POP
// end ;
37454: LD_VAR 0 1
37458: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37459: LD_INT 0
37461: PPUSH
37462: PPUSH
37463: PPUSH
37464: PPUSH
37465: PPUSH
37466: PPUSH
37467: PPUSH
37468: PPUSH
// if not mc_bases then
37469: LD_EXP 50
37473: NOT
37474: IFFALSE 37478
// exit ;
37476: GO 38104
// for i = 1 to mc_bases do
37478: LD_ADDR_VAR 0 2
37482: PUSH
37483: DOUBLE
37484: LD_INT 1
37486: DEC
37487: ST_TO_ADDR
37488: LD_EXP 50
37492: PUSH
37493: FOR_TO
37494: IFFALSE 38102
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37496: LD_EXP 79
37500: PUSH
37501: LD_VAR 0 2
37505: ARRAY
37506: NOT
37507: PUSH
37508: LD_EXP 79
37512: PUSH
37513: LD_VAR 0 2
37517: ARRAY
37518: PPUSH
37519: LD_INT 25
37521: PUSH
37522: LD_INT 12
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PPUSH
37529: CALL_OW 72
37533: NOT
37534: OR
37535: IFFALSE 37539
// continue ;
37537: GO 37493
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37539: LD_ADDR_VAR 0 5
37543: PUSH
37544: LD_EXP 79
37548: PUSH
37549: LD_VAR 0 2
37553: ARRAY
37554: PUSH
37555: LD_INT 1
37557: ARRAY
37558: PPUSH
37559: CALL_OW 255
37563: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37564: LD_VAR 0 5
37568: PPUSH
37569: LD_INT 2
37571: PPUSH
37572: CALL_OW 325
37576: IFFALSE 37829
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37578: LD_ADDR_VAR 0 4
37582: PUSH
37583: LD_EXP 79
37587: PUSH
37588: LD_VAR 0 2
37592: ARRAY
37593: PPUSH
37594: LD_INT 25
37596: PUSH
37597: LD_INT 16
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PPUSH
37604: CALL_OW 72
37608: ST_TO_ADDR
// if tmp < 6 then
37609: LD_VAR 0 4
37613: PUSH
37614: LD_INT 6
37616: LESS
37617: IFFALSE 37829
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37619: LD_ADDR_VAR 0 6
37623: PUSH
37624: LD_EXP 50
37628: PUSH
37629: LD_VAR 0 2
37633: ARRAY
37634: PPUSH
37635: LD_INT 2
37637: PUSH
37638: LD_INT 30
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 30
37650: PUSH
37651: LD_INT 1
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: LIST
37662: PPUSH
37663: CALL_OW 72
37667: ST_TO_ADDR
// if depot then
37668: LD_VAR 0 6
37672: IFFALSE 37829
// begin selected := 0 ;
37674: LD_ADDR_VAR 0 7
37678: PUSH
37679: LD_INT 0
37681: ST_TO_ADDR
// for j in depot do
37682: LD_ADDR_VAR 0 3
37686: PUSH
37687: LD_VAR 0 6
37691: PUSH
37692: FOR_IN
37693: IFFALSE 37724
// begin if UnitsInside ( j ) < 6 then
37695: LD_VAR 0 3
37699: PPUSH
37700: CALL_OW 313
37704: PUSH
37705: LD_INT 6
37707: LESS
37708: IFFALSE 37722
// begin selected := j ;
37710: LD_ADDR_VAR 0 7
37714: PUSH
37715: LD_VAR 0 3
37719: ST_TO_ADDR
// break ;
37720: GO 37724
// end ; end ;
37722: GO 37692
37724: POP
37725: POP
// if selected then
37726: LD_VAR 0 7
37730: IFFALSE 37829
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37732: LD_ADDR_VAR 0 3
37736: PUSH
37737: LD_EXP 79
37741: PUSH
37742: LD_VAR 0 2
37746: ARRAY
37747: PPUSH
37748: LD_INT 25
37750: PUSH
37751: LD_INT 12
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PPUSH
37758: CALL_OW 72
37762: PUSH
37763: FOR_IN
37764: IFFALSE 37827
// if not HasTask ( j ) then
37766: LD_VAR 0 3
37770: PPUSH
37771: CALL_OW 314
37775: NOT
37776: IFFALSE 37825
// begin if not IsInUnit ( j ) then
37778: LD_VAR 0 3
37782: PPUSH
37783: CALL_OW 310
37787: NOT
37788: IFFALSE 37804
// ComEnterUnit ( j , selected ) ;
37790: LD_VAR 0 3
37794: PPUSH
37795: LD_VAR 0 7
37799: PPUSH
37800: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37804: LD_VAR 0 3
37808: PPUSH
37809: LD_INT 16
37811: PPUSH
37812: CALL_OW 183
// AddComExitBuilding ( j ) ;
37816: LD_VAR 0 3
37820: PPUSH
37821: CALL_OW 182
// end ;
37825: GO 37763
37827: POP
37828: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37829: LD_VAR 0 5
37833: PPUSH
37834: LD_INT 11
37836: PPUSH
37837: CALL_OW 325
37841: IFFALSE 38100
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37843: LD_ADDR_VAR 0 4
37847: PUSH
37848: LD_EXP 79
37852: PUSH
37853: LD_VAR 0 2
37857: ARRAY
37858: PPUSH
37859: LD_INT 25
37861: PUSH
37862: LD_INT 16
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PPUSH
37869: CALL_OW 72
37873: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37874: LD_VAR 0 4
37878: PUSH
37879: LD_INT 6
37881: GREATEREQUAL
37882: PUSH
37883: LD_VAR 0 5
37887: PPUSH
37888: LD_INT 2
37890: PPUSH
37891: CALL_OW 325
37895: NOT
37896: OR
37897: IFFALSE 38100
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37899: LD_ADDR_VAR 0 8
37903: PUSH
37904: LD_EXP 50
37908: PUSH
37909: LD_VAR 0 2
37913: ARRAY
37914: PPUSH
37915: LD_INT 2
37917: PUSH
37918: LD_INT 30
37920: PUSH
37921: LD_INT 4
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 30
37930: PUSH
37931: LD_INT 5
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: LIST
37942: PPUSH
37943: CALL_OW 72
37947: ST_TO_ADDR
// if barracks then
37948: LD_VAR 0 8
37952: IFFALSE 38100
// begin selected := 0 ;
37954: LD_ADDR_VAR 0 7
37958: PUSH
37959: LD_INT 0
37961: ST_TO_ADDR
// for j in barracks do
37962: LD_ADDR_VAR 0 3
37966: PUSH
37967: LD_VAR 0 8
37971: PUSH
37972: FOR_IN
37973: IFFALSE 38004
// begin if UnitsInside ( j ) < 6 then
37975: LD_VAR 0 3
37979: PPUSH
37980: CALL_OW 313
37984: PUSH
37985: LD_INT 6
37987: LESS
37988: IFFALSE 38002
// begin selected := j ;
37990: LD_ADDR_VAR 0 7
37994: PUSH
37995: LD_VAR 0 3
37999: ST_TO_ADDR
// break ;
38000: GO 38004
// end ; end ;
38002: GO 37972
38004: POP
38005: POP
// if selected then
38006: LD_VAR 0 7
38010: IFFALSE 38100
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38012: LD_ADDR_VAR 0 3
38016: PUSH
38017: LD_EXP 79
38021: PUSH
38022: LD_VAR 0 2
38026: ARRAY
38027: PPUSH
38028: LD_INT 25
38030: PUSH
38031: LD_INT 12
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PPUSH
38038: CALL_OW 72
38042: PUSH
38043: FOR_IN
38044: IFFALSE 38098
// if not IsInUnit ( j ) and not HasTask ( j ) then
38046: LD_VAR 0 3
38050: PPUSH
38051: CALL_OW 310
38055: NOT
38056: PUSH
38057: LD_VAR 0 3
38061: PPUSH
38062: CALL_OW 314
38066: NOT
38067: AND
38068: IFFALSE 38096
// begin ComEnterUnit ( j , selected ) ;
38070: LD_VAR 0 3
38074: PPUSH
38075: LD_VAR 0 7
38079: PPUSH
38080: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38084: LD_VAR 0 3
38088: PPUSH
38089: LD_INT 15
38091: PPUSH
38092: CALL_OW 183
// end ;
38096: GO 38043
38098: POP
38099: POP
// end ; end ; end ; end ; end ;
38100: GO 37493
38102: POP
38103: POP
// end ;
38104: LD_VAR 0 1
38108: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38109: LD_INT 0
38111: PPUSH
38112: PPUSH
38113: PPUSH
38114: PPUSH
// if not mc_bases then
38115: LD_EXP 50
38119: NOT
38120: IFFALSE 38124
// exit ;
38122: GO 38302
// for i = 1 to mc_bases do
38124: LD_ADDR_VAR 0 2
38128: PUSH
38129: DOUBLE
38130: LD_INT 1
38132: DEC
38133: ST_TO_ADDR
38134: LD_EXP 50
38138: PUSH
38139: FOR_TO
38140: IFFALSE 38300
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38142: LD_ADDR_VAR 0 4
38146: PUSH
38147: LD_EXP 50
38151: PUSH
38152: LD_VAR 0 2
38156: ARRAY
38157: PPUSH
38158: LD_INT 25
38160: PUSH
38161: LD_INT 9
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PPUSH
38168: CALL_OW 72
38172: ST_TO_ADDR
// if not tmp then
38173: LD_VAR 0 4
38177: NOT
38178: IFFALSE 38182
// continue ;
38180: GO 38139
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38182: LD_EXP 76
38186: PUSH
38187: LD_VAR 0 2
38191: ARRAY
38192: PPUSH
38193: LD_INT 29
38195: PPUSH
38196: CALL_OW 325
38200: NOT
38201: PUSH
38202: LD_EXP 76
38206: PUSH
38207: LD_VAR 0 2
38211: ARRAY
38212: PPUSH
38213: LD_INT 28
38215: PPUSH
38216: CALL_OW 325
38220: NOT
38221: AND
38222: IFFALSE 38226
// continue ;
38224: GO 38139
// for j in tmp do
38226: LD_ADDR_VAR 0 3
38230: PUSH
38231: LD_VAR 0 4
38235: PUSH
38236: FOR_IN
38237: IFFALSE 38296
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38239: LD_VAR 0 3
38243: PUSH
38244: LD_EXP 53
38248: PUSH
38249: LD_VAR 0 2
38253: ARRAY
38254: PUSH
38255: LD_INT 1
38257: ARRAY
38258: IN
38259: NOT
38260: PUSH
38261: LD_VAR 0 3
38265: PUSH
38266: LD_EXP 53
38270: PUSH
38271: LD_VAR 0 2
38275: ARRAY
38276: PUSH
38277: LD_INT 2
38279: ARRAY
38280: IN
38281: NOT
38282: AND
38283: IFFALSE 38294
// ComSpaceTimeShoot ( j ) ;
38285: LD_VAR 0 3
38289: PPUSH
38290: CALL 49488 0 1
38294: GO 38236
38296: POP
38297: POP
// end ;
38298: GO 38139
38300: POP
38301: POP
// end ;
38302: LD_VAR 0 1
38306: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38307: LD_INT 0
38309: PPUSH
38310: PPUSH
38311: PPUSH
38312: PPUSH
38313: PPUSH
38314: PPUSH
38315: PPUSH
38316: PPUSH
38317: PPUSH
// if not mc_bases then
38318: LD_EXP 50
38322: NOT
38323: IFFALSE 38327
// exit ;
38325: GO 38949
// for i = 1 to mc_bases do
38327: LD_ADDR_VAR 0 2
38331: PUSH
38332: DOUBLE
38333: LD_INT 1
38335: DEC
38336: ST_TO_ADDR
38337: LD_EXP 50
38341: PUSH
38342: FOR_TO
38343: IFFALSE 38947
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38345: LD_EXP 85
38349: PUSH
38350: LD_VAR 0 2
38354: ARRAY
38355: NOT
38356: PUSH
38357: LD_INT 38
38359: PPUSH
38360: LD_EXP 76
38364: PUSH
38365: LD_VAR 0 2
38369: ARRAY
38370: PPUSH
38371: CALL_OW 321
38375: PUSH
38376: LD_INT 2
38378: NONEQUAL
38379: OR
38380: IFFALSE 38384
// continue ;
38382: GO 38342
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38384: LD_ADDR_VAR 0 8
38388: PUSH
38389: LD_EXP 50
38393: PUSH
38394: LD_VAR 0 2
38398: ARRAY
38399: PPUSH
38400: LD_INT 30
38402: PUSH
38403: LD_INT 34
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PPUSH
38410: CALL_OW 72
38414: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38415: LD_ADDR_VAR 0 9
38419: PUSH
38420: LD_EXP 50
38424: PUSH
38425: LD_VAR 0 2
38429: ARRAY
38430: PPUSH
38431: LD_INT 25
38433: PUSH
38434: LD_INT 4
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PPUSH
38441: CALL_OW 72
38445: PPUSH
38446: LD_INT 0
38448: PPUSH
38449: CALL 83491 0 2
38453: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38454: LD_VAR 0 9
38458: NOT
38459: PUSH
38460: LD_VAR 0 8
38464: NOT
38465: OR
38466: PUSH
38467: LD_EXP 50
38471: PUSH
38472: LD_VAR 0 2
38476: ARRAY
38477: PPUSH
38478: LD_INT 124
38480: PPUSH
38481: CALL 83491 0 2
38485: OR
38486: IFFALSE 38490
// continue ;
38488: GO 38342
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38490: LD_EXP 86
38494: PUSH
38495: LD_VAR 0 2
38499: ARRAY
38500: PUSH
38501: LD_EXP 85
38505: PUSH
38506: LD_VAR 0 2
38510: ARRAY
38511: LESS
38512: PUSH
38513: LD_EXP 86
38517: PUSH
38518: LD_VAR 0 2
38522: ARRAY
38523: PUSH
38524: LD_VAR 0 8
38528: LESS
38529: AND
38530: IFFALSE 38945
// begin tmp := sci [ 1 ] ;
38532: LD_ADDR_VAR 0 7
38536: PUSH
38537: LD_VAR 0 9
38541: PUSH
38542: LD_INT 1
38544: ARRAY
38545: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38546: LD_VAR 0 7
38550: PPUSH
38551: LD_INT 124
38553: PPUSH
38554: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38558: LD_ADDR_VAR 0 3
38562: PUSH
38563: DOUBLE
38564: LD_EXP 85
38568: PUSH
38569: LD_VAR 0 2
38573: ARRAY
38574: INC
38575: ST_TO_ADDR
38576: LD_EXP 85
38580: PUSH
38581: LD_VAR 0 2
38585: ARRAY
38586: PUSH
38587: FOR_DOWNTO
38588: IFFALSE 38931
// begin if IsInUnit ( tmp ) then
38590: LD_VAR 0 7
38594: PPUSH
38595: CALL_OW 310
38599: IFFALSE 38610
// ComExitBuilding ( tmp ) ;
38601: LD_VAR 0 7
38605: PPUSH
38606: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38610: LD_INT 35
38612: PPUSH
38613: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38617: LD_VAR 0 7
38621: PPUSH
38622: CALL_OW 310
38626: NOT
38627: PUSH
38628: LD_VAR 0 7
38632: PPUSH
38633: CALL_OW 314
38637: NOT
38638: AND
38639: IFFALSE 38610
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38641: LD_ADDR_VAR 0 6
38645: PUSH
38646: LD_VAR 0 7
38650: PPUSH
38651: CALL_OW 250
38655: PUSH
38656: LD_VAR 0 7
38660: PPUSH
38661: CALL_OW 251
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38670: LD_INT 35
38672: PPUSH
38673: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38677: LD_ADDR_VAR 0 4
38681: PUSH
38682: LD_EXP 85
38686: PUSH
38687: LD_VAR 0 2
38691: ARRAY
38692: PUSH
38693: LD_VAR 0 3
38697: ARRAY
38698: PUSH
38699: LD_INT 1
38701: ARRAY
38702: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38703: LD_ADDR_VAR 0 5
38707: PUSH
38708: LD_EXP 85
38712: PUSH
38713: LD_VAR 0 2
38717: ARRAY
38718: PUSH
38719: LD_VAR 0 3
38723: ARRAY
38724: PUSH
38725: LD_INT 2
38727: ARRAY
38728: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38729: LD_VAR 0 7
38733: PPUSH
38734: LD_INT 10
38736: PPUSH
38737: CALL 56275 0 2
38741: PUSH
38742: LD_INT 4
38744: ARRAY
38745: IFFALSE 38783
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38747: LD_VAR 0 7
38751: PPUSH
38752: LD_VAR 0 6
38756: PUSH
38757: LD_INT 1
38759: ARRAY
38760: PPUSH
38761: LD_VAR 0 6
38765: PUSH
38766: LD_INT 2
38768: ARRAY
38769: PPUSH
38770: CALL_OW 111
// wait ( 0 0$10 ) ;
38774: LD_INT 350
38776: PPUSH
38777: CALL_OW 67
// end else
38781: GO 38809
// begin ComMoveXY ( tmp , x , y ) ;
38783: LD_VAR 0 7
38787: PPUSH
38788: LD_VAR 0 4
38792: PPUSH
38793: LD_VAR 0 5
38797: PPUSH
38798: CALL_OW 111
// wait ( 0 0$3 ) ;
38802: LD_INT 105
38804: PPUSH
38805: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38809: LD_VAR 0 7
38813: PPUSH
38814: LD_VAR 0 4
38818: PPUSH
38819: LD_VAR 0 5
38823: PPUSH
38824: CALL_OW 307
38828: IFFALSE 38670
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38830: LD_VAR 0 7
38834: PPUSH
38835: LD_VAR 0 4
38839: PPUSH
38840: LD_VAR 0 5
38844: PPUSH
38845: LD_VAR 0 8
38849: PUSH
38850: LD_VAR 0 3
38854: ARRAY
38855: PPUSH
38856: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38860: LD_INT 35
38862: PPUSH
38863: CALL_OW 67
// until not HasTask ( tmp ) ;
38867: LD_VAR 0 7
38871: PPUSH
38872: CALL_OW 314
38876: NOT
38877: IFFALSE 38860
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38879: LD_ADDR_EXP 86
38883: PUSH
38884: LD_EXP 86
38888: PPUSH
38889: LD_VAR 0 2
38893: PUSH
38894: LD_EXP 86
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: PUSH
38905: LD_INT 1
38907: PLUS
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PPUSH
38913: LD_VAR 0 8
38917: PUSH
38918: LD_VAR 0 3
38922: ARRAY
38923: PPUSH
38924: CALL 53678 0 3
38928: ST_TO_ADDR
// end ;
38929: GO 38587
38931: POP
38932: POP
// MC_Reset ( i , 124 ) ;
38933: LD_VAR 0 2
38937: PPUSH
38938: LD_INT 124
38940: PPUSH
38941: CALL 22091 0 2
// end ; end ;
38945: GO 38342
38947: POP
38948: POP
// end ;
38949: LD_VAR 0 1
38953: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38954: LD_INT 0
38956: PPUSH
38957: PPUSH
38958: PPUSH
// if not mc_bases then
38959: LD_EXP 50
38963: NOT
38964: IFFALSE 38968
// exit ;
38966: GO 39574
// for i = 1 to mc_bases do
38968: LD_ADDR_VAR 0 2
38972: PUSH
38973: DOUBLE
38974: LD_INT 1
38976: DEC
38977: ST_TO_ADDR
38978: LD_EXP 50
38982: PUSH
38983: FOR_TO
38984: IFFALSE 39572
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38986: LD_ADDR_VAR 0 3
38990: PUSH
38991: LD_EXP 50
38995: PUSH
38996: LD_VAR 0 2
39000: ARRAY
39001: PPUSH
39002: LD_INT 25
39004: PUSH
39005: LD_INT 4
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PPUSH
39012: CALL_OW 72
39016: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39017: LD_VAR 0 3
39021: NOT
39022: PUSH
39023: LD_EXP 87
39027: PUSH
39028: LD_VAR 0 2
39032: ARRAY
39033: NOT
39034: OR
39035: PUSH
39036: LD_EXP 50
39040: PUSH
39041: LD_VAR 0 2
39045: ARRAY
39046: PPUSH
39047: LD_INT 2
39049: PUSH
39050: LD_INT 30
39052: PUSH
39053: LD_INT 0
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 30
39062: PUSH
39063: LD_INT 1
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: LIST
39074: PPUSH
39075: CALL_OW 72
39079: NOT
39080: OR
39081: IFFALSE 39131
// begin if mc_deposits_finder [ i ] then
39083: LD_EXP 88
39087: PUSH
39088: LD_VAR 0 2
39092: ARRAY
39093: IFFALSE 39129
// begin MC_Reset ( i , 125 ) ;
39095: LD_VAR 0 2
39099: PPUSH
39100: LD_INT 125
39102: PPUSH
39103: CALL 22091 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39107: LD_ADDR_EXP 88
39111: PUSH
39112: LD_EXP 88
39116: PPUSH
39117: LD_VAR 0 2
39121: PPUSH
39122: EMPTY
39123: PPUSH
39124: CALL_OW 1
39128: ST_TO_ADDR
// end ; continue ;
39129: GO 38983
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39131: LD_EXP 87
39135: PUSH
39136: LD_VAR 0 2
39140: ARRAY
39141: PUSH
39142: LD_INT 1
39144: ARRAY
39145: PUSH
39146: LD_INT 3
39148: ARRAY
39149: PUSH
39150: LD_INT 1
39152: EQUAL
39153: PUSH
39154: LD_INT 20
39156: PPUSH
39157: LD_EXP 76
39161: PUSH
39162: LD_VAR 0 2
39166: ARRAY
39167: PPUSH
39168: CALL_OW 321
39172: PUSH
39173: LD_INT 2
39175: NONEQUAL
39176: AND
39177: IFFALSE 39227
// begin if mc_deposits_finder [ i ] then
39179: LD_EXP 88
39183: PUSH
39184: LD_VAR 0 2
39188: ARRAY
39189: IFFALSE 39225
// begin MC_Reset ( i , 125 ) ;
39191: LD_VAR 0 2
39195: PPUSH
39196: LD_INT 125
39198: PPUSH
39199: CALL 22091 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39203: LD_ADDR_EXP 88
39207: PUSH
39208: LD_EXP 88
39212: PPUSH
39213: LD_VAR 0 2
39217: PPUSH
39218: EMPTY
39219: PPUSH
39220: CALL_OW 1
39224: ST_TO_ADDR
// end ; continue ;
39225: GO 38983
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39227: LD_EXP 87
39231: PUSH
39232: LD_VAR 0 2
39236: ARRAY
39237: PUSH
39238: LD_INT 1
39240: ARRAY
39241: PUSH
39242: LD_INT 1
39244: ARRAY
39245: PPUSH
39246: LD_EXP 87
39250: PUSH
39251: LD_VAR 0 2
39255: ARRAY
39256: PUSH
39257: LD_INT 1
39259: ARRAY
39260: PUSH
39261: LD_INT 2
39263: ARRAY
39264: PPUSH
39265: LD_EXP 76
39269: PUSH
39270: LD_VAR 0 2
39274: ARRAY
39275: PPUSH
39276: CALL_OW 440
39280: IFFALSE 39323
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39282: LD_ADDR_EXP 87
39286: PUSH
39287: LD_EXP 87
39291: PPUSH
39292: LD_VAR 0 2
39296: PPUSH
39297: LD_EXP 87
39301: PUSH
39302: LD_VAR 0 2
39306: ARRAY
39307: PPUSH
39308: LD_INT 1
39310: PPUSH
39311: CALL_OW 3
39315: PPUSH
39316: CALL_OW 1
39320: ST_TO_ADDR
39321: GO 39570
// begin if not mc_deposits_finder [ i ] then
39323: LD_EXP 88
39327: PUSH
39328: LD_VAR 0 2
39332: ARRAY
39333: NOT
39334: IFFALSE 39386
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39336: LD_ADDR_EXP 88
39340: PUSH
39341: LD_EXP 88
39345: PPUSH
39346: LD_VAR 0 2
39350: PPUSH
39351: LD_VAR 0 3
39355: PUSH
39356: LD_INT 1
39358: ARRAY
39359: PUSH
39360: EMPTY
39361: LIST
39362: PPUSH
39363: CALL_OW 1
39367: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39368: LD_VAR 0 3
39372: PUSH
39373: LD_INT 1
39375: ARRAY
39376: PPUSH
39377: LD_INT 125
39379: PPUSH
39380: CALL_OW 109
// end else
39384: GO 39570
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39386: LD_EXP 88
39390: PUSH
39391: LD_VAR 0 2
39395: ARRAY
39396: PUSH
39397: LD_INT 1
39399: ARRAY
39400: PPUSH
39401: CALL_OW 310
39405: IFFALSE 39428
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39407: LD_EXP 88
39411: PUSH
39412: LD_VAR 0 2
39416: ARRAY
39417: PUSH
39418: LD_INT 1
39420: ARRAY
39421: PPUSH
39422: CALL_OW 122
39426: GO 39570
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39428: LD_EXP 88
39432: PUSH
39433: LD_VAR 0 2
39437: ARRAY
39438: PUSH
39439: LD_INT 1
39441: ARRAY
39442: PPUSH
39443: CALL_OW 314
39447: NOT
39448: PUSH
39449: LD_EXP 88
39453: PUSH
39454: LD_VAR 0 2
39458: ARRAY
39459: PUSH
39460: LD_INT 1
39462: ARRAY
39463: PPUSH
39464: LD_EXP 87
39468: PUSH
39469: LD_VAR 0 2
39473: ARRAY
39474: PUSH
39475: LD_INT 1
39477: ARRAY
39478: PUSH
39479: LD_INT 1
39481: ARRAY
39482: PPUSH
39483: LD_EXP 87
39487: PUSH
39488: LD_VAR 0 2
39492: ARRAY
39493: PUSH
39494: LD_INT 1
39496: ARRAY
39497: PUSH
39498: LD_INT 2
39500: ARRAY
39501: PPUSH
39502: CALL_OW 297
39506: PUSH
39507: LD_INT 6
39509: GREATER
39510: AND
39511: IFFALSE 39570
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39513: LD_EXP 88
39517: PUSH
39518: LD_VAR 0 2
39522: ARRAY
39523: PUSH
39524: LD_INT 1
39526: ARRAY
39527: PPUSH
39528: LD_EXP 87
39532: PUSH
39533: LD_VAR 0 2
39537: ARRAY
39538: PUSH
39539: LD_INT 1
39541: ARRAY
39542: PUSH
39543: LD_INT 1
39545: ARRAY
39546: PPUSH
39547: LD_EXP 87
39551: PUSH
39552: LD_VAR 0 2
39556: ARRAY
39557: PUSH
39558: LD_INT 1
39560: ARRAY
39561: PUSH
39562: LD_INT 2
39564: ARRAY
39565: PPUSH
39566: CALL_OW 111
// end ; end ; end ;
39570: GO 38983
39572: POP
39573: POP
// end ;
39574: LD_VAR 0 1
39578: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39579: LD_INT 0
39581: PPUSH
39582: PPUSH
39583: PPUSH
39584: PPUSH
39585: PPUSH
39586: PPUSH
39587: PPUSH
39588: PPUSH
39589: PPUSH
39590: PPUSH
39591: PPUSH
// if not mc_bases then
39592: LD_EXP 50
39596: NOT
39597: IFFALSE 39601
// exit ;
39599: GO 40541
// for i = 1 to mc_bases do
39601: LD_ADDR_VAR 0 2
39605: PUSH
39606: DOUBLE
39607: LD_INT 1
39609: DEC
39610: ST_TO_ADDR
39611: LD_EXP 50
39615: PUSH
39616: FOR_TO
39617: IFFALSE 40539
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39619: LD_EXP 50
39623: PUSH
39624: LD_VAR 0 2
39628: ARRAY
39629: NOT
39630: PUSH
39631: LD_EXP 73
39635: PUSH
39636: LD_VAR 0 2
39640: ARRAY
39641: OR
39642: IFFALSE 39646
// continue ;
39644: GO 39616
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39646: LD_ADDR_VAR 0 7
39650: PUSH
39651: LD_EXP 50
39655: PUSH
39656: LD_VAR 0 2
39660: ARRAY
39661: PUSH
39662: LD_INT 1
39664: ARRAY
39665: PPUSH
39666: CALL_OW 248
39670: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39671: LD_VAR 0 7
39675: PUSH
39676: LD_INT 3
39678: EQUAL
39679: PUSH
39680: LD_EXP 69
39684: PUSH
39685: LD_VAR 0 2
39689: ARRAY
39690: PUSH
39691: LD_EXP 72
39695: PUSH
39696: LD_VAR 0 2
39700: ARRAY
39701: UNION
39702: PPUSH
39703: LD_INT 33
39705: PUSH
39706: LD_INT 2
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PPUSH
39713: CALL_OW 72
39717: NOT
39718: OR
39719: IFFALSE 39723
// continue ;
39721: GO 39616
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39723: LD_ADDR_VAR 0 9
39727: PUSH
39728: LD_EXP 50
39732: PUSH
39733: LD_VAR 0 2
39737: ARRAY
39738: PPUSH
39739: LD_INT 30
39741: PUSH
39742: LD_INT 36
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PPUSH
39749: CALL_OW 72
39753: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39754: LD_ADDR_VAR 0 10
39758: PUSH
39759: LD_EXP 69
39763: PUSH
39764: LD_VAR 0 2
39768: ARRAY
39769: PPUSH
39770: LD_INT 34
39772: PUSH
39773: LD_INT 31
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PPUSH
39780: CALL_OW 72
39784: ST_TO_ADDR
// if not cts and not mcts then
39785: LD_VAR 0 9
39789: NOT
39790: PUSH
39791: LD_VAR 0 10
39795: NOT
39796: AND
39797: IFFALSE 39801
// continue ;
39799: GO 39616
// x := cts ;
39801: LD_ADDR_VAR 0 11
39805: PUSH
39806: LD_VAR 0 9
39810: ST_TO_ADDR
// if not x then
39811: LD_VAR 0 11
39815: NOT
39816: IFFALSE 39828
// x := mcts ;
39818: LD_ADDR_VAR 0 11
39822: PUSH
39823: LD_VAR 0 10
39827: ST_TO_ADDR
// if not x then
39828: LD_VAR 0 11
39832: NOT
39833: IFFALSE 39837
// continue ;
39835: GO 39616
// if mc_remote_driver [ i ] then
39837: LD_EXP 90
39841: PUSH
39842: LD_VAR 0 2
39846: ARRAY
39847: IFFALSE 40234
// for j in mc_remote_driver [ i ] do
39849: LD_ADDR_VAR 0 3
39853: PUSH
39854: LD_EXP 90
39858: PUSH
39859: LD_VAR 0 2
39863: ARRAY
39864: PUSH
39865: FOR_IN
39866: IFFALSE 40232
// begin if GetClass ( j ) <> 3 then
39868: LD_VAR 0 3
39872: PPUSH
39873: CALL_OW 257
39877: PUSH
39878: LD_INT 3
39880: NONEQUAL
39881: IFFALSE 39934
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39883: LD_ADDR_EXP 90
39887: PUSH
39888: LD_EXP 90
39892: PPUSH
39893: LD_VAR 0 2
39897: PPUSH
39898: LD_EXP 90
39902: PUSH
39903: LD_VAR 0 2
39907: ARRAY
39908: PUSH
39909: LD_VAR 0 3
39913: DIFF
39914: PPUSH
39915: CALL_OW 1
39919: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39920: LD_VAR 0 3
39924: PPUSH
39925: LD_INT 0
39927: PPUSH
39928: CALL_OW 109
// continue ;
39932: GO 39865
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39934: LD_EXP 69
39938: PUSH
39939: LD_VAR 0 2
39943: ARRAY
39944: PPUSH
39945: LD_INT 34
39947: PUSH
39948: LD_INT 31
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 58
39957: PUSH
39958: EMPTY
39959: LIST
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PPUSH
39965: CALL_OW 72
39969: PUSH
39970: LD_VAR 0 3
39974: PPUSH
39975: CALL 83526 0 1
39979: NOT
39980: AND
39981: IFFALSE 40052
// begin if IsInUnit ( j ) then
39983: LD_VAR 0 3
39987: PPUSH
39988: CALL_OW 310
39992: IFFALSE 40003
// ComExitBuilding ( j ) ;
39994: LD_VAR 0 3
39998: PPUSH
39999: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40003: LD_VAR 0 3
40007: PPUSH
40008: LD_EXP 69
40012: PUSH
40013: LD_VAR 0 2
40017: ARRAY
40018: PPUSH
40019: LD_INT 34
40021: PUSH
40022: LD_INT 31
40024: PUSH
40025: EMPTY
40026: LIST
40027: LIST
40028: PUSH
40029: LD_INT 58
40031: PUSH
40032: EMPTY
40033: LIST
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PPUSH
40039: CALL_OW 72
40043: PUSH
40044: LD_INT 1
40046: ARRAY
40047: PPUSH
40048: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40052: LD_VAR 0 3
40056: PPUSH
40057: CALL_OW 310
40061: NOT
40062: PUSH
40063: LD_VAR 0 3
40067: PPUSH
40068: CALL_OW 310
40072: PPUSH
40073: CALL_OW 266
40077: PUSH
40078: LD_INT 36
40080: NONEQUAL
40081: PUSH
40082: LD_VAR 0 3
40086: PPUSH
40087: CALL 83526 0 1
40091: NOT
40092: AND
40093: OR
40094: IFFALSE 40230
// begin if IsInUnit ( j ) then
40096: LD_VAR 0 3
40100: PPUSH
40101: CALL_OW 310
40105: IFFALSE 40116
// ComExitBuilding ( j ) ;
40107: LD_VAR 0 3
40111: PPUSH
40112: CALL_OW 122
// ct := 0 ;
40116: LD_ADDR_VAR 0 8
40120: PUSH
40121: LD_INT 0
40123: ST_TO_ADDR
// for k in x do
40124: LD_ADDR_VAR 0 4
40128: PUSH
40129: LD_VAR 0 11
40133: PUSH
40134: FOR_IN
40135: IFFALSE 40208
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40137: LD_VAR 0 4
40141: PPUSH
40142: CALL_OW 264
40146: PUSH
40147: LD_INT 31
40149: EQUAL
40150: PUSH
40151: LD_VAR 0 4
40155: PPUSH
40156: CALL_OW 311
40160: NOT
40161: AND
40162: PUSH
40163: LD_VAR 0 4
40167: PPUSH
40168: CALL_OW 266
40172: PUSH
40173: LD_INT 36
40175: EQUAL
40176: PUSH
40177: LD_VAR 0 4
40181: PPUSH
40182: CALL_OW 313
40186: PUSH
40187: LD_INT 3
40189: LESS
40190: AND
40191: OR
40192: IFFALSE 40206
// begin ct := k ;
40194: LD_ADDR_VAR 0 8
40198: PUSH
40199: LD_VAR 0 4
40203: ST_TO_ADDR
// break ;
40204: GO 40208
// end ;
40206: GO 40134
40208: POP
40209: POP
// if ct then
40210: LD_VAR 0 8
40214: IFFALSE 40230
// ComEnterUnit ( j , ct ) ;
40216: LD_VAR 0 3
40220: PPUSH
40221: LD_VAR 0 8
40225: PPUSH
40226: CALL_OW 120
// end ; end ;
40230: GO 39865
40232: POP
40233: POP
// places := 0 ;
40234: LD_ADDR_VAR 0 5
40238: PUSH
40239: LD_INT 0
40241: ST_TO_ADDR
// for j = 1 to x do
40242: LD_ADDR_VAR 0 3
40246: PUSH
40247: DOUBLE
40248: LD_INT 1
40250: DEC
40251: ST_TO_ADDR
40252: LD_VAR 0 11
40256: PUSH
40257: FOR_TO
40258: IFFALSE 40334
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40260: LD_VAR 0 11
40264: PUSH
40265: LD_VAR 0 3
40269: ARRAY
40270: PPUSH
40271: CALL_OW 264
40275: PUSH
40276: LD_INT 31
40278: EQUAL
40279: IFFALSE 40297
// places := places + 1 else
40281: LD_ADDR_VAR 0 5
40285: PUSH
40286: LD_VAR 0 5
40290: PUSH
40291: LD_INT 1
40293: PLUS
40294: ST_TO_ADDR
40295: GO 40332
// if GetBType ( x [ j ] ) = b_control_tower then
40297: LD_VAR 0 11
40301: PUSH
40302: LD_VAR 0 3
40306: ARRAY
40307: PPUSH
40308: CALL_OW 266
40312: PUSH
40313: LD_INT 36
40315: EQUAL
40316: IFFALSE 40332
// places := places + 3 ;
40318: LD_ADDR_VAR 0 5
40322: PUSH
40323: LD_VAR 0 5
40327: PUSH
40328: LD_INT 3
40330: PLUS
40331: ST_TO_ADDR
40332: GO 40257
40334: POP
40335: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40336: LD_VAR 0 5
40340: PUSH
40341: LD_INT 0
40343: EQUAL
40344: PUSH
40345: LD_VAR 0 5
40349: PUSH
40350: LD_EXP 90
40354: PUSH
40355: LD_VAR 0 2
40359: ARRAY
40360: LESSEQUAL
40361: OR
40362: IFFALSE 40366
// continue ;
40364: GO 39616
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40366: LD_ADDR_VAR 0 6
40370: PUSH
40371: LD_EXP 50
40375: PUSH
40376: LD_VAR 0 2
40380: ARRAY
40381: PPUSH
40382: LD_INT 25
40384: PUSH
40385: LD_INT 3
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PPUSH
40392: CALL_OW 72
40396: PUSH
40397: LD_EXP 90
40401: PUSH
40402: LD_VAR 0 2
40406: ARRAY
40407: DIFF
40408: PPUSH
40409: LD_INT 3
40411: PPUSH
40412: CALL 84426 0 2
40416: ST_TO_ADDR
// for j in tmp do
40417: LD_ADDR_VAR 0 3
40421: PUSH
40422: LD_VAR 0 6
40426: PUSH
40427: FOR_IN
40428: IFFALSE 40463
// if GetTag ( j ) > 0 then
40430: LD_VAR 0 3
40434: PPUSH
40435: CALL_OW 110
40439: PUSH
40440: LD_INT 0
40442: GREATER
40443: IFFALSE 40461
// tmp := tmp diff j ;
40445: LD_ADDR_VAR 0 6
40449: PUSH
40450: LD_VAR 0 6
40454: PUSH
40455: LD_VAR 0 3
40459: DIFF
40460: ST_TO_ADDR
40461: GO 40427
40463: POP
40464: POP
// if not tmp then
40465: LD_VAR 0 6
40469: NOT
40470: IFFALSE 40474
// continue ;
40472: GO 39616
// if places then
40474: LD_VAR 0 5
40478: IFFALSE 40537
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40480: LD_ADDR_EXP 90
40484: PUSH
40485: LD_EXP 90
40489: PPUSH
40490: LD_VAR 0 2
40494: PPUSH
40495: LD_EXP 90
40499: PUSH
40500: LD_VAR 0 2
40504: ARRAY
40505: PUSH
40506: LD_VAR 0 6
40510: PUSH
40511: LD_INT 1
40513: ARRAY
40514: UNION
40515: PPUSH
40516: CALL_OW 1
40520: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40521: LD_VAR 0 6
40525: PUSH
40526: LD_INT 1
40528: ARRAY
40529: PPUSH
40530: LD_INT 126
40532: PPUSH
40533: CALL_OW 109
// end ; end ;
40537: GO 39616
40539: POP
40540: POP
// end ;
40541: LD_VAR 0 1
40545: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40546: LD_INT 0
40548: PPUSH
40549: PPUSH
40550: PPUSH
40551: PPUSH
40552: PPUSH
40553: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40554: LD_VAR 0 1
40558: NOT
40559: PUSH
40560: LD_VAR 0 2
40564: NOT
40565: OR
40566: PUSH
40567: LD_VAR 0 3
40571: NOT
40572: OR
40573: PUSH
40574: LD_VAR 0 4
40578: PUSH
40579: LD_INT 1
40581: PUSH
40582: LD_INT 2
40584: PUSH
40585: LD_INT 3
40587: PUSH
40588: LD_INT 4
40590: PUSH
40591: LD_INT 5
40593: PUSH
40594: LD_INT 8
40596: PUSH
40597: LD_INT 9
40599: PUSH
40600: LD_INT 15
40602: PUSH
40603: LD_INT 16
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: IN
40617: NOT
40618: OR
40619: IFFALSE 40623
// exit ;
40621: GO 41523
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40623: LD_ADDR_VAR 0 2
40627: PUSH
40628: LD_VAR 0 2
40632: PPUSH
40633: LD_INT 21
40635: PUSH
40636: LD_INT 3
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: LD_INT 24
40645: PUSH
40646: LD_INT 250
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PPUSH
40657: CALL_OW 72
40661: ST_TO_ADDR
// case class of 1 , 15 :
40662: LD_VAR 0 4
40666: PUSH
40667: LD_INT 1
40669: DOUBLE
40670: EQUAL
40671: IFTRUE 40681
40673: LD_INT 15
40675: DOUBLE
40676: EQUAL
40677: IFTRUE 40681
40679: GO 40766
40681: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40682: LD_ADDR_VAR 0 8
40686: PUSH
40687: LD_VAR 0 2
40691: PPUSH
40692: LD_INT 2
40694: PUSH
40695: LD_INT 30
40697: PUSH
40698: LD_INT 32
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 30
40707: PUSH
40708: LD_INT 31
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: LIST
40719: PPUSH
40720: CALL_OW 72
40724: PUSH
40725: LD_VAR 0 2
40729: PPUSH
40730: LD_INT 2
40732: PUSH
40733: LD_INT 30
40735: PUSH
40736: LD_INT 4
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 30
40745: PUSH
40746: LD_INT 5
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: LIST
40757: PPUSH
40758: CALL_OW 72
40762: ADD
40763: ST_TO_ADDR
40764: GO 41012
40766: LD_INT 2
40768: DOUBLE
40769: EQUAL
40770: IFTRUE 40780
40772: LD_INT 16
40774: DOUBLE
40775: EQUAL
40776: IFTRUE 40780
40778: GO 40826
40780: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40781: LD_ADDR_VAR 0 8
40785: PUSH
40786: LD_VAR 0 2
40790: PPUSH
40791: LD_INT 2
40793: PUSH
40794: LD_INT 30
40796: PUSH
40797: LD_INT 0
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 30
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: LIST
40818: PPUSH
40819: CALL_OW 72
40823: ST_TO_ADDR
40824: GO 41012
40826: LD_INT 3
40828: DOUBLE
40829: EQUAL
40830: IFTRUE 40834
40832: GO 40880
40834: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40835: LD_ADDR_VAR 0 8
40839: PUSH
40840: LD_VAR 0 2
40844: PPUSH
40845: LD_INT 2
40847: PUSH
40848: LD_INT 30
40850: PUSH
40851: LD_INT 2
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 30
40860: PUSH
40861: LD_INT 3
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: PPUSH
40873: CALL_OW 72
40877: ST_TO_ADDR
40878: GO 41012
40880: LD_INT 4
40882: DOUBLE
40883: EQUAL
40884: IFTRUE 40888
40886: GO 40945
40888: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40889: LD_ADDR_VAR 0 8
40893: PUSH
40894: LD_VAR 0 2
40898: PPUSH
40899: LD_INT 2
40901: PUSH
40902: LD_INT 30
40904: PUSH
40905: LD_INT 6
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 30
40914: PUSH
40915: LD_INT 7
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 30
40924: PUSH
40925: LD_INT 8
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: PPUSH
40938: CALL_OW 72
40942: ST_TO_ADDR
40943: GO 41012
40945: LD_INT 5
40947: DOUBLE
40948: EQUAL
40949: IFTRUE 40965
40951: LD_INT 8
40953: DOUBLE
40954: EQUAL
40955: IFTRUE 40965
40957: LD_INT 9
40959: DOUBLE
40960: EQUAL
40961: IFTRUE 40965
40963: GO 41011
40965: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40966: LD_ADDR_VAR 0 8
40970: PUSH
40971: LD_VAR 0 2
40975: PPUSH
40976: LD_INT 2
40978: PUSH
40979: LD_INT 30
40981: PUSH
40982: LD_INT 4
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 30
40991: PUSH
40992: LD_INT 5
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: LIST
41003: PPUSH
41004: CALL_OW 72
41008: ST_TO_ADDR
41009: GO 41012
41011: POP
// if not tmp then
41012: LD_VAR 0 8
41016: NOT
41017: IFFALSE 41021
// exit ;
41019: GO 41523
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41021: LD_VAR 0 4
41025: PUSH
41026: LD_INT 1
41028: PUSH
41029: LD_INT 15
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: IN
41036: PUSH
41037: LD_EXP 59
41041: PUSH
41042: LD_VAR 0 1
41046: ARRAY
41047: AND
41048: IFFALSE 41204
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41050: LD_ADDR_VAR 0 9
41054: PUSH
41055: LD_EXP 59
41059: PUSH
41060: LD_VAR 0 1
41064: ARRAY
41065: PUSH
41066: LD_INT 1
41068: ARRAY
41069: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41070: LD_VAR 0 9
41074: PUSH
41075: LD_EXP 60
41079: PUSH
41080: LD_VAR 0 1
41084: ARRAY
41085: IN
41086: NOT
41087: IFFALSE 41202
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41089: LD_ADDR_EXP 60
41093: PUSH
41094: LD_EXP 60
41098: PPUSH
41099: LD_VAR 0 1
41103: PUSH
41104: LD_EXP 60
41108: PUSH
41109: LD_VAR 0 1
41113: ARRAY
41114: PUSH
41115: LD_INT 1
41117: PLUS
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PPUSH
41123: LD_VAR 0 9
41127: PPUSH
41128: CALL 53678 0 3
41132: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41133: LD_ADDR_EXP 59
41137: PUSH
41138: LD_EXP 59
41142: PPUSH
41143: LD_VAR 0 1
41147: PPUSH
41148: LD_EXP 59
41152: PUSH
41153: LD_VAR 0 1
41157: ARRAY
41158: PUSH
41159: LD_VAR 0 9
41163: DIFF
41164: PPUSH
41165: CALL_OW 1
41169: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41170: LD_VAR 0 3
41174: PPUSH
41175: LD_EXP 60
41179: PUSH
41180: LD_VAR 0 1
41184: ARRAY
41185: PUSH
41186: LD_EXP 60
41190: PUSH
41191: LD_VAR 0 1
41195: ARRAY
41196: ARRAY
41197: PPUSH
41198: CALL_OW 120
// end ; exit ;
41202: GO 41523
// end ; if tmp > 1 then
41204: LD_VAR 0 8
41208: PUSH
41209: LD_INT 1
41211: GREATER
41212: IFFALSE 41316
// for i = 2 to tmp do
41214: LD_ADDR_VAR 0 6
41218: PUSH
41219: DOUBLE
41220: LD_INT 2
41222: DEC
41223: ST_TO_ADDR
41224: LD_VAR 0 8
41228: PUSH
41229: FOR_TO
41230: IFFALSE 41314
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41232: LD_VAR 0 8
41236: PUSH
41237: LD_VAR 0 6
41241: ARRAY
41242: PPUSH
41243: CALL_OW 461
41247: PUSH
41248: LD_INT 6
41250: EQUAL
41251: IFFALSE 41312
// begin x := tmp [ i ] ;
41253: LD_ADDR_VAR 0 9
41257: PUSH
41258: LD_VAR 0 8
41262: PUSH
41263: LD_VAR 0 6
41267: ARRAY
41268: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41269: LD_ADDR_VAR 0 8
41273: PUSH
41274: LD_VAR 0 8
41278: PPUSH
41279: LD_VAR 0 6
41283: PPUSH
41284: CALL_OW 3
41288: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41289: LD_ADDR_VAR 0 8
41293: PUSH
41294: LD_VAR 0 8
41298: PPUSH
41299: LD_INT 1
41301: PPUSH
41302: LD_VAR 0 9
41306: PPUSH
41307: CALL_OW 2
41311: ST_TO_ADDR
// end ;
41312: GO 41229
41314: POP
41315: POP
// for i in tmp do
41316: LD_ADDR_VAR 0 6
41320: PUSH
41321: LD_VAR 0 8
41325: PUSH
41326: FOR_IN
41327: IFFALSE 41396
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41329: LD_VAR 0 6
41333: PPUSH
41334: CALL_OW 313
41338: PUSH
41339: LD_INT 6
41341: LESS
41342: PUSH
41343: LD_VAR 0 6
41347: PPUSH
41348: CALL_OW 266
41352: PUSH
41353: LD_INT 31
41355: PUSH
41356: LD_INT 32
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: IN
41363: NOT
41364: AND
41365: PUSH
41366: LD_VAR 0 6
41370: PPUSH
41371: CALL_OW 313
41375: PUSH
41376: LD_INT 0
41378: EQUAL
41379: OR
41380: IFFALSE 41394
// begin j := i ;
41382: LD_ADDR_VAR 0 7
41386: PUSH
41387: LD_VAR 0 6
41391: ST_TO_ADDR
// break ;
41392: GO 41396
// end ; end ;
41394: GO 41326
41396: POP
41397: POP
// if j then
41398: LD_VAR 0 7
41402: IFFALSE 41420
// ComEnterUnit ( unit , j ) else
41404: LD_VAR 0 3
41408: PPUSH
41409: LD_VAR 0 7
41413: PPUSH
41414: CALL_OW 120
41418: GO 41523
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41420: LD_ADDR_VAR 0 10
41424: PUSH
41425: LD_VAR 0 2
41429: PPUSH
41430: LD_INT 2
41432: PUSH
41433: LD_INT 30
41435: PUSH
41436: LD_INT 0
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 30
41445: PUSH
41446: LD_INT 1
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: LIST
41457: PPUSH
41458: CALL_OW 72
41462: ST_TO_ADDR
// if depot then
41463: LD_VAR 0 10
41467: IFFALSE 41523
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41469: LD_ADDR_VAR 0 10
41473: PUSH
41474: LD_VAR 0 10
41478: PPUSH
41479: LD_VAR 0 3
41483: PPUSH
41484: CALL_OW 74
41488: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41489: LD_VAR 0 3
41493: PPUSH
41494: LD_VAR 0 10
41498: PPUSH
41499: CALL_OW 296
41503: PUSH
41504: LD_INT 10
41506: GREATER
41507: IFFALSE 41523
// ComStandNearbyBuilding ( unit , depot ) ;
41509: LD_VAR 0 3
41513: PPUSH
41514: LD_VAR 0 10
41518: PPUSH
41519: CALL 50105 0 2
// end ; end ; end ;
41523: LD_VAR 0 5
41527: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41528: LD_INT 0
41530: PPUSH
41531: PPUSH
41532: PPUSH
41533: PPUSH
// if not mc_bases then
41534: LD_EXP 50
41538: NOT
41539: IFFALSE 41543
// exit ;
41541: GO 41782
// for i = 1 to mc_bases do
41543: LD_ADDR_VAR 0 2
41547: PUSH
41548: DOUBLE
41549: LD_INT 1
41551: DEC
41552: ST_TO_ADDR
41553: LD_EXP 50
41557: PUSH
41558: FOR_TO
41559: IFFALSE 41780
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41561: LD_ADDR_VAR 0 4
41565: PUSH
41566: LD_EXP 50
41570: PUSH
41571: LD_VAR 0 2
41575: ARRAY
41576: PPUSH
41577: LD_INT 21
41579: PUSH
41580: LD_INT 1
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PPUSH
41587: CALL_OW 72
41591: PUSH
41592: LD_EXP 79
41596: PUSH
41597: LD_VAR 0 2
41601: ARRAY
41602: UNION
41603: ST_TO_ADDR
// if not tmp then
41604: LD_VAR 0 4
41608: NOT
41609: IFFALSE 41613
// continue ;
41611: GO 41558
// for j in tmp do
41613: LD_ADDR_VAR 0 3
41617: PUSH
41618: LD_VAR 0 4
41622: PUSH
41623: FOR_IN
41624: IFFALSE 41776
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41626: LD_VAR 0 3
41630: PPUSH
41631: CALL_OW 110
41635: NOT
41636: PUSH
41637: LD_VAR 0 3
41641: PPUSH
41642: CALL_OW 314
41646: NOT
41647: AND
41648: PUSH
41649: LD_VAR 0 3
41653: PPUSH
41654: CALL_OW 311
41658: NOT
41659: AND
41660: PUSH
41661: LD_VAR 0 3
41665: PPUSH
41666: CALL_OW 310
41670: NOT
41671: AND
41672: PUSH
41673: LD_VAR 0 3
41677: PUSH
41678: LD_EXP 53
41682: PUSH
41683: LD_VAR 0 2
41687: ARRAY
41688: PUSH
41689: LD_INT 1
41691: ARRAY
41692: IN
41693: NOT
41694: AND
41695: PUSH
41696: LD_VAR 0 3
41700: PUSH
41701: LD_EXP 53
41705: PUSH
41706: LD_VAR 0 2
41710: ARRAY
41711: PUSH
41712: LD_INT 2
41714: ARRAY
41715: IN
41716: NOT
41717: AND
41718: PUSH
41719: LD_VAR 0 3
41723: PUSH
41724: LD_EXP 62
41728: PUSH
41729: LD_VAR 0 2
41733: ARRAY
41734: IN
41735: NOT
41736: AND
41737: IFFALSE 41774
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41739: LD_VAR 0 2
41743: PPUSH
41744: LD_EXP 50
41748: PUSH
41749: LD_VAR 0 2
41753: ARRAY
41754: PPUSH
41755: LD_VAR 0 3
41759: PPUSH
41760: LD_VAR 0 3
41764: PPUSH
41765: CALL_OW 257
41769: PPUSH
41770: CALL 40546 0 4
// end ;
41774: GO 41623
41776: POP
41777: POP
// end ;
41778: GO 41558
41780: POP
41781: POP
// end ;
41782: LD_VAR 0 1
41786: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41787: LD_INT 0
41789: PPUSH
41790: PPUSH
41791: PPUSH
41792: PPUSH
41793: PPUSH
41794: PPUSH
// if not mc_bases [ base ] then
41795: LD_EXP 50
41799: PUSH
41800: LD_VAR 0 1
41804: ARRAY
41805: NOT
41806: IFFALSE 41810
// exit ;
41808: GO 41992
// tmp := [ ] ;
41810: LD_ADDR_VAR 0 6
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41817: LD_ADDR_VAR 0 7
41821: PUSH
41822: LD_VAR 0 3
41826: PPUSH
41827: LD_INT 0
41829: PPUSH
41830: CALL_OW 517
41834: ST_TO_ADDR
// if not list then
41835: LD_VAR 0 7
41839: NOT
41840: IFFALSE 41844
// exit ;
41842: GO 41992
// for i = 1 to amount do
41844: LD_ADDR_VAR 0 5
41848: PUSH
41849: DOUBLE
41850: LD_INT 1
41852: DEC
41853: ST_TO_ADDR
41854: LD_VAR 0 2
41858: PUSH
41859: FOR_TO
41860: IFFALSE 41940
// begin x := rand ( 1 , list [ 1 ] ) ;
41862: LD_ADDR_VAR 0 8
41866: PUSH
41867: LD_INT 1
41869: PPUSH
41870: LD_VAR 0 7
41874: PUSH
41875: LD_INT 1
41877: ARRAY
41878: PPUSH
41879: CALL_OW 12
41883: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41884: LD_ADDR_VAR 0 6
41888: PUSH
41889: LD_VAR 0 6
41893: PPUSH
41894: LD_VAR 0 5
41898: PPUSH
41899: LD_VAR 0 7
41903: PUSH
41904: LD_INT 1
41906: ARRAY
41907: PUSH
41908: LD_VAR 0 8
41912: ARRAY
41913: PUSH
41914: LD_VAR 0 7
41918: PUSH
41919: LD_INT 2
41921: ARRAY
41922: PUSH
41923: LD_VAR 0 8
41927: ARRAY
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PPUSH
41933: CALL_OW 1
41937: ST_TO_ADDR
// end ;
41938: GO 41859
41940: POP
41941: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41942: LD_ADDR_EXP 63
41946: PUSH
41947: LD_EXP 63
41951: PPUSH
41952: LD_VAR 0 1
41956: PPUSH
41957: LD_VAR 0 6
41961: PPUSH
41962: CALL_OW 1
41966: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41967: LD_ADDR_EXP 65
41971: PUSH
41972: LD_EXP 65
41976: PPUSH
41977: LD_VAR 0 1
41981: PPUSH
41982: LD_VAR 0 3
41986: PPUSH
41987: CALL_OW 1
41991: ST_TO_ADDR
// end ;
41992: LD_VAR 0 4
41996: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41997: LD_INT 0
41999: PPUSH
// if not mc_bases [ base ] then
42000: LD_EXP 50
42004: PUSH
42005: LD_VAR 0 1
42009: ARRAY
42010: NOT
42011: IFFALSE 42015
// exit ;
42013: GO 42040
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42015: LD_ADDR_EXP 55
42019: PUSH
42020: LD_EXP 55
42024: PPUSH
42025: LD_VAR 0 1
42029: PPUSH
42030: LD_VAR 0 2
42034: PPUSH
42035: CALL_OW 1
42039: ST_TO_ADDR
// end ;
42040: LD_VAR 0 3
42044: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42045: LD_INT 0
42047: PPUSH
// if not mc_bases [ base ] then
42048: LD_EXP 50
42052: PUSH
42053: LD_VAR 0 1
42057: ARRAY
42058: NOT
42059: IFFALSE 42063
// exit ;
42061: GO 42100
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42063: LD_ADDR_EXP 55
42067: PUSH
42068: LD_EXP 55
42072: PPUSH
42073: LD_VAR 0 1
42077: PPUSH
42078: LD_EXP 55
42082: PUSH
42083: LD_VAR 0 1
42087: ARRAY
42088: PUSH
42089: LD_VAR 0 2
42093: UNION
42094: PPUSH
42095: CALL_OW 1
42099: ST_TO_ADDR
// end ;
42100: LD_VAR 0 3
42104: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42105: LD_INT 0
42107: PPUSH
// if not mc_bases [ base ] then
42108: LD_EXP 50
42112: PUSH
42113: LD_VAR 0 1
42117: ARRAY
42118: NOT
42119: IFFALSE 42123
// exit ;
42121: GO 42148
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42123: LD_ADDR_EXP 71
42127: PUSH
42128: LD_EXP 71
42132: PPUSH
42133: LD_VAR 0 1
42137: PPUSH
42138: LD_VAR 0 2
42142: PPUSH
42143: CALL_OW 1
42147: ST_TO_ADDR
// end ;
42148: LD_VAR 0 3
42152: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42153: LD_INT 0
42155: PPUSH
// if not mc_bases [ base ] then
42156: LD_EXP 50
42160: PUSH
42161: LD_VAR 0 1
42165: ARRAY
42166: NOT
42167: IFFALSE 42171
// exit ;
42169: GO 42208
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42171: LD_ADDR_EXP 71
42175: PUSH
42176: LD_EXP 71
42180: PPUSH
42181: LD_VAR 0 1
42185: PPUSH
42186: LD_EXP 71
42190: PUSH
42191: LD_VAR 0 1
42195: ARRAY
42196: PUSH
42197: LD_VAR 0 2
42201: ADD
42202: PPUSH
42203: CALL_OW 1
42207: ST_TO_ADDR
// end ;
42208: LD_VAR 0 3
42212: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42213: LD_INT 0
42215: PPUSH
// if not mc_bases [ base ] then
42216: LD_EXP 50
42220: PUSH
42221: LD_VAR 0 1
42225: ARRAY
42226: NOT
42227: IFFALSE 42231
// exit ;
42229: GO 42285
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42231: LD_ADDR_EXP 72
42235: PUSH
42236: LD_EXP 72
42240: PPUSH
42241: LD_VAR 0 1
42245: PPUSH
42246: LD_VAR 0 2
42250: PPUSH
42251: CALL_OW 1
42255: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42256: LD_ADDR_EXP 61
42260: PUSH
42261: LD_EXP 61
42265: PPUSH
42266: LD_VAR 0 1
42270: PPUSH
42271: LD_VAR 0 2
42275: PUSH
42276: LD_INT 0
42278: PLUS
42279: PPUSH
42280: CALL_OW 1
42284: ST_TO_ADDR
// end ;
42285: LD_VAR 0 3
42289: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42290: LD_INT 0
42292: PPUSH
// if not mc_bases [ base ] then
42293: LD_EXP 50
42297: PUSH
42298: LD_VAR 0 1
42302: ARRAY
42303: NOT
42304: IFFALSE 42308
// exit ;
42306: GO 42333
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42308: LD_ADDR_EXP 61
42312: PUSH
42313: LD_EXP 61
42317: PPUSH
42318: LD_VAR 0 1
42322: PPUSH
42323: LD_VAR 0 2
42327: PPUSH
42328: CALL_OW 1
42332: ST_TO_ADDR
// end ;
42333: LD_VAR 0 3
42337: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42338: LD_INT 0
42340: PPUSH
42341: PPUSH
42342: PPUSH
42343: PPUSH
// if not mc_bases [ base ] then
42344: LD_EXP 50
42348: PUSH
42349: LD_VAR 0 1
42353: ARRAY
42354: NOT
42355: IFFALSE 42359
// exit ;
42357: GO 42424
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42359: LD_ADDR_EXP 70
42363: PUSH
42364: LD_EXP 70
42368: PPUSH
42369: LD_VAR 0 1
42373: PUSH
42374: LD_EXP 70
42378: PUSH
42379: LD_VAR 0 1
42383: ARRAY
42384: PUSH
42385: LD_INT 1
42387: PLUS
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PPUSH
42393: LD_VAR 0 1
42397: PUSH
42398: LD_VAR 0 2
42402: PUSH
42403: LD_VAR 0 3
42407: PUSH
42408: LD_VAR 0 4
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: PPUSH
42419: CALL 53678 0 3
42423: ST_TO_ADDR
// end ;
42424: LD_VAR 0 5
42428: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42429: LD_INT 0
42431: PPUSH
// if not mc_bases [ base ] then
42432: LD_EXP 50
42436: PUSH
42437: LD_VAR 0 1
42441: ARRAY
42442: NOT
42443: IFFALSE 42447
// exit ;
42445: GO 42472
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42447: LD_ADDR_EXP 87
42451: PUSH
42452: LD_EXP 87
42456: PPUSH
42457: LD_VAR 0 1
42461: PPUSH
42462: LD_VAR 0 2
42466: PPUSH
42467: CALL_OW 1
42471: ST_TO_ADDR
// end ;
42472: LD_VAR 0 3
42476: RET
// export function MC_GetMinesField ( base ) ; begin
42477: LD_INT 0
42479: PPUSH
// result := mc_mines [ base ] ;
42480: LD_ADDR_VAR 0 2
42484: PUSH
42485: LD_EXP 63
42489: PUSH
42490: LD_VAR 0 1
42494: ARRAY
42495: ST_TO_ADDR
// end ;
42496: LD_VAR 0 2
42500: RET
// export function MC_GetProduceList ( base ) ; begin
42501: LD_INT 0
42503: PPUSH
// result := mc_produce [ base ] ;
42504: LD_ADDR_VAR 0 2
42508: PUSH
42509: LD_EXP 71
42513: PUSH
42514: LD_VAR 0 1
42518: ARRAY
42519: ST_TO_ADDR
// end ;
42520: LD_VAR 0 2
42524: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42525: LD_INT 0
42527: PPUSH
42528: PPUSH
// if not mc_bases then
42529: LD_EXP 50
42533: NOT
42534: IFFALSE 42538
// exit ;
42536: GO 42603
// if mc_bases [ base ] then
42538: LD_EXP 50
42542: PUSH
42543: LD_VAR 0 1
42547: ARRAY
42548: IFFALSE 42603
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42550: LD_ADDR_VAR 0 3
42554: PUSH
42555: LD_EXP 50
42559: PUSH
42560: LD_VAR 0 1
42564: ARRAY
42565: PPUSH
42566: LD_INT 30
42568: PUSH
42569: LD_VAR 0 2
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PPUSH
42578: CALL_OW 72
42582: ST_TO_ADDR
// if result then
42583: LD_VAR 0 3
42587: IFFALSE 42603
// result := result [ 1 ] ;
42589: LD_ADDR_VAR 0 3
42593: PUSH
42594: LD_VAR 0 3
42598: PUSH
42599: LD_INT 1
42601: ARRAY
42602: ST_TO_ADDR
// end ; end ;
42603: LD_VAR 0 3
42607: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42608: LD_INT 0
42610: PPUSH
42611: PPUSH
// if not mc_bases then
42612: LD_EXP 50
42616: NOT
42617: IFFALSE 42621
// exit ;
42619: GO 42666
// if mc_bases [ base ] then
42621: LD_EXP 50
42625: PUSH
42626: LD_VAR 0 1
42630: ARRAY
42631: IFFALSE 42666
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42633: LD_ADDR_VAR 0 3
42637: PUSH
42638: LD_EXP 50
42642: PUSH
42643: LD_VAR 0 1
42647: ARRAY
42648: PPUSH
42649: LD_INT 30
42651: PUSH
42652: LD_VAR 0 2
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PPUSH
42661: CALL_OW 72
42665: ST_TO_ADDR
// end ;
42666: LD_VAR 0 3
42670: RET
// export function MC_SetTame ( base , area ) ; begin
42671: LD_INT 0
42673: PPUSH
// if not mc_bases or not base then
42674: LD_EXP 50
42678: NOT
42679: PUSH
42680: LD_VAR 0 1
42684: NOT
42685: OR
42686: IFFALSE 42690
// exit ;
42688: GO 42715
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42690: LD_ADDR_EXP 78
42694: PUSH
42695: LD_EXP 78
42699: PPUSH
42700: LD_VAR 0 1
42704: PPUSH
42705: LD_VAR 0 2
42709: PPUSH
42710: CALL_OW 1
42714: ST_TO_ADDR
// end ;
42715: LD_VAR 0 3
42719: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42720: LD_INT 0
42722: PPUSH
42723: PPUSH
// if not mc_bases or not base then
42724: LD_EXP 50
42728: NOT
42729: PUSH
42730: LD_VAR 0 1
42734: NOT
42735: OR
42736: IFFALSE 42740
// exit ;
42738: GO 42842
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42740: LD_ADDR_VAR 0 4
42744: PUSH
42745: LD_EXP 50
42749: PUSH
42750: LD_VAR 0 1
42754: ARRAY
42755: PPUSH
42756: LD_INT 30
42758: PUSH
42759: LD_VAR 0 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PPUSH
42768: CALL_OW 72
42772: ST_TO_ADDR
// if not tmp then
42773: LD_VAR 0 4
42777: NOT
42778: IFFALSE 42782
// exit ;
42780: GO 42842
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42782: LD_ADDR_EXP 82
42786: PUSH
42787: LD_EXP 82
42791: PPUSH
42792: LD_VAR 0 1
42796: PPUSH
42797: LD_EXP 82
42801: PUSH
42802: LD_VAR 0 1
42806: ARRAY
42807: PPUSH
42808: LD_EXP 82
42812: PUSH
42813: LD_VAR 0 1
42817: ARRAY
42818: PUSH
42819: LD_INT 1
42821: PLUS
42822: PPUSH
42823: LD_VAR 0 4
42827: PUSH
42828: LD_INT 1
42830: ARRAY
42831: PPUSH
42832: CALL_OW 2
42836: PPUSH
42837: CALL_OW 1
42841: ST_TO_ADDR
// end ;
42842: LD_VAR 0 3
42846: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42847: LD_INT 0
42849: PPUSH
42850: PPUSH
// if not mc_bases or not base or not kinds then
42851: LD_EXP 50
42855: NOT
42856: PUSH
42857: LD_VAR 0 1
42861: NOT
42862: OR
42863: PUSH
42864: LD_VAR 0 2
42868: NOT
42869: OR
42870: IFFALSE 42874
// exit ;
42872: GO 42935
// for i in kinds do
42874: LD_ADDR_VAR 0 4
42878: PUSH
42879: LD_VAR 0 2
42883: PUSH
42884: FOR_IN
42885: IFFALSE 42933
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42887: LD_ADDR_EXP 84
42891: PUSH
42892: LD_EXP 84
42896: PPUSH
42897: LD_VAR 0 1
42901: PUSH
42902: LD_EXP 84
42906: PUSH
42907: LD_VAR 0 1
42911: ARRAY
42912: PUSH
42913: LD_INT 1
42915: PLUS
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PPUSH
42921: LD_VAR 0 4
42925: PPUSH
42926: CALL 53678 0 3
42930: ST_TO_ADDR
42931: GO 42884
42933: POP
42934: POP
// end ;
42935: LD_VAR 0 3
42939: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42940: LD_INT 0
42942: PPUSH
// if not mc_bases or not base or not areas then
42943: LD_EXP 50
42947: NOT
42948: PUSH
42949: LD_VAR 0 1
42953: NOT
42954: OR
42955: PUSH
42956: LD_VAR 0 2
42960: NOT
42961: OR
42962: IFFALSE 42966
// exit ;
42964: GO 42991
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42966: LD_ADDR_EXP 68
42970: PUSH
42971: LD_EXP 68
42975: PPUSH
42976: LD_VAR 0 1
42980: PPUSH
42981: LD_VAR 0 2
42985: PPUSH
42986: CALL_OW 1
42990: ST_TO_ADDR
// end ;
42991: LD_VAR 0 3
42995: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42996: LD_INT 0
42998: PPUSH
// if not mc_bases or not base or not teleports_exit then
42999: LD_EXP 50
43003: NOT
43004: PUSH
43005: LD_VAR 0 1
43009: NOT
43010: OR
43011: PUSH
43012: LD_VAR 0 2
43016: NOT
43017: OR
43018: IFFALSE 43022
// exit ;
43020: GO 43047
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43022: LD_ADDR_EXP 85
43026: PUSH
43027: LD_EXP 85
43031: PPUSH
43032: LD_VAR 0 1
43036: PPUSH
43037: LD_VAR 0 2
43041: PPUSH
43042: CALL_OW 1
43046: ST_TO_ADDR
// end ;
43047: LD_VAR 0 3
43051: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43052: LD_INT 0
43054: PPUSH
43055: PPUSH
43056: PPUSH
// if not mc_bases or not base or not ext_list then
43057: LD_EXP 50
43061: NOT
43062: PUSH
43063: LD_VAR 0 1
43067: NOT
43068: OR
43069: PUSH
43070: LD_VAR 0 5
43074: NOT
43075: OR
43076: IFFALSE 43080
// exit ;
43078: GO 43253
// tmp := GetFacExtXYD ( x , y , d ) ;
43080: LD_ADDR_VAR 0 8
43084: PUSH
43085: LD_VAR 0 2
43089: PPUSH
43090: LD_VAR 0 3
43094: PPUSH
43095: LD_VAR 0 4
43099: PPUSH
43100: CALL 83556 0 3
43104: ST_TO_ADDR
// if not tmp then
43105: LD_VAR 0 8
43109: NOT
43110: IFFALSE 43114
// exit ;
43112: GO 43253
// for i in tmp do
43114: LD_ADDR_VAR 0 7
43118: PUSH
43119: LD_VAR 0 8
43123: PUSH
43124: FOR_IN
43125: IFFALSE 43251
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43127: LD_ADDR_EXP 55
43131: PUSH
43132: LD_EXP 55
43136: PPUSH
43137: LD_VAR 0 1
43141: PPUSH
43142: LD_EXP 55
43146: PUSH
43147: LD_VAR 0 1
43151: ARRAY
43152: PPUSH
43153: LD_EXP 55
43157: PUSH
43158: LD_VAR 0 1
43162: ARRAY
43163: PUSH
43164: LD_INT 1
43166: PLUS
43167: PPUSH
43168: LD_VAR 0 5
43172: PUSH
43173: LD_INT 1
43175: ARRAY
43176: PUSH
43177: LD_VAR 0 7
43181: PUSH
43182: LD_INT 1
43184: ARRAY
43185: PUSH
43186: LD_VAR 0 7
43190: PUSH
43191: LD_INT 2
43193: ARRAY
43194: PUSH
43195: LD_VAR 0 7
43199: PUSH
43200: LD_INT 3
43202: ARRAY
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: PPUSH
43210: CALL_OW 2
43214: PPUSH
43215: CALL_OW 1
43219: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43220: LD_ADDR_VAR 0 5
43224: PUSH
43225: LD_VAR 0 5
43229: PPUSH
43230: LD_INT 1
43232: PPUSH
43233: CALL_OW 3
43237: ST_TO_ADDR
// if not ext_list then
43238: LD_VAR 0 5
43242: NOT
43243: IFFALSE 43249
// exit ;
43245: POP
43246: POP
43247: GO 43253
// end ;
43249: GO 43124
43251: POP
43252: POP
// end ;
43253: LD_VAR 0 6
43257: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43258: LD_INT 0
43260: PPUSH
// if not mc_bases or not base or not weapon_list then
43261: LD_EXP 50
43265: NOT
43266: PUSH
43267: LD_VAR 0 1
43271: NOT
43272: OR
43273: PUSH
43274: LD_VAR 0 2
43278: NOT
43279: OR
43280: IFFALSE 43284
// exit ;
43282: GO 43309
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43284: LD_ADDR_EXP 89
43288: PUSH
43289: LD_EXP 89
43293: PPUSH
43294: LD_VAR 0 1
43298: PPUSH
43299: LD_VAR 0 2
43303: PPUSH
43304: CALL_OW 1
43308: ST_TO_ADDR
// end ;
43309: LD_VAR 0 3
43313: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43314: LD_INT 0
43316: PPUSH
// if not mc_bases or not base or not tech_list then
43317: LD_EXP 50
43321: NOT
43322: PUSH
43323: LD_VAR 0 1
43327: NOT
43328: OR
43329: PUSH
43330: LD_VAR 0 2
43334: NOT
43335: OR
43336: IFFALSE 43340
// exit ;
43338: GO 43365
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43340: LD_ADDR_EXP 77
43344: PUSH
43345: LD_EXP 77
43349: PPUSH
43350: LD_VAR 0 1
43354: PPUSH
43355: LD_VAR 0 2
43359: PPUSH
43360: CALL_OW 1
43364: ST_TO_ADDR
// end ;
43365: LD_VAR 0 3
43369: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43370: LD_INT 0
43372: PPUSH
// if not mc_bases or not parking_area or not base then
43373: LD_EXP 50
43377: NOT
43378: PUSH
43379: LD_VAR 0 2
43383: NOT
43384: OR
43385: PUSH
43386: LD_VAR 0 1
43390: NOT
43391: OR
43392: IFFALSE 43396
// exit ;
43394: GO 43421
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43396: LD_ADDR_EXP 74
43400: PUSH
43401: LD_EXP 74
43405: PPUSH
43406: LD_VAR 0 1
43410: PPUSH
43411: LD_VAR 0 2
43415: PPUSH
43416: CALL_OW 1
43420: ST_TO_ADDR
// end ;
43421: LD_VAR 0 3
43425: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43426: LD_INT 0
43428: PPUSH
// if not mc_bases or not base or not scan_area then
43429: LD_EXP 50
43433: NOT
43434: PUSH
43435: LD_VAR 0 1
43439: NOT
43440: OR
43441: PUSH
43442: LD_VAR 0 2
43446: NOT
43447: OR
43448: IFFALSE 43452
// exit ;
43450: GO 43477
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43452: LD_ADDR_EXP 75
43456: PUSH
43457: LD_EXP 75
43461: PPUSH
43462: LD_VAR 0 1
43466: PPUSH
43467: LD_VAR 0 2
43471: PPUSH
43472: CALL_OW 1
43476: ST_TO_ADDR
// end ;
43477: LD_VAR 0 3
43481: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43482: LD_INT 0
43484: PPUSH
43485: PPUSH
// if not mc_bases or not base then
43486: LD_EXP 50
43490: NOT
43491: PUSH
43492: LD_VAR 0 1
43496: NOT
43497: OR
43498: IFFALSE 43502
// exit ;
43500: GO 43566
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43502: LD_ADDR_VAR 0 3
43506: PUSH
43507: LD_INT 1
43509: PUSH
43510: LD_INT 2
43512: PUSH
43513: LD_INT 3
43515: PUSH
43516: LD_INT 4
43518: PUSH
43519: LD_INT 11
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43529: LD_ADDR_EXP 77
43533: PUSH
43534: LD_EXP 77
43538: PPUSH
43539: LD_VAR 0 1
43543: PPUSH
43544: LD_EXP 77
43548: PUSH
43549: LD_VAR 0 1
43553: ARRAY
43554: PUSH
43555: LD_VAR 0 3
43559: DIFF
43560: PPUSH
43561: CALL_OW 1
43565: ST_TO_ADDR
// end ;
43566: LD_VAR 0 2
43570: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43571: LD_INT 0
43573: PPUSH
// result := mc_vehicles [ base ] ;
43574: LD_ADDR_VAR 0 3
43578: PUSH
43579: LD_EXP 69
43583: PUSH
43584: LD_VAR 0 1
43588: ARRAY
43589: ST_TO_ADDR
// if onlyCombat then
43590: LD_VAR 0 2
43594: IFFALSE 43766
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43596: LD_ADDR_VAR 0 3
43600: PUSH
43601: LD_VAR 0 3
43605: PUSH
43606: LD_VAR 0 3
43610: PPUSH
43611: LD_INT 2
43613: PUSH
43614: LD_INT 34
43616: PUSH
43617: LD_INT 12
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 34
43626: PUSH
43627: LD_INT 51
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 34
43636: PUSH
43637: LD_INT 89
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 34
43646: PUSH
43647: LD_INT 32
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 34
43656: PUSH
43657: LD_INT 13
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 34
43666: PUSH
43667: LD_INT 52
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 34
43676: PUSH
43677: LD_INT 88
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 34
43686: PUSH
43687: LD_INT 14
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 34
43696: PUSH
43697: LD_INT 53
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 34
43706: PUSH
43707: LD_INT 98
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 34
43716: PUSH
43717: LD_INT 31
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: LD_INT 34
43726: PUSH
43727: LD_INT 48
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 34
43736: PUSH
43737: LD_INT 8
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: LIST
43753: LIST
43754: LIST
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: PPUSH
43760: CALL_OW 72
43764: DIFF
43765: ST_TO_ADDR
// end ; end_of_file
43766: LD_VAR 0 3
43770: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43771: LD_INT 0
43773: PPUSH
43774: PPUSH
43775: PPUSH
// if not mc_bases or not skirmish then
43776: LD_EXP 50
43780: NOT
43781: PUSH
43782: LD_EXP 48
43786: NOT
43787: OR
43788: IFFALSE 43792
// exit ;
43790: GO 43957
// for i = 1 to mc_bases do
43792: LD_ADDR_VAR 0 4
43796: PUSH
43797: DOUBLE
43798: LD_INT 1
43800: DEC
43801: ST_TO_ADDR
43802: LD_EXP 50
43806: PUSH
43807: FOR_TO
43808: IFFALSE 43955
// begin if sci in mc_bases [ i ] then
43810: LD_VAR 0 2
43814: PUSH
43815: LD_EXP 50
43819: PUSH
43820: LD_VAR 0 4
43824: ARRAY
43825: IN
43826: IFFALSE 43953
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43828: LD_ADDR_EXP 79
43832: PUSH
43833: LD_EXP 79
43837: PPUSH
43838: LD_VAR 0 4
43842: PUSH
43843: LD_EXP 79
43847: PUSH
43848: LD_VAR 0 4
43852: ARRAY
43853: PUSH
43854: LD_INT 1
43856: PLUS
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PPUSH
43862: LD_VAR 0 1
43866: PPUSH
43867: CALL 53678 0 3
43871: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43872: LD_ADDR_VAR 0 5
43876: PUSH
43877: LD_EXP 50
43881: PUSH
43882: LD_VAR 0 4
43886: ARRAY
43887: PPUSH
43888: LD_INT 2
43890: PUSH
43891: LD_INT 30
43893: PUSH
43894: LD_INT 0
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 30
43903: PUSH
43904: LD_INT 1
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: LIST
43915: PPUSH
43916: CALL_OW 72
43920: PPUSH
43921: LD_VAR 0 1
43925: PPUSH
43926: CALL_OW 74
43930: ST_TO_ADDR
// if tmp then
43931: LD_VAR 0 5
43935: IFFALSE 43951
// ComStandNearbyBuilding ( ape , tmp ) ;
43937: LD_VAR 0 1
43941: PPUSH
43942: LD_VAR 0 5
43946: PPUSH
43947: CALL 50105 0 2
// break ;
43951: GO 43955
// end ; end ;
43953: GO 43807
43955: POP
43956: POP
// end ;
43957: LD_VAR 0 3
43961: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43962: LD_INT 0
43964: PPUSH
43965: PPUSH
43966: PPUSH
// if not mc_bases or not skirmish then
43967: LD_EXP 50
43971: NOT
43972: PUSH
43973: LD_EXP 48
43977: NOT
43978: OR
43979: IFFALSE 43983
// exit ;
43981: GO 44072
// for i = 1 to mc_bases do
43983: LD_ADDR_VAR 0 4
43987: PUSH
43988: DOUBLE
43989: LD_INT 1
43991: DEC
43992: ST_TO_ADDR
43993: LD_EXP 50
43997: PUSH
43998: FOR_TO
43999: IFFALSE 44070
// begin if building in mc_busy_turret_list [ i ] then
44001: LD_VAR 0 1
44005: PUSH
44006: LD_EXP 60
44010: PUSH
44011: LD_VAR 0 4
44015: ARRAY
44016: IN
44017: IFFALSE 44068
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44019: LD_ADDR_VAR 0 5
44023: PUSH
44024: LD_EXP 60
44028: PUSH
44029: LD_VAR 0 4
44033: ARRAY
44034: PUSH
44035: LD_VAR 0 1
44039: DIFF
44040: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44041: LD_ADDR_EXP 60
44045: PUSH
44046: LD_EXP 60
44050: PPUSH
44051: LD_VAR 0 4
44055: PPUSH
44056: LD_VAR 0 5
44060: PPUSH
44061: CALL_OW 1
44065: ST_TO_ADDR
// break ;
44066: GO 44070
// end ; end ;
44068: GO 43998
44070: POP
44071: POP
// end ;
44072: LD_VAR 0 3
44076: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44077: LD_INT 0
44079: PPUSH
44080: PPUSH
44081: PPUSH
// if not mc_bases or not skirmish then
44082: LD_EXP 50
44086: NOT
44087: PUSH
44088: LD_EXP 48
44092: NOT
44093: OR
44094: IFFALSE 44098
// exit ;
44096: GO 44297
// for i = 1 to mc_bases do
44098: LD_ADDR_VAR 0 5
44102: PUSH
44103: DOUBLE
44104: LD_INT 1
44106: DEC
44107: ST_TO_ADDR
44108: LD_EXP 50
44112: PUSH
44113: FOR_TO
44114: IFFALSE 44295
// if building in mc_bases [ i ] then
44116: LD_VAR 0 1
44120: PUSH
44121: LD_EXP 50
44125: PUSH
44126: LD_VAR 0 5
44130: ARRAY
44131: IN
44132: IFFALSE 44293
// begin tmp := mc_bases [ i ] diff building ;
44134: LD_ADDR_VAR 0 6
44138: PUSH
44139: LD_EXP 50
44143: PUSH
44144: LD_VAR 0 5
44148: ARRAY
44149: PUSH
44150: LD_VAR 0 1
44154: DIFF
44155: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44156: LD_ADDR_EXP 50
44160: PUSH
44161: LD_EXP 50
44165: PPUSH
44166: LD_VAR 0 5
44170: PPUSH
44171: LD_VAR 0 6
44175: PPUSH
44176: CALL_OW 1
44180: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44181: LD_VAR 0 1
44185: PUSH
44186: LD_EXP 58
44190: PUSH
44191: LD_VAR 0 5
44195: ARRAY
44196: IN
44197: IFFALSE 44236
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44199: LD_ADDR_EXP 58
44203: PUSH
44204: LD_EXP 58
44208: PPUSH
44209: LD_VAR 0 5
44213: PPUSH
44214: LD_EXP 58
44218: PUSH
44219: LD_VAR 0 5
44223: ARRAY
44224: PUSH
44225: LD_VAR 0 1
44229: DIFF
44230: PPUSH
44231: CALL_OW 1
44235: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44236: LD_VAR 0 1
44240: PUSH
44241: LD_EXP 59
44245: PUSH
44246: LD_VAR 0 5
44250: ARRAY
44251: IN
44252: IFFALSE 44291
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44254: LD_ADDR_EXP 59
44258: PUSH
44259: LD_EXP 59
44263: PPUSH
44264: LD_VAR 0 5
44268: PPUSH
44269: LD_EXP 59
44273: PUSH
44274: LD_VAR 0 5
44278: ARRAY
44279: PUSH
44280: LD_VAR 0 1
44284: DIFF
44285: PPUSH
44286: CALL_OW 1
44290: ST_TO_ADDR
// break ;
44291: GO 44295
// end ;
44293: GO 44113
44295: POP
44296: POP
// end ;
44297: LD_VAR 0 4
44301: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44302: LD_INT 0
44304: PPUSH
44305: PPUSH
44306: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44307: LD_EXP 50
44311: NOT
44312: PUSH
44313: LD_EXP 48
44317: NOT
44318: OR
44319: PUSH
44320: LD_VAR 0 3
44324: PUSH
44325: LD_EXP 76
44329: IN
44330: NOT
44331: OR
44332: IFFALSE 44336
// exit ;
44334: GO 44459
// for i = 1 to mc_vehicles do
44336: LD_ADDR_VAR 0 6
44340: PUSH
44341: DOUBLE
44342: LD_INT 1
44344: DEC
44345: ST_TO_ADDR
44346: LD_EXP 69
44350: PUSH
44351: FOR_TO
44352: IFFALSE 44457
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44354: LD_VAR 0 2
44358: PUSH
44359: LD_EXP 69
44363: PUSH
44364: LD_VAR 0 6
44368: ARRAY
44369: IN
44370: PUSH
44371: LD_VAR 0 1
44375: PUSH
44376: LD_EXP 69
44380: PUSH
44381: LD_VAR 0 6
44385: ARRAY
44386: IN
44387: OR
44388: IFFALSE 44455
// begin tmp := mc_vehicles [ i ] diff old ;
44390: LD_ADDR_VAR 0 7
44394: PUSH
44395: LD_EXP 69
44399: PUSH
44400: LD_VAR 0 6
44404: ARRAY
44405: PUSH
44406: LD_VAR 0 2
44410: DIFF
44411: ST_TO_ADDR
// tmp := tmp diff new ;
44412: LD_ADDR_VAR 0 7
44416: PUSH
44417: LD_VAR 0 7
44421: PUSH
44422: LD_VAR 0 1
44426: DIFF
44427: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44428: LD_ADDR_EXP 69
44432: PUSH
44433: LD_EXP 69
44437: PPUSH
44438: LD_VAR 0 6
44442: PPUSH
44443: LD_VAR 0 7
44447: PPUSH
44448: CALL_OW 1
44452: ST_TO_ADDR
// break ;
44453: GO 44457
// end ;
44455: GO 44351
44457: POP
44458: POP
// end ;
44459: LD_VAR 0 5
44463: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44464: LD_INT 0
44466: PPUSH
44467: PPUSH
44468: PPUSH
44469: PPUSH
// if not mc_bases or not skirmish then
44470: LD_EXP 50
44474: NOT
44475: PUSH
44476: LD_EXP 48
44480: NOT
44481: OR
44482: IFFALSE 44486
// exit ;
44484: GO 44868
// side := GetSide ( vehicle ) ;
44486: LD_ADDR_VAR 0 5
44490: PUSH
44491: LD_VAR 0 1
44495: PPUSH
44496: CALL_OW 255
44500: ST_TO_ADDR
// for i = 1 to mc_bases do
44501: LD_ADDR_VAR 0 4
44505: PUSH
44506: DOUBLE
44507: LD_INT 1
44509: DEC
44510: ST_TO_ADDR
44511: LD_EXP 50
44515: PUSH
44516: FOR_TO
44517: IFFALSE 44866
// begin if factory in mc_bases [ i ] then
44519: LD_VAR 0 2
44523: PUSH
44524: LD_EXP 50
44528: PUSH
44529: LD_VAR 0 4
44533: ARRAY
44534: IN
44535: IFFALSE 44864
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44537: LD_EXP 72
44541: PUSH
44542: LD_VAR 0 4
44546: ARRAY
44547: PUSH
44548: LD_EXP 61
44552: PUSH
44553: LD_VAR 0 4
44557: ARRAY
44558: LESS
44559: PUSH
44560: LD_VAR 0 1
44564: PPUSH
44565: CALL_OW 264
44569: PUSH
44570: LD_INT 31
44572: PUSH
44573: LD_INT 32
44575: PUSH
44576: LD_INT 51
44578: PUSH
44579: LD_INT 89
44581: PUSH
44582: LD_INT 12
44584: PUSH
44585: LD_INT 30
44587: PUSH
44588: LD_INT 98
44590: PUSH
44591: LD_INT 11
44593: PUSH
44594: LD_INT 53
44596: PUSH
44597: LD_INT 14
44599: PUSH
44600: LD_INT 91
44602: PUSH
44603: LD_INT 29
44605: PUSH
44606: LD_INT 99
44608: PUSH
44609: LD_INT 13
44611: PUSH
44612: LD_INT 52
44614: PUSH
44615: LD_INT 88
44617: PUSH
44618: LD_INT 48
44620: PUSH
44621: LD_INT 8
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: LIST
44637: LIST
44638: LIST
44639: LIST
44640: LIST
44641: LIST
44642: LIST
44643: IN
44644: NOT
44645: AND
44646: IFFALSE 44694
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44648: LD_ADDR_EXP 72
44652: PUSH
44653: LD_EXP 72
44657: PPUSH
44658: LD_VAR 0 4
44662: PUSH
44663: LD_EXP 72
44667: PUSH
44668: LD_VAR 0 4
44672: ARRAY
44673: PUSH
44674: LD_INT 1
44676: PLUS
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: PPUSH
44682: LD_VAR 0 1
44686: PPUSH
44687: CALL 53678 0 3
44691: ST_TO_ADDR
44692: GO 44738
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44694: LD_ADDR_EXP 69
44698: PUSH
44699: LD_EXP 69
44703: PPUSH
44704: LD_VAR 0 4
44708: PUSH
44709: LD_EXP 69
44713: PUSH
44714: LD_VAR 0 4
44718: ARRAY
44719: PUSH
44720: LD_INT 1
44722: PLUS
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PPUSH
44728: LD_VAR 0 1
44732: PPUSH
44733: CALL 53678 0 3
44737: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44738: LD_VAR 0 1
44742: PPUSH
44743: CALL_OW 263
44747: PUSH
44748: LD_INT 2
44750: EQUAL
44751: IFFALSE 44780
// begin repeat wait ( 0 0$3 ) ;
44753: LD_INT 105
44755: PPUSH
44756: CALL_OW 67
// Connect ( vehicle ) ;
44760: LD_VAR 0 1
44764: PPUSH
44765: CALL 56647 0 1
// until IsControledBy ( vehicle ) ;
44769: LD_VAR 0 1
44773: PPUSH
44774: CALL_OW 312
44778: IFFALSE 44753
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44780: LD_VAR 0 1
44784: PPUSH
44785: LD_EXP 74
44789: PUSH
44790: LD_VAR 0 4
44794: ARRAY
44795: PPUSH
44796: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44800: LD_VAR 0 1
44804: PPUSH
44805: CALL_OW 263
44809: PUSH
44810: LD_INT 1
44812: NONEQUAL
44813: IFFALSE 44817
// break ;
44815: GO 44866
// repeat wait ( 0 0$1 ) ;
44817: LD_INT 35
44819: PPUSH
44820: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44824: LD_VAR 0 1
44828: PPUSH
44829: LD_EXP 74
44833: PUSH
44834: LD_VAR 0 4
44838: ARRAY
44839: PPUSH
44840: CALL_OW 308
44844: IFFALSE 44817
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44846: LD_VAR 0 1
44850: PPUSH
44851: CALL_OW 311
44855: PPUSH
44856: CALL_OW 121
// exit ;
44860: POP
44861: POP
44862: GO 44868
// end ; end ;
44864: GO 44516
44866: POP
44867: POP
// end ;
44868: LD_VAR 0 3
44872: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44873: LD_INT 0
44875: PPUSH
44876: PPUSH
44877: PPUSH
44878: PPUSH
// if not mc_bases or not skirmish then
44879: LD_EXP 50
44883: NOT
44884: PUSH
44885: LD_EXP 48
44889: NOT
44890: OR
44891: IFFALSE 44895
// exit ;
44893: GO 45248
// repeat wait ( 0 0$1 ) ;
44895: LD_INT 35
44897: PPUSH
44898: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44902: LD_VAR 0 2
44906: PPUSH
44907: LD_VAR 0 3
44911: PPUSH
44912: CALL_OW 284
44916: IFFALSE 44895
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44918: LD_VAR 0 2
44922: PPUSH
44923: LD_VAR 0 3
44927: PPUSH
44928: CALL_OW 283
44932: PUSH
44933: LD_INT 4
44935: EQUAL
44936: IFFALSE 44940
// exit ;
44938: GO 45248
// for i = 1 to mc_bases do
44940: LD_ADDR_VAR 0 7
44944: PUSH
44945: DOUBLE
44946: LD_INT 1
44948: DEC
44949: ST_TO_ADDR
44950: LD_EXP 50
44954: PUSH
44955: FOR_TO
44956: IFFALSE 45246
// begin if mc_crates_area [ i ] then
44958: LD_EXP 68
44962: PUSH
44963: LD_VAR 0 7
44967: ARRAY
44968: IFFALSE 45079
// for j in mc_crates_area [ i ] do
44970: LD_ADDR_VAR 0 8
44974: PUSH
44975: LD_EXP 68
44979: PUSH
44980: LD_VAR 0 7
44984: ARRAY
44985: PUSH
44986: FOR_IN
44987: IFFALSE 45077
// if InArea ( x , y , j ) then
44989: LD_VAR 0 2
44993: PPUSH
44994: LD_VAR 0 3
44998: PPUSH
44999: LD_VAR 0 8
45003: PPUSH
45004: CALL_OW 309
45008: IFFALSE 45075
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45010: LD_ADDR_EXP 66
45014: PUSH
45015: LD_EXP 66
45019: PPUSH
45020: LD_VAR 0 7
45024: PUSH
45025: LD_EXP 66
45029: PUSH
45030: LD_VAR 0 7
45034: ARRAY
45035: PUSH
45036: LD_INT 1
45038: PLUS
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PPUSH
45044: LD_VAR 0 4
45048: PUSH
45049: LD_VAR 0 2
45053: PUSH
45054: LD_VAR 0 3
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: LIST
45063: PPUSH
45064: CALL 53678 0 3
45068: ST_TO_ADDR
// exit ;
45069: POP
45070: POP
45071: POP
45072: POP
45073: GO 45248
// end ;
45075: GO 44986
45077: POP
45078: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45079: LD_ADDR_VAR 0 9
45083: PUSH
45084: LD_EXP 50
45088: PUSH
45089: LD_VAR 0 7
45093: ARRAY
45094: PPUSH
45095: LD_INT 2
45097: PUSH
45098: LD_INT 30
45100: PUSH
45101: LD_INT 0
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: PUSH
45108: LD_INT 30
45110: PUSH
45111: LD_INT 1
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: LIST
45122: PPUSH
45123: CALL_OW 72
45127: ST_TO_ADDR
// if not depot then
45128: LD_VAR 0 9
45132: NOT
45133: IFFALSE 45137
// continue ;
45135: GO 44955
// for j in depot do
45137: LD_ADDR_VAR 0 8
45141: PUSH
45142: LD_VAR 0 9
45146: PUSH
45147: FOR_IN
45148: IFFALSE 45242
// if GetDistUnitXY ( j , x , y ) < 30 then
45150: LD_VAR 0 8
45154: PPUSH
45155: LD_VAR 0 2
45159: PPUSH
45160: LD_VAR 0 3
45164: PPUSH
45165: CALL_OW 297
45169: PUSH
45170: LD_INT 30
45172: LESS
45173: IFFALSE 45240
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45175: LD_ADDR_EXP 66
45179: PUSH
45180: LD_EXP 66
45184: PPUSH
45185: LD_VAR 0 7
45189: PUSH
45190: LD_EXP 66
45194: PUSH
45195: LD_VAR 0 7
45199: ARRAY
45200: PUSH
45201: LD_INT 1
45203: PLUS
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PPUSH
45209: LD_VAR 0 4
45213: PUSH
45214: LD_VAR 0 2
45218: PUSH
45219: LD_VAR 0 3
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: LIST
45228: PPUSH
45229: CALL 53678 0 3
45233: ST_TO_ADDR
// exit ;
45234: POP
45235: POP
45236: POP
45237: POP
45238: GO 45248
// end ;
45240: GO 45147
45242: POP
45243: POP
// end ;
45244: GO 44955
45246: POP
45247: POP
// end ;
45248: LD_VAR 0 6
45252: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45253: LD_INT 0
45255: PPUSH
45256: PPUSH
45257: PPUSH
45258: PPUSH
// if not mc_bases or not skirmish then
45259: LD_EXP 50
45263: NOT
45264: PUSH
45265: LD_EXP 48
45269: NOT
45270: OR
45271: IFFALSE 45275
// exit ;
45273: GO 45552
// side := GetSide ( lab ) ;
45275: LD_ADDR_VAR 0 4
45279: PUSH
45280: LD_VAR 0 2
45284: PPUSH
45285: CALL_OW 255
45289: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45290: LD_VAR 0 4
45294: PUSH
45295: LD_EXP 76
45299: IN
45300: NOT
45301: PUSH
45302: LD_EXP 77
45306: NOT
45307: OR
45308: PUSH
45309: LD_EXP 50
45313: NOT
45314: OR
45315: IFFALSE 45319
// exit ;
45317: GO 45552
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45319: LD_ADDR_EXP 77
45323: PUSH
45324: LD_EXP 77
45328: PPUSH
45329: LD_VAR 0 4
45333: PPUSH
45334: LD_EXP 77
45338: PUSH
45339: LD_VAR 0 4
45343: ARRAY
45344: PUSH
45345: LD_VAR 0 1
45349: DIFF
45350: PPUSH
45351: CALL_OW 1
45355: ST_TO_ADDR
// for i = 1 to mc_bases do
45356: LD_ADDR_VAR 0 5
45360: PUSH
45361: DOUBLE
45362: LD_INT 1
45364: DEC
45365: ST_TO_ADDR
45366: LD_EXP 50
45370: PUSH
45371: FOR_TO
45372: IFFALSE 45550
// begin if lab in mc_bases [ i ] then
45374: LD_VAR 0 2
45378: PUSH
45379: LD_EXP 50
45383: PUSH
45384: LD_VAR 0 5
45388: ARRAY
45389: IN
45390: IFFALSE 45548
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45392: LD_VAR 0 1
45396: PUSH
45397: LD_INT 11
45399: PUSH
45400: LD_INT 4
45402: PUSH
45403: LD_INT 3
45405: PUSH
45406: LD_INT 2
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: IN
45415: PUSH
45416: LD_EXP 80
45420: PUSH
45421: LD_VAR 0 5
45425: ARRAY
45426: AND
45427: IFFALSE 45548
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45429: LD_ADDR_VAR 0 6
45433: PUSH
45434: LD_EXP 80
45438: PUSH
45439: LD_VAR 0 5
45443: ARRAY
45444: PUSH
45445: LD_INT 1
45447: ARRAY
45448: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45449: LD_ADDR_EXP 80
45453: PUSH
45454: LD_EXP 80
45458: PPUSH
45459: LD_VAR 0 5
45463: PPUSH
45464: EMPTY
45465: PPUSH
45466: CALL_OW 1
45470: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45471: LD_VAR 0 6
45475: PPUSH
45476: LD_INT 0
45478: PPUSH
45479: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45483: LD_VAR 0 6
45487: PPUSH
45488: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45492: LD_ADDR_EXP 79
45496: PUSH
45497: LD_EXP 79
45501: PPUSH
45502: LD_VAR 0 5
45506: PPUSH
45507: LD_EXP 79
45511: PUSH
45512: LD_VAR 0 5
45516: ARRAY
45517: PPUSH
45518: LD_INT 1
45520: PPUSH
45521: LD_VAR 0 6
45525: PPUSH
45526: CALL_OW 2
45530: PPUSH
45531: CALL_OW 1
45535: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45536: LD_VAR 0 5
45540: PPUSH
45541: LD_INT 112
45543: PPUSH
45544: CALL 22091 0 2
// end ; end ; end ;
45548: GO 45371
45550: POP
45551: POP
// end ;
45552: LD_VAR 0 3
45556: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45557: LD_INT 0
45559: PPUSH
45560: PPUSH
45561: PPUSH
45562: PPUSH
45563: PPUSH
45564: PPUSH
45565: PPUSH
45566: PPUSH
// if not mc_bases or not skirmish then
45567: LD_EXP 50
45571: NOT
45572: PUSH
45573: LD_EXP 48
45577: NOT
45578: OR
45579: IFFALSE 45583
// exit ;
45581: GO 46952
// for i = 1 to mc_bases do
45583: LD_ADDR_VAR 0 3
45587: PUSH
45588: DOUBLE
45589: LD_INT 1
45591: DEC
45592: ST_TO_ADDR
45593: LD_EXP 50
45597: PUSH
45598: FOR_TO
45599: IFFALSE 46950
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45601: LD_VAR 0 1
45605: PUSH
45606: LD_EXP 50
45610: PUSH
45611: LD_VAR 0 3
45615: ARRAY
45616: IN
45617: PUSH
45618: LD_VAR 0 1
45622: PUSH
45623: LD_EXP 57
45627: PUSH
45628: LD_VAR 0 3
45632: ARRAY
45633: IN
45634: OR
45635: PUSH
45636: LD_VAR 0 1
45640: PUSH
45641: LD_EXP 72
45645: PUSH
45646: LD_VAR 0 3
45650: ARRAY
45651: IN
45652: OR
45653: PUSH
45654: LD_VAR 0 1
45658: PUSH
45659: LD_EXP 69
45663: PUSH
45664: LD_VAR 0 3
45668: ARRAY
45669: IN
45670: OR
45671: PUSH
45672: LD_VAR 0 1
45676: PUSH
45677: LD_EXP 79
45681: PUSH
45682: LD_VAR 0 3
45686: ARRAY
45687: IN
45688: OR
45689: PUSH
45690: LD_VAR 0 1
45694: PUSH
45695: LD_EXP 80
45699: PUSH
45700: LD_VAR 0 3
45704: ARRAY
45705: IN
45706: OR
45707: IFFALSE 46948
// begin if un in mc_ape [ i ] then
45709: LD_VAR 0 1
45713: PUSH
45714: LD_EXP 79
45718: PUSH
45719: LD_VAR 0 3
45723: ARRAY
45724: IN
45725: IFFALSE 45764
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45727: LD_ADDR_EXP 79
45731: PUSH
45732: LD_EXP 79
45736: PPUSH
45737: LD_VAR 0 3
45741: PPUSH
45742: LD_EXP 79
45746: PUSH
45747: LD_VAR 0 3
45751: ARRAY
45752: PUSH
45753: LD_VAR 0 1
45757: DIFF
45758: PPUSH
45759: CALL_OW 1
45763: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45764: LD_VAR 0 1
45768: PUSH
45769: LD_EXP 80
45773: PUSH
45774: LD_VAR 0 3
45778: ARRAY
45779: IN
45780: IFFALSE 45804
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45782: LD_ADDR_EXP 80
45786: PUSH
45787: LD_EXP 80
45791: PPUSH
45792: LD_VAR 0 3
45796: PPUSH
45797: EMPTY
45798: PPUSH
45799: CALL_OW 1
45803: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45804: LD_VAR 0 1
45808: PPUSH
45809: CALL_OW 247
45813: PUSH
45814: LD_INT 2
45816: EQUAL
45817: PUSH
45818: LD_VAR 0 1
45822: PPUSH
45823: CALL_OW 110
45827: PUSH
45828: LD_INT 20
45830: EQUAL
45831: PUSH
45832: LD_VAR 0 1
45836: PUSH
45837: LD_EXP 72
45841: PUSH
45842: LD_VAR 0 3
45846: ARRAY
45847: IN
45848: OR
45849: PUSH
45850: LD_VAR 0 1
45854: PPUSH
45855: CALL_OW 264
45859: PUSH
45860: LD_INT 12
45862: PUSH
45863: LD_INT 51
45865: PUSH
45866: LD_INT 89
45868: PUSH
45869: LD_INT 32
45871: PUSH
45872: LD_INT 13
45874: PUSH
45875: LD_INT 52
45877: PUSH
45878: LD_INT 31
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: IN
45890: OR
45891: AND
45892: IFFALSE 46200
// begin if un in mc_defender [ i ] then
45894: LD_VAR 0 1
45898: PUSH
45899: LD_EXP 72
45903: PUSH
45904: LD_VAR 0 3
45908: ARRAY
45909: IN
45910: IFFALSE 45949
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45912: LD_ADDR_EXP 72
45916: PUSH
45917: LD_EXP 72
45921: PPUSH
45922: LD_VAR 0 3
45926: PPUSH
45927: LD_EXP 72
45931: PUSH
45932: LD_VAR 0 3
45936: ARRAY
45937: PUSH
45938: LD_VAR 0 1
45942: DIFF
45943: PPUSH
45944: CALL_OW 1
45948: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45949: LD_ADDR_VAR 0 8
45953: PUSH
45954: LD_VAR 0 3
45958: PPUSH
45959: LD_INT 3
45961: PPUSH
45962: CALL 42608 0 2
45966: ST_TO_ADDR
// if fac then
45967: LD_VAR 0 8
45971: IFFALSE 46200
// begin for j in fac do
45973: LD_ADDR_VAR 0 4
45977: PUSH
45978: LD_VAR 0 8
45982: PUSH
45983: FOR_IN
45984: IFFALSE 46198
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45986: LD_ADDR_VAR 0 9
45990: PUSH
45991: LD_VAR 0 8
45995: PPUSH
45996: LD_VAR 0 1
46000: PPUSH
46001: CALL_OW 265
46005: PPUSH
46006: LD_VAR 0 1
46010: PPUSH
46011: CALL_OW 262
46015: PPUSH
46016: LD_VAR 0 1
46020: PPUSH
46021: CALL_OW 263
46025: PPUSH
46026: LD_VAR 0 1
46030: PPUSH
46031: CALL_OW 264
46035: PPUSH
46036: CALL 51176 0 5
46040: ST_TO_ADDR
// if components then
46041: LD_VAR 0 9
46045: IFFALSE 46196
// begin if GetWeapon ( un ) = ar_control_tower then
46047: LD_VAR 0 1
46051: PPUSH
46052: CALL_OW 264
46056: PUSH
46057: LD_INT 31
46059: EQUAL
46060: IFFALSE 46177
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46062: LD_VAR 0 1
46066: PPUSH
46067: CALL_OW 311
46071: PPUSH
46072: LD_INT 0
46074: PPUSH
46075: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46079: LD_ADDR_EXP 90
46083: PUSH
46084: LD_EXP 90
46088: PPUSH
46089: LD_VAR 0 3
46093: PPUSH
46094: LD_EXP 90
46098: PUSH
46099: LD_VAR 0 3
46103: ARRAY
46104: PUSH
46105: LD_VAR 0 1
46109: PPUSH
46110: CALL_OW 311
46114: DIFF
46115: PPUSH
46116: CALL_OW 1
46120: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46121: LD_ADDR_VAR 0 7
46125: PUSH
46126: LD_EXP 71
46130: PUSH
46131: LD_VAR 0 3
46135: ARRAY
46136: PPUSH
46137: LD_INT 1
46139: PPUSH
46140: LD_VAR 0 9
46144: PPUSH
46145: CALL_OW 2
46149: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46150: LD_ADDR_EXP 71
46154: PUSH
46155: LD_EXP 71
46159: PPUSH
46160: LD_VAR 0 3
46164: PPUSH
46165: LD_VAR 0 7
46169: PPUSH
46170: CALL_OW 1
46174: ST_TO_ADDR
// end else
46175: GO 46194
// MC_InsertProduceList ( i , [ components ] ) ;
46177: LD_VAR 0 3
46181: PPUSH
46182: LD_VAR 0 9
46186: PUSH
46187: EMPTY
46188: LIST
46189: PPUSH
46190: CALL 42153 0 2
// break ;
46194: GO 46198
// end ; end ;
46196: GO 45983
46198: POP
46199: POP
// end ; end ; if GetType ( un ) = unit_building then
46200: LD_VAR 0 1
46204: PPUSH
46205: CALL_OW 247
46209: PUSH
46210: LD_INT 3
46212: EQUAL
46213: IFFALSE 46616
// begin btype := GetBType ( un ) ;
46215: LD_ADDR_VAR 0 5
46219: PUSH
46220: LD_VAR 0 1
46224: PPUSH
46225: CALL_OW 266
46229: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46230: LD_VAR 0 5
46234: PUSH
46235: LD_INT 29
46237: PUSH
46238: LD_INT 30
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: IN
46245: IFFALSE 46318
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46247: LD_VAR 0 1
46251: PPUSH
46252: CALL_OW 250
46256: PPUSH
46257: LD_VAR 0 1
46261: PPUSH
46262: CALL_OW 251
46266: PPUSH
46267: LD_VAR 0 1
46271: PPUSH
46272: CALL_OW 255
46276: PPUSH
46277: CALL_OW 440
46281: NOT
46282: IFFALSE 46318
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46284: LD_VAR 0 1
46288: PPUSH
46289: CALL_OW 250
46293: PPUSH
46294: LD_VAR 0 1
46298: PPUSH
46299: CALL_OW 251
46303: PPUSH
46304: LD_VAR 0 1
46308: PPUSH
46309: CALL_OW 255
46313: PPUSH
46314: CALL_OW 441
// end ; if btype = b_warehouse then
46318: LD_VAR 0 5
46322: PUSH
46323: LD_INT 1
46325: EQUAL
46326: IFFALSE 46344
// begin btype := b_depot ;
46328: LD_ADDR_VAR 0 5
46332: PUSH
46333: LD_INT 0
46335: ST_TO_ADDR
// pos := 1 ;
46336: LD_ADDR_VAR 0 6
46340: PUSH
46341: LD_INT 1
46343: ST_TO_ADDR
// end ; if btype = b_factory then
46344: LD_VAR 0 5
46348: PUSH
46349: LD_INT 3
46351: EQUAL
46352: IFFALSE 46370
// begin btype := b_workshop ;
46354: LD_ADDR_VAR 0 5
46358: PUSH
46359: LD_INT 2
46361: ST_TO_ADDR
// pos := 1 ;
46362: LD_ADDR_VAR 0 6
46366: PUSH
46367: LD_INT 1
46369: ST_TO_ADDR
// end ; if btype = b_barracks then
46370: LD_VAR 0 5
46374: PUSH
46375: LD_INT 5
46377: EQUAL
46378: IFFALSE 46388
// btype := b_armoury ;
46380: LD_ADDR_VAR 0 5
46384: PUSH
46385: LD_INT 4
46387: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46388: LD_VAR 0 5
46392: PUSH
46393: LD_INT 7
46395: PUSH
46396: LD_INT 8
46398: PUSH
46399: EMPTY
46400: LIST
46401: LIST
46402: IN
46403: IFFALSE 46413
// btype := b_lab ;
46405: LD_ADDR_VAR 0 5
46409: PUSH
46410: LD_INT 6
46412: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46413: LD_ADDR_EXP 55
46417: PUSH
46418: LD_EXP 55
46422: PPUSH
46423: LD_VAR 0 3
46427: PUSH
46428: LD_EXP 55
46432: PUSH
46433: LD_VAR 0 3
46437: ARRAY
46438: PUSH
46439: LD_INT 1
46441: PLUS
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: PPUSH
46447: LD_VAR 0 5
46451: PUSH
46452: LD_VAR 0 1
46456: PPUSH
46457: CALL_OW 250
46461: PUSH
46462: LD_VAR 0 1
46466: PPUSH
46467: CALL_OW 251
46471: PUSH
46472: LD_VAR 0 1
46476: PPUSH
46477: CALL_OW 254
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: LIST
46486: LIST
46487: PPUSH
46488: CALL 53678 0 3
46492: ST_TO_ADDR
// if pos = 1 then
46493: LD_VAR 0 6
46497: PUSH
46498: LD_INT 1
46500: EQUAL
46501: IFFALSE 46616
// begin tmp := mc_build_list [ i ] ;
46503: LD_ADDR_VAR 0 7
46507: PUSH
46508: LD_EXP 55
46512: PUSH
46513: LD_VAR 0 3
46517: ARRAY
46518: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46519: LD_VAR 0 7
46523: PPUSH
46524: LD_INT 2
46526: PUSH
46527: LD_INT 30
46529: PUSH
46530: LD_INT 0
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: PUSH
46537: LD_INT 30
46539: PUSH
46540: LD_INT 1
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: LIST
46551: PPUSH
46552: CALL_OW 72
46556: IFFALSE 46566
// pos := 2 ;
46558: LD_ADDR_VAR 0 6
46562: PUSH
46563: LD_INT 2
46565: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46566: LD_ADDR_VAR 0 7
46570: PUSH
46571: LD_VAR 0 7
46575: PPUSH
46576: LD_VAR 0 6
46580: PPUSH
46581: LD_VAR 0 7
46585: PPUSH
46586: CALL 54004 0 3
46590: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46591: LD_ADDR_EXP 55
46595: PUSH
46596: LD_EXP 55
46600: PPUSH
46601: LD_VAR 0 3
46605: PPUSH
46606: LD_VAR 0 7
46610: PPUSH
46611: CALL_OW 1
46615: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46616: LD_VAR 0 1
46620: PUSH
46621: LD_EXP 50
46625: PUSH
46626: LD_VAR 0 3
46630: ARRAY
46631: IN
46632: IFFALSE 46671
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46634: LD_ADDR_EXP 50
46638: PUSH
46639: LD_EXP 50
46643: PPUSH
46644: LD_VAR 0 3
46648: PPUSH
46649: LD_EXP 50
46653: PUSH
46654: LD_VAR 0 3
46658: ARRAY
46659: PUSH
46660: LD_VAR 0 1
46664: DIFF
46665: PPUSH
46666: CALL_OW 1
46670: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46671: LD_VAR 0 1
46675: PUSH
46676: LD_EXP 57
46680: PUSH
46681: LD_VAR 0 3
46685: ARRAY
46686: IN
46687: IFFALSE 46726
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46689: LD_ADDR_EXP 57
46693: PUSH
46694: LD_EXP 57
46698: PPUSH
46699: LD_VAR 0 3
46703: PPUSH
46704: LD_EXP 57
46708: PUSH
46709: LD_VAR 0 3
46713: ARRAY
46714: PUSH
46715: LD_VAR 0 1
46719: DIFF
46720: PPUSH
46721: CALL_OW 1
46725: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46726: LD_VAR 0 1
46730: PUSH
46731: LD_EXP 69
46735: PUSH
46736: LD_VAR 0 3
46740: ARRAY
46741: IN
46742: IFFALSE 46781
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46744: LD_ADDR_EXP 69
46748: PUSH
46749: LD_EXP 69
46753: PPUSH
46754: LD_VAR 0 3
46758: PPUSH
46759: LD_EXP 69
46763: PUSH
46764: LD_VAR 0 3
46768: ARRAY
46769: PUSH
46770: LD_VAR 0 1
46774: DIFF
46775: PPUSH
46776: CALL_OW 1
46780: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46781: LD_VAR 0 1
46785: PUSH
46786: LD_EXP 72
46790: PUSH
46791: LD_VAR 0 3
46795: ARRAY
46796: IN
46797: IFFALSE 46836
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46799: LD_ADDR_EXP 72
46803: PUSH
46804: LD_EXP 72
46808: PPUSH
46809: LD_VAR 0 3
46813: PPUSH
46814: LD_EXP 72
46818: PUSH
46819: LD_VAR 0 3
46823: ARRAY
46824: PUSH
46825: LD_VAR 0 1
46829: DIFF
46830: PPUSH
46831: CALL_OW 1
46835: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46836: LD_VAR 0 1
46840: PUSH
46841: LD_EXP 59
46845: PUSH
46846: LD_VAR 0 3
46850: ARRAY
46851: IN
46852: IFFALSE 46891
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46854: LD_ADDR_EXP 59
46858: PUSH
46859: LD_EXP 59
46863: PPUSH
46864: LD_VAR 0 3
46868: PPUSH
46869: LD_EXP 59
46873: PUSH
46874: LD_VAR 0 3
46878: ARRAY
46879: PUSH
46880: LD_VAR 0 1
46884: DIFF
46885: PPUSH
46886: CALL_OW 1
46890: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46891: LD_VAR 0 1
46895: PUSH
46896: LD_EXP 58
46900: PUSH
46901: LD_VAR 0 3
46905: ARRAY
46906: IN
46907: IFFALSE 46946
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46909: LD_ADDR_EXP 58
46913: PUSH
46914: LD_EXP 58
46918: PPUSH
46919: LD_VAR 0 3
46923: PPUSH
46924: LD_EXP 58
46928: PUSH
46929: LD_VAR 0 3
46933: ARRAY
46934: PUSH
46935: LD_VAR 0 1
46939: DIFF
46940: PPUSH
46941: CALL_OW 1
46945: ST_TO_ADDR
// end ; break ;
46946: GO 46950
// end ;
46948: GO 45598
46950: POP
46951: POP
// end ;
46952: LD_VAR 0 2
46956: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46957: LD_INT 0
46959: PPUSH
46960: PPUSH
46961: PPUSH
// if not mc_bases or not skirmish then
46962: LD_EXP 50
46966: NOT
46967: PUSH
46968: LD_EXP 48
46972: NOT
46973: OR
46974: IFFALSE 46978
// exit ;
46976: GO 47193
// for i = 1 to mc_bases do
46978: LD_ADDR_VAR 0 3
46982: PUSH
46983: DOUBLE
46984: LD_INT 1
46986: DEC
46987: ST_TO_ADDR
46988: LD_EXP 50
46992: PUSH
46993: FOR_TO
46994: IFFALSE 47191
// begin if building in mc_construct_list [ i ] then
46996: LD_VAR 0 1
47000: PUSH
47001: LD_EXP 57
47005: PUSH
47006: LD_VAR 0 3
47010: ARRAY
47011: IN
47012: IFFALSE 47189
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47014: LD_ADDR_EXP 57
47018: PUSH
47019: LD_EXP 57
47023: PPUSH
47024: LD_VAR 0 3
47028: PPUSH
47029: LD_EXP 57
47033: PUSH
47034: LD_VAR 0 3
47038: ARRAY
47039: PUSH
47040: LD_VAR 0 1
47044: DIFF
47045: PPUSH
47046: CALL_OW 1
47050: ST_TO_ADDR
// if building in mc_lab [ i ] then
47051: LD_VAR 0 1
47055: PUSH
47056: LD_EXP 83
47060: PUSH
47061: LD_VAR 0 3
47065: ARRAY
47066: IN
47067: IFFALSE 47122
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47069: LD_ADDR_EXP 84
47073: PUSH
47074: LD_EXP 84
47078: PPUSH
47079: LD_VAR 0 3
47083: PPUSH
47084: LD_EXP 84
47088: PUSH
47089: LD_VAR 0 3
47093: ARRAY
47094: PPUSH
47095: LD_INT 1
47097: PPUSH
47098: LD_EXP 84
47102: PUSH
47103: LD_VAR 0 3
47107: ARRAY
47108: PPUSH
47109: LD_INT 0
47111: PPUSH
47112: CALL 53096 0 4
47116: PPUSH
47117: CALL_OW 1
47121: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47122: LD_VAR 0 1
47126: PUSH
47127: LD_EXP 50
47131: PUSH
47132: LD_VAR 0 3
47136: ARRAY
47137: IN
47138: NOT
47139: IFFALSE 47185
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47141: LD_ADDR_EXP 50
47145: PUSH
47146: LD_EXP 50
47150: PPUSH
47151: LD_VAR 0 3
47155: PUSH
47156: LD_EXP 50
47160: PUSH
47161: LD_VAR 0 3
47165: ARRAY
47166: PUSH
47167: LD_INT 1
47169: PLUS
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: PPUSH
47175: LD_VAR 0 1
47179: PPUSH
47180: CALL 53678 0 3
47184: ST_TO_ADDR
// exit ;
47185: POP
47186: POP
47187: GO 47193
// end ; end ;
47189: GO 46993
47191: POP
47192: POP
// end ;
47193: LD_VAR 0 2
47197: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47198: LD_INT 0
47200: PPUSH
47201: PPUSH
47202: PPUSH
47203: PPUSH
47204: PPUSH
47205: PPUSH
47206: PPUSH
// if not mc_bases or not skirmish then
47207: LD_EXP 50
47211: NOT
47212: PUSH
47213: LD_EXP 48
47217: NOT
47218: OR
47219: IFFALSE 47223
// exit ;
47221: GO 47884
// for i = 1 to mc_bases do
47223: LD_ADDR_VAR 0 3
47227: PUSH
47228: DOUBLE
47229: LD_INT 1
47231: DEC
47232: ST_TO_ADDR
47233: LD_EXP 50
47237: PUSH
47238: FOR_TO
47239: IFFALSE 47882
// begin if building in mc_construct_list [ i ] then
47241: LD_VAR 0 1
47245: PUSH
47246: LD_EXP 57
47250: PUSH
47251: LD_VAR 0 3
47255: ARRAY
47256: IN
47257: IFFALSE 47880
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47259: LD_ADDR_EXP 57
47263: PUSH
47264: LD_EXP 57
47268: PPUSH
47269: LD_VAR 0 3
47273: PPUSH
47274: LD_EXP 57
47278: PUSH
47279: LD_VAR 0 3
47283: ARRAY
47284: PUSH
47285: LD_VAR 0 1
47289: DIFF
47290: PPUSH
47291: CALL_OW 1
47295: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47296: LD_ADDR_EXP 50
47300: PUSH
47301: LD_EXP 50
47305: PPUSH
47306: LD_VAR 0 3
47310: PUSH
47311: LD_EXP 50
47315: PUSH
47316: LD_VAR 0 3
47320: ARRAY
47321: PUSH
47322: LD_INT 1
47324: PLUS
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PPUSH
47330: LD_VAR 0 1
47334: PPUSH
47335: CALL 53678 0 3
47339: ST_TO_ADDR
// btype := GetBType ( building ) ;
47340: LD_ADDR_VAR 0 5
47344: PUSH
47345: LD_VAR 0 1
47349: PPUSH
47350: CALL_OW 266
47354: ST_TO_ADDR
// side := GetSide ( building ) ;
47355: LD_ADDR_VAR 0 8
47359: PUSH
47360: LD_VAR 0 1
47364: PPUSH
47365: CALL_OW 255
47369: ST_TO_ADDR
// if btype = b_lab then
47370: LD_VAR 0 5
47374: PUSH
47375: LD_INT 6
47377: EQUAL
47378: IFFALSE 47428
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47380: LD_ADDR_EXP 83
47384: PUSH
47385: LD_EXP 83
47389: PPUSH
47390: LD_VAR 0 3
47394: PUSH
47395: LD_EXP 83
47399: PUSH
47400: LD_VAR 0 3
47404: ARRAY
47405: PUSH
47406: LD_INT 1
47408: PLUS
47409: PUSH
47410: EMPTY
47411: LIST
47412: LIST
47413: PPUSH
47414: LD_VAR 0 1
47418: PPUSH
47419: CALL 53678 0 3
47423: ST_TO_ADDR
// exit ;
47424: POP
47425: POP
47426: GO 47884
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47428: LD_VAR 0 5
47432: PUSH
47433: LD_INT 0
47435: PUSH
47436: LD_INT 2
47438: PUSH
47439: LD_INT 4
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: LIST
47446: IN
47447: IFFALSE 47571
// begin if btype = b_armoury then
47449: LD_VAR 0 5
47453: PUSH
47454: LD_INT 4
47456: EQUAL
47457: IFFALSE 47467
// btype := b_barracks ;
47459: LD_ADDR_VAR 0 5
47463: PUSH
47464: LD_INT 5
47466: ST_TO_ADDR
// if btype = b_depot then
47467: LD_VAR 0 5
47471: PUSH
47472: LD_INT 0
47474: EQUAL
47475: IFFALSE 47485
// btype := b_warehouse ;
47477: LD_ADDR_VAR 0 5
47481: PUSH
47482: LD_INT 1
47484: ST_TO_ADDR
// if btype = b_workshop then
47485: LD_VAR 0 5
47489: PUSH
47490: LD_INT 2
47492: EQUAL
47493: IFFALSE 47503
// btype := b_factory ;
47495: LD_ADDR_VAR 0 5
47499: PUSH
47500: LD_INT 3
47502: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47503: LD_VAR 0 5
47507: PPUSH
47508: LD_VAR 0 8
47512: PPUSH
47513: CALL_OW 323
47517: PUSH
47518: LD_INT 1
47520: EQUAL
47521: IFFALSE 47567
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47523: LD_ADDR_EXP 82
47527: PUSH
47528: LD_EXP 82
47532: PPUSH
47533: LD_VAR 0 3
47537: PUSH
47538: LD_EXP 82
47542: PUSH
47543: LD_VAR 0 3
47547: ARRAY
47548: PUSH
47549: LD_INT 1
47551: PLUS
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: PPUSH
47557: LD_VAR 0 1
47561: PPUSH
47562: CALL 53678 0 3
47566: ST_TO_ADDR
// exit ;
47567: POP
47568: POP
47569: GO 47884
// end ; if btype in [ b_bunker , b_turret ] then
47571: LD_VAR 0 5
47575: PUSH
47576: LD_INT 32
47578: PUSH
47579: LD_INT 33
47581: PUSH
47582: EMPTY
47583: LIST
47584: LIST
47585: IN
47586: IFFALSE 47876
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47588: LD_ADDR_EXP 58
47592: PUSH
47593: LD_EXP 58
47597: PPUSH
47598: LD_VAR 0 3
47602: PUSH
47603: LD_EXP 58
47607: PUSH
47608: LD_VAR 0 3
47612: ARRAY
47613: PUSH
47614: LD_INT 1
47616: PLUS
47617: PUSH
47618: EMPTY
47619: LIST
47620: LIST
47621: PPUSH
47622: LD_VAR 0 1
47626: PPUSH
47627: CALL 53678 0 3
47631: ST_TO_ADDR
// if btype = b_bunker then
47632: LD_VAR 0 5
47636: PUSH
47637: LD_INT 32
47639: EQUAL
47640: IFFALSE 47876
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47642: LD_ADDR_EXP 59
47646: PUSH
47647: LD_EXP 59
47651: PPUSH
47652: LD_VAR 0 3
47656: PUSH
47657: LD_EXP 59
47661: PUSH
47662: LD_VAR 0 3
47666: ARRAY
47667: PUSH
47668: LD_INT 1
47670: PLUS
47671: PUSH
47672: EMPTY
47673: LIST
47674: LIST
47675: PPUSH
47676: LD_VAR 0 1
47680: PPUSH
47681: CALL 53678 0 3
47685: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47686: LD_ADDR_VAR 0 6
47690: PUSH
47691: LD_EXP 50
47695: PUSH
47696: LD_VAR 0 3
47700: ARRAY
47701: PPUSH
47702: LD_INT 25
47704: PUSH
47705: LD_INT 1
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: PUSH
47712: LD_INT 3
47714: PUSH
47715: LD_INT 54
47717: PUSH
47718: EMPTY
47719: LIST
47720: PUSH
47721: EMPTY
47722: LIST
47723: LIST
47724: PUSH
47725: EMPTY
47726: LIST
47727: LIST
47728: PPUSH
47729: CALL_OW 72
47733: ST_TO_ADDR
// if tmp then
47734: LD_VAR 0 6
47738: IFFALSE 47744
// exit ;
47740: POP
47741: POP
47742: GO 47884
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47744: LD_ADDR_VAR 0 6
47748: PUSH
47749: LD_EXP 50
47753: PUSH
47754: LD_VAR 0 3
47758: ARRAY
47759: PPUSH
47760: LD_INT 2
47762: PUSH
47763: LD_INT 30
47765: PUSH
47766: LD_INT 4
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 30
47775: PUSH
47776: LD_INT 5
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: LIST
47787: PPUSH
47788: CALL_OW 72
47792: ST_TO_ADDR
// if not tmp then
47793: LD_VAR 0 6
47797: NOT
47798: IFFALSE 47804
// exit ;
47800: POP
47801: POP
47802: GO 47884
// for j in tmp do
47804: LD_ADDR_VAR 0 4
47808: PUSH
47809: LD_VAR 0 6
47813: PUSH
47814: FOR_IN
47815: IFFALSE 47874
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47817: LD_ADDR_VAR 0 7
47821: PUSH
47822: LD_VAR 0 4
47826: PPUSH
47827: CALL_OW 313
47831: PPUSH
47832: LD_INT 25
47834: PUSH
47835: LD_INT 1
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: PPUSH
47842: CALL_OW 72
47846: ST_TO_ADDR
// if units then
47847: LD_VAR 0 7
47851: IFFALSE 47872
// begin ComExitBuilding ( units [ 1 ] ) ;
47853: LD_VAR 0 7
47857: PUSH
47858: LD_INT 1
47860: ARRAY
47861: PPUSH
47862: CALL_OW 122
// exit ;
47866: POP
47867: POP
47868: POP
47869: POP
47870: GO 47884
// end ; end ;
47872: GO 47814
47874: POP
47875: POP
// end ; end ; exit ;
47876: POP
47877: POP
47878: GO 47884
// end ; end ;
47880: GO 47238
47882: POP
47883: POP
// end ;
47884: LD_VAR 0 2
47888: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47889: LD_INT 0
47891: PPUSH
47892: PPUSH
47893: PPUSH
47894: PPUSH
47895: PPUSH
47896: PPUSH
47897: PPUSH
// if not mc_bases or not skirmish then
47898: LD_EXP 50
47902: NOT
47903: PUSH
47904: LD_EXP 48
47908: NOT
47909: OR
47910: IFFALSE 47914
// exit ;
47912: GO 48179
// btype := GetBType ( building ) ;
47914: LD_ADDR_VAR 0 6
47918: PUSH
47919: LD_VAR 0 1
47923: PPUSH
47924: CALL_OW 266
47928: ST_TO_ADDR
// x := GetX ( building ) ;
47929: LD_ADDR_VAR 0 7
47933: PUSH
47934: LD_VAR 0 1
47938: PPUSH
47939: CALL_OW 250
47943: ST_TO_ADDR
// y := GetY ( building ) ;
47944: LD_ADDR_VAR 0 8
47948: PUSH
47949: LD_VAR 0 1
47953: PPUSH
47954: CALL_OW 251
47958: ST_TO_ADDR
// d := GetDir ( building ) ;
47959: LD_ADDR_VAR 0 9
47963: PUSH
47964: LD_VAR 0 1
47968: PPUSH
47969: CALL_OW 254
47973: ST_TO_ADDR
// for i = 1 to mc_bases do
47974: LD_ADDR_VAR 0 4
47978: PUSH
47979: DOUBLE
47980: LD_INT 1
47982: DEC
47983: ST_TO_ADDR
47984: LD_EXP 50
47988: PUSH
47989: FOR_TO
47990: IFFALSE 48177
// begin if not mc_build_list [ i ] then
47992: LD_EXP 55
47996: PUSH
47997: LD_VAR 0 4
48001: ARRAY
48002: NOT
48003: IFFALSE 48007
// continue ;
48005: GO 47989
// for j := 1 to mc_build_list [ i ] do
48007: LD_ADDR_VAR 0 5
48011: PUSH
48012: DOUBLE
48013: LD_INT 1
48015: DEC
48016: ST_TO_ADDR
48017: LD_EXP 55
48021: PUSH
48022: LD_VAR 0 4
48026: ARRAY
48027: PUSH
48028: FOR_TO
48029: IFFALSE 48173
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48031: LD_VAR 0 6
48035: PUSH
48036: LD_VAR 0 7
48040: PUSH
48041: LD_VAR 0 8
48045: PUSH
48046: LD_VAR 0 9
48050: PUSH
48051: EMPTY
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: PPUSH
48057: LD_EXP 55
48061: PUSH
48062: LD_VAR 0 4
48066: ARRAY
48067: PUSH
48068: LD_VAR 0 5
48072: ARRAY
48073: PPUSH
48074: CALL 59858 0 2
48078: IFFALSE 48171
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48080: LD_ADDR_EXP 55
48084: PUSH
48085: LD_EXP 55
48089: PPUSH
48090: LD_VAR 0 4
48094: PPUSH
48095: LD_EXP 55
48099: PUSH
48100: LD_VAR 0 4
48104: ARRAY
48105: PPUSH
48106: LD_VAR 0 5
48110: PPUSH
48111: CALL_OW 3
48115: PPUSH
48116: CALL_OW 1
48120: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48121: LD_ADDR_EXP 57
48125: PUSH
48126: LD_EXP 57
48130: PPUSH
48131: LD_VAR 0 4
48135: PUSH
48136: LD_EXP 57
48140: PUSH
48141: LD_VAR 0 4
48145: ARRAY
48146: PUSH
48147: LD_INT 1
48149: PLUS
48150: PUSH
48151: EMPTY
48152: LIST
48153: LIST
48154: PPUSH
48155: LD_VAR 0 1
48159: PPUSH
48160: CALL 53678 0 3
48164: ST_TO_ADDR
// exit ;
48165: POP
48166: POP
48167: POP
48168: POP
48169: GO 48179
// end ;
48171: GO 48028
48173: POP
48174: POP
// end ;
48175: GO 47989
48177: POP
48178: POP
// end ;
48179: LD_VAR 0 3
48183: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48184: LD_INT 0
48186: PPUSH
48187: PPUSH
48188: PPUSH
// if not mc_bases or not skirmish then
48189: LD_EXP 50
48193: NOT
48194: PUSH
48195: LD_EXP 48
48199: NOT
48200: OR
48201: IFFALSE 48205
// exit ;
48203: GO 48395
// for i = 1 to mc_bases do
48205: LD_ADDR_VAR 0 4
48209: PUSH
48210: DOUBLE
48211: LD_INT 1
48213: DEC
48214: ST_TO_ADDR
48215: LD_EXP 50
48219: PUSH
48220: FOR_TO
48221: IFFALSE 48308
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48223: LD_VAR 0 1
48227: PUSH
48228: LD_EXP 58
48232: PUSH
48233: LD_VAR 0 4
48237: ARRAY
48238: IN
48239: PUSH
48240: LD_VAR 0 1
48244: PUSH
48245: LD_EXP 59
48249: PUSH
48250: LD_VAR 0 4
48254: ARRAY
48255: IN
48256: NOT
48257: AND
48258: IFFALSE 48306
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48260: LD_ADDR_EXP 59
48264: PUSH
48265: LD_EXP 59
48269: PPUSH
48270: LD_VAR 0 4
48274: PUSH
48275: LD_EXP 59
48279: PUSH
48280: LD_VAR 0 4
48284: ARRAY
48285: PUSH
48286: LD_INT 1
48288: PLUS
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: PPUSH
48294: LD_VAR 0 1
48298: PPUSH
48299: CALL 53678 0 3
48303: ST_TO_ADDR
// break ;
48304: GO 48308
// end ; end ;
48306: GO 48220
48308: POP
48309: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48310: LD_VAR 0 1
48314: PPUSH
48315: CALL_OW 257
48319: PUSH
48320: LD_EXP 76
48324: IN
48325: PUSH
48326: LD_VAR 0 1
48330: PPUSH
48331: CALL_OW 266
48335: PUSH
48336: LD_INT 5
48338: EQUAL
48339: AND
48340: PUSH
48341: LD_VAR 0 2
48345: PPUSH
48346: CALL_OW 110
48350: PUSH
48351: LD_INT 18
48353: NONEQUAL
48354: AND
48355: IFFALSE 48395
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48357: LD_VAR 0 2
48361: PPUSH
48362: CALL_OW 257
48366: PUSH
48367: LD_INT 5
48369: PUSH
48370: LD_INT 8
48372: PUSH
48373: LD_INT 9
48375: PUSH
48376: EMPTY
48377: LIST
48378: LIST
48379: LIST
48380: IN
48381: IFFALSE 48395
// SetClass ( unit , 1 ) ;
48383: LD_VAR 0 2
48387: PPUSH
48388: LD_INT 1
48390: PPUSH
48391: CALL_OW 336
// end ;
48395: LD_VAR 0 3
48399: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48400: LD_INT 0
48402: PPUSH
48403: PPUSH
// if not mc_bases or not skirmish then
48404: LD_EXP 50
48408: NOT
48409: PUSH
48410: LD_EXP 48
48414: NOT
48415: OR
48416: IFFALSE 48420
// exit ;
48418: GO 48536
// if GetLives ( abandoned_vehicle ) > 250 then
48420: LD_VAR 0 2
48424: PPUSH
48425: CALL_OW 256
48429: PUSH
48430: LD_INT 250
48432: GREATER
48433: IFFALSE 48437
// exit ;
48435: GO 48536
// for i = 1 to mc_bases do
48437: LD_ADDR_VAR 0 6
48441: PUSH
48442: DOUBLE
48443: LD_INT 1
48445: DEC
48446: ST_TO_ADDR
48447: LD_EXP 50
48451: PUSH
48452: FOR_TO
48453: IFFALSE 48534
// begin if driver in mc_bases [ i ] then
48455: LD_VAR 0 1
48459: PUSH
48460: LD_EXP 50
48464: PUSH
48465: LD_VAR 0 6
48469: ARRAY
48470: IN
48471: IFFALSE 48532
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48473: LD_VAR 0 1
48477: PPUSH
48478: LD_EXP 50
48482: PUSH
48483: LD_VAR 0 6
48487: ARRAY
48488: PPUSH
48489: LD_INT 2
48491: PUSH
48492: LD_INT 30
48494: PUSH
48495: LD_INT 0
48497: PUSH
48498: EMPTY
48499: LIST
48500: LIST
48501: PUSH
48502: LD_INT 30
48504: PUSH
48505: LD_INT 1
48507: PUSH
48508: EMPTY
48509: LIST
48510: LIST
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: LIST
48516: PPUSH
48517: CALL_OW 72
48521: PUSH
48522: LD_INT 1
48524: ARRAY
48525: PPUSH
48526: CALL 86794 0 2
// break ;
48530: GO 48534
// end ; end ;
48532: GO 48452
48534: POP
48535: POP
// end ; end_of_file
48536: LD_VAR 0 5
48540: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48541: LD_INT 0
48543: PPUSH
48544: PPUSH
// if exist_mode then
48545: LD_VAR 0 2
48549: IFFALSE 48574
// unit := CreateCharacter ( prefix & ident ) else
48551: LD_ADDR_VAR 0 5
48555: PUSH
48556: LD_VAR 0 3
48560: PUSH
48561: LD_VAR 0 1
48565: STR
48566: PPUSH
48567: CALL_OW 34
48571: ST_TO_ADDR
48572: GO 48589
// unit := NewCharacter ( ident ) ;
48574: LD_ADDR_VAR 0 5
48578: PUSH
48579: LD_VAR 0 1
48583: PPUSH
48584: CALL_OW 25
48588: ST_TO_ADDR
// result := unit ;
48589: LD_ADDR_VAR 0 4
48593: PUSH
48594: LD_VAR 0 5
48598: ST_TO_ADDR
// end ;
48599: LD_VAR 0 4
48603: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48604: LD_INT 0
48606: PPUSH
48607: PPUSH
// if not side or not nation then
48608: LD_VAR 0 1
48612: NOT
48613: PUSH
48614: LD_VAR 0 2
48618: NOT
48619: OR
48620: IFFALSE 48624
// exit ;
48622: GO 49392
// case nation of nation_american :
48624: LD_VAR 0 2
48628: PUSH
48629: LD_INT 1
48631: DOUBLE
48632: EQUAL
48633: IFTRUE 48637
48635: GO 48851
48637: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48638: LD_ADDR_VAR 0 4
48642: PUSH
48643: LD_INT 35
48645: PUSH
48646: LD_INT 45
48648: PUSH
48649: LD_INT 46
48651: PUSH
48652: LD_INT 47
48654: PUSH
48655: LD_INT 82
48657: PUSH
48658: LD_INT 83
48660: PUSH
48661: LD_INT 84
48663: PUSH
48664: LD_INT 85
48666: PUSH
48667: LD_INT 86
48669: PUSH
48670: LD_INT 1
48672: PUSH
48673: LD_INT 2
48675: PUSH
48676: LD_INT 6
48678: PUSH
48679: LD_INT 15
48681: PUSH
48682: LD_INT 16
48684: PUSH
48685: LD_INT 7
48687: PUSH
48688: LD_INT 12
48690: PUSH
48691: LD_INT 13
48693: PUSH
48694: LD_INT 10
48696: PUSH
48697: LD_INT 14
48699: PUSH
48700: LD_INT 20
48702: PUSH
48703: LD_INT 21
48705: PUSH
48706: LD_INT 22
48708: PUSH
48709: LD_INT 25
48711: PUSH
48712: LD_INT 32
48714: PUSH
48715: LD_INT 27
48717: PUSH
48718: LD_INT 36
48720: PUSH
48721: LD_INT 69
48723: PUSH
48724: LD_INT 39
48726: PUSH
48727: LD_INT 34
48729: PUSH
48730: LD_INT 40
48732: PUSH
48733: LD_INT 48
48735: PUSH
48736: LD_INT 49
48738: PUSH
48739: LD_INT 50
48741: PUSH
48742: LD_INT 51
48744: PUSH
48745: LD_INT 52
48747: PUSH
48748: LD_INT 53
48750: PUSH
48751: LD_INT 54
48753: PUSH
48754: LD_INT 55
48756: PUSH
48757: LD_INT 56
48759: PUSH
48760: LD_INT 57
48762: PUSH
48763: LD_INT 58
48765: PUSH
48766: LD_INT 59
48768: PUSH
48769: LD_INT 60
48771: PUSH
48772: LD_INT 61
48774: PUSH
48775: LD_INT 62
48777: PUSH
48778: LD_INT 80
48780: PUSH
48781: LD_INT 82
48783: PUSH
48784: LD_INT 83
48786: PUSH
48787: LD_INT 84
48789: PUSH
48790: LD_INT 85
48792: PUSH
48793: LD_INT 86
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: LIST
48806: LIST
48807: LIST
48808: LIST
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: LIST
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: ST_TO_ADDR
48849: GO 49316
48851: LD_INT 2
48853: DOUBLE
48854: EQUAL
48855: IFTRUE 48859
48857: GO 49085
48859: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48860: LD_ADDR_VAR 0 4
48864: PUSH
48865: LD_INT 35
48867: PUSH
48868: LD_INT 45
48870: PUSH
48871: LD_INT 46
48873: PUSH
48874: LD_INT 47
48876: PUSH
48877: LD_INT 82
48879: PUSH
48880: LD_INT 83
48882: PUSH
48883: LD_INT 84
48885: PUSH
48886: LD_INT 85
48888: PUSH
48889: LD_INT 87
48891: PUSH
48892: LD_INT 70
48894: PUSH
48895: LD_INT 1
48897: PUSH
48898: LD_INT 11
48900: PUSH
48901: LD_INT 3
48903: PUSH
48904: LD_INT 4
48906: PUSH
48907: LD_INT 5
48909: PUSH
48910: LD_INT 6
48912: PUSH
48913: LD_INT 15
48915: PUSH
48916: LD_INT 18
48918: PUSH
48919: LD_INT 7
48921: PUSH
48922: LD_INT 17
48924: PUSH
48925: LD_INT 8
48927: PUSH
48928: LD_INT 20
48930: PUSH
48931: LD_INT 21
48933: PUSH
48934: LD_INT 22
48936: PUSH
48937: LD_INT 72
48939: PUSH
48940: LD_INT 26
48942: PUSH
48943: LD_INT 69
48945: PUSH
48946: LD_INT 39
48948: PUSH
48949: LD_INT 40
48951: PUSH
48952: LD_INT 41
48954: PUSH
48955: LD_INT 42
48957: PUSH
48958: LD_INT 43
48960: PUSH
48961: LD_INT 48
48963: PUSH
48964: LD_INT 49
48966: PUSH
48967: LD_INT 50
48969: PUSH
48970: LD_INT 51
48972: PUSH
48973: LD_INT 52
48975: PUSH
48976: LD_INT 53
48978: PUSH
48979: LD_INT 54
48981: PUSH
48982: LD_INT 55
48984: PUSH
48985: LD_INT 56
48987: PUSH
48988: LD_INT 60
48990: PUSH
48991: LD_INT 61
48993: PUSH
48994: LD_INT 62
48996: PUSH
48997: LD_INT 66
48999: PUSH
49000: LD_INT 67
49002: PUSH
49003: LD_INT 68
49005: PUSH
49006: LD_INT 81
49008: PUSH
49009: LD_INT 82
49011: PUSH
49012: LD_INT 83
49014: PUSH
49015: LD_INT 84
49017: PUSH
49018: LD_INT 85
49020: PUSH
49021: LD_INT 87
49023: PUSH
49024: LD_INT 88
49026: PUSH
49027: EMPTY
49028: LIST
49029: LIST
49030: LIST
49031: LIST
49032: LIST
49033: LIST
49034: LIST
49035: LIST
49036: LIST
49037: LIST
49038: LIST
49039: LIST
49040: LIST
49041: LIST
49042: LIST
49043: LIST
49044: LIST
49045: LIST
49046: LIST
49047: LIST
49048: LIST
49049: LIST
49050: LIST
49051: LIST
49052: LIST
49053: LIST
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: ST_TO_ADDR
49083: GO 49316
49085: LD_INT 3
49087: DOUBLE
49088: EQUAL
49089: IFTRUE 49093
49091: GO 49315
49093: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49094: LD_ADDR_VAR 0 4
49098: PUSH
49099: LD_INT 46
49101: PUSH
49102: LD_INT 47
49104: PUSH
49105: LD_INT 1
49107: PUSH
49108: LD_INT 2
49110: PUSH
49111: LD_INT 82
49113: PUSH
49114: LD_INT 83
49116: PUSH
49117: LD_INT 84
49119: PUSH
49120: LD_INT 85
49122: PUSH
49123: LD_INT 86
49125: PUSH
49126: LD_INT 11
49128: PUSH
49129: LD_INT 9
49131: PUSH
49132: LD_INT 20
49134: PUSH
49135: LD_INT 19
49137: PUSH
49138: LD_INT 21
49140: PUSH
49141: LD_INT 24
49143: PUSH
49144: LD_INT 22
49146: PUSH
49147: LD_INT 25
49149: PUSH
49150: LD_INT 28
49152: PUSH
49153: LD_INT 29
49155: PUSH
49156: LD_INT 30
49158: PUSH
49159: LD_INT 31
49161: PUSH
49162: LD_INT 37
49164: PUSH
49165: LD_INT 38
49167: PUSH
49168: LD_INT 32
49170: PUSH
49171: LD_INT 27
49173: PUSH
49174: LD_INT 33
49176: PUSH
49177: LD_INT 69
49179: PUSH
49180: LD_INT 39
49182: PUSH
49183: LD_INT 34
49185: PUSH
49186: LD_INT 40
49188: PUSH
49189: LD_INT 71
49191: PUSH
49192: LD_INT 23
49194: PUSH
49195: LD_INT 44
49197: PUSH
49198: LD_INT 48
49200: PUSH
49201: LD_INT 49
49203: PUSH
49204: LD_INT 50
49206: PUSH
49207: LD_INT 51
49209: PUSH
49210: LD_INT 52
49212: PUSH
49213: LD_INT 53
49215: PUSH
49216: LD_INT 54
49218: PUSH
49219: LD_INT 55
49221: PUSH
49222: LD_INT 56
49224: PUSH
49225: LD_INT 57
49227: PUSH
49228: LD_INT 58
49230: PUSH
49231: LD_INT 59
49233: PUSH
49234: LD_INT 63
49236: PUSH
49237: LD_INT 64
49239: PUSH
49240: LD_INT 65
49242: PUSH
49243: LD_INT 82
49245: PUSH
49246: LD_INT 83
49248: PUSH
49249: LD_INT 84
49251: PUSH
49252: LD_INT 85
49254: PUSH
49255: LD_INT 86
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: LIST
49262: LIST
49263: LIST
49264: LIST
49265: LIST
49266: LIST
49267: LIST
49268: LIST
49269: LIST
49270: LIST
49271: LIST
49272: LIST
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: LIST
49280: LIST
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: LIST
49288: LIST
49289: LIST
49290: LIST
49291: LIST
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: ST_TO_ADDR
49313: GO 49316
49315: POP
// if state > - 1 and state < 3 then
49316: LD_VAR 0 3
49320: PUSH
49321: LD_INT 1
49323: NEG
49324: GREATER
49325: PUSH
49326: LD_VAR 0 3
49330: PUSH
49331: LD_INT 3
49333: LESS
49334: AND
49335: IFFALSE 49392
// for i in result do
49337: LD_ADDR_VAR 0 5
49341: PUSH
49342: LD_VAR 0 4
49346: PUSH
49347: FOR_IN
49348: IFFALSE 49390
// if GetTech ( i , side ) <> state then
49350: LD_VAR 0 5
49354: PPUSH
49355: LD_VAR 0 1
49359: PPUSH
49360: CALL_OW 321
49364: PUSH
49365: LD_VAR 0 3
49369: NONEQUAL
49370: IFFALSE 49388
// result := result diff i ;
49372: LD_ADDR_VAR 0 4
49376: PUSH
49377: LD_VAR 0 4
49381: PUSH
49382: LD_VAR 0 5
49386: DIFF
49387: ST_TO_ADDR
49388: GO 49347
49390: POP
49391: POP
// end ;
49392: LD_VAR 0 4
49396: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49397: LD_INT 0
49399: PPUSH
49400: PPUSH
49401: PPUSH
// result := true ;
49402: LD_ADDR_VAR 0 3
49406: PUSH
49407: LD_INT 1
49409: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49410: LD_ADDR_VAR 0 5
49414: PUSH
49415: LD_VAR 0 2
49419: PPUSH
49420: CALL_OW 480
49424: ST_TO_ADDR
// if not tmp then
49425: LD_VAR 0 5
49429: NOT
49430: IFFALSE 49434
// exit ;
49432: GO 49483
// for i in tmp do
49434: LD_ADDR_VAR 0 4
49438: PUSH
49439: LD_VAR 0 5
49443: PUSH
49444: FOR_IN
49445: IFFALSE 49481
// if GetTech ( i , side ) <> state_researched then
49447: LD_VAR 0 4
49451: PPUSH
49452: LD_VAR 0 1
49456: PPUSH
49457: CALL_OW 321
49461: PUSH
49462: LD_INT 2
49464: NONEQUAL
49465: IFFALSE 49479
// begin result := false ;
49467: LD_ADDR_VAR 0 3
49471: PUSH
49472: LD_INT 0
49474: ST_TO_ADDR
// exit ;
49475: POP
49476: POP
49477: GO 49483
// end ;
49479: GO 49444
49481: POP
49482: POP
// end ;
49483: LD_VAR 0 3
49487: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49488: LD_INT 0
49490: PPUSH
49491: PPUSH
49492: PPUSH
49493: PPUSH
49494: PPUSH
49495: PPUSH
49496: PPUSH
49497: PPUSH
49498: PPUSH
49499: PPUSH
49500: PPUSH
49501: PPUSH
49502: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49503: LD_VAR 0 1
49507: NOT
49508: PUSH
49509: LD_VAR 0 1
49513: PPUSH
49514: CALL_OW 257
49518: PUSH
49519: LD_INT 9
49521: NONEQUAL
49522: OR
49523: IFFALSE 49527
// exit ;
49525: GO 50100
// side := GetSide ( unit ) ;
49527: LD_ADDR_VAR 0 9
49531: PUSH
49532: LD_VAR 0 1
49536: PPUSH
49537: CALL_OW 255
49541: ST_TO_ADDR
// tech_space := tech_spacanom ;
49542: LD_ADDR_VAR 0 12
49546: PUSH
49547: LD_INT 29
49549: ST_TO_ADDR
// tech_time := tech_taurad ;
49550: LD_ADDR_VAR 0 13
49554: PUSH
49555: LD_INT 28
49557: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49558: LD_ADDR_VAR 0 11
49562: PUSH
49563: LD_VAR 0 1
49567: PPUSH
49568: CALL_OW 310
49572: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49573: LD_VAR 0 11
49577: PPUSH
49578: CALL_OW 247
49582: PUSH
49583: LD_INT 2
49585: EQUAL
49586: IFFALSE 49590
// exit ;
49588: GO 50100
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49590: LD_ADDR_VAR 0 8
49594: PUSH
49595: LD_INT 81
49597: PUSH
49598: LD_VAR 0 9
49602: PUSH
49603: EMPTY
49604: LIST
49605: LIST
49606: PUSH
49607: LD_INT 3
49609: PUSH
49610: LD_INT 21
49612: PUSH
49613: LD_INT 3
49615: PUSH
49616: EMPTY
49617: LIST
49618: LIST
49619: PUSH
49620: EMPTY
49621: LIST
49622: LIST
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PPUSH
49628: CALL_OW 69
49632: ST_TO_ADDR
// if not tmp then
49633: LD_VAR 0 8
49637: NOT
49638: IFFALSE 49642
// exit ;
49640: GO 50100
// if in_unit then
49642: LD_VAR 0 11
49646: IFFALSE 49670
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49648: LD_ADDR_VAR 0 10
49652: PUSH
49653: LD_VAR 0 8
49657: PPUSH
49658: LD_VAR 0 11
49662: PPUSH
49663: CALL_OW 74
49667: ST_TO_ADDR
49668: GO 49690
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49670: LD_ADDR_VAR 0 10
49674: PUSH
49675: LD_VAR 0 8
49679: PPUSH
49680: LD_VAR 0 1
49684: PPUSH
49685: CALL_OW 74
49689: ST_TO_ADDR
// if not enemy then
49690: LD_VAR 0 10
49694: NOT
49695: IFFALSE 49699
// exit ;
49697: GO 50100
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49699: LD_VAR 0 11
49703: PUSH
49704: LD_VAR 0 11
49708: PPUSH
49709: LD_VAR 0 10
49713: PPUSH
49714: CALL_OW 296
49718: PUSH
49719: LD_INT 13
49721: GREATER
49722: AND
49723: PUSH
49724: LD_VAR 0 1
49728: PPUSH
49729: LD_VAR 0 10
49733: PPUSH
49734: CALL_OW 296
49738: PUSH
49739: LD_INT 12
49741: GREATER
49742: OR
49743: IFFALSE 49747
// exit ;
49745: GO 50100
// missile := [ 1 ] ;
49747: LD_ADDR_VAR 0 14
49751: PUSH
49752: LD_INT 1
49754: PUSH
49755: EMPTY
49756: LIST
49757: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49758: LD_VAR 0 9
49762: PPUSH
49763: LD_VAR 0 12
49767: PPUSH
49768: CALL_OW 325
49772: IFFALSE 49801
// missile := Replace ( missile , missile + 1 , 2 ) ;
49774: LD_ADDR_VAR 0 14
49778: PUSH
49779: LD_VAR 0 14
49783: PPUSH
49784: LD_VAR 0 14
49788: PUSH
49789: LD_INT 1
49791: PLUS
49792: PPUSH
49793: LD_INT 2
49795: PPUSH
49796: CALL_OW 1
49800: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49801: LD_VAR 0 9
49805: PPUSH
49806: LD_VAR 0 13
49810: PPUSH
49811: CALL_OW 325
49815: PUSH
49816: LD_VAR 0 10
49820: PPUSH
49821: CALL_OW 255
49825: PPUSH
49826: LD_VAR 0 13
49830: PPUSH
49831: CALL_OW 325
49835: NOT
49836: AND
49837: IFFALSE 49866
// missile := Replace ( missile , missile + 1 , 3 ) ;
49839: LD_ADDR_VAR 0 14
49843: PUSH
49844: LD_VAR 0 14
49848: PPUSH
49849: LD_VAR 0 14
49853: PUSH
49854: LD_INT 1
49856: PLUS
49857: PPUSH
49858: LD_INT 3
49860: PPUSH
49861: CALL_OW 1
49865: ST_TO_ADDR
// if missile < 2 then
49866: LD_VAR 0 14
49870: PUSH
49871: LD_INT 2
49873: LESS
49874: IFFALSE 49878
// exit ;
49876: GO 50100
// x := GetX ( enemy ) ;
49878: LD_ADDR_VAR 0 4
49882: PUSH
49883: LD_VAR 0 10
49887: PPUSH
49888: CALL_OW 250
49892: ST_TO_ADDR
// y := GetY ( enemy ) ;
49893: LD_ADDR_VAR 0 5
49897: PUSH
49898: LD_VAR 0 10
49902: PPUSH
49903: CALL_OW 251
49907: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49908: LD_ADDR_VAR 0 6
49912: PUSH
49913: LD_VAR 0 4
49917: PUSH
49918: LD_INT 1
49920: NEG
49921: PPUSH
49922: LD_INT 1
49924: PPUSH
49925: CALL_OW 12
49929: PLUS
49930: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49931: LD_ADDR_VAR 0 7
49935: PUSH
49936: LD_VAR 0 5
49940: PUSH
49941: LD_INT 1
49943: NEG
49944: PPUSH
49945: LD_INT 1
49947: PPUSH
49948: CALL_OW 12
49952: PLUS
49953: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49954: LD_VAR 0 6
49958: PPUSH
49959: LD_VAR 0 7
49963: PPUSH
49964: CALL_OW 488
49968: NOT
49969: IFFALSE 49991
// begin _x := x ;
49971: LD_ADDR_VAR 0 6
49975: PUSH
49976: LD_VAR 0 4
49980: ST_TO_ADDR
// _y := y ;
49981: LD_ADDR_VAR 0 7
49985: PUSH
49986: LD_VAR 0 5
49990: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49991: LD_ADDR_VAR 0 3
49995: PUSH
49996: LD_INT 1
49998: PPUSH
49999: LD_VAR 0 14
50003: PPUSH
50004: CALL_OW 12
50008: ST_TO_ADDR
// case i of 1 :
50009: LD_VAR 0 3
50013: PUSH
50014: LD_INT 1
50016: DOUBLE
50017: EQUAL
50018: IFTRUE 50022
50020: GO 50039
50022: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50023: LD_VAR 0 1
50027: PPUSH
50028: LD_VAR 0 10
50032: PPUSH
50033: CALL_OW 115
50037: GO 50100
50039: LD_INT 2
50041: DOUBLE
50042: EQUAL
50043: IFTRUE 50047
50045: GO 50069
50047: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50048: LD_VAR 0 1
50052: PPUSH
50053: LD_VAR 0 6
50057: PPUSH
50058: LD_VAR 0 7
50062: PPUSH
50063: CALL_OW 153
50067: GO 50100
50069: LD_INT 3
50071: DOUBLE
50072: EQUAL
50073: IFTRUE 50077
50075: GO 50099
50077: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50078: LD_VAR 0 1
50082: PPUSH
50083: LD_VAR 0 6
50087: PPUSH
50088: LD_VAR 0 7
50092: PPUSH
50093: CALL_OW 154
50097: GO 50100
50099: POP
// end ;
50100: LD_VAR 0 2
50104: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50105: LD_INT 0
50107: PPUSH
50108: PPUSH
50109: PPUSH
50110: PPUSH
50111: PPUSH
50112: PPUSH
// if not unit or not building then
50113: LD_VAR 0 1
50117: NOT
50118: PUSH
50119: LD_VAR 0 2
50123: NOT
50124: OR
50125: IFFALSE 50129
// exit ;
50127: GO 50287
// x := GetX ( building ) ;
50129: LD_ADDR_VAR 0 5
50133: PUSH
50134: LD_VAR 0 2
50138: PPUSH
50139: CALL_OW 250
50143: ST_TO_ADDR
// y := GetY ( building ) ;
50144: LD_ADDR_VAR 0 6
50148: PUSH
50149: LD_VAR 0 2
50153: PPUSH
50154: CALL_OW 251
50158: ST_TO_ADDR
// for i = 0 to 5 do
50159: LD_ADDR_VAR 0 4
50163: PUSH
50164: DOUBLE
50165: LD_INT 0
50167: DEC
50168: ST_TO_ADDR
50169: LD_INT 5
50171: PUSH
50172: FOR_TO
50173: IFFALSE 50285
// begin _x := ShiftX ( x , i , 3 ) ;
50175: LD_ADDR_VAR 0 7
50179: PUSH
50180: LD_VAR 0 5
50184: PPUSH
50185: LD_VAR 0 4
50189: PPUSH
50190: LD_INT 3
50192: PPUSH
50193: CALL_OW 272
50197: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50198: LD_ADDR_VAR 0 8
50202: PUSH
50203: LD_VAR 0 6
50207: PPUSH
50208: LD_VAR 0 4
50212: PPUSH
50213: LD_INT 3
50215: PPUSH
50216: CALL_OW 273
50220: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50221: LD_VAR 0 7
50225: PPUSH
50226: LD_VAR 0 8
50230: PPUSH
50231: CALL_OW 488
50235: NOT
50236: IFFALSE 50240
// continue ;
50238: GO 50172
// if HexInfo ( _x , _y ) = 0 then
50240: LD_VAR 0 7
50244: PPUSH
50245: LD_VAR 0 8
50249: PPUSH
50250: CALL_OW 428
50254: PUSH
50255: LD_INT 0
50257: EQUAL
50258: IFFALSE 50283
// begin ComMoveXY ( unit , _x , _y ) ;
50260: LD_VAR 0 1
50264: PPUSH
50265: LD_VAR 0 7
50269: PPUSH
50270: LD_VAR 0 8
50274: PPUSH
50275: CALL_OW 111
// exit ;
50279: POP
50280: POP
50281: GO 50287
// end ; end ;
50283: GO 50172
50285: POP
50286: POP
// end ;
50287: LD_VAR 0 3
50291: RET
// export function ScanBase ( side , base_area ) ; begin
50292: LD_INT 0
50294: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50295: LD_ADDR_VAR 0 3
50299: PUSH
50300: LD_VAR 0 2
50304: PPUSH
50305: LD_INT 81
50307: PUSH
50308: LD_VAR 0 1
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PPUSH
50317: CALL_OW 70
50321: ST_TO_ADDR
// end ;
50322: LD_VAR 0 3
50326: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50327: LD_INT 0
50329: PPUSH
50330: PPUSH
50331: PPUSH
50332: PPUSH
// result := false ;
50333: LD_ADDR_VAR 0 2
50337: PUSH
50338: LD_INT 0
50340: ST_TO_ADDR
// side := GetSide ( unit ) ;
50341: LD_ADDR_VAR 0 3
50345: PUSH
50346: LD_VAR 0 1
50350: PPUSH
50351: CALL_OW 255
50355: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50356: LD_ADDR_VAR 0 4
50360: PUSH
50361: LD_VAR 0 1
50365: PPUSH
50366: CALL_OW 248
50370: ST_TO_ADDR
// case nat of 1 :
50371: LD_VAR 0 4
50375: PUSH
50376: LD_INT 1
50378: DOUBLE
50379: EQUAL
50380: IFTRUE 50384
50382: GO 50395
50384: POP
// tech := tech_lassight ; 2 :
50385: LD_ADDR_VAR 0 5
50389: PUSH
50390: LD_INT 12
50392: ST_TO_ADDR
50393: GO 50434
50395: LD_INT 2
50397: DOUBLE
50398: EQUAL
50399: IFTRUE 50403
50401: GO 50414
50403: POP
// tech := tech_mortar ; 3 :
50404: LD_ADDR_VAR 0 5
50408: PUSH
50409: LD_INT 41
50411: ST_TO_ADDR
50412: GO 50434
50414: LD_INT 3
50416: DOUBLE
50417: EQUAL
50418: IFTRUE 50422
50420: GO 50433
50422: POP
// tech := tech_bazooka ; end ;
50423: LD_ADDR_VAR 0 5
50427: PUSH
50428: LD_INT 44
50430: ST_TO_ADDR
50431: GO 50434
50433: POP
// if Researched ( side , tech ) then
50434: LD_VAR 0 3
50438: PPUSH
50439: LD_VAR 0 5
50443: PPUSH
50444: CALL_OW 325
50448: IFFALSE 50475
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50450: LD_ADDR_VAR 0 2
50454: PUSH
50455: LD_INT 5
50457: PUSH
50458: LD_INT 8
50460: PUSH
50461: LD_INT 9
50463: PUSH
50464: EMPTY
50465: LIST
50466: LIST
50467: LIST
50468: PUSH
50469: LD_VAR 0 4
50473: ARRAY
50474: ST_TO_ADDR
// end ;
50475: LD_VAR 0 2
50479: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50480: LD_INT 0
50482: PPUSH
50483: PPUSH
50484: PPUSH
// if not mines then
50485: LD_VAR 0 2
50489: NOT
50490: IFFALSE 50494
// exit ;
50492: GO 50638
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50494: LD_ADDR_VAR 0 5
50498: PUSH
50499: LD_INT 81
50501: PUSH
50502: LD_VAR 0 1
50506: PUSH
50507: EMPTY
50508: LIST
50509: LIST
50510: PUSH
50511: LD_INT 3
50513: PUSH
50514: LD_INT 21
50516: PUSH
50517: LD_INT 3
50519: PUSH
50520: EMPTY
50521: LIST
50522: LIST
50523: PUSH
50524: EMPTY
50525: LIST
50526: LIST
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: PPUSH
50532: CALL_OW 69
50536: ST_TO_ADDR
// for i in mines do
50537: LD_ADDR_VAR 0 4
50541: PUSH
50542: LD_VAR 0 2
50546: PUSH
50547: FOR_IN
50548: IFFALSE 50636
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50550: LD_VAR 0 4
50554: PUSH
50555: LD_INT 1
50557: ARRAY
50558: PPUSH
50559: LD_VAR 0 4
50563: PUSH
50564: LD_INT 2
50566: ARRAY
50567: PPUSH
50568: CALL_OW 458
50572: NOT
50573: IFFALSE 50577
// continue ;
50575: GO 50547
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50577: LD_VAR 0 4
50581: PUSH
50582: LD_INT 1
50584: ARRAY
50585: PPUSH
50586: LD_VAR 0 4
50590: PUSH
50591: LD_INT 2
50593: ARRAY
50594: PPUSH
50595: CALL_OW 428
50599: PUSH
50600: LD_VAR 0 5
50604: IN
50605: IFFALSE 50634
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50607: LD_VAR 0 4
50611: PUSH
50612: LD_INT 1
50614: ARRAY
50615: PPUSH
50616: LD_VAR 0 4
50620: PUSH
50621: LD_INT 2
50623: ARRAY
50624: PPUSH
50625: LD_VAR 0 1
50629: PPUSH
50630: CALL_OW 456
// end ;
50634: GO 50547
50636: POP
50637: POP
// end ;
50638: LD_VAR 0 3
50642: RET
// export function Count ( array ) ; var i ; begin
50643: LD_INT 0
50645: PPUSH
50646: PPUSH
// result := 0 ;
50647: LD_ADDR_VAR 0 2
50651: PUSH
50652: LD_INT 0
50654: ST_TO_ADDR
// for i in array do
50655: LD_ADDR_VAR 0 3
50659: PUSH
50660: LD_VAR 0 1
50664: PUSH
50665: FOR_IN
50666: IFFALSE 50690
// if i then
50668: LD_VAR 0 3
50672: IFFALSE 50688
// result := result + 1 ;
50674: LD_ADDR_VAR 0 2
50678: PUSH
50679: LD_VAR 0 2
50683: PUSH
50684: LD_INT 1
50686: PLUS
50687: ST_TO_ADDR
50688: GO 50665
50690: POP
50691: POP
// end ;
50692: LD_VAR 0 2
50696: RET
// export function IsEmpty ( building ) ; begin
50697: LD_INT 0
50699: PPUSH
// if not building then
50700: LD_VAR 0 1
50704: NOT
50705: IFFALSE 50709
// exit ;
50707: GO 50752
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50709: LD_ADDR_VAR 0 2
50713: PUSH
50714: LD_VAR 0 1
50718: PUSH
50719: LD_INT 22
50721: PUSH
50722: LD_VAR 0 1
50726: PPUSH
50727: CALL_OW 255
50731: PUSH
50732: EMPTY
50733: LIST
50734: LIST
50735: PUSH
50736: LD_INT 58
50738: PUSH
50739: EMPTY
50740: LIST
50741: PUSH
50742: EMPTY
50743: LIST
50744: LIST
50745: PPUSH
50746: CALL_OW 69
50750: IN
50751: ST_TO_ADDR
// end ;
50752: LD_VAR 0 2
50756: RET
// export function IsNotFull ( building ) ; var places ; begin
50757: LD_INT 0
50759: PPUSH
50760: PPUSH
// if not building then
50761: LD_VAR 0 1
50765: NOT
50766: IFFALSE 50770
// exit ;
50768: GO 50941
// result := false ;
50770: LD_ADDR_VAR 0 2
50774: PUSH
50775: LD_INT 0
50777: ST_TO_ADDR
// places := 0 ;
50778: LD_ADDR_VAR 0 3
50782: PUSH
50783: LD_INT 0
50785: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
50786: LD_VAR 0 1
50790: PPUSH
50791: CALL_OW 266
50795: PUSH
50796: LD_INT 0
50798: DOUBLE
50799: EQUAL
50800: IFTRUE 50858
50802: LD_INT 1
50804: DOUBLE
50805: EQUAL
50806: IFTRUE 50858
50808: LD_INT 6
50810: DOUBLE
50811: EQUAL
50812: IFTRUE 50858
50814: LD_INT 7
50816: DOUBLE
50817: EQUAL
50818: IFTRUE 50858
50820: LD_INT 8
50822: DOUBLE
50823: EQUAL
50824: IFTRUE 50858
50826: LD_INT 4
50828: DOUBLE
50829: EQUAL
50830: IFTRUE 50858
50832: LD_INT 5
50834: DOUBLE
50835: EQUAL
50836: IFTRUE 50858
50838: LD_INT 2
50840: DOUBLE
50841: EQUAL
50842: IFTRUE 50858
50844: LD_INT 3
50846: DOUBLE
50847: EQUAL
50848: IFTRUE 50858
50850: LD_INT 35
50852: DOUBLE
50853: EQUAL
50854: IFTRUE 50858
50856: GO 50869
50858: POP
// places := 6 ; b_bunker , b_breastwork :
50859: LD_ADDR_VAR 0 3
50863: PUSH
50864: LD_INT 6
50866: ST_TO_ADDR
50867: GO 50914
50869: LD_INT 32
50871: DOUBLE
50872: EQUAL
50873: IFTRUE 50883
50875: LD_INT 31
50877: DOUBLE
50878: EQUAL
50879: IFTRUE 50883
50881: GO 50894
50883: POP
// places := 1 ; b_control_tower :
50884: LD_ADDR_VAR 0 3
50888: PUSH
50889: LD_INT 1
50891: ST_TO_ADDR
50892: GO 50914
50894: LD_INT 36
50896: DOUBLE
50897: EQUAL
50898: IFTRUE 50902
50900: GO 50913
50902: POP
// places := 3 ; end ;
50903: LD_ADDR_VAR 0 3
50907: PUSH
50908: LD_INT 3
50910: ST_TO_ADDR
50911: GO 50914
50913: POP
// if places then
50914: LD_VAR 0 3
50918: IFFALSE 50941
// result := UnitsInside ( building ) < places ;
50920: LD_ADDR_VAR 0 2
50924: PUSH
50925: LD_VAR 0 1
50929: PPUSH
50930: CALL_OW 313
50934: PUSH
50935: LD_VAR 0 3
50939: LESS
50940: ST_TO_ADDR
// end ;
50941: LD_VAR 0 2
50945: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50946: LD_INT 0
50948: PPUSH
50949: PPUSH
50950: PPUSH
50951: PPUSH
// tmp := [ ] ;
50952: LD_ADDR_VAR 0 3
50956: PUSH
50957: EMPTY
50958: ST_TO_ADDR
// list := [ ] ;
50959: LD_ADDR_VAR 0 5
50963: PUSH
50964: EMPTY
50965: ST_TO_ADDR
// for i = 16 to 25 do
50966: LD_ADDR_VAR 0 4
50970: PUSH
50971: DOUBLE
50972: LD_INT 16
50974: DEC
50975: ST_TO_ADDR
50976: LD_INT 25
50978: PUSH
50979: FOR_TO
50980: IFFALSE 51053
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50982: LD_ADDR_VAR 0 3
50986: PUSH
50987: LD_VAR 0 3
50991: PUSH
50992: LD_INT 22
50994: PUSH
50995: LD_VAR 0 1
50999: PPUSH
51000: CALL_OW 255
51004: PUSH
51005: EMPTY
51006: LIST
51007: LIST
51008: PUSH
51009: LD_INT 91
51011: PUSH
51012: LD_VAR 0 1
51016: PUSH
51017: LD_INT 6
51019: PUSH
51020: EMPTY
51021: LIST
51022: LIST
51023: LIST
51024: PUSH
51025: LD_INT 30
51027: PUSH
51028: LD_VAR 0 4
51032: PUSH
51033: EMPTY
51034: LIST
51035: LIST
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: LIST
51041: PUSH
51042: EMPTY
51043: LIST
51044: PPUSH
51045: CALL_OW 69
51049: ADD
51050: ST_TO_ADDR
51051: GO 50979
51053: POP
51054: POP
// for i = 1 to tmp do
51055: LD_ADDR_VAR 0 4
51059: PUSH
51060: DOUBLE
51061: LD_INT 1
51063: DEC
51064: ST_TO_ADDR
51065: LD_VAR 0 3
51069: PUSH
51070: FOR_TO
51071: IFFALSE 51159
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51073: LD_ADDR_VAR 0 5
51077: PUSH
51078: LD_VAR 0 5
51082: PUSH
51083: LD_VAR 0 3
51087: PUSH
51088: LD_VAR 0 4
51092: ARRAY
51093: PPUSH
51094: CALL_OW 266
51098: PUSH
51099: LD_VAR 0 3
51103: PUSH
51104: LD_VAR 0 4
51108: ARRAY
51109: PPUSH
51110: CALL_OW 250
51114: PUSH
51115: LD_VAR 0 3
51119: PUSH
51120: LD_VAR 0 4
51124: ARRAY
51125: PPUSH
51126: CALL_OW 251
51130: PUSH
51131: LD_VAR 0 3
51135: PUSH
51136: LD_VAR 0 4
51140: ARRAY
51141: PPUSH
51142: CALL_OW 254
51146: PUSH
51147: EMPTY
51148: LIST
51149: LIST
51150: LIST
51151: LIST
51152: PUSH
51153: EMPTY
51154: LIST
51155: ADD
51156: ST_TO_ADDR
51157: GO 51070
51159: POP
51160: POP
// result := list ;
51161: LD_ADDR_VAR 0 2
51165: PUSH
51166: LD_VAR 0 5
51170: ST_TO_ADDR
// end ;
51171: LD_VAR 0 2
51175: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51176: LD_INT 0
51178: PPUSH
51179: PPUSH
51180: PPUSH
51181: PPUSH
51182: PPUSH
51183: PPUSH
51184: PPUSH
// if not factory then
51185: LD_VAR 0 1
51189: NOT
51190: IFFALSE 51194
// exit ;
51192: GO 51787
// if control = control_apeman then
51194: LD_VAR 0 4
51198: PUSH
51199: LD_INT 5
51201: EQUAL
51202: IFFALSE 51311
// begin tmp := UnitsInside ( factory ) ;
51204: LD_ADDR_VAR 0 8
51208: PUSH
51209: LD_VAR 0 1
51213: PPUSH
51214: CALL_OW 313
51218: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51219: LD_VAR 0 8
51223: PPUSH
51224: LD_INT 25
51226: PUSH
51227: LD_INT 12
51229: PUSH
51230: EMPTY
51231: LIST
51232: LIST
51233: PPUSH
51234: CALL_OW 72
51238: NOT
51239: IFFALSE 51249
// control := control_manual ;
51241: LD_ADDR_VAR 0 4
51245: PUSH
51246: LD_INT 1
51248: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51249: LD_ADDR_VAR 0 8
51253: PUSH
51254: LD_VAR 0 1
51258: PPUSH
51259: CALL 50946 0 1
51263: ST_TO_ADDR
// if tmp then
51264: LD_VAR 0 8
51268: IFFALSE 51311
// begin for i in tmp do
51270: LD_ADDR_VAR 0 7
51274: PUSH
51275: LD_VAR 0 8
51279: PUSH
51280: FOR_IN
51281: IFFALSE 51309
// if i [ 1 ] = b_ext_radio then
51283: LD_VAR 0 7
51287: PUSH
51288: LD_INT 1
51290: ARRAY
51291: PUSH
51292: LD_INT 22
51294: EQUAL
51295: IFFALSE 51307
// begin control := control_remote ;
51297: LD_ADDR_VAR 0 4
51301: PUSH
51302: LD_INT 2
51304: ST_TO_ADDR
// break ;
51305: GO 51309
// end ;
51307: GO 51280
51309: POP
51310: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51311: LD_VAR 0 1
51315: PPUSH
51316: LD_VAR 0 2
51320: PPUSH
51321: LD_VAR 0 3
51325: PPUSH
51326: LD_VAR 0 4
51330: PPUSH
51331: LD_VAR 0 5
51335: PPUSH
51336: CALL_OW 448
51340: IFFALSE 51375
// begin result := [ chassis , engine , control , weapon ] ;
51342: LD_ADDR_VAR 0 6
51346: PUSH
51347: LD_VAR 0 2
51351: PUSH
51352: LD_VAR 0 3
51356: PUSH
51357: LD_VAR 0 4
51361: PUSH
51362: LD_VAR 0 5
51366: PUSH
51367: EMPTY
51368: LIST
51369: LIST
51370: LIST
51371: LIST
51372: ST_TO_ADDR
// exit ;
51373: GO 51787
// end ; _chassis := AvailableChassisList ( factory ) ;
51375: LD_ADDR_VAR 0 9
51379: PUSH
51380: LD_VAR 0 1
51384: PPUSH
51385: CALL_OW 475
51389: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51390: LD_ADDR_VAR 0 11
51394: PUSH
51395: LD_VAR 0 1
51399: PPUSH
51400: CALL_OW 476
51404: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51405: LD_ADDR_VAR 0 12
51409: PUSH
51410: LD_VAR 0 1
51414: PPUSH
51415: CALL_OW 477
51419: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51420: LD_ADDR_VAR 0 10
51424: PUSH
51425: LD_VAR 0 1
51429: PPUSH
51430: CALL_OW 478
51434: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51435: LD_VAR 0 9
51439: NOT
51440: PUSH
51441: LD_VAR 0 11
51445: NOT
51446: OR
51447: PUSH
51448: LD_VAR 0 12
51452: NOT
51453: OR
51454: PUSH
51455: LD_VAR 0 10
51459: NOT
51460: OR
51461: IFFALSE 51496
// begin result := [ chassis , engine , control , weapon ] ;
51463: LD_ADDR_VAR 0 6
51467: PUSH
51468: LD_VAR 0 2
51472: PUSH
51473: LD_VAR 0 3
51477: PUSH
51478: LD_VAR 0 4
51482: PUSH
51483: LD_VAR 0 5
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: ST_TO_ADDR
// exit ;
51494: GO 51787
// end ; if not chassis in _chassis then
51496: LD_VAR 0 2
51500: PUSH
51501: LD_VAR 0 9
51505: IN
51506: NOT
51507: IFFALSE 51533
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51509: LD_ADDR_VAR 0 2
51513: PUSH
51514: LD_VAR 0 9
51518: PUSH
51519: LD_INT 1
51521: PPUSH
51522: LD_VAR 0 9
51526: PPUSH
51527: CALL_OW 12
51531: ARRAY
51532: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51533: LD_VAR 0 2
51537: PPUSH
51538: LD_VAR 0 3
51542: PPUSH
51543: CALL 51792 0 2
51547: NOT
51548: IFFALSE 51607
// repeat engine := _engine [ 1 ] ;
51550: LD_ADDR_VAR 0 3
51554: PUSH
51555: LD_VAR 0 11
51559: PUSH
51560: LD_INT 1
51562: ARRAY
51563: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51564: LD_ADDR_VAR 0 11
51568: PUSH
51569: LD_VAR 0 11
51573: PPUSH
51574: LD_INT 1
51576: PPUSH
51577: CALL_OW 3
51581: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51582: LD_VAR 0 2
51586: PPUSH
51587: LD_VAR 0 3
51591: PPUSH
51592: CALL 51792 0 2
51596: PUSH
51597: LD_VAR 0 11
51601: PUSH
51602: EMPTY
51603: EQUAL
51604: OR
51605: IFFALSE 51550
// if not control in _control then
51607: LD_VAR 0 4
51611: PUSH
51612: LD_VAR 0 12
51616: IN
51617: NOT
51618: IFFALSE 51644
// control := _control [ rand ( 1 , _control ) ] ;
51620: LD_ADDR_VAR 0 4
51624: PUSH
51625: LD_VAR 0 12
51629: PUSH
51630: LD_INT 1
51632: PPUSH
51633: LD_VAR 0 12
51637: PPUSH
51638: CALL_OW 12
51642: ARRAY
51643: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51644: LD_VAR 0 2
51648: PPUSH
51649: LD_VAR 0 5
51653: PPUSH
51654: CALL 52012 0 2
51658: NOT
51659: IFFALSE 51718
// repeat weapon := _weapon [ 1 ] ;
51661: LD_ADDR_VAR 0 5
51665: PUSH
51666: LD_VAR 0 10
51670: PUSH
51671: LD_INT 1
51673: ARRAY
51674: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51675: LD_ADDR_VAR 0 10
51679: PUSH
51680: LD_VAR 0 10
51684: PPUSH
51685: LD_INT 1
51687: PPUSH
51688: CALL_OW 3
51692: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51693: LD_VAR 0 2
51697: PPUSH
51698: LD_VAR 0 5
51702: PPUSH
51703: CALL 52012 0 2
51707: PUSH
51708: LD_VAR 0 10
51712: PUSH
51713: EMPTY
51714: EQUAL
51715: OR
51716: IFFALSE 51661
// result := [ ] ;
51718: LD_ADDR_VAR 0 6
51722: PUSH
51723: EMPTY
51724: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51725: LD_VAR 0 1
51729: PPUSH
51730: LD_VAR 0 2
51734: PPUSH
51735: LD_VAR 0 3
51739: PPUSH
51740: LD_VAR 0 4
51744: PPUSH
51745: LD_VAR 0 5
51749: PPUSH
51750: CALL_OW 448
51754: IFFALSE 51787
// result := [ chassis , engine , control , weapon ] ;
51756: LD_ADDR_VAR 0 6
51760: PUSH
51761: LD_VAR 0 2
51765: PUSH
51766: LD_VAR 0 3
51770: PUSH
51771: LD_VAR 0 4
51775: PUSH
51776: LD_VAR 0 5
51780: PUSH
51781: EMPTY
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: ST_TO_ADDR
// end ;
51787: LD_VAR 0 6
51791: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51792: LD_INT 0
51794: PPUSH
// if not chassis or not engine then
51795: LD_VAR 0 1
51799: NOT
51800: PUSH
51801: LD_VAR 0 2
51805: NOT
51806: OR
51807: IFFALSE 51811
// exit ;
51809: GO 52007
// case engine of engine_solar :
51811: LD_VAR 0 2
51815: PUSH
51816: LD_INT 2
51818: DOUBLE
51819: EQUAL
51820: IFTRUE 51824
51822: GO 51862
51824: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51825: LD_ADDR_VAR 0 3
51829: PUSH
51830: LD_INT 11
51832: PUSH
51833: LD_INT 12
51835: PUSH
51836: LD_INT 13
51838: PUSH
51839: LD_INT 14
51841: PUSH
51842: LD_INT 1
51844: PUSH
51845: LD_INT 2
51847: PUSH
51848: LD_INT 3
51850: PUSH
51851: EMPTY
51852: LIST
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: ST_TO_ADDR
51860: GO 51991
51862: LD_INT 1
51864: DOUBLE
51865: EQUAL
51866: IFTRUE 51870
51868: GO 51932
51870: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51871: LD_ADDR_VAR 0 3
51875: PUSH
51876: LD_INT 11
51878: PUSH
51879: LD_INT 12
51881: PUSH
51882: LD_INT 13
51884: PUSH
51885: LD_INT 14
51887: PUSH
51888: LD_INT 1
51890: PUSH
51891: LD_INT 2
51893: PUSH
51894: LD_INT 3
51896: PUSH
51897: LD_INT 4
51899: PUSH
51900: LD_INT 5
51902: PUSH
51903: LD_INT 21
51905: PUSH
51906: LD_INT 23
51908: PUSH
51909: LD_INT 22
51911: PUSH
51912: LD_INT 24
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: LIST
51919: LIST
51920: LIST
51921: LIST
51922: LIST
51923: LIST
51924: LIST
51925: LIST
51926: LIST
51927: LIST
51928: LIST
51929: ST_TO_ADDR
51930: GO 51991
51932: LD_INT 3
51934: DOUBLE
51935: EQUAL
51936: IFTRUE 51940
51938: GO 51990
51940: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51941: LD_ADDR_VAR 0 3
51945: PUSH
51946: LD_INT 13
51948: PUSH
51949: LD_INT 14
51951: PUSH
51952: LD_INT 2
51954: PUSH
51955: LD_INT 3
51957: PUSH
51958: LD_INT 4
51960: PUSH
51961: LD_INT 5
51963: PUSH
51964: LD_INT 21
51966: PUSH
51967: LD_INT 22
51969: PUSH
51970: LD_INT 23
51972: PUSH
51973: LD_INT 24
51975: PUSH
51976: EMPTY
51977: LIST
51978: LIST
51979: LIST
51980: LIST
51981: LIST
51982: LIST
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: ST_TO_ADDR
51988: GO 51991
51990: POP
// result := ( chassis in result ) ;
51991: LD_ADDR_VAR 0 3
51995: PUSH
51996: LD_VAR 0 1
52000: PUSH
52001: LD_VAR 0 3
52005: IN
52006: ST_TO_ADDR
// end ;
52007: LD_VAR 0 3
52011: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52012: LD_INT 0
52014: PPUSH
// if not chassis or not weapon then
52015: LD_VAR 0 1
52019: NOT
52020: PUSH
52021: LD_VAR 0 2
52025: NOT
52026: OR
52027: IFFALSE 52031
// exit ;
52029: GO 53091
// case weapon of us_machine_gun :
52031: LD_VAR 0 2
52035: PUSH
52036: LD_INT 2
52038: DOUBLE
52039: EQUAL
52040: IFTRUE 52044
52042: GO 52074
52044: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52045: LD_ADDR_VAR 0 3
52049: PUSH
52050: LD_INT 1
52052: PUSH
52053: LD_INT 2
52055: PUSH
52056: LD_INT 3
52058: PUSH
52059: LD_INT 4
52061: PUSH
52062: LD_INT 5
52064: PUSH
52065: EMPTY
52066: LIST
52067: LIST
52068: LIST
52069: LIST
52070: LIST
52071: ST_TO_ADDR
52072: GO 53075
52074: LD_INT 3
52076: DOUBLE
52077: EQUAL
52078: IFTRUE 52082
52080: GO 52112
52082: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52083: LD_ADDR_VAR 0 3
52087: PUSH
52088: LD_INT 1
52090: PUSH
52091: LD_INT 2
52093: PUSH
52094: LD_INT 3
52096: PUSH
52097: LD_INT 4
52099: PUSH
52100: LD_INT 5
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: ST_TO_ADDR
52110: GO 53075
52112: LD_INT 11
52114: DOUBLE
52115: EQUAL
52116: IFTRUE 52120
52118: GO 52150
52120: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52121: LD_ADDR_VAR 0 3
52125: PUSH
52126: LD_INT 1
52128: PUSH
52129: LD_INT 2
52131: PUSH
52132: LD_INT 3
52134: PUSH
52135: LD_INT 4
52137: PUSH
52138: LD_INT 5
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: LIST
52145: LIST
52146: LIST
52147: ST_TO_ADDR
52148: GO 53075
52150: LD_INT 4
52152: DOUBLE
52153: EQUAL
52154: IFTRUE 52158
52156: GO 52184
52158: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52159: LD_ADDR_VAR 0 3
52163: PUSH
52164: LD_INT 2
52166: PUSH
52167: LD_INT 3
52169: PUSH
52170: LD_INT 4
52172: PUSH
52173: LD_INT 5
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: LIST
52180: LIST
52181: ST_TO_ADDR
52182: GO 53075
52184: LD_INT 5
52186: DOUBLE
52187: EQUAL
52188: IFTRUE 52192
52190: GO 52218
52192: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52193: LD_ADDR_VAR 0 3
52197: PUSH
52198: LD_INT 2
52200: PUSH
52201: LD_INT 3
52203: PUSH
52204: LD_INT 4
52206: PUSH
52207: LD_INT 5
52209: PUSH
52210: EMPTY
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: ST_TO_ADDR
52216: GO 53075
52218: LD_INT 9
52220: DOUBLE
52221: EQUAL
52222: IFTRUE 52226
52224: GO 52252
52226: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52227: LD_ADDR_VAR 0 3
52231: PUSH
52232: LD_INT 2
52234: PUSH
52235: LD_INT 3
52237: PUSH
52238: LD_INT 4
52240: PUSH
52241: LD_INT 5
52243: PUSH
52244: EMPTY
52245: LIST
52246: LIST
52247: LIST
52248: LIST
52249: ST_TO_ADDR
52250: GO 53075
52252: LD_INT 7
52254: DOUBLE
52255: EQUAL
52256: IFTRUE 52260
52258: GO 52286
52260: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52261: LD_ADDR_VAR 0 3
52265: PUSH
52266: LD_INT 2
52268: PUSH
52269: LD_INT 3
52271: PUSH
52272: LD_INT 4
52274: PUSH
52275: LD_INT 5
52277: PUSH
52278: EMPTY
52279: LIST
52280: LIST
52281: LIST
52282: LIST
52283: ST_TO_ADDR
52284: GO 53075
52286: LD_INT 12
52288: DOUBLE
52289: EQUAL
52290: IFTRUE 52294
52292: GO 52320
52294: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52295: LD_ADDR_VAR 0 3
52299: PUSH
52300: LD_INT 2
52302: PUSH
52303: LD_INT 3
52305: PUSH
52306: LD_INT 4
52308: PUSH
52309: LD_INT 5
52311: PUSH
52312: EMPTY
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: ST_TO_ADDR
52318: GO 53075
52320: LD_INT 13
52322: DOUBLE
52323: EQUAL
52324: IFTRUE 52328
52326: GO 52354
52328: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52329: LD_ADDR_VAR 0 3
52333: PUSH
52334: LD_INT 2
52336: PUSH
52337: LD_INT 3
52339: PUSH
52340: LD_INT 4
52342: PUSH
52343: LD_INT 5
52345: PUSH
52346: EMPTY
52347: LIST
52348: LIST
52349: LIST
52350: LIST
52351: ST_TO_ADDR
52352: GO 53075
52354: LD_INT 14
52356: DOUBLE
52357: EQUAL
52358: IFTRUE 52362
52360: GO 52380
52362: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52363: LD_ADDR_VAR 0 3
52367: PUSH
52368: LD_INT 4
52370: PUSH
52371: LD_INT 5
52373: PUSH
52374: EMPTY
52375: LIST
52376: LIST
52377: ST_TO_ADDR
52378: GO 53075
52380: LD_INT 6
52382: DOUBLE
52383: EQUAL
52384: IFTRUE 52388
52386: GO 52406
52388: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52389: LD_ADDR_VAR 0 3
52393: PUSH
52394: LD_INT 4
52396: PUSH
52397: LD_INT 5
52399: PUSH
52400: EMPTY
52401: LIST
52402: LIST
52403: ST_TO_ADDR
52404: GO 53075
52406: LD_INT 10
52408: DOUBLE
52409: EQUAL
52410: IFTRUE 52414
52412: GO 52432
52414: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52415: LD_ADDR_VAR 0 3
52419: PUSH
52420: LD_INT 4
52422: PUSH
52423: LD_INT 5
52425: PUSH
52426: EMPTY
52427: LIST
52428: LIST
52429: ST_TO_ADDR
52430: GO 53075
52432: LD_INT 22
52434: DOUBLE
52435: EQUAL
52436: IFTRUE 52440
52438: GO 52466
52440: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52441: LD_ADDR_VAR 0 3
52445: PUSH
52446: LD_INT 11
52448: PUSH
52449: LD_INT 12
52451: PUSH
52452: LD_INT 13
52454: PUSH
52455: LD_INT 14
52457: PUSH
52458: EMPTY
52459: LIST
52460: LIST
52461: LIST
52462: LIST
52463: ST_TO_ADDR
52464: GO 53075
52466: LD_INT 23
52468: DOUBLE
52469: EQUAL
52470: IFTRUE 52474
52472: GO 52500
52474: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52475: LD_ADDR_VAR 0 3
52479: PUSH
52480: LD_INT 11
52482: PUSH
52483: LD_INT 12
52485: PUSH
52486: LD_INT 13
52488: PUSH
52489: LD_INT 14
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: LIST
52496: LIST
52497: ST_TO_ADDR
52498: GO 53075
52500: LD_INT 24
52502: DOUBLE
52503: EQUAL
52504: IFTRUE 52508
52506: GO 52534
52508: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52509: LD_ADDR_VAR 0 3
52513: PUSH
52514: LD_INT 11
52516: PUSH
52517: LD_INT 12
52519: PUSH
52520: LD_INT 13
52522: PUSH
52523: LD_INT 14
52525: PUSH
52526: EMPTY
52527: LIST
52528: LIST
52529: LIST
52530: LIST
52531: ST_TO_ADDR
52532: GO 53075
52534: LD_INT 30
52536: DOUBLE
52537: EQUAL
52538: IFTRUE 52542
52540: GO 52568
52542: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52543: LD_ADDR_VAR 0 3
52547: PUSH
52548: LD_INT 11
52550: PUSH
52551: LD_INT 12
52553: PUSH
52554: LD_INT 13
52556: PUSH
52557: LD_INT 14
52559: PUSH
52560: EMPTY
52561: LIST
52562: LIST
52563: LIST
52564: LIST
52565: ST_TO_ADDR
52566: GO 53075
52568: LD_INT 25
52570: DOUBLE
52571: EQUAL
52572: IFTRUE 52576
52574: GO 52594
52576: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52577: LD_ADDR_VAR 0 3
52581: PUSH
52582: LD_INT 13
52584: PUSH
52585: LD_INT 14
52587: PUSH
52588: EMPTY
52589: LIST
52590: LIST
52591: ST_TO_ADDR
52592: GO 53075
52594: LD_INT 27
52596: DOUBLE
52597: EQUAL
52598: IFTRUE 52602
52600: GO 52620
52602: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52603: LD_ADDR_VAR 0 3
52607: PUSH
52608: LD_INT 13
52610: PUSH
52611: LD_INT 14
52613: PUSH
52614: EMPTY
52615: LIST
52616: LIST
52617: ST_TO_ADDR
52618: GO 53075
52620: LD_INT 92
52622: DOUBLE
52623: EQUAL
52624: IFTRUE 52628
52626: GO 52654
52628: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52629: LD_ADDR_VAR 0 3
52633: PUSH
52634: LD_INT 11
52636: PUSH
52637: LD_INT 12
52639: PUSH
52640: LD_INT 13
52642: PUSH
52643: LD_INT 14
52645: PUSH
52646: EMPTY
52647: LIST
52648: LIST
52649: LIST
52650: LIST
52651: ST_TO_ADDR
52652: GO 53075
52654: LD_INT 28
52656: DOUBLE
52657: EQUAL
52658: IFTRUE 52662
52660: GO 52680
52662: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52663: LD_ADDR_VAR 0 3
52667: PUSH
52668: LD_INT 13
52670: PUSH
52671: LD_INT 14
52673: PUSH
52674: EMPTY
52675: LIST
52676: LIST
52677: ST_TO_ADDR
52678: GO 53075
52680: LD_INT 29
52682: DOUBLE
52683: EQUAL
52684: IFTRUE 52688
52686: GO 52706
52688: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52689: LD_ADDR_VAR 0 3
52693: PUSH
52694: LD_INT 13
52696: PUSH
52697: LD_INT 14
52699: PUSH
52700: EMPTY
52701: LIST
52702: LIST
52703: ST_TO_ADDR
52704: GO 53075
52706: LD_INT 31
52708: DOUBLE
52709: EQUAL
52710: IFTRUE 52714
52712: GO 52732
52714: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52715: LD_ADDR_VAR 0 3
52719: PUSH
52720: LD_INT 13
52722: PUSH
52723: LD_INT 14
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: ST_TO_ADDR
52730: GO 53075
52732: LD_INT 26
52734: DOUBLE
52735: EQUAL
52736: IFTRUE 52740
52738: GO 52758
52740: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52741: LD_ADDR_VAR 0 3
52745: PUSH
52746: LD_INT 13
52748: PUSH
52749: LD_INT 14
52751: PUSH
52752: EMPTY
52753: LIST
52754: LIST
52755: ST_TO_ADDR
52756: GO 53075
52758: LD_INT 42
52760: DOUBLE
52761: EQUAL
52762: IFTRUE 52766
52764: GO 52792
52766: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52767: LD_ADDR_VAR 0 3
52771: PUSH
52772: LD_INT 21
52774: PUSH
52775: LD_INT 22
52777: PUSH
52778: LD_INT 23
52780: PUSH
52781: LD_INT 24
52783: PUSH
52784: EMPTY
52785: LIST
52786: LIST
52787: LIST
52788: LIST
52789: ST_TO_ADDR
52790: GO 53075
52792: LD_INT 43
52794: DOUBLE
52795: EQUAL
52796: IFTRUE 52800
52798: GO 52826
52800: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52801: LD_ADDR_VAR 0 3
52805: PUSH
52806: LD_INT 21
52808: PUSH
52809: LD_INT 22
52811: PUSH
52812: LD_INT 23
52814: PUSH
52815: LD_INT 24
52817: PUSH
52818: EMPTY
52819: LIST
52820: LIST
52821: LIST
52822: LIST
52823: ST_TO_ADDR
52824: GO 53075
52826: LD_INT 44
52828: DOUBLE
52829: EQUAL
52830: IFTRUE 52834
52832: GO 52860
52834: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52835: LD_ADDR_VAR 0 3
52839: PUSH
52840: LD_INT 21
52842: PUSH
52843: LD_INT 22
52845: PUSH
52846: LD_INT 23
52848: PUSH
52849: LD_INT 24
52851: PUSH
52852: EMPTY
52853: LIST
52854: LIST
52855: LIST
52856: LIST
52857: ST_TO_ADDR
52858: GO 53075
52860: LD_INT 45
52862: DOUBLE
52863: EQUAL
52864: IFTRUE 52868
52866: GO 52894
52868: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52869: LD_ADDR_VAR 0 3
52873: PUSH
52874: LD_INT 21
52876: PUSH
52877: LD_INT 22
52879: PUSH
52880: LD_INT 23
52882: PUSH
52883: LD_INT 24
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: LIST
52890: LIST
52891: ST_TO_ADDR
52892: GO 53075
52894: LD_INT 49
52896: DOUBLE
52897: EQUAL
52898: IFTRUE 52902
52900: GO 52928
52902: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52903: LD_ADDR_VAR 0 3
52907: PUSH
52908: LD_INT 21
52910: PUSH
52911: LD_INT 22
52913: PUSH
52914: LD_INT 23
52916: PUSH
52917: LD_INT 24
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: LIST
52924: LIST
52925: ST_TO_ADDR
52926: GO 53075
52928: LD_INT 51
52930: DOUBLE
52931: EQUAL
52932: IFTRUE 52936
52934: GO 52962
52936: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52937: LD_ADDR_VAR 0 3
52941: PUSH
52942: LD_INT 21
52944: PUSH
52945: LD_INT 22
52947: PUSH
52948: LD_INT 23
52950: PUSH
52951: LD_INT 24
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: LIST
52958: LIST
52959: ST_TO_ADDR
52960: GO 53075
52962: LD_INT 52
52964: DOUBLE
52965: EQUAL
52966: IFTRUE 52970
52968: GO 52996
52970: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52971: LD_ADDR_VAR 0 3
52975: PUSH
52976: LD_INT 21
52978: PUSH
52979: LD_INT 22
52981: PUSH
52982: LD_INT 23
52984: PUSH
52985: LD_INT 24
52987: PUSH
52988: EMPTY
52989: LIST
52990: LIST
52991: LIST
52992: LIST
52993: ST_TO_ADDR
52994: GO 53075
52996: LD_INT 53
52998: DOUBLE
52999: EQUAL
53000: IFTRUE 53004
53002: GO 53022
53004: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53005: LD_ADDR_VAR 0 3
53009: PUSH
53010: LD_INT 23
53012: PUSH
53013: LD_INT 24
53015: PUSH
53016: EMPTY
53017: LIST
53018: LIST
53019: ST_TO_ADDR
53020: GO 53075
53022: LD_INT 46
53024: DOUBLE
53025: EQUAL
53026: IFTRUE 53030
53028: GO 53048
53030: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53031: LD_ADDR_VAR 0 3
53035: PUSH
53036: LD_INT 23
53038: PUSH
53039: LD_INT 24
53041: PUSH
53042: EMPTY
53043: LIST
53044: LIST
53045: ST_TO_ADDR
53046: GO 53075
53048: LD_INT 47
53050: DOUBLE
53051: EQUAL
53052: IFTRUE 53056
53054: GO 53074
53056: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53057: LD_ADDR_VAR 0 3
53061: PUSH
53062: LD_INT 23
53064: PUSH
53065: LD_INT 24
53067: PUSH
53068: EMPTY
53069: LIST
53070: LIST
53071: ST_TO_ADDR
53072: GO 53075
53074: POP
// result := ( chassis in result ) ;
53075: LD_ADDR_VAR 0 3
53079: PUSH
53080: LD_VAR 0 1
53084: PUSH
53085: LD_VAR 0 3
53089: IN
53090: ST_TO_ADDR
// end ;
53091: LD_VAR 0 3
53095: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53096: LD_INT 0
53098: PPUSH
53099: PPUSH
53100: PPUSH
53101: PPUSH
53102: PPUSH
53103: PPUSH
53104: PPUSH
// result := array ;
53105: LD_ADDR_VAR 0 5
53109: PUSH
53110: LD_VAR 0 1
53114: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53115: LD_VAR 0 1
53119: NOT
53120: PUSH
53121: LD_VAR 0 2
53125: NOT
53126: OR
53127: PUSH
53128: LD_VAR 0 3
53132: NOT
53133: OR
53134: PUSH
53135: LD_VAR 0 2
53139: PUSH
53140: LD_VAR 0 1
53144: GREATER
53145: OR
53146: PUSH
53147: LD_VAR 0 3
53151: PUSH
53152: LD_VAR 0 1
53156: GREATER
53157: OR
53158: IFFALSE 53162
// exit ;
53160: GO 53458
// if direction then
53162: LD_VAR 0 4
53166: IFFALSE 53230
// begin d := 1 ;
53168: LD_ADDR_VAR 0 9
53172: PUSH
53173: LD_INT 1
53175: ST_TO_ADDR
// if i_from > i_to then
53176: LD_VAR 0 2
53180: PUSH
53181: LD_VAR 0 3
53185: GREATER
53186: IFFALSE 53212
// length := ( array - i_from ) + i_to else
53188: LD_ADDR_VAR 0 11
53192: PUSH
53193: LD_VAR 0 1
53197: PUSH
53198: LD_VAR 0 2
53202: MINUS
53203: PUSH
53204: LD_VAR 0 3
53208: PLUS
53209: ST_TO_ADDR
53210: GO 53228
// length := i_to - i_from ;
53212: LD_ADDR_VAR 0 11
53216: PUSH
53217: LD_VAR 0 3
53221: PUSH
53222: LD_VAR 0 2
53226: MINUS
53227: ST_TO_ADDR
// end else
53228: GO 53291
// begin d := - 1 ;
53230: LD_ADDR_VAR 0 9
53234: PUSH
53235: LD_INT 1
53237: NEG
53238: ST_TO_ADDR
// if i_from > i_to then
53239: LD_VAR 0 2
53243: PUSH
53244: LD_VAR 0 3
53248: GREATER
53249: IFFALSE 53269
// length := i_from - i_to else
53251: LD_ADDR_VAR 0 11
53255: PUSH
53256: LD_VAR 0 2
53260: PUSH
53261: LD_VAR 0 3
53265: MINUS
53266: ST_TO_ADDR
53267: GO 53291
// length := ( array - i_to ) + i_from ;
53269: LD_ADDR_VAR 0 11
53273: PUSH
53274: LD_VAR 0 1
53278: PUSH
53279: LD_VAR 0 3
53283: MINUS
53284: PUSH
53285: LD_VAR 0 2
53289: PLUS
53290: ST_TO_ADDR
// end ; if not length then
53291: LD_VAR 0 11
53295: NOT
53296: IFFALSE 53300
// exit ;
53298: GO 53458
// tmp := array ;
53300: LD_ADDR_VAR 0 10
53304: PUSH
53305: LD_VAR 0 1
53309: ST_TO_ADDR
// for i = 1 to length do
53310: LD_ADDR_VAR 0 6
53314: PUSH
53315: DOUBLE
53316: LD_INT 1
53318: DEC
53319: ST_TO_ADDR
53320: LD_VAR 0 11
53324: PUSH
53325: FOR_TO
53326: IFFALSE 53446
// begin for j = 1 to array do
53328: LD_ADDR_VAR 0 7
53332: PUSH
53333: DOUBLE
53334: LD_INT 1
53336: DEC
53337: ST_TO_ADDR
53338: LD_VAR 0 1
53342: PUSH
53343: FOR_TO
53344: IFFALSE 53432
// begin k := j + d ;
53346: LD_ADDR_VAR 0 8
53350: PUSH
53351: LD_VAR 0 7
53355: PUSH
53356: LD_VAR 0 9
53360: PLUS
53361: ST_TO_ADDR
// if k > array then
53362: LD_VAR 0 8
53366: PUSH
53367: LD_VAR 0 1
53371: GREATER
53372: IFFALSE 53382
// k := 1 ;
53374: LD_ADDR_VAR 0 8
53378: PUSH
53379: LD_INT 1
53381: ST_TO_ADDR
// if not k then
53382: LD_VAR 0 8
53386: NOT
53387: IFFALSE 53399
// k := array ;
53389: LD_ADDR_VAR 0 8
53393: PUSH
53394: LD_VAR 0 1
53398: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53399: LD_ADDR_VAR 0 10
53403: PUSH
53404: LD_VAR 0 10
53408: PPUSH
53409: LD_VAR 0 8
53413: PPUSH
53414: LD_VAR 0 1
53418: PUSH
53419: LD_VAR 0 7
53423: ARRAY
53424: PPUSH
53425: CALL_OW 1
53429: ST_TO_ADDR
// end ;
53430: GO 53343
53432: POP
53433: POP
// array := tmp ;
53434: LD_ADDR_VAR 0 1
53438: PUSH
53439: LD_VAR 0 10
53443: ST_TO_ADDR
// end ;
53444: GO 53325
53446: POP
53447: POP
// result := array ;
53448: LD_ADDR_VAR 0 5
53452: PUSH
53453: LD_VAR 0 1
53457: ST_TO_ADDR
// end ;
53458: LD_VAR 0 5
53462: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53463: LD_INT 0
53465: PPUSH
53466: PPUSH
// result := 0 ;
53467: LD_ADDR_VAR 0 3
53471: PUSH
53472: LD_INT 0
53474: ST_TO_ADDR
// if not array or not value in array then
53475: LD_VAR 0 1
53479: NOT
53480: PUSH
53481: LD_VAR 0 2
53485: PUSH
53486: LD_VAR 0 1
53490: IN
53491: NOT
53492: OR
53493: IFFALSE 53497
// exit ;
53495: GO 53551
// for i = 1 to array do
53497: LD_ADDR_VAR 0 4
53501: PUSH
53502: DOUBLE
53503: LD_INT 1
53505: DEC
53506: ST_TO_ADDR
53507: LD_VAR 0 1
53511: PUSH
53512: FOR_TO
53513: IFFALSE 53549
// if value = array [ i ] then
53515: LD_VAR 0 2
53519: PUSH
53520: LD_VAR 0 1
53524: PUSH
53525: LD_VAR 0 4
53529: ARRAY
53530: EQUAL
53531: IFFALSE 53547
// begin result := i ;
53533: LD_ADDR_VAR 0 3
53537: PUSH
53538: LD_VAR 0 4
53542: ST_TO_ADDR
// exit ;
53543: POP
53544: POP
53545: GO 53551
// end ;
53547: GO 53512
53549: POP
53550: POP
// end ;
53551: LD_VAR 0 3
53555: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53556: LD_INT 0
53558: PPUSH
// vc_chassis := chassis ;
53559: LD_ADDR_OWVAR 37
53563: PUSH
53564: LD_VAR 0 1
53568: ST_TO_ADDR
// vc_engine := engine ;
53569: LD_ADDR_OWVAR 39
53573: PUSH
53574: LD_VAR 0 2
53578: ST_TO_ADDR
// vc_control := control ;
53579: LD_ADDR_OWVAR 38
53583: PUSH
53584: LD_VAR 0 3
53588: ST_TO_ADDR
// vc_weapon := weapon ;
53589: LD_ADDR_OWVAR 40
53593: PUSH
53594: LD_VAR 0 4
53598: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53599: LD_ADDR_OWVAR 41
53603: PUSH
53604: LD_VAR 0 5
53608: ST_TO_ADDR
// end ;
53609: LD_VAR 0 6
53613: RET
// export function WantPlant ( unit ) ; var task ; begin
53614: LD_INT 0
53616: PPUSH
53617: PPUSH
// result := false ;
53618: LD_ADDR_VAR 0 2
53622: PUSH
53623: LD_INT 0
53625: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53626: LD_ADDR_VAR 0 3
53630: PUSH
53631: LD_VAR 0 1
53635: PPUSH
53636: CALL_OW 437
53640: ST_TO_ADDR
// if task then
53641: LD_VAR 0 3
53645: IFFALSE 53673
// if task [ 1 ] [ 1 ] = p then
53647: LD_VAR 0 3
53651: PUSH
53652: LD_INT 1
53654: ARRAY
53655: PUSH
53656: LD_INT 1
53658: ARRAY
53659: PUSH
53660: LD_STRING p
53662: EQUAL
53663: IFFALSE 53673
// result := true ;
53665: LD_ADDR_VAR 0 2
53669: PUSH
53670: LD_INT 1
53672: ST_TO_ADDR
// end ;
53673: LD_VAR 0 2
53677: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53678: LD_INT 0
53680: PPUSH
53681: PPUSH
53682: PPUSH
53683: PPUSH
// if pos < 1 then
53684: LD_VAR 0 2
53688: PUSH
53689: LD_INT 1
53691: LESS
53692: IFFALSE 53696
// exit ;
53694: GO 53999
// if pos = 1 then
53696: LD_VAR 0 2
53700: PUSH
53701: LD_INT 1
53703: EQUAL
53704: IFFALSE 53737
// result := Replace ( arr , pos [ 1 ] , value ) else
53706: LD_ADDR_VAR 0 4
53710: PUSH
53711: LD_VAR 0 1
53715: PPUSH
53716: LD_VAR 0 2
53720: PUSH
53721: LD_INT 1
53723: ARRAY
53724: PPUSH
53725: LD_VAR 0 3
53729: PPUSH
53730: CALL_OW 1
53734: ST_TO_ADDR
53735: GO 53999
// begin tmp := arr ;
53737: LD_ADDR_VAR 0 6
53741: PUSH
53742: LD_VAR 0 1
53746: ST_TO_ADDR
// s_arr := [ tmp ] ;
53747: LD_ADDR_VAR 0 7
53751: PUSH
53752: LD_VAR 0 6
53756: PUSH
53757: EMPTY
53758: LIST
53759: ST_TO_ADDR
// for i = 1 to pos - 1 do
53760: LD_ADDR_VAR 0 5
53764: PUSH
53765: DOUBLE
53766: LD_INT 1
53768: DEC
53769: ST_TO_ADDR
53770: LD_VAR 0 2
53774: PUSH
53775: LD_INT 1
53777: MINUS
53778: PUSH
53779: FOR_TO
53780: IFFALSE 53825
// begin tmp := tmp [ pos [ i ] ] ;
53782: LD_ADDR_VAR 0 6
53786: PUSH
53787: LD_VAR 0 6
53791: PUSH
53792: LD_VAR 0 2
53796: PUSH
53797: LD_VAR 0 5
53801: ARRAY
53802: ARRAY
53803: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53804: LD_ADDR_VAR 0 7
53808: PUSH
53809: LD_VAR 0 7
53813: PUSH
53814: LD_VAR 0 6
53818: PUSH
53819: EMPTY
53820: LIST
53821: ADD
53822: ST_TO_ADDR
// end ;
53823: GO 53779
53825: POP
53826: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53827: LD_ADDR_VAR 0 6
53831: PUSH
53832: LD_VAR 0 6
53836: PPUSH
53837: LD_VAR 0 2
53841: PUSH
53842: LD_VAR 0 2
53846: ARRAY
53847: PPUSH
53848: LD_VAR 0 3
53852: PPUSH
53853: CALL_OW 1
53857: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53858: LD_ADDR_VAR 0 7
53862: PUSH
53863: LD_VAR 0 7
53867: PPUSH
53868: LD_VAR 0 7
53872: PPUSH
53873: LD_VAR 0 6
53877: PPUSH
53878: CALL_OW 1
53882: ST_TO_ADDR
// for i = s_arr downto 2 do
53883: LD_ADDR_VAR 0 5
53887: PUSH
53888: DOUBLE
53889: LD_VAR 0 7
53893: INC
53894: ST_TO_ADDR
53895: LD_INT 2
53897: PUSH
53898: FOR_DOWNTO
53899: IFFALSE 53983
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53901: LD_ADDR_VAR 0 6
53905: PUSH
53906: LD_VAR 0 7
53910: PUSH
53911: LD_VAR 0 5
53915: PUSH
53916: LD_INT 1
53918: MINUS
53919: ARRAY
53920: PPUSH
53921: LD_VAR 0 2
53925: PUSH
53926: LD_VAR 0 5
53930: PUSH
53931: LD_INT 1
53933: MINUS
53934: ARRAY
53935: PPUSH
53936: LD_VAR 0 7
53940: PUSH
53941: LD_VAR 0 5
53945: ARRAY
53946: PPUSH
53947: CALL_OW 1
53951: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53952: LD_ADDR_VAR 0 7
53956: PUSH
53957: LD_VAR 0 7
53961: PPUSH
53962: LD_VAR 0 5
53966: PUSH
53967: LD_INT 1
53969: MINUS
53970: PPUSH
53971: LD_VAR 0 6
53975: PPUSH
53976: CALL_OW 1
53980: ST_TO_ADDR
// end ;
53981: GO 53898
53983: POP
53984: POP
// result := s_arr [ 1 ] ;
53985: LD_ADDR_VAR 0 4
53989: PUSH
53990: LD_VAR 0 7
53994: PUSH
53995: LD_INT 1
53997: ARRAY
53998: ST_TO_ADDR
// end ; end ;
53999: LD_VAR 0 4
54003: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54004: LD_INT 0
54006: PPUSH
54007: PPUSH
// if not list then
54008: LD_VAR 0 1
54012: NOT
54013: IFFALSE 54017
// exit ;
54015: GO 54108
// i := list [ pos1 ] ;
54017: LD_ADDR_VAR 0 5
54021: PUSH
54022: LD_VAR 0 1
54026: PUSH
54027: LD_VAR 0 2
54031: ARRAY
54032: ST_TO_ADDR
// if not i then
54033: LD_VAR 0 5
54037: NOT
54038: IFFALSE 54042
// exit ;
54040: GO 54108
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54042: LD_ADDR_VAR 0 1
54046: PUSH
54047: LD_VAR 0 1
54051: PPUSH
54052: LD_VAR 0 2
54056: PPUSH
54057: LD_VAR 0 1
54061: PUSH
54062: LD_VAR 0 3
54066: ARRAY
54067: PPUSH
54068: CALL_OW 1
54072: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54073: LD_ADDR_VAR 0 1
54077: PUSH
54078: LD_VAR 0 1
54082: PPUSH
54083: LD_VAR 0 3
54087: PPUSH
54088: LD_VAR 0 5
54092: PPUSH
54093: CALL_OW 1
54097: ST_TO_ADDR
// result := list ;
54098: LD_ADDR_VAR 0 4
54102: PUSH
54103: LD_VAR 0 1
54107: ST_TO_ADDR
// end ;
54108: LD_VAR 0 4
54112: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54113: LD_INT 0
54115: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54116: LD_ADDR_VAR 0 5
54120: PUSH
54121: LD_VAR 0 1
54125: PPUSH
54126: CALL_OW 250
54130: PPUSH
54131: LD_VAR 0 1
54135: PPUSH
54136: CALL_OW 251
54140: PPUSH
54141: LD_VAR 0 2
54145: PPUSH
54146: LD_VAR 0 3
54150: PPUSH
54151: LD_VAR 0 4
54155: PPUSH
54156: CALL 54166 0 5
54160: ST_TO_ADDR
// end ;
54161: LD_VAR 0 5
54165: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54166: LD_INT 0
54168: PPUSH
54169: PPUSH
54170: PPUSH
54171: PPUSH
// if not list then
54172: LD_VAR 0 3
54176: NOT
54177: IFFALSE 54181
// exit ;
54179: GO 54569
// result := [ ] ;
54181: LD_ADDR_VAR 0 6
54185: PUSH
54186: EMPTY
54187: ST_TO_ADDR
// for i in list do
54188: LD_ADDR_VAR 0 7
54192: PUSH
54193: LD_VAR 0 3
54197: PUSH
54198: FOR_IN
54199: IFFALSE 54401
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54201: LD_ADDR_VAR 0 9
54205: PUSH
54206: LD_VAR 0 7
54210: PPUSH
54211: LD_VAR 0 1
54215: PPUSH
54216: LD_VAR 0 2
54220: PPUSH
54221: CALL_OW 297
54225: ST_TO_ADDR
// if not result then
54226: LD_VAR 0 6
54230: NOT
54231: IFFALSE 54257
// result := [ [ i , tmp ] ] else
54233: LD_ADDR_VAR 0 6
54237: PUSH
54238: LD_VAR 0 7
54242: PUSH
54243: LD_VAR 0 9
54247: PUSH
54248: EMPTY
54249: LIST
54250: LIST
54251: PUSH
54252: EMPTY
54253: LIST
54254: ST_TO_ADDR
54255: GO 54399
// begin if result [ result ] [ 2 ] < tmp then
54257: LD_VAR 0 6
54261: PUSH
54262: LD_VAR 0 6
54266: ARRAY
54267: PUSH
54268: LD_INT 2
54270: ARRAY
54271: PUSH
54272: LD_VAR 0 9
54276: LESS
54277: IFFALSE 54319
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54279: LD_ADDR_VAR 0 6
54283: PUSH
54284: LD_VAR 0 6
54288: PPUSH
54289: LD_VAR 0 6
54293: PUSH
54294: LD_INT 1
54296: PLUS
54297: PPUSH
54298: LD_VAR 0 7
54302: PUSH
54303: LD_VAR 0 9
54307: PUSH
54308: EMPTY
54309: LIST
54310: LIST
54311: PPUSH
54312: CALL_OW 2
54316: ST_TO_ADDR
54317: GO 54399
// for j = 1 to result do
54319: LD_ADDR_VAR 0 8
54323: PUSH
54324: DOUBLE
54325: LD_INT 1
54327: DEC
54328: ST_TO_ADDR
54329: LD_VAR 0 6
54333: PUSH
54334: FOR_TO
54335: IFFALSE 54397
// begin if tmp < result [ j ] [ 2 ] then
54337: LD_VAR 0 9
54341: PUSH
54342: LD_VAR 0 6
54346: PUSH
54347: LD_VAR 0 8
54351: ARRAY
54352: PUSH
54353: LD_INT 2
54355: ARRAY
54356: LESS
54357: IFFALSE 54395
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54359: LD_ADDR_VAR 0 6
54363: PUSH
54364: LD_VAR 0 6
54368: PPUSH
54369: LD_VAR 0 8
54373: PPUSH
54374: LD_VAR 0 7
54378: PUSH
54379: LD_VAR 0 9
54383: PUSH
54384: EMPTY
54385: LIST
54386: LIST
54387: PPUSH
54388: CALL_OW 2
54392: ST_TO_ADDR
// break ;
54393: GO 54397
// end ; end ;
54395: GO 54334
54397: POP
54398: POP
// end ; end ;
54399: GO 54198
54401: POP
54402: POP
// if result and not asc then
54403: LD_VAR 0 6
54407: PUSH
54408: LD_VAR 0 4
54412: NOT
54413: AND
54414: IFFALSE 54489
// begin tmp := result ;
54416: LD_ADDR_VAR 0 9
54420: PUSH
54421: LD_VAR 0 6
54425: ST_TO_ADDR
// for i = tmp downto 1 do
54426: LD_ADDR_VAR 0 7
54430: PUSH
54431: DOUBLE
54432: LD_VAR 0 9
54436: INC
54437: ST_TO_ADDR
54438: LD_INT 1
54440: PUSH
54441: FOR_DOWNTO
54442: IFFALSE 54487
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54444: LD_ADDR_VAR 0 6
54448: PUSH
54449: LD_VAR 0 6
54453: PPUSH
54454: LD_VAR 0 9
54458: PUSH
54459: LD_VAR 0 7
54463: MINUS
54464: PUSH
54465: LD_INT 1
54467: PLUS
54468: PPUSH
54469: LD_VAR 0 9
54473: PUSH
54474: LD_VAR 0 7
54478: ARRAY
54479: PPUSH
54480: CALL_OW 1
54484: ST_TO_ADDR
54485: GO 54441
54487: POP
54488: POP
// end ; tmp := [ ] ;
54489: LD_ADDR_VAR 0 9
54493: PUSH
54494: EMPTY
54495: ST_TO_ADDR
// if mode then
54496: LD_VAR 0 5
54500: IFFALSE 54569
// begin for i = 1 to result do
54502: LD_ADDR_VAR 0 7
54506: PUSH
54507: DOUBLE
54508: LD_INT 1
54510: DEC
54511: ST_TO_ADDR
54512: LD_VAR 0 6
54516: PUSH
54517: FOR_TO
54518: IFFALSE 54557
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54520: LD_ADDR_VAR 0 9
54524: PUSH
54525: LD_VAR 0 9
54529: PPUSH
54530: LD_VAR 0 7
54534: PPUSH
54535: LD_VAR 0 6
54539: PUSH
54540: LD_VAR 0 7
54544: ARRAY
54545: PUSH
54546: LD_INT 1
54548: ARRAY
54549: PPUSH
54550: CALL_OW 1
54554: ST_TO_ADDR
54555: GO 54517
54557: POP
54558: POP
// result := tmp ;
54559: LD_ADDR_VAR 0 6
54563: PUSH
54564: LD_VAR 0 9
54568: ST_TO_ADDR
// end ; end ;
54569: LD_VAR 0 6
54573: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54574: LD_INT 0
54576: PPUSH
54577: PPUSH
54578: PPUSH
54579: PPUSH
54580: PPUSH
54581: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54582: LD_ADDR_VAR 0 5
54586: PUSH
54587: LD_INT 0
54589: PUSH
54590: LD_INT 0
54592: PUSH
54593: LD_INT 0
54595: PUSH
54596: EMPTY
54597: PUSH
54598: EMPTY
54599: LIST
54600: LIST
54601: LIST
54602: LIST
54603: ST_TO_ADDR
// if not x or not y then
54604: LD_VAR 0 2
54608: NOT
54609: PUSH
54610: LD_VAR 0 3
54614: NOT
54615: OR
54616: IFFALSE 54620
// exit ;
54618: GO 56270
// if not range then
54620: LD_VAR 0 4
54624: NOT
54625: IFFALSE 54635
// range := 10 ;
54627: LD_ADDR_VAR 0 4
54631: PUSH
54632: LD_INT 10
54634: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54635: LD_ADDR_VAR 0 8
54639: PUSH
54640: LD_INT 81
54642: PUSH
54643: LD_VAR 0 1
54647: PUSH
54648: EMPTY
54649: LIST
54650: LIST
54651: PUSH
54652: LD_INT 92
54654: PUSH
54655: LD_VAR 0 2
54659: PUSH
54660: LD_VAR 0 3
54664: PUSH
54665: LD_VAR 0 4
54669: PUSH
54670: EMPTY
54671: LIST
54672: LIST
54673: LIST
54674: LIST
54675: PUSH
54676: LD_INT 3
54678: PUSH
54679: LD_INT 21
54681: PUSH
54682: LD_INT 3
54684: PUSH
54685: EMPTY
54686: LIST
54687: LIST
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: PUSH
54693: EMPTY
54694: LIST
54695: LIST
54696: LIST
54697: PPUSH
54698: CALL_OW 69
54702: ST_TO_ADDR
// if not tmp then
54703: LD_VAR 0 8
54707: NOT
54708: IFFALSE 54712
// exit ;
54710: GO 56270
// for i in tmp do
54712: LD_ADDR_VAR 0 6
54716: PUSH
54717: LD_VAR 0 8
54721: PUSH
54722: FOR_IN
54723: IFFALSE 56245
// begin points := [ 0 , 0 , 0 ] ;
54725: LD_ADDR_VAR 0 9
54729: PUSH
54730: LD_INT 0
54732: PUSH
54733: LD_INT 0
54735: PUSH
54736: LD_INT 0
54738: PUSH
54739: EMPTY
54740: LIST
54741: LIST
54742: LIST
54743: ST_TO_ADDR
// bpoints := 1 ;
54744: LD_ADDR_VAR 0 10
54748: PUSH
54749: LD_INT 1
54751: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54752: LD_VAR 0 6
54756: PPUSH
54757: CALL_OW 247
54761: PUSH
54762: LD_INT 1
54764: DOUBLE
54765: EQUAL
54766: IFTRUE 54770
54768: GO 55348
54770: POP
// begin if GetClass ( i ) = 1 then
54771: LD_VAR 0 6
54775: PPUSH
54776: CALL_OW 257
54780: PUSH
54781: LD_INT 1
54783: EQUAL
54784: IFFALSE 54805
// points := [ 10 , 5 , 3 ] ;
54786: LD_ADDR_VAR 0 9
54790: PUSH
54791: LD_INT 10
54793: PUSH
54794: LD_INT 5
54796: PUSH
54797: LD_INT 3
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: LIST
54804: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54805: LD_VAR 0 6
54809: PPUSH
54810: CALL_OW 257
54814: PUSH
54815: LD_INT 2
54817: PUSH
54818: LD_INT 3
54820: PUSH
54821: LD_INT 4
54823: PUSH
54824: EMPTY
54825: LIST
54826: LIST
54827: LIST
54828: IN
54829: IFFALSE 54850
// points := [ 3 , 2 , 1 ] ;
54831: LD_ADDR_VAR 0 9
54835: PUSH
54836: LD_INT 3
54838: PUSH
54839: LD_INT 2
54841: PUSH
54842: LD_INT 1
54844: PUSH
54845: EMPTY
54846: LIST
54847: LIST
54848: LIST
54849: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54850: LD_VAR 0 6
54854: PPUSH
54855: CALL_OW 257
54859: PUSH
54860: LD_INT 5
54862: EQUAL
54863: IFFALSE 54884
// points := [ 130 , 5 , 2 ] ;
54865: LD_ADDR_VAR 0 9
54869: PUSH
54870: LD_INT 130
54872: PUSH
54873: LD_INT 5
54875: PUSH
54876: LD_INT 2
54878: PUSH
54879: EMPTY
54880: LIST
54881: LIST
54882: LIST
54883: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54884: LD_VAR 0 6
54888: PPUSH
54889: CALL_OW 257
54893: PUSH
54894: LD_INT 8
54896: EQUAL
54897: IFFALSE 54918
// points := [ 35 , 35 , 30 ] ;
54899: LD_ADDR_VAR 0 9
54903: PUSH
54904: LD_INT 35
54906: PUSH
54907: LD_INT 35
54909: PUSH
54910: LD_INT 30
54912: PUSH
54913: EMPTY
54914: LIST
54915: LIST
54916: LIST
54917: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54918: LD_VAR 0 6
54922: PPUSH
54923: CALL_OW 257
54927: PUSH
54928: LD_INT 9
54930: EQUAL
54931: IFFALSE 54952
// points := [ 20 , 55 , 40 ] ;
54933: LD_ADDR_VAR 0 9
54937: PUSH
54938: LD_INT 20
54940: PUSH
54941: LD_INT 55
54943: PUSH
54944: LD_INT 40
54946: PUSH
54947: EMPTY
54948: LIST
54949: LIST
54950: LIST
54951: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54952: LD_VAR 0 6
54956: PPUSH
54957: CALL_OW 257
54961: PUSH
54962: LD_INT 12
54964: PUSH
54965: LD_INT 16
54967: PUSH
54968: EMPTY
54969: LIST
54970: LIST
54971: IN
54972: IFFALSE 54993
// points := [ 5 , 3 , 2 ] ;
54974: LD_ADDR_VAR 0 9
54978: PUSH
54979: LD_INT 5
54981: PUSH
54982: LD_INT 3
54984: PUSH
54985: LD_INT 2
54987: PUSH
54988: EMPTY
54989: LIST
54990: LIST
54991: LIST
54992: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54993: LD_VAR 0 6
54997: PPUSH
54998: CALL_OW 257
55002: PUSH
55003: LD_INT 17
55005: EQUAL
55006: IFFALSE 55027
// points := [ 100 , 50 , 75 ] ;
55008: LD_ADDR_VAR 0 9
55012: PUSH
55013: LD_INT 100
55015: PUSH
55016: LD_INT 50
55018: PUSH
55019: LD_INT 75
55021: PUSH
55022: EMPTY
55023: LIST
55024: LIST
55025: LIST
55026: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55027: LD_VAR 0 6
55031: PPUSH
55032: CALL_OW 257
55036: PUSH
55037: LD_INT 15
55039: EQUAL
55040: IFFALSE 55061
// points := [ 10 , 5 , 3 ] ;
55042: LD_ADDR_VAR 0 9
55046: PUSH
55047: LD_INT 10
55049: PUSH
55050: LD_INT 5
55052: PUSH
55053: LD_INT 3
55055: PUSH
55056: EMPTY
55057: LIST
55058: LIST
55059: LIST
55060: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55061: LD_VAR 0 6
55065: PPUSH
55066: CALL_OW 257
55070: PUSH
55071: LD_INT 14
55073: EQUAL
55074: IFFALSE 55095
// points := [ 10 , 0 , 0 ] ;
55076: LD_ADDR_VAR 0 9
55080: PUSH
55081: LD_INT 10
55083: PUSH
55084: LD_INT 0
55086: PUSH
55087: LD_INT 0
55089: PUSH
55090: EMPTY
55091: LIST
55092: LIST
55093: LIST
55094: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55095: LD_VAR 0 6
55099: PPUSH
55100: CALL_OW 257
55104: PUSH
55105: LD_INT 11
55107: EQUAL
55108: IFFALSE 55129
// points := [ 30 , 10 , 5 ] ;
55110: LD_ADDR_VAR 0 9
55114: PUSH
55115: LD_INT 30
55117: PUSH
55118: LD_INT 10
55120: PUSH
55121: LD_INT 5
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: LIST
55128: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55129: LD_VAR 0 1
55133: PPUSH
55134: LD_INT 5
55136: PPUSH
55137: CALL_OW 321
55141: PUSH
55142: LD_INT 2
55144: EQUAL
55145: IFFALSE 55162
// bpoints := bpoints * 1.8 ;
55147: LD_ADDR_VAR 0 10
55151: PUSH
55152: LD_VAR 0 10
55156: PUSH
55157: LD_REAL  1.80000000000000E+0000
55160: MUL
55161: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55162: LD_VAR 0 6
55166: PPUSH
55167: CALL_OW 257
55171: PUSH
55172: LD_INT 1
55174: PUSH
55175: LD_INT 2
55177: PUSH
55178: LD_INT 3
55180: PUSH
55181: LD_INT 4
55183: PUSH
55184: EMPTY
55185: LIST
55186: LIST
55187: LIST
55188: LIST
55189: IN
55190: PUSH
55191: LD_VAR 0 1
55195: PPUSH
55196: LD_INT 51
55198: PPUSH
55199: CALL_OW 321
55203: PUSH
55204: LD_INT 2
55206: EQUAL
55207: AND
55208: IFFALSE 55225
// bpoints := bpoints * 1.2 ;
55210: LD_ADDR_VAR 0 10
55214: PUSH
55215: LD_VAR 0 10
55219: PUSH
55220: LD_REAL  1.20000000000000E+0000
55223: MUL
55224: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55225: LD_VAR 0 6
55229: PPUSH
55230: CALL_OW 257
55234: PUSH
55235: LD_INT 5
55237: PUSH
55238: LD_INT 7
55240: PUSH
55241: LD_INT 9
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: LIST
55248: IN
55249: PUSH
55250: LD_VAR 0 1
55254: PPUSH
55255: LD_INT 52
55257: PPUSH
55258: CALL_OW 321
55262: PUSH
55263: LD_INT 2
55265: EQUAL
55266: AND
55267: IFFALSE 55284
// bpoints := bpoints * 1.5 ;
55269: LD_ADDR_VAR 0 10
55273: PUSH
55274: LD_VAR 0 10
55278: PUSH
55279: LD_REAL  1.50000000000000E+0000
55282: MUL
55283: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55284: LD_VAR 0 1
55288: PPUSH
55289: LD_INT 66
55291: PPUSH
55292: CALL_OW 321
55296: PUSH
55297: LD_INT 2
55299: EQUAL
55300: IFFALSE 55317
// bpoints := bpoints * 1.1 ;
55302: LD_ADDR_VAR 0 10
55306: PUSH
55307: LD_VAR 0 10
55311: PUSH
55312: LD_REAL  1.10000000000000E+0000
55315: MUL
55316: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55317: LD_ADDR_VAR 0 10
55321: PUSH
55322: LD_VAR 0 10
55326: PUSH
55327: LD_VAR 0 6
55331: PPUSH
55332: LD_INT 1
55334: PPUSH
55335: CALL_OW 259
55339: PUSH
55340: LD_REAL  1.15000000000000E+0000
55343: MUL
55344: MUL
55345: ST_TO_ADDR
// end ; unit_vehicle :
55346: GO 56174
55348: LD_INT 2
55350: DOUBLE
55351: EQUAL
55352: IFTRUE 55356
55354: GO 56162
55356: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55357: LD_VAR 0 6
55361: PPUSH
55362: CALL_OW 264
55366: PUSH
55367: LD_INT 2
55369: PUSH
55370: LD_INT 42
55372: PUSH
55373: LD_INT 24
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: LIST
55380: IN
55381: IFFALSE 55402
// points := [ 25 , 5 , 3 ] ;
55383: LD_ADDR_VAR 0 9
55387: PUSH
55388: LD_INT 25
55390: PUSH
55391: LD_INT 5
55393: PUSH
55394: LD_INT 3
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: LIST
55401: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55402: LD_VAR 0 6
55406: PPUSH
55407: CALL_OW 264
55411: PUSH
55412: LD_INT 4
55414: PUSH
55415: LD_INT 43
55417: PUSH
55418: LD_INT 25
55420: PUSH
55421: EMPTY
55422: LIST
55423: LIST
55424: LIST
55425: IN
55426: IFFALSE 55447
// points := [ 40 , 15 , 5 ] ;
55428: LD_ADDR_VAR 0 9
55432: PUSH
55433: LD_INT 40
55435: PUSH
55436: LD_INT 15
55438: PUSH
55439: LD_INT 5
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: LIST
55446: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55447: LD_VAR 0 6
55451: PPUSH
55452: CALL_OW 264
55456: PUSH
55457: LD_INT 3
55459: PUSH
55460: LD_INT 23
55462: PUSH
55463: EMPTY
55464: LIST
55465: LIST
55466: IN
55467: IFFALSE 55488
// points := [ 7 , 25 , 8 ] ;
55469: LD_ADDR_VAR 0 9
55473: PUSH
55474: LD_INT 7
55476: PUSH
55477: LD_INT 25
55479: PUSH
55480: LD_INT 8
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: LIST
55487: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55488: LD_VAR 0 6
55492: PPUSH
55493: CALL_OW 264
55497: PUSH
55498: LD_INT 5
55500: PUSH
55501: LD_INT 27
55503: PUSH
55504: LD_INT 44
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: LIST
55511: IN
55512: IFFALSE 55533
// points := [ 14 , 50 , 16 ] ;
55514: LD_ADDR_VAR 0 9
55518: PUSH
55519: LD_INT 14
55521: PUSH
55522: LD_INT 50
55524: PUSH
55525: LD_INT 16
55527: PUSH
55528: EMPTY
55529: LIST
55530: LIST
55531: LIST
55532: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55533: LD_VAR 0 6
55537: PPUSH
55538: CALL_OW 264
55542: PUSH
55543: LD_INT 6
55545: PUSH
55546: LD_INT 46
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: IN
55553: IFFALSE 55574
// points := [ 32 , 120 , 70 ] ;
55555: LD_ADDR_VAR 0 9
55559: PUSH
55560: LD_INT 32
55562: PUSH
55563: LD_INT 120
55565: PUSH
55566: LD_INT 70
55568: PUSH
55569: EMPTY
55570: LIST
55571: LIST
55572: LIST
55573: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55574: LD_VAR 0 6
55578: PPUSH
55579: CALL_OW 264
55583: PUSH
55584: LD_INT 7
55586: PUSH
55587: LD_INT 28
55589: PUSH
55590: LD_INT 45
55592: PUSH
55593: LD_INT 92
55595: PUSH
55596: EMPTY
55597: LIST
55598: LIST
55599: LIST
55600: LIST
55601: IN
55602: IFFALSE 55623
// points := [ 35 , 20 , 45 ] ;
55604: LD_ADDR_VAR 0 9
55608: PUSH
55609: LD_INT 35
55611: PUSH
55612: LD_INT 20
55614: PUSH
55615: LD_INT 45
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: LIST
55622: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55623: LD_VAR 0 6
55627: PPUSH
55628: CALL_OW 264
55632: PUSH
55633: LD_INT 47
55635: PUSH
55636: EMPTY
55637: LIST
55638: IN
55639: IFFALSE 55660
// points := [ 67 , 45 , 75 ] ;
55641: LD_ADDR_VAR 0 9
55645: PUSH
55646: LD_INT 67
55648: PUSH
55649: LD_INT 45
55651: PUSH
55652: LD_INT 75
55654: PUSH
55655: EMPTY
55656: LIST
55657: LIST
55658: LIST
55659: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55660: LD_VAR 0 6
55664: PPUSH
55665: CALL_OW 264
55669: PUSH
55670: LD_INT 26
55672: PUSH
55673: EMPTY
55674: LIST
55675: IN
55676: IFFALSE 55697
// points := [ 120 , 30 , 80 ] ;
55678: LD_ADDR_VAR 0 9
55682: PUSH
55683: LD_INT 120
55685: PUSH
55686: LD_INT 30
55688: PUSH
55689: LD_INT 80
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: LIST
55696: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55697: LD_VAR 0 6
55701: PPUSH
55702: CALL_OW 264
55706: PUSH
55707: LD_INT 22
55709: PUSH
55710: EMPTY
55711: LIST
55712: IN
55713: IFFALSE 55734
// points := [ 40 , 1 , 1 ] ;
55715: LD_ADDR_VAR 0 9
55719: PUSH
55720: LD_INT 40
55722: PUSH
55723: LD_INT 1
55725: PUSH
55726: LD_INT 1
55728: PUSH
55729: EMPTY
55730: LIST
55731: LIST
55732: LIST
55733: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55734: LD_VAR 0 6
55738: PPUSH
55739: CALL_OW 264
55743: PUSH
55744: LD_INT 29
55746: PUSH
55747: EMPTY
55748: LIST
55749: IN
55750: IFFALSE 55771
// points := [ 70 , 200 , 400 ] ;
55752: LD_ADDR_VAR 0 9
55756: PUSH
55757: LD_INT 70
55759: PUSH
55760: LD_INT 200
55762: PUSH
55763: LD_INT 400
55765: PUSH
55766: EMPTY
55767: LIST
55768: LIST
55769: LIST
55770: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55771: LD_VAR 0 6
55775: PPUSH
55776: CALL_OW 264
55780: PUSH
55781: LD_INT 14
55783: PUSH
55784: LD_INT 53
55786: PUSH
55787: EMPTY
55788: LIST
55789: LIST
55790: IN
55791: IFFALSE 55812
// points := [ 40 , 10 , 20 ] ;
55793: LD_ADDR_VAR 0 9
55797: PUSH
55798: LD_INT 40
55800: PUSH
55801: LD_INT 10
55803: PUSH
55804: LD_INT 20
55806: PUSH
55807: EMPTY
55808: LIST
55809: LIST
55810: LIST
55811: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55812: LD_VAR 0 6
55816: PPUSH
55817: CALL_OW 264
55821: PUSH
55822: LD_INT 9
55824: PUSH
55825: EMPTY
55826: LIST
55827: IN
55828: IFFALSE 55849
// points := [ 5 , 70 , 20 ] ;
55830: LD_ADDR_VAR 0 9
55834: PUSH
55835: LD_INT 5
55837: PUSH
55838: LD_INT 70
55840: PUSH
55841: LD_INT 20
55843: PUSH
55844: EMPTY
55845: LIST
55846: LIST
55847: LIST
55848: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55849: LD_VAR 0 6
55853: PPUSH
55854: CALL_OW 264
55858: PUSH
55859: LD_INT 10
55861: PUSH
55862: EMPTY
55863: LIST
55864: IN
55865: IFFALSE 55886
// points := [ 35 , 110 , 70 ] ;
55867: LD_ADDR_VAR 0 9
55871: PUSH
55872: LD_INT 35
55874: PUSH
55875: LD_INT 110
55877: PUSH
55878: LD_INT 70
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: LIST
55885: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55886: LD_VAR 0 6
55890: PPUSH
55891: CALL_OW 265
55895: PUSH
55896: LD_INT 25
55898: EQUAL
55899: IFFALSE 55920
// points := [ 80 , 65 , 100 ] ;
55901: LD_ADDR_VAR 0 9
55905: PUSH
55906: LD_INT 80
55908: PUSH
55909: LD_INT 65
55911: PUSH
55912: LD_INT 100
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: LIST
55919: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55920: LD_VAR 0 6
55924: PPUSH
55925: CALL_OW 263
55929: PUSH
55930: LD_INT 1
55932: EQUAL
55933: IFFALSE 55968
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55935: LD_ADDR_VAR 0 10
55939: PUSH
55940: LD_VAR 0 10
55944: PUSH
55945: LD_VAR 0 6
55949: PPUSH
55950: CALL_OW 311
55954: PPUSH
55955: LD_INT 3
55957: PPUSH
55958: CALL_OW 259
55962: PUSH
55963: LD_INT 4
55965: MUL
55966: MUL
55967: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55968: LD_VAR 0 6
55972: PPUSH
55973: CALL_OW 263
55977: PUSH
55978: LD_INT 2
55980: EQUAL
55981: IFFALSE 56032
// begin j := IsControledBy ( i ) ;
55983: LD_ADDR_VAR 0 7
55987: PUSH
55988: LD_VAR 0 6
55992: PPUSH
55993: CALL_OW 312
55997: ST_TO_ADDR
// if j then
55998: LD_VAR 0 7
56002: IFFALSE 56032
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56004: LD_ADDR_VAR 0 10
56008: PUSH
56009: LD_VAR 0 10
56013: PUSH
56014: LD_VAR 0 7
56018: PPUSH
56019: LD_INT 3
56021: PPUSH
56022: CALL_OW 259
56026: PUSH
56027: LD_INT 3
56029: MUL
56030: MUL
56031: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56032: LD_VAR 0 6
56036: PPUSH
56037: CALL_OW 264
56041: PUSH
56042: LD_INT 5
56044: PUSH
56045: LD_INT 6
56047: PUSH
56048: LD_INT 46
56050: PUSH
56051: LD_INT 44
56053: PUSH
56054: LD_INT 47
56056: PUSH
56057: LD_INT 45
56059: PUSH
56060: LD_INT 28
56062: PUSH
56063: LD_INT 7
56065: PUSH
56066: LD_INT 27
56068: PUSH
56069: LD_INT 29
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: LIST
56076: LIST
56077: LIST
56078: LIST
56079: LIST
56080: LIST
56081: LIST
56082: LIST
56083: IN
56084: PUSH
56085: LD_VAR 0 1
56089: PPUSH
56090: LD_INT 52
56092: PPUSH
56093: CALL_OW 321
56097: PUSH
56098: LD_INT 2
56100: EQUAL
56101: AND
56102: IFFALSE 56119
// bpoints := bpoints * 1.2 ;
56104: LD_ADDR_VAR 0 10
56108: PUSH
56109: LD_VAR 0 10
56113: PUSH
56114: LD_REAL  1.20000000000000E+0000
56117: MUL
56118: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56119: LD_VAR 0 6
56123: PPUSH
56124: CALL_OW 264
56128: PUSH
56129: LD_INT 6
56131: PUSH
56132: LD_INT 46
56134: PUSH
56135: LD_INT 47
56137: PUSH
56138: EMPTY
56139: LIST
56140: LIST
56141: LIST
56142: IN
56143: IFFALSE 56160
// bpoints := bpoints * 1.2 ;
56145: LD_ADDR_VAR 0 10
56149: PUSH
56150: LD_VAR 0 10
56154: PUSH
56155: LD_REAL  1.20000000000000E+0000
56158: MUL
56159: ST_TO_ADDR
// end ; unit_building :
56160: GO 56174
56162: LD_INT 3
56164: DOUBLE
56165: EQUAL
56166: IFTRUE 56170
56168: GO 56173
56170: POP
// ; end ;
56171: GO 56174
56173: POP
// for j = 1 to 3 do
56174: LD_ADDR_VAR 0 7
56178: PUSH
56179: DOUBLE
56180: LD_INT 1
56182: DEC
56183: ST_TO_ADDR
56184: LD_INT 3
56186: PUSH
56187: FOR_TO
56188: IFFALSE 56241
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56190: LD_ADDR_VAR 0 5
56194: PUSH
56195: LD_VAR 0 5
56199: PPUSH
56200: LD_VAR 0 7
56204: PPUSH
56205: LD_VAR 0 5
56209: PUSH
56210: LD_VAR 0 7
56214: ARRAY
56215: PUSH
56216: LD_VAR 0 9
56220: PUSH
56221: LD_VAR 0 7
56225: ARRAY
56226: PUSH
56227: LD_VAR 0 10
56231: MUL
56232: PLUS
56233: PPUSH
56234: CALL_OW 1
56238: ST_TO_ADDR
56239: GO 56187
56241: POP
56242: POP
// end ;
56243: GO 54722
56245: POP
56246: POP
// result := Replace ( result , 4 , tmp ) ;
56247: LD_ADDR_VAR 0 5
56251: PUSH
56252: LD_VAR 0 5
56256: PPUSH
56257: LD_INT 4
56259: PPUSH
56260: LD_VAR 0 8
56264: PPUSH
56265: CALL_OW 1
56269: ST_TO_ADDR
// end ;
56270: LD_VAR 0 5
56274: RET
// export function DangerAtRange ( unit , range ) ; begin
56275: LD_INT 0
56277: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56278: LD_ADDR_VAR 0 3
56282: PUSH
56283: LD_VAR 0 1
56287: PPUSH
56288: CALL_OW 255
56292: PPUSH
56293: LD_VAR 0 1
56297: PPUSH
56298: CALL_OW 250
56302: PPUSH
56303: LD_VAR 0 1
56307: PPUSH
56308: CALL_OW 251
56312: PPUSH
56313: LD_VAR 0 2
56317: PPUSH
56318: CALL 54574 0 4
56322: ST_TO_ADDR
// end ;
56323: LD_VAR 0 3
56327: RET
// export function DangerInArea ( side , area ) ; begin
56328: LD_INT 0
56330: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56331: LD_ADDR_VAR 0 3
56335: PUSH
56336: LD_VAR 0 2
56340: PPUSH
56341: LD_INT 81
56343: PUSH
56344: LD_VAR 0 1
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: PPUSH
56353: CALL_OW 70
56357: ST_TO_ADDR
// end ;
56358: LD_VAR 0 3
56362: RET
// export function IsExtension ( b ) ; begin
56363: LD_INT 0
56365: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56366: LD_ADDR_VAR 0 2
56370: PUSH
56371: LD_VAR 0 1
56375: PUSH
56376: LD_INT 23
56378: PUSH
56379: LD_INT 20
56381: PUSH
56382: LD_INT 22
56384: PUSH
56385: LD_INT 17
56387: PUSH
56388: LD_INT 24
56390: PUSH
56391: LD_INT 21
56393: PUSH
56394: LD_INT 19
56396: PUSH
56397: LD_INT 16
56399: PUSH
56400: LD_INT 25
56402: PUSH
56403: LD_INT 18
56405: PUSH
56406: EMPTY
56407: LIST
56408: LIST
56409: LIST
56410: LIST
56411: LIST
56412: LIST
56413: LIST
56414: LIST
56415: LIST
56416: LIST
56417: IN
56418: ST_TO_ADDR
// end ;
56419: LD_VAR 0 2
56423: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56424: LD_INT 0
56426: PPUSH
56427: PPUSH
56428: PPUSH
// result := [ ] ;
56429: LD_ADDR_VAR 0 4
56433: PUSH
56434: EMPTY
56435: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56436: LD_ADDR_VAR 0 5
56440: PUSH
56441: LD_VAR 0 2
56445: PPUSH
56446: LD_INT 21
56448: PUSH
56449: LD_INT 3
56451: PUSH
56452: EMPTY
56453: LIST
56454: LIST
56455: PPUSH
56456: CALL_OW 70
56460: ST_TO_ADDR
// if not tmp then
56461: LD_VAR 0 5
56465: NOT
56466: IFFALSE 56470
// exit ;
56468: GO 56534
// if checkLink then
56470: LD_VAR 0 3
56474: IFFALSE 56524
// begin for i in tmp do
56476: LD_ADDR_VAR 0 6
56480: PUSH
56481: LD_VAR 0 5
56485: PUSH
56486: FOR_IN
56487: IFFALSE 56522
// if GetBase ( i ) <> base then
56489: LD_VAR 0 6
56493: PPUSH
56494: CALL_OW 274
56498: PUSH
56499: LD_VAR 0 1
56503: NONEQUAL
56504: IFFALSE 56520
// ComLinkToBase ( base , i ) ;
56506: LD_VAR 0 1
56510: PPUSH
56511: LD_VAR 0 6
56515: PPUSH
56516: CALL_OW 169
56520: GO 56486
56522: POP
56523: POP
// end ; result := tmp ;
56524: LD_ADDR_VAR 0 4
56528: PUSH
56529: LD_VAR 0 5
56533: ST_TO_ADDR
// end ;
56534: LD_VAR 0 4
56538: RET
// export function ComComplete ( units , b ) ; var i ; begin
56539: LD_INT 0
56541: PPUSH
56542: PPUSH
// if not units then
56543: LD_VAR 0 1
56547: NOT
56548: IFFALSE 56552
// exit ;
56550: GO 56642
// for i in units do
56552: LD_ADDR_VAR 0 4
56556: PUSH
56557: LD_VAR 0 1
56561: PUSH
56562: FOR_IN
56563: IFFALSE 56640
// if BuildingStatus ( b ) = bs_build then
56565: LD_VAR 0 2
56569: PPUSH
56570: CALL_OW 461
56574: PUSH
56575: LD_INT 1
56577: EQUAL
56578: IFFALSE 56638
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56580: LD_VAR 0 4
56584: PPUSH
56585: LD_STRING h
56587: PUSH
56588: LD_VAR 0 2
56592: PPUSH
56593: CALL_OW 250
56597: PUSH
56598: LD_VAR 0 2
56602: PPUSH
56603: CALL_OW 251
56607: PUSH
56608: LD_VAR 0 2
56612: PUSH
56613: LD_INT 0
56615: PUSH
56616: LD_INT 0
56618: PUSH
56619: LD_INT 0
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: LIST
56626: LIST
56627: LIST
56628: LIST
56629: LIST
56630: PUSH
56631: EMPTY
56632: LIST
56633: PPUSH
56634: CALL_OW 446
56638: GO 56562
56640: POP
56641: POP
// end ;
56642: LD_VAR 0 3
56646: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56647: LD_INT 0
56649: PPUSH
56650: PPUSH
56651: PPUSH
56652: PPUSH
56653: PPUSH
56654: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56655: LD_VAR 0 1
56659: NOT
56660: PUSH
56661: LD_VAR 0 1
56665: PPUSH
56666: CALL_OW 263
56670: PUSH
56671: LD_INT 2
56673: NONEQUAL
56674: OR
56675: IFFALSE 56679
// exit ;
56677: GO 56995
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56679: LD_ADDR_VAR 0 6
56683: PUSH
56684: LD_INT 22
56686: PUSH
56687: LD_VAR 0 1
56691: PPUSH
56692: CALL_OW 255
56696: PUSH
56697: EMPTY
56698: LIST
56699: LIST
56700: PUSH
56701: LD_INT 2
56703: PUSH
56704: LD_INT 30
56706: PUSH
56707: LD_INT 36
56709: PUSH
56710: EMPTY
56711: LIST
56712: LIST
56713: PUSH
56714: LD_INT 34
56716: PUSH
56717: LD_INT 31
56719: PUSH
56720: EMPTY
56721: LIST
56722: LIST
56723: PUSH
56724: EMPTY
56725: LIST
56726: LIST
56727: LIST
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: PPUSH
56733: CALL_OW 69
56737: ST_TO_ADDR
// if not tmp then
56738: LD_VAR 0 6
56742: NOT
56743: IFFALSE 56747
// exit ;
56745: GO 56995
// result := [ ] ;
56747: LD_ADDR_VAR 0 2
56751: PUSH
56752: EMPTY
56753: ST_TO_ADDR
// for i in tmp do
56754: LD_ADDR_VAR 0 3
56758: PUSH
56759: LD_VAR 0 6
56763: PUSH
56764: FOR_IN
56765: IFFALSE 56836
// begin t := UnitsInside ( i ) ;
56767: LD_ADDR_VAR 0 4
56771: PUSH
56772: LD_VAR 0 3
56776: PPUSH
56777: CALL_OW 313
56781: ST_TO_ADDR
// if t then
56782: LD_VAR 0 4
56786: IFFALSE 56834
// for j in t do
56788: LD_ADDR_VAR 0 7
56792: PUSH
56793: LD_VAR 0 4
56797: PUSH
56798: FOR_IN
56799: IFFALSE 56832
// result := Replace ( result , result + 1 , j ) ;
56801: LD_ADDR_VAR 0 2
56805: PUSH
56806: LD_VAR 0 2
56810: PPUSH
56811: LD_VAR 0 2
56815: PUSH
56816: LD_INT 1
56818: PLUS
56819: PPUSH
56820: LD_VAR 0 7
56824: PPUSH
56825: CALL_OW 1
56829: ST_TO_ADDR
56830: GO 56798
56832: POP
56833: POP
// end ;
56834: GO 56764
56836: POP
56837: POP
// if not result then
56838: LD_VAR 0 2
56842: NOT
56843: IFFALSE 56847
// exit ;
56845: GO 56995
// mech := result [ 1 ] ;
56847: LD_ADDR_VAR 0 5
56851: PUSH
56852: LD_VAR 0 2
56856: PUSH
56857: LD_INT 1
56859: ARRAY
56860: ST_TO_ADDR
// if result > 1 then
56861: LD_VAR 0 2
56865: PUSH
56866: LD_INT 1
56868: GREATER
56869: IFFALSE 56981
// begin for i = 2 to result do
56871: LD_ADDR_VAR 0 3
56875: PUSH
56876: DOUBLE
56877: LD_INT 2
56879: DEC
56880: ST_TO_ADDR
56881: LD_VAR 0 2
56885: PUSH
56886: FOR_TO
56887: IFFALSE 56979
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56889: LD_ADDR_VAR 0 4
56893: PUSH
56894: LD_VAR 0 2
56898: PUSH
56899: LD_VAR 0 3
56903: ARRAY
56904: PPUSH
56905: LD_INT 3
56907: PPUSH
56908: CALL_OW 259
56912: PUSH
56913: LD_VAR 0 2
56917: PUSH
56918: LD_VAR 0 3
56922: ARRAY
56923: PPUSH
56924: CALL_OW 432
56928: MINUS
56929: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56930: LD_VAR 0 4
56934: PUSH
56935: LD_VAR 0 5
56939: PPUSH
56940: LD_INT 3
56942: PPUSH
56943: CALL_OW 259
56947: PUSH
56948: LD_VAR 0 5
56952: PPUSH
56953: CALL_OW 432
56957: MINUS
56958: GREATEREQUAL
56959: IFFALSE 56977
// mech := result [ i ] ;
56961: LD_ADDR_VAR 0 5
56965: PUSH
56966: LD_VAR 0 2
56970: PUSH
56971: LD_VAR 0 3
56975: ARRAY
56976: ST_TO_ADDR
// end ;
56977: GO 56886
56979: POP
56980: POP
// end ; ComLinkTo ( vehicle , mech ) ;
56981: LD_VAR 0 1
56985: PPUSH
56986: LD_VAR 0 5
56990: PPUSH
56991: CALL_OW 135
// end ;
56995: LD_VAR 0 2
56999: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57000: LD_INT 0
57002: PPUSH
57003: PPUSH
57004: PPUSH
57005: PPUSH
57006: PPUSH
57007: PPUSH
57008: PPUSH
57009: PPUSH
57010: PPUSH
57011: PPUSH
57012: PPUSH
57013: PPUSH
57014: PPUSH
// result := [ ] ;
57015: LD_ADDR_VAR 0 7
57019: PUSH
57020: EMPTY
57021: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57022: LD_VAR 0 1
57026: PPUSH
57027: CALL_OW 266
57031: PUSH
57032: LD_INT 0
57034: PUSH
57035: LD_INT 1
57037: PUSH
57038: EMPTY
57039: LIST
57040: LIST
57041: IN
57042: NOT
57043: IFFALSE 57047
// exit ;
57045: GO 58681
// if name then
57047: LD_VAR 0 3
57051: IFFALSE 57067
// SetBName ( base_dep , name ) ;
57053: LD_VAR 0 1
57057: PPUSH
57058: LD_VAR 0 3
57062: PPUSH
57063: CALL_OW 500
// base := GetBase ( base_dep ) ;
57067: LD_ADDR_VAR 0 15
57071: PUSH
57072: LD_VAR 0 1
57076: PPUSH
57077: CALL_OW 274
57081: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57082: LD_ADDR_VAR 0 16
57086: PUSH
57087: LD_VAR 0 1
57091: PPUSH
57092: CALL_OW 255
57096: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57097: LD_ADDR_VAR 0 17
57101: PUSH
57102: LD_VAR 0 1
57106: PPUSH
57107: CALL_OW 248
57111: ST_TO_ADDR
// if sources then
57112: LD_VAR 0 5
57116: IFFALSE 57163
// for i = 1 to 3 do
57118: LD_ADDR_VAR 0 8
57122: PUSH
57123: DOUBLE
57124: LD_INT 1
57126: DEC
57127: ST_TO_ADDR
57128: LD_INT 3
57130: PUSH
57131: FOR_TO
57132: IFFALSE 57161
// AddResourceType ( base , i , sources [ i ] ) ;
57134: LD_VAR 0 15
57138: PPUSH
57139: LD_VAR 0 8
57143: PPUSH
57144: LD_VAR 0 5
57148: PUSH
57149: LD_VAR 0 8
57153: ARRAY
57154: PPUSH
57155: CALL_OW 276
57159: GO 57131
57161: POP
57162: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57163: LD_ADDR_VAR 0 18
57167: PUSH
57168: LD_VAR 0 15
57172: PPUSH
57173: LD_VAR 0 2
57177: PPUSH
57178: LD_INT 1
57180: PPUSH
57181: CALL 56424 0 3
57185: ST_TO_ADDR
// InitHc ;
57186: CALL_OW 19
// InitUc ;
57190: CALL_OW 18
// uc_side := side ;
57194: LD_ADDR_OWVAR 20
57198: PUSH
57199: LD_VAR 0 16
57203: ST_TO_ADDR
// uc_nation := nation ;
57204: LD_ADDR_OWVAR 21
57208: PUSH
57209: LD_VAR 0 17
57213: ST_TO_ADDR
// if buildings then
57214: LD_VAR 0 18
57218: IFFALSE 58540
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57220: LD_ADDR_VAR 0 19
57224: PUSH
57225: LD_VAR 0 18
57229: PPUSH
57230: LD_INT 2
57232: PUSH
57233: LD_INT 30
57235: PUSH
57236: LD_INT 29
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: PUSH
57243: LD_INT 30
57245: PUSH
57246: LD_INT 30
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: PUSH
57253: EMPTY
57254: LIST
57255: LIST
57256: LIST
57257: PPUSH
57258: CALL_OW 72
57262: ST_TO_ADDR
// if tmp then
57263: LD_VAR 0 19
57267: IFFALSE 57315
// for i in tmp do
57269: LD_ADDR_VAR 0 8
57273: PUSH
57274: LD_VAR 0 19
57278: PUSH
57279: FOR_IN
57280: IFFALSE 57313
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57282: LD_VAR 0 8
57286: PPUSH
57287: CALL_OW 250
57291: PPUSH
57292: LD_VAR 0 8
57296: PPUSH
57297: CALL_OW 251
57301: PPUSH
57302: LD_VAR 0 16
57306: PPUSH
57307: CALL_OW 441
57311: GO 57279
57313: POP
57314: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57315: LD_VAR 0 18
57319: PPUSH
57320: LD_INT 2
57322: PUSH
57323: LD_INT 30
57325: PUSH
57326: LD_INT 32
57328: PUSH
57329: EMPTY
57330: LIST
57331: LIST
57332: PUSH
57333: LD_INT 30
57335: PUSH
57336: LD_INT 33
57338: PUSH
57339: EMPTY
57340: LIST
57341: LIST
57342: PUSH
57343: EMPTY
57344: LIST
57345: LIST
57346: LIST
57347: PPUSH
57348: CALL_OW 72
57352: IFFALSE 57440
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57354: LD_ADDR_VAR 0 8
57358: PUSH
57359: LD_VAR 0 18
57363: PPUSH
57364: LD_INT 2
57366: PUSH
57367: LD_INT 30
57369: PUSH
57370: LD_INT 32
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: PUSH
57377: LD_INT 30
57379: PUSH
57380: LD_INT 33
57382: PUSH
57383: EMPTY
57384: LIST
57385: LIST
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: LIST
57391: PPUSH
57392: CALL_OW 72
57396: PUSH
57397: FOR_IN
57398: IFFALSE 57438
// begin if not GetBWeapon ( i ) then
57400: LD_VAR 0 8
57404: PPUSH
57405: CALL_OW 269
57409: NOT
57410: IFFALSE 57436
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57412: LD_VAR 0 8
57416: PPUSH
57417: LD_VAR 0 8
57421: PPUSH
57422: LD_VAR 0 2
57426: PPUSH
57427: CALL 58686 0 2
57431: PPUSH
57432: CALL_OW 431
// end ;
57436: GO 57397
57438: POP
57439: POP
// end ; for i = 1 to personel do
57440: LD_ADDR_VAR 0 8
57444: PUSH
57445: DOUBLE
57446: LD_INT 1
57448: DEC
57449: ST_TO_ADDR
57450: LD_VAR 0 6
57454: PUSH
57455: FOR_TO
57456: IFFALSE 58520
// begin if i > 4 then
57458: LD_VAR 0 8
57462: PUSH
57463: LD_INT 4
57465: GREATER
57466: IFFALSE 57470
// break ;
57468: GO 58520
// case i of 1 :
57470: LD_VAR 0 8
57474: PUSH
57475: LD_INT 1
57477: DOUBLE
57478: EQUAL
57479: IFTRUE 57483
57481: GO 57563
57483: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57484: LD_ADDR_VAR 0 12
57488: PUSH
57489: LD_VAR 0 18
57493: PPUSH
57494: LD_INT 22
57496: PUSH
57497: LD_VAR 0 16
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: PUSH
57506: LD_INT 58
57508: PUSH
57509: EMPTY
57510: LIST
57511: PUSH
57512: LD_INT 2
57514: PUSH
57515: LD_INT 30
57517: PUSH
57518: LD_INT 32
57520: PUSH
57521: EMPTY
57522: LIST
57523: LIST
57524: PUSH
57525: LD_INT 30
57527: PUSH
57528: LD_INT 4
57530: PUSH
57531: EMPTY
57532: LIST
57533: LIST
57534: PUSH
57535: LD_INT 30
57537: PUSH
57538: LD_INT 5
57540: PUSH
57541: EMPTY
57542: LIST
57543: LIST
57544: PUSH
57545: EMPTY
57546: LIST
57547: LIST
57548: LIST
57549: LIST
57550: PUSH
57551: EMPTY
57552: LIST
57553: LIST
57554: LIST
57555: PPUSH
57556: CALL_OW 72
57560: ST_TO_ADDR
57561: GO 57785
57563: LD_INT 2
57565: DOUBLE
57566: EQUAL
57567: IFTRUE 57571
57569: GO 57633
57571: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57572: LD_ADDR_VAR 0 12
57576: PUSH
57577: LD_VAR 0 18
57581: PPUSH
57582: LD_INT 22
57584: PUSH
57585: LD_VAR 0 16
57589: PUSH
57590: EMPTY
57591: LIST
57592: LIST
57593: PUSH
57594: LD_INT 2
57596: PUSH
57597: LD_INT 30
57599: PUSH
57600: LD_INT 0
57602: PUSH
57603: EMPTY
57604: LIST
57605: LIST
57606: PUSH
57607: LD_INT 30
57609: PUSH
57610: LD_INT 1
57612: PUSH
57613: EMPTY
57614: LIST
57615: LIST
57616: PUSH
57617: EMPTY
57618: LIST
57619: LIST
57620: LIST
57621: PUSH
57622: EMPTY
57623: LIST
57624: LIST
57625: PPUSH
57626: CALL_OW 72
57630: ST_TO_ADDR
57631: GO 57785
57633: LD_INT 3
57635: DOUBLE
57636: EQUAL
57637: IFTRUE 57641
57639: GO 57703
57641: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57642: LD_ADDR_VAR 0 12
57646: PUSH
57647: LD_VAR 0 18
57651: PPUSH
57652: LD_INT 22
57654: PUSH
57655: LD_VAR 0 16
57659: PUSH
57660: EMPTY
57661: LIST
57662: LIST
57663: PUSH
57664: LD_INT 2
57666: PUSH
57667: LD_INT 30
57669: PUSH
57670: LD_INT 2
57672: PUSH
57673: EMPTY
57674: LIST
57675: LIST
57676: PUSH
57677: LD_INT 30
57679: PUSH
57680: LD_INT 3
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: PUSH
57687: EMPTY
57688: LIST
57689: LIST
57690: LIST
57691: PUSH
57692: EMPTY
57693: LIST
57694: LIST
57695: PPUSH
57696: CALL_OW 72
57700: ST_TO_ADDR
57701: GO 57785
57703: LD_INT 4
57705: DOUBLE
57706: EQUAL
57707: IFTRUE 57711
57709: GO 57784
57711: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57712: LD_ADDR_VAR 0 12
57716: PUSH
57717: LD_VAR 0 18
57721: PPUSH
57722: LD_INT 22
57724: PUSH
57725: LD_VAR 0 16
57729: PUSH
57730: EMPTY
57731: LIST
57732: LIST
57733: PUSH
57734: LD_INT 2
57736: PUSH
57737: LD_INT 30
57739: PUSH
57740: LD_INT 6
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: PUSH
57747: LD_INT 30
57749: PUSH
57750: LD_INT 7
57752: PUSH
57753: EMPTY
57754: LIST
57755: LIST
57756: PUSH
57757: LD_INT 30
57759: PUSH
57760: LD_INT 8
57762: PUSH
57763: EMPTY
57764: LIST
57765: LIST
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: LIST
57771: LIST
57772: PUSH
57773: EMPTY
57774: LIST
57775: LIST
57776: PPUSH
57777: CALL_OW 72
57781: ST_TO_ADDR
57782: GO 57785
57784: POP
// if i = 1 then
57785: LD_VAR 0 8
57789: PUSH
57790: LD_INT 1
57792: EQUAL
57793: IFFALSE 57904
// begin tmp := [ ] ;
57795: LD_ADDR_VAR 0 19
57799: PUSH
57800: EMPTY
57801: ST_TO_ADDR
// for j in f do
57802: LD_ADDR_VAR 0 9
57806: PUSH
57807: LD_VAR 0 12
57811: PUSH
57812: FOR_IN
57813: IFFALSE 57886
// if GetBType ( j ) = b_bunker then
57815: LD_VAR 0 9
57819: PPUSH
57820: CALL_OW 266
57824: PUSH
57825: LD_INT 32
57827: EQUAL
57828: IFFALSE 57855
// tmp := Insert ( tmp , 1 , j ) else
57830: LD_ADDR_VAR 0 19
57834: PUSH
57835: LD_VAR 0 19
57839: PPUSH
57840: LD_INT 1
57842: PPUSH
57843: LD_VAR 0 9
57847: PPUSH
57848: CALL_OW 2
57852: ST_TO_ADDR
57853: GO 57884
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57855: LD_ADDR_VAR 0 19
57859: PUSH
57860: LD_VAR 0 19
57864: PPUSH
57865: LD_VAR 0 19
57869: PUSH
57870: LD_INT 1
57872: PLUS
57873: PPUSH
57874: LD_VAR 0 9
57878: PPUSH
57879: CALL_OW 2
57883: ST_TO_ADDR
57884: GO 57812
57886: POP
57887: POP
// if tmp then
57888: LD_VAR 0 19
57892: IFFALSE 57904
// f := tmp ;
57894: LD_ADDR_VAR 0 12
57898: PUSH
57899: LD_VAR 0 19
57903: ST_TO_ADDR
// end ; x := personel [ i ] ;
57904: LD_ADDR_VAR 0 13
57908: PUSH
57909: LD_VAR 0 6
57913: PUSH
57914: LD_VAR 0 8
57918: ARRAY
57919: ST_TO_ADDR
// if x = - 1 then
57920: LD_VAR 0 13
57924: PUSH
57925: LD_INT 1
57927: NEG
57928: EQUAL
57929: IFFALSE 58138
// begin for j in f do
57931: LD_ADDR_VAR 0 9
57935: PUSH
57936: LD_VAR 0 12
57940: PUSH
57941: FOR_IN
57942: IFFALSE 58134
// repeat InitHc ;
57944: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57948: LD_VAR 0 9
57952: PPUSH
57953: CALL_OW 266
57957: PUSH
57958: LD_INT 5
57960: EQUAL
57961: IFFALSE 58031
// begin if UnitsInside ( j ) < 3 then
57963: LD_VAR 0 9
57967: PPUSH
57968: CALL_OW 313
57972: PUSH
57973: LD_INT 3
57975: LESS
57976: IFFALSE 58012
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57978: LD_INT 0
57980: PPUSH
57981: LD_INT 5
57983: PUSH
57984: LD_INT 8
57986: PUSH
57987: LD_INT 9
57989: PUSH
57990: EMPTY
57991: LIST
57992: LIST
57993: LIST
57994: PUSH
57995: LD_VAR 0 17
57999: ARRAY
58000: PPUSH
58001: LD_VAR 0 4
58005: PPUSH
58006: CALL_OW 380
58010: GO 58029
// PrepareHuman ( false , i , skill ) ;
58012: LD_INT 0
58014: PPUSH
58015: LD_VAR 0 8
58019: PPUSH
58020: LD_VAR 0 4
58024: PPUSH
58025: CALL_OW 380
// end else
58029: GO 58048
// PrepareHuman ( false , i , skill ) ;
58031: LD_INT 0
58033: PPUSH
58034: LD_VAR 0 8
58038: PPUSH
58039: LD_VAR 0 4
58043: PPUSH
58044: CALL_OW 380
// un := CreateHuman ;
58048: LD_ADDR_VAR 0 14
58052: PUSH
58053: CALL_OW 44
58057: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58058: LD_ADDR_VAR 0 7
58062: PUSH
58063: LD_VAR 0 7
58067: PPUSH
58068: LD_INT 1
58070: PPUSH
58071: LD_VAR 0 14
58075: PPUSH
58076: CALL_OW 2
58080: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58081: LD_VAR 0 14
58085: PPUSH
58086: LD_VAR 0 9
58090: PPUSH
58091: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58095: LD_VAR 0 9
58099: PPUSH
58100: CALL_OW 313
58104: PUSH
58105: LD_INT 6
58107: EQUAL
58108: PUSH
58109: LD_VAR 0 9
58113: PPUSH
58114: CALL_OW 266
58118: PUSH
58119: LD_INT 32
58121: PUSH
58122: LD_INT 31
58124: PUSH
58125: EMPTY
58126: LIST
58127: LIST
58128: IN
58129: OR
58130: IFFALSE 57944
58132: GO 57941
58134: POP
58135: POP
// end else
58136: GO 58518
// for j = 1 to x do
58138: LD_ADDR_VAR 0 9
58142: PUSH
58143: DOUBLE
58144: LD_INT 1
58146: DEC
58147: ST_TO_ADDR
58148: LD_VAR 0 13
58152: PUSH
58153: FOR_TO
58154: IFFALSE 58516
// begin InitHc ;
58156: CALL_OW 19
// if not f then
58160: LD_VAR 0 12
58164: NOT
58165: IFFALSE 58254
// begin PrepareHuman ( false , i , skill ) ;
58167: LD_INT 0
58169: PPUSH
58170: LD_VAR 0 8
58174: PPUSH
58175: LD_VAR 0 4
58179: PPUSH
58180: CALL_OW 380
// un := CreateHuman ;
58184: LD_ADDR_VAR 0 14
58188: PUSH
58189: CALL_OW 44
58193: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58194: LD_ADDR_VAR 0 7
58198: PUSH
58199: LD_VAR 0 7
58203: PPUSH
58204: LD_INT 1
58206: PPUSH
58207: LD_VAR 0 14
58211: PPUSH
58212: CALL_OW 2
58216: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58217: LD_VAR 0 14
58221: PPUSH
58222: LD_VAR 0 1
58226: PPUSH
58227: CALL_OW 250
58231: PPUSH
58232: LD_VAR 0 1
58236: PPUSH
58237: CALL_OW 251
58241: PPUSH
58242: LD_INT 10
58244: PPUSH
58245: LD_INT 0
58247: PPUSH
58248: CALL_OW 50
// continue ;
58252: GO 58153
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58254: LD_VAR 0 12
58258: PUSH
58259: LD_INT 1
58261: ARRAY
58262: PPUSH
58263: CALL_OW 313
58267: PUSH
58268: LD_VAR 0 12
58272: PUSH
58273: LD_INT 1
58275: ARRAY
58276: PPUSH
58277: CALL_OW 266
58281: PUSH
58282: LD_INT 32
58284: PUSH
58285: LD_INT 31
58287: PUSH
58288: EMPTY
58289: LIST
58290: LIST
58291: IN
58292: AND
58293: PUSH
58294: LD_VAR 0 12
58298: PUSH
58299: LD_INT 1
58301: ARRAY
58302: PPUSH
58303: CALL_OW 313
58307: PUSH
58308: LD_INT 6
58310: EQUAL
58311: OR
58312: IFFALSE 58332
// f := Delete ( f , 1 ) ;
58314: LD_ADDR_VAR 0 12
58318: PUSH
58319: LD_VAR 0 12
58323: PPUSH
58324: LD_INT 1
58326: PPUSH
58327: CALL_OW 3
58331: ST_TO_ADDR
// if not f then
58332: LD_VAR 0 12
58336: NOT
58337: IFFALSE 58355
// begin x := x + 2 ;
58339: LD_ADDR_VAR 0 13
58343: PUSH
58344: LD_VAR 0 13
58348: PUSH
58349: LD_INT 2
58351: PLUS
58352: ST_TO_ADDR
// continue ;
58353: GO 58153
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58355: LD_VAR 0 12
58359: PUSH
58360: LD_INT 1
58362: ARRAY
58363: PPUSH
58364: CALL_OW 266
58368: PUSH
58369: LD_INT 5
58371: EQUAL
58372: IFFALSE 58446
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58374: LD_VAR 0 12
58378: PUSH
58379: LD_INT 1
58381: ARRAY
58382: PPUSH
58383: CALL_OW 313
58387: PUSH
58388: LD_INT 3
58390: LESS
58391: IFFALSE 58427
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58393: LD_INT 0
58395: PPUSH
58396: LD_INT 5
58398: PUSH
58399: LD_INT 8
58401: PUSH
58402: LD_INT 9
58404: PUSH
58405: EMPTY
58406: LIST
58407: LIST
58408: LIST
58409: PUSH
58410: LD_VAR 0 17
58414: ARRAY
58415: PPUSH
58416: LD_VAR 0 4
58420: PPUSH
58421: CALL_OW 380
58425: GO 58444
// PrepareHuman ( false , i , skill ) ;
58427: LD_INT 0
58429: PPUSH
58430: LD_VAR 0 8
58434: PPUSH
58435: LD_VAR 0 4
58439: PPUSH
58440: CALL_OW 380
// end else
58444: GO 58463
// PrepareHuman ( false , i , skill ) ;
58446: LD_INT 0
58448: PPUSH
58449: LD_VAR 0 8
58453: PPUSH
58454: LD_VAR 0 4
58458: PPUSH
58459: CALL_OW 380
// un := CreateHuman ;
58463: LD_ADDR_VAR 0 14
58467: PUSH
58468: CALL_OW 44
58472: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58473: LD_ADDR_VAR 0 7
58477: PUSH
58478: LD_VAR 0 7
58482: PPUSH
58483: LD_INT 1
58485: PPUSH
58486: LD_VAR 0 14
58490: PPUSH
58491: CALL_OW 2
58495: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58496: LD_VAR 0 14
58500: PPUSH
58501: LD_VAR 0 12
58505: PUSH
58506: LD_INT 1
58508: ARRAY
58509: PPUSH
58510: CALL_OW 52
// end ;
58514: GO 58153
58516: POP
58517: POP
// end ;
58518: GO 57455
58520: POP
58521: POP
// result := result ^ buildings ;
58522: LD_ADDR_VAR 0 7
58526: PUSH
58527: LD_VAR 0 7
58531: PUSH
58532: LD_VAR 0 18
58536: ADD
58537: ST_TO_ADDR
// end else
58538: GO 58681
// begin for i = 1 to personel do
58540: LD_ADDR_VAR 0 8
58544: PUSH
58545: DOUBLE
58546: LD_INT 1
58548: DEC
58549: ST_TO_ADDR
58550: LD_VAR 0 6
58554: PUSH
58555: FOR_TO
58556: IFFALSE 58679
// begin if i > 4 then
58558: LD_VAR 0 8
58562: PUSH
58563: LD_INT 4
58565: GREATER
58566: IFFALSE 58570
// break ;
58568: GO 58679
// x := personel [ i ] ;
58570: LD_ADDR_VAR 0 13
58574: PUSH
58575: LD_VAR 0 6
58579: PUSH
58580: LD_VAR 0 8
58584: ARRAY
58585: ST_TO_ADDR
// if x = - 1 then
58586: LD_VAR 0 13
58590: PUSH
58591: LD_INT 1
58593: NEG
58594: EQUAL
58595: IFFALSE 58599
// continue ;
58597: GO 58555
// PrepareHuman ( false , i , skill ) ;
58599: LD_INT 0
58601: PPUSH
58602: LD_VAR 0 8
58606: PPUSH
58607: LD_VAR 0 4
58611: PPUSH
58612: CALL_OW 380
// un := CreateHuman ;
58616: LD_ADDR_VAR 0 14
58620: PUSH
58621: CALL_OW 44
58625: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58626: LD_VAR 0 14
58630: PPUSH
58631: LD_VAR 0 1
58635: PPUSH
58636: CALL_OW 250
58640: PPUSH
58641: LD_VAR 0 1
58645: PPUSH
58646: CALL_OW 251
58650: PPUSH
58651: LD_INT 10
58653: PPUSH
58654: LD_INT 0
58656: PPUSH
58657: CALL_OW 50
// result := result ^ un ;
58661: LD_ADDR_VAR 0 7
58665: PUSH
58666: LD_VAR 0 7
58670: PUSH
58671: LD_VAR 0 14
58675: ADD
58676: ST_TO_ADDR
// end ;
58677: GO 58555
58679: POP
58680: POP
// end ; end ;
58681: LD_VAR 0 7
58685: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58686: LD_INT 0
58688: PPUSH
58689: PPUSH
58690: PPUSH
58691: PPUSH
58692: PPUSH
58693: PPUSH
58694: PPUSH
58695: PPUSH
58696: PPUSH
58697: PPUSH
58698: PPUSH
58699: PPUSH
58700: PPUSH
58701: PPUSH
58702: PPUSH
58703: PPUSH
// result := false ;
58704: LD_ADDR_VAR 0 3
58708: PUSH
58709: LD_INT 0
58711: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58712: LD_VAR 0 1
58716: NOT
58717: PUSH
58718: LD_VAR 0 1
58722: PPUSH
58723: CALL_OW 266
58727: PUSH
58728: LD_INT 32
58730: PUSH
58731: LD_INT 33
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: IN
58738: NOT
58739: OR
58740: IFFALSE 58744
// exit ;
58742: GO 59853
// nat := GetNation ( tower ) ;
58744: LD_ADDR_VAR 0 12
58748: PUSH
58749: LD_VAR 0 1
58753: PPUSH
58754: CALL_OW 248
58758: ST_TO_ADDR
// side := GetSide ( tower ) ;
58759: LD_ADDR_VAR 0 16
58763: PUSH
58764: LD_VAR 0 1
58768: PPUSH
58769: CALL_OW 255
58773: ST_TO_ADDR
// x := GetX ( tower ) ;
58774: LD_ADDR_VAR 0 10
58778: PUSH
58779: LD_VAR 0 1
58783: PPUSH
58784: CALL_OW 250
58788: ST_TO_ADDR
// y := GetY ( tower ) ;
58789: LD_ADDR_VAR 0 11
58793: PUSH
58794: LD_VAR 0 1
58798: PPUSH
58799: CALL_OW 251
58803: ST_TO_ADDR
// if not x or not y then
58804: LD_VAR 0 10
58808: NOT
58809: PUSH
58810: LD_VAR 0 11
58814: NOT
58815: OR
58816: IFFALSE 58820
// exit ;
58818: GO 59853
// weapon := 0 ;
58820: LD_ADDR_VAR 0 18
58824: PUSH
58825: LD_INT 0
58827: ST_TO_ADDR
// fac_list := [ ] ;
58828: LD_ADDR_VAR 0 17
58832: PUSH
58833: EMPTY
58834: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58835: LD_ADDR_VAR 0 6
58839: PUSH
58840: LD_VAR 0 1
58844: PPUSH
58845: CALL_OW 274
58849: PPUSH
58850: LD_VAR 0 2
58854: PPUSH
58855: LD_INT 0
58857: PPUSH
58858: CALL 56424 0 3
58862: PPUSH
58863: LD_INT 30
58865: PUSH
58866: LD_INT 3
58868: PUSH
58869: EMPTY
58870: LIST
58871: LIST
58872: PPUSH
58873: CALL_OW 72
58877: ST_TO_ADDR
// if not factories then
58878: LD_VAR 0 6
58882: NOT
58883: IFFALSE 58887
// exit ;
58885: GO 59853
// for i in factories do
58887: LD_ADDR_VAR 0 8
58891: PUSH
58892: LD_VAR 0 6
58896: PUSH
58897: FOR_IN
58898: IFFALSE 58923
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58900: LD_ADDR_VAR 0 17
58904: PUSH
58905: LD_VAR 0 17
58909: PUSH
58910: LD_VAR 0 8
58914: PPUSH
58915: CALL_OW 478
58919: UNION
58920: ST_TO_ADDR
58921: GO 58897
58923: POP
58924: POP
// if not fac_list then
58925: LD_VAR 0 17
58929: NOT
58930: IFFALSE 58934
// exit ;
58932: GO 59853
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58934: LD_ADDR_VAR 0 5
58938: PUSH
58939: LD_INT 4
58941: PUSH
58942: LD_INT 5
58944: PUSH
58945: LD_INT 9
58947: PUSH
58948: LD_INT 10
58950: PUSH
58951: LD_INT 6
58953: PUSH
58954: LD_INT 7
58956: PUSH
58957: LD_INT 11
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: LIST
58964: LIST
58965: LIST
58966: LIST
58967: LIST
58968: PUSH
58969: LD_INT 27
58971: PUSH
58972: LD_INT 28
58974: PUSH
58975: LD_INT 26
58977: PUSH
58978: LD_INT 30
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: LIST
58985: LIST
58986: PUSH
58987: LD_INT 43
58989: PUSH
58990: LD_INT 44
58992: PUSH
58993: LD_INT 46
58995: PUSH
58996: LD_INT 45
58998: PUSH
58999: LD_INT 47
59001: PUSH
59002: LD_INT 49
59004: PUSH
59005: EMPTY
59006: LIST
59007: LIST
59008: LIST
59009: LIST
59010: LIST
59011: LIST
59012: PUSH
59013: EMPTY
59014: LIST
59015: LIST
59016: LIST
59017: PUSH
59018: LD_VAR 0 12
59022: ARRAY
59023: ST_TO_ADDR
// list := list isect fac_list ;
59024: LD_ADDR_VAR 0 5
59028: PUSH
59029: LD_VAR 0 5
59033: PUSH
59034: LD_VAR 0 17
59038: ISECT
59039: ST_TO_ADDR
// if not list then
59040: LD_VAR 0 5
59044: NOT
59045: IFFALSE 59049
// exit ;
59047: GO 59853
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59049: LD_VAR 0 12
59053: PUSH
59054: LD_INT 3
59056: EQUAL
59057: PUSH
59058: LD_INT 49
59060: PUSH
59061: LD_VAR 0 5
59065: IN
59066: AND
59067: PUSH
59068: LD_INT 31
59070: PPUSH
59071: LD_VAR 0 16
59075: PPUSH
59076: CALL_OW 321
59080: PUSH
59081: LD_INT 2
59083: EQUAL
59084: AND
59085: IFFALSE 59145
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59087: LD_INT 22
59089: PUSH
59090: LD_VAR 0 16
59094: PUSH
59095: EMPTY
59096: LIST
59097: LIST
59098: PUSH
59099: LD_INT 35
59101: PUSH
59102: LD_INT 49
59104: PUSH
59105: EMPTY
59106: LIST
59107: LIST
59108: PUSH
59109: LD_INT 91
59111: PUSH
59112: LD_VAR 0 1
59116: PUSH
59117: LD_INT 10
59119: PUSH
59120: EMPTY
59121: LIST
59122: LIST
59123: LIST
59124: PUSH
59125: EMPTY
59126: LIST
59127: LIST
59128: LIST
59129: PPUSH
59130: CALL_OW 69
59134: NOT
59135: IFFALSE 59145
// weapon := ru_time_lapser ;
59137: LD_ADDR_VAR 0 18
59141: PUSH
59142: LD_INT 49
59144: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59145: LD_VAR 0 12
59149: PUSH
59150: LD_INT 1
59152: PUSH
59153: LD_INT 2
59155: PUSH
59156: EMPTY
59157: LIST
59158: LIST
59159: IN
59160: PUSH
59161: LD_INT 11
59163: PUSH
59164: LD_VAR 0 5
59168: IN
59169: PUSH
59170: LD_INT 30
59172: PUSH
59173: LD_VAR 0 5
59177: IN
59178: OR
59179: AND
59180: PUSH
59181: LD_INT 6
59183: PPUSH
59184: LD_VAR 0 16
59188: PPUSH
59189: CALL_OW 321
59193: PUSH
59194: LD_INT 2
59196: EQUAL
59197: AND
59198: IFFALSE 59363
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59200: LD_INT 22
59202: PUSH
59203: LD_VAR 0 16
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: PUSH
59212: LD_INT 2
59214: PUSH
59215: LD_INT 35
59217: PUSH
59218: LD_INT 11
59220: PUSH
59221: EMPTY
59222: LIST
59223: LIST
59224: PUSH
59225: LD_INT 35
59227: PUSH
59228: LD_INT 30
59230: PUSH
59231: EMPTY
59232: LIST
59233: LIST
59234: PUSH
59235: EMPTY
59236: LIST
59237: LIST
59238: LIST
59239: PUSH
59240: LD_INT 91
59242: PUSH
59243: LD_VAR 0 1
59247: PUSH
59248: LD_INT 18
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: LIST
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: LIST
59260: PPUSH
59261: CALL_OW 69
59265: NOT
59266: PUSH
59267: LD_INT 22
59269: PUSH
59270: LD_VAR 0 16
59274: PUSH
59275: EMPTY
59276: LIST
59277: LIST
59278: PUSH
59279: LD_INT 2
59281: PUSH
59282: LD_INT 30
59284: PUSH
59285: LD_INT 32
59287: PUSH
59288: EMPTY
59289: LIST
59290: LIST
59291: PUSH
59292: LD_INT 30
59294: PUSH
59295: LD_INT 33
59297: PUSH
59298: EMPTY
59299: LIST
59300: LIST
59301: PUSH
59302: EMPTY
59303: LIST
59304: LIST
59305: LIST
59306: PUSH
59307: LD_INT 91
59309: PUSH
59310: LD_VAR 0 1
59314: PUSH
59315: LD_INT 12
59317: PUSH
59318: EMPTY
59319: LIST
59320: LIST
59321: LIST
59322: PUSH
59323: EMPTY
59324: LIST
59325: LIST
59326: LIST
59327: PUSH
59328: EMPTY
59329: LIST
59330: PPUSH
59331: CALL_OW 69
59335: PUSH
59336: LD_INT 2
59338: GREATER
59339: AND
59340: IFFALSE 59363
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59342: LD_ADDR_VAR 0 18
59346: PUSH
59347: LD_INT 11
59349: PUSH
59350: LD_INT 30
59352: PUSH
59353: EMPTY
59354: LIST
59355: LIST
59356: PUSH
59357: LD_VAR 0 12
59361: ARRAY
59362: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59363: LD_VAR 0 18
59367: NOT
59368: PUSH
59369: LD_INT 40
59371: PPUSH
59372: LD_VAR 0 16
59376: PPUSH
59377: CALL_OW 321
59381: PUSH
59382: LD_INT 2
59384: EQUAL
59385: AND
59386: PUSH
59387: LD_INT 7
59389: PUSH
59390: LD_VAR 0 5
59394: IN
59395: PUSH
59396: LD_INT 28
59398: PUSH
59399: LD_VAR 0 5
59403: IN
59404: OR
59405: PUSH
59406: LD_INT 45
59408: PUSH
59409: LD_VAR 0 5
59413: IN
59414: OR
59415: AND
59416: IFFALSE 59670
// begin hex := GetHexInfo ( x , y ) ;
59418: LD_ADDR_VAR 0 4
59422: PUSH
59423: LD_VAR 0 10
59427: PPUSH
59428: LD_VAR 0 11
59432: PPUSH
59433: CALL_OW 546
59437: ST_TO_ADDR
// if hex [ 1 ] then
59438: LD_VAR 0 4
59442: PUSH
59443: LD_INT 1
59445: ARRAY
59446: IFFALSE 59450
// exit ;
59448: GO 59853
// height := hex [ 2 ] ;
59450: LD_ADDR_VAR 0 15
59454: PUSH
59455: LD_VAR 0 4
59459: PUSH
59460: LD_INT 2
59462: ARRAY
59463: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59464: LD_ADDR_VAR 0 14
59468: PUSH
59469: LD_INT 0
59471: PUSH
59472: LD_INT 2
59474: PUSH
59475: LD_INT 3
59477: PUSH
59478: LD_INT 5
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: LIST
59485: LIST
59486: ST_TO_ADDR
// for i in tmp do
59487: LD_ADDR_VAR 0 8
59491: PUSH
59492: LD_VAR 0 14
59496: PUSH
59497: FOR_IN
59498: IFFALSE 59668
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59500: LD_ADDR_VAR 0 9
59504: PUSH
59505: LD_VAR 0 10
59509: PPUSH
59510: LD_VAR 0 8
59514: PPUSH
59515: LD_INT 5
59517: PPUSH
59518: CALL_OW 272
59522: PUSH
59523: LD_VAR 0 11
59527: PPUSH
59528: LD_VAR 0 8
59532: PPUSH
59533: LD_INT 5
59535: PPUSH
59536: CALL_OW 273
59540: PUSH
59541: EMPTY
59542: LIST
59543: LIST
59544: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59545: LD_VAR 0 9
59549: PUSH
59550: LD_INT 1
59552: ARRAY
59553: PPUSH
59554: LD_VAR 0 9
59558: PUSH
59559: LD_INT 2
59561: ARRAY
59562: PPUSH
59563: CALL_OW 488
59567: IFFALSE 59666
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59569: LD_ADDR_VAR 0 4
59573: PUSH
59574: LD_VAR 0 9
59578: PUSH
59579: LD_INT 1
59581: ARRAY
59582: PPUSH
59583: LD_VAR 0 9
59587: PUSH
59588: LD_INT 2
59590: ARRAY
59591: PPUSH
59592: CALL_OW 546
59596: ST_TO_ADDR
// if hex [ 1 ] then
59597: LD_VAR 0 4
59601: PUSH
59602: LD_INT 1
59604: ARRAY
59605: IFFALSE 59609
// continue ;
59607: GO 59497
// h := hex [ 2 ] ;
59609: LD_ADDR_VAR 0 13
59613: PUSH
59614: LD_VAR 0 4
59618: PUSH
59619: LD_INT 2
59621: ARRAY
59622: ST_TO_ADDR
// if h + 7 < height then
59623: LD_VAR 0 13
59627: PUSH
59628: LD_INT 7
59630: PLUS
59631: PUSH
59632: LD_VAR 0 15
59636: LESS
59637: IFFALSE 59666
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59639: LD_ADDR_VAR 0 18
59643: PUSH
59644: LD_INT 7
59646: PUSH
59647: LD_INT 28
59649: PUSH
59650: LD_INT 45
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: LIST
59657: PUSH
59658: LD_VAR 0 12
59662: ARRAY
59663: ST_TO_ADDR
// break ;
59664: GO 59668
// end ; end ; end ;
59666: GO 59497
59668: POP
59669: POP
// end ; if not weapon then
59670: LD_VAR 0 18
59674: NOT
59675: IFFALSE 59735
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59677: LD_ADDR_VAR 0 5
59681: PUSH
59682: LD_VAR 0 5
59686: PUSH
59687: LD_INT 11
59689: PUSH
59690: LD_INT 30
59692: PUSH
59693: LD_INT 49
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: LIST
59700: DIFF
59701: ST_TO_ADDR
// if not list then
59702: LD_VAR 0 5
59706: NOT
59707: IFFALSE 59711
// exit ;
59709: GO 59853
// weapon := list [ rand ( 1 , list ) ] ;
59711: LD_ADDR_VAR 0 18
59715: PUSH
59716: LD_VAR 0 5
59720: PUSH
59721: LD_INT 1
59723: PPUSH
59724: LD_VAR 0 5
59728: PPUSH
59729: CALL_OW 12
59733: ARRAY
59734: ST_TO_ADDR
// end ; if weapon then
59735: LD_VAR 0 18
59739: IFFALSE 59853
// begin tmp := CostOfWeapon ( weapon ) ;
59741: LD_ADDR_VAR 0 14
59745: PUSH
59746: LD_VAR 0 18
59750: PPUSH
59751: CALL_OW 451
59755: ST_TO_ADDR
// j := GetBase ( tower ) ;
59756: LD_ADDR_VAR 0 9
59760: PUSH
59761: LD_VAR 0 1
59765: PPUSH
59766: CALL_OW 274
59770: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59771: LD_VAR 0 9
59775: PPUSH
59776: LD_INT 1
59778: PPUSH
59779: CALL_OW 275
59783: PUSH
59784: LD_VAR 0 14
59788: PUSH
59789: LD_INT 1
59791: ARRAY
59792: GREATEREQUAL
59793: PUSH
59794: LD_VAR 0 9
59798: PPUSH
59799: LD_INT 2
59801: PPUSH
59802: CALL_OW 275
59806: PUSH
59807: LD_VAR 0 14
59811: PUSH
59812: LD_INT 2
59814: ARRAY
59815: GREATEREQUAL
59816: AND
59817: PUSH
59818: LD_VAR 0 9
59822: PPUSH
59823: LD_INT 3
59825: PPUSH
59826: CALL_OW 275
59830: PUSH
59831: LD_VAR 0 14
59835: PUSH
59836: LD_INT 3
59838: ARRAY
59839: GREATEREQUAL
59840: AND
59841: IFFALSE 59853
// result := weapon ;
59843: LD_ADDR_VAR 0 3
59847: PUSH
59848: LD_VAR 0 18
59852: ST_TO_ADDR
// end ; end ;
59853: LD_VAR 0 3
59857: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59858: LD_INT 0
59860: PPUSH
59861: PPUSH
// result := true ;
59862: LD_ADDR_VAR 0 3
59866: PUSH
59867: LD_INT 1
59869: ST_TO_ADDR
// if array1 = array2 then
59870: LD_VAR 0 1
59874: PUSH
59875: LD_VAR 0 2
59879: EQUAL
59880: IFFALSE 59940
// begin for i = 1 to array1 do
59882: LD_ADDR_VAR 0 4
59886: PUSH
59887: DOUBLE
59888: LD_INT 1
59890: DEC
59891: ST_TO_ADDR
59892: LD_VAR 0 1
59896: PUSH
59897: FOR_TO
59898: IFFALSE 59936
// if array1 [ i ] <> array2 [ i ] then
59900: LD_VAR 0 1
59904: PUSH
59905: LD_VAR 0 4
59909: ARRAY
59910: PUSH
59911: LD_VAR 0 2
59915: PUSH
59916: LD_VAR 0 4
59920: ARRAY
59921: NONEQUAL
59922: IFFALSE 59934
// begin result := false ;
59924: LD_ADDR_VAR 0 3
59928: PUSH
59929: LD_INT 0
59931: ST_TO_ADDR
// break ;
59932: GO 59936
// end ;
59934: GO 59897
59936: POP
59937: POP
// end else
59938: GO 59948
// result := false ;
59940: LD_ADDR_VAR 0 3
59944: PUSH
59945: LD_INT 0
59947: ST_TO_ADDR
// end ;
59948: LD_VAR 0 3
59952: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59953: LD_INT 0
59955: PPUSH
59956: PPUSH
// if not array1 or not array2 then
59957: LD_VAR 0 1
59961: NOT
59962: PUSH
59963: LD_VAR 0 2
59967: NOT
59968: OR
59969: IFFALSE 59973
// exit ;
59971: GO 60037
// result := true ;
59973: LD_ADDR_VAR 0 3
59977: PUSH
59978: LD_INT 1
59980: ST_TO_ADDR
// for i = 1 to array1 do
59981: LD_ADDR_VAR 0 4
59985: PUSH
59986: DOUBLE
59987: LD_INT 1
59989: DEC
59990: ST_TO_ADDR
59991: LD_VAR 0 1
59995: PUSH
59996: FOR_TO
59997: IFFALSE 60035
// if array1 [ i ] <> array2 [ i ] then
59999: LD_VAR 0 1
60003: PUSH
60004: LD_VAR 0 4
60008: ARRAY
60009: PUSH
60010: LD_VAR 0 2
60014: PUSH
60015: LD_VAR 0 4
60019: ARRAY
60020: NONEQUAL
60021: IFFALSE 60033
// begin result := false ;
60023: LD_ADDR_VAR 0 3
60027: PUSH
60028: LD_INT 0
60030: ST_TO_ADDR
// break ;
60031: GO 60035
// end ;
60033: GO 59996
60035: POP
60036: POP
// end ;
60037: LD_VAR 0 3
60041: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60042: LD_INT 0
60044: PPUSH
60045: PPUSH
60046: PPUSH
// pom := GetBase ( fac ) ;
60047: LD_ADDR_VAR 0 5
60051: PUSH
60052: LD_VAR 0 1
60056: PPUSH
60057: CALL_OW 274
60061: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60062: LD_ADDR_VAR 0 4
60066: PUSH
60067: LD_VAR 0 2
60071: PUSH
60072: LD_INT 1
60074: ARRAY
60075: PPUSH
60076: LD_VAR 0 2
60080: PUSH
60081: LD_INT 2
60083: ARRAY
60084: PPUSH
60085: LD_VAR 0 2
60089: PUSH
60090: LD_INT 3
60092: ARRAY
60093: PPUSH
60094: LD_VAR 0 2
60098: PUSH
60099: LD_INT 4
60101: ARRAY
60102: PPUSH
60103: CALL_OW 449
60107: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60108: LD_ADDR_VAR 0 3
60112: PUSH
60113: LD_VAR 0 5
60117: PPUSH
60118: LD_INT 1
60120: PPUSH
60121: CALL_OW 275
60125: PUSH
60126: LD_VAR 0 4
60130: PUSH
60131: LD_INT 1
60133: ARRAY
60134: GREATEREQUAL
60135: PUSH
60136: LD_VAR 0 5
60140: PPUSH
60141: LD_INT 2
60143: PPUSH
60144: CALL_OW 275
60148: PUSH
60149: LD_VAR 0 4
60153: PUSH
60154: LD_INT 2
60156: ARRAY
60157: GREATEREQUAL
60158: AND
60159: PUSH
60160: LD_VAR 0 5
60164: PPUSH
60165: LD_INT 3
60167: PPUSH
60168: CALL_OW 275
60172: PUSH
60173: LD_VAR 0 4
60177: PUSH
60178: LD_INT 3
60180: ARRAY
60181: GREATEREQUAL
60182: AND
60183: ST_TO_ADDR
// end ;
60184: LD_VAR 0 3
60188: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60189: LD_INT 0
60191: PPUSH
60192: PPUSH
60193: PPUSH
60194: PPUSH
// pom := GetBase ( building ) ;
60195: LD_ADDR_VAR 0 3
60199: PUSH
60200: LD_VAR 0 1
60204: PPUSH
60205: CALL_OW 274
60209: ST_TO_ADDR
// if not pom then
60210: LD_VAR 0 3
60214: NOT
60215: IFFALSE 60219
// exit ;
60217: GO 60389
// btype := GetBType ( building ) ;
60219: LD_ADDR_VAR 0 5
60223: PUSH
60224: LD_VAR 0 1
60228: PPUSH
60229: CALL_OW 266
60233: ST_TO_ADDR
// if btype = b_armoury then
60234: LD_VAR 0 5
60238: PUSH
60239: LD_INT 4
60241: EQUAL
60242: IFFALSE 60252
// btype := b_barracks ;
60244: LD_ADDR_VAR 0 5
60248: PUSH
60249: LD_INT 5
60251: ST_TO_ADDR
// if btype = b_depot then
60252: LD_VAR 0 5
60256: PUSH
60257: LD_INT 0
60259: EQUAL
60260: IFFALSE 60270
// btype := b_warehouse ;
60262: LD_ADDR_VAR 0 5
60266: PUSH
60267: LD_INT 1
60269: ST_TO_ADDR
// if btype = b_workshop then
60270: LD_VAR 0 5
60274: PUSH
60275: LD_INT 2
60277: EQUAL
60278: IFFALSE 60288
// btype := b_factory ;
60280: LD_ADDR_VAR 0 5
60284: PUSH
60285: LD_INT 3
60287: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60288: LD_ADDR_VAR 0 4
60292: PUSH
60293: LD_VAR 0 5
60297: PPUSH
60298: LD_VAR 0 1
60302: PPUSH
60303: CALL_OW 248
60307: PPUSH
60308: CALL_OW 450
60312: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60313: LD_ADDR_VAR 0 2
60317: PUSH
60318: LD_VAR 0 3
60322: PPUSH
60323: LD_INT 1
60325: PPUSH
60326: CALL_OW 275
60330: PUSH
60331: LD_VAR 0 4
60335: PUSH
60336: LD_INT 1
60338: ARRAY
60339: GREATEREQUAL
60340: PUSH
60341: LD_VAR 0 3
60345: PPUSH
60346: LD_INT 2
60348: PPUSH
60349: CALL_OW 275
60353: PUSH
60354: LD_VAR 0 4
60358: PUSH
60359: LD_INT 2
60361: ARRAY
60362: GREATEREQUAL
60363: AND
60364: PUSH
60365: LD_VAR 0 3
60369: PPUSH
60370: LD_INT 3
60372: PPUSH
60373: CALL_OW 275
60377: PUSH
60378: LD_VAR 0 4
60382: PUSH
60383: LD_INT 3
60385: ARRAY
60386: GREATEREQUAL
60387: AND
60388: ST_TO_ADDR
// end ;
60389: LD_VAR 0 2
60393: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60394: LD_INT 0
60396: PPUSH
60397: PPUSH
60398: PPUSH
// pom := GetBase ( building ) ;
60399: LD_ADDR_VAR 0 4
60403: PUSH
60404: LD_VAR 0 1
60408: PPUSH
60409: CALL_OW 274
60413: ST_TO_ADDR
// if not pom then
60414: LD_VAR 0 4
60418: NOT
60419: IFFALSE 60423
// exit ;
60421: GO 60524
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60423: LD_ADDR_VAR 0 5
60427: PUSH
60428: LD_VAR 0 2
60432: PPUSH
60433: LD_VAR 0 1
60437: PPUSH
60438: CALL_OW 248
60442: PPUSH
60443: CALL_OW 450
60447: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60448: LD_ADDR_VAR 0 3
60452: PUSH
60453: LD_VAR 0 4
60457: PPUSH
60458: LD_INT 1
60460: PPUSH
60461: CALL_OW 275
60465: PUSH
60466: LD_VAR 0 5
60470: PUSH
60471: LD_INT 1
60473: ARRAY
60474: GREATEREQUAL
60475: PUSH
60476: LD_VAR 0 4
60480: PPUSH
60481: LD_INT 2
60483: PPUSH
60484: CALL_OW 275
60488: PUSH
60489: LD_VAR 0 5
60493: PUSH
60494: LD_INT 2
60496: ARRAY
60497: GREATEREQUAL
60498: AND
60499: PUSH
60500: LD_VAR 0 4
60504: PPUSH
60505: LD_INT 3
60507: PPUSH
60508: CALL_OW 275
60512: PUSH
60513: LD_VAR 0 5
60517: PUSH
60518: LD_INT 3
60520: ARRAY
60521: GREATEREQUAL
60522: AND
60523: ST_TO_ADDR
// end ;
60524: LD_VAR 0 3
60528: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60529: LD_INT 0
60531: PPUSH
60532: PPUSH
60533: PPUSH
60534: PPUSH
60535: PPUSH
60536: PPUSH
60537: PPUSH
60538: PPUSH
60539: PPUSH
60540: PPUSH
60541: PPUSH
// result := false ;
60542: LD_ADDR_VAR 0 8
60546: PUSH
60547: LD_INT 0
60549: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60550: LD_VAR 0 5
60554: NOT
60555: PUSH
60556: LD_VAR 0 1
60560: NOT
60561: OR
60562: PUSH
60563: LD_VAR 0 2
60567: NOT
60568: OR
60569: PUSH
60570: LD_VAR 0 3
60574: NOT
60575: OR
60576: IFFALSE 60580
// exit ;
60578: GO 61394
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60580: LD_ADDR_VAR 0 14
60584: PUSH
60585: LD_VAR 0 1
60589: PPUSH
60590: LD_VAR 0 2
60594: PPUSH
60595: LD_VAR 0 3
60599: PPUSH
60600: LD_VAR 0 4
60604: PPUSH
60605: LD_VAR 0 5
60609: PUSH
60610: LD_INT 1
60612: ARRAY
60613: PPUSH
60614: CALL_OW 248
60618: PPUSH
60619: LD_INT 0
60621: PPUSH
60622: CALL 62627 0 6
60626: ST_TO_ADDR
// if not hexes then
60627: LD_VAR 0 14
60631: NOT
60632: IFFALSE 60636
// exit ;
60634: GO 61394
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60636: LD_ADDR_VAR 0 17
60640: PUSH
60641: LD_VAR 0 5
60645: PPUSH
60646: LD_INT 22
60648: PUSH
60649: LD_VAR 0 13
60653: PPUSH
60654: CALL_OW 255
60658: PUSH
60659: EMPTY
60660: LIST
60661: LIST
60662: PUSH
60663: LD_INT 2
60665: PUSH
60666: LD_INT 30
60668: PUSH
60669: LD_INT 0
60671: PUSH
60672: EMPTY
60673: LIST
60674: LIST
60675: PUSH
60676: LD_INT 30
60678: PUSH
60679: LD_INT 1
60681: PUSH
60682: EMPTY
60683: LIST
60684: LIST
60685: PUSH
60686: EMPTY
60687: LIST
60688: LIST
60689: LIST
60690: PUSH
60691: EMPTY
60692: LIST
60693: LIST
60694: PPUSH
60695: CALL_OW 72
60699: ST_TO_ADDR
// for i = 1 to hexes do
60700: LD_ADDR_VAR 0 9
60704: PUSH
60705: DOUBLE
60706: LD_INT 1
60708: DEC
60709: ST_TO_ADDR
60710: LD_VAR 0 14
60714: PUSH
60715: FOR_TO
60716: IFFALSE 61392
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60718: LD_ADDR_VAR 0 13
60722: PUSH
60723: LD_VAR 0 14
60727: PUSH
60728: LD_VAR 0 9
60732: ARRAY
60733: PUSH
60734: LD_INT 1
60736: ARRAY
60737: PPUSH
60738: LD_VAR 0 14
60742: PUSH
60743: LD_VAR 0 9
60747: ARRAY
60748: PUSH
60749: LD_INT 2
60751: ARRAY
60752: PPUSH
60753: CALL_OW 428
60757: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60758: LD_VAR 0 14
60762: PUSH
60763: LD_VAR 0 9
60767: ARRAY
60768: PUSH
60769: LD_INT 1
60771: ARRAY
60772: PPUSH
60773: LD_VAR 0 14
60777: PUSH
60778: LD_VAR 0 9
60782: ARRAY
60783: PUSH
60784: LD_INT 2
60786: ARRAY
60787: PPUSH
60788: CALL_OW 351
60792: PUSH
60793: LD_VAR 0 14
60797: PUSH
60798: LD_VAR 0 9
60802: ARRAY
60803: PUSH
60804: LD_INT 1
60806: ARRAY
60807: PPUSH
60808: LD_VAR 0 14
60812: PUSH
60813: LD_VAR 0 9
60817: ARRAY
60818: PUSH
60819: LD_INT 2
60821: ARRAY
60822: PPUSH
60823: CALL_OW 488
60827: NOT
60828: OR
60829: PUSH
60830: LD_VAR 0 13
60834: PPUSH
60835: CALL_OW 247
60839: PUSH
60840: LD_INT 3
60842: EQUAL
60843: OR
60844: IFFALSE 60850
// exit ;
60846: POP
60847: POP
60848: GO 61394
// if not tmp then
60850: LD_VAR 0 13
60854: NOT
60855: IFFALSE 60859
// continue ;
60857: GO 60715
// result := true ;
60859: LD_ADDR_VAR 0 8
60863: PUSH
60864: LD_INT 1
60866: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60867: LD_VAR 0 6
60871: PUSH
60872: LD_VAR 0 13
60876: PPUSH
60877: CALL_OW 247
60881: PUSH
60882: LD_INT 2
60884: EQUAL
60885: AND
60886: PUSH
60887: LD_VAR 0 13
60891: PPUSH
60892: CALL_OW 263
60896: PUSH
60897: LD_INT 1
60899: EQUAL
60900: AND
60901: IFFALSE 61065
// begin if IsDrivenBy ( tmp ) then
60903: LD_VAR 0 13
60907: PPUSH
60908: CALL_OW 311
60912: IFFALSE 60916
// continue ;
60914: GO 60715
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60916: LD_VAR 0 6
60920: PPUSH
60921: LD_INT 3
60923: PUSH
60924: LD_INT 60
60926: PUSH
60927: EMPTY
60928: LIST
60929: PUSH
60930: EMPTY
60931: LIST
60932: LIST
60933: PUSH
60934: LD_INT 3
60936: PUSH
60937: LD_INT 55
60939: PUSH
60940: EMPTY
60941: LIST
60942: PUSH
60943: EMPTY
60944: LIST
60945: LIST
60946: PUSH
60947: EMPTY
60948: LIST
60949: LIST
60950: PPUSH
60951: CALL_OW 72
60955: IFFALSE 61063
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60957: LD_ADDR_VAR 0 18
60961: PUSH
60962: LD_VAR 0 6
60966: PPUSH
60967: LD_INT 3
60969: PUSH
60970: LD_INT 60
60972: PUSH
60973: EMPTY
60974: LIST
60975: PUSH
60976: EMPTY
60977: LIST
60978: LIST
60979: PUSH
60980: LD_INT 3
60982: PUSH
60983: LD_INT 55
60985: PUSH
60986: EMPTY
60987: LIST
60988: PUSH
60989: EMPTY
60990: LIST
60991: LIST
60992: PUSH
60993: EMPTY
60994: LIST
60995: LIST
60996: PPUSH
60997: CALL_OW 72
61001: PUSH
61002: LD_INT 1
61004: ARRAY
61005: ST_TO_ADDR
// if IsInUnit ( driver ) then
61006: LD_VAR 0 18
61010: PPUSH
61011: CALL_OW 310
61015: IFFALSE 61026
// ComExit ( driver ) ;
61017: LD_VAR 0 18
61021: PPUSH
61022: CALL 86315 0 1
// AddComEnterUnit ( driver , tmp ) ;
61026: LD_VAR 0 18
61030: PPUSH
61031: LD_VAR 0 13
61035: PPUSH
61036: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61040: LD_VAR 0 18
61044: PPUSH
61045: LD_VAR 0 7
61049: PPUSH
61050: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61054: LD_VAR 0 18
61058: PPUSH
61059: CALL_OW 181
// end ; continue ;
61063: GO 60715
// end ; if not cleaners or not tmp in cleaners then
61065: LD_VAR 0 6
61069: NOT
61070: PUSH
61071: LD_VAR 0 13
61075: PUSH
61076: LD_VAR 0 6
61080: IN
61081: NOT
61082: OR
61083: IFFALSE 61390
// begin if dep then
61085: LD_VAR 0 17
61089: IFFALSE 61225
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61091: LD_ADDR_VAR 0 16
61095: PUSH
61096: LD_VAR 0 17
61100: PUSH
61101: LD_INT 1
61103: ARRAY
61104: PPUSH
61105: CALL_OW 250
61109: PPUSH
61110: LD_VAR 0 17
61114: PUSH
61115: LD_INT 1
61117: ARRAY
61118: PPUSH
61119: CALL_OW 254
61123: PPUSH
61124: LD_INT 5
61126: PPUSH
61127: CALL_OW 272
61131: PUSH
61132: LD_VAR 0 17
61136: PUSH
61137: LD_INT 1
61139: ARRAY
61140: PPUSH
61141: CALL_OW 251
61145: PPUSH
61146: LD_VAR 0 17
61150: PUSH
61151: LD_INT 1
61153: ARRAY
61154: PPUSH
61155: CALL_OW 254
61159: PPUSH
61160: LD_INT 5
61162: PPUSH
61163: CALL_OW 273
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61172: LD_VAR 0 16
61176: PUSH
61177: LD_INT 1
61179: ARRAY
61180: PPUSH
61181: LD_VAR 0 16
61185: PUSH
61186: LD_INT 2
61188: ARRAY
61189: PPUSH
61190: CALL_OW 488
61194: IFFALSE 61225
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61196: LD_VAR 0 13
61200: PPUSH
61201: LD_VAR 0 16
61205: PUSH
61206: LD_INT 1
61208: ARRAY
61209: PPUSH
61210: LD_VAR 0 16
61214: PUSH
61215: LD_INT 2
61217: ARRAY
61218: PPUSH
61219: CALL_OW 111
// continue ;
61223: GO 60715
// end ; end ; r := GetDir ( tmp ) ;
61225: LD_ADDR_VAR 0 15
61229: PUSH
61230: LD_VAR 0 13
61234: PPUSH
61235: CALL_OW 254
61239: ST_TO_ADDR
// if r = 5 then
61240: LD_VAR 0 15
61244: PUSH
61245: LD_INT 5
61247: EQUAL
61248: IFFALSE 61258
// r := 0 ;
61250: LD_ADDR_VAR 0 15
61254: PUSH
61255: LD_INT 0
61257: ST_TO_ADDR
// for j = r to 5 do
61258: LD_ADDR_VAR 0 10
61262: PUSH
61263: DOUBLE
61264: LD_VAR 0 15
61268: DEC
61269: ST_TO_ADDR
61270: LD_INT 5
61272: PUSH
61273: FOR_TO
61274: IFFALSE 61388
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61276: LD_ADDR_VAR 0 11
61280: PUSH
61281: LD_VAR 0 13
61285: PPUSH
61286: CALL_OW 250
61290: PPUSH
61291: LD_VAR 0 10
61295: PPUSH
61296: LD_INT 2
61298: PPUSH
61299: CALL_OW 272
61303: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61304: LD_ADDR_VAR 0 12
61308: PUSH
61309: LD_VAR 0 13
61313: PPUSH
61314: CALL_OW 251
61318: PPUSH
61319: LD_VAR 0 10
61323: PPUSH
61324: LD_INT 2
61326: PPUSH
61327: CALL_OW 273
61331: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61332: LD_VAR 0 11
61336: PPUSH
61337: LD_VAR 0 12
61341: PPUSH
61342: CALL_OW 488
61346: PUSH
61347: LD_VAR 0 11
61351: PPUSH
61352: LD_VAR 0 12
61356: PPUSH
61357: CALL_OW 428
61361: NOT
61362: AND
61363: IFFALSE 61386
// begin ComMoveXY ( tmp , _x , _y ) ;
61365: LD_VAR 0 13
61369: PPUSH
61370: LD_VAR 0 11
61374: PPUSH
61375: LD_VAR 0 12
61379: PPUSH
61380: CALL_OW 111
// break ;
61384: GO 61388
// end ; end ;
61386: GO 61273
61388: POP
61389: POP
// end ; end ;
61390: GO 60715
61392: POP
61393: POP
// end ;
61394: LD_VAR 0 8
61398: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61399: LD_INT 0
61401: PPUSH
// result := true ;
61402: LD_ADDR_VAR 0 3
61406: PUSH
61407: LD_INT 1
61409: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61410: LD_VAR 0 2
61414: PUSH
61415: LD_INT 24
61417: DOUBLE
61418: EQUAL
61419: IFTRUE 61429
61421: LD_INT 33
61423: DOUBLE
61424: EQUAL
61425: IFTRUE 61429
61427: GO 61454
61429: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61430: LD_ADDR_VAR 0 3
61434: PUSH
61435: LD_INT 32
61437: PPUSH
61438: LD_VAR 0 1
61442: PPUSH
61443: CALL_OW 321
61447: PUSH
61448: LD_INT 2
61450: EQUAL
61451: ST_TO_ADDR
61452: GO 61770
61454: LD_INT 20
61456: DOUBLE
61457: EQUAL
61458: IFTRUE 61462
61460: GO 61487
61462: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61463: LD_ADDR_VAR 0 3
61467: PUSH
61468: LD_INT 6
61470: PPUSH
61471: LD_VAR 0 1
61475: PPUSH
61476: CALL_OW 321
61480: PUSH
61481: LD_INT 2
61483: EQUAL
61484: ST_TO_ADDR
61485: GO 61770
61487: LD_INT 22
61489: DOUBLE
61490: EQUAL
61491: IFTRUE 61501
61493: LD_INT 36
61495: DOUBLE
61496: EQUAL
61497: IFTRUE 61501
61499: GO 61526
61501: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61502: LD_ADDR_VAR 0 3
61506: PUSH
61507: LD_INT 15
61509: PPUSH
61510: LD_VAR 0 1
61514: PPUSH
61515: CALL_OW 321
61519: PUSH
61520: LD_INT 2
61522: EQUAL
61523: ST_TO_ADDR
61524: GO 61770
61526: LD_INT 30
61528: DOUBLE
61529: EQUAL
61530: IFTRUE 61534
61532: GO 61559
61534: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61535: LD_ADDR_VAR 0 3
61539: PUSH
61540: LD_INT 20
61542: PPUSH
61543: LD_VAR 0 1
61547: PPUSH
61548: CALL_OW 321
61552: PUSH
61553: LD_INT 2
61555: EQUAL
61556: ST_TO_ADDR
61557: GO 61770
61559: LD_INT 28
61561: DOUBLE
61562: EQUAL
61563: IFTRUE 61573
61565: LD_INT 21
61567: DOUBLE
61568: EQUAL
61569: IFTRUE 61573
61571: GO 61598
61573: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61574: LD_ADDR_VAR 0 3
61578: PUSH
61579: LD_INT 21
61581: PPUSH
61582: LD_VAR 0 1
61586: PPUSH
61587: CALL_OW 321
61591: PUSH
61592: LD_INT 2
61594: EQUAL
61595: ST_TO_ADDR
61596: GO 61770
61598: LD_INT 16
61600: DOUBLE
61601: EQUAL
61602: IFTRUE 61606
61604: GO 61631
61606: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61607: LD_ADDR_VAR 0 3
61611: PUSH
61612: LD_INT 84
61614: PPUSH
61615: LD_VAR 0 1
61619: PPUSH
61620: CALL_OW 321
61624: PUSH
61625: LD_INT 2
61627: EQUAL
61628: ST_TO_ADDR
61629: GO 61770
61631: LD_INT 19
61633: DOUBLE
61634: EQUAL
61635: IFTRUE 61645
61637: LD_INT 23
61639: DOUBLE
61640: EQUAL
61641: IFTRUE 61645
61643: GO 61670
61645: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61646: LD_ADDR_VAR 0 3
61650: PUSH
61651: LD_INT 83
61653: PPUSH
61654: LD_VAR 0 1
61658: PPUSH
61659: CALL_OW 321
61663: PUSH
61664: LD_INT 2
61666: EQUAL
61667: ST_TO_ADDR
61668: GO 61770
61670: LD_INT 17
61672: DOUBLE
61673: EQUAL
61674: IFTRUE 61678
61676: GO 61703
61678: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61679: LD_ADDR_VAR 0 3
61683: PUSH
61684: LD_INT 39
61686: PPUSH
61687: LD_VAR 0 1
61691: PPUSH
61692: CALL_OW 321
61696: PUSH
61697: LD_INT 2
61699: EQUAL
61700: ST_TO_ADDR
61701: GO 61770
61703: LD_INT 18
61705: DOUBLE
61706: EQUAL
61707: IFTRUE 61711
61709: GO 61736
61711: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61712: LD_ADDR_VAR 0 3
61716: PUSH
61717: LD_INT 40
61719: PPUSH
61720: LD_VAR 0 1
61724: PPUSH
61725: CALL_OW 321
61729: PUSH
61730: LD_INT 2
61732: EQUAL
61733: ST_TO_ADDR
61734: GO 61770
61736: LD_INT 27
61738: DOUBLE
61739: EQUAL
61740: IFTRUE 61744
61742: GO 61769
61744: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61745: LD_ADDR_VAR 0 3
61749: PUSH
61750: LD_INT 35
61752: PPUSH
61753: LD_VAR 0 1
61757: PPUSH
61758: CALL_OW 321
61762: PUSH
61763: LD_INT 2
61765: EQUAL
61766: ST_TO_ADDR
61767: GO 61770
61769: POP
// end ;
61770: LD_VAR 0 3
61774: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61775: LD_INT 0
61777: PPUSH
61778: PPUSH
61779: PPUSH
61780: PPUSH
61781: PPUSH
61782: PPUSH
61783: PPUSH
61784: PPUSH
61785: PPUSH
61786: PPUSH
61787: PPUSH
// result := false ;
61788: LD_ADDR_VAR 0 6
61792: PUSH
61793: LD_INT 0
61795: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61796: LD_VAR 0 1
61800: NOT
61801: PUSH
61802: LD_VAR 0 1
61806: PPUSH
61807: CALL_OW 266
61811: PUSH
61812: LD_INT 0
61814: PUSH
61815: LD_INT 1
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: IN
61822: NOT
61823: OR
61824: PUSH
61825: LD_VAR 0 2
61829: NOT
61830: OR
61831: PUSH
61832: LD_VAR 0 5
61836: PUSH
61837: LD_INT 0
61839: PUSH
61840: LD_INT 1
61842: PUSH
61843: LD_INT 2
61845: PUSH
61846: LD_INT 3
61848: PUSH
61849: LD_INT 4
61851: PUSH
61852: LD_INT 5
61854: PUSH
61855: EMPTY
61856: LIST
61857: LIST
61858: LIST
61859: LIST
61860: LIST
61861: LIST
61862: IN
61863: NOT
61864: OR
61865: PUSH
61866: LD_VAR 0 3
61870: PPUSH
61871: LD_VAR 0 4
61875: PPUSH
61876: CALL_OW 488
61880: NOT
61881: OR
61882: IFFALSE 61886
// exit ;
61884: GO 62622
// side := GetSide ( depot ) ;
61886: LD_ADDR_VAR 0 9
61890: PUSH
61891: LD_VAR 0 1
61895: PPUSH
61896: CALL_OW 255
61900: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61901: LD_VAR 0 9
61905: PPUSH
61906: LD_VAR 0 2
61910: PPUSH
61911: CALL 61399 0 2
61915: NOT
61916: IFFALSE 61920
// exit ;
61918: GO 62622
// pom := GetBase ( depot ) ;
61920: LD_ADDR_VAR 0 10
61924: PUSH
61925: LD_VAR 0 1
61929: PPUSH
61930: CALL_OW 274
61934: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61935: LD_ADDR_VAR 0 11
61939: PUSH
61940: LD_VAR 0 2
61944: PPUSH
61945: LD_VAR 0 1
61949: PPUSH
61950: CALL_OW 248
61954: PPUSH
61955: CALL_OW 450
61959: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61960: LD_VAR 0 10
61964: PPUSH
61965: LD_INT 1
61967: PPUSH
61968: CALL_OW 275
61972: PUSH
61973: LD_VAR 0 11
61977: PUSH
61978: LD_INT 1
61980: ARRAY
61981: GREATEREQUAL
61982: PUSH
61983: LD_VAR 0 10
61987: PPUSH
61988: LD_INT 2
61990: PPUSH
61991: CALL_OW 275
61995: PUSH
61996: LD_VAR 0 11
62000: PUSH
62001: LD_INT 2
62003: ARRAY
62004: GREATEREQUAL
62005: AND
62006: PUSH
62007: LD_VAR 0 10
62011: PPUSH
62012: LD_INT 3
62014: PPUSH
62015: CALL_OW 275
62019: PUSH
62020: LD_VAR 0 11
62024: PUSH
62025: LD_INT 3
62027: ARRAY
62028: GREATEREQUAL
62029: AND
62030: NOT
62031: IFFALSE 62035
// exit ;
62033: GO 62622
// if GetBType ( depot ) = b_depot then
62035: LD_VAR 0 1
62039: PPUSH
62040: CALL_OW 266
62044: PUSH
62045: LD_INT 0
62047: EQUAL
62048: IFFALSE 62060
// dist := 28 else
62050: LD_ADDR_VAR 0 14
62054: PUSH
62055: LD_INT 28
62057: ST_TO_ADDR
62058: GO 62068
// dist := 36 ;
62060: LD_ADDR_VAR 0 14
62064: PUSH
62065: LD_INT 36
62067: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62068: LD_VAR 0 1
62072: PPUSH
62073: LD_VAR 0 3
62077: PPUSH
62078: LD_VAR 0 4
62082: PPUSH
62083: CALL_OW 297
62087: PUSH
62088: LD_VAR 0 14
62092: GREATER
62093: IFFALSE 62097
// exit ;
62095: GO 62622
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62097: LD_ADDR_VAR 0 12
62101: PUSH
62102: LD_VAR 0 2
62106: PPUSH
62107: LD_VAR 0 3
62111: PPUSH
62112: LD_VAR 0 4
62116: PPUSH
62117: LD_VAR 0 5
62121: PPUSH
62122: LD_VAR 0 1
62126: PPUSH
62127: CALL_OW 248
62131: PPUSH
62132: LD_INT 0
62134: PPUSH
62135: CALL 62627 0 6
62139: ST_TO_ADDR
// if not hexes then
62140: LD_VAR 0 12
62144: NOT
62145: IFFALSE 62149
// exit ;
62147: GO 62622
// hex := GetHexInfo ( x , y ) ;
62149: LD_ADDR_VAR 0 15
62153: PUSH
62154: LD_VAR 0 3
62158: PPUSH
62159: LD_VAR 0 4
62163: PPUSH
62164: CALL_OW 546
62168: ST_TO_ADDR
// if hex [ 1 ] then
62169: LD_VAR 0 15
62173: PUSH
62174: LD_INT 1
62176: ARRAY
62177: IFFALSE 62181
// exit ;
62179: GO 62622
// height := hex [ 2 ] ;
62181: LD_ADDR_VAR 0 13
62185: PUSH
62186: LD_VAR 0 15
62190: PUSH
62191: LD_INT 2
62193: ARRAY
62194: ST_TO_ADDR
// for i = 1 to hexes do
62195: LD_ADDR_VAR 0 7
62199: PUSH
62200: DOUBLE
62201: LD_INT 1
62203: DEC
62204: ST_TO_ADDR
62205: LD_VAR 0 12
62209: PUSH
62210: FOR_TO
62211: IFFALSE 62541
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62213: LD_VAR 0 12
62217: PUSH
62218: LD_VAR 0 7
62222: ARRAY
62223: PUSH
62224: LD_INT 1
62226: ARRAY
62227: PPUSH
62228: LD_VAR 0 12
62232: PUSH
62233: LD_VAR 0 7
62237: ARRAY
62238: PUSH
62239: LD_INT 2
62241: ARRAY
62242: PPUSH
62243: CALL_OW 488
62247: NOT
62248: PUSH
62249: LD_VAR 0 12
62253: PUSH
62254: LD_VAR 0 7
62258: ARRAY
62259: PUSH
62260: LD_INT 1
62262: ARRAY
62263: PPUSH
62264: LD_VAR 0 12
62268: PUSH
62269: LD_VAR 0 7
62273: ARRAY
62274: PUSH
62275: LD_INT 2
62277: ARRAY
62278: PPUSH
62279: CALL_OW 428
62283: PUSH
62284: LD_INT 0
62286: GREATER
62287: OR
62288: PUSH
62289: LD_VAR 0 12
62293: PUSH
62294: LD_VAR 0 7
62298: ARRAY
62299: PUSH
62300: LD_INT 1
62302: ARRAY
62303: PPUSH
62304: LD_VAR 0 12
62308: PUSH
62309: LD_VAR 0 7
62313: ARRAY
62314: PUSH
62315: LD_INT 2
62317: ARRAY
62318: PPUSH
62319: CALL_OW 351
62323: OR
62324: IFFALSE 62330
// exit ;
62326: POP
62327: POP
62328: GO 62622
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62330: LD_ADDR_VAR 0 8
62334: PUSH
62335: LD_VAR 0 12
62339: PUSH
62340: LD_VAR 0 7
62344: ARRAY
62345: PUSH
62346: LD_INT 1
62348: ARRAY
62349: PPUSH
62350: LD_VAR 0 12
62354: PUSH
62355: LD_VAR 0 7
62359: ARRAY
62360: PUSH
62361: LD_INT 2
62363: ARRAY
62364: PPUSH
62365: CALL_OW 546
62369: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62370: LD_VAR 0 8
62374: PUSH
62375: LD_INT 1
62377: ARRAY
62378: PUSH
62379: LD_VAR 0 8
62383: PUSH
62384: LD_INT 2
62386: ARRAY
62387: PUSH
62388: LD_VAR 0 13
62392: PUSH
62393: LD_INT 2
62395: PLUS
62396: GREATER
62397: OR
62398: PUSH
62399: LD_VAR 0 8
62403: PUSH
62404: LD_INT 2
62406: ARRAY
62407: PUSH
62408: LD_VAR 0 13
62412: PUSH
62413: LD_INT 2
62415: MINUS
62416: LESS
62417: OR
62418: PUSH
62419: LD_VAR 0 8
62423: PUSH
62424: LD_INT 3
62426: ARRAY
62427: PUSH
62428: LD_INT 0
62430: PUSH
62431: LD_INT 8
62433: PUSH
62434: LD_INT 9
62436: PUSH
62437: LD_INT 10
62439: PUSH
62440: LD_INT 11
62442: PUSH
62443: LD_INT 12
62445: PUSH
62446: LD_INT 13
62448: PUSH
62449: LD_INT 16
62451: PUSH
62452: LD_INT 17
62454: PUSH
62455: LD_INT 18
62457: PUSH
62458: LD_INT 19
62460: PUSH
62461: LD_INT 20
62463: PUSH
62464: LD_INT 21
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: LIST
62471: LIST
62472: LIST
62473: LIST
62474: LIST
62475: LIST
62476: LIST
62477: LIST
62478: LIST
62479: LIST
62480: LIST
62481: IN
62482: NOT
62483: OR
62484: PUSH
62485: LD_VAR 0 8
62489: PUSH
62490: LD_INT 5
62492: ARRAY
62493: NOT
62494: OR
62495: PUSH
62496: LD_VAR 0 8
62500: PUSH
62501: LD_INT 6
62503: ARRAY
62504: PUSH
62505: LD_INT 1
62507: PUSH
62508: LD_INT 2
62510: PUSH
62511: LD_INT 7
62513: PUSH
62514: LD_INT 9
62516: PUSH
62517: LD_INT 10
62519: PUSH
62520: LD_INT 11
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: LIST
62527: LIST
62528: LIST
62529: LIST
62530: IN
62531: NOT
62532: OR
62533: IFFALSE 62539
// exit ;
62535: POP
62536: POP
62537: GO 62622
// end ;
62539: GO 62210
62541: POP
62542: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62543: LD_VAR 0 9
62547: PPUSH
62548: LD_VAR 0 3
62552: PPUSH
62553: LD_VAR 0 4
62557: PPUSH
62558: LD_INT 20
62560: PPUSH
62561: CALL 54574 0 4
62565: PUSH
62566: LD_INT 4
62568: ARRAY
62569: IFFALSE 62573
// exit ;
62571: GO 62622
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62573: LD_VAR 0 2
62577: PUSH
62578: LD_INT 29
62580: PUSH
62581: LD_INT 30
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: IN
62588: PUSH
62589: LD_VAR 0 3
62593: PPUSH
62594: LD_VAR 0 4
62598: PPUSH
62599: LD_VAR 0 9
62603: PPUSH
62604: CALL_OW 440
62608: NOT
62609: AND
62610: IFFALSE 62614
// exit ;
62612: GO 62622
// result := true ;
62614: LD_ADDR_VAR 0 6
62618: PUSH
62619: LD_INT 1
62621: ST_TO_ADDR
// end ;
62622: LD_VAR 0 6
62626: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62627: LD_INT 0
62629: PPUSH
62630: PPUSH
62631: PPUSH
62632: PPUSH
62633: PPUSH
62634: PPUSH
62635: PPUSH
62636: PPUSH
62637: PPUSH
62638: PPUSH
62639: PPUSH
62640: PPUSH
62641: PPUSH
62642: PPUSH
62643: PPUSH
62644: PPUSH
62645: PPUSH
62646: PPUSH
62647: PPUSH
62648: PPUSH
62649: PPUSH
62650: PPUSH
62651: PPUSH
62652: PPUSH
62653: PPUSH
62654: PPUSH
62655: PPUSH
62656: PPUSH
62657: PPUSH
62658: PPUSH
62659: PPUSH
62660: PPUSH
62661: PPUSH
62662: PPUSH
62663: PPUSH
62664: PPUSH
62665: PPUSH
62666: PPUSH
62667: PPUSH
62668: PPUSH
62669: PPUSH
62670: PPUSH
62671: PPUSH
62672: PPUSH
62673: PPUSH
62674: PPUSH
62675: PPUSH
62676: PPUSH
62677: PPUSH
62678: PPUSH
62679: PPUSH
62680: PPUSH
62681: PPUSH
62682: PPUSH
62683: PPUSH
62684: PPUSH
62685: PPUSH
62686: PPUSH
// result = [ ] ;
62687: LD_ADDR_VAR 0 7
62691: PUSH
62692: EMPTY
62693: ST_TO_ADDR
// temp_list = [ ] ;
62694: LD_ADDR_VAR 0 9
62698: PUSH
62699: EMPTY
62700: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62701: LD_VAR 0 4
62705: PUSH
62706: LD_INT 0
62708: PUSH
62709: LD_INT 1
62711: PUSH
62712: LD_INT 2
62714: PUSH
62715: LD_INT 3
62717: PUSH
62718: LD_INT 4
62720: PUSH
62721: LD_INT 5
62723: PUSH
62724: EMPTY
62725: LIST
62726: LIST
62727: LIST
62728: LIST
62729: LIST
62730: LIST
62731: IN
62732: NOT
62733: PUSH
62734: LD_VAR 0 1
62738: PUSH
62739: LD_INT 0
62741: PUSH
62742: LD_INT 1
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: IN
62749: PUSH
62750: LD_VAR 0 5
62754: PUSH
62755: LD_INT 1
62757: PUSH
62758: LD_INT 2
62760: PUSH
62761: LD_INT 3
62763: PUSH
62764: EMPTY
62765: LIST
62766: LIST
62767: LIST
62768: IN
62769: NOT
62770: AND
62771: OR
62772: IFFALSE 62776
// exit ;
62774: GO 81167
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62776: LD_VAR 0 1
62780: PUSH
62781: LD_INT 6
62783: PUSH
62784: LD_INT 7
62786: PUSH
62787: LD_INT 8
62789: PUSH
62790: LD_INT 13
62792: PUSH
62793: LD_INT 12
62795: PUSH
62796: LD_INT 15
62798: PUSH
62799: LD_INT 11
62801: PUSH
62802: LD_INT 14
62804: PUSH
62805: LD_INT 10
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: LIST
62812: LIST
62813: LIST
62814: LIST
62815: LIST
62816: LIST
62817: LIST
62818: IN
62819: IFFALSE 62829
// btype = b_lab ;
62821: LD_ADDR_VAR 0 1
62825: PUSH
62826: LD_INT 6
62828: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62829: LD_VAR 0 6
62833: PUSH
62834: LD_INT 0
62836: PUSH
62837: LD_INT 1
62839: PUSH
62840: LD_INT 2
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: LIST
62847: IN
62848: NOT
62849: PUSH
62850: LD_VAR 0 1
62854: PUSH
62855: LD_INT 0
62857: PUSH
62858: LD_INT 1
62860: PUSH
62861: LD_INT 2
62863: PUSH
62864: LD_INT 3
62866: PUSH
62867: LD_INT 6
62869: PUSH
62870: LD_INT 36
62872: PUSH
62873: LD_INT 4
62875: PUSH
62876: LD_INT 5
62878: PUSH
62879: LD_INT 31
62881: PUSH
62882: LD_INT 32
62884: PUSH
62885: LD_INT 33
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: LIST
62898: LIST
62899: LIST
62900: IN
62901: NOT
62902: PUSH
62903: LD_VAR 0 6
62907: PUSH
62908: LD_INT 1
62910: EQUAL
62911: AND
62912: OR
62913: PUSH
62914: LD_VAR 0 1
62918: PUSH
62919: LD_INT 2
62921: PUSH
62922: LD_INT 3
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: IN
62929: NOT
62930: PUSH
62931: LD_VAR 0 6
62935: PUSH
62936: LD_INT 2
62938: EQUAL
62939: AND
62940: OR
62941: IFFALSE 62951
// mode = 0 ;
62943: LD_ADDR_VAR 0 6
62947: PUSH
62948: LD_INT 0
62950: ST_TO_ADDR
// case mode of 0 :
62951: LD_VAR 0 6
62955: PUSH
62956: LD_INT 0
62958: DOUBLE
62959: EQUAL
62960: IFTRUE 62964
62962: GO 74417
62964: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62965: LD_ADDR_VAR 0 11
62969: PUSH
62970: LD_INT 0
62972: PUSH
62973: LD_INT 0
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: PUSH
62980: LD_INT 0
62982: PUSH
62983: LD_INT 1
62985: NEG
62986: PUSH
62987: EMPTY
62988: LIST
62989: LIST
62990: PUSH
62991: LD_INT 1
62993: PUSH
62994: LD_INT 0
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: PUSH
63001: LD_INT 1
63003: PUSH
63004: LD_INT 1
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 0
63013: PUSH
63014: LD_INT 1
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: LD_INT 1
63023: NEG
63024: PUSH
63025: LD_INT 0
63027: PUSH
63028: EMPTY
63029: LIST
63030: LIST
63031: PUSH
63032: LD_INT 1
63034: NEG
63035: PUSH
63036: LD_INT 1
63038: NEG
63039: PUSH
63040: EMPTY
63041: LIST
63042: LIST
63043: PUSH
63044: LD_INT 1
63046: NEG
63047: PUSH
63048: LD_INT 2
63050: NEG
63051: PUSH
63052: EMPTY
63053: LIST
63054: LIST
63055: PUSH
63056: LD_INT 0
63058: PUSH
63059: LD_INT 2
63061: NEG
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: PUSH
63067: LD_INT 1
63069: PUSH
63070: LD_INT 1
63072: NEG
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PUSH
63078: LD_INT 1
63080: PUSH
63081: LD_INT 2
63083: PUSH
63084: EMPTY
63085: LIST
63086: LIST
63087: PUSH
63088: LD_INT 0
63090: PUSH
63091: LD_INT 2
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: PUSH
63098: LD_INT 1
63100: NEG
63101: PUSH
63102: LD_INT 1
63104: PUSH
63105: EMPTY
63106: LIST
63107: LIST
63108: PUSH
63109: LD_INT 1
63111: PUSH
63112: LD_INT 3
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: PUSH
63119: LD_INT 0
63121: PUSH
63122: LD_INT 3
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 1
63131: NEG
63132: PUSH
63133: LD_INT 2
63135: PUSH
63136: EMPTY
63137: LIST
63138: LIST
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63158: LD_ADDR_VAR 0 12
63162: PUSH
63163: LD_INT 0
63165: PUSH
63166: LD_INT 0
63168: PUSH
63169: EMPTY
63170: LIST
63171: LIST
63172: PUSH
63173: LD_INT 0
63175: PUSH
63176: LD_INT 1
63178: NEG
63179: PUSH
63180: EMPTY
63181: LIST
63182: LIST
63183: PUSH
63184: LD_INT 1
63186: PUSH
63187: LD_INT 0
63189: PUSH
63190: EMPTY
63191: LIST
63192: LIST
63193: PUSH
63194: LD_INT 1
63196: PUSH
63197: LD_INT 1
63199: PUSH
63200: EMPTY
63201: LIST
63202: LIST
63203: PUSH
63204: LD_INT 0
63206: PUSH
63207: LD_INT 1
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: PUSH
63214: LD_INT 1
63216: NEG
63217: PUSH
63218: LD_INT 0
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: PUSH
63225: LD_INT 1
63227: NEG
63228: PUSH
63229: LD_INT 1
63231: NEG
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PUSH
63237: LD_INT 1
63239: PUSH
63240: LD_INT 1
63242: NEG
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: LD_INT 2
63250: PUSH
63251: LD_INT 0
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: PUSH
63258: LD_INT 2
63260: PUSH
63261: LD_INT 1
63263: PUSH
63264: EMPTY
63265: LIST
63266: LIST
63267: PUSH
63268: LD_INT 1
63270: NEG
63271: PUSH
63272: LD_INT 1
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PUSH
63279: LD_INT 2
63281: NEG
63282: PUSH
63283: LD_INT 0
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: PUSH
63290: LD_INT 2
63292: NEG
63293: PUSH
63294: LD_INT 1
63296: NEG
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 2
63304: NEG
63305: PUSH
63306: LD_INT 1
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: PUSH
63313: LD_INT 3
63315: NEG
63316: PUSH
63317: LD_INT 0
63319: PUSH
63320: EMPTY
63321: LIST
63322: LIST
63323: PUSH
63324: LD_INT 3
63326: NEG
63327: PUSH
63328: LD_INT 1
63330: NEG
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PUSH
63336: EMPTY
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: LIST
63351: LIST
63352: LIST
63353: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63354: LD_ADDR_VAR 0 13
63358: PUSH
63359: LD_INT 0
63361: PUSH
63362: LD_INT 0
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 0
63371: PUSH
63372: LD_INT 1
63374: NEG
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PUSH
63380: LD_INT 1
63382: PUSH
63383: LD_INT 0
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: LD_INT 1
63392: PUSH
63393: LD_INT 1
63395: PUSH
63396: EMPTY
63397: LIST
63398: LIST
63399: PUSH
63400: LD_INT 0
63402: PUSH
63403: LD_INT 1
63405: PUSH
63406: EMPTY
63407: LIST
63408: LIST
63409: PUSH
63410: LD_INT 1
63412: NEG
63413: PUSH
63414: LD_INT 0
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 1
63423: NEG
63424: PUSH
63425: LD_INT 1
63427: NEG
63428: PUSH
63429: EMPTY
63430: LIST
63431: LIST
63432: PUSH
63433: LD_INT 1
63435: NEG
63436: PUSH
63437: LD_INT 2
63439: NEG
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PUSH
63445: LD_INT 2
63447: PUSH
63448: LD_INT 1
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PUSH
63455: LD_INT 2
63457: PUSH
63458: LD_INT 2
63460: PUSH
63461: EMPTY
63462: LIST
63463: LIST
63464: PUSH
63465: LD_INT 1
63467: PUSH
63468: LD_INT 2
63470: PUSH
63471: EMPTY
63472: LIST
63473: LIST
63474: PUSH
63475: LD_INT 2
63477: NEG
63478: PUSH
63479: LD_INT 1
63481: NEG
63482: PUSH
63483: EMPTY
63484: LIST
63485: LIST
63486: PUSH
63487: LD_INT 2
63489: NEG
63490: PUSH
63491: LD_INT 2
63493: NEG
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PUSH
63499: LD_INT 2
63501: NEG
63502: PUSH
63503: LD_INT 3
63505: NEG
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 3
63513: NEG
63514: PUSH
63515: LD_INT 2
63517: NEG
63518: PUSH
63519: EMPTY
63520: LIST
63521: LIST
63522: PUSH
63523: LD_INT 3
63525: NEG
63526: PUSH
63527: LD_INT 3
63529: NEG
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: LIST
63539: LIST
63540: LIST
63541: LIST
63542: LIST
63543: LIST
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: LIST
63552: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63553: LD_ADDR_VAR 0 14
63557: PUSH
63558: LD_INT 0
63560: PUSH
63561: LD_INT 0
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: PUSH
63568: LD_INT 0
63570: PUSH
63571: LD_INT 1
63573: NEG
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PUSH
63579: LD_INT 1
63581: PUSH
63582: LD_INT 0
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: PUSH
63589: LD_INT 1
63591: PUSH
63592: LD_INT 1
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: PUSH
63599: LD_INT 0
63601: PUSH
63602: LD_INT 1
63604: PUSH
63605: EMPTY
63606: LIST
63607: LIST
63608: PUSH
63609: LD_INT 1
63611: NEG
63612: PUSH
63613: LD_INT 0
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PUSH
63620: LD_INT 1
63622: NEG
63623: PUSH
63624: LD_INT 1
63626: NEG
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: LD_INT 1
63634: NEG
63635: PUSH
63636: LD_INT 2
63638: NEG
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: PUSH
63644: LD_INT 0
63646: PUSH
63647: LD_INT 2
63649: NEG
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 1
63657: PUSH
63658: LD_INT 1
63660: NEG
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: PUSH
63666: LD_INT 1
63668: PUSH
63669: LD_INT 2
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: PUSH
63676: LD_INT 0
63678: PUSH
63679: LD_INT 2
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: LD_INT 1
63688: NEG
63689: PUSH
63690: LD_INT 1
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 1
63699: NEG
63700: PUSH
63701: LD_INT 3
63703: NEG
63704: PUSH
63705: EMPTY
63706: LIST
63707: LIST
63708: PUSH
63709: LD_INT 0
63711: PUSH
63712: LD_INT 3
63714: NEG
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 1
63722: PUSH
63723: LD_INT 2
63725: NEG
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: LIST
63744: LIST
63745: LIST
63746: LIST
63747: LIST
63748: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63749: LD_ADDR_VAR 0 15
63753: PUSH
63754: LD_INT 0
63756: PUSH
63757: LD_INT 0
63759: PUSH
63760: EMPTY
63761: LIST
63762: LIST
63763: PUSH
63764: LD_INT 0
63766: PUSH
63767: LD_INT 1
63769: NEG
63770: PUSH
63771: EMPTY
63772: LIST
63773: LIST
63774: PUSH
63775: LD_INT 1
63777: PUSH
63778: LD_INT 0
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 1
63787: PUSH
63788: LD_INT 1
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PUSH
63795: LD_INT 0
63797: PUSH
63798: LD_INT 1
63800: PUSH
63801: EMPTY
63802: LIST
63803: LIST
63804: PUSH
63805: LD_INT 1
63807: NEG
63808: PUSH
63809: LD_INT 0
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: PUSH
63816: LD_INT 1
63818: NEG
63819: PUSH
63820: LD_INT 1
63822: NEG
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 1
63830: PUSH
63831: LD_INT 1
63833: NEG
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 2
63841: PUSH
63842: LD_INT 0
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: PUSH
63849: LD_INT 2
63851: PUSH
63852: LD_INT 1
63854: PUSH
63855: EMPTY
63856: LIST
63857: LIST
63858: PUSH
63859: LD_INT 1
63861: NEG
63862: PUSH
63863: LD_INT 1
63865: PUSH
63866: EMPTY
63867: LIST
63868: LIST
63869: PUSH
63870: LD_INT 2
63872: NEG
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PUSH
63881: LD_INT 2
63883: NEG
63884: PUSH
63885: LD_INT 1
63887: NEG
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: LD_INT 2
63895: PUSH
63896: LD_INT 1
63898: NEG
63899: PUSH
63900: EMPTY
63901: LIST
63902: LIST
63903: PUSH
63904: LD_INT 3
63906: PUSH
63907: LD_INT 0
63909: PUSH
63910: EMPTY
63911: LIST
63912: LIST
63913: PUSH
63914: LD_INT 3
63916: PUSH
63917: LD_INT 1
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63942: LD_ADDR_VAR 0 16
63946: PUSH
63947: LD_INT 0
63949: PUSH
63950: LD_INT 0
63952: PUSH
63953: EMPTY
63954: LIST
63955: LIST
63956: PUSH
63957: LD_INT 0
63959: PUSH
63960: LD_INT 1
63962: NEG
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: PUSH
63968: LD_INT 1
63970: PUSH
63971: LD_INT 0
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: PUSH
63978: LD_INT 1
63980: PUSH
63981: LD_INT 1
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: PUSH
63988: LD_INT 0
63990: PUSH
63991: LD_INT 1
63993: PUSH
63994: EMPTY
63995: LIST
63996: LIST
63997: PUSH
63998: LD_INT 1
64000: NEG
64001: PUSH
64002: LD_INT 0
64004: PUSH
64005: EMPTY
64006: LIST
64007: LIST
64008: PUSH
64009: LD_INT 1
64011: NEG
64012: PUSH
64013: LD_INT 1
64015: NEG
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: PUSH
64021: LD_INT 1
64023: NEG
64024: PUSH
64025: LD_INT 2
64027: NEG
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: LD_INT 2
64035: PUSH
64036: LD_INT 1
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 2
64045: PUSH
64046: LD_INT 2
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: LD_INT 1
64055: PUSH
64056: LD_INT 2
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PUSH
64063: LD_INT 2
64065: NEG
64066: PUSH
64067: LD_INT 1
64069: NEG
64070: PUSH
64071: EMPTY
64072: LIST
64073: LIST
64074: PUSH
64075: LD_INT 2
64077: NEG
64078: PUSH
64079: LD_INT 2
64081: NEG
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: LD_INT 3
64089: PUSH
64090: LD_INT 2
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: LD_INT 3
64099: PUSH
64100: LD_INT 3
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: LD_INT 2
64109: PUSH
64110: LD_INT 3
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64135: LD_ADDR_VAR 0 17
64139: PUSH
64140: LD_INT 0
64142: PUSH
64143: LD_INT 0
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PUSH
64150: LD_INT 0
64152: PUSH
64153: LD_INT 1
64155: NEG
64156: PUSH
64157: EMPTY
64158: LIST
64159: LIST
64160: PUSH
64161: LD_INT 1
64163: PUSH
64164: LD_INT 0
64166: PUSH
64167: EMPTY
64168: LIST
64169: LIST
64170: PUSH
64171: LD_INT 1
64173: PUSH
64174: LD_INT 1
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: PUSH
64181: LD_INT 0
64183: PUSH
64184: LD_INT 1
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: PUSH
64191: LD_INT 1
64193: NEG
64194: PUSH
64195: LD_INT 0
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PUSH
64202: LD_INT 1
64204: NEG
64205: PUSH
64206: LD_INT 1
64208: NEG
64209: PUSH
64210: EMPTY
64211: LIST
64212: LIST
64213: PUSH
64214: LD_INT 1
64216: NEG
64217: PUSH
64218: LD_INT 2
64220: NEG
64221: PUSH
64222: EMPTY
64223: LIST
64224: LIST
64225: PUSH
64226: LD_INT 0
64228: PUSH
64229: LD_INT 2
64231: NEG
64232: PUSH
64233: EMPTY
64234: LIST
64235: LIST
64236: PUSH
64237: LD_INT 1
64239: PUSH
64240: LD_INT 1
64242: NEG
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: PUSH
64248: LD_INT 2
64250: PUSH
64251: LD_INT 0
64253: PUSH
64254: EMPTY
64255: LIST
64256: LIST
64257: PUSH
64258: LD_INT 2
64260: PUSH
64261: LD_INT 1
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: PUSH
64268: LD_INT 2
64270: PUSH
64271: LD_INT 2
64273: PUSH
64274: EMPTY
64275: LIST
64276: LIST
64277: PUSH
64278: LD_INT 1
64280: PUSH
64281: LD_INT 2
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 0
64290: PUSH
64291: LD_INT 2
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PUSH
64298: LD_INT 1
64300: NEG
64301: PUSH
64302: LD_INT 1
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 2
64311: NEG
64312: PUSH
64313: LD_INT 0
64315: PUSH
64316: EMPTY
64317: LIST
64318: LIST
64319: PUSH
64320: LD_INT 2
64322: NEG
64323: PUSH
64324: LD_INT 1
64326: NEG
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 2
64334: NEG
64335: PUSH
64336: LD_INT 2
64338: NEG
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: LIST
64348: LIST
64349: LIST
64350: LIST
64351: LIST
64352: LIST
64353: LIST
64354: LIST
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: LIST
64360: LIST
64361: LIST
64362: LIST
64363: LIST
64364: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64365: LD_ADDR_VAR 0 18
64369: PUSH
64370: LD_INT 0
64372: PUSH
64373: LD_INT 0
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 0
64382: PUSH
64383: LD_INT 1
64385: NEG
64386: PUSH
64387: EMPTY
64388: LIST
64389: LIST
64390: PUSH
64391: LD_INT 1
64393: PUSH
64394: LD_INT 0
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: LD_INT 1
64403: PUSH
64404: LD_INT 1
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: LD_INT 0
64413: PUSH
64414: LD_INT 1
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 1
64423: NEG
64424: PUSH
64425: LD_INT 0
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 1
64434: NEG
64435: PUSH
64436: LD_INT 1
64438: NEG
64439: PUSH
64440: EMPTY
64441: LIST
64442: LIST
64443: PUSH
64444: LD_INT 1
64446: NEG
64447: PUSH
64448: LD_INT 2
64450: NEG
64451: PUSH
64452: EMPTY
64453: LIST
64454: LIST
64455: PUSH
64456: LD_INT 0
64458: PUSH
64459: LD_INT 2
64461: NEG
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: PUSH
64467: LD_INT 1
64469: PUSH
64470: LD_INT 1
64472: NEG
64473: PUSH
64474: EMPTY
64475: LIST
64476: LIST
64477: PUSH
64478: LD_INT 2
64480: PUSH
64481: LD_INT 0
64483: PUSH
64484: EMPTY
64485: LIST
64486: LIST
64487: PUSH
64488: LD_INT 2
64490: PUSH
64491: LD_INT 1
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: PUSH
64498: LD_INT 2
64500: PUSH
64501: LD_INT 2
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: PUSH
64508: LD_INT 1
64510: PUSH
64511: LD_INT 2
64513: PUSH
64514: EMPTY
64515: LIST
64516: LIST
64517: PUSH
64518: LD_INT 0
64520: PUSH
64521: LD_INT 2
64523: PUSH
64524: EMPTY
64525: LIST
64526: LIST
64527: PUSH
64528: LD_INT 1
64530: NEG
64531: PUSH
64532: LD_INT 1
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PUSH
64539: LD_INT 2
64541: NEG
64542: PUSH
64543: LD_INT 0
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 2
64552: NEG
64553: PUSH
64554: LD_INT 1
64556: NEG
64557: PUSH
64558: EMPTY
64559: LIST
64560: LIST
64561: PUSH
64562: LD_INT 2
64564: NEG
64565: PUSH
64566: LD_INT 2
64568: NEG
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: LIST
64581: LIST
64582: LIST
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: LIST
64592: LIST
64593: LIST
64594: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64595: LD_ADDR_VAR 0 19
64599: PUSH
64600: LD_INT 0
64602: PUSH
64603: LD_INT 0
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: PUSH
64610: LD_INT 0
64612: PUSH
64613: LD_INT 1
64615: NEG
64616: PUSH
64617: EMPTY
64618: LIST
64619: LIST
64620: PUSH
64621: LD_INT 1
64623: PUSH
64624: LD_INT 0
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: LD_INT 1
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 0
64643: PUSH
64644: LD_INT 1
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 1
64653: NEG
64654: PUSH
64655: LD_INT 0
64657: PUSH
64658: EMPTY
64659: LIST
64660: LIST
64661: PUSH
64662: LD_INT 1
64664: NEG
64665: PUSH
64666: LD_INT 1
64668: NEG
64669: PUSH
64670: EMPTY
64671: LIST
64672: LIST
64673: PUSH
64674: LD_INT 1
64676: NEG
64677: PUSH
64678: LD_INT 2
64680: NEG
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 0
64688: PUSH
64689: LD_INT 2
64691: NEG
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PUSH
64697: LD_INT 1
64699: PUSH
64700: LD_INT 1
64702: NEG
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PUSH
64708: LD_INT 2
64710: PUSH
64711: LD_INT 0
64713: PUSH
64714: EMPTY
64715: LIST
64716: LIST
64717: PUSH
64718: LD_INT 2
64720: PUSH
64721: LD_INT 1
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: PUSH
64728: LD_INT 2
64730: PUSH
64731: LD_INT 2
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 1
64740: PUSH
64741: LD_INT 2
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: LD_INT 0
64750: PUSH
64751: LD_INT 2
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: LD_INT 1
64760: NEG
64761: PUSH
64762: LD_INT 1
64764: PUSH
64765: EMPTY
64766: LIST
64767: LIST
64768: PUSH
64769: LD_INT 2
64771: NEG
64772: PUSH
64773: LD_INT 0
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PUSH
64780: LD_INT 2
64782: NEG
64783: PUSH
64784: LD_INT 1
64786: NEG
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: LD_INT 2
64794: NEG
64795: PUSH
64796: LD_INT 2
64798: NEG
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: LIST
64808: LIST
64809: LIST
64810: LIST
64811: LIST
64812: LIST
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64825: LD_ADDR_VAR 0 20
64829: PUSH
64830: LD_INT 0
64832: PUSH
64833: LD_INT 0
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PUSH
64840: LD_INT 0
64842: PUSH
64843: LD_INT 1
64845: NEG
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: PUSH
64851: LD_INT 1
64853: PUSH
64854: LD_INT 0
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 1
64863: PUSH
64864: LD_INT 1
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PUSH
64871: LD_INT 0
64873: PUSH
64874: LD_INT 1
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 1
64883: NEG
64884: PUSH
64885: LD_INT 0
64887: PUSH
64888: EMPTY
64889: LIST
64890: LIST
64891: PUSH
64892: LD_INT 1
64894: NEG
64895: PUSH
64896: LD_INT 1
64898: NEG
64899: PUSH
64900: EMPTY
64901: LIST
64902: LIST
64903: PUSH
64904: LD_INT 1
64906: NEG
64907: PUSH
64908: LD_INT 2
64910: NEG
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: LD_INT 0
64918: PUSH
64919: LD_INT 2
64921: NEG
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: LD_INT 1
64929: PUSH
64930: LD_INT 1
64932: NEG
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: PUSH
64938: LD_INT 2
64940: PUSH
64941: LD_INT 0
64943: PUSH
64944: EMPTY
64945: LIST
64946: LIST
64947: PUSH
64948: LD_INT 2
64950: PUSH
64951: LD_INT 1
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PUSH
64958: LD_INT 2
64960: PUSH
64961: LD_INT 2
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 1
64970: PUSH
64971: LD_INT 2
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 0
64980: PUSH
64981: LD_INT 2
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: LD_INT 1
64990: NEG
64991: PUSH
64992: LD_INT 1
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: LD_INT 2
65001: NEG
65002: PUSH
65003: LD_INT 0
65005: PUSH
65006: EMPTY
65007: LIST
65008: LIST
65009: PUSH
65010: LD_INT 2
65012: NEG
65013: PUSH
65014: LD_INT 1
65016: NEG
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: LD_INT 2
65024: NEG
65025: PUSH
65026: LD_INT 2
65028: NEG
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: LIST
65038: LIST
65039: LIST
65040: LIST
65041: LIST
65042: LIST
65043: LIST
65044: LIST
65045: LIST
65046: LIST
65047: LIST
65048: LIST
65049: LIST
65050: LIST
65051: LIST
65052: LIST
65053: LIST
65054: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65055: LD_ADDR_VAR 0 21
65059: PUSH
65060: LD_INT 0
65062: PUSH
65063: LD_INT 0
65065: PUSH
65066: EMPTY
65067: LIST
65068: LIST
65069: PUSH
65070: LD_INT 0
65072: PUSH
65073: LD_INT 1
65075: NEG
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PUSH
65081: LD_INT 1
65083: PUSH
65084: LD_INT 0
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: LD_INT 1
65093: PUSH
65094: LD_INT 1
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 0
65103: PUSH
65104: LD_INT 1
65106: PUSH
65107: EMPTY
65108: LIST
65109: LIST
65110: PUSH
65111: LD_INT 1
65113: NEG
65114: PUSH
65115: LD_INT 0
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 1
65124: NEG
65125: PUSH
65126: LD_INT 1
65128: NEG
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: LD_INT 1
65136: NEG
65137: PUSH
65138: LD_INT 2
65140: NEG
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 0
65148: PUSH
65149: LD_INT 2
65151: NEG
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: LD_INT 1
65159: PUSH
65160: LD_INT 1
65162: NEG
65163: PUSH
65164: EMPTY
65165: LIST
65166: LIST
65167: PUSH
65168: LD_INT 2
65170: PUSH
65171: LD_INT 0
65173: PUSH
65174: EMPTY
65175: LIST
65176: LIST
65177: PUSH
65178: LD_INT 2
65180: PUSH
65181: LD_INT 1
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: PUSH
65188: LD_INT 2
65190: PUSH
65191: LD_INT 2
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 1
65200: PUSH
65201: LD_INT 2
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: PUSH
65208: LD_INT 0
65210: PUSH
65211: LD_INT 2
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 1
65220: NEG
65221: PUSH
65222: LD_INT 1
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PUSH
65229: LD_INT 2
65231: NEG
65232: PUSH
65233: LD_INT 0
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: LD_INT 2
65242: NEG
65243: PUSH
65244: LD_INT 1
65246: NEG
65247: PUSH
65248: EMPTY
65249: LIST
65250: LIST
65251: PUSH
65252: LD_INT 2
65254: NEG
65255: PUSH
65256: LD_INT 2
65258: NEG
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: LIST
65268: LIST
65269: LIST
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65285: LD_ADDR_VAR 0 22
65289: PUSH
65290: LD_INT 0
65292: PUSH
65293: LD_INT 0
65295: PUSH
65296: EMPTY
65297: LIST
65298: LIST
65299: PUSH
65300: LD_INT 0
65302: PUSH
65303: LD_INT 1
65305: NEG
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 1
65313: PUSH
65314: LD_INT 0
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 1
65323: PUSH
65324: LD_INT 1
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 0
65333: PUSH
65334: LD_INT 1
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: LD_INT 1
65343: NEG
65344: PUSH
65345: LD_INT 0
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: LD_INT 1
65354: NEG
65355: PUSH
65356: LD_INT 1
65358: NEG
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: PUSH
65364: LD_INT 1
65366: NEG
65367: PUSH
65368: LD_INT 2
65370: NEG
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 0
65378: PUSH
65379: LD_INT 2
65381: NEG
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 1
65389: PUSH
65390: LD_INT 1
65392: NEG
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: LD_INT 2
65400: PUSH
65401: LD_INT 0
65403: PUSH
65404: EMPTY
65405: LIST
65406: LIST
65407: PUSH
65408: LD_INT 2
65410: PUSH
65411: LD_INT 1
65413: PUSH
65414: EMPTY
65415: LIST
65416: LIST
65417: PUSH
65418: LD_INT 2
65420: PUSH
65421: LD_INT 2
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 1
65430: PUSH
65431: LD_INT 2
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: LD_INT 0
65440: PUSH
65441: LD_INT 2
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: NEG
65451: PUSH
65452: LD_INT 1
65454: PUSH
65455: EMPTY
65456: LIST
65457: LIST
65458: PUSH
65459: LD_INT 2
65461: NEG
65462: PUSH
65463: LD_INT 0
65465: PUSH
65466: EMPTY
65467: LIST
65468: LIST
65469: PUSH
65470: LD_INT 2
65472: NEG
65473: PUSH
65474: LD_INT 1
65476: NEG
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: PUSH
65482: LD_INT 2
65484: NEG
65485: PUSH
65486: LD_INT 2
65488: NEG
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65515: LD_ADDR_VAR 0 23
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: LD_INT 0
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: PUSH
65530: LD_INT 0
65532: PUSH
65533: LD_INT 1
65535: NEG
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: PUSH
65541: LD_INT 1
65543: PUSH
65544: LD_INT 0
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: LD_INT 1
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 0
65563: PUSH
65564: LD_INT 1
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 1
65573: NEG
65574: PUSH
65575: LD_INT 0
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 1
65584: NEG
65585: PUSH
65586: LD_INT 1
65588: NEG
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 1
65596: NEG
65597: PUSH
65598: LD_INT 2
65600: NEG
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: LD_INT 0
65608: PUSH
65609: LD_INT 2
65611: NEG
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 1
65619: PUSH
65620: LD_INT 1
65622: NEG
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 2
65630: PUSH
65631: LD_INT 0
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PUSH
65638: LD_INT 2
65640: PUSH
65641: LD_INT 1
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 2
65650: PUSH
65651: LD_INT 2
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 1
65660: PUSH
65661: LD_INT 2
65663: PUSH
65664: EMPTY
65665: LIST
65666: LIST
65667: PUSH
65668: LD_INT 0
65670: PUSH
65671: LD_INT 2
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: PUSH
65678: LD_INT 1
65680: NEG
65681: PUSH
65682: LD_INT 1
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: PUSH
65689: LD_INT 2
65691: NEG
65692: PUSH
65693: LD_INT 0
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: LD_INT 2
65702: NEG
65703: PUSH
65704: LD_INT 1
65706: NEG
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: PUSH
65712: LD_INT 2
65714: NEG
65715: PUSH
65716: LD_INT 2
65718: NEG
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 2
65726: NEG
65727: PUSH
65728: LD_INT 3
65730: NEG
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 1
65738: NEG
65739: PUSH
65740: LD_INT 3
65742: NEG
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: LD_INT 1
65750: PUSH
65751: LD_INT 2
65753: NEG
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 2
65761: PUSH
65762: LD_INT 1
65764: NEG
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65795: LD_ADDR_VAR 0 24
65799: PUSH
65800: LD_INT 0
65802: PUSH
65803: LD_INT 0
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: LD_INT 0
65812: PUSH
65813: LD_INT 1
65815: NEG
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 1
65823: PUSH
65824: LD_INT 0
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 1
65833: PUSH
65834: LD_INT 1
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 0
65843: PUSH
65844: LD_INT 1
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: LD_INT 1
65853: NEG
65854: PUSH
65855: LD_INT 0
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: LD_INT 1
65864: NEG
65865: PUSH
65866: LD_INT 1
65868: NEG
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 1
65876: NEG
65877: PUSH
65878: LD_INT 2
65880: NEG
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 0
65888: PUSH
65889: LD_INT 2
65891: NEG
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 1
65899: PUSH
65900: LD_INT 1
65902: NEG
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 2
65910: PUSH
65911: LD_INT 0
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: PUSH
65918: LD_INT 2
65920: PUSH
65921: LD_INT 1
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: PUSH
65928: LD_INT 2
65930: PUSH
65931: LD_INT 2
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 1
65940: PUSH
65941: LD_INT 2
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: LD_INT 2
65953: PUSH
65954: EMPTY
65955: LIST
65956: LIST
65957: PUSH
65958: LD_INT 1
65960: NEG
65961: PUSH
65962: LD_INT 1
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PUSH
65969: LD_INT 2
65971: NEG
65972: PUSH
65973: LD_INT 0
65975: PUSH
65976: EMPTY
65977: LIST
65978: LIST
65979: PUSH
65980: LD_INT 2
65982: NEG
65983: PUSH
65984: LD_INT 1
65986: NEG
65987: PUSH
65988: EMPTY
65989: LIST
65990: LIST
65991: PUSH
65992: LD_INT 2
65994: NEG
65995: PUSH
65996: LD_INT 2
65998: NEG
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 1
66006: PUSH
66007: LD_INT 2
66009: NEG
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 2
66017: PUSH
66018: LD_INT 1
66020: NEG
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 3
66028: PUSH
66029: LD_INT 1
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: PUSH
66036: LD_INT 3
66038: PUSH
66039: LD_INT 2
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66071: LD_ADDR_VAR 0 25
66075: PUSH
66076: LD_INT 0
66078: PUSH
66079: LD_INT 0
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: LD_INT 1
66091: NEG
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 1
66099: PUSH
66100: LD_INT 0
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: LD_INT 1
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 0
66119: PUSH
66120: LD_INT 1
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: NEG
66130: PUSH
66131: LD_INT 0
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 1
66140: NEG
66141: PUSH
66142: LD_INT 1
66144: NEG
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: PUSH
66150: LD_INT 1
66152: NEG
66153: PUSH
66154: LD_INT 2
66156: NEG
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 0
66164: PUSH
66165: LD_INT 2
66167: NEG
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PUSH
66173: LD_INT 1
66175: PUSH
66176: LD_INT 1
66178: NEG
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 2
66186: PUSH
66187: LD_INT 0
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 2
66196: PUSH
66197: LD_INT 1
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 2
66206: PUSH
66207: LD_INT 2
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 1
66216: PUSH
66217: LD_INT 2
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 0
66226: PUSH
66227: LD_INT 2
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: LD_INT 1
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 2
66247: NEG
66248: PUSH
66249: LD_INT 0
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: LD_INT 2
66258: NEG
66259: PUSH
66260: LD_INT 1
66262: NEG
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: PUSH
66268: LD_INT 2
66270: NEG
66271: PUSH
66272: LD_INT 2
66274: NEG
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 3
66282: PUSH
66283: LD_INT 1
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 3
66292: PUSH
66293: LD_INT 2
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 2
66302: PUSH
66303: LD_INT 3
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 1
66312: PUSH
66313: LD_INT 3
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: EMPTY
66321: LIST
66322: LIST
66323: LIST
66324: LIST
66325: LIST
66326: LIST
66327: LIST
66328: LIST
66329: LIST
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: LIST
66338: LIST
66339: LIST
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66345: LD_ADDR_VAR 0 26
66349: PUSH
66350: LD_INT 0
66352: PUSH
66353: LD_INT 0
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: LD_INT 1
66365: NEG
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PUSH
66371: LD_INT 1
66373: PUSH
66374: LD_INT 0
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: LD_INT 1
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 1
66403: NEG
66404: PUSH
66405: LD_INT 0
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 1
66414: NEG
66415: PUSH
66416: LD_INT 1
66418: NEG
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 1
66426: NEG
66427: PUSH
66428: LD_INT 2
66430: NEG
66431: PUSH
66432: EMPTY
66433: LIST
66434: LIST
66435: PUSH
66436: LD_INT 0
66438: PUSH
66439: LD_INT 2
66441: NEG
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 1
66449: PUSH
66450: LD_INT 1
66452: NEG
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 2
66460: PUSH
66461: LD_INT 0
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 2
66470: PUSH
66471: LD_INT 1
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 2
66480: PUSH
66481: LD_INT 2
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: PUSH
66491: LD_INT 2
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: LD_INT 2
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: LD_INT 1
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 2
66521: NEG
66522: PUSH
66523: LD_INT 0
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: LD_INT 2
66532: NEG
66533: PUSH
66534: LD_INT 1
66536: NEG
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 2
66544: NEG
66545: PUSH
66546: LD_INT 2
66548: NEG
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 2
66556: PUSH
66557: LD_INT 3
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: PUSH
66564: LD_INT 1
66566: PUSH
66567: LD_INT 3
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: LD_INT 1
66576: NEG
66577: PUSH
66578: LD_INT 2
66580: PUSH
66581: EMPTY
66582: LIST
66583: LIST
66584: PUSH
66585: LD_INT 2
66587: NEG
66588: PUSH
66589: LD_INT 1
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66621: LD_ADDR_VAR 0 27
66625: PUSH
66626: LD_INT 0
66628: PUSH
66629: LD_INT 0
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: LD_INT 0
66638: PUSH
66639: LD_INT 1
66641: NEG
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: LD_INT 1
66649: PUSH
66650: LD_INT 0
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 1
66659: PUSH
66660: LD_INT 1
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: LD_INT 1
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 1
66679: NEG
66680: PUSH
66681: LD_INT 0
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 1
66690: NEG
66691: PUSH
66692: LD_INT 1
66694: NEG
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 1
66702: NEG
66703: PUSH
66704: LD_INT 2
66706: NEG
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 0
66714: PUSH
66715: LD_INT 2
66717: NEG
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 1
66725: PUSH
66726: LD_INT 1
66728: NEG
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 2
66736: PUSH
66737: LD_INT 0
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 2
66746: PUSH
66747: LD_INT 1
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: PUSH
66754: LD_INT 2
66756: PUSH
66757: LD_INT 2
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 1
66766: PUSH
66767: LD_INT 2
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 0
66776: PUSH
66777: LD_INT 2
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 1
66786: NEG
66787: PUSH
66788: LD_INT 1
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: NEG
66798: PUSH
66799: LD_INT 0
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 2
66808: NEG
66809: PUSH
66810: LD_INT 1
66812: NEG
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 2
66820: NEG
66821: PUSH
66822: LD_INT 2
66824: NEG
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 1
66832: NEG
66833: PUSH
66834: LD_INT 2
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 2
66843: NEG
66844: PUSH
66845: LD_INT 1
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 3
66854: NEG
66855: PUSH
66856: LD_INT 1
66858: NEG
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: PUSH
66864: LD_INT 3
66866: NEG
66867: PUSH
66868: LD_INT 2
66870: NEG
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66901: LD_ADDR_VAR 0 28
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: LD_INT 0
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: LD_INT 1
66921: NEG
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: LD_INT 0
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: LD_INT 1
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: PUSH
66947: LD_INT 0
66949: PUSH
66950: LD_INT 1
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: LD_INT 1
66959: NEG
66960: PUSH
66961: LD_INT 0
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 1
66970: NEG
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 1
66982: NEG
66983: PUSH
66984: LD_INT 2
66986: NEG
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 0
66994: PUSH
66995: LD_INT 2
66997: NEG
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 1
67005: PUSH
67006: LD_INT 1
67008: NEG
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 2
67016: PUSH
67017: LD_INT 0
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 2
67026: PUSH
67027: LD_INT 1
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 2
67036: PUSH
67037: LD_INT 2
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 1
67046: PUSH
67047: LD_INT 2
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 2
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: NEG
67067: PUSH
67068: LD_INT 1
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 2
67077: NEG
67078: PUSH
67079: LD_INT 0
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 2
67088: NEG
67089: PUSH
67090: LD_INT 1
67092: NEG
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 2
67100: NEG
67101: PUSH
67102: LD_INT 2
67104: NEG
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 2
67112: NEG
67113: PUSH
67114: LD_INT 3
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 1
67124: NEG
67125: PUSH
67126: LD_INT 3
67128: NEG
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 3
67136: NEG
67137: PUSH
67138: LD_INT 1
67140: NEG
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 3
67148: NEG
67149: PUSH
67150: LD_INT 2
67152: NEG
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: LIST
67162: LIST
67163: LIST
67164: LIST
67165: LIST
67166: LIST
67167: LIST
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: LIST
67179: LIST
67180: LIST
67181: LIST
67182: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67183: LD_ADDR_VAR 0 29
67187: PUSH
67188: LD_INT 0
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: LD_INT 1
67203: NEG
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 1
67211: PUSH
67212: LD_INT 0
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 1
67221: PUSH
67222: LD_INT 1
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 0
67231: PUSH
67232: LD_INT 1
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: PUSH
67239: LD_INT 1
67241: NEG
67242: PUSH
67243: LD_INT 0
67245: PUSH
67246: EMPTY
67247: LIST
67248: LIST
67249: PUSH
67250: LD_INT 1
67252: NEG
67253: PUSH
67254: LD_INT 1
67256: NEG
67257: PUSH
67258: EMPTY
67259: LIST
67260: LIST
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PUSH
67266: LD_INT 2
67268: NEG
67269: PUSH
67270: EMPTY
67271: LIST
67272: LIST
67273: PUSH
67274: LD_INT 0
67276: PUSH
67277: LD_INT 2
67279: NEG
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 1
67287: PUSH
67288: LD_INT 1
67290: NEG
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 2
67298: PUSH
67299: LD_INT 0
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 2
67308: PUSH
67309: LD_INT 1
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: PUSH
67319: LD_INT 2
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 0
67328: PUSH
67329: LD_INT 2
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 1
67338: NEG
67339: PUSH
67340: LD_INT 1
67342: PUSH
67343: EMPTY
67344: LIST
67345: LIST
67346: PUSH
67347: LD_INT 2
67349: NEG
67350: PUSH
67351: LD_INT 1
67353: NEG
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 2
67361: NEG
67362: PUSH
67363: LD_INT 2
67365: NEG
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 2
67373: NEG
67374: PUSH
67375: LD_INT 3
67377: NEG
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: LD_INT 2
67385: PUSH
67386: LD_INT 1
67388: NEG
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 3
67396: PUSH
67397: LD_INT 1
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: LD_INT 3
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 1
67416: NEG
67417: PUSH
67418: LD_INT 2
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 3
67427: NEG
67428: PUSH
67429: LD_INT 2
67431: NEG
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67462: LD_ADDR_VAR 0 30
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: LD_INT 0
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 0
67479: PUSH
67480: LD_INT 1
67482: NEG
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 1
67490: PUSH
67491: LD_INT 0
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 1
67500: PUSH
67501: LD_INT 1
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: LD_INT 0
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 1
67520: NEG
67521: PUSH
67522: LD_INT 0
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 1
67531: NEG
67532: PUSH
67533: LD_INT 1
67535: NEG
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 1
67543: NEG
67544: PUSH
67545: LD_INT 2
67547: NEG
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 0
67555: PUSH
67556: LD_INT 2
67558: NEG
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 1
67566: PUSH
67567: LD_INT 1
67569: NEG
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 2
67577: PUSH
67578: LD_INT 0
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 2
67587: PUSH
67588: LD_INT 1
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 2
67597: PUSH
67598: LD_INT 2
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: PUSH
67608: LD_INT 2
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: PUSH
67615: LD_INT 1
67617: NEG
67618: PUSH
67619: LD_INT 1
67621: PUSH
67622: EMPTY
67623: LIST
67624: LIST
67625: PUSH
67626: LD_INT 2
67628: NEG
67629: PUSH
67630: LD_INT 0
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: LD_INT 2
67639: NEG
67640: PUSH
67641: LD_INT 1
67643: NEG
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 1
67651: NEG
67652: PUSH
67653: LD_INT 3
67655: NEG
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 1
67663: PUSH
67664: LD_INT 2
67666: NEG
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 3
67674: PUSH
67675: LD_INT 2
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 2
67684: PUSH
67685: LD_INT 3
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 2
67694: NEG
67695: PUSH
67696: LD_INT 1
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 3
67705: NEG
67706: PUSH
67707: LD_INT 1
67709: NEG
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67740: LD_ADDR_VAR 0 31
67744: PUSH
67745: LD_INT 0
67747: PUSH
67748: LD_INT 0
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: PUSH
67755: LD_INT 0
67757: PUSH
67758: LD_INT 1
67760: NEG
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 1
67768: PUSH
67769: LD_INT 0
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 1
67778: PUSH
67779: LD_INT 1
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: LD_INT 0
67788: PUSH
67789: LD_INT 1
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 1
67798: NEG
67799: PUSH
67800: LD_INT 0
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: LD_INT 1
67813: NEG
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 1
67821: NEG
67822: PUSH
67823: LD_INT 2
67825: NEG
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: LD_INT 1
67833: PUSH
67834: LD_INT 1
67836: NEG
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 2
67844: PUSH
67845: LD_INT 0
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 2
67854: PUSH
67855: LD_INT 1
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: LD_INT 2
67864: PUSH
67865: LD_INT 2
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 1
67874: PUSH
67875: LD_INT 2
67877: PUSH
67878: EMPTY
67879: LIST
67880: LIST
67881: PUSH
67882: LD_INT 0
67884: PUSH
67885: LD_INT 2
67887: PUSH
67888: EMPTY
67889: LIST
67890: LIST
67891: PUSH
67892: LD_INT 1
67894: NEG
67895: PUSH
67896: LD_INT 1
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: LD_INT 2
67905: NEG
67906: PUSH
67907: LD_INT 1
67909: NEG
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 2
67917: NEG
67918: PUSH
67919: LD_INT 2
67921: NEG
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: LD_INT 2
67929: NEG
67930: PUSH
67931: LD_INT 3
67933: NEG
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 2
67941: PUSH
67942: LD_INT 1
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 3
67952: PUSH
67953: LD_INT 1
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: LD_INT 3
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 1
67972: NEG
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 3
67983: NEG
67984: PUSH
67985: LD_INT 2
67987: NEG
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68018: LD_ADDR_VAR 0 32
68022: PUSH
68023: LD_INT 0
68025: PUSH
68026: LD_INT 0
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 0
68035: PUSH
68036: LD_INT 1
68038: NEG
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: LD_INT 0
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 1
68056: PUSH
68057: LD_INT 1
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 0
68066: PUSH
68067: LD_INT 1
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 1
68087: NEG
68088: PUSH
68089: LD_INT 1
68091: NEG
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 1
68099: NEG
68100: PUSH
68101: LD_INT 2
68103: NEG
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 0
68111: PUSH
68112: LD_INT 2
68114: NEG
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 1
68122: PUSH
68123: LD_INT 1
68125: NEG
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 2
68133: PUSH
68134: LD_INT 1
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: LD_INT 2
68143: PUSH
68144: LD_INT 2
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 1
68153: PUSH
68154: LD_INT 2
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: LD_INT 0
68163: PUSH
68164: LD_INT 2
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 1
68173: NEG
68174: PUSH
68175: LD_INT 1
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: LD_INT 2
68184: NEG
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 2
68195: NEG
68196: PUSH
68197: LD_INT 1
68199: NEG
68200: PUSH
68201: EMPTY
68202: LIST
68203: LIST
68204: PUSH
68205: LD_INT 1
68207: NEG
68208: PUSH
68209: LD_INT 3
68211: NEG
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: LD_INT 1
68219: PUSH
68220: LD_INT 2
68222: NEG
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 3
68230: PUSH
68231: LD_INT 2
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 2
68240: PUSH
68241: LD_INT 3
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 2
68250: NEG
68251: PUSH
68252: LD_INT 1
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 3
68261: NEG
68262: PUSH
68263: LD_INT 1
68265: NEG
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68296: LD_ADDR_VAR 0 33
68300: PUSH
68301: LD_INT 0
68303: PUSH
68304: LD_INT 0
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 0
68313: PUSH
68314: LD_INT 1
68316: NEG
68317: PUSH
68318: EMPTY
68319: LIST
68320: LIST
68321: PUSH
68322: LD_INT 1
68324: PUSH
68325: LD_INT 0
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: PUSH
68332: LD_INT 1
68334: PUSH
68335: LD_INT 1
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: PUSH
68342: LD_INT 0
68344: PUSH
68345: LD_INT 1
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: LD_INT 1
68354: NEG
68355: PUSH
68356: LD_INT 0
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: LD_INT 1
68365: NEG
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 1
68377: NEG
68378: PUSH
68379: LD_INT 2
68381: NEG
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: PUSH
68387: LD_INT 1
68389: PUSH
68390: LD_INT 1
68392: NEG
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 2
68400: PUSH
68401: LD_INT 0
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 2
68410: PUSH
68411: LD_INT 1
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 1
68420: PUSH
68421: LD_INT 2
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 0
68430: PUSH
68431: LD_INT 2
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 1
68440: NEG
68441: PUSH
68442: LD_INT 1
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: LD_INT 2
68451: NEG
68452: PUSH
68453: LD_INT 0
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 2
68462: NEG
68463: PUSH
68464: LD_INT 1
68466: NEG
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 2
68474: NEG
68475: PUSH
68476: LD_INT 2
68478: NEG
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: LD_INT 2
68486: NEG
68487: PUSH
68488: LD_INT 3
68490: NEG
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 2
68498: PUSH
68499: LD_INT 1
68501: NEG
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 3
68509: PUSH
68510: LD_INT 1
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 1
68519: PUSH
68520: LD_INT 3
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 1
68529: NEG
68530: PUSH
68531: LD_INT 2
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 3
68540: NEG
68541: PUSH
68542: LD_INT 2
68544: NEG
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68575: LD_ADDR_VAR 0 34
68579: PUSH
68580: LD_INT 0
68582: PUSH
68583: LD_INT 0
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 0
68592: PUSH
68593: LD_INT 1
68595: NEG
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: LD_INT 1
68603: PUSH
68604: LD_INT 0
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 1
68613: PUSH
68614: LD_INT 1
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 0
68623: PUSH
68624: LD_INT 1
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 1
68633: NEG
68634: PUSH
68635: LD_INT 0
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 1
68644: NEG
68645: PUSH
68646: LD_INT 1
68648: NEG
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PUSH
68654: LD_INT 1
68656: NEG
68657: PUSH
68658: LD_INT 2
68660: NEG
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 0
68668: PUSH
68669: LD_INT 2
68671: NEG
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 1
68679: PUSH
68680: LD_INT 1
68682: NEG
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 2
68690: PUSH
68691: LD_INT 1
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 2
68700: PUSH
68701: LD_INT 2
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 1
68710: PUSH
68711: LD_INT 2
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 1
68720: NEG
68721: PUSH
68722: LD_INT 1
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 2
68731: NEG
68732: PUSH
68733: LD_INT 0
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 2
68742: NEG
68743: PUSH
68744: LD_INT 1
68746: NEG
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 2
68754: NEG
68755: PUSH
68756: LD_INT 2
68758: NEG
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 1
68766: NEG
68767: PUSH
68768: LD_INT 3
68770: NEG
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: PUSH
68776: LD_INT 1
68778: PUSH
68779: LD_INT 2
68781: NEG
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: LD_INT 3
68789: PUSH
68790: LD_INT 2
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 2
68799: PUSH
68800: LD_INT 3
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 2
68809: NEG
68810: PUSH
68811: LD_INT 1
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 3
68820: NEG
68821: PUSH
68822: LD_INT 1
68824: NEG
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68855: LD_ADDR_VAR 0 35
68859: PUSH
68860: LD_INT 0
68862: PUSH
68863: LD_INT 0
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 0
68872: PUSH
68873: LD_INT 1
68875: NEG
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 1
68883: PUSH
68884: LD_INT 0
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 1
68893: PUSH
68894: LD_INT 1
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 0
68903: PUSH
68904: LD_INT 1
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 1
68913: NEG
68914: PUSH
68915: LD_INT 0
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: NEG
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 2
68936: PUSH
68937: LD_INT 1
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 2
68946: NEG
68947: PUSH
68948: LD_INT 1
68950: NEG
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68967: LD_ADDR_VAR 0 36
68971: PUSH
68972: LD_INT 0
68974: PUSH
68975: LD_INT 0
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: LD_INT 0
68984: PUSH
68985: LD_INT 1
68987: NEG
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 1
68995: PUSH
68996: LD_INT 0
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 1
69005: PUSH
69006: LD_INT 1
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 0
69015: PUSH
69016: LD_INT 1
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 1
69025: NEG
69026: PUSH
69027: LD_INT 0
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 1
69036: NEG
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 1
69048: NEG
69049: PUSH
69050: LD_INT 2
69052: NEG
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 1
69060: PUSH
69061: LD_INT 2
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69079: LD_ADDR_VAR 0 37
69083: PUSH
69084: LD_INT 0
69086: PUSH
69087: LD_INT 0
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: PUSH
69094: LD_INT 0
69096: PUSH
69097: LD_INT 1
69099: NEG
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: LD_INT 1
69107: PUSH
69108: LD_INT 0
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 1
69117: PUSH
69118: LD_INT 1
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 0
69127: PUSH
69128: LD_INT 1
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: PUSH
69135: LD_INT 1
69137: NEG
69138: PUSH
69139: LD_INT 0
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 1
69148: NEG
69149: PUSH
69150: LD_INT 1
69152: NEG
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 1
69160: PUSH
69161: LD_INT 1
69163: NEG
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: NEG
69172: PUSH
69173: LD_INT 1
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69191: LD_ADDR_VAR 0 38
69195: PUSH
69196: LD_INT 0
69198: PUSH
69199: LD_INT 0
69201: PUSH
69202: EMPTY
69203: LIST
69204: LIST
69205: PUSH
69206: LD_INT 0
69208: PUSH
69209: LD_INT 1
69211: NEG
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 1
69219: PUSH
69220: LD_INT 0
69222: PUSH
69223: EMPTY
69224: LIST
69225: LIST
69226: PUSH
69227: LD_INT 1
69229: PUSH
69230: LD_INT 1
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 0
69239: PUSH
69240: LD_INT 1
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PUSH
69247: LD_INT 1
69249: NEG
69250: PUSH
69251: LD_INT 0
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 1
69260: NEG
69261: PUSH
69262: LD_INT 1
69264: NEG
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 2
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 2
69282: NEG
69283: PUSH
69284: LD_INT 1
69286: NEG
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69303: LD_ADDR_VAR 0 39
69307: PUSH
69308: LD_INT 0
69310: PUSH
69311: LD_INT 0
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 0
69320: PUSH
69321: LD_INT 1
69323: NEG
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 1
69331: PUSH
69332: LD_INT 0
69334: PUSH
69335: EMPTY
69336: LIST
69337: LIST
69338: PUSH
69339: LD_INT 1
69341: PUSH
69342: LD_INT 1
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 0
69351: PUSH
69352: LD_INT 1
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 1
69361: NEG
69362: PUSH
69363: LD_INT 0
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 1
69372: NEG
69373: PUSH
69374: LD_INT 1
69376: NEG
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 1
69384: NEG
69385: PUSH
69386: LD_INT 2
69388: NEG
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 1
69396: PUSH
69397: LD_INT 2
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69415: LD_ADDR_VAR 0 40
69419: PUSH
69420: LD_INT 0
69422: PUSH
69423: LD_INT 0
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: LD_INT 0
69432: PUSH
69433: LD_INT 1
69435: NEG
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 1
69443: PUSH
69444: LD_INT 0
69446: PUSH
69447: EMPTY
69448: LIST
69449: LIST
69450: PUSH
69451: LD_INT 1
69453: PUSH
69454: LD_INT 1
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 0
69463: PUSH
69464: LD_INT 1
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 1
69473: NEG
69474: PUSH
69475: LD_INT 0
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 1
69484: NEG
69485: PUSH
69486: LD_INT 1
69488: NEG
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 1
69496: PUSH
69497: LD_INT 1
69499: NEG
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 1
69507: NEG
69508: PUSH
69509: LD_INT 1
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69527: LD_ADDR_VAR 0 41
69531: PUSH
69532: LD_INT 0
69534: PUSH
69535: LD_INT 0
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 0
69544: PUSH
69545: LD_INT 1
69547: NEG
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 1
69555: PUSH
69556: LD_INT 0
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: LD_INT 1
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: LD_INT 0
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 1
69585: NEG
69586: PUSH
69587: LD_INT 0
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: PUSH
69594: LD_INT 1
69596: NEG
69597: PUSH
69598: LD_INT 1
69600: NEG
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: PUSH
69606: LD_INT 1
69608: NEG
69609: PUSH
69610: LD_INT 2
69612: NEG
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PUSH
69618: LD_INT 1
69620: PUSH
69621: LD_INT 1
69623: NEG
69624: PUSH
69625: EMPTY
69626: LIST
69627: LIST
69628: PUSH
69629: LD_INT 2
69631: PUSH
69632: LD_INT 0
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: PUSH
69639: LD_INT 2
69641: PUSH
69642: LD_INT 1
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 2
69651: PUSH
69652: LD_INT 2
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 1
69661: PUSH
69662: LD_INT 2
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 1
69671: NEG
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 2
69682: NEG
69683: PUSH
69684: LD_INT 0
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 2
69693: NEG
69694: PUSH
69695: LD_INT 1
69697: NEG
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 2
69705: NEG
69706: PUSH
69707: LD_INT 2
69709: NEG
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 2
69717: NEG
69718: PUSH
69719: LD_INT 3
69721: NEG
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: LD_INT 2
69729: PUSH
69730: LD_INT 1
69732: NEG
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 3
69740: PUSH
69741: LD_INT 0
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 3
69750: PUSH
69751: LD_INT 1
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 3
69760: PUSH
69761: LD_INT 2
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 3
69770: PUSH
69771: LD_INT 3
69773: PUSH
69774: EMPTY
69775: LIST
69776: LIST
69777: PUSH
69778: LD_INT 2
69780: PUSH
69781: LD_INT 3
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 2
69790: NEG
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 3
69801: NEG
69802: PUSH
69803: LD_INT 0
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 3
69812: NEG
69813: PUSH
69814: LD_INT 1
69816: NEG
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 3
69824: NEG
69825: PUSH
69826: LD_INT 2
69828: NEG
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 3
69836: NEG
69837: PUSH
69838: LD_INT 3
69840: NEG
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69877: LD_ADDR_VAR 0 42
69881: PUSH
69882: LD_INT 0
69884: PUSH
69885: LD_INT 0
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 0
69894: PUSH
69895: LD_INT 1
69897: NEG
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: LD_INT 0
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 1
69915: PUSH
69916: LD_INT 1
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 0
69925: PUSH
69926: LD_INT 1
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: LD_INT 0
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 1
69946: NEG
69947: PUSH
69948: LD_INT 1
69950: NEG
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: PUSH
69956: LD_INT 1
69958: NEG
69959: PUSH
69960: LD_INT 2
69962: NEG
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PUSH
69968: LD_INT 0
69970: PUSH
69971: LD_INT 2
69973: NEG
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 1
69981: PUSH
69982: LD_INT 1
69984: NEG
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 2
69992: PUSH
69993: LD_INT 1
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 2
70002: PUSH
70003: LD_INT 2
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: LD_INT 2
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 0
70022: PUSH
70023: LD_INT 2
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 1
70032: NEG
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: LD_INT 2
70043: NEG
70044: PUSH
70045: LD_INT 1
70047: NEG
70048: PUSH
70049: EMPTY
70050: LIST
70051: LIST
70052: PUSH
70053: LD_INT 2
70055: NEG
70056: PUSH
70057: LD_INT 2
70059: NEG
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 2
70067: NEG
70068: PUSH
70069: LD_INT 3
70071: NEG
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 1
70079: NEG
70080: PUSH
70081: LD_INT 3
70083: NEG
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 0
70091: PUSH
70092: LD_INT 3
70094: NEG
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: LD_INT 1
70102: PUSH
70103: LD_INT 2
70105: NEG
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 3
70113: PUSH
70114: LD_INT 2
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 3
70123: PUSH
70124: LD_INT 3
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 2
70133: PUSH
70134: LD_INT 3
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 1
70143: PUSH
70144: LD_INT 3
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 0
70153: PUSH
70154: LD_INT 3
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: PUSH
70161: LD_INT 1
70163: NEG
70164: PUSH
70165: LD_INT 2
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PUSH
70172: LD_INT 3
70174: NEG
70175: PUSH
70176: LD_INT 2
70178: NEG
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 3
70186: NEG
70187: PUSH
70188: LD_INT 3
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70227: LD_ADDR_VAR 0 43
70231: PUSH
70232: LD_INT 0
70234: PUSH
70235: LD_INT 0
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: LD_INT 1
70247: NEG
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: LD_INT 0
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PUSH
70263: LD_INT 1
70265: PUSH
70266: LD_INT 1
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: PUSH
70273: LD_INT 0
70275: PUSH
70276: LD_INT 1
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 1
70285: NEG
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 1
70296: NEG
70297: PUSH
70298: LD_INT 1
70300: NEG
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 1
70308: NEG
70309: PUSH
70310: LD_INT 2
70312: NEG
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 2
70323: NEG
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: LD_INT 1
70334: NEG
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PUSH
70340: LD_INT 2
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 2
70352: PUSH
70353: LD_INT 1
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: LD_INT 2
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 0
70372: PUSH
70373: LD_INT 2
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: NEG
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: PUSH
70391: LD_INT 2
70393: NEG
70394: PUSH
70395: LD_INT 0
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 2
70404: NEG
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 1
70416: NEG
70417: PUSH
70418: LD_INT 3
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: LD_INT 3
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 1
70439: PUSH
70440: LD_INT 2
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 2
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 3
70461: PUSH
70462: LD_INT 0
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 3
70471: PUSH
70472: LD_INT 1
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: PUSH
70479: LD_INT 1
70481: PUSH
70482: LD_INT 3
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 0
70491: PUSH
70492: LD_INT 3
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 1
70501: NEG
70502: PUSH
70503: LD_INT 2
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 2
70512: NEG
70513: PUSH
70514: LD_INT 1
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 3
70523: NEG
70524: PUSH
70525: LD_INT 0
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PUSH
70532: LD_INT 3
70534: NEG
70535: PUSH
70536: LD_INT 1
70538: NEG
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70575: LD_ADDR_VAR 0 44
70579: PUSH
70580: LD_INT 0
70582: PUSH
70583: LD_INT 0
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 0
70592: PUSH
70593: LD_INT 1
70595: NEG
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 1
70603: PUSH
70604: LD_INT 0
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 1
70613: PUSH
70614: LD_INT 1
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 0
70623: PUSH
70624: LD_INT 1
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 1
70633: NEG
70634: PUSH
70635: LD_INT 0
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 1
70644: NEG
70645: PUSH
70646: LD_INT 1
70648: NEG
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 1
70656: NEG
70657: PUSH
70658: LD_INT 2
70660: NEG
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 1
70668: PUSH
70669: LD_INT 1
70671: NEG
70672: PUSH
70673: EMPTY
70674: LIST
70675: LIST
70676: PUSH
70677: LD_INT 2
70679: PUSH
70680: LD_INT 0
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 2
70689: PUSH
70690: LD_INT 1
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 2
70699: PUSH
70700: LD_INT 2
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: PUSH
70707: LD_INT 1
70709: PUSH
70710: LD_INT 2
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 1
70719: NEG
70720: PUSH
70721: LD_INT 1
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 2
70730: NEG
70731: PUSH
70732: LD_INT 0
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 2
70741: NEG
70742: PUSH
70743: LD_INT 1
70745: NEG
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 2
70753: NEG
70754: PUSH
70755: LD_INT 2
70757: NEG
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: LD_INT 2
70765: NEG
70766: PUSH
70767: LD_INT 3
70769: NEG
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 2
70777: PUSH
70778: LD_INT 1
70780: NEG
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 3
70788: PUSH
70789: LD_INT 0
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 3
70798: PUSH
70799: LD_INT 1
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 3
70808: PUSH
70809: LD_INT 2
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 3
70818: PUSH
70819: LD_INT 3
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 2
70828: PUSH
70829: LD_INT 3
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 2
70838: NEG
70839: PUSH
70840: LD_INT 1
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 3
70849: NEG
70850: PUSH
70851: LD_INT 0
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 3
70860: NEG
70861: PUSH
70862: LD_INT 1
70864: NEG
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 3
70872: NEG
70873: PUSH
70874: LD_INT 2
70876: NEG
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 3
70884: NEG
70885: PUSH
70886: LD_INT 3
70888: NEG
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70925: LD_ADDR_VAR 0 45
70929: PUSH
70930: LD_INT 0
70932: PUSH
70933: LD_INT 0
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 0
70942: PUSH
70943: LD_INT 1
70945: NEG
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: PUSH
70951: LD_INT 1
70953: PUSH
70954: LD_INT 0
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: PUSH
70961: LD_INT 1
70963: PUSH
70964: LD_INT 1
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 0
70973: PUSH
70974: LD_INT 1
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 1
70983: NEG
70984: PUSH
70985: LD_INT 0
70987: PUSH
70988: EMPTY
70989: LIST
70990: LIST
70991: PUSH
70992: LD_INT 1
70994: NEG
70995: PUSH
70996: LD_INT 1
70998: NEG
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 1
71006: NEG
71007: PUSH
71008: LD_INT 2
71010: NEG
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: LD_INT 0
71018: PUSH
71019: LD_INT 2
71021: NEG
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 1
71029: PUSH
71030: LD_INT 1
71032: NEG
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 2
71040: PUSH
71041: LD_INT 1
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 2
71050: PUSH
71051: LD_INT 2
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: PUSH
71058: LD_INT 1
71060: PUSH
71061: LD_INT 2
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: LD_INT 2
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PUSH
71078: LD_INT 1
71080: NEG
71081: PUSH
71082: LD_INT 1
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 2
71091: NEG
71092: PUSH
71093: LD_INT 1
71095: NEG
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 2
71103: NEG
71104: PUSH
71105: LD_INT 2
71107: NEG
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 2
71115: NEG
71116: PUSH
71117: LD_INT 3
71119: NEG
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: LD_INT 1
71127: NEG
71128: PUSH
71129: LD_INT 3
71131: NEG
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 0
71139: PUSH
71140: LD_INT 3
71142: NEG
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 1
71150: PUSH
71151: LD_INT 2
71153: NEG
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 3
71161: PUSH
71162: LD_INT 2
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 3
71171: PUSH
71172: LD_INT 3
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 2
71181: PUSH
71182: LD_INT 3
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: LD_INT 3
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 0
71201: PUSH
71202: LD_INT 3
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 1
71211: NEG
71212: PUSH
71213: LD_INT 2
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 3
71222: NEG
71223: PUSH
71224: LD_INT 2
71226: NEG
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 3
71234: NEG
71235: PUSH
71236: LD_INT 3
71238: NEG
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71275: LD_ADDR_VAR 0 46
71279: PUSH
71280: LD_INT 0
71282: PUSH
71283: LD_INT 0
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: LD_INT 1
71295: NEG
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: LD_INT 0
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 1
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: LD_INT 1
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: NEG
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 1
71344: NEG
71345: PUSH
71346: LD_INT 1
71348: NEG
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 1
71356: NEG
71357: PUSH
71358: LD_INT 2
71360: NEG
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: LD_INT 2
71371: NEG
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 1
71379: PUSH
71380: LD_INT 1
71382: NEG
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: LD_INT 2
71390: PUSH
71391: LD_INT 0
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 2
71400: PUSH
71401: LD_INT 1
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 1
71410: PUSH
71411: LD_INT 2
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 0
71420: PUSH
71421: LD_INT 2
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 1
71430: NEG
71431: PUSH
71432: LD_INT 1
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: PUSH
71439: LD_INT 2
71441: NEG
71442: PUSH
71443: LD_INT 0
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 2
71452: NEG
71453: PUSH
71454: LD_INT 1
71456: NEG
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 1
71464: NEG
71465: PUSH
71466: LD_INT 3
71468: NEG
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 0
71476: PUSH
71477: LD_INT 3
71479: NEG
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 1
71487: PUSH
71488: LD_INT 2
71490: NEG
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 2
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 3
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 3
71519: PUSH
71520: LD_INT 1
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 1
71529: PUSH
71530: LD_INT 3
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 0
71539: PUSH
71540: LD_INT 3
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 1
71549: NEG
71550: PUSH
71551: LD_INT 2
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 2
71560: NEG
71561: PUSH
71562: LD_INT 1
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 3
71571: NEG
71572: PUSH
71573: LD_INT 0
71575: PUSH
71576: EMPTY
71577: LIST
71578: LIST
71579: PUSH
71580: LD_INT 3
71582: NEG
71583: PUSH
71584: LD_INT 1
71586: NEG
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71623: LD_ADDR_VAR 0 47
71627: PUSH
71628: LD_INT 0
71630: PUSH
71631: LD_INT 0
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 0
71640: PUSH
71641: LD_INT 1
71643: NEG
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 1
71651: PUSH
71652: LD_INT 0
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 1
71661: PUSH
71662: LD_INT 1
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 0
71671: PUSH
71672: LD_INT 1
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 1
71681: NEG
71682: PUSH
71683: LD_INT 0
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PUSH
71690: LD_INT 1
71692: NEG
71693: PUSH
71694: LD_INT 1
71696: NEG
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: LD_INT 1
71704: NEG
71705: PUSH
71706: LD_INT 2
71708: NEG
71709: PUSH
71710: EMPTY
71711: LIST
71712: LIST
71713: PUSH
71714: LD_INT 0
71716: PUSH
71717: LD_INT 2
71719: NEG
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: LD_INT 1
71727: PUSH
71728: LD_INT 1
71730: NEG
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 2
71738: NEG
71739: PUSH
71740: LD_INT 1
71742: NEG
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 2
71750: NEG
71751: PUSH
71752: LD_INT 2
71754: NEG
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71774: LD_ADDR_VAR 0 48
71778: PUSH
71779: LD_INT 0
71781: PUSH
71782: LD_INT 0
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 0
71791: PUSH
71792: LD_INT 1
71794: NEG
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 1
71802: PUSH
71803: LD_INT 0
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 1
71812: PUSH
71813: LD_INT 1
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PUSH
71820: LD_INT 0
71822: PUSH
71823: LD_INT 1
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: PUSH
71830: LD_INT 1
71832: NEG
71833: PUSH
71834: LD_INT 0
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 1
71843: NEG
71844: PUSH
71845: LD_INT 1
71847: NEG
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 1
71855: NEG
71856: PUSH
71857: LD_INT 2
71859: NEG
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 0
71867: PUSH
71868: LD_INT 2
71870: NEG
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 1
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 2
71889: PUSH
71890: LD_INT 0
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: PUSH
71897: LD_INT 2
71899: PUSH
71900: LD_INT 1
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: LIST
71911: LIST
71912: LIST
71913: LIST
71914: LIST
71915: LIST
71916: LIST
71917: LIST
71918: LIST
71919: LIST
71920: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71921: LD_ADDR_VAR 0 49
71925: PUSH
71926: LD_INT 0
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: PUSH
71936: LD_INT 0
71938: PUSH
71939: LD_INT 1
71941: NEG
71942: PUSH
71943: EMPTY
71944: LIST
71945: LIST
71946: PUSH
71947: LD_INT 1
71949: PUSH
71950: LD_INT 0
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 1
71959: PUSH
71960: LD_INT 1
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 0
71969: PUSH
71970: LD_INT 1
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 1
71979: NEG
71980: PUSH
71981: LD_INT 0
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: NEG
71991: PUSH
71992: LD_INT 1
71994: NEG
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 1
72002: PUSH
72003: LD_INT 1
72005: NEG
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 2
72013: PUSH
72014: LD_INT 0
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 2
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 2
72033: PUSH
72034: LD_INT 2
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 1
72043: PUSH
72044: LD_INT 2
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72065: LD_ADDR_VAR 0 50
72069: PUSH
72070: LD_INT 0
72072: PUSH
72073: LD_INT 0
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 0
72082: PUSH
72083: LD_INT 1
72085: NEG
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 1
72093: PUSH
72094: LD_INT 0
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 1
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 1
72123: NEG
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 1
72134: NEG
72135: PUSH
72136: LD_INT 1
72138: NEG
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PUSH
72144: LD_INT 2
72146: PUSH
72147: LD_INT 1
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 2
72156: PUSH
72157: LD_INT 2
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 1
72166: PUSH
72167: LD_INT 2
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 0
72176: PUSH
72177: LD_INT 2
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 1
72186: NEG
72187: PUSH
72188: LD_INT 1
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: LIST
72199: LIST
72200: LIST
72201: LIST
72202: LIST
72203: LIST
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72209: LD_ADDR_VAR 0 51
72213: PUSH
72214: LD_INT 0
72216: PUSH
72217: LD_INT 0
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 0
72226: PUSH
72227: LD_INT 1
72229: NEG
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 1
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 1
72247: PUSH
72248: LD_INT 1
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: LD_INT 1
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 1
72267: NEG
72268: PUSH
72269: LD_INT 0
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 1
72278: NEG
72279: PUSH
72280: LD_INT 1
72282: NEG
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: PUSH
72288: LD_INT 1
72290: PUSH
72291: LD_INT 2
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 0
72300: PUSH
72301: LD_INT 2
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PUSH
72308: LD_INT 1
72310: NEG
72311: PUSH
72312: LD_INT 1
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 2
72321: NEG
72322: PUSH
72323: LD_INT 0
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: LD_INT 2
72332: NEG
72333: PUSH
72334: LD_INT 1
72336: NEG
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: LIST
72348: LIST
72349: LIST
72350: LIST
72351: LIST
72352: LIST
72353: LIST
72354: LIST
72355: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72356: LD_ADDR_VAR 0 52
72360: PUSH
72361: LD_INT 0
72363: PUSH
72364: LD_INT 0
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 0
72373: PUSH
72374: LD_INT 1
72376: NEG
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: PUSH
72382: LD_INT 1
72384: PUSH
72385: LD_INT 0
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PUSH
72392: LD_INT 1
72394: PUSH
72395: LD_INT 1
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 0
72404: PUSH
72405: LD_INT 1
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: NEG
72415: PUSH
72416: LD_INT 0
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: LD_INT 1
72425: NEG
72426: PUSH
72427: LD_INT 1
72429: NEG
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 1
72437: NEG
72438: PUSH
72439: LD_INT 2
72441: NEG
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: PUSH
72447: LD_INT 1
72449: NEG
72450: PUSH
72451: LD_INT 1
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: LD_INT 2
72460: NEG
72461: PUSH
72462: LD_INT 0
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: LD_INT 2
72471: NEG
72472: PUSH
72473: LD_INT 1
72475: NEG
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PUSH
72481: LD_INT 2
72483: NEG
72484: PUSH
72485: LD_INT 2
72487: NEG
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72507: LD_ADDR_VAR 0 53
72511: PUSH
72512: LD_INT 0
72514: PUSH
72515: LD_INT 0
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 0
72524: PUSH
72525: LD_INT 1
72527: NEG
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 1
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: LD_INT 1
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: LD_INT 1
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: NEG
72566: PUSH
72567: LD_INT 0
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 1
72576: NEG
72577: PUSH
72578: LD_INT 1
72580: NEG
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PUSH
72586: LD_INT 1
72588: NEG
72589: PUSH
72590: LD_INT 2
72592: NEG
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: LD_INT 0
72600: PUSH
72601: LD_INT 2
72603: NEG
72604: PUSH
72605: EMPTY
72606: LIST
72607: LIST
72608: PUSH
72609: LD_INT 1
72611: PUSH
72612: LD_INT 1
72614: NEG
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 2
72622: PUSH
72623: LD_INT 0
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: PUSH
72630: LD_INT 2
72632: PUSH
72633: LD_INT 1
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 2
72642: PUSH
72643: LD_INT 2
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 1
72652: PUSH
72653: LD_INT 2
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: LD_INT 0
72662: PUSH
72663: LD_INT 2
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: PUSH
72670: LD_INT 1
72672: NEG
72673: PUSH
72674: LD_INT 1
72676: PUSH
72677: EMPTY
72678: LIST
72679: LIST
72680: PUSH
72681: LD_INT 2
72683: NEG
72684: PUSH
72685: LD_INT 0
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 2
72694: NEG
72695: PUSH
72696: LD_INT 1
72698: NEG
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 2
72706: NEG
72707: PUSH
72708: LD_INT 2
72710: NEG
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: LIST
72720: LIST
72721: LIST
72722: LIST
72723: LIST
72724: LIST
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72737: LD_ADDR_VAR 0 54
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: LD_INT 0
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 0
72754: PUSH
72755: LD_INT 1
72757: NEG
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 1
72765: PUSH
72766: LD_INT 0
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: LD_INT 1
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 0
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 1
72795: NEG
72796: PUSH
72797: LD_INT 0
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 1
72806: NEG
72807: PUSH
72808: LD_INT 1
72810: NEG
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: LD_INT 1
72818: NEG
72819: PUSH
72820: LD_INT 2
72822: NEG
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PUSH
72828: LD_INT 0
72830: PUSH
72831: LD_INT 2
72833: NEG
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 1
72841: PUSH
72842: LD_INT 1
72844: NEG
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 2
72852: PUSH
72853: LD_INT 0
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 2
72862: PUSH
72863: LD_INT 1
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 2
72872: PUSH
72873: LD_INT 2
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 1
72882: PUSH
72883: LD_INT 2
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 0
72892: PUSH
72893: LD_INT 2
72895: PUSH
72896: EMPTY
72897: LIST
72898: LIST
72899: PUSH
72900: LD_INT 1
72902: NEG
72903: PUSH
72904: LD_INT 1
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: LD_INT 2
72913: NEG
72914: PUSH
72915: LD_INT 0
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: PUSH
72922: LD_INT 2
72924: NEG
72925: PUSH
72926: LD_INT 1
72928: NEG
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 2
72936: NEG
72937: PUSH
72938: LD_INT 2
72940: NEG
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: LIST
72950: LIST
72951: LIST
72952: LIST
72953: LIST
72954: LIST
72955: LIST
72956: LIST
72957: LIST
72958: LIST
72959: LIST
72960: LIST
72961: LIST
72962: LIST
72963: LIST
72964: LIST
72965: LIST
72966: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72967: LD_ADDR_VAR 0 55
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: LD_INT 0
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 0
72984: PUSH
72985: LD_INT 1
72987: NEG
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 1
72995: PUSH
72996: LD_INT 0
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 1
73005: PUSH
73006: LD_INT 1
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 0
73015: PUSH
73016: LD_INT 1
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 1
73025: NEG
73026: PUSH
73027: LD_INT 0
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 1
73036: NEG
73037: PUSH
73038: LD_INT 1
73040: NEG
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 1
73048: NEG
73049: PUSH
73050: LD_INT 2
73052: NEG
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 0
73060: PUSH
73061: LD_INT 2
73063: NEG
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 1
73071: PUSH
73072: LD_INT 1
73074: NEG
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 2
73082: PUSH
73083: LD_INT 0
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 2
73092: PUSH
73093: LD_INT 1
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: LD_INT 2
73102: PUSH
73103: LD_INT 2
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 1
73112: PUSH
73113: LD_INT 2
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 0
73122: PUSH
73123: LD_INT 2
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 1
73132: NEG
73133: PUSH
73134: LD_INT 1
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 2
73143: NEG
73144: PUSH
73145: LD_INT 0
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 2
73154: NEG
73155: PUSH
73156: LD_INT 1
73158: NEG
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 2
73166: NEG
73167: PUSH
73168: LD_INT 2
73170: NEG
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: LIST
73180: LIST
73181: LIST
73182: LIST
73183: LIST
73184: LIST
73185: LIST
73186: LIST
73187: LIST
73188: LIST
73189: LIST
73190: LIST
73191: LIST
73192: LIST
73193: LIST
73194: LIST
73195: LIST
73196: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73197: LD_ADDR_VAR 0 56
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: LD_INT 0
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 0
73214: PUSH
73215: LD_INT 1
73217: NEG
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 1
73225: PUSH
73226: LD_INT 0
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 1
73235: PUSH
73236: LD_INT 1
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 0
73245: PUSH
73246: LD_INT 1
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: LD_INT 0
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 1
73266: NEG
73267: PUSH
73268: LD_INT 1
73270: NEG
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: LD_INT 1
73278: NEG
73279: PUSH
73280: LD_INT 2
73282: NEG
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 0
73290: PUSH
73291: LD_INT 2
73293: NEG
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 1
73301: PUSH
73302: LD_INT 1
73304: NEG
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 2
73312: PUSH
73313: LD_INT 0
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 2
73322: PUSH
73323: LD_INT 1
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 2
73332: PUSH
73333: LD_INT 2
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 1
73342: PUSH
73343: LD_INT 2
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 0
73352: PUSH
73353: LD_INT 2
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: NEG
73363: PUSH
73364: LD_INT 1
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: PUSH
73371: LD_INT 2
73373: NEG
73374: PUSH
73375: LD_INT 0
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: LD_INT 2
73384: NEG
73385: PUSH
73386: LD_INT 1
73388: NEG
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PUSH
73394: LD_INT 2
73396: NEG
73397: PUSH
73398: LD_INT 2
73400: NEG
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: LIST
73410: LIST
73411: LIST
73412: LIST
73413: LIST
73414: LIST
73415: LIST
73416: LIST
73417: LIST
73418: LIST
73419: LIST
73420: LIST
73421: LIST
73422: LIST
73423: LIST
73424: LIST
73425: LIST
73426: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73427: LD_ADDR_VAR 0 57
73431: PUSH
73432: LD_INT 0
73434: PUSH
73435: LD_INT 0
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: PUSH
73442: LD_INT 0
73444: PUSH
73445: LD_INT 1
73447: NEG
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 1
73455: PUSH
73456: LD_INT 0
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: PUSH
73466: LD_INT 1
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 0
73475: PUSH
73476: LD_INT 1
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 1
73485: NEG
73486: PUSH
73487: LD_INT 0
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: LD_INT 1
73496: NEG
73497: PUSH
73498: LD_INT 1
73500: NEG
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 1
73508: NEG
73509: PUSH
73510: LD_INT 2
73512: NEG
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 0
73520: PUSH
73521: LD_INT 2
73523: NEG
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: LD_INT 1
73531: PUSH
73532: LD_INT 1
73534: NEG
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PUSH
73540: LD_INT 2
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: PUSH
73550: LD_INT 2
73552: PUSH
73553: LD_INT 1
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: PUSH
73560: LD_INT 2
73562: PUSH
73563: LD_INT 2
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 1
73572: PUSH
73573: LD_INT 2
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: LD_INT 2
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: LD_INT 1
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 2
73603: NEG
73604: PUSH
73605: LD_INT 0
73607: PUSH
73608: EMPTY
73609: LIST
73610: LIST
73611: PUSH
73612: LD_INT 2
73614: NEG
73615: PUSH
73616: LD_INT 1
73618: NEG
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: PUSH
73624: LD_INT 2
73626: NEG
73627: PUSH
73628: LD_INT 2
73630: NEG
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: LIST
73643: LIST
73644: LIST
73645: LIST
73646: LIST
73647: LIST
73648: LIST
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: LIST
73654: LIST
73655: LIST
73656: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73657: LD_ADDR_VAR 0 58
73661: PUSH
73662: LD_INT 0
73664: PUSH
73665: LD_INT 0
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: LD_INT 1
73677: NEG
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: PUSH
73683: LD_INT 1
73685: PUSH
73686: LD_INT 0
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: LD_INT 1
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 0
73705: PUSH
73706: LD_INT 1
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 1
73715: NEG
73716: PUSH
73717: LD_INT 0
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 1
73726: NEG
73727: PUSH
73728: LD_INT 1
73730: NEG
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 1
73738: NEG
73739: PUSH
73740: LD_INT 2
73742: NEG
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: LD_INT 0
73750: PUSH
73751: LD_INT 2
73753: NEG
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 1
73761: PUSH
73762: LD_INT 1
73764: NEG
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 2
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 2
73782: PUSH
73783: LD_INT 1
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 2
73792: PUSH
73793: LD_INT 2
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 1
73802: PUSH
73803: LD_INT 2
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: PUSH
73810: LD_INT 0
73812: PUSH
73813: LD_INT 2
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 1
73822: NEG
73823: PUSH
73824: LD_INT 1
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: PUSH
73831: LD_INT 2
73833: NEG
73834: PUSH
73835: LD_INT 0
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: LD_INT 2
73844: NEG
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 2
73856: NEG
73857: PUSH
73858: LD_INT 2
73860: NEG
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: LIST
73880: LIST
73881: LIST
73882: LIST
73883: LIST
73884: LIST
73885: LIST
73886: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73887: LD_ADDR_VAR 0 59
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: LD_INT 0
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 0
73904: PUSH
73905: LD_INT 1
73907: NEG
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 1
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 1
73925: PUSH
73926: LD_INT 1
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 0
73935: PUSH
73936: LD_INT 1
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 1
73945: NEG
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 1
73956: NEG
73957: PUSH
73958: LD_INT 1
73960: NEG
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73975: LD_ADDR_VAR 0 60
73979: PUSH
73980: LD_INT 0
73982: PUSH
73983: LD_INT 0
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 0
73992: PUSH
73993: LD_INT 1
73995: NEG
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 1
74003: PUSH
74004: LD_INT 0
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 1
74013: PUSH
74014: LD_INT 1
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 0
74023: PUSH
74024: LD_INT 1
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 1
74033: NEG
74034: PUSH
74035: LD_INT 0
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 1
74044: NEG
74045: PUSH
74046: LD_INT 1
74048: NEG
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74063: LD_ADDR_VAR 0 61
74067: PUSH
74068: LD_INT 0
74070: PUSH
74071: LD_INT 0
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: LD_INT 1
74083: NEG
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 1
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 1
74101: PUSH
74102: LD_INT 1
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: LD_INT 0
74111: PUSH
74112: LD_INT 1
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 1
74121: NEG
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 1
74132: NEG
74133: PUSH
74134: LD_INT 1
74136: NEG
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: LIST
74148: LIST
74149: LIST
74150: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74151: LD_ADDR_VAR 0 62
74155: PUSH
74156: LD_INT 0
74158: PUSH
74159: LD_INT 0
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 0
74168: PUSH
74169: LD_INT 1
74171: NEG
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 1
74179: PUSH
74180: LD_INT 0
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: LD_INT 1
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 0
74199: PUSH
74200: LD_INT 1
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 1
74209: NEG
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 1
74220: NEG
74221: PUSH
74222: LD_INT 1
74224: NEG
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: LIST
74238: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74239: LD_ADDR_VAR 0 63
74243: PUSH
74244: LD_INT 0
74246: PUSH
74247: LD_INT 0
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 0
74256: PUSH
74257: LD_INT 1
74259: NEG
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: LD_INT 1
74267: PUSH
74268: LD_INT 0
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 1
74277: PUSH
74278: LD_INT 1
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 0
74287: PUSH
74288: LD_INT 1
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: LD_INT 1
74297: NEG
74298: PUSH
74299: LD_INT 0
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 1
74308: NEG
74309: PUSH
74310: LD_INT 1
74312: NEG
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: LIST
74326: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74327: LD_ADDR_VAR 0 64
74331: PUSH
74332: LD_INT 0
74334: PUSH
74335: LD_INT 0
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: LD_INT 0
74344: PUSH
74345: LD_INT 1
74347: NEG
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: LD_INT 1
74355: PUSH
74356: LD_INT 0
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: PUSH
74363: LD_INT 1
74365: PUSH
74366: LD_INT 1
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 0
74375: PUSH
74376: LD_INT 1
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 1
74385: NEG
74386: PUSH
74387: LD_INT 0
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 1
74396: NEG
74397: PUSH
74398: LD_INT 1
74400: NEG
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: ST_TO_ADDR
// end ; 1 :
74415: GO 80312
74417: LD_INT 1
74419: DOUBLE
74420: EQUAL
74421: IFTRUE 74425
74423: GO 77048
74425: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74426: LD_ADDR_VAR 0 11
74430: PUSH
74431: LD_INT 1
74433: NEG
74434: PUSH
74435: LD_INT 3
74437: NEG
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 0
74445: PUSH
74446: LD_INT 3
74448: NEG
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 1
74456: PUSH
74457: LD_INT 2
74459: NEG
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: LIST
74469: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74470: LD_ADDR_VAR 0 12
74474: PUSH
74475: LD_INT 2
74477: PUSH
74478: LD_INT 1
74480: NEG
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 3
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 3
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: LIST
74510: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74511: LD_ADDR_VAR 0 13
74515: PUSH
74516: LD_INT 3
74518: PUSH
74519: LD_INT 2
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 3
74528: PUSH
74529: LD_INT 3
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 2
74538: PUSH
74539: LD_INT 3
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: LIST
74550: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74551: LD_ADDR_VAR 0 14
74555: PUSH
74556: LD_INT 1
74558: PUSH
74559: LD_INT 3
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 0
74568: PUSH
74569: LD_INT 3
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 1
74578: NEG
74579: PUSH
74580: LD_INT 2
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: LIST
74591: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74592: LD_ADDR_VAR 0 15
74596: PUSH
74597: LD_INT 2
74599: NEG
74600: PUSH
74601: LD_INT 1
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 3
74610: NEG
74611: PUSH
74612: LD_INT 0
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: LD_INT 3
74621: NEG
74622: PUSH
74623: LD_INT 1
74625: NEG
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: LIST
74635: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74636: LD_ADDR_VAR 0 16
74640: PUSH
74641: LD_INT 2
74643: NEG
74644: PUSH
74645: LD_INT 3
74647: NEG
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 3
74655: NEG
74656: PUSH
74657: LD_INT 2
74659: NEG
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 3
74667: NEG
74668: PUSH
74669: LD_INT 3
74671: NEG
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: LIST
74681: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74682: LD_ADDR_VAR 0 17
74686: PUSH
74687: LD_INT 1
74689: NEG
74690: PUSH
74691: LD_INT 3
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 0
74701: PUSH
74702: LD_INT 3
74704: NEG
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: LD_INT 2
74715: NEG
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: LIST
74725: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74726: LD_ADDR_VAR 0 18
74730: PUSH
74731: LD_INT 2
74733: PUSH
74734: LD_INT 1
74736: NEG
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: LD_INT 3
74744: PUSH
74745: LD_INT 0
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 3
74754: PUSH
74755: LD_INT 1
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: LIST
74766: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74767: LD_ADDR_VAR 0 19
74771: PUSH
74772: LD_INT 3
74774: PUSH
74775: LD_INT 2
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: PUSH
74782: LD_INT 3
74784: PUSH
74785: LD_INT 3
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: PUSH
74792: LD_INT 2
74794: PUSH
74795: LD_INT 3
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: LIST
74806: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74807: LD_ADDR_VAR 0 20
74811: PUSH
74812: LD_INT 1
74814: PUSH
74815: LD_INT 3
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 0
74824: PUSH
74825: LD_INT 3
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: NEG
74835: PUSH
74836: LD_INT 2
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: LIST
74847: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74848: LD_ADDR_VAR 0 21
74852: PUSH
74853: LD_INT 2
74855: NEG
74856: PUSH
74857: LD_INT 1
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 3
74866: NEG
74867: PUSH
74868: LD_INT 0
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 3
74877: NEG
74878: PUSH
74879: LD_INT 1
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: LIST
74891: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74892: LD_ADDR_VAR 0 22
74896: PUSH
74897: LD_INT 2
74899: NEG
74900: PUSH
74901: LD_INT 3
74903: NEG
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 3
74911: NEG
74912: PUSH
74913: LD_INT 2
74915: NEG
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 3
74923: NEG
74924: PUSH
74925: LD_INT 3
74927: NEG
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: LIST
74937: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74938: LD_ADDR_VAR 0 23
74942: PUSH
74943: LD_INT 0
74945: PUSH
74946: LD_INT 3
74948: NEG
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 1
74956: NEG
74957: PUSH
74958: LD_INT 4
74960: NEG
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: LD_INT 3
74971: NEG
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: LIST
74981: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74982: LD_ADDR_VAR 0 24
74986: PUSH
74987: LD_INT 3
74989: PUSH
74990: LD_INT 0
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 3
74999: PUSH
75000: LD_INT 1
75002: NEG
75003: PUSH
75004: EMPTY
75005: LIST
75006: LIST
75007: PUSH
75008: LD_INT 4
75010: PUSH
75011: LD_INT 1
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: LIST
75022: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75023: LD_ADDR_VAR 0 25
75027: PUSH
75028: LD_INT 3
75030: PUSH
75031: LD_INT 3
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PUSH
75038: LD_INT 4
75040: PUSH
75041: LD_INT 3
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 3
75050: PUSH
75051: LD_INT 4
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: LIST
75062: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75063: LD_ADDR_VAR 0 26
75067: PUSH
75068: LD_INT 0
75070: PUSH
75071: LD_INT 3
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: LD_INT 1
75080: PUSH
75081: LD_INT 4
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 1
75090: NEG
75091: PUSH
75092: LD_INT 3
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: LIST
75103: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75104: LD_ADDR_VAR 0 27
75108: PUSH
75109: LD_INT 3
75111: NEG
75112: PUSH
75113: LD_INT 0
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 3
75122: NEG
75123: PUSH
75124: LD_INT 1
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 4
75133: NEG
75134: PUSH
75135: LD_INT 1
75137: NEG
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: LIST
75147: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75148: LD_ADDR_VAR 0 28
75152: PUSH
75153: LD_INT 3
75155: NEG
75156: PUSH
75157: LD_INT 3
75159: NEG
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 3
75167: NEG
75168: PUSH
75169: LD_INT 4
75171: NEG
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: LD_INT 4
75179: NEG
75180: PUSH
75181: LD_INT 3
75183: NEG
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: LIST
75193: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75194: LD_ADDR_VAR 0 29
75198: PUSH
75199: LD_INT 1
75201: NEG
75202: PUSH
75203: LD_INT 3
75205: NEG
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 0
75213: PUSH
75214: LD_INT 3
75216: NEG
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 1
75224: PUSH
75225: LD_INT 2
75227: NEG
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 1
75235: NEG
75236: PUSH
75237: LD_INT 4
75239: NEG
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 0
75247: PUSH
75248: LD_INT 4
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 1
75258: PUSH
75259: LD_INT 3
75261: NEG
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 1
75269: NEG
75270: PUSH
75271: LD_INT 5
75273: NEG
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 0
75281: PUSH
75282: LD_INT 5
75284: NEG
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: PUSH
75290: LD_INT 1
75292: PUSH
75293: LD_INT 4
75295: NEG
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: PUSH
75301: LD_INT 1
75303: NEG
75304: PUSH
75305: LD_INT 6
75307: NEG
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 0
75315: PUSH
75316: LD_INT 6
75318: NEG
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 1
75326: PUSH
75327: LD_INT 5
75329: NEG
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: LIST
75339: LIST
75340: LIST
75341: LIST
75342: LIST
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75349: LD_ADDR_VAR 0 30
75353: PUSH
75354: LD_INT 2
75356: PUSH
75357: LD_INT 1
75359: NEG
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 3
75367: PUSH
75368: LD_INT 0
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 3
75377: PUSH
75378: LD_INT 1
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: LD_INT 3
75387: PUSH
75388: LD_INT 1
75390: NEG
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 4
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 4
75408: PUSH
75409: LD_INT 1
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: LD_INT 4
75418: PUSH
75419: LD_INT 1
75421: NEG
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PUSH
75427: LD_INT 5
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: EMPTY
75434: LIST
75435: LIST
75436: PUSH
75437: LD_INT 5
75439: PUSH
75440: LD_INT 1
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 5
75449: PUSH
75450: LD_INT 1
75452: NEG
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 6
75460: PUSH
75461: LD_INT 0
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: PUSH
75468: LD_INT 6
75470: PUSH
75471: LD_INT 1
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: LIST
75482: LIST
75483: LIST
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75492: LD_ADDR_VAR 0 31
75496: PUSH
75497: LD_INT 3
75499: PUSH
75500: LD_INT 2
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 3
75509: PUSH
75510: LD_INT 3
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: LD_INT 3
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PUSH
75527: LD_INT 4
75529: PUSH
75530: LD_INT 3
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: PUSH
75537: LD_INT 4
75539: PUSH
75540: LD_INT 4
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 3
75549: PUSH
75550: LD_INT 4
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: LD_INT 5
75559: PUSH
75560: LD_INT 4
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 5
75569: PUSH
75570: LD_INT 5
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 4
75579: PUSH
75580: LD_INT 5
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 6
75589: PUSH
75590: LD_INT 5
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 6
75599: PUSH
75600: LD_INT 6
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: LD_INT 5
75609: PUSH
75610: LD_INT 6
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: LIST
75621: LIST
75622: LIST
75623: LIST
75624: LIST
75625: LIST
75626: LIST
75627: LIST
75628: LIST
75629: LIST
75630: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75631: LD_ADDR_VAR 0 32
75635: PUSH
75636: LD_INT 1
75638: PUSH
75639: LD_INT 3
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 0
75648: PUSH
75649: LD_INT 3
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 1
75658: NEG
75659: PUSH
75660: LD_INT 2
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: PUSH
75667: LD_INT 1
75669: PUSH
75670: LD_INT 4
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PUSH
75677: LD_INT 0
75679: PUSH
75680: LD_INT 4
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: LD_INT 1
75689: NEG
75690: PUSH
75691: LD_INT 3
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 1
75700: PUSH
75701: LD_INT 5
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 0
75710: PUSH
75711: LD_INT 5
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 1
75720: NEG
75721: PUSH
75722: LD_INT 4
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 1
75731: PUSH
75732: LD_INT 6
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: LD_INT 0
75741: PUSH
75742: LD_INT 6
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 1
75751: NEG
75752: PUSH
75753: LD_INT 5
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: LIST
75769: LIST
75770: LIST
75771: LIST
75772: LIST
75773: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75774: LD_ADDR_VAR 0 33
75778: PUSH
75779: LD_INT 2
75781: NEG
75782: PUSH
75783: LD_INT 1
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 3
75792: NEG
75793: PUSH
75794: LD_INT 0
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 3
75803: NEG
75804: PUSH
75805: LD_INT 1
75807: NEG
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 3
75815: NEG
75816: PUSH
75817: LD_INT 1
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 4
75826: NEG
75827: PUSH
75828: LD_INT 0
75830: PUSH
75831: EMPTY
75832: LIST
75833: LIST
75834: PUSH
75835: LD_INT 4
75837: NEG
75838: PUSH
75839: LD_INT 1
75841: NEG
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: LD_INT 4
75849: NEG
75850: PUSH
75851: LD_INT 1
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: PUSH
75858: LD_INT 5
75860: NEG
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 5
75871: NEG
75872: PUSH
75873: LD_INT 1
75875: NEG
75876: PUSH
75877: EMPTY
75878: LIST
75879: LIST
75880: PUSH
75881: LD_INT 5
75883: NEG
75884: PUSH
75885: LD_INT 1
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 6
75894: NEG
75895: PUSH
75896: LD_INT 0
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 6
75905: NEG
75906: PUSH
75907: LD_INT 1
75909: NEG
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: LIST
75926: LIST
75927: LIST
75928: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75929: LD_ADDR_VAR 0 34
75933: PUSH
75934: LD_INT 2
75936: NEG
75937: PUSH
75938: LD_INT 3
75940: NEG
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 3
75948: NEG
75949: PUSH
75950: LD_INT 2
75952: NEG
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 3
75960: NEG
75961: PUSH
75962: LD_INT 3
75964: NEG
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 3
75972: NEG
75973: PUSH
75974: LD_INT 4
75976: NEG
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: LD_INT 4
75984: NEG
75985: PUSH
75986: LD_INT 3
75988: NEG
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PUSH
75994: LD_INT 4
75996: NEG
75997: PUSH
75998: LD_INT 4
76000: NEG
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: LD_INT 4
76008: NEG
76009: PUSH
76010: LD_INT 5
76012: NEG
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: LD_INT 5
76020: NEG
76021: PUSH
76022: LD_INT 4
76024: NEG
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 5
76032: NEG
76033: PUSH
76034: LD_INT 5
76036: NEG
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 5
76044: NEG
76045: PUSH
76046: LD_INT 6
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 6
76056: NEG
76057: PUSH
76058: LD_INT 5
76060: NEG
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PUSH
76066: LD_INT 6
76068: NEG
76069: PUSH
76070: LD_INT 6
76072: NEG
76073: PUSH
76074: EMPTY
76075: LIST
76076: LIST
76077: PUSH
76078: EMPTY
76079: LIST
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76092: LD_ADDR_VAR 0 41
76096: PUSH
76097: LD_INT 0
76099: PUSH
76100: LD_INT 2
76102: NEG
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 1
76110: NEG
76111: PUSH
76112: LD_INT 3
76114: NEG
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 1
76122: PUSH
76123: LD_INT 2
76125: NEG
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: LIST
76135: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76136: LD_ADDR_VAR 0 42
76140: PUSH
76141: LD_INT 2
76143: PUSH
76144: LD_INT 0
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 2
76153: PUSH
76154: LD_INT 1
76156: NEG
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 3
76164: PUSH
76165: LD_INT 1
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: LIST
76176: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76177: LD_ADDR_VAR 0 43
76181: PUSH
76182: LD_INT 2
76184: PUSH
76185: LD_INT 2
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 3
76194: PUSH
76195: LD_INT 2
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 2
76204: PUSH
76205: LD_INT 3
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: LIST
76216: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76217: LD_ADDR_VAR 0 44
76221: PUSH
76222: LD_INT 0
76224: PUSH
76225: LD_INT 2
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: PUSH
76232: LD_INT 1
76234: PUSH
76235: LD_INT 3
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 1
76244: NEG
76245: PUSH
76246: LD_INT 2
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: LIST
76257: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76258: LD_ADDR_VAR 0 45
76262: PUSH
76263: LD_INT 2
76265: NEG
76266: PUSH
76267: LD_INT 0
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 2
76276: NEG
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 3
76287: NEG
76288: PUSH
76289: LD_INT 1
76291: NEG
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: LIST
76301: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76302: LD_ADDR_VAR 0 46
76306: PUSH
76307: LD_INT 2
76309: NEG
76310: PUSH
76311: LD_INT 2
76313: NEG
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 2
76321: NEG
76322: PUSH
76323: LD_INT 3
76325: NEG
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 3
76333: NEG
76334: PUSH
76335: LD_INT 2
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: LIST
76347: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76348: LD_ADDR_VAR 0 47
76352: PUSH
76353: LD_INT 2
76355: NEG
76356: PUSH
76357: LD_INT 3
76359: NEG
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 1
76367: NEG
76368: PUSH
76369: LD_INT 3
76371: NEG
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76381: LD_ADDR_VAR 0 48
76385: PUSH
76386: LD_INT 1
76388: PUSH
76389: LD_INT 2
76391: NEG
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 2
76399: PUSH
76400: LD_INT 1
76402: NEG
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76412: LD_ADDR_VAR 0 49
76416: PUSH
76417: LD_INT 3
76419: PUSH
76420: LD_INT 1
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 3
76429: PUSH
76430: LD_INT 2
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76441: LD_ADDR_VAR 0 50
76445: PUSH
76446: LD_INT 2
76448: PUSH
76449: LD_INT 3
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 1
76458: PUSH
76459: LD_INT 3
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76470: LD_ADDR_VAR 0 51
76474: PUSH
76475: LD_INT 1
76477: NEG
76478: PUSH
76479: LD_INT 2
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 2
76488: NEG
76489: PUSH
76490: LD_INT 1
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76501: LD_ADDR_VAR 0 52
76505: PUSH
76506: LD_INT 3
76508: NEG
76509: PUSH
76510: LD_INT 1
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 3
76520: NEG
76521: PUSH
76522: LD_INT 2
76524: NEG
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76534: LD_ADDR_VAR 0 53
76538: PUSH
76539: LD_INT 1
76541: NEG
76542: PUSH
76543: LD_INT 3
76545: NEG
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 0
76553: PUSH
76554: LD_INT 3
76556: NEG
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: PUSH
76562: LD_INT 1
76564: PUSH
76565: LD_INT 2
76567: NEG
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: LIST
76577: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76578: LD_ADDR_VAR 0 54
76582: PUSH
76583: LD_INT 2
76585: PUSH
76586: LD_INT 1
76588: NEG
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 3
76596: PUSH
76597: LD_INT 0
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 3
76606: PUSH
76607: LD_INT 1
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: LIST
76618: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76619: LD_ADDR_VAR 0 55
76623: PUSH
76624: LD_INT 3
76626: PUSH
76627: LD_INT 2
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 3
76636: PUSH
76637: LD_INT 3
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 2
76646: PUSH
76647: LD_INT 3
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: LIST
76658: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76659: LD_ADDR_VAR 0 56
76663: PUSH
76664: LD_INT 1
76666: PUSH
76667: LD_INT 3
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 0
76676: PUSH
76677: LD_INT 3
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 1
76686: NEG
76687: PUSH
76688: LD_INT 2
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: LIST
76699: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76700: LD_ADDR_VAR 0 57
76704: PUSH
76705: LD_INT 2
76707: NEG
76708: PUSH
76709: LD_INT 1
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 3
76718: NEG
76719: PUSH
76720: LD_INT 0
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 3
76729: NEG
76730: PUSH
76731: LD_INT 1
76733: NEG
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: LIST
76743: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76744: LD_ADDR_VAR 0 58
76748: PUSH
76749: LD_INT 2
76751: NEG
76752: PUSH
76753: LD_INT 3
76755: NEG
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: LD_INT 3
76763: NEG
76764: PUSH
76765: LD_INT 2
76767: NEG
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 3
76775: NEG
76776: PUSH
76777: LD_INT 3
76779: NEG
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: LIST
76789: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76790: LD_ADDR_VAR 0 59
76794: PUSH
76795: LD_INT 1
76797: NEG
76798: PUSH
76799: LD_INT 2
76801: NEG
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 0
76809: PUSH
76810: LD_INT 2
76812: NEG
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 1
76820: PUSH
76821: LD_INT 1
76823: NEG
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: LIST
76833: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76834: LD_ADDR_VAR 0 60
76838: PUSH
76839: LD_INT 1
76841: PUSH
76842: LD_INT 1
76844: NEG
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 2
76852: PUSH
76853: LD_INT 0
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 2
76862: PUSH
76863: LD_INT 1
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: LIST
76874: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76875: LD_ADDR_VAR 0 61
76879: PUSH
76880: LD_INT 2
76882: PUSH
76883: LD_INT 1
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 2
76892: PUSH
76893: LD_INT 2
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 1
76902: PUSH
76903: LD_INT 2
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: LIST
76914: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76915: LD_ADDR_VAR 0 62
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: LD_INT 2
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 0
76932: PUSH
76933: LD_INT 2
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: LD_INT 1
76942: NEG
76943: PUSH
76944: LD_INT 1
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: LIST
76955: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76956: LD_ADDR_VAR 0 63
76960: PUSH
76961: LD_INT 1
76963: NEG
76964: PUSH
76965: LD_INT 1
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 2
76974: NEG
76975: PUSH
76976: LD_INT 0
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 2
76985: NEG
76986: PUSH
76987: LD_INT 1
76989: NEG
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: LIST
76999: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77000: LD_ADDR_VAR 0 64
77004: PUSH
77005: LD_INT 1
77007: NEG
77008: PUSH
77009: LD_INT 2
77011: NEG
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 2
77019: NEG
77020: PUSH
77021: LD_INT 1
77023: NEG
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 2
77031: NEG
77032: PUSH
77033: LD_INT 2
77035: NEG
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: LIST
77045: ST_TO_ADDR
// end ; 2 :
77046: GO 80312
77048: LD_INT 2
77050: DOUBLE
77051: EQUAL
77052: IFTRUE 77056
77054: GO 80311
77056: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77057: LD_ADDR_VAR 0 29
77061: PUSH
77062: LD_INT 4
77064: PUSH
77065: LD_INT 0
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: LD_INT 4
77074: PUSH
77075: LD_INT 1
77077: NEG
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 5
77085: PUSH
77086: LD_INT 0
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 5
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 4
77105: PUSH
77106: LD_INT 1
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 3
77115: PUSH
77116: LD_INT 0
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 3
77125: PUSH
77126: LD_INT 1
77128: NEG
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 3
77136: PUSH
77137: LD_INT 2
77139: NEG
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 5
77147: PUSH
77148: LD_INT 2
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 3
77157: PUSH
77158: LD_INT 3
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 3
77167: PUSH
77168: LD_INT 2
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 4
77177: PUSH
77178: LD_INT 3
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 4
77187: PUSH
77188: LD_INT 4
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 3
77197: PUSH
77198: LD_INT 4
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: PUSH
77205: LD_INT 2
77207: PUSH
77208: LD_INT 3
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 2
77217: PUSH
77218: LD_INT 2
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 4
77227: PUSH
77228: LD_INT 2
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 2
77237: PUSH
77238: LD_INT 4
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 0
77247: PUSH
77248: LD_INT 4
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 0
77257: PUSH
77258: LD_INT 3
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 1
77267: PUSH
77268: LD_INT 4
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 1
77277: PUSH
77278: LD_INT 5
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 0
77287: PUSH
77288: LD_INT 5
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 1
77297: NEG
77298: PUSH
77299: LD_INT 4
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: NEG
77309: PUSH
77310: LD_INT 3
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: PUSH
77317: LD_INT 2
77319: PUSH
77320: LD_INT 5
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: LD_INT 2
77329: NEG
77330: PUSH
77331: LD_INT 3
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 3
77340: NEG
77341: PUSH
77342: LD_INT 0
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 3
77351: NEG
77352: PUSH
77353: LD_INT 1
77355: NEG
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 2
77363: NEG
77364: PUSH
77365: LD_INT 0
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 2
77374: NEG
77375: PUSH
77376: LD_INT 1
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 3
77385: NEG
77386: PUSH
77387: LD_INT 1
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 4
77396: NEG
77397: PUSH
77398: LD_INT 0
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 4
77407: NEG
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 4
77419: NEG
77420: PUSH
77421: LD_INT 2
77423: NEG
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 2
77431: NEG
77432: PUSH
77433: LD_INT 2
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 4
77442: NEG
77443: PUSH
77444: LD_INT 4
77446: NEG
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 4
77454: NEG
77455: PUSH
77456: LD_INT 5
77458: NEG
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 3
77466: NEG
77467: PUSH
77468: LD_INT 4
77470: NEG
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 3
77478: NEG
77479: PUSH
77480: LD_INT 3
77482: NEG
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: PUSH
77488: LD_INT 4
77490: NEG
77491: PUSH
77492: LD_INT 3
77494: NEG
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 5
77502: NEG
77503: PUSH
77504: LD_INT 4
77506: NEG
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 5
77514: NEG
77515: PUSH
77516: LD_INT 5
77518: NEG
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 3
77526: NEG
77527: PUSH
77528: LD_INT 5
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 5
77538: NEG
77539: PUSH
77540: LD_INT 3
77542: NEG
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: LIST
77568: LIST
77569: LIST
77570: LIST
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77595: LD_ADDR_VAR 0 30
77599: PUSH
77600: LD_INT 4
77602: PUSH
77603: LD_INT 4
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 4
77612: PUSH
77613: LD_INT 3
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 5
77622: PUSH
77623: LD_INT 4
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 5
77632: PUSH
77633: LD_INT 5
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 4
77642: PUSH
77643: LD_INT 5
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 3
77652: PUSH
77653: LD_INT 4
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 3
77662: PUSH
77663: LD_INT 3
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 5
77672: PUSH
77673: LD_INT 3
77675: PUSH
77676: EMPTY
77677: LIST
77678: LIST
77679: PUSH
77680: LD_INT 3
77682: PUSH
77683: LD_INT 5
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: LD_INT 0
77692: PUSH
77693: LD_INT 3
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: LD_INT 0
77702: PUSH
77703: LD_INT 2
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: PUSH
77710: LD_INT 1
77712: PUSH
77713: LD_INT 3
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: PUSH
77720: LD_INT 1
77722: PUSH
77723: LD_INT 4
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: PUSH
77730: LD_INT 0
77732: PUSH
77733: LD_INT 4
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: PUSH
77740: LD_INT 1
77742: NEG
77743: PUSH
77744: LD_INT 3
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: LD_INT 1
77753: NEG
77754: PUSH
77755: LD_INT 2
77757: PUSH
77758: EMPTY
77759: LIST
77760: LIST
77761: PUSH
77762: LD_INT 2
77764: PUSH
77765: LD_INT 4
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 2
77774: NEG
77775: PUSH
77776: LD_INT 2
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 4
77785: NEG
77786: PUSH
77787: LD_INT 0
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 4
77796: NEG
77797: PUSH
77798: LD_INT 1
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 3
77808: NEG
77809: PUSH
77810: LD_INT 0
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 3
77819: NEG
77820: PUSH
77821: LD_INT 1
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: PUSH
77828: LD_INT 4
77830: NEG
77831: PUSH
77832: LD_INT 1
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 5
77841: NEG
77842: PUSH
77843: LD_INT 0
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 5
77852: NEG
77853: PUSH
77854: LD_INT 1
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 5
77864: NEG
77865: PUSH
77866: LD_INT 2
77868: NEG
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 3
77876: NEG
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 3
77887: NEG
77888: PUSH
77889: LD_INT 3
77891: NEG
77892: PUSH
77893: EMPTY
77894: LIST
77895: LIST
77896: PUSH
77897: LD_INT 3
77899: NEG
77900: PUSH
77901: LD_INT 4
77903: NEG
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 2
77911: NEG
77912: PUSH
77913: LD_INT 3
77915: NEG
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 2
77923: NEG
77924: PUSH
77925: LD_INT 2
77927: NEG
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 3
77935: NEG
77936: PUSH
77937: LD_INT 2
77939: NEG
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: LD_INT 4
77947: NEG
77948: PUSH
77949: LD_INT 3
77951: NEG
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 4
77959: NEG
77960: PUSH
77961: LD_INT 4
77963: NEG
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 2
77971: NEG
77972: PUSH
77973: LD_INT 4
77975: NEG
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 4
77983: NEG
77984: PUSH
77985: LD_INT 2
77987: NEG
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 0
77995: PUSH
77996: LD_INT 4
77998: NEG
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: LD_INT 0
78006: PUSH
78007: LD_INT 5
78009: NEG
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 1
78017: PUSH
78018: LD_INT 4
78020: NEG
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 1
78028: PUSH
78029: LD_INT 3
78031: NEG
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 0
78039: PUSH
78040: LD_INT 3
78042: NEG
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 1
78050: NEG
78051: PUSH
78052: LD_INT 4
78054: NEG
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 1
78062: NEG
78063: PUSH
78064: LD_INT 5
78066: NEG
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 2
78074: PUSH
78075: LD_INT 3
78077: NEG
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 2
78085: NEG
78086: PUSH
78087: LD_INT 5
78089: NEG
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: LIST
78099: LIST
78100: LIST
78101: LIST
78102: LIST
78103: LIST
78104: LIST
78105: LIST
78106: LIST
78107: LIST
78108: LIST
78109: LIST
78110: LIST
78111: LIST
78112: LIST
78113: LIST
78114: LIST
78115: LIST
78116: LIST
78117: LIST
78118: LIST
78119: LIST
78120: LIST
78121: LIST
78122: LIST
78123: LIST
78124: LIST
78125: LIST
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78142: LD_ADDR_VAR 0 31
78146: PUSH
78147: LD_INT 0
78149: PUSH
78150: LD_INT 4
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PUSH
78157: LD_INT 0
78159: PUSH
78160: LD_INT 3
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 1
78169: PUSH
78170: LD_INT 4
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 1
78179: PUSH
78180: LD_INT 5
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PUSH
78187: LD_INT 0
78189: PUSH
78190: LD_INT 5
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: PUSH
78197: LD_INT 1
78199: NEG
78200: PUSH
78201: LD_INT 4
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: LD_INT 1
78210: NEG
78211: PUSH
78212: LD_INT 3
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PUSH
78219: LD_INT 2
78221: PUSH
78222: LD_INT 5
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 2
78231: NEG
78232: PUSH
78233: LD_INT 3
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 3
78242: NEG
78243: PUSH
78244: LD_INT 0
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 3
78253: NEG
78254: PUSH
78255: LD_INT 1
78257: NEG
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 2
78265: NEG
78266: PUSH
78267: LD_INT 0
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 2
78276: NEG
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 3
78287: NEG
78288: PUSH
78289: LD_INT 1
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 4
78298: NEG
78299: PUSH
78300: LD_INT 0
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: LD_INT 4
78309: NEG
78310: PUSH
78311: LD_INT 1
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 4
78321: NEG
78322: PUSH
78323: LD_INT 2
78325: NEG
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 2
78333: NEG
78334: PUSH
78335: LD_INT 2
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 4
78344: NEG
78345: PUSH
78346: LD_INT 4
78348: NEG
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 4
78356: NEG
78357: PUSH
78358: LD_INT 5
78360: NEG
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: PUSH
78366: LD_INT 3
78368: NEG
78369: PUSH
78370: LD_INT 4
78372: NEG
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 3
78380: NEG
78381: PUSH
78382: LD_INT 3
78384: NEG
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 4
78392: NEG
78393: PUSH
78394: LD_INT 3
78396: NEG
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 5
78404: NEG
78405: PUSH
78406: LD_INT 4
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 5
78416: NEG
78417: PUSH
78418: LD_INT 5
78420: NEG
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 3
78428: NEG
78429: PUSH
78430: LD_INT 5
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 5
78440: NEG
78441: PUSH
78442: LD_INT 3
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 0
78452: PUSH
78453: LD_INT 3
78455: NEG
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 0
78463: PUSH
78464: LD_INT 4
78466: NEG
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 1
78474: PUSH
78475: LD_INT 3
78477: NEG
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 1
78485: PUSH
78486: LD_INT 2
78488: NEG
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 0
78496: PUSH
78497: LD_INT 2
78499: NEG
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 1
78507: NEG
78508: PUSH
78509: LD_INT 3
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 1
78519: NEG
78520: PUSH
78521: LD_INT 4
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 2
78531: PUSH
78532: LD_INT 2
78534: NEG
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 2
78542: NEG
78543: PUSH
78544: LD_INT 4
78546: NEG
78547: PUSH
78548: EMPTY
78549: LIST
78550: LIST
78551: PUSH
78552: LD_INT 4
78554: PUSH
78555: LD_INT 0
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 4
78564: PUSH
78565: LD_INT 1
78567: NEG
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 5
78575: PUSH
78576: LD_INT 0
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 5
78585: PUSH
78586: LD_INT 1
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 4
78595: PUSH
78596: LD_INT 1
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 3
78605: PUSH
78606: LD_INT 0
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 3
78615: PUSH
78616: LD_INT 1
78618: NEG
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 3
78626: PUSH
78627: LD_INT 2
78629: NEG
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 5
78637: PUSH
78638: LD_INT 2
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: LIST
78649: LIST
78650: LIST
78651: LIST
78652: LIST
78653: LIST
78654: LIST
78655: LIST
78656: LIST
78657: LIST
78658: LIST
78659: LIST
78660: LIST
78661: LIST
78662: LIST
78663: LIST
78664: LIST
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78692: LD_ADDR_VAR 0 32
78696: PUSH
78697: LD_INT 4
78699: NEG
78700: PUSH
78701: LD_INT 0
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 4
78710: NEG
78711: PUSH
78712: LD_INT 1
78714: NEG
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 3
78722: NEG
78723: PUSH
78724: LD_INT 0
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 3
78733: NEG
78734: PUSH
78735: LD_INT 1
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 4
78744: NEG
78745: PUSH
78746: LD_INT 1
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: PUSH
78753: LD_INT 5
78755: NEG
78756: PUSH
78757: LD_INT 0
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 5
78766: NEG
78767: PUSH
78768: LD_INT 1
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 5
78778: NEG
78779: PUSH
78780: LD_INT 2
78782: NEG
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 3
78790: NEG
78791: PUSH
78792: LD_INT 2
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 3
78801: NEG
78802: PUSH
78803: LD_INT 3
78805: NEG
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 3
78813: NEG
78814: PUSH
78815: LD_INT 4
78817: NEG
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 2
78825: NEG
78826: PUSH
78827: LD_INT 3
78829: NEG
78830: PUSH
78831: EMPTY
78832: LIST
78833: LIST
78834: PUSH
78835: LD_INT 2
78837: NEG
78838: PUSH
78839: LD_INT 2
78841: NEG
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 3
78849: NEG
78850: PUSH
78851: LD_INT 2
78853: NEG
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 4
78861: NEG
78862: PUSH
78863: LD_INT 3
78865: NEG
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 4
78873: NEG
78874: PUSH
78875: LD_INT 4
78877: NEG
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 2
78885: NEG
78886: PUSH
78887: LD_INT 4
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 4
78897: NEG
78898: PUSH
78899: LD_INT 2
78901: NEG
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 0
78909: PUSH
78910: LD_INT 4
78912: NEG
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 0
78920: PUSH
78921: LD_INT 5
78923: NEG
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 1
78931: PUSH
78932: LD_INT 4
78934: NEG
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 1
78942: PUSH
78943: LD_INT 3
78945: NEG
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 0
78953: PUSH
78954: LD_INT 3
78956: NEG
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 1
78964: NEG
78965: PUSH
78966: LD_INT 4
78968: NEG
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 1
78976: NEG
78977: PUSH
78978: LD_INT 5
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 2
78988: PUSH
78989: LD_INT 3
78991: NEG
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 2
78999: NEG
79000: PUSH
79001: LD_INT 5
79003: NEG
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 3
79011: PUSH
79012: LD_INT 0
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: LD_INT 3
79021: PUSH
79022: LD_INT 1
79024: NEG
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 4
79032: PUSH
79033: LD_INT 0
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 4
79042: PUSH
79043: LD_INT 1
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 3
79052: PUSH
79053: LD_INT 1
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 2
79062: PUSH
79063: LD_INT 0
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 2
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 2
79083: PUSH
79084: LD_INT 2
79086: NEG
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 4
79094: PUSH
79095: LD_INT 2
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 4
79104: PUSH
79105: LD_INT 4
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 4
79114: PUSH
79115: LD_INT 3
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 5
79124: PUSH
79125: LD_INT 4
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 5
79134: PUSH
79135: LD_INT 5
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 4
79144: PUSH
79145: LD_INT 5
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 3
79154: PUSH
79155: LD_INT 4
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 3
79164: PUSH
79165: LD_INT 3
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 5
79174: PUSH
79175: LD_INT 3
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 3
79184: PUSH
79185: LD_INT 5
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: LIST
79203: LIST
79204: LIST
79205: LIST
79206: LIST
79207: LIST
79208: LIST
79209: LIST
79210: LIST
79211: LIST
79212: LIST
79213: LIST
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: LIST
79232: LIST
79233: LIST
79234: LIST
79235: LIST
79236: LIST
79237: LIST
79238: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79239: LD_ADDR_VAR 0 33
79243: PUSH
79244: LD_INT 4
79246: NEG
79247: PUSH
79248: LD_INT 4
79250: NEG
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 4
79258: NEG
79259: PUSH
79260: LD_INT 5
79262: NEG
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: LD_INT 3
79270: NEG
79271: PUSH
79272: LD_INT 4
79274: NEG
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 3
79282: NEG
79283: PUSH
79284: LD_INT 3
79286: NEG
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 4
79294: NEG
79295: PUSH
79296: LD_INT 3
79298: NEG
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: PUSH
79304: LD_INT 5
79306: NEG
79307: PUSH
79308: LD_INT 4
79310: NEG
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 5
79318: NEG
79319: PUSH
79320: LD_INT 5
79322: NEG
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: LD_INT 3
79330: NEG
79331: PUSH
79332: LD_INT 5
79334: NEG
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 5
79342: NEG
79343: PUSH
79344: LD_INT 3
79346: NEG
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 0
79354: PUSH
79355: LD_INT 3
79357: NEG
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 0
79365: PUSH
79366: LD_INT 4
79368: NEG
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 1
79376: PUSH
79377: LD_INT 3
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 1
79387: PUSH
79388: LD_INT 2
79390: NEG
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 0
79398: PUSH
79399: LD_INT 2
79401: NEG
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 1
79409: NEG
79410: PUSH
79411: LD_INT 3
79413: NEG
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 1
79421: NEG
79422: PUSH
79423: LD_INT 4
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 2
79433: PUSH
79434: LD_INT 2
79436: NEG
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 2
79444: NEG
79445: PUSH
79446: LD_INT 4
79448: NEG
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 4
79456: PUSH
79457: LD_INT 0
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 4
79466: PUSH
79467: LD_INT 1
79469: NEG
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 5
79477: PUSH
79478: LD_INT 0
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 5
79487: PUSH
79488: LD_INT 1
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: LD_INT 4
79497: PUSH
79498: LD_INT 1
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 3
79507: PUSH
79508: LD_INT 0
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 3
79517: PUSH
79518: LD_INT 1
79520: NEG
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 3
79528: PUSH
79529: LD_INT 2
79531: NEG
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 5
79539: PUSH
79540: LD_INT 2
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 3
79549: PUSH
79550: LD_INT 3
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 3
79559: PUSH
79560: LD_INT 2
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 4
79569: PUSH
79570: LD_INT 3
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 4
79579: PUSH
79580: LD_INT 4
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 3
79589: PUSH
79590: LD_INT 4
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 2
79599: PUSH
79600: LD_INT 3
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 2
79609: PUSH
79610: LD_INT 2
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 4
79619: PUSH
79620: LD_INT 2
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 2
79629: PUSH
79630: LD_INT 4
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 0
79639: PUSH
79640: LD_INT 4
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 0
79649: PUSH
79650: LD_INT 3
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 1
79659: PUSH
79660: LD_INT 4
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 1
79669: PUSH
79670: LD_INT 5
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 0
79679: PUSH
79680: LD_INT 5
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 1
79689: NEG
79690: PUSH
79691: LD_INT 4
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 1
79700: NEG
79701: PUSH
79702: LD_INT 3
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 2
79711: PUSH
79712: LD_INT 5
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 2
79721: NEG
79722: PUSH
79723: LD_INT 3
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: LIST
79734: LIST
79735: LIST
79736: LIST
79737: LIST
79738: LIST
79739: LIST
79740: LIST
79741: LIST
79742: LIST
79743: LIST
79744: LIST
79745: LIST
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: LIST
79773: LIST
79774: LIST
79775: LIST
79776: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79777: LD_ADDR_VAR 0 34
79781: PUSH
79782: LD_INT 0
79784: PUSH
79785: LD_INT 4
79787: NEG
79788: PUSH
79789: EMPTY
79790: LIST
79791: LIST
79792: PUSH
79793: LD_INT 0
79795: PUSH
79796: LD_INT 5
79798: NEG
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 1
79806: PUSH
79807: LD_INT 4
79809: NEG
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 1
79817: PUSH
79818: LD_INT 3
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 0
79828: PUSH
79829: LD_INT 3
79831: NEG
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: LD_INT 4
79843: NEG
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 1
79851: NEG
79852: PUSH
79853: LD_INT 5
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 2
79863: PUSH
79864: LD_INT 3
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 2
79874: NEG
79875: PUSH
79876: LD_INT 5
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 3
79886: PUSH
79887: LD_INT 0
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: LD_INT 3
79896: PUSH
79897: LD_INT 1
79899: NEG
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: LD_INT 4
79907: PUSH
79908: LD_INT 0
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 4
79917: PUSH
79918: LD_INT 1
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 3
79927: PUSH
79928: LD_INT 1
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: LD_INT 2
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 2
79947: PUSH
79948: LD_INT 1
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 2
79958: PUSH
79959: LD_INT 2
79961: NEG
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 4
79969: PUSH
79970: LD_INT 2
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 4
79979: PUSH
79980: LD_INT 4
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 4
79989: PUSH
79990: LD_INT 3
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 5
79999: PUSH
80000: LD_INT 4
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 5
80009: PUSH
80010: LD_INT 5
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 4
80019: PUSH
80020: LD_INT 5
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 3
80029: PUSH
80030: LD_INT 4
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 3
80039: PUSH
80040: LD_INT 3
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 5
80049: PUSH
80050: LD_INT 3
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 3
80059: PUSH
80060: LD_INT 5
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 0
80069: PUSH
80070: LD_INT 3
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: LD_INT 2
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 1
80089: PUSH
80090: LD_INT 3
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 1
80099: PUSH
80100: LD_INT 4
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 0
80109: PUSH
80110: LD_INT 4
80112: PUSH
80113: EMPTY
80114: LIST
80115: LIST
80116: PUSH
80117: LD_INT 1
80119: NEG
80120: PUSH
80121: LD_INT 3
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 1
80130: NEG
80131: PUSH
80132: LD_INT 2
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 2
80141: PUSH
80142: LD_INT 4
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 2
80151: NEG
80152: PUSH
80153: LD_INT 2
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 4
80162: NEG
80163: PUSH
80164: LD_INT 0
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 4
80173: NEG
80174: PUSH
80175: LD_INT 1
80177: NEG
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 3
80185: NEG
80186: PUSH
80187: LD_INT 0
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 3
80196: NEG
80197: PUSH
80198: LD_INT 1
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 4
80207: NEG
80208: PUSH
80209: LD_INT 1
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 5
80218: NEG
80219: PUSH
80220: LD_INT 0
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 5
80229: NEG
80230: PUSH
80231: LD_INT 1
80233: NEG
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 5
80241: NEG
80242: PUSH
80243: LD_INT 2
80245: NEG
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 3
80253: NEG
80254: PUSH
80255: LD_INT 2
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: LIST
80301: LIST
80302: LIST
80303: LIST
80304: LIST
80305: LIST
80306: LIST
80307: LIST
80308: ST_TO_ADDR
// end ; end ;
80309: GO 80312
80311: POP
// case btype of b_depot , b_warehouse :
80312: LD_VAR 0 1
80316: PUSH
80317: LD_INT 0
80319: DOUBLE
80320: EQUAL
80321: IFTRUE 80331
80323: LD_INT 1
80325: DOUBLE
80326: EQUAL
80327: IFTRUE 80331
80329: GO 80532
80331: POP
// case nation of nation_american :
80332: LD_VAR 0 5
80336: PUSH
80337: LD_INT 1
80339: DOUBLE
80340: EQUAL
80341: IFTRUE 80345
80343: GO 80401
80345: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80346: LD_ADDR_VAR 0 9
80350: PUSH
80351: LD_VAR 0 11
80355: PUSH
80356: LD_VAR 0 12
80360: PUSH
80361: LD_VAR 0 13
80365: PUSH
80366: LD_VAR 0 14
80370: PUSH
80371: LD_VAR 0 15
80375: PUSH
80376: LD_VAR 0 16
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: PUSH
80389: LD_VAR 0 4
80393: PUSH
80394: LD_INT 1
80396: PLUS
80397: ARRAY
80398: ST_TO_ADDR
80399: GO 80530
80401: LD_INT 2
80403: DOUBLE
80404: EQUAL
80405: IFTRUE 80409
80407: GO 80465
80409: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80410: LD_ADDR_VAR 0 9
80414: PUSH
80415: LD_VAR 0 17
80419: PUSH
80420: LD_VAR 0 18
80424: PUSH
80425: LD_VAR 0 19
80429: PUSH
80430: LD_VAR 0 20
80434: PUSH
80435: LD_VAR 0 21
80439: PUSH
80440: LD_VAR 0 22
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: PUSH
80453: LD_VAR 0 4
80457: PUSH
80458: LD_INT 1
80460: PLUS
80461: ARRAY
80462: ST_TO_ADDR
80463: GO 80530
80465: LD_INT 3
80467: DOUBLE
80468: EQUAL
80469: IFTRUE 80473
80471: GO 80529
80473: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80474: LD_ADDR_VAR 0 9
80478: PUSH
80479: LD_VAR 0 23
80483: PUSH
80484: LD_VAR 0 24
80488: PUSH
80489: LD_VAR 0 25
80493: PUSH
80494: LD_VAR 0 26
80498: PUSH
80499: LD_VAR 0 27
80503: PUSH
80504: LD_VAR 0 28
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: LIST
80513: LIST
80514: LIST
80515: LIST
80516: PUSH
80517: LD_VAR 0 4
80521: PUSH
80522: LD_INT 1
80524: PLUS
80525: ARRAY
80526: ST_TO_ADDR
80527: GO 80530
80529: POP
80530: GO 81085
80532: LD_INT 2
80534: DOUBLE
80535: EQUAL
80536: IFTRUE 80546
80538: LD_INT 3
80540: DOUBLE
80541: EQUAL
80542: IFTRUE 80546
80544: GO 80602
80546: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80547: LD_ADDR_VAR 0 9
80551: PUSH
80552: LD_VAR 0 29
80556: PUSH
80557: LD_VAR 0 30
80561: PUSH
80562: LD_VAR 0 31
80566: PUSH
80567: LD_VAR 0 32
80571: PUSH
80572: LD_VAR 0 33
80576: PUSH
80577: LD_VAR 0 34
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: PUSH
80590: LD_VAR 0 4
80594: PUSH
80595: LD_INT 1
80597: PLUS
80598: ARRAY
80599: ST_TO_ADDR
80600: GO 81085
80602: LD_INT 16
80604: DOUBLE
80605: EQUAL
80606: IFTRUE 80664
80608: LD_INT 17
80610: DOUBLE
80611: EQUAL
80612: IFTRUE 80664
80614: LD_INT 18
80616: DOUBLE
80617: EQUAL
80618: IFTRUE 80664
80620: LD_INT 19
80622: DOUBLE
80623: EQUAL
80624: IFTRUE 80664
80626: LD_INT 22
80628: DOUBLE
80629: EQUAL
80630: IFTRUE 80664
80632: LD_INT 20
80634: DOUBLE
80635: EQUAL
80636: IFTRUE 80664
80638: LD_INT 21
80640: DOUBLE
80641: EQUAL
80642: IFTRUE 80664
80644: LD_INT 23
80646: DOUBLE
80647: EQUAL
80648: IFTRUE 80664
80650: LD_INT 24
80652: DOUBLE
80653: EQUAL
80654: IFTRUE 80664
80656: LD_INT 25
80658: DOUBLE
80659: EQUAL
80660: IFTRUE 80664
80662: GO 80720
80664: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80665: LD_ADDR_VAR 0 9
80669: PUSH
80670: LD_VAR 0 35
80674: PUSH
80675: LD_VAR 0 36
80679: PUSH
80680: LD_VAR 0 37
80684: PUSH
80685: LD_VAR 0 38
80689: PUSH
80690: LD_VAR 0 39
80694: PUSH
80695: LD_VAR 0 40
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: PUSH
80708: LD_VAR 0 4
80712: PUSH
80713: LD_INT 1
80715: PLUS
80716: ARRAY
80717: ST_TO_ADDR
80718: GO 81085
80720: LD_INT 6
80722: DOUBLE
80723: EQUAL
80724: IFTRUE 80776
80726: LD_INT 7
80728: DOUBLE
80729: EQUAL
80730: IFTRUE 80776
80732: LD_INT 8
80734: DOUBLE
80735: EQUAL
80736: IFTRUE 80776
80738: LD_INT 13
80740: DOUBLE
80741: EQUAL
80742: IFTRUE 80776
80744: LD_INT 12
80746: DOUBLE
80747: EQUAL
80748: IFTRUE 80776
80750: LD_INT 15
80752: DOUBLE
80753: EQUAL
80754: IFTRUE 80776
80756: LD_INT 11
80758: DOUBLE
80759: EQUAL
80760: IFTRUE 80776
80762: LD_INT 14
80764: DOUBLE
80765: EQUAL
80766: IFTRUE 80776
80768: LD_INT 10
80770: DOUBLE
80771: EQUAL
80772: IFTRUE 80776
80774: GO 80832
80776: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80777: LD_ADDR_VAR 0 9
80781: PUSH
80782: LD_VAR 0 41
80786: PUSH
80787: LD_VAR 0 42
80791: PUSH
80792: LD_VAR 0 43
80796: PUSH
80797: LD_VAR 0 44
80801: PUSH
80802: LD_VAR 0 45
80806: PUSH
80807: LD_VAR 0 46
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: PUSH
80820: LD_VAR 0 4
80824: PUSH
80825: LD_INT 1
80827: PLUS
80828: ARRAY
80829: ST_TO_ADDR
80830: GO 81085
80832: LD_INT 36
80834: DOUBLE
80835: EQUAL
80836: IFTRUE 80840
80838: GO 80896
80840: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80841: LD_ADDR_VAR 0 9
80845: PUSH
80846: LD_VAR 0 47
80850: PUSH
80851: LD_VAR 0 48
80855: PUSH
80856: LD_VAR 0 49
80860: PUSH
80861: LD_VAR 0 50
80865: PUSH
80866: LD_VAR 0 51
80870: PUSH
80871: LD_VAR 0 52
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: PUSH
80884: LD_VAR 0 4
80888: PUSH
80889: LD_INT 1
80891: PLUS
80892: ARRAY
80893: ST_TO_ADDR
80894: GO 81085
80896: LD_INT 4
80898: DOUBLE
80899: EQUAL
80900: IFTRUE 80922
80902: LD_INT 5
80904: DOUBLE
80905: EQUAL
80906: IFTRUE 80922
80908: LD_INT 34
80910: DOUBLE
80911: EQUAL
80912: IFTRUE 80922
80914: LD_INT 37
80916: DOUBLE
80917: EQUAL
80918: IFTRUE 80922
80920: GO 80978
80922: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80923: LD_ADDR_VAR 0 9
80927: PUSH
80928: LD_VAR 0 53
80932: PUSH
80933: LD_VAR 0 54
80937: PUSH
80938: LD_VAR 0 55
80942: PUSH
80943: LD_VAR 0 56
80947: PUSH
80948: LD_VAR 0 57
80952: PUSH
80953: LD_VAR 0 58
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: PUSH
80966: LD_VAR 0 4
80970: PUSH
80971: LD_INT 1
80973: PLUS
80974: ARRAY
80975: ST_TO_ADDR
80976: GO 81085
80978: LD_INT 31
80980: DOUBLE
80981: EQUAL
80982: IFTRUE 81028
80984: LD_INT 32
80986: DOUBLE
80987: EQUAL
80988: IFTRUE 81028
80990: LD_INT 33
80992: DOUBLE
80993: EQUAL
80994: IFTRUE 81028
80996: LD_INT 27
80998: DOUBLE
80999: EQUAL
81000: IFTRUE 81028
81002: LD_INT 26
81004: DOUBLE
81005: EQUAL
81006: IFTRUE 81028
81008: LD_INT 28
81010: DOUBLE
81011: EQUAL
81012: IFTRUE 81028
81014: LD_INT 29
81016: DOUBLE
81017: EQUAL
81018: IFTRUE 81028
81020: LD_INT 30
81022: DOUBLE
81023: EQUAL
81024: IFTRUE 81028
81026: GO 81084
81028: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81029: LD_ADDR_VAR 0 9
81033: PUSH
81034: LD_VAR 0 59
81038: PUSH
81039: LD_VAR 0 60
81043: PUSH
81044: LD_VAR 0 61
81048: PUSH
81049: LD_VAR 0 62
81053: PUSH
81054: LD_VAR 0 63
81058: PUSH
81059: LD_VAR 0 64
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: PUSH
81072: LD_VAR 0 4
81076: PUSH
81077: LD_INT 1
81079: PLUS
81080: ARRAY
81081: ST_TO_ADDR
81082: GO 81085
81084: POP
// temp_list2 = [ ] ;
81085: LD_ADDR_VAR 0 10
81089: PUSH
81090: EMPTY
81091: ST_TO_ADDR
// for i in temp_list do
81092: LD_ADDR_VAR 0 8
81096: PUSH
81097: LD_VAR 0 9
81101: PUSH
81102: FOR_IN
81103: IFFALSE 81155
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81105: LD_ADDR_VAR 0 10
81109: PUSH
81110: LD_VAR 0 10
81114: PUSH
81115: LD_VAR 0 8
81119: PUSH
81120: LD_INT 1
81122: ARRAY
81123: PUSH
81124: LD_VAR 0 2
81128: PLUS
81129: PUSH
81130: LD_VAR 0 8
81134: PUSH
81135: LD_INT 2
81137: ARRAY
81138: PUSH
81139: LD_VAR 0 3
81143: PLUS
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: EMPTY
81150: LIST
81151: ADD
81152: ST_TO_ADDR
81153: GO 81102
81155: POP
81156: POP
// result = temp_list2 ;
81157: LD_ADDR_VAR 0 7
81161: PUSH
81162: LD_VAR 0 10
81166: ST_TO_ADDR
// end ;
81167: LD_VAR 0 7
81171: RET
// export function EnemyInRange ( unit , dist ) ; begin
81172: LD_INT 0
81174: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81175: LD_ADDR_VAR 0 3
81179: PUSH
81180: LD_VAR 0 1
81184: PPUSH
81185: CALL_OW 255
81189: PPUSH
81190: LD_VAR 0 1
81194: PPUSH
81195: CALL_OW 250
81199: PPUSH
81200: LD_VAR 0 1
81204: PPUSH
81205: CALL_OW 251
81209: PPUSH
81210: LD_VAR 0 2
81214: PPUSH
81215: CALL 54574 0 4
81219: PUSH
81220: LD_INT 4
81222: ARRAY
81223: ST_TO_ADDR
// end ;
81224: LD_VAR 0 3
81228: RET
// export function PlayerSeeMe ( unit ) ; begin
81229: LD_INT 0
81231: PPUSH
// result := See ( your_side , unit ) ;
81232: LD_ADDR_VAR 0 2
81236: PUSH
81237: LD_OWVAR 2
81241: PPUSH
81242: LD_VAR 0 1
81246: PPUSH
81247: CALL_OW 292
81251: ST_TO_ADDR
// end ;
81252: LD_VAR 0 2
81256: RET
// export function ReverseDir ( unit ) ; begin
81257: LD_INT 0
81259: PPUSH
// if not unit then
81260: LD_VAR 0 1
81264: NOT
81265: IFFALSE 81269
// exit ;
81267: GO 81292
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81269: LD_ADDR_VAR 0 2
81273: PUSH
81274: LD_VAR 0 1
81278: PPUSH
81279: CALL_OW 254
81283: PUSH
81284: LD_INT 3
81286: PLUS
81287: PUSH
81288: LD_INT 6
81290: MOD
81291: ST_TO_ADDR
// end ;
81292: LD_VAR 0 2
81296: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81297: LD_INT 0
81299: PPUSH
81300: PPUSH
81301: PPUSH
81302: PPUSH
81303: PPUSH
81304: PPUSH
// if not unit or not hexes then
81305: LD_VAR 0 1
81309: NOT
81310: PUSH
81311: LD_VAR 0 2
81315: NOT
81316: OR
81317: IFFALSE 81321
// exit ;
81319: GO 81444
// dist := 9999 ;
81321: LD_ADDR_VAR 0 5
81325: PUSH
81326: LD_INT 9999
81328: ST_TO_ADDR
// for i = 1 to hexes do
81329: LD_ADDR_VAR 0 4
81333: PUSH
81334: DOUBLE
81335: LD_INT 1
81337: DEC
81338: ST_TO_ADDR
81339: LD_VAR 0 2
81343: PUSH
81344: FOR_TO
81345: IFFALSE 81432
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81347: LD_ADDR_VAR 0 6
81351: PUSH
81352: LD_VAR 0 1
81356: PPUSH
81357: LD_VAR 0 2
81361: PUSH
81362: LD_VAR 0 4
81366: ARRAY
81367: PUSH
81368: LD_INT 1
81370: ARRAY
81371: PPUSH
81372: LD_VAR 0 2
81376: PUSH
81377: LD_VAR 0 4
81381: ARRAY
81382: PUSH
81383: LD_INT 2
81385: ARRAY
81386: PPUSH
81387: CALL_OW 297
81391: ST_TO_ADDR
// if tdist < dist then
81392: LD_VAR 0 6
81396: PUSH
81397: LD_VAR 0 5
81401: LESS
81402: IFFALSE 81430
// begin hex := hexes [ i ] ;
81404: LD_ADDR_VAR 0 8
81408: PUSH
81409: LD_VAR 0 2
81413: PUSH
81414: LD_VAR 0 4
81418: ARRAY
81419: ST_TO_ADDR
// dist := tdist ;
81420: LD_ADDR_VAR 0 5
81424: PUSH
81425: LD_VAR 0 6
81429: ST_TO_ADDR
// end ; end ;
81430: GO 81344
81432: POP
81433: POP
// result := hex ;
81434: LD_ADDR_VAR 0 3
81438: PUSH
81439: LD_VAR 0 8
81443: ST_TO_ADDR
// end ;
81444: LD_VAR 0 3
81448: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81449: LD_INT 0
81451: PPUSH
81452: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81453: LD_VAR 0 1
81457: NOT
81458: PUSH
81459: LD_VAR 0 1
81463: PUSH
81464: LD_INT 21
81466: PUSH
81467: LD_INT 2
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 23
81476: PUSH
81477: LD_INT 2
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PPUSH
81488: CALL_OW 69
81492: IN
81493: NOT
81494: OR
81495: IFFALSE 81499
// exit ;
81497: GO 81546
// for i = 1 to 3 do
81499: LD_ADDR_VAR 0 3
81503: PUSH
81504: DOUBLE
81505: LD_INT 1
81507: DEC
81508: ST_TO_ADDR
81509: LD_INT 3
81511: PUSH
81512: FOR_TO
81513: IFFALSE 81544
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81515: LD_VAR 0 1
81519: PPUSH
81520: CALL_OW 250
81524: PPUSH
81525: LD_VAR 0 1
81529: PPUSH
81530: CALL_OW 251
81534: PPUSH
81535: LD_INT 1
81537: PPUSH
81538: CALL_OW 453
81542: GO 81512
81544: POP
81545: POP
// end ;
81546: LD_VAR 0 2
81550: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81551: LD_INT 0
81553: PPUSH
81554: PPUSH
81555: PPUSH
81556: PPUSH
81557: PPUSH
81558: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81559: LD_VAR 0 1
81563: NOT
81564: PUSH
81565: LD_VAR 0 2
81569: NOT
81570: OR
81571: PUSH
81572: LD_VAR 0 1
81576: PPUSH
81577: CALL_OW 314
81581: OR
81582: IFFALSE 81586
// exit ;
81584: GO 82027
// x := GetX ( enemy_unit ) ;
81586: LD_ADDR_VAR 0 7
81590: PUSH
81591: LD_VAR 0 2
81595: PPUSH
81596: CALL_OW 250
81600: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81601: LD_ADDR_VAR 0 8
81605: PUSH
81606: LD_VAR 0 2
81610: PPUSH
81611: CALL_OW 251
81615: ST_TO_ADDR
// if not x or not y then
81616: LD_VAR 0 7
81620: NOT
81621: PUSH
81622: LD_VAR 0 8
81626: NOT
81627: OR
81628: IFFALSE 81632
// exit ;
81630: GO 82027
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81632: LD_ADDR_VAR 0 6
81636: PUSH
81637: LD_VAR 0 7
81641: PPUSH
81642: LD_INT 0
81644: PPUSH
81645: LD_INT 4
81647: PPUSH
81648: CALL_OW 272
81652: PUSH
81653: LD_VAR 0 8
81657: PPUSH
81658: LD_INT 0
81660: PPUSH
81661: LD_INT 4
81663: PPUSH
81664: CALL_OW 273
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_VAR 0 7
81677: PPUSH
81678: LD_INT 1
81680: PPUSH
81681: LD_INT 4
81683: PPUSH
81684: CALL_OW 272
81688: PUSH
81689: LD_VAR 0 8
81693: PPUSH
81694: LD_INT 1
81696: PPUSH
81697: LD_INT 4
81699: PPUSH
81700: CALL_OW 273
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_VAR 0 7
81713: PPUSH
81714: LD_INT 2
81716: PPUSH
81717: LD_INT 4
81719: PPUSH
81720: CALL_OW 272
81724: PUSH
81725: LD_VAR 0 8
81729: PPUSH
81730: LD_INT 2
81732: PPUSH
81733: LD_INT 4
81735: PPUSH
81736: CALL_OW 273
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_VAR 0 7
81749: PPUSH
81750: LD_INT 3
81752: PPUSH
81753: LD_INT 4
81755: PPUSH
81756: CALL_OW 272
81760: PUSH
81761: LD_VAR 0 8
81765: PPUSH
81766: LD_INT 3
81768: PPUSH
81769: LD_INT 4
81771: PPUSH
81772: CALL_OW 273
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_VAR 0 7
81785: PPUSH
81786: LD_INT 4
81788: PPUSH
81789: LD_INT 4
81791: PPUSH
81792: CALL_OW 272
81796: PUSH
81797: LD_VAR 0 8
81801: PPUSH
81802: LD_INT 4
81804: PPUSH
81805: LD_INT 4
81807: PPUSH
81808: CALL_OW 273
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_VAR 0 7
81821: PPUSH
81822: LD_INT 5
81824: PPUSH
81825: LD_INT 4
81827: PPUSH
81828: CALL_OW 272
81832: PUSH
81833: LD_VAR 0 8
81837: PPUSH
81838: LD_INT 5
81840: PPUSH
81841: LD_INT 4
81843: PPUSH
81844: CALL_OW 273
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: ST_TO_ADDR
// for i = tmp downto 1 do
81861: LD_ADDR_VAR 0 4
81865: PUSH
81866: DOUBLE
81867: LD_VAR 0 6
81871: INC
81872: ST_TO_ADDR
81873: LD_INT 1
81875: PUSH
81876: FOR_DOWNTO
81877: IFFALSE 81978
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81879: LD_VAR 0 6
81883: PUSH
81884: LD_VAR 0 4
81888: ARRAY
81889: PUSH
81890: LD_INT 1
81892: ARRAY
81893: PPUSH
81894: LD_VAR 0 6
81898: PUSH
81899: LD_VAR 0 4
81903: ARRAY
81904: PUSH
81905: LD_INT 2
81907: ARRAY
81908: PPUSH
81909: CALL_OW 488
81913: NOT
81914: PUSH
81915: LD_VAR 0 6
81919: PUSH
81920: LD_VAR 0 4
81924: ARRAY
81925: PUSH
81926: LD_INT 1
81928: ARRAY
81929: PPUSH
81930: LD_VAR 0 6
81934: PUSH
81935: LD_VAR 0 4
81939: ARRAY
81940: PUSH
81941: LD_INT 2
81943: ARRAY
81944: PPUSH
81945: CALL_OW 428
81949: PUSH
81950: LD_INT 0
81952: NONEQUAL
81953: OR
81954: IFFALSE 81976
// tmp := Delete ( tmp , i ) ;
81956: LD_ADDR_VAR 0 6
81960: PUSH
81961: LD_VAR 0 6
81965: PPUSH
81966: LD_VAR 0 4
81970: PPUSH
81971: CALL_OW 3
81975: ST_TO_ADDR
81976: GO 81876
81978: POP
81979: POP
// j := GetClosestHex ( unit , tmp ) ;
81980: LD_ADDR_VAR 0 5
81984: PUSH
81985: LD_VAR 0 1
81989: PPUSH
81990: LD_VAR 0 6
81994: PPUSH
81995: CALL 81297 0 2
81999: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82000: LD_VAR 0 1
82004: PPUSH
82005: LD_VAR 0 5
82009: PUSH
82010: LD_INT 1
82012: ARRAY
82013: PPUSH
82014: LD_VAR 0 5
82018: PUSH
82019: LD_INT 2
82021: ARRAY
82022: PPUSH
82023: CALL_OW 111
// end ;
82027: LD_VAR 0 3
82031: RET
// export function PrepareApemanSoldier ( ) ; begin
82032: LD_INT 0
82034: PPUSH
// uc_nation := 0 ;
82035: LD_ADDR_OWVAR 21
82039: PUSH
82040: LD_INT 0
82042: ST_TO_ADDR
// hc_sex := sex_male ;
82043: LD_ADDR_OWVAR 27
82047: PUSH
82048: LD_INT 1
82050: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82051: LD_ADDR_OWVAR 28
82055: PUSH
82056: LD_INT 15
82058: ST_TO_ADDR
// hc_gallery :=  ;
82059: LD_ADDR_OWVAR 33
82063: PUSH
82064: LD_STRING 
82066: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82067: LD_ADDR_OWVAR 31
82071: PUSH
82072: LD_INT 0
82074: PPUSH
82075: LD_INT 3
82077: PPUSH
82078: CALL_OW 12
82082: PUSH
82083: LD_INT 0
82085: PPUSH
82086: LD_INT 3
82088: PPUSH
82089: CALL_OW 12
82093: PUSH
82094: LD_INT 0
82096: PUSH
82097: LD_INT 0
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: ST_TO_ADDR
// end ;
82106: LD_VAR 0 1
82110: RET
// export function PrepareApemanEngineer ( ) ; begin
82111: LD_INT 0
82113: PPUSH
// uc_nation := 0 ;
82114: LD_ADDR_OWVAR 21
82118: PUSH
82119: LD_INT 0
82121: ST_TO_ADDR
// hc_sex := sex_male ;
82122: LD_ADDR_OWVAR 27
82126: PUSH
82127: LD_INT 1
82129: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82130: LD_ADDR_OWVAR 28
82134: PUSH
82135: LD_INT 16
82137: ST_TO_ADDR
// hc_gallery :=  ;
82138: LD_ADDR_OWVAR 33
82142: PUSH
82143: LD_STRING 
82145: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82146: LD_ADDR_OWVAR 31
82150: PUSH
82151: LD_INT 0
82153: PPUSH
82154: LD_INT 3
82156: PPUSH
82157: CALL_OW 12
82161: PUSH
82162: LD_INT 0
82164: PPUSH
82165: LD_INT 3
82167: PPUSH
82168: CALL_OW 12
82172: PUSH
82173: LD_INT 0
82175: PUSH
82176: LD_INT 0
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: ST_TO_ADDR
// end ;
82185: LD_VAR 0 1
82189: RET
// export function PrepareApeman ( agressivity ) ; begin
82190: LD_INT 0
82192: PPUSH
// uc_side := 0 ;
82193: LD_ADDR_OWVAR 20
82197: PUSH
82198: LD_INT 0
82200: ST_TO_ADDR
// uc_nation := 0 ;
82201: LD_ADDR_OWVAR 21
82205: PUSH
82206: LD_INT 0
82208: ST_TO_ADDR
// hc_sex := sex_male ;
82209: LD_ADDR_OWVAR 27
82213: PUSH
82214: LD_INT 1
82216: ST_TO_ADDR
// hc_class := class_apeman ;
82217: LD_ADDR_OWVAR 28
82221: PUSH
82222: LD_INT 12
82224: ST_TO_ADDR
// hc_gallery :=  ;
82225: LD_ADDR_OWVAR 33
82229: PUSH
82230: LD_STRING 
82232: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82233: LD_ADDR_OWVAR 35
82237: PUSH
82238: LD_VAR 0 1
82242: NEG
82243: PPUSH
82244: LD_VAR 0 1
82248: PPUSH
82249: CALL_OW 12
82253: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82254: LD_ADDR_OWVAR 31
82258: PUSH
82259: LD_INT 0
82261: PPUSH
82262: LD_INT 3
82264: PPUSH
82265: CALL_OW 12
82269: PUSH
82270: LD_INT 0
82272: PPUSH
82273: LD_INT 3
82275: PPUSH
82276: CALL_OW 12
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: LD_INT 0
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: ST_TO_ADDR
// end ;
82293: LD_VAR 0 2
82297: RET
// export function PrepareTiger ( agressivity ) ; begin
82298: LD_INT 0
82300: PPUSH
// uc_side := 0 ;
82301: LD_ADDR_OWVAR 20
82305: PUSH
82306: LD_INT 0
82308: ST_TO_ADDR
// uc_nation := 0 ;
82309: LD_ADDR_OWVAR 21
82313: PUSH
82314: LD_INT 0
82316: ST_TO_ADDR
// hc_class := class_tiger ;
82317: LD_ADDR_OWVAR 28
82321: PUSH
82322: LD_INT 14
82324: ST_TO_ADDR
// hc_gallery :=  ;
82325: LD_ADDR_OWVAR 33
82329: PUSH
82330: LD_STRING 
82332: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82333: LD_ADDR_OWVAR 35
82337: PUSH
82338: LD_VAR 0 1
82342: NEG
82343: PPUSH
82344: LD_VAR 0 1
82348: PPUSH
82349: CALL_OW 12
82353: ST_TO_ADDR
// end ;
82354: LD_VAR 0 2
82358: RET
// export function PrepareEnchidna ( ) ; begin
82359: LD_INT 0
82361: PPUSH
// uc_side := 0 ;
82362: LD_ADDR_OWVAR 20
82366: PUSH
82367: LD_INT 0
82369: ST_TO_ADDR
// uc_nation := 0 ;
82370: LD_ADDR_OWVAR 21
82374: PUSH
82375: LD_INT 0
82377: ST_TO_ADDR
// hc_class := class_baggie ;
82378: LD_ADDR_OWVAR 28
82382: PUSH
82383: LD_INT 13
82385: ST_TO_ADDR
// hc_gallery :=  ;
82386: LD_ADDR_OWVAR 33
82390: PUSH
82391: LD_STRING 
82393: ST_TO_ADDR
// end ;
82394: LD_VAR 0 1
82398: RET
// export function PrepareFrog ( ) ; begin
82399: LD_INT 0
82401: PPUSH
// uc_side := 0 ;
82402: LD_ADDR_OWVAR 20
82406: PUSH
82407: LD_INT 0
82409: ST_TO_ADDR
// uc_nation := 0 ;
82410: LD_ADDR_OWVAR 21
82414: PUSH
82415: LD_INT 0
82417: ST_TO_ADDR
// hc_class := class_frog ;
82418: LD_ADDR_OWVAR 28
82422: PUSH
82423: LD_INT 19
82425: ST_TO_ADDR
// hc_gallery :=  ;
82426: LD_ADDR_OWVAR 33
82430: PUSH
82431: LD_STRING 
82433: ST_TO_ADDR
// end ;
82434: LD_VAR 0 1
82438: RET
// export function PrepareFish ( ) ; begin
82439: LD_INT 0
82441: PPUSH
// uc_side := 0 ;
82442: LD_ADDR_OWVAR 20
82446: PUSH
82447: LD_INT 0
82449: ST_TO_ADDR
// uc_nation := 0 ;
82450: LD_ADDR_OWVAR 21
82454: PUSH
82455: LD_INT 0
82457: ST_TO_ADDR
// hc_class := class_fish ;
82458: LD_ADDR_OWVAR 28
82462: PUSH
82463: LD_INT 20
82465: ST_TO_ADDR
// hc_gallery :=  ;
82466: LD_ADDR_OWVAR 33
82470: PUSH
82471: LD_STRING 
82473: ST_TO_ADDR
// end ;
82474: LD_VAR 0 1
82478: RET
// export function PrepareBird ( ) ; begin
82479: LD_INT 0
82481: PPUSH
// uc_side := 0 ;
82482: LD_ADDR_OWVAR 20
82486: PUSH
82487: LD_INT 0
82489: ST_TO_ADDR
// uc_nation := 0 ;
82490: LD_ADDR_OWVAR 21
82494: PUSH
82495: LD_INT 0
82497: ST_TO_ADDR
// hc_class := class_phororhacos ;
82498: LD_ADDR_OWVAR 28
82502: PUSH
82503: LD_INT 18
82505: ST_TO_ADDR
// hc_gallery :=  ;
82506: LD_ADDR_OWVAR 33
82510: PUSH
82511: LD_STRING 
82513: ST_TO_ADDR
// end ;
82514: LD_VAR 0 1
82518: RET
// export function PrepareHorse ( ) ; begin
82519: LD_INT 0
82521: PPUSH
// uc_side := 0 ;
82522: LD_ADDR_OWVAR 20
82526: PUSH
82527: LD_INT 0
82529: ST_TO_ADDR
// uc_nation := 0 ;
82530: LD_ADDR_OWVAR 21
82534: PUSH
82535: LD_INT 0
82537: ST_TO_ADDR
// hc_class := class_horse ;
82538: LD_ADDR_OWVAR 28
82542: PUSH
82543: LD_INT 21
82545: ST_TO_ADDR
// hc_gallery :=  ;
82546: LD_ADDR_OWVAR 33
82550: PUSH
82551: LD_STRING 
82553: ST_TO_ADDR
// end ;
82554: LD_VAR 0 1
82558: RET
// export function PrepareMastodont ( ) ; begin
82559: LD_INT 0
82561: PPUSH
// uc_side := 0 ;
82562: LD_ADDR_OWVAR 20
82566: PUSH
82567: LD_INT 0
82569: ST_TO_ADDR
// uc_nation := 0 ;
82570: LD_ADDR_OWVAR 21
82574: PUSH
82575: LD_INT 0
82577: ST_TO_ADDR
// vc_chassis := class_mastodont ;
82578: LD_ADDR_OWVAR 37
82582: PUSH
82583: LD_INT 31
82585: ST_TO_ADDR
// vc_control := control_rider ;
82586: LD_ADDR_OWVAR 38
82590: PUSH
82591: LD_INT 4
82593: ST_TO_ADDR
// end ;
82594: LD_VAR 0 1
82598: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82599: LD_INT 0
82601: PPUSH
82602: PPUSH
82603: PPUSH
// uc_side = 0 ;
82604: LD_ADDR_OWVAR 20
82608: PUSH
82609: LD_INT 0
82611: ST_TO_ADDR
// uc_nation = 0 ;
82612: LD_ADDR_OWVAR 21
82616: PUSH
82617: LD_INT 0
82619: ST_TO_ADDR
// InitHc_All ( ) ;
82620: CALL_OW 584
// InitVc ;
82624: CALL_OW 20
// if mastodonts then
82628: LD_VAR 0 6
82632: IFFALSE 82699
// for i = 1 to mastodonts do
82634: LD_ADDR_VAR 0 11
82638: PUSH
82639: DOUBLE
82640: LD_INT 1
82642: DEC
82643: ST_TO_ADDR
82644: LD_VAR 0 6
82648: PUSH
82649: FOR_TO
82650: IFFALSE 82697
// begin vc_chassis := 31 ;
82652: LD_ADDR_OWVAR 37
82656: PUSH
82657: LD_INT 31
82659: ST_TO_ADDR
// vc_control := control_rider ;
82660: LD_ADDR_OWVAR 38
82664: PUSH
82665: LD_INT 4
82667: ST_TO_ADDR
// animal := CreateVehicle ;
82668: LD_ADDR_VAR 0 12
82672: PUSH
82673: CALL_OW 45
82677: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82678: LD_VAR 0 12
82682: PPUSH
82683: LD_VAR 0 8
82687: PPUSH
82688: LD_INT 0
82690: PPUSH
82691: CALL 84834 0 3
// end ;
82695: GO 82649
82697: POP
82698: POP
// if horses then
82699: LD_VAR 0 5
82703: IFFALSE 82770
// for i = 1 to horses do
82705: LD_ADDR_VAR 0 11
82709: PUSH
82710: DOUBLE
82711: LD_INT 1
82713: DEC
82714: ST_TO_ADDR
82715: LD_VAR 0 5
82719: PUSH
82720: FOR_TO
82721: IFFALSE 82768
// begin hc_class := 21 ;
82723: LD_ADDR_OWVAR 28
82727: PUSH
82728: LD_INT 21
82730: ST_TO_ADDR
// hc_gallery :=  ;
82731: LD_ADDR_OWVAR 33
82735: PUSH
82736: LD_STRING 
82738: ST_TO_ADDR
// animal := CreateHuman ;
82739: LD_ADDR_VAR 0 12
82743: PUSH
82744: CALL_OW 44
82748: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82749: LD_VAR 0 12
82753: PPUSH
82754: LD_VAR 0 8
82758: PPUSH
82759: LD_INT 0
82761: PPUSH
82762: CALL 84834 0 3
// end ;
82766: GO 82720
82768: POP
82769: POP
// if birds then
82770: LD_VAR 0 1
82774: IFFALSE 82841
// for i = 1 to birds do
82776: LD_ADDR_VAR 0 11
82780: PUSH
82781: DOUBLE
82782: LD_INT 1
82784: DEC
82785: ST_TO_ADDR
82786: LD_VAR 0 1
82790: PUSH
82791: FOR_TO
82792: IFFALSE 82839
// begin hc_class = 18 ;
82794: LD_ADDR_OWVAR 28
82798: PUSH
82799: LD_INT 18
82801: ST_TO_ADDR
// hc_gallery =  ;
82802: LD_ADDR_OWVAR 33
82806: PUSH
82807: LD_STRING 
82809: ST_TO_ADDR
// animal := CreateHuman ;
82810: LD_ADDR_VAR 0 12
82814: PUSH
82815: CALL_OW 44
82819: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82820: LD_VAR 0 12
82824: PPUSH
82825: LD_VAR 0 8
82829: PPUSH
82830: LD_INT 0
82832: PPUSH
82833: CALL 84834 0 3
// end ;
82837: GO 82791
82839: POP
82840: POP
// if tigers then
82841: LD_VAR 0 2
82845: IFFALSE 82929
// for i = 1 to tigers do
82847: LD_ADDR_VAR 0 11
82851: PUSH
82852: DOUBLE
82853: LD_INT 1
82855: DEC
82856: ST_TO_ADDR
82857: LD_VAR 0 2
82861: PUSH
82862: FOR_TO
82863: IFFALSE 82927
// begin hc_class = class_tiger ;
82865: LD_ADDR_OWVAR 28
82869: PUSH
82870: LD_INT 14
82872: ST_TO_ADDR
// hc_gallery =  ;
82873: LD_ADDR_OWVAR 33
82877: PUSH
82878: LD_STRING 
82880: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82881: LD_ADDR_OWVAR 35
82885: PUSH
82886: LD_INT 7
82888: NEG
82889: PPUSH
82890: LD_INT 7
82892: PPUSH
82893: CALL_OW 12
82897: ST_TO_ADDR
// animal := CreateHuman ;
82898: LD_ADDR_VAR 0 12
82902: PUSH
82903: CALL_OW 44
82907: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82908: LD_VAR 0 12
82912: PPUSH
82913: LD_VAR 0 8
82917: PPUSH
82918: LD_INT 0
82920: PPUSH
82921: CALL 84834 0 3
// end ;
82925: GO 82862
82927: POP
82928: POP
// if apemans then
82929: LD_VAR 0 3
82933: IFFALSE 83056
// for i = 1 to apemans do
82935: LD_ADDR_VAR 0 11
82939: PUSH
82940: DOUBLE
82941: LD_INT 1
82943: DEC
82944: ST_TO_ADDR
82945: LD_VAR 0 3
82949: PUSH
82950: FOR_TO
82951: IFFALSE 83054
// begin hc_class = class_apeman ;
82953: LD_ADDR_OWVAR 28
82957: PUSH
82958: LD_INT 12
82960: ST_TO_ADDR
// hc_gallery =  ;
82961: LD_ADDR_OWVAR 33
82965: PUSH
82966: LD_STRING 
82968: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
82969: LD_ADDR_OWVAR 35
82973: PUSH
82974: LD_INT 2
82976: NEG
82977: PPUSH
82978: LD_INT 2
82980: PPUSH
82981: CALL_OW 12
82985: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82986: LD_ADDR_OWVAR 31
82990: PUSH
82991: LD_INT 1
82993: PPUSH
82994: LD_INT 3
82996: PPUSH
82997: CALL_OW 12
83001: PUSH
83002: LD_INT 1
83004: PPUSH
83005: LD_INT 3
83007: PPUSH
83008: CALL_OW 12
83012: PUSH
83013: LD_INT 0
83015: PUSH
83016: LD_INT 0
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: ST_TO_ADDR
// animal := CreateHuman ;
83025: LD_ADDR_VAR 0 12
83029: PUSH
83030: CALL_OW 44
83034: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83035: LD_VAR 0 12
83039: PPUSH
83040: LD_VAR 0 8
83044: PPUSH
83045: LD_INT 0
83047: PPUSH
83048: CALL 84834 0 3
// end ;
83052: GO 82950
83054: POP
83055: POP
// if enchidnas then
83056: LD_VAR 0 4
83060: IFFALSE 83127
// for i = 1 to enchidnas do
83062: LD_ADDR_VAR 0 11
83066: PUSH
83067: DOUBLE
83068: LD_INT 1
83070: DEC
83071: ST_TO_ADDR
83072: LD_VAR 0 4
83076: PUSH
83077: FOR_TO
83078: IFFALSE 83125
// begin hc_class = 13 ;
83080: LD_ADDR_OWVAR 28
83084: PUSH
83085: LD_INT 13
83087: ST_TO_ADDR
// hc_gallery =  ;
83088: LD_ADDR_OWVAR 33
83092: PUSH
83093: LD_STRING 
83095: ST_TO_ADDR
// animal := CreateHuman ;
83096: LD_ADDR_VAR 0 12
83100: PUSH
83101: CALL_OW 44
83105: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83106: LD_VAR 0 12
83110: PPUSH
83111: LD_VAR 0 8
83115: PPUSH
83116: LD_INT 0
83118: PPUSH
83119: CALL 84834 0 3
// end ;
83123: GO 83077
83125: POP
83126: POP
// if fishes then
83127: LD_VAR 0 7
83131: IFFALSE 83198
// for i = 1 to fishes do
83133: LD_ADDR_VAR 0 11
83137: PUSH
83138: DOUBLE
83139: LD_INT 1
83141: DEC
83142: ST_TO_ADDR
83143: LD_VAR 0 7
83147: PUSH
83148: FOR_TO
83149: IFFALSE 83196
// begin hc_class = 20 ;
83151: LD_ADDR_OWVAR 28
83155: PUSH
83156: LD_INT 20
83158: ST_TO_ADDR
// hc_gallery =  ;
83159: LD_ADDR_OWVAR 33
83163: PUSH
83164: LD_STRING 
83166: ST_TO_ADDR
// animal := CreateHuman ;
83167: LD_ADDR_VAR 0 12
83171: PUSH
83172: CALL_OW 44
83176: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83177: LD_VAR 0 12
83181: PPUSH
83182: LD_VAR 0 9
83186: PPUSH
83187: LD_INT 0
83189: PPUSH
83190: CALL 84834 0 3
// end ;
83194: GO 83148
83196: POP
83197: POP
// end ;
83198: LD_VAR 0 10
83202: RET
// export function WantHeal ( sci , unit ) ; begin
83203: LD_INT 0
83205: PPUSH
// if GetTaskList ( sci ) > 0 then
83206: LD_VAR 0 1
83210: PPUSH
83211: CALL_OW 437
83215: PUSH
83216: LD_INT 0
83218: GREATER
83219: IFFALSE 83289
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83221: LD_VAR 0 1
83225: PPUSH
83226: CALL_OW 437
83230: PUSH
83231: LD_INT 1
83233: ARRAY
83234: PUSH
83235: LD_INT 1
83237: ARRAY
83238: PUSH
83239: LD_STRING l
83241: EQUAL
83242: PUSH
83243: LD_VAR 0 1
83247: PPUSH
83248: CALL_OW 437
83252: PUSH
83253: LD_INT 1
83255: ARRAY
83256: PUSH
83257: LD_INT 4
83259: ARRAY
83260: PUSH
83261: LD_VAR 0 2
83265: EQUAL
83266: AND
83267: IFFALSE 83279
// result := true else
83269: LD_ADDR_VAR 0 3
83273: PUSH
83274: LD_INT 1
83276: ST_TO_ADDR
83277: GO 83287
// result := false ;
83279: LD_ADDR_VAR 0 3
83283: PUSH
83284: LD_INT 0
83286: ST_TO_ADDR
// end else
83287: GO 83297
// result := false ;
83289: LD_ADDR_VAR 0 3
83293: PUSH
83294: LD_INT 0
83296: ST_TO_ADDR
// end ;
83297: LD_VAR 0 3
83301: RET
// export function HealTarget ( sci ) ; begin
83302: LD_INT 0
83304: PPUSH
// if not sci then
83305: LD_VAR 0 1
83309: NOT
83310: IFFALSE 83314
// exit ;
83312: GO 83379
// result := 0 ;
83314: LD_ADDR_VAR 0 2
83318: PUSH
83319: LD_INT 0
83321: ST_TO_ADDR
// if GetTaskList ( sci ) then
83322: LD_VAR 0 1
83326: PPUSH
83327: CALL_OW 437
83331: IFFALSE 83379
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83333: LD_VAR 0 1
83337: PPUSH
83338: CALL_OW 437
83342: PUSH
83343: LD_INT 1
83345: ARRAY
83346: PUSH
83347: LD_INT 1
83349: ARRAY
83350: PUSH
83351: LD_STRING l
83353: EQUAL
83354: IFFALSE 83379
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83356: LD_ADDR_VAR 0 2
83360: PUSH
83361: LD_VAR 0 1
83365: PPUSH
83366: CALL_OW 437
83370: PUSH
83371: LD_INT 1
83373: ARRAY
83374: PUSH
83375: LD_INT 4
83377: ARRAY
83378: ST_TO_ADDR
// end ;
83379: LD_VAR 0 2
83383: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83384: LD_INT 0
83386: PPUSH
83387: PPUSH
83388: PPUSH
83389: PPUSH
// if not base_units then
83390: LD_VAR 0 1
83394: NOT
83395: IFFALSE 83399
// exit ;
83397: GO 83486
// result := false ;
83399: LD_ADDR_VAR 0 2
83403: PUSH
83404: LD_INT 0
83406: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83407: LD_ADDR_VAR 0 5
83411: PUSH
83412: LD_VAR 0 1
83416: PPUSH
83417: LD_INT 21
83419: PUSH
83420: LD_INT 3
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PPUSH
83427: CALL_OW 72
83431: ST_TO_ADDR
// if not tmp then
83432: LD_VAR 0 5
83436: NOT
83437: IFFALSE 83441
// exit ;
83439: GO 83486
// for i in tmp do
83441: LD_ADDR_VAR 0 3
83445: PUSH
83446: LD_VAR 0 5
83450: PUSH
83451: FOR_IN
83452: IFFALSE 83484
// begin result := EnemyInRange ( i , 22 ) ;
83454: LD_ADDR_VAR 0 2
83458: PUSH
83459: LD_VAR 0 3
83463: PPUSH
83464: LD_INT 22
83466: PPUSH
83467: CALL 81172 0 2
83471: ST_TO_ADDR
// if result then
83472: LD_VAR 0 2
83476: IFFALSE 83482
// exit ;
83478: POP
83479: POP
83480: GO 83486
// end ;
83482: GO 83451
83484: POP
83485: POP
// end ;
83486: LD_VAR 0 2
83490: RET
// export function FilterByTag ( units , tag ) ; begin
83491: LD_INT 0
83493: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83494: LD_ADDR_VAR 0 3
83498: PUSH
83499: LD_VAR 0 1
83503: PPUSH
83504: LD_INT 120
83506: PUSH
83507: LD_VAR 0 2
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PPUSH
83516: CALL_OW 72
83520: ST_TO_ADDR
// end ;
83521: LD_VAR 0 3
83525: RET
// export function IsDriver ( un ) ; begin
83526: LD_INT 0
83528: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83529: LD_ADDR_VAR 0 2
83533: PUSH
83534: LD_VAR 0 1
83538: PUSH
83539: LD_INT 55
83541: PUSH
83542: EMPTY
83543: LIST
83544: PPUSH
83545: CALL_OW 69
83549: IN
83550: ST_TO_ADDR
// end ;
83551: LD_VAR 0 2
83555: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83556: LD_INT 0
83558: PPUSH
83559: PPUSH
// list := [ ] ;
83560: LD_ADDR_VAR 0 5
83564: PUSH
83565: EMPTY
83566: ST_TO_ADDR
// case d of 0 :
83567: LD_VAR 0 3
83571: PUSH
83572: LD_INT 0
83574: DOUBLE
83575: EQUAL
83576: IFTRUE 83580
83578: GO 83713
83580: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83581: LD_ADDR_VAR 0 5
83585: PUSH
83586: LD_VAR 0 1
83590: PUSH
83591: LD_INT 4
83593: MINUS
83594: PUSH
83595: LD_VAR 0 2
83599: PUSH
83600: LD_INT 4
83602: MINUS
83603: PUSH
83604: LD_INT 2
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: LIST
83611: PUSH
83612: LD_VAR 0 1
83616: PUSH
83617: LD_INT 3
83619: MINUS
83620: PUSH
83621: LD_VAR 0 2
83625: PUSH
83626: LD_INT 1
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: LIST
83633: PUSH
83634: LD_VAR 0 1
83638: PUSH
83639: LD_INT 4
83641: PLUS
83642: PUSH
83643: LD_VAR 0 2
83647: PUSH
83648: LD_INT 4
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: LIST
83655: PUSH
83656: LD_VAR 0 1
83660: PUSH
83661: LD_INT 3
83663: PLUS
83664: PUSH
83665: LD_VAR 0 2
83669: PUSH
83670: LD_INT 3
83672: PLUS
83673: PUSH
83674: LD_INT 5
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: LIST
83681: PUSH
83682: LD_VAR 0 1
83686: PUSH
83687: LD_VAR 0 2
83691: PUSH
83692: LD_INT 4
83694: PLUS
83695: PUSH
83696: LD_INT 0
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: LIST
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: ST_TO_ADDR
// end ; 1 :
83711: GO 84411
83713: LD_INT 1
83715: DOUBLE
83716: EQUAL
83717: IFTRUE 83721
83719: GO 83854
83721: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83722: LD_ADDR_VAR 0 5
83726: PUSH
83727: LD_VAR 0 1
83731: PUSH
83732: LD_VAR 0 2
83736: PUSH
83737: LD_INT 4
83739: MINUS
83740: PUSH
83741: LD_INT 3
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: LIST
83748: PUSH
83749: LD_VAR 0 1
83753: PUSH
83754: LD_INT 3
83756: MINUS
83757: PUSH
83758: LD_VAR 0 2
83762: PUSH
83763: LD_INT 3
83765: MINUS
83766: PUSH
83767: LD_INT 2
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: LIST
83774: PUSH
83775: LD_VAR 0 1
83779: PUSH
83780: LD_INT 4
83782: MINUS
83783: PUSH
83784: LD_VAR 0 2
83788: PUSH
83789: LD_INT 1
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: LIST
83796: PUSH
83797: LD_VAR 0 1
83801: PUSH
83802: LD_VAR 0 2
83806: PUSH
83807: LD_INT 3
83809: PLUS
83810: PUSH
83811: LD_INT 0
83813: PUSH
83814: EMPTY
83815: LIST
83816: LIST
83817: LIST
83818: PUSH
83819: LD_VAR 0 1
83823: PUSH
83824: LD_INT 4
83826: PLUS
83827: PUSH
83828: LD_VAR 0 2
83832: PUSH
83833: LD_INT 4
83835: PLUS
83836: PUSH
83837: LD_INT 5
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: LIST
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: ST_TO_ADDR
// end ; 2 :
83852: GO 84411
83854: LD_INT 2
83856: DOUBLE
83857: EQUAL
83858: IFTRUE 83862
83860: GO 83991
83862: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83863: LD_ADDR_VAR 0 5
83867: PUSH
83868: LD_VAR 0 1
83872: PUSH
83873: LD_VAR 0 2
83877: PUSH
83878: LD_INT 3
83880: MINUS
83881: PUSH
83882: LD_INT 3
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: LIST
83889: PUSH
83890: LD_VAR 0 1
83894: PUSH
83895: LD_INT 4
83897: PLUS
83898: PUSH
83899: LD_VAR 0 2
83903: PUSH
83904: LD_INT 4
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: LIST
83911: PUSH
83912: LD_VAR 0 1
83916: PUSH
83917: LD_VAR 0 2
83921: PUSH
83922: LD_INT 4
83924: PLUS
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: LIST
83933: PUSH
83934: LD_VAR 0 1
83938: PUSH
83939: LD_INT 3
83941: MINUS
83942: PUSH
83943: LD_VAR 0 2
83947: PUSH
83948: LD_INT 1
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: LIST
83955: PUSH
83956: LD_VAR 0 1
83960: PUSH
83961: LD_INT 4
83963: MINUS
83964: PUSH
83965: LD_VAR 0 2
83969: PUSH
83970: LD_INT 4
83972: MINUS
83973: PUSH
83974: LD_INT 2
83976: PUSH
83977: EMPTY
83978: LIST
83979: LIST
83980: LIST
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: ST_TO_ADDR
// end ; 3 :
83989: GO 84411
83991: LD_INT 3
83993: DOUBLE
83994: EQUAL
83995: IFTRUE 83999
83997: GO 84132
83999: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84000: LD_ADDR_VAR 0 5
84004: PUSH
84005: LD_VAR 0 1
84009: PUSH
84010: LD_INT 3
84012: PLUS
84013: PUSH
84014: LD_VAR 0 2
84018: PUSH
84019: LD_INT 4
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: LIST
84026: PUSH
84027: LD_VAR 0 1
84031: PUSH
84032: LD_INT 4
84034: PLUS
84035: PUSH
84036: LD_VAR 0 2
84040: PUSH
84041: LD_INT 4
84043: PLUS
84044: PUSH
84045: LD_INT 5
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: LIST
84052: PUSH
84053: LD_VAR 0 1
84057: PUSH
84058: LD_INT 4
84060: MINUS
84061: PUSH
84062: LD_VAR 0 2
84066: PUSH
84067: LD_INT 1
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: LIST
84074: PUSH
84075: LD_VAR 0 1
84079: PUSH
84080: LD_VAR 0 2
84084: PUSH
84085: LD_INT 4
84087: MINUS
84088: PUSH
84089: LD_INT 3
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: LIST
84096: PUSH
84097: LD_VAR 0 1
84101: PUSH
84102: LD_INT 3
84104: MINUS
84105: PUSH
84106: LD_VAR 0 2
84110: PUSH
84111: LD_INT 3
84113: MINUS
84114: PUSH
84115: LD_INT 2
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: LIST
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: ST_TO_ADDR
// end ; 4 :
84130: GO 84411
84132: LD_INT 4
84134: DOUBLE
84135: EQUAL
84136: IFTRUE 84140
84138: GO 84273
84140: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84141: LD_ADDR_VAR 0 5
84145: PUSH
84146: LD_VAR 0 1
84150: PUSH
84151: LD_VAR 0 2
84155: PUSH
84156: LD_INT 4
84158: PLUS
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: LIST
84167: PUSH
84168: LD_VAR 0 1
84172: PUSH
84173: LD_INT 3
84175: PLUS
84176: PUSH
84177: LD_VAR 0 2
84181: PUSH
84182: LD_INT 3
84184: PLUS
84185: PUSH
84186: LD_INT 5
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: LIST
84193: PUSH
84194: LD_VAR 0 1
84198: PUSH
84199: LD_INT 4
84201: PLUS
84202: PUSH
84203: LD_VAR 0 2
84207: PUSH
84208: LD_INT 4
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: LIST
84215: PUSH
84216: LD_VAR 0 1
84220: PUSH
84221: LD_VAR 0 2
84225: PUSH
84226: LD_INT 3
84228: MINUS
84229: PUSH
84230: LD_INT 3
84232: PUSH
84233: EMPTY
84234: LIST
84235: LIST
84236: LIST
84237: PUSH
84238: LD_VAR 0 1
84242: PUSH
84243: LD_INT 4
84245: MINUS
84246: PUSH
84247: LD_VAR 0 2
84251: PUSH
84252: LD_INT 4
84254: MINUS
84255: PUSH
84256: LD_INT 2
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: LIST
84263: PUSH
84264: EMPTY
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: ST_TO_ADDR
// end ; 5 :
84271: GO 84411
84273: LD_INT 5
84275: DOUBLE
84276: EQUAL
84277: IFTRUE 84281
84279: GO 84410
84281: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84282: LD_ADDR_VAR 0 5
84286: PUSH
84287: LD_VAR 0 1
84291: PUSH
84292: LD_INT 4
84294: MINUS
84295: PUSH
84296: LD_VAR 0 2
84300: PUSH
84301: LD_INT 1
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: LIST
84308: PUSH
84309: LD_VAR 0 1
84313: PUSH
84314: LD_VAR 0 2
84318: PUSH
84319: LD_INT 4
84321: MINUS
84322: PUSH
84323: LD_INT 3
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: LIST
84330: PUSH
84331: LD_VAR 0 1
84335: PUSH
84336: LD_INT 4
84338: PLUS
84339: PUSH
84340: LD_VAR 0 2
84344: PUSH
84345: LD_INT 4
84347: PLUS
84348: PUSH
84349: LD_INT 5
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: LIST
84356: PUSH
84357: LD_VAR 0 1
84361: PUSH
84362: LD_INT 3
84364: PLUS
84365: PUSH
84366: LD_VAR 0 2
84370: PUSH
84371: LD_INT 4
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: LIST
84378: PUSH
84379: LD_VAR 0 1
84383: PUSH
84384: LD_VAR 0 2
84388: PUSH
84389: LD_INT 3
84391: PLUS
84392: PUSH
84393: LD_INT 0
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: LIST
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: ST_TO_ADDR
// end ; end ;
84408: GO 84411
84410: POP
// result := list ;
84411: LD_ADDR_VAR 0 4
84415: PUSH
84416: LD_VAR 0 5
84420: ST_TO_ADDR
// end ;
84421: LD_VAR 0 4
84425: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84426: LD_INT 0
84428: PPUSH
84429: PPUSH
84430: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84431: LD_VAR 0 1
84435: NOT
84436: PUSH
84437: LD_VAR 0 2
84441: PUSH
84442: LD_INT 1
84444: PUSH
84445: LD_INT 2
84447: PUSH
84448: LD_INT 3
84450: PUSH
84451: LD_INT 4
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: IN
84460: NOT
84461: OR
84462: IFFALSE 84466
// exit ;
84464: GO 84558
// tmp := [ ] ;
84466: LD_ADDR_VAR 0 5
84470: PUSH
84471: EMPTY
84472: ST_TO_ADDR
// for i in units do
84473: LD_ADDR_VAR 0 4
84477: PUSH
84478: LD_VAR 0 1
84482: PUSH
84483: FOR_IN
84484: IFFALSE 84527
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
84486: LD_ADDR_VAR 0 5
84490: PUSH
84491: LD_VAR 0 5
84495: PPUSH
84496: LD_VAR 0 5
84500: PUSH
84501: LD_INT 1
84503: PLUS
84504: PPUSH
84505: LD_VAR 0 4
84509: PPUSH
84510: LD_VAR 0 2
84514: PPUSH
84515: CALL_OW 259
84519: PPUSH
84520: CALL_OW 2
84524: ST_TO_ADDR
84525: GO 84483
84527: POP
84528: POP
// if not tmp then
84529: LD_VAR 0 5
84533: NOT
84534: IFFALSE 84538
// exit ;
84536: GO 84558
// result := SortListByListDesc ( units , tmp ) ;
84538: LD_ADDR_VAR 0 3
84542: PUSH
84543: LD_VAR 0 1
84547: PPUSH
84548: LD_VAR 0 5
84552: PPUSH
84553: CALL_OW 77
84557: ST_TO_ADDR
// end ;
84558: LD_VAR 0 3
84562: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84563: LD_INT 0
84565: PPUSH
84566: PPUSH
84567: PPUSH
// result := false ;
84568: LD_ADDR_VAR 0 3
84572: PUSH
84573: LD_INT 0
84575: ST_TO_ADDR
// x := GetX ( building ) ;
84576: LD_ADDR_VAR 0 4
84580: PUSH
84581: LD_VAR 0 2
84585: PPUSH
84586: CALL_OW 250
84590: ST_TO_ADDR
// y := GetY ( building ) ;
84591: LD_ADDR_VAR 0 5
84595: PUSH
84596: LD_VAR 0 2
84600: PPUSH
84601: CALL_OW 251
84605: ST_TO_ADDR
// if not building or not x or not y then
84606: LD_VAR 0 2
84610: NOT
84611: PUSH
84612: LD_VAR 0 4
84616: NOT
84617: OR
84618: PUSH
84619: LD_VAR 0 5
84623: NOT
84624: OR
84625: IFFALSE 84629
// exit ;
84627: GO 84721
// if GetTaskList ( unit ) then
84629: LD_VAR 0 1
84633: PPUSH
84634: CALL_OW 437
84638: IFFALSE 84721
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84640: LD_STRING e
84642: PUSH
84643: LD_VAR 0 1
84647: PPUSH
84648: CALL_OW 437
84652: PUSH
84653: LD_INT 1
84655: ARRAY
84656: PUSH
84657: LD_INT 1
84659: ARRAY
84660: EQUAL
84661: PUSH
84662: LD_VAR 0 4
84666: PUSH
84667: LD_VAR 0 1
84671: PPUSH
84672: CALL_OW 437
84676: PUSH
84677: LD_INT 1
84679: ARRAY
84680: PUSH
84681: LD_INT 2
84683: ARRAY
84684: EQUAL
84685: AND
84686: PUSH
84687: LD_VAR 0 5
84691: PUSH
84692: LD_VAR 0 1
84696: PPUSH
84697: CALL_OW 437
84701: PUSH
84702: LD_INT 1
84704: ARRAY
84705: PUSH
84706: LD_INT 3
84708: ARRAY
84709: EQUAL
84710: AND
84711: IFFALSE 84721
// result := true end ;
84713: LD_ADDR_VAR 0 3
84717: PUSH
84718: LD_INT 1
84720: ST_TO_ADDR
// end ;
84721: LD_VAR 0 3
84725: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84726: LD_INT 0
84728: PPUSH
// result := false ;
84729: LD_ADDR_VAR 0 4
84733: PUSH
84734: LD_INT 0
84736: ST_TO_ADDR
// if GetTaskList ( unit ) then
84737: LD_VAR 0 1
84741: PPUSH
84742: CALL_OW 437
84746: IFFALSE 84829
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84748: LD_STRING M
84750: PUSH
84751: LD_VAR 0 1
84755: PPUSH
84756: CALL_OW 437
84760: PUSH
84761: LD_INT 1
84763: ARRAY
84764: PUSH
84765: LD_INT 1
84767: ARRAY
84768: EQUAL
84769: PUSH
84770: LD_VAR 0 2
84774: PUSH
84775: LD_VAR 0 1
84779: PPUSH
84780: CALL_OW 437
84784: PUSH
84785: LD_INT 1
84787: ARRAY
84788: PUSH
84789: LD_INT 2
84791: ARRAY
84792: EQUAL
84793: AND
84794: PUSH
84795: LD_VAR 0 3
84799: PUSH
84800: LD_VAR 0 1
84804: PPUSH
84805: CALL_OW 437
84809: PUSH
84810: LD_INT 1
84812: ARRAY
84813: PUSH
84814: LD_INT 3
84816: ARRAY
84817: EQUAL
84818: AND
84819: IFFALSE 84829
// result := true ;
84821: LD_ADDR_VAR 0 4
84825: PUSH
84826: LD_INT 1
84828: ST_TO_ADDR
// end ; end ;
84829: LD_VAR 0 4
84833: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84834: LD_INT 0
84836: PPUSH
84837: PPUSH
84838: PPUSH
84839: PPUSH
// if not unit or not area then
84840: LD_VAR 0 1
84844: NOT
84845: PUSH
84846: LD_VAR 0 2
84850: NOT
84851: OR
84852: IFFALSE 84856
// exit ;
84854: GO 85020
// tmp := AreaToList ( area , i ) ;
84856: LD_ADDR_VAR 0 6
84860: PUSH
84861: LD_VAR 0 2
84865: PPUSH
84866: LD_VAR 0 5
84870: PPUSH
84871: CALL_OW 517
84875: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84876: LD_ADDR_VAR 0 5
84880: PUSH
84881: DOUBLE
84882: LD_INT 1
84884: DEC
84885: ST_TO_ADDR
84886: LD_VAR 0 6
84890: PUSH
84891: LD_INT 1
84893: ARRAY
84894: PUSH
84895: FOR_TO
84896: IFFALSE 85018
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84898: LD_ADDR_VAR 0 7
84902: PUSH
84903: LD_VAR 0 6
84907: PUSH
84908: LD_INT 1
84910: ARRAY
84911: PUSH
84912: LD_VAR 0 5
84916: ARRAY
84917: PUSH
84918: LD_VAR 0 6
84922: PUSH
84923: LD_INT 2
84925: ARRAY
84926: PUSH
84927: LD_VAR 0 5
84931: ARRAY
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84937: LD_VAR 0 7
84941: PUSH
84942: LD_INT 1
84944: ARRAY
84945: PPUSH
84946: LD_VAR 0 7
84950: PUSH
84951: LD_INT 2
84953: ARRAY
84954: PPUSH
84955: CALL_OW 428
84959: PUSH
84960: LD_INT 0
84962: EQUAL
84963: IFFALSE 85016
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84965: LD_VAR 0 1
84969: PPUSH
84970: LD_VAR 0 7
84974: PUSH
84975: LD_INT 1
84977: ARRAY
84978: PPUSH
84979: LD_VAR 0 7
84983: PUSH
84984: LD_INT 2
84986: ARRAY
84987: PPUSH
84988: LD_VAR 0 3
84992: PPUSH
84993: CALL_OW 48
// result := IsPlaced ( unit ) ;
84997: LD_ADDR_VAR 0 4
85001: PUSH
85002: LD_VAR 0 1
85006: PPUSH
85007: CALL_OW 305
85011: ST_TO_ADDR
// exit ;
85012: POP
85013: POP
85014: GO 85020
// end ; end ;
85016: GO 84895
85018: POP
85019: POP
// end ;
85020: LD_VAR 0 4
85024: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85025: LD_INT 0
85027: PPUSH
85028: PPUSH
85029: PPUSH
// if not side or side > 8 then
85030: LD_VAR 0 1
85034: NOT
85035: PUSH
85036: LD_VAR 0 1
85040: PUSH
85041: LD_INT 8
85043: GREATER
85044: OR
85045: IFFALSE 85049
// exit ;
85047: GO 85236
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85049: LD_ADDR_VAR 0 4
85053: PUSH
85054: LD_INT 22
85056: PUSH
85057: LD_VAR 0 1
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_INT 21
85068: PUSH
85069: LD_INT 3
85071: PUSH
85072: EMPTY
85073: LIST
85074: LIST
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PPUSH
85080: CALL_OW 69
85084: ST_TO_ADDR
// if not tmp then
85085: LD_VAR 0 4
85089: NOT
85090: IFFALSE 85094
// exit ;
85092: GO 85236
// enable_addtolog := true ;
85094: LD_ADDR_OWVAR 81
85098: PUSH
85099: LD_INT 1
85101: ST_TO_ADDR
// AddToLog ( [ ) ;
85102: LD_STRING [
85104: PPUSH
85105: CALL_OW 561
// for i in tmp do
85109: LD_ADDR_VAR 0 3
85113: PUSH
85114: LD_VAR 0 4
85118: PUSH
85119: FOR_IN
85120: IFFALSE 85227
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85122: LD_STRING [
85124: PUSH
85125: LD_VAR 0 3
85129: PPUSH
85130: CALL_OW 266
85134: STR
85135: PUSH
85136: LD_STRING , 
85138: STR
85139: PUSH
85140: LD_VAR 0 3
85144: PPUSH
85145: CALL_OW 250
85149: STR
85150: PUSH
85151: LD_STRING , 
85153: STR
85154: PUSH
85155: LD_VAR 0 3
85159: PPUSH
85160: CALL_OW 251
85164: STR
85165: PUSH
85166: LD_STRING , 
85168: STR
85169: PUSH
85170: LD_VAR 0 3
85174: PPUSH
85175: CALL_OW 254
85179: STR
85180: PUSH
85181: LD_STRING , 
85183: STR
85184: PUSH
85185: LD_VAR 0 3
85189: PPUSH
85190: LD_INT 1
85192: PPUSH
85193: CALL_OW 268
85197: STR
85198: PUSH
85199: LD_STRING , 
85201: STR
85202: PUSH
85203: LD_VAR 0 3
85207: PPUSH
85208: LD_INT 2
85210: PPUSH
85211: CALL_OW 268
85215: STR
85216: PUSH
85217: LD_STRING ],
85219: STR
85220: PPUSH
85221: CALL_OW 561
// end ;
85225: GO 85119
85227: POP
85228: POP
// AddToLog ( ]; ) ;
85229: LD_STRING ];
85231: PPUSH
85232: CALL_OW 561
// end ;
85236: LD_VAR 0 2
85240: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85241: LD_INT 0
85243: PPUSH
85244: PPUSH
85245: PPUSH
85246: PPUSH
85247: PPUSH
// if not area or not rate or not max then
85248: LD_VAR 0 1
85252: NOT
85253: PUSH
85254: LD_VAR 0 2
85258: NOT
85259: OR
85260: PUSH
85261: LD_VAR 0 4
85265: NOT
85266: OR
85267: IFFALSE 85271
// exit ;
85269: GO 85460
// while 1 do
85271: LD_INT 1
85273: IFFALSE 85460
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85275: LD_ADDR_VAR 0 9
85279: PUSH
85280: LD_VAR 0 1
85284: PPUSH
85285: LD_INT 1
85287: PPUSH
85288: CALL_OW 287
85292: PUSH
85293: LD_INT 10
85295: MUL
85296: ST_TO_ADDR
// r := rate / 10 ;
85297: LD_ADDR_VAR 0 7
85301: PUSH
85302: LD_VAR 0 2
85306: PUSH
85307: LD_INT 10
85309: DIVREAL
85310: ST_TO_ADDR
// time := 1 1$00 ;
85311: LD_ADDR_VAR 0 8
85315: PUSH
85316: LD_INT 2100
85318: ST_TO_ADDR
// if amount < min then
85319: LD_VAR 0 9
85323: PUSH
85324: LD_VAR 0 3
85328: LESS
85329: IFFALSE 85347
// r := r * 2 else
85331: LD_ADDR_VAR 0 7
85335: PUSH
85336: LD_VAR 0 7
85340: PUSH
85341: LD_INT 2
85343: MUL
85344: ST_TO_ADDR
85345: GO 85373
// if amount > max then
85347: LD_VAR 0 9
85351: PUSH
85352: LD_VAR 0 4
85356: GREATER
85357: IFFALSE 85373
// r := r / 2 ;
85359: LD_ADDR_VAR 0 7
85363: PUSH
85364: LD_VAR 0 7
85368: PUSH
85369: LD_INT 2
85371: DIVREAL
85372: ST_TO_ADDR
// time := time / r ;
85373: LD_ADDR_VAR 0 8
85377: PUSH
85378: LD_VAR 0 8
85382: PUSH
85383: LD_VAR 0 7
85387: DIVREAL
85388: ST_TO_ADDR
// if time < 0 then
85389: LD_VAR 0 8
85393: PUSH
85394: LD_INT 0
85396: LESS
85397: IFFALSE 85414
// time := time * - 1 ;
85399: LD_ADDR_VAR 0 8
85403: PUSH
85404: LD_VAR 0 8
85408: PUSH
85409: LD_INT 1
85411: NEG
85412: MUL
85413: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85414: LD_VAR 0 8
85418: PUSH
85419: LD_INT 35
85421: PPUSH
85422: LD_INT 875
85424: PPUSH
85425: CALL_OW 12
85429: PLUS
85430: PPUSH
85431: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85435: LD_INT 1
85437: PPUSH
85438: LD_INT 5
85440: PPUSH
85441: CALL_OW 12
85445: PPUSH
85446: LD_VAR 0 1
85450: PPUSH
85451: LD_INT 1
85453: PPUSH
85454: CALL_OW 55
// end ;
85458: GO 85271
// end ;
85460: LD_VAR 0 5
85464: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85465: LD_INT 0
85467: PPUSH
85468: PPUSH
85469: PPUSH
85470: PPUSH
85471: PPUSH
85472: PPUSH
85473: PPUSH
85474: PPUSH
// if not turrets or not factories then
85475: LD_VAR 0 1
85479: NOT
85480: PUSH
85481: LD_VAR 0 2
85485: NOT
85486: OR
85487: IFFALSE 85491
// exit ;
85489: GO 85798
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85491: LD_ADDR_VAR 0 10
85495: PUSH
85496: LD_INT 5
85498: PUSH
85499: LD_INT 6
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 2
85508: PUSH
85509: LD_INT 4
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 3
85518: PUSH
85519: LD_INT 5
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 24
85533: PUSH
85534: LD_INT 25
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 23
85543: PUSH
85544: LD_INT 27
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: LD_INT 42
85557: PUSH
85558: LD_INT 43
85560: PUSH
85561: EMPTY
85562: LIST
85563: LIST
85564: PUSH
85565: LD_INT 44
85567: PUSH
85568: LD_INT 46
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 45
85577: PUSH
85578: LD_INT 47
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: LIST
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: LIST
85594: ST_TO_ADDR
// result := [ ] ;
85595: LD_ADDR_VAR 0 3
85599: PUSH
85600: EMPTY
85601: ST_TO_ADDR
// for i in turrets do
85602: LD_ADDR_VAR 0 4
85606: PUSH
85607: LD_VAR 0 1
85611: PUSH
85612: FOR_IN
85613: IFFALSE 85796
// begin nat := GetNation ( i ) ;
85615: LD_ADDR_VAR 0 7
85619: PUSH
85620: LD_VAR 0 4
85624: PPUSH
85625: CALL_OW 248
85629: ST_TO_ADDR
// weapon := 0 ;
85630: LD_ADDR_VAR 0 8
85634: PUSH
85635: LD_INT 0
85637: ST_TO_ADDR
// if not nat then
85638: LD_VAR 0 7
85642: NOT
85643: IFFALSE 85647
// continue ;
85645: GO 85612
// for j in list [ nat ] do
85647: LD_ADDR_VAR 0 5
85651: PUSH
85652: LD_VAR 0 10
85656: PUSH
85657: LD_VAR 0 7
85661: ARRAY
85662: PUSH
85663: FOR_IN
85664: IFFALSE 85705
// if GetBWeapon ( i ) = j [ 1 ] then
85666: LD_VAR 0 4
85670: PPUSH
85671: CALL_OW 269
85675: PUSH
85676: LD_VAR 0 5
85680: PUSH
85681: LD_INT 1
85683: ARRAY
85684: EQUAL
85685: IFFALSE 85703
// begin weapon := j [ 2 ] ;
85687: LD_ADDR_VAR 0 8
85691: PUSH
85692: LD_VAR 0 5
85696: PUSH
85697: LD_INT 2
85699: ARRAY
85700: ST_TO_ADDR
// break ;
85701: GO 85705
// end ;
85703: GO 85663
85705: POP
85706: POP
// if not weapon then
85707: LD_VAR 0 8
85711: NOT
85712: IFFALSE 85716
// continue ;
85714: GO 85612
// for k in factories do
85716: LD_ADDR_VAR 0 6
85720: PUSH
85721: LD_VAR 0 2
85725: PUSH
85726: FOR_IN
85727: IFFALSE 85792
// begin weapons := AvailableWeaponList ( k ) ;
85729: LD_ADDR_VAR 0 9
85733: PUSH
85734: LD_VAR 0 6
85738: PPUSH
85739: CALL_OW 478
85743: ST_TO_ADDR
// if not weapons then
85744: LD_VAR 0 9
85748: NOT
85749: IFFALSE 85753
// continue ;
85751: GO 85726
// if weapon in weapons then
85753: LD_VAR 0 8
85757: PUSH
85758: LD_VAR 0 9
85762: IN
85763: IFFALSE 85790
// begin result := [ i , weapon ] ;
85765: LD_ADDR_VAR 0 3
85769: PUSH
85770: LD_VAR 0 4
85774: PUSH
85775: LD_VAR 0 8
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: ST_TO_ADDR
// exit ;
85784: POP
85785: POP
85786: POP
85787: POP
85788: GO 85798
// end ; end ;
85790: GO 85726
85792: POP
85793: POP
// end ;
85794: GO 85612
85796: POP
85797: POP
// end ;
85798: LD_VAR 0 3
85802: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85803: LD_INT 0
85805: PPUSH
// if not side or side > 8 then
85806: LD_VAR 0 3
85810: NOT
85811: PUSH
85812: LD_VAR 0 3
85816: PUSH
85817: LD_INT 8
85819: GREATER
85820: OR
85821: IFFALSE 85825
// exit ;
85823: GO 85884
// if not range then
85825: LD_VAR 0 4
85829: NOT
85830: IFFALSE 85841
// range := - 12 ;
85832: LD_ADDR_VAR 0 4
85836: PUSH
85837: LD_INT 12
85839: NEG
85840: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
85841: LD_VAR 0 1
85845: PPUSH
85846: LD_VAR 0 2
85850: PPUSH
85851: LD_VAR 0 3
85855: PPUSH
85856: LD_VAR 0 4
85860: PPUSH
85861: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85865: LD_VAR 0 1
85869: PPUSH
85870: LD_VAR 0 2
85874: PPUSH
85875: LD_VAR 0 3
85879: PPUSH
85880: CALL_OW 331
// end ;
85884: LD_VAR 0 5
85888: RET
// export function Video ( mode ) ; begin
85889: LD_INT 0
85891: PPUSH
// ingame_video = mode ;
85892: LD_ADDR_OWVAR 52
85896: PUSH
85897: LD_VAR 0 1
85901: ST_TO_ADDR
// interface_hidden = mode ;
85902: LD_ADDR_OWVAR 54
85906: PUSH
85907: LD_VAR 0 1
85911: ST_TO_ADDR
// end ;
85912: LD_VAR 0 2
85916: RET
// export function Join ( array , element ) ; begin
85917: LD_INT 0
85919: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85920: LD_ADDR_VAR 0 3
85924: PUSH
85925: LD_VAR 0 1
85929: PPUSH
85930: LD_VAR 0 1
85934: PUSH
85935: LD_INT 1
85937: PLUS
85938: PPUSH
85939: LD_VAR 0 2
85943: PPUSH
85944: CALL_OW 1
85948: ST_TO_ADDR
// end ;
85949: LD_VAR 0 3
85953: RET
// export function JoinUnion ( array , element ) ; begin
85954: LD_INT 0
85956: PPUSH
// result := array union element ;
85957: LD_ADDR_VAR 0 3
85961: PUSH
85962: LD_VAR 0 1
85966: PUSH
85967: LD_VAR 0 2
85971: UNION
85972: ST_TO_ADDR
// end ;
85973: LD_VAR 0 3
85977: RET
// export function GetBehemoths ( side ) ; begin
85978: LD_INT 0
85980: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
85981: LD_ADDR_VAR 0 2
85985: PUSH
85986: LD_INT 22
85988: PUSH
85989: LD_VAR 0 1
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 31
86000: PUSH
86001: LD_INT 25
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PPUSH
86012: CALL_OW 69
86016: ST_TO_ADDR
// end ;
86017: LD_VAR 0 2
86021: RET
// export function Shuffle ( array ) ; var i , index ; begin
86022: LD_INT 0
86024: PPUSH
86025: PPUSH
86026: PPUSH
// result := [ ] ;
86027: LD_ADDR_VAR 0 2
86031: PUSH
86032: EMPTY
86033: ST_TO_ADDR
// if not array then
86034: LD_VAR 0 1
86038: NOT
86039: IFFALSE 86043
// exit ;
86041: GO 86142
// Randomize ;
86043: CALL_OW 10
// for i = array downto 1 do
86047: LD_ADDR_VAR 0 3
86051: PUSH
86052: DOUBLE
86053: LD_VAR 0 1
86057: INC
86058: ST_TO_ADDR
86059: LD_INT 1
86061: PUSH
86062: FOR_DOWNTO
86063: IFFALSE 86140
// begin index := rand ( 1 , array ) ;
86065: LD_ADDR_VAR 0 4
86069: PUSH
86070: LD_INT 1
86072: PPUSH
86073: LD_VAR 0 1
86077: PPUSH
86078: CALL_OW 12
86082: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86083: LD_ADDR_VAR 0 2
86087: PUSH
86088: LD_VAR 0 2
86092: PPUSH
86093: LD_VAR 0 2
86097: PUSH
86098: LD_INT 1
86100: PLUS
86101: PPUSH
86102: LD_VAR 0 1
86106: PUSH
86107: LD_VAR 0 4
86111: ARRAY
86112: PPUSH
86113: CALL_OW 2
86117: ST_TO_ADDR
// array := Delete ( array , index ) ;
86118: LD_ADDR_VAR 0 1
86122: PUSH
86123: LD_VAR 0 1
86127: PPUSH
86128: LD_VAR 0 4
86132: PPUSH
86133: CALL_OW 3
86137: ST_TO_ADDR
// end ;
86138: GO 86062
86140: POP
86141: POP
// end ;
86142: LD_VAR 0 2
86146: RET
// export function GetBaseMaterials ( base ) ; begin
86147: LD_INT 0
86149: PPUSH
// result := [ 0 , 0 , 0 ] ;
86150: LD_ADDR_VAR 0 2
86154: PUSH
86155: LD_INT 0
86157: PUSH
86158: LD_INT 0
86160: PUSH
86161: LD_INT 0
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: LIST
86168: ST_TO_ADDR
// if not base then
86169: LD_VAR 0 1
86173: NOT
86174: IFFALSE 86178
// exit ;
86176: GO 86227
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86178: LD_ADDR_VAR 0 2
86182: PUSH
86183: LD_VAR 0 1
86187: PPUSH
86188: LD_INT 1
86190: PPUSH
86191: CALL_OW 275
86195: PUSH
86196: LD_VAR 0 1
86200: PPUSH
86201: LD_INT 2
86203: PPUSH
86204: CALL_OW 275
86208: PUSH
86209: LD_VAR 0 1
86213: PPUSH
86214: LD_INT 3
86216: PPUSH
86217: CALL_OW 275
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: LIST
86226: ST_TO_ADDR
// end ;
86227: LD_VAR 0 2
86231: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86232: LD_INT 0
86234: PPUSH
86235: PPUSH
// result := array ;
86236: LD_ADDR_VAR 0 3
86240: PUSH
86241: LD_VAR 0 1
86245: ST_TO_ADDR
// if size >= result then
86246: LD_VAR 0 2
86250: PUSH
86251: LD_VAR 0 3
86255: GREATEREQUAL
86256: IFFALSE 86260
// exit ;
86258: GO 86310
// if size then
86260: LD_VAR 0 2
86264: IFFALSE 86310
// for i := array downto size do
86266: LD_ADDR_VAR 0 4
86270: PUSH
86271: DOUBLE
86272: LD_VAR 0 1
86276: INC
86277: ST_TO_ADDR
86278: LD_VAR 0 2
86282: PUSH
86283: FOR_DOWNTO
86284: IFFALSE 86308
// result := Delete ( result , result ) ;
86286: LD_ADDR_VAR 0 3
86290: PUSH
86291: LD_VAR 0 3
86295: PPUSH
86296: LD_VAR 0 3
86300: PPUSH
86301: CALL_OW 3
86305: ST_TO_ADDR
86306: GO 86283
86308: POP
86309: POP
// end ;
86310: LD_VAR 0 3
86314: RET
// export function ComExit ( unit ) ; var tmp ; begin
86315: LD_INT 0
86317: PPUSH
86318: PPUSH
// if not IsInUnit ( unit ) then
86319: LD_VAR 0 1
86323: PPUSH
86324: CALL_OW 310
86328: NOT
86329: IFFALSE 86333
// exit ;
86331: GO 86393
// tmp := IsInUnit ( unit ) ;
86333: LD_ADDR_VAR 0 3
86337: PUSH
86338: LD_VAR 0 1
86342: PPUSH
86343: CALL_OW 310
86347: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86348: LD_VAR 0 3
86352: PPUSH
86353: CALL_OW 247
86357: PUSH
86358: LD_INT 2
86360: EQUAL
86361: IFFALSE 86374
// ComExitVehicle ( unit ) else
86363: LD_VAR 0 1
86367: PPUSH
86368: CALL_OW 121
86372: GO 86383
// ComExitBuilding ( unit ) ;
86374: LD_VAR 0 1
86378: PPUSH
86379: CALL_OW 122
// result := tmp ;
86383: LD_ADDR_VAR 0 2
86387: PUSH
86388: LD_VAR 0 3
86392: ST_TO_ADDR
// end ;
86393: LD_VAR 0 2
86397: RET
// export function ComExitAll ( units ) ; var i ; begin
86398: LD_INT 0
86400: PPUSH
86401: PPUSH
// if not units then
86402: LD_VAR 0 1
86406: NOT
86407: IFFALSE 86411
// exit ;
86409: GO 86437
// for i in units do
86411: LD_ADDR_VAR 0 3
86415: PUSH
86416: LD_VAR 0 1
86420: PUSH
86421: FOR_IN
86422: IFFALSE 86435
// ComExit ( i ) ;
86424: LD_VAR 0 3
86428: PPUSH
86429: CALL 86315 0 1
86433: GO 86421
86435: POP
86436: POP
// end ;
86437: LD_VAR 0 2
86441: RET
// export function ResetHc ; begin
86442: LD_INT 0
86444: PPUSH
// InitHc ;
86445: CALL_OW 19
// hc_importance := 0 ;
86449: LD_ADDR_OWVAR 32
86453: PUSH
86454: LD_INT 0
86456: ST_TO_ADDR
// end ;
86457: LD_VAR 0 1
86461: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86462: LD_INT 0
86464: PPUSH
86465: PPUSH
86466: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86467: LD_ADDR_VAR 0 6
86471: PUSH
86472: LD_VAR 0 1
86476: PUSH
86477: LD_VAR 0 3
86481: PLUS
86482: PUSH
86483: LD_INT 2
86485: DIV
86486: ST_TO_ADDR
// if _x < 0 then
86487: LD_VAR 0 6
86491: PUSH
86492: LD_INT 0
86494: LESS
86495: IFFALSE 86512
// _x := _x * - 1 ;
86497: LD_ADDR_VAR 0 6
86501: PUSH
86502: LD_VAR 0 6
86506: PUSH
86507: LD_INT 1
86509: NEG
86510: MUL
86511: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86512: LD_ADDR_VAR 0 7
86516: PUSH
86517: LD_VAR 0 2
86521: PUSH
86522: LD_VAR 0 4
86526: PLUS
86527: PUSH
86528: LD_INT 2
86530: DIV
86531: ST_TO_ADDR
// if _y < 0 then
86532: LD_VAR 0 7
86536: PUSH
86537: LD_INT 0
86539: LESS
86540: IFFALSE 86557
// _y := _y * - 1 ;
86542: LD_ADDR_VAR 0 7
86546: PUSH
86547: LD_VAR 0 7
86551: PUSH
86552: LD_INT 1
86554: NEG
86555: MUL
86556: ST_TO_ADDR
// result := [ _x , _y ] ;
86557: LD_ADDR_VAR 0 5
86561: PUSH
86562: LD_VAR 0 6
86566: PUSH
86567: LD_VAR 0 7
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: ST_TO_ADDR
// end ;
86576: LD_VAR 0 5
86580: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
86581: LD_INT 0
86583: PPUSH
86584: PPUSH
86585: PPUSH
86586: PPUSH
// task := GetTaskList ( unit ) ;
86587: LD_ADDR_VAR 0 7
86591: PUSH
86592: LD_VAR 0 1
86596: PPUSH
86597: CALL_OW 437
86601: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
86602: LD_VAR 0 7
86606: NOT
86607: PUSH
86608: LD_VAR 0 1
86612: PPUSH
86613: LD_VAR 0 2
86617: PPUSH
86618: CALL_OW 308
86622: NOT
86623: AND
86624: IFFALSE 86628
// exit ;
86626: GO 86746
// if IsInArea ( unit , area ) then
86628: LD_VAR 0 1
86632: PPUSH
86633: LD_VAR 0 2
86637: PPUSH
86638: CALL_OW 308
86642: IFFALSE 86660
// begin ComMoveToArea ( unit , goAway ) ;
86644: LD_VAR 0 1
86648: PPUSH
86649: LD_VAR 0 3
86653: PPUSH
86654: CALL_OW 113
// exit ;
86658: GO 86746
// end ; if task [ 1 ] [ 1 ] <> M then
86660: LD_VAR 0 7
86664: PUSH
86665: LD_INT 1
86667: ARRAY
86668: PUSH
86669: LD_INT 1
86671: ARRAY
86672: PUSH
86673: LD_STRING M
86675: NONEQUAL
86676: IFFALSE 86680
// exit ;
86678: GO 86746
// x := task [ 1 ] [ 2 ] ;
86680: LD_ADDR_VAR 0 5
86684: PUSH
86685: LD_VAR 0 7
86689: PUSH
86690: LD_INT 1
86692: ARRAY
86693: PUSH
86694: LD_INT 2
86696: ARRAY
86697: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86698: LD_ADDR_VAR 0 6
86702: PUSH
86703: LD_VAR 0 7
86707: PUSH
86708: LD_INT 1
86710: ARRAY
86711: PUSH
86712: LD_INT 3
86714: ARRAY
86715: ST_TO_ADDR
// if InArea ( x , y , area ) then
86716: LD_VAR 0 5
86720: PPUSH
86721: LD_VAR 0 6
86725: PPUSH
86726: LD_VAR 0 2
86730: PPUSH
86731: CALL_OW 309
86735: IFFALSE 86746
// ComStop ( unit ) ;
86737: LD_VAR 0 1
86741: PPUSH
86742: CALL_OW 141
// end ;
86746: LD_VAR 0 4
86750: RET
// export function Abs ( value ) ; begin
86751: LD_INT 0
86753: PPUSH
// result := value ;
86754: LD_ADDR_VAR 0 2
86758: PUSH
86759: LD_VAR 0 1
86763: ST_TO_ADDR
// if value < 0 then
86764: LD_VAR 0 1
86768: PUSH
86769: LD_INT 0
86771: LESS
86772: IFFALSE 86789
// result := value * - 1 ;
86774: LD_ADDR_VAR 0 2
86778: PUSH
86779: LD_VAR 0 1
86783: PUSH
86784: LD_INT 1
86786: NEG
86787: MUL
86788: ST_TO_ADDR
// end ;
86789: LD_VAR 0 2
86793: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86794: LD_INT 0
86796: PPUSH
86797: PPUSH
86798: PPUSH
86799: PPUSH
86800: PPUSH
86801: PPUSH
86802: PPUSH
86803: PPUSH
// if not unit or not building then
86804: LD_VAR 0 1
86808: NOT
86809: PUSH
86810: LD_VAR 0 2
86814: NOT
86815: OR
86816: IFFALSE 86820
// exit ;
86818: GO 87046
// x := GetX ( building ) ;
86820: LD_ADDR_VAR 0 4
86824: PUSH
86825: LD_VAR 0 2
86829: PPUSH
86830: CALL_OW 250
86834: ST_TO_ADDR
// y := GetY ( building ) ;
86835: LD_ADDR_VAR 0 6
86839: PUSH
86840: LD_VAR 0 2
86844: PPUSH
86845: CALL_OW 251
86849: ST_TO_ADDR
// d := GetDir ( building ) ;
86850: LD_ADDR_VAR 0 8
86854: PUSH
86855: LD_VAR 0 2
86859: PPUSH
86860: CALL_OW 254
86864: ST_TO_ADDR
// r := 4 ;
86865: LD_ADDR_VAR 0 9
86869: PUSH
86870: LD_INT 4
86872: ST_TO_ADDR
// for i := 1 to 5 do
86873: LD_ADDR_VAR 0 10
86877: PUSH
86878: DOUBLE
86879: LD_INT 1
86881: DEC
86882: ST_TO_ADDR
86883: LD_INT 5
86885: PUSH
86886: FOR_TO
86887: IFFALSE 87044
// begin _x := ShiftX ( x , d , r + i ) ;
86889: LD_ADDR_VAR 0 5
86893: PUSH
86894: LD_VAR 0 4
86898: PPUSH
86899: LD_VAR 0 8
86903: PPUSH
86904: LD_VAR 0 9
86908: PUSH
86909: LD_VAR 0 10
86913: PLUS
86914: PPUSH
86915: CALL_OW 272
86919: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86920: LD_ADDR_VAR 0 7
86924: PUSH
86925: LD_VAR 0 6
86929: PPUSH
86930: LD_VAR 0 8
86934: PPUSH
86935: LD_VAR 0 9
86939: PUSH
86940: LD_VAR 0 10
86944: PLUS
86945: PPUSH
86946: CALL_OW 273
86950: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
86951: LD_VAR 0 5
86955: PPUSH
86956: LD_VAR 0 7
86960: PPUSH
86961: CALL_OW 488
86965: PUSH
86966: LD_VAR 0 5
86970: PPUSH
86971: LD_VAR 0 7
86975: PPUSH
86976: CALL_OW 428
86980: PPUSH
86981: CALL_OW 247
86985: PUSH
86986: LD_INT 3
86988: PUSH
86989: LD_INT 2
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: IN
86996: NOT
86997: AND
86998: IFFALSE 87042
// begin ComMoveXY ( unit , _x , _y ) ;
87000: LD_VAR 0 1
87004: PPUSH
87005: LD_VAR 0 5
87009: PPUSH
87010: LD_VAR 0 7
87014: PPUSH
87015: CALL_OW 111
// result := [ _x , _y ] ;
87019: LD_ADDR_VAR 0 3
87023: PUSH
87024: LD_VAR 0 5
87028: PUSH
87029: LD_VAR 0 7
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: ST_TO_ADDR
// exit ;
87038: POP
87039: POP
87040: GO 87046
// end ; end ;
87042: GO 86886
87044: POP
87045: POP
// end ;
87046: LD_VAR 0 3
87050: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87051: LD_INT 0
87053: PPUSH
87054: PPUSH
87055: PPUSH
// result := 0 ;
87056: LD_ADDR_VAR 0 3
87060: PUSH
87061: LD_INT 0
87063: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87064: LD_VAR 0 1
87068: PUSH
87069: LD_INT 0
87071: LESS
87072: PUSH
87073: LD_VAR 0 1
87077: PUSH
87078: LD_INT 8
87080: GREATER
87081: OR
87082: PUSH
87083: LD_VAR 0 2
87087: PUSH
87088: LD_INT 0
87090: LESS
87091: OR
87092: PUSH
87093: LD_VAR 0 2
87097: PUSH
87098: LD_INT 8
87100: GREATER
87101: OR
87102: IFFALSE 87106
// exit ;
87104: GO 87181
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87106: LD_ADDR_VAR 0 4
87110: PUSH
87111: LD_INT 22
87113: PUSH
87114: LD_VAR 0 2
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PPUSH
87123: CALL_OW 69
87127: PUSH
87128: FOR_IN
87129: IFFALSE 87179
// begin un := UnitShoot ( i ) ;
87131: LD_ADDR_VAR 0 5
87135: PUSH
87136: LD_VAR 0 4
87140: PPUSH
87141: CALL_OW 504
87145: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87146: LD_VAR 0 5
87150: PPUSH
87151: CALL_OW 255
87155: PUSH
87156: LD_VAR 0 1
87160: EQUAL
87161: IFFALSE 87177
// begin result := un ;
87163: LD_ADDR_VAR 0 3
87167: PUSH
87168: LD_VAR 0 5
87172: ST_TO_ADDR
// exit ;
87173: POP
87174: POP
87175: GO 87181
// end ; end ;
87177: GO 87128
87179: POP
87180: POP
// end ;
87181: LD_VAR 0 3
87185: RET
// export function GetCargoBay ( units ) ; begin
87186: LD_INT 0
87188: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87189: LD_ADDR_VAR 0 2
87193: PUSH
87194: LD_VAR 0 1
87198: PPUSH
87199: LD_INT 2
87201: PUSH
87202: LD_INT 34
87204: PUSH
87205: LD_INT 12
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 34
87214: PUSH
87215: LD_INT 51
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 34
87224: PUSH
87225: LD_INT 32
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 34
87234: PUSH
87235: LD_INT 89
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: PPUSH
87249: CALL_OW 72
87253: ST_TO_ADDR
// end ;
87254: LD_VAR 0 2
87258: RET
// export function Negate ( value ) ; begin
87259: LD_INT 0
87261: PPUSH
// result := not value ;
87262: LD_ADDR_VAR 0 2
87266: PUSH
87267: LD_VAR 0 1
87271: NOT
87272: ST_TO_ADDR
// end ;
87273: LD_VAR 0 2
87277: RET
// export function Inc ( value ) ; begin
87278: LD_INT 0
87280: PPUSH
// result := value + 1 ;
87281: LD_ADDR_VAR 0 2
87285: PUSH
87286: LD_VAR 0 1
87290: PUSH
87291: LD_INT 1
87293: PLUS
87294: ST_TO_ADDR
// end ;
87295: LD_VAR 0 2
87299: RET
// export function Dec ( value ) ; begin
87300: LD_INT 0
87302: PPUSH
// result := value - 1 ;
87303: LD_ADDR_VAR 0 2
87307: PUSH
87308: LD_VAR 0 1
87312: PUSH
87313: LD_INT 1
87315: MINUS
87316: ST_TO_ADDR
// end ;
87317: LD_VAR 0 2
87321: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87322: LD_INT 0
87324: PPUSH
87325: PPUSH
87326: PPUSH
87327: PPUSH
87328: PPUSH
87329: PPUSH
87330: PPUSH
87331: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87332: LD_VAR 0 1
87336: PPUSH
87337: LD_VAR 0 2
87341: PPUSH
87342: CALL_OW 488
87346: NOT
87347: PUSH
87348: LD_VAR 0 3
87352: PPUSH
87353: LD_VAR 0 4
87357: PPUSH
87358: CALL_OW 488
87362: NOT
87363: OR
87364: IFFALSE 87377
// begin result := - 1 ;
87366: LD_ADDR_VAR 0 5
87370: PUSH
87371: LD_INT 1
87373: NEG
87374: ST_TO_ADDR
// exit ;
87375: GO 87612
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87377: LD_ADDR_VAR 0 12
87381: PUSH
87382: LD_VAR 0 1
87386: PPUSH
87387: LD_VAR 0 2
87391: PPUSH
87392: LD_VAR 0 3
87396: PPUSH
87397: LD_VAR 0 4
87401: PPUSH
87402: CALL 86462 0 4
87406: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87407: LD_ADDR_VAR 0 11
87411: PUSH
87412: LD_VAR 0 1
87416: PPUSH
87417: LD_VAR 0 2
87421: PPUSH
87422: LD_VAR 0 12
87426: PUSH
87427: LD_INT 1
87429: ARRAY
87430: PPUSH
87431: LD_VAR 0 12
87435: PUSH
87436: LD_INT 2
87438: ARRAY
87439: PPUSH
87440: CALL_OW 298
87444: ST_TO_ADDR
// distance := 9999 ;
87445: LD_ADDR_VAR 0 10
87449: PUSH
87450: LD_INT 9999
87452: ST_TO_ADDR
// for i := 0 to 5 do
87453: LD_ADDR_VAR 0 6
87457: PUSH
87458: DOUBLE
87459: LD_INT 0
87461: DEC
87462: ST_TO_ADDR
87463: LD_INT 5
87465: PUSH
87466: FOR_TO
87467: IFFALSE 87610
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87469: LD_ADDR_VAR 0 7
87473: PUSH
87474: LD_VAR 0 1
87478: PPUSH
87479: LD_VAR 0 6
87483: PPUSH
87484: LD_VAR 0 11
87488: PPUSH
87489: CALL_OW 272
87493: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87494: LD_ADDR_VAR 0 8
87498: PUSH
87499: LD_VAR 0 2
87503: PPUSH
87504: LD_VAR 0 6
87508: PPUSH
87509: LD_VAR 0 11
87513: PPUSH
87514: CALL_OW 273
87518: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87519: LD_VAR 0 7
87523: PPUSH
87524: LD_VAR 0 8
87528: PPUSH
87529: CALL_OW 488
87533: NOT
87534: IFFALSE 87538
// continue ;
87536: GO 87466
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87538: LD_ADDR_VAR 0 9
87542: PUSH
87543: LD_VAR 0 12
87547: PUSH
87548: LD_INT 1
87550: ARRAY
87551: PPUSH
87552: LD_VAR 0 12
87556: PUSH
87557: LD_INT 2
87559: ARRAY
87560: PPUSH
87561: LD_VAR 0 7
87565: PPUSH
87566: LD_VAR 0 8
87570: PPUSH
87571: CALL_OW 298
87575: ST_TO_ADDR
// if tmp < distance then
87576: LD_VAR 0 9
87580: PUSH
87581: LD_VAR 0 10
87585: LESS
87586: IFFALSE 87608
// begin result := i ;
87588: LD_ADDR_VAR 0 5
87592: PUSH
87593: LD_VAR 0 6
87597: ST_TO_ADDR
// distance := tmp ;
87598: LD_ADDR_VAR 0 10
87602: PUSH
87603: LD_VAR 0 9
87607: ST_TO_ADDR
// end ; end ;
87608: GO 87466
87610: POP
87611: POP
// end ;
87612: LD_VAR 0 5
87616: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87617: LD_INT 0
87619: PPUSH
87620: PPUSH
// if not driver or not IsInUnit ( driver ) then
87621: LD_VAR 0 1
87625: NOT
87626: PUSH
87627: LD_VAR 0 1
87631: PPUSH
87632: CALL_OW 310
87636: NOT
87637: OR
87638: IFFALSE 87642
// exit ;
87640: GO 87732
// vehicle := IsInUnit ( driver ) ;
87642: LD_ADDR_VAR 0 3
87646: PUSH
87647: LD_VAR 0 1
87651: PPUSH
87652: CALL_OW 310
87656: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87657: LD_VAR 0 1
87661: PPUSH
87662: LD_STRING \
87664: PUSH
87665: LD_INT 0
87667: PUSH
87668: LD_INT 0
87670: PUSH
87671: LD_INT 0
87673: PUSH
87674: LD_INT 0
87676: PUSH
87677: LD_INT 0
87679: PUSH
87680: LD_INT 0
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: PUSH
87692: LD_STRING E
87694: PUSH
87695: LD_INT 0
87697: PUSH
87698: LD_INT 0
87700: PUSH
87701: LD_VAR 0 3
87705: PUSH
87706: LD_INT 0
87708: PUSH
87709: LD_INT 0
87711: PUSH
87712: LD_INT 0
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PPUSH
87728: CALL_OW 446
// end ;
87732: LD_VAR 0 2
87736: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87737: LD_INT 0
87739: PPUSH
87740: PPUSH
// if not driver or not IsInUnit ( driver ) then
87741: LD_VAR 0 1
87745: NOT
87746: PUSH
87747: LD_VAR 0 1
87751: PPUSH
87752: CALL_OW 310
87756: NOT
87757: OR
87758: IFFALSE 87762
// exit ;
87760: GO 87852
// vehicle := IsInUnit ( driver ) ;
87762: LD_ADDR_VAR 0 3
87766: PUSH
87767: LD_VAR 0 1
87771: PPUSH
87772: CALL_OW 310
87776: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87777: LD_VAR 0 1
87781: PPUSH
87782: LD_STRING \
87784: PUSH
87785: LD_INT 0
87787: PUSH
87788: LD_INT 0
87790: PUSH
87791: LD_INT 0
87793: PUSH
87794: LD_INT 0
87796: PUSH
87797: LD_INT 0
87799: PUSH
87800: LD_INT 0
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: PUSH
87812: LD_STRING E
87814: PUSH
87815: LD_INT 0
87817: PUSH
87818: LD_INT 0
87820: PUSH
87821: LD_VAR 0 3
87825: PUSH
87826: LD_INT 0
87828: PUSH
87829: LD_INT 0
87831: PUSH
87832: LD_INT 0
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PPUSH
87848: CALL_OW 447
// end ;
87852: LD_VAR 0 2
87856: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
87857: LD_INT 0
87859: PPUSH
87860: PPUSH
87861: PPUSH
// tmp := [ ] ;
87862: LD_ADDR_VAR 0 5
87866: PUSH
87867: EMPTY
87868: ST_TO_ADDR
// for i in units do
87869: LD_ADDR_VAR 0 4
87873: PUSH
87874: LD_VAR 0 1
87878: PUSH
87879: FOR_IN
87880: IFFALSE 87918
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
87882: LD_ADDR_VAR 0 5
87886: PUSH
87887: LD_VAR 0 5
87891: PPUSH
87892: LD_VAR 0 5
87896: PUSH
87897: LD_INT 1
87899: PLUS
87900: PPUSH
87901: LD_VAR 0 4
87905: PPUSH
87906: CALL_OW 256
87910: PPUSH
87911: CALL_OW 2
87915: ST_TO_ADDR
87916: GO 87879
87918: POP
87919: POP
// if not tmp then
87920: LD_VAR 0 5
87924: NOT
87925: IFFALSE 87929
// exit ;
87927: GO 87977
// if asc then
87929: LD_VAR 0 2
87933: IFFALSE 87957
// result := SortListByListAsc ( units , tmp ) else
87935: LD_ADDR_VAR 0 3
87939: PUSH
87940: LD_VAR 0 1
87944: PPUSH
87945: LD_VAR 0 5
87949: PPUSH
87950: CALL_OW 76
87954: ST_TO_ADDR
87955: GO 87977
// result := SortListByListDesc ( units , tmp ) ;
87957: LD_ADDR_VAR 0 3
87961: PUSH
87962: LD_VAR 0 1
87966: PPUSH
87967: LD_VAR 0 5
87971: PPUSH
87972: CALL_OW 77
87976: ST_TO_ADDR
// end ;
87977: LD_VAR 0 3
87981: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
87982: LD_INT 0
87984: PPUSH
87985: PPUSH
// task := GetTaskList ( mech ) ;
87986: LD_ADDR_VAR 0 4
87990: PUSH
87991: LD_VAR 0 1
87995: PPUSH
87996: CALL_OW 437
88000: ST_TO_ADDR
// if not task then
88001: LD_VAR 0 4
88005: NOT
88006: IFFALSE 88010
// exit ;
88008: GO 88052
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88010: LD_ADDR_VAR 0 3
88014: PUSH
88015: LD_VAR 0 4
88019: PUSH
88020: LD_INT 1
88022: ARRAY
88023: PUSH
88024: LD_INT 1
88026: ARRAY
88027: PUSH
88028: LD_STRING r
88030: EQUAL
88031: PUSH
88032: LD_VAR 0 4
88036: PUSH
88037: LD_INT 1
88039: ARRAY
88040: PUSH
88041: LD_INT 4
88043: ARRAY
88044: PUSH
88045: LD_VAR 0 2
88049: EQUAL
88050: AND
88051: ST_TO_ADDR
// end ;
88052: LD_VAR 0 3
88056: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88057: LD_INT 0
88059: PPUSH
// SetDir ( unit , d ) ;
88060: LD_VAR 0 1
88064: PPUSH
88065: LD_VAR 0 4
88069: PPUSH
88070: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88074: LD_VAR 0 1
88078: PPUSH
88079: LD_VAR 0 2
88083: PPUSH
88084: LD_VAR 0 3
88088: PPUSH
88089: LD_VAR 0 5
88093: PPUSH
88094: CALL_OW 48
// end ;
88098: LD_VAR 0 6
88102: RET
// export function ToNaturalNumber ( number ) ; begin
88103: LD_INT 0
88105: PPUSH
// result := number div 1 ;
88106: LD_ADDR_VAR 0 2
88110: PUSH
88111: LD_VAR 0 1
88115: PUSH
88116: LD_INT 1
88118: DIV
88119: ST_TO_ADDR
// if number < 0 then
88120: LD_VAR 0 1
88124: PUSH
88125: LD_INT 0
88127: LESS
88128: IFFALSE 88138
// result := 0 ;
88130: LD_ADDR_VAR 0 2
88134: PUSH
88135: LD_INT 0
88137: ST_TO_ADDR
// end ;
88138: LD_VAR 0 2
88142: RET
// export function SortByClass ( units , class ) ; var un ; begin
88143: LD_INT 0
88145: PPUSH
88146: PPUSH
// if not units or not class then
88147: LD_VAR 0 1
88151: NOT
88152: PUSH
88153: LD_VAR 0 2
88157: NOT
88158: OR
88159: IFFALSE 88163
// exit ;
88161: GO 88258
// result := [ ] ;
88163: LD_ADDR_VAR 0 3
88167: PUSH
88168: EMPTY
88169: ST_TO_ADDR
// for un in units do
88170: LD_ADDR_VAR 0 4
88174: PUSH
88175: LD_VAR 0 1
88179: PUSH
88180: FOR_IN
88181: IFFALSE 88256
// if GetClass ( un ) = class then
88183: LD_VAR 0 4
88187: PPUSH
88188: CALL_OW 257
88192: PUSH
88193: LD_VAR 0 2
88197: EQUAL
88198: IFFALSE 88225
// result := Insert ( result , 1 , un ) else
88200: LD_ADDR_VAR 0 3
88204: PUSH
88205: LD_VAR 0 3
88209: PPUSH
88210: LD_INT 1
88212: PPUSH
88213: LD_VAR 0 4
88217: PPUSH
88218: CALL_OW 2
88222: ST_TO_ADDR
88223: GO 88254
// result := Replace ( result , result + 1 , un ) ;
88225: LD_ADDR_VAR 0 3
88229: PUSH
88230: LD_VAR 0 3
88234: PPUSH
88235: LD_VAR 0 3
88239: PUSH
88240: LD_INT 1
88242: PLUS
88243: PPUSH
88244: LD_VAR 0 4
88248: PPUSH
88249: CALL_OW 1
88253: ST_TO_ADDR
88254: GO 88180
88256: POP
88257: POP
// end ;
88258: LD_VAR 0 3
88262: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88263: LD_INT 0
88265: PPUSH
88266: PPUSH
88267: PPUSH
88268: PPUSH
88269: PPUSH
88270: PPUSH
88271: PPUSH
// result := [ ] ;
88272: LD_ADDR_VAR 0 4
88276: PUSH
88277: EMPTY
88278: ST_TO_ADDR
// if x - r < 0 then
88279: LD_VAR 0 1
88283: PUSH
88284: LD_VAR 0 3
88288: MINUS
88289: PUSH
88290: LD_INT 0
88292: LESS
88293: IFFALSE 88305
// min_x := 0 else
88295: LD_ADDR_VAR 0 8
88299: PUSH
88300: LD_INT 0
88302: ST_TO_ADDR
88303: GO 88321
// min_x := x - r ;
88305: LD_ADDR_VAR 0 8
88309: PUSH
88310: LD_VAR 0 1
88314: PUSH
88315: LD_VAR 0 3
88319: MINUS
88320: ST_TO_ADDR
// if y - r < 0 then
88321: LD_VAR 0 2
88325: PUSH
88326: LD_VAR 0 3
88330: MINUS
88331: PUSH
88332: LD_INT 0
88334: LESS
88335: IFFALSE 88347
// min_y := 0 else
88337: LD_ADDR_VAR 0 7
88341: PUSH
88342: LD_INT 0
88344: ST_TO_ADDR
88345: GO 88363
// min_y := y - r ;
88347: LD_ADDR_VAR 0 7
88351: PUSH
88352: LD_VAR 0 2
88356: PUSH
88357: LD_VAR 0 3
88361: MINUS
88362: ST_TO_ADDR
// max_x := x + r ;
88363: LD_ADDR_VAR 0 9
88367: PUSH
88368: LD_VAR 0 1
88372: PUSH
88373: LD_VAR 0 3
88377: PLUS
88378: ST_TO_ADDR
// max_y := y + r ;
88379: LD_ADDR_VAR 0 10
88383: PUSH
88384: LD_VAR 0 2
88388: PUSH
88389: LD_VAR 0 3
88393: PLUS
88394: ST_TO_ADDR
// for _x = min_x to max_x do
88395: LD_ADDR_VAR 0 5
88399: PUSH
88400: DOUBLE
88401: LD_VAR 0 8
88405: DEC
88406: ST_TO_ADDR
88407: LD_VAR 0 9
88411: PUSH
88412: FOR_TO
88413: IFFALSE 88514
// for _y = min_y to max_y do
88415: LD_ADDR_VAR 0 6
88419: PUSH
88420: DOUBLE
88421: LD_VAR 0 7
88425: DEC
88426: ST_TO_ADDR
88427: LD_VAR 0 10
88431: PUSH
88432: FOR_TO
88433: IFFALSE 88510
// begin if not ValidHex ( _x , _y ) then
88435: LD_VAR 0 5
88439: PPUSH
88440: LD_VAR 0 6
88444: PPUSH
88445: CALL_OW 488
88449: NOT
88450: IFFALSE 88454
// continue ;
88452: GO 88432
// if GetResourceTypeXY ( _x , _y ) then
88454: LD_VAR 0 5
88458: PPUSH
88459: LD_VAR 0 6
88463: PPUSH
88464: CALL_OW 283
88468: IFFALSE 88508
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88470: LD_ADDR_VAR 0 4
88474: PUSH
88475: LD_VAR 0 4
88479: PPUSH
88480: LD_VAR 0 4
88484: PUSH
88485: LD_INT 1
88487: PLUS
88488: PPUSH
88489: LD_VAR 0 5
88493: PUSH
88494: LD_VAR 0 6
88498: PUSH
88499: EMPTY
88500: LIST
88501: LIST
88502: PPUSH
88503: CALL_OW 1
88507: ST_TO_ADDR
// end ;
88508: GO 88432
88510: POP
88511: POP
88512: GO 88412
88514: POP
88515: POP
// end ;
88516: LD_VAR 0 4
88520: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88521: LD_INT 0
88523: PPUSH
88524: PPUSH
88525: PPUSH
88526: PPUSH
88527: PPUSH
88528: PPUSH
88529: PPUSH
88530: PPUSH
// if not units then
88531: LD_VAR 0 1
88535: NOT
88536: IFFALSE 88540
// exit ;
88538: GO 89064
// result := UnitFilter ( units , [ f_ok ] ) ;
88540: LD_ADDR_VAR 0 3
88544: PUSH
88545: LD_VAR 0 1
88549: PPUSH
88550: LD_INT 50
88552: PUSH
88553: EMPTY
88554: LIST
88555: PPUSH
88556: CALL_OW 72
88560: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
88561: LD_ADDR_VAR 0 8
88565: PUSH
88566: LD_VAR 0 1
88570: PUSH
88571: LD_INT 1
88573: ARRAY
88574: PPUSH
88575: CALL_OW 255
88579: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
88580: LD_ADDR_VAR 0 10
88584: PUSH
88585: LD_INT 29
88587: PUSH
88588: LD_INT 91
88590: PUSH
88591: LD_INT 49
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: LIST
88598: ST_TO_ADDR
// if not result then
88599: LD_VAR 0 3
88603: NOT
88604: IFFALSE 88608
// exit ;
88606: GO 89064
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88608: LD_ADDR_VAR 0 5
88612: PUSH
88613: LD_INT 81
88615: PUSH
88616: LD_VAR 0 8
88620: PUSH
88621: EMPTY
88622: LIST
88623: LIST
88624: PPUSH
88625: CALL_OW 69
88629: ST_TO_ADDR
// for i in result do
88630: LD_ADDR_VAR 0 4
88634: PUSH
88635: LD_VAR 0 3
88639: PUSH
88640: FOR_IN
88641: IFFALSE 89062
// begin tag := GetTag ( i ) + 1 ;
88643: LD_ADDR_VAR 0 9
88647: PUSH
88648: LD_VAR 0 4
88652: PPUSH
88653: CALL_OW 110
88657: PUSH
88658: LD_INT 1
88660: PLUS
88661: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88662: LD_ADDR_VAR 0 7
88666: PUSH
88667: LD_VAR 0 4
88671: PPUSH
88672: CALL_OW 250
88676: PPUSH
88677: LD_VAR 0 4
88681: PPUSH
88682: CALL_OW 251
88686: PPUSH
88687: LD_INT 6
88689: PPUSH
88690: CALL 88263 0 3
88694: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88695: LD_VAR 0 4
88699: PPUSH
88700: CALL_OW 247
88704: PUSH
88705: LD_INT 2
88707: EQUAL
88708: PUSH
88709: LD_VAR 0 7
88713: AND
88714: PUSH
88715: LD_VAR 0 4
88719: PPUSH
88720: CALL_OW 264
88724: PUSH
88725: LD_VAR 0 10
88729: IN
88730: NOT
88731: AND
88732: IFFALSE 88771
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88734: LD_VAR 0 4
88738: PPUSH
88739: LD_VAR 0 7
88743: PUSH
88744: LD_INT 1
88746: ARRAY
88747: PUSH
88748: LD_INT 1
88750: ARRAY
88751: PPUSH
88752: LD_VAR 0 7
88756: PUSH
88757: LD_INT 1
88759: ARRAY
88760: PUSH
88761: LD_INT 2
88763: ARRAY
88764: PPUSH
88765: CALL_OW 116
88769: GO 89060
// if path > tag then
88771: LD_VAR 0 2
88775: PUSH
88776: LD_VAR 0 9
88780: GREATER
88781: IFFALSE 88989
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
88783: LD_ADDR_VAR 0 6
88787: PUSH
88788: LD_VAR 0 5
88792: PPUSH
88793: LD_INT 91
88795: PUSH
88796: LD_VAR 0 4
88800: PUSH
88801: LD_INT 8
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: LIST
88808: PPUSH
88809: CALL_OW 72
88813: ST_TO_ADDR
// if nearEnemy then
88814: LD_VAR 0 6
88818: IFFALSE 88887
// begin if GetWeapon ( i ) = ru_time_lapser then
88820: LD_VAR 0 4
88824: PPUSH
88825: CALL_OW 264
88829: PUSH
88830: LD_INT 49
88832: EQUAL
88833: IFFALSE 88861
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
88835: LD_VAR 0 4
88839: PPUSH
88840: LD_VAR 0 6
88844: PPUSH
88845: LD_VAR 0 4
88849: PPUSH
88850: CALL_OW 74
88854: PPUSH
88855: CALL_OW 112
88859: GO 88885
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
88861: LD_VAR 0 4
88865: PPUSH
88866: LD_VAR 0 6
88870: PPUSH
88871: LD_VAR 0 4
88875: PPUSH
88876: CALL_OW 74
88880: PPUSH
88881: CALL_OW 115
// end else
88885: GO 88987
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
88887: LD_VAR 0 4
88891: PPUSH
88892: LD_VAR 0 2
88896: PUSH
88897: LD_VAR 0 9
88901: ARRAY
88902: PUSH
88903: LD_INT 1
88905: ARRAY
88906: PPUSH
88907: LD_VAR 0 2
88911: PUSH
88912: LD_VAR 0 9
88916: ARRAY
88917: PUSH
88918: LD_INT 2
88920: ARRAY
88921: PPUSH
88922: CALL_OW 297
88926: PUSH
88927: LD_INT 6
88929: GREATER
88930: IFFALSE 88973
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
88932: LD_VAR 0 4
88936: PPUSH
88937: LD_VAR 0 2
88941: PUSH
88942: LD_VAR 0 9
88946: ARRAY
88947: PUSH
88948: LD_INT 1
88950: ARRAY
88951: PPUSH
88952: LD_VAR 0 2
88956: PUSH
88957: LD_VAR 0 9
88961: ARRAY
88962: PUSH
88963: LD_INT 2
88965: ARRAY
88966: PPUSH
88967: CALL_OW 114
88971: GO 88987
// SetTag ( i , tag ) ;
88973: LD_VAR 0 4
88977: PPUSH
88978: LD_VAR 0 9
88982: PPUSH
88983: CALL_OW 109
// end else
88987: GO 89060
// if enemy then
88989: LD_VAR 0 5
88993: IFFALSE 89060
// begin if GetWeapon ( i ) = ru_time_lapser then
88995: LD_VAR 0 4
88999: PPUSH
89000: CALL_OW 264
89004: PUSH
89005: LD_INT 49
89007: EQUAL
89008: IFFALSE 89036
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89010: LD_VAR 0 4
89014: PPUSH
89015: LD_VAR 0 5
89019: PPUSH
89020: LD_VAR 0 4
89024: PPUSH
89025: CALL_OW 74
89029: PPUSH
89030: CALL_OW 112
89034: GO 89060
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89036: LD_VAR 0 4
89040: PPUSH
89041: LD_VAR 0 5
89045: PPUSH
89046: LD_VAR 0 4
89050: PPUSH
89051: CALL_OW 74
89055: PPUSH
89056: CALL_OW 115
// end ; end ;
89060: GO 88640
89062: POP
89063: POP
// end ;
89064: LD_VAR 0 3
89068: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89069: LD_INT 0
89071: PPUSH
89072: PPUSH
89073: PPUSH
// if not unit or IsInUnit ( unit ) then
89074: LD_VAR 0 1
89078: NOT
89079: PUSH
89080: LD_VAR 0 1
89084: PPUSH
89085: CALL_OW 310
89089: OR
89090: IFFALSE 89094
// exit ;
89092: GO 89185
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89094: LD_ADDR_VAR 0 4
89098: PUSH
89099: LD_VAR 0 1
89103: PPUSH
89104: CALL_OW 250
89108: PPUSH
89109: LD_VAR 0 2
89113: PPUSH
89114: LD_INT 1
89116: PPUSH
89117: CALL_OW 272
89121: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89122: LD_ADDR_VAR 0 5
89126: PUSH
89127: LD_VAR 0 1
89131: PPUSH
89132: CALL_OW 251
89136: PPUSH
89137: LD_VAR 0 2
89141: PPUSH
89142: LD_INT 1
89144: PPUSH
89145: CALL_OW 273
89149: ST_TO_ADDR
// if ValidHex ( x , y ) then
89150: LD_VAR 0 4
89154: PPUSH
89155: LD_VAR 0 5
89159: PPUSH
89160: CALL_OW 488
89164: IFFALSE 89185
// ComTurnXY ( unit , x , y ) ;
89166: LD_VAR 0 1
89170: PPUSH
89171: LD_VAR 0 4
89175: PPUSH
89176: LD_VAR 0 5
89180: PPUSH
89181: CALL_OW 118
// end ;
89185: LD_VAR 0 3
89189: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89190: LD_INT 0
89192: PPUSH
89193: PPUSH
// result := false ;
89194: LD_ADDR_VAR 0 3
89198: PUSH
89199: LD_INT 0
89201: ST_TO_ADDR
// if not units then
89202: LD_VAR 0 2
89206: NOT
89207: IFFALSE 89211
// exit ;
89209: GO 89256
// for i in units do
89211: LD_ADDR_VAR 0 4
89215: PUSH
89216: LD_VAR 0 2
89220: PUSH
89221: FOR_IN
89222: IFFALSE 89254
// if See ( side , i ) then
89224: LD_VAR 0 1
89228: PPUSH
89229: LD_VAR 0 4
89233: PPUSH
89234: CALL_OW 292
89238: IFFALSE 89252
// begin result := true ;
89240: LD_ADDR_VAR 0 3
89244: PUSH
89245: LD_INT 1
89247: ST_TO_ADDR
// exit ;
89248: POP
89249: POP
89250: GO 89256
// end ;
89252: GO 89221
89254: POP
89255: POP
// end ;
89256: LD_VAR 0 3
89260: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89261: LD_INT 0
89263: PPUSH
89264: PPUSH
89265: PPUSH
89266: PPUSH
// if not unit or not points then
89267: LD_VAR 0 1
89271: NOT
89272: PUSH
89273: LD_VAR 0 2
89277: NOT
89278: OR
89279: IFFALSE 89283
// exit ;
89281: GO 89373
// dist := 99999 ;
89283: LD_ADDR_VAR 0 5
89287: PUSH
89288: LD_INT 99999
89290: ST_TO_ADDR
// for i in points do
89291: LD_ADDR_VAR 0 4
89295: PUSH
89296: LD_VAR 0 2
89300: PUSH
89301: FOR_IN
89302: IFFALSE 89371
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89304: LD_ADDR_VAR 0 6
89308: PUSH
89309: LD_VAR 0 1
89313: PPUSH
89314: LD_VAR 0 4
89318: PUSH
89319: LD_INT 1
89321: ARRAY
89322: PPUSH
89323: LD_VAR 0 4
89327: PUSH
89328: LD_INT 2
89330: ARRAY
89331: PPUSH
89332: CALL_OW 297
89336: ST_TO_ADDR
// if tmpDist < dist then
89337: LD_VAR 0 6
89341: PUSH
89342: LD_VAR 0 5
89346: LESS
89347: IFFALSE 89369
// begin result := i ;
89349: LD_ADDR_VAR 0 3
89353: PUSH
89354: LD_VAR 0 4
89358: ST_TO_ADDR
// dist := tmpDist ;
89359: LD_ADDR_VAR 0 5
89363: PUSH
89364: LD_VAR 0 6
89368: ST_TO_ADDR
// end ; end ;
89369: GO 89301
89371: POP
89372: POP
// end ;
89373: LD_VAR 0 3
89377: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89378: LD_INT 0
89380: PPUSH
// uc_side := side ;
89381: LD_ADDR_OWVAR 20
89385: PUSH
89386: LD_VAR 0 1
89390: ST_TO_ADDR
// uc_nation := 3 ;
89391: LD_ADDR_OWVAR 21
89395: PUSH
89396: LD_INT 3
89398: ST_TO_ADDR
// vc_chassis := 25 ;
89399: LD_ADDR_OWVAR 37
89403: PUSH
89404: LD_INT 25
89406: ST_TO_ADDR
// vc_engine := engine_siberite ;
89407: LD_ADDR_OWVAR 39
89411: PUSH
89412: LD_INT 3
89414: ST_TO_ADDR
// vc_control := control_computer ;
89415: LD_ADDR_OWVAR 38
89419: PUSH
89420: LD_INT 3
89422: ST_TO_ADDR
// vc_weapon := 59 ;
89423: LD_ADDR_OWVAR 40
89427: PUSH
89428: LD_INT 59
89430: ST_TO_ADDR
// result := CreateVehicle ;
89431: LD_ADDR_VAR 0 5
89435: PUSH
89436: CALL_OW 45
89440: ST_TO_ADDR
// SetDir ( result , d ) ;
89441: LD_VAR 0 5
89445: PPUSH
89446: LD_VAR 0 4
89450: PPUSH
89451: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89455: LD_VAR 0 5
89459: PPUSH
89460: LD_VAR 0 2
89464: PPUSH
89465: LD_VAR 0 3
89469: PPUSH
89470: LD_INT 0
89472: PPUSH
89473: CALL_OW 48
// end ;
89477: LD_VAR 0 5
89481: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89482: LD_INT 0
89484: PPUSH
89485: PPUSH
89486: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89487: LD_ADDR_VAR 0 2
89491: PUSH
89492: LD_INT 0
89494: PUSH
89495: LD_INT 0
89497: PUSH
89498: LD_INT 0
89500: PUSH
89501: LD_INT 0
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89510: LD_VAR 0 1
89514: NOT
89515: PUSH
89516: LD_VAR 0 1
89520: PPUSH
89521: CALL_OW 264
89525: PUSH
89526: LD_INT 12
89528: PUSH
89529: LD_INT 51
89531: PUSH
89532: LD_INT 32
89534: PUSH
89535: LD_INT 89
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: IN
89544: NOT
89545: OR
89546: IFFALSE 89550
// exit ;
89548: GO 89648
// for i := 1 to 3 do
89550: LD_ADDR_VAR 0 3
89554: PUSH
89555: DOUBLE
89556: LD_INT 1
89558: DEC
89559: ST_TO_ADDR
89560: LD_INT 3
89562: PUSH
89563: FOR_TO
89564: IFFALSE 89646
// begin tmp := GetCargo ( cargo , i ) ;
89566: LD_ADDR_VAR 0 4
89570: PUSH
89571: LD_VAR 0 1
89575: PPUSH
89576: LD_VAR 0 3
89580: PPUSH
89581: CALL_OW 289
89585: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
89586: LD_ADDR_VAR 0 2
89590: PUSH
89591: LD_VAR 0 2
89595: PPUSH
89596: LD_VAR 0 3
89600: PPUSH
89601: LD_VAR 0 4
89605: PPUSH
89606: CALL_OW 1
89610: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
89611: LD_ADDR_VAR 0 2
89615: PUSH
89616: LD_VAR 0 2
89620: PPUSH
89621: LD_INT 4
89623: PPUSH
89624: LD_VAR 0 2
89628: PUSH
89629: LD_INT 4
89631: ARRAY
89632: PUSH
89633: LD_VAR 0 4
89637: PLUS
89638: PPUSH
89639: CALL_OW 1
89643: ST_TO_ADDR
// end ;
89644: GO 89563
89646: POP
89647: POP
// end ;
89648: LD_VAR 0 2
89652: RET
// export function Length ( array ) ; begin
89653: LD_INT 0
89655: PPUSH
// result := array + 0 ;
89656: LD_ADDR_VAR 0 2
89660: PUSH
89661: LD_VAR 0 1
89665: PUSH
89666: LD_INT 0
89668: PLUS
89669: ST_TO_ADDR
// end ;
89670: LD_VAR 0 2
89674: RET
// export function PrepareArray ( array ) ; begin
89675: LD_INT 0
89677: PPUSH
// result := array diff 0 ;
89678: LD_ADDR_VAR 0 2
89682: PUSH
89683: LD_VAR 0 1
89687: PUSH
89688: LD_INT 0
89690: DIFF
89691: ST_TO_ADDR
// if not result [ 1 ] then
89692: LD_VAR 0 2
89696: PUSH
89697: LD_INT 1
89699: ARRAY
89700: NOT
89701: IFFALSE 89721
// result := Delete ( result , 1 ) ;
89703: LD_ADDR_VAR 0 2
89707: PUSH
89708: LD_VAR 0 2
89712: PPUSH
89713: LD_INT 1
89715: PPUSH
89716: CALL_OW 3
89720: ST_TO_ADDR
// end ; end_of_file end_of_file
89721: LD_VAR 0 2
89725: RET
// every 0 0$1 do
89726: GO 89728
89728: DISABLE
// begin enable ;
89729: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89730: LD_STRING updateTimer(
89732: PUSH
89733: LD_OWVAR 1
89737: STR
89738: PUSH
89739: LD_STRING );
89741: STR
89742: PPUSH
89743: CALL_OW 559
// end ;
89747: END
// export function SOS_MapStart ( ) ; begin
89748: LD_INT 0
89750: PPUSH
// if streamModeActive then
89751: LD_EXP 94
89755: IFFALSE 89764
// DefineStreamItems ( true ) ;
89757: LD_INT 1
89759: PPUSH
89760: CALL 91418 0 1
// UpdateFactoryWaypoints ( ) ;
89764: CALL 104279 0 0
// UpdateWarehouseGatheringPoints ( ) ;
89768: CALL 104536 0 0
// end ;
89772: LD_VAR 0 1
89776: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89777: LD_INT 0
89779: PPUSH
// if p2 = 100 then
89780: LD_VAR 0 2
89784: PUSH
89785: LD_INT 100
89787: EQUAL
89788: IFFALSE 90791
// begin if not StreamModeActive then
89790: LD_EXP 94
89794: NOT
89795: IFFALSE 89805
// StreamModeActive := true ;
89797: LD_ADDR_EXP 94
89801: PUSH
89802: LD_INT 1
89804: ST_TO_ADDR
// if p3 = 0 then
89805: LD_VAR 0 3
89809: PUSH
89810: LD_INT 0
89812: EQUAL
89813: IFFALSE 89819
// InitStreamMode ;
89815: CALL 90954 0 0
// if p3 = 1 then
89819: LD_VAR 0 3
89823: PUSH
89824: LD_INT 1
89826: EQUAL
89827: IFFALSE 89837
// sRocket := true ;
89829: LD_ADDR_EXP 99
89833: PUSH
89834: LD_INT 1
89836: ST_TO_ADDR
// if p3 = 2 then
89837: LD_VAR 0 3
89841: PUSH
89842: LD_INT 2
89844: EQUAL
89845: IFFALSE 89855
// sSpeed := true ;
89847: LD_ADDR_EXP 98
89851: PUSH
89852: LD_INT 1
89854: ST_TO_ADDR
// if p3 = 3 then
89855: LD_VAR 0 3
89859: PUSH
89860: LD_INT 3
89862: EQUAL
89863: IFFALSE 89873
// sEngine := true ;
89865: LD_ADDR_EXP 100
89869: PUSH
89870: LD_INT 1
89872: ST_TO_ADDR
// if p3 = 4 then
89873: LD_VAR 0 3
89877: PUSH
89878: LD_INT 4
89880: EQUAL
89881: IFFALSE 89891
// sSpec := true ;
89883: LD_ADDR_EXP 97
89887: PUSH
89888: LD_INT 1
89890: ST_TO_ADDR
// if p3 = 5 then
89891: LD_VAR 0 3
89895: PUSH
89896: LD_INT 5
89898: EQUAL
89899: IFFALSE 89909
// sLevel := true ;
89901: LD_ADDR_EXP 101
89905: PUSH
89906: LD_INT 1
89908: ST_TO_ADDR
// if p3 = 6 then
89909: LD_VAR 0 3
89913: PUSH
89914: LD_INT 6
89916: EQUAL
89917: IFFALSE 89927
// sArmoury := true ;
89919: LD_ADDR_EXP 102
89923: PUSH
89924: LD_INT 1
89926: ST_TO_ADDR
// if p3 = 7 then
89927: LD_VAR 0 3
89931: PUSH
89932: LD_INT 7
89934: EQUAL
89935: IFFALSE 89945
// sRadar := true ;
89937: LD_ADDR_EXP 103
89941: PUSH
89942: LD_INT 1
89944: ST_TO_ADDR
// if p3 = 8 then
89945: LD_VAR 0 3
89949: PUSH
89950: LD_INT 8
89952: EQUAL
89953: IFFALSE 89963
// sBunker := true ;
89955: LD_ADDR_EXP 104
89959: PUSH
89960: LD_INT 1
89962: ST_TO_ADDR
// if p3 = 9 then
89963: LD_VAR 0 3
89967: PUSH
89968: LD_INT 9
89970: EQUAL
89971: IFFALSE 89981
// sHack := true ;
89973: LD_ADDR_EXP 105
89977: PUSH
89978: LD_INT 1
89980: ST_TO_ADDR
// if p3 = 10 then
89981: LD_VAR 0 3
89985: PUSH
89986: LD_INT 10
89988: EQUAL
89989: IFFALSE 89999
// sFire := true ;
89991: LD_ADDR_EXP 106
89995: PUSH
89996: LD_INT 1
89998: ST_TO_ADDR
// if p3 = 11 then
89999: LD_VAR 0 3
90003: PUSH
90004: LD_INT 11
90006: EQUAL
90007: IFFALSE 90017
// sRefresh := true ;
90009: LD_ADDR_EXP 107
90013: PUSH
90014: LD_INT 1
90016: ST_TO_ADDR
// if p3 = 12 then
90017: LD_VAR 0 3
90021: PUSH
90022: LD_INT 12
90024: EQUAL
90025: IFFALSE 90035
// sExp := true ;
90027: LD_ADDR_EXP 108
90031: PUSH
90032: LD_INT 1
90034: ST_TO_ADDR
// if p3 = 13 then
90035: LD_VAR 0 3
90039: PUSH
90040: LD_INT 13
90042: EQUAL
90043: IFFALSE 90053
// sDepot := true ;
90045: LD_ADDR_EXP 109
90049: PUSH
90050: LD_INT 1
90052: ST_TO_ADDR
// if p3 = 14 then
90053: LD_VAR 0 3
90057: PUSH
90058: LD_INT 14
90060: EQUAL
90061: IFFALSE 90071
// sFlag := true ;
90063: LD_ADDR_EXP 110
90067: PUSH
90068: LD_INT 1
90070: ST_TO_ADDR
// if p3 = 15 then
90071: LD_VAR 0 3
90075: PUSH
90076: LD_INT 15
90078: EQUAL
90079: IFFALSE 90089
// sKamikadze := true ;
90081: LD_ADDR_EXP 118
90085: PUSH
90086: LD_INT 1
90088: ST_TO_ADDR
// if p3 = 16 then
90089: LD_VAR 0 3
90093: PUSH
90094: LD_INT 16
90096: EQUAL
90097: IFFALSE 90107
// sTroll := true ;
90099: LD_ADDR_EXP 119
90103: PUSH
90104: LD_INT 1
90106: ST_TO_ADDR
// if p3 = 17 then
90107: LD_VAR 0 3
90111: PUSH
90112: LD_INT 17
90114: EQUAL
90115: IFFALSE 90125
// sSlow := true ;
90117: LD_ADDR_EXP 120
90121: PUSH
90122: LD_INT 1
90124: ST_TO_ADDR
// if p3 = 18 then
90125: LD_VAR 0 3
90129: PUSH
90130: LD_INT 18
90132: EQUAL
90133: IFFALSE 90143
// sLack := true ;
90135: LD_ADDR_EXP 121
90139: PUSH
90140: LD_INT 1
90142: ST_TO_ADDR
// if p3 = 19 then
90143: LD_VAR 0 3
90147: PUSH
90148: LD_INT 19
90150: EQUAL
90151: IFFALSE 90161
// sTank := true ;
90153: LD_ADDR_EXP 123
90157: PUSH
90158: LD_INT 1
90160: ST_TO_ADDR
// if p3 = 20 then
90161: LD_VAR 0 3
90165: PUSH
90166: LD_INT 20
90168: EQUAL
90169: IFFALSE 90179
// sRemote := true ;
90171: LD_ADDR_EXP 124
90175: PUSH
90176: LD_INT 1
90178: ST_TO_ADDR
// if p3 = 21 then
90179: LD_VAR 0 3
90183: PUSH
90184: LD_INT 21
90186: EQUAL
90187: IFFALSE 90197
// sPowell := true ;
90189: LD_ADDR_EXP 125
90193: PUSH
90194: LD_INT 1
90196: ST_TO_ADDR
// if p3 = 22 then
90197: LD_VAR 0 3
90201: PUSH
90202: LD_INT 22
90204: EQUAL
90205: IFFALSE 90215
// sTeleport := true ;
90207: LD_ADDR_EXP 128
90211: PUSH
90212: LD_INT 1
90214: ST_TO_ADDR
// if p3 = 23 then
90215: LD_VAR 0 3
90219: PUSH
90220: LD_INT 23
90222: EQUAL
90223: IFFALSE 90233
// sOilTower := true ;
90225: LD_ADDR_EXP 130
90229: PUSH
90230: LD_INT 1
90232: ST_TO_ADDR
// if p3 = 24 then
90233: LD_VAR 0 3
90237: PUSH
90238: LD_INT 24
90240: EQUAL
90241: IFFALSE 90251
// sShovel := true ;
90243: LD_ADDR_EXP 131
90247: PUSH
90248: LD_INT 1
90250: ST_TO_ADDR
// if p3 = 25 then
90251: LD_VAR 0 3
90255: PUSH
90256: LD_INT 25
90258: EQUAL
90259: IFFALSE 90269
// sSheik := true ;
90261: LD_ADDR_EXP 132
90265: PUSH
90266: LD_INT 1
90268: ST_TO_ADDR
// if p3 = 26 then
90269: LD_VAR 0 3
90273: PUSH
90274: LD_INT 26
90276: EQUAL
90277: IFFALSE 90287
// sEarthquake := true ;
90279: LD_ADDR_EXP 134
90283: PUSH
90284: LD_INT 1
90286: ST_TO_ADDR
// if p3 = 27 then
90287: LD_VAR 0 3
90291: PUSH
90292: LD_INT 27
90294: EQUAL
90295: IFFALSE 90305
// sAI := true ;
90297: LD_ADDR_EXP 135
90301: PUSH
90302: LD_INT 1
90304: ST_TO_ADDR
// if p3 = 28 then
90305: LD_VAR 0 3
90309: PUSH
90310: LD_INT 28
90312: EQUAL
90313: IFFALSE 90323
// sCargo := true ;
90315: LD_ADDR_EXP 138
90319: PUSH
90320: LD_INT 1
90322: ST_TO_ADDR
// if p3 = 29 then
90323: LD_VAR 0 3
90327: PUSH
90328: LD_INT 29
90330: EQUAL
90331: IFFALSE 90341
// sDLaser := true ;
90333: LD_ADDR_EXP 139
90337: PUSH
90338: LD_INT 1
90340: ST_TO_ADDR
// if p3 = 30 then
90341: LD_VAR 0 3
90345: PUSH
90346: LD_INT 30
90348: EQUAL
90349: IFFALSE 90359
// sExchange := true ;
90351: LD_ADDR_EXP 140
90355: PUSH
90356: LD_INT 1
90358: ST_TO_ADDR
// if p3 = 31 then
90359: LD_VAR 0 3
90363: PUSH
90364: LD_INT 31
90366: EQUAL
90367: IFFALSE 90377
// sFac := true ;
90369: LD_ADDR_EXP 141
90373: PUSH
90374: LD_INT 1
90376: ST_TO_ADDR
// if p3 = 32 then
90377: LD_VAR 0 3
90381: PUSH
90382: LD_INT 32
90384: EQUAL
90385: IFFALSE 90395
// sPower := true ;
90387: LD_ADDR_EXP 142
90391: PUSH
90392: LD_INT 1
90394: ST_TO_ADDR
// if p3 = 33 then
90395: LD_VAR 0 3
90399: PUSH
90400: LD_INT 33
90402: EQUAL
90403: IFFALSE 90413
// sRandom := true ;
90405: LD_ADDR_EXP 143
90409: PUSH
90410: LD_INT 1
90412: ST_TO_ADDR
// if p3 = 34 then
90413: LD_VAR 0 3
90417: PUSH
90418: LD_INT 34
90420: EQUAL
90421: IFFALSE 90431
// sShield := true ;
90423: LD_ADDR_EXP 144
90427: PUSH
90428: LD_INT 1
90430: ST_TO_ADDR
// if p3 = 35 then
90431: LD_VAR 0 3
90435: PUSH
90436: LD_INT 35
90438: EQUAL
90439: IFFALSE 90449
// sTime := true ;
90441: LD_ADDR_EXP 145
90445: PUSH
90446: LD_INT 1
90448: ST_TO_ADDR
// if p3 = 36 then
90449: LD_VAR 0 3
90453: PUSH
90454: LD_INT 36
90456: EQUAL
90457: IFFALSE 90467
// sTools := true ;
90459: LD_ADDR_EXP 146
90463: PUSH
90464: LD_INT 1
90466: ST_TO_ADDR
// if p3 = 101 then
90467: LD_VAR 0 3
90471: PUSH
90472: LD_INT 101
90474: EQUAL
90475: IFFALSE 90485
// sSold := true ;
90477: LD_ADDR_EXP 111
90481: PUSH
90482: LD_INT 1
90484: ST_TO_ADDR
// if p3 = 102 then
90485: LD_VAR 0 3
90489: PUSH
90490: LD_INT 102
90492: EQUAL
90493: IFFALSE 90503
// sDiff := true ;
90495: LD_ADDR_EXP 112
90499: PUSH
90500: LD_INT 1
90502: ST_TO_ADDR
// if p3 = 103 then
90503: LD_VAR 0 3
90507: PUSH
90508: LD_INT 103
90510: EQUAL
90511: IFFALSE 90521
// sFog := true ;
90513: LD_ADDR_EXP 115
90517: PUSH
90518: LD_INT 1
90520: ST_TO_ADDR
// if p3 = 104 then
90521: LD_VAR 0 3
90525: PUSH
90526: LD_INT 104
90528: EQUAL
90529: IFFALSE 90539
// sReset := true ;
90531: LD_ADDR_EXP 116
90535: PUSH
90536: LD_INT 1
90538: ST_TO_ADDR
// if p3 = 105 then
90539: LD_VAR 0 3
90543: PUSH
90544: LD_INT 105
90546: EQUAL
90547: IFFALSE 90557
// sSun := true ;
90549: LD_ADDR_EXP 117
90553: PUSH
90554: LD_INT 1
90556: ST_TO_ADDR
// if p3 = 106 then
90557: LD_VAR 0 3
90561: PUSH
90562: LD_INT 106
90564: EQUAL
90565: IFFALSE 90575
// sTiger := true ;
90567: LD_ADDR_EXP 113
90571: PUSH
90572: LD_INT 1
90574: ST_TO_ADDR
// if p3 = 107 then
90575: LD_VAR 0 3
90579: PUSH
90580: LD_INT 107
90582: EQUAL
90583: IFFALSE 90593
// sBomb := true ;
90585: LD_ADDR_EXP 114
90589: PUSH
90590: LD_INT 1
90592: ST_TO_ADDR
// if p3 = 108 then
90593: LD_VAR 0 3
90597: PUSH
90598: LD_INT 108
90600: EQUAL
90601: IFFALSE 90611
// sWound := true ;
90603: LD_ADDR_EXP 122
90607: PUSH
90608: LD_INT 1
90610: ST_TO_ADDR
// if p3 = 109 then
90611: LD_VAR 0 3
90615: PUSH
90616: LD_INT 109
90618: EQUAL
90619: IFFALSE 90629
// sBetray := true ;
90621: LD_ADDR_EXP 126
90625: PUSH
90626: LD_INT 1
90628: ST_TO_ADDR
// if p3 = 110 then
90629: LD_VAR 0 3
90633: PUSH
90634: LD_INT 110
90636: EQUAL
90637: IFFALSE 90647
// sContamin := true ;
90639: LD_ADDR_EXP 127
90643: PUSH
90644: LD_INT 1
90646: ST_TO_ADDR
// if p3 = 111 then
90647: LD_VAR 0 3
90651: PUSH
90652: LD_INT 111
90654: EQUAL
90655: IFFALSE 90665
// sOil := true ;
90657: LD_ADDR_EXP 129
90661: PUSH
90662: LD_INT 1
90664: ST_TO_ADDR
// if p3 = 112 then
90665: LD_VAR 0 3
90669: PUSH
90670: LD_INT 112
90672: EQUAL
90673: IFFALSE 90683
// sStu := true ;
90675: LD_ADDR_EXP 133
90679: PUSH
90680: LD_INT 1
90682: ST_TO_ADDR
// if p3 = 113 then
90683: LD_VAR 0 3
90687: PUSH
90688: LD_INT 113
90690: EQUAL
90691: IFFALSE 90701
// sBazooka := true ;
90693: LD_ADDR_EXP 136
90697: PUSH
90698: LD_INT 1
90700: ST_TO_ADDR
// if p3 = 114 then
90701: LD_VAR 0 3
90705: PUSH
90706: LD_INT 114
90708: EQUAL
90709: IFFALSE 90719
// sMortar := true ;
90711: LD_ADDR_EXP 137
90715: PUSH
90716: LD_INT 1
90718: ST_TO_ADDR
// if p3 = 115 then
90719: LD_VAR 0 3
90723: PUSH
90724: LD_INT 115
90726: EQUAL
90727: IFFALSE 90737
// sRanger := true ;
90729: LD_ADDR_EXP 147
90733: PUSH
90734: LD_INT 1
90736: ST_TO_ADDR
// if p3 = 116 then
90737: LD_VAR 0 3
90741: PUSH
90742: LD_INT 116
90744: EQUAL
90745: IFFALSE 90755
// sComputer := true ;
90747: LD_ADDR_EXP 148
90751: PUSH
90752: LD_INT 1
90754: ST_TO_ADDR
// if p3 = 117 then
90755: LD_VAR 0 3
90759: PUSH
90760: LD_INT 117
90762: EQUAL
90763: IFFALSE 90773
// s30 := true ;
90765: LD_ADDR_EXP 149
90769: PUSH
90770: LD_INT 1
90772: ST_TO_ADDR
// if p3 = 118 then
90773: LD_VAR 0 3
90777: PUSH
90778: LD_INT 118
90780: EQUAL
90781: IFFALSE 90791
// s60 := true ;
90783: LD_ADDR_EXP 150
90787: PUSH
90788: LD_INT 1
90790: ST_TO_ADDR
// end ; if p2 = 101 then
90791: LD_VAR 0 2
90795: PUSH
90796: LD_INT 101
90798: EQUAL
90799: IFFALSE 90927
// begin case p3 of 1 :
90801: LD_VAR 0 3
90805: PUSH
90806: LD_INT 1
90808: DOUBLE
90809: EQUAL
90810: IFTRUE 90814
90812: GO 90821
90814: POP
// hHackUnlimitedResources ; 2 :
90815: CALL 103025 0 0
90819: GO 90927
90821: LD_INT 2
90823: DOUBLE
90824: EQUAL
90825: IFTRUE 90829
90827: GO 90836
90829: POP
// hHackSetLevel10 ; 3 :
90830: CALL 103158 0 0
90834: GO 90927
90836: LD_INT 3
90838: DOUBLE
90839: EQUAL
90840: IFTRUE 90844
90842: GO 90851
90844: POP
// hHackSetLevel10YourUnits ; 4 :
90845: CALL 103243 0 0
90849: GO 90927
90851: LD_INT 4
90853: DOUBLE
90854: EQUAL
90855: IFTRUE 90859
90857: GO 90866
90859: POP
// hHackInvincible ; 5 :
90860: CALL 103691 0 0
90864: GO 90927
90866: LD_INT 5
90868: DOUBLE
90869: EQUAL
90870: IFTRUE 90874
90872: GO 90881
90874: POP
// hHackInvisible ; 6 :
90875: CALL 103802 0 0
90879: GO 90927
90881: LD_INT 6
90883: DOUBLE
90884: EQUAL
90885: IFTRUE 90889
90887: GO 90896
90889: POP
// hHackChangeYourSide ; 7 :
90890: CALL 103859 0 0
90894: GO 90927
90896: LD_INT 7
90898: DOUBLE
90899: EQUAL
90900: IFTRUE 90904
90902: GO 90911
90904: POP
// hHackChangeUnitSide ; 8 :
90905: CALL 103901 0 0
90909: GO 90927
90911: LD_INT 8
90913: DOUBLE
90914: EQUAL
90915: IFTRUE 90919
90917: GO 90926
90919: POP
// hHackFog ; end ;
90920: CALL 104002 0 0
90924: GO 90927
90926: POP
// end ; end ;
90927: LD_VAR 0 7
90931: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
90932: GO 90934
90934: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90935: LD_STRING initStreamRollete();
90937: PPUSH
90938: CALL_OW 559
// InitStreamMode ;
90942: CALL 90954 0 0
// DefineStreamItems ( false ) ;
90946: LD_INT 0
90948: PPUSH
90949: CALL 91418 0 1
// end ;
90953: END
// function InitStreamMode ; begin
90954: LD_INT 0
90956: PPUSH
// streamModeActive := false ;
90957: LD_ADDR_EXP 94
90961: PUSH
90962: LD_INT 0
90964: ST_TO_ADDR
// normalCounter := 36 ;
90965: LD_ADDR_EXP 95
90969: PUSH
90970: LD_INT 36
90972: ST_TO_ADDR
// hardcoreCounter := 18 ;
90973: LD_ADDR_EXP 96
90977: PUSH
90978: LD_INT 18
90980: ST_TO_ADDR
// sRocket := false ;
90981: LD_ADDR_EXP 99
90985: PUSH
90986: LD_INT 0
90988: ST_TO_ADDR
// sSpeed := false ;
90989: LD_ADDR_EXP 98
90993: PUSH
90994: LD_INT 0
90996: ST_TO_ADDR
// sEngine := false ;
90997: LD_ADDR_EXP 100
91001: PUSH
91002: LD_INT 0
91004: ST_TO_ADDR
// sSpec := false ;
91005: LD_ADDR_EXP 97
91009: PUSH
91010: LD_INT 0
91012: ST_TO_ADDR
// sLevel := false ;
91013: LD_ADDR_EXP 101
91017: PUSH
91018: LD_INT 0
91020: ST_TO_ADDR
// sArmoury := false ;
91021: LD_ADDR_EXP 102
91025: PUSH
91026: LD_INT 0
91028: ST_TO_ADDR
// sRadar := false ;
91029: LD_ADDR_EXP 103
91033: PUSH
91034: LD_INT 0
91036: ST_TO_ADDR
// sBunker := false ;
91037: LD_ADDR_EXP 104
91041: PUSH
91042: LD_INT 0
91044: ST_TO_ADDR
// sHack := false ;
91045: LD_ADDR_EXP 105
91049: PUSH
91050: LD_INT 0
91052: ST_TO_ADDR
// sFire := false ;
91053: LD_ADDR_EXP 106
91057: PUSH
91058: LD_INT 0
91060: ST_TO_ADDR
// sRefresh := false ;
91061: LD_ADDR_EXP 107
91065: PUSH
91066: LD_INT 0
91068: ST_TO_ADDR
// sExp := false ;
91069: LD_ADDR_EXP 108
91073: PUSH
91074: LD_INT 0
91076: ST_TO_ADDR
// sDepot := false ;
91077: LD_ADDR_EXP 109
91081: PUSH
91082: LD_INT 0
91084: ST_TO_ADDR
// sFlag := false ;
91085: LD_ADDR_EXP 110
91089: PUSH
91090: LD_INT 0
91092: ST_TO_ADDR
// sKamikadze := false ;
91093: LD_ADDR_EXP 118
91097: PUSH
91098: LD_INT 0
91100: ST_TO_ADDR
// sTroll := false ;
91101: LD_ADDR_EXP 119
91105: PUSH
91106: LD_INT 0
91108: ST_TO_ADDR
// sSlow := false ;
91109: LD_ADDR_EXP 120
91113: PUSH
91114: LD_INT 0
91116: ST_TO_ADDR
// sLack := false ;
91117: LD_ADDR_EXP 121
91121: PUSH
91122: LD_INT 0
91124: ST_TO_ADDR
// sTank := false ;
91125: LD_ADDR_EXP 123
91129: PUSH
91130: LD_INT 0
91132: ST_TO_ADDR
// sRemote := false ;
91133: LD_ADDR_EXP 124
91137: PUSH
91138: LD_INT 0
91140: ST_TO_ADDR
// sPowell := false ;
91141: LD_ADDR_EXP 125
91145: PUSH
91146: LD_INT 0
91148: ST_TO_ADDR
// sTeleport := false ;
91149: LD_ADDR_EXP 128
91153: PUSH
91154: LD_INT 0
91156: ST_TO_ADDR
// sOilTower := false ;
91157: LD_ADDR_EXP 130
91161: PUSH
91162: LD_INT 0
91164: ST_TO_ADDR
// sShovel := false ;
91165: LD_ADDR_EXP 131
91169: PUSH
91170: LD_INT 0
91172: ST_TO_ADDR
// sSheik := false ;
91173: LD_ADDR_EXP 132
91177: PUSH
91178: LD_INT 0
91180: ST_TO_ADDR
// sEarthquake := false ;
91181: LD_ADDR_EXP 134
91185: PUSH
91186: LD_INT 0
91188: ST_TO_ADDR
// sAI := false ;
91189: LD_ADDR_EXP 135
91193: PUSH
91194: LD_INT 0
91196: ST_TO_ADDR
// sCargo := false ;
91197: LD_ADDR_EXP 138
91201: PUSH
91202: LD_INT 0
91204: ST_TO_ADDR
// sDLaser := false ;
91205: LD_ADDR_EXP 139
91209: PUSH
91210: LD_INT 0
91212: ST_TO_ADDR
// sExchange := false ;
91213: LD_ADDR_EXP 140
91217: PUSH
91218: LD_INT 0
91220: ST_TO_ADDR
// sFac := false ;
91221: LD_ADDR_EXP 141
91225: PUSH
91226: LD_INT 0
91228: ST_TO_ADDR
// sPower := false ;
91229: LD_ADDR_EXP 142
91233: PUSH
91234: LD_INT 0
91236: ST_TO_ADDR
// sRandom := false ;
91237: LD_ADDR_EXP 143
91241: PUSH
91242: LD_INT 0
91244: ST_TO_ADDR
// sShield := false ;
91245: LD_ADDR_EXP 144
91249: PUSH
91250: LD_INT 0
91252: ST_TO_ADDR
// sTime := false ;
91253: LD_ADDR_EXP 145
91257: PUSH
91258: LD_INT 0
91260: ST_TO_ADDR
// sTools := false ;
91261: LD_ADDR_EXP 146
91265: PUSH
91266: LD_INT 0
91268: ST_TO_ADDR
// sSold := false ;
91269: LD_ADDR_EXP 111
91273: PUSH
91274: LD_INT 0
91276: ST_TO_ADDR
// sDiff := false ;
91277: LD_ADDR_EXP 112
91281: PUSH
91282: LD_INT 0
91284: ST_TO_ADDR
// sFog := false ;
91285: LD_ADDR_EXP 115
91289: PUSH
91290: LD_INT 0
91292: ST_TO_ADDR
// sReset := false ;
91293: LD_ADDR_EXP 116
91297: PUSH
91298: LD_INT 0
91300: ST_TO_ADDR
// sSun := false ;
91301: LD_ADDR_EXP 117
91305: PUSH
91306: LD_INT 0
91308: ST_TO_ADDR
// sTiger := false ;
91309: LD_ADDR_EXP 113
91313: PUSH
91314: LD_INT 0
91316: ST_TO_ADDR
// sBomb := false ;
91317: LD_ADDR_EXP 114
91321: PUSH
91322: LD_INT 0
91324: ST_TO_ADDR
// sWound := false ;
91325: LD_ADDR_EXP 122
91329: PUSH
91330: LD_INT 0
91332: ST_TO_ADDR
// sBetray := false ;
91333: LD_ADDR_EXP 126
91337: PUSH
91338: LD_INT 0
91340: ST_TO_ADDR
// sContamin := false ;
91341: LD_ADDR_EXP 127
91345: PUSH
91346: LD_INT 0
91348: ST_TO_ADDR
// sOil := false ;
91349: LD_ADDR_EXP 129
91353: PUSH
91354: LD_INT 0
91356: ST_TO_ADDR
// sStu := false ;
91357: LD_ADDR_EXP 133
91361: PUSH
91362: LD_INT 0
91364: ST_TO_ADDR
// sBazooka := false ;
91365: LD_ADDR_EXP 136
91369: PUSH
91370: LD_INT 0
91372: ST_TO_ADDR
// sMortar := false ;
91373: LD_ADDR_EXP 137
91377: PUSH
91378: LD_INT 0
91380: ST_TO_ADDR
// sRanger := false ;
91381: LD_ADDR_EXP 147
91385: PUSH
91386: LD_INT 0
91388: ST_TO_ADDR
// sComputer := false ;
91389: LD_ADDR_EXP 148
91393: PUSH
91394: LD_INT 0
91396: ST_TO_ADDR
// s30 := false ;
91397: LD_ADDR_EXP 149
91401: PUSH
91402: LD_INT 0
91404: ST_TO_ADDR
// s60 := false ;
91405: LD_ADDR_EXP 150
91409: PUSH
91410: LD_INT 0
91412: ST_TO_ADDR
// end ;
91413: LD_VAR 0 1
91417: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91418: LD_INT 0
91420: PPUSH
91421: PPUSH
91422: PPUSH
91423: PPUSH
91424: PPUSH
91425: PPUSH
91426: PPUSH
// result := [ ] ;
91427: LD_ADDR_VAR 0 2
91431: PUSH
91432: EMPTY
91433: ST_TO_ADDR
// if campaign_id = 1 then
91434: LD_OWVAR 69
91438: PUSH
91439: LD_INT 1
91441: EQUAL
91442: IFFALSE 94608
// begin case mission_number of 1 :
91444: LD_OWVAR 70
91448: PUSH
91449: LD_INT 1
91451: DOUBLE
91452: EQUAL
91453: IFTRUE 91457
91455: GO 91533
91457: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91458: LD_ADDR_VAR 0 2
91462: PUSH
91463: LD_INT 2
91465: PUSH
91466: LD_INT 4
91468: PUSH
91469: LD_INT 11
91471: PUSH
91472: LD_INT 12
91474: PUSH
91475: LD_INT 15
91477: PUSH
91478: LD_INT 16
91480: PUSH
91481: LD_INT 22
91483: PUSH
91484: LD_INT 23
91486: PUSH
91487: LD_INT 26
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: PUSH
91501: LD_INT 101
91503: PUSH
91504: LD_INT 102
91506: PUSH
91507: LD_INT 106
91509: PUSH
91510: LD_INT 116
91512: PUSH
91513: LD_INT 117
91515: PUSH
91516: LD_INT 118
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: ST_TO_ADDR
91531: GO 94606
91533: LD_INT 2
91535: DOUBLE
91536: EQUAL
91537: IFTRUE 91541
91539: GO 91625
91541: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91542: LD_ADDR_VAR 0 2
91546: PUSH
91547: LD_INT 2
91549: PUSH
91550: LD_INT 4
91552: PUSH
91553: LD_INT 11
91555: PUSH
91556: LD_INT 12
91558: PUSH
91559: LD_INT 15
91561: PUSH
91562: LD_INT 16
91564: PUSH
91565: LD_INT 22
91567: PUSH
91568: LD_INT 23
91570: PUSH
91571: LD_INT 26
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: LIST
91581: LIST
91582: LIST
91583: LIST
91584: PUSH
91585: LD_INT 101
91587: PUSH
91588: LD_INT 102
91590: PUSH
91591: LD_INT 105
91593: PUSH
91594: LD_INT 106
91596: PUSH
91597: LD_INT 108
91599: PUSH
91600: LD_INT 116
91602: PUSH
91603: LD_INT 117
91605: PUSH
91606: LD_INT 118
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: ST_TO_ADDR
91623: GO 94606
91625: LD_INT 3
91627: DOUBLE
91628: EQUAL
91629: IFTRUE 91633
91631: GO 91721
91633: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91634: LD_ADDR_VAR 0 2
91638: PUSH
91639: LD_INT 2
91641: PUSH
91642: LD_INT 4
91644: PUSH
91645: LD_INT 5
91647: PUSH
91648: LD_INT 11
91650: PUSH
91651: LD_INT 12
91653: PUSH
91654: LD_INT 15
91656: PUSH
91657: LD_INT 16
91659: PUSH
91660: LD_INT 22
91662: PUSH
91663: LD_INT 26
91665: PUSH
91666: LD_INT 36
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 101
91683: PUSH
91684: LD_INT 102
91686: PUSH
91687: LD_INT 105
91689: PUSH
91690: LD_INT 106
91692: PUSH
91693: LD_INT 108
91695: PUSH
91696: LD_INT 116
91698: PUSH
91699: LD_INT 117
91701: PUSH
91702: LD_INT 118
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: ST_TO_ADDR
91719: GO 94606
91721: LD_INT 4
91723: DOUBLE
91724: EQUAL
91725: IFTRUE 91729
91727: GO 91825
91729: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
91730: LD_ADDR_VAR 0 2
91734: PUSH
91735: LD_INT 2
91737: PUSH
91738: LD_INT 4
91740: PUSH
91741: LD_INT 5
91743: PUSH
91744: LD_INT 8
91746: PUSH
91747: LD_INT 11
91749: PUSH
91750: LD_INT 12
91752: PUSH
91753: LD_INT 15
91755: PUSH
91756: LD_INT 16
91758: PUSH
91759: LD_INT 22
91761: PUSH
91762: LD_INT 23
91764: PUSH
91765: LD_INT 26
91767: PUSH
91768: LD_INT 36
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 101
91787: PUSH
91788: LD_INT 102
91790: PUSH
91791: LD_INT 105
91793: PUSH
91794: LD_INT 106
91796: PUSH
91797: LD_INT 108
91799: PUSH
91800: LD_INT 116
91802: PUSH
91803: LD_INT 117
91805: PUSH
91806: LD_INT 118
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: ST_TO_ADDR
91823: GO 94606
91825: LD_INT 5
91827: DOUBLE
91828: EQUAL
91829: IFTRUE 91833
91831: GO 91945
91833: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
91834: LD_ADDR_VAR 0 2
91838: PUSH
91839: LD_INT 2
91841: PUSH
91842: LD_INT 4
91844: PUSH
91845: LD_INT 5
91847: PUSH
91848: LD_INT 6
91850: PUSH
91851: LD_INT 8
91853: PUSH
91854: LD_INT 11
91856: PUSH
91857: LD_INT 12
91859: PUSH
91860: LD_INT 15
91862: PUSH
91863: LD_INT 16
91865: PUSH
91866: LD_INT 22
91868: PUSH
91869: LD_INT 23
91871: PUSH
91872: LD_INT 25
91874: PUSH
91875: LD_INT 26
91877: PUSH
91878: LD_INT 36
91880: PUSH
91881: EMPTY
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: PUSH
91897: LD_INT 101
91899: PUSH
91900: LD_INT 102
91902: PUSH
91903: LD_INT 105
91905: PUSH
91906: LD_INT 106
91908: PUSH
91909: LD_INT 108
91911: PUSH
91912: LD_INT 109
91914: PUSH
91915: LD_INT 112
91917: PUSH
91918: LD_INT 116
91920: PUSH
91921: LD_INT 117
91923: PUSH
91924: LD_INT 118
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: ST_TO_ADDR
91943: GO 94606
91945: LD_INT 6
91947: DOUBLE
91948: EQUAL
91949: IFTRUE 91953
91951: GO 92085
91953: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
91954: LD_ADDR_VAR 0 2
91958: PUSH
91959: LD_INT 2
91961: PUSH
91962: LD_INT 4
91964: PUSH
91965: LD_INT 5
91967: PUSH
91968: LD_INT 6
91970: PUSH
91971: LD_INT 8
91973: PUSH
91974: LD_INT 11
91976: PUSH
91977: LD_INT 12
91979: PUSH
91980: LD_INT 15
91982: PUSH
91983: LD_INT 16
91985: PUSH
91986: LD_INT 20
91988: PUSH
91989: LD_INT 21
91991: PUSH
91992: LD_INT 22
91994: PUSH
91995: LD_INT 23
91997: PUSH
91998: LD_INT 25
92000: PUSH
92001: LD_INT 26
92003: PUSH
92004: LD_INT 30
92006: PUSH
92007: LD_INT 31
92009: PUSH
92010: LD_INT 32
92012: PUSH
92013: LD_INT 36
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 101
92039: PUSH
92040: LD_INT 102
92042: PUSH
92043: LD_INT 105
92045: PUSH
92046: LD_INT 106
92048: PUSH
92049: LD_INT 108
92051: PUSH
92052: LD_INT 109
92054: PUSH
92055: LD_INT 112
92057: PUSH
92058: LD_INT 116
92060: PUSH
92061: LD_INT 117
92063: PUSH
92064: LD_INT 118
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: PUSH
92079: EMPTY
92080: LIST
92081: LIST
92082: ST_TO_ADDR
92083: GO 94606
92085: LD_INT 7
92087: DOUBLE
92088: EQUAL
92089: IFTRUE 92093
92091: GO 92205
92093: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92094: LD_ADDR_VAR 0 2
92098: PUSH
92099: LD_INT 2
92101: PUSH
92102: LD_INT 4
92104: PUSH
92105: LD_INT 5
92107: PUSH
92108: LD_INT 7
92110: PUSH
92111: LD_INT 11
92113: PUSH
92114: LD_INT 12
92116: PUSH
92117: LD_INT 15
92119: PUSH
92120: LD_INT 16
92122: PUSH
92123: LD_INT 20
92125: PUSH
92126: LD_INT 21
92128: PUSH
92129: LD_INT 22
92131: PUSH
92132: LD_INT 23
92134: PUSH
92135: LD_INT 25
92137: PUSH
92138: LD_INT 26
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 101
92159: PUSH
92160: LD_INT 102
92162: PUSH
92163: LD_INT 103
92165: PUSH
92166: LD_INT 105
92168: PUSH
92169: LD_INT 106
92171: PUSH
92172: LD_INT 108
92174: PUSH
92175: LD_INT 112
92177: PUSH
92178: LD_INT 116
92180: PUSH
92181: LD_INT 117
92183: PUSH
92184: LD_INT 118
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: LIST
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: ST_TO_ADDR
92203: GO 94606
92205: LD_INT 8
92207: DOUBLE
92208: EQUAL
92209: IFTRUE 92213
92211: GO 92353
92213: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92214: LD_ADDR_VAR 0 2
92218: PUSH
92219: LD_INT 2
92221: PUSH
92222: LD_INT 4
92224: PUSH
92225: LD_INT 5
92227: PUSH
92228: LD_INT 6
92230: PUSH
92231: LD_INT 7
92233: PUSH
92234: LD_INT 8
92236: PUSH
92237: LD_INT 11
92239: PUSH
92240: LD_INT 12
92242: PUSH
92243: LD_INT 15
92245: PUSH
92246: LD_INT 16
92248: PUSH
92249: LD_INT 20
92251: PUSH
92252: LD_INT 21
92254: PUSH
92255: LD_INT 22
92257: PUSH
92258: LD_INT 23
92260: PUSH
92261: LD_INT 25
92263: PUSH
92264: LD_INT 26
92266: PUSH
92267: LD_INT 30
92269: PUSH
92270: LD_INT 31
92272: PUSH
92273: LD_INT 32
92275: PUSH
92276: LD_INT 36
92278: PUSH
92279: EMPTY
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: PUSH
92301: LD_INT 101
92303: PUSH
92304: LD_INT 102
92306: PUSH
92307: LD_INT 103
92309: PUSH
92310: LD_INT 105
92312: PUSH
92313: LD_INT 106
92315: PUSH
92316: LD_INT 108
92318: PUSH
92319: LD_INT 109
92321: PUSH
92322: LD_INT 112
92324: PUSH
92325: LD_INT 116
92327: PUSH
92328: LD_INT 117
92330: PUSH
92331: LD_INT 118
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: ST_TO_ADDR
92351: GO 94606
92353: LD_INT 9
92355: DOUBLE
92356: EQUAL
92357: IFTRUE 92361
92359: GO 92509
92361: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92362: LD_ADDR_VAR 0 2
92366: PUSH
92367: LD_INT 2
92369: PUSH
92370: LD_INT 4
92372: PUSH
92373: LD_INT 5
92375: PUSH
92376: LD_INT 6
92378: PUSH
92379: LD_INT 7
92381: PUSH
92382: LD_INT 8
92384: PUSH
92385: LD_INT 11
92387: PUSH
92388: LD_INT 12
92390: PUSH
92391: LD_INT 15
92393: PUSH
92394: LD_INT 16
92396: PUSH
92397: LD_INT 20
92399: PUSH
92400: LD_INT 21
92402: PUSH
92403: LD_INT 22
92405: PUSH
92406: LD_INT 23
92408: PUSH
92409: LD_INT 25
92411: PUSH
92412: LD_INT 26
92414: PUSH
92415: LD_INT 28
92417: PUSH
92418: LD_INT 30
92420: PUSH
92421: LD_INT 31
92423: PUSH
92424: LD_INT 32
92426: PUSH
92427: LD_INT 36
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 101
92455: PUSH
92456: LD_INT 102
92458: PUSH
92459: LD_INT 103
92461: PUSH
92462: LD_INT 105
92464: PUSH
92465: LD_INT 106
92467: PUSH
92468: LD_INT 108
92470: PUSH
92471: LD_INT 109
92473: PUSH
92474: LD_INT 112
92476: PUSH
92477: LD_INT 114
92479: PUSH
92480: LD_INT 116
92482: PUSH
92483: LD_INT 117
92485: PUSH
92486: LD_INT 118
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: ST_TO_ADDR
92507: GO 94606
92509: LD_INT 10
92511: DOUBLE
92512: EQUAL
92513: IFTRUE 92517
92515: GO 92713
92517: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92518: LD_ADDR_VAR 0 2
92522: PUSH
92523: LD_INT 2
92525: PUSH
92526: LD_INT 4
92528: PUSH
92529: LD_INT 5
92531: PUSH
92532: LD_INT 6
92534: PUSH
92535: LD_INT 7
92537: PUSH
92538: LD_INT 8
92540: PUSH
92541: LD_INT 9
92543: PUSH
92544: LD_INT 10
92546: PUSH
92547: LD_INT 11
92549: PUSH
92550: LD_INT 12
92552: PUSH
92553: LD_INT 13
92555: PUSH
92556: LD_INT 14
92558: PUSH
92559: LD_INT 15
92561: PUSH
92562: LD_INT 16
92564: PUSH
92565: LD_INT 17
92567: PUSH
92568: LD_INT 18
92570: PUSH
92571: LD_INT 19
92573: PUSH
92574: LD_INT 20
92576: PUSH
92577: LD_INT 21
92579: PUSH
92580: LD_INT 22
92582: PUSH
92583: LD_INT 23
92585: PUSH
92586: LD_INT 24
92588: PUSH
92589: LD_INT 25
92591: PUSH
92592: LD_INT 26
92594: PUSH
92595: LD_INT 28
92597: PUSH
92598: LD_INT 30
92600: PUSH
92601: LD_INT 31
92603: PUSH
92604: LD_INT 32
92606: PUSH
92607: LD_INT 36
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 101
92643: PUSH
92644: LD_INT 102
92646: PUSH
92647: LD_INT 103
92649: PUSH
92650: LD_INT 104
92652: PUSH
92653: LD_INT 105
92655: PUSH
92656: LD_INT 106
92658: PUSH
92659: LD_INT 107
92661: PUSH
92662: LD_INT 108
92664: PUSH
92665: LD_INT 109
92667: PUSH
92668: LD_INT 110
92670: PUSH
92671: LD_INT 111
92673: PUSH
92674: LD_INT 112
92676: PUSH
92677: LD_INT 114
92679: PUSH
92680: LD_INT 116
92682: PUSH
92683: LD_INT 117
92685: PUSH
92686: LD_INT 118
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: ST_TO_ADDR
92711: GO 94606
92713: LD_INT 11
92715: DOUBLE
92716: EQUAL
92717: IFTRUE 92721
92719: GO 92925
92721: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
92722: LD_ADDR_VAR 0 2
92726: PUSH
92727: LD_INT 2
92729: PUSH
92730: LD_INT 3
92732: PUSH
92733: LD_INT 4
92735: PUSH
92736: LD_INT 5
92738: PUSH
92739: LD_INT 6
92741: PUSH
92742: LD_INT 7
92744: PUSH
92745: LD_INT 8
92747: PUSH
92748: LD_INT 9
92750: PUSH
92751: LD_INT 10
92753: PUSH
92754: LD_INT 11
92756: PUSH
92757: LD_INT 12
92759: PUSH
92760: LD_INT 13
92762: PUSH
92763: LD_INT 14
92765: PUSH
92766: LD_INT 15
92768: PUSH
92769: LD_INT 16
92771: PUSH
92772: LD_INT 17
92774: PUSH
92775: LD_INT 18
92777: PUSH
92778: LD_INT 19
92780: PUSH
92781: LD_INT 20
92783: PUSH
92784: LD_INT 21
92786: PUSH
92787: LD_INT 22
92789: PUSH
92790: LD_INT 23
92792: PUSH
92793: LD_INT 24
92795: PUSH
92796: LD_INT 25
92798: PUSH
92799: LD_INT 26
92801: PUSH
92802: LD_INT 28
92804: PUSH
92805: LD_INT 30
92807: PUSH
92808: LD_INT 31
92810: PUSH
92811: LD_INT 32
92813: PUSH
92814: LD_INT 34
92816: PUSH
92817: LD_INT 36
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: PUSH
92853: LD_INT 101
92855: PUSH
92856: LD_INT 102
92858: PUSH
92859: LD_INT 103
92861: PUSH
92862: LD_INT 104
92864: PUSH
92865: LD_INT 105
92867: PUSH
92868: LD_INT 106
92870: PUSH
92871: LD_INT 107
92873: PUSH
92874: LD_INT 108
92876: PUSH
92877: LD_INT 109
92879: PUSH
92880: LD_INT 110
92882: PUSH
92883: LD_INT 111
92885: PUSH
92886: LD_INT 112
92888: PUSH
92889: LD_INT 114
92891: PUSH
92892: LD_INT 116
92894: PUSH
92895: LD_INT 117
92897: PUSH
92898: LD_INT 118
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: ST_TO_ADDR
92923: GO 94606
92925: LD_INT 12
92927: DOUBLE
92928: EQUAL
92929: IFTRUE 92933
92931: GO 93153
92933: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
92934: LD_ADDR_VAR 0 2
92938: PUSH
92939: LD_INT 1
92941: PUSH
92942: LD_INT 2
92944: PUSH
92945: LD_INT 3
92947: PUSH
92948: LD_INT 4
92950: PUSH
92951: LD_INT 5
92953: PUSH
92954: LD_INT 6
92956: PUSH
92957: LD_INT 7
92959: PUSH
92960: LD_INT 8
92962: PUSH
92963: LD_INT 9
92965: PUSH
92966: LD_INT 10
92968: PUSH
92969: LD_INT 11
92971: PUSH
92972: LD_INT 12
92974: PUSH
92975: LD_INT 13
92977: PUSH
92978: LD_INT 14
92980: PUSH
92981: LD_INT 15
92983: PUSH
92984: LD_INT 16
92986: PUSH
92987: LD_INT 17
92989: PUSH
92990: LD_INT 18
92992: PUSH
92993: LD_INT 19
92995: PUSH
92996: LD_INT 20
92998: PUSH
92999: LD_INT 21
93001: PUSH
93002: LD_INT 22
93004: PUSH
93005: LD_INT 23
93007: PUSH
93008: LD_INT 24
93010: PUSH
93011: LD_INT 25
93013: PUSH
93014: LD_INT 26
93016: PUSH
93017: LD_INT 27
93019: PUSH
93020: LD_INT 28
93022: PUSH
93023: LD_INT 30
93025: PUSH
93026: LD_INT 31
93028: PUSH
93029: LD_INT 32
93031: PUSH
93032: LD_INT 33
93034: PUSH
93035: LD_INT 34
93037: PUSH
93038: LD_INT 36
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: PUSH
93077: LD_INT 101
93079: PUSH
93080: LD_INT 102
93082: PUSH
93083: LD_INT 103
93085: PUSH
93086: LD_INT 104
93088: PUSH
93089: LD_INT 105
93091: PUSH
93092: LD_INT 106
93094: PUSH
93095: LD_INT 107
93097: PUSH
93098: LD_INT 108
93100: PUSH
93101: LD_INT 109
93103: PUSH
93104: LD_INT 110
93106: PUSH
93107: LD_INT 111
93109: PUSH
93110: LD_INT 112
93112: PUSH
93113: LD_INT 113
93115: PUSH
93116: LD_INT 114
93118: PUSH
93119: LD_INT 116
93121: PUSH
93122: LD_INT 117
93124: PUSH
93125: LD_INT 118
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: ST_TO_ADDR
93151: GO 94606
93153: LD_INT 13
93155: DOUBLE
93156: EQUAL
93157: IFTRUE 93161
93159: GO 93369
93161: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93162: LD_ADDR_VAR 0 2
93166: PUSH
93167: LD_INT 1
93169: PUSH
93170: LD_INT 2
93172: PUSH
93173: LD_INT 3
93175: PUSH
93176: LD_INT 4
93178: PUSH
93179: LD_INT 5
93181: PUSH
93182: LD_INT 8
93184: PUSH
93185: LD_INT 9
93187: PUSH
93188: LD_INT 10
93190: PUSH
93191: LD_INT 11
93193: PUSH
93194: LD_INT 12
93196: PUSH
93197: LD_INT 14
93199: PUSH
93200: LD_INT 15
93202: PUSH
93203: LD_INT 16
93205: PUSH
93206: LD_INT 17
93208: PUSH
93209: LD_INT 18
93211: PUSH
93212: LD_INT 19
93214: PUSH
93215: LD_INT 20
93217: PUSH
93218: LD_INT 21
93220: PUSH
93221: LD_INT 22
93223: PUSH
93224: LD_INT 23
93226: PUSH
93227: LD_INT 24
93229: PUSH
93230: LD_INT 25
93232: PUSH
93233: LD_INT 26
93235: PUSH
93236: LD_INT 27
93238: PUSH
93239: LD_INT 28
93241: PUSH
93242: LD_INT 30
93244: PUSH
93245: LD_INT 31
93247: PUSH
93248: LD_INT 32
93250: PUSH
93251: LD_INT 33
93253: PUSH
93254: LD_INT 34
93256: PUSH
93257: LD_INT 36
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: PUSH
93293: LD_INT 101
93295: PUSH
93296: LD_INT 102
93298: PUSH
93299: LD_INT 103
93301: PUSH
93302: LD_INT 104
93304: PUSH
93305: LD_INT 105
93307: PUSH
93308: LD_INT 106
93310: PUSH
93311: LD_INT 107
93313: PUSH
93314: LD_INT 108
93316: PUSH
93317: LD_INT 109
93319: PUSH
93320: LD_INT 110
93322: PUSH
93323: LD_INT 111
93325: PUSH
93326: LD_INT 112
93328: PUSH
93329: LD_INT 113
93331: PUSH
93332: LD_INT 114
93334: PUSH
93335: LD_INT 116
93337: PUSH
93338: LD_INT 117
93340: PUSH
93341: LD_INT 118
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: ST_TO_ADDR
93367: GO 94606
93369: LD_INT 14
93371: DOUBLE
93372: EQUAL
93373: IFTRUE 93377
93375: GO 93601
93377: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93378: LD_ADDR_VAR 0 2
93382: PUSH
93383: LD_INT 1
93385: PUSH
93386: LD_INT 2
93388: PUSH
93389: LD_INT 3
93391: PUSH
93392: LD_INT 4
93394: PUSH
93395: LD_INT 5
93397: PUSH
93398: LD_INT 6
93400: PUSH
93401: LD_INT 7
93403: PUSH
93404: LD_INT 8
93406: PUSH
93407: LD_INT 9
93409: PUSH
93410: LD_INT 10
93412: PUSH
93413: LD_INT 11
93415: PUSH
93416: LD_INT 12
93418: PUSH
93419: LD_INT 13
93421: PUSH
93422: LD_INT 14
93424: PUSH
93425: LD_INT 15
93427: PUSH
93428: LD_INT 16
93430: PUSH
93431: LD_INT 17
93433: PUSH
93434: LD_INT 18
93436: PUSH
93437: LD_INT 19
93439: PUSH
93440: LD_INT 20
93442: PUSH
93443: LD_INT 21
93445: PUSH
93446: LD_INT 22
93448: PUSH
93449: LD_INT 23
93451: PUSH
93452: LD_INT 24
93454: PUSH
93455: LD_INT 25
93457: PUSH
93458: LD_INT 26
93460: PUSH
93461: LD_INT 27
93463: PUSH
93464: LD_INT 28
93466: PUSH
93467: LD_INT 29
93469: PUSH
93470: LD_INT 30
93472: PUSH
93473: LD_INT 31
93475: PUSH
93476: LD_INT 32
93478: PUSH
93479: LD_INT 33
93481: PUSH
93482: LD_INT 34
93484: PUSH
93485: LD_INT 36
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: PUSH
93525: LD_INT 101
93527: PUSH
93528: LD_INT 102
93530: PUSH
93531: LD_INT 103
93533: PUSH
93534: LD_INT 104
93536: PUSH
93537: LD_INT 105
93539: PUSH
93540: LD_INT 106
93542: PUSH
93543: LD_INT 107
93545: PUSH
93546: LD_INT 108
93548: PUSH
93549: LD_INT 109
93551: PUSH
93552: LD_INT 110
93554: PUSH
93555: LD_INT 111
93557: PUSH
93558: LD_INT 112
93560: PUSH
93561: LD_INT 113
93563: PUSH
93564: LD_INT 114
93566: PUSH
93567: LD_INT 116
93569: PUSH
93570: LD_INT 117
93572: PUSH
93573: LD_INT 118
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: ST_TO_ADDR
93599: GO 94606
93601: LD_INT 15
93603: DOUBLE
93604: EQUAL
93605: IFTRUE 93609
93607: GO 93833
93609: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93610: LD_ADDR_VAR 0 2
93614: PUSH
93615: LD_INT 1
93617: PUSH
93618: LD_INT 2
93620: PUSH
93621: LD_INT 3
93623: PUSH
93624: LD_INT 4
93626: PUSH
93627: LD_INT 5
93629: PUSH
93630: LD_INT 6
93632: PUSH
93633: LD_INT 7
93635: PUSH
93636: LD_INT 8
93638: PUSH
93639: LD_INT 9
93641: PUSH
93642: LD_INT 10
93644: PUSH
93645: LD_INT 11
93647: PUSH
93648: LD_INT 12
93650: PUSH
93651: LD_INT 13
93653: PUSH
93654: LD_INT 14
93656: PUSH
93657: LD_INT 15
93659: PUSH
93660: LD_INT 16
93662: PUSH
93663: LD_INT 17
93665: PUSH
93666: LD_INT 18
93668: PUSH
93669: LD_INT 19
93671: PUSH
93672: LD_INT 20
93674: PUSH
93675: LD_INT 21
93677: PUSH
93678: LD_INT 22
93680: PUSH
93681: LD_INT 23
93683: PUSH
93684: LD_INT 24
93686: PUSH
93687: LD_INT 25
93689: PUSH
93690: LD_INT 26
93692: PUSH
93693: LD_INT 27
93695: PUSH
93696: LD_INT 28
93698: PUSH
93699: LD_INT 29
93701: PUSH
93702: LD_INT 30
93704: PUSH
93705: LD_INT 31
93707: PUSH
93708: LD_INT 32
93710: PUSH
93711: LD_INT 33
93713: PUSH
93714: LD_INT 34
93716: PUSH
93717: LD_INT 36
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: LIST
93736: LIST
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: PUSH
93757: LD_INT 101
93759: PUSH
93760: LD_INT 102
93762: PUSH
93763: LD_INT 103
93765: PUSH
93766: LD_INT 104
93768: PUSH
93769: LD_INT 105
93771: PUSH
93772: LD_INT 106
93774: PUSH
93775: LD_INT 107
93777: PUSH
93778: LD_INT 108
93780: PUSH
93781: LD_INT 109
93783: PUSH
93784: LD_INT 110
93786: PUSH
93787: LD_INT 111
93789: PUSH
93790: LD_INT 112
93792: PUSH
93793: LD_INT 113
93795: PUSH
93796: LD_INT 114
93798: PUSH
93799: LD_INT 116
93801: PUSH
93802: LD_INT 117
93804: PUSH
93805: LD_INT 118
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: ST_TO_ADDR
93831: GO 94606
93833: LD_INT 16
93835: DOUBLE
93836: EQUAL
93837: IFTRUE 93841
93839: GO 93977
93841: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
93842: LD_ADDR_VAR 0 2
93846: PUSH
93847: LD_INT 2
93849: PUSH
93850: LD_INT 4
93852: PUSH
93853: LD_INT 5
93855: PUSH
93856: LD_INT 7
93858: PUSH
93859: LD_INT 11
93861: PUSH
93862: LD_INT 12
93864: PUSH
93865: LD_INT 15
93867: PUSH
93868: LD_INT 16
93870: PUSH
93871: LD_INT 20
93873: PUSH
93874: LD_INT 21
93876: PUSH
93877: LD_INT 22
93879: PUSH
93880: LD_INT 23
93882: PUSH
93883: LD_INT 25
93885: PUSH
93886: LD_INT 26
93888: PUSH
93889: LD_INT 30
93891: PUSH
93892: LD_INT 31
93894: PUSH
93895: LD_INT 32
93897: PUSH
93898: LD_INT 33
93900: PUSH
93901: LD_INT 34
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: PUSH
93925: LD_INT 101
93927: PUSH
93928: LD_INT 102
93930: PUSH
93931: LD_INT 103
93933: PUSH
93934: LD_INT 106
93936: PUSH
93937: LD_INT 108
93939: PUSH
93940: LD_INT 112
93942: PUSH
93943: LD_INT 113
93945: PUSH
93946: LD_INT 114
93948: PUSH
93949: LD_INT 116
93951: PUSH
93952: LD_INT 117
93954: PUSH
93955: LD_INT 118
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: ST_TO_ADDR
93975: GO 94606
93977: LD_INT 17
93979: DOUBLE
93980: EQUAL
93981: IFTRUE 93985
93983: GO 94209
93985: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
93986: LD_ADDR_VAR 0 2
93990: PUSH
93991: LD_INT 1
93993: PUSH
93994: LD_INT 2
93996: PUSH
93997: LD_INT 3
93999: PUSH
94000: LD_INT 4
94002: PUSH
94003: LD_INT 5
94005: PUSH
94006: LD_INT 6
94008: PUSH
94009: LD_INT 7
94011: PUSH
94012: LD_INT 8
94014: PUSH
94015: LD_INT 9
94017: PUSH
94018: LD_INT 10
94020: PUSH
94021: LD_INT 11
94023: PUSH
94024: LD_INT 12
94026: PUSH
94027: LD_INT 13
94029: PUSH
94030: LD_INT 14
94032: PUSH
94033: LD_INT 15
94035: PUSH
94036: LD_INT 16
94038: PUSH
94039: LD_INT 17
94041: PUSH
94042: LD_INT 18
94044: PUSH
94045: LD_INT 19
94047: PUSH
94048: LD_INT 20
94050: PUSH
94051: LD_INT 21
94053: PUSH
94054: LD_INT 22
94056: PUSH
94057: LD_INT 23
94059: PUSH
94060: LD_INT 24
94062: PUSH
94063: LD_INT 25
94065: PUSH
94066: LD_INT 26
94068: PUSH
94069: LD_INT 27
94071: PUSH
94072: LD_INT 28
94074: PUSH
94075: LD_INT 29
94077: PUSH
94078: LD_INT 30
94080: PUSH
94081: LD_INT 31
94083: PUSH
94084: LD_INT 32
94086: PUSH
94087: LD_INT 33
94089: PUSH
94090: LD_INT 34
94092: PUSH
94093: LD_INT 36
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: PUSH
94133: LD_INT 101
94135: PUSH
94136: LD_INT 102
94138: PUSH
94139: LD_INT 103
94141: PUSH
94142: LD_INT 104
94144: PUSH
94145: LD_INT 105
94147: PUSH
94148: LD_INT 106
94150: PUSH
94151: LD_INT 107
94153: PUSH
94154: LD_INT 108
94156: PUSH
94157: LD_INT 109
94159: PUSH
94160: LD_INT 110
94162: PUSH
94163: LD_INT 111
94165: PUSH
94166: LD_INT 112
94168: PUSH
94169: LD_INT 113
94171: PUSH
94172: LD_INT 114
94174: PUSH
94175: LD_INT 116
94177: PUSH
94178: LD_INT 117
94180: PUSH
94181: LD_INT 118
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: ST_TO_ADDR
94207: GO 94606
94209: LD_INT 18
94211: DOUBLE
94212: EQUAL
94213: IFTRUE 94217
94215: GO 94365
94217: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94218: LD_ADDR_VAR 0 2
94222: PUSH
94223: LD_INT 2
94225: PUSH
94226: LD_INT 4
94228: PUSH
94229: LD_INT 5
94231: PUSH
94232: LD_INT 7
94234: PUSH
94235: LD_INT 11
94237: PUSH
94238: LD_INT 12
94240: PUSH
94241: LD_INT 15
94243: PUSH
94244: LD_INT 16
94246: PUSH
94247: LD_INT 20
94249: PUSH
94250: LD_INT 21
94252: PUSH
94253: LD_INT 22
94255: PUSH
94256: LD_INT 23
94258: PUSH
94259: LD_INT 25
94261: PUSH
94262: LD_INT 26
94264: PUSH
94265: LD_INT 30
94267: PUSH
94268: LD_INT 31
94270: PUSH
94271: LD_INT 32
94273: PUSH
94274: LD_INT 33
94276: PUSH
94277: LD_INT 34
94279: PUSH
94280: LD_INT 35
94282: PUSH
94283: LD_INT 36
94285: PUSH
94286: EMPTY
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: PUSH
94309: LD_INT 101
94311: PUSH
94312: LD_INT 102
94314: PUSH
94315: LD_INT 103
94317: PUSH
94318: LD_INT 106
94320: PUSH
94321: LD_INT 108
94323: PUSH
94324: LD_INT 112
94326: PUSH
94327: LD_INT 113
94329: PUSH
94330: LD_INT 114
94332: PUSH
94333: LD_INT 115
94335: PUSH
94336: LD_INT 116
94338: PUSH
94339: LD_INT 117
94341: PUSH
94342: LD_INT 118
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: ST_TO_ADDR
94363: GO 94606
94365: LD_INT 19
94367: DOUBLE
94368: EQUAL
94369: IFTRUE 94373
94371: GO 94605
94373: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94374: LD_ADDR_VAR 0 2
94378: PUSH
94379: LD_INT 1
94381: PUSH
94382: LD_INT 2
94384: PUSH
94385: LD_INT 3
94387: PUSH
94388: LD_INT 4
94390: PUSH
94391: LD_INT 5
94393: PUSH
94394: LD_INT 6
94396: PUSH
94397: LD_INT 7
94399: PUSH
94400: LD_INT 8
94402: PUSH
94403: LD_INT 9
94405: PUSH
94406: LD_INT 10
94408: PUSH
94409: LD_INT 11
94411: PUSH
94412: LD_INT 12
94414: PUSH
94415: LD_INT 13
94417: PUSH
94418: LD_INT 14
94420: PUSH
94421: LD_INT 15
94423: PUSH
94424: LD_INT 16
94426: PUSH
94427: LD_INT 17
94429: PUSH
94430: LD_INT 18
94432: PUSH
94433: LD_INT 19
94435: PUSH
94436: LD_INT 20
94438: PUSH
94439: LD_INT 21
94441: PUSH
94442: LD_INT 22
94444: PUSH
94445: LD_INT 23
94447: PUSH
94448: LD_INT 24
94450: PUSH
94451: LD_INT 25
94453: PUSH
94454: LD_INT 26
94456: PUSH
94457: LD_INT 27
94459: PUSH
94460: LD_INT 28
94462: PUSH
94463: LD_INT 29
94465: PUSH
94466: LD_INT 30
94468: PUSH
94469: LD_INT 31
94471: PUSH
94472: LD_INT 32
94474: PUSH
94475: LD_INT 33
94477: PUSH
94478: LD_INT 34
94480: PUSH
94481: LD_INT 35
94483: PUSH
94484: LD_INT 36
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 101
94527: PUSH
94528: LD_INT 102
94530: PUSH
94531: LD_INT 103
94533: PUSH
94534: LD_INT 104
94536: PUSH
94537: LD_INT 105
94539: PUSH
94540: LD_INT 106
94542: PUSH
94543: LD_INT 107
94545: PUSH
94546: LD_INT 108
94548: PUSH
94549: LD_INT 109
94551: PUSH
94552: LD_INT 110
94554: PUSH
94555: LD_INT 111
94557: PUSH
94558: LD_INT 112
94560: PUSH
94561: LD_INT 113
94563: PUSH
94564: LD_INT 114
94566: PUSH
94567: LD_INT 115
94569: PUSH
94570: LD_INT 116
94572: PUSH
94573: LD_INT 117
94575: PUSH
94576: LD_INT 118
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: ST_TO_ADDR
94603: GO 94606
94605: POP
// end else
94606: GO 94837
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94608: LD_ADDR_VAR 0 2
94612: PUSH
94613: LD_INT 1
94615: PUSH
94616: LD_INT 2
94618: PUSH
94619: LD_INT 3
94621: PUSH
94622: LD_INT 4
94624: PUSH
94625: LD_INT 5
94627: PUSH
94628: LD_INT 6
94630: PUSH
94631: LD_INT 7
94633: PUSH
94634: LD_INT 8
94636: PUSH
94637: LD_INT 9
94639: PUSH
94640: LD_INT 10
94642: PUSH
94643: LD_INT 11
94645: PUSH
94646: LD_INT 12
94648: PUSH
94649: LD_INT 13
94651: PUSH
94652: LD_INT 14
94654: PUSH
94655: LD_INT 15
94657: PUSH
94658: LD_INT 16
94660: PUSH
94661: LD_INT 17
94663: PUSH
94664: LD_INT 18
94666: PUSH
94667: LD_INT 19
94669: PUSH
94670: LD_INT 20
94672: PUSH
94673: LD_INT 21
94675: PUSH
94676: LD_INT 22
94678: PUSH
94679: LD_INT 23
94681: PUSH
94682: LD_INT 24
94684: PUSH
94685: LD_INT 25
94687: PUSH
94688: LD_INT 26
94690: PUSH
94691: LD_INT 27
94693: PUSH
94694: LD_INT 28
94696: PUSH
94697: LD_INT 29
94699: PUSH
94700: LD_INT 30
94702: PUSH
94703: LD_INT 31
94705: PUSH
94706: LD_INT 32
94708: PUSH
94709: LD_INT 33
94711: PUSH
94712: LD_INT 34
94714: PUSH
94715: LD_INT 35
94717: PUSH
94718: LD_INT 36
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 101
94761: PUSH
94762: LD_INT 102
94764: PUSH
94765: LD_INT 103
94767: PUSH
94768: LD_INT 104
94770: PUSH
94771: LD_INT 105
94773: PUSH
94774: LD_INT 106
94776: PUSH
94777: LD_INT 107
94779: PUSH
94780: LD_INT 108
94782: PUSH
94783: LD_INT 109
94785: PUSH
94786: LD_INT 110
94788: PUSH
94789: LD_INT 111
94791: PUSH
94792: LD_INT 112
94794: PUSH
94795: LD_INT 113
94797: PUSH
94798: LD_INT 114
94800: PUSH
94801: LD_INT 115
94803: PUSH
94804: LD_INT 116
94806: PUSH
94807: LD_INT 117
94809: PUSH
94810: LD_INT 118
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: ST_TO_ADDR
// if result then
94837: LD_VAR 0 2
94841: IFFALSE 95627
// begin normal :=  ;
94843: LD_ADDR_VAR 0 5
94847: PUSH
94848: LD_STRING 
94850: ST_TO_ADDR
// hardcore :=  ;
94851: LD_ADDR_VAR 0 6
94855: PUSH
94856: LD_STRING 
94858: ST_TO_ADDR
// active :=  ;
94859: LD_ADDR_VAR 0 7
94863: PUSH
94864: LD_STRING 
94866: ST_TO_ADDR
// for i = 1 to normalCounter do
94867: LD_ADDR_VAR 0 8
94871: PUSH
94872: DOUBLE
94873: LD_INT 1
94875: DEC
94876: ST_TO_ADDR
94877: LD_EXP 95
94881: PUSH
94882: FOR_TO
94883: IFFALSE 94984
// begin tmp := 0 ;
94885: LD_ADDR_VAR 0 3
94889: PUSH
94890: LD_STRING 0
94892: ST_TO_ADDR
// if result [ 1 ] then
94893: LD_VAR 0 2
94897: PUSH
94898: LD_INT 1
94900: ARRAY
94901: IFFALSE 94966
// if result [ 1 ] [ 1 ] = i then
94903: LD_VAR 0 2
94907: PUSH
94908: LD_INT 1
94910: ARRAY
94911: PUSH
94912: LD_INT 1
94914: ARRAY
94915: PUSH
94916: LD_VAR 0 8
94920: EQUAL
94921: IFFALSE 94966
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94923: LD_ADDR_VAR 0 2
94927: PUSH
94928: LD_VAR 0 2
94932: PPUSH
94933: LD_INT 1
94935: PPUSH
94936: LD_VAR 0 2
94940: PUSH
94941: LD_INT 1
94943: ARRAY
94944: PPUSH
94945: LD_INT 1
94947: PPUSH
94948: CALL_OW 3
94952: PPUSH
94953: CALL_OW 1
94957: ST_TO_ADDR
// tmp := 1 ;
94958: LD_ADDR_VAR 0 3
94962: PUSH
94963: LD_STRING 1
94965: ST_TO_ADDR
// end ; normal := normal & tmp ;
94966: LD_ADDR_VAR 0 5
94970: PUSH
94971: LD_VAR 0 5
94975: PUSH
94976: LD_VAR 0 3
94980: STR
94981: ST_TO_ADDR
// end ;
94982: GO 94882
94984: POP
94985: POP
// for i = 1 to hardcoreCounter do
94986: LD_ADDR_VAR 0 8
94990: PUSH
94991: DOUBLE
94992: LD_INT 1
94994: DEC
94995: ST_TO_ADDR
94996: LD_EXP 96
95000: PUSH
95001: FOR_TO
95002: IFFALSE 95107
// begin tmp := 0 ;
95004: LD_ADDR_VAR 0 3
95008: PUSH
95009: LD_STRING 0
95011: ST_TO_ADDR
// if result [ 2 ] then
95012: LD_VAR 0 2
95016: PUSH
95017: LD_INT 2
95019: ARRAY
95020: IFFALSE 95089
// if result [ 2 ] [ 1 ] = 100 + i then
95022: LD_VAR 0 2
95026: PUSH
95027: LD_INT 2
95029: ARRAY
95030: PUSH
95031: LD_INT 1
95033: ARRAY
95034: PUSH
95035: LD_INT 100
95037: PUSH
95038: LD_VAR 0 8
95042: PLUS
95043: EQUAL
95044: IFFALSE 95089
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95046: LD_ADDR_VAR 0 2
95050: PUSH
95051: LD_VAR 0 2
95055: PPUSH
95056: LD_INT 2
95058: PPUSH
95059: LD_VAR 0 2
95063: PUSH
95064: LD_INT 2
95066: ARRAY
95067: PPUSH
95068: LD_INT 1
95070: PPUSH
95071: CALL_OW 3
95075: PPUSH
95076: CALL_OW 1
95080: ST_TO_ADDR
// tmp := 1 ;
95081: LD_ADDR_VAR 0 3
95085: PUSH
95086: LD_STRING 1
95088: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95089: LD_ADDR_VAR 0 6
95093: PUSH
95094: LD_VAR 0 6
95098: PUSH
95099: LD_VAR 0 3
95103: STR
95104: ST_TO_ADDR
// end ;
95105: GO 95001
95107: POP
95108: POP
// if isGameLoad then
95109: LD_VAR 0 1
95113: IFFALSE 95588
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95115: LD_ADDR_VAR 0 4
95119: PUSH
95120: LD_EXP 99
95124: PUSH
95125: LD_EXP 98
95129: PUSH
95130: LD_EXP 100
95134: PUSH
95135: LD_EXP 97
95139: PUSH
95140: LD_EXP 101
95144: PUSH
95145: LD_EXP 102
95149: PUSH
95150: LD_EXP 103
95154: PUSH
95155: LD_EXP 104
95159: PUSH
95160: LD_EXP 105
95164: PUSH
95165: LD_EXP 106
95169: PUSH
95170: LD_EXP 107
95174: PUSH
95175: LD_EXP 108
95179: PUSH
95180: LD_EXP 109
95184: PUSH
95185: LD_EXP 110
95189: PUSH
95190: LD_EXP 118
95194: PUSH
95195: LD_EXP 119
95199: PUSH
95200: LD_EXP 120
95204: PUSH
95205: LD_EXP 121
95209: PUSH
95210: LD_EXP 123
95214: PUSH
95215: LD_EXP 124
95219: PUSH
95220: LD_EXP 125
95224: PUSH
95225: LD_EXP 128
95229: PUSH
95230: LD_EXP 130
95234: PUSH
95235: LD_EXP 131
95239: PUSH
95240: LD_EXP 132
95244: PUSH
95245: LD_EXP 134
95249: PUSH
95250: LD_EXP 135
95254: PUSH
95255: LD_EXP 138
95259: PUSH
95260: LD_EXP 139
95264: PUSH
95265: LD_EXP 140
95269: PUSH
95270: LD_EXP 141
95274: PUSH
95275: LD_EXP 142
95279: PUSH
95280: LD_EXP 143
95284: PUSH
95285: LD_EXP 144
95289: PUSH
95290: LD_EXP 145
95294: PUSH
95295: LD_EXP 146
95299: PUSH
95300: LD_EXP 111
95304: PUSH
95305: LD_EXP 112
95309: PUSH
95310: LD_EXP 115
95314: PUSH
95315: LD_EXP 116
95319: PUSH
95320: LD_EXP 117
95324: PUSH
95325: LD_EXP 113
95329: PUSH
95330: LD_EXP 114
95334: PUSH
95335: LD_EXP 122
95339: PUSH
95340: LD_EXP 126
95344: PUSH
95345: LD_EXP 127
95349: PUSH
95350: LD_EXP 129
95354: PUSH
95355: LD_EXP 133
95359: PUSH
95360: LD_EXP 136
95364: PUSH
95365: LD_EXP 137
95369: PUSH
95370: LD_EXP 147
95374: PUSH
95375: LD_EXP 148
95379: PUSH
95380: LD_EXP 149
95384: PUSH
95385: LD_EXP 150
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: ST_TO_ADDR
// tmp :=  ;
95446: LD_ADDR_VAR 0 3
95450: PUSH
95451: LD_STRING 
95453: ST_TO_ADDR
// for i = 1 to normalCounter do
95454: LD_ADDR_VAR 0 8
95458: PUSH
95459: DOUBLE
95460: LD_INT 1
95462: DEC
95463: ST_TO_ADDR
95464: LD_EXP 95
95468: PUSH
95469: FOR_TO
95470: IFFALSE 95506
// begin if flags [ i ] then
95472: LD_VAR 0 4
95476: PUSH
95477: LD_VAR 0 8
95481: ARRAY
95482: IFFALSE 95504
// tmp := tmp & i & ; ;
95484: LD_ADDR_VAR 0 3
95488: PUSH
95489: LD_VAR 0 3
95493: PUSH
95494: LD_VAR 0 8
95498: STR
95499: PUSH
95500: LD_STRING ;
95502: STR
95503: ST_TO_ADDR
// end ;
95504: GO 95469
95506: POP
95507: POP
// for i = 1 to hardcoreCounter do
95508: LD_ADDR_VAR 0 8
95512: PUSH
95513: DOUBLE
95514: LD_INT 1
95516: DEC
95517: ST_TO_ADDR
95518: LD_EXP 96
95522: PUSH
95523: FOR_TO
95524: IFFALSE 95570
// begin if flags [ normalCounter + i ] then
95526: LD_VAR 0 4
95530: PUSH
95531: LD_EXP 95
95535: PUSH
95536: LD_VAR 0 8
95540: PLUS
95541: ARRAY
95542: IFFALSE 95568
// tmp := tmp & ( 100 + i ) & ; ;
95544: LD_ADDR_VAR 0 3
95548: PUSH
95549: LD_VAR 0 3
95553: PUSH
95554: LD_INT 100
95556: PUSH
95557: LD_VAR 0 8
95561: PLUS
95562: STR
95563: PUSH
95564: LD_STRING ;
95566: STR
95567: ST_TO_ADDR
// end ;
95568: GO 95523
95570: POP
95571: POP
// if tmp then
95572: LD_VAR 0 3
95576: IFFALSE 95588
// active := tmp ;
95578: LD_ADDR_VAR 0 7
95582: PUSH
95583: LD_VAR 0 3
95587: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95588: LD_STRING getStreamItemsFromMission("
95590: PUSH
95591: LD_VAR 0 5
95595: STR
95596: PUSH
95597: LD_STRING ","
95599: STR
95600: PUSH
95601: LD_VAR 0 6
95605: STR
95606: PUSH
95607: LD_STRING ","
95609: STR
95610: PUSH
95611: LD_VAR 0 7
95615: STR
95616: PUSH
95617: LD_STRING ")
95619: STR
95620: PPUSH
95621: CALL_OW 559
// end else
95625: GO 95634
// ToLua ( getStreamItemsFromMission("","","") ) ;
95627: LD_STRING getStreamItemsFromMission("","","")
95629: PPUSH
95630: CALL_OW 559
// end ;
95634: LD_VAR 0 2
95638: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95639: LD_EXP 94
95643: PUSH
95644: LD_EXP 99
95648: AND
95649: IFFALSE 95773
95651: GO 95653
95653: DISABLE
95654: LD_INT 0
95656: PPUSH
95657: PPUSH
// begin enable ;
95658: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95659: LD_ADDR_VAR 0 2
95663: PUSH
95664: LD_INT 22
95666: PUSH
95667: LD_OWVAR 2
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 2
95678: PUSH
95679: LD_INT 34
95681: PUSH
95682: LD_INT 7
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PUSH
95689: LD_INT 34
95691: PUSH
95692: LD_INT 45
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: PUSH
95699: LD_INT 34
95701: PUSH
95702: LD_INT 28
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: PUSH
95709: LD_INT 34
95711: PUSH
95712: LD_INT 47
95714: PUSH
95715: EMPTY
95716: LIST
95717: LIST
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: PPUSH
95730: CALL_OW 69
95734: ST_TO_ADDR
// if not tmp then
95735: LD_VAR 0 2
95739: NOT
95740: IFFALSE 95744
// exit ;
95742: GO 95773
// for i in tmp do
95744: LD_ADDR_VAR 0 1
95748: PUSH
95749: LD_VAR 0 2
95753: PUSH
95754: FOR_IN
95755: IFFALSE 95771
// begin SetLives ( i , 0 ) ;
95757: LD_VAR 0 1
95761: PPUSH
95762: LD_INT 0
95764: PPUSH
95765: CALL_OW 234
// end ;
95769: GO 95754
95771: POP
95772: POP
// end ;
95773: PPOPN 2
95775: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95776: LD_EXP 94
95780: PUSH
95781: LD_EXP 100
95785: AND
95786: IFFALSE 95870
95788: GO 95790
95790: DISABLE
95791: LD_INT 0
95793: PPUSH
95794: PPUSH
// begin enable ;
95795: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95796: LD_ADDR_VAR 0 2
95800: PUSH
95801: LD_INT 22
95803: PUSH
95804: LD_OWVAR 2
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 32
95815: PUSH
95816: LD_INT 3
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PPUSH
95827: CALL_OW 69
95831: ST_TO_ADDR
// if not tmp then
95832: LD_VAR 0 2
95836: NOT
95837: IFFALSE 95841
// exit ;
95839: GO 95870
// for i in tmp do
95841: LD_ADDR_VAR 0 1
95845: PUSH
95846: LD_VAR 0 2
95850: PUSH
95851: FOR_IN
95852: IFFALSE 95868
// begin SetLives ( i , 0 ) ;
95854: LD_VAR 0 1
95858: PPUSH
95859: LD_INT 0
95861: PPUSH
95862: CALL_OW 234
// end ;
95866: GO 95851
95868: POP
95869: POP
// end ;
95870: PPOPN 2
95872: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
95873: LD_EXP 94
95877: PUSH
95878: LD_EXP 97
95882: AND
95883: IFFALSE 95976
95885: GO 95887
95887: DISABLE
95888: LD_INT 0
95890: PPUSH
// begin enable ;
95891: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
95892: LD_ADDR_VAR 0 1
95896: PUSH
95897: LD_INT 22
95899: PUSH
95900: LD_OWVAR 2
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 2
95911: PUSH
95912: LD_INT 25
95914: PUSH
95915: LD_INT 5
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 25
95924: PUSH
95925: LD_INT 9
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: PUSH
95932: LD_INT 25
95934: PUSH
95935: LD_INT 8
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: PPUSH
95952: CALL_OW 69
95956: PUSH
95957: FOR_IN
95958: IFFALSE 95974
// begin SetClass ( i , 1 ) ;
95960: LD_VAR 0 1
95964: PPUSH
95965: LD_INT 1
95967: PPUSH
95968: CALL_OW 336
// end ;
95972: GO 95957
95974: POP
95975: POP
// end ;
95976: PPOPN 1
95978: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95979: LD_EXP 94
95983: PUSH
95984: LD_EXP 98
95988: AND
95989: PUSH
95990: LD_OWVAR 65
95994: PUSH
95995: LD_INT 7
95997: LESS
95998: AND
95999: IFFALSE 96013
96001: GO 96003
96003: DISABLE
// begin enable ;
96004: ENABLE
// game_speed := 7 ;
96005: LD_ADDR_OWVAR 65
96009: PUSH
96010: LD_INT 7
96012: ST_TO_ADDR
// end ;
96013: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96014: LD_EXP 94
96018: PUSH
96019: LD_EXP 101
96023: AND
96024: IFFALSE 96226
96026: GO 96028
96028: DISABLE
96029: LD_INT 0
96031: PPUSH
96032: PPUSH
96033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96034: LD_ADDR_VAR 0 3
96038: PUSH
96039: LD_INT 81
96041: PUSH
96042: LD_OWVAR 2
96046: PUSH
96047: EMPTY
96048: LIST
96049: LIST
96050: PUSH
96051: LD_INT 21
96053: PUSH
96054: LD_INT 1
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: PUSH
96061: EMPTY
96062: LIST
96063: LIST
96064: PPUSH
96065: CALL_OW 69
96069: ST_TO_ADDR
// if not tmp then
96070: LD_VAR 0 3
96074: NOT
96075: IFFALSE 96079
// exit ;
96077: GO 96226
// if tmp > 5 then
96079: LD_VAR 0 3
96083: PUSH
96084: LD_INT 5
96086: GREATER
96087: IFFALSE 96099
// k := 5 else
96089: LD_ADDR_VAR 0 2
96093: PUSH
96094: LD_INT 5
96096: ST_TO_ADDR
96097: GO 96109
// k := tmp ;
96099: LD_ADDR_VAR 0 2
96103: PUSH
96104: LD_VAR 0 3
96108: ST_TO_ADDR
// for i := 1 to k do
96109: LD_ADDR_VAR 0 1
96113: PUSH
96114: DOUBLE
96115: LD_INT 1
96117: DEC
96118: ST_TO_ADDR
96119: LD_VAR 0 2
96123: PUSH
96124: FOR_TO
96125: IFFALSE 96224
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96127: LD_VAR 0 3
96131: PUSH
96132: LD_VAR 0 1
96136: ARRAY
96137: PPUSH
96138: LD_VAR 0 1
96142: PUSH
96143: LD_INT 4
96145: MOD
96146: PUSH
96147: LD_INT 1
96149: PLUS
96150: PPUSH
96151: CALL_OW 259
96155: PUSH
96156: LD_INT 10
96158: LESS
96159: IFFALSE 96222
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96161: LD_VAR 0 3
96165: PUSH
96166: LD_VAR 0 1
96170: ARRAY
96171: PPUSH
96172: LD_VAR 0 1
96176: PUSH
96177: LD_INT 4
96179: MOD
96180: PUSH
96181: LD_INT 1
96183: PLUS
96184: PPUSH
96185: LD_VAR 0 3
96189: PUSH
96190: LD_VAR 0 1
96194: ARRAY
96195: PPUSH
96196: LD_VAR 0 1
96200: PUSH
96201: LD_INT 4
96203: MOD
96204: PUSH
96205: LD_INT 1
96207: PLUS
96208: PPUSH
96209: CALL_OW 259
96213: PUSH
96214: LD_INT 1
96216: PLUS
96217: PPUSH
96218: CALL_OW 237
96222: GO 96124
96224: POP
96225: POP
// end ;
96226: PPOPN 3
96228: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96229: LD_EXP 94
96233: PUSH
96234: LD_EXP 102
96238: AND
96239: IFFALSE 96259
96241: GO 96243
96243: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96244: LD_INT 4
96246: PPUSH
96247: LD_OWVAR 2
96251: PPUSH
96252: LD_INT 0
96254: PPUSH
96255: CALL_OW 324
96259: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96260: LD_EXP 94
96264: PUSH
96265: LD_EXP 131
96269: AND
96270: IFFALSE 96290
96272: GO 96274
96274: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96275: LD_INT 19
96277: PPUSH
96278: LD_OWVAR 2
96282: PPUSH
96283: LD_INT 0
96285: PPUSH
96286: CALL_OW 324
96290: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96291: LD_EXP 94
96295: PUSH
96296: LD_EXP 103
96300: AND
96301: IFFALSE 96403
96303: GO 96305
96305: DISABLE
96306: LD_INT 0
96308: PPUSH
96309: PPUSH
// begin enable ;
96310: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96311: LD_ADDR_VAR 0 2
96315: PUSH
96316: LD_INT 22
96318: PUSH
96319: LD_OWVAR 2
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: LD_INT 2
96330: PUSH
96331: LD_INT 34
96333: PUSH
96334: LD_INT 11
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 34
96343: PUSH
96344: LD_INT 30
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: LIST
96355: PUSH
96356: EMPTY
96357: LIST
96358: LIST
96359: PPUSH
96360: CALL_OW 69
96364: ST_TO_ADDR
// if not tmp then
96365: LD_VAR 0 2
96369: NOT
96370: IFFALSE 96374
// exit ;
96372: GO 96403
// for i in tmp do
96374: LD_ADDR_VAR 0 1
96378: PUSH
96379: LD_VAR 0 2
96383: PUSH
96384: FOR_IN
96385: IFFALSE 96401
// begin SetLives ( i , 0 ) ;
96387: LD_VAR 0 1
96391: PPUSH
96392: LD_INT 0
96394: PPUSH
96395: CALL_OW 234
// end ;
96399: GO 96384
96401: POP
96402: POP
// end ;
96403: PPOPN 2
96405: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96406: LD_EXP 94
96410: PUSH
96411: LD_EXP 104
96415: AND
96416: IFFALSE 96436
96418: GO 96420
96420: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96421: LD_INT 32
96423: PPUSH
96424: LD_OWVAR 2
96428: PPUSH
96429: LD_INT 0
96431: PPUSH
96432: CALL_OW 324
96436: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96437: LD_EXP 94
96441: PUSH
96442: LD_EXP 105
96446: AND
96447: IFFALSE 96628
96449: GO 96451
96451: DISABLE
96452: LD_INT 0
96454: PPUSH
96455: PPUSH
96456: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96457: LD_ADDR_VAR 0 2
96461: PUSH
96462: LD_INT 22
96464: PUSH
96465: LD_OWVAR 2
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: PUSH
96474: LD_INT 33
96476: PUSH
96477: LD_INT 3
96479: PUSH
96480: EMPTY
96481: LIST
96482: LIST
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PPUSH
96488: CALL_OW 69
96492: ST_TO_ADDR
// if not tmp then
96493: LD_VAR 0 2
96497: NOT
96498: IFFALSE 96502
// exit ;
96500: GO 96628
// side := 0 ;
96502: LD_ADDR_VAR 0 3
96506: PUSH
96507: LD_INT 0
96509: ST_TO_ADDR
// for i := 1 to 8 do
96510: LD_ADDR_VAR 0 1
96514: PUSH
96515: DOUBLE
96516: LD_INT 1
96518: DEC
96519: ST_TO_ADDR
96520: LD_INT 8
96522: PUSH
96523: FOR_TO
96524: IFFALSE 96572
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96526: LD_OWVAR 2
96530: PUSH
96531: LD_VAR 0 1
96535: NONEQUAL
96536: PUSH
96537: LD_OWVAR 2
96541: PPUSH
96542: LD_VAR 0 1
96546: PPUSH
96547: CALL_OW 81
96551: PUSH
96552: LD_INT 2
96554: EQUAL
96555: AND
96556: IFFALSE 96570
// begin side := i ;
96558: LD_ADDR_VAR 0 3
96562: PUSH
96563: LD_VAR 0 1
96567: ST_TO_ADDR
// break ;
96568: GO 96572
// end ;
96570: GO 96523
96572: POP
96573: POP
// if not side then
96574: LD_VAR 0 3
96578: NOT
96579: IFFALSE 96583
// exit ;
96581: GO 96628
// for i := 1 to tmp do
96583: LD_ADDR_VAR 0 1
96587: PUSH
96588: DOUBLE
96589: LD_INT 1
96591: DEC
96592: ST_TO_ADDR
96593: LD_VAR 0 2
96597: PUSH
96598: FOR_TO
96599: IFFALSE 96626
// if Prob ( 60 ) then
96601: LD_INT 60
96603: PPUSH
96604: CALL_OW 13
96608: IFFALSE 96624
// SetSide ( i , side ) ;
96610: LD_VAR 0 1
96614: PPUSH
96615: LD_VAR 0 3
96619: PPUSH
96620: CALL_OW 235
96624: GO 96598
96626: POP
96627: POP
// end ;
96628: PPOPN 3
96630: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96631: LD_EXP 94
96635: PUSH
96636: LD_EXP 107
96640: AND
96641: IFFALSE 96760
96643: GO 96645
96645: DISABLE
96646: LD_INT 0
96648: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96649: LD_ADDR_VAR 0 1
96653: PUSH
96654: LD_INT 22
96656: PUSH
96657: LD_OWVAR 2
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: PUSH
96666: LD_INT 21
96668: PUSH
96669: LD_INT 1
96671: PUSH
96672: EMPTY
96673: LIST
96674: LIST
96675: PUSH
96676: LD_INT 3
96678: PUSH
96679: LD_INT 23
96681: PUSH
96682: LD_INT 0
96684: PUSH
96685: EMPTY
96686: LIST
96687: LIST
96688: PUSH
96689: EMPTY
96690: LIST
96691: LIST
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: LIST
96697: PPUSH
96698: CALL_OW 69
96702: PUSH
96703: FOR_IN
96704: IFFALSE 96758
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96706: LD_VAR 0 1
96710: PPUSH
96711: CALL_OW 257
96715: PUSH
96716: LD_INT 1
96718: PUSH
96719: LD_INT 2
96721: PUSH
96722: LD_INT 3
96724: PUSH
96725: LD_INT 4
96727: PUSH
96728: EMPTY
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: IN
96734: IFFALSE 96756
// SetClass ( un , rand ( 1 , 4 ) ) ;
96736: LD_VAR 0 1
96740: PPUSH
96741: LD_INT 1
96743: PPUSH
96744: LD_INT 4
96746: PPUSH
96747: CALL_OW 12
96751: PPUSH
96752: CALL_OW 336
96756: GO 96703
96758: POP
96759: POP
// end ;
96760: PPOPN 1
96762: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96763: LD_EXP 94
96767: PUSH
96768: LD_EXP 106
96772: AND
96773: IFFALSE 96852
96775: GO 96777
96777: DISABLE
96778: LD_INT 0
96780: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96781: LD_ADDR_VAR 0 1
96785: PUSH
96786: LD_INT 22
96788: PUSH
96789: LD_OWVAR 2
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PUSH
96798: LD_INT 21
96800: PUSH
96801: LD_INT 3
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: EMPTY
96809: LIST
96810: LIST
96811: PPUSH
96812: CALL_OW 69
96816: ST_TO_ADDR
// if not tmp then
96817: LD_VAR 0 1
96821: NOT
96822: IFFALSE 96826
// exit ;
96824: GO 96852
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
96826: LD_VAR 0 1
96830: PUSH
96831: LD_INT 1
96833: PPUSH
96834: LD_VAR 0 1
96838: PPUSH
96839: CALL_OW 12
96843: ARRAY
96844: PPUSH
96845: LD_INT 100
96847: PPUSH
96848: CALL_OW 234
// end ;
96852: PPOPN 1
96854: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
96855: LD_EXP 94
96859: PUSH
96860: LD_EXP 108
96864: AND
96865: IFFALSE 96963
96867: GO 96869
96869: DISABLE
96870: LD_INT 0
96872: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96873: LD_ADDR_VAR 0 1
96877: PUSH
96878: LD_INT 22
96880: PUSH
96881: LD_OWVAR 2
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: LD_INT 21
96892: PUSH
96893: LD_INT 1
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PPUSH
96904: CALL_OW 69
96908: ST_TO_ADDR
// if not tmp then
96909: LD_VAR 0 1
96913: NOT
96914: IFFALSE 96918
// exit ;
96916: GO 96963
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
96918: LD_VAR 0 1
96922: PUSH
96923: LD_INT 1
96925: PPUSH
96926: LD_VAR 0 1
96930: PPUSH
96931: CALL_OW 12
96935: ARRAY
96936: PPUSH
96937: LD_INT 1
96939: PPUSH
96940: LD_INT 4
96942: PPUSH
96943: CALL_OW 12
96947: PPUSH
96948: LD_INT 3000
96950: PPUSH
96951: LD_INT 9000
96953: PPUSH
96954: CALL_OW 12
96958: PPUSH
96959: CALL_OW 492
// end ;
96963: PPOPN 1
96965: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96966: LD_EXP 94
96970: PUSH
96971: LD_EXP 109
96975: AND
96976: IFFALSE 96996
96978: GO 96980
96980: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96981: LD_INT 1
96983: PPUSH
96984: LD_OWVAR 2
96988: PPUSH
96989: LD_INT 0
96991: PPUSH
96992: CALL_OW 324
96996: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96997: LD_EXP 94
97001: PUSH
97002: LD_EXP 110
97006: AND
97007: IFFALSE 97090
97009: GO 97011
97011: DISABLE
97012: LD_INT 0
97014: PPUSH
97015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97016: LD_ADDR_VAR 0 2
97020: PUSH
97021: LD_INT 22
97023: PUSH
97024: LD_OWVAR 2
97028: PUSH
97029: EMPTY
97030: LIST
97031: LIST
97032: PUSH
97033: LD_INT 21
97035: PUSH
97036: LD_INT 3
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: EMPTY
97044: LIST
97045: LIST
97046: PPUSH
97047: CALL_OW 69
97051: ST_TO_ADDR
// if not tmp then
97052: LD_VAR 0 2
97056: NOT
97057: IFFALSE 97061
// exit ;
97059: GO 97090
// for i in tmp do
97061: LD_ADDR_VAR 0 1
97065: PUSH
97066: LD_VAR 0 2
97070: PUSH
97071: FOR_IN
97072: IFFALSE 97088
// SetBLevel ( i , 10 ) ;
97074: LD_VAR 0 1
97078: PPUSH
97079: LD_INT 10
97081: PPUSH
97082: CALL_OW 241
97086: GO 97071
97088: POP
97089: POP
// end ;
97090: PPOPN 2
97092: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97093: LD_EXP 94
97097: PUSH
97098: LD_EXP 111
97102: AND
97103: IFFALSE 97214
97105: GO 97107
97107: DISABLE
97108: LD_INT 0
97110: PPUSH
97111: PPUSH
97112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97113: LD_ADDR_VAR 0 3
97117: PUSH
97118: LD_INT 22
97120: PUSH
97121: LD_OWVAR 2
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: LD_INT 25
97132: PUSH
97133: LD_INT 1
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PUSH
97140: EMPTY
97141: LIST
97142: LIST
97143: PPUSH
97144: CALL_OW 69
97148: ST_TO_ADDR
// if not tmp then
97149: LD_VAR 0 3
97153: NOT
97154: IFFALSE 97158
// exit ;
97156: GO 97214
// un := tmp [ rand ( 1 , tmp ) ] ;
97158: LD_ADDR_VAR 0 2
97162: PUSH
97163: LD_VAR 0 3
97167: PUSH
97168: LD_INT 1
97170: PPUSH
97171: LD_VAR 0 3
97175: PPUSH
97176: CALL_OW 12
97180: ARRAY
97181: ST_TO_ADDR
// if Crawls ( un ) then
97182: LD_VAR 0 2
97186: PPUSH
97187: CALL_OW 318
97191: IFFALSE 97202
// ComWalk ( un ) ;
97193: LD_VAR 0 2
97197: PPUSH
97198: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97202: LD_VAR 0 2
97206: PPUSH
97207: LD_INT 5
97209: PPUSH
97210: CALL_OW 336
// end ;
97214: PPOPN 3
97216: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97217: LD_EXP 94
97221: PUSH
97222: LD_EXP 112
97226: AND
97227: PUSH
97228: LD_OWVAR 67
97232: PUSH
97233: LD_INT 4
97235: LESS
97236: AND
97237: IFFALSE 97256
97239: GO 97241
97241: DISABLE
// begin Difficulty := Difficulty + 1 ;
97242: LD_ADDR_OWVAR 67
97246: PUSH
97247: LD_OWVAR 67
97251: PUSH
97252: LD_INT 1
97254: PLUS
97255: ST_TO_ADDR
// end ;
97256: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97257: LD_EXP 94
97261: PUSH
97262: LD_EXP 113
97266: AND
97267: IFFALSE 97370
97269: GO 97271
97271: DISABLE
97272: LD_INT 0
97274: PPUSH
// begin for i := 1 to 5 do
97275: LD_ADDR_VAR 0 1
97279: PUSH
97280: DOUBLE
97281: LD_INT 1
97283: DEC
97284: ST_TO_ADDR
97285: LD_INT 5
97287: PUSH
97288: FOR_TO
97289: IFFALSE 97368
// begin uc_nation := nation_nature ;
97291: LD_ADDR_OWVAR 21
97295: PUSH
97296: LD_INT 0
97298: ST_TO_ADDR
// uc_side := 0 ;
97299: LD_ADDR_OWVAR 20
97303: PUSH
97304: LD_INT 0
97306: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97307: LD_ADDR_OWVAR 29
97311: PUSH
97312: LD_INT 12
97314: PUSH
97315: LD_INT 12
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: ST_TO_ADDR
// hc_agressivity := 20 ;
97322: LD_ADDR_OWVAR 35
97326: PUSH
97327: LD_INT 20
97329: ST_TO_ADDR
// hc_class := class_tiger ;
97330: LD_ADDR_OWVAR 28
97334: PUSH
97335: LD_INT 14
97337: ST_TO_ADDR
// hc_gallery :=  ;
97338: LD_ADDR_OWVAR 33
97342: PUSH
97343: LD_STRING 
97345: ST_TO_ADDR
// hc_name :=  ;
97346: LD_ADDR_OWVAR 26
97350: PUSH
97351: LD_STRING 
97353: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97354: CALL_OW 44
97358: PPUSH
97359: LD_INT 0
97361: PPUSH
97362: CALL_OW 51
// end ;
97366: GO 97288
97368: POP
97369: POP
// end ;
97370: PPOPN 1
97372: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97373: LD_EXP 94
97377: PUSH
97378: LD_EXP 114
97382: AND
97383: IFFALSE 97392
97385: GO 97387
97387: DISABLE
// StreamSibBomb ;
97388: CALL 97393 0 0
97392: END
// export function StreamSibBomb ; var i , x , y ; begin
97393: LD_INT 0
97395: PPUSH
97396: PPUSH
97397: PPUSH
97398: PPUSH
// result := false ;
97399: LD_ADDR_VAR 0 1
97403: PUSH
97404: LD_INT 0
97406: ST_TO_ADDR
// for i := 1 to 16 do
97407: LD_ADDR_VAR 0 2
97411: PUSH
97412: DOUBLE
97413: LD_INT 1
97415: DEC
97416: ST_TO_ADDR
97417: LD_INT 16
97419: PUSH
97420: FOR_TO
97421: IFFALSE 97620
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97423: LD_ADDR_VAR 0 3
97427: PUSH
97428: LD_INT 10
97430: PUSH
97431: LD_INT 20
97433: PUSH
97434: LD_INT 30
97436: PUSH
97437: LD_INT 40
97439: PUSH
97440: LD_INT 50
97442: PUSH
97443: LD_INT 60
97445: PUSH
97446: LD_INT 70
97448: PUSH
97449: LD_INT 80
97451: PUSH
97452: LD_INT 90
97454: PUSH
97455: LD_INT 100
97457: PUSH
97458: LD_INT 110
97460: PUSH
97461: LD_INT 120
97463: PUSH
97464: LD_INT 130
97466: PUSH
97467: LD_INT 140
97469: PUSH
97470: LD_INT 150
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 1
97492: PPUSH
97493: LD_INT 15
97495: PPUSH
97496: CALL_OW 12
97500: ARRAY
97501: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97502: LD_ADDR_VAR 0 4
97506: PUSH
97507: LD_INT 10
97509: PUSH
97510: LD_INT 20
97512: PUSH
97513: LD_INT 30
97515: PUSH
97516: LD_INT 40
97518: PUSH
97519: LD_INT 50
97521: PUSH
97522: LD_INT 60
97524: PUSH
97525: LD_INT 70
97527: PUSH
97528: LD_INT 80
97530: PUSH
97531: LD_INT 90
97533: PUSH
97534: LD_INT 100
97536: PUSH
97537: LD_INT 110
97539: PUSH
97540: LD_INT 120
97542: PUSH
97543: LD_INT 130
97545: PUSH
97546: LD_INT 140
97548: PUSH
97549: LD_INT 150
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: PUSH
97569: LD_INT 1
97571: PPUSH
97572: LD_INT 15
97574: PPUSH
97575: CALL_OW 12
97579: ARRAY
97580: ST_TO_ADDR
// if ValidHex ( x , y ) then
97581: LD_VAR 0 3
97585: PPUSH
97586: LD_VAR 0 4
97590: PPUSH
97591: CALL_OW 488
97595: IFFALSE 97618
// begin result := [ x , y ] ;
97597: LD_ADDR_VAR 0 1
97601: PUSH
97602: LD_VAR 0 3
97606: PUSH
97607: LD_VAR 0 4
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: ST_TO_ADDR
// break ;
97616: GO 97620
// end ; end ;
97618: GO 97420
97620: POP
97621: POP
// if result then
97622: LD_VAR 0 1
97626: IFFALSE 97686
// begin ToLua ( playSibBomb() ) ;
97628: LD_STRING playSibBomb()
97630: PPUSH
97631: CALL_OW 559
// wait ( 0 0$14 ) ;
97635: LD_INT 490
97637: PPUSH
97638: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97642: LD_VAR 0 1
97646: PUSH
97647: LD_INT 1
97649: ARRAY
97650: PPUSH
97651: LD_VAR 0 1
97655: PUSH
97656: LD_INT 2
97658: ARRAY
97659: PPUSH
97660: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97664: LD_VAR 0 1
97668: PUSH
97669: LD_INT 1
97671: ARRAY
97672: PPUSH
97673: LD_VAR 0 1
97677: PUSH
97678: LD_INT 2
97680: ARRAY
97681: PPUSH
97682: CALL_OW 429
// end ; end ;
97686: LD_VAR 0 1
97690: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97691: LD_EXP 94
97695: PUSH
97696: LD_EXP 116
97700: AND
97701: IFFALSE 97713
97703: GO 97705
97705: DISABLE
// YouLost (  ) ;
97706: LD_STRING 
97708: PPUSH
97709: CALL_OW 104
97713: END
// every 0 0$1 trigger StreamModeActive and sFog do
97714: LD_EXP 94
97718: PUSH
97719: LD_EXP 115
97723: AND
97724: IFFALSE 97738
97726: GO 97728
97728: DISABLE
// FogOff ( your_side ) ;
97729: LD_OWVAR 2
97733: PPUSH
97734: CALL_OW 344
97738: END
// every 0 0$1 trigger StreamModeActive and sSun do
97739: LD_EXP 94
97743: PUSH
97744: LD_EXP 117
97748: AND
97749: IFFALSE 97777
97751: GO 97753
97753: DISABLE
// begin solar_recharge_percent := 0 ;
97754: LD_ADDR_OWVAR 79
97758: PUSH
97759: LD_INT 0
97761: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97762: LD_INT 10500
97764: PPUSH
97765: CALL_OW 67
// solar_recharge_percent := 100 ;
97769: LD_ADDR_OWVAR 79
97773: PUSH
97774: LD_INT 100
97776: ST_TO_ADDR
// end ;
97777: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97778: LD_EXP 94
97782: PUSH
97783: LD_EXP 118
97787: AND
97788: IFFALSE 98027
97790: GO 97792
97792: DISABLE
97793: LD_INT 0
97795: PPUSH
97796: PPUSH
97797: PPUSH
// begin tmp := [ ] ;
97798: LD_ADDR_VAR 0 3
97802: PUSH
97803: EMPTY
97804: ST_TO_ADDR
// for i := 1 to 6 do
97805: LD_ADDR_VAR 0 1
97809: PUSH
97810: DOUBLE
97811: LD_INT 1
97813: DEC
97814: ST_TO_ADDR
97815: LD_INT 6
97817: PUSH
97818: FOR_TO
97819: IFFALSE 97924
// begin uc_nation := nation_nature ;
97821: LD_ADDR_OWVAR 21
97825: PUSH
97826: LD_INT 0
97828: ST_TO_ADDR
// uc_side := 0 ;
97829: LD_ADDR_OWVAR 20
97833: PUSH
97834: LD_INT 0
97836: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97837: LD_ADDR_OWVAR 29
97841: PUSH
97842: LD_INT 12
97844: PUSH
97845: LD_INT 12
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: ST_TO_ADDR
// hc_agressivity := 20 ;
97852: LD_ADDR_OWVAR 35
97856: PUSH
97857: LD_INT 20
97859: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
97860: LD_ADDR_OWVAR 28
97864: PUSH
97865: LD_INT 17
97867: ST_TO_ADDR
// hc_gallery :=  ;
97868: LD_ADDR_OWVAR 33
97872: PUSH
97873: LD_STRING 
97875: ST_TO_ADDR
// hc_name :=  ;
97876: LD_ADDR_OWVAR 26
97880: PUSH
97881: LD_STRING 
97883: ST_TO_ADDR
// un := CreateHuman ;
97884: LD_ADDR_VAR 0 2
97888: PUSH
97889: CALL_OW 44
97893: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
97894: LD_VAR 0 2
97898: PPUSH
97899: LD_INT 1
97901: PPUSH
97902: CALL_OW 51
// tmp := tmp ^ un ;
97906: LD_ADDR_VAR 0 3
97910: PUSH
97911: LD_VAR 0 3
97915: PUSH
97916: LD_VAR 0 2
97920: ADD
97921: ST_TO_ADDR
// end ;
97922: GO 97818
97924: POP
97925: POP
// repeat wait ( 0 0$1 ) ;
97926: LD_INT 35
97928: PPUSH
97929: CALL_OW 67
// for un in tmp do
97933: LD_ADDR_VAR 0 2
97937: PUSH
97938: LD_VAR 0 3
97942: PUSH
97943: FOR_IN
97944: IFFALSE 98018
// begin if IsDead ( un ) then
97946: LD_VAR 0 2
97950: PPUSH
97951: CALL_OW 301
97955: IFFALSE 97975
// begin tmp := tmp diff un ;
97957: LD_ADDR_VAR 0 3
97961: PUSH
97962: LD_VAR 0 3
97966: PUSH
97967: LD_VAR 0 2
97971: DIFF
97972: ST_TO_ADDR
// continue ;
97973: GO 97943
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97975: LD_VAR 0 2
97979: PPUSH
97980: LD_INT 3
97982: PUSH
97983: LD_INT 22
97985: PUSH
97986: LD_INT 0
97988: PUSH
97989: EMPTY
97990: LIST
97991: LIST
97992: PUSH
97993: EMPTY
97994: LIST
97995: LIST
97996: PPUSH
97997: CALL_OW 69
98001: PPUSH
98002: LD_VAR 0 2
98006: PPUSH
98007: CALL_OW 74
98011: PPUSH
98012: CALL_OW 115
// end ;
98016: GO 97943
98018: POP
98019: POP
// until not tmp ;
98020: LD_VAR 0 3
98024: NOT
98025: IFFALSE 97926
// end ;
98027: PPOPN 3
98029: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98030: LD_EXP 94
98034: PUSH
98035: LD_EXP 119
98039: AND
98040: IFFALSE 98094
98042: GO 98044
98044: DISABLE
// begin ToLua ( displayTroll(); ) ;
98045: LD_STRING displayTroll();
98047: PPUSH
98048: CALL_OW 559
// wait ( 3 3$00 ) ;
98052: LD_INT 6300
98054: PPUSH
98055: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98059: LD_STRING hideTroll();
98061: PPUSH
98062: CALL_OW 559
// wait ( 1 1$00 ) ;
98066: LD_INT 2100
98068: PPUSH
98069: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98073: LD_STRING displayTroll();
98075: PPUSH
98076: CALL_OW 559
// wait ( 1 1$00 ) ;
98080: LD_INT 2100
98082: PPUSH
98083: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98087: LD_STRING hideTroll();
98089: PPUSH
98090: CALL_OW 559
// end ;
98094: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98095: LD_EXP 94
98099: PUSH
98100: LD_EXP 120
98104: AND
98105: IFFALSE 98168
98107: GO 98109
98109: DISABLE
98110: LD_INT 0
98112: PPUSH
// begin p := 0 ;
98113: LD_ADDR_VAR 0 1
98117: PUSH
98118: LD_INT 0
98120: ST_TO_ADDR
// repeat game_speed := 1 ;
98121: LD_ADDR_OWVAR 65
98125: PUSH
98126: LD_INT 1
98128: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98129: LD_INT 35
98131: PPUSH
98132: CALL_OW 67
// p := p + 1 ;
98136: LD_ADDR_VAR 0 1
98140: PUSH
98141: LD_VAR 0 1
98145: PUSH
98146: LD_INT 1
98148: PLUS
98149: ST_TO_ADDR
// until p >= 60 ;
98150: LD_VAR 0 1
98154: PUSH
98155: LD_INT 60
98157: GREATEREQUAL
98158: IFFALSE 98121
// game_speed := 4 ;
98160: LD_ADDR_OWVAR 65
98164: PUSH
98165: LD_INT 4
98167: ST_TO_ADDR
// end ;
98168: PPOPN 1
98170: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98171: LD_EXP 94
98175: PUSH
98176: LD_EXP 121
98180: AND
98181: IFFALSE 98327
98183: GO 98185
98185: DISABLE
98186: LD_INT 0
98188: PPUSH
98189: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98190: LD_ADDR_VAR 0 1
98194: PUSH
98195: LD_INT 22
98197: PUSH
98198: LD_OWVAR 2
98202: PUSH
98203: EMPTY
98204: LIST
98205: LIST
98206: PUSH
98207: LD_INT 2
98209: PUSH
98210: LD_INT 30
98212: PUSH
98213: LD_INT 0
98215: PUSH
98216: EMPTY
98217: LIST
98218: LIST
98219: PUSH
98220: LD_INT 30
98222: PUSH
98223: LD_INT 1
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: PUSH
98230: EMPTY
98231: LIST
98232: LIST
98233: LIST
98234: PUSH
98235: EMPTY
98236: LIST
98237: LIST
98238: PPUSH
98239: CALL_OW 69
98243: ST_TO_ADDR
// if not depot then
98244: LD_VAR 0 1
98248: NOT
98249: IFFALSE 98253
// exit ;
98251: GO 98327
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98253: LD_ADDR_VAR 0 2
98257: PUSH
98258: LD_VAR 0 1
98262: PUSH
98263: LD_INT 1
98265: PPUSH
98266: LD_VAR 0 1
98270: PPUSH
98271: CALL_OW 12
98275: ARRAY
98276: PPUSH
98277: CALL_OW 274
98281: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98282: LD_VAR 0 2
98286: PPUSH
98287: LD_INT 1
98289: PPUSH
98290: LD_INT 0
98292: PPUSH
98293: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98297: LD_VAR 0 2
98301: PPUSH
98302: LD_INT 2
98304: PPUSH
98305: LD_INT 0
98307: PPUSH
98308: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98312: LD_VAR 0 2
98316: PPUSH
98317: LD_INT 3
98319: PPUSH
98320: LD_INT 0
98322: PPUSH
98323: CALL_OW 277
// end ;
98327: PPOPN 2
98329: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98330: LD_EXP 94
98334: PUSH
98335: LD_EXP 122
98339: AND
98340: IFFALSE 98437
98342: GO 98344
98344: DISABLE
98345: LD_INT 0
98347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98348: LD_ADDR_VAR 0 1
98352: PUSH
98353: LD_INT 22
98355: PUSH
98356: LD_OWVAR 2
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PUSH
98365: LD_INT 21
98367: PUSH
98368: LD_INT 1
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: PUSH
98375: LD_INT 3
98377: PUSH
98378: LD_INT 23
98380: PUSH
98381: LD_INT 0
98383: PUSH
98384: EMPTY
98385: LIST
98386: LIST
98387: PUSH
98388: EMPTY
98389: LIST
98390: LIST
98391: PUSH
98392: EMPTY
98393: LIST
98394: LIST
98395: LIST
98396: PPUSH
98397: CALL_OW 69
98401: ST_TO_ADDR
// if not tmp then
98402: LD_VAR 0 1
98406: NOT
98407: IFFALSE 98411
// exit ;
98409: GO 98437
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98411: LD_VAR 0 1
98415: PUSH
98416: LD_INT 1
98418: PPUSH
98419: LD_VAR 0 1
98423: PPUSH
98424: CALL_OW 12
98428: ARRAY
98429: PPUSH
98430: LD_INT 200
98432: PPUSH
98433: CALL_OW 234
// end ;
98437: PPOPN 1
98439: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98440: LD_EXP 94
98444: PUSH
98445: LD_EXP 123
98449: AND
98450: IFFALSE 98529
98452: GO 98454
98454: DISABLE
98455: LD_INT 0
98457: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98458: LD_ADDR_VAR 0 1
98462: PUSH
98463: LD_INT 22
98465: PUSH
98466: LD_OWVAR 2
98470: PUSH
98471: EMPTY
98472: LIST
98473: LIST
98474: PUSH
98475: LD_INT 21
98477: PUSH
98478: LD_INT 2
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: PUSH
98485: EMPTY
98486: LIST
98487: LIST
98488: PPUSH
98489: CALL_OW 69
98493: ST_TO_ADDR
// if not tmp then
98494: LD_VAR 0 1
98498: NOT
98499: IFFALSE 98503
// exit ;
98501: GO 98529
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98503: LD_VAR 0 1
98507: PUSH
98508: LD_INT 1
98510: PPUSH
98511: LD_VAR 0 1
98515: PPUSH
98516: CALL_OW 12
98520: ARRAY
98521: PPUSH
98522: LD_INT 60
98524: PPUSH
98525: CALL_OW 234
// end ;
98529: PPOPN 1
98531: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98532: LD_EXP 94
98536: PUSH
98537: LD_EXP 124
98541: AND
98542: IFFALSE 98641
98544: GO 98546
98546: DISABLE
98547: LD_INT 0
98549: PPUSH
98550: PPUSH
// begin enable ;
98551: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98552: LD_ADDR_VAR 0 1
98556: PUSH
98557: LD_INT 22
98559: PUSH
98560: LD_OWVAR 2
98564: PUSH
98565: EMPTY
98566: LIST
98567: LIST
98568: PUSH
98569: LD_INT 61
98571: PUSH
98572: EMPTY
98573: LIST
98574: PUSH
98575: LD_INT 33
98577: PUSH
98578: LD_INT 2
98580: PUSH
98581: EMPTY
98582: LIST
98583: LIST
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: LIST
98589: PPUSH
98590: CALL_OW 69
98594: ST_TO_ADDR
// if not tmp then
98595: LD_VAR 0 1
98599: NOT
98600: IFFALSE 98604
// exit ;
98602: GO 98641
// for i in tmp do
98604: LD_ADDR_VAR 0 2
98608: PUSH
98609: LD_VAR 0 1
98613: PUSH
98614: FOR_IN
98615: IFFALSE 98639
// if IsControledBy ( i ) then
98617: LD_VAR 0 2
98621: PPUSH
98622: CALL_OW 312
98626: IFFALSE 98637
// ComUnlink ( i ) ;
98628: LD_VAR 0 2
98632: PPUSH
98633: CALL_OW 136
98637: GO 98614
98639: POP
98640: POP
// end ;
98641: PPOPN 2
98643: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98644: LD_EXP 94
98648: PUSH
98649: LD_EXP 125
98653: AND
98654: IFFALSE 98794
98656: GO 98658
98658: DISABLE
98659: LD_INT 0
98661: PPUSH
98662: PPUSH
// begin ToLua ( displayPowell(); ) ;
98663: LD_STRING displayPowell();
98665: PPUSH
98666: CALL_OW 559
// uc_side := 0 ;
98670: LD_ADDR_OWVAR 20
98674: PUSH
98675: LD_INT 0
98677: ST_TO_ADDR
// uc_nation := 2 ;
98678: LD_ADDR_OWVAR 21
98682: PUSH
98683: LD_INT 2
98685: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98686: LD_ADDR_OWVAR 37
98690: PUSH
98691: LD_INT 14
98693: ST_TO_ADDR
// vc_engine := engine_siberite ;
98694: LD_ADDR_OWVAR 39
98698: PUSH
98699: LD_INT 3
98701: ST_TO_ADDR
// vc_control := control_apeman ;
98702: LD_ADDR_OWVAR 38
98706: PUSH
98707: LD_INT 5
98709: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98710: LD_ADDR_OWVAR 40
98714: PUSH
98715: LD_INT 29
98717: ST_TO_ADDR
// un := CreateVehicle ;
98718: LD_ADDR_VAR 0 2
98722: PUSH
98723: CALL_OW 45
98727: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98728: LD_VAR 0 2
98732: PPUSH
98733: LD_INT 1
98735: PPUSH
98736: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98740: LD_INT 35
98742: PPUSH
98743: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98747: LD_VAR 0 2
98751: PPUSH
98752: LD_INT 22
98754: PUSH
98755: LD_OWVAR 2
98759: PUSH
98760: EMPTY
98761: LIST
98762: LIST
98763: PPUSH
98764: CALL_OW 69
98768: PPUSH
98769: LD_VAR 0 2
98773: PPUSH
98774: CALL_OW 74
98778: PPUSH
98779: CALL_OW 115
// until IsDead ( un ) ;
98783: LD_VAR 0 2
98787: PPUSH
98788: CALL_OW 301
98792: IFFALSE 98740
// end ;
98794: PPOPN 2
98796: END
// every 0 0$1 trigger StreamModeActive and sStu do
98797: LD_EXP 94
98801: PUSH
98802: LD_EXP 133
98806: AND
98807: IFFALSE 98823
98809: GO 98811
98811: DISABLE
// begin ToLua ( displayStucuk(); ) ;
98812: LD_STRING displayStucuk();
98814: PPUSH
98815: CALL_OW 559
// ResetFog ;
98819: CALL_OW 335
// end ;
98823: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
98824: LD_EXP 94
98828: PUSH
98829: LD_EXP 126
98833: AND
98834: IFFALSE 98975
98836: GO 98838
98838: DISABLE
98839: LD_INT 0
98841: PPUSH
98842: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98843: LD_ADDR_VAR 0 2
98847: PUSH
98848: LD_INT 22
98850: PUSH
98851: LD_OWVAR 2
98855: PUSH
98856: EMPTY
98857: LIST
98858: LIST
98859: PUSH
98860: LD_INT 21
98862: PUSH
98863: LD_INT 1
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: PPUSH
98874: CALL_OW 69
98878: ST_TO_ADDR
// if not tmp then
98879: LD_VAR 0 2
98883: NOT
98884: IFFALSE 98888
// exit ;
98886: GO 98975
// un := tmp [ rand ( 1 , tmp ) ] ;
98888: LD_ADDR_VAR 0 1
98892: PUSH
98893: LD_VAR 0 2
98897: PUSH
98898: LD_INT 1
98900: PPUSH
98901: LD_VAR 0 2
98905: PPUSH
98906: CALL_OW 12
98910: ARRAY
98911: ST_TO_ADDR
// SetSide ( un , 0 ) ;
98912: LD_VAR 0 1
98916: PPUSH
98917: LD_INT 0
98919: PPUSH
98920: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98924: LD_VAR 0 1
98928: PPUSH
98929: LD_OWVAR 3
98933: PUSH
98934: LD_VAR 0 1
98938: DIFF
98939: PPUSH
98940: LD_VAR 0 1
98944: PPUSH
98945: CALL_OW 74
98949: PPUSH
98950: CALL_OW 115
// wait ( 0 0$20 ) ;
98954: LD_INT 700
98956: PPUSH
98957: CALL_OW 67
// SetSide ( un , your_side ) ;
98961: LD_VAR 0 1
98965: PPUSH
98966: LD_OWVAR 2
98970: PPUSH
98971: CALL_OW 235
// end ;
98975: PPOPN 2
98977: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98978: LD_EXP 94
98982: PUSH
98983: LD_EXP 127
98987: AND
98988: IFFALSE 99094
98990: GO 98992
98992: DISABLE
98993: LD_INT 0
98995: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98996: LD_ADDR_VAR 0 1
99000: PUSH
99001: LD_INT 22
99003: PUSH
99004: LD_OWVAR 2
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: PUSH
99013: LD_INT 2
99015: PUSH
99016: LD_INT 30
99018: PUSH
99019: LD_INT 0
99021: PUSH
99022: EMPTY
99023: LIST
99024: LIST
99025: PUSH
99026: LD_INT 30
99028: PUSH
99029: LD_INT 1
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: PUSH
99036: EMPTY
99037: LIST
99038: LIST
99039: LIST
99040: PUSH
99041: EMPTY
99042: LIST
99043: LIST
99044: PPUSH
99045: CALL_OW 69
99049: ST_TO_ADDR
// if not depot then
99050: LD_VAR 0 1
99054: NOT
99055: IFFALSE 99059
// exit ;
99057: GO 99094
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99059: LD_VAR 0 1
99063: PUSH
99064: LD_INT 1
99066: ARRAY
99067: PPUSH
99068: CALL_OW 250
99072: PPUSH
99073: LD_VAR 0 1
99077: PUSH
99078: LD_INT 1
99080: ARRAY
99081: PPUSH
99082: CALL_OW 251
99086: PPUSH
99087: LD_INT 70
99089: PPUSH
99090: CALL_OW 495
// end ;
99094: PPOPN 1
99096: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99097: LD_EXP 94
99101: PUSH
99102: LD_EXP 128
99106: AND
99107: IFFALSE 99318
99109: GO 99111
99111: DISABLE
99112: LD_INT 0
99114: PPUSH
99115: PPUSH
99116: PPUSH
99117: PPUSH
99118: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99119: LD_ADDR_VAR 0 5
99123: PUSH
99124: LD_INT 22
99126: PUSH
99127: LD_OWVAR 2
99131: PUSH
99132: EMPTY
99133: LIST
99134: LIST
99135: PUSH
99136: LD_INT 21
99138: PUSH
99139: LD_INT 1
99141: PUSH
99142: EMPTY
99143: LIST
99144: LIST
99145: PUSH
99146: EMPTY
99147: LIST
99148: LIST
99149: PPUSH
99150: CALL_OW 69
99154: ST_TO_ADDR
// if not tmp then
99155: LD_VAR 0 5
99159: NOT
99160: IFFALSE 99164
// exit ;
99162: GO 99318
// for i in tmp do
99164: LD_ADDR_VAR 0 1
99168: PUSH
99169: LD_VAR 0 5
99173: PUSH
99174: FOR_IN
99175: IFFALSE 99316
// begin d := rand ( 0 , 5 ) ;
99177: LD_ADDR_VAR 0 4
99181: PUSH
99182: LD_INT 0
99184: PPUSH
99185: LD_INT 5
99187: PPUSH
99188: CALL_OW 12
99192: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99193: LD_ADDR_VAR 0 2
99197: PUSH
99198: LD_VAR 0 1
99202: PPUSH
99203: CALL_OW 250
99207: PPUSH
99208: LD_VAR 0 4
99212: PPUSH
99213: LD_INT 3
99215: PPUSH
99216: LD_INT 12
99218: PPUSH
99219: CALL_OW 12
99223: PPUSH
99224: CALL_OW 272
99228: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99229: LD_ADDR_VAR 0 3
99233: PUSH
99234: LD_VAR 0 1
99238: PPUSH
99239: CALL_OW 251
99243: PPUSH
99244: LD_VAR 0 4
99248: PPUSH
99249: LD_INT 3
99251: PPUSH
99252: LD_INT 12
99254: PPUSH
99255: CALL_OW 12
99259: PPUSH
99260: CALL_OW 273
99264: ST_TO_ADDR
// if ValidHex ( x , y ) then
99265: LD_VAR 0 2
99269: PPUSH
99270: LD_VAR 0 3
99274: PPUSH
99275: CALL_OW 488
99279: IFFALSE 99314
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99281: LD_VAR 0 1
99285: PPUSH
99286: LD_VAR 0 2
99290: PPUSH
99291: LD_VAR 0 3
99295: PPUSH
99296: LD_INT 3
99298: PPUSH
99299: LD_INT 6
99301: PPUSH
99302: CALL_OW 12
99306: PPUSH
99307: LD_INT 1
99309: PPUSH
99310: CALL_OW 483
// end ;
99314: GO 99174
99316: POP
99317: POP
// end ;
99318: PPOPN 5
99320: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99321: LD_EXP 94
99325: PUSH
99326: LD_EXP 129
99330: AND
99331: IFFALSE 99425
99333: GO 99335
99335: DISABLE
99336: LD_INT 0
99338: PPUSH
99339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99340: LD_ADDR_VAR 0 2
99344: PUSH
99345: LD_INT 22
99347: PUSH
99348: LD_OWVAR 2
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: PUSH
99357: LD_INT 32
99359: PUSH
99360: LD_INT 1
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: PUSH
99367: LD_INT 21
99369: PUSH
99370: LD_INT 2
99372: PUSH
99373: EMPTY
99374: LIST
99375: LIST
99376: PUSH
99377: EMPTY
99378: LIST
99379: LIST
99380: LIST
99381: PPUSH
99382: CALL_OW 69
99386: ST_TO_ADDR
// if not tmp then
99387: LD_VAR 0 2
99391: NOT
99392: IFFALSE 99396
// exit ;
99394: GO 99425
// for i in tmp do
99396: LD_ADDR_VAR 0 1
99400: PUSH
99401: LD_VAR 0 2
99405: PUSH
99406: FOR_IN
99407: IFFALSE 99423
// SetFuel ( i , 0 ) ;
99409: LD_VAR 0 1
99413: PPUSH
99414: LD_INT 0
99416: PPUSH
99417: CALL_OW 240
99421: GO 99406
99423: POP
99424: POP
// end ;
99425: PPOPN 2
99427: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99428: LD_EXP 94
99432: PUSH
99433: LD_EXP 130
99437: AND
99438: IFFALSE 99504
99440: GO 99442
99442: DISABLE
99443: LD_INT 0
99445: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99446: LD_ADDR_VAR 0 1
99450: PUSH
99451: LD_INT 22
99453: PUSH
99454: LD_OWVAR 2
99458: PUSH
99459: EMPTY
99460: LIST
99461: LIST
99462: PUSH
99463: LD_INT 30
99465: PUSH
99466: LD_INT 29
99468: PUSH
99469: EMPTY
99470: LIST
99471: LIST
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: PPUSH
99477: CALL_OW 69
99481: ST_TO_ADDR
// if not tmp then
99482: LD_VAR 0 1
99486: NOT
99487: IFFALSE 99491
// exit ;
99489: GO 99504
// DestroyUnit ( tmp [ 1 ] ) ;
99491: LD_VAR 0 1
99495: PUSH
99496: LD_INT 1
99498: ARRAY
99499: PPUSH
99500: CALL_OW 65
// end ;
99504: PPOPN 1
99506: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99507: LD_EXP 94
99511: PUSH
99512: LD_EXP 132
99516: AND
99517: IFFALSE 99646
99519: GO 99521
99521: DISABLE
99522: LD_INT 0
99524: PPUSH
// begin uc_side := 0 ;
99525: LD_ADDR_OWVAR 20
99529: PUSH
99530: LD_INT 0
99532: ST_TO_ADDR
// uc_nation := nation_arabian ;
99533: LD_ADDR_OWVAR 21
99537: PUSH
99538: LD_INT 2
99540: ST_TO_ADDR
// hc_gallery :=  ;
99541: LD_ADDR_OWVAR 33
99545: PUSH
99546: LD_STRING 
99548: ST_TO_ADDR
// hc_name :=  ;
99549: LD_ADDR_OWVAR 26
99553: PUSH
99554: LD_STRING 
99556: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99557: LD_INT 1
99559: PPUSH
99560: LD_INT 11
99562: PPUSH
99563: LD_INT 10
99565: PPUSH
99566: CALL_OW 380
// un := CreateHuman ;
99570: LD_ADDR_VAR 0 1
99574: PUSH
99575: CALL_OW 44
99579: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99580: LD_VAR 0 1
99584: PPUSH
99585: LD_INT 1
99587: PPUSH
99588: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99592: LD_INT 35
99594: PPUSH
99595: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99599: LD_VAR 0 1
99603: PPUSH
99604: LD_INT 22
99606: PUSH
99607: LD_OWVAR 2
99611: PUSH
99612: EMPTY
99613: LIST
99614: LIST
99615: PPUSH
99616: CALL_OW 69
99620: PPUSH
99621: LD_VAR 0 1
99625: PPUSH
99626: CALL_OW 74
99630: PPUSH
99631: CALL_OW 115
// until IsDead ( un ) ;
99635: LD_VAR 0 1
99639: PPUSH
99640: CALL_OW 301
99644: IFFALSE 99592
// end ;
99646: PPOPN 1
99648: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99649: LD_EXP 94
99653: PUSH
99654: LD_EXP 134
99658: AND
99659: IFFALSE 99671
99661: GO 99663
99663: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99664: LD_STRING earthquake(getX(game), 0, 32)
99666: PPUSH
99667: CALL_OW 559
99671: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99672: LD_EXP 94
99676: PUSH
99677: LD_EXP 135
99681: AND
99682: IFFALSE 99773
99684: GO 99686
99686: DISABLE
99687: LD_INT 0
99689: PPUSH
// begin enable ;
99690: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99691: LD_ADDR_VAR 0 1
99695: PUSH
99696: LD_INT 22
99698: PUSH
99699: LD_OWVAR 2
99703: PUSH
99704: EMPTY
99705: LIST
99706: LIST
99707: PUSH
99708: LD_INT 21
99710: PUSH
99711: LD_INT 2
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: PUSH
99718: LD_INT 33
99720: PUSH
99721: LD_INT 3
99723: PUSH
99724: EMPTY
99725: LIST
99726: LIST
99727: PUSH
99728: EMPTY
99729: LIST
99730: LIST
99731: LIST
99732: PPUSH
99733: CALL_OW 69
99737: ST_TO_ADDR
// if not tmp then
99738: LD_VAR 0 1
99742: NOT
99743: IFFALSE 99747
// exit ;
99745: GO 99773
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99747: LD_VAR 0 1
99751: PUSH
99752: LD_INT 1
99754: PPUSH
99755: LD_VAR 0 1
99759: PPUSH
99760: CALL_OW 12
99764: ARRAY
99765: PPUSH
99766: LD_INT 1
99768: PPUSH
99769: CALL_OW 234
// end ;
99773: PPOPN 1
99775: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99776: LD_EXP 94
99780: PUSH
99781: LD_EXP 136
99785: AND
99786: IFFALSE 99927
99788: GO 99790
99790: DISABLE
99791: LD_INT 0
99793: PPUSH
99794: PPUSH
99795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99796: LD_ADDR_VAR 0 3
99800: PUSH
99801: LD_INT 22
99803: PUSH
99804: LD_OWVAR 2
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 25
99815: PUSH
99816: LD_INT 1
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: EMPTY
99824: LIST
99825: LIST
99826: PPUSH
99827: CALL_OW 69
99831: ST_TO_ADDR
// if not tmp then
99832: LD_VAR 0 3
99836: NOT
99837: IFFALSE 99841
// exit ;
99839: GO 99927
// un := tmp [ rand ( 1 , tmp ) ] ;
99841: LD_ADDR_VAR 0 2
99845: PUSH
99846: LD_VAR 0 3
99850: PUSH
99851: LD_INT 1
99853: PPUSH
99854: LD_VAR 0 3
99858: PPUSH
99859: CALL_OW 12
99863: ARRAY
99864: ST_TO_ADDR
// if Crawls ( un ) then
99865: LD_VAR 0 2
99869: PPUSH
99870: CALL_OW 318
99874: IFFALSE 99885
// ComWalk ( un ) ;
99876: LD_VAR 0 2
99880: PPUSH
99881: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
99885: LD_VAR 0 2
99889: PPUSH
99890: LD_INT 9
99892: PPUSH
99893: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
99897: LD_INT 28
99899: PPUSH
99900: LD_OWVAR 2
99904: PPUSH
99905: LD_INT 2
99907: PPUSH
99908: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
99912: LD_INT 29
99914: PPUSH
99915: LD_OWVAR 2
99919: PPUSH
99920: LD_INT 2
99922: PPUSH
99923: CALL_OW 322
// end ;
99927: PPOPN 3
99929: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99930: LD_EXP 94
99934: PUSH
99935: LD_EXP 137
99939: AND
99940: IFFALSE 100051
99942: GO 99944
99944: DISABLE
99945: LD_INT 0
99947: PPUSH
99948: PPUSH
99949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99950: LD_ADDR_VAR 0 3
99954: PUSH
99955: LD_INT 22
99957: PUSH
99958: LD_OWVAR 2
99962: PUSH
99963: EMPTY
99964: LIST
99965: LIST
99966: PUSH
99967: LD_INT 25
99969: PUSH
99970: LD_INT 1
99972: PUSH
99973: EMPTY
99974: LIST
99975: LIST
99976: PUSH
99977: EMPTY
99978: LIST
99979: LIST
99980: PPUSH
99981: CALL_OW 69
99985: ST_TO_ADDR
// if not tmp then
99986: LD_VAR 0 3
99990: NOT
99991: IFFALSE 99995
// exit ;
99993: GO 100051
// un := tmp [ rand ( 1 , tmp ) ] ;
99995: LD_ADDR_VAR 0 2
99999: PUSH
100000: LD_VAR 0 3
100004: PUSH
100005: LD_INT 1
100007: PPUSH
100008: LD_VAR 0 3
100012: PPUSH
100013: CALL_OW 12
100017: ARRAY
100018: ST_TO_ADDR
// if Crawls ( un ) then
100019: LD_VAR 0 2
100023: PPUSH
100024: CALL_OW 318
100028: IFFALSE 100039
// ComWalk ( un ) ;
100030: LD_VAR 0 2
100034: PPUSH
100035: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100039: LD_VAR 0 2
100043: PPUSH
100044: LD_INT 8
100046: PPUSH
100047: CALL_OW 336
// end ;
100051: PPOPN 3
100053: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100054: LD_EXP 94
100058: PUSH
100059: LD_EXP 138
100063: AND
100064: IFFALSE 100208
100066: GO 100068
100068: DISABLE
100069: LD_INT 0
100071: PPUSH
100072: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100073: LD_ADDR_VAR 0 2
100077: PUSH
100078: LD_INT 22
100080: PUSH
100081: LD_OWVAR 2
100085: PUSH
100086: EMPTY
100087: LIST
100088: LIST
100089: PUSH
100090: LD_INT 21
100092: PUSH
100093: LD_INT 2
100095: PUSH
100096: EMPTY
100097: LIST
100098: LIST
100099: PUSH
100100: LD_INT 2
100102: PUSH
100103: LD_INT 34
100105: PUSH
100106: LD_INT 12
100108: PUSH
100109: EMPTY
100110: LIST
100111: LIST
100112: PUSH
100113: LD_INT 34
100115: PUSH
100116: LD_INT 51
100118: PUSH
100119: EMPTY
100120: LIST
100121: LIST
100122: PUSH
100123: LD_INT 34
100125: PUSH
100126: LD_INT 32
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: PUSH
100133: EMPTY
100134: LIST
100135: LIST
100136: LIST
100137: LIST
100138: PUSH
100139: EMPTY
100140: LIST
100141: LIST
100142: LIST
100143: PPUSH
100144: CALL_OW 69
100148: ST_TO_ADDR
// if not tmp then
100149: LD_VAR 0 2
100153: NOT
100154: IFFALSE 100158
// exit ;
100156: GO 100208
// for i in tmp do
100158: LD_ADDR_VAR 0 1
100162: PUSH
100163: LD_VAR 0 2
100167: PUSH
100168: FOR_IN
100169: IFFALSE 100206
// if GetCargo ( i , mat_artifact ) = 0 then
100171: LD_VAR 0 1
100175: PPUSH
100176: LD_INT 4
100178: PPUSH
100179: CALL_OW 289
100183: PUSH
100184: LD_INT 0
100186: EQUAL
100187: IFFALSE 100204
// SetCargo ( i , mat_siberit , 100 ) ;
100189: LD_VAR 0 1
100193: PPUSH
100194: LD_INT 3
100196: PPUSH
100197: LD_INT 100
100199: PPUSH
100200: CALL_OW 290
100204: GO 100168
100206: POP
100207: POP
// end ;
100208: PPOPN 2
100210: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100211: LD_EXP 94
100215: PUSH
100216: LD_EXP 139
100220: AND
100221: IFFALSE 100404
100223: GO 100225
100225: DISABLE
100226: LD_INT 0
100228: PPUSH
100229: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100230: LD_ADDR_VAR 0 2
100234: PUSH
100235: LD_INT 22
100237: PUSH
100238: LD_OWVAR 2
100242: PUSH
100243: EMPTY
100244: LIST
100245: LIST
100246: PPUSH
100247: CALL_OW 69
100251: ST_TO_ADDR
// if not tmp then
100252: LD_VAR 0 2
100256: NOT
100257: IFFALSE 100261
// exit ;
100259: GO 100404
// for i := 1 to 2 do
100261: LD_ADDR_VAR 0 1
100265: PUSH
100266: DOUBLE
100267: LD_INT 1
100269: DEC
100270: ST_TO_ADDR
100271: LD_INT 2
100273: PUSH
100274: FOR_TO
100275: IFFALSE 100402
// begin uc_side := your_side ;
100277: LD_ADDR_OWVAR 20
100281: PUSH
100282: LD_OWVAR 2
100286: ST_TO_ADDR
// uc_nation := nation_american ;
100287: LD_ADDR_OWVAR 21
100291: PUSH
100292: LD_INT 1
100294: ST_TO_ADDR
// vc_chassis := us_morphling ;
100295: LD_ADDR_OWVAR 37
100299: PUSH
100300: LD_INT 5
100302: ST_TO_ADDR
// vc_engine := engine_siberite ;
100303: LD_ADDR_OWVAR 39
100307: PUSH
100308: LD_INT 3
100310: ST_TO_ADDR
// vc_control := control_computer ;
100311: LD_ADDR_OWVAR 38
100315: PUSH
100316: LD_INT 3
100318: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100319: LD_ADDR_OWVAR 40
100323: PUSH
100324: LD_INT 10
100326: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100327: LD_VAR 0 2
100331: PUSH
100332: LD_INT 1
100334: ARRAY
100335: PPUSH
100336: CALL_OW 310
100340: NOT
100341: IFFALSE 100388
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100343: CALL_OW 45
100347: PPUSH
100348: LD_VAR 0 2
100352: PUSH
100353: LD_INT 1
100355: ARRAY
100356: PPUSH
100357: CALL_OW 250
100361: PPUSH
100362: LD_VAR 0 2
100366: PUSH
100367: LD_INT 1
100369: ARRAY
100370: PPUSH
100371: CALL_OW 251
100375: PPUSH
100376: LD_INT 12
100378: PPUSH
100379: LD_INT 1
100381: PPUSH
100382: CALL_OW 50
100386: GO 100400
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100388: CALL_OW 45
100392: PPUSH
100393: LD_INT 1
100395: PPUSH
100396: CALL_OW 51
// end ;
100400: GO 100274
100402: POP
100403: POP
// end ;
100404: PPOPN 2
100406: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100407: LD_EXP 94
100411: PUSH
100412: LD_EXP 140
100416: AND
100417: IFFALSE 100639
100419: GO 100421
100421: DISABLE
100422: LD_INT 0
100424: PPUSH
100425: PPUSH
100426: PPUSH
100427: PPUSH
100428: PPUSH
100429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100430: LD_ADDR_VAR 0 6
100434: PUSH
100435: LD_INT 22
100437: PUSH
100438: LD_OWVAR 2
100442: PUSH
100443: EMPTY
100444: LIST
100445: LIST
100446: PUSH
100447: LD_INT 21
100449: PUSH
100450: LD_INT 1
100452: PUSH
100453: EMPTY
100454: LIST
100455: LIST
100456: PUSH
100457: LD_INT 3
100459: PUSH
100460: LD_INT 23
100462: PUSH
100463: LD_INT 0
100465: PUSH
100466: EMPTY
100467: LIST
100468: LIST
100469: PUSH
100470: EMPTY
100471: LIST
100472: LIST
100473: PUSH
100474: EMPTY
100475: LIST
100476: LIST
100477: LIST
100478: PPUSH
100479: CALL_OW 69
100483: ST_TO_ADDR
// if not tmp then
100484: LD_VAR 0 6
100488: NOT
100489: IFFALSE 100493
// exit ;
100491: GO 100639
// s1 := rand ( 1 , 4 ) ;
100493: LD_ADDR_VAR 0 2
100497: PUSH
100498: LD_INT 1
100500: PPUSH
100501: LD_INT 4
100503: PPUSH
100504: CALL_OW 12
100508: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100509: LD_ADDR_VAR 0 4
100513: PUSH
100514: LD_VAR 0 6
100518: PUSH
100519: LD_INT 1
100521: ARRAY
100522: PPUSH
100523: LD_VAR 0 2
100527: PPUSH
100528: CALL_OW 259
100532: ST_TO_ADDR
// if s1 = 1 then
100533: LD_VAR 0 2
100537: PUSH
100538: LD_INT 1
100540: EQUAL
100541: IFFALSE 100561
// s2 := rand ( 2 , 4 ) else
100543: LD_ADDR_VAR 0 3
100547: PUSH
100548: LD_INT 2
100550: PPUSH
100551: LD_INT 4
100553: PPUSH
100554: CALL_OW 12
100558: ST_TO_ADDR
100559: GO 100569
// s2 := 1 ;
100561: LD_ADDR_VAR 0 3
100565: PUSH
100566: LD_INT 1
100568: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100569: LD_ADDR_VAR 0 5
100573: PUSH
100574: LD_VAR 0 6
100578: PUSH
100579: LD_INT 1
100581: ARRAY
100582: PPUSH
100583: LD_VAR 0 3
100587: PPUSH
100588: CALL_OW 259
100592: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100593: LD_VAR 0 6
100597: PUSH
100598: LD_INT 1
100600: ARRAY
100601: PPUSH
100602: LD_VAR 0 2
100606: PPUSH
100607: LD_VAR 0 5
100611: PPUSH
100612: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100616: LD_VAR 0 6
100620: PUSH
100621: LD_INT 1
100623: ARRAY
100624: PPUSH
100625: LD_VAR 0 3
100629: PPUSH
100630: LD_VAR 0 4
100634: PPUSH
100635: CALL_OW 237
// end ;
100639: PPOPN 6
100641: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100642: LD_EXP 94
100646: PUSH
100647: LD_EXP 141
100651: AND
100652: IFFALSE 100731
100654: GO 100656
100656: DISABLE
100657: LD_INT 0
100659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100660: LD_ADDR_VAR 0 1
100664: PUSH
100665: LD_INT 22
100667: PUSH
100668: LD_OWVAR 2
100672: PUSH
100673: EMPTY
100674: LIST
100675: LIST
100676: PUSH
100677: LD_INT 30
100679: PUSH
100680: LD_INT 3
100682: PUSH
100683: EMPTY
100684: LIST
100685: LIST
100686: PUSH
100687: EMPTY
100688: LIST
100689: LIST
100690: PPUSH
100691: CALL_OW 69
100695: ST_TO_ADDR
// if not tmp then
100696: LD_VAR 0 1
100700: NOT
100701: IFFALSE 100705
// exit ;
100703: GO 100731
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100705: LD_VAR 0 1
100709: PUSH
100710: LD_INT 1
100712: PPUSH
100713: LD_VAR 0 1
100717: PPUSH
100718: CALL_OW 12
100722: ARRAY
100723: PPUSH
100724: LD_INT 1
100726: PPUSH
100727: CALL_OW 234
// end ;
100731: PPOPN 1
100733: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100734: LD_EXP 94
100738: PUSH
100739: LD_EXP 142
100743: AND
100744: IFFALSE 100856
100746: GO 100748
100748: DISABLE
100749: LD_INT 0
100751: PPUSH
100752: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100753: LD_ADDR_VAR 0 2
100757: PUSH
100758: LD_INT 22
100760: PUSH
100761: LD_OWVAR 2
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PUSH
100770: LD_INT 2
100772: PUSH
100773: LD_INT 30
100775: PUSH
100776: LD_INT 27
100778: PUSH
100779: EMPTY
100780: LIST
100781: LIST
100782: PUSH
100783: LD_INT 30
100785: PUSH
100786: LD_INT 26
100788: PUSH
100789: EMPTY
100790: LIST
100791: LIST
100792: PUSH
100793: LD_INT 30
100795: PUSH
100796: LD_INT 28
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: LIST
100807: LIST
100808: PUSH
100809: EMPTY
100810: LIST
100811: LIST
100812: PPUSH
100813: CALL_OW 69
100817: ST_TO_ADDR
// if not tmp then
100818: LD_VAR 0 2
100822: NOT
100823: IFFALSE 100827
// exit ;
100825: GO 100856
// for i in tmp do
100827: LD_ADDR_VAR 0 1
100831: PUSH
100832: LD_VAR 0 2
100836: PUSH
100837: FOR_IN
100838: IFFALSE 100854
// SetLives ( i , 1 ) ;
100840: LD_VAR 0 1
100844: PPUSH
100845: LD_INT 1
100847: PPUSH
100848: CALL_OW 234
100852: GO 100837
100854: POP
100855: POP
// end ;
100856: PPOPN 2
100858: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
100859: LD_EXP 94
100863: PUSH
100864: LD_EXP 143
100868: AND
100869: IFFALSE 101156
100871: GO 100873
100873: DISABLE
100874: LD_INT 0
100876: PPUSH
100877: PPUSH
100878: PPUSH
// begin i := rand ( 1 , 7 ) ;
100879: LD_ADDR_VAR 0 1
100883: PUSH
100884: LD_INT 1
100886: PPUSH
100887: LD_INT 7
100889: PPUSH
100890: CALL_OW 12
100894: ST_TO_ADDR
// case i of 1 :
100895: LD_VAR 0 1
100899: PUSH
100900: LD_INT 1
100902: DOUBLE
100903: EQUAL
100904: IFTRUE 100908
100906: GO 100918
100908: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
100909: LD_STRING earthquake(getX(game), 0, 32)
100911: PPUSH
100912: CALL_OW 559
100916: GO 101156
100918: LD_INT 2
100920: DOUBLE
100921: EQUAL
100922: IFTRUE 100926
100924: GO 100940
100926: POP
// begin ToLua ( displayStucuk(); ) ;
100927: LD_STRING displayStucuk();
100929: PPUSH
100930: CALL_OW 559
// ResetFog ;
100934: CALL_OW 335
// end ; 3 :
100938: GO 101156
100940: LD_INT 3
100942: DOUBLE
100943: EQUAL
100944: IFTRUE 100948
100946: GO 101052
100948: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100949: LD_ADDR_VAR 0 2
100953: PUSH
100954: LD_INT 22
100956: PUSH
100957: LD_OWVAR 2
100961: PUSH
100962: EMPTY
100963: LIST
100964: LIST
100965: PUSH
100966: LD_INT 25
100968: PUSH
100969: LD_INT 1
100971: PUSH
100972: EMPTY
100973: LIST
100974: LIST
100975: PUSH
100976: EMPTY
100977: LIST
100978: LIST
100979: PPUSH
100980: CALL_OW 69
100984: ST_TO_ADDR
// if not tmp then
100985: LD_VAR 0 2
100989: NOT
100990: IFFALSE 100994
// exit ;
100992: GO 101156
// un := tmp [ rand ( 1 , tmp ) ] ;
100994: LD_ADDR_VAR 0 3
100998: PUSH
100999: LD_VAR 0 2
101003: PUSH
101004: LD_INT 1
101006: PPUSH
101007: LD_VAR 0 2
101011: PPUSH
101012: CALL_OW 12
101016: ARRAY
101017: ST_TO_ADDR
// if Crawls ( un ) then
101018: LD_VAR 0 3
101022: PPUSH
101023: CALL_OW 318
101027: IFFALSE 101038
// ComWalk ( un ) ;
101029: LD_VAR 0 3
101033: PPUSH
101034: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101038: LD_VAR 0 3
101042: PPUSH
101043: LD_INT 8
101045: PPUSH
101046: CALL_OW 336
// end ; 4 :
101050: GO 101156
101052: LD_INT 4
101054: DOUBLE
101055: EQUAL
101056: IFTRUE 101060
101058: GO 101134
101060: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101061: LD_ADDR_VAR 0 2
101065: PUSH
101066: LD_INT 22
101068: PUSH
101069: LD_OWVAR 2
101073: PUSH
101074: EMPTY
101075: LIST
101076: LIST
101077: PUSH
101078: LD_INT 30
101080: PUSH
101081: LD_INT 29
101083: PUSH
101084: EMPTY
101085: LIST
101086: LIST
101087: PUSH
101088: EMPTY
101089: LIST
101090: LIST
101091: PPUSH
101092: CALL_OW 69
101096: ST_TO_ADDR
// if not tmp then
101097: LD_VAR 0 2
101101: NOT
101102: IFFALSE 101106
// exit ;
101104: GO 101156
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101106: LD_VAR 0 2
101110: PUSH
101111: LD_INT 1
101113: ARRAY
101114: PPUSH
101115: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101119: LD_VAR 0 2
101123: PUSH
101124: LD_INT 1
101126: ARRAY
101127: PPUSH
101128: CALL_OW 65
// end ; 5 .. 7 :
101132: GO 101156
101134: LD_INT 5
101136: DOUBLE
101137: GREATEREQUAL
101138: IFFALSE 101146
101140: LD_INT 7
101142: DOUBLE
101143: LESSEQUAL
101144: IFTRUE 101148
101146: GO 101155
101148: POP
// StreamSibBomb ; end ;
101149: CALL 97393 0 0
101153: GO 101156
101155: POP
// end ;
101156: PPOPN 3
101158: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101159: LD_EXP 94
101163: PUSH
101164: LD_EXP 144
101168: AND
101169: IFFALSE 101325
101171: GO 101173
101173: DISABLE
101174: LD_INT 0
101176: PPUSH
101177: PPUSH
101178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101179: LD_ADDR_VAR 0 2
101183: PUSH
101184: LD_INT 81
101186: PUSH
101187: LD_OWVAR 2
101191: PUSH
101192: EMPTY
101193: LIST
101194: LIST
101195: PUSH
101196: LD_INT 2
101198: PUSH
101199: LD_INT 21
101201: PUSH
101202: LD_INT 1
101204: PUSH
101205: EMPTY
101206: LIST
101207: LIST
101208: PUSH
101209: LD_INT 21
101211: PUSH
101212: LD_INT 2
101214: PUSH
101215: EMPTY
101216: LIST
101217: LIST
101218: PUSH
101219: EMPTY
101220: LIST
101221: LIST
101222: LIST
101223: PUSH
101224: EMPTY
101225: LIST
101226: LIST
101227: PPUSH
101228: CALL_OW 69
101232: ST_TO_ADDR
// if not tmp then
101233: LD_VAR 0 2
101237: NOT
101238: IFFALSE 101242
// exit ;
101240: GO 101325
// p := 0 ;
101242: LD_ADDR_VAR 0 3
101246: PUSH
101247: LD_INT 0
101249: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101250: LD_INT 35
101252: PPUSH
101253: CALL_OW 67
// p := p + 1 ;
101257: LD_ADDR_VAR 0 3
101261: PUSH
101262: LD_VAR 0 3
101266: PUSH
101267: LD_INT 1
101269: PLUS
101270: ST_TO_ADDR
// for i in tmp do
101271: LD_ADDR_VAR 0 1
101275: PUSH
101276: LD_VAR 0 2
101280: PUSH
101281: FOR_IN
101282: IFFALSE 101313
// if GetLives ( i ) < 1000 then
101284: LD_VAR 0 1
101288: PPUSH
101289: CALL_OW 256
101293: PUSH
101294: LD_INT 1000
101296: LESS
101297: IFFALSE 101311
// SetLives ( i , 1000 ) ;
101299: LD_VAR 0 1
101303: PPUSH
101304: LD_INT 1000
101306: PPUSH
101307: CALL_OW 234
101311: GO 101281
101313: POP
101314: POP
// until p > 20 ;
101315: LD_VAR 0 3
101319: PUSH
101320: LD_INT 20
101322: GREATER
101323: IFFALSE 101250
// end ;
101325: PPOPN 3
101327: END
// every 0 0$1 trigger StreamModeActive and sTime do
101328: LD_EXP 94
101332: PUSH
101333: LD_EXP 145
101337: AND
101338: IFFALSE 101373
101340: GO 101342
101342: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101343: LD_INT 28
101345: PPUSH
101346: LD_OWVAR 2
101350: PPUSH
101351: LD_INT 2
101353: PPUSH
101354: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101358: LD_INT 30
101360: PPUSH
101361: LD_OWVAR 2
101365: PPUSH
101366: LD_INT 2
101368: PPUSH
101369: CALL_OW 322
// end ;
101373: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101374: LD_EXP 94
101378: PUSH
101379: LD_EXP 146
101383: AND
101384: IFFALSE 101505
101386: GO 101388
101388: DISABLE
101389: LD_INT 0
101391: PPUSH
101392: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101393: LD_ADDR_VAR 0 2
101397: PUSH
101398: LD_INT 22
101400: PUSH
101401: LD_OWVAR 2
101405: PUSH
101406: EMPTY
101407: LIST
101408: LIST
101409: PUSH
101410: LD_INT 21
101412: PUSH
101413: LD_INT 1
101415: PUSH
101416: EMPTY
101417: LIST
101418: LIST
101419: PUSH
101420: LD_INT 3
101422: PUSH
101423: LD_INT 23
101425: PUSH
101426: LD_INT 0
101428: PUSH
101429: EMPTY
101430: LIST
101431: LIST
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: PUSH
101437: EMPTY
101438: LIST
101439: LIST
101440: LIST
101441: PPUSH
101442: CALL_OW 69
101446: ST_TO_ADDR
// if not tmp then
101447: LD_VAR 0 2
101451: NOT
101452: IFFALSE 101456
// exit ;
101454: GO 101505
// for i in tmp do
101456: LD_ADDR_VAR 0 1
101460: PUSH
101461: LD_VAR 0 2
101465: PUSH
101466: FOR_IN
101467: IFFALSE 101503
// begin if Crawls ( i ) then
101469: LD_VAR 0 1
101473: PPUSH
101474: CALL_OW 318
101478: IFFALSE 101489
// ComWalk ( i ) ;
101480: LD_VAR 0 1
101484: PPUSH
101485: CALL_OW 138
// SetClass ( i , 2 ) ;
101489: LD_VAR 0 1
101493: PPUSH
101494: LD_INT 2
101496: PPUSH
101497: CALL_OW 336
// end ;
101501: GO 101466
101503: POP
101504: POP
// end ;
101505: PPOPN 2
101507: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101508: LD_EXP 94
101512: PUSH
101513: LD_EXP 147
101517: AND
101518: IFFALSE 101806
101520: GO 101522
101522: DISABLE
101523: LD_INT 0
101525: PPUSH
101526: PPUSH
101527: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101528: LD_OWVAR 2
101532: PPUSH
101533: LD_INT 9
101535: PPUSH
101536: LD_INT 1
101538: PPUSH
101539: LD_INT 1
101541: PPUSH
101542: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101546: LD_INT 9
101548: PPUSH
101549: LD_OWVAR 2
101553: PPUSH
101554: CALL_OW 343
// uc_side := 9 ;
101558: LD_ADDR_OWVAR 20
101562: PUSH
101563: LD_INT 9
101565: ST_TO_ADDR
// uc_nation := 2 ;
101566: LD_ADDR_OWVAR 21
101570: PUSH
101571: LD_INT 2
101573: ST_TO_ADDR
// hc_name := Dark Warrior ;
101574: LD_ADDR_OWVAR 26
101578: PUSH
101579: LD_STRING Dark Warrior
101581: ST_TO_ADDR
// hc_gallery :=  ;
101582: LD_ADDR_OWVAR 33
101586: PUSH
101587: LD_STRING 
101589: ST_TO_ADDR
// hc_noskilllimit := true ;
101590: LD_ADDR_OWVAR 76
101594: PUSH
101595: LD_INT 1
101597: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101598: LD_ADDR_OWVAR 31
101602: PUSH
101603: LD_INT 30
101605: PUSH
101606: LD_INT 30
101608: PUSH
101609: LD_INT 30
101611: PUSH
101612: LD_INT 30
101614: PUSH
101615: EMPTY
101616: LIST
101617: LIST
101618: LIST
101619: LIST
101620: ST_TO_ADDR
// un := CreateHuman ;
101621: LD_ADDR_VAR 0 3
101625: PUSH
101626: CALL_OW 44
101630: ST_TO_ADDR
// hc_noskilllimit := false ;
101631: LD_ADDR_OWVAR 76
101635: PUSH
101636: LD_INT 0
101638: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101639: LD_VAR 0 3
101643: PPUSH
101644: LD_INT 1
101646: PPUSH
101647: CALL_OW 51
// ToLua ( playRanger() ) ;
101651: LD_STRING playRanger()
101653: PPUSH
101654: CALL_OW 559
// p := 0 ;
101658: LD_ADDR_VAR 0 2
101662: PUSH
101663: LD_INT 0
101665: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101666: LD_INT 35
101668: PPUSH
101669: CALL_OW 67
// p := p + 1 ;
101673: LD_ADDR_VAR 0 2
101677: PUSH
101678: LD_VAR 0 2
101682: PUSH
101683: LD_INT 1
101685: PLUS
101686: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101687: LD_VAR 0 3
101691: PPUSH
101692: CALL_OW 256
101696: PUSH
101697: LD_INT 1000
101699: LESS
101700: IFFALSE 101714
// SetLives ( un , 1000 ) ;
101702: LD_VAR 0 3
101706: PPUSH
101707: LD_INT 1000
101709: PPUSH
101710: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101714: LD_VAR 0 3
101718: PPUSH
101719: LD_INT 81
101721: PUSH
101722: LD_OWVAR 2
101726: PUSH
101727: EMPTY
101728: LIST
101729: LIST
101730: PUSH
101731: LD_INT 91
101733: PUSH
101734: LD_VAR 0 3
101738: PUSH
101739: LD_INT 30
101741: PUSH
101742: EMPTY
101743: LIST
101744: LIST
101745: LIST
101746: PUSH
101747: EMPTY
101748: LIST
101749: LIST
101750: PPUSH
101751: CALL_OW 69
101755: PPUSH
101756: LD_VAR 0 3
101760: PPUSH
101761: CALL_OW 74
101765: PPUSH
101766: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
101770: LD_VAR 0 2
101774: PUSH
101775: LD_INT 80
101777: GREATER
101778: PUSH
101779: LD_VAR 0 3
101783: PPUSH
101784: CALL_OW 301
101788: OR
101789: IFFALSE 101666
// if un then
101791: LD_VAR 0 3
101795: IFFALSE 101806
// RemoveUnit ( un ) ;
101797: LD_VAR 0 3
101801: PPUSH
101802: CALL_OW 64
// end ;
101806: PPOPN 3
101808: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
101809: LD_EXP 148
101813: IFFALSE 101929
101815: GO 101817
101817: DISABLE
101818: LD_INT 0
101820: PPUSH
101821: PPUSH
101822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101823: LD_ADDR_VAR 0 2
101827: PUSH
101828: LD_INT 81
101830: PUSH
101831: LD_OWVAR 2
101835: PUSH
101836: EMPTY
101837: LIST
101838: LIST
101839: PUSH
101840: LD_INT 21
101842: PUSH
101843: LD_INT 1
101845: PUSH
101846: EMPTY
101847: LIST
101848: LIST
101849: PUSH
101850: EMPTY
101851: LIST
101852: LIST
101853: PPUSH
101854: CALL_OW 69
101858: ST_TO_ADDR
// ToLua ( playComputer() ) ;
101859: LD_STRING playComputer()
101861: PPUSH
101862: CALL_OW 559
// if not tmp then
101866: LD_VAR 0 2
101870: NOT
101871: IFFALSE 101875
// exit ;
101873: GO 101929
// for i in tmp do
101875: LD_ADDR_VAR 0 1
101879: PUSH
101880: LD_VAR 0 2
101884: PUSH
101885: FOR_IN
101886: IFFALSE 101927
// for j := 1 to 4 do
101888: LD_ADDR_VAR 0 3
101892: PUSH
101893: DOUBLE
101894: LD_INT 1
101896: DEC
101897: ST_TO_ADDR
101898: LD_INT 4
101900: PUSH
101901: FOR_TO
101902: IFFALSE 101923
// SetSkill ( i , j , 10 ) ;
101904: LD_VAR 0 1
101908: PPUSH
101909: LD_VAR 0 3
101913: PPUSH
101914: LD_INT 10
101916: PPUSH
101917: CALL_OW 237
101921: GO 101901
101923: POP
101924: POP
101925: GO 101885
101927: POP
101928: POP
// end ;
101929: PPOPN 3
101931: END
// every 0 0$1 trigger s30 do var i , tmp ;
101932: LD_EXP 149
101936: IFFALSE 102005
101938: GO 101940
101940: DISABLE
101941: LD_INT 0
101943: PPUSH
101944: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101945: LD_ADDR_VAR 0 2
101949: PUSH
101950: LD_INT 22
101952: PUSH
101953: LD_OWVAR 2
101957: PUSH
101958: EMPTY
101959: LIST
101960: LIST
101961: PPUSH
101962: CALL_OW 69
101966: ST_TO_ADDR
// if not tmp then
101967: LD_VAR 0 2
101971: NOT
101972: IFFALSE 101976
// exit ;
101974: GO 102005
// for i in tmp do
101976: LD_ADDR_VAR 0 1
101980: PUSH
101981: LD_VAR 0 2
101985: PUSH
101986: FOR_IN
101987: IFFALSE 102003
// SetLives ( i , 300 ) ;
101989: LD_VAR 0 1
101993: PPUSH
101994: LD_INT 300
101996: PPUSH
101997: CALL_OW 234
102001: GO 101986
102003: POP
102004: POP
// end ;
102005: PPOPN 2
102007: END
// every 0 0$1 trigger s60 do var i , tmp ;
102008: LD_EXP 150
102012: IFFALSE 102081
102014: GO 102016
102016: DISABLE
102017: LD_INT 0
102019: PPUSH
102020: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102021: LD_ADDR_VAR 0 2
102025: PUSH
102026: LD_INT 22
102028: PUSH
102029: LD_OWVAR 2
102033: PUSH
102034: EMPTY
102035: LIST
102036: LIST
102037: PPUSH
102038: CALL_OW 69
102042: ST_TO_ADDR
// if not tmp then
102043: LD_VAR 0 2
102047: NOT
102048: IFFALSE 102052
// exit ;
102050: GO 102081
// for i in tmp do
102052: LD_ADDR_VAR 0 1
102056: PUSH
102057: LD_VAR 0 2
102061: PUSH
102062: FOR_IN
102063: IFFALSE 102079
// SetLives ( i , 600 ) ;
102065: LD_VAR 0 1
102069: PPUSH
102070: LD_INT 600
102072: PPUSH
102073: CALL_OW 234
102077: GO 102062
102079: POP
102080: POP
// end ;
102081: PPOPN 2
102083: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102084: LD_INT 0
102086: PPUSH
// case cmd of 301 :
102087: LD_VAR 0 1
102091: PUSH
102092: LD_INT 301
102094: DOUBLE
102095: EQUAL
102096: IFTRUE 102100
102098: GO 102132
102100: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102101: LD_VAR 0 6
102105: PPUSH
102106: LD_VAR 0 7
102110: PPUSH
102111: LD_VAR 0 8
102115: PPUSH
102116: LD_VAR 0 4
102120: PPUSH
102121: LD_VAR 0 5
102125: PPUSH
102126: CALL 103333 0 5
102130: GO 102253
102132: LD_INT 302
102134: DOUBLE
102135: EQUAL
102136: IFTRUE 102140
102138: GO 102177
102140: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102141: LD_VAR 0 6
102145: PPUSH
102146: LD_VAR 0 7
102150: PPUSH
102151: LD_VAR 0 8
102155: PPUSH
102156: LD_VAR 0 9
102160: PPUSH
102161: LD_VAR 0 4
102165: PPUSH
102166: LD_VAR 0 5
102170: PPUSH
102171: CALL 103424 0 6
102175: GO 102253
102177: LD_INT 303
102179: DOUBLE
102180: EQUAL
102181: IFTRUE 102185
102183: GO 102222
102185: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102186: LD_VAR 0 6
102190: PPUSH
102191: LD_VAR 0 7
102195: PPUSH
102196: LD_VAR 0 8
102200: PPUSH
102201: LD_VAR 0 9
102205: PPUSH
102206: LD_VAR 0 4
102210: PPUSH
102211: LD_VAR 0 5
102215: PPUSH
102216: CALL 102258 0 6
102220: GO 102253
102222: LD_INT 304
102224: DOUBLE
102225: EQUAL
102226: IFTRUE 102230
102228: GO 102252
102230: POP
// hHackTeleport ( unit , x , y ) ; end ;
102231: LD_VAR 0 2
102235: PPUSH
102236: LD_VAR 0 4
102240: PPUSH
102241: LD_VAR 0 5
102245: PPUSH
102246: CALL 104017 0 3
102250: GO 102253
102252: POP
// end ;
102253: LD_VAR 0 12
102257: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102258: LD_INT 0
102260: PPUSH
102261: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102262: LD_VAR 0 1
102266: PUSH
102267: LD_INT 1
102269: LESS
102270: PUSH
102271: LD_VAR 0 1
102275: PUSH
102276: LD_INT 3
102278: GREATER
102279: OR
102280: PUSH
102281: LD_VAR 0 5
102285: PPUSH
102286: LD_VAR 0 6
102290: PPUSH
102291: CALL_OW 428
102295: OR
102296: IFFALSE 102300
// exit ;
102298: GO 103020
// uc_side := your_side ;
102300: LD_ADDR_OWVAR 20
102304: PUSH
102305: LD_OWVAR 2
102309: ST_TO_ADDR
// uc_nation := nation ;
102310: LD_ADDR_OWVAR 21
102314: PUSH
102315: LD_VAR 0 1
102319: ST_TO_ADDR
// bc_level = 1 ;
102320: LD_ADDR_OWVAR 43
102324: PUSH
102325: LD_INT 1
102327: ST_TO_ADDR
// case btype of 1 :
102328: LD_VAR 0 2
102332: PUSH
102333: LD_INT 1
102335: DOUBLE
102336: EQUAL
102337: IFTRUE 102341
102339: GO 102352
102341: POP
// bc_type := b_depot ; 2 :
102342: LD_ADDR_OWVAR 42
102346: PUSH
102347: LD_INT 0
102349: ST_TO_ADDR
102350: GO 102964
102352: LD_INT 2
102354: DOUBLE
102355: EQUAL
102356: IFTRUE 102360
102358: GO 102371
102360: POP
// bc_type := b_warehouse ; 3 :
102361: LD_ADDR_OWVAR 42
102365: PUSH
102366: LD_INT 1
102368: ST_TO_ADDR
102369: GO 102964
102371: LD_INT 3
102373: DOUBLE
102374: EQUAL
102375: IFTRUE 102379
102377: GO 102390
102379: POP
// bc_type := b_lab ; 4 .. 9 :
102380: LD_ADDR_OWVAR 42
102384: PUSH
102385: LD_INT 6
102387: ST_TO_ADDR
102388: GO 102964
102390: LD_INT 4
102392: DOUBLE
102393: GREATEREQUAL
102394: IFFALSE 102402
102396: LD_INT 9
102398: DOUBLE
102399: LESSEQUAL
102400: IFTRUE 102404
102402: GO 102456
102404: POP
// begin bc_type := b_lab_half ;
102405: LD_ADDR_OWVAR 42
102409: PUSH
102410: LD_INT 7
102412: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102413: LD_ADDR_OWVAR 44
102417: PUSH
102418: LD_INT 10
102420: PUSH
102421: LD_INT 11
102423: PUSH
102424: LD_INT 12
102426: PUSH
102427: LD_INT 15
102429: PUSH
102430: LD_INT 14
102432: PUSH
102433: LD_INT 13
102435: PUSH
102436: EMPTY
102437: LIST
102438: LIST
102439: LIST
102440: LIST
102441: LIST
102442: LIST
102443: PUSH
102444: LD_VAR 0 2
102448: PUSH
102449: LD_INT 3
102451: MINUS
102452: ARRAY
102453: ST_TO_ADDR
// end ; 10 .. 13 :
102454: GO 102964
102456: LD_INT 10
102458: DOUBLE
102459: GREATEREQUAL
102460: IFFALSE 102468
102462: LD_INT 13
102464: DOUBLE
102465: LESSEQUAL
102466: IFTRUE 102470
102468: GO 102547
102470: POP
// begin bc_type := b_lab_full ;
102471: LD_ADDR_OWVAR 42
102475: PUSH
102476: LD_INT 8
102478: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102479: LD_ADDR_OWVAR 44
102483: PUSH
102484: LD_INT 10
102486: PUSH
102487: LD_INT 12
102489: PUSH
102490: LD_INT 14
102492: PUSH
102493: LD_INT 13
102495: PUSH
102496: EMPTY
102497: LIST
102498: LIST
102499: LIST
102500: LIST
102501: PUSH
102502: LD_VAR 0 2
102506: PUSH
102507: LD_INT 9
102509: MINUS
102510: ARRAY
102511: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102512: LD_ADDR_OWVAR 45
102516: PUSH
102517: LD_INT 11
102519: PUSH
102520: LD_INT 15
102522: PUSH
102523: LD_INT 12
102525: PUSH
102526: LD_INT 15
102528: PUSH
102529: EMPTY
102530: LIST
102531: LIST
102532: LIST
102533: LIST
102534: PUSH
102535: LD_VAR 0 2
102539: PUSH
102540: LD_INT 9
102542: MINUS
102543: ARRAY
102544: ST_TO_ADDR
// end ; 14 :
102545: GO 102964
102547: LD_INT 14
102549: DOUBLE
102550: EQUAL
102551: IFTRUE 102555
102553: GO 102566
102555: POP
// bc_type := b_workshop ; 15 :
102556: LD_ADDR_OWVAR 42
102560: PUSH
102561: LD_INT 2
102563: ST_TO_ADDR
102564: GO 102964
102566: LD_INT 15
102568: DOUBLE
102569: EQUAL
102570: IFTRUE 102574
102572: GO 102585
102574: POP
// bc_type := b_factory ; 16 :
102575: LD_ADDR_OWVAR 42
102579: PUSH
102580: LD_INT 3
102582: ST_TO_ADDR
102583: GO 102964
102585: LD_INT 16
102587: DOUBLE
102588: EQUAL
102589: IFTRUE 102593
102591: GO 102604
102593: POP
// bc_type := b_ext_gun ; 17 :
102594: LD_ADDR_OWVAR 42
102598: PUSH
102599: LD_INT 17
102601: ST_TO_ADDR
102602: GO 102964
102604: LD_INT 17
102606: DOUBLE
102607: EQUAL
102608: IFTRUE 102612
102610: GO 102640
102612: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102613: LD_ADDR_OWVAR 42
102617: PUSH
102618: LD_INT 19
102620: PUSH
102621: LD_INT 23
102623: PUSH
102624: LD_INT 19
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: LIST
102631: PUSH
102632: LD_VAR 0 1
102636: ARRAY
102637: ST_TO_ADDR
102638: GO 102964
102640: LD_INT 18
102642: DOUBLE
102643: EQUAL
102644: IFTRUE 102648
102646: GO 102659
102648: POP
// bc_type := b_ext_radar ; 19 :
102649: LD_ADDR_OWVAR 42
102653: PUSH
102654: LD_INT 20
102656: ST_TO_ADDR
102657: GO 102964
102659: LD_INT 19
102661: DOUBLE
102662: EQUAL
102663: IFTRUE 102667
102665: GO 102678
102667: POP
// bc_type := b_ext_radio ; 20 :
102668: LD_ADDR_OWVAR 42
102672: PUSH
102673: LD_INT 22
102675: ST_TO_ADDR
102676: GO 102964
102678: LD_INT 20
102680: DOUBLE
102681: EQUAL
102682: IFTRUE 102686
102684: GO 102697
102686: POP
// bc_type := b_ext_siberium ; 21 :
102687: LD_ADDR_OWVAR 42
102691: PUSH
102692: LD_INT 21
102694: ST_TO_ADDR
102695: GO 102964
102697: LD_INT 21
102699: DOUBLE
102700: EQUAL
102701: IFTRUE 102705
102703: GO 102716
102705: POP
// bc_type := b_ext_computer ; 22 :
102706: LD_ADDR_OWVAR 42
102710: PUSH
102711: LD_INT 24
102713: ST_TO_ADDR
102714: GO 102964
102716: LD_INT 22
102718: DOUBLE
102719: EQUAL
102720: IFTRUE 102724
102722: GO 102735
102724: POP
// bc_type := b_ext_track ; 23 :
102725: LD_ADDR_OWVAR 42
102729: PUSH
102730: LD_INT 16
102732: ST_TO_ADDR
102733: GO 102964
102735: LD_INT 23
102737: DOUBLE
102738: EQUAL
102739: IFTRUE 102743
102741: GO 102754
102743: POP
// bc_type := b_ext_laser ; 24 :
102744: LD_ADDR_OWVAR 42
102748: PUSH
102749: LD_INT 25
102751: ST_TO_ADDR
102752: GO 102964
102754: LD_INT 24
102756: DOUBLE
102757: EQUAL
102758: IFTRUE 102762
102760: GO 102773
102762: POP
// bc_type := b_control_tower ; 25 :
102763: LD_ADDR_OWVAR 42
102767: PUSH
102768: LD_INT 36
102770: ST_TO_ADDR
102771: GO 102964
102773: LD_INT 25
102775: DOUBLE
102776: EQUAL
102777: IFTRUE 102781
102779: GO 102792
102781: POP
// bc_type := b_breastwork ; 26 :
102782: LD_ADDR_OWVAR 42
102786: PUSH
102787: LD_INT 31
102789: ST_TO_ADDR
102790: GO 102964
102792: LD_INT 26
102794: DOUBLE
102795: EQUAL
102796: IFTRUE 102800
102798: GO 102811
102800: POP
// bc_type := b_bunker ; 27 :
102801: LD_ADDR_OWVAR 42
102805: PUSH
102806: LD_INT 32
102808: ST_TO_ADDR
102809: GO 102964
102811: LD_INT 27
102813: DOUBLE
102814: EQUAL
102815: IFTRUE 102819
102817: GO 102830
102819: POP
// bc_type := b_turret ; 28 :
102820: LD_ADDR_OWVAR 42
102824: PUSH
102825: LD_INT 33
102827: ST_TO_ADDR
102828: GO 102964
102830: LD_INT 28
102832: DOUBLE
102833: EQUAL
102834: IFTRUE 102838
102836: GO 102849
102838: POP
// bc_type := b_armoury ; 29 :
102839: LD_ADDR_OWVAR 42
102843: PUSH
102844: LD_INT 4
102846: ST_TO_ADDR
102847: GO 102964
102849: LD_INT 29
102851: DOUBLE
102852: EQUAL
102853: IFTRUE 102857
102855: GO 102868
102857: POP
// bc_type := b_barracks ; 30 :
102858: LD_ADDR_OWVAR 42
102862: PUSH
102863: LD_INT 5
102865: ST_TO_ADDR
102866: GO 102964
102868: LD_INT 30
102870: DOUBLE
102871: EQUAL
102872: IFTRUE 102876
102874: GO 102887
102876: POP
// bc_type := b_solar_power ; 31 :
102877: LD_ADDR_OWVAR 42
102881: PUSH
102882: LD_INT 27
102884: ST_TO_ADDR
102885: GO 102964
102887: LD_INT 31
102889: DOUBLE
102890: EQUAL
102891: IFTRUE 102895
102893: GO 102906
102895: POP
// bc_type := b_oil_power ; 32 :
102896: LD_ADDR_OWVAR 42
102900: PUSH
102901: LD_INT 26
102903: ST_TO_ADDR
102904: GO 102964
102906: LD_INT 32
102908: DOUBLE
102909: EQUAL
102910: IFTRUE 102914
102912: GO 102925
102914: POP
// bc_type := b_siberite_power ; 33 :
102915: LD_ADDR_OWVAR 42
102919: PUSH
102920: LD_INT 28
102922: ST_TO_ADDR
102923: GO 102964
102925: LD_INT 33
102927: DOUBLE
102928: EQUAL
102929: IFTRUE 102933
102931: GO 102944
102933: POP
// bc_type := b_oil_mine ; 34 :
102934: LD_ADDR_OWVAR 42
102938: PUSH
102939: LD_INT 29
102941: ST_TO_ADDR
102942: GO 102964
102944: LD_INT 34
102946: DOUBLE
102947: EQUAL
102948: IFTRUE 102952
102950: GO 102963
102952: POP
// bc_type := b_siberite_mine ; end ;
102953: LD_ADDR_OWVAR 42
102957: PUSH
102958: LD_INT 30
102960: ST_TO_ADDR
102961: GO 102964
102963: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102964: LD_ADDR_VAR 0 8
102968: PUSH
102969: LD_VAR 0 5
102973: PPUSH
102974: LD_VAR 0 6
102978: PPUSH
102979: LD_VAR 0 3
102983: PPUSH
102984: CALL_OW 47
102988: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102989: LD_OWVAR 42
102993: PUSH
102994: LD_INT 32
102996: PUSH
102997: LD_INT 33
102999: PUSH
103000: EMPTY
103001: LIST
103002: LIST
103003: IN
103004: IFFALSE 103020
// PlaceWeaponTurret ( b , weapon ) ;
103006: LD_VAR 0 8
103010: PPUSH
103011: LD_VAR 0 4
103015: PPUSH
103016: CALL_OW 431
// end ;
103020: LD_VAR 0 7
103024: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103025: LD_INT 0
103027: PPUSH
103028: PPUSH
103029: PPUSH
103030: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103031: LD_ADDR_VAR 0 4
103035: PUSH
103036: LD_INT 22
103038: PUSH
103039: LD_OWVAR 2
103043: PUSH
103044: EMPTY
103045: LIST
103046: LIST
103047: PUSH
103048: LD_INT 2
103050: PUSH
103051: LD_INT 30
103053: PUSH
103054: LD_INT 0
103056: PUSH
103057: EMPTY
103058: LIST
103059: LIST
103060: PUSH
103061: LD_INT 30
103063: PUSH
103064: LD_INT 1
103066: PUSH
103067: EMPTY
103068: LIST
103069: LIST
103070: PUSH
103071: EMPTY
103072: LIST
103073: LIST
103074: LIST
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: PPUSH
103080: CALL_OW 69
103084: ST_TO_ADDR
// if not tmp then
103085: LD_VAR 0 4
103089: NOT
103090: IFFALSE 103094
// exit ;
103092: GO 103153
// for i in tmp do
103094: LD_ADDR_VAR 0 2
103098: PUSH
103099: LD_VAR 0 4
103103: PUSH
103104: FOR_IN
103105: IFFALSE 103151
// for j = 1 to 3 do
103107: LD_ADDR_VAR 0 3
103111: PUSH
103112: DOUBLE
103113: LD_INT 1
103115: DEC
103116: ST_TO_ADDR
103117: LD_INT 3
103119: PUSH
103120: FOR_TO
103121: IFFALSE 103147
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103123: LD_VAR 0 2
103127: PPUSH
103128: CALL_OW 274
103132: PPUSH
103133: LD_VAR 0 3
103137: PPUSH
103138: LD_INT 99999
103140: PPUSH
103141: CALL_OW 277
103145: GO 103120
103147: POP
103148: POP
103149: GO 103104
103151: POP
103152: POP
// end ;
103153: LD_VAR 0 1
103157: RET
// export function hHackSetLevel10 ; var i , j ; begin
103158: LD_INT 0
103160: PPUSH
103161: PPUSH
103162: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103163: LD_ADDR_VAR 0 2
103167: PUSH
103168: LD_INT 21
103170: PUSH
103171: LD_INT 1
103173: PUSH
103174: EMPTY
103175: LIST
103176: LIST
103177: PPUSH
103178: CALL_OW 69
103182: PUSH
103183: FOR_IN
103184: IFFALSE 103236
// if IsSelected ( i ) then
103186: LD_VAR 0 2
103190: PPUSH
103191: CALL_OW 306
103195: IFFALSE 103234
// begin for j := 1 to 4 do
103197: LD_ADDR_VAR 0 3
103201: PUSH
103202: DOUBLE
103203: LD_INT 1
103205: DEC
103206: ST_TO_ADDR
103207: LD_INT 4
103209: PUSH
103210: FOR_TO
103211: IFFALSE 103232
// SetSkill ( i , j , 10 ) ;
103213: LD_VAR 0 2
103217: PPUSH
103218: LD_VAR 0 3
103222: PPUSH
103223: LD_INT 10
103225: PPUSH
103226: CALL_OW 237
103230: GO 103210
103232: POP
103233: POP
// end ;
103234: GO 103183
103236: POP
103237: POP
// end ;
103238: LD_VAR 0 1
103242: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103243: LD_INT 0
103245: PPUSH
103246: PPUSH
103247: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103248: LD_ADDR_VAR 0 2
103252: PUSH
103253: LD_INT 22
103255: PUSH
103256: LD_OWVAR 2
103260: PUSH
103261: EMPTY
103262: LIST
103263: LIST
103264: PUSH
103265: LD_INT 21
103267: PUSH
103268: LD_INT 1
103270: PUSH
103271: EMPTY
103272: LIST
103273: LIST
103274: PUSH
103275: EMPTY
103276: LIST
103277: LIST
103278: PPUSH
103279: CALL_OW 69
103283: PUSH
103284: FOR_IN
103285: IFFALSE 103326
// begin for j := 1 to 4 do
103287: LD_ADDR_VAR 0 3
103291: PUSH
103292: DOUBLE
103293: LD_INT 1
103295: DEC
103296: ST_TO_ADDR
103297: LD_INT 4
103299: PUSH
103300: FOR_TO
103301: IFFALSE 103322
// SetSkill ( i , j , 10 ) ;
103303: LD_VAR 0 2
103307: PPUSH
103308: LD_VAR 0 3
103312: PPUSH
103313: LD_INT 10
103315: PPUSH
103316: CALL_OW 237
103320: GO 103300
103322: POP
103323: POP
// end ;
103324: GO 103284
103326: POP
103327: POP
// end ;
103328: LD_VAR 0 1
103332: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103333: LD_INT 0
103335: PPUSH
// uc_side := your_side ;
103336: LD_ADDR_OWVAR 20
103340: PUSH
103341: LD_OWVAR 2
103345: ST_TO_ADDR
// uc_nation := nation ;
103346: LD_ADDR_OWVAR 21
103350: PUSH
103351: LD_VAR 0 1
103355: ST_TO_ADDR
// InitHc ;
103356: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103360: LD_INT 0
103362: PPUSH
103363: LD_VAR 0 2
103367: PPUSH
103368: LD_VAR 0 3
103372: PPUSH
103373: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103377: LD_VAR 0 4
103381: PPUSH
103382: LD_VAR 0 5
103386: PPUSH
103387: CALL_OW 428
103391: PUSH
103392: LD_INT 0
103394: EQUAL
103395: IFFALSE 103419
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103397: CALL_OW 44
103401: PPUSH
103402: LD_VAR 0 4
103406: PPUSH
103407: LD_VAR 0 5
103411: PPUSH
103412: LD_INT 1
103414: PPUSH
103415: CALL_OW 48
// end ;
103419: LD_VAR 0 6
103423: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103424: LD_INT 0
103426: PPUSH
103427: PPUSH
// uc_side := your_side ;
103428: LD_ADDR_OWVAR 20
103432: PUSH
103433: LD_OWVAR 2
103437: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103438: LD_VAR 0 1
103442: PUSH
103443: LD_INT 1
103445: PUSH
103446: LD_INT 2
103448: PUSH
103449: LD_INT 3
103451: PUSH
103452: LD_INT 4
103454: PUSH
103455: LD_INT 5
103457: PUSH
103458: EMPTY
103459: LIST
103460: LIST
103461: LIST
103462: LIST
103463: LIST
103464: IN
103465: IFFALSE 103477
// uc_nation := nation_american else
103467: LD_ADDR_OWVAR 21
103471: PUSH
103472: LD_INT 1
103474: ST_TO_ADDR
103475: GO 103520
// if chassis in [ 11 , 12 , 13 , 14 ] then
103477: LD_VAR 0 1
103481: PUSH
103482: LD_INT 11
103484: PUSH
103485: LD_INT 12
103487: PUSH
103488: LD_INT 13
103490: PUSH
103491: LD_INT 14
103493: PUSH
103494: EMPTY
103495: LIST
103496: LIST
103497: LIST
103498: LIST
103499: IN
103500: IFFALSE 103512
// uc_nation := nation_arabian else
103502: LD_ADDR_OWVAR 21
103506: PUSH
103507: LD_INT 2
103509: ST_TO_ADDR
103510: GO 103520
// uc_nation := nation_russian ;
103512: LD_ADDR_OWVAR 21
103516: PUSH
103517: LD_INT 3
103519: ST_TO_ADDR
// vc_chassis := chassis ;
103520: LD_ADDR_OWVAR 37
103524: PUSH
103525: LD_VAR 0 1
103529: ST_TO_ADDR
// vc_engine := engine ;
103530: LD_ADDR_OWVAR 39
103534: PUSH
103535: LD_VAR 0 2
103539: ST_TO_ADDR
// vc_control := control ;
103540: LD_ADDR_OWVAR 38
103544: PUSH
103545: LD_VAR 0 3
103549: ST_TO_ADDR
// vc_weapon := weapon ;
103550: LD_ADDR_OWVAR 40
103554: PUSH
103555: LD_VAR 0 4
103559: ST_TO_ADDR
// un := CreateVehicle ;
103560: LD_ADDR_VAR 0 8
103564: PUSH
103565: CALL_OW 45
103569: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103570: LD_VAR 0 8
103574: PPUSH
103575: LD_INT 0
103577: PPUSH
103578: LD_INT 5
103580: PPUSH
103581: CALL_OW 12
103585: PPUSH
103586: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103590: LD_VAR 0 8
103594: PPUSH
103595: LD_VAR 0 5
103599: PPUSH
103600: LD_VAR 0 6
103604: PPUSH
103605: LD_INT 1
103607: PPUSH
103608: CALL_OW 48
// end ;
103612: LD_VAR 0 7
103616: RET
// export hInvincible ; every 1 do
103617: GO 103619
103619: DISABLE
// hInvincible := [ ] ;
103620: LD_ADDR_EXP 151
103624: PUSH
103625: EMPTY
103626: ST_TO_ADDR
103627: END
// every 10 do var i ;
103628: GO 103630
103630: DISABLE
103631: LD_INT 0
103633: PPUSH
// begin enable ;
103634: ENABLE
// if not hInvincible then
103635: LD_EXP 151
103639: NOT
103640: IFFALSE 103644
// exit ;
103642: GO 103688
// for i in hInvincible do
103644: LD_ADDR_VAR 0 1
103648: PUSH
103649: LD_EXP 151
103653: PUSH
103654: FOR_IN
103655: IFFALSE 103686
// if GetLives ( i ) < 1000 then
103657: LD_VAR 0 1
103661: PPUSH
103662: CALL_OW 256
103666: PUSH
103667: LD_INT 1000
103669: LESS
103670: IFFALSE 103684
// SetLives ( i , 1000 ) ;
103672: LD_VAR 0 1
103676: PPUSH
103677: LD_INT 1000
103679: PPUSH
103680: CALL_OW 234
103684: GO 103654
103686: POP
103687: POP
// end ;
103688: PPOPN 1
103690: END
// export function hHackInvincible ; var i ; begin
103691: LD_INT 0
103693: PPUSH
103694: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103695: LD_ADDR_VAR 0 2
103699: PUSH
103700: LD_INT 2
103702: PUSH
103703: LD_INT 21
103705: PUSH
103706: LD_INT 1
103708: PUSH
103709: EMPTY
103710: LIST
103711: LIST
103712: PUSH
103713: LD_INT 21
103715: PUSH
103716: LD_INT 2
103718: PUSH
103719: EMPTY
103720: LIST
103721: LIST
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: LIST
103727: PPUSH
103728: CALL_OW 69
103732: PUSH
103733: FOR_IN
103734: IFFALSE 103795
// if IsSelected ( i ) then
103736: LD_VAR 0 2
103740: PPUSH
103741: CALL_OW 306
103745: IFFALSE 103793
// begin if i in hInvincible then
103747: LD_VAR 0 2
103751: PUSH
103752: LD_EXP 151
103756: IN
103757: IFFALSE 103777
// hInvincible := hInvincible diff i else
103759: LD_ADDR_EXP 151
103763: PUSH
103764: LD_EXP 151
103768: PUSH
103769: LD_VAR 0 2
103773: DIFF
103774: ST_TO_ADDR
103775: GO 103793
// hInvincible := hInvincible union i ;
103777: LD_ADDR_EXP 151
103781: PUSH
103782: LD_EXP 151
103786: PUSH
103787: LD_VAR 0 2
103791: UNION
103792: ST_TO_ADDR
// end ;
103793: GO 103733
103795: POP
103796: POP
// end ;
103797: LD_VAR 0 1
103801: RET
// export function hHackInvisible ; var i , j ; begin
103802: LD_INT 0
103804: PPUSH
103805: PPUSH
103806: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103807: LD_ADDR_VAR 0 2
103811: PUSH
103812: LD_INT 21
103814: PUSH
103815: LD_INT 1
103817: PUSH
103818: EMPTY
103819: LIST
103820: LIST
103821: PPUSH
103822: CALL_OW 69
103826: PUSH
103827: FOR_IN
103828: IFFALSE 103852
// if IsSelected ( i ) then
103830: LD_VAR 0 2
103834: PPUSH
103835: CALL_OW 306
103839: IFFALSE 103850
// ComForceInvisible ( i ) ;
103841: LD_VAR 0 2
103845: PPUSH
103846: CALL_OW 496
103850: GO 103827
103852: POP
103853: POP
// end ;
103854: LD_VAR 0 1
103858: RET
// export function hHackChangeYourSide ; begin
103859: LD_INT 0
103861: PPUSH
// if your_side = 8 then
103862: LD_OWVAR 2
103866: PUSH
103867: LD_INT 8
103869: EQUAL
103870: IFFALSE 103882
// your_side := 0 else
103872: LD_ADDR_OWVAR 2
103876: PUSH
103877: LD_INT 0
103879: ST_TO_ADDR
103880: GO 103896
// your_side := your_side + 1 ;
103882: LD_ADDR_OWVAR 2
103886: PUSH
103887: LD_OWVAR 2
103891: PUSH
103892: LD_INT 1
103894: PLUS
103895: ST_TO_ADDR
// end ;
103896: LD_VAR 0 1
103900: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103901: LD_INT 0
103903: PPUSH
103904: PPUSH
103905: PPUSH
// for i in all_units do
103906: LD_ADDR_VAR 0 2
103910: PUSH
103911: LD_OWVAR 3
103915: PUSH
103916: FOR_IN
103917: IFFALSE 103995
// if IsSelected ( i ) then
103919: LD_VAR 0 2
103923: PPUSH
103924: CALL_OW 306
103928: IFFALSE 103993
// begin j := GetSide ( i ) ;
103930: LD_ADDR_VAR 0 3
103934: PUSH
103935: LD_VAR 0 2
103939: PPUSH
103940: CALL_OW 255
103944: ST_TO_ADDR
// if j = 8 then
103945: LD_VAR 0 3
103949: PUSH
103950: LD_INT 8
103952: EQUAL
103953: IFFALSE 103965
// j := 0 else
103955: LD_ADDR_VAR 0 3
103959: PUSH
103960: LD_INT 0
103962: ST_TO_ADDR
103963: GO 103979
// j := j + 1 ;
103965: LD_ADDR_VAR 0 3
103969: PUSH
103970: LD_VAR 0 3
103974: PUSH
103975: LD_INT 1
103977: PLUS
103978: ST_TO_ADDR
// SetSide ( i , j ) ;
103979: LD_VAR 0 2
103983: PPUSH
103984: LD_VAR 0 3
103988: PPUSH
103989: CALL_OW 235
// end ;
103993: GO 103916
103995: POP
103996: POP
// end ;
103997: LD_VAR 0 1
104001: RET
// export function hHackFog ; begin
104002: LD_INT 0
104004: PPUSH
// FogOff ( true ) ;
104005: LD_INT 1
104007: PPUSH
104008: CALL_OW 344
// end ;
104012: LD_VAR 0 1
104016: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104017: LD_INT 0
104019: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104020: LD_VAR 0 1
104024: PPUSH
104025: LD_VAR 0 2
104029: PPUSH
104030: LD_VAR 0 3
104034: PPUSH
104035: LD_INT 1
104037: PPUSH
104038: LD_INT 1
104040: PPUSH
104041: CALL_OW 483
// CenterOnXY ( x , y ) ;
104045: LD_VAR 0 2
104049: PPUSH
104050: LD_VAR 0 3
104054: PPUSH
104055: CALL_OW 84
// end ;
104059: LD_VAR 0 4
104063: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104064: LD_INT 0
104066: PPUSH
104067: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104068: LD_VAR 0 1
104072: NOT
104073: PUSH
104074: LD_VAR 0 2
104078: PPUSH
104079: LD_VAR 0 3
104083: PPUSH
104084: CALL_OW 488
104088: NOT
104089: OR
104090: PUSH
104091: LD_VAR 0 1
104095: PPUSH
104096: CALL_OW 266
104100: PUSH
104101: LD_INT 3
104103: NONEQUAL
104104: PUSH
104105: LD_VAR 0 1
104109: PPUSH
104110: CALL_OW 247
104114: PUSH
104115: LD_INT 1
104117: EQUAL
104118: NOT
104119: AND
104120: OR
104121: IFFALSE 104125
// exit ;
104123: GO 104274
// if GetType ( factory ) = unit_human then
104125: LD_VAR 0 1
104129: PPUSH
104130: CALL_OW 247
104134: PUSH
104135: LD_INT 1
104137: EQUAL
104138: IFFALSE 104155
// factory := IsInUnit ( factory ) ;
104140: LD_ADDR_VAR 0 1
104144: PUSH
104145: LD_VAR 0 1
104149: PPUSH
104150: CALL_OW 310
104154: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104155: LD_VAR 0 1
104159: PPUSH
104160: CALL_OW 266
104164: PUSH
104165: LD_INT 3
104167: NONEQUAL
104168: IFFALSE 104172
// exit ;
104170: GO 104274
// if HexInfo ( x , y ) = factory then
104172: LD_VAR 0 2
104176: PPUSH
104177: LD_VAR 0 3
104181: PPUSH
104182: CALL_OW 428
104186: PUSH
104187: LD_VAR 0 1
104191: EQUAL
104192: IFFALSE 104219
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104194: LD_ADDR_EXP 152
104198: PUSH
104199: LD_EXP 152
104203: PPUSH
104204: LD_VAR 0 1
104208: PPUSH
104209: LD_INT 0
104211: PPUSH
104212: CALL_OW 1
104216: ST_TO_ADDR
104217: GO 104270
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104219: LD_ADDR_EXP 152
104223: PUSH
104224: LD_EXP 152
104228: PPUSH
104229: LD_VAR 0 1
104233: PPUSH
104234: LD_VAR 0 1
104238: PPUSH
104239: CALL_OW 255
104243: PUSH
104244: LD_VAR 0 1
104248: PUSH
104249: LD_VAR 0 2
104253: PUSH
104254: LD_VAR 0 3
104258: PUSH
104259: EMPTY
104260: LIST
104261: LIST
104262: LIST
104263: LIST
104264: PPUSH
104265: CALL_OW 1
104269: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104270: CALL 104279 0 0
// end ;
104274: LD_VAR 0 4
104278: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104279: LD_INT 0
104281: PPUSH
104282: PPUSH
104283: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104284: LD_STRING resetFactoryWaypoint();
104286: PPUSH
104287: CALL_OW 559
// if factoryWaypoints then
104291: LD_EXP 152
104295: IFFALSE 104421
// begin list := PrepareArray ( factoryWaypoints ) ;
104297: LD_ADDR_VAR 0 3
104301: PUSH
104302: LD_EXP 152
104306: PPUSH
104307: CALL 89675 0 1
104311: ST_TO_ADDR
// for i := 1 to list do
104312: LD_ADDR_VAR 0 2
104316: PUSH
104317: DOUBLE
104318: LD_INT 1
104320: DEC
104321: ST_TO_ADDR
104322: LD_VAR 0 3
104326: PUSH
104327: FOR_TO
104328: IFFALSE 104419
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104330: LD_STRING setFactoryWaypointXY(
104332: PUSH
104333: LD_VAR 0 3
104337: PUSH
104338: LD_VAR 0 2
104342: ARRAY
104343: PUSH
104344: LD_INT 1
104346: ARRAY
104347: STR
104348: PUSH
104349: LD_STRING ,
104351: STR
104352: PUSH
104353: LD_VAR 0 3
104357: PUSH
104358: LD_VAR 0 2
104362: ARRAY
104363: PUSH
104364: LD_INT 2
104366: ARRAY
104367: STR
104368: PUSH
104369: LD_STRING ,
104371: STR
104372: PUSH
104373: LD_VAR 0 3
104377: PUSH
104378: LD_VAR 0 2
104382: ARRAY
104383: PUSH
104384: LD_INT 3
104386: ARRAY
104387: STR
104388: PUSH
104389: LD_STRING ,
104391: STR
104392: PUSH
104393: LD_VAR 0 3
104397: PUSH
104398: LD_VAR 0 2
104402: ARRAY
104403: PUSH
104404: LD_INT 4
104406: ARRAY
104407: STR
104408: PUSH
104409: LD_STRING )
104411: STR
104412: PPUSH
104413: CALL_OW 559
104417: GO 104327
104419: POP
104420: POP
// end ; end ;
104421: LD_VAR 0 1
104425: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104426: LD_INT 0
104428: PPUSH
// if HexInfo ( x , y ) = warehouse then
104429: LD_VAR 0 2
104433: PPUSH
104434: LD_VAR 0 3
104438: PPUSH
104439: CALL_OW 428
104443: PUSH
104444: LD_VAR 0 1
104448: EQUAL
104449: IFFALSE 104476
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104451: LD_ADDR_EXP 153
104455: PUSH
104456: LD_EXP 153
104460: PPUSH
104461: LD_VAR 0 1
104465: PPUSH
104466: LD_INT 0
104468: PPUSH
104469: CALL_OW 1
104473: ST_TO_ADDR
104474: GO 104527
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104476: LD_ADDR_EXP 153
104480: PUSH
104481: LD_EXP 153
104485: PPUSH
104486: LD_VAR 0 1
104490: PPUSH
104491: LD_VAR 0 1
104495: PPUSH
104496: CALL_OW 255
104500: PUSH
104501: LD_VAR 0 1
104505: PUSH
104506: LD_VAR 0 2
104510: PUSH
104511: LD_VAR 0 3
104515: PUSH
104516: EMPTY
104517: LIST
104518: LIST
104519: LIST
104520: LIST
104521: PPUSH
104522: CALL_OW 1
104526: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104527: CALL 104536 0 0
// end ;
104531: LD_VAR 0 4
104535: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104536: LD_INT 0
104538: PPUSH
104539: PPUSH
104540: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104541: LD_STRING resetWarehouseGatheringPoints();
104543: PPUSH
104544: CALL_OW 559
// if warehouseGatheringPoints then
104548: LD_EXP 153
104552: IFFALSE 104678
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104554: LD_ADDR_VAR 0 3
104558: PUSH
104559: LD_EXP 153
104563: PPUSH
104564: CALL 89675 0 1
104568: ST_TO_ADDR
// for i := 1 to list do
104569: LD_ADDR_VAR 0 2
104573: PUSH
104574: DOUBLE
104575: LD_INT 1
104577: DEC
104578: ST_TO_ADDR
104579: LD_VAR 0 3
104583: PUSH
104584: FOR_TO
104585: IFFALSE 104676
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104587: LD_STRING setWarehouseGatheringPointXY(
104589: PUSH
104590: LD_VAR 0 3
104594: PUSH
104595: LD_VAR 0 2
104599: ARRAY
104600: PUSH
104601: LD_INT 1
104603: ARRAY
104604: STR
104605: PUSH
104606: LD_STRING ,
104608: STR
104609: PUSH
104610: LD_VAR 0 3
104614: PUSH
104615: LD_VAR 0 2
104619: ARRAY
104620: PUSH
104621: LD_INT 2
104623: ARRAY
104624: STR
104625: PUSH
104626: LD_STRING ,
104628: STR
104629: PUSH
104630: LD_VAR 0 3
104634: PUSH
104635: LD_VAR 0 2
104639: ARRAY
104640: PUSH
104641: LD_INT 3
104643: ARRAY
104644: STR
104645: PUSH
104646: LD_STRING ,
104648: STR
104649: PUSH
104650: LD_VAR 0 3
104654: PUSH
104655: LD_VAR 0 2
104659: ARRAY
104660: PUSH
104661: LD_INT 4
104663: ARRAY
104664: STR
104665: PUSH
104666: LD_STRING )
104668: STR
104669: PPUSH
104670: CALL_OW 559
104674: GO 104584
104676: POP
104677: POP
// end ; end ;
104678: LD_VAR 0 1
104682: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
104683: LD_EXP 153
104687: IFFALSE 105372
104689: GO 104691
104691: DISABLE
104692: LD_INT 0
104694: PPUSH
104695: PPUSH
104696: PPUSH
104697: PPUSH
104698: PPUSH
104699: PPUSH
104700: PPUSH
104701: PPUSH
104702: PPUSH
// begin enable ;
104703: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
104704: LD_ADDR_VAR 0 3
104708: PUSH
104709: LD_EXP 153
104713: PPUSH
104714: CALL 89675 0 1
104718: ST_TO_ADDR
// if not list then
104719: LD_VAR 0 3
104723: NOT
104724: IFFALSE 104728
// exit ;
104726: GO 105372
// for i := 1 to list do
104728: LD_ADDR_VAR 0 1
104732: PUSH
104733: DOUBLE
104734: LD_INT 1
104736: DEC
104737: ST_TO_ADDR
104738: LD_VAR 0 3
104742: PUSH
104743: FOR_TO
104744: IFFALSE 105370
// begin depot := list [ i ] [ 2 ] ;
104746: LD_ADDR_VAR 0 8
104750: PUSH
104751: LD_VAR 0 3
104755: PUSH
104756: LD_VAR 0 1
104760: ARRAY
104761: PUSH
104762: LD_INT 2
104764: ARRAY
104765: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
104766: LD_ADDR_VAR 0 5
104770: PUSH
104771: LD_VAR 0 3
104775: PUSH
104776: LD_VAR 0 1
104780: ARRAY
104781: PUSH
104782: LD_INT 1
104784: ARRAY
104785: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
104786: LD_VAR 0 8
104790: PPUSH
104791: CALL_OW 301
104795: PUSH
104796: LD_VAR 0 5
104800: PUSH
104801: LD_VAR 0 8
104805: PPUSH
104806: CALL_OW 255
104810: NONEQUAL
104811: OR
104812: IFFALSE 104841
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
104814: LD_ADDR_EXP 153
104818: PUSH
104819: LD_EXP 153
104823: PPUSH
104824: LD_VAR 0 8
104828: PPUSH
104829: LD_INT 0
104831: PPUSH
104832: CALL_OW 1
104836: ST_TO_ADDR
// exit ;
104837: POP
104838: POP
104839: GO 105372
// end ; x := list [ i ] [ 3 ] ;
104841: LD_ADDR_VAR 0 6
104845: PUSH
104846: LD_VAR 0 3
104850: PUSH
104851: LD_VAR 0 1
104855: ARRAY
104856: PUSH
104857: LD_INT 3
104859: ARRAY
104860: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
104861: LD_ADDR_VAR 0 7
104865: PUSH
104866: LD_VAR 0 3
104870: PUSH
104871: LD_VAR 0 1
104875: ARRAY
104876: PUSH
104877: LD_INT 4
104879: ARRAY
104880: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
104881: LD_ADDR_VAR 0 9
104885: PUSH
104886: LD_VAR 0 6
104890: PPUSH
104891: LD_VAR 0 7
104895: PPUSH
104896: LD_INT 16
104898: PPUSH
104899: CALL 88263 0 3
104903: ST_TO_ADDR
// if not cratesNearbyPoint then
104904: LD_VAR 0 9
104908: NOT
104909: IFFALSE 104915
// exit ;
104911: POP
104912: POP
104913: GO 105372
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
104915: LD_ADDR_VAR 0 4
104919: PUSH
104920: LD_INT 22
104922: PUSH
104923: LD_VAR 0 5
104927: PUSH
104928: EMPTY
104929: LIST
104930: LIST
104931: PUSH
104932: LD_INT 3
104934: PUSH
104935: LD_INT 60
104937: PUSH
104938: EMPTY
104939: LIST
104940: PUSH
104941: EMPTY
104942: LIST
104943: LIST
104944: PUSH
104945: LD_INT 91
104947: PUSH
104948: LD_VAR 0 8
104952: PUSH
104953: LD_INT 6
104955: PUSH
104956: EMPTY
104957: LIST
104958: LIST
104959: LIST
104960: PUSH
104961: LD_INT 2
104963: PUSH
104964: LD_INT 25
104966: PUSH
104967: LD_INT 2
104969: PUSH
104970: EMPTY
104971: LIST
104972: LIST
104973: PUSH
104974: LD_INT 25
104976: PUSH
104977: LD_INT 16
104979: PUSH
104980: EMPTY
104981: LIST
104982: LIST
104983: PUSH
104984: EMPTY
104985: LIST
104986: LIST
104987: LIST
104988: PUSH
104989: EMPTY
104990: LIST
104991: LIST
104992: LIST
104993: LIST
104994: PPUSH
104995: CALL_OW 69
104999: PUSH
105000: LD_VAR 0 8
105004: PPUSH
105005: CALL_OW 313
105009: PPUSH
105010: LD_INT 3
105012: PUSH
105013: LD_INT 60
105015: PUSH
105016: EMPTY
105017: LIST
105018: PUSH
105019: EMPTY
105020: LIST
105021: LIST
105022: PUSH
105023: LD_INT 2
105025: PUSH
105026: LD_INT 25
105028: PUSH
105029: LD_INT 2
105031: PUSH
105032: EMPTY
105033: LIST
105034: LIST
105035: PUSH
105036: LD_INT 25
105038: PUSH
105039: LD_INT 16
105041: PUSH
105042: EMPTY
105043: LIST
105044: LIST
105045: PUSH
105046: EMPTY
105047: LIST
105048: LIST
105049: LIST
105050: PUSH
105051: EMPTY
105052: LIST
105053: LIST
105054: PPUSH
105055: CALL_OW 72
105059: UNION
105060: ST_TO_ADDR
// if tmp then
105061: LD_VAR 0 4
105065: IFFALSE 105145
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105067: LD_ADDR_VAR 0 4
105071: PUSH
105072: LD_VAR 0 4
105076: PPUSH
105077: LD_INT 3
105079: PPUSH
105080: CALL 86232 0 2
105084: ST_TO_ADDR
// for j in tmp do
105085: LD_ADDR_VAR 0 2
105089: PUSH
105090: LD_VAR 0 4
105094: PUSH
105095: FOR_IN
105096: IFFALSE 105139
// begin if IsInUnit ( j ) then
105098: LD_VAR 0 2
105102: PPUSH
105103: CALL_OW 310
105107: IFFALSE 105118
// ComExit ( j ) ;
105109: LD_VAR 0 2
105113: PPUSH
105114: CALL 86315 0 1
// AddComCollect ( j , x , y ) ;
105118: LD_VAR 0 2
105122: PPUSH
105123: LD_VAR 0 6
105127: PPUSH
105128: LD_VAR 0 7
105132: PPUSH
105133: CALL_OW 177
// end ;
105137: GO 105095
105139: POP
105140: POP
// exit ;
105141: POP
105142: POP
105143: GO 105372
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105145: LD_ADDR_VAR 0 4
105149: PUSH
105150: LD_INT 22
105152: PUSH
105153: LD_VAR 0 5
105157: PUSH
105158: EMPTY
105159: LIST
105160: LIST
105161: PUSH
105162: LD_INT 91
105164: PUSH
105165: LD_VAR 0 8
105169: PUSH
105170: LD_INT 8
105172: PUSH
105173: EMPTY
105174: LIST
105175: LIST
105176: LIST
105177: PUSH
105178: LD_INT 2
105180: PUSH
105181: LD_INT 34
105183: PUSH
105184: LD_INT 12
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: PUSH
105191: LD_INT 34
105193: PUSH
105194: LD_INT 51
105196: PUSH
105197: EMPTY
105198: LIST
105199: LIST
105200: PUSH
105201: LD_INT 34
105203: PUSH
105204: LD_INT 32
105206: PUSH
105207: EMPTY
105208: LIST
105209: LIST
105210: PUSH
105211: LD_INT 34
105213: PUSH
105214: LD_INT 89
105216: PUSH
105217: EMPTY
105218: LIST
105219: LIST
105220: PUSH
105221: EMPTY
105222: LIST
105223: LIST
105224: LIST
105225: LIST
105226: LIST
105227: PUSH
105228: EMPTY
105229: LIST
105230: LIST
105231: LIST
105232: PPUSH
105233: CALL_OW 69
105237: ST_TO_ADDR
// if tmp then
105238: LD_VAR 0 4
105242: IFFALSE 105368
// begin for j in tmp do
105244: LD_ADDR_VAR 0 2
105248: PUSH
105249: LD_VAR 0 4
105253: PUSH
105254: FOR_IN
105255: IFFALSE 105366
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105257: LD_VAR 0 2
105261: PPUSH
105262: CALL_OW 262
105266: PUSH
105267: LD_INT 3
105269: EQUAL
105270: PUSH
105271: LD_VAR 0 2
105275: PPUSH
105276: CALL_OW 261
105280: PUSH
105281: LD_INT 20
105283: GREATER
105284: OR
105285: PUSH
105286: LD_VAR 0 2
105290: PPUSH
105291: CALL_OW 314
105295: NOT
105296: AND
105297: PUSH
105298: LD_VAR 0 2
105302: PPUSH
105303: CALL_OW 263
105307: PUSH
105308: LD_INT 1
105310: NONEQUAL
105311: PUSH
105312: LD_VAR 0 2
105316: PPUSH
105317: CALL_OW 311
105321: OR
105322: AND
105323: IFFALSE 105364
// begin ComCollect ( j , x , y ) ;
105325: LD_VAR 0 2
105329: PPUSH
105330: LD_VAR 0 6
105334: PPUSH
105335: LD_VAR 0 7
105339: PPUSH
105340: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105344: LD_VAR 0 2
105348: PPUSH
105349: LD_VAR 0 8
105353: PPUSH
105354: CALL_OW 172
// exit ;
105358: POP
105359: POP
105360: POP
105361: POP
105362: GO 105372
// end ;
105364: GO 105254
105366: POP
105367: POP
// end ; end ;
105368: GO 104743
105370: POP
105371: POP
// end ; end_of_file
105372: PPOPN 9
105374: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105375: LD_INT 0
105377: PPUSH
105378: PPUSH
105379: PPUSH
105380: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105381: LD_VAR 0 1
105385: PPUSH
105386: CALL_OW 264
105390: PUSH
105391: LD_INT 91
105393: EQUAL
105394: IFFALSE 105466
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105396: LD_INT 68
105398: PPUSH
105399: LD_VAR 0 1
105403: PPUSH
105404: CALL_OW 255
105408: PPUSH
105409: CALL_OW 321
105413: PUSH
105414: LD_INT 2
105416: EQUAL
105417: IFFALSE 105429
// eff := 70 else
105419: LD_ADDR_VAR 0 4
105423: PUSH
105424: LD_INT 70
105426: ST_TO_ADDR
105427: GO 105437
// eff := 30 ;
105429: LD_ADDR_VAR 0 4
105433: PUSH
105434: LD_INT 30
105436: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105437: LD_VAR 0 1
105441: PPUSH
105442: CALL_OW 250
105446: PPUSH
105447: LD_VAR 0 1
105451: PPUSH
105452: CALL_OW 251
105456: PPUSH
105457: LD_VAR 0 4
105461: PPUSH
105462: CALL_OW 495
// end ; end ;
105466: LD_VAR 0 2
105470: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105471: LD_INT 0
105473: PPUSH
// end ;
105474: LD_VAR 0 4
105478: RET
// export function SOS_Command ( cmd ) ; begin
105479: LD_INT 0
105481: PPUSH
// end ;
105482: LD_VAR 0 2
105486: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105487: LD_INT 0
105489: PPUSH
// end ;
105490: LD_VAR 0 6
105494: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105495: LD_INT 0
105497: PPUSH
105498: PPUSH
// if not vehicle or not factory then
105499: LD_VAR 0 1
105503: NOT
105504: PUSH
105505: LD_VAR 0 2
105509: NOT
105510: OR
105511: IFFALSE 105515
// exit ;
105513: GO 105746
// if factoryWaypoints >= factory then
105515: LD_EXP 152
105519: PUSH
105520: LD_VAR 0 2
105524: GREATEREQUAL
105525: IFFALSE 105746
// if factoryWaypoints [ factory ] then
105527: LD_EXP 152
105531: PUSH
105532: LD_VAR 0 2
105536: ARRAY
105537: IFFALSE 105746
// begin if GetControl ( vehicle ) = control_manual then
105539: LD_VAR 0 1
105543: PPUSH
105544: CALL_OW 263
105548: PUSH
105549: LD_INT 1
105551: EQUAL
105552: IFFALSE 105633
// begin driver := IsDrivenBy ( vehicle ) ;
105554: LD_ADDR_VAR 0 4
105558: PUSH
105559: LD_VAR 0 1
105563: PPUSH
105564: CALL_OW 311
105568: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105569: LD_VAR 0 4
105573: PPUSH
105574: LD_EXP 152
105578: PUSH
105579: LD_VAR 0 2
105583: ARRAY
105584: PUSH
105585: LD_INT 3
105587: ARRAY
105588: PPUSH
105589: LD_EXP 152
105593: PUSH
105594: LD_VAR 0 2
105598: ARRAY
105599: PUSH
105600: LD_INT 4
105602: ARRAY
105603: PPUSH
105604: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105608: LD_VAR 0 4
105612: PPUSH
105613: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105617: LD_VAR 0 4
105621: PPUSH
105622: LD_VAR 0 2
105626: PPUSH
105627: CALL_OW 180
// end else
105631: GO 105746
// if GetControl ( vehicle ) = control_remote then
105633: LD_VAR 0 1
105637: PPUSH
105638: CALL_OW 263
105642: PUSH
105643: LD_INT 2
105645: EQUAL
105646: IFFALSE 105707
// begin wait ( 0 0$2 ) ;
105648: LD_INT 70
105650: PPUSH
105651: CALL_OW 67
// if Connect ( vehicle ) then
105655: LD_VAR 0 1
105659: PPUSH
105660: CALL 56647 0 1
105664: IFFALSE 105705
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105666: LD_VAR 0 1
105670: PPUSH
105671: LD_EXP 152
105675: PUSH
105676: LD_VAR 0 2
105680: ARRAY
105681: PUSH
105682: LD_INT 3
105684: ARRAY
105685: PPUSH
105686: LD_EXP 152
105690: PUSH
105691: LD_VAR 0 2
105695: ARRAY
105696: PUSH
105697: LD_INT 4
105699: ARRAY
105700: PPUSH
105701: CALL_OW 171
// end else
105705: GO 105746
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105707: LD_VAR 0 1
105711: PPUSH
105712: LD_EXP 152
105716: PUSH
105717: LD_VAR 0 2
105721: ARRAY
105722: PUSH
105723: LD_INT 3
105725: ARRAY
105726: PPUSH
105727: LD_EXP 152
105731: PUSH
105732: LD_VAR 0 2
105736: ARRAY
105737: PUSH
105738: LD_INT 4
105740: ARRAY
105741: PPUSH
105742: CALL_OW 171
// end ; end ;
105746: LD_VAR 0 3
105750: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105751: LD_INT 0
105753: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105754: LD_VAR 0 1
105758: PUSH
105759: LD_INT 250
105761: EQUAL
105762: PUSH
105763: LD_VAR 0 2
105767: PPUSH
105768: CALL_OW 264
105772: PUSH
105773: LD_INT 81
105775: EQUAL
105776: AND
105777: IFFALSE 105798
// MinerPlaceMine ( unit , x , y ) ;
105779: LD_VAR 0 2
105783: PPUSH
105784: LD_VAR 0 4
105788: PPUSH
105789: LD_VAR 0 5
105793: PPUSH
105794: CALL 108183 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
105798: LD_VAR 0 1
105802: PUSH
105803: LD_INT 251
105805: EQUAL
105806: PUSH
105807: LD_VAR 0 2
105811: PPUSH
105812: CALL_OW 264
105816: PUSH
105817: LD_INT 81
105819: EQUAL
105820: AND
105821: IFFALSE 105842
// MinerDetonateMine ( unit , x , y ) ;
105823: LD_VAR 0 2
105827: PPUSH
105828: LD_VAR 0 4
105832: PPUSH
105833: LD_VAR 0 5
105837: PPUSH
105838: CALL 108458 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
105842: LD_VAR 0 1
105846: PUSH
105847: LD_INT 252
105849: EQUAL
105850: PUSH
105851: LD_VAR 0 2
105855: PPUSH
105856: CALL_OW 264
105860: PUSH
105861: LD_INT 81
105863: EQUAL
105864: AND
105865: IFFALSE 105886
// MinerCreateMinefield ( unit , x , y ) ;
105867: LD_VAR 0 2
105871: PPUSH
105872: LD_VAR 0 4
105876: PPUSH
105877: LD_VAR 0 5
105881: PPUSH
105882: CALL 108875 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
105886: LD_VAR 0 1
105890: PUSH
105891: LD_INT 253
105893: EQUAL
105894: PUSH
105895: LD_VAR 0 2
105899: PPUSH
105900: CALL_OW 257
105904: PUSH
105905: LD_INT 5
105907: EQUAL
105908: AND
105909: IFFALSE 105930
// ComBinocular ( unit , x , y ) ;
105911: LD_VAR 0 2
105915: PPUSH
105916: LD_VAR 0 4
105920: PPUSH
105921: LD_VAR 0 5
105925: PPUSH
105926: CALL 109244 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
105930: LD_VAR 0 1
105934: PUSH
105935: LD_INT 254
105937: EQUAL
105938: PUSH
105939: LD_VAR 0 2
105943: PPUSH
105944: CALL_OW 264
105948: PUSH
105949: LD_INT 99
105951: EQUAL
105952: AND
105953: PUSH
105954: LD_VAR 0 3
105958: PPUSH
105959: CALL_OW 263
105963: PUSH
105964: LD_INT 3
105966: EQUAL
105967: AND
105968: IFFALSE 105984
// HackDestroyVehicle ( unit , selectedUnit ) ;
105970: LD_VAR 0 2
105974: PPUSH
105975: LD_VAR 0 3
105979: PPUSH
105980: CALL 107547 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
105984: LD_VAR 0 1
105988: PUSH
105989: LD_INT 255
105991: EQUAL
105992: PUSH
105993: LD_VAR 0 2
105997: PPUSH
105998: CALL_OW 264
106002: PUSH
106003: LD_INT 14
106005: PUSH
106006: LD_INT 53
106008: PUSH
106009: EMPTY
106010: LIST
106011: LIST
106012: IN
106013: AND
106014: PUSH
106015: LD_VAR 0 4
106019: PPUSH
106020: LD_VAR 0 5
106024: PPUSH
106025: CALL_OW 488
106029: AND
106030: IFFALSE 106054
// CutTreeXYR ( unit , x , y , 12 ) ;
106032: LD_VAR 0 2
106036: PPUSH
106037: LD_VAR 0 4
106041: PPUSH
106042: LD_VAR 0 5
106046: PPUSH
106047: LD_INT 12
106049: PPUSH
106050: CALL 106117 0 4
// if cmd = 256 then
106054: LD_VAR 0 1
106058: PUSH
106059: LD_INT 256
106061: EQUAL
106062: IFFALSE 106083
// SetFactoryWaypoint ( unit , x , y ) ;
106064: LD_VAR 0 2
106068: PPUSH
106069: LD_VAR 0 4
106073: PPUSH
106074: LD_VAR 0 5
106078: PPUSH
106079: CALL 104064 0 3
// if cmd = 257 then
106083: LD_VAR 0 1
106087: PUSH
106088: LD_INT 257
106090: EQUAL
106091: IFFALSE 106112
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106093: LD_VAR 0 2
106097: PPUSH
106098: LD_VAR 0 4
106102: PPUSH
106103: LD_VAR 0 5
106107: PPUSH
106108: CALL 104426 0 3
// end ;
106112: LD_VAR 0 6
106116: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106117: LD_INT 0
106119: PPUSH
106120: PPUSH
106121: PPUSH
106122: PPUSH
106123: PPUSH
106124: PPUSH
106125: PPUSH
106126: PPUSH
106127: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106128: LD_VAR 0 1
106132: NOT
106133: PUSH
106134: LD_VAR 0 2
106138: PPUSH
106139: LD_VAR 0 3
106143: PPUSH
106144: CALL_OW 488
106148: NOT
106149: OR
106150: PUSH
106151: LD_VAR 0 4
106155: NOT
106156: OR
106157: IFFALSE 106161
// exit ;
106159: GO 106501
// list := [ ] ;
106161: LD_ADDR_VAR 0 13
106165: PUSH
106166: EMPTY
106167: ST_TO_ADDR
// if x - r < 0 then
106168: LD_VAR 0 2
106172: PUSH
106173: LD_VAR 0 4
106177: MINUS
106178: PUSH
106179: LD_INT 0
106181: LESS
106182: IFFALSE 106194
// min_x := 0 else
106184: LD_ADDR_VAR 0 7
106188: PUSH
106189: LD_INT 0
106191: ST_TO_ADDR
106192: GO 106210
// min_x := x - r ;
106194: LD_ADDR_VAR 0 7
106198: PUSH
106199: LD_VAR 0 2
106203: PUSH
106204: LD_VAR 0 4
106208: MINUS
106209: ST_TO_ADDR
// if y - r < 0 then
106210: LD_VAR 0 3
106214: PUSH
106215: LD_VAR 0 4
106219: MINUS
106220: PUSH
106221: LD_INT 0
106223: LESS
106224: IFFALSE 106236
// min_y := 0 else
106226: LD_ADDR_VAR 0 8
106230: PUSH
106231: LD_INT 0
106233: ST_TO_ADDR
106234: GO 106252
// min_y := y - r ;
106236: LD_ADDR_VAR 0 8
106240: PUSH
106241: LD_VAR 0 3
106245: PUSH
106246: LD_VAR 0 4
106250: MINUS
106251: ST_TO_ADDR
// max_x := x + r ;
106252: LD_ADDR_VAR 0 9
106256: PUSH
106257: LD_VAR 0 2
106261: PUSH
106262: LD_VAR 0 4
106266: PLUS
106267: ST_TO_ADDR
// max_y := y + r ;
106268: LD_ADDR_VAR 0 10
106272: PUSH
106273: LD_VAR 0 3
106277: PUSH
106278: LD_VAR 0 4
106282: PLUS
106283: ST_TO_ADDR
// for _x = min_x to max_x do
106284: LD_ADDR_VAR 0 11
106288: PUSH
106289: DOUBLE
106290: LD_VAR 0 7
106294: DEC
106295: ST_TO_ADDR
106296: LD_VAR 0 9
106300: PUSH
106301: FOR_TO
106302: IFFALSE 106419
// for _y = min_y to max_y do
106304: LD_ADDR_VAR 0 12
106308: PUSH
106309: DOUBLE
106310: LD_VAR 0 8
106314: DEC
106315: ST_TO_ADDR
106316: LD_VAR 0 10
106320: PUSH
106321: FOR_TO
106322: IFFALSE 106415
// begin if not ValidHex ( _x , _y ) then
106324: LD_VAR 0 11
106328: PPUSH
106329: LD_VAR 0 12
106333: PPUSH
106334: CALL_OW 488
106338: NOT
106339: IFFALSE 106343
// continue ;
106341: GO 106321
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106343: LD_VAR 0 11
106347: PPUSH
106348: LD_VAR 0 12
106352: PPUSH
106353: CALL_OW 351
106357: PUSH
106358: LD_VAR 0 11
106362: PPUSH
106363: LD_VAR 0 12
106367: PPUSH
106368: CALL_OW 554
106372: AND
106373: IFFALSE 106413
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106375: LD_ADDR_VAR 0 13
106379: PUSH
106380: LD_VAR 0 13
106384: PPUSH
106385: LD_VAR 0 13
106389: PUSH
106390: LD_INT 1
106392: PLUS
106393: PPUSH
106394: LD_VAR 0 11
106398: PUSH
106399: LD_VAR 0 12
106403: PUSH
106404: EMPTY
106405: LIST
106406: LIST
106407: PPUSH
106408: CALL_OW 2
106412: ST_TO_ADDR
// end ;
106413: GO 106321
106415: POP
106416: POP
106417: GO 106301
106419: POP
106420: POP
// if not list then
106421: LD_VAR 0 13
106425: NOT
106426: IFFALSE 106430
// exit ;
106428: GO 106501
// for i in list do
106430: LD_ADDR_VAR 0 6
106434: PUSH
106435: LD_VAR 0 13
106439: PUSH
106440: FOR_IN
106441: IFFALSE 106499
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106443: LD_VAR 0 1
106447: PPUSH
106448: LD_STRING M
106450: PUSH
106451: LD_VAR 0 6
106455: PUSH
106456: LD_INT 1
106458: ARRAY
106459: PUSH
106460: LD_VAR 0 6
106464: PUSH
106465: LD_INT 2
106467: ARRAY
106468: PUSH
106469: LD_INT 0
106471: PUSH
106472: LD_INT 0
106474: PUSH
106475: LD_INT 0
106477: PUSH
106478: LD_INT 0
106480: PUSH
106481: EMPTY
106482: LIST
106483: LIST
106484: LIST
106485: LIST
106486: LIST
106487: LIST
106488: LIST
106489: PUSH
106490: EMPTY
106491: LIST
106492: PPUSH
106493: CALL_OW 447
106497: GO 106440
106499: POP
106500: POP
// end ;
106501: LD_VAR 0 5
106505: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106506: LD_EXP 155
106510: NOT
106511: IFFALSE 106561
106513: GO 106515
106515: DISABLE
// begin initHack := true ;
106516: LD_ADDR_EXP 155
106520: PUSH
106521: LD_INT 1
106523: ST_TO_ADDR
// hackTanks := [ ] ;
106524: LD_ADDR_EXP 156
106528: PUSH
106529: EMPTY
106530: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106531: LD_ADDR_EXP 157
106535: PUSH
106536: EMPTY
106537: ST_TO_ADDR
// hackLimit := 3 ;
106538: LD_ADDR_EXP 158
106542: PUSH
106543: LD_INT 3
106545: ST_TO_ADDR
// hackDist := 12 ;
106546: LD_ADDR_EXP 159
106550: PUSH
106551: LD_INT 12
106553: ST_TO_ADDR
// hackCounter := [ ] ;
106554: LD_ADDR_EXP 160
106558: PUSH
106559: EMPTY
106560: ST_TO_ADDR
// end ;
106561: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106562: LD_EXP 155
106566: PUSH
106567: LD_INT 34
106569: PUSH
106570: LD_INT 99
106572: PUSH
106573: EMPTY
106574: LIST
106575: LIST
106576: PPUSH
106577: CALL_OW 69
106581: AND
106582: IFFALSE 106835
106584: GO 106586
106586: DISABLE
106587: LD_INT 0
106589: PPUSH
106590: PPUSH
// begin enable ;
106591: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106592: LD_ADDR_VAR 0 1
106596: PUSH
106597: LD_INT 34
106599: PUSH
106600: LD_INT 99
106602: PUSH
106603: EMPTY
106604: LIST
106605: LIST
106606: PPUSH
106607: CALL_OW 69
106611: PUSH
106612: FOR_IN
106613: IFFALSE 106833
// begin if not i in hackTanks then
106615: LD_VAR 0 1
106619: PUSH
106620: LD_EXP 156
106624: IN
106625: NOT
106626: IFFALSE 106709
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106628: LD_ADDR_EXP 156
106632: PUSH
106633: LD_EXP 156
106637: PPUSH
106638: LD_EXP 156
106642: PUSH
106643: LD_INT 1
106645: PLUS
106646: PPUSH
106647: LD_VAR 0 1
106651: PPUSH
106652: CALL_OW 1
106656: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106657: LD_ADDR_EXP 157
106661: PUSH
106662: LD_EXP 157
106666: PPUSH
106667: LD_EXP 157
106671: PUSH
106672: LD_INT 1
106674: PLUS
106675: PPUSH
106676: EMPTY
106677: PPUSH
106678: CALL_OW 1
106682: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106683: LD_ADDR_EXP 160
106687: PUSH
106688: LD_EXP 160
106692: PPUSH
106693: LD_EXP 160
106697: PUSH
106698: LD_INT 1
106700: PLUS
106701: PPUSH
106702: EMPTY
106703: PPUSH
106704: CALL_OW 1
106708: ST_TO_ADDR
// end ; if not IsOk ( i ) then
106709: LD_VAR 0 1
106713: PPUSH
106714: CALL_OW 302
106718: NOT
106719: IFFALSE 106732
// begin HackUnlinkAll ( i ) ;
106721: LD_VAR 0 1
106725: PPUSH
106726: CALL 106838 0 1
// continue ;
106730: GO 106612
// end ; HackCheckCapturedStatus ( i ) ;
106732: LD_VAR 0 1
106736: PPUSH
106737: CALL 107281 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
106741: LD_ADDR_VAR 0 2
106745: PUSH
106746: LD_INT 81
106748: PUSH
106749: LD_VAR 0 1
106753: PPUSH
106754: CALL_OW 255
106758: PUSH
106759: EMPTY
106760: LIST
106761: LIST
106762: PUSH
106763: LD_INT 33
106765: PUSH
106766: LD_INT 3
106768: PUSH
106769: EMPTY
106770: LIST
106771: LIST
106772: PUSH
106773: LD_INT 91
106775: PUSH
106776: LD_VAR 0 1
106780: PUSH
106781: LD_EXP 159
106785: PUSH
106786: EMPTY
106787: LIST
106788: LIST
106789: LIST
106790: PUSH
106791: LD_INT 50
106793: PUSH
106794: EMPTY
106795: LIST
106796: PUSH
106797: EMPTY
106798: LIST
106799: LIST
106800: LIST
106801: LIST
106802: PPUSH
106803: CALL_OW 69
106807: ST_TO_ADDR
// if not tmp then
106808: LD_VAR 0 2
106812: NOT
106813: IFFALSE 106817
// continue ;
106815: GO 106612
// HackLink ( i , tmp ) ;
106817: LD_VAR 0 1
106821: PPUSH
106822: LD_VAR 0 2
106826: PPUSH
106827: CALL 106974 0 2
// end ;
106831: GO 106612
106833: POP
106834: POP
// end ;
106835: PPOPN 2
106837: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
106838: LD_INT 0
106840: PPUSH
106841: PPUSH
106842: PPUSH
// if not hack in hackTanks then
106843: LD_VAR 0 1
106847: PUSH
106848: LD_EXP 156
106852: IN
106853: NOT
106854: IFFALSE 106858
// exit ;
106856: GO 106969
// index := GetElementIndex ( hackTanks , hack ) ;
106858: LD_ADDR_VAR 0 4
106862: PUSH
106863: LD_EXP 156
106867: PPUSH
106868: LD_VAR 0 1
106872: PPUSH
106873: CALL 53463 0 2
106877: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
106878: LD_EXP 157
106882: PUSH
106883: LD_VAR 0 4
106887: ARRAY
106888: IFFALSE 106969
// begin for i in hackTanksCaptured [ index ] do
106890: LD_ADDR_VAR 0 3
106894: PUSH
106895: LD_EXP 157
106899: PUSH
106900: LD_VAR 0 4
106904: ARRAY
106905: PUSH
106906: FOR_IN
106907: IFFALSE 106933
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
106909: LD_VAR 0 3
106913: PUSH
106914: LD_INT 1
106916: ARRAY
106917: PPUSH
106918: LD_VAR 0 3
106922: PUSH
106923: LD_INT 2
106925: ARRAY
106926: PPUSH
106927: CALL_OW 235
106931: GO 106906
106933: POP
106934: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
106935: LD_ADDR_EXP 157
106939: PUSH
106940: LD_EXP 157
106944: PPUSH
106945: LD_VAR 0 4
106949: PPUSH
106950: EMPTY
106951: PPUSH
106952: CALL_OW 1
106956: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
106957: LD_VAR 0 1
106961: PPUSH
106962: LD_INT 0
106964: PPUSH
106965: CALL_OW 505
// end ; end ;
106969: LD_VAR 0 2
106973: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
106974: LD_INT 0
106976: PPUSH
106977: PPUSH
106978: PPUSH
// if not hack in hackTanks or not vehicles then
106979: LD_VAR 0 1
106983: PUSH
106984: LD_EXP 156
106988: IN
106989: NOT
106990: PUSH
106991: LD_VAR 0 2
106995: NOT
106996: OR
106997: IFFALSE 107001
// exit ;
106999: GO 107276
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107001: LD_ADDR_VAR 0 2
107005: PUSH
107006: LD_VAR 0 1
107010: PPUSH
107011: LD_VAR 0 2
107015: PPUSH
107016: LD_INT 1
107018: PPUSH
107019: LD_INT 1
107021: PPUSH
107022: CALL 54113 0 4
107026: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107027: LD_ADDR_VAR 0 5
107031: PUSH
107032: LD_EXP 156
107036: PPUSH
107037: LD_VAR 0 1
107041: PPUSH
107042: CALL 53463 0 2
107046: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107047: LD_EXP 157
107051: PUSH
107052: LD_VAR 0 5
107056: ARRAY
107057: PUSH
107058: LD_EXP 158
107062: LESS
107063: IFFALSE 107252
// begin for i := 1 to vehicles do
107065: LD_ADDR_VAR 0 4
107069: PUSH
107070: DOUBLE
107071: LD_INT 1
107073: DEC
107074: ST_TO_ADDR
107075: LD_VAR 0 2
107079: PUSH
107080: FOR_TO
107081: IFFALSE 107250
// begin if hackTanksCaptured [ index ] = hackLimit then
107083: LD_EXP 157
107087: PUSH
107088: LD_VAR 0 5
107092: ARRAY
107093: PUSH
107094: LD_EXP 158
107098: EQUAL
107099: IFFALSE 107103
// break ;
107101: GO 107250
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107103: LD_ADDR_EXP 160
107107: PUSH
107108: LD_EXP 160
107112: PPUSH
107113: LD_VAR 0 5
107117: PPUSH
107118: LD_EXP 160
107122: PUSH
107123: LD_VAR 0 5
107127: ARRAY
107128: PUSH
107129: LD_INT 1
107131: PLUS
107132: PPUSH
107133: CALL_OW 1
107137: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107138: LD_ADDR_EXP 157
107142: PUSH
107143: LD_EXP 157
107147: PPUSH
107148: LD_VAR 0 5
107152: PUSH
107153: LD_EXP 157
107157: PUSH
107158: LD_VAR 0 5
107162: ARRAY
107163: PUSH
107164: LD_INT 1
107166: PLUS
107167: PUSH
107168: EMPTY
107169: LIST
107170: LIST
107171: PPUSH
107172: LD_VAR 0 2
107176: PUSH
107177: LD_VAR 0 4
107181: ARRAY
107182: PUSH
107183: LD_VAR 0 2
107187: PUSH
107188: LD_VAR 0 4
107192: ARRAY
107193: PPUSH
107194: CALL_OW 255
107198: PUSH
107199: EMPTY
107200: LIST
107201: LIST
107202: PPUSH
107203: CALL 53678 0 3
107207: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107208: LD_VAR 0 2
107212: PUSH
107213: LD_VAR 0 4
107217: ARRAY
107218: PPUSH
107219: LD_VAR 0 1
107223: PPUSH
107224: CALL_OW 255
107228: PPUSH
107229: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107233: LD_VAR 0 2
107237: PUSH
107238: LD_VAR 0 4
107242: ARRAY
107243: PPUSH
107244: CALL_OW 141
// end ;
107248: GO 107080
107250: POP
107251: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107252: LD_VAR 0 1
107256: PPUSH
107257: LD_EXP 157
107261: PUSH
107262: LD_VAR 0 5
107266: ARRAY
107267: PUSH
107268: LD_INT 0
107270: PLUS
107271: PPUSH
107272: CALL_OW 505
// end ;
107276: LD_VAR 0 3
107280: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107281: LD_INT 0
107283: PPUSH
107284: PPUSH
107285: PPUSH
107286: PPUSH
// if not hack in hackTanks then
107287: LD_VAR 0 1
107291: PUSH
107292: LD_EXP 156
107296: IN
107297: NOT
107298: IFFALSE 107302
// exit ;
107300: GO 107542
// index := GetElementIndex ( hackTanks , hack ) ;
107302: LD_ADDR_VAR 0 4
107306: PUSH
107307: LD_EXP 156
107311: PPUSH
107312: LD_VAR 0 1
107316: PPUSH
107317: CALL 53463 0 2
107321: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107322: LD_ADDR_VAR 0 3
107326: PUSH
107327: DOUBLE
107328: LD_EXP 157
107332: PUSH
107333: LD_VAR 0 4
107337: ARRAY
107338: INC
107339: ST_TO_ADDR
107340: LD_INT 1
107342: PUSH
107343: FOR_DOWNTO
107344: IFFALSE 107516
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107346: LD_ADDR_VAR 0 5
107350: PUSH
107351: LD_EXP 157
107355: PUSH
107356: LD_VAR 0 4
107360: ARRAY
107361: PUSH
107362: LD_VAR 0 3
107366: ARRAY
107367: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107368: LD_VAR 0 5
107372: PUSH
107373: LD_INT 1
107375: ARRAY
107376: PPUSH
107377: CALL_OW 302
107381: NOT
107382: PUSH
107383: LD_VAR 0 5
107387: PUSH
107388: LD_INT 1
107390: ARRAY
107391: PPUSH
107392: CALL_OW 255
107396: PUSH
107397: LD_VAR 0 1
107401: PPUSH
107402: CALL_OW 255
107406: NONEQUAL
107407: OR
107408: IFFALSE 107514
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107410: LD_VAR 0 5
107414: PUSH
107415: LD_INT 1
107417: ARRAY
107418: PPUSH
107419: CALL_OW 305
107423: PUSH
107424: LD_VAR 0 5
107428: PUSH
107429: LD_INT 1
107431: ARRAY
107432: PPUSH
107433: CALL_OW 255
107437: PUSH
107438: LD_VAR 0 1
107442: PPUSH
107443: CALL_OW 255
107447: EQUAL
107448: AND
107449: IFFALSE 107473
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107451: LD_VAR 0 5
107455: PUSH
107456: LD_INT 1
107458: ARRAY
107459: PPUSH
107460: LD_VAR 0 5
107464: PUSH
107465: LD_INT 2
107467: ARRAY
107468: PPUSH
107469: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107473: LD_ADDR_EXP 157
107477: PUSH
107478: LD_EXP 157
107482: PPUSH
107483: LD_VAR 0 4
107487: PPUSH
107488: LD_EXP 157
107492: PUSH
107493: LD_VAR 0 4
107497: ARRAY
107498: PPUSH
107499: LD_VAR 0 3
107503: PPUSH
107504: CALL_OW 3
107508: PPUSH
107509: CALL_OW 1
107513: ST_TO_ADDR
// end ; end ;
107514: GO 107343
107516: POP
107517: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107518: LD_VAR 0 1
107522: PPUSH
107523: LD_EXP 157
107527: PUSH
107528: LD_VAR 0 4
107532: ARRAY
107533: PUSH
107534: LD_INT 0
107536: PLUS
107537: PPUSH
107538: CALL_OW 505
// end ;
107542: LD_VAR 0 2
107546: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107547: LD_INT 0
107549: PPUSH
107550: PPUSH
107551: PPUSH
107552: PPUSH
// if not hack in hackTanks then
107553: LD_VAR 0 1
107557: PUSH
107558: LD_EXP 156
107562: IN
107563: NOT
107564: IFFALSE 107568
// exit ;
107566: GO 107653
// index := GetElementIndex ( hackTanks , hack ) ;
107568: LD_ADDR_VAR 0 5
107572: PUSH
107573: LD_EXP 156
107577: PPUSH
107578: LD_VAR 0 1
107582: PPUSH
107583: CALL 53463 0 2
107587: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107588: LD_ADDR_VAR 0 4
107592: PUSH
107593: DOUBLE
107594: LD_INT 1
107596: DEC
107597: ST_TO_ADDR
107598: LD_EXP 157
107602: PUSH
107603: LD_VAR 0 5
107607: ARRAY
107608: PUSH
107609: FOR_TO
107610: IFFALSE 107651
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107612: LD_EXP 157
107616: PUSH
107617: LD_VAR 0 5
107621: ARRAY
107622: PUSH
107623: LD_VAR 0 4
107627: ARRAY
107628: PUSH
107629: LD_INT 1
107631: ARRAY
107632: PUSH
107633: LD_VAR 0 2
107637: EQUAL
107638: IFFALSE 107649
// KillUnit ( vehicle ) ;
107640: LD_VAR 0 2
107644: PPUSH
107645: CALL_OW 66
107649: GO 107609
107651: POP
107652: POP
// end ;
107653: LD_VAR 0 3
107657: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107658: LD_EXP 161
107662: NOT
107663: IFFALSE 107698
107665: GO 107667
107667: DISABLE
// begin initMiner := true ;
107668: LD_ADDR_EXP 161
107672: PUSH
107673: LD_INT 1
107675: ST_TO_ADDR
// minersList := [ ] ;
107676: LD_ADDR_EXP 162
107680: PUSH
107681: EMPTY
107682: ST_TO_ADDR
// minerMinesList := [ ] ;
107683: LD_ADDR_EXP 163
107687: PUSH
107688: EMPTY
107689: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107690: LD_ADDR_EXP 164
107694: PUSH
107695: LD_INT 5
107697: ST_TO_ADDR
// end ;
107698: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107699: LD_EXP 161
107703: PUSH
107704: LD_INT 34
107706: PUSH
107707: LD_INT 81
107709: PUSH
107710: EMPTY
107711: LIST
107712: LIST
107713: PPUSH
107714: CALL_OW 69
107718: AND
107719: IFFALSE 108180
107721: GO 107723
107723: DISABLE
107724: LD_INT 0
107726: PPUSH
107727: PPUSH
107728: PPUSH
107729: PPUSH
// begin enable ;
107730: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
107731: LD_ADDR_VAR 0 1
107735: PUSH
107736: LD_INT 34
107738: PUSH
107739: LD_INT 81
107741: PUSH
107742: EMPTY
107743: LIST
107744: LIST
107745: PPUSH
107746: CALL_OW 69
107750: PUSH
107751: FOR_IN
107752: IFFALSE 107824
// begin if not i in minersList then
107754: LD_VAR 0 1
107758: PUSH
107759: LD_EXP 162
107763: IN
107764: NOT
107765: IFFALSE 107822
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
107767: LD_ADDR_EXP 162
107771: PUSH
107772: LD_EXP 162
107776: PPUSH
107777: LD_EXP 162
107781: PUSH
107782: LD_INT 1
107784: PLUS
107785: PPUSH
107786: LD_VAR 0 1
107790: PPUSH
107791: CALL_OW 1
107795: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
107796: LD_ADDR_EXP 163
107800: PUSH
107801: LD_EXP 163
107805: PPUSH
107806: LD_EXP 163
107810: PUSH
107811: LD_INT 1
107813: PLUS
107814: PPUSH
107815: EMPTY
107816: PPUSH
107817: CALL_OW 1
107821: ST_TO_ADDR
// end end ;
107822: GO 107751
107824: POP
107825: POP
// for i := minerMinesList downto 1 do
107826: LD_ADDR_VAR 0 1
107830: PUSH
107831: DOUBLE
107832: LD_EXP 163
107836: INC
107837: ST_TO_ADDR
107838: LD_INT 1
107840: PUSH
107841: FOR_DOWNTO
107842: IFFALSE 108178
// begin if IsLive ( minersList [ i ] ) then
107844: LD_EXP 162
107848: PUSH
107849: LD_VAR 0 1
107853: ARRAY
107854: PPUSH
107855: CALL_OW 300
107859: IFFALSE 107887
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
107861: LD_EXP 162
107865: PUSH
107866: LD_VAR 0 1
107870: ARRAY
107871: PPUSH
107872: LD_EXP 163
107876: PUSH
107877: LD_VAR 0 1
107881: ARRAY
107882: PPUSH
107883: CALL_OW 505
// if not minerMinesList [ i ] then
107887: LD_EXP 163
107891: PUSH
107892: LD_VAR 0 1
107896: ARRAY
107897: NOT
107898: IFFALSE 107902
// continue ;
107900: GO 107841
// for j := minerMinesList [ i ] downto 1 do
107902: LD_ADDR_VAR 0 2
107906: PUSH
107907: DOUBLE
107908: LD_EXP 163
107912: PUSH
107913: LD_VAR 0 1
107917: ARRAY
107918: INC
107919: ST_TO_ADDR
107920: LD_INT 1
107922: PUSH
107923: FOR_DOWNTO
107924: IFFALSE 108174
// begin side := GetSide ( minersList [ i ] ) ;
107926: LD_ADDR_VAR 0 3
107930: PUSH
107931: LD_EXP 162
107935: PUSH
107936: LD_VAR 0 1
107940: ARRAY
107941: PPUSH
107942: CALL_OW 255
107946: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
107947: LD_ADDR_VAR 0 4
107951: PUSH
107952: LD_EXP 163
107956: PUSH
107957: LD_VAR 0 1
107961: ARRAY
107962: PUSH
107963: LD_VAR 0 2
107967: ARRAY
107968: PUSH
107969: LD_INT 1
107971: ARRAY
107972: PPUSH
107973: LD_EXP 163
107977: PUSH
107978: LD_VAR 0 1
107982: ARRAY
107983: PUSH
107984: LD_VAR 0 2
107988: ARRAY
107989: PUSH
107990: LD_INT 2
107992: ARRAY
107993: PPUSH
107994: CALL_OW 428
107998: ST_TO_ADDR
// if not tmp then
107999: LD_VAR 0 4
108003: NOT
108004: IFFALSE 108008
// continue ;
108006: GO 107923
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108008: LD_VAR 0 4
108012: PUSH
108013: LD_INT 81
108015: PUSH
108016: LD_VAR 0 3
108020: PUSH
108021: EMPTY
108022: LIST
108023: LIST
108024: PPUSH
108025: CALL_OW 69
108029: IN
108030: PUSH
108031: LD_EXP 163
108035: PUSH
108036: LD_VAR 0 1
108040: ARRAY
108041: PUSH
108042: LD_VAR 0 2
108046: ARRAY
108047: PUSH
108048: LD_INT 1
108050: ARRAY
108051: PPUSH
108052: LD_EXP 163
108056: PUSH
108057: LD_VAR 0 1
108061: ARRAY
108062: PUSH
108063: LD_VAR 0 2
108067: ARRAY
108068: PUSH
108069: LD_INT 2
108071: ARRAY
108072: PPUSH
108073: CALL_OW 458
108077: AND
108078: IFFALSE 108172
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108080: LD_EXP 163
108084: PUSH
108085: LD_VAR 0 1
108089: ARRAY
108090: PUSH
108091: LD_VAR 0 2
108095: ARRAY
108096: PUSH
108097: LD_INT 1
108099: ARRAY
108100: PPUSH
108101: LD_EXP 163
108105: PUSH
108106: LD_VAR 0 1
108110: ARRAY
108111: PUSH
108112: LD_VAR 0 2
108116: ARRAY
108117: PUSH
108118: LD_INT 2
108120: ARRAY
108121: PPUSH
108122: LD_VAR 0 3
108126: PPUSH
108127: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108131: LD_ADDR_EXP 163
108135: PUSH
108136: LD_EXP 163
108140: PPUSH
108141: LD_VAR 0 1
108145: PPUSH
108146: LD_EXP 163
108150: PUSH
108151: LD_VAR 0 1
108155: ARRAY
108156: PPUSH
108157: LD_VAR 0 2
108161: PPUSH
108162: CALL_OW 3
108166: PPUSH
108167: CALL_OW 1
108171: ST_TO_ADDR
// end ; end ;
108172: GO 107923
108174: POP
108175: POP
// end ;
108176: GO 107841
108178: POP
108179: POP
// end ;
108180: PPOPN 4
108182: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108183: LD_INT 0
108185: PPUSH
108186: PPUSH
// result := false ;
108187: LD_ADDR_VAR 0 4
108191: PUSH
108192: LD_INT 0
108194: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108195: LD_VAR 0 1
108199: PPUSH
108200: CALL_OW 264
108204: PUSH
108205: LD_INT 81
108207: EQUAL
108208: NOT
108209: IFFALSE 108213
// exit ;
108211: GO 108453
// index := GetElementIndex ( minersList , unit ) ;
108213: LD_ADDR_VAR 0 5
108217: PUSH
108218: LD_EXP 162
108222: PPUSH
108223: LD_VAR 0 1
108227: PPUSH
108228: CALL 53463 0 2
108232: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108233: LD_EXP 163
108237: PUSH
108238: LD_VAR 0 5
108242: ARRAY
108243: PUSH
108244: LD_EXP 164
108248: GREATEREQUAL
108249: IFFALSE 108253
// exit ;
108251: GO 108453
// ComMoveXY ( unit , x , y ) ;
108253: LD_VAR 0 1
108257: PPUSH
108258: LD_VAR 0 2
108262: PPUSH
108263: LD_VAR 0 3
108267: PPUSH
108268: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108272: LD_INT 35
108274: PPUSH
108275: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108279: LD_VAR 0 1
108283: PPUSH
108284: LD_VAR 0 2
108288: PPUSH
108289: LD_VAR 0 3
108293: PPUSH
108294: CALL 84726 0 3
108298: NOT
108299: PUSH
108300: LD_VAR 0 1
108304: PPUSH
108305: CALL_OW 314
108309: AND
108310: IFFALSE 108314
// exit ;
108312: GO 108453
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108314: LD_VAR 0 2
108318: PPUSH
108319: LD_VAR 0 3
108323: PPUSH
108324: CALL_OW 428
108328: PUSH
108329: LD_VAR 0 1
108333: EQUAL
108334: PUSH
108335: LD_VAR 0 1
108339: PPUSH
108340: CALL_OW 314
108344: NOT
108345: AND
108346: IFFALSE 108272
// PlaySoundXY ( x , y , PlantMine ) ;
108348: LD_VAR 0 2
108352: PPUSH
108353: LD_VAR 0 3
108357: PPUSH
108358: LD_STRING PlantMine
108360: PPUSH
108361: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108365: LD_VAR 0 2
108369: PPUSH
108370: LD_VAR 0 3
108374: PPUSH
108375: LD_VAR 0 1
108379: PPUSH
108380: CALL_OW 255
108384: PPUSH
108385: LD_INT 0
108387: PPUSH
108388: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108392: LD_ADDR_EXP 163
108396: PUSH
108397: LD_EXP 163
108401: PPUSH
108402: LD_VAR 0 5
108406: PUSH
108407: LD_EXP 163
108411: PUSH
108412: LD_VAR 0 5
108416: ARRAY
108417: PUSH
108418: LD_INT 1
108420: PLUS
108421: PUSH
108422: EMPTY
108423: LIST
108424: LIST
108425: PPUSH
108426: LD_VAR 0 2
108430: PUSH
108431: LD_VAR 0 3
108435: PUSH
108436: EMPTY
108437: LIST
108438: LIST
108439: PPUSH
108440: CALL 53678 0 3
108444: ST_TO_ADDR
// result := true ;
108445: LD_ADDR_VAR 0 4
108449: PUSH
108450: LD_INT 1
108452: ST_TO_ADDR
// end ;
108453: LD_VAR 0 4
108457: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108458: LD_INT 0
108460: PPUSH
108461: PPUSH
108462: PPUSH
// if not unit in minersList then
108463: LD_VAR 0 1
108467: PUSH
108468: LD_EXP 162
108472: IN
108473: NOT
108474: IFFALSE 108478
// exit ;
108476: GO 108870
// index := GetElementIndex ( minersList , unit ) ;
108478: LD_ADDR_VAR 0 6
108482: PUSH
108483: LD_EXP 162
108487: PPUSH
108488: LD_VAR 0 1
108492: PPUSH
108493: CALL 53463 0 2
108497: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108498: LD_ADDR_VAR 0 5
108502: PUSH
108503: DOUBLE
108504: LD_EXP 163
108508: PUSH
108509: LD_VAR 0 6
108513: ARRAY
108514: INC
108515: ST_TO_ADDR
108516: LD_INT 1
108518: PUSH
108519: FOR_DOWNTO
108520: IFFALSE 108681
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108522: LD_EXP 163
108526: PUSH
108527: LD_VAR 0 6
108531: ARRAY
108532: PUSH
108533: LD_VAR 0 5
108537: ARRAY
108538: PUSH
108539: LD_INT 1
108541: ARRAY
108542: PUSH
108543: LD_VAR 0 2
108547: EQUAL
108548: PUSH
108549: LD_EXP 163
108553: PUSH
108554: LD_VAR 0 6
108558: ARRAY
108559: PUSH
108560: LD_VAR 0 5
108564: ARRAY
108565: PUSH
108566: LD_INT 2
108568: ARRAY
108569: PUSH
108570: LD_VAR 0 3
108574: EQUAL
108575: AND
108576: IFFALSE 108679
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108578: LD_EXP 163
108582: PUSH
108583: LD_VAR 0 6
108587: ARRAY
108588: PUSH
108589: LD_VAR 0 5
108593: ARRAY
108594: PUSH
108595: LD_INT 1
108597: ARRAY
108598: PPUSH
108599: LD_EXP 163
108603: PUSH
108604: LD_VAR 0 6
108608: ARRAY
108609: PUSH
108610: LD_VAR 0 5
108614: ARRAY
108615: PUSH
108616: LD_INT 2
108618: ARRAY
108619: PPUSH
108620: LD_VAR 0 1
108624: PPUSH
108625: CALL_OW 255
108629: PPUSH
108630: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108634: LD_ADDR_EXP 163
108638: PUSH
108639: LD_EXP 163
108643: PPUSH
108644: LD_VAR 0 6
108648: PPUSH
108649: LD_EXP 163
108653: PUSH
108654: LD_VAR 0 6
108658: ARRAY
108659: PPUSH
108660: LD_VAR 0 5
108664: PPUSH
108665: CALL_OW 3
108669: PPUSH
108670: CALL_OW 1
108674: ST_TO_ADDR
// exit ;
108675: POP
108676: POP
108677: GO 108870
// end ; end ;
108679: GO 108519
108681: POP
108682: POP
// for i := minerMinesList [ index ] downto 1 do
108683: LD_ADDR_VAR 0 5
108687: PUSH
108688: DOUBLE
108689: LD_EXP 163
108693: PUSH
108694: LD_VAR 0 6
108698: ARRAY
108699: INC
108700: ST_TO_ADDR
108701: LD_INT 1
108703: PUSH
108704: FOR_DOWNTO
108705: IFFALSE 108868
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
108707: LD_EXP 163
108711: PUSH
108712: LD_VAR 0 6
108716: ARRAY
108717: PUSH
108718: LD_VAR 0 5
108722: ARRAY
108723: PUSH
108724: LD_INT 1
108726: ARRAY
108727: PPUSH
108728: LD_EXP 163
108732: PUSH
108733: LD_VAR 0 6
108737: ARRAY
108738: PUSH
108739: LD_VAR 0 5
108743: ARRAY
108744: PUSH
108745: LD_INT 2
108747: ARRAY
108748: PPUSH
108749: LD_VAR 0 2
108753: PPUSH
108754: LD_VAR 0 3
108758: PPUSH
108759: CALL_OW 298
108763: PUSH
108764: LD_INT 6
108766: LESS
108767: IFFALSE 108866
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108769: LD_EXP 163
108773: PUSH
108774: LD_VAR 0 6
108778: ARRAY
108779: PUSH
108780: LD_VAR 0 5
108784: ARRAY
108785: PUSH
108786: LD_INT 1
108788: ARRAY
108789: PPUSH
108790: LD_EXP 163
108794: PUSH
108795: LD_VAR 0 6
108799: ARRAY
108800: PUSH
108801: LD_VAR 0 5
108805: ARRAY
108806: PUSH
108807: LD_INT 2
108809: ARRAY
108810: PPUSH
108811: LD_VAR 0 1
108815: PPUSH
108816: CALL_OW 255
108820: PPUSH
108821: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108825: LD_ADDR_EXP 163
108829: PUSH
108830: LD_EXP 163
108834: PPUSH
108835: LD_VAR 0 6
108839: PPUSH
108840: LD_EXP 163
108844: PUSH
108845: LD_VAR 0 6
108849: ARRAY
108850: PPUSH
108851: LD_VAR 0 5
108855: PPUSH
108856: CALL_OW 3
108860: PPUSH
108861: CALL_OW 1
108865: ST_TO_ADDR
// end ; end ;
108866: GO 108704
108868: POP
108869: POP
// end ;
108870: LD_VAR 0 4
108874: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
108875: LD_INT 0
108877: PPUSH
108878: PPUSH
108879: PPUSH
108880: PPUSH
108881: PPUSH
108882: PPUSH
108883: PPUSH
108884: PPUSH
108885: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
108886: LD_VAR 0 1
108890: PPUSH
108891: CALL_OW 264
108895: PUSH
108896: LD_INT 81
108898: EQUAL
108899: NOT
108900: PUSH
108901: LD_VAR 0 1
108905: PUSH
108906: LD_EXP 162
108910: IN
108911: NOT
108912: OR
108913: IFFALSE 108917
// exit ;
108915: GO 109239
// index := GetElementIndex ( minersList , unit ) ;
108917: LD_ADDR_VAR 0 6
108921: PUSH
108922: LD_EXP 162
108926: PPUSH
108927: LD_VAR 0 1
108931: PPUSH
108932: CALL 53463 0 2
108936: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
108937: LD_ADDR_VAR 0 8
108941: PUSH
108942: LD_EXP 164
108946: PUSH
108947: LD_EXP 163
108951: PUSH
108952: LD_VAR 0 6
108956: ARRAY
108957: MINUS
108958: ST_TO_ADDR
// if not minesFreeAmount then
108959: LD_VAR 0 8
108963: NOT
108964: IFFALSE 108968
// exit ;
108966: GO 109239
// tmp := [ ] ;
108968: LD_ADDR_VAR 0 7
108972: PUSH
108973: EMPTY
108974: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
108975: LD_ADDR_VAR 0 5
108979: PUSH
108980: DOUBLE
108981: LD_INT 1
108983: DEC
108984: ST_TO_ADDR
108985: LD_VAR 0 8
108989: PUSH
108990: FOR_TO
108991: IFFALSE 109186
// begin _d := rand ( 0 , 5 ) ;
108993: LD_ADDR_VAR 0 11
108997: PUSH
108998: LD_INT 0
109000: PPUSH
109001: LD_INT 5
109003: PPUSH
109004: CALL_OW 12
109008: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109009: LD_ADDR_VAR 0 12
109013: PUSH
109014: LD_INT 2
109016: PPUSH
109017: LD_INT 6
109019: PPUSH
109020: CALL_OW 12
109024: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109025: LD_ADDR_VAR 0 9
109029: PUSH
109030: LD_VAR 0 2
109034: PPUSH
109035: LD_VAR 0 11
109039: PPUSH
109040: LD_VAR 0 12
109044: PPUSH
109045: CALL_OW 272
109049: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109050: LD_ADDR_VAR 0 10
109054: PUSH
109055: LD_VAR 0 3
109059: PPUSH
109060: LD_VAR 0 11
109064: PPUSH
109065: LD_VAR 0 12
109069: PPUSH
109070: CALL_OW 273
109074: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109075: LD_VAR 0 9
109079: PPUSH
109080: LD_VAR 0 10
109084: PPUSH
109085: CALL_OW 488
109089: PUSH
109090: LD_VAR 0 9
109094: PUSH
109095: LD_VAR 0 10
109099: PUSH
109100: EMPTY
109101: LIST
109102: LIST
109103: PUSH
109104: LD_VAR 0 7
109108: IN
109109: NOT
109110: AND
109111: PUSH
109112: LD_VAR 0 9
109116: PPUSH
109117: LD_VAR 0 10
109121: PPUSH
109122: CALL_OW 458
109126: NOT
109127: AND
109128: IFFALSE 109170
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109130: LD_ADDR_VAR 0 7
109134: PUSH
109135: LD_VAR 0 7
109139: PPUSH
109140: LD_VAR 0 7
109144: PUSH
109145: LD_INT 1
109147: PLUS
109148: PPUSH
109149: LD_VAR 0 9
109153: PUSH
109154: LD_VAR 0 10
109158: PUSH
109159: EMPTY
109160: LIST
109161: LIST
109162: PPUSH
109163: CALL_OW 1
109167: ST_TO_ADDR
109168: GO 109184
// i := i - 1 ;
109170: LD_ADDR_VAR 0 5
109174: PUSH
109175: LD_VAR 0 5
109179: PUSH
109180: LD_INT 1
109182: MINUS
109183: ST_TO_ADDR
// end ;
109184: GO 108990
109186: POP
109187: POP
// for i in tmp do
109188: LD_ADDR_VAR 0 5
109192: PUSH
109193: LD_VAR 0 7
109197: PUSH
109198: FOR_IN
109199: IFFALSE 109237
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109201: LD_VAR 0 1
109205: PPUSH
109206: LD_VAR 0 5
109210: PUSH
109211: LD_INT 1
109213: ARRAY
109214: PPUSH
109215: LD_VAR 0 5
109219: PUSH
109220: LD_INT 2
109222: ARRAY
109223: PPUSH
109224: CALL 108183 0 3
109228: NOT
109229: IFFALSE 109235
// exit ;
109231: POP
109232: POP
109233: GO 109239
109235: GO 109198
109237: POP
109238: POP
// end ;
109239: LD_VAR 0 4
109243: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109244: LD_INT 0
109246: PPUSH
109247: PPUSH
109248: PPUSH
109249: PPUSH
109250: PPUSH
109251: PPUSH
109252: PPUSH
// if not GetClass ( unit ) = class_sniper then
109253: LD_VAR 0 1
109257: PPUSH
109258: CALL_OW 257
109262: PUSH
109263: LD_INT 5
109265: EQUAL
109266: NOT
109267: IFFALSE 109271
// exit ;
109269: GO 109659
// dist := 8 ;
109271: LD_ADDR_VAR 0 5
109275: PUSH
109276: LD_INT 8
109278: ST_TO_ADDR
// viewRange := 12 ;
109279: LD_ADDR_VAR 0 7
109283: PUSH
109284: LD_INT 12
109286: ST_TO_ADDR
// side := GetSide ( unit ) ;
109287: LD_ADDR_VAR 0 6
109291: PUSH
109292: LD_VAR 0 1
109296: PPUSH
109297: CALL_OW 255
109301: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109302: LD_INT 61
109304: PPUSH
109305: LD_VAR 0 6
109309: PPUSH
109310: CALL_OW 321
109314: PUSH
109315: LD_INT 2
109317: EQUAL
109318: IFFALSE 109328
// viewRange := 16 ;
109320: LD_ADDR_VAR 0 7
109324: PUSH
109325: LD_INT 16
109327: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109328: LD_VAR 0 1
109332: PPUSH
109333: LD_VAR 0 2
109337: PPUSH
109338: LD_VAR 0 3
109342: PPUSH
109343: CALL_OW 297
109347: PUSH
109348: LD_VAR 0 5
109352: GREATER
109353: IFFALSE 109432
// begin ComMoveXY ( unit , x , y ) ;
109355: LD_VAR 0 1
109359: PPUSH
109360: LD_VAR 0 2
109364: PPUSH
109365: LD_VAR 0 3
109369: PPUSH
109370: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109374: LD_INT 35
109376: PPUSH
109377: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109381: LD_VAR 0 1
109385: PPUSH
109386: LD_VAR 0 2
109390: PPUSH
109391: LD_VAR 0 3
109395: PPUSH
109396: CALL 84726 0 3
109400: NOT
109401: IFFALSE 109405
// exit ;
109403: GO 109659
// until GetDistUnitXY ( unit , x , y ) < dist ;
109405: LD_VAR 0 1
109409: PPUSH
109410: LD_VAR 0 2
109414: PPUSH
109415: LD_VAR 0 3
109419: PPUSH
109420: CALL_OW 297
109424: PUSH
109425: LD_VAR 0 5
109429: LESS
109430: IFFALSE 109374
// end ; ComTurnXY ( unit , x , y ) ;
109432: LD_VAR 0 1
109436: PPUSH
109437: LD_VAR 0 2
109441: PPUSH
109442: LD_VAR 0 3
109446: PPUSH
109447: CALL_OW 118
// wait ( 5 ) ;
109451: LD_INT 5
109453: PPUSH
109454: CALL_OW 67
// _d := GetDir ( unit ) ;
109458: LD_ADDR_VAR 0 10
109462: PUSH
109463: LD_VAR 0 1
109467: PPUSH
109468: CALL_OW 254
109472: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109473: LD_ADDR_VAR 0 8
109477: PUSH
109478: LD_VAR 0 1
109482: PPUSH
109483: CALL_OW 250
109487: PPUSH
109488: LD_VAR 0 10
109492: PPUSH
109493: LD_VAR 0 5
109497: PPUSH
109498: CALL_OW 272
109502: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109503: LD_ADDR_VAR 0 9
109507: PUSH
109508: LD_VAR 0 1
109512: PPUSH
109513: CALL_OW 251
109517: PPUSH
109518: LD_VAR 0 10
109522: PPUSH
109523: LD_VAR 0 5
109527: PPUSH
109528: CALL_OW 273
109532: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109533: LD_VAR 0 8
109537: PPUSH
109538: LD_VAR 0 9
109542: PPUSH
109543: CALL_OW 488
109547: NOT
109548: IFFALSE 109552
// exit ;
109550: GO 109659
// ComAnimCustom ( unit , 1 ) ;
109552: LD_VAR 0 1
109556: PPUSH
109557: LD_INT 1
109559: PPUSH
109560: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109564: LD_VAR 0 8
109568: PPUSH
109569: LD_VAR 0 9
109573: PPUSH
109574: LD_VAR 0 6
109578: PPUSH
109579: LD_VAR 0 7
109583: PPUSH
109584: CALL_OW 330
// repeat wait ( 1 ) ;
109588: LD_INT 1
109590: PPUSH
109591: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109595: LD_VAR 0 1
109599: PPUSH
109600: CALL_OW 316
109604: PUSH
109605: LD_VAR 0 1
109609: PPUSH
109610: CALL_OW 314
109614: OR
109615: PUSH
109616: LD_VAR 0 1
109620: PPUSH
109621: CALL_OW 302
109625: NOT
109626: OR
109627: PUSH
109628: LD_VAR 0 1
109632: PPUSH
109633: CALL_OW 301
109637: OR
109638: IFFALSE 109588
// RemoveSeeing ( _x , _y , side ) ;
109640: LD_VAR 0 8
109644: PPUSH
109645: LD_VAR 0 9
109649: PPUSH
109650: LD_VAR 0 6
109654: PPUSH
109655: CALL_OW 331
// end ; end_of_file
109659: LD_VAR 0 4
109663: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109664: LD_INT 0
109666: PPUSH
109667: PPUSH
109668: PPUSH
109669: PPUSH
109670: PPUSH
109671: PPUSH
109672: PPUSH
109673: PPUSH
109674: PPUSH
109675: PPUSH
109676: PPUSH
109677: PPUSH
109678: PPUSH
109679: PPUSH
109680: PPUSH
109681: PPUSH
109682: PPUSH
109683: PPUSH
109684: PPUSH
109685: PPUSH
109686: PPUSH
109687: PPUSH
109688: PPUSH
109689: PPUSH
109690: PPUSH
109691: PPUSH
109692: PPUSH
109693: PPUSH
109694: PPUSH
109695: PPUSH
109696: PPUSH
109697: PPUSH
109698: PPUSH
109699: PPUSH
// if not list then
109700: LD_VAR 0 1
109704: NOT
109705: IFFALSE 109709
// exit ;
109707: GO 114368
// base := list [ 1 ] ;
109709: LD_ADDR_VAR 0 3
109713: PUSH
109714: LD_VAR 0 1
109718: PUSH
109719: LD_INT 1
109721: ARRAY
109722: ST_TO_ADDR
// group := list [ 2 ] ;
109723: LD_ADDR_VAR 0 4
109727: PUSH
109728: LD_VAR 0 1
109732: PUSH
109733: LD_INT 2
109735: ARRAY
109736: ST_TO_ADDR
// path := list [ 3 ] ;
109737: LD_ADDR_VAR 0 5
109741: PUSH
109742: LD_VAR 0 1
109746: PUSH
109747: LD_INT 3
109749: ARRAY
109750: ST_TO_ADDR
// flags := list [ 4 ] ;
109751: LD_ADDR_VAR 0 6
109755: PUSH
109756: LD_VAR 0 1
109760: PUSH
109761: LD_INT 4
109763: ARRAY
109764: ST_TO_ADDR
// mined := [ ] ;
109765: LD_ADDR_VAR 0 27
109769: PUSH
109770: EMPTY
109771: ST_TO_ADDR
// bombed := [ ] ;
109772: LD_ADDR_VAR 0 28
109776: PUSH
109777: EMPTY
109778: ST_TO_ADDR
// healers := [ ] ;
109779: LD_ADDR_VAR 0 31
109783: PUSH
109784: EMPTY
109785: ST_TO_ADDR
// to_heal := [ ] ;
109786: LD_ADDR_VAR 0 30
109790: PUSH
109791: EMPTY
109792: ST_TO_ADDR
// repairs := [ ] ;
109793: LD_ADDR_VAR 0 33
109797: PUSH
109798: EMPTY
109799: ST_TO_ADDR
// to_repair := [ ] ;
109800: LD_ADDR_VAR 0 32
109804: PUSH
109805: EMPTY
109806: ST_TO_ADDR
// if not group or not path then
109807: LD_VAR 0 4
109811: NOT
109812: PUSH
109813: LD_VAR 0 5
109817: NOT
109818: OR
109819: IFFALSE 109823
// exit ;
109821: GO 114368
// side := GetSide ( group [ 1 ] ) ;
109823: LD_ADDR_VAR 0 35
109827: PUSH
109828: LD_VAR 0 4
109832: PUSH
109833: LD_INT 1
109835: ARRAY
109836: PPUSH
109837: CALL_OW 255
109841: ST_TO_ADDR
// if flags then
109842: LD_VAR 0 6
109846: IFFALSE 109990
// begin f_ignore_area := flags [ 1 ] ;
109848: LD_ADDR_VAR 0 17
109852: PUSH
109853: LD_VAR 0 6
109857: PUSH
109858: LD_INT 1
109860: ARRAY
109861: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
109862: LD_ADDR_VAR 0 18
109866: PUSH
109867: LD_VAR 0 6
109871: PUSH
109872: LD_INT 2
109874: ARRAY
109875: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
109876: LD_ADDR_VAR 0 19
109880: PUSH
109881: LD_VAR 0 6
109885: PUSH
109886: LD_INT 3
109888: ARRAY
109889: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
109890: LD_ADDR_VAR 0 20
109894: PUSH
109895: LD_VAR 0 6
109899: PUSH
109900: LD_INT 4
109902: ARRAY
109903: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
109904: LD_ADDR_VAR 0 21
109908: PUSH
109909: LD_VAR 0 6
109913: PUSH
109914: LD_INT 5
109916: ARRAY
109917: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
109918: LD_ADDR_VAR 0 22
109922: PUSH
109923: LD_VAR 0 6
109927: PUSH
109928: LD_INT 6
109930: ARRAY
109931: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
109932: LD_ADDR_VAR 0 23
109936: PUSH
109937: LD_VAR 0 6
109941: PUSH
109942: LD_INT 7
109944: ARRAY
109945: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
109946: LD_ADDR_VAR 0 24
109950: PUSH
109951: LD_VAR 0 6
109955: PUSH
109956: LD_INT 8
109958: ARRAY
109959: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
109960: LD_ADDR_VAR 0 25
109964: PUSH
109965: LD_VAR 0 6
109969: PUSH
109970: LD_INT 9
109972: ARRAY
109973: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
109974: LD_ADDR_VAR 0 26
109978: PUSH
109979: LD_VAR 0 6
109983: PUSH
109984: LD_INT 10
109986: ARRAY
109987: ST_TO_ADDR
// end else
109988: GO 110070
// begin f_ignore_area := false ;
109990: LD_ADDR_VAR 0 17
109994: PUSH
109995: LD_INT 0
109997: ST_TO_ADDR
// f_capture := false ;
109998: LD_ADDR_VAR 0 18
110002: PUSH
110003: LD_INT 0
110005: ST_TO_ADDR
// f_ignore_civ := false ;
110006: LD_ADDR_VAR 0 19
110010: PUSH
110011: LD_INT 0
110013: ST_TO_ADDR
// f_murder := false ;
110014: LD_ADDR_VAR 0 20
110018: PUSH
110019: LD_INT 0
110021: ST_TO_ADDR
// f_mines := false ;
110022: LD_ADDR_VAR 0 21
110026: PUSH
110027: LD_INT 0
110029: ST_TO_ADDR
// f_repair := false ;
110030: LD_ADDR_VAR 0 22
110034: PUSH
110035: LD_INT 0
110037: ST_TO_ADDR
// f_heal := false ;
110038: LD_ADDR_VAR 0 23
110042: PUSH
110043: LD_INT 0
110045: ST_TO_ADDR
// f_spacetime := false ;
110046: LD_ADDR_VAR 0 24
110050: PUSH
110051: LD_INT 0
110053: ST_TO_ADDR
// f_attack_depot := false ;
110054: LD_ADDR_VAR 0 25
110058: PUSH
110059: LD_INT 0
110061: ST_TO_ADDR
// f_crawl := false ;
110062: LD_ADDR_VAR 0 26
110066: PUSH
110067: LD_INT 0
110069: ST_TO_ADDR
// end ; if f_heal then
110070: LD_VAR 0 23
110074: IFFALSE 110101
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110076: LD_ADDR_VAR 0 31
110080: PUSH
110081: LD_VAR 0 4
110085: PPUSH
110086: LD_INT 25
110088: PUSH
110089: LD_INT 4
110091: PUSH
110092: EMPTY
110093: LIST
110094: LIST
110095: PPUSH
110096: CALL_OW 72
110100: ST_TO_ADDR
// if f_repair then
110101: LD_VAR 0 22
110105: IFFALSE 110132
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110107: LD_ADDR_VAR 0 33
110111: PUSH
110112: LD_VAR 0 4
110116: PPUSH
110117: LD_INT 25
110119: PUSH
110120: LD_INT 3
110122: PUSH
110123: EMPTY
110124: LIST
110125: LIST
110126: PPUSH
110127: CALL_OW 72
110131: ST_TO_ADDR
// units_path := [ ] ;
110132: LD_ADDR_VAR 0 16
110136: PUSH
110137: EMPTY
110138: ST_TO_ADDR
// for i = 1 to group do
110139: LD_ADDR_VAR 0 7
110143: PUSH
110144: DOUBLE
110145: LD_INT 1
110147: DEC
110148: ST_TO_ADDR
110149: LD_VAR 0 4
110153: PUSH
110154: FOR_TO
110155: IFFALSE 110184
// units_path := Replace ( units_path , i , path ) ;
110157: LD_ADDR_VAR 0 16
110161: PUSH
110162: LD_VAR 0 16
110166: PPUSH
110167: LD_VAR 0 7
110171: PPUSH
110172: LD_VAR 0 5
110176: PPUSH
110177: CALL_OW 1
110181: ST_TO_ADDR
110182: GO 110154
110184: POP
110185: POP
// repeat for i = group downto 1 do
110186: LD_ADDR_VAR 0 7
110190: PUSH
110191: DOUBLE
110192: LD_VAR 0 4
110196: INC
110197: ST_TO_ADDR
110198: LD_INT 1
110200: PUSH
110201: FOR_DOWNTO
110202: IFFALSE 114324
// begin wait ( 5 ) ;
110204: LD_INT 5
110206: PPUSH
110207: CALL_OW 67
// tmp := [ ] ;
110211: LD_ADDR_VAR 0 14
110215: PUSH
110216: EMPTY
110217: ST_TO_ADDR
// attacking := false ;
110218: LD_ADDR_VAR 0 29
110222: PUSH
110223: LD_INT 0
110225: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110226: LD_VAR 0 4
110230: PUSH
110231: LD_VAR 0 7
110235: ARRAY
110236: PPUSH
110237: CALL_OW 301
110241: PUSH
110242: LD_VAR 0 4
110246: PUSH
110247: LD_VAR 0 7
110251: ARRAY
110252: NOT
110253: OR
110254: IFFALSE 110363
// begin if GetType ( group [ i ] ) = unit_human then
110256: LD_VAR 0 4
110260: PUSH
110261: LD_VAR 0 7
110265: ARRAY
110266: PPUSH
110267: CALL_OW 247
110271: PUSH
110272: LD_INT 1
110274: EQUAL
110275: IFFALSE 110321
// begin to_heal := to_heal diff group [ i ] ;
110277: LD_ADDR_VAR 0 30
110281: PUSH
110282: LD_VAR 0 30
110286: PUSH
110287: LD_VAR 0 4
110291: PUSH
110292: LD_VAR 0 7
110296: ARRAY
110297: DIFF
110298: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110299: LD_ADDR_VAR 0 31
110303: PUSH
110304: LD_VAR 0 31
110308: PUSH
110309: LD_VAR 0 4
110313: PUSH
110314: LD_VAR 0 7
110318: ARRAY
110319: DIFF
110320: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110321: LD_ADDR_VAR 0 4
110325: PUSH
110326: LD_VAR 0 4
110330: PPUSH
110331: LD_VAR 0 7
110335: PPUSH
110336: CALL_OW 3
110340: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110341: LD_ADDR_VAR 0 16
110345: PUSH
110346: LD_VAR 0 16
110350: PPUSH
110351: LD_VAR 0 7
110355: PPUSH
110356: CALL_OW 3
110360: ST_TO_ADDR
// continue ;
110361: GO 110201
// end ; if f_repair then
110363: LD_VAR 0 22
110367: IFFALSE 110856
// begin if GetType ( group [ i ] ) = unit_vehicle then
110369: LD_VAR 0 4
110373: PUSH
110374: LD_VAR 0 7
110378: ARRAY
110379: PPUSH
110380: CALL_OW 247
110384: PUSH
110385: LD_INT 2
110387: EQUAL
110388: IFFALSE 110578
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110390: LD_VAR 0 4
110394: PUSH
110395: LD_VAR 0 7
110399: ARRAY
110400: PPUSH
110401: CALL_OW 256
110405: PUSH
110406: LD_INT 700
110408: LESS
110409: PUSH
110410: LD_VAR 0 4
110414: PUSH
110415: LD_VAR 0 7
110419: ARRAY
110420: PUSH
110421: LD_VAR 0 32
110425: IN
110426: NOT
110427: AND
110428: IFFALSE 110452
// to_repair := to_repair union group [ i ] ;
110430: LD_ADDR_VAR 0 32
110434: PUSH
110435: LD_VAR 0 32
110439: PUSH
110440: LD_VAR 0 4
110444: PUSH
110445: LD_VAR 0 7
110449: ARRAY
110450: UNION
110451: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110452: LD_VAR 0 4
110456: PUSH
110457: LD_VAR 0 7
110461: ARRAY
110462: PPUSH
110463: CALL_OW 256
110467: PUSH
110468: LD_INT 1000
110470: EQUAL
110471: PUSH
110472: LD_VAR 0 4
110476: PUSH
110477: LD_VAR 0 7
110481: ARRAY
110482: PUSH
110483: LD_VAR 0 32
110487: IN
110488: AND
110489: IFFALSE 110513
// to_repair := to_repair diff group [ i ] ;
110491: LD_ADDR_VAR 0 32
110495: PUSH
110496: LD_VAR 0 32
110500: PUSH
110501: LD_VAR 0 4
110505: PUSH
110506: LD_VAR 0 7
110510: ARRAY
110511: DIFF
110512: ST_TO_ADDR
// if group [ i ] in to_repair then
110513: LD_VAR 0 4
110517: PUSH
110518: LD_VAR 0 7
110522: ARRAY
110523: PUSH
110524: LD_VAR 0 32
110528: IN
110529: IFFALSE 110576
// begin if not IsInArea ( group [ i ] , f_repair ) then
110531: LD_VAR 0 4
110535: PUSH
110536: LD_VAR 0 7
110540: ARRAY
110541: PPUSH
110542: LD_VAR 0 22
110546: PPUSH
110547: CALL_OW 308
110551: NOT
110552: IFFALSE 110574
// ComMoveToArea ( group [ i ] , f_repair ) ;
110554: LD_VAR 0 4
110558: PUSH
110559: LD_VAR 0 7
110563: ARRAY
110564: PPUSH
110565: LD_VAR 0 22
110569: PPUSH
110570: CALL_OW 113
// continue ;
110574: GO 110201
// end ; end else
110576: GO 110856
// if group [ i ] in repairs then
110578: LD_VAR 0 4
110582: PUSH
110583: LD_VAR 0 7
110587: ARRAY
110588: PUSH
110589: LD_VAR 0 33
110593: IN
110594: IFFALSE 110856
// begin if IsInUnit ( group [ i ] ) then
110596: LD_VAR 0 4
110600: PUSH
110601: LD_VAR 0 7
110605: ARRAY
110606: PPUSH
110607: CALL_OW 310
110611: IFFALSE 110679
// begin z := IsInUnit ( group [ i ] ) ;
110613: LD_ADDR_VAR 0 13
110617: PUSH
110618: LD_VAR 0 4
110622: PUSH
110623: LD_VAR 0 7
110627: ARRAY
110628: PPUSH
110629: CALL_OW 310
110633: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110634: LD_VAR 0 13
110638: PUSH
110639: LD_VAR 0 32
110643: IN
110644: PUSH
110645: LD_VAR 0 13
110649: PPUSH
110650: LD_VAR 0 22
110654: PPUSH
110655: CALL_OW 308
110659: AND
110660: IFFALSE 110677
// ComExitVehicle ( group [ i ] ) ;
110662: LD_VAR 0 4
110666: PUSH
110667: LD_VAR 0 7
110671: ARRAY
110672: PPUSH
110673: CALL_OW 121
// end else
110677: GO 110856
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110679: LD_ADDR_VAR 0 13
110683: PUSH
110684: LD_VAR 0 4
110688: PPUSH
110689: LD_INT 95
110691: PUSH
110692: LD_VAR 0 22
110696: PUSH
110697: EMPTY
110698: LIST
110699: LIST
110700: PUSH
110701: LD_INT 58
110703: PUSH
110704: EMPTY
110705: LIST
110706: PUSH
110707: EMPTY
110708: LIST
110709: LIST
110710: PPUSH
110711: CALL_OW 72
110715: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
110716: LD_VAR 0 4
110720: PUSH
110721: LD_VAR 0 7
110725: ARRAY
110726: PPUSH
110727: CALL_OW 314
110731: NOT
110732: IFFALSE 110854
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
110734: LD_ADDR_VAR 0 10
110738: PUSH
110739: LD_VAR 0 13
110743: PPUSH
110744: LD_VAR 0 4
110748: PUSH
110749: LD_VAR 0 7
110753: ARRAY
110754: PPUSH
110755: CALL_OW 74
110759: ST_TO_ADDR
// if not x then
110760: LD_VAR 0 10
110764: NOT
110765: IFFALSE 110769
// continue ;
110767: GO 110201
// if GetLives ( x ) < 1000 then
110769: LD_VAR 0 10
110773: PPUSH
110774: CALL_OW 256
110778: PUSH
110779: LD_INT 1000
110781: LESS
110782: IFFALSE 110806
// ComRepairVehicle ( group [ i ] , x ) else
110784: LD_VAR 0 4
110788: PUSH
110789: LD_VAR 0 7
110793: ARRAY
110794: PPUSH
110795: LD_VAR 0 10
110799: PPUSH
110800: CALL_OW 129
110804: GO 110854
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
110806: LD_VAR 0 23
110810: PUSH
110811: LD_VAR 0 4
110815: PUSH
110816: LD_VAR 0 7
110820: ARRAY
110821: PPUSH
110822: CALL_OW 256
110826: PUSH
110827: LD_INT 1000
110829: LESS
110830: AND
110831: NOT
110832: IFFALSE 110854
// ComEnterUnit ( group [ i ] , x ) ;
110834: LD_VAR 0 4
110838: PUSH
110839: LD_VAR 0 7
110843: ARRAY
110844: PPUSH
110845: LD_VAR 0 10
110849: PPUSH
110850: CALL_OW 120
// end ; continue ;
110854: GO 110201
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
110856: LD_VAR 0 23
110860: PUSH
110861: LD_VAR 0 4
110865: PUSH
110866: LD_VAR 0 7
110870: ARRAY
110871: PPUSH
110872: CALL_OW 247
110876: PUSH
110877: LD_INT 1
110879: EQUAL
110880: AND
110881: IFFALSE 111359
// begin if group [ i ] in healers then
110883: LD_VAR 0 4
110887: PUSH
110888: LD_VAR 0 7
110892: ARRAY
110893: PUSH
110894: LD_VAR 0 31
110898: IN
110899: IFFALSE 111172
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
110901: LD_VAR 0 4
110905: PUSH
110906: LD_VAR 0 7
110910: ARRAY
110911: PPUSH
110912: LD_VAR 0 23
110916: PPUSH
110917: CALL_OW 308
110921: NOT
110922: PUSH
110923: LD_VAR 0 4
110927: PUSH
110928: LD_VAR 0 7
110932: ARRAY
110933: PPUSH
110934: CALL_OW 314
110938: NOT
110939: AND
110940: IFFALSE 110964
// ComMoveToArea ( group [ i ] , f_heal ) else
110942: LD_VAR 0 4
110946: PUSH
110947: LD_VAR 0 7
110951: ARRAY
110952: PPUSH
110953: LD_VAR 0 23
110957: PPUSH
110958: CALL_OW 113
110962: GO 111170
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
110964: LD_VAR 0 4
110968: PUSH
110969: LD_VAR 0 7
110973: ARRAY
110974: PPUSH
110975: CALL 83302 0 1
110979: PPUSH
110980: CALL_OW 256
110984: PUSH
110985: LD_INT 1000
110987: EQUAL
110988: IFFALSE 111007
// ComStop ( group [ i ] ) else
110990: LD_VAR 0 4
110994: PUSH
110995: LD_VAR 0 7
110999: ARRAY
111000: PPUSH
111001: CALL_OW 141
111005: GO 111170
// if not HasTask ( group [ i ] ) and to_heal then
111007: LD_VAR 0 4
111011: PUSH
111012: LD_VAR 0 7
111016: ARRAY
111017: PPUSH
111018: CALL_OW 314
111022: NOT
111023: PUSH
111024: LD_VAR 0 30
111028: AND
111029: IFFALSE 111170
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111031: LD_ADDR_VAR 0 13
111035: PUSH
111036: LD_VAR 0 30
111040: PPUSH
111041: LD_INT 3
111043: PUSH
111044: LD_INT 54
111046: PUSH
111047: EMPTY
111048: LIST
111049: PUSH
111050: EMPTY
111051: LIST
111052: LIST
111053: PPUSH
111054: CALL_OW 72
111058: PPUSH
111059: LD_VAR 0 4
111063: PUSH
111064: LD_VAR 0 7
111068: ARRAY
111069: PPUSH
111070: CALL_OW 74
111074: ST_TO_ADDR
// if z then
111075: LD_VAR 0 13
111079: IFFALSE 111170
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111081: LD_INT 91
111083: PUSH
111084: LD_VAR 0 13
111088: PUSH
111089: LD_INT 10
111091: PUSH
111092: EMPTY
111093: LIST
111094: LIST
111095: LIST
111096: PUSH
111097: LD_INT 81
111099: PUSH
111100: LD_VAR 0 13
111104: PPUSH
111105: CALL_OW 255
111109: PUSH
111110: EMPTY
111111: LIST
111112: LIST
111113: PUSH
111114: EMPTY
111115: LIST
111116: LIST
111117: PPUSH
111118: CALL_OW 69
111122: PUSH
111123: LD_INT 0
111125: EQUAL
111126: IFFALSE 111150
// ComHeal ( group [ i ] , z ) else
111128: LD_VAR 0 4
111132: PUSH
111133: LD_VAR 0 7
111137: ARRAY
111138: PPUSH
111139: LD_VAR 0 13
111143: PPUSH
111144: CALL_OW 128
111148: GO 111170
// ComMoveToArea ( group [ i ] , f_heal ) ;
111150: LD_VAR 0 4
111154: PUSH
111155: LD_VAR 0 7
111159: ARRAY
111160: PPUSH
111161: LD_VAR 0 23
111165: PPUSH
111166: CALL_OW 113
// end ; continue ;
111170: GO 110201
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111172: LD_VAR 0 4
111176: PUSH
111177: LD_VAR 0 7
111181: ARRAY
111182: PPUSH
111183: CALL_OW 256
111187: PUSH
111188: LD_INT 700
111190: LESS
111191: PUSH
111192: LD_VAR 0 4
111196: PUSH
111197: LD_VAR 0 7
111201: ARRAY
111202: PUSH
111203: LD_VAR 0 30
111207: IN
111208: NOT
111209: AND
111210: IFFALSE 111234
// to_heal := to_heal union group [ i ] ;
111212: LD_ADDR_VAR 0 30
111216: PUSH
111217: LD_VAR 0 30
111221: PUSH
111222: LD_VAR 0 4
111226: PUSH
111227: LD_VAR 0 7
111231: ARRAY
111232: UNION
111233: ST_TO_ADDR
// if group [ i ] in to_heal then
111234: LD_VAR 0 4
111238: PUSH
111239: LD_VAR 0 7
111243: ARRAY
111244: PUSH
111245: LD_VAR 0 30
111249: IN
111250: IFFALSE 111359
// begin if GetLives ( group [ i ] ) = 1000 then
111252: LD_VAR 0 4
111256: PUSH
111257: LD_VAR 0 7
111261: ARRAY
111262: PPUSH
111263: CALL_OW 256
111267: PUSH
111268: LD_INT 1000
111270: EQUAL
111271: IFFALSE 111297
// to_heal := to_heal diff group [ i ] else
111273: LD_ADDR_VAR 0 30
111277: PUSH
111278: LD_VAR 0 30
111282: PUSH
111283: LD_VAR 0 4
111287: PUSH
111288: LD_VAR 0 7
111292: ARRAY
111293: DIFF
111294: ST_TO_ADDR
111295: GO 111359
// begin if not IsInArea ( group [ i ] , to_heal ) then
111297: LD_VAR 0 4
111301: PUSH
111302: LD_VAR 0 7
111306: ARRAY
111307: PPUSH
111308: LD_VAR 0 30
111312: PPUSH
111313: CALL_OW 308
111317: NOT
111318: IFFALSE 111342
// ComMoveToArea ( group [ i ] , f_heal ) else
111320: LD_VAR 0 4
111324: PUSH
111325: LD_VAR 0 7
111329: ARRAY
111330: PPUSH
111331: LD_VAR 0 23
111335: PPUSH
111336: CALL_OW 113
111340: GO 111357
// ComHold ( group [ i ] ) ;
111342: LD_VAR 0 4
111346: PUSH
111347: LD_VAR 0 7
111351: ARRAY
111352: PPUSH
111353: CALL_OW 140
// continue ;
111357: GO 110201
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111359: LD_VAR 0 4
111363: PUSH
111364: LD_VAR 0 7
111368: ARRAY
111369: PPUSH
111370: LD_INT 10
111372: PPUSH
111373: CALL 81172 0 2
111377: NOT
111378: PUSH
111379: LD_VAR 0 16
111383: PUSH
111384: LD_VAR 0 7
111388: ARRAY
111389: PUSH
111390: EMPTY
111391: EQUAL
111392: NOT
111393: AND
111394: IFFALSE 111660
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111396: LD_VAR 0 4
111400: PUSH
111401: LD_VAR 0 7
111405: ARRAY
111406: PPUSH
111407: CALL_OW 262
111411: PUSH
111412: LD_INT 1
111414: PUSH
111415: LD_INT 2
111417: PUSH
111418: EMPTY
111419: LIST
111420: LIST
111421: IN
111422: IFFALSE 111463
// if GetFuel ( group [ i ] ) < 10 then
111424: LD_VAR 0 4
111428: PUSH
111429: LD_VAR 0 7
111433: ARRAY
111434: PPUSH
111435: CALL_OW 261
111439: PUSH
111440: LD_INT 10
111442: LESS
111443: IFFALSE 111463
// SetFuel ( group [ i ] , 12 ) ;
111445: LD_VAR 0 4
111449: PUSH
111450: LD_VAR 0 7
111454: ARRAY
111455: PPUSH
111456: LD_INT 12
111458: PPUSH
111459: CALL_OW 240
// if units_path [ i ] then
111463: LD_VAR 0 16
111467: PUSH
111468: LD_VAR 0 7
111472: ARRAY
111473: IFFALSE 111658
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111475: LD_VAR 0 4
111479: PUSH
111480: LD_VAR 0 7
111484: ARRAY
111485: PPUSH
111486: LD_VAR 0 16
111490: PUSH
111491: LD_VAR 0 7
111495: ARRAY
111496: PUSH
111497: LD_INT 1
111499: ARRAY
111500: PUSH
111501: LD_INT 1
111503: ARRAY
111504: PPUSH
111505: LD_VAR 0 16
111509: PUSH
111510: LD_VAR 0 7
111514: ARRAY
111515: PUSH
111516: LD_INT 1
111518: ARRAY
111519: PUSH
111520: LD_INT 2
111522: ARRAY
111523: PPUSH
111524: CALL_OW 297
111528: PUSH
111529: LD_INT 6
111531: GREATER
111532: IFFALSE 111607
// begin if not HasTask ( group [ i ] ) then
111534: LD_VAR 0 4
111538: PUSH
111539: LD_VAR 0 7
111543: ARRAY
111544: PPUSH
111545: CALL_OW 314
111549: NOT
111550: IFFALSE 111605
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111552: LD_VAR 0 4
111556: PUSH
111557: LD_VAR 0 7
111561: ARRAY
111562: PPUSH
111563: LD_VAR 0 16
111567: PUSH
111568: LD_VAR 0 7
111572: ARRAY
111573: PUSH
111574: LD_INT 1
111576: ARRAY
111577: PUSH
111578: LD_INT 1
111580: ARRAY
111581: PPUSH
111582: LD_VAR 0 16
111586: PUSH
111587: LD_VAR 0 7
111591: ARRAY
111592: PUSH
111593: LD_INT 1
111595: ARRAY
111596: PUSH
111597: LD_INT 2
111599: ARRAY
111600: PPUSH
111601: CALL_OW 114
// end else
111605: GO 111658
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111607: LD_ADDR_VAR 0 15
111611: PUSH
111612: LD_VAR 0 16
111616: PUSH
111617: LD_VAR 0 7
111621: ARRAY
111622: PPUSH
111623: LD_INT 1
111625: PPUSH
111626: CALL_OW 3
111630: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111631: LD_ADDR_VAR 0 16
111635: PUSH
111636: LD_VAR 0 16
111640: PPUSH
111641: LD_VAR 0 7
111645: PPUSH
111646: LD_VAR 0 15
111650: PPUSH
111651: CALL_OW 1
111655: ST_TO_ADDR
// continue ;
111656: GO 110201
// end ; end ; end else
111658: GO 114322
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111660: LD_ADDR_VAR 0 14
111664: PUSH
111665: LD_INT 81
111667: PUSH
111668: LD_VAR 0 4
111672: PUSH
111673: LD_VAR 0 7
111677: ARRAY
111678: PPUSH
111679: CALL_OW 255
111683: PUSH
111684: EMPTY
111685: LIST
111686: LIST
111687: PPUSH
111688: CALL_OW 69
111692: ST_TO_ADDR
// if not tmp then
111693: LD_VAR 0 14
111697: NOT
111698: IFFALSE 111702
// continue ;
111700: GO 110201
// if f_ignore_area then
111702: LD_VAR 0 17
111706: IFFALSE 111794
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
111708: LD_ADDR_VAR 0 15
111712: PUSH
111713: LD_VAR 0 14
111717: PPUSH
111718: LD_INT 3
111720: PUSH
111721: LD_INT 92
111723: PUSH
111724: LD_VAR 0 17
111728: PUSH
111729: LD_INT 1
111731: ARRAY
111732: PUSH
111733: LD_VAR 0 17
111737: PUSH
111738: LD_INT 2
111740: ARRAY
111741: PUSH
111742: LD_VAR 0 17
111746: PUSH
111747: LD_INT 3
111749: ARRAY
111750: PUSH
111751: EMPTY
111752: LIST
111753: LIST
111754: LIST
111755: LIST
111756: PUSH
111757: EMPTY
111758: LIST
111759: LIST
111760: PPUSH
111761: CALL_OW 72
111765: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111766: LD_VAR 0 14
111770: PUSH
111771: LD_VAR 0 15
111775: DIFF
111776: IFFALSE 111794
// tmp := tmp diff tmp2 ;
111778: LD_ADDR_VAR 0 14
111782: PUSH
111783: LD_VAR 0 14
111787: PUSH
111788: LD_VAR 0 15
111792: DIFF
111793: ST_TO_ADDR
// end ; if not f_murder then
111794: LD_VAR 0 20
111798: NOT
111799: IFFALSE 111857
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
111801: LD_ADDR_VAR 0 15
111805: PUSH
111806: LD_VAR 0 14
111810: PPUSH
111811: LD_INT 3
111813: PUSH
111814: LD_INT 50
111816: PUSH
111817: EMPTY
111818: LIST
111819: PUSH
111820: EMPTY
111821: LIST
111822: LIST
111823: PPUSH
111824: CALL_OW 72
111828: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111829: LD_VAR 0 14
111833: PUSH
111834: LD_VAR 0 15
111838: DIFF
111839: IFFALSE 111857
// tmp := tmp diff tmp2 ;
111841: LD_ADDR_VAR 0 14
111845: PUSH
111846: LD_VAR 0 14
111850: PUSH
111851: LD_VAR 0 15
111855: DIFF
111856: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
111857: LD_ADDR_VAR 0 14
111861: PUSH
111862: LD_VAR 0 4
111866: PUSH
111867: LD_VAR 0 7
111871: ARRAY
111872: PPUSH
111873: LD_VAR 0 14
111877: PPUSH
111878: LD_INT 1
111880: PPUSH
111881: LD_INT 1
111883: PPUSH
111884: CALL 54113 0 4
111888: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
111889: LD_VAR 0 4
111893: PUSH
111894: LD_VAR 0 7
111898: ARRAY
111899: PPUSH
111900: CALL_OW 257
111904: PUSH
111905: LD_INT 1
111907: EQUAL
111908: IFFALSE 112356
// begin if WantPlant ( group [ i ] ) then
111910: LD_VAR 0 4
111914: PUSH
111915: LD_VAR 0 7
111919: ARRAY
111920: PPUSH
111921: CALL 53614 0 1
111925: IFFALSE 111929
// continue ;
111927: GO 110201
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
111929: LD_VAR 0 18
111933: PUSH
111934: LD_VAR 0 4
111938: PUSH
111939: LD_VAR 0 7
111943: ARRAY
111944: PPUSH
111945: CALL_OW 310
111949: NOT
111950: AND
111951: PUSH
111952: LD_VAR 0 14
111956: PUSH
111957: LD_INT 1
111959: ARRAY
111960: PUSH
111961: LD_VAR 0 14
111965: PPUSH
111966: LD_INT 21
111968: PUSH
111969: LD_INT 2
111971: PUSH
111972: EMPTY
111973: LIST
111974: LIST
111975: PUSH
111976: LD_INT 58
111978: PUSH
111979: EMPTY
111980: LIST
111981: PUSH
111982: EMPTY
111983: LIST
111984: LIST
111985: PPUSH
111986: CALL_OW 72
111990: IN
111991: AND
111992: IFFALSE 112028
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
111994: LD_VAR 0 4
111998: PUSH
111999: LD_VAR 0 7
112003: ARRAY
112004: PPUSH
112005: LD_VAR 0 14
112009: PUSH
112010: LD_INT 1
112012: ARRAY
112013: PPUSH
112014: CALL_OW 120
// attacking := true ;
112018: LD_ADDR_VAR 0 29
112022: PUSH
112023: LD_INT 1
112025: ST_TO_ADDR
// continue ;
112026: GO 110201
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112028: LD_VAR 0 26
112032: PUSH
112033: LD_VAR 0 4
112037: PUSH
112038: LD_VAR 0 7
112042: ARRAY
112043: PPUSH
112044: CALL_OW 257
112048: PUSH
112049: LD_INT 1
112051: EQUAL
112052: AND
112053: PUSH
112054: LD_VAR 0 4
112058: PUSH
112059: LD_VAR 0 7
112063: ARRAY
112064: PPUSH
112065: CALL_OW 256
112069: PUSH
112070: LD_INT 800
112072: LESS
112073: AND
112074: PUSH
112075: LD_VAR 0 4
112079: PUSH
112080: LD_VAR 0 7
112084: ARRAY
112085: PPUSH
112086: CALL_OW 318
112090: NOT
112091: AND
112092: IFFALSE 112109
// ComCrawl ( group [ i ] ) ;
112094: LD_VAR 0 4
112098: PUSH
112099: LD_VAR 0 7
112103: ARRAY
112104: PPUSH
112105: CALL_OW 137
// if f_mines then
112109: LD_VAR 0 21
112113: IFFALSE 112356
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112115: LD_VAR 0 14
112119: PUSH
112120: LD_INT 1
112122: ARRAY
112123: PPUSH
112124: CALL_OW 247
112128: PUSH
112129: LD_INT 3
112131: EQUAL
112132: PUSH
112133: LD_VAR 0 14
112137: PUSH
112138: LD_INT 1
112140: ARRAY
112141: PUSH
112142: LD_VAR 0 27
112146: IN
112147: NOT
112148: AND
112149: IFFALSE 112356
// begin x := GetX ( tmp [ 1 ] ) ;
112151: LD_ADDR_VAR 0 10
112155: PUSH
112156: LD_VAR 0 14
112160: PUSH
112161: LD_INT 1
112163: ARRAY
112164: PPUSH
112165: CALL_OW 250
112169: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112170: LD_ADDR_VAR 0 11
112174: PUSH
112175: LD_VAR 0 14
112179: PUSH
112180: LD_INT 1
112182: ARRAY
112183: PPUSH
112184: CALL_OW 251
112188: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112189: LD_ADDR_VAR 0 12
112193: PUSH
112194: LD_VAR 0 4
112198: PUSH
112199: LD_VAR 0 7
112203: ARRAY
112204: PPUSH
112205: CALL 81257 0 1
112209: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112210: LD_VAR 0 4
112214: PUSH
112215: LD_VAR 0 7
112219: ARRAY
112220: PPUSH
112221: LD_VAR 0 10
112225: PPUSH
112226: LD_VAR 0 11
112230: PPUSH
112231: LD_VAR 0 14
112235: PUSH
112236: LD_INT 1
112238: ARRAY
112239: PPUSH
112240: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112244: LD_VAR 0 4
112248: PUSH
112249: LD_VAR 0 7
112253: ARRAY
112254: PPUSH
112255: LD_VAR 0 10
112259: PPUSH
112260: LD_VAR 0 12
112264: PPUSH
112265: LD_INT 7
112267: PPUSH
112268: CALL_OW 272
112272: PPUSH
112273: LD_VAR 0 11
112277: PPUSH
112278: LD_VAR 0 12
112282: PPUSH
112283: LD_INT 7
112285: PPUSH
112286: CALL_OW 273
112290: PPUSH
112291: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112295: LD_VAR 0 4
112299: PUSH
112300: LD_VAR 0 7
112304: ARRAY
112305: PPUSH
112306: LD_INT 71
112308: PPUSH
112309: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112313: LD_ADDR_VAR 0 27
112317: PUSH
112318: LD_VAR 0 27
112322: PPUSH
112323: LD_VAR 0 27
112327: PUSH
112328: LD_INT 1
112330: PLUS
112331: PPUSH
112332: LD_VAR 0 14
112336: PUSH
112337: LD_INT 1
112339: ARRAY
112340: PPUSH
112341: CALL_OW 1
112345: ST_TO_ADDR
// attacking := true ;
112346: LD_ADDR_VAR 0 29
112350: PUSH
112351: LD_INT 1
112353: ST_TO_ADDR
// continue ;
112354: GO 110201
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112356: LD_VAR 0 4
112360: PUSH
112361: LD_VAR 0 7
112365: ARRAY
112366: PPUSH
112367: CALL_OW 257
112371: PUSH
112372: LD_INT 17
112374: EQUAL
112375: PUSH
112376: LD_VAR 0 4
112380: PUSH
112381: LD_VAR 0 7
112385: ARRAY
112386: PPUSH
112387: CALL_OW 110
112391: PUSH
112392: LD_INT 71
112394: EQUAL
112395: NOT
112396: AND
112397: IFFALSE 112543
// begin attacking := false ;
112399: LD_ADDR_VAR 0 29
112403: PUSH
112404: LD_INT 0
112406: ST_TO_ADDR
// k := 5 ;
112407: LD_ADDR_VAR 0 9
112411: PUSH
112412: LD_INT 5
112414: ST_TO_ADDR
// if tmp < k then
112415: LD_VAR 0 14
112419: PUSH
112420: LD_VAR 0 9
112424: LESS
112425: IFFALSE 112437
// k := tmp ;
112427: LD_ADDR_VAR 0 9
112431: PUSH
112432: LD_VAR 0 14
112436: ST_TO_ADDR
// for j = 1 to k do
112437: LD_ADDR_VAR 0 8
112441: PUSH
112442: DOUBLE
112443: LD_INT 1
112445: DEC
112446: ST_TO_ADDR
112447: LD_VAR 0 9
112451: PUSH
112452: FOR_TO
112453: IFFALSE 112541
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112455: LD_VAR 0 14
112459: PUSH
112460: LD_VAR 0 8
112464: ARRAY
112465: PUSH
112466: LD_VAR 0 14
112470: PPUSH
112471: LD_INT 58
112473: PUSH
112474: EMPTY
112475: LIST
112476: PPUSH
112477: CALL_OW 72
112481: IN
112482: NOT
112483: IFFALSE 112539
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112485: LD_VAR 0 4
112489: PUSH
112490: LD_VAR 0 7
112494: ARRAY
112495: PPUSH
112496: LD_VAR 0 14
112500: PUSH
112501: LD_VAR 0 8
112505: ARRAY
112506: PPUSH
112507: CALL_OW 115
// attacking := true ;
112511: LD_ADDR_VAR 0 29
112515: PUSH
112516: LD_INT 1
112518: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112519: LD_VAR 0 4
112523: PUSH
112524: LD_VAR 0 7
112528: ARRAY
112529: PPUSH
112530: LD_INT 71
112532: PPUSH
112533: CALL_OW 109
// continue ;
112537: GO 112452
// end ; end ;
112539: GO 112452
112541: POP
112542: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112543: LD_VAR 0 4
112547: PUSH
112548: LD_VAR 0 7
112552: ARRAY
112553: PPUSH
112554: CALL_OW 257
112558: PUSH
112559: LD_INT 8
112561: EQUAL
112562: PUSH
112563: LD_VAR 0 4
112567: PUSH
112568: LD_VAR 0 7
112572: ARRAY
112573: PPUSH
112574: CALL_OW 264
112578: PUSH
112579: LD_INT 28
112581: PUSH
112582: LD_INT 45
112584: PUSH
112585: LD_INT 7
112587: PUSH
112588: LD_INT 47
112590: PUSH
112591: EMPTY
112592: LIST
112593: LIST
112594: LIST
112595: LIST
112596: IN
112597: OR
112598: IFFALSE 112854
// begin attacking := false ;
112600: LD_ADDR_VAR 0 29
112604: PUSH
112605: LD_INT 0
112607: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112608: LD_VAR 0 14
112612: PUSH
112613: LD_INT 1
112615: ARRAY
112616: PPUSH
112617: CALL_OW 266
112621: PUSH
112622: LD_INT 32
112624: PUSH
112625: LD_INT 31
112627: PUSH
112628: LD_INT 33
112630: PUSH
112631: LD_INT 4
112633: PUSH
112634: LD_INT 5
112636: PUSH
112637: EMPTY
112638: LIST
112639: LIST
112640: LIST
112641: LIST
112642: LIST
112643: IN
112644: IFFALSE 112830
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112646: LD_ADDR_VAR 0 9
112650: PUSH
112651: LD_VAR 0 14
112655: PUSH
112656: LD_INT 1
112658: ARRAY
112659: PPUSH
112660: CALL_OW 266
112664: PPUSH
112665: LD_VAR 0 14
112669: PUSH
112670: LD_INT 1
112672: ARRAY
112673: PPUSH
112674: CALL_OW 250
112678: PPUSH
112679: LD_VAR 0 14
112683: PUSH
112684: LD_INT 1
112686: ARRAY
112687: PPUSH
112688: CALL_OW 251
112692: PPUSH
112693: LD_VAR 0 14
112697: PUSH
112698: LD_INT 1
112700: ARRAY
112701: PPUSH
112702: CALL_OW 254
112706: PPUSH
112707: LD_VAR 0 14
112711: PUSH
112712: LD_INT 1
112714: ARRAY
112715: PPUSH
112716: CALL_OW 248
112720: PPUSH
112721: LD_INT 0
112723: PPUSH
112724: CALL 62627 0 6
112728: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
112729: LD_ADDR_VAR 0 8
112733: PUSH
112734: LD_VAR 0 4
112738: PUSH
112739: LD_VAR 0 7
112743: ARRAY
112744: PPUSH
112745: LD_VAR 0 9
112749: PPUSH
112750: CALL 81297 0 2
112754: ST_TO_ADDR
// if j then
112755: LD_VAR 0 8
112759: IFFALSE 112828
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
112761: LD_VAR 0 8
112765: PUSH
112766: LD_INT 1
112768: ARRAY
112769: PPUSH
112770: LD_VAR 0 8
112774: PUSH
112775: LD_INT 2
112777: ARRAY
112778: PPUSH
112779: CALL_OW 488
112783: IFFALSE 112828
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
112785: LD_VAR 0 4
112789: PUSH
112790: LD_VAR 0 7
112794: ARRAY
112795: PPUSH
112796: LD_VAR 0 8
112800: PUSH
112801: LD_INT 1
112803: ARRAY
112804: PPUSH
112805: LD_VAR 0 8
112809: PUSH
112810: LD_INT 2
112812: ARRAY
112813: PPUSH
112814: CALL_OW 116
// attacking := true ;
112818: LD_ADDR_VAR 0 29
112822: PUSH
112823: LD_INT 1
112825: ST_TO_ADDR
// continue ;
112826: GO 110201
// end ; end else
112828: GO 112854
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112830: LD_VAR 0 4
112834: PUSH
112835: LD_VAR 0 7
112839: ARRAY
112840: PPUSH
112841: LD_VAR 0 14
112845: PUSH
112846: LD_INT 1
112848: ARRAY
112849: PPUSH
112850: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
112854: LD_VAR 0 4
112858: PUSH
112859: LD_VAR 0 7
112863: ARRAY
112864: PPUSH
112865: CALL_OW 265
112869: PUSH
112870: LD_INT 11
112872: EQUAL
112873: IFFALSE 113151
// begin k := 10 ;
112875: LD_ADDR_VAR 0 9
112879: PUSH
112880: LD_INT 10
112882: ST_TO_ADDR
// x := 0 ;
112883: LD_ADDR_VAR 0 10
112887: PUSH
112888: LD_INT 0
112890: ST_TO_ADDR
// if tmp < k then
112891: LD_VAR 0 14
112895: PUSH
112896: LD_VAR 0 9
112900: LESS
112901: IFFALSE 112913
// k := tmp ;
112903: LD_ADDR_VAR 0 9
112907: PUSH
112908: LD_VAR 0 14
112912: ST_TO_ADDR
// for j = k downto 1 do
112913: LD_ADDR_VAR 0 8
112917: PUSH
112918: DOUBLE
112919: LD_VAR 0 9
112923: INC
112924: ST_TO_ADDR
112925: LD_INT 1
112927: PUSH
112928: FOR_DOWNTO
112929: IFFALSE 113004
// begin if GetType ( tmp [ j ] ) = unit_human then
112931: LD_VAR 0 14
112935: PUSH
112936: LD_VAR 0 8
112940: ARRAY
112941: PPUSH
112942: CALL_OW 247
112946: PUSH
112947: LD_INT 1
112949: EQUAL
112950: IFFALSE 113002
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
112952: LD_VAR 0 4
112956: PUSH
112957: LD_VAR 0 7
112961: ARRAY
112962: PPUSH
112963: LD_VAR 0 14
112967: PUSH
112968: LD_VAR 0 8
112972: ARRAY
112973: PPUSH
112974: CALL 81551 0 2
// x := tmp [ j ] ;
112978: LD_ADDR_VAR 0 10
112982: PUSH
112983: LD_VAR 0 14
112987: PUSH
112988: LD_VAR 0 8
112992: ARRAY
112993: ST_TO_ADDR
// attacking := true ;
112994: LD_ADDR_VAR 0 29
112998: PUSH
112999: LD_INT 1
113001: ST_TO_ADDR
// end ; end ;
113002: GO 112928
113004: POP
113005: POP
// if not x then
113006: LD_VAR 0 10
113010: NOT
113011: IFFALSE 113151
// begin attacking := true ;
113013: LD_ADDR_VAR 0 29
113017: PUSH
113018: LD_INT 1
113020: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113021: LD_VAR 0 4
113025: PUSH
113026: LD_VAR 0 7
113030: ARRAY
113031: PPUSH
113032: CALL_OW 250
113036: PPUSH
113037: LD_VAR 0 4
113041: PUSH
113042: LD_VAR 0 7
113046: ARRAY
113047: PPUSH
113048: CALL_OW 251
113052: PPUSH
113053: CALL_OW 546
113057: PUSH
113058: LD_INT 2
113060: ARRAY
113061: PUSH
113062: LD_VAR 0 14
113066: PUSH
113067: LD_INT 1
113069: ARRAY
113070: PPUSH
113071: CALL_OW 250
113075: PPUSH
113076: LD_VAR 0 14
113080: PUSH
113081: LD_INT 1
113083: ARRAY
113084: PPUSH
113085: CALL_OW 251
113089: PPUSH
113090: CALL_OW 546
113094: PUSH
113095: LD_INT 2
113097: ARRAY
113098: EQUAL
113099: IFFALSE 113127
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113101: LD_VAR 0 4
113105: PUSH
113106: LD_VAR 0 7
113110: ARRAY
113111: PPUSH
113112: LD_VAR 0 14
113116: PUSH
113117: LD_INT 1
113119: ARRAY
113120: PPUSH
113121: CALL 81551 0 2
113125: GO 113151
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113127: LD_VAR 0 4
113131: PUSH
113132: LD_VAR 0 7
113136: ARRAY
113137: PPUSH
113138: LD_VAR 0 14
113142: PUSH
113143: LD_INT 1
113145: ARRAY
113146: PPUSH
113147: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113151: LD_VAR 0 4
113155: PUSH
113156: LD_VAR 0 7
113160: ARRAY
113161: PPUSH
113162: CALL_OW 264
113166: PUSH
113167: LD_INT 29
113169: EQUAL
113170: IFFALSE 113536
// begin if WantsToAttack ( group [ i ] ) in bombed then
113172: LD_VAR 0 4
113176: PUSH
113177: LD_VAR 0 7
113181: ARRAY
113182: PPUSH
113183: CALL_OW 319
113187: PUSH
113188: LD_VAR 0 28
113192: IN
113193: IFFALSE 113197
// continue ;
113195: GO 110201
// k := 8 ;
113197: LD_ADDR_VAR 0 9
113201: PUSH
113202: LD_INT 8
113204: ST_TO_ADDR
// x := 0 ;
113205: LD_ADDR_VAR 0 10
113209: PUSH
113210: LD_INT 0
113212: ST_TO_ADDR
// if tmp < k then
113213: LD_VAR 0 14
113217: PUSH
113218: LD_VAR 0 9
113222: LESS
113223: IFFALSE 113235
// k := tmp ;
113225: LD_ADDR_VAR 0 9
113229: PUSH
113230: LD_VAR 0 14
113234: ST_TO_ADDR
// for j = 1 to k do
113235: LD_ADDR_VAR 0 8
113239: PUSH
113240: DOUBLE
113241: LD_INT 1
113243: DEC
113244: ST_TO_ADDR
113245: LD_VAR 0 9
113249: PUSH
113250: FOR_TO
113251: IFFALSE 113383
// begin if GetType ( tmp [ j ] ) = unit_building then
113253: LD_VAR 0 14
113257: PUSH
113258: LD_VAR 0 8
113262: ARRAY
113263: PPUSH
113264: CALL_OW 247
113268: PUSH
113269: LD_INT 3
113271: EQUAL
113272: IFFALSE 113381
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113274: LD_VAR 0 14
113278: PUSH
113279: LD_VAR 0 8
113283: ARRAY
113284: PUSH
113285: LD_VAR 0 28
113289: IN
113290: NOT
113291: PUSH
113292: LD_VAR 0 14
113296: PUSH
113297: LD_VAR 0 8
113301: ARRAY
113302: PPUSH
113303: CALL_OW 313
113307: AND
113308: IFFALSE 113381
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113310: LD_VAR 0 4
113314: PUSH
113315: LD_VAR 0 7
113319: ARRAY
113320: PPUSH
113321: LD_VAR 0 14
113325: PUSH
113326: LD_VAR 0 8
113330: ARRAY
113331: PPUSH
113332: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113336: LD_ADDR_VAR 0 28
113340: PUSH
113341: LD_VAR 0 28
113345: PPUSH
113346: LD_VAR 0 28
113350: PUSH
113351: LD_INT 1
113353: PLUS
113354: PPUSH
113355: LD_VAR 0 14
113359: PUSH
113360: LD_VAR 0 8
113364: ARRAY
113365: PPUSH
113366: CALL_OW 1
113370: ST_TO_ADDR
// attacking := true ;
113371: LD_ADDR_VAR 0 29
113375: PUSH
113376: LD_INT 1
113378: ST_TO_ADDR
// break ;
113379: GO 113383
// end ; end ;
113381: GO 113250
113383: POP
113384: POP
// if not attacking and f_attack_depot then
113385: LD_VAR 0 29
113389: NOT
113390: PUSH
113391: LD_VAR 0 25
113395: AND
113396: IFFALSE 113491
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113398: LD_ADDR_VAR 0 13
113402: PUSH
113403: LD_VAR 0 14
113407: PPUSH
113408: LD_INT 2
113410: PUSH
113411: LD_INT 30
113413: PUSH
113414: LD_INT 0
113416: PUSH
113417: EMPTY
113418: LIST
113419: LIST
113420: PUSH
113421: LD_INT 30
113423: PUSH
113424: LD_INT 1
113426: PUSH
113427: EMPTY
113428: LIST
113429: LIST
113430: PUSH
113431: EMPTY
113432: LIST
113433: LIST
113434: LIST
113435: PPUSH
113436: CALL_OW 72
113440: ST_TO_ADDR
// if z then
113441: LD_VAR 0 13
113445: IFFALSE 113491
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113447: LD_VAR 0 4
113451: PUSH
113452: LD_VAR 0 7
113456: ARRAY
113457: PPUSH
113458: LD_VAR 0 13
113462: PPUSH
113463: LD_VAR 0 4
113467: PUSH
113468: LD_VAR 0 7
113472: ARRAY
113473: PPUSH
113474: CALL_OW 74
113478: PPUSH
113479: CALL_OW 115
// attacking := true ;
113483: LD_ADDR_VAR 0 29
113487: PUSH
113488: LD_INT 1
113490: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113491: LD_VAR 0 4
113495: PUSH
113496: LD_VAR 0 7
113500: ARRAY
113501: PPUSH
113502: CALL_OW 256
113506: PUSH
113507: LD_INT 500
113509: LESS
113510: IFFALSE 113536
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113512: LD_VAR 0 4
113516: PUSH
113517: LD_VAR 0 7
113521: ARRAY
113522: PPUSH
113523: LD_VAR 0 14
113527: PUSH
113528: LD_INT 1
113530: ARRAY
113531: PPUSH
113532: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113536: LD_VAR 0 4
113540: PUSH
113541: LD_VAR 0 7
113545: ARRAY
113546: PPUSH
113547: CALL_OW 264
113551: PUSH
113552: LD_INT 49
113554: EQUAL
113555: IFFALSE 113676
// begin if not HasTask ( group [ i ] ) then
113557: LD_VAR 0 4
113561: PUSH
113562: LD_VAR 0 7
113566: ARRAY
113567: PPUSH
113568: CALL_OW 314
113572: NOT
113573: IFFALSE 113676
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113575: LD_ADDR_VAR 0 9
113579: PUSH
113580: LD_INT 81
113582: PUSH
113583: LD_VAR 0 4
113587: PUSH
113588: LD_VAR 0 7
113592: ARRAY
113593: PPUSH
113594: CALL_OW 255
113598: PUSH
113599: EMPTY
113600: LIST
113601: LIST
113602: PPUSH
113603: CALL_OW 69
113607: PPUSH
113608: LD_VAR 0 4
113612: PUSH
113613: LD_VAR 0 7
113617: ARRAY
113618: PPUSH
113619: CALL_OW 74
113623: ST_TO_ADDR
// if k then
113624: LD_VAR 0 9
113628: IFFALSE 113676
// if GetDistUnits ( group [ i ] , k ) > 10 then
113630: LD_VAR 0 4
113634: PUSH
113635: LD_VAR 0 7
113639: ARRAY
113640: PPUSH
113641: LD_VAR 0 9
113645: PPUSH
113646: CALL_OW 296
113650: PUSH
113651: LD_INT 10
113653: GREATER
113654: IFFALSE 113676
// ComMoveUnit ( group [ i ] , k ) ;
113656: LD_VAR 0 4
113660: PUSH
113661: LD_VAR 0 7
113665: ARRAY
113666: PPUSH
113667: LD_VAR 0 9
113671: PPUSH
113672: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113676: LD_VAR 0 4
113680: PUSH
113681: LD_VAR 0 7
113685: ARRAY
113686: PPUSH
113687: CALL_OW 256
113691: PUSH
113692: LD_INT 250
113694: LESS
113695: PUSH
113696: LD_VAR 0 4
113700: PUSH
113701: LD_VAR 0 7
113705: ARRAY
113706: PUSH
113707: LD_INT 21
113709: PUSH
113710: LD_INT 2
113712: PUSH
113713: EMPTY
113714: LIST
113715: LIST
113716: PUSH
113717: LD_INT 23
113719: PUSH
113720: LD_INT 2
113722: PUSH
113723: EMPTY
113724: LIST
113725: LIST
113726: PUSH
113727: EMPTY
113728: LIST
113729: LIST
113730: PPUSH
113731: CALL_OW 69
113735: IN
113736: AND
113737: IFFALSE 113862
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
113739: LD_ADDR_VAR 0 9
113743: PUSH
113744: LD_OWVAR 3
113748: PUSH
113749: LD_VAR 0 4
113753: PUSH
113754: LD_VAR 0 7
113758: ARRAY
113759: DIFF
113760: PPUSH
113761: LD_VAR 0 4
113765: PUSH
113766: LD_VAR 0 7
113770: ARRAY
113771: PPUSH
113772: CALL_OW 74
113776: ST_TO_ADDR
// if not k then
113777: LD_VAR 0 9
113781: NOT
113782: IFFALSE 113786
// continue ;
113784: GO 110201
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
113786: LD_VAR 0 9
113790: PUSH
113791: LD_INT 81
113793: PUSH
113794: LD_VAR 0 4
113798: PUSH
113799: LD_VAR 0 7
113803: ARRAY
113804: PPUSH
113805: CALL_OW 255
113809: PUSH
113810: EMPTY
113811: LIST
113812: LIST
113813: PPUSH
113814: CALL_OW 69
113818: IN
113819: PUSH
113820: LD_VAR 0 9
113824: PPUSH
113825: LD_VAR 0 4
113829: PUSH
113830: LD_VAR 0 7
113834: ARRAY
113835: PPUSH
113836: CALL_OW 296
113840: PUSH
113841: LD_INT 5
113843: LESS
113844: AND
113845: IFFALSE 113862
// ComAutodestruct ( group [ i ] ) ;
113847: LD_VAR 0 4
113851: PUSH
113852: LD_VAR 0 7
113856: ARRAY
113857: PPUSH
113858: CALL 81449 0 1
// end ; if f_attack_depot then
113862: LD_VAR 0 25
113866: IFFALSE 113978
// begin k := 6 ;
113868: LD_ADDR_VAR 0 9
113872: PUSH
113873: LD_INT 6
113875: ST_TO_ADDR
// if tmp < k then
113876: LD_VAR 0 14
113880: PUSH
113881: LD_VAR 0 9
113885: LESS
113886: IFFALSE 113898
// k := tmp ;
113888: LD_ADDR_VAR 0 9
113892: PUSH
113893: LD_VAR 0 14
113897: ST_TO_ADDR
// for j = 1 to k do
113898: LD_ADDR_VAR 0 8
113902: PUSH
113903: DOUBLE
113904: LD_INT 1
113906: DEC
113907: ST_TO_ADDR
113908: LD_VAR 0 9
113912: PUSH
113913: FOR_TO
113914: IFFALSE 113976
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
113916: LD_VAR 0 8
113920: PPUSH
113921: CALL_OW 266
113925: PUSH
113926: LD_INT 0
113928: PUSH
113929: LD_INT 1
113931: PUSH
113932: EMPTY
113933: LIST
113934: LIST
113935: IN
113936: IFFALSE 113974
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113938: LD_VAR 0 4
113942: PUSH
113943: LD_VAR 0 7
113947: ARRAY
113948: PPUSH
113949: LD_VAR 0 14
113953: PUSH
113954: LD_VAR 0 8
113958: ARRAY
113959: PPUSH
113960: CALL_OW 115
// attacking := true ;
113964: LD_ADDR_VAR 0 29
113968: PUSH
113969: LD_INT 1
113971: ST_TO_ADDR
// break ;
113972: GO 113976
// end ;
113974: GO 113913
113976: POP
113977: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
113978: LD_VAR 0 4
113982: PUSH
113983: LD_VAR 0 7
113987: ARRAY
113988: PPUSH
113989: CALL_OW 302
113993: PUSH
113994: LD_VAR 0 29
113998: NOT
113999: AND
114000: IFFALSE 114322
// begin if GetTag ( group [ i ] ) = 71 then
114002: LD_VAR 0 4
114006: PUSH
114007: LD_VAR 0 7
114011: ARRAY
114012: PPUSH
114013: CALL_OW 110
114017: PUSH
114018: LD_INT 71
114020: EQUAL
114021: IFFALSE 114062
// begin if HasTask ( group [ i ] ) then
114023: LD_VAR 0 4
114027: PUSH
114028: LD_VAR 0 7
114032: ARRAY
114033: PPUSH
114034: CALL_OW 314
114038: IFFALSE 114044
// continue else
114040: GO 110201
114042: GO 114062
// SetTag ( group [ i ] , 0 ) ;
114044: LD_VAR 0 4
114048: PUSH
114049: LD_VAR 0 7
114053: ARRAY
114054: PPUSH
114055: LD_INT 0
114057: PPUSH
114058: CALL_OW 109
// end ; k := 8 ;
114062: LD_ADDR_VAR 0 9
114066: PUSH
114067: LD_INT 8
114069: ST_TO_ADDR
// x := 0 ;
114070: LD_ADDR_VAR 0 10
114074: PUSH
114075: LD_INT 0
114077: ST_TO_ADDR
// if tmp < k then
114078: LD_VAR 0 14
114082: PUSH
114083: LD_VAR 0 9
114087: LESS
114088: IFFALSE 114100
// k := tmp ;
114090: LD_ADDR_VAR 0 9
114094: PUSH
114095: LD_VAR 0 14
114099: ST_TO_ADDR
// for j = 1 to k do
114100: LD_ADDR_VAR 0 8
114104: PUSH
114105: DOUBLE
114106: LD_INT 1
114108: DEC
114109: ST_TO_ADDR
114110: LD_VAR 0 9
114114: PUSH
114115: FOR_TO
114116: IFFALSE 114214
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114118: LD_VAR 0 14
114122: PUSH
114123: LD_VAR 0 8
114127: ARRAY
114128: PPUSH
114129: CALL_OW 247
114133: PUSH
114134: LD_INT 1
114136: EQUAL
114137: PUSH
114138: LD_VAR 0 14
114142: PUSH
114143: LD_VAR 0 8
114147: ARRAY
114148: PPUSH
114149: CALL_OW 256
114153: PUSH
114154: LD_INT 250
114156: LESS
114157: PUSH
114158: LD_VAR 0 20
114162: AND
114163: PUSH
114164: LD_VAR 0 20
114168: NOT
114169: PUSH
114170: LD_VAR 0 14
114174: PUSH
114175: LD_VAR 0 8
114179: ARRAY
114180: PPUSH
114181: CALL_OW 256
114185: PUSH
114186: LD_INT 250
114188: GREATEREQUAL
114189: AND
114190: OR
114191: AND
114192: IFFALSE 114212
// begin x := tmp [ j ] ;
114194: LD_ADDR_VAR 0 10
114198: PUSH
114199: LD_VAR 0 14
114203: PUSH
114204: LD_VAR 0 8
114208: ARRAY
114209: ST_TO_ADDR
// break ;
114210: GO 114214
// end ;
114212: GO 114115
114214: POP
114215: POP
// if x then
114216: LD_VAR 0 10
114220: IFFALSE 114244
// ComAttackUnit ( group [ i ] , x ) else
114222: LD_VAR 0 4
114226: PUSH
114227: LD_VAR 0 7
114231: ARRAY
114232: PPUSH
114233: LD_VAR 0 10
114237: PPUSH
114238: CALL_OW 115
114242: GO 114268
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114244: LD_VAR 0 4
114248: PUSH
114249: LD_VAR 0 7
114253: ARRAY
114254: PPUSH
114255: LD_VAR 0 14
114259: PUSH
114260: LD_INT 1
114262: ARRAY
114263: PPUSH
114264: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114268: LD_VAR 0 4
114272: PUSH
114273: LD_VAR 0 7
114277: ARRAY
114278: PPUSH
114279: CALL_OW 314
114283: NOT
114284: IFFALSE 114322
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114286: LD_VAR 0 4
114290: PUSH
114291: LD_VAR 0 7
114295: ARRAY
114296: PPUSH
114297: LD_VAR 0 14
114301: PPUSH
114302: LD_VAR 0 4
114306: PUSH
114307: LD_VAR 0 7
114311: ARRAY
114312: PPUSH
114313: CALL_OW 74
114317: PPUSH
114318: CALL_OW 115
// end ; end ; end ;
114322: GO 110201
114324: POP
114325: POP
// wait ( 0 0$2 ) ;
114326: LD_INT 70
114328: PPUSH
114329: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114333: LD_VAR 0 4
114337: NOT
114338: PUSH
114339: LD_VAR 0 4
114343: PUSH
114344: EMPTY
114345: EQUAL
114346: OR
114347: PUSH
114348: LD_INT 81
114350: PUSH
114351: LD_VAR 0 35
114355: PUSH
114356: EMPTY
114357: LIST
114358: LIST
114359: PPUSH
114360: CALL_OW 69
114364: NOT
114365: OR
114366: IFFALSE 110186
// end ;
114368: LD_VAR 0 2
114372: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114373: LD_INT 0
114375: PPUSH
114376: PPUSH
114377: PPUSH
114378: PPUSH
114379: PPUSH
114380: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114381: LD_VAR 0 1
114385: NOT
114386: PUSH
114387: LD_EXP 50
114391: PUSH
114392: LD_VAR 0 1
114396: ARRAY
114397: NOT
114398: OR
114399: PUSH
114400: LD_VAR 0 2
114404: NOT
114405: OR
114406: IFFALSE 114410
// exit ;
114408: GO 114964
// side := mc_sides [ base ] ;
114410: LD_ADDR_VAR 0 6
114414: PUSH
114415: LD_EXP 76
114419: PUSH
114420: LD_VAR 0 1
114424: ARRAY
114425: ST_TO_ADDR
// if not side then
114426: LD_VAR 0 6
114430: NOT
114431: IFFALSE 114435
// exit ;
114433: GO 114964
// for i in solds do
114435: LD_ADDR_VAR 0 7
114439: PUSH
114440: LD_VAR 0 2
114444: PUSH
114445: FOR_IN
114446: IFFALSE 114507
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114448: LD_VAR 0 7
114452: PPUSH
114453: CALL_OW 310
114457: PPUSH
114458: CALL_OW 266
114462: PUSH
114463: LD_INT 32
114465: PUSH
114466: LD_INT 31
114468: PUSH
114469: EMPTY
114470: LIST
114471: LIST
114472: IN
114473: IFFALSE 114493
// solds := solds diff i else
114475: LD_ADDR_VAR 0 2
114479: PUSH
114480: LD_VAR 0 2
114484: PUSH
114485: LD_VAR 0 7
114489: DIFF
114490: ST_TO_ADDR
114491: GO 114505
// SetTag ( i , 18 ) ;
114493: LD_VAR 0 7
114497: PPUSH
114498: LD_INT 18
114500: PPUSH
114501: CALL_OW 109
114505: GO 114445
114507: POP
114508: POP
// if not solds then
114509: LD_VAR 0 2
114513: NOT
114514: IFFALSE 114518
// exit ;
114516: GO 114964
// repeat wait ( 0 0$2 ) ;
114518: LD_INT 70
114520: PPUSH
114521: CALL_OW 67
// enemy := mc_scan [ base ] ;
114525: LD_ADDR_VAR 0 4
114529: PUSH
114530: LD_EXP 73
114534: PUSH
114535: LD_VAR 0 1
114539: ARRAY
114540: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114541: LD_EXP 50
114545: PUSH
114546: LD_VAR 0 1
114550: ARRAY
114551: NOT
114552: PUSH
114553: LD_EXP 50
114557: PUSH
114558: LD_VAR 0 1
114562: ARRAY
114563: PUSH
114564: EMPTY
114565: EQUAL
114566: OR
114567: IFFALSE 114604
// begin for i in solds do
114569: LD_ADDR_VAR 0 7
114573: PUSH
114574: LD_VAR 0 2
114578: PUSH
114579: FOR_IN
114580: IFFALSE 114593
// ComStop ( i ) ;
114582: LD_VAR 0 7
114586: PPUSH
114587: CALL_OW 141
114591: GO 114579
114593: POP
114594: POP
// solds := [ ] ;
114595: LD_ADDR_VAR 0 2
114599: PUSH
114600: EMPTY
114601: ST_TO_ADDR
// exit ;
114602: GO 114964
// end ; for i in solds do
114604: LD_ADDR_VAR 0 7
114608: PUSH
114609: LD_VAR 0 2
114613: PUSH
114614: FOR_IN
114615: IFFALSE 114936
// begin if IsInUnit ( i ) then
114617: LD_VAR 0 7
114621: PPUSH
114622: CALL_OW 310
114626: IFFALSE 114637
// ComExitBuilding ( i ) ;
114628: LD_VAR 0 7
114632: PPUSH
114633: CALL_OW 122
// if GetLives ( i ) > 500 then
114637: LD_VAR 0 7
114641: PPUSH
114642: CALL_OW 256
114646: PUSH
114647: LD_INT 500
114649: GREATER
114650: IFFALSE 114703
// begin e := NearestUnitToUnit ( enemy , i ) ;
114652: LD_ADDR_VAR 0 5
114656: PUSH
114657: LD_VAR 0 4
114661: PPUSH
114662: LD_VAR 0 7
114666: PPUSH
114667: CALL_OW 74
114671: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114672: LD_VAR 0 7
114676: PPUSH
114677: LD_VAR 0 5
114681: PPUSH
114682: CALL_OW 250
114686: PPUSH
114687: LD_VAR 0 5
114691: PPUSH
114692: CALL_OW 251
114696: PPUSH
114697: CALL_OW 114
// end else
114701: GO 114934
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
114703: LD_VAR 0 7
114707: PPUSH
114708: LD_EXP 50
114712: PUSH
114713: LD_VAR 0 1
114717: ARRAY
114718: PPUSH
114719: LD_INT 2
114721: PUSH
114722: LD_INT 30
114724: PUSH
114725: LD_INT 0
114727: PUSH
114728: EMPTY
114729: LIST
114730: LIST
114731: PUSH
114732: LD_INT 30
114734: PUSH
114735: LD_INT 1
114737: PUSH
114738: EMPTY
114739: LIST
114740: LIST
114741: PUSH
114742: LD_INT 30
114744: PUSH
114745: LD_INT 6
114747: PUSH
114748: EMPTY
114749: LIST
114750: LIST
114751: PUSH
114752: EMPTY
114753: LIST
114754: LIST
114755: LIST
114756: LIST
114757: PPUSH
114758: CALL_OW 72
114762: PPUSH
114763: LD_VAR 0 7
114767: PPUSH
114768: CALL_OW 74
114772: PPUSH
114773: CALL_OW 296
114777: PUSH
114778: LD_INT 10
114780: GREATER
114781: IFFALSE 114934
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
114783: LD_ADDR_VAR 0 8
114787: PUSH
114788: LD_EXP 50
114792: PUSH
114793: LD_VAR 0 1
114797: ARRAY
114798: PPUSH
114799: LD_INT 2
114801: PUSH
114802: LD_INT 30
114804: PUSH
114805: LD_INT 0
114807: PUSH
114808: EMPTY
114809: LIST
114810: LIST
114811: PUSH
114812: LD_INT 30
114814: PUSH
114815: LD_INT 1
114817: PUSH
114818: EMPTY
114819: LIST
114820: LIST
114821: PUSH
114822: LD_INT 30
114824: PUSH
114825: LD_INT 6
114827: PUSH
114828: EMPTY
114829: LIST
114830: LIST
114831: PUSH
114832: EMPTY
114833: LIST
114834: LIST
114835: LIST
114836: LIST
114837: PPUSH
114838: CALL_OW 72
114842: PPUSH
114843: LD_VAR 0 7
114847: PPUSH
114848: CALL_OW 74
114852: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
114853: LD_VAR 0 7
114857: PPUSH
114858: LD_VAR 0 8
114862: PPUSH
114863: CALL_OW 250
114867: PPUSH
114868: LD_INT 3
114870: PPUSH
114871: LD_INT 5
114873: PPUSH
114874: CALL_OW 272
114878: PPUSH
114879: LD_VAR 0 8
114883: PPUSH
114884: CALL_OW 251
114888: PPUSH
114889: LD_INT 3
114891: PPUSH
114892: LD_INT 5
114894: PPUSH
114895: CALL_OW 273
114899: PPUSH
114900: CALL_OW 111
// SetTag ( i , 0 ) ;
114904: LD_VAR 0 7
114908: PPUSH
114909: LD_INT 0
114911: PPUSH
114912: CALL_OW 109
// solds := solds diff i ;
114916: LD_ADDR_VAR 0 2
114920: PUSH
114921: LD_VAR 0 2
114925: PUSH
114926: LD_VAR 0 7
114930: DIFF
114931: ST_TO_ADDR
// continue ;
114932: GO 114614
// end ; end ;
114934: GO 114614
114936: POP
114937: POP
// until not solds or not enemy ;
114938: LD_VAR 0 2
114942: NOT
114943: PUSH
114944: LD_VAR 0 4
114948: NOT
114949: OR
114950: IFFALSE 114518
// MC_Reset ( base , 18 ) ;
114952: LD_VAR 0 1
114956: PPUSH
114957: LD_INT 18
114959: PPUSH
114960: CALL 22091 0 2
// end ;
114964: LD_VAR 0 3
114968: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
114969: LD_INT 0
114971: PPUSH
114972: PPUSH
114973: PPUSH
114974: PPUSH
114975: PPUSH
114976: PPUSH
114977: PPUSH
114978: PPUSH
114979: PPUSH
114980: PPUSH
114981: PPUSH
114982: PPUSH
114983: PPUSH
114984: PPUSH
114985: PPUSH
114986: PPUSH
114987: PPUSH
114988: PPUSH
114989: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
114990: LD_ADDR_VAR 0 12
114994: PUSH
114995: LD_EXP 50
114999: PUSH
115000: LD_VAR 0 1
115004: ARRAY
115005: PPUSH
115006: LD_INT 25
115008: PUSH
115009: LD_INT 3
115011: PUSH
115012: EMPTY
115013: LIST
115014: LIST
115015: PPUSH
115016: CALL_OW 72
115020: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115021: LD_EXP 90
115025: PUSH
115026: LD_VAR 0 1
115030: ARRAY
115031: IFFALSE 115055
// mechs := mechs diff mc_remote_driver [ base ] ;
115033: LD_ADDR_VAR 0 12
115037: PUSH
115038: LD_VAR 0 12
115042: PUSH
115043: LD_EXP 90
115047: PUSH
115048: LD_VAR 0 1
115052: ARRAY
115053: DIFF
115054: ST_TO_ADDR
// for i in mechs do
115055: LD_ADDR_VAR 0 4
115059: PUSH
115060: LD_VAR 0 12
115064: PUSH
115065: FOR_IN
115066: IFFALSE 115101
// if GetTag ( i ) > 0 then
115068: LD_VAR 0 4
115072: PPUSH
115073: CALL_OW 110
115077: PUSH
115078: LD_INT 0
115080: GREATER
115081: IFFALSE 115099
// mechs := mechs diff i ;
115083: LD_ADDR_VAR 0 12
115087: PUSH
115088: LD_VAR 0 12
115092: PUSH
115093: LD_VAR 0 4
115097: DIFF
115098: ST_TO_ADDR
115099: GO 115065
115101: POP
115102: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115103: LD_ADDR_VAR 0 8
115107: PUSH
115108: LD_EXP 50
115112: PUSH
115113: LD_VAR 0 1
115117: ARRAY
115118: PPUSH
115119: LD_INT 2
115121: PUSH
115122: LD_INT 25
115124: PUSH
115125: LD_INT 1
115127: PUSH
115128: EMPTY
115129: LIST
115130: LIST
115131: PUSH
115132: LD_INT 25
115134: PUSH
115135: LD_INT 5
115137: PUSH
115138: EMPTY
115139: LIST
115140: LIST
115141: PUSH
115142: LD_INT 25
115144: PUSH
115145: LD_INT 8
115147: PUSH
115148: EMPTY
115149: LIST
115150: LIST
115151: PUSH
115152: LD_INT 25
115154: PUSH
115155: LD_INT 9
115157: PUSH
115158: EMPTY
115159: LIST
115160: LIST
115161: PUSH
115162: EMPTY
115163: LIST
115164: LIST
115165: LIST
115166: LIST
115167: LIST
115168: PPUSH
115169: CALL_OW 72
115173: ST_TO_ADDR
// if not defenders and not solds then
115174: LD_VAR 0 2
115178: NOT
115179: PUSH
115180: LD_VAR 0 8
115184: NOT
115185: AND
115186: IFFALSE 115190
// exit ;
115188: GO 116960
// depot_under_attack := false ;
115190: LD_ADDR_VAR 0 16
115194: PUSH
115195: LD_INT 0
115197: ST_TO_ADDR
// sold_defenders := [ ] ;
115198: LD_ADDR_VAR 0 17
115202: PUSH
115203: EMPTY
115204: ST_TO_ADDR
// if mechs then
115205: LD_VAR 0 12
115209: IFFALSE 115362
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115211: LD_ADDR_VAR 0 4
115215: PUSH
115216: LD_VAR 0 2
115220: PPUSH
115221: LD_INT 21
115223: PUSH
115224: LD_INT 2
115226: PUSH
115227: EMPTY
115228: LIST
115229: LIST
115230: PPUSH
115231: CALL_OW 72
115235: PUSH
115236: FOR_IN
115237: IFFALSE 115360
// begin if GetTag ( i ) <> 20 then
115239: LD_VAR 0 4
115243: PPUSH
115244: CALL_OW 110
115248: PUSH
115249: LD_INT 20
115251: NONEQUAL
115252: IFFALSE 115266
// SetTag ( i , 20 ) ;
115254: LD_VAR 0 4
115258: PPUSH
115259: LD_INT 20
115261: PPUSH
115262: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115266: LD_VAR 0 4
115270: PPUSH
115271: CALL_OW 263
115275: PUSH
115276: LD_INT 1
115278: EQUAL
115279: PUSH
115280: LD_VAR 0 4
115284: PPUSH
115285: CALL_OW 311
115289: NOT
115290: AND
115291: IFFALSE 115358
// begin un := mechs [ 1 ] ;
115293: LD_ADDR_VAR 0 10
115297: PUSH
115298: LD_VAR 0 12
115302: PUSH
115303: LD_INT 1
115305: ARRAY
115306: ST_TO_ADDR
// ComExit ( un ) ;
115307: LD_VAR 0 10
115311: PPUSH
115312: CALL 86315 0 1
// AddComEnterUnit ( un , i ) ;
115316: LD_VAR 0 10
115320: PPUSH
115321: LD_VAR 0 4
115325: PPUSH
115326: CALL_OW 180
// SetTag ( un , 19 ) ;
115330: LD_VAR 0 10
115334: PPUSH
115335: LD_INT 19
115337: PPUSH
115338: CALL_OW 109
// mechs := mechs diff un ;
115342: LD_ADDR_VAR 0 12
115346: PUSH
115347: LD_VAR 0 12
115351: PUSH
115352: LD_VAR 0 10
115356: DIFF
115357: ST_TO_ADDR
// end ; end ;
115358: GO 115236
115360: POP
115361: POP
// if solds then
115362: LD_VAR 0 8
115366: IFFALSE 115425
// for i in solds do
115368: LD_ADDR_VAR 0 4
115372: PUSH
115373: LD_VAR 0 8
115377: PUSH
115378: FOR_IN
115379: IFFALSE 115423
// if not GetTag ( i ) then
115381: LD_VAR 0 4
115385: PPUSH
115386: CALL_OW 110
115390: NOT
115391: IFFALSE 115421
// begin defenders := defenders union i ;
115393: LD_ADDR_VAR 0 2
115397: PUSH
115398: LD_VAR 0 2
115402: PUSH
115403: LD_VAR 0 4
115407: UNION
115408: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115409: LD_VAR 0 4
115413: PPUSH
115414: LD_INT 18
115416: PPUSH
115417: CALL_OW 109
// end ;
115421: GO 115378
115423: POP
115424: POP
// repeat wait ( 0 0$2 ) ;
115425: LD_INT 70
115427: PPUSH
115428: CALL_OW 67
// enemy := mc_scan [ base ] ;
115432: LD_ADDR_VAR 0 21
115436: PUSH
115437: LD_EXP 73
115441: PUSH
115442: LD_VAR 0 1
115446: ARRAY
115447: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115448: LD_EXP 50
115452: PUSH
115453: LD_VAR 0 1
115457: ARRAY
115458: NOT
115459: PUSH
115460: LD_EXP 50
115464: PUSH
115465: LD_VAR 0 1
115469: ARRAY
115470: PUSH
115471: EMPTY
115472: EQUAL
115473: OR
115474: IFFALSE 115511
// begin for i in defenders do
115476: LD_ADDR_VAR 0 4
115480: PUSH
115481: LD_VAR 0 2
115485: PUSH
115486: FOR_IN
115487: IFFALSE 115500
// ComStop ( i ) ;
115489: LD_VAR 0 4
115493: PPUSH
115494: CALL_OW 141
115498: GO 115486
115500: POP
115501: POP
// defenders := [ ] ;
115502: LD_ADDR_VAR 0 2
115506: PUSH
115507: EMPTY
115508: ST_TO_ADDR
// exit ;
115509: GO 116960
// end ; for i in defenders do
115511: LD_ADDR_VAR 0 4
115515: PUSH
115516: LD_VAR 0 2
115520: PUSH
115521: FOR_IN
115522: IFFALSE 116420
// begin e := NearestUnitToUnit ( enemy , i ) ;
115524: LD_ADDR_VAR 0 13
115528: PUSH
115529: LD_VAR 0 21
115533: PPUSH
115534: LD_VAR 0 4
115538: PPUSH
115539: CALL_OW 74
115543: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115544: LD_ADDR_VAR 0 7
115548: PUSH
115549: LD_EXP 50
115553: PUSH
115554: LD_VAR 0 1
115558: ARRAY
115559: PPUSH
115560: LD_INT 2
115562: PUSH
115563: LD_INT 30
115565: PUSH
115566: LD_INT 0
115568: PUSH
115569: EMPTY
115570: LIST
115571: LIST
115572: PUSH
115573: LD_INT 30
115575: PUSH
115576: LD_INT 1
115578: PUSH
115579: EMPTY
115580: LIST
115581: LIST
115582: PUSH
115583: EMPTY
115584: LIST
115585: LIST
115586: LIST
115587: PPUSH
115588: CALL_OW 72
115592: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115593: LD_ADDR_VAR 0 16
115597: PUSH
115598: LD_VAR 0 7
115602: NOT
115603: PUSH
115604: LD_VAR 0 7
115608: PPUSH
115609: LD_INT 3
115611: PUSH
115612: LD_INT 24
115614: PUSH
115615: LD_INT 600
115617: PUSH
115618: EMPTY
115619: LIST
115620: LIST
115621: PUSH
115622: EMPTY
115623: LIST
115624: LIST
115625: PPUSH
115626: CALL_OW 72
115630: OR
115631: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115632: LD_VAR 0 4
115636: PPUSH
115637: CALL_OW 247
115641: PUSH
115642: LD_INT 2
115644: DOUBLE
115645: EQUAL
115646: IFTRUE 115650
115648: GO 116046
115650: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115651: LD_VAR 0 4
115655: PPUSH
115656: CALL_OW 256
115660: PUSH
115661: LD_INT 1000
115663: EQUAL
115664: PUSH
115665: LD_VAR 0 4
115669: PPUSH
115670: LD_VAR 0 13
115674: PPUSH
115675: CALL_OW 296
115679: PUSH
115680: LD_INT 40
115682: LESS
115683: PUSH
115684: LD_VAR 0 13
115688: PPUSH
115689: LD_EXP 75
115693: PUSH
115694: LD_VAR 0 1
115698: ARRAY
115699: PPUSH
115700: CALL_OW 308
115704: OR
115705: AND
115706: IFFALSE 115828
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
115708: LD_VAR 0 4
115712: PPUSH
115713: CALL_OW 262
115717: PUSH
115718: LD_INT 1
115720: EQUAL
115721: PUSH
115722: LD_VAR 0 4
115726: PPUSH
115727: CALL_OW 261
115731: PUSH
115732: LD_INT 30
115734: LESS
115735: AND
115736: PUSH
115737: LD_VAR 0 7
115741: AND
115742: IFFALSE 115812
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
115744: LD_VAR 0 4
115748: PPUSH
115749: LD_VAR 0 7
115753: PPUSH
115754: LD_VAR 0 4
115758: PPUSH
115759: CALL_OW 74
115763: PPUSH
115764: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
115768: LD_VAR 0 4
115772: PPUSH
115773: LD_VAR 0 7
115777: PPUSH
115778: LD_VAR 0 4
115782: PPUSH
115783: CALL_OW 74
115787: PPUSH
115788: CALL_OW 296
115792: PUSH
115793: LD_INT 6
115795: LESS
115796: IFFALSE 115810
// SetFuel ( i , 100 ) ;
115798: LD_VAR 0 4
115802: PPUSH
115803: LD_INT 100
115805: PPUSH
115806: CALL_OW 240
// end else
115810: GO 115826
// ComAttackUnit ( i , e ) ;
115812: LD_VAR 0 4
115816: PPUSH
115817: LD_VAR 0 13
115821: PPUSH
115822: CALL_OW 115
// end else
115826: GO 115929
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
115828: LD_VAR 0 13
115832: PPUSH
115833: LD_EXP 75
115837: PUSH
115838: LD_VAR 0 1
115842: ARRAY
115843: PPUSH
115844: CALL_OW 308
115848: NOT
115849: PUSH
115850: LD_VAR 0 4
115854: PPUSH
115855: LD_VAR 0 13
115859: PPUSH
115860: CALL_OW 296
115864: PUSH
115865: LD_INT 40
115867: GREATEREQUAL
115868: AND
115869: PUSH
115870: LD_VAR 0 4
115874: PPUSH
115875: CALL_OW 256
115879: PUSH
115880: LD_INT 650
115882: LESSEQUAL
115883: OR
115884: PUSH
115885: LD_VAR 0 4
115889: PPUSH
115890: LD_EXP 74
115894: PUSH
115895: LD_VAR 0 1
115899: ARRAY
115900: PPUSH
115901: CALL_OW 308
115905: NOT
115906: AND
115907: IFFALSE 115929
// ComMoveToArea ( i , mc_parking [ base ] ) ;
115909: LD_VAR 0 4
115913: PPUSH
115914: LD_EXP 74
115918: PUSH
115919: LD_VAR 0 1
115923: ARRAY
115924: PPUSH
115925: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
115929: LD_VAR 0 4
115933: PPUSH
115934: CALL_OW 256
115938: PUSH
115939: LD_INT 1000
115941: LESS
115942: PUSH
115943: LD_VAR 0 4
115947: PPUSH
115948: CALL_OW 263
115952: PUSH
115953: LD_INT 1
115955: EQUAL
115956: AND
115957: PUSH
115958: LD_VAR 0 4
115962: PPUSH
115963: CALL_OW 311
115967: AND
115968: PUSH
115969: LD_VAR 0 4
115973: PPUSH
115974: LD_EXP 74
115978: PUSH
115979: LD_VAR 0 1
115983: ARRAY
115984: PPUSH
115985: CALL_OW 308
115989: AND
115990: IFFALSE 116044
// begin mech := IsDrivenBy ( i ) ;
115992: LD_ADDR_VAR 0 9
115996: PUSH
115997: LD_VAR 0 4
116001: PPUSH
116002: CALL_OW 311
116006: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116007: LD_VAR 0 9
116011: PPUSH
116012: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116016: LD_VAR 0 9
116020: PPUSH
116021: LD_VAR 0 4
116025: PPUSH
116026: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116030: LD_VAR 0 9
116034: PPUSH
116035: LD_VAR 0 4
116039: PPUSH
116040: CALL_OW 180
// end ; end ; unit_human :
116044: GO 116391
116046: LD_INT 1
116048: DOUBLE
116049: EQUAL
116050: IFTRUE 116054
116052: GO 116390
116054: POP
// begin b := IsInUnit ( i ) ;
116055: LD_ADDR_VAR 0 18
116059: PUSH
116060: LD_VAR 0 4
116064: PPUSH
116065: CALL_OW 310
116069: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116070: LD_ADDR_VAR 0 19
116074: PUSH
116075: LD_VAR 0 18
116079: NOT
116080: PUSH
116081: LD_VAR 0 18
116085: PPUSH
116086: CALL_OW 266
116090: PUSH
116091: LD_INT 32
116093: PUSH
116094: LD_INT 31
116096: PUSH
116097: EMPTY
116098: LIST
116099: LIST
116100: IN
116101: OR
116102: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116103: LD_VAR 0 18
116107: PPUSH
116108: CALL_OW 266
116112: PUSH
116113: LD_INT 5
116115: EQUAL
116116: PUSH
116117: LD_VAR 0 4
116121: PPUSH
116122: CALL_OW 257
116126: PUSH
116127: LD_INT 1
116129: PUSH
116130: LD_INT 2
116132: PUSH
116133: LD_INT 3
116135: PUSH
116136: LD_INT 4
116138: PUSH
116139: EMPTY
116140: LIST
116141: LIST
116142: LIST
116143: LIST
116144: IN
116145: AND
116146: IFFALSE 116183
// begin class := AllowSpecClass ( i ) ;
116148: LD_ADDR_VAR 0 20
116152: PUSH
116153: LD_VAR 0 4
116157: PPUSH
116158: CALL 50327 0 1
116162: ST_TO_ADDR
// if class then
116163: LD_VAR 0 20
116167: IFFALSE 116183
// ComChangeProfession ( i , class ) ;
116169: LD_VAR 0 4
116173: PPUSH
116174: LD_VAR 0 20
116178: PPUSH
116179: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116183: LD_VAR 0 16
116187: PUSH
116188: LD_VAR 0 2
116192: PPUSH
116193: LD_INT 21
116195: PUSH
116196: LD_INT 2
116198: PUSH
116199: EMPTY
116200: LIST
116201: LIST
116202: PPUSH
116203: CALL_OW 72
116207: PUSH
116208: LD_INT 1
116210: LESSEQUAL
116211: OR
116212: PUSH
116213: LD_VAR 0 19
116217: AND
116218: PUSH
116219: LD_VAR 0 4
116223: PUSH
116224: LD_VAR 0 17
116228: IN
116229: NOT
116230: AND
116231: IFFALSE 116324
// begin if b then
116233: LD_VAR 0 18
116237: IFFALSE 116286
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116239: LD_VAR 0 18
116243: PPUSH
116244: LD_VAR 0 21
116248: PPUSH
116249: LD_VAR 0 18
116253: PPUSH
116254: CALL_OW 74
116258: PPUSH
116259: CALL_OW 296
116263: PUSH
116264: LD_INT 10
116266: LESS
116267: PUSH
116268: LD_VAR 0 18
116272: PPUSH
116273: CALL_OW 461
116277: PUSH
116278: LD_INT 7
116280: NONEQUAL
116281: AND
116282: IFFALSE 116286
// continue ;
116284: GO 115521
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116286: LD_ADDR_VAR 0 17
116290: PUSH
116291: LD_VAR 0 17
116295: PPUSH
116296: LD_VAR 0 17
116300: PUSH
116301: LD_INT 1
116303: PLUS
116304: PPUSH
116305: LD_VAR 0 4
116309: PPUSH
116310: CALL_OW 1
116314: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116315: LD_VAR 0 4
116319: PPUSH
116320: CALL_OW 122
// end ; if sold_defenders then
116324: LD_VAR 0 17
116328: IFFALSE 116388
// if i in sold_defenders then
116330: LD_VAR 0 4
116334: PUSH
116335: LD_VAR 0 17
116339: IN
116340: IFFALSE 116388
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116342: LD_VAR 0 4
116346: PPUSH
116347: CALL_OW 314
116351: NOT
116352: PUSH
116353: LD_VAR 0 4
116357: PPUSH
116358: LD_VAR 0 13
116362: PPUSH
116363: CALL_OW 296
116367: PUSH
116368: LD_INT 30
116370: LESS
116371: AND
116372: IFFALSE 116388
// ComAttackUnit ( i , e ) ;
116374: LD_VAR 0 4
116378: PPUSH
116379: LD_VAR 0 13
116383: PPUSH
116384: CALL_OW 115
// end ; end ; end ;
116388: GO 116391
116390: POP
// if IsDead ( i ) then
116391: LD_VAR 0 4
116395: PPUSH
116396: CALL_OW 301
116400: IFFALSE 116418
// defenders := defenders diff i ;
116402: LD_ADDR_VAR 0 2
116406: PUSH
116407: LD_VAR 0 2
116411: PUSH
116412: LD_VAR 0 4
116416: DIFF
116417: ST_TO_ADDR
// end ;
116418: GO 115521
116420: POP
116421: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116422: LD_VAR 0 21
116426: NOT
116427: PUSH
116428: LD_VAR 0 2
116432: NOT
116433: OR
116434: PUSH
116435: LD_EXP 50
116439: PUSH
116440: LD_VAR 0 1
116444: ARRAY
116445: NOT
116446: OR
116447: IFFALSE 115425
// MC_Reset ( base , 18 ) ;
116449: LD_VAR 0 1
116453: PPUSH
116454: LD_INT 18
116456: PPUSH
116457: CALL 22091 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116461: LD_ADDR_VAR 0 2
116465: PUSH
116466: LD_VAR 0 2
116470: PUSH
116471: LD_VAR 0 2
116475: PPUSH
116476: LD_INT 2
116478: PUSH
116479: LD_INT 25
116481: PUSH
116482: LD_INT 1
116484: PUSH
116485: EMPTY
116486: LIST
116487: LIST
116488: PUSH
116489: LD_INT 25
116491: PUSH
116492: LD_INT 5
116494: PUSH
116495: EMPTY
116496: LIST
116497: LIST
116498: PUSH
116499: LD_INT 25
116501: PUSH
116502: LD_INT 8
116504: PUSH
116505: EMPTY
116506: LIST
116507: LIST
116508: PUSH
116509: LD_INT 25
116511: PUSH
116512: LD_INT 9
116514: PUSH
116515: EMPTY
116516: LIST
116517: LIST
116518: PUSH
116519: EMPTY
116520: LIST
116521: LIST
116522: LIST
116523: LIST
116524: LIST
116525: PPUSH
116526: CALL_OW 72
116530: DIFF
116531: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116532: LD_VAR 0 21
116536: NOT
116537: PUSH
116538: LD_VAR 0 2
116542: PPUSH
116543: LD_INT 21
116545: PUSH
116546: LD_INT 2
116548: PUSH
116549: EMPTY
116550: LIST
116551: LIST
116552: PPUSH
116553: CALL_OW 72
116557: AND
116558: IFFALSE 116896
// begin tmp := FilterByTag ( defenders , 19 ) ;
116560: LD_ADDR_VAR 0 11
116564: PUSH
116565: LD_VAR 0 2
116569: PPUSH
116570: LD_INT 19
116572: PPUSH
116573: CALL 83491 0 2
116577: ST_TO_ADDR
// if tmp then
116578: LD_VAR 0 11
116582: IFFALSE 116652
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116584: LD_ADDR_VAR 0 11
116588: PUSH
116589: LD_VAR 0 11
116593: PPUSH
116594: LD_INT 25
116596: PUSH
116597: LD_INT 3
116599: PUSH
116600: EMPTY
116601: LIST
116602: LIST
116603: PPUSH
116604: CALL_OW 72
116608: ST_TO_ADDR
// if tmp then
116609: LD_VAR 0 11
116613: IFFALSE 116652
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116615: LD_ADDR_EXP 62
116619: PUSH
116620: LD_EXP 62
116624: PPUSH
116625: LD_VAR 0 1
116629: PPUSH
116630: LD_EXP 62
116634: PUSH
116635: LD_VAR 0 1
116639: ARRAY
116640: PUSH
116641: LD_VAR 0 11
116645: UNION
116646: PPUSH
116647: CALL_OW 1
116651: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116652: LD_VAR 0 1
116656: PPUSH
116657: LD_INT 19
116659: PPUSH
116660: CALL 22091 0 2
// repeat wait ( 0 0$1 ) ;
116664: LD_INT 35
116666: PPUSH
116667: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116671: LD_EXP 50
116675: PUSH
116676: LD_VAR 0 1
116680: ARRAY
116681: NOT
116682: PUSH
116683: LD_EXP 50
116687: PUSH
116688: LD_VAR 0 1
116692: ARRAY
116693: PUSH
116694: EMPTY
116695: EQUAL
116696: OR
116697: IFFALSE 116734
// begin for i in defenders do
116699: LD_ADDR_VAR 0 4
116703: PUSH
116704: LD_VAR 0 2
116708: PUSH
116709: FOR_IN
116710: IFFALSE 116723
// ComStop ( i ) ;
116712: LD_VAR 0 4
116716: PPUSH
116717: CALL_OW 141
116721: GO 116709
116723: POP
116724: POP
// defenders := [ ] ;
116725: LD_ADDR_VAR 0 2
116729: PUSH
116730: EMPTY
116731: ST_TO_ADDR
// exit ;
116732: GO 116960
// end ; for i in defenders do
116734: LD_ADDR_VAR 0 4
116738: PUSH
116739: LD_VAR 0 2
116743: PUSH
116744: FOR_IN
116745: IFFALSE 116834
// begin if not IsInArea ( i , mc_parking [ base ] ) then
116747: LD_VAR 0 4
116751: PPUSH
116752: LD_EXP 74
116756: PUSH
116757: LD_VAR 0 1
116761: ARRAY
116762: PPUSH
116763: CALL_OW 308
116767: NOT
116768: IFFALSE 116792
// ComMoveToArea ( i , mc_parking [ base ] ) else
116770: LD_VAR 0 4
116774: PPUSH
116775: LD_EXP 74
116779: PUSH
116780: LD_VAR 0 1
116784: ARRAY
116785: PPUSH
116786: CALL_OW 113
116790: GO 116832
// if GetControl ( i ) = control_manual then
116792: LD_VAR 0 4
116796: PPUSH
116797: CALL_OW 263
116801: PUSH
116802: LD_INT 1
116804: EQUAL
116805: IFFALSE 116832
// if IsDrivenBy ( i ) then
116807: LD_VAR 0 4
116811: PPUSH
116812: CALL_OW 311
116816: IFFALSE 116832
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
116818: LD_VAR 0 4
116822: PPUSH
116823: CALL_OW 311
116827: PPUSH
116828: CALL_OW 121
// end ;
116832: GO 116744
116834: POP
116835: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
116836: LD_VAR 0 2
116840: PPUSH
116841: LD_INT 95
116843: PUSH
116844: LD_EXP 74
116848: PUSH
116849: LD_VAR 0 1
116853: ARRAY
116854: PUSH
116855: EMPTY
116856: LIST
116857: LIST
116858: PPUSH
116859: CALL_OW 72
116863: PUSH
116864: LD_VAR 0 2
116868: EQUAL
116869: PUSH
116870: LD_EXP 73
116874: PUSH
116875: LD_VAR 0 1
116879: ARRAY
116880: OR
116881: PUSH
116882: LD_EXP 50
116886: PUSH
116887: LD_VAR 0 1
116891: ARRAY
116892: NOT
116893: OR
116894: IFFALSE 116664
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
116896: LD_ADDR_EXP 72
116900: PUSH
116901: LD_EXP 72
116905: PPUSH
116906: LD_VAR 0 1
116910: PPUSH
116911: LD_VAR 0 2
116915: PPUSH
116916: LD_INT 21
116918: PUSH
116919: LD_INT 2
116921: PUSH
116922: EMPTY
116923: LIST
116924: LIST
116925: PPUSH
116926: CALL_OW 72
116930: PPUSH
116931: CALL_OW 1
116935: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
116936: LD_VAR 0 1
116940: PPUSH
116941: LD_INT 19
116943: PPUSH
116944: CALL 22091 0 2
// MC_Reset ( base , 20 ) ;
116948: LD_VAR 0 1
116952: PPUSH
116953: LD_INT 20
116955: PPUSH
116956: CALL 22091 0 2
// end ; end_of_file
116960: LD_VAR 0 3
116964: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
116965: LD_VAR 0 1
116969: PUSH
116970: LD_INT 200
116972: DOUBLE
116973: GREATEREQUAL
116974: IFFALSE 116982
116976: LD_INT 299
116978: DOUBLE
116979: LESSEQUAL
116980: IFTRUE 116984
116982: GO 117016
116984: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
116985: LD_VAR 0 1
116989: PPUSH
116990: LD_VAR 0 2
116994: PPUSH
116995: LD_VAR 0 3
116999: PPUSH
117000: LD_VAR 0 4
117004: PPUSH
117005: LD_VAR 0 5
117009: PPUSH
117010: CALL 105751 0 5
117014: GO 117093
117016: LD_INT 300
117018: DOUBLE
117019: GREATEREQUAL
117020: IFFALSE 117028
117022: LD_INT 399
117024: DOUBLE
117025: LESSEQUAL
117026: IFTRUE 117030
117028: GO 117092
117030: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117031: LD_VAR 0 1
117035: PPUSH
117036: LD_VAR 0 2
117040: PPUSH
117041: LD_VAR 0 3
117045: PPUSH
117046: LD_VAR 0 4
117050: PPUSH
117051: LD_VAR 0 5
117055: PPUSH
117056: LD_VAR 0 6
117060: PPUSH
117061: LD_VAR 0 7
117065: PPUSH
117066: LD_VAR 0 8
117070: PPUSH
117071: LD_VAR 0 9
117075: PPUSH
117076: LD_VAR 0 10
117080: PPUSH
117081: LD_VAR 0 11
117085: PPUSH
117086: CALL 102084 0 11
117090: GO 117093
117092: POP
// end ;
117093: PPOPN 11
117095: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117096: LD_VAR 0 1
117100: PPUSH
117101: LD_VAR 0 2
117105: PPUSH
117106: LD_VAR 0 3
117110: PPUSH
117111: LD_VAR 0 4
117115: PPUSH
117116: LD_VAR 0 5
117120: PPUSH
117121: CALL 105487 0 5
// end ; end_of_file
117125: PPOPN 5
117127: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117128: LD_VAR 0 1
117132: PPUSH
117133: LD_VAR 0 2
117137: PPUSH
117138: LD_VAR 0 3
117142: PPUSH
117143: LD_VAR 0 4
117147: PPUSH
117148: LD_VAR 0 5
117152: PPUSH
117153: LD_VAR 0 6
117157: PPUSH
117158: CALL 89777 0 6
// end ;
117162: PPOPN 6
117164: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117165: LD_INT 0
117167: PPUSH
// begin if not units then
117168: LD_VAR 0 1
117172: NOT
117173: IFFALSE 117177
// exit ;
117175: GO 117177
// end ;
117177: PPOPN 7
117179: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117180: CALL 89748 0 0
// end ;
117184: PPOPN 1
117186: END
