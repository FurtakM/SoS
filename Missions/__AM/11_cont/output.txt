// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18693 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 84606 0 9
// PrepareAmerican ;
  77: CALL 655 0 0
// PrepareArabian ;
  81: CALL 2537 0 0
// MC_Start ( ) ;
  85: CALL 20873 0 0
// Action ;
  89: CALL 9046 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42846 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42846 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42846 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 43291 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 43183 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 43183 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: IFFALSE 642
 633: PUSH
 634: LD_INT 45
 636: PPUSH
 637: CALL_OW 302
 641: AND
 642: IFFALSE 654
 644: GO 646
 646: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 647: LD_STRING ACH_EAST
 649: PPUSH
 650: CALL_OW 543
 654: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
 663: PPUSH
 664: PPUSH
// uc_side := 4 ;
 665: LD_ADDR_OWVAR 20
 669: PUSH
 670: LD_INT 4
 672: ST_TO_ADDR
// uc_nation := 1 ;
 673: LD_ADDR_OWVAR 21
 677: PUSH
 678: LD_INT 1
 680: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 681: LD_ADDR_EXP 30
 685: PUSH
 686: LD_STRING Powell
 688: PPUSH
 689: LD_INT 0
 691: PPUSH
 692: LD_STRING 
 694: PPUSH
 695: CALL 49755 0 3
 699: ST_TO_ADDR
// uc_side := 1 ;
 700: LD_ADDR_OWVAR 20
 704: PUSH
 705: LD_INT 1
 707: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 708: LD_ADDR_EXP 21
 712: PUSH
 713: LD_STRING JMM
 715: PPUSH
 716: LD_EXP 1
 720: NOT
 721: PPUSH
 722: LD_EXP 4
 726: PPUSH
 727: CALL 49755 0 3
 731: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 732: LD_EXP 21
 736: PPUSH
 737: CALL_OW 257
 741: PUSH
 742: LD_INT 4
 744: GREATER
 745: IFFALSE 759
// SetClass ( JMM , 1 ) ;
 747: LD_EXP 21
 751: PPUSH
 752: LD_INT 1
 754: PPUSH
 755: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 759: LD_ADDR_EXP 22
 763: PUSH
 764: LD_STRING Lisa
 766: PPUSH
 767: LD_EXP 1
 771: NOT
 772: PPUSH
 773: LD_EXP 4
 777: PPUSH
 778: CALL 49755 0 3
 782: ST_TO_ADDR
// if not Lisa then
 783: LD_EXP 22
 787: NOT
 788: IFFALSE 803
// Lisa := CreateCharacter ( 10_Lisa ) ;
 790: LD_ADDR_EXP 22
 794: PUSH
 795: LD_STRING 10_Lisa
 797: PPUSH
 798: CALL_OW 34
 802: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 803: LD_ADDR_EXP 31
 807: PUSH
 808: LD_STRING Cornel
 810: PPUSH
 811: LD_EXP 1
 815: NOT
 816: PPUSH
 817: LD_EXP 4
 821: PPUSH
 822: CALL 49755 0 3
 826: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 827: LD_ADDR_EXP 23
 831: PUSH
 832: LD_STRING Donaldson
 834: PPUSH
 835: LD_EXP 1
 839: NOT
 840: PPUSH
 841: LD_EXP 4
 845: PPUSH
 846: CALL 49755 0 3
 850: ST_TO_ADDR
// if not Donaldson then
 851: LD_EXP 23
 855: NOT
 856: IFFALSE 871
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 858: LD_ADDR_EXP 23
 862: PUSH
 863: LD_STRING 10_Donaldson
 865: PPUSH
 866: CALL_OW 34
 870: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 871: LD_ADDR_EXP 24
 875: PUSH
 876: LD_STRING Bobby
 878: PPUSH
 879: LD_EXP 1
 883: NOT
 884: PPUSH
 885: LD_EXP 4
 889: PPUSH
 890: CALL 49755 0 3
 894: ST_TO_ADDR
// if not Bobby then
 895: LD_EXP 24
 899: NOT
 900: IFFALSE 915
// Bobby := CreateCharacter ( 10_Bobby ) ;
 902: LD_ADDR_EXP 24
 906: PUSH
 907: LD_STRING 10_Bobby
 909: PPUSH
 910: CALL_OW 34
 914: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 915: LD_ADDR_EXP 25
 919: PUSH
 920: LD_STRING Cyrus
 922: PPUSH
 923: LD_EXP 1
 927: NOT
 928: PPUSH
 929: LD_EXP 4
 933: PPUSH
 934: CALL 49755 0 3
 938: ST_TO_ADDR
// if not Cyrus then
 939: LD_EXP 25
 943: NOT
 944: IFFALSE 959
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 946: LD_ADDR_EXP 25
 950: PUSH
 951: LD_STRING 10_Cyrus
 953: PPUSH
 954: CALL_OW 34
 958: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 959: LD_ADDR_EXP 26
 963: PUSH
 964: LD_STRING Denis
 966: PPUSH
 967: LD_EXP 1
 971: NOT
 972: PPUSH
 973: LD_EXP 4
 977: PPUSH
 978: CALL 49755 0 3
 982: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 983: LD_ADDR_EXP 27
 987: PUSH
 988: LD_STRING Brown
 990: PPUSH
 991: LD_EXP 1
 995: NOT
 996: PPUSH
 997: LD_EXP 4
1001: PPUSH
1002: CALL 49755 0 3
1006: ST_TO_ADDR
// if not Brown then
1007: LD_EXP 27
1011: NOT
1012: IFFALSE 1027
// Brown := CreateCharacter ( 10_Brown ) ;
1014: LD_ADDR_EXP 27
1018: PUSH
1019: LD_STRING 10_Brown
1021: PPUSH
1022: CALL_OW 34
1026: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1027: LD_ADDR_EXP 28
1031: PUSH
1032: LD_STRING Gladstone
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_EXP 4
1045: PPUSH
1046: CALL 49755 0 3
1050: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1051: LD_ADDR_EXP 29
1055: PUSH
1056: LD_STRING Houten
1058: PPUSH
1059: LD_EXP 1
1063: NOT
1064: PPUSH
1065: LD_EXP 4
1069: PPUSH
1070: CALL 49755 0 3
1074: ST_TO_ADDR
// if not Houten then
1075: LD_EXP 29
1079: NOT
1080: IFFALSE 1095
// Houten := CreateCharacter ( 10_Houten ) ;
1082: LD_ADDR_EXP 29
1086: PUSH
1087: LD_STRING 10_Houten
1089: PPUSH
1090: CALL_OW 34
1094: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1095: LD_ADDR_EXP 31
1099: PUSH
1100: LD_STRING Cornell
1102: PPUSH
1103: LD_EXP 1
1107: NOT
1108: PPUSH
1109: LD_EXP 4
1113: PPUSH
1114: CALL 49755 0 3
1118: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 32
1123: PUSH
1124: LD_STRING Gary
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 49755 0 3
1142: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1143: LD_ADDR_EXP 33
1147: PUSH
1148: LD_STRING Frank
1150: PPUSH
1151: LD_EXP 1
1155: NOT
1156: PPUSH
1157: LD_EXP 4
1161: PPUSH
1162: CALL 49755 0 3
1166: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1167: LD_ADDR_EXP 34
1171: PUSH
1172: LD_STRING Kikuchi
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_EXP 4
1185: PPUSH
1186: CALL 49755 0 3
1190: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1191: LD_ADDR_VAR 0 5
1195: PUSH
1196: LD_EXP 22
1200: PUSH
1201: LD_EXP 23
1205: PUSH
1206: LD_EXP 24
1210: PUSH
1211: LD_EXP 25
1215: PUSH
1216: LD_EXP 26
1220: PUSH
1221: LD_EXP 27
1225: PUSH
1226: LD_EXP 28
1230: PUSH
1231: LD_EXP 29
1235: PUSH
1236: LD_EXP 31
1240: PUSH
1241: LD_EXP 32
1245: PUSH
1246: LD_EXP 33
1250: PUSH
1251: LD_EXP 34
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: ST_TO_ADDR
// tmp := tmp diff 0 ;
1270: LD_ADDR_VAR 0 5
1274: PUSH
1275: LD_VAR 0 5
1279: PUSH
1280: LD_INT 0
1282: DIFF
1283: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1284: LD_ADDR_VAR 0 5
1288: PUSH
1289: LD_VAR 0 5
1293: PUSH
1294: LD_STRING 10_other_survivors
1296: PPUSH
1297: CALL_OW 31
1301: UNION
1302: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1303: LD_ADDR_VAR 0 5
1307: PUSH
1308: LD_VAR 0 5
1312: PUSH
1313: LD_STRING 10_lock
1315: PPUSH
1316: CALL_OW 31
1320: UNION
1321: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1322: LD_ADDR_VAR 0 5
1326: PUSH
1327: LD_VAR 0 5
1331: PUSH
1332: LD_STRING 10c_lock
1334: PPUSH
1335: CALL_OW 31
1339: UNION
1340: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1341: LD_STRING 10_lock
1343: PPUSH
1344: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1348: LD_STRING 10c_lock
1350: PPUSH
1351: CALL_OW 40
// for i in tmp do
1355: LD_ADDR_VAR 0 2
1359: PUSH
1360: LD_VAR 0 5
1364: PUSH
1365: FOR_IN
1366: IFFALSE 1404
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1368: LD_VAR 0 2
1372: PPUSH
1373: CALL_OW 257
1377: PUSH
1378: LD_INT 8
1380: PUSH
1381: LD_INT 2
1383: PUSH
1384: EMPTY
1385: LIST
1386: LIST
1387: IN
1388: IFFALSE 1402
// SetClass ( i , class_soldier ) ;
1390: LD_VAR 0 2
1394: PPUSH
1395: LD_INT 1
1397: PPUSH
1398: CALL_OW 336
1402: GO 1365
1404: POP
1405: POP
// if tmp < 12 then
1406: LD_VAR 0 5
1410: PUSH
1411: LD_INT 12
1413: LESS
1414: IFFALSE 1508
// begin k := 16 - tmp ;
1416: LD_ADDR_VAR 0 3
1420: PUSH
1421: LD_INT 16
1423: PUSH
1424: LD_VAR 0 5
1428: MINUS
1429: ST_TO_ADDR
// for i = 1 to k do
1430: LD_ADDR_VAR 0 2
1434: PUSH
1435: DOUBLE
1436: LD_INT 1
1438: DEC
1439: ST_TO_ADDR
1440: LD_VAR 0 3
1444: PUSH
1445: FOR_TO
1446: IFFALSE 1506
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1448: LD_INT 0
1450: PPUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 1
1456: PUSH
1457: LD_INT 3
1459: PUSH
1460: LD_INT 4
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: PUSH
1469: LD_INT 1
1471: PPUSH
1472: LD_INT 4
1474: PPUSH
1475: CALL_OW 12
1479: ARRAY
1480: PPUSH
1481: LD_INT 6
1483: PPUSH
1484: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: CALL_OW 44
1502: ADD
1503: ST_TO_ADDR
// end ;
1504: GO 1445
1506: POP
1507: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1508: LD_ADDR_EXP 19
1512: PUSH
1513: LD_STRING 1
1515: PPUSH
1516: LD_INT 12
1518: PPUSH
1519: LD_INT 12
1521: PPUSH
1522: LD_INT -5
1524: PUSH
1525: LD_EXP 21
1529: PUSH
1530: LD_INT -2
1532: PUSH
1533: LD_INT -3
1535: PUSH
1536: LD_INT -5
1538: PUSH
1539: EMPTY
1540: LIST
1541: LIST
1542: LIST
1543: LIST
1544: LIST
1545: PUSH
1546: LD_VAR 0 5
1550: ADD
1551: PUSH
1552: LD_INT -6
1554: PUSH
1555: LD_INT -4
1557: PUSH
1558: LD_EXP 30
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: LIST
1567: ADD
1568: PPUSH
1569: LD_INT 1
1571: PUSH
1572: LD_INT 4
1574: PUSH
1575: EMPTY
1576: LIST
1577: LIST
1578: PUSH
1579: LD_INT 3
1581: PUSH
1582: LD_INT 0
1584: PUSH
1585: LD_INT 5
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: PUSH
1593: LD_INT 4
1595: PUSH
1596: LD_INT 0
1598: PUSH
1599: LD_INT 3
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: LIST
1606: PUSH
1607: LD_INT 5
1609: PUSH
1610: LD_INT 0
1612: PUSH
1613: LD_INT 2
1615: PUSH
1616: EMPTY
1617: LIST
1618: LIST
1619: LIST
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PPUSH
1627: CALL_OW 42
1631: ST_TO_ADDR
// others := tmp diff selected ;
1632: LD_ADDR_VAR 0 8
1636: PUSH
1637: LD_VAR 0 5
1641: PUSH
1642: LD_EXP 19
1646: DIFF
1647: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1648: LD_ADDR_VAR 0 8
1652: PUSH
1653: LD_VAR 0 8
1657: PUSH
1658: LD_EXP 22
1662: PUSH
1663: LD_EXP 23
1667: PUSH
1668: LD_EXP 24
1672: PUSH
1673: LD_EXP 25
1677: PUSH
1678: LD_EXP 26
1682: PUSH
1683: LD_EXP 27
1687: PUSH
1688: LD_EXP 28
1692: PUSH
1693: LD_EXP 29
1697: PUSH
1698: LD_EXP 31
1702: PUSH
1703: LD_EXP 32
1707: PUSH
1708: LD_EXP 33
1712: PUSH
1713: LD_EXP 34
1717: PUSH
1718: EMPTY
1719: LIST
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: LIST
1731: DIFF
1732: ST_TO_ADDR
// if others then
1733: LD_VAR 0 8
1737: IFFALSE 1751
// SaveCharacters ( others , 11_others ) ;
1739: LD_VAR 0 8
1743: PPUSH
1744: LD_STRING 11_others
1746: PPUSH
1747: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1751: LD_ADDR_VAR 0 6
1755: PUSH
1756: LD_INT 3
1758: PUSH
1759: LD_INT 1
1761: PUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: LIST
1772: LIST
1773: PUSH
1774: LD_INT 2
1776: PUSH
1777: LD_INT 3
1779: PUSH
1780: LD_INT 1
1782: PUSH
1783: LD_INT 5
1785: PUSH
1786: EMPTY
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 1
1797: PUSH
1798: LD_INT 1
1800: PUSH
1801: LD_INT 5
1803: PUSH
1804: EMPTY
1805: LIST
1806: LIST
1807: LIST
1808: LIST
1809: PUSH
1810: LD_INT 2
1812: PUSH
1813: LD_INT 1
1815: PUSH
1816: LD_INT 1
1818: PUSH
1819: LD_INT 7
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: LIST
1826: LIST
1827: PUSH
1828: LD_INT 3
1830: PUSH
1831: LD_INT 3
1833: PUSH
1834: LD_INT 1
1836: PUSH
1837: LD_INT 7
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: PUSH
1846: EMPTY
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: ST_TO_ADDR
// for i in JMM ^ selected do
1853: LD_ADDR_VAR 0 2
1857: PUSH
1858: LD_EXP 21
1862: PUSH
1863: LD_EXP 19
1867: ADD
1868: PUSH
1869: FOR_IN
1870: IFFALSE 2060
// begin if GetClass ( i ) = 3 then
1872: LD_VAR 0 2
1876: PPUSH
1877: CALL_OW 257
1881: PUSH
1882: LD_INT 3
1884: EQUAL
1885: IFFALSE 2043
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1887: LD_ADDR_OWVAR 37
1891: PUSH
1892: LD_VAR 0 6
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1905: LD_ADDR_OWVAR 39
1909: PUSH
1910: LD_VAR 0 6
1914: PUSH
1915: LD_INT 1
1917: ARRAY
1918: PUSH
1919: LD_INT 2
1921: ARRAY
1922: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
1923: LD_ADDR_OWVAR 38
1927: PUSH
1928: LD_VAR 0 6
1932: PUSH
1933: LD_INT 1
1935: ARRAY
1936: PUSH
1937: LD_INT 3
1939: ARRAY
1940: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
1941: LD_ADDR_OWVAR 40
1945: PUSH
1946: LD_VAR 0 6
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PUSH
1955: LD_INT 4
1957: ARRAY
1958: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
1959: LD_ADDR_VAR 0 6
1963: PUSH
1964: LD_VAR 0 6
1968: PPUSH
1969: LD_INT 1
1971: PPUSH
1972: CALL_OW 3
1976: ST_TO_ADDR
// veh := CreateVehicle ;
1977: LD_ADDR_VAR 0 7
1981: PUSH
1982: CALL_OW 45
1986: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
1987: LD_VAR 0 7
1991: PPUSH
1992: LD_INT 8
1994: PPUSH
1995: LD_INT 0
1997: PPUSH
1998: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2002: LD_VAR 0 2
2006: PPUSH
2007: LD_VAR 0 7
2011: PPUSH
2012: CALL_OW 52
// if i = JMM then
2016: LD_VAR 0 2
2020: PUSH
2021: LD_EXP 21
2025: EQUAL
2026: IFFALSE 2041
// SetMark ( veh , - 1 ) ;
2028: LD_VAR 0 7
2032: PPUSH
2033: LD_INT 1
2035: NEG
2036: PPUSH
2037: CALL_OW 242
// end else
2041: GO 2058
// PlaceUnitArea ( i , am_hum_start , false ) ;
2043: LD_VAR 0 2
2047: PPUSH
2048: LD_INT 9
2050: PPUSH
2051: LD_INT 0
2053: PPUSH
2054: CALL_OW 49
// end ;
2058: GO 1869
2060: POP
2061: POP
// vc_chassis := us_medium_tracked ;
2062: LD_ADDR_OWVAR 37
2066: PUSH
2067: LD_INT 3
2069: ST_TO_ADDR
// vc_engine := engine_solar ;
2070: LD_ADDR_OWVAR 39
2074: PUSH
2075: LD_INT 2
2077: ST_TO_ADDR
// vc_control := control_computer ;
2078: LD_ADDR_OWVAR 38
2082: PUSH
2083: LD_INT 3
2085: ST_TO_ADDR
// vc_weapon := us_radar ;
2086: LD_ADDR_OWVAR 40
2090: PUSH
2091: LD_INT 11
2093: ST_TO_ADDR
// veh := CreateVehicle ;
2094: LD_ADDR_VAR 0 7
2098: PUSH
2099: CALL_OW 45
2103: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2104: LD_VAR 0 7
2108: PPUSH
2109: LD_INT 87
2111: PPUSH
2112: LD_INT 142
2114: PPUSH
2115: LD_INT 0
2117: PPUSH
2118: CALL_OW 48
// end ;
2122: LD_VAR 0 1
2126: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2127: LD_INT 0
2129: PPUSH
2130: PPUSH
2131: PPUSH
2132: PPUSH
// uc_side := 1 ;
2133: LD_ADDR_OWVAR 20
2137: PUSH
2138: LD_INT 1
2140: ST_TO_ADDR
// uc_nation := 1 ;
2141: LD_ADDR_OWVAR 21
2145: PUSH
2146: LD_INT 1
2148: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_siberite , control_computer , us_laser ] , [ us_medium_tracked , engine_siberite , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_computer , us_radar ] , [ us_heavy_tracked , engine_siberite , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_siberite , control_computer , us_laser ] , [ us_medium_tracked , engine_siberite , control_computer , us_cargo_bay ] ] ;
2149: LD_ADDR_VAR 0 3
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: LD_INT 3
2162: PUSH
2163: LD_INT 9
2165: PUSH
2166: EMPTY
2167: LIST
2168: LIST
2169: LIST
2170: LIST
2171: PUSH
2172: LD_INT 3
2174: PUSH
2175: LD_INT 3
2177: PUSH
2178: LD_INT 3
2180: PUSH
2181: LD_INT 7
2183: PUSH
2184: EMPTY
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: PUSH
2190: LD_INT 3
2192: PUSH
2193: LD_INT 3
2195: PUSH
2196: LD_INT 3
2198: PUSH
2199: LD_INT 7
2201: PUSH
2202: EMPTY
2203: LIST
2204: LIST
2205: LIST
2206: LIST
2207: PUSH
2208: LD_INT 3
2210: PUSH
2211: LD_INT 3
2213: PUSH
2214: LD_INT 3
2216: PUSH
2217: LD_INT 11
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: LIST
2224: LIST
2225: PUSH
2226: LD_INT 4
2228: PUSH
2229: LD_INT 3
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 6
2237: PUSH
2238: EMPTY
2239: LIST
2240: LIST
2241: LIST
2242: LIST
2243: PUSH
2244: LD_INT 4
2246: PUSH
2247: LD_INT 3
2249: PUSH
2250: LD_INT 3
2252: PUSH
2253: LD_INT 9
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: LIST
2260: LIST
2261: PUSH
2262: LD_INT 3
2264: PUSH
2265: LD_INT 3
2267: PUSH
2268: LD_INT 3
2270: PUSH
2271: LD_INT 12
2273: PUSH
2274: EMPTY
2275: LIST
2276: LIST
2277: LIST
2278: LIST
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: LIST
2288: ST_TO_ADDR
// for i := 1 to [ 7 , 7 , 6 , 5 ] [ Difficulty ] do
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: DOUBLE
2295: LD_INT 1
2297: DEC
2298: ST_TO_ADDR
2299: LD_INT 7
2301: PUSH
2302: LD_INT 7
2304: PUSH
2305: LD_INT 6
2307: PUSH
2308: LD_INT 5
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: LIST
2315: LIST
2316: PUSH
2317: LD_OWVAR 67
2321: ARRAY
2322: PUSH
2323: FOR_TO
2324: IFFALSE 2498
// begin uc_side := 1 ;
2326: LD_ADDR_OWVAR 20
2330: PUSH
2331: LD_INT 1
2333: ST_TO_ADDR
// uc_nation := 1 ;
2334: LD_ADDR_OWVAR 21
2338: PUSH
2339: LD_INT 1
2341: ST_TO_ADDR
// vc_chassis := vehs [ i ] [ 1 ] ;
2342: LD_ADDR_OWVAR 37
2346: PUSH
2347: LD_VAR 0 3
2351: PUSH
2352: LD_VAR 0 2
2356: ARRAY
2357: PUSH
2358: LD_INT 1
2360: ARRAY
2361: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2362: LD_ADDR_OWVAR 39
2366: PUSH
2367: LD_VAR 0 3
2371: PUSH
2372: LD_VAR 0 2
2376: ARRAY
2377: PUSH
2378: LD_INT 2
2380: ARRAY
2381: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2382: LD_ADDR_OWVAR 38
2386: PUSH
2387: LD_VAR 0 3
2391: PUSH
2392: LD_VAR 0 2
2396: ARRAY
2397: PUSH
2398: LD_INT 3
2400: ARRAY
2401: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2402: LD_ADDR_OWVAR 40
2406: PUSH
2407: LD_VAR 0 3
2411: PUSH
2412: LD_VAR 0 2
2416: ARRAY
2417: PUSH
2418: LD_INT 4
2420: ARRAY
2421: ST_TO_ADDR
// veh := CreateVehicle ;
2422: LD_ADDR_VAR 0 4
2426: PUSH
2427: CALL_OW 45
2431: ST_TO_ADDR
// if vc_weapon = us_cargo_bay then
2432: LD_OWVAR 40
2436: PUSH
2437: LD_INT 12
2439: EQUAL
2440: IFFALSE 2457
// SetCargo ( veh , mat_cans , 100 ) ;
2442: LD_VAR 0 4
2446: PPUSH
2447: LD_INT 1
2449: PPUSH
2450: LD_INT 100
2452: PPUSH
2453: CALL_OW 290
// repeat wait ( 0 0$0.3 ) ;
2457: LD_INT 10
2459: PPUSH
2460: CALL_OW 67
// until PlaceUnitArea ( veh , am_veh_start , false ) ;
2464: LD_VAR 0 4
2468: PPUSH
2469: LD_INT 8
2471: PPUSH
2472: LD_INT 0
2474: PPUSH
2475: CALL_OW 49
2479: IFFALSE 2457
// ComMoveXY ( veh , 90 , 143 ) ;
2481: LD_VAR 0 4
2485: PPUSH
2486: LD_INT 90
2488: PPUSH
2489: LD_INT 143
2491: PPUSH
2492: CALL_OW 111
// end ;
2496: GO 2323
2498: POP
2499: POP
// wait ( 0 0$2 ) ;
2500: LD_INT 70
2502: PPUSH
2503: CALL_OW 67
// DialogueOn ;
2507: CALL_OW 6
// CenterNowOnXY ( 90 , 143 ) ;
2511: LD_INT 90
2513: PPUSH
2514: LD_INT 143
2516: PPUSH
2517: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2521: LD_INT 10
2523: PPUSH
2524: CALL_OW 68
// DialogueOff ;
2528: CALL_OW 7
// end ; end_of_file
2532: LD_VAR 0 1
2536: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2537: LD_INT 0
2539: PPUSH
2540: PPUSH
2541: PPUSH
2542: PPUSH
2543: PPUSH
2544: PPUSH
// if Difficulty = 1 then
2545: LD_OWVAR 67
2549: PUSH
2550: LD_INT 1
2552: EQUAL
2553: IFFALSE 2650
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2555: LD_ADDR_VAR 0 6
2559: PUSH
2560: LD_INT 129
2562: PUSH
2563: LD_INT 45
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PUSH
2570: LD_INT 143
2572: PUSH
2573: LD_INT 58
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: PUSH
2580: LD_INT 184
2582: PUSH
2583: LD_INT 113
2585: PUSH
2586: EMPTY
2587: LIST
2588: LIST
2589: PUSH
2590: LD_INT 163
2592: PUSH
2593: LD_INT 107
2595: PUSH
2596: EMPTY
2597: LIST
2598: LIST
2599: PUSH
2600: EMPTY
2601: LIST
2602: LIST
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// for i in tmp do
2606: LD_ADDR_VAR 0 2
2610: PUSH
2611: LD_VAR 0 6
2615: PUSH
2616: FOR_IN
2617: IFFALSE 2648
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2619: LD_VAR 0 2
2623: PUSH
2624: LD_INT 1
2626: ARRAY
2627: PPUSH
2628: LD_VAR 0 2
2632: PUSH
2633: LD_INT 2
2635: ARRAY
2636: PPUSH
2637: CALL_OW 428
2641: PPUSH
2642: CALL_OW 64
2646: GO 2616
2648: POP
2649: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2650: LD_ADDR_VAR 0 2
2654: PUSH
2655: LD_INT 21
2657: PUSH
2658: LD_INT 3
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PPUSH
2665: CALL_OW 69
2669: PUSH
2670: FOR_IN
2671: IFFALSE 2708
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2673: LD_VAR 0 2
2677: PPUSH
2678: LD_INT 5
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 8
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: PUSH
2696: LD_OWVAR 67
2700: ARRAY
2701: PPUSH
2702: CALL_OW 241
2706: GO 2670
2708: POP
2709: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2710: LD_ADDR_VAR 0 5
2714: PUSH
2715: LD_INT 5
2717: PUSH
2718: LD_INT 6
2720: PUSH
2721: LD_INT 7
2723: PUSH
2724: LD_INT 8
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_OWVAR 67
2737: ARRAY
2738: ST_TO_ADDR
// uc_side := 2 ;
2739: LD_ADDR_OWVAR 20
2743: PUSH
2744: LD_INT 2
2746: ST_TO_ADDR
// uc_nation := 2 ;
2747: LD_ADDR_OWVAR 21
2751: PUSH
2752: LD_INT 2
2754: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2755: LD_ADDR_OWVAR 37
2759: PUSH
2760: LD_INT 14
2762: ST_TO_ADDR
// vc_engine := engine_siberite ;
2763: LD_ADDR_OWVAR 39
2767: PUSH
2768: LD_INT 3
2770: ST_TO_ADDR
// vc_control := control_manual ;
2771: LD_ADDR_OWVAR 38
2775: PUSH
2776: LD_INT 1
2778: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2779: LD_ADDR_OWVAR 40
2783: PUSH
2784: LD_INT 31
2786: ST_TO_ADDR
// for i = 1 to 3 do
2787: LD_ADDR_VAR 0 2
2791: PUSH
2792: DOUBLE
2793: LD_INT 1
2795: DEC
2796: ST_TO_ADDR
2797: LD_INT 3
2799: PUSH
2800: FOR_TO
2801: IFFALSE 2885
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2803: LD_INT 0
2805: PPUSH
2806: LD_INT 3
2808: PPUSH
2809: LD_VAR 0 5
2813: PPUSH
2814: CALL_OW 380
// un := CreateVehicle ;
2818: LD_ADDR_VAR 0 4
2822: PUSH
2823: CALL_OW 45
2827: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2828: LD_VAR 0 4
2832: PPUSH
2833: LD_INT 0
2835: PPUSH
2836: LD_INT 5
2838: PPUSH
2839: CALL_OW 12
2843: PPUSH
2844: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2848: LD_VAR 0 4
2852: PPUSH
2853: LD_INT 156
2855: PPUSH
2856: LD_INT 15
2858: PPUSH
2859: LD_INT 6
2861: PPUSH
2862: LD_INT 0
2864: PPUSH
2865: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2869: CALL_OW 44
2873: PPUSH
2874: LD_VAR 0 4
2878: PPUSH
2879: CALL_OW 52
// end ;
2883: GO 2800
2885: POP
2886: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2887: LD_ADDR_EXP 37
2891: PUSH
2892: LD_INT 94
2894: PPUSH
2895: LD_INT 28
2897: PPUSH
2898: LD_STRING dammam
2900: PPUSH
2901: LD_VAR 0 5
2905: PPUSH
2906: LD_INT 10000
2908: PUSH
2909: LD_INT 1000
2911: PUSH
2912: LD_INT 300
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: LIST
2919: PPUSH
2920: LD_INT 12
2922: PUSH
2923: LD_INT 2
2925: PUSH
2926: LD_INT 3
2928: PUSH
2929: LD_INT 4
2931: PUSH
2932: LD_INT 4
2934: PUSH
2935: EMPTY
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_OWVAR 67
2945: ARRAY
2946: PUSH
2947: LD_INT 1
2949: NEG
2950: PUSH
2951: LD_INT 4
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: PPUSH
2960: CALL 58612 0 6
2964: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
2965: LD_ADDR_EXP 37
2969: PUSH
2970: LD_EXP 37
2974: PUSH
2975: LD_INT 122
2977: PPUSH
2978: LD_INT 25
2980: PPUSH
2981: LD_STRING 
2983: PPUSH
2984: LD_VAR 0 5
2988: PPUSH
2989: LD_INT 500
2991: PUSH
2992: LD_INT 60
2994: PUSH
2995: LD_INT 0
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: PPUSH
3003: LD_INT 8
3005: PUSH
3006: LD_INT 2
3008: PUSH
3009: LD_INT 3
3011: PUSH
3012: LD_INT 4
3014: PUSH
3015: LD_INT 5
3017: PUSH
3018: EMPTY
3019: LIST
3020: LIST
3021: LIST
3022: LIST
3023: PUSH
3024: LD_OWVAR 67
3028: ARRAY
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: LD_INT 0
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: LIST
3040: LIST
3041: PPUSH
3042: CALL 58612 0 6
3046: UNION
3047: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 900 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3048: LD_ADDR_EXP 35
3052: PUSH
3053: LD_INT 45
3055: PPUSH
3056: LD_INT 24
3058: PPUSH
3059: LD_STRING jeddah
3061: PPUSH
3062: LD_VAR 0 5
3066: PPUSH
3067: LD_INT 900
3069: PUSH
3070: LD_INT 300
3072: PUSH
3073: LD_INT 10
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: PPUSH
3081: LD_INT 9
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: LD_INT 3
3089: PUSH
3090: LD_INT 2
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PPUSH
3099: CALL 58612 0 6
3103: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3104: LD_ADDR_EXP 36
3108: PUSH
3109: LD_INT 7
3111: PPUSH
3112: LD_INT 27
3114: PPUSH
3115: LD_STRING riyadh
3117: PPUSH
3118: LD_VAR 0 5
3122: PPUSH
3123: LD_INT 500
3125: PUSH
3126: LD_INT 60
3128: PUSH
3129: LD_INT 0
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: PPUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 3
3145: PUSH
3146: LD_INT 1
3148: PUSH
3149: EMPTY
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: PPUSH
3155: CALL 58612 0 6
3159: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3160: LD_ADDR_EXP 39
3164: PUSH
3165: LD_INT 204
3167: PPUSH
3168: LD_INT 26
3170: PPUSH
3171: LD_STRING 
3173: PPUSH
3174: LD_VAR 0 5
3178: PPUSH
3179: LD_INT 500
3181: PUSH
3182: LD_INT 50
3184: PUSH
3185: LD_INT 0
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: LIST
3192: PPUSH
3193: LD_INT 9
3195: PUSH
3196: LD_INT 2
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: LD_INT 1
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: PPUSH
3211: CALL 58612 0 6
3215: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3216: LD_ADDR_EXP 50
3220: PUSH
3221: LD_EXP 37
3225: PUSH
3226: LD_EXP 35
3230: PUSH
3231: LD_EXP 39
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3241: LD_ADDR_VAR 0 2
3245: PUSH
3246: LD_INT 22
3248: PUSH
3249: LD_INT 2
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PUSH
3256: LD_INT 30
3258: PUSH
3259: LD_INT 31
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: LD_INT 58
3268: PUSH
3269: EMPTY
3270: LIST
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: LIST
3276: PPUSH
3277: CALL_OW 69
3281: PUSH
3282: FOR_IN
3283: IFFALSE 3408
// begin if GetBase ( i ) then
3285: LD_VAR 0 2
3289: PPUSH
3290: CALL_OW 274
3294: IFFALSE 3298
// continue ;
3296: GO 3282
// d := GetDir ( i ) ;
3298: LD_ADDR_VAR 0 3
3302: PUSH
3303: LD_VAR 0 2
3307: PPUSH
3308: CALL_OW 254
3312: ST_TO_ADDR
// if d < 3 then
3313: LD_VAR 0 3
3317: PUSH
3318: LD_INT 3
3320: LESS
3321: IFFALSE 3339
// d := d + 3 else
3323: LD_ADDR_VAR 0 3
3327: PUSH
3328: LD_VAR 0 3
3332: PUSH
3333: LD_INT 3
3335: PLUS
3336: ST_TO_ADDR
3337: GO 3353
// d := d - 3 ;
3339: LD_ADDR_VAR 0 3
3343: PUSH
3344: LD_VAR 0 3
3348: PUSH
3349: LD_INT 3
3351: MINUS
3352: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3353: LD_INT 0
3355: PPUSH
3356: LD_INT 8
3358: PPUSH
3359: LD_VAR 0 5
3363: PPUSH
3364: CALL_OW 380
// un := CreateHuman ;
3368: LD_ADDR_VAR 0 4
3372: PUSH
3373: CALL_OW 44
3377: ST_TO_ADDR
// SetDir ( un , d ) ;
3378: LD_VAR 0 4
3382: PPUSH
3383: LD_VAR 0 3
3387: PPUSH
3388: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3392: LD_VAR 0 4
3396: PPUSH
3397: LD_VAR 0 2
3401: PPUSH
3402: CALL_OW 52
// end ;
3406: GO 3282
3408: POP
3409: POP
// if Difficulty > 1 then
3410: LD_OWVAR 67
3414: PUSH
3415: LD_INT 1
3417: GREATER
3418: IFFALSE 3789
// begin ar_kamikadze := [ ] ;
3420: LD_ADDR_EXP 42
3424: PUSH
3425: EMPTY
3426: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3427: LD_INT 0
3429: PPUSH
3430: LD_INT 1
3432: PPUSH
3433: LD_VAR 0 5
3437: PPUSH
3438: CALL_OW 380
// un := CreateHuman ;
3442: LD_ADDR_VAR 0 4
3446: PUSH
3447: CALL_OW 44
3451: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3452: LD_VAR 0 4
3456: PPUSH
3457: LD_INT 3
3459: PPUSH
3460: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3464: LD_VAR 0 4
3468: PPUSH
3469: LD_INT 23
3471: PPUSH
3472: LD_INT 44
3474: PPUSH
3475: LD_INT 0
3477: PPUSH
3478: CALL_OW 48
// ComCrawl ( un ) ;
3482: LD_VAR 0 4
3486: PPUSH
3487: CALL_OW 137
// un := CreateHuman ;
3491: LD_ADDR_VAR 0 4
3495: PUSH
3496: CALL_OW 44
3500: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3501: LD_VAR 0 4
3505: PPUSH
3506: LD_INT 3
3508: PPUSH
3509: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3513: LD_VAR 0 4
3517: PPUSH
3518: LD_INT 30
3520: PPUSH
3521: LD_INT 39
3523: PPUSH
3524: LD_INT 0
3526: PPUSH
3527: CALL_OW 48
// ComCrawl ( un ) ;
3531: LD_VAR 0 4
3535: PPUSH
3536: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3540: LD_INT 0
3542: PPUSH
3543: LD_INT 17
3545: PPUSH
3546: LD_VAR 0 5
3550: PPUSH
3551: CALL_OW 380
// un := CreateHuman ;
3555: LD_ADDR_VAR 0 4
3559: PUSH
3560: CALL_OW 44
3564: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3565: LD_VAR 0 4
3569: PPUSH
3570: LD_INT 3
3572: PPUSH
3573: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3577: LD_VAR 0 4
3581: PPUSH
3582: LD_INT 45
3584: PPUSH
3585: LD_INT 86
3587: PPUSH
3588: LD_INT 0
3590: PPUSH
3591: CALL_OW 48
// ComHold ( un ) ;
3595: LD_VAR 0 4
3599: PPUSH
3600: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3604: LD_ADDR_EXP 42
3608: PUSH
3609: LD_EXP 42
3613: PPUSH
3614: LD_EXP 42
3618: PUSH
3619: LD_INT 1
3621: PLUS
3622: PPUSH
3623: LD_VAR 0 4
3627: PPUSH
3628: CALL_OW 1
3632: ST_TO_ADDR
// un := CreateHuman ;
3633: LD_ADDR_VAR 0 4
3637: PUSH
3638: CALL_OW 44
3642: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3643: LD_VAR 0 4
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3655: LD_VAR 0 4
3659: PPUSH
3660: LD_INT 60
3662: PPUSH
3663: LD_INT 85
3665: PPUSH
3666: LD_INT 0
3668: PPUSH
3669: CALL_OW 48
// ComHold ( un ) ;
3673: LD_VAR 0 4
3677: PPUSH
3678: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3682: LD_ADDR_EXP 42
3686: PUSH
3687: LD_EXP 42
3691: PPUSH
3692: LD_EXP 42
3696: PUSH
3697: LD_INT 1
3699: PLUS
3700: PPUSH
3701: LD_VAR 0 4
3705: PPUSH
3706: CALL_OW 1
3710: ST_TO_ADDR
// un := CreateHuman ;
3711: LD_ADDR_VAR 0 4
3715: PUSH
3716: CALL_OW 44
3720: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3721: LD_VAR 0 4
3725: PPUSH
3726: LD_INT 3
3728: PPUSH
3729: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3733: LD_VAR 0 4
3737: PPUSH
3738: LD_INT 222
3740: PPUSH
3741: LD_INT 166
3743: PPUSH
3744: LD_INT 0
3746: PPUSH
3747: CALL_OW 48
// ComHold ( un ) ;
3751: LD_VAR 0 4
3755: PPUSH
3756: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3760: LD_ADDR_EXP 42
3764: PUSH
3765: LD_EXP 42
3769: PPUSH
3770: LD_EXP 42
3774: PUSH
3775: LD_INT 1
3777: PLUS
3778: PPUSH
3779: LD_VAR 0 4
3783: PPUSH
3784: CALL_OW 1
3788: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3789: LD_ADDR_EXP 40
3793: PUSH
3794: EMPTY
3795: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 1
3801: PPUSH
3802: LD_VAR 0 5
3806: PPUSH
3807: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3811: LD_ADDR_OWVAR 26
3815: PUSH
3816: LD_STRING Pavel Grigorovic
3818: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3819: LD_ADDR_OWVAR 33
3823: PUSH
3824: LD_STRING SecondCharsGal
3826: ST_TO_ADDR
// hc_face_number := 4 ;
3827: LD_ADDR_OWVAR 34
3831: PUSH
3832: LD_INT 4
3834: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3835: LD_ADDR_EXP 40
3839: PUSH
3840: LD_EXP 40
3844: PPUSH
3845: LD_INT 1
3847: PPUSH
3848: CALL_OW 44
3852: PPUSH
3853: CALL_OW 1
3857: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3858: LD_INT 2
3860: PPUSH
3861: LD_INT 4
3863: PPUSH
3864: LD_INT 2
3866: PPUSH
3867: CALL_OW 380
// hc_name := Lucy Sebel ;
3871: LD_ADDR_OWVAR 26
3875: PUSH
3876: LD_STRING Lucy Sebel
3878: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3879: LD_ADDR_OWVAR 33
3883: PUSH
3884: LD_STRING SecondCharsGal
3886: ST_TO_ADDR
// hc_face_number := 15 ;
3887: LD_ADDR_OWVAR 34
3891: PUSH
3892: LD_INT 15
3894: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3895: LD_ADDR_EXP 40
3899: PUSH
3900: LD_EXP 40
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 44
3912: PPUSH
3913: CALL_OW 1
3917: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3918: LD_INT 2
3920: PPUSH
3921: LD_INT 4
3923: PPUSH
3924: LD_INT 2
3926: PPUSH
3927: CALL_OW 380
// hc_gallery :=  ;
3931: LD_ADDR_OWVAR 33
3935: PUSH
3936: LD_STRING 
3938: ST_TO_ADDR
// hc_name :=  ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING 
3946: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3947: LD_ADDR_EXP 40
3951: PUSH
3952: LD_EXP 40
3956: PPUSH
3957: LD_INT 3
3959: PPUSH
3960: CALL_OW 44
3964: PPUSH
3965: CALL_OW 1
3969: ST_TO_ADDR
// hc_sex := sex_male ;
3970: LD_ADDR_OWVAR 27
3974: PUSH
3975: LD_INT 1
3977: ST_TO_ADDR
// hc_class = 11 ;
3978: LD_ADDR_OWVAR 28
3982: PUSH
3983: LD_INT 11
3985: ST_TO_ADDR
// hc_gallery = sandar ;
3986: LD_ADDR_OWVAR 33
3990: PUSH
3991: LD_STRING sandar
3993: ST_TO_ADDR
// hc_face_number = 33 ;
3994: LD_ADDR_OWVAR 34
3998: PUSH
3999: LD_INT 33
4001: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4002: LD_ADDR_OWVAR 26
4006: PUSH
4007: LD_STRING Thabit Muhair Saliba
4009: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4010: LD_ADDR_OWVAR 31
4014: PUSH
4015: LD_INT 0
4017: PUSH
4018: LD_INT 0
4020: PUSH
4021: LD_INT 0
4023: PUSH
4024: LD_INT 0
4026: PUSH
4027: EMPTY
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: ST_TO_ADDR
// Saliba = CreateHuman ;
4033: LD_ADDR_EXP 44
4037: PUSH
4038: CALL_OW 44
4042: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4043: LD_EXP 44
4047: PPUSH
4048: LD_INT 7
4050: PPUSH
4051: CALL_OW 52
// if gensher_active then
4055: LD_EXP 18
4059: IFFALSE 4086
// begin Gensher = NewCharacter ( Dietrich ) ;
4061: LD_ADDR_EXP 45
4065: PUSH
4066: LD_STRING Dietrich
4068: PPUSH
4069: CALL_OW 25
4073: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4074: LD_EXP 45
4078: PPUSH
4079: LD_INT 94
4081: PPUSH
4082: CALL_OW 52
// end ; InitHc ;
4086: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4090: LD_ADDR_EXP 41
4094: PUSH
4095: EMPTY
4096: ST_TO_ADDR
// for i := 1 to 5 do
4097: LD_ADDR_VAR 0 2
4101: PUSH
4102: DOUBLE
4103: LD_INT 1
4105: DEC
4106: ST_TO_ADDR
4107: LD_INT 5
4109: PUSH
4110: FOR_TO
4111: IFFALSE 4283
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4113: LD_INT 13
4115: PUSH
4116: LD_INT 14
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_INT 2
4128: PPUSH
4129: CALL_OW 12
4133: ARRAY
4134: PPUSH
4135: LD_INT 1
4137: PUSH
4138: LD_INT 2
4140: PUSH
4141: EMPTY
4142: LIST
4143: LIST
4144: PUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_INT 2
4150: PPUSH
4151: CALL_OW 12
4155: ARRAY
4156: PPUSH
4157: LD_INT 1
4159: PPUSH
4160: LD_INT 25
4162: PUSH
4163: LD_INT 27
4165: PUSH
4166: LD_INT 26
4168: PUSH
4169: EMPTY
4170: LIST
4171: LIST
4172: LIST
4173: PUSH
4174: LD_INT 1
4176: PPUSH
4177: LD_INT 3
4179: PPUSH
4180: CALL_OW 12
4184: ARRAY
4185: PPUSH
4186: LD_INT 60
4188: PPUSH
4189: LD_INT 100
4191: PPUSH
4192: CALL_OW 12
4196: PPUSH
4197: CALL 54775 0 5
// un := CreateVehicle ;
4201: LD_ADDR_VAR 0 4
4205: PUSH
4206: CALL_OW 45
4210: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4211: LD_ADDR_EXP 41
4215: PUSH
4216: LD_EXP 41
4220: PPUSH
4221: LD_EXP 41
4225: PUSH
4226: LD_INT 1
4228: PLUS
4229: PPUSH
4230: LD_VAR 0 4
4234: PPUSH
4235: CALL_OW 1
4239: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4240: LD_VAR 0 4
4244: PPUSH
4245: LD_INT 0
4247: PPUSH
4248: LD_INT 5
4250: PPUSH
4251: CALL_OW 12
4255: PPUSH
4256: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4260: LD_VAR 0 4
4264: PPUSH
4265: LD_INT 124
4267: PPUSH
4268: LD_INT 141
4270: PPUSH
4271: LD_INT 8
4273: PPUSH
4274: LD_INT 0
4276: PPUSH
4277: CALL_OW 50
// end ;
4281: GO 4110
4283: POP
4284: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4285: LD_ADDR_EXP 43
4289: PUSH
4290: EMPTY
4291: PUSH
4292: EMPTY
4293: PUSH
4294: EMPTY
4295: PUSH
4296: EMPTY
4297: LIST
4298: LIST
4299: LIST
4300: ST_TO_ADDR
// for d := 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4301: LD_ADDR_VAR 0 3
4305: PUSH
4306: DOUBLE
4307: LD_INT 1
4309: DEC
4310: ST_TO_ADDR
4311: LD_INT 3
4313: PUSH
4314: LD_INT 3
4316: PUSH
4317: LD_INT 4
4319: PUSH
4320: LD_INT 4
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: LIST
4327: LIST
4328: PUSH
4329: LD_OWVAR 67
4333: ARRAY
4334: PUSH
4335: FOR_TO
4336: IFFALSE 4550
// for i := 1 to 3 do
4338: LD_ADDR_VAR 0 2
4342: PUSH
4343: DOUBLE
4344: LD_INT 1
4346: DEC
4347: ST_TO_ADDR
4348: LD_INT 3
4350: PUSH
4351: FOR_TO
4352: IFFALSE 4546
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4354: LD_INT 14
4356: PPUSH
4357: LD_INT 3
4359: PUSH
4360: LD_INT 2
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 1
4369: PPUSH
4370: LD_INT 2
4372: PPUSH
4373: CALL_OW 12
4377: ARRAY
4378: PPUSH
4379: LD_INT 1
4381: PUSH
4382: LD_INT 5
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 1
4391: PPUSH
4392: LD_INT 2
4394: PPUSH
4395: CALL_OW 12
4399: ARRAY
4400: PPUSH
4401: LD_INT 25
4403: PUSH
4404: LD_INT 27
4406: PUSH
4407: LD_INT 26
4409: PUSH
4410: LD_INT 28
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: LIST
4417: LIST
4418: PUSH
4419: LD_INT 1
4421: PPUSH
4422: LD_INT 4
4424: PPUSH
4425: CALL_OW 12
4429: ARRAY
4430: PPUSH
4431: LD_INT 100
4433: PPUSH
4434: CALL 54775 0 5
// un := CreateVehicle ;
4438: LD_ADDR_VAR 0 4
4442: PUSH
4443: CALL_OW 45
4447: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4448: LD_ADDR_EXP 43
4452: PUSH
4453: LD_EXP 43
4457: PPUSH
4458: LD_VAR 0 2
4462: PUSH
4463: LD_EXP 43
4467: PUSH
4468: LD_VAR 0 2
4472: ARRAY
4473: PUSH
4474: LD_INT 1
4476: PLUS
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PPUSH
4482: LD_VAR 0 4
4486: PPUSH
4487: CALL 54897 0 3
4491: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4492: LD_VAR 0 4
4496: PPUSH
4497: LD_INT 0
4499: PPUSH
4500: LD_INT 5
4502: PPUSH
4503: CALL_OW 12
4507: PPUSH
4508: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4512: LD_VAR 0 4
4516: PPUSH
4517: LD_INT 20
4519: PUSH
4520: LD_INT 21
4522: PUSH
4523: LD_INT 22
4525: PUSH
4526: EMPTY
4527: LIST
4528: LIST
4529: LIST
4530: PUSH
4531: LD_VAR 0 2
4535: ARRAY
4536: PPUSH
4537: LD_INT 0
4539: PPUSH
4540: CALL_OW 49
// end ;
4544: GO 4351
4546: POP
4547: POP
4548: GO 4335
4550: POP
4551: POP
// InitHc ;
4552: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4556: LD_INT 4
4558: PPUSH
4559: LD_INT 5
4561: PPUSH
4562: LD_INT 10
4564: PPUSH
4565: LD_INT 5
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 58
// end ;
4575: LD_VAR 0 1
4579: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4580: LD_EXP 42
4584: IFFALSE 4658
4586: GO 4588
4588: DISABLE
4589: LD_INT 0
4591: PPUSH
// begin enable ;
4592: ENABLE
// for i in ar_kamikadze do
4593: LD_ADDR_VAR 0 1
4597: PUSH
4598: LD_EXP 42
4602: PUSH
4603: FOR_IN
4604: IFFALSE 4656
// if See ( 1 , i ) then
4606: LD_INT 1
4608: PPUSH
4609: LD_VAR 0 1
4613: PPUSH
4614: CALL_OW 292
4618: IFFALSE 4654
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4620: LD_VAR 0 1
4624: PPUSH
4625: LD_INT 81
4627: PUSH
4628: LD_INT 2
4630: PUSH
4631: EMPTY
4632: LIST
4633: LIST
4634: PPUSH
4635: CALL_OW 69
4639: PPUSH
4640: LD_VAR 0 1
4644: PPUSH
4645: CALL_OW 74
4649: PPUSH
4650: CALL_OW 115
4654: GO 4603
4656: POP
4657: POP
// end ;
4658: PPOPN 1
4660: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4661: LD_EXP 13
4665: IFFALSE 4986
4667: GO 4669
4669: DISABLE
4670: LD_INT 0
4672: PPUSH
4673: PPUSH
4674: PPUSH
4675: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4676: LD_INT 35
4678: PPUSH
4679: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4683: LD_INT 1
4685: PPUSH
4686: CALL 43579 0 1
4690: PUSH
4691: LD_INT 0
4693: EQUAL
4694: IFFALSE 4676
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4696: LD_INT 1
4698: PPUSH
4699: LD_INT 14
4701: PUSH
4702: LD_INT 3
4704: PUSH
4705: LD_INT 2
4707: PUSH
4708: LD_INT 32
4710: PUSH
4711: EMPTY
4712: LIST
4713: LIST
4714: LIST
4715: LIST
4716: PUSH
4717: EMPTY
4718: LIST
4719: PPUSH
4720: CALL 43183 0 2
// repeat wait ( 0 0$1 ) ;
4724: LD_INT 35
4726: PPUSH
4727: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4731: LD_EXP 69
4735: PUSH
4736: LD_INT 1
4738: ARRAY
4739: PPUSH
4740: LD_INT 33
4742: PUSH
4743: LD_INT 2
4745: PUSH
4746: EMPTY
4747: LIST
4748: LIST
4749: PUSH
4750: LD_INT 34
4752: PUSH
4753: LD_INT 32
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PPUSH
4764: CALL_OW 72
4768: IFFALSE 4724
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4770: LD_ADDR_VAR 0 2
4774: PUSH
4775: LD_EXP 69
4779: PUSH
4780: LD_INT 1
4782: ARRAY
4783: PPUSH
4784: LD_INT 33
4786: PUSH
4787: LD_INT 2
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: LD_INT 34
4796: PUSH
4797: LD_INT 32
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PPUSH
4808: CALL_OW 72
4812: PUSH
4813: LD_INT 1
4815: ARRAY
4816: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4817: LD_ADDR_VAR 0 4
4821: PUSH
4822: LD_INT 5
4824: PPUSH
4825: CALL_OW 469
4829: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4830: LD_INT 35
4832: PPUSH
4833: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4837: LD_ADDR_VAR 0 4
4841: PUSH
4842: LD_INT 5
4844: PPUSH
4845: CALL_OW 469
4849: ST_TO_ADDR
// tmp := 100 ;
4850: LD_ADDR_VAR 0 3
4854: PUSH
4855: LD_INT 100
4857: ST_TO_ADDR
// if pos then
4858: LD_VAR 0 4
4862: IFFALSE 4902
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4864: LD_ADDR_VAR 0 3
4868: PUSH
4869: LD_INT 2
4871: PPUSH
4872: LD_VAR 0 4
4876: PUSH
4877: LD_INT 1
4879: ARRAY
4880: PPUSH
4881: LD_VAR 0 4
4885: PUSH
4886: LD_INT 2
4888: ARRAY
4889: PPUSH
4890: LD_INT 20
4892: PPUSH
4893: CALL 56167 0 4
4897: PUSH
4898: LD_INT 4
4900: ARRAY
4901: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4902: LD_VAR 0 4
4906: IFFALSE 4915
4908: PUSH
4909: LD_EXP 14
4913: NOT
4914: AND
4915: IFFALSE 4927
4917: PUSH
4918: LD_VAR 0 3
4922: PUSH
4923: LD_INT 10
4925: LESS
4926: AND
4927: IFFALSE 4830
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4929: LD_VAR 0 2
4933: PPUSH
4934: LD_VAR 0 4
4938: PUSH
4939: LD_INT 1
4941: ARRAY
4942: PPUSH
4943: LD_VAR 0 4
4947: PUSH
4948: LD_INT 2
4950: ARRAY
4951: PPUSH
4952: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4956: LD_VAR 0 2
4960: PPUSH
4961: LD_INT 198
4963: PPUSH
4964: LD_INT 113
4966: PPUSH
4967: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4971: LD_VAR 0 2
4975: PPUSH
4976: LD_INT 124
4978: PPUSH
4979: LD_INT 7
4981: PPUSH
4982: CALL_OW 171
// end ;
4986: PPOPN 4
4988: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
4989: LD_EXP 6
4993: IFFALSE 6956
4995: GO 4997
4997: DISABLE
4998: LD_INT 0
5000: PPUSH
5001: PPUSH
5002: PPUSH
5003: PPUSH
5004: PPUSH
5005: PPUSH
5006: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5007: LD_ADDR_VAR 0 4
5011: PUSH
5012: LD_INT 5
5014: PUSH
5015: LD_INT 6
5017: PUSH
5018: LD_INT 7
5020: PUSH
5021: LD_INT 8
5023: PUSH
5024: EMPTY
5025: LIST
5026: LIST
5027: LIST
5028: LIST
5029: PUSH
5030: LD_OWVAR 67
5034: ARRAY
5035: ST_TO_ADDR
// coords := [ ] ;
5036: LD_ADDR_VAR 0 5
5040: PUSH
5041: EMPTY
5042: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5043: LD_ADDR_VAR 0 6
5047: PUSH
5048: LD_INT 0
5050: PUSH
5051: LD_INT 0
5053: PUSH
5054: LD_INT 0
5056: PUSH
5057: LD_INT 0
5059: PUSH
5060: LD_INT 1
5062: PUSH
5063: LD_INT 0
5065: PUSH
5066: LD_INT 0
5068: PUSH
5069: LD_INT 0
5071: PUSH
5072: LD_INT 1
5074: PUSH
5075: LD_INT 0
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5090: LD_INT 1
5092: PPUSH
5093: LD_INT 14
5095: PUSH
5096: LD_INT 1
5098: PUSH
5099: LD_INT 2
5101: PUSH
5102: LD_INT 28
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 14
5113: PUSH
5114: LD_INT 1
5116: PUSH
5117: LD_INT 2
5119: PUSH
5120: LD_INT 25
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: LIST
5127: LIST
5128: PUSH
5129: LD_INT 14
5131: PUSH
5132: LD_INT 1
5134: PUSH
5135: LD_INT 2
5137: PUSH
5138: LD_INT 28
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: LIST
5145: LIST
5146: PUSH
5147: LD_INT 14
5149: PUSH
5150: LD_INT 1
5152: PUSH
5153: LD_INT 2
5155: PUSH
5156: LD_INT 29
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: LIST
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: PPUSH
5171: CALL 43183 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5175: LD_INT 21000
5177: PUSH
5178: LD_INT 19950
5180: PUSH
5181: LD_INT 18900
5183: PUSH
5184: LD_INT 18200
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: PUSH
5193: LD_OWVAR 67
5197: ARRAY
5198: PPUSH
5199: CALL_OW 67
// InitHc ;
5203: CALL_OW 19
// InitUc ;
5207: CALL_OW 18
// uc_side := 2 ;
5211: LD_ADDR_OWVAR 20
5215: PUSH
5216: LD_INT 2
5218: ST_TO_ADDR
// uc_nation := 2 ;
5219: LD_ADDR_OWVAR 21
5223: PUSH
5224: LD_INT 2
5226: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5227: LD_ADDR_VAR 0 3
5231: PUSH
5232: EMPTY
5233: PUSH
5234: EMPTY
5235: PUSH
5236: EMPTY
5237: PUSH
5238: EMPTY
5239: PUSH
5240: EMPTY
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5249: LD_ADDR_VAR 0 3
5253: PUSH
5254: LD_VAR 0 3
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: LD_EXP 69
5266: PUSH
5267: LD_INT 1
5269: ARRAY
5270: PUSH
5271: LD_INT 2
5273: PUSH
5274: LD_INT 34
5276: PUSH
5277: LD_INT 88
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PUSH
5284: LD_INT 34
5286: PUSH
5287: LD_INT 32
5289: PUSH
5290: EMPTY
5291: LIST
5292: LIST
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: PPUSH
5299: CALL_OW 69
5303: DIFF
5304: PPUSH
5305: CALL_OW 1
5309: ST_TO_ADDR
// for i = 1 to Difficulty do
5310: LD_ADDR_VAR 0 1
5314: PUSH
5315: DOUBLE
5316: LD_INT 1
5318: DEC
5319: ST_TO_ADDR
5320: LD_OWVAR 67
5324: PUSH
5325: FOR_TO
5326: IFFALSE 5464
// begin uc_side := 2 ;
5328: LD_ADDR_OWVAR 20
5332: PUSH
5333: LD_INT 2
5335: ST_TO_ADDR
// uc_nation := 2 ;
5336: LD_ADDR_OWVAR 21
5340: PUSH
5341: LD_INT 2
5343: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5344: LD_INT 13
5346: PPUSH
5347: LD_INT 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 29
5355: PPUSH
5356: LD_INT 100
5358: PPUSH
5359: CALL 54775 0 5
// un := CreateVehicle ;
5363: LD_ADDR_VAR 0 2
5367: PUSH
5368: CALL_OW 45
5372: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5373: LD_ADDR_VAR 0 3
5377: PUSH
5378: LD_VAR 0 3
5382: PPUSH
5383: LD_INT 1
5385: PUSH
5386: LD_VAR 0 3
5390: PUSH
5391: LD_INT 1
5393: ARRAY
5394: PUSH
5395: LD_INT 1
5397: PLUS
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: PPUSH
5403: LD_VAR 0 2
5407: PPUSH
5408: CALL 54897 0 3
5412: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5413: LD_VAR 0 2
5417: PPUSH
5418: LD_INT 3
5420: PPUSH
5421: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5425: LD_VAR 0 2
5429: PPUSH
5430: LD_INT 16
5432: PPUSH
5433: LD_INT 0
5435: PPUSH
5436: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5440: LD_VAR 0 2
5444: PPUSH
5445: LD_INT 51
5447: PPUSH
5448: LD_INT 10
5450: PPUSH
5451: CALL_OW 111
// wait ( 0 0$2 ) ;
5455: LD_INT 70
5457: PPUSH
5458: CALL_OW 67
// end ;
5462: GO 5325
5464: POP
5465: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5466: LD_ADDR_VAR 0 5
5470: PUSH
5471: LD_INT 51
5473: PUSH
5474: LD_INT 24
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: PUSH
5481: LD_INT 75
5483: PUSH
5484: LD_INT 90
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5495: LD_INT 1
5497: PPUSH
5498: LD_VAR 0 3
5502: PUSH
5503: LD_INT 1
5505: ARRAY
5506: PPUSH
5507: LD_VAR 0 5
5511: PPUSH
5512: LD_VAR 0 6
5516: PPUSH
5517: CALL 43416 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5521: LD_ADDR_VAR 0 1
5525: PUSH
5526: DOUBLE
5527: LD_INT 1
5529: DEC
5530: ST_TO_ADDR
5531: LD_INT 1
5533: PUSH
5534: LD_INT 3
5536: PUSH
5537: LD_INT 4
5539: PUSH
5540: LD_INT 5
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_OWVAR 67
5553: ARRAY
5554: PUSH
5555: FOR_TO
5556: IFFALSE 5656
// begin uc_side := 2 ;
5558: LD_ADDR_OWVAR 20
5562: PUSH
5563: LD_INT 2
5565: ST_TO_ADDR
// uc_nation := 2 ;
5566: LD_ADDR_OWVAR 21
5570: PUSH
5571: LD_INT 2
5573: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5574: LD_INT 0
5576: PPUSH
5577: LD_INT 17
5579: PPUSH
5580: LD_VAR 0 4
5584: PPUSH
5585: CALL_OW 380
// un := CreateHuman ;
5589: LD_ADDR_VAR 0 2
5593: PUSH
5594: CALL_OW 44
5598: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5599: LD_ADDR_VAR 0 3
5603: PUSH
5604: LD_VAR 0 3
5608: PPUSH
5609: LD_INT 2
5611: PUSH
5612: LD_VAR 0 3
5616: PUSH
5617: LD_INT 2
5619: ARRAY
5620: PUSH
5621: LD_INT 1
5623: PLUS
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: PPUSH
5629: LD_VAR 0 2
5633: PPUSH
5634: CALL 54897 0 3
5638: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5639: LD_VAR 0 2
5643: PPUSH
5644: LD_INT 13
5646: PPUSH
5647: LD_INT 0
5649: PPUSH
5650: CALL_OW 49
// end ;
5654: GO 5555
5656: POP
5657: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5658: LD_ADDR_VAR 0 1
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_INT 3
5670: PUSH
5671: LD_INT 4
5673: PUSH
5674: LD_INT 5
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_OWVAR 67
5690: ARRAY
5691: PUSH
5692: FOR_TO
5693: IFFALSE 5814
// begin uc_side := 2 ;
5695: LD_ADDR_OWVAR 20
5699: PUSH
5700: LD_INT 2
5702: ST_TO_ADDR
// uc_nation := 2 ;
5703: LD_ADDR_OWVAR 21
5707: PUSH
5708: LD_INT 2
5710: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5711: LD_INT 0
5713: PPUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 8
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: PUSH
5724: LD_VAR 0 1
5728: PUSH
5729: LD_INT 2
5731: MOD
5732: PUSH
5733: LD_INT 1
5735: PLUS
5736: ARRAY
5737: PPUSH
5738: LD_VAR 0 4
5742: PPUSH
5743: CALL_OW 380
// un := CreateHuman ;
5747: LD_ADDR_VAR 0 2
5751: PUSH
5752: CALL_OW 44
5756: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5757: LD_ADDR_VAR 0 3
5761: PUSH
5762: LD_VAR 0 3
5766: PPUSH
5767: LD_INT 2
5769: PUSH
5770: LD_VAR 0 3
5774: PUSH
5775: LD_INT 2
5777: ARRAY
5778: PUSH
5779: LD_INT 1
5781: PLUS
5782: PUSH
5783: EMPTY
5784: LIST
5785: LIST
5786: PPUSH
5787: LD_VAR 0 2
5791: PPUSH
5792: CALL 54897 0 3
5796: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5797: LD_VAR 0 2
5801: PPUSH
5802: LD_INT 13
5804: PPUSH
5805: LD_INT 0
5807: PPUSH
5808: CALL_OW 49
// end ;
5812: GO 5692
5814: POP
5815: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5816: LD_ADDR_VAR 0 5
5820: PUSH
5821: LD_INT 67
5823: PUSH
5824: LD_INT 112
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: PUSH
5831: LD_INT 85
5833: PUSH
5834: LD_INT 130
5836: PUSH
5837: EMPTY
5838: LIST
5839: LIST
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5845: LD_INT 2
5847: PPUSH
5848: LD_VAR 0 3
5852: PUSH
5853: LD_INT 2
5855: ARRAY
5856: PPUSH
5857: LD_VAR 0 5
5861: PPUSH
5862: LD_VAR 0 6
5866: PPUSH
5867: CALL 43416 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5871: LD_ADDR_VAR 0 1
5875: PUSH
5876: DOUBLE
5877: LD_INT 1
5879: DEC
5880: ST_TO_ADDR
5881: LD_INT 1
5883: PUSH
5884: LD_INT 2
5886: PUSH
5887: LD_INT 3
5889: PUSH
5890: LD_INT 5
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_OWVAR 67
5903: ARRAY
5904: PUSH
5905: FOR_TO
5906: IFFALSE 6006
// begin uc_side := 2 ;
5908: LD_ADDR_OWVAR 20
5912: PUSH
5913: LD_INT 2
5915: ST_TO_ADDR
// uc_nation := 2 ;
5916: LD_ADDR_OWVAR 21
5920: PUSH
5921: LD_INT 2
5923: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5924: LD_INT 0
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_VAR 0 4
5934: PPUSH
5935: CALL_OW 380
// un := CreateHuman ;
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: CALL_OW 44
5948: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5949: LD_ADDR_VAR 0 3
5953: PUSH
5954: LD_VAR 0 3
5958: PPUSH
5959: LD_INT 3
5961: PUSH
5962: LD_VAR 0 3
5966: PUSH
5967: LD_INT 3
5969: ARRAY
5970: PUSH
5971: LD_INT 1
5973: PLUS
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PPUSH
5979: LD_VAR 0 2
5983: PPUSH
5984: CALL 54897 0 3
5988: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5989: LD_VAR 0 2
5993: PPUSH
5994: LD_INT 14
5996: PPUSH
5997: LD_INT 0
5999: PPUSH
6000: CALL_OW 49
// end ;
6004: GO 5905
6006: POP
6007: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6008: LD_ADDR_VAR 0 5
6012: PUSH
6013: LD_INT 148
6015: PUSH
6016: LD_INT 158
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 148
6025: PUSH
6026: LD_INT 158
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6037: LD_INT 3
6039: PPUSH
6040: LD_VAR 0 3
6044: PUSH
6045: LD_INT 3
6047: ARRAY
6048: PPUSH
6049: LD_VAR 0 5
6053: PPUSH
6054: LD_VAR 0 6
6058: PPUSH
6059: CALL 43416 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6063: LD_ADDR_VAR 0 1
6067: PUSH
6068: DOUBLE
6069: LD_INT 1
6071: DEC
6072: ST_TO_ADDR
6073: LD_INT 2
6075: PUSH
6076: LD_INT 3
6078: PUSH
6079: LD_INT 4
6081: PUSH
6082: LD_INT 5
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: LD_OWVAR 67
6095: ARRAY
6096: PUSH
6097: FOR_TO
6098: IFFALSE 6322
// begin uc_side := 2 ;
6100: LD_ADDR_OWVAR 20
6104: PUSH
6105: LD_INT 2
6107: ST_TO_ADDR
// uc_nation := 2 ;
6108: LD_ADDR_OWVAR 21
6112: PUSH
6113: LD_INT 2
6115: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6116: LD_INT 14
6118: PPUSH
6119: LD_INT 3
6121: PPUSH
6122: LD_INT 1
6124: PUSH
6125: LD_INT 5
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 1
6134: PPUSH
6135: LD_INT 2
6137: PPUSH
6138: CALL_OW 12
6142: ARRAY
6143: PPUSH
6144: LD_INT 27
6146: PUSH
6147: LD_INT 26
6149: PUSH
6150: LD_INT 28
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: LIST
6157: PUSH
6158: LD_INT 1
6160: PPUSH
6161: LD_INT 3
6163: PPUSH
6164: CALL_OW 12
6168: ARRAY
6169: PPUSH
6170: LD_INT 100
6172: PPUSH
6173: CALL 54775 0 5
// un := CreateVehicle ;
6177: LD_ADDR_VAR 0 2
6181: PUSH
6182: CALL_OW 45
6186: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6187: LD_ADDR_VAR 0 3
6191: PUSH
6192: LD_VAR 0 3
6196: PPUSH
6197: LD_INT 4
6199: PUSH
6200: LD_VAR 0 3
6204: PUSH
6205: LD_INT 4
6207: ARRAY
6208: PUSH
6209: LD_INT 1
6211: PLUS
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: PPUSH
6217: LD_VAR 0 2
6221: PPUSH
6222: CALL 54897 0 3
6226: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_INT 5
6234: PPUSH
6235: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6239: LD_VAR 0 2
6243: PPUSH
6244: LD_INT 15
6246: PPUSH
6247: LD_INT 0
6249: PPUSH
6250: CALL_OW 49
// if GetControl ( un ) = control_manual then
6254: LD_VAR 0 2
6258: PPUSH
6259: CALL_OW 263
6263: PUSH
6264: LD_INT 1
6266: EQUAL
6267: IFFALSE 6298
// begin PrepareHuman ( false , 3 , skill ) ;
6269: LD_INT 0
6271: PPUSH
6272: LD_INT 3
6274: PPUSH
6275: LD_VAR 0 4
6279: PPUSH
6280: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6284: CALL_OW 44
6288: PPUSH
6289: LD_VAR 0 2
6293: PPUSH
6294: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6298: LD_VAR 0 2
6302: PPUSH
6303: LD_INT 179
6305: PPUSH
6306: LD_INT 135
6308: PPUSH
6309: CALL_OW 111
// wait ( 0 0$2 ) ;
6313: LD_INT 70
6315: PPUSH
6316: CALL_OW 67
// end ;
6320: GO 6097
6322: POP
6323: POP
// vc_chassis := 15 ;
6324: LD_ADDR_OWVAR 37
6328: PUSH
6329: LD_INT 15
6331: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6332: LD_ADDR_VAR 0 3
6336: PUSH
6337: LD_VAR 0 3
6341: PPUSH
6342: LD_INT 4
6344: PUSH
6345: LD_VAR 0 3
6349: PUSH
6350: LD_INT 4
6352: ARRAY
6353: PUSH
6354: LD_INT 1
6356: PLUS
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: PPUSH
6362: CALL_OW 45
6366: PPUSH
6367: CALL 54897 0 3
6371: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6372: LD_VAR 0 3
6376: PUSH
6377: LD_INT 4
6379: ARRAY
6380: PUSH
6381: LD_VAR 0 3
6385: PUSH
6386: LD_INT 4
6388: ARRAY
6389: ARRAY
6390: PPUSH
6391: LD_INT 15
6393: PPUSH
6394: LD_INT 0
6396: PPUSH
6397: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6401: LD_INT 0
6403: PPUSH
6404: LD_INT 11
6406: PPUSH
6407: LD_VAR 0 4
6411: PPUSH
6412: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6416: LD_ADDR_VAR 0 3
6420: PUSH
6421: LD_VAR 0 3
6425: PPUSH
6426: LD_INT 4
6428: PUSH
6429: LD_VAR 0 3
6433: PUSH
6434: LD_INT 4
6436: ARRAY
6437: PUSH
6438: LD_INT 1
6440: PLUS
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PPUSH
6446: CALL_OW 44
6450: PPUSH
6451: CALL 54897 0 3
6455: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6456: LD_VAR 0 3
6460: PUSH
6461: LD_INT 4
6463: ARRAY
6464: PUSH
6465: LD_VAR 0 3
6469: PUSH
6470: LD_INT 4
6472: ARRAY
6473: ARRAY
6474: PPUSH
6475: LD_VAR 0 3
6479: PUSH
6480: LD_INT 4
6482: ARRAY
6483: PUSH
6484: LD_VAR 0 3
6488: PUSH
6489: LD_INT 4
6491: ARRAY
6492: PUSH
6493: LD_INT 1
6495: MINUS
6496: ARRAY
6497: PPUSH
6498: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6502: LD_ADDR_VAR 0 5
6506: PUSH
6507: LD_INT 148
6509: PUSH
6510: LD_INT 140
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: PUSH
6517: EMPTY
6518: LIST
6519: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6520: LD_INT 1
6522: PPUSH
6523: LD_VAR 0 3
6527: PUSH
6528: LD_INT 4
6530: ARRAY
6531: PPUSH
6532: LD_VAR 0 5
6536: PPUSH
6537: LD_VAR 0 6
6541: PPUSH
6542: CALL 43416 0 4
// if gensher_active then
6546: LD_EXP 18
6550: IFFALSE 6956
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6552: LD_EXP 45
6556: PPUSH
6557: LD_STRING D10-Diet-1
6559: PPUSH
6560: CALL_OW 94
// for i = 1 to 2 do
6564: LD_ADDR_VAR 0 1
6568: PUSH
6569: DOUBLE
6570: LD_INT 1
6572: DEC
6573: ST_TO_ADDR
6574: LD_INT 2
6576: PUSH
6577: FOR_TO
6578: IFFALSE 6716
// begin uc_side := 2 ;
6580: LD_ADDR_OWVAR 20
6584: PUSH
6585: LD_INT 2
6587: ST_TO_ADDR
// uc_nation := 2 ;
6588: LD_ADDR_OWVAR 21
6592: PUSH
6593: LD_INT 2
6595: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6596: LD_INT 13
6598: PPUSH
6599: LD_INT 3
6601: PPUSH
6602: LD_INT 5
6604: PPUSH
6605: LD_INT 29
6607: PPUSH
6608: LD_INT 100
6610: PPUSH
6611: CALL 54775 0 5
// un := CreateVehicle ;
6615: LD_ADDR_VAR 0 2
6619: PUSH
6620: CALL_OW 45
6624: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6625: LD_ADDR_VAR 0 3
6629: PUSH
6630: LD_VAR 0 3
6634: PPUSH
6635: LD_INT 5
6637: PUSH
6638: LD_VAR 0 3
6642: PUSH
6643: LD_INT 5
6645: ARRAY
6646: PUSH
6647: LD_INT 1
6649: PLUS
6650: PUSH
6651: EMPTY
6652: LIST
6653: LIST
6654: PPUSH
6655: LD_VAR 0 2
6659: PPUSH
6660: CALL 54897 0 3
6664: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6665: LD_VAR 0 2
6669: PPUSH
6670: LD_INT 0
6672: PPUSH
6673: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6677: LD_VAR 0 2
6681: PPUSH
6682: LD_INT 23
6684: PPUSH
6685: LD_INT 0
6687: PPUSH
6688: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6692: LD_VAR 0 2
6696: PPUSH
6697: LD_INT 85
6699: PPUSH
6700: LD_INT 152
6702: PPUSH
6703: CALL_OW 111
// wait ( 0 0$2 ) ;
6707: LD_INT 70
6709: PPUSH
6710: CALL_OW 67
// end ;
6714: GO 6577
6716: POP
6717: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6718: LD_ADDR_VAR 0 1
6722: PUSH
6723: DOUBLE
6724: LD_INT 1
6726: DEC
6727: ST_TO_ADDR
6728: LD_INT 2
6730: PUSH
6731: LD_INT 3
6733: PUSH
6734: LD_INT 3
6736: PUSH
6737: LD_INT 4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: LIST
6745: PUSH
6746: LD_OWVAR 67
6750: ARRAY
6751: PUSH
6752: FOR_TO
6753: IFFALSE 6910
// begin uc_side := 2 ;
6755: LD_ADDR_OWVAR 20
6759: PUSH
6760: LD_INT 2
6762: ST_TO_ADDR
// uc_nation := 2 ;
6763: LD_ADDR_OWVAR 21
6767: PUSH
6768: LD_INT 2
6770: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6771: LD_INT 14
6773: PPUSH
6774: LD_INT 3
6776: PPUSH
6777: LD_INT 5
6779: PPUSH
6780: LD_INT 27
6782: PUSH
6783: LD_INT 28
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: PUSH
6790: LD_INT 1
6792: PPUSH
6793: LD_INT 2
6795: PPUSH
6796: CALL_OW 12
6800: ARRAY
6801: PPUSH
6802: LD_INT 100
6804: PPUSH
6805: CALL 54775 0 5
// un := CreateVehicle ;
6809: LD_ADDR_VAR 0 2
6813: PUSH
6814: CALL_OW 45
6818: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6819: LD_ADDR_VAR 0 3
6823: PUSH
6824: LD_VAR 0 3
6828: PPUSH
6829: LD_INT 5
6831: PUSH
6832: LD_VAR 0 3
6836: PUSH
6837: LD_INT 5
6839: ARRAY
6840: PUSH
6841: LD_INT 1
6843: PLUS
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PPUSH
6849: LD_VAR 0 2
6853: PPUSH
6854: CALL 54897 0 3
6858: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6859: LD_VAR 0 2
6863: PPUSH
6864: LD_INT 0
6866: PPUSH
6867: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 23
6878: PPUSH
6879: LD_INT 0
6881: PPUSH
6882: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6886: LD_VAR 0 2
6890: PPUSH
6891: LD_INT 85
6893: PPUSH
6894: LD_INT 152
6896: PPUSH
6897: CALL_OW 111
// wait ( 0 0$2 ) ;
6901: LD_INT 70
6903: PPUSH
6904: CALL_OW 67
// end ;
6908: GO 6752
6910: POP
6911: POP
// coords := [ [ 97 , 143 ] ] ;
6912: LD_ADDR_VAR 0 5
6916: PUSH
6917: LD_INT 97
6919: PUSH
6920: LD_INT 143
6922: PUSH
6923: EMPTY
6924: LIST
6925: LIST
6926: PUSH
6927: EMPTY
6928: LIST
6929: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6930: LD_INT 1
6932: PPUSH
6933: LD_VAR 0 3
6937: PUSH
6938: LD_INT 5
6940: ARRAY
6941: PPUSH
6942: LD_VAR 0 5
6946: PPUSH
6947: LD_VAR 0 6
6951: PPUSH
6952: CALL 43416 0 4
// end ; end ;
6956: PPOPN 7
6958: END
// every 4 4$0 + 15 15$0 do var i , tmp , enemy , tmp2 , coords , w , list , p ;
6959: GO 6961
6961: DISABLE
6962: LD_INT 0
6964: PPUSH
6965: PPUSH
6966: PPUSH
6967: PPUSH
6968: PPUSH
6969: PPUSH
6970: PPUSH
6971: PPUSH
// begin tmp := [ ] ;
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: EMPTY
6978: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
6979: LD_ADDR_VAR 0 6
6983: PUSH
6984: LD_INT 1
6986: PPUSH
6987: LD_INT 3
6989: PPUSH
6990: CALL_OW 12
6994: ST_TO_ADDR
// if w = 3 then
6995: LD_VAR 0 6
6999: PUSH
7000: LD_INT 3
7002: EQUAL
7003: IFFALSE 7090
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7005: LD_ADDR_VAR 0 7
7009: PUSH
7010: LD_INT 11
7012: PUSH
7013: LD_INT 1
7015: PUSH
7016: LD_INT 2
7018: PUSH
7019: LD_INT 24
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: PUSH
7028: LD_INT 11
7030: PUSH
7031: LD_INT 1
7033: PUSH
7034: LD_INT 2
7036: PUSH
7037: LD_INT 24
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: LIST
7044: LIST
7045: PUSH
7046: LD_INT 11
7048: PUSH
7049: LD_INT 1
7051: PUSH
7052: LD_INT 2
7054: PUSH
7055: LD_INT 24
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: LIST
7062: LIST
7063: PUSH
7064: LD_INT 11
7066: PUSH
7067: LD_INT 1
7069: PUSH
7070: LD_INT 2
7072: PUSH
7073: LD_INT 24
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: ST_TO_ADDR
7088: GO 7192
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7090: LD_ADDR_VAR 0 7
7094: PUSH
7095: LD_INT 14
7097: PUSH
7098: LD_INT 1
7100: PUSH
7101: LD_INT 2
7103: PUSH
7104: LD_INT 28
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: LIST
7111: LIST
7112: PUSH
7113: LD_INT 14
7115: PUSH
7116: LD_INT 1
7118: PUSH
7119: LD_INT 2
7121: PUSH
7122: LD_INT 25
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: LIST
7129: LIST
7130: PUSH
7131: LD_INT 14
7133: PUSH
7134: LD_INT 1
7136: PUSH
7137: LD_INT 2
7139: PUSH
7140: LD_INT 28
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: LIST
7147: LIST
7148: PUSH
7149: LD_INT 14
7151: PUSH
7152: LD_INT 1
7154: PUSH
7155: LD_INT 2
7157: PUSH
7158: LD_INT 29
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_INT 14
7169: PUSH
7170: LD_INT 1
7172: PUSH
7173: LD_INT 2
7175: PUSH
7176: LD_INT 29
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: LIST
7183: LIST
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: LIST
7191: ST_TO_ADDR
// if w < 3 then
7192: LD_VAR 0 6
7196: PUSH
7197: LD_INT 3
7199: LESS
7200: IFFALSE 7280
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7202: LD_ADDR_VAR 0 7
7206: PUSH
7207: LD_VAR 0 7
7211: PPUSH
7212: LD_INT 1
7214: PUSH
7215: LD_VAR 0 7
7219: PUSH
7220: LD_VAR 0 1
7224: ARRAY
7225: PUSH
7226: LD_INT 1
7228: PLUS
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PPUSH
7234: LD_INT 14
7236: PUSH
7237: LD_INT 1
7239: PUSH
7240: LD_INT 2
7242: PUSH
7243: LD_INT 25
7245: PUSH
7246: LD_INT 28
7248: PUSH
7249: LD_INT 29
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: LIST
7256: PUSH
7257: LD_INT 1
7259: PPUSH
7260: LD_INT 3
7262: PPUSH
7263: CALL_OW 12
7267: ARRAY
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: PPUSH
7275: CALL 54897 0 3
7279: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7280: LD_INT 1
7282: PPUSH
7283: LD_VAR 0 7
7287: PPUSH
7288: CALL 43183 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7292: LD_INT 45
7294: PPUSH
7295: CALL_OW 255
7299: PUSH
7300: LD_INT 2
7302: EQUAL
7303: IFFALSE 7314
7305: PUSH
7306: LD_INT 45
7308: PPUSH
7309: CALL_OW 302
7313: AND
7314: IFFALSE 7326
7316: PUSH
7317: LD_VAR 0 6
7321: PUSH
7322: LD_INT 3
7324: LESS
7325: AND
7326: IFFALSE 7411
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7328: LD_ADDR_VAR 0 7
7332: PUSH
7333: LD_INT 14
7335: PUSH
7336: LD_INT 1
7338: PUSH
7339: LD_INT 2
7341: PUSH
7342: LD_INT 28
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: LIST
7349: LIST
7350: PUSH
7351: LD_INT 14
7353: PUSH
7354: LD_INT 1
7356: PUSH
7357: LD_INT 2
7359: PUSH
7360: LD_INT 27
7362: PUSH
7363: EMPTY
7364: LIST
7365: LIST
7366: LIST
7367: LIST
7368: PUSH
7369: LD_INT 14
7371: PUSH
7372: LD_INT 1
7374: PUSH
7375: LD_INT 2
7377: PUSH
7378: LD_INT 27
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7392: LD_INT 2
7394: PPUSH
7395: LD_VAR 0 7
7399: PPUSH
7400: CALL 43183 0 2
// wait ( 0 0$20 ) ;
7404: LD_INT 700
7406: PPUSH
7407: CALL_OW 67
// end ; p := 60 ;
7411: LD_ADDR_VAR 0 8
7415: PUSH
7416: LD_INT 60
7418: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7419: LD_INT 35
7421: PPUSH
7422: CALL_OW 67
// p := Dec ( p ) ;
7426: LD_ADDR_VAR 0 8
7430: PUSH
7431: LD_VAR 0 8
7435: PPUSH
7436: CALL 89350 0 1
7440: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 or p <= 0 ;
7441: LD_EXP 69
7445: PUSH
7446: LD_INT 1
7448: ARRAY
7449: PPUSH
7450: LD_INT 3
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: LD_INT 34
7458: PUSH
7459: LD_INT 32
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: LD_INT 34
7468: PUSH
7469: LD_INT 88
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: LIST
7480: PUSH
7481: EMPTY
7482: LIST
7483: LIST
7484: PPUSH
7485: CALL_OW 72
7489: PUSH
7490: LD_INT 4
7492: GREATEREQUAL
7493: IFTRUE 7505
7495: PUSH
7496: LD_VAR 0 8
7500: PUSH
7501: LD_INT 0
7503: LESSEQUAL
7504: OR
7505: IFFALSE 7419
// wait ( 0 0$10 ) ;
7507: LD_INT 350
7509: PPUSH
7510: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7514: LD_ADDR_VAR 0 2
7518: PUSH
7519: LD_EXP 69
7523: PUSH
7524: LD_INT 1
7526: ARRAY
7527: PPUSH
7528: LD_INT 3
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 34
7536: PUSH
7537: LD_INT 32
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 34
7546: PUSH
7547: LD_INT 88
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: LIST
7558: PUSH
7559: EMPTY
7560: LIST
7561: LIST
7562: PPUSH
7563: CALL_OW 72
7567: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7568: LD_ADDR_VAR 0 4
7572: PUSH
7573: LD_EXP 69
7577: PUSH
7578: LD_INT 2
7580: ARRAY
7581: PPUSH
7582: LD_INT 3
7584: PUSH
7585: LD_INT 2
7587: PUSH
7588: LD_INT 34
7590: PUSH
7591: LD_INT 32
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 34
7600: PUSH
7601: LD_INT 88
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 72
7621: ST_TO_ADDR
// if tmp2 then
7622: LD_VAR 0 4
7626: IFFALSE 7644
// tmp := tmp union tmp2 ;
7628: LD_ADDR_VAR 0 2
7632: PUSH
7633: LD_VAR 0 2
7637: PUSH
7638: LD_VAR 0 4
7642: UNION
7643: ST_TO_ADDR
// if not tmp then
7644: LD_VAR 0 2
7648: NOT
7649: IFFALSE 7654
// begin enable ;
7651: ENABLE
// exit ;
7652: GO 8054
// end ; if Count ( tmp2 ) or Prob ( 50 ) then
7654: LD_VAR 0 4
7658: PPUSH
7659: CALL 51979 0 1
7663: IFTRUE 7674
7665: PUSH
7666: LD_INT 50
7668: PPUSH
7669: CALL_OW 13
7673: OR
7674: IFFALSE 7707
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7676: LD_ADDR_VAR 0 5
7680: PUSH
7681: LD_INT 48
7683: PUSH
7684: LD_INT 33
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 71
7693: PUSH
7694: LD_INT 88
7696: PUSH
7697: EMPTY
7698: LIST
7699: LIST
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: ST_TO_ADDR
7705: GO 7736
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7707: LD_ADDR_VAR 0 5
7711: PUSH
7712: LD_INT 128
7714: PUSH
7715: LD_INT 94
7717: PUSH
7718: EMPTY
7719: LIST
7720: LIST
7721: PUSH
7722: LD_INT 180
7724: PUSH
7725: LD_INT 135
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: ST_TO_ADDR
// if w = 3 then
7736: LD_VAR 0 6
7740: PUSH
7741: LD_INT 3
7743: EQUAL
7744: IFFALSE 7775
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7746: LD_ADDR_VAR 0 5
7750: PUSH
7751: LD_INT 91
7753: PUSH
7754: LD_INT 58
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: PUSH
7761: LD_INT 117
7763: PUSH
7764: LD_INT 107
7766: PUSH
7767: EMPTY
7768: LIST
7769: LIST
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7775: LD_INT 28
7777: PPUSH
7778: LD_INT 22
7780: PUSH
7781: LD_INT 1
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PPUSH
7788: CALL_OW 70
7792: IFFALSE 7812
// coords := [ [ 163 , 41 ] ] ;
7794: LD_ADDR_VAR 0 5
7798: PUSH
7799: LD_INT 163
7801: PUSH
7802: LD_INT 41
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: EMPTY
7810: LIST
7811: ST_TO_ADDR
// p := 30 ;
7812: LD_ADDR_VAR 0 8
7816: PUSH
7817: LD_INT 30
7819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7820: LD_INT 35
7822: PPUSH
7823: CALL_OW 67
// AgressiveMove ( tmp , coords ) ;
7827: LD_VAR 0 2
7831: PPUSH
7832: LD_VAR 0 5
7836: PPUSH
7837: CALL 90721 0 2
// p := Dec ( p ) ;
7841: LD_ADDR_VAR 0 8
7845: PUSH
7846: LD_VAR 0 8
7850: PPUSH
7851: CALL 89350 0 1
7855: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7856: LD_VAR 0 2
7860: PPUSH
7861: LD_INT 60
7863: PUSH
7864: EMPTY
7865: LIST
7866: PPUSH
7867: CALL_OW 72
7871: PUSH
7872: LD_INT 0
7874: EQUAL
7875: IFTRUE 7887
7877: PUSH
7878: LD_VAR 0 8
7882: PUSH
7883: LD_INT 0
7885: LESSEQUAL
7886: OR
7887: IFFALSE 7820
// repeat wait ( 0 0$2 ) ;
7889: LD_INT 70
7891: PPUSH
7892: CALL_OW 67
// enemy := FilterAllUnits ( [ f_side , 1 ] ) ;
7896: LD_ADDR_VAR 0 3
7900: PUSH
7901: LD_INT 22
7903: PUSH
7904: LD_INT 1
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: PPUSH
7911: CALL_OW 69
7915: ST_TO_ADDR
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7916: LD_ADDR_VAR 0 2
7920: PUSH
7921: LD_VAR 0 2
7925: PPUSH
7926: LD_INT 50
7928: PUSH
7929: EMPTY
7930: LIST
7931: PPUSH
7932: CALL_OW 72
7936: ST_TO_ADDR
// for i in tmp do
7937: LD_ADDR_VAR 0 1
7941: PUSH
7942: LD_VAR 0 2
7946: PUSH
7947: FOR_IN
7948: IFFALSE 8044
// if GetChassis ( i ) = ar_hovercraft then
7950: LD_VAR 0 1
7954: PPUSH
7955: CALL_OW 265
7959: PUSH
7960: LD_INT 11
7962: EQUAL
7963: IFFALSE 8018
// begin if not AttackHovercraft ( i , NearestUnitToUnit ( enemy , i ) ) then
7965: LD_VAR 0 1
7969: PPUSH
7970: LD_VAR 0 3
7974: PPUSH
7975: LD_VAR 0 1
7979: PPUSH
7980: CALL_OW 74
7984: PPUSH
7985: CALL 83366 0 2
7989: NOT
7990: IFFALSE 8016
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
7992: LD_VAR 0 1
7996: PPUSH
7997: LD_VAR 0 3
8001: PPUSH
8002: LD_VAR 0 1
8006: PPUSH
8007: CALL_OW 74
8011: PPUSH
8012: CALL_OW 115
// end else
8016: GO 8042
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8018: LD_VAR 0 1
8022: PPUSH
8023: LD_VAR 0 3
8027: PPUSH
8028: LD_VAR 0 1
8032: PPUSH
8033: CALL_OW 74
8037: PPUSH
8038: CALL_OW 115
8042: GO 7947
8044: POP
8045: POP
// until not tmp ;
8046: LD_VAR 0 2
8050: NOT
8051: IFFALSE 7889
// enable ;
8053: ENABLE
// end ;
8054: PPOPN 8
8056: END
// every 28 28$00 do var i , enemy , tmp , un , x , p ;
8057: GO 8059
8059: DISABLE
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
8064: PPUSH
8065: PPUSH
8066: PPUSH
8067: PPUSH
// begin enable ;
8068: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8069: LD_INT 35
8071: PPUSH
8072: LD_INT 1190
8074: PPUSH
8075: CALL_OW 12
8079: PPUSH
8080: CALL_OW 67
// tmp := [ ] ;
8084: LD_ADDR_VAR 0 3
8088: PUSH
8089: EMPTY
8090: ST_TO_ADDR
// InitHc ;
8091: CALL_OW 19
// for i := 1 to 3 do
8095: LD_ADDR_VAR 0 1
8099: PUSH
8100: DOUBLE
8101: LD_INT 1
8103: DEC
8104: ST_TO_ADDR
8105: LD_INT 3
8107: PUSH
8108: FOR_TO
8109: IFFALSE 8252
// begin uc_side := 8 ;
8111: LD_ADDR_OWVAR 20
8115: PUSH
8116: LD_INT 8
8118: ST_TO_ADDR
// uc_nation := 2 ;
8119: LD_ADDR_OWVAR 21
8123: PUSH
8124: LD_INT 2
8126: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8127: LD_INT 13
8129: PUSH
8130: LD_INT 14
8132: PUSH
8133: EMPTY
8134: LIST
8135: LIST
8136: PUSH
8137: LD_INT 1
8139: PPUSH
8140: LD_INT 2
8142: PPUSH
8143: CALL_OW 12
8147: ARRAY
8148: PPUSH
8149: LD_INT 3
8151: PPUSH
8152: LD_INT 5
8154: PPUSH
8155: LD_INT 27
8157: PUSH
8158: LD_INT 28
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: LD_INT 1
8167: PPUSH
8168: LD_INT 2
8170: PPUSH
8171: CALL_OW 12
8175: ARRAY
8176: PPUSH
8177: LD_INT 100
8179: PPUSH
8180: CALL 54775 0 5
// un := CreateVehicle ;
8184: LD_ADDR_VAR 0 4
8188: PUSH
8189: CALL_OW 45
8193: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8194: LD_VAR 0 4
8198: PPUSH
8199: LD_INT 4
8201: PPUSH
8202: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8206: LD_VAR 0 4
8210: PPUSH
8211: LD_INT 15
8213: PPUSH
8214: LD_INT 0
8216: PPUSH
8217: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8221: LD_ADDR_VAR 0 3
8225: PUSH
8226: LD_VAR 0 3
8230: PPUSH
8231: LD_VAR 0 3
8235: PUSH
8236: LD_INT 1
8238: PLUS
8239: PPUSH
8240: LD_VAR 0 4
8244: PPUSH
8245: CALL_OW 1
8249: ST_TO_ADDR
// end ;
8250: GO 8108
8252: POP
8253: POP
// for i := 1 to 3 do
8254: LD_ADDR_VAR 0 1
8258: PUSH
8259: DOUBLE
8260: LD_INT 1
8262: DEC
8263: ST_TO_ADDR
8264: LD_INT 3
8266: PUSH
8267: FOR_TO
8268: IFFALSE 8376
// begin uc_side := 8 ;
8270: LD_ADDR_OWVAR 20
8274: PUSH
8275: LD_INT 8
8277: ST_TO_ADDR
// uc_nation := 2 ;
8278: LD_ADDR_OWVAR 21
8282: PUSH
8283: LD_INT 2
8285: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8286: LD_INT 0
8288: PPUSH
8289: LD_INT 1
8291: PPUSH
8292: LD_INT 6
8294: PPUSH
8295: CALL_OW 380
// un := CreateHuman ;
8299: LD_ADDR_VAR 0 4
8303: PUSH
8304: CALL_OW 44
8308: ST_TO_ADDR
// if Prob ( 50 ) then
8309: LD_INT 50
8311: PPUSH
8312: CALL_OW 13
8316: IFFALSE 8330
// SetClass ( un , class_mortar ) ;
8318: LD_VAR 0 4
8322: PPUSH
8323: LD_INT 8
8325: PPUSH
8326: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8330: LD_VAR 0 4
8334: PPUSH
8335: LD_INT 15
8337: PPUSH
8338: LD_INT 0
8340: PPUSH
8341: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8345: LD_ADDR_VAR 0 3
8349: PUSH
8350: LD_VAR 0 3
8354: PPUSH
8355: LD_VAR 0 3
8359: PUSH
8360: LD_INT 1
8362: PLUS
8363: PPUSH
8364: LD_VAR 0 4
8368: PPUSH
8369: CALL_OW 1
8373: ST_TO_ADDR
// end ;
8374: GO 8267
8376: POP
8377: POP
// wait ( 0 0$3 ) ;
8378: LD_INT 105
8380: PPUSH
8381: CALL_OW 67
// p := 0 ;
8385: LD_ADDR_VAR 0 6
8389: PUSH
8390: LD_INT 0
8392: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8393: LD_INT 105
8395: PPUSH
8396: CALL_OW 67
// p := p + 3 ;
8400: LD_ADDR_VAR 0 6
8404: PUSH
8405: LD_VAR 0 6
8409: PUSH
8410: LD_INT 3
8412: PLUS
8413: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_enemy , 8 ] ) ;
8414: LD_ADDR_VAR 0 2
8418: PUSH
8419: LD_INT 81
8421: PUSH
8422: LD_INT 8
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: PPUSH
8429: CALL_OW 69
8433: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8434: LD_ADDR_VAR 0 1
8438: PUSH
8439: LD_VAR 0 3
8443: PPUSH
8444: LD_INT 50
8446: PUSH
8447: EMPTY
8448: LIST
8449: PPUSH
8450: CALL_OW 72
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8484
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8458: LD_VAR 0 1
8462: PPUSH
8463: LD_VAR 0 2
8467: PPUSH
8468: LD_VAR 0 1
8472: PPUSH
8473: CALL_OW 74
8477: PPUSH
8478: CALL_OW 115
8482: GO 8455
8484: POP
8485: POP
// until p >= 120 ;
8486: LD_VAR 0 6
8490: PUSH
8491: LD_INT 120
8493: GREATEREQUAL
8494: IFFALSE 8393
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8496: LD_VAR 0 3
8500: PPUSH
8501: LD_INT 210
8503: PPUSH
8504: LD_INT 178
8506: PPUSH
8507: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8511: LD_ADDR_VAR 0 5
8515: PUSH
8516: LD_INT 10
8518: PPUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 8
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PPUSH
8529: CALL_OW 70
8533: ST_TO_ADDR
// if x then
8534: LD_VAR 0 5
8538: IFFALSE 8566
// for i in x do
8540: LD_ADDR_VAR 0 1
8544: PUSH
8545: LD_VAR 0 5
8549: PUSH
8550: FOR_IN
8551: IFFALSE 8564
// RemoveUnit ( i ) ;
8553: LD_VAR 0 1
8557: PPUSH
8558: CALL_OW 64
8562: GO 8550
8564: POP
8565: POP
// wait ( 0 0$1 ) ;
8566: LD_INT 35
8568: PPUSH
8569: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8573: LD_INT 22
8575: PUSH
8576: LD_INT 8
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: PPUSH
8583: CALL_OW 69
8587: NOT
8588: IFFALSE 8496
// end ;
8590: PPOPN 6
8592: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8593: LD_INT 22
8595: PUSH
8596: LD_INT 2
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PUSH
8603: LD_INT 34
8605: PUSH
8606: LD_INT 31
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: PUSH
8613: LD_INT 3
8615: PUSH
8616: LD_INT 24
8618: PUSH
8619: LD_INT 1000
8621: PUSH
8622: EMPTY
8623: LIST
8624: LIST
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PPUSH
8635: CALL_OW 69
8639: IFFALSE 8744
8641: GO 8643
8643: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8644: LD_INT 45
8646: PPUSH
8647: CALL_OW 302
8651: IFFALSE 8662
8653: PUSH
8654: LD_INT 45
8656: PPUSH
8657: CALL_OW 255
8661: AND
8662: IFFALSE 8705
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8664: LD_INT 22
8666: PUSH
8667: LD_INT 2
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: LD_INT 34
8676: PUSH
8677: LD_INT 31
8679: PUSH
8680: EMPTY
8681: LIST
8682: LIST
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: PPUSH
8688: CALL_OW 69
8692: PPUSH
8693: LD_INT 18
8695: PPUSH
8696: LD_INT 8
8698: PPUSH
8699: CALL_OW 111
8703: GO 8744
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8705: LD_INT 22
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: PUSH
8715: LD_INT 34
8717: PUSH
8718: LD_INT 31
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PPUSH
8729: CALL_OW 69
8733: PPUSH
8734: LD_INT 106
8736: PPUSH
8737: LD_INT 14
8739: PPUSH
8740: CALL_OW 111
// end ;
8744: END
// every 0 0$10 trigger not IsOk ( ar_dep_e ) or GetSide ( ar_dep_e ) <> 2 do var i , un , tmp , enemy ;
8745: LD_INT 204
8747: PPUSH
8748: CALL_OW 302
8752: NOT
8753: IFTRUE 8768
8755: PUSH
8756: LD_INT 204
8758: PPUSH
8759: CALL_OW 255
8763: PUSH
8764: LD_INT 2
8766: NONEQUAL
8767: OR
8768: IFFALSE 9043
8770: GO 8772
8772: DISABLE
8773: LD_INT 0
8775: PPUSH
8776: PPUSH
8777: PPUSH
8778: PPUSH
// begin if Difficulty = 1 then
8779: LD_OWVAR 67
8783: PUSH
8784: LD_INT 1
8786: EQUAL
8787: IFFALSE 8791
// exit ;
8789: GO 9043
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty - 1 ] do
8791: LD_ADDR_VAR 0 1
8795: PUSH
8796: DOUBLE
8797: LD_INT 1
8799: DEC
8800: ST_TO_ADDR
8801: LD_INT 2
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 4
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: LIST
8814: PUSH
8815: LD_OWVAR 67
8819: PUSH
8820: LD_INT 1
8822: MINUS
8823: ARRAY
8824: PUSH
8825: FOR_TO
8826: IFFALSE 8915
// begin uc_side := 2 ;
8828: LD_ADDR_OWVAR 20
8832: PUSH
8833: LD_INT 2
8835: ST_TO_ADDR
// uc_nation := nation_nature ;
8836: LD_ADDR_OWVAR 21
8840: PUSH
8841: LD_INT 0
8843: ST_TO_ADDR
// PrepareApemanSoldier ( ) ;
8844: CALL 83878 0 0
// hc_class := class_apeman_kamikaze ;
8848: LD_ADDR_OWVAR 28
8852: PUSH
8853: LD_INT 17
8855: ST_TO_ADDR
// un := CreateHuman ;
8856: LD_ADDR_VAR 0 2
8860: PUSH
8861: CALL_OW 44
8865: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8866: LD_VAR 0 2
8870: PPUSH
8871: LD_INT 4
8873: PPUSH
8874: CALL_OW 233
// PlaceUnitArea ( un , east_ape_spawn , false ) ;
8878: LD_VAR 0 2
8882: PPUSH
8883: LD_INT 30
8885: PPUSH
8886: LD_INT 0
8888: PPUSH
8889: CALL_OW 49
// tmp := Join ( tmp , un ) ;
8893: LD_ADDR_VAR 0 3
8897: PUSH
8898: LD_VAR 0 3
8902: PPUSH
8903: LD_VAR 0 2
8907: PPUSH
8908: CALL 87955 0 2
8912: ST_TO_ADDR
// end ;
8913: GO 8825
8915: POP
8916: POP
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// for i in tmp do
8924: LD_ADDR_VAR 0 1
8928: PUSH
8929: LD_VAR 0 3
8933: PUSH
8934: FOR_IN
8935: IFFALSE 9026
// begin if not IsOk ( i ) then
8937: LD_VAR 0 1
8941: PPUSH
8942: CALL_OW 302
8946: NOT
8947: IFFALSE 8967
// begin tmp := tmp diff i ;
8949: LD_ADDR_VAR 0 3
8953: PUSH
8954: LD_VAR 0 3
8958: PUSH
8959: LD_VAR 0 1
8963: DIFF
8964: ST_TO_ADDR
// continue ;
8965: GO 8934
// end ; enemy := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ;
8967: LD_ADDR_VAR 0 4
8971: PUSH
8972: LD_INT 81
8974: PUSH
8975: LD_VAR 0 1
8979: PPUSH
8980: CALL_OW 255
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: PPUSH
8994: LD_VAR 0 1
8998: PPUSH
8999: CALL_OW 74
9003: ST_TO_ADDR
// if enemy then
9004: LD_VAR 0 4
9008: IFFALSE 9024
// ComAttackUnit ( i , enemy ) ;
9010: LD_VAR 0 1
9014: PPUSH
9015: LD_VAR 0 4
9019: PPUSH
9020: CALL_OW 115
// end ;
9024: GO 8934
9026: POP
9027: POP
// until not tmp ;
9028: LD_VAR 0 3
9032: NOT
9033: IFFALSE 8917
// wait ( 10 10$00 ) ;
9035: LD_INT 21000
9037: PPUSH
9038: CALL_OW 67
// enable ;
9042: ENABLE
// end ; end_of_file
9043: PPOPN 4
9045: END
// export function Action ; var tmp , p , radar , sols , i ; begin
9046: LD_INT 0
9048: PPUSH
9049: PPUSH
9050: PPUSH
9051: PPUSH
9052: PPUSH
9053: PPUSH
// InGameOn ;
9054: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
9058: LD_EXP 21
9062: PPUSH
9063: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
9067: LD_INT 2
9069: PPUSH
9070: LD_INT 1
9072: PPUSH
9073: LD_INT 1
9075: PPUSH
9076: LD_INT 1
9078: PPUSH
9079: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
9083: LD_ADDR_VAR 0 2
9087: PUSH
9088: LD_INT 22
9090: PUSH
9091: LD_INT 1
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PUSH
9098: LD_INT 25
9100: PUSH
9101: LD_INT 1
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PPUSH
9112: CALL_OW 69
9116: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
9117: LD_ADDR_VAR 0 4
9121: PUSH
9122: LD_INT 22
9124: PUSH
9125: LD_INT 1
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PUSH
9132: LD_INT 34
9134: PUSH
9135: LD_INT 11
9137: PUSH
9138: EMPTY
9139: LIST
9140: LIST
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: PPUSH
9146: CALL_OW 69
9150: PUSH
9151: LD_INT 1
9153: ARRAY
9154: ST_TO_ADDR
// for i = 1 to tmp do
9155: LD_ADDR_VAR 0 6
9159: PUSH
9160: DOUBLE
9161: LD_INT 1
9163: DEC
9164: ST_TO_ADDR
9165: LD_VAR 0 2
9169: PUSH
9170: FOR_TO
9171: IFFALSE 9218
// begin if i = 5 then
9173: LD_VAR 0 6
9177: PUSH
9178: LD_INT 5
9180: EQUAL
9181: IFFALSE 9185
// break ;
9183: GO 9218
// sols := Replace ( sols , i , tmp [ i ] ) ;
9185: LD_ADDR_VAR 0 5
9189: PUSH
9190: LD_VAR 0 5
9194: PPUSH
9195: LD_VAR 0 6
9199: PPUSH
9200: LD_VAR 0 2
9204: PUSH
9205: LD_VAR 0 6
9209: ARRAY
9210: PPUSH
9211: CALL_OW 1
9215: ST_TO_ADDR
// end ;
9216: GO 9170
9218: POP
9219: POP
// tmp := ar_force_tmp ;
9220: LD_ADDR_VAR 0 2
9224: PUSH
9225: LD_EXP 40
9229: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
9230: LD_VAR 0 2
9234: PUSH
9235: LD_INT 1
9237: ARRAY
9238: PPUSH
9239: LD_INT 108
9241: PPUSH
9242: LD_INT 139
9244: PPUSH
9245: LD_INT 0
9247: PPUSH
9248: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
9252: LD_VAR 0 2
9256: PUSH
9257: LD_INT 1
9259: ARRAY
9260: PPUSH
9261: LD_EXP 21
9265: PPUSH
9266: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
9270: LD_VAR 0 2
9274: PUSH
9275: LD_INT 2
9277: ARRAY
9278: PPUSH
9279: LD_INT 114
9281: PPUSH
9282: LD_INT 132
9284: PPUSH
9285: LD_INT 0
9287: PPUSH
9288: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9292: LD_VAR 0 2
9296: PUSH
9297: LD_INT 3
9299: ARRAY
9300: PPUSH
9301: LD_INT 115
9303: PPUSH
9304: LD_INT 132
9306: PPUSH
9307: LD_INT 0
9309: PPUSH
9310: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9314: LD_VAR 0 2
9318: PUSH
9319: LD_INT 2
9321: ARRAY
9322: PUSH
9323: LD_VAR 0 2
9327: PUSH
9328: LD_INT 3
9330: ARRAY
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9340: LD_VAR 0 4
9344: PPUSH
9345: LD_INT 83
9347: PPUSH
9348: LD_INT 123
9350: PPUSH
9351: CALL_OW 111
// Wait ( 0 0$01 ) ;
9355: LD_INT 35
9357: PPUSH
9358: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9362: LD_INT 90
9364: PPUSH
9365: LD_INT 144
9367: PPUSH
9368: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9372: LD_VAR 0 5
9376: PPUSH
9377: LD_INT 88
9379: PPUSH
9380: LD_INT 129
9382: PPUSH
9383: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9387: LD_ADDR_VAR 0 3
9391: PUSH
9392: LD_INT 92
9394: PUSH
9395: LD_INT 131
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PUSH
9402: LD_INT 88
9404: PUSH
9405: LD_INT 127
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: LD_INT 91
9414: PUSH
9415: LD_INT 132
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PUSH
9422: LD_INT 92
9424: PUSH
9425: LD_INT 134
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: LIST
9436: LIST
9437: ST_TO_ADDR
// for i = 1 to sols do
9438: LD_ADDR_VAR 0 6
9442: PUSH
9443: DOUBLE
9444: LD_INT 1
9446: DEC
9447: ST_TO_ADDR
9448: LD_VAR 0 5
9452: PUSH
9453: FOR_TO
9454: IFFALSE 9527
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9456: LD_VAR 0 5
9460: PUSH
9461: LD_VAR 0 6
9465: ARRAY
9466: PPUSH
9467: LD_VAR 0 3
9471: PUSH
9472: LD_VAR 0 6
9476: ARRAY
9477: PUSH
9478: LD_INT 1
9480: ARRAY
9481: PPUSH
9482: LD_VAR 0 3
9486: PUSH
9487: LD_VAR 0 6
9491: ARRAY
9492: PUSH
9493: LD_INT 2
9495: ARRAY
9496: PPUSH
9497: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9501: LD_VAR 0 5
9505: PUSH
9506: LD_VAR 0 6
9510: ARRAY
9511: PPUSH
9512: CALL_OW 197
// AddComHold ( sols ) ;
9516: LD_VAR 0 5
9520: PPUSH
9521: CALL_OW 200
// end ;
9525: GO 9453
9527: POP
9528: POP
// repeat wait ( 0 0$1 ) ;
9529: LD_INT 35
9531: PPUSH
9532: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9536: LD_VAR 0 5
9540: PUSH
9541: LD_INT 1
9543: ARRAY
9544: PPUSH
9545: LD_INT 92
9547: PPUSH
9548: LD_INT 131
9550: PPUSH
9551: CALL_OW 297
9555: PUSH
9556: LD_INT 4
9558: LESS
9559: IFFALSE 9529
// CenterOnXY ( 96 , 139 ) ;
9561: LD_INT 96
9563: PPUSH
9564: LD_INT 139
9566: PPUSH
9567: CALL_OW 84
// wait ( 0 0$3 ) ;
9571: LD_INT 105
9573: PPUSH
9574: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9578: LD_INT 111
9580: PPUSH
9581: LD_INT 135
9583: PPUSH
9584: LD_INT 1
9586: PPUSH
9587: LD_INT 25
9589: NEG
9590: PPUSH
9591: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9595: LD_VAR 0 2
9599: PUSH
9600: LD_INT 2
9602: ARRAY
9603: PPUSH
9604: LD_VAR 0 2
9608: PUSH
9609: LD_INT 1
9611: ARRAY
9612: PPUSH
9613: CALL_OW 250
9617: PUSH
9618: LD_INT 3
9620: PLUS
9621: PPUSH
9622: LD_VAR 0 2
9626: PUSH
9627: LD_INT 1
9629: ARRAY
9630: PPUSH
9631: CALL_OW 251
9635: PPUSH
9636: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9640: LD_VAR 0 2
9644: PUSH
9645: LD_INT 3
9647: ARRAY
9648: PPUSH
9649: LD_INT 7
9651: PPUSH
9652: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9656: LD_VAR 0 2
9660: PUSH
9661: LD_INT 2
9663: ARRAY
9664: PPUSH
9665: LD_VAR 0 2
9669: PUSH
9670: LD_INT 1
9672: ARRAY
9673: PPUSH
9674: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9678: LD_INT 35
9680: PPUSH
9681: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9685: LD_VAR 0 2
9689: PUSH
9690: LD_INT 1
9692: ARRAY
9693: PPUSH
9694: LD_VAR 0 2
9698: PUSH
9699: LD_INT 2
9701: ARRAY
9702: PPUSH
9703: CALL_OW 296
9707: PUSH
9708: LD_INT 5
9710: LESS
9711: IFFALSE 9678
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9713: LD_VAR 0 2
9717: PUSH
9718: LD_INT 1
9720: ARRAY
9721: PPUSH
9722: LD_VAR 0 2
9726: PUSH
9727: LD_INT 2
9729: ARRAY
9730: PPUSH
9731: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9735: LD_VAR 0 2
9739: PUSH
9740: LD_INT 1
9742: ARRAY
9743: PPUSH
9744: LD_STRING D1a-Merc1-1
9746: PPUSH
9747: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9751: LD_VAR 0 2
9755: PUSH
9756: LD_INT 2
9758: ARRAY
9759: PPUSH
9760: LD_STRING D1a-FMerc2-1
9762: PPUSH
9763: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9767: LD_VAR 0 2
9771: PUSH
9772: LD_INT 2
9774: ARRAY
9775: PPUSH
9776: LD_VAR 0 2
9780: PUSH
9781: LD_INT 1
9783: ARRAY
9784: PPUSH
9785: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9789: LD_VAR 0 2
9793: PUSH
9794: LD_INT 1
9796: ARRAY
9797: PPUSH
9798: LD_INT 500
9800: PPUSH
9801: CALL_OW 234
// wait ( 0 0$2 ) ;
9805: LD_INT 70
9807: PPUSH
9808: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9812: LD_VAR 0 2
9816: PUSH
9817: LD_INT 1
9819: ARRAY
9820: PPUSH
9821: LD_INT 2
9823: PPUSH
9824: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9828: LD_INT 10
9830: PPUSH
9831: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9835: LD_VAR 0 2
9839: PUSH
9840: LD_INT 1
9842: ARRAY
9843: PPUSH
9844: LD_STRING D1a-Merc1-2
9846: PPUSH
9847: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9851: LD_INT 7
9853: PPUSH
9854: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9858: LD_VAR 0 2
9862: PUSH
9863: LD_INT 1
9865: ARRAY
9866: PPUSH
9867: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9871: LD_VAR 0 2
9875: PUSH
9876: LD_INT 2
9878: ARRAY
9879: PPUSH
9880: LD_INT 10
9882: PPUSH
9883: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9887: LD_VAR 0 2
9891: PUSH
9892: LD_INT 2
9894: ARRAY
9895: PPUSH
9896: LD_STRING D1a-FMerc2-2
9898: PPUSH
9899: CALL_OW 88
// wait ( 0 0$1 ) ;
9903: LD_INT 35
9905: PPUSH
9906: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9910: LD_INT 7
9912: PPUSH
9913: CALL_OW 85
// wait ( 0 0$2 ) ;
9917: LD_INT 70
9919: PPUSH
9920: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9924: LD_EXP 44
9928: PPUSH
9929: LD_STRING D1a-Saliba-1
9931: PPUSH
9932: CALL_OW 91
// KillUnit ( Saliba ) ;
9936: LD_EXP 44
9940: PPUSH
9941: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9945: LD_VAR 0 2
9949: PUSH
9950: LD_INT 3
9952: ARRAY
9953: PPUSH
9954: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9958: LD_EXP 21
9962: PPUSH
9963: CALL_OW 85
// wait ( 0 0$1 ) ;
9967: LD_INT 35
9969: PPUSH
9970: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9974: LD_VAR 0 5
9978: PPUSH
9979: LD_INT 88
9981: PPUSH
9982: LD_INT 141
9984: PPUSH
9985: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9989: LD_VAR 0 5
9993: PPUSH
9994: LD_INT 70
9996: PPUSH
9997: CALL_OW 202
// wait ( 0 0$2 ) ;
10001: LD_INT 70
10003: PPUSH
10004: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
10008: LD_INT 2
10010: PPUSH
10011: LD_INT 1
10013: PPUSH
10014: LD_INT 2
10016: PPUSH
10017: LD_INT 1
10019: PPUSH
10020: CALL_OW 80
// InGameOff ;
10024: CALL_OW 9
// ComWalk ( sols ) ;
10028: LD_VAR 0 5
10032: PPUSH
10033: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
10037: LD_STRING M1
10039: PPUSH
10040: CALL_OW 337
// game_speed := 4 ;
10044: LD_ADDR_OWVAR 65
10048: PUSH
10049: LD_INT 4
10051: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
10052: LD_INT 111
10054: PPUSH
10055: LD_INT 135
10057: PPUSH
10058: LD_INT 1
10060: PPUSH
10061: CALL_OW 331
// SaveForQuickRestart ;
10065: CALL_OW 22
// ar_run := true ;
10069: LD_ADDR_EXP 5
10073: PUSH
10074: LD_INT 1
10076: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10077: LD_INT 35
10079: PPUSH
10080: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 1
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 91
10096: PUSH
10097: LD_INT 7
10099: PUSH
10100: LD_INT 10
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: PPUSH
10112: CALL_OW 69
10116: IFTRUE 10131
10118: PUSH
10119: LD_INT 7
10121: PPUSH
10122: CALL_OW 256
10126: PUSH
10127: LD_INT 999
10129: LESS
10130: OR
10131: IFFALSE 10077
// if GetSide ( ar_dep_s ) = 2 then
10133: LD_INT 7
10135: PPUSH
10136: CALL_OW 255
10140: PUSH
10141: LD_INT 2
10143: EQUAL
10144: IFFALSE 10156
// SetSide ( ar_dep_s , 1 ) ;
10146: LD_INT 7
10148: PPUSH
10149: LD_INT 1
10151: PPUSH
10152: CALL_OW 235
// end ;
10156: LD_VAR 0 1
10160: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
10161: LD_EXP 5
10165: IFFALSE 10525
10167: GO 10169
10169: DISABLE
10170: LD_INT 0
10172: PPUSH
10173: PPUSH
10174: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
10175: LD_ADDR_VAR 0 2
10179: PUSH
10180: LD_EXP 40
10184: PUSH
10185: LD_EXP 36
10189: PPUSH
10190: LD_INT 2
10192: PUSH
10193: LD_INT 21
10195: PUSH
10196: LD_INT 2
10198: PUSH
10199: EMPTY
10200: LIST
10201: LIST
10202: PUSH
10203: LD_INT 21
10205: PUSH
10206: LD_INT 1
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: LIST
10217: PPUSH
10218: CALL_OW 72
10222: ADD
10223: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
10224: LD_VAR 0 2
10228: PPUSH
10229: LD_INT 5
10231: PPUSH
10232: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
10236: LD_INT 5
10238: PPUSH
10239: LD_INT 1
10241: PPUSH
10242: CALL_OW 343
// k := 1 ;
10246: LD_ADDR_VAR 0 3
10250: PUSH
10251: LD_INT 1
10253: ST_TO_ADDR
// for i in tmp do
10254: LD_ADDR_VAR 0 1
10258: PUSH
10259: LD_VAR 0 2
10263: PUSH
10264: FOR_IN
10265: IFFALSE 10350
// begin if IsInUnit ( i ) then
10267: LD_VAR 0 1
10271: PPUSH
10272: CALL_OW 310
10276: IFFALSE 10287
// ComExitBuilding ( i ) ;
10278: LD_VAR 0 1
10282: PPUSH
10283: CALL_OW 122
// if GetClass ( i ) = 3 then
10287: LD_VAR 0 1
10291: PPUSH
10292: CALL_OW 257
10296: PUSH
10297: LD_INT 3
10299: EQUAL
10300: IFFALSE 10336
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10302: LD_VAR 0 1
10306: PPUSH
10307: LD_EXP 41
10311: PUSH
10312: LD_VAR 0 3
10316: ARRAY
10317: PPUSH
10318: CALL_OW 180
// k := k + 1 ;
10322: LD_ADDR_VAR 0 3
10326: PUSH
10327: LD_VAR 0 3
10331: PUSH
10332: LD_INT 1
10334: PLUS
10335: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10336: LD_VAR 0 1
10340: PPUSH
10341: LD_INT 10
10343: PPUSH
10344: CALL_OW 173
// end ;
10348: GO 10264
10350: POP
10351: POP
// ar_patrol := true ;
10352: LD_ADDR_EXP 7
10356: PUSH
10357: LD_INT 1
10359: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10360: LD_INT 10
10362: PPUSH
10363: CALL_OW 67
// for i in tmp do
10367: LD_ADDR_VAR 0 1
10371: PUSH
10372: LD_VAR 0 2
10376: PUSH
10377: FOR_IN
10378: IFFALSE 10406
// if not HasTask ( i ) then
10380: LD_VAR 0 1
10384: PPUSH
10385: CALL_OW 314
10389: NOT
10390: IFFALSE 10404
// ComMoveToArea ( i , escape_area ) ;
10392: LD_VAR 0 1
10396: PPUSH
10397: LD_INT 10
10399: PPUSH
10400: CALL_OW 113
10404: GO 10377
10406: POP
10407: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10408: LD_ADDR_VAR 0 3
10412: PUSH
10413: LD_VAR 0 2
10417: PPUSH
10418: LD_INT 95
10420: PUSH
10421: LD_INT 10
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PPUSH
10428: CALL_OW 72
10432: ST_TO_ADDR
// if k then
10433: LD_VAR 0 3
10437: IFFALSE 10506
// for i in k do
10439: LD_ADDR_VAR 0 1
10443: PUSH
10444: LD_VAR 0 3
10448: PUSH
10449: FOR_IN
10450: IFFALSE 10504
// begin if IsInUnit ( i ) then
10452: LD_VAR 0 1
10456: PPUSH
10457: CALL_OW 310
10461: IFFALSE 10477
// RemoveUnit ( IsInUnit ( i ) ) ;
10463: LD_VAR 0 1
10467: PPUSH
10468: CALL_OW 310
10472: PPUSH
10473: CALL_OW 64
// RemoveUnit ( i ) ;
10477: LD_VAR 0 1
10481: PPUSH
10482: CALL_OW 64
// tmp := tmp diff i ;
10486: LD_ADDR_VAR 0 2
10490: PUSH
10491: LD_VAR 0 2
10495: PUSH
10496: LD_VAR 0 1
10500: DIFF
10501: ST_TO_ADDR
// end ;
10502: GO 10449
10504: POP
10505: POP
// until tmp = [ ] ;
10506: LD_VAR 0 2
10510: PUSH
10511: EMPTY
10512: EQUAL
10513: IFFALSE 10360
// ChangeSideFog ( 5 , 5 ) ;
10515: LD_INT 5
10517: PPUSH
10518: LD_INT 5
10520: PPUSH
10521: CALL_OW 343
// end ;
10525: PPOPN 3
10527: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10528: LD_EXP 7
10532: IFFALSE 10824
10534: GO 10536
10536: DISABLE
10537: LD_INT 0
10539: PPUSH
10540: PPUSH
10541: PPUSH
// begin uc_side := 2 ;
10542: LD_ADDR_OWVAR 20
10546: PUSH
10547: LD_INT 2
10549: ST_TO_ADDR
// uc_nation := 2 ;
10550: LD_ADDR_OWVAR 21
10554: PUSH
10555: LD_INT 2
10557: ST_TO_ADDR
// InitHc ;
10558: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10562: LD_INT 1
10564: PPUSH
10565: LD_INT 1
10567: PPUSH
10568: LD_INT 6
10570: PPUSH
10571: CALL_OW 380
// un := CreateHuman ;
10575: LD_ADDR_VAR 0 2
10579: PUSH
10580: CALL_OW 44
10584: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10585: LD_INT 14
10587: PPUSH
10588: LD_INT 1
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: LD_INT 27
10596: PPUSH
10597: LD_INT 98
10599: PPUSH
10600: CALL 54775 0 5
// veh := CreateVehicle ;
10604: LD_ADDR_VAR 0 3
10608: PUSH
10609: CALL_OW 45
10613: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10614: LD_VAR 0 3
10618: PPUSH
10619: LD_INT 4
10621: PPUSH
10622: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10626: LD_VAR 0 3
10630: PPUSH
10631: LD_INT 179
10633: PPUSH
10634: LD_INT 135
10636: PPUSH
10637: LD_INT 0
10639: PPUSH
10640: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10644: LD_VAR 0 2
10648: PPUSH
10649: LD_VAR 0 3
10653: PPUSH
10654: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10658: LD_VAR 0 2
10662: PPUSH
10663: LD_INT 126
10665: PPUSH
10666: LD_INT 133
10668: PPUSH
10669: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10673: LD_INT 10
10675: PPUSH
10676: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10680: LD_INT 1
10682: PPUSH
10683: LD_VAR 0 3
10687: PPUSH
10688: CALL_OW 292
10692: IFTRUE 10712
10694: PUSH
10695: LD_VAR 0 3
10699: PPUSH
10700: LD_INT 7
10702: PPUSH
10703: CALL_OW 296
10707: PUSH
10708: LD_INT 9
10710: LESS
10711: OR
10712: IFFALSE 10673
// ComHold ( veh ) ;
10714: LD_VAR 0 3
10718: PPUSH
10719: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10723: LD_VAR 0 2
10727: PPUSH
10728: LD_STRING D2aa-Ar1-1
10730: PPUSH
10731: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10735: LD_VAR 0 2
10739: PPUSH
10740: LD_INT 177
10742: PPUSH
10743: LD_INT 96
10745: PPUSH
10746: CALL_OW 111
// AddComExitVehicle ( un ) ;
10750: LD_VAR 0 2
10754: PPUSH
10755: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10759: LD_INT 35
10761: PPUSH
10762: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10766: LD_VAR 0 2
10770: PPUSH
10771: LD_INT 204
10773: PPUSH
10774: CALL_OW 296
10778: PUSH
10779: LD_INT 15
10781: LESS
10782: IFFALSE 10759
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10784: LD_ADDR_EXP 50
10788: PUSH
10789: LD_EXP 50
10793: PPUSH
10794: LD_INT 3
10796: PUSH
10797: LD_EXP 50
10801: PUSH
10802: LD_INT 3
10804: ARRAY
10805: PUSH
10806: LD_INT 1
10808: PLUS
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: LD_VAR 0 2
10818: PPUSH
10819: CALL 54897 0 3
10823: ST_TO_ADDR
// end ;
10824: PPOPN 3
10826: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10827: LD_INT 7
10829: PPUSH
10830: CALL_OW 255
10834: PUSH
10835: LD_INT 1
10837: EQUAL
10838: IFTRUE 10849
10840: PUSH
10841: LD_INT 7
10843: PPUSH
10844: CALL_OW 301
10848: OR
10849: IFFALSE 13264
10851: GO 10853
10853: DISABLE
10854: LD_INT 0
10856: PPUSH
10857: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10858: LD_ADDR_VAR 0 1
10862: PUSH
10863: LD_EXP 36
10867: PPUSH
10868: LD_INT 21
10870: PUSH
10871: LD_INT 3
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PPUSH
10878: CALL_OW 72
10882: PUSH
10883: FOR_IN
10884: IFFALSE 10900
// SetSide ( i , 1 ) ;
10886: LD_VAR 0 1
10890: PPUSH
10891: LD_INT 1
10893: PPUSH
10894: CALL_OW 235
10898: GO 10883
10900: POP
10901: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10902: LD_ADDR_VAR 0 2
10906: PUSH
10907: LD_INT 46
10909: PUSH
10910: LD_INT 41
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 50
10919: PUSH
10920: LD_INT 25
10922: PUSH
10923: EMPTY
10924: LIST
10925: LIST
10926: PUSH
10927: LD_INT 57
10929: PUSH
10930: LD_INT 75
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: PUSH
10937: LD_INT 75
10939: PUSH
10940: LD_INT 89
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PUSH
10947: LD_INT 51
10949: PUSH
10950: LD_INT 45
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: PUSH
10957: LD_INT 95
10959: PUSH
10960: LD_INT 95
10962: PUSH
10963: EMPTY
10964: LIST
10965: LIST
10966: PUSH
10967: LD_INT 84
10969: PUSH
10970: LD_INT 77
10972: PUSH
10973: EMPTY
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 101
10979: PUSH
10980: LD_INT 76
10982: PUSH
10983: EMPTY
10984: LIST
10985: LIST
10986: PUSH
10987: LD_INT 118
10989: PUSH
10990: LD_INT 81
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: PUSH
10997: LD_INT 139
10999: PUSH
11000: LD_INT 97
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: PUSH
11007: LD_INT 129
11009: PUSH
11010: LD_INT 114
11012: PUSH
11013: EMPTY
11014: LIST
11015: LIST
11016: PUSH
11017: LD_INT 154
11019: PUSH
11020: LD_INT 111
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: ST_TO_ADDR
// base_captured := true ;
11041: LD_ADDR_EXP 6
11045: PUSH
11046: LD_INT 1
11048: ST_TO_ADDR
// DialogueOn ;
11049: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
11053: LD_EXP 21
11057: PPUSH
11058: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
11062: LD_EXP 21
11066: PPUSH
11067: LD_STRING D2-JMM-1
11069: PPUSH
11070: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
11074: LD_EXP 30
11078: PPUSH
11079: LD_STRING D2-Pow-1
11081: PPUSH
11082: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
11086: LD_EXP 21
11090: PPUSH
11091: LD_STRING D2-JMM-2
11093: PPUSH
11094: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
11098: LD_EXP 30
11102: PPUSH
11103: LD_STRING D2-Pow-2
11105: PPUSH
11106: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
11110: LD_EXP 21
11114: PPUSH
11115: LD_STRING D2-JMM-3
11117: PPUSH
11118: CALL_OW 88
// DialogueOff ;
11122: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
11126: LD_STRING M2
11128: PPUSH
11129: CALL_OW 337
// Wait ( 0 0$2 ) ;
11133: LD_INT 70
11135: PPUSH
11136: CALL_OW 67
// if IsOk ( Gary ) then
11140: LD_EXP 32
11144: PPUSH
11145: CALL_OW 302
11149: IFFALSE 11163
// Say ( Gary , D2a-Gary-1 ) ;
11151: LD_EXP 32
11155: PPUSH
11156: LD_STRING D2a-Gary-1
11158: PPUSH
11159: CALL_OW 88
// if IsOk ( Bobby ) then
11163: LD_EXP 24
11167: PPUSH
11168: CALL_OW 302
11172: IFFALSE 11186
// Say ( Bobby , D2a-Bobby-1 ) ;
11174: LD_EXP 24
11178: PPUSH
11179: LD_STRING D2a-Bobby-1
11181: PPUSH
11182: CALL_OW 88
// if IsOk ( Cyrus ) then
11186: LD_EXP 25
11190: PPUSH
11191: CALL_OW 302
11195: IFFALSE 11209
// Say ( Cyrus , D2a-Cyrus-1 ) ;
11197: LD_EXP 25
11201: PPUSH
11202: LD_STRING D2a-Cyrus-1
11204: PPUSH
11205: CALL_OW 88
// if IsOk ( Lisa ) then
11209: LD_EXP 22
11213: PPUSH
11214: CALL_OW 302
11218: IFFALSE 11232
// Say ( Lisa , D2a-Lisa-1 ) ;
11220: LD_EXP 22
11224: PPUSH
11225: LD_STRING D2a-Lisa-1
11227: PPUSH
11228: CALL_OW 88
// if IsOk ( Frank ) then
11232: LD_EXP 33
11236: PPUSH
11237: CALL_OW 302
11241: IFFALSE 11255
// Say ( Frank , D2a-Frank-1 ) ;
11243: LD_EXP 33
11247: PPUSH
11248: LD_STRING D2a-Frank-1
11250: PPUSH
11251: CALL_OW 88
// if IsOk ( Cornel ) then
11255: LD_EXP 31
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Cornel , D2a-Corn-1 ) ;
11266: LD_EXP 31
11270: PPUSH
11271: LD_STRING D2a-Corn-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Donaldson ) then
11278: LD_EXP 23
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11301
// Say ( Donaldson , D2a-Don-1 ) ;
11289: LD_EXP 23
11293: PPUSH
11294: LD_STRING D2a-Don-1
11296: PPUSH
11297: CALL_OW 88
// if IsOk ( Brown ) then
11301: LD_EXP 27
11305: PPUSH
11306: CALL_OW 302
11310: IFFALSE 11324
// Say ( Brown , D2a-Brown-1 ) ;
11312: LD_EXP 27
11316: PPUSH
11317: LD_STRING D2a-Brown-1
11319: PPUSH
11320: CALL_OW 88
// Wait ( 0 0$30 ) ;
11324: LD_INT 1050
11326: PPUSH
11327: CALL_OW 67
// if IsOk ( Frank ) then
11331: LD_EXP 33
11335: PPUSH
11336: CALL_OW 302
11340: IFFALSE 12324
// begin DialogueOn ;
11342: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11346: LD_EXP 21
11350: PUSH
11351: LD_EXP 33
11355: PUSH
11356: EMPTY
11357: LIST
11358: LIST
11359: PPUSH
11360: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11364: LD_EXP 33
11368: PPUSH
11369: LD_STRING D3F-Frank-1
11371: PPUSH
11372: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11376: LD_EXP 21
11380: PPUSH
11381: LD_STRING D3F-JMM-1
11383: PPUSH
11384: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11388: LD_EXP 33
11392: PPUSH
11393: LD_STRING D3F-Frank-2
11395: PPUSH
11396: CALL_OW 88
// case Query ( QFrank ) of 1 :
11400: LD_STRING QFrank
11402: PPUSH
11403: CALL_OW 97
11407: PUSH
11408: LD_INT 1
11410: DOUBLE
11411: EQUAL
11412: IFTRUE 11416
11414: GO 11439
11416: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11417: LD_EXP 21
11421: PPUSH
11422: LD_STRING D3Fa-JMM-1
11424: PPUSH
11425: CALL_OW 88
// us_scout := 1 ;
11429: LD_ADDR_EXP 8
11433: PUSH
11434: LD_INT 1
11436: ST_TO_ADDR
// end ; 2 :
11437: GO 11602
11439: LD_INT 2
11441: DOUBLE
11442: EQUAL
11443: IFTRUE 11447
11445: GO 11569
11447: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11448: LD_EXP 21
11452: PPUSH
11453: LD_STRING D3Fb-JMM-1
11455: PPUSH
11456: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11460: LD_EXP 33
11464: PPUSH
11465: LD_STRING D3Fb-Frank-1
11467: PPUSH
11468: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11472: LD_STRING QFrank2
11474: PPUSH
11475: CALL_OW 97
11479: PUSH
11480: LD_INT 1
11482: DOUBLE
11483: EQUAL
11484: IFTRUE 11488
11486: GO 11535
11488: POP
// begin us_scout := 2 ;
11489: LD_ADDR_EXP 8
11493: PUSH
11494: LD_INT 2
11496: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11497: LD_EXP 21
11501: PPUSH
11502: LD_STRING D3Fba-JMM-1
11504: PPUSH
11505: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11509: LD_EXP 33
11513: PPUSH
11514: LD_STRING D3Fba-Frank-1
11516: PPUSH
11517: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11521: LD_EXP 21
11525: PPUSH
11526: LD_STRING D3Fba-JMM-2
11528: PPUSH
11529: CALL_OW 88
// end ; 2 :
11533: GO 11567
11535: LD_INT 2
11537: DOUBLE
11538: EQUAL
11539: IFTRUE 11543
11541: GO 11566
11543: POP
// begin us_scout := 0 ;
11544: LD_ADDR_EXP 8
11548: PUSH
11549: LD_INT 0
11551: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11552: LD_EXP 21
11556: PPUSH
11557: LD_STRING D3Fbb-JMM-1
11559: PPUSH
11560: CALL_OW 88
// end ; end ;
11564: GO 11567
11566: POP
// end ; 3 :
11567: GO 11602
11569: LD_INT 3
11571: DOUBLE
11572: EQUAL
11573: IFTRUE 11577
11575: GO 11601
11577: POP
// begin us_scout := - 1 ;
11578: LD_ADDR_EXP 8
11582: PUSH
11583: LD_INT 1
11585: NEG
11586: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11587: LD_EXP 21
11591: PPUSH
11592: LD_STRING D3Fc-JMM-1
11594: PPUSH
11595: CALL_OW 88
// end ; end ;
11599: GO 11602
11601: POP
// DialogueOff ;
11602: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11606: LD_EXP 8
11610: PUSH
11611: LD_INT 1
11613: NEG
11614: PUSH
11615: LD_INT 0
11617: PUSH
11618: EMPTY
11619: LIST
11620: LIST
11621: IN
11622: IFFALSE 11626
// exit ;
11624: GO 13264
// if us_scout in [ 1 , 2 ] then
11626: LD_EXP 8
11630: PUSH
11631: LD_INT 1
11633: PUSH
11634: LD_INT 2
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: IN
11641: IFFALSE 12324
// begin if IsInUnit ( Frank ) then
11643: LD_EXP 33
11647: PPUSH
11648: CALL_OW 310
11652: IFFALSE 11663
// ComExit ( Frank ) ;
11654: LD_EXP 33
11658: PPUSH
11659: CALL 88353 0 1
// SetSide ( Frank , 4 ) ;
11663: LD_EXP 33
11667: PPUSH
11668: LD_INT 4
11670: PPUSH
11671: CALL_OW 235
// wait ( 0 0$1 ) ;
11675: LD_INT 35
11677: PPUSH
11678: CALL_OW 67
// if us_scout = 2 then
11682: LD_EXP 8
11686: PUSH
11687: LD_INT 2
11689: EQUAL
11690: IFFALSE 12060
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11692: LD_EXP 33
11696: PPUSH
11697: LD_INT 75
11699: PPUSH
11700: LD_INT 63
11702: PPUSH
11703: CALL_OW 111
// AddComHold ( Frank ) ;
11707: LD_EXP 33
11711: PPUSH
11712: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11716: LD_EXP 33
11720: PPUSH
11721: LD_INT 770
11723: PPUSH
11724: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11728: LD_EXP 33
11732: PPUSH
11733: LD_INT 100
11735: PPUSH
11736: LD_INT 75
11738: PPUSH
11739: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11743: LD_EXP 33
11747: PPUSH
11748: LD_INT 123
11750: PPUSH
11751: LD_INT 103
11753: PPUSH
11754: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11758: LD_EXP 33
11762: PPUSH
11763: LD_INT 138
11765: PPUSH
11766: LD_INT 108
11768: PPUSH
11769: CALL_OW 171
// AddComHold ( Frank ) ;
11773: LD_EXP 33
11777: PPUSH
11778: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11782: LD_INT 35
11784: PPUSH
11785: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11789: LD_EXP 33
11793: PPUSH
11794: LD_INT 138
11796: PPUSH
11797: LD_INT 108
11799: PPUSH
11800: CALL_OW 307
11804: IFFALSE 11782
// AddComMoveXY ( Frank , 125 , 132 ) ;
11806: LD_EXP 33
11810: PPUSH
11811: LD_INT 125
11813: PPUSH
11814: LD_INT 132
11816: PPUSH
11817: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11821: LD_INT 35
11823: PPUSH
11824: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11828: LD_INT 1
11830: PPUSH
11831: LD_EXP 33
11835: PPUSH
11836: CALL_OW 292
11840: IFTRUE 11860
11842: PUSH
11843: LD_EXP 33
11847: PPUSH
11848: LD_INT 7
11850: PPUSH
11851: CALL_OW 296
11855: PUSH
11856: LD_INT 7
11858: LESS
11859: OR
11860: IFFALSE 11821
// DialogueOn ;
11862: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11866: LD_EXP 33
11870: PPUSH
11871: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11875: LD_INT 10
11877: PPUSH
11878: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11882: LD_EXP 21
11886: PPUSH
11887: LD_STRING D4Fa-JMM-1
11889: PPUSH
11890: CALL_OW 88
// for i in points do
11894: LD_ADDR_VAR 0 1
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: FOR_IN
11905: IFFALSE 11963
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11907: LD_VAR 0 1
11911: PUSH
11912: LD_INT 1
11914: ARRAY
11915: PPUSH
11916: LD_VAR 0 1
11920: PUSH
11921: LD_INT 2
11923: ARRAY
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: LD_INT 20
11930: NEG
11931: PPUSH
11932: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11936: LD_VAR 0 1
11940: PUSH
11941: LD_INT 1
11943: ARRAY
11944: PPUSH
11945: LD_VAR 0 1
11949: PUSH
11950: LD_INT 2
11952: ARRAY
11953: PPUSH
11954: LD_INT 1
11956: PPUSH
11957: CALL_OW 331
// end ;
11961: GO 11904
11963: POP
11964: POP
// dwait ( 0 0$0.5 ) ;
11965: LD_INT 18
11967: PPUSH
11968: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11972: LD_INT 42
11974: PPUSH
11975: LD_INT 27
11977: PPUSH
11978: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11982: LD_EXP 33
11986: PPUSH
11987: LD_STRING D4Fa-Frank-1
11989: PPUSH
11990: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11994: LD_INT 18
11996: PPUSH
11997: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
12001: LD_EXP 21
12005: PPUSH
12006: LD_STRING D4Fa-JMM-2
12008: PPUSH
12009: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
12013: LD_INT 118
12015: PPUSH
12016: LD_INT 80
12018: PPUSH
12019: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
12023: LD_EXP 33
12027: PPUSH
12028: LD_STRING D4Fa-Frank-2
12030: PPUSH
12031: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12035: LD_INT 10
12037: PPUSH
12038: CALL_OW 68
// DialogueOff ;
12042: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12046: LD_EXP 33
12050: PPUSH
12051: LD_INT 1
12053: PPUSH
12054: CALL_OW 235
// end else
12058: GO 12324
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12060: LD_INT 2
12062: PPUSH
12063: LD_INT 4
12065: PPUSH
12066: LD_INT 2
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
12076: LD_EXP 33
12080: PPUSH
12081: LD_INT 75
12083: PPUSH
12084: LD_INT 63
12086: PPUSH
12087: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
12091: LD_EXP 33
12095: PPUSH
12096: LD_INT 175
12098: PPUSH
12099: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
12103: LD_EXP 33
12107: PPUSH
12108: LD_INT 102
12110: PPUSH
12111: LD_INT 76
12113: PPUSH
12114: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
12118: LD_EXP 33
12122: PPUSH
12123: LD_INT 108
12125: PPUSH
12126: LD_INT 70
12128: PPUSH
12129: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12133: LD_INT 35
12135: PPUSH
12136: CALL_OW 67
// until See ( 2 , Frank ) ;
12140: LD_INT 2
12142: PPUSH
12143: LD_EXP 33
12147: PPUSH
12148: CALL_OW 292
12152: IFFALSE 12133
// ComMoveXY ( Frank , 112 , 118 ) ;
12154: LD_EXP 33
12158: PPUSH
12159: LD_INT 112
12161: PPUSH
12162: LD_INT 118
12164: PPUSH
12165: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
12169: LD_EXP 33
12173: PPUSH
12174: CALL_OW 256
12178: PUSH
12179: LD_INT 750
12181: GREATEREQUAL
12182: IFFALSE 12196
// SetLives ( Frank , 700 ) ;
12184: LD_EXP 33
12188: PPUSH
12189: LD_INT 700
12191: PPUSH
12192: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12196: LD_INT 35
12198: PPUSH
12199: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
12203: LD_INT 1
12205: PPUSH
12206: LD_EXP 33
12210: PPUSH
12211: CALL_OW 292
12215: IFTRUE 12235
12217: PUSH
12218: LD_EXP 33
12222: PPUSH
12223: LD_INT 7
12225: PPUSH
12226: CALL_OW 296
12230: PUSH
12231: LD_INT 17
12233: LESS
12234: OR
12235: IFFALSE 12196
// DialogueOn ;
12237: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
12241: LD_EXP 33
12245: PPUSH
12246: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
12250: LD_EXP 33
12254: PPUSH
12255: LD_STRING D4Fb-Frank-1
12257: PPUSH
12258: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
12262: LD_EXP 21
12266: PPUSH
12267: LD_STRING D4Fb-JMM-1
12269: PPUSH
12270: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
12274: LD_INT 2
12276: PPUSH
12277: LD_STRING D4Fb-FSci1-1
12279: PPUSH
12280: CALL 17323 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
12284: LD_EXP 33
12288: PPUSH
12289: LD_STRING D4Fb-Frank-2
12291: PPUSH
12292: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12296: LD_EXP 21
12300: PPUSH
12301: LD_STRING D4Fb-JMM-2
12303: PPUSH
12304: CALL_OW 88
// DialogueOff ;
12308: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12312: LD_EXP 33
12316: PPUSH
12317: LD_INT 1
12319: PPUSH
12320: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12324: LD_EXP 34
12328: PPUSH
12329: CALL_OW 302
12333: IFFALSE 12347
12335: PUSH
12336: LD_EXP 33
12340: PPUSH
12341: CALL_OW 302
12345: NOT
12346: AND
12347: IFFALSE 13264
// begin DialogueOn ;
12349: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12353: LD_EXP 21
12357: PUSH
12358: LD_EXP 34
12362: PUSH
12363: EMPTY
12364: LIST
12365: LIST
12366: PPUSH
12367: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12371: LD_EXP 34
12375: PPUSH
12376: LD_STRING D3Y-Yam-1
12378: PPUSH
12379: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12383: LD_EXP 21
12387: PPUSH
12388: LD_STRING D3Y-JMM-1
12390: PPUSH
12391: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12395: LD_EXP 34
12399: PPUSH
12400: LD_STRING D3Y-Yam-2
12402: PPUSH
12403: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12407: LD_STRING QYamoko
12409: PPUSH
12410: CALL_OW 97
12414: PUSH
12415: LD_INT 1
12417: DOUBLE
12418: EQUAL
12419: IFTRUE 12423
12421: GO 12458
12423: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12424: LD_EXP 21
12428: PPUSH
12429: LD_STRING D3Ya-JMM-1
12431: PPUSH
12432: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12436: LD_EXP 34
12440: PPUSH
12441: LD_STRING D3Ya-Yam-1
12443: PPUSH
12444: CALL_OW 88
// us_scout := 1 ;
12448: LD_ADDR_EXP 8
12452: PUSH
12453: LD_INT 1
12455: ST_TO_ADDR
// end ; 2 :
12456: GO 12491
12458: LD_INT 2
12460: DOUBLE
12461: EQUAL
12462: IFTRUE 12466
12464: GO 12490
12466: POP
// begin us_scout := - 1 ;
12467: LD_ADDR_EXP 8
12471: PUSH
12472: LD_INT 1
12474: NEG
12475: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12476: LD_EXP 21
12480: PPUSH
12481: LD_STRING D3Yb-JMM-1
12483: PPUSH
12484: CALL_OW 88
// end ; end ;
12488: GO 12491
12490: POP
// DialogueOff ;
12491: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12495: LD_EXP 8
12499: PUSH
12500: LD_INT 1
12502: NEG
12503: PUSH
12504: LD_INT 0
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: IN
12511: IFFALSE 12515
// exit ;
12513: GO 13264
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12515: LD_ADDR_EXP 8
12519: PUSH
12520: LD_INT 2
12522: PUSH
12523: LD_INT 2
12525: PUSH
12526: LD_INT 1
12528: PUSH
12529: LD_INT 1
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: LIST
12536: LIST
12537: PUSH
12538: LD_OWVAR 67
12542: ARRAY
12543: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12544: LD_EXP 8
12548: PUSH
12549: LD_INT 1
12551: PUSH
12552: LD_INT 2
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: IN
12559: IFFALSE 13264
// begin if IsInUnit ( Kikuchi ) then
12561: LD_EXP 34
12565: PPUSH
12566: CALL_OW 310
12570: IFFALSE 12581
// ComExitBuilding ( Kikuchi ) ;
12572: LD_EXP 34
12576: PPUSH
12577: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12581: LD_EXP 34
12585: PPUSH
12586: CALL_OW 311
12590: IFFALSE 12601
// ComExitVehicle ( Kikuchi ) ;
12592: LD_EXP 34
12596: PPUSH
12597: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12601: LD_EXP 34
12605: PPUSH
12606: LD_INT 4
12608: PPUSH
12609: CALL_OW 235
// wait ( 0 0$1 ) ;
12613: LD_INT 35
12615: PPUSH
12616: CALL_OW 67
// if us_scout = 2 then
12620: LD_EXP 8
12624: PUSH
12625: LD_INT 2
12627: EQUAL
12628: IFFALSE 13010
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12630: LD_EXP 34
12634: PPUSH
12635: LD_INT 75
12637: PPUSH
12638: LD_INT 63
12640: PPUSH
12641: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12645: LD_EXP 34
12649: PPUSH
12650: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12654: LD_EXP 34
12658: PPUSH
12659: LD_INT 770
12661: PPUSH
12662: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12666: LD_EXP 34
12670: PPUSH
12671: LD_INT 100
12673: PPUSH
12674: LD_INT 75
12676: PPUSH
12677: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_INT 123
12688: PPUSH
12689: LD_INT 103
12691: PPUSH
12692: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12696: LD_EXP 34
12700: PPUSH
12701: LD_INT 138
12703: PPUSH
12704: LD_INT 108
12706: PPUSH
12707: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12711: LD_EXP 34
12715: PPUSH
12716: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12720: LD_INT 35
12722: PPUSH
12723: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12727: LD_EXP 34
12731: PPUSH
12732: LD_INT 138
12734: PPUSH
12735: LD_INT 108
12737: PPUSH
12738: CALL_OW 307
12742: IFFALSE 12720
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12744: LD_EXP 34
12748: PPUSH
12749: LD_INT 125
12751: PPUSH
12752: LD_INT 132
12754: PPUSH
12755: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12759: LD_INT 35
12761: PPUSH
12762: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12766: LD_INT 1
12768: PPUSH
12769: LD_EXP 34
12773: PPUSH
12774: CALL_OW 292
12778: IFTRUE 12798
12780: PUSH
12781: LD_EXP 34
12785: PPUSH
12786: LD_INT 7
12788: PPUSH
12789: CALL_OW 296
12793: PUSH
12794: LD_INT 7
12796: LESS
12797: OR
12798: IFFALSE 12759
// DialogueOn ;
12800: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12804: LD_EXP 34
12808: PPUSH
12809: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12813: LD_INT 10
12815: PPUSH
12816: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12820: LD_EXP 34
12824: PPUSH
12825: LD_STRING D4Ya-Yam-1
12827: PPUSH
12828: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12832: LD_EXP 21
12836: PPUSH
12837: LD_STRING D4Ya-JMM-1
12839: PPUSH
12840: CALL_OW 88
// for i in points do
12844: LD_ADDR_VAR 0 1
12848: PUSH
12849: LD_VAR 0 2
12853: PUSH
12854: FOR_IN
12855: IFFALSE 12913
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12857: LD_VAR 0 1
12861: PUSH
12862: LD_INT 1
12864: ARRAY
12865: PPUSH
12866: LD_VAR 0 1
12870: PUSH
12871: LD_INT 2
12873: ARRAY
12874: PPUSH
12875: LD_INT 1
12877: PPUSH
12878: LD_INT 20
12880: NEG
12881: PPUSH
12882: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12886: LD_VAR 0 1
12890: PUSH
12891: LD_INT 1
12893: ARRAY
12894: PPUSH
12895: LD_VAR 0 1
12899: PUSH
12900: LD_INT 2
12902: ARRAY
12903: PPUSH
12904: LD_INT 1
12906: PPUSH
12907: CALL_OW 331
// end ;
12911: GO 12854
12913: POP
12914: POP
// dwait ( 0 0$0.5 ) ;
12915: LD_INT 18
12917: PPUSH
12918: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12922: LD_INT 42
12924: PPUSH
12925: LD_INT 27
12927: PPUSH
12928: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12932: LD_EXP 34
12936: PPUSH
12937: LD_STRING D4Ya-Yam-2
12939: PPUSH
12940: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12944: LD_INT 18
12946: PPUSH
12947: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12951: LD_INT 118
12953: PPUSH
12954: LD_INT 80
12956: PPUSH
12957: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12961: LD_EXP 21
12965: PPUSH
12966: LD_STRING D4Ya-JMM-2
12968: PPUSH
12969: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12973: LD_EXP 34
12977: PPUSH
12978: LD_STRING D4Ya-Yam-3
12980: PPUSH
12981: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12985: LD_INT 10
12987: PPUSH
12988: CALL_OW 68
// DialogueOff ;
12992: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12996: LD_EXP 34
13000: PPUSH
13001: LD_INT 1
13003: PPUSH
13004: CALL_OW 235
// end else
13008: GO 13264
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
13010: LD_INT 2
13012: PPUSH
13013: LD_INT 4
13015: PPUSH
13016: LD_INT 2
13018: PPUSH
13019: LD_INT 1
13021: PPUSH
13022: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
13026: LD_EXP 34
13030: PPUSH
13031: LD_INT 75
13033: PPUSH
13034: LD_INT 63
13036: PPUSH
13037: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
13041: LD_EXP 34
13045: PPUSH
13046: LD_INT 175
13048: PPUSH
13049: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
13053: LD_EXP 34
13057: PPUSH
13058: LD_INT 102
13060: PPUSH
13061: LD_INT 76
13063: PPUSH
13064: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
13068: LD_EXP 34
13072: PPUSH
13073: LD_INT 108
13075: PPUSH
13076: LD_INT 70
13078: PPUSH
13079: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
13083: LD_INT 35
13085: PPUSH
13086: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
13090: LD_INT 2
13092: PPUSH
13093: LD_EXP 34
13097: PPUSH
13098: CALL_OW 292
13102: IFFALSE 13083
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
13104: LD_EXP 34
13108: PPUSH
13109: LD_INT 112
13111: PPUSH
13112: LD_INT 118
13114: PPUSH
13115: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
13119: LD_EXP 34
13123: PPUSH
13124: CALL_OW 256
13128: PUSH
13129: LD_INT 750
13131: GREATEREQUAL
13132: IFFALSE 13146
// SetLives ( Kikuchi , 700 ) ;
13134: LD_EXP 34
13138: PPUSH
13139: LD_INT 700
13141: PPUSH
13142: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
13146: LD_INT 35
13148: PPUSH
13149: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
13153: LD_INT 1
13155: PPUSH
13156: LD_EXP 34
13160: PPUSH
13161: CALL_OW 292
13165: IFTRUE 13185
13167: PUSH
13168: LD_EXP 34
13172: PPUSH
13173: LD_INT 7
13175: PPUSH
13176: CALL_OW 296
13180: PUSH
13181: LD_INT 17
13183: LESS
13184: OR
13185: IFFALSE 13146
// DialogueOn ;
13187: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
13191: LD_EXP 34
13195: PPUSH
13196: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
13200: LD_EXP 34
13204: PPUSH
13205: LD_STRING D4Yb-Yam-1
13207: PPUSH
13208: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
13212: LD_EXP 21
13216: PPUSH
13217: LD_STRING D4Yb-JMM-1
13219: PPUSH
13220: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
13224: LD_EXP 34
13228: PPUSH
13229: LD_STRING D4Yb-Yam-2
13231: PPUSH
13232: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
13236: LD_EXP 21
13240: PPUSH
13241: LD_STRING D4Yb-JMM-2
13243: PPUSH
13244: CALL_OW 88
// DialogueOff ;
13248: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
13252: LD_EXP 34
13256: PPUSH
13257: LD_INT 1
13259: PPUSH
13260: CALL_OW 235
// end ; end ; end ; end ;
13264: PPOPN 2
13266: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
13267: LD_EXP 6
13271: IFFALSE 14314
13273: GO 13275
13275: DISABLE
13276: LD_INT 0
13278: PPUSH
13279: PPUSH
13280: PPUSH
13281: PPUSH
// begin enable ;
13282: ENABLE
// if not seen [ 1 ] then
13283: LD_EXP 9
13287: PUSH
13288: LD_INT 1
13290: ARRAY
13291: NOT
13292: IFFALSE 13472
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13294: LD_ADDR_VAR 0 2
13298: PUSH
13299: LD_INT 22
13301: PUSH
13302: LD_INT 2
13304: PUSH
13305: EMPTY
13306: LIST
13307: LIST
13308: PUSH
13309: LD_INT 2
13311: PUSH
13312: LD_INT 25
13314: PUSH
13315: LD_INT 11
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: LD_INT 33
13324: PUSH
13325: LD_INT 4
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: PUSH
13337: EMPTY
13338: LIST
13339: LIST
13340: PPUSH
13341: CALL_OW 69
13345: ST_TO_ADDR
// if tmp then
13346: LD_VAR 0 2
13350: IFFALSE 13472
// for i in tmp do
13352: LD_ADDR_VAR 0 1
13356: PUSH
13357: LD_VAR 0 2
13361: PUSH
13362: FOR_IN
13363: IFFALSE 13470
// if See ( 1 , i ) then
13365: LD_INT 1
13367: PPUSH
13368: LD_VAR 0 1
13372: PPUSH
13373: CALL_OW 292
13377: IFFALSE 13468
// begin seen := Replace ( seen , 1 , true ) ;
13379: LD_ADDR_EXP 9
13383: PUSH
13384: LD_EXP 9
13388: PPUSH
13389: LD_INT 1
13391: PPUSH
13392: LD_INT 1
13394: PPUSH
13395: CALL_OW 1
13399: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13400: LD_INT 1
13402: PPUSH
13403: CALL 17185 0 1
13407: IFFALSE 13468
// begin DialogueOn ;
13409: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13413: LD_VAR 0 1
13417: PPUSH
13418: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13422: LD_INT 10
13424: PPUSH
13425: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13429: LD_ADDR_VAR 0 3
13433: PUSH
13434: LD_INT 1
13436: PPUSH
13437: LD_STRING D5a-Sol2-1
13439: PPUSH
13440: CALL 17323 0 2
13444: ST_TO_ADDR
// if not un then
13445: LD_VAR 0 3
13449: NOT
13450: IFFALSE 13462
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13452: LD_INT 2
13454: PPUSH
13455: LD_STRING D5a-FSol2-1
13457: PPUSH
13458: CALL 17323 0 2
// DialogueOff ;
13462: CALL_OW 7
// break ;
13466: GO 13470
// end ; end ;
13468: GO 13362
13470: POP
13471: POP
// end ; if not seen [ 2 ] then
13472: LD_EXP 9
13476: PUSH
13477: LD_INT 2
13479: ARRAY
13480: NOT
13481: IFFALSE 13706
// begin can_kamikazed := true ;
13483: LD_ADDR_EXP 10
13487: PUSH
13488: LD_INT 1
13490: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13491: LD_ADDR_VAR 0 2
13495: PUSH
13496: LD_INT 22
13498: PUSH
13499: LD_INT 2
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: PUSH
13506: LD_INT 25
13508: PUSH
13509: LD_INT 17
13511: PUSH
13512: EMPTY
13513: LIST
13514: LIST
13515: PUSH
13516: EMPTY
13517: LIST
13518: LIST
13519: PPUSH
13520: CALL_OW 69
13524: ST_TO_ADDR
// if tmp then
13525: LD_VAR 0 2
13529: IFFALSE 13706
// for i in tmp do
13531: LD_ADDR_VAR 0 1
13535: PUSH
13536: LD_VAR 0 2
13540: PUSH
13541: FOR_IN
13542: IFFALSE 13704
// if See ( 1 , i ) then
13544: LD_INT 1
13546: PPUSH
13547: LD_VAR 0 1
13551: PPUSH
13552: CALL_OW 292
13556: IFFALSE 13702
// begin seen := Replace ( seen , 2 , true ) ;
13558: LD_ADDR_EXP 9
13562: PUSH
13563: LD_EXP 9
13567: PPUSH
13568: LD_INT 2
13570: PPUSH
13571: LD_INT 1
13573: PPUSH
13574: CALL_OW 1
13578: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13579: LD_INT 1
13581: PPUSH
13582: CALL 17185 0 1
13586: IFFALSE 13702
// begin DialogueOn ;
13588: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13592: LD_VAR 0 1
13596: PPUSH
13597: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13601: LD_INT 10
13603: PPUSH
13604: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13608: LD_ADDR_VAR 0 3
13612: PUSH
13613: LD_INT 1
13615: PPUSH
13616: LD_STRING D5b-Sol1-1
13618: PPUSH
13619: CALL 17323 0 2
13623: ST_TO_ADDR
// if not un then
13624: LD_VAR 0 3
13628: NOT
13629: IFFALSE 13647
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13631: LD_ADDR_VAR 0 3
13635: PUSH
13636: LD_INT 2
13638: PPUSH
13639: LD_STRING D5b-FSol1-1
13641: PPUSH
13642: CALL 17323 0 2
13646: ST_TO_ADDR
// if un then
13647: LD_VAR 0 3
13651: IFFALSE 13696
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13653: LD_ADDR_VAR 0 4
13657: PUSH
13658: LD_INT 1
13660: PPUSH
13661: LD_STRING D5b-Sol2-1
13663: PPUSH
13664: LD_VAR 0 3
13668: PPUSH
13669: CALL 17509 0 3
13673: ST_TO_ADDR
// if not un2 then
13674: LD_VAR 0 4
13678: NOT
13679: IFFALSE 13696
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13681: LD_INT 2
13683: PPUSH
13684: LD_STRING D5b-FSol2-1
13686: PPUSH
13687: LD_VAR 0 3
13691: PPUSH
13692: CALL 17509 0 3
// end ; DialogueOff ;
13696: CALL_OW 7
// break ;
13700: GO 13704
// end ; end ;
13702: GO 13541
13704: POP
13705: POP
// end ; if not seen [ 3 ] then
13706: LD_EXP 9
13710: PUSH
13711: LD_INT 3
13713: ARRAY
13714: NOT
13715: IFFALSE 13889
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13717: LD_ADDR_VAR 0 2
13721: PUSH
13722: LD_INT 22
13724: PUSH
13725: LD_INT 2
13727: PUSH
13728: EMPTY
13729: LIST
13730: LIST
13731: PUSH
13732: LD_INT 33
13734: PUSH
13735: LD_INT 2
13737: PUSH
13738: EMPTY
13739: LIST
13740: LIST
13741: PUSH
13742: EMPTY
13743: LIST
13744: LIST
13745: PPUSH
13746: CALL_OW 69
13750: ST_TO_ADDR
// if tmp then
13751: LD_VAR 0 2
13755: IFFALSE 13889
// for i in tmp do
13757: LD_ADDR_VAR 0 1
13761: PUSH
13762: LD_VAR 0 2
13766: PUSH
13767: FOR_IN
13768: IFFALSE 13887
// if See ( 1 , i ) then
13770: LD_INT 1
13772: PPUSH
13773: LD_VAR 0 1
13777: PPUSH
13778: CALL_OW 292
13782: IFFALSE 13885
// begin seen := Replace ( seen , 3 , true ) ;
13784: LD_ADDR_EXP 9
13788: PUSH
13789: LD_EXP 9
13793: PPUSH
13794: LD_INT 3
13796: PPUSH
13797: LD_INT 1
13799: PPUSH
13800: CALL_OW 1
13804: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13805: LD_INT 1
13807: PPUSH
13808: CALL 17185 0 1
13812: IFFALSE 13885
// begin DialogueOn ;
13814: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13818: LD_VAR 0 1
13822: PPUSH
13823: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13827: LD_INT 10
13829: PPUSH
13830: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: LD_INT 1
13841: PPUSH
13842: LD_STRING D8-Sol1-1
13844: PPUSH
13845: CALL 17323 0 2
13849: ST_TO_ADDR
// if not un then
13850: LD_VAR 0 3
13854: NOT
13855: IFFALSE 13867
// SayRand ( sex_female , D8-FSol1-1 ) ;
13857: LD_INT 2
13859: PPUSH
13860: LD_STRING D8-FSol1-1
13862: PPUSH
13863: CALL 17323 0 2
// Say ( JMM , D8-JMM-1 ) ;
13867: LD_EXP 21
13871: PPUSH
13872: LD_STRING D8-JMM-1
13874: PPUSH
13875: CALL_OW 88
// DialogueOff ;
13879: CALL_OW 7
// break ;
13883: GO 13887
// end ; end ;
13885: GO 13767
13887: POP
13888: POP
// end ; if not seen [ 4 ] then
13889: LD_EXP 9
13893: PUSH
13894: LD_INT 4
13896: ARRAY
13897: NOT
13898: IFFALSE 14060
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13900: LD_ADDR_VAR 0 2
13904: PUSH
13905: LD_INT 22
13907: PUSH
13908: LD_INT 2
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: PUSH
13915: LD_INT 33
13917: PUSH
13918: LD_INT 5
13920: PUSH
13921: EMPTY
13922: LIST
13923: LIST
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PPUSH
13929: CALL_OW 69
13933: ST_TO_ADDR
// if tmp then
13934: LD_VAR 0 2
13938: IFFALSE 14060
// for i in tmp do
13940: LD_ADDR_VAR 0 1
13944: PUSH
13945: LD_VAR 0 2
13949: PUSH
13950: FOR_IN
13951: IFFALSE 14058
// if See ( 1 , i ) then
13953: LD_INT 1
13955: PPUSH
13956: LD_VAR 0 1
13960: PPUSH
13961: CALL_OW 292
13965: IFFALSE 14056
// begin seen := Replace ( seen , 4 , true ) ;
13967: LD_ADDR_EXP 9
13971: PUSH
13972: LD_EXP 9
13976: PPUSH
13977: LD_INT 4
13979: PPUSH
13980: LD_INT 1
13982: PPUSH
13983: CALL_OW 1
13987: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13988: LD_INT 1
13990: PPUSH
13991: CALL 17185 0 1
13995: IFFALSE 14056
// begin DialogueOn ;
13997: CALL_OW 6
// CenterNowOnUnits ( i ) ;
14001: LD_VAR 0 1
14005: PPUSH
14006: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
14010: LD_INT 10
14012: PPUSH
14013: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
14017: LD_ADDR_VAR 0 3
14021: PUSH
14022: LD_INT 1
14024: PPUSH
14025: LD_STRING D5a-Sol1-1
14027: PPUSH
14028: CALL 17323 0 2
14032: ST_TO_ADDR
// if not un then
14033: LD_VAR 0 3
14037: NOT
14038: IFFALSE 14050
// SayRand ( sex_female , D5a-FSol1-1 ) ;
14040: LD_INT 2
14042: PPUSH
14043: LD_STRING D5a-FSol1-1
14045: PPUSH
14046: CALL 17323 0 2
// DialogueOff ;
14050: CALL_OW 7
// break ;
14054: GO 14058
// end ; end ;
14056: GO 13950
14058: POP
14059: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
14060: LD_EXP 9
14064: PUSH
14065: LD_INT 5
14067: ARRAY
14068: NOT
14069: IFFALSE 14081
14071: PUSH
14072: LD_EXP 9
14076: PUSH
14077: LD_INT 3
14079: ARRAY
14080: AND
14081: IFFALSE 14255
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
14083: LD_ADDR_VAR 0 2
14087: PUSH
14088: LD_INT 22
14090: PUSH
14091: LD_INT 2
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: PUSH
14098: LD_INT 34
14100: PUSH
14101: LD_INT 31
14103: PUSH
14104: EMPTY
14105: LIST
14106: LIST
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PPUSH
14112: CALL_OW 69
14116: ST_TO_ADDR
// if tmp then
14117: LD_VAR 0 2
14121: IFFALSE 14255
// for i in tmp do
14123: LD_ADDR_VAR 0 1
14127: PUSH
14128: LD_VAR 0 2
14132: PUSH
14133: FOR_IN
14134: IFFALSE 14253
// if See ( 1 , i ) then
14136: LD_INT 1
14138: PPUSH
14139: LD_VAR 0 1
14143: PPUSH
14144: CALL_OW 292
14148: IFFALSE 14251
// begin seen := Replace ( seen , 5 , true ) ;
14150: LD_ADDR_EXP 9
14154: PUSH
14155: LD_EXP 9
14159: PPUSH
14160: LD_INT 5
14162: PPUSH
14163: LD_INT 1
14165: PPUSH
14166: CALL_OW 1
14170: ST_TO_ADDR
// if CanSayRand ( 1 ) then
14171: LD_INT 1
14173: PPUSH
14174: CALL 17185 0 1
14178: IFFALSE 14251
// begin DialogueOn ;
14180: CALL_OW 6
// CenterNowOnUnits ( i ) ;
14184: LD_VAR 0 1
14188: PPUSH
14189: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
14193: LD_INT 10
14195: PPUSH
14196: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
14200: LD_ADDR_VAR 0 3
14204: PUSH
14205: LD_INT 1
14207: PPUSH
14208: LD_STRING D8a-Sol2-1
14210: PPUSH
14211: CALL 17323 0 2
14215: ST_TO_ADDR
// if not un then
14216: LD_VAR 0 3
14220: NOT
14221: IFFALSE 14233
// SayRand ( sex_female , D8a-FSol2-1 ) ;
14223: LD_INT 2
14225: PPUSH
14226: LD_STRING D8a-FSol2-1
14228: PPUSH
14229: CALL 17323 0 2
// Say ( JMM , D8a-JMM-1 ) ;
14233: LD_EXP 21
14237: PPUSH
14238: LD_STRING D8a-JMM-1
14240: PPUSH
14241: CALL_OW 88
// DialogueOff ;
14245: CALL_OW 7
// break ;
14249: GO 14253
// end ; end ;
14251: GO 14133
14253: POP
14254: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
14255: LD_EXP 9
14259: PUSH
14260: LD_INT 1
14262: ARRAY
14263: IFFALSE 14275
14265: PUSH
14266: LD_EXP 9
14270: PUSH
14271: LD_INT 2
14273: ARRAY
14274: AND
14275: IFFALSE 14287
14277: PUSH
14278: LD_EXP 9
14282: PUSH
14283: LD_INT 3
14285: ARRAY
14286: AND
14287: IFFALSE 14299
14289: PUSH
14290: LD_EXP 9
14294: PUSH
14295: LD_INT 4
14297: ARRAY
14298: AND
14299: IFFALSE 14311
14301: PUSH
14302: LD_EXP 9
14306: PUSH
14307: LD_INT 5
14309: ARRAY
14310: AND
14311: IFFALSE 14314
// disable ;
14313: DISABLE
// end ;
14314: PPOPN 4
14316: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14317: LD_EXP 10
14321: IFFALSE 14329
14323: PUSH
14324: LD_EXP 11
14328: AND
14329: IFFALSE 14527
14331: GO 14333
14333: DISABLE
14334: LD_INT 0
14336: PPUSH
// begin DialogueOn ;
14337: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14341: LD_EXP 11
14345: PPUSH
14346: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14350: LD_ADDR_VAR 0 1
14354: PUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_STRING D5c-Sol1-1
14360: PPUSH
14361: CALL 17323 0 2
14365: ST_TO_ADDR
// if not un then
14366: LD_VAR 0 1
14370: NOT
14371: IFFALSE 14389
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14373: LD_ADDR_VAR 0 1
14377: PUSH
14378: LD_INT 2
14380: PPUSH
14381: LD_STRING D5c-FSol1-1
14383: PPUSH
14384: CALL 17323 0 2
14388: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14389: LD_EXP 21
14393: PPUSH
14394: LD_STRING D5c-JMM-1
14396: PPUSH
14397: CALL_OW 88
// if IsOk ( Lisa ) then
14401: LD_EXP 22
14405: PPUSH
14406: CALL_OW 302
14410: IFFALSE 14426
// Say ( Lisa , D5d-Lisa-1 ) else
14412: LD_EXP 22
14416: PPUSH
14417: LD_STRING D5d-Lisa-1
14419: PPUSH
14420: CALL_OW 88
14424: GO 14511
// if IsOk ( Cyrus ) then
14426: LD_EXP 25
14430: PPUSH
14431: CALL_OW 302
14435: IFFALSE 14451
// Say ( Cyrus , D5d-Cyrus-1 ) else
14437: LD_EXP 25
14441: PPUSH
14442: LD_STRING D5d-Cyrus-1
14444: PPUSH
14445: CALL_OW 88
14449: GO 14511
// if IsOk ( Gary ) then
14451: LD_EXP 32
14455: PPUSH
14456: CALL_OW 302
14460: IFFALSE 14476
// Say ( Gary , D5d-Gary-1 ) else
14462: LD_EXP 32
14466: PPUSH
14467: LD_STRING D5d-Gary-1
14469: PPUSH
14470: CALL_OW 88
14474: GO 14511
// if GetSex ( un ) = sex_male then
14476: LD_VAR 0 1
14480: PPUSH
14481: CALL_OW 258
14485: PUSH
14486: LD_INT 1
14488: EQUAL
14489: IFFALSE 14505
// Say ( un , D5d-Sol1-1 ) else
14491: LD_VAR 0 1
14495: PPUSH
14496: LD_STRING D5d-Sol1-1
14498: PPUSH
14499: CALL_OW 88
14503: GO 14511
// begin DialogueOff ;
14505: CALL_OW 7
// exit ;
14509: GO 14527
// end ; Say ( JMM , D5d-JMM-1 ) ;
14511: LD_EXP 21
14515: PPUSH
14516: LD_STRING D5d-JMM-1
14518: PPUSH
14519: CALL_OW 88
// DialogueOff ;
14523: CALL_OW 7
// end ;
14527: PPOPN 1
14529: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14530: LD_INT 1
14532: PPUSH
14533: LD_INT 17
14535: PPUSH
14536: CALL_OW 294
14540: PUSH
14541: LD_INT 2
14543: GREATEREQUAL
14544: IFFALSE 14676
14546: GO 14548
14548: DISABLE
14549: LD_INT 0
14551: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14552: LD_INT 10
14554: PPUSH
14555: LD_INT 5
14557: PPUSH
14558: LD_INT 1
14560: PPUSH
14561: LD_INT 10
14563: NEG
14564: PPUSH
14565: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14569: LD_INT 10
14571: PPUSH
14572: LD_INT 5
14574: PPUSH
14575: LD_INT 1
14577: PPUSH
14578: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14582: LD_INT 10
14584: PPUSH
14585: LD_INT 5
14587: PPUSH
14588: CALL_OW 86
// DialogueOn ;
14592: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14596: LD_ADDR_VAR 0 1
14600: PUSH
14601: LD_INT 1
14603: PPUSH
14604: LD_STRING D6-Sci1-1
14606: PPUSH
14607: CALL 17323 0 2
14611: ST_TO_ADDR
// if un then
14612: LD_VAR 0 1
14616: IFFALSE 14654
// begin Say ( JMM , D6-JMM-1 ) ;
14618: LD_EXP 21
14622: PPUSH
14623: LD_STRING D6-JMM-1
14625: PPUSH
14626: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14630: LD_VAR 0 1
14634: PPUSH
14635: LD_STRING D6-Sci1-2
14637: PPUSH
14638: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14642: LD_EXP 21
14646: PPUSH
14647: LD_STRING D6-JMM-2
14649: PPUSH
14650: CALL_OW 88
// end ; DialogueOff ;
14654: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14658: LD_STRING M3
14660: PPUSH
14661: CALL_OW 337
// wait ( 0 0$30 ) ;
14665: LD_INT 1050
14667: PPUSH
14668: CALL_OW 67
// AmericanReinforcements ;
14672: CALL 2127 0 0
// end ;
14676: PPOPN 1
14678: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14679: LD_OWVAR 1
14683: PUSH
14684: LD_INT 42000
14686: GREATEREQUAL
14687: IFFALSE 14741
14689: PUSH
14690: LD_INT 2
14692: PPUSH
14693: LD_INT 169
14695: PPUSH
14696: LD_INT 90
14698: PPUSH
14699: LD_INT 10
14701: PPUSH
14702: CALL 56167 0 4
14706: PUSH
14707: LD_INT 4
14709: ARRAY
14710: PUSH
14711: LD_INT 0
14713: EQUAL
14714: IFTRUE 14725
14716: PUSH
14717: LD_INT 45
14719: PPUSH
14720: CALL_OW 301
14724: OR
14725: IFTRUE 14740
14727: PUSH
14728: LD_INT 45
14730: PPUSH
14731: CALL_OW 255
14735: PUSH
14736: LD_INT 1
14738: EQUAL
14739: OR
14740: AND
14741: IFFALSE 14753
14743: PUSH
14744: LD_INT 94
14746: PPUSH
14747: CALL_OW 301
14751: NOT
14752: AND
14753: IFFALSE 15966
14755: GO 14757
14757: DISABLE
14758: LD_INT 0
14760: PPUSH
14761: PPUSH
14762: PPUSH
14763: PPUSH
14764: PPUSH
// begin uc_side := 5 ;
14765: LD_ADDR_OWVAR 20
14769: PUSH
14770: LD_INT 5
14772: ST_TO_ADDR
// uc_nation := 2 ;
14773: LD_ADDR_OWVAR 21
14777: PUSH
14778: LD_INT 2
14780: ST_TO_ADDR
// InitHc ;
14781: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14785: LD_INT 1
14787: PPUSH
14788: LD_INT 3
14790: PPUSH
14791: LD_INT 8
14793: PPUSH
14794: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14798: LD_ADDR_OWVAR 29
14802: PUSH
14803: LD_INT 12
14805: PUSH
14806: LD_INT 12
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: ST_TO_ADDR
// hc_name := Hans Fliege ;
14813: LD_ADDR_OWVAR 26
14817: PUSH
14818: LD_STRING Hans Fliege
14820: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14821: LD_ADDR_OWVAR 33
14825: PUSH
14826: LD_STRING SecondCharsGal
14828: ST_TO_ADDR
// hc_face_number := 7 ;
14829: LD_ADDR_OWVAR 34
14833: PUSH
14834: LD_INT 7
14836: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14837: LD_ADDR_EXP 46
14841: PUSH
14842: CALL_OW 44
14846: ST_TO_ADDR
// InitHc ;
14847: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14851: LD_INT 1
14853: PPUSH
14854: LD_INT 16
14856: PPUSH
14857: LD_INT 2
14859: PPUSH
14860: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14864: LD_ADDR_OWVAR 29
14868: PUSH
14869: LD_INT 12
14871: PUSH
14872: LD_INT 12
14874: PUSH
14875: EMPTY
14876: LIST
14877: LIST
14878: ST_TO_ADDR
// hc_name :=  ;
14879: LD_ADDR_OWVAR 26
14883: PUSH
14884: LD_STRING 
14886: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14887: LD_ADDR_EXP 47
14891: PUSH
14892: CALL_OW 44
14896: ST_TO_ADDR
// InitHc ;
14897: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14901: LD_INT 35
14903: PPUSH
14904: CALL_OW 67
// until not InBattle ( 1 ) ;
14908: LD_INT 1
14910: PPUSH
14911: CALL_OW 463
14915: NOT
14916: IFFALSE 14901
// wait ( 0 0$5 ) ;
14918: LD_INT 175
14920: PPUSH
14921: CALL_OW 67
// DialogueOn ;
14925: CALL_OW 6
// InGameOn ;
14929: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14933: LD_ADDR_VAR 0 1
14937: PUSH
14938: LD_INT 22
14940: PUSH
14941: LD_INT 1
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PUSH
14948: LD_INT 2
14950: PUSH
14951: LD_INT 25
14953: PUSH
14954: LD_INT 1
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: PUSH
14961: LD_INT 25
14963: PUSH
14964: LD_INT 2
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PUSH
14971: LD_INT 25
14973: PUSH
14974: LD_INT 3
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PUSH
14981: LD_INT 25
14983: PUSH
14984: LD_INT 4
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: PUSH
14991: LD_INT 25
14993: PUSH
14994: LD_INT 5
14996: PUSH
14997: EMPTY
14998: LIST
14999: LIST
15000: PUSH
15001: LD_INT 25
15003: PUSH
15004: LD_INT 8
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PPUSH
15024: CALL_OW 69
15028: PUSH
15029: LD_EXP 21
15033: PUSH
15034: LD_EXP 22
15038: PUSH
15039: LD_EXP 23
15043: PUSH
15044: LD_EXP 24
15048: PUSH
15049: LD_EXP 25
15053: PUSH
15054: LD_EXP 26
15058: PUSH
15059: LD_EXP 27
15063: PUSH
15064: LD_EXP 28
15068: PUSH
15069: LD_EXP 29
15073: PUSH
15074: LD_EXP 31
15078: PUSH
15079: LD_EXP 32
15083: PUSH
15084: LD_EXP 33
15088: PUSH
15089: LD_EXP 34
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: LIST
15106: LIST
15107: LIST
15108: DIFF
15109: PPUSH
15110: LD_INT 26
15112: PUSH
15113: LD_INT 1
15115: PUSH
15116: EMPTY
15117: LIST
15118: LIST
15119: PPUSH
15120: CALL_OW 72
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// if Brown then
15129: LD_EXP 27
15133: IFFALSE 15145
// un := Brown ;
15135: LD_ADDR_VAR 0 1
15139: PUSH
15140: LD_EXP 27
15144: ST_TO_ADDR
// if un then
15145: LD_VAR 0 1
15149: IFFALSE 15175
// begin Say ( un , D7-Sol1-1 ) ;
15151: LD_VAR 0 1
15155: PPUSH
15156: LD_STRING D7-Sol1-1
15158: PPUSH
15159: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
15163: LD_EXP 21
15167: PPUSH
15168: LD_STRING D7-JMM-1
15170: PPUSH
15171: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
15175: LD_EXP 46
15179: PPUSH
15180: LD_STRING D7-Ar1-1
15182: PPUSH
15183: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
15187: LD_EXP 21
15191: PPUSH
15192: LD_STRING D7-JMM-2
15194: PPUSH
15195: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
15199: LD_EXP 46
15203: PPUSH
15204: LD_STRING D7-Ar1-2
15206: PPUSH
15207: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
15211: LD_EXP 21
15215: PPUSH
15216: LD_STRING D7-JMM-3
15218: PPUSH
15219: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
15223: LD_EXP 46
15227: PPUSH
15228: LD_STRING D7-Ar1-3
15230: PPUSH
15231: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
15235: LD_EXP 21
15239: PPUSH
15240: LD_STRING D7-JMM-4
15242: PPUSH
15243: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
15247: LD_EXP 46
15251: PPUSH
15252: LD_STRING D7-Ar1-4
15254: PPUSH
15255: CALL_OW 94
// InGameOff ;
15259: CALL_OW 9
// DialogueOff ;
15263: CALL_OW 7
// case Query ( QCameras ) of 1 :
15267: LD_STRING QCameras
15269: PPUSH
15270: CALL_OW 97
15274: PUSH
15275: LD_INT 1
15277: DOUBLE
15278: EQUAL
15279: IFTRUE 15283
15281: GO 15286
15283: POP
// ; 2 :
15284: GO 15300
15286: LD_INT 2
15288: DOUBLE
15289: EQUAL
15290: IFTRUE 15294
15292: GO 15299
15294: POP
// exit ; end ;
15295: GO 15966
15297: GO 15300
15299: POP
// ChangeMissionObjectives ( MCar ) ;
15300: LD_STRING MCar
15302: PPUSH
15303: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
15307: LD_INT 124
15309: PPUSH
15310: LD_INT 90
15312: PPUSH
15313: LD_INT 1
15315: PPUSH
15316: LD_INT 6
15318: NEG
15319: PPUSH
15320: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15324: LD_INT 124
15326: PPUSH
15327: LD_INT 90
15329: PPUSH
15330: LD_INT 1
15332: PPUSH
15333: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15337: LD_INT 12
15339: PPUSH
15340: LD_INT 1
15342: PPUSH
15343: CALL_OW 424
// wait ( 3 ) ;
15347: LD_INT 3
15349: PPUSH
15350: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15354: LD_INT 124
15356: PPUSH
15357: LD_INT 90
15359: PPUSH
15360: CALL_OW 86
// cargo := false ;
15364: LD_ADDR_VAR 0 3
15368: PUSH
15369: LD_INT 0
15371: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15372: LD_INT 35
15374: PPUSH
15375: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15379: LD_ADDR_VAR 0 3
15383: PUSH
15384: LD_INT 12
15386: PPUSH
15387: LD_INT 32
15389: PUSH
15390: LD_INT 3
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: PUSH
15397: LD_INT 34
15399: PUSH
15400: LD_INT 32
15402: PUSH
15403: EMPTY
15404: LIST
15405: LIST
15406: PUSH
15407: LD_INT 58
15409: PUSH
15410: EMPTY
15411: LIST
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: PPUSH
15418: CALL_OW 70
15422: ST_TO_ADDR
// until cargo ;
15423: LD_VAR 0 3
15427: IFFALSE 15372
// cargo := cargo [ 1 ] ;
15429: LD_ADDR_VAR 0 3
15433: PUSH
15434: LD_VAR 0 3
15438: PUSH
15439: LD_INT 1
15441: ARRAY
15442: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15443: LD_VAR 0 3
15447: PPUSH
15448: LD_INT 5
15450: PPUSH
15451: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15455: LD_INT 12
15457: PPUSH
15458: LD_INT 0
15460: PPUSH
15461: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15465: LD_EXP 46
15469: PPUSH
15470: LD_INT 11
15472: PPUSH
15473: LD_INT 0
15475: PPUSH
15476: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15480: LD_EXP 47
15484: PPUSH
15485: LD_INT 11
15487: PPUSH
15488: LD_INT 0
15490: PPUSH
15491: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15495: LD_EXP 46
15499: PUSH
15500: LD_EXP 47
15504: PUSH
15505: EMPTY
15506: LIST
15507: LIST
15508: PPUSH
15509: LD_INT 12
15511: PPUSH
15512: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15516: LD_EXP 46
15520: PPUSH
15521: LD_VAR 0 3
15525: PPUSH
15526: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15530: LD_EXP 46
15534: PUSH
15535: LD_EXP 47
15539: PUSH
15540: EMPTY
15541: LIST
15542: LIST
15543: PPUSH
15544: LD_INT 209
15546: PPUSH
15547: LD_INT 178
15549: PPUSH
15550: CALL_OW 171
// escaped := 0 ;
15554: LD_ADDR_VAR 0 5
15558: PUSH
15559: LD_INT 0
15561: ST_TO_ADDR
// while ( true ) do
15562: LD_INT 1
15564: IFFALSE 15788
// begin wait ( 0 0$1 ) ;
15566: LD_INT 35
15568: PPUSH
15569: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15573: LD_EXP 46
15577: PPUSH
15578: CALL_OW 314
15582: NOT
15583: IFTRUE 15597
15585: PUSH
15586: LD_EXP 47
15590: PPUSH
15591: CALL_OW 314
15595: NOT
15596: OR
15597: IFFALSE 15623
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15599: LD_EXP 46
15603: PUSH
15604: LD_EXP 47
15608: PUSH
15609: EMPTY
15610: LIST
15611: LIST
15612: PPUSH
15613: LD_INT 209
15615: PPUSH
15616: LD_INT 178
15618: PPUSH
15619: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15623: LD_EXP 46
15627: PPUSH
15628: LD_INT 10
15630: PPUSH
15631: CALL_OW 308
15635: IFFALSE 15660
// begin RemoveUnit ( ar_mechanic ) ;
15637: LD_EXP 46
15641: PPUSH
15642: CALL_OW 64
// escaped := escaped + 1 ;
15646: LD_ADDR_VAR 0 5
15650: PUSH
15651: LD_VAR 0 5
15655: PUSH
15656: LD_INT 1
15658: PLUS
15659: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15660: LD_EXP 47
15664: PPUSH
15665: LD_INT 10
15667: PPUSH
15668: CALL_OW 308
15672: IFFALSE 15697
// begin RemoveUnit ( ar_mechanic_friend ) ;
15674: LD_EXP 47
15678: PPUSH
15679: CALL_OW 64
// escaped := escaped + 1 ;
15683: LD_ADDR_VAR 0 5
15687: PUSH
15688: LD_VAR 0 5
15692: PUSH
15693: LD_INT 1
15695: PLUS
15696: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15697: LD_VAR 0 3
15701: PPUSH
15702: LD_INT 10
15704: PPUSH
15705: CALL_OW 308
15709: IFFALSE 15720
// RemoveUnit ( cargo ) ;
15711: LD_VAR 0 3
15715: PPUSH
15716: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15720: LD_EXP 46
15724: PPUSH
15725: CALL_OW 305
15729: NOT
15730: IFFALSE 15742
15732: PUSH
15733: LD_VAR 0 5
15737: PUSH
15738: LD_INT 2
15740: GREATEREQUAL
15741: AND
15742: IFFALSE 15746
// break ;
15744: GO 15788
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15746: LD_EXP 46
15750: PPUSH
15751: CALL_OW 305
15755: NOT
15756: IFFALSE 15770
15758: PUSH
15759: LD_EXP 47
15763: PPUSH
15764: CALL_OW 305
15768: NOT
15769: AND
15770: IFFALSE 15782
15772: PUSH
15773: LD_VAR 0 5
15777: PUSH
15778: LD_INT 2
15780: LESS
15781: AND
15782: IFFALSE 15786
// exit ;
15784: GO 15966
// end ;
15786: GO 15562
// wait ( 0 0$2 ) ;
15788: LD_INT 70
15790: PPUSH
15791: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15795: LD_EXP 46
15799: PPUSH
15800: LD_STRING D7a-Ar1-1
15802: PPUSH
15803: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15807: LD_ADDR_VAR 0 4
15811: PUSH
15812: LD_INT 129
15814: PUSH
15815: LD_INT 10
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PUSH
15822: LD_INT 103
15824: PUSH
15825: LD_INT 6
15827: PUSH
15828: EMPTY
15829: LIST
15830: LIST
15831: PUSH
15832: LD_INT 148
15834: PUSH
15835: LD_INT 47
15837: PUSH
15838: EMPTY
15839: LIST
15840: LIST
15841: PUSH
15842: LD_INT 155
15844: PUSH
15845: LD_INT 16
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: EMPTY
15853: LIST
15854: LIST
15855: LIST
15856: LIST
15857: ST_TO_ADDR
// if Difficulty = 1 then
15858: LD_OWVAR 67
15862: PUSH
15863: LD_INT 1
15865: EQUAL
15866: IFFALSE 15903
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15868: LD_ADDR_VAR 0 4
15872: PUSH
15873: LD_VAR 0 4
15877: PUSH
15878: LD_INT 78
15880: PUSH
15881: LD_INT 7
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: PUSH
15888: LD_INT 104
15890: PUSH
15891: LD_INT 43
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: ADD
15902: ST_TO_ADDR
// for i in tmp do
15903: LD_ADDR_VAR 0 2
15907: PUSH
15908: LD_VAR 0 4
15912: PUSH
15913: FOR_IN
15914: IFFALSE 15947
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15916: LD_VAR 0 2
15920: PUSH
15921: LD_INT 1
15923: ARRAY
15924: PPUSH
15925: LD_VAR 0 2
15929: PUSH
15930: LD_INT 2
15932: ARRAY
15933: PPUSH
15934: LD_INT 1
15936: PPUSH
15937: LD_INT 9
15939: NEG
15940: PPUSH
15941: CALL_OW 330
15945: GO 15913
15947: POP
15948: POP
// SetAchievement ( ACH_FRIEND ) ;
15949: LD_STRING ACH_FRIEND
15951: PPUSH
15952: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15956: LD_INT 129
15958: PPUSH
15959: LD_INT 10
15961: PPUSH
15962: CALL_OW 84
// end ;
15966: PPOPN 5
15968: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15969: LD_EXP 15
15973: PUSH
15974: LD_INT 21000
15976: MINUS
15977: PUSH
15978: LD_OWVAR 1
15982: LESSEQUAL
15983: IFFALSE 16023
15985: GO 15987
15987: DISABLE
// begin powell_warn := true ;
15988: LD_ADDR_EXP 16
15992: PUSH
15993: LD_INT 1
15995: ST_TO_ADDR
// DialogueOn ;
15996: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
16000: LD_EXP 30
16004: PPUSH
16005: LD_STRING D9-Pow-1
16007: PPUSH
16008: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
16012: LD_INT 10
16014: PPUSH
16015: CALL_OW 68
// DialogueOff ;
16019: CALL_OW 7
// end ;
16023: END
// every 0 0$1 trigger game_time <= tick do
16024: LD_EXP 15
16028: PUSH
16029: LD_OWVAR 1
16033: LESSEQUAL
16034: IFFALSE 16073
16036: GO 16038
16038: DISABLE
// begin DialogueOn ;
16039: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
16043: LD_EXP 30
16047: PPUSH
16048: LD_STRING D9a-Pow-1
16050: PPUSH
16051: CALL_OW 94
// dwait ( 0 0$2 ) ;
16055: LD_INT 70
16057: PPUSH
16058: CALL_OW 68
// DialogueOff ;
16062: CALL_OW 7
// YouLost ( Command ) ;
16066: LD_STRING Command
16068: PPUSH
16069: CALL_OW 104
// end ;
16073: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
16074: LD_INT 22
16076: PUSH
16077: LD_INT 2
16079: PUSH
16080: EMPTY
16081: LIST
16082: LIST
16083: PUSH
16084: LD_INT 30
16086: PUSH
16087: LD_INT 1
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: PPUSH
16098: CALL_OW 69
16102: PUSH
16103: LD_INT 0
16105: EQUAL
16106: IFFALSE 16119
16108: PUSH
16109: LD_EXP 21
16113: PPUSH
16114: CALL_OW 302
16118: AND
16119: IFFALSE 16167
16121: GO 16123
16123: DISABLE
// begin case Query ( QEndMission ) of 1 :
16124: LD_STRING QEndMission
16126: PPUSH
16127: CALL_OW 97
16131: PUSH
16132: LD_INT 1
16134: DOUBLE
16135: EQUAL
16136: IFTRUE 16140
16138: GO 16151
16140: POP
// end_the_mission_allowed := true ; 2 :
16141: LD_ADDR_OWVAR 57
16145: PUSH
16146: LD_INT 1
16148: ST_TO_ADDR
16149: GO 16167
16151: LD_INT 2
16153: DOUBLE
16154: EQUAL
16155: IFTRUE 16159
16157: GO 16166
16159: POP
// EndMission ; end ;
16160: CALL 16189 0 0
16164: GO 16167
16166: POP
// end ;
16167: END
// on EndTheMissionRaised ( p ) do begin if end_the_mission_allowed then
16168: LD_OWVAR 57
16172: IFFALSE 16186
// begin end_the_mission_allowed := false ;
16174: LD_ADDR_OWVAR 57
16178: PUSH
16179: LD_INT 0
16181: ST_TO_ADDR
// EndMission ;
16182: CALL 16189 0 0
// end ; end ;
16186: PPOPN 1
16188: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
16189: LD_INT 0
16191: PPUSH
16192: PPUSH
16193: PPUSH
16194: PPUSH
16195: PPUSH
// m1 := false ;
16196: LD_ADDR_VAR 0 3
16200: PUSH
16201: LD_INT 0
16203: ST_TO_ADDR
// m2 := false ;
16204: LD_ADDR_VAR 0 4
16208: PUSH
16209: LD_INT 0
16211: ST_TO_ADDR
// m3 := false ;
16212: LD_ADDR_VAR 0 5
16216: PUSH
16217: LD_INT 0
16219: ST_TO_ADDR
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 9 then
16220: LD_INT 22
16222: PUSH
16223: LD_INT 1
16225: PUSH
16226: EMPTY
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 21
16232: PUSH
16233: LD_INT 1
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: LD_INT 23
16242: PUSH
16243: LD_INT 1
16245: PUSH
16246: EMPTY
16247: LIST
16248: LIST
16249: PUSH
16250: LD_INT 50
16252: PUSH
16253: EMPTY
16254: LIST
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: LIST
16261: PPUSH
16262: CALL_OW 69
16266: PPUSH
16267: CALL 51979 0 1
16271: PUSH
16272: LD_INT 9
16274: LESS
16275: IFFALSE 16286
// begin YouLost ( LostVictory ) ;
16277: LD_STRING LostVictory
16279: PPUSH
16280: CALL_OW 104
// exit ;
16284: GO 17180
// end ; if not am_veh_consturcted then
16286: LD_EXP 20
16290: NOT
16291: IFFALSE 16300
// SetAchievement ( ACH_ARABTECH ) ;
16293: LD_STRING ACH_ARABTECH
16295: PPUSH
16296: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
16300: LD_OWVAR 1
16304: PUSH
16305: LD_INT 252000
16307: PUSH
16308: LD_INT 210000
16310: PUSH
16311: LD_INT 199500
16313: PUSH
16314: LD_INT 193200
16316: PUSH
16317: EMPTY
16318: LIST
16319: LIST
16320: LIST
16321: LIST
16322: PUSH
16323: LD_OWVAR 67
16327: ARRAY
16328: LESS
16329: IFFALSE 16351
// begin m3 := true ;
16331: LD_ADDR_VAR 0 5
16335: PUSH
16336: LD_INT 1
16338: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
16339: LD_STRING Time1
16341: PPUSH
16342: LD_INT 1
16344: PPUSH
16345: CALL_OW 101
// end else
16349: GO 16382
// if not powell_warn then
16351: LD_EXP 16
16355: NOT
16356: IFFALSE 16371
// AddMedal ( Time1 , - 1 ) else
16358: LD_STRING Time1
16360: PPUSH
16361: LD_INT 1
16363: NEG
16364: PPUSH
16365: CALL_OW 101
16369: GO 16382
// AddMedal ( Time1 , - 2 ) ;
16371: LD_STRING Time1
16373: PPUSH
16374: LD_INT 2
16376: NEG
16377: PPUSH
16378: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
16382: LD_EXP 17
16386: PUSH
16387: LD_INT 5
16389: PUSH
16390: LD_INT 4
16392: PUSH
16393: LD_INT 3
16395: PUSH
16396: LD_INT 3
16398: PUSH
16399: EMPTY
16400: LIST
16401: LIST
16402: LIST
16403: LIST
16404: PUSH
16405: LD_OWVAR 67
16409: ARRAY
16410: GREATEREQUAL
16411: IFFALSE 16426
// AddMedal ( Destroy , - 2 ) else
16413: LD_STRING Destroy
16415: PPUSH
16416: LD_INT 2
16418: NEG
16419: PPUSH
16420: CALL_OW 101
16424: GO 16559
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16426: LD_INT 22
16428: PUSH
16429: LD_INT 2
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: PUSH
16436: LD_INT 21
16438: PUSH
16439: LD_INT 3
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PUSH
16446: LD_INT 50
16448: PUSH
16449: EMPTY
16450: LIST
16451: PUSH
16452: EMPTY
16453: LIST
16454: LIST
16455: LIST
16456: PPUSH
16457: CALL_OW 69
16461: PUSH
16462: LD_INT 25
16464: GREATEREQUAL
16465: IFFALSE 16480
// AddMedal ( Destroy , - 1 ) else
16467: LD_STRING Destroy
16469: PPUSH
16470: LD_INT 1
16472: NEG
16473: PPUSH
16474: CALL_OW 101
16478: GO 16559
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16480: LD_INT 22
16482: PUSH
16483: LD_INT 2
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: PUSH
16490: LD_INT 21
16492: PUSH
16493: LD_INT 3
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: PUSH
16500: LD_INT 50
16502: PUSH
16503: EMPTY
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: LIST
16510: PPUSH
16511: CALL_OW 69
16515: PUSH
16516: LD_INT 15
16518: GREATEREQUAL
16519: IFFALSE 16541
// begin m1 := true ;
16521: LD_ADDR_VAR 0 3
16525: PUSH
16526: LD_INT 1
16528: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16529: LD_STRING Destroy
16531: PPUSH
16532: LD_INT 1
16534: PPUSH
16535: CALL_OW 101
// end else
16539: GO 16559
// begin m1 := true ;
16541: LD_ADDR_VAR 0 3
16545: PUSH
16546: LD_INT 1
16548: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16549: LD_STRING Destroy
16551: PPUSH
16552: LD_INT 2
16554: PPUSH
16555: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16559: LD_EXP 13
16563: PPUSH
16564: LD_STRING 11_artifact_captured
16566: PPUSH
16567: CALL_OW 39
// if artifact_get then
16571: LD_EXP 13
16575: IFFALSE 16597
// begin m2 := true ;
16577: LD_ADDR_VAR 0 4
16581: PUSH
16582: LD_INT 1
16584: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16585: LD_STRING Artefact
16587: PPUSH
16588: LD_INT 1
16590: PPUSH
16591: CALL_OW 101
// end else
16595: GO 16608
// AddMedal ( Artefact , - 1 ) ;
16597: LD_STRING Artefact
16599: PPUSH
16600: LD_INT 1
16602: NEG
16603: PPUSH
16604: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16608: LD_VAR 0 3
16612: IFFALSE 16620
16614: PUSH
16615: LD_VAR 0 4
16619: AND
16620: IFFALSE 16628
16622: PUSH
16623: LD_VAR 0 5
16627: AND
16628: IFFALSE 16640
16630: PUSH
16631: LD_OWVAR 67
16635: PUSH
16636: LD_INT 3
16638: GREATEREQUAL
16639: AND
16640: IFFALSE 16652
// SetAchievementEX ( ACH_AMER , 11 ) ;
16642: LD_STRING ACH_AMER
16644: PPUSH
16645: LD_INT 11
16647: PPUSH
16648: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16652: LD_VAR 0 3
16656: IFFALSE 16664
16658: PUSH
16659: LD_VAR 0 4
16663: AND
16664: IFFALSE 16672
16666: PUSH
16667: LD_VAR 0 5
16671: AND
16672: IFFALSE 16684
16674: PUSH
16675: LD_EXP 17
16679: PUSH
16680: LD_INT 0
16682: EQUAL
16683: AND
16684: IFFALSE 16700
// begin wait ( 3 ) ;
16686: LD_INT 3
16688: PPUSH
16689: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16693: LD_STRING ACH_GENERAL
16695: PPUSH
16696: CALL_OW 543
// end ; if tick <= 100 100$00 then
16700: LD_OWVAR 1
16704: PUSH
16705: LD_INT 210000
16707: LESSEQUAL
16708: IFFALSE 16724
// begin wait ( 3 ) ;
16710: LD_INT 3
16712: PPUSH
16713: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16717: LD_STRING ACH_ASPEED_11
16719: PPUSH
16720: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16724: LD_STRING MAIN
16726: PPUSH
16727: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16731: LD_ADDR_EXP 19
16735: PUSH
16736: LD_EXP 19
16740: PPUSH
16741: LD_INT 51
16743: PUSH
16744: EMPTY
16745: LIST
16746: PPUSH
16747: CALL_OW 72
16751: ST_TO_ADDR
// tmp := JMM ^ selected ;
16752: LD_ADDR_VAR 0 2
16756: PUSH
16757: LD_EXP 21
16761: PUSH
16762: LD_EXP 19
16766: ADD
16767: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16768: LD_VAR 0 2
16772: PPUSH
16773: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16777: LD_VAR 0 2
16781: PUSH
16782: LD_EXP 21
16786: PUSH
16787: LD_EXP 22
16791: PUSH
16792: LD_EXP 23
16796: PUSH
16797: LD_EXP 24
16801: PUSH
16802: LD_EXP 25
16806: PUSH
16807: LD_EXP 26
16811: PUSH
16812: LD_EXP 27
16816: PUSH
16817: LD_EXP 28
16821: PUSH
16822: LD_EXP 29
16826: PUSH
16827: LD_EXP 31
16831: PUSH
16832: LD_EXP 32
16836: PUSH
16837: LD_EXP 33
16841: PUSH
16842: LD_EXP 34
16846: PUSH
16847: EMPTY
16848: LIST
16849: LIST
16850: LIST
16851: LIST
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: DIFF
16862: PPUSH
16863: LD_STRING 11c_others
16865: PPUSH
16866: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16870: LD_EXP 21
16874: PPUSH
16875: LD_EXP 3
16879: PUSH
16880: LD_STRING JMM
16882: STR
16883: PPUSH
16884: CALL_OW 38
// if Lisa then
16888: LD_EXP 22
16892: IFFALSE 16912
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16894: LD_EXP 22
16898: PPUSH
16899: LD_EXP 3
16903: PUSH
16904: LD_STRING Lisa
16906: STR
16907: PPUSH
16908: CALL_OW 38
// if Donaldson then
16912: LD_EXP 23
16916: IFFALSE 16936
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16918: LD_EXP 23
16922: PPUSH
16923: LD_EXP 3
16927: PUSH
16928: LD_STRING Donaldson
16930: STR
16931: PPUSH
16932: CALL_OW 38
// if Bobby then
16936: LD_EXP 24
16940: IFFALSE 16960
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16942: LD_EXP 24
16946: PPUSH
16947: LD_EXP 3
16951: PUSH
16952: LD_STRING Bobby
16954: STR
16955: PPUSH
16956: CALL_OW 38
// if Cyrus then
16960: LD_EXP 25
16964: IFFALSE 16984
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16966: LD_EXP 25
16970: PPUSH
16971: LD_EXP 3
16975: PUSH
16976: LD_STRING Cyrus
16978: STR
16979: PPUSH
16980: CALL_OW 38
// if Denis then
16984: LD_EXP 26
16988: IFFALSE 17008
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16990: LD_EXP 26
16994: PPUSH
16995: LD_EXP 3
16999: PUSH
17000: LD_STRING Denis
17002: STR
17003: PPUSH
17004: CALL_OW 38
// if Brown then
17008: LD_EXP 27
17012: IFFALSE 17032
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
17014: LD_EXP 27
17018: PPUSH
17019: LD_EXP 3
17023: PUSH
17024: LD_STRING Brown
17026: STR
17027: PPUSH
17028: CALL_OW 38
// if Gladstone then
17032: LD_EXP 28
17036: IFFALSE 17056
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
17038: LD_EXP 28
17042: PPUSH
17043: LD_EXP 3
17047: PUSH
17048: LD_STRING Gladstone
17050: STR
17051: PPUSH
17052: CALL_OW 38
// if Houten then
17056: LD_EXP 29
17060: IFFALSE 17080
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
17062: LD_EXP 29
17066: PPUSH
17067: LD_EXP 3
17071: PUSH
17072: LD_STRING Houten
17074: STR
17075: PPUSH
17076: CALL_OW 38
// if Cornel then
17080: LD_EXP 31
17084: IFFALSE 17104
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
17086: LD_EXP 31
17090: PPUSH
17091: LD_EXP 3
17095: PUSH
17096: LD_STRING Cornell
17098: STR
17099: PPUSH
17100: CALL_OW 38
// if Gary then
17104: LD_EXP 32
17108: IFFALSE 17128
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
17110: LD_EXP 32
17114: PPUSH
17115: LD_EXP 3
17119: PUSH
17120: LD_STRING Gary
17122: STR
17123: PPUSH
17124: CALL_OW 38
// if Frank then
17128: LD_EXP 33
17132: IFFALSE 17152
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
17134: LD_EXP 33
17138: PPUSH
17139: LD_EXP 3
17143: PUSH
17144: LD_STRING Frank
17146: STR
17147: PPUSH
17148: CALL_OW 38
// if Kikuchi then
17152: LD_EXP 34
17156: IFFALSE 17176
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
17158: LD_EXP 34
17162: PPUSH
17163: LD_EXP 3
17167: PUSH
17168: LD_STRING Kikuchi
17170: STR
17171: PPUSH
17172: CALL_OW 38
// YouWin ;
17176: CALL_OW 103
// end ;
17180: LD_VAR 0 1
17184: RET
// export function CanSayRand ( side ) ; begin
17185: LD_INT 0
17187: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_nation , 1 ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
17188: LD_ADDR_VAR 0 2
17192: PUSH
17193: LD_INT 52
17195: PUSH
17196: EMPTY
17197: LIST
17198: PUSH
17199: LD_INT 22
17201: PUSH
17202: LD_VAR 0 1
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: LD_INT 23
17213: PUSH
17214: LD_INT 1
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: LIST
17225: PPUSH
17226: CALL_OW 69
17230: PUSH
17231: LD_EXP 21
17235: PUSH
17236: LD_EXP 33
17240: PUSH
17241: LD_EXP 22
17245: PUSH
17246: LD_EXP 23
17250: PUSH
17251: LD_EXP 24
17255: PUSH
17256: LD_EXP 25
17260: PUSH
17261: LD_EXP 26
17265: PUSH
17266: LD_EXP 27
17270: PUSH
17271: LD_EXP 28
17275: PUSH
17276: LD_EXP 29
17280: PUSH
17281: LD_EXP 30
17285: PUSH
17286: LD_EXP 31
17290: PUSH
17291: LD_EXP 32
17295: PUSH
17296: LD_EXP 34
17300: PUSH
17301: EMPTY
17302: LIST
17303: LIST
17304: LIST
17305: LIST
17306: LIST
17307: LIST
17308: LIST
17309: LIST
17310: LIST
17311: LIST
17312: LIST
17313: LIST
17314: LIST
17315: LIST
17316: DIFF
17317: ST_TO_ADDR
// end ;
17318: LD_VAR 0 2
17322: RET
// export function SayRand ( sex , dial ) ; begin
17323: LD_INT 0
17325: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_nation , 1 ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
17326: LD_ADDR_VAR 0 3
17330: PUSH
17331: LD_INT 52
17333: PUSH
17334: EMPTY
17335: LIST
17336: PUSH
17337: LD_INT 22
17339: PUSH
17340: LD_INT 1
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: PUSH
17347: LD_INT 26
17349: PUSH
17350: LD_VAR 0 1
17354: PUSH
17355: EMPTY
17356: LIST
17357: LIST
17358: PUSH
17359: LD_INT 23
17361: PUSH
17362: LD_INT 1
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: PUSH
17369: EMPTY
17370: LIST
17371: LIST
17372: LIST
17373: LIST
17374: PPUSH
17375: CALL_OW 69
17379: PUSH
17380: LD_EXP 21
17384: PUSH
17385: LD_EXP 33
17389: PUSH
17390: LD_EXP 22
17394: PUSH
17395: LD_EXP 23
17399: PUSH
17400: LD_EXP 24
17404: PUSH
17405: LD_EXP 25
17409: PUSH
17410: LD_EXP 26
17414: PUSH
17415: LD_EXP 27
17419: PUSH
17420: LD_EXP 28
17424: PUSH
17425: LD_EXP 29
17429: PUSH
17430: LD_EXP 30
17434: PUSH
17435: LD_EXP 31
17439: PUSH
17440: LD_EXP 32
17444: PUSH
17445: LD_EXP 34
17449: PUSH
17450: EMPTY
17451: LIST
17452: LIST
17453: LIST
17454: LIST
17455: LIST
17456: LIST
17457: LIST
17458: LIST
17459: LIST
17460: LIST
17461: LIST
17462: LIST
17463: LIST
17464: LIST
17465: DIFF
17466: ST_TO_ADDR
// if not result then
17467: LD_VAR 0 3
17471: NOT
17472: IFFALSE 17476
// exit ;
17474: GO 17504
// result := result [ 1 ] ;
17476: LD_ADDR_VAR 0 3
17480: PUSH
17481: LD_VAR 0 3
17485: PUSH
17486: LD_INT 1
17488: ARRAY
17489: ST_TO_ADDR
// Say ( result , dial ) ;
17490: LD_VAR 0 3
17494: PPUSH
17495: LD_VAR 0 2
17499: PPUSH
17500: CALL_OW 88
// end ;
17504: LD_VAR 0 3
17508: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17509: LD_INT 0
17511: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_nation , 1 ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17512: LD_ADDR_VAR 0 4
17516: PUSH
17517: LD_INT 22
17519: PUSH
17520: LD_INT 1
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: PUSH
17527: LD_INT 26
17529: PUSH
17530: LD_VAR 0 1
17534: PUSH
17535: EMPTY
17536: LIST
17537: LIST
17538: PUSH
17539: LD_INT 23
17541: PUSH
17542: LD_INT 1
17544: PUSH
17545: EMPTY
17546: LIST
17547: LIST
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: LIST
17553: PPUSH
17554: CALL_OW 69
17558: PUSH
17559: LD_EXP 21
17563: PUSH
17564: LD_EXP 33
17568: PUSH
17569: LD_EXP 22
17573: PUSH
17574: LD_EXP 23
17578: PUSH
17579: LD_EXP 24
17583: PUSH
17584: LD_EXP 25
17588: PUSH
17589: LD_EXP 26
17593: PUSH
17594: LD_EXP 27
17598: PUSH
17599: LD_EXP 28
17603: PUSH
17604: LD_EXP 29
17608: PUSH
17609: LD_EXP 30
17613: PUSH
17614: LD_EXP 31
17618: PUSH
17619: LD_EXP 32
17623: PUSH
17624: LD_EXP 34
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: LIST
17633: LIST
17634: LIST
17635: LIST
17636: LIST
17637: LIST
17638: LIST
17639: LIST
17640: LIST
17641: LIST
17642: LIST
17643: LIST
17644: PUSH
17645: LD_VAR 0 3
17649: ADD
17650: DIFF
17651: ST_TO_ADDR
// if not result then
17652: LD_VAR 0 4
17656: NOT
17657: IFFALSE 17661
// exit ;
17659: GO 17689
// result := result [ 1 ] ;
17661: LD_ADDR_VAR 0 4
17665: PUSH
17666: LD_VAR 0 4
17670: PUSH
17671: LD_INT 1
17673: ARRAY
17674: ST_TO_ADDR
// Say ( result , dial ) ;
17675: LD_VAR 0 4
17679: PPUSH
17680: LD_VAR 0 2
17684: PPUSH
17685: CALL_OW 88
// end ; end_of_file
17689: LD_VAR 0 4
17693: RET
// export function CustomEvent ( event ) ; begin
17694: LD_INT 0
17696: PPUSH
// end ;
17697: LD_VAR 0 2
17701: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17702: LD_VAR 0 1
17706: PPUSH
17707: CALL_OW 255
17711: PUSH
17712: LD_INT 1
17714: EQUAL
17715: IFFALSE 17725
// artifact_get := true ;
17717: LD_ADDR_EXP 13
17721: PUSH
17722: LD_INT 1
17724: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17725: LD_VAR 0 1
17729: PPUSH
17730: CALL_OW 255
17734: PUSH
17735: LD_INT 2
17737: EQUAL
17738: IFFALSE 17756
// begin artifact_get := false ;
17740: LD_ADDR_EXP 13
17744: PUSH
17745: LD_INT 0
17747: ST_TO_ADDR
// artifact_stolen := true ;
17748: LD_ADDR_EXP 12
17752: PUSH
17753: LD_INT 1
17755: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17756: LD_ADDR_EXP 14
17760: PUSH
17761: LD_INT 1
17763: ST_TO_ADDR
// end ;
17764: PPOPN 2
17766: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17767: LD_ADDR_EXP 14
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ;
17775: PPOPN 2
17777: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17778: LD_VAR 0 1
17782: PPUSH
17783: CALL 109388 0 1
// if un = JMM then
17787: LD_VAR 0 1
17791: PUSH
17792: LD_EXP 21
17796: EQUAL
17797: IFFALSE 17808
// begin YouLost ( JMM ) ;
17799: LD_STRING JMM
17801: PPUSH
17802: CALL_OW 104
// exit ;
17806: GO 17940
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17808: LD_VAR 0 1
17812: PUSH
17813: LD_INT 22
17815: PUSH
17816: LD_INT 1
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: LD_INT 21
17825: PUSH
17826: LD_INT 1
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: PUSH
17833: LD_INT 2
17835: PUSH
17836: LD_INT 25
17838: PUSH
17839: LD_INT 1
17841: PUSH
17842: EMPTY
17843: LIST
17844: LIST
17845: PUSH
17846: LD_INT 25
17848: PUSH
17849: LD_INT 2
17851: PUSH
17852: EMPTY
17853: LIST
17854: LIST
17855: PUSH
17856: LD_INT 25
17858: PUSH
17859: LD_INT 3
17861: PUSH
17862: EMPTY
17863: LIST
17864: LIST
17865: PUSH
17866: LD_INT 25
17868: PUSH
17869: LD_INT 4
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: PUSH
17876: LD_INT 25
17878: PUSH
17879: LD_INT 5
17881: PUSH
17882: EMPTY
17883: LIST
17884: LIST
17885: PUSH
17886: LD_INT 25
17888: PUSH
17889: LD_INT 8
17891: PUSH
17892: EMPTY
17893: LIST
17894: LIST
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: LIST
17904: PUSH
17905: EMPTY
17906: LIST
17907: LIST
17908: LIST
17909: PPUSH
17910: CALL_OW 69
17914: IN
17915: IFFALSE 17931
// loses_counter := loses_counter + 1 ;
17917: LD_ADDR_EXP 17
17921: PUSH
17922: LD_EXP 17
17926: PUSH
17927: LD_INT 1
17929: PLUS
17930: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL 46737 0 1
// end ;
17940: PPOPN 1
17942: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17943: LD_VAR 0 1
17947: PPUSH
17948: LD_VAR 0 2
17952: PPUSH
17953: CALL 49091 0 2
// end ;
17957: PPOPN 2
17959: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17960: LD_VAR 0 1
17964: PPUSH
17965: CALL 48398 0 1
// end ;
17969: PPOPN 1
17971: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17972: LD_VAR 0 1
17976: PPUSH
17977: LD_VAR 0 2
17981: PPUSH
17982: LD_VAR 0 3
17986: PPUSH
17987: LD_VAR 0 4
17991: PPUSH
17992: LD_VAR 0 5
17996: PPUSH
17997: CALL 46043 0 5
// end ;
18001: PPOPN 5
18003: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
18004: LD_VAR 0 1
18008: PPUSH
18009: LD_VAR 0 2
18013: PPUSH
18014: CALL 109446 0 2
// if GetNation ( vehicle ) = nation_american then
18018: LD_VAR 0 1
18022: PPUSH
18023: CALL_OW 248
18027: PUSH
18028: LD_INT 1
18030: EQUAL
18031: IFFALSE 18041
// am_veh_consturcted := true ;
18033: LD_ADDR_EXP 20
18037: PUSH
18038: LD_INT 1
18040: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
18041: LD_VAR 0 1
18045: PPUSH
18046: LD_VAR 0 2
18050: PPUSH
18051: CALL 45592 0 2
// end ;
18055: PPOPN 2
18057: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
18058: LD_VAR 0 1
18062: PPUSH
18063: CALL_OW 247
18067: PUSH
18068: LD_INT 2
18070: EQUAL
18071: IFFALSE 18075
// exit ;
18073: GO 18092
// if not kamikazed then
18075: LD_EXP 11
18079: NOT
18080: IFFALSE 18092
// kamikazed := unit ;
18082: LD_ADDR_EXP 11
18086: PUSH
18087: LD_VAR 0 1
18091: ST_TO_ADDR
// end ;
18092: PPOPN 1
18094: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
18095: LD_INT 0
18097: PPUSH
18098: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
18099: LD_VAR 0 1
18103: PPUSH
18104: LD_VAR 0 2
18108: PPUSH
18109: LD_VAR 0 3
18113: PPUSH
18114: LD_VAR 0 4
18118: PPUSH
18119: CALL 45424 0 4
// end ;
18123: PPOPN 6
18125: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
18126: LD_INT 0
18128: PPUSH
// begin if building = ar_dep_n then
18129: LD_VAR 0 1
18133: PUSH
18134: LD_INT 94
18136: EQUAL
18137: IFFALSE 18189
// begin for i := 1 to 3 do
18139: LD_ADDR_VAR 0 4
18143: PUSH
18144: DOUBLE
18145: LD_INT 1
18147: DEC
18148: ST_TO_ADDR
18149: LD_INT 3
18151: PUSH
18152: FOR_TO
18153: IFFALSE 18187
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
18155: LD_INT 115
18157: PUSH
18158: LD_VAR 0 4
18162: PUSH
18163: LD_INT 2
18165: MUL
18166: PLUS
18167: PPUSH
18168: LD_INT 6
18170: PPUSH
18171: LD_INT 1
18173: PPUSH
18174: CALL_OW 453
// wait ( 0 0$0.3 ) ;
18178: LD_INT 10
18180: PPUSH
18181: CALL_OW 67
// end ;
18185: GO 18152
18187: POP
18188: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
18189: LD_VAR 0 1
18193: PPUSH
18194: LD_VAR 0 2
18198: PPUSH
18199: LD_VAR 0 3
18203: PPUSH
18204: CALL 45197 0 3
// end ;
18208: PPOPN 4
18210: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
18211: LD_VAR 0 1
18215: PPUSH
18216: LD_VAR 0 2
18220: PPUSH
18221: CALL 46425 0 2
// end ;
18225: PPOPN 2
18227: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
18228: LD_VAR 0 1
18232: PPUSH
18233: LD_VAR 0 2
18237: PPUSH
18238: CALL 44887 0 2
// end ;
18242: PPOPN 2
18244: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
18245: LD_VAR 0 1
18249: PPUSH
18250: LD_VAR 0 2
18254: PPUSH
18255: CALL 45080 0 2
// end ;
18259: PPOPN 2
18261: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
18262: LD_VAR 0 1
18266: PPUSH
18267: CALL 48155 0 1
// end ;
18271: PPOPN 1
18273: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
18274: LD_VAR 0 1
18278: PPUSH
18279: LD_VAR 0 2
18283: PPUSH
18284: CALL 49388 0 2
// end ;
18288: PPOPN 2
18290: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
18291: LD_VAR 0 1
18295: PPUSH
18296: LD_VAR 0 2
18300: PPUSH
18301: LD_VAR 0 3
18305: PPUSH
18306: LD_VAR 0 4
18310: PPUSH
18311: CALL 49612 0 4
// end ;
18315: PPOPN 4
18317: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18318: LD_VAR 0 1
18322: PPUSH
18323: CALL 109430 0 1
// end ;
18327: PPOPN 1
18329: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18330: LD_INT 22
18332: PUSH
18333: LD_INT 2
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: PUSH
18340: LD_INT 50
18342: PUSH
18343: EMPTY
18344: LIST
18345: PUSH
18346: LD_INT 21
18348: PUSH
18349: LD_INT 1
18351: PUSH
18352: EMPTY
18353: LIST
18354: LIST
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: LIST
18360: PPUSH
18361: CALL_OW 69
18365: IFFALSE 18449
18367: GO 18369
18369: DISABLE
18370: LD_INT 0
18372: PPUSH
// begin enable ;
18373: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18374: LD_ADDR_VAR 0 1
18378: PUSH
18379: LD_INT 22
18381: PUSH
18382: LD_INT 2
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: PUSH
18389: LD_INT 50
18391: PUSH
18392: EMPTY
18393: LIST
18394: PUSH
18395: LD_INT 21
18397: PUSH
18398: LD_INT 1
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: PUSH
18405: EMPTY
18406: LIST
18407: LIST
18408: LIST
18409: PPUSH
18410: CALL_OW 69
18414: PUSH
18415: FOR_IN
18416: IFFALSE 18447
// if GetFuel ( i ) < 3 then
18418: LD_VAR 0 1
18422: PPUSH
18423: CALL_OW 261
18427: PUSH
18428: LD_INT 3
18430: LESS
18431: IFFALSE 18445
// SetFuel ( i , 5 ) ;
18433: LD_VAR 0 1
18437: PPUSH
18438: LD_INT 5
18440: PPUSH
18441: CALL_OW 240
18445: GO 18415
18447: POP
18448: POP
// end ; end_of_file
18449: PPOPN 1
18451: END
// every 0 0$1 trigger game do
18452: LD_EXP 2
18456: IFFALSE 18486
18458: GO 18460
18460: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18461: LD_INT 7
18463: PUSH
18464: LD_INT 6
18466: PUSH
18467: LD_INT 4
18469: PUSH
18470: LD_INT 6
18472: PUSH
18473: EMPTY
18474: LIST
18475: LIST
18476: LIST
18477: LIST
18478: PPUSH
18479: LD_INT 1750
18481: PPUSH
18482: CALL 18487 0 2
18486: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18487: LD_INT 0
18489: PPUSH
18490: PPUSH
18491: PPUSH
// if not areas then
18492: LD_VAR 0 1
18496: NOT
18497: IFFALSE 18501
// exit ;
18499: GO 18631
// repeat wait ( time ) ;
18501: LD_VAR 0 2
18505: PPUSH
18506: CALL_OW 67
// for i in areas do
18510: LD_ADDR_VAR 0 4
18514: PUSH
18515: LD_VAR 0 1
18519: PUSH
18520: FOR_IN
18521: IFFALSE 18590
// begin p := rand ( 1 , 90 ) ;
18523: LD_ADDR_VAR 0 5
18527: PUSH
18528: LD_INT 1
18530: PPUSH
18531: LD_INT 90
18533: PPUSH
18534: CALL_OW 12
18538: ST_TO_ADDR
// if Prob ( p ) then
18539: LD_VAR 0 5
18543: PPUSH
18544: CALL_OW 13
18548: IFFALSE 18588
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18550: LD_INT 2
18552: PPUSH
18553: LD_INT 5
18555: PPUSH
18556: CALL_OW 12
18560: PPUSH
18561: LD_VAR 0 4
18565: PPUSH
18566: LD_INT 1
18568: PPUSH
18569: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
18573: LD_INT 385
18575: PPUSH
18576: LD_INT 945
18578: PPUSH
18579: CALL_OW 12
18583: PPUSH
18584: CALL_OW 67
// end ; end ;
18588: GO 18520
18590: POP
18591: POP
// time := time + 0 0$3 ;
18592: LD_ADDR_VAR 0 2
18596: PUSH
18597: LD_VAR 0 2
18601: PUSH
18602: LD_INT 105
18604: PLUS
18605: ST_TO_ADDR
// if time > 2 2$30 then
18606: LD_VAR 0 2
18610: PUSH
18611: LD_INT 5250
18613: GREATER
18614: IFFALSE 18624
// time := 0 0$40 ;
18616: LD_ADDR_VAR 0 2
18620: PUSH
18621: LD_INT 1400
18623: ST_TO_ADDR
// until not game ;
18624: LD_EXP 2
18628: NOT
18629: IFFALSE 18501
// end ;
18631: LD_VAR 0 3
18635: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18636: LD_OWVAR 1
18640: PUSH
18641: LD_INT 84000
18643: PUSH
18644: LD_INT 73500
18646: PUSH
18647: LD_INT 63000
18649: PUSH
18650: LD_INT 52500
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: LIST
18657: LIST
18658: PUSH
18659: LD_OWVAR 67
18663: ARRAY
18664: LESS
18665: IFFALSE 18692
18667: GO 18669
18669: DISABLE
// begin enable ;
18670: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18671: LD_INT 1
18673: PPUSH
18674: LD_INT 5
18676: PPUSH
18677: CALL_OW 12
18681: PPUSH
18682: LD_INT 7
18684: PPUSH
18685: LD_INT 1
18687: PPUSH
18688: CALL_OW 55
// end ; end_of_file
18692: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18693: LD_INT 0
18695: PPUSH
18696: PPUSH
// skirmish := false ;
18697: LD_ADDR_EXP 48
18701: PUSH
18702: LD_INT 0
18704: ST_TO_ADDR
// debug_mc := false ;
18705: LD_ADDR_EXP 49
18709: PUSH
18710: LD_INT 0
18712: ST_TO_ADDR
// mc_bases := [ ] ;
18713: LD_ADDR_EXP 50
18717: PUSH
18718: EMPTY
18719: ST_TO_ADDR
// mc_sides := [ ] ;
18720: LD_ADDR_EXP 76
18724: PUSH
18725: EMPTY
18726: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18727: LD_ADDR_EXP 51
18731: PUSH
18732: EMPTY
18733: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18734: LD_ADDR_EXP 52
18738: PUSH
18739: EMPTY
18740: ST_TO_ADDR
// mc_need_heal := [ ] ;
18741: LD_ADDR_EXP 53
18745: PUSH
18746: EMPTY
18747: ST_TO_ADDR
// mc_healers := [ ] ;
18748: LD_ADDR_EXP 54
18752: PUSH
18753: EMPTY
18754: ST_TO_ADDR
// mc_build_list := [ ] ;
18755: LD_ADDR_EXP 55
18759: PUSH
18760: EMPTY
18761: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18762: LD_ADDR_EXP 82
18766: PUSH
18767: EMPTY
18768: ST_TO_ADDR
// mc_builders := [ ] ;
18769: LD_ADDR_EXP 56
18773: PUSH
18774: EMPTY
18775: ST_TO_ADDR
// mc_construct_list := [ ] ;
18776: LD_ADDR_EXP 57
18780: PUSH
18781: EMPTY
18782: ST_TO_ADDR
// mc_turret_list := [ ] ;
18783: LD_ADDR_EXP 58
18787: PUSH
18788: EMPTY
18789: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18790: LD_ADDR_EXP 59
18794: PUSH
18795: EMPTY
18796: ST_TO_ADDR
// mc_miners := [ ] ;
18797: LD_ADDR_EXP 64
18801: PUSH
18802: EMPTY
18803: ST_TO_ADDR
// mc_mines := [ ] ;
18804: LD_ADDR_EXP 63
18808: PUSH
18809: EMPTY
18810: ST_TO_ADDR
// mc_minefields := [ ] ;
18811: LD_ADDR_EXP 65
18815: PUSH
18816: EMPTY
18817: ST_TO_ADDR
// mc_crates := [ ] ;
18818: LD_ADDR_EXP 66
18822: PUSH
18823: EMPTY
18824: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18825: LD_ADDR_EXP 67
18829: PUSH
18830: EMPTY
18831: ST_TO_ADDR
// mc_crates_area := [ ] ;
18832: LD_ADDR_EXP 68
18836: PUSH
18837: EMPTY
18838: ST_TO_ADDR
// mc_vehicles := [ ] ;
18839: LD_ADDR_EXP 69
18843: PUSH
18844: EMPTY
18845: ST_TO_ADDR
// mc_attack := [ ] ;
18846: LD_ADDR_EXP 70
18850: PUSH
18851: EMPTY
18852: ST_TO_ADDR
// mc_produce := [ ] ;
18853: LD_ADDR_EXP 71
18857: PUSH
18858: EMPTY
18859: ST_TO_ADDR
// mc_defender := [ ] ;
18860: LD_ADDR_EXP 72
18864: PUSH
18865: EMPTY
18866: ST_TO_ADDR
// mc_parking := [ ] ;
18867: LD_ADDR_EXP 74
18871: PUSH
18872: EMPTY
18873: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18874: LD_ADDR_EXP 60
18878: PUSH
18879: EMPTY
18880: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18881: LD_ADDR_EXP 62
18885: PUSH
18886: EMPTY
18887: ST_TO_ADDR
// mc_scan := [ ] ;
18888: LD_ADDR_EXP 73
18892: PUSH
18893: EMPTY
18894: ST_TO_ADDR
// mc_scan_area := [ ] ;
18895: LD_ADDR_EXP 75
18899: PUSH
18900: EMPTY
18901: ST_TO_ADDR
// mc_tech := [ ] ;
18902: LD_ADDR_EXP 77
18906: PUSH
18907: EMPTY
18908: ST_TO_ADDR
// mc_class := [ ] ;
18909: LD_ADDR_EXP 91
18913: PUSH
18914: EMPTY
18915: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18916: LD_ADDR_EXP 92
18920: PUSH
18921: EMPTY
18922: ST_TO_ADDR
// mc_is_defending := [ ] ;
18923: LD_ADDR_EXP 93
18927: PUSH
18928: EMPTY
18929: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18930: LD_ADDR_EXP 84
18934: PUSH
18935: EMPTY
18936: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18937: LD_ADDR_EXP 94
18941: PUSH
18942: LD_INT 0
18944: ST_TO_ADDR
// end ;
18945: LD_VAR 0 1
18949: RET
// export function MC_Kill ( base ) ; begin
18950: LD_INT 0
18952: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18953: LD_ADDR_EXP 50
18957: PUSH
18958: LD_EXP 50
18962: PPUSH
18963: LD_VAR 0 1
18967: PPUSH
18968: EMPTY
18969: PPUSH
18970: CALL_OW 1
18974: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18975: LD_ADDR_EXP 51
18979: PUSH
18980: LD_EXP 51
18984: PPUSH
18985: LD_VAR 0 1
18989: PPUSH
18990: EMPTY
18991: PPUSH
18992: CALL_OW 1
18996: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18997: LD_ADDR_EXP 52
19001: PUSH
19002: LD_EXP 52
19006: PPUSH
19007: LD_VAR 0 1
19011: PPUSH
19012: EMPTY
19013: PPUSH
19014: CALL_OW 1
19018: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19019: LD_ADDR_EXP 53
19023: PUSH
19024: LD_EXP 53
19028: PPUSH
19029: LD_VAR 0 1
19033: PPUSH
19034: EMPTY
19035: PPUSH
19036: CALL_OW 1
19040: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19041: LD_ADDR_EXP 54
19045: PUSH
19046: LD_EXP 54
19050: PPUSH
19051: LD_VAR 0 1
19055: PPUSH
19056: EMPTY
19057: PPUSH
19058: CALL_OW 1
19062: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19063: LD_ADDR_EXP 55
19067: PUSH
19068: LD_EXP 55
19072: PPUSH
19073: LD_VAR 0 1
19077: PPUSH
19078: EMPTY
19079: PPUSH
19080: CALL_OW 1
19084: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19085: LD_ADDR_EXP 56
19089: PUSH
19090: LD_EXP 56
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: EMPTY
19101: PPUSH
19102: CALL_OW 1
19106: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19107: LD_ADDR_EXP 57
19111: PUSH
19112: LD_EXP 57
19116: PPUSH
19117: LD_VAR 0 1
19121: PPUSH
19122: EMPTY
19123: PPUSH
19124: CALL_OW 1
19128: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19129: LD_ADDR_EXP 58
19133: PUSH
19134: LD_EXP 58
19138: PPUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: EMPTY
19145: PPUSH
19146: CALL_OW 1
19150: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19151: LD_ADDR_EXP 59
19155: PUSH
19156: LD_EXP 59
19160: PPUSH
19161: LD_VAR 0 1
19165: PPUSH
19166: EMPTY
19167: PPUSH
19168: CALL_OW 1
19172: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19173: LD_ADDR_EXP 60
19177: PUSH
19178: LD_EXP 60
19182: PPUSH
19183: LD_VAR 0 1
19187: PPUSH
19188: EMPTY
19189: PPUSH
19190: CALL_OW 1
19194: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19195: LD_ADDR_EXP 61
19199: PUSH
19200: LD_EXP 61
19204: PPUSH
19205: LD_VAR 0 1
19209: PPUSH
19210: LD_INT 0
19212: PPUSH
19213: CALL_OW 1
19217: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19218: LD_ADDR_EXP 62
19222: PUSH
19223: LD_EXP 62
19227: PPUSH
19228: LD_VAR 0 1
19232: PPUSH
19233: EMPTY
19234: PPUSH
19235: CALL_OW 1
19239: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19240: LD_ADDR_EXP 63
19244: PUSH
19245: LD_EXP 63
19249: PPUSH
19250: LD_VAR 0 1
19254: PPUSH
19255: EMPTY
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19262: LD_ADDR_EXP 64
19266: PUSH
19267: LD_EXP 64
19271: PPUSH
19272: LD_VAR 0 1
19276: PPUSH
19277: EMPTY
19278: PPUSH
19279: CALL_OW 1
19283: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19284: LD_ADDR_EXP 65
19288: PUSH
19289: LD_EXP 65
19293: PPUSH
19294: LD_VAR 0 1
19298: PPUSH
19299: EMPTY
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19306: LD_ADDR_EXP 66
19310: PUSH
19311: LD_EXP 66
19315: PPUSH
19316: LD_VAR 0 1
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19328: LD_ADDR_EXP 67
19332: PUSH
19333: LD_EXP 67
19337: PPUSH
19338: LD_VAR 0 1
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19350: LD_ADDR_EXP 68
19354: PUSH
19355: LD_EXP 68
19359: PPUSH
19360: LD_VAR 0 1
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19372: LD_ADDR_EXP 69
19376: PUSH
19377: LD_EXP 69
19381: PPUSH
19382: LD_VAR 0 1
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19394: LD_ADDR_EXP 70
19398: PUSH
19399: LD_EXP 70
19403: PPUSH
19404: LD_VAR 0 1
19408: PPUSH
19409: EMPTY
19410: PPUSH
19411: CALL_OW 1
19415: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19416: LD_ADDR_EXP 71
19420: PUSH
19421: LD_EXP 71
19425: PPUSH
19426: LD_VAR 0 1
19430: PPUSH
19431: EMPTY
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19438: LD_ADDR_EXP 72
19442: PUSH
19443: LD_EXP 72
19447: PPUSH
19448: LD_VAR 0 1
19452: PPUSH
19453: EMPTY
19454: PPUSH
19455: CALL_OW 1
19459: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19460: LD_ADDR_EXP 73
19464: PUSH
19465: LD_EXP 73
19469: PPUSH
19470: LD_VAR 0 1
19474: PPUSH
19475: EMPTY
19476: PPUSH
19477: CALL_OW 1
19481: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19482: LD_ADDR_EXP 74
19486: PUSH
19487: LD_EXP 74
19491: PPUSH
19492: LD_VAR 0 1
19496: PPUSH
19497: EMPTY
19498: PPUSH
19499: CALL_OW 1
19503: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19504: LD_ADDR_EXP 75
19508: PUSH
19509: LD_EXP 75
19513: PPUSH
19514: LD_VAR 0 1
19518: PPUSH
19519: EMPTY
19520: PPUSH
19521: CALL_OW 1
19525: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19526: LD_ADDR_EXP 77
19530: PUSH
19531: LD_EXP 77
19535: PPUSH
19536: LD_VAR 0 1
19540: PPUSH
19541: EMPTY
19542: PPUSH
19543: CALL_OW 1
19547: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19548: LD_ADDR_EXP 79
19552: PUSH
19553: LD_EXP 79
19557: PPUSH
19558: LD_VAR 0 1
19562: PPUSH
19563: EMPTY
19564: PPUSH
19565: CALL_OW 1
19569: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19570: LD_ADDR_EXP 80
19574: PUSH
19575: LD_EXP 80
19579: PPUSH
19580: LD_VAR 0 1
19584: PPUSH
19585: EMPTY
19586: PPUSH
19587: CALL_OW 1
19591: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19592: LD_ADDR_EXP 81
19596: PUSH
19597: LD_EXP 81
19601: PPUSH
19602: LD_VAR 0 1
19606: PPUSH
19607: EMPTY
19608: PPUSH
19609: CALL_OW 1
19613: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19614: LD_ADDR_EXP 82
19618: PUSH
19619: LD_EXP 82
19623: PPUSH
19624: LD_VAR 0 1
19628: PPUSH
19629: EMPTY
19630: PPUSH
19631: CALL_OW 1
19635: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19636: LD_ADDR_EXP 83
19640: PUSH
19641: LD_EXP 83
19645: PPUSH
19646: LD_VAR 0 1
19650: PPUSH
19651: EMPTY
19652: PPUSH
19653: CALL_OW 1
19657: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19658: LD_ADDR_EXP 84
19662: PUSH
19663: LD_EXP 84
19667: PPUSH
19668: LD_VAR 0 1
19672: PPUSH
19673: EMPTY
19674: PPUSH
19675: CALL_OW 1
19679: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19680: LD_ADDR_EXP 85
19684: PUSH
19685: LD_EXP 85
19689: PPUSH
19690: LD_VAR 0 1
19694: PPUSH
19695: EMPTY
19696: PPUSH
19697: CALL_OW 1
19701: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19702: LD_ADDR_EXP 86
19706: PUSH
19707: LD_EXP 86
19711: PPUSH
19712: LD_VAR 0 1
19716: PPUSH
19717: EMPTY
19718: PPUSH
19719: CALL_OW 1
19723: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19724: LD_ADDR_EXP 87
19728: PUSH
19729: LD_EXP 87
19733: PPUSH
19734: LD_VAR 0 1
19738: PPUSH
19739: EMPTY
19740: PPUSH
19741: CALL_OW 1
19745: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19746: LD_ADDR_EXP 88
19750: PUSH
19751: LD_EXP 88
19755: PPUSH
19756: LD_VAR 0 1
19760: PPUSH
19761: EMPTY
19762: PPUSH
19763: CALL_OW 1
19767: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19768: LD_ADDR_EXP 89
19772: PUSH
19773: LD_EXP 89
19777: PPUSH
19778: LD_VAR 0 1
19782: PPUSH
19783: EMPTY
19784: PPUSH
19785: CALL_OW 1
19789: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19790: LD_ADDR_EXP 90
19794: PUSH
19795: LD_EXP 90
19799: PPUSH
19800: LD_VAR 0 1
19804: PPUSH
19805: EMPTY
19806: PPUSH
19807: CALL_OW 1
19811: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19812: LD_ADDR_EXP 91
19816: PUSH
19817: LD_EXP 91
19821: PPUSH
19822: LD_VAR 0 1
19826: PPUSH
19827: EMPTY
19828: PPUSH
19829: CALL_OW 1
19833: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19834: LD_ADDR_EXP 92
19838: PUSH
19839: LD_EXP 92
19843: PPUSH
19844: LD_VAR 0 1
19848: PPUSH
19849: LD_INT 0
19851: PPUSH
19852: CALL_OW 1
19856: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19857: LD_ADDR_EXP 93
19861: PUSH
19862: LD_EXP 93
19866: PPUSH
19867: LD_VAR 0 1
19871: PPUSH
19872: LD_INT 0
19874: PPUSH
19875: CALL_OW 1
19879: ST_TO_ADDR
// end ;
19880: LD_VAR 0 2
19884: RET
// export function MC_Add ( side , units ) ; var base ; begin
19885: LD_INT 0
19887: PPUSH
19888: PPUSH
// base := mc_bases + 1 ;
19889: LD_ADDR_VAR 0 4
19893: PUSH
19894: LD_EXP 50
19898: PUSH
19899: LD_INT 1
19901: PLUS
19902: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19903: LD_ADDR_EXP 76
19907: PUSH
19908: LD_EXP 76
19912: PPUSH
19913: LD_VAR 0 4
19917: PPUSH
19918: LD_VAR 0 1
19922: PPUSH
19923: CALL_OW 1
19927: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19928: LD_ADDR_EXP 50
19932: PUSH
19933: LD_EXP 50
19937: PPUSH
19938: LD_VAR 0 4
19942: PPUSH
19943: LD_VAR 0 2
19947: PPUSH
19948: CALL_OW 1
19952: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19953: LD_ADDR_EXP 51
19957: PUSH
19958: LD_EXP 51
19962: PPUSH
19963: LD_VAR 0 4
19967: PPUSH
19968: EMPTY
19969: PPUSH
19970: CALL_OW 1
19974: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19975: LD_ADDR_EXP 52
19979: PUSH
19980: LD_EXP 52
19984: PPUSH
19985: LD_VAR 0 4
19989: PPUSH
19990: EMPTY
19991: PPUSH
19992: CALL_OW 1
19996: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19997: LD_ADDR_EXP 53
20001: PUSH
20002: LD_EXP 53
20006: PPUSH
20007: LD_VAR 0 4
20011: PPUSH
20012: EMPTY
20013: PPUSH
20014: CALL_OW 1
20018: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20019: LD_ADDR_EXP 54
20023: PUSH
20024: LD_EXP 54
20028: PPUSH
20029: LD_VAR 0 4
20033: PPUSH
20034: EMPTY
20035: PPUSH
20036: CALL_OW 1
20040: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20041: LD_ADDR_EXP 55
20045: PUSH
20046: LD_EXP 55
20050: PPUSH
20051: LD_VAR 0 4
20055: PPUSH
20056: EMPTY
20057: PPUSH
20058: CALL_OW 1
20062: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20063: LD_ADDR_EXP 56
20067: PUSH
20068: LD_EXP 56
20072: PPUSH
20073: LD_VAR 0 4
20077: PPUSH
20078: EMPTY
20079: PPUSH
20080: CALL_OW 1
20084: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20085: LD_ADDR_EXP 57
20089: PUSH
20090: LD_EXP 57
20094: PPUSH
20095: LD_VAR 0 4
20099: PPUSH
20100: EMPTY
20101: PPUSH
20102: CALL_OW 1
20106: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20107: LD_ADDR_EXP 58
20111: PUSH
20112: LD_EXP 58
20116: PPUSH
20117: LD_VAR 0 4
20121: PPUSH
20122: EMPTY
20123: PPUSH
20124: CALL_OW 1
20128: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20129: LD_ADDR_EXP 59
20133: PUSH
20134: LD_EXP 59
20138: PPUSH
20139: LD_VAR 0 4
20143: PPUSH
20144: EMPTY
20145: PPUSH
20146: CALL_OW 1
20150: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20151: LD_ADDR_EXP 60
20155: PUSH
20156: LD_EXP 60
20160: PPUSH
20161: LD_VAR 0 4
20165: PPUSH
20166: EMPTY
20167: PPUSH
20168: CALL_OW 1
20172: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20173: LD_ADDR_EXP 61
20177: PUSH
20178: LD_EXP 61
20182: PPUSH
20183: LD_VAR 0 4
20187: PPUSH
20188: LD_INT 0
20190: PPUSH
20191: CALL_OW 1
20195: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20196: LD_ADDR_EXP 62
20200: PUSH
20201: LD_EXP 62
20205: PPUSH
20206: LD_VAR 0 4
20210: PPUSH
20211: EMPTY
20212: PPUSH
20213: CALL_OW 1
20217: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20218: LD_ADDR_EXP 63
20222: PUSH
20223: LD_EXP 63
20227: PPUSH
20228: LD_VAR 0 4
20232: PPUSH
20233: EMPTY
20234: PPUSH
20235: CALL_OW 1
20239: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20240: LD_ADDR_EXP 64
20244: PUSH
20245: LD_EXP 64
20249: PPUSH
20250: LD_VAR 0 4
20254: PPUSH
20255: EMPTY
20256: PPUSH
20257: CALL_OW 1
20261: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20262: LD_ADDR_EXP 65
20266: PUSH
20267: LD_EXP 65
20271: PPUSH
20272: LD_VAR 0 4
20276: PPUSH
20277: EMPTY
20278: PPUSH
20279: CALL_OW 1
20283: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20284: LD_ADDR_EXP 66
20288: PUSH
20289: LD_EXP 66
20293: PPUSH
20294: LD_VAR 0 4
20298: PPUSH
20299: EMPTY
20300: PPUSH
20301: CALL_OW 1
20305: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20306: LD_ADDR_EXP 67
20310: PUSH
20311: LD_EXP 67
20315: PPUSH
20316: LD_VAR 0 4
20320: PPUSH
20321: EMPTY
20322: PPUSH
20323: CALL_OW 1
20327: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20328: LD_ADDR_EXP 68
20332: PUSH
20333: LD_EXP 68
20337: PPUSH
20338: LD_VAR 0 4
20342: PPUSH
20343: EMPTY
20344: PPUSH
20345: CALL_OW 1
20349: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20350: LD_ADDR_EXP 69
20354: PUSH
20355: LD_EXP 69
20359: PPUSH
20360: LD_VAR 0 4
20364: PPUSH
20365: EMPTY
20366: PPUSH
20367: CALL_OW 1
20371: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20372: LD_ADDR_EXP 70
20376: PUSH
20377: LD_EXP 70
20381: PPUSH
20382: LD_VAR 0 4
20386: PPUSH
20387: EMPTY
20388: PPUSH
20389: CALL_OW 1
20393: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20394: LD_ADDR_EXP 71
20398: PUSH
20399: LD_EXP 71
20403: PPUSH
20404: LD_VAR 0 4
20408: PPUSH
20409: EMPTY
20410: PPUSH
20411: CALL_OW 1
20415: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20416: LD_ADDR_EXP 72
20420: PUSH
20421: LD_EXP 72
20425: PPUSH
20426: LD_VAR 0 4
20430: PPUSH
20431: EMPTY
20432: PPUSH
20433: CALL_OW 1
20437: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20438: LD_ADDR_EXP 73
20442: PUSH
20443: LD_EXP 73
20447: PPUSH
20448: LD_VAR 0 4
20452: PPUSH
20453: EMPTY
20454: PPUSH
20455: CALL_OW 1
20459: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20460: LD_ADDR_EXP 74
20464: PUSH
20465: LD_EXP 74
20469: PPUSH
20470: LD_VAR 0 4
20474: PPUSH
20475: EMPTY
20476: PPUSH
20477: CALL_OW 1
20481: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20482: LD_ADDR_EXP 75
20486: PUSH
20487: LD_EXP 75
20491: PPUSH
20492: LD_VAR 0 4
20496: PPUSH
20497: EMPTY
20498: PPUSH
20499: CALL_OW 1
20503: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20504: LD_ADDR_EXP 77
20508: PUSH
20509: LD_EXP 77
20513: PPUSH
20514: LD_VAR 0 4
20518: PPUSH
20519: EMPTY
20520: PPUSH
20521: CALL_OW 1
20525: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20526: LD_ADDR_EXP 79
20530: PUSH
20531: LD_EXP 79
20535: PPUSH
20536: LD_VAR 0 4
20540: PPUSH
20541: EMPTY
20542: PPUSH
20543: CALL_OW 1
20547: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20548: LD_ADDR_EXP 80
20552: PUSH
20553: LD_EXP 80
20557: PPUSH
20558: LD_VAR 0 4
20562: PPUSH
20563: EMPTY
20564: PPUSH
20565: CALL_OW 1
20569: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20570: LD_ADDR_EXP 81
20574: PUSH
20575: LD_EXP 81
20579: PPUSH
20580: LD_VAR 0 4
20584: PPUSH
20585: EMPTY
20586: PPUSH
20587: CALL_OW 1
20591: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20592: LD_ADDR_EXP 82
20596: PUSH
20597: LD_EXP 82
20601: PPUSH
20602: LD_VAR 0 4
20606: PPUSH
20607: EMPTY
20608: PPUSH
20609: CALL_OW 1
20613: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20614: LD_ADDR_EXP 83
20618: PUSH
20619: LD_EXP 83
20623: PPUSH
20624: LD_VAR 0 4
20628: PPUSH
20629: EMPTY
20630: PPUSH
20631: CALL_OW 1
20635: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20636: LD_ADDR_EXP 84
20640: PUSH
20641: LD_EXP 84
20645: PPUSH
20646: LD_VAR 0 4
20650: PPUSH
20651: EMPTY
20652: PPUSH
20653: CALL_OW 1
20657: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20658: LD_ADDR_EXP 85
20662: PUSH
20663: LD_EXP 85
20667: PPUSH
20668: LD_VAR 0 4
20672: PPUSH
20673: EMPTY
20674: PPUSH
20675: CALL_OW 1
20679: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20680: LD_ADDR_EXP 86
20684: PUSH
20685: LD_EXP 86
20689: PPUSH
20690: LD_VAR 0 4
20694: PPUSH
20695: EMPTY
20696: PPUSH
20697: CALL_OW 1
20701: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20702: LD_ADDR_EXP 87
20706: PUSH
20707: LD_EXP 87
20711: PPUSH
20712: LD_VAR 0 4
20716: PPUSH
20717: EMPTY
20718: PPUSH
20719: CALL_OW 1
20723: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20724: LD_ADDR_EXP 88
20728: PUSH
20729: LD_EXP 88
20733: PPUSH
20734: LD_VAR 0 4
20738: PPUSH
20739: EMPTY
20740: PPUSH
20741: CALL_OW 1
20745: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20746: LD_ADDR_EXP 89
20750: PUSH
20751: LD_EXP 89
20755: PPUSH
20756: LD_VAR 0 4
20760: PPUSH
20761: EMPTY
20762: PPUSH
20763: CALL_OW 1
20767: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20768: LD_ADDR_EXP 90
20772: PUSH
20773: LD_EXP 90
20777: PPUSH
20778: LD_VAR 0 4
20782: PPUSH
20783: EMPTY
20784: PPUSH
20785: CALL_OW 1
20789: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20790: LD_ADDR_EXP 91
20794: PUSH
20795: LD_EXP 91
20799: PPUSH
20800: LD_VAR 0 4
20804: PPUSH
20805: EMPTY
20806: PPUSH
20807: CALL_OW 1
20811: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20812: LD_ADDR_EXP 92
20816: PUSH
20817: LD_EXP 92
20821: PPUSH
20822: LD_VAR 0 4
20826: PPUSH
20827: LD_INT 0
20829: PPUSH
20830: CALL_OW 1
20834: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20835: LD_ADDR_EXP 93
20839: PUSH
20840: LD_EXP 93
20844: PPUSH
20845: LD_VAR 0 4
20849: PPUSH
20850: LD_INT 0
20852: PPUSH
20853: CALL_OW 1
20857: ST_TO_ADDR
// result := base ;
20858: LD_ADDR_VAR 0 3
20862: PUSH
20863: LD_VAR 0 4
20867: ST_TO_ADDR
// end ;
20868: LD_VAR 0 3
20872: RET
// export function MC_Start ( ) ; var i ; begin
20873: LD_INT 0
20875: PPUSH
20876: PPUSH
// for i = 1 to mc_bases do
20877: LD_ADDR_VAR 0 2
20881: PUSH
20882: DOUBLE
20883: LD_INT 1
20885: DEC
20886: ST_TO_ADDR
20887: LD_EXP 50
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21993
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20895: LD_ADDR_EXP 50
20899: PUSH
20900: LD_EXP 50
20904: PPUSH
20905: LD_VAR 0 2
20909: PPUSH
20910: LD_EXP 50
20914: PUSH
20915: LD_VAR 0 2
20919: ARRAY
20920: PUSH
20921: LD_INT 0
20923: DIFF
20924: PPUSH
20925: CALL_OW 1
20929: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20930: LD_ADDR_EXP 51
20934: PUSH
20935: LD_EXP 51
20939: PPUSH
20940: LD_VAR 0 2
20944: PPUSH
20945: EMPTY
20946: PPUSH
20947: CALL_OW 1
20951: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20952: LD_ADDR_EXP 52
20956: PUSH
20957: LD_EXP 52
20961: PPUSH
20962: LD_VAR 0 2
20966: PPUSH
20967: EMPTY
20968: PPUSH
20969: CALL_OW 1
20973: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20974: LD_ADDR_EXP 53
20978: PUSH
20979: LD_EXP 53
20983: PPUSH
20984: LD_VAR 0 2
20988: PPUSH
20989: EMPTY
20990: PPUSH
20991: CALL_OW 1
20995: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20996: LD_ADDR_EXP 54
21000: PUSH
21001: LD_EXP 54
21005: PPUSH
21006: LD_VAR 0 2
21010: PPUSH
21011: EMPTY
21012: PUSH
21013: EMPTY
21014: PUSH
21015: EMPTY
21016: LIST
21017: LIST
21018: PPUSH
21019: CALL_OW 1
21023: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
21024: LD_ADDR_EXP 55
21028: PUSH
21029: LD_EXP 55
21033: PPUSH
21034: LD_VAR 0 2
21038: PPUSH
21039: EMPTY
21040: PPUSH
21041: CALL_OW 1
21045: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
21046: LD_ADDR_EXP 82
21050: PUSH
21051: LD_EXP 82
21055: PPUSH
21056: LD_VAR 0 2
21060: PPUSH
21061: EMPTY
21062: PPUSH
21063: CALL_OW 1
21067: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
21068: LD_ADDR_EXP 56
21072: PUSH
21073: LD_EXP 56
21077: PPUSH
21078: LD_VAR 0 2
21082: PPUSH
21083: EMPTY
21084: PPUSH
21085: CALL_OW 1
21089: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
21090: LD_ADDR_EXP 57
21094: PUSH
21095: LD_EXP 57
21099: PPUSH
21100: LD_VAR 0 2
21104: PPUSH
21105: EMPTY
21106: PPUSH
21107: CALL_OW 1
21111: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
21112: LD_ADDR_EXP 58
21116: PUSH
21117: LD_EXP 58
21121: PPUSH
21122: LD_VAR 0 2
21126: PPUSH
21127: LD_EXP 50
21131: PUSH
21132: LD_VAR 0 2
21136: ARRAY
21137: PPUSH
21138: LD_INT 2
21140: PUSH
21141: LD_INT 30
21143: PUSH
21144: LD_INT 32
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: PUSH
21151: LD_INT 30
21153: PUSH
21154: LD_INT 33
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: PUSH
21161: EMPTY
21162: LIST
21163: LIST
21164: LIST
21165: PPUSH
21166: CALL_OW 72
21170: PPUSH
21171: CALL_OW 1
21175: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
21176: LD_ADDR_EXP 59
21180: PUSH
21181: LD_EXP 59
21185: PPUSH
21186: LD_VAR 0 2
21190: PPUSH
21191: LD_EXP 50
21195: PUSH
21196: LD_VAR 0 2
21200: ARRAY
21201: PPUSH
21202: LD_INT 2
21204: PUSH
21205: LD_INT 30
21207: PUSH
21208: LD_INT 32
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PUSH
21215: LD_INT 30
21217: PUSH
21218: LD_INT 31
21220: PUSH
21221: EMPTY
21222: LIST
21223: LIST
21224: PUSH
21225: EMPTY
21226: LIST
21227: LIST
21228: LIST
21229: PUSH
21230: LD_INT 58
21232: PUSH
21233: EMPTY
21234: LIST
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: PPUSH
21240: CALL_OW 72
21244: PPUSH
21245: CALL_OW 1
21249: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
21250: LD_ADDR_EXP 60
21254: PUSH
21255: LD_EXP 60
21259: PPUSH
21260: LD_VAR 0 2
21264: PPUSH
21265: EMPTY
21266: PPUSH
21267: CALL_OW 1
21271: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
21272: LD_ADDR_EXP 64
21276: PUSH
21277: LD_EXP 64
21281: PPUSH
21282: LD_VAR 0 2
21286: PPUSH
21287: EMPTY
21288: PPUSH
21289: CALL_OW 1
21293: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
21294: LD_ADDR_EXP 63
21298: PUSH
21299: LD_EXP 63
21303: PPUSH
21304: LD_VAR 0 2
21308: PPUSH
21309: EMPTY
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21316: LD_ADDR_EXP 65
21320: PUSH
21321: LD_EXP 65
21325: PPUSH
21326: LD_VAR 0 2
21330: PPUSH
21331: EMPTY
21332: PPUSH
21333: CALL_OW 1
21337: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21338: LD_ADDR_EXP 66
21342: PUSH
21343: LD_EXP 66
21347: PPUSH
21348: LD_VAR 0 2
21352: PPUSH
21353: EMPTY
21354: PPUSH
21355: CALL_OW 1
21359: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21360: LD_ADDR_EXP 67
21364: PUSH
21365: LD_EXP 67
21369: PPUSH
21370: LD_VAR 0 2
21374: PPUSH
21375: EMPTY
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21382: LD_ADDR_EXP 68
21386: PUSH
21387: LD_EXP 68
21391: PPUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: EMPTY
21398: PPUSH
21399: CALL_OW 1
21403: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21404: LD_ADDR_EXP 69
21408: PUSH
21409: LD_EXP 69
21413: PPUSH
21414: LD_VAR 0 2
21418: PPUSH
21419: EMPTY
21420: PPUSH
21421: CALL_OW 1
21425: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21426: LD_ADDR_EXP 70
21430: PUSH
21431: LD_EXP 70
21435: PPUSH
21436: LD_VAR 0 2
21440: PPUSH
21441: EMPTY
21442: PPUSH
21443: CALL_OW 1
21447: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21448: LD_ADDR_EXP 71
21452: PUSH
21453: LD_EXP 71
21457: PPUSH
21458: LD_VAR 0 2
21462: PPUSH
21463: EMPTY
21464: PPUSH
21465: CALL_OW 1
21469: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21470: LD_ADDR_EXP 72
21474: PUSH
21475: LD_EXP 72
21479: PPUSH
21480: LD_VAR 0 2
21484: PPUSH
21485: EMPTY
21486: PPUSH
21487: CALL_OW 1
21491: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21492: LD_ADDR_EXP 61
21496: PUSH
21497: LD_EXP 61
21501: PPUSH
21502: LD_VAR 0 2
21506: PPUSH
21507: LD_INT 0
21509: PPUSH
21510: CALL_OW 1
21514: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21515: LD_ADDR_EXP 74
21519: PUSH
21520: LD_EXP 74
21524: PPUSH
21525: LD_VAR 0 2
21529: PPUSH
21530: LD_INT 0
21532: PPUSH
21533: CALL_OW 1
21537: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21538: LD_ADDR_EXP 62
21542: PUSH
21543: LD_EXP 62
21547: PPUSH
21548: LD_VAR 0 2
21552: PPUSH
21553: EMPTY
21554: PPUSH
21555: CALL_OW 1
21559: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21560: LD_ADDR_EXP 73
21564: PUSH
21565: LD_EXP 73
21569: PPUSH
21570: LD_VAR 0 2
21574: PPUSH
21575: LD_INT 0
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21583: LD_ADDR_EXP 75
21587: PUSH
21588: LD_EXP 75
21592: PPUSH
21593: LD_VAR 0 2
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21605: LD_ADDR_EXP 78
21609: PUSH
21610: LD_EXP 78
21614: PPUSH
21615: LD_VAR 0 2
21619: PPUSH
21620: LD_INT 0
21622: PPUSH
21623: CALL_OW 1
21627: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21628: LD_ADDR_EXP 79
21632: PUSH
21633: LD_EXP 79
21637: PPUSH
21638: LD_VAR 0 2
21642: PPUSH
21643: EMPTY
21644: PPUSH
21645: CALL_OW 1
21649: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21650: LD_ADDR_EXP 80
21654: PUSH
21655: LD_EXP 80
21659: PPUSH
21660: LD_VAR 0 2
21664: PPUSH
21665: EMPTY
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21672: LD_ADDR_EXP 81
21676: PUSH
21677: LD_EXP 81
21681: PPUSH
21682: LD_VAR 0 2
21686: PPUSH
21687: EMPTY
21688: PPUSH
21689: CALL_OW 1
21693: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21694: LD_ADDR_EXP 83
21698: PUSH
21699: LD_EXP 83
21703: PPUSH
21704: LD_VAR 0 2
21708: PPUSH
21709: LD_EXP 50
21713: PUSH
21714: LD_VAR 0 2
21718: ARRAY
21719: PPUSH
21720: LD_INT 2
21722: PUSH
21723: LD_INT 30
21725: PUSH
21726: LD_INT 6
21728: PUSH
21729: EMPTY
21730: LIST
21731: LIST
21732: PUSH
21733: LD_INT 30
21735: PUSH
21736: LD_INT 7
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: PUSH
21743: LD_INT 30
21745: PUSH
21746: LD_INT 8
21748: PUSH
21749: EMPTY
21750: LIST
21751: LIST
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: LIST
21757: LIST
21758: PPUSH
21759: CALL_OW 72
21763: PPUSH
21764: CALL_OW 1
21768: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21769: LD_ADDR_EXP 84
21773: PUSH
21774: LD_EXP 84
21778: PPUSH
21779: LD_VAR 0 2
21783: PPUSH
21784: EMPTY
21785: PPUSH
21786: CALL_OW 1
21790: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21791: LD_ADDR_EXP 85
21795: PUSH
21796: LD_EXP 85
21800: PPUSH
21801: LD_VAR 0 2
21805: PPUSH
21806: EMPTY
21807: PPUSH
21808: CALL_OW 1
21812: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21813: LD_ADDR_EXP 86
21817: PUSH
21818: LD_EXP 86
21822: PPUSH
21823: LD_VAR 0 2
21827: PPUSH
21828: EMPTY
21829: PPUSH
21830: CALL_OW 1
21834: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21835: LD_ADDR_EXP 87
21839: PUSH
21840: LD_EXP 87
21844: PPUSH
21845: LD_VAR 0 2
21849: PPUSH
21850: EMPTY
21851: PPUSH
21852: CALL_OW 1
21856: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21857: LD_ADDR_EXP 88
21861: PUSH
21862: LD_EXP 88
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: EMPTY
21873: PPUSH
21874: CALL_OW 1
21878: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21879: LD_ADDR_EXP 89
21883: PUSH
21884: LD_EXP 89
21888: PPUSH
21889: LD_VAR 0 2
21893: PPUSH
21894: EMPTY
21895: PPUSH
21896: CALL_OW 1
21900: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21901: LD_ADDR_EXP 90
21905: PUSH
21906: LD_EXP 90
21910: PPUSH
21911: LD_VAR 0 2
21915: PPUSH
21916: EMPTY
21917: PPUSH
21918: CALL_OW 1
21922: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21923: LD_ADDR_EXP 91
21927: PUSH
21928: LD_EXP 91
21932: PPUSH
21933: LD_VAR 0 2
21937: PPUSH
21938: EMPTY
21939: PPUSH
21940: CALL_OW 1
21944: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21945: LD_ADDR_EXP 92
21949: PUSH
21950: LD_EXP 92
21954: PPUSH
21955: LD_VAR 0 2
21959: PPUSH
21960: LD_INT 0
21962: PPUSH
21963: CALL_OW 1
21967: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21968: LD_ADDR_EXP 93
21972: PUSH
21973: LD_EXP 93
21977: PPUSH
21978: LD_VAR 0 2
21982: PPUSH
21983: LD_INT 0
21985: PPUSH
21986: CALL_OW 1
21990: ST_TO_ADDR
// end ;
21991: GO 20892
21993: POP
21994: POP
// MC_InitSides ( ) ;
21995: CALL 22281 0 0
// MC_InitResearch ( ) ;
21999: CALL 22020 0 0
// CustomInitMacro ( ) ;
22003: CALL 304 0 0
// skirmish := true ;
22007: LD_ADDR_EXP 48
22011: PUSH
22012: LD_INT 1
22014: ST_TO_ADDR
// end ;
22015: LD_VAR 0 1
22019: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
22020: LD_INT 0
22022: PPUSH
22023: PPUSH
22024: PPUSH
22025: PPUSH
22026: PPUSH
22027: PPUSH
// if not mc_bases then
22028: LD_EXP 50
22032: NOT
22033: IFFALSE 22037
// exit ;
22035: GO 22276
// for i = 1 to 8 do
22037: LD_ADDR_VAR 0 2
22041: PUSH
22042: DOUBLE
22043: LD_INT 1
22045: DEC
22046: ST_TO_ADDR
22047: LD_INT 8
22049: PUSH
22050: FOR_TO
22051: IFFALSE 22077
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
22053: LD_ADDR_EXP 77
22057: PUSH
22058: LD_EXP 77
22062: PPUSH
22063: LD_VAR 0 2
22067: PPUSH
22068: EMPTY
22069: PPUSH
22070: CALL_OW 1
22074: ST_TO_ADDR
22075: GO 22050
22077: POP
22078: POP
// tmp := [ ] ;
22079: LD_ADDR_VAR 0 5
22083: PUSH
22084: EMPTY
22085: ST_TO_ADDR
// for i = 1 to mc_sides do
22086: LD_ADDR_VAR 0 2
22090: PUSH
22091: DOUBLE
22092: LD_INT 1
22094: DEC
22095: ST_TO_ADDR
22096: LD_EXP 76
22100: PUSH
22101: FOR_TO
22102: IFFALSE 22160
// if not mc_sides [ i ] in tmp then
22104: LD_EXP 76
22108: PUSH
22109: LD_VAR 0 2
22113: ARRAY
22114: PUSH
22115: LD_VAR 0 5
22119: IN
22120: NOT
22121: IFFALSE 22158
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
22123: LD_ADDR_VAR 0 5
22127: PUSH
22128: LD_VAR 0 5
22132: PPUSH
22133: LD_VAR 0 5
22137: PUSH
22138: LD_INT 1
22140: PLUS
22141: PPUSH
22142: LD_EXP 76
22146: PUSH
22147: LD_VAR 0 2
22151: ARRAY
22152: PPUSH
22153: CALL_OW 2
22157: ST_TO_ADDR
22158: GO 22101
22160: POP
22161: POP
// if not tmp then
22162: LD_VAR 0 5
22166: NOT
22167: IFFALSE 22171
// exit ;
22169: GO 22276
// for j in tmp do
22171: LD_ADDR_VAR 0 3
22175: PUSH
22176: LD_VAR 0 5
22180: PUSH
22181: FOR_IN
22182: IFFALSE 22274
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
22184: LD_ADDR_VAR 0 6
22188: PUSH
22189: LD_INT 22
22191: PUSH
22192: LD_VAR 0 3
22196: PUSH
22197: EMPTY
22198: LIST
22199: LIST
22200: PPUSH
22201: CALL_OW 69
22205: ST_TO_ADDR
// if not un then
22206: LD_VAR 0 6
22210: NOT
22211: IFFALSE 22215
// continue ;
22213: GO 22181
// nation := GetNation ( un [ 1 ] ) ;
22215: LD_ADDR_VAR 0 4
22219: PUSH
22220: LD_VAR 0 6
22224: PUSH
22225: LD_INT 1
22227: ARRAY
22228: PPUSH
22229: CALL_OW 248
22233: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
22234: LD_ADDR_EXP 77
22238: PUSH
22239: LD_EXP 77
22243: PPUSH
22244: LD_VAR 0 3
22248: PPUSH
22249: LD_VAR 0 3
22253: PPUSH
22254: LD_VAR 0 4
22258: PPUSH
22259: LD_INT 1
22261: PPUSH
22262: CALL 49902 0 3
22266: PPUSH
22267: CALL_OW 1
22271: ST_TO_ADDR
// end ;
22272: GO 22181
22274: POP
22275: POP
// end ;
22276: LD_VAR 0 1
22280: RET
// export function MC_InitSides ( ) ; var i ; begin
22281: LD_INT 0
22283: PPUSH
22284: PPUSH
// if not mc_bases then
22285: LD_EXP 50
22289: NOT
22290: IFFALSE 22294
// exit ;
22292: GO 22368
// for i = 1 to mc_bases do
22294: LD_ADDR_VAR 0 2
22298: PUSH
22299: DOUBLE
22300: LD_INT 1
22302: DEC
22303: ST_TO_ADDR
22304: LD_EXP 50
22308: PUSH
22309: FOR_TO
22310: IFFALSE 22366
// if mc_bases [ i ] then
22312: LD_EXP 50
22316: PUSH
22317: LD_VAR 0 2
22321: ARRAY
22322: IFFALSE 22364
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22324: LD_ADDR_EXP 76
22328: PUSH
22329: LD_EXP 76
22333: PPUSH
22334: LD_VAR 0 2
22338: PPUSH
22339: LD_EXP 50
22343: PUSH
22344: LD_VAR 0 2
22348: ARRAY
22349: PUSH
22350: LD_INT 1
22352: ARRAY
22353: PPUSH
22354: CALL_OW 255
22358: PPUSH
22359: CALL_OW 1
22363: ST_TO_ADDR
22364: GO 22309
22366: POP
22367: POP
// end ;
22368: LD_VAR 0 1
22372: RET
// every 0 0$03 trigger skirmish do
22373: LD_EXP 48
22377: IFFALSE 22531
22379: GO 22381
22381: DISABLE
// begin enable ;
22382: ENABLE
// MC_CheckBuildings ( ) ;
22383: CALL 27089 0 0
// MC_CheckPeopleLife ( ) ;
22387: CALL 27250 0 0
// RaiseSailEvent ( 100 ) ;
22391: LD_INT 100
22393: PPUSH
22394: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22398: LD_INT 103
22400: PPUSH
22401: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22405: LD_INT 104
22407: PPUSH
22408: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22412: LD_INT 105
22414: PPUSH
22415: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22419: LD_INT 106
22421: PPUSH
22422: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22426: LD_INT 107
22428: PPUSH
22429: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22433: LD_INT 108
22435: PPUSH
22436: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22440: LD_INT 109
22442: PPUSH
22443: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22447: LD_INT 110
22449: PPUSH
22450: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22454: LD_INT 111
22456: PPUSH
22457: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22461: LD_INT 112
22463: PPUSH
22464: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22468: LD_INT 113
22470: PPUSH
22471: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22475: LD_INT 120
22477: PPUSH
22478: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22482: LD_INT 121
22484: PPUSH
22485: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22489: LD_INT 122
22491: PPUSH
22492: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22496: LD_INT 123
22498: PPUSH
22499: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22503: LD_INT 124
22505: PPUSH
22506: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22510: LD_INT 125
22512: PPUSH
22513: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22517: LD_INT 126
22519: PPUSH
22520: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22524: LD_INT 200
22526: PPUSH
22527: CALL_OW 427
// end ;
22531: END
// on SailEvent ( event ) do begin if event < 100 then
22532: LD_VAR 0 1
22536: PUSH
22537: LD_INT 100
22539: LESS
22540: IFFALSE 22551
// CustomEvent ( event ) ;
22542: LD_VAR 0 1
22546: PPUSH
22547: CALL 17694 0 1
// if event = 100 then
22551: LD_VAR 0 1
22555: PUSH
22556: LD_INT 100
22558: EQUAL
22559: IFFALSE 22565
// MC_ClassManager ( ) ;
22561: CALL 22959 0 0
// if event = 101 then
22565: LD_VAR 0 1
22569: PUSH
22570: LD_INT 101
22572: EQUAL
22573: IFFALSE 22579
// MC_RepairBuildings ( ) ;
22575: CALL 27837 0 0
// if event = 102 then
22579: LD_VAR 0 1
22583: PUSH
22584: LD_INT 102
22586: EQUAL
22587: IFFALSE 22593
// MC_Heal ( ) ;
22589: CALL 28776 0 0
// if event = 103 then
22593: LD_VAR 0 1
22597: PUSH
22598: LD_INT 103
22600: EQUAL
22601: IFFALSE 22607
// MC_Build ( ) ;
22603: CALL 29202 0 0
// if event = 104 then
22607: LD_VAR 0 1
22611: PUSH
22612: LD_INT 104
22614: EQUAL
22615: IFFALSE 22621
// MC_TurretWeapon ( ) ;
22617: CALL 30850 0 0
// if event = 105 then
22621: LD_VAR 0 1
22625: PUSH
22626: LD_INT 105
22628: EQUAL
22629: IFFALSE 22635
// MC_BuildUpgrade ( ) ;
22631: CALL 30395 0 0
// if event = 106 then
22635: LD_VAR 0 1
22639: PUSH
22640: LD_INT 106
22642: EQUAL
22643: IFFALSE 22649
// MC_PlantMines ( ) ;
22645: CALL 31282 0 0
// if event = 107 then
22649: LD_VAR 0 1
22653: PUSH
22654: LD_INT 107
22656: EQUAL
22657: IFFALSE 22663
// MC_CollectCrates ( ) ;
22659: CALL 32092 0 0
// if event = 108 then
22663: LD_VAR 0 1
22667: PUSH
22668: LD_INT 108
22670: EQUAL
22671: IFFALSE 22677
// MC_LinkRemoteControl ( ) ;
22673: CALL 33966 0 0
// if event = 109 then
22677: LD_VAR 0 1
22681: PUSH
22682: LD_INT 109
22684: EQUAL
22685: IFFALSE 22691
// MC_ProduceVehicle ( ) ;
22687: CALL 34151 0 0
// if event = 110 then
22691: LD_VAR 0 1
22695: PUSH
22696: LD_INT 110
22698: EQUAL
22699: IFFALSE 22705
// MC_SendAttack ( ) ;
22701: CALL 34621 0 0
// if event = 111 then
22705: LD_VAR 0 1
22709: PUSH
22710: LD_INT 111
22712: EQUAL
22713: IFFALSE 22719
// MC_Defend ( ) ;
22715: CALL 34729 0 0
// if event = 112 then
22719: LD_VAR 0 1
22723: PUSH
22724: LD_INT 112
22726: EQUAL
22727: IFFALSE 22733
// MC_Research ( ) ;
22729: CALL 35629 0 0
// if event = 113 then
22733: LD_VAR 0 1
22737: PUSH
22738: LD_INT 113
22740: EQUAL
22741: IFFALSE 22747
// MC_MinesTrigger ( ) ;
22743: CALL 36769 0 0
// if event = 120 then
22747: LD_VAR 0 1
22751: PUSH
22752: LD_INT 120
22754: EQUAL
22755: IFFALSE 22761
// MC_RepairVehicle ( ) ;
22757: CALL 36870 0 0
// if event = 121 then
22761: LD_VAR 0 1
22765: PUSH
22766: LD_INT 121
22768: EQUAL
22769: IFFALSE 22775
// MC_TameApe ( ) ;
22771: CALL 37647 0 0
// if event = 122 then
22775: LD_VAR 0 1
22779: PUSH
22780: LD_INT 122
22782: EQUAL
22783: IFFALSE 22789
// MC_ChangeApeClass ( ) ;
22785: CALL 38492 0 0
// if event = 123 then
22789: LD_VAR 0 1
22793: PUSH
22794: LD_INT 123
22796: EQUAL
22797: IFFALSE 22803
// MC_Bazooka ( ) ;
22799: CALL 39148 0 0
// if event = 124 then
22803: LD_VAR 0 1
22807: PUSH
22808: LD_INT 124
22810: EQUAL
22811: IFFALSE 22817
// MC_TeleportExit ( ) ;
22813: CALL 39350 0 0
// if event = 125 then
22817: LD_VAR 0 1
22821: PUSH
22822: LD_INT 125
22824: EQUAL
22825: IFFALSE 22831
// MC_Deposits ( ) ;
22827: CALL 40007 0 0
// if event = 126 then
22831: LD_VAR 0 1
22835: PUSH
22836: LD_INT 126
22838: EQUAL
22839: IFFALSE 22845
// MC_RemoteDriver ( ) ;
22841: CALL 40640 0 0
// if event = 200 then
22845: LD_VAR 0 1
22849: PUSH
22850: LD_INT 200
22852: EQUAL
22853: IFFALSE 22859
// MC_Idle ( ) ;
22855: CALL 42575 0 0
// end ;
22859: PPOPN 1
22861: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22862: LD_INT 0
22864: PPUSH
22865: PPUSH
// if not mc_bases [ base ] or not tag then
22866: LD_EXP 50
22870: PUSH
22871: LD_VAR 0 1
22875: ARRAY
22876: NOT
22877: IFTRUE 22886
22879: PUSH
22880: LD_VAR 0 2
22884: NOT
22885: OR
22886: IFFALSE 22890
// exit ;
22888: GO 22954
// for i in mc_bases [ base ] union mc_ape [ base ] do
22890: LD_ADDR_VAR 0 4
22894: PUSH
22895: LD_EXP 50
22899: PUSH
22900: LD_VAR 0 1
22904: ARRAY
22905: PUSH
22906: LD_EXP 79
22910: PUSH
22911: LD_VAR 0 1
22915: ARRAY
22916: UNION
22917: PUSH
22918: FOR_IN
22919: IFFALSE 22952
// if GetTag ( i ) = tag then
22921: LD_VAR 0 4
22925: PPUSH
22926: CALL_OW 110
22930: PUSH
22931: LD_VAR 0 2
22935: EQUAL
22936: IFFALSE 22950
// SetTag ( i , 0 ) ;
22938: LD_VAR 0 4
22942: PPUSH
22943: LD_INT 0
22945: PPUSH
22946: CALL_OW 109
22950: GO 22918
22952: POP
22953: POP
// end ;
22954: LD_VAR 0 3
22958: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22959: LD_INT 0
22961: PPUSH
22962: PPUSH
22963: PPUSH
22964: PPUSH
22965: PPUSH
22966: PPUSH
22967: PPUSH
22968: PPUSH
// if not mc_bases then
22969: LD_EXP 50
22973: NOT
22974: IFFALSE 22978
// exit ;
22976: GO 23429
// for i = 1 to mc_bases do
22978: LD_ADDR_VAR 0 2
22982: PUSH
22983: DOUBLE
22984: LD_INT 1
22986: DEC
22987: ST_TO_ADDR
22988: LD_EXP 50
22992: PUSH
22993: FOR_TO
22994: IFFALSE 23427
// begin tmp := MC_ClassCheckReq ( i ) ;
22996: LD_ADDR_VAR 0 4
23000: PUSH
23001: LD_VAR 0 2
23005: PPUSH
23006: CALL 23434 0 1
23010: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
23011: LD_ADDR_EXP 91
23015: PUSH
23016: LD_EXP 91
23020: PPUSH
23021: LD_VAR 0 2
23025: PPUSH
23026: LD_VAR 0 4
23030: PPUSH
23031: CALL_OW 1
23035: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
23036: LD_ADDR_VAR 0 6
23040: PUSH
23041: LD_EXP 50
23045: PUSH
23046: LD_VAR 0 2
23050: ARRAY
23051: PPUSH
23052: LD_INT 2
23054: PUSH
23055: LD_INT 30
23057: PUSH
23058: LD_INT 4
23060: PUSH
23061: EMPTY
23062: LIST
23063: LIST
23064: PUSH
23065: LD_INT 30
23067: PUSH
23068: LD_INT 5
23070: PUSH
23071: EMPTY
23072: LIST
23073: LIST
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: LIST
23079: PPUSH
23080: CALL_OW 72
23084: PUSH
23085: LD_EXP 50
23089: PUSH
23090: LD_VAR 0 2
23094: ARRAY
23095: PPUSH
23096: LD_INT 2
23098: PUSH
23099: LD_INT 30
23101: PUSH
23102: LD_INT 0
23104: PUSH
23105: EMPTY
23106: LIST
23107: LIST
23108: PUSH
23109: LD_INT 30
23111: PUSH
23112: LD_INT 1
23114: PUSH
23115: EMPTY
23116: LIST
23117: LIST
23118: PUSH
23119: EMPTY
23120: LIST
23121: LIST
23122: LIST
23123: PPUSH
23124: CALL_OW 72
23128: PUSH
23129: LD_EXP 50
23133: PUSH
23134: LD_VAR 0 2
23138: ARRAY
23139: PPUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 3
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PPUSH
23150: CALL_OW 72
23154: PUSH
23155: LD_EXP 50
23159: PUSH
23160: LD_VAR 0 2
23164: ARRAY
23165: PPUSH
23166: LD_INT 2
23168: PUSH
23169: LD_INT 30
23171: PUSH
23172: LD_INT 6
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: PUSH
23179: LD_INT 30
23181: PUSH
23182: LD_INT 7
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 30
23191: PUSH
23192: LD_INT 8
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: EMPTY
23200: LIST
23201: LIST
23202: LIST
23203: LIST
23204: PPUSH
23205: CALL_OW 72
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: LIST
23214: LIST
23215: ST_TO_ADDR
// for j := 1 to 4 do
23216: LD_ADDR_VAR 0 3
23220: PUSH
23221: DOUBLE
23222: LD_INT 1
23224: DEC
23225: ST_TO_ADDR
23226: LD_INT 4
23228: PUSH
23229: FOR_TO
23230: IFFALSE 23423
// begin if not tmp [ j ] then
23232: LD_VAR 0 4
23236: PUSH
23237: LD_VAR 0 3
23241: ARRAY
23242: NOT
23243: IFFALSE 23247
// continue ;
23245: GO 23229
// for p in tmp [ j ] do
23247: LD_ADDR_VAR 0 5
23251: PUSH
23252: LD_VAR 0 4
23256: PUSH
23257: LD_VAR 0 3
23261: ARRAY
23262: PUSH
23263: FOR_IN
23264: IFFALSE 23419
// begin if not b [ j ] then
23266: LD_VAR 0 6
23270: PUSH
23271: LD_VAR 0 3
23275: ARRAY
23276: NOT
23277: IFFALSE 23281
// break ;
23279: GO 23419
// e := 0 ;
23281: LD_ADDR_VAR 0 7
23285: PUSH
23286: LD_INT 0
23288: ST_TO_ADDR
// for k in b [ j ] do
23289: LD_ADDR_VAR 0 8
23293: PUSH
23294: LD_VAR 0 6
23298: PUSH
23299: LD_VAR 0 3
23303: ARRAY
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23333
// if IsNotFull ( k ) then
23308: LD_VAR 0 8
23312: PPUSH
23313: CALL 52061 0 1
23317: IFFALSE 23331
// begin e := k ;
23319: LD_ADDR_VAR 0 7
23323: PUSH
23324: LD_VAR 0 8
23328: ST_TO_ADDR
// break ;
23329: GO 23333
// end ;
23331: GO 23305
23333: POP
23334: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23335: LD_VAR 0 7
23339: IFFALSE 23358
23341: PUSH
23342: LD_VAR 0 5
23346: PPUSH
23347: LD_VAR 0 7
23351: PPUSH
23352: CALL 86565 0 2
23356: NOT
23357: AND
23358: IFFALSE 23417
// begin if IsInUnit ( p ) then
23360: LD_VAR 0 5
23364: PPUSH
23365: CALL_OW 310
23369: IFFALSE 23380
// ComExitBuilding ( p ) ;
23371: LD_VAR 0 5
23375: PPUSH
23376: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23380: LD_VAR 0 5
23384: PPUSH
23385: LD_VAR 0 7
23389: PPUSH
23390: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23394: LD_VAR 0 5
23398: PPUSH
23399: LD_VAR 0 3
23403: PPUSH
23404: CALL_OW 183
// AddComExitBuilding ( p ) ;
23408: LD_VAR 0 5
23412: PPUSH
23413: CALL_OW 182
// end ; end ;
23417: GO 23263
23419: POP
23420: POP
// end ;
23421: GO 23229
23423: POP
23424: POP
// end ;
23425: GO 22993
23427: POP
23428: POP
// end ;
23429: LD_VAR 0 1
23433: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23434: LD_INT 0
23436: PPUSH
23437: PPUSH
23438: PPUSH
23439: PPUSH
23440: PPUSH
23441: PPUSH
23442: PPUSH
23443: PPUSH
23444: PPUSH
23445: PPUSH
23446: PPUSH
23447: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23448: LD_ADDR_VAR 0 2
23452: PUSH
23453: LD_INT 0
23455: PUSH
23456: LD_INT 0
23458: PUSH
23459: LD_INT 0
23461: PUSH
23462: LD_INT 0
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: LIST
23469: LIST
23470: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23471: LD_VAR 0 1
23475: NOT
23476: IFTRUE 23491
23478: PUSH
23479: LD_EXP 50
23483: PUSH
23484: LD_VAR 0 1
23488: ARRAY
23489: NOT
23490: OR
23491: IFTRUE 23539
23493: PUSH
23494: LD_EXP 50
23498: PUSH
23499: LD_VAR 0 1
23503: ARRAY
23504: PPUSH
23505: LD_INT 2
23507: PUSH
23508: LD_INT 30
23510: PUSH
23511: LD_INT 0
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: PUSH
23518: LD_INT 30
23520: PUSH
23521: LD_INT 1
23523: PUSH
23524: EMPTY
23525: LIST
23526: LIST
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: LIST
23532: PPUSH
23533: CALL_OW 72
23537: NOT
23538: OR
23539: IFFALSE 23543
// exit ;
23541: GO 27084
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23543: LD_ADDR_VAR 0 4
23547: PUSH
23548: LD_EXP 50
23552: PUSH
23553: LD_VAR 0 1
23557: ARRAY
23558: PPUSH
23559: LD_INT 2
23561: PUSH
23562: LD_INT 25
23564: PUSH
23565: LD_INT 1
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: PUSH
23572: LD_INT 25
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: PUSH
23582: LD_INT 25
23584: PUSH
23585: LD_INT 3
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PUSH
23592: LD_INT 25
23594: PUSH
23595: LD_INT 4
23597: PUSH
23598: EMPTY
23599: LIST
23600: LIST
23601: PUSH
23602: LD_INT 25
23604: PUSH
23605: LD_INT 5
23607: PUSH
23608: EMPTY
23609: LIST
23610: LIST
23611: PUSH
23612: LD_INT 25
23614: PUSH
23615: LD_INT 8
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 25
23624: PUSH
23625: LD_INT 9
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: PPUSH
23642: CALL_OW 72
23646: ST_TO_ADDR
// if not tmp then
23647: LD_VAR 0 4
23651: NOT
23652: IFFALSE 23656
// exit ;
23654: GO 27084
// for i in tmp do
23656: LD_ADDR_VAR 0 3
23660: PUSH
23661: LD_VAR 0 4
23665: PUSH
23666: FOR_IN
23667: IFFALSE 23698
// if GetTag ( i ) then
23669: LD_VAR 0 3
23673: PPUSH
23674: CALL_OW 110
23678: IFFALSE 23696
// tmp := tmp diff i ;
23680: LD_ADDR_VAR 0 4
23684: PUSH
23685: LD_VAR 0 4
23689: PUSH
23690: LD_VAR 0 3
23694: DIFF
23695: ST_TO_ADDR
23696: GO 23666
23698: POP
23699: POP
// if not tmp then
23700: LD_VAR 0 4
23704: NOT
23705: IFFALSE 23709
// exit ;
23707: GO 27084
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23709: LD_ADDR_VAR 0 5
23713: PUSH
23714: LD_EXP 50
23718: PUSH
23719: LD_VAR 0 1
23723: ARRAY
23724: PPUSH
23725: LD_INT 2
23727: PUSH
23728: LD_INT 25
23730: PUSH
23731: LD_INT 1
23733: PUSH
23734: EMPTY
23735: LIST
23736: LIST
23737: PUSH
23738: LD_INT 25
23740: PUSH
23741: LD_INT 5
23743: PUSH
23744: EMPTY
23745: LIST
23746: LIST
23747: PUSH
23748: LD_INT 25
23750: PUSH
23751: LD_INT 8
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: PUSH
23758: LD_INT 25
23760: PUSH
23761: LD_INT 9
23763: PUSH
23764: EMPTY
23765: LIST
23766: LIST
23767: PUSH
23768: EMPTY
23769: LIST
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: PPUSH
23775: CALL_OW 72
23779: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23780: LD_ADDR_VAR 0 6
23784: PUSH
23785: LD_EXP 50
23789: PUSH
23790: LD_VAR 0 1
23794: ARRAY
23795: PPUSH
23796: LD_INT 25
23798: PUSH
23799: LD_INT 2
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: PPUSH
23806: CALL_OW 72
23810: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23811: LD_ADDR_VAR 0 7
23815: PUSH
23816: LD_EXP 50
23820: PUSH
23821: LD_VAR 0 1
23825: ARRAY
23826: PPUSH
23827: LD_INT 25
23829: PUSH
23830: LD_INT 3
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: PPUSH
23837: CALL_OW 72
23841: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23842: LD_ADDR_VAR 0 8
23846: PUSH
23847: LD_EXP 50
23851: PUSH
23852: LD_VAR 0 1
23856: ARRAY
23857: PPUSH
23858: LD_INT 25
23860: PUSH
23861: LD_INT 4
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: PUSH
23868: LD_INT 24
23870: PUSH
23871: LD_INT 251
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PPUSH
23882: CALL_OW 72
23886: ST_TO_ADDR
// if mc_is_defending [ base ] then
23887: LD_EXP 93
23891: PUSH
23892: LD_VAR 0 1
23896: ARRAY
23897: IFFALSE 24358
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23899: LD_ADDR_EXP 92
23903: PUSH
23904: LD_EXP 92
23908: PPUSH
23909: LD_VAR 0 1
23913: PPUSH
23914: LD_INT 4
23916: PPUSH
23917: CALL_OW 1
23921: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23922: LD_ADDR_VAR 0 12
23926: PUSH
23927: LD_EXP 50
23931: PUSH
23932: LD_VAR 0 1
23936: ARRAY
23937: PPUSH
23938: LD_INT 2
23940: PUSH
23941: LD_INT 30
23943: PUSH
23944: LD_INT 4
23946: PUSH
23947: EMPTY
23948: LIST
23949: LIST
23950: PUSH
23951: LD_INT 30
23953: PUSH
23954: LD_INT 5
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: PUSH
23961: EMPTY
23962: LIST
23963: LIST
23964: LIST
23965: PPUSH
23966: CALL_OW 72
23970: ST_TO_ADDR
// if not b then
23971: LD_VAR 0 12
23975: NOT
23976: IFFALSE 23980
// exit ;
23978: GO 27084
// p := [ ] ;
23980: LD_ADDR_VAR 0 11
23984: PUSH
23985: EMPTY
23986: ST_TO_ADDR
// if sci >= 2 then
23987: LD_VAR 0 8
23991: PUSH
23992: LD_INT 2
23994: GREATEREQUAL
23995: IFFALSE 24026
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23997: LD_ADDR_VAR 0 8
24001: PUSH
24002: LD_VAR 0 8
24006: PUSH
24007: LD_INT 1
24009: ARRAY
24010: PUSH
24011: LD_VAR 0 8
24015: PUSH
24016: LD_INT 2
24018: ARRAY
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: ST_TO_ADDR
24024: GO 24087
// if sci = 1 then
24026: LD_VAR 0 8
24030: PUSH
24031: LD_INT 1
24033: EQUAL
24034: IFFALSE 24055
// sci := [ sci [ 1 ] ] else
24036: LD_ADDR_VAR 0 8
24040: PUSH
24041: LD_VAR 0 8
24045: PUSH
24046: LD_INT 1
24048: ARRAY
24049: PUSH
24050: EMPTY
24051: LIST
24052: ST_TO_ADDR
24053: GO 24087
// if sci = 0 then
24055: LD_VAR 0 8
24059: PUSH
24060: LD_INT 0
24062: EQUAL
24063: IFFALSE 24087
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
24065: LD_ADDR_VAR 0 11
24069: PUSH
24070: LD_VAR 0 4
24074: PPUSH
24075: LD_INT 4
24077: PPUSH
24078: CALL 86435 0 2
24082: PUSH
24083: LD_INT 1
24085: ARRAY
24086: ST_TO_ADDR
// if eng > 4 then
24087: LD_VAR 0 6
24091: PUSH
24092: LD_INT 4
24094: GREATER
24095: IFFALSE 24141
// for i = eng downto 4 do
24097: LD_ADDR_VAR 0 3
24101: PUSH
24102: DOUBLE
24103: LD_VAR 0 6
24107: INC
24108: ST_TO_ADDR
24109: LD_INT 4
24111: PUSH
24112: FOR_DOWNTO
24113: IFFALSE 24139
// eng := eng diff eng [ i ] ;
24115: LD_ADDR_VAR 0 6
24119: PUSH
24120: LD_VAR 0 6
24124: PUSH
24125: LD_VAR 0 6
24129: PUSH
24130: LD_VAR 0 3
24134: ARRAY
24135: DIFF
24136: ST_TO_ADDR
24137: GO 24112
24139: POP
24140: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
24141: LD_ADDR_VAR 0 4
24145: PUSH
24146: LD_VAR 0 4
24150: PUSH
24151: LD_VAR 0 5
24155: PUSH
24156: LD_VAR 0 6
24160: UNION
24161: PUSH
24162: LD_VAR 0 7
24166: UNION
24167: PUSH
24168: LD_VAR 0 8
24172: UNION
24173: DIFF
24174: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
24175: LD_ADDR_VAR 0 13
24179: PUSH
24180: LD_EXP 50
24184: PUSH
24185: LD_VAR 0 1
24189: ARRAY
24190: PPUSH
24191: LD_INT 2
24193: PUSH
24194: LD_INT 30
24196: PUSH
24197: LD_INT 32
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: PUSH
24204: LD_INT 30
24206: PUSH
24207: LD_INT 31
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: LIST
24218: PPUSH
24219: CALL_OW 72
24223: PUSH
24224: LD_EXP 50
24228: PUSH
24229: LD_VAR 0 1
24233: ARRAY
24234: PPUSH
24235: LD_INT 2
24237: PUSH
24238: LD_INT 30
24240: PUSH
24241: LD_INT 4
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: PUSH
24248: LD_INT 30
24250: PUSH
24251: LD_INT 5
24253: PUSH
24254: EMPTY
24255: LIST
24256: LIST
24257: PUSH
24258: EMPTY
24259: LIST
24260: LIST
24261: LIST
24262: PPUSH
24263: CALL_OW 72
24267: PUSH
24268: LD_INT 6
24270: MUL
24271: PLUS
24272: ST_TO_ADDR
// if bcount < tmp then
24273: LD_VAR 0 13
24277: PUSH
24278: LD_VAR 0 4
24282: LESS
24283: IFFALSE 24329
// for i = tmp downto bcount do
24285: LD_ADDR_VAR 0 3
24289: PUSH
24290: DOUBLE
24291: LD_VAR 0 4
24295: INC
24296: ST_TO_ADDR
24297: LD_VAR 0 13
24301: PUSH
24302: FOR_DOWNTO
24303: IFFALSE 24327
// tmp := Delete ( tmp , tmp ) ;
24305: LD_ADDR_VAR 0 4
24309: PUSH
24310: LD_VAR 0 4
24314: PPUSH
24315: LD_VAR 0 4
24319: PPUSH
24320: CALL_OW 3
24324: ST_TO_ADDR
24325: GO 24302
24327: POP
24328: POP
// result := [ tmp , 0 , 0 , p ] ;
24329: LD_ADDR_VAR 0 2
24333: PUSH
24334: LD_VAR 0 4
24338: PUSH
24339: LD_INT 0
24341: PUSH
24342: LD_INT 0
24344: PUSH
24345: LD_VAR 0 11
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: ST_TO_ADDR
// exit ;
24356: GO 27084
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24358: LD_EXP 50
24362: PUSH
24363: LD_VAR 0 1
24367: ARRAY
24368: PPUSH
24369: LD_INT 2
24371: PUSH
24372: LD_INT 30
24374: PUSH
24375: LD_INT 6
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: PUSH
24382: LD_INT 30
24384: PUSH
24385: LD_INT 7
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PUSH
24392: LD_INT 30
24394: PUSH
24395: LD_INT 8
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: LIST
24406: LIST
24407: PPUSH
24408: CALL_OW 72
24412: NOT
24413: IFFALSE 24443
24415: PUSH
24416: LD_EXP 50
24420: PUSH
24421: LD_VAR 0 1
24425: ARRAY
24426: PPUSH
24427: LD_INT 30
24429: PUSH
24430: LD_INT 3
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: PPUSH
24437: CALL_OW 72
24441: NOT
24442: AND
24443: IFFALSE 24515
// begin if eng = tmp then
24445: LD_VAR 0 6
24449: PUSH
24450: LD_VAR 0 4
24454: EQUAL
24455: IFFALSE 24459
// exit ;
24457: GO 27084
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24459: LD_ADDR_EXP 92
24463: PUSH
24464: LD_EXP 92
24468: PPUSH
24469: LD_VAR 0 1
24473: PPUSH
24474: LD_INT 1
24476: PPUSH
24477: CALL_OW 1
24481: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24482: LD_ADDR_VAR 0 2
24486: PUSH
24487: LD_INT 0
24489: PUSH
24490: LD_VAR 0 4
24494: PUSH
24495: LD_VAR 0 6
24499: DIFF
24500: PUSH
24501: LD_INT 0
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: EMPTY
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: ST_TO_ADDR
// exit ;
24513: GO 27084
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24515: LD_EXP 77
24519: PUSH
24520: LD_EXP 76
24524: PUSH
24525: LD_VAR 0 1
24529: ARRAY
24530: ARRAY
24531: IFFALSE 24589
24533: PUSH
24534: LD_EXP 50
24538: PUSH
24539: LD_VAR 0 1
24543: ARRAY
24544: PPUSH
24545: LD_INT 2
24547: PUSH
24548: LD_INT 30
24550: PUSH
24551: LD_INT 6
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: PUSH
24558: LD_INT 30
24560: PUSH
24561: LD_INT 7
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: PUSH
24568: LD_INT 30
24570: PUSH
24571: LD_INT 8
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: LIST
24582: LIST
24583: PPUSH
24584: CALL_OW 72
24588: AND
24589: IFFALSE 24619
24591: PUSH
24592: LD_EXP 50
24596: PUSH
24597: LD_VAR 0 1
24601: ARRAY
24602: PPUSH
24603: LD_INT 30
24605: PUSH
24606: LD_INT 3
24608: PUSH
24609: EMPTY
24610: LIST
24611: LIST
24612: PPUSH
24613: CALL_OW 72
24617: NOT
24618: AND
24619: IFFALSE 24835
// begin if sci >= 6 then
24621: LD_VAR 0 8
24625: PUSH
24626: LD_INT 6
24628: GREATEREQUAL
24629: IFFALSE 24633
// exit ;
24631: GO 27084
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24633: LD_ADDR_EXP 92
24637: PUSH
24638: LD_EXP 92
24642: PPUSH
24643: LD_VAR 0 1
24647: PPUSH
24648: LD_INT 2
24650: PPUSH
24651: CALL_OW 1
24655: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24656: LD_ADDR_VAR 0 9
24660: PUSH
24661: LD_VAR 0 4
24665: PUSH
24666: LD_VAR 0 8
24670: DIFF
24671: PPUSH
24672: LD_INT 4
24674: PPUSH
24675: CALL 86435 0 2
24679: ST_TO_ADDR
// p := [ ] ;
24680: LD_ADDR_VAR 0 11
24684: PUSH
24685: EMPTY
24686: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24687: LD_VAR 0 8
24691: PUSH
24692: LD_INT 6
24694: LESS
24695: IFFALSE 24707
24697: PUSH
24698: LD_VAR 0 9
24702: PUSH
24703: LD_INT 6
24705: GREATER
24706: AND
24707: IFFALSE 24788
// begin for i = 1 to 6 - sci do
24709: LD_ADDR_VAR 0 3
24713: PUSH
24714: DOUBLE
24715: LD_INT 1
24717: DEC
24718: ST_TO_ADDR
24719: LD_INT 6
24721: PUSH
24722: LD_VAR 0 8
24726: MINUS
24727: PUSH
24728: FOR_TO
24729: IFFALSE 24784
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24731: LD_ADDR_VAR 0 11
24735: PUSH
24736: LD_VAR 0 11
24740: PPUSH
24741: LD_VAR 0 11
24745: PUSH
24746: LD_INT 1
24748: PLUS
24749: PPUSH
24750: LD_VAR 0 9
24754: PUSH
24755: LD_INT 1
24757: ARRAY
24758: PPUSH
24759: CALL_OW 2
24763: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24764: LD_ADDR_VAR 0 9
24768: PUSH
24769: LD_VAR 0 9
24773: PPUSH
24774: LD_INT 1
24776: PPUSH
24777: CALL_OW 3
24781: ST_TO_ADDR
// end ;
24782: GO 24728
24784: POP
24785: POP
// end else
24786: GO 24808
// if sort then
24788: LD_VAR 0 9
24792: IFFALSE 24808
// p := sort [ 1 ] ;
24794: LD_ADDR_VAR 0 11
24798: PUSH
24799: LD_VAR 0 9
24803: PUSH
24804: LD_INT 1
24806: ARRAY
24807: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24808: LD_ADDR_VAR 0 2
24812: PUSH
24813: LD_INT 0
24815: PUSH
24816: LD_INT 0
24818: PUSH
24819: LD_INT 0
24821: PUSH
24822: LD_VAR 0 11
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: LIST
24831: LIST
24832: ST_TO_ADDR
// exit ;
24833: GO 27084
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24835: LD_EXP 77
24839: PUSH
24840: LD_EXP 76
24844: PUSH
24845: LD_VAR 0 1
24849: ARRAY
24850: ARRAY
24851: IFFALSE 24909
24853: PUSH
24854: LD_EXP 50
24858: PUSH
24859: LD_VAR 0 1
24863: ARRAY
24864: PPUSH
24865: LD_INT 2
24867: PUSH
24868: LD_INT 30
24870: PUSH
24871: LD_INT 6
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: LD_INT 30
24880: PUSH
24881: LD_INT 7
24883: PUSH
24884: EMPTY
24885: LIST
24886: LIST
24887: PUSH
24888: LD_INT 30
24890: PUSH
24891: LD_INT 8
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PUSH
24898: EMPTY
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: PPUSH
24904: CALL_OW 72
24908: AND
24909: IFFALSE 24938
24911: PUSH
24912: LD_EXP 50
24916: PUSH
24917: LD_VAR 0 1
24921: ARRAY
24922: PPUSH
24923: LD_INT 30
24925: PUSH
24926: LD_INT 3
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PPUSH
24933: CALL_OW 72
24937: AND
24938: IFFALSE 25678
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24940: LD_ADDR_EXP 92
24944: PUSH
24945: LD_EXP 92
24949: PPUSH
24950: LD_VAR 0 1
24954: PPUSH
24955: LD_INT 3
24957: PPUSH
24958: CALL_OW 1
24962: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24963: LD_ADDR_VAR 0 2
24967: PUSH
24968: LD_INT 0
24970: PUSH
24971: LD_INT 0
24973: PUSH
24974: LD_INT 0
24976: PUSH
24977: LD_INT 0
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: LIST
24984: LIST
24985: ST_TO_ADDR
// if not eng then
24986: LD_VAR 0 6
24990: NOT
24991: IFFALSE 25054
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24993: LD_ADDR_VAR 0 11
24997: PUSH
24998: LD_VAR 0 4
25002: PPUSH
25003: LD_INT 2
25005: PPUSH
25006: CALL 86435 0 2
25010: PUSH
25011: LD_INT 1
25013: ARRAY
25014: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
25015: LD_ADDR_VAR 0 2
25019: PUSH
25020: LD_VAR 0 2
25024: PPUSH
25025: LD_INT 2
25027: PPUSH
25028: LD_VAR 0 11
25032: PPUSH
25033: CALL_OW 1
25037: ST_TO_ADDR
// tmp := tmp diff p ;
25038: LD_ADDR_VAR 0 4
25042: PUSH
25043: LD_VAR 0 4
25047: PUSH
25048: LD_VAR 0 11
25052: DIFF
25053: ST_TO_ADDR
// end ; if tmp and sci < 6 then
25054: LD_VAR 0 4
25058: IFFALSE 25070
25060: PUSH
25061: LD_VAR 0 8
25065: PUSH
25066: LD_INT 6
25068: LESS
25069: AND
25070: IFFALSE 25258
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
25072: LD_ADDR_VAR 0 9
25076: PUSH
25077: LD_VAR 0 4
25081: PUSH
25082: LD_VAR 0 8
25086: PUSH
25087: LD_VAR 0 7
25091: UNION
25092: DIFF
25093: PPUSH
25094: LD_INT 4
25096: PPUSH
25097: CALL 86435 0 2
25101: ST_TO_ADDR
// p := [ ] ;
25102: LD_ADDR_VAR 0 11
25106: PUSH
25107: EMPTY
25108: ST_TO_ADDR
// if sort then
25109: LD_VAR 0 9
25113: IFFALSE 25229
// for i = 1 to 6 - sci do
25115: LD_ADDR_VAR 0 3
25119: PUSH
25120: DOUBLE
25121: LD_INT 1
25123: DEC
25124: ST_TO_ADDR
25125: LD_INT 6
25127: PUSH
25128: LD_VAR 0 8
25132: MINUS
25133: PUSH
25134: FOR_TO
25135: IFFALSE 25227
// begin if i = sort then
25137: LD_VAR 0 3
25141: PUSH
25142: LD_VAR 0 9
25146: EQUAL
25147: IFFALSE 25151
// break ;
25149: GO 25227
// if GetClass ( i ) = 4 then
25151: LD_VAR 0 3
25155: PPUSH
25156: CALL_OW 257
25160: PUSH
25161: LD_INT 4
25163: EQUAL
25164: IFFALSE 25168
// continue ;
25166: GO 25134
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25168: LD_ADDR_VAR 0 11
25172: PUSH
25173: LD_VAR 0 11
25177: PPUSH
25178: LD_VAR 0 11
25182: PUSH
25183: LD_INT 1
25185: PLUS
25186: PPUSH
25187: LD_VAR 0 9
25191: PUSH
25192: LD_VAR 0 3
25196: ARRAY
25197: PPUSH
25198: CALL_OW 2
25202: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25203: LD_ADDR_VAR 0 4
25207: PUSH
25208: LD_VAR 0 4
25212: PUSH
25213: LD_VAR 0 9
25217: PUSH
25218: LD_VAR 0 3
25222: ARRAY
25223: DIFF
25224: ST_TO_ADDR
// end ;
25225: GO 25134
25227: POP
25228: POP
// if p then
25229: LD_VAR 0 11
25233: IFFALSE 25258
// result := Replace ( result , 4 , p ) ;
25235: LD_ADDR_VAR 0 2
25239: PUSH
25240: LD_VAR 0 2
25244: PPUSH
25245: LD_INT 4
25247: PPUSH
25248: LD_VAR 0 11
25252: PPUSH
25253: CALL_OW 1
25257: ST_TO_ADDR
// end ; if tmp and mech < 6 then
25258: LD_VAR 0 4
25262: IFFALSE 25274
25264: PUSH
25265: LD_VAR 0 7
25269: PUSH
25270: LD_INT 6
25272: LESS
25273: AND
25274: IFFALSE 25462
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25276: LD_ADDR_VAR 0 9
25280: PUSH
25281: LD_VAR 0 4
25285: PUSH
25286: LD_VAR 0 8
25290: PUSH
25291: LD_VAR 0 7
25295: UNION
25296: DIFF
25297: PPUSH
25298: LD_INT 3
25300: PPUSH
25301: CALL 86435 0 2
25305: ST_TO_ADDR
// p := [ ] ;
25306: LD_ADDR_VAR 0 11
25310: PUSH
25311: EMPTY
25312: ST_TO_ADDR
// if sort then
25313: LD_VAR 0 9
25317: IFFALSE 25433
// for i = 1 to 6 - mech do
25319: LD_ADDR_VAR 0 3
25323: PUSH
25324: DOUBLE
25325: LD_INT 1
25327: DEC
25328: ST_TO_ADDR
25329: LD_INT 6
25331: PUSH
25332: LD_VAR 0 7
25336: MINUS
25337: PUSH
25338: FOR_TO
25339: IFFALSE 25431
// begin if i = sort then
25341: LD_VAR 0 3
25345: PUSH
25346: LD_VAR 0 9
25350: EQUAL
25351: IFFALSE 25355
// break ;
25353: GO 25431
// if GetClass ( i ) = 3 then
25355: LD_VAR 0 3
25359: PPUSH
25360: CALL_OW 257
25364: PUSH
25365: LD_INT 3
25367: EQUAL
25368: IFFALSE 25372
// continue ;
25370: GO 25338
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25372: LD_ADDR_VAR 0 11
25376: PUSH
25377: LD_VAR 0 11
25381: PPUSH
25382: LD_VAR 0 11
25386: PUSH
25387: LD_INT 1
25389: PLUS
25390: PPUSH
25391: LD_VAR 0 9
25395: PUSH
25396: LD_VAR 0 3
25400: ARRAY
25401: PPUSH
25402: CALL_OW 2
25406: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25407: LD_ADDR_VAR 0 4
25411: PUSH
25412: LD_VAR 0 4
25416: PUSH
25417: LD_VAR 0 9
25421: PUSH
25422: LD_VAR 0 3
25426: ARRAY
25427: DIFF
25428: ST_TO_ADDR
// end ;
25429: GO 25338
25431: POP
25432: POP
// if p then
25433: LD_VAR 0 11
25437: IFFALSE 25462
// result := Replace ( result , 3 , p ) ;
25439: LD_ADDR_VAR 0 2
25443: PUSH
25444: LD_VAR 0 2
25448: PPUSH
25449: LD_INT 3
25451: PPUSH
25452: LD_VAR 0 11
25456: PPUSH
25457: CALL_OW 1
25461: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25462: LD_VAR 0 4
25466: PUSH
25467: LD_INT 6
25469: GREATER
25470: IFFALSE 25482
25472: PUSH
25473: LD_VAR 0 6
25477: PUSH
25478: LD_INT 6
25480: LESS
25481: AND
25482: IFFALSE 25676
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25484: LD_ADDR_VAR 0 9
25488: PUSH
25489: LD_VAR 0 4
25493: PUSH
25494: LD_VAR 0 8
25498: PUSH
25499: LD_VAR 0 7
25503: UNION
25504: PUSH
25505: LD_VAR 0 6
25509: UNION
25510: DIFF
25511: PPUSH
25512: LD_INT 2
25514: PPUSH
25515: CALL 86435 0 2
25519: ST_TO_ADDR
// p := [ ] ;
25520: LD_ADDR_VAR 0 11
25524: PUSH
25525: EMPTY
25526: ST_TO_ADDR
// if sort then
25527: LD_VAR 0 9
25531: IFFALSE 25647
// for i = 1 to 6 - eng do
25533: LD_ADDR_VAR 0 3
25537: PUSH
25538: DOUBLE
25539: LD_INT 1
25541: DEC
25542: ST_TO_ADDR
25543: LD_INT 6
25545: PUSH
25546: LD_VAR 0 6
25550: MINUS
25551: PUSH
25552: FOR_TO
25553: IFFALSE 25645
// begin if i = sort then
25555: LD_VAR 0 3
25559: PUSH
25560: LD_VAR 0 9
25564: EQUAL
25565: IFFALSE 25569
// break ;
25567: GO 25645
// if GetClass ( i ) = 2 then
25569: LD_VAR 0 3
25573: PPUSH
25574: CALL_OW 257
25578: PUSH
25579: LD_INT 2
25581: EQUAL
25582: IFFALSE 25586
// continue ;
25584: GO 25552
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25586: LD_ADDR_VAR 0 11
25590: PUSH
25591: LD_VAR 0 11
25595: PPUSH
25596: LD_VAR 0 11
25600: PUSH
25601: LD_INT 1
25603: PLUS
25604: PPUSH
25605: LD_VAR 0 9
25609: PUSH
25610: LD_VAR 0 3
25614: ARRAY
25615: PPUSH
25616: CALL_OW 2
25620: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25621: LD_ADDR_VAR 0 4
25625: PUSH
25626: LD_VAR 0 4
25630: PUSH
25631: LD_VAR 0 9
25635: PUSH
25636: LD_VAR 0 3
25640: ARRAY
25641: DIFF
25642: ST_TO_ADDR
// end ;
25643: GO 25552
25645: POP
25646: POP
// if p then
25647: LD_VAR 0 11
25651: IFFALSE 25676
// result := Replace ( result , 2 , p ) ;
25653: LD_ADDR_VAR 0 2
25657: PUSH
25658: LD_VAR 0 2
25662: PPUSH
25663: LD_INT 2
25665: PPUSH
25666: LD_VAR 0 11
25670: PPUSH
25671: CALL_OW 1
25675: ST_TO_ADDR
// end ; exit ;
25676: GO 27084
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25678: LD_EXP 77
25682: PUSH
25683: LD_EXP 76
25687: PUSH
25688: LD_VAR 0 1
25692: ARRAY
25693: ARRAY
25694: NOT
25695: IFFALSE 25724
25697: PUSH
25698: LD_EXP 50
25702: PUSH
25703: LD_VAR 0 1
25707: ARRAY
25708: PPUSH
25709: LD_INT 30
25711: PUSH
25712: LD_INT 3
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PPUSH
25719: CALL_OW 72
25723: AND
25724: IFFALSE 25738
25726: PUSH
25727: LD_EXP 55
25731: PUSH
25732: LD_VAR 0 1
25736: ARRAY
25737: AND
25738: IFFALSE 26352
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25740: LD_ADDR_EXP 92
25744: PUSH
25745: LD_EXP 92
25749: PPUSH
25750: LD_VAR 0 1
25754: PPUSH
25755: LD_INT 5
25757: PPUSH
25758: CALL_OW 1
25762: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25763: LD_ADDR_VAR 0 2
25767: PUSH
25768: LD_INT 0
25770: PUSH
25771: LD_INT 0
25773: PUSH
25774: LD_INT 0
25776: PUSH
25777: LD_INT 0
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: LIST
25784: LIST
25785: ST_TO_ADDR
// if sci > 1 then
25786: LD_VAR 0 8
25790: PUSH
25791: LD_INT 1
25793: GREATER
25794: IFFALSE 25822
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25796: LD_ADDR_VAR 0 4
25800: PUSH
25801: LD_VAR 0 4
25805: PUSH
25806: LD_VAR 0 8
25810: PUSH
25811: LD_VAR 0 8
25815: PUSH
25816: LD_INT 1
25818: ARRAY
25819: DIFF
25820: DIFF
25821: ST_TO_ADDR
// if tmp and not sci then
25822: LD_VAR 0 4
25826: IFFALSE 25835
25828: PUSH
25829: LD_VAR 0 8
25833: NOT
25834: AND
25835: IFFALSE 25904
// begin sort := SortBySkill ( tmp , 4 ) ;
25837: LD_ADDR_VAR 0 9
25841: PUSH
25842: LD_VAR 0 4
25846: PPUSH
25847: LD_INT 4
25849: PPUSH
25850: CALL 86435 0 2
25854: ST_TO_ADDR
// if sort then
25855: LD_VAR 0 9
25859: IFFALSE 25875
// p := sort [ 1 ] ;
25861: LD_ADDR_VAR 0 11
25865: PUSH
25866: LD_VAR 0 9
25870: PUSH
25871: LD_INT 1
25873: ARRAY
25874: ST_TO_ADDR
// if p then
25875: LD_VAR 0 11
25879: IFFALSE 25904
// result := Replace ( result , 4 , p ) ;
25881: LD_ADDR_VAR 0 2
25885: PUSH
25886: LD_VAR 0 2
25890: PPUSH
25891: LD_INT 4
25893: PPUSH
25894: LD_VAR 0 11
25898: PPUSH
25899: CALL_OW 1
25903: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25904: LD_ADDR_VAR 0 4
25908: PUSH
25909: LD_VAR 0 4
25913: PUSH
25914: LD_VAR 0 7
25918: DIFF
25919: ST_TO_ADDR
// if tmp and mech < 6 then
25920: LD_VAR 0 4
25924: IFFALSE 25936
25926: PUSH
25927: LD_VAR 0 7
25931: PUSH
25932: LD_INT 6
25934: LESS
25935: AND
25936: IFFALSE 26124
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25938: LD_ADDR_VAR 0 9
25942: PUSH
25943: LD_VAR 0 4
25947: PUSH
25948: LD_VAR 0 8
25952: PUSH
25953: LD_VAR 0 7
25957: UNION
25958: DIFF
25959: PPUSH
25960: LD_INT 3
25962: PPUSH
25963: CALL 86435 0 2
25967: ST_TO_ADDR
// p := [ ] ;
25968: LD_ADDR_VAR 0 11
25972: PUSH
25973: EMPTY
25974: ST_TO_ADDR
// if sort then
25975: LD_VAR 0 9
25979: IFFALSE 26095
// for i = 1 to 6 - mech do
25981: LD_ADDR_VAR 0 3
25985: PUSH
25986: DOUBLE
25987: LD_INT 1
25989: DEC
25990: ST_TO_ADDR
25991: LD_INT 6
25993: PUSH
25994: LD_VAR 0 7
25998: MINUS
25999: PUSH
26000: FOR_TO
26001: IFFALSE 26093
// begin if i = sort then
26003: LD_VAR 0 3
26007: PUSH
26008: LD_VAR 0 9
26012: EQUAL
26013: IFFALSE 26017
// break ;
26015: GO 26093
// if GetClass ( i ) = 3 then
26017: LD_VAR 0 3
26021: PPUSH
26022: CALL_OW 257
26026: PUSH
26027: LD_INT 3
26029: EQUAL
26030: IFFALSE 26034
// continue ;
26032: GO 26000
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26034: LD_ADDR_VAR 0 11
26038: PUSH
26039: LD_VAR 0 11
26043: PPUSH
26044: LD_VAR 0 11
26048: PUSH
26049: LD_INT 1
26051: PLUS
26052: PPUSH
26053: LD_VAR 0 9
26057: PUSH
26058: LD_VAR 0 3
26062: ARRAY
26063: PPUSH
26064: CALL_OW 2
26068: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26069: LD_ADDR_VAR 0 4
26073: PUSH
26074: LD_VAR 0 4
26078: PUSH
26079: LD_VAR 0 9
26083: PUSH
26084: LD_VAR 0 3
26088: ARRAY
26089: DIFF
26090: ST_TO_ADDR
// end ;
26091: GO 26000
26093: POP
26094: POP
// if p then
26095: LD_VAR 0 11
26099: IFFALSE 26124
// result := Replace ( result , 3 , p ) ;
26101: LD_ADDR_VAR 0 2
26105: PUSH
26106: LD_VAR 0 2
26110: PPUSH
26111: LD_INT 3
26113: PPUSH
26114: LD_VAR 0 11
26118: PPUSH
26119: CALL_OW 1
26123: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26124: LD_ADDR_VAR 0 4
26128: PUSH
26129: LD_VAR 0 4
26133: PUSH
26134: LD_VAR 0 6
26138: DIFF
26139: ST_TO_ADDR
// if tmp and eng < 6 then
26140: LD_VAR 0 4
26144: IFFALSE 26156
26146: PUSH
26147: LD_VAR 0 6
26151: PUSH
26152: LD_INT 6
26154: LESS
26155: AND
26156: IFFALSE 26350
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26158: LD_ADDR_VAR 0 9
26162: PUSH
26163: LD_VAR 0 4
26167: PUSH
26168: LD_VAR 0 8
26172: PUSH
26173: LD_VAR 0 7
26177: UNION
26178: PUSH
26179: LD_VAR 0 6
26183: UNION
26184: DIFF
26185: PPUSH
26186: LD_INT 2
26188: PPUSH
26189: CALL 86435 0 2
26193: ST_TO_ADDR
// p := [ ] ;
26194: LD_ADDR_VAR 0 11
26198: PUSH
26199: EMPTY
26200: ST_TO_ADDR
// if sort then
26201: LD_VAR 0 9
26205: IFFALSE 26321
// for i = 1 to 6 - eng do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_INT 6
26219: PUSH
26220: LD_VAR 0 6
26224: MINUS
26225: PUSH
26226: FOR_TO
26227: IFFALSE 26319
// begin if i = sort then
26229: LD_VAR 0 3
26233: PUSH
26234: LD_VAR 0 9
26238: EQUAL
26239: IFFALSE 26243
// break ;
26241: GO 26319
// if GetClass ( i ) = 2 then
26243: LD_VAR 0 3
26247: PPUSH
26248: CALL_OW 257
26252: PUSH
26253: LD_INT 2
26255: EQUAL
26256: IFFALSE 26260
// continue ;
26258: GO 26226
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26260: LD_ADDR_VAR 0 11
26264: PUSH
26265: LD_VAR 0 11
26269: PPUSH
26270: LD_VAR 0 11
26274: PUSH
26275: LD_INT 1
26277: PLUS
26278: PPUSH
26279: LD_VAR 0 9
26283: PUSH
26284: LD_VAR 0 3
26288: ARRAY
26289: PPUSH
26290: CALL_OW 2
26294: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26295: LD_ADDR_VAR 0 4
26299: PUSH
26300: LD_VAR 0 4
26304: PUSH
26305: LD_VAR 0 9
26309: PUSH
26310: LD_VAR 0 3
26314: ARRAY
26315: DIFF
26316: ST_TO_ADDR
// end ;
26317: GO 26226
26319: POP
26320: POP
// if p then
26321: LD_VAR 0 11
26325: IFFALSE 26350
// result := Replace ( result , 2 , p ) ;
26327: LD_ADDR_VAR 0 2
26331: PUSH
26332: LD_VAR 0 2
26336: PPUSH
26337: LD_INT 2
26339: PPUSH
26340: LD_VAR 0 11
26344: PPUSH
26345: CALL_OW 1
26349: ST_TO_ADDR
// end ; exit ;
26350: GO 27084
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26352: LD_EXP 77
26356: PUSH
26357: LD_EXP 76
26361: PUSH
26362: LD_VAR 0 1
26366: ARRAY
26367: ARRAY
26368: NOT
26369: IFFALSE 26398
26371: PUSH
26372: LD_EXP 50
26376: PUSH
26377: LD_VAR 0 1
26381: ARRAY
26382: PPUSH
26383: LD_INT 30
26385: PUSH
26386: LD_INT 3
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PPUSH
26393: CALL_OW 72
26397: AND
26398: IFFALSE 26413
26400: PUSH
26401: LD_EXP 55
26405: PUSH
26406: LD_VAR 0 1
26410: ARRAY
26411: NOT
26412: AND
26413: IFFALSE 27084
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26415: LD_ADDR_EXP 92
26419: PUSH
26420: LD_EXP 92
26424: PPUSH
26425: LD_VAR 0 1
26429: PPUSH
26430: LD_INT 6
26432: PPUSH
26433: CALL_OW 1
26437: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26438: LD_ADDR_VAR 0 2
26442: PUSH
26443: LD_INT 0
26445: PUSH
26446: LD_INT 0
26448: PUSH
26449: LD_INT 0
26451: PUSH
26452: LD_INT 0
26454: PUSH
26455: EMPTY
26456: LIST
26457: LIST
26458: LIST
26459: LIST
26460: ST_TO_ADDR
// if sci >= 1 then
26461: LD_VAR 0 8
26465: PUSH
26466: LD_INT 1
26468: GREATEREQUAL
26469: IFFALSE 26491
// tmp := tmp diff sci [ 1 ] ;
26471: LD_ADDR_VAR 0 4
26475: PUSH
26476: LD_VAR 0 4
26480: PUSH
26481: LD_VAR 0 8
26485: PUSH
26486: LD_INT 1
26488: ARRAY
26489: DIFF
26490: ST_TO_ADDR
// if tmp and not sci then
26491: LD_VAR 0 4
26495: IFFALSE 26504
26497: PUSH
26498: LD_VAR 0 8
26502: NOT
26503: AND
26504: IFFALSE 26573
// begin sort := SortBySkill ( tmp , 4 ) ;
26506: LD_ADDR_VAR 0 9
26510: PUSH
26511: LD_VAR 0 4
26515: PPUSH
26516: LD_INT 4
26518: PPUSH
26519: CALL 86435 0 2
26523: ST_TO_ADDR
// if sort then
26524: LD_VAR 0 9
26528: IFFALSE 26544
// p := sort [ 1 ] ;
26530: LD_ADDR_VAR 0 11
26534: PUSH
26535: LD_VAR 0 9
26539: PUSH
26540: LD_INT 1
26542: ARRAY
26543: ST_TO_ADDR
// if p then
26544: LD_VAR 0 11
26548: IFFALSE 26573
// result := Replace ( result , 4 , p ) ;
26550: LD_ADDR_VAR 0 2
26554: PUSH
26555: LD_VAR 0 2
26559: PPUSH
26560: LD_INT 4
26562: PPUSH
26563: LD_VAR 0 11
26567: PPUSH
26568: CALL_OW 1
26572: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26573: LD_ADDR_VAR 0 4
26577: PUSH
26578: LD_VAR 0 4
26582: PUSH
26583: LD_VAR 0 7
26587: DIFF
26588: ST_TO_ADDR
// if tmp and mech < 6 then
26589: LD_VAR 0 4
26593: IFFALSE 26605
26595: PUSH
26596: LD_VAR 0 7
26600: PUSH
26601: LD_INT 6
26603: LESS
26604: AND
26605: IFFALSE 26787
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26607: LD_ADDR_VAR 0 9
26611: PUSH
26612: LD_VAR 0 4
26616: PUSH
26617: LD_VAR 0 7
26621: DIFF
26622: PPUSH
26623: LD_INT 3
26625: PPUSH
26626: CALL 86435 0 2
26630: ST_TO_ADDR
// p := [ ] ;
26631: LD_ADDR_VAR 0 11
26635: PUSH
26636: EMPTY
26637: ST_TO_ADDR
// if sort then
26638: LD_VAR 0 9
26642: IFFALSE 26758
// for i = 1 to 6 - mech do
26644: LD_ADDR_VAR 0 3
26648: PUSH
26649: DOUBLE
26650: LD_INT 1
26652: DEC
26653: ST_TO_ADDR
26654: LD_INT 6
26656: PUSH
26657: LD_VAR 0 7
26661: MINUS
26662: PUSH
26663: FOR_TO
26664: IFFALSE 26756
// begin if i = sort then
26666: LD_VAR 0 3
26670: PUSH
26671: LD_VAR 0 9
26675: EQUAL
26676: IFFALSE 26680
// break ;
26678: GO 26756
// if GetClass ( i ) = 3 then
26680: LD_VAR 0 3
26684: PPUSH
26685: CALL_OW 257
26689: PUSH
26690: LD_INT 3
26692: EQUAL
26693: IFFALSE 26697
// continue ;
26695: GO 26663
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26697: LD_ADDR_VAR 0 11
26701: PUSH
26702: LD_VAR 0 11
26706: PPUSH
26707: LD_VAR 0 11
26711: PUSH
26712: LD_INT 1
26714: PLUS
26715: PPUSH
26716: LD_VAR 0 9
26720: PUSH
26721: LD_VAR 0 3
26725: ARRAY
26726: PPUSH
26727: CALL_OW 2
26731: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26732: LD_ADDR_VAR 0 4
26736: PUSH
26737: LD_VAR 0 4
26741: PUSH
26742: LD_VAR 0 9
26746: PUSH
26747: LD_VAR 0 3
26751: ARRAY
26752: DIFF
26753: ST_TO_ADDR
// end ;
26754: GO 26663
26756: POP
26757: POP
// if p then
26758: LD_VAR 0 11
26762: IFFALSE 26787
// result := Replace ( result , 3 , p ) ;
26764: LD_ADDR_VAR 0 2
26768: PUSH
26769: LD_VAR 0 2
26773: PPUSH
26774: LD_INT 3
26776: PPUSH
26777: LD_VAR 0 11
26781: PPUSH
26782: CALL_OW 1
26786: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26787: LD_ADDR_VAR 0 4
26791: PUSH
26792: LD_VAR 0 4
26796: PUSH
26797: LD_VAR 0 6
26801: DIFF
26802: ST_TO_ADDR
// if tmp and eng < 4 then
26803: LD_VAR 0 4
26807: IFFALSE 26819
26809: PUSH
26810: LD_VAR 0 6
26814: PUSH
26815: LD_INT 4
26817: LESS
26818: AND
26819: IFFALSE 27009
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26821: LD_ADDR_VAR 0 9
26825: PUSH
26826: LD_VAR 0 4
26830: PUSH
26831: LD_VAR 0 7
26835: PUSH
26836: LD_VAR 0 6
26840: UNION
26841: DIFF
26842: PPUSH
26843: LD_INT 2
26845: PPUSH
26846: CALL 86435 0 2
26850: ST_TO_ADDR
// p := [ ] ;
26851: LD_ADDR_VAR 0 11
26855: PUSH
26856: EMPTY
26857: ST_TO_ADDR
// if sort then
26858: LD_VAR 0 9
26862: IFFALSE 26978
// for i = 1 to 4 - eng do
26864: LD_ADDR_VAR 0 3
26868: PUSH
26869: DOUBLE
26870: LD_INT 1
26872: DEC
26873: ST_TO_ADDR
26874: LD_INT 4
26876: PUSH
26877: LD_VAR 0 6
26881: MINUS
26882: PUSH
26883: FOR_TO
26884: IFFALSE 26976
// begin if i = sort then
26886: LD_VAR 0 3
26890: PUSH
26891: LD_VAR 0 9
26895: EQUAL
26896: IFFALSE 26900
// break ;
26898: GO 26976
// if GetClass ( i ) = 2 then
26900: LD_VAR 0 3
26904: PPUSH
26905: CALL_OW 257
26909: PUSH
26910: LD_INT 2
26912: EQUAL
26913: IFFALSE 26917
// continue ;
26915: GO 26883
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26917: LD_ADDR_VAR 0 11
26921: PUSH
26922: LD_VAR 0 11
26926: PPUSH
26927: LD_VAR 0 11
26931: PUSH
26932: LD_INT 1
26934: PLUS
26935: PPUSH
26936: LD_VAR 0 9
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 2
26951: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: LD_VAR 0 4
26961: PUSH
26962: LD_VAR 0 9
26966: PUSH
26967: LD_VAR 0 3
26971: ARRAY
26972: DIFF
26973: ST_TO_ADDR
// end ;
26974: GO 26883
26976: POP
26977: POP
// if p then
26978: LD_VAR 0 11
26982: IFFALSE 27007
// result := Replace ( result , 2 , p ) ;
26984: LD_ADDR_VAR 0 2
26988: PUSH
26989: LD_VAR 0 2
26993: PPUSH
26994: LD_INT 2
26996: PPUSH
26997: LD_VAR 0 11
27001: PPUSH
27002: CALL_OW 1
27006: ST_TO_ADDR
// end else
27007: GO 27053
// for i = eng downto 5 do
27009: LD_ADDR_VAR 0 3
27013: PUSH
27014: DOUBLE
27015: LD_VAR 0 6
27019: INC
27020: ST_TO_ADDR
27021: LD_INT 5
27023: PUSH
27024: FOR_DOWNTO
27025: IFFALSE 27051
// tmp := tmp union eng [ i ] ;
27027: LD_ADDR_VAR 0 4
27031: PUSH
27032: LD_VAR 0 4
27036: PUSH
27037: LD_VAR 0 6
27041: PUSH
27042: LD_VAR 0 3
27046: ARRAY
27047: UNION
27048: ST_TO_ADDR
27049: GO 27024
27051: POP
27052: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
27053: LD_ADDR_VAR 0 2
27057: PUSH
27058: LD_VAR 0 2
27062: PPUSH
27063: LD_INT 1
27065: PPUSH
27066: LD_VAR 0 4
27070: PUSH
27071: LD_VAR 0 5
27075: DIFF
27076: PPUSH
27077: CALL_OW 1
27081: ST_TO_ADDR
// exit ;
27082: GO 27084
// end ; end ;
27084: LD_VAR 0 2
27088: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
27089: LD_INT 0
27091: PPUSH
27092: PPUSH
27093: PPUSH
// if not mc_bases then
27094: LD_EXP 50
27098: NOT
27099: IFFALSE 27103
// exit ;
27101: GO 27245
// for i = 1 to mc_bases do
27103: LD_ADDR_VAR 0 2
27107: PUSH
27108: DOUBLE
27109: LD_INT 1
27111: DEC
27112: ST_TO_ADDR
27113: LD_EXP 50
27117: PUSH
27118: FOR_TO
27119: IFFALSE 27236
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
27121: LD_ADDR_VAR 0 3
27125: PUSH
27126: LD_EXP 50
27130: PUSH
27131: LD_VAR 0 2
27135: ARRAY
27136: PPUSH
27137: LD_INT 21
27139: PUSH
27140: LD_INT 3
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PUSH
27147: LD_INT 3
27149: PUSH
27150: LD_INT 2
27152: PUSH
27153: LD_INT 30
27155: PUSH
27156: LD_INT 29
27158: PUSH
27159: EMPTY
27160: LIST
27161: LIST
27162: PUSH
27163: LD_INT 30
27165: PUSH
27166: LD_INT 30
27168: PUSH
27169: EMPTY
27170: LIST
27171: LIST
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: LIST
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PUSH
27182: LD_INT 3
27184: PUSH
27185: LD_INT 24
27187: PUSH
27188: LD_INT 1000
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: PUSH
27199: EMPTY
27200: LIST
27201: LIST
27202: LIST
27203: PPUSH
27204: CALL_OW 72
27208: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
27209: LD_ADDR_EXP 51
27213: PUSH
27214: LD_EXP 51
27218: PPUSH
27219: LD_VAR 0 2
27223: PPUSH
27224: LD_VAR 0 3
27228: PPUSH
27229: CALL_OW 1
27233: ST_TO_ADDR
// end ;
27234: GO 27118
27236: POP
27237: POP
// RaiseSailEvent ( 101 ) ;
27238: LD_INT 101
27240: PPUSH
27241: CALL_OW 427
// end ;
27245: LD_VAR 0 1
27249: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
27250: LD_INT 0
27252: PPUSH
27253: PPUSH
27254: PPUSH
27255: PPUSH
27256: PPUSH
27257: PPUSH
27258: PPUSH
// if not mc_bases then
27259: LD_EXP 50
27263: NOT
27264: IFFALSE 27268
// exit ;
27266: GO 27832
// for i = 1 to mc_bases do
27268: LD_ADDR_VAR 0 2
27272: PUSH
27273: DOUBLE
27274: LD_INT 1
27276: DEC
27277: ST_TO_ADDR
27278: LD_EXP 50
27282: PUSH
27283: FOR_TO
27284: IFFALSE 27823
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
27286: LD_ADDR_VAR 0 5
27290: PUSH
27291: LD_EXP 50
27295: PUSH
27296: LD_VAR 0 2
27300: ARRAY
27301: PUSH
27302: LD_EXP 79
27306: PUSH
27307: LD_VAR 0 2
27311: ARRAY
27312: UNION
27313: PPUSH
27314: LD_INT 21
27316: PUSH
27317: LD_INT 1
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: PUSH
27327: LD_INT 3
27329: PUSH
27330: LD_INT 54
27332: PUSH
27333: EMPTY
27334: LIST
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 3
27342: PUSH
27343: LD_INT 24
27345: PUSH
27346: LD_INT 1000
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PUSH
27353: EMPTY
27354: LIST
27355: LIST
27356: PUSH
27357: EMPTY
27358: LIST
27359: LIST
27360: LIST
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PPUSH
27366: CALL_OW 72
27370: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27371: LD_ADDR_VAR 0 6
27375: PUSH
27376: LD_EXP 50
27380: PUSH
27381: LD_VAR 0 2
27385: ARRAY
27386: PPUSH
27387: LD_INT 21
27389: PUSH
27390: LD_INT 1
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PUSH
27397: LD_INT 1
27399: PUSH
27400: LD_INT 3
27402: PUSH
27403: LD_INT 54
27405: PUSH
27406: EMPTY
27407: LIST
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: PUSH
27413: LD_INT 3
27415: PUSH
27416: LD_INT 24
27418: PUSH
27419: LD_INT 250
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: LIST
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PPUSH
27439: CALL_OW 72
27443: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27444: LD_ADDR_VAR 0 7
27448: PUSH
27449: LD_VAR 0 5
27453: PUSH
27454: LD_VAR 0 6
27458: DIFF
27459: ST_TO_ADDR
// if not need_heal_1 then
27460: LD_VAR 0 6
27464: NOT
27465: IFFALSE 27498
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27467: LD_ADDR_EXP 53
27471: PUSH
27472: LD_EXP 53
27476: PPUSH
27477: LD_VAR 0 2
27481: PUSH
27482: LD_INT 1
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PPUSH
27489: EMPTY
27490: PPUSH
27491: CALL 54897 0 3
27495: ST_TO_ADDR
27496: GO 27568
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27498: LD_ADDR_EXP 53
27502: PUSH
27503: LD_EXP 53
27507: PPUSH
27508: LD_VAR 0 2
27512: PUSH
27513: LD_INT 1
27515: PUSH
27516: EMPTY
27517: LIST
27518: LIST
27519: PPUSH
27520: LD_EXP 53
27524: PUSH
27525: LD_VAR 0 2
27529: ARRAY
27530: PUSH
27531: LD_INT 1
27533: ARRAY
27534: PPUSH
27535: LD_INT 3
27537: PUSH
27538: LD_INT 24
27540: PUSH
27541: LD_INT 1000
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: PPUSH
27552: CALL_OW 72
27556: PUSH
27557: LD_VAR 0 6
27561: UNION
27562: PPUSH
27563: CALL 54897 0 3
27567: ST_TO_ADDR
// if not need_heal_2 then
27568: LD_VAR 0 7
27572: NOT
27573: IFFALSE 27606
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27575: LD_ADDR_EXP 53
27579: PUSH
27580: LD_EXP 53
27584: PPUSH
27585: LD_VAR 0 2
27589: PUSH
27590: LD_INT 2
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PPUSH
27597: EMPTY
27598: PPUSH
27599: CALL 54897 0 3
27603: ST_TO_ADDR
27604: GO 27638
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27606: LD_ADDR_EXP 53
27610: PUSH
27611: LD_EXP 53
27615: PPUSH
27616: LD_VAR 0 2
27620: PUSH
27621: LD_INT 2
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PPUSH
27628: LD_VAR 0 7
27632: PPUSH
27633: CALL 54897 0 3
27637: ST_TO_ADDR
// if need_heal_2 then
27638: LD_VAR 0 7
27642: IFFALSE 27803
// for j in need_heal_2 do
27644: LD_ADDR_VAR 0 3
27648: PUSH
27649: LD_VAR 0 7
27653: PUSH
27654: FOR_IN
27655: IFFALSE 27801
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27657: LD_ADDR_VAR 0 5
27661: PUSH
27662: LD_EXP 50
27666: PUSH
27667: LD_VAR 0 2
27671: ARRAY
27672: PPUSH
27673: LD_INT 2
27675: PUSH
27676: LD_INT 30
27678: PUSH
27679: LD_INT 6
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 30
27688: PUSH
27689: LD_INT 7
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: LD_INT 30
27698: PUSH
27699: LD_INT 8
27701: PUSH
27702: EMPTY
27703: LIST
27704: LIST
27705: PUSH
27706: LD_INT 30
27708: PUSH
27709: LD_INT 0
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: PUSH
27716: LD_INT 30
27718: PUSH
27719: LD_INT 1
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: LIST
27730: LIST
27731: LIST
27732: LIST
27733: PPUSH
27734: CALL_OW 72
27738: ST_TO_ADDR
// if tmp then
27739: LD_VAR 0 5
27743: IFFALSE 27799
// begin k := NearestUnitToUnit ( tmp , j ) ;
27745: LD_ADDR_VAR 0 4
27749: PUSH
27750: LD_VAR 0 5
27754: PPUSH
27755: LD_VAR 0 3
27759: PPUSH
27760: CALL_OW 74
27764: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27765: LD_VAR 0 3
27769: PPUSH
27770: LD_VAR 0 4
27774: PPUSH
27775: CALL_OW 296
27779: PUSH
27780: LD_INT 5
27782: GREATER
27783: IFFALSE 27799
// ComMoveToNearbyEntrance ( j , k ) ;
27785: LD_VAR 0 3
27789: PPUSH
27790: LD_VAR 0 4
27794: PPUSH
27795: CALL 88834 0 2
// end ; end ;
27799: GO 27654
27801: POP
27802: POP
// if not need_heal_1 and not need_heal_2 then
27803: LD_VAR 0 6
27807: NOT
27808: IFFALSE 27817
27810: PUSH
27811: LD_VAR 0 7
27815: NOT
27816: AND
27817: IFFALSE 27821
// continue ;
27819: GO 27283
// end ;
27821: GO 27283
27823: POP
27824: POP
// RaiseSailEvent ( 102 ) ;
27825: LD_INT 102
27827: PPUSH
27828: CALL_OW 427
// end ;
27832: LD_VAR 0 1
27836: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27837: LD_INT 0
27839: PPUSH
27840: PPUSH
27841: PPUSH
27842: PPUSH
27843: PPUSH
27844: PPUSH
27845: PPUSH
27846: PPUSH
// if not mc_bases then
27847: LD_EXP 50
27851: NOT
27852: IFFALSE 27856
// exit ;
27854: GO 28771
// for i = 1 to mc_bases do
27856: LD_ADDR_VAR 0 2
27860: PUSH
27861: DOUBLE
27862: LD_INT 1
27864: DEC
27865: ST_TO_ADDR
27866: LD_EXP 50
27870: PUSH
27871: FOR_TO
27872: IFFALSE 28769
// begin if not mc_building_need_repair [ i ] then
27874: LD_EXP 51
27878: PUSH
27879: LD_VAR 0 2
27883: ARRAY
27884: NOT
27885: IFFALSE 28070
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27887: LD_ADDR_VAR 0 6
27891: PUSH
27892: LD_EXP 69
27896: PUSH
27897: LD_VAR 0 2
27901: ARRAY
27902: PPUSH
27903: LD_INT 3
27905: PUSH
27906: LD_INT 24
27908: PUSH
27909: LD_INT 1000
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: EMPTY
27917: LIST
27918: LIST
27919: PUSH
27920: LD_INT 2
27922: PUSH
27923: LD_INT 34
27925: PUSH
27926: LD_INT 13
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: LD_INT 34
27935: PUSH
27936: LD_INT 52
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: LD_INT 34
27945: PUSH
27946: LD_INT 88
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: EMPTY
27954: LIST
27955: LIST
27956: LIST
27957: LIST
27958: PUSH
27959: EMPTY
27960: LIST
27961: LIST
27962: PPUSH
27963: CALL_OW 72
27967: ST_TO_ADDR
// if cranes then
27968: LD_VAR 0 6
27972: IFFALSE 28034
// for j in cranes do
27974: LD_ADDR_VAR 0 3
27978: PUSH
27979: LD_VAR 0 6
27983: PUSH
27984: FOR_IN
27985: IFFALSE 28032
// if not IsInArea ( j , mc_parking [ i ] ) then
27987: LD_VAR 0 3
27991: PPUSH
27992: LD_EXP 74
27996: PUSH
27997: LD_VAR 0 2
28001: ARRAY
28002: PPUSH
28003: CALL_OW 308
28007: NOT
28008: IFFALSE 28030
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28010: LD_VAR 0 3
28014: PPUSH
28015: LD_EXP 74
28019: PUSH
28020: LD_VAR 0 2
28024: ARRAY
28025: PPUSH
28026: CALL_OW 113
28030: GO 27984
28032: POP
28033: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
28034: LD_ADDR_EXP 52
28038: PUSH
28039: LD_EXP 52
28043: PPUSH
28044: LD_VAR 0 2
28048: PPUSH
28049: EMPTY
28050: PPUSH
28051: CALL_OW 1
28055: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
28056: LD_VAR 0 2
28060: PPUSH
28061: LD_INT 101
28063: PPUSH
28064: CALL 22862 0 2
// continue ;
28068: GO 27871
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
28070: LD_ADDR_EXP 56
28074: PUSH
28075: LD_EXP 56
28079: PPUSH
28080: LD_VAR 0 2
28084: PPUSH
28085: EMPTY
28086: PPUSH
28087: CALL_OW 1
28091: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28092: LD_VAR 0 2
28096: PPUSH
28097: LD_INT 103
28099: PPUSH
28100: CALL 22862 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
28104: LD_ADDR_VAR 0 5
28108: PUSH
28109: LD_EXP 50
28113: PUSH
28114: LD_VAR 0 2
28118: ARRAY
28119: PUSH
28120: LD_EXP 79
28124: PUSH
28125: LD_VAR 0 2
28129: ARRAY
28130: UNION
28131: PPUSH
28132: LD_INT 2
28134: PUSH
28135: LD_INT 25
28137: PUSH
28138: LD_INT 2
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 25
28147: PUSH
28148: LD_INT 16
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: LIST
28159: PUSH
28160: EMPTY
28161: LIST
28162: PPUSH
28163: CALL_OW 72
28167: ST_TO_ADDR
// if mc_need_heal [ i ] then
28168: LD_EXP 53
28172: PUSH
28173: LD_VAR 0 2
28177: ARRAY
28178: IFFALSE 28222
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
28180: LD_ADDR_VAR 0 5
28184: PUSH
28185: LD_VAR 0 5
28189: PUSH
28190: LD_EXP 53
28194: PUSH
28195: LD_VAR 0 2
28199: ARRAY
28200: PUSH
28201: LD_INT 1
28203: ARRAY
28204: PUSH
28205: LD_EXP 53
28209: PUSH
28210: LD_VAR 0 2
28214: ARRAY
28215: PUSH
28216: LD_INT 2
28218: ARRAY
28219: UNION
28220: DIFF
28221: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
28222: LD_ADDR_VAR 0 6
28226: PUSH
28227: LD_EXP 69
28231: PUSH
28232: LD_VAR 0 2
28236: ARRAY
28237: PPUSH
28238: LD_INT 2
28240: PUSH
28241: LD_INT 34
28243: PUSH
28244: LD_INT 13
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 34
28253: PUSH
28254: LD_INT 52
28256: PUSH
28257: EMPTY
28258: LIST
28259: LIST
28260: PUSH
28261: LD_INT 34
28263: PUSH
28264: LD_INT 88
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: LIST
28275: LIST
28276: PPUSH
28277: CALL_OW 72
28281: ST_TO_ADDR
// if cranes then
28282: LD_VAR 0 6
28286: IFFALSE 28458
// begin for j in cranes do
28288: LD_ADDR_VAR 0 3
28292: PUSH
28293: LD_VAR 0 6
28297: PUSH
28298: FOR_IN
28299: IFFALSE 28456
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
28301: LD_VAR 0 3
28305: PPUSH
28306: CALL_OW 256
28310: PUSH
28311: LD_INT 1000
28313: EQUAL
28314: IFFALSE 28328
28316: PUSH
28317: LD_VAR 0 3
28321: PPUSH
28322: CALL_OW 314
28326: NOT
28327: AND
28328: IFFALSE 28394
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
28330: LD_ADDR_VAR 0 8
28334: PUSH
28335: LD_EXP 51
28339: PUSH
28340: LD_VAR 0 2
28344: ARRAY
28345: PPUSH
28346: LD_VAR 0 3
28350: PPUSH
28351: CALL_OW 74
28355: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28356: LD_VAR 0 8
28360: PPUSH
28361: LD_INT 16
28363: PPUSH
28364: CALL 57876 0 2
28368: PUSH
28369: LD_INT 4
28371: ARRAY
28372: PUSH
28373: LD_INT 10
28375: LESS
28376: IFFALSE 28392
// ComRepairBuilding ( j , to_repair ) ;
28378: LD_VAR 0 3
28382: PPUSH
28383: LD_VAR 0 8
28387: PPUSH
28388: CALL_OW 130
// end else
28392: GO 28454
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28394: LD_VAR 0 3
28398: PPUSH
28399: CALL_OW 256
28403: PUSH
28404: LD_INT 500
28406: LESS
28407: IFFALSE 28432
28409: PUSH
28410: LD_VAR 0 3
28414: PPUSH
28415: LD_EXP 74
28419: PUSH
28420: LD_VAR 0 2
28424: ARRAY
28425: PPUSH
28426: CALL_OW 308
28430: NOT
28431: AND
28432: IFFALSE 28454
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28434: LD_VAR 0 3
28438: PPUSH
28439: LD_EXP 74
28443: PUSH
28444: LD_VAR 0 2
28448: ARRAY
28449: PPUSH
28450: CALL_OW 113
// end ;
28454: GO 28298
28456: POP
28457: POP
// end ; if tmp > 3 then
28458: LD_VAR 0 5
28462: PUSH
28463: LD_INT 3
28465: GREATER
28466: IFFALSE 28486
// tmp := ShrinkArray ( tmp , 4 ) ;
28468: LD_ADDR_VAR 0 5
28472: PUSH
28473: LD_VAR 0 5
28477: PPUSH
28478: LD_INT 4
28480: PPUSH
28481: CALL 88270 0 2
28485: ST_TO_ADDR
// if not tmp then
28486: LD_VAR 0 5
28490: NOT
28491: IFFALSE 28495
// continue ;
28493: GO 27871
// for j in tmp do
28495: LD_ADDR_VAR 0 3
28499: PUSH
28500: LD_VAR 0 5
28504: PUSH
28505: FOR_IN
28506: IFFALSE 28765
// begin if IsInUnit ( j ) then
28508: LD_VAR 0 3
28512: PPUSH
28513: CALL_OW 310
28517: IFFALSE 28528
// ComExitBuilding ( j ) ;
28519: LD_VAR 0 3
28523: PPUSH
28524: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28528: LD_VAR 0 3
28532: PUSH
28533: LD_EXP 52
28537: PUSH
28538: LD_VAR 0 2
28542: ARRAY
28543: IN
28544: NOT
28545: IFFALSE 28603
// begin SetTag ( j , 101 ) ;
28547: LD_VAR 0 3
28551: PPUSH
28552: LD_INT 101
28554: PPUSH
28555: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28559: LD_ADDR_EXP 52
28563: PUSH
28564: LD_EXP 52
28568: PPUSH
28569: LD_VAR 0 2
28573: PUSH
28574: LD_EXP 52
28578: PUSH
28579: LD_VAR 0 2
28583: ARRAY
28584: PUSH
28585: LD_INT 1
28587: PLUS
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PPUSH
28593: LD_VAR 0 3
28597: PPUSH
28598: CALL 54897 0 3
28602: ST_TO_ADDR
// end ; wait ( 1 ) ;
28603: LD_INT 1
28605: PPUSH
28606: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28610: LD_ADDR_VAR 0 7
28614: PUSH
28615: LD_EXP 51
28619: PUSH
28620: LD_VAR 0 2
28624: ARRAY
28625: ST_TO_ADDR
// if mc_scan [ i ] then
28626: LD_EXP 73
28630: PUSH
28631: LD_VAR 0 2
28635: ARRAY
28636: IFFALSE 28698
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28638: LD_ADDR_VAR 0 7
28642: PUSH
28643: LD_EXP 51
28647: PUSH
28648: LD_VAR 0 2
28652: ARRAY
28653: PPUSH
28654: LD_INT 3
28656: PUSH
28657: LD_INT 30
28659: PUSH
28660: LD_INT 32
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: PUSH
28667: LD_INT 30
28669: PUSH
28670: LD_INT 33
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 30
28679: PUSH
28680: LD_INT 31
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: LIST
28691: LIST
28692: PPUSH
28693: CALL_OW 72
28697: ST_TO_ADDR
// if not to_repair_tmp then
28698: LD_VAR 0 7
28702: NOT
28703: IFFALSE 28707
// continue ;
28705: GO 28505
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28707: LD_ADDR_VAR 0 8
28711: PUSH
28712: LD_VAR 0 7
28716: PPUSH
28717: LD_VAR 0 3
28721: PPUSH
28722: CALL_OW 74
28726: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28727: LD_VAR 0 8
28731: PPUSH
28732: LD_INT 16
28734: PPUSH
28735: CALL 57876 0 2
28739: PUSH
28740: LD_INT 4
28742: ARRAY
28743: PUSH
28744: LD_INT 14
28746: LESS
28747: IFFALSE 28763
// ComRepairBuilding ( j , to_repair ) ;
28749: LD_VAR 0 3
28753: PPUSH
28754: LD_VAR 0 8
28758: PPUSH
28759: CALL_OW 130
// end ;
28763: GO 28505
28765: POP
28766: POP
// end ;
28767: GO 27871
28769: POP
28770: POP
// end ;
28771: LD_VAR 0 1
28775: RET
// export function MC_Heal ; var i , j , tmp ; begin
28776: LD_INT 0
28778: PPUSH
28779: PPUSH
28780: PPUSH
28781: PPUSH
// if not mc_bases then
28782: LD_EXP 50
28786: NOT
28787: IFFALSE 28791
// exit ;
28789: GO 29197
// for i = 1 to mc_bases do
28791: LD_ADDR_VAR 0 2
28795: PUSH
28796: DOUBLE
28797: LD_INT 1
28799: DEC
28800: ST_TO_ADDR
28801: LD_EXP 50
28805: PUSH
28806: FOR_TO
28807: IFFALSE 29195
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28809: LD_EXP 53
28813: PUSH
28814: LD_VAR 0 2
28818: ARRAY
28819: PUSH
28820: LD_INT 1
28822: ARRAY
28823: NOT
28824: IFFALSE 28843
28826: PUSH
28827: LD_EXP 53
28831: PUSH
28832: LD_VAR 0 2
28836: ARRAY
28837: PUSH
28838: LD_INT 2
28840: ARRAY
28841: NOT
28842: AND
28843: IFFALSE 28881
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28845: LD_ADDR_EXP 54
28849: PUSH
28850: LD_EXP 54
28854: PPUSH
28855: LD_VAR 0 2
28859: PPUSH
28860: EMPTY
28861: PPUSH
28862: CALL_OW 1
28866: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28867: LD_VAR 0 2
28871: PPUSH
28872: LD_INT 102
28874: PPUSH
28875: CALL 22862 0 2
// continue ;
28879: GO 28806
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28881: LD_ADDR_VAR 0 4
28885: PUSH
28886: LD_EXP 50
28890: PUSH
28891: LD_VAR 0 2
28895: ARRAY
28896: PPUSH
28897: LD_INT 25
28899: PUSH
28900: LD_INT 4
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: PPUSH
28907: CALL_OW 72
28911: ST_TO_ADDR
// if not tmp then
28912: LD_VAR 0 4
28916: NOT
28917: IFFALSE 28921
// continue ;
28919: GO 28806
// if mc_taming [ i ] then
28921: LD_EXP 81
28925: PUSH
28926: LD_VAR 0 2
28930: ARRAY
28931: IFFALSE 28955
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28933: LD_ADDR_EXP 81
28937: PUSH
28938: LD_EXP 81
28942: PPUSH
28943: LD_VAR 0 2
28947: PPUSH
28948: EMPTY
28949: PPUSH
28950: CALL_OW 1
28954: ST_TO_ADDR
// for j in tmp do
28955: LD_ADDR_VAR 0 3
28959: PUSH
28960: LD_VAR 0 4
28964: PUSH
28965: FOR_IN
28966: IFFALSE 29191
// begin if IsInUnit ( j ) then
28968: LD_VAR 0 3
28972: PPUSH
28973: CALL_OW 310
28977: IFFALSE 28988
// ComExitBuilding ( j ) ;
28979: LD_VAR 0 3
28983: PPUSH
28984: CALL_OW 122
// if not j in mc_healers [ i ] then
28988: LD_VAR 0 3
28992: PUSH
28993: LD_EXP 54
28997: PUSH
28998: LD_VAR 0 2
29002: ARRAY
29003: IN
29004: NOT
29005: IFFALSE 29051
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
29007: LD_ADDR_EXP 54
29011: PUSH
29012: LD_EXP 54
29016: PPUSH
29017: LD_VAR 0 2
29021: PUSH
29022: LD_EXP 54
29026: PUSH
29027: LD_VAR 0 2
29031: ARRAY
29032: PUSH
29033: LD_INT 1
29035: PLUS
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PPUSH
29041: LD_VAR 0 3
29045: PPUSH
29046: CALL 54897 0 3
29050: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
29051: LD_VAR 0 3
29055: PPUSH
29056: CALL_OW 110
29060: PUSH
29061: LD_INT 102
29063: NONEQUAL
29064: IFFALSE 29078
// SetTag ( j , 102 ) ;
29066: LD_VAR 0 3
29070: PPUSH
29071: LD_INT 102
29073: PPUSH
29074: CALL_OW 109
// Wait ( 3 ) ;
29078: LD_INT 3
29080: PPUSH
29081: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
29085: LD_EXP 53
29089: PUSH
29090: LD_VAR 0 2
29094: ARRAY
29095: PUSH
29096: LD_INT 1
29098: ARRAY
29099: IFFALSE 29131
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
29101: LD_VAR 0 3
29105: PPUSH
29106: LD_EXP 53
29110: PUSH
29111: LD_VAR 0 2
29115: ARRAY
29116: PUSH
29117: LD_INT 1
29119: ARRAY
29120: PUSH
29121: LD_INT 1
29123: ARRAY
29124: PPUSH
29125: CALL_OW 128
29129: GO 29189
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
29131: LD_VAR 0 3
29135: PPUSH
29136: CALL_OW 314
29140: NOT
29141: IFFALSE 29159
29143: PUSH
29144: LD_EXP 53
29148: PUSH
29149: LD_VAR 0 2
29153: ARRAY
29154: PUSH
29155: LD_INT 2
29157: ARRAY
29158: AND
29159: IFFALSE 29189
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
29161: LD_VAR 0 3
29165: PPUSH
29166: LD_EXP 53
29170: PUSH
29171: LD_VAR 0 2
29175: ARRAY
29176: PUSH
29177: LD_INT 2
29179: ARRAY
29180: PUSH
29181: LD_INT 1
29183: ARRAY
29184: PPUSH
29185: CALL_OW 128
// end ;
29189: GO 28965
29191: POP
29192: POP
// end ;
29193: GO 28806
29195: POP
29196: POP
// end ;
29197: LD_VAR 0 1
29201: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
29202: LD_INT 0
29204: PPUSH
29205: PPUSH
29206: PPUSH
29207: PPUSH
29208: PPUSH
29209: PPUSH
// if not mc_bases then
29210: LD_EXP 50
29214: NOT
29215: IFFALSE 29219
// exit ;
29217: GO 30390
// for i = 1 to mc_bases do
29219: LD_ADDR_VAR 0 2
29223: PUSH
29224: DOUBLE
29225: LD_INT 1
29227: DEC
29228: ST_TO_ADDR
29229: LD_EXP 50
29233: PUSH
29234: FOR_TO
29235: IFFALSE 30388
// begin if mc_scan [ i ] then
29237: LD_EXP 73
29241: PUSH
29242: LD_VAR 0 2
29246: ARRAY
29247: IFFALSE 29251
// continue ;
29249: GO 29234
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
29251: LD_EXP 55
29255: PUSH
29256: LD_VAR 0 2
29260: ARRAY
29261: NOT
29262: IFFALSE 29277
29264: PUSH
29265: LD_EXP 57
29269: PUSH
29270: LD_VAR 0 2
29274: ARRAY
29275: NOT
29276: AND
29277: IFFALSE 29291
29279: PUSH
29280: LD_EXP 56
29284: PUSH
29285: LD_VAR 0 2
29289: ARRAY
29290: AND
29291: IFFALSE 29329
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
29293: LD_ADDR_EXP 56
29297: PUSH
29298: LD_EXP 56
29302: PPUSH
29303: LD_VAR 0 2
29307: PPUSH
29308: EMPTY
29309: PPUSH
29310: CALL_OW 1
29314: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29315: LD_VAR 0 2
29319: PPUSH
29320: LD_INT 103
29322: PPUSH
29323: CALL 22862 0 2
// continue ;
29327: GO 29234
// end ; if mc_construct_list [ i ] then
29329: LD_EXP 57
29333: PUSH
29334: LD_VAR 0 2
29338: ARRAY
29339: IFFALSE 29559
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29341: LD_ADDR_VAR 0 5
29345: PUSH
29346: LD_EXP 50
29350: PUSH
29351: LD_VAR 0 2
29355: ARRAY
29356: PPUSH
29357: LD_INT 25
29359: PUSH
29360: LD_INT 2
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PPUSH
29367: CALL_OW 72
29371: PUSH
29372: LD_EXP 52
29376: PUSH
29377: LD_VAR 0 2
29381: ARRAY
29382: DIFF
29383: ST_TO_ADDR
// if not tmp then
29384: LD_VAR 0 5
29388: NOT
29389: IFFALSE 29393
// continue ;
29391: GO 29234
// for j in tmp do
29393: LD_ADDR_VAR 0 3
29397: PUSH
29398: LD_VAR 0 5
29402: PUSH
29403: FOR_IN
29404: IFFALSE 29555
// begin if not mc_builders [ i ] then
29406: LD_EXP 56
29410: PUSH
29411: LD_VAR 0 2
29415: ARRAY
29416: NOT
29417: IFFALSE 29475
// begin SetTag ( j , 103 ) ;
29419: LD_VAR 0 3
29423: PPUSH
29424: LD_INT 103
29426: PPUSH
29427: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29431: LD_ADDR_EXP 56
29435: PUSH
29436: LD_EXP 56
29440: PPUSH
29441: LD_VAR 0 2
29445: PUSH
29446: LD_EXP 56
29450: PUSH
29451: LD_VAR 0 2
29455: ARRAY
29456: PUSH
29457: LD_INT 1
29459: PLUS
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PPUSH
29465: LD_VAR 0 3
29469: PPUSH
29470: CALL 54897 0 3
29474: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29475: LD_VAR 0 3
29479: PPUSH
29480: CALL_OW 310
29484: IFFALSE 29495
// ComExitBuilding ( j ) ;
29486: LD_VAR 0 3
29490: PPUSH
29491: CALL_OW 122
// wait ( 3 ) ;
29495: LD_INT 3
29497: PPUSH
29498: CALL_OW 67
// if not mc_construct_list [ i ] then
29502: LD_EXP 57
29506: PUSH
29507: LD_VAR 0 2
29511: ARRAY
29512: NOT
29513: IFFALSE 29517
// break ;
29515: GO 29555
// if not HasTask ( j ) then
29517: LD_VAR 0 3
29521: PPUSH
29522: CALL_OW 314
29526: NOT
29527: IFFALSE 29553
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29529: LD_VAR 0 3
29533: PPUSH
29534: LD_EXP 57
29538: PUSH
29539: LD_VAR 0 2
29543: ARRAY
29544: PUSH
29545: LD_INT 1
29547: ARRAY
29548: PPUSH
29549: CALL 58149 0 2
// end ;
29553: GO 29403
29555: POP
29556: POP
// end else
29557: GO 30386
// if mc_build_list [ i ] then
29559: LD_EXP 55
29563: PUSH
29564: LD_VAR 0 2
29568: ARRAY
29569: IFFALSE 30386
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29571: LD_EXP 55
29575: PUSH
29576: LD_VAR 0 2
29580: ARRAY
29581: PUSH
29582: LD_INT 1
29584: ARRAY
29585: PUSH
29586: LD_INT 1
29588: ARRAY
29589: PPUSH
29590: CALL 57973 0 1
29594: IFFALSE 29642
29596: PUSH
29597: LD_EXP 50
29601: PUSH
29602: LD_VAR 0 2
29606: ARRAY
29607: PPUSH
29608: LD_INT 2
29610: PUSH
29611: LD_INT 30
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 30
29623: PUSH
29624: LD_INT 3
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: LIST
29635: PPUSH
29636: CALL_OW 72
29640: NOT
29641: AND
29642: IFFALSE 29747
// begin for j = 1 to mc_build_list [ i ] do
29644: LD_ADDR_VAR 0 3
29648: PUSH
29649: DOUBLE
29650: LD_INT 1
29652: DEC
29653: ST_TO_ADDR
29654: LD_EXP 55
29658: PUSH
29659: LD_VAR 0 2
29663: ARRAY
29664: PUSH
29665: FOR_TO
29666: IFFALSE 29745
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29668: LD_EXP 55
29672: PUSH
29673: LD_VAR 0 2
29677: ARRAY
29678: PUSH
29679: LD_VAR 0 3
29683: ARRAY
29684: PUSH
29685: LD_INT 1
29687: ARRAY
29688: PUSH
29689: LD_INT 2
29691: EQUAL
29692: IFFALSE 29743
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29694: LD_ADDR_EXP 55
29698: PUSH
29699: LD_EXP 55
29703: PPUSH
29704: LD_VAR 0 2
29708: PPUSH
29709: LD_EXP 55
29713: PUSH
29714: LD_VAR 0 2
29718: ARRAY
29719: PPUSH
29720: LD_VAR 0 3
29724: PPUSH
29725: LD_INT 1
29727: PPUSH
29728: LD_INT 0
29730: PPUSH
29731: CALL 54305 0 4
29735: PPUSH
29736: CALL_OW 1
29740: ST_TO_ADDR
// break ;
29741: GO 29745
// end ;
29743: GO 29665
29745: POP
29746: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29747: LD_ADDR_VAR 0 6
29751: PUSH
29752: LD_EXP 50
29756: PUSH
29757: LD_VAR 0 2
29761: ARRAY
29762: PPUSH
29763: LD_INT 2
29765: PUSH
29766: LD_INT 30
29768: PUSH
29769: LD_INT 0
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 30
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: LIST
29790: PPUSH
29791: CALL_OW 72
29795: ST_TO_ADDR
// for k := 1 to depot do
29796: LD_ADDR_VAR 0 4
29800: PUSH
29801: DOUBLE
29802: LD_INT 1
29804: DEC
29805: ST_TO_ADDR
29806: LD_VAR 0 6
29810: PUSH
29811: FOR_TO
29812: IFFALSE 30384
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29814: LD_EXP 55
29818: PUSH
29819: LD_VAR 0 2
29823: ARRAY
29824: PUSH
29825: LD_INT 1
29827: ARRAY
29828: PUSH
29829: LD_INT 1
29831: ARRAY
29832: PUSH
29833: LD_INT 0
29835: EQUAL
29836: IFTRUE 29931
29838: PUSH
29839: LD_VAR 0 6
29843: PUSH
29844: LD_VAR 0 4
29848: ARRAY
29849: PPUSH
29850: LD_EXP 55
29854: PUSH
29855: LD_VAR 0 2
29859: ARRAY
29860: PUSH
29861: LD_INT 1
29863: ARRAY
29864: PUSH
29865: LD_INT 1
29867: ARRAY
29868: PPUSH
29869: LD_EXP 55
29873: PUSH
29874: LD_VAR 0 2
29878: ARRAY
29879: PUSH
29880: LD_INT 1
29882: ARRAY
29883: PUSH
29884: LD_INT 2
29886: ARRAY
29887: PPUSH
29888: LD_EXP 55
29892: PUSH
29893: LD_VAR 0 2
29897: ARRAY
29898: PUSH
29899: LD_INT 1
29901: ARRAY
29902: PUSH
29903: LD_INT 3
29905: ARRAY
29906: PPUSH
29907: LD_EXP 55
29911: PUSH
29912: LD_VAR 0 2
29916: ARRAY
29917: PUSH
29918: LD_INT 1
29920: ARRAY
29921: PUSH
29922: LD_INT 4
29924: ARRAY
29925: PPUSH
29926: CALL 63453 0 5
29930: OR
29931: IFFALSE 30212
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29933: LD_ADDR_VAR 0 5
29937: PUSH
29938: LD_EXP 50
29942: PUSH
29943: LD_VAR 0 2
29947: ARRAY
29948: PPUSH
29949: LD_INT 25
29951: PUSH
29952: LD_INT 2
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PPUSH
29959: CALL_OW 72
29963: PUSH
29964: LD_EXP 52
29968: PUSH
29969: LD_VAR 0 2
29973: ARRAY
29974: DIFF
29975: ST_TO_ADDR
// if not tmp then
29976: LD_VAR 0 5
29980: NOT
29981: IFFALSE 29985
// continue ;
29983: GO 29811
// for j in tmp do
29985: LD_ADDR_VAR 0 3
29989: PUSH
29990: LD_VAR 0 5
29994: PUSH
29995: FOR_IN
29996: IFFALSE 30208
// begin if not mc_builders [ i ] then
29998: LD_EXP 56
30002: PUSH
30003: LD_VAR 0 2
30007: ARRAY
30008: NOT
30009: IFFALSE 30067
// begin SetTag ( j , 103 ) ;
30011: LD_VAR 0 3
30015: PPUSH
30016: LD_INT 103
30018: PPUSH
30019: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30023: LD_ADDR_EXP 56
30027: PUSH
30028: LD_EXP 56
30032: PPUSH
30033: LD_VAR 0 2
30037: PUSH
30038: LD_EXP 56
30042: PUSH
30043: LD_VAR 0 2
30047: ARRAY
30048: PUSH
30049: LD_INT 1
30051: PLUS
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PPUSH
30057: LD_VAR 0 3
30061: PPUSH
30062: CALL 54897 0 3
30066: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30067: LD_VAR 0 3
30071: PPUSH
30072: CALL_OW 310
30076: IFFALSE 30087
// ComExitBuilding ( j ) ;
30078: LD_VAR 0 3
30082: PPUSH
30083: CALL_OW 122
// wait ( 3 ) ;
30087: LD_INT 3
30089: PPUSH
30090: CALL_OW 67
// if not mc_build_list [ i ] then
30094: LD_EXP 55
30098: PUSH
30099: LD_VAR 0 2
30103: ARRAY
30104: NOT
30105: IFFALSE 30109
// break ;
30107: GO 30208
// if not HasTask ( j ) then
30109: LD_VAR 0 3
30113: PPUSH
30114: CALL_OW 314
30118: NOT
30119: IFFALSE 30206
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
30121: LD_VAR 0 3
30125: PPUSH
30126: LD_EXP 55
30130: PUSH
30131: LD_VAR 0 2
30135: ARRAY
30136: PUSH
30137: LD_INT 1
30139: ARRAY
30140: PUSH
30141: LD_INT 1
30143: ARRAY
30144: PPUSH
30145: LD_EXP 55
30149: PUSH
30150: LD_VAR 0 2
30154: ARRAY
30155: PUSH
30156: LD_INT 1
30158: ARRAY
30159: PUSH
30160: LD_INT 2
30162: ARRAY
30163: PPUSH
30164: LD_EXP 55
30168: PUSH
30169: LD_VAR 0 2
30173: ARRAY
30174: PUSH
30175: LD_INT 1
30177: ARRAY
30178: PUSH
30179: LD_INT 3
30181: ARRAY
30182: PPUSH
30183: LD_EXP 55
30187: PUSH
30188: LD_VAR 0 2
30192: ARRAY
30193: PUSH
30194: LD_INT 1
30196: ARRAY
30197: PUSH
30198: LD_INT 4
30200: ARRAY
30201: PPUSH
30202: CALL_OW 145
// end ;
30206: GO 29995
30208: POP
30209: POP
// end else
30210: GO 30382
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
30212: LD_EXP 50
30216: PUSH
30217: LD_VAR 0 2
30221: ARRAY
30222: PPUSH
30223: LD_EXP 55
30227: PUSH
30228: LD_VAR 0 2
30232: ARRAY
30233: PUSH
30234: LD_INT 1
30236: ARRAY
30237: PUSH
30238: LD_INT 1
30240: ARRAY
30241: PPUSH
30242: LD_EXP 55
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: PUSH
30253: LD_INT 1
30255: ARRAY
30256: PUSH
30257: LD_INT 2
30259: ARRAY
30260: PPUSH
30261: LD_EXP 55
30265: PUSH
30266: LD_VAR 0 2
30270: ARRAY
30271: PUSH
30272: LD_INT 1
30274: ARRAY
30275: PUSH
30276: LD_INT 3
30278: ARRAY
30279: PPUSH
30280: LD_EXP 55
30284: PUSH
30285: LD_VAR 0 2
30289: ARRAY
30290: PUSH
30291: LD_INT 1
30293: ARRAY
30294: PUSH
30295: LD_INT 4
30297: ARRAY
30298: PPUSH
30299: LD_EXP 50
30303: PUSH
30304: LD_VAR 0 2
30308: ARRAY
30309: PPUSH
30310: LD_INT 21
30312: PUSH
30313: LD_INT 3
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PPUSH
30320: CALL_OW 72
30324: PPUSH
30325: EMPTY
30326: PPUSH
30327: CALL 62189 0 7
30331: NOT
30332: IFFALSE 30382
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
30334: LD_ADDR_EXP 55
30338: PUSH
30339: LD_EXP 55
30343: PPUSH
30344: LD_VAR 0 2
30348: PPUSH
30349: LD_EXP 55
30353: PUSH
30354: LD_VAR 0 2
30358: ARRAY
30359: PPUSH
30360: LD_INT 1
30362: PPUSH
30363: LD_INT 1
30365: NEG
30366: PPUSH
30367: LD_INT 0
30369: PPUSH
30370: CALL 54305 0 4
30374: PPUSH
30375: CALL_OW 1
30379: ST_TO_ADDR
// continue ;
30380: GO 29811
// end ; end ;
30382: GO 29811
30384: POP
30385: POP
// end ; end ;
30386: GO 29234
30388: POP
30389: POP
// end ;
30390: LD_VAR 0 1
30394: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30395: LD_INT 0
30397: PPUSH
30398: PPUSH
30399: PPUSH
30400: PPUSH
30401: PPUSH
30402: PPUSH
// if not mc_bases then
30403: LD_EXP 50
30407: NOT
30408: IFFALSE 30412
// exit ;
30410: GO 30845
// for i = 1 to mc_bases do
30412: LD_ADDR_VAR 0 2
30416: PUSH
30417: DOUBLE
30418: LD_INT 1
30420: DEC
30421: ST_TO_ADDR
30422: LD_EXP 50
30426: PUSH
30427: FOR_TO
30428: IFFALSE 30843
// begin tmp := mc_build_upgrade [ i ] ;
30430: LD_ADDR_VAR 0 4
30434: PUSH
30435: LD_EXP 82
30439: PUSH
30440: LD_VAR 0 2
30444: ARRAY
30445: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30446: LD_ADDR_VAR 0 6
30450: PUSH
30451: LD_EXP 83
30455: PUSH
30456: LD_VAR 0 2
30460: ARRAY
30461: PPUSH
30462: LD_INT 2
30464: PUSH
30465: LD_INT 30
30467: PUSH
30468: LD_INT 6
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 30
30477: PUSH
30478: LD_INT 7
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: LIST
30489: PPUSH
30490: CALL_OW 72
30494: ST_TO_ADDR
// if not tmp and not lab then
30495: LD_VAR 0 4
30499: NOT
30500: IFFALSE 30509
30502: PUSH
30503: LD_VAR 0 6
30507: NOT
30508: AND
30509: IFFALSE 30513
// continue ;
30511: GO 30427
// if tmp then
30513: LD_VAR 0 4
30517: IFFALSE 30637
// for j in tmp do
30519: LD_ADDR_VAR 0 3
30523: PUSH
30524: LD_VAR 0 4
30528: PUSH
30529: FOR_IN
30530: IFFALSE 30635
// begin if UpgradeCost ( j ) then
30532: LD_VAR 0 3
30536: PPUSH
30537: CALL 61841 0 1
30541: IFFALSE 30633
// begin ComUpgrade ( j ) ;
30543: LD_VAR 0 3
30547: PPUSH
30548: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30552: LD_ADDR_EXP 82
30556: PUSH
30557: LD_EXP 82
30561: PPUSH
30562: LD_VAR 0 2
30566: PPUSH
30567: LD_EXP 82
30571: PUSH
30572: LD_VAR 0 2
30576: ARRAY
30577: PUSH
30578: LD_VAR 0 3
30582: DIFF
30583: PPUSH
30584: CALL_OW 1
30588: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30589: LD_ADDR_EXP 57
30593: PUSH
30594: LD_EXP 57
30598: PPUSH
30599: LD_VAR 0 2
30603: PUSH
30604: LD_EXP 57
30608: PUSH
30609: LD_VAR 0 2
30613: ARRAY
30614: PUSH
30615: LD_INT 1
30617: PLUS
30618: PUSH
30619: EMPTY
30620: LIST
30621: LIST
30622: PPUSH
30623: LD_VAR 0 3
30627: PPUSH
30628: CALL 54897 0 3
30632: ST_TO_ADDR
// end ; end ;
30633: GO 30529
30635: POP
30636: POP
// if not lab or not mc_lab_upgrade [ i ] then
30637: LD_VAR 0 6
30641: NOT
30642: IFTRUE 30657
30644: PUSH
30645: LD_EXP 84
30649: PUSH
30650: LD_VAR 0 2
30654: ARRAY
30655: NOT
30656: OR
30657: IFFALSE 30661
// continue ;
30659: GO 30427
// for j in lab do
30661: LD_ADDR_VAR 0 3
30665: PUSH
30666: LD_VAR 0 6
30670: PUSH
30671: FOR_IN
30672: IFFALSE 30839
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30674: LD_VAR 0 3
30678: PPUSH
30679: CALL_OW 266
30683: PUSH
30684: LD_INT 6
30686: PUSH
30687: LD_INT 7
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: IN
30694: IFFALSE 30711
30696: PUSH
30697: LD_VAR 0 3
30701: PPUSH
30702: CALL_OW 461
30706: PUSH
30707: LD_INT 1
30709: NONEQUAL
30710: AND
30711: IFFALSE 30837
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30713: LD_VAR 0 3
30717: PPUSH
30718: LD_EXP 84
30722: PUSH
30723: LD_VAR 0 2
30727: ARRAY
30728: PUSH
30729: LD_INT 1
30731: ARRAY
30732: PPUSH
30733: CALL 62050 0 2
30737: IFFALSE 30837
// begin ComCancel ( j ) ;
30739: LD_VAR 0 3
30743: PPUSH
30744: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30748: LD_VAR 0 3
30752: PPUSH
30753: LD_EXP 84
30757: PUSH
30758: LD_VAR 0 2
30762: ARRAY
30763: PUSH
30764: LD_INT 1
30766: ARRAY
30767: PPUSH
30768: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30772: LD_VAR 0 3
30776: PUSH
30777: LD_EXP 57
30781: PUSH
30782: LD_VAR 0 2
30786: ARRAY
30787: IN
30788: NOT
30789: IFFALSE 30835
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30791: LD_ADDR_EXP 57
30795: PUSH
30796: LD_EXP 57
30800: PPUSH
30801: LD_VAR 0 2
30805: PUSH
30806: LD_EXP 57
30810: PUSH
30811: LD_VAR 0 2
30815: ARRAY
30816: PUSH
30817: LD_INT 1
30819: PLUS
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PPUSH
30825: LD_VAR 0 3
30829: PPUSH
30830: CALL 54897 0 3
30834: ST_TO_ADDR
// break ;
30835: GO 30839
// end ; end ; end ;
30837: GO 30671
30839: POP
30840: POP
// end ;
30841: GO 30427
30843: POP
30844: POP
// end ;
30845: LD_VAR 0 1
30849: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30850: LD_INT 0
30852: PPUSH
30853: PPUSH
30854: PPUSH
30855: PPUSH
30856: PPUSH
30857: PPUSH
30858: PPUSH
30859: PPUSH
30860: PPUSH
// if not mc_bases then
30861: LD_EXP 50
30865: NOT
30866: IFFALSE 30870
// exit ;
30868: GO 31277
// for i = 1 to mc_bases do
30870: LD_ADDR_VAR 0 2
30874: PUSH
30875: DOUBLE
30876: LD_INT 1
30878: DEC
30879: ST_TO_ADDR
30880: LD_EXP 50
30884: PUSH
30885: FOR_TO
30886: IFFALSE 31275
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30888: LD_EXP 58
30892: PUSH
30893: LD_VAR 0 2
30897: ARRAY
30898: NOT
30899: IFTRUE 30929
30901: PUSH
30902: LD_EXP 50
30906: PUSH
30907: LD_VAR 0 2
30911: ARRAY
30912: PPUSH
30913: LD_INT 30
30915: PUSH
30916: LD_INT 3
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PPUSH
30923: CALL_OW 72
30927: NOT
30928: OR
30929: IFFALSE 30933
// continue ;
30931: GO 30885
// busy := false ;
30933: LD_ADDR_VAR 0 8
30937: PUSH
30938: LD_INT 0
30940: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30941: LD_ADDR_VAR 0 4
30945: PUSH
30946: LD_EXP 50
30950: PUSH
30951: LD_VAR 0 2
30955: ARRAY
30956: PPUSH
30957: LD_INT 30
30959: PUSH
30960: LD_INT 3
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PPUSH
30967: CALL_OW 72
30971: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30972: LD_ADDR_VAR 0 6
30976: PUSH
30977: LD_EXP 58
30981: PUSH
30982: LD_VAR 0 2
30986: ARRAY
30987: PPUSH
30988: LD_INT 2
30990: PUSH
30991: LD_INT 30
30993: PUSH
30994: LD_INT 32
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 30
31003: PUSH
31004: LD_INT 33
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: LIST
31015: PPUSH
31016: CALL_OW 72
31020: ST_TO_ADDR
// if not t then
31021: LD_VAR 0 6
31025: NOT
31026: IFFALSE 31030
// continue ;
31028: GO 30885
// for j in tmp do
31030: LD_ADDR_VAR 0 3
31034: PUSH
31035: LD_VAR 0 4
31039: PUSH
31040: FOR_IN
31041: IFFALSE 31071
// if not BuildingStatus ( j ) = bs_idle then
31043: LD_VAR 0 3
31047: PPUSH
31048: CALL_OW 461
31052: PUSH
31053: LD_INT 2
31055: EQUAL
31056: NOT
31057: IFFALSE 31069
// begin busy := true ;
31059: LD_ADDR_VAR 0 8
31063: PUSH
31064: LD_INT 1
31066: ST_TO_ADDR
// break ;
31067: GO 31071
// end ;
31069: GO 31040
31071: POP
31072: POP
// if busy then
31073: LD_VAR 0 8
31077: IFFALSE 31081
// continue ;
31079: GO 30885
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
31081: LD_ADDR_VAR 0 7
31085: PUSH
31086: LD_VAR 0 6
31090: PPUSH
31091: LD_INT 35
31093: PUSH
31094: LD_INT 0
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PPUSH
31101: CALL_OW 72
31105: ST_TO_ADDR
// if tw then
31106: LD_VAR 0 7
31110: IFFALSE 31187
// begin tw := tw [ 1 ] ;
31112: LD_ADDR_VAR 0 7
31116: PUSH
31117: LD_VAR 0 7
31121: PUSH
31122: LD_INT 1
31124: ARRAY
31125: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
31126: LD_ADDR_VAR 0 9
31130: PUSH
31131: LD_VAR 0 7
31135: PPUSH
31136: LD_EXP 75
31140: PUSH
31141: LD_VAR 0 2
31145: ARRAY
31146: PPUSH
31147: CALL 60304 0 2
31151: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
31152: LD_EXP 89
31156: PUSH
31157: LD_VAR 0 2
31161: ARRAY
31162: IFFALSE 31185
// if not weapon in mc_allowed_tower_weapons [ i ] then
31164: LD_VAR 0 9
31168: PUSH
31169: LD_EXP 89
31173: PUSH
31174: LD_VAR 0 2
31178: ARRAY
31179: IN
31180: NOT
31181: IFFALSE 31185
// continue ;
31183: GO 30885
// end else
31185: GO 31250
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
31187: LD_ADDR_VAR 0 5
31191: PUSH
31192: LD_EXP 58
31196: PUSH
31197: LD_VAR 0 2
31201: ARRAY
31202: PPUSH
31203: LD_VAR 0 4
31207: PPUSH
31208: CALL 87499 0 2
31212: ST_TO_ADDR
// if not tmp2 then
31213: LD_VAR 0 5
31217: NOT
31218: IFFALSE 31222
// continue ;
31220: GO 30885
// tw := tmp2 [ 1 ] ;
31222: LD_ADDR_VAR 0 7
31226: PUSH
31227: LD_VAR 0 5
31231: PUSH
31232: LD_INT 1
31234: ARRAY
31235: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
31236: LD_ADDR_VAR 0 9
31240: PUSH
31241: LD_VAR 0 5
31245: PUSH
31246: LD_INT 2
31248: ARRAY
31249: ST_TO_ADDR
// end ; if not weapon then
31250: LD_VAR 0 9
31254: NOT
31255: IFFALSE 31259
// continue ;
31257: GO 30885
// ComPlaceWeapon ( tw , weapon ) ;
31259: LD_VAR 0 7
31263: PPUSH
31264: LD_VAR 0 9
31268: PPUSH
31269: CALL_OW 148
// end ;
31273: GO 30885
31275: POP
31276: POP
// end ;
31277: LD_VAR 0 1
31281: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
31282: LD_INT 0
31284: PPUSH
31285: PPUSH
31286: PPUSH
31287: PPUSH
31288: PPUSH
31289: PPUSH
31290: PPUSH
// if not mc_bases then
31291: LD_EXP 50
31295: NOT
31296: IFFALSE 31300
// exit ;
31298: GO 32087
// for i = 1 to mc_bases do
31300: LD_ADDR_VAR 0 2
31304: PUSH
31305: DOUBLE
31306: LD_INT 1
31308: DEC
31309: ST_TO_ADDR
31310: LD_EXP 50
31314: PUSH
31315: FOR_TO
31316: IFFALSE 32085
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
31318: LD_EXP 63
31322: PUSH
31323: LD_VAR 0 2
31327: ARRAY
31328: NOT
31329: IFTRUE 31355
31331: PUSH
31332: LD_EXP 63
31336: PUSH
31337: LD_VAR 0 2
31341: ARRAY
31342: PUSH
31343: LD_EXP 64
31347: PUSH
31348: LD_VAR 0 2
31352: ARRAY
31353: EQUAL
31354: OR
31355: IFTRUE 31369
31357: PUSH
31358: LD_EXP 73
31362: PUSH
31363: LD_VAR 0 2
31367: ARRAY
31368: OR
31369: IFFALSE 31373
// continue ;
31371: GO 31315
// if mc_miners [ i ] then
31373: LD_EXP 64
31377: PUSH
31378: LD_VAR 0 2
31382: ARRAY
31383: IFFALSE 31770
// begin for j = mc_miners [ i ] downto 1 do
31385: LD_ADDR_VAR 0 3
31389: PUSH
31390: DOUBLE
31391: LD_EXP 64
31395: PUSH
31396: LD_VAR 0 2
31400: ARRAY
31401: INC
31402: ST_TO_ADDR
31403: LD_INT 1
31405: PUSH
31406: FOR_DOWNTO
31407: IFFALSE 31768
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31409: LD_EXP 64
31413: PUSH
31414: LD_VAR 0 2
31418: ARRAY
31419: PUSH
31420: LD_VAR 0 3
31424: ARRAY
31425: PPUSH
31426: CALL_OW 301
31430: IFTRUE 31459
31432: PUSH
31433: LD_EXP 64
31437: PUSH
31438: LD_VAR 0 2
31442: ARRAY
31443: PUSH
31444: LD_VAR 0 3
31448: ARRAY
31449: PPUSH
31450: CALL_OW 257
31454: PUSH
31455: LD_INT 1
31457: NONEQUAL
31458: OR
31459: IFFALSE 31522
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31461: LD_ADDR_VAR 0 5
31465: PUSH
31466: LD_EXP 64
31470: PUSH
31471: LD_VAR 0 2
31475: ARRAY
31476: PUSH
31477: LD_EXP 64
31481: PUSH
31482: LD_VAR 0 2
31486: ARRAY
31487: PUSH
31488: LD_VAR 0 3
31492: ARRAY
31493: DIFF
31494: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31495: LD_ADDR_EXP 64
31499: PUSH
31500: LD_EXP 64
31504: PPUSH
31505: LD_VAR 0 2
31509: PPUSH
31510: LD_VAR 0 5
31514: PPUSH
31515: CALL_OW 1
31519: ST_TO_ADDR
// continue ;
31520: GO 31406
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31522: LD_EXP 64
31526: PUSH
31527: LD_VAR 0 2
31531: ARRAY
31532: PUSH
31533: LD_VAR 0 3
31537: ARRAY
31538: PPUSH
31539: CALL_OW 257
31543: PUSH
31544: LD_INT 1
31546: EQUAL
31547: IFFALSE 31573
31549: PUSH
31550: LD_EXP 64
31554: PUSH
31555: LD_VAR 0 2
31559: ARRAY
31560: PUSH
31561: LD_VAR 0 3
31565: ARRAY
31566: PPUSH
31567: CALL_OW 459
31571: NOT
31572: AND
31573: IFFALSE 31599
31575: PUSH
31576: LD_EXP 64
31580: PUSH
31581: LD_VAR 0 2
31585: ARRAY
31586: PUSH
31587: LD_VAR 0 3
31591: ARRAY
31592: PPUSH
31593: CALL_OW 314
31597: NOT
31598: AND
31599: IFFALSE 31766
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31601: LD_EXP 64
31605: PUSH
31606: LD_VAR 0 2
31610: ARRAY
31611: PUSH
31612: LD_VAR 0 3
31616: ARRAY
31617: PPUSH
31618: CALL_OW 310
31622: IFFALSE 31645
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31624: LD_EXP 64
31628: PUSH
31629: LD_VAR 0 2
31633: ARRAY
31634: PUSH
31635: LD_VAR 0 3
31639: ARRAY
31640: PPUSH
31641: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31645: LD_EXP 64
31649: PUSH
31650: LD_VAR 0 2
31654: ARRAY
31655: PUSH
31656: LD_VAR 0 3
31660: ARRAY
31661: PPUSH
31662: CALL_OW 314
31666: NOT
31667: IFFALSE 31766
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31669: LD_ADDR_VAR 0 7
31673: PUSH
31674: LD_VAR 0 3
31678: PUSH
31679: LD_EXP 63
31683: PUSH
31684: LD_VAR 0 2
31688: ARRAY
31689: PPUSH
31690: CALL 51979 0 1
31694: MOD
31695: PUSH
31696: LD_INT 1
31698: PLUS
31699: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31700: LD_EXP 64
31704: PUSH
31705: LD_VAR 0 2
31709: ARRAY
31710: PUSH
31711: LD_VAR 0 3
31715: ARRAY
31716: PPUSH
31717: LD_EXP 63
31721: PUSH
31722: LD_VAR 0 2
31726: ARRAY
31727: PUSH
31728: LD_VAR 0 7
31732: ARRAY
31733: PUSH
31734: LD_INT 1
31736: ARRAY
31737: PPUSH
31738: LD_EXP 63
31742: PUSH
31743: LD_VAR 0 2
31747: ARRAY
31748: PUSH
31749: LD_VAR 0 7
31753: ARRAY
31754: PUSH
31755: LD_INT 2
31757: ARRAY
31758: PPUSH
31759: LD_INT 0
31761: PPUSH
31762: CALL_OW 193
// end ; end ; end ;
31766: GO 31406
31768: POP
31769: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31770: LD_ADDR_VAR 0 5
31774: PUSH
31775: LD_EXP 50
31779: PUSH
31780: LD_VAR 0 2
31784: ARRAY
31785: PPUSH
31786: LD_INT 2
31788: PUSH
31789: LD_INT 30
31791: PUSH
31792: LD_INT 4
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 30
31801: PUSH
31802: LD_INT 5
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 30
31811: PUSH
31812: LD_INT 32
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: PPUSH
31825: CALL_OW 72
31829: ST_TO_ADDR
// if not tmp then
31830: LD_VAR 0 5
31834: NOT
31835: IFFALSE 31839
// continue ;
31837: GO 31315
// list := [ ] ;
31839: LD_ADDR_VAR 0 6
31843: PUSH
31844: EMPTY
31845: ST_TO_ADDR
// for j in tmp do
31846: LD_ADDR_VAR 0 3
31850: PUSH
31851: LD_VAR 0 5
31855: PUSH
31856: FOR_IN
31857: IFFALSE 31928
// begin for k in UnitsInside ( j ) do
31859: LD_ADDR_VAR 0 4
31863: PUSH
31864: LD_VAR 0 3
31868: PPUSH
31869: CALL_OW 313
31873: PUSH
31874: FOR_IN
31875: IFFALSE 31924
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31877: LD_VAR 0 4
31881: PPUSH
31882: CALL_OW 257
31886: PUSH
31887: LD_INT 1
31889: EQUAL
31890: IFFALSE 31904
31892: PUSH
31893: LD_VAR 0 4
31897: PPUSH
31898: CALL_OW 459
31902: NOT
31903: AND
31904: IFFALSE 31922
// list := list ^ k ;
31906: LD_ADDR_VAR 0 6
31910: PUSH
31911: LD_VAR 0 6
31915: PUSH
31916: LD_VAR 0 4
31920: ADD
31921: ST_TO_ADDR
31922: GO 31874
31924: POP
31925: POP
// end ;
31926: GO 31856
31928: POP
31929: POP
// list := list diff mc_miners [ i ] ;
31930: LD_ADDR_VAR 0 6
31934: PUSH
31935: LD_VAR 0 6
31939: PUSH
31940: LD_EXP 64
31944: PUSH
31945: LD_VAR 0 2
31949: ARRAY
31950: DIFF
31951: ST_TO_ADDR
// if not list then
31952: LD_VAR 0 6
31956: NOT
31957: IFFALSE 31961
// continue ;
31959: GO 31315
// k := mc_mines [ i ] - mc_miners [ i ] ;
31961: LD_ADDR_VAR 0 4
31965: PUSH
31966: LD_EXP 63
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: PUSH
31977: LD_EXP 64
31981: PUSH
31982: LD_VAR 0 2
31986: ARRAY
31987: MINUS
31988: ST_TO_ADDR
// if k > list then
31989: LD_VAR 0 4
31993: PUSH
31994: LD_VAR 0 6
31998: GREATER
31999: IFFALSE 32011
// k := list ;
32001: LD_ADDR_VAR 0 4
32005: PUSH
32006: LD_VAR 0 6
32010: ST_TO_ADDR
// for j = 1 to k do
32011: LD_ADDR_VAR 0 3
32015: PUSH
32016: DOUBLE
32017: LD_INT 1
32019: DEC
32020: ST_TO_ADDR
32021: LD_VAR 0 4
32025: PUSH
32026: FOR_TO
32027: IFFALSE 32081
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
32029: LD_ADDR_EXP 64
32033: PUSH
32034: LD_EXP 64
32038: PPUSH
32039: LD_VAR 0 2
32043: PUSH
32044: LD_EXP 64
32048: PUSH
32049: LD_VAR 0 2
32053: ARRAY
32054: PUSH
32055: LD_INT 1
32057: PLUS
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PPUSH
32063: LD_VAR 0 6
32067: PUSH
32068: LD_VAR 0 3
32072: ARRAY
32073: PPUSH
32074: CALL 54897 0 3
32078: ST_TO_ADDR
32079: GO 32026
32081: POP
32082: POP
// end ;
32083: GO 31315
32085: POP
32086: POP
// end ;
32087: LD_VAR 0 1
32091: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
32092: LD_INT 0
32094: PPUSH
32095: PPUSH
32096: PPUSH
32097: PPUSH
32098: PPUSH
32099: PPUSH
32100: PPUSH
32101: PPUSH
32102: PPUSH
32103: PPUSH
32104: PPUSH
// if not mc_bases then
32105: LD_EXP 50
32109: NOT
32110: IFFALSE 32114
// exit ;
32112: GO 33961
// for i = 1 to mc_bases do
32114: LD_ADDR_VAR 0 2
32118: PUSH
32119: DOUBLE
32120: LD_INT 1
32122: DEC
32123: ST_TO_ADDR
32124: LD_EXP 50
32128: PUSH
32129: FOR_TO
32130: IFFALSE 33959
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
32132: LD_EXP 50
32136: PUSH
32137: LD_VAR 0 2
32141: ARRAY
32142: NOT
32143: IFTRUE 32157
32145: PUSH
32146: LD_EXP 57
32150: PUSH
32151: LD_VAR 0 2
32155: ARRAY
32156: OR
32157: IFFALSE 32161
// continue ;
32159: GO 32129
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
32161: LD_EXP 66
32165: PUSH
32166: LD_VAR 0 2
32170: ARRAY
32171: NOT
32172: IFFALSE 32186
32174: PUSH
32175: LD_EXP 67
32179: PUSH
32180: LD_VAR 0 2
32184: ARRAY
32185: AND
32186: IFFALSE 32224
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
32188: LD_ADDR_EXP 67
32192: PUSH
32193: LD_EXP 67
32197: PPUSH
32198: LD_VAR 0 2
32202: PPUSH
32203: EMPTY
32204: PPUSH
32205: CALL_OW 1
32209: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
32210: LD_VAR 0 2
32214: PPUSH
32215: LD_INT 107
32217: PPUSH
32218: CALL 22862 0 2
// continue ;
32222: GO 32129
// end ; target := [ ] ;
32224: LD_ADDR_VAR 0 7
32228: PUSH
32229: EMPTY
32230: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
32231: LD_ADDR_VAR 0 6
32235: PUSH
32236: LD_EXP 50
32240: PUSH
32241: LD_VAR 0 2
32245: ARRAY
32246: PUSH
32247: LD_INT 1
32249: ARRAY
32250: PPUSH
32251: CALL_OW 255
32255: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32256: LD_ADDR_VAR 0 9
32260: PUSH
32261: LD_EXP 50
32265: PUSH
32266: LD_VAR 0 2
32270: ARRAY
32271: PPUSH
32272: LD_INT 2
32274: PUSH
32275: LD_INT 30
32277: PUSH
32278: LD_INT 0
32280: PUSH
32281: EMPTY
32282: LIST
32283: LIST
32284: PUSH
32285: LD_INT 30
32287: PUSH
32288: LD_INT 1
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: LIST
32299: PPUSH
32300: CALL_OW 72
32304: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
32305: LD_ADDR_VAR 0 3
32309: PUSH
32310: DOUBLE
32311: LD_EXP 66
32315: PUSH
32316: LD_VAR 0 2
32320: ARRAY
32321: INC
32322: ST_TO_ADDR
32323: LD_INT 1
32325: PUSH
32326: FOR_DOWNTO
32327: IFFALSE 32574
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
32329: LD_EXP 66
32333: PUSH
32334: LD_VAR 0 2
32338: ARRAY
32339: PUSH
32340: LD_VAR 0 3
32344: ARRAY
32345: PUSH
32346: LD_INT 2
32348: ARRAY
32349: PPUSH
32350: LD_EXP 66
32354: PUSH
32355: LD_VAR 0 2
32359: ARRAY
32360: PUSH
32361: LD_VAR 0 3
32365: ARRAY
32366: PUSH
32367: LD_INT 3
32369: ARRAY
32370: PPUSH
32371: CALL_OW 488
32375: IFFALSE 32429
32377: PUSH
32378: LD_EXP 66
32382: PUSH
32383: LD_VAR 0 2
32387: ARRAY
32388: PUSH
32389: LD_VAR 0 3
32393: ARRAY
32394: PUSH
32395: LD_INT 2
32397: ARRAY
32398: PPUSH
32399: LD_EXP 66
32403: PUSH
32404: LD_VAR 0 2
32408: ARRAY
32409: PUSH
32410: LD_VAR 0 3
32414: ARRAY
32415: PUSH
32416: LD_INT 3
32418: ARRAY
32419: PPUSH
32420: CALL_OW 284
32424: PUSH
32425: LD_INT 0
32427: EQUAL
32428: AND
32429: IFFALSE 32484
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32431: LD_ADDR_VAR 0 5
32435: PUSH
32436: LD_EXP 66
32440: PUSH
32441: LD_VAR 0 2
32445: ARRAY
32446: PPUSH
32447: LD_VAR 0 3
32451: PPUSH
32452: CALL_OW 3
32456: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32457: LD_ADDR_EXP 66
32461: PUSH
32462: LD_EXP 66
32466: PPUSH
32467: LD_VAR 0 2
32471: PPUSH
32472: LD_VAR 0 5
32476: PPUSH
32477: CALL_OW 1
32481: ST_TO_ADDR
// continue ;
32482: GO 32326
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32484: LD_VAR 0 6
32488: PPUSH
32489: LD_EXP 66
32493: PUSH
32494: LD_VAR 0 2
32498: ARRAY
32499: PUSH
32500: LD_VAR 0 3
32504: ARRAY
32505: PUSH
32506: LD_INT 2
32508: ARRAY
32509: PPUSH
32510: LD_EXP 66
32514: PUSH
32515: LD_VAR 0 2
32519: ARRAY
32520: PUSH
32521: LD_VAR 0 3
32525: ARRAY
32526: PUSH
32527: LD_INT 3
32529: ARRAY
32530: PPUSH
32531: LD_INT 30
32533: PPUSH
32534: CALL 56167 0 4
32538: PUSH
32539: LD_INT 4
32541: ARRAY
32542: PUSH
32543: LD_INT 0
32545: EQUAL
32546: IFFALSE 32572
// begin target := mc_crates [ i ] [ j ] ;
32548: LD_ADDR_VAR 0 7
32552: PUSH
32553: LD_EXP 66
32557: PUSH
32558: LD_VAR 0 2
32562: ARRAY
32563: PUSH
32564: LD_VAR 0 3
32568: ARRAY
32569: ST_TO_ADDR
// break ;
32570: GO 32574
// end ; end ;
32572: GO 32326
32574: POP
32575: POP
// if not target then
32576: LD_VAR 0 7
32580: NOT
32581: IFFALSE 32585
// continue ;
32583: GO 32129
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32585: LD_ADDR_VAR 0 8
32589: PUSH
32590: LD_EXP 69
32594: PUSH
32595: LD_VAR 0 2
32599: ARRAY
32600: PPUSH
32601: LD_INT 2
32603: PUSH
32604: LD_INT 3
32606: PUSH
32607: LD_INT 58
32609: PUSH
32610: EMPTY
32611: LIST
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 61
32619: PUSH
32620: EMPTY
32621: LIST
32622: PUSH
32623: LD_INT 33
32625: PUSH
32626: LD_INT 5
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 33
32635: PUSH
32636: LD_INT 3
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 2
32652: PUSH
32653: LD_INT 34
32655: PUSH
32656: LD_INT 32
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 34
32665: PUSH
32666: LD_INT 51
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 34
32675: PUSH
32676: LD_INT 12
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PPUSH
32693: CALL_OW 72
32697: ST_TO_ADDR
// if not cargo then
32698: LD_VAR 0 8
32702: NOT
32703: IFFALSE 33417
// begin if mc_crates_collector [ i ] < 5 then
32705: LD_EXP 67
32709: PUSH
32710: LD_VAR 0 2
32714: ARRAY
32715: PUSH
32716: LD_INT 5
32718: LESS
32719: IFFALSE 33089
// begin if mc_ape [ i ] then
32721: LD_EXP 79
32725: PUSH
32726: LD_VAR 0 2
32730: ARRAY
32731: IFFALSE 32778
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32733: LD_ADDR_VAR 0 5
32737: PUSH
32738: LD_EXP 79
32742: PUSH
32743: LD_VAR 0 2
32747: ARRAY
32748: PPUSH
32749: LD_INT 25
32751: PUSH
32752: LD_INT 16
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 24
32761: PUSH
32762: LD_INT 750
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PPUSH
32773: CALL_OW 72
32777: ST_TO_ADDR
// if not tmp then
32778: LD_VAR 0 5
32782: NOT
32783: IFFALSE 32830
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32785: LD_ADDR_VAR 0 5
32789: PUSH
32790: LD_EXP 50
32794: PUSH
32795: LD_VAR 0 2
32799: ARRAY
32800: PPUSH
32801: LD_INT 25
32803: PUSH
32804: LD_INT 2
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 24
32813: PUSH
32814: LD_INT 750
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PPUSH
32825: CALL_OW 72
32829: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32830: LD_EXP 79
32834: PUSH
32835: LD_VAR 0 2
32839: ARRAY
32840: IFFALSE 32883
32842: PUSH
32843: LD_EXP 50
32847: PUSH
32848: LD_VAR 0 2
32852: ARRAY
32853: PPUSH
32854: LD_INT 25
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 24
32866: PUSH
32867: LD_INT 750
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PPUSH
32878: CALL_OW 72
32882: AND
32883: IFFALSE 32895
32885: PUSH
32886: LD_VAR 0 5
32890: PUSH
32891: LD_INT 5
32893: LESS
32894: AND
32895: IFFALSE 32977
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32897: LD_ADDR_VAR 0 3
32901: PUSH
32902: LD_EXP 50
32906: PUSH
32907: LD_VAR 0 2
32911: ARRAY
32912: PPUSH
32913: LD_INT 25
32915: PUSH
32916: LD_INT 2
32918: PUSH
32919: EMPTY
32920: LIST
32921: LIST
32922: PUSH
32923: LD_INT 24
32925: PUSH
32926: LD_INT 750
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PPUSH
32937: CALL_OW 72
32941: PUSH
32942: FOR_IN
32943: IFFALSE 32975
// begin tmp := tmp union j ;
32945: LD_ADDR_VAR 0 5
32949: PUSH
32950: LD_VAR 0 5
32954: PUSH
32955: LD_VAR 0 3
32959: UNION
32960: ST_TO_ADDR
// if tmp >= 5 then
32961: LD_VAR 0 5
32965: PUSH
32966: LD_INT 5
32968: GREATEREQUAL
32969: IFFALSE 32973
// break ;
32971: GO 32975
// end ;
32973: GO 32942
32975: POP
32976: POP
// end ; if not tmp then
32977: LD_VAR 0 5
32981: NOT
32982: IFFALSE 32986
// continue ;
32984: GO 32129
// for j in tmp do
32986: LD_ADDR_VAR 0 3
32990: PUSH
32991: LD_VAR 0 5
32995: PUSH
32996: FOR_IN
32997: IFFALSE 33087
// if not GetTag ( j ) then
32999: LD_VAR 0 3
33003: PPUSH
33004: CALL_OW 110
33008: NOT
33009: IFFALSE 33085
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
33011: LD_ADDR_EXP 67
33015: PUSH
33016: LD_EXP 67
33020: PPUSH
33021: LD_VAR 0 2
33025: PUSH
33026: LD_EXP 67
33030: PUSH
33031: LD_VAR 0 2
33035: ARRAY
33036: PUSH
33037: LD_INT 1
33039: PLUS
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PPUSH
33045: LD_VAR 0 3
33049: PPUSH
33050: CALL 54897 0 3
33054: ST_TO_ADDR
// SetTag ( j , 107 ) ;
33055: LD_VAR 0 3
33059: PPUSH
33060: LD_INT 107
33062: PPUSH
33063: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
33067: LD_EXP 67
33071: PUSH
33072: LD_VAR 0 2
33076: ARRAY
33077: PUSH
33078: LD_INT 5
33080: GREATEREQUAL
33081: IFFALSE 33085
// break ;
33083: GO 33087
// end ;
33085: GO 32996
33087: POP
33088: POP
// end ; if mc_crates_collector [ i ] and target then
33089: LD_EXP 67
33093: PUSH
33094: LD_VAR 0 2
33098: ARRAY
33099: IFFALSE 33107
33101: PUSH
33102: LD_VAR 0 7
33106: AND
33107: IFFALSE 33415
// begin if mc_crates_collector [ i ] < target [ 1 ] then
33109: LD_EXP 67
33113: PUSH
33114: LD_VAR 0 2
33118: ARRAY
33119: PUSH
33120: LD_VAR 0 7
33124: PUSH
33125: LD_INT 1
33127: ARRAY
33128: LESS
33129: IFFALSE 33149
// tmp := mc_crates_collector [ i ] else
33131: LD_ADDR_VAR 0 5
33135: PUSH
33136: LD_EXP 67
33140: PUSH
33141: LD_VAR 0 2
33145: ARRAY
33146: ST_TO_ADDR
33147: GO 33163
// tmp := target [ 1 ] ;
33149: LD_ADDR_VAR 0 5
33153: PUSH
33154: LD_VAR 0 7
33158: PUSH
33159: LD_INT 1
33161: ARRAY
33162: ST_TO_ADDR
// k := 0 ;
33163: LD_ADDR_VAR 0 4
33167: PUSH
33168: LD_INT 0
33170: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
33171: LD_ADDR_VAR 0 3
33175: PUSH
33176: LD_EXP 67
33180: PUSH
33181: LD_VAR 0 2
33185: ARRAY
33186: PUSH
33187: FOR_IN
33188: IFFALSE 33413
// begin k := k + 1 ;
33190: LD_ADDR_VAR 0 4
33194: PUSH
33195: LD_VAR 0 4
33199: PUSH
33200: LD_INT 1
33202: PLUS
33203: ST_TO_ADDR
// if k > tmp then
33204: LD_VAR 0 4
33208: PUSH
33209: LD_VAR 0 5
33213: GREATER
33214: IFFALSE 33218
// break ;
33216: GO 33413
// if not GetClass ( j ) in [ 2 , 16 ] then
33218: LD_VAR 0 3
33222: PPUSH
33223: CALL_OW 257
33227: PUSH
33228: LD_INT 2
33230: PUSH
33231: LD_INT 16
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: IN
33238: NOT
33239: IFFALSE 33292
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
33241: LD_ADDR_EXP 67
33245: PUSH
33246: LD_EXP 67
33250: PPUSH
33251: LD_VAR 0 2
33255: PPUSH
33256: LD_EXP 67
33260: PUSH
33261: LD_VAR 0 2
33265: ARRAY
33266: PUSH
33267: LD_VAR 0 3
33271: DIFF
33272: PPUSH
33273: CALL_OW 1
33277: ST_TO_ADDR
// SetTag ( j , 0 ) ;
33278: LD_VAR 0 3
33282: PPUSH
33283: LD_INT 0
33285: PPUSH
33286: CALL_OW 109
// continue ;
33290: GO 33187
// end ; if IsInUnit ( j ) then
33292: LD_VAR 0 3
33296: PPUSH
33297: CALL_OW 310
33301: IFFALSE 33312
// ComExitBuilding ( j ) ;
33303: LD_VAR 0 3
33307: PPUSH
33308: CALL_OW 122
// wait ( 3 ) ;
33312: LD_INT 3
33314: PPUSH
33315: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
33319: LD_VAR 0 3
33323: PPUSH
33324: CALL_OW 314
33328: IFFALSE 33366
33330: PUSH
33331: LD_VAR 0 6
33335: PPUSH
33336: LD_VAR 0 7
33340: PUSH
33341: LD_INT 2
33343: ARRAY
33344: PPUSH
33345: LD_VAR 0 7
33349: PUSH
33350: LD_INT 3
33352: ARRAY
33353: PPUSH
33354: LD_INT 30
33356: PPUSH
33357: CALL 56167 0 4
33361: PUSH
33362: LD_INT 4
33364: ARRAY
33365: AND
33366: IFFALSE 33384
// ComStandNearbyBuilding ( j , depot ) else
33368: LD_VAR 0 3
33372: PPUSH
33373: LD_VAR 0 9
33377: PPUSH
33378: CALL 51439 0 2
33382: GO 33411
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33384: LD_VAR 0 3
33388: PPUSH
33389: LD_VAR 0 7
33393: PUSH
33394: LD_INT 2
33396: ARRAY
33397: PPUSH
33398: LD_VAR 0 7
33402: PUSH
33403: LD_INT 3
33405: ARRAY
33406: PPUSH
33407: CALL_OW 117
// end ;
33411: GO 33187
33413: POP
33414: POP
// end ; end else
33415: GO 33957
// begin for j in cargo do
33417: LD_ADDR_VAR 0 3
33421: PUSH
33422: LD_VAR 0 8
33426: PUSH
33427: FOR_IN
33428: IFFALSE 33955
// begin if GetTag ( j ) <> 0 then
33430: LD_VAR 0 3
33434: PPUSH
33435: CALL_OW 110
33439: PUSH
33440: LD_INT 0
33442: NONEQUAL
33443: IFFALSE 33447
// continue ;
33445: GO 33427
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33447: LD_VAR 0 3
33451: PPUSH
33452: CALL_OW 256
33456: PUSH
33457: LD_INT 1000
33459: LESS
33460: IFFALSE 33485
33462: PUSH
33463: LD_VAR 0 3
33467: PPUSH
33468: LD_EXP 74
33472: PUSH
33473: LD_VAR 0 2
33477: ARRAY
33478: PPUSH
33479: CALL_OW 308
33483: NOT
33484: AND
33485: IFFALSE 33507
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33487: LD_VAR 0 3
33491: PPUSH
33492: LD_EXP 74
33496: PUSH
33497: LD_VAR 0 2
33501: ARRAY
33502: PPUSH
33503: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33507: LD_VAR 0 3
33511: PPUSH
33512: CALL_OW 256
33516: PUSH
33517: LD_INT 1000
33519: LESS
33520: IFFALSE 33544
33522: PUSH
33523: LD_VAR 0 3
33527: PPUSH
33528: LD_EXP 74
33532: PUSH
33533: LD_VAR 0 2
33537: ARRAY
33538: PPUSH
33539: CALL_OW 308
33543: AND
33544: IFFALSE 33548
// continue ;
33546: GO 33427
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33548: LD_VAR 0 3
33552: PPUSH
33553: CALL_OW 262
33557: PUSH
33558: LD_INT 2
33560: EQUAL
33561: IFFALSE 33578
33563: PUSH
33564: LD_VAR 0 3
33568: PPUSH
33569: CALL_OW 261
33573: PUSH
33574: LD_INT 15
33576: LESS
33577: AND
33578: IFFALSE 33582
// continue ;
33580: GO 33427
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33582: LD_VAR 0 3
33586: PPUSH
33587: CALL_OW 262
33591: PUSH
33592: LD_INT 1
33594: EQUAL
33595: IFFALSE 33612
33597: PUSH
33598: LD_VAR 0 3
33602: PPUSH
33603: CALL_OW 261
33607: PUSH
33608: LD_INT 10
33610: LESS
33611: AND
33612: IFFALSE 33892
// begin if not depot then
33614: LD_VAR 0 9
33618: NOT
33619: IFFALSE 33623
// continue ;
33621: GO 33427
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33623: LD_VAR 0 3
33627: PPUSH
33628: LD_VAR 0 9
33632: PPUSH
33633: LD_VAR 0 3
33637: PPUSH
33638: CALL_OW 74
33642: PPUSH
33643: CALL_OW 296
33647: PUSH
33648: LD_INT 6
33650: LESS
33651: IFFALSE 33667
// SetFuel ( j , 100 ) else
33653: LD_VAR 0 3
33657: PPUSH
33658: LD_INT 100
33660: PPUSH
33661: CALL_OW 240
33665: GO 33892
// if GetFuel ( j ) = 0 then
33667: LD_VAR 0 3
33671: PPUSH
33672: CALL_OW 261
33676: PUSH
33677: LD_INT 0
33679: EQUAL
33680: IFFALSE 33892
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33682: LD_ADDR_EXP 69
33686: PUSH
33687: LD_EXP 69
33691: PPUSH
33692: LD_VAR 0 2
33696: PPUSH
33697: LD_EXP 69
33701: PUSH
33702: LD_VAR 0 2
33706: ARRAY
33707: PUSH
33708: LD_VAR 0 3
33712: DIFF
33713: PPUSH
33714: CALL_OW 1
33718: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33719: LD_VAR 0 3
33723: PPUSH
33724: CALL_OW 263
33728: PUSH
33729: LD_INT 1
33731: EQUAL
33732: IFFALSE 33748
// ComExitVehicle ( IsInUnit ( j ) ) ;
33734: LD_VAR 0 3
33738: PPUSH
33739: CALL_OW 310
33743: PPUSH
33744: CALL_OW 121
// if GetControl ( j ) = control_remote then
33748: LD_VAR 0 3
33752: PPUSH
33753: CALL_OW 263
33757: PUSH
33758: LD_INT 2
33760: EQUAL
33761: IFFALSE 33772
// ComUnlink ( j ) ;
33763: LD_VAR 0 3
33767: PPUSH
33768: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33772: LD_ADDR_VAR 0 10
33776: PUSH
33777: LD_VAR 0 2
33781: PPUSH
33782: LD_INT 3
33784: PPUSH
33785: CALL 43686 0 2
33789: ST_TO_ADDR
// if fac then
33790: LD_VAR 0 10
33794: IFFALSE 33890
// begin for k in fac do
33796: LD_ADDR_VAR 0 4
33800: PUSH
33801: LD_VAR 0 10
33805: PUSH
33806: FOR_IN
33807: IFFALSE 33888
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33809: LD_ADDR_VAR 0 11
33813: PUSH
33814: LD_VAR 0 10
33818: PPUSH
33819: LD_VAR 0 3
33823: PPUSH
33824: CALL_OW 265
33828: PPUSH
33829: LD_VAR 0 3
33833: PPUSH
33834: CALL_OW 262
33838: PPUSH
33839: LD_VAR 0 3
33843: PPUSH
33844: CALL_OW 263
33848: PPUSH
33849: LD_VAR 0 3
33853: PPUSH
33854: CALL_OW 264
33858: PPUSH
33859: CALL 52337 0 5
33863: ST_TO_ADDR
// if components then
33864: LD_VAR 0 11
33868: IFFALSE 33886
// begin MC_InsertProduceList ( i , components ) ;
33870: LD_VAR 0 2
33874: PPUSH
33875: LD_VAR 0 11
33879: PPUSH
33880: CALL 43231 0 2
// break ;
33884: GO 33888
// end ; end ;
33886: GO 33806
33888: POP
33889: POP
// end ; continue ;
33890: GO 33427
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33892: LD_VAR 0 3
33896: PPUSH
33897: LD_INT 1
33899: PPUSH
33900: CALL_OW 289
33904: PUSH
33905: LD_INT 100
33907: LESS
33908: IFFALSE 33922
33910: PUSH
33911: LD_VAR 0 3
33915: PPUSH
33916: CALL_OW 314
33920: NOT
33921: AND
33922: IFFALSE 33951
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33924: LD_VAR 0 3
33928: PPUSH
33929: LD_VAR 0 7
33933: PUSH
33934: LD_INT 2
33936: ARRAY
33937: PPUSH
33938: LD_VAR 0 7
33942: PUSH
33943: LD_INT 3
33945: ARRAY
33946: PPUSH
33947: CALL_OW 117
// break ;
33951: GO 33955
// end ;
33953: GO 33427
33955: POP
33956: POP
// end ; end ;
33957: GO 32129
33959: POP
33960: POP
// end ;
33961: LD_VAR 0 1
33965: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33966: LD_INT 0
33968: PPUSH
33969: PPUSH
33970: PPUSH
33971: PPUSH
// if not mc_bases then
33972: LD_EXP 50
33976: NOT
33977: IFFALSE 33981
// exit ;
33979: GO 34146
// for i = 1 to mc_bases do
33981: LD_ADDR_VAR 0 2
33985: PUSH
33986: DOUBLE
33987: LD_INT 1
33989: DEC
33990: ST_TO_ADDR
33991: LD_EXP 50
33995: PUSH
33996: FOR_TO
33997: IFFALSE 34144
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33999: LD_ADDR_VAR 0 4
34003: PUSH
34004: LD_EXP 69
34008: PUSH
34009: LD_VAR 0 2
34013: ARRAY
34014: PUSH
34015: LD_EXP 72
34019: PUSH
34020: LD_VAR 0 2
34024: ARRAY
34025: UNION
34026: PPUSH
34027: LD_INT 33
34029: PUSH
34030: LD_INT 2
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PPUSH
34037: CALL_OW 72
34041: ST_TO_ADDR
// if tmp then
34042: LD_VAR 0 4
34046: IFFALSE 34142
// for j in tmp do
34048: LD_ADDR_VAR 0 3
34052: PUSH
34053: LD_VAR 0 4
34057: PUSH
34058: FOR_IN
34059: IFFALSE 34140
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
34061: LD_VAR 0 3
34065: PPUSH
34066: CALL_OW 312
34070: NOT
34071: IFFALSE 34088
34073: PUSH
34074: LD_VAR 0 3
34078: PPUSH
34079: CALL_OW 256
34083: PUSH
34084: LD_INT 250
34086: GREATEREQUAL
34087: AND
34088: IFFALSE 34101
// Connect ( j ) else
34090: LD_VAR 0 3
34094: PPUSH
34095: CALL 58257 0 1
34099: GO 34138
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
34101: LD_VAR 0 3
34105: PPUSH
34106: CALL_OW 256
34110: PUSH
34111: LD_INT 250
34113: LESS
34114: IFFALSE 34127
34116: PUSH
34117: LD_VAR 0 3
34121: PPUSH
34122: CALL_OW 312
34126: AND
34127: IFFALSE 34138
// ComUnlink ( j ) ;
34129: LD_VAR 0 3
34133: PPUSH
34134: CALL_OW 136
34138: GO 34058
34140: POP
34141: POP
// end ;
34142: GO 33996
34144: POP
34145: POP
// end ;
34146: LD_VAR 0 1
34150: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
34151: LD_INT 0
34153: PPUSH
34154: PPUSH
34155: PPUSH
34156: PPUSH
34157: PPUSH
// if not mc_bases then
34158: LD_EXP 50
34162: NOT
34163: IFFALSE 34167
// exit ;
34165: GO 34616
// for i = 1 to mc_bases do
34167: LD_ADDR_VAR 0 2
34171: PUSH
34172: DOUBLE
34173: LD_INT 1
34175: DEC
34176: ST_TO_ADDR
34177: LD_EXP 50
34181: PUSH
34182: FOR_TO
34183: IFFALSE 34614
// begin if not mc_produce [ i ] then
34185: LD_EXP 71
34189: PUSH
34190: LD_VAR 0 2
34194: ARRAY
34195: NOT
34196: IFFALSE 34200
// continue ;
34198: GO 34182
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34200: LD_ADDR_VAR 0 5
34204: PUSH
34205: LD_EXP 50
34209: PUSH
34210: LD_VAR 0 2
34214: ARRAY
34215: PPUSH
34216: LD_INT 30
34218: PUSH
34219: LD_INT 3
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PPUSH
34226: CALL_OW 72
34230: ST_TO_ADDR
// if not fac then
34231: LD_VAR 0 5
34235: NOT
34236: IFFALSE 34240
// continue ;
34238: GO 34182
// for j in fac do
34240: LD_ADDR_VAR 0 3
34244: PUSH
34245: LD_VAR 0 5
34249: PUSH
34250: FOR_IN
34251: IFFALSE 34610
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
34253: LD_VAR 0 3
34257: PPUSH
34258: CALL_OW 461
34262: PUSH
34263: LD_INT 2
34265: NONEQUAL
34266: IFTRUE 34286
34268: PUSH
34269: LD_VAR 0 3
34273: PPUSH
34274: LD_INT 15
34276: PPUSH
34277: CALL 57876 0 2
34281: PUSH
34282: LD_INT 4
34284: ARRAY
34285: OR
34286: IFFALSE 34290
// continue ;
34288: GO 34250
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
34290: LD_VAR 0 3
34294: PPUSH
34295: LD_EXP 71
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_INT 1
34308: ARRAY
34309: PUSH
34310: LD_INT 1
34312: ARRAY
34313: PPUSH
34314: LD_EXP 71
34318: PUSH
34319: LD_VAR 0 2
34323: ARRAY
34324: PUSH
34325: LD_INT 1
34327: ARRAY
34328: PUSH
34329: LD_INT 2
34331: ARRAY
34332: PPUSH
34333: LD_EXP 71
34337: PUSH
34338: LD_VAR 0 2
34342: ARRAY
34343: PUSH
34344: LD_INT 1
34346: ARRAY
34347: PUSH
34348: LD_INT 3
34350: ARRAY
34351: PPUSH
34352: LD_EXP 71
34356: PUSH
34357: LD_VAR 0 2
34361: ARRAY
34362: PUSH
34363: LD_INT 1
34365: ARRAY
34366: PUSH
34367: LD_INT 4
34369: ARRAY
34370: PPUSH
34371: CALL_OW 448
34375: IFFALSE 34470
34377: PUSH
34378: LD_VAR 0 3
34382: PPUSH
34383: LD_EXP 71
34387: PUSH
34388: LD_VAR 0 2
34392: ARRAY
34393: PUSH
34394: LD_INT 1
34396: ARRAY
34397: PUSH
34398: LD_INT 1
34400: ARRAY
34401: PUSH
34402: LD_EXP 71
34406: PUSH
34407: LD_VAR 0 2
34411: ARRAY
34412: PUSH
34413: LD_INT 1
34415: ARRAY
34416: PUSH
34417: LD_INT 2
34419: ARRAY
34420: PUSH
34421: LD_EXP 71
34425: PUSH
34426: LD_VAR 0 2
34430: ARRAY
34431: PUSH
34432: LD_INT 1
34434: ARRAY
34435: PUSH
34436: LD_INT 3
34438: ARRAY
34439: PUSH
34440: LD_EXP 71
34444: PUSH
34445: LD_VAR 0 2
34449: ARRAY
34450: PUSH
34451: LD_INT 1
34453: ARRAY
34454: PUSH
34455: LD_INT 4
34457: ARRAY
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: PPUSH
34465: CALL 61690 0 2
34469: AND
34470: IFFALSE 34608
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34472: LD_VAR 0 3
34476: PPUSH
34477: LD_EXP 71
34481: PUSH
34482: LD_VAR 0 2
34486: ARRAY
34487: PUSH
34488: LD_INT 1
34490: ARRAY
34491: PUSH
34492: LD_INT 1
34494: ARRAY
34495: PPUSH
34496: LD_EXP 71
34500: PUSH
34501: LD_VAR 0 2
34505: ARRAY
34506: PUSH
34507: LD_INT 1
34509: ARRAY
34510: PUSH
34511: LD_INT 2
34513: ARRAY
34514: PPUSH
34515: LD_EXP 71
34519: PUSH
34520: LD_VAR 0 2
34524: ARRAY
34525: PUSH
34526: LD_INT 1
34528: ARRAY
34529: PUSH
34530: LD_INT 3
34532: ARRAY
34533: PPUSH
34534: LD_EXP 71
34538: PUSH
34539: LD_VAR 0 2
34543: ARRAY
34544: PUSH
34545: LD_INT 1
34547: ARRAY
34548: PUSH
34549: LD_INT 4
34551: ARRAY
34552: PPUSH
34553: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34557: LD_ADDR_VAR 0 4
34561: PUSH
34562: LD_EXP 71
34566: PUSH
34567: LD_VAR 0 2
34571: ARRAY
34572: PPUSH
34573: LD_INT 1
34575: PPUSH
34576: CALL_OW 3
34580: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34581: LD_ADDR_EXP 71
34585: PUSH
34586: LD_EXP 71
34590: PPUSH
34591: LD_VAR 0 2
34595: PPUSH
34596: LD_VAR 0 4
34600: PPUSH
34601: CALL_OW 1
34605: ST_TO_ADDR
// break ;
34606: GO 34610
// end ; end ;
34608: GO 34250
34610: POP
34611: POP
// end ;
34612: GO 34182
34614: POP
34615: POP
// end ;
34616: LD_VAR 0 1
34620: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34621: LD_INT 0
34623: PPUSH
34624: PPUSH
34625: PPUSH
// if not mc_bases then
34626: LD_EXP 50
34630: NOT
34631: IFFALSE 34635
// exit ;
34633: GO 34724
// for i = 1 to mc_bases do
34635: LD_ADDR_VAR 0 2
34639: PUSH
34640: DOUBLE
34641: LD_INT 1
34643: DEC
34644: ST_TO_ADDR
34645: LD_EXP 50
34649: PUSH
34650: FOR_TO
34651: IFFALSE 34722
// begin if mc_attack [ i ] then
34653: LD_EXP 70
34657: PUSH
34658: LD_VAR 0 2
34662: ARRAY
34663: IFFALSE 34720
// begin tmp := mc_attack [ i ] [ 1 ] ;
34665: LD_ADDR_VAR 0 3
34669: PUSH
34670: LD_EXP 70
34674: PUSH
34675: LD_VAR 0 2
34679: ARRAY
34680: PUSH
34681: LD_INT 1
34683: ARRAY
34684: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34685: LD_ADDR_EXP 70
34689: PUSH
34690: LD_EXP 70
34694: PPUSH
34695: LD_VAR 0 2
34699: PPUSH
34700: EMPTY
34701: PPUSH
34702: CALL_OW 1
34706: ST_TO_ADDR
// Attack ( tmp ) ;
34707: LD_VAR 0 3
34711: PPUSH
34712: CALL 115762 0 1
// exit ;
34716: POP
34717: POP
34718: GO 34724
// end ; end ;
34720: GO 34650
34722: POP
34723: POP
// end ;
34724: LD_VAR 0 1
34728: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34729: LD_INT 0
34731: PPUSH
34732: PPUSH
34733: PPUSH
34734: PPUSH
34735: PPUSH
34736: PPUSH
34737: PPUSH
// if not mc_bases then
34738: LD_EXP 50
34742: NOT
34743: IFFALSE 34747
// exit ;
34745: GO 35624
// for i = 1 to mc_bases do
34747: LD_ADDR_VAR 0 2
34751: PUSH
34752: DOUBLE
34753: LD_INT 1
34755: DEC
34756: ST_TO_ADDR
34757: LD_EXP 50
34761: PUSH
34762: FOR_TO
34763: IFFALSE 35622
// begin if not mc_bases [ i ] then
34765: LD_EXP 50
34769: PUSH
34770: LD_VAR 0 2
34774: ARRAY
34775: NOT
34776: IFFALSE 34780
// continue ;
34778: GO 34762
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34780: LD_ADDR_VAR 0 7
34784: PUSH
34785: LD_EXP 50
34789: PUSH
34790: LD_VAR 0 2
34794: ARRAY
34795: PUSH
34796: LD_INT 1
34798: ARRAY
34799: PPUSH
34800: CALL 51663 0 1
34804: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34805: LD_ADDR_EXP 73
34809: PUSH
34810: LD_EXP 73
34814: PPUSH
34815: LD_VAR 0 2
34819: PPUSH
34820: LD_EXP 50
34824: PUSH
34825: LD_VAR 0 2
34829: ARRAY
34830: PUSH
34831: LD_INT 1
34833: ARRAY
34834: PPUSH
34835: CALL_OW 255
34839: PPUSH
34840: LD_EXP 75
34844: PUSH
34845: LD_VAR 0 2
34849: ARRAY
34850: PPUSH
34851: CALL 51628 0 2
34855: PPUSH
34856: CALL_OW 1
34860: ST_TO_ADDR
// if not mc_scan [ i ] then
34861: LD_EXP 73
34865: PUSH
34866: LD_VAR 0 2
34870: ARRAY
34871: NOT
34872: IFFALSE 35056
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34874: LD_ADDR_EXP 93
34878: PUSH
34879: LD_EXP 93
34883: PPUSH
34884: LD_VAR 0 2
34888: PPUSH
34889: LD_INT 0
34891: PPUSH
34892: CALL_OW 1
34896: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34897: LD_ADDR_VAR 0 4
34901: PUSH
34902: LD_EXP 50
34906: PUSH
34907: LD_VAR 0 2
34911: ARRAY
34912: PPUSH
34913: LD_INT 2
34915: PUSH
34916: LD_INT 25
34918: PUSH
34919: LD_INT 5
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 25
34928: PUSH
34929: LD_INT 8
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 25
34938: PUSH
34939: LD_INT 9
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: PPUSH
34952: CALL_OW 72
34956: ST_TO_ADDR
// if not tmp then
34957: LD_VAR 0 4
34961: NOT
34962: IFFALSE 34966
// continue ;
34964: GO 34762
// for j in tmp do
34966: LD_ADDR_VAR 0 3
34970: PUSH
34971: LD_VAR 0 4
34975: PUSH
34976: FOR_IN
34977: IFFALSE 35054
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34979: LD_VAR 0 3
34983: PPUSH
34984: CALL_OW 310
34988: PPUSH
34989: CALL_OW 266
34993: PUSH
34994: LD_INT 5
34996: EQUAL
34997: IFFALSE 35014
34999: PUSH
35000: LD_VAR 0 3
35004: PPUSH
35005: CALL_OW 257
35009: PUSH
35010: LD_INT 1
35012: EQUAL
35013: AND
35014: IFFALSE 35028
35016: PUSH
35017: LD_VAR 0 3
35021: PPUSH
35022: CALL_OW 459
35026: NOT
35027: AND
35028: IFFALSE 35036
35030: PUSH
35031: LD_VAR 0 7
35035: AND
35036: IFFALSE 35052
// ComChangeProfession ( j , class ) ;
35038: LD_VAR 0 3
35042: PPUSH
35043: LD_VAR 0 7
35047: PPUSH
35048: CALL_OW 123
35052: GO 34976
35054: POP
35055: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
35056: LD_EXP 73
35060: PUSH
35061: LD_VAR 0 2
35065: ARRAY
35066: IFFALSE 35081
35068: PUSH
35069: LD_EXP 93
35073: PUSH
35074: LD_VAR 0 2
35078: ARRAY
35079: NOT
35080: AND
35081: IFFALSE 35096
35083: PUSH
35084: LD_EXP 72
35088: PUSH
35089: LD_VAR 0 2
35093: ARRAY
35094: NOT
35095: AND
35096: IFFALSE 35247
35098: PUSH
35099: LD_EXP 50
35103: PUSH
35104: LD_VAR 0 2
35108: ARRAY
35109: PPUSH
35110: LD_INT 50
35112: PUSH
35113: EMPTY
35114: LIST
35115: PUSH
35116: LD_INT 2
35118: PUSH
35119: LD_INT 30
35121: PUSH
35122: LD_INT 32
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 30
35131: PUSH
35132: LD_INT 33
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 30
35141: PUSH
35142: LD_INT 4
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 30
35151: PUSH
35152: LD_INT 5
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: LIST
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PPUSH
35170: CALL_OW 72
35174: PUSH
35175: LD_INT 4
35177: LESS
35178: IFTRUE 35246
35180: PUSH
35181: LD_EXP 50
35185: PUSH
35186: LD_VAR 0 2
35190: ARRAY
35191: PPUSH
35192: LD_INT 3
35194: PUSH
35195: LD_INT 24
35197: PUSH
35198: LD_INT 1000
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 2
35211: PUSH
35212: LD_INT 30
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 30
35224: PUSH
35225: LD_INT 1
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: LIST
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PPUSH
35241: CALL_OW 72
35245: OR
35246: AND
35247: IFFALSE 35500
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35249: LD_ADDR_EXP 93
35253: PUSH
35254: LD_EXP 93
35258: PPUSH
35259: LD_VAR 0 2
35263: PPUSH
35264: LD_INT 1
35266: PPUSH
35267: CALL_OW 1
35271: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35272: LD_ADDR_VAR 0 4
35276: PUSH
35277: LD_EXP 50
35281: PUSH
35282: LD_VAR 0 2
35286: ARRAY
35287: PPUSH
35288: LD_INT 2
35290: PUSH
35291: LD_INT 25
35293: PUSH
35294: LD_INT 1
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 25
35303: PUSH
35304: LD_INT 5
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 25
35313: PUSH
35314: LD_INT 8
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 25
35323: PUSH
35324: LD_INT 9
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: PPUSH
35338: CALL_OW 72
35342: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
35343: LD_ADDR_VAR 0 4
35347: PUSH
35348: LD_VAR 0 4
35352: PUSH
35353: LD_VAR 0 4
35357: PPUSH
35358: LD_INT 18
35360: PPUSH
35361: CALL 85500 0 2
35365: DIFF
35366: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
35367: LD_VAR 0 4
35371: NOT
35372: IFFALSE 35420
35374: PUSH
35375: LD_EXP 50
35379: PUSH
35380: LD_VAR 0 2
35384: ARRAY
35385: PPUSH
35386: LD_INT 2
35388: PUSH
35389: LD_INT 30
35391: PUSH
35392: LD_INT 4
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 30
35401: PUSH
35402: LD_INT 5
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: LIST
35413: PPUSH
35414: CALL_OW 72
35418: NOT
35419: AND
35420: IFFALSE 35482
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
35422: LD_ADDR_VAR 0 4
35426: PUSH
35427: LD_EXP 50
35431: PUSH
35432: LD_VAR 0 2
35436: ARRAY
35437: PPUSH
35438: LD_INT 2
35440: PUSH
35441: LD_INT 25
35443: PUSH
35444: LD_INT 2
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: LD_INT 25
35453: PUSH
35454: LD_INT 3
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 25
35463: PUSH
35464: LD_INT 4
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: PPUSH
35477: CALL_OW 72
35481: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35482: LD_VAR 0 2
35486: PPUSH
35487: LD_VAR 0 4
35491: PPUSH
35492: CALL 120531 0 2
// exit ;
35496: POP
35497: POP
35498: GO 35624
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35500: LD_EXP 73
35504: PUSH
35505: LD_VAR 0 2
35509: ARRAY
35510: IFFALSE 35525
35512: PUSH
35513: LD_EXP 93
35517: PUSH
35518: LD_VAR 0 2
35522: ARRAY
35523: NOT
35524: AND
35525: IFFALSE 35539
35527: PUSH
35528: LD_EXP 72
35532: PUSH
35533: LD_VAR 0 2
35537: ARRAY
35538: AND
35539: IFFALSE 35620
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35541: LD_ADDR_EXP 93
35545: PUSH
35546: LD_EXP 93
35550: PPUSH
35551: LD_VAR 0 2
35555: PPUSH
35556: LD_INT 1
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35564: LD_ADDR_VAR 0 4
35568: PUSH
35569: LD_EXP 72
35573: PUSH
35574: LD_VAR 0 2
35578: ARRAY
35579: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35580: LD_ADDR_EXP 72
35584: PUSH
35585: LD_EXP 72
35589: PPUSH
35590: LD_VAR 0 2
35594: PPUSH
35595: EMPTY
35596: PPUSH
35597: CALL_OW 1
35601: ST_TO_ADDR
// Defend ( i , tmp ) ;
35602: LD_VAR 0 2
35606: PPUSH
35607: LD_VAR 0 4
35611: PPUSH
35612: CALL 121135 0 2
// exit ;
35616: POP
35617: POP
35618: GO 35624
// end ; end ;
35620: GO 34762
35622: POP
35623: POP
// end ;
35624: LD_VAR 0 1
35628: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35629: LD_INT 0
35631: PPUSH
35632: PPUSH
35633: PPUSH
35634: PPUSH
35635: PPUSH
35636: PPUSH
35637: PPUSH
35638: PPUSH
35639: PPUSH
35640: PPUSH
35641: PPUSH
// if not mc_bases then
35642: LD_EXP 50
35646: NOT
35647: IFFALSE 35651
// exit ;
35649: GO 36764
// for i = 1 to mc_bases do
35651: LD_ADDR_VAR 0 2
35655: PUSH
35656: DOUBLE
35657: LD_INT 1
35659: DEC
35660: ST_TO_ADDR
35661: LD_EXP 50
35665: PUSH
35666: FOR_TO
35667: IFFALSE 36762
// begin tmp := mc_lab [ i ] ;
35669: LD_ADDR_VAR 0 6
35673: PUSH
35674: LD_EXP 83
35678: PUSH
35679: LD_VAR 0 2
35683: ARRAY
35684: ST_TO_ADDR
// if not tmp then
35685: LD_VAR 0 6
35689: NOT
35690: IFFALSE 35694
// continue ;
35692: GO 35666
// idle_lab := 0 ;
35694: LD_ADDR_VAR 0 11
35698: PUSH
35699: LD_INT 0
35701: ST_TO_ADDR
// for j in tmp do
35702: LD_ADDR_VAR 0 3
35706: PUSH
35707: LD_VAR 0 6
35711: PUSH
35712: FOR_IN
35713: IFFALSE 36758
// begin researching := false ;
35715: LD_ADDR_VAR 0 10
35719: PUSH
35720: LD_INT 0
35722: ST_TO_ADDR
// side := GetSide ( j ) ;
35723: LD_ADDR_VAR 0 4
35727: PUSH
35728: LD_VAR 0 3
35732: PPUSH
35733: CALL_OW 255
35737: ST_TO_ADDR
// if not mc_tech [ side ] then
35738: LD_EXP 77
35742: PUSH
35743: LD_VAR 0 4
35747: ARRAY
35748: NOT
35749: IFFALSE 35753
// continue ;
35751: GO 35712
// if BuildingStatus ( j ) = bs_idle then
35753: LD_VAR 0 3
35757: PPUSH
35758: CALL_OW 461
35762: PUSH
35763: LD_INT 2
35765: EQUAL
35766: IFFALSE 35958
// begin if idle_lab and UnitsInside ( j ) < 6 then
35768: LD_VAR 0 11
35772: IFFALSE 35789
35774: PUSH
35775: LD_VAR 0 3
35779: PPUSH
35780: CALL_OW 313
35784: PUSH
35785: LD_INT 6
35787: LESS
35788: AND
35789: IFFALSE 35860
// begin tmp2 := UnitsInside ( idle_lab ) ;
35791: LD_ADDR_VAR 0 9
35795: PUSH
35796: LD_VAR 0 11
35800: PPUSH
35801: CALL_OW 313
35805: ST_TO_ADDR
// if tmp2 then
35806: LD_VAR 0 9
35810: IFFALSE 35852
// for x in tmp2 do
35812: LD_ADDR_VAR 0 7
35816: PUSH
35817: LD_VAR 0 9
35821: PUSH
35822: FOR_IN
35823: IFFALSE 35850
// begin ComExitBuilding ( x ) ;
35825: LD_VAR 0 7
35829: PPUSH
35830: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35834: LD_VAR 0 7
35838: PPUSH
35839: LD_VAR 0 3
35843: PPUSH
35844: CALL_OW 180
// end ;
35848: GO 35822
35850: POP
35851: POP
// idle_lab := 0 ;
35852: LD_ADDR_VAR 0 11
35856: PUSH
35857: LD_INT 0
35859: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35860: LD_ADDR_VAR 0 5
35864: PUSH
35865: LD_EXP 77
35869: PUSH
35870: LD_VAR 0 4
35874: ARRAY
35875: PUSH
35876: FOR_IN
35877: IFFALSE 35939
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35879: LD_VAR 0 3
35883: PPUSH
35884: LD_VAR 0 5
35888: PPUSH
35889: CALL_OW 430
35893: IFFALSE 35911
35895: PUSH
35896: LD_VAR 0 4
35900: PPUSH
35901: LD_VAR 0 5
35905: PPUSH
35906: CALL 50723 0 2
35910: AND
35911: IFFALSE 35937
// begin researching := true ;
35913: LD_ADDR_VAR 0 10
35917: PUSH
35918: LD_INT 1
35920: ST_TO_ADDR
// ComResearch ( j , t ) ;
35921: LD_VAR 0 3
35925: PPUSH
35926: LD_VAR 0 5
35930: PPUSH
35931: CALL_OW 124
// break ;
35935: GO 35939
// end ;
35937: GO 35876
35939: POP
35940: POP
// if not researching then
35941: LD_VAR 0 10
35945: NOT
35946: IFFALSE 35958
// idle_lab := j ;
35948: LD_ADDR_VAR 0 11
35952: PUSH
35953: LD_VAR 0 3
35957: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35958: LD_VAR 0 3
35962: PPUSH
35963: CALL_OW 461
35967: PUSH
35968: LD_INT 10
35970: EQUAL
35971: IFFALSE 36577
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35973: LD_EXP 79
35977: PUSH
35978: LD_VAR 0 2
35982: ARRAY
35983: NOT
35984: IFFALSE 35999
35986: PUSH
35987: LD_EXP 80
35991: PUSH
35992: LD_VAR 0 2
35996: ARRAY
35997: NOT
35998: AND
35999: IFFALSE 36017
36001: PUSH
36002: LD_EXP 77
36006: PUSH
36007: LD_VAR 0 4
36011: ARRAY
36012: PUSH
36013: LD_INT 1
36015: GREATER
36016: AND
36017: IFFALSE 36148
// begin ComCancel ( j ) ;
36019: LD_VAR 0 3
36023: PPUSH
36024: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36028: LD_ADDR_EXP 77
36032: PUSH
36033: LD_EXP 77
36037: PPUSH
36038: LD_VAR 0 4
36042: PPUSH
36043: LD_EXP 77
36047: PUSH
36048: LD_VAR 0 4
36052: ARRAY
36053: PPUSH
36054: LD_EXP 77
36058: PUSH
36059: LD_VAR 0 4
36063: ARRAY
36064: PUSH
36065: LD_INT 1
36067: MINUS
36068: PPUSH
36069: LD_EXP 77
36073: PUSH
36074: LD_VAR 0 4
36078: ARRAY
36079: PPUSH
36080: LD_INT 0
36082: PPUSH
36083: CALL 54305 0 4
36087: PPUSH
36088: CALL_OW 1
36092: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36093: LD_ADDR_EXP 77
36097: PUSH
36098: LD_EXP 77
36102: PPUSH
36103: LD_VAR 0 4
36107: PPUSH
36108: LD_EXP 77
36112: PUSH
36113: LD_VAR 0 4
36117: ARRAY
36118: PPUSH
36119: LD_EXP 77
36123: PUSH
36124: LD_VAR 0 4
36128: ARRAY
36129: PPUSH
36130: LD_INT 1
36132: PPUSH
36133: LD_INT 0
36135: PPUSH
36136: CALL 54305 0 4
36140: PPUSH
36141: CALL_OW 1
36145: ST_TO_ADDR
// continue ;
36146: GO 35712
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36148: LD_EXP 79
36152: PUSH
36153: LD_VAR 0 2
36157: ARRAY
36158: IFFALSE 36173
36160: PUSH
36161: LD_EXP 80
36165: PUSH
36166: LD_VAR 0 2
36170: ARRAY
36171: NOT
36172: AND
36173: IFFALSE 36300
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36175: LD_ADDR_EXP 80
36179: PUSH
36180: LD_EXP 80
36184: PPUSH
36185: LD_VAR 0 2
36189: PUSH
36190: LD_EXP 80
36194: PUSH
36195: LD_VAR 0 2
36199: ARRAY
36200: PUSH
36201: LD_INT 1
36203: PLUS
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PPUSH
36209: LD_EXP 79
36213: PUSH
36214: LD_VAR 0 2
36218: ARRAY
36219: PUSH
36220: LD_INT 1
36222: ARRAY
36223: PPUSH
36224: CALL 54897 0 3
36228: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
36229: LD_EXP 79
36233: PUSH
36234: LD_VAR 0 2
36238: ARRAY
36239: PUSH
36240: LD_INT 1
36242: ARRAY
36243: PPUSH
36244: LD_INT 112
36246: PPUSH
36247: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
36251: LD_ADDR_VAR 0 9
36255: PUSH
36256: LD_EXP 79
36260: PUSH
36261: LD_VAR 0 2
36265: ARRAY
36266: PPUSH
36267: LD_INT 1
36269: PPUSH
36270: CALL_OW 3
36274: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
36275: LD_ADDR_EXP 79
36279: PUSH
36280: LD_EXP 79
36284: PPUSH
36285: LD_VAR 0 2
36289: PPUSH
36290: LD_VAR 0 9
36294: PPUSH
36295: CALL_OW 1
36299: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
36300: LD_EXP 79
36304: PUSH
36305: LD_VAR 0 2
36309: ARRAY
36310: IFFALSE 36324
36312: PUSH
36313: LD_EXP 80
36317: PUSH
36318: LD_VAR 0 2
36322: ARRAY
36323: AND
36324: IFFALSE 36348
36326: PUSH
36327: LD_EXP 80
36331: PUSH
36332: LD_VAR 0 2
36336: ARRAY
36337: PUSH
36338: LD_INT 1
36340: ARRAY
36341: PPUSH
36342: CALL_OW 310
36346: NOT
36347: AND
36348: IFFALSE 36365
36350: PUSH
36351: LD_VAR 0 3
36355: PPUSH
36356: CALL_OW 313
36360: PUSH
36361: LD_INT 6
36363: EQUAL
36364: AND
36365: IFFALSE 36421
// begin tmp2 := UnitsInside ( j ) ;
36367: LD_ADDR_VAR 0 9
36371: PUSH
36372: LD_VAR 0 3
36376: PPUSH
36377: CALL_OW 313
36381: ST_TO_ADDR
// if tmp2 = 6 then
36382: LD_VAR 0 9
36386: PUSH
36387: LD_INT 6
36389: EQUAL
36390: IFFALSE 36421
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
36392: LD_VAR 0 9
36396: PUSH
36397: LD_INT 1
36399: ARRAY
36400: PPUSH
36401: LD_INT 112
36403: PPUSH
36404: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
36408: LD_VAR 0 9
36412: PUSH
36413: LD_INT 1
36415: ARRAY
36416: PPUSH
36417: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
36421: LD_EXP 80
36425: PUSH
36426: LD_VAR 0 2
36430: ARRAY
36431: IFFALSE 36455
36433: PUSH
36434: LD_EXP 80
36438: PUSH
36439: LD_VAR 0 2
36443: ARRAY
36444: PUSH
36445: LD_INT 1
36447: ARRAY
36448: PPUSH
36449: CALL_OW 314
36453: NOT
36454: AND
36455: IFFALSE 36479
36457: PUSH
36458: LD_EXP 80
36462: PUSH
36463: LD_VAR 0 2
36467: ARRAY
36468: PUSH
36469: LD_INT 1
36471: ARRAY
36472: PPUSH
36473: CALL_OW 310
36477: NOT
36478: AND
36479: IFFALSE 36505
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36481: LD_EXP 80
36485: PUSH
36486: LD_VAR 0 2
36490: ARRAY
36491: PUSH
36492: LD_INT 1
36494: ARRAY
36495: PPUSH
36496: LD_VAR 0 3
36500: PPUSH
36501: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36505: LD_EXP 80
36509: PUSH
36510: LD_VAR 0 2
36514: ARRAY
36515: PUSH
36516: LD_INT 1
36518: ARRAY
36519: PPUSH
36520: CALL_OW 310
36524: IFFALSE 36556
36526: PUSH
36527: LD_EXP 80
36531: PUSH
36532: LD_VAR 0 2
36536: ARRAY
36537: PUSH
36538: LD_INT 1
36540: ARRAY
36541: PPUSH
36542: CALL_OW 310
36546: PPUSH
36547: CALL_OW 461
36551: PUSH
36552: LD_INT 3
36554: NONEQUAL
36555: AND
36556: IFFALSE 36577
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36558: LD_EXP 80
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PUSH
36569: LD_INT 1
36571: ARRAY
36572: PPUSH
36573: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36577: LD_VAR 0 3
36581: PPUSH
36582: CALL_OW 461
36586: PUSH
36587: LD_INT 6
36589: EQUAL
36590: IFFALSE 36602
36592: PUSH
36593: LD_VAR 0 6
36597: PUSH
36598: LD_INT 1
36600: GREATER
36601: AND
36602: IFFALSE 36756
// begin sci := [ ] ;
36604: LD_ADDR_VAR 0 8
36608: PUSH
36609: EMPTY
36610: ST_TO_ADDR
// for x in ( tmp diff j ) do
36611: LD_ADDR_VAR 0 7
36615: PUSH
36616: LD_VAR 0 6
36620: PUSH
36621: LD_VAR 0 3
36625: DIFF
36626: PUSH
36627: FOR_IN
36628: IFFALSE 36680
// begin if sci = 6 then
36630: LD_VAR 0 8
36634: PUSH
36635: LD_INT 6
36637: EQUAL
36638: IFFALSE 36642
// break ;
36640: GO 36680
// if BuildingStatus ( x ) = bs_idle then
36642: LD_VAR 0 7
36646: PPUSH
36647: CALL_OW 461
36651: PUSH
36652: LD_INT 2
36654: EQUAL
36655: IFFALSE 36678
// sci := sci ^ UnitsInside ( x ) ;
36657: LD_ADDR_VAR 0 8
36661: PUSH
36662: LD_VAR 0 8
36666: PUSH
36667: LD_VAR 0 7
36671: PPUSH
36672: CALL_OW 313
36676: ADD
36677: ST_TO_ADDR
// end ;
36678: GO 36627
36680: POP
36681: POP
// if not sci then
36682: LD_VAR 0 8
36686: NOT
36687: IFFALSE 36691
// continue ;
36689: GO 35712
// for x in sci do
36691: LD_ADDR_VAR 0 7
36695: PUSH
36696: LD_VAR 0 8
36700: PUSH
36701: FOR_IN
36702: IFFALSE 36754
// if IsInUnit ( x ) and not HasTask ( x ) then
36704: LD_VAR 0 7
36708: PPUSH
36709: CALL_OW 310
36713: IFFALSE 36727
36715: PUSH
36716: LD_VAR 0 7
36720: PPUSH
36721: CALL_OW 314
36725: NOT
36726: AND
36727: IFFALSE 36752
// begin ComExitBuilding ( x ) ;
36729: LD_VAR 0 7
36733: PPUSH
36734: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36738: LD_VAR 0 7
36742: PPUSH
36743: LD_VAR 0 3
36747: PPUSH
36748: CALL_OW 180
// end ;
36752: GO 36701
36754: POP
36755: POP
// end ; end ;
36756: GO 35712
36758: POP
36759: POP
// end ;
36760: GO 35666
36762: POP
36763: POP
// end ;
36764: LD_VAR 0 1
36768: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36769: LD_INT 0
36771: PPUSH
36772: PPUSH
// if not mc_bases then
36773: LD_EXP 50
36777: NOT
36778: IFFALSE 36782
// exit ;
36780: GO 36865
// for i = 1 to mc_bases do
36782: LD_ADDR_VAR 0 2
36786: PUSH
36787: DOUBLE
36788: LD_INT 1
36790: DEC
36791: ST_TO_ADDR
36792: LD_EXP 50
36796: PUSH
36797: FOR_TO
36798: IFFALSE 36863
// if mc_mines [ i ] and mc_miners [ i ] then
36800: LD_EXP 63
36804: PUSH
36805: LD_VAR 0 2
36809: ARRAY
36810: IFFALSE 36824
36812: PUSH
36813: LD_EXP 64
36817: PUSH
36818: LD_VAR 0 2
36822: ARRAY
36823: AND
36824: IFFALSE 36861
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36826: LD_EXP 64
36830: PUSH
36831: LD_VAR 0 2
36835: ARRAY
36836: PUSH
36837: LD_INT 1
36839: ARRAY
36840: PPUSH
36841: CALL_OW 255
36845: PPUSH
36846: LD_EXP 63
36850: PUSH
36851: LD_VAR 0 2
36855: ARRAY
36856: PPUSH
36857: CALL 51816 0 2
36861: GO 36797
36863: POP
36864: POP
// end ;
36865: LD_VAR 0 1
36869: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36870: LD_INT 0
36872: PPUSH
36873: PPUSH
36874: PPUSH
36875: PPUSH
36876: PPUSH
36877: PPUSH
36878: PPUSH
36879: PPUSH
// if not mc_bases or not mc_parking then
36880: LD_EXP 50
36884: NOT
36885: IFTRUE 36894
36887: PUSH
36888: LD_EXP 74
36892: NOT
36893: OR
36894: IFFALSE 36898
// exit ;
36896: GO 37642
// for i = 1 to mc_bases do
36898: LD_ADDR_VAR 0 2
36902: PUSH
36903: DOUBLE
36904: LD_INT 1
36906: DEC
36907: ST_TO_ADDR
36908: LD_EXP 50
36912: PUSH
36913: FOR_TO
36914: IFFALSE 37640
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36916: LD_EXP 50
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: NOT
36927: IFTRUE 36942
36929: PUSH
36930: LD_EXP 74
36934: PUSH
36935: LD_VAR 0 2
36939: ARRAY
36940: NOT
36941: OR
36942: IFFALSE 36946
// continue ;
36944: GO 36913
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36946: LD_ADDR_VAR 0 5
36950: PUSH
36951: LD_EXP 50
36955: PUSH
36956: LD_VAR 0 2
36960: ARRAY
36961: PUSH
36962: LD_INT 1
36964: ARRAY
36965: PPUSH
36966: CALL_OW 255
36970: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36971: LD_ADDR_VAR 0 6
36975: PUSH
36976: LD_EXP 50
36980: PUSH
36981: LD_VAR 0 2
36985: ARRAY
36986: PPUSH
36987: LD_INT 30
36989: PUSH
36990: LD_INT 3
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PPUSH
36997: CALL_OW 72
37001: ST_TO_ADDR
// if not fac then
37002: LD_VAR 0 6
37006: NOT
37007: IFFALSE 37058
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37009: LD_ADDR_VAR 0 6
37013: PUSH
37014: LD_EXP 50
37018: PUSH
37019: LD_VAR 0 2
37023: ARRAY
37024: PPUSH
37025: LD_INT 2
37027: PUSH
37028: LD_INT 30
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 30
37040: PUSH
37041: LD_INT 1
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: LIST
37052: PPUSH
37053: CALL_OW 72
37057: ST_TO_ADDR
// if not fac then
37058: LD_VAR 0 6
37062: NOT
37063: IFFALSE 37067
// continue ;
37065: GO 36913
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37067: LD_ADDR_VAR 0 7
37071: PUSH
37072: LD_EXP 74
37076: PUSH
37077: LD_VAR 0 2
37081: ARRAY
37082: PPUSH
37083: LD_INT 22
37085: PUSH
37086: LD_VAR 0 5
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 21
37097: PUSH
37098: LD_INT 2
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 3
37107: PUSH
37108: LD_INT 60
37110: PUSH
37111: EMPTY
37112: LIST
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PUSH
37118: LD_INT 3
37120: PUSH
37121: LD_INT 24
37123: PUSH
37124: LD_INT 1000
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: PPUSH
37141: CALL_OW 70
37145: ST_TO_ADDR
// for j in fac do
37146: LD_ADDR_VAR 0 3
37150: PUSH
37151: LD_VAR 0 6
37155: PUSH
37156: FOR_IN
37157: IFFALSE 37252
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37159: LD_ADDR_VAR 0 7
37163: PUSH
37164: LD_VAR 0 7
37168: PUSH
37169: LD_INT 22
37171: PUSH
37172: LD_VAR 0 5
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 91
37183: PUSH
37184: LD_VAR 0 3
37188: PUSH
37189: LD_INT 15
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 21
37199: PUSH
37200: LD_INT 2
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 3
37209: PUSH
37210: LD_INT 60
37212: PUSH
37213: EMPTY
37214: LIST
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 3
37222: PUSH
37223: LD_INT 24
37225: PUSH
37226: LD_INT 1000
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: PPUSH
37244: CALL_OW 69
37248: UNION
37249: ST_TO_ADDR
37250: GO 37156
37252: POP
37253: POP
// if not vehs then
37254: LD_VAR 0 7
37258: NOT
37259: IFFALSE 37285
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37261: LD_ADDR_EXP 62
37265: PUSH
37266: LD_EXP 62
37270: PPUSH
37271: LD_VAR 0 2
37275: PPUSH
37276: EMPTY
37277: PPUSH
37278: CALL_OW 1
37282: ST_TO_ADDR
// continue ;
37283: GO 36913
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37285: LD_ADDR_VAR 0 8
37289: PUSH
37290: LD_EXP 50
37294: PUSH
37295: LD_VAR 0 2
37299: ARRAY
37300: PPUSH
37301: LD_INT 30
37303: PUSH
37304: LD_INT 3
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PPUSH
37311: CALL_OW 72
37315: ST_TO_ADDR
// if tmp then
37316: LD_VAR 0 8
37320: IFFALSE 37423
// begin for j in tmp do
37322: LD_ADDR_VAR 0 3
37326: PUSH
37327: LD_VAR 0 8
37331: PUSH
37332: FOR_IN
37333: IFFALSE 37421
// for k in UnitsInside ( j ) do
37335: LD_ADDR_VAR 0 4
37339: PUSH
37340: LD_VAR 0 3
37344: PPUSH
37345: CALL_OW 313
37349: PUSH
37350: FOR_IN
37351: IFFALSE 37417
// if k then
37353: LD_VAR 0 4
37357: IFFALSE 37415
// if not k in mc_repair_vehicle [ i ] then
37359: LD_VAR 0 4
37363: PUSH
37364: LD_EXP 62
37368: PUSH
37369: LD_VAR 0 2
37373: ARRAY
37374: IN
37375: NOT
37376: IFFALSE 37415
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
37378: LD_ADDR_EXP 62
37382: PUSH
37383: LD_EXP 62
37387: PPUSH
37388: LD_VAR 0 2
37392: PPUSH
37393: LD_EXP 62
37397: PUSH
37398: LD_VAR 0 2
37402: ARRAY
37403: PUSH
37404: LD_VAR 0 4
37408: UNION
37409: PPUSH
37410: CALL_OW 1
37414: ST_TO_ADDR
37415: GO 37350
37417: POP
37418: POP
37419: GO 37332
37421: POP
37422: POP
// end ; if not mc_repair_vehicle [ i ] then
37423: LD_EXP 62
37427: PUSH
37428: LD_VAR 0 2
37432: ARRAY
37433: NOT
37434: IFFALSE 37438
// continue ;
37436: GO 36913
// for j in mc_repair_vehicle [ i ] do
37438: LD_ADDR_VAR 0 3
37442: PUSH
37443: LD_EXP 62
37447: PUSH
37448: LD_VAR 0 2
37452: ARRAY
37453: PUSH
37454: FOR_IN
37455: IFFALSE 37636
// begin if GetClass ( j ) <> 3 then
37457: LD_VAR 0 3
37461: PPUSH
37462: CALL_OW 257
37466: PUSH
37467: LD_INT 3
37469: NONEQUAL
37470: IFFALSE 37511
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37472: LD_ADDR_EXP 62
37476: PUSH
37477: LD_EXP 62
37481: PPUSH
37482: LD_VAR 0 2
37486: PPUSH
37487: LD_EXP 62
37491: PUSH
37492: LD_VAR 0 2
37496: ARRAY
37497: PUSH
37498: LD_VAR 0 3
37502: DIFF
37503: PPUSH
37504: CALL_OW 1
37508: ST_TO_ADDR
// continue ;
37509: GO 37454
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37511: LD_VAR 0 3
37515: PPUSH
37516: CALL_OW 311
37520: NOT
37521: IFFALSE 37546
37523: PUSH
37524: LD_VAR 0 3
37528: PUSH
37529: LD_EXP 53
37533: PUSH
37534: LD_VAR 0 2
37538: ARRAY
37539: PUSH
37540: LD_INT 1
37542: ARRAY
37543: IN
37544: NOT
37545: AND
37546: IFFALSE 37571
37548: PUSH
37549: LD_VAR 0 3
37553: PUSH
37554: LD_EXP 53
37558: PUSH
37559: LD_VAR 0 2
37563: ARRAY
37564: PUSH
37565: LD_INT 2
37567: ARRAY
37568: IN
37569: NOT
37570: AND
37571: IFFALSE 37634
// begin if IsInUnit ( j ) then
37573: LD_VAR 0 3
37577: PPUSH
37578: CALL_OW 310
37582: IFFALSE 37595
// ComExitBuilding ( j ) else
37584: LD_VAR 0 3
37588: PPUSH
37589: CALL_OW 122
37593: GO 37634
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37595: LD_VAR 0 3
37599: PPUSH
37600: LD_VAR 0 7
37604: PUSH
37605: LD_INT 1
37607: ARRAY
37608: PPUSH
37609: CALL 90038 0 2
37613: NOT
37614: IFFALSE 37634
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37616: LD_VAR 0 3
37620: PPUSH
37621: LD_VAR 0 7
37625: PUSH
37626: LD_INT 1
37628: ARRAY
37629: PPUSH
37630: CALL_OW 129
// end ; end ;
37634: GO 37454
37636: POP
37637: POP
// end ;
37638: GO 36913
37640: POP
37641: POP
// end ;
37642: LD_VAR 0 1
37646: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37647: LD_INT 0
37649: PPUSH
37650: PPUSH
37651: PPUSH
37652: PPUSH
37653: PPUSH
37654: PPUSH
37655: PPUSH
37656: PPUSH
37657: PPUSH
37658: PPUSH
37659: PPUSH
// if not mc_bases then
37660: LD_EXP 50
37664: NOT
37665: IFFALSE 37669
// exit ;
37667: GO 38487
// for i = 1 to mc_bases do
37669: LD_ADDR_VAR 0 2
37673: PUSH
37674: DOUBLE
37675: LD_INT 1
37677: DEC
37678: ST_TO_ADDR
37679: LD_EXP 50
37683: PUSH
37684: FOR_TO
37685: IFFALSE 38485
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37687: LD_EXP 78
37691: PUSH
37692: LD_VAR 0 2
37696: ARRAY
37697: NOT
37698: IFTRUE 37716
37700: PUSH
37701: LD_EXP 53
37705: PUSH
37706: LD_VAR 0 2
37710: ARRAY
37711: PUSH
37712: LD_INT 1
37714: ARRAY
37715: OR
37716: IFTRUE 37734
37718: PUSH
37719: LD_EXP 53
37723: PUSH
37724: LD_VAR 0 2
37728: ARRAY
37729: PUSH
37730: LD_INT 2
37732: ARRAY
37733: OR
37734: IFTRUE 37757
37736: PUSH
37737: LD_EXP 76
37741: PUSH
37742: LD_VAR 0 2
37746: ARRAY
37747: PPUSH
37748: LD_INT 1
37750: PPUSH
37751: CALL_OW 325
37755: NOT
37756: OR
37757: IFTRUE 37771
37759: PUSH
37760: LD_EXP 73
37764: PUSH
37765: LD_VAR 0 2
37769: ARRAY
37770: OR
37771: IFFALSE 37775
// continue ;
37773: GO 37684
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37775: LD_ADDR_VAR 0 8
37779: PUSH
37780: LD_EXP 50
37784: PUSH
37785: LD_VAR 0 2
37789: ARRAY
37790: PPUSH
37791: LD_INT 25
37793: PUSH
37794: LD_INT 4
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 50
37803: PUSH
37804: EMPTY
37805: LIST
37806: PUSH
37807: LD_INT 3
37809: PUSH
37810: LD_INT 60
37812: PUSH
37813: EMPTY
37814: LIST
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: LIST
37824: PPUSH
37825: CALL_OW 72
37829: PUSH
37830: LD_EXP 54
37834: PUSH
37835: LD_VAR 0 2
37839: ARRAY
37840: DIFF
37841: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37842: LD_ADDR_VAR 0 9
37846: PUSH
37847: LD_EXP 50
37851: PUSH
37852: LD_VAR 0 2
37856: ARRAY
37857: PPUSH
37858: LD_INT 2
37860: PUSH
37861: LD_INT 30
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 30
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: LIST
37885: PPUSH
37886: CALL_OW 72
37890: ST_TO_ADDR
// if not tmp or not dep then
37891: LD_VAR 0 8
37895: NOT
37896: IFTRUE 37905
37898: PUSH
37899: LD_VAR 0 9
37903: NOT
37904: OR
37905: IFFALSE 37909
// continue ;
37907: GO 37684
// side := GetSide ( tmp [ 1 ] ) ;
37909: LD_ADDR_VAR 0 11
37913: PUSH
37914: LD_VAR 0 8
37918: PUSH
37919: LD_INT 1
37921: ARRAY
37922: PPUSH
37923: CALL_OW 255
37927: ST_TO_ADDR
// dep := dep [ 1 ] ;
37928: LD_ADDR_VAR 0 9
37932: PUSH
37933: LD_VAR 0 9
37937: PUSH
37938: LD_INT 1
37940: ARRAY
37941: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37942: LD_ADDR_VAR 0 7
37946: PUSH
37947: LD_EXP 78
37951: PUSH
37952: LD_VAR 0 2
37956: ARRAY
37957: PPUSH
37958: LD_INT 22
37960: PUSH
37961: LD_INT 0
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 25
37970: PUSH
37971: LD_INT 12
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PPUSH
37982: CALL_OW 70
37986: PUSH
37987: LD_INT 22
37989: PUSH
37990: LD_INT 0
37992: PUSH
37993: EMPTY
37994: LIST
37995: LIST
37996: PUSH
37997: LD_INT 25
37999: PUSH
38000: LD_INT 12
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 91
38009: PUSH
38010: LD_VAR 0 9
38014: PUSH
38015: LD_INT 20
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: LIST
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: LIST
38027: PPUSH
38028: CALL_OW 69
38032: UNION
38033: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38034: LD_ADDR_VAR 0 10
38038: PUSH
38039: LD_EXP 78
38043: PUSH
38044: LD_VAR 0 2
38048: ARRAY
38049: PPUSH
38050: LD_INT 81
38052: PUSH
38053: LD_VAR 0 11
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PPUSH
38062: CALL_OW 70
38066: ST_TO_ADDR
// if not apes or danger_at_area then
38067: LD_VAR 0 7
38071: NOT
38072: IFTRUE 38080
38074: PUSH
38075: LD_VAR 0 10
38079: OR
38080: IFFALSE 38130
// begin if mc_taming [ i ] then
38082: LD_EXP 81
38086: PUSH
38087: LD_VAR 0 2
38091: ARRAY
38092: IFFALSE 38128
// begin MC_Reset ( i , 121 ) ;
38094: LD_VAR 0 2
38098: PPUSH
38099: LD_INT 121
38101: PPUSH
38102: CALL 22862 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38106: LD_ADDR_EXP 81
38110: PUSH
38111: LD_EXP 81
38115: PPUSH
38116: LD_VAR 0 2
38120: PPUSH
38121: EMPTY
38122: PPUSH
38123: CALL_OW 1
38127: ST_TO_ADDR
// end ; continue ;
38128: GO 37684
// end ; for j in tmp do
38130: LD_ADDR_VAR 0 3
38134: PUSH
38135: LD_VAR 0 8
38139: PUSH
38140: FOR_IN
38141: IFFALSE 38481
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38143: LD_VAR 0 3
38147: PUSH
38148: LD_EXP 81
38152: PUSH
38153: LD_VAR 0 2
38157: ARRAY
38158: IN
38159: NOT
38160: IFFALSE 38178
38162: PUSH
38163: LD_EXP 81
38167: PUSH
38168: LD_VAR 0 2
38172: ARRAY
38173: PUSH
38174: LD_INT 3
38176: LESS
38177: AND
38178: IFFALSE 38236
// begin SetTag ( j , 121 ) ;
38180: LD_VAR 0 3
38184: PPUSH
38185: LD_INT 121
38187: PPUSH
38188: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38192: LD_ADDR_EXP 81
38196: PUSH
38197: LD_EXP 81
38201: PPUSH
38202: LD_VAR 0 2
38206: PUSH
38207: LD_EXP 81
38211: PUSH
38212: LD_VAR 0 2
38216: ARRAY
38217: PUSH
38218: LD_INT 1
38220: PLUS
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PPUSH
38226: LD_VAR 0 3
38230: PPUSH
38231: CALL 54897 0 3
38235: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38236: LD_VAR 0 3
38240: PUSH
38241: LD_EXP 81
38245: PUSH
38246: LD_VAR 0 2
38250: ARRAY
38251: IN
38252: IFFALSE 38479
// begin if GetClass ( j ) <> 4 then
38254: LD_VAR 0 3
38258: PPUSH
38259: CALL_OW 257
38263: PUSH
38264: LD_INT 4
38266: NONEQUAL
38267: IFFALSE 38320
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38269: LD_ADDR_EXP 81
38273: PUSH
38274: LD_EXP 81
38278: PPUSH
38279: LD_VAR 0 2
38283: PPUSH
38284: LD_EXP 81
38288: PUSH
38289: LD_VAR 0 2
38293: ARRAY
38294: PUSH
38295: LD_VAR 0 3
38299: DIFF
38300: PPUSH
38301: CALL_OW 1
38305: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38306: LD_VAR 0 3
38310: PPUSH
38311: LD_INT 0
38313: PPUSH
38314: CALL_OW 109
// continue ;
38318: GO 38140
// end ; if IsInUnit ( j ) then
38320: LD_VAR 0 3
38324: PPUSH
38325: CALL_OW 310
38329: IFFALSE 38340
// ComExitBuilding ( j ) ;
38331: LD_VAR 0 3
38335: PPUSH
38336: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
38340: LD_ADDR_VAR 0 6
38344: PUSH
38345: LD_VAR 0 7
38349: PPUSH
38350: LD_VAR 0 3
38354: PPUSH
38355: CALL_OW 74
38359: ST_TO_ADDR
// if not ape then
38360: LD_VAR 0 6
38364: NOT
38365: IFFALSE 38369
// break ;
38367: GO 38481
// x := GetX ( ape ) ;
38369: LD_ADDR_VAR 0 4
38373: PUSH
38374: LD_VAR 0 6
38378: PPUSH
38379: CALL_OW 250
38383: ST_TO_ADDR
// y := GetY ( ape ) ;
38384: LD_ADDR_VAR 0 5
38388: PUSH
38389: LD_VAR 0 6
38393: PPUSH
38394: CALL_OW 251
38398: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
38399: LD_VAR 0 4
38403: PPUSH
38404: LD_VAR 0 5
38408: PPUSH
38409: CALL_OW 488
38413: NOT
38414: IFTRUE 38444
38416: PUSH
38417: LD_VAR 0 11
38421: PPUSH
38422: LD_VAR 0 4
38426: PPUSH
38427: LD_VAR 0 5
38431: PPUSH
38432: LD_INT 20
38434: PPUSH
38435: CALL 56167 0 4
38439: PUSH
38440: LD_INT 4
38442: ARRAY
38443: OR
38444: IFFALSE 38448
// break ;
38446: GO 38481
// if not HasTask ( j ) then
38448: LD_VAR 0 3
38452: PPUSH
38453: CALL_OW 314
38457: NOT
38458: IFFALSE 38479
// ComTameXY ( j , x , y ) ;
38460: LD_VAR 0 3
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: LD_VAR 0 5
38474: PPUSH
38475: CALL_OW 131
// end ; end ;
38479: GO 38140
38481: POP
38482: POP
// end ;
38483: GO 37684
38485: POP
38486: POP
// end ;
38487: LD_VAR 0 1
38491: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38492: LD_INT 0
38494: PPUSH
38495: PPUSH
38496: PPUSH
38497: PPUSH
38498: PPUSH
38499: PPUSH
38500: PPUSH
38501: PPUSH
// if not mc_bases then
38502: LD_EXP 50
38506: NOT
38507: IFFALSE 38511
// exit ;
38509: GO 39143
// for i = 1 to mc_bases do
38511: LD_ADDR_VAR 0 2
38515: PUSH
38516: DOUBLE
38517: LD_INT 1
38519: DEC
38520: ST_TO_ADDR
38521: LD_EXP 50
38525: PUSH
38526: FOR_TO
38527: IFFALSE 39141
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38529: LD_EXP 79
38533: PUSH
38534: LD_VAR 0 2
38538: ARRAY
38539: NOT
38540: IFTRUE 38570
38542: PUSH
38543: LD_EXP 79
38547: PUSH
38548: LD_VAR 0 2
38552: ARRAY
38553: PPUSH
38554: LD_INT 25
38556: PUSH
38557: LD_INT 12
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PPUSH
38564: CALL_OW 72
38568: NOT
38569: OR
38570: IFFALSE 38574
// continue ;
38572: GO 38526
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38574: LD_ADDR_VAR 0 5
38578: PUSH
38579: LD_EXP 79
38583: PUSH
38584: LD_VAR 0 2
38588: ARRAY
38589: PUSH
38590: LD_INT 1
38592: ARRAY
38593: PPUSH
38594: CALL_OW 255
38598: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38599: LD_VAR 0 5
38603: PPUSH
38604: LD_INT 2
38606: PPUSH
38607: CALL_OW 325
38611: IFFALSE 38864
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38613: LD_ADDR_VAR 0 4
38617: PUSH
38618: LD_EXP 79
38622: PUSH
38623: LD_VAR 0 2
38627: ARRAY
38628: PPUSH
38629: LD_INT 25
38631: PUSH
38632: LD_INT 16
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PPUSH
38639: CALL_OW 72
38643: ST_TO_ADDR
// if tmp < 6 then
38644: LD_VAR 0 4
38648: PUSH
38649: LD_INT 6
38651: LESS
38652: IFFALSE 38864
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38654: LD_ADDR_VAR 0 6
38658: PUSH
38659: LD_EXP 50
38663: PUSH
38664: LD_VAR 0 2
38668: ARRAY
38669: PPUSH
38670: LD_INT 2
38672: PUSH
38673: LD_INT 30
38675: PUSH
38676: LD_INT 0
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 30
38685: PUSH
38686: LD_INT 1
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: LIST
38697: PPUSH
38698: CALL_OW 72
38702: ST_TO_ADDR
// if depot then
38703: LD_VAR 0 6
38707: IFFALSE 38864
// begin selected := 0 ;
38709: LD_ADDR_VAR 0 7
38713: PUSH
38714: LD_INT 0
38716: ST_TO_ADDR
// for j in depot do
38717: LD_ADDR_VAR 0 3
38721: PUSH
38722: LD_VAR 0 6
38726: PUSH
38727: FOR_IN
38728: IFFALSE 38759
// begin if UnitsInside ( j ) < 6 then
38730: LD_VAR 0 3
38734: PPUSH
38735: CALL_OW 313
38739: PUSH
38740: LD_INT 6
38742: LESS
38743: IFFALSE 38757
// begin selected := j ;
38745: LD_ADDR_VAR 0 7
38749: PUSH
38750: LD_VAR 0 3
38754: ST_TO_ADDR
// break ;
38755: GO 38759
// end ; end ;
38757: GO 38727
38759: POP
38760: POP
// if selected then
38761: LD_VAR 0 7
38765: IFFALSE 38864
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38767: LD_ADDR_VAR 0 3
38771: PUSH
38772: LD_EXP 79
38776: PUSH
38777: LD_VAR 0 2
38781: ARRAY
38782: PPUSH
38783: LD_INT 25
38785: PUSH
38786: LD_INT 12
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PPUSH
38793: CALL_OW 72
38797: PUSH
38798: FOR_IN
38799: IFFALSE 38862
// if not HasTask ( j ) then
38801: LD_VAR 0 3
38805: PPUSH
38806: CALL_OW 314
38810: NOT
38811: IFFALSE 38860
// begin if not IsInUnit ( j ) then
38813: LD_VAR 0 3
38817: PPUSH
38818: CALL_OW 310
38822: NOT
38823: IFFALSE 38839
// ComEnterUnit ( j , selected ) ;
38825: LD_VAR 0 3
38829: PPUSH
38830: LD_VAR 0 7
38834: PPUSH
38835: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38839: LD_VAR 0 3
38843: PPUSH
38844: LD_INT 16
38846: PPUSH
38847: CALL_OW 183
// AddComExitBuilding ( j ) ;
38851: LD_VAR 0 3
38855: PPUSH
38856: CALL_OW 182
// end ;
38860: GO 38798
38862: POP
38863: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38864: LD_VAR 0 5
38868: PPUSH
38869: LD_INT 11
38871: PPUSH
38872: CALL_OW 325
38876: IFFALSE 39139
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38878: LD_ADDR_VAR 0 4
38882: PUSH
38883: LD_EXP 79
38887: PUSH
38888: LD_VAR 0 2
38892: ARRAY
38893: PPUSH
38894: LD_INT 25
38896: PUSH
38897: LD_INT 16
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PPUSH
38904: CALL_OW 72
38908: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38909: LD_VAR 0 4
38913: PUSH
38914: LD_INT 6
38916: GREATEREQUAL
38917: IFTRUE 38934
38919: PUSH
38920: LD_VAR 0 5
38924: PPUSH
38925: LD_INT 2
38927: PPUSH
38928: CALL_OW 325
38932: NOT
38933: OR
38934: IFFALSE 39139
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38936: LD_ADDR_VAR 0 8
38940: PUSH
38941: LD_EXP 50
38945: PUSH
38946: LD_VAR 0 2
38950: ARRAY
38951: PPUSH
38952: LD_INT 2
38954: PUSH
38955: LD_INT 30
38957: PUSH
38958: LD_INT 4
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PUSH
38965: LD_INT 30
38967: PUSH
38968: LD_INT 5
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: LIST
38979: PPUSH
38980: CALL_OW 72
38984: ST_TO_ADDR
// if barracks then
38985: LD_VAR 0 8
38989: IFFALSE 39139
// begin selected := 0 ;
38991: LD_ADDR_VAR 0 7
38995: PUSH
38996: LD_INT 0
38998: ST_TO_ADDR
// for j in barracks do
38999: LD_ADDR_VAR 0 3
39003: PUSH
39004: LD_VAR 0 8
39008: PUSH
39009: FOR_IN
39010: IFFALSE 39041
// begin if UnitsInside ( j ) < 6 then
39012: LD_VAR 0 3
39016: PPUSH
39017: CALL_OW 313
39021: PUSH
39022: LD_INT 6
39024: LESS
39025: IFFALSE 39039
// begin selected := j ;
39027: LD_ADDR_VAR 0 7
39031: PUSH
39032: LD_VAR 0 3
39036: ST_TO_ADDR
// break ;
39037: GO 39041
// end ; end ;
39039: GO 39009
39041: POP
39042: POP
// if selected then
39043: LD_VAR 0 7
39047: IFFALSE 39139
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39049: LD_ADDR_VAR 0 3
39053: PUSH
39054: LD_EXP 79
39058: PUSH
39059: LD_VAR 0 2
39063: ARRAY
39064: PPUSH
39065: LD_INT 25
39067: PUSH
39068: LD_INT 12
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PPUSH
39075: CALL_OW 72
39079: PUSH
39080: FOR_IN
39081: IFFALSE 39137
// if not IsInUnit ( j ) and not HasTask ( j ) then
39083: LD_VAR 0 3
39087: PPUSH
39088: CALL_OW 310
39092: NOT
39093: IFFALSE 39107
39095: PUSH
39096: LD_VAR 0 3
39100: PPUSH
39101: CALL_OW 314
39105: NOT
39106: AND
39107: IFFALSE 39135
// begin ComEnterUnit ( j , selected ) ;
39109: LD_VAR 0 3
39113: PPUSH
39114: LD_VAR 0 7
39118: PPUSH
39119: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39123: LD_VAR 0 3
39127: PPUSH
39128: LD_INT 15
39130: PPUSH
39131: CALL_OW 183
// end ;
39135: GO 39080
39137: POP
39138: POP
// end ; end ; end ; end ; end ;
39139: GO 38526
39141: POP
39142: POP
// end ;
39143: LD_VAR 0 1
39147: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39148: LD_INT 0
39150: PPUSH
39151: PPUSH
39152: PPUSH
39153: PPUSH
// if not mc_bases then
39154: LD_EXP 50
39158: NOT
39159: IFFALSE 39163
// exit ;
39161: GO 39345
// for i = 1 to mc_bases do
39163: LD_ADDR_VAR 0 2
39167: PUSH
39168: DOUBLE
39169: LD_INT 1
39171: DEC
39172: ST_TO_ADDR
39173: LD_EXP 50
39177: PUSH
39178: FOR_TO
39179: IFFALSE 39343
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39181: LD_ADDR_VAR 0 4
39185: PUSH
39186: LD_EXP 50
39190: PUSH
39191: LD_VAR 0 2
39195: ARRAY
39196: PPUSH
39197: LD_INT 25
39199: PUSH
39200: LD_INT 9
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PPUSH
39207: CALL_OW 72
39211: ST_TO_ADDR
// if not tmp then
39212: LD_VAR 0 4
39216: NOT
39217: IFFALSE 39221
// continue ;
39219: GO 39178
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39221: LD_EXP 76
39225: PUSH
39226: LD_VAR 0 2
39230: ARRAY
39231: PPUSH
39232: LD_INT 29
39234: PPUSH
39235: CALL_OW 325
39239: NOT
39240: IFFALSE 39263
39242: PUSH
39243: LD_EXP 76
39247: PUSH
39248: LD_VAR 0 2
39252: ARRAY
39253: PPUSH
39254: LD_INT 28
39256: PPUSH
39257: CALL_OW 325
39261: NOT
39262: AND
39263: IFFALSE 39267
// continue ;
39265: GO 39178
// for j in tmp do
39267: LD_ADDR_VAR 0 3
39271: PUSH
39272: LD_VAR 0 4
39276: PUSH
39277: FOR_IN
39278: IFFALSE 39339
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39280: LD_VAR 0 3
39284: PUSH
39285: LD_EXP 53
39289: PUSH
39290: LD_VAR 0 2
39294: ARRAY
39295: PUSH
39296: LD_INT 1
39298: ARRAY
39299: IN
39300: NOT
39301: IFFALSE 39326
39303: PUSH
39304: LD_VAR 0 3
39308: PUSH
39309: LD_EXP 53
39313: PUSH
39314: LD_VAR 0 2
39318: ARRAY
39319: PUSH
39320: LD_INT 2
39322: ARRAY
39323: IN
39324: NOT
39325: AND
39326: IFFALSE 39337
// ComSpaceTimeShoot ( j ) ;
39328: LD_VAR 0 3
39332: PPUSH
39333: CALL 50814 0 1
39337: GO 39277
39339: POP
39340: POP
// end ;
39341: GO 39178
39343: POP
39344: POP
// end ;
39345: LD_VAR 0 1
39349: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
39350: LD_INT 0
39352: PPUSH
39353: PPUSH
39354: PPUSH
39355: PPUSH
39356: PPUSH
39357: PPUSH
39358: PPUSH
39359: PPUSH
39360: PPUSH
// if not mc_bases then
39361: LD_EXP 50
39365: NOT
39366: IFFALSE 39370
// exit ;
39368: GO 40002
// for i = 1 to mc_bases do
39370: LD_ADDR_VAR 0 2
39374: PUSH
39375: DOUBLE
39376: LD_INT 1
39378: DEC
39379: ST_TO_ADDR
39380: LD_EXP 50
39384: PUSH
39385: FOR_TO
39386: IFFALSE 40000
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
39388: LD_EXP 85
39392: PUSH
39393: LD_VAR 0 2
39397: ARRAY
39398: NOT
39399: IFTRUE 39425
39401: PUSH
39402: LD_INT 38
39404: PPUSH
39405: LD_EXP 76
39409: PUSH
39410: LD_VAR 0 2
39414: ARRAY
39415: PPUSH
39416: CALL_OW 321
39420: PUSH
39421: LD_INT 2
39423: NONEQUAL
39424: OR
39425: IFFALSE 39429
// continue ;
39427: GO 39385
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
39429: LD_ADDR_VAR 0 8
39433: PUSH
39434: LD_EXP 50
39438: PUSH
39439: LD_VAR 0 2
39443: ARRAY
39444: PPUSH
39445: LD_INT 30
39447: PUSH
39448: LD_INT 34
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PPUSH
39455: CALL_OW 72
39459: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
39460: LD_ADDR_VAR 0 9
39464: PUSH
39465: LD_EXP 50
39469: PUSH
39470: LD_VAR 0 2
39474: ARRAY
39475: PPUSH
39476: LD_INT 25
39478: PUSH
39479: LD_INT 4
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PPUSH
39486: CALL_OW 72
39490: PPUSH
39491: LD_INT 0
39493: PPUSH
39494: CALL 85500 0 2
39498: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39499: LD_VAR 0 9
39503: NOT
39504: IFTRUE 39513
39506: PUSH
39507: LD_VAR 0 8
39511: NOT
39512: OR
39513: IFTRUE 39535
39515: PUSH
39516: LD_EXP 50
39520: PUSH
39521: LD_VAR 0 2
39525: ARRAY
39526: PPUSH
39527: LD_INT 124
39529: PPUSH
39530: CALL 85500 0 2
39534: OR
39535: IFFALSE 39539
// continue ;
39537: GO 39385
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39539: LD_EXP 86
39543: PUSH
39544: LD_VAR 0 2
39548: ARRAY
39549: PUSH
39550: LD_EXP 85
39554: PUSH
39555: LD_VAR 0 2
39559: ARRAY
39560: LESS
39561: IFFALSE 39581
39563: PUSH
39564: LD_EXP 86
39568: PUSH
39569: LD_VAR 0 2
39573: ARRAY
39574: PUSH
39575: LD_VAR 0 8
39579: LESS
39580: AND
39581: IFFALSE 39998
// begin tmp := sci [ 1 ] ;
39583: LD_ADDR_VAR 0 7
39587: PUSH
39588: LD_VAR 0 9
39592: PUSH
39593: LD_INT 1
39595: ARRAY
39596: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39597: LD_VAR 0 7
39601: PPUSH
39602: LD_INT 124
39604: PPUSH
39605: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39609: LD_ADDR_VAR 0 3
39613: PUSH
39614: DOUBLE
39615: LD_EXP 85
39619: PUSH
39620: LD_VAR 0 2
39624: ARRAY
39625: INC
39626: ST_TO_ADDR
39627: LD_EXP 85
39631: PUSH
39632: LD_VAR 0 2
39636: ARRAY
39637: PUSH
39638: FOR_DOWNTO
39639: IFFALSE 39984
// begin if IsInUnit ( tmp ) then
39641: LD_VAR 0 7
39645: PPUSH
39646: CALL_OW 310
39650: IFFALSE 39661
// ComExitBuilding ( tmp ) ;
39652: LD_VAR 0 7
39656: PPUSH
39657: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39661: LD_INT 35
39663: PPUSH
39664: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39668: LD_VAR 0 7
39672: PPUSH
39673: CALL_OW 310
39677: NOT
39678: IFFALSE 39692
39680: PUSH
39681: LD_VAR 0 7
39685: PPUSH
39686: CALL_OW 314
39690: NOT
39691: AND
39692: IFFALSE 39661
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39694: LD_ADDR_VAR 0 6
39698: PUSH
39699: LD_VAR 0 7
39703: PPUSH
39704: CALL_OW 250
39708: PUSH
39709: LD_VAR 0 7
39713: PPUSH
39714: CALL_OW 251
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39723: LD_INT 35
39725: PPUSH
39726: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39730: LD_ADDR_VAR 0 4
39734: PUSH
39735: LD_EXP 85
39739: PUSH
39740: LD_VAR 0 2
39744: ARRAY
39745: PUSH
39746: LD_VAR 0 3
39750: ARRAY
39751: PUSH
39752: LD_INT 1
39754: ARRAY
39755: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39756: LD_ADDR_VAR 0 5
39760: PUSH
39761: LD_EXP 85
39765: PUSH
39766: LD_VAR 0 2
39770: ARRAY
39771: PUSH
39772: LD_VAR 0 3
39776: ARRAY
39777: PUSH
39778: LD_INT 2
39780: ARRAY
39781: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39782: LD_VAR 0 7
39786: PPUSH
39787: LD_INT 10
39789: PPUSH
39790: CALL 57876 0 2
39794: PUSH
39795: LD_INT 4
39797: ARRAY
39798: IFFALSE 39836
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39800: LD_VAR 0 7
39804: PPUSH
39805: LD_VAR 0 6
39809: PUSH
39810: LD_INT 1
39812: ARRAY
39813: PPUSH
39814: LD_VAR 0 6
39818: PUSH
39819: LD_INT 2
39821: ARRAY
39822: PPUSH
39823: CALL_OW 111
// wait ( 0 0$10 ) ;
39827: LD_INT 350
39829: PPUSH
39830: CALL_OW 67
// end else
39834: GO 39862
// begin ComMoveXY ( tmp , x , y ) ;
39836: LD_VAR 0 7
39840: PPUSH
39841: LD_VAR 0 4
39845: PPUSH
39846: LD_VAR 0 5
39850: PPUSH
39851: CALL_OW 111
// wait ( 0 0$3 ) ;
39855: LD_INT 105
39857: PPUSH
39858: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39862: LD_VAR 0 7
39866: PPUSH
39867: LD_VAR 0 4
39871: PPUSH
39872: LD_VAR 0 5
39876: PPUSH
39877: CALL_OW 307
39881: IFFALSE 39723
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39883: LD_VAR 0 7
39887: PPUSH
39888: LD_VAR 0 4
39892: PPUSH
39893: LD_VAR 0 5
39897: PPUSH
39898: LD_VAR 0 8
39902: PUSH
39903: LD_VAR 0 3
39907: ARRAY
39908: PPUSH
39909: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39913: LD_INT 35
39915: PPUSH
39916: CALL_OW 67
// until not HasTask ( tmp ) ;
39920: LD_VAR 0 7
39924: PPUSH
39925: CALL_OW 314
39929: NOT
39930: IFFALSE 39913
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39932: LD_ADDR_EXP 86
39936: PUSH
39937: LD_EXP 86
39941: PPUSH
39942: LD_VAR 0 2
39946: PUSH
39947: LD_EXP 86
39951: PUSH
39952: LD_VAR 0 2
39956: ARRAY
39957: PUSH
39958: LD_INT 1
39960: PLUS
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PPUSH
39966: LD_VAR 0 8
39970: PUSH
39971: LD_VAR 0 3
39975: ARRAY
39976: PPUSH
39977: CALL 54897 0 3
39981: ST_TO_ADDR
// end ;
39982: GO 39638
39984: POP
39985: POP
// MC_Reset ( i , 124 ) ;
39986: LD_VAR 0 2
39990: PPUSH
39991: LD_INT 124
39993: PPUSH
39994: CALL 22862 0 2
// end ; end ;
39998: GO 39385
40000: POP
40001: POP
// end ;
40002: LD_VAR 0 1
40006: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40007: LD_INT 0
40009: PPUSH
40010: PPUSH
40011: PPUSH
// if not mc_bases then
40012: LD_EXP 50
40016: NOT
40017: IFFALSE 40021
// exit ;
40019: GO 40635
// for i = 1 to mc_bases do
40021: LD_ADDR_VAR 0 2
40025: PUSH
40026: DOUBLE
40027: LD_INT 1
40029: DEC
40030: ST_TO_ADDR
40031: LD_EXP 50
40035: PUSH
40036: FOR_TO
40037: IFFALSE 40633
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40039: LD_ADDR_VAR 0 3
40043: PUSH
40044: LD_EXP 50
40048: PUSH
40049: LD_VAR 0 2
40053: ARRAY
40054: PPUSH
40055: LD_INT 25
40057: PUSH
40058: LD_INT 4
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PPUSH
40065: CALL_OW 72
40069: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40070: LD_VAR 0 3
40074: NOT
40075: IFTRUE 40090
40077: PUSH
40078: LD_EXP 87
40082: PUSH
40083: LD_VAR 0 2
40087: ARRAY
40088: NOT
40089: OR
40090: IFTRUE 40138
40092: PUSH
40093: LD_EXP 50
40097: PUSH
40098: LD_VAR 0 2
40102: ARRAY
40103: PPUSH
40104: LD_INT 2
40106: PUSH
40107: LD_INT 30
40109: PUSH
40110: LD_INT 0
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 30
40119: PUSH
40120: LD_INT 1
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: LIST
40131: PPUSH
40132: CALL_OW 72
40136: NOT
40137: OR
40138: IFFALSE 40188
// begin if mc_deposits_finder [ i ] then
40140: LD_EXP 88
40144: PUSH
40145: LD_VAR 0 2
40149: ARRAY
40150: IFFALSE 40186
// begin MC_Reset ( i , 125 ) ;
40152: LD_VAR 0 2
40156: PPUSH
40157: LD_INT 125
40159: PPUSH
40160: CALL 22862 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40164: LD_ADDR_EXP 88
40168: PUSH
40169: LD_EXP 88
40173: PPUSH
40174: LD_VAR 0 2
40178: PPUSH
40179: EMPTY
40180: PPUSH
40181: CALL_OW 1
40185: ST_TO_ADDR
// end ; continue ;
40186: GO 40036
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40188: LD_EXP 87
40192: PUSH
40193: LD_VAR 0 2
40197: ARRAY
40198: PUSH
40199: LD_INT 1
40201: ARRAY
40202: PUSH
40203: LD_INT 3
40205: ARRAY
40206: PUSH
40207: LD_INT 1
40209: EQUAL
40210: IFFALSE 40236
40212: PUSH
40213: LD_INT 20
40215: PPUSH
40216: LD_EXP 76
40220: PUSH
40221: LD_VAR 0 2
40225: ARRAY
40226: PPUSH
40227: CALL_OW 321
40231: PUSH
40232: LD_INT 2
40234: NONEQUAL
40235: AND
40236: IFFALSE 40286
// begin if mc_deposits_finder [ i ] then
40238: LD_EXP 88
40242: PUSH
40243: LD_VAR 0 2
40247: ARRAY
40248: IFFALSE 40284
// begin MC_Reset ( i , 125 ) ;
40250: LD_VAR 0 2
40254: PPUSH
40255: LD_INT 125
40257: PPUSH
40258: CALL 22862 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40262: LD_ADDR_EXP 88
40266: PUSH
40267: LD_EXP 88
40271: PPUSH
40272: LD_VAR 0 2
40276: PPUSH
40277: EMPTY
40278: PPUSH
40279: CALL_OW 1
40283: ST_TO_ADDR
// end ; continue ;
40284: GO 40036
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40286: LD_EXP 87
40290: PUSH
40291: LD_VAR 0 2
40295: ARRAY
40296: PUSH
40297: LD_INT 1
40299: ARRAY
40300: PUSH
40301: LD_INT 1
40303: ARRAY
40304: PPUSH
40305: LD_EXP 87
40309: PUSH
40310: LD_VAR 0 2
40314: ARRAY
40315: PUSH
40316: LD_INT 1
40318: ARRAY
40319: PUSH
40320: LD_INT 2
40322: ARRAY
40323: PPUSH
40324: LD_EXP 76
40328: PUSH
40329: LD_VAR 0 2
40333: ARRAY
40334: PPUSH
40335: CALL_OW 440
40339: IFFALSE 40382
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
40341: LD_ADDR_EXP 87
40345: PUSH
40346: LD_EXP 87
40350: PPUSH
40351: LD_VAR 0 2
40355: PPUSH
40356: LD_EXP 87
40360: PUSH
40361: LD_VAR 0 2
40365: ARRAY
40366: PPUSH
40367: LD_INT 1
40369: PPUSH
40370: CALL_OW 3
40374: PPUSH
40375: CALL_OW 1
40379: ST_TO_ADDR
40380: GO 40631
// begin if not mc_deposits_finder [ i ] then
40382: LD_EXP 88
40386: PUSH
40387: LD_VAR 0 2
40391: ARRAY
40392: NOT
40393: IFFALSE 40445
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
40395: LD_ADDR_EXP 88
40399: PUSH
40400: LD_EXP 88
40404: PPUSH
40405: LD_VAR 0 2
40409: PPUSH
40410: LD_VAR 0 3
40414: PUSH
40415: LD_INT 1
40417: ARRAY
40418: PUSH
40419: EMPTY
40420: LIST
40421: PPUSH
40422: CALL_OW 1
40426: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
40427: LD_VAR 0 3
40431: PUSH
40432: LD_INT 1
40434: ARRAY
40435: PPUSH
40436: LD_INT 125
40438: PPUSH
40439: CALL_OW 109
// end else
40443: GO 40631
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
40445: LD_EXP 88
40449: PUSH
40450: LD_VAR 0 2
40454: ARRAY
40455: PUSH
40456: LD_INT 1
40458: ARRAY
40459: PPUSH
40460: CALL_OW 310
40464: IFFALSE 40487
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
40466: LD_EXP 88
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: PUSH
40477: LD_INT 1
40479: ARRAY
40480: PPUSH
40481: CALL_OW 122
40485: GO 40631
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
40487: LD_EXP 88
40491: PUSH
40492: LD_VAR 0 2
40496: ARRAY
40497: PUSH
40498: LD_INT 1
40500: ARRAY
40501: PPUSH
40502: CALL_OW 314
40506: NOT
40507: IFFALSE 40572
40509: PUSH
40510: LD_EXP 88
40514: PUSH
40515: LD_VAR 0 2
40519: ARRAY
40520: PUSH
40521: LD_INT 1
40523: ARRAY
40524: PPUSH
40525: LD_EXP 87
40529: PUSH
40530: LD_VAR 0 2
40534: ARRAY
40535: PUSH
40536: LD_INT 1
40538: ARRAY
40539: PUSH
40540: LD_INT 1
40542: ARRAY
40543: PPUSH
40544: LD_EXP 87
40548: PUSH
40549: LD_VAR 0 2
40553: ARRAY
40554: PUSH
40555: LD_INT 1
40557: ARRAY
40558: PUSH
40559: LD_INT 2
40561: ARRAY
40562: PPUSH
40563: CALL_OW 297
40567: PUSH
40568: LD_INT 6
40570: GREATER
40571: AND
40572: IFFALSE 40631
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40574: LD_EXP 88
40578: PUSH
40579: LD_VAR 0 2
40583: ARRAY
40584: PUSH
40585: LD_INT 1
40587: ARRAY
40588: PPUSH
40589: LD_EXP 87
40593: PUSH
40594: LD_VAR 0 2
40598: ARRAY
40599: PUSH
40600: LD_INT 1
40602: ARRAY
40603: PUSH
40604: LD_INT 1
40606: ARRAY
40607: PPUSH
40608: LD_EXP 87
40612: PUSH
40613: LD_VAR 0 2
40617: ARRAY
40618: PUSH
40619: LD_INT 1
40621: ARRAY
40622: PUSH
40623: LD_INT 2
40625: ARRAY
40626: PPUSH
40627: CALL_OW 111
// end ; end ; end ;
40631: GO 40036
40633: POP
40634: POP
// end ;
40635: LD_VAR 0 1
40639: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40640: LD_INT 0
40642: PPUSH
40643: PPUSH
40644: PPUSH
40645: PPUSH
40646: PPUSH
40647: PPUSH
40648: PPUSH
40649: PPUSH
40650: PPUSH
40651: PPUSH
40652: PPUSH
// if not mc_bases then
40653: LD_EXP 50
40657: NOT
40658: IFFALSE 40662
// exit ;
40660: GO 41622
// for i = 1 to mc_bases do
40662: LD_ADDR_VAR 0 2
40666: PUSH
40667: DOUBLE
40668: LD_INT 1
40670: DEC
40671: ST_TO_ADDR
40672: LD_EXP 50
40676: PUSH
40677: FOR_TO
40678: IFFALSE 41620
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40680: LD_EXP 50
40684: PUSH
40685: LD_VAR 0 2
40689: ARRAY
40690: NOT
40691: IFTRUE 40705
40693: PUSH
40694: LD_EXP 73
40698: PUSH
40699: LD_VAR 0 2
40703: ARRAY
40704: OR
40705: IFFALSE 40709
// continue ;
40707: GO 40677
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40709: LD_ADDR_VAR 0 7
40713: PUSH
40714: LD_EXP 50
40718: PUSH
40719: LD_VAR 0 2
40723: ARRAY
40724: PUSH
40725: LD_INT 1
40727: ARRAY
40728: PPUSH
40729: CALL_OW 248
40733: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40734: LD_VAR 0 7
40738: PUSH
40739: LD_INT 3
40741: EQUAL
40742: IFTRUE 40784
40744: PUSH
40745: LD_EXP 69
40749: PUSH
40750: LD_VAR 0 2
40754: ARRAY
40755: PUSH
40756: LD_EXP 72
40760: PUSH
40761: LD_VAR 0 2
40765: ARRAY
40766: UNION
40767: PPUSH
40768: LD_INT 33
40770: PUSH
40771: LD_INT 2
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PPUSH
40778: CALL_OW 72
40782: NOT
40783: OR
40784: IFFALSE 40788
// continue ;
40786: GO 40677
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40788: LD_ADDR_VAR 0 9
40792: PUSH
40793: LD_EXP 50
40797: PUSH
40798: LD_VAR 0 2
40802: ARRAY
40803: PPUSH
40804: LD_INT 30
40806: PUSH
40807: LD_INT 36
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PPUSH
40814: CALL_OW 72
40818: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40819: LD_ADDR_VAR 0 10
40823: PUSH
40824: LD_EXP 69
40828: PUSH
40829: LD_VAR 0 2
40833: ARRAY
40834: PPUSH
40835: LD_INT 34
40837: PUSH
40838: LD_INT 31
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PPUSH
40845: CALL_OW 72
40849: ST_TO_ADDR
// if not cts and not mcts then
40850: LD_VAR 0 9
40854: NOT
40855: IFFALSE 40864
40857: PUSH
40858: LD_VAR 0 10
40862: NOT
40863: AND
40864: IFFALSE 40868
// continue ;
40866: GO 40677
// x := cts ;
40868: LD_ADDR_VAR 0 11
40872: PUSH
40873: LD_VAR 0 9
40877: ST_TO_ADDR
// if not x then
40878: LD_VAR 0 11
40882: NOT
40883: IFFALSE 40895
// x := mcts ;
40885: LD_ADDR_VAR 0 11
40889: PUSH
40890: LD_VAR 0 10
40894: ST_TO_ADDR
// if not x then
40895: LD_VAR 0 11
40899: NOT
40900: IFFALSE 40904
// continue ;
40902: GO 40677
// if mc_remote_driver [ i ] then
40904: LD_EXP 90
40908: PUSH
40909: LD_VAR 0 2
40913: ARRAY
40914: IFFALSE 41313
// for j in mc_remote_driver [ i ] do
40916: LD_ADDR_VAR 0 3
40920: PUSH
40921: LD_EXP 90
40925: PUSH
40926: LD_VAR 0 2
40930: ARRAY
40931: PUSH
40932: FOR_IN
40933: IFFALSE 41311
// begin if GetClass ( j ) <> 3 then
40935: LD_VAR 0 3
40939: PPUSH
40940: CALL_OW 257
40944: PUSH
40945: LD_INT 3
40947: NONEQUAL
40948: IFFALSE 41001
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40950: LD_ADDR_EXP 90
40954: PUSH
40955: LD_EXP 90
40959: PPUSH
40960: LD_VAR 0 2
40964: PPUSH
40965: LD_EXP 90
40969: PUSH
40970: LD_VAR 0 2
40974: ARRAY
40975: PUSH
40976: LD_VAR 0 3
40980: DIFF
40981: PPUSH
40982: CALL_OW 1
40986: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40987: LD_VAR 0 3
40991: PPUSH
40992: LD_INT 0
40994: PPUSH
40995: CALL_OW 109
// continue ;
40999: GO 40932
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41001: LD_EXP 69
41005: PUSH
41006: LD_VAR 0 2
41010: ARRAY
41011: PPUSH
41012: LD_INT 34
41014: PUSH
41015: LD_INT 31
41017: PUSH
41018: EMPTY
41019: LIST
41020: LIST
41021: PUSH
41022: LD_INT 58
41024: PUSH
41025: EMPTY
41026: LIST
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PPUSH
41032: CALL_OW 72
41036: IFFALSE 41050
41038: PUSH
41039: LD_VAR 0 3
41043: PPUSH
41044: CALL 85535 0 1
41048: NOT
41049: AND
41050: IFFALSE 41121
// begin if IsInUnit ( j ) then
41052: LD_VAR 0 3
41056: PPUSH
41057: CALL_OW 310
41061: IFFALSE 41072
// ComExitBuilding ( j ) ;
41063: LD_VAR 0 3
41067: PPUSH
41068: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
41072: LD_VAR 0 3
41076: PPUSH
41077: LD_EXP 69
41081: PUSH
41082: LD_VAR 0 2
41086: ARRAY
41087: PPUSH
41088: LD_INT 34
41090: PUSH
41091: LD_INT 31
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 58
41100: PUSH
41101: EMPTY
41102: LIST
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PPUSH
41108: CALL_OW 72
41112: PUSH
41113: LD_INT 1
41115: ARRAY
41116: PPUSH
41117: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41121: LD_VAR 0 3
41125: PPUSH
41126: CALL_OW 310
41130: NOT
41131: IFTRUE 41167
41133: PUSH
41134: LD_VAR 0 3
41138: PPUSH
41139: CALL_OW 310
41143: PPUSH
41144: CALL_OW 266
41148: PUSH
41149: LD_INT 36
41151: NONEQUAL
41152: IFFALSE 41166
41154: PUSH
41155: LD_VAR 0 3
41159: PPUSH
41160: CALL 85535 0 1
41164: NOT
41165: AND
41166: OR
41167: IFFALSE 41309
// begin if IsInUnit ( j ) then
41169: LD_VAR 0 3
41173: PPUSH
41174: CALL_OW 310
41178: IFFALSE 41189
// ComExitBuilding ( j ) ;
41180: LD_VAR 0 3
41184: PPUSH
41185: CALL_OW 122
// ct := 0 ;
41189: LD_ADDR_VAR 0 8
41193: PUSH
41194: LD_INT 0
41196: ST_TO_ADDR
// for k in x do
41197: LD_ADDR_VAR 0 4
41201: PUSH
41202: LD_VAR 0 11
41206: PUSH
41207: FOR_IN
41208: IFFALSE 41287
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41210: LD_VAR 0 4
41214: PPUSH
41215: CALL_OW 264
41219: PUSH
41220: LD_INT 31
41222: EQUAL
41223: IFFALSE 41237
41225: PUSH
41226: LD_VAR 0 4
41230: PPUSH
41231: CALL_OW 311
41235: NOT
41236: AND
41237: IFTRUE 41271
41239: PUSH
41240: LD_VAR 0 4
41244: PPUSH
41245: CALL_OW 266
41249: PUSH
41250: LD_INT 36
41252: EQUAL
41253: IFFALSE 41270
41255: PUSH
41256: LD_VAR 0 4
41260: PPUSH
41261: CALL_OW 313
41265: PUSH
41266: LD_INT 3
41268: LESS
41269: AND
41270: OR
41271: IFFALSE 41285
// begin ct := k ;
41273: LD_ADDR_VAR 0 8
41277: PUSH
41278: LD_VAR 0 4
41282: ST_TO_ADDR
// break ;
41283: GO 41287
// end ;
41285: GO 41207
41287: POP
41288: POP
// if ct then
41289: LD_VAR 0 8
41293: IFFALSE 41309
// ComEnterUnit ( j , ct ) ;
41295: LD_VAR 0 3
41299: PPUSH
41300: LD_VAR 0 8
41304: PPUSH
41305: CALL_OW 120
// end ; end ;
41309: GO 40932
41311: POP
41312: POP
// places := 0 ;
41313: LD_ADDR_VAR 0 5
41317: PUSH
41318: LD_INT 0
41320: ST_TO_ADDR
// for j = 1 to x do
41321: LD_ADDR_VAR 0 3
41325: PUSH
41326: DOUBLE
41327: LD_INT 1
41329: DEC
41330: ST_TO_ADDR
41331: LD_VAR 0 11
41335: PUSH
41336: FOR_TO
41337: IFFALSE 41413
// if GetWeapon ( x [ j ] ) = ar_control_tower then
41339: LD_VAR 0 11
41343: PUSH
41344: LD_VAR 0 3
41348: ARRAY
41349: PPUSH
41350: CALL_OW 264
41354: PUSH
41355: LD_INT 31
41357: EQUAL
41358: IFFALSE 41376
// places := places + 1 else
41360: LD_ADDR_VAR 0 5
41364: PUSH
41365: LD_VAR 0 5
41369: PUSH
41370: LD_INT 1
41372: PLUS
41373: ST_TO_ADDR
41374: GO 41411
// if GetBType ( x [ j ] ) = b_control_tower then
41376: LD_VAR 0 11
41380: PUSH
41381: LD_VAR 0 3
41385: ARRAY
41386: PPUSH
41387: CALL_OW 266
41391: PUSH
41392: LD_INT 36
41394: EQUAL
41395: IFFALSE 41411
// places := places + 3 ;
41397: LD_ADDR_VAR 0 5
41401: PUSH
41402: LD_VAR 0 5
41406: PUSH
41407: LD_INT 3
41409: PLUS
41410: ST_TO_ADDR
41411: GO 41336
41413: POP
41414: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
41415: LD_VAR 0 5
41419: PUSH
41420: LD_INT 0
41422: EQUAL
41423: IFTRUE 41443
41425: PUSH
41426: LD_VAR 0 5
41430: PUSH
41431: LD_EXP 90
41435: PUSH
41436: LD_VAR 0 2
41440: ARRAY
41441: LESSEQUAL
41442: OR
41443: IFFALSE 41447
// continue ;
41445: GO 40677
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
41447: LD_ADDR_VAR 0 6
41451: PUSH
41452: LD_EXP 50
41456: PUSH
41457: LD_VAR 0 2
41461: ARRAY
41462: PPUSH
41463: LD_INT 25
41465: PUSH
41466: LD_INT 3
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PPUSH
41473: CALL_OW 72
41477: PUSH
41478: LD_EXP 90
41482: PUSH
41483: LD_VAR 0 2
41487: ARRAY
41488: DIFF
41489: PPUSH
41490: LD_INT 3
41492: PPUSH
41493: CALL 86435 0 2
41497: ST_TO_ADDR
// for j in tmp do
41498: LD_ADDR_VAR 0 3
41502: PUSH
41503: LD_VAR 0 6
41507: PUSH
41508: FOR_IN
41509: IFFALSE 41544
// if GetTag ( j ) > 0 then
41511: LD_VAR 0 3
41515: PPUSH
41516: CALL_OW 110
41520: PUSH
41521: LD_INT 0
41523: GREATER
41524: IFFALSE 41542
// tmp := tmp diff j ;
41526: LD_ADDR_VAR 0 6
41530: PUSH
41531: LD_VAR 0 6
41535: PUSH
41536: LD_VAR 0 3
41540: DIFF
41541: ST_TO_ADDR
41542: GO 41508
41544: POP
41545: POP
// if not tmp then
41546: LD_VAR 0 6
41550: NOT
41551: IFFALSE 41555
// continue ;
41553: GO 40677
// if places then
41555: LD_VAR 0 5
41559: IFFALSE 41618
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41561: LD_ADDR_EXP 90
41565: PUSH
41566: LD_EXP 90
41570: PPUSH
41571: LD_VAR 0 2
41575: PPUSH
41576: LD_EXP 90
41580: PUSH
41581: LD_VAR 0 2
41585: ARRAY
41586: PUSH
41587: LD_VAR 0 6
41591: PUSH
41592: LD_INT 1
41594: ARRAY
41595: UNION
41596: PPUSH
41597: CALL_OW 1
41601: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41602: LD_VAR 0 6
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PPUSH
41611: LD_INT 126
41613: PPUSH
41614: CALL_OW 109
// end ; end ;
41618: GO 40677
41620: POP
41621: POP
// end ;
41622: LD_VAR 0 1
41626: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41627: LD_INT 0
41629: PPUSH
41630: PPUSH
41631: PPUSH
41632: PPUSH
41633: PPUSH
41634: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41635: LD_VAR 0 1
41639: NOT
41640: IFTRUE 41649
41642: PUSH
41643: LD_VAR 0 2
41647: NOT
41648: OR
41649: IFTRUE 41658
41651: PUSH
41652: LD_VAR 0 3
41656: NOT
41657: OR
41658: IFTRUE 41706
41660: PUSH
41661: LD_VAR 0 4
41665: PUSH
41666: LD_INT 1
41668: PUSH
41669: LD_INT 2
41671: PUSH
41672: LD_INT 3
41674: PUSH
41675: LD_INT 4
41677: PUSH
41678: LD_INT 5
41680: PUSH
41681: LD_INT 8
41683: PUSH
41684: LD_INT 9
41686: PUSH
41687: LD_INT 15
41689: PUSH
41690: LD_INT 16
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: IN
41704: NOT
41705: OR
41706: IFFALSE 41710
// exit ;
41708: GO 42570
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41710: LD_ADDR_VAR 0 2
41714: PUSH
41715: LD_VAR 0 2
41719: PPUSH
41720: LD_INT 21
41722: PUSH
41723: LD_INT 3
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 24
41732: PUSH
41733: LD_INT 250
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PPUSH
41744: CALL_OW 72
41748: ST_TO_ADDR
// case class of 1 , 15 :
41749: LD_VAR 0 4
41753: PUSH
41754: LD_INT 1
41756: DOUBLE
41757: EQUAL
41758: IFTRUE 41768
41760: LD_INT 15
41762: DOUBLE
41763: EQUAL
41764: IFTRUE 41768
41766: GO 41853
41768: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41769: LD_ADDR_VAR 0 8
41773: PUSH
41774: LD_VAR 0 2
41778: PPUSH
41779: LD_INT 2
41781: PUSH
41782: LD_INT 30
41784: PUSH
41785: LD_INT 32
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PUSH
41792: LD_INT 30
41794: PUSH
41795: LD_INT 31
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: LIST
41806: PPUSH
41807: CALL_OW 72
41811: PUSH
41812: LD_VAR 0 2
41816: PPUSH
41817: LD_INT 2
41819: PUSH
41820: LD_INT 30
41822: PUSH
41823: LD_INT 4
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 30
41832: PUSH
41833: LD_INT 5
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: LIST
41844: PPUSH
41845: CALL_OW 72
41849: ADD
41850: ST_TO_ADDR
41851: GO 42099
41853: LD_INT 2
41855: DOUBLE
41856: EQUAL
41857: IFTRUE 41867
41859: LD_INT 16
41861: DOUBLE
41862: EQUAL
41863: IFTRUE 41867
41865: GO 41913
41867: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41868: LD_ADDR_VAR 0 8
41872: PUSH
41873: LD_VAR 0 2
41877: PPUSH
41878: LD_INT 2
41880: PUSH
41881: LD_INT 30
41883: PUSH
41884: LD_INT 0
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 30
41893: PUSH
41894: LD_INT 1
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: LIST
41905: PPUSH
41906: CALL_OW 72
41910: ST_TO_ADDR
41911: GO 42099
41913: LD_INT 3
41915: DOUBLE
41916: EQUAL
41917: IFTRUE 41921
41919: GO 41967
41921: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41922: LD_ADDR_VAR 0 8
41926: PUSH
41927: LD_VAR 0 2
41931: PPUSH
41932: LD_INT 2
41934: PUSH
41935: LD_INT 30
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 30
41947: PUSH
41948: LD_INT 3
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: LIST
41959: PPUSH
41960: CALL_OW 72
41964: ST_TO_ADDR
41965: GO 42099
41967: LD_INT 4
41969: DOUBLE
41970: EQUAL
41971: IFTRUE 41975
41973: GO 42032
41975: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41976: LD_ADDR_VAR 0 8
41980: PUSH
41981: LD_VAR 0 2
41985: PPUSH
41986: LD_INT 2
41988: PUSH
41989: LD_INT 30
41991: PUSH
41992: LD_INT 6
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 30
42001: PUSH
42002: LD_INT 7
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 30
42011: PUSH
42012: LD_INT 8
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: LIST
42023: LIST
42024: PPUSH
42025: CALL_OW 72
42029: ST_TO_ADDR
42030: GO 42099
42032: LD_INT 5
42034: DOUBLE
42035: EQUAL
42036: IFTRUE 42052
42038: LD_INT 8
42040: DOUBLE
42041: EQUAL
42042: IFTRUE 42052
42044: LD_INT 9
42046: DOUBLE
42047: EQUAL
42048: IFTRUE 42052
42050: GO 42098
42052: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42053: LD_ADDR_VAR 0 8
42057: PUSH
42058: LD_VAR 0 2
42062: PPUSH
42063: LD_INT 2
42065: PUSH
42066: LD_INT 30
42068: PUSH
42069: LD_INT 4
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 30
42078: PUSH
42079: LD_INT 5
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: EMPTY
42087: LIST
42088: LIST
42089: LIST
42090: PPUSH
42091: CALL_OW 72
42095: ST_TO_ADDR
42096: GO 42099
42098: POP
// if not tmp then
42099: LD_VAR 0 8
42103: NOT
42104: IFFALSE 42108
// exit ;
42106: GO 42570
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42108: LD_VAR 0 4
42112: PUSH
42113: LD_INT 1
42115: PUSH
42116: LD_INT 15
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: IN
42123: IFFALSE 42137
42125: PUSH
42126: LD_EXP 59
42130: PUSH
42131: LD_VAR 0 1
42135: ARRAY
42136: AND
42137: IFFALSE 42293
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42139: LD_ADDR_VAR 0 9
42143: PUSH
42144: LD_EXP 59
42148: PUSH
42149: LD_VAR 0 1
42153: ARRAY
42154: PUSH
42155: LD_INT 1
42157: ARRAY
42158: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42159: LD_VAR 0 9
42163: PUSH
42164: LD_EXP 60
42168: PUSH
42169: LD_VAR 0 1
42173: ARRAY
42174: IN
42175: NOT
42176: IFFALSE 42291
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42178: LD_ADDR_EXP 60
42182: PUSH
42183: LD_EXP 60
42187: PPUSH
42188: LD_VAR 0 1
42192: PUSH
42193: LD_EXP 60
42197: PUSH
42198: LD_VAR 0 1
42202: ARRAY
42203: PUSH
42204: LD_INT 1
42206: PLUS
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PPUSH
42212: LD_VAR 0 9
42216: PPUSH
42217: CALL 54897 0 3
42221: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42222: LD_ADDR_EXP 59
42226: PUSH
42227: LD_EXP 59
42231: PPUSH
42232: LD_VAR 0 1
42236: PPUSH
42237: LD_EXP 59
42241: PUSH
42242: LD_VAR 0 1
42246: ARRAY
42247: PUSH
42248: LD_VAR 0 9
42252: DIFF
42253: PPUSH
42254: CALL_OW 1
42258: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42259: LD_VAR 0 3
42263: PPUSH
42264: LD_EXP 60
42268: PUSH
42269: LD_VAR 0 1
42273: ARRAY
42274: PUSH
42275: LD_EXP 60
42279: PUSH
42280: LD_VAR 0 1
42284: ARRAY
42285: ARRAY
42286: PPUSH
42287: CALL_OW 120
// end ; exit ;
42291: GO 42570
// end ; if tmp > 1 then
42293: LD_VAR 0 8
42297: PUSH
42298: LD_INT 1
42300: GREATER
42301: IFFALSE 42405
// for i = 2 to tmp do
42303: LD_ADDR_VAR 0 6
42307: PUSH
42308: DOUBLE
42309: LD_INT 2
42311: DEC
42312: ST_TO_ADDR
42313: LD_VAR 0 8
42317: PUSH
42318: FOR_TO
42319: IFFALSE 42403
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42321: LD_VAR 0 8
42325: PUSH
42326: LD_VAR 0 6
42330: ARRAY
42331: PPUSH
42332: CALL_OW 461
42336: PUSH
42337: LD_INT 6
42339: EQUAL
42340: IFFALSE 42401
// begin x := tmp [ i ] ;
42342: LD_ADDR_VAR 0 9
42346: PUSH
42347: LD_VAR 0 8
42351: PUSH
42352: LD_VAR 0 6
42356: ARRAY
42357: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
42358: LD_ADDR_VAR 0 8
42362: PUSH
42363: LD_VAR 0 8
42367: PPUSH
42368: LD_VAR 0 6
42372: PPUSH
42373: CALL_OW 3
42377: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
42378: LD_ADDR_VAR 0 8
42382: PUSH
42383: LD_VAR 0 8
42387: PPUSH
42388: LD_INT 1
42390: PPUSH
42391: LD_VAR 0 9
42395: PPUSH
42396: CALL_OW 2
42400: ST_TO_ADDR
// end ;
42401: GO 42318
42403: POP
42404: POP
// for i in tmp do
42405: LD_ADDR_VAR 0 6
42409: PUSH
42410: LD_VAR 0 8
42414: PUSH
42415: FOR_IN
42416: IFFALSE 42443
// begin if IsNotFull ( i ) then
42418: LD_VAR 0 6
42422: PPUSH
42423: CALL 52061 0 1
42427: IFFALSE 42441
// begin j := i ;
42429: LD_ADDR_VAR 0 7
42433: PUSH
42434: LD_VAR 0 6
42438: ST_TO_ADDR
// break ;
42439: GO 42443
// end ; end ;
42441: GO 42415
42443: POP
42444: POP
// if j then
42445: LD_VAR 0 7
42449: IFFALSE 42467
// ComEnterUnit ( unit , j ) else
42451: LD_VAR 0 3
42455: PPUSH
42456: LD_VAR 0 7
42460: PPUSH
42461: CALL_OW 120
42465: GO 42570
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42467: LD_ADDR_VAR 0 10
42471: PUSH
42472: LD_VAR 0 2
42476: PPUSH
42477: LD_INT 2
42479: PUSH
42480: LD_INT 30
42482: PUSH
42483: LD_INT 0
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: PUSH
42490: LD_INT 30
42492: PUSH
42493: LD_INT 1
42495: PUSH
42496: EMPTY
42497: LIST
42498: LIST
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: LIST
42504: PPUSH
42505: CALL_OW 72
42509: ST_TO_ADDR
// if depot then
42510: LD_VAR 0 10
42514: IFFALSE 42570
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42516: LD_ADDR_VAR 0 10
42520: PUSH
42521: LD_VAR 0 10
42525: PPUSH
42526: LD_VAR 0 3
42530: PPUSH
42531: CALL_OW 74
42535: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42536: LD_VAR 0 3
42540: PPUSH
42541: LD_VAR 0 10
42545: PPUSH
42546: CALL_OW 296
42550: PUSH
42551: LD_INT 10
42553: GREATER
42554: IFFALSE 42570
// ComStandNearbyBuilding ( unit , depot ) ;
42556: LD_VAR 0 3
42560: PPUSH
42561: LD_VAR 0 10
42565: PPUSH
42566: CALL 51439 0 2
// end ; end ; end ;
42570: LD_VAR 0 5
42574: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42575: LD_INT 0
42577: PPUSH
42578: PPUSH
42579: PPUSH
42580: PPUSH
// if not mc_bases then
42581: LD_EXP 50
42585: NOT
42586: IFFALSE 42590
// exit ;
42588: GO 42841
// for i = 1 to mc_bases do
42590: LD_ADDR_VAR 0 2
42594: PUSH
42595: DOUBLE
42596: LD_INT 1
42598: DEC
42599: ST_TO_ADDR
42600: LD_EXP 50
42604: PUSH
42605: FOR_TO
42606: IFFALSE 42839
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42608: LD_ADDR_VAR 0 4
42612: PUSH
42613: LD_EXP 50
42617: PUSH
42618: LD_VAR 0 2
42622: ARRAY
42623: PPUSH
42624: LD_INT 21
42626: PUSH
42627: LD_INT 1
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PPUSH
42634: CALL_OW 72
42638: PUSH
42639: LD_EXP 79
42643: PUSH
42644: LD_VAR 0 2
42648: ARRAY
42649: UNION
42650: ST_TO_ADDR
// if not tmp then
42651: LD_VAR 0 4
42655: NOT
42656: IFFALSE 42660
// continue ;
42658: GO 42605
// for j in tmp do
42660: LD_ADDR_VAR 0 3
42664: PUSH
42665: LD_VAR 0 4
42669: PUSH
42670: FOR_IN
42671: IFFALSE 42835
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42673: LD_VAR 0 3
42677: PPUSH
42678: CALL_OW 110
42682: NOT
42683: IFFALSE 42697
42685: PUSH
42686: LD_VAR 0 3
42690: PPUSH
42691: CALL_OW 314
42695: NOT
42696: AND
42697: IFFALSE 42711
42699: PUSH
42700: LD_VAR 0 3
42704: PPUSH
42705: CALL_OW 311
42709: NOT
42710: AND
42711: IFFALSE 42725
42713: PUSH
42714: LD_VAR 0 3
42718: PPUSH
42719: CALL_OW 310
42723: NOT
42724: AND
42725: IFFALSE 42750
42727: PUSH
42728: LD_VAR 0 3
42732: PUSH
42733: LD_EXP 53
42737: PUSH
42738: LD_VAR 0 2
42742: ARRAY
42743: PUSH
42744: LD_INT 1
42746: ARRAY
42747: IN
42748: NOT
42749: AND
42750: IFFALSE 42775
42752: PUSH
42753: LD_VAR 0 3
42757: PUSH
42758: LD_EXP 53
42762: PUSH
42763: LD_VAR 0 2
42767: ARRAY
42768: PUSH
42769: LD_INT 2
42771: ARRAY
42772: IN
42773: NOT
42774: AND
42775: IFFALSE 42796
42777: PUSH
42778: LD_VAR 0 3
42782: PUSH
42783: LD_EXP 62
42787: PUSH
42788: LD_VAR 0 2
42792: ARRAY
42793: IN
42794: NOT
42795: AND
42796: IFFALSE 42833
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42798: LD_VAR 0 2
42802: PPUSH
42803: LD_EXP 50
42807: PUSH
42808: LD_VAR 0 2
42812: ARRAY
42813: PPUSH
42814: LD_VAR 0 3
42818: PPUSH
42819: LD_VAR 0 3
42823: PPUSH
42824: CALL_OW 257
42828: PPUSH
42829: CALL 41627 0 4
// end ;
42833: GO 42670
42835: POP
42836: POP
// end ;
42837: GO 42605
42839: POP
42840: POP
// end ;
42841: LD_VAR 0 1
42845: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42846: LD_INT 0
42848: PPUSH
42849: PPUSH
42850: PPUSH
42851: PPUSH
42852: PPUSH
42853: PPUSH
// if not mc_bases [ base ] then
42854: LD_EXP 50
42858: PUSH
42859: LD_VAR 0 1
42863: ARRAY
42864: NOT
42865: IFFALSE 42869
// exit ;
42867: GO 43070
// tmp := [ ] ;
42869: LD_ADDR_VAR 0 6
42873: PUSH
42874: EMPTY
42875: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42876: LD_ADDR_VAR 0 7
42880: PUSH
42881: LD_VAR 0 3
42885: PPUSH
42886: LD_INT 0
42888: PPUSH
42889: CALL_OW 517
42893: ST_TO_ADDR
// if not list then
42894: LD_VAR 0 7
42898: NOT
42899: IFFALSE 42903
// exit ;
42901: GO 43070
// c := Count ( list [ 1 ] ) ;
42903: LD_ADDR_VAR 0 9
42907: PUSH
42908: LD_VAR 0 7
42912: PUSH
42913: LD_INT 1
42915: ARRAY
42916: PPUSH
42917: CALL 51979 0 1
42921: ST_TO_ADDR
// if amount > c then
42922: LD_VAR 0 2
42926: PUSH
42927: LD_VAR 0 9
42931: GREATER
42932: IFFALSE 42944
// amount := c ;
42934: LD_ADDR_VAR 0 2
42938: PUSH
42939: LD_VAR 0 9
42943: ST_TO_ADDR
// for i := 1 to amount do
42944: LD_ADDR_VAR 0 5
42948: PUSH
42949: DOUBLE
42950: LD_INT 1
42952: DEC
42953: ST_TO_ADDR
42954: LD_VAR 0 2
42958: PUSH
42959: FOR_TO
42960: IFFALSE 43018
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42962: LD_ADDR_VAR 0 6
42966: PUSH
42967: LD_VAR 0 6
42971: PPUSH
42972: LD_VAR 0 5
42976: PPUSH
42977: LD_VAR 0 7
42981: PUSH
42982: LD_INT 1
42984: ARRAY
42985: PUSH
42986: LD_VAR 0 5
42990: ARRAY
42991: PUSH
42992: LD_VAR 0 7
42996: PUSH
42997: LD_INT 2
42999: ARRAY
43000: PUSH
43001: LD_VAR 0 5
43005: ARRAY
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PPUSH
43011: CALL_OW 1
43015: ST_TO_ADDR
43016: GO 42959
43018: POP
43019: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43020: LD_ADDR_EXP 63
43024: PUSH
43025: LD_EXP 63
43029: PPUSH
43030: LD_VAR 0 1
43034: PPUSH
43035: LD_VAR 0 6
43039: PPUSH
43040: CALL_OW 1
43044: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43045: LD_ADDR_EXP 65
43049: PUSH
43050: LD_EXP 65
43054: PPUSH
43055: LD_VAR 0 1
43059: PPUSH
43060: LD_VAR 0 3
43064: PPUSH
43065: CALL_OW 1
43069: ST_TO_ADDR
// end ;
43070: LD_VAR 0 4
43074: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43075: LD_INT 0
43077: PPUSH
// if not mc_bases [ base ] then
43078: LD_EXP 50
43082: PUSH
43083: LD_VAR 0 1
43087: ARRAY
43088: NOT
43089: IFFALSE 43093
// exit ;
43091: GO 43118
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43093: LD_ADDR_EXP 55
43097: PUSH
43098: LD_EXP 55
43102: PPUSH
43103: LD_VAR 0 1
43107: PPUSH
43108: LD_VAR 0 2
43112: PPUSH
43113: CALL_OW 1
43117: ST_TO_ADDR
// end ;
43118: LD_VAR 0 3
43122: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43123: LD_INT 0
43125: PPUSH
// if not mc_bases [ base ] then
43126: LD_EXP 50
43130: PUSH
43131: LD_VAR 0 1
43135: ARRAY
43136: NOT
43137: IFFALSE 43141
// exit ;
43139: GO 43178
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43141: LD_ADDR_EXP 55
43145: PUSH
43146: LD_EXP 55
43150: PPUSH
43151: LD_VAR 0 1
43155: PPUSH
43156: LD_EXP 55
43160: PUSH
43161: LD_VAR 0 1
43165: ARRAY
43166: PUSH
43167: LD_VAR 0 2
43171: UNION
43172: PPUSH
43173: CALL_OW 1
43177: ST_TO_ADDR
// end ;
43178: LD_VAR 0 3
43182: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43183: LD_INT 0
43185: PPUSH
// if not mc_bases [ base ] then
43186: LD_EXP 50
43190: PUSH
43191: LD_VAR 0 1
43195: ARRAY
43196: NOT
43197: IFFALSE 43201
// exit ;
43199: GO 43226
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43201: LD_ADDR_EXP 71
43205: PUSH
43206: LD_EXP 71
43210: PPUSH
43211: LD_VAR 0 1
43215: PPUSH
43216: LD_VAR 0 2
43220: PPUSH
43221: CALL_OW 1
43225: ST_TO_ADDR
// end ;
43226: LD_VAR 0 3
43230: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43231: LD_INT 0
43233: PPUSH
// if not mc_bases [ base ] then
43234: LD_EXP 50
43238: PUSH
43239: LD_VAR 0 1
43243: ARRAY
43244: NOT
43245: IFFALSE 43249
// exit ;
43247: GO 43286
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43249: LD_ADDR_EXP 71
43253: PUSH
43254: LD_EXP 71
43258: PPUSH
43259: LD_VAR 0 1
43263: PPUSH
43264: LD_EXP 71
43268: PUSH
43269: LD_VAR 0 1
43273: ARRAY
43274: PUSH
43275: LD_VAR 0 2
43279: ADD
43280: PPUSH
43281: CALL_OW 1
43285: ST_TO_ADDR
// end ;
43286: LD_VAR 0 3
43290: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43291: LD_INT 0
43293: PPUSH
// if not mc_bases [ base ] then
43294: LD_EXP 50
43298: PUSH
43299: LD_VAR 0 1
43303: ARRAY
43304: NOT
43305: IFFALSE 43309
// exit ;
43307: GO 43363
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43309: LD_ADDR_EXP 72
43313: PUSH
43314: LD_EXP 72
43318: PPUSH
43319: LD_VAR 0 1
43323: PPUSH
43324: LD_VAR 0 2
43328: PPUSH
43329: CALL_OW 1
43333: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
43334: LD_ADDR_EXP 61
43338: PUSH
43339: LD_EXP 61
43343: PPUSH
43344: LD_VAR 0 1
43348: PPUSH
43349: LD_VAR 0 2
43353: PUSH
43354: LD_INT 0
43356: PLUS
43357: PPUSH
43358: CALL_OW 1
43362: ST_TO_ADDR
// end ;
43363: LD_VAR 0 3
43367: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
43368: LD_INT 0
43370: PPUSH
// if not mc_bases [ base ] then
43371: LD_EXP 50
43375: PUSH
43376: LD_VAR 0 1
43380: ARRAY
43381: NOT
43382: IFFALSE 43386
// exit ;
43384: GO 43411
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
43386: LD_ADDR_EXP 61
43390: PUSH
43391: LD_EXP 61
43395: PPUSH
43396: LD_VAR 0 1
43400: PPUSH
43401: LD_VAR 0 2
43405: PPUSH
43406: CALL_OW 1
43410: ST_TO_ADDR
// end ;
43411: LD_VAR 0 3
43415: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
43416: LD_INT 0
43418: PPUSH
43419: PPUSH
43420: PPUSH
43421: PPUSH
// if not mc_bases [ base ] then
43422: LD_EXP 50
43426: PUSH
43427: LD_VAR 0 1
43431: ARRAY
43432: NOT
43433: IFFALSE 43437
// exit ;
43435: GO 43502
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
43437: LD_ADDR_EXP 70
43441: PUSH
43442: LD_EXP 70
43446: PPUSH
43447: LD_VAR 0 1
43451: PUSH
43452: LD_EXP 70
43456: PUSH
43457: LD_VAR 0 1
43461: ARRAY
43462: PUSH
43463: LD_INT 1
43465: PLUS
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PPUSH
43471: LD_VAR 0 1
43475: PUSH
43476: LD_VAR 0 2
43480: PUSH
43481: LD_VAR 0 3
43485: PUSH
43486: LD_VAR 0 4
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: LIST
43495: LIST
43496: PPUSH
43497: CALL 54897 0 3
43501: ST_TO_ADDR
// end ;
43502: LD_VAR 0 5
43506: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43507: LD_INT 0
43509: PPUSH
// if not mc_bases [ base ] then
43510: LD_EXP 50
43514: PUSH
43515: LD_VAR 0 1
43519: ARRAY
43520: NOT
43521: IFFALSE 43525
// exit ;
43523: GO 43550
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43525: LD_ADDR_EXP 87
43529: PUSH
43530: LD_EXP 87
43534: PPUSH
43535: LD_VAR 0 1
43539: PPUSH
43540: LD_VAR 0 2
43544: PPUSH
43545: CALL_OW 1
43549: ST_TO_ADDR
// end ;
43550: LD_VAR 0 3
43554: RET
// export function MC_GetMinesField ( base ) ; begin
43555: LD_INT 0
43557: PPUSH
// result := mc_mines [ base ] ;
43558: LD_ADDR_VAR 0 2
43562: PUSH
43563: LD_EXP 63
43567: PUSH
43568: LD_VAR 0 1
43572: ARRAY
43573: ST_TO_ADDR
// end ;
43574: LD_VAR 0 2
43578: RET
// export function MC_GetProduceList ( base ) ; begin
43579: LD_INT 0
43581: PPUSH
// result := mc_produce [ base ] ;
43582: LD_ADDR_VAR 0 2
43586: PUSH
43587: LD_EXP 71
43591: PUSH
43592: LD_VAR 0 1
43596: ARRAY
43597: ST_TO_ADDR
// end ;
43598: LD_VAR 0 2
43602: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43603: LD_INT 0
43605: PPUSH
43606: PPUSH
// if not mc_bases then
43607: LD_EXP 50
43611: NOT
43612: IFFALSE 43616
// exit ;
43614: GO 43681
// if mc_bases [ base ] then
43616: LD_EXP 50
43620: PUSH
43621: LD_VAR 0 1
43625: ARRAY
43626: IFFALSE 43681
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43628: LD_ADDR_VAR 0 3
43632: PUSH
43633: LD_EXP 50
43637: PUSH
43638: LD_VAR 0 1
43642: ARRAY
43643: PPUSH
43644: LD_INT 30
43646: PUSH
43647: LD_VAR 0 2
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PPUSH
43656: CALL_OW 72
43660: ST_TO_ADDR
// if result then
43661: LD_VAR 0 3
43665: IFFALSE 43681
// result := result [ 1 ] ;
43667: LD_ADDR_VAR 0 3
43671: PUSH
43672: LD_VAR 0 3
43676: PUSH
43677: LD_INT 1
43679: ARRAY
43680: ST_TO_ADDR
// end ; end ;
43681: LD_VAR 0 3
43685: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43686: LD_INT 0
43688: PPUSH
43689: PPUSH
// if not mc_bases then
43690: LD_EXP 50
43694: NOT
43695: IFFALSE 43699
// exit ;
43697: GO 43744
// if mc_bases [ base ] then
43699: LD_EXP 50
43703: PUSH
43704: LD_VAR 0 1
43708: ARRAY
43709: IFFALSE 43744
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43711: LD_ADDR_VAR 0 3
43715: PUSH
43716: LD_EXP 50
43720: PUSH
43721: LD_VAR 0 1
43725: ARRAY
43726: PPUSH
43727: LD_INT 30
43729: PUSH
43730: LD_VAR 0 2
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PPUSH
43739: CALL_OW 72
43743: ST_TO_ADDR
// end ;
43744: LD_VAR 0 3
43748: RET
// export function MC_SetTame ( base , area ) ; begin
43749: LD_INT 0
43751: PPUSH
// if not mc_bases or not base then
43752: LD_EXP 50
43756: NOT
43757: IFTRUE 43766
43759: PUSH
43760: LD_VAR 0 1
43764: NOT
43765: OR
43766: IFFALSE 43770
// exit ;
43768: GO 43795
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43770: LD_ADDR_EXP 78
43774: PUSH
43775: LD_EXP 78
43779: PPUSH
43780: LD_VAR 0 1
43784: PPUSH
43785: LD_VAR 0 2
43789: PPUSH
43790: CALL_OW 1
43794: ST_TO_ADDR
// end ;
43795: LD_VAR 0 3
43799: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43800: LD_INT 0
43802: PPUSH
43803: PPUSH
// if not mc_bases or not base then
43804: LD_EXP 50
43808: NOT
43809: IFTRUE 43818
43811: PUSH
43812: LD_VAR 0 1
43816: NOT
43817: OR
43818: IFFALSE 43822
// exit ;
43820: GO 43924
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43822: LD_ADDR_VAR 0 4
43826: PUSH
43827: LD_EXP 50
43831: PUSH
43832: LD_VAR 0 1
43836: ARRAY
43837: PPUSH
43838: LD_INT 30
43840: PUSH
43841: LD_VAR 0 2
43845: PUSH
43846: EMPTY
43847: LIST
43848: LIST
43849: PPUSH
43850: CALL_OW 72
43854: ST_TO_ADDR
// if not tmp then
43855: LD_VAR 0 4
43859: NOT
43860: IFFALSE 43864
// exit ;
43862: GO 43924
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43864: LD_ADDR_EXP 82
43868: PUSH
43869: LD_EXP 82
43873: PPUSH
43874: LD_VAR 0 1
43878: PPUSH
43879: LD_EXP 82
43883: PUSH
43884: LD_VAR 0 1
43888: ARRAY
43889: PPUSH
43890: LD_EXP 82
43894: PUSH
43895: LD_VAR 0 1
43899: ARRAY
43900: PUSH
43901: LD_INT 1
43903: PLUS
43904: PPUSH
43905: LD_VAR 0 4
43909: PUSH
43910: LD_INT 1
43912: ARRAY
43913: PPUSH
43914: CALL_OW 2
43918: PPUSH
43919: CALL_OW 1
43923: ST_TO_ADDR
// end ;
43924: LD_VAR 0 3
43928: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43929: LD_INT 0
43931: PPUSH
43932: PPUSH
// if not mc_bases or not base or not kinds then
43933: LD_EXP 50
43937: NOT
43938: IFTRUE 43947
43940: PUSH
43941: LD_VAR 0 1
43945: NOT
43946: OR
43947: IFTRUE 43956
43949: PUSH
43950: LD_VAR 0 2
43954: NOT
43955: OR
43956: IFFALSE 43960
// exit ;
43958: GO 44021
// for i in kinds do
43960: LD_ADDR_VAR 0 4
43964: PUSH
43965: LD_VAR 0 2
43969: PUSH
43970: FOR_IN
43971: IFFALSE 44019
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43973: LD_ADDR_EXP 84
43977: PUSH
43978: LD_EXP 84
43982: PPUSH
43983: LD_VAR 0 1
43987: PUSH
43988: LD_EXP 84
43992: PUSH
43993: LD_VAR 0 1
43997: ARRAY
43998: PUSH
43999: LD_INT 1
44001: PLUS
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PPUSH
44007: LD_VAR 0 4
44011: PPUSH
44012: CALL 54897 0 3
44016: ST_TO_ADDR
44017: GO 43970
44019: POP
44020: POP
// end ;
44021: LD_VAR 0 3
44025: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44026: LD_INT 0
44028: PPUSH
// if not mc_bases or not base or not areas then
44029: LD_EXP 50
44033: NOT
44034: IFTRUE 44043
44036: PUSH
44037: LD_VAR 0 1
44041: NOT
44042: OR
44043: IFTRUE 44052
44045: PUSH
44046: LD_VAR 0 2
44050: NOT
44051: OR
44052: IFFALSE 44056
// exit ;
44054: GO 44081
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44056: LD_ADDR_EXP 68
44060: PUSH
44061: LD_EXP 68
44065: PPUSH
44066: LD_VAR 0 1
44070: PPUSH
44071: LD_VAR 0 2
44075: PPUSH
44076: CALL_OW 1
44080: ST_TO_ADDR
// end ;
44081: LD_VAR 0 3
44085: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44086: LD_INT 0
44088: PPUSH
// if not mc_bases or not base or not teleports_exit then
44089: LD_EXP 50
44093: NOT
44094: IFTRUE 44103
44096: PUSH
44097: LD_VAR 0 1
44101: NOT
44102: OR
44103: IFTRUE 44112
44105: PUSH
44106: LD_VAR 0 2
44110: NOT
44111: OR
44112: IFFALSE 44116
// exit ;
44114: GO 44141
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44116: LD_ADDR_EXP 85
44120: PUSH
44121: LD_EXP 85
44125: PPUSH
44126: LD_VAR 0 1
44130: PPUSH
44131: LD_VAR 0 2
44135: PPUSH
44136: CALL_OW 1
44140: ST_TO_ADDR
// end ;
44141: LD_VAR 0 3
44145: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44146: LD_INT 0
44148: PPUSH
44149: PPUSH
44150: PPUSH
// if not mc_bases or not base or not ext_list then
44151: LD_EXP 50
44155: NOT
44156: IFTRUE 44165
44158: PUSH
44159: LD_VAR 0 1
44163: NOT
44164: OR
44165: IFTRUE 44174
44167: PUSH
44168: LD_VAR 0 5
44172: NOT
44173: OR
44174: IFFALSE 44178
// exit ;
44176: GO 44351
// tmp := GetFacExtXYD ( x , y , d ) ;
44178: LD_ADDR_VAR 0 8
44182: PUSH
44183: LD_VAR 0 2
44187: PPUSH
44188: LD_VAR 0 3
44192: PPUSH
44193: LD_VAR 0 4
44197: PPUSH
44198: CALL 85565 0 3
44202: ST_TO_ADDR
// if not tmp then
44203: LD_VAR 0 8
44207: NOT
44208: IFFALSE 44212
// exit ;
44210: GO 44351
// for i in tmp do
44212: LD_ADDR_VAR 0 7
44216: PUSH
44217: LD_VAR 0 8
44221: PUSH
44222: FOR_IN
44223: IFFALSE 44349
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44225: LD_ADDR_EXP 55
44229: PUSH
44230: LD_EXP 55
44234: PPUSH
44235: LD_VAR 0 1
44239: PPUSH
44240: LD_EXP 55
44244: PUSH
44245: LD_VAR 0 1
44249: ARRAY
44250: PPUSH
44251: LD_EXP 55
44255: PUSH
44256: LD_VAR 0 1
44260: ARRAY
44261: PUSH
44262: LD_INT 1
44264: PLUS
44265: PPUSH
44266: LD_VAR 0 5
44270: PUSH
44271: LD_INT 1
44273: ARRAY
44274: PUSH
44275: LD_VAR 0 7
44279: PUSH
44280: LD_INT 1
44282: ARRAY
44283: PUSH
44284: LD_VAR 0 7
44288: PUSH
44289: LD_INT 2
44291: ARRAY
44292: PUSH
44293: LD_VAR 0 7
44297: PUSH
44298: LD_INT 3
44300: ARRAY
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: PPUSH
44308: CALL_OW 2
44312: PPUSH
44313: CALL_OW 1
44317: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44318: LD_ADDR_VAR 0 5
44322: PUSH
44323: LD_VAR 0 5
44327: PPUSH
44328: LD_INT 1
44330: PPUSH
44331: CALL_OW 3
44335: ST_TO_ADDR
// if not ext_list then
44336: LD_VAR 0 5
44340: NOT
44341: IFFALSE 44347
// exit ;
44343: POP
44344: POP
44345: GO 44351
// end ;
44347: GO 44222
44349: POP
44350: POP
// end ;
44351: LD_VAR 0 6
44355: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
44356: LD_INT 0
44358: PPUSH
// if not mc_bases or not base or not weapon_list then
44359: LD_EXP 50
44363: NOT
44364: IFTRUE 44373
44366: PUSH
44367: LD_VAR 0 1
44371: NOT
44372: OR
44373: IFTRUE 44382
44375: PUSH
44376: LD_VAR 0 2
44380: NOT
44381: OR
44382: IFFALSE 44386
// exit ;
44384: GO 44411
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
44386: LD_ADDR_EXP 89
44390: PUSH
44391: LD_EXP 89
44395: PPUSH
44396: LD_VAR 0 1
44400: PPUSH
44401: LD_VAR 0 2
44405: PPUSH
44406: CALL_OW 1
44410: ST_TO_ADDR
// end ;
44411: LD_VAR 0 3
44415: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
44416: LD_INT 0
44418: PPUSH
// if not mc_bases or not base or not tech_list then
44419: LD_EXP 50
44423: NOT
44424: IFTRUE 44433
44426: PUSH
44427: LD_VAR 0 1
44431: NOT
44432: OR
44433: IFTRUE 44442
44435: PUSH
44436: LD_VAR 0 2
44440: NOT
44441: OR
44442: IFFALSE 44446
// exit ;
44444: GO 44471
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
44446: LD_ADDR_EXP 77
44450: PUSH
44451: LD_EXP 77
44455: PPUSH
44456: LD_VAR 0 1
44460: PPUSH
44461: LD_VAR 0 2
44465: PPUSH
44466: CALL_OW 1
44470: ST_TO_ADDR
// end ;
44471: LD_VAR 0 3
44475: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
44476: LD_INT 0
44478: PPUSH
// if not mc_bases or not parking_area or not base then
44479: LD_EXP 50
44483: NOT
44484: IFTRUE 44493
44486: PUSH
44487: LD_VAR 0 2
44491: NOT
44492: OR
44493: IFTRUE 44502
44495: PUSH
44496: LD_VAR 0 1
44500: NOT
44501: OR
44502: IFFALSE 44506
// exit ;
44504: GO 44531
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44506: LD_ADDR_EXP 74
44510: PUSH
44511: LD_EXP 74
44515: PPUSH
44516: LD_VAR 0 1
44520: PPUSH
44521: LD_VAR 0 2
44525: PPUSH
44526: CALL_OW 1
44530: ST_TO_ADDR
// end ;
44531: LD_VAR 0 3
44535: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44536: LD_INT 0
44538: PPUSH
// if not mc_bases or not base or not scan_area then
44539: LD_EXP 50
44543: NOT
44544: IFTRUE 44553
44546: PUSH
44547: LD_VAR 0 1
44551: NOT
44552: OR
44553: IFTRUE 44562
44555: PUSH
44556: LD_VAR 0 2
44560: NOT
44561: OR
44562: IFFALSE 44566
// exit ;
44564: GO 44591
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44566: LD_ADDR_EXP 75
44570: PUSH
44571: LD_EXP 75
44575: PPUSH
44576: LD_VAR 0 1
44580: PPUSH
44581: LD_VAR 0 2
44585: PPUSH
44586: CALL_OW 1
44590: ST_TO_ADDR
// end ;
44591: LD_VAR 0 3
44595: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44596: LD_INT 0
44598: PPUSH
44599: PPUSH
// if not mc_bases or not base then
44600: LD_EXP 50
44604: NOT
44605: IFTRUE 44614
44607: PUSH
44608: LD_VAR 0 1
44612: NOT
44613: OR
44614: IFFALSE 44618
// exit ;
44616: GO 44682
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44618: LD_ADDR_VAR 0 3
44622: PUSH
44623: LD_INT 1
44625: PUSH
44626: LD_INT 2
44628: PUSH
44629: LD_INT 3
44631: PUSH
44632: LD_INT 4
44634: PUSH
44635: LD_INT 11
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: LIST
44642: LIST
44643: LIST
44644: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44645: LD_ADDR_EXP 77
44649: PUSH
44650: LD_EXP 77
44654: PPUSH
44655: LD_VAR 0 1
44659: PPUSH
44660: LD_EXP 77
44664: PUSH
44665: LD_VAR 0 1
44669: ARRAY
44670: PUSH
44671: LD_VAR 0 3
44675: DIFF
44676: PPUSH
44677: CALL_OW 1
44681: ST_TO_ADDR
// end ;
44682: LD_VAR 0 2
44686: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44687: LD_INT 0
44689: PPUSH
// result := mc_vehicles [ base ] ;
44690: LD_ADDR_VAR 0 3
44694: PUSH
44695: LD_EXP 69
44699: PUSH
44700: LD_VAR 0 1
44704: ARRAY
44705: ST_TO_ADDR
// if onlyCombat then
44706: LD_VAR 0 2
44710: IFFALSE 44882
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44712: LD_ADDR_VAR 0 3
44716: PUSH
44717: LD_VAR 0 3
44721: PUSH
44722: LD_VAR 0 3
44726: PPUSH
44727: LD_INT 2
44729: PUSH
44730: LD_INT 34
44732: PUSH
44733: LD_INT 12
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 34
44742: PUSH
44743: LD_INT 51
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 34
44752: PUSH
44753: LD_INT 89
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 34
44762: PUSH
44763: LD_INT 32
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 34
44772: PUSH
44773: LD_INT 13
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 34
44782: PUSH
44783: LD_INT 52
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 34
44792: PUSH
44793: LD_INT 88
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 34
44802: PUSH
44803: LD_INT 14
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 34
44812: PUSH
44813: LD_INT 53
44815: PUSH
44816: EMPTY
44817: LIST
44818: LIST
44819: PUSH
44820: LD_INT 34
44822: PUSH
44823: LD_INT 98
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 34
44832: PUSH
44833: LD_INT 31
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 34
44842: PUSH
44843: LD_INT 48
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 34
44852: PUSH
44853: LD_INT 8
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: LIST
44864: LIST
44865: LIST
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: LIST
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: PPUSH
44876: CALL_OW 72
44880: DIFF
44881: ST_TO_ADDR
// end ; end_of_file
44882: LD_VAR 0 3
44886: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44887: LD_INT 0
44889: PPUSH
44890: PPUSH
44891: PPUSH
// if not mc_bases or not skirmish then
44892: LD_EXP 50
44896: NOT
44897: IFTRUE 44906
44899: PUSH
44900: LD_EXP 48
44904: NOT
44905: OR
44906: IFFALSE 44910
// exit ;
44908: GO 45075
// for i = 1 to mc_bases do
44910: LD_ADDR_VAR 0 4
44914: PUSH
44915: DOUBLE
44916: LD_INT 1
44918: DEC
44919: ST_TO_ADDR
44920: LD_EXP 50
44924: PUSH
44925: FOR_TO
44926: IFFALSE 45073
// begin if sci in mc_bases [ i ] then
44928: LD_VAR 0 2
44932: PUSH
44933: LD_EXP 50
44937: PUSH
44938: LD_VAR 0 4
44942: ARRAY
44943: IN
44944: IFFALSE 45071
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44946: LD_ADDR_EXP 79
44950: PUSH
44951: LD_EXP 79
44955: PPUSH
44956: LD_VAR 0 4
44960: PUSH
44961: LD_EXP 79
44965: PUSH
44966: LD_VAR 0 4
44970: ARRAY
44971: PUSH
44972: LD_INT 1
44974: PLUS
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PPUSH
44980: LD_VAR 0 1
44984: PPUSH
44985: CALL 54897 0 3
44989: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44990: LD_ADDR_VAR 0 5
44994: PUSH
44995: LD_EXP 50
44999: PUSH
45000: LD_VAR 0 4
45004: ARRAY
45005: PPUSH
45006: LD_INT 2
45008: PUSH
45009: LD_INT 30
45011: PUSH
45012: LD_INT 0
45014: PUSH
45015: EMPTY
45016: LIST
45017: LIST
45018: PUSH
45019: LD_INT 30
45021: PUSH
45022: LD_INT 1
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: LIST
45033: PPUSH
45034: CALL_OW 72
45038: PPUSH
45039: LD_VAR 0 1
45043: PPUSH
45044: CALL_OW 74
45048: ST_TO_ADDR
// if tmp then
45049: LD_VAR 0 5
45053: IFFALSE 45069
// ComStandNearbyBuilding ( ape , tmp ) ;
45055: LD_VAR 0 1
45059: PPUSH
45060: LD_VAR 0 5
45064: PPUSH
45065: CALL 51439 0 2
// break ;
45069: GO 45073
// end ; end ;
45071: GO 44925
45073: POP
45074: POP
// end ;
45075: LD_VAR 0 3
45079: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45080: LD_INT 0
45082: PPUSH
45083: PPUSH
45084: PPUSH
// if not mc_bases or not skirmish then
45085: LD_EXP 50
45089: NOT
45090: IFTRUE 45099
45092: PUSH
45093: LD_EXP 48
45097: NOT
45098: OR
45099: IFFALSE 45103
// exit ;
45101: GO 45192
// for i = 1 to mc_bases do
45103: LD_ADDR_VAR 0 4
45107: PUSH
45108: DOUBLE
45109: LD_INT 1
45111: DEC
45112: ST_TO_ADDR
45113: LD_EXP 50
45117: PUSH
45118: FOR_TO
45119: IFFALSE 45190
// begin if building in mc_busy_turret_list [ i ] then
45121: LD_VAR 0 1
45125: PUSH
45126: LD_EXP 60
45130: PUSH
45131: LD_VAR 0 4
45135: ARRAY
45136: IN
45137: IFFALSE 45188
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45139: LD_ADDR_VAR 0 5
45143: PUSH
45144: LD_EXP 60
45148: PUSH
45149: LD_VAR 0 4
45153: ARRAY
45154: PUSH
45155: LD_VAR 0 1
45159: DIFF
45160: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45161: LD_ADDR_EXP 60
45165: PUSH
45166: LD_EXP 60
45170: PPUSH
45171: LD_VAR 0 4
45175: PPUSH
45176: LD_VAR 0 5
45180: PPUSH
45181: CALL_OW 1
45185: ST_TO_ADDR
// break ;
45186: GO 45190
// end ; end ;
45188: GO 45118
45190: POP
45191: POP
// end ;
45192: LD_VAR 0 3
45196: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45197: LD_INT 0
45199: PPUSH
45200: PPUSH
45201: PPUSH
// if not mc_bases or not skirmish then
45202: LD_EXP 50
45206: NOT
45207: IFTRUE 45216
45209: PUSH
45210: LD_EXP 48
45214: NOT
45215: OR
45216: IFFALSE 45220
// exit ;
45218: GO 45419
// for i = 1 to mc_bases do
45220: LD_ADDR_VAR 0 5
45224: PUSH
45225: DOUBLE
45226: LD_INT 1
45228: DEC
45229: ST_TO_ADDR
45230: LD_EXP 50
45234: PUSH
45235: FOR_TO
45236: IFFALSE 45417
// if building in mc_bases [ i ] then
45238: LD_VAR 0 1
45242: PUSH
45243: LD_EXP 50
45247: PUSH
45248: LD_VAR 0 5
45252: ARRAY
45253: IN
45254: IFFALSE 45415
// begin tmp := mc_bases [ i ] diff building ;
45256: LD_ADDR_VAR 0 6
45260: PUSH
45261: LD_EXP 50
45265: PUSH
45266: LD_VAR 0 5
45270: ARRAY
45271: PUSH
45272: LD_VAR 0 1
45276: DIFF
45277: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45278: LD_ADDR_EXP 50
45282: PUSH
45283: LD_EXP 50
45287: PPUSH
45288: LD_VAR 0 5
45292: PPUSH
45293: LD_VAR 0 6
45297: PPUSH
45298: CALL_OW 1
45302: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45303: LD_VAR 0 1
45307: PUSH
45308: LD_EXP 58
45312: PUSH
45313: LD_VAR 0 5
45317: ARRAY
45318: IN
45319: IFFALSE 45358
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45321: LD_ADDR_EXP 58
45325: PUSH
45326: LD_EXP 58
45330: PPUSH
45331: LD_VAR 0 5
45335: PPUSH
45336: LD_EXP 58
45340: PUSH
45341: LD_VAR 0 5
45345: ARRAY
45346: PUSH
45347: LD_VAR 0 1
45351: DIFF
45352: PPUSH
45353: CALL_OW 1
45357: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45358: LD_VAR 0 1
45362: PUSH
45363: LD_EXP 59
45367: PUSH
45368: LD_VAR 0 5
45372: ARRAY
45373: IN
45374: IFFALSE 45413
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
45376: LD_ADDR_EXP 59
45380: PUSH
45381: LD_EXP 59
45385: PPUSH
45386: LD_VAR 0 5
45390: PPUSH
45391: LD_EXP 59
45395: PUSH
45396: LD_VAR 0 5
45400: ARRAY
45401: PUSH
45402: LD_VAR 0 1
45406: DIFF
45407: PPUSH
45408: CALL_OW 1
45412: ST_TO_ADDR
// break ;
45413: GO 45417
// end ;
45415: GO 45235
45417: POP
45418: POP
// end ;
45419: LD_VAR 0 4
45423: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
45424: LD_INT 0
45426: PPUSH
45427: PPUSH
45428: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
45429: LD_EXP 50
45433: NOT
45434: IFTRUE 45443
45436: PUSH
45437: LD_EXP 48
45441: NOT
45442: OR
45443: IFTRUE 45458
45445: PUSH
45446: LD_VAR 0 3
45450: PUSH
45451: LD_EXP 76
45455: IN
45456: NOT
45457: OR
45458: IFFALSE 45462
// exit ;
45460: GO 45587
// for i = 1 to mc_vehicles do
45462: LD_ADDR_VAR 0 6
45466: PUSH
45467: DOUBLE
45468: LD_INT 1
45470: DEC
45471: ST_TO_ADDR
45472: LD_EXP 69
45476: PUSH
45477: FOR_TO
45478: IFFALSE 45585
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
45480: LD_VAR 0 2
45484: PUSH
45485: LD_EXP 69
45489: PUSH
45490: LD_VAR 0 6
45494: ARRAY
45495: IN
45496: IFTRUE 45516
45498: PUSH
45499: LD_VAR 0 1
45503: PUSH
45504: LD_EXP 69
45508: PUSH
45509: LD_VAR 0 6
45513: ARRAY
45514: IN
45515: OR
45516: IFFALSE 45583
// begin tmp := mc_vehicles [ i ] diff old ;
45518: LD_ADDR_VAR 0 7
45522: PUSH
45523: LD_EXP 69
45527: PUSH
45528: LD_VAR 0 6
45532: ARRAY
45533: PUSH
45534: LD_VAR 0 2
45538: DIFF
45539: ST_TO_ADDR
// tmp := tmp diff new ;
45540: LD_ADDR_VAR 0 7
45544: PUSH
45545: LD_VAR 0 7
45549: PUSH
45550: LD_VAR 0 1
45554: DIFF
45555: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45556: LD_ADDR_EXP 69
45560: PUSH
45561: LD_EXP 69
45565: PPUSH
45566: LD_VAR 0 6
45570: PPUSH
45571: LD_VAR 0 7
45575: PPUSH
45576: CALL_OW 1
45580: ST_TO_ADDR
// break ;
45581: GO 45585
// end ;
45583: GO 45477
45585: POP
45586: POP
// end ;
45587: LD_VAR 0 5
45591: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45592: LD_INT 0
45594: PPUSH
45595: PPUSH
45596: PPUSH
45597: PPUSH
// if not mc_bases or not skirmish then
45598: LD_EXP 50
45602: NOT
45603: IFTRUE 45612
45605: PUSH
45606: LD_EXP 48
45610: NOT
45611: OR
45612: IFFALSE 45616
// exit ;
45614: GO 46038
// repeat wait ( 0 0$1 ) ;
45616: LD_INT 35
45618: PPUSH
45619: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45623: LD_EXP 94
45627: NOT
45628: IFFALSE 45616
// mc_block_vehicle_constructed_thread := true ;
45630: LD_ADDR_EXP 94
45634: PUSH
45635: LD_INT 1
45637: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45638: LD_ADDR_VAR 0 5
45642: PUSH
45643: LD_VAR 0 1
45647: PPUSH
45648: CALL_OW 255
45652: ST_TO_ADDR
// for i = 1 to mc_bases do
45653: LD_ADDR_VAR 0 4
45657: PUSH
45658: DOUBLE
45659: LD_INT 1
45661: DEC
45662: ST_TO_ADDR
45663: LD_EXP 50
45667: PUSH
45668: FOR_TO
45669: IFFALSE 46028
// begin if factory in mc_bases [ i ] then
45671: LD_VAR 0 2
45675: PUSH
45676: LD_EXP 50
45680: PUSH
45681: LD_VAR 0 4
45685: ARRAY
45686: IN
45687: IFFALSE 46026
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45689: LD_EXP 72
45693: PUSH
45694: LD_VAR 0 4
45698: ARRAY
45699: PUSH
45700: LD_EXP 61
45704: PUSH
45705: LD_VAR 0 4
45709: ARRAY
45710: LESS
45711: IFFALSE 45800
45713: PUSH
45714: LD_VAR 0 1
45718: PPUSH
45719: CALL_OW 264
45723: PUSH
45724: LD_INT 31
45726: PUSH
45727: LD_INT 32
45729: PUSH
45730: LD_INT 51
45732: PUSH
45733: LD_INT 89
45735: PUSH
45736: LD_INT 12
45738: PUSH
45739: LD_INT 30
45741: PUSH
45742: LD_INT 98
45744: PUSH
45745: LD_INT 11
45747: PUSH
45748: LD_INT 53
45750: PUSH
45751: LD_INT 14
45753: PUSH
45754: LD_INT 91
45756: PUSH
45757: LD_INT 29
45759: PUSH
45760: LD_INT 99
45762: PUSH
45763: LD_INT 13
45765: PUSH
45766: LD_INT 52
45768: PUSH
45769: LD_INT 88
45771: PUSH
45772: LD_INT 48
45774: PUSH
45775: LD_INT 8
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: LIST
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: IN
45798: NOT
45799: AND
45800: IFFALSE 45848
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45802: LD_ADDR_EXP 72
45806: PUSH
45807: LD_EXP 72
45811: PPUSH
45812: LD_VAR 0 4
45816: PUSH
45817: LD_EXP 72
45821: PUSH
45822: LD_VAR 0 4
45826: ARRAY
45827: PUSH
45828: LD_INT 1
45830: PLUS
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PPUSH
45836: LD_VAR 0 1
45840: PPUSH
45841: CALL 54897 0 3
45845: ST_TO_ADDR
45846: GO 45892
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45848: LD_ADDR_EXP 69
45852: PUSH
45853: LD_EXP 69
45857: PPUSH
45858: LD_VAR 0 4
45862: PUSH
45863: LD_EXP 69
45867: PUSH
45868: LD_VAR 0 4
45872: ARRAY
45873: PUSH
45874: LD_INT 1
45876: PLUS
45877: PUSH
45878: EMPTY
45879: LIST
45880: LIST
45881: PPUSH
45882: LD_VAR 0 1
45886: PPUSH
45887: CALL 54897 0 3
45891: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45892: LD_ADDR_EXP 94
45896: PUSH
45897: LD_INT 0
45899: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45900: LD_VAR 0 1
45904: PPUSH
45905: CALL_OW 263
45909: PUSH
45910: LD_INT 2
45912: EQUAL
45913: IFFALSE 45942
// begin repeat wait ( 0 0$3 ) ;
45915: LD_INT 105
45917: PPUSH
45918: CALL_OW 67
// Connect ( vehicle ) ;
45922: LD_VAR 0 1
45926: PPUSH
45927: CALL 58257 0 1
// until IsControledBy ( vehicle ) ;
45931: LD_VAR 0 1
45935: PPUSH
45936: CALL_OW 312
45940: IFFALSE 45915
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45942: LD_VAR 0 1
45946: PPUSH
45947: LD_EXP 74
45951: PUSH
45952: LD_VAR 0 4
45956: ARRAY
45957: PPUSH
45958: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45962: LD_VAR 0 1
45966: PPUSH
45967: CALL_OW 263
45971: PUSH
45972: LD_INT 1
45974: NONEQUAL
45975: IFFALSE 45979
// break ;
45977: GO 46028
// repeat wait ( 0 0$1 ) ;
45979: LD_INT 35
45981: PPUSH
45982: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45986: LD_VAR 0 1
45990: PPUSH
45991: LD_EXP 74
45995: PUSH
45996: LD_VAR 0 4
46000: ARRAY
46001: PPUSH
46002: CALL_OW 308
46006: IFFALSE 45979
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46008: LD_VAR 0 1
46012: PPUSH
46013: CALL_OW 311
46017: PPUSH
46018: CALL_OW 121
// exit ;
46022: POP
46023: POP
46024: GO 46038
// end ; end ;
46026: GO 45668
46028: POP
46029: POP
// mc_block_vehicle_constructed_thread := false ;
46030: LD_ADDR_EXP 94
46034: PUSH
46035: LD_INT 0
46037: ST_TO_ADDR
// end ;
46038: LD_VAR 0 3
46042: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46043: LD_INT 0
46045: PPUSH
46046: PPUSH
46047: PPUSH
46048: PPUSH
// if not mc_bases or not skirmish then
46049: LD_EXP 50
46053: NOT
46054: IFTRUE 46063
46056: PUSH
46057: LD_EXP 48
46061: NOT
46062: OR
46063: IFFALSE 46067
// exit ;
46065: GO 46420
// repeat wait ( 0 0$1 ) ;
46067: LD_INT 35
46069: PPUSH
46070: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46074: LD_VAR 0 2
46078: PPUSH
46079: LD_VAR 0 3
46083: PPUSH
46084: CALL_OW 284
46088: IFFALSE 46067
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46090: LD_VAR 0 2
46094: PPUSH
46095: LD_VAR 0 3
46099: PPUSH
46100: CALL_OW 283
46104: PUSH
46105: LD_INT 4
46107: EQUAL
46108: IFFALSE 46112
// exit ;
46110: GO 46420
// for i = 1 to mc_bases do
46112: LD_ADDR_VAR 0 7
46116: PUSH
46117: DOUBLE
46118: LD_INT 1
46120: DEC
46121: ST_TO_ADDR
46122: LD_EXP 50
46126: PUSH
46127: FOR_TO
46128: IFFALSE 46418
// begin if mc_crates_area [ i ] then
46130: LD_EXP 68
46134: PUSH
46135: LD_VAR 0 7
46139: ARRAY
46140: IFFALSE 46251
// for j in mc_crates_area [ i ] do
46142: LD_ADDR_VAR 0 8
46146: PUSH
46147: LD_EXP 68
46151: PUSH
46152: LD_VAR 0 7
46156: ARRAY
46157: PUSH
46158: FOR_IN
46159: IFFALSE 46249
// if InArea ( x , y , j ) then
46161: LD_VAR 0 2
46165: PPUSH
46166: LD_VAR 0 3
46170: PPUSH
46171: LD_VAR 0 8
46175: PPUSH
46176: CALL_OW 309
46180: IFFALSE 46247
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46182: LD_ADDR_EXP 66
46186: PUSH
46187: LD_EXP 66
46191: PPUSH
46192: LD_VAR 0 7
46196: PUSH
46197: LD_EXP 66
46201: PUSH
46202: LD_VAR 0 7
46206: ARRAY
46207: PUSH
46208: LD_INT 1
46210: PLUS
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PPUSH
46216: LD_VAR 0 4
46220: PUSH
46221: LD_VAR 0 2
46225: PUSH
46226: LD_VAR 0 3
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: LIST
46235: PPUSH
46236: CALL 54897 0 3
46240: ST_TO_ADDR
// exit ;
46241: POP
46242: POP
46243: POP
46244: POP
46245: GO 46420
// end ;
46247: GO 46158
46249: POP
46250: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46251: LD_ADDR_VAR 0 9
46255: PUSH
46256: LD_EXP 50
46260: PUSH
46261: LD_VAR 0 7
46265: ARRAY
46266: PPUSH
46267: LD_INT 2
46269: PUSH
46270: LD_INT 30
46272: PUSH
46273: LD_INT 0
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: LD_INT 30
46282: PUSH
46283: LD_INT 1
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: LIST
46294: PPUSH
46295: CALL_OW 72
46299: ST_TO_ADDR
// if not depot then
46300: LD_VAR 0 9
46304: NOT
46305: IFFALSE 46309
// continue ;
46307: GO 46127
// for j in depot do
46309: LD_ADDR_VAR 0 8
46313: PUSH
46314: LD_VAR 0 9
46318: PUSH
46319: FOR_IN
46320: IFFALSE 46414
// if GetDistUnitXY ( j , x , y ) < 30 then
46322: LD_VAR 0 8
46326: PPUSH
46327: LD_VAR 0 2
46331: PPUSH
46332: LD_VAR 0 3
46336: PPUSH
46337: CALL_OW 297
46341: PUSH
46342: LD_INT 30
46344: LESS
46345: IFFALSE 46412
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46347: LD_ADDR_EXP 66
46351: PUSH
46352: LD_EXP 66
46356: PPUSH
46357: LD_VAR 0 7
46361: PUSH
46362: LD_EXP 66
46366: PUSH
46367: LD_VAR 0 7
46371: ARRAY
46372: PUSH
46373: LD_INT 1
46375: PLUS
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PPUSH
46381: LD_VAR 0 4
46385: PUSH
46386: LD_VAR 0 2
46390: PUSH
46391: LD_VAR 0 3
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: LIST
46400: PPUSH
46401: CALL 54897 0 3
46405: ST_TO_ADDR
// exit ;
46406: POP
46407: POP
46408: POP
46409: POP
46410: GO 46420
// end ;
46412: GO 46319
46414: POP
46415: POP
// end ;
46416: GO 46127
46418: POP
46419: POP
// end ;
46420: LD_VAR 0 6
46424: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46425: LD_INT 0
46427: PPUSH
46428: PPUSH
46429: PPUSH
46430: PPUSH
// if not mc_bases or not skirmish then
46431: LD_EXP 50
46435: NOT
46436: IFTRUE 46445
46438: PUSH
46439: LD_EXP 48
46443: NOT
46444: OR
46445: IFFALSE 46449
// exit ;
46447: GO 46732
// side := GetSide ( lab ) ;
46449: LD_ADDR_VAR 0 4
46453: PUSH
46454: LD_VAR 0 2
46458: PPUSH
46459: CALL_OW 255
46463: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
46464: LD_VAR 0 4
46468: PUSH
46469: LD_EXP 76
46473: IN
46474: NOT
46475: IFTRUE 46484
46477: PUSH
46478: LD_EXP 77
46482: NOT
46483: OR
46484: IFTRUE 46493
46486: PUSH
46487: LD_EXP 50
46491: NOT
46492: OR
46493: IFFALSE 46497
// exit ;
46495: GO 46732
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
46497: LD_ADDR_EXP 77
46501: PUSH
46502: LD_EXP 77
46506: PPUSH
46507: LD_VAR 0 4
46511: PPUSH
46512: LD_EXP 77
46516: PUSH
46517: LD_VAR 0 4
46521: ARRAY
46522: PUSH
46523: LD_VAR 0 1
46527: DIFF
46528: PPUSH
46529: CALL_OW 1
46533: ST_TO_ADDR
// for i = 1 to mc_bases do
46534: LD_ADDR_VAR 0 5
46538: PUSH
46539: DOUBLE
46540: LD_INT 1
46542: DEC
46543: ST_TO_ADDR
46544: LD_EXP 50
46548: PUSH
46549: FOR_TO
46550: IFFALSE 46730
// begin if lab in mc_bases [ i ] then
46552: LD_VAR 0 2
46556: PUSH
46557: LD_EXP 50
46561: PUSH
46562: LD_VAR 0 5
46566: ARRAY
46567: IN
46568: IFFALSE 46728
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46570: LD_VAR 0 1
46574: PUSH
46575: LD_INT 11
46577: PUSH
46578: LD_INT 4
46580: PUSH
46581: LD_INT 3
46583: PUSH
46584: LD_INT 2
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: IN
46593: IFFALSE 46607
46595: PUSH
46596: LD_EXP 80
46600: PUSH
46601: LD_VAR 0 5
46605: ARRAY
46606: AND
46607: IFFALSE 46728
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46609: LD_ADDR_VAR 0 6
46613: PUSH
46614: LD_EXP 80
46618: PUSH
46619: LD_VAR 0 5
46623: ARRAY
46624: PUSH
46625: LD_INT 1
46627: ARRAY
46628: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46629: LD_ADDR_EXP 80
46633: PUSH
46634: LD_EXP 80
46638: PPUSH
46639: LD_VAR 0 5
46643: PPUSH
46644: EMPTY
46645: PPUSH
46646: CALL_OW 1
46650: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46651: LD_VAR 0 6
46655: PPUSH
46656: LD_INT 0
46658: PPUSH
46659: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46663: LD_VAR 0 6
46667: PPUSH
46668: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46672: LD_ADDR_EXP 79
46676: PUSH
46677: LD_EXP 79
46681: PPUSH
46682: LD_VAR 0 5
46686: PPUSH
46687: LD_EXP 79
46691: PUSH
46692: LD_VAR 0 5
46696: ARRAY
46697: PPUSH
46698: LD_INT 1
46700: PPUSH
46701: LD_VAR 0 6
46705: PPUSH
46706: CALL_OW 2
46710: PPUSH
46711: CALL_OW 1
46715: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46716: LD_VAR 0 5
46720: PPUSH
46721: LD_INT 112
46723: PPUSH
46724: CALL 22862 0 2
// end ; end ; end ;
46728: GO 46549
46730: POP
46731: POP
// end ;
46732: LD_VAR 0 3
46736: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46737: LD_INT 0
46739: PPUSH
46740: PPUSH
46741: PPUSH
46742: PPUSH
46743: PPUSH
46744: PPUSH
46745: PPUSH
46746: PPUSH
// if not mc_bases or not skirmish then
46747: LD_EXP 50
46751: NOT
46752: IFTRUE 46761
46754: PUSH
46755: LD_EXP 48
46759: NOT
46760: OR
46761: IFFALSE 46765
// exit ;
46763: GO 48150
// for i = 1 to mc_bases do
46765: LD_ADDR_VAR 0 3
46769: PUSH
46770: DOUBLE
46771: LD_INT 1
46773: DEC
46774: ST_TO_ADDR
46775: LD_EXP 50
46779: PUSH
46780: FOR_TO
46781: IFFALSE 48148
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46783: LD_VAR 0 1
46787: PUSH
46788: LD_EXP 50
46792: PUSH
46793: LD_VAR 0 3
46797: ARRAY
46798: IN
46799: IFTRUE 46819
46801: PUSH
46802: LD_VAR 0 1
46806: PUSH
46807: LD_EXP 57
46811: PUSH
46812: LD_VAR 0 3
46816: ARRAY
46817: IN
46818: OR
46819: IFTRUE 46839
46821: PUSH
46822: LD_VAR 0 1
46826: PUSH
46827: LD_EXP 72
46831: PUSH
46832: LD_VAR 0 3
46836: ARRAY
46837: IN
46838: OR
46839: IFTRUE 46859
46841: PUSH
46842: LD_VAR 0 1
46846: PUSH
46847: LD_EXP 69
46851: PUSH
46852: LD_VAR 0 3
46856: ARRAY
46857: IN
46858: OR
46859: IFTRUE 46879
46861: PUSH
46862: LD_VAR 0 1
46866: PUSH
46867: LD_EXP 79
46871: PUSH
46872: LD_VAR 0 3
46876: ARRAY
46877: IN
46878: OR
46879: IFTRUE 46899
46881: PUSH
46882: LD_VAR 0 1
46886: PUSH
46887: LD_EXP 80
46891: PUSH
46892: LD_VAR 0 3
46896: ARRAY
46897: IN
46898: OR
46899: IFFALSE 48146
// begin if un in mc_ape [ i ] then
46901: LD_VAR 0 1
46905: PUSH
46906: LD_EXP 79
46910: PUSH
46911: LD_VAR 0 3
46915: ARRAY
46916: IN
46917: IFFALSE 46956
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46919: LD_ADDR_EXP 79
46923: PUSH
46924: LD_EXP 79
46928: PPUSH
46929: LD_VAR 0 3
46933: PPUSH
46934: LD_EXP 79
46938: PUSH
46939: LD_VAR 0 3
46943: ARRAY
46944: PUSH
46945: LD_VAR 0 1
46949: DIFF
46950: PPUSH
46951: CALL_OW 1
46955: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46956: LD_VAR 0 1
46960: PUSH
46961: LD_EXP 80
46965: PUSH
46966: LD_VAR 0 3
46970: ARRAY
46971: IN
46972: IFFALSE 46996
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46974: LD_ADDR_EXP 80
46978: PUSH
46979: LD_EXP 80
46983: PPUSH
46984: LD_VAR 0 3
46988: PPUSH
46989: EMPTY
46990: PPUSH
46991: CALL_OW 1
46995: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46996: LD_VAR 0 1
47000: PPUSH
47001: CALL_OW 247
47005: PUSH
47006: LD_INT 2
47008: EQUAL
47009: IFFALSE 47090
47011: PUSH
47012: LD_VAR 0 1
47016: PPUSH
47017: CALL_OW 110
47021: PUSH
47022: LD_INT 20
47024: EQUAL
47025: IFTRUE 47045
47027: PUSH
47028: LD_VAR 0 1
47032: PUSH
47033: LD_EXP 72
47037: PUSH
47038: LD_VAR 0 3
47042: ARRAY
47043: IN
47044: OR
47045: IFTRUE 47089
47047: PUSH
47048: LD_VAR 0 1
47052: PPUSH
47053: CALL_OW 264
47057: PUSH
47058: LD_INT 12
47060: PUSH
47061: LD_INT 51
47063: PUSH
47064: LD_INT 89
47066: PUSH
47067: LD_INT 32
47069: PUSH
47070: LD_INT 13
47072: PUSH
47073: LD_INT 52
47075: PUSH
47076: LD_INT 31
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: IN
47088: OR
47089: AND
47090: IFFALSE 47398
// begin if un in mc_defender [ i ] then
47092: LD_VAR 0 1
47096: PUSH
47097: LD_EXP 72
47101: PUSH
47102: LD_VAR 0 3
47106: ARRAY
47107: IN
47108: IFFALSE 47147
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47110: LD_ADDR_EXP 72
47114: PUSH
47115: LD_EXP 72
47119: PPUSH
47120: LD_VAR 0 3
47124: PPUSH
47125: LD_EXP 72
47129: PUSH
47130: LD_VAR 0 3
47134: ARRAY
47135: PUSH
47136: LD_VAR 0 1
47140: DIFF
47141: PPUSH
47142: CALL_OW 1
47146: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47147: LD_ADDR_VAR 0 8
47151: PUSH
47152: LD_VAR 0 3
47156: PPUSH
47157: LD_INT 3
47159: PPUSH
47160: CALL 43686 0 2
47164: ST_TO_ADDR
// if fac then
47165: LD_VAR 0 8
47169: IFFALSE 47398
// begin for j in fac do
47171: LD_ADDR_VAR 0 4
47175: PUSH
47176: LD_VAR 0 8
47180: PUSH
47181: FOR_IN
47182: IFFALSE 47396
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47184: LD_ADDR_VAR 0 9
47188: PUSH
47189: LD_VAR 0 8
47193: PPUSH
47194: LD_VAR 0 1
47198: PPUSH
47199: CALL_OW 265
47203: PPUSH
47204: LD_VAR 0 1
47208: PPUSH
47209: CALL_OW 262
47213: PPUSH
47214: LD_VAR 0 1
47218: PPUSH
47219: CALL_OW 263
47223: PPUSH
47224: LD_VAR 0 1
47228: PPUSH
47229: CALL_OW 264
47233: PPUSH
47234: CALL 52337 0 5
47238: ST_TO_ADDR
// if components then
47239: LD_VAR 0 9
47243: IFFALSE 47394
// begin if GetWeapon ( un ) = ar_control_tower then
47245: LD_VAR 0 1
47249: PPUSH
47250: CALL_OW 264
47254: PUSH
47255: LD_INT 31
47257: EQUAL
47258: IFFALSE 47375
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
47260: LD_VAR 0 1
47264: PPUSH
47265: CALL_OW 311
47269: PPUSH
47270: LD_INT 0
47272: PPUSH
47273: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
47277: LD_ADDR_EXP 90
47281: PUSH
47282: LD_EXP 90
47286: PPUSH
47287: LD_VAR 0 3
47291: PPUSH
47292: LD_EXP 90
47296: PUSH
47297: LD_VAR 0 3
47301: ARRAY
47302: PUSH
47303: LD_VAR 0 1
47307: PPUSH
47308: CALL_OW 311
47312: DIFF
47313: PPUSH
47314: CALL_OW 1
47318: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
47319: LD_ADDR_VAR 0 7
47323: PUSH
47324: LD_EXP 71
47328: PUSH
47329: LD_VAR 0 3
47333: ARRAY
47334: PPUSH
47335: LD_INT 1
47337: PPUSH
47338: LD_VAR 0 9
47342: PPUSH
47343: CALL_OW 2
47347: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47348: LD_ADDR_EXP 71
47352: PUSH
47353: LD_EXP 71
47357: PPUSH
47358: LD_VAR 0 3
47362: PPUSH
47363: LD_VAR 0 7
47367: PPUSH
47368: CALL_OW 1
47372: ST_TO_ADDR
// end else
47373: GO 47392
// MC_InsertProduceList ( i , [ components ] ) ;
47375: LD_VAR 0 3
47379: PPUSH
47380: LD_VAR 0 9
47384: PUSH
47385: EMPTY
47386: LIST
47387: PPUSH
47388: CALL 43231 0 2
// break ;
47392: GO 47396
// end ; end ;
47394: GO 47181
47396: POP
47397: POP
// end ; end ; if GetType ( un ) = unit_building then
47398: LD_VAR 0 1
47402: PPUSH
47403: CALL_OW 247
47407: PUSH
47408: LD_INT 3
47410: EQUAL
47411: IFFALSE 47814
// begin btype := GetBType ( un ) ;
47413: LD_ADDR_VAR 0 5
47417: PUSH
47418: LD_VAR 0 1
47422: PPUSH
47423: CALL_OW 266
47427: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47428: LD_VAR 0 5
47432: PUSH
47433: LD_INT 29
47435: PUSH
47436: LD_INT 30
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: IN
47443: IFFALSE 47516
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47445: LD_VAR 0 1
47449: PPUSH
47450: CALL_OW 250
47454: PPUSH
47455: LD_VAR 0 1
47459: PPUSH
47460: CALL_OW 251
47464: PPUSH
47465: LD_VAR 0 1
47469: PPUSH
47470: CALL_OW 255
47474: PPUSH
47475: CALL_OW 440
47479: NOT
47480: IFFALSE 47516
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
47482: LD_VAR 0 1
47486: PPUSH
47487: CALL_OW 250
47491: PPUSH
47492: LD_VAR 0 1
47496: PPUSH
47497: CALL_OW 251
47501: PPUSH
47502: LD_VAR 0 1
47506: PPUSH
47507: CALL_OW 255
47511: PPUSH
47512: CALL_OW 441
// end ; if btype = b_warehouse then
47516: LD_VAR 0 5
47520: PUSH
47521: LD_INT 1
47523: EQUAL
47524: IFFALSE 47542
// begin btype := b_depot ;
47526: LD_ADDR_VAR 0 5
47530: PUSH
47531: LD_INT 0
47533: ST_TO_ADDR
// pos := 1 ;
47534: LD_ADDR_VAR 0 6
47538: PUSH
47539: LD_INT 1
47541: ST_TO_ADDR
// end ; if btype = b_factory then
47542: LD_VAR 0 5
47546: PUSH
47547: LD_INT 3
47549: EQUAL
47550: IFFALSE 47568
// begin btype := b_workshop ;
47552: LD_ADDR_VAR 0 5
47556: PUSH
47557: LD_INT 2
47559: ST_TO_ADDR
// pos := 1 ;
47560: LD_ADDR_VAR 0 6
47564: PUSH
47565: LD_INT 1
47567: ST_TO_ADDR
// end ; if btype = b_barracks then
47568: LD_VAR 0 5
47572: PUSH
47573: LD_INT 5
47575: EQUAL
47576: IFFALSE 47586
// btype := b_armoury ;
47578: LD_ADDR_VAR 0 5
47582: PUSH
47583: LD_INT 4
47585: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47586: LD_VAR 0 5
47590: PUSH
47591: LD_INT 7
47593: PUSH
47594: LD_INT 8
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: IN
47601: IFFALSE 47611
// btype := b_lab ;
47603: LD_ADDR_VAR 0 5
47607: PUSH
47608: LD_INT 6
47610: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47611: LD_ADDR_EXP 55
47615: PUSH
47616: LD_EXP 55
47620: PPUSH
47621: LD_VAR 0 3
47625: PUSH
47626: LD_EXP 55
47630: PUSH
47631: LD_VAR 0 3
47635: ARRAY
47636: PUSH
47637: LD_INT 1
47639: PLUS
47640: PUSH
47641: EMPTY
47642: LIST
47643: LIST
47644: PPUSH
47645: LD_VAR 0 5
47649: PUSH
47650: LD_VAR 0 1
47654: PPUSH
47655: CALL_OW 250
47659: PUSH
47660: LD_VAR 0 1
47664: PPUSH
47665: CALL_OW 251
47669: PUSH
47670: LD_VAR 0 1
47674: PPUSH
47675: CALL_OW 254
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: PPUSH
47686: CALL 54897 0 3
47690: ST_TO_ADDR
// if pos = 1 then
47691: LD_VAR 0 6
47695: PUSH
47696: LD_INT 1
47698: EQUAL
47699: IFFALSE 47814
// begin tmp := mc_build_list [ i ] ;
47701: LD_ADDR_VAR 0 7
47705: PUSH
47706: LD_EXP 55
47710: PUSH
47711: LD_VAR 0 3
47715: ARRAY
47716: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47717: LD_VAR 0 7
47721: PPUSH
47722: LD_INT 2
47724: PUSH
47725: LD_INT 30
47727: PUSH
47728: LD_INT 0
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: PUSH
47735: LD_INT 30
47737: PUSH
47738: LD_INT 1
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: LIST
47749: PPUSH
47750: CALL_OW 72
47754: IFFALSE 47764
// pos := 2 ;
47756: LD_ADDR_VAR 0 6
47760: PUSH
47761: LD_INT 2
47763: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47764: LD_ADDR_VAR 0 7
47768: PUSH
47769: LD_VAR 0 7
47773: PPUSH
47774: LD_VAR 0 6
47778: PPUSH
47779: LD_VAR 0 7
47783: PPUSH
47784: CALL 55223 0 3
47788: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47789: LD_ADDR_EXP 55
47793: PUSH
47794: LD_EXP 55
47798: PPUSH
47799: LD_VAR 0 3
47803: PPUSH
47804: LD_VAR 0 7
47808: PPUSH
47809: CALL_OW 1
47813: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47814: LD_VAR 0 1
47818: PUSH
47819: LD_EXP 50
47823: PUSH
47824: LD_VAR 0 3
47828: ARRAY
47829: IN
47830: IFFALSE 47869
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47832: LD_ADDR_EXP 50
47836: PUSH
47837: LD_EXP 50
47841: PPUSH
47842: LD_VAR 0 3
47846: PPUSH
47847: LD_EXP 50
47851: PUSH
47852: LD_VAR 0 3
47856: ARRAY
47857: PUSH
47858: LD_VAR 0 1
47862: DIFF
47863: PPUSH
47864: CALL_OW 1
47868: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47869: LD_VAR 0 1
47873: PUSH
47874: LD_EXP 57
47878: PUSH
47879: LD_VAR 0 3
47883: ARRAY
47884: IN
47885: IFFALSE 47924
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47887: LD_ADDR_EXP 57
47891: PUSH
47892: LD_EXP 57
47896: PPUSH
47897: LD_VAR 0 3
47901: PPUSH
47902: LD_EXP 57
47906: PUSH
47907: LD_VAR 0 3
47911: ARRAY
47912: PUSH
47913: LD_VAR 0 1
47917: DIFF
47918: PPUSH
47919: CALL_OW 1
47923: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47924: LD_VAR 0 1
47928: PUSH
47929: LD_EXP 69
47933: PUSH
47934: LD_VAR 0 3
47938: ARRAY
47939: IN
47940: IFFALSE 47979
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47942: LD_ADDR_EXP 69
47946: PUSH
47947: LD_EXP 69
47951: PPUSH
47952: LD_VAR 0 3
47956: PPUSH
47957: LD_EXP 69
47961: PUSH
47962: LD_VAR 0 3
47966: ARRAY
47967: PUSH
47968: LD_VAR 0 1
47972: DIFF
47973: PPUSH
47974: CALL_OW 1
47978: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47979: LD_VAR 0 1
47983: PUSH
47984: LD_EXP 72
47988: PUSH
47989: LD_VAR 0 3
47993: ARRAY
47994: IN
47995: IFFALSE 48034
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47997: LD_ADDR_EXP 72
48001: PUSH
48002: LD_EXP 72
48006: PPUSH
48007: LD_VAR 0 3
48011: PPUSH
48012: LD_EXP 72
48016: PUSH
48017: LD_VAR 0 3
48021: ARRAY
48022: PUSH
48023: LD_VAR 0 1
48027: DIFF
48028: PPUSH
48029: CALL_OW 1
48033: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48034: LD_VAR 0 1
48038: PUSH
48039: LD_EXP 59
48043: PUSH
48044: LD_VAR 0 3
48048: ARRAY
48049: IN
48050: IFFALSE 48089
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48052: LD_ADDR_EXP 59
48056: PUSH
48057: LD_EXP 59
48061: PPUSH
48062: LD_VAR 0 3
48066: PPUSH
48067: LD_EXP 59
48071: PUSH
48072: LD_VAR 0 3
48076: ARRAY
48077: PUSH
48078: LD_VAR 0 1
48082: DIFF
48083: PPUSH
48084: CALL_OW 1
48088: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48089: LD_VAR 0 1
48093: PUSH
48094: LD_EXP 58
48098: PUSH
48099: LD_VAR 0 3
48103: ARRAY
48104: IN
48105: IFFALSE 48144
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48107: LD_ADDR_EXP 58
48111: PUSH
48112: LD_EXP 58
48116: PPUSH
48117: LD_VAR 0 3
48121: PPUSH
48122: LD_EXP 58
48126: PUSH
48127: LD_VAR 0 3
48131: ARRAY
48132: PUSH
48133: LD_VAR 0 1
48137: DIFF
48138: PPUSH
48139: CALL_OW 1
48143: ST_TO_ADDR
// end ; break ;
48144: GO 48148
// end ;
48146: GO 46780
48148: POP
48149: POP
// end ;
48150: LD_VAR 0 2
48154: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48155: LD_INT 0
48157: PPUSH
48158: PPUSH
48159: PPUSH
// if not mc_bases or not skirmish then
48160: LD_EXP 50
48164: NOT
48165: IFTRUE 48174
48167: PUSH
48168: LD_EXP 48
48172: NOT
48173: OR
48174: IFFALSE 48178
// exit ;
48176: GO 48393
// for i = 1 to mc_bases do
48178: LD_ADDR_VAR 0 3
48182: PUSH
48183: DOUBLE
48184: LD_INT 1
48186: DEC
48187: ST_TO_ADDR
48188: LD_EXP 50
48192: PUSH
48193: FOR_TO
48194: IFFALSE 48391
// begin if building in mc_construct_list [ i ] then
48196: LD_VAR 0 1
48200: PUSH
48201: LD_EXP 57
48205: PUSH
48206: LD_VAR 0 3
48210: ARRAY
48211: IN
48212: IFFALSE 48389
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48214: LD_ADDR_EXP 57
48218: PUSH
48219: LD_EXP 57
48223: PPUSH
48224: LD_VAR 0 3
48228: PPUSH
48229: LD_EXP 57
48233: PUSH
48234: LD_VAR 0 3
48238: ARRAY
48239: PUSH
48240: LD_VAR 0 1
48244: DIFF
48245: PPUSH
48246: CALL_OW 1
48250: ST_TO_ADDR
// if building in mc_lab [ i ] then
48251: LD_VAR 0 1
48255: PUSH
48256: LD_EXP 83
48260: PUSH
48261: LD_VAR 0 3
48265: ARRAY
48266: IN
48267: IFFALSE 48322
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48269: LD_ADDR_EXP 84
48273: PUSH
48274: LD_EXP 84
48278: PPUSH
48279: LD_VAR 0 3
48283: PPUSH
48284: LD_EXP 84
48288: PUSH
48289: LD_VAR 0 3
48293: ARRAY
48294: PPUSH
48295: LD_INT 1
48297: PPUSH
48298: LD_EXP 84
48302: PUSH
48303: LD_VAR 0 3
48307: ARRAY
48308: PPUSH
48309: LD_INT 0
48311: PPUSH
48312: CALL 54305 0 4
48316: PPUSH
48317: CALL_OW 1
48321: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48322: LD_VAR 0 1
48326: PUSH
48327: LD_EXP 50
48331: PUSH
48332: LD_VAR 0 3
48336: ARRAY
48337: IN
48338: NOT
48339: IFFALSE 48385
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48341: LD_ADDR_EXP 50
48345: PUSH
48346: LD_EXP 50
48350: PPUSH
48351: LD_VAR 0 3
48355: PUSH
48356: LD_EXP 50
48360: PUSH
48361: LD_VAR 0 3
48365: ARRAY
48366: PUSH
48367: LD_INT 1
48369: PLUS
48370: PUSH
48371: EMPTY
48372: LIST
48373: LIST
48374: PPUSH
48375: LD_VAR 0 1
48379: PPUSH
48380: CALL 54897 0 3
48384: ST_TO_ADDR
// exit ;
48385: POP
48386: POP
48387: GO 48393
// end ; end ;
48389: GO 48193
48391: POP
48392: POP
// end ;
48393: LD_VAR 0 2
48397: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48398: LD_INT 0
48400: PPUSH
48401: PPUSH
48402: PPUSH
48403: PPUSH
48404: PPUSH
48405: PPUSH
48406: PPUSH
// if not mc_bases or not skirmish then
48407: LD_EXP 50
48411: NOT
48412: IFTRUE 48421
48414: PUSH
48415: LD_EXP 48
48419: NOT
48420: OR
48421: IFFALSE 48425
// exit ;
48423: GO 49086
// for i = 1 to mc_bases do
48425: LD_ADDR_VAR 0 3
48429: PUSH
48430: DOUBLE
48431: LD_INT 1
48433: DEC
48434: ST_TO_ADDR
48435: LD_EXP 50
48439: PUSH
48440: FOR_TO
48441: IFFALSE 49084
// begin if building in mc_construct_list [ i ] then
48443: LD_VAR 0 1
48447: PUSH
48448: LD_EXP 57
48452: PUSH
48453: LD_VAR 0 3
48457: ARRAY
48458: IN
48459: IFFALSE 49082
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48461: LD_ADDR_EXP 57
48465: PUSH
48466: LD_EXP 57
48470: PPUSH
48471: LD_VAR 0 3
48475: PPUSH
48476: LD_EXP 57
48480: PUSH
48481: LD_VAR 0 3
48485: ARRAY
48486: PUSH
48487: LD_VAR 0 1
48491: DIFF
48492: PPUSH
48493: CALL_OW 1
48497: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48498: LD_ADDR_EXP 50
48502: PUSH
48503: LD_EXP 50
48507: PPUSH
48508: LD_VAR 0 3
48512: PUSH
48513: LD_EXP 50
48517: PUSH
48518: LD_VAR 0 3
48522: ARRAY
48523: PUSH
48524: LD_INT 1
48526: PLUS
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PPUSH
48532: LD_VAR 0 1
48536: PPUSH
48537: CALL 54897 0 3
48541: ST_TO_ADDR
// btype := GetBType ( building ) ;
48542: LD_ADDR_VAR 0 5
48546: PUSH
48547: LD_VAR 0 1
48551: PPUSH
48552: CALL_OW 266
48556: ST_TO_ADDR
// side := GetSide ( building ) ;
48557: LD_ADDR_VAR 0 8
48561: PUSH
48562: LD_VAR 0 1
48566: PPUSH
48567: CALL_OW 255
48571: ST_TO_ADDR
// if btype = b_lab then
48572: LD_VAR 0 5
48576: PUSH
48577: LD_INT 6
48579: EQUAL
48580: IFFALSE 48630
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48582: LD_ADDR_EXP 83
48586: PUSH
48587: LD_EXP 83
48591: PPUSH
48592: LD_VAR 0 3
48596: PUSH
48597: LD_EXP 83
48601: PUSH
48602: LD_VAR 0 3
48606: ARRAY
48607: PUSH
48608: LD_INT 1
48610: PLUS
48611: PUSH
48612: EMPTY
48613: LIST
48614: LIST
48615: PPUSH
48616: LD_VAR 0 1
48620: PPUSH
48621: CALL 54897 0 3
48625: ST_TO_ADDR
// exit ;
48626: POP
48627: POP
48628: GO 49086
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48630: LD_VAR 0 5
48634: PUSH
48635: LD_INT 0
48637: PUSH
48638: LD_INT 2
48640: PUSH
48641: LD_INT 4
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: LIST
48648: IN
48649: IFFALSE 48773
// begin if btype = b_armoury then
48651: LD_VAR 0 5
48655: PUSH
48656: LD_INT 4
48658: EQUAL
48659: IFFALSE 48669
// btype := b_barracks ;
48661: LD_ADDR_VAR 0 5
48665: PUSH
48666: LD_INT 5
48668: ST_TO_ADDR
// if btype = b_depot then
48669: LD_VAR 0 5
48673: PUSH
48674: LD_INT 0
48676: EQUAL
48677: IFFALSE 48687
// btype := b_warehouse ;
48679: LD_ADDR_VAR 0 5
48683: PUSH
48684: LD_INT 1
48686: ST_TO_ADDR
// if btype = b_workshop then
48687: LD_VAR 0 5
48691: PUSH
48692: LD_INT 2
48694: EQUAL
48695: IFFALSE 48705
// btype := b_factory ;
48697: LD_ADDR_VAR 0 5
48701: PUSH
48702: LD_INT 3
48704: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48705: LD_VAR 0 5
48709: PPUSH
48710: LD_VAR 0 8
48714: PPUSH
48715: CALL_OW 323
48719: PUSH
48720: LD_INT 1
48722: EQUAL
48723: IFFALSE 48769
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48725: LD_ADDR_EXP 82
48729: PUSH
48730: LD_EXP 82
48734: PPUSH
48735: LD_VAR 0 3
48739: PUSH
48740: LD_EXP 82
48744: PUSH
48745: LD_VAR 0 3
48749: ARRAY
48750: PUSH
48751: LD_INT 1
48753: PLUS
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: PPUSH
48759: LD_VAR 0 1
48763: PPUSH
48764: CALL 54897 0 3
48768: ST_TO_ADDR
// exit ;
48769: POP
48770: POP
48771: GO 49086
// end ; if btype in [ b_bunker , b_turret ] then
48773: LD_VAR 0 5
48777: PUSH
48778: LD_INT 32
48780: PUSH
48781: LD_INT 33
48783: PUSH
48784: EMPTY
48785: LIST
48786: LIST
48787: IN
48788: IFFALSE 49078
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48790: LD_ADDR_EXP 58
48794: PUSH
48795: LD_EXP 58
48799: PPUSH
48800: LD_VAR 0 3
48804: PUSH
48805: LD_EXP 58
48809: PUSH
48810: LD_VAR 0 3
48814: ARRAY
48815: PUSH
48816: LD_INT 1
48818: PLUS
48819: PUSH
48820: EMPTY
48821: LIST
48822: LIST
48823: PPUSH
48824: LD_VAR 0 1
48828: PPUSH
48829: CALL 54897 0 3
48833: ST_TO_ADDR
// if btype = b_bunker then
48834: LD_VAR 0 5
48838: PUSH
48839: LD_INT 32
48841: EQUAL
48842: IFFALSE 49078
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48844: LD_ADDR_EXP 59
48848: PUSH
48849: LD_EXP 59
48853: PPUSH
48854: LD_VAR 0 3
48858: PUSH
48859: LD_EXP 59
48863: PUSH
48864: LD_VAR 0 3
48868: ARRAY
48869: PUSH
48870: LD_INT 1
48872: PLUS
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PPUSH
48878: LD_VAR 0 1
48882: PPUSH
48883: CALL 54897 0 3
48887: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48888: LD_ADDR_VAR 0 6
48892: PUSH
48893: LD_EXP 50
48897: PUSH
48898: LD_VAR 0 3
48902: ARRAY
48903: PPUSH
48904: LD_INT 25
48906: PUSH
48907: LD_INT 1
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: PUSH
48914: LD_INT 3
48916: PUSH
48917: LD_INT 54
48919: PUSH
48920: EMPTY
48921: LIST
48922: PUSH
48923: EMPTY
48924: LIST
48925: LIST
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: PPUSH
48931: CALL_OW 72
48935: ST_TO_ADDR
// if tmp then
48936: LD_VAR 0 6
48940: IFFALSE 48946
// exit ;
48942: POP
48943: POP
48944: GO 49086
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48946: LD_ADDR_VAR 0 6
48950: PUSH
48951: LD_EXP 50
48955: PUSH
48956: LD_VAR 0 3
48960: ARRAY
48961: PPUSH
48962: LD_INT 2
48964: PUSH
48965: LD_INT 30
48967: PUSH
48968: LD_INT 4
48970: PUSH
48971: EMPTY
48972: LIST
48973: LIST
48974: PUSH
48975: LD_INT 30
48977: PUSH
48978: LD_INT 5
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: PUSH
48985: EMPTY
48986: LIST
48987: LIST
48988: LIST
48989: PPUSH
48990: CALL_OW 72
48994: ST_TO_ADDR
// if not tmp then
48995: LD_VAR 0 6
48999: NOT
49000: IFFALSE 49006
// exit ;
49002: POP
49003: POP
49004: GO 49086
// for j in tmp do
49006: LD_ADDR_VAR 0 4
49010: PUSH
49011: LD_VAR 0 6
49015: PUSH
49016: FOR_IN
49017: IFFALSE 49076
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49019: LD_ADDR_VAR 0 7
49023: PUSH
49024: LD_VAR 0 4
49028: PPUSH
49029: CALL_OW 313
49033: PPUSH
49034: LD_INT 25
49036: PUSH
49037: LD_INT 1
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PPUSH
49044: CALL_OW 72
49048: ST_TO_ADDR
// if units then
49049: LD_VAR 0 7
49053: IFFALSE 49074
// begin ComExitBuilding ( units [ 1 ] ) ;
49055: LD_VAR 0 7
49059: PUSH
49060: LD_INT 1
49062: ARRAY
49063: PPUSH
49064: CALL_OW 122
// exit ;
49068: POP
49069: POP
49070: POP
49071: POP
49072: GO 49086
// end ; end ;
49074: GO 49016
49076: POP
49077: POP
// end ; end ; exit ;
49078: POP
49079: POP
49080: GO 49086
// end ; end ;
49082: GO 48440
49084: POP
49085: POP
// end ;
49086: LD_VAR 0 2
49090: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49091: LD_INT 0
49093: PPUSH
49094: PPUSH
49095: PPUSH
49096: PPUSH
49097: PPUSH
49098: PPUSH
49099: PPUSH
// if not mc_bases or not skirmish then
49100: LD_EXP 50
49104: NOT
49105: IFTRUE 49114
49107: PUSH
49108: LD_EXP 48
49112: NOT
49113: OR
49114: IFFALSE 49118
// exit ;
49116: GO 49383
// btype := GetBType ( building ) ;
49118: LD_ADDR_VAR 0 6
49122: PUSH
49123: LD_VAR 0 1
49127: PPUSH
49128: CALL_OW 266
49132: ST_TO_ADDR
// x := GetX ( building ) ;
49133: LD_ADDR_VAR 0 7
49137: PUSH
49138: LD_VAR 0 1
49142: PPUSH
49143: CALL_OW 250
49147: ST_TO_ADDR
// y := GetY ( building ) ;
49148: LD_ADDR_VAR 0 8
49152: PUSH
49153: LD_VAR 0 1
49157: PPUSH
49158: CALL_OW 251
49162: ST_TO_ADDR
// d := GetDir ( building ) ;
49163: LD_ADDR_VAR 0 9
49167: PUSH
49168: LD_VAR 0 1
49172: PPUSH
49173: CALL_OW 254
49177: ST_TO_ADDR
// for i = 1 to mc_bases do
49178: LD_ADDR_VAR 0 4
49182: PUSH
49183: DOUBLE
49184: LD_INT 1
49186: DEC
49187: ST_TO_ADDR
49188: LD_EXP 50
49192: PUSH
49193: FOR_TO
49194: IFFALSE 49381
// begin if not mc_build_list [ i ] then
49196: LD_EXP 55
49200: PUSH
49201: LD_VAR 0 4
49205: ARRAY
49206: NOT
49207: IFFALSE 49211
// continue ;
49209: GO 49193
// for j := 1 to mc_build_list [ i ] do
49211: LD_ADDR_VAR 0 5
49215: PUSH
49216: DOUBLE
49217: LD_INT 1
49219: DEC
49220: ST_TO_ADDR
49221: LD_EXP 55
49225: PUSH
49226: LD_VAR 0 4
49230: ARRAY
49231: PUSH
49232: FOR_TO
49233: IFFALSE 49377
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
49235: LD_VAR 0 6
49239: PUSH
49240: LD_VAR 0 7
49244: PUSH
49245: LD_VAR 0 8
49249: PUSH
49250: LD_VAR 0 9
49254: PUSH
49255: EMPTY
49256: LIST
49257: LIST
49258: LIST
49259: LIST
49260: PPUSH
49261: LD_EXP 55
49265: PUSH
49266: LD_VAR 0 4
49270: ARRAY
49271: PUSH
49272: LD_VAR 0 5
49276: ARRAY
49277: PPUSH
49278: CALL 61504 0 2
49282: IFFALSE 49375
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
49284: LD_ADDR_EXP 55
49288: PUSH
49289: LD_EXP 55
49293: PPUSH
49294: LD_VAR 0 4
49298: PPUSH
49299: LD_EXP 55
49303: PUSH
49304: LD_VAR 0 4
49308: ARRAY
49309: PPUSH
49310: LD_VAR 0 5
49314: PPUSH
49315: CALL_OW 3
49319: PPUSH
49320: CALL_OW 1
49324: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49325: LD_ADDR_EXP 57
49329: PUSH
49330: LD_EXP 57
49334: PPUSH
49335: LD_VAR 0 4
49339: PUSH
49340: LD_EXP 57
49344: PUSH
49345: LD_VAR 0 4
49349: ARRAY
49350: PUSH
49351: LD_INT 1
49353: PLUS
49354: PUSH
49355: EMPTY
49356: LIST
49357: LIST
49358: PPUSH
49359: LD_VAR 0 1
49363: PPUSH
49364: CALL 54897 0 3
49368: ST_TO_ADDR
// exit ;
49369: POP
49370: POP
49371: POP
49372: POP
49373: GO 49383
// end ;
49375: GO 49232
49377: POP
49378: POP
// end ;
49379: GO 49193
49381: POP
49382: POP
// end ;
49383: LD_VAR 0 3
49387: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49388: LD_INT 0
49390: PPUSH
49391: PPUSH
49392: PPUSH
// if not mc_bases or not skirmish then
49393: LD_EXP 50
49397: NOT
49398: IFTRUE 49407
49400: PUSH
49401: LD_EXP 48
49405: NOT
49406: OR
49407: IFFALSE 49411
// exit ;
49409: GO 49607
// for i = 1 to mc_bases do
49411: LD_ADDR_VAR 0 4
49415: PUSH
49416: DOUBLE
49417: LD_INT 1
49419: DEC
49420: ST_TO_ADDR
49421: LD_EXP 50
49425: PUSH
49426: FOR_TO
49427: IFFALSE 49516
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49429: LD_VAR 0 1
49433: PUSH
49434: LD_EXP 58
49438: PUSH
49439: LD_VAR 0 4
49443: ARRAY
49444: IN
49445: IFFALSE 49466
49447: PUSH
49448: LD_VAR 0 1
49452: PUSH
49453: LD_EXP 59
49457: PUSH
49458: LD_VAR 0 4
49462: ARRAY
49463: IN
49464: NOT
49465: AND
49466: IFFALSE 49514
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49468: LD_ADDR_EXP 59
49472: PUSH
49473: LD_EXP 59
49477: PPUSH
49478: LD_VAR 0 4
49482: PUSH
49483: LD_EXP 59
49487: PUSH
49488: LD_VAR 0 4
49492: ARRAY
49493: PUSH
49494: LD_INT 1
49496: PLUS
49497: PUSH
49498: EMPTY
49499: LIST
49500: LIST
49501: PPUSH
49502: LD_VAR 0 1
49506: PPUSH
49507: CALL 54897 0 3
49511: ST_TO_ADDR
// break ;
49512: GO 49516
// end ; end ;
49514: GO 49426
49516: POP
49517: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
49518: LD_VAR 0 1
49522: PPUSH
49523: CALL_OW 257
49527: PUSH
49528: LD_EXP 76
49532: IN
49533: IFFALSE 49550
49535: PUSH
49536: LD_VAR 0 1
49540: PPUSH
49541: CALL_OW 266
49545: PUSH
49546: LD_INT 5
49548: EQUAL
49549: AND
49550: IFFALSE 49567
49552: PUSH
49553: LD_VAR 0 2
49557: PPUSH
49558: CALL_OW 110
49562: PUSH
49563: LD_INT 18
49565: NONEQUAL
49566: AND
49567: IFFALSE 49607
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49569: LD_VAR 0 2
49573: PPUSH
49574: CALL_OW 257
49578: PUSH
49579: LD_INT 5
49581: PUSH
49582: LD_INT 8
49584: PUSH
49585: LD_INT 9
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: LIST
49592: IN
49593: IFFALSE 49607
// SetClass ( unit , 1 ) ;
49595: LD_VAR 0 2
49599: PPUSH
49600: LD_INT 1
49602: PPUSH
49603: CALL_OW 336
// end ;
49607: LD_VAR 0 3
49611: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49612: LD_INT 0
49614: PPUSH
49615: PPUSH
// if not mc_bases or not skirmish then
49616: LD_EXP 50
49620: NOT
49621: IFTRUE 49630
49623: PUSH
49624: LD_EXP 48
49628: NOT
49629: OR
49630: IFFALSE 49634
// exit ;
49632: GO 49750
// if GetLives ( abandoned_vehicle ) > 250 then
49634: LD_VAR 0 2
49638: PPUSH
49639: CALL_OW 256
49643: PUSH
49644: LD_INT 250
49646: GREATER
49647: IFFALSE 49651
// exit ;
49649: GO 49750
// for i = 1 to mc_bases do
49651: LD_ADDR_VAR 0 6
49655: PUSH
49656: DOUBLE
49657: LD_INT 1
49659: DEC
49660: ST_TO_ADDR
49661: LD_EXP 50
49665: PUSH
49666: FOR_TO
49667: IFFALSE 49748
// begin if driver in mc_bases [ i ] then
49669: LD_VAR 0 1
49673: PUSH
49674: LD_EXP 50
49678: PUSH
49679: LD_VAR 0 6
49683: ARRAY
49684: IN
49685: IFFALSE 49746
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49687: LD_VAR 0 1
49691: PPUSH
49692: LD_EXP 50
49696: PUSH
49697: LD_VAR 0 6
49701: ARRAY
49702: PPUSH
49703: LD_INT 2
49705: PUSH
49706: LD_INT 30
49708: PUSH
49709: LD_INT 0
49711: PUSH
49712: EMPTY
49713: LIST
49714: LIST
49715: PUSH
49716: LD_INT 30
49718: PUSH
49719: LD_INT 1
49721: PUSH
49722: EMPTY
49723: LIST
49724: LIST
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: LIST
49730: PPUSH
49731: CALL_OW 72
49735: PUSH
49736: LD_INT 1
49738: ARRAY
49739: PPUSH
49740: CALL 88834 0 2
// break ;
49744: GO 49748
// end ; end ;
49746: GO 49666
49748: POP
49749: POP
// end ; end_of_file
49750: LD_VAR 0 5
49754: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49755: LD_INT 0
49757: PPUSH
49758: PPUSH
// if exist_mode then
49759: LD_VAR 0 2
49763: IFFALSE 49809
// begin unit := CreateCharacter ( prefix & ident ) ;
49765: LD_ADDR_VAR 0 5
49769: PUSH
49770: LD_VAR 0 3
49774: PUSH
49775: LD_VAR 0 1
49779: STR
49780: PPUSH
49781: CALL_OW 34
49785: ST_TO_ADDR
// if unit then
49786: LD_VAR 0 5
49790: IFFALSE 49807
// DeleteCharacters ( prefix & ident ) ;
49792: LD_VAR 0 3
49796: PUSH
49797: LD_VAR 0 1
49801: STR
49802: PPUSH
49803: CALL_OW 40
// end else
49807: GO 49824
// unit := NewCharacter ( ident ) ;
49809: LD_ADDR_VAR 0 5
49813: PUSH
49814: LD_VAR 0 1
49818: PPUSH
49819: CALL_OW 25
49823: ST_TO_ADDR
// result := unit ;
49824: LD_ADDR_VAR 0 4
49828: PUSH
49829: LD_VAR 0 5
49833: ST_TO_ADDR
// end ;
49834: LD_VAR 0 4
49838: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
49839: LD_INT 0
49841: PPUSH
49842: PPUSH
// if exist_mode then
49843: LD_VAR 0 2
49847: IFFALSE 49872
// unit := CreateCharacter ( prefix & ident ) else
49849: LD_ADDR_VAR 0 5
49853: PUSH
49854: LD_VAR 0 3
49858: PUSH
49859: LD_VAR 0 1
49863: STR
49864: PPUSH
49865: CALL_OW 34
49869: ST_TO_ADDR
49870: GO 49887
// unit := NewCharacter ( ident ) ;
49872: LD_ADDR_VAR 0 5
49876: PUSH
49877: LD_VAR 0 1
49881: PPUSH
49882: CALL_OW 25
49886: ST_TO_ADDR
// result := unit ;
49887: LD_ADDR_VAR 0 4
49891: PUSH
49892: LD_VAR 0 5
49896: ST_TO_ADDR
// end ;
49897: LD_VAR 0 4
49901: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49902: LD_INT 0
49904: PPUSH
49905: PPUSH
// if not side or not nation then
49906: LD_VAR 0 1
49910: NOT
49911: IFTRUE 49920
49913: PUSH
49914: LD_VAR 0 2
49918: NOT
49919: OR
49920: IFFALSE 49924
// exit ;
49922: GO 50718
// case nation of nation_american :
49924: LD_VAR 0 2
49928: PUSH
49929: LD_INT 1
49931: DOUBLE
49932: EQUAL
49933: IFTRUE 49937
49935: GO 50159
49937: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
49938: LD_ADDR_VAR 0 4
49942: PUSH
49943: LD_INT 35
49945: PUSH
49946: LD_INT 45
49948: PUSH
49949: LD_INT 46
49951: PUSH
49952: LD_INT 47
49954: PUSH
49955: LD_INT 82
49957: PUSH
49958: LD_INT 83
49960: PUSH
49961: LD_INT 84
49963: PUSH
49964: LD_INT 85
49966: PUSH
49967: LD_INT 86
49969: PUSH
49970: LD_INT 1
49972: PUSH
49973: LD_INT 2
49975: PUSH
49976: LD_INT 6
49978: PUSH
49979: LD_INT 15
49981: PUSH
49982: LD_INT 16
49984: PUSH
49985: LD_INT 7
49987: PUSH
49988: LD_INT 12
49990: PUSH
49991: LD_INT 13
49993: PUSH
49994: LD_INT 10
49996: PUSH
49997: LD_INT 14
49999: PUSH
50000: LD_INT 20
50002: PUSH
50003: LD_INT 21
50005: PUSH
50006: LD_INT 22
50008: PUSH
50009: LD_INT 25
50011: PUSH
50012: LD_INT 32
50014: PUSH
50015: LD_INT 27
50017: PUSH
50018: LD_INT 36
50020: PUSH
50021: LD_INT 69
50023: PUSH
50024: LD_INT 39
50026: PUSH
50027: LD_INT 34
50029: PUSH
50030: LD_INT 40
50032: PUSH
50033: LD_INT 48
50035: PUSH
50036: LD_INT 49
50038: PUSH
50039: LD_INT 50
50041: PUSH
50042: LD_INT 51
50044: PUSH
50045: LD_INT 52
50047: PUSH
50048: LD_INT 53
50050: PUSH
50051: LD_INT 54
50053: PUSH
50054: LD_INT 55
50056: PUSH
50057: LD_INT 56
50059: PUSH
50060: LD_INT 57
50062: PUSH
50063: LD_INT 58
50065: PUSH
50066: LD_INT 59
50068: PUSH
50069: LD_INT 60
50071: PUSH
50072: LD_INT 61
50074: PUSH
50075: LD_INT 62
50077: PUSH
50078: LD_INT 80
50080: PUSH
50081: LD_INT 82
50083: PUSH
50084: LD_INT 83
50086: PUSH
50087: LD_INT 84
50089: PUSH
50090: LD_INT 85
50092: PUSH
50093: LD_INT 86
50095: PUSH
50096: LD_INT 90
50098: PUSH
50099: LD_INT 93
50101: PUSH
50102: EMPTY
50103: LIST
50104: LIST
50105: LIST
50106: LIST
50107: LIST
50108: LIST
50109: LIST
50110: LIST
50111: LIST
50112: LIST
50113: LIST
50114: LIST
50115: LIST
50116: LIST
50117: LIST
50118: LIST
50119: LIST
50120: LIST
50121: LIST
50122: LIST
50123: LIST
50124: LIST
50125: LIST
50126: LIST
50127: LIST
50128: LIST
50129: LIST
50130: LIST
50131: LIST
50132: LIST
50133: LIST
50134: LIST
50135: LIST
50136: LIST
50137: LIST
50138: LIST
50139: LIST
50140: LIST
50141: LIST
50142: LIST
50143: LIST
50144: LIST
50145: LIST
50146: LIST
50147: LIST
50148: LIST
50149: LIST
50150: LIST
50151: LIST
50152: LIST
50153: LIST
50154: LIST
50155: LIST
50156: ST_TO_ADDR
50157: GO 50640
50159: LD_INT 2
50161: DOUBLE
50162: EQUAL
50163: IFTRUE 50167
50165: GO 50401
50167: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
50168: LD_ADDR_VAR 0 4
50172: PUSH
50173: LD_INT 35
50175: PUSH
50176: LD_INT 45
50178: PUSH
50179: LD_INT 46
50181: PUSH
50182: LD_INT 47
50184: PUSH
50185: LD_INT 82
50187: PUSH
50188: LD_INT 83
50190: PUSH
50191: LD_INT 84
50193: PUSH
50194: LD_INT 85
50196: PUSH
50197: LD_INT 87
50199: PUSH
50200: LD_INT 70
50202: PUSH
50203: LD_INT 1
50205: PUSH
50206: LD_INT 11
50208: PUSH
50209: LD_INT 3
50211: PUSH
50212: LD_INT 4
50214: PUSH
50215: LD_INT 5
50217: PUSH
50218: LD_INT 6
50220: PUSH
50221: LD_INT 15
50223: PUSH
50224: LD_INT 18
50226: PUSH
50227: LD_INT 7
50229: PUSH
50230: LD_INT 17
50232: PUSH
50233: LD_INT 8
50235: PUSH
50236: LD_INT 20
50238: PUSH
50239: LD_INT 21
50241: PUSH
50242: LD_INT 22
50244: PUSH
50245: LD_INT 72
50247: PUSH
50248: LD_INT 26
50250: PUSH
50251: LD_INT 69
50253: PUSH
50254: LD_INT 39
50256: PUSH
50257: LD_INT 40
50259: PUSH
50260: LD_INT 41
50262: PUSH
50263: LD_INT 42
50265: PUSH
50266: LD_INT 43
50268: PUSH
50269: LD_INT 48
50271: PUSH
50272: LD_INT 49
50274: PUSH
50275: LD_INT 50
50277: PUSH
50278: LD_INT 51
50280: PUSH
50281: LD_INT 52
50283: PUSH
50284: LD_INT 53
50286: PUSH
50287: LD_INT 54
50289: PUSH
50290: LD_INT 55
50292: PUSH
50293: LD_INT 56
50295: PUSH
50296: LD_INT 60
50298: PUSH
50299: LD_INT 61
50301: PUSH
50302: LD_INT 62
50304: PUSH
50305: LD_INT 66
50307: PUSH
50308: LD_INT 67
50310: PUSH
50311: LD_INT 68
50313: PUSH
50314: LD_INT 81
50316: PUSH
50317: LD_INT 82
50319: PUSH
50320: LD_INT 83
50322: PUSH
50323: LD_INT 84
50325: PUSH
50326: LD_INT 85
50328: PUSH
50329: LD_INT 87
50331: PUSH
50332: LD_INT 88
50334: PUSH
50335: LD_INT 92
50337: PUSH
50338: LD_INT 94
50340: PUSH
50341: EMPTY
50342: LIST
50343: LIST
50344: LIST
50345: LIST
50346: LIST
50347: LIST
50348: LIST
50349: LIST
50350: LIST
50351: LIST
50352: LIST
50353: LIST
50354: LIST
50355: LIST
50356: LIST
50357: LIST
50358: LIST
50359: LIST
50360: LIST
50361: LIST
50362: LIST
50363: LIST
50364: LIST
50365: LIST
50366: LIST
50367: LIST
50368: LIST
50369: LIST
50370: LIST
50371: LIST
50372: LIST
50373: LIST
50374: LIST
50375: LIST
50376: LIST
50377: LIST
50378: LIST
50379: LIST
50380: LIST
50381: LIST
50382: LIST
50383: LIST
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: LIST
50389: LIST
50390: LIST
50391: LIST
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: ST_TO_ADDR
50399: GO 50640
50401: LD_INT 3
50403: DOUBLE
50404: EQUAL
50405: IFTRUE 50409
50407: GO 50639
50409: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
50410: LD_ADDR_VAR 0 4
50414: PUSH
50415: LD_INT 46
50417: PUSH
50418: LD_INT 47
50420: PUSH
50421: LD_INT 1
50423: PUSH
50424: LD_INT 2
50426: PUSH
50427: LD_INT 82
50429: PUSH
50430: LD_INT 83
50432: PUSH
50433: LD_INT 84
50435: PUSH
50436: LD_INT 85
50438: PUSH
50439: LD_INT 86
50441: PUSH
50442: LD_INT 11
50444: PUSH
50445: LD_INT 9
50447: PUSH
50448: LD_INT 20
50450: PUSH
50451: LD_INT 19
50453: PUSH
50454: LD_INT 21
50456: PUSH
50457: LD_INT 24
50459: PUSH
50460: LD_INT 22
50462: PUSH
50463: LD_INT 25
50465: PUSH
50466: LD_INT 28
50468: PUSH
50469: LD_INT 29
50471: PUSH
50472: LD_INT 30
50474: PUSH
50475: LD_INT 31
50477: PUSH
50478: LD_INT 37
50480: PUSH
50481: LD_INT 38
50483: PUSH
50484: LD_INT 32
50486: PUSH
50487: LD_INT 27
50489: PUSH
50490: LD_INT 33
50492: PUSH
50493: LD_INT 69
50495: PUSH
50496: LD_INT 39
50498: PUSH
50499: LD_INT 34
50501: PUSH
50502: LD_INT 40
50504: PUSH
50505: LD_INT 71
50507: PUSH
50508: LD_INT 23
50510: PUSH
50511: LD_INT 44
50513: PUSH
50514: LD_INT 48
50516: PUSH
50517: LD_INT 49
50519: PUSH
50520: LD_INT 50
50522: PUSH
50523: LD_INT 51
50525: PUSH
50526: LD_INT 52
50528: PUSH
50529: LD_INT 53
50531: PUSH
50532: LD_INT 54
50534: PUSH
50535: LD_INT 55
50537: PUSH
50538: LD_INT 56
50540: PUSH
50541: LD_INT 57
50543: PUSH
50544: LD_INT 58
50546: PUSH
50547: LD_INT 59
50549: PUSH
50550: LD_INT 63
50552: PUSH
50553: LD_INT 64
50555: PUSH
50556: LD_INT 65
50558: PUSH
50559: LD_INT 82
50561: PUSH
50562: LD_INT 83
50564: PUSH
50565: LD_INT 84
50567: PUSH
50568: LD_INT 85
50570: PUSH
50571: LD_INT 86
50573: PUSH
50574: LD_INT 89
50576: PUSH
50577: LD_INT 91
50579: PUSH
50580: EMPTY
50581: LIST
50582: LIST
50583: LIST
50584: LIST
50585: LIST
50586: LIST
50587: LIST
50588: LIST
50589: LIST
50590: LIST
50591: LIST
50592: LIST
50593: LIST
50594: LIST
50595: LIST
50596: LIST
50597: LIST
50598: LIST
50599: LIST
50600: LIST
50601: LIST
50602: LIST
50603: LIST
50604: LIST
50605: LIST
50606: LIST
50607: LIST
50608: LIST
50609: LIST
50610: LIST
50611: LIST
50612: LIST
50613: LIST
50614: LIST
50615: LIST
50616: LIST
50617: LIST
50618: LIST
50619: LIST
50620: LIST
50621: LIST
50622: LIST
50623: LIST
50624: LIST
50625: LIST
50626: LIST
50627: LIST
50628: LIST
50629: LIST
50630: LIST
50631: LIST
50632: LIST
50633: LIST
50634: LIST
50635: LIST
50636: ST_TO_ADDR
50637: GO 50640
50639: POP
// if state > - 1 and state < 3 then
50640: LD_VAR 0 3
50644: PUSH
50645: LD_INT 1
50647: NEG
50648: GREATER
50649: IFFALSE 50661
50651: PUSH
50652: LD_VAR 0 3
50656: PUSH
50657: LD_INT 3
50659: LESS
50660: AND
50661: IFFALSE 50718
// for i in result do
50663: LD_ADDR_VAR 0 5
50667: PUSH
50668: LD_VAR 0 4
50672: PUSH
50673: FOR_IN
50674: IFFALSE 50716
// if GetTech ( i , side ) <> state then
50676: LD_VAR 0 5
50680: PPUSH
50681: LD_VAR 0 1
50685: PPUSH
50686: CALL_OW 321
50690: PUSH
50691: LD_VAR 0 3
50695: NONEQUAL
50696: IFFALSE 50714
// result := result diff i ;
50698: LD_ADDR_VAR 0 4
50702: PUSH
50703: LD_VAR 0 4
50707: PUSH
50708: LD_VAR 0 5
50712: DIFF
50713: ST_TO_ADDR
50714: GO 50673
50716: POP
50717: POP
// end ;
50718: LD_VAR 0 4
50722: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50723: LD_INT 0
50725: PPUSH
50726: PPUSH
50727: PPUSH
// result := true ;
50728: LD_ADDR_VAR 0 3
50732: PUSH
50733: LD_INT 1
50735: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50736: LD_ADDR_VAR 0 5
50740: PUSH
50741: LD_VAR 0 2
50745: PPUSH
50746: CALL_OW 480
50750: ST_TO_ADDR
// if not tmp then
50751: LD_VAR 0 5
50755: NOT
50756: IFFALSE 50760
// exit ;
50758: GO 50809
// for i in tmp do
50760: LD_ADDR_VAR 0 4
50764: PUSH
50765: LD_VAR 0 5
50769: PUSH
50770: FOR_IN
50771: IFFALSE 50807
// if GetTech ( i , side ) <> state_researched then
50773: LD_VAR 0 4
50777: PPUSH
50778: LD_VAR 0 1
50782: PPUSH
50783: CALL_OW 321
50787: PUSH
50788: LD_INT 2
50790: NONEQUAL
50791: IFFALSE 50805
// begin result := false ;
50793: LD_ADDR_VAR 0 3
50797: PUSH
50798: LD_INT 0
50800: ST_TO_ADDR
// exit ;
50801: POP
50802: POP
50803: GO 50809
// end ;
50805: GO 50770
50807: POP
50808: POP
// end ;
50809: LD_VAR 0 3
50813: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50814: LD_INT 0
50816: PPUSH
50817: PPUSH
50818: PPUSH
50819: PPUSH
50820: PPUSH
50821: PPUSH
50822: PPUSH
50823: PPUSH
50824: PPUSH
50825: PPUSH
50826: PPUSH
50827: PPUSH
50828: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50829: LD_VAR 0 1
50833: NOT
50834: IFTRUE 50851
50836: PUSH
50837: LD_VAR 0 1
50841: PPUSH
50842: CALL_OW 257
50846: PUSH
50847: LD_INT 9
50849: NONEQUAL
50850: OR
50851: IFFALSE 50855
// exit ;
50853: GO 51434
// side := GetSide ( unit ) ;
50855: LD_ADDR_VAR 0 9
50859: PUSH
50860: LD_VAR 0 1
50864: PPUSH
50865: CALL_OW 255
50869: ST_TO_ADDR
// tech_space := tech_spacanom ;
50870: LD_ADDR_VAR 0 12
50874: PUSH
50875: LD_INT 29
50877: ST_TO_ADDR
// tech_time := tech_taurad ;
50878: LD_ADDR_VAR 0 13
50882: PUSH
50883: LD_INT 28
50885: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50886: LD_ADDR_VAR 0 11
50890: PUSH
50891: LD_VAR 0 1
50895: PPUSH
50896: CALL_OW 310
50900: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50901: LD_VAR 0 11
50905: PPUSH
50906: CALL_OW 247
50910: PUSH
50911: LD_INT 2
50913: EQUAL
50914: IFFALSE 50918
// exit ;
50916: GO 51434
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50918: LD_ADDR_VAR 0 8
50922: PUSH
50923: LD_INT 81
50925: PUSH
50926: LD_VAR 0 9
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: PUSH
50935: LD_INT 3
50937: PUSH
50938: LD_INT 21
50940: PUSH
50941: LD_INT 3
50943: PUSH
50944: EMPTY
50945: LIST
50946: LIST
50947: PUSH
50948: EMPTY
50949: LIST
50950: LIST
50951: PUSH
50952: EMPTY
50953: LIST
50954: LIST
50955: PPUSH
50956: CALL_OW 69
50960: ST_TO_ADDR
// if not tmp then
50961: LD_VAR 0 8
50965: NOT
50966: IFFALSE 50970
// exit ;
50968: GO 51434
// if in_unit then
50970: LD_VAR 0 11
50974: IFFALSE 50998
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50976: LD_ADDR_VAR 0 10
50980: PUSH
50981: LD_VAR 0 8
50985: PPUSH
50986: LD_VAR 0 11
50990: PPUSH
50991: CALL_OW 74
50995: ST_TO_ADDR
50996: GO 51018
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50998: LD_ADDR_VAR 0 10
51002: PUSH
51003: LD_VAR 0 8
51007: PPUSH
51008: LD_VAR 0 1
51012: PPUSH
51013: CALL_OW 74
51017: ST_TO_ADDR
// if not enemy then
51018: LD_VAR 0 10
51022: NOT
51023: IFFALSE 51027
// exit ;
51025: GO 51434
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51027: LD_VAR 0 11
51031: IFFALSE 51053
51033: PUSH
51034: LD_VAR 0 11
51038: PPUSH
51039: LD_VAR 0 10
51043: PPUSH
51044: CALL_OW 296
51048: PUSH
51049: LD_INT 13
51051: GREATER
51052: AND
51053: IFTRUE 51075
51055: PUSH
51056: LD_VAR 0 1
51060: PPUSH
51061: LD_VAR 0 10
51065: PPUSH
51066: CALL_OW 296
51070: PUSH
51071: LD_INT 12
51073: GREATER
51074: OR
51075: IFFALSE 51079
// exit ;
51077: GO 51434
// missile := [ 1 ] ;
51079: LD_ADDR_VAR 0 14
51083: PUSH
51084: LD_INT 1
51086: PUSH
51087: EMPTY
51088: LIST
51089: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51090: LD_VAR 0 9
51094: PPUSH
51095: LD_VAR 0 12
51099: PPUSH
51100: CALL_OW 325
51104: IFFALSE 51133
// missile := Replace ( missile , missile + 1 , 2 ) ;
51106: LD_ADDR_VAR 0 14
51110: PUSH
51111: LD_VAR 0 14
51115: PPUSH
51116: LD_VAR 0 14
51120: PUSH
51121: LD_INT 1
51123: PLUS
51124: PPUSH
51125: LD_INT 2
51127: PPUSH
51128: CALL_OW 1
51132: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51133: LD_VAR 0 9
51137: PPUSH
51138: LD_VAR 0 13
51142: PPUSH
51143: CALL_OW 325
51147: IFFALSE 51171
51149: PUSH
51150: LD_VAR 0 10
51154: PPUSH
51155: CALL_OW 255
51159: PPUSH
51160: LD_VAR 0 13
51164: PPUSH
51165: CALL_OW 325
51169: NOT
51170: AND
51171: IFFALSE 51200
// missile := Replace ( missile , missile + 1 , 3 ) ;
51173: LD_ADDR_VAR 0 14
51177: PUSH
51178: LD_VAR 0 14
51182: PPUSH
51183: LD_VAR 0 14
51187: PUSH
51188: LD_INT 1
51190: PLUS
51191: PPUSH
51192: LD_INT 3
51194: PPUSH
51195: CALL_OW 1
51199: ST_TO_ADDR
// if missile < 2 then
51200: LD_VAR 0 14
51204: PUSH
51205: LD_INT 2
51207: LESS
51208: IFFALSE 51212
// exit ;
51210: GO 51434
// x := GetX ( enemy ) ;
51212: LD_ADDR_VAR 0 4
51216: PUSH
51217: LD_VAR 0 10
51221: PPUSH
51222: CALL_OW 250
51226: ST_TO_ADDR
// y := GetY ( enemy ) ;
51227: LD_ADDR_VAR 0 5
51231: PUSH
51232: LD_VAR 0 10
51236: PPUSH
51237: CALL_OW 251
51241: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51242: LD_ADDR_VAR 0 6
51246: PUSH
51247: LD_VAR 0 4
51251: PUSH
51252: LD_INT 1
51254: NEG
51255: PPUSH
51256: LD_INT 1
51258: PPUSH
51259: CALL_OW 12
51263: PLUS
51264: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51265: LD_ADDR_VAR 0 7
51269: PUSH
51270: LD_VAR 0 5
51274: PUSH
51275: LD_INT 1
51277: NEG
51278: PPUSH
51279: LD_INT 1
51281: PPUSH
51282: CALL_OW 12
51286: PLUS
51287: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51288: LD_VAR 0 6
51292: PPUSH
51293: LD_VAR 0 7
51297: PPUSH
51298: CALL_OW 488
51302: NOT
51303: IFFALSE 51325
// begin _x := x ;
51305: LD_ADDR_VAR 0 6
51309: PUSH
51310: LD_VAR 0 4
51314: ST_TO_ADDR
// _y := y ;
51315: LD_ADDR_VAR 0 7
51319: PUSH
51320: LD_VAR 0 5
51324: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51325: LD_ADDR_VAR 0 3
51329: PUSH
51330: LD_INT 1
51332: PPUSH
51333: LD_VAR 0 14
51337: PPUSH
51338: CALL_OW 12
51342: ST_TO_ADDR
// case i of 1 :
51343: LD_VAR 0 3
51347: PUSH
51348: LD_INT 1
51350: DOUBLE
51351: EQUAL
51352: IFTRUE 51356
51354: GO 51373
51356: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51357: LD_VAR 0 1
51361: PPUSH
51362: LD_VAR 0 10
51366: PPUSH
51367: CALL_OW 115
51371: GO 51434
51373: LD_INT 2
51375: DOUBLE
51376: EQUAL
51377: IFTRUE 51381
51379: GO 51403
51381: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51382: LD_VAR 0 1
51386: PPUSH
51387: LD_VAR 0 6
51391: PPUSH
51392: LD_VAR 0 7
51396: PPUSH
51397: CALL_OW 153
51401: GO 51434
51403: LD_INT 3
51405: DOUBLE
51406: EQUAL
51407: IFTRUE 51411
51409: GO 51433
51411: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51412: LD_VAR 0 1
51416: PPUSH
51417: LD_VAR 0 6
51421: PPUSH
51422: LD_VAR 0 7
51426: PPUSH
51427: CALL_OW 154
51431: GO 51434
51433: POP
// end ;
51434: LD_VAR 0 2
51438: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51439: LD_INT 0
51441: PPUSH
51442: PPUSH
51443: PPUSH
51444: PPUSH
51445: PPUSH
51446: PPUSH
// if not unit or not building then
51447: LD_VAR 0 1
51451: NOT
51452: IFTRUE 51461
51454: PUSH
51455: LD_VAR 0 2
51459: NOT
51460: OR
51461: IFFALSE 51465
// exit ;
51463: GO 51623
// x := GetX ( building ) ;
51465: LD_ADDR_VAR 0 5
51469: PUSH
51470: LD_VAR 0 2
51474: PPUSH
51475: CALL_OW 250
51479: ST_TO_ADDR
// y := GetY ( building ) ;
51480: LD_ADDR_VAR 0 6
51484: PUSH
51485: LD_VAR 0 2
51489: PPUSH
51490: CALL_OW 251
51494: ST_TO_ADDR
// for i := 0 to 5 do
51495: LD_ADDR_VAR 0 4
51499: PUSH
51500: DOUBLE
51501: LD_INT 0
51503: DEC
51504: ST_TO_ADDR
51505: LD_INT 5
51507: PUSH
51508: FOR_TO
51509: IFFALSE 51621
// begin _x := ShiftX ( x , i , 3 ) ;
51511: LD_ADDR_VAR 0 7
51515: PUSH
51516: LD_VAR 0 5
51520: PPUSH
51521: LD_VAR 0 4
51525: PPUSH
51526: LD_INT 3
51528: PPUSH
51529: CALL_OW 272
51533: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51534: LD_ADDR_VAR 0 8
51538: PUSH
51539: LD_VAR 0 6
51543: PPUSH
51544: LD_VAR 0 4
51548: PPUSH
51549: LD_INT 3
51551: PPUSH
51552: CALL_OW 273
51556: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51557: LD_VAR 0 7
51561: PPUSH
51562: LD_VAR 0 8
51566: PPUSH
51567: CALL_OW 488
51571: NOT
51572: IFFALSE 51576
// continue ;
51574: GO 51508
// if HexInfo ( _x , _y ) = 0 then
51576: LD_VAR 0 7
51580: PPUSH
51581: LD_VAR 0 8
51585: PPUSH
51586: CALL_OW 428
51590: PUSH
51591: LD_INT 0
51593: EQUAL
51594: IFFALSE 51619
// begin ComMoveXY ( unit , _x , _y ) ;
51596: LD_VAR 0 1
51600: PPUSH
51601: LD_VAR 0 7
51605: PPUSH
51606: LD_VAR 0 8
51610: PPUSH
51611: CALL_OW 111
// exit ;
51615: POP
51616: POP
51617: GO 51623
// end ; end ;
51619: GO 51508
51621: POP
51622: POP
// end ;
51623: LD_VAR 0 3
51627: RET
// export function ScanBase ( side , base_area ) ; begin
51628: LD_INT 0
51630: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51631: LD_ADDR_VAR 0 3
51635: PUSH
51636: LD_VAR 0 2
51640: PPUSH
51641: LD_INT 81
51643: PUSH
51644: LD_VAR 0 1
51648: PUSH
51649: EMPTY
51650: LIST
51651: LIST
51652: PPUSH
51653: CALL_OW 70
51657: ST_TO_ADDR
// end ;
51658: LD_VAR 0 3
51662: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
51663: LD_INT 0
51665: PPUSH
51666: PPUSH
51667: PPUSH
51668: PPUSH
// result := false ;
51669: LD_ADDR_VAR 0 2
51673: PUSH
51674: LD_INT 0
51676: ST_TO_ADDR
// side := GetSide ( unit ) ;
51677: LD_ADDR_VAR 0 3
51681: PUSH
51682: LD_VAR 0 1
51686: PPUSH
51687: CALL_OW 255
51691: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51692: LD_ADDR_VAR 0 4
51696: PUSH
51697: LD_VAR 0 1
51701: PPUSH
51702: CALL_OW 248
51706: ST_TO_ADDR
// case nat of 1 :
51707: LD_VAR 0 4
51711: PUSH
51712: LD_INT 1
51714: DOUBLE
51715: EQUAL
51716: IFTRUE 51720
51718: GO 51731
51720: POP
// tech := tech_lassight ; 2 :
51721: LD_ADDR_VAR 0 5
51725: PUSH
51726: LD_INT 12
51728: ST_TO_ADDR
51729: GO 51770
51731: LD_INT 2
51733: DOUBLE
51734: EQUAL
51735: IFTRUE 51739
51737: GO 51750
51739: POP
// tech := tech_mortar ; 3 :
51740: LD_ADDR_VAR 0 5
51744: PUSH
51745: LD_INT 41
51747: ST_TO_ADDR
51748: GO 51770
51750: LD_INT 3
51752: DOUBLE
51753: EQUAL
51754: IFTRUE 51758
51756: GO 51769
51758: POP
// tech := tech_bazooka ; end ;
51759: LD_ADDR_VAR 0 5
51763: PUSH
51764: LD_INT 44
51766: ST_TO_ADDR
51767: GO 51770
51769: POP
// if Researched ( side , tech ) then
51770: LD_VAR 0 3
51774: PPUSH
51775: LD_VAR 0 5
51779: PPUSH
51780: CALL_OW 325
51784: IFFALSE 51811
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51786: LD_ADDR_VAR 0 2
51790: PUSH
51791: LD_INT 5
51793: PUSH
51794: LD_INT 8
51796: PUSH
51797: LD_INT 9
51799: PUSH
51800: EMPTY
51801: LIST
51802: LIST
51803: LIST
51804: PUSH
51805: LD_VAR 0 4
51809: ARRAY
51810: ST_TO_ADDR
// end ;
51811: LD_VAR 0 2
51815: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51816: LD_INT 0
51818: PPUSH
51819: PPUSH
51820: PPUSH
// if not mines then
51821: LD_VAR 0 2
51825: NOT
51826: IFFALSE 51830
// exit ;
51828: GO 51974
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51830: LD_ADDR_VAR 0 5
51834: PUSH
51835: LD_INT 81
51837: PUSH
51838: LD_VAR 0 1
51842: PUSH
51843: EMPTY
51844: LIST
51845: LIST
51846: PUSH
51847: LD_INT 3
51849: PUSH
51850: LD_INT 21
51852: PUSH
51853: LD_INT 3
51855: PUSH
51856: EMPTY
51857: LIST
51858: LIST
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: PPUSH
51868: CALL_OW 69
51872: ST_TO_ADDR
// for i in mines do
51873: LD_ADDR_VAR 0 4
51877: PUSH
51878: LD_VAR 0 2
51882: PUSH
51883: FOR_IN
51884: IFFALSE 51972
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51886: LD_VAR 0 4
51890: PUSH
51891: LD_INT 1
51893: ARRAY
51894: PPUSH
51895: LD_VAR 0 4
51899: PUSH
51900: LD_INT 2
51902: ARRAY
51903: PPUSH
51904: CALL_OW 458
51908: NOT
51909: IFFALSE 51913
// continue ;
51911: GO 51883
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51913: LD_VAR 0 4
51917: PUSH
51918: LD_INT 1
51920: ARRAY
51921: PPUSH
51922: LD_VAR 0 4
51926: PUSH
51927: LD_INT 2
51929: ARRAY
51930: PPUSH
51931: CALL_OW 428
51935: PUSH
51936: LD_VAR 0 5
51940: IN
51941: IFFALSE 51970
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51943: LD_VAR 0 4
51947: PUSH
51948: LD_INT 1
51950: ARRAY
51951: PPUSH
51952: LD_VAR 0 4
51956: PUSH
51957: LD_INT 2
51959: ARRAY
51960: PPUSH
51961: LD_VAR 0 1
51965: PPUSH
51966: CALL_OW 456
// end ;
51970: GO 51883
51972: POP
51973: POP
// end ;
51974: LD_VAR 0 3
51978: RET
// export function Count ( array ) ; begin
51979: LD_INT 0
51981: PPUSH
// result := array + 0 ;
51982: LD_ADDR_VAR 0 2
51986: PUSH
51987: LD_VAR 0 1
51991: PUSH
51992: LD_INT 0
51994: PLUS
51995: ST_TO_ADDR
// end ;
51996: LD_VAR 0 2
52000: RET
// export function IsEmpty ( building ) ; begin
52001: LD_INT 0
52003: PPUSH
// if not building then
52004: LD_VAR 0 1
52008: NOT
52009: IFFALSE 52013
// exit ;
52011: GO 52056
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
52013: LD_ADDR_VAR 0 2
52017: PUSH
52018: LD_VAR 0 1
52022: PUSH
52023: LD_INT 22
52025: PUSH
52026: LD_VAR 0 1
52030: PPUSH
52031: CALL_OW 255
52035: PUSH
52036: EMPTY
52037: LIST
52038: LIST
52039: PUSH
52040: LD_INT 58
52042: PUSH
52043: EMPTY
52044: LIST
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: PPUSH
52050: CALL_OW 69
52054: IN
52055: ST_TO_ADDR
// end ;
52056: LD_VAR 0 2
52060: RET
// export function IsNotFull ( building ) ; var places ; begin
52061: LD_INT 0
52063: PPUSH
52064: PPUSH
// if not building then
52065: LD_VAR 0 1
52069: NOT
52070: IFFALSE 52074
// exit ;
52072: GO 52102
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
52074: LD_ADDR_VAR 0 2
52078: PUSH
52079: LD_VAR 0 1
52083: PPUSH
52084: LD_INT 3
52086: PUSH
52087: LD_INT 62
52089: PUSH
52090: EMPTY
52091: LIST
52092: PUSH
52093: EMPTY
52094: LIST
52095: LIST
52096: PPUSH
52097: CALL_OW 72
52101: ST_TO_ADDR
// end ;
52102: LD_VAR 0 2
52106: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
52107: LD_INT 0
52109: PPUSH
52110: PPUSH
52111: PPUSH
52112: PPUSH
// tmp := [ ] ;
52113: LD_ADDR_VAR 0 3
52117: PUSH
52118: EMPTY
52119: ST_TO_ADDR
// list := [ ] ;
52120: LD_ADDR_VAR 0 5
52124: PUSH
52125: EMPTY
52126: ST_TO_ADDR
// for i = 16 to 25 do
52127: LD_ADDR_VAR 0 4
52131: PUSH
52132: DOUBLE
52133: LD_INT 16
52135: DEC
52136: ST_TO_ADDR
52137: LD_INT 25
52139: PUSH
52140: FOR_TO
52141: IFFALSE 52214
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
52143: LD_ADDR_VAR 0 3
52147: PUSH
52148: LD_VAR 0 3
52152: PUSH
52153: LD_INT 22
52155: PUSH
52156: LD_VAR 0 1
52160: PPUSH
52161: CALL_OW 255
52165: PUSH
52166: EMPTY
52167: LIST
52168: LIST
52169: PUSH
52170: LD_INT 91
52172: PUSH
52173: LD_VAR 0 1
52177: PUSH
52178: LD_INT 6
52180: PUSH
52181: EMPTY
52182: LIST
52183: LIST
52184: LIST
52185: PUSH
52186: LD_INT 30
52188: PUSH
52189: LD_VAR 0 4
52193: PUSH
52194: EMPTY
52195: LIST
52196: LIST
52197: PUSH
52198: EMPTY
52199: LIST
52200: LIST
52201: LIST
52202: PUSH
52203: EMPTY
52204: LIST
52205: PPUSH
52206: CALL_OW 69
52210: ADD
52211: ST_TO_ADDR
52212: GO 52140
52214: POP
52215: POP
// for i = 1 to tmp do
52216: LD_ADDR_VAR 0 4
52220: PUSH
52221: DOUBLE
52222: LD_INT 1
52224: DEC
52225: ST_TO_ADDR
52226: LD_VAR 0 3
52230: PUSH
52231: FOR_TO
52232: IFFALSE 52320
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
52234: LD_ADDR_VAR 0 5
52238: PUSH
52239: LD_VAR 0 5
52243: PUSH
52244: LD_VAR 0 3
52248: PUSH
52249: LD_VAR 0 4
52253: ARRAY
52254: PPUSH
52255: CALL_OW 266
52259: PUSH
52260: LD_VAR 0 3
52264: PUSH
52265: LD_VAR 0 4
52269: ARRAY
52270: PPUSH
52271: CALL_OW 250
52275: PUSH
52276: LD_VAR 0 3
52280: PUSH
52281: LD_VAR 0 4
52285: ARRAY
52286: PPUSH
52287: CALL_OW 251
52291: PUSH
52292: LD_VAR 0 3
52296: PUSH
52297: LD_VAR 0 4
52301: ARRAY
52302: PPUSH
52303: CALL_OW 254
52307: PUSH
52308: EMPTY
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: PUSH
52314: EMPTY
52315: LIST
52316: ADD
52317: ST_TO_ADDR
52318: GO 52231
52320: POP
52321: POP
// result := list ;
52322: LD_ADDR_VAR 0 2
52326: PUSH
52327: LD_VAR 0 5
52331: ST_TO_ADDR
// end ;
52332: LD_VAR 0 2
52336: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
52337: LD_INT 0
52339: PPUSH
52340: PPUSH
52341: PPUSH
52342: PPUSH
52343: PPUSH
52344: PPUSH
52345: PPUSH
// if not factory then
52346: LD_VAR 0 1
52350: NOT
52351: IFFALSE 52355
// exit ;
52353: GO 52958
// if control = control_apeman then
52355: LD_VAR 0 4
52359: PUSH
52360: LD_INT 5
52362: EQUAL
52363: IFFALSE 52472
// begin tmp := UnitsInside ( factory ) ;
52365: LD_ADDR_VAR 0 8
52369: PUSH
52370: LD_VAR 0 1
52374: PPUSH
52375: CALL_OW 313
52379: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
52380: LD_VAR 0 8
52384: PPUSH
52385: LD_INT 25
52387: PUSH
52388: LD_INT 12
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PPUSH
52395: CALL_OW 72
52399: NOT
52400: IFFALSE 52410
// control := control_manual ;
52402: LD_ADDR_VAR 0 4
52406: PUSH
52407: LD_INT 1
52409: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
52410: LD_ADDR_VAR 0 8
52414: PUSH
52415: LD_VAR 0 1
52419: PPUSH
52420: CALL 52107 0 1
52424: ST_TO_ADDR
// if tmp then
52425: LD_VAR 0 8
52429: IFFALSE 52472
// begin for i in tmp do
52431: LD_ADDR_VAR 0 7
52435: PUSH
52436: LD_VAR 0 8
52440: PUSH
52441: FOR_IN
52442: IFFALSE 52470
// if i [ 1 ] = b_ext_radio then
52444: LD_VAR 0 7
52448: PUSH
52449: LD_INT 1
52451: ARRAY
52452: PUSH
52453: LD_INT 22
52455: EQUAL
52456: IFFALSE 52468
// begin control := control_remote ;
52458: LD_ADDR_VAR 0 4
52462: PUSH
52463: LD_INT 2
52465: ST_TO_ADDR
// break ;
52466: GO 52470
// end ;
52468: GO 52441
52470: POP
52471: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52472: LD_VAR 0 1
52476: PPUSH
52477: LD_VAR 0 2
52481: PPUSH
52482: LD_VAR 0 3
52486: PPUSH
52487: LD_VAR 0 4
52491: PPUSH
52492: LD_VAR 0 5
52496: PPUSH
52497: CALL_OW 448
52501: IFFALSE 52536
// begin result := [ chassis , engine , control , weapon ] ;
52503: LD_ADDR_VAR 0 6
52507: PUSH
52508: LD_VAR 0 2
52512: PUSH
52513: LD_VAR 0 3
52517: PUSH
52518: LD_VAR 0 4
52522: PUSH
52523: LD_VAR 0 5
52527: PUSH
52528: EMPTY
52529: LIST
52530: LIST
52531: LIST
52532: LIST
52533: ST_TO_ADDR
// exit ;
52534: GO 52958
// end ; _chassis := AvailableChassisList ( factory ) ;
52536: LD_ADDR_VAR 0 9
52540: PUSH
52541: LD_VAR 0 1
52545: PPUSH
52546: CALL_OW 475
52550: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
52551: LD_ADDR_VAR 0 11
52555: PUSH
52556: LD_VAR 0 1
52560: PPUSH
52561: CALL_OW 476
52565: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
52566: LD_ADDR_VAR 0 12
52570: PUSH
52571: LD_VAR 0 1
52575: PPUSH
52576: CALL_OW 477
52580: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
52581: LD_ADDR_VAR 0 10
52585: PUSH
52586: LD_VAR 0 1
52590: PPUSH
52591: CALL_OW 478
52595: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
52596: LD_VAR 0 9
52600: NOT
52601: IFTRUE 52610
52603: PUSH
52604: LD_VAR 0 11
52608: NOT
52609: OR
52610: IFTRUE 52619
52612: PUSH
52613: LD_VAR 0 12
52617: NOT
52618: OR
52619: IFTRUE 52628
52621: PUSH
52622: LD_VAR 0 10
52626: NOT
52627: OR
52628: IFFALSE 52663
// begin result := [ chassis , engine , control , weapon ] ;
52630: LD_ADDR_VAR 0 6
52634: PUSH
52635: LD_VAR 0 2
52639: PUSH
52640: LD_VAR 0 3
52644: PUSH
52645: LD_VAR 0 4
52649: PUSH
52650: LD_VAR 0 5
52654: PUSH
52655: EMPTY
52656: LIST
52657: LIST
52658: LIST
52659: LIST
52660: ST_TO_ADDR
// exit ;
52661: GO 52958
// end ; if not chassis in _chassis then
52663: LD_VAR 0 2
52667: PUSH
52668: LD_VAR 0 9
52672: IN
52673: NOT
52674: IFFALSE 52700
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
52676: LD_ADDR_VAR 0 2
52680: PUSH
52681: LD_VAR 0 9
52685: PUSH
52686: LD_INT 1
52688: PPUSH
52689: LD_VAR 0 9
52693: PPUSH
52694: CALL_OW 12
52698: ARRAY
52699: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52700: LD_VAR 0 2
52704: PPUSH
52705: LD_VAR 0 3
52709: PPUSH
52710: CALL 52963 0 2
52714: NOT
52715: IFFALSE 52776
// repeat engine := _engine [ 1 ] ;
52717: LD_ADDR_VAR 0 3
52721: PUSH
52722: LD_VAR 0 11
52726: PUSH
52727: LD_INT 1
52729: ARRAY
52730: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52731: LD_ADDR_VAR 0 11
52735: PUSH
52736: LD_VAR 0 11
52740: PPUSH
52741: LD_INT 1
52743: PPUSH
52744: CALL_OW 3
52748: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52749: LD_VAR 0 2
52753: PPUSH
52754: LD_VAR 0 3
52758: PPUSH
52759: CALL 52963 0 2
52763: IFTRUE 52774
52765: PUSH
52766: LD_VAR 0 11
52770: PUSH
52771: EMPTY
52772: EQUAL
52773: OR
52774: IFFALSE 52717
// if not control in _control then
52776: LD_VAR 0 4
52780: PUSH
52781: LD_VAR 0 12
52785: IN
52786: NOT
52787: IFFALSE 52813
// control := _control [ rand ( 1 , _control ) ] ;
52789: LD_ADDR_VAR 0 4
52793: PUSH
52794: LD_VAR 0 12
52798: PUSH
52799: LD_INT 1
52801: PPUSH
52802: LD_VAR 0 12
52806: PPUSH
52807: CALL_OW 12
52811: ARRAY
52812: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52813: LD_VAR 0 2
52817: PPUSH
52818: LD_VAR 0 5
52822: PPUSH
52823: CALL 53185 0 2
52827: NOT
52828: IFFALSE 52889
// repeat weapon := _weapon [ 1 ] ;
52830: LD_ADDR_VAR 0 5
52834: PUSH
52835: LD_VAR 0 10
52839: PUSH
52840: LD_INT 1
52842: ARRAY
52843: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52844: LD_ADDR_VAR 0 10
52848: PUSH
52849: LD_VAR 0 10
52853: PPUSH
52854: LD_INT 1
52856: PPUSH
52857: CALL_OW 3
52861: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52862: LD_VAR 0 2
52866: PPUSH
52867: LD_VAR 0 5
52871: PPUSH
52872: CALL 53185 0 2
52876: IFTRUE 52887
52878: PUSH
52879: LD_VAR 0 10
52883: PUSH
52884: EMPTY
52885: EQUAL
52886: OR
52887: IFFALSE 52830
// result := [ ] ;
52889: LD_ADDR_VAR 0 6
52893: PUSH
52894: EMPTY
52895: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52896: LD_VAR 0 1
52900: PPUSH
52901: LD_VAR 0 2
52905: PPUSH
52906: LD_VAR 0 3
52910: PPUSH
52911: LD_VAR 0 4
52915: PPUSH
52916: LD_VAR 0 5
52920: PPUSH
52921: CALL_OW 448
52925: IFFALSE 52958
// result := [ chassis , engine , control , weapon ] ;
52927: LD_ADDR_VAR 0 6
52931: PUSH
52932: LD_VAR 0 2
52936: PUSH
52937: LD_VAR 0 3
52941: PUSH
52942: LD_VAR 0 4
52946: PUSH
52947: LD_VAR 0 5
52951: PUSH
52952: EMPTY
52953: LIST
52954: LIST
52955: LIST
52956: LIST
52957: ST_TO_ADDR
// end ;
52958: LD_VAR 0 6
52962: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52963: LD_INT 0
52965: PPUSH
// if not chassis or not engine then
52966: LD_VAR 0 1
52970: NOT
52971: IFTRUE 52980
52973: PUSH
52974: LD_VAR 0 2
52978: NOT
52979: OR
52980: IFFALSE 52984
// exit ;
52982: GO 53180
// case engine of engine_solar :
52984: LD_VAR 0 2
52988: PUSH
52989: LD_INT 2
52991: DOUBLE
52992: EQUAL
52993: IFTRUE 52997
52995: GO 53035
52997: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52998: LD_ADDR_VAR 0 3
53002: PUSH
53003: LD_INT 11
53005: PUSH
53006: LD_INT 12
53008: PUSH
53009: LD_INT 13
53011: PUSH
53012: LD_INT 14
53014: PUSH
53015: LD_INT 1
53017: PUSH
53018: LD_INT 2
53020: PUSH
53021: LD_INT 3
53023: PUSH
53024: EMPTY
53025: LIST
53026: LIST
53027: LIST
53028: LIST
53029: LIST
53030: LIST
53031: LIST
53032: ST_TO_ADDR
53033: GO 53164
53035: LD_INT 1
53037: DOUBLE
53038: EQUAL
53039: IFTRUE 53043
53041: GO 53105
53043: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
53044: LD_ADDR_VAR 0 3
53048: PUSH
53049: LD_INT 11
53051: PUSH
53052: LD_INT 12
53054: PUSH
53055: LD_INT 13
53057: PUSH
53058: LD_INT 14
53060: PUSH
53061: LD_INT 1
53063: PUSH
53064: LD_INT 2
53066: PUSH
53067: LD_INT 3
53069: PUSH
53070: LD_INT 4
53072: PUSH
53073: LD_INT 5
53075: PUSH
53076: LD_INT 21
53078: PUSH
53079: LD_INT 23
53081: PUSH
53082: LD_INT 22
53084: PUSH
53085: LD_INT 24
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: LIST
53092: LIST
53093: LIST
53094: LIST
53095: LIST
53096: LIST
53097: LIST
53098: LIST
53099: LIST
53100: LIST
53101: LIST
53102: ST_TO_ADDR
53103: GO 53164
53105: LD_INT 3
53107: DOUBLE
53108: EQUAL
53109: IFTRUE 53113
53111: GO 53163
53113: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53114: LD_ADDR_VAR 0 3
53118: PUSH
53119: LD_INT 13
53121: PUSH
53122: LD_INT 14
53124: PUSH
53125: LD_INT 2
53127: PUSH
53128: LD_INT 3
53130: PUSH
53131: LD_INT 4
53133: PUSH
53134: LD_INT 5
53136: PUSH
53137: LD_INT 21
53139: PUSH
53140: LD_INT 22
53142: PUSH
53143: LD_INT 23
53145: PUSH
53146: LD_INT 24
53148: PUSH
53149: EMPTY
53150: LIST
53151: LIST
53152: LIST
53153: LIST
53154: LIST
53155: LIST
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: ST_TO_ADDR
53161: GO 53164
53163: POP
// result := ( chassis in result ) ;
53164: LD_ADDR_VAR 0 3
53168: PUSH
53169: LD_VAR 0 1
53173: PUSH
53174: LD_VAR 0 3
53178: IN
53179: ST_TO_ADDR
// end ;
53180: LD_VAR 0 3
53184: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
53185: LD_INT 0
53187: PPUSH
// if not chassis or not weapon then
53188: LD_VAR 0 1
53192: NOT
53193: IFTRUE 53202
53195: PUSH
53196: LD_VAR 0 2
53200: NOT
53201: OR
53202: IFFALSE 53206
// exit ;
53204: GO 54300
// case weapon of us_machine_gun :
53206: LD_VAR 0 2
53210: PUSH
53211: LD_INT 2
53213: DOUBLE
53214: EQUAL
53215: IFTRUE 53219
53217: GO 53249
53219: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
53220: LD_ADDR_VAR 0 3
53224: PUSH
53225: LD_INT 1
53227: PUSH
53228: LD_INT 2
53230: PUSH
53231: LD_INT 3
53233: PUSH
53234: LD_INT 4
53236: PUSH
53237: LD_INT 5
53239: PUSH
53240: EMPTY
53241: LIST
53242: LIST
53243: LIST
53244: LIST
53245: LIST
53246: ST_TO_ADDR
53247: GO 54284
53249: LD_INT 3
53251: DOUBLE
53252: EQUAL
53253: IFTRUE 53257
53255: GO 53287
53257: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
53258: LD_ADDR_VAR 0 3
53262: PUSH
53263: LD_INT 1
53265: PUSH
53266: LD_INT 2
53268: PUSH
53269: LD_INT 3
53271: PUSH
53272: LD_INT 4
53274: PUSH
53275: LD_INT 5
53277: PUSH
53278: EMPTY
53279: LIST
53280: LIST
53281: LIST
53282: LIST
53283: LIST
53284: ST_TO_ADDR
53285: GO 54284
53287: LD_INT 11
53289: DOUBLE
53290: EQUAL
53291: IFTRUE 53295
53293: GO 53325
53295: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
53296: LD_ADDR_VAR 0 3
53300: PUSH
53301: LD_INT 1
53303: PUSH
53304: LD_INT 2
53306: PUSH
53307: LD_INT 3
53309: PUSH
53310: LD_INT 4
53312: PUSH
53313: LD_INT 5
53315: PUSH
53316: EMPTY
53317: LIST
53318: LIST
53319: LIST
53320: LIST
53321: LIST
53322: ST_TO_ADDR
53323: GO 54284
53325: LD_INT 4
53327: DOUBLE
53328: EQUAL
53329: IFTRUE 53333
53331: GO 53359
53333: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
53334: LD_ADDR_VAR 0 3
53338: PUSH
53339: LD_INT 2
53341: PUSH
53342: LD_INT 3
53344: PUSH
53345: LD_INT 4
53347: PUSH
53348: LD_INT 5
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: ST_TO_ADDR
53357: GO 54284
53359: LD_INT 5
53361: DOUBLE
53362: EQUAL
53363: IFTRUE 53367
53365: GO 53393
53367: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
53368: LD_ADDR_VAR 0 3
53372: PUSH
53373: LD_INT 2
53375: PUSH
53376: LD_INT 3
53378: PUSH
53379: LD_INT 4
53381: PUSH
53382: LD_INT 5
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: LIST
53389: LIST
53390: ST_TO_ADDR
53391: GO 54284
53393: LD_INT 9
53395: DOUBLE
53396: EQUAL
53397: IFTRUE 53401
53399: GO 53427
53401: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
53402: LD_ADDR_VAR 0 3
53406: PUSH
53407: LD_INT 2
53409: PUSH
53410: LD_INT 3
53412: PUSH
53413: LD_INT 4
53415: PUSH
53416: LD_INT 5
53418: PUSH
53419: EMPTY
53420: LIST
53421: LIST
53422: LIST
53423: LIST
53424: ST_TO_ADDR
53425: GO 54284
53427: LD_INT 7
53429: DOUBLE
53430: EQUAL
53431: IFTRUE 53435
53433: GO 53461
53435: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
53436: LD_ADDR_VAR 0 3
53440: PUSH
53441: LD_INT 2
53443: PUSH
53444: LD_INT 3
53446: PUSH
53447: LD_INT 4
53449: PUSH
53450: LD_INT 5
53452: PUSH
53453: EMPTY
53454: LIST
53455: LIST
53456: LIST
53457: LIST
53458: ST_TO_ADDR
53459: GO 54284
53461: LD_INT 12
53463: DOUBLE
53464: EQUAL
53465: IFTRUE 53469
53467: GO 53495
53469: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
53470: LD_ADDR_VAR 0 3
53474: PUSH
53475: LD_INT 2
53477: PUSH
53478: LD_INT 3
53480: PUSH
53481: LD_INT 4
53483: PUSH
53484: LD_INT 5
53486: PUSH
53487: EMPTY
53488: LIST
53489: LIST
53490: LIST
53491: LIST
53492: ST_TO_ADDR
53493: GO 54284
53495: LD_INT 13
53497: DOUBLE
53498: EQUAL
53499: IFTRUE 53503
53501: GO 53529
53503: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
53504: LD_ADDR_VAR 0 3
53508: PUSH
53509: LD_INT 2
53511: PUSH
53512: LD_INT 3
53514: PUSH
53515: LD_INT 4
53517: PUSH
53518: LD_INT 5
53520: PUSH
53521: EMPTY
53522: LIST
53523: LIST
53524: LIST
53525: LIST
53526: ST_TO_ADDR
53527: GO 54284
53529: LD_INT 14
53531: DOUBLE
53532: EQUAL
53533: IFTRUE 53537
53535: GO 53555
53537: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
53538: LD_ADDR_VAR 0 3
53542: PUSH
53543: LD_INT 4
53545: PUSH
53546: LD_INT 5
53548: PUSH
53549: EMPTY
53550: LIST
53551: LIST
53552: ST_TO_ADDR
53553: GO 54284
53555: LD_INT 6
53557: DOUBLE
53558: EQUAL
53559: IFTRUE 53563
53561: GO 53581
53563: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
53564: LD_ADDR_VAR 0 3
53568: PUSH
53569: LD_INT 4
53571: PUSH
53572: LD_INT 5
53574: PUSH
53575: EMPTY
53576: LIST
53577: LIST
53578: ST_TO_ADDR
53579: GO 54284
53581: LD_INT 10
53583: DOUBLE
53584: EQUAL
53585: IFTRUE 53589
53587: GO 53607
53589: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
53590: LD_ADDR_VAR 0 3
53594: PUSH
53595: LD_INT 4
53597: PUSH
53598: LD_INT 5
53600: PUSH
53601: EMPTY
53602: LIST
53603: LIST
53604: ST_TO_ADDR
53605: GO 54284
53607: LD_INT 22
53609: DOUBLE
53610: EQUAL
53611: IFTRUE 53615
53613: GO 53641
53615: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
53616: LD_ADDR_VAR 0 3
53620: PUSH
53621: LD_INT 11
53623: PUSH
53624: LD_INT 12
53626: PUSH
53627: LD_INT 13
53629: PUSH
53630: LD_INT 14
53632: PUSH
53633: EMPTY
53634: LIST
53635: LIST
53636: LIST
53637: LIST
53638: ST_TO_ADDR
53639: GO 54284
53641: LD_INT 23
53643: DOUBLE
53644: EQUAL
53645: IFTRUE 53649
53647: GO 53675
53649: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
53650: LD_ADDR_VAR 0 3
53654: PUSH
53655: LD_INT 11
53657: PUSH
53658: LD_INT 12
53660: PUSH
53661: LD_INT 13
53663: PUSH
53664: LD_INT 14
53666: PUSH
53667: EMPTY
53668: LIST
53669: LIST
53670: LIST
53671: LIST
53672: ST_TO_ADDR
53673: GO 54284
53675: LD_INT 24
53677: DOUBLE
53678: EQUAL
53679: IFTRUE 53683
53681: GO 53709
53683: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
53684: LD_ADDR_VAR 0 3
53688: PUSH
53689: LD_INT 11
53691: PUSH
53692: LD_INT 12
53694: PUSH
53695: LD_INT 13
53697: PUSH
53698: LD_INT 14
53700: PUSH
53701: EMPTY
53702: LIST
53703: LIST
53704: LIST
53705: LIST
53706: ST_TO_ADDR
53707: GO 54284
53709: LD_INT 30
53711: DOUBLE
53712: EQUAL
53713: IFTRUE 53717
53715: GO 53743
53717: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53718: LD_ADDR_VAR 0 3
53722: PUSH
53723: LD_INT 11
53725: PUSH
53726: LD_INT 12
53728: PUSH
53729: LD_INT 13
53731: PUSH
53732: LD_INT 14
53734: PUSH
53735: EMPTY
53736: LIST
53737: LIST
53738: LIST
53739: LIST
53740: ST_TO_ADDR
53741: GO 54284
53743: LD_INT 25
53745: DOUBLE
53746: EQUAL
53747: IFTRUE 53751
53749: GO 53769
53751: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53752: LD_ADDR_VAR 0 3
53756: PUSH
53757: LD_INT 13
53759: PUSH
53760: LD_INT 14
53762: PUSH
53763: EMPTY
53764: LIST
53765: LIST
53766: ST_TO_ADDR
53767: GO 54284
53769: LD_INT 27
53771: DOUBLE
53772: EQUAL
53773: IFTRUE 53777
53775: GO 53795
53777: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
53778: LD_ADDR_VAR 0 3
53782: PUSH
53783: LD_INT 13
53785: PUSH
53786: LD_INT 14
53788: PUSH
53789: EMPTY
53790: LIST
53791: LIST
53792: ST_TO_ADDR
53793: GO 54284
53795: LD_INT 92
53797: DOUBLE
53798: EQUAL
53799: IFTRUE 53803
53801: GO 53829
53803: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53804: LD_ADDR_VAR 0 3
53808: PUSH
53809: LD_INT 11
53811: PUSH
53812: LD_INT 12
53814: PUSH
53815: LD_INT 13
53817: PUSH
53818: LD_INT 14
53820: PUSH
53821: EMPTY
53822: LIST
53823: LIST
53824: LIST
53825: LIST
53826: ST_TO_ADDR
53827: GO 54284
53829: LD_INT 28
53831: DOUBLE
53832: EQUAL
53833: IFTRUE 53837
53835: GO 53855
53837: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53838: LD_ADDR_VAR 0 3
53842: PUSH
53843: LD_INT 13
53845: PUSH
53846: LD_INT 14
53848: PUSH
53849: EMPTY
53850: LIST
53851: LIST
53852: ST_TO_ADDR
53853: GO 54284
53855: LD_INT 29
53857: DOUBLE
53858: EQUAL
53859: IFTRUE 53863
53861: GO 53881
53863: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53864: LD_ADDR_VAR 0 3
53868: PUSH
53869: LD_INT 13
53871: PUSH
53872: LD_INT 14
53874: PUSH
53875: EMPTY
53876: LIST
53877: LIST
53878: ST_TO_ADDR
53879: GO 54284
53881: LD_INT 31
53883: DOUBLE
53884: EQUAL
53885: IFTRUE 53889
53887: GO 53907
53889: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53890: LD_ADDR_VAR 0 3
53894: PUSH
53895: LD_INT 13
53897: PUSH
53898: LD_INT 14
53900: PUSH
53901: EMPTY
53902: LIST
53903: LIST
53904: ST_TO_ADDR
53905: GO 54284
53907: LD_INT 26
53909: DOUBLE
53910: EQUAL
53911: IFTRUE 53915
53913: GO 53933
53915: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53916: LD_ADDR_VAR 0 3
53920: PUSH
53921: LD_INT 13
53923: PUSH
53924: LD_INT 14
53926: PUSH
53927: EMPTY
53928: LIST
53929: LIST
53930: ST_TO_ADDR
53931: GO 54284
53933: LD_INT 42
53935: DOUBLE
53936: EQUAL
53937: IFTRUE 53941
53939: GO 53967
53941: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53942: LD_ADDR_VAR 0 3
53946: PUSH
53947: LD_INT 21
53949: PUSH
53950: LD_INT 22
53952: PUSH
53953: LD_INT 23
53955: PUSH
53956: LD_INT 24
53958: PUSH
53959: EMPTY
53960: LIST
53961: LIST
53962: LIST
53963: LIST
53964: ST_TO_ADDR
53965: GO 54284
53967: LD_INT 43
53969: DOUBLE
53970: EQUAL
53971: IFTRUE 53975
53973: GO 54001
53975: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53976: LD_ADDR_VAR 0 3
53980: PUSH
53981: LD_INT 21
53983: PUSH
53984: LD_INT 22
53986: PUSH
53987: LD_INT 23
53989: PUSH
53990: LD_INT 24
53992: PUSH
53993: EMPTY
53994: LIST
53995: LIST
53996: LIST
53997: LIST
53998: ST_TO_ADDR
53999: GO 54284
54001: LD_INT 44
54003: DOUBLE
54004: EQUAL
54005: IFTRUE 54009
54007: GO 54035
54009: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54010: LD_ADDR_VAR 0 3
54014: PUSH
54015: LD_INT 21
54017: PUSH
54018: LD_INT 22
54020: PUSH
54021: LD_INT 23
54023: PUSH
54024: LD_INT 24
54026: PUSH
54027: EMPTY
54028: LIST
54029: LIST
54030: LIST
54031: LIST
54032: ST_TO_ADDR
54033: GO 54284
54035: LD_INT 45
54037: DOUBLE
54038: EQUAL
54039: IFTRUE 54043
54041: GO 54069
54043: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
54044: LD_ADDR_VAR 0 3
54048: PUSH
54049: LD_INT 21
54051: PUSH
54052: LD_INT 22
54054: PUSH
54055: LD_INT 23
54057: PUSH
54058: LD_INT 24
54060: PUSH
54061: EMPTY
54062: LIST
54063: LIST
54064: LIST
54065: LIST
54066: ST_TO_ADDR
54067: GO 54284
54069: LD_INT 49
54071: DOUBLE
54072: EQUAL
54073: IFTRUE 54077
54075: GO 54103
54077: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
54078: LD_ADDR_VAR 0 3
54082: PUSH
54083: LD_INT 21
54085: PUSH
54086: LD_INT 22
54088: PUSH
54089: LD_INT 23
54091: PUSH
54092: LD_INT 24
54094: PUSH
54095: EMPTY
54096: LIST
54097: LIST
54098: LIST
54099: LIST
54100: ST_TO_ADDR
54101: GO 54284
54103: LD_INT 51
54105: DOUBLE
54106: EQUAL
54107: IFTRUE 54111
54109: GO 54137
54111: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
54112: LD_ADDR_VAR 0 3
54116: PUSH
54117: LD_INT 21
54119: PUSH
54120: LD_INT 22
54122: PUSH
54123: LD_INT 23
54125: PUSH
54126: LD_INT 24
54128: PUSH
54129: EMPTY
54130: LIST
54131: LIST
54132: LIST
54133: LIST
54134: ST_TO_ADDR
54135: GO 54284
54137: LD_INT 52
54139: DOUBLE
54140: EQUAL
54141: IFTRUE 54145
54143: GO 54171
54145: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
54146: LD_ADDR_VAR 0 3
54150: PUSH
54151: LD_INT 21
54153: PUSH
54154: LD_INT 22
54156: PUSH
54157: LD_INT 23
54159: PUSH
54160: LD_INT 24
54162: PUSH
54163: EMPTY
54164: LIST
54165: LIST
54166: LIST
54167: LIST
54168: ST_TO_ADDR
54169: GO 54284
54171: LD_INT 53
54173: DOUBLE
54174: EQUAL
54175: IFTRUE 54179
54177: GO 54197
54179: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
54180: LD_ADDR_VAR 0 3
54184: PUSH
54185: LD_INT 23
54187: PUSH
54188: LD_INT 24
54190: PUSH
54191: EMPTY
54192: LIST
54193: LIST
54194: ST_TO_ADDR
54195: GO 54284
54197: LD_INT 46
54199: DOUBLE
54200: EQUAL
54201: IFTRUE 54205
54203: GO 54223
54205: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
54206: LD_ADDR_VAR 0 3
54210: PUSH
54211: LD_INT 23
54213: PUSH
54214: LD_INT 24
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: ST_TO_ADDR
54221: GO 54284
54223: LD_INT 47
54225: DOUBLE
54226: EQUAL
54227: IFTRUE 54231
54229: GO 54249
54231: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_radar :
54232: LD_ADDR_VAR 0 3
54236: PUSH
54237: LD_INT 23
54239: PUSH
54240: LD_INT 24
54242: PUSH
54243: EMPTY
54244: LIST
54245: LIST
54246: ST_TO_ADDR
54247: GO 54284
54249: LD_INT 98
54251: DOUBLE
54252: EQUAL
54253: IFTRUE 54257
54255: GO 54283
54257: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54258: LD_ADDR_VAR 0 3
54262: PUSH
54263: LD_INT 21
54265: PUSH
54266: LD_INT 22
54268: PUSH
54269: LD_INT 23
54271: PUSH
54272: LD_INT 24
54274: PUSH
54275: EMPTY
54276: LIST
54277: LIST
54278: LIST
54279: LIST
54280: ST_TO_ADDR
54281: GO 54284
54283: POP
// result := ( chassis in result ) ;
54284: LD_ADDR_VAR 0 3
54288: PUSH
54289: LD_VAR 0 1
54293: PUSH
54294: LD_VAR 0 3
54298: IN
54299: ST_TO_ADDR
// end ;
54300: LD_VAR 0 3
54304: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
54305: LD_INT 0
54307: PPUSH
54308: PPUSH
54309: PPUSH
54310: PPUSH
54311: PPUSH
54312: PPUSH
54313: PPUSH
// result := array ;
54314: LD_ADDR_VAR 0 5
54318: PUSH
54319: LD_VAR 0 1
54323: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
54324: LD_VAR 0 1
54328: NOT
54329: IFTRUE 54338
54331: PUSH
54332: LD_VAR 0 2
54336: NOT
54337: OR
54338: IFTRUE 54347
54340: PUSH
54341: LD_VAR 0 3
54345: NOT
54346: OR
54347: IFTRUE 54361
54349: PUSH
54350: LD_VAR 0 2
54354: PUSH
54355: LD_VAR 0 1
54359: GREATER
54360: OR
54361: IFTRUE 54375
54363: PUSH
54364: LD_VAR 0 3
54368: PUSH
54369: LD_VAR 0 1
54373: GREATER
54374: OR
54375: IFFALSE 54379
// exit ;
54377: GO 54675
// if direction then
54379: LD_VAR 0 4
54383: IFFALSE 54447
// begin d := 1 ;
54385: LD_ADDR_VAR 0 9
54389: PUSH
54390: LD_INT 1
54392: ST_TO_ADDR
// if i_from > i_to then
54393: LD_VAR 0 2
54397: PUSH
54398: LD_VAR 0 3
54402: GREATER
54403: IFFALSE 54429
// length := ( array - i_from ) + i_to else
54405: LD_ADDR_VAR 0 11
54409: PUSH
54410: LD_VAR 0 1
54414: PUSH
54415: LD_VAR 0 2
54419: MINUS
54420: PUSH
54421: LD_VAR 0 3
54425: PLUS
54426: ST_TO_ADDR
54427: GO 54445
// length := i_to - i_from ;
54429: LD_ADDR_VAR 0 11
54433: PUSH
54434: LD_VAR 0 3
54438: PUSH
54439: LD_VAR 0 2
54443: MINUS
54444: ST_TO_ADDR
// end else
54445: GO 54508
// begin d := - 1 ;
54447: LD_ADDR_VAR 0 9
54451: PUSH
54452: LD_INT 1
54454: NEG
54455: ST_TO_ADDR
// if i_from > i_to then
54456: LD_VAR 0 2
54460: PUSH
54461: LD_VAR 0 3
54465: GREATER
54466: IFFALSE 54486
// length := i_from - i_to else
54468: LD_ADDR_VAR 0 11
54472: PUSH
54473: LD_VAR 0 2
54477: PUSH
54478: LD_VAR 0 3
54482: MINUS
54483: ST_TO_ADDR
54484: GO 54508
// length := ( array - i_to ) + i_from ;
54486: LD_ADDR_VAR 0 11
54490: PUSH
54491: LD_VAR 0 1
54495: PUSH
54496: LD_VAR 0 3
54500: MINUS
54501: PUSH
54502: LD_VAR 0 2
54506: PLUS
54507: ST_TO_ADDR
// end ; if not length then
54508: LD_VAR 0 11
54512: NOT
54513: IFFALSE 54517
// exit ;
54515: GO 54675
// tmp := array ;
54517: LD_ADDR_VAR 0 10
54521: PUSH
54522: LD_VAR 0 1
54526: ST_TO_ADDR
// for i = 1 to length do
54527: LD_ADDR_VAR 0 6
54531: PUSH
54532: DOUBLE
54533: LD_INT 1
54535: DEC
54536: ST_TO_ADDR
54537: LD_VAR 0 11
54541: PUSH
54542: FOR_TO
54543: IFFALSE 54663
// begin for j = 1 to array do
54545: LD_ADDR_VAR 0 7
54549: PUSH
54550: DOUBLE
54551: LD_INT 1
54553: DEC
54554: ST_TO_ADDR
54555: LD_VAR 0 1
54559: PUSH
54560: FOR_TO
54561: IFFALSE 54649
// begin k := j + d ;
54563: LD_ADDR_VAR 0 8
54567: PUSH
54568: LD_VAR 0 7
54572: PUSH
54573: LD_VAR 0 9
54577: PLUS
54578: ST_TO_ADDR
// if k > array then
54579: LD_VAR 0 8
54583: PUSH
54584: LD_VAR 0 1
54588: GREATER
54589: IFFALSE 54599
// k := 1 ;
54591: LD_ADDR_VAR 0 8
54595: PUSH
54596: LD_INT 1
54598: ST_TO_ADDR
// if not k then
54599: LD_VAR 0 8
54603: NOT
54604: IFFALSE 54616
// k := array ;
54606: LD_ADDR_VAR 0 8
54610: PUSH
54611: LD_VAR 0 1
54615: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
54616: LD_ADDR_VAR 0 10
54620: PUSH
54621: LD_VAR 0 10
54625: PPUSH
54626: LD_VAR 0 8
54630: PPUSH
54631: LD_VAR 0 1
54635: PUSH
54636: LD_VAR 0 7
54640: ARRAY
54641: PPUSH
54642: CALL_OW 1
54646: ST_TO_ADDR
// end ;
54647: GO 54560
54649: POP
54650: POP
// array := tmp ;
54651: LD_ADDR_VAR 0 1
54655: PUSH
54656: LD_VAR 0 10
54660: ST_TO_ADDR
// end ;
54661: GO 54542
54663: POP
54664: POP
// result := array ;
54665: LD_ADDR_VAR 0 5
54669: PUSH
54670: LD_VAR 0 1
54674: ST_TO_ADDR
// end ;
54675: LD_VAR 0 5
54679: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
54680: LD_INT 0
54682: PPUSH
54683: PPUSH
// result := 0 ;
54684: LD_ADDR_VAR 0 3
54688: PUSH
54689: LD_INT 0
54691: ST_TO_ADDR
// if not array or not value in array then
54692: LD_VAR 0 1
54696: NOT
54697: IFTRUE 54712
54699: PUSH
54700: LD_VAR 0 2
54704: PUSH
54705: LD_VAR 0 1
54709: IN
54710: NOT
54711: OR
54712: IFFALSE 54716
// exit ;
54714: GO 54770
// for i = 1 to array do
54716: LD_ADDR_VAR 0 4
54720: PUSH
54721: DOUBLE
54722: LD_INT 1
54724: DEC
54725: ST_TO_ADDR
54726: LD_VAR 0 1
54730: PUSH
54731: FOR_TO
54732: IFFALSE 54768
// if value = array [ i ] then
54734: LD_VAR 0 2
54738: PUSH
54739: LD_VAR 0 1
54743: PUSH
54744: LD_VAR 0 4
54748: ARRAY
54749: EQUAL
54750: IFFALSE 54766
// begin result := i ;
54752: LD_ADDR_VAR 0 3
54756: PUSH
54757: LD_VAR 0 4
54761: ST_TO_ADDR
// exit ;
54762: POP
54763: POP
54764: GO 54770
// end ;
54766: GO 54731
54768: POP
54769: POP
// end ;
54770: LD_VAR 0 3
54774: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54775: LD_INT 0
54777: PPUSH
// vc_chassis := chassis ;
54778: LD_ADDR_OWVAR 37
54782: PUSH
54783: LD_VAR 0 1
54787: ST_TO_ADDR
// vc_engine := engine ;
54788: LD_ADDR_OWVAR 39
54792: PUSH
54793: LD_VAR 0 2
54797: ST_TO_ADDR
// vc_control := control ;
54798: LD_ADDR_OWVAR 38
54802: PUSH
54803: LD_VAR 0 3
54807: ST_TO_ADDR
// vc_weapon := weapon ;
54808: LD_ADDR_OWVAR 40
54812: PUSH
54813: LD_VAR 0 4
54817: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54818: LD_ADDR_OWVAR 41
54822: PUSH
54823: LD_VAR 0 5
54827: ST_TO_ADDR
// end ;
54828: LD_VAR 0 6
54832: RET
// export function WantPlant ( unit ) ; var task ; begin
54833: LD_INT 0
54835: PPUSH
54836: PPUSH
// result := false ;
54837: LD_ADDR_VAR 0 2
54841: PUSH
54842: LD_INT 0
54844: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54845: LD_ADDR_VAR 0 3
54849: PUSH
54850: LD_VAR 0 1
54854: PPUSH
54855: CALL_OW 437
54859: ST_TO_ADDR
// if task then
54860: LD_VAR 0 3
54864: IFFALSE 54892
// if task [ 1 ] [ 1 ] = p then
54866: LD_VAR 0 3
54870: PUSH
54871: LD_INT 1
54873: ARRAY
54874: PUSH
54875: LD_INT 1
54877: ARRAY
54878: PUSH
54879: LD_STRING p
54881: EQUAL
54882: IFFALSE 54892
// result := true ;
54884: LD_ADDR_VAR 0 2
54888: PUSH
54889: LD_INT 1
54891: ST_TO_ADDR
// end ;
54892: LD_VAR 0 2
54896: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54897: LD_INT 0
54899: PPUSH
54900: PPUSH
54901: PPUSH
54902: PPUSH
// if pos < 1 then
54903: LD_VAR 0 2
54907: PUSH
54908: LD_INT 1
54910: LESS
54911: IFFALSE 54915
// exit ;
54913: GO 55218
// if pos = 1 then
54915: LD_VAR 0 2
54919: PUSH
54920: LD_INT 1
54922: EQUAL
54923: IFFALSE 54956
// result := Replace ( arr , pos [ 1 ] , value ) else
54925: LD_ADDR_VAR 0 4
54929: PUSH
54930: LD_VAR 0 1
54934: PPUSH
54935: LD_VAR 0 2
54939: PUSH
54940: LD_INT 1
54942: ARRAY
54943: PPUSH
54944: LD_VAR 0 3
54948: PPUSH
54949: CALL_OW 1
54953: ST_TO_ADDR
54954: GO 55218
// begin tmp := arr ;
54956: LD_ADDR_VAR 0 6
54960: PUSH
54961: LD_VAR 0 1
54965: ST_TO_ADDR
// s_arr := [ tmp ] ;
54966: LD_ADDR_VAR 0 7
54970: PUSH
54971: LD_VAR 0 6
54975: PUSH
54976: EMPTY
54977: LIST
54978: ST_TO_ADDR
// for i = 1 to pos - 1 do
54979: LD_ADDR_VAR 0 5
54983: PUSH
54984: DOUBLE
54985: LD_INT 1
54987: DEC
54988: ST_TO_ADDR
54989: LD_VAR 0 2
54993: PUSH
54994: LD_INT 1
54996: MINUS
54997: PUSH
54998: FOR_TO
54999: IFFALSE 55044
// begin tmp := tmp [ pos [ i ] ] ;
55001: LD_ADDR_VAR 0 6
55005: PUSH
55006: LD_VAR 0 6
55010: PUSH
55011: LD_VAR 0 2
55015: PUSH
55016: LD_VAR 0 5
55020: ARRAY
55021: ARRAY
55022: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55023: LD_ADDR_VAR 0 7
55027: PUSH
55028: LD_VAR 0 7
55032: PUSH
55033: LD_VAR 0 6
55037: PUSH
55038: EMPTY
55039: LIST
55040: ADD
55041: ST_TO_ADDR
// end ;
55042: GO 54998
55044: POP
55045: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55046: LD_ADDR_VAR 0 6
55050: PUSH
55051: LD_VAR 0 6
55055: PPUSH
55056: LD_VAR 0 2
55060: PUSH
55061: LD_VAR 0 2
55065: ARRAY
55066: PPUSH
55067: LD_VAR 0 3
55071: PPUSH
55072: CALL_OW 1
55076: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55077: LD_ADDR_VAR 0 7
55081: PUSH
55082: LD_VAR 0 7
55086: PPUSH
55087: LD_VAR 0 7
55091: PPUSH
55092: LD_VAR 0 6
55096: PPUSH
55097: CALL_OW 1
55101: ST_TO_ADDR
// for i = s_arr downto 2 do
55102: LD_ADDR_VAR 0 5
55106: PUSH
55107: DOUBLE
55108: LD_VAR 0 7
55112: INC
55113: ST_TO_ADDR
55114: LD_INT 2
55116: PUSH
55117: FOR_DOWNTO
55118: IFFALSE 55202
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
55120: LD_ADDR_VAR 0 6
55124: PUSH
55125: LD_VAR 0 7
55129: PUSH
55130: LD_VAR 0 5
55134: PUSH
55135: LD_INT 1
55137: MINUS
55138: ARRAY
55139: PPUSH
55140: LD_VAR 0 2
55144: PUSH
55145: LD_VAR 0 5
55149: PUSH
55150: LD_INT 1
55152: MINUS
55153: ARRAY
55154: PPUSH
55155: LD_VAR 0 7
55159: PUSH
55160: LD_VAR 0 5
55164: ARRAY
55165: PPUSH
55166: CALL_OW 1
55170: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
55171: LD_ADDR_VAR 0 7
55175: PUSH
55176: LD_VAR 0 7
55180: PPUSH
55181: LD_VAR 0 5
55185: PUSH
55186: LD_INT 1
55188: MINUS
55189: PPUSH
55190: LD_VAR 0 6
55194: PPUSH
55195: CALL_OW 1
55199: ST_TO_ADDR
// end ;
55200: GO 55117
55202: POP
55203: POP
// result := s_arr [ 1 ] ;
55204: LD_ADDR_VAR 0 4
55208: PUSH
55209: LD_VAR 0 7
55213: PUSH
55214: LD_INT 1
55216: ARRAY
55217: ST_TO_ADDR
// end ; end ;
55218: LD_VAR 0 4
55222: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
55223: LD_INT 0
55225: PPUSH
55226: PPUSH
// if not list then
55227: LD_VAR 0 1
55231: NOT
55232: IFFALSE 55236
// exit ;
55234: GO 55327
// i := list [ pos1 ] ;
55236: LD_ADDR_VAR 0 5
55240: PUSH
55241: LD_VAR 0 1
55245: PUSH
55246: LD_VAR 0 2
55250: ARRAY
55251: ST_TO_ADDR
// if not i then
55252: LD_VAR 0 5
55256: NOT
55257: IFFALSE 55261
// exit ;
55259: GO 55327
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
55261: LD_ADDR_VAR 0 1
55265: PUSH
55266: LD_VAR 0 1
55270: PPUSH
55271: LD_VAR 0 2
55275: PPUSH
55276: LD_VAR 0 1
55280: PUSH
55281: LD_VAR 0 3
55285: ARRAY
55286: PPUSH
55287: CALL_OW 1
55291: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
55292: LD_ADDR_VAR 0 1
55296: PUSH
55297: LD_VAR 0 1
55301: PPUSH
55302: LD_VAR 0 3
55306: PPUSH
55307: LD_VAR 0 5
55311: PPUSH
55312: CALL_OW 1
55316: ST_TO_ADDR
// result := list ;
55317: LD_ADDR_VAR 0 4
55321: PUSH
55322: LD_VAR 0 1
55326: ST_TO_ADDR
// end ;
55327: LD_VAR 0 4
55331: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
55332: LD_INT 0
55334: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
55335: LD_ADDR_VAR 0 5
55339: PUSH
55340: LD_VAR 0 1
55344: PPUSH
55345: CALL_OW 250
55349: PPUSH
55350: LD_VAR 0 1
55354: PPUSH
55355: CALL_OW 251
55359: PPUSH
55360: LD_VAR 0 2
55364: PPUSH
55365: LD_VAR 0 3
55369: PPUSH
55370: LD_VAR 0 4
55374: PPUSH
55375: CALL 55757 0 5
55379: ST_TO_ADDR
// end ;
55380: LD_VAR 0 5
55384: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
55385: LD_INT 0
55387: PPUSH
55388: PPUSH
55389: PPUSH
55390: PPUSH
// if not list or not unit then
55391: LD_VAR 0 2
55395: NOT
55396: IFTRUE 55405
55398: PUSH
55399: LD_VAR 0 1
55403: NOT
55404: OR
55405: IFFALSE 55409
// exit ;
55407: GO 55752
// result := [ ] ;
55409: LD_ADDR_VAR 0 5
55413: PUSH
55414: EMPTY
55415: ST_TO_ADDR
// for i in list do
55416: LD_ADDR_VAR 0 6
55420: PUSH
55421: LD_VAR 0 2
55425: PUSH
55426: FOR_IN
55427: IFFALSE 55645
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55429: LD_ADDR_VAR 0 8
55433: PUSH
55434: LD_VAR 0 1
55438: PPUSH
55439: LD_VAR 0 6
55443: PUSH
55444: LD_INT 1
55446: ARRAY
55447: PPUSH
55448: LD_VAR 0 6
55452: PUSH
55453: LD_INT 2
55455: ARRAY
55456: PPUSH
55457: CALL_OW 297
55461: ST_TO_ADDR
// if not Count ( result ) then
55462: LD_VAR 0 5
55466: PPUSH
55467: CALL 51979 0 1
55471: NOT
55472: IFFALSE 55505
// begin result := Join ( result , [ i , tmp ] ) ;
55474: LD_ADDR_VAR 0 5
55478: PUSH
55479: LD_VAR 0 5
55483: PPUSH
55484: LD_VAR 0 6
55488: PUSH
55489: LD_VAR 0 8
55493: PUSH
55494: EMPTY
55495: LIST
55496: LIST
55497: PPUSH
55498: CALL 87955 0 2
55502: ST_TO_ADDR
// continue ;
55503: GO 55426
// end ; if result [ result ] [ 2 ] <= tmp then
55505: LD_VAR 0 5
55509: PUSH
55510: LD_VAR 0 5
55514: ARRAY
55515: PUSH
55516: LD_INT 2
55518: ARRAY
55519: PUSH
55520: LD_VAR 0 8
55524: LESSEQUAL
55525: IFFALSE 55558
// result := Join ( result , [ i , tmp ] ) else
55527: LD_ADDR_VAR 0 5
55531: PUSH
55532: LD_VAR 0 5
55536: PPUSH
55537: LD_VAR 0 6
55541: PUSH
55542: LD_VAR 0 8
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: PPUSH
55551: CALL 87955 0 2
55555: ST_TO_ADDR
55556: GO 55643
// begin for j := 1 to Count ( result ) do
55558: LD_ADDR_VAR 0 7
55562: PUSH
55563: DOUBLE
55564: LD_INT 1
55566: DEC
55567: ST_TO_ADDR
55568: LD_VAR 0 5
55572: PPUSH
55573: CALL 51979 0 1
55577: PUSH
55578: FOR_TO
55579: IFFALSE 55641
// begin if tmp < result [ j ] [ 2 ] then
55581: LD_VAR 0 8
55585: PUSH
55586: LD_VAR 0 5
55590: PUSH
55591: LD_VAR 0 7
55595: ARRAY
55596: PUSH
55597: LD_INT 2
55599: ARRAY
55600: LESS
55601: IFFALSE 55639
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55603: LD_ADDR_VAR 0 5
55607: PUSH
55608: LD_VAR 0 5
55612: PPUSH
55613: LD_VAR 0 7
55617: PPUSH
55618: LD_VAR 0 6
55622: PUSH
55623: LD_VAR 0 8
55627: PUSH
55628: EMPTY
55629: LIST
55630: LIST
55631: PPUSH
55632: CALL_OW 2
55636: ST_TO_ADDR
// break ;
55637: GO 55641
// end ; end ;
55639: GO 55578
55641: POP
55642: POP
// end ; end ;
55643: GO 55426
55645: POP
55646: POP
// if result and not asc then
55647: LD_VAR 0 5
55651: IFFALSE 55660
55653: PUSH
55654: LD_VAR 0 3
55658: NOT
55659: AND
55660: IFFALSE 55677
// result := ReverseArray ( result ) ;
55662: LD_ADDR_VAR 0 5
55666: PUSH
55667: LD_VAR 0 5
55671: PPUSH
55672: CALL 83035 0 1
55676: ST_TO_ADDR
// tmp := [ ] ;
55677: LD_ADDR_VAR 0 8
55681: PUSH
55682: EMPTY
55683: ST_TO_ADDR
// if mode then
55684: LD_VAR 0 4
55688: IFFALSE 55752
// begin for i := 1 to result do
55690: LD_ADDR_VAR 0 6
55694: PUSH
55695: DOUBLE
55696: LD_INT 1
55698: DEC
55699: ST_TO_ADDR
55700: LD_VAR 0 5
55704: PUSH
55705: FOR_TO
55706: IFFALSE 55740
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
55708: LD_ADDR_VAR 0 8
55712: PUSH
55713: LD_VAR 0 8
55717: PPUSH
55718: LD_VAR 0 5
55722: PUSH
55723: LD_VAR 0 6
55727: ARRAY
55728: PUSH
55729: LD_INT 1
55731: ARRAY
55732: PPUSH
55733: CALL 87955 0 2
55737: ST_TO_ADDR
55738: GO 55705
55740: POP
55741: POP
// result := tmp ;
55742: LD_ADDR_VAR 0 5
55746: PUSH
55747: LD_VAR 0 8
55751: ST_TO_ADDR
// end ; end ;
55752: LD_VAR 0 5
55756: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
55757: LD_INT 0
55759: PPUSH
55760: PPUSH
55761: PPUSH
55762: PPUSH
// if not list then
55763: LD_VAR 0 3
55767: NOT
55768: IFFALSE 55772
// exit ;
55770: GO 56162
// result := [ ] ;
55772: LD_ADDR_VAR 0 6
55776: PUSH
55777: EMPTY
55778: ST_TO_ADDR
// for i in list do
55779: LD_ADDR_VAR 0 7
55783: PUSH
55784: LD_VAR 0 3
55788: PUSH
55789: FOR_IN
55790: IFFALSE 55992
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55792: LD_ADDR_VAR 0 9
55796: PUSH
55797: LD_VAR 0 7
55801: PPUSH
55802: LD_VAR 0 1
55806: PPUSH
55807: LD_VAR 0 2
55811: PPUSH
55812: CALL_OW 297
55816: ST_TO_ADDR
// if not result then
55817: LD_VAR 0 6
55821: NOT
55822: IFFALSE 55848
// result := [ [ i , tmp ] ] else
55824: LD_ADDR_VAR 0 6
55828: PUSH
55829: LD_VAR 0 7
55833: PUSH
55834: LD_VAR 0 9
55838: PUSH
55839: EMPTY
55840: LIST
55841: LIST
55842: PUSH
55843: EMPTY
55844: LIST
55845: ST_TO_ADDR
55846: GO 55990
// begin if result [ result ] [ 2 ] <= tmp then
55848: LD_VAR 0 6
55852: PUSH
55853: LD_VAR 0 6
55857: ARRAY
55858: PUSH
55859: LD_INT 2
55861: ARRAY
55862: PUSH
55863: LD_VAR 0 9
55867: LESSEQUAL
55868: IFFALSE 55910
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55870: LD_ADDR_VAR 0 6
55874: PUSH
55875: LD_VAR 0 6
55879: PPUSH
55880: LD_VAR 0 6
55884: PUSH
55885: LD_INT 1
55887: PLUS
55888: PPUSH
55889: LD_VAR 0 7
55893: PUSH
55894: LD_VAR 0 9
55898: PUSH
55899: EMPTY
55900: LIST
55901: LIST
55902: PPUSH
55903: CALL_OW 2
55907: ST_TO_ADDR
55908: GO 55990
// for j := 1 to result do
55910: LD_ADDR_VAR 0 8
55914: PUSH
55915: DOUBLE
55916: LD_INT 1
55918: DEC
55919: ST_TO_ADDR
55920: LD_VAR 0 6
55924: PUSH
55925: FOR_TO
55926: IFFALSE 55988
// begin if tmp < result [ j ] [ 2 ] then
55928: LD_VAR 0 9
55932: PUSH
55933: LD_VAR 0 6
55937: PUSH
55938: LD_VAR 0 8
55942: ARRAY
55943: PUSH
55944: LD_INT 2
55946: ARRAY
55947: LESS
55948: IFFALSE 55986
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55950: LD_ADDR_VAR 0 6
55954: PUSH
55955: LD_VAR 0 6
55959: PPUSH
55960: LD_VAR 0 8
55964: PPUSH
55965: LD_VAR 0 7
55969: PUSH
55970: LD_VAR 0 9
55974: PUSH
55975: EMPTY
55976: LIST
55977: LIST
55978: PPUSH
55979: CALL_OW 2
55983: ST_TO_ADDR
// break ;
55984: GO 55988
// end ; end ;
55986: GO 55925
55988: POP
55989: POP
// end ; end ;
55990: GO 55789
55992: POP
55993: POP
// if result and not asc then
55994: LD_VAR 0 6
55998: IFFALSE 56007
56000: PUSH
56001: LD_VAR 0 4
56005: NOT
56006: AND
56007: IFFALSE 56082
// begin tmp := result ;
56009: LD_ADDR_VAR 0 9
56013: PUSH
56014: LD_VAR 0 6
56018: ST_TO_ADDR
// for i = tmp downto 1 do
56019: LD_ADDR_VAR 0 7
56023: PUSH
56024: DOUBLE
56025: LD_VAR 0 9
56029: INC
56030: ST_TO_ADDR
56031: LD_INT 1
56033: PUSH
56034: FOR_DOWNTO
56035: IFFALSE 56080
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56037: LD_ADDR_VAR 0 6
56041: PUSH
56042: LD_VAR 0 6
56046: PPUSH
56047: LD_VAR 0 9
56051: PUSH
56052: LD_VAR 0 7
56056: MINUS
56057: PUSH
56058: LD_INT 1
56060: PLUS
56061: PPUSH
56062: LD_VAR 0 9
56066: PUSH
56067: LD_VAR 0 7
56071: ARRAY
56072: PPUSH
56073: CALL_OW 1
56077: ST_TO_ADDR
56078: GO 56034
56080: POP
56081: POP
// end ; tmp := [ ] ;
56082: LD_ADDR_VAR 0 9
56086: PUSH
56087: EMPTY
56088: ST_TO_ADDR
// if mode then
56089: LD_VAR 0 5
56093: IFFALSE 56162
// begin for i = 1 to result do
56095: LD_ADDR_VAR 0 7
56099: PUSH
56100: DOUBLE
56101: LD_INT 1
56103: DEC
56104: ST_TO_ADDR
56105: LD_VAR 0 6
56109: PUSH
56110: FOR_TO
56111: IFFALSE 56150
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56113: LD_ADDR_VAR 0 9
56117: PUSH
56118: LD_VAR 0 9
56122: PPUSH
56123: LD_VAR 0 7
56127: PPUSH
56128: LD_VAR 0 6
56132: PUSH
56133: LD_VAR 0 7
56137: ARRAY
56138: PUSH
56139: LD_INT 1
56141: ARRAY
56142: PPUSH
56143: CALL_OW 1
56147: ST_TO_ADDR
56148: GO 56110
56150: POP
56151: POP
// result := tmp ;
56152: LD_ADDR_VAR 0 6
56156: PUSH
56157: LD_VAR 0 9
56161: ST_TO_ADDR
// end ; end ;
56162: LD_VAR 0 6
56166: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56167: LD_INT 0
56169: PPUSH
56170: PPUSH
56171: PPUSH
56172: PPUSH
56173: PPUSH
56174: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56175: LD_ADDR_VAR 0 5
56179: PUSH
56180: LD_INT 0
56182: PUSH
56183: LD_INT 0
56185: PUSH
56186: LD_INT 0
56188: PUSH
56189: EMPTY
56190: PUSH
56191: EMPTY
56192: LIST
56193: LIST
56194: LIST
56195: LIST
56196: ST_TO_ADDR
// if not x or not y then
56197: LD_VAR 0 2
56201: NOT
56202: IFTRUE 56211
56204: PUSH
56205: LD_VAR 0 3
56209: NOT
56210: OR
56211: IFFALSE 56215
// exit ;
56213: GO 57871
// if not range then
56215: LD_VAR 0 4
56219: NOT
56220: IFFALSE 56230
// range := 10 ;
56222: LD_ADDR_VAR 0 4
56226: PUSH
56227: LD_INT 10
56229: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56230: LD_ADDR_VAR 0 8
56234: PUSH
56235: LD_INT 81
56237: PUSH
56238: LD_VAR 0 1
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PUSH
56247: LD_INT 92
56249: PUSH
56250: LD_VAR 0 2
56254: PUSH
56255: LD_VAR 0 3
56259: PUSH
56260: LD_VAR 0 4
56264: PUSH
56265: EMPTY
56266: LIST
56267: LIST
56268: LIST
56269: LIST
56270: PUSH
56271: LD_INT 3
56273: PUSH
56274: LD_INT 21
56276: PUSH
56277: LD_INT 3
56279: PUSH
56280: EMPTY
56281: LIST
56282: LIST
56283: PUSH
56284: EMPTY
56285: LIST
56286: LIST
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: LIST
56292: PPUSH
56293: CALL_OW 69
56297: ST_TO_ADDR
// if not tmp then
56298: LD_VAR 0 8
56302: NOT
56303: IFFALSE 56307
// exit ;
56305: GO 57871
// for i in tmp do
56307: LD_ADDR_VAR 0 6
56311: PUSH
56312: LD_VAR 0 8
56316: PUSH
56317: FOR_IN
56318: IFFALSE 57846
// begin points := [ 0 , 0 , 0 ] ;
56320: LD_ADDR_VAR 0 9
56324: PUSH
56325: LD_INT 0
56327: PUSH
56328: LD_INT 0
56330: PUSH
56331: LD_INT 0
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: LIST
56338: ST_TO_ADDR
// bpoints := 1 ;
56339: LD_ADDR_VAR 0 10
56343: PUSH
56344: LD_INT 1
56346: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56347: LD_VAR 0 6
56351: PPUSH
56352: CALL_OW 247
56356: PUSH
56357: LD_INT 1
56359: DOUBLE
56360: EQUAL
56361: IFTRUE 56365
56363: GO 56947
56365: POP
// begin if GetClass ( i ) = 1 then
56366: LD_VAR 0 6
56370: PPUSH
56371: CALL_OW 257
56375: PUSH
56376: LD_INT 1
56378: EQUAL
56379: IFFALSE 56400
// points := [ 10 , 5 , 3 ] ;
56381: LD_ADDR_VAR 0 9
56385: PUSH
56386: LD_INT 10
56388: PUSH
56389: LD_INT 5
56391: PUSH
56392: LD_INT 3
56394: PUSH
56395: EMPTY
56396: LIST
56397: LIST
56398: LIST
56399: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56400: LD_VAR 0 6
56404: PPUSH
56405: CALL_OW 257
56409: PUSH
56410: LD_INT 2
56412: PUSH
56413: LD_INT 3
56415: PUSH
56416: LD_INT 4
56418: PUSH
56419: EMPTY
56420: LIST
56421: LIST
56422: LIST
56423: IN
56424: IFFALSE 56445
// points := [ 3 , 2 , 1 ] ;
56426: LD_ADDR_VAR 0 9
56430: PUSH
56431: LD_INT 3
56433: PUSH
56434: LD_INT 2
56436: PUSH
56437: LD_INT 1
56439: PUSH
56440: EMPTY
56441: LIST
56442: LIST
56443: LIST
56444: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56445: LD_VAR 0 6
56449: PPUSH
56450: CALL_OW 257
56454: PUSH
56455: LD_INT 5
56457: EQUAL
56458: IFFALSE 56479
// points := [ 130 , 5 , 2 ] ;
56460: LD_ADDR_VAR 0 9
56464: PUSH
56465: LD_INT 130
56467: PUSH
56468: LD_INT 5
56470: PUSH
56471: LD_INT 2
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: LIST
56478: ST_TO_ADDR
// if GetClass ( i ) = 8 then
56479: LD_VAR 0 6
56483: PPUSH
56484: CALL_OW 257
56488: PUSH
56489: LD_INT 8
56491: EQUAL
56492: IFFALSE 56513
// points := [ 35 , 35 , 30 ] ;
56494: LD_ADDR_VAR 0 9
56498: PUSH
56499: LD_INT 35
56501: PUSH
56502: LD_INT 35
56504: PUSH
56505: LD_INT 30
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: LIST
56512: ST_TO_ADDR
// if GetClass ( i ) = 9 then
56513: LD_VAR 0 6
56517: PPUSH
56518: CALL_OW 257
56522: PUSH
56523: LD_INT 9
56525: EQUAL
56526: IFFALSE 56547
// points := [ 20 , 55 , 40 ] ;
56528: LD_ADDR_VAR 0 9
56532: PUSH
56533: LD_INT 20
56535: PUSH
56536: LD_INT 55
56538: PUSH
56539: LD_INT 40
56541: PUSH
56542: EMPTY
56543: LIST
56544: LIST
56545: LIST
56546: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
56547: LD_VAR 0 6
56551: PPUSH
56552: CALL_OW 257
56556: PUSH
56557: LD_INT 12
56559: PUSH
56560: LD_INT 16
56562: PUSH
56563: EMPTY
56564: LIST
56565: LIST
56566: IN
56567: IFFALSE 56588
// points := [ 5 , 3 , 2 ] ;
56569: LD_ADDR_VAR 0 9
56573: PUSH
56574: LD_INT 5
56576: PUSH
56577: LD_INT 3
56579: PUSH
56580: LD_INT 2
56582: PUSH
56583: EMPTY
56584: LIST
56585: LIST
56586: LIST
56587: ST_TO_ADDR
// if GetClass ( i ) = 17 then
56588: LD_VAR 0 6
56592: PPUSH
56593: CALL_OW 257
56597: PUSH
56598: LD_INT 17
56600: EQUAL
56601: IFFALSE 56622
// points := [ 100 , 50 , 75 ] ;
56603: LD_ADDR_VAR 0 9
56607: PUSH
56608: LD_INT 100
56610: PUSH
56611: LD_INT 50
56613: PUSH
56614: LD_INT 75
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: LIST
56621: ST_TO_ADDR
// if GetClass ( i ) = 15 then
56622: LD_VAR 0 6
56626: PPUSH
56627: CALL_OW 257
56631: PUSH
56632: LD_INT 15
56634: EQUAL
56635: IFFALSE 56656
// points := [ 10 , 5 , 3 ] ;
56637: LD_ADDR_VAR 0 9
56641: PUSH
56642: LD_INT 10
56644: PUSH
56645: LD_INT 5
56647: PUSH
56648: LD_INT 3
56650: PUSH
56651: EMPTY
56652: LIST
56653: LIST
56654: LIST
56655: ST_TO_ADDR
// if GetClass ( i ) = 14 then
56656: LD_VAR 0 6
56660: PPUSH
56661: CALL_OW 257
56665: PUSH
56666: LD_INT 14
56668: EQUAL
56669: IFFALSE 56690
// points := [ 10 , 0 , 0 ] ;
56671: LD_ADDR_VAR 0 9
56675: PUSH
56676: LD_INT 10
56678: PUSH
56679: LD_INT 0
56681: PUSH
56682: LD_INT 0
56684: PUSH
56685: EMPTY
56686: LIST
56687: LIST
56688: LIST
56689: ST_TO_ADDR
// if GetClass ( i ) = 11 then
56690: LD_VAR 0 6
56694: PPUSH
56695: CALL_OW 257
56699: PUSH
56700: LD_INT 11
56702: EQUAL
56703: IFFALSE 56724
// points := [ 30 , 10 , 5 ] ;
56705: LD_ADDR_VAR 0 9
56709: PUSH
56710: LD_INT 30
56712: PUSH
56713: LD_INT 10
56715: PUSH
56716: LD_INT 5
56718: PUSH
56719: EMPTY
56720: LIST
56721: LIST
56722: LIST
56723: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
56724: LD_VAR 0 1
56728: PPUSH
56729: LD_INT 5
56731: PPUSH
56732: CALL_OW 321
56736: PUSH
56737: LD_INT 2
56739: EQUAL
56740: IFFALSE 56757
// bpoints := bpoints * 1.8 ;
56742: LD_ADDR_VAR 0 10
56746: PUSH
56747: LD_VAR 0 10
56751: PUSH
56752: LD_REAL  1.80000000000000E+0000
56755: MUL
56756: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
56757: LD_VAR 0 6
56761: PPUSH
56762: CALL_OW 257
56766: PUSH
56767: LD_INT 1
56769: PUSH
56770: LD_INT 2
56772: PUSH
56773: LD_INT 3
56775: PUSH
56776: LD_INT 4
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: LIST
56783: LIST
56784: IN
56785: IFFALSE 56805
56787: PUSH
56788: LD_VAR 0 1
56792: PPUSH
56793: LD_INT 51
56795: PPUSH
56796: CALL_OW 321
56800: PUSH
56801: LD_INT 2
56803: EQUAL
56804: AND
56805: IFFALSE 56822
// bpoints := bpoints * 1.2 ;
56807: LD_ADDR_VAR 0 10
56811: PUSH
56812: LD_VAR 0 10
56816: PUSH
56817: LD_REAL  1.20000000000000E+0000
56820: MUL
56821: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56822: LD_VAR 0 6
56826: PPUSH
56827: CALL_OW 257
56831: PUSH
56832: LD_INT 5
56834: PUSH
56835: LD_INT 7
56837: PUSH
56838: LD_INT 9
56840: PUSH
56841: EMPTY
56842: LIST
56843: LIST
56844: LIST
56845: IN
56846: IFFALSE 56866
56848: PUSH
56849: LD_VAR 0 1
56853: PPUSH
56854: LD_INT 52
56856: PPUSH
56857: CALL_OW 321
56861: PUSH
56862: LD_INT 2
56864: EQUAL
56865: AND
56866: IFFALSE 56883
// bpoints := bpoints * 1.5 ;
56868: LD_ADDR_VAR 0 10
56872: PUSH
56873: LD_VAR 0 10
56877: PUSH
56878: LD_REAL  1.50000000000000E+0000
56881: MUL
56882: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56883: LD_VAR 0 1
56887: PPUSH
56888: LD_INT 66
56890: PPUSH
56891: CALL_OW 321
56895: PUSH
56896: LD_INT 2
56898: EQUAL
56899: IFFALSE 56916
// bpoints := bpoints * 1.1 ;
56901: LD_ADDR_VAR 0 10
56905: PUSH
56906: LD_VAR 0 10
56910: PUSH
56911: LD_REAL  1.10000000000000E+0000
56914: MUL
56915: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56916: LD_ADDR_VAR 0 10
56920: PUSH
56921: LD_VAR 0 10
56925: PUSH
56926: LD_VAR 0 6
56930: PPUSH
56931: LD_INT 1
56933: PPUSH
56934: CALL_OW 259
56938: PUSH
56939: LD_REAL  1.15000000000000E+0000
56942: MUL
56943: MUL
56944: ST_TO_ADDR
// end ; unit_vehicle :
56945: GO 57775
56947: LD_INT 2
56949: DOUBLE
56950: EQUAL
56951: IFTRUE 56955
56953: GO 57763
56955: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56956: LD_VAR 0 6
56960: PPUSH
56961: CALL_OW 264
56965: PUSH
56966: LD_INT 2
56968: PUSH
56969: LD_INT 42
56971: PUSH
56972: LD_INT 24
56974: PUSH
56975: EMPTY
56976: LIST
56977: LIST
56978: LIST
56979: IN
56980: IFFALSE 57001
// points := [ 25 , 5 , 3 ] ;
56982: LD_ADDR_VAR 0 9
56986: PUSH
56987: LD_INT 25
56989: PUSH
56990: LD_INT 5
56992: PUSH
56993: LD_INT 3
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: LIST
57000: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57001: LD_VAR 0 6
57005: PPUSH
57006: CALL_OW 264
57010: PUSH
57011: LD_INT 4
57013: PUSH
57014: LD_INT 43
57016: PUSH
57017: LD_INT 25
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: LIST
57024: IN
57025: IFFALSE 57046
// points := [ 40 , 15 , 5 ] ;
57027: LD_ADDR_VAR 0 9
57031: PUSH
57032: LD_INT 40
57034: PUSH
57035: LD_INT 15
57037: PUSH
57038: LD_INT 5
57040: PUSH
57041: EMPTY
57042: LIST
57043: LIST
57044: LIST
57045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57046: LD_VAR 0 6
57050: PPUSH
57051: CALL_OW 264
57055: PUSH
57056: LD_INT 3
57058: PUSH
57059: LD_INT 23
57061: PUSH
57062: EMPTY
57063: LIST
57064: LIST
57065: IN
57066: IFFALSE 57087
// points := [ 7 , 25 , 8 ] ;
57068: LD_ADDR_VAR 0 9
57072: PUSH
57073: LD_INT 7
57075: PUSH
57076: LD_INT 25
57078: PUSH
57079: LD_INT 8
57081: PUSH
57082: EMPTY
57083: LIST
57084: LIST
57085: LIST
57086: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57087: LD_VAR 0 6
57091: PPUSH
57092: CALL_OW 264
57096: PUSH
57097: LD_INT 5
57099: PUSH
57100: LD_INT 27
57102: PUSH
57103: LD_INT 44
57105: PUSH
57106: EMPTY
57107: LIST
57108: LIST
57109: LIST
57110: IN
57111: IFFALSE 57132
// points := [ 14 , 50 , 16 ] ;
57113: LD_ADDR_VAR 0 9
57117: PUSH
57118: LD_INT 14
57120: PUSH
57121: LD_INT 50
57123: PUSH
57124: LD_INT 16
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: LIST
57131: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57132: LD_VAR 0 6
57136: PPUSH
57137: CALL_OW 264
57141: PUSH
57142: LD_INT 6
57144: PUSH
57145: LD_INT 46
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: IN
57152: IFFALSE 57173
// points := [ 32 , 120 , 70 ] ;
57154: LD_ADDR_VAR 0 9
57158: PUSH
57159: LD_INT 32
57161: PUSH
57162: LD_INT 120
57164: PUSH
57165: LD_INT 70
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: LIST
57172: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
57173: LD_VAR 0 6
57177: PPUSH
57178: CALL_OW 264
57182: PUSH
57183: LD_INT 7
57185: PUSH
57186: LD_INT 28
57188: PUSH
57189: LD_INT 45
57191: PUSH
57192: LD_INT 92
57194: PUSH
57195: EMPTY
57196: LIST
57197: LIST
57198: LIST
57199: LIST
57200: IN
57201: IFFALSE 57222
// points := [ 35 , 20 , 45 ] ;
57203: LD_ADDR_VAR 0 9
57207: PUSH
57208: LD_INT 35
57210: PUSH
57211: LD_INT 20
57213: PUSH
57214: LD_INT 45
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: LIST
57221: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57222: LD_VAR 0 6
57226: PPUSH
57227: CALL_OW 264
57231: PUSH
57232: LD_INT 47
57234: PUSH
57235: EMPTY
57236: LIST
57237: IN
57238: IFFALSE 57259
// points := [ 67 , 45 , 75 ] ;
57240: LD_ADDR_VAR 0 9
57244: PUSH
57245: LD_INT 67
57247: PUSH
57248: LD_INT 45
57250: PUSH
57251: LD_INT 75
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: LIST
57258: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57259: LD_VAR 0 6
57263: PPUSH
57264: CALL_OW 264
57268: PUSH
57269: LD_INT 26
57271: PUSH
57272: EMPTY
57273: LIST
57274: IN
57275: IFFALSE 57296
// points := [ 120 , 30 , 80 ] ;
57277: LD_ADDR_VAR 0 9
57281: PUSH
57282: LD_INT 120
57284: PUSH
57285: LD_INT 30
57287: PUSH
57288: LD_INT 80
57290: PUSH
57291: EMPTY
57292: LIST
57293: LIST
57294: LIST
57295: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57296: LD_VAR 0 6
57300: PPUSH
57301: CALL_OW 264
57305: PUSH
57306: LD_INT 22
57308: PUSH
57309: EMPTY
57310: LIST
57311: IN
57312: IFFALSE 57333
// points := [ 40 , 1 , 1 ] ;
57314: LD_ADDR_VAR 0 9
57318: PUSH
57319: LD_INT 40
57321: PUSH
57322: LD_INT 1
57324: PUSH
57325: LD_INT 1
57327: PUSH
57328: EMPTY
57329: LIST
57330: LIST
57331: LIST
57332: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57333: LD_VAR 0 6
57337: PPUSH
57338: CALL_OW 264
57342: PUSH
57343: LD_INT 29
57345: PUSH
57346: EMPTY
57347: LIST
57348: IN
57349: IFFALSE 57370
// points := [ 70 , 200 , 400 ] ;
57351: LD_ADDR_VAR 0 9
57355: PUSH
57356: LD_INT 70
57358: PUSH
57359: LD_INT 200
57361: PUSH
57362: LD_INT 400
57364: PUSH
57365: EMPTY
57366: LIST
57367: LIST
57368: LIST
57369: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57370: LD_VAR 0 6
57374: PPUSH
57375: CALL_OW 264
57379: PUSH
57380: LD_INT 14
57382: PUSH
57383: LD_INT 53
57385: PUSH
57386: EMPTY
57387: LIST
57388: LIST
57389: IN
57390: IFFALSE 57411
// points := [ 40 , 10 , 20 ] ;
57392: LD_ADDR_VAR 0 9
57396: PUSH
57397: LD_INT 40
57399: PUSH
57400: LD_INT 10
57402: PUSH
57403: LD_INT 20
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: LIST
57410: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57411: LD_VAR 0 6
57415: PPUSH
57416: CALL_OW 264
57420: PUSH
57421: LD_INT 9
57423: PUSH
57424: EMPTY
57425: LIST
57426: IN
57427: IFFALSE 57448
// points := [ 5 , 70 , 20 ] ;
57429: LD_ADDR_VAR 0 9
57433: PUSH
57434: LD_INT 5
57436: PUSH
57437: LD_INT 70
57439: PUSH
57440: LD_INT 20
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: LIST
57447: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57448: LD_VAR 0 6
57452: PPUSH
57453: CALL_OW 264
57457: PUSH
57458: LD_INT 10
57460: PUSH
57461: EMPTY
57462: LIST
57463: IN
57464: IFFALSE 57485
// points := [ 35 , 110 , 70 ] ;
57466: LD_ADDR_VAR 0 9
57470: PUSH
57471: LD_INT 35
57473: PUSH
57474: LD_INT 110
57476: PUSH
57477: LD_INT 70
57479: PUSH
57480: EMPTY
57481: LIST
57482: LIST
57483: LIST
57484: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
57485: LD_VAR 0 6
57489: PPUSH
57490: CALL_OW 265
57494: PUSH
57495: LD_INT 25
57497: EQUAL
57498: IFFALSE 57519
// points := [ 80 , 65 , 100 ] ;
57500: LD_ADDR_VAR 0 9
57504: PUSH
57505: LD_INT 80
57507: PUSH
57508: LD_INT 65
57510: PUSH
57511: LD_INT 100
57513: PUSH
57514: EMPTY
57515: LIST
57516: LIST
57517: LIST
57518: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
57519: LD_VAR 0 6
57523: PPUSH
57524: CALL_OW 263
57528: PUSH
57529: LD_INT 1
57531: EQUAL
57532: IFFALSE 57567
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
57534: LD_ADDR_VAR 0 10
57538: PUSH
57539: LD_VAR 0 10
57543: PUSH
57544: LD_VAR 0 6
57548: PPUSH
57549: CALL_OW 311
57553: PPUSH
57554: LD_INT 3
57556: PPUSH
57557: CALL_OW 259
57561: PUSH
57562: LD_INT 4
57564: MUL
57565: MUL
57566: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
57567: LD_VAR 0 6
57571: PPUSH
57572: CALL_OW 263
57576: PUSH
57577: LD_INT 2
57579: EQUAL
57580: IFFALSE 57631
// begin j := IsControledBy ( i ) ;
57582: LD_ADDR_VAR 0 7
57586: PUSH
57587: LD_VAR 0 6
57591: PPUSH
57592: CALL_OW 312
57596: ST_TO_ADDR
// if j then
57597: LD_VAR 0 7
57601: IFFALSE 57631
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
57603: LD_ADDR_VAR 0 10
57607: PUSH
57608: LD_VAR 0 10
57612: PUSH
57613: LD_VAR 0 7
57617: PPUSH
57618: LD_INT 3
57620: PPUSH
57621: CALL_OW 259
57625: PUSH
57626: LD_INT 3
57628: MUL
57629: MUL
57630: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
57631: LD_VAR 0 6
57635: PPUSH
57636: CALL_OW 264
57640: PUSH
57641: LD_INT 5
57643: PUSH
57644: LD_INT 6
57646: PUSH
57647: LD_INT 46
57649: PUSH
57650: LD_INT 44
57652: PUSH
57653: LD_INT 47
57655: PUSH
57656: LD_INT 45
57658: PUSH
57659: LD_INT 28
57661: PUSH
57662: LD_INT 7
57664: PUSH
57665: LD_INT 27
57667: PUSH
57668: LD_INT 29
57670: PUSH
57671: EMPTY
57672: LIST
57673: LIST
57674: LIST
57675: LIST
57676: LIST
57677: LIST
57678: LIST
57679: LIST
57680: LIST
57681: LIST
57682: IN
57683: IFFALSE 57703
57685: PUSH
57686: LD_VAR 0 1
57690: PPUSH
57691: LD_INT 52
57693: PPUSH
57694: CALL_OW 321
57698: PUSH
57699: LD_INT 2
57701: EQUAL
57702: AND
57703: IFFALSE 57720
// bpoints := bpoints * 1.2 ;
57705: LD_ADDR_VAR 0 10
57709: PUSH
57710: LD_VAR 0 10
57714: PUSH
57715: LD_REAL  1.20000000000000E+0000
57718: MUL
57719: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
57720: LD_VAR 0 6
57724: PPUSH
57725: CALL_OW 264
57729: PUSH
57730: LD_INT 6
57732: PUSH
57733: LD_INT 46
57735: PUSH
57736: LD_INT 47
57738: PUSH
57739: EMPTY
57740: LIST
57741: LIST
57742: LIST
57743: IN
57744: IFFALSE 57761
// bpoints := bpoints * 1.2 ;
57746: LD_ADDR_VAR 0 10
57750: PUSH
57751: LD_VAR 0 10
57755: PUSH
57756: LD_REAL  1.20000000000000E+0000
57759: MUL
57760: ST_TO_ADDR
// end ; unit_building :
57761: GO 57775
57763: LD_INT 3
57765: DOUBLE
57766: EQUAL
57767: IFTRUE 57771
57769: GO 57774
57771: POP
// ; end ;
57772: GO 57775
57774: POP
// for j = 1 to 3 do
57775: LD_ADDR_VAR 0 7
57779: PUSH
57780: DOUBLE
57781: LD_INT 1
57783: DEC
57784: ST_TO_ADDR
57785: LD_INT 3
57787: PUSH
57788: FOR_TO
57789: IFFALSE 57842
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57791: LD_ADDR_VAR 0 5
57795: PUSH
57796: LD_VAR 0 5
57800: PPUSH
57801: LD_VAR 0 7
57805: PPUSH
57806: LD_VAR 0 5
57810: PUSH
57811: LD_VAR 0 7
57815: ARRAY
57816: PUSH
57817: LD_VAR 0 9
57821: PUSH
57822: LD_VAR 0 7
57826: ARRAY
57827: PUSH
57828: LD_VAR 0 10
57832: MUL
57833: PLUS
57834: PPUSH
57835: CALL_OW 1
57839: ST_TO_ADDR
57840: GO 57788
57842: POP
57843: POP
// end ;
57844: GO 56317
57846: POP
57847: POP
// result := Replace ( result , 4 , tmp ) ;
57848: LD_ADDR_VAR 0 5
57852: PUSH
57853: LD_VAR 0 5
57857: PPUSH
57858: LD_INT 4
57860: PPUSH
57861: LD_VAR 0 8
57865: PPUSH
57866: CALL_OW 1
57870: ST_TO_ADDR
// end ;
57871: LD_VAR 0 5
57875: RET
// export function DangerAtRange ( unit , range ) ; begin
57876: LD_INT 0
57878: PPUSH
// if not unit then
57879: LD_VAR 0 1
57883: NOT
57884: IFFALSE 57888
// exit ;
57886: GO 57933
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57888: LD_ADDR_VAR 0 3
57892: PUSH
57893: LD_VAR 0 1
57897: PPUSH
57898: CALL_OW 255
57902: PPUSH
57903: LD_VAR 0 1
57907: PPUSH
57908: CALL_OW 250
57912: PPUSH
57913: LD_VAR 0 1
57917: PPUSH
57918: CALL_OW 251
57922: PPUSH
57923: LD_VAR 0 2
57927: PPUSH
57928: CALL 56167 0 4
57932: ST_TO_ADDR
// end ;
57933: LD_VAR 0 3
57937: RET
// export function DangerInArea ( side , area ) ; begin
57938: LD_INT 0
57940: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57941: LD_ADDR_VAR 0 3
57945: PUSH
57946: LD_VAR 0 2
57950: PPUSH
57951: LD_INT 81
57953: PUSH
57954: LD_VAR 0 1
57958: PUSH
57959: EMPTY
57960: LIST
57961: LIST
57962: PPUSH
57963: CALL_OW 70
57967: ST_TO_ADDR
// end ;
57968: LD_VAR 0 3
57972: RET
// export function IsExtension ( b ) ; begin
57973: LD_INT 0
57975: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57976: LD_ADDR_VAR 0 2
57980: PUSH
57981: LD_VAR 0 1
57985: PUSH
57986: LD_INT 23
57988: PUSH
57989: LD_INT 20
57991: PUSH
57992: LD_INT 22
57994: PUSH
57995: LD_INT 17
57997: PUSH
57998: LD_INT 24
58000: PUSH
58001: LD_INT 21
58003: PUSH
58004: LD_INT 19
58006: PUSH
58007: LD_INT 16
58009: PUSH
58010: LD_INT 25
58012: PUSH
58013: LD_INT 18
58015: PUSH
58016: EMPTY
58017: LIST
58018: LIST
58019: LIST
58020: LIST
58021: LIST
58022: LIST
58023: LIST
58024: LIST
58025: LIST
58026: LIST
58027: IN
58028: ST_TO_ADDR
// end ;
58029: LD_VAR 0 2
58033: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
58034: LD_INT 0
58036: PPUSH
58037: PPUSH
58038: PPUSH
// result := [ ] ;
58039: LD_ADDR_VAR 0 4
58043: PUSH
58044: EMPTY
58045: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58046: LD_ADDR_VAR 0 5
58050: PUSH
58051: LD_VAR 0 2
58055: PPUSH
58056: LD_INT 21
58058: PUSH
58059: LD_INT 3
58061: PUSH
58062: EMPTY
58063: LIST
58064: LIST
58065: PPUSH
58066: CALL_OW 70
58070: ST_TO_ADDR
// if not tmp then
58071: LD_VAR 0 5
58075: NOT
58076: IFFALSE 58080
// exit ;
58078: GO 58144
// if checkLink then
58080: LD_VAR 0 3
58084: IFFALSE 58134
// begin for i in tmp do
58086: LD_ADDR_VAR 0 6
58090: PUSH
58091: LD_VAR 0 5
58095: PUSH
58096: FOR_IN
58097: IFFALSE 58132
// if GetBase ( i ) <> base then
58099: LD_VAR 0 6
58103: PPUSH
58104: CALL_OW 274
58108: PUSH
58109: LD_VAR 0 1
58113: NONEQUAL
58114: IFFALSE 58130
// ComLinkToBase ( base , i ) ;
58116: LD_VAR 0 1
58120: PPUSH
58121: LD_VAR 0 6
58125: PPUSH
58126: CALL_OW 169
58130: GO 58096
58132: POP
58133: POP
// end ; result := tmp ;
58134: LD_ADDR_VAR 0 4
58138: PUSH
58139: LD_VAR 0 5
58143: ST_TO_ADDR
// end ;
58144: LD_VAR 0 4
58148: RET
// export function ComComplete ( units , b ) ; var i ; begin
58149: LD_INT 0
58151: PPUSH
58152: PPUSH
// if not units then
58153: LD_VAR 0 1
58157: NOT
58158: IFFALSE 58162
// exit ;
58160: GO 58252
// for i in units do
58162: LD_ADDR_VAR 0 4
58166: PUSH
58167: LD_VAR 0 1
58171: PUSH
58172: FOR_IN
58173: IFFALSE 58250
// if BuildingStatus ( b ) = bs_build then
58175: LD_VAR 0 2
58179: PPUSH
58180: CALL_OW 461
58184: PUSH
58185: LD_INT 1
58187: EQUAL
58188: IFFALSE 58248
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58190: LD_VAR 0 4
58194: PPUSH
58195: LD_STRING h
58197: PUSH
58198: LD_VAR 0 2
58202: PPUSH
58203: CALL_OW 250
58207: PUSH
58208: LD_VAR 0 2
58212: PPUSH
58213: CALL_OW 251
58217: PUSH
58218: LD_VAR 0 2
58222: PUSH
58223: LD_INT 0
58225: PUSH
58226: LD_INT 0
58228: PUSH
58229: LD_INT 0
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: LIST
58236: LIST
58237: LIST
58238: LIST
58239: LIST
58240: PUSH
58241: EMPTY
58242: LIST
58243: PPUSH
58244: CALL_OW 446
58248: GO 58172
58250: POP
58251: POP
// end ;
58252: LD_VAR 0 3
58256: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58257: LD_INT 0
58259: PPUSH
58260: PPUSH
58261: PPUSH
58262: PPUSH
58263: PPUSH
58264: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
58265: LD_VAR 0 1
58269: NOT
58270: IFTRUE 58287
58272: PUSH
58273: LD_VAR 0 1
58277: PPUSH
58278: CALL_OW 263
58282: PUSH
58283: LD_INT 2
58285: NONEQUAL
58286: OR
58287: IFFALSE 58291
// exit ;
58289: GO 58607
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58291: LD_ADDR_VAR 0 6
58295: PUSH
58296: LD_INT 22
58298: PUSH
58299: LD_VAR 0 1
58303: PPUSH
58304: CALL_OW 255
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: PUSH
58313: LD_INT 2
58315: PUSH
58316: LD_INT 30
58318: PUSH
58319: LD_INT 36
58321: PUSH
58322: EMPTY
58323: LIST
58324: LIST
58325: PUSH
58326: LD_INT 34
58328: PUSH
58329: LD_INT 31
58331: PUSH
58332: EMPTY
58333: LIST
58334: LIST
58335: PUSH
58336: EMPTY
58337: LIST
58338: LIST
58339: LIST
58340: PUSH
58341: EMPTY
58342: LIST
58343: LIST
58344: PPUSH
58345: CALL_OW 69
58349: ST_TO_ADDR
// if not tmp then
58350: LD_VAR 0 6
58354: NOT
58355: IFFALSE 58359
// exit ;
58357: GO 58607
// result := [ ] ;
58359: LD_ADDR_VAR 0 2
58363: PUSH
58364: EMPTY
58365: ST_TO_ADDR
// for i in tmp do
58366: LD_ADDR_VAR 0 3
58370: PUSH
58371: LD_VAR 0 6
58375: PUSH
58376: FOR_IN
58377: IFFALSE 58448
// begin t := UnitsInside ( i ) ;
58379: LD_ADDR_VAR 0 4
58383: PUSH
58384: LD_VAR 0 3
58388: PPUSH
58389: CALL_OW 313
58393: ST_TO_ADDR
// if t then
58394: LD_VAR 0 4
58398: IFFALSE 58446
// for j in t do
58400: LD_ADDR_VAR 0 7
58404: PUSH
58405: LD_VAR 0 4
58409: PUSH
58410: FOR_IN
58411: IFFALSE 58444
// result := Replace ( result , result + 1 , j ) ;
58413: LD_ADDR_VAR 0 2
58417: PUSH
58418: LD_VAR 0 2
58422: PPUSH
58423: LD_VAR 0 2
58427: PUSH
58428: LD_INT 1
58430: PLUS
58431: PPUSH
58432: LD_VAR 0 7
58436: PPUSH
58437: CALL_OW 1
58441: ST_TO_ADDR
58442: GO 58410
58444: POP
58445: POP
// end ;
58446: GO 58376
58448: POP
58449: POP
// if not result then
58450: LD_VAR 0 2
58454: NOT
58455: IFFALSE 58459
// exit ;
58457: GO 58607
// mech := result [ 1 ] ;
58459: LD_ADDR_VAR 0 5
58463: PUSH
58464: LD_VAR 0 2
58468: PUSH
58469: LD_INT 1
58471: ARRAY
58472: ST_TO_ADDR
// if result > 1 then
58473: LD_VAR 0 2
58477: PUSH
58478: LD_INT 1
58480: GREATER
58481: IFFALSE 58593
// begin for i = 2 to result do
58483: LD_ADDR_VAR 0 3
58487: PUSH
58488: DOUBLE
58489: LD_INT 2
58491: DEC
58492: ST_TO_ADDR
58493: LD_VAR 0 2
58497: PUSH
58498: FOR_TO
58499: IFFALSE 58591
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58501: LD_ADDR_VAR 0 4
58505: PUSH
58506: LD_VAR 0 2
58510: PUSH
58511: LD_VAR 0 3
58515: ARRAY
58516: PPUSH
58517: LD_INT 3
58519: PPUSH
58520: CALL_OW 259
58524: PUSH
58525: LD_VAR 0 2
58529: PUSH
58530: LD_VAR 0 3
58534: ARRAY
58535: PPUSH
58536: CALL_OW 432
58540: MINUS
58541: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
58542: LD_VAR 0 4
58546: PUSH
58547: LD_VAR 0 5
58551: PPUSH
58552: LD_INT 3
58554: PPUSH
58555: CALL_OW 259
58559: PUSH
58560: LD_VAR 0 5
58564: PPUSH
58565: CALL_OW 432
58569: MINUS
58570: GREATEREQUAL
58571: IFFALSE 58589
// mech := result [ i ] ;
58573: LD_ADDR_VAR 0 5
58577: PUSH
58578: LD_VAR 0 2
58582: PUSH
58583: LD_VAR 0 3
58587: ARRAY
58588: ST_TO_ADDR
// end ;
58589: GO 58498
58591: POP
58592: POP
// end ; ComLinkTo ( vehicle , mech ) ;
58593: LD_VAR 0 1
58597: PPUSH
58598: LD_VAR 0 5
58602: PPUSH
58603: CALL_OW 135
// end ;
58607: LD_VAR 0 2
58611: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
58612: LD_INT 0
58614: PPUSH
58615: PPUSH
58616: PPUSH
58617: PPUSH
58618: PPUSH
58619: PPUSH
58620: PPUSH
58621: PPUSH
58622: PPUSH
58623: PPUSH
58624: PPUSH
58625: PPUSH
58626: PPUSH
// result := [ ] ;
58627: LD_ADDR_VAR 0 7
58631: PUSH
58632: EMPTY
58633: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
58634: LD_VAR 0 1
58638: PPUSH
58639: CALL_OW 266
58643: PUSH
58644: LD_INT 0
58646: PUSH
58647: LD_INT 1
58649: PUSH
58650: EMPTY
58651: LIST
58652: LIST
58653: IN
58654: NOT
58655: IFFALSE 58659
// exit ;
58657: GO 60299
// if name then
58659: LD_VAR 0 3
58663: IFFALSE 58679
// SetBName ( base_dep , name ) ;
58665: LD_VAR 0 1
58669: PPUSH
58670: LD_VAR 0 3
58674: PPUSH
58675: CALL_OW 500
// base := GetBase ( base_dep ) ;
58679: LD_ADDR_VAR 0 15
58683: PUSH
58684: LD_VAR 0 1
58688: PPUSH
58689: CALL_OW 274
58693: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
58694: LD_ADDR_VAR 0 16
58698: PUSH
58699: LD_VAR 0 1
58703: PPUSH
58704: CALL_OW 255
58708: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
58709: LD_ADDR_VAR 0 17
58713: PUSH
58714: LD_VAR 0 1
58718: PPUSH
58719: CALL_OW 248
58723: ST_TO_ADDR
// if sources then
58724: LD_VAR 0 5
58728: IFFALSE 58775
// for i = 1 to 3 do
58730: LD_ADDR_VAR 0 8
58734: PUSH
58735: DOUBLE
58736: LD_INT 1
58738: DEC
58739: ST_TO_ADDR
58740: LD_INT 3
58742: PUSH
58743: FOR_TO
58744: IFFALSE 58773
// AddResourceType ( base , i , sources [ i ] ) ;
58746: LD_VAR 0 15
58750: PPUSH
58751: LD_VAR 0 8
58755: PPUSH
58756: LD_VAR 0 5
58760: PUSH
58761: LD_VAR 0 8
58765: ARRAY
58766: PPUSH
58767: CALL_OW 276
58771: GO 58743
58773: POP
58774: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
58775: LD_ADDR_VAR 0 18
58779: PUSH
58780: LD_VAR 0 15
58784: PPUSH
58785: LD_VAR 0 2
58789: PPUSH
58790: LD_INT 1
58792: PPUSH
58793: CALL 58034 0 3
58797: ST_TO_ADDR
// InitHc ;
58798: CALL_OW 19
// InitUc ;
58802: CALL_OW 18
// uc_side := side ;
58806: LD_ADDR_OWVAR 20
58810: PUSH
58811: LD_VAR 0 16
58815: ST_TO_ADDR
// uc_nation := nation ;
58816: LD_ADDR_OWVAR 21
58820: PUSH
58821: LD_VAR 0 17
58825: ST_TO_ADDR
// if buildings then
58826: LD_VAR 0 18
58830: IFFALSE 60158
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58832: LD_ADDR_VAR 0 19
58836: PUSH
58837: LD_VAR 0 18
58841: PPUSH
58842: LD_INT 2
58844: PUSH
58845: LD_INT 30
58847: PUSH
58848: LD_INT 29
58850: PUSH
58851: EMPTY
58852: LIST
58853: LIST
58854: PUSH
58855: LD_INT 30
58857: PUSH
58858: LD_INT 30
58860: PUSH
58861: EMPTY
58862: LIST
58863: LIST
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: LIST
58869: PPUSH
58870: CALL_OW 72
58874: ST_TO_ADDR
// if tmp then
58875: LD_VAR 0 19
58879: IFFALSE 58927
// for i in tmp do
58881: LD_ADDR_VAR 0 8
58885: PUSH
58886: LD_VAR 0 19
58890: PUSH
58891: FOR_IN
58892: IFFALSE 58925
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58894: LD_VAR 0 8
58898: PPUSH
58899: CALL_OW 250
58903: PPUSH
58904: LD_VAR 0 8
58908: PPUSH
58909: CALL_OW 251
58913: PPUSH
58914: LD_VAR 0 16
58918: PPUSH
58919: CALL_OW 441
58923: GO 58891
58925: POP
58926: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58927: LD_VAR 0 18
58931: PPUSH
58932: LD_INT 2
58934: PUSH
58935: LD_INT 30
58937: PUSH
58938: LD_INT 32
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: PUSH
58945: LD_INT 30
58947: PUSH
58948: LD_INT 33
58950: PUSH
58951: EMPTY
58952: LIST
58953: LIST
58954: PUSH
58955: EMPTY
58956: LIST
58957: LIST
58958: LIST
58959: PPUSH
58960: CALL_OW 72
58964: IFFALSE 59052
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58966: LD_ADDR_VAR 0 8
58970: PUSH
58971: LD_VAR 0 18
58975: PPUSH
58976: LD_INT 2
58978: PUSH
58979: LD_INT 30
58981: PUSH
58982: LD_INT 32
58984: PUSH
58985: EMPTY
58986: LIST
58987: LIST
58988: PUSH
58989: LD_INT 30
58991: PUSH
58992: LD_INT 33
58994: PUSH
58995: EMPTY
58996: LIST
58997: LIST
58998: PUSH
58999: EMPTY
59000: LIST
59001: LIST
59002: LIST
59003: PPUSH
59004: CALL_OW 72
59008: PUSH
59009: FOR_IN
59010: IFFALSE 59050
// begin if not GetBWeapon ( i ) then
59012: LD_VAR 0 8
59016: PPUSH
59017: CALL_OW 269
59021: NOT
59022: IFFALSE 59048
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59024: LD_VAR 0 8
59028: PPUSH
59029: LD_VAR 0 8
59033: PPUSH
59034: LD_VAR 0 2
59038: PPUSH
59039: CALL 60304 0 2
59043: PPUSH
59044: CALL_OW 431
// end ;
59048: GO 59009
59050: POP
59051: POP
// end ; for i = 1 to personel do
59052: LD_ADDR_VAR 0 8
59056: PUSH
59057: DOUBLE
59058: LD_INT 1
59060: DEC
59061: ST_TO_ADDR
59062: LD_VAR 0 6
59066: PUSH
59067: FOR_TO
59068: IFFALSE 60138
// begin if i > 4 then
59070: LD_VAR 0 8
59074: PUSH
59075: LD_INT 4
59077: GREATER
59078: IFFALSE 59082
// break ;
59080: GO 60138
// case i of 1 :
59082: LD_VAR 0 8
59086: PUSH
59087: LD_INT 1
59089: DOUBLE
59090: EQUAL
59091: IFTRUE 59095
59093: GO 59175
59095: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59096: LD_ADDR_VAR 0 12
59100: PUSH
59101: LD_VAR 0 18
59105: PPUSH
59106: LD_INT 22
59108: PUSH
59109: LD_VAR 0 16
59113: PUSH
59114: EMPTY
59115: LIST
59116: LIST
59117: PUSH
59118: LD_INT 58
59120: PUSH
59121: EMPTY
59122: LIST
59123: PUSH
59124: LD_INT 2
59126: PUSH
59127: LD_INT 30
59129: PUSH
59130: LD_INT 32
59132: PUSH
59133: EMPTY
59134: LIST
59135: LIST
59136: PUSH
59137: LD_INT 30
59139: PUSH
59140: LD_INT 4
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: PUSH
59147: LD_INT 30
59149: PUSH
59150: LD_INT 5
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PUSH
59157: EMPTY
59158: LIST
59159: LIST
59160: LIST
59161: LIST
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: LIST
59167: PPUSH
59168: CALL_OW 72
59172: ST_TO_ADDR
59173: GO 59397
59175: LD_INT 2
59177: DOUBLE
59178: EQUAL
59179: IFTRUE 59183
59181: GO 59245
59183: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59184: LD_ADDR_VAR 0 12
59188: PUSH
59189: LD_VAR 0 18
59193: PPUSH
59194: LD_INT 22
59196: PUSH
59197: LD_VAR 0 16
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: PUSH
59206: LD_INT 2
59208: PUSH
59209: LD_INT 30
59211: PUSH
59212: LD_INT 0
59214: PUSH
59215: EMPTY
59216: LIST
59217: LIST
59218: PUSH
59219: LD_INT 30
59221: PUSH
59222: LD_INT 1
59224: PUSH
59225: EMPTY
59226: LIST
59227: LIST
59228: PUSH
59229: EMPTY
59230: LIST
59231: LIST
59232: LIST
59233: PUSH
59234: EMPTY
59235: LIST
59236: LIST
59237: PPUSH
59238: CALL_OW 72
59242: ST_TO_ADDR
59243: GO 59397
59245: LD_INT 3
59247: DOUBLE
59248: EQUAL
59249: IFTRUE 59253
59251: GO 59315
59253: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59254: LD_ADDR_VAR 0 12
59258: PUSH
59259: LD_VAR 0 18
59263: PPUSH
59264: LD_INT 22
59266: PUSH
59267: LD_VAR 0 16
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: PUSH
59276: LD_INT 2
59278: PUSH
59279: LD_INT 30
59281: PUSH
59282: LD_INT 2
59284: PUSH
59285: EMPTY
59286: LIST
59287: LIST
59288: PUSH
59289: LD_INT 30
59291: PUSH
59292: LD_INT 3
59294: PUSH
59295: EMPTY
59296: LIST
59297: LIST
59298: PUSH
59299: EMPTY
59300: LIST
59301: LIST
59302: LIST
59303: PUSH
59304: EMPTY
59305: LIST
59306: LIST
59307: PPUSH
59308: CALL_OW 72
59312: ST_TO_ADDR
59313: GO 59397
59315: LD_INT 4
59317: DOUBLE
59318: EQUAL
59319: IFTRUE 59323
59321: GO 59396
59323: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59324: LD_ADDR_VAR 0 12
59328: PUSH
59329: LD_VAR 0 18
59333: PPUSH
59334: LD_INT 22
59336: PUSH
59337: LD_VAR 0 16
59341: PUSH
59342: EMPTY
59343: LIST
59344: LIST
59345: PUSH
59346: LD_INT 2
59348: PUSH
59349: LD_INT 30
59351: PUSH
59352: LD_INT 6
59354: PUSH
59355: EMPTY
59356: LIST
59357: LIST
59358: PUSH
59359: LD_INT 30
59361: PUSH
59362: LD_INT 7
59364: PUSH
59365: EMPTY
59366: LIST
59367: LIST
59368: PUSH
59369: LD_INT 30
59371: PUSH
59372: LD_INT 8
59374: PUSH
59375: EMPTY
59376: LIST
59377: LIST
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: PUSH
59385: EMPTY
59386: LIST
59387: LIST
59388: PPUSH
59389: CALL_OW 72
59393: ST_TO_ADDR
59394: GO 59397
59396: POP
// if i = 1 then
59397: LD_VAR 0 8
59401: PUSH
59402: LD_INT 1
59404: EQUAL
59405: IFFALSE 59516
// begin tmp := [ ] ;
59407: LD_ADDR_VAR 0 19
59411: PUSH
59412: EMPTY
59413: ST_TO_ADDR
// for j in f do
59414: LD_ADDR_VAR 0 9
59418: PUSH
59419: LD_VAR 0 12
59423: PUSH
59424: FOR_IN
59425: IFFALSE 59498
// if GetBType ( j ) = b_bunker then
59427: LD_VAR 0 9
59431: PPUSH
59432: CALL_OW 266
59436: PUSH
59437: LD_INT 32
59439: EQUAL
59440: IFFALSE 59467
// tmp := Insert ( tmp , 1 , j ) else
59442: LD_ADDR_VAR 0 19
59446: PUSH
59447: LD_VAR 0 19
59451: PPUSH
59452: LD_INT 1
59454: PPUSH
59455: LD_VAR 0 9
59459: PPUSH
59460: CALL_OW 2
59464: ST_TO_ADDR
59465: GO 59496
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59467: LD_ADDR_VAR 0 19
59471: PUSH
59472: LD_VAR 0 19
59476: PPUSH
59477: LD_VAR 0 19
59481: PUSH
59482: LD_INT 1
59484: PLUS
59485: PPUSH
59486: LD_VAR 0 9
59490: PPUSH
59491: CALL_OW 2
59495: ST_TO_ADDR
59496: GO 59424
59498: POP
59499: POP
// if tmp then
59500: LD_VAR 0 19
59504: IFFALSE 59516
// f := tmp ;
59506: LD_ADDR_VAR 0 12
59510: PUSH
59511: LD_VAR 0 19
59515: ST_TO_ADDR
// end ; x := personel [ i ] ;
59516: LD_ADDR_VAR 0 13
59520: PUSH
59521: LD_VAR 0 6
59525: PUSH
59526: LD_VAR 0 8
59530: ARRAY
59531: ST_TO_ADDR
// if x = - 1 then
59532: LD_VAR 0 13
59536: PUSH
59537: LD_INT 1
59539: NEG
59540: EQUAL
59541: IFFALSE 59752
// begin for j in f do
59543: LD_ADDR_VAR 0 9
59547: PUSH
59548: LD_VAR 0 12
59552: PUSH
59553: FOR_IN
59554: IFFALSE 59748
// repeat InitHc ;
59556: CALL_OW 19
// if GetBType ( j ) = b_barracks then
59560: LD_VAR 0 9
59564: PPUSH
59565: CALL_OW 266
59569: PUSH
59570: LD_INT 5
59572: EQUAL
59573: IFFALSE 59643
// begin if UnitsInside ( j ) < 3 then
59575: LD_VAR 0 9
59579: PPUSH
59580: CALL_OW 313
59584: PUSH
59585: LD_INT 3
59587: LESS
59588: IFFALSE 59624
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59590: LD_INT 0
59592: PPUSH
59593: LD_INT 5
59595: PUSH
59596: LD_INT 8
59598: PUSH
59599: LD_INT 9
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: LIST
59606: PUSH
59607: LD_VAR 0 17
59611: ARRAY
59612: PPUSH
59613: LD_VAR 0 4
59617: PPUSH
59618: CALL_OW 380
59622: GO 59641
// PrepareHuman ( false , i , skill ) ;
59624: LD_INT 0
59626: PPUSH
59627: LD_VAR 0 8
59631: PPUSH
59632: LD_VAR 0 4
59636: PPUSH
59637: CALL_OW 380
// end else
59641: GO 59660
// PrepareHuman ( false , i , skill ) ;
59643: LD_INT 0
59645: PPUSH
59646: LD_VAR 0 8
59650: PPUSH
59651: LD_VAR 0 4
59655: PPUSH
59656: CALL_OW 380
// un := CreateHuman ;
59660: LD_ADDR_VAR 0 14
59664: PUSH
59665: CALL_OW 44
59669: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59670: LD_ADDR_VAR 0 7
59674: PUSH
59675: LD_VAR 0 7
59679: PPUSH
59680: LD_INT 1
59682: PPUSH
59683: LD_VAR 0 14
59687: PPUSH
59688: CALL_OW 2
59692: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
59693: LD_VAR 0 14
59697: PPUSH
59698: LD_VAR 0 9
59702: PPUSH
59703: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
59707: LD_VAR 0 9
59711: PPUSH
59712: CALL_OW 313
59716: PUSH
59717: LD_INT 6
59719: EQUAL
59720: IFTRUE 59744
59722: PUSH
59723: LD_VAR 0 9
59727: PPUSH
59728: CALL_OW 266
59732: PUSH
59733: LD_INT 32
59735: PUSH
59736: LD_INT 31
59738: PUSH
59739: EMPTY
59740: LIST
59741: LIST
59742: IN
59743: OR
59744: IFFALSE 59556
59746: GO 59553
59748: POP
59749: POP
// end else
59750: GO 60136
// for j = 1 to x do
59752: LD_ADDR_VAR 0 9
59756: PUSH
59757: DOUBLE
59758: LD_INT 1
59760: DEC
59761: ST_TO_ADDR
59762: LD_VAR 0 13
59766: PUSH
59767: FOR_TO
59768: IFFALSE 60134
// begin InitHc ;
59770: CALL_OW 19
// if not f then
59774: LD_VAR 0 12
59778: NOT
59779: IFFALSE 59868
// begin PrepareHuman ( false , i , skill ) ;
59781: LD_INT 0
59783: PPUSH
59784: LD_VAR 0 8
59788: PPUSH
59789: LD_VAR 0 4
59793: PPUSH
59794: CALL_OW 380
// un := CreateHuman ;
59798: LD_ADDR_VAR 0 14
59802: PUSH
59803: CALL_OW 44
59807: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59808: LD_ADDR_VAR 0 7
59812: PUSH
59813: LD_VAR 0 7
59817: PPUSH
59818: LD_INT 1
59820: PPUSH
59821: LD_VAR 0 14
59825: PPUSH
59826: CALL_OW 2
59830: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59831: LD_VAR 0 14
59835: PPUSH
59836: LD_VAR 0 1
59840: PPUSH
59841: CALL_OW 250
59845: PPUSH
59846: LD_VAR 0 1
59850: PPUSH
59851: CALL_OW 251
59855: PPUSH
59856: LD_INT 10
59858: PPUSH
59859: LD_INT 0
59861: PPUSH
59862: CALL_OW 50
// continue ;
59866: GO 59767
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59868: LD_VAR 0 12
59872: PUSH
59873: LD_INT 1
59875: ARRAY
59876: PPUSH
59877: CALL_OW 313
59881: IFFALSE 59909
59883: PUSH
59884: LD_VAR 0 12
59888: PUSH
59889: LD_INT 1
59891: ARRAY
59892: PPUSH
59893: CALL_OW 266
59897: PUSH
59898: LD_INT 32
59900: PUSH
59901: LD_INT 31
59903: PUSH
59904: EMPTY
59905: LIST
59906: LIST
59907: IN
59908: AND
59909: IFTRUE 59930
59911: PUSH
59912: LD_VAR 0 12
59916: PUSH
59917: LD_INT 1
59919: ARRAY
59920: PPUSH
59921: CALL_OW 313
59925: PUSH
59926: LD_INT 6
59928: EQUAL
59929: OR
59930: IFFALSE 59950
// f := Delete ( f , 1 ) ;
59932: LD_ADDR_VAR 0 12
59936: PUSH
59937: LD_VAR 0 12
59941: PPUSH
59942: LD_INT 1
59944: PPUSH
59945: CALL_OW 3
59949: ST_TO_ADDR
// if not f then
59950: LD_VAR 0 12
59954: NOT
59955: IFFALSE 59973
// begin x := x + 2 ;
59957: LD_ADDR_VAR 0 13
59961: PUSH
59962: LD_VAR 0 13
59966: PUSH
59967: LD_INT 2
59969: PLUS
59970: ST_TO_ADDR
// continue ;
59971: GO 59767
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59973: LD_VAR 0 12
59977: PUSH
59978: LD_INT 1
59980: ARRAY
59981: PPUSH
59982: CALL_OW 266
59986: PUSH
59987: LD_INT 5
59989: EQUAL
59990: IFFALSE 60064
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59992: LD_VAR 0 12
59996: PUSH
59997: LD_INT 1
59999: ARRAY
60000: PPUSH
60001: CALL_OW 313
60005: PUSH
60006: LD_INT 3
60008: LESS
60009: IFFALSE 60045
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60011: LD_INT 0
60013: PPUSH
60014: LD_INT 5
60016: PUSH
60017: LD_INT 8
60019: PUSH
60020: LD_INT 9
60022: PUSH
60023: EMPTY
60024: LIST
60025: LIST
60026: LIST
60027: PUSH
60028: LD_VAR 0 17
60032: ARRAY
60033: PPUSH
60034: LD_VAR 0 4
60038: PPUSH
60039: CALL_OW 380
60043: GO 60062
// PrepareHuman ( false , i , skill ) ;
60045: LD_INT 0
60047: PPUSH
60048: LD_VAR 0 8
60052: PPUSH
60053: LD_VAR 0 4
60057: PPUSH
60058: CALL_OW 380
// end else
60062: GO 60081
// PrepareHuman ( false , i , skill ) ;
60064: LD_INT 0
60066: PPUSH
60067: LD_VAR 0 8
60071: PPUSH
60072: LD_VAR 0 4
60076: PPUSH
60077: CALL_OW 380
// un := CreateHuman ;
60081: LD_ADDR_VAR 0 14
60085: PUSH
60086: CALL_OW 44
60090: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60091: LD_ADDR_VAR 0 7
60095: PUSH
60096: LD_VAR 0 7
60100: PPUSH
60101: LD_INT 1
60103: PPUSH
60104: LD_VAR 0 14
60108: PPUSH
60109: CALL_OW 2
60113: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60114: LD_VAR 0 14
60118: PPUSH
60119: LD_VAR 0 12
60123: PUSH
60124: LD_INT 1
60126: ARRAY
60127: PPUSH
60128: CALL_OW 52
// end ;
60132: GO 59767
60134: POP
60135: POP
// end ;
60136: GO 59067
60138: POP
60139: POP
// result := result ^ buildings ;
60140: LD_ADDR_VAR 0 7
60144: PUSH
60145: LD_VAR 0 7
60149: PUSH
60150: LD_VAR 0 18
60154: ADD
60155: ST_TO_ADDR
// end else
60156: GO 60299
// begin for i = 1 to personel do
60158: LD_ADDR_VAR 0 8
60162: PUSH
60163: DOUBLE
60164: LD_INT 1
60166: DEC
60167: ST_TO_ADDR
60168: LD_VAR 0 6
60172: PUSH
60173: FOR_TO
60174: IFFALSE 60297
// begin if i > 4 then
60176: LD_VAR 0 8
60180: PUSH
60181: LD_INT 4
60183: GREATER
60184: IFFALSE 60188
// break ;
60186: GO 60297
// x := personel [ i ] ;
60188: LD_ADDR_VAR 0 13
60192: PUSH
60193: LD_VAR 0 6
60197: PUSH
60198: LD_VAR 0 8
60202: ARRAY
60203: ST_TO_ADDR
// if x = - 1 then
60204: LD_VAR 0 13
60208: PUSH
60209: LD_INT 1
60211: NEG
60212: EQUAL
60213: IFFALSE 60217
// continue ;
60215: GO 60173
// PrepareHuman ( false , i , skill ) ;
60217: LD_INT 0
60219: PPUSH
60220: LD_VAR 0 8
60224: PPUSH
60225: LD_VAR 0 4
60229: PPUSH
60230: CALL_OW 380
// un := CreateHuman ;
60234: LD_ADDR_VAR 0 14
60238: PUSH
60239: CALL_OW 44
60243: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60244: LD_VAR 0 14
60248: PPUSH
60249: LD_VAR 0 1
60253: PPUSH
60254: CALL_OW 250
60258: PPUSH
60259: LD_VAR 0 1
60263: PPUSH
60264: CALL_OW 251
60268: PPUSH
60269: LD_INT 10
60271: PPUSH
60272: LD_INT 0
60274: PPUSH
60275: CALL_OW 50
// result := result ^ un ;
60279: LD_ADDR_VAR 0 7
60283: PUSH
60284: LD_VAR 0 7
60288: PUSH
60289: LD_VAR 0 14
60293: ADD
60294: ST_TO_ADDR
// end ;
60295: GO 60173
60297: POP
60298: POP
// end ; end ;
60299: LD_VAR 0 7
60303: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60304: LD_INT 0
60306: PPUSH
60307: PPUSH
60308: PPUSH
60309: PPUSH
60310: PPUSH
60311: PPUSH
60312: PPUSH
60313: PPUSH
60314: PPUSH
60315: PPUSH
60316: PPUSH
60317: PPUSH
60318: PPUSH
60319: PPUSH
60320: PPUSH
60321: PPUSH
// result := false ;
60322: LD_ADDR_VAR 0 3
60326: PUSH
60327: LD_INT 0
60329: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60330: LD_VAR 0 1
60334: NOT
60335: IFTRUE 60360
60337: PUSH
60338: LD_VAR 0 1
60342: PPUSH
60343: CALL_OW 266
60347: PUSH
60348: LD_INT 32
60350: PUSH
60351: LD_INT 33
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: IN
60358: NOT
60359: OR
60360: IFFALSE 60364
// exit ;
60362: GO 61499
// nat := GetNation ( tower ) ;
60364: LD_ADDR_VAR 0 12
60368: PUSH
60369: LD_VAR 0 1
60373: PPUSH
60374: CALL_OW 248
60378: ST_TO_ADDR
// side := GetSide ( tower ) ;
60379: LD_ADDR_VAR 0 16
60383: PUSH
60384: LD_VAR 0 1
60388: PPUSH
60389: CALL_OW 255
60393: ST_TO_ADDR
// x := GetX ( tower ) ;
60394: LD_ADDR_VAR 0 10
60398: PUSH
60399: LD_VAR 0 1
60403: PPUSH
60404: CALL_OW 250
60408: ST_TO_ADDR
// y := GetY ( tower ) ;
60409: LD_ADDR_VAR 0 11
60413: PUSH
60414: LD_VAR 0 1
60418: PPUSH
60419: CALL_OW 251
60423: ST_TO_ADDR
// if not x or not y then
60424: LD_VAR 0 10
60428: NOT
60429: IFTRUE 60438
60431: PUSH
60432: LD_VAR 0 11
60436: NOT
60437: OR
60438: IFFALSE 60442
// exit ;
60440: GO 61499
// weapon := 0 ;
60442: LD_ADDR_VAR 0 18
60446: PUSH
60447: LD_INT 0
60449: ST_TO_ADDR
// fac_list := [ ] ;
60450: LD_ADDR_VAR 0 17
60454: PUSH
60455: EMPTY
60456: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
60457: LD_ADDR_VAR 0 6
60461: PUSH
60462: LD_VAR 0 1
60466: PPUSH
60467: CALL_OW 274
60471: PPUSH
60472: LD_VAR 0 2
60476: PPUSH
60477: LD_INT 0
60479: PPUSH
60480: CALL 58034 0 3
60484: PPUSH
60485: LD_INT 30
60487: PUSH
60488: LD_INT 3
60490: PUSH
60491: EMPTY
60492: LIST
60493: LIST
60494: PPUSH
60495: CALL_OW 72
60499: ST_TO_ADDR
// if not factories then
60500: LD_VAR 0 6
60504: NOT
60505: IFFALSE 60509
// exit ;
60507: GO 61499
// for i in factories do
60509: LD_ADDR_VAR 0 8
60513: PUSH
60514: LD_VAR 0 6
60518: PUSH
60519: FOR_IN
60520: IFFALSE 60545
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60522: LD_ADDR_VAR 0 17
60526: PUSH
60527: LD_VAR 0 17
60531: PUSH
60532: LD_VAR 0 8
60536: PPUSH
60537: CALL_OW 478
60541: UNION
60542: ST_TO_ADDR
60543: GO 60519
60545: POP
60546: POP
// if not fac_list then
60547: LD_VAR 0 17
60551: NOT
60552: IFFALSE 60556
// exit ;
60554: GO 61499
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
60556: LD_ADDR_VAR 0 5
60560: PUSH
60561: LD_INT 4
60563: PUSH
60564: LD_INT 5
60566: PUSH
60567: LD_INT 9
60569: PUSH
60570: LD_INT 10
60572: PUSH
60573: LD_INT 6
60575: PUSH
60576: LD_INT 7
60578: PUSH
60579: LD_INT 11
60581: PUSH
60582: EMPTY
60583: LIST
60584: LIST
60585: LIST
60586: LIST
60587: LIST
60588: LIST
60589: LIST
60590: PUSH
60591: LD_INT 27
60593: PUSH
60594: LD_INT 28
60596: PUSH
60597: LD_INT 26
60599: PUSH
60600: LD_INT 30
60602: PUSH
60603: EMPTY
60604: LIST
60605: LIST
60606: LIST
60607: LIST
60608: PUSH
60609: LD_INT 43
60611: PUSH
60612: LD_INT 44
60614: PUSH
60615: LD_INT 46
60617: PUSH
60618: LD_INT 45
60620: PUSH
60621: LD_INT 47
60623: PUSH
60624: LD_INT 49
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: LIST
60631: LIST
60632: LIST
60633: LIST
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: LIST
60639: PUSH
60640: LD_VAR 0 12
60644: ARRAY
60645: ST_TO_ADDR
// list := list isect fac_list ;
60646: LD_ADDR_VAR 0 5
60650: PUSH
60651: LD_VAR 0 5
60655: PUSH
60656: LD_VAR 0 17
60660: ISECT
60661: ST_TO_ADDR
// if not list then
60662: LD_VAR 0 5
60666: NOT
60667: IFFALSE 60671
// exit ;
60669: GO 61499
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
60671: LD_VAR 0 12
60675: PUSH
60676: LD_INT 3
60678: EQUAL
60679: IFFALSE 60691
60681: PUSH
60682: LD_INT 49
60684: PUSH
60685: LD_VAR 0 5
60689: IN
60690: AND
60691: IFFALSE 60711
60693: PUSH
60694: LD_INT 31
60696: PPUSH
60697: LD_VAR 0 16
60701: PPUSH
60702: CALL_OW 321
60706: PUSH
60707: LD_INT 2
60709: EQUAL
60710: AND
60711: IFFALSE 60771
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
60713: LD_INT 22
60715: PUSH
60716: LD_VAR 0 16
60720: PUSH
60721: EMPTY
60722: LIST
60723: LIST
60724: PUSH
60725: LD_INT 35
60727: PUSH
60728: LD_INT 49
60730: PUSH
60731: EMPTY
60732: LIST
60733: LIST
60734: PUSH
60735: LD_INT 91
60737: PUSH
60738: LD_VAR 0 1
60742: PUSH
60743: LD_INT 10
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: LIST
60750: PUSH
60751: EMPTY
60752: LIST
60753: LIST
60754: LIST
60755: PPUSH
60756: CALL_OW 69
60760: NOT
60761: IFFALSE 60771
// weapon := ru_time_lapser ;
60763: LD_ADDR_VAR 0 18
60767: PUSH
60768: LD_INT 49
60770: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
60771: LD_VAR 0 12
60775: PUSH
60776: LD_INT 1
60778: PUSH
60779: LD_INT 2
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: IN
60786: IFFALSE 60810
60788: PUSH
60789: LD_INT 11
60791: PUSH
60792: LD_VAR 0 5
60796: IN
60797: IFTRUE 60809
60799: PUSH
60800: LD_INT 30
60802: PUSH
60803: LD_VAR 0 5
60807: IN
60808: OR
60809: AND
60810: IFFALSE 60830
60812: PUSH
60813: LD_INT 6
60815: PPUSH
60816: LD_VAR 0 16
60820: PPUSH
60821: CALL_OW 321
60825: PUSH
60826: LD_INT 2
60828: EQUAL
60829: AND
60830: IFFALSE 60997
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60832: LD_INT 22
60834: PUSH
60835: LD_VAR 0 16
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: PUSH
60844: LD_INT 2
60846: PUSH
60847: LD_INT 35
60849: PUSH
60850: LD_INT 11
60852: PUSH
60853: EMPTY
60854: LIST
60855: LIST
60856: PUSH
60857: LD_INT 35
60859: PUSH
60860: LD_INT 30
60862: PUSH
60863: EMPTY
60864: LIST
60865: LIST
60866: PUSH
60867: EMPTY
60868: LIST
60869: LIST
60870: LIST
60871: PUSH
60872: LD_INT 91
60874: PUSH
60875: LD_VAR 0 1
60879: PUSH
60880: LD_INT 18
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: LIST
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: LIST
60892: PPUSH
60893: CALL_OW 69
60897: NOT
60898: IFFALSE 60974
60900: PUSH
60901: LD_INT 22
60903: PUSH
60904: LD_VAR 0 16
60908: PUSH
60909: EMPTY
60910: LIST
60911: LIST
60912: PUSH
60913: LD_INT 2
60915: PUSH
60916: LD_INT 30
60918: PUSH
60919: LD_INT 32
60921: PUSH
60922: EMPTY
60923: LIST
60924: LIST
60925: PUSH
60926: LD_INT 30
60928: PUSH
60929: LD_INT 33
60931: PUSH
60932: EMPTY
60933: LIST
60934: LIST
60935: PUSH
60936: EMPTY
60937: LIST
60938: LIST
60939: LIST
60940: PUSH
60941: LD_INT 91
60943: PUSH
60944: LD_VAR 0 1
60948: PUSH
60949: LD_INT 12
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: LIST
60956: PUSH
60957: EMPTY
60958: LIST
60959: LIST
60960: LIST
60961: PUSH
60962: EMPTY
60963: LIST
60964: PPUSH
60965: CALL_OW 69
60969: PUSH
60970: LD_INT 2
60972: GREATER
60973: AND
60974: IFFALSE 60997
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60976: LD_ADDR_VAR 0 18
60980: PUSH
60981: LD_INT 11
60983: PUSH
60984: LD_INT 30
60986: PUSH
60987: EMPTY
60988: LIST
60989: LIST
60990: PUSH
60991: LD_VAR 0 12
60995: ARRAY
60996: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60997: LD_VAR 0 18
61001: NOT
61002: IFFALSE 61022
61004: PUSH
61005: LD_INT 40
61007: PPUSH
61008: LD_VAR 0 16
61012: PPUSH
61013: CALL_OW 321
61017: PUSH
61018: LD_INT 2
61020: EQUAL
61021: AND
61022: IFFALSE 61058
61024: PUSH
61025: LD_INT 7
61027: PUSH
61028: LD_VAR 0 5
61032: IN
61033: IFTRUE 61045
61035: PUSH
61036: LD_INT 28
61038: PUSH
61039: LD_VAR 0 5
61043: IN
61044: OR
61045: IFTRUE 61057
61047: PUSH
61048: LD_INT 45
61050: PUSH
61051: LD_VAR 0 5
61055: IN
61056: OR
61057: AND
61058: IFFALSE 61312
// begin hex := GetHexInfo ( x , y ) ;
61060: LD_ADDR_VAR 0 4
61064: PUSH
61065: LD_VAR 0 10
61069: PPUSH
61070: LD_VAR 0 11
61074: PPUSH
61075: CALL_OW 546
61079: ST_TO_ADDR
// if hex [ 1 ] then
61080: LD_VAR 0 4
61084: PUSH
61085: LD_INT 1
61087: ARRAY
61088: IFFALSE 61092
// exit ;
61090: GO 61499
// height := hex [ 2 ] ;
61092: LD_ADDR_VAR 0 15
61096: PUSH
61097: LD_VAR 0 4
61101: PUSH
61102: LD_INT 2
61104: ARRAY
61105: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61106: LD_ADDR_VAR 0 14
61110: PUSH
61111: LD_INT 0
61113: PUSH
61114: LD_INT 2
61116: PUSH
61117: LD_INT 3
61119: PUSH
61120: LD_INT 5
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: LIST
61127: LIST
61128: ST_TO_ADDR
// for i in tmp do
61129: LD_ADDR_VAR 0 8
61133: PUSH
61134: LD_VAR 0 14
61138: PUSH
61139: FOR_IN
61140: IFFALSE 61310
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61142: LD_ADDR_VAR 0 9
61146: PUSH
61147: LD_VAR 0 10
61151: PPUSH
61152: LD_VAR 0 8
61156: PPUSH
61157: LD_INT 5
61159: PPUSH
61160: CALL_OW 272
61164: PUSH
61165: LD_VAR 0 11
61169: PPUSH
61170: LD_VAR 0 8
61174: PPUSH
61175: LD_INT 5
61177: PPUSH
61178: CALL_OW 273
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61187: LD_VAR 0 9
61191: PUSH
61192: LD_INT 1
61194: ARRAY
61195: PPUSH
61196: LD_VAR 0 9
61200: PUSH
61201: LD_INT 2
61203: ARRAY
61204: PPUSH
61205: CALL_OW 488
61209: IFFALSE 61308
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61211: LD_ADDR_VAR 0 4
61215: PUSH
61216: LD_VAR 0 9
61220: PUSH
61221: LD_INT 1
61223: ARRAY
61224: PPUSH
61225: LD_VAR 0 9
61229: PUSH
61230: LD_INT 2
61232: ARRAY
61233: PPUSH
61234: CALL_OW 546
61238: ST_TO_ADDR
// if hex [ 1 ] then
61239: LD_VAR 0 4
61243: PUSH
61244: LD_INT 1
61246: ARRAY
61247: IFFALSE 61251
// continue ;
61249: GO 61139
// h := hex [ 2 ] ;
61251: LD_ADDR_VAR 0 13
61255: PUSH
61256: LD_VAR 0 4
61260: PUSH
61261: LD_INT 2
61263: ARRAY
61264: ST_TO_ADDR
// if h + 7 < height then
61265: LD_VAR 0 13
61269: PUSH
61270: LD_INT 7
61272: PLUS
61273: PUSH
61274: LD_VAR 0 15
61278: LESS
61279: IFFALSE 61308
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61281: LD_ADDR_VAR 0 18
61285: PUSH
61286: LD_INT 7
61288: PUSH
61289: LD_INT 28
61291: PUSH
61292: LD_INT 45
61294: PUSH
61295: EMPTY
61296: LIST
61297: LIST
61298: LIST
61299: PUSH
61300: LD_VAR 0 12
61304: ARRAY
61305: ST_TO_ADDR
// break ;
61306: GO 61310
// end ; end ; end ;
61308: GO 61139
61310: POP
61311: POP
// end ; if not weapon then
61312: LD_VAR 0 18
61316: NOT
61317: IFFALSE 61377
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61319: LD_ADDR_VAR 0 5
61323: PUSH
61324: LD_VAR 0 5
61328: PUSH
61329: LD_INT 11
61331: PUSH
61332: LD_INT 30
61334: PUSH
61335: LD_INT 49
61337: PUSH
61338: EMPTY
61339: LIST
61340: LIST
61341: LIST
61342: DIFF
61343: ST_TO_ADDR
// if not list then
61344: LD_VAR 0 5
61348: NOT
61349: IFFALSE 61353
// exit ;
61351: GO 61499
// weapon := list [ rand ( 1 , list ) ] ;
61353: LD_ADDR_VAR 0 18
61357: PUSH
61358: LD_VAR 0 5
61362: PUSH
61363: LD_INT 1
61365: PPUSH
61366: LD_VAR 0 5
61370: PPUSH
61371: CALL_OW 12
61375: ARRAY
61376: ST_TO_ADDR
// end ; if weapon then
61377: LD_VAR 0 18
61381: IFFALSE 61499
// begin tmp := CostOfWeapon ( weapon ) ;
61383: LD_ADDR_VAR 0 14
61387: PUSH
61388: LD_VAR 0 18
61392: PPUSH
61393: CALL_OW 451
61397: ST_TO_ADDR
// j := GetBase ( tower ) ;
61398: LD_ADDR_VAR 0 9
61402: PUSH
61403: LD_VAR 0 1
61407: PPUSH
61408: CALL_OW 274
61412: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61413: LD_VAR 0 9
61417: PPUSH
61418: LD_INT 1
61420: PPUSH
61421: CALL_OW 275
61425: PUSH
61426: LD_VAR 0 14
61430: PUSH
61431: LD_INT 1
61433: ARRAY
61434: GREATEREQUAL
61435: IFFALSE 61461
61437: PUSH
61438: LD_VAR 0 9
61442: PPUSH
61443: LD_INT 2
61445: PPUSH
61446: CALL_OW 275
61450: PUSH
61451: LD_VAR 0 14
61455: PUSH
61456: LD_INT 2
61458: ARRAY
61459: GREATEREQUAL
61460: AND
61461: IFFALSE 61487
61463: PUSH
61464: LD_VAR 0 9
61468: PPUSH
61469: LD_INT 3
61471: PPUSH
61472: CALL_OW 275
61476: PUSH
61477: LD_VAR 0 14
61481: PUSH
61482: LD_INT 3
61484: ARRAY
61485: GREATEREQUAL
61486: AND
61487: IFFALSE 61499
// result := weapon ;
61489: LD_ADDR_VAR 0 3
61493: PUSH
61494: LD_VAR 0 18
61498: ST_TO_ADDR
// end ; end ;
61499: LD_VAR 0 3
61503: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61504: LD_INT 0
61506: PPUSH
61507: PPUSH
// result := true ;
61508: LD_ADDR_VAR 0 3
61512: PUSH
61513: LD_INT 1
61515: ST_TO_ADDR
// if array1 = array2 then
61516: LD_VAR 0 1
61520: PUSH
61521: LD_VAR 0 2
61525: EQUAL
61526: IFFALSE 61586
// begin for i = 1 to array1 do
61528: LD_ADDR_VAR 0 4
61532: PUSH
61533: DOUBLE
61534: LD_INT 1
61536: DEC
61537: ST_TO_ADDR
61538: LD_VAR 0 1
61542: PUSH
61543: FOR_TO
61544: IFFALSE 61582
// if array1 [ i ] <> array2 [ i ] then
61546: LD_VAR 0 1
61550: PUSH
61551: LD_VAR 0 4
61555: ARRAY
61556: PUSH
61557: LD_VAR 0 2
61561: PUSH
61562: LD_VAR 0 4
61566: ARRAY
61567: NONEQUAL
61568: IFFALSE 61580
// begin result := false ;
61570: LD_ADDR_VAR 0 3
61574: PUSH
61575: LD_INT 0
61577: ST_TO_ADDR
// break ;
61578: GO 61582
// end ;
61580: GO 61543
61582: POP
61583: POP
// end else
61584: GO 61594
// result := false ;
61586: LD_ADDR_VAR 0 3
61590: PUSH
61591: LD_INT 0
61593: ST_TO_ADDR
// end ;
61594: LD_VAR 0 3
61598: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
61599: LD_INT 0
61601: PPUSH
61602: PPUSH
// if not array1 or not array2 then
61603: LD_VAR 0 1
61607: NOT
61608: IFTRUE 61617
61610: PUSH
61611: LD_VAR 0 2
61615: NOT
61616: OR
61617: IFFALSE 61621
// exit ;
61619: GO 61685
// result := true ;
61621: LD_ADDR_VAR 0 3
61625: PUSH
61626: LD_INT 1
61628: ST_TO_ADDR
// for i = 1 to array1 do
61629: LD_ADDR_VAR 0 4
61633: PUSH
61634: DOUBLE
61635: LD_INT 1
61637: DEC
61638: ST_TO_ADDR
61639: LD_VAR 0 1
61643: PUSH
61644: FOR_TO
61645: IFFALSE 61683
// if array1 [ i ] <> array2 [ i ] then
61647: LD_VAR 0 1
61651: PUSH
61652: LD_VAR 0 4
61656: ARRAY
61657: PUSH
61658: LD_VAR 0 2
61662: PUSH
61663: LD_VAR 0 4
61667: ARRAY
61668: NONEQUAL
61669: IFFALSE 61681
// begin result := false ;
61671: LD_ADDR_VAR 0 3
61675: PUSH
61676: LD_INT 0
61678: ST_TO_ADDR
// break ;
61679: GO 61683
// end ;
61681: GO 61644
61683: POP
61684: POP
// end ;
61685: LD_VAR 0 3
61689: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
61690: LD_INT 0
61692: PPUSH
61693: PPUSH
61694: PPUSH
// pom := GetBase ( fac ) ;
61695: LD_ADDR_VAR 0 5
61699: PUSH
61700: LD_VAR 0 1
61704: PPUSH
61705: CALL_OW 274
61709: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
61710: LD_ADDR_VAR 0 4
61714: PUSH
61715: LD_VAR 0 2
61719: PUSH
61720: LD_INT 1
61722: ARRAY
61723: PPUSH
61724: LD_VAR 0 2
61728: PUSH
61729: LD_INT 2
61731: ARRAY
61732: PPUSH
61733: LD_VAR 0 2
61737: PUSH
61738: LD_INT 3
61740: ARRAY
61741: PPUSH
61742: LD_VAR 0 2
61746: PUSH
61747: LD_INT 4
61749: ARRAY
61750: PPUSH
61751: CALL_OW 449
61755: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61756: LD_ADDR_VAR 0 3
61760: PUSH
61761: LD_VAR 0 5
61765: PPUSH
61766: LD_INT 1
61768: PPUSH
61769: CALL_OW 275
61773: PUSH
61774: LD_VAR 0 4
61778: PUSH
61779: LD_INT 1
61781: ARRAY
61782: GREATEREQUAL
61783: IFFALSE 61809
61785: PUSH
61786: LD_VAR 0 5
61790: PPUSH
61791: LD_INT 2
61793: PPUSH
61794: CALL_OW 275
61798: PUSH
61799: LD_VAR 0 4
61803: PUSH
61804: LD_INT 2
61806: ARRAY
61807: GREATEREQUAL
61808: AND
61809: IFFALSE 61835
61811: PUSH
61812: LD_VAR 0 5
61816: PPUSH
61817: LD_INT 3
61819: PPUSH
61820: CALL_OW 275
61824: PUSH
61825: LD_VAR 0 4
61829: PUSH
61830: LD_INT 3
61832: ARRAY
61833: GREATEREQUAL
61834: AND
61835: ST_TO_ADDR
// end ;
61836: LD_VAR 0 3
61840: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
61841: LD_INT 0
61843: PPUSH
61844: PPUSH
61845: PPUSH
61846: PPUSH
// pom := GetBase ( building ) ;
61847: LD_ADDR_VAR 0 3
61851: PUSH
61852: LD_VAR 0 1
61856: PPUSH
61857: CALL_OW 274
61861: ST_TO_ADDR
// if not pom then
61862: LD_VAR 0 3
61866: NOT
61867: IFFALSE 61871
// exit ;
61869: GO 62045
// btype := GetBType ( building ) ;
61871: LD_ADDR_VAR 0 5
61875: PUSH
61876: LD_VAR 0 1
61880: PPUSH
61881: CALL_OW 266
61885: ST_TO_ADDR
// if btype = b_armoury then
61886: LD_VAR 0 5
61890: PUSH
61891: LD_INT 4
61893: EQUAL
61894: IFFALSE 61904
// btype := b_barracks ;
61896: LD_ADDR_VAR 0 5
61900: PUSH
61901: LD_INT 5
61903: ST_TO_ADDR
// if btype = b_depot then
61904: LD_VAR 0 5
61908: PUSH
61909: LD_INT 0
61911: EQUAL
61912: IFFALSE 61922
// btype := b_warehouse ;
61914: LD_ADDR_VAR 0 5
61918: PUSH
61919: LD_INT 1
61921: ST_TO_ADDR
// if btype = b_workshop then
61922: LD_VAR 0 5
61926: PUSH
61927: LD_INT 2
61929: EQUAL
61930: IFFALSE 61940
// btype := b_factory ;
61932: LD_ADDR_VAR 0 5
61936: PUSH
61937: LD_INT 3
61939: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61940: LD_ADDR_VAR 0 4
61944: PUSH
61945: LD_VAR 0 5
61949: PPUSH
61950: LD_VAR 0 1
61954: PPUSH
61955: CALL_OW 248
61959: PPUSH
61960: CALL_OW 450
61964: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61965: LD_ADDR_VAR 0 2
61969: PUSH
61970: LD_VAR 0 3
61974: PPUSH
61975: LD_INT 1
61977: PPUSH
61978: CALL_OW 275
61982: PUSH
61983: LD_VAR 0 4
61987: PUSH
61988: LD_INT 1
61990: ARRAY
61991: GREATEREQUAL
61992: IFFALSE 62018
61994: PUSH
61995: LD_VAR 0 3
61999: PPUSH
62000: LD_INT 2
62002: PPUSH
62003: CALL_OW 275
62007: PUSH
62008: LD_VAR 0 4
62012: PUSH
62013: LD_INT 2
62015: ARRAY
62016: GREATEREQUAL
62017: AND
62018: IFFALSE 62044
62020: PUSH
62021: LD_VAR 0 3
62025: PPUSH
62026: LD_INT 3
62028: PPUSH
62029: CALL_OW 275
62033: PUSH
62034: LD_VAR 0 4
62038: PUSH
62039: LD_INT 3
62041: ARRAY
62042: GREATEREQUAL
62043: AND
62044: ST_TO_ADDR
// end ;
62045: LD_VAR 0 2
62049: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62050: LD_INT 0
62052: PPUSH
62053: PPUSH
62054: PPUSH
// pom := GetBase ( building ) ;
62055: LD_ADDR_VAR 0 4
62059: PUSH
62060: LD_VAR 0 1
62064: PPUSH
62065: CALL_OW 274
62069: ST_TO_ADDR
// if not pom then
62070: LD_VAR 0 4
62074: NOT
62075: IFFALSE 62079
// exit ;
62077: GO 62184
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62079: LD_ADDR_VAR 0 5
62083: PUSH
62084: LD_VAR 0 2
62088: PPUSH
62089: LD_VAR 0 1
62093: PPUSH
62094: CALL_OW 248
62098: PPUSH
62099: CALL_OW 450
62103: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62104: LD_ADDR_VAR 0 3
62108: PUSH
62109: LD_VAR 0 4
62113: PPUSH
62114: LD_INT 1
62116: PPUSH
62117: CALL_OW 275
62121: PUSH
62122: LD_VAR 0 5
62126: PUSH
62127: LD_INT 1
62129: ARRAY
62130: GREATEREQUAL
62131: IFFALSE 62157
62133: PUSH
62134: LD_VAR 0 4
62138: PPUSH
62139: LD_INT 2
62141: PPUSH
62142: CALL_OW 275
62146: PUSH
62147: LD_VAR 0 5
62151: PUSH
62152: LD_INT 2
62154: ARRAY
62155: GREATEREQUAL
62156: AND
62157: IFFALSE 62183
62159: PUSH
62160: LD_VAR 0 4
62164: PPUSH
62165: LD_INT 3
62167: PPUSH
62168: CALL_OW 275
62172: PUSH
62173: LD_VAR 0 5
62177: PUSH
62178: LD_INT 3
62180: ARRAY
62181: GREATEREQUAL
62182: AND
62183: ST_TO_ADDR
// end ;
62184: LD_VAR 0 3
62188: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
62189: LD_INT 0
62191: PPUSH
62192: PPUSH
62193: PPUSH
62194: PPUSH
62195: PPUSH
62196: PPUSH
62197: PPUSH
62198: PPUSH
62199: PPUSH
62200: PPUSH
62201: PPUSH
// result := false ;
62202: LD_ADDR_VAR 0 8
62206: PUSH
62207: LD_INT 0
62209: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
62210: LD_VAR 0 5
62214: NOT
62215: IFTRUE 62224
62217: PUSH
62218: LD_VAR 0 1
62222: NOT
62223: OR
62224: IFTRUE 62233
62226: PUSH
62227: LD_VAR 0 2
62231: NOT
62232: OR
62233: IFTRUE 62242
62235: PUSH
62236: LD_VAR 0 3
62240: NOT
62241: OR
62242: IFFALSE 62246
// exit ;
62244: GO 63072
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
62246: LD_ADDR_VAR 0 14
62250: PUSH
62251: LD_VAR 0 1
62255: PPUSH
62256: LD_VAR 0 2
62260: PPUSH
62261: LD_VAR 0 3
62265: PPUSH
62266: LD_VAR 0 4
62270: PPUSH
62271: LD_VAR 0 5
62275: PUSH
62276: LD_INT 1
62278: ARRAY
62279: PPUSH
62280: CALL_OW 248
62284: PPUSH
62285: LD_INT 0
62287: PPUSH
62288: CALL 64353 0 6
62292: ST_TO_ADDR
// if not hexes then
62293: LD_VAR 0 14
62297: NOT
62298: IFFALSE 62302
// exit ;
62300: GO 63072
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62302: LD_ADDR_VAR 0 17
62306: PUSH
62307: LD_VAR 0 5
62311: PPUSH
62312: LD_INT 22
62314: PUSH
62315: LD_VAR 0 13
62319: PPUSH
62320: CALL_OW 255
62324: PUSH
62325: EMPTY
62326: LIST
62327: LIST
62328: PUSH
62329: LD_INT 2
62331: PUSH
62332: LD_INT 30
62334: PUSH
62335: LD_INT 0
62337: PUSH
62338: EMPTY
62339: LIST
62340: LIST
62341: PUSH
62342: LD_INT 30
62344: PUSH
62345: LD_INT 1
62347: PUSH
62348: EMPTY
62349: LIST
62350: LIST
62351: PUSH
62352: EMPTY
62353: LIST
62354: LIST
62355: LIST
62356: PUSH
62357: EMPTY
62358: LIST
62359: LIST
62360: PPUSH
62361: CALL_OW 72
62365: ST_TO_ADDR
// for i = 1 to hexes do
62366: LD_ADDR_VAR 0 9
62370: PUSH
62371: DOUBLE
62372: LD_INT 1
62374: DEC
62375: ST_TO_ADDR
62376: LD_VAR 0 14
62380: PUSH
62381: FOR_TO
62382: IFFALSE 63070
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62384: LD_ADDR_VAR 0 13
62388: PUSH
62389: LD_VAR 0 14
62393: PUSH
62394: LD_VAR 0 9
62398: ARRAY
62399: PUSH
62400: LD_INT 1
62402: ARRAY
62403: PPUSH
62404: LD_VAR 0 14
62408: PUSH
62409: LD_VAR 0 9
62413: ARRAY
62414: PUSH
62415: LD_INT 2
62417: ARRAY
62418: PPUSH
62419: CALL_OW 428
62423: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62424: LD_VAR 0 14
62428: PUSH
62429: LD_VAR 0 9
62433: ARRAY
62434: PUSH
62435: LD_INT 1
62437: ARRAY
62438: PPUSH
62439: LD_VAR 0 14
62443: PUSH
62444: LD_VAR 0 9
62448: ARRAY
62449: PUSH
62450: LD_INT 2
62452: ARRAY
62453: PPUSH
62454: CALL_OW 351
62458: IFTRUE 62497
62460: PUSH
62461: LD_VAR 0 14
62465: PUSH
62466: LD_VAR 0 9
62470: ARRAY
62471: PUSH
62472: LD_INT 1
62474: ARRAY
62475: PPUSH
62476: LD_VAR 0 14
62480: PUSH
62481: LD_VAR 0 9
62485: ARRAY
62486: PUSH
62487: LD_INT 2
62489: ARRAY
62490: PPUSH
62491: CALL_OW 488
62495: NOT
62496: OR
62497: IFTRUE 62514
62499: PUSH
62500: LD_VAR 0 13
62504: PPUSH
62505: CALL_OW 247
62509: PUSH
62510: LD_INT 3
62512: EQUAL
62513: OR
62514: IFFALSE 62520
// exit ;
62516: POP
62517: POP
62518: GO 63072
// if not tmp then
62520: LD_VAR 0 13
62524: NOT
62525: IFFALSE 62529
// continue ;
62527: GO 62381
// result := true ;
62529: LD_ADDR_VAR 0 8
62533: PUSH
62534: LD_INT 1
62536: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
62537: LD_VAR 0 6
62541: IFFALSE 62558
62543: PUSH
62544: LD_VAR 0 13
62548: PPUSH
62549: CALL_OW 247
62553: PUSH
62554: LD_INT 2
62556: EQUAL
62557: AND
62558: IFFALSE 62575
62560: PUSH
62561: LD_VAR 0 13
62565: PPUSH
62566: CALL_OW 263
62570: PUSH
62571: LD_INT 1
62573: EQUAL
62574: AND
62575: IFFALSE 62739
// begin if IsDrivenBy ( tmp ) then
62577: LD_VAR 0 13
62581: PPUSH
62582: CALL_OW 311
62586: IFFALSE 62590
// continue ;
62588: GO 62381
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
62590: LD_VAR 0 6
62594: PPUSH
62595: LD_INT 3
62597: PUSH
62598: LD_INT 60
62600: PUSH
62601: EMPTY
62602: LIST
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: LD_INT 3
62610: PUSH
62611: LD_INT 55
62613: PUSH
62614: EMPTY
62615: LIST
62616: PUSH
62617: EMPTY
62618: LIST
62619: LIST
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: PPUSH
62625: CALL_OW 72
62629: IFFALSE 62737
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
62631: LD_ADDR_VAR 0 18
62635: PUSH
62636: LD_VAR 0 6
62640: PPUSH
62641: LD_INT 3
62643: PUSH
62644: LD_INT 60
62646: PUSH
62647: EMPTY
62648: LIST
62649: PUSH
62650: EMPTY
62651: LIST
62652: LIST
62653: PUSH
62654: LD_INT 3
62656: PUSH
62657: LD_INT 55
62659: PUSH
62660: EMPTY
62661: LIST
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: PUSH
62667: EMPTY
62668: LIST
62669: LIST
62670: PPUSH
62671: CALL_OW 72
62675: PUSH
62676: LD_INT 1
62678: ARRAY
62679: ST_TO_ADDR
// if IsInUnit ( driver ) then
62680: LD_VAR 0 18
62684: PPUSH
62685: CALL_OW 310
62689: IFFALSE 62700
// ComExit ( driver ) ;
62691: LD_VAR 0 18
62695: PPUSH
62696: CALL 88353 0 1
// AddComEnterUnit ( driver , tmp ) ;
62700: LD_VAR 0 18
62704: PPUSH
62705: LD_VAR 0 13
62709: PPUSH
62710: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
62714: LD_VAR 0 18
62718: PPUSH
62719: LD_VAR 0 7
62723: PPUSH
62724: CALL_OW 173
// AddComExitVehicle ( driver ) ;
62728: LD_VAR 0 18
62732: PPUSH
62733: CALL_OW 181
// end ; continue ;
62737: GO 62381
// end ; if not cleaners or not tmp in cleaners then
62739: LD_VAR 0 6
62743: NOT
62744: IFTRUE 62759
62746: PUSH
62747: LD_VAR 0 13
62751: PUSH
62752: LD_VAR 0 6
62756: IN
62757: NOT
62758: OR
62759: IFFALSE 63068
// begin if dep then
62761: LD_VAR 0 17
62765: IFFALSE 62901
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62767: LD_ADDR_VAR 0 16
62771: PUSH
62772: LD_VAR 0 17
62776: PUSH
62777: LD_INT 1
62779: ARRAY
62780: PPUSH
62781: CALL_OW 250
62785: PPUSH
62786: LD_VAR 0 17
62790: PUSH
62791: LD_INT 1
62793: ARRAY
62794: PPUSH
62795: CALL_OW 254
62799: PPUSH
62800: LD_INT 5
62802: PPUSH
62803: CALL_OW 272
62807: PUSH
62808: LD_VAR 0 17
62812: PUSH
62813: LD_INT 1
62815: ARRAY
62816: PPUSH
62817: CALL_OW 251
62821: PPUSH
62822: LD_VAR 0 17
62826: PUSH
62827: LD_INT 1
62829: ARRAY
62830: PPUSH
62831: CALL_OW 254
62835: PPUSH
62836: LD_INT 5
62838: PPUSH
62839: CALL_OW 273
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62848: LD_VAR 0 16
62852: PUSH
62853: LD_INT 1
62855: ARRAY
62856: PPUSH
62857: LD_VAR 0 16
62861: PUSH
62862: LD_INT 2
62864: ARRAY
62865: PPUSH
62866: CALL_OW 488
62870: IFFALSE 62901
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62872: LD_VAR 0 13
62876: PPUSH
62877: LD_VAR 0 16
62881: PUSH
62882: LD_INT 1
62884: ARRAY
62885: PPUSH
62886: LD_VAR 0 16
62890: PUSH
62891: LD_INT 2
62893: ARRAY
62894: PPUSH
62895: CALL_OW 111
// continue ;
62899: GO 62381
// end ; end ; r := GetDir ( tmp ) ;
62901: LD_ADDR_VAR 0 15
62905: PUSH
62906: LD_VAR 0 13
62910: PPUSH
62911: CALL_OW 254
62915: ST_TO_ADDR
// if r = 5 then
62916: LD_VAR 0 15
62920: PUSH
62921: LD_INT 5
62923: EQUAL
62924: IFFALSE 62934
// r := 0 ;
62926: LD_ADDR_VAR 0 15
62930: PUSH
62931: LD_INT 0
62933: ST_TO_ADDR
// for j = r to 5 do
62934: LD_ADDR_VAR 0 10
62938: PUSH
62939: DOUBLE
62940: LD_VAR 0 15
62944: DEC
62945: ST_TO_ADDR
62946: LD_INT 5
62948: PUSH
62949: FOR_TO
62950: IFFALSE 63066
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62952: LD_ADDR_VAR 0 11
62956: PUSH
62957: LD_VAR 0 13
62961: PPUSH
62962: CALL_OW 250
62966: PPUSH
62967: LD_VAR 0 10
62971: PPUSH
62972: LD_INT 2
62974: PPUSH
62975: CALL_OW 272
62979: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62980: LD_ADDR_VAR 0 12
62984: PUSH
62985: LD_VAR 0 13
62989: PPUSH
62990: CALL_OW 251
62994: PPUSH
62995: LD_VAR 0 10
62999: PPUSH
63000: LD_INT 2
63002: PPUSH
63003: CALL_OW 273
63007: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63008: LD_VAR 0 11
63012: PPUSH
63013: LD_VAR 0 12
63017: PPUSH
63018: CALL_OW 488
63022: IFFALSE 63041
63024: PUSH
63025: LD_VAR 0 11
63029: PPUSH
63030: LD_VAR 0 12
63034: PPUSH
63035: CALL_OW 428
63039: NOT
63040: AND
63041: IFFALSE 63064
// begin ComMoveXY ( tmp , _x , _y ) ;
63043: LD_VAR 0 13
63047: PPUSH
63048: LD_VAR 0 11
63052: PPUSH
63053: LD_VAR 0 12
63057: PPUSH
63058: CALL_OW 111
// break ;
63062: GO 63066
// end ; end ;
63064: GO 62949
63066: POP
63067: POP
// end ; end ;
63068: GO 62381
63070: POP
63071: POP
// end ;
63072: LD_VAR 0 8
63076: RET
// export function BuildingTechInvented ( side , btype ) ; begin
63077: LD_INT 0
63079: PPUSH
// result := true ;
63080: LD_ADDR_VAR 0 3
63084: PUSH
63085: LD_INT 1
63087: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
63088: LD_VAR 0 2
63092: PUSH
63093: LD_INT 24
63095: DOUBLE
63096: EQUAL
63097: IFTRUE 63107
63099: LD_INT 33
63101: DOUBLE
63102: EQUAL
63103: IFTRUE 63107
63105: GO 63132
63107: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
63108: LD_ADDR_VAR 0 3
63112: PUSH
63113: LD_INT 32
63115: PPUSH
63116: LD_VAR 0 1
63120: PPUSH
63121: CALL_OW 321
63125: PUSH
63126: LD_INT 2
63128: EQUAL
63129: ST_TO_ADDR
63130: GO 63448
63132: LD_INT 20
63134: DOUBLE
63135: EQUAL
63136: IFTRUE 63140
63138: GO 63165
63140: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
63141: LD_ADDR_VAR 0 3
63145: PUSH
63146: LD_INT 6
63148: PPUSH
63149: LD_VAR 0 1
63153: PPUSH
63154: CALL_OW 321
63158: PUSH
63159: LD_INT 2
63161: EQUAL
63162: ST_TO_ADDR
63163: GO 63448
63165: LD_INT 22
63167: DOUBLE
63168: EQUAL
63169: IFTRUE 63179
63171: LD_INT 36
63173: DOUBLE
63174: EQUAL
63175: IFTRUE 63179
63177: GO 63204
63179: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
63180: LD_ADDR_VAR 0 3
63184: PUSH
63185: LD_INT 15
63187: PPUSH
63188: LD_VAR 0 1
63192: PPUSH
63193: CALL_OW 321
63197: PUSH
63198: LD_INT 2
63200: EQUAL
63201: ST_TO_ADDR
63202: GO 63448
63204: LD_INT 30
63206: DOUBLE
63207: EQUAL
63208: IFTRUE 63212
63210: GO 63237
63212: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
63213: LD_ADDR_VAR 0 3
63217: PUSH
63218: LD_INT 20
63220: PPUSH
63221: LD_VAR 0 1
63225: PPUSH
63226: CALL_OW 321
63230: PUSH
63231: LD_INT 2
63233: EQUAL
63234: ST_TO_ADDR
63235: GO 63448
63237: LD_INT 28
63239: DOUBLE
63240: EQUAL
63241: IFTRUE 63251
63243: LD_INT 21
63245: DOUBLE
63246: EQUAL
63247: IFTRUE 63251
63249: GO 63276
63251: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
63252: LD_ADDR_VAR 0 3
63256: PUSH
63257: LD_INT 21
63259: PPUSH
63260: LD_VAR 0 1
63264: PPUSH
63265: CALL_OW 321
63269: PUSH
63270: LD_INT 2
63272: EQUAL
63273: ST_TO_ADDR
63274: GO 63448
63276: LD_INT 16
63278: DOUBLE
63279: EQUAL
63280: IFTRUE 63284
63282: GO 63309
63284: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
63285: LD_ADDR_VAR 0 3
63289: PUSH
63290: LD_INT 84
63292: PPUSH
63293: LD_VAR 0 1
63297: PPUSH
63298: CALL_OW 321
63302: PUSH
63303: LD_INT 2
63305: EQUAL
63306: ST_TO_ADDR
63307: GO 63448
63309: LD_INT 19
63311: DOUBLE
63312: EQUAL
63313: IFTRUE 63323
63315: LD_INT 23
63317: DOUBLE
63318: EQUAL
63319: IFTRUE 63323
63321: GO 63348
63323: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
63324: LD_ADDR_VAR 0 3
63328: PUSH
63329: LD_INT 83
63331: PPUSH
63332: LD_VAR 0 1
63336: PPUSH
63337: CALL_OW 321
63341: PUSH
63342: LD_INT 2
63344: EQUAL
63345: ST_TO_ADDR
63346: GO 63448
63348: LD_INT 17
63350: DOUBLE
63351: EQUAL
63352: IFTRUE 63356
63354: GO 63381
63356: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
63357: LD_ADDR_VAR 0 3
63361: PUSH
63362: LD_INT 39
63364: PPUSH
63365: LD_VAR 0 1
63369: PPUSH
63370: CALL_OW 321
63374: PUSH
63375: LD_INT 2
63377: EQUAL
63378: ST_TO_ADDR
63379: GO 63448
63381: LD_INT 18
63383: DOUBLE
63384: EQUAL
63385: IFTRUE 63389
63387: GO 63414
63389: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
63390: LD_ADDR_VAR 0 3
63394: PUSH
63395: LD_INT 40
63397: PPUSH
63398: LD_VAR 0 1
63402: PPUSH
63403: CALL_OW 321
63407: PUSH
63408: LD_INT 2
63410: EQUAL
63411: ST_TO_ADDR
63412: GO 63448
63414: LD_INT 27
63416: DOUBLE
63417: EQUAL
63418: IFTRUE 63422
63420: GO 63447
63422: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
63423: LD_ADDR_VAR 0 3
63427: PUSH
63428: LD_INT 35
63430: PPUSH
63431: LD_VAR 0 1
63435: PPUSH
63436: CALL_OW 321
63440: PUSH
63441: LD_INT 2
63443: EQUAL
63444: ST_TO_ADDR
63445: GO 63448
63447: POP
// end ;
63448: LD_VAR 0 3
63452: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
63453: LD_INT 0
63455: PPUSH
63456: PPUSH
63457: PPUSH
63458: PPUSH
63459: PPUSH
63460: PPUSH
63461: PPUSH
63462: PPUSH
63463: PPUSH
63464: PPUSH
63465: PPUSH
// result := false ;
63466: LD_ADDR_VAR 0 6
63470: PUSH
63471: LD_INT 0
63473: ST_TO_ADDR
// if btype = b_depot then
63474: LD_VAR 0 2
63478: PUSH
63479: LD_INT 0
63481: EQUAL
63482: IFFALSE 63494
// begin result := true ;
63484: LD_ADDR_VAR 0 6
63488: PUSH
63489: LD_INT 1
63491: ST_TO_ADDR
// exit ;
63492: GO 64348
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63494: LD_VAR 0 1
63498: NOT
63499: IFTRUE 63524
63501: PUSH
63502: LD_VAR 0 1
63506: PPUSH
63507: CALL_OW 266
63511: PUSH
63512: LD_INT 0
63514: PUSH
63515: LD_INT 1
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: IN
63522: NOT
63523: OR
63524: IFTRUE 63533
63526: PUSH
63527: LD_VAR 0 2
63531: NOT
63532: OR
63533: IFTRUE 63569
63535: PUSH
63536: LD_VAR 0 5
63540: PUSH
63541: LD_INT 0
63543: PUSH
63544: LD_INT 1
63546: PUSH
63547: LD_INT 2
63549: PUSH
63550: LD_INT 3
63552: PUSH
63553: LD_INT 4
63555: PUSH
63556: LD_INT 5
63558: PUSH
63559: EMPTY
63560: LIST
63561: LIST
63562: LIST
63563: LIST
63564: LIST
63565: LIST
63566: IN
63567: NOT
63568: OR
63569: IFTRUE 63588
63571: PUSH
63572: LD_VAR 0 3
63576: PPUSH
63577: LD_VAR 0 4
63581: PPUSH
63582: CALL_OW 488
63586: NOT
63587: OR
63588: IFFALSE 63592
// exit ;
63590: GO 64348
// side := GetSide ( depot ) ;
63592: LD_ADDR_VAR 0 9
63596: PUSH
63597: LD_VAR 0 1
63601: PPUSH
63602: CALL_OW 255
63606: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
63607: LD_VAR 0 9
63611: PPUSH
63612: LD_VAR 0 2
63616: PPUSH
63617: CALL 63077 0 2
63621: NOT
63622: IFFALSE 63626
// exit ;
63624: GO 64348
// pom := GetBase ( depot ) ;
63626: LD_ADDR_VAR 0 10
63630: PUSH
63631: LD_VAR 0 1
63635: PPUSH
63636: CALL_OW 274
63640: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63641: LD_ADDR_VAR 0 11
63645: PUSH
63646: LD_VAR 0 2
63650: PPUSH
63651: LD_VAR 0 1
63655: PPUSH
63656: CALL_OW 248
63660: PPUSH
63661: CALL_OW 450
63665: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63666: LD_VAR 0 10
63670: PPUSH
63671: LD_INT 1
63673: PPUSH
63674: CALL_OW 275
63678: PUSH
63679: LD_VAR 0 11
63683: PUSH
63684: LD_INT 1
63686: ARRAY
63687: GREATEREQUAL
63688: IFFALSE 63714
63690: PUSH
63691: LD_VAR 0 10
63695: PPUSH
63696: LD_INT 2
63698: PPUSH
63699: CALL_OW 275
63703: PUSH
63704: LD_VAR 0 11
63708: PUSH
63709: LD_INT 2
63711: ARRAY
63712: GREATEREQUAL
63713: AND
63714: IFFALSE 63740
63716: PUSH
63717: LD_VAR 0 10
63721: PPUSH
63722: LD_INT 3
63724: PPUSH
63725: CALL_OW 275
63729: PUSH
63730: LD_VAR 0 11
63734: PUSH
63735: LD_INT 3
63737: ARRAY
63738: GREATEREQUAL
63739: AND
63740: NOT
63741: IFFALSE 63745
// exit ;
63743: GO 64348
// if GetBType ( depot ) = b_depot then
63745: LD_VAR 0 1
63749: PPUSH
63750: CALL_OW 266
63754: PUSH
63755: LD_INT 0
63757: EQUAL
63758: IFFALSE 63770
// dist := 28 else
63760: LD_ADDR_VAR 0 14
63764: PUSH
63765: LD_INT 28
63767: ST_TO_ADDR
63768: GO 63778
// dist := 36 ;
63770: LD_ADDR_VAR 0 14
63774: PUSH
63775: LD_INT 36
63777: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63778: LD_VAR 0 1
63782: PPUSH
63783: LD_VAR 0 3
63787: PPUSH
63788: LD_VAR 0 4
63792: PPUSH
63793: CALL_OW 297
63797: PUSH
63798: LD_VAR 0 14
63802: GREATER
63803: IFFALSE 63807
// exit ;
63805: GO 64348
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63807: LD_ADDR_VAR 0 12
63811: PUSH
63812: LD_VAR 0 2
63816: PPUSH
63817: LD_VAR 0 3
63821: PPUSH
63822: LD_VAR 0 4
63826: PPUSH
63827: LD_VAR 0 5
63831: PPUSH
63832: LD_VAR 0 1
63836: PPUSH
63837: CALL_OW 248
63841: PPUSH
63842: LD_INT 0
63844: PPUSH
63845: CALL 64353 0 6
63849: ST_TO_ADDR
// if not hexes then
63850: LD_VAR 0 12
63854: NOT
63855: IFFALSE 63859
// exit ;
63857: GO 64348
// hex := GetHexInfo ( x , y ) ;
63859: LD_ADDR_VAR 0 15
63863: PUSH
63864: LD_VAR 0 3
63868: PPUSH
63869: LD_VAR 0 4
63873: PPUSH
63874: CALL_OW 546
63878: ST_TO_ADDR
// if hex [ 1 ] then
63879: LD_VAR 0 15
63883: PUSH
63884: LD_INT 1
63886: ARRAY
63887: IFFALSE 63891
// exit ;
63889: GO 64348
// height := hex [ 2 ] ;
63891: LD_ADDR_VAR 0 13
63895: PUSH
63896: LD_VAR 0 15
63900: PUSH
63901: LD_INT 2
63903: ARRAY
63904: ST_TO_ADDR
// for i = 1 to hexes do
63905: LD_ADDR_VAR 0 7
63909: PUSH
63910: DOUBLE
63911: LD_INT 1
63913: DEC
63914: ST_TO_ADDR
63915: LD_VAR 0 12
63919: PUSH
63920: FOR_TO
63921: IFFALSE 64265
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63923: LD_VAR 0 12
63927: PUSH
63928: LD_VAR 0 7
63932: ARRAY
63933: PUSH
63934: LD_INT 1
63936: ARRAY
63937: PPUSH
63938: LD_VAR 0 12
63942: PUSH
63943: LD_VAR 0 7
63947: ARRAY
63948: PUSH
63949: LD_INT 2
63951: ARRAY
63952: PPUSH
63953: CALL_OW 488
63957: NOT
63958: IFTRUE 64000
63960: PUSH
63961: LD_VAR 0 12
63965: PUSH
63966: LD_VAR 0 7
63970: ARRAY
63971: PUSH
63972: LD_INT 1
63974: ARRAY
63975: PPUSH
63976: LD_VAR 0 12
63980: PUSH
63981: LD_VAR 0 7
63985: ARRAY
63986: PUSH
63987: LD_INT 2
63989: ARRAY
63990: PPUSH
63991: CALL_OW 428
63995: PUSH
63996: LD_INT 0
63998: GREATER
63999: OR
64000: IFTRUE 64038
64002: PUSH
64003: LD_VAR 0 12
64007: PUSH
64008: LD_VAR 0 7
64012: ARRAY
64013: PUSH
64014: LD_INT 1
64016: ARRAY
64017: PPUSH
64018: LD_VAR 0 12
64022: PUSH
64023: LD_VAR 0 7
64027: ARRAY
64028: PUSH
64029: LD_INT 2
64031: ARRAY
64032: PPUSH
64033: CALL_OW 351
64037: OR
64038: IFFALSE 64044
// exit ;
64040: POP
64041: POP
64042: GO 64348
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64044: LD_ADDR_VAR 0 8
64048: PUSH
64049: LD_VAR 0 12
64053: PUSH
64054: LD_VAR 0 7
64058: ARRAY
64059: PUSH
64060: LD_INT 1
64062: ARRAY
64063: PPUSH
64064: LD_VAR 0 12
64068: PUSH
64069: LD_VAR 0 7
64073: ARRAY
64074: PUSH
64075: LD_INT 2
64077: ARRAY
64078: PPUSH
64079: CALL_OW 546
64083: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64084: LD_VAR 0 8
64088: PUSH
64089: LD_INT 1
64091: ARRAY
64092: IFTRUE 64114
64094: PUSH
64095: LD_VAR 0 8
64099: PUSH
64100: LD_INT 2
64102: ARRAY
64103: PUSH
64104: LD_VAR 0 13
64108: PUSH
64109: LD_INT 2
64111: PLUS
64112: GREATER
64113: OR
64114: IFTRUE 64136
64116: PUSH
64117: LD_VAR 0 8
64121: PUSH
64122: LD_INT 2
64124: ARRAY
64125: PUSH
64126: LD_VAR 0 13
64130: PUSH
64131: LD_INT 2
64133: MINUS
64134: LESS
64135: OR
64136: IFTRUE 64204
64138: PUSH
64139: LD_VAR 0 8
64143: PUSH
64144: LD_INT 3
64146: ARRAY
64147: PUSH
64148: LD_INT 0
64150: PUSH
64151: LD_INT 8
64153: PUSH
64154: LD_INT 9
64156: PUSH
64157: LD_INT 10
64159: PUSH
64160: LD_INT 11
64162: PUSH
64163: LD_INT 12
64165: PUSH
64166: LD_INT 13
64168: PUSH
64169: LD_INT 16
64171: PUSH
64172: LD_INT 17
64174: PUSH
64175: LD_INT 18
64177: PUSH
64178: LD_INT 19
64180: PUSH
64181: LD_INT 20
64183: PUSH
64184: LD_INT 21
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: LIST
64191: LIST
64192: LIST
64193: LIST
64194: LIST
64195: LIST
64196: LIST
64197: LIST
64198: LIST
64199: LIST
64200: LIST
64201: IN
64202: NOT
64203: OR
64204: IFTRUE 64217
64206: PUSH
64207: LD_VAR 0 8
64211: PUSH
64212: LD_INT 5
64214: ARRAY
64215: NOT
64216: OR
64217: IFTRUE 64257
64219: PUSH
64220: LD_VAR 0 8
64224: PUSH
64225: LD_INT 6
64227: ARRAY
64228: PUSH
64229: LD_INT 1
64231: PUSH
64232: LD_INT 2
64234: PUSH
64235: LD_INT 7
64237: PUSH
64238: LD_INT 9
64240: PUSH
64241: LD_INT 10
64243: PUSH
64244: LD_INT 11
64246: PUSH
64247: EMPTY
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: IN
64255: NOT
64256: OR
64257: IFFALSE 64263
// exit ;
64259: POP
64260: POP
64261: GO 64348
// end ;
64263: GO 63920
64265: POP
64266: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
64267: LD_VAR 0 9
64271: PPUSH
64272: LD_VAR 0 3
64276: PPUSH
64277: LD_VAR 0 4
64281: PPUSH
64282: LD_INT 20
64284: PPUSH
64285: CALL 56167 0 4
64289: PUSH
64290: LD_INT 4
64292: ARRAY
64293: IFFALSE 64297
// exit ;
64295: GO 64348
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
64297: LD_VAR 0 2
64301: PUSH
64302: LD_INT 29
64304: PUSH
64305: LD_INT 30
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: IN
64312: IFFALSE 64336
64314: PUSH
64315: LD_VAR 0 3
64319: PPUSH
64320: LD_VAR 0 4
64324: PPUSH
64325: LD_VAR 0 9
64329: PPUSH
64330: CALL_OW 440
64334: NOT
64335: AND
64336: IFFALSE 64340
// exit ;
64338: GO 64348
// result := true ;
64340: LD_ADDR_VAR 0 6
64344: PUSH
64345: LD_INT 1
64347: ST_TO_ADDR
// end ;
64348: LD_VAR 0 6
64352: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
64353: LD_INT 0
64355: PPUSH
64356: PPUSH
64357: PPUSH
64358: PPUSH
64359: PPUSH
64360: PPUSH
64361: PPUSH
64362: PPUSH
64363: PPUSH
64364: PPUSH
64365: PPUSH
64366: PPUSH
64367: PPUSH
64368: PPUSH
64369: PPUSH
64370: PPUSH
64371: PPUSH
64372: PPUSH
64373: PPUSH
64374: PPUSH
64375: PPUSH
64376: PPUSH
64377: PPUSH
64378: PPUSH
64379: PPUSH
64380: PPUSH
64381: PPUSH
64382: PPUSH
64383: PPUSH
64384: PPUSH
64385: PPUSH
64386: PPUSH
64387: PPUSH
64388: PPUSH
64389: PPUSH
64390: PPUSH
64391: PPUSH
64392: PPUSH
64393: PPUSH
64394: PPUSH
64395: PPUSH
64396: PPUSH
64397: PPUSH
64398: PPUSH
64399: PPUSH
64400: PPUSH
64401: PPUSH
64402: PPUSH
64403: PPUSH
64404: PPUSH
64405: PPUSH
64406: PPUSH
64407: PPUSH
64408: PPUSH
64409: PPUSH
64410: PPUSH
64411: PPUSH
64412: PPUSH
// result = [ ] ;
64413: LD_ADDR_VAR 0 7
64417: PUSH
64418: EMPTY
64419: ST_TO_ADDR
// temp_list = [ ] ;
64420: LD_ADDR_VAR 0 9
64424: PUSH
64425: EMPTY
64426: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64427: LD_VAR 0 4
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: LD_INT 1
64437: PUSH
64438: LD_INT 2
64440: PUSH
64441: LD_INT 3
64443: PUSH
64444: LD_INT 4
64446: PUSH
64447: LD_INT 5
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: IN
64458: NOT
64459: IFTRUE 64502
64461: PUSH
64462: LD_VAR 0 1
64466: PUSH
64467: LD_INT 0
64469: PUSH
64470: LD_INT 1
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: IN
64477: IFFALSE 64501
64479: PUSH
64480: LD_VAR 0 5
64484: PUSH
64485: LD_INT 1
64487: PUSH
64488: LD_INT 2
64490: PUSH
64491: LD_INT 3
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: LIST
64498: IN
64499: NOT
64500: AND
64501: OR
64502: IFFALSE 64506
// exit ;
64504: GO 82905
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64506: LD_VAR 0 1
64510: PUSH
64511: LD_INT 6
64513: PUSH
64514: LD_INT 7
64516: PUSH
64517: LD_INT 8
64519: PUSH
64520: LD_INT 13
64522: PUSH
64523: LD_INT 12
64525: PUSH
64526: LD_INT 15
64528: PUSH
64529: LD_INT 11
64531: PUSH
64532: LD_INT 14
64534: PUSH
64535: LD_INT 10
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: IN
64549: IFFALSE 64559
// btype = b_lab ;
64551: LD_ADDR_VAR 0 1
64555: PUSH
64556: LD_INT 6
64558: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64559: LD_VAR 0 6
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: LD_INT 1
64569: PUSH
64570: LD_INT 2
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: LIST
64577: IN
64578: NOT
64579: IFTRUE 64647
64581: PUSH
64582: LD_VAR 0 1
64586: PUSH
64587: LD_INT 0
64589: PUSH
64590: LD_INT 1
64592: PUSH
64593: LD_INT 2
64595: PUSH
64596: LD_INT 3
64598: PUSH
64599: LD_INT 6
64601: PUSH
64602: LD_INT 36
64604: PUSH
64605: LD_INT 4
64607: PUSH
64608: LD_INT 5
64610: PUSH
64611: LD_INT 31
64613: PUSH
64614: LD_INT 32
64616: PUSH
64617: LD_INT 33
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: LIST
64624: LIST
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: LIST
64632: IN
64633: NOT
64634: IFFALSE 64646
64636: PUSH
64637: LD_VAR 0 6
64641: PUSH
64642: LD_INT 1
64644: EQUAL
64645: AND
64646: OR
64647: IFTRUE 64679
64649: PUSH
64650: LD_VAR 0 1
64654: PUSH
64655: LD_INT 2
64657: PUSH
64658: LD_INT 3
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: IN
64665: NOT
64666: IFFALSE 64678
64668: PUSH
64669: LD_VAR 0 6
64673: PUSH
64674: LD_INT 2
64676: EQUAL
64677: AND
64678: OR
64679: IFFALSE 64689
// mode = 0 ;
64681: LD_ADDR_VAR 0 6
64685: PUSH
64686: LD_INT 0
64688: ST_TO_ADDR
// case mode of 0 :
64689: LD_VAR 0 6
64693: PUSH
64694: LD_INT 0
64696: DOUBLE
64697: EQUAL
64698: IFTRUE 64702
64700: GO 76155
64702: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64703: LD_ADDR_VAR 0 11
64707: PUSH
64708: LD_INT 0
64710: PUSH
64711: LD_INT 0
64713: PUSH
64714: EMPTY
64715: LIST
64716: LIST
64717: PUSH
64718: LD_INT 0
64720: PUSH
64721: LD_INT 1
64723: NEG
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: PUSH
64729: LD_INT 1
64731: PUSH
64732: LD_INT 0
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: PUSH
64739: LD_INT 1
64741: PUSH
64742: LD_INT 1
64744: PUSH
64745: EMPTY
64746: LIST
64747: LIST
64748: PUSH
64749: LD_INT 0
64751: PUSH
64752: LD_INT 1
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: PUSH
64759: LD_INT 1
64761: NEG
64762: PUSH
64763: LD_INT 0
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PUSH
64770: LD_INT 1
64772: NEG
64773: PUSH
64774: LD_INT 1
64776: NEG
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: PUSH
64782: LD_INT 1
64784: NEG
64785: PUSH
64786: LD_INT 2
64788: NEG
64789: PUSH
64790: EMPTY
64791: LIST
64792: LIST
64793: PUSH
64794: LD_INT 0
64796: PUSH
64797: LD_INT 2
64799: NEG
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 1
64807: PUSH
64808: LD_INT 1
64810: NEG
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: LD_INT 2
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 0
64828: PUSH
64829: LD_INT 2
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: PUSH
64836: LD_INT 1
64838: NEG
64839: PUSH
64840: LD_INT 1
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 1
64849: PUSH
64850: LD_INT 3
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 0
64859: PUSH
64860: LD_INT 3
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 1
64869: NEG
64870: PUSH
64871: LD_INT 2
64873: PUSH
64874: EMPTY
64875: LIST
64876: LIST
64877: PUSH
64878: EMPTY
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: LIST
64889: LIST
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64896: LD_ADDR_VAR 0 12
64900: PUSH
64901: LD_INT 0
64903: PUSH
64904: LD_INT 0
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 0
64913: PUSH
64914: LD_INT 1
64916: NEG
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: PUSH
64922: LD_INT 1
64924: PUSH
64925: LD_INT 0
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 1
64934: PUSH
64935: LD_INT 1
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 0
64944: PUSH
64945: LD_INT 1
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: LD_INT 1
64954: NEG
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 1
64965: NEG
64966: PUSH
64967: LD_INT 1
64969: NEG
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: LD_INT 1
64977: PUSH
64978: LD_INT 1
64980: NEG
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: PUSH
64986: LD_INT 2
64988: PUSH
64989: LD_INT 0
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: PUSH
64996: LD_INT 2
64998: PUSH
64999: LD_INT 1
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: LD_INT 1
65008: NEG
65009: PUSH
65010: LD_INT 1
65012: PUSH
65013: EMPTY
65014: LIST
65015: LIST
65016: PUSH
65017: LD_INT 2
65019: NEG
65020: PUSH
65021: LD_INT 0
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: LD_INT 2
65030: NEG
65031: PUSH
65032: LD_INT 1
65034: NEG
65035: PUSH
65036: EMPTY
65037: LIST
65038: LIST
65039: PUSH
65040: LD_INT 2
65042: NEG
65043: PUSH
65044: LD_INT 1
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: PUSH
65051: LD_INT 3
65053: NEG
65054: PUSH
65055: LD_INT 0
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 3
65064: NEG
65065: PUSH
65066: LD_INT 1
65068: NEG
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: LIST
65078: LIST
65079: LIST
65080: LIST
65081: LIST
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: LIST
65087: LIST
65088: LIST
65089: LIST
65090: LIST
65091: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65092: LD_ADDR_VAR 0 13
65096: PUSH
65097: LD_INT 0
65099: PUSH
65100: LD_INT 0
65102: PUSH
65103: EMPTY
65104: LIST
65105: LIST
65106: PUSH
65107: LD_INT 0
65109: PUSH
65110: LD_INT 1
65112: NEG
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 1
65120: PUSH
65121: LD_INT 0
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PUSH
65128: LD_INT 1
65130: PUSH
65131: LD_INT 1
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: PUSH
65138: LD_INT 0
65140: PUSH
65141: LD_INT 1
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: LD_INT 1
65150: NEG
65151: PUSH
65152: LD_INT 0
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 1
65161: NEG
65162: PUSH
65163: LD_INT 1
65165: NEG
65166: PUSH
65167: EMPTY
65168: LIST
65169: LIST
65170: PUSH
65171: LD_INT 1
65173: NEG
65174: PUSH
65175: LD_INT 2
65177: NEG
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: PUSH
65183: LD_INT 2
65185: PUSH
65186: LD_INT 1
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PUSH
65193: LD_INT 2
65195: PUSH
65196: LD_INT 2
65198: PUSH
65199: EMPTY
65200: LIST
65201: LIST
65202: PUSH
65203: LD_INT 1
65205: PUSH
65206: LD_INT 2
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PUSH
65213: LD_INT 2
65215: NEG
65216: PUSH
65217: LD_INT 1
65219: NEG
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PUSH
65225: LD_INT 2
65227: NEG
65228: PUSH
65229: LD_INT 2
65231: NEG
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: LD_INT 2
65239: NEG
65240: PUSH
65241: LD_INT 3
65243: NEG
65244: PUSH
65245: EMPTY
65246: LIST
65247: LIST
65248: PUSH
65249: LD_INT 3
65251: NEG
65252: PUSH
65253: LD_INT 2
65255: NEG
65256: PUSH
65257: EMPTY
65258: LIST
65259: LIST
65260: PUSH
65261: LD_INT 3
65263: NEG
65264: PUSH
65265: LD_INT 3
65267: NEG
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: LIST
65288: LIST
65289: LIST
65290: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
65291: LD_ADDR_VAR 0 14
65295: PUSH
65296: LD_INT 0
65298: PUSH
65299: LD_INT 0
65301: PUSH
65302: EMPTY
65303: LIST
65304: LIST
65305: PUSH
65306: LD_INT 0
65308: PUSH
65309: LD_INT 1
65311: NEG
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 1
65319: PUSH
65320: LD_INT 0
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 1
65329: PUSH
65330: LD_INT 1
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PUSH
65337: LD_INT 0
65339: PUSH
65340: LD_INT 1
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PUSH
65347: LD_INT 1
65349: NEG
65350: PUSH
65351: LD_INT 0
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: PUSH
65358: LD_INT 1
65360: NEG
65361: PUSH
65362: LD_INT 1
65364: NEG
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PUSH
65370: LD_INT 1
65372: NEG
65373: PUSH
65374: LD_INT 2
65376: NEG
65377: PUSH
65378: EMPTY
65379: LIST
65380: LIST
65381: PUSH
65382: LD_INT 0
65384: PUSH
65385: LD_INT 2
65387: NEG
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: LD_INT 1
65395: PUSH
65396: LD_INT 1
65398: NEG
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 1
65406: PUSH
65407: LD_INT 2
65409: PUSH
65410: EMPTY
65411: LIST
65412: LIST
65413: PUSH
65414: LD_INT 0
65416: PUSH
65417: LD_INT 2
65419: PUSH
65420: EMPTY
65421: LIST
65422: LIST
65423: PUSH
65424: LD_INT 1
65426: NEG
65427: PUSH
65428: LD_INT 1
65430: PUSH
65431: EMPTY
65432: LIST
65433: LIST
65434: PUSH
65435: LD_INT 1
65437: NEG
65438: PUSH
65439: LD_INT 3
65441: NEG
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: PUSH
65447: LD_INT 0
65449: PUSH
65450: LD_INT 3
65452: NEG
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: PUSH
65458: LD_INT 1
65460: PUSH
65461: LD_INT 2
65463: NEG
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: PUSH
65469: EMPTY
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65487: LD_ADDR_VAR 0 15
65491: PUSH
65492: LD_INT 0
65494: PUSH
65495: LD_INT 0
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: PUSH
65502: LD_INT 0
65504: PUSH
65505: LD_INT 1
65507: NEG
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: LD_INT 0
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: PUSH
65523: LD_INT 1
65525: PUSH
65526: LD_INT 1
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: PUSH
65533: LD_INT 0
65535: PUSH
65536: LD_INT 1
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: PUSH
65543: LD_INT 1
65545: NEG
65546: PUSH
65547: LD_INT 0
65549: PUSH
65550: EMPTY
65551: LIST
65552: LIST
65553: PUSH
65554: LD_INT 1
65556: NEG
65557: PUSH
65558: LD_INT 1
65560: NEG
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PUSH
65566: LD_INT 1
65568: PUSH
65569: LD_INT 1
65571: NEG
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PUSH
65577: LD_INT 2
65579: PUSH
65580: LD_INT 0
65582: PUSH
65583: EMPTY
65584: LIST
65585: LIST
65586: PUSH
65587: LD_INT 2
65589: PUSH
65590: LD_INT 1
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 1
65599: NEG
65600: PUSH
65601: LD_INT 1
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: PUSH
65608: LD_INT 2
65610: NEG
65611: PUSH
65612: LD_INT 0
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: PUSH
65619: LD_INT 2
65621: NEG
65622: PUSH
65623: LD_INT 1
65625: NEG
65626: PUSH
65627: EMPTY
65628: LIST
65629: LIST
65630: PUSH
65631: LD_INT 2
65633: PUSH
65634: LD_INT 1
65636: NEG
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PUSH
65642: LD_INT 3
65644: PUSH
65645: LD_INT 0
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 3
65654: PUSH
65655: LD_INT 1
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: LIST
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65680: LD_ADDR_VAR 0 16
65684: PUSH
65685: LD_INT 0
65687: PUSH
65688: LD_INT 0
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: LD_INT 0
65697: PUSH
65698: LD_INT 1
65700: NEG
65701: PUSH
65702: EMPTY
65703: LIST
65704: LIST
65705: PUSH
65706: LD_INT 1
65708: PUSH
65709: LD_INT 0
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PUSH
65716: LD_INT 1
65718: PUSH
65719: LD_INT 1
65721: PUSH
65722: EMPTY
65723: LIST
65724: LIST
65725: PUSH
65726: LD_INT 0
65728: PUSH
65729: LD_INT 1
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 1
65738: NEG
65739: PUSH
65740: LD_INT 0
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 1
65749: NEG
65750: PUSH
65751: LD_INT 1
65753: NEG
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 1
65761: NEG
65762: PUSH
65763: LD_INT 2
65765: NEG
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: PUSH
65771: LD_INT 2
65773: PUSH
65774: LD_INT 1
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: LD_INT 2
65783: PUSH
65784: LD_INT 2
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 1
65793: PUSH
65794: LD_INT 2
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PUSH
65801: LD_INT 2
65803: NEG
65804: PUSH
65805: LD_INT 1
65807: NEG
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 2
65815: NEG
65816: PUSH
65817: LD_INT 2
65819: NEG
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 3
65827: PUSH
65828: LD_INT 2
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 3
65837: PUSH
65838: LD_INT 3
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: PUSH
65845: LD_INT 2
65847: PUSH
65848: LD_INT 3
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: LIST
65871: LIST
65872: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65873: LD_ADDR_VAR 0 17
65877: PUSH
65878: LD_INT 0
65880: PUSH
65881: LD_INT 0
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: LD_INT 0
65890: PUSH
65891: LD_INT 1
65893: NEG
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: PUSH
65899: LD_INT 1
65901: PUSH
65902: LD_INT 0
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: PUSH
65909: LD_INT 1
65911: PUSH
65912: LD_INT 1
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: PUSH
65919: LD_INT 0
65921: PUSH
65922: LD_INT 1
65924: PUSH
65925: EMPTY
65926: LIST
65927: LIST
65928: PUSH
65929: LD_INT 1
65931: NEG
65932: PUSH
65933: LD_INT 0
65935: PUSH
65936: EMPTY
65937: LIST
65938: LIST
65939: PUSH
65940: LD_INT 1
65942: NEG
65943: PUSH
65944: LD_INT 1
65946: NEG
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 1
65954: NEG
65955: PUSH
65956: LD_INT 2
65958: NEG
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 0
65966: PUSH
65967: LD_INT 2
65969: NEG
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 1
65977: PUSH
65978: LD_INT 1
65980: NEG
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: LD_INT 2
65988: PUSH
65989: LD_INT 0
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 2
65998: PUSH
65999: LD_INT 1
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 2
66008: PUSH
66009: LD_INT 2
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 1
66018: PUSH
66019: LD_INT 2
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 0
66028: PUSH
66029: LD_INT 2
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: PUSH
66036: LD_INT 1
66038: NEG
66039: PUSH
66040: LD_INT 1
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: PUSH
66047: LD_INT 2
66049: NEG
66050: PUSH
66051: LD_INT 0
66053: PUSH
66054: EMPTY
66055: LIST
66056: LIST
66057: PUSH
66058: LD_INT 2
66060: NEG
66061: PUSH
66062: LD_INT 1
66064: NEG
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: LD_INT 2
66072: NEG
66073: PUSH
66074: LD_INT 2
66076: NEG
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: LIST
66086: LIST
66087: LIST
66088: LIST
66089: LIST
66090: LIST
66091: LIST
66092: LIST
66093: LIST
66094: LIST
66095: LIST
66096: LIST
66097: LIST
66098: LIST
66099: LIST
66100: LIST
66101: LIST
66102: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66103: LD_ADDR_VAR 0 18
66107: PUSH
66108: LD_INT 0
66110: PUSH
66111: LD_INT 0
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 0
66120: PUSH
66121: LD_INT 1
66123: NEG
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: PUSH
66129: LD_INT 1
66131: PUSH
66132: LD_INT 0
66134: PUSH
66135: EMPTY
66136: LIST
66137: LIST
66138: PUSH
66139: LD_INT 1
66141: PUSH
66142: LD_INT 1
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 0
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: LD_INT 1
66161: NEG
66162: PUSH
66163: LD_INT 0
66165: PUSH
66166: EMPTY
66167: LIST
66168: LIST
66169: PUSH
66170: LD_INT 1
66172: NEG
66173: PUSH
66174: LD_INT 1
66176: NEG
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 1
66184: NEG
66185: PUSH
66186: LD_INT 2
66188: NEG
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 0
66196: PUSH
66197: LD_INT 2
66199: NEG
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 1
66207: PUSH
66208: LD_INT 1
66210: NEG
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 2
66218: PUSH
66219: LD_INT 0
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: PUSH
66226: LD_INT 2
66228: PUSH
66229: LD_INT 1
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 2
66238: PUSH
66239: LD_INT 2
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: PUSH
66246: LD_INT 1
66248: PUSH
66249: LD_INT 2
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: LD_INT 0
66258: PUSH
66259: LD_INT 2
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PUSH
66266: LD_INT 1
66268: NEG
66269: PUSH
66270: LD_INT 1
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 2
66279: NEG
66280: PUSH
66281: LD_INT 0
66283: PUSH
66284: EMPTY
66285: LIST
66286: LIST
66287: PUSH
66288: LD_INT 2
66290: NEG
66291: PUSH
66292: LD_INT 1
66294: NEG
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 2
66302: NEG
66303: PUSH
66304: LD_INT 2
66306: NEG
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: LIST
66319: LIST
66320: LIST
66321: LIST
66322: LIST
66323: LIST
66324: LIST
66325: LIST
66326: LIST
66327: LIST
66328: LIST
66329: LIST
66330: LIST
66331: LIST
66332: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66333: LD_ADDR_VAR 0 19
66337: PUSH
66338: LD_INT 0
66340: PUSH
66341: LD_INT 0
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 0
66350: PUSH
66351: LD_INT 1
66353: NEG
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: LD_INT 1
66361: PUSH
66362: LD_INT 0
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 1
66371: PUSH
66372: LD_INT 1
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 0
66381: PUSH
66382: LD_INT 1
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: NEG
66392: PUSH
66393: LD_INT 0
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 1
66402: NEG
66403: PUSH
66404: LD_INT 1
66406: NEG
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 1
66414: NEG
66415: PUSH
66416: LD_INT 2
66418: NEG
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 0
66426: PUSH
66427: LD_INT 2
66429: NEG
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 1
66437: PUSH
66438: LD_INT 1
66440: NEG
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: PUSH
66446: LD_INT 2
66448: PUSH
66449: LD_INT 0
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 2
66458: PUSH
66459: LD_INT 1
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 2
66468: PUSH
66469: LD_INT 2
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 1
66478: PUSH
66479: LD_INT 2
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: LD_INT 0
66488: PUSH
66489: LD_INT 2
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: LD_INT 1
66502: PUSH
66503: EMPTY
66504: LIST
66505: LIST
66506: PUSH
66507: LD_INT 2
66509: NEG
66510: PUSH
66511: LD_INT 0
66513: PUSH
66514: EMPTY
66515: LIST
66516: LIST
66517: PUSH
66518: LD_INT 2
66520: NEG
66521: PUSH
66522: LD_INT 1
66524: NEG
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: LD_INT 2
66532: NEG
66533: PUSH
66534: LD_INT 2
66536: NEG
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: LIST
66551: LIST
66552: LIST
66553: LIST
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66563: LD_ADDR_VAR 0 20
66567: PUSH
66568: LD_INT 0
66570: PUSH
66571: LD_INT 0
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: PUSH
66578: LD_INT 0
66580: PUSH
66581: LD_INT 1
66583: NEG
66584: PUSH
66585: EMPTY
66586: LIST
66587: LIST
66588: PUSH
66589: LD_INT 1
66591: PUSH
66592: LD_INT 0
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: PUSH
66602: LD_INT 1
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: PUSH
66609: LD_INT 0
66611: PUSH
66612: LD_INT 1
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: LD_INT 0
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 1
66632: NEG
66633: PUSH
66634: LD_INT 1
66636: NEG
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 1
66644: NEG
66645: PUSH
66646: LD_INT 2
66648: NEG
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: PUSH
66654: LD_INT 0
66656: PUSH
66657: LD_INT 2
66659: NEG
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 1
66667: PUSH
66668: LD_INT 1
66670: NEG
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 2
66678: PUSH
66679: LD_INT 0
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 2
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 2
66698: PUSH
66699: LD_INT 2
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 1
66708: PUSH
66709: LD_INT 2
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 0
66718: PUSH
66719: LD_INT 2
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: LD_INT 1
66728: NEG
66729: PUSH
66730: LD_INT 1
66732: PUSH
66733: EMPTY
66734: LIST
66735: LIST
66736: PUSH
66737: LD_INT 2
66739: NEG
66740: PUSH
66741: LD_INT 0
66743: PUSH
66744: EMPTY
66745: LIST
66746: LIST
66747: PUSH
66748: LD_INT 2
66750: NEG
66751: PUSH
66752: LD_INT 1
66754: NEG
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: PUSH
66760: LD_INT 2
66762: NEG
66763: PUSH
66764: LD_INT 2
66766: NEG
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66793: LD_ADDR_VAR 0 21
66797: PUSH
66798: LD_INT 0
66800: PUSH
66801: LD_INT 0
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 0
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 1
66821: PUSH
66822: LD_INT 0
66824: PUSH
66825: EMPTY
66826: LIST
66827: LIST
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 0
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: LD_INT 0
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: PUSH
66860: LD_INT 1
66862: NEG
66863: PUSH
66864: LD_INT 1
66866: NEG
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 1
66874: NEG
66875: PUSH
66876: LD_INT 2
66878: NEG
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PUSH
66884: LD_INT 0
66886: PUSH
66887: LD_INT 2
66889: NEG
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 1
66897: PUSH
66898: LD_INT 1
66900: NEG
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: LD_INT 0
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 2
66918: PUSH
66919: LD_INT 1
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: LD_INT 2
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: PUSH
66936: LD_INT 1
66938: PUSH
66939: LD_INT 2
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 0
66948: PUSH
66949: LD_INT 2
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 1
66958: NEG
66959: PUSH
66960: LD_INT 1
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 2
66969: NEG
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 2
66980: NEG
66981: PUSH
66982: LD_INT 1
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 2
66992: NEG
66993: PUSH
66994: LD_INT 2
66996: NEG
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67023: LD_ADDR_VAR 0 22
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: LD_INT 0
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 0
67040: PUSH
67041: LD_INT 1
67043: NEG
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 1
67051: PUSH
67052: LD_INT 0
67054: PUSH
67055: EMPTY
67056: LIST
67057: LIST
67058: PUSH
67059: LD_INT 1
67061: PUSH
67062: LD_INT 1
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 0
67071: PUSH
67072: LD_INT 1
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 1
67081: NEG
67082: PUSH
67083: LD_INT 0
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 1
67092: NEG
67093: PUSH
67094: LD_INT 1
67096: NEG
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 1
67104: NEG
67105: PUSH
67106: LD_INT 2
67108: NEG
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 0
67116: PUSH
67117: LD_INT 2
67119: NEG
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: LD_INT 1
67130: NEG
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: LD_INT 2
67138: PUSH
67139: LD_INT 0
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 2
67148: PUSH
67149: LD_INT 1
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 2
67158: PUSH
67159: LD_INT 2
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 1
67168: PUSH
67169: LD_INT 2
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 0
67178: PUSH
67179: LD_INT 2
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 1
67188: NEG
67189: PUSH
67190: LD_INT 1
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 2
67199: NEG
67200: PUSH
67201: LD_INT 0
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 2
67210: NEG
67211: PUSH
67212: LD_INT 1
67214: NEG
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: LD_INT 2
67222: NEG
67223: PUSH
67224: LD_INT 2
67226: NEG
67227: PUSH
67228: EMPTY
67229: LIST
67230: LIST
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
67253: LD_ADDR_VAR 0 23
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: LD_INT 0
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 0
67270: PUSH
67271: LD_INT 1
67273: NEG
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: PUSH
67279: LD_INT 1
67281: PUSH
67282: LD_INT 0
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PUSH
67289: LD_INT 1
67291: PUSH
67292: LD_INT 1
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: LD_INT 0
67301: PUSH
67302: LD_INT 1
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 1
67311: NEG
67312: PUSH
67313: LD_INT 0
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 1
67322: NEG
67323: PUSH
67324: LD_INT 1
67326: NEG
67327: PUSH
67328: EMPTY
67329: LIST
67330: LIST
67331: PUSH
67332: LD_INT 1
67334: NEG
67335: PUSH
67336: LD_INT 2
67338: NEG
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: LD_INT 0
67346: PUSH
67347: LD_INT 2
67349: NEG
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 1
67357: PUSH
67358: LD_INT 1
67360: NEG
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 2
67368: PUSH
67369: LD_INT 0
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 2
67378: PUSH
67379: LD_INT 1
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: LD_INT 2
67388: PUSH
67389: LD_INT 2
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: LD_INT 1
67398: PUSH
67399: LD_INT 2
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: PUSH
67406: LD_INT 0
67408: PUSH
67409: LD_INT 2
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PUSH
67416: LD_INT 1
67418: NEG
67419: PUSH
67420: LD_INT 1
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 2
67429: NEG
67430: PUSH
67431: LD_INT 0
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 2
67440: NEG
67441: PUSH
67442: LD_INT 1
67444: NEG
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 2
67452: NEG
67453: PUSH
67454: LD_INT 2
67456: NEG
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 2
67464: NEG
67465: PUSH
67466: LD_INT 3
67468: NEG
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: NEG
67477: PUSH
67478: LD_INT 3
67480: NEG
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: PUSH
67486: LD_INT 1
67488: PUSH
67489: LD_INT 2
67491: NEG
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 2
67499: PUSH
67500: LD_INT 1
67502: NEG
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67533: LD_ADDR_VAR 0 24
67537: PUSH
67538: LD_INT 0
67540: PUSH
67541: LD_INT 0
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 0
67550: PUSH
67551: LD_INT 1
67553: NEG
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PUSH
67559: LD_INT 1
67561: PUSH
67562: LD_INT 0
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 1
67571: PUSH
67572: LD_INT 1
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 0
67581: PUSH
67582: LD_INT 1
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 1
67591: NEG
67592: PUSH
67593: LD_INT 0
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: LD_INT 1
67606: NEG
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 1
67614: NEG
67615: PUSH
67616: LD_INT 2
67618: NEG
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PUSH
67624: LD_INT 0
67626: PUSH
67627: LD_INT 2
67629: NEG
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 1
67637: PUSH
67638: LD_INT 1
67640: NEG
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 2
67648: PUSH
67649: LD_INT 0
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: PUSH
67656: LD_INT 2
67658: PUSH
67659: LD_INT 1
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: PUSH
67666: LD_INT 2
67668: PUSH
67669: LD_INT 2
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: LD_INT 2
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 0
67688: PUSH
67689: LD_INT 2
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 1
67698: NEG
67699: PUSH
67700: LD_INT 1
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: LD_INT 2
67709: NEG
67710: PUSH
67711: LD_INT 0
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 2
67720: NEG
67721: PUSH
67722: LD_INT 1
67724: NEG
67725: PUSH
67726: EMPTY
67727: LIST
67728: LIST
67729: PUSH
67730: LD_INT 2
67732: NEG
67733: PUSH
67734: LD_INT 2
67736: NEG
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: PUSH
67742: LD_INT 1
67744: PUSH
67745: LD_INT 2
67747: NEG
67748: PUSH
67749: EMPTY
67750: LIST
67751: LIST
67752: PUSH
67753: LD_INT 2
67755: PUSH
67756: LD_INT 1
67758: NEG
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 3
67766: PUSH
67767: LD_INT 1
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 3
67776: PUSH
67777: LD_INT 2
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: EMPTY
67785: LIST
67786: LIST
67787: LIST
67788: LIST
67789: LIST
67790: LIST
67791: LIST
67792: LIST
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67809: LD_ADDR_VAR 0 25
67813: PUSH
67814: LD_INT 0
67816: PUSH
67817: LD_INT 0
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 0
67826: PUSH
67827: LD_INT 1
67829: NEG
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 1
67837: PUSH
67838: LD_INT 0
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 1
67847: PUSH
67848: LD_INT 1
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 0
67857: PUSH
67858: LD_INT 1
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: LD_INT 1
67867: NEG
67868: PUSH
67869: LD_INT 0
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: PUSH
67880: LD_INT 1
67882: NEG
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 1
67890: NEG
67891: PUSH
67892: LD_INT 2
67894: NEG
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: LD_INT 0
67902: PUSH
67903: LD_INT 2
67905: NEG
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: LD_INT 1
67913: PUSH
67914: LD_INT 1
67916: NEG
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 2
67924: PUSH
67925: LD_INT 0
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 2
67934: PUSH
67935: LD_INT 1
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 2
67944: PUSH
67945: LD_INT 2
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: PUSH
67952: LD_INT 1
67954: PUSH
67955: LD_INT 2
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PUSH
67962: LD_INT 0
67964: PUSH
67965: LD_INT 2
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 1
67974: NEG
67975: PUSH
67976: LD_INT 1
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 2
67985: NEG
67986: PUSH
67987: LD_INT 0
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 2
67996: NEG
67997: PUSH
67998: LD_INT 1
68000: NEG
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 2
68008: NEG
68009: PUSH
68010: LD_INT 2
68012: NEG
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 3
68020: PUSH
68021: LD_INT 1
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 3
68030: PUSH
68031: LD_INT 2
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 2
68040: PUSH
68041: LD_INT 3
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 1
68050: PUSH
68051: LD_INT 3
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68083: LD_ADDR_VAR 0 26
68087: PUSH
68088: LD_INT 0
68090: PUSH
68091: LD_INT 0
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 0
68100: PUSH
68101: LD_INT 1
68103: NEG
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 1
68111: PUSH
68112: LD_INT 0
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: LD_INT 1
68121: PUSH
68122: LD_INT 1
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 0
68131: PUSH
68132: LD_INT 1
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PUSH
68139: LD_INT 1
68141: NEG
68142: PUSH
68143: LD_INT 0
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PUSH
68150: LD_INT 1
68152: NEG
68153: PUSH
68154: LD_INT 1
68156: NEG
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 1
68164: NEG
68165: PUSH
68166: LD_INT 2
68168: NEG
68169: PUSH
68170: EMPTY
68171: LIST
68172: LIST
68173: PUSH
68174: LD_INT 0
68176: PUSH
68177: LD_INT 2
68179: NEG
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 1
68187: PUSH
68188: LD_INT 1
68190: NEG
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 2
68198: PUSH
68199: LD_INT 0
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 2
68208: PUSH
68209: LD_INT 1
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 2
68218: PUSH
68219: LD_INT 2
68221: PUSH
68222: EMPTY
68223: LIST
68224: LIST
68225: PUSH
68226: LD_INT 1
68228: PUSH
68229: LD_INT 2
68231: PUSH
68232: EMPTY
68233: LIST
68234: LIST
68235: PUSH
68236: LD_INT 0
68238: PUSH
68239: LD_INT 2
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PUSH
68246: LD_INT 1
68248: NEG
68249: PUSH
68250: LD_INT 1
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: PUSH
68257: LD_INT 2
68259: NEG
68260: PUSH
68261: LD_INT 0
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 2
68270: NEG
68271: PUSH
68272: LD_INT 1
68274: NEG
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 2
68282: NEG
68283: PUSH
68284: LD_INT 2
68286: NEG
68287: PUSH
68288: EMPTY
68289: LIST
68290: LIST
68291: PUSH
68292: LD_INT 2
68294: PUSH
68295: LD_INT 3
68297: PUSH
68298: EMPTY
68299: LIST
68300: LIST
68301: PUSH
68302: LD_INT 1
68304: PUSH
68305: LD_INT 3
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 1
68314: NEG
68315: PUSH
68316: LD_INT 2
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 2
68325: NEG
68326: PUSH
68327: LD_INT 1
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: PUSH
68334: EMPTY
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: LIST
68357: LIST
68358: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68359: LD_ADDR_VAR 0 27
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: LD_INT 0
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: LD_INT 0
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 1
68387: PUSH
68388: LD_INT 0
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 1
68397: PUSH
68398: LD_INT 1
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 0
68407: PUSH
68408: LD_INT 1
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 1
68417: NEG
68418: PUSH
68419: LD_INT 0
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 1
68428: NEG
68429: PUSH
68430: LD_INT 1
68432: NEG
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 1
68440: NEG
68441: PUSH
68442: LD_INT 2
68444: NEG
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 0
68452: PUSH
68453: LD_INT 2
68455: NEG
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: LD_INT 1
68466: NEG
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 2
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 2
68484: PUSH
68485: LD_INT 1
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 2
68494: PUSH
68495: LD_INT 2
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PUSH
68502: LD_INT 1
68504: PUSH
68505: LD_INT 2
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: LD_INT 2
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 1
68524: NEG
68525: PUSH
68526: LD_INT 1
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: PUSH
68533: LD_INT 2
68535: NEG
68536: PUSH
68537: LD_INT 0
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: PUSH
68544: LD_INT 2
68546: NEG
68547: PUSH
68548: LD_INT 1
68550: NEG
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 2
68558: NEG
68559: PUSH
68560: LD_INT 2
68562: NEG
68563: PUSH
68564: EMPTY
68565: LIST
68566: LIST
68567: PUSH
68568: LD_INT 1
68570: NEG
68571: PUSH
68572: LD_INT 2
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 2
68581: NEG
68582: PUSH
68583: LD_INT 1
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 3
68592: NEG
68593: PUSH
68594: LD_INT 1
68596: NEG
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 3
68604: NEG
68605: PUSH
68606: LD_INT 2
68608: NEG
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68639: LD_ADDR_VAR 0 28
68643: PUSH
68644: LD_INT 0
68646: PUSH
68647: LD_INT 0
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PUSH
68654: LD_INT 0
68656: PUSH
68657: LD_INT 1
68659: NEG
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 1
68667: PUSH
68668: LD_INT 0
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: PUSH
68675: LD_INT 1
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: EMPTY
68682: LIST
68683: LIST
68684: PUSH
68685: LD_INT 0
68687: PUSH
68688: LD_INT 1
68690: PUSH
68691: EMPTY
68692: LIST
68693: LIST
68694: PUSH
68695: LD_INT 1
68697: NEG
68698: PUSH
68699: LD_INT 0
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 1
68708: NEG
68709: PUSH
68710: LD_INT 1
68712: NEG
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 1
68720: NEG
68721: PUSH
68722: LD_INT 2
68724: NEG
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 0
68732: PUSH
68733: LD_INT 2
68735: NEG
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: LD_INT 1
68743: PUSH
68744: LD_INT 1
68746: NEG
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 2
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 2
68764: PUSH
68765: LD_INT 1
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 2
68774: PUSH
68775: LD_INT 2
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 1
68784: PUSH
68785: LD_INT 2
68787: PUSH
68788: EMPTY
68789: LIST
68790: LIST
68791: PUSH
68792: LD_INT 0
68794: PUSH
68795: LD_INT 2
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PUSH
68802: LD_INT 1
68804: NEG
68805: PUSH
68806: LD_INT 1
68808: PUSH
68809: EMPTY
68810: LIST
68811: LIST
68812: PUSH
68813: LD_INT 2
68815: NEG
68816: PUSH
68817: LD_INT 0
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 2
68826: NEG
68827: PUSH
68828: LD_INT 1
68830: NEG
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 2
68838: NEG
68839: PUSH
68840: LD_INT 2
68842: NEG
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 2
68850: NEG
68851: PUSH
68852: LD_INT 3
68854: NEG
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 1
68862: NEG
68863: PUSH
68864: LD_INT 3
68866: NEG
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 3
68874: NEG
68875: PUSH
68876: LD_INT 1
68878: NEG
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: PUSH
68884: LD_INT 3
68886: NEG
68887: PUSH
68888: LD_INT 2
68890: NEG
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68921: LD_ADDR_VAR 0 29
68925: PUSH
68926: LD_INT 0
68928: PUSH
68929: LD_INT 0
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 0
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 1
68949: PUSH
68950: LD_INT 0
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: LD_INT 1
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 0
68969: PUSH
68970: LD_INT 1
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 1
68979: NEG
68980: PUSH
68981: LD_INT 0
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 1
68990: NEG
68991: PUSH
68992: LD_INT 1
68994: NEG
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: PUSH
69000: LD_INT 1
69002: NEG
69003: PUSH
69004: LD_INT 2
69006: NEG
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: LD_INT 2
69017: NEG
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 1
69025: PUSH
69026: LD_INT 1
69028: NEG
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 2
69036: PUSH
69037: LD_INT 0
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 2
69046: PUSH
69047: LD_INT 1
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 1
69056: PUSH
69057: LD_INT 2
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 0
69066: PUSH
69067: LD_INT 2
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 1
69076: NEG
69077: PUSH
69078: LD_INT 1
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PUSH
69085: LD_INT 2
69087: NEG
69088: PUSH
69089: LD_INT 1
69091: NEG
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 2
69099: NEG
69100: PUSH
69101: LD_INT 2
69103: NEG
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 2
69111: NEG
69112: PUSH
69113: LD_INT 3
69115: NEG
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: PUSH
69121: LD_INT 2
69123: PUSH
69124: LD_INT 1
69126: NEG
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 3
69134: PUSH
69135: LD_INT 1
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 1
69144: PUSH
69145: LD_INT 3
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 1
69154: NEG
69155: PUSH
69156: LD_INT 2
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 3
69165: NEG
69166: PUSH
69167: LD_INT 2
69169: NEG
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69200: LD_ADDR_VAR 0 30
69204: PUSH
69205: LD_INT 0
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 0
69217: PUSH
69218: LD_INT 1
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 1
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 1
69238: PUSH
69239: LD_INT 1
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 0
69248: PUSH
69249: LD_INT 1
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: PUSH
69256: LD_INT 1
69258: NEG
69259: PUSH
69260: LD_INT 0
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: LD_INT 1
69269: NEG
69270: PUSH
69271: LD_INT 1
69273: NEG
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 1
69281: NEG
69282: PUSH
69283: LD_INT 2
69285: NEG
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 0
69293: PUSH
69294: LD_INT 2
69296: NEG
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 1
69304: PUSH
69305: LD_INT 1
69307: NEG
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 2
69315: PUSH
69316: LD_INT 0
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 2
69325: PUSH
69326: LD_INT 1
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 2
69335: PUSH
69336: LD_INT 2
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: LD_INT 1
69345: PUSH
69346: LD_INT 2
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 1
69355: NEG
69356: PUSH
69357: LD_INT 1
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 2
69366: NEG
69367: PUSH
69368: LD_INT 0
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: LD_INT 2
69377: NEG
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: NEG
69390: PUSH
69391: LD_INT 3
69393: NEG
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 1
69401: PUSH
69402: LD_INT 2
69404: NEG
69405: PUSH
69406: EMPTY
69407: LIST
69408: LIST
69409: PUSH
69410: LD_INT 3
69412: PUSH
69413: LD_INT 2
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: PUSH
69420: LD_INT 2
69422: PUSH
69423: LD_INT 3
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: LD_INT 2
69432: NEG
69433: PUSH
69434: LD_INT 1
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 3
69443: NEG
69444: PUSH
69445: LD_INT 1
69447: NEG
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69478: LD_ADDR_VAR 0 31
69482: PUSH
69483: LD_INT 0
69485: PUSH
69486: LD_INT 0
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 0
69495: PUSH
69496: LD_INT 1
69498: NEG
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 1
69506: PUSH
69507: LD_INT 0
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 1
69516: PUSH
69517: LD_INT 1
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: LD_INT 1
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 1
69536: NEG
69537: PUSH
69538: LD_INT 0
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 1
69547: NEG
69548: PUSH
69549: LD_INT 1
69551: NEG
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: LD_INT 2
69563: NEG
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 1
69571: PUSH
69572: LD_INT 1
69574: NEG
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 2
69582: PUSH
69583: LD_INT 0
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 2
69592: PUSH
69593: LD_INT 1
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 2
69602: PUSH
69603: LD_INT 2
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 1
69612: PUSH
69613: LD_INT 2
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 0
69622: PUSH
69623: LD_INT 2
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 1
69632: NEG
69633: PUSH
69634: LD_INT 1
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 2
69643: NEG
69644: PUSH
69645: LD_INT 1
69647: NEG
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 2
69655: NEG
69656: PUSH
69657: LD_INT 2
69659: NEG
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 2
69667: NEG
69668: PUSH
69669: LD_INT 3
69671: NEG
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 2
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 3
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 1
69700: PUSH
69701: LD_INT 3
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 1
69710: NEG
69711: PUSH
69712: LD_INT 2
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 3
69721: NEG
69722: PUSH
69723: LD_INT 2
69725: NEG
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69756: LD_ADDR_VAR 0 32
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: LD_INT 0
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 0
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: PUSH
69785: LD_INT 0
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 0
69804: PUSH
69805: LD_INT 1
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: LD_INT 0
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 1
69825: NEG
69826: PUSH
69827: LD_INT 1
69829: NEG
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PUSH
69835: LD_INT 1
69837: NEG
69838: PUSH
69839: LD_INT 2
69841: NEG
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: PUSH
69847: LD_INT 0
69849: PUSH
69850: LD_INT 2
69852: NEG
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 1
69860: PUSH
69861: LD_INT 1
69863: NEG
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 2
69871: PUSH
69872: LD_INT 1
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 2
69881: PUSH
69882: LD_INT 2
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: PUSH
69892: LD_INT 2
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 0
69901: PUSH
69902: LD_INT 2
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 1
69911: NEG
69912: PUSH
69913: LD_INT 1
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 2
69922: NEG
69923: PUSH
69924: LD_INT 0
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 2
69933: NEG
69934: PUSH
69935: LD_INT 1
69937: NEG
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 1
69945: NEG
69946: PUSH
69947: LD_INT 3
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: PUSH
69958: LD_INT 2
69960: NEG
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: LD_INT 3
69968: PUSH
69969: LD_INT 2
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: PUSH
69976: LD_INT 2
69978: PUSH
69979: LD_INT 3
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: PUSH
69986: LD_INT 2
69988: NEG
69989: PUSH
69990: LD_INT 1
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 3
69999: NEG
70000: PUSH
70001: LD_INT 1
70003: NEG
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70034: LD_ADDR_VAR 0 33
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: LD_INT 0
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 0
70051: PUSH
70052: LD_INT 1
70054: NEG
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 1
70072: PUSH
70073: LD_INT 1
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 0
70082: PUSH
70083: LD_INT 1
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 1
70092: NEG
70093: PUSH
70094: LD_INT 0
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 1
70103: NEG
70104: PUSH
70105: LD_INT 1
70107: NEG
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: LD_INT 2
70119: NEG
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 1
70127: PUSH
70128: LD_INT 1
70130: NEG
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 2
70138: PUSH
70139: LD_INT 0
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 2
70148: PUSH
70149: LD_INT 1
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 1
70158: PUSH
70159: LD_INT 2
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 0
70168: PUSH
70169: LD_INT 2
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 1
70178: NEG
70179: PUSH
70180: LD_INT 1
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 2
70189: NEG
70190: PUSH
70191: LD_INT 0
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 2
70200: NEG
70201: PUSH
70202: LD_INT 1
70204: NEG
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 2
70212: NEG
70213: PUSH
70214: LD_INT 2
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 2
70224: NEG
70225: PUSH
70226: LD_INT 3
70228: NEG
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 2
70236: PUSH
70237: LD_INT 1
70239: NEG
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: PUSH
70245: LD_INT 3
70247: PUSH
70248: LD_INT 1
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 1
70257: PUSH
70258: LD_INT 3
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 1
70267: NEG
70268: PUSH
70269: LD_INT 2
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 3
70278: NEG
70279: PUSH
70280: LD_INT 2
70282: NEG
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70313: LD_ADDR_VAR 0 34
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 0
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 0
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: LD_INT 1
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 1
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: NEG
70383: PUSH
70384: LD_INT 1
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 2
70398: NEG
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 0
70406: PUSH
70407: LD_INT 2
70409: NEG
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: LD_INT 1
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 2
70428: PUSH
70429: LD_INT 1
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 2
70438: PUSH
70439: LD_INT 2
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 1
70448: PUSH
70449: LD_INT 2
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 1
70458: NEG
70459: PUSH
70460: LD_INT 1
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 2
70469: NEG
70470: PUSH
70471: LD_INT 0
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 2
70480: NEG
70481: PUSH
70482: LD_INT 1
70484: NEG
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 2
70492: NEG
70493: PUSH
70494: LD_INT 2
70496: NEG
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: LD_INT 1
70504: NEG
70505: PUSH
70506: LD_INT 3
70508: NEG
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 1
70516: PUSH
70517: LD_INT 2
70519: NEG
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 3
70527: PUSH
70528: LD_INT 2
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 2
70537: PUSH
70538: LD_INT 3
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 2
70547: NEG
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 3
70558: NEG
70559: PUSH
70560: LD_INT 1
70562: NEG
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: LIST
70591: LIST
70592: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70593: LD_ADDR_VAR 0 35
70597: PUSH
70598: LD_INT 0
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 0
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 1
70621: PUSH
70622: LD_INT 0
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: PUSH
70632: LD_INT 1
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: LD_INT 1
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 1
70651: NEG
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 1
70662: NEG
70663: PUSH
70664: LD_INT 1
70666: NEG
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 2
70674: PUSH
70675: LD_INT 1
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 2
70684: NEG
70685: PUSH
70686: LD_INT 1
70688: NEG
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70705: LD_ADDR_VAR 0 36
70709: PUSH
70710: LD_INT 0
70712: PUSH
70713: LD_INT 0
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 0
70722: PUSH
70723: LD_INT 1
70725: NEG
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: PUSH
70731: LD_INT 1
70733: PUSH
70734: LD_INT 0
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: LD_INT 1
70743: PUSH
70744: LD_INT 1
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 0
70753: PUSH
70754: LD_INT 1
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 1
70763: NEG
70764: PUSH
70765: LD_INT 0
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 1
70774: NEG
70775: PUSH
70776: LD_INT 1
70778: NEG
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 1
70786: NEG
70787: PUSH
70788: LD_INT 2
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 1
70798: PUSH
70799: LD_INT 2
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70817: LD_ADDR_VAR 0 37
70821: PUSH
70822: LD_INT 0
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 0
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: LD_INT 0
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 1
70855: PUSH
70856: LD_INT 1
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 0
70865: PUSH
70866: LD_INT 1
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: LD_INT 0
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 1
70886: NEG
70887: PUSH
70888: LD_INT 1
70890: NEG
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: LD_INT 1
70901: NEG
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 1
70909: NEG
70910: PUSH
70911: LD_INT 1
70913: PUSH
70914: EMPTY
70915: LIST
70916: LIST
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70929: LD_ADDR_VAR 0 38
70933: PUSH
70934: LD_INT 0
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 0
70946: PUSH
70947: LD_INT 1
70949: NEG
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 1
70957: PUSH
70958: LD_INT 0
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 1
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 0
70977: PUSH
70978: LD_INT 1
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: LD_INT 0
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: LD_INT 1
70998: NEG
70999: PUSH
71000: LD_INT 1
71002: NEG
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 2
71010: PUSH
71011: LD_INT 1
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 2
71020: NEG
71021: PUSH
71022: LD_INT 1
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71041: LD_ADDR_VAR 0 39
71045: PUSH
71046: LD_INT 0
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 1
71069: PUSH
71070: LD_INT 0
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 1
71079: PUSH
71080: LD_INT 1
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 0
71089: PUSH
71090: LD_INT 1
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 1
71099: NEG
71100: PUSH
71101: LD_INT 0
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PUSH
71108: LD_INT 1
71110: NEG
71111: PUSH
71112: LD_INT 1
71114: NEG
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: LD_INT 2
71126: NEG
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: PUSH
71135: LD_INT 2
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71153: LD_ADDR_VAR 0 40
71157: PUSH
71158: LD_INT 0
71160: PUSH
71161: LD_INT 0
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: LD_INT 0
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 1
71181: PUSH
71182: LD_INT 0
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 0
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 1
71211: NEG
71212: PUSH
71213: LD_INT 0
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 1
71222: NEG
71223: PUSH
71224: LD_INT 1
71226: NEG
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 1
71234: PUSH
71235: LD_INT 1
71237: NEG
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 1
71245: NEG
71246: PUSH
71247: LD_INT 1
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71265: LD_ADDR_VAR 0 41
71269: PUSH
71270: LD_INT 0
71272: PUSH
71273: LD_INT 0
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 0
71282: PUSH
71283: LD_INT 1
71285: NEG
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 1
71293: PUSH
71294: LD_INT 0
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: LD_INT 1
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 1
71323: NEG
71324: PUSH
71325: LD_INT 0
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 1
71334: NEG
71335: PUSH
71336: LD_INT 1
71338: NEG
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 1
71346: NEG
71347: PUSH
71348: LD_INT 2
71350: NEG
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 1
71358: PUSH
71359: LD_INT 1
71361: NEG
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 2
71369: PUSH
71370: LD_INT 0
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 2
71379: PUSH
71380: LD_INT 1
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 2
71389: PUSH
71390: LD_INT 2
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: LD_INT 2
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 1
71409: NEG
71410: PUSH
71411: LD_INT 1
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 2
71420: NEG
71421: PUSH
71422: LD_INT 0
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 2
71431: NEG
71432: PUSH
71433: LD_INT 1
71435: NEG
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 2
71443: NEG
71444: PUSH
71445: LD_INT 2
71447: NEG
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 2
71455: NEG
71456: PUSH
71457: LD_INT 3
71459: NEG
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 2
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 3
71478: PUSH
71479: LD_INT 0
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 3
71488: PUSH
71489: LD_INT 1
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 3
71498: PUSH
71499: LD_INT 2
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: PUSH
71506: LD_INT 3
71508: PUSH
71509: LD_INT 3
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 2
71518: PUSH
71519: LD_INT 3
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 2
71528: NEG
71529: PUSH
71530: LD_INT 1
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 3
71539: NEG
71540: PUSH
71541: LD_INT 0
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 3
71550: NEG
71551: PUSH
71552: LD_INT 1
71554: NEG
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 3
71562: NEG
71563: PUSH
71564: LD_INT 2
71566: NEG
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 3
71574: NEG
71575: PUSH
71576: LD_INT 3
71578: NEG
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71615: LD_ADDR_VAR 0 42
71619: PUSH
71620: LD_INT 0
71622: PUSH
71623: LD_INT 0
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 0
71632: PUSH
71633: LD_INT 1
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 1
71643: PUSH
71644: LD_INT 0
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 1
71653: PUSH
71654: LD_INT 1
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: PUSH
71661: LD_INT 0
71663: PUSH
71664: LD_INT 1
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 1
71673: NEG
71674: PUSH
71675: LD_INT 0
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 1
71684: NEG
71685: PUSH
71686: LD_INT 1
71688: NEG
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 1
71696: NEG
71697: PUSH
71698: LD_INT 2
71700: NEG
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 0
71708: PUSH
71709: LD_INT 2
71711: NEG
71712: PUSH
71713: EMPTY
71714: LIST
71715: LIST
71716: PUSH
71717: LD_INT 1
71719: PUSH
71720: LD_INT 1
71722: NEG
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 2
71730: PUSH
71731: LD_INT 1
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 2
71740: PUSH
71741: LD_INT 2
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 1
71750: PUSH
71751: LD_INT 2
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 0
71760: PUSH
71761: LD_INT 2
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 1
71770: NEG
71771: PUSH
71772: LD_INT 1
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: LD_INT 2
71781: NEG
71782: PUSH
71783: LD_INT 1
71785: NEG
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 2
71793: NEG
71794: PUSH
71795: LD_INT 2
71797: NEG
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 2
71805: NEG
71806: PUSH
71807: LD_INT 3
71809: NEG
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 1
71817: NEG
71818: PUSH
71819: LD_INT 3
71821: NEG
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: LD_INT 3
71832: NEG
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 1
71840: PUSH
71841: LD_INT 2
71843: NEG
71844: PUSH
71845: EMPTY
71846: LIST
71847: LIST
71848: PUSH
71849: LD_INT 3
71851: PUSH
71852: LD_INT 2
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 3
71861: PUSH
71862: LD_INT 3
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 2
71871: PUSH
71872: LD_INT 3
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: PUSH
71879: LD_INT 1
71881: PUSH
71882: LD_INT 3
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: LD_INT 3
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 1
71901: NEG
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PUSH
71910: LD_INT 3
71912: NEG
71913: PUSH
71914: LD_INT 2
71916: NEG
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 3
71924: NEG
71925: PUSH
71926: LD_INT 3
71928: NEG
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: LIST
71938: LIST
71939: LIST
71940: LIST
71941: LIST
71942: LIST
71943: LIST
71944: LIST
71945: LIST
71946: LIST
71947: LIST
71948: LIST
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71965: LD_ADDR_VAR 0 43
71969: PUSH
71970: LD_INT 0
71972: PUSH
71973: LD_INT 0
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 0
71982: PUSH
71983: LD_INT 1
71985: NEG
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 1
71993: PUSH
71994: LD_INT 0
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 1
72003: PUSH
72004: LD_INT 1
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 0
72013: PUSH
72014: LD_INT 1
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 1
72023: NEG
72024: PUSH
72025: LD_INT 0
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 1
72034: NEG
72035: PUSH
72036: LD_INT 1
72038: NEG
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 1
72046: NEG
72047: PUSH
72048: LD_INT 2
72050: NEG
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 0
72058: PUSH
72059: LD_INT 2
72061: NEG
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: LD_INT 1
72072: NEG
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 2
72080: PUSH
72081: LD_INT 0
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: LD_INT 2
72090: PUSH
72091: LD_INT 1
72093: PUSH
72094: EMPTY
72095: LIST
72096: LIST
72097: PUSH
72098: LD_INT 1
72100: PUSH
72101: LD_INT 2
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: LD_INT 0
72110: PUSH
72111: LD_INT 2
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 1
72120: NEG
72121: PUSH
72122: LD_INT 1
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: LD_INT 2
72131: NEG
72132: PUSH
72133: LD_INT 0
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 2
72142: NEG
72143: PUSH
72144: LD_INT 1
72146: NEG
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: NEG
72155: PUSH
72156: LD_INT 3
72158: NEG
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 0
72166: PUSH
72167: LD_INT 3
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: PUSH
72178: LD_INT 2
72180: NEG
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 2
72188: PUSH
72189: LD_INT 1
72191: NEG
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 3
72199: PUSH
72200: LD_INT 0
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 3
72209: PUSH
72210: LD_INT 1
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PUSH
72217: LD_INT 1
72219: PUSH
72220: LD_INT 3
72222: PUSH
72223: EMPTY
72224: LIST
72225: LIST
72226: PUSH
72227: LD_INT 0
72229: PUSH
72230: LD_INT 3
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: PUSH
72237: LD_INT 1
72239: NEG
72240: PUSH
72241: LD_INT 2
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 2
72250: NEG
72251: PUSH
72252: LD_INT 1
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: PUSH
72259: LD_INT 3
72261: NEG
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 3
72272: NEG
72273: PUSH
72274: LD_INT 1
72276: NEG
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: LIST
72286: LIST
72287: LIST
72288: LIST
72289: LIST
72290: LIST
72291: LIST
72292: LIST
72293: LIST
72294: LIST
72295: LIST
72296: LIST
72297: LIST
72298: LIST
72299: LIST
72300: LIST
72301: LIST
72302: LIST
72303: LIST
72304: LIST
72305: LIST
72306: LIST
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: LIST
72312: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72313: LD_ADDR_VAR 0 44
72317: PUSH
72318: LD_INT 0
72320: PUSH
72321: LD_INT 0
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 0
72330: PUSH
72331: LD_INT 1
72333: NEG
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 1
72341: PUSH
72342: LD_INT 0
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 1
72351: PUSH
72352: LD_INT 1
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 0
72361: PUSH
72362: LD_INT 1
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: LD_INT 1
72371: NEG
72372: PUSH
72373: LD_INT 0
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 1
72382: NEG
72383: PUSH
72384: LD_INT 1
72386: NEG
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PUSH
72392: LD_INT 1
72394: NEG
72395: PUSH
72396: LD_INT 2
72398: NEG
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PUSH
72404: LD_INT 1
72406: PUSH
72407: LD_INT 1
72409: NEG
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 2
72417: PUSH
72418: LD_INT 0
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 2
72427: PUSH
72428: LD_INT 1
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 2
72437: PUSH
72438: LD_INT 2
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 1
72447: PUSH
72448: LD_INT 2
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 1
72457: NEG
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 2
72468: NEG
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 2
72479: NEG
72480: PUSH
72481: LD_INT 1
72483: NEG
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 2
72491: NEG
72492: PUSH
72493: LD_INT 2
72495: NEG
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 2
72503: NEG
72504: PUSH
72505: LD_INT 3
72507: NEG
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 2
72515: PUSH
72516: LD_INT 1
72518: NEG
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 3
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 3
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 3
72546: PUSH
72547: LD_INT 2
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 3
72556: PUSH
72557: LD_INT 3
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 2
72566: PUSH
72567: LD_INT 3
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 2
72576: NEG
72577: PUSH
72578: LD_INT 1
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 3
72587: NEG
72588: PUSH
72589: LD_INT 0
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PUSH
72596: LD_INT 3
72598: NEG
72599: PUSH
72600: LD_INT 1
72602: NEG
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: LD_INT 3
72610: NEG
72611: PUSH
72612: LD_INT 2
72614: NEG
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 3
72622: NEG
72623: PUSH
72624: LD_INT 3
72626: NEG
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: LIST
72638: LIST
72639: LIST
72640: LIST
72641: LIST
72642: LIST
72643: LIST
72644: LIST
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72663: LD_ADDR_VAR 0 45
72667: PUSH
72668: LD_INT 0
72670: PUSH
72671: LD_INT 0
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: PUSH
72678: LD_INT 0
72680: PUSH
72681: LD_INT 1
72683: NEG
72684: PUSH
72685: EMPTY
72686: LIST
72687: LIST
72688: PUSH
72689: LD_INT 1
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 1
72701: PUSH
72702: LD_INT 1
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 0
72711: PUSH
72712: LD_INT 1
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 1
72721: NEG
72722: PUSH
72723: LD_INT 0
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: PUSH
72730: LD_INT 1
72732: NEG
72733: PUSH
72734: LD_INT 1
72736: NEG
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 1
72744: NEG
72745: PUSH
72746: LD_INT 2
72748: NEG
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 0
72756: PUSH
72757: LD_INT 2
72759: NEG
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PUSH
72765: LD_INT 1
72767: PUSH
72768: LD_INT 1
72770: NEG
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 2
72778: PUSH
72779: LD_INT 1
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 2
72788: PUSH
72789: LD_INT 2
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: LD_INT 2
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 0
72808: PUSH
72809: LD_INT 2
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: LD_INT 1
72818: NEG
72819: PUSH
72820: LD_INT 1
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 2
72829: NEG
72830: PUSH
72831: LD_INT 1
72833: NEG
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 2
72841: NEG
72842: PUSH
72843: LD_INT 2
72845: NEG
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 2
72853: NEG
72854: PUSH
72855: LD_INT 3
72857: NEG
72858: PUSH
72859: EMPTY
72860: LIST
72861: LIST
72862: PUSH
72863: LD_INT 1
72865: NEG
72866: PUSH
72867: LD_INT 3
72869: NEG
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: LD_INT 3
72880: NEG
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 1
72888: PUSH
72889: LD_INT 2
72891: NEG
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 3
72899: PUSH
72900: LD_INT 2
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 3
72909: PUSH
72910: LD_INT 3
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: LD_INT 2
72919: PUSH
72920: LD_INT 3
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: PUSH
72930: LD_INT 3
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: PUSH
72937: LD_INT 0
72939: PUSH
72940: LD_INT 3
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 1
72949: NEG
72950: PUSH
72951: LD_INT 2
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 3
72960: NEG
72961: PUSH
72962: LD_INT 2
72964: NEG
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PUSH
72970: LD_INT 3
72972: NEG
72973: PUSH
72974: LD_INT 3
72976: NEG
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: LIST
72986: LIST
72987: LIST
72988: LIST
72989: LIST
72990: LIST
72991: LIST
72992: LIST
72993: LIST
72994: LIST
72995: LIST
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73013: LD_ADDR_VAR 0 46
73017: PUSH
73018: LD_INT 0
73020: PUSH
73021: LD_INT 0
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: LD_INT 1
73033: NEG
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 1
73041: PUSH
73042: LD_INT 0
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 1
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 0
73061: PUSH
73062: LD_INT 1
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 1
73071: NEG
73072: PUSH
73073: LD_INT 0
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 1
73082: NEG
73083: PUSH
73084: LD_INT 1
73086: NEG
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 1
73094: NEG
73095: PUSH
73096: LD_INT 2
73098: NEG
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 0
73106: PUSH
73107: LD_INT 2
73109: NEG
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: PUSH
73115: LD_INT 1
73117: PUSH
73118: LD_INT 1
73120: NEG
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 2
73128: PUSH
73129: LD_INT 0
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 2
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 1
73148: PUSH
73149: LD_INT 2
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 0
73158: PUSH
73159: LD_INT 2
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 1
73168: NEG
73169: PUSH
73170: LD_INT 1
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: LD_INT 2
73179: NEG
73180: PUSH
73181: LD_INT 0
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 2
73190: NEG
73191: PUSH
73192: LD_INT 1
73194: NEG
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: LD_INT 3
73206: NEG
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 0
73214: PUSH
73215: LD_INT 3
73217: NEG
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 1
73225: PUSH
73226: LD_INT 2
73228: NEG
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 2
73236: PUSH
73237: LD_INT 1
73239: NEG
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 3
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 3
73257: PUSH
73258: LD_INT 1
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 1
73267: PUSH
73268: LD_INT 3
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 0
73277: PUSH
73278: LD_INT 3
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PUSH
73285: LD_INT 1
73287: NEG
73288: PUSH
73289: LD_INT 2
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PUSH
73296: LD_INT 2
73298: NEG
73299: PUSH
73300: LD_INT 1
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PUSH
73307: LD_INT 3
73309: NEG
73310: PUSH
73311: LD_INT 0
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 3
73320: NEG
73321: PUSH
73322: LD_INT 1
73324: NEG
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: LIST
73334: LIST
73335: LIST
73336: LIST
73337: LIST
73338: LIST
73339: LIST
73340: LIST
73341: LIST
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73361: LD_ADDR_VAR 0 47
73365: PUSH
73366: LD_INT 0
73368: PUSH
73369: LD_INT 0
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 0
73378: PUSH
73379: LD_INT 1
73381: NEG
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 1
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 1
73399: PUSH
73400: LD_INT 1
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 0
73409: PUSH
73410: LD_INT 1
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 1
73419: NEG
73420: PUSH
73421: LD_INT 0
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 1
73430: NEG
73431: PUSH
73432: LD_INT 1
73434: NEG
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 1
73442: NEG
73443: PUSH
73444: LD_INT 2
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 0
73454: PUSH
73455: LD_INT 2
73457: NEG
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: PUSH
73466: LD_INT 1
73468: NEG
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 2
73476: NEG
73477: PUSH
73478: LD_INT 1
73480: NEG
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 2
73488: NEG
73489: PUSH
73490: LD_INT 2
73492: NEG
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73512: LD_ADDR_VAR 0 48
73516: PUSH
73517: LD_INT 0
73519: PUSH
73520: LD_INT 0
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: LD_INT 1
73532: NEG
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 1
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 1
73550: PUSH
73551: LD_INT 1
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: LD_INT 1
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: PUSH
73568: LD_INT 1
73570: NEG
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 1
73581: NEG
73582: PUSH
73583: LD_INT 1
73585: NEG
73586: PUSH
73587: EMPTY
73588: LIST
73589: LIST
73590: PUSH
73591: LD_INT 1
73593: NEG
73594: PUSH
73595: LD_INT 2
73597: NEG
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 0
73605: PUSH
73606: LD_INT 2
73608: NEG
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 1
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 2
73627: PUSH
73628: LD_INT 0
73630: PUSH
73631: EMPTY
73632: LIST
73633: LIST
73634: PUSH
73635: LD_INT 2
73637: PUSH
73638: LD_INT 1
73640: PUSH
73641: EMPTY
73642: LIST
73643: LIST
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: LIST
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: LIST
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73659: LD_ADDR_VAR 0 49
73663: PUSH
73664: LD_INT 0
73666: PUSH
73667: LD_INT 0
73669: PUSH
73670: EMPTY
73671: LIST
73672: LIST
73673: PUSH
73674: LD_INT 0
73676: PUSH
73677: LD_INT 1
73679: NEG
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: LD_INT 1
73687: PUSH
73688: LD_INT 0
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 1
73697: PUSH
73698: LD_INT 1
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 0
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 1
73717: NEG
73718: PUSH
73719: LD_INT 0
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 1
73728: NEG
73729: PUSH
73730: LD_INT 1
73732: NEG
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 1
73740: PUSH
73741: LD_INT 1
73743: NEG
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 2
73751: PUSH
73752: LD_INT 0
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 2
73761: PUSH
73762: LD_INT 1
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: LD_INT 2
73771: PUSH
73772: LD_INT 2
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: PUSH
73779: LD_INT 1
73781: PUSH
73782: LD_INT 2
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: LIST
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: LIST
73798: LIST
73799: LIST
73800: LIST
73801: LIST
73802: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73803: LD_ADDR_VAR 0 50
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: LD_INT 0
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: LD_INT 0
73820: PUSH
73821: LD_INT 1
73823: NEG
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: LD_INT 0
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 1
73841: PUSH
73842: LD_INT 1
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 0
73851: PUSH
73852: LD_INT 1
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 1
73861: NEG
73862: PUSH
73863: LD_INT 0
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 1
73872: NEG
73873: PUSH
73874: LD_INT 1
73876: NEG
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 2
73884: PUSH
73885: LD_INT 1
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 2
73894: PUSH
73895: LD_INT 2
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 1
73904: PUSH
73905: LD_INT 2
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 0
73914: PUSH
73915: LD_INT 2
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 1
73924: NEG
73925: PUSH
73926: LD_INT 1
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: LIST
73940: LIST
73941: LIST
73942: LIST
73943: LIST
73944: LIST
73945: LIST
73946: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73947: LD_ADDR_VAR 0 51
73951: PUSH
73952: LD_INT 0
73954: PUSH
73955: LD_INT 0
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: PUSH
73962: LD_INT 0
73964: PUSH
73965: LD_INT 1
73967: NEG
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 1
73975: PUSH
73976: LD_INT 0
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 1
73985: PUSH
73986: LD_INT 1
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 0
73995: PUSH
73996: LD_INT 1
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: LD_INT 1
74005: NEG
74006: PUSH
74007: LD_INT 0
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 1
74016: NEG
74017: PUSH
74018: LD_INT 1
74020: NEG
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PUSH
74026: LD_INT 1
74028: PUSH
74029: LD_INT 2
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 0
74038: PUSH
74039: LD_INT 2
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 1
74048: NEG
74049: PUSH
74050: LD_INT 1
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 2
74059: NEG
74060: PUSH
74061: LD_INT 0
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 2
74070: NEG
74071: PUSH
74072: LD_INT 1
74074: NEG
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: LIST
74084: LIST
74085: LIST
74086: LIST
74087: LIST
74088: LIST
74089: LIST
74090: LIST
74091: LIST
74092: LIST
74093: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74094: LD_ADDR_VAR 0 52
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: LD_INT 0
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: LD_INT 0
74111: PUSH
74112: LD_INT 1
74114: NEG
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 1
74132: PUSH
74133: LD_INT 1
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: LD_INT 1
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 1
74152: NEG
74153: PUSH
74154: LD_INT 0
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 1
74163: NEG
74164: PUSH
74165: LD_INT 1
74167: NEG
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 1
74175: NEG
74176: PUSH
74177: LD_INT 2
74179: NEG
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 1
74187: NEG
74188: PUSH
74189: LD_INT 1
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 2
74198: NEG
74199: PUSH
74200: LD_INT 0
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 2
74209: NEG
74210: PUSH
74211: LD_INT 1
74213: NEG
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PUSH
74219: LD_INT 2
74221: NEG
74222: PUSH
74223: LD_INT 2
74225: NEG
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74245: LD_ADDR_VAR 0 53
74249: PUSH
74250: LD_INT 0
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 0
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PUSH
74271: LD_INT 1
74273: PUSH
74274: LD_INT 0
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: LD_INT 1
74283: PUSH
74284: LD_INT 1
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 0
74293: PUSH
74294: LD_INT 1
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 1
74303: NEG
74304: PUSH
74305: LD_INT 0
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 1
74314: NEG
74315: PUSH
74316: LD_INT 1
74318: NEG
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PUSH
74324: LD_INT 1
74326: NEG
74327: PUSH
74328: LD_INT 2
74330: NEG
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 0
74338: PUSH
74339: LD_INT 2
74341: NEG
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: LD_INT 1
74352: NEG
74353: PUSH
74354: EMPTY
74355: LIST
74356: LIST
74357: PUSH
74358: LD_INT 2
74360: PUSH
74361: LD_INT 0
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 2
74370: PUSH
74371: LD_INT 1
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 2
74380: PUSH
74381: LD_INT 2
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: LD_INT 1
74390: PUSH
74391: LD_INT 2
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 0
74400: PUSH
74401: LD_INT 2
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 1
74410: NEG
74411: PUSH
74412: LD_INT 1
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 2
74421: NEG
74422: PUSH
74423: LD_INT 0
74425: PUSH
74426: EMPTY
74427: LIST
74428: LIST
74429: PUSH
74430: LD_INT 2
74432: NEG
74433: PUSH
74434: LD_INT 1
74436: NEG
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: PUSH
74442: LD_INT 2
74444: NEG
74445: PUSH
74446: LD_INT 2
74448: NEG
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: LIST
74461: LIST
74462: LIST
74463: LIST
74464: LIST
74465: LIST
74466: LIST
74467: LIST
74468: LIST
74469: LIST
74470: LIST
74471: LIST
74472: LIST
74473: LIST
74474: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74475: LD_ADDR_VAR 0 54
74479: PUSH
74480: LD_INT 0
74482: PUSH
74483: LD_INT 0
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: PUSH
74490: LD_INT 0
74492: PUSH
74493: LD_INT 1
74495: NEG
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: LD_INT 1
74503: PUSH
74504: LD_INT 0
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 1
74513: PUSH
74514: LD_INT 1
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: PUSH
74521: LD_INT 0
74523: PUSH
74524: LD_INT 1
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: LD_INT 1
74533: NEG
74534: PUSH
74535: LD_INT 0
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 1
74544: NEG
74545: PUSH
74546: LD_INT 1
74548: NEG
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 1
74556: NEG
74557: PUSH
74558: LD_INT 2
74560: NEG
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 0
74568: PUSH
74569: LD_INT 2
74571: NEG
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 1
74579: PUSH
74580: LD_INT 1
74582: NEG
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: LD_INT 2
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 2
74600: PUSH
74601: LD_INT 1
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 2
74610: PUSH
74611: LD_INT 2
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: LD_INT 2
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 0
74630: PUSH
74631: LD_INT 2
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: LD_INT 1
74640: NEG
74641: PUSH
74642: LD_INT 1
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 2
74651: NEG
74652: PUSH
74653: LD_INT 0
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: LD_INT 2
74662: NEG
74663: PUSH
74664: LD_INT 1
74666: NEG
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 2
74674: NEG
74675: PUSH
74676: LD_INT 2
74678: NEG
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: LIST
74688: LIST
74689: LIST
74690: LIST
74691: LIST
74692: LIST
74693: LIST
74694: LIST
74695: LIST
74696: LIST
74697: LIST
74698: LIST
74699: LIST
74700: LIST
74701: LIST
74702: LIST
74703: LIST
74704: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74705: LD_ADDR_VAR 0 55
74709: PUSH
74710: LD_INT 0
74712: PUSH
74713: LD_INT 0
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 0
74722: PUSH
74723: LD_INT 1
74725: NEG
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 1
74733: PUSH
74734: LD_INT 0
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: LD_INT 1
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 0
74753: PUSH
74754: LD_INT 1
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 1
74763: NEG
74764: PUSH
74765: LD_INT 0
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 1
74774: NEG
74775: PUSH
74776: LD_INT 1
74778: NEG
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: LD_INT 1
74786: NEG
74787: PUSH
74788: LD_INT 2
74790: NEG
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: LD_INT 0
74798: PUSH
74799: LD_INT 2
74801: NEG
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 1
74809: PUSH
74810: LD_INT 1
74812: NEG
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 2
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 2
74830: PUSH
74831: LD_INT 1
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 2
74840: PUSH
74841: LD_INT 2
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: LD_INT 1
74850: PUSH
74851: LD_INT 2
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PUSH
74858: LD_INT 0
74860: PUSH
74861: LD_INT 2
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 1
74870: NEG
74871: PUSH
74872: LD_INT 1
74874: PUSH
74875: EMPTY
74876: LIST
74877: LIST
74878: PUSH
74879: LD_INT 2
74881: NEG
74882: PUSH
74883: LD_INT 0
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 2
74892: NEG
74893: PUSH
74894: LD_INT 1
74896: NEG
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: LD_INT 2
74904: NEG
74905: PUSH
74906: LD_INT 2
74908: NEG
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: LIST
74926: LIST
74927: LIST
74928: LIST
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74935: LD_ADDR_VAR 0 56
74939: PUSH
74940: LD_INT 0
74942: PUSH
74943: LD_INT 0
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 0
74952: PUSH
74953: LD_INT 1
74955: NEG
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 1
74963: PUSH
74964: LD_INT 0
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 1
74973: PUSH
74974: LD_INT 1
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: PUSH
74981: LD_INT 0
74983: PUSH
74984: LD_INT 1
74986: PUSH
74987: EMPTY
74988: LIST
74989: LIST
74990: PUSH
74991: LD_INT 1
74993: NEG
74994: PUSH
74995: LD_INT 0
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: PUSH
75002: LD_INT 1
75004: NEG
75005: PUSH
75006: LD_INT 1
75008: NEG
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 1
75016: NEG
75017: PUSH
75018: LD_INT 2
75020: NEG
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: LD_INT 2
75031: NEG
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 1
75039: PUSH
75040: LD_INT 1
75042: NEG
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 2
75050: PUSH
75051: LD_INT 0
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 2
75060: PUSH
75061: LD_INT 1
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 2
75070: PUSH
75071: LD_INT 2
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: LD_INT 1
75080: PUSH
75081: LD_INT 2
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 0
75090: PUSH
75091: LD_INT 2
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 1
75100: NEG
75101: PUSH
75102: LD_INT 1
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PUSH
75109: LD_INT 2
75111: NEG
75112: PUSH
75113: LD_INT 0
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 2
75122: NEG
75123: PUSH
75124: LD_INT 1
75126: NEG
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 2
75134: NEG
75135: PUSH
75136: LD_INT 2
75138: NEG
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: LIST
75159: LIST
75160: LIST
75161: LIST
75162: LIST
75163: LIST
75164: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75165: LD_ADDR_VAR 0 57
75169: PUSH
75170: LD_INT 0
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 0
75182: PUSH
75183: LD_INT 1
75185: NEG
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_INT 1
75193: PUSH
75194: LD_INT 0
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: LD_INT 1
75203: PUSH
75204: LD_INT 1
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 0
75213: PUSH
75214: LD_INT 1
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 1
75223: NEG
75224: PUSH
75225: LD_INT 0
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 1
75234: NEG
75235: PUSH
75236: LD_INT 1
75238: NEG
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 1
75246: NEG
75247: PUSH
75248: LD_INT 2
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 0
75258: PUSH
75259: LD_INT 2
75261: NEG
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 1
75269: PUSH
75270: LD_INT 1
75272: NEG
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 2
75280: PUSH
75281: LD_INT 0
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 2
75290: PUSH
75291: LD_INT 1
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 2
75300: PUSH
75301: LD_INT 2
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PUSH
75308: LD_INT 1
75310: PUSH
75311: LD_INT 2
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 0
75320: PUSH
75321: LD_INT 2
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 1
75330: NEG
75331: PUSH
75332: LD_INT 1
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: LD_INT 2
75341: NEG
75342: PUSH
75343: LD_INT 0
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: LD_INT 2
75352: NEG
75353: PUSH
75354: LD_INT 1
75356: NEG
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 2
75364: NEG
75365: PUSH
75366: LD_INT 2
75368: NEG
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: LIST
75389: LIST
75390: LIST
75391: LIST
75392: LIST
75393: LIST
75394: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75395: LD_ADDR_VAR 0 58
75399: PUSH
75400: LD_INT 0
75402: PUSH
75403: LD_INT 0
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 0
75412: PUSH
75413: LD_INT 1
75415: NEG
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 1
75423: PUSH
75424: LD_INT 0
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: LD_INT 1
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 0
75443: PUSH
75444: LD_INT 1
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 1
75453: NEG
75454: PUSH
75455: LD_INT 0
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 1
75464: NEG
75465: PUSH
75466: LD_INT 1
75468: NEG
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 1
75476: NEG
75477: PUSH
75478: LD_INT 2
75480: NEG
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 0
75488: PUSH
75489: LD_INT 2
75491: NEG
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PUSH
75497: LD_INT 1
75499: PUSH
75500: LD_INT 1
75502: NEG
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: PUSH
75508: LD_INT 2
75510: PUSH
75511: LD_INT 0
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 2
75520: PUSH
75521: LD_INT 1
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 2
75530: PUSH
75531: LD_INT 2
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 1
75540: PUSH
75541: LD_INT 2
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: LD_INT 0
75550: PUSH
75551: LD_INT 2
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 1
75560: NEG
75561: PUSH
75562: LD_INT 1
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 2
75571: NEG
75572: PUSH
75573: LD_INT 0
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 2
75582: NEG
75583: PUSH
75584: LD_INT 1
75586: NEG
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 2
75594: NEG
75595: PUSH
75596: LD_INT 2
75598: NEG
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: LIST
75619: LIST
75620: LIST
75621: LIST
75622: LIST
75623: LIST
75624: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75625: LD_ADDR_VAR 0 59
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: LD_INT 0
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 0
75642: PUSH
75643: LD_INT 1
75645: NEG
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 1
75653: PUSH
75654: LD_INT 0
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 1
75663: PUSH
75664: LD_INT 1
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 0
75673: PUSH
75674: LD_INT 1
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 1
75683: NEG
75684: PUSH
75685: LD_INT 0
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 1
75694: NEG
75695: PUSH
75696: LD_INT 1
75698: NEG
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75713: LD_ADDR_VAR 0 60
75717: PUSH
75718: LD_INT 0
75720: PUSH
75721: LD_INT 0
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: LD_INT 0
75730: PUSH
75731: LD_INT 1
75733: NEG
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: LD_INT 1
75741: PUSH
75742: LD_INT 0
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 1
75751: PUSH
75752: LD_INT 1
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 0
75761: PUSH
75762: LD_INT 1
75764: PUSH
75765: EMPTY
75766: LIST
75767: LIST
75768: PUSH
75769: LD_INT 1
75771: NEG
75772: PUSH
75773: LD_INT 0
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 1
75782: NEG
75783: PUSH
75784: LD_INT 1
75786: NEG
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75801: LD_ADDR_VAR 0 61
75805: PUSH
75806: LD_INT 0
75808: PUSH
75809: LD_INT 0
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: LD_INT 0
75818: PUSH
75819: LD_INT 1
75821: NEG
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 1
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 1
75839: PUSH
75840: LD_INT 1
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: LD_INT 0
75849: PUSH
75850: LD_INT 1
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: LD_INT 1
75859: NEG
75860: PUSH
75861: LD_INT 0
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 1
75870: NEG
75871: PUSH
75872: LD_INT 1
75874: NEG
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: LIST
75884: LIST
75885: LIST
75886: LIST
75887: LIST
75888: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75889: LD_ADDR_VAR 0 62
75893: PUSH
75894: LD_INT 0
75896: PUSH
75897: LD_INT 0
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 0
75906: PUSH
75907: LD_INT 1
75909: NEG
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: LD_INT 1
75917: PUSH
75918: LD_INT 0
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PUSH
75925: LD_INT 1
75927: PUSH
75928: LD_INT 1
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: LD_INT 1
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 1
75947: NEG
75948: PUSH
75949: LD_INT 0
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 1
75958: NEG
75959: PUSH
75960: LD_INT 1
75962: NEG
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: LIST
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75977: LD_ADDR_VAR 0 63
75981: PUSH
75982: LD_INT 0
75984: PUSH
75985: LD_INT 0
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 0
75994: PUSH
75995: LD_INT 1
75997: NEG
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 1
76005: PUSH
76006: LD_INT 0
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 1
76015: PUSH
76016: LD_INT 1
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 0
76025: PUSH
76026: LD_INT 1
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 1
76035: NEG
76036: PUSH
76037: LD_INT 0
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 1
76046: NEG
76047: PUSH
76048: LD_INT 1
76050: NEG
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76065: LD_ADDR_VAR 0 64
76069: PUSH
76070: LD_INT 0
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: LD_INT 0
76082: PUSH
76083: LD_INT 1
76085: NEG
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 1
76093: PUSH
76094: LD_INT 0
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 1
76103: PUSH
76104: LD_INT 1
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 0
76113: PUSH
76114: LD_INT 1
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 1
76123: NEG
76124: PUSH
76125: LD_INT 0
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 1
76134: NEG
76135: PUSH
76136: LD_INT 1
76138: NEG
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: LIST
76148: LIST
76149: LIST
76150: LIST
76151: LIST
76152: ST_TO_ADDR
// end ; 1 :
76153: GO 82050
76155: LD_INT 1
76157: DOUBLE
76158: EQUAL
76159: IFTRUE 76163
76161: GO 78786
76163: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76164: LD_ADDR_VAR 0 11
76168: PUSH
76169: LD_INT 1
76171: NEG
76172: PUSH
76173: LD_INT 3
76175: NEG
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: LD_INT 3
76186: NEG
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 1
76194: PUSH
76195: LD_INT 2
76197: NEG
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: LIST
76207: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76208: LD_ADDR_VAR 0 12
76212: PUSH
76213: LD_INT 2
76215: PUSH
76216: LD_INT 1
76218: NEG
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 3
76226: PUSH
76227: LD_INT 0
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 3
76236: PUSH
76237: LD_INT 1
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: LIST
76248: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76249: LD_ADDR_VAR 0 13
76253: PUSH
76254: LD_INT 3
76256: PUSH
76257: LD_INT 2
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: LD_INT 3
76266: PUSH
76267: LD_INT 3
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 2
76276: PUSH
76277: LD_INT 3
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: LIST
76288: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76289: LD_ADDR_VAR 0 14
76293: PUSH
76294: LD_INT 1
76296: PUSH
76297: LD_INT 3
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 0
76306: PUSH
76307: LD_INT 3
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 1
76316: NEG
76317: PUSH
76318: LD_INT 2
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: LIST
76329: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76330: LD_ADDR_VAR 0 15
76334: PUSH
76335: LD_INT 2
76337: NEG
76338: PUSH
76339: LD_INT 1
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 3
76348: NEG
76349: PUSH
76350: LD_INT 0
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 3
76359: NEG
76360: PUSH
76361: LD_INT 1
76363: NEG
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: LIST
76373: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76374: LD_ADDR_VAR 0 16
76378: PUSH
76379: LD_INT 2
76381: NEG
76382: PUSH
76383: LD_INT 3
76385: NEG
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 3
76393: NEG
76394: PUSH
76395: LD_INT 2
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 3
76405: NEG
76406: PUSH
76407: LD_INT 3
76409: NEG
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: LIST
76419: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76420: LD_ADDR_VAR 0 17
76424: PUSH
76425: LD_INT 1
76427: NEG
76428: PUSH
76429: LD_INT 3
76431: NEG
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 0
76439: PUSH
76440: LD_INT 3
76442: NEG
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 1
76450: PUSH
76451: LD_INT 2
76453: NEG
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: LIST
76463: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76464: LD_ADDR_VAR 0 18
76468: PUSH
76469: LD_INT 2
76471: PUSH
76472: LD_INT 1
76474: NEG
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PUSH
76480: LD_INT 3
76482: PUSH
76483: LD_INT 0
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 3
76492: PUSH
76493: LD_INT 1
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: LIST
76504: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76505: LD_ADDR_VAR 0 19
76509: PUSH
76510: LD_INT 3
76512: PUSH
76513: LD_INT 2
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 3
76522: PUSH
76523: LD_INT 3
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 2
76532: PUSH
76533: LD_INT 3
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: LIST
76544: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76545: LD_ADDR_VAR 0 20
76549: PUSH
76550: LD_INT 1
76552: PUSH
76553: LD_INT 3
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 0
76562: PUSH
76563: LD_INT 3
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: LD_INT 1
76572: NEG
76573: PUSH
76574: LD_INT 2
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: LIST
76585: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76586: LD_ADDR_VAR 0 21
76590: PUSH
76591: LD_INT 2
76593: NEG
76594: PUSH
76595: LD_INT 1
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 3
76604: NEG
76605: PUSH
76606: LD_INT 0
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 3
76615: NEG
76616: PUSH
76617: LD_INT 1
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: LIST
76629: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76630: LD_ADDR_VAR 0 22
76634: PUSH
76635: LD_INT 2
76637: NEG
76638: PUSH
76639: LD_INT 3
76641: NEG
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 3
76649: NEG
76650: PUSH
76651: LD_INT 2
76653: NEG
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 3
76661: NEG
76662: PUSH
76663: LD_INT 3
76665: NEG
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: LIST
76675: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76676: LD_ADDR_VAR 0 23
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: LD_INT 3
76686: NEG
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: LD_INT 1
76694: NEG
76695: PUSH
76696: LD_INT 4
76698: NEG
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 1
76706: PUSH
76707: LD_INT 3
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: LIST
76719: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76720: LD_ADDR_VAR 0 24
76724: PUSH
76725: LD_INT 3
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 3
76737: PUSH
76738: LD_INT 1
76740: NEG
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: LD_INT 4
76748: PUSH
76749: LD_INT 1
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: LIST
76760: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76761: LD_ADDR_VAR 0 25
76765: PUSH
76766: LD_INT 3
76768: PUSH
76769: LD_INT 3
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 4
76778: PUSH
76779: LD_INT 3
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 3
76788: PUSH
76789: LD_INT 4
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: LIST
76800: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76801: LD_ADDR_VAR 0 26
76805: PUSH
76806: LD_INT 0
76808: PUSH
76809: LD_INT 3
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: LD_INT 4
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 1
76828: NEG
76829: PUSH
76830: LD_INT 3
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: LIST
76841: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76842: LD_ADDR_VAR 0 27
76846: PUSH
76847: LD_INT 3
76849: NEG
76850: PUSH
76851: LD_INT 0
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 3
76860: NEG
76861: PUSH
76862: LD_INT 1
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 4
76871: NEG
76872: PUSH
76873: LD_INT 1
76875: NEG
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: LIST
76885: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76886: LD_ADDR_VAR 0 28
76890: PUSH
76891: LD_INT 3
76893: NEG
76894: PUSH
76895: LD_INT 3
76897: NEG
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 3
76905: NEG
76906: PUSH
76907: LD_INT 4
76909: NEG
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 4
76917: NEG
76918: PUSH
76919: LD_INT 3
76921: NEG
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: LIST
76931: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76932: LD_ADDR_VAR 0 29
76936: PUSH
76937: LD_INT 1
76939: NEG
76940: PUSH
76941: LD_INT 3
76943: NEG
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 0
76951: PUSH
76952: LD_INT 3
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 1
76962: PUSH
76963: LD_INT 2
76965: NEG
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 1
76973: NEG
76974: PUSH
76975: LD_INT 4
76977: NEG
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 0
76985: PUSH
76986: LD_INT 4
76988: NEG
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 1
76996: PUSH
76997: LD_INT 3
76999: NEG
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 1
77007: NEG
77008: PUSH
77009: LD_INT 5
77011: NEG
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 0
77019: PUSH
77020: LD_INT 5
77022: NEG
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 1
77030: PUSH
77031: LD_INT 4
77033: NEG
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 1
77041: NEG
77042: PUSH
77043: LD_INT 6
77045: NEG
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: LD_INT 0
77053: PUSH
77054: LD_INT 6
77056: NEG
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: LD_INT 1
77064: PUSH
77065: LD_INT 5
77067: NEG
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77087: LD_ADDR_VAR 0 30
77091: PUSH
77092: LD_INT 2
77094: PUSH
77095: LD_INT 1
77097: NEG
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 3
77105: PUSH
77106: LD_INT 0
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 3
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 3
77125: PUSH
77126: LD_INT 1
77128: NEG
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 4
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 4
77146: PUSH
77147: LD_INT 1
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: LD_INT 4
77156: PUSH
77157: LD_INT 1
77159: NEG
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 5
77167: PUSH
77168: LD_INT 0
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 5
77177: PUSH
77178: LD_INT 1
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 5
77187: PUSH
77188: LD_INT 1
77190: NEG
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: LD_INT 6
77198: PUSH
77199: LD_INT 0
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 6
77208: PUSH
77209: LD_INT 1
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: LIST
77226: LIST
77227: LIST
77228: LIST
77229: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
77230: LD_ADDR_VAR 0 31
77234: PUSH
77235: LD_INT 3
77237: PUSH
77238: LD_INT 2
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 3
77247: PUSH
77248: LD_INT 3
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 2
77257: PUSH
77258: LD_INT 3
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 4
77267: PUSH
77268: LD_INT 3
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 4
77277: PUSH
77278: LD_INT 4
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 3
77287: PUSH
77288: LD_INT 4
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 5
77297: PUSH
77298: LD_INT 4
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 5
77307: PUSH
77308: LD_INT 5
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 4
77317: PUSH
77318: LD_INT 5
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 6
77327: PUSH
77328: LD_INT 5
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 6
77337: PUSH
77338: LD_INT 6
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 5
77347: PUSH
77348: LD_INT 6
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77369: LD_ADDR_VAR 0 32
77373: PUSH
77374: LD_INT 1
77376: PUSH
77377: LD_INT 3
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 0
77386: PUSH
77387: LD_INT 3
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 1
77396: NEG
77397: PUSH
77398: LD_INT 2
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 1
77407: PUSH
77408: LD_INT 4
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: LD_INT 0
77417: PUSH
77418: LD_INT 4
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 1
77427: NEG
77428: PUSH
77429: LD_INT 3
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 1
77438: PUSH
77439: LD_INT 5
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 0
77448: PUSH
77449: LD_INT 5
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 1
77458: NEG
77459: PUSH
77460: LD_INT 4
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 1
77469: PUSH
77470: LD_INT 6
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 0
77479: PUSH
77480: LD_INT 6
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: LD_INT 1
77489: NEG
77490: PUSH
77491: LD_INT 5
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: LIST
77502: LIST
77503: LIST
77504: LIST
77505: LIST
77506: LIST
77507: LIST
77508: LIST
77509: LIST
77510: LIST
77511: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77512: LD_ADDR_VAR 0 33
77516: PUSH
77517: LD_INT 2
77519: NEG
77520: PUSH
77521: LD_INT 1
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 3
77530: NEG
77531: PUSH
77532: LD_INT 0
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 3
77541: NEG
77542: PUSH
77543: LD_INT 1
77545: NEG
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 3
77553: NEG
77554: PUSH
77555: LD_INT 1
77557: PUSH
77558: EMPTY
77559: LIST
77560: LIST
77561: PUSH
77562: LD_INT 4
77564: NEG
77565: PUSH
77566: LD_INT 0
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 4
77575: NEG
77576: PUSH
77577: LD_INT 1
77579: NEG
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 4
77587: NEG
77588: PUSH
77589: LD_INT 1
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: PUSH
77596: LD_INT 5
77598: NEG
77599: PUSH
77600: LD_INT 0
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 5
77609: NEG
77610: PUSH
77611: LD_INT 1
77613: NEG
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 5
77621: NEG
77622: PUSH
77623: LD_INT 1
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 6
77632: NEG
77633: PUSH
77634: LD_INT 0
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 6
77643: NEG
77644: PUSH
77645: LD_INT 1
77647: NEG
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77667: LD_ADDR_VAR 0 34
77671: PUSH
77672: LD_INT 2
77674: NEG
77675: PUSH
77676: LD_INT 3
77678: NEG
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 3
77686: NEG
77687: PUSH
77688: LD_INT 2
77690: NEG
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 3
77698: NEG
77699: PUSH
77700: LD_INT 3
77702: NEG
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 3
77710: NEG
77711: PUSH
77712: LD_INT 4
77714: NEG
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: PUSH
77720: LD_INT 4
77722: NEG
77723: PUSH
77724: LD_INT 3
77726: NEG
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: LD_INT 4
77734: NEG
77735: PUSH
77736: LD_INT 4
77738: NEG
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 4
77746: NEG
77747: PUSH
77748: LD_INT 5
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 5
77758: NEG
77759: PUSH
77760: LD_INT 4
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 5
77770: NEG
77771: PUSH
77772: LD_INT 5
77774: NEG
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 5
77782: NEG
77783: PUSH
77784: LD_INT 6
77786: NEG
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 6
77794: NEG
77795: PUSH
77796: LD_INT 5
77798: NEG
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 6
77806: NEG
77807: PUSH
77808: LD_INT 6
77810: NEG
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77830: LD_ADDR_VAR 0 41
77834: PUSH
77835: LD_INT 0
77837: PUSH
77838: LD_INT 2
77840: NEG
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: LD_INT 1
77848: NEG
77849: PUSH
77850: LD_INT 3
77852: NEG
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 1
77860: PUSH
77861: LD_INT 2
77863: NEG
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77874: LD_ADDR_VAR 0 42
77878: PUSH
77879: LD_INT 2
77881: PUSH
77882: LD_INT 0
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 2
77891: PUSH
77892: LD_INT 1
77894: NEG
77895: PUSH
77896: EMPTY
77897: LIST
77898: LIST
77899: PUSH
77900: LD_INT 3
77902: PUSH
77903: LD_INT 1
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: LIST
77914: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77915: LD_ADDR_VAR 0 43
77919: PUSH
77920: LD_INT 2
77922: PUSH
77923: LD_INT 2
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 3
77932: PUSH
77933: LD_INT 2
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 2
77942: PUSH
77943: LD_INT 3
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: LIST
77954: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77955: LD_ADDR_VAR 0 44
77959: PUSH
77960: LD_INT 0
77962: PUSH
77963: LD_INT 2
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 1
77972: PUSH
77973: LD_INT 3
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PUSH
77980: LD_INT 1
77982: NEG
77983: PUSH
77984: LD_INT 2
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: LIST
77995: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77996: LD_ADDR_VAR 0 45
78000: PUSH
78001: LD_INT 2
78003: NEG
78004: PUSH
78005: LD_INT 0
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: PUSH
78012: LD_INT 2
78014: NEG
78015: PUSH
78016: LD_INT 1
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PUSH
78023: LD_INT 3
78025: NEG
78026: PUSH
78027: LD_INT 1
78029: NEG
78030: PUSH
78031: EMPTY
78032: LIST
78033: LIST
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: LIST
78039: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78040: LD_ADDR_VAR 0 46
78044: PUSH
78045: LD_INT 2
78047: NEG
78048: PUSH
78049: LD_INT 2
78051: NEG
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 2
78059: NEG
78060: PUSH
78061: LD_INT 3
78063: NEG
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 3
78071: NEG
78072: PUSH
78073: LD_INT 2
78075: NEG
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: LIST
78085: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78086: LD_ADDR_VAR 0 47
78090: PUSH
78091: LD_INT 2
78093: NEG
78094: PUSH
78095: LD_INT 3
78097: NEG
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 1
78105: NEG
78106: PUSH
78107: LD_INT 3
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78119: LD_ADDR_VAR 0 48
78123: PUSH
78124: LD_INT 1
78126: PUSH
78127: LD_INT 2
78129: NEG
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 2
78137: PUSH
78138: LD_INT 1
78140: NEG
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78150: LD_ADDR_VAR 0 49
78154: PUSH
78155: LD_INT 3
78157: PUSH
78158: LD_INT 1
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 3
78167: PUSH
78168: LD_INT 2
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78179: LD_ADDR_VAR 0 50
78183: PUSH
78184: LD_INT 2
78186: PUSH
78187: LD_INT 3
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 1
78196: PUSH
78197: LD_INT 3
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78208: LD_ADDR_VAR 0 51
78212: PUSH
78213: LD_INT 1
78215: NEG
78216: PUSH
78217: LD_INT 2
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 2
78226: NEG
78227: PUSH
78228: LD_INT 1
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78239: LD_ADDR_VAR 0 52
78243: PUSH
78244: LD_INT 3
78246: NEG
78247: PUSH
78248: LD_INT 1
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 3
78258: NEG
78259: PUSH
78260: LD_INT 2
78262: NEG
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78272: LD_ADDR_VAR 0 53
78276: PUSH
78277: LD_INT 1
78279: NEG
78280: PUSH
78281: LD_INT 3
78283: NEG
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PUSH
78289: LD_INT 0
78291: PUSH
78292: LD_INT 3
78294: NEG
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: LD_INT 1
78302: PUSH
78303: LD_INT 2
78305: NEG
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: LIST
78315: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78316: LD_ADDR_VAR 0 54
78320: PUSH
78321: LD_INT 2
78323: PUSH
78324: LD_INT 1
78326: NEG
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 3
78334: PUSH
78335: LD_INT 0
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 3
78344: PUSH
78345: LD_INT 1
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: EMPTY
78353: LIST
78354: LIST
78355: LIST
78356: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78357: LD_ADDR_VAR 0 55
78361: PUSH
78362: LD_INT 3
78364: PUSH
78365: LD_INT 2
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 3
78374: PUSH
78375: LD_INT 3
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 2
78384: PUSH
78385: LD_INT 3
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: LIST
78396: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78397: LD_ADDR_VAR 0 56
78401: PUSH
78402: LD_INT 1
78404: PUSH
78405: LD_INT 3
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 0
78414: PUSH
78415: LD_INT 3
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 1
78424: NEG
78425: PUSH
78426: LD_INT 2
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: EMPTY
78434: LIST
78435: LIST
78436: LIST
78437: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78438: LD_ADDR_VAR 0 57
78442: PUSH
78443: LD_INT 2
78445: NEG
78446: PUSH
78447: LD_INT 1
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 3
78456: NEG
78457: PUSH
78458: LD_INT 0
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 3
78467: NEG
78468: PUSH
78469: LD_INT 1
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: LIST
78481: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78482: LD_ADDR_VAR 0 58
78486: PUSH
78487: LD_INT 2
78489: NEG
78490: PUSH
78491: LD_INT 3
78493: NEG
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 3
78501: NEG
78502: PUSH
78503: LD_INT 2
78505: NEG
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: PUSH
78511: LD_INT 3
78513: NEG
78514: PUSH
78515: LD_INT 3
78517: NEG
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: LIST
78527: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78528: LD_ADDR_VAR 0 59
78532: PUSH
78533: LD_INT 1
78535: NEG
78536: PUSH
78537: LD_INT 2
78539: NEG
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 0
78547: PUSH
78548: LD_INT 2
78550: NEG
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: LD_INT 1
78558: PUSH
78559: LD_INT 1
78561: NEG
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: EMPTY
78568: LIST
78569: LIST
78570: LIST
78571: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78572: LD_ADDR_VAR 0 60
78576: PUSH
78577: LD_INT 1
78579: PUSH
78580: LD_INT 1
78582: NEG
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: PUSH
78588: LD_INT 2
78590: PUSH
78591: LD_INT 0
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 2
78600: PUSH
78601: LD_INT 1
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: LIST
78612: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78613: LD_ADDR_VAR 0 61
78617: PUSH
78618: LD_INT 2
78620: PUSH
78621: LD_INT 1
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 2
78630: PUSH
78631: LD_INT 2
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 1
78640: PUSH
78641: LD_INT 2
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: LIST
78652: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78653: LD_ADDR_VAR 0 62
78657: PUSH
78658: LD_INT 1
78660: PUSH
78661: LD_INT 2
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 0
78670: PUSH
78671: LD_INT 2
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 1
78680: NEG
78681: PUSH
78682: LD_INT 1
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: LIST
78693: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78694: LD_ADDR_VAR 0 63
78698: PUSH
78699: LD_INT 1
78701: NEG
78702: PUSH
78703: LD_INT 1
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 2
78712: NEG
78713: PUSH
78714: LD_INT 0
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 2
78723: NEG
78724: PUSH
78725: LD_INT 1
78727: NEG
78728: PUSH
78729: EMPTY
78730: LIST
78731: LIST
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: LIST
78737: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78738: LD_ADDR_VAR 0 64
78742: PUSH
78743: LD_INT 1
78745: NEG
78746: PUSH
78747: LD_INT 2
78749: NEG
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: LD_INT 2
78757: NEG
78758: PUSH
78759: LD_INT 1
78761: NEG
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 2
78769: NEG
78770: PUSH
78771: LD_INT 2
78773: NEG
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: LIST
78783: ST_TO_ADDR
// end ; 2 :
78784: GO 82050
78786: LD_INT 2
78788: DOUBLE
78789: EQUAL
78790: IFTRUE 78794
78792: GO 82049
78794: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78795: LD_ADDR_VAR 0 29
78799: PUSH
78800: LD_INT 4
78802: PUSH
78803: LD_INT 0
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 4
78812: PUSH
78813: LD_INT 1
78815: NEG
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 5
78823: PUSH
78824: LD_INT 0
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 5
78833: PUSH
78834: LD_INT 1
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: LD_INT 4
78843: PUSH
78844: LD_INT 1
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PUSH
78851: LD_INT 3
78853: PUSH
78854: LD_INT 0
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 3
78863: PUSH
78864: LD_INT 1
78866: NEG
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 3
78874: PUSH
78875: LD_INT 2
78877: NEG
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 5
78885: PUSH
78886: LD_INT 2
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: LD_INT 3
78895: PUSH
78896: LD_INT 3
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 3
78905: PUSH
78906: LD_INT 2
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: PUSH
78913: LD_INT 4
78915: PUSH
78916: LD_INT 3
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 4
78925: PUSH
78926: LD_INT 4
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 3
78935: PUSH
78936: LD_INT 4
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 2
78945: PUSH
78946: LD_INT 3
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 2
78955: PUSH
78956: LD_INT 2
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 4
78965: PUSH
78966: LD_INT 2
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 2
78975: PUSH
78976: LD_INT 4
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 0
78985: PUSH
78986: LD_INT 4
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 0
78995: PUSH
78996: LD_INT 3
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 1
79005: PUSH
79006: LD_INT 4
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 1
79015: PUSH
79016: LD_INT 5
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 0
79025: PUSH
79026: LD_INT 5
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 1
79035: NEG
79036: PUSH
79037: LD_INT 4
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 1
79046: NEG
79047: PUSH
79048: LD_INT 3
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 2
79057: PUSH
79058: LD_INT 5
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 2
79067: NEG
79068: PUSH
79069: LD_INT 3
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 3
79078: NEG
79079: PUSH
79080: LD_INT 0
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 3
79089: NEG
79090: PUSH
79091: LD_INT 1
79093: NEG
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 2
79101: NEG
79102: PUSH
79103: LD_INT 0
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: LD_INT 2
79112: NEG
79113: PUSH
79114: LD_INT 1
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 3
79123: NEG
79124: PUSH
79125: LD_INT 1
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 4
79134: NEG
79135: PUSH
79136: LD_INT 0
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PUSH
79143: LD_INT 4
79145: NEG
79146: PUSH
79147: LD_INT 1
79149: NEG
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 4
79157: NEG
79158: PUSH
79159: LD_INT 2
79161: NEG
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 2
79169: NEG
79170: PUSH
79171: LD_INT 2
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 4
79180: NEG
79181: PUSH
79182: LD_INT 4
79184: NEG
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 4
79192: NEG
79193: PUSH
79194: LD_INT 5
79196: NEG
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 3
79204: NEG
79205: PUSH
79206: LD_INT 4
79208: NEG
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 3
79216: NEG
79217: PUSH
79218: LD_INT 3
79220: NEG
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 4
79228: NEG
79229: PUSH
79230: LD_INT 3
79232: NEG
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 5
79240: NEG
79241: PUSH
79242: LD_INT 4
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 5
79252: NEG
79253: PUSH
79254: LD_INT 5
79256: NEG
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 3
79264: NEG
79265: PUSH
79266: LD_INT 5
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 5
79276: NEG
79277: PUSH
79278: LD_INT 3
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: LIST
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79333: LD_ADDR_VAR 0 30
79337: PUSH
79338: LD_INT 4
79340: PUSH
79341: LD_INT 4
79343: PUSH
79344: EMPTY
79345: LIST
79346: LIST
79347: PUSH
79348: LD_INT 4
79350: PUSH
79351: LD_INT 3
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 5
79360: PUSH
79361: LD_INT 4
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 5
79370: PUSH
79371: LD_INT 5
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 4
79380: PUSH
79381: LD_INT 5
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 3
79390: PUSH
79391: LD_INT 4
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 3
79400: PUSH
79401: LD_INT 3
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: LD_INT 5
79410: PUSH
79411: LD_INT 3
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 3
79420: PUSH
79421: LD_INT 5
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 0
79430: PUSH
79431: LD_INT 3
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: LD_INT 2
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 1
79450: PUSH
79451: LD_INT 3
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 1
79460: PUSH
79461: LD_INT 4
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 0
79470: PUSH
79471: LD_INT 4
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 1
79480: NEG
79481: PUSH
79482: LD_INT 3
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 1
79491: NEG
79492: PUSH
79493: LD_INT 2
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 2
79502: PUSH
79503: LD_INT 4
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 2
79512: NEG
79513: PUSH
79514: LD_INT 2
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 4
79523: NEG
79524: PUSH
79525: LD_INT 0
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 4
79534: NEG
79535: PUSH
79536: LD_INT 1
79538: NEG
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 3
79546: NEG
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 3
79557: NEG
79558: PUSH
79559: LD_INT 1
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: PUSH
79566: LD_INT 4
79568: NEG
79569: PUSH
79570: LD_INT 1
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 5
79579: NEG
79580: PUSH
79581: LD_INT 0
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 5
79590: NEG
79591: PUSH
79592: LD_INT 1
79594: NEG
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: LD_INT 5
79602: NEG
79603: PUSH
79604: LD_INT 2
79606: NEG
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 3
79614: NEG
79615: PUSH
79616: LD_INT 2
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: LD_INT 3
79625: NEG
79626: PUSH
79627: LD_INT 3
79629: NEG
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 3
79637: NEG
79638: PUSH
79639: LD_INT 4
79641: NEG
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 2
79649: NEG
79650: PUSH
79651: LD_INT 3
79653: NEG
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 2
79661: NEG
79662: PUSH
79663: LD_INT 2
79665: NEG
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 3
79673: NEG
79674: PUSH
79675: LD_INT 2
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 4
79685: NEG
79686: PUSH
79687: LD_INT 3
79689: NEG
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 4
79697: NEG
79698: PUSH
79699: LD_INT 4
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 2
79709: NEG
79710: PUSH
79711: LD_INT 4
79713: NEG
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 4
79721: NEG
79722: PUSH
79723: LD_INT 2
79725: NEG
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 0
79733: PUSH
79734: LD_INT 4
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 0
79744: PUSH
79745: LD_INT 5
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 1
79755: PUSH
79756: LD_INT 4
79758: NEG
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 1
79766: PUSH
79767: LD_INT 3
79769: NEG
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 0
79777: PUSH
79778: LD_INT 3
79780: NEG
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 1
79788: NEG
79789: PUSH
79790: LD_INT 4
79792: NEG
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 1
79800: NEG
79801: PUSH
79802: LD_INT 5
79804: NEG
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 2
79812: PUSH
79813: LD_INT 3
79815: NEG
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: LD_INT 2
79823: NEG
79824: PUSH
79825: LD_INT 5
79827: NEG
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: LIST
79837: LIST
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79880: LD_ADDR_VAR 0 31
79884: PUSH
79885: LD_INT 0
79887: PUSH
79888: LD_INT 4
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 0
79897: PUSH
79898: LD_INT 3
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: LD_INT 1
79907: PUSH
79908: LD_INT 4
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: LD_INT 5
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 0
79927: PUSH
79928: LD_INT 5
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: LD_INT 1
79937: NEG
79938: PUSH
79939: LD_INT 4
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 1
79948: NEG
79949: PUSH
79950: LD_INT 3
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 2
79959: PUSH
79960: LD_INT 5
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 2
79969: NEG
79970: PUSH
79971: LD_INT 3
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 3
79980: NEG
79981: PUSH
79982: LD_INT 0
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 3
79991: NEG
79992: PUSH
79993: LD_INT 1
79995: NEG
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 2
80003: NEG
80004: PUSH
80005: LD_INT 0
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 2
80014: NEG
80015: PUSH
80016: LD_INT 1
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 3
80025: NEG
80026: PUSH
80027: LD_INT 1
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 4
80036: NEG
80037: PUSH
80038: LD_INT 0
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 4
80047: NEG
80048: PUSH
80049: LD_INT 1
80051: NEG
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 4
80059: NEG
80060: PUSH
80061: LD_INT 2
80063: NEG
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 2
80071: NEG
80072: PUSH
80073: LD_INT 2
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 4
80082: NEG
80083: PUSH
80084: LD_INT 4
80086: NEG
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: LD_INT 4
80094: NEG
80095: PUSH
80096: LD_INT 5
80098: NEG
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 3
80106: NEG
80107: PUSH
80108: LD_INT 4
80110: NEG
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 3
80118: NEG
80119: PUSH
80120: LD_INT 3
80122: NEG
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 4
80130: NEG
80131: PUSH
80132: LD_INT 3
80134: NEG
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 5
80142: NEG
80143: PUSH
80144: LD_INT 4
80146: NEG
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 5
80154: NEG
80155: PUSH
80156: LD_INT 5
80158: NEG
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 3
80166: NEG
80167: PUSH
80168: LD_INT 5
80170: NEG
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 5
80178: NEG
80179: PUSH
80180: LD_INT 3
80182: NEG
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 3
80193: NEG
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 0
80201: PUSH
80202: LD_INT 4
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 1
80212: PUSH
80213: LD_INT 3
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: PUSH
80224: LD_INT 2
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 0
80234: PUSH
80235: LD_INT 2
80237: NEG
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 1
80245: NEG
80246: PUSH
80247: LD_INT 3
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 1
80257: NEG
80258: PUSH
80259: LD_INT 4
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 2
80269: PUSH
80270: LD_INT 2
80272: NEG
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 2
80280: NEG
80281: PUSH
80282: LD_INT 4
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 4
80292: PUSH
80293: LD_INT 0
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 4
80302: PUSH
80303: LD_INT 1
80305: NEG
80306: PUSH
80307: EMPTY
80308: LIST
80309: LIST
80310: PUSH
80311: LD_INT 5
80313: PUSH
80314: LD_INT 0
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 5
80323: PUSH
80324: LD_INT 1
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: LD_INT 4
80333: PUSH
80334: LD_INT 1
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 3
80343: PUSH
80344: LD_INT 0
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 3
80353: PUSH
80354: LD_INT 1
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 3
80364: PUSH
80365: LD_INT 2
80367: NEG
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: LD_INT 5
80375: PUSH
80376: LD_INT 2
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: LIST
80421: LIST
80422: LIST
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80430: LD_ADDR_VAR 0 32
80434: PUSH
80435: LD_INT 4
80437: NEG
80438: PUSH
80439: LD_INT 0
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 4
80448: NEG
80449: PUSH
80450: LD_INT 1
80452: NEG
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 3
80460: NEG
80461: PUSH
80462: LD_INT 0
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 3
80471: NEG
80472: PUSH
80473: LD_INT 1
80475: PUSH
80476: EMPTY
80477: LIST
80478: LIST
80479: PUSH
80480: LD_INT 4
80482: NEG
80483: PUSH
80484: LD_INT 1
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: PUSH
80491: LD_INT 5
80493: NEG
80494: PUSH
80495: LD_INT 0
80497: PUSH
80498: EMPTY
80499: LIST
80500: LIST
80501: PUSH
80502: LD_INT 5
80504: NEG
80505: PUSH
80506: LD_INT 1
80508: NEG
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: PUSH
80514: LD_INT 5
80516: NEG
80517: PUSH
80518: LD_INT 2
80520: NEG
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 3
80528: NEG
80529: PUSH
80530: LD_INT 2
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 3
80539: NEG
80540: PUSH
80541: LD_INT 3
80543: NEG
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 3
80551: NEG
80552: PUSH
80553: LD_INT 4
80555: NEG
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PUSH
80561: LD_INT 2
80563: NEG
80564: PUSH
80565: LD_INT 3
80567: NEG
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 2
80575: NEG
80576: PUSH
80577: LD_INT 2
80579: NEG
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 3
80587: NEG
80588: PUSH
80589: LD_INT 2
80591: NEG
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: LD_INT 4
80599: NEG
80600: PUSH
80601: LD_INT 3
80603: NEG
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 4
80611: NEG
80612: PUSH
80613: LD_INT 4
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 2
80623: NEG
80624: PUSH
80625: LD_INT 4
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 4
80635: NEG
80636: PUSH
80637: LD_INT 2
80639: NEG
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: LD_INT 4
80650: NEG
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 0
80658: PUSH
80659: LD_INT 5
80661: NEG
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 1
80669: PUSH
80670: LD_INT 4
80672: NEG
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 1
80680: PUSH
80681: LD_INT 3
80683: NEG
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 0
80691: PUSH
80692: LD_INT 3
80694: NEG
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 1
80702: NEG
80703: PUSH
80704: LD_INT 4
80706: NEG
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 1
80714: NEG
80715: PUSH
80716: LD_INT 5
80718: NEG
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 2
80726: PUSH
80727: LD_INT 3
80729: NEG
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 2
80737: NEG
80738: PUSH
80739: LD_INT 5
80741: NEG
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 3
80749: PUSH
80750: LD_INT 0
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 3
80759: PUSH
80760: LD_INT 1
80762: NEG
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: PUSH
80768: LD_INT 4
80770: PUSH
80771: LD_INT 0
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 4
80780: PUSH
80781: LD_INT 1
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 3
80790: PUSH
80791: LD_INT 1
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 2
80800: PUSH
80801: LD_INT 0
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 2
80810: PUSH
80811: LD_INT 1
80813: NEG
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 2
80821: PUSH
80822: LD_INT 2
80824: NEG
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 4
80832: PUSH
80833: LD_INT 2
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 4
80842: PUSH
80843: LD_INT 4
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 4
80852: PUSH
80853: LD_INT 3
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: LD_INT 5
80862: PUSH
80863: LD_INT 4
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 5
80872: PUSH
80873: LD_INT 5
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 4
80882: PUSH
80883: LD_INT 5
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 3
80892: PUSH
80893: LD_INT 4
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: LD_INT 3
80902: PUSH
80903: LD_INT 3
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 5
80912: PUSH
80913: LD_INT 3
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 3
80922: PUSH
80923: LD_INT 5
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80977: LD_ADDR_VAR 0 33
80981: PUSH
80982: LD_INT 4
80984: NEG
80985: PUSH
80986: LD_INT 4
80988: NEG
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 4
80996: NEG
80997: PUSH
80998: LD_INT 5
81000: NEG
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 3
81008: NEG
81009: PUSH
81010: LD_INT 4
81012: NEG
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: LD_INT 3
81020: NEG
81021: PUSH
81022: LD_INT 3
81024: NEG
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 4
81032: NEG
81033: PUSH
81034: LD_INT 3
81036: NEG
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 5
81044: NEG
81045: PUSH
81046: LD_INT 4
81048: NEG
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: PUSH
81054: LD_INT 5
81056: NEG
81057: PUSH
81058: LD_INT 5
81060: NEG
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: LD_INT 3
81068: NEG
81069: PUSH
81070: LD_INT 5
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 5
81080: NEG
81081: PUSH
81082: LD_INT 3
81084: NEG
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 0
81092: PUSH
81093: LD_INT 3
81095: NEG
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 0
81103: PUSH
81104: LD_INT 4
81106: NEG
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 1
81114: PUSH
81115: LD_INT 3
81117: NEG
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 1
81125: PUSH
81126: LD_INT 2
81128: NEG
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 0
81136: PUSH
81137: LD_INT 2
81139: NEG
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PUSH
81145: LD_INT 1
81147: NEG
81148: PUSH
81149: LD_INT 3
81151: NEG
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 1
81159: NEG
81160: PUSH
81161: LD_INT 4
81163: NEG
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 2
81171: PUSH
81172: LD_INT 2
81174: NEG
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 2
81182: NEG
81183: PUSH
81184: LD_INT 4
81186: NEG
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 4
81194: PUSH
81195: LD_INT 0
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 4
81204: PUSH
81205: LD_INT 1
81207: NEG
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 5
81215: PUSH
81216: LD_INT 0
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 5
81225: PUSH
81226: LD_INT 1
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 4
81235: PUSH
81236: LD_INT 1
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: PUSH
81243: LD_INT 3
81245: PUSH
81246: LD_INT 0
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: LD_INT 3
81255: PUSH
81256: LD_INT 1
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 3
81266: PUSH
81267: LD_INT 2
81269: NEG
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: PUSH
81275: LD_INT 5
81277: PUSH
81278: LD_INT 2
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 3
81287: PUSH
81288: LD_INT 3
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 3
81297: PUSH
81298: LD_INT 2
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 4
81307: PUSH
81308: LD_INT 3
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 4
81317: PUSH
81318: LD_INT 4
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 3
81327: PUSH
81328: LD_INT 4
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 2
81337: PUSH
81338: LD_INT 3
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 2
81347: PUSH
81348: LD_INT 2
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 4
81357: PUSH
81358: LD_INT 2
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 2
81367: PUSH
81368: LD_INT 4
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 0
81377: PUSH
81378: LD_INT 4
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 0
81387: PUSH
81388: LD_INT 3
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 1
81397: PUSH
81398: LD_INT 4
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 1
81407: PUSH
81408: LD_INT 5
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 0
81417: PUSH
81418: LD_INT 5
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 1
81427: NEG
81428: PUSH
81429: LD_INT 4
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 1
81438: NEG
81439: PUSH
81440: LD_INT 3
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 2
81449: PUSH
81450: LD_INT 5
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 2
81459: NEG
81460: PUSH
81461: LD_INT 3
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81515: LD_ADDR_VAR 0 34
81519: PUSH
81520: LD_INT 0
81522: PUSH
81523: LD_INT 4
81525: NEG
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 0
81533: PUSH
81534: LD_INT 5
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 1
81544: PUSH
81545: LD_INT 4
81547: NEG
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 1
81555: PUSH
81556: LD_INT 3
81558: NEG
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 0
81566: PUSH
81567: LD_INT 3
81569: NEG
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: LD_INT 4
81581: NEG
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 1
81589: NEG
81590: PUSH
81591: LD_INT 5
81593: NEG
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 2
81601: PUSH
81602: LD_INT 3
81604: NEG
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 2
81612: NEG
81613: PUSH
81614: LD_INT 5
81616: NEG
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 3
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 3
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 4
81645: PUSH
81646: LD_INT 0
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 4
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 3
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 2
81675: PUSH
81676: LD_INT 0
81678: PUSH
81679: EMPTY
81680: LIST
81681: LIST
81682: PUSH
81683: LD_INT 2
81685: PUSH
81686: LD_INT 1
81688: NEG
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 2
81696: PUSH
81697: LD_INT 2
81699: NEG
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 4
81707: PUSH
81708: LD_INT 2
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 4
81717: PUSH
81718: LD_INT 4
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 4
81727: PUSH
81728: LD_INT 3
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 5
81737: PUSH
81738: LD_INT 4
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 5
81747: PUSH
81748: LD_INT 5
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 4
81757: PUSH
81758: LD_INT 5
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 3
81767: PUSH
81768: LD_INT 4
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 3
81777: PUSH
81778: LD_INT 3
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 5
81787: PUSH
81788: LD_INT 3
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 3
81797: PUSH
81798: LD_INT 5
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 0
81807: PUSH
81808: LD_INT 3
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 0
81817: PUSH
81818: LD_INT 2
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 1
81827: PUSH
81828: LD_INT 3
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 1
81837: PUSH
81838: LD_INT 4
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 0
81847: PUSH
81848: LD_INT 4
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 1
81857: NEG
81858: PUSH
81859: LD_INT 3
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 1
81868: NEG
81869: PUSH
81870: LD_INT 2
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 2
81879: PUSH
81880: LD_INT 4
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 2
81889: NEG
81890: PUSH
81891: LD_INT 2
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 4
81900: NEG
81901: PUSH
81902: LD_INT 0
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 4
81911: NEG
81912: PUSH
81913: LD_INT 1
81915: NEG
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 3
81923: NEG
81924: PUSH
81925: LD_INT 0
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 3
81934: NEG
81935: PUSH
81936: LD_INT 1
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 4
81945: NEG
81946: PUSH
81947: LD_INT 1
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 5
81956: NEG
81957: PUSH
81958: LD_INT 0
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 5
81967: NEG
81968: PUSH
81969: LD_INT 1
81971: NEG
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 5
81979: NEG
81980: PUSH
81981: LD_INT 2
81983: NEG
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 3
81991: NEG
81992: PUSH
81993: LD_INT 2
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: ST_TO_ADDR
// end ; end ;
82047: GO 82050
82049: POP
// case btype of b_depot , b_warehouse :
82050: LD_VAR 0 1
82054: PUSH
82055: LD_INT 0
82057: DOUBLE
82058: EQUAL
82059: IFTRUE 82069
82061: LD_INT 1
82063: DOUBLE
82064: EQUAL
82065: IFTRUE 82069
82067: GO 82270
82069: POP
// case nation of nation_american :
82070: LD_VAR 0 5
82074: PUSH
82075: LD_INT 1
82077: DOUBLE
82078: EQUAL
82079: IFTRUE 82083
82081: GO 82139
82083: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
82084: LD_ADDR_VAR 0 9
82088: PUSH
82089: LD_VAR 0 11
82093: PUSH
82094: LD_VAR 0 12
82098: PUSH
82099: LD_VAR 0 13
82103: PUSH
82104: LD_VAR 0 14
82108: PUSH
82109: LD_VAR 0 15
82113: PUSH
82114: LD_VAR 0 16
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: PUSH
82127: LD_VAR 0 4
82131: PUSH
82132: LD_INT 1
82134: PLUS
82135: ARRAY
82136: ST_TO_ADDR
82137: GO 82268
82139: LD_INT 2
82141: DOUBLE
82142: EQUAL
82143: IFTRUE 82147
82145: GO 82203
82147: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
82148: LD_ADDR_VAR 0 9
82152: PUSH
82153: LD_VAR 0 17
82157: PUSH
82158: LD_VAR 0 18
82162: PUSH
82163: LD_VAR 0 19
82167: PUSH
82168: LD_VAR 0 20
82172: PUSH
82173: LD_VAR 0 21
82177: PUSH
82178: LD_VAR 0 22
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: PUSH
82191: LD_VAR 0 4
82195: PUSH
82196: LD_INT 1
82198: PLUS
82199: ARRAY
82200: ST_TO_ADDR
82201: GO 82268
82203: LD_INT 3
82205: DOUBLE
82206: EQUAL
82207: IFTRUE 82211
82209: GO 82267
82211: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
82212: LD_ADDR_VAR 0 9
82216: PUSH
82217: LD_VAR 0 23
82221: PUSH
82222: LD_VAR 0 24
82226: PUSH
82227: LD_VAR 0 25
82231: PUSH
82232: LD_VAR 0 26
82236: PUSH
82237: LD_VAR 0 27
82241: PUSH
82242: LD_VAR 0 28
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: PUSH
82255: LD_VAR 0 4
82259: PUSH
82260: LD_INT 1
82262: PLUS
82263: ARRAY
82264: ST_TO_ADDR
82265: GO 82268
82267: POP
82268: GO 82823
82270: LD_INT 2
82272: DOUBLE
82273: EQUAL
82274: IFTRUE 82284
82276: LD_INT 3
82278: DOUBLE
82279: EQUAL
82280: IFTRUE 82284
82282: GO 82340
82284: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
82285: LD_ADDR_VAR 0 9
82289: PUSH
82290: LD_VAR 0 29
82294: PUSH
82295: LD_VAR 0 30
82299: PUSH
82300: LD_VAR 0 31
82304: PUSH
82305: LD_VAR 0 32
82309: PUSH
82310: LD_VAR 0 33
82314: PUSH
82315: LD_VAR 0 34
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: LIST
82327: PUSH
82328: LD_VAR 0 4
82332: PUSH
82333: LD_INT 1
82335: PLUS
82336: ARRAY
82337: ST_TO_ADDR
82338: GO 82823
82340: LD_INT 16
82342: DOUBLE
82343: EQUAL
82344: IFTRUE 82402
82346: LD_INT 17
82348: DOUBLE
82349: EQUAL
82350: IFTRUE 82402
82352: LD_INT 18
82354: DOUBLE
82355: EQUAL
82356: IFTRUE 82402
82358: LD_INT 19
82360: DOUBLE
82361: EQUAL
82362: IFTRUE 82402
82364: LD_INT 22
82366: DOUBLE
82367: EQUAL
82368: IFTRUE 82402
82370: LD_INT 20
82372: DOUBLE
82373: EQUAL
82374: IFTRUE 82402
82376: LD_INT 21
82378: DOUBLE
82379: EQUAL
82380: IFTRUE 82402
82382: LD_INT 23
82384: DOUBLE
82385: EQUAL
82386: IFTRUE 82402
82388: LD_INT 24
82390: DOUBLE
82391: EQUAL
82392: IFTRUE 82402
82394: LD_INT 25
82396: DOUBLE
82397: EQUAL
82398: IFTRUE 82402
82400: GO 82458
82402: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82403: LD_ADDR_VAR 0 9
82407: PUSH
82408: LD_VAR 0 35
82412: PUSH
82413: LD_VAR 0 36
82417: PUSH
82418: LD_VAR 0 37
82422: PUSH
82423: LD_VAR 0 38
82427: PUSH
82428: LD_VAR 0 39
82432: PUSH
82433: LD_VAR 0 40
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: LIST
82442: LIST
82443: LIST
82444: LIST
82445: PUSH
82446: LD_VAR 0 4
82450: PUSH
82451: LD_INT 1
82453: PLUS
82454: ARRAY
82455: ST_TO_ADDR
82456: GO 82823
82458: LD_INT 6
82460: DOUBLE
82461: EQUAL
82462: IFTRUE 82514
82464: LD_INT 7
82466: DOUBLE
82467: EQUAL
82468: IFTRUE 82514
82470: LD_INT 8
82472: DOUBLE
82473: EQUAL
82474: IFTRUE 82514
82476: LD_INT 13
82478: DOUBLE
82479: EQUAL
82480: IFTRUE 82514
82482: LD_INT 12
82484: DOUBLE
82485: EQUAL
82486: IFTRUE 82514
82488: LD_INT 15
82490: DOUBLE
82491: EQUAL
82492: IFTRUE 82514
82494: LD_INT 11
82496: DOUBLE
82497: EQUAL
82498: IFTRUE 82514
82500: LD_INT 14
82502: DOUBLE
82503: EQUAL
82504: IFTRUE 82514
82506: LD_INT 10
82508: DOUBLE
82509: EQUAL
82510: IFTRUE 82514
82512: GO 82570
82514: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
82515: LD_ADDR_VAR 0 9
82519: PUSH
82520: LD_VAR 0 41
82524: PUSH
82525: LD_VAR 0 42
82529: PUSH
82530: LD_VAR 0 43
82534: PUSH
82535: LD_VAR 0 44
82539: PUSH
82540: LD_VAR 0 45
82544: PUSH
82545: LD_VAR 0 46
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: PUSH
82558: LD_VAR 0 4
82562: PUSH
82563: LD_INT 1
82565: PLUS
82566: ARRAY
82567: ST_TO_ADDR
82568: GO 82823
82570: LD_INT 36
82572: DOUBLE
82573: EQUAL
82574: IFTRUE 82578
82576: GO 82634
82578: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82579: LD_ADDR_VAR 0 9
82583: PUSH
82584: LD_VAR 0 47
82588: PUSH
82589: LD_VAR 0 48
82593: PUSH
82594: LD_VAR 0 49
82598: PUSH
82599: LD_VAR 0 50
82603: PUSH
82604: LD_VAR 0 51
82608: PUSH
82609: LD_VAR 0 52
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: PUSH
82622: LD_VAR 0 4
82626: PUSH
82627: LD_INT 1
82629: PLUS
82630: ARRAY
82631: ST_TO_ADDR
82632: GO 82823
82634: LD_INT 4
82636: DOUBLE
82637: EQUAL
82638: IFTRUE 82660
82640: LD_INT 5
82642: DOUBLE
82643: EQUAL
82644: IFTRUE 82660
82646: LD_INT 34
82648: DOUBLE
82649: EQUAL
82650: IFTRUE 82660
82652: LD_INT 37
82654: DOUBLE
82655: EQUAL
82656: IFTRUE 82660
82658: GO 82716
82660: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82661: LD_ADDR_VAR 0 9
82665: PUSH
82666: LD_VAR 0 53
82670: PUSH
82671: LD_VAR 0 54
82675: PUSH
82676: LD_VAR 0 55
82680: PUSH
82681: LD_VAR 0 56
82685: PUSH
82686: LD_VAR 0 57
82690: PUSH
82691: LD_VAR 0 58
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: PUSH
82704: LD_VAR 0 4
82708: PUSH
82709: LD_INT 1
82711: PLUS
82712: ARRAY
82713: ST_TO_ADDR
82714: GO 82823
82716: LD_INT 31
82718: DOUBLE
82719: EQUAL
82720: IFTRUE 82766
82722: LD_INT 32
82724: DOUBLE
82725: EQUAL
82726: IFTRUE 82766
82728: LD_INT 33
82730: DOUBLE
82731: EQUAL
82732: IFTRUE 82766
82734: LD_INT 27
82736: DOUBLE
82737: EQUAL
82738: IFTRUE 82766
82740: LD_INT 26
82742: DOUBLE
82743: EQUAL
82744: IFTRUE 82766
82746: LD_INT 28
82748: DOUBLE
82749: EQUAL
82750: IFTRUE 82766
82752: LD_INT 29
82754: DOUBLE
82755: EQUAL
82756: IFTRUE 82766
82758: LD_INT 30
82760: DOUBLE
82761: EQUAL
82762: IFTRUE 82766
82764: GO 82822
82766: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
82767: LD_ADDR_VAR 0 9
82771: PUSH
82772: LD_VAR 0 59
82776: PUSH
82777: LD_VAR 0 60
82781: PUSH
82782: LD_VAR 0 61
82786: PUSH
82787: LD_VAR 0 62
82791: PUSH
82792: LD_VAR 0 63
82796: PUSH
82797: LD_VAR 0 64
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: PUSH
82810: LD_VAR 0 4
82814: PUSH
82815: LD_INT 1
82817: PLUS
82818: ARRAY
82819: ST_TO_ADDR
82820: GO 82823
82822: POP
// temp_list2 = [ ] ;
82823: LD_ADDR_VAR 0 10
82827: PUSH
82828: EMPTY
82829: ST_TO_ADDR
// for i in temp_list do
82830: LD_ADDR_VAR 0 8
82834: PUSH
82835: LD_VAR 0 9
82839: PUSH
82840: FOR_IN
82841: IFFALSE 82893
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82843: LD_ADDR_VAR 0 10
82847: PUSH
82848: LD_VAR 0 10
82852: PUSH
82853: LD_VAR 0 8
82857: PUSH
82858: LD_INT 1
82860: ARRAY
82861: PUSH
82862: LD_VAR 0 2
82866: PLUS
82867: PUSH
82868: LD_VAR 0 8
82872: PUSH
82873: LD_INT 2
82875: ARRAY
82876: PUSH
82877: LD_VAR 0 3
82881: PLUS
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: EMPTY
82888: LIST
82889: ADD
82890: ST_TO_ADDR
82891: GO 82840
82893: POP
82894: POP
// result = temp_list2 ;
82895: LD_ADDR_VAR 0 7
82899: PUSH
82900: LD_VAR 0 10
82904: ST_TO_ADDR
// end ;
82905: LD_VAR 0 7
82909: RET
// export function EnemyInRange ( unit , dist ) ; begin
82910: LD_INT 0
82912: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82913: LD_ADDR_VAR 0 3
82917: PUSH
82918: LD_VAR 0 1
82922: PPUSH
82923: CALL_OW 255
82927: PPUSH
82928: LD_VAR 0 1
82932: PPUSH
82933: CALL_OW 250
82937: PPUSH
82938: LD_VAR 0 1
82942: PPUSH
82943: CALL_OW 251
82947: PPUSH
82948: LD_VAR 0 2
82952: PPUSH
82953: CALL 56167 0 4
82957: PUSH
82958: LD_INT 4
82960: ARRAY
82961: ST_TO_ADDR
// end ;
82962: LD_VAR 0 3
82966: RET
// export function PlayerSeeMe ( unit ) ; begin
82967: LD_INT 0
82969: PPUSH
// result := See ( your_side , unit ) ;
82970: LD_ADDR_VAR 0 2
82974: PUSH
82975: LD_OWVAR 2
82979: PPUSH
82980: LD_VAR 0 1
82984: PPUSH
82985: CALL_OW 292
82989: ST_TO_ADDR
// end ;
82990: LD_VAR 0 2
82994: RET
// export function ReverseDir ( unit ) ; begin
82995: LD_INT 0
82997: PPUSH
// if not unit then
82998: LD_VAR 0 1
83002: NOT
83003: IFFALSE 83007
// exit ;
83005: GO 83030
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
83007: LD_ADDR_VAR 0 2
83011: PUSH
83012: LD_VAR 0 1
83016: PPUSH
83017: CALL_OW 254
83021: PUSH
83022: LD_INT 3
83024: PLUS
83025: PUSH
83026: LD_INT 6
83028: MOD
83029: ST_TO_ADDR
// end ;
83030: LD_VAR 0 2
83034: RET
// export function ReverseArray ( array ) ; var i ; begin
83035: LD_INT 0
83037: PPUSH
83038: PPUSH
// if not array then
83039: LD_VAR 0 1
83043: NOT
83044: IFFALSE 83048
// exit ;
83046: GO 83103
// result := [ ] ;
83048: LD_ADDR_VAR 0 2
83052: PUSH
83053: EMPTY
83054: ST_TO_ADDR
// for i := array downto 1 do
83055: LD_ADDR_VAR 0 3
83059: PUSH
83060: DOUBLE
83061: LD_VAR 0 1
83065: INC
83066: ST_TO_ADDR
83067: LD_INT 1
83069: PUSH
83070: FOR_DOWNTO
83071: IFFALSE 83101
// result := Join ( result , array [ i ] ) ;
83073: LD_ADDR_VAR 0 2
83077: PUSH
83078: LD_VAR 0 2
83082: PPUSH
83083: LD_VAR 0 1
83087: PUSH
83088: LD_VAR 0 3
83092: ARRAY
83093: PPUSH
83094: CALL 87955 0 2
83098: ST_TO_ADDR
83099: GO 83070
83101: POP
83102: POP
// end ;
83103: LD_VAR 0 2
83107: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
83108: LD_INT 0
83110: PPUSH
83111: PPUSH
83112: PPUSH
83113: PPUSH
83114: PPUSH
83115: PPUSH
// if not unit or not hexes then
83116: LD_VAR 0 1
83120: NOT
83121: IFTRUE 83130
83123: PUSH
83124: LD_VAR 0 2
83128: NOT
83129: OR
83130: IFFALSE 83134
// exit ;
83132: GO 83257
// dist := 9999 ;
83134: LD_ADDR_VAR 0 5
83138: PUSH
83139: LD_INT 9999
83141: ST_TO_ADDR
// for i = 1 to hexes do
83142: LD_ADDR_VAR 0 4
83146: PUSH
83147: DOUBLE
83148: LD_INT 1
83150: DEC
83151: ST_TO_ADDR
83152: LD_VAR 0 2
83156: PUSH
83157: FOR_TO
83158: IFFALSE 83245
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83160: LD_ADDR_VAR 0 6
83164: PUSH
83165: LD_VAR 0 1
83169: PPUSH
83170: LD_VAR 0 2
83174: PUSH
83175: LD_VAR 0 4
83179: ARRAY
83180: PUSH
83181: LD_INT 1
83183: ARRAY
83184: PPUSH
83185: LD_VAR 0 2
83189: PUSH
83190: LD_VAR 0 4
83194: ARRAY
83195: PUSH
83196: LD_INT 2
83198: ARRAY
83199: PPUSH
83200: CALL_OW 297
83204: ST_TO_ADDR
// if tdist < dist then
83205: LD_VAR 0 6
83209: PUSH
83210: LD_VAR 0 5
83214: LESS
83215: IFFALSE 83243
// begin hex := hexes [ i ] ;
83217: LD_ADDR_VAR 0 8
83221: PUSH
83222: LD_VAR 0 2
83226: PUSH
83227: LD_VAR 0 4
83231: ARRAY
83232: ST_TO_ADDR
// dist := tdist ;
83233: LD_ADDR_VAR 0 5
83237: PUSH
83238: LD_VAR 0 6
83242: ST_TO_ADDR
// end ; end ;
83243: GO 83157
83245: POP
83246: POP
// result := hex ;
83247: LD_ADDR_VAR 0 3
83251: PUSH
83252: LD_VAR 0 8
83256: ST_TO_ADDR
// end ;
83257: LD_VAR 0 3
83261: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83262: LD_INT 0
83264: PPUSH
83265: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83266: LD_VAR 0 1
83270: NOT
83271: IFTRUE 83310
83273: PUSH
83274: LD_VAR 0 1
83278: PUSH
83279: LD_INT 21
83281: PUSH
83282: LD_INT 2
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 23
83291: PUSH
83292: LD_INT 2
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PPUSH
83303: CALL_OW 69
83307: IN
83308: NOT
83309: OR
83310: IFFALSE 83314
// exit ;
83312: GO 83361
// for i = 1 to 3 do
83314: LD_ADDR_VAR 0 3
83318: PUSH
83319: DOUBLE
83320: LD_INT 1
83322: DEC
83323: ST_TO_ADDR
83324: LD_INT 3
83326: PUSH
83327: FOR_TO
83328: IFFALSE 83359
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
83330: LD_VAR 0 1
83334: PPUSH
83335: CALL_OW 250
83339: PPUSH
83340: LD_VAR 0 1
83344: PPUSH
83345: CALL_OW 251
83349: PPUSH
83350: LD_INT 1
83352: PPUSH
83353: CALL_OW 453
83357: GO 83327
83359: POP
83360: POP
// end ;
83361: LD_VAR 0 2
83365: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
83366: LD_INT 0
83368: PPUSH
83369: PPUSH
83370: PPUSH
83371: PPUSH
83372: PPUSH
83373: PPUSH
// if not unit or not enemy_unit then
83374: LD_VAR 0 1
83378: NOT
83379: IFTRUE 83388
83381: PUSH
83382: LD_VAR 0 2
83386: NOT
83387: OR
83388: IFFALSE 83392
// exit ;
83390: GO 83873
// if GetLives ( i ) < 250 then
83392: LD_VAR 0 4
83396: PPUSH
83397: CALL_OW 256
83401: PUSH
83402: LD_INT 250
83404: LESS
83405: IFFALSE 83418
// begin ComAutodestruct ( i ) ;
83407: LD_VAR 0 4
83411: PPUSH
83412: CALL 83262 0 1
// exit ;
83416: GO 83873
// end ; x := GetX ( enemy_unit ) ;
83418: LD_ADDR_VAR 0 7
83422: PUSH
83423: LD_VAR 0 2
83427: PPUSH
83428: CALL_OW 250
83432: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83433: LD_ADDR_VAR 0 8
83437: PUSH
83438: LD_VAR 0 2
83442: PPUSH
83443: CALL_OW 251
83447: ST_TO_ADDR
// if not x or not y then
83448: LD_VAR 0 7
83452: NOT
83453: IFTRUE 83462
83455: PUSH
83456: LD_VAR 0 8
83460: NOT
83461: OR
83462: IFFALSE 83466
// exit ;
83464: GO 83873
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83466: LD_ADDR_VAR 0 6
83470: PUSH
83471: LD_VAR 0 7
83475: PPUSH
83476: LD_INT 0
83478: PPUSH
83479: LD_INT 4
83481: PPUSH
83482: CALL_OW 272
83486: PUSH
83487: LD_VAR 0 8
83491: PPUSH
83492: LD_INT 0
83494: PPUSH
83495: LD_INT 4
83497: PPUSH
83498: CALL_OW 273
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_VAR 0 7
83511: PPUSH
83512: LD_INT 1
83514: PPUSH
83515: LD_INT 4
83517: PPUSH
83518: CALL_OW 272
83522: PUSH
83523: LD_VAR 0 8
83527: PPUSH
83528: LD_INT 1
83530: PPUSH
83531: LD_INT 4
83533: PPUSH
83534: CALL_OW 273
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_VAR 0 7
83547: PPUSH
83548: LD_INT 2
83550: PPUSH
83551: LD_INT 4
83553: PPUSH
83554: CALL_OW 272
83558: PUSH
83559: LD_VAR 0 8
83563: PPUSH
83564: LD_INT 2
83566: PPUSH
83567: LD_INT 4
83569: PPUSH
83570: CALL_OW 273
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_VAR 0 7
83583: PPUSH
83584: LD_INT 3
83586: PPUSH
83587: LD_INT 4
83589: PPUSH
83590: CALL_OW 272
83594: PUSH
83595: LD_VAR 0 8
83599: PPUSH
83600: LD_INT 3
83602: PPUSH
83603: LD_INT 4
83605: PPUSH
83606: CALL_OW 273
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_VAR 0 7
83619: PPUSH
83620: LD_INT 4
83622: PPUSH
83623: LD_INT 4
83625: PPUSH
83626: CALL_OW 272
83630: PUSH
83631: LD_VAR 0 8
83635: PPUSH
83636: LD_INT 4
83638: PPUSH
83639: LD_INT 4
83641: PPUSH
83642: CALL_OW 273
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_VAR 0 7
83655: PPUSH
83656: LD_INT 5
83658: PPUSH
83659: LD_INT 4
83661: PPUSH
83662: CALL_OW 272
83666: PUSH
83667: LD_VAR 0 8
83671: PPUSH
83672: LD_INT 5
83674: PPUSH
83675: LD_INT 4
83677: PPUSH
83678: CALL_OW 273
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: ST_TO_ADDR
// for i = tmp downto 1 do
83695: LD_ADDR_VAR 0 4
83699: PUSH
83700: DOUBLE
83701: LD_VAR 0 6
83705: INC
83706: ST_TO_ADDR
83707: LD_INT 1
83709: PUSH
83710: FOR_DOWNTO
83711: IFFALSE 83814
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83713: LD_VAR 0 6
83717: PUSH
83718: LD_VAR 0 4
83722: ARRAY
83723: PUSH
83724: LD_INT 1
83726: ARRAY
83727: PPUSH
83728: LD_VAR 0 6
83732: PUSH
83733: LD_VAR 0 4
83737: ARRAY
83738: PUSH
83739: LD_INT 2
83741: ARRAY
83742: PPUSH
83743: CALL_OW 488
83747: NOT
83748: IFTRUE 83790
83750: PUSH
83751: LD_VAR 0 6
83755: PUSH
83756: LD_VAR 0 4
83760: ARRAY
83761: PUSH
83762: LD_INT 1
83764: ARRAY
83765: PPUSH
83766: LD_VAR 0 6
83770: PUSH
83771: LD_VAR 0 4
83775: ARRAY
83776: PUSH
83777: LD_INT 2
83779: ARRAY
83780: PPUSH
83781: CALL_OW 428
83785: PUSH
83786: LD_INT 0
83788: NONEQUAL
83789: OR
83790: IFFALSE 83812
// tmp := Delete ( tmp , i ) ;
83792: LD_ADDR_VAR 0 6
83796: PUSH
83797: LD_VAR 0 6
83801: PPUSH
83802: LD_VAR 0 4
83806: PPUSH
83807: CALL_OW 3
83811: ST_TO_ADDR
83812: GO 83710
83814: POP
83815: POP
// j := GetClosestHex ( unit , tmp ) ;
83816: LD_ADDR_VAR 0 5
83820: PUSH
83821: LD_VAR 0 1
83825: PPUSH
83826: LD_VAR 0 6
83830: PPUSH
83831: CALL 83108 0 2
83835: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83836: LD_VAR 0 1
83840: PPUSH
83841: LD_VAR 0 5
83845: PUSH
83846: LD_INT 1
83848: ARRAY
83849: PPUSH
83850: LD_VAR 0 5
83854: PUSH
83855: LD_INT 2
83857: ARRAY
83858: PPUSH
83859: CALL_OW 111
// result := j ;
83863: LD_ADDR_VAR 0 3
83867: PUSH
83868: LD_VAR 0 5
83872: ST_TO_ADDR
// end ;
83873: LD_VAR 0 3
83877: RET
// export function PrepareApemanSoldier ( ) ; begin
83878: LD_INT 0
83880: PPUSH
// uc_nation := 0 ;
83881: LD_ADDR_OWVAR 21
83885: PUSH
83886: LD_INT 0
83888: ST_TO_ADDR
// hc_sex := sex_male ;
83889: LD_ADDR_OWVAR 27
83893: PUSH
83894: LD_INT 1
83896: ST_TO_ADDR
// hc_name :=  ;
83897: LD_ADDR_OWVAR 26
83901: PUSH
83902: LD_STRING 
83904: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
83905: LD_ADDR_OWVAR 28
83909: PUSH
83910: LD_INT 15
83912: ST_TO_ADDR
// hc_gallery :=  ;
83913: LD_ADDR_OWVAR 33
83917: PUSH
83918: LD_STRING 
83920: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83921: LD_ADDR_OWVAR 31
83925: PUSH
83926: LD_INT 0
83928: PPUSH
83929: LD_INT 3
83931: PPUSH
83932: CALL_OW 12
83936: PUSH
83937: LD_INT 0
83939: PPUSH
83940: LD_INT 3
83942: PPUSH
83943: CALL_OW 12
83947: PUSH
83948: LD_INT 0
83950: PUSH
83951: LD_INT 0
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
83960: LD_ADDR_OWVAR 29
83964: PUSH
83965: LD_INT 12
83967: PUSH
83968: LD_INT 12
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: ST_TO_ADDR
// end ;
83975: LD_VAR 0 1
83979: RET
// export function PrepareApemanEngineer ( ) ; begin
83980: LD_INT 0
83982: PPUSH
// uc_nation := 0 ;
83983: LD_ADDR_OWVAR 21
83987: PUSH
83988: LD_INT 0
83990: ST_TO_ADDR
// hc_sex := sex_male ;
83991: LD_ADDR_OWVAR 27
83995: PUSH
83996: LD_INT 1
83998: ST_TO_ADDR
// hc_name :=  ;
83999: LD_ADDR_OWVAR 26
84003: PUSH
84004: LD_STRING 
84006: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
84007: LD_ADDR_OWVAR 28
84011: PUSH
84012: LD_INT 16
84014: ST_TO_ADDR
// hc_gallery :=  ;
84015: LD_ADDR_OWVAR 33
84019: PUSH
84020: LD_STRING 
84022: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
84023: LD_ADDR_OWVAR 31
84027: PUSH
84028: LD_INT 0
84030: PPUSH
84031: LD_INT 3
84033: PPUSH
84034: CALL_OW 12
84038: PUSH
84039: LD_INT 0
84041: PPUSH
84042: LD_INT 3
84044: PPUSH
84045: CALL_OW 12
84049: PUSH
84050: LD_INT 0
84052: PUSH
84053: LD_INT 0
84055: PUSH
84056: EMPTY
84057: LIST
84058: LIST
84059: LIST
84060: LIST
84061: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
84062: LD_ADDR_OWVAR 29
84066: PUSH
84067: LD_INT 12
84069: PUSH
84070: LD_INT 12
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: ST_TO_ADDR
// end ;
84077: LD_VAR 0 1
84081: RET
// export function PrepareApeman ( agressivity ) ; begin
84082: LD_INT 0
84084: PPUSH
// uc_side := 0 ;
84085: LD_ADDR_OWVAR 20
84089: PUSH
84090: LD_INT 0
84092: ST_TO_ADDR
// uc_nation := 0 ;
84093: LD_ADDR_OWVAR 21
84097: PUSH
84098: LD_INT 0
84100: ST_TO_ADDR
// hc_sex := sex_male ;
84101: LD_ADDR_OWVAR 27
84105: PUSH
84106: LD_INT 1
84108: ST_TO_ADDR
// hc_class := class_apeman ;
84109: LD_ADDR_OWVAR 28
84113: PUSH
84114: LD_INT 12
84116: ST_TO_ADDR
// hc_gallery :=  ;
84117: LD_ADDR_OWVAR 33
84121: PUSH
84122: LD_STRING 
84124: ST_TO_ADDR
// hc_name :=  ;
84125: LD_ADDR_OWVAR 26
84129: PUSH
84130: LD_STRING 
84132: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
84133: LD_ADDR_OWVAR 29
84137: PUSH
84138: LD_INT 12
84140: PUSH
84141: LD_INT 12
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: ST_TO_ADDR
// if agressivity = 0 then
84148: LD_VAR 0 1
84152: PUSH
84153: LD_INT 0
84155: EQUAL
84156: IFFALSE 84168
// hc_agressivity := 0 else
84158: LD_ADDR_OWVAR 35
84162: PUSH
84163: LD_INT 0
84165: ST_TO_ADDR
84166: GO 84189
// hc_agressivity := rand ( - agressivity , agressivity ) ;
84168: LD_ADDR_OWVAR 35
84172: PUSH
84173: LD_VAR 0 1
84177: NEG
84178: PPUSH
84179: LD_VAR 0 1
84183: PPUSH
84184: CALL_OW 12
84188: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
84189: LD_ADDR_OWVAR 31
84193: PUSH
84194: LD_INT 0
84196: PPUSH
84197: LD_INT 3
84199: PPUSH
84200: CALL_OW 12
84204: PUSH
84205: LD_INT 0
84207: PPUSH
84208: LD_INT 3
84210: PPUSH
84211: CALL_OW 12
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: LD_INT 0
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: ST_TO_ADDR
// end ;
84228: LD_VAR 0 2
84232: RET
// export function PrepareTiger ( agressivity ) ; begin
84233: LD_INT 0
84235: PPUSH
// uc_side := 0 ;
84236: LD_ADDR_OWVAR 20
84240: PUSH
84241: LD_INT 0
84243: ST_TO_ADDR
// uc_nation := 0 ;
84244: LD_ADDR_OWVAR 21
84248: PUSH
84249: LD_INT 0
84251: ST_TO_ADDR
// InitHc ;
84252: CALL_OW 19
// hc_class := class_tiger ;
84256: LD_ADDR_OWVAR 28
84260: PUSH
84261: LD_INT 14
84263: ST_TO_ADDR
// hc_gallery :=  ;
84264: LD_ADDR_OWVAR 33
84268: PUSH
84269: LD_STRING 
84271: ST_TO_ADDR
// hc_name :=  ;
84272: LD_ADDR_OWVAR 26
84276: PUSH
84277: LD_STRING 
84279: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
84280: LD_ADDR_OWVAR 35
84284: PUSH
84285: LD_VAR 0 1
84289: NEG
84290: PPUSH
84291: LD_VAR 0 1
84295: PPUSH
84296: CALL_OW 12
84300: ST_TO_ADDR
// end ;
84301: LD_VAR 0 2
84305: RET
// export function PrepareEnchidna ( ) ; begin
84306: LD_INT 0
84308: PPUSH
// uc_side := 0 ;
84309: LD_ADDR_OWVAR 20
84313: PUSH
84314: LD_INT 0
84316: ST_TO_ADDR
// uc_nation := 0 ;
84317: LD_ADDR_OWVAR 21
84321: PUSH
84322: LD_INT 0
84324: ST_TO_ADDR
// InitHc ;
84325: CALL_OW 19
// hc_class := class_baggie ;
84329: LD_ADDR_OWVAR 28
84333: PUSH
84334: LD_INT 13
84336: ST_TO_ADDR
// hc_gallery :=  ;
84337: LD_ADDR_OWVAR 33
84341: PUSH
84342: LD_STRING 
84344: ST_TO_ADDR
// hc_name :=  ;
84345: LD_ADDR_OWVAR 26
84349: PUSH
84350: LD_STRING 
84352: ST_TO_ADDR
// end ;
84353: LD_VAR 0 1
84357: RET
// export function PrepareFrog ( ) ; begin
84358: LD_INT 0
84360: PPUSH
// uc_side := 0 ;
84361: LD_ADDR_OWVAR 20
84365: PUSH
84366: LD_INT 0
84368: ST_TO_ADDR
// uc_nation := 0 ;
84369: LD_ADDR_OWVAR 21
84373: PUSH
84374: LD_INT 0
84376: ST_TO_ADDR
// InitHc ;
84377: CALL_OW 19
// hc_class := class_frog ;
84381: LD_ADDR_OWVAR 28
84385: PUSH
84386: LD_INT 19
84388: ST_TO_ADDR
// hc_gallery :=  ;
84389: LD_ADDR_OWVAR 33
84393: PUSH
84394: LD_STRING 
84396: ST_TO_ADDR
// hc_name :=  ;
84397: LD_ADDR_OWVAR 26
84401: PUSH
84402: LD_STRING 
84404: ST_TO_ADDR
// end ;
84405: LD_VAR 0 1
84409: RET
// export function PrepareFish ( ) ; begin
84410: LD_INT 0
84412: PPUSH
// uc_side := 0 ;
84413: LD_ADDR_OWVAR 20
84417: PUSH
84418: LD_INT 0
84420: ST_TO_ADDR
// uc_nation := 0 ;
84421: LD_ADDR_OWVAR 21
84425: PUSH
84426: LD_INT 0
84428: ST_TO_ADDR
// InitHc ;
84429: CALL_OW 19
// hc_class := class_fish ;
84433: LD_ADDR_OWVAR 28
84437: PUSH
84438: LD_INT 20
84440: ST_TO_ADDR
// hc_gallery :=  ;
84441: LD_ADDR_OWVAR 33
84445: PUSH
84446: LD_STRING 
84448: ST_TO_ADDR
// hc_name :=  ;
84449: LD_ADDR_OWVAR 26
84453: PUSH
84454: LD_STRING 
84456: ST_TO_ADDR
// end ;
84457: LD_VAR 0 1
84461: RET
// export function PrepareBird ( ) ; begin
84462: LD_INT 0
84464: PPUSH
// uc_side := 0 ;
84465: LD_ADDR_OWVAR 20
84469: PUSH
84470: LD_INT 0
84472: ST_TO_ADDR
// uc_nation := 0 ;
84473: LD_ADDR_OWVAR 21
84477: PUSH
84478: LD_INT 0
84480: ST_TO_ADDR
// InitHc ;
84481: CALL_OW 19
// hc_class := class_phororhacos ;
84485: LD_ADDR_OWVAR 28
84489: PUSH
84490: LD_INT 18
84492: ST_TO_ADDR
// hc_gallery :=  ;
84493: LD_ADDR_OWVAR 33
84497: PUSH
84498: LD_STRING 
84500: ST_TO_ADDR
// hc_name :=  ;
84501: LD_ADDR_OWVAR 26
84505: PUSH
84506: LD_STRING 
84508: ST_TO_ADDR
// end ;
84509: LD_VAR 0 1
84513: RET
// export function PrepareHorse ( ) ; begin
84514: LD_INT 0
84516: PPUSH
// uc_side := 0 ;
84517: LD_ADDR_OWVAR 20
84521: PUSH
84522: LD_INT 0
84524: ST_TO_ADDR
// uc_nation := 0 ;
84525: LD_ADDR_OWVAR 21
84529: PUSH
84530: LD_INT 0
84532: ST_TO_ADDR
// InitHc ;
84533: CALL_OW 19
// hc_class := class_horse ;
84537: LD_ADDR_OWVAR 28
84541: PUSH
84542: LD_INT 21
84544: ST_TO_ADDR
// hc_gallery :=  ;
84545: LD_ADDR_OWVAR 33
84549: PUSH
84550: LD_STRING 
84552: ST_TO_ADDR
// hc_name :=  ;
84553: LD_ADDR_OWVAR 26
84557: PUSH
84558: LD_STRING 
84560: ST_TO_ADDR
// end ;
84561: LD_VAR 0 1
84565: RET
// export function PrepareMastodont ( ) ; begin
84566: LD_INT 0
84568: PPUSH
// uc_side := 0 ;
84569: LD_ADDR_OWVAR 20
84573: PUSH
84574: LD_INT 0
84576: ST_TO_ADDR
// uc_nation := 0 ;
84577: LD_ADDR_OWVAR 21
84581: PUSH
84582: LD_INT 0
84584: ST_TO_ADDR
// vc_chassis := class_mastodont ;
84585: LD_ADDR_OWVAR 37
84589: PUSH
84590: LD_INT 31
84592: ST_TO_ADDR
// vc_control := control_rider ;
84593: LD_ADDR_OWVAR 38
84597: PUSH
84598: LD_INT 4
84600: ST_TO_ADDR
// end ;
84601: LD_VAR 0 1
84605: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84606: LD_INT 0
84608: PPUSH
84609: PPUSH
84610: PPUSH
// uc_side = 0 ;
84611: LD_ADDR_OWVAR 20
84615: PUSH
84616: LD_INT 0
84618: ST_TO_ADDR
// uc_nation = 0 ;
84619: LD_ADDR_OWVAR 21
84623: PUSH
84624: LD_INT 0
84626: ST_TO_ADDR
// InitHc_All ( ) ;
84627: CALL_OW 584
// InitVc ;
84631: CALL_OW 20
// if mastodonts then
84635: LD_VAR 0 6
84639: IFFALSE 84706
// for i = 1 to mastodonts do
84641: LD_ADDR_VAR 0 11
84645: PUSH
84646: DOUBLE
84647: LD_INT 1
84649: DEC
84650: ST_TO_ADDR
84651: LD_VAR 0 6
84655: PUSH
84656: FOR_TO
84657: IFFALSE 84704
// begin vc_chassis := 31 ;
84659: LD_ADDR_OWVAR 37
84663: PUSH
84664: LD_INT 31
84666: ST_TO_ADDR
// vc_control := control_rider ;
84667: LD_ADDR_OWVAR 38
84671: PUSH
84672: LD_INT 4
84674: ST_TO_ADDR
// animal := CreateVehicle ;
84675: LD_ADDR_VAR 0 12
84679: PUSH
84680: CALL_OW 45
84684: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84685: LD_VAR 0 12
84689: PPUSH
84690: LD_VAR 0 8
84694: PPUSH
84695: LD_INT 0
84697: PPUSH
84698: CALL 86848 0 3
// end ;
84702: GO 84656
84704: POP
84705: POP
// if horses then
84706: LD_VAR 0 5
84710: IFFALSE 84777
// for i = 1 to horses do
84712: LD_ADDR_VAR 0 11
84716: PUSH
84717: DOUBLE
84718: LD_INT 1
84720: DEC
84721: ST_TO_ADDR
84722: LD_VAR 0 5
84726: PUSH
84727: FOR_TO
84728: IFFALSE 84775
// begin hc_class := 21 ;
84730: LD_ADDR_OWVAR 28
84734: PUSH
84735: LD_INT 21
84737: ST_TO_ADDR
// hc_gallery :=  ;
84738: LD_ADDR_OWVAR 33
84742: PUSH
84743: LD_STRING 
84745: ST_TO_ADDR
// animal := CreateHuman ;
84746: LD_ADDR_VAR 0 12
84750: PUSH
84751: CALL_OW 44
84755: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84756: LD_VAR 0 12
84760: PPUSH
84761: LD_VAR 0 8
84765: PPUSH
84766: LD_INT 0
84768: PPUSH
84769: CALL 86848 0 3
// end ;
84773: GO 84727
84775: POP
84776: POP
// if birds then
84777: LD_VAR 0 1
84781: IFFALSE 84848
// for i = 1 to birds do
84783: LD_ADDR_VAR 0 11
84787: PUSH
84788: DOUBLE
84789: LD_INT 1
84791: DEC
84792: ST_TO_ADDR
84793: LD_VAR 0 1
84797: PUSH
84798: FOR_TO
84799: IFFALSE 84846
// begin hc_class := 18 ;
84801: LD_ADDR_OWVAR 28
84805: PUSH
84806: LD_INT 18
84808: ST_TO_ADDR
// hc_gallery =  ;
84809: LD_ADDR_OWVAR 33
84813: PUSH
84814: LD_STRING 
84816: ST_TO_ADDR
// animal := CreateHuman ;
84817: LD_ADDR_VAR 0 12
84821: PUSH
84822: CALL_OW 44
84826: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84827: LD_VAR 0 12
84831: PPUSH
84832: LD_VAR 0 8
84836: PPUSH
84837: LD_INT 0
84839: PPUSH
84840: CALL 86848 0 3
// end ;
84844: GO 84798
84846: POP
84847: POP
// if tigers then
84848: LD_VAR 0 2
84852: IFFALSE 84936
// for i = 1 to tigers do
84854: LD_ADDR_VAR 0 11
84858: PUSH
84859: DOUBLE
84860: LD_INT 1
84862: DEC
84863: ST_TO_ADDR
84864: LD_VAR 0 2
84868: PUSH
84869: FOR_TO
84870: IFFALSE 84934
// begin hc_class = class_tiger ;
84872: LD_ADDR_OWVAR 28
84876: PUSH
84877: LD_INT 14
84879: ST_TO_ADDR
// hc_gallery =  ;
84880: LD_ADDR_OWVAR 33
84884: PUSH
84885: LD_STRING 
84887: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84888: LD_ADDR_OWVAR 35
84892: PUSH
84893: LD_INT 7
84895: NEG
84896: PPUSH
84897: LD_INT 7
84899: PPUSH
84900: CALL_OW 12
84904: ST_TO_ADDR
// animal := CreateHuman ;
84905: LD_ADDR_VAR 0 12
84909: PUSH
84910: CALL_OW 44
84914: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84915: LD_VAR 0 12
84919: PPUSH
84920: LD_VAR 0 8
84924: PPUSH
84925: LD_INT 0
84927: PPUSH
84928: CALL 86848 0 3
// end ;
84932: GO 84869
84934: POP
84935: POP
// if apemans then
84936: LD_VAR 0 3
84940: IFFALSE 85063
// for i = 1 to apemans do
84942: LD_ADDR_VAR 0 11
84946: PUSH
84947: DOUBLE
84948: LD_INT 1
84950: DEC
84951: ST_TO_ADDR
84952: LD_VAR 0 3
84956: PUSH
84957: FOR_TO
84958: IFFALSE 85061
// begin hc_class = class_apeman ;
84960: LD_ADDR_OWVAR 28
84964: PUSH
84965: LD_INT 12
84967: ST_TO_ADDR
// hc_gallery =  ;
84968: LD_ADDR_OWVAR 33
84972: PUSH
84973: LD_STRING 
84975: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
84976: LD_ADDR_OWVAR 35
84980: PUSH
84981: LD_INT 2
84983: NEG
84984: PPUSH
84985: LD_INT 2
84987: PPUSH
84988: CALL_OW 12
84992: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84993: LD_ADDR_OWVAR 31
84997: PUSH
84998: LD_INT 1
85000: PPUSH
85001: LD_INT 3
85003: PPUSH
85004: CALL_OW 12
85008: PUSH
85009: LD_INT 1
85011: PPUSH
85012: LD_INT 3
85014: PPUSH
85015: CALL_OW 12
85019: PUSH
85020: LD_INT 0
85022: PUSH
85023: LD_INT 0
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: ST_TO_ADDR
// animal := CreateHuman ;
85032: LD_ADDR_VAR 0 12
85036: PUSH
85037: CALL_OW 44
85041: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85042: LD_VAR 0 12
85046: PPUSH
85047: LD_VAR 0 8
85051: PPUSH
85052: LD_INT 0
85054: PPUSH
85055: CALL 86848 0 3
// end ;
85059: GO 84957
85061: POP
85062: POP
// if enchidnas then
85063: LD_VAR 0 4
85067: IFFALSE 85134
// for i = 1 to enchidnas do
85069: LD_ADDR_VAR 0 11
85073: PUSH
85074: DOUBLE
85075: LD_INT 1
85077: DEC
85078: ST_TO_ADDR
85079: LD_VAR 0 4
85083: PUSH
85084: FOR_TO
85085: IFFALSE 85132
// begin hc_class = 13 ;
85087: LD_ADDR_OWVAR 28
85091: PUSH
85092: LD_INT 13
85094: ST_TO_ADDR
// hc_gallery =  ;
85095: LD_ADDR_OWVAR 33
85099: PUSH
85100: LD_STRING 
85102: ST_TO_ADDR
// animal := CreateHuman ;
85103: LD_ADDR_VAR 0 12
85107: PUSH
85108: CALL_OW 44
85112: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85113: LD_VAR 0 12
85117: PPUSH
85118: LD_VAR 0 8
85122: PPUSH
85123: LD_INT 0
85125: PPUSH
85126: CALL 86848 0 3
// end ;
85130: GO 85084
85132: POP
85133: POP
// if fishes then
85134: LD_VAR 0 7
85138: IFFALSE 85205
// for i = 1 to fishes do
85140: LD_ADDR_VAR 0 11
85144: PUSH
85145: DOUBLE
85146: LD_INT 1
85148: DEC
85149: ST_TO_ADDR
85150: LD_VAR 0 7
85154: PUSH
85155: FOR_TO
85156: IFFALSE 85203
// begin hc_class = 20 ;
85158: LD_ADDR_OWVAR 28
85162: PUSH
85163: LD_INT 20
85165: ST_TO_ADDR
// hc_gallery =  ;
85166: LD_ADDR_OWVAR 33
85170: PUSH
85171: LD_STRING 
85173: ST_TO_ADDR
// animal := CreateHuman ;
85174: LD_ADDR_VAR 0 12
85178: PUSH
85179: CALL_OW 44
85183: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85184: LD_VAR 0 12
85188: PPUSH
85189: LD_VAR 0 9
85193: PPUSH
85194: LD_INT 0
85196: PPUSH
85197: CALL 86848 0 3
// end ;
85201: GO 85155
85203: POP
85204: POP
// end ;
85205: LD_VAR 0 10
85209: RET
// export function WantHeal ( sci , unit ) ; begin
85210: LD_INT 0
85212: PPUSH
// if GetTaskList ( sci ) > 0 then
85213: LD_VAR 0 1
85217: PPUSH
85218: CALL_OW 437
85222: PUSH
85223: LD_INT 0
85225: GREATER
85226: IFFALSE 85298
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85228: LD_VAR 0 1
85232: PPUSH
85233: CALL_OW 437
85237: PUSH
85238: LD_INT 1
85240: ARRAY
85241: PUSH
85242: LD_INT 1
85244: ARRAY
85245: PUSH
85246: LD_STRING l
85248: EQUAL
85249: IFFALSE 85276
85251: PUSH
85252: LD_VAR 0 1
85256: PPUSH
85257: CALL_OW 437
85261: PUSH
85262: LD_INT 1
85264: ARRAY
85265: PUSH
85266: LD_INT 4
85268: ARRAY
85269: PUSH
85270: LD_VAR 0 2
85274: EQUAL
85275: AND
85276: IFFALSE 85288
// result := true else
85278: LD_ADDR_VAR 0 3
85282: PUSH
85283: LD_INT 1
85285: ST_TO_ADDR
85286: GO 85296
// result := false ;
85288: LD_ADDR_VAR 0 3
85292: PUSH
85293: LD_INT 0
85295: ST_TO_ADDR
// end else
85296: GO 85306
// result := false ;
85298: LD_ADDR_VAR 0 3
85302: PUSH
85303: LD_INT 0
85305: ST_TO_ADDR
// end ;
85306: LD_VAR 0 3
85310: RET
// export function HealTarget ( sci ) ; begin
85311: LD_INT 0
85313: PPUSH
// if not sci then
85314: LD_VAR 0 1
85318: NOT
85319: IFFALSE 85323
// exit ;
85321: GO 85388
// result := 0 ;
85323: LD_ADDR_VAR 0 2
85327: PUSH
85328: LD_INT 0
85330: ST_TO_ADDR
// if GetTaskList ( sci ) then
85331: LD_VAR 0 1
85335: PPUSH
85336: CALL_OW 437
85340: IFFALSE 85388
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85342: LD_VAR 0 1
85346: PPUSH
85347: CALL_OW 437
85351: PUSH
85352: LD_INT 1
85354: ARRAY
85355: PUSH
85356: LD_INT 1
85358: ARRAY
85359: PUSH
85360: LD_STRING l
85362: EQUAL
85363: IFFALSE 85388
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85365: LD_ADDR_VAR 0 2
85369: PUSH
85370: LD_VAR 0 1
85374: PPUSH
85375: CALL_OW 437
85379: PUSH
85380: LD_INT 1
85382: ARRAY
85383: PUSH
85384: LD_INT 4
85386: ARRAY
85387: ST_TO_ADDR
// end ;
85388: LD_VAR 0 2
85392: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
85393: LD_INT 0
85395: PPUSH
85396: PPUSH
85397: PPUSH
85398: PPUSH
// if not base_units then
85399: LD_VAR 0 1
85403: NOT
85404: IFFALSE 85408
// exit ;
85406: GO 85495
// result := false ;
85408: LD_ADDR_VAR 0 2
85412: PUSH
85413: LD_INT 0
85415: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
85416: LD_ADDR_VAR 0 5
85420: PUSH
85421: LD_VAR 0 1
85425: PPUSH
85426: LD_INT 21
85428: PUSH
85429: LD_INT 3
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PPUSH
85436: CALL_OW 72
85440: ST_TO_ADDR
// if not tmp then
85441: LD_VAR 0 5
85445: NOT
85446: IFFALSE 85450
// exit ;
85448: GO 85495
// for i in tmp do
85450: LD_ADDR_VAR 0 3
85454: PUSH
85455: LD_VAR 0 5
85459: PUSH
85460: FOR_IN
85461: IFFALSE 85493
// begin result := EnemyInRange ( i , 22 ) ;
85463: LD_ADDR_VAR 0 2
85467: PUSH
85468: LD_VAR 0 3
85472: PPUSH
85473: LD_INT 22
85475: PPUSH
85476: CALL 82910 0 2
85480: ST_TO_ADDR
// if result then
85481: LD_VAR 0 2
85485: IFFALSE 85491
// exit ;
85487: POP
85488: POP
85489: GO 85495
// end ;
85491: GO 85460
85493: POP
85494: POP
// end ;
85495: LD_VAR 0 2
85499: RET
// export function FilterByTag ( units , tag ) ; begin
85500: LD_INT 0
85502: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
85503: LD_ADDR_VAR 0 3
85507: PUSH
85508: LD_VAR 0 1
85512: PPUSH
85513: LD_INT 120
85515: PUSH
85516: LD_VAR 0 2
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PPUSH
85525: CALL_OW 72
85529: ST_TO_ADDR
// end ;
85530: LD_VAR 0 3
85534: RET
// export function IsDriver ( un ) ; begin
85535: LD_INT 0
85537: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
85538: LD_ADDR_VAR 0 2
85542: PUSH
85543: LD_VAR 0 1
85547: PUSH
85548: LD_INT 55
85550: PUSH
85551: EMPTY
85552: LIST
85553: PPUSH
85554: CALL_OW 69
85558: IN
85559: ST_TO_ADDR
// end ;
85560: LD_VAR 0 2
85564: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85565: LD_INT 0
85567: PPUSH
85568: PPUSH
// list := [ ] ;
85569: LD_ADDR_VAR 0 5
85573: PUSH
85574: EMPTY
85575: ST_TO_ADDR
// case d of 0 :
85576: LD_VAR 0 3
85580: PUSH
85581: LD_INT 0
85583: DOUBLE
85584: EQUAL
85585: IFTRUE 85589
85587: GO 85722
85589: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85590: LD_ADDR_VAR 0 5
85594: PUSH
85595: LD_VAR 0 1
85599: PUSH
85600: LD_INT 4
85602: MINUS
85603: PUSH
85604: LD_VAR 0 2
85608: PUSH
85609: LD_INT 4
85611: MINUS
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: LIST
85620: PUSH
85621: LD_VAR 0 1
85625: PUSH
85626: LD_INT 3
85628: MINUS
85629: PUSH
85630: LD_VAR 0 2
85634: PUSH
85635: LD_INT 1
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: LIST
85642: PUSH
85643: LD_VAR 0 1
85647: PUSH
85648: LD_INT 4
85650: PLUS
85651: PUSH
85652: LD_VAR 0 2
85656: PUSH
85657: LD_INT 4
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: LIST
85664: PUSH
85665: LD_VAR 0 1
85669: PUSH
85670: LD_INT 3
85672: PLUS
85673: PUSH
85674: LD_VAR 0 2
85678: PUSH
85679: LD_INT 3
85681: PLUS
85682: PUSH
85683: LD_INT 5
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: LIST
85690: PUSH
85691: LD_VAR 0 1
85695: PUSH
85696: LD_VAR 0 2
85700: PUSH
85701: LD_INT 4
85703: PLUS
85704: PUSH
85705: LD_INT 0
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: LIST
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: ST_TO_ADDR
// end ; 1 :
85720: GO 86420
85722: LD_INT 1
85724: DOUBLE
85725: EQUAL
85726: IFTRUE 85730
85728: GO 85863
85730: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85731: LD_ADDR_VAR 0 5
85735: PUSH
85736: LD_VAR 0 1
85740: PUSH
85741: LD_VAR 0 2
85745: PUSH
85746: LD_INT 4
85748: MINUS
85749: PUSH
85750: LD_INT 3
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: LIST
85757: PUSH
85758: LD_VAR 0 1
85762: PUSH
85763: LD_INT 3
85765: MINUS
85766: PUSH
85767: LD_VAR 0 2
85771: PUSH
85772: LD_INT 3
85774: MINUS
85775: PUSH
85776: LD_INT 2
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: LIST
85783: PUSH
85784: LD_VAR 0 1
85788: PUSH
85789: LD_INT 4
85791: MINUS
85792: PUSH
85793: LD_VAR 0 2
85797: PUSH
85798: LD_INT 1
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: LIST
85805: PUSH
85806: LD_VAR 0 1
85810: PUSH
85811: LD_VAR 0 2
85815: PUSH
85816: LD_INT 3
85818: PLUS
85819: PUSH
85820: LD_INT 0
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: LIST
85827: PUSH
85828: LD_VAR 0 1
85832: PUSH
85833: LD_INT 4
85835: PLUS
85836: PUSH
85837: LD_VAR 0 2
85841: PUSH
85842: LD_INT 4
85844: PLUS
85845: PUSH
85846: LD_INT 5
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: LIST
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: ST_TO_ADDR
// end ; 2 :
85861: GO 86420
85863: LD_INT 2
85865: DOUBLE
85866: EQUAL
85867: IFTRUE 85871
85869: GO 86000
85871: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
85872: LD_ADDR_VAR 0 5
85876: PUSH
85877: LD_VAR 0 1
85881: PUSH
85882: LD_VAR 0 2
85886: PUSH
85887: LD_INT 3
85889: MINUS
85890: PUSH
85891: LD_INT 3
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: LIST
85898: PUSH
85899: LD_VAR 0 1
85903: PUSH
85904: LD_INT 4
85906: PLUS
85907: PUSH
85908: LD_VAR 0 2
85912: PUSH
85913: LD_INT 4
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: LIST
85920: PUSH
85921: LD_VAR 0 1
85925: PUSH
85926: LD_VAR 0 2
85930: PUSH
85931: LD_INT 4
85933: PLUS
85934: PUSH
85935: LD_INT 0
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: LIST
85942: PUSH
85943: LD_VAR 0 1
85947: PUSH
85948: LD_INT 3
85950: MINUS
85951: PUSH
85952: LD_VAR 0 2
85956: PUSH
85957: LD_INT 1
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: LIST
85964: PUSH
85965: LD_VAR 0 1
85969: PUSH
85970: LD_INT 4
85972: MINUS
85973: PUSH
85974: LD_VAR 0 2
85978: PUSH
85979: LD_INT 4
85981: MINUS
85982: PUSH
85983: LD_INT 2
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: LIST
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: ST_TO_ADDR
// end ; 3 :
85998: GO 86420
86000: LD_INT 3
86002: DOUBLE
86003: EQUAL
86004: IFTRUE 86008
86006: GO 86141
86008: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86009: LD_ADDR_VAR 0 5
86013: PUSH
86014: LD_VAR 0 1
86018: PUSH
86019: LD_INT 3
86021: PLUS
86022: PUSH
86023: LD_VAR 0 2
86027: PUSH
86028: LD_INT 4
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: LIST
86035: PUSH
86036: LD_VAR 0 1
86040: PUSH
86041: LD_INT 4
86043: PLUS
86044: PUSH
86045: LD_VAR 0 2
86049: PUSH
86050: LD_INT 4
86052: PLUS
86053: PUSH
86054: LD_INT 5
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: LIST
86061: PUSH
86062: LD_VAR 0 1
86066: PUSH
86067: LD_INT 4
86069: MINUS
86070: PUSH
86071: LD_VAR 0 2
86075: PUSH
86076: LD_INT 1
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: LIST
86083: PUSH
86084: LD_VAR 0 1
86088: PUSH
86089: LD_VAR 0 2
86093: PUSH
86094: LD_INT 4
86096: MINUS
86097: PUSH
86098: LD_INT 3
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: LIST
86105: PUSH
86106: LD_VAR 0 1
86110: PUSH
86111: LD_INT 3
86113: MINUS
86114: PUSH
86115: LD_VAR 0 2
86119: PUSH
86120: LD_INT 3
86122: MINUS
86123: PUSH
86124: LD_INT 2
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: LIST
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: ST_TO_ADDR
// end ; 4 :
86139: GO 86420
86141: LD_INT 4
86143: DOUBLE
86144: EQUAL
86145: IFTRUE 86149
86147: GO 86282
86149: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86150: LD_ADDR_VAR 0 5
86154: PUSH
86155: LD_VAR 0 1
86159: PUSH
86160: LD_VAR 0 2
86164: PUSH
86165: LD_INT 4
86167: PLUS
86168: PUSH
86169: LD_INT 0
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: LIST
86176: PUSH
86177: LD_VAR 0 1
86181: PUSH
86182: LD_INT 3
86184: PLUS
86185: PUSH
86186: LD_VAR 0 2
86190: PUSH
86191: LD_INT 3
86193: PLUS
86194: PUSH
86195: LD_INT 5
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: LIST
86202: PUSH
86203: LD_VAR 0 1
86207: PUSH
86208: LD_INT 4
86210: PLUS
86211: PUSH
86212: LD_VAR 0 2
86216: PUSH
86217: LD_INT 4
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: LIST
86224: PUSH
86225: LD_VAR 0 1
86229: PUSH
86230: LD_VAR 0 2
86234: PUSH
86235: LD_INT 3
86237: MINUS
86238: PUSH
86239: LD_INT 3
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: LIST
86246: PUSH
86247: LD_VAR 0 1
86251: PUSH
86252: LD_INT 4
86254: MINUS
86255: PUSH
86256: LD_VAR 0 2
86260: PUSH
86261: LD_INT 4
86263: MINUS
86264: PUSH
86265: LD_INT 2
86267: PUSH
86268: EMPTY
86269: LIST
86270: LIST
86271: LIST
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: ST_TO_ADDR
// end ; 5 :
86280: GO 86420
86282: LD_INT 5
86284: DOUBLE
86285: EQUAL
86286: IFTRUE 86290
86288: GO 86419
86290: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
86291: LD_ADDR_VAR 0 5
86295: PUSH
86296: LD_VAR 0 1
86300: PUSH
86301: LD_INT 4
86303: MINUS
86304: PUSH
86305: LD_VAR 0 2
86309: PUSH
86310: LD_INT 1
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: LIST
86317: PUSH
86318: LD_VAR 0 1
86322: PUSH
86323: LD_VAR 0 2
86327: PUSH
86328: LD_INT 4
86330: MINUS
86331: PUSH
86332: LD_INT 3
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: LIST
86339: PUSH
86340: LD_VAR 0 1
86344: PUSH
86345: LD_INT 4
86347: PLUS
86348: PUSH
86349: LD_VAR 0 2
86353: PUSH
86354: LD_INT 4
86356: PLUS
86357: PUSH
86358: LD_INT 5
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: LIST
86365: PUSH
86366: LD_VAR 0 1
86370: PUSH
86371: LD_INT 3
86373: PLUS
86374: PUSH
86375: LD_VAR 0 2
86379: PUSH
86380: LD_INT 4
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: LIST
86387: PUSH
86388: LD_VAR 0 1
86392: PUSH
86393: LD_VAR 0 2
86397: PUSH
86398: LD_INT 3
86400: PLUS
86401: PUSH
86402: LD_INT 0
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: LIST
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: ST_TO_ADDR
// end ; end ;
86417: GO 86420
86419: POP
// result := list ;
86420: LD_ADDR_VAR 0 4
86424: PUSH
86425: LD_VAR 0 5
86429: ST_TO_ADDR
// end ;
86430: LD_VAR 0 4
86434: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
86435: LD_INT 0
86437: PPUSH
86438: PPUSH
86439: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
86440: LD_VAR 0 1
86444: NOT
86445: IFTRUE 86473
86447: PUSH
86448: LD_VAR 0 2
86452: PUSH
86453: LD_INT 1
86455: PUSH
86456: LD_INT 2
86458: PUSH
86459: LD_INT 3
86461: PUSH
86462: LD_INT 4
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: IN
86471: NOT
86472: OR
86473: IFFALSE 86477
// exit ;
86475: GO 86560
// tmp := [ ] ;
86477: LD_ADDR_VAR 0 5
86481: PUSH
86482: EMPTY
86483: ST_TO_ADDR
// for i in units do
86484: LD_ADDR_VAR 0 4
86488: PUSH
86489: LD_VAR 0 1
86493: PUSH
86494: FOR_IN
86495: IFFALSE 86529
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
86497: LD_ADDR_VAR 0 5
86501: PUSH
86502: LD_VAR 0 5
86506: PPUSH
86507: LD_VAR 0 4
86511: PPUSH
86512: LD_VAR 0 2
86516: PPUSH
86517: CALL_OW 259
86521: PPUSH
86522: CALL 87955 0 2
86526: ST_TO_ADDR
86527: GO 86494
86529: POP
86530: POP
// if not tmp then
86531: LD_VAR 0 5
86535: NOT
86536: IFFALSE 86540
// exit ;
86538: GO 86560
// result := SortListByListDesc ( units , tmp ) ;
86540: LD_ADDR_VAR 0 3
86544: PUSH
86545: LD_VAR 0 1
86549: PPUSH
86550: LD_VAR 0 5
86554: PPUSH
86555: CALL_OW 77
86559: ST_TO_ADDR
// end ;
86560: LD_VAR 0 3
86564: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86565: LD_INT 0
86567: PPUSH
86568: PPUSH
86569: PPUSH
// result := false ;
86570: LD_ADDR_VAR 0 3
86574: PUSH
86575: LD_INT 0
86577: ST_TO_ADDR
// if not building then
86578: LD_VAR 0 2
86582: NOT
86583: IFFALSE 86587
// exit ;
86585: GO 86731
// x := GetX ( building ) ;
86587: LD_ADDR_VAR 0 4
86591: PUSH
86592: LD_VAR 0 2
86596: PPUSH
86597: CALL_OW 250
86601: ST_TO_ADDR
// y := GetY ( building ) ;
86602: LD_ADDR_VAR 0 5
86606: PUSH
86607: LD_VAR 0 2
86611: PPUSH
86612: CALL_OW 251
86616: ST_TO_ADDR
// if not x or not y then
86617: LD_VAR 0 4
86621: NOT
86622: IFTRUE 86631
86624: PUSH
86625: LD_VAR 0 5
86629: NOT
86630: OR
86631: IFFALSE 86635
// exit ;
86633: GO 86731
// if GetTaskList ( unit ) then
86635: LD_VAR 0 1
86639: PPUSH
86640: CALL_OW 437
86644: IFFALSE 86731
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86646: LD_STRING e
86648: PUSH
86649: LD_VAR 0 1
86653: PPUSH
86654: CALL_OW 437
86658: PUSH
86659: LD_INT 1
86661: ARRAY
86662: PUSH
86663: LD_INT 1
86665: ARRAY
86666: EQUAL
86667: IFFALSE 86694
86669: PUSH
86670: LD_VAR 0 4
86674: PUSH
86675: LD_VAR 0 1
86679: PPUSH
86680: CALL_OW 437
86684: PUSH
86685: LD_INT 1
86687: ARRAY
86688: PUSH
86689: LD_INT 2
86691: ARRAY
86692: EQUAL
86693: AND
86694: IFFALSE 86721
86696: PUSH
86697: LD_VAR 0 5
86701: PUSH
86702: LD_VAR 0 1
86706: PPUSH
86707: CALL_OW 437
86711: PUSH
86712: LD_INT 1
86714: ARRAY
86715: PUSH
86716: LD_INT 3
86718: ARRAY
86719: EQUAL
86720: AND
86721: IFFALSE 86731
// result := true end ;
86723: LD_ADDR_VAR 0 3
86727: PUSH
86728: LD_INT 1
86730: ST_TO_ADDR
// end ;
86731: LD_VAR 0 3
86735: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
86736: LD_INT 0
86738: PPUSH
// result := false ;
86739: LD_ADDR_VAR 0 4
86743: PUSH
86744: LD_INT 0
86746: ST_TO_ADDR
// if GetTaskList ( unit ) then
86747: LD_VAR 0 1
86751: PPUSH
86752: CALL_OW 437
86756: IFFALSE 86843
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86758: LD_STRING M
86760: PUSH
86761: LD_VAR 0 1
86765: PPUSH
86766: CALL_OW 437
86770: PUSH
86771: LD_INT 1
86773: ARRAY
86774: PUSH
86775: LD_INT 1
86777: ARRAY
86778: EQUAL
86779: IFFALSE 86806
86781: PUSH
86782: LD_VAR 0 2
86786: PUSH
86787: LD_VAR 0 1
86791: PPUSH
86792: CALL_OW 437
86796: PUSH
86797: LD_INT 1
86799: ARRAY
86800: PUSH
86801: LD_INT 2
86803: ARRAY
86804: EQUAL
86805: AND
86806: IFFALSE 86833
86808: PUSH
86809: LD_VAR 0 3
86813: PUSH
86814: LD_VAR 0 1
86818: PPUSH
86819: CALL_OW 437
86823: PUSH
86824: LD_INT 1
86826: ARRAY
86827: PUSH
86828: LD_INT 3
86830: ARRAY
86831: EQUAL
86832: AND
86833: IFFALSE 86843
// result := true ;
86835: LD_ADDR_VAR 0 4
86839: PUSH
86840: LD_INT 1
86842: ST_TO_ADDR
// end ; end ;
86843: LD_VAR 0 4
86847: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86848: LD_INT 0
86850: PPUSH
86851: PPUSH
86852: PPUSH
86853: PPUSH
// if not unit or not area then
86854: LD_VAR 0 1
86858: NOT
86859: IFTRUE 86868
86861: PUSH
86862: LD_VAR 0 2
86866: NOT
86867: OR
86868: IFFALSE 86872
// exit ;
86870: GO 87048
// tmp := AreaToList ( area , i ) ;
86872: LD_ADDR_VAR 0 6
86876: PUSH
86877: LD_VAR 0 2
86881: PPUSH
86882: LD_VAR 0 5
86886: PPUSH
86887: CALL_OW 517
86891: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
86892: LD_ADDR_VAR 0 5
86896: PUSH
86897: DOUBLE
86898: LD_INT 1
86900: DEC
86901: ST_TO_ADDR
86902: LD_VAR 0 6
86906: PUSH
86907: LD_INT 1
86909: ARRAY
86910: PUSH
86911: FOR_TO
86912: IFFALSE 87046
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
86914: LD_ADDR_VAR 0 7
86918: PUSH
86919: LD_VAR 0 6
86923: PUSH
86924: LD_INT 1
86926: ARRAY
86927: PUSH
86928: LD_VAR 0 5
86932: ARRAY
86933: PUSH
86934: LD_VAR 0 6
86938: PUSH
86939: LD_INT 2
86941: ARRAY
86942: PUSH
86943: LD_VAR 0 5
86947: ARRAY
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
86953: LD_INT 92
86955: PUSH
86956: LD_VAR 0 7
86960: PUSH
86961: LD_INT 1
86963: ARRAY
86964: PUSH
86965: LD_VAR 0 7
86969: PUSH
86970: LD_INT 2
86972: ARRAY
86973: PUSH
86974: LD_INT 2
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: PPUSH
86983: CALL_OW 69
86987: PUSH
86988: LD_INT 0
86990: EQUAL
86991: IFFALSE 87044
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
86993: LD_VAR 0 1
86997: PPUSH
86998: LD_VAR 0 7
87002: PUSH
87003: LD_INT 1
87005: ARRAY
87006: PPUSH
87007: LD_VAR 0 7
87011: PUSH
87012: LD_INT 2
87014: ARRAY
87015: PPUSH
87016: LD_VAR 0 3
87020: PPUSH
87021: CALL_OW 48
// result := IsPlaced ( unit ) ;
87025: LD_ADDR_VAR 0 4
87029: PUSH
87030: LD_VAR 0 1
87034: PPUSH
87035: CALL_OW 305
87039: ST_TO_ADDR
// exit ;
87040: POP
87041: POP
87042: GO 87048
// end ; end ;
87044: GO 86911
87046: POP
87047: POP
// end ;
87048: LD_VAR 0 4
87052: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87053: LD_INT 0
87055: PPUSH
87056: PPUSH
87057: PPUSH
// if not side or side > 8 then
87058: LD_VAR 0 1
87062: NOT
87063: IFTRUE 87075
87065: PUSH
87066: LD_VAR 0 1
87070: PUSH
87071: LD_INT 8
87073: GREATER
87074: OR
87075: IFFALSE 87079
// exit ;
87077: GO 87266
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87079: LD_ADDR_VAR 0 4
87083: PUSH
87084: LD_INT 22
87086: PUSH
87087: LD_VAR 0 1
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 21
87098: PUSH
87099: LD_INT 3
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PPUSH
87110: CALL_OW 69
87114: ST_TO_ADDR
// if not tmp then
87115: LD_VAR 0 4
87119: NOT
87120: IFFALSE 87124
// exit ;
87122: GO 87266
// enable_addtolog := true ;
87124: LD_ADDR_OWVAR 81
87128: PUSH
87129: LD_INT 1
87131: ST_TO_ADDR
// AddToLog ( [ ) ;
87132: LD_STRING [
87134: PPUSH
87135: CALL_OW 561
// for i in tmp do
87139: LD_ADDR_VAR 0 3
87143: PUSH
87144: LD_VAR 0 4
87148: PUSH
87149: FOR_IN
87150: IFFALSE 87257
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87152: LD_STRING [
87154: PUSH
87155: LD_VAR 0 3
87159: PPUSH
87160: CALL_OW 266
87164: STR
87165: PUSH
87166: LD_STRING , 
87168: STR
87169: PUSH
87170: LD_VAR 0 3
87174: PPUSH
87175: CALL_OW 250
87179: STR
87180: PUSH
87181: LD_STRING , 
87183: STR
87184: PUSH
87185: LD_VAR 0 3
87189: PPUSH
87190: CALL_OW 251
87194: STR
87195: PUSH
87196: LD_STRING , 
87198: STR
87199: PUSH
87200: LD_VAR 0 3
87204: PPUSH
87205: CALL_OW 254
87209: STR
87210: PUSH
87211: LD_STRING , 
87213: STR
87214: PUSH
87215: LD_VAR 0 3
87219: PPUSH
87220: LD_INT 1
87222: PPUSH
87223: CALL_OW 268
87227: STR
87228: PUSH
87229: LD_STRING , 
87231: STR
87232: PUSH
87233: LD_VAR 0 3
87237: PPUSH
87238: LD_INT 2
87240: PPUSH
87241: CALL_OW 268
87245: STR
87246: PUSH
87247: LD_STRING ],
87249: STR
87250: PPUSH
87251: CALL_OW 561
// end ;
87255: GO 87149
87257: POP
87258: POP
// AddToLog ( ]; ) ;
87259: LD_STRING ];
87261: PPUSH
87262: CALL_OW 561
// end ;
87266: LD_VAR 0 2
87270: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
87271: LD_INT 0
87273: PPUSH
87274: PPUSH
87275: PPUSH
87276: PPUSH
87277: PPUSH
// if not area or not rate or not max then
87278: LD_VAR 0 1
87282: NOT
87283: IFTRUE 87292
87285: PUSH
87286: LD_VAR 0 2
87290: NOT
87291: OR
87292: IFTRUE 87301
87294: PUSH
87295: LD_VAR 0 4
87299: NOT
87300: OR
87301: IFFALSE 87305
// exit ;
87303: GO 87494
// while 1 do
87305: LD_INT 1
87307: IFFALSE 87494
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
87309: LD_ADDR_VAR 0 9
87313: PUSH
87314: LD_VAR 0 1
87318: PPUSH
87319: LD_INT 1
87321: PPUSH
87322: CALL_OW 287
87326: PUSH
87327: LD_INT 10
87329: MUL
87330: ST_TO_ADDR
// r := rate / 10 ;
87331: LD_ADDR_VAR 0 7
87335: PUSH
87336: LD_VAR 0 2
87340: PUSH
87341: LD_INT 10
87343: DIVREAL
87344: ST_TO_ADDR
// time := 1 1$00 ;
87345: LD_ADDR_VAR 0 8
87349: PUSH
87350: LD_INT 2100
87352: ST_TO_ADDR
// if amount < min then
87353: LD_VAR 0 9
87357: PUSH
87358: LD_VAR 0 3
87362: LESS
87363: IFFALSE 87381
// r := r * 2 else
87365: LD_ADDR_VAR 0 7
87369: PUSH
87370: LD_VAR 0 7
87374: PUSH
87375: LD_INT 2
87377: MUL
87378: ST_TO_ADDR
87379: GO 87407
// if amount > max then
87381: LD_VAR 0 9
87385: PUSH
87386: LD_VAR 0 4
87390: GREATER
87391: IFFALSE 87407
// r := r / 2 ;
87393: LD_ADDR_VAR 0 7
87397: PUSH
87398: LD_VAR 0 7
87402: PUSH
87403: LD_INT 2
87405: DIVREAL
87406: ST_TO_ADDR
// time := time / r ;
87407: LD_ADDR_VAR 0 8
87411: PUSH
87412: LD_VAR 0 8
87416: PUSH
87417: LD_VAR 0 7
87421: DIVREAL
87422: ST_TO_ADDR
// if time < 0 then
87423: LD_VAR 0 8
87427: PUSH
87428: LD_INT 0
87430: LESS
87431: IFFALSE 87448
// time := time * - 1 ;
87433: LD_ADDR_VAR 0 8
87437: PUSH
87438: LD_VAR 0 8
87442: PUSH
87443: LD_INT 1
87445: NEG
87446: MUL
87447: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
87448: LD_VAR 0 8
87452: PUSH
87453: LD_INT 35
87455: PPUSH
87456: LD_INT 875
87458: PPUSH
87459: CALL_OW 12
87463: PLUS
87464: PPUSH
87465: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
87469: LD_INT 1
87471: PPUSH
87472: LD_INT 5
87474: PPUSH
87475: CALL_OW 12
87479: PPUSH
87480: LD_VAR 0 1
87484: PPUSH
87485: LD_INT 1
87487: PPUSH
87488: CALL_OW 55
// end ;
87492: GO 87305
// end ;
87494: LD_VAR 0 5
87498: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
87499: LD_INT 0
87501: PPUSH
87502: PPUSH
87503: PPUSH
87504: PPUSH
87505: PPUSH
87506: PPUSH
87507: PPUSH
87508: PPUSH
// if not turrets or not factories then
87509: LD_VAR 0 1
87513: NOT
87514: IFTRUE 87523
87516: PUSH
87517: LD_VAR 0 2
87521: NOT
87522: OR
87523: IFFALSE 87527
// exit ;
87525: GO 87834
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
87527: LD_ADDR_VAR 0 10
87531: PUSH
87532: LD_INT 5
87534: PUSH
87535: LD_INT 6
87537: PUSH
87538: EMPTY
87539: LIST
87540: LIST
87541: PUSH
87542: LD_INT 2
87544: PUSH
87545: LD_INT 4
87547: PUSH
87548: EMPTY
87549: LIST
87550: LIST
87551: PUSH
87552: LD_INT 3
87554: PUSH
87555: LD_INT 5
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 24
87569: PUSH
87570: LD_INT 25
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 23
87579: PUSH
87580: LD_INT 27
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 42
87593: PUSH
87594: LD_INT 43
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 44
87603: PUSH
87604: LD_INT 46
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 45
87613: PUSH
87614: LD_INT 47
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: LIST
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: LIST
87630: ST_TO_ADDR
// result := [ ] ;
87631: LD_ADDR_VAR 0 3
87635: PUSH
87636: EMPTY
87637: ST_TO_ADDR
// for i in turrets do
87638: LD_ADDR_VAR 0 4
87642: PUSH
87643: LD_VAR 0 1
87647: PUSH
87648: FOR_IN
87649: IFFALSE 87832
// begin nat := GetNation ( i ) ;
87651: LD_ADDR_VAR 0 7
87655: PUSH
87656: LD_VAR 0 4
87660: PPUSH
87661: CALL_OW 248
87665: ST_TO_ADDR
// weapon := 0 ;
87666: LD_ADDR_VAR 0 8
87670: PUSH
87671: LD_INT 0
87673: ST_TO_ADDR
// if not nat then
87674: LD_VAR 0 7
87678: NOT
87679: IFFALSE 87683
// continue ;
87681: GO 87648
// for j in list [ nat ] do
87683: LD_ADDR_VAR 0 5
87687: PUSH
87688: LD_VAR 0 10
87692: PUSH
87693: LD_VAR 0 7
87697: ARRAY
87698: PUSH
87699: FOR_IN
87700: IFFALSE 87741
// if GetBWeapon ( i ) = j [ 1 ] then
87702: LD_VAR 0 4
87706: PPUSH
87707: CALL_OW 269
87711: PUSH
87712: LD_VAR 0 5
87716: PUSH
87717: LD_INT 1
87719: ARRAY
87720: EQUAL
87721: IFFALSE 87739
// begin weapon := j [ 2 ] ;
87723: LD_ADDR_VAR 0 8
87727: PUSH
87728: LD_VAR 0 5
87732: PUSH
87733: LD_INT 2
87735: ARRAY
87736: ST_TO_ADDR
// break ;
87737: GO 87741
// end ;
87739: GO 87699
87741: POP
87742: POP
// if not weapon then
87743: LD_VAR 0 8
87747: NOT
87748: IFFALSE 87752
// continue ;
87750: GO 87648
// for k in factories do
87752: LD_ADDR_VAR 0 6
87756: PUSH
87757: LD_VAR 0 2
87761: PUSH
87762: FOR_IN
87763: IFFALSE 87828
// begin weapons := AvailableWeaponList ( k ) ;
87765: LD_ADDR_VAR 0 9
87769: PUSH
87770: LD_VAR 0 6
87774: PPUSH
87775: CALL_OW 478
87779: ST_TO_ADDR
// if not weapons then
87780: LD_VAR 0 9
87784: NOT
87785: IFFALSE 87789
// continue ;
87787: GO 87762
// if weapon in weapons then
87789: LD_VAR 0 8
87793: PUSH
87794: LD_VAR 0 9
87798: IN
87799: IFFALSE 87826
// begin result := [ i , weapon ] ;
87801: LD_ADDR_VAR 0 3
87805: PUSH
87806: LD_VAR 0 4
87810: PUSH
87811: LD_VAR 0 8
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: ST_TO_ADDR
// exit ;
87820: POP
87821: POP
87822: POP
87823: POP
87824: GO 87834
// end ; end ;
87826: GO 87762
87828: POP
87829: POP
// end ;
87830: GO 87648
87832: POP
87833: POP
// end ;
87834: LD_VAR 0 3
87838: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87839: LD_INT 0
87841: PPUSH
// if not side or side > 8 then
87842: LD_VAR 0 3
87846: NOT
87847: IFTRUE 87859
87849: PUSH
87850: LD_VAR 0 3
87854: PUSH
87855: LD_INT 8
87857: GREATER
87858: OR
87859: IFFALSE 87863
// exit ;
87861: GO 87922
// if not range then
87863: LD_VAR 0 4
87867: NOT
87868: IFFALSE 87879
// range := - 12 ;
87870: LD_ADDR_VAR 0 4
87874: PUSH
87875: LD_INT 12
87877: NEG
87878: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
87879: LD_VAR 0 1
87883: PPUSH
87884: LD_VAR 0 2
87888: PPUSH
87889: LD_VAR 0 3
87893: PPUSH
87894: LD_VAR 0 4
87898: PPUSH
87899: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
87903: LD_VAR 0 1
87907: PPUSH
87908: LD_VAR 0 2
87912: PPUSH
87913: LD_VAR 0 3
87917: PPUSH
87918: CALL_OW 331
// end ;
87922: LD_VAR 0 5
87926: RET
// export function Video ( mode ) ; begin
87927: LD_INT 0
87929: PPUSH
// ingame_video = mode ;
87930: LD_ADDR_OWVAR 52
87934: PUSH
87935: LD_VAR 0 1
87939: ST_TO_ADDR
// interface_hidden = mode ;
87940: LD_ADDR_OWVAR 54
87944: PUSH
87945: LD_VAR 0 1
87949: ST_TO_ADDR
// end ;
87950: LD_VAR 0 2
87954: RET
// export function Join ( array , element ) ; begin
87955: LD_INT 0
87957: PPUSH
// result := Replace ( array , array + 1 , element ) ;
87958: LD_ADDR_VAR 0 3
87962: PUSH
87963: LD_VAR 0 1
87967: PPUSH
87968: LD_VAR 0 1
87972: PUSH
87973: LD_INT 1
87975: PLUS
87976: PPUSH
87977: LD_VAR 0 2
87981: PPUSH
87982: CALL_OW 1
87986: ST_TO_ADDR
// end ;
87987: LD_VAR 0 3
87991: RET
// export function JoinUnion ( array , element ) ; begin
87992: LD_INT 0
87994: PPUSH
// result := array union element ;
87995: LD_ADDR_VAR 0 3
87999: PUSH
88000: LD_VAR 0 1
88004: PUSH
88005: LD_VAR 0 2
88009: UNION
88010: ST_TO_ADDR
// end ;
88011: LD_VAR 0 3
88015: RET
// export function GetBehemoths ( side ) ; begin
88016: LD_INT 0
88018: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
88019: LD_ADDR_VAR 0 2
88023: PUSH
88024: LD_INT 22
88026: PUSH
88027: LD_VAR 0 1
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PUSH
88036: LD_INT 31
88038: PUSH
88039: LD_INT 25
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PPUSH
88050: CALL_OW 69
88054: ST_TO_ADDR
// end ;
88055: LD_VAR 0 2
88059: RET
// export function Shuffle ( array ) ; var i , index ; begin
88060: LD_INT 0
88062: PPUSH
88063: PPUSH
88064: PPUSH
// result := [ ] ;
88065: LD_ADDR_VAR 0 2
88069: PUSH
88070: EMPTY
88071: ST_TO_ADDR
// if not array then
88072: LD_VAR 0 1
88076: NOT
88077: IFFALSE 88081
// exit ;
88079: GO 88180
// Randomize ;
88081: CALL_OW 10
// for i = array downto 1 do
88085: LD_ADDR_VAR 0 3
88089: PUSH
88090: DOUBLE
88091: LD_VAR 0 1
88095: INC
88096: ST_TO_ADDR
88097: LD_INT 1
88099: PUSH
88100: FOR_DOWNTO
88101: IFFALSE 88178
// begin index := rand ( 1 , array ) ;
88103: LD_ADDR_VAR 0 4
88107: PUSH
88108: LD_INT 1
88110: PPUSH
88111: LD_VAR 0 1
88115: PPUSH
88116: CALL_OW 12
88120: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88121: LD_ADDR_VAR 0 2
88125: PUSH
88126: LD_VAR 0 2
88130: PPUSH
88131: LD_VAR 0 2
88135: PUSH
88136: LD_INT 1
88138: PLUS
88139: PPUSH
88140: LD_VAR 0 1
88144: PUSH
88145: LD_VAR 0 4
88149: ARRAY
88150: PPUSH
88151: CALL_OW 2
88155: ST_TO_ADDR
// array := Delete ( array , index ) ;
88156: LD_ADDR_VAR 0 1
88160: PUSH
88161: LD_VAR 0 1
88165: PPUSH
88166: LD_VAR 0 4
88170: PPUSH
88171: CALL_OW 3
88175: ST_TO_ADDR
// end ;
88176: GO 88100
88178: POP
88179: POP
// end ;
88180: LD_VAR 0 2
88184: RET
// export function GetBaseMaterials ( base ) ; begin
88185: LD_INT 0
88187: PPUSH
// result := [ 0 , 0 , 0 ] ;
88188: LD_ADDR_VAR 0 2
88192: PUSH
88193: LD_INT 0
88195: PUSH
88196: LD_INT 0
88198: PUSH
88199: LD_INT 0
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: LIST
88206: ST_TO_ADDR
// if not base then
88207: LD_VAR 0 1
88211: NOT
88212: IFFALSE 88216
// exit ;
88214: GO 88265
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88216: LD_ADDR_VAR 0 2
88220: PUSH
88221: LD_VAR 0 1
88225: PPUSH
88226: LD_INT 1
88228: PPUSH
88229: CALL_OW 275
88233: PUSH
88234: LD_VAR 0 1
88238: PPUSH
88239: LD_INT 2
88241: PPUSH
88242: CALL_OW 275
88246: PUSH
88247: LD_VAR 0 1
88251: PPUSH
88252: LD_INT 3
88254: PPUSH
88255: CALL_OW 275
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: LIST
88264: ST_TO_ADDR
// end ;
88265: LD_VAR 0 2
88269: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
88270: LD_INT 0
88272: PPUSH
88273: PPUSH
// result := array ;
88274: LD_ADDR_VAR 0 3
88278: PUSH
88279: LD_VAR 0 1
88283: ST_TO_ADDR
// if size >= result then
88284: LD_VAR 0 2
88288: PUSH
88289: LD_VAR 0 3
88293: GREATEREQUAL
88294: IFFALSE 88298
// exit ;
88296: GO 88348
// if size then
88298: LD_VAR 0 2
88302: IFFALSE 88348
// for i := array downto size do
88304: LD_ADDR_VAR 0 4
88308: PUSH
88309: DOUBLE
88310: LD_VAR 0 1
88314: INC
88315: ST_TO_ADDR
88316: LD_VAR 0 2
88320: PUSH
88321: FOR_DOWNTO
88322: IFFALSE 88346
// result := Delete ( result , result ) ;
88324: LD_ADDR_VAR 0 3
88328: PUSH
88329: LD_VAR 0 3
88333: PPUSH
88334: LD_VAR 0 3
88338: PPUSH
88339: CALL_OW 3
88343: ST_TO_ADDR
88344: GO 88321
88346: POP
88347: POP
// end ;
88348: LD_VAR 0 3
88352: RET
// export function ComExit ( unit ) ; var tmp ; begin
88353: LD_INT 0
88355: PPUSH
88356: PPUSH
// if not IsInUnit ( unit ) then
88357: LD_VAR 0 1
88361: PPUSH
88362: CALL_OW 310
88366: NOT
88367: IFFALSE 88371
// exit ;
88369: GO 88431
// tmp := IsInUnit ( unit ) ;
88371: LD_ADDR_VAR 0 3
88375: PUSH
88376: LD_VAR 0 1
88380: PPUSH
88381: CALL_OW 310
88385: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
88386: LD_VAR 0 3
88390: PPUSH
88391: CALL_OW 247
88395: PUSH
88396: LD_INT 2
88398: EQUAL
88399: IFFALSE 88412
// ComExitVehicle ( unit ) else
88401: LD_VAR 0 1
88405: PPUSH
88406: CALL_OW 121
88410: GO 88421
// ComExitBuilding ( unit ) ;
88412: LD_VAR 0 1
88416: PPUSH
88417: CALL_OW 122
// result := tmp ;
88421: LD_ADDR_VAR 0 2
88425: PUSH
88426: LD_VAR 0 3
88430: ST_TO_ADDR
// end ;
88431: LD_VAR 0 2
88435: RET
// export function ComExitAll ( units ) ; var i ; begin
88436: LD_INT 0
88438: PPUSH
88439: PPUSH
// if not units then
88440: LD_VAR 0 1
88444: NOT
88445: IFFALSE 88449
// exit ;
88447: GO 88475
// for i in units do
88449: LD_ADDR_VAR 0 3
88453: PUSH
88454: LD_VAR 0 1
88458: PUSH
88459: FOR_IN
88460: IFFALSE 88473
// ComExit ( i ) ;
88462: LD_VAR 0 3
88466: PPUSH
88467: CALL 88353 0 1
88471: GO 88459
88473: POP
88474: POP
// end ;
88475: LD_VAR 0 2
88479: RET
// export function ResetHc ; begin
88480: LD_INT 0
88482: PPUSH
// InitHc ;
88483: CALL_OW 19
// hc_importance := 0 ;
88487: LD_ADDR_OWVAR 32
88491: PUSH
88492: LD_INT 0
88494: ST_TO_ADDR
// end ;
88495: LD_VAR 0 1
88499: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
88500: LD_INT 0
88502: PPUSH
88503: PPUSH
88504: PPUSH
// _x := ( x1 + x2 ) div 2 ;
88505: LD_ADDR_VAR 0 6
88509: PUSH
88510: LD_VAR 0 1
88514: PUSH
88515: LD_VAR 0 3
88519: PLUS
88520: PUSH
88521: LD_INT 2
88523: DIV
88524: ST_TO_ADDR
// if _x < 0 then
88525: LD_VAR 0 6
88529: PUSH
88530: LD_INT 0
88532: LESS
88533: IFFALSE 88550
// _x := _x * - 1 ;
88535: LD_ADDR_VAR 0 6
88539: PUSH
88540: LD_VAR 0 6
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: MUL
88549: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
88550: LD_ADDR_VAR 0 7
88554: PUSH
88555: LD_VAR 0 2
88559: PUSH
88560: LD_VAR 0 4
88564: PLUS
88565: PUSH
88566: LD_INT 2
88568: DIV
88569: ST_TO_ADDR
// if _y < 0 then
88570: LD_VAR 0 7
88574: PUSH
88575: LD_INT 0
88577: LESS
88578: IFFALSE 88595
// _y := _y * - 1 ;
88580: LD_ADDR_VAR 0 7
88584: PUSH
88585: LD_VAR 0 7
88589: PUSH
88590: LD_INT 1
88592: NEG
88593: MUL
88594: ST_TO_ADDR
// result := [ _x , _y ] ;
88595: LD_ADDR_VAR 0 5
88599: PUSH
88600: LD_VAR 0 6
88604: PUSH
88605: LD_VAR 0 7
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: ST_TO_ADDR
// end ;
88614: LD_VAR 0 5
88618: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88619: LD_INT 0
88621: PPUSH
88622: PPUSH
88623: PPUSH
88624: PPUSH
// task := GetTaskList ( unit ) ;
88625: LD_ADDR_VAR 0 7
88629: PUSH
88630: LD_VAR 0 1
88634: PPUSH
88635: CALL_OW 437
88639: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88640: LD_VAR 0 7
88644: NOT
88645: IFFALSE 88664
88647: PUSH
88648: LD_VAR 0 1
88652: PPUSH
88653: LD_VAR 0 2
88657: PPUSH
88658: CALL_OW 308
88662: NOT
88663: AND
88664: IFFALSE 88668
// exit ;
88666: GO 88786
// if IsInArea ( unit , area ) then
88668: LD_VAR 0 1
88672: PPUSH
88673: LD_VAR 0 2
88677: PPUSH
88678: CALL_OW 308
88682: IFFALSE 88700
// begin ComMoveToArea ( unit , goAway ) ;
88684: LD_VAR 0 1
88688: PPUSH
88689: LD_VAR 0 3
88693: PPUSH
88694: CALL_OW 113
// exit ;
88698: GO 88786
// end ; if task [ 1 ] [ 1 ] <> M then
88700: LD_VAR 0 7
88704: PUSH
88705: LD_INT 1
88707: ARRAY
88708: PUSH
88709: LD_INT 1
88711: ARRAY
88712: PUSH
88713: LD_STRING M
88715: NONEQUAL
88716: IFFALSE 88720
// exit ;
88718: GO 88786
// x := task [ 1 ] [ 2 ] ;
88720: LD_ADDR_VAR 0 5
88724: PUSH
88725: LD_VAR 0 7
88729: PUSH
88730: LD_INT 1
88732: ARRAY
88733: PUSH
88734: LD_INT 2
88736: ARRAY
88737: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88738: LD_ADDR_VAR 0 6
88742: PUSH
88743: LD_VAR 0 7
88747: PUSH
88748: LD_INT 1
88750: ARRAY
88751: PUSH
88752: LD_INT 3
88754: ARRAY
88755: ST_TO_ADDR
// if InArea ( x , y , area ) then
88756: LD_VAR 0 5
88760: PPUSH
88761: LD_VAR 0 6
88765: PPUSH
88766: LD_VAR 0 2
88770: PPUSH
88771: CALL_OW 309
88775: IFFALSE 88786
// ComStop ( unit ) ;
88777: LD_VAR 0 1
88781: PPUSH
88782: CALL_OW 141
// end ;
88786: LD_VAR 0 4
88790: RET
// export function Abs ( value ) ; begin
88791: LD_INT 0
88793: PPUSH
// result := value ;
88794: LD_ADDR_VAR 0 2
88798: PUSH
88799: LD_VAR 0 1
88803: ST_TO_ADDR
// if value < 0 then
88804: LD_VAR 0 1
88808: PUSH
88809: LD_INT 0
88811: LESS
88812: IFFALSE 88829
// result := value * - 1 ;
88814: LD_ADDR_VAR 0 2
88818: PUSH
88819: LD_VAR 0 1
88823: PUSH
88824: LD_INT 1
88826: NEG
88827: MUL
88828: ST_TO_ADDR
// end ;
88829: LD_VAR 0 2
88833: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
88834: LD_INT 0
88836: PPUSH
88837: PPUSH
88838: PPUSH
88839: PPUSH
88840: PPUSH
88841: PPUSH
88842: PPUSH
88843: PPUSH
// if not unit or not building then
88844: LD_VAR 0 1
88848: NOT
88849: IFTRUE 88858
88851: PUSH
88852: LD_VAR 0 2
88856: NOT
88857: OR
88858: IFFALSE 88862
// exit ;
88860: GO 89090
// x := GetX ( building ) ;
88862: LD_ADDR_VAR 0 4
88866: PUSH
88867: LD_VAR 0 2
88871: PPUSH
88872: CALL_OW 250
88876: ST_TO_ADDR
// y := GetY ( building ) ;
88877: LD_ADDR_VAR 0 6
88881: PUSH
88882: LD_VAR 0 2
88886: PPUSH
88887: CALL_OW 251
88891: ST_TO_ADDR
// d := GetDir ( building ) ;
88892: LD_ADDR_VAR 0 8
88896: PUSH
88897: LD_VAR 0 2
88901: PPUSH
88902: CALL_OW 254
88906: ST_TO_ADDR
// r := 4 ;
88907: LD_ADDR_VAR 0 9
88911: PUSH
88912: LD_INT 4
88914: ST_TO_ADDR
// for i := 1 to 5 do
88915: LD_ADDR_VAR 0 10
88919: PUSH
88920: DOUBLE
88921: LD_INT 1
88923: DEC
88924: ST_TO_ADDR
88925: LD_INT 5
88927: PUSH
88928: FOR_TO
88929: IFFALSE 89088
// begin _x := ShiftX ( x , d , r + i ) ;
88931: LD_ADDR_VAR 0 5
88935: PUSH
88936: LD_VAR 0 4
88940: PPUSH
88941: LD_VAR 0 8
88945: PPUSH
88946: LD_VAR 0 9
88950: PUSH
88951: LD_VAR 0 10
88955: PLUS
88956: PPUSH
88957: CALL_OW 272
88961: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
88962: LD_ADDR_VAR 0 7
88966: PUSH
88967: LD_VAR 0 6
88971: PPUSH
88972: LD_VAR 0 8
88976: PPUSH
88977: LD_VAR 0 9
88981: PUSH
88982: LD_VAR 0 10
88986: PLUS
88987: PPUSH
88988: CALL_OW 273
88992: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
88993: LD_VAR 0 5
88997: PPUSH
88998: LD_VAR 0 7
89002: PPUSH
89003: CALL_OW 488
89007: IFFALSE 89042
89009: PUSH
89010: LD_VAR 0 5
89014: PPUSH
89015: LD_VAR 0 7
89019: PPUSH
89020: CALL_OW 428
89024: PPUSH
89025: CALL_OW 247
89029: PUSH
89030: LD_INT 3
89032: PUSH
89033: LD_INT 2
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: IN
89040: NOT
89041: AND
89042: IFFALSE 89086
// begin ComMoveXY ( unit , _x , _y ) ;
89044: LD_VAR 0 1
89048: PPUSH
89049: LD_VAR 0 5
89053: PPUSH
89054: LD_VAR 0 7
89058: PPUSH
89059: CALL_OW 111
// result := [ _x , _y ] ;
89063: LD_ADDR_VAR 0 3
89067: PUSH
89068: LD_VAR 0 5
89072: PUSH
89073: LD_VAR 0 7
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: ST_TO_ADDR
// exit ;
89082: POP
89083: POP
89084: GO 89090
// end ; end ;
89086: GO 88928
89088: POP
89089: POP
// end ;
89090: LD_VAR 0 3
89094: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89095: LD_INT 0
89097: PPUSH
89098: PPUSH
89099: PPUSH
// result := 0 ;
89100: LD_ADDR_VAR 0 3
89104: PUSH
89105: LD_INT 0
89107: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89108: LD_VAR 0 1
89112: PUSH
89113: LD_INT 0
89115: LESS
89116: IFTRUE 89128
89118: PUSH
89119: LD_VAR 0 1
89123: PUSH
89124: LD_INT 8
89126: GREATER
89127: OR
89128: IFTRUE 89140
89130: PUSH
89131: LD_VAR 0 2
89135: PUSH
89136: LD_INT 0
89138: LESS
89139: OR
89140: IFTRUE 89152
89142: PUSH
89143: LD_VAR 0 2
89147: PUSH
89148: LD_INT 8
89150: GREATER
89151: OR
89152: IFFALSE 89156
// exit ;
89154: GO 89231
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89156: LD_ADDR_VAR 0 4
89160: PUSH
89161: LD_INT 22
89163: PUSH
89164: LD_VAR 0 2
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PPUSH
89173: CALL_OW 69
89177: PUSH
89178: FOR_IN
89179: IFFALSE 89229
// begin un := UnitShoot ( i ) ;
89181: LD_ADDR_VAR 0 5
89185: PUSH
89186: LD_VAR 0 4
89190: PPUSH
89191: CALL_OW 504
89195: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89196: LD_VAR 0 5
89200: PPUSH
89201: CALL_OW 255
89205: PUSH
89206: LD_VAR 0 1
89210: EQUAL
89211: IFFALSE 89227
// begin result := un ;
89213: LD_ADDR_VAR 0 3
89217: PUSH
89218: LD_VAR 0 5
89222: ST_TO_ADDR
// exit ;
89223: POP
89224: POP
89225: GO 89231
// end ; end ;
89227: GO 89178
89229: POP
89230: POP
// end ;
89231: LD_VAR 0 3
89235: RET
// export function GetCargoBay ( units ) ; begin
89236: LD_INT 0
89238: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89239: LD_ADDR_VAR 0 2
89243: PUSH
89244: LD_VAR 0 1
89248: PPUSH
89249: LD_INT 2
89251: PUSH
89252: LD_INT 34
89254: PUSH
89255: LD_INT 12
89257: PUSH
89258: EMPTY
89259: LIST
89260: LIST
89261: PUSH
89262: LD_INT 34
89264: PUSH
89265: LD_INT 51
89267: PUSH
89268: EMPTY
89269: LIST
89270: LIST
89271: PUSH
89272: LD_INT 34
89274: PUSH
89275: LD_INT 32
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 34
89284: PUSH
89285: LD_INT 89
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: PPUSH
89299: CALL_OW 72
89303: ST_TO_ADDR
// end ;
89304: LD_VAR 0 2
89308: RET
// export function Negate ( value ) ; begin
89309: LD_INT 0
89311: PPUSH
// result := not value ;
89312: LD_ADDR_VAR 0 2
89316: PUSH
89317: LD_VAR 0 1
89321: NOT
89322: ST_TO_ADDR
// end ;
89323: LD_VAR 0 2
89327: RET
// export function Inc ( value ) ; begin
89328: LD_INT 0
89330: PPUSH
// result := value + 1 ;
89331: LD_ADDR_VAR 0 2
89335: PUSH
89336: LD_VAR 0 1
89340: PUSH
89341: LD_INT 1
89343: PLUS
89344: ST_TO_ADDR
// end ;
89345: LD_VAR 0 2
89349: RET
// export function Dec ( value ) ; begin
89350: LD_INT 0
89352: PPUSH
// result := value - 1 ;
89353: LD_ADDR_VAR 0 2
89357: PUSH
89358: LD_VAR 0 1
89362: PUSH
89363: LD_INT 1
89365: MINUS
89366: ST_TO_ADDR
// end ;
89367: LD_VAR 0 2
89371: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
89372: LD_INT 0
89374: PPUSH
89375: PPUSH
89376: PPUSH
89377: PPUSH
89378: PPUSH
89379: PPUSH
89380: PPUSH
89381: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
89382: LD_VAR 0 1
89386: PPUSH
89387: LD_VAR 0 2
89391: PPUSH
89392: CALL_OW 488
89396: NOT
89397: IFTRUE 89416
89399: PUSH
89400: LD_VAR 0 3
89404: PPUSH
89405: LD_VAR 0 4
89409: PPUSH
89410: CALL_OW 488
89414: NOT
89415: OR
89416: IFFALSE 89429
// begin result := - 1 ;
89418: LD_ADDR_VAR 0 5
89422: PUSH
89423: LD_INT 1
89425: NEG
89426: ST_TO_ADDR
// exit ;
89427: GO 89664
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
89429: LD_ADDR_VAR 0 12
89433: PUSH
89434: LD_VAR 0 1
89438: PPUSH
89439: LD_VAR 0 2
89443: PPUSH
89444: LD_VAR 0 3
89448: PPUSH
89449: LD_VAR 0 4
89453: PPUSH
89454: CALL 88500 0 4
89458: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
89459: LD_ADDR_VAR 0 11
89463: PUSH
89464: LD_VAR 0 1
89468: PPUSH
89469: LD_VAR 0 2
89473: PPUSH
89474: LD_VAR 0 12
89478: PUSH
89479: LD_INT 1
89481: ARRAY
89482: PPUSH
89483: LD_VAR 0 12
89487: PUSH
89488: LD_INT 2
89490: ARRAY
89491: PPUSH
89492: CALL_OW 298
89496: ST_TO_ADDR
// distance := 9999 ;
89497: LD_ADDR_VAR 0 10
89501: PUSH
89502: LD_INT 9999
89504: ST_TO_ADDR
// for i := 0 to 5 do
89505: LD_ADDR_VAR 0 6
89509: PUSH
89510: DOUBLE
89511: LD_INT 0
89513: DEC
89514: ST_TO_ADDR
89515: LD_INT 5
89517: PUSH
89518: FOR_TO
89519: IFFALSE 89662
// begin _x := ShiftX ( x1 , i , centerDist ) ;
89521: LD_ADDR_VAR 0 7
89525: PUSH
89526: LD_VAR 0 1
89530: PPUSH
89531: LD_VAR 0 6
89535: PPUSH
89536: LD_VAR 0 11
89540: PPUSH
89541: CALL_OW 272
89545: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
89546: LD_ADDR_VAR 0 8
89550: PUSH
89551: LD_VAR 0 2
89555: PPUSH
89556: LD_VAR 0 6
89560: PPUSH
89561: LD_VAR 0 11
89565: PPUSH
89566: CALL_OW 273
89570: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
89571: LD_VAR 0 7
89575: PPUSH
89576: LD_VAR 0 8
89580: PPUSH
89581: CALL_OW 488
89585: NOT
89586: IFFALSE 89590
// continue ;
89588: GO 89518
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
89590: LD_ADDR_VAR 0 9
89594: PUSH
89595: LD_VAR 0 12
89599: PUSH
89600: LD_INT 1
89602: ARRAY
89603: PPUSH
89604: LD_VAR 0 12
89608: PUSH
89609: LD_INT 2
89611: ARRAY
89612: PPUSH
89613: LD_VAR 0 7
89617: PPUSH
89618: LD_VAR 0 8
89622: PPUSH
89623: CALL_OW 298
89627: ST_TO_ADDR
// if tmp < distance then
89628: LD_VAR 0 9
89632: PUSH
89633: LD_VAR 0 10
89637: LESS
89638: IFFALSE 89660
// begin result := i ;
89640: LD_ADDR_VAR 0 5
89644: PUSH
89645: LD_VAR 0 6
89649: ST_TO_ADDR
// distance := tmp ;
89650: LD_ADDR_VAR 0 10
89654: PUSH
89655: LD_VAR 0 9
89659: ST_TO_ADDR
// end ; end ;
89660: GO 89518
89662: POP
89663: POP
// end ;
89664: LD_VAR 0 5
89668: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89669: LD_INT 0
89671: PPUSH
89672: PPUSH
// if not driver or not IsInUnit ( driver ) then
89673: LD_VAR 0 1
89677: NOT
89678: IFTRUE 89692
89680: PUSH
89681: LD_VAR 0 1
89685: PPUSH
89686: CALL_OW 310
89690: NOT
89691: OR
89692: IFFALSE 89696
// exit ;
89694: GO 89786
// vehicle := IsInUnit ( driver ) ;
89696: LD_ADDR_VAR 0 3
89700: PUSH
89701: LD_VAR 0 1
89705: PPUSH
89706: CALL_OW 310
89710: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89711: LD_VAR 0 1
89715: PPUSH
89716: LD_STRING \
89718: PUSH
89719: LD_INT 0
89721: PUSH
89722: LD_INT 0
89724: PUSH
89725: LD_INT 0
89727: PUSH
89728: LD_INT 0
89730: PUSH
89731: LD_INT 0
89733: PUSH
89734: LD_INT 0
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: LIST
89744: LIST
89745: PUSH
89746: LD_STRING E
89748: PUSH
89749: LD_INT 0
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: LD_VAR 0 3
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: LD_INT 0
89765: PUSH
89766: LD_INT 0
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PPUSH
89782: CALL_OW 446
// end ;
89786: LD_VAR 0 2
89790: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89791: LD_INT 0
89793: PPUSH
89794: PPUSH
// if not driver or not IsInUnit ( driver ) then
89795: LD_VAR 0 1
89799: NOT
89800: IFTRUE 89814
89802: PUSH
89803: LD_VAR 0 1
89807: PPUSH
89808: CALL_OW 310
89812: NOT
89813: OR
89814: IFFALSE 89818
// exit ;
89816: GO 89908
// vehicle := IsInUnit ( driver ) ;
89818: LD_ADDR_VAR 0 3
89822: PUSH
89823: LD_VAR 0 1
89827: PPUSH
89828: CALL_OW 310
89832: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89833: LD_VAR 0 1
89837: PPUSH
89838: LD_STRING \
89840: PUSH
89841: LD_INT 0
89843: PUSH
89844: LD_INT 0
89846: PUSH
89847: LD_INT 0
89849: PUSH
89850: LD_INT 0
89852: PUSH
89853: LD_INT 0
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: PUSH
89868: LD_STRING E
89870: PUSH
89871: LD_INT 0
89873: PUSH
89874: LD_INT 0
89876: PUSH
89877: LD_VAR 0 3
89881: PUSH
89882: LD_INT 0
89884: PUSH
89885: LD_INT 0
89887: PUSH
89888: LD_INT 0
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PPUSH
89904: CALL_OW 447
// end ;
89908: LD_VAR 0 2
89912: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
89913: LD_INT 0
89915: PPUSH
89916: PPUSH
89917: PPUSH
// tmp := [ ] ;
89918: LD_ADDR_VAR 0 5
89922: PUSH
89923: EMPTY
89924: ST_TO_ADDR
// for i in units do
89925: LD_ADDR_VAR 0 4
89929: PUSH
89930: LD_VAR 0 1
89934: PUSH
89935: FOR_IN
89936: IFFALSE 89974
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
89938: LD_ADDR_VAR 0 5
89942: PUSH
89943: LD_VAR 0 5
89947: PPUSH
89948: LD_VAR 0 5
89952: PUSH
89953: LD_INT 1
89955: PLUS
89956: PPUSH
89957: LD_VAR 0 4
89961: PPUSH
89962: CALL_OW 256
89966: PPUSH
89967: CALL_OW 2
89971: ST_TO_ADDR
89972: GO 89935
89974: POP
89975: POP
// if not tmp then
89976: LD_VAR 0 5
89980: NOT
89981: IFFALSE 89985
// exit ;
89983: GO 90033
// if asc then
89985: LD_VAR 0 2
89989: IFFALSE 90013
// result := SortListByListAsc ( units , tmp ) else
89991: LD_ADDR_VAR 0 3
89995: PUSH
89996: LD_VAR 0 1
90000: PPUSH
90001: LD_VAR 0 5
90005: PPUSH
90006: CALL_OW 76
90010: ST_TO_ADDR
90011: GO 90033
// result := SortListByListDesc ( units , tmp ) ;
90013: LD_ADDR_VAR 0 3
90017: PUSH
90018: LD_VAR 0 1
90022: PPUSH
90023: LD_VAR 0 5
90027: PPUSH
90028: CALL_OW 77
90032: ST_TO_ADDR
// end ;
90033: LD_VAR 0 3
90037: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90038: LD_INT 0
90040: PPUSH
90041: PPUSH
// task := GetTaskList ( mech ) ;
90042: LD_ADDR_VAR 0 4
90046: PUSH
90047: LD_VAR 0 1
90051: PPUSH
90052: CALL_OW 437
90056: ST_TO_ADDR
// if not task then
90057: LD_VAR 0 4
90061: NOT
90062: IFFALSE 90066
// exit ;
90064: GO 90110
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90066: LD_ADDR_VAR 0 3
90070: PUSH
90071: LD_VAR 0 4
90075: PUSH
90076: LD_INT 1
90078: ARRAY
90079: PUSH
90080: LD_INT 1
90082: ARRAY
90083: PUSH
90084: LD_STRING r
90086: EQUAL
90087: IFFALSE 90109
90089: PUSH
90090: LD_VAR 0 4
90094: PUSH
90095: LD_INT 1
90097: ARRAY
90098: PUSH
90099: LD_INT 4
90101: ARRAY
90102: PUSH
90103: LD_VAR 0 2
90107: EQUAL
90108: AND
90109: ST_TO_ADDR
// end ;
90110: LD_VAR 0 3
90114: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90115: LD_INT 0
90117: PPUSH
// SetDir ( unit , d ) ;
90118: LD_VAR 0 1
90122: PPUSH
90123: LD_VAR 0 4
90127: PPUSH
90128: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
90132: LD_ADDR_VAR 0 6
90136: PUSH
90137: LD_VAR 0 1
90141: PPUSH
90142: LD_VAR 0 2
90146: PPUSH
90147: LD_VAR 0 3
90151: PPUSH
90152: LD_VAR 0 5
90156: PPUSH
90157: CALL_OW 48
90161: ST_TO_ADDR
// end ;
90162: LD_VAR 0 6
90166: RET
// export function ToNaturalNumber ( number ) ; begin
90167: LD_INT 0
90169: PPUSH
// result := number div 1 ;
90170: LD_ADDR_VAR 0 2
90174: PUSH
90175: LD_VAR 0 1
90179: PUSH
90180: LD_INT 1
90182: DIV
90183: ST_TO_ADDR
// if number < 0 then
90184: LD_VAR 0 1
90188: PUSH
90189: LD_INT 0
90191: LESS
90192: IFFALSE 90202
// result := 0 ;
90194: LD_ADDR_VAR 0 2
90198: PUSH
90199: LD_INT 0
90201: ST_TO_ADDR
// end ;
90202: LD_VAR 0 2
90206: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
90207: LD_INT 0
90209: PPUSH
90210: PPUSH
90211: PPUSH
// if not buildings then
90212: LD_VAR 0 1
90216: NOT
90217: IFFALSE 90221
// exit ;
90219: GO 90336
// tmp := [ ] ;
90221: LD_ADDR_VAR 0 5
90225: PUSH
90226: EMPTY
90227: ST_TO_ADDR
// for b in buildings do
90228: LD_ADDR_VAR 0 4
90232: PUSH
90233: LD_VAR 0 1
90237: PUSH
90238: FOR_IN
90239: IFFALSE 90277
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
90241: LD_ADDR_VAR 0 5
90245: PUSH
90246: LD_VAR 0 5
90250: PPUSH
90251: LD_VAR 0 5
90255: PUSH
90256: LD_INT 1
90258: PLUS
90259: PPUSH
90260: LD_VAR 0 4
90264: PPUSH
90265: CALL_OW 266
90269: PPUSH
90270: CALL_OW 1
90274: ST_TO_ADDR
90275: GO 90238
90277: POP
90278: POP
// if not tmp then
90279: LD_VAR 0 5
90283: NOT
90284: IFFALSE 90288
// exit ;
90286: GO 90336
// if asc then
90288: LD_VAR 0 2
90292: IFFALSE 90316
// result := SortListByListAsc ( buildings , tmp ) else
90294: LD_ADDR_VAR 0 3
90298: PUSH
90299: LD_VAR 0 1
90303: PPUSH
90304: LD_VAR 0 5
90308: PPUSH
90309: CALL_OW 76
90313: ST_TO_ADDR
90314: GO 90336
// result := SortListByListDesc ( buildings , tmp ) ;
90316: LD_ADDR_VAR 0 3
90320: PUSH
90321: LD_VAR 0 1
90325: PPUSH
90326: LD_VAR 0 5
90330: PPUSH
90331: CALL_OW 77
90335: ST_TO_ADDR
// end ;
90336: LD_VAR 0 3
90340: RET
// export function SortByClass ( units , class ) ; var un ; begin
90341: LD_INT 0
90343: PPUSH
90344: PPUSH
// if not units or not class then
90345: LD_VAR 0 1
90349: NOT
90350: IFTRUE 90359
90352: PUSH
90353: LD_VAR 0 2
90357: NOT
90358: OR
90359: IFFALSE 90363
// exit ;
90361: GO 90458
// result := [ ] ;
90363: LD_ADDR_VAR 0 3
90367: PUSH
90368: EMPTY
90369: ST_TO_ADDR
// for un in units do
90370: LD_ADDR_VAR 0 4
90374: PUSH
90375: LD_VAR 0 1
90379: PUSH
90380: FOR_IN
90381: IFFALSE 90456
// if GetClass ( un ) = class then
90383: LD_VAR 0 4
90387: PPUSH
90388: CALL_OW 257
90392: PUSH
90393: LD_VAR 0 2
90397: EQUAL
90398: IFFALSE 90425
// result := Insert ( result , 1 , un ) else
90400: LD_ADDR_VAR 0 3
90404: PUSH
90405: LD_VAR 0 3
90409: PPUSH
90410: LD_INT 1
90412: PPUSH
90413: LD_VAR 0 4
90417: PPUSH
90418: CALL_OW 2
90422: ST_TO_ADDR
90423: GO 90454
// result := Replace ( result , result + 1 , un ) ;
90425: LD_ADDR_VAR 0 3
90429: PUSH
90430: LD_VAR 0 3
90434: PPUSH
90435: LD_VAR 0 3
90439: PUSH
90440: LD_INT 1
90442: PLUS
90443: PPUSH
90444: LD_VAR 0 4
90448: PPUSH
90449: CALL_OW 1
90453: ST_TO_ADDR
90454: GO 90380
90456: POP
90457: POP
// end ;
90458: LD_VAR 0 3
90462: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
90463: LD_INT 0
90465: PPUSH
90466: PPUSH
90467: PPUSH
90468: PPUSH
90469: PPUSH
90470: PPUSH
90471: PPUSH
// result := [ ] ;
90472: LD_ADDR_VAR 0 4
90476: PUSH
90477: EMPTY
90478: ST_TO_ADDR
// if x - r < 0 then
90479: LD_VAR 0 1
90483: PUSH
90484: LD_VAR 0 3
90488: MINUS
90489: PUSH
90490: LD_INT 0
90492: LESS
90493: IFFALSE 90505
// min_x := 0 else
90495: LD_ADDR_VAR 0 8
90499: PUSH
90500: LD_INT 0
90502: ST_TO_ADDR
90503: GO 90521
// min_x := x - r ;
90505: LD_ADDR_VAR 0 8
90509: PUSH
90510: LD_VAR 0 1
90514: PUSH
90515: LD_VAR 0 3
90519: MINUS
90520: ST_TO_ADDR
// if y - r < 0 then
90521: LD_VAR 0 2
90525: PUSH
90526: LD_VAR 0 3
90530: MINUS
90531: PUSH
90532: LD_INT 0
90534: LESS
90535: IFFALSE 90547
// min_y := 0 else
90537: LD_ADDR_VAR 0 7
90541: PUSH
90542: LD_INT 0
90544: ST_TO_ADDR
90545: GO 90563
// min_y := y - r ;
90547: LD_ADDR_VAR 0 7
90551: PUSH
90552: LD_VAR 0 2
90556: PUSH
90557: LD_VAR 0 3
90561: MINUS
90562: ST_TO_ADDR
// max_x := x + r ;
90563: LD_ADDR_VAR 0 9
90567: PUSH
90568: LD_VAR 0 1
90572: PUSH
90573: LD_VAR 0 3
90577: PLUS
90578: ST_TO_ADDR
// max_y := y + r ;
90579: LD_ADDR_VAR 0 10
90583: PUSH
90584: LD_VAR 0 2
90588: PUSH
90589: LD_VAR 0 3
90593: PLUS
90594: ST_TO_ADDR
// for _x = min_x to max_x do
90595: LD_ADDR_VAR 0 5
90599: PUSH
90600: DOUBLE
90601: LD_VAR 0 8
90605: DEC
90606: ST_TO_ADDR
90607: LD_VAR 0 9
90611: PUSH
90612: FOR_TO
90613: IFFALSE 90714
// for _y = min_y to max_y do
90615: LD_ADDR_VAR 0 6
90619: PUSH
90620: DOUBLE
90621: LD_VAR 0 7
90625: DEC
90626: ST_TO_ADDR
90627: LD_VAR 0 10
90631: PUSH
90632: FOR_TO
90633: IFFALSE 90710
// begin if not ValidHex ( _x , _y ) then
90635: LD_VAR 0 5
90639: PPUSH
90640: LD_VAR 0 6
90644: PPUSH
90645: CALL_OW 488
90649: NOT
90650: IFFALSE 90654
// continue ;
90652: GO 90632
// if GetResourceTypeXY ( _x , _y ) then
90654: LD_VAR 0 5
90658: PPUSH
90659: LD_VAR 0 6
90663: PPUSH
90664: CALL_OW 283
90668: IFFALSE 90708
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
90670: LD_ADDR_VAR 0 4
90674: PUSH
90675: LD_VAR 0 4
90679: PPUSH
90680: LD_VAR 0 4
90684: PUSH
90685: LD_INT 1
90687: PLUS
90688: PPUSH
90689: LD_VAR 0 5
90693: PUSH
90694: LD_VAR 0 6
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PPUSH
90703: CALL_OW 1
90707: ST_TO_ADDR
// end ;
90708: GO 90632
90710: POP
90711: POP
90712: GO 90612
90714: POP
90715: POP
// end ;
90716: LD_VAR 0 4
90720: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
90721: LD_INT 0
90723: PPUSH
90724: PPUSH
90725: PPUSH
90726: PPUSH
90727: PPUSH
90728: PPUSH
90729: PPUSH
90730: PPUSH
// if not units then
90731: LD_VAR 0 1
90735: NOT
90736: IFFALSE 90740
// exit ;
90738: GO 91272
// result := UnitFilter ( units , [ f_ok ] ) ;
90740: LD_ADDR_VAR 0 3
90744: PUSH
90745: LD_VAR 0 1
90749: PPUSH
90750: LD_INT 50
90752: PUSH
90753: EMPTY
90754: LIST
90755: PPUSH
90756: CALL_OW 72
90760: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
90761: LD_ADDR_VAR 0 8
90765: PUSH
90766: LD_VAR 0 1
90770: PUSH
90771: LD_INT 1
90773: ARRAY
90774: PPUSH
90775: CALL_OW 255
90779: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
90780: LD_ADDR_VAR 0 10
90784: PUSH
90785: LD_INT 29
90787: PUSH
90788: LD_INT 91
90790: PUSH
90791: LD_INT 49
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: LIST
90798: ST_TO_ADDR
// if not result then
90799: LD_VAR 0 3
90803: NOT
90804: IFFALSE 90808
// exit ;
90806: GO 91272
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
90808: LD_ADDR_VAR 0 5
90812: PUSH
90813: LD_INT 81
90815: PUSH
90816: LD_VAR 0 8
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PPUSH
90825: CALL_OW 69
90829: ST_TO_ADDR
// for i in result do
90830: LD_ADDR_VAR 0 4
90834: PUSH
90835: LD_VAR 0 3
90839: PUSH
90840: FOR_IN
90841: IFFALSE 91270
// begin tag := GetTag ( i ) + 1 ;
90843: LD_ADDR_VAR 0 9
90847: PUSH
90848: LD_VAR 0 4
90852: PPUSH
90853: CALL_OW 110
90857: PUSH
90858: LD_INT 1
90860: PLUS
90861: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
90862: LD_ADDR_VAR 0 7
90866: PUSH
90867: LD_VAR 0 4
90871: PPUSH
90872: CALL_OW 250
90876: PPUSH
90877: LD_VAR 0 4
90881: PPUSH
90882: CALL_OW 251
90886: PPUSH
90887: LD_INT 4
90889: PPUSH
90890: CALL 90463 0 3
90894: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
90895: LD_VAR 0 4
90899: PPUSH
90900: CALL_OW 247
90904: PUSH
90905: LD_INT 2
90907: EQUAL
90908: IFFALSE 90920
90910: PUSH
90911: LD_VAR 0 7
90915: PUSH
90916: LD_INT 2
90918: GREATER
90919: AND
90920: IFFALSE 90940
90922: PUSH
90923: LD_VAR 0 4
90927: PPUSH
90928: CALL_OW 264
90932: PUSH
90933: LD_VAR 0 10
90937: IN
90938: NOT
90939: AND
90940: IFFALSE 90979
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
90942: LD_VAR 0 4
90946: PPUSH
90947: LD_VAR 0 7
90951: PUSH
90952: LD_INT 1
90954: ARRAY
90955: PUSH
90956: LD_INT 1
90958: ARRAY
90959: PPUSH
90960: LD_VAR 0 7
90964: PUSH
90965: LD_INT 1
90967: ARRAY
90968: PUSH
90969: LD_INT 2
90971: ARRAY
90972: PPUSH
90973: CALL_OW 116
90977: GO 91268
// if path > tag then
90979: LD_VAR 0 2
90983: PUSH
90984: LD_VAR 0 9
90988: GREATER
90989: IFFALSE 91197
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
90991: LD_ADDR_VAR 0 6
90995: PUSH
90996: LD_VAR 0 5
91000: PPUSH
91001: LD_INT 91
91003: PUSH
91004: LD_VAR 0 4
91008: PUSH
91009: LD_INT 8
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: LIST
91016: PPUSH
91017: CALL_OW 72
91021: ST_TO_ADDR
// if nearEnemy then
91022: LD_VAR 0 6
91026: IFFALSE 91095
// begin if GetWeapon ( i ) = ru_time_lapser then
91028: LD_VAR 0 4
91032: PPUSH
91033: CALL_OW 264
91037: PUSH
91038: LD_INT 49
91040: EQUAL
91041: IFFALSE 91069
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
91043: LD_VAR 0 4
91047: PPUSH
91048: LD_VAR 0 6
91052: PPUSH
91053: LD_VAR 0 4
91057: PPUSH
91058: CALL_OW 74
91062: PPUSH
91063: CALL_OW 112
91067: GO 91093
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
91069: LD_VAR 0 4
91073: PPUSH
91074: LD_VAR 0 6
91078: PPUSH
91079: LD_VAR 0 4
91083: PPUSH
91084: CALL_OW 74
91088: PPUSH
91089: CALL 92353 0 2
// end else
91093: GO 91195
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
91095: LD_VAR 0 4
91099: PPUSH
91100: LD_VAR 0 2
91104: PUSH
91105: LD_VAR 0 9
91109: ARRAY
91110: PUSH
91111: LD_INT 1
91113: ARRAY
91114: PPUSH
91115: LD_VAR 0 2
91119: PUSH
91120: LD_VAR 0 9
91124: ARRAY
91125: PUSH
91126: LD_INT 2
91128: ARRAY
91129: PPUSH
91130: CALL_OW 297
91134: PUSH
91135: LD_INT 6
91137: GREATER
91138: IFFALSE 91181
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
91140: LD_VAR 0 4
91144: PPUSH
91145: LD_VAR 0 2
91149: PUSH
91150: LD_VAR 0 9
91154: ARRAY
91155: PUSH
91156: LD_INT 1
91158: ARRAY
91159: PPUSH
91160: LD_VAR 0 2
91164: PUSH
91165: LD_VAR 0 9
91169: ARRAY
91170: PUSH
91171: LD_INT 2
91173: ARRAY
91174: PPUSH
91175: CALL_OW 114
91179: GO 91195
// SetTag ( i , tag ) ;
91181: LD_VAR 0 4
91185: PPUSH
91186: LD_VAR 0 9
91190: PPUSH
91191: CALL_OW 109
// end else
91195: GO 91268
// if enemy then
91197: LD_VAR 0 5
91201: IFFALSE 91268
// begin if GetWeapon ( i ) = ru_time_lapser then
91203: LD_VAR 0 4
91207: PPUSH
91208: CALL_OW 264
91212: PUSH
91213: LD_INT 49
91215: EQUAL
91216: IFFALSE 91244
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
91218: LD_VAR 0 4
91222: PPUSH
91223: LD_VAR 0 5
91227: PPUSH
91228: LD_VAR 0 4
91232: PPUSH
91233: CALL_OW 74
91237: PPUSH
91238: CALL_OW 112
91242: GO 91268
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
91244: LD_VAR 0 4
91248: PPUSH
91249: LD_VAR 0 5
91253: PPUSH
91254: LD_VAR 0 4
91258: PPUSH
91259: CALL_OW 74
91263: PPUSH
91264: CALL 92353 0 2
// end ; end ;
91268: GO 90840
91270: POP
91271: POP
// end ;
91272: LD_VAR 0 3
91276: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
91277: LD_INT 0
91279: PPUSH
91280: PPUSH
91281: PPUSH
// if not unit or IsInUnit ( unit ) then
91282: LD_VAR 0 1
91286: NOT
91287: IFTRUE 91300
91289: PUSH
91290: LD_VAR 0 1
91294: PPUSH
91295: CALL_OW 310
91299: OR
91300: IFFALSE 91304
// exit ;
91302: GO 91395
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
91304: LD_ADDR_VAR 0 4
91308: PUSH
91309: LD_VAR 0 1
91313: PPUSH
91314: CALL_OW 250
91318: PPUSH
91319: LD_VAR 0 2
91323: PPUSH
91324: LD_INT 1
91326: PPUSH
91327: CALL_OW 272
91331: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
91332: LD_ADDR_VAR 0 5
91336: PUSH
91337: LD_VAR 0 1
91341: PPUSH
91342: CALL_OW 251
91346: PPUSH
91347: LD_VAR 0 2
91351: PPUSH
91352: LD_INT 1
91354: PPUSH
91355: CALL_OW 273
91359: ST_TO_ADDR
// if ValidHex ( x , y ) then
91360: LD_VAR 0 4
91364: PPUSH
91365: LD_VAR 0 5
91369: PPUSH
91370: CALL_OW 488
91374: IFFALSE 91395
// ComTurnXY ( unit , x , y ) ;
91376: LD_VAR 0 1
91380: PPUSH
91381: LD_VAR 0 4
91385: PPUSH
91386: LD_VAR 0 5
91390: PPUSH
91391: CALL_OW 118
// end ;
91395: LD_VAR 0 3
91399: RET
// export function SeeUnits ( side , units ) ; var i ; begin
91400: LD_INT 0
91402: PPUSH
91403: PPUSH
// result := false ;
91404: LD_ADDR_VAR 0 3
91408: PUSH
91409: LD_INT 0
91411: ST_TO_ADDR
// if not units then
91412: LD_VAR 0 2
91416: NOT
91417: IFFALSE 91421
// exit ;
91419: GO 91466
// for i in units do
91421: LD_ADDR_VAR 0 4
91425: PUSH
91426: LD_VAR 0 2
91430: PUSH
91431: FOR_IN
91432: IFFALSE 91464
// if See ( side , i ) then
91434: LD_VAR 0 1
91438: PPUSH
91439: LD_VAR 0 4
91443: PPUSH
91444: CALL_OW 292
91448: IFFALSE 91462
// begin result := true ;
91450: LD_ADDR_VAR 0 3
91454: PUSH
91455: LD_INT 1
91457: ST_TO_ADDR
// exit ;
91458: POP
91459: POP
91460: GO 91466
// end ;
91462: GO 91431
91464: POP
91465: POP
// end ;
91466: LD_VAR 0 3
91470: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
91471: LD_INT 0
91473: PPUSH
91474: PPUSH
91475: PPUSH
91476: PPUSH
// if not unit or not points then
91477: LD_VAR 0 1
91481: NOT
91482: IFTRUE 91491
91484: PUSH
91485: LD_VAR 0 2
91489: NOT
91490: OR
91491: IFFALSE 91495
// exit ;
91493: GO 91585
// dist := 99999 ;
91495: LD_ADDR_VAR 0 5
91499: PUSH
91500: LD_INT 99999
91502: ST_TO_ADDR
// for i in points do
91503: LD_ADDR_VAR 0 4
91507: PUSH
91508: LD_VAR 0 2
91512: PUSH
91513: FOR_IN
91514: IFFALSE 91583
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
91516: LD_ADDR_VAR 0 6
91520: PUSH
91521: LD_VAR 0 1
91525: PPUSH
91526: LD_VAR 0 4
91530: PUSH
91531: LD_INT 1
91533: ARRAY
91534: PPUSH
91535: LD_VAR 0 4
91539: PUSH
91540: LD_INT 2
91542: ARRAY
91543: PPUSH
91544: CALL_OW 297
91548: ST_TO_ADDR
// if tmpDist < dist then
91549: LD_VAR 0 6
91553: PUSH
91554: LD_VAR 0 5
91558: LESS
91559: IFFALSE 91581
// begin result := i ;
91561: LD_ADDR_VAR 0 3
91565: PUSH
91566: LD_VAR 0 4
91570: ST_TO_ADDR
// dist := tmpDist ;
91571: LD_ADDR_VAR 0 5
91575: PUSH
91576: LD_VAR 0 6
91580: ST_TO_ADDR
// end ; end ;
91581: GO 91513
91583: POP
91584: POP
// end ;
91585: LD_VAR 0 3
91589: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
91590: LD_INT 0
91592: PPUSH
// uc_side := side ;
91593: LD_ADDR_OWVAR 20
91597: PUSH
91598: LD_VAR 0 1
91602: ST_TO_ADDR
// uc_nation := 3 ;
91603: LD_ADDR_OWVAR 21
91607: PUSH
91608: LD_INT 3
91610: ST_TO_ADDR
// vc_chassis := 25 ;
91611: LD_ADDR_OWVAR 37
91615: PUSH
91616: LD_INT 25
91618: ST_TO_ADDR
// vc_engine := engine_siberite ;
91619: LD_ADDR_OWVAR 39
91623: PUSH
91624: LD_INT 3
91626: ST_TO_ADDR
// vc_control := control_computer ;
91627: LD_ADDR_OWVAR 38
91631: PUSH
91632: LD_INT 3
91634: ST_TO_ADDR
// vc_weapon := 59 ;
91635: LD_ADDR_OWVAR 40
91639: PUSH
91640: LD_INT 59
91642: ST_TO_ADDR
// result := CreateVehicle ;
91643: LD_ADDR_VAR 0 5
91647: PUSH
91648: CALL_OW 45
91652: ST_TO_ADDR
// SetDir ( result , d ) ;
91653: LD_VAR 0 5
91657: PPUSH
91658: LD_VAR 0 4
91662: PPUSH
91663: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
91667: LD_VAR 0 5
91671: PPUSH
91672: LD_VAR 0 2
91676: PPUSH
91677: LD_VAR 0 3
91681: PPUSH
91682: LD_INT 0
91684: PPUSH
91685: CALL_OW 48
// end ;
91689: LD_VAR 0 5
91693: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
91694: LD_INT 0
91696: PPUSH
91697: PPUSH
91698: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
91699: LD_ADDR_VAR 0 2
91703: PUSH
91704: LD_INT 0
91706: PUSH
91707: LD_INT 0
91709: PUSH
91710: LD_INT 0
91712: PUSH
91713: LD_INT 0
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
91722: LD_VAR 0 1
91726: NOT
91727: IFTRUE 91760
91729: PUSH
91730: LD_VAR 0 1
91734: PPUSH
91735: CALL_OW 264
91739: PUSH
91740: LD_INT 12
91742: PUSH
91743: LD_INT 51
91745: PUSH
91746: LD_INT 32
91748: PUSH
91749: LD_INT 89
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: IN
91758: NOT
91759: OR
91760: IFFALSE 91764
// exit ;
91762: GO 91862
// for i := 1 to 3 do
91764: LD_ADDR_VAR 0 3
91768: PUSH
91769: DOUBLE
91770: LD_INT 1
91772: DEC
91773: ST_TO_ADDR
91774: LD_INT 3
91776: PUSH
91777: FOR_TO
91778: IFFALSE 91860
// begin tmp := GetCargo ( cargo , i ) ;
91780: LD_ADDR_VAR 0 4
91784: PUSH
91785: LD_VAR 0 1
91789: PPUSH
91790: LD_VAR 0 3
91794: PPUSH
91795: CALL_OW 289
91799: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
91800: LD_ADDR_VAR 0 2
91804: PUSH
91805: LD_VAR 0 2
91809: PPUSH
91810: LD_VAR 0 3
91814: PPUSH
91815: LD_VAR 0 4
91819: PPUSH
91820: CALL_OW 1
91824: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
91825: LD_ADDR_VAR 0 2
91829: PUSH
91830: LD_VAR 0 2
91834: PPUSH
91835: LD_INT 4
91837: PPUSH
91838: LD_VAR 0 2
91842: PUSH
91843: LD_INT 4
91845: ARRAY
91846: PUSH
91847: LD_VAR 0 4
91851: PLUS
91852: PPUSH
91853: CALL_OW 1
91857: ST_TO_ADDR
// end ;
91858: GO 91777
91860: POP
91861: POP
// end ;
91862: LD_VAR 0 2
91866: RET
// export function Length ( array ) ; begin
91867: LD_INT 0
91869: PPUSH
// result := array + 0 ;
91870: LD_ADDR_VAR 0 2
91874: PUSH
91875: LD_VAR 0 1
91879: PUSH
91880: LD_INT 0
91882: PLUS
91883: ST_TO_ADDR
// end ;
91884: LD_VAR 0 2
91888: RET
// export function PrepareArray ( array ) ; begin
91889: LD_INT 0
91891: PPUSH
// result := array diff 0 ;
91892: LD_ADDR_VAR 0 2
91896: PUSH
91897: LD_VAR 0 1
91901: PUSH
91902: LD_INT 0
91904: DIFF
91905: ST_TO_ADDR
// if not result [ 1 ] then
91906: LD_VAR 0 2
91910: PUSH
91911: LD_INT 1
91913: ARRAY
91914: NOT
91915: IFFALSE 91935
// result := Delete ( result , 1 ) ;
91917: LD_ADDR_VAR 0 2
91921: PUSH
91922: LD_VAR 0 2
91926: PPUSH
91927: LD_INT 1
91929: PPUSH
91930: CALL_OW 3
91934: ST_TO_ADDR
// end ;
91935: LD_VAR 0 2
91939: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
91940: LD_INT 0
91942: PPUSH
91943: PPUSH
91944: PPUSH
91945: PPUSH
// sibRocketRange := 25 ;
91946: LD_ADDR_VAR 0 6
91950: PUSH
91951: LD_INT 25
91953: ST_TO_ADDR
// result := false ;
91954: LD_ADDR_VAR 0 4
91958: PUSH
91959: LD_INT 0
91961: ST_TO_ADDR
// for i := 0 to 5 do
91962: LD_ADDR_VAR 0 5
91966: PUSH
91967: DOUBLE
91968: LD_INT 0
91970: DEC
91971: ST_TO_ADDR
91972: LD_INT 5
91974: PUSH
91975: FOR_TO
91976: IFFALSE 92043
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
91978: LD_VAR 0 1
91982: PPUSH
91983: LD_VAR 0 5
91987: PPUSH
91988: LD_VAR 0 6
91992: PPUSH
91993: CALL_OW 272
91997: PPUSH
91998: LD_VAR 0 2
92002: PPUSH
92003: LD_VAR 0 5
92007: PPUSH
92008: LD_VAR 0 6
92012: PPUSH
92013: CALL_OW 273
92017: PPUSH
92018: LD_VAR 0 3
92022: PPUSH
92023: CALL_OW 309
92027: IFFALSE 92041
// begin result := true ;
92029: LD_ADDR_VAR 0 4
92033: PUSH
92034: LD_INT 1
92036: ST_TO_ADDR
// exit ;
92037: POP
92038: POP
92039: GO 92045
// end ;
92041: GO 91975
92043: POP
92044: POP
// end ;
92045: LD_VAR 0 4
92049: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
92050: LD_INT 0
92052: PPUSH
92053: PPUSH
92054: PPUSH
// if btype = b_depot then
92055: LD_VAR 0 2
92059: PUSH
92060: LD_INT 0
92062: EQUAL
92063: IFFALSE 92075
// begin result := true ;
92065: LD_ADDR_VAR 0 3
92069: PUSH
92070: LD_INT 1
92072: ST_TO_ADDR
// exit ;
92073: GO 92195
// end ; pom := GetBase ( depot ) ;
92075: LD_ADDR_VAR 0 4
92079: PUSH
92080: LD_VAR 0 1
92084: PPUSH
92085: CALL_OW 274
92089: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
92090: LD_ADDR_VAR 0 5
92094: PUSH
92095: LD_VAR 0 2
92099: PPUSH
92100: LD_VAR 0 1
92104: PPUSH
92105: CALL_OW 248
92109: PPUSH
92110: CALL_OW 450
92114: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
92115: LD_ADDR_VAR 0 3
92119: PUSH
92120: LD_VAR 0 4
92124: PPUSH
92125: LD_INT 1
92127: PPUSH
92128: CALL_OW 275
92132: PUSH
92133: LD_VAR 0 5
92137: PUSH
92138: LD_INT 1
92140: ARRAY
92141: GREATEREQUAL
92142: IFFALSE 92168
92144: PUSH
92145: LD_VAR 0 4
92149: PPUSH
92150: LD_INT 2
92152: PPUSH
92153: CALL_OW 275
92157: PUSH
92158: LD_VAR 0 5
92162: PUSH
92163: LD_INT 2
92165: ARRAY
92166: GREATEREQUAL
92167: AND
92168: IFFALSE 92194
92170: PUSH
92171: LD_VAR 0 4
92175: PPUSH
92176: LD_INT 3
92178: PPUSH
92179: CALL_OW 275
92183: PUSH
92184: LD_VAR 0 5
92188: PUSH
92189: LD_INT 3
92191: ARRAY
92192: GREATEREQUAL
92193: AND
92194: ST_TO_ADDR
// end ;
92195: LD_VAR 0 3
92199: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
92200: LD_INT 0
92202: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
92203: LD_VAR 0 1
92207: PPUSH
92208: LD_VAR 0 2
92212: PPUSH
92213: LD_INT 0
92215: PPUSH
92216: LD_INT 0
92218: PPUSH
92219: LD_INT 1
92221: PPUSH
92222: LD_INT 0
92224: PPUSH
92225: CALL_OW 587
// end ;
92229: LD_VAR 0 3
92233: RET
// export function CenterOnNow ( unit ) ; begin
92234: LD_INT 0
92236: PPUSH
// result := IsInUnit ( unit ) ;
92237: LD_ADDR_VAR 0 2
92241: PUSH
92242: LD_VAR 0 1
92246: PPUSH
92247: CALL_OW 310
92251: ST_TO_ADDR
// if not result then
92252: LD_VAR 0 2
92256: NOT
92257: IFFALSE 92269
// result := unit ;
92259: LD_ADDR_VAR 0 2
92263: PUSH
92264: LD_VAR 0 1
92268: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
92269: LD_VAR 0 1
92273: PPUSH
92274: CALL_OW 87
// end ;
92278: LD_VAR 0 2
92282: RET
// export function ComMoveHex ( unit , hex ) ; begin
92283: LD_INT 0
92285: PPUSH
// if not hex then
92286: LD_VAR 0 2
92290: NOT
92291: IFFALSE 92295
// exit ;
92293: GO 92348
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
92295: LD_VAR 0 2
92299: PUSH
92300: LD_INT 1
92302: ARRAY
92303: PPUSH
92304: LD_VAR 0 2
92308: PUSH
92309: LD_INT 2
92311: ARRAY
92312: PPUSH
92313: CALL_OW 428
92317: IFFALSE 92321
// exit ;
92319: GO 92348
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
92321: LD_VAR 0 1
92325: PPUSH
92326: LD_VAR 0 2
92330: PUSH
92331: LD_INT 1
92333: ARRAY
92334: PPUSH
92335: LD_VAR 0 2
92339: PUSH
92340: LD_INT 2
92342: ARRAY
92343: PPUSH
92344: CALL_OW 111
// end ;
92348: LD_VAR 0 3
92352: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
92353: LD_INT 0
92355: PPUSH
92356: PPUSH
92357: PPUSH
// if not unit or not enemy then
92358: LD_VAR 0 1
92362: NOT
92363: IFTRUE 92372
92365: PUSH
92366: LD_VAR 0 2
92370: NOT
92371: OR
92372: IFFALSE 92376
// exit ;
92374: GO 92502
// x := GetX ( enemy ) ;
92376: LD_ADDR_VAR 0 4
92380: PUSH
92381: LD_VAR 0 2
92385: PPUSH
92386: CALL_OW 250
92390: ST_TO_ADDR
// y := GetY ( enemy ) ;
92391: LD_ADDR_VAR 0 5
92395: PUSH
92396: LD_VAR 0 2
92400: PPUSH
92401: CALL_OW 251
92405: ST_TO_ADDR
// if ValidHex ( x , y ) then
92406: LD_VAR 0 4
92410: PPUSH
92411: LD_VAR 0 5
92415: PPUSH
92416: CALL_OW 488
92420: IFFALSE 92502
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
92422: LD_VAR 0 2
92426: PPUSH
92427: CALL_OW 247
92431: PUSH
92432: LD_INT 3
92434: PUSH
92435: LD_INT 2
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: IN
92442: IFTRUE 92465
92444: PUSH
92445: LD_VAR 0 1
92449: PPUSH
92450: CALL_OW 255
92454: PPUSH
92455: LD_VAR 0 2
92459: PPUSH
92460: CALL_OW 292
92464: OR
92465: IFFALSE 92483
// ComAttackUnit ( unit , enemy ) else
92467: LD_VAR 0 1
92471: PPUSH
92472: LD_VAR 0 2
92476: PPUSH
92477: CALL_OW 115
92481: GO 92502
// ComAgressiveMove ( unit , x , y ) ;
92483: LD_VAR 0 1
92487: PPUSH
92488: LD_VAR 0 4
92492: PPUSH
92493: LD_VAR 0 5
92497: PPUSH
92498: CALL_OW 114
// end ;
92502: LD_VAR 0 3
92506: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
92507: LD_INT 0
92509: PPUSH
92510: PPUSH
92511: PPUSH
// list := AreaToList ( area , 0 ) ;
92512: LD_ADDR_VAR 0 5
92516: PUSH
92517: LD_VAR 0 1
92521: PPUSH
92522: LD_INT 0
92524: PPUSH
92525: CALL_OW 517
92529: ST_TO_ADDR
// if not list then
92530: LD_VAR 0 5
92534: NOT
92535: IFFALSE 92539
// exit ;
92537: GO 92669
// if all then
92539: LD_VAR 0 2
92543: IFFALSE 92631
// begin for i := 1 to list [ 1 ] do
92545: LD_ADDR_VAR 0 4
92549: PUSH
92550: DOUBLE
92551: LD_INT 1
92553: DEC
92554: ST_TO_ADDR
92555: LD_VAR 0 5
92559: PUSH
92560: LD_INT 1
92562: ARRAY
92563: PUSH
92564: FOR_TO
92565: IFFALSE 92627
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
92567: LD_ADDR_VAR 0 3
92571: PUSH
92572: LD_VAR 0 3
92576: PPUSH
92577: LD_VAR 0 3
92581: PUSH
92582: LD_INT 1
92584: PLUS
92585: PPUSH
92586: LD_VAR 0 5
92590: PUSH
92591: LD_INT 1
92593: ARRAY
92594: PUSH
92595: LD_VAR 0 4
92599: ARRAY
92600: PUSH
92601: LD_VAR 0 5
92605: PUSH
92606: LD_INT 2
92608: ARRAY
92609: PUSH
92610: LD_VAR 0 4
92614: ARRAY
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PPUSH
92620: CALL_OW 1
92624: ST_TO_ADDR
92625: GO 92564
92627: POP
92628: POP
// exit ;
92629: GO 92669
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
92631: LD_ADDR_VAR 0 3
92635: PUSH
92636: LD_VAR 0 5
92640: PUSH
92641: LD_INT 1
92643: ARRAY
92644: PUSH
92645: LD_INT 1
92647: ARRAY
92648: PUSH
92649: LD_VAR 0 5
92653: PUSH
92654: LD_INT 2
92656: ARRAY
92657: PUSH
92658: LD_INT 1
92660: ARRAY
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: PUSH
92666: EMPTY
92667: LIST
92668: ST_TO_ADDR
// end ;
92669: LD_VAR 0 3
92673: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
92674: LD_INT 0
92676: PPUSH
92677: PPUSH
// list := AreaToList ( area , 0 ) ;
92678: LD_ADDR_VAR 0 4
92682: PUSH
92683: LD_VAR 0 1
92687: PPUSH
92688: LD_INT 0
92690: PPUSH
92691: CALL_OW 517
92695: ST_TO_ADDR
// if not list then
92696: LD_VAR 0 4
92700: NOT
92701: IFFALSE 92705
// exit ;
92703: GO 92746
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
92705: LD_ADDR_VAR 0 3
92709: PUSH
92710: LD_VAR 0 4
92714: PUSH
92715: LD_INT 1
92717: ARRAY
92718: PUSH
92719: LD_INT 1
92721: ARRAY
92722: PUSH
92723: LD_VAR 0 4
92727: PUSH
92728: LD_INT 2
92730: ARRAY
92731: PUSH
92732: LD_INT 1
92734: ARRAY
92735: PUSH
92736: LD_VAR 0 2
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: LIST
92745: ST_TO_ADDR
// end ;
92746: LD_VAR 0 3
92750: RET
// export function First ( array ) ; begin
92751: LD_INT 0
92753: PPUSH
// if not array then
92754: LD_VAR 0 1
92758: NOT
92759: IFFALSE 92763
// exit ;
92761: GO 92777
// result := array [ 1 ] ;
92763: LD_ADDR_VAR 0 2
92767: PUSH
92768: LD_VAR 0 1
92772: PUSH
92773: LD_INT 1
92775: ARRAY
92776: ST_TO_ADDR
// end ;
92777: LD_VAR 0 2
92781: RET
// export function Last ( array ) ; begin
92782: LD_INT 0
92784: PPUSH
// if not array then
92785: LD_VAR 0 1
92789: NOT
92790: IFFALSE 92794
// exit ;
92792: GO 92810
// result := array [ array ] ;
92794: LD_ADDR_VAR 0 2
92798: PUSH
92799: LD_VAR 0 1
92803: PUSH
92804: LD_VAR 0 1
92808: ARRAY
92809: ST_TO_ADDR
// end ;
92810: LD_VAR 0 2
92814: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
92815: LD_INT 0
92817: PPUSH
92818: PPUSH
// result := [ ] ;
92819: LD_ADDR_VAR 0 5
92823: PUSH
92824: EMPTY
92825: ST_TO_ADDR
// if not array then
92826: LD_VAR 0 1
92830: NOT
92831: IFFALSE 92835
// exit ;
92833: GO 92947
// for i := 1 to array do
92835: LD_ADDR_VAR 0 6
92839: PUSH
92840: DOUBLE
92841: LD_INT 1
92843: DEC
92844: ST_TO_ADDR
92845: LD_VAR 0 1
92849: PUSH
92850: FOR_TO
92851: IFFALSE 92945
// if array [ i ] [ index ] = value then
92853: LD_VAR 0 1
92857: PUSH
92858: LD_VAR 0 6
92862: ARRAY
92863: PUSH
92864: LD_VAR 0 2
92868: ARRAY
92869: PUSH
92870: LD_VAR 0 3
92874: EQUAL
92875: IFFALSE 92943
// begin if indexColumn then
92877: LD_VAR 0 4
92881: IFFALSE 92917
// result := Join ( result , array [ i ] [ indexColumn ] ) else
92883: LD_ADDR_VAR 0 5
92887: PUSH
92888: LD_VAR 0 5
92892: PPUSH
92893: LD_VAR 0 1
92897: PUSH
92898: LD_VAR 0 6
92902: ARRAY
92903: PUSH
92904: LD_VAR 0 4
92908: ARRAY
92909: PPUSH
92910: CALL 87955 0 2
92914: ST_TO_ADDR
92915: GO 92943
// result := Join ( result , array [ i ] ) ;
92917: LD_ADDR_VAR 0 5
92921: PUSH
92922: LD_VAR 0 5
92926: PPUSH
92927: LD_VAR 0 1
92931: PUSH
92932: LD_VAR 0 6
92936: ARRAY
92937: PPUSH
92938: CALL 87955 0 2
92942: ST_TO_ADDR
// end ;
92943: GO 92850
92945: POP
92946: POP
// end ;
92947: LD_VAR 0 5
92951: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
92952: LD_INT 0
92954: PPUSH
// if not vehicles or not parkingPoint then
92955: LD_VAR 0 1
92959: NOT
92960: IFTRUE 92969
92962: PUSH
92963: LD_VAR 0 2
92967: NOT
92968: OR
92969: IFFALSE 92973
// exit ;
92971: GO 93071
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
92973: LD_ADDR_VAR 0 1
92977: PUSH
92978: LD_VAR 0 1
92982: PPUSH
92983: LD_INT 50
92985: PUSH
92986: EMPTY
92987: LIST
92988: PUSH
92989: LD_INT 3
92991: PUSH
92992: LD_INT 92
92994: PUSH
92995: LD_VAR 0 2
92999: PUSH
93000: LD_INT 1
93002: ARRAY
93003: PUSH
93004: LD_VAR 0 2
93008: PUSH
93009: LD_INT 2
93011: ARRAY
93012: PUSH
93013: LD_INT 8
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PPUSH
93030: CALL_OW 72
93034: ST_TO_ADDR
// if not vehicles then
93035: LD_VAR 0 1
93039: NOT
93040: IFFALSE 93044
// exit ;
93042: GO 93071
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
93044: LD_VAR 0 1
93048: PPUSH
93049: LD_VAR 0 2
93053: PUSH
93054: LD_INT 1
93056: ARRAY
93057: PPUSH
93058: LD_VAR 0 2
93062: PUSH
93063: LD_INT 2
93065: ARRAY
93066: PPUSH
93067: CALL_OW 111
// end ;
93071: LD_VAR 0 3
93075: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
93076: LD_INT 0
93078: PPUSH
93079: PPUSH
93080: PPUSH
// if not side or not area then
93081: LD_VAR 0 1
93085: NOT
93086: IFTRUE 93095
93088: PUSH
93089: LD_VAR 0 2
93093: NOT
93094: OR
93095: IFFALSE 93099
// exit ;
93097: GO 93218
// tmp := AreaToList ( area , 0 ) ;
93099: LD_ADDR_VAR 0 5
93103: PUSH
93104: LD_VAR 0 2
93108: PPUSH
93109: LD_INT 0
93111: PPUSH
93112: CALL_OW 517
93116: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
93117: LD_ADDR_VAR 0 4
93121: PUSH
93122: DOUBLE
93123: LD_INT 1
93125: DEC
93126: ST_TO_ADDR
93127: LD_VAR 0 5
93131: PUSH
93132: LD_INT 1
93134: ARRAY
93135: PUSH
93136: FOR_TO
93137: IFFALSE 93216
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
93139: LD_VAR 0 5
93143: PUSH
93144: LD_INT 1
93146: ARRAY
93147: PUSH
93148: LD_VAR 0 4
93152: ARRAY
93153: PPUSH
93154: LD_VAR 0 5
93158: PUSH
93159: LD_INT 2
93161: ARRAY
93162: PUSH
93163: LD_VAR 0 4
93167: ARRAY
93168: PPUSH
93169: CALL_OW 351
93173: IFFALSE 93214
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
93175: LD_VAR 0 5
93179: PUSH
93180: LD_INT 1
93182: ARRAY
93183: PUSH
93184: LD_VAR 0 4
93188: ARRAY
93189: PPUSH
93190: LD_VAR 0 5
93194: PUSH
93195: LD_INT 2
93197: ARRAY
93198: PUSH
93199: LD_VAR 0 4
93203: ARRAY
93204: PPUSH
93205: LD_VAR 0 1
93209: PPUSH
93210: CALL_OW 244
// end ;
93214: GO 93136
93216: POP
93217: POP
// end ;
93218: LD_VAR 0 3
93222: RET
// export function UniqueArray ( array ) ; var i ; begin
93223: LD_INT 0
93225: PPUSH
93226: PPUSH
// result := [ ] ;
93227: LD_ADDR_VAR 0 2
93231: PUSH
93232: EMPTY
93233: ST_TO_ADDR
// if not array then
93234: LD_VAR 0 1
93238: NOT
93239: IFFALSE 93243
// exit ;
93241: GO 93304
// for i := 1 to array do
93243: LD_ADDR_VAR 0 3
93247: PUSH
93248: DOUBLE
93249: LD_INT 1
93251: DEC
93252: ST_TO_ADDR
93253: LD_VAR 0 1
93257: PUSH
93258: FOR_TO
93259: IFFALSE 93302
// if not array [ i ] in result then
93261: LD_VAR 0 1
93265: PUSH
93266: LD_VAR 0 3
93270: ARRAY
93271: PUSH
93272: LD_VAR 0 2
93276: IN
93277: NOT
93278: IFFALSE 93300
// result := Join ( result , i ) ;
93280: LD_ADDR_VAR 0 2
93284: PUSH
93285: LD_VAR 0 2
93289: PPUSH
93290: LD_VAR 0 3
93294: PPUSH
93295: CALL 87955 0 2
93299: ST_TO_ADDR
93300: GO 93258
93302: POP
93303: POP
// end ; end_of_file end_of_file
93304: LD_VAR 0 2
93308: RET
// export globalGameSaveCounter ; every 0 0$1 do
93309: GO 93311
93311: DISABLE
// begin enable ;
93312: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93313: LD_STRING updateTimer(
93315: PUSH
93316: LD_OWVAR 1
93320: STR
93321: PUSH
93322: LD_STRING );
93324: STR
93325: PPUSH
93326: CALL_OW 559
// end ;
93330: END
// every 0 0$1 do
93331: GO 93333
93333: DISABLE
// begin globalGameSaveCounter := 0 ;
93334: LD_ADDR_EXP 95
93338: PUSH
93339: LD_INT 0
93341: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93342: LD_STRING setGameSaveCounter(0)
93344: PPUSH
93345: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93349: LD_STRING initStreamRollete();
93351: PPUSH
93352: CALL_OW 559
// InitStreamMode ;
93356: CALL 94701 0 0
// DefineStreamItems ( false ) ;
93360: LD_INT 0
93362: PPUSH
93363: CALL 95165 0 1
// end ;
93367: END
// export function SOS_MapStart ( ) ; begin
93368: LD_INT 0
93370: PPUSH
// if streamModeActive then
93371: LD_EXP 96
93375: IFFALSE 93384
// DefineStreamItems ( true ) ;
93377: LD_INT 1
93379: PPUSH
93380: CALL 95165 0 1
// UpdateLuaVariables ( ) ;
93384: CALL 93401 0 0
// UpdateFactoryWaypoints ( ) ;
93388: CALL 108287 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93392: CALL 108539 0 0
// end ;
93396: LD_VAR 0 1
93400: RET
// function UpdateLuaVariables ( ) ; begin
93401: LD_INT 0
93403: PPUSH
// if globalGameSaveCounter then
93404: LD_EXP 95
93408: IFFALSE 93442
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93410: LD_ADDR_EXP 95
93414: PUSH
93415: LD_EXP 95
93419: PPUSH
93420: CALL 89328 0 1
93424: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93425: LD_STRING setGameSaveCounter(
93427: PUSH
93428: LD_EXP 95
93432: STR
93433: PUSH
93434: LD_STRING )
93436: STR
93437: PPUSH
93438: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93442: LD_STRING setGameDifficulty(
93444: PUSH
93445: LD_OWVAR 67
93449: STR
93450: PUSH
93451: LD_STRING )
93453: STR
93454: PPUSH
93455: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
93459: LD_STRING displayDifficulty(
93461: PUSH
93462: LD_OWVAR 67
93466: STR
93467: PUSH
93468: LD_STRING )
93470: STR
93471: PPUSH
93472: CALL_OW 559
// end ;
93476: LD_VAR 0 1
93480: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93481: LD_INT 0
93483: PPUSH
// if p2 = stream_mode then
93484: LD_VAR 0 2
93488: PUSH
93489: LD_INT 100
93491: EQUAL
93492: IFFALSE 94495
// begin if not StreamModeActive then
93494: LD_EXP 96
93498: NOT
93499: IFFALSE 93509
// StreamModeActive := true ;
93501: LD_ADDR_EXP 96
93505: PUSH
93506: LD_INT 1
93508: ST_TO_ADDR
// if p3 = 0 then
93509: LD_VAR 0 3
93513: PUSH
93514: LD_INT 0
93516: EQUAL
93517: IFFALSE 93523
// InitStreamMode ;
93519: CALL 94701 0 0
// if p3 = 1 then
93523: LD_VAR 0 3
93527: PUSH
93528: LD_INT 1
93530: EQUAL
93531: IFFALSE 93541
// sRocket := true ;
93533: LD_ADDR_EXP 101
93537: PUSH
93538: LD_INT 1
93540: ST_TO_ADDR
// if p3 = 2 then
93541: LD_VAR 0 3
93545: PUSH
93546: LD_INT 2
93548: EQUAL
93549: IFFALSE 93559
// sSpeed := true ;
93551: LD_ADDR_EXP 100
93555: PUSH
93556: LD_INT 1
93558: ST_TO_ADDR
// if p3 = 3 then
93559: LD_VAR 0 3
93563: PUSH
93564: LD_INT 3
93566: EQUAL
93567: IFFALSE 93577
// sEngine := true ;
93569: LD_ADDR_EXP 102
93573: PUSH
93574: LD_INT 1
93576: ST_TO_ADDR
// if p3 = 4 then
93577: LD_VAR 0 3
93581: PUSH
93582: LD_INT 4
93584: EQUAL
93585: IFFALSE 93595
// sSpec := true ;
93587: LD_ADDR_EXP 99
93591: PUSH
93592: LD_INT 1
93594: ST_TO_ADDR
// if p3 = 5 then
93595: LD_VAR 0 3
93599: PUSH
93600: LD_INT 5
93602: EQUAL
93603: IFFALSE 93613
// sLevel := true ;
93605: LD_ADDR_EXP 103
93609: PUSH
93610: LD_INT 1
93612: ST_TO_ADDR
// if p3 = 6 then
93613: LD_VAR 0 3
93617: PUSH
93618: LD_INT 6
93620: EQUAL
93621: IFFALSE 93631
// sArmoury := true ;
93623: LD_ADDR_EXP 104
93627: PUSH
93628: LD_INT 1
93630: ST_TO_ADDR
// if p3 = 7 then
93631: LD_VAR 0 3
93635: PUSH
93636: LD_INT 7
93638: EQUAL
93639: IFFALSE 93649
// sRadar := true ;
93641: LD_ADDR_EXP 105
93645: PUSH
93646: LD_INT 1
93648: ST_TO_ADDR
// if p3 = 8 then
93649: LD_VAR 0 3
93653: PUSH
93654: LD_INT 8
93656: EQUAL
93657: IFFALSE 93667
// sBunker := true ;
93659: LD_ADDR_EXP 106
93663: PUSH
93664: LD_INT 1
93666: ST_TO_ADDR
// if p3 = 9 then
93667: LD_VAR 0 3
93671: PUSH
93672: LD_INT 9
93674: EQUAL
93675: IFFALSE 93685
// sHack := true ;
93677: LD_ADDR_EXP 107
93681: PUSH
93682: LD_INT 1
93684: ST_TO_ADDR
// if p3 = 10 then
93685: LD_VAR 0 3
93689: PUSH
93690: LD_INT 10
93692: EQUAL
93693: IFFALSE 93703
// sFire := true ;
93695: LD_ADDR_EXP 108
93699: PUSH
93700: LD_INT 1
93702: ST_TO_ADDR
// if p3 = 11 then
93703: LD_VAR 0 3
93707: PUSH
93708: LD_INT 11
93710: EQUAL
93711: IFFALSE 93721
// sRefresh := true ;
93713: LD_ADDR_EXP 109
93717: PUSH
93718: LD_INT 1
93720: ST_TO_ADDR
// if p3 = 12 then
93721: LD_VAR 0 3
93725: PUSH
93726: LD_INT 12
93728: EQUAL
93729: IFFALSE 93739
// sExp := true ;
93731: LD_ADDR_EXP 110
93735: PUSH
93736: LD_INT 1
93738: ST_TO_ADDR
// if p3 = 13 then
93739: LD_VAR 0 3
93743: PUSH
93744: LD_INT 13
93746: EQUAL
93747: IFFALSE 93757
// sDepot := true ;
93749: LD_ADDR_EXP 111
93753: PUSH
93754: LD_INT 1
93756: ST_TO_ADDR
// if p3 = 14 then
93757: LD_VAR 0 3
93761: PUSH
93762: LD_INT 14
93764: EQUAL
93765: IFFALSE 93775
// sFlag := true ;
93767: LD_ADDR_EXP 112
93771: PUSH
93772: LD_INT 1
93774: ST_TO_ADDR
// if p3 = 15 then
93775: LD_VAR 0 3
93779: PUSH
93780: LD_INT 15
93782: EQUAL
93783: IFFALSE 93793
// sKamikadze := true ;
93785: LD_ADDR_EXP 120
93789: PUSH
93790: LD_INT 1
93792: ST_TO_ADDR
// if p3 = 16 then
93793: LD_VAR 0 3
93797: PUSH
93798: LD_INT 16
93800: EQUAL
93801: IFFALSE 93811
// sTroll := true ;
93803: LD_ADDR_EXP 121
93807: PUSH
93808: LD_INT 1
93810: ST_TO_ADDR
// if p3 = 17 then
93811: LD_VAR 0 3
93815: PUSH
93816: LD_INT 17
93818: EQUAL
93819: IFFALSE 93829
// sSlow := true ;
93821: LD_ADDR_EXP 122
93825: PUSH
93826: LD_INT 1
93828: ST_TO_ADDR
// if p3 = 18 then
93829: LD_VAR 0 3
93833: PUSH
93834: LD_INT 18
93836: EQUAL
93837: IFFALSE 93847
// sLack := true ;
93839: LD_ADDR_EXP 123
93843: PUSH
93844: LD_INT 1
93846: ST_TO_ADDR
// if p3 = 19 then
93847: LD_VAR 0 3
93851: PUSH
93852: LD_INT 19
93854: EQUAL
93855: IFFALSE 93865
// sTank := true ;
93857: LD_ADDR_EXP 125
93861: PUSH
93862: LD_INT 1
93864: ST_TO_ADDR
// if p3 = 20 then
93865: LD_VAR 0 3
93869: PUSH
93870: LD_INT 20
93872: EQUAL
93873: IFFALSE 93883
// sRemote := true ;
93875: LD_ADDR_EXP 126
93879: PUSH
93880: LD_INT 1
93882: ST_TO_ADDR
// if p3 = 21 then
93883: LD_VAR 0 3
93887: PUSH
93888: LD_INT 21
93890: EQUAL
93891: IFFALSE 93901
// sPowell := true ;
93893: LD_ADDR_EXP 127
93897: PUSH
93898: LD_INT 1
93900: ST_TO_ADDR
// if p3 = 22 then
93901: LD_VAR 0 3
93905: PUSH
93906: LD_INT 22
93908: EQUAL
93909: IFFALSE 93919
// sTeleport := true ;
93911: LD_ADDR_EXP 130
93915: PUSH
93916: LD_INT 1
93918: ST_TO_ADDR
// if p3 = 23 then
93919: LD_VAR 0 3
93923: PUSH
93924: LD_INT 23
93926: EQUAL
93927: IFFALSE 93937
// sOilTower := true ;
93929: LD_ADDR_EXP 132
93933: PUSH
93934: LD_INT 1
93936: ST_TO_ADDR
// if p3 = 24 then
93937: LD_VAR 0 3
93941: PUSH
93942: LD_INT 24
93944: EQUAL
93945: IFFALSE 93955
// sShovel := true ;
93947: LD_ADDR_EXP 133
93951: PUSH
93952: LD_INT 1
93954: ST_TO_ADDR
// if p3 = 25 then
93955: LD_VAR 0 3
93959: PUSH
93960: LD_INT 25
93962: EQUAL
93963: IFFALSE 93973
// sSheik := true ;
93965: LD_ADDR_EXP 134
93969: PUSH
93970: LD_INT 1
93972: ST_TO_ADDR
// if p3 = 26 then
93973: LD_VAR 0 3
93977: PUSH
93978: LD_INT 26
93980: EQUAL
93981: IFFALSE 93991
// sEarthquake := true ;
93983: LD_ADDR_EXP 136
93987: PUSH
93988: LD_INT 1
93990: ST_TO_ADDR
// if p3 = 27 then
93991: LD_VAR 0 3
93995: PUSH
93996: LD_INT 27
93998: EQUAL
93999: IFFALSE 94009
// sAI := true ;
94001: LD_ADDR_EXP 137
94005: PUSH
94006: LD_INT 1
94008: ST_TO_ADDR
// if p3 = 28 then
94009: LD_VAR 0 3
94013: PUSH
94014: LD_INT 28
94016: EQUAL
94017: IFFALSE 94027
// sCargo := true ;
94019: LD_ADDR_EXP 140
94023: PUSH
94024: LD_INT 1
94026: ST_TO_ADDR
// if p3 = 29 then
94027: LD_VAR 0 3
94031: PUSH
94032: LD_INT 29
94034: EQUAL
94035: IFFALSE 94045
// sDLaser := true ;
94037: LD_ADDR_EXP 141
94041: PUSH
94042: LD_INT 1
94044: ST_TO_ADDR
// if p3 = 30 then
94045: LD_VAR 0 3
94049: PUSH
94050: LD_INT 30
94052: EQUAL
94053: IFFALSE 94063
// sExchange := true ;
94055: LD_ADDR_EXP 142
94059: PUSH
94060: LD_INT 1
94062: ST_TO_ADDR
// if p3 = 31 then
94063: LD_VAR 0 3
94067: PUSH
94068: LD_INT 31
94070: EQUAL
94071: IFFALSE 94081
// sFac := true ;
94073: LD_ADDR_EXP 143
94077: PUSH
94078: LD_INT 1
94080: ST_TO_ADDR
// if p3 = 32 then
94081: LD_VAR 0 3
94085: PUSH
94086: LD_INT 32
94088: EQUAL
94089: IFFALSE 94099
// sPower := true ;
94091: LD_ADDR_EXP 144
94095: PUSH
94096: LD_INT 1
94098: ST_TO_ADDR
// if p3 = 33 then
94099: LD_VAR 0 3
94103: PUSH
94104: LD_INT 33
94106: EQUAL
94107: IFFALSE 94117
// sRandom := true ;
94109: LD_ADDR_EXP 145
94113: PUSH
94114: LD_INT 1
94116: ST_TO_ADDR
// if p3 = 34 then
94117: LD_VAR 0 3
94121: PUSH
94122: LD_INT 34
94124: EQUAL
94125: IFFALSE 94135
// sShield := true ;
94127: LD_ADDR_EXP 146
94131: PUSH
94132: LD_INT 1
94134: ST_TO_ADDR
// if p3 = 35 then
94135: LD_VAR 0 3
94139: PUSH
94140: LD_INT 35
94142: EQUAL
94143: IFFALSE 94153
// sTime := true ;
94145: LD_ADDR_EXP 147
94149: PUSH
94150: LD_INT 1
94152: ST_TO_ADDR
// if p3 = 36 then
94153: LD_VAR 0 3
94157: PUSH
94158: LD_INT 36
94160: EQUAL
94161: IFFALSE 94171
// sTools := true ;
94163: LD_ADDR_EXP 148
94167: PUSH
94168: LD_INT 1
94170: ST_TO_ADDR
// if p3 = 101 then
94171: LD_VAR 0 3
94175: PUSH
94176: LD_INT 101
94178: EQUAL
94179: IFFALSE 94189
// sSold := true ;
94181: LD_ADDR_EXP 113
94185: PUSH
94186: LD_INT 1
94188: ST_TO_ADDR
// if p3 = 102 then
94189: LD_VAR 0 3
94193: PUSH
94194: LD_INT 102
94196: EQUAL
94197: IFFALSE 94207
// sDiff := true ;
94199: LD_ADDR_EXP 114
94203: PUSH
94204: LD_INT 1
94206: ST_TO_ADDR
// if p3 = 103 then
94207: LD_VAR 0 3
94211: PUSH
94212: LD_INT 103
94214: EQUAL
94215: IFFALSE 94225
// sFog := true ;
94217: LD_ADDR_EXP 117
94221: PUSH
94222: LD_INT 1
94224: ST_TO_ADDR
// if p3 = 104 then
94225: LD_VAR 0 3
94229: PUSH
94230: LD_INT 104
94232: EQUAL
94233: IFFALSE 94243
// sReset := true ;
94235: LD_ADDR_EXP 118
94239: PUSH
94240: LD_INT 1
94242: ST_TO_ADDR
// if p3 = 105 then
94243: LD_VAR 0 3
94247: PUSH
94248: LD_INT 105
94250: EQUAL
94251: IFFALSE 94261
// sSun := true ;
94253: LD_ADDR_EXP 119
94257: PUSH
94258: LD_INT 1
94260: ST_TO_ADDR
// if p3 = 106 then
94261: LD_VAR 0 3
94265: PUSH
94266: LD_INT 106
94268: EQUAL
94269: IFFALSE 94279
// sTiger := true ;
94271: LD_ADDR_EXP 115
94275: PUSH
94276: LD_INT 1
94278: ST_TO_ADDR
// if p3 = 107 then
94279: LD_VAR 0 3
94283: PUSH
94284: LD_INT 107
94286: EQUAL
94287: IFFALSE 94297
// sBomb := true ;
94289: LD_ADDR_EXP 116
94293: PUSH
94294: LD_INT 1
94296: ST_TO_ADDR
// if p3 = 108 then
94297: LD_VAR 0 3
94301: PUSH
94302: LD_INT 108
94304: EQUAL
94305: IFFALSE 94315
// sWound := true ;
94307: LD_ADDR_EXP 124
94311: PUSH
94312: LD_INT 1
94314: ST_TO_ADDR
// if p3 = 109 then
94315: LD_VAR 0 3
94319: PUSH
94320: LD_INT 109
94322: EQUAL
94323: IFFALSE 94333
// sBetray := true ;
94325: LD_ADDR_EXP 128
94329: PUSH
94330: LD_INT 1
94332: ST_TO_ADDR
// if p3 = 110 then
94333: LD_VAR 0 3
94337: PUSH
94338: LD_INT 110
94340: EQUAL
94341: IFFALSE 94351
// sContamin := true ;
94343: LD_ADDR_EXP 129
94347: PUSH
94348: LD_INT 1
94350: ST_TO_ADDR
// if p3 = 111 then
94351: LD_VAR 0 3
94355: PUSH
94356: LD_INT 111
94358: EQUAL
94359: IFFALSE 94369
// sOil := true ;
94361: LD_ADDR_EXP 131
94365: PUSH
94366: LD_INT 1
94368: ST_TO_ADDR
// if p3 = 112 then
94369: LD_VAR 0 3
94373: PUSH
94374: LD_INT 112
94376: EQUAL
94377: IFFALSE 94387
// sStu := true ;
94379: LD_ADDR_EXP 135
94383: PUSH
94384: LD_INT 1
94386: ST_TO_ADDR
// if p3 = 113 then
94387: LD_VAR 0 3
94391: PUSH
94392: LD_INT 113
94394: EQUAL
94395: IFFALSE 94405
// sBazooka := true ;
94397: LD_ADDR_EXP 138
94401: PUSH
94402: LD_INT 1
94404: ST_TO_ADDR
// if p3 = 114 then
94405: LD_VAR 0 3
94409: PUSH
94410: LD_INT 114
94412: EQUAL
94413: IFFALSE 94423
// sMortar := true ;
94415: LD_ADDR_EXP 139
94419: PUSH
94420: LD_INT 1
94422: ST_TO_ADDR
// if p3 = 115 then
94423: LD_VAR 0 3
94427: PUSH
94428: LD_INT 115
94430: EQUAL
94431: IFFALSE 94441
// sRanger := true ;
94433: LD_ADDR_EXP 149
94437: PUSH
94438: LD_INT 1
94440: ST_TO_ADDR
// if p3 = 116 then
94441: LD_VAR 0 3
94445: PUSH
94446: LD_INT 116
94448: EQUAL
94449: IFFALSE 94459
// sComputer := true ;
94451: LD_ADDR_EXP 150
94455: PUSH
94456: LD_INT 1
94458: ST_TO_ADDR
// if p3 = 117 then
94459: LD_VAR 0 3
94463: PUSH
94464: LD_INT 117
94466: EQUAL
94467: IFFALSE 94477
// s30 := true ;
94469: LD_ADDR_EXP 151
94473: PUSH
94474: LD_INT 1
94476: ST_TO_ADDR
// if p3 = 118 then
94477: LD_VAR 0 3
94481: PUSH
94482: LD_INT 118
94484: EQUAL
94485: IFFALSE 94495
// s60 := true ;
94487: LD_ADDR_EXP 152
94491: PUSH
94492: LD_INT 1
94494: ST_TO_ADDR
// end ; if p2 = hack_mode then
94495: LD_VAR 0 2
94499: PUSH
94500: LD_INT 101
94502: EQUAL
94503: IFFALSE 94631
// begin case p3 of 1 :
94505: LD_VAR 0 3
94509: PUSH
94510: LD_INT 1
94512: DOUBLE
94513: EQUAL
94514: IFTRUE 94518
94516: GO 94525
94518: POP
// hHackUnlimitedResources ; 2 :
94519: CALL 106894 0 0
94523: GO 94631
94525: LD_INT 2
94527: DOUBLE
94528: EQUAL
94529: IFTRUE 94533
94531: GO 94540
94533: POP
// hHackSetLevel10 ; 3 :
94534: CALL 107027 0 0
94538: GO 94631
94540: LD_INT 3
94542: DOUBLE
94543: EQUAL
94544: IFTRUE 94548
94546: GO 94555
94548: POP
// hHackSetLevel10YourUnits ; 4 :
94549: CALL 107112 0 0
94553: GO 94631
94555: LD_INT 4
94557: DOUBLE
94558: EQUAL
94559: IFTRUE 94563
94561: GO 94570
94563: POP
// hHackInvincible ; 5 :
94564: CALL 107560 0 0
94568: GO 94631
94570: LD_INT 5
94572: DOUBLE
94573: EQUAL
94574: IFTRUE 94578
94576: GO 94585
94578: POP
// hHackInvisible ; 6 :
94579: CALL 107671 0 0
94583: GO 94631
94585: LD_INT 6
94587: DOUBLE
94588: EQUAL
94589: IFTRUE 94593
94591: GO 94600
94593: POP
// hHackChangeYourSide ; 7 :
94594: CALL 107728 0 0
94598: GO 94631
94600: LD_INT 7
94602: DOUBLE
94603: EQUAL
94604: IFTRUE 94608
94606: GO 94615
94608: POP
// hHackChangeUnitSide ; 8 :
94609: CALL 107770 0 0
94613: GO 94631
94615: LD_INT 8
94617: DOUBLE
94618: EQUAL
94619: IFTRUE 94623
94621: GO 94630
94623: POP
// hHackFog ; end ;
94624: CALL 107871 0 0
94628: GO 94631
94630: POP
// end ; if p2 = game_save_mode then
94631: LD_VAR 0 2
94635: PUSH
94636: LD_INT 102
94638: EQUAL
94639: IFFALSE 94696
// begin if p3 = 1 then
94641: LD_VAR 0 3
94645: PUSH
94646: LD_INT 1
94648: EQUAL
94649: IFFALSE 94661
// globalGameSaveCounter := p4 ;
94651: LD_ADDR_EXP 95
94655: PUSH
94656: LD_VAR 0 4
94660: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
94661: LD_VAR 0 3
94665: PUSH
94666: LD_INT 2
94668: EQUAL
94669: IFFALSE 94677
94671: PUSH
94672: LD_EXP 95
94676: AND
94677: IFFALSE 94696
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94679: LD_STRING setGameSaveCounter(
94681: PUSH
94682: LD_EXP 95
94686: STR
94687: PUSH
94688: LD_STRING )
94690: STR
94691: PPUSH
94692: CALL_OW 559
// end ; end ;
94696: LD_VAR 0 7
94700: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
94701: LD_INT 0
94703: PPUSH
// streamModeActive := false ;
94704: LD_ADDR_EXP 96
94708: PUSH
94709: LD_INT 0
94711: ST_TO_ADDR
// normalCounter := 36 ;
94712: LD_ADDR_EXP 97
94716: PUSH
94717: LD_INT 36
94719: ST_TO_ADDR
// hardcoreCounter := 18 ;
94720: LD_ADDR_EXP 98
94724: PUSH
94725: LD_INT 18
94727: ST_TO_ADDR
// sRocket := false ;
94728: LD_ADDR_EXP 101
94732: PUSH
94733: LD_INT 0
94735: ST_TO_ADDR
// sSpeed := false ;
94736: LD_ADDR_EXP 100
94740: PUSH
94741: LD_INT 0
94743: ST_TO_ADDR
// sEngine := false ;
94744: LD_ADDR_EXP 102
94748: PUSH
94749: LD_INT 0
94751: ST_TO_ADDR
// sSpec := false ;
94752: LD_ADDR_EXP 99
94756: PUSH
94757: LD_INT 0
94759: ST_TO_ADDR
// sLevel := false ;
94760: LD_ADDR_EXP 103
94764: PUSH
94765: LD_INT 0
94767: ST_TO_ADDR
// sArmoury := false ;
94768: LD_ADDR_EXP 104
94772: PUSH
94773: LD_INT 0
94775: ST_TO_ADDR
// sRadar := false ;
94776: LD_ADDR_EXP 105
94780: PUSH
94781: LD_INT 0
94783: ST_TO_ADDR
// sBunker := false ;
94784: LD_ADDR_EXP 106
94788: PUSH
94789: LD_INT 0
94791: ST_TO_ADDR
// sHack := false ;
94792: LD_ADDR_EXP 107
94796: PUSH
94797: LD_INT 0
94799: ST_TO_ADDR
// sFire := false ;
94800: LD_ADDR_EXP 108
94804: PUSH
94805: LD_INT 0
94807: ST_TO_ADDR
// sRefresh := false ;
94808: LD_ADDR_EXP 109
94812: PUSH
94813: LD_INT 0
94815: ST_TO_ADDR
// sExp := false ;
94816: LD_ADDR_EXP 110
94820: PUSH
94821: LD_INT 0
94823: ST_TO_ADDR
// sDepot := false ;
94824: LD_ADDR_EXP 111
94828: PUSH
94829: LD_INT 0
94831: ST_TO_ADDR
// sFlag := false ;
94832: LD_ADDR_EXP 112
94836: PUSH
94837: LD_INT 0
94839: ST_TO_ADDR
// sKamikadze := false ;
94840: LD_ADDR_EXP 120
94844: PUSH
94845: LD_INT 0
94847: ST_TO_ADDR
// sTroll := false ;
94848: LD_ADDR_EXP 121
94852: PUSH
94853: LD_INT 0
94855: ST_TO_ADDR
// sSlow := false ;
94856: LD_ADDR_EXP 122
94860: PUSH
94861: LD_INT 0
94863: ST_TO_ADDR
// sLack := false ;
94864: LD_ADDR_EXP 123
94868: PUSH
94869: LD_INT 0
94871: ST_TO_ADDR
// sTank := false ;
94872: LD_ADDR_EXP 125
94876: PUSH
94877: LD_INT 0
94879: ST_TO_ADDR
// sRemote := false ;
94880: LD_ADDR_EXP 126
94884: PUSH
94885: LD_INT 0
94887: ST_TO_ADDR
// sPowell := false ;
94888: LD_ADDR_EXP 127
94892: PUSH
94893: LD_INT 0
94895: ST_TO_ADDR
// sTeleport := false ;
94896: LD_ADDR_EXP 130
94900: PUSH
94901: LD_INT 0
94903: ST_TO_ADDR
// sOilTower := false ;
94904: LD_ADDR_EXP 132
94908: PUSH
94909: LD_INT 0
94911: ST_TO_ADDR
// sShovel := false ;
94912: LD_ADDR_EXP 133
94916: PUSH
94917: LD_INT 0
94919: ST_TO_ADDR
// sSheik := false ;
94920: LD_ADDR_EXP 134
94924: PUSH
94925: LD_INT 0
94927: ST_TO_ADDR
// sEarthquake := false ;
94928: LD_ADDR_EXP 136
94932: PUSH
94933: LD_INT 0
94935: ST_TO_ADDR
// sAI := false ;
94936: LD_ADDR_EXP 137
94940: PUSH
94941: LD_INT 0
94943: ST_TO_ADDR
// sCargo := false ;
94944: LD_ADDR_EXP 140
94948: PUSH
94949: LD_INT 0
94951: ST_TO_ADDR
// sDLaser := false ;
94952: LD_ADDR_EXP 141
94956: PUSH
94957: LD_INT 0
94959: ST_TO_ADDR
// sExchange := false ;
94960: LD_ADDR_EXP 142
94964: PUSH
94965: LD_INT 0
94967: ST_TO_ADDR
// sFac := false ;
94968: LD_ADDR_EXP 143
94972: PUSH
94973: LD_INT 0
94975: ST_TO_ADDR
// sPower := false ;
94976: LD_ADDR_EXP 144
94980: PUSH
94981: LD_INT 0
94983: ST_TO_ADDR
// sRandom := false ;
94984: LD_ADDR_EXP 145
94988: PUSH
94989: LD_INT 0
94991: ST_TO_ADDR
// sShield := false ;
94992: LD_ADDR_EXP 146
94996: PUSH
94997: LD_INT 0
94999: ST_TO_ADDR
// sTime := false ;
95000: LD_ADDR_EXP 147
95004: PUSH
95005: LD_INT 0
95007: ST_TO_ADDR
// sTools := false ;
95008: LD_ADDR_EXP 148
95012: PUSH
95013: LD_INT 0
95015: ST_TO_ADDR
// sSold := false ;
95016: LD_ADDR_EXP 113
95020: PUSH
95021: LD_INT 0
95023: ST_TO_ADDR
// sDiff := false ;
95024: LD_ADDR_EXP 114
95028: PUSH
95029: LD_INT 0
95031: ST_TO_ADDR
// sFog := false ;
95032: LD_ADDR_EXP 117
95036: PUSH
95037: LD_INT 0
95039: ST_TO_ADDR
// sReset := false ;
95040: LD_ADDR_EXP 118
95044: PUSH
95045: LD_INT 0
95047: ST_TO_ADDR
// sSun := false ;
95048: LD_ADDR_EXP 119
95052: PUSH
95053: LD_INT 0
95055: ST_TO_ADDR
// sTiger := false ;
95056: LD_ADDR_EXP 115
95060: PUSH
95061: LD_INT 0
95063: ST_TO_ADDR
// sBomb := false ;
95064: LD_ADDR_EXP 116
95068: PUSH
95069: LD_INT 0
95071: ST_TO_ADDR
// sWound := false ;
95072: LD_ADDR_EXP 124
95076: PUSH
95077: LD_INT 0
95079: ST_TO_ADDR
// sBetray := false ;
95080: LD_ADDR_EXP 128
95084: PUSH
95085: LD_INT 0
95087: ST_TO_ADDR
// sContamin := false ;
95088: LD_ADDR_EXP 129
95092: PUSH
95093: LD_INT 0
95095: ST_TO_ADDR
// sOil := false ;
95096: LD_ADDR_EXP 131
95100: PUSH
95101: LD_INT 0
95103: ST_TO_ADDR
// sStu := false ;
95104: LD_ADDR_EXP 135
95108: PUSH
95109: LD_INT 0
95111: ST_TO_ADDR
// sBazooka := false ;
95112: LD_ADDR_EXP 138
95116: PUSH
95117: LD_INT 0
95119: ST_TO_ADDR
// sMortar := false ;
95120: LD_ADDR_EXP 139
95124: PUSH
95125: LD_INT 0
95127: ST_TO_ADDR
// sRanger := false ;
95128: LD_ADDR_EXP 149
95132: PUSH
95133: LD_INT 0
95135: ST_TO_ADDR
// sComputer := false ;
95136: LD_ADDR_EXP 150
95140: PUSH
95141: LD_INT 0
95143: ST_TO_ADDR
// s30 := false ;
95144: LD_ADDR_EXP 151
95148: PUSH
95149: LD_INT 0
95151: ST_TO_ADDR
// s60 := false ;
95152: LD_ADDR_EXP 152
95156: PUSH
95157: LD_INT 0
95159: ST_TO_ADDR
// end ;
95160: LD_VAR 0 1
95164: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95165: LD_INT 0
95167: PPUSH
95168: PPUSH
95169: PPUSH
95170: PPUSH
95171: PPUSH
95172: PPUSH
95173: PPUSH
// result := [ ] ;
95174: LD_ADDR_VAR 0 2
95178: PUSH
95179: EMPTY
95180: ST_TO_ADDR
// if campaign_id = 1 then
95181: LD_OWVAR 69
95185: PUSH
95186: LD_INT 1
95188: EQUAL
95189: IFFALSE 98355
// begin case mission_number of 1 :
95191: LD_OWVAR 70
95195: PUSH
95196: LD_INT 1
95198: DOUBLE
95199: EQUAL
95200: IFTRUE 95204
95202: GO 95280
95204: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95205: LD_ADDR_VAR 0 2
95209: PUSH
95210: LD_INT 2
95212: PUSH
95213: LD_INT 4
95215: PUSH
95216: LD_INT 11
95218: PUSH
95219: LD_INT 12
95221: PUSH
95222: LD_INT 15
95224: PUSH
95225: LD_INT 16
95227: PUSH
95228: LD_INT 22
95230: PUSH
95231: LD_INT 23
95233: PUSH
95234: LD_INT 26
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 101
95250: PUSH
95251: LD_INT 102
95253: PUSH
95254: LD_INT 106
95256: PUSH
95257: LD_INT 116
95259: PUSH
95260: LD_INT 117
95262: PUSH
95263: LD_INT 118
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: ST_TO_ADDR
95278: GO 98353
95280: LD_INT 2
95282: DOUBLE
95283: EQUAL
95284: IFTRUE 95288
95286: GO 95372
95288: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95289: LD_ADDR_VAR 0 2
95293: PUSH
95294: LD_INT 2
95296: PUSH
95297: LD_INT 4
95299: PUSH
95300: LD_INT 11
95302: PUSH
95303: LD_INT 12
95305: PUSH
95306: LD_INT 15
95308: PUSH
95309: LD_INT 16
95311: PUSH
95312: LD_INT 22
95314: PUSH
95315: LD_INT 23
95317: PUSH
95318: LD_INT 26
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 101
95334: PUSH
95335: LD_INT 102
95337: PUSH
95338: LD_INT 105
95340: PUSH
95341: LD_INT 106
95343: PUSH
95344: LD_INT 108
95346: PUSH
95347: LD_INT 116
95349: PUSH
95350: LD_INT 117
95352: PUSH
95353: LD_INT 118
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: ST_TO_ADDR
95370: GO 98353
95372: LD_INT 3
95374: DOUBLE
95375: EQUAL
95376: IFTRUE 95380
95378: GO 95468
95380: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95381: LD_ADDR_VAR 0 2
95385: PUSH
95386: LD_INT 2
95388: PUSH
95389: LD_INT 4
95391: PUSH
95392: LD_INT 5
95394: PUSH
95395: LD_INT 11
95397: PUSH
95398: LD_INT 12
95400: PUSH
95401: LD_INT 15
95403: PUSH
95404: LD_INT 16
95406: PUSH
95407: LD_INT 22
95409: PUSH
95410: LD_INT 26
95412: PUSH
95413: LD_INT 36
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 101
95430: PUSH
95431: LD_INT 102
95433: PUSH
95434: LD_INT 105
95436: PUSH
95437: LD_INT 106
95439: PUSH
95440: LD_INT 108
95442: PUSH
95443: LD_INT 116
95445: PUSH
95446: LD_INT 117
95448: PUSH
95449: LD_INT 118
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: ST_TO_ADDR
95466: GO 98353
95468: LD_INT 4
95470: DOUBLE
95471: EQUAL
95472: IFTRUE 95476
95474: GO 95572
95476: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95477: LD_ADDR_VAR 0 2
95481: PUSH
95482: LD_INT 2
95484: PUSH
95485: LD_INT 4
95487: PUSH
95488: LD_INT 5
95490: PUSH
95491: LD_INT 8
95493: PUSH
95494: LD_INT 11
95496: PUSH
95497: LD_INT 12
95499: PUSH
95500: LD_INT 15
95502: PUSH
95503: LD_INT 16
95505: PUSH
95506: LD_INT 22
95508: PUSH
95509: LD_INT 23
95511: PUSH
95512: LD_INT 26
95514: PUSH
95515: LD_INT 36
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 101
95534: PUSH
95535: LD_INT 102
95537: PUSH
95538: LD_INT 105
95540: PUSH
95541: LD_INT 106
95543: PUSH
95544: LD_INT 108
95546: PUSH
95547: LD_INT 116
95549: PUSH
95550: LD_INT 117
95552: PUSH
95553: LD_INT 118
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: PUSH
95566: EMPTY
95567: LIST
95568: LIST
95569: ST_TO_ADDR
95570: GO 98353
95572: LD_INT 5
95574: DOUBLE
95575: EQUAL
95576: IFTRUE 95580
95578: GO 95692
95580: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95581: LD_ADDR_VAR 0 2
95585: PUSH
95586: LD_INT 2
95588: PUSH
95589: LD_INT 4
95591: PUSH
95592: LD_INT 5
95594: PUSH
95595: LD_INT 6
95597: PUSH
95598: LD_INT 8
95600: PUSH
95601: LD_INT 11
95603: PUSH
95604: LD_INT 12
95606: PUSH
95607: LD_INT 15
95609: PUSH
95610: LD_INT 16
95612: PUSH
95613: LD_INT 22
95615: PUSH
95616: LD_INT 23
95618: PUSH
95619: LD_INT 25
95621: PUSH
95622: LD_INT 26
95624: PUSH
95625: LD_INT 36
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: PUSH
95644: LD_INT 101
95646: PUSH
95647: LD_INT 102
95649: PUSH
95650: LD_INT 105
95652: PUSH
95653: LD_INT 106
95655: PUSH
95656: LD_INT 108
95658: PUSH
95659: LD_INT 109
95661: PUSH
95662: LD_INT 112
95664: PUSH
95665: LD_INT 116
95667: PUSH
95668: LD_INT 117
95670: PUSH
95671: LD_INT 118
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: ST_TO_ADDR
95690: GO 98353
95692: LD_INT 6
95694: DOUBLE
95695: EQUAL
95696: IFTRUE 95700
95698: GO 95832
95700: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95701: LD_ADDR_VAR 0 2
95705: PUSH
95706: LD_INT 2
95708: PUSH
95709: LD_INT 4
95711: PUSH
95712: LD_INT 5
95714: PUSH
95715: LD_INT 6
95717: PUSH
95718: LD_INT 8
95720: PUSH
95721: LD_INT 11
95723: PUSH
95724: LD_INT 12
95726: PUSH
95727: LD_INT 15
95729: PUSH
95730: LD_INT 16
95732: PUSH
95733: LD_INT 20
95735: PUSH
95736: LD_INT 21
95738: PUSH
95739: LD_INT 22
95741: PUSH
95742: LD_INT 23
95744: PUSH
95745: LD_INT 25
95747: PUSH
95748: LD_INT 26
95750: PUSH
95751: LD_INT 30
95753: PUSH
95754: LD_INT 31
95756: PUSH
95757: LD_INT 32
95759: PUSH
95760: LD_INT 36
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 101
95786: PUSH
95787: LD_INT 102
95789: PUSH
95790: LD_INT 105
95792: PUSH
95793: LD_INT 106
95795: PUSH
95796: LD_INT 108
95798: PUSH
95799: LD_INT 109
95801: PUSH
95802: LD_INT 112
95804: PUSH
95805: LD_INT 116
95807: PUSH
95808: LD_INT 117
95810: PUSH
95811: LD_INT 118
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: ST_TO_ADDR
95830: GO 98353
95832: LD_INT 7
95834: DOUBLE
95835: EQUAL
95836: IFTRUE 95840
95838: GO 95952
95840: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95841: LD_ADDR_VAR 0 2
95845: PUSH
95846: LD_INT 2
95848: PUSH
95849: LD_INT 4
95851: PUSH
95852: LD_INT 5
95854: PUSH
95855: LD_INT 7
95857: PUSH
95858: LD_INT 11
95860: PUSH
95861: LD_INT 12
95863: PUSH
95864: LD_INT 15
95866: PUSH
95867: LD_INT 16
95869: PUSH
95870: LD_INT 20
95872: PUSH
95873: LD_INT 21
95875: PUSH
95876: LD_INT 22
95878: PUSH
95879: LD_INT 23
95881: PUSH
95882: LD_INT 25
95884: PUSH
95885: LD_INT 26
95887: PUSH
95888: EMPTY
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 101
95906: PUSH
95907: LD_INT 102
95909: PUSH
95910: LD_INT 103
95912: PUSH
95913: LD_INT 105
95915: PUSH
95916: LD_INT 106
95918: PUSH
95919: LD_INT 108
95921: PUSH
95922: LD_INT 112
95924: PUSH
95925: LD_INT 116
95927: PUSH
95928: LD_INT 117
95930: PUSH
95931: LD_INT 118
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: PUSH
95946: EMPTY
95947: LIST
95948: LIST
95949: ST_TO_ADDR
95950: GO 98353
95952: LD_INT 8
95954: DOUBLE
95955: EQUAL
95956: IFTRUE 95960
95958: GO 96100
95960: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95961: LD_ADDR_VAR 0 2
95965: PUSH
95966: LD_INT 2
95968: PUSH
95969: LD_INT 4
95971: PUSH
95972: LD_INT 5
95974: PUSH
95975: LD_INT 6
95977: PUSH
95978: LD_INT 7
95980: PUSH
95981: LD_INT 8
95983: PUSH
95984: LD_INT 11
95986: PUSH
95987: LD_INT 12
95989: PUSH
95990: LD_INT 15
95992: PUSH
95993: LD_INT 16
95995: PUSH
95996: LD_INT 20
95998: PUSH
95999: LD_INT 21
96001: PUSH
96002: LD_INT 22
96004: PUSH
96005: LD_INT 23
96007: PUSH
96008: LD_INT 25
96010: PUSH
96011: LD_INT 26
96013: PUSH
96014: LD_INT 30
96016: PUSH
96017: LD_INT 31
96019: PUSH
96020: LD_INT 32
96022: PUSH
96023: LD_INT 36
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: PUSH
96048: LD_INT 101
96050: PUSH
96051: LD_INT 102
96053: PUSH
96054: LD_INT 103
96056: PUSH
96057: LD_INT 105
96059: PUSH
96060: LD_INT 106
96062: PUSH
96063: LD_INT 108
96065: PUSH
96066: LD_INT 109
96068: PUSH
96069: LD_INT 112
96071: PUSH
96072: LD_INT 116
96074: PUSH
96075: LD_INT 117
96077: PUSH
96078: LD_INT 118
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: ST_TO_ADDR
96098: GO 98353
96100: LD_INT 9
96102: DOUBLE
96103: EQUAL
96104: IFTRUE 96108
96106: GO 96256
96108: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96109: LD_ADDR_VAR 0 2
96113: PUSH
96114: LD_INT 2
96116: PUSH
96117: LD_INT 4
96119: PUSH
96120: LD_INT 5
96122: PUSH
96123: LD_INT 6
96125: PUSH
96126: LD_INT 7
96128: PUSH
96129: LD_INT 8
96131: PUSH
96132: LD_INT 11
96134: PUSH
96135: LD_INT 12
96137: PUSH
96138: LD_INT 15
96140: PUSH
96141: LD_INT 16
96143: PUSH
96144: LD_INT 20
96146: PUSH
96147: LD_INT 21
96149: PUSH
96150: LD_INT 22
96152: PUSH
96153: LD_INT 23
96155: PUSH
96156: LD_INT 25
96158: PUSH
96159: LD_INT 26
96161: PUSH
96162: LD_INT 28
96164: PUSH
96165: LD_INT 30
96167: PUSH
96168: LD_INT 31
96170: PUSH
96171: LD_INT 32
96173: PUSH
96174: LD_INT 36
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 101
96202: PUSH
96203: LD_INT 102
96205: PUSH
96206: LD_INT 103
96208: PUSH
96209: LD_INT 105
96211: PUSH
96212: LD_INT 106
96214: PUSH
96215: LD_INT 108
96217: PUSH
96218: LD_INT 109
96220: PUSH
96221: LD_INT 112
96223: PUSH
96224: LD_INT 114
96226: PUSH
96227: LD_INT 116
96229: PUSH
96230: LD_INT 117
96232: PUSH
96233: LD_INT 118
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: LIST
96240: LIST
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: PUSH
96250: EMPTY
96251: LIST
96252: LIST
96253: ST_TO_ADDR
96254: GO 98353
96256: LD_INT 10
96258: DOUBLE
96259: EQUAL
96260: IFTRUE 96264
96262: GO 96460
96264: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96265: LD_ADDR_VAR 0 2
96269: PUSH
96270: LD_INT 2
96272: PUSH
96273: LD_INT 4
96275: PUSH
96276: LD_INT 5
96278: PUSH
96279: LD_INT 6
96281: PUSH
96282: LD_INT 7
96284: PUSH
96285: LD_INT 8
96287: PUSH
96288: LD_INT 9
96290: PUSH
96291: LD_INT 10
96293: PUSH
96294: LD_INT 11
96296: PUSH
96297: LD_INT 12
96299: PUSH
96300: LD_INT 13
96302: PUSH
96303: LD_INT 14
96305: PUSH
96306: LD_INT 15
96308: PUSH
96309: LD_INT 16
96311: PUSH
96312: LD_INT 17
96314: PUSH
96315: LD_INT 18
96317: PUSH
96318: LD_INT 19
96320: PUSH
96321: LD_INT 20
96323: PUSH
96324: LD_INT 21
96326: PUSH
96327: LD_INT 22
96329: PUSH
96330: LD_INT 23
96332: PUSH
96333: LD_INT 24
96335: PUSH
96336: LD_INT 25
96338: PUSH
96339: LD_INT 26
96341: PUSH
96342: LD_INT 28
96344: PUSH
96345: LD_INT 30
96347: PUSH
96348: LD_INT 31
96350: PUSH
96351: LD_INT 32
96353: PUSH
96354: LD_INT 36
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: PUSH
96388: LD_INT 101
96390: PUSH
96391: LD_INT 102
96393: PUSH
96394: LD_INT 103
96396: PUSH
96397: LD_INT 104
96399: PUSH
96400: LD_INT 105
96402: PUSH
96403: LD_INT 106
96405: PUSH
96406: LD_INT 107
96408: PUSH
96409: LD_INT 108
96411: PUSH
96412: LD_INT 109
96414: PUSH
96415: LD_INT 110
96417: PUSH
96418: LD_INT 111
96420: PUSH
96421: LD_INT 112
96423: PUSH
96424: LD_INT 114
96426: PUSH
96427: LD_INT 116
96429: PUSH
96430: LD_INT 117
96432: PUSH
96433: LD_INT 118
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: ST_TO_ADDR
96458: GO 98353
96460: LD_INT 11
96462: DOUBLE
96463: EQUAL
96464: IFTRUE 96468
96466: GO 96672
96468: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96469: LD_ADDR_VAR 0 2
96473: PUSH
96474: LD_INT 2
96476: PUSH
96477: LD_INT 3
96479: PUSH
96480: LD_INT 4
96482: PUSH
96483: LD_INT 5
96485: PUSH
96486: LD_INT 6
96488: PUSH
96489: LD_INT 7
96491: PUSH
96492: LD_INT 8
96494: PUSH
96495: LD_INT 9
96497: PUSH
96498: LD_INT 10
96500: PUSH
96501: LD_INT 11
96503: PUSH
96504: LD_INT 12
96506: PUSH
96507: LD_INT 13
96509: PUSH
96510: LD_INT 14
96512: PUSH
96513: LD_INT 15
96515: PUSH
96516: LD_INT 16
96518: PUSH
96519: LD_INT 17
96521: PUSH
96522: LD_INT 18
96524: PUSH
96525: LD_INT 19
96527: PUSH
96528: LD_INT 20
96530: PUSH
96531: LD_INT 21
96533: PUSH
96534: LD_INT 22
96536: PUSH
96537: LD_INT 23
96539: PUSH
96540: LD_INT 24
96542: PUSH
96543: LD_INT 25
96545: PUSH
96546: LD_INT 26
96548: PUSH
96549: LD_INT 28
96551: PUSH
96552: LD_INT 30
96554: PUSH
96555: LD_INT 31
96557: PUSH
96558: LD_INT 32
96560: PUSH
96561: LD_INT 34
96563: PUSH
96564: LD_INT 36
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: PUSH
96600: LD_INT 101
96602: PUSH
96603: LD_INT 102
96605: PUSH
96606: LD_INT 103
96608: PUSH
96609: LD_INT 104
96611: PUSH
96612: LD_INT 105
96614: PUSH
96615: LD_INT 106
96617: PUSH
96618: LD_INT 107
96620: PUSH
96621: LD_INT 108
96623: PUSH
96624: LD_INT 109
96626: PUSH
96627: LD_INT 110
96629: PUSH
96630: LD_INT 111
96632: PUSH
96633: LD_INT 112
96635: PUSH
96636: LD_INT 114
96638: PUSH
96639: LD_INT 116
96641: PUSH
96642: LD_INT 117
96644: PUSH
96645: LD_INT 118
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: ST_TO_ADDR
96670: GO 98353
96672: LD_INT 12
96674: DOUBLE
96675: EQUAL
96676: IFTRUE 96680
96678: GO 96900
96680: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96681: LD_ADDR_VAR 0 2
96685: PUSH
96686: LD_INT 1
96688: PUSH
96689: LD_INT 2
96691: PUSH
96692: LD_INT 3
96694: PUSH
96695: LD_INT 4
96697: PUSH
96698: LD_INT 5
96700: PUSH
96701: LD_INT 6
96703: PUSH
96704: LD_INT 7
96706: PUSH
96707: LD_INT 8
96709: PUSH
96710: LD_INT 9
96712: PUSH
96713: LD_INT 10
96715: PUSH
96716: LD_INT 11
96718: PUSH
96719: LD_INT 12
96721: PUSH
96722: LD_INT 13
96724: PUSH
96725: LD_INT 14
96727: PUSH
96728: LD_INT 15
96730: PUSH
96731: LD_INT 16
96733: PUSH
96734: LD_INT 17
96736: PUSH
96737: LD_INT 18
96739: PUSH
96740: LD_INT 19
96742: PUSH
96743: LD_INT 20
96745: PUSH
96746: LD_INT 21
96748: PUSH
96749: LD_INT 22
96751: PUSH
96752: LD_INT 23
96754: PUSH
96755: LD_INT 24
96757: PUSH
96758: LD_INT 25
96760: PUSH
96761: LD_INT 26
96763: PUSH
96764: LD_INT 27
96766: PUSH
96767: LD_INT 28
96769: PUSH
96770: LD_INT 30
96772: PUSH
96773: LD_INT 31
96775: PUSH
96776: LD_INT 32
96778: PUSH
96779: LD_INT 33
96781: PUSH
96782: LD_INT 34
96784: PUSH
96785: LD_INT 36
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: PUSH
96824: LD_INT 101
96826: PUSH
96827: LD_INT 102
96829: PUSH
96830: LD_INT 103
96832: PUSH
96833: LD_INT 104
96835: PUSH
96836: LD_INT 105
96838: PUSH
96839: LD_INT 106
96841: PUSH
96842: LD_INT 107
96844: PUSH
96845: LD_INT 108
96847: PUSH
96848: LD_INT 109
96850: PUSH
96851: LD_INT 110
96853: PUSH
96854: LD_INT 111
96856: PUSH
96857: LD_INT 112
96859: PUSH
96860: LD_INT 113
96862: PUSH
96863: LD_INT 114
96865: PUSH
96866: LD_INT 116
96868: PUSH
96869: LD_INT 117
96871: PUSH
96872: LD_INT 118
96874: PUSH
96875: EMPTY
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: PUSH
96894: EMPTY
96895: LIST
96896: LIST
96897: ST_TO_ADDR
96898: GO 98353
96900: LD_INT 13
96902: DOUBLE
96903: EQUAL
96904: IFTRUE 96908
96906: GO 97116
96908: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96909: LD_ADDR_VAR 0 2
96913: PUSH
96914: LD_INT 1
96916: PUSH
96917: LD_INT 2
96919: PUSH
96920: LD_INT 3
96922: PUSH
96923: LD_INT 4
96925: PUSH
96926: LD_INT 5
96928: PUSH
96929: LD_INT 8
96931: PUSH
96932: LD_INT 9
96934: PUSH
96935: LD_INT 10
96937: PUSH
96938: LD_INT 11
96940: PUSH
96941: LD_INT 12
96943: PUSH
96944: LD_INT 14
96946: PUSH
96947: LD_INT 15
96949: PUSH
96950: LD_INT 16
96952: PUSH
96953: LD_INT 17
96955: PUSH
96956: LD_INT 18
96958: PUSH
96959: LD_INT 19
96961: PUSH
96962: LD_INT 20
96964: PUSH
96965: LD_INT 21
96967: PUSH
96968: LD_INT 22
96970: PUSH
96971: LD_INT 23
96973: PUSH
96974: LD_INT 24
96976: PUSH
96977: LD_INT 25
96979: PUSH
96980: LD_INT 26
96982: PUSH
96983: LD_INT 27
96985: PUSH
96986: LD_INT 28
96988: PUSH
96989: LD_INT 30
96991: PUSH
96992: LD_INT 31
96994: PUSH
96995: LD_INT 32
96997: PUSH
96998: LD_INT 33
97000: PUSH
97001: LD_INT 34
97003: PUSH
97004: LD_INT 36
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: PUSH
97040: LD_INT 101
97042: PUSH
97043: LD_INT 102
97045: PUSH
97046: LD_INT 103
97048: PUSH
97049: LD_INT 104
97051: PUSH
97052: LD_INT 105
97054: PUSH
97055: LD_INT 106
97057: PUSH
97058: LD_INT 107
97060: PUSH
97061: LD_INT 108
97063: PUSH
97064: LD_INT 109
97066: PUSH
97067: LD_INT 110
97069: PUSH
97070: LD_INT 111
97072: PUSH
97073: LD_INT 112
97075: PUSH
97076: LD_INT 113
97078: PUSH
97079: LD_INT 114
97081: PUSH
97082: LD_INT 116
97084: PUSH
97085: LD_INT 117
97087: PUSH
97088: LD_INT 118
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: ST_TO_ADDR
97114: GO 98353
97116: LD_INT 14
97118: DOUBLE
97119: EQUAL
97120: IFTRUE 97124
97122: GO 97348
97124: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97125: LD_ADDR_VAR 0 2
97129: PUSH
97130: LD_INT 1
97132: PUSH
97133: LD_INT 2
97135: PUSH
97136: LD_INT 3
97138: PUSH
97139: LD_INT 4
97141: PUSH
97142: LD_INT 5
97144: PUSH
97145: LD_INT 6
97147: PUSH
97148: LD_INT 7
97150: PUSH
97151: LD_INT 8
97153: PUSH
97154: LD_INT 9
97156: PUSH
97157: LD_INT 10
97159: PUSH
97160: LD_INT 11
97162: PUSH
97163: LD_INT 12
97165: PUSH
97166: LD_INT 13
97168: PUSH
97169: LD_INT 14
97171: PUSH
97172: LD_INT 15
97174: PUSH
97175: LD_INT 16
97177: PUSH
97178: LD_INT 17
97180: PUSH
97181: LD_INT 18
97183: PUSH
97184: LD_INT 19
97186: PUSH
97187: LD_INT 20
97189: PUSH
97190: LD_INT 21
97192: PUSH
97193: LD_INT 22
97195: PUSH
97196: LD_INT 23
97198: PUSH
97199: LD_INT 24
97201: PUSH
97202: LD_INT 25
97204: PUSH
97205: LD_INT 26
97207: PUSH
97208: LD_INT 27
97210: PUSH
97211: LD_INT 28
97213: PUSH
97214: LD_INT 29
97216: PUSH
97217: LD_INT 30
97219: PUSH
97220: LD_INT 31
97222: PUSH
97223: LD_INT 32
97225: PUSH
97226: LD_INT 33
97228: PUSH
97229: LD_INT 34
97231: PUSH
97232: LD_INT 36
97234: PUSH
97235: EMPTY
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: LIST
97241: LIST
97242: LIST
97243: LIST
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: PUSH
97272: LD_INT 101
97274: PUSH
97275: LD_INT 102
97277: PUSH
97278: LD_INT 103
97280: PUSH
97281: LD_INT 104
97283: PUSH
97284: LD_INT 105
97286: PUSH
97287: LD_INT 106
97289: PUSH
97290: LD_INT 107
97292: PUSH
97293: LD_INT 108
97295: PUSH
97296: LD_INT 109
97298: PUSH
97299: LD_INT 110
97301: PUSH
97302: LD_INT 111
97304: PUSH
97305: LD_INT 112
97307: PUSH
97308: LD_INT 113
97310: PUSH
97311: LD_INT 114
97313: PUSH
97314: LD_INT 116
97316: PUSH
97317: LD_INT 117
97319: PUSH
97320: LD_INT 118
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: ST_TO_ADDR
97346: GO 98353
97348: LD_INT 15
97350: DOUBLE
97351: EQUAL
97352: IFTRUE 97356
97354: GO 97580
97356: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97357: LD_ADDR_VAR 0 2
97361: PUSH
97362: LD_INT 1
97364: PUSH
97365: LD_INT 2
97367: PUSH
97368: LD_INT 3
97370: PUSH
97371: LD_INT 4
97373: PUSH
97374: LD_INT 5
97376: PUSH
97377: LD_INT 6
97379: PUSH
97380: LD_INT 7
97382: PUSH
97383: LD_INT 8
97385: PUSH
97386: LD_INT 9
97388: PUSH
97389: LD_INT 10
97391: PUSH
97392: LD_INT 11
97394: PUSH
97395: LD_INT 12
97397: PUSH
97398: LD_INT 13
97400: PUSH
97401: LD_INT 14
97403: PUSH
97404: LD_INT 15
97406: PUSH
97407: LD_INT 16
97409: PUSH
97410: LD_INT 17
97412: PUSH
97413: LD_INT 18
97415: PUSH
97416: LD_INT 19
97418: PUSH
97419: LD_INT 20
97421: PUSH
97422: LD_INT 21
97424: PUSH
97425: LD_INT 22
97427: PUSH
97428: LD_INT 23
97430: PUSH
97431: LD_INT 24
97433: PUSH
97434: LD_INT 25
97436: PUSH
97437: LD_INT 26
97439: PUSH
97440: LD_INT 27
97442: PUSH
97443: LD_INT 28
97445: PUSH
97446: LD_INT 29
97448: PUSH
97449: LD_INT 30
97451: PUSH
97452: LD_INT 31
97454: PUSH
97455: LD_INT 32
97457: PUSH
97458: LD_INT 33
97460: PUSH
97461: LD_INT 34
97463: PUSH
97464: LD_INT 36
97466: PUSH
97467: EMPTY
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: PUSH
97504: LD_INT 101
97506: PUSH
97507: LD_INT 102
97509: PUSH
97510: LD_INT 103
97512: PUSH
97513: LD_INT 104
97515: PUSH
97516: LD_INT 105
97518: PUSH
97519: LD_INT 106
97521: PUSH
97522: LD_INT 107
97524: PUSH
97525: LD_INT 108
97527: PUSH
97528: LD_INT 109
97530: PUSH
97531: LD_INT 110
97533: PUSH
97534: LD_INT 111
97536: PUSH
97537: LD_INT 112
97539: PUSH
97540: LD_INT 113
97542: PUSH
97543: LD_INT 114
97545: PUSH
97546: LD_INT 116
97548: PUSH
97549: LD_INT 117
97551: PUSH
97552: LD_INT 118
97554: PUSH
97555: EMPTY
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: PUSH
97574: EMPTY
97575: LIST
97576: LIST
97577: ST_TO_ADDR
97578: GO 98353
97580: LD_INT 16
97582: DOUBLE
97583: EQUAL
97584: IFTRUE 97588
97586: GO 97724
97588: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97589: LD_ADDR_VAR 0 2
97593: PUSH
97594: LD_INT 2
97596: PUSH
97597: LD_INT 4
97599: PUSH
97600: LD_INT 5
97602: PUSH
97603: LD_INT 7
97605: PUSH
97606: LD_INT 11
97608: PUSH
97609: LD_INT 12
97611: PUSH
97612: LD_INT 15
97614: PUSH
97615: LD_INT 16
97617: PUSH
97618: LD_INT 20
97620: PUSH
97621: LD_INT 21
97623: PUSH
97624: LD_INT 22
97626: PUSH
97627: LD_INT 23
97629: PUSH
97630: LD_INT 25
97632: PUSH
97633: LD_INT 26
97635: PUSH
97636: LD_INT 30
97638: PUSH
97639: LD_INT 31
97641: PUSH
97642: LD_INT 32
97644: PUSH
97645: LD_INT 33
97647: PUSH
97648: LD_INT 34
97650: PUSH
97651: EMPTY
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: PUSH
97672: LD_INT 101
97674: PUSH
97675: LD_INT 102
97677: PUSH
97678: LD_INT 103
97680: PUSH
97681: LD_INT 106
97683: PUSH
97684: LD_INT 108
97686: PUSH
97687: LD_INT 112
97689: PUSH
97690: LD_INT 113
97692: PUSH
97693: LD_INT 114
97695: PUSH
97696: LD_INT 116
97698: PUSH
97699: LD_INT 117
97701: PUSH
97702: LD_INT 118
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: ST_TO_ADDR
97722: GO 98353
97724: LD_INT 17
97726: DOUBLE
97727: EQUAL
97728: IFTRUE 97732
97730: GO 97956
97732: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97733: LD_ADDR_VAR 0 2
97737: PUSH
97738: LD_INT 1
97740: PUSH
97741: LD_INT 2
97743: PUSH
97744: LD_INT 3
97746: PUSH
97747: LD_INT 4
97749: PUSH
97750: LD_INT 5
97752: PUSH
97753: LD_INT 6
97755: PUSH
97756: LD_INT 7
97758: PUSH
97759: LD_INT 8
97761: PUSH
97762: LD_INT 9
97764: PUSH
97765: LD_INT 10
97767: PUSH
97768: LD_INT 11
97770: PUSH
97771: LD_INT 12
97773: PUSH
97774: LD_INT 13
97776: PUSH
97777: LD_INT 14
97779: PUSH
97780: LD_INT 15
97782: PUSH
97783: LD_INT 16
97785: PUSH
97786: LD_INT 17
97788: PUSH
97789: LD_INT 18
97791: PUSH
97792: LD_INT 19
97794: PUSH
97795: LD_INT 20
97797: PUSH
97798: LD_INT 21
97800: PUSH
97801: LD_INT 22
97803: PUSH
97804: LD_INT 23
97806: PUSH
97807: LD_INT 24
97809: PUSH
97810: LD_INT 25
97812: PUSH
97813: LD_INT 26
97815: PUSH
97816: LD_INT 27
97818: PUSH
97819: LD_INT 28
97821: PUSH
97822: LD_INT 29
97824: PUSH
97825: LD_INT 30
97827: PUSH
97828: LD_INT 31
97830: PUSH
97831: LD_INT 32
97833: PUSH
97834: LD_INT 33
97836: PUSH
97837: LD_INT 34
97839: PUSH
97840: LD_INT 36
97842: PUSH
97843: EMPTY
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: PUSH
97880: LD_INT 101
97882: PUSH
97883: LD_INT 102
97885: PUSH
97886: LD_INT 103
97888: PUSH
97889: LD_INT 104
97891: PUSH
97892: LD_INT 105
97894: PUSH
97895: LD_INT 106
97897: PUSH
97898: LD_INT 107
97900: PUSH
97901: LD_INT 108
97903: PUSH
97904: LD_INT 109
97906: PUSH
97907: LD_INT 110
97909: PUSH
97910: LD_INT 111
97912: PUSH
97913: LD_INT 112
97915: PUSH
97916: LD_INT 113
97918: PUSH
97919: LD_INT 114
97921: PUSH
97922: LD_INT 116
97924: PUSH
97925: LD_INT 117
97927: PUSH
97928: LD_INT 118
97930: PUSH
97931: EMPTY
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: PUSH
97950: EMPTY
97951: LIST
97952: LIST
97953: ST_TO_ADDR
97954: GO 98353
97956: LD_INT 18
97958: DOUBLE
97959: EQUAL
97960: IFTRUE 97964
97962: GO 98112
97964: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97965: LD_ADDR_VAR 0 2
97969: PUSH
97970: LD_INT 2
97972: PUSH
97973: LD_INT 4
97975: PUSH
97976: LD_INT 5
97978: PUSH
97979: LD_INT 7
97981: PUSH
97982: LD_INT 11
97984: PUSH
97985: LD_INT 12
97987: PUSH
97988: LD_INT 15
97990: PUSH
97991: LD_INT 16
97993: PUSH
97994: LD_INT 20
97996: PUSH
97997: LD_INT 21
97999: PUSH
98000: LD_INT 22
98002: PUSH
98003: LD_INT 23
98005: PUSH
98006: LD_INT 25
98008: PUSH
98009: LD_INT 26
98011: PUSH
98012: LD_INT 30
98014: PUSH
98015: LD_INT 31
98017: PUSH
98018: LD_INT 32
98020: PUSH
98021: LD_INT 33
98023: PUSH
98024: LD_INT 34
98026: PUSH
98027: LD_INT 35
98029: PUSH
98030: LD_INT 36
98032: PUSH
98033: EMPTY
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 101
98058: PUSH
98059: LD_INT 102
98061: PUSH
98062: LD_INT 103
98064: PUSH
98065: LD_INT 106
98067: PUSH
98068: LD_INT 108
98070: PUSH
98071: LD_INT 112
98073: PUSH
98074: LD_INT 113
98076: PUSH
98077: LD_INT 114
98079: PUSH
98080: LD_INT 115
98082: PUSH
98083: LD_INT 116
98085: PUSH
98086: LD_INT 117
98088: PUSH
98089: LD_INT 118
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: PUSH
98106: EMPTY
98107: LIST
98108: LIST
98109: ST_TO_ADDR
98110: GO 98353
98112: LD_INT 19
98114: DOUBLE
98115: EQUAL
98116: IFTRUE 98120
98118: GO 98352
98120: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98121: LD_ADDR_VAR 0 2
98125: PUSH
98126: LD_INT 1
98128: PUSH
98129: LD_INT 2
98131: PUSH
98132: LD_INT 3
98134: PUSH
98135: LD_INT 4
98137: PUSH
98138: LD_INT 5
98140: PUSH
98141: LD_INT 6
98143: PUSH
98144: LD_INT 7
98146: PUSH
98147: LD_INT 8
98149: PUSH
98150: LD_INT 9
98152: PUSH
98153: LD_INT 10
98155: PUSH
98156: LD_INT 11
98158: PUSH
98159: LD_INT 12
98161: PUSH
98162: LD_INT 13
98164: PUSH
98165: LD_INT 14
98167: PUSH
98168: LD_INT 15
98170: PUSH
98171: LD_INT 16
98173: PUSH
98174: LD_INT 17
98176: PUSH
98177: LD_INT 18
98179: PUSH
98180: LD_INT 19
98182: PUSH
98183: LD_INT 20
98185: PUSH
98186: LD_INT 21
98188: PUSH
98189: LD_INT 22
98191: PUSH
98192: LD_INT 23
98194: PUSH
98195: LD_INT 24
98197: PUSH
98198: LD_INT 25
98200: PUSH
98201: LD_INT 26
98203: PUSH
98204: LD_INT 27
98206: PUSH
98207: LD_INT 28
98209: PUSH
98210: LD_INT 29
98212: PUSH
98213: LD_INT 30
98215: PUSH
98216: LD_INT 31
98218: PUSH
98219: LD_INT 32
98221: PUSH
98222: LD_INT 33
98224: PUSH
98225: LD_INT 34
98227: PUSH
98228: LD_INT 35
98230: PUSH
98231: LD_INT 36
98233: PUSH
98234: EMPTY
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: LIST
98271: PUSH
98272: LD_INT 101
98274: PUSH
98275: LD_INT 102
98277: PUSH
98278: LD_INT 103
98280: PUSH
98281: LD_INT 104
98283: PUSH
98284: LD_INT 105
98286: PUSH
98287: LD_INT 106
98289: PUSH
98290: LD_INT 107
98292: PUSH
98293: LD_INT 108
98295: PUSH
98296: LD_INT 109
98298: PUSH
98299: LD_INT 110
98301: PUSH
98302: LD_INT 111
98304: PUSH
98305: LD_INT 112
98307: PUSH
98308: LD_INT 113
98310: PUSH
98311: LD_INT 114
98313: PUSH
98314: LD_INT 115
98316: PUSH
98317: LD_INT 116
98319: PUSH
98320: LD_INT 117
98322: PUSH
98323: LD_INT 118
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: ST_TO_ADDR
98350: GO 98353
98352: POP
// end else
98353: GO 98584
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98355: LD_ADDR_VAR 0 2
98359: PUSH
98360: LD_INT 1
98362: PUSH
98363: LD_INT 2
98365: PUSH
98366: LD_INT 3
98368: PUSH
98369: LD_INT 4
98371: PUSH
98372: LD_INT 5
98374: PUSH
98375: LD_INT 6
98377: PUSH
98378: LD_INT 7
98380: PUSH
98381: LD_INT 8
98383: PUSH
98384: LD_INT 9
98386: PUSH
98387: LD_INT 10
98389: PUSH
98390: LD_INT 11
98392: PUSH
98393: LD_INT 12
98395: PUSH
98396: LD_INT 13
98398: PUSH
98399: LD_INT 14
98401: PUSH
98402: LD_INT 15
98404: PUSH
98405: LD_INT 16
98407: PUSH
98408: LD_INT 17
98410: PUSH
98411: LD_INT 18
98413: PUSH
98414: LD_INT 19
98416: PUSH
98417: LD_INT 20
98419: PUSH
98420: LD_INT 21
98422: PUSH
98423: LD_INT 22
98425: PUSH
98426: LD_INT 23
98428: PUSH
98429: LD_INT 24
98431: PUSH
98432: LD_INT 25
98434: PUSH
98435: LD_INT 26
98437: PUSH
98438: LD_INT 27
98440: PUSH
98441: LD_INT 28
98443: PUSH
98444: LD_INT 29
98446: PUSH
98447: LD_INT 30
98449: PUSH
98450: LD_INT 31
98452: PUSH
98453: LD_INT 32
98455: PUSH
98456: LD_INT 33
98458: PUSH
98459: LD_INT 34
98461: PUSH
98462: LD_INT 35
98464: PUSH
98465: LD_INT 36
98467: PUSH
98468: EMPTY
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: PUSH
98506: LD_INT 101
98508: PUSH
98509: LD_INT 102
98511: PUSH
98512: LD_INT 103
98514: PUSH
98515: LD_INT 104
98517: PUSH
98518: LD_INT 105
98520: PUSH
98521: LD_INT 106
98523: PUSH
98524: LD_INT 107
98526: PUSH
98527: LD_INT 108
98529: PUSH
98530: LD_INT 109
98532: PUSH
98533: LD_INT 110
98535: PUSH
98536: LD_INT 111
98538: PUSH
98539: LD_INT 112
98541: PUSH
98542: LD_INT 113
98544: PUSH
98545: LD_INT 114
98547: PUSH
98548: LD_INT 115
98550: PUSH
98551: LD_INT 116
98553: PUSH
98554: LD_INT 117
98556: PUSH
98557: LD_INT 118
98559: PUSH
98560: EMPTY
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: ST_TO_ADDR
// if result then
98584: LD_VAR 0 2
98588: IFFALSE 99374
// begin normal :=  ;
98590: LD_ADDR_VAR 0 5
98594: PUSH
98595: LD_STRING 
98597: ST_TO_ADDR
// hardcore :=  ;
98598: LD_ADDR_VAR 0 6
98602: PUSH
98603: LD_STRING 
98605: ST_TO_ADDR
// active :=  ;
98606: LD_ADDR_VAR 0 7
98610: PUSH
98611: LD_STRING 
98613: ST_TO_ADDR
// for i = 1 to normalCounter do
98614: LD_ADDR_VAR 0 8
98618: PUSH
98619: DOUBLE
98620: LD_INT 1
98622: DEC
98623: ST_TO_ADDR
98624: LD_EXP 97
98628: PUSH
98629: FOR_TO
98630: IFFALSE 98731
// begin tmp := 0 ;
98632: LD_ADDR_VAR 0 3
98636: PUSH
98637: LD_STRING 0
98639: ST_TO_ADDR
// if result [ 1 ] then
98640: LD_VAR 0 2
98644: PUSH
98645: LD_INT 1
98647: ARRAY
98648: IFFALSE 98713
// if result [ 1 ] [ 1 ] = i then
98650: LD_VAR 0 2
98654: PUSH
98655: LD_INT 1
98657: ARRAY
98658: PUSH
98659: LD_INT 1
98661: ARRAY
98662: PUSH
98663: LD_VAR 0 8
98667: EQUAL
98668: IFFALSE 98713
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98670: LD_ADDR_VAR 0 2
98674: PUSH
98675: LD_VAR 0 2
98679: PPUSH
98680: LD_INT 1
98682: PPUSH
98683: LD_VAR 0 2
98687: PUSH
98688: LD_INT 1
98690: ARRAY
98691: PPUSH
98692: LD_INT 1
98694: PPUSH
98695: CALL_OW 3
98699: PPUSH
98700: CALL_OW 1
98704: ST_TO_ADDR
// tmp := 1 ;
98705: LD_ADDR_VAR 0 3
98709: PUSH
98710: LD_STRING 1
98712: ST_TO_ADDR
// end ; normal := normal & tmp ;
98713: LD_ADDR_VAR 0 5
98717: PUSH
98718: LD_VAR 0 5
98722: PUSH
98723: LD_VAR 0 3
98727: STR
98728: ST_TO_ADDR
// end ;
98729: GO 98629
98731: POP
98732: POP
// for i = 1 to hardcoreCounter do
98733: LD_ADDR_VAR 0 8
98737: PUSH
98738: DOUBLE
98739: LD_INT 1
98741: DEC
98742: ST_TO_ADDR
98743: LD_EXP 98
98747: PUSH
98748: FOR_TO
98749: IFFALSE 98854
// begin tmp := 0 ;
98751: LD_ADDR_VAR 0 3
98755: PUSH
98756: LD_STRING 0
98758: ST_TO_ADDR
// if result [ 2 ] then
98759: LD_VAR 0 2
98763: PUSH
98764: LD_INT 2
98766: ARRAY
98767: IFFALSE 98836
// if result [ 2 ] [ 1 ] = 100 + i then
98769: LD_VAR 0 2
98773: PUSH
98774: LD_INT 2
98776: ARRAY
98777: PUSH
98778: LD_INT 1
98780: ARRAY
98781: PUSH
98782: LD_INT 100
98784: PUSH
98785: LD_VAR 0 8
98789: PLUS
98790: EQUAL
98791: IFFALSE 98836
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98793: LD_ADDR_VAR 0 2
98797: PUSH
98798: LD_VAR 0 2
98802: PPUSH
98803: LD_INT 2
98805: PPUSH
98806: LD_VAR 0 2
98810: PUSH
98811: LD_INT 2
98813: ARRAY
98814: PPUSH
98815: LD_INT 1
98817: PPUSH
98818: CALL_OW 3
98822: PPUSH
98823: CALL_OW 1
98827: ST_TO_ADDR
// tmp := 1 ;
98828: LD_ADDR_VAR 0 3
98832: PUSH
98833: LD_STRING 1
98835: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98836: LD_ADDR_VAR 0 6
98840: PUSH
98841: LD_VAR 0 6
98845: PUSH
98846: LD_VAR 0 3
98850: STR
98851: ST_TO_ADDR
// end ;
98852: GO 98748
98854: POP
98855: POP
// if isGameLoad then
98856: LD_VAR 0 1
98860: IFFALSE 99335
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98862: LD_ADDR_VAR 0 4
98866: PUSH
98867: LD_EXP 101
98871: PUSH
98872: LD_EXP 100
98876: PUSH
98877: LD_EXP 102
98881: PUSH
98882: LD_EXP 99
98886: PUSH
98887: LD_EXP 103
98891: PUSH
98892: LD_EXP 104
98896: PUSH
98897: LD_EXP 105
98901: PUSH
98902: LD_EXP 106
98906: PUSH
98907: LD_EXP 107
98911: PUSH
98912: LD_EXP 108
98916: PUSH
98917: LD_EXP 109
98921: PUSH
98922: LD_EXP 110
98926: PUSH
98927: LD_EXP 111
98931: PUSH
98932: LD_EXP 112
98936: PUSH
98937: LD_EXP 120
98941: PUSH
98942: LD_EXP 121
98946: PUSH
98947: LD_EXP 122
98951: PUSH
98952: LD_EXP 123
98956: PUSH
98957: LD_EXP 125
98961: PUSH
98962: LD_EXP 126
98966: PUSH
98967: LD_EXP 127
98971: PUSH
98972: LD_EXP 130
98976: PUSH
98977: LD_EXP 132
98981: PUSH
98982: LD_EXP 133
98986: PUSH
98987: LD_EXP 134
98991: PUSH
98992: LD_EXP 136
98996: PUSH
98997: LD_EXP 137
99001: PUSH
99002: LD_EXP 140
99006: PUSH
99007: LD_EXP 141
99011: PUSH
99012: LD_EXP 142
99016: PUSH
99017: LD_EXP 143
99021: PUSH
99022: LD_EXP 144
99026: PUSH
99027: LD_EXP 145
99031: PUSH
99032: LD_EXP 146
99036: PUSH
99037: LD_EXP 147
99041: PUSH
99042: LD_EXP 148
99046: PUSH
99047: LD_EXP 113
99051: PUSH
99052: LD_EXP 114
99056: PUSH
99057: LD_EXP 117
99061: PUSH
99062: LD_EXP 118
99066: PUSH
99067: LD_EXP 119
99071: PUSH
99072: LD_EXP 115
99076: PUSH
99077: LD_EXP 116
99081: PUSH
99082: LD_EXP 124
99086: PUSH
99087: LD_EXP 128
99091: PUSH
99092: LD_EXP 129
99096: PUSH
99097: LD_EXP 131
99101: PUSH
99102: LD_EXP 135
99106: PUSH
99107: LD_EXP 138
99111: PUSH
99112: LD_EXP 139
99116: PUSH
99117: LD_EXP 149
99121: PUSH
99122: LD_EXP 150
99126: PUSH
99127: LD_EXP 151
99131: PUSH
99132: LD_EXP 152
99136: PUSH
99137: EMPTY
99138: LIST
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: LIST
99144: LIST
99145: LIST
99146: LIST
99147: LIST
99148: LIST
99149: LIST
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: ST_TO_ADDR
// tmp :=  ;
99193: LD_ADDR_VAR 0 3
99197: PUSH
99198: LD_STRING 
99200: ST_TO_ADDR
// for i = 1 to normalCounter do
99201: LD_ADDR_VAR 0 8
99205: PUSH
99206: DOUBLE
99207: LD_INT 1
99209: DEC
99210: ST_TO_ADDR
99211: LD_EXP 97
99215: PUSH
99216: FOR_TO
99217: IFFALSE 99253
// begin if flags [ i ] then
99219: LD_VAR 0 4
99223: PUSH
99224: LD_VAR 0 8
99228: ARRAY
99229: IFFALSE 99251
// tmp := tmp & i & ; ;
99231: LD_ADDR_VAR 0 3
99235: PUSH
99236: LD_VAR 0 3
99240: PUSH
99241: LD_VAR 0 8
99245: STR
99246: PUSH
99247: LD_STRING ;
99249: STR
99250: ST_TO_ADDR
// end ;
99251: GO 99216
99253: POP
99254: POP
// for i = 1 to hardcoreCounter do
99255: LD_ADDR_VAR 0 8
99259: PUSH
99260: DOUBLE
99261: LD_INT 1
99263: DEC
99264: ST_TO_ADDR
99265: LD_EXP 98
99269: PUSH
99270: FOR_TO
99271: IFFALSE 99317
// begin if flags [ normalCounter + i ] then
99273: LD_VAR 0 4
99277: PUSH
99278: LD_EXP 97
99282: PUSH
99283: LD_VAR 0 8
99287: PLUS
99288: ARRAY
99289: IFFALSE 99315
// tmp := tmp & ( 100 + i ) & ; ;
99291: LD_ADDR_VAR 0 3
99295: PUSH
99296: LD_VAR 0 3
99300: PUSH
99301: LD_INT 100
99303: PUSH
99304: LD_VAR 0 8
99308: PLUS
99309: STR
99310: PUSH
99311: LD_STRING ;
99313: STR
99314: ST_TO_ADDR
// end ;
99315: GO 99270
99317: POP
99318: POP
// if tmp then
99319: LD_VAR 0 3
99323: IFFALSE 99335
// active := tmp ;
99325: LD_ADDR_VAR 0 7
99329: PUSH
99330: LD_VAR 0 3
99334: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99335: LD_STRING getStreamItemsFromMission("
99337: PUSH
99338: LD_VAR 0 5
99342: STR
99343: PUSH
99344: LD_STRING ","
99346: STR
99347: PUSH
99348: LD_VAR 0 6
99352: STR
99353: PUSH
99354: LD_STRING ","
99356: STR
99357: PUSH
99358: LD_VAR 0 7
99362: STR
99363: PUSH
99364: LD_STRING ")
99366: STR
99367: PPUSH
99368: CALL_OW 559
// end else
99372: GO 99381
// ToLua ( getStreamItemsFromMission("","","") ) ;
99374: LD_STRING getStreamItemsFromMission("","","")
99376: PPUSH
99377: CALL_OW 559
// end ;
99381: LD_VAR 0 2
99385: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99386: LD_EXP 96
99390: IFFALSE 99398
99392: PUSH
99393: LD_EXP 101
99397: AND
99398: IFFALSE 99522
99400: GO 99402
99402: DISABLE
99403: LD_INT 0
99405: PPUSH
99406: PPUSH
// begin enable ;
99407: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99408: LD_ADDR_VAR 0 2
99412: PUSH
99413: LD_INT 22
99415: PUSH
99416: LD_OWVAR 2
99420: PUSH
99421: EMPTY
99422: LIST
99423: LIST
99424: PUSH
99425: LD_INT 2
99427: PUSH
99428: LD_INT 34
99430: PUSH
99431: LD_INT 7
99433: PUSH
99434: EMPTY
99435: LIST
99436: LIST
99437: PUSH
99438: LD_INT 34
99440: PUSH
99441: LD_INT 45
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: PUSH
99448: LD_INT 34
99450: PUSH
99451: LD_INT 28
99453: PUSH
99454: EMPTY
99455: LIST
99456: LIST
99457: PUSH
99458: LD_INT 34
99460: PUSH
99461: LD_INT 47
99463: PUSH
99464: EMPTY
99465: LIST
99466: LIST
99467: PUSH
99468: EMPTY
99469: LIST
99470: LIST
99471: LIST
99472: LIST
99473: LIST
99474: PUSH
99475: EMPTY
99476: LIST
99477: LIST
99478: PPUSH
99479: CALL_OW 69
99483: ST_TO_ADDR
// if not tmp then
99484: LD_VAR 0 2
99488: NOT
99489: IFFALSE 99493
// exit ;
99491: GO 99522
// for i in tmp do
99493: LD_ADDR_VAR 0 1
99497: PUSH
99498: LD_VAR 0 2
99502: PUSH
99503: FOR_IN
99504: IFFALSE 99520
// begin SetLives ( i , 0 ) ;
99506: LD_VAR 0 1
99510: PPUSH
99511: LD_INT 0
99513: PPUSH
99514: CALL_OW 234
// end ;
99518: GO 99503
99520: POP
99521: POP
// end ;
99522: PPOPN 2
99524: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99525: LD_EXP 96
99529: IFFALSE 99537
99531: PUSH
99532: LD_EXP 102
99536: AND
99537: IFFALSE 99621
99539: GO 99541
99541: DISABLE
99542: LD_INT 0
99544: PPUSH
99545: PPUSH
// begin enable ;
99546: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99547: LD_ADDR_VAR 0 2
99551: PUSH
99552: LD_INT 22
99554: PUSH
99555: LD_OWVAR 2
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PUSH
99564: LD_INT 32
99566: PUSH
99567: LD_INT 3
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: PUSH
99574: EMPTY
99575: LIST
99576: LIST
99577: PPUSH
99578: CALL_OW 69
99582: ST_TO_ADDR
// if not tmp then
99583: LD_VAR 0 2
99587: NOT
99588: IFFALSE 99592
// exit ;
99590: GO 99621
// for i in tmp do
99592: LD_ADDR_VAR 0 1
99596: PUSH
99597: LD_VAR 0 2
99601: PUSH
99602: FOR_IN
99603: IFFALSE 99619
// begin SetLives ( i , 0 ) ;
99605: LD_VAR 0 1
99609: PPUSH
99610: LD_INT 0
99612: PPUSH
99613: CALL_OW 234
// end ;
99617: GO 99602
99619: POP
99620: POP
// end ;
99621: PPOPN 2
99623: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99624: LD_EXP 96
99628: IFFALSE 99636
99630: PUSH
99631: LD_EXP 99
99635: AND
99636: IFFALSE 99729
99638: GO 99640
99640: DISABLE
99641: LD_INT 0
99643: PPUSH
// begin enable ;
99644: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99645: LD_ADDR_VAR 0 1
99649: PUSH
99650: LD_INT 22
99652: PUSH
99653: LD_OWVAR 2
99657: PUSH
99658: EMPTY
99659: LIST
99660: LIST
99661: PUSH
99662: LD_INT 2
99664: PUSH
99665: LD_INT 25
99667: PUSH
99668: LD_INT 5
99670: PUSH
99671: EMPTY
99672: LIST
99673: LIST
99674: PUSH
99675: LD_INT 25
99677: PUSH
99678: LD_INT 9
99680: PUSH
99681: EMPTY
99682: LIST
99683: LIST
99684: PUSH
99685: LD_INT 25
99687: PUSH
99688: LD_INT 8
99690: PUSH
99691: EMPTY
99692: LIST
99693: LIST
99694: PUSH
99695: EMPTY
99696: LIST
99697: LIST
99698: LIST
99699: LIST
99700: PUSH
99701: EMPTY
99702: LIST
99703: LIST
99704: PPUSH
99705: CALL_OW 69
99709: PUSH
99710: FOR_IN
99711: IFFALSE 99727
// begin SetClass ( i , 1 ) ;
99713: LD_VAR 0 1
99717: PPUSH
99718: LD_INT 1
99720: PPUSH
99721: CALL_OW 336
// end ;
99725: GO 99710
99727: POP
99728: POP
// end ;
99729: PPOPN 1
99731: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99732: LD_EXP 96
99736: IFFALSE 99744
99738: PUSH
99739: LD_EXP 100
99743: AND
99744: IFFALSE 99756
99746: PUSH
99747: LD_OWVAR 65
99751: PUSH
99752: LD_INT 7
99754: LESS
99755: AND
99756: IFFALSE 99770
99758: GO 99760
99760: DISABLE
// begin enable ;
99761: ENABLE
// game_speed := 7 ;
99762: LD_ADDR_OWVAR 65
99766: PUSH
99767: LD_INT 7
99769: ST_TO_ADDR
// end ;
99770: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99771: LD_EXP 96
99775: IFFALSE 99783
99777: PUSH
99778: LD_EXP 103
99782: AND
99783: IFFALSE 99985
99785: GO 99787
99787: DISABLE
99788: LD_INT 0
99790: PPUSH
99791: PPUSH
99792: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99793: LD_ADDR_VAR 0 3
99797: PUSH
99798: LD_INT 81
99800: PUSH
99801: LD_OWVAR 2
99805: PUSH
99806: EMPTY
99807: LIST
99808: LIST
99809: PUSH
99810: LD_INT 21
99812: PUSH
99813: LD_INT 1
99815: PUSH
99816: EMPTY
99817: LIST
99818: LIST
99819: PUSH
99820: EMPTY
99821: LIST
99822: LIST
99823: PPUSH
99824: CALL_OW 69
99828: ST_TO_ADDR
// if not tmp then
99829: LD_VAR 0 3
99833: NOT
99834: IFFALSE 99838
// exit ;
99836: GO 99985
// if tmp > 5 then
99838: LD_VAR 0 3
99842: PUSH
99843: LD_INT 5
99845: GREATER
99846: IFFALSE 99858
// k := 5 else
99848: LD_ADDR_VAR 0 2
99852: PUSH
99853: LD_INT 5
99855: ST_TO_ADDR
99856: GO 99868
// k := tmp ;
99858: LD_ADDR_VAR 0 2
99862: PUSH
99863: LD_VAR 0 3
99867: ST_TO_ADDR
// for i := 1 to k do
99868: LD_ADDR_VAR 0 1
99872: PUSH
99873: DOUBLE
99874: LD_INT 1
99876: DEC
99877: ST_TO_ADDR
99878: LD_VAR 0 2
99882: PUSH
99883: FOR_TO
99884: IFFALSE 99983
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99886: LD_VAR 0 3
99890: PUSH
99891: LD_VAR 0 1
99895: ARRAY
99896: PPUSH
99897: LD_VAR 0 1
99901: PUSH
99902: LD_INT 4
99904: MOD
99905: PUSH
99906: LD_INT 1
99908: PLUS
99909: PPUSH
99910: CALL_OW 259
99914: PUSH
99915: LD_INT 10
99917: LESS
99918: IFFALSE 99981
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99920: LD_VAR 0 3
99924: PUSH
99925: LD_VAR 0 1
99929: ARRAY
99930: PPUSH
99931: LD_VAR 0 1
99935: PUSH
99936: LD_INT 4
99938: MOD
99939: PUSH
99940: LD_INT 1
99942: PLUS
99943: PPUSH
99944: LD_VAR 0 3
99948: PUSH
99949: LD_VAR 0 1
99953: ARRAY
99954: PPUSH
99955: LD_VAR 0 1
99959: PUSH
99960: LD_INT 4
99962: MOD
99963: PUSH
99964: LD_INT 1
99966: PLUS
99967: PPUSH
99968: CALL_OW 259
99972: PUSH
99973: LD_INT 1
99975: PLUS
99976: PPUSH
99977: CALL_OW 237
99981: GO 99883
99983: POP
99984: POP
// end ;
99985: PPOPN 3
99987: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99988: LD_EXP 96
99992: IFFALSE 100000
99994: PUSH
99995: LD_EXP 104
99999: AND
100000: IFFALSE 100020
100002: GO 100004
100004: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100005: LD_INT 4
100007: PPUSH
100008: LD_OWVAR 2
100012: PPUSH
100013: LD_INT 0
100015: PPUSH
100016: CALL_OW 324
100020: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100021: LD_EXP 96
100025: IFFALSE 100033
100027: PUSH
100028: LD_EXP 133
100032: AND
100033: IFFALSE 100053
100035: GO 100037
100037: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100038: LD_INT 19
100040: PPUSH
100041: LD_OWVAR 2
100045: PPUSH
100046: LD_INT 0
100048: PPUSH
100049: CALL_OW 324
100053: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100054: LD_EXP 96
100058: IFFALSE 100066
100060: PUSH
100061: LD_EXP 105
100065: AND
100066: IFFALSE 100168
100068: GO 100070
100070: DISABLE
100071: LD_INT 0
100073: PPUSH
100074: PPUSH
// begin enable ;
100075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100076: LD_ADDR_VAR 0 2
100080: PUSH
100081: LD_INT 22
100083: PUSH
100084: LD_OWVAR 2
100088: PUSH
100089: EMPTY
100090: LIST
100091: LIST
100092: PUSH
100093: LD_INT 2
100095: PUSH
100096: LD_INT 34
100098: PUSH
100099: LD_INT 11
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: PUSH
100106: LD_INT 34
100108: PUSH
100109: LD_INT 30
100111: PUSH
100112: EMPTY
100113: LIST
100114: LIST
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: LIST
100120: PUSH
100121: EMPTY
100122: LIST
100123: LIST
100124: PPUSH
100125: CALL_OW 69
100129: ST_TO_ADDR
// if not tmp then
100130: LD_VAR 0 2
100134: NOT
100135: IFFALSE 100139
// exit ;
100137: GO 100168
// for i in tmp do
100139: LD_ADDR_VAR 0 1
100143: PUSH
100144: LD_VAR 0 2
100148: PUSH
100149: FOR_IN
100150: IFFALSE 100166
// begin SetLives ( i , 0 ) ;
100152: LD_VAR 0 1
100156: PPUSH
100157: LD_INT 0
100159: PPUSH
100160: CALL_OW 234
// end ;
100164: GO 100149
100166: POP
100167: POP
// end ;
100168: PPOPN 2
100170: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100171: LD_EXP 96
100175: IFFALSE 100183
100177: PUSH
100178: LD_EXP 106
100182: AND
100183: IFFALSE 100203
100185: GO 100187
100187: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100188: LD_INT 32
100190: PPUSH
100191: LD_OWVAR 2
100195: PPUSH
100196: LD_INT 0
100198: PPUSH
100199: CALL_OW 324
100203: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100204: LD_EXP 96
100208: IFFALSE 100216
100210: PUSH
100211: LD_EXP 107
100215: AND
100216: IFFALSE 100399
100218: GO 100220
100220: DISABLE
100221: LD_INT 0
100223: PPUSH
100224: PPUSH
100225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100226: LD_ADDR_VAR 0 2
100230: PUSH
100231: LD_INT 22
100233: PUSH
100234: LD_OWVAR 2
100238: PUSH
100239: EMPTY
100240: LIST
100241: LIST
100242: PUSH
100243: LD_INT 33
100245: PUSH
100246: LD_INT 3
100248: PUSH
100249: EMPTY
100250: LIST
100251: LIST
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: PPUSH
100257: CALL_OW 69
100261: ST_TO_ADDR
// if not tmp then
100262: LD_VAR 0 2
100266: NOT
100267: IFFALSE 100271
// exit ;
100269: GO 100399
// side := 0 ;
100271: LD_ADDR_VAR 0 3
100275: PUSH
100276: LD_INT 0
100278: ST_TO_ADDR
// for i := 1 to 8 do
100279: LD_ADDR_VAR 0 1
100283: PUSH
100284: DOUBLE
100285: LD_INT 1
100287: DEC
100288: ST_TO_ADDR
100289: LD_INT 8
100291: PUSH
100292: FOR_TO
100293: IFFALSE 100343
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100295: LD_OWVAR 2
100299: PUSH
100300: LD_VAR 0 1
100304: NONEQUAL
100305: IFFALSE 100327
100307: PUSH
100308: LD_OWVAR 2
100312: PPUSH
100313: LD_VAR 0 1
100317: PPUSH
100318: CALL_OW 81
100322: PUSH
100323: LD_INT 2
100325: EQUAL
100326: AND
100327: IFFALSE 100341
// begin side := i ;
100329: LD_ADDR_VAR 0 3
100333: PUSH
100334: LD_VAR 0 1
100338: ST_TO_ADDR
// break ;
100339: GO 100343
// end ;
100341: GO 100292
100343: POP
100344: POP
// if not side then
100345: LD_VAR 0 3
100349: NOT
100350: IFFALSE 100354
// exit ;
100352: GO 100399
// for i := 1 to tmp do
100354: LD_ADDR_VAR 0 1
100358: PUSH
100359: DOUBLE
100360: LD_INT 1
100362: DEC
100363: ST_TO_ADDR
100364: LD_VAR 0 2
100368: PUSH
100369: FOR_TO
100370: IFFALSE 100397
// if Prob ( 60 ) then
100372: LD_INT 60
100374: PPUSH
100375: CALL_OW 13
100379: IFFALSE 100395
// SetSide ( i , side ) ;
100381: LD_VAR 0 1
100385: PPUSH
100386: LD_VAR 0 3
100390: PPUSH
100391: CALL_OW 235
100395: GO 100369
100397: POP
100398: POP
// end ;
100399: PPOPN 3
100401: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100402: LD_EXP 96
100406: IFFALSE 100414
100408: PUSH
100409: LD_EXP 109
100413: AND
100414: IFFALSE 100533
100416: GO 100418
100418: DISABLE
100419: LD_INT 0
100421: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100422: LD_ADDR_VAR 0 1
100426: PUSH
100427: LD_INT 22
100429: PUSH
100430: LD_OWVAR 2
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: LD_INT 21
100441: PUSH
100442: LD_INT 1
100444: PUSH
100445: EMPTY
100446: LIST
100447: LIST
100448: PUSH
100449: LD_INT 3
100451: PUSH
100452: LD_INT 23
100454: PUSH
100455: LD_INT 0
100457: PUSH
100458: EMPTY
100459: LIST
100460: LIST
100461: PUSH
100462: EMPTY
100463: LIST
100464: LIST
100465: PUSH
100466: EMPTY
100467: LIST
100468: LIST
100469: LIST
100470: PPUSH
100471: CALL_OW 69
100475: PUSH
100476: FOR_IN
100477: IFFALSE 100531
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100479: LD_VAR 0 1
100483: PPUSH
100484: CALL_OW 257
100488: PUSH
100489: LD_INT 1
100491: PUSH
100492: LD_INT 2
100494: PUSH
100495: LD_INT 3
100497: PUSH
100498: LD_INT 4
100500: PUSH
100501: EMPTY
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: IN
100507: IFFALSE 100529
// SetClass ( un , rand ( 1 , 4 ) ) ;
100509: LD_VAR 0 1
100513: PPUSH
100514: LD_INT 1
100516: PPUSH
100517: LD_INT 4
100519: PPUSH
100520: CALL_OW 12
100524: PPUSH
100525: CALL_OW 336
100529: GO 100476
100531: POP
100532: POP
// end ;
100533: PPOPN 1
100535: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100536: LD_EXP 96
100540: IFFALSE 100548
100542: PUSH
100543: LD_EXP 108
100547: AND
100548: IFFALSE 100627
100550: GO 100552
100552: DISABLE
100553: LD_INT 0
100555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100556: LD_ADDR_VAR 0 1
100560: PUSH
100561: LD_INT 22
100563: PUSH
100564: LD_OWVAR 2
100568: PUSH
100569: EMPTY
100570: LIST
100571: LIST
100572: PUSH
100573: LD_INT 21
100575: PUSH
100576: LD_INT 3
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: PPUSH
100587: CALL_OW 69
100591: ST_TO_ADDR
// if not tmp then
100592: LD_VAR 0 1
100596: NOT
100597: IFFALSE 100601
// exit ;
100599: GO 100627
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100601: LD_VAR 0 1
100605: PUSH
100606: LD_INT 1
100608: PPUSH
100609: LD_VAR 0 1
100613: PPUSH
100614: CALL_OW 12
100618: ARRAY
100619: PPUSH
100620: LD_INT 100
100622: PPUSH
100623: CALL_OW 234
// end ;
100627: PPOPN 1
100629: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100630: LD_EXP 96
100634: IFFALSE 100642
100636: PUSH
100637: LD_EXP 110
100641: AND
100642: IFFALSE 100740
100644: GO 100646
100646: DISABLE
100647: LD_INT 0
100649: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100650: LD_ADDR_VAR 0 1
100654: PUSH
100655: LD_INT 22
100657: PUSH
100658: LD_OWVAR 2
100662: PUSH
100663: EMPTY
100664: LIST
100665: LIST
100666: PUSH
100667: LD_INT 21
100669: PUSH
100670: LD_INT 1
100672: PUSH
100673: EMPTY
100674: LIST
100675: LIST
100676: PUSH
100677: EMPTY
100678: LIST
100679: LIST
100680: PPUSH
100681: CALL_OW 69
100685: ST_TO_ADDR
// if not tmp then
100686: LD_VAR 0 1
100690: NOT
100691: IFFALSE 100695
// exit ;
100693: GO 100740
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100695: LD_VAR 0 1
100699: PUSH
100700: LD_INT 1
100702: PPUSH
100703: LD_VAR 0 1
100707: PPUSH
100708: CALL_OW 12
100712: ARRAY
100713: PPUSH
100714: LD_INT 1
100716: PPUSH
100717: LD_INT 4
100719: PPUSH
100720: CALL_OW 12
100724: PPUSH
100725: LD_INT 3000
100727: PPUSH
100728: LD_INT 9000
100730: PPUSH
100731: CALL_OW 12
100735: PPUSH
100736: CALL_OW 492
// end ;
100740: PPOPN 1
100742: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100743: LD_EXP 96
100747: IFFALSE 100755
100749: PUSH
100750: LD_EXP 111
100754: AND
100755: IFFALSE 100775
100757: GO 100759
100759: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100760: LD_INT 1
100762: PPUSH
100763: LD_OWVAR 2
100767: PPUSH
100768: LD_INT 0
100770: PPUSH
100771: CALL_OW 324
100775: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100776: LD_EXP 96
100780: IFFALSE 100788
100782: PUSH
100783: LD_EXP 112
100787: AND
100788: IFFALSE 100871
100790: GO 100792
100792: DISABLE
100793: LD_INT 0
100795: PPUSH
100796: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100797: LD_ADDR_VAR 0 2
100801: PUSH
100802: LD_INT 22
100804: PUSH
100805: LD_OWVAR 2
100809: PUSH
100810: EMPTY
100811: LIST
100812: LIST
100813: PUSH
100814: LD_INT 21
100816: PUSH
100817: LD_INT 3
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: PUSH
100824: EMPTY
100825: LIST
100826: LIST
100827: PPUSH
100828: CALL_OW 69
100832: ST_TO_ADDR
// if not tmp then
100833: LD_VAR 0 2
100837: NOT
100838: IFFALSE 100842
// exit ;
100840: GO 100871
// for i in tmp do
100842: LD_ADDR_VAR 0 1
100846: PUSH
100847: LD_VAR 0 2
100851: PUSH
100852: FOR_IN
100853: IFFALSE 100869
// SetBLevel ( i , 10 ) ;
100855: LD_VAR 0 1
100859: PPUSH
100860: LD_INT 10
100862: PPUSH
100863: CALL_OW 241
100867: GO 100852
100869: POP
100870: POP
// end ;
100871: PPOPN 2
100873: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100874: LD_EXP 96
100878: IFFALSE 100886
100880: PUSH
100881: LD_EXP 113
100885: AND
100886: IFFALSE 100997
100888: GO 100890
100890: DISABLE
100891: LD_INT 0
100893: PPUSH
100894: PPUSH
100895: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100896: LD_ADDR_VAR 0 3
100900: PUSH
100901: LD_INT 22
100903: PUSH
100904: LD_OWVAR 2
100908: PUSH
100909: EMPTY
100910: LIST
100911: LIST
100912: PUSH
100913: LD_INT 25
100915: PUSH
100916: LD_INT 1
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: PPUSH
100927: CALL_OW 69
100931: ST_TO_ADDR
// if not tmp then
100932: LD_VAR 0 3
100936: NOT
100937: IFFALSE 100941
// exit ;
100939: GO 100997
// un := tmp [ rand ( 1 , tmp ) ] ;
100941: LD_ADDR_VAR 0 2
100945: PUSH
100946: LD_VAR 0 3
100950: PUSH
100951: LD_INT 1
100953: PPUSH
100954: LD_VAR 0 3
100958: PPUSH
100959: CALL_OW 12
100963: ARRAY
100964: ST_TO_ADDR
// if Crawls ( un ) then
100965: LD_VAR 0 2
100969: PPUSH
100970: CALL_OW 318
100974: IFFALSE 100985
// ComWalk ( un ) ;
100976: LD_VAR 0 2
100980: PPUSH
100981: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100985: LD_VAR 0 2
100989: PPUSH
100990: LD_INT 5
100992: PPUSH
100993: CALL_OW 336
// end ;
100997: PPOPN 3
100999: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101000: LD_EXP 96
101004: IFFALSE 101012
101006: PUSH
101007: LD_EXP 114
101011: AND
101012: IFFALSE 101024
101014: PUSH
101015: LD_OWVAR 67
101019: PUSH
101020: LD_INT 4
101022: LESS
101023: AND
101024: IFFALSE 101043
101026: GO 101028
101028: DISABLE
// begin Difficulty := Difficulty + 1 ;
101029: LD_ADDR_OWVAR 67
101033: PUSH
101034: LD_OWVAR 67
101038: PUSH
101039: LD_INT 1
101041: PLUS
101042: ST_TO_ADDR
// end ;
101043: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101044: LD_EXP 96
101048: IFFALSE 101056
101050: PUSH
101051: LD_EXP 115
101055: AND
101056: IFFALSE 101159
101058: GO 101060
101060: DISABLE
101061: LD_INT 0
101063: PPUSH
// begin for i := 1 to 5 do
101064: LD_ADDR_VAR 0 1
101068: PUSH
101069: DOUBLE
101070: LD_INT 1
101072: DEC
101073: ST_TO_ADDR
101074: LD_INT 5
101076: PUSH
101077: FOR_TO
101078: IFFALSE 101157
// begin uc_nation := nation_nature ;
101080: LD_ADDR_OWVAR 21
101084: PUSH
101085: LD_INT 0
101087: ST_TO_ADDR
// uc_side := 0 ;
101088: LD_ADDR_OWVAR 20
101092: PUSH
101093: LD_INT 0
101095: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101096: LD_ADDR_OWVAR 29
101100: PUSH
101101: LD_INT 12
101103: PUSH
101104: LD_INT 12
101106: PUSH
101107: EMPTY
101108: LIST
101109: LIST
101110: ST_TO_ADDR
// hc_agressivity := 20 ;
101111: LD_ADDR_OWVAR 35
101115: PUSH
101116: LD_INT 20
101118: ST_TO_ADDR
// hc_class := class_tiger ;
101119: LD_ADDR_OWVAR 28
101123: PUSH
101124: LD_INT 14
101126: ST_TO_ADDR
// hc_gallery :=  ;
101127: LD_ADDR_OWVAR 33
101131: PUSH
101132: LD_STRING 
101134: ST_TO_ADDR
// hc_name :=  ;
101135: LD_ADDR_OWVAR 26
101139: PUSH
101140: LD_STRING 
101142: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101143: CALL_OW 44
101147: PPUSH
101148: LD_INT 0
101150: PPUSH
101151: CALL_OW 51
// end ;
101155: GO 101077
101157: POP
101158: POP
// end ;
101159: PPOPN 1
101161: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101162: LD_EXP 96
101166: IFFALSE 101174
101168: PUSH
101169: LD_EXP 116
101173: AND
101174: IFFALSE 101183
101176: GO 101178
101178: DISABLE
// StreamSibBomb ;
101179: CALL 101184 0 0
101183: END
// export function StreamSibBomb ; var i , x , y ; begin
101184: LD_INT 0
101186: PPUSH
101187: PPUSH
101188: PPUSH
101189: PPUSH
// result := false ;
101190: LD_ADDR_VAR 0 1
101194: PUSH
101195: LD_INT 0
101197: ST_TO_ADDR
// for i := 1 to 16 do
101198: LD_ADDR_VAR 0 2
101202: PUSH
101203: DOUBLE
101204: LD_INT 1
101206: DEC
101207: ST_TO_ADDR
101208: LD_INT 16
101210: PUSH
101211: FOR_TO
101212: IFFALSE 101411
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101214: LD_ADDR_VAR 0 3
101218: PUSH
101219: LD_INT 10
101221: PUSH
101222: LD_INT 20
101224: PUSH
101225: LD_INT 30
101227: PUSH
101228: LD_INT 40
101230: PUSH
101231: LD_INT 50
101233: PUSH
101234: LD_INT 60
101236: PUSH
101237: LD_INT 70
101239: PUSH
101240: LD_INT 80
101242: PUSH
101243: LD_INT 90
101245: PUSH
101246: LD_INT 100
101248: PUSH
101249: LD_INT 110
101251: PUSH
101252: LD_INT 120
101254: PUSH
101255: LD_INT 130
101257: PUSH
101258: LD_INT 140
101260: PUSH
101261: LD_INT 150
101263: PUSH
101264: EMPTY
101265: LIST
101266: LIST
101267: LIST
101268: LIST
101269: LIST
101270: LIST
101271: LIST
101272: LIST
101273: LIST
101274: LIST
101275: LIST
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: PUSH
101281: LD_INT 1
101283: PPUSH
101284: LD_INT 15
101286: PPUSH
101287: CALL_OW 12
101291: ARRAY
101292: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101293: LD_ADDR_VAR 0 4
101297: PUSH
101298: LD_INT 10
101300: PUSH
101301: LD_INT 20
101303: PUSH
101304: LD_INT 30
101306: PUSH
101307: LD_INT 40
101309: PUSH
101310: LD_INT 50
101312: PUSH
101313: LD_INT 60
101315: PUSH
101316: LD_INT 70
101318: PUSH
101319: LD_INT 80
101321: PUSH
101322: LD_INT 90
101324: PUSH
101325: LD_INT 100
101327: PUSH
101328: LD_INT 110
101330: PUSH
101331: LD_INT 120
101333: PUSH
101334: LD_INT 130
101336: PUSH
101337: LD_INT 140
101339: PUSH
101340: LD_INT 150
101342: PUSH
101343: EMPTY
101344: LIST
101345: LIST
101346: LIST
101347: LIST
101348: LIST
101349: LIST
101350: LIST
101351: LIST
101352: LIST
101353: LIST
101354: LIST
101355: LIST
101356: LIST
101357: LIST
101358: LIST
101359: PUSH
101360: LD_INT 1
101362: PPUSH
101363: LD_INT 15
101365: PPUSH
101366: CALL_OW 12
101370: ARRAY
101371: ST_TO_ADDR
// if ValidHex ( x , y ) then
101372: LD_VAR 0 3
101376: PPUSH
101377: LD_VAR 0 4
101381: PPUSH
101382: CALL_OW 488
101386: IFFALSE 101409
// begin result := [ x , y ] ;
101388: LD_ADDR_VAR 0 1
101392: PUSH
101393: LD_VAR 0 3
101397: PUSH
101398: LD_VAR 0 4
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: ST_TO_ADDR
// break ;
101407: GO 101411
// end ; end ;
101409: GO 101211
101411: POP
101412: POP
// if result then
101413: LD_VAR 0 1
101417: IFFALSE 101477
// begin ToLua ( playSibBomb() ) ;
101419: LD_STRING playSibBomb()
101421: PPUSH
101422: CALL_OW 559
// wait ( 0 0$14 ) ;
101426: LD_INT 490
101428: PPUSH
101429: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101433: LD_VAR 0 1
101437: PUSH
101438: LD_INT 1
101440: ARRAY
101441: PPUSH
101442: LD_VAR 0 1
101446: PUSH
101447: LD_INT 2
101449: ARRAY
101450: PPUSH
101451: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101455: LD_VAR 0 1
101459: PUSH
101460: LD_INT 1
101462: ARRAY
101463: PPUSH
101464: LD_VAR 0 1
101468: PUSH
101469: LD_INT 2
101471: ARRAY
101472: PPUSH
101473: CALL_OW 429
// end ; end ;
101477: LD_VAR 0 1
101481: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101482: LD_EXP 96
101486: IFFALSE 101494
101488: PUSH
101489: LD_EXP 118
101493: AND
101494: IFFALSE 101506
101496: GO 101498
101498: DISABLE
// YouLost (  ) ;
101499: LD_STRING 
101501: PPUSH
101502: CALL_OW 104
101506: END
// every 0 0$1 trigger StreamModeActive and sFog do
101507: LD_EXP 96
101511: IFFALSE 101519
101513: PUSH
101514: LD_EXP 117
101518: AND
101519: IFFALSE 101533
101521: GO 101523
101523: DISABLE
// FogOff ( your_side ) ;
101524: LD_OWVAR 2
101528: PPUSH
101529: CALL_OW 344
101533: END
// every 0 0$1 trigger StreamModeActive and sSun do
101534: LD_EXP 96
101538: IFFALSE 101546
101540: PUSH
101541: LD_EXP 119
101545: AND
101546: IFFALSE 101574
101548: GO 101550
101550: DISABLE
// begin solar_recharge_percent := 0 ;
101551: LD_ADDR_OWVAR 79
101555: PUSH
101556: LD_INT 0
101558: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101559: LD_INT 10500
101561: PPUSH
101562: CALL_OW 67
// solar_recharge_percent := 100 ;
101566: LD_ADDR_OWVAR 79
101570: PUSH
101571: LD_INT 100
101573: ST_TO_ADDR
// end ;
101574: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101575: LD_EXP 96
101579: IFFALSE 101587
101581: PUSH
101582: LD_EXP 120
101586: AND
101587: IFFALSE 101826
101589: GO 101591
101591: DISABLE
101592: LD_INT 0
101594: PPUSH
101595: PPUSH
101596: PPUSH
// begin tmp := [ ] ;
101597: LD_ADDR_VAR 0 3
101601: PUSH
101602: EMPTY
101603: ST_TO_ADDR
// for i := 1 to 6 do
101604: LD_ADDR_VAR 0 1
101608: PUSH
101609: DOUBLE
101610: LD_INT 1
101612: DEC
101613: ST_TO_ADDR
101614: LD_INT 6
101616: PUSH
101617: FOR_TO
101618: IFFALSE 101723
// begin uc_nation := nation_nature ;
101620: LD_ADDR_OWVAR 21
101624: PUSH
101625: LD_INT 0
101627: ST_TO_ADDR
// uc_side := 0 ;
101628: LD_ADDR_OWVAR 20
101632: PUSH
101633: LD_INT 0
101635: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101636: LD_ADDR_OWVAR 29
101640: PUSH
101641: LD_INT 12
101643: PUSH
101644: LD_INT 12
101646: PUSH
101647: EMPTY
101648: LIST
101649: LIST
101650: ST_TO_ADDR
// hc_agressivity := 20 ;
101651: LD_ADDR_OWVAR 35
101655: PUSH
101656: LD_INT 20
101658: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101659: LD_ADDR_OWVAR 28
101663: PUSH
101664: LD_INT 17
101666: ST_TO_ADDR
// hc_gallery :=  ;
101667: LD_ADDR_OWVAR 33
101671: PUSH
101672: LD_STRING 
101674: ST_TO_ADDR
// hc_name :=  ;
101675: LD_ADDR_OWVAR 26
101679: PUSH
101680: LD_STRING 
101682: ST_TO_ADDR
// un := CreateHuman ;
101683: LD_ADDR_VAR 0 2
101687: PUSH
101688: CALL_OW 44
101692: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101693: LD_VAR 0 2
101697: PPUSH
101698: LD_INT 1
101700: PPUSH
101701: CALL_OW 51
// tmp := tmp ^ un ;
101705: LD_ADDR_VAR 0 3
101709: PUSH
101710: LD_VAR 0 3
101714: PUSH
101715: LD_VAR 0 2
101719: ADD
101720: ST_TO_ADDR
// end ;
101721: GO 101617
101723: POP
101724: POP
// repeat wait ( 0 0$1 ) ;
101725: LD_INT 35
101727: PPUSH
101728: CALL_OW 67
// for un in tmp do
101732: LD_ADDR_VAR 0 2
101736: PUSH
101737: LD_VAR 0 3
101741: PUSH
101742: FOR_IN
101743: IFFALSE 101817
// begin if IsDead ( un ) then
101745: LD_VAR 0 2
101749: PPUSH
101750: CALL_OW 301
101754: IFFALSE 101774
// begin tmp := tmp diff un ;
101756: LD_ADDR_VAR 0 3
101760: PUSH
101761: LD_VAR 0 3
101765: PUSH
101766: LD_VAR 0 2
101770: DIFF
101771: ST_TO_ADDR
// continue ;
101772: GO 101742
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101774: LD_VAR 0 2
101778: PPUSH
101779: LD_INT 3
101781: PUSH
101782: LD_INT 22
101784: PUSH
101785: LD_INT 0
101787: PUSH
101788: EMPTY
101789: LIST
101790: LIST
101791: PUSH
101792: EMPTY
101793: LIST
101794: LIST
101795: PPUSH
101796: CALL_OW 69
101800: PPUSH
101801: LD_VAR 0 2
101805: PPUSH
101806: CALL_OW 74
101810: PPUSH
101811: CALL_OW 115
// end ;
101815: GO 101742
101817: POP
101818: POP
// until not tmp ;
101819: LD_VAR 0 3
101823: NOT
101824: IFFALSE 101725
// end ;
101826: PPOPN 3
101828: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101829: LD_EXP 96
101833: IFFALSE 101841
101835: PUSH
101836: LD_EXP 121
101840: AND
101841: IFFALSE 101895
101843: GO 101845
101845: DISABLE
// begin ToLua ( displayTroll(); ) ;
101846: LD_STRING displayTroll();
101848: PPUSH
101849: CALL_OW 559
// wait ( 3 3$00 ) ;
101853: LD_INT 6300
101855: PPUSH
101856: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101860: LD_STRING hideTroll();
101862: PPUSH
101863: CALL_OW 559
// wait ( 1 1$00 ) ;
101867: LD_INT 2100
101869: PPUSH
101870: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101874: LD_STRING displayTroll();
101876: PPUSH
101877: CALL_OW 559
// wait ( 1 1$00 ) ;
101881: LD_INT 2100
101883: PPUSH
101884: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101888: LD_STRING hideTroll();
101890: PPUSH
101891: CALL_OW 559
// end ;
101895: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101896: LD_EXP 96
101900: IFFALSE 101908
101902: PUSH
101903: LD_EXP 122
101907: AND
101908: IFFALSE 101971
101910: GO 101912
101912: DISABLE
101913: LD_INT 0
101915: PPUSH
// begin p := 0 ;
101916: LD_ADDR_VAR 0 1
101920: PUSH
101921: LD_INT 0
101923: ST_TO_ADDR
// repeat game_speed := 1 ;
101924: LD_ADDR_OWVAR 65
101928: PUSH
101929: LD_INT 1
101931: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101932: LD_INT 35
101934: PPUSH
101935: CALL_OW 67
// p := p + 1 ;
101939: LD_ADDR_VAR 0 1
101943: PUSH
101944: LD_VAR 0 1
101948: PUSH
101949: LD_INT 1
101951: PLUS
101952: ST_TO_ADDR
// until p >= 60 ;
101953: LD_VAR 0 1
101957: PUSH
101958: LD_INT 60
101960: GREATEREQUAL
101961: IFFALSE 101924
// game_speed := 4 ;
101963: LD_ADDR_OWVAR 65
101967: PUSH
101968: LD_INT 4
101970: ST_TO_ADDR
// end ;
101971: PPOPN 1
101973: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101974: LD_EXP 96
101978: IFFALSE 101986
101980: PUSH
101981: LD_EXP 123
101985: AND
101986: IFFALSE 102132
101988: GO 101990
101990: DISABLE
101991: LD_INT 0
101993: PPUSH
101994: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101995: LD_ADDR_VAR 0 1
101999: PUSH
102000: LD_INT 22
102002: PUSH
102003: LD_OWVAR 2
102007: PUSH
102008: EMPTY
102009: LIST
102010: LIST
102011: PUSH
102012: LD_INT 2
102014: PUSH
102015: LD_INT 30
102017: PUSH
102018: LD_INT 0
102020: PUSH
102021: EMPTY
102022: LIST
102023: LIST
102024: PUSH
102025: LD_INT 30
102027: PUSH
102028: LD_INT 1
102030: PUSH
102031: EMPTY
102032: LIST
102033: LIST
102034: PUSH
102035: EMPTY
102036: LIST
102037: LIST
102038: LIST
102039: PUSH
102040: EMPTY
102041: LIST
102042: LIST
102043: PPUSH
102044: CALL_OW 69
102048: ST_TO_ADDR
// if not depot then
102049: LD_VAR 0 1
102053: NOT
102054: IFFALSE 102058
// exit ;
102056: GO 102132
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102058: LD_ADDR_VAR 0 2
102062: PUSH
102063: LD_VAR 0 1
102067: PUSH
102068: LD_INT 1
102070: PPUSH
102071: LD_VAR 0 1
102075: PPUSH
102076: CALL_OW 12
102080: ARRAY
102081: PPUSH
102082: CALL_OW 274
102086: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102087: LD_VAR 0 2
102091: PPUSH
102092: LD_INT 1
102094: PPUSH
102095: LD_INT 0
102097: PPUSH
102098: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102102: LD_VAR 0 2
102106: PPUSH
102107: LD_INT 2
102109: PPUSH
102110: LD_INT 0
102112: PPUSH
102113: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102117: LD_VAR 0 2
102121: PPUSH
102122: LD_INT 3
102124: PPUSH
102125: LD_INT 0
102127: PPUSH
102128: CALL_OW 277
// end ;
102132: PPOPN 2
102134: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102135: LD_EXP 96
102139: IFFALSE 102147
102141: PUSH
102142: LD_EXP 124
102146: AND
102147: IFFALSE 102244
102149: GO 102151
102151: DISABLE
102152: LD_INT 0
102154: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102155: LD_ADDR_VAR 0 1
102159: PUSH
102160: LD_INT 22
102162: PUSH
102163: LD_OWVAR 2
102167: PUSH
102168: EMPTY
102169: LIST
102170: LIST
102171: PUSH
102172: LD_INT 21
102174: PUSH
102175: LD_INT 1
102177: PUSH
102178: EMPTY
102179: LIST
102180: LIST
102181: PUSH
102182: LD_INT 3
102184: PUSH
102185: LD_INT 23
102187: PUSH
102188: LD_INT 0
102190: PUSH
102191: EMPTY
102192: LIST
102193: LIST
102194: PUSH
102195: EMPTY
102196: LIST
102197: LIST
102198: PUSH
102199: EMPTY
102200: LIST
102201: LIST
102202: LIST
102203: PPUSH
102204: CALL_OW 69
102208: ST_TO_ADDR
// if not tmp then
102209: LD_VAR 0 1
102213: NOT
102214: IFFALSE 102218
// exit ;
102216: GO 102244
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102218: LD_VAR 0 1
102222: PUSH
102223: LD_INT 1
102225: PPUSH
102226: LD_VAR 0 1
102230: PPUSH
102231: CALL_OW 12
102235: ARRAY
102236: PPUSH
102237: LD_INT 200
102239: PPUSH
102240: CALL_OW 234
// end ;
102244: PPOPN 1
102246: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102247: LD_EXP 96
102251: IFFALSE 102259
102253: PUSH
102254: LD_EXP 125
102258: AND
102259: IFFALSE 102338
102261: GO 102263
102263: DISABLE
102264: LD_INT 0
102266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102267: LD_ADDR_VAR 0 1
102271: PUSH
102272: LD_INT 22
102274: PUSH
102275: LD_OWVAR 2
102279: PUSH
102280: EMPTY
102281: LIST
102282: LIST
102283: PUSH
102284: LD_INT 21
102286: PUSH
102287: LD_INT 2
102289: PUSH
102290: EMPTY
102291: LIST
102292: LIST
102293: PUSH
102294: EMPTY
102295: LIST
102296: LIST
102297: PPUSH
102298: CALL_OW 69
102302: ST_TO_ADDR
// if not tmp then
102303: LD_VAR 0 1
102307: NOT
102308: IFFALSE 102312
// exit ;
102310: GO 102338
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102312: LD_VAR 0 1
102316: PUSH
102317: LD_INT 1
102319: PPUSH
102320: LD_VAR 0 1
102324: PPUSH
102325: CALL_OW 12
102329: ARRAY
102330: PPUSH
102331: LD_INT 60
102333: PPUSH
102334: CALL_OW 234
// end ;
102338: PPOPN 1
102340: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102341: LD_EXP 96
102345: IFFALSE 102353
102347: PUSH
102348: LD_EXP 126
102352: AND
102353: IFFALSE 102452
102355: GO 102357
102357: DISABLE
102358: LD_INT 0
102360: PPUSH
102361: PPUSH
// begin enable ;
102362: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102363: LD_ADDR_VAR 0 1
102367: PUSH
102368: LD_INT 22
102370: PUSH
102371: LD_OWVAR 2
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: PUSH
102380: LD_INT 61
102382: PUSH
102383: EMPTY
102384: LIST
102385: PUSH
102386: LD_INT 33
102388: PUSH
102389: LD_INT 2
102391: PUSH
102392: EMPTY
102393: LIST
102394: LIST
102395: PUSH
102396: EMPTY
102397: LIST
102398: LIST
102399: LIST
102400: PPUSH
102401: CALL_OW 69
102405: ST_TO_ADDR
// if not tmp then
102406: LD_VAR 0 1
102410: NOT
102411: IFFALSE 102415
// exit ;
102413: GO 102452
// for i in tmp do
102415: LD_ADDR_VAR 0 2
102419: PUSH
102420: LD_VAR 0 1
102424: PUSH
102425: FOR_IN
102426: IFFALSE 102450
// if IsControledBy ( i ) then
102428: LD_VAR 0 2
102432: PPUSH
102433: CALL_OW 312
102437: IFFALSE 102448
// ComUnlink ( i ) ;
102439: LD_VAR 0 2
102443: PPUSH
102444: CALL_OW 136
102448: GO 102425
102450: POP
102451: POP
// end ;
102452: PPOPN 2
102454: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102455: LD_EXP 96
102459: IFFALSE 102467
102461: PUSH
102462: LD_EXP 127
102466: AND
102467: IFFALSE 102607
102469: GO 102471
102471: DISABLE
102472: LD_INT 0
102474: PPUSH
102475: PPUSH
// begin ToLua ( displayPowell(); ) ;
102476: LD_STRING displayPowell();
102478: PPUSH
102479: CALL_OW 559
// uc_side := 0 ;
102483: LD_ADDR_OWVAR 20
102487: PUSH
102488: LD_INT 0
102490: ST_TO_ADDR
// uc_nation := 2 ;
102491: LD_ADDR_OWVAR 21
102495: PUSH
102496: LD_INT 2
102498: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102499: LD_ADDR_OWVAR 37
102503: PUSH
102504: LD_INT 14
102506: ST_TO_ADDR
// vc_engine := engine_siberite ;
102507: LD_ADDR_OWVAR 39
102511: PUSH
102512: LD_INT 3
102514: ST_TO_ADDR
// vc_control := control_apeman ;
102515: LD_ADDR_OWVAR 38
102519: PUSH
102520: LD_INT 5
102522: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102523: LD_ADDR_OWVAR 40
102527: PUSH
102528: LD_INT 29
102530: ST_TO_ADDR
// un := CreateVehicle ;
102531: LD_ADDR_VAR 0 2
102535: PUSH
102536: CALL_OW 45
102540: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102541: LD_VAR 0 2
102545: PPUSH
102546: LD_INT 1
102548: PPUSH
102549: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102553: LD_INT 35
102555: PPUSH
102556: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102560: LD_VAR 0 2
102564: PPUSH
102565: LD_INT 22
102567: PUSH
102568: LD_OWVAR 2
102572: PUSH
102573: EMPTY
102574: LIST
102575: LIST
102576: PPUSH
102577: CALL_OW 69
102581: PPUSH
102582: LD_VAR 0 2
102586: PPUSH
102587: CALL_OW 74
102591: PPUSH
102592: CALL_OW 115
// until IsDead ( un ) ;
102596: LD_VAR 0 2
102600: PPUSH
102601: CALL_OW 301
102605: IFFALSE 102553
// end ;
102607: PPOPN 2
102609: END
// every 0 0$1 trigger StreamModeActive and sStu do
102610: LD_EXP 96
102614: IFFALSE 102622
102616: PUSH
102617: LD_EXP 135
102621: AND
102622: IFFALSE 102638
102624: GO 102626
102626: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102627: LD_STRING displayStucuk();
102629: PPUSH
102630: CALL_OW 559
// ResetFog ;
102634: CALL_OW 335
// end ;
102638: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102639: LD_EXP 96
102643: IFFALSE 102651
102645: PUSH
102646: LD_EXP 128
102650: AND
102651: IFFALSE 102792
102653: GO 102655
102655: DISABLE
102656: LD_INT 0
102658: PPUSH
102659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102660: LD_ADDR_VAR 0 2
102664: PUSH
102665: LD_INT 22
102667: PUSH
102668: LD_OWVAR 2
102672: PUSH
102673: EMPTY
102674: LIST
102675: LIST
102676: PUSH
102677: LD_INT 21
102679: PUSH
102680: LD_INT 1
102682: PUSH
102683: EMPTY
102684: LIST
102685: LIST
102686: PUSH
102687: EMPTY
102688: LIST
102689: LIST
102690: PPUSH
102691: CALL_OW 69
102695: ST_TO_ADDR
// if not tmp then
102696: LD_VAR 0 2
102700: NOT
102701: IFFALSE 102705
// exit ;
102703: GO 102792
// un := tmp [ rand ( 1 , tmp ) ] ;
102705: LD_ADDR_VAR 0 1
102709: PUSH
102710: LD_VAR 0 2
102714: PUSH
102715: LD_INT 1
102717: PPUSH
102718: LD_VAR 0 2
102722: PPUSH
102723: CALL_OW 12
102727: ARRAY
102728: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102729: LD_VAR 0 1
102733: PPUSH
102734: LD_INT 0
102736: PPUSH
102737: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102741: LD_VAR 0 1
102745: PPUSH
102746: LD_OWVAR 3
102750: PUSH
102751: LD_VAR 0 1
102755: DIFF
102756: PPUSH
102757: LD_VAR 0 1
102761: PPUSH
102762: CALL_OW 74
102766: PPUSH
102767: CALL_OW 115
// wait ( 0 0$20 ) ;
102771: LD_INT 700
102773: PPUSH
102774: CALL_OW 67
// SetSide ( un , your_side ) ;
102778: LD_VAR 0 1
102782: PPUSH
102783: LD_OWVAR 2
102787: PPUSH
102788: CALL_OW 235
// end ;
102792: PPOPN 2
102794: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102795: LD_EXP 96
102799: IFFALSE 102807
102801: PUSH
102802: LD_EXP 129
102806: AND
102807: IFFALSE 102913
102809: GO 102811
102811: DISABLE
102812: LD_INT 0
102814: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102815: LD_ADDR_VAR 0 1
102819: PUSH
102820: LD_INT 22
102822: PUSH
102823: LD_OWVAR 2
102827: PUSH
102828: EMPTY
102829: LIST
102830: LIST
102831: PUSH
102832: LD_INT 2
102834: PUSH
102835: LD_INT 30
102837: PUSH
102838: LD_INT 0
102840: PUSH
102841: EMPTY
102842: LIST
102843: LIST
102844: PUSH
102845: LD_INT 30
102847: PUSH
102848: LD_INT 1
102850: PUSH
102851: EMPTY
102852: LIST
102853: LIST
102854: PUSH
102855: EMPTY
102856: LIST
102857: LIST
102858: LIST
102859: PUSH
102860: EMPTY
102861: LIST
102862: LIST
102863: PPUSH
102864: CALL_OW 69
102868: ST_TO_ADDR
// if not depot then
102869: LD_VAR 0 1
102873: NOT
102874: IFFALSE 102878
// exit ;
102876: GO 102913
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102878: LD_VAR 0 1
102882: PUSH
102883: LD_INT 1
102885: ARRAY
102886: PPUSH
102887: CALL_OW 250
102891: PPUSH
102892: LD_VAR 0 1
102896: PUSH
102897: LD_INT 1
102899: ARRAY
102900: PPUSH
102901: CALL_OW 251
102905: PPUSH
102906: LD_INT 70
102908: PPUSH
102909: CALL_OW 495
// end ;
102913: PPOPN 1
102915: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102916: LD_EXP 96
102920: IFFALSE 102928
102922: PUSH
102923: LD_EXP 130
102927: AND
102928: IFFALSE 103139
102930: GO 102932
102932: DISABLE
102933: LD_INT 0
102935: PPUSH
102936: PPUSH
102937: PPUSH
102938: PPUSH
102939: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102940: LD_ADDR_VAR 0 5
102944: PUSH
102945: LD_INT 22
102947: PUSH
102948: LD_OWVAR 2
102952: PUSH
102953: EMPTY
102954: LIST
102955: LIST
102956: PUSH
102957: LD_INT 21
102959: PUSH
102960: LD_INT 1
102962: PUSH
102963: EMPTY
102964: LIST
102965: LIST
102966: PUSH
102967: EMPTY
102968: LIST
102969: LIST
102970: PPUSH
102971: CALL_OW 69
102975: ST_TO_ADDR
// if not tmp then
102976: LD_VAR 0 5
102980: NOT
102981: IFFALSE 102985
// exit ;
102983: GO 103139
// for i in tmp do
102985: LD_ADDR_VAR 0 1
102989: PUSH
102990: LD_VAR 0 5
102994: PUSH
102995: FOR_IN
102996: IFFALSE 103137
// begin d := rand ( 0 , 5 ) ;
102998: LD_ADDR_VAR 0 4
103002: PUSH
103003: LD_INT 0
103005: PPUSH
103006: LD_INT 5
103008: PPUSH
103009: CALL_OW 12
103013: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103014: LD_ADDR_VAR 0 2
103018: PUSH
103019: LD_VAR 0 1
103023: PPUSH
103024: CALL_OW 250
103028: PPUSH
103029: LD_VAR 0 4
103033: PPUSH
103034: LD_INT 3
103036: PPUSH
103037: LD_INT 12
103039: PPUSH
103040: CALL_OW 12
103044: PPUSH
103045: CALL_OW 272
103049: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103050: LD_ADDR_VAR 0 3
103054: PUSH
103055: LD_VAR 0 1
103059: PPUSH
103060: CALL_OW 251
103064: PPUSH
103065: LD_VAR 0 4
103069: PPUSH
103070: LD_INT 3
103072: PPUSH
103073: LD_INT 12
103075: PPUSH
103076: CALL_OW 12
103080: PPUSH
103081: CALL_OW 273
103085: ST_TO_ADDR
// if ValidHex ( x , y ) then
103086: LD_VAR 0 2
103090: PPUSH
103091: LD_VAR 0 3
103095: PPUSH
103096: CALL_OW 488
103100: IFFALSE 103135
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103102: LD_VAR 0 1
103106: PPUSH
103107: LD_VAR 0 2
103111: PPUSH
103112: LD_VAR 0 3
103116: PPUSH
103117: LD_INT 3
103119: PPUSH
103120: LD_INT 6
103122: PPUSH
103123: CALL_OW 12
103127: PPUSH
103128: LD_INT 1
103130: PPUSH
103131: CALL_OW 483
// end ;
103135: GO 102995
103137: POP
103138: POP
// end ;
103139: PPOPN 5
103141: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103142: LD_EXP 96
103146: IFFALSE 103154
103148: PUSH
103149: LD_EXP 131
103153: AND
103154: IFFALSE 103248
103156: GO 103158
103158: DISABLE
103159: LD_INT 0
103161: PPUSH
103162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103163: LD_ADDR_VAR 0 2
103167: PUSH
103168: LD_INT 22
103170: PUSH
103171: LD_OWVAR 2
103175: PUSH
103176: EMPTY
103177: LIST
103178: LIST
103179: PUSH
103180: LD_INT 32
103182: PUSH
103183: LD_INT 1
103185: PUSH
103186: EMPTY
103187: LIST
103188: LIST
103189: PUSH
103190: LD_INT 21
103192: PUSH
103193: LD_INT 2
103195: PUSH
103196: EMPTY
103197: LIST
103198: LIST
103199: PUSH
103200: EMPTY
103201: LIST
103202: LIST
103203: LIST
103204: PPUSH
103205: CALL_OW 69
103209: ST_TO_ADDR
// if not tmp then
103210: LD_VAR 0 2
103214: NOT
103215: IFFALSE 103219
// exit ;
103217: GO 103248
// for i in tmp do
103219: LD_ADDR_VAR 0 1
103223: PUSH
103224: LD_VAR 0 2
103228: PUSH
103229: FOR_IN
103230: IFFALSE 103246
// SetFuel ( i , 0 ) ;
103232: LD_VAR 0 1
103236: PPUSH
103237: LD_INT 0
103239: PPUSH
103240: CALL_OW 240
103244: GO 103229
103246: POP
103247: POP
// end ;
103248: PPOPN 2
103250: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103251: LD_EXP 96
103255: IFFALSE 103263
103257: PUSH
103258: LD_EXP 132
103262: AND
103263: IFFALSE 103329
103265: GO 103267
103267: DISABLE
103268: LD_INT 0
103270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103271: LD_ADDR_VAR 0 1
103275: PUSH
103276: LD_INT 22
103278: PUSH
103279: LD_OWVAR 2
103283: PUSH
103284: EMPTY
103285: LIST
103286: LIST
103287: PUSH
103288: LD_INT 30
103290: PUSH
103291: LD_INT 29
103293: PUSH
103294: EMPTY
103295: LIST
103296: LIST
103297: PUSH
103298: EMPTY
103299: LIST
103300: LIST
103301: PPUSH
103302: CALL_OW 69
103306: ST_TO_ADDR
// if not tmp then
103307: LD_VAR 0 1
103311: NOT
103312: IFFALSE 103316
// exit ;
103314: GO 103329
// DestroyUnit ( tmp [ 1 ] ) ;
103316: LD_VAR 0 1
103320: PUSH
103321: LD_INT 1
103323: ARRAY
103324: PPUSH
103325: CALL_OW 65
// end ;
103329: PPOPN 1
103331: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103332: LD_EXP 96
103336: IFFALSE 103344
103338: PUSH
103339: LD_EXP 134
103343: AND
103344: IFFALSE 103473
103346: GO 103348
103348: DISABLE
103349: LD_INT 0
103351: PPUSH
// begin uc_side := 0 ;
103352: LD_ADDR_OWVAR 20
103356: PUSH
103357: LD_INT 0
103359: ST_TO_ADDR
// uc_nation := nation_arabian ;
103360: LD_ADDR_OWVAR 21
103364: PUSH
103365: LD_INT 2
103367: ST_TO_ADDR
// hc_gallery :=  ;
103368: LD_ADDR_OWVAR 33
103372: PUSH
103373: LD_STRING 
103375: ST_TO_ADDR
// hc_name :=  ;
103376: LD_ADDR_OWVAR 26
103380: PUSH
103381: LD_STRING 
103383: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103384: LD_INT 1
103386: PPUSH
103387: LD_INT 11
103389: PPUSH
103390: LD_INT 10
103392: PPUSH
103393: CALL_OW 380
// un := CreateHuman ;
103397: LD_ADDR_VAR 0 1
103401: PUSH
103402: CALL_OW 44
103406: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103407: LD_VAR 0 1
103411: PPUSH
103412: LD_INT 1
103414: PPUSH
103415: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103419: LD_INT 35
103421: PPUSH
103422: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103426: LD_VAR 0 1
103430: PPUSH
103431: LD_INT 22
103433: PUSH
103434: LD_OWVAR 2
103438: PUSH
103439: EMPTY
103440: LIST
103441: LIST
103442: PPUSH
103443: CALL_OW 69
103447: PPUSH
103448: LD_VAR 0 1
103452: PPUSH
103453: CALL_OW 74
103457: PPUSH
103458: CALL_OW 115
// until IsDead ( un ) ;
103462: LD_VAR 0 1
103466: PPUSH
103467: CALL_OW 301
103471: IFFALSE 103419
// end ;
103473: PPOPN 1
103475: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103476: LD_EXP 96
103480: IFFALSE 103488
103482: PUSH
103483: LD_EXP 136
103487: AND
103488: IFFALSE 103500
103490: GO 103492
103492: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103493: LD_STRING earthquake(getX(game), 0, 32)
103495: PPUSH
103496: CALL_OW 559
103500: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103501: LD_EXP 96
103505: IFFALSE 103513
103507: PUSH
103508: LD_EXP 137
103512: AND
103513: IFFALSE 103604
103515: GO 103517
103517: DISABLE
103518: LD_INT 0
103520: PPUSH
// begin enable ;
103521: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103522: LD_ADDR_VAR 0 1
103526: PUSH
103527: LD_INT 22
103529: PUSH
103530: LD_OWVAR 2
103534: PUSH
103535: EMPTY
103536: LIST
103537: LIST
103538: PUSH
103539: LD_INT 21
103541: PUSH
103542: LD_INT 2
103544: PUSH
103545: EMPTY
103546: LIST
103547: LIST
103548: PUSH
103549: LD_INT 33
103551: PUSH
103552: LD_INT 3
103554: PUSH
103555: EMPTY
103556: LIST
103557: LIST
103558: PUSH
103559: EMPTY
103560: LIST
103561: LIST
103562: LIST
103563: PPUSH
103564: CALL_OW 69
103568: ST_TO_ADDR
// if not tmp then
103569: LD_VAR 0 1
103573: NOT
103574: IFFALSE 103578
// exit ;
103576: GO 103604
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103578: LD_VAR 0 1
103582: PUSH
103583: LD_INT 1
103585: PPUSH
103586: LD_VAR 0 1
103590: PPUSH
103591: CALL_OW 12
103595: ARRAY
103596: PPUSH
103597: LD_INT 1
103599: PPUSH
103600: CALL_OW 234
// end ;
103604: PPOPN 1
103606: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103607: LD_EXP 96
103611: IFFALSE 103619
103613: PUSH
103614: LD_EXP 138
103618: AND
103619: IFFALSE 103760
103621: GO 103623
103623: DISABLE
103624: LD_INT 0
103626: PPUSH
103627: PPUSH
103628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103629: LD_ADDR_VAR 0 3
103633: PUSH
103634: LD_INT 22
103636: PUSH
103637: LD_OWVAR 2
103641: PUSH
103642: EMPTY
103643: LIST
103644: LIST
103645: PUSH
103646: LD_INT 25
103648: PUSH
103649: LD_INT 1
103651: PUSH
103652: EMPTY
103653: LIST
103654: LIST
103655: PUSH
103656: EMPTY
103657: LIST
103658: LIST
103659: PPUSH
103660: CALL_OW 69
103664: ST_TO_ADDR
// if not tmp then
103665: LD_VAR 0 3
103669: NOT
103670: IFFALSE 103674
// exit ;
103672: GO 103760
// un := tmp [ rand ( 1 , tmp ) ] ;
103674: LD_ADDR_VAR 0 2
103678: PUSH
103679: LD_VAR 0 3
103683: PUSH
103684: LD_INT 1
103686: PPUSH
103687: LD_VAR 0 3
103691: PPUSH
103692: CALL_OW 12
103696: ARRAY
103697: ST_TO_ADDR
// if Crawls ( un ) then
103698: LD_VAR 0 2
103702: PPUSH
103703: CALL_OW 318
103707: IFFALSE 103718
// ComWalk ( un ) ;
103709: LD_VAR 0 2
103713: PPUSH
103714: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103718: LD_VAR 0 2
103722: PPUSH
103723: LD_INT 9
103725: PPUSH
103726: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103730: LD_INT 28
103732: PPUSH
103733: LD_OWVAR 2
103737: PPUSH
103738: LD_INT 2
103740: PPUSH
103741: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103745: LD_INT 29
103747: PPUSH
103748: LD_OWVAR 2
103752: PPUSH
103753: LD_INT 2
103755: PPUSH
103756: CALL_OW 322
// end ;
103760: PPOPN 3
103762: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103763: LD_EXP 96
103767: IFFALSE 103775
103769: PUSH
103770: LD_EXP 139
103774: AND
103775: IFFALSE 103886
103777: GO 103779
103779: DISABLE
103780: LD_INT 0
103782: PPUSH
103783: PPUSH
103784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103785: LD_ADDR_VAR 0 3
103789: PUSH
103790: LD_INT 22
103792: PUSH
103793: LD_OWVAR 2
103797: PUSH
103798: EMPTY
103799: LIST
103800: LIST
103801: PUSH
103802: LD_INT 25
103804: PUSH
103805: LD_INT 1
103807: PUSH
103808: EMPTY
103809: LIST
103810: LIST
103811: PUSH
103812: EMPTY
103813: LIST
103814: LIST
103815: PPUSH
103816: CALL_OW 69
103820: ST_TO_ADDR
// if not tmp then
103821: LD_VAR 0 3
103825: NOT
103826: IFFALSE 103830
// exit ;
103828: GO 103886
// un := tmp [ rand ( 1 , tmp ) ] ;
103830: LD_ADDR_VAR 0 2
103834: PUSH
103835: LD_VAR 0 3
103839: PUSH
103840: LD_INT 1
103842: PPUSH
103843: LD_VAR 0 3
103847: PPUSH
103848: CALL_OW 12
103852: ARRAY
103853: ST_TO_ADDR
// if Crawls ( un ) then
103854: LD_VAR 0 2
103858: PPUSH
103859: CALL_OW 318
103863: IFFALSE 103874
// ComWalk ( un ) ;
103865: LD_VAR 0 2
103869: PPUSH
103870: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103874: LD_VAR 0 2
103878: PPUSH
103879: LD_INT 8
103881: PPUSH
103882: CALL_OW 336
// end ;
103886: PPOPN 3
103888: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103889: LD_EXP 96
103893: IFFALSE 103901
103895: PUSH
103896: LD_EXP 140
103900: AND
103901: IFFALSE 104045
103903: GO 103905
103905: DISABLE
103906: LD_INT 0
103908: PPUSH
103909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103910: LD_ADDR_VAR 0 2
103914: PUSH
103915: LD_INT 22
103917: PUSH
103918: LD_OWVAR 2
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: PUSH
103927: LD_INT 21
103929: PUSH
103930: LD_INT 2
103932: PUSH
103933: EMPTY
103934: LIST
103935: LIST
103936: PUSH
103937: LD_INT 2
103939: PUSH
103940: LD_INT 34
103942: PUSH
103943: LD_INT 12
103945: PUSH
103946: EMPTY
103947: LIST
103948: LIST
103949: PUSH
103950: LD_INT 34
103952: PUSH
103953: LD_INT 51
103955: PUSH
103956: EMPTY
103957: LIST
103958: LIST
103959: PUSH
103960: LD_INT 34
103962: PUSH
103963: LD_INT 32
103965: PUSH
103966: EMPTY
103967: LIST
103968: LIST
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: LIST
103974: LIST
103975: PUSH
103976: EMPTY
103977: LIST
103978: LIST
103979: LIST
103980: PPUSH
103981: CALL_OW 69
103985: ST_TO_ADDR
// if not tmp then
103986: LD_VAR 0 2
103990: NOT
103991: IFFALSE 103995
// exit ;
103993: GO 104045
// for i in tmp do
103995: LD_ADDR_VAR 0 1
103999: PUSH
104000: LD_VAR 0 2
104004: PUSH
104005: FOR_IN
104006: IFFALSE 104043
// if GetCargo ( i , mat_artifact ) = 0 then
104008: LD_VAR 0 1
104012: PPUSH
104013: LD_INT 4
104015: PPUSH
104016: CALL_OW 289
104020: PUSH
104021: LD_INT 0
104023: EQUAL
104024: IFFALSE 104041
// SetCargo ( i , mat_siberit , 100 ) ;
104026: LD_VAR 0 1
104030: PPUSH
104031: LD_INT 3
104033: PPUSH
104034: LD_INT 100
104036: PPUSH
104037: CALL_OW 290
104041: GO 104005
104043: POP
104044: POP
// end ;
104045: PPOPN 2
104047: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104048: LD_EXP 96
104052: IFFALSE 104060
104054: PUSH
104055: LD_EXP 141
104059: AND
104060: IFFALSE 104243
104062: GO 104064
104064: DISABLE
104065: LD_INT 0
104067: PPUSH
104068: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104069: LD_ADDR_VAR 0 2
104073: PUSH
104074: LD_INT 22
104076: PUSH
104077: LD_OWVAR 2
104081: PUSH
104082: EMPTY
104083: LIST
104084: LIST
104085: PPUSH
104086: CALL_OW 69
104090: ST_TO_ADDR
// if not tmp then
104091: LD_VAR 0 2
104095: NOT
104096: IFFALSE 104100
// exit ;
104098: GO 104243
// for i := 1 to 2 do
104100: LD_ADDR_VAR 0 1
104104: PUSH
104105: DOUBLE
104106: LD_INT 1
104108: DEC
104109: ST_TO_ADDR
104110: LD_INT 2
104112: PUSH
104113: FOR_TO
104114: IFFALSE 104241
// begin uc_side := your_side ;
104116: LD_ADDR_OWVAR 20
104120: PUSH
104121: LD_OWVAR 2
104125: ST_TO_ADDR
// uc_nation := nation_american ;
104126: LD_ADDR_OWVAR 21
104130: PUSH
104131: LD_INT 1
104133: ST_TO_ADDR
// vc_chassis := us_morphling ;
104134: LD_ADDR_OWVAR 37
104138: PUSH
104139: LD_INT 5
104141: ST_TO_ADDR
// vc_engine := engine_siberite ;
104142: LD_ADDR_OWVAR 39
104146: PUSH
104147: LD_INT 3
104149: ST_TO_ADDR
// vc_control := control_computer ;
104150: LD_ADDR_OWVAR 38
104154: PUSH
104155: LD_INT 3
104157: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104158: LD_ADDR_OWVAR 40
104162: PUSH
104163: LD_INT 10
104165: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104166: LD_VAR 0 2
104170: PUSH
104171: LD_INT 1
104173: ARRAY
104174: PPUSH
104175: CALL_OW 310
104179: NOT
104180: IFFALSE 104227
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104182: CALL_OW 45
104186: PPUSH
104187: LD_VAR 0 2
104191: PUSH
104192: LD_INT 1
104194: ARRAY
104195: PPUSH
104196: CALL_OW 250
104200: PPUSH
104201: LD_VAR 0 2
104205: PUSH
104206: LD_INT 1
104208: ARRAY
104209: PPUSH
104210: CALL_OW 251
104214: PPUSH
104215: LD_INT 12
104217: PPUSH
104218: LD_INT 1
104220: PPUSH
104221: CALL_OW 50
104225: GO 104239
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104227: CALL_OW 45
104231: PPUSH
104232: LD_INT 1
104234: PPUSH
104235: CALL_OW 51
// end ;
104239: GO 104113
104241: POP
104242: POP
// end ;
104243: PPOPN 2
104245: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104246: LD_EXP 96
104250: IFFALSE 104258
104252: PUSH
104253: LD_EXP 142
104257: AND
104258: IFFALSE 104480
104260: GO 104262
104262: DISABLE
104263: LD_INT 0
104265: PPUSH
104266: PPUSH
104267: PPUSH
104268: PPUSH
104269: PPUSH
104270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104271: LD_ADDR_VAR 0 6
104275: PUSH
104276: LD_INT 22
104278: PUSH
104279: LD_OWVAR 2
104283: PUSH
104284: EMPTY
104285: LIST
104286: LIST
104287: PUSH
104288: LD_INT 21
104290: PUSH
104291: LD_INT 1
104293: PUSH
104294: EMPTY
104295: LIST
104296: LIST
104297: PUSH
104298: LD_INT 3
104300: PUSH
104301: LD_INT 23
104303: PUSH
104304: LD_INT 0
104306: PUSH
104307: EMPTY
104308: LIST
104309: LIST
104310: PUSH
104311: EMPTY
104312: LIST
104313: LIST
104314: PUSH
104315: EMPTY
104316: LIST
104317: LIST
104318: LIST
104319: PPUSH
104320: CALL_OW 69
104324: ST_TO_ADDR
// if not tmp then
104325: LD_VAR 0 6
104329: NOT
104330: IFFALSE 104334
// exit ;
104332: GO 104480
// s1 := rand ( 1 , 4 ) ;
104334: LD_ADDR_VAR 0 2
104338: PUSH
104339: LD_INT 1
104341: PPUSH
104342: LD_INT 4
104344: PPUSH
104345: CALL_OW 12
104349: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104350: LD_ADDR_VAR 0 4
104354: PUSH
104355: LD_VAR 0 6
104359: PUSH
104360: LD_INT 1
104362: ARRAY
104363: PPUSH
104364: LD_VAR 0 2
104368: PPUSH
104369: CALL_OW 259
104373: ST_TO_ADDR
// if s1 = 1 then
104374: LD_VAR 0 2
104378: PUSH
104379: LD_INT 1
104381: EQUAL
104382: IFFALSE 104402
// s2 := rand ( 2 , 4 ) else
104384: LD_ADDR_VAR 0 3
104388: PUSH
104389: LD_INT 2
104391: PPUSH
104392: LD_INT 4
104394: PPUSH
104395: CALL_OW 12
104399: ST_TO_ADDR
104400: GO 104410
// s2 := 1 ;
104402: LD_ADDR_VAR 0 3
104406: PUSH
104407: LD_INT 1
104409: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104410: LD_ADDR_VAR 0 5
104414: PUSH
104415: LD_VAR 0 6
104419: PUSH
104420: LD_INT 1
104422: ARRAY
104423: PPUSH
104424: LD_VAR 0 3
104428: PPUSH
104429: CALL_OW 259
104433: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104434: LD_VAR 0 6
104438: PUSH
104439: LD_INT 1
104441: ARRAY
104442: PPUSH
104443: LD_VAR 0 2
104447: PPUSH
104448: LD_VAR 0 5
104452: PPUSH
104453: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104457: LD_VAR 0 6
104461: PUSH
104462: LD_INT 1
104464: ARRAY
104465: PPUSH
104466: LD_VAR 0 3
104470: PPUSH
104471: LD_VAR 0 4
104475: PPUSH
104476: CALL_OW 237
// end ;
104480: PPOPN 6
104482: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104483: LD_EXP 96
104487: IFFALSE 104495
104489: PUSH
104490: LD_EXP 143
104494: AND
104495: IFFALSE 104574
104497: GO 104499
104499: DISABLE
104500: LD_INT 0
104502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104503: LD_ADDR_VAR 0 1
104507: PUSH
104508: LD_INT 22
104510: PUSH
104511: LD_OWVAR 2
104515: PUSH
104516: EMPTY
104517: LIST
104518: LIST
104519: PUSH
104520: LD_INT 30
104522: PUSH
104523: LD_INT 3
104525: PUSH
104526: EMPTY
104527: LIST
104528: LIST
104529: PUSH
104530: EMPTY
104531: LIST
104532: LIST
104533: PPUSH
104534: CALL_OW 69
104538: ST_TO_ADDR
// if not tmp then
104539: LD_VAR 0 1
104543: NOT
104544: IFFALSE 104548
// exit ;
104546: GO 104574
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104548: LD_VAR 0 1
104552: PUSH
104553: LD_INT 1
104555: PPUSH
104556: LD_VAR 0 1
104560: PPUSH
104561: CALL_OW 12
104565: ARRAY
104566: PPUSH
104567: LD_INT 1
104569: PPUSH
104570: CALL_OW 234
// end ;
104574: PPOPN 1
104576: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104577: LD_EXP 96
104581: IFFALSE 104589
104583: PUSH
104584: LD_EXP 144
104588: AND
104589: IFFALSE 104701
104591: GO 104593
104593: DISABLE
104594: LD_INT 0
104596: PPUSH
104597: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104598: LD_ADDR_VAR 0 2
104602: PUSH
104603: LD_INT 22
104605: PUSH
104606: LD_OWVAR 2
104610: PUSH
104611: EMPTY
104612: LIST
104613: LIST
104614: PUSH
104615: LD_INT 2
104617: PUSH
104618: LD_INT 30
104620: PUSH
104621: LD_INT 27
104623: PUSH
104624: EMPTY
104625: LIST
104626: LIST
104627: PUSH
104628: LD_INT 30
104630: PUSH
104631: LD_INT 26
104633: PUSH
104634: EMPTY
104635: LIST
104636: LIST
104637: PUSH
104638: LD_INT 30
104640: PUSH
104641: LD_INT 28
104643: PUSH
104644: EMPTY
104645: LIST
104646: LIST
104647: PUSH
104648: EMPTY
104649: LIST
104650: LIST
104651: LIST
104652: LIST
104653: PUSH
104654: EMPTY
104655: LIST
104656: LIST
104657: PPUSH
104658: CALL_OW 69
104662: ST_TO_ADDR
// if not tmp then
104663: LD_VAR 0 2
104667: NOT
104668: IFFALSE 104672
// exit ;
104670: GO 104701
// for i in tmp do
104672: LD_ADDR_VAR 0 1
104676: PUSH
104677: LD_VAR 0 2
104681: PUSH
104682: FOR_IN
104683: IFFALSE 104699
// SetLives ( i , 1 ) ;
104685: LD_VAR 0 1
104689: PPUSH
104690: LD_INT 1
104692: PPUSH
104693: CALL_OW 234
104697: GO 104682
104699: POP
104700: POP
// end ;
104701: PPOPN 2
104703: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104704: LD_EXP 96
104708: IFFALSE 104716
104710: PUSH
104711: LD_EXP 145
104715: AND
104716: IFFALSE 105003
104718: GO 104720
104720: DISABLE
104721: LD_INT 0
104723: PPUSH
104724: PPUSH
104725: PPUSH
// begin i := rand ( 1 , 7 ) ;
104726: LD_ADDR_VAR 0 1
104730: PUSH
104731: LD_INT 1
104733: PPUSH
104734: LD_INT 7
104736: PPUSH
104737: CALL_OW 12
104741: ST_TO_ADDR
// case i of 1 :
104742: LD_VAR 0 1
104746: PUSH
104747: LD_INT 1
104749: DOUBLE
104750: EQUAL
104751: IFTRUE 104755
104753: GO 104765
104755: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104756: LD_STRING earthquake(getX(game), 0, 32)
104758: PPUSH
104759: CALL_OW 559
104763: GO 105003
104765: LD_INT 2
104767: DOUBLE
104768: EQUAL
104769: IFTRUE 104773
104771: GO 104787
104773: POP
// begin ToLua ( displayStucuk(); ) ;
104774: LD_STRING displayStucuk();
104776: PPUSH
104777: CALL_OW 559
// ResetFog ;
104781: CALL_OW 335
// end ; 3 :
104785: GO 105003
104787: LD_INT 3
104789: DOUBLE
104790: EQUAL
104791: IFTRUE 104795
104793: GO 104899
104795: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104796: LD_ADDR_VAR 0 2
104800: PUSH
104801: LD_INT 22
104803: PUSH
104804: LD_OWVAR 2
104808: PUSH
104809: EMPTY
104810: LIST
104811: LIST
104812: PUSH
104813: LD_INT 25
104815: PUSH
104816: LD_INT 1
104818: PUSH
104819: EMPTY
104820: LIST
104821: LIST
104822: PUSH
104823: EMPTY
104824: LIST
104825: LIST
104826: PPUSH
104827: CALL_OW 69
104831: ST_TO_ADDR
// if not tmp then
104832: LD_VAR 0 2
104836: NOT
104837: IFFALSE 104841
// exit ;
104839: GO 105003
// un := tmp [ rand ( 1 , tmp ) ] ;
104841: LD_ADDR_VAR 0 3
104845: PUSH
104846: LD_VAR 0 2
104850: PUSH
104851: LD_INT 1
104853: PPUSH
104854: LD_VAR 0 2
104858: PPUSH
104859: CALL_OW 12
104863: ARRAY
104864: ST_TO_ADDR
// if Crawls ( un ) then
104865: LD_VAR 0 3
104869: PPUSH
104870: CALL_OW 318
104874: IFFALSE 104885
// ComWalk ( un ) ;
104876: LD_VAR 0 3
104880: PPUSH
104881: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104885: LD_VAR 0 3
104889: PPUSH
104890: LD_INT 8
104892: PPUSH
104893: CALL_OW 336
// end ; 4 :
104897: GO 105003
104899: LD_INT 4
104901: DOUBLE
104902: EQUAL
104903: IFTRUE 104907
104905: GO 104981
104907: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104908: LD_ADDR_VAR 0 2
104912: PUSH
104913: LD_INT 22
104915: PUSH
104916: LD_OWVAR 2
104920: PUSH
104921: EMPTY
104922: LIST
104923: LIST
104924: PUSH
104925: LD_INT 30
104927: PUSH
104928: LD_INT 29
104930: PUSH
104931: EMPTY
104932: LIST
104933: LIST
104934: PUSH
104935: EMPTY
104936: LIST
104937: LIST
104938: PPUSH
104939: CALL_OW 69
104943: ST_TO_ADDR
// if not tmp then
104944: LD_VAR 0 2
104948: NOT
104949: IFFALSE 104953
// exit ;
104951: GO 105003
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104953: LD_VAR 0 2
104957: PUSH
104958: LD_INT 1
104960: ARRAY
104961: PPUSH
104962: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104966: LD_VAR 0 2
104970: PUSH
104971: LD_INT 1
104973: ARRAY
104974: PPUSH
104975: CALL_OW 65
// end ; 5 .. 7 :
104979: GO 105003
104981: LD_INT 5
104983: DOUBLE
104984: GREATEREQUAL
104985: IFFALSE 104993
104987: LD_INT 7
104989: DOUBLE
104990: LESSEQUAL
104991: IFTRUE 104995
104993: GO 105002
104995: POP
// StreamSibBomb ; end ;
104996: CALL 101184 0 0
105000: GO 105003
105002: POP
// end ;
105003: PPOPN 3
105005: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105006: LD_EXP 96
105010: IFFALSE 105018
105012: PUSH
105013: LD_EXP 146
105017: AND
105018: IFFALSE 105174
105020: GO 105022
105022: DISABLE
105023: LD_INT 0
105025: PPUSH
105026: PPUSH
105027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105028: LD_ADDR_VAR 0 2
105032: PUSH
105033: LD_INT 81
105035: PUSH
105036: LD_OWVAR 2
105040: PUSH
105041: EMPTY
105042: LIST
105043: LIST
105044: PUSH
105045: LD_INT 2
105047: PUSH
105048: LD_INT 21
105050: PUSH
105051: LD_INT 1
105053: PUSH
105054: EMPTY
105055: LIST
105056: LIST
105057: PUSH
105058: LD_INT 21
105060: PUSH
105061: LD_INT 2
105063: PUSH
105064: EMPTY
105065: LIST
105066: LIST
105067: PUSH
105068: EMPTY
105069: LIST
105070: LIST
105071: LIST
105072: PUSH
105073: EMPTY
105074: LIST
105075: LIST
105076: PPUSH
105077: CALL_OW 69
105081: ST_TO_ADDR
// if not tmp then
105082: LD_VAR 0 2
105086: NOT
105087: IFFALSE 105091
// exit ;
105089: GO 105174
// p := 0 ;
105091: LD_ADDR_VAR 0 3
105095: PUSH
105096: LD_INT 0
105098: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105099: LD_INT 35
105101: PPUSH
105102: CALL_OW 67
// p := p + 1 ;
105106: LD_ADDR_VAR 0 3
105110: PUSH
105111: LD_VAR 0 3
105115: PUSH
105116: LD_INT 1
105118: PLUS
105119: ST_TO_ADDR
// for i in tmp do
105120: LD_ADDR_VAR 0 1
105124: PUSH
105125: LD_VAR 0 2
105129: PUSH
105130: FOR_IN
105131: IFFALSE 105162
// if GetLives ( i ) < 1000 then
105133: LD_VAR 0 1
105137: PPUSH
105138: CALL_OW 256
105142: PUSH
105143: LD_INT 1000
105145: LESS
105146: IFFALSE 105160
// SetLives ( i , 1000 ) ;
105148: LD_VAR 0 1
105152: PPUSH
105153: LD_INT 1000
105155: PPUSH
105156: CALL_OW 234
105160: GO 105130
105162: POP
105163: POP
// until p > 20 ;
105164: LD_VAR 0 3
105168: PUSH
105169: LD_INT 20
105171: GREATER
105172: IFFALSE 105099
// end ;
105174: PPOPN 3
105176: END
// every 0 0$1 trigger StreamModeActive and sTime do
105177: LD_EXP 96
105181: IFFALSE 105189
105183: PUSH
105184: LD_EXP 147
105188: AND
105189: IFFALSE 105224
105191: GO 105193
105193: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105194: LD_INT 28
105196: PPUSH
105197: LD_OWVAR 2
105201: PPUSH
105202: LD_INT 2
105204: PPUSH
105205: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105209: LD_INT 30
105211: PPUSH
105212: LD_OWVAR 2
105216: PPUSH
105217: LD_INT 2
105219: PPUSH
105220: CALL_OW 322
// end ;
105224: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105225: LD_EXP 96
105229: IFFALSE 105237
105231: PUSH
105232: LD_EXP 148
105236: AND
105237: IFFALSE 105358
105239: GO 105241
105241: DISABLE
105242: LD_INT 0
105244: PPUSH
105245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105246: LD_ADDR_VAR 0 2
105250: PUSH
105251: LD_INT 22
105253: PUSH
105254: LD_OWVAR 2
105258: PUSH
105259: EMPTY
105260: LIST
105261: LIST
105262: PUSH
105263: LD_INT 21
105265: PUSH
105266: LD_INT 1
105268: PUSH
105269: EMPTY
105270: LIST
105271: LIST
105272: PUSH
105273: LD_INT 3
105275: PUSH
105276: LD_INT 23
105278: PUSH
105279: LD_INT 0
105281: PUSH
105282: EMPTY
105283: LIST
105284: LIST
105285: PUSH
105286: EMPTY
105287: LIST
105288: LIST
105289: PUSH
105290: EMPTY
105291: LIST
105292: LIST
105293: LIST
105294: PPUSH
105295: CALL_OW 69
105299: ST_TO_ADDR
// if not tmp then
105300: LD_VAR 0 2
105304: NOT
105305: IFFALSE 105309
// exit ;
105307: GO 105358
// for i in tmp do
105309: LD_ADDR_VAR 0 1
105313: PUSH
105314: LD_VAR 0 2
105318: PUSH
105319: FOR_IN
105320: IFFALSE 105356
// begin if Crawls ( i ) then
105322: LD_VAR 0 1
105326: PPUSH
105327: CALL_OW 318
105331: IFFALSE 105342
// ComWalk ( i ) ;
105333: LD_VAR 0 1
105337: PPUSH
105338: CALL_OW 138
// SetClass ( i , 2 ) ;
105342: LD_VAR 0 1
105346: PPUSH
105347: LD_INT 2
105349: PPUSH
105350: CALL_OW 336
// end ;
105354: GO 105319
105356: POP
105357: POP
// end ;
105358: PPOPN 2
105360: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105361: LD_EXP 96
105365: IFFALSE 105373
105367: PUSH
105368: LD_EXP 149
105372: AND
105373: IFFALSE 105663
105375: GO 105377
105377: DISABLE
105378: LD_INT 0
105380: PPUSH
105381: PPUSH
105382: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105383: LD_OWVAR 2
105387: PPUSH
105388: LD_INT 9
105390: PPUSH
105391: LD_INT 1
105393: PPUSH
105394: LD_INT 1
105396: PPUSH
105397: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105401: LD_INT 9
105403: PPUSH
105404: LD_OWVAR 2
105408: PPUSH
105409: CALL_OW 343
// uc_side := 9 ;
105413: LD_ADDR_OWVAR 20
105417: PUSH
105418: LD_INT 9
105420: ST_TO_ADDR
// uc_nation := 2 ;
105421: LD_ADDR_OWVAR 21
105425: PUSH
105426: LD_INT 2
105428: ST_TO_ADDR
// hc_name := Dark Warrior ;
105429: LD_ADDR_OWVAR 26
105433: PUSH
105434: LD_STRING Dark Warrior
105436: ST_TO_ADDR
// hc_gallery :=  ;
105437: LD_ADDR_OWVAR 33
105441: PUSH
105442: LD_STRING 
105444: ST_TO_ADDR
// hc_noskilllimit := true ;
105445: LD_ADDR_OWVAR 76
105449: PUSH
105450: LD_INT 1
105452: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105453: LD_ADDR_OWVAR 31
105457: PUSH
105458: LD_INT 30
105460: PUSH
105461: LD_INT 30
105463: PUSH
105464: LD_INT 30
105466: PUSH
105467: LD_INT 30
105469: PUSH
105470: EMPTY
105471: LIST
105472: LIST
105473: LIST
105474: LIST
105475: ST_TO_ADDR
// un := CreateHuman ;
105476: LD_ADDR_VAR 0 3
105480: PUSH
105481: CALL_OW 44
105485: ST_TO_ADDR
// hc_noskilllimit := false ;
105486: LD_ADDR_OWVAR 76
105490: PUSH
105491: LD_INT 0
105493: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105494: LD_VAR 0 3
105498: PPUSH
105499: LD_INT 1
105501: PPUSH
105502: CALL_OW 51
// ToLua ( playRanger() ) ;
105506: LD_STRING playRanger()
105508: PPUSH
105509: CALL_OW 559
// p := 0 ;
105513: LD_ADDR_VAR 0 2
105517: PUSH
105518: LD_INT 0
105520: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105521: LD_INT 35
105523: PPUSH
105524: CALL_OW 67
// p := p + 1 ;
105528: LD_ADDR_VAR 0 2
105532: PUSH
105533: LD_VAR 0 2
105537: PUSH
105538: LD_INT 1
105540: PLUS
105541: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105542: LD_VAR 0 3
105546: PPUSH
105547: CALL_OW 256
105551: PUSH
105552: LD_INT 1000
105554: LESS
105555: IFFALSE 105569
// SetLives ( un , 1000 ) ;
105557: LD_VAR 0 3
105561: PPUSH
105562: LD_INT 1000
105564: PPUSH
105565: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105569: LD_VAR 0 3
105573: PPUSH
105574: LD_INT 81
105576: PUSH
105577: LD_OWVAR 2
105581: PUSH
105582: EMPTY
105583: LIST
105584: LIST
105585: PUSH
105586: LD_INT 91
105588: PUSH
105589: LD_VAR 0 3
105593: PUSH
105594: LD_INT 30
105596: PUSH
105597: EMPTY
105598: LIST
105599: LIST
105600: LIST
105601: PUSH
105602: EMPTY
105603: LIST
105604: LIST
105605: PPUSH
105606: CALL_OW 69
105610: PPUSH
105611: LD_VAR 0 3
105615: PPUSH
105616: CALL_OW 74
105620: PPUSH
105621: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105625: LD_VAR 0 2
105629: PUSH
105630: LD_INT 80
105632: GREATER
105633: IFTRUE 105646
105635: PUSH
105636: LD_VAR 0 3
105640: PPUSH
105641: CALL_OW 301
105645: OR
105646: IFFALSE 105521
// if un then
105648: LD_VAR 0 3
105652: IFFALSE 105663
// RemoveUnit ( un ) ;
105654: LD_VAR 0 3
105658: PPUSH
105659: CALL_OW 64
// end ;
105663: PPOPN 3
105665: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105666: LD_EXP 150
105670: IFFALSE 105786
105672: GO 105674
105674: DISABLE
105675: LD_INT 0
105677: PPUSH
105678: PPUSH
105679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105680: LD_ADDR_VAR 0 2
105684: PUSH
105685: LD_INT 81
105687: PUSH
105688: LD_OWVAR 2
105692: PUSH
105693: EMPTY
105694: LIST
105695: LIST
105696: PUSH
105697: LD_INT 21
105699: PUSH
105700: LD_INT 1
105702: PUSH
105703: EMPTY
105704: LIST
105705: LIST
105706: PUSH
105707: EMPTY
105708: LIST
105709: LIST
105710: PPUSH
105711: CALL_OW 69
105715: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105716: LD_STRING playComputer()
105718: PPUSH
105719: CALL_OW 559
// if not tmp then
105723: LD_VAR 0 2
105727: NOT
105728: IFFALSE 105732
// exit ;
105730: GO 105786
// for i in tmp do
105732: LD_ADDR_VAR 0 1
105736: PUSH
105737: LD_VAR 0 2
105741: PUSH
105742: FOR_IN
105743: IFFALSE 105784
// for j := 1 to 4 do
105745: LD_ADDR_VAR 0 3
105749: PUSH
105750: DOUBLE
105751: LD_INT 1
105753: DEC
105754: ST_TO_ADDR
105755: LD_INT 4
105757: PUSH
105758: FOR_TO
105759: IFFALSE 105780
// SetSkill ( i , j , 10 ) ;
105761: LD_VAR 0 1
105765: PPUSH
105766: LD_VAR 0 3
105770: PPUSH
105771: LD_INT 10
105773: PPUSH
105774: CALL_OW 237
105778: GO 105758
105780: POP
105781: POP
105782: GO 105742
105784: POP
105785: POP
// end ;
105786: PPOPN 3
105788: END
// every 0 0$1 trigger s30 do var i , tmp ;
105789: LD_EXP 151
105793: IFFALSE 105862
105795: GO 105797
105797: DISABLE
105798: LD_INT 0
105800: PPUSH
105801: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105802: LD_ADDR_VAR 0 2
105806: PUSH
105807: LD_INT 22
105809: PUSH
105810: LD_OWVAR 2
105814: PUSH
105815: EMPTY
105816: LIST
105817: LIST
105818: PPUSH
105819: CALL_OW 69
105823: ST_TO_ADDR
// if not tmp then
105824: LD_VAR 0 2
105828: NOT
105829: IFFALSE 105833
// exit ;
105831: GO 105862
// for i in tmp do
105833: LD_ADDR_VAR 0 1
105837: PUSH
105838: LD_VAR 0 2
105842: PUSH
105843: FOR_IN
105844: IFFALSE 105860
// SetLives ( i , 300 ) ;
105846: LD_VAR 0 1
105850: PPUSH
105851: LD_INT 300
105853: PPUSH
105854: CALL_OW 234
105858: GO 105843
105860: POP
105861: POP
// end ;
105862: PPOPN 2
105864: END
// every 0 0$1 trigger s60 do var i , tmp ;
105865: LD_EXP 152
105869: IFFALSE 105938
105871: GO 105873
105873: DISABLE
105874: LD_INT 0
105876: PPUSH
105877: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105878: LD_ADDR_VAR 0 2
105882: PUSH
105883: LD_INT 22
105885: PUSH
105886: LD_OWVAR 2
105890: PUSH
105891: EMPTY
105892: LIST
105893: LIST
105894: PPUSH
105895: CALL_OW 69
105899: ST_TO_ADDR
// if not tmp then
105900: LD_VAR 0 2
105904: NOT
105905: IFFALSE 105909
// exit ;
105907: GO 105938
// for i in tmp do
105909: LD_ADDR_VAR 0 1
105913: PUSH
105914: LD_VAR 0 2
105918: PUSH
105919: FOR_IN
105920: IFFALSE 105936
// SetLives ( i , 600 ) ;
105922: LD_VAR 0 1
105926: PPUSH
105927: LD_INT 600
105929: PPUSH
105930: CALL_OW 234
105934: GO 105919
105936: POP
105937: POP
// end ;
105938: PPOPN 2
105940: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105941: LD_INT 0
105943: PPUSH
// case cmd of 301 :
105944: LD_VAR 0 1
105948: PUSH
105949: LD_INT 301
105951: DOUBLE
105952: EQUAL
105953: IFTRUE 105957
105955: GO 105989
105957: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105958: LD_VAR 0 6
105962: PPUSH
105963: LD_VAR 0 7
105967: PPUSH
105968: LD_VAR 0 8
105972: PPUSH
105973: LD_VAR 0 4
105977: PPUSH
105978: LD_VAR 0 5
105982: PPUSH
105983: CALL 107202 0 5
105987: GO 106110
105989: LD_INT 302
105991: DOUBLE
105992: EQUAL
105993: IFTRUE 105997
105995: GO 106034
105997: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105998: LD_VAR 0 6
106002: PPUSH
106003: LD_VAR 0 7
106007: PPUSH
106008: LD_VAR 0 8
106012: PPUSH
106013: LD_VAR 0 9
106017: PPUSH
106018: LD_VAR 0 4
106022: PPUSH
106023: LD_VAR 0 5
106027: PPUSH
106028: CALL 107293 0 6
106032: GO 106110
106034: LD_INT 303
106036: DOUBLE
106037: EQUAL
106038: IFTRUE 106042
106040: GO 106079
106042: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106043: LD_VAR 0 6
106047: PPUSH
106048: LD_VAR 0 7
106052: PPUSH
106053: LD_VAR 0 8
106057: PPUSH
106058: LD_VAR 0 9
106062: PPUSH
106063: LD_VAR 0 4
106067: PPUSH
106068: LD_VAR 0 5
106072: PPUSH
106073: CALL 106115 0 6
106077: GO 106110
106079: LD_INT 304
106081: DOUBLE
106082: EQUAL
106083: IFTRUE 106087
106085: GO 106109
106087: POP
// hHackTeleport ( unit , x , y ) ; end ;
106088: LD_VAR 0 2
106092: PPUSH
106093: LD_VAR 0 4
106097: PPUSH
106098: LD_VAR 0 5
106102: PPUSH
106103: CALL 107886 0 3
106107: GO 106110
106109: POP
// end ;
106110: LD_VAR 0 12
106114: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106115: LD_INT 0
106117: PPUSH
106118: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106119: LD_VAR 0 1
106123: PUSH
106124: LD_INT 1
106126: LESS
106127: IFTRUE 106139
106129: PUSH
106130: LD_VAR 0 1
106134: PUSH
106135: LD_INT 3
106137: GREATER
106138: OR
106139: IFTRUE 106157
106141: PUSH
106142: LD_VAR 0 5
106146: PPUSH
106147: LD_VAR 0 6
106151: PPUSH
106152: CALL_OW 428
106156: OR
106157: IFFALSE 106161
// exit ;
106159: GO 106889
// uc_side := your_side ;
106161: LD_ADDR_OWVAR 20
106165: PUSH
106166: LD_OWVAR 2
106170: ST_TO_ADDR
// uc_nation := nation ;
106171: LD_ADDR_OWVAR 21
106175: PUSH
106176: LD_VAR 0 1
106180: ST_TO_ADDR
// bc_level = 1 ;
106181: LD_ADDR_OWVAR 43
106185: PUSH
106186: LD_INT 1
106188: ST_TO_ADDR
// case btype of 1 :
106189: LD_VAR 0 2
106193: PUSH
106194: LD_INT 1
106196: DOUBLE
106197: EQUAL
106198: IFTRUE 106202
106200: GO 106213
106202: POP
// bc_type := b_depot ; 2 :
106203: LD_ADDR_OWVAR 42
106207: PUSH
106208: LD_INT 0
106210: ST_TO_ADDR
106211: GO 106833
106213: LD_INT 2
106215: DOUBLE
106216: EQUAL
106217: IFTRUE 106221
106219: GO 106232
106221: POP
// bc_type := b_warehouse ; 3 :
106222: LD_ADDR_OWVAR 42
106226: PUSH
106227: LD_INT 1
106229: ST_TO_ADDR
106230: GO 106833
106232: LD_INT 3
106234: DOUBLE
106235: EQUAL
106236: IFTRUE 106240
106238: GO 106251
106240: POP
// bc_type := b_lab ; 4 .. 9 :
106241: LD_ADDR_OWVAR 42
106245: PUSH
106246: LD_INT 6
106248: ST_TO_ADDR
106249: GO 106833
106251: LD_INT 4
106253: DOUBLE
106254: GREATEREQUAL
106255: IFFALSE 106263
106257: LD_INT 9
106259: DOUBLE
106260: LESSEQUAL
106261: IFTRUE 106265
106263: GO 106325
106265: POP
// begin bc_type := b_lab_half ;
106266: LD_ADDR_OWVAR 42
106270: PUSH
106271: LD_INT 7
106273: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106274: LD_ADDR_OWVAR 44
106278: PUSH
106279: LD_INT 10
106281: PUSH
106282: LD_INT 11
106284: PUSH
106285: LD_INT 12
106287: PUSH
106288: LD_INT 15
106290: PUSH
106291: LD_INT 14
106293: PUSH
106294: LD_INT 13
106296: PUSH
106297: EMPTY
106298: LIST
106299: LIST
106300: LIST
106301: LIST
106302: LIST
106303: LIST
106304: PUSH
106305: LD_VAR 0 2
106309: PUSH
106310: LD_INT 3
106312: MINUS
106313: ARRAY
106314: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
106315: LD_ADDR_OWVAR 45
106319: PUSH
106320: LD_INT 9
106322: ST_TO_ADDR
// end ; 10 .. 13 :
106323: GO 106833
106325: LD_INT 10
106327: DOUBLE
106328: GREATEREQUAL
106329: IFFALSE 106337
106331: LD_INT 13
106333: DOUBLE
106334: LESSEQUAL
106335: IFTRUE 106339
106337: GO 106416
106339: POP
// begin bc_type := b_lab_full ;
106340: LD_ADDR_OWVAR 42
106344: PUSH
106345: LD_INT 8
106347: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106348: LD_ADDR_OWVAR 44
106352: PUSH
106353: LD_INT 10
106355: PUSH
106356: LD_INT 12
106358: PUSH
106359: LD_INT 14
106361: PUSH
106362: LD_INT 13
106364: PUSH
106365: EMPTY
106366: LIST
106367: LIST
106368: LIST
106369: LIST
106370: PUSH
106371: LD_VAR 0 2
106375: PUSH
106376: LD_INT 9
106378: MINUS
106379: ARRAY
106380: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106381: LD_ADDR_OWVAR 45
106385: PUSH
106386: LD_INT 11
106388: PUSH
106389: LD_INT 15
106391: PUSH
106392: LD_INT 12
106394: PUSH
106395: LD_INT 15
106397: PUSH
106398: EMPTY
106399: LIST
106400: LIST
106401: LIST
106402: LIST
106403: PUSH
106404: LD_VAR 0 2
106408: PUSH
106409: LD_INT 9
106411: MINUS
106412: ARRAY
106413: ST_TO_ADDR
// end ; 14 :
106414: GO 106833
106416: LD_INT 14
106418: DOUBLE
106419: EQUAL
106420: IFTRUE 106424
106422: GO 106435
106424: POP
// bc_type := b_workshop ; 15 :
106425: LD_ADDR_OWVAR 42
106429: PUSH
106430: LD_INT 2
106432: ST_TO_ADDR
106433: GO 106833
106435: LD_INT 15
106437: DOUBLE
106438: EQUAL
106439: IFTRUE 106443
106441: GO 106454
106443: POP
// bc_type := b_factory ; 16 :
106444: LD_ADDR_OWVAR 42
106448: PUSH
106449: LD_INT 3
106451: ST_TO_ADDR
106452: GO 106833
106454: LD_INT 16
106456: DOUBLE
106457: EQUAL
106458: IFTRUE 106462
106460: GO 106473
106462: POP
// bc_type := b_ext_gun ; 17 :
106463: LD_ADDR_OWVAR 42
106467: PUSH
106468: LD_INT 17
106470: ST_TO_ADDR
106471: GO 106833
106473: LD_INT 17
106475: DOUBLE
106476: EQUAL
106477: IFTRUE 106481
106479: GO 106509
106481: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106482: LD_ADDR_OWVAR 42
106486: PUSH
106487: LD_INT 19
106489: PUSH
106490: LD_INT 23
106492: PUSH
106493: LD_INT 19
106495: PUSH
106496: EMPTY
106497: LIST
106498: LIST
106499: LIST
106500: PUSH
106501: LD_VAR 0 1
106505: ARRAY
106506: ST_TO_ADDR
106507: GO 106833
106509: LD_INT 18
106511: DOUBLE
106512: EQUAL
106513: IFTRUE 106517
106515: GO 106528
106517: POP
// bc_type := b_ext_radar ; 19 :
106518: LD_ADDR_OWVAR 42
106522: PUSH
106523: LD_INT 20
106525: ST_TO_ADDR
106526: GO 106833
106528: LD_INT 19
106530: DOUBLE
106531: EQUAL
106532: IFTRUE 106536
106534: GO 106547
106536: POP
// bc_type := b_ext_radio ; 20 :
106537: LD_ADDR_OWVAR 42
106541: PUSH
106542: LD_INT 22
106544: ST_TO_ADDR
106545: GO 106833
106547: LD_INT 20
106549: DOUBLE
106550: EQUAL
106551: IFTRUE 106555
106553: GO 106566
106555: POP
// bc_type := b_ext_siberium ; 21 :
106556: LD_ADDR_OWVAR 42
106560: PUSH
106561: LD_INT 21
106563: ST_TO_ADDR
106564: GO 106833
106566: LD_INT 21
106568: DOUBLE
106569: EQUAL
106570: IFTRUE 106574
106572: GO 106585
106574: POP
// bc_type := b_ext_computer ; 22 :
106575: LD_ADDR_OWVAR 42
106579: PUSH
106580: LD_INT 24
106582: ST_TO_ADDR
106583: GO 106833
106585: LD_INT 22
106587: DOUBLE
106588: EQUAL
106589: IFTRUE 106593
106591: GO 106604
106593: POP
// bc_type := b_ext_track ; 23 :
106594: LD_ADDR_OWVAR 42
106598: PUSH
106599: LD_INT 16
106601: ST_TO_ADDR
106602: GO 106833
106604: LD_INT 23
106606: DOUBLE
106607: EQUAL
106608: IFTRUE 106612
106610: GO 106623
106612: POP
// bc_type := b_ext_laser ; 24 :
106613: LD_ADDR_OWVAR 42
106617: PUSH
106618: LD_INT 25
106620: ST_TO_ADDR
106621: GO 106833
106623: LD_INT 24
106625: DOUBLE
106626: EQUAL
106627: IFTRUE 106631
106629: GO 106642
106631: POP
// bc_type := b_control_tower ; 25 :
106632: LD_ADDR_OWVAR 42
106636: PUSH
106637: LD_INT 36
106639: ST_TO_ADDR
106640: GO 106833
106642: LD_INT 25
106644: DOUBLE
106645: EQUAL
106646: IFTRUE 106650
106648: GO 106661
106650: POP
// bc_type := b_breastwork ; 26 :
106651: LD_ADDR_OWVAR 42
106655: PUSH
106656: LD_INT 31
106658: ST_TO_ADDR
106659: GO 106833
106661: LD_INT 26
106663: DOUBLE
106664: EQUAL
106665: IFTRUE 106669
106667: GO 106680
106669: POP
// bc_type := b_bunker ; 27 :
106670: LD_ADDR_OWVAR 42
106674: PUSH
106675: LD_INT 32
106677: ST_TO_ADDR
106678: GO 106833
106680: LD_INT 27
106682: DOUBLE
106683: EQUAL
106684: IFTRUE 106688
106686: GO 106699
106688: POP
// bc_type := b_turret ; 28 :
106689: LD_ADDR_OWVAR 42
106693: PUSH
106694: LD_INT 33
106696: ST_TO_ADDR
106697: GO 106833
106699: LD_INT 28
106701: DOUBLE
106702: EQUAL
106703: IFTRUE 106707
106705: GO 106718
106707: POP
// bc_type := b_armoury ; 29 :
106708: LD_ADDR_OWVAR 42
106712: PUSH
106713: LD_INT 4
106715: ST_TO_ADDR
106716: GO 106833
106718: LD_INT 29
106720: DOUBLE
106721: EQUAL
106722: IFTRUE 106726
106724: GO 106737
106726: POP
// bc_type := b_barracks ; 30 :
106727: LD_ADDR_OWVAR 42
106731: PUSH
106732: LD_INT 5
106734: ST_TO_ADDR
106735: GO 106833
106737: LD_INT 30
106739: DOUBLE
106740: EQUAL
106741: IFTRUE 106745
106743: GO 106756
106745: POP
// bc_type := b_solar_power ; 31 :
106746: LD_ADDR_OWVAR 42
106750: PUSH
106751: LD_INT 27
106753: ST_TO_ADDR
106754: GO 106833
106756: LD_INT 31
106758: DOUBLE
106759: EQUAL
106760: IFTRUE 106764
106762: GO 106775
106764: POP
// bc_type := b_oil_power ; 32 :
106765: LD_ADDR_OWVAR 42
106769: PUSH
106770: LD_INT 26
106772: ST_TO_ADDR
106773: GO 106833
106775: LD_INT 32
106777: DOUBLE
106778: EQUAL
106779: IFTRUE 106783
106781: GO 106794
106783: POP
// bc_type := b_siberite_power ; 33 :
106784: LD_ADDR_OWVAR 42
106788: PUSH
106789: LD_INT 28
106791: ST_TO_ADDR
106792: GO 106833
106794: LD_INT 33
106796: DOUBLE
106797: EQUAL
106798: IFTRUE 106802
106800: GO 106813
106802: POP
// bc_type := b_oil_mine ; 34 :
106803: LD_ADDR_OWVAR 42
106807: PUSH
106808: LD_INT 29
106810: ST_TO_ADDR
106811: GO 106833
106813: LD_INT 34
106815: DOUBLE
106816: EQUAL
106817: IFTRUE 106821
106819: GO 106832
106821: POP
// bc_type := b_siberite_mine ; end ;
106822: LD_ADDR_OWVAR 42
106826: PUSH
106827: LD_INT 30
106829: ST_TO_ADDR
106830: GO 106833
106832: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106833: LD_ADDR_VAR 0 8
106837: PUSH
106838: LD_VAR 0 5
106842: PPUSH
106843: LD_VAR 0 6
106847: PPUSH
106848: LD_VAR 0 3
106852: PPUSH
106853: CALL_OW 47
106857: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106858: LD_OWVAR 42
106862: PUSH
106863: LD_INT 32
106865: PUSH
106866: LD_INT 33
106868: PUSH
106869: EMPTY
106870: LIST
106871: LIST
106872: IN
106873: IFFALSE 106889
// PlaceWeaponTurret ( b , weapon ) ;
106875: LD_VAR 0 8
106879: PPUSH
106880: LD_VAR 0 4
106884: PPUSH
106885: CALL_OW 431
// end ;
106889: LD_VAR 0 7
106893: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106894: LD_INT 0
106896: PPUSH
106897: PPUSH
106898: PPUSH
106899: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106900: LD_ADDR_VAR 0 4
106904: PUSH
106905: LD_INT 22
106907: PUSH
106908: LD_OWVAR 2
106912: PUSH
106913: EMPTY
106914: LIST
106915: LIST
106916: PUSH
106917: LD_INT 2
106919: PUSH
106920: LD_INT 30
106922: PUSH
106923: LD_INT 0
106925: PUSH
106926: EMPTY
106927: LIST
106928: LIST
106929: PUSH
106930: LD_INT 30
106932: PUSH
106933: LD_INT 1
106935: PUSH
106936: EMPTY
106937: LIST
106938: LIST
106939: PUSH
106940: EMPTY
106941: LIST
106942: LIST
106943: LIST
106944: PUSH
106945: EMPTY
106946: LIST
106947: LIST
106948: PPUSH
106949: CALL_OW 69
106953: ST_TO_ADDR
// if not tmp then
106954: LD_VAR 0 4
106958: NOT
106959: IFFALSE 106963
// exit ;
106961: GO 107022
// for i in tmp do
106963: LD_ADDR_VAR 0 2
106967: PUSH
106968: LD_VAR 0 4
106972: PUSH
106973: FOR_IN
106974: IFFALSE 107020
// for j = 1 to 3 do
106976: LD_ADDR_VAR 0 3
106980: PUSH
106981: DOUBLE
106982: LD_INT 1
106984: DEC
106985: ST_TO_ADDR
106986: LD_INT 3
106988: PUSH
106989: FOR_TO
106990: IFFALSE 107016
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106992: LD_VAR 0 2
106996: PPUSH
106997: CALL_OW 274
107001: PPUSH
107002: LD_VAR 0 3
107006: PPUSH
107007: LD_INT 99999
107009: PPUSH
107010: CALL_OW 277
107014: GO 106989
107016: POP
107017: POP
107018: GO 106973
107020: POP
107021: POP
// end ;
107022: LD_VAR 0 1
107026: RET
// export function hHackSetLevel10 ; var i , j ; begin
107027: LD_INT 0
107029: PPUSH
107030: PPUSH
107031: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107032: LD_ADDR_VAR 0 2
107036: PUSH
107037: LD_INT 21
107039: PUSH
107040: LD_INT 1
107042: PUSH
107043: EMPTY
107044: LIST
107045: LIST
107046: PPUSH
107047: CALL_OW 69
107051: PUSH
107052: FOR_IN
107053: IFFALSE 107105
// if IsSelected ( i ) then
107055: LD_VAR 0 2
107059: PPUSH
107060: CALL_OW 306
107064: IFFALSE 107103
// begin for j := 1 to 4 do
107066: LD_ADDR_VAR 0 3
107070: PUSH
107071: DOUBLE
107072: LD_INT 1
107074: DEC
107075: ST_TO_ADDR
107076: LD_INT 4
107078: PUSH
107079: FOR_TO
107080: IFFALSE 107101
// SetSkill ( i , j , 10 ) ;
107082: LD_VAR 0 2
107086: PPUSH
107087: LD_VAR 0 3
107091: PPUSH
107092: LD_INT 10
107094: PPUSH
107095: CALL_OW 237
107099: GO 107079
107101: POP
107102: POP
// end ;
107103: GO 107052
107105: POP
107106: POP
// end ;
107107: LD_VAR 0 1
107111: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107112: LD_INT 0
107114: PPUSH
107115: PPUSH
107116: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107117: LD_ADDR_VAR 0 2
107121: PUSH
107122: LD_INT 22
107124: PUSH
107125: LD_OWVAR 2
107129: PUSH
107130: EMPTY
107131: LIST
107132: LIST
107133: PUSH
107134: LD_INT 21
107136: PUSH
107137: LD_INT 1
107139: PUSH
107140: EMPTY
107141: LIST
107142: LIST
107143: PUSH
107144: EMPTY
107145: LIST
107146: LIST
107147: PPUSH
107148: CALL_OW 69
107152: PUSH
107153: FOR_IN
107154: IFFALSE 107195
// begin for j := 1 to 4 do
107156: LD_ADDR_VAR 0 3
107160: PUSH
107161: DOUBLE
107162: LD_INT 1
107164: DEC
107165: ST_TO_ADDR
107166: LD_INT 4
107168: PUSH
107169: FOR_TO
107170: IFFALSE 107191
// SetSkill ( i , j , 10 ) ;
107172: LD_VAR 0 2
107176: PPUSH
107177: LD_VAR 0 3
107181: PPUSH
107182: LD_INT 10
107184: PPUSH
107185: CALL_OW 237
107189: GO 107169
107191: POP
107192: POP
// end ;
107193: GO 107153
107195: POP
107196: POP
// end ;
107197: LD_VAR 0 1
107201: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107202: LD_INT 0
107204: PPUSH
// uc_side := your_side ;
107205: LD_ADDR_OWVAR 20
107209: PUSH
107210: LD_OWVAR 2
107214: ST_TO_ADDR
// uc_nation := nation ;
107215: LD_ADDR_OWVAR 21
107219: PUSH
107220: LD_VAR 0 1
107224: ST_TO_ADDR
// InitHc ;
107225: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107229: LD_INT 0
107231: PPUSH
107232: LD_VAR 0 2
107236: PPUSH
107237: LD_VAR 0 3
107241: PPUSH
107242: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107246: LD_VAR 0 4
107250: PPUSH
107251: LD_VAR 0 5
107255: PPUSH
107256: CALL_OW 428
107260: PUSH
107261: LD_INT 0
107263: EQUAL
107264: IFFALSE 107288
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107266: CALL_OW 44
107270: PPUSH
107271: LD_VAR 0 4
107275: PPUSH
107276: LD_VAR 0 5
107280: PPUSH
107281: LD_INT 1
107283: PPUSH
107284: CALL_OW 48
// end ;
107288: LD_VAR 0 6
107292: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107293: LD_INT 0
107295: PPUSH
107296: PPUSH
// uc_side := your_side ;
107297: LD_ADDR_OWVAR 20
107301: PUSH
107302: LD_OWVAR 2
107306: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107307: LD_VAR 0 1
107311: PUSH
107312: LD_INT 1
107314: PUSH
107315: LD_INT 2
107317: PUSH
107318: LD_INT 3
107320: PUSH
107321: LD_INT 4
107323: PUSH
107324: LD_INT 5
107326: PUSH
107327: EMPTY
107328: LIST
107329: LIST
107330: LIST
107331: LIST
107332: LIST
107333: IN
107334: IFFALSE 107346
// uc_nation := nation_american else
107336: LD_ADDR_OWVAR 21
107340: PUSH
107341: LD_INT 1
107343: ST_TO_ADDR
107344: GO 107389
// if chassis in [ 11 , 12 , 13 , 14 ] then
107346: LD_VAR 0 1
107350: PUSH
107351: LD_INT 11
107353: PUSH
107354: LD_INT 12
107356: PUSH
107357: LD_INT 13
107359: PUSH
107360: LD_INT 14
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: LIST
107367: LIST
107368: IN
107369: IFFALSE 107381
// uc_nation := nation_arabian else
107371: LD_ADDR_OWVAR 21
107375: PUSH
107376: LD_INT 2
107378: ST_TO_ADDR
107379: GO 107389
// uc_nation := nation_russian ;
107381: LD_ADDR_OWVAR 21
107385: PUSH
107386: LD_INT 3
107388: ST_TO_ADDR
// vc_chassis := chassis ;
107389: LD_ADDR_OWVAR 37
107393: PUSH
107394: LD_VAR 0 1
107398: ST_TO_ADDR
// vc_engine := engine ;
107399: LD_ADDR_OWVAR 39
107403: PUSH
107404: LD_VAR 0 2
107408: ST_TO_ADDR
// vc_control := control ;
107409: LD_ADDR_OWVAR 38
107413: PUSH
107414: LD_VAR 0 3
107418: ST_TO_ADDR
// vc_weapon := weapon ;
107419: LD_ADDR_OWVAR 40
107423: PUSH
107424: LD_VAR 0 4
107428: ST_TO_ADDR
// un := CreateVehicle ;
107429: LD_ADDR_VAR 0 8
107433: PUSH
107434: CALL_OW 45
107438: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107439: LD_VAR 0 8
107443: PPUSH
107444: LD_INT 0
107446: PPUSH
107447: LD_INT 5
107449: PPUSH
107450: CALL_OW 12
107454: PPUSH
107455: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107459: LD_VAR 0 8
107463: PPUSH
107464: LD_VAR 0 5
107468: PPUSH
107469: LD_VAR 0 6
107473: PPUSH
107474: LD_INT 1
107476: PPUSH
107477: CALL_OW 48
// end ;
107481: LD_VAR 0 7
107485: RET
// export hInvincible ; every 1 do
107486: GO 107488
107488: DISABLE
// hInvincible := [ ] ;
107489: LD_ADDR_EXP 153
107493: PUSH
107494: EMPTY
107495: ST_TO_ADDR
107496: END
// every 10 do var i ;
107497: GO 107499
107499: DISABLE
107500: LD_INT 0
107502: PPUSH
// begin enable ;
107503: ENABLE
// if not hInvincible then
107504: LD_EXP 153
107508: NOT
107509: IFFALSE 107513
// exit ;
107511: GO 107557
// for i in hInvincible do
107513: LD_ADDR_VAR 0 1
107517: PUSH
107518: LD_EXP 153
107522: PUSH
107523: FOR_IN
107524: IFFALSE 107555
// if GetLives ( i ) < 1000 then
107526: LD_VAR 0 1
107530: PPUSH
107531: CALL_OW 256
107535: PUSH
107536: LD_INT 1000
107538: LESS
107539: IFFALSE 107553
// SetLives ( i , 1000 ) ;
107541: LD_VAR 0 1
107545: PPUSH
107546: LD_INT 1000
107548: PPUSH
107549: CALL_OW 234
107553: GO 107523
107555: POP
107556: POP
// end ;
107557: PPOPN 1
107559: END
// export function hHackInvincible ; var i ; begin
107560: LD_INT 0
107562: PPUSH
107563: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107564: LD_ADDR_VAR 0 2
107568: PUSH
107569: LD_INT 2
107571: PUSH
107572: LD_INT 21
107574: PUSH
107575: LD_INT 1
107577: PUSH
107578: EMPTY
107579: LIST
107580: LIST
107581: PUSH
107582: LD_INT 21
107584: PUSH
107585: LD_INT 2
107587: PUSH
107588: EMPTY
107589: LIST
107590: LIST
107591: PUSH
107592: EMPTY
107593: LIST
107594: LIST
107595: LIST
107596: PPUSH
107597: CALL_OW 69
107601: PUSH
107602: FOR_IN
107603: IFFALSE 107664
// if IsSelected ( i ) then
107605: LD_VAR 0 2
107609: PPUSH
107610: CALL_OW 306
107614: IFFALSE 107662
// begin if i in hInvincible then
107616: LD_VAR 0 2
107620: PUSH
107621: LD_EXP 153
107625: IN
107626: IFFALSE 107646
// hInvincible := hInvincible diff i else
107628: LD_ADDR_EXP 153
107632: PUSH
107633: LD_EXP 153
107637: PUSH
107638: LD_VAR 0 2
107642: DIFF
107643: ST_TO_ADDR
107644: GO 107662
// hInvincible := hInvincible union i ;
107646: LD_ADDR_EXP 153
107650: PUSH
107651: LD_EXP 153
107655: PUSH
107656: LD_VAR 0 2
107660: UNION
107661: ST_TO_ADDR
// end ;
107662: GO 107602
107664: POP
107665: POP
// end ;
107666: LD_VAR 0 1
107670: RET
// export function hHackInvisible ; var i , j ; begin
107671: LD_INT 0
107673: PPUSH
107674: PPUSH
107675: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107676: LD_ADDR_VAR 0 2
107680: PUSH
107681: LD_INT 21
107683: PUSH
107684: LD_INT 1
107686: PUSH
107687: EMPTY
107688: LIST
107689: LIST
107690: PPUSH
107691: CALL_OW 69
107695: PUSH
107696: FOR_IN
107697: IFFALSE 107721
// if IsSelected ( i ) then
107699: LD_VAR 0 2
107703: PPUSH
107704: CALL_OW 306
107708: IFFALSE 107719
// ComForceInvisible ( i ) ;
107710: LD_VAR 0 2
107714: PPUSH
107715: CALL_OW 496
107719: GO 107696
107721: POP
107722: POP
// end ;
107723: LD_VAR 0 1
107727: RET
// export function hHackChangeYourSide ; begin
107728: LD_INT 0
107730: PPUSH
// if your_side = 8 then
107731: LD_OWVAR 2
107735: PUSH
107736: LD_INT 8
107738: EQUAL
107739: IFFALSE 107751
// your_side := 0 else
107741: LD_ADDR_OWVAR 2
107745: PUSH
107746: LD_INT 0
107748: ST_TO_ADDR
107749: GO 107765
// your_side := your_side + 1 ;
107751: LD_ADDR_OWVAR 2
107755: PUSH
107756: LD_OWVAR 2
107760: PUSH
107761: LD_INT 1
107763: PLUS
107764: ST_TO_ADDR
// end ;
107765: LD_VAR 0 1
107769: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107770: LD_INT 0
107772: PPUSH
107773: PPUSH
107774: PPUSH
// for i in all_units do
107775: LD_ADDR_VAR 0 2
107779: PUSH
107780: LD_OWVAR 3
107784: PUSH
107785: FOR_IN
107786: IFFALSE 107864
// if IsSelected ( i ) then
107788: LD_VAR 0 2
107792: PPUSH
107793: CALL_OW 306
107797: IFFALSE 107862
// begin j := GetSide ( i ) ;
107799: LD_ADDR_VAR 0 3
107803: PUSH
107804: LD_VAR 0 2
107808: PPUSH
107809: CALL_OW 255
107813: ST_TO_ADDR
// if j = 8 then
107814: LD_VAR 0 3
107818: PUSH
107819: LD_INT 8
107821: EQUAL
107822: IFFALSE 107834
// j := 0 else
107824: LD_ADDR_VAR 0 3
107828: PUSH
107829: LD_INT 0
107831: ST_TO_ADDR
107832: GO 107848
// j := j + 1 ;
107834: LD_ADDR_VAR 0 3
107838: PUSH
107839: LD_VAR 0 3
107843: PUSH
107844: LD_INT 1
107846: PLUS
107847: ST_TO_ADDR
// SetSide ( i , j ) ;
107848: LD_VAR 0 2
107852: PPUSH
107853: LD_VAR 0 3
107857: PPUSH
107858: CALL_OW 235
// end ;
107862: GO 107785
107864: POP
107865: POP
// end ;
107866: LD_VAR 0 1
107870: RET
// export function hHackFog ; begin
107871: LD_INT 0
107873: PPUSH
// FogOff ( true ) ;
107874: LD_INT 1
107876: PPUSH
107877: CALL_OW 344
// end ;
107881: LD_VAR 0 1
107885: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107886: LD_INT 0
107888: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107889: LD_VAR 0 1
107893: PPUSH
107894: LD_VAR 0 2
107898: PPUSH
107899: LD_VAR 0 3
107903: PPUSH
107904: LD_INT 1
107906: PPUSH
107907: LD_INT 1
107909: PPUSH
107910: CALL_OW 483
// CenterOnXY ( x , y ) ;
107914: LD_VAR 0 2
107918: PPUSH
107919: LD_VAR 0 3
107923: PPUSH
107924: CALL_OW 84
// end ;
107928: LD_VAR 0 4
107932: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107933: LD_INT 0
107935: PPUSH
107936: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107937: LD_VAR 0 1
107941: NOT
107942: IFTRUE 107961
107944: PUSH
107945: LD_VAR 0 2
107949: PPUSH
107950: LD_VAR 0 3
107954: PPUSH
107955: CALL_OW 488
107959: NOT
107960: OR
107961: IFTRUE 107996
107963: PUSH
107964: LD_VAR 0 1
107968: PPUSH
107969: CALL_OW 266
107973: PUSH
107974: LD_INT 3
107976: NONEQUAL
107977: IFFALSE 107995
107979: PUSH
107980: LD_VAR 0 1
107984: PPUSH
107985: CALL_OW 247
107989: PUSH
107990: LD_INT 1
107992: EQUAL
107993: NOT
107994: AND
107995: OR
107996: IFFALSE 108000
// exit ;
107998: GO 108282
// if GetType ( factory ) = unit_human then
108000: LD_VAR 0 1
108004: PPUSH
108005: CALL_OW 247
108009: PUSH
108010: LD_INT 1
108012: EQUAL
108013: IFFALSE 108030
// factory := IsInUnit ( factory ) ;
108015: LD_ADDR_VAR 0 1
108019: PUSH
108020: LD_VAR 0 1
108024: PPUSH
108025: CALL_OW 310
108029: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108030: LD_VAR 0 1
108034: PPUSH
108035: CALL_OW 266
108039: PUSH
108040: LD_INT 3
108042: NONEQUAL
108043: IFFALSE 108047
// exit ;
108045: GO 108282
// for i := 1 to Count ( factoryWaypoints ) do
108047: LD_ADDR_VAR 0 5
108051: PUSH
108052: DOUBLE
108053: LD_INT 1
108055: DEC
108056: ST_TO_ADDR
108057: LD_EXP 154
108061: PPUSH
108062: CALL 51979 0 1
108066: PUSH
108067: FOR_TO
108068: IFFALSE 108230
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
108070: LD_VAR 0 2
108074: PPUSH
108075: LD_VAR 0 3
108079: PPUSH
108080: CALL_OW 428
108084: PUSH
108085: LD_EXP 154
108089: PUSH
108090: LD_VAR 0 5
108094: ARRAY
108095: PUSH
108096: LD_INT 2
108098: ARRAY
108099: EQUAL
108100: IFFALSE 108132
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
108102: LD_ADDR_EXP 154
108106: PUSH
108107: LD_EXP 154
108111: PPUSH
108112: LD_VAR 0 5
108116: PPUSH
108117: CALL_OW 3
108121: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108122: CALL 108287 0 0
// exit ;
108126: POP
108127: POP
108128: GO 108282
// end else
108130: GO 108228
// if factory = factoryWaypoints [ i ] [ 2 ] then
108132: LD_VAR 0 1
108136: PUSH
108137: LD_EXP 154
108141: PUSH
108142: LD_VAR 0 5
108146: ARRAY
108147: PUSH
108148: LD_INT 2
108150: ARRAY
108151: EQUAL
108152: IFFALSE 108228
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
108154: LD_ADDR_EXP 154
108158: PUSH
108159: LD_EXP 154
108163: PPUSH
108164: LD_VAR 0 5
108168: PPUSH
108169: CALL_OW 3
108173: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
108174: LD_ADDR_EXP 154
108178: PUSH
108179: LD_EXP 154
108183: PPUSH
108184: LD_VAR 0 1
108188: PPUSH
108189: CALL_OW 255
108193: PUSH
108194: LD_VAR 0 1
108198: PUSH
108199: LD_VAR 0 2
108203: PUSH
108204: LD_VAR 0 3
108208: PUSH
108209: EMPTY
108210: LIST
108211: LIST
108212: LIST
108213: LIST
108214: PPUSH
108215: CALL 87955 0 2
108219: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108220: CALL 108287 0 0
// exit ;
108224: POP
108225: POP
108226: GO 108282
// end ; end ;
108228: GO 108067
108230: POP
108231: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
108232: LD_ADDR_EXP 154
108236: PUSH
108237: LD_EXP 154
108241: PPUSH
108242: LD_VAR 0 1
108246: PPUSH
108247: CALL_OW 255
108251: PUSH
108252: LD_VAR 0 1
108256: PUSH
108257: LD_VAR 0 2
108261: PUSH
108262: LD_VAR 0 3
108266: PUSH
108267: EMPTY
108268: LIST
108269: LIST
108270: LIST
108271: LIST
108272: PPUSH
108273: CALL 87955 0 2
108277: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108278: CALL 108287 0 0
// end ;
108282: LD_VAR 0 4
108286: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108287: LD_INT 0
108289: PPUSH
108290: PPUSH
108291: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108292: LD_STRING resetFactoryWaypoint();
108294: PPUSH
108295: CALL_OW 559
// if factoryWaypoints then
108299: LD_EXP 154
108303: IFFALSE 108424
// begin list := factoryWaypoints ;
108305: LD_ADDR_VAR 0 3
108309: PUSH
108310: LD_EXP 154
108314: ST_TO_ADDR
// for i := 1 to list do
108315: LD_ADDR_VAR 0 2
108319: PUSH
108320: DOUBLE
108321: LD_INT 1
108323: DEC
108324: ST_TO_ADDR
108325: LD_VAR 0 3
108329: PUSH
108330: FOR_TO
108331: IFFALSE 108422
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108333: LD_STRING setFactoryWaypointXY(
108335: PUSH
108336: LD_VAR 0 3
108340: PUSH
108341: LD_VAR 0 2
108345: ARRAY
108346: PUSH
108347: LD_INT 1
108349: ARRAY
108350: STR
108351: PUSH
108352: LD_STRING ,
108354: STR
108355: PUSH
108356: LD_VAR 0 3
108360: PUSH
108361: LD_VAR 0 2
108365: ARRAY
108366: PUSH
108367: LD_INT 2
108369: ARRAY
108370: STR
108371: PUSH
108372: LD_STRING ,
108374: STR
108375: PUSH
108376: LD_VAR 0 3
108380: PUSH
108381: LD_VAR 0 2
108385: ARRAY
108386: PUSH
108387: LD_INT 3
108389: ARRAY
108390: STR
108391: PUSH
108392: LD_STRING ,
108394: STR
108395: PUSH
108396: LD_VAR 0 3
108400: PUSH
108401: LD_VAR 0 2
108405: ARRAY
108406: PUSH
108407: LD_INT 4
108409: ARRAY
108410: STR
108411: PUSH
108412: LD_STRING )
108414: STR
108415: PPUSH
108416: CALL_OW 559
108420: GO 108330
108422: POP
108423: POP
// end ; end ;
108424: LD_VAR 0 1
108428: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108429: LD_INT 0
108431: PPUSH
// if HexInfo ( x , y ) = warehouse then
108432: LD_VAR 0 2
108436: PPUSH
108437: LD_VAR 0 3
108441: PPUSH
108442: CALL_OW 428
108446: PUSH
108447: LD_VAR 0 1
108451: EQUAL
108452: IFFALSE 108479
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108454: LD_ADDR_EXP 156
108458: PUSH
108459: LD_EXP 156
108463: PPUSH
108464: LD_VAR 0 1
108468: PPUSH
108469: LD_INT 0
108471: PPUSH
108472: CALL_OW 1
108476: ST_TO_ADDR
108477: GO 108530
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108479: LD_ADDR_EXP 156
108483: PUSH
108484: LD_EXP 156
108488: PPUSH
108489: LD_VAR 0 1
108493: PPUSH
108494: LD_VAR 0 1
108498: PPUSH
108499: CALL_OW 255
108503: PUSH
108504: LD_VAR 0 1
108508: PUSH
108509: LD_VAR 0 2
108513: PUSH
108514: LD_VAR 0 3
108518: PUSH
108519: EMPTY
108520: LIST
108521: LIST
108522: LIST
108523: LIST
108524: PPUSH
108525: CALL_OW 1
108529: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108530: CALL 108539 0 0
// end ;
108534: LD_VAR 0 4
108538: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108539: LD_INT 0
108541: PPUSH
108542: PPUSH
108543: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108544: LD_STRING resetWarehouseGatheringPoints();
108546: PPUSH
108547: CALL_OW 559
// if warehouseGatheringPoints then
108551: LD_EXP 156
108555: IFFALSE 108681
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108557: LD_ADDR_VAR 0 3
108561: PUSH
108562: LD_EXP 156
108566: PPUSH
108567: CALL 91889 0 1
108571: ST_TO_ADDR
// for i := 1 to list do
108572: LD_ADDR_VAR 0 2
108576: PUSH
108577: DOUBLE
108578: LD_INT 1
108580: DEC
108581: ST_TO_ADDR
108582: LD_VAR 0 3
108586: PUSH
108587: FOR_TO
108588: IFFALSE 108679
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108590: LD_STRING setWarehouseGatheringPointXY(
108592: PUSH
108593: LD_VAR 0 3
108597: PUSH
108598: LD_VAR 0 2
108602: ARRAY
108603: PUSH
108604: LD_INT 1
108606: ARRAY
108607: STR
108608: PUSH
108609: LD_STRING ,
108611: STR
108612: PUSH
108613: LD_VAR 0 3
108617: PUSH
108618: LD_VAR 0 2
108622: ARRAY
108623: PUSH
108624: LD_INT 2
108626: ARRAY
108627: STR
108628: PUSH
108629: LD_STRING ,
108631: STR
108632: PUSH
108633: LD_VAR 0 3
108637: PUSH
108638: LD_VAR 0 2
108642: ARRAY
108643: PUSH
108644: LD_INT 3
108646: ARRAY
108647: STR
108648: PUSH
108649: LD_STRING ,
108651: STR
108652: PUSH
108653: LD_VAR 0 3
108657: PUSH
108658: LD_VAR 0 2
108662: ARRAY
108663: PUSH
108664: LD_INT 4
108666: ARRAY
108667: STR
108668: PUSH
108669: LD_STRING )
108671: STR
108672: PPUSH
108673: CALL_OW 559
108677: GO 108587
108679: POP
108680: POP
// end ; end ;
108681: LD_VAR 0 1
108685: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108686: LD_EXP 156
108690: IFFALSE 109385
108692: GO 108694
108694: DISABLE
108695: LD_INT 0
108697: PPUSH
108698: PPUSH
108699: PPUSH
108700: PPUSH
108701: PPUSH
108702: PPUSH
108703: PPUSH
108704: PPUSH
108705: PPUSH
// begin enable ;
108706: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108707: LD_ADDR_VAR 0 3
108711: PUSH
108712: LD_EXP 156
108716: PPUSH
108717: CALL 91889 0 1
108721: ST_TO_ADDR
// if not list then
108722: LD_VAR 0 3
108726: NOT
108727: IFFALSE 108731
// exit ;
108729: GO 109385
// for i := 1 to list do
108731: LD_ADDR_VAR 0 1
108735: PUSH
108736: DOUBLE
108737: LD_INT 1
108739: DEC
108740: ST_TO_ADDR
108741: LD_VAR 0 3
108745: PUSH
108746: FOR_TO
108747: IFFALSE 109383
// begin depot := list [ i ] [ 2 ] ;
108749: LD_ADDR_VAR 0 8
108753: PUSH
108754: LD_VAR 0 3
108758: PUSH
108759: LD_VAR 0 1
108763: ARRAY
108764: PUSH
108765: LD_INT 2
108767: ARRAY
108768: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108769: LD_ADDR_VAR 0 5
108773: PUSH
108774: LD_VAR 0 3
108778: PUSH
108779: LD_VAR 0 1
108783: ARRAY
108784: PUSH
108785: LD_INT 1
108787: ARRAY
108788: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108789: LD_VAR 0 8
108793: PPUSH
108794: CALL_OW 301
108798: IFTRUE 108817
108800: PUSH
108801: LD_VAR 0 5
108805: PUSH
108806: LD_VAR 0 8
108810: PPUSH
108811: CALL_OW 255
108815: NONEQUAL
108816: OR
108817: IFFALSE 108846
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108819: LD_ADDR_EXP 156
108823: PUSH
108824: LD_EXP 156
108828: PPUSH
108829: LD_VAR 0 8
108833: PPUSH
108834: LD_INT 0
108836: PPUSH
108837: CALL_OW 1
108841: ST_TO_ADDR
// exit ;
108842: POP
108843: POP
108844: GO 109385
// end ; x := list [ i ] [ 3 ] ;
108846: LD_ADDR_VAR 0 6
108850: PUSH
108851: LD_VAR 0 3
108855: PUSH
108856: LD_VAR 0 1
108860: ARRAY
108861: PUSH
108862: LD_INT 3
108864: ARRAY
108865: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108866: LD_ADDR_VAR 0 7
108870: PUSH
108871: LD_VAR 0 3
108875: PUSH
108876: LD_VAR 0 1
108880: ARRAY
108881: PUSH
108882: LD_INT 4
108884: ARRAY
108885: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108886: LD_ADDR_VAR 0 9
108890: PUSH
108891: LD_VAR 0 6
108895: PPUSH
108896: LD_VAR 0 7
108900: PPUSH
108901: LD_INT 16
108903: PPUSH
108904: CALL 90463 0 3
108908: ST_TO_ADDR
// if not cratesNearbyPoint then
108909: LD_VAR 0 9
108913: NOT
108914: IFFALSE 108920
// exit ;
108916: POP
108917: POP
108918: GO 109385
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108920: LD_ADDR_VAR 0 4
108924: PUSH
108925: LD_INT 22
108927: PUSH
108928: LD_VAR 0 5
108932: PUSH
108933: EMPTY
108934: LIST
108935: LIST
108936: PUSH
108937: LD_INT 3
108939: PUSH
108940: LD_INT 60
108942: PUSH
108943: EMPTY
108944: LIST
108945: PUSH
108946: EMPTY
108947: LIST
108948: LIST
108949: PUSH
108950: LD_INT 91
108952: PUSH
108953: LD_VAR 0 8
108957: PUSH
108958: LD_INT 6
108960: PUSH
108961: EMPTY
108962: LIST
108963: LIST
108964: LIST
108965: PUSH
108966: LD_INT 2
108968: PUSH
108969: LD_INT 25
108971: PUSH
108972: LD_INT 2
108974: PUSH
108975: EMPTY
108976: LIST
108977: LIST
108978: PUSH
108979: LD_INT 25
108981: PUSH
108982: LD_INT 16
108984: PUSH
108985: EMPTY
108986: LIST
108987: LIST
108988: PUSH
108989: EMPTY
108990: LIST
108991: LIST
108992: LIST
108993: PUSH
108994: EMPTY
108995: LIST
108996: LIST
108997: LIST
108998: LIST
108999: PPUSH
109000: CALL_OW 69
109004: PUSH
109005: LD_VAR 0 8
109009: PPUSH
109010: CALL_OW 313
109014: PPUSH
109015: LD_INT 3
109017: PUSH
109018: LD_INT 60
109020: PUSH
109021: EMPTY
109022: LIST
109023: PUSH
109024: EMPTY
109025: LIST
109026: LIST
109027: PUSH
109028: LD_INT 2
109030: PUSH
109031: LD_INT 25
109033: PUSH
109034: LD_INT 2
109036: PUSH
109037: EMPTY
109038: LIST
109039: LIST
109040: PUSH
109041: LD_INT 25
109043: PUSH
109044: LD_INT 16
109046: PUSH
109047: EMPTY
109048: LIST
109049: LIST
109050: PUSH
109051: EMPTY
109052: LIST
109053: LIST
109054: LIST
109055: PUSH
109056: EMPTY
109057: LIST
109058: LIST
109059: PPUSH
109060: CALL_OW 72
109064: UNION
109065: ST_TO_ADDR
// if tmp then
109066: LD_VAR 0 4
109070: IFFALSE 109150
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109072: LD_ADDR_VAR 0 4
109076: PUSH
109077: LD_VAR 0 4
109081: PPUSH
109082: LD_INT 3
109084: PPUSH
109085: CALL 88270 0 2
109089: ST_TO_ADDR
// for j in tmp do
109090: LD_ADDR_VAR 0 2
109094: PUSH
109095: LD_VAR 0 4
109099: PUSH
109100: FOR_IN
109101: IFFALSE 109144
// begin if IsInUnit ( j ) then
109103: LD_VAR 0 2
109107: PPUSH
109108: CALL_OW 310
109112: IFFALSE 109123
// ComExit ( j ) ;
109114: LD_VAR 0 2
109118: PPUSH
109119: CALL 88353 0 1
// AddComCollect ( j , x , y ) ;
109123: LD_VAR 0 2
109127: PPUSH
109128: LD_VAR 0 6
109132: PPUSH
109133: LD_VAR 0 7
109137: PPUSH
109138: CALL_OW 177
// end ;
109142: GO 109100
109144: POP
109145: POP
// exit ;
109146: POP
109147: POP
109148: GO 109385
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109150: LD_ADDR_VAR 0 4
109154: PUSH
109155: LD_INT 22
109157: PUSH
109158: LD_VAR 0 5
109162: PUSH
109163: EMPTY
109164: LIST
109165: LIST
109166: PUSH
109167: LD_INT 91
109169: PUSH
109170: LD_VAR 0 8
109174: PUSH
109175: LD_INT 8
109177: PUSH
109178: EMPTY
109179: LIST
109180: LIST
109181: LIST
109182: PUSH
109183: LD_INT 2
109185: PUSH
109186: LD_INT 34
109188: PUSH
109189: LD_INT 12
109191: PUSH
109192: EMPTY
109193: LIST
109194: LIST
109195: PUSH
109196: LD_INT 34
109198: PUSH
109199: LD_INT 51
109201: PUSH
109202: EMPTY
109203: LIST
109204: LIST
109205: PUSH
109206: LD_INT 34
109208: PUSH
109209: LD_INT 32
109211: PUSH
109212: EMPTY
109213: LIST
109214: LIST
109215: PUSH
109216: LD_INT 34
109218: PUSH
109219: LD_INT 89
109221: PUSH
109222: EMPTY
109223: LIST
109224: LIST
109225: PUSH
109226: EMPTY
109227: LIST
109228: LIST
109229: LIST
109230: LIST
109231: LIST
109232: PUSH
109233: EMPTY
109234: LIST
109235: LIST
109236: LIST
109237: PPUSH
109238: CALL_OW 69
109242: ST_TO_ADDR
// if tmp then
109243: LD_VAR 0 4
109247: IFFALSE 109381
// begin for j in tmp do
109249: LD_ADDR_VAR 0 2
109253: PUSH
109254: LD_VAR 0 4
109258: PUSH
109259: FOR_IN
109260: IFFALSE 109379
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109262: LD_VAR 0 2
109266: PPUSH
109267: CALL_OW 262
109271: PUSH
109272: LD_INT 3
109274: EQUAL
109275: IFTRUE 109292
109277: PUSH
109278: LD_VAR 0 2
109282: PPUSH
109283: CALL_OW 261
109287: PUSH
109288: LD_INT 20
109290: GREATER
109291: OR
109292: IFFALSE 109306
109294: PUSH
109295: LD_VAR 0 2
109299: PPUSH
109300: CALL_OW 314
109304: NOT
109305: AND
109306: IFFALSE 109336
109308: PUSH
109309: LD_VAR 0 2
109313: PPUSH
109314: CALL_OW 263
109318: PUSH
109319: LD_INT 1
109321: NONEQUAL
109322: IFTRUE 109335
109324: PUSH
109325: LD_VAR 0 2
109329: PPUSH
109330: CALL_OW 311
109334: OR
109335: AND
109336: IFFALSE 109377
// begin ComCollect ( j , x , y ) ;
109338: LD_VAR 0 2
109342: PPUSH
109343: LD_VAR 0 6
109347: PPUSH
109348: LD_VAR 0 7
109352: PPUSH
109353: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109357: LD_VAR 0 2
109361: PPUSH
109362: LD_VAR 0 8
109366: PPUSH
109367: CALL_OW 172
// exit ;
109371: POP
109372: POP
109373: POP
109374: POP
109375: GO 109385
// end ;
109377: GO 109259
109379: POP
109380: POP
// end ; end ;
109381: GO 108746
109383: POP
109384: POP
// end ; end_of_file
109385: PPOPN 9
109387: END
// export function SOS_UnitDestroyed ( un ) ; begin
109388: LD_INT 0
109390: PPUSH
// ComRadiation ( un ) ;
109391: LD_VAR 0 1
109395: PPUSH
109396: CALL 110558 0 1
// end ;
109400: LD_VAR 0 2
109404: RET
// export function SOS_UnitKamikazed ( un ) ; begin
109405: LD_INT 0
109407: PPUSH
// ComRadiation ( un ) ;
109408: LD_VAR 0 1
109412: PPUSH
109413: CALL 110558 0 1
// end ;
109417: LD_VAR 0 2
109421: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
109422: LD_INT 0
109424: PPUSH
// end ;
109425: LD_VAR 0 4
109429: RET
// export function SOS_Command ( cmd ) ; begin
109430: LD_INT 0
109432: PPUSH
// end ;
109433: LD_VAR 0 2
109437: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
109438: LD_INT 0
109440: PPUSH
// end ;
109441: LD_VAR 0 6
109445: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex , weapon ; begin
109446: LD_INT 0
109448: PPUSH
109449: PPUSH
109450: PPUSH
109451: PPUSH
109452: PPUSH
// if not vehicle or not factory then
109453: LD_VAR 0 1
109457: NOT
109458: IFTRUE 109467
109460: PUSH
109461: LD_VAR 0 2
109465: NOT
109466: OR
109467: IFFALSE 109471
// exit ;
109469: GO 110133
// weapon := GetWeapon ( vehicle ) ;
109471: LD_ADDR_VAR 0 7
109475: PUSH
109476: LD_VAR 0 1
109480: PPUSH
109481: CALL_OW 264
109485: ST_TO_ADDR
// if weapon = ar_miner then
109486: LD_VAR 0 7
109490: PUSH
109491: LD_INT 81
109493: EQUAL
109494: IFFALSE 109551
// begin minersList := Replace ( minersList , minersList + 1 , vehicle ) ;
109496: LD_ADDR_EXP 165
109500: PUSH
109501: LD_EXP 165
109505: PPUSH
109506: LD_EXP 165
109510: PUSH
109511: LD_INT 1
109513: PLUS
109514: PPUSH
109515: LD_VAR 0 1
109519: PPUSH
109520: CALL_OW 1
109524: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109525: LD_ADDR_EXP 166
109529: PUSH
109530: LD_EXP 166
109534: PPUSH
109535: LD_EXP 166
109539: PUSH
109540: LD_INT 1
109542: PLUS
109543: PPUSH
109544: EMPTY
109545: PPUSH
109546: CALL_OW 1
109550: ST_TO_ADDR
// end ; if not factoryWaypoints then
109551: LD_EXP 154
109555: NOT
109556: IFFALSE 109560
// exit ;
109558: GO 110133
// for i := 1 to Count ( factoryWaypoints ) do
109560: LD_ADDR_VAR 0 4
109564: PUSH
109565: DOUBLE
109566: LD_INT 1
109568: DEC
109569: ST_TO_ADDR
109570: LD_EXP 154
109574: PPUSH
109575: CALL 51979 0 1
109579: PUSH
109580: FOR_TO
109581: IFFALSE 110131
// if factoryWaypoints [ i ] [ 2 ] = factory then
109583: LD_EXP 154
109587: PUSH
109588: LD_VAR 0 4
109592: ARRAY
109593: PUSH
109594: LD_INT 2
109596: ARRAY
109597: PUSH
109598: LD_VAR 0 2
109602: EQUAL
109603: IFFALSE 110129
// begin if GetControl ( vehicle ) = control_manual then
109605: LD_VAR 0 1
109609: PPUSH
109610: CALL_OW 263
109614: PUSH
109615: LD_INT 1
109617: EQUAL
109618: IFFALSE 109982
// begin driver := IsDrivenBy ( vehicle ) ;
109620: LD_ADDR_VAR 0 5
109624: PUSH
109625: LD_VAR 0 1
109629: PPUSH
109630: CALL_OW 311
109634: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
109635: LD_VAR 0 5
109639: PUSH
109640: LD_EXP 155
109644: IN
109645: IFTRUE 109659
109647: PUSH
109648: LD_VAR 0 1
109652: PUSH
109653: LD_EXP 155
109657: IN
109658: OR
109659: IFFALSE 109665
// exit ;
109661: POP
109662: POP
109663: GO 110133
// if not HasTask ( driver ) then
109665: LD_VAR 0 5
109669: PPUSH
109670: CALL_OW 314
109674: NOT
109675: IFFALSE 109980
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
109677: LD_ADDR_EXP 155
109681: PUSH
109682: LD_EXP 155
109686: PPUSH
109687: LD_VAR 0 5
109691: PPUSH
109692: CALL 87955 0 2
109696: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
109697: LD_ADDR_EXP 155
109701: PUSH
109702: LD_EXP 155
109706: PPUSH
109707: LD_VAR 0 1
109711: PPUSH
109712: CALL 87955 0 2
109716: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
109717: LD_ADDR_VAR 0 6
109721: PUSH
109722: LD_EXP 154
109726: PUSH
109727: LD_VAR 0 4
109731: ARRAY
109732: PUSH
109733: LD_INT 3
109735: ARRAY
109736: PPUSH
109737: LD_EXP 154
109741: PUSH
109742: LD_VAR 0 4
109746: ARRAY
109747: PUSH
109748: LD_INT 4
109750: ARRAY
109751: PPUSH
109752: CALL_OW 428
109756: ST_TO_ADDR
// if hex then
109757: LD_VAR 0 6
109761: IFFALSE 109779
// ComMoveUnit ( driver , hex ) else
109763: LD_VAR 0 5
109767: PPUSH
109768: LD_VAR 0 6
109772: PPUSH
109773: CALL_OW 112
109777: GO 109863
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
109779: LD_VAR 0 1
109783: PPUSH
109784: LD_EXP 154
109788: PUSH
109789: LD_VAR 0 4
109793: ARRAY
109794: PUSH
109795: LD_INT 3
109797: ARRAY
109798: PPUSH
109799: LD_EXP 154
109803: PUSH
109804: LD_VAR 0 4
109808: ARRAY
109809: PUSH
109810: LD_INT 4
109812: ARRAY
109813: PPUSH
109814: CALL_OW 297
109818: PUSH
109819: LD_INT 0
109821: GREATER
109822: IFFALSE 109863
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
109824: LD_VAR 0 5
109828: PPUSH
109829: LD_EXP 154
109833: PUSH
109834: LD_VAR 0 4
109838: ARRAY
109839: PUSH
109840: LD_INT 3
109842: ARRAY
109843: PPUSH
109844: LD_EXP 154
109848: PUSH
109849: LD_VAR 0 4
109853: ARRAY
109854: PUSH
109855: LD_INT 4
109857: ARRAY
109858: PPUSH
109859: CALL_OW 111
// AddComExitVehicle ( driver ) ;
109863: LD_VAR 0 5
109867: PPUSH
109868: CALL_OW 181
// if Multiplayer then
109872: LD_OWVAR 4
109876: IFFALSE 109925
// begin repeat wait ( 10 ) ;
109878: LD_INT 10
109880: PPUSH
109881: CALL_OW 67
// until not IsInUnit ( driver ) ;
109885: LD_VAR 0 5
109889: PPUSH
109890: CALL_OW 310
109894: NOT
109895: IFFALSE 109878
// if not HasTask ( driver ) then
109897: LD_VAR 0 5
109901: PPUSH
109902: CALL_OW 314
109906: NOT
109907: IFFALSE 109923
// ComEnterUnit ( driver , factory ) ;
109909: LD_VAR 0 5
109913: PPUSH
109914: LD_VAR 0 2
109918: PPUSH
109919: CALL_OW 120
// end else
109923: GO 109939
// AddComEnterUnit ( driver , factory ) ;
109925: LD_VAR 0 5
109929: PPUSH
109930: LD_VAR 0 2
109934: PPUSH
109935: CALL_OW 180
// wait ( 0 0$1 ) ;
109939: LD_INT 35
109941: PPUSH
109942: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
109946: LD_ADDR_EXP 155
109950: PUSH
109951: LD_EXP 155
109955: PUSH
109956: LD_VAR 0 5
109960: DIFF
109961: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
109962: LD_ADDR_EXP 155
109966: PUSH
109967: LD_EXP 155
109971: PUSH
109972: LD_VAR 0 1
109976: DIFF
109977: ST_TO_ADDR
// break ;
109978: GO 110131
// end ; end else
109980: GO 110129
// if GetControl ( vehicle ) = control_remote then
109982: LD_VAR 0 1
109986: PPUSH
109987: CALL_OW 263
109991: PUSH
109992: LD_INT 2
109994: EQUAL
109995: IFFALSE 110081
// begin wait ( 0 0$2 ) ;
109997: LD_INT 70
109999: PPUSH
110000: CALL_OW 67
// repeat wait ( 10 ) ;
110004: LD_INT 10
110006: PPUSH
110007: CALL_OW 67
// Connect ( vehicle ) ;
110011: LD_VAR 0 1
110015: PPUSH
110016: CALL 58257 0 1
// until IsControledBy ( vehicle ) ;
110020: LD_VAR 0 1
110024: PPUSH
110025: CALL_OW 312
110029: IFFALSE 110004
// wait ( 10 ) ;
110031: LD_INT 10
110033: PPUSH
110034: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
110038: LD_VAR 0 1
110042: PPUSH
110043: LD_EXP 154
110047: PUSH
110048: LD_VAR 0 4
110052: ARRAY
110053: PUSH
110054: LD_INT 3
110056: ARRAY
110057: PPUSH
110058: LD_EXP 154
110062: PUSH
110063: LD_VAR 0 4
110067: ARRAY
110068: PUSH
110069: LD_INT 4
110071: ARRAY
110072: PPUSH
110073: CALL_OW 111
// break ;
110077: GO 110131
// end else
110079: GO 110129
// begin wait ( 0 0$3 ) ;
110081: LD_INT 105
110083: PPUSH
110084: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
110088: LD_VAR 0 1
110092: PPUSH
110093: LD_EXP 154
110097: PUSH
110098: LD_VAR 0 4
110102: ARRAY
110103: PUSH
110104: LD_INT 3
110106: ARRAY
110107: PPUSH
110108: LD_EXP 154
110112: PUSH
110113: LD_VAR 0 4
110117: ARRAY
110118: PUSH
110119: LD_INT 4
110121: ARRAY
110122: PPUSH
110123: CALL_OW 111
// break ;
110127: GO 110131
// end ; end ;
110129: GO 109580
110131: POP
110132: POP
// end ;
110133: LD_VAR 0 3
110137: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
110138: LD_INT 0
110140: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
110141: LD_VAR 0 1
110145: PUSH
110146: LD_INT 250
110148: EQUAL
110149: IFFALSE 110166
110151: PUSH
110152: LD_VAR 0 2
110156: PPUSH
110157: CALL_OW 264
110161: PUSH
110162: LD_INT 81
110164: EQUAL
110165: AND
110166: IFFALSE 110187
// MinerPlaceMine ( unit , x , y ) ;
110168: LD_VAR 0 2
110172: PPUSH
110173: LD_VAR 0 4
110177: PPUSH
110178: LD_VAR 0 5
110182: PPUSH
110183: CALL 113468 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
110187: LD_VAR 0 1
110191: PUSH
110192: LD_INT 251
110194: EQUAL
110195: IFFALSE 110212
110197: PUSH
110198: LD_VAR 0 2
110202: PPUSH
110203: CALL_OW 264
110207: PUSH
110208: LD_INT 81
110210: EQUAL
110211: AND
110212: IFFALSE 110233
// MinerDetonateMine ( unit , x , y ) ;
110214: LD_VAR 0 2
110218: PPUSH
110219: LD_VAR 0 4
110223: PPUSH
110224: LD_VAR 0 5
110228: PPUSH
110229: CALL 113875 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
110233: LD_VAR 0 1
110237: PUSH
110238: LD_INT 252
110240: EQUAL
110241: IFFALSE 110258
110243: PUSH
110244: LD_VAR 0 2
110248: PPUSH
110249: CALL_OW 264
110253: PUSH
110254: LD_INT 81
110256: EQUAL
110257: AND
110258: IFFALSE 110279
// MinerCreateMinefield ( unit , x , y ) ;
110260: LD_VAR 0 2
110264: PPUSH
110265: LD_VAR 0 4
110269: PPUSH
110270: LD_VAR 0 5
110274: PPUSH
110275: CALL 114107 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
110279: LD_VAR 0 1
110283: PUSH
110284: LD_INT 253
110286: EQUAL
110287: IFFALSE 110304
110289: PUSH
110290: LD_VAR 0 2
110294: PPUSH
110295: CALL_OW 257
110299: PUSH
110300: LD_INT 5
110302: EQUAL
110303: AND
110304: IFFALSE 110325
// ComBinocular ( unit , x , y ) ;
110306: LD_VAR 0 2
110310: PPUSH
110311: LD_VAR 0 4
110315: PPUSH
110316: LD_VAR 0 5
110320: PPUSH
110321: CALL 114482 0 3
// if selectedUnit then
110325: LD_VAR 0 3
110329: IFFALSE 110389
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
110331: LD_VAR 0 1
110335: PUSH
110336: LD_INT 254
110338: EQUAL
110339: IFFALSE 110356
110341: PUSH
110342: LD_VAR 0 2
110346: PPUSH
110347: CALL_OW 264
110351: PUSH
110352: LD_INT 99
110354: EQUAL
110355: AND
110356: IFFALSE 110373
110358: PUSH
110359: LD_VAR 0 3
110363: PPUSH
110364: CALL_OW 263
110368: PUSH
110369: LD_INT 3
110371: EQUAL
110372: AND
110373: IFFALSE 110389
// HackDestroyVehicle ( unit , selectedUnit ) ;
110375: LD_VAR 0 2
110379: PPUSH
110380: LD_VAR 0 3
110384: PPUSH
110385: CALL 112679 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
110389: LD_VAR 0 1
110393: PUSH
110394: LD_INT 255
110396: EQUAL
110397: IFFALSE 110421
110399: PUSH
110400: LD_VAR 0 2
110404: PPUSH
110405: CALL_OW 264
110409: PUSH
110410: LD_INT 14
110412: PUSH
110413: LD_INT 53
110415: PUSH
110416: EMPTY
110417: LIST
110418: LIST
110419: IN
110420: AND
110421: IFFALSE 110439
110423: PUSH
110424: LD_VAR 0 4
110428: PPUSH
110429: LD_VAR 0 5
110433: PPUSH
110434: CALL_OW 488
110438: AND
110439: IFFALSE 110463
// CutTreeXYR ( unit , x , y , 12 ) ;
110441: LD_VAR 0 2
110445: PPUSH
110446: LD_VAR 0 4
110450: PPUSH
110451: LD_VAR 0 5
110455: PPUSH
110456: LD_INT 12
110458: PPUSH
110459: CALL 110654 0 4
// if cmd = 256 then
110463: LD_VAR 0 1
110467: PUSH
110468: LD_INT 256
110470: EQUAL
110471: IFFALSE 110492
// SetFactoryWaypoint ( unit , x , y ) ;
110473: LD_VAR 0 2
110477: PPUSH
110478: LD_VAR 0 4
110482: PPUSH
110483: LD_VAR 0 5
110487: PPUSH
110488: CALL 107933 0 3
// if cmd = 257 then
110492: LD_VAR 0 1
110496: PUSH
110497: LD_INT 257
110499: EQUAL
110500: IFFALSE 110521
// SetWarehouseGatheringPoint ( unit , x , y ) ;
110502: LD_VAR 0 2
110506: PPUSH
110507: LD_VAR 0 4
110511: PPUSH
110512: LD_VAR 0 5
110516: PPUSH
110517: CALL 108429 0 3
// if cmd = 258 then
110521: LD_VAR 0 1
110525: PUSH
110526: LD_INT 258
110528: EQUAL
110529: IFFALSE 110553
// BurnTreeXYR ( unit , x , y , 8 ) ;
110531: LD_VAR 0 2
110535: PPUSH
110536: LD_VAR 0 4
110540: PPUSH
110541: LD_VAR 0 5
110545: PPUSH
110546: LD_INT 8
110548: PPUSH
110549: CALL 111054 0 4
// end ;
110553: LD_VAR 0 6
110557: RET
// export function ComRadiation ( un ) ; var eff ; begin
110558: LD_INT 0
110560: PPUSH
110561: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
110562: LD_VAR 0 1
110566: PPUSH
110567: CALL_OW 264
110571: PUSH
110572: LD_INT 91
110574: NONEQUAL
110575: IFFALSE 110579
// exit ;
110577: GO 110649
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
110579: LD_INT 68
110581: PPUSH
110582: LD_VAR 0 1
110586: PPUSH
110587: CALL_OW 255
110591: PPUSH
110592: CALL_OW 321
110596: PUSH
110597: LD_INT 2
110599: EQUAL
110600: IFFALSE 110612
// eff := 50 else
110602: LD_ADDR_VAR 0 3
110606: PUSH
110607: LD_INT 50
110609: ST_TO_ADDR
110610: GO 110620
// eff := 25 ;
110612: LD_ADDR_VAR 0 3
110616: PUSH
110617: LD_INT 25
110619: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
110620: LD_VAR 0 1
110624: PPUSH
110625: CALL_OW 250
110629: PPUSH
110630: LD_VAR 0 1
110634: PPUSH
110635: CALL_OW 251
110639: PPUSH
110640: LD_VAR 0 3
110644: PPUSH
110645: CALL_OW 495
// end ;
110649: LD_VAR 0 2
110653: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
110654: LD_INT 0
110656: PPUSH
110657: PPUSH
110658: PPUSH
110659: PPUSH
110660: PPUSH
110661: PPUSH
110662: PPUSH
110663: PPUSH
110664: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
110665: LD_VAR 0 1
110669: PPUSH
110670: CALL_OW 302
110674: NOT
110675: IFTRUE 110694
110677: PUSH
110678: LD_VAR 0 2
110682: PPUSH
110683: LD_VAR 0 3
110687: PPUSH
110688: CALL_OW 488
110692: NOT
110693: OR
110694: IFTRUE 110703
110696: PUSH
110697: LD_VAR 0 4
110701: NOT
110702: OR
110703: IFFALSE 110707
// exit ;
110705: GO 111049
// list := [ ] ;
110707: LD_ADDR_VAR 0 13
110711: PUSH
110712: EMPTY
110713: ST_TO_ADDR
// if x - r < 0 then
110714: LD_VAR 0 2
110718: PUSH
110719: LD_VAR 0 4
110723: MINUS
110724: PUSH
110725: LD_INT 0
110727: LESS
110728: IFFALSE 110740
// min_x := 0 else
110730: LD_ADDR_VAR 0 7
110734: PUSH
110735: LD_INT 0
110737: ST_TO_ADDR
110738: GO 110756
// min_x := x - r ;
110740: LD_ADDR_VAR 0 7
110744: PUSH
110745: LD_VAR 0 2
110749: PUSH
110750: LD_VAR 0 4
110754: MINUS
110755: ST_TO_ADDR
// if y - r < 0 then
110756: LD_VAR 0 3
110760: PUSH
110761: LD_VAR 0 4
110765: MINUS
110766: PUSH
110767: LD_INT 0
110769: LESS
110770: IFFALSE 110782
// min_y := 0 else
110772: LD_ADDR_VAR 0 8
110776: PUSH
110777: LD_INT 0
110779: ST_TO_ADDR
110780: GO 110798
// min_y := y - r ;
110782: LD_ADDR_VAR 0 8
110786: PUSH
110787: LD_VAR 0 3
110791: PUSH
110792: LD_VAR 0 4
110796: MINUS
110797: ST_TO_ADDR
// max_x := x + r ;
110798: LD_ADDR_VAR 0 9
110802: PUSH
110803: LD_VAR 0 2
110807: PUSH
110808: LD_VAR 0 4
110812: PLUS
110813: ST_TO_ADDR
// max_y := y + r ;
110814: LD_ADDR_VAR 0 10
110818: PUSH
110819: LD_VAR 0 3
110823: PUSH
110824: LD_VAR 0 4
110828: PLUS
110829: ST_TO_ADDR
// for _x = min_x to max_x do
110830: LD_ADDR_VAR 0 11
110834: PUSH
110835: DOUBLE
110836: LD_VAR 0 7
110840: DEC
110841: ST_TO_ADDR
110842: LD_VAR 0 9
110846: PUSH
110847: FOR_TO
110848: IFFALSE 110967
// for _y = min_y to max_y do
110850: LD_ADDR_VAR 0 12
110854: PUSH
110855: DOUBLE
110856: LD_VAR 0 8
110860: DEC
110861: ST_TO_ADDR
110862: LD_VAR 0 10
110866: PUSH
110867: FOR_TO
110868: IFFALSE 110963
// begin if not ValidHex ( _x , _y ) then
110870: LD_VAR 0 11
110874: PPUSH
110875: LD_VAR 0 12
110879: PPUSH
110880: CALL_OW 488
110884: NOT
110885: IFFALSE 110889
// continue ;
110887: GO 110867
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110889: LD_VAR 0 11
110893: PPUSH
110894: LD_VAR 0 12
110898: PPUSH
110899: CALL_OW 351
110903: IFFALSE 110921
110905: PUSH
110906: LD_VAR 0 11
110910: PPUSH
110911: LD_VAR 0 12
110915: PPUSH
110916: CALL_OW 554
110920: AND
110921: IFFALSE 110961
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110923: LD_ADDR_VAR 0 13
110927: PUSH
110928: LD_VAR 0 13
110932: PPUSH
110933: LD_VAR 0 13
110937: PUSH
110938: LD_INT 1
110940: PLUS
110941: PPUSH
110942: LD_VAR 0 11
110946: PUSH
110947: LD_VAR 0 12
110951: PUSH
110952: EMPTY
110953: LIST
110954: LIST
110955: PPUSH
110956: CALL_OW 2
110960: ST_TO_ADDR
// end ;
110961: GO 110867
110963: POP
110964: POP
110965: GO 110847
110967: POP
110968: POP
// if not list then
110969: LD_VAR 0 13
110973: NOT
110974: IFFALSE 110978
// exit ;
110976: GO 111049
// for i in list do
110978: LD_ADDR_VAR 0 6
110982: PUSH
110983: LD_VAR 0 13
110987: PUSH
110988: FOR_IN
110989: IFFALSE 111047
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
110991: LD_VAR 0 1
110995: PPUSH
110996: LD_STRING M
110998: PUSH
110999: LD_VAR 0 6
111003: PUSH
111004: LD_INT 1
111006: ARRAY
111007: PUSH
111008: LD_VAR 0 6
111012: PUSH
111013: LD_INT 2
111015: ARRAY
111016: PUSH
111017: LD_INT 0
111019: PUSH
111020: LD_INT 0
111022: PUSH
111023: LD_INT 0
111025: PUSH
111026: LD_INT 0
111028: PUSH
111029: EMPTY
111030: LIST
111031: LIST
111032: LIST
111033: LIST
111034: LIST
111035: LIST
111036: LIST
111037: PUSH
111038: EMPTY
111039: LIST
111040: PPUSH
111041: CALL_OW 447
111045: GO 110988
111047: POP
111048: POP
// end ;
111049: LD_VAR 0 5
111053: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
111054: LD_INT 0
111056: PPUSH
111057: PPUSH
111058: PPUSH
111059: PPUSH
111060: PPUSH
111061: PPUSH
111062: PPUSH
111063: PPUSH
111064: PPUSH
111065: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
111066: LD_VAR 0 1
111070: PPUSH
111071: CALL_OW 302
111075: NOT
111076: IFTRUE 111095
111078: PUSH
111079: LD_VAR 0 2
111083: PPUSH
111084: LD_VAR 0 3
111088: PPUSH
111089: CALL_OW 488
111093: NOT
111094: OR
111095: IFTRUE 111104
111097: PUSH
111098: LD_VAR 0 4
111102: NOT
111103: OR
111104: IFFALSE 111108
// exit ;
111106: GO 111625
// list := [ ] ;
111108: LD_ADDR_VAR 0 13
111112: PUSH
111113: EMPTY
111114: ST_TO_ADDR
// if x - r < 0 then
111115: LD_VAR 0 2
111119: PUSH
111120: LD_VAR 0 4
111124: MINUS
111125: PUSH
111126: LD_INT 0
111128: LESS
111129: IFFALSE 111141
// min_x := 0 else
111131: LD_ADDR_VAR 0 7
111135: PUSH
111136: LD_INT 0
111138: ST_TO_ADDR
111139: GO 111157
// min_x := x - r ;
111141: LD_ADDR_VAR 0 7
111145: PUSH
111146: LD_VAR 0 2
111150: PUSH
111151: LD_VAR 0 4
111155: MINUS
111156: ST_TO_ADDR
// if y - r < 0 then
111157: LD_VAR 0 3
111161: PUSH
111162: LD_VAR 0 4
111166: MINUS
111167: PUSH
111168: LD_INT 0
111170: LESS
111171: IFFALSE 111183
// min_y := 0 else
111173: LD_ADDR_VAR 0 8
111177: PUSH
111178: LD_INT 0
111180: ST_TO_ADDR
111181: GO 111199
// min_y := y - r ;
111183: LD_ADDR_VAR 0 8
111187: PUSH
111188: LD_VAR 0 3
111192: PUSH
111193: LD_VAR 0 4
111197: MINUS
111198: ST_TO_ADDR
// max_x := x + r ;
111199: LD_ADDR_VAR 0 9
111203: PUSH
111204: LD_VAR 0 2
111208: PUSH
111209: LD_VAR 0 4
111213: PLUS
111214: ST_TO_ADDR
// max_y := y + r ;
111215: LD_ADDR_VAR 0 10
111219: PUSH
111220: LD_VAR 0 3
111224: PUSH
111225: LD_VAR 0 4
111229: PLUS
111230: ST_TO_ADDR
// for _x = min_x to max_x do
111231: LD_ADDR_VAR 0 11
111235: PUSH
111236: DOUBLE
111237: LD_VAR 0 7
111241: DEC
111242: ST_TO_ADDR
111243: LD_VAR 0 9
111247: PUSH
111248: FOR_TO
111249: IFFALSE 111368
// for _y = min_y to max_y do
111251: LD_ADDR_VAR 0 12
111255: PUSH
111256: DOUBLE
111257: LD_VAR 0 8
111261: DEC
111262: ST_TO_ADDR
111263: LD_VAR 0 10
111267: PUSH
111268: FOR_TO
111269: IFFALSE 111364
// begin if not ValidHex ( _x , _y ) then
111271: LD_VAR 0 11
111275: PPUSH
111276: LD_VAR 0 12
111280: PPUSH
111281: CALL_OW 488
111285: NOT
111286: IFFALSE 111290
// continue ;
111288: GO 111268
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
111290: LD_VAR 0 11
111294: PPUSH
111295: LD_VAR 0 12
111299: PPUSH
111300: CALL_OW 351
111304: IFFALSE 111322
111306: PUSH
111307: LD_VAR 0 11
111311: PPUSH
111312: LD_VAR 0 12
111316: PPUSH
111317: CALL_OW 554
111321: AND
111322: IFFALSE 111362
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
111324: LD_ADDR_VAR 0 13
111328: PUSH
111329: LD_VAR 0 13
111333: PPUSH
111334: LD_VAR 0 13
111338: PUSH
111339: LD_INT 1
111341: PLUS
111342: PPUSH
111343: LD_VAR 0 11
111347: PUSH
111348: LD_VAR 0 12
111352: PUSH
111353: EMPTY
111354: LIST
111355: LIST
111356: PPUSH
111357: CALL_OW 2
111361: ST_TO_ADDR
// end ;
111362: GO 111268
111364: POP
111365: POP
111366: GO 111248
111368: POP
111369: POP
// if not list then
111370: LD_VAR 0 13
111374: NOT
111375: IFFALSE 111379
// exit ;
111377: GO 111625
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
111379: LD_ADDR_VAR 0 13
111383: PUSH
111384: LD_VAR 0 1
111388: PPUSH
111389: LD_VAR 0 13
111393: PPUSH
111394: LD_INT 1
111396: PPUSH
111397: LD_INT 1
111399: PPUSH
111400: CALL 55385 0 4
111404: ST_TO_ADDR
// ComStop ( flame ) ;
111405: LD_VAR 0 1
111409: PPUSH
111410: CALL_OW 141
// for i in list do
111414: LD_ADDR_VAR 0 6
111418: PUSH
111419: LD_VAR 0 13
111423: PUSH
111424: FOR_IN
111425: IFFALSE 111456
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
111427: LD_VAR 0 1
111431: PPUSH
111432: LD_VAR 0 6
111436: PUSH
111437: LD_INT 1
111439: ARRAY
111440: PPUSH
111441: LD_VAR 0 6
111445: PUSH
111446: LD_INT 2
111448: ARRAY
111449: PPUSH
111450: CALL_OW 176
111454: GO 111424
111456: POP
111457: POP
// repeat wait ( 0 0$1 ) ;
111458: LD_INT 35
111460: PPUSH
111461: CALL_OW 67
// task := GetTaskList ( flame ) ;
111465: LD_ADDR_VAR 0 14
111469: PUSH
111470: LD_VAR 0 1
111474: PPUSH
111475: CALL_OW 437
111479: ST_TO_ADDR
// if not task then
111480: LD_VAR 0 14
111484: NOT
111485: IFFALSE 111489
// exit ;
111487: GO 111625
// if task [ 1 ] [ 1 ] <> | then
111489: LD_VAR 0 14
111493: PUSH
111494: LD_INT 1
111496: ARRAY
111497: PUSH
111498: LD_INT 1
111500: ARRAY
111501: PUSH
111502: LD_STRING |
111504: NONEQUAL
111505: IFFALSE 111509
// exit ;
111507: GO 111625
// _x := task [ 1 ] [ 2 ] ;
111509: LD_ADDR_VAR 0 11
111513: PUSH
111514: LD_VAR 0 14
111518: PUSH
111519: LD_INT 1
111521: ARRAY
111522: PUSH
111523: LD_INT 2
111525: ARRAY
111526: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
111527: LD_ADDR_VAR 0 12
111531: PUSH
111532: LD_VAR 0 14
111536: PUSH
111537: LD_INT 1
111539: ARRAY
111540: PUSH
111541: LD_INT 3
111543: ARRAY
111544: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
111545: LD_VAR 0 11
111549: PPUSH
111550: LD_VAR 0 12
111554: PPUSH
111555: CALL_OW 351
111559: NOT
111560: IFTRUE 111579
111562: PUSH
111563: LD_VAR 0 11
111567: PPUSH
111568: LD_VAR 0 12
111572: PPUSH
111573: CALL_OW 554
111577: NOT
111578: OR
111579: IFFALSE 111613
// begin task := Delete ( task , 1 ) ;
111581: LD_ADDR_VAR 0 14
111585: PUSH
111586: LD_VAR 0 14
111590: PPUSH
111591: LD_INT 1
111593: PPUSH
111594: CALL_OW 3
111598: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
111599: LD_VAR 0 1
111603: PPUSH
111604: LD_VAR 0 14
111608: PPUSH
111609: CALL_OW 446
// end ; until not HasTask ( flame ) ;
111613: LD_VAR 0 1
111617: PPUSH
111618: CALL_OW 314
111622: NOT
111623: IFFALSE 111458
// end ;
111625: LD_VAR 0 5
111629: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
111630: LD_EXP 158
111634: NOT
111635: IFFALSE 111685
111637: GO 111639
111639: DISABLE
// begin initHack := true ;
111640: LD_ADDR_EXP 158
111644: PUSH
111645: LD_INT 1
111647: ST_TO_ADDR
// hackTanks := [ ] ;
111648: LD_ADDR_EXP 159
111652: PUSH
111653: EMPTY
111654: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
111655: LD_ADDR_EXP 160
111659: PUSH
111660: EMPTY
111661: ST_TO_ADDR
// hackLimit := 3 ;
111662: LD_ADDR_EXP 161
111666: PUSH
111667: LD_INT 3
111669: ST_TO_ADDR
// hackDist := 12 ;
111670: LD_ADDR_EXP 162
111674: PUSH
111675: LD_INT 12
111677: ST_TO_ADDR
// hackCounter := [ ] ;
111678: LD_ADDR_EXP 163
111682: PUSH
111683: EMPTY
111684: ST_TO_ADDR
// end ;
111685: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
111686: LD_EXP 158
111690: IFFALSE 111708
111692: PUSH
111693: LD_INT 34
111695: PUSH
111696: LD_INT 99
111698: PUSH
111699: EMPTY
111700: LIST
111701: LIST
111702: PPUSH
111703: CALL_OW 69
111707: AND
111708: IFFALSE 111961
111710: GO 111712
111712: DISABLE
111713: LD_INT 0
111715: PPUSH
111716: PPUSH
// begin enable ;
111717: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
111718: LD_ADDR_VAR 0 1
111722: PUSH
111723: LD_INT 34
111725: PUSH
111726: LD_INT 99
111728: PUSH
111729: EMPTY
111730: LIST
111731: LIST
111732: PPUSH
111733: CALL_OW 69
111737: PUSH
111738: FOR_IN
111739: IFFALSE 111959
// begin if not i in hackTanks then
111741: LD_VAR 0 1
111745: PUSH
111746: LD_EXP 159
111750: IN
111751: NOT
111752: IFFALSE 111835
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
111754: LD_ADDR_EXP 159
111758: PUSH
111759: LD_EXP 159
111763: PPUSH
111764: LD_EXP 159
111768: PUSH
111769: LD_INT 1
111771: PLUS
111772: PPUSH
111773: LD_VAR 0 1
111777: PPUSH
111778: CALL_OW 1
111782: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
111783: LD_ADDR_EXP 160
111787: PUSH
111788: LD_EXP 160
111792: PPUSH
111793: LD_EXP 160
111797: PUSH
111798: LD_INT 1
111800: PLUS
111801: PPUSH
111802: EMPTY
111803: PPUSH
111804: CALL_OW 1
111808: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
111809: LD_ADDR_EXP 163
111813: PUSH
111814: LD_EXP 163
111818: PPUSH
111819: LD_EXP 163
111823: PUSH
111824: LD_INT 1
111826: PLUS
111827: PPUSH
111828: EMPTY
111829: PPUSH
111830: CALL_OW 1
111834: ST_TO_ADDR
// end ; if not IsOk ( i ) then
111835: LD_VAR 0 1
111839: PPUSH
111840: CALL_OW 302
111844: NOT
111845: IFFALSE 111858
// begin HackUnlinkAll ( i ) ;
111847: LD_VAR 0 1
111851: PPUSH
111852: CALL 111964 0 1
// continue ;
111856: GO 111738
// end ; HackCheckCapturedStatus ( i ) ;
111858: LD_VAR 0 1
111862: PPUSH
111863: CALL 112409 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
111867: LD_ADDR_VAR 0 2
111871: PUSH
111872: LD_INT 81
111874: PUSH
111875: LD_VAR 0 1
111879: PPUSH
111880: CALL_OW 255
111884: PUSH
111885: EMPTY
111886: LIST
111887: LIST
111888: PUSH
111889: LD_INT 33
111891: PUSH
111892: LD_INT 3
111894: PUSH
111895: EMPTY
111896: LIST
111897: LIST
111898: PUSH
111899: LD_INT 91
111901: PUSH
111902: LD_VAR 0 1
111906: PUSH
111907: LD_EXP 162
111911: PUSH
111912: EMPTY
111913: LIST
111914: LIST
111915: LIST
111916: PUSH
111917: LD_INT 50
111919: PUSH
111920: EMPTY
111921: LIST
111922: PUSH
111923: EMPTY
111924: LIST
111925: LIST
111926: LIST
111927: LIST
111928: PPUSH
111929: CALL_OW 69
111933: ST_TO_ADDR
// if not tmp then
111934: LD_VAR 0 2
111938: NOT
111939: IFFALSE 111943
// continue ;
111941: GO 111738
// HackLink ( i , tmp ) ;
111943: LD_VAR 0 1
111947: PPUSH
111948: LD_VAR 0 2
111952: PPUSH
111953: CALL 112100 0 2
// end ;
111957: GO 111738
111959: POP
111960: POP
// end ;
111961: PPOPN 2
111963: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
111964: LD_INT 0
111966: PPUSH
111967: PPUSH
111968: PPUSH
// if not hack in hackTanks then
111969: LD_VAR 0 1
111973: PUSH
111974: LD_EXP 159
111978: IN
111979: NOT
111980: IFFALSE 111984
// exit ;
111982: GO 112095
// index := GetElementIndex ( hackTanks , hack ) ;
111984: LD_ADDR_VAR 0 4
111988: PUSH
111989: LD_EXP 159
111993: PPUSH
111994: LD_VAR 0 1
111998: PPUSH
111999: CALL 54680 0 2
112003: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
112004: LD_EXP 160
112008: PUSH
112009: LD_VAR 0 4
112013: ARRAY
112014: IFFALSE 112095
// begin for i in hackTanksCaptured [ index ] do
112016: LD_ADDR_VAR 0 3
112020: PUSH
112021: LD_EXP 160
112025: PUSH
112026: LD_VAR 0 4
112030: ARRAY
112031: PUSH
112032: FOR_IN
112033: IFFALSE 112059
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
112035: LD_VAR 0 3
112039: PUSH
112040: LD_INT 1
112042: ARRAY
112043: PPUSH
112044: LD_VAR 0 3
112048: PUSH
112049: LD_INT 2
112051: ARRAY
112052: PPUSH
112053: CALL_OW 235
112057: GO 112032
112059: POP
112060: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
112061: LD_ADDR_EXP 160
112065: PUSH
112066: LD_EXP 160
112070: PPUSH
112071: LD_VAR 0 4
112075: PPUSH
112076: EMPTY
112077: PPUSH
112078: CALL_OW 1
112082: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
112083: LD_VAR 0 1
112087: PPUSH
112088: LD_INT 0
112090: PPUSH
112091: CALL_OW 505
// end ; end ;
112095: LD_VAR 0 2
112099: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
112100: LD_INT 0
112102: PPUSH
112103: PPUSH
112104: PPUSH
// if not hack in hackTanks or not vehicles then
112105: LD_VAR 0 1
112109: PUSH
112110: LD_EXP 159
112114: IN
112115: NOT
112116: IFTRUE 112125
112118: PUSH
112119: LD_VAR 0 2
112123: NOT
112124: OR
112125: IFFALSE 112129
// exit ;
112127: GO 112404
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
112129: LD_ADDR_VAR 0 2
112133: PUSH
112134: LD_VAR 0 1
112138: PPUSH
112139: LD_VAR 0 2
112143: PPUSH
112144: LD_INT 1
112146: PPUSH
112147: LD_INT 1
112149: PPUSH
112150: CALL 55332 0 4
112154: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
112155: LD_ADDR_VAR 0 5
112159: PUSH
112160: LD_EXP 159
112164: PPUSH
112165: LD_VAR 0 1
112169: PPUSH
112170: CALL 54680 0 2
112174: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
112175: LD_EXP 160
112179: PUSH
112180: LD_VAR 0 5
112184: ARRAY
112185: PUSH
112186: LD_EXP 161
112190: LESS
112191: IFFALSE 112380
// begin for i := 1 to vehicles do
112193: LD_ADDR_VAR 0 4
112197: PUSH
112198: DOUBLE
112199: LD_INT 1
112201: DEC
112202: ST_TO_ADDR
112203: LD_VAR 0 2
112207: PUSH
112208: FOR_TO
112209: IFFALSE 112378
// begin if hackTanksCaptured [ index ] = hackLimit then
112211: LD_EXP 160
112215: PUSH
112216: LD_VAR 0 5
112220: ARRAY
112221: PUSH
112222: LD_EXP 161
112226: EQUAL
112227: IFFALSE 112231
// break ;
112229: GO 112378
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
112231: LD_ADDR_EXP 163
112235: PUSH
112236: LD_EXP 163
112240: PPUSH
112241: LD_VAR 0 5
112245: PPUSH
112246: LD_EXP 163
112250: PUSH
112251: LD_VAR 0 5
112255: ARRAY
112256: PUSH
112257: LD_INT 1
112259: PLUS
112260: PPUSH
112261: CALL_OW 1
112265: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
112266: LD_ADDR_EXP 160
112270: PUSH
112271: LD_EXP 160
112275: PPUSH
112276: LD_VAR 0 5
112280: PUSH
112281: LD_EXP 160
112285: PUSH
112286: LD_VAR 0 5
112290: ARRAY
112291: PUSH
112292: LD_INT 1
112294: PLUS
112295: PUSH
112296: EMPTY
112297: LIST
112298: LIST
112299: PPUSH
112300: LD_VAR 0 2
112304: PUSH
112305: LD_VAR 0 4
112309: ARRAY
112310: PUSH
112311: LD_VAR 0 2
112315: PUSH
112316: LD_VAR 0 4
112320: ARRAY
112321: PPUSH
112322: CALL_OW 255
112326: PUSH
112327: EMPTY
112328: LIST
112329: LIST
112330: PPUSH
112331: CALL 54897 0 3
112335: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
112336: LD_VAR 0 2
112340: PUSH
112341: LD_VAR 0 4
112345: ARRAY
112346: PPUSH
112347: LD_VAR 0 1
112351: PPUSH
112352: CALL_OW 255
112356: PPUSH
112357: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
112361: LD_VAR 0 2
112365: PUSH
112366: LD_VAR 0 4
112370: ARRAY
112371: PPUSH
112372: CALL_OW 141
// end ;
112376: GO 112208
112378: POP
112379: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
112380: LD_VAR 0 1
112384: PPUSH
112385: LD_EXP 160
112389: PUSH
112390: LD_VAR 0 5
112394: ARRAY
112395: PUSH
112396: LD_INT 0
112398: PLUS
112399: PPUSH
112400: CALL_OW 505
// end ;
112404: LD_VAR 0 3
112408: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
112409: LD_INT 0
112411: PPUSH
112412: PPUSH
112413: PPUSH
112414: PPUSH
// if not hack in hackTanks then
112415: LD_VAR 0 1
112419: PUSH
112420: LD_EXP 159
112424: IN
112425: NOT
112426: IFFALSE 112430
// exit ;
112428: GO 112674
// index := GetElementIndex ( hackTanks , hack ) ;
112430: LD_ADDR_VAR 0 4
112434: PUSH
112435: LD_EXP 159
112439: PPUSH
112440: LD_VAR 0 1
112444: PPUSH
112445: CALL 54680 0 2
112449: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
112450: LD_ADDR_VAR 0 3
112454: PUSH
112455: DOUBLE
112456: LD_EXP 160
112460: PUSH
112461: LD_VAR 0 4
112465: ARRAY
112466: INC
112467: ST_TO_ADDR
112468: LD_INT 1
112470: PUSH
112471: FOR_DOWNTO
112472: IFFALSE 112648
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
112474: LD_ADDR_VAR 0 5
112478: PUSH
112479: LD_EXP 160
112483: PUSH
112484: LD_VAR 0 4
112488: ARRAY
112489: PUSH
112490: LD_VAR 0 3
112494: ARRAY
112495: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
112496: LD_VAR 0 5
112500: PUSH
112501: LD_INT 1
112503: ARRAY
112504: PPUSH
112505: CALL_OW 302
112509: NOT
112510: IFTRUE 112538
112512: PUSH
112513: LD_VAR 0 5
112517: PUSH
112518: LD_INT 1
112520: ARRAY
112521: PPUSH
112522: CALL_OW 255
112526: PUSH
112527: LD_VAR 0 1
112531: PPUSH
112532: CALL_OW 255
112536: NONEQUAL
112537: OR
112538: IFFALSE 112646
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
112540: LD_VAR 0 5
112544: PUSH
112545: LD_INT 1
112547: ARRAY
112548: PPUSH
112549: CALL_OW 305
112553: IFFALSE 112581
112555: PUSH
112556: LD_VAR 0 5
112560: PUSH
112561: LD_INT 1
112563: ARRAY
112564: PPUSH
112565: CALL_OW 255
112569: PUSH
112570: LD_VAR 0 1
112574: PPUSH
112575: CALL_OW 255
112579: EQUAL
112580: AND
112581: IFFALSE 112605
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
112583: LD_VAR 0 5
112587: PUSH
112588: LD_INT 1
112590: ARRAY
112591: PPUSH
112592: LD_VAR 0 5
112596: PUSH
112597: LD_INT 2
112599: ARRAY
112600: PPUSH
112601: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
112605: LD_ADDR_EXP 160
112609: PUSH
112610: LD_EXP 160
112614: PPUSH
112615: LD_VAR 0 4
112619: PPUSH
112620: LD_EXP 160
112624: PUSH
112625: LD_VAR 0 4
112629: ARRAY
112630: PPUSH
112631: LD_VAR 0 3
112635: PPUSH
112636: CALL_OW 3
112640: PPUSH
112641: CALL_OW 1
112645: ST_TO_ADDR
// end ; end ;
112646: GO 112471
112648: POP
112649: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
112650: LD_VAR 0 1
112654: PPUSH
112655: LD_EXP 160
112659: PUSH
112660: LD_VAR 0 4
112664: ARRAY
112665: PUSH
112666: LD_INT 0
112668: PLUS
112669: PPUSH
112670: CALL_OW 505
// end ;
112674: LD_VAR 0 2
112678: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
112679: LD_INT 0
112681: PPUSH
112682: PPUSH
112683: PPUSH
112684: PPUSH
// if not hack in hackTanks then
112685: LD_VAR 0 1
112689: PUSH
112690: LD_EXP 159
112694: IN
112695: NOT
112696: IFFALSE 112700
// exit ;
112698: GO 112785
// index := GetElementIndex ( hackTanks , hack ) ;
112700: LD_ADDR_VAR 0 5
112704: PUSH
112705: LD_EXP 159
112709: PPUSH
112710: LD_VAR 0 1
112714: PPUSH
112715: CALL 54680 0 2
112719: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
112720: LD_ADDR_VAR 0 4
112724: PUSH
112725: DOUBLE
112726: LD_INT 1
112728: DEC
112729: ST_TO_ADDR
112730: LD_EXP 160
112734: PUSH
112735: LD_VAR 0 5
112739: ARRAY
112740: PUSH
112741: FOR_TO
112742: IFFALSE 112783
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
112744: LD_EXP 160
112748: PUSH
112749: LD_VAR 0 5
112753: ARRAY
112754: PUSH
112755: LD_VAR 0 4
112759: ARRAY
112760: PUSH
112761: LD_INT 1
112763: ARRAY
112764: PUSH
112765: LD_VAR 0 2
112769: EQUAL
112770: IFFALSE 112781
// KillUnit ( vehicle ) ;
112772: LD_VAR 0 2
112776: PPUSH
112777: CALL_OW 66
112781: GO 112741
112783: POP
112784: POP
// end ;
112785: LD_VAR 0 3
112789: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do var i ;
112790: LD_EXP 164
112794: NOT
112795: IFFALSE 112928
112797: GO 112799
112799: DISABLE
112800: LD_INT 0
112802: PPUSH
// begin initMiner := true ;
112803: LD_ADDR_EXP 164
112807: PUSH
112808: LD_INT 1
112810: ST_TO_ADDR
// minersList := [ ] ;
112811: LD_ADDR_EXP 165
112815: PUSH
112816: EMPTY
112817: ST_TO_ADDR
// minerMinesList := [ ] ;
112818: LD_ADDR_EXP 166
112822: PUSH
112823: EMPTY
112824: ST_TO_ADDR
// minesLimitPerVehicle := 6 ;
112825: LD_ADDR_EXP 167
112829: PUSH
112830: LD_INT 6
112832: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
112833: LD_ADDR_VAR 0 1
112837: PUSH
112838: LD_INT 34
112840: PUSH
112841: LD_INT 81
112843: PUSH
112844: EMPTY
112845: LIST
112846: LIST
112847: PPUSH
112848: CALL_OW 69
112852: PUSH
112853: FOR_IN
112854: IFFALSE 112926
// begin if not i in minersList then
112856: LD_VAR 0 1
112860: PUSH
112861: LD_EXP 165
112865: IN
112866: NOT
112867: IFFALSE 112924
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
112869: LD_ADDR_EXP 165
112873: PUSH
112874: LD_EXP 165
112878: PPUSH
112879: LD_EXP 165
112883: PUSH
112884: LD_INT 1
112886: PLUS
112887: PPUSH
112888: LD_VAR 0 1
112892: PPUSH
112893: CALL_OW 1
112897: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
112898: LD_ADDR_EXP 166
112902: PUSH
112903: LD_EXP 166
112907: PPUSH
112908: LD_EXP 166
112912: PUSH
112913: LD_INT 1
112915: PLUS
112916: PPUSH
112917: EMPTY
112918: PPUSH
112919: CALL_OW 1
112923: ST_TO_ADDR
// end end ;
112924: GO 112853
112926: POP
112927: POP
// end ;
112928: PPOPN 1
112930: END
// every 0 0$1 trigger initMiner and ( Count ( minerMinesList ) or FilterAllUnits ( [ f_weapon , ar_miner ] ) ) do var i , j , side , tmp ;
112931: LD_EXP 164
112935: IFFALSE 112966
112937: PUSH
112938: LD_EXP 166
112942: PPUSH
112943: CALL 51979 0 1
112947: IFTRUE 112965
112949: PUSH
112950: LD_INT 34
112952: PUSH
112953: LD_INT 81
112955: PUSH
112956: EMPTY
112957: LIST
112958: LIST
112959: PPUSH
112960: CALL_OW 69
112964: OR
112965: AND
112966: IFFALSE 113465
112968: GO 112970
112970: DISABLE
112971: LD_INT 0
112973: PPUSH
112974: PPUSH
112975: PPUSH
112976: PPUSH
// begin enable ;
112977: ENABLE
// for i := minerMinesList downto 1 do
112978: LD_ADDR_VAR 0 1
112982: PUSH
112983: DOUBLE
112984: LD_EXP 166
112988: INC
112989: ST_TO_ADDR
112990: LD_INT 1
112992: PUSH
112993: FOR_DOWNTO
112994: IFFALSE 113463
// begin if IsLive ( minersList [ i ] ) then
112996: LD_EXP 165
113000: PUSH
113001: LD_VAR 0 1
113005: ARRAY
113006: PPUSH
113007: CALL_OW 300
113011: IFFALSE 113044
// SetUnitDisplayNumber ( minersList [ i ] , Count ( minerMinesList [ i ] ) ) ;
113013: LD_EXP 165
113017: PUSH
113018: LD_VAR 0 1
113022: ARRAY
113023: PPUSH
113024: LD_EXP 166
113028: PUSH
113029: LD_VAR 0 1
113033: ARRAY
113034: PPUSH
113035: CALL 51979 0 1
113039: PPUSH
113040: CALL_OW 505
// if not minerMinesList [ i ] then
113044: LD_EXP 166
113048: PUSH
113049: LD_VAR 0 1
113053: ARRAY
113054: NOT
113055: IFFALSE 113059
// continue ;
113057: GO 112993
// for j := minerMinesList [ i ] downto 1 do
113059: LD_ADDR_VAR 0 2
113063: PUSH
113064: DOUBLE
113065: LD_EXP 166
113069: PUSH
113070: LD_VAR 0 1
113074: ARRAY
113075: INC
113076: ST_TO_ADDR
113077: LD_INT 1
113079: PUSH
113080: FOR_DOWNTO
113081: IFFALSE 113459
// begin side := GetSide ( minersList [ i ] ) ;
113083: LD_ADDR_VAR 0 3
113087: PUSH
113088: LD_EXP 165
113092: PUSH
113093: LD_VAR 0 1
113097: ARRAY
113098: PPUSH
113099: CALL_OW 255
113103: ST_TO_ADDR
// if IsDead ( minersList [ i ] ) or not IsPlaced ( minersList [ i ] ) then
113104: LD_EXP 165
113108: PUSH
113109: LD_VAR 0 1
113113: ARRAY
113114: PPUSH
113115: CALL_OW 301
113119: IFTRUE 113139
113121: PUSH
113122: LD_EXP 165
113126: PUSH
113127: LD_VAR 0 1
113131: ARRAY
113132: PPUSH
113133: CALL_OW 305
113137: NOT
113138: OR
113139: IFFALSE 113230
// begin RemoveMineXY ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
113141: LD_EXP 166
113145: PUSH
113146: LD_VAR 0 1
113150: ARRAY
113151: PUSH
113152: LD_VAR 0 2
113156: ARRAY
113157: PUSH
113158: LD_INT 1
113160: ARRAY
113161: PPUSH
113162: LD_EXP 166
113166: PUSH
113167: LD_VAR 0 1
113171: ARRAY
113172: PUSH
113173: LD_VAR 0 2
113177: ARRAY
113178: PUSH
113179: LD_INT 2
113181: ARRAY
113182: PPUSH
113183: CALL_OW 612
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
113187: LD_ADDR_EXP 166
113191: PUSH
113192: LD_EXP 166
113196: PPUSH
113197: LD_VAR 0 1
113201: PPUSH
113202: LD_EXP 166
113206: PUSH
113207: LD_VAR 0 1
113211: ARRAY
113212: PPUSH
113213: LD_VAR 0 2
113217: PPUSH
113218: CALL_OW 3
113222: PPUSH
113223: CALL_OW 1
113227: ST_TO_ADDR
// continue ;
113228: GO 113080
// end ; tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
113230: LD_ADDR_VAR 0 4
113234: PUSH
113235: LD_EXP 166
113239: PUSH
113240: LD_VAR 0 1
113244: ARRAY
113245: PUSH
113246: LD_VAR 0 2
113250: ARRAY
113251: PUSH
113252: LD_INT 1
113254: ARRAY
113255: PPUSH
113256: LD_EXP 166
113260: PUSH
113261: LD_VAR 0 1
113265: ARRAY
113266: PUSH
113267: LD_VAR 0 2
113271: ARRAY
113272: PUSH
113273: LD_INT 2
113275: ARRAY
113276: PPUSH
113277: CALL_OW 428
113281: ST_TO_ADDR
// if not tmp then
113282: LD_VAR 0 4
113286: NOT
113287: IFFALSE 113291
// continue ;
113289: GO 113080
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
113291: LD_VAR 0 4
113295: PUSH
113296: LD_INT 81
113298: PUSH
113299: LD_VAR 0 3
113303: PUSH
113304: EMPTY
113305: LIST
113306: LIST
113307: PPUSH
113308: CALL_OW 69
113312: IN
113313: IFFALSE 113363
113315: PUSH
113316: LD_EXP 166
113320: PUSH
113321: LD_VAR 0 1
113325: ARRAY
113326: PUSH
113327: LD_VAR 0 2
113331: ARRAY
113332: PUSH
113333: LD_INT 1
113335: ARRAY
113336: PPUSH
113337: LD_EXP 166
113341: PUSH
113342: LD_VAR 0 1
113346: ARRAY
113347: PUSH
113348: LD_VAR 0 2
113352: ARRAY
113353: PUSH
113354: LD_INT 2
113356: ARRAY
113357: PPUSH
113358: CALL_OW 458
113362: AND
113363: IFFALSE 113457
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
113365: LD_EXP 166
113369: PUSH
113370: LD_VAR 0 1
113374: ARRAY
113375: PUSH
113376: LD_VAR 0 2
113380: ARRAY
113381: PUSH
113382: LD_INT 1
113384: ARRAY
113385: PPUSH
113386: LD_EXP 166
113390: PUSH
113391: LD_VAR 0 1
113395: ARRAY
113396: PUSH
113397: LD_VAR 0 2
113401: ARRAY
113402: PUSH
113403: LD_INT 2
113405: ARRAY
113406: PPUSH
113407: LD_VAR 0 3
113411: PPUSH
113412: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
113416: LD_ADDR_EXP 166
113420: PUSH
113421: LD_EXP 166
113425: PPUSH
113426: LD_VAR 0 1
113430: PPUSH
113431: LD_EXP 166
113435: PUSH
113436: LD_VAR 0 1
113440: ARRAY
113441: PPUSH
113442: LD_VAR 0 2
113446: PPUSH
113447: CALL_OW 3
113451: PPUSH
113452: CALL_OW 1
113456: ST_TO_ADDR
// end ; end ;
113457: GO 113080
113459: POP
113460: POP
// end ;
113461: GO 112993
113463: POP
113464: POP
// end ;
113465: PPOPN 4
113467: END
// export function MinerPlaceMine ( unit , x , y ) ; var index , side , i ; begin
113468: LD_INT 0
113470: PPUSH
113471: PPUSH
113472: PPUSH
113473: PPUSH
// result := false ;
113474: LD_ADDR_VAR 0 4
113478: PUSH
113479: LD_INT 0
113481: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
113482: LD_VAR 0 1
113486: PPUSH
113487: CALL_OW 264
113491: PUSH
113492: LD_INT 81
113494: EQUAL
113495: NOT
113496: IFFALSE 113500
// exit ;
113498: GO 113870
// side := GetSide ( unit ) ;
113500: LD_ADDR_VAR 0 6
113504: PUSH
113505: LD_VAR 0 1
113509: PPUSH
113510: CALL_OW 255
113514: ST_TO_ADDR
// index := GetElementIndex ( minersList , unit ) ;
113515: LD_ADDR_VAR 0 5
113519: PUSH
113520: LD_EXP 165
113524: PPUSH
113525: LD_VAR 0 1
113529: PPUSH
113530: CALL 54680 0 2
113534: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
113535: LD_EXP 166
113539: PUSH
113540: LD_VAR 0 5
113544: ARRAY
113545: PUSH
113546: LD_EXP 167
113550: GREATEREQUAL
113551: IFFALSE 113555
// exit ;
113553: GO 113870
// ComMoveXY ( unit , x , y ) ;
113555: LD_VAR 0 1
113559: PPUSH
113560: LD_VAR 0 2
113564: PPUSH
113565: LD_VAR 0 3
113569: PPUSH
113570: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113574: LD_INT 35
113576: PPUSH
113577: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
113581: LD_VAR 0 1
113585: PPUSH
113586: LD_VAR 0 2
113590: PPUSH
113591: LD_VAR 0 3
113595: PPUSH
113596: CALL 86736 0 3
113600: NOT
113601: IFFALSE 113614
113603: PUSH
113604: LD_VAR 0 1
113608: PPUSH
113609: CALL_OW 314
113613: AND
113614: IFFALSE 113618
// exit ;
113616: GO 113870
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
113618: LD_VAR 0 2
113622: PPUSH
113623: LD_VAR 0 3
113627: PPUSH
113628: CALL_OW 428
113632: PUSH
113633: LD_VAR 0 1
113637: EQUAL
113638: IFFALSE 113652
113640: PUSH
113641: LD_VAR 0 1
113645: PPUSH
113646: CALL_OW 314
113650: NOT
113651: AND
113652: IFFALSE 113574
// if MineAtPos ( x , y ) then
113654: LD_VAR 0 2
113658: PPUSH
113659: LD_VAR 0 3
113663: PPUSH
113664: CALL_OW 458
113668: IFFALSE 113672
// exit ;
113670: GO 113870
// if your_side = side then
113672: LD_OWVAR 2
113676: PUSH
113677: LD_VAR 0 6
113681: EQUAL
113682: IFFALSE 113701
// PlaySoundXY ( x , y , PlantMine ) ;
113684: LD_VAR 0 2
113688: PPUSH
113689: LD_VAR 0 3
113693: PPUSH
113694: LD_STRING PlantMine
113696: PPUSH
113697: CALL_OW 366
// repeat wait ( 1 ) ;
113701: LD_INT 1
113703: PPUSH
113704: CALL_OW 67
// until PlaceMine ( x , y , side , 0 ) ;
113708: LD_VAR 0 2
113712: PPUSH
113713: LD_VAR 0 3
113717: PPUSH
113718: LD_VAR 0 6
113722: PPUSH
113723: LD_INT 0
113725: PPUSH
113726: CALL_OW 454
113730: IFFALSE 113701
// if MineAtPos ( x , y ) then
113732: LD_VAR 0 2
113736: PPUSH
113737: LD_VAR 0 3
113741: PPUSH
113742: CALL_OW 458
113746: IFFALSE 113862
// begin for i in minerMinesList [ index ] do
113748: LD_ADDR_VAR 0 7
113752: PUSH
113753: LD_EXP 166
113757: PUSH
113758: LD_VAR 0 5
113762: ARRAY
113763: PUSH
113764: FOR_IN
113765: IFFALSE 113807
// if i [ 1 ] = x and i [ 2 ] = y then
113767: LD_VAR 0 7
113771: PUSH
113772: LD_INT 1
113774: ARRAY
113775: PUSH
113776: LD_VAR 0 2
113780: EQUAL
113781: IFFALSE 113799
113783: PUSH
113784: LD_VAR 0 7
113788: PUSH
113789: LD_INT 2
113791: ARRAY
113792: PUSH
113793: LD_VAR 0 3
113797: EQUAL
113798: AND
113799: IFFALSE 113805
// exit ;
113801: POP
113802: POP
113803: GO 113870
113805: GO 113764
113807: POP
113808: POP
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
113809: LD_ADDR_EXP 166
113813: PUSH
113814: LD_EXP 166
113818: PPUSH
113819: LD_VAR 0 5
113823: PUSH
113824: LD_EXP 166
113828: PUSH
113829: LD_VAR 0 5
113833: ARRAY
113834: PUSH
113835: LD_INT 1
113837: PLUS
113838: PUSH
113839: EMPTY
113840: LIST
113841: LIST
113842: PPUSH
113843: LD_VAR 0 2
113847: PUSH
113848: LD_VAR 0 3
113852: PUSH
113853: EMPTY
113854: LIST
113855: LIST
113856: PPUSH
113857: CALL 54897 0 3
113861: ST_TO_ADDR
// end ; result := true ;
113862: LD_ADDR_VAR 0 4
113866: PUSH
113867: LD_INT 1
113869: ST_TO_ADDR
// end ;
113870: LD_VAR 0 4
113874: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
113875: LD_INT 0
113877: PPUSH
113878: PPUSH
113879: PPUSH
// if not unit in minersList then
113880: LD_VAR 0 1
113884: PUSH
113885: LD_EXP 165
113889: IN
113890: NOT
113891: IFFALSE 113895
// exit ;
113893: GO 114102
// index := GetElementIndex ( minersList , unit ) ;
113895: LD_ADDR_VAR 0 6
113899: PUSH
113900: LD_EXP 165
113904: PPUSH
113905: LD_VAR 0 1
113909: PPUSH
113910: CALL 54680 0 2
113914: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
113915: LD_ADDR_VAR 0 5
113919: PUSH
113920: DOUBLE
113921: LD_EXP 166
113925: PUSH
113926: LD_VAR 0 6
113930: ARRAY
113931: INC
113932: ST_TO_ADDR
113933: LD_INT 1
113935: PUSH
113936: FOR_DOWNTO
113937: IFFALSE 114100
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
113939: LD_EXP 166
113943: PUSH
113944: LD_VAR 0 6
113948: ARRAY
113949: PUSH
113950: LD_VAR 0 5
113954: ARRAY
113955: PUSH
113956: LD_INT 1
113958: ARRAY
113959: PPUSH
113960: LD_EXP 166
113964: PUSH
113965: LD_VAR 0 6
113969: ARRAY
113970: PUSH
113971: LD_VAR 0 5
113975: ARRAY
113976: PUSH
113977: LD_INT 2
113979: ARRAY
113980: PPUSH
113981: LD_VAR 0 2
113985: PPUSH
113986: LD_VAR 0 3
113990: PPUSH
113991: CALL_OW 298
113995: PUSH
113996: LD_INT 6
113998: LESS
113999: IFFALSE 114098
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
114001: LD_EXP 166
114005: PUSH
114006: LD_VAR 0 6
114010: ARRAY
114011: PUSH
114012: LD_VAR 0 5
114016: ARRAY
114017: PUSH
114018: LD_INT 1
114020: ARRAY
114021: PPUSH
114022: LD_EXP 166
114026: PUSH
114027: LD_VAR 0 6
114031: ARRAY
114032: PUSH
114033: LD_VAR 0 5
114037: ARRAY
114038: PUSH
114039: LD_INT 2
114041: ARRAY
114042: PPUSH
114043: LD_VAR 0 1
114047: PPUSH
114048: CALL_OW 255
114052: PPUSH
114053: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
114057: LD_ADDR_EXP 166
114061: PUSH
114062: LD_EXP 166
114066: PPUSH
114067: LD_VAR 0 6
114071: PPUSH
114072: LD_EXP 166
114076: PUSH
114077: LD_VAR 0 6
114081: ARRAY
114082: PPUSH
114083: LD_VAR 0 5
114087: PPUSH
114088: CALL_OW 3
114092: PPUSH
114093: CALL_OW 1
114097: ST_TO_ADDR
// end ; end ;
114098: GO 113936
114100: POP
114101: POP
// end ;
114102: LD_VAR 0 4
114106: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
114107: LD_INT 0
114109: PPUSH
114110: PPUSH
114111: PPUSH
114112: PPUSH
114113: PPUSH
114114: PPUSH
114115: PPUSH
114116: PPUSH
114117: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
114118: LD_VAR 0 1
114122: PPUSH
114123: CALL_OW 264
114127: PUSH
114128: LD_INT 81
114130: EQUAL
114131: NOT
114132: IFTRUE 114147
114134: PUSH
114135: LD_VAR 0 1
114139: PUSH
114140: LD_EXP 165
114144: IN
114145: NOT
114146: OR
114147: IFFALSE 114151
// exit ;
114149: GO 114477
// index := GetElementIndex ( minersList , unit ) ;
114151: LD_ADDR_VAR 0 6
114155: PUSH
114156: LD_EXP 165
114160: PPUSH
114161: LD_VAR 0 1
114165: PPUSH
114166: CALL 54680 0 2
114170: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
114171: LD_ADDR_VAR 0 8
114175: PUSH
114176: LD_EXP 167
114180: PUSH
114181: LD_EXP 166
114185: PUSH
114186: LD_VAR 0 6
114190: ARRAY
114191: MINUS
114192: ST_TO_ADDR
// if not minesFreeAmount then
114193: LD_VAR 0 8
114197: NOT
114198: IFFALSE 114202
// exit ;
114200: GO 114477
// tmp := [ ] ;
114202: LD_ADDR_VAR 0 7
114206: PUSH
114207: EMPTY
114208: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
114209: LD_ADDR_VAR 0 5
114213: PUSH
114214: DOUBLE
114215: LD_INT 1
114217: DEC
114218: ST_TO_ADDR
114219: LD_VAR 0 8
114223: PUSH
114224: FOR_TO
114225: IFFALSE 114424
// begin _d := rand ( 0 , 5 ) ;
114227: LD_ADDR_VAR 0 11
114231: PUSH
114232: LD_INT 0
114234: PPUSH
114235: LD_INT 5
114237: PPUSH
114238: CALL_OW 12
114242: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
114243: LD_ADDR_VAR 0 12
114247: PUSH
114248: LD_INT 2
114250: PPUSH
114251: LD_INT 6
114253: PPUSH
114254: CALL_OW 12
114258: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
114259: LD_ADDR_VAR 0 9
114263: PUSH
114264: LD_VAR 0 2
114268: PPUSH
114269: LD_VAR 0 11
114273: PPUSH
114274: LD_VAR 0 12
114278: PPUSH
114279: CALL_OW 272
114283: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
114284: LD_ADDR_VAR 0 10
114288: PUSH
114289: LD_VAR 0 3
114293: PPUSH
114294: LD_VAR 0 11
114298: PPUSH
114299: LD_VAR 0 12
114303: PPUSH
114304: CALL_OW 273
114308: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
114309: LD_VAR 0 9
114313: PPUSH
114314: LD_VAR 0 10
114318: PPUSH
114319: CALL_OW 488
114323: IFFALSE 114347
114325: PUSH
114326: LD_VAR 0 9
114330: PUSH
114331: LD_VAR 0 10
114335: PUSH
114336: EMPTY
114337: LIST
114338: LIST
114339: PUSH
114340: LD_VAR 0 7
114344: IN
114345: NOT
114346: AND
114347: IFFALSE 114366
114349: PUSH
114350: LD_VAR 0 9
114354: PPUSH
114355: LD_VAR 0 10
114359: PPUSH
114360: CALL_OW 458
114364: NOT
114365: AND
114366: IFFALSE 114408
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
114368: LD_ADDR_VAR 0 7
114372: PUSH
114373: LD_VAR 0 7
114377: PPUSH
114378: LD_VAR 0 7
114382: PUSH
114383: LD_INT 1
114385: PLUS
114386: PPUSH
114387: LD_VAR 0 9
114391: PUSH
114392: LD_VAR 0 10
114396: PUSH
114397: EMPTY
114398: LIST
114399: LIST
114400: PPUSH
114401: CALL_OW 1
114405: ST_TO_ADDR
114406: GO 114422
// i := i - 1 ;
114408: LD_ADDR_VAR 0 5
114412: PUSH
114413: LD_VAR 0 5
114417: PUSH
114418: LD_INT 1
114420: MINUS
114421: ST_TO_ADDR
// end ;
114422: GO 114224
114424: POP
114425: POP
// for i in tmp do
114426: LD_ADDR_VAR 0 5
114430: PUSH
114431: LD_VAR 0 7
114435: PUSH
114436: FOR_IN
114437: IFFALSE 114475
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
114439: LD_VAR 0 1
114443: PPUSH
114444: LD_VAR 0 5
114448: PUSH
114449: LD_INT 1
114451: ARRAY
114452: PPUSH
114453: LD_VAR 0 5
114457: PUSH
114458: LD_INT 2
114460: ARRAY
114461: PPUSH
114462: CALL 113468 0 3
114466: NOT
114467: IFFALSE 114473
// exit ;
114469: POP
114470: POP
114471: GO 114477
114473: GO 114436
114475: POP
114476: POP
// end ;
114477: LD_VAR 0 4
114481: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
114482: LD_INT 0
114484: PPUSH
114485: PPUSH
114486: PPUSH
114487: PPUSH
114488: PPUSH
114489: PPUSH
114490: PPUSH
114491: PPUSH
114492: PPUSH
// if GetClass ( unit ) <> class_sniper then
114493: LD_VAR 0 1
114497: PPUSH
114498: CALL_OW 257
114502: PUSH
114503: LD_INT 5
114505: NONEQUAL
114506: IFFALSE 114510
// exit ;
114508: GO 114980
// dist := 8 ;
114510: LD_ADDR_VAR 0 5
114514: PUSH
114515: LD_INT 8
114517: ST_TO_ADDR
// viewRange := 12 ;
114518: LD_ADDR_VAR 0 8
114522: PUSH
114523: LD_INT 12
114525: ST_TO_ADDR
// side := GetSide ( unit ) ;
114526: LD_ADDR_VAR 0 6
114530: PUSH
114531: LD_VAR 0 1
114535: PPUSH
114536: CALL_OW 255
114540: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
114541: LD_INT 61
114543: PPUSH
114544: LD_VAR 0 6
114548: PPUSH
114549: CALL_OW 321
114553: PUSH
114554: LD_INT 2
114556: EQUAL
114557: IFFALSE 114567
// viewRange := 16 ;
114559: LD_ADDR_VAR 0 8
114563: PUSH
114564: LD_INT 16
114566: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
114567: LD_VAR 0 1
114571: PPUSH
114572: LD_VAR 0 2
114576: PPUSH
114577: LD_VAR 0 3
114581: PPUSH
114582: CALL_OW 297
114586: PUSH
114587: LD_VAR 0 5
114591: GREATER
114592: IFFALSE 114671
// begin ComMoveXY ( unit , x , y ) ;
114594: LD_VAR 0 1
114598: PPUSH
114599: LD_VAR 0 2
114603: PPUSH
114604: LD_VAR 0 3
114608: PPUSH
114609: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
114613: LD_INT 35
114615: PPUSH
114616: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
114620: LD_VAR 0 1
114624: PPUSH
114625: LD_VAR 0 2
114629: PPUSH
114630: LD_VAR 0 3
114634: PPUSH
114635: CALL 86736 0 3
114639: NOT
114640: IFFALSE 114644
// exit ;
114642: GO 114980
// until GetDistUnitXY ( unit , x , y ) < dist ;
114644: LD_VAR 0 1
114648: PPUSH
114649: LD_VAR 0 2
114653: PPUSH
114654: LD_VAR 0 3
114658: PPUSH
114659: CALL_OW 297
114663: PUSH
114664: LD_VAR 0 5
114668: LESS
114669: IFFALSE 114613
// end ; ComTurnXY ( unit , x , y ) ;
114671: LD_VAR 0 1
114675: PPUSH
114676: LD_VAR 0 2
114680: PPUSH
114681: LD_VAR 0 3
114685: PPUSH
114686: CALL_OW 118
// repeat if Multiplayer then
114690: LD_OWVAR 4
114694: IFFALSE 114705
// wait ( 35 ) else
114696: LD_INT 35
114698: PPUSH
114699: CALL_OW 67
114703: GO 114712
// wait ( 5 ) ;
114705: LD_INT 5
114707: PPUSH
114708: CALL_OW 67
// _d := GetDir ( unit ) ;
114712: LD_ADDR_VAR 0 11
114716: PUSH
114717: LD_VAR 0 1
114721: PPUSH
114722: CALL_OW 254
114726: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
114727: LD_ADDR_VAR 0 7
114731: PUSH
114732: LD_VAR 0 1
114736: PPUSH
114737: CALL_OW 250
114741: PPUSH
114742: LD_VAR 0 1
114746: PPUSH
114747: CALL_OW 251
114751: PPUSH
114752: LD_VAR 0 2
114756: PPUSH
114757: LD_VAR 0 3
114761: PPUSH
114762: CALL 89372 0 4
114766: ST_TO_ADDR
// until dir = _d ;
114767: LD_VAR 0 7
114771: PUSH
114772: LD_VAR 0 11
114776: EQUAL
114777: IFFALSE 114690
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
114779: LD_ADDR_VAR 0 9
114783: PUSH
114784: LD_VAR 0 1
114788: PPUSH
114789: CALL_OW 250
114793: PPUSH
114794: LD_VAR 0 7
114798: PPUSH
114799: LD_VAR 0 5
114803: PPUSH
114804: CALL_OW 272
114808: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
114809: LD_ADDR_VAR 0 10
114813: PUSH
114814: LD_VAR 0 1
114818: PPUSH
114819: CALL_OW 251
114823: PPUSH
114824: LD_VAR 0 7
114828: PPUSH
114829: LD_VAR 0 5
114833: PPUSH
114834: CALL_OW 273
114838: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
114839: LD_VAR 0 9
114843: PPUSH
114844: LD_VAR 0 10
114848: PPUSH
114849: CALL_OW 488
114853: NOT
114854: IFFALSE 114858
// exit ;
114856: GO 114980
// ComAnimCustom ( unit , 1 ) ;
114858: LD_VAR 0 1
114862: PPUSH
114863: LD_INT 1
114865: PPUSH
114866: CALL_OW 592
// p := 0 ;
114870: LD_ADDR_VAR 0 12
114874: PUSH
114875: LD_INT 0
114877: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
114878: LD_VAR 0 9
114882: PPUSH
114883: LD_VAR 0 10
114887: PPUSH
114888: LD_VAR 0 6
114892: PPUSH
114893: LD_VAR 0 8
114897: PPUSH
114898: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
114902: LD_INT 35
114904: PPUSH
114905: CALL_OW 67
// p := Inc ( p ) ;
114909: LD_ADDR_VAR 0 12
114913: PUSH
114914: LD_VAR 0 12
114918: PPUSH
114919: CALL 89328 0 1
114923: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
114924: LD_VAR 0 12
114928: PUSH
114929: LD_INT 3
114931: EQUAL
114932: IFTRUE 114946
114934: PUSH
114935: LD_VAR 0 1
114939: PPUSH
114940: CALL_OW 302
114944: NOT
114945: OR
114946: IFTRUE 114959
114948: PUSH
114949: LD_VAR 0 1
114953: PPUSH
114954: CALL_OW 301
114958: OR
114959: IFFALSE 114902
// RemoveSeeing ( _x , _y , side ) ;
114961: LD_VAR 0 9
114965: PPUSH
114966: LD_VAR 0 10
114970: PPUSH
114971: LD_VAR 0 6
114975: PPUSH
114976: CALL_OW 331
// end ;
114980: LD_VAR 0 4
114984: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
114985: LD_INT 0
114987: PPUSH
114988: PPUSH
114989: PPUSH
114990: PPUSH
114991: PPUSH
114992: PPUSH
114993: PPUSH
114994: PPUSH
114995: PPUSH
114996: PPUSH
114997: PPUSH
// if not unit then
114998: LD_VAR 0 1
115002: NOT
115003: IFFALSE 115007
// exit ;
115005: GO 115278
// side := GetSide ( unit ) ;
115007: LD_ADDR_VAR 0 3
115011: PUSH
115012: LD_VAR 0 1
115016: PPUSH
115017: CALL_OW 255
115021: ST_TO_ADDR
// x := GetX ( unit ) ;
115022: LD_ADDR_VAR 0 5
115026: PUSH
115027: LD_VAR 0 1
115031: PPUSH
115032: CALL_OW 250
115036: ST_TO_ADDR
// y := GetY ( unit ) ;
115037: LD_ADDR_VAR 0 6
115041: PUSH
115042: LD_VAR 0 1
115046: PPUSH
115047: CALL_OW 251
115051: ST_TO_ADDR
// r := 8 ;
115052: LD_ADDR_VAR 0 4
115056: PUSH
115057: LD_INT 8
115059: ST_TO_ADDR
// if x - r < 0 then
115060: LD_VAR 0 5
115064: PUSH
115065: LD_VAR 0 4
115069: MINUS
115070: PUSH
115071: LD_INT 0
115073: LESS
115074: IFFALSE 115086
// min_x := 0 else
115076: LD_ADDR_VAR 0 7
115080: PUSH
115081: LD_INT 0
115083: ST_TO_ADDR
115084: GO 115102
// min_x := x - r ;
115086: LD_ADDR_VAR 0 7
115090: PUSH
115091: LD_VAR 0 5
115095: PUSH
115096: LD_VAR 0 4
115100: MINUS
115101: ST_TO_ADDR
// if y - r < 0 then
115102: LD_VAR 0 6
115106: PUSH
115107: LD_VAR 0 4
115111: MINUS
115112: PUSH
115113: LD_INT 0
115115: LESS
115116: IFFALSE 115128
// min_y := 0 else
115118: LD_ADDR_VAR 0 8
115122: PUSH
115123: LD_INT 0
115125: ST_TO_ADDR
115126: GO 115144
// min_y := y - r ;
115128: LD_ADDR_VAR 0 8
115132: PUSH
115133: LD_VAR 0 6
115137: PUSH
115138: LD_VAR 0 4
115142: MINUS
115143: ST_TO_ADDR
// max_x := x + r ;
115144: LD_ADDR_VAR 0 9
115148: PUSH
115149: LD_VAR 0 5
115153: PUSH
115154: LD_VAR 0 4
115158: PLUS
115159: ST_TO_ADDR
// max_y := y + r ;
115160: LD_ADDR_VAR 0 10
115164: PUSH
115165: LD_VAR 0 6
115169: PUSH
115170: LD_VAR 0 4
115174: PLUS
115175: ST_TO_ADDR
// for _x = min_x to max_x do
115176: LD_ADDR_VAR 0 11
115180: PUSH
115181: DOUBLE
115182: LD_VAR 0 7
115186: DEC
115187: ST_TO_ADDR
115188: LD_VAR 0 9
115192: PUSH
115193: FOR_TO
115194: IFFALSE 115276
// for _y = min_y to max_y do
115196: LD_ADDR_VAR 0 12
115200: PUSH
115201: DOUBLE
115202: LD_VAR 0 8
115206: DEC
115207: ST_TO_ADDR
115208: LD_VAR 0 10
115212: PUSH
115213: FOR_TO
115214: IFFALSE 115272
// begin if not ValidHex ( _x , _y ) then
115216: LD_VAR 0 11
115220: PPUSH
115221: LD_VAR 0 12
115225: PPUSH
115226: CALL_OW 488
115230: NOT
115231: IFFALSE 115235
// continue ;
115233: GO 115213
// if MineAtPos ( _x , _y ) then
115235: LD_VAR 0 11
115239: PPUSH
115240: LD_VAR 0 12
115244: PPUSH
115245: CALL_OW 458
115249: IFFALSE 115270
// ViewMineAtPos ( _x , _y , side ) ;
115251: LD_VAR 0 11
115255: PPUSH
115256: LD_VAR 0 12
115260: PPUSH
115261: LD_VAR 0 3
115265: PPUSH
115266: CALL_OW 457
// end ;
115270: GO 115213
115272: POP
115273: POP
115274: GO 115193
115276: POP
115277: POP
// end ;
115278: LD_VAR 0 2
115282: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer ; begin
115283: LD_INT 0
115285: PPUSH
115286: PPUSH
115287: PPUSH
115288: PPUSH
115289: PPUSH
115290: PPUSH
// if not units then
115291: LD_VAR 0 1
115295: NOT
115296: IFFALSE 115300
// exit ;
115298: GO 115730
// scaners := [ ] ;
115300: LD_ADDR_VAR 0 6
115304: PUSH
115305: EMPTY
115306: ST_TO_ADDR
// for i in units do
115307: LD_ADDR_VAR 0 3
115311: PUSH
115312: LD_VAR 0 1
115316: PUSH
115317: FOR_IN
115318: IFFALSE 115475
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
115320: LD_VAR 0 3
115324: PPUSH
115325: CALL_OW 264
115329: PUSH
115330: LD_INT 11
115332: NONEQUAL
115333: IFTRUE 115347
115335: PUSH
115336: LD_VAR 0 3
115340: PPUSH
115341: CALL_OW 302
115345: NOT
115346: OR
115347: IFTRUE 115364
115349: PUSH
115350: LD_VAR 0 3
115354: PPUSH
115355: CALL_OW 110
115359: PUSH
115360: LD_INT 502
115362: EQUAL
115363: OR
115364: IFFALSE 115368
// continue ;
115366: GO 115317
// ComStop ( i ) ;
115368: LD_VAR 0 3
115372: PPUSH
115373: CALL_OW 141
// x := GetX ( i ) ;
115377: LD_ADDR_VAR 0 4
115381: PUSH
115382: LD_VAR 0 3
115386: PPUSH
115387: CALL_OW 250
115391: ST_TO_ADDR
// y := GetY ( i ) ;
115392: LD_ADDR_VAR 0 5
115396: PUSH
115397: LD_VAR 0 3
115401: PPUSH
115402: CALL_OW 251
115406: ST_TO_ADDR
// if GetSide ( i ) = your_side then
115407: LD_VAR 0 3
115411: PPUSH
115412: CALL_OW 255
115416: PUSH
115417: LD_OWVAR 2
115421: EQUAL
115422: IFFALSE 115441
// PlaySoundXY ( x , y , mineDetector ) ;
115424: LD_VAR 0 4
115428: PPUSH
115429: LD_VAR 0 5
115433: PPUSH
115434: LD_STRING mineDetector
115436: PPUSH
115437: CALL_OW 366
// scaners := Join ( scaners , i ) ;
115441: LD_ADDR_VAR 0 6
115445: PUSH
115446: LD_VAR 0 6
115450: PPUSH
115451: LD_VAR 0 3
115455: PPUSH
115456: CALL 87955 0 2
115460: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
115461: LD_VAR 0 3
115465: PPUSH
115466: LD_INT 502
115468: PPUSH
115469: CALL_OW 109
// end ;
115473: GO 115317
115475: POP
115476: POP
// if not scaners then
115477: LD_VAR 0 6
115481: NOT
115482: IFFALSE 115486
// exit ;
115484: GO 115730
// wait ( 3 ) ;
115486: LD_INT 3
115488: PPUSH
115489: CALL_OW 67
// timer := 6 ;
115493: LD_ADDR_VAR 0 7
115497: PUSH
115498: LD_INT 6
115500: ST_TO_ADDR
// repeat for i in scaners do
115501: LD_ADDR_VAR 0 3
115505: PUSH
115506: LD_VAR 0 6
115510: PUSH
115511: FOR_IN
115512: IFFALSE 115628
// begin if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
115514: LD_VAR 0 3
115518: PPUSH
115519: CALL_OW 302
115523: NOT
115524: IFTRUE 115537
115526: PUSH
115527: LD_VAR 0 3
115531: PPUSH
115532: CALL_OW 314
115536: OR
115537: IFTRUE 115568
115539: PUSH
115540: LD_VAR 0 3
115544: PPUSH
115545: CALL_OW 263
115549: PUSH
115550: LD_INT 1
115552: EQUAL
115553: IFFALSE 115567
115555: PUSH
115556: LD_VAR 0 3
115560: PPUSH
115561: CALL_OW 311
115565: NOT
115566: AND
115567: OR
115568: IFFALSE 115612
// begin SetUnitDisplayNumber ( i , 0 ) ;
115570: LD_VAR 0 3
115574: PPUSH
115575: LD_INT 0
115577: PPUSH
115578: CALL_OW 505
// SetTag ( i , 0 ) ;
115582: LD_VAR 0 3
115586: PPUSH
115587: LD_INT 0
115589: PPUSH
115590: CALL_OW 109
// scaners := scaners diff i ;
115594: LD_ADDR_VAR 0 6
115598: PUSH
115599: LD_VAR 0 6
115603: PUSH
115604: LD_VAR 0 3
115608: DIFF
115609: ST_TO_ADDR
// continue ;
115610: GO 115511
// end ; SetUnitDisplayNumber ( i , timer ) ;
115612: LD_VAR 0 3
115616: PPUSH
115617: LD_VAR 0 7
115621: PPUSH
115622: CALL_OW 505
// end ;
115626: GO 115511
115628: POP
115629: POP
// if not scaners then
115630: LD_VAR 0 6
115634: NOT
115635: IFFALSE 115639
// exit ;
115637: GO 115730
// timer := Dec ( timer ) ;
115639: LD_ADDR_VAR 0 7
115643: PUSH
115644: LD_VAR 0 7
115648: PPUSH
115649: CALL 89350 0 1
115653: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115654: LD_INT 35
115656: PPUSH
115657: CALL_OW 67
// until timer = 0 ;
115661: LD_VAR 0 7
115665: PUSH
115666: LD_INT 0
115668: EQUAL
115669: IFFALSE 115501
// if not scaners then
115671: LD_VAR 0 6
115675: NOT
115676: IFFALSE 115680
// exit ;
115678: GO 115730
// for i in scaners do
115680: LD_ADDR_VAR 0 3
115684: PUSH
115685: LD_VAR 0 6
115689: PUSH
115690: FOR_IN
115691: IFFALSE 115728
// begin SetUnitDisplayNumber ( i , 0 ) ;
115693: LD_VAR 0 3
115697: PPUSH
115698: LD_INT 0
115700: PPUSH
115701: CALL_OW 505
// SetTag ( i , 0 ) ;
115705: LD_VAR 0 3
115709: PPUSH
115710: LD_INT 0
115712: PPUSH
115713: CALL_OW 109
// RevealDetectorMine ( i ) ;
115717: LD_VAR 0 3
115721: PPUSH
115722: CALL 114985 0 1
// end ;
115726: GO 115690
115728: POP
115729: POP
// end ;
115730: LD_VAR 0 2
115734: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
115735: LD_INT 0
115737: PPUSH
// if p1 = mine_detector_mode then
115738: LD_VAR 0 2
115742: PUSH
115743: LD_INT 103
115745: EQUAL
115746: IFFALSE 115757
// DetectMine ( units ) ;
115748: LD_VAR 0 1
115752: PPUSH
115753: CALL 115283 0 1
// end ; end_of_file
115757: LD_VAR 0 7
115761: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
115762: LD_INT 0
115764: PPUSH
115765: PPUSH
115766: PPUSH
115767: PPUSH
115768: PPUSH
115769: PPUSH
115770: PPUSH
115771: PPUSH
115772: PPUSH
115773: PPUSH
115774: PPUSH
115775: PPUSH
115776: PPUSH
115777: PPUSH
115778: PPUSH
115779: PPUSH
115780: PPUSH
115781: PPUSH
115782: PPUSH
115783: PPUSH
115784: PPUSH
115785: PPUSH
115786: PPUSH
115787: PPUSH
115788: PPUSH
115789: PPUSH
115790: PPUSH
115791: PPUSH
115792: PPUSH
115793: PPUSH
115794: PPUSH
115795: PPUSH
115796: PPUSH
115797: PPUSH
// if not list then
115798: LD_VAR 0 1
115802: NOT
115803: IFFALSE 115807
// exit ;
115805: GO 120526
// base := list [ 1 ] ;
115807: LD_ADDR_VAR 0 3
115811: PUSH
115812: LD_VAR 0 1
115816: PUSH
115817: LD_INT 1
115819: ARRAY
115820: ST_TO_ADDR
// group := list [ 2 ] ;
115821: LD_ADDR_VAR 0 4
115825: PUSH
115826: LD_VAR 0 1
115830: PUSH
115831: LD_INT 2
115833: ARRAY
115834: ST_TO_ADDR
// path := list [ 3 ] ;
115835: LD_ADDR_VAR 0 5
115839: PUSH
115840: LD_VAR 0 1
115844: PUSH
115845: LD_INT 3
115847: ARRAY
115848: ST_TO_ADDR
// flags := list [ 4 ] ;
115849: LD_ADDR_VAR 0 6
115853: PUSH
115854: LD_VAR 0 1
115858: PUSH
115859: LD_INT 4
115861: ARRAY
115862: ST_TO_ADDR
// mined := [ ] ;
115863: LD_ADDR_VAR 0 27
115867: PUSH
115868: EMPTY
115869: ST_TO_ADDR
// bombed := [ ] ;
115870: LD_ADDR_VAR 0 28
115874: PUSH
115875: EMPTY
115876: ST_TO_ADDR
// healers := [ ] ;
115877: LD_ADDR_VAR 0 31
115881: PUSH
115882: EMPTY
115883: ST_TO_ADDR
// to_heal := [ ] ;
115884: LD_ADDR_VAR 0 30
115888: PUSH
115889: EMPTY
115890: ST_TO_ADDR
// repairs := [ ] ;
115891: LD_ADDR_VAR 0 33
115895: PUSH
115896: EMPTY
115897: ST_TO_ADDR
// to_repair := [ ] ;
115898: LD_ADDR_VAR 0 32
115902: PUSH
115903: EMPTY
115904: ST_TO_ADDR
// if not group or not path then
115905: LD_VAR 0 4
115909: NOT
115910: IFTRUE 115919
115912: PUSH
115913: LD_VAR 0 5
115917: NOT
115918: OR
115919: IFFALSE 115923
// exit ;
115921: GO 120526
// side := GetSide ( group [ 1 ] ) ;
115923: LD_ADDR_VAR 0 35
115927: PUSH
115928: LD_VAR 0 4
115932: PUSH
115933: LD_INT 1
115935: ARRAY
115936: PPUSH
115937: CALL_OW 255
115941: ST_TO_ADDR
// if flags then
115942: LD_VAR 0 6
115946: IFFALSE 116090
// begin f_ignore_area := flags [ 1 ] ;
115948: LD_ADDR_VAR 0 17
115952: PUSH
115953: LD_VAR 0 6
115957: PUSH
115958: LD_INT 1
115960: ARRAY
115961: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
115962: LD_ADDR_VAR 0 18
115966: PUSH
115967: LD_VAR 0 6
115971: PUSH
115972: LD_INT 2
115974: ARRAY
115975: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
115976: LD_ADDR_VAR 0 19
115980: PUSH
115981: LD_VAR 0 6
115985: PUSH
115986: LD_INT 3
115988: ARRAY
115989: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
115990: LD_ADDR_VAR 0 20
115994: PUSH
115995: LD_VAR 0 6
115999: PUSH
116000: LD_INT 4
116002: ARRAY
116003: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
116004: LD_ADDR_VAR 0 21
116008: PUSH
116009: LD_VAR 0 6
116013: PUSH
116014: LD_INT 5
116016: ARRAY
116017: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
116018: LD_ADDR_VAR 0 22
116022: PUSH
116023: LD_VAR 0 6
116027: PUSH
116028: LD_INT 6
116030: ARRAY
116031: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
116032: LD_ADDR_VAR 0 23
116036: PUSH
116037: LD_VAR 0 6
116041: PUSH
116042: LD_INT 7
116044: ARRAY
116045: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
116046: LD_ADDR_VAR 0 24
116050: PUSH
116051: LD_VAR 0 6
116055: PUSH
116056: LD_INT 8
116058: ARRAY
116059: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
116060: LD_ADDR_VAR 0 25
116064: PUSH
116065: LD_VAR 0 6
116069: PUSH
116070: LD_INT 9
116072: ARRAY
116073: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
116074: LD_ADDR_VAR 0 26
116078: PUSH
116079: LD_VAR 0 6
116083: PUSH
116084: LD_INT 10
116086: ARRAY
116087: ST_TO_ADDR
// end else
116088: GO 116170
// begin f_ignore_area := false ;
116090: LD_ADDR_VAR 0 17
116094: PUSH
116095: LD_INT 0
116097: ST_TO_ADDR
// f_capture := false ;
116098: LD_ADDR_VAR 0 18
116102: PUSH
116103: LD_INT 0
116105: ST_TO_ADDR
// f_ignore_civ := false ;
116106: LD_ADDR_VAR 0 19
116110: PUSH
116111: LD_INT 0
116113: ST_TO_ADDR
// f_murder := false ;
116114: LD_ADDR_VAR 0 20
116118: PUSH
116119: LD_INT 0
116121: ST_TO_ADDR
// f_mines := false ;
116122: LD_ADDR_VAR 0 21
116126: PUSH
116127: LD_INT 0
116129: ST_TO_ADDR
// f_repair := false ;
116130: LD_ADDR_VAR 0 22
116134: PUSH
116135: LD_INT 0
116137: ST_TO_ADDR
// f_heal := false ;
116138: LD_ADDR_VAR 0 23
116142: PUSH
116143: LD_INT 0
116145: ST_TO_ADDR
// f_spacetime := false ;
116146: LD_ADDR_VAR 0 24
116150: PUSH
116151: LD_INT 0
116153: ST_TO_ADDR
// f_attack_depot := false ;
116154: LD_ADDR_VAR 0 25
116158: PUSH
116159: LD_INT 0
116161: ST_TO_ADDR
// f_crawl := false ;
116162: LD_ADDR_VAR 0 26
116166: PUSH
116167: LD_INT 0
116169: ST_TO_ADDR
// end ; if f_heal then
116170: LD_VAR 0 23
116174: IFFALSE 116201
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
116176: LD_ADDR_VAR 0 31
116180: PUSH
116181: LD_VAR 0 4
116185: PPUSH
116186: LD_INT 25
116188: PUSH
116189: LD_INT 4
116191: PUSH
116192: EMPTY
116193: LIST
116194: LIST
116195: PPUSH
116196: CALL_OW 72
116200: ST_TO_ADDR
// if f_repair then
116201: LD_VAR 0 22
116205: IFFALSE 116232
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
116207: LD_ADDR_VAR 0 33
116211: PUSH
116212: LD_VAR 0 4
116216: PPUSH
116217: LD_INT 25
116219: PUSH
116220: LD_INT 3
116222: PUSH
116223: EMPTY
116224: LIST
116225: LIST
116226: PPUSH
116227: CALL_OW 72
116231: ST_TO_ADDR
// units_path := [ ] ;
116232: LD_ADDR_VAR 0 16
116236: PUSH
116237: EMPTY
116238: ST_TO_ADDR
// for i = 1 to group do
116239: LD_ADDR_VAR 0 7
116243: PUSH
116244: DOUBLE
116245: LD_INT 1
116247: DEC
116248: ST_TO_ADDR
116249: LD_VAR 0 4
116253: PUSH
116254: FOR_TO
116255: IFFALSE 116284
// units_path := Replace ( units_path , i , path ) ;
116257: LD_ADDR_VAR 0 16
116261: PUSH
116262: LD_VAR 0 16
116266: PPUSH
116267: LD_VAR 0 7
116271: PPUSH
116272: LD_VAR 0 5
116276: PPUSH
116277: CALL_OW 1
116281: ST_TO_ADDR
116282: GO 116254
116284: POP
116285: POP
// repeat for i = group downto 1 do
116286: LD_ADDR_VAR 0 7
116290: PUSH
116291: DOUBLE
116292: LD_VAR 0 4
116296: INC
116297: ST_TO_ADDR
116298: LD_INT 1
116300: PUSH
116301: FOR_DOWNTO
116302: IFFALSE 120478
// begin wait ( 5 ) ;
116304: LD_INT 5
116306: PPUSH
116307: CALL_OW 67
// tmp := [ ] ;
116311: LD_ADDR_VAR 0 14
116315: PUSH
116316: EMPTY
116317: ST_TO_ADDR
// attacking := false ;
116318: LD_ADDR_VAR 0 29
116322: PUSH
116323: LD_INT 0
116325: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
116326: LD_VAR 0 4
116330: PUSH
116331: LD_VAR 0 7
116335: ARRAY
116336: PPUSH
116337: CALL_OW 301
116341: IFTRUE 116356
116343: PUSH
116344: LD_VAR 0 4
116348: PUSH
116349: LD_VAR 0 7
116353: ARRAY
116354: NOT
116355: OR
116356: IFFALSE 116465
// begin if GetType ( group [ i ] ) = unit_human then
116358: LD_VAR 0 4
116362: PUSH
116363: LD_VAR 0 7
116367: ARRAY
116368: PPUSH
116369: CALL_OW 247
116373: PUSH
116374: LD_INT 1
116376: EQUAL
116377: IFFALSE 116423
// begin to_heal := to_heal diff group [ i ] ;
116379: LD_ADDR_VAR 0 30
116383: PUSH
116384: LD_VAR 0 30
116388: PUSH
116389: LD_VAR 0 4
116393: PUSH
116394: LD_VAR 0 7
116398: ARRAY
116399: DIFF
116400: ST_TO_ADDR
// healers := healers diff group [ i ] ;
116401: LD_ADDR_VAR 0 31
116405: PUSH
116406: LD_VAR 0 31
116410: PUSH
116411: LD_VAR 0 4
116415: PUSH
116416: LD_VAR 0 7
116420: ARRAY
116421: DIFF
116422: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
116423: LD_ADDR_VAR 0 4
116427: PUSH
116428: LD_VAR 0 4
116432: PPUSH
116433: LD_VAR 0 7
116437: PPUSH
116438: CALL_OW 3
116442: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
116443: LD_ADDR_VAR 0 16
116447: PUSH
116448: LD_VAR 0 16
116452: PPUSH
116453: LD_VAR 0 7
116457: PPUSH
116458: CALL_OW 3
116462: ST_TO_ADDR
// continue ;
116463: GO 116301
// end ; if f_repair then
116465: LD_VAR 0 22
116469: IFFALSE 116966
// begin if GetType ( group [ i ] ) = unit_vehicle then
116471: LD_VAR 0 4
116475: PUSH
116476: LD_VAR 0 7
116480: ARRAY
116481: PPUSH
116482: CALL_OW 247
116486: PUSH
116487: LD_INT 2
116489: EQUAL
116490: IFFALSE 116684
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
116492: LD_VAR 0 4
116496: PUSH
116497: LD_VAR 0 7
116501: ARRAY
116502: PPUSH
116503: CALL_OW 256
116507: PUSH
116508: LD_INT 700
116510: LESS
116511: IFFALSE 116532
116513: PUSH
116514: LD_VAR 0 4
116518: PUSH
116519: LD_VAR 0 7
116523: ARRAY
116524: PUSH
116525: LD_VAR 0 32
116529: IN
116530: NOT
116531: AND
116532: IFFALSE 116556
// to_repair := to_repair union group [ i ] ;
116534: LD_ADDR_VAR 0 32
116538: PUSH
116539: LD_VAR 0 32
116543: PUSH
116544: LD_VAR 0 4
116548: PUSH
116549: LD_VAR 0 7
116553: ARRAY
116554: UNION
116555: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
116556: LD_VAR 0 4
116560: PUSH
116561: LD_VAR 0 7
116565: ARRAY
116566: PPUSH
116567: CALL_OW 256
116571: PUSH
116572: LD_INT 1000
116574: EQUAL
116575: IFFALSE 116595
116577: PUSH
116578: LD_VAR 0 4
116582: PUSH
116583: LD_VAR 0 7
116587: ARRAY
116588: PUSH
116589: LD_VAR 0 32
116593: IN
116594: AND
116595: IFFALSE 116619
// to_repair := to_repair diff group [ i ] ;
116597: LD_ADDR_VAR 0 32
116601: PUSH
116602: LD_VAR 0 32
116606: PUSH
116607: LD_VAR 0 4
116611: PUSH
116612: LD_VAR 0 7
116616: ARRAY
116617: DIFF
116618: ST_TO_ADDR
// if group [ i ] in to_repair then
116619: LD_VAR 0 4
116623: PUSH
116624: LD_VAR 0 7
116628: ARRAY
116629: PUSH
116630: LD_VAR 0 32
116634: IN
116635: IFFALSE 116682
// begin if not IsInArea ( group [ i ] , f_repair ) then
116637: LD_VAR 0 4
116641: PUSH
116642: LD_VAR 0 7
116646: ARRAY
116647: PPUSH
116648: LD_VAR 0 22
116652: PPUSH
116653: CALL_OW 308
116657: NOT
116658: IFFALSE 116680
// ComMoveToArea ( group [ i ] , f_repair ) ;
116660: LD_VAR 0 4
116664: PUSH
116665: LD_VAR 0 7
116669: ARRAY
116670: PPUSH
116671: LD_VAR 0 22
116675: PPUSH
116676: CALL_OW 113
// continue ;
116680: GO 116301
// end ; end else
116682: GO 116966
// if group [ i ] in repairs then
116684: LD_VAR 0 4
116688: PUSH
116689: LD_VAR 0 7
116693: ARRAY
116694: PUSH
116695: LD_VAR 0 33
116699: IN
116700: IFFALSE 116966
// begin if IsInUnit ( group [ i ] ) then
116702: LD_VAR 0 4
116706: PUSH
116707: LD_VAR 0 7
116711: ARRAY
116712: PPUSH
116713: CALL_OW 310
116717: IFFALSE 116787
// begin z := IsInUnit ( group [ i ] ) ;
116719: LD_ADDR_VAR 0 13
116723: PUSH
116724: LD_VAR 0 4
116728: PUSH
116729: LD_VAR 0 7
116733: ARRAY
116734: PPUSH
116735: CALL_OW 310
116739: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
116740: LD_VAR 0 13
116744: PUSH
116745: LD_VAR 0 32
116749: IN
116750: IFFALSE 116768
116752: PUSH
116753: LD_VAR 0 13
116757: PPUSH
116758: LD_VAR 0 22
116762: PPUSH
116763: CALL_OW 308
116767: AND
116768: IFFALSE 116785
// ComExitVehicle ( group [ i ] ) ;
116770: LD_VAR 0 4
116774: PUSH
116775: LD_VAR 0 7
116779: ARRAY
116780: PPUSH
116781: CALL_OW 121
// end else
116785: GO 116966
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
116787: LD_ADDR_VAR 0 13
116791: PUSH
116792: LD_VAR 0 4
116796: PPUSH
116797: LD_INT 95
116799: PUSH
116800: LD_VAR 0 22
116804: PUSH
116805: EMPTY
116806: LIST
116807: LIST
116808: PUSH
116809: LD_INT 58
116811: PUSH
116812: EMPTY
116813: LIST
116814: PUSH
116815: EMPTY
116816: LIST
116817: LIST
116818: PPUSH
116819: CALL_OW 72
116823: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
116824: LD_VAR 0 4
116828: PUSH
116829: LD_VAR 0 7
116833: ARRAY
116834: PPUSH
116835: CALL_OW 314
116839: NOT
116840: IFFALSE 116964
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
116842: LD_ADDR_VAR 0 10
116846: PUSH
116847: LD_VAR 0 13
116851: PPUSH
116852: LD_VAR 0 4
116856: PUSH
116857: LD_VAR 0 7
116861: ARRAY
116862: PPUSH
116863: CALL_OW 74
116867: ST_TO_ADDR
// if not x then
116868: LD_VAR 0 10
116872: NOT
116873: IFFALSE 116877
// continue ;
116875: GO 116301
// if GetLives ( x ) < 1000 then
116877: LD_VAR 0 10
116881: PPUSH
116882: CALL_OW 256
116886: PUSH
116887: LD_INT 1000
116889: LESS
116890: IFFALSE 116914
// ComRepairVehicle ( group [ i ] , x ) else
116892: LD_VAR 0 4
116896: PUSH
116897: LD_VAR 0 7
116901: ARRAY
116902: PPUSH
116903: LD_VAR 0 10
116907: PPUSH
116908: CALL_OW 129
116912: GO 116964
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
116914: LD_VAR 0 23
116918: IFFALSE 116941
116920: PUSH
116921: LD_VAR 0 4
116925: PUSH
116926: LD_VAR 0 7
116930: ARRAY
116931: PPUSH
116932: CALL_OW 256
116936: PUSH
116937: LD_INT 1000
116939: LESS
116940: AND
116941: NOT
116942: IFFALSE 116964
// ComEnterUnit ( group [ i ] , x ) ;
116944: LD_VAR 0 4
116948: PUSH
116949: LD_VAR 0 7
116953: ARRAY
116954: PPUSH
116955: LD_VAR 0 10
116959: PPUSH
116960: CALL_OW 120
// end ; continue ;
116964: GO 116301
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
116966: LD_VAR 0 23
116970: IFFALSE 116993
116972: PUSH
116973: LD_VAR 0 4
116977: PUSH
116978: LD_VAR 0 7
116982: ARRAY
116983: PPUSH
116984: CALL_OW 247
116988: PUSH
116989: LD_INT 1
116991: EQUAL
116992: AND
116993: IFFALSE 117477
// begin if group [ i ] in healers then
116995: LD_VAR 0 4
116999: PUSH
117000: LD_VAR 0 7
117004: ARRAY
117005: PUSH
117006: LD_VAR 0 31
117010: IN
117011: IFFALSE 117288
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
117013: LD_VAR 0 4
117017: PUSH
117018: LD_VAR 0 7
117022: ARRAY
117023: PPUSH
117024: LD_VAR 0 23
117028: PPUSH
117029: CALL_OW 308
117033: NOT
117034: IFFALSE 117054
117036: PUSH
117037: LD_VAR 0 4
117041: PUSH
117042: LD_VAR 0 7
117046: ARRAY
117047: PPUSH
117048: CALL_OW 314
117052: NOT
117053: AND
117054: IFFALSE 117078
// ComMoveToArea ( group [ i ] , f_heal ) else
117056: LD_VAR 0 4
117060: PUSH
117061: LD_VAR 0 7
117065: ARRAY
117066: PPUSH
117067: LD_VAR 0 23
117071: PPUSH
117072: CALL_OW 113
117076: GO 117286
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
117078: LD_VAR 0 4
117082: PUSH
117083: LD_VAR 0 7
117087: ARRAY
117088: PPUSH
117089: CALL 85311 0 1
117093: PPUSH
117094: CALL_OW 256
117098: PUSH
117099: LD_INT 1000
117101: EQUAL
117102: IFFALSE 117121
// ComStop ( group [ i ] ) else
117104: LD_VAR 0 4
117108: PUSH
117109: LD_VAR 0 7
117113: ARRAY
117114: PPUSH
117115: CALL_OW 141
117119: GO 117286
// if not HasTask ( group [ i ] ) and to_heal then
117121: LD_VAR 0 4
117125: PUSH
117126: LD_VAR 0 7
117130: ARRAY
117131: PPUSH
117132: CALL_OW 314
117136: NOT
117137: IFFALSE 117145
117139: PUSH
117140: LD_VAR 0 30
117144: AND
117145: IFFALSE 117286
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
117147: LD_ADDR_VAR 0 13
117151: PUSH
117152: LD_VAR 0 30
117156: PPUSH
117157: LD_INT 3
117159: PUSH
117160: LD_INT 54
117162: PUSH
117163: EMPTY
117164: LIST
117165: PUSH
117166: EMPTY
117167: LIST
117168: LIST
117169: PPUSH
117170: CALL_OW 72
117174: PPUSH
117175: LD_VAR 0 4
117179: PUSH
117180: LD_VAR 0 7
117184: ARRAY
117185: PPUSH
117186: CALL_OW 74
117190: ST_TO_ADDR
// if z then
117191: LD_VAR 0 13
117195: IFFALSE 117286
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
117197: LD_INT 91
117199: PUSH
117200: LD_VAR 0 13
117204: PUSH
117205: LD_INT 10
117207: PUSH
117208: EMPTY
117209: LIST
117210: LIST
117211: LIST
117212: PUSH
117213: LD_INT 81
117215: PUSH
117216: LD_VAR 0 13
117220: PPUSH
117221: CALL_OW 255
117225: PUSH
117226: EMPTY
117227: LIST
117228: LIST
117229: PUSH
117230: EMPTY
117231: LIST
117232: LIST
117233: PPUSH
117234: CALL_OW 69
117238: PUSH
117239: LD_INT 0
117241: EQUAL
117242: IFFALSE 117266
// ComHeal ( group [ i ] , z ) else
117244: LD_VAR 0 4
117248: PUSH
117249: LD_VAR 0 7
117253: ARRAY
117254: PPUSH
117255: LD_VAR 0 13
117259: PPUSH
117260: CALL_OW 128
117264: GO 117286
// ComMoveToArea ( group [ i ] , f_heal ) ;
117266: LD_VAR 0 4
117270: PUSH
117271: LD_VAR 0 7
117275: ARRAY
117276: PPUSH
117277: LD_VAR 0 23
117281: PPUSH
117282: CALL_OW 113
// end ; continue ;
117286: GO 116301
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
117288: LD_VAR 0 4
117292: PUSH
117293: LD_VAR 0 7
117297: ARRAY
117298: PPUSH
117299: CALL_OW 256
117303: PUSH
117304: LD_INT 700
117306: LESS
117307: IFFALSE 117328
117309: PUSH
117310: LD_VAR 0 4
117314: PUSH
117315: LD_VAR 0 7
117319: ARRAY
117320: PUSH
117321: LD_VAR 0 30
117325: IN
117326: NOT
117327: AND
117328: IFFALSE 117352
// to_heal := to_heal union group [ i ] ;
117330: LD_ADDR_VAR 0 30
117334: PUSH
117335: LD_VAR 0 30
117339: PUSH
117340: LD_VAR 0 4
117344: PUSH
117345: LD_VAR 0 7
117349: ARRAY
117350: UNION
117351: ST_TO_ADDR
// if group [ i ] in to_heal then
117352: LD_VAR 0 4
117356: PUSH
117357: LD_VAR 0 7
117361: ARRAY
117362: PUSH
117363: LD_VAR 0 30
117367: IN
117368: IFFALSE 117477
// begin if GetLives ( group [ i ] ) = 1000 then
117370: LD_VAR 0 4
117374: PUSH
117375: LD_VAR 0 7
117379: ARRAY
117380: PPUSH
117381: CALL_OW 256
117385: PUSH
117386: LD_INT 1000
117388: EQUAL
117389: IFFALSE 117415
// to_heal := to_heal diff group [ i ] else
117391: LD_ADDR_VAR 0 30
117395: PUSH
117396: LD_VAR 0 30
117400: PUSH
117401: LD_VAR 0 4
117405: PUSH
117406: LD_VAR 0 7
117410: ARRAY
117411: DIFF
117412: ST_TO_ADDR
117413: GO 117477
// begin if not IsInArea ( group [ i ] , to_heal ) then
117415: LD_VAR 0 4
117419: PUSH
117420: LD_VAR 0 7
117424: ARRAY
117425: PPUSH
117426: LD_VAR 0 30
117430: PPUSH
117431: CALL_OW 308
117435: NOT
117436: IFFALSE 117460
// ComMoveToArea ( group [ i ] , f_heal ) else
117438: LD_VAR 0 4
117442: PUSH
117443: LD_VAR 0 7
117447: ARRAY
117448: PPUSH
117449: LD_VAR 0 23
117453: PPUSH
117454: CALL_OW 113
117458: GO 117475
// ComHold ( group [ i ] ) ;
117460: LD_VAR 0 4
117464: PUSH
117465: LD_VAR 0 7
117469: ARRAY
117470: PPUSH
117471: CALL_OW 140
// continue ;
117475: GO 116301
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
117477: LD_VAR 0 4
117481: PUSH
117482: LD_VAR 0 7
117486: ARRAY
117487: PPUSH
117488: LD_INT 10
117490: PPUSH
117491: CALL 82910 0 2
117495: NOT
117496: IFFALSE 117514
117498: PUSH
117499: LD_VAR 0 16
117503: PUSH
117504: LD_VAR 0 7
117508: ARRAY
117509: PUSH
117510: EMPTY
117511: EQUAL
117512: NOT
117513: AND
117514: IFFALSE 117780
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
117516: LD_VAR 0 4
117520: PUSH
117521: LD_VAR 0 7
117525: ARRAY
117526: PPUSH
117527: CALL_OW 262
117531: PUSH
117532: LD_INT 1
117534: PUSH
117535: LD_INT 2
117537: PUSH
117538: EMPTY
117539: LIST
117540: LIST
117541: IN
117542: IFFALSE 117583
// if GetFuel ( group [ i ] ) < 10 then
117544: LD_VAR 0 4
117548: PUSH
117549: LD_VAR 0 7
117553: ARRAY
117554: PPUSH
117555: CALL_OW 261
117559: PUSH
117560: LD_INT 10
117562: LESS
117563: IFFALSE 117583
// SetFuel ( group [ i ] , 12 ) ;
117565: LD_VAR 0 4
117569: PUSH
117570: LD_VAR 0 7
117574: ARRAY
117575: PPUSH
117576: LD_INT 12
117578: PPUSH
117579: CALL_OW 240
// if units_path [ i ] then
117583: LD_VAR 0 16
117587: PUSH
117588: LD_VAR 0 7
117592: ARRAY
117593: IFFALSE 117778
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
117595: LD_VAR 0 4
117599: PUSH
117600: LD_VAR 0 7
117604: ARRAY
117605: PPUSH
117606: LD_VAR 0 16
117610: PUSH
117611: LD_VAR 0 7
117615: ARRAY
117616: PUSH
117617: LD_INT 1
117619: ARRAY
117620: PUSH
117621: LD_INT 1
117623: ARRAY
117624: PPUSH
117625: LD_VAR 0 16
117629: PUSH
117630: LD_VAR 0 7
117634: ARRAY
117635: PUSH
117636: LD_INT 1
117638: ARRAY
117639: PUSH
117640: LD_INT 2
117642: ARRAY
117643: PPUSH
117644: CALL_OW 297
117648: PUSH
117649: LD_INT 6
117651: GREATER
117652: IFFALSE 117727
// begin if not HasTask ( group [ i ] ) then
117654: LD_VAR 0 4
117658: PUSH
117659: LD_VAR 0 7
117663: ARRAY
117664: PPUSH
117665: CALL_OW 314
117669: NOT
117670: IFFALSE 117725
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
117672: LD_VAR 0 4
117676: PUSH
117677: LD_VAR 0 7
117681: ARRAY
117682: PPUSH
117683: LD_VAR 0 16
117687: PUSH
117688: LD_VAR 0 7
117692: ARRAY
117693: PUSH
117694: LD_INT 1
117696: ARRAY
117697: PUSH
117698: LD_INT 1
117700: ARRAY
117701: PPUSH
117702: LD_VAR 0 16
117706: PUSH
117707: LD_VAR 0 7
117711: ARRAY
117712: PUSH
117713: LD_INT 1
117715: ARRAY
117716: PUSH
117717: LD_INT 2
117719: ARRAY
117720: PPUSH
117721: CALL_OW 114
// end else
117725: GO 117778
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
117727: LD_ADDR_VAR 0 15
117731: PUSH
117732: LD_VAR 0 16
117736: PUSH
117737: LD_VAR 0 7
117741: ARRAY
117742: PPUSH
117743: LD_INT 1
117745: PPUSH
117746: CALL_OW 3
117750: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
117751: LD_ADDR_VAR 0 16
117755: PUSH
117756: LD_VAR 0 16
117760: PPUSH
117761: LD_VAR 0 7
117765: PPUSH
117766: LD_VAR 0 15
117770: PPUSH
117771: CALL_OW 1
117775: ST_TO_ADDR
// continue ;
117776: GO 116301
// end ; end ; end else
117778: GO 120476
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
117780: LD_ADDR_VAR 0 14
117784: PUSH
117785: LD_INT 81
117787: PUSH
117788: LD_VAR 0 4
117792: PUSH
117793: LD_VAR 0 7
117797: ARRAY
117798: PPUSH
117799: CALL_OW 255
117803: PUSH
117804: EMPTY
117805: LIST
117806: LIST
117807: PPUSH
117808: CALL_OW 69
117812: ST_TO_ADDR
// if not tmp then
117813: LD_VAR 0 14
117817: NOT
117818: IFFALSE 117822
// continue ;
117820: GO 116301
// if f_ignore_area then
117822: LD_VAR 0 17
117826: IFFALSE 117914
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
117828: LD_ADDR_VAR 0 15
117832: PUSH
117833: LD_VAR 0 14
117837: PPUSH
117838: LD_INT 3
117840: PUSH
117841: LD_INT 92
117843: PUSH
117844: LD_VAR 0 17
117848: PUSH
117849: LD_INT 1
117851: ARRAY
117852: PUSH
117853: LD_VAR 0 17
117857: PUSH
117858: LD_INT 2
117860: ARRAY
117861: PUSH
117862: LD_VAR 0 17
117866: PUSH
117867: LD_INT 3
117869: ARRAY
117870: PUSH
117871: EMPTY
117872: LIST
117873: LIST
117874: LIST
117875: LIST
117876: PUSH
117877: EMPTY
117878: LIST
117879: LIST
117880: PPUSH
117881: CALL_OW 72
117885: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
117886: LD_VAR 0 14
117890: PUSH
117891: LD_VAR 0 15
117895: DIFF
117896: IFFALSE 117914
// tmp := tmp diff tmp2 ;
117898: LD_ADDR_VAR 0 14
117902: PUSH
117903: LD_VAR 0 14
117907: PUSH
117908: LD_VAR 0 15
117912: DIFF
117913: ST_TO_ADDR
// end ; if not f_murder then
117914: LD_VAR 0 20
117918: NOT
117919: IFFALSE 117977
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
117921: LD_ADDR_VAR 0 15
117925: PUSH
117926: LD_VAR 0 14
117930: PPUSH
117931: LD_INT 3
117933: PUSH
117934: LD_INT 50
117936: PUSH
117937: EMPTY
117938: LIST
117939: PUSH
117940: EMPTY
117941: LIST
117942: LIST
117943: PPUSH
117944: CALL_OW 72
117948: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
117949: LD_VAR 0 14
117953: PUSH
117954: LD_VAR 0 15
117958: DIFF
117959: IFFALSE 117977
// tmp := tmp diff tmp2 ;
117961: LD_ADDR_VAR 0 14
117965: PUSH
117966: LD_VAR 0 14
117970: PUSH
117971: LD_VAR 0 15
117975: DIFF
117976: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
117977: LD_ADDR_VAR 0 14
117981: PUSH
117982: LD_VAR 0 4
117986: PUSH
117987: LD_VAR 0 7
117991: ARRAY
117992: PPUSH
117993: LD_VAR 0 14
117997: PPUSH
117998: LD_INT 1
118000: PPUSH
118001: LD_INT 1
118003: PPUSH
118004: CALL 55332 0 4
118008: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
118009: LD_VAR 0 4
118013: PUSH
118014: LD_VAR 0 7
118018: ARRAY
118019: PPUSH
118020: CALL_OW 257
118024: PUSH
118025: LD_INT 1
118027: EQUAL
118028: IFFALSE 118488
// begin if WantPlant ( group [ i ] ) then
118030: LD_VAR 0 4
118034: PUSH
118035: LD_VAR 0 7
118039: ARRAY
118040: PPUSH
118041: CALL 54833 0 1
118045: IFFALSE 118049
// continue ;
118047: GO 116301
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
118049: LD_VAR 0 18
118053: IFFALSE 118073
118055: PUSH
118056: LD_VAR 0 4
118060: PUSH
118061: LD_VAR 0 7
118065: ARRAY
118066: PPUSH
118067: CALL_OW 310
118071: NOT
118072: AND
118073: IFFALSE 118116
118075: PUSH
118076: LD_VAR 0 14
118080: PUSH
118081: LD_INT 1
118083: ARRAY
118084: PUSH
118085: LD_VAR 0 14
118089: PPUSH
118090: LD_INT 21
118092: PUSH
118093: LD_INT 2
118095: PUSH
118096: EMPTY
118097: LIST
118098: LIST
118099: PUSH
118100: LD_INT 58
118102: PUSH
118103: EMPTY
118104: LIST
118105: PUSH
118106: EMPTY
118107: LIST
118108: LIST
118109: PPUSH
118110: CALL_OW 72
118114: IN
118115: AND
118116: IFFALSE 118152
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
118118: LD_VAR 0 4
118122: PUSH
118123: LD_VAR 0 7
118127: ARRAY
118128: PPUSH
118129: LD_VAR 0 14
118133: PUSH
118134: LD_INT 1
118136: ARRAY
118137: PPUSH
118138: CALL_OW 120
// attacking := true ;
118142: LD_ADDR_VAR 0 29
118146: PUSH
118147: LD_INT 1
118149: ST_TO_ADDR
// continue ;
118150: GO 116301
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
118152: LD_VAR 0 26
118156: IFFALSE 118179
118158: PUSH
118159: LD_VAR 0 4
118163: PUSH
118164: LD_VAR 0 7
118168: ARRAY
118169: PPUSH
118170: CALL_OW 257
118174: PUSH
118175: LD_INT 1
118177: EQUAL
118178: AND
118179: IFFALSE 118202
118181: PUSH
118182: LD_VAR 0 4
118186: PUSH
118187: LD_VAR 0 7
118191: ARRAY
118192: PPUSH
118193: CALL_OW 256
118197: PUSH
118198: LD_INT 800
118200: LESS
118201: AND
118202: IFFALSE 118222
118204: PUSH
118205: LD_VAR 0 4
118209: PUSH
118210: LD_VAR 0 7
118214: ARRAY
118215: PPUSH
118216: CALL_OW 318
118220: NOT
118221: AND
118222: IFFALSE 118239
// ComCrawl ( group [ i ] ) ;
118224: LD_VAR 0 4
118228: PUSH
118229: LD_VAR 0 7
118233: ARRAY
118234: PPUSH
118235: CALL_OW 137
// if f_mines then
118239: LD_VAR 0 21
118243: IFFALSE 118488
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
118245: LD_VAR 0 14
118249: PUSH
118250: LD_INT 1
118252: ARRAY
118253: PPUSH
118254: CALL_OW 247
118258: PUSH
118259: LD_INT 3
118261: EQUAL
118262: IFFALSE 118281
118264: PUSH
118265: LD_VAR 0 14
118269: PUSH
118270: LD_INT 1
118272: ARRAY
118273: PUSH
118274: LD_VAR 0 27
118278: IN
118279: NOT
118280: AND
118281: IFFALSE 118488
// begin x := GetX ( tmp [ 1 ] ) ;
118283: LD_ADDR_VAR 0 10
118287: PUSH
118288: LD_VAR 0 14
118292: PUSH
118293: LD_INT 1
118295: ARRAY
118296: PPUSH
118297: CALL_OW 250
118301: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
118302: LD_ADDR_VAR 0 11
118306: PUSH
118307: LD_VAR 0 14
118311: PUSH
118312: LD_INT 1
118314: ARRAY
118315: PPUSH
118316: CALL_OW 251
118320: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
118321: LD_ADDR_VAR 0 12
118325: PUSH
118326: LD_VAR 0 4
118330: PUSH
118331: LD_VAR 0 7
118335: ARRAY
118336: PPUSH
118337: CALL 82995 0 1
118341: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
118342: LD_VAR 0 4
118346: PUSH
118347: LD_VAR 0 7
118351: ARRAY
118352: PPUSH
118353: LD_VAR 0 10
118357: PPUSH
118358: LD_VAR 0 11
118362: PPUSH
118363: LD_VAR 0 14
118367: PUSH
118368: LD_INT 1
118370: ARRAY
118371: PPUSH
118372: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
118376: LD_VAR 0 4
118380: PUSH
118381: LD_VAR 0 7
118385: ARRAY
118386: PPUSH
118387: LD_VAR 0 10
118391: PPUSH
118392: LD_VAR 0 12
118396: PPUSH
118397: LD_INT 7
118399: PPUSH
118400: CALL_OW 272
118404: PPUSH
118405: LD_VAR 0 11
118409: PPUSH
118410: LD_VAR 0 12
118414: PPUSH
118415: LD_INT 7
118417: PPUSH
118418: CALL_OW 273
118422: PPUSH
118423: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
118427: LD_VAR 0 4
118431: PUSH
118432: LD_VAR 0 7
118436: ARRAY
118437: PPUSH
118438: LD_INT 71
118440: PPUSH
118441: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
118445: LD_ADDR_VAR 0 27
118449: PUSH
118450: LD_VAR 0 27
118454: PPUSH
118455: LD_VAR 0 27
118459: PUSH
118460: LD_INT 1
118462: PLUS
118463: PPUSH
118464: LD_VAR 0 14
118468: PUSH
118469: LD_INT 1
118471: ARRAY
118472: PPUSH
118473: CALL_OW 1
118477: ST_TO_ADDR
// attacking := true ;
118478: LD_ADDR_VAR 0 29
118482: PUSH
118483: LD_INT 1
118485: ST_TO_ADDR
// continue ;
118486: GO 116301
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
118488: LD_VAR 0 4
118492: PUSH
118493: LD_VAR 0 7
118497: ARRAY
118498: PPUSH
118499: CALL_OW 257
118503: PUSH
118504: LD_INT 17
118506: EQUAL
118507: IFFALSE 118531
118509: PUSH
118510: LD_VAR 0 4
118514: PUSH
118515: LD_VAR 0 7
118519: ARRAY
118520: PPUSH
118521: CALL_OW 110
118525: PUSH
118526: LD_INT 71
118528: EQUAL
118529: NOT
118530: AND
118531: IFFALSE 118677
// begin attacking := false ;
118533: LD_ADDR_VAR 0 29
118537: PUSH
118538: LD_INT 0
118540: ST_TO_ADDR
// k := 5 ;
118541: LD_ADDR_VAR 0 9
118545: PUSH
118546: LD_INT 5
118548: ST_TO_ADDR
// if tmp < k then
118549: LD_VAR 0 14
118553: PUSH
118554: LD_VAR 0 9
118558: LESS
118559: IFFALSE 118571
// k := tmp ;
118561: LD_ADDR_VAR 0 9
118565: PUSH
118566: LD_VAR 0 14
118570: ST_TO_ADDR
// for j = 1 to k do
118571: LD_ADDR_VAR 0 8
118575: PUSH
118576: DOUBLE
118577: LD_INT 1
118579: DEC
118580: ST_TO_ADDR
118581: LD_VAR 0 9
118585: PUSH
118586: FOR_TO
118587: IFFALSE 118675
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
118589: LD_VAR 0 14
118593: PUSH
118594: LD_VAR 0 8
118598: ARRAY
118599: PUSH
118600: LD_VAR 0 14
118604: PPUSH
118605: LD_INT 58
118607: PUSH
118608: EMPTY
118609: LIST
118610: PPUSH
118611: CALL_OW 72
118615: IN
118616: NOT
118617: IFFALSE 118673
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118619: LD_VAR 0 4
118623: PUSH
118624: LD_VAR 0 7
118628: ARRAY
118629: PPUSH
118630: LD_VAR 0 14
118634: PUSH
118635: LD_VAR 0 8
118639: ARRAY
118640: PPUSH
118641: CALL_OW 115
// attacking := true ;
118645: LD_ADDR_VAR 0 29
118649: PUSH
118650: LD_INT 1
118652: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
118653: LD_VAR 0 4
118657: PUSH
118658: LD_VAR 0 7
118662: ARRAY
118663: PPUSH
118664: LD_INT 71
118666: PPUSH
118667: CALL_OW 109
// continue ;
118671: GO 118586
// end ; end ;
118673: GO 118586
118675: POP
118676: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
118677: LD_VAR 0 4
118681: PUSH
118682: LD_VAR 0 7
118686: ARRAY
118687: PPUSH
118688: CALL_OW 257
118692: PUSH
118693: LD_INT 8
118695: EQUAL
118696: IFTRUE 118734
118698: PUSH
118699: LD_VAR 0 4
118703: PUSH
118704: LD_VAR 0 7
118708: ARRAY
118709: PPUSH
118710: CALL_OW 264
118714: PUSH
118715: LD_INT 28
118717: PUSH
118718: LD_INT 45
118720: PUSH
118721: LD_INT 7
118723: PUSH
118724: LD_INT 47
118726: PUSH
118727: EMPTY
118728: LIST
118729: LIST
118730: LIST
118731: LIST
118732: IN
118733: OR
118734: IFFALSE 118990
// begin attacking := false ;
118736: LD_ADDR_VAR 0 29
118740: PUSH
118741: LD_INT 0
118743: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
118744: LD_VAR 0 14
118748: PUSH
118749: LD_INT 1
118751: ARRAY
118752: PPUSH
118753: CALL_OW 266
118757: PUSH
118758: LD_INT 32
118760: PUSH
118761: LD_INT 31
118763: PUSH
118764: LD_INT 33
118766: PUSH
118767: LD_INT 4
118769: PUSH
118770: LD_INT 5
118772: PUSH
118773: EMPTY
118774: LIST
118775: LIST
118776: LIST
118777: LIST
118778: LIST
118779: IN
118780: IFFALSE 118966
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
118782: LD_ADDR_VAR 0 9
118786: PUSH
118787: LD_VAR 0 14
118791: PUSH
118792: LD_INT 1
118794: ARRAY
118795: PPUSH
118796: CALL_OW 266
118800: PPUSH
118801: LD_VAR 0 14
118805: PUSH
118806: LD_INT 1
118808: ARRAY
118809: PPUSH
118810: CALL_OW 250
118814: PPUSH
118815: LD_VAR 0 14
118819: PUSH
118820: LD_INT 1
118822: ARRAY
118823: PPUSH
118824: CALL_OW 251
118828: PPUSH
118829: LD_VAR 0 14
118833: PUSH
118834: LD_INT 1
118836: ARRAY
118837: PPUSH
118838: CALL_OW 254
118842: PPUSH
118843: LD_VAR 0 14
118847: PUSH
118848: LD_INT 1
118850: ARRAY
118851: PPUSH
118852: CALL_OW 248
118856: PPUSH
118857: LD_INT 0
118859: PPUSH
118860: CALL 64353 0 6
118864: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
118865: LD_ADDR_VAR 0 8
118869: PUSH
118870: LD_VAR 0 4
118874: PUSH
118875: LD_VAR 0 7
118879: ARRAY
118880: PPUSH
118881: LD_VAR 0 9
118885: PPUSH
118886: CALL 83108 0 2
118890: ST_TO_ADDR
// if j then
118891: LD_VAR 0 8
118895: IFFALSE 118964
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
118897: LD_VAR 0 8
118901: PUSH
118902: LD_INT 1
118904: ARRAY
118905: PPUSH
118906: LD_VAR 0 8
118910: PUSH
118911: LD_INT 2
118913: ARRAY
118914: PPUSH
118915: CALL_OW 488
118919: IFFALSE 118964
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
118921: LD_VAR 0 4
118925: PUSH
118926: LD_VAR 0 7
118930: ARRAY
118931: PPUSH
118932: LD_VAR 0 8
118936: PUSH
118937: LD_INT 1
118939: ARRAY
118940: PPUSH
118941: LD_VAR 0 8
118945: PUSH
118946: LD_INT 2
118948: ARRAY
118949: PPUSH
118950: CALL_OW 116
// attacking := true ;
118954: LD_ADDR_VAR 0 29
118958: PUSH
118959: LD_INT 1
118961: ST_TO_ADDR
// continue ;
118962: GO 116301
// end ; end else
118964: GO 118990
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118966: LD_VAR 0 4
118970: PUSH
118971: LD_VAR 0 7
118975: ARRAY
118976: PPUSH
118977: LD_VAR 0 14
118981: PUSH
118982: LD_INT 1
118984: ARRAY
118985: PPUSH
118986: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
118990: LD_VAR 0 4
118994: PUSH
118995: LD_VAR 0 7
118999: ARRAY
119000: PPUSH
119001: CALL_OW 265
119005: PUSH
119006: LD_INT 11
119008: EQUAL
119009: IFFALSE 119287
// begin k := 10 ;
119011: LD_ADDR_VAR 0 9
119015: PUSH
119016: LD_INT 10
119018: ST_TO_ADDR
// x := 0 ;
119019: LD_ADDR_VAR 0 10
119023: PUSH
119024: LD_INT 0
119026: ST_TO_ADDR
// if tmp < k then
119027: LD_VAR 0 14
119031: PUSH
119032: LD_VAR 0 9
119036: LESS
119037: IFFALSE 119049
// k := tmp ;
119039: LD_ADDR_VAR 0 9
119043: PUSH
119044: LD_VAR 0 14
119048: ST_TO_ADDR
// for j = k downto 1 do
119049: LD_ADDR_VAR 0 8
119053: PUSH
119054: DOUBLE
119055: LD_VAR 0 9
119059: INC
119060: ST_TO_ADDR
119061: LD_INT 1
119063: PUSH
119064: FOR_DOWNTO
119065: IFFALSE 119140
// begin if GetType ( tmp [ j ] ) = unit_human then
119067: LD_VAR 0 14
119071: PUSH
119072: LD_VAR 0 8
119076: ARRAY
119077: PPUSH
119078: CALL_OW 247
119082: PUSH
119083: LD_INT 1
119085: EQUAL
119086: IFFALSE 119138
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
119088: LD_VAR 0 4
119092: PUSH
119093: LD_VAR 0 7
119097: ARRAY
119098: PPUSH
119099: LD_VAR 0 14
119103: PUSH
119104: LD_VAR 0 8
119108: ARRAY
119109: PPUSH
119110: CALL 83366 0 2
// x := tmp [ j ] ;
119114: LD_ADDR_VAR 0 10
119118: PUSH
119119: LD_VAR 0 14
119123: PUSH
119124: LD_VAR 0 8
119128: ARRAY
119129: ST_TO_ADDR
// attacking := true ;
119130: LD_ADDR_VAR 0 29
119134: PUSH
119135: LD_INT 1
119137: ST_TO_ADDR
// end ; end ;
119138: GO 119064
119140: POP
119141: POP
// if not x then
119142: LD_VAR 0 10
119146: NOT
119147: IFFALSE 119287
// begin attacking := true ;
119149: LD_ADDR_VAR 0 29
119153: PUSH
119154: LD_INT 1
119156: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
119157: LD_VAR 0 4
119161: PUSH
119162: LD_VAR 0 7
119166: ARRAY
119167: PPUSH
119168: CALL_OW 250
119172: PPUSH
119173: LD_VAR 0 4
119177: PUSH
119178: LD_VAR 0 7
119182: ARRAY
119183: PPUSH
119184: CALL_OW 251
119188: PPUSH
119189: CALL_OW 546
119193: PUSH
119194: LD_INT 2
119196: ARRAY
119197: PUSH
119198: LD_VAR 0 14
119202: PUSH
119203: LD_INT 1
119205: ARRAY
119206: PPUSH
119207: CALL_OW 250
119211: PPUSH
119212: LD_VAR 0 14
119216: PUSH
119217: LD_INT 1
119219: ARRAY
119220: PPUSH
119221: CALL_OW 251
119225: PPUSH
119226: CALL_OW 546
119230: PUSH
119231: LD_INT 2
119233: ARRAY
119234: EQUAL
119235: IFFALSE 119263
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
119237: LD_VAR 0 4
119241: PUSH
119242: LD_VAR 0 7
119246: ARRAY
119247: PPUSH
119248: LD_VAR 0 14
119252: PUSH
119253: LD_INT 1
119255: ARRAY
119256: PPUSH
119257: CALL 83366 0 2
119261: GO 119287
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119263: LD_VAR 0 4
119267: PUSH
119268: LD_VAR 0 7
119272: ARRAY
119273: PPUSH
119274: LD_VAR 0 14
119278: PUSH
119279: LD_INT 1
119281: ARRAY
119282: PPUSH
119283: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
119287: LD_VAR 0 4
119291: PUSH
119292: LD_VAR 0 7
119296: ARRAY
119297: PPUSH
119298: CALL_OW 264
119302: PUSH
119303: LD_INT 29
119305: EQUAL
119306: IFFALSE 119676
// begin if WantsToAttack ( group [ i ] ) in bombed then
119308: LD_VAR 0 4
119312: PUSH
119313: LD_VAR 0 7
119317: ARRAY
119318: PPUSH
119319: CALL_OW 319
119323: PUSH
119324: LD_VAR 0 28
119328: IN
119329: IFFALSE 119333
// continue ;
119331: GO 116301
// k := 8 ;
119333: LD_ADDR_VAR 0 9
119337: PUSH
119338: LD_INT 8
119340: ST_TO_ADDR
// x := 0 ;
119341: LD_ADDR_VAR 0 10
119345: PUSH
119346: LD_INT 0
119348: ST_TO_ADDR
// if tmp < k then
119349: LD_VAR 0 14
119353: PUSH
119354: LD_VAR 0 9
119358: LESS
119359: IFFALSE 119371
// k := tmp ;
119361: LD_ADDR_VAR 0 9
119365: PUSH
119366: LD_VAR 0 14
119370: ST_TO_ADDR
// for j = 1 to k do
119371: LD_ADDR_VAR 0 8
119375: PUSH
119376: DOUBLE
119377: LD_INT 1
119379: DEC
119380: ST_TO_ADDR
119381: LD_VAR 0 9
119385: PUSH
119386: FOR_TO
119387: IFFALSE 119521
// begin if GetType ( tmp [ j ] ) = unit_building then
119389: LD_VAR 0 14
119393: PUSH
119394: LD_VAR 0 8
119398: ARRAY
119399: PPUSH
119400: CALL_OW 247
119404: PUSH
119405: LD_INT 3
119407: EQUAL
119408: IFFALSE 119519
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
119410: LD_VAR 0 14
119414: PUSH
119415: LD_VAR 0 8
119419: ARRAY
119420: PUSH
119421: LD_VAR 0 28
119425: IN
119426: NOT
119427: IFFALSE 119446
119429: PUSH
119430: LD_VAR 0 14
119434: PUSH
119435: LD_VAR 0 8
119439: ARRAY
119440: PPUSH
119441: CALL_OW 313
119445: AND
119446: IFFALSE 119519
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119448: LD_VAR 0 4
119452: PUSH
119453: LD_VAR 0 7
119457: ARRAY
119458: PPUSH
119459: LD_VAR 0 14
119463: PUSH
119464: LD_VAR 0 8
119468: ARRAY
119469: PPUSH
119470: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
119474: LD_ADDR_VAR 0 28
119478: PUSH
119479: LD_VAR 0 28
119483: PPUSH
119484: LD_VAR 0 28
119488: PUSH
119489: LD_INT 1
119491: PLUS
119492: PPUSH
119493: LD_VAR 0 14
119497: PUSH
119498: LD_VAR 0 8
119502: ARRAY
119503: PPUSH
119504: CALL_OW 1
119508: ST_TO_ADDR
// attacking := true ;
119509: LD_ADDR_VAR 0 29
119513: PUSH
119514: LD_INT 1
119516: ST_TO_ADDR
// break ;
119517: GO 119521
// end ; end ;
119519: GO 119386
119521: POP
119522: POP
// if not attacking and f_attack_depot then
119523: LD_VAR 0 29
119527: NOT
119528: IFFALSE 119536
119530: PUSH
119531: LD_VAR 0 25
119535: AND
119536: IFFALSE 119631
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119538: LD_ADDR_VAR 0 13
119542: PUSH
119543: LD_VAR 0 14
119547: PPUSH
119548: LD_INT 2
119550: PUSH
119551: LD_INT 30
119553: PUSH
119554: LD_INT 0
119556: PUSH
119557: EMPTY
119558: LIST
119559: LIST
119560: PUSH
119561: LD_INT 30
119563: PUSH
119564: LD_INT 1
119566: PUSH
119567: EMPTY
119568: LIST
119569: LIST
119570: PUSH
119571: EMPTY
119572: LIST
119573: LIST
119574: LIST
119575: PPUSH
119576: CALL_OW 72
119580: ST_TO_ADDR
// if z then
119581: LD_VAR 0 13
119585: IFFALSE 119631
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
119587: LD_VAR 0 4
119591: PUSH
119592: LD_VAR 0 7
119596: ARRAY
119597: PPUSH
119598: LD_VAR 0 13
119602: PPUSH
119603: LD_VAR 0 4
119607: PUSH
119608: LD_VAR 0 7
119612: ARRAY
119613: PPUSH
119614: CALL_OW 74
119618: PPUSH
119619: CALL_OW 115
// attacking := true ;
119623: LD_ADDR_VAR 0 29
119627: PUSH
119628: LD_INT 1
119630: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
119631: LD_VAR 0 4
119635: PUSH
119636: LD_VAR 0 7
119640: ARRAY
119641: PPUSH
119642: CALL_OW 256
119646: PUSH
119647: LD_INT 500
119649: LESS
119650: IFFALSE 119676
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119652: LD_VAR 0 4
119656: PUSH
119657: LD_VAR 0 7
119661: ARRAY
119662: PPUSH
119663: LD_VAR 0 14
119667: PUSH
119668: LD_INT 1
119670: ARRAY
119671: PPUSH
119672: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
119676: LD_VAR 0 4
119680: PUSH
119681: LD_VAR 0 7
119685: ARRAY
119686: PPUSH
119687: CALL_OW 264
119691: PUSH
119692: LD_INT 49
119694: EQUAL
119695: IFFALSE 119816
// begin if not HasTask ( group [ i ] ) then
119697: LD_VAR 0 4
119701: PUSH
119702: LD_VAR 0 7
119706: ARRAY
119707: PPUSH
119708: CALL_OW 314
119712: NOT
119713: IFFALSE 119816
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
119715: LD_ADDR_VAR 0 9
119719: PUSH
119720: LD_INT 81
119722: PUSH
119723: LD_VAR 0 4
119727: PUSH
119728: LD_VAR 0 7
119732: ARRAY
119733: PPUSH
119734: CALL_OW 255
119738: PUSH
119739: EMPTY
119740: LIST
119741: LIST
119742: PPUSH
119743: CALL_OW 69
119747: PPUSH
119748: LD_VAR 0 4
119752: PUSH
119753: LD_VAR 0 7
119757: ARRAY
119758: PPUSH
119759: CALL_OW 74
119763: ST_TO_ADDR
// if k then
119764: LD_VAR 0 9
119768: IFFALSE 119816
// if GetDistUnits ( group [ i ] , k ) > 10 then
119770: LD_VAR 0 4
119774: PUSH
119775: LD_VAR 0 7
119779: ARRAY
119780: PPUSH
119781: LD_VAR 0 9
119785: PPUSH
119786: CALL_OW 296
119790: PUSH
119791: LD_INT 10
119793: GREATER
119794: IFFALSE 119816
// ComMoveUnit ( group [ i ] , k ) ;
119796: LD_VAR 0 4
119800: PUSH
119801: LD_VAR 0 7
119805: ARRAY
119806: PPUSH
119807: LD_VAR 0 9
119811: PPUSH
119812: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
119816: LD_VAR 0 4
119820: PUSH
119821: LD_VAR 0 7
119825: ARRAY
119826: PPUSH
119827: CALL_OW 256
119831: PUSH
119832: LD_INT 250
119834: LESS
119835: IFFALSE 119879
119837: PUSH
119838: LD_VAR 0 4
119842: PUSH
119843: LD_VAR 0 7
119847: ARRAY
119848: PUSH
119849: LD_INT 21
119851: PUSH
119852: LD_INT 2
119854: PUSH
119855: EMPTY
119856: LIST
119857: LIST
119858: PUSH
119859: LD_INT 23
119861: PUSH
119862: LD_INT 2
119864: PUSH
119865: EMPTY
119866: LIST
119867: LIST
119868: PUSH
119869: EMPTY
119870: LIST
119871: LIST
119872: PPUSH
119873: CALL_OW 69
119877: IN
119878: AND
119879: IFFALSE 120006
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
119881: LD_ADDR_VAR 0 9
119885: PUSH
119886: LD_OWVAR 3
119890: PUSH
119891: LD_VAR 0 4
119895: PUSH
119896: LD_VAR 0 7
119900: ARRAY
119901: DIFF
119902: PPUSH
119903: LD_VAR 0 4
119907: PUSH
119908: LD_VAR 0 7
119912: ARRAY
119913: PPUSH
119914: CALL_OW 74
119918: ST_TO_ADDR
// if not k then
119919: LD_VAR 0 9
119923: NOT
119924: IFFALSE 119928
// continue ;
119926: GO 116301
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
119928: LD_VAR 0 9
119932: PUSH
119933: LD_INT 81
119935: PUSH
119936: LD_VAR 0 4
119940: PUSH
119941: LD_VAR 0 7
119945: ARRAY
119946: PPUSH
119947: CALL_OW 255
119951: PUSH
119952: EMPTY
119953: LIST
119954: LIST
119955: PPUSH
119956: CALL_OW 69
119960: IN
119961: IFFALSE 119989
119963: PUSH
119964: LD_VAR 0 9
119968: PPUSH
119969: LD_VAR 0 4
119973: PUSH
119974: LD_VAR 0 7
119978: ARRAY
119979: PPUSH
119980: CALL_OW 296
119984: PUSH
119985: LD_INT 5
119987: LESS
119988: AND
119989: IFFALSE 120006
// ComAutodestruct ( group [ i ] ) ;
119991: LD_VAR 0 4
119995: PUSH
119996: LD_VAR 0 7
120000: ARRAY
120001: PPUSH
120002: CALL 83262 0 1
// end ; if f_attack_depot then
120006: LD_VAR 0 25
120010: IFFALSE 120122
// begin k := 6 ;
120012: LD_ADDR_VAR 0 9
120016: PUSH
120017: LD_INT 6
120019: ST_TO_ADDR
// if tmp < k then
120020: LD_VAR 0 14
120024: PUSH
120025: LD_VAR 0 9
120029: LESS
120030: IFFALSE 120042
// k := tmp ;
120032: LD_ADDR_VAR 0 9
120036: PUSH
120037: LD_VAR 0 14
120041: ST_TO_ADDR
// for j = 1 to k do
120042: LD_ADDR_VAR 0 8
120046: PUSH
120047: DOUBLE
120048: LD_INT 1
120050: DEC
120051: ST_TO_ADDR
120052: LD_VAR 0 9
120056: PUSH
120057: FOR_TO
120058: IFFALSE 120120
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
120060: LD_VAR 0 8
120064: PPUSH
120065: CALL_OW 266
120069: PUSH
120070: LD_INT 0
120072: PUSH
120073: LD_INT 1
120075: PUSH
120076: EMPTY
120077: LIST
120078: LIST
120079: IN
120080: IFFALSE 120118
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120082: LD_VAR 0 4
120086: PUSH
120087: LD_VAR 0 7
120091: ARRAY
120092: PPUSH
120093: LD_VAR 0 14
120097: PUSH
120098: LD_VAR 0 8
120102: ARRAY
120103: PPUSH
120104: CALL_OW 115
// attacking := true ;
120108: LD_ADDR_VAR 0 29
120112: PUSH
120113: LD_INT 1
120115: ST_TO_ADDR
// break ;
120116: GO 120120
// end ;
120118: GO 120057
120120: POP
120121: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
120122: LD_VAR 0 4
120126: PUSH
120127: LD_VAR 0 7
120131: ARRAY
120132: PPUSH
120133: CALL_OW 302
120137: IFFALSE 120146
120139: PUSH
120140: LD_VAR 0 29
120144: NOT
120145: AND
120146: IFFALSE 120476
// begin if GetTag ( group [ i ] ) = 71 then
120148: LD_VAR 0 4
120152: PUSH
120153: LD_VAR 0 7
120157: ARRAY
120158: PPUSH
120159: CALL_OW 110
120163: PUSH
120164: LD_INT 71
120166: EQUAL
120167: IFFALSE 120208
// begin if HasTask ( group [ i ] ) then
120169: LD_VAR 0 4
120173: PUSH
120174: LD_VAR 0 7
120178: ARRAY
120179: PPUSH
120180: CALL_OW 314
120184: IFFALSE 120190
// continue else
120186: GO 116301
120188: GO 120208
// SetTag ( group [ i ] , 0 ) ;
120190: LD_VAR 0 4
120194: PUSH
120195: LD_VAR 0 7
120199: ARRAY
120200: PPUSH
120201: LD_INT 0
120203: PPUSH
120204: CALL_OW 109
// end ; k := 8 ;
120208: LD_ADDR_VAR 0 9
120212: PUSH
120213: LD_INT 8
120215: ST_TO_ADDR
// x := 0 ;
120216: LD_ADDR_VAR 0 10
120220: PUSH
120221: LD_INT 0
120223: ST_TO_ADDR
// if tmp < k then
120224: LD_VAR 0 14
120228: PUSH
120229: LD_VAR 0 9
120233: LESS
120234: IFFALSE 120246
// k := tmp ;
120236: LD_ADDR_VAR 0 9
120240: PUSH
120241: LD_VAR 0 14
120245: ST_TO_ADDR
// for j = 1 to k do
120246: LD_ADDR_VAR 0 8
120250: PUSH
120251: DOUBLE
120252: LD_INT 1
120254: DEC
120255: ST_TO_ADDR
120256: LD_VAR 0 9
120260: PUSH
120261: FOR_TO
120262: IFFALSE 120368
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
120264: LD_VAR 0 14
120268: PUSH
120269: LD_VAR 0 8
120273: ARRAY
120274: PPUSH
120275: CALL_OW 247
120279: PUSH
120280: LD_INT 1
120282: EQUAL
120283: IFFALSE 120346
120285: PUSH
120286: LD_VAR 0 14
120290: PUSH
120291: LD_VAR 0 8
120295: ARRAY
120296: PPUSH
120297: CALL_OW 256
120301: PUSH
120302: LD_INT 250
120304: LESS
120305: IFFALSE 120313
120307: PUSH
120308: LD_VAR 0 20
120312: AND
120313: IFTRUE 120345
120315: PUSH
120316: LD_VAR 0 20
120320: NOT
120321: IFFALSE 120344
120323: PUSH
120324: LD_VAR 0 14
120328: PUSH
120329: LD_VAR 0 8
120333: ARRAY
120334: PPUSH
120335: CALL_OW 256
120339: PUSH
120340: LD_INT 250
120342: GREATEREQUAL
120343: AND
120344: OR
120345: AND
120346: IFFALSE 120366
// begin x := tmp [ j ] ;
120348: LD_ADDR_VAR 0 10
120352: PUSH
120353: LD_VAR 0 14
120357: PUSH
120358: LD_VAR 0 8
120362: ARRAY
120363: ST_TO_ADDR
// break ;
120364: GO 120368
// end ;
120366: GO 120261
120368: POP
120369: POP
// if x then
120370: LD_VAR 0 10
120374: IFFALSE 120398
// ComAttackUnit ( group [ i ] , x ) else
120376: LD_VAR 0 4
120380: PUSH
120381: LD_VAR 0 7
120385: ARRAY
120386: PPUSH
120387: LD_VAR 0 10
120391: PPUSH
120392: CALL_OW 115
120396: GO 120422
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120398: LD_VAR 0 4
120402: PUSH
120403: LD_VAR 0 7
120407: ARRAY
120408: PPUSH
120409: LD_VAR 0 14
120413: PUSH
120414: LD_INT 1
120416: ARRAY
120417: PPUSH
120418: CALL_OW 115
// if not HasTask ( group [ i ] ) then
120422: LD_VAR 0 4
120426: PUSH
120427: LD_VAR 0 7
120431: ARRAY
120432: PPUSH
120433: CALL_OW 314
120437: NOT
120438: IFFALSE 120476
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
120440: LD_VAR 0 4
120444: PUSH
120445: LD_VAR 0 7
120449: ARRAY
120450: PPUSH
120451: LD_VAR 0 14
120455: PPUSH
120456: LD_VAR 0 4
120460: PUSH
120461: LD_VAR 0 7
120465: ARRAY
120466: PPUSH
120467: CALL_OW 74
120471: PPUSH
120472: CALL_OW 115
// end ; end ; end ;
120476: GO 116301
120478: POP
120479: POP
// wait ( 0 0$2 ) ;
120480: LD_INT 70
120482: PPUSH
120483: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
120487: LD_VAR 0 4
120491: NOT
120492: IFTRUE 120503
120494: PUSH
120495: LD_VAR 0 4
120499: PUSH
120500: EMPTY
120501: EQUAL
120502: OR
120503: IFTRUE 120524
120505: PUSH
120506: LD_INT 81
120508: PUSH
120509: LD_VAR 0 35
120513: PUSH
120514: EMPTY
120515: LIST
120516: LIST
120517: PPUSH
120518: CALL_OW 69
120522: NOT
120523: OR
120524: IFFALSE 116286
// end ;
120526: LD_VAR 0 2
120530: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
120531: LD_INT 0
120533: PPUSH
120534: PPUSH
120535: PPUSH
120536: PPUSH
120537: PPUSH
120538: PPUSH
// if not base or not mc_bases [ base ] or not solds then
120539: LD_VAR 0 1
120543: NOT
120544: IFTRUE 120559
120546: PUSH
120547: LD_EXP 50
120551: PUSH
120552: LD_VAR 0 1
120556: ARRAY
120557: NOT
120558: OR
120559: IFTRUE 120568
120561: PUSH
120562: LD_VAR 0 2
120566: NOT
120567: OR
120568: IFFALSE 120572
// exit ;
120570: GO 121130
// side := mc_sides [ base ] ;
120572: LD_ADDR_VAR 0 6
120576: PUSH
120577: LD_EXP 76
120581: PUSH
120582: LD_VAR 0 1
120586: ARRAY
120587: ST_TO_ADDR
// if not side then
120588: LD_VAR 0 6
120592: NOT
120593: IFFALSE 120597
// exit ;
120595: GO 121130
// for i in solds do
120597: LD_ADDR_VAR 0 7
120601: PUSH
120602: LD_VAR 0 2
120606: PUSH
120607: FOR_IN
120608: IFFALSE 120669
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
120610: LD_VAR 0 7
120614: PPUSH
120615: CALL_OW 310
120619: PPUSH
120620: CALL_OW 266
120624: PUSH
120625: LD_INT 32
120627: PUSH
120628: LD_INT 31
120630: PUSH
120631: EMPTY
120632: LIST
120633: LIST
120634: IN
120635: IFFALSE 120655
// solds := solds diff i else
120637: LD_ADDR_VAR 0 2
120641: PUSH
120642: LD_VAR 0 2
120646: PUSH
120647: LD_VAR 0 7
120651: DIFF
120652: ST_TO_ADDR
120653: GO 120667
// SetTag ( i , 18 ) ;
120655: LD_VAR 0 7
120659: PPUSH
120660: LD_INT 18
120662: PPUSH
120663: CALL_OW 109
120667: GO 120607
120669: POP
120670: POP
// if not solds then
120671: LD_VAR 0 2
120675: NOT
120676: IFFALSE 120680
// exit ;
120678: GO 121130
// repeat wait ( 0 0$2 ) ;
120680: LD_INT 70
120682: PPUSH
120683: CALL_OW 67
// enemy := mc_scan [ base ] ;
120687: LD_ADDR_VAR 0 4
120691: PUSH
120692: LD_EXP 73
120696: PUSH
120697: LD_VAR 0 1
120701: ARRAY
120702: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120703: LD_EXP 50
120707: PUSH
120708: LD_VAR 0 1
120712: ARRAY
120713: NOT
120714: IFTRUE 120731
120716: PUSH
120717: LD_EXP 50
120721: PUSH
120722: LD_VAR 0 1
120726: ARRAY
120727: PUSH
120728: EMPTY
120729: EQUAL
120730: OR
120731: IFFALSE 120768
// begin for i in solds do
120733: LD_ADDR_VAR 0 7
120737: PUSH
120738: LD_VAR 0 2
120742: PUSH
120743: FOR_IN
120744: IFFALSE 120757
// ComStop ( i ) ;
120746: LD_VAR 0 7
120750: PPUSH
120751: CALL_OW 141
120755: GO 120743
120757: POP
120758: POP
// solds := [ ] ;
120759: LD_ADDR_VAR 0 2
120763: PUSH
120764: EMPTY
120765: ST_TO_ADDR
// exit ;
120766: GO 121130
// end ; for i in solds do
120768: LD_ADDR_VAR 0 7
120772: PUSH
120773: LD_VAR 0 2
120777: PUSH
120778: FOR_IN
120779: IFFALSE 121100
// begin if IsInUnit ( i ) then
120781: LD_VAR 0 7
120785: PPUSH
120786: CALL_OW 310
120790: IFFALSE 120801
// ComExitBuilding ( i ) ;
120792: LD_VAR 0 7
120796: PPUSH
120797: CALL_OW 122
// if GetLives ( i ) > 500 then
120801: LD_VAR 0 7
120805: PPUSH
120806: CALL_OW 256
120810: PUSH
120811: LD_INT 500
120813: GREATER
120814: IFFALSE 120867
// begin e := NearestUnitToUnit ( enemy , i ) ;
120816: LD_ADDR_VAR 0 5
120820: PUSH
120821: LD_VAR 0 4
120825: PPUSH
120826: LD_VAR 0 7
120830: PPUSH
120831: CALL_OW 74
120835: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
120836: LD_VAR 0 7
120840: PPUSH
120841: LD_VAR 0 5
120845: PPUSH
120846: CALL_OW 250
120850: PPUSH
120851: LD_VAR 0 5
120855: PPUSH
120856: CALL_OW 251
120860: PPUSH
120861: CALL_OW 114
// end else
120865: GO 121098
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
120867: LD_VAR 0 7
120871: PPUSH
120872: LD_EXP 50
120876: PUSH
120877: LD_VAR 0 1
120881: ARRAY
120882: PPUSH
120883: LD_INT 2
120885: PUSH
120886: LD_INT 30
120888: PUSH
120889: LD_INT 0
120891: PUSH
120892: EMPTY
120893: LIST
120894: LIST
120895: PUSH
120896: LD_INT 30
120898: PUSH
120899: LD_INT 1
120901: PUSH
120902: EMPTY
120903: LIST
120904: LIST
120905: PUSH
120906: LD_INT 30
120908: PUSH
120909: LD_INT 6
120911: PUSH
120912: EMPTY
120913: LIST
120914: LIST
120915: PUSH
120916: EMPTY
120917: LIST
120918: LIST
120919: LIST
120920: LIST
120921: PPUSH
120922: CALL_OW 72
120926: PPUSH
120927: LD_VAR 0 7
120931: PPUSH
120932: CALL_OW 74
120936: PPUSH
120937: CALL_OW 296
120941: PUSH
120942: LD_INT 10
120944: GREATER
120945: IFFALSE 121098
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
120947: LD_ADDR_VAR 0 8
120951: PUSH
120952: LD_EXP 50
120956: PUSH
120957: LD_VAR 0 1
120961: ARRAY
120962: PPUSH
120963: LD_INT 2
120965: PUSH
120966: LD_INT 30
120968: PUSH
120969: LD_INT 0
120971: PUSH
120972: EMPTY
120973: LIST
120974: LIST
120975: PUSH
120976: LD_INT 30
120978: PUSH
120979: LD_INT 1
120981: PUSH
120982: EMPTY
120983: LIST
120984: LIST
120985: PUSH
120986: LD_INT 30
120988: PUSH
120989: LD_INT 6
120991: PUSH
120992: EMPTY
120993: LIST
120994: LIST
120995: PUSH
120996: EMPTY
120997: LIST
120998: LIST
120999: LIST
121000: LIST
121001: PPUSH
121002: CALL_OW 72
121006: PPUSH
121007: LD_VAR 0 7
121011: PPUSH
121012: CALL_OW 74
121016: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
121017: LD_VAR 0 7
121021: PPUSH
121022: LD_VAR 0 8
121026: PPUSH
121027: CALL_OW 250
121031: PPUSH
121032: LD_INT 3
121034: PPUSH
121035: LD_INT 5
121037: PPUSH
121038: CALL_OW 272
121042: PPUSH
121043: LD_VAR 0 8
121047: PPUSH
121048: CALL_OW 251
121052: PPUSH
121053: LD_INT 3
121055: PPUSH
121056: LD_INT 5
121058: PPUSH
121059: CALL_OW 273
121063: PPUSH
121064: CALL_OW 111
// SetTag ( i , 0 ) ;
121068: LD_VAR 0 7
121072: PPUSH
121073: LD_INT 0
121075: PPUSH
121076: CALL_OW 109
// solds := solds diff i ;
121080: LD_ADDR_VAR 0 2
121084: PUSH
121085: LD_VAR 0 2
121089: PUSH
121090: LD_VAR 0 7
121094: DIFF
121095: ST_TO_ADDR
// continue ;
121096: GO 120778
// end ; end ;
121098: GO 120778
121100: POP
121101: POP
// until not solds or not enemy ;
121102: LD_VAR 0 2
121106: NOT
121107: IFTRUE 121116
121109: PUSH
121110: LD_VAR 0 4
121114: NOT
121115: OR
121116: IFFALSE 120680
// MC_Reset ( base , 18 ) ;
121118: LD_VAR 0 1
121122: PPUSH
121123: LD_INT 18
121125: PPUSH
121126: CALL 22862 0 2
// end ;
121130: LD_VAR 0 3
121134: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
121135: LD_INT 0
121137: PPUSH
121138: PPUSH
121139: PPUSH
121140: PPUSH
121141: PPUSH
121142: PPUSH
121143: PPUSH
121144: PPUSH
121145: PPUSH
121146: PPUSH
121147: PPUSH
121148: PPUSH
121149: PPUSH
121150: PPUSH
121151: PPUSH
121152: PPUSH
121153: PPUSH
121154: PPUSH
121155: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
121156: LD_ADDR_VAR 0 12
121160: PUSH
121161: LD_EXP 50
121165: PUSH
121166: LD_VAR 0 1
121170: ARRAY
121171: PPUSH
121172: LD_INT 25
121174: PUSH
121175: LD_INT 3
121177: PUSH
121178: EMPTY
121179: LIST
121180: LIST
121181: PPUSH
121182: CALL_OW 72
121186: ST_TO_ADDR
// if mc_remote_driver [ base ] then
121187: LD_EXP 90
121191: PUSH
121192: LD_VAR 0 1
121196: ARRAY
121197: IFFALSE 121221
// mechs := mechs diff mc_remote_driver [ base ] ;
121199: LD_ADDR_VAR 0 12
121203: PUSH
121204: LD_VAR 0 12
121208: PUSH
121209: LD_EXP 90
121213: PUSH
121214: LD_VAR 0 1
121218: ARRAY
121219: DIFF
121220: ST_TO_ADDR
// for i in mechs do
121221: LD_ADDR_VAR 0 4
121225: PUSH
121226: LD_VAR 0 12
121230: PUSH
121231: FOR_IN
121232: IFFALSE 121267
// if GetTag ( i ) > 0 then
121234: LD_VAR 0 4
121238: PPUSH
121239: CALL_OW 110
121243: PUSH
121244: LD_INT 0
121246: GREATER
121247: IFFALSE 121265
// mechs := mechs diff i ;
121249: LD_ADDR_VAR 0 12
121253: PUSH
121254: LD_VAR 0 12
121258: PUSH
121259: LD_VAR 0 4
121263: DIFF
121264: ST_TO_ADDR
121265: GO 121231
121267: POP
121268: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121269: LD_ADDR_VAR 0 8
121273: PUSH
121274: LD_EXP 50
121278: PUSH
121279: LD_VAR 0 1
121283: ARRAY
121284: PPUSH
121285: LD_INT 2
121287: PUSH
121288: LD_INT 25
121290: PUSH
121291: LD_INT 1
121293: PUSH
121294: EMPTY
121295: LIST
121296: LIST
121297: PUSH
121298: LD_INT 25
121300: PUSH
121301: LD_INT 5
121303: PUSH
121304: EMPTY
121305: LIST
121306: LIST
121307: PUSH
121308: LD_INT 25
121310: PUSH
121311: LD_INT 8
121313: PUSH
121314: EMPTY
121315: LIST
121316: LIST
121317: PUSH
121318: LD_INT 25
121320: PUSH
121321: LD_INT 9
121323: PUSH
121324: EMPTY
121325: LIST
121326: LIST
121327: PUSH
121328: EMPTY
121329: LIST
121330: LIST
121331: LIST
121332: LIST
121333: LIST
121334: PPUSH
121335: CALL_OW 72
121339: ST_TO_ADDR
// if not defenders and not solds then
121340: LD_VAR 0 2
121344: NOT
121345: IFFALSE 121354
121347: PUSH
121348: LD_VAR 0 8
121352: NOT
121353: AND
121354: IFFALSE 121358
// exit ;
121356: GO 123180
// depot_under_attack := false ;
121358: LD_ADDR_VAR 0 16
121362: PUSH
121363: LD_INT 0
121365: ST_TO_ADDR
// sold_defenders := [ ] ;
121366: LD_ADDR_VAR 0 17
121370: PUSH
121371: EMPTY
121372: ST_TO_ADDR
// if mechs then
121373: LD_VAR 0 12
121377: IFFALSE 121532
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
121379: LD_ADDR_VAR 0 4
121383: PUSH
121384: LD_VAR 0 2
121388: PPUSH
121389: LD_INT 21
121391: PUSH
121392: LD_INT 2
121394: PUSH
121395: EMPTY
121396: LIST
121397: LIST
121398: PPUSH
121399: CALL_OW 72
121403: PUSH
121404: FOR_IN
121405: IFFALSE 121530
// begin if GetTag ( i ) <> 20 then
121407: LD_VAR 0 4
121411: PPUSH
121412: CALL_OW 110
121416: PUSH
121417: LD_INT 20
121419: NONEQUAL
121420: IFFALSE 121434
// SetTag ( i , 20 ) ;
121422: LD_VAR 0 4
121426: PPUSH
121427: LD_INT 20
121429: PPUSH
121430: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
121434: LD_VAR 0 4
121438: PPUSH
121439: CALL_OW 263
121443: PUSH
121444: LD_INT 1
121446: EQUAL
121447: IFFALSE 121461
121449: PUSH
121450: LD_VAR 0 4
121454: PPUSH
121455: CALL_OW 311
121459: NOT
121460: AND
121461: IFFALSE 121528
// begin un := mechs [ 1 ] ;
121463: LD_ADDR_VAR 0 10
121467: PUSH
121468: LD_VAR 0 12
121472: PUSH
121473: LD_INT 1
121475: ARRAY
121476: ST_TO_ADDR
// ComExit ( un ) ;
121477: LD_VAR 0 10
121481: PPUSH
121482: CALL 88353 0 1
// AddComEnterUnit ( un , i ) ;
121486: LD_VAR 0 10
121490: PPUSH
121491: LD_VAR 0 4
121495: PPUSH
121496: CALL_OW 180
// SetTag ( un , 19 ) ;
121500: LD_VAR 0 10
121504: PPUSH
121505: LD_INT 19
121507: PPUSH
121508: CALL_OW 109
// mechs := mechs diff un ;
121512: LD_ADDR_VAR 0 12
121516: PUSH
121517: LD_VAR 0 12
121521: PUSH
121522: LD_VAR 0 10
121526: DIFF
121527: ST_TO_ADDR
// end ; end ;
121528: GO 121404
121530: POP
121531: POP
// if solds then
121532: LD_VAR 0 8
121536: IFFALSE 121595
// for i in solds do
121538: LD_ADDR_VAR 0 4
121542: PUSH
121543: LD_VAR 0 8
121547: PUSH
121548: FOR_IN
121549: IFFALSE 121593
// if not GetTag ( i ) then
121551: LD_VAR 0 4
121555: PPUSH
121556: CALL_OW 110
121560: NOT
121561: IFFALSE 121591
// begin defenders := defenders union i ;
121563: LD_ADDR_VAR 0 2
121567: PUSH
121568: LD_VAR 0 2
121572: PUSH
121573: LD_VAR 0 4
121577: UNION
121578: ST_TO_ADDR
// SetTag ( i , 18 ) ;
121579: LD_VAR 0 4
121583: PPUSH
121584: LD_INT 18
121586: PPUSH
121587: CALL_OW 109
// end ;
121591: GO 121548
121593: POP
121594: POP
// repeat wait ( 0 0$2 ) ;
121595: LD_INT 70
121597: PPUSH
121598: CALL_OW 67
// enemy := mc_scan [ base ] ;
121602: LD_ADDR_VAR 0 21
121606: PUSH
121607: LD_EXP 73
121611: PUSH
121612: LD_VAR 0 1
121616: ARRAY
121617: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121618: LD_EXP 50
121622: PUSH
121623: LD_VAR 0 1
121627: ARRAY
121628: NOT
121629: IFTRUE 121646
121631: PUSH
121632: LD_EXP 50
121636: PUSH
121637: LD_VAR 0 1
121641: ARRAY
121642: PUSH
121643: EMPTY
121644: EQUAL
121645: OR
121646: IFFALSE 121683
// begin for i in defenders do
121648: LD_ADDR_VAR 0 4
121652: PUSH
121653: LD_VAR 0 2
121657: PUSH
121658: FOR_IN
121659: IFFALSE 121672
// ComStop ( i ) ;
121661: LD_VAR 0 4
121665: PPUSH
121666: CALL_OW 141
121670: GO 121658
121672: POP
121673: POP
// defenders := [ ] ;
121674: LD_ADDR_VAR 0 2
121678: PUSH
121679: EMPTY
121680: ST_TO_ADDR
// exit ;
121681: GO 123180
// end ; for i in defenders do
121683: LD_ADDR_VAR 0 4
121687: PUSH
121688: LD_VAR 0 2
121692: PUSH
121693: FOR_IN
121694: IFFALSE 122628
// begin e := NearestUnitToUnit ( enemy , i ) ;
121696: LD_ADDR_VAR 0 13
121700: PUSH
121701: LD_VAR 0 21
121705: PPUSH
121706: LD_VAR 0 4
121710: PPUSH
121711: CALL_OW 74
121715: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
121716: LD_ADDR_VAR 0 7
121720: PUSH
121721: LD_EXP 50
121725: PUSH
121726: LD_VAR 0 1
121730: ARRAY
121731: PPUSH
121732: LD_INT 2
121734: PUSH
121735: LD_INT 30
121737: PUSH
121738: LD_INT 0
121740: PUSH
121741: EMPTY
121742: LIST
121743: LIST
121744: PUSH
121745: LD_INT 30
121747: PUSH
121748: LD_INT 1
121750: PUSH
121751: EMPTY
121752: LIST
121753: LIST
121754: PUSH
121755: EMPTY
121756: LIST
121757: LIST
121758: LIST
121759: PPUSH
121760: CALL_OW 72
121764: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
121765: LD_ADDR_VAR 0 16
121769: PUSH
121770: LD_VAR 0 7
121774: NOT
121775: IFTRUE 121805
121777: PUSH
121778: LD_VAR 0 7
121782: PPUSH
121783: LD_INT 3
121785: PUSH
121786: LD_INT 24
121788: PUSH
121789: LD_INT 600
121791: PUSH
121792: EMPTY
121793: LIST
121794: LIST
121795: PUSH
121796: EMPTY
121797: LIST
121798: LIST
121799: PPUSH
121800: CALL_OW 72
121804: OR
121805: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
121806: LD_VAR 0 4
121810: PPUSH
121811: CALL_OW 247
121815: PUSH
121816: LD_INT 2
121818: DOUBLE
121819: EQUAL
121820: IFTRUE 121824
121822: GO 122240
121824: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
121825: LD_VAR 0 4
121829: PPUSH
121830: CALL_OW 256
121834: PUSH
121835: LD_INT 1000
121837: EQUAL
121838: IFFALSE 121884
121840: PUSH
121841: LD_VAR 0 4
121845: PPUSH
121846: LD_VAR 0 13
121850: PPUSH
121851: CALL_OW 296
121855: PUSH
121856: LD_INT 40
121858: LESS
121859: IFTRUE 121883
121861: PUSH
121862: LD_VAR 0 13
121866: PPUSH
121867: LD_EXP 75
121871: PUSH
121872: LD_VAR 0 1
121876: ARRAY
121877: PPUSH
121878: CALL_OW 308
121882: OR
121883: AND
121884: IFFALSE 122010
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
121886: LD_VAR 0 4
121890: PPUSH
121891: CALL_OW 262
121895: PUSH
121896: LD_INT 1
121898: EQUAL
121899: IFFALSE 121916
121901: PUSH
121902: LD_VAR 0 4
121906: PPUSH
121907: CALL_OW 261
121911: PUSH
121912: LD_INT 30
121914: LESS
121915: AND
121916: IFFALSE 121924
121918: PUSH
121919: LD_VAR 0 7
121923: AND
121924: IFFALSE 121994
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
121926: LD_VAR 0 4
121930: PPUSH
121931: LD_VAR 0 7
121935: PPUSH
121936: LD_VAR 0 4
121940: PPUSH
121941: CALL_OW 74
121945: PPUSH
121946: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
121950: LD_VAR 0 4
121954: PPUSH
121955: LD_VAR 0 7
121959: PPUSH
121960: LD_VAR 0 4
121964: PPUSH
121965: CALL_OW 74
121969: PPUSH
121970: CALL_OW 296
121974: PUSH
121975: LD_INT 6
121977: LESS
121978: IFFALSE 121992
// SetFuel ( i , 100 ) ;
121980: LD_VAR 0 4
121984: PPUSH
121985: LD_INT 100
121987: PPUSH
121988: CALL_OW 240
// end else
121992: GO 122008
// ComAttackUnit ( i , e ) ;
121994: LD_VAR 0 4
121998: PPUSH
121999: LD_VAR 0 13
122003: PPUSH
122004: CALL_OW 115
// end else
122008: GO 122117
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
122010: LD_VAR 0 13
122014: PPUSH
122015: LD_EXP 75
122019: PUSH
122020: LD_VAR 0 1
122024: ARRAY
122025: PPUSH
122026: CALL_OW 308
122030: NOT
122031: IFFALSE 122053
122033: PUSH
122034: LD_VAR 0 4
122038: PPUSH
122039: LD_VAR 0 13
122043: PPUSH
122044: CALL_OW 296
122048: PUSH
122049: LD_INT 40
122051: GREATEREQUAL
122052: AND
122053: IFTRUE 122070
122055: PUSH
122056: LD_VAR 0 4
122060: PPUSH
122061: CALL_OW 256
122065: PUSH
122066: LD_INT 650
122068: LESSEQUAL
122069: OR
122070: IFFALSE 122095
122072: PUSH
122073: LD_VAR 0 4
122077: PPUSH
122078: LD_EXP 74
122082: PUSH
122083: LD_VAR 0 1
122087: ARRAY
122088: PPUSH
122089: CALL_OW 308
122093: NOT
122094: AND
122095: IFFALSE 122117
// ComMoveToArea ( i , mc_parking [ base ] ) ;
122097: LD_VAR 0 4
122101: PPUSH
122102: LD_EXP 74
122106: PUSH
122107: LD_VAR 0 1
122111: ARRAY
122112: PPUSH
122113: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
122117: LD_VAR 0 4
122121: PPUSH
122122: CALL_OW 256
122126: PUSH
122127: LD_INT 1000
122129: LESS
122130: IFFALSE 122147
122132: PUSH
122133: LD_VAR 0 4
122137: PPUSH
122138: CALL_OW 263
122142: PUSH
122143: LD_INT 1
122145: EQUAL
122146: AND
122147: IFFALSE 122160
122149: PUSH
122150: LD_VAR 0 4
122154: PPUSH
122155: CALL_OW 311
122159: AND
122160: IFFALSE 122184
122162: PUSH
122163: LD_VAR 0 4
122167: PPUSH
122168: LD_EXP 74
122172: PUSH
122173: LD_VAR 0 1
122177: ARRAY
122178: PPUSH
122179: CALL_OW 308
122183: AND
122184: IFFALSE 122238
// begin mech := IsDrivenBy ( i ) ;
122186: LD_ADDR_VAR 0 9
122190: PUSH
122191: LD_VAR 0 4
122195: PPUSH
122196: CALL_OW 311
122200: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
122201: LD_VAR 0 9
122205: PPUSH
122206: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
122210: LD_VAR 0 9
122214: PPUSH
122215: LD_VAR 0 4
122219: PPUSH
122220: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
122224: LD_VAR 0 9
122228: PPUSH
122229: LD_VAR 0 4
122233: PPUSH
122234: CALL_OW 180
// end ; end ; unit_human :
122238: GO 122599
122240: LD_INT 1
122242: DOUBLE
122243: EQUAL
122244: IFTRUE 122248
122246: GO 122598
122248: POP
// begin b := IsInUnit ( i ) ;
122249: LD_ADDR_VAR 0 18
122253: PUSH
122254: LD_VAR 0 4
122258: PPUSH
122259: CALL_OW 310
122263: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
122264: LD_ADDR_VAR 0 19
122268: PUSH
122269: LD_VAR 0 18
122273: NOT
122274: IFTRUE 122298
122276: PUSH
122277: LD_VAR 0 18
122281: PPUSH
122282: CALL_OW 266
122286: PUSH
122287: LD_INT 32
122289: PUSH
122290: LD_INT 31
122292: PUSH
122293: EMPTY
122294: LIST
122295: LIST
122296: IN
122297: OR
122298: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
122299: LD_VAR 0 18
122303: PPUSH
122304: CALL_OW 266
122308: PUSH
122309: LD_INT 5
122311: EQUAL
122312: IFFALSE 122344
122314: PUSH
122315: LD_VAR 0 4
122319: PPUSH
122320: CALL_OW 257
122324: PUSH
122325: LD_INT 1
122327: PUSH
122328: LD_INT 2
122330: PUSH
122331: LD_INT 3
122333: PUSH
122334: LD_INT 4
122336: PUSH
122337: EMPTY
122338: LIST
122339: LIST
122340: LIST
122341: LIST
122342: IN
122343: AND
122344: IFFALSE 122381
// begin class := AllowSpecClass ( i ) ;
122346: LD_ADDR_VAR 0 20
122350: PUSH
122351: LD_VAR 0 4
122355: PPUSH
122356: CALL 51663 0 1
122360: ST_TO_ADDR
// if class then
122361: LD_VAR 0 20
122365: IFFALSE 122381
// ComChangeProfession ( i , class ) ;
122367: LD_VAR 0 4
122371: PPUSH
122372: LD_VAR 0 20
122376: PPUSH
122377: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
122381: LD_VAR 0 16
122385: IFTRUE 122412
122387: PUSH
122388: LD_VAR 0 2
122392: PPUSH
122393: LD_INT 21
122395: PUSH
122396: LD_INT 2
122398: PUSH
122399: EMPTY
122400: LIST
122401: LIST
122402: PPUSH
122403: CALL_OW 72
122407: PUSH
122408: LD_INT 1
122410: LESSEQUAL
122411: OR
122412: IFFALSE 122420
122414: PUSH
122415: LD_VAR 0 19
122419: AND
122420: IFFALSE 122435
122422: PUSH
122423: LD_VAR 0 4
122427: PUSH
122428: LD_VAR 0 17
122432: IN
122433: NOT
122434: AND
122435: IFFALSE 122530
// begin if b then
122437: LD_VAR 0 18
122441: IFFALSE 122492
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
122443: LD_VAR 0 18
122447: PPUSH
122448: LD_VAR 0 21
122452: PPUSH
122453: LD_VAR 0 18
122457: PPUSH
122458: CALL_OW 74
122462: PPUSH
122463: CALL_OW 296
122467: PUSH
122468: LD_INT 10
122470: LESS
122471: IFFALSE 122488
122473: PUSH
122474: LD_VAR 0 18
122478: PPUSH
122479: CALL_OW 461
122483: PUSH
122484: LD_INT 7
122486: NONEQUAL
122487: AND
122488: IFFALSE 122492
// continue ;
122490: GO 121693
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
122492: LD_ADDR_VAR 0 17
122496: PUSH
122497: LD_VAR 0 17
122501: PPUSH
122502: LD_VAR 0 17
122506: PUSH
122507: LD_INT 1
122509: PLUS
122510: PPUSH
122511: LD_VAR 0 4
122515: PPUSH
122516: CALL_OW 1
122520: ST_TO_ADDR
// ComExitBuilding ( i ) ;
122521: LD_VAR 0 4
122525: PPUSH
122526: CALL_OW 122
// end ; if sold_defenders then
122530: LD_VAR 0 17
122534: IFFALSE 122596
// if i in sold_defenders then
122536: LD_VAR 0 4
122540: PUSH
122541: LD_VAR 0 17
122545: IN
122546: IFFALSE 122596
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
122548: LD_VAR 0 4
122552: PPUSH
122553: CALL_OW 314
122557: NOT
122558: IFFALSE 122580
122560: PUSH
122561: LD_VAR 0 4
122565: PPUSH
122566: LD_VAR 0 13
122570: PPUSH
122571: CALL_OW 296
122575: PUSH
122576: LD_INT 30
122578: LESS
122579: AND
122580: IFFALSE 122596
// ComAttackUnit ( i , e ) ;
122582: LD_VAR 0 4
122586: PPUSH
122587: LD_VAR 0 13
122591: PPUSH
122592: CALL_OW 115
// end ; end ; end ;
122596: GO 122599
122598: POP
// if IsDead ( i ) then
122599: LD_VAR 0 4
122603: PPUSH
122604: CALL_OW 301
122608: IFFALSE 122626
// defenders := defenders diff i ;
122610: LD_ADDR_VAR 0 2
122614: PUSH
122615: LD_VAR 0 2
122619: PUSH
122620: LD_VAR 0 4
122624: DIFF
122625: ST_TO_ADDR
// end ;
122626: GO 121693
122628: POP
122629: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
122630: LD_VAR 0 21
122634: NOT
122635: IFTRUE 122644
122637: PUSH
122638: LD_VAR 0 2
122642: NOT
122643: OR
122644: IFTRUE 122659
122646: PUSH
122647: LD_EXP 50
122651: PUSH
122652: LD_VAR 0 1
122656: ARRAY
122657: NOT
122658: OR
122659: IFFALSE 121595
// MC_Reset ( base , 18 ) ;
122661: LD_VAR 0 1
122665: PPUSH
122666: LD_INT 18
122668: PPUSH
122669: CALL 22862 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122673: LD_ADDR_VAR 0 2
122677: PUSH
122678: LD_VAR 0 2
122682: PUSH
122683: LD_VAR 0 2
122687: PPUSH
122688: LD_INT 2
122690: PUSH
122691: LD_INT 25
122693: PUSH
122694: LD_INT 1
122696: PUSH
122697: EMPTY
122698: LIST
122699: LIST
122700: PUSH
122701: LD_INT 25
122703: PUSH
122704: LD_INT 5
122706: PUSH
122707: EMPTY
122708: LIST
122709: LIST
122710: PUSH
122711: LD_INT 25
122713: PUSH
122714: LD_INT 8
122716: PUSH
122717: EMPTY
122718: LIST
122719: LIST
122720: PUSH
122721: LD_INT 25
122723: PUSH
122724: LD_INT 9
122726: PUSH
122727: EMPTY
122728: LIST
122729: LIST
122730: PUSH
122731: EMPTY
122732: LIST
122733: LIST
122734: LIST
122735: LIST
122736: LIST
122737: PPUSH
122738: CALL_OW 72
122742: DIFF
122743: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
122744: LD_VAR 0 21
122748: NOT
122749: IFFALSE 122772
122751: PUSH
122752: LD_VAR 0 2
122756: PPUSH
122757: LD_INT 21
122759: PUSH
122760: LD_INT 2
122762: PUSH
122763: EMPTY
122764: LIST
122765: LIST
122766: PPUSH
122767: CALL_OW 72
122771: AND
122772: IFFALSE 123116
// begin tmp := FilterByTag ( defenders , 19 ) ;
122774: LD_ADDR_VAR 0 11
122778: PUSH
122779: LD_VAR 0 2
122783: PPUSH
122784: LD_INT 19
122786: PPUSH
122787: CALL 85500 0 2
122791: ST_TO_ADDR
// if tmp then
122792: LD_VAR 0 11
122796: IFFALSE 122866
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
122798: LD_ADDR_VAR 0 11
122802: PUSH
122803: LD_VAR 0 11
122807: PPUSH
122808: LD_INT 25
122810: PUSH
122811: LD_INT 3
122813: PUSH
122814: EMPTY
122815: LIST
122816: LIST
122817: PPUSH
122818: CALL_OW 72
122822: ST_TO_ADDR
// if tmp then
122823: LD_VAR 0 11
122827: IFFALSE 122866
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
122829: LD_ADDR_EXP 62
122833: PUSH
122834: LD_EXP 62
122838: PPUSH
122839: LD_VAR 0 1
122843: PPUSH
122844: LD_EXP 62
122848: PUSH
122849: LD_VAR 0 1
122853: ARRAY
122854: PUSH
122855: LD_VAR 0 11
122859: UNION
122860: PPUSH
122861: CALL_OW 1
122865: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
122866: LD_VAR 0 1
122870: PPUSH
122871: LD_INT 19
122873: PPUSH
122874: CALL 22862 0 2
// repeat wait ( 0 0$1 ) ;
122878: LD_INT 35
122880: PPUSH
122881: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122885: LD_EXP 50
122889: PUSH
122890: LD_VAR 0 1
122894: ARRAY
122895: NOT
122896: IFTRUE 122913
122898: PUSH
122899: LD_EXP 50
122903: PUSH
122904: LD_VAR 0 1
122908: ARRAY
122909: PUSH
122910: EMPTY
122911: EQUAL
122912: OR
122913: IFFALSE 122950
// begin for i in defenders do
122915: LD_ADDR_VAR 0 4
122919: PUSH
122920: LD_VAR 0 2
122924: PUSH
122925: FOR_IN
122926: IFFALSE 122939
// ComStop ( i ) ;
122928: LD_VAR 0 4
122932: PPUSH
122933: CALL_OW 141
122937: GO 122925
122939: POP
122940: POP
// defenders := [ ] ;
122941: LD_ADDR_VAR 0 2
122945: PUSH
122946: EMPTY
122947: ST_TO_ADDR
// exit ;
122948: GO 123180
// end ; for i in defenders do
122950: LD_ADDR_VAR 0 4
122954: PUSH
122955: LD_VAR 0 2
122959: PUSH
122960: FOR_IN
122961: IFFALSE 123050
// begin if not IsInArea ( i , mc_parking [ base ] ) then
122963: LD_VAR 0 4
122967: PPUSH
122968: LD_EXP 74
122972: PUSH
122973: LD_VAR 0 1
122977: ARRAY
122978: PPUSH
122979: CALL_OW 308
122983: NOT
122984: IFFALSE 123008
// ComMoveToArea ( i , mc_parking [ base ] ) else
122986: LD_VAR 0 4
122990: PPUSH
122991: LD_EXP 74
122995: PUSH
122996: LD_VAR 0 1
123000: ARRAY
123001: PPUSH
123002: CALL_OW 113
123006: GO 123048
// if GetControl ( i ) = control_manual then
123008: LD_VAR 0 4
123012: PPUSH
123013: CALL_OW 263
123017: PUSH
123018: LD_INT 1
123020: EQUAL
123021: IFFALSE 123048
// if IsDrivenBy ( i ) then
123023: LD_VAR 0 4
123027: PPUSH
123028: CALL_OW 311
123032: IFFALSE 123048
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
123034: LD_VAR 0 4
123038: PPUSH
123039: CALL_OW 311
123043: PPUSH
123044: CALL_OW 121
// end ;
123048: GO 122960
123050: POP
123051: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
123052: LD_VAR 0 2
123056: PPUSH
123057: LD_INT 95
123059: PUSH
123060: LD_EXP 74
123064: PUSH
123065: LD_VAR 0 1
123069: ARRAY
123070: PUSH
123071: EMPTY
123072: LIST
123073: LIST
123074: PPUSH
123075: CALL_OW 72
123079: PUSH
123080: LD_VAR 0 2
123084: EQUAL
123085: IFTRUE 123099
123087: PUSH
123088: LD_EXP 73
123092: PUSH
123093: LD_VAR 0 1
123097: ARRAY
123098: OR
123099: IFTRUE 123114
123101: PUSH
123102: LD_EXP 50
123106: PUSH
123107: LD_VAR 0 1
123111: ARRAY
123112: NOT
123113: OR
123114: IFFALSE 122878
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
123116: LD_ADDR_EXP 72
123120: PUSH
123121: LD_EXP 72
123125: PPUSH
123126: LD_VAR 0 1
123130: PPUSH
123131: LD_VAR 0 2
123135: PPUSH
123136: LD_INT 21
123138: PUSH
123139: LD_INT 2
123141: PUSH
123142: EMPTY
123143: LIST
123144: LIST
123145: PPUSH
123146: CALL_OW 72
123150: PPUSH
123151: CALL_OW 1
123155: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
123156: LD_VAR 0 1
123160: PPUSH
123161: LD_INT 19
123163: PPUSH
123164: CALL 22862 0 2
// MC_Reset ( base , 20 ) ;
123168: LD_VAR 0 1
123172: PPUSH
123173: LD_INT 20
123175: PPUSH
123176: CALL 22862 0 2
// end ; end_of_file
123180: LD_VAR 0 3
123184: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
123185: LD_VAR 0 1
123189: PUSH
123190: LD_INT 200
123192: DOUBLE
123193: GREATEREQUAL
123194: IFFALSE 123202
123196: LD_INT 299
123198: DOUBLE
123199: LESSEQUAL
123200: IFTRUE 123204
123202: GO 123236
123204: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
123205: LD_VAR 0 1
123209: PPUSH
123210: LD_VAR 0 2
123214: PPUSH
123215: LD_VAR 0 3
123219: PPUSH
123220: LD_VAR 0 4
123224: PPUSH
123225: LD_VAR 0 5
123229: PPUSH
123230: CALL 110138 0 5
123234: GO 123313
123236: LD_INT 300
123238: DOUBLE
123239: GREATEREQUAL
123240: IFFALSE 123248
123242: LD_INT 399
123244: DOUBLE
123245: LESSEQUAL
123246: IFTRUE 123250
123248: GO 123312
123250: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
123251: LD_VAR 0 1
123255: PPUSH
123256: LD_VAR 0 2
123260: PPUSH
123261: LD_VAR 0 3
123265: PPUSH
123266: LD_VAR 0 4
123270: PPUSH
123271: LD_VAR 0 5
123275: PPUSH
123276: LD_VAR 0 6
123280: PPUSH
123281: LD_VAR 0 7
123285: PPUSH
123286: LD_VAR 0 8
123290: PPUSH
123291: LD_VAR 0 9
123295: PPUSH
123296: LD_VAR 0 10
123300: PPUSH
123301: LD_VAR 0 11
123305: PPUSH
123306: CALL 105941 0 11
123310: GO 123313
123312: POP
// end ;
123313: PPOPN 11
123315: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
123316: LD_VAR 0 1
123320: PPUSH
123321: LD_VAR 0 2
123325: PPUSH
123326: LD_VAR 0 3
123330: PPUSH
123331: LD_VAR 0 4
123335: PPUSH
123336: LD_VAR 0 5
123340: PPUSH
123341: CALL 109438 0 5
// end ; end_of_file
123345: PPOPN 5
123347: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
123348: LD_VAR 0 1
123352: PPUSH
123353: LD_VAR 0 2
123357: PPUSH
123358: LD_VAR 0 3
123362: PPUSH
123363: LD_VAR 0 4
123367: PPUSH
123368: LD_VAR 0 5
123372: PPUSH
123373: LD_VAR 0 6
123377: PPUSH
123378: CALL 93481 0 6
// end ;
123382: PPOPN 6
123384: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
123385: LD_INT 0
123387: PPUSH
// begin if not units then
123388: LD_VAR 0 1
123392: NOT
123393: IFFALSE 123397
// exit ;
123395: GO 123431
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
123397: LD_VAR 0 1
123401: PPUSH
123402: LD_VAR 0 2
123406: PPUSH
123407: LD_VAR 0 3
123411: PPUSH
123412: LD_VAR 0 4
123416: PPUSH
123417: LD_VAR 0 5
123421: PPUSH
123422: LD_VAR 0 6
123426: PPUSH
123427: CALL 115735 0 6
// end ;
123431: PPOPN 7
123433: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
123434: CALL 93368 0 0
// end ;
123438: PPOPN 1
123440: END
