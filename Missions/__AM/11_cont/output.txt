// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17227 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82195 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19339 0 0
// Action ;
  89: CALL 7917 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40556 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 4
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40556 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 4
 407: PUSH
 408: LD_INT 6
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40556 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 40982 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47266 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47266 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47266 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47266 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47266 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47266 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47266 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47266 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47266 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47266 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47266 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47266 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47266 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47266 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47266 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2347: LD_ADDR_VAR 0 5
2351: PUSH
2352: LD_INT 5
2354: PUSH
2355: LD_INT 6
2357: PUSH
2358: LD_INT 7
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: LIST
2365: PUSH
2366: LD_OWVAR 67
2370: ARRAY
2371: ST_TO_ADDR
// uc_side := 2 ;
2372: LD_ADDR_OWVAR 20
2376: PUSH
2377: LD_INT 2
2379: ST_TO_ADDR
// uc_nation := 2 ;
2380: LD_ADDR_OWVAR 21
2384: PUSH
2385: LD_INT 2
2387: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2388: LD_ADDR_OWVAR 37
2392: PUSH
2393: LD_INT 14
2395: ST_TO_ADDR
// vc_engine := engine_siberite ;
2396: LD_ADDR_OWVAR 39
2400: PUSH
2401: LD_INT 3
2403: ST_TO_ADDR
// vc_control := control_manual ;
2404: LD_ADDR_OWVAR 38
2408: PUSH
2409: LD_INT 1
2411: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2412: LD_ADDR_OWVAR 40
2416: PUSH
2417: LD_INT 31
2419: ST_TO_ADDR
// for i = 1 to 3 do
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: DOUBLE
2426: LD_INT 1
2428: DEC
2429: ST_TO_ADDR
2430: LD_INT 3
2432: PUSH
2433: FOR_TO
2434: IFFALSE 2518
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2436: LD_INT 0
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: LD_VAR 0 5
2446: PPUSH
2447: CALL_OW 380
// un := CreateVehicle ;
2451: LD_ADDR_VAR 0 4
2455: PUSH
2456: CALL_OW 45
2460: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2461: LD_VAR 0 4
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: LD_INT 5
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2481: LD_VAR 0 4
2485: PPUSH
2486: LD_INT 156
2488: PPUSH
2489: LD_INT 15
2491: PPUSH
2492: LD_INT 6
2494: PPUSH
2495: LD_INT 0
2497: PPUSH
2498: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2502: CALL_OW 44
2506: PPUSH
2507: LD_VAR 0 4
2511: PPUSH
2512: CALL_OW 52
// end ;
2516: GO 2433
2518: POP
2519: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , [ 3 , 4 , 5 ] [ Difficulty ] , - 1 , 4 ] ) ;
2520: LD_ADDR_EXP 37
2524: PUSH
2525: LD_INT 94
2527: PPUSH
2528: LD_INT 28
2530: PPUSH
2531: LD_STRING dammam
2533: PPUSH
2534: LD_VAR 0 5
2538: PPUSH
2539: LD_INT 10000
2541: PUSH
2542: LD_INT 1000
2544: PUSH
2545: LD_INT 300
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: PPUSH
2553: LD_INT 1
2555: NEG
2556: PUSH
2557: LD_INT 3
2559: PUSH
2560: LD_INT 4
2562: PUSH
2563: LD_INT 5
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: LIST
2570: PUSH
2571: LD_OWVAR 67
2575: ARRAY
2576: PUSH
2577: LD_INT 1
2579: NEG
2580: PUSH
2581: LD_INT 4
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: LIST
2588: LIST
2589: PPUSH
2590: CALL 57790 0 6
2594: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 3 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2595: LD_ADDR_EXP 37
2599: PUSH
2600: LD_EXP 37
2604: PUSH
2605: LD_INT 122
2607: PPUSH
2608: LD_INT 25
2610: PPUSH
2611: LD_STRING 
2613: PPUSH
2614: LD_VAR 0 5
2618: PPUSH
2619: LD_INT 500
2621: PUSH
2622: LD_INT 60
2624: PUSH
2625: LD_INT 0
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: LIST
2632: PPUSH
2633: LD_INT 1
2635: NEG
2636: PUSH
2637: LD_INT 3
2639: PUSH
2640: LD_INT 3
2642: PUSH
2643: LD_INT 4
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: LIST
2650: PUSH
2651: LD_OWVAR 67
2655: ARRAY
2656: PUSH
2657: LD_INT 2
2659: PUSH
2660: LD_INT 0
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: LIST
2667: LIST
2668: PPUSH
2669: CALL 57790 0 6
2673: UNION
2674: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2675: LD_ADDR_EXP 35
2679: PUSH
2680: LD_INT 45
2682: PPUSH
2683: LD_INT 24
2685: PPUSH
2686: LD_STRING jeddah
2688: PPUSH
2689: LD_VAR 0 5
2693: PPUSH
2694: LD_INT 700
2696: PUSH
2697: LD_INT 300
2699: PUSH
2700: LD_INT 10
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PPUSH
2708: LD_INT 1
2710: NEG
2711: PUSH
2712: LD_INT 5
2714: PUSH
2715: LD_INT 3
2717: PUSH
2718: LD_INT 2
2720: PUSH
2721: EMPTY
2722: LIST
2723: LIST
2724: LIST
2725: LIST
2726: PPUSH
2727: CALL 57790 0 6
2731: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2732: LD_ADDR_EXP 36
2736: PUSH
2737: LD_INT 7
2739: PPUSH
2740: LD_INT 27
2742: PPUSH
2743: LD_STRING riyadh
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: LD_INT 500
2753: PUSH
2754: LD_INT 60
2756: PUSH
2757: LD_INT 0
2759: PUSH
2760: EMPTY
2761: LIST
2762: LIST
2763: LIST
2764: PPUSH
2765: LD_INT 4
2767: PUSH
2768: LD_INT 2
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: LD_INT 1
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL 57790 0 6
2787: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 12 , 3 , 3 , 2 ] ) ;
2788: LD_ADDR_EXP 39
2792: PUSH
2793: LD_INT 204
2795: PPUSH
2796: LD_INT 26
2798: PPUSH
2799: LD_STRING 
2801: PPUSH
2802: LD_VAR 0 5
2806: PPUSH
2807: LD_INT 500
2809: PUSH
2810: LD_INT 50
2812: PUSH
2813: LD_INT 0
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: LIST
2820: PPUSH
2821: LD_INT 12
2823: PUSH
2824: LD_INT 3
2826: PUSH
2827: LD_INT 3
2829: PUSH
2830: LD_INT 2
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: LIST
2837: LIST
2838: PPUSH
2839: CALL 57790 0 6
2843: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2844: LD_ADDR_EXP 50
2848: PUSH
2849: LD_EXP 37
2853: PUSH
2854: LD_EXP 35
2858: PUSH
2859: LD_EXP 39
2863: PUSH
2864: EMPTY
2865: LIST
2866: LIST
2867: LIST
2868: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2869: LD_ADDR_VAR 0 2
2873: PUSH
2874: LD_INT 22
2876: PUSH
2877: LD_INT 2
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PUSH
2884: LD_INT 30
2886: PUSH
2887: LD_INT 31
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: PUSH
2894: LD_INT 58
2896: PUSH
2897: EMPTY
2898: LIST
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: LIST
2904: PPUSH
2905: CALL_OW 69
2909: PUSH
2910: FOR_IN
2911: IFFALSE 3036
// begin if GetBase ( i ) then
2913: LD_VAR 0 2
2917: PPUSH
2918: CALL_OW 274
2922: IFFALSE 2926
// continue ;
2924: GO 2910
// d := GetDir ( i ) ;
2926: LD_ADDR_VAR 0 3
2930: PUSH
2931: LD_VAR 0 2
2935: PPUSH
2936: CALL_OW 254
2940: ST_TO_ADDR
// if d < 3 then
2941: LD_VAR 0 3
2945: PUSH
2946: LD_INT 3
2948: LESS
2949: IFFALSE 2967
// d := d + 3 else
2951: LD_ADDR_VAR 0 3
2955: PUSH
2956: LD_VAR 0 3
2960: PUSH
2961: LD_INT 3
2963: PLUS
2964: ST_TO_ADDR
2965: GO 2981
// d := d - 3 ;
2967: LD_ADDR_VAR 0 3
2971: PUSH
2972: LD_VAR 0 3
2976: PUSH
2977: LD_INT 3
2979: MINUS
2980: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2981: LD_INT 0
2983: PPUSH
2984: LD_INT 8
2986: PPUSH
2987: LD_VAR 0 5
2991: PPUSH
2992: CALL_OW 380
// un := CreateHuman ;
2996: LD_ADDR_VAR 0 4
3000: PUSH
3001: CALL_OW 44
3005: ST_TO_ADDR
// SetDir ( un , d ) ;
3006: LD_VAR 0 4
3010: PPUSH
3011: LD_VAR 0 3
3015: PPUSH
3016: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3020: LD_VAR 0 4
3024: PPUSH
3025: LD_VAR 0 2
3029: PPUSH
3030: CALL_OW 52
// end ;
3034: GO 2910
3036: POP
3037: POP
// if Difficulty > 1 then
3038: LD_OWVAR 67
3042: PUSH
3043: LD_INT 1
3045: GREATER
3046: IFFALSE 3417
// begin ar_kamikadze := [ ] ;
3048: LD_ADDR_EXP 42
3052: PUSH
3053: EMPTY
3054: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3055: LD_INT 0
3057: PPUSH
3058: LD_INT 1
3060: PPUSH
3061: LD_VAR 0 5
3065: PPUSH
3066: CALL_OW 380
// un := CreateHuman ;
3070: LD_ADDR_VAR 0 4
3074: PUSH
3075: CALL_OW 44
3079: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3080: LD_VAR 0 4
3084: PPUSH
3085: LD_INT 3
3087: PPUSH
3088: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3092: LD_VAR 0 4
3096: PPUSH
3097: LD_INT 23
3099: PPUSH
3100: LD_INT 44
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 48
// ComCrawl ( un ) ;
3110: LD_VAR 0 4
3114: PPUSH
3115: CALL_OW 137
// un := CreateHuman ;
3119: LD_ADDR_VAR 0 4
3123: PUSH
3124: CALL_OW 44
3128: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3129: LD_VAR 0 4
3133: PPUSH
3134: LD_INT 3
3136: PPUSH
3137: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3141: LD_VAR 0 4
3145: PPUSH
3146: LD_INT 30
3148: PPUSH
3149: LD_INT 39
3151: PPUSH
3152: LD_INT 0
3154: PPUSH
3155: CALL_OW 48
// ComCrawl ( un ) ;
3159: LD_VAR 0 4
3163: PPUSH
3164: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3168: LD_INT 0
3170: PPUSH
3171: LD_INT 17
3173: PPUSH
3174: LD_VAR 0 5
3178: PPUSH
3179: CALL_OW 380
// un := CreateHuman ;
3183: LD_ADDR_VAR 0 4
3187: PUSH
3188: CALL_OW 44
3192: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3193: LD_VAR 0 4
3197: PPUSH
3198: LD_INT 3
3200: PPUSH
3201: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3205: LD_VAR 0 4
3209: PPUSH
3210: LD_INT 45
3212: PPUSH
3213: LD_INT 86
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 48
// ComHold ( un ) ;
3223: LD_VAR 0 4
3227: PPUSH
3228: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3232: LD_ADDR_EXP 42
3236: PUSH
3237: LD_EXP 42
3241: PPUSH
3242: LD_EXP 42
3246: PUSH
3247: LD_INT 1
3249: PLUS
3250: PPUSH
3251: LD_VAR 0 4
3255: PPUSH
3256: CALL_OW 1
3260: ST_TO_ADDR
// un := CreateHuman ;
3261: LD_ADDR_VAR 0 4
3265: PUSH
3266: CALL_OW 44
3270: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3271: LD_VAR 0 4
3275: PPUSH
3276: LD_INT 3
3278: PPUSH
3279: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3283: LD_VAR 0 4
3287: PPUSH
3288: LD_INT 60
3290: PPUSH
3291: LD_INT 85
3293: PPUSH
3294: LD_INT 0
3296: PPUSH
3297: CALL_OW 48
// ComHold ( un ) ;
3301: LD_VAR 0 4
3305: PPUSH
3306: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3310: LD_ADDR_EXP 42
3314: PUSH
3315: LD_EXP 42
3319: PPUSH
3320: LD_EXP 42
3324: PUSH
3325: LD_INT 1
3327: PLUS
3328: PPUSH
3329: LD_VAR 0 4
3333: PPUSH
3334: CALL_OW 1
3338: ST_TO_ADDR
// un := CreateHuman ;
3339: LD_ADDR_VAR 0 4
3343: PUSH
3344: CALL_OW 44
3348: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3349: LD_VAR 0 4
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3361: LD_VAR 0 4
3365: PPUSH
3366: LD_INT 222
3368: PPUSH
3369: LD_INT 166
3371: PPUSH
3372: LD_INT 0
3374: PPUSH
3375: CALL_OW 48
// ComHold ( un ) ;
3379: LD_VAR 0 4
3383: PPUSH
3384: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3388: LD_ADDR_EXP 42
3392: PUSH
3393: LD_EXP 42
3397: PPUSH
3398: LD_EXP 42
3402: PUSH
3403: LD_INT 1
3405: PLUS
3406: PPUSH
3407: LD_VAR 0 4
3411: PPUSH
3412: CALL_OW 1
3416: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3417: LD_ADDR_EXP 40
3421: PUSH
3422: EMPTY
3423: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3424: LD_INT 1
3426: PPUSH
3427: LD_INT 1
3429: PPUSH
3430: LD_VAR 0 5
3434: PPUSH
3435: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3439: LD_ADDR_OWVAR 26
3443: PUSH
3444: LD_STRING Pavel Grigorovic
3446: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3447: LD_ADDR_OWVAR 33
3451: PUSH
3452: LD_STRING SecondCharsGal
3454: ST_TO_ADDR
// hc_face_number := 4 ;
3455: LD_ADDR_OWVAR 34
3459: PUSH
3460: LD_INT 4
3462: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3463: LD_ADDR_EXP 40
3467: PUSH
3468: LD_EXP 40
3472: PPUSH
3473: LD_INT 1
3475: PPUSH
3476: CALL_OW 44
3480: PPUSH
3481: CALL_OW 1
3485: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3486: LD_INT 2
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 5
3496: PPUSH
3497: CALL_OW 380
// hc_name := Lucy Sebel ;
3501: LD_ADDR_OWVAR 26
3505: PUSH
3506: LD_STRING Lucy Sebel
3508: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3509: LD_ADDR_OWVAR 33
3513: PUSH
3514: LD_STRING SecondCharsGal
3516: ST_TO_ADDR
// hc_face_number := 15 ;
3517: LD_ADDR_OWVAR 34
3521: PUSH
3522: LD_INT 15
3524: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3525: LD_ADDR_EXP 40
3529: PUSH
3530: LD_EXP 40
3534: PPUSH
3535: LD_INT 2
3537: PPUSH
3538: CALL_OW 44
3542: PPUSH
3543: CALL_OW 1
3547: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 4
3553: PPUSH
3554: LD_VAR 0 5
3558: PPUSH
3559: CALL_OW 380
// hc_gallery :=  ;
3563: LD_ADDR_OWVAR 33
3567: PUSH
3568: LD_STRING 
3570: ST_TO_ADDR
// hc_name :=  ;
3571: LD_ADDR_OWVAR 26
3575: PUSH
3576: LD_STRING 
3578: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3579: LD_ADDR_EXP 40
3583: PUSH
3584: LD_EXP 40
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 44
3596: PPUSH
3597: CALL_OW 1
3601: ST_TO_ADDR
// hc_sex := sex_male ;
3602: LD_ADDR_OWVAR 27
3606: PUSH
3607: LD_INT 1
3609: ST_TO_ADDR
// hc_class = 11 ;
3610: LD_ADDR_OWVAR 28
3614: PUSH
3615: LD_INT 11
3617: ST_TO_ADDR
// hc_gallery = sandar ;
3618: LD_ADDR_OWVAR 33
3622: PUSH
3623: LD_STRING sandar
3625: ST_TO_ADDR
// hc_face_number = 33 ;
3626: LD_ADDR_OWVAR 34
3630: PUSH
3631: LD_INT 33
3633: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3634: LD_ADDR_OWVAR 26
3638: PUSH
3639: LD_STRING Thabit Muhair Saliba
3641: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3642: LD_ADDR_OWVAR 31
3646: PUSH
3647: LD_INT 0
3649: PUSH
3650: LD_INT 0
3652: PUSH
3653: LD_INT 0
3655: PUSH
3656: LD_INT 0
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: LIST
3663: LIST
3664: ST_TO_ADDR
// Saliba = CreateHuman ;
3665: LD_ADDR_EXP 44
3669: PUSH
3670: CALL_OW 44
3674: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3675: LD_EXP 44
3679: PPUSH
3680: LD_INT 7
3682: PPUSH
3683: CALL_OW 52
// if gensher_active then
3687: LD_EXP 18
3691: IFFALSE 3718
// begin Gensher = NewCharacter ( Dietrich ) ;
3693: LD_ADDR_EXP 45
3697: PUSH
3698: LD_STRING Dietrich
3700: PPUSH
3701: CALL_OW 25
3705: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3706: LD_EXP 45
3710: PPUSH
3711: LD_INT 94
3713: PPUSH
3714: CALL_OW 52
// end ; InitHc ;
3718: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3722: LD_ADDR_EXP 41
3726: PUSH
3727: EMPTY
3728: ST_TO_ADDR
// for i = 1 to 5 do
3729: LD_ADDR_VAR 0 2
3733: PUSH
3734: DOUBLE
3735: LD_INT 1
3737: DEC
3738: ST_TO_ADDR
3739: LD_INT 5
3741: PUSH
3742: FOR_TO
3743: IFFALSE 3915
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3745: LD_INT 13
3747: PUSH
3748: LD_INT 14
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: PUSH
3755: LD_INT 1
3757: PPUSH
3758: LD_INT 2
3760: PPUSH
3761: CALL_OW 12
3765: ARRAY
3766: PPUSH
3767: LD_INT 1
3769: PUSH
3770: LD_INT 2
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 2
3782: PPUSH
3783: CALL_OW 12
3787: ARRAY
3788: PPUSH
3789: LD_INT 1
3791: PPUSH
3792: LD_INT 25
3794: PUSH
3795: LD_INT 27
3797: PUSH
3798: LD_INT 26
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: LIST
3805: PUSH
3806: LD_INT 1
3808: PPUSH
3809: LD_INT 3
3811: PPUSH
3812: CALL_OW 12
3816: ARRAY
3817: PPUSH
3818: LD_INT 60
3820: PPUSH
3821: LD_INT 100
3823: PPUSH
3824: CALL_OW 12
3828: PPUSH
3829: CALL 54381 0 5
// un := CreateVehicle ;
3833: LD_ADDR_VAR 0 4
3837: PUSH
3838: CALL_OW 45
3842: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3843: LD_ADDR_EXP 41
3847: PUSH
3848: LD_EXP 41
3852: PPUSH
3853: LD_EXP 41
3857: PUSH
3858: LD_INT 1
3860: PLUS
3861: PPUSH
3862: LD_VAR 0 4
3866: PPUSH
3867: CALL_OW 1
3871: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3872: LD_VAR 0 4
3876: PPUSH
3877: LD_INT 0
3879: PPUSH
3880: LD_INT 5
3882: PPUSH
3883: CALL_OW 12
3887: PPUSH
3888: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3892: LD_VAR 0 4
3896: PPUSH
3897: LD_INT 124
3899: PPUSH
3900: LD_INT 141
3902: PPUSH
3903: LD_INT 8
3905: PPUSH
3906: LD_INT 0
3908: PPUSH
3909: CALL_OW 50
// end ;
3913: GO 3742
3915: POP
3916: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3917: LD_ADDR_EXP 43
3921: PUSH
3922: EMPTY
3923: PUSH
3924: EMPTY
3925: PUSH
3926: EMPTY
3927: PUSH
3928: EMPTY
3929: LIST
3930: LIST
3931: LIST
3932: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3933: LD_ADDR_VAR 0 3
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: LD_INT 3
3948: PUSH
3949: LD_INT 4
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: LIST
3956: PUSH
3957: LD_OWVAR 67
3961: ARRAY
3962: PUSH
3963: FOR_TO
3964: IFFALSE 4178
// for i = 1 to 3 do
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 3
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4174
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3982: LD_INT 14
3984: PPUSH
3985: LD_INT 3
3987: PUSH
3988: LD_INT 2
3990: PUSH
3991: EMPTY
3992: LIST
3993: LIST
3994: PUSH
3995: LD_INT 1
3997: PPUSH
3998: LD_INT 2
4000: PPUSH
4001: CALL_OW 12
4005: ARRAY
4006: PPUSH
4007: LD_INT 1
4009: PUSH
4010: LD_INT 5
4012: PUSH
4013: EMPTY
4014: LIST
4015: LIST
4016: PUSH
4017: LD_INT 1
4019: PPUSH
4020: LD_INT 2
4022: PPUSH
4023: CALL_OW 12
4027: ARRAY
4028: PPUSH
4029: LD_INT 25
4031: PUSH
4032: LD_INT 27
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 28
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: LIST
4045: LIST
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 4
4052: PPUSH
4053: CALL_OW 12
4057: ARRAY
4058: PPUSH
4059: LD_INT 100
4061: PPUSH
4062: CALL 54381 0 5
// un := CreateVehicle ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: CALL_OW 45
4075: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4076: LD_ADDR_EXP 43
4080: PUSH
4081: LD_EXP 43
4085: PPUSH
4086: LD_VAR 0 2
4090: PUSH
4091: LD_EXP 43
4095: PUSH
4096: LD_VAR 0 2
4100: ARRAY
4101: PUSH
4102: LD_INT 1
4104: PLUS
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PPUSH
4110: LD_VAR 0 4
4114: PPUSH
4115: CALL 54503 0 3
4119: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4120: LD_VAR 0 4
4124: PPUSH
4125: LD_INT 0
4127: PPUSH
4128: LD_INT 5
4130: PPUSH
4131: CALL_OW 12
4135: PPUSH
4136: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4140: LD_VAR 0 4
4144: PPUSH
4145: LD_INT 20
4147: PUSH
4148: LD_INT 21
4150: PUSH
4151: LD_INT 22
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_VAR 0 2
4163: ARRAY
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 3979
4174: POP
4175: POP
4176: GO 3963
4178: POP
4179: POP
// InitHc ;
4180: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4184: LD_INT 4
4186: PPUSH
4187: LD_INT 5
4189: PPUSH
4190: LD_INT 10
4192: PPUSH
4193: LD_INT 5
4195: PPUSH
4196: LD_INT 0
4198: PPUSH
4199: CALL_OW 58
// end ;
4203: LD_VAR 0 1
4207: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4208: LD_EXP 42
4212: IFFALSE 4286
4214: GO 4216
4216: DISABLE
4217: LD_INT 0
4219: PPUSH
// begin enable ;
4220: ENABLE
// for i in ar_kamikadze do
4221: LD_ADDR_VAR 0 1
4225: PUSH
4226: LD_EXP 42
4230: PUSH
4231: FOR_IN
4232: IFFALSE 4284
// if See ( 1 , i ) then
4234: LD_INT 1
4236: PPUSH
4237: LD_VAR 0 1
4241: PPUSH
4242: CALL_OW 292
4246: IFFALSE 4282
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4248: LD_VAR 0 1
4252: PPUSH
4253: LD_INT 81
4255: PUSH
4256: LD_INT 2
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PPUSH
4263: CALL_OW 69
4267: PPUSH
4268: LD_VAR 0 1
4272: PPUSH
4273: CALL_OW 74
4277: PPUSH
4278: CALL_OW 115
4282: GO 4231
4284: POP
4285: POP
// end ;
4286: PPOPN 1
4288: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4289: LD_EXP 13
4293: IFFALSE 4610
4295: GO 4297
4297: DISABLE
4298: LD_INT 0
4300: PPUSH
4301: PPUSH
4302: PPUSH
4303: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4304: LD_INT 35
4306: PPUSH
4307: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4311: LD_INT 1
4313: PPUSH
4314: CALL 41270 0 1
4318: PUSH
4319: LD_INT 0
4321: EQUAL
4322: IFFALSE 4304
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4324: LD_INT 1
4326: PPUSH
4327: LD_INT 14
4329: PUSH
4330: LD_INT 3
4332: PUSH
4333: LD_INT 2
4335: PUSH
4336: LD_INT 32
4338: PUSH
4339: EMPTY
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: EMPTY
4346: LIST
4347: PPUSH
4348: CALL 40874 0 2
// repeat wait ( 0 0$1 ) ;
4352: LD_INT 35
4354: PPUSH
4355: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4359: LD_EXP 69
4363: PUSH
4364: LD_INT 1
4366: ARRAY
4367: PPUSH
4368: LD_INT 33
4370: PUSH
4371: LD_INT 2
4373: PUSH
4374: EMPTY
4375: LIST
4376: LIST
4377: PUSH
4378: LD_INT 34
4380: PUSH
4381: LD_INT 32
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PPUSH
4392: CALL_OW 72
4396: IFFALSE 4352
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4398: LD_ADDR_VAR 0 2
4402: PUSH
4403: LD_EXP 69
4407: PUSH
4408: LD_INT 1
4410: ARRAY
4411: PPUSH
4412: LD_INT 33
4414: PUSH
4415: LD_INT 2
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 34
4424: PUSH
4425: LD_INT 32
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 72
4440: PUSH
4441: LD_INT 1
4443: ARRAY
4444: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4445: LD_ADDR_VAR 0 4
4449: PUSH
4450: LD_INT 5
4452: PPUSH
4453: CALL_OW 469
4457: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4458: LD_INT 35
4460: PPUSH
4461: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4465: LD_ADDR_VAR 0 4
4469: PUSH
4470: LD_INT 5
4472: PPUSH
4473: CALL_OW 469
4477: ST_TO_ADDR
// tmp := 100 ;
4478: LD_ADDR_VAR 0 3
4482: PUSH
4483: LD_INT 100
4485: ST_TO_ADDR
// if pos then
4486: LD_VAR 0 4
4490: IFFALSE 4530
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4492: LD_ADDR_VAR 0 3
4496: PUSH
4497: LD_INT 2
4499: PPUSH
4500: LD_VAR 0 4
4504: PUSH
4505: LD_INT 1
4507: ARRAY
4508: PPUSH
4509: LD_VAR 0 4
4513: PUSH
4514: LD_INT 2
4516: ARRAY
4517: PPUSH
4518: LD_INT 20
4520: PPUSH
4521: CALL 55399 0 4
4525: PUSH
4526: LD_INT 4
4528: ARRAY
4529: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4530: LD_VAR 0 4
4534: PUSH
4535: LD_EXP 14
4539: NOT
4540: AND
4541: PUSH
4542: LD_VAR 0 3
4546: PUSH
4547: LD_INT 10
4549: LESS
4550: AND
4551: IFFALSE 4458
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4553: LD_VAR 0 2
4557: PPUSH
4558: LD_VAR 0 4
4562: PUSH
4563: LD_INT 1
4565: ARRAY
4566: PPUSH
4567: LD_VAR 0 4
4571: PUSH
4572: LD_INT 2
4574: ARRAY
4575: PPUSH
4576: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4580: LD_VAR 0 2
4584: PPUSH
4585: LD_INT 198
4587: PPUSH
4588: LD_INT 113
4590: PPUSH
4591: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4595: LD_VAR 0 2
4599: PPUSH
4600: LD_INT 124
4602: PPUSH
4603: LD_INT 7
4605: PPUSH
4606: CALL_OW 171
// end ;
4610: PPOPN 4
4612: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4613: LD_EXP 6
4617: IFFALSE 7293
4619: GO 4621
4621: DISABLE
4622: LD_INT 0
4624: PPUSH
4625: PPUSH
4626: PPUSH
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4632: LD_ADDR_VAR 0 4
4636: PUSH
4637: LD_INT 5
4639: PUSH
4640: LD_INT 6
4642: PUSH
4643: LD_INT 7
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: LIST
4650: PUSH
4651: LD_OWVAR 67
4655: ARRAY
4656: ST_TO_ADDR
// coords := [ ] ;
4657: LD_ADDR_VAR 0 5
4661: PUSH
4662: EMPTY
4663: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4664: LD_ADDR_VAR 0 6
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: LD_INT 0
4677: PUSH
4678: LD_INT 0
4680: PUSH
4681: LD_INT 1
4683: PUSH
4684: LD_INT 0
4686: PUSH
4687: LD_INT 0
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 1
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: LIST
4710: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4711: LD_INT 1
4713: PPUSH
4714: LD_INT 14
4716: PUSH
4717: LD_INT 1
4719: PUSH
4720: LD_INT 2
4722: PUSH
4723: LD_INT 28
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: LIST
4730: LIST
4731: PUSH
4732: LD_INT 14
4734: PUSH
4735: LD_INT 1
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: LD_INT 25
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: PUSH
4750: LD_INT 14
4752: PUSH
4753: LD_INT 1
4755: PUSH
4756: LD_INT 2
4758: PUSH
4759: LD_INT 28
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: PUSH
4768: LD_INT 14
4770: PUSH
4771: LD_INT 1
4773: PUSH
4774: LD_INT 2
4776: PUSH
4777: LD_INT 29
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: PUSH
4786: EMPTY
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL 40874 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4796: LD_INT 21000
4798: PUSH
4799: LD_INT 19950
4801: PUSH
4802: LD_INT 18900
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: PUSH
4810: LD_OWVAR 67
4814: ARRAY
4815: PPUSH
4816: CALL_OW 67
// InitHc ;
4820: CALL_OW 19
// InitUc ;
4824: CALL_OW 18
// uc_side := 2 ;
4828: LD_ADDR_OWVAR 20
4832: PUSH
4833: LD_INT 2
4835: ST_TO_ADDR
// uc_nation := 2 ;
4836: LD_ADDR_OWVAR 21
4840: PUSH
4841: LD_INT 2
4843: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4844: LD_ADDR_VAR 0 3
4848: PUSH
4849: EMPTY
4850: PUSH
4851: EMPTY
4852: PUSH
4853: EMPTY
4854: PUSH
4855: EMPTY
4856: PUSH
4857: EMPTY
4858: PUSH
4859: EMPTY
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4866: LD_ADDR_VAR 0 3
4870: PUSH
4871: LD_VAR 0 3
4875: PPUSH
4876: LD_INT 1
4878: PPUSH
4879: LD_EXP 69
4883: PUSH
4884: LD_INT 1
4886: ARRAY
4887: PUSH
4888: LD_INT 34
4890: PUSH
4891: LD_INT 32
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PPUSH
4898: CALL_OW 69
4902: DIFF
4903: PPUSH
4904: CALL_OW 1
4908: ST_TO_ADDR
// for i = 1 to Difficulty do
4909: LD_ADDR_VAR 0 1
4913: PUSH
4914: DOUBLE
4915: LD_INT 1
4917: DEC
4918: ST_TO_ADDR
4919: LD_OWVAR 67
4923: PUSH
4924: FOR_TO
4925: IFFALSE 5063
// begin uc_side := 2 ;
4927: LD_ADDR_OWVAR 20
4931: PUSH
4932: LD_INT 2
4934: ST_TO_ADDR
// uc_nation := 2 ;
4935: LD_ADDR_OWVAR 21
4939: PUSH
4940: LD_INT 2
4942: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4943: LD_INT 13
4945: PPUSH
4946: LD_INT 3
4948: PPUSH
4949: LD_INT 5
4951: PPUSH
4952: LD_INT 29
4954: PPUSH
4955: LD_INT 100
4957: PPUSH
4958: CALL 54381 0 5
// un := CreateVehicle ;
4962: LD_ADDR_VAR 0 2
4966: PUSH
4967: CALL_OW 45
4971: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4972: LD_ADDR_VAR 0 3
4976: PUSH
4977: LD_VAR 0 3
4981: PPUSH
4982: LD_INT 1
4984: PUSH
4985: LD_VAR 0 3
4989: PUSH
4990: LD_INT 1
4992: ARRAY
4993: PUSH
4994: LD_INT 1
4996: PLUS
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: PPUSH
5002: LD_VAR 0 2
5006: PPUSH
5007: CALL 54503 0 3
5011: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_INT 3
5019: PPUSH
5020: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5024: LD_VAR 0 2
5028: PPUSH
5029: LD_INT 16
5031: PPUSH
5032: LD_INT 0
5034: PPUSH
5035: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 51
5046: PPUSH
5047: LD_INT 10
5049: PPUSH
5050: CALL_OW 111
// wait ( 0 0$2 ) ;
5054: LD_INT 70
5056: PPUSH
5057: CALL_OW 67
// end ;
5061: GO 4924
5063: POP
5064: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5065: LD_ADDR_VAR 0 5
5069: PUSH
5070: LD_INT 51
5072: PUSH
5073: LD_INT 24
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 75
5082: PUSH
5083: LD_INT 90
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5094: LD_INT 1
5096: PPUSH
5097: LD_VAR 0 3
5101: PUSH
5102: LD_INT 1
5104: ARRAY
5105: PPUSH
5106: LD_VAR 0 5
5110: PPUSH
5111: LD_VAR 0 6
5115: PPUSH
5116: CALL 41107 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5120: LD_ADDR_VAR 0 1
5124: PUSH
5125: DOUBLE
5126: LD_INT 1
5128: DEC
5129: ST_TO_ADDR
5130: LD_INT 1
5132: PUSH
5133: LD_INT 3
5135: PUSH
5136: LD_INT 3
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: LIST
5143: PUSH
5144: LD_OWVAR 67
5148: ARRAY
5149: PUSH
5150: FOR_TO
5151: IFFALSE 5251
// begin uc_side := 2 ;
5153: LD_ADDR_OWVAR 20
5157: PUSH
5158: LD_INT 2
5160: ST_TO_ADDR
// uc_nation := 2 ;
5161: LD_ADDR_OWVAR 21
5165: PUSH
5166: LD_INT 2
5168: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5169: LD_INT 0
5171: PPUSH
5172: LD_INT 17
5174: PPUSH
5175: LD_VAR 0 4
5179: PPUSH
5180: CALL_OW 380
// un := CreateHuman ;
5184: LD_ADDR_VAR 0 2
5188: PUSH
5189: CALL_OW 44
5193: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5194: LD_ADDR_VAR 0 3
5198: PUSH
5199: LD_VAR 0 3
5203: PPUSH
5204: LD_INT 2
5206: PUSH
5207: LD_VAR 0 3
5211: PUSH
5212: LD_INT 2
5214: ARRAY
5215: PUSH
5216: LD_INT 1
5218: PLUS
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: PPUSH
5224: LD_VAR 0 2
5228: PPUSH
5229: CALL 54503 0 3
5233: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5234: LD_VAR 0 2
5238: PPUSH
5239: LD_INT 13
5241: PPUSH
5242: LD_INT 0
5244: PPUSH
5245: CALL_OW 49
// end ;
5249: GO 5150
5251: POP
5252: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5253: LD_ADDR_VAR 0 1
5257: PUSH
5258: DOUBLE
5259: LD_INT 1
5261: DEC
5262: ST_TO_ADDR
5263: LD_INT 3
5265: PUSH
5266: LD_INT 4
5268: PUSH
5269: LD_INT 4
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: PUSH
5277: LD_OWVAR 67
5281: ARRAY
5282: PUSH
5283: FOR_TO
5284: IFFALSE 5405
// begin uc_side := 2 ;
5286: LD_ADDR_OWVAR 20
5290: PUSH
5291: LD_INT 2
5293: ST_TO_ADDR
// uc_nation := 2 ;
5294: LD_ADDR_OWVAR 21
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5302: LD_INT 0
5304: PPUSH
5305: LD_INT 1
5307: PUSH
5308: LD_INT 8
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PUSH
5315: LD_VAR 0 1
5319: PUSH
5320: LD_INT 2
5322: MOD
5323: PUSH
5324: LD_INT 1
5326: PLUS
5327: ARRAY
5328: PPUSH
5329: LD_VAR 0 4
5333: PPUSH
5334: CALL_OW 380
// un := CreateHuman ;
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: CALL_OW 44
5347: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5348: LD_ADDR_VAR 0 3
5352: PUSH
5353: LD_VAR 0 3
5357: PPUSH
5358: LD_INT 2
5360: PUSH
5361: LD_VAR 0 3
5365: PUSH
5366: LD_INT 2
5368: ARRAY
5369: PUSH
5370: LD_INT 1
5372: PLUS
5373: PUSH
5374: EMPTY
5375: LIST
5376: LIST
5377: PPUSH
5378: LD_VAR 0 2
5382: PPUSH
5383: CALL 54503 0 3
5387: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5388: LD_VAR 0 2
5392: PPUSH
5393: LD_INT 13
5395: PPUSH
5396: LD_INT 0
5398: PPUSH
5399: CALL_OW 49
// end ;
5403: GO 5283
5405: POP
5406: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5407: LD_ADDR_VAR 0 5
5411: PUSH
5412: LD_INT 67
5414: PUSH
5415: LD_INT 112
5417: PUSH
5418: EMPTY
5419: LIST
5420: LIST
5421: PUSH
5422: LD_INT 85
5424: PUSH
5425: LD_INT 130
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5436: LD_INT 2
5438: PPUSH
5439: LD_VAR 0 3
5443: PUSH
5444: LD_INT 2
5446: ARRAY
5447: PPUSH
5448: LD_VAR 0 5
5452: PPUSH
5453: LD_VAR 0 6
5457: PPUSH
5458: CALL 41107 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5462: LD_ADDR_VAR 0 1
5466: PUSH
5467: DOUBLE
5468: LD_INT 1
5470: DEC
5471: ST_TO_ADDR
5472: LD_INT 1
5474: PUSH
5475: LD_INT 2
5477: PUSH
5478: LD_INT 3
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: LIST
5485: PUSH
5486: LD_OWVAR 67
5490: ARRAY
5491: PUSH
5492: FOR_TO
5493: IFFALSE 5593
// begin uc_side := 2 ;
5495: LD_ADDR_OWVAR 20
5499: PUSH
5500: LD_INT 2
5502: ST_TO_ADDR
// uc_nation := 2 ;
5503: LD_ADDR_OWVAR 21
5507: PUSH
5508: LD_INT 2
5510: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5511: LD_INT 0
5513: PPUSH
5514: LD_INT 17
5516: PPUSH
5517: LD_VAR 0 4
5521: PPUSH
5522: CALL_OW 380
// un := CreateHuman ;
5526: LD_ADDR_VAR 0 2
5530: PUSH
5531: CALL_OW 44
5535: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5536: LD_ADDR_VAR 0 3
5540: PUSH
5541: LD_VAR 0 3
5545: PPUSH
5546: LD_INT 3
5548: PUSH
5549: LD_VAR 0 3
5553: PUSH
5554: LD_INT 3
5556: ARRAY
5557: PUSH
5558: LD_INT 1
5560: PLUS
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PPUSH
5566: LD_VAR 0 2
5570: PPUSH
5571: CALL 54503 0 3
5575: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5576: LD_VAR 0 2
5580: PPUSH
5581: LD_INT 14
5583: PPUSH
5584: LD_INT 0
5586: PPUSH
5587: CALL_OW 49
// end ;
5591: GO 5492
5593: POP
5594: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5595: LD_ADDR_VAR 0 5
5599: PUSH
5600: LD_INT 148
5602: PUSH
5603: LD_INT 158
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: PUSH
5610: LD_INT 148
5612: PUSH
5613: LD_INT 158
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5624: LD_INT 3
5626: PPUSH
5627: LD_VAR 0 3
5631: PUSH
5632: LD_INT 3
5634: ARRAY
5635: PPUSH
5636: LD_VAR 0 5
5640: PPUSH
5641: LD_VAR 0 6
5645: PPUSH
5646: CALL 41107 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5650: LD_ADDR_VAR 0 1
5654: PUSH
5655: DOUBLE
5656: LD_INT 1
5658: DEC
5659: ST_TO_ADDR
5660: LD_INT 2
5662: PUSH
5663: LD_INT 4
5665: PUSH
5666: LD_INT 4
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_OWVAR 67
5678: ARRAY
5679: PUSH
5680: FOR_TO
5681: IFFALSE 5905
// begin uc_side := 2 ;
5683: LD_ADDR_OWVAR 20
5687: PUSH
5688: LD_INT 2
5690: ST_TO_ADDR
// uc_nation := 2 ;
5691: LD_ADDR_OWVAR 21
5695: PUSH
5696: LD_INT 2
5698: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5699: LD_INT 14
5701: PPUSH
5702: LD_INT 3
5704: PPUSH
5705: LD_INT 1
5707: PUSH
5708: LD_INT 5
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: LD_INT 1
5717: PPUSH
5718: LD_INT 2
5720: PPUSH
5721: CALL_OW 12
5725: ARRAY
5726: PPUSH
5727: LD_INT 27
5729: PUSH
5730: LD_INT 26
5732: PUSH
5733: LD_INT 28
5735: PUSH
5736: EMPTY
5737: LIST
5738: LIST
5739: LIST
5740: PUSH
5741: LD_INT 1
5743: PPUSH
5744: LD_INT 3
5746: PPUSH
5747: CALL_OW 12
5751: ARRAY
5752: PPUSH
5753: LD_INT 100
5755: PPUSH
5756: CALL 54381 0 5
// un := CreateVehicle ;
5760: LD_ADDR_VAR 0 2
5764: PUSH
5765: CALL_OW 45
5769: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5770: LD_ADDR_VAR 0 3
5774: PUSH
5775: LD_VAR 0 3
5779: PPUSH
5780: LD_INT 4
5782: PUSH
5783: LD_VAR 0 3
5787: PUSH
5788: LD_INT 4
5790: ARRAY
5791: PUSH
5792: LD_INT 1
5794: PLUS
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PPUSH
5800: LD_VAR 0 2
5804: PPUSH
5805: CALL 54503 0 3
5809: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5810: LD_VAR 0 2
5814: PPUSH
5815: LD_INT 5
5817: PPUSH
5818: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5822: LD_VAR 0 2
5826: PPUSH
5827: LD_INT 15
5829: PPUSH
5830: LD_INT 0
5832: PPUSH
5833: CALL_OW 49
// if GetControl ( un ) = control_manual then
5837: LD_VAR 0 2
5841: PPUSH
5842: CALL_OW 263
5846: PUSH
5847: LD_INT 1
5849: EQUAL
5850: IFFALSE 5881
// begin PrepareHuman ( false , 3 , skill ) ;
5852: LD_INT 0
5854: PPUSH
5855: LD_INT 3
5857: PPUSH
5858: LD_VAR 0 4
5862: PPUSH
5863: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5867: CALL_OW 44
5871: PPUSH
5872: LD_VAR 0 2
5876: PPUSH
5877: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5881: LD_VAR 0 2
5885: PPUSH
5886: LD_INT 179
5888: PPUSH
5889: LD_INT 135
5891: PPUSH
5892: CALL_OW 111
// wait ( 0 0$2 ) ;
5896: LD_INT 70
5898: PPUSH
5899: CALL_OW 67
// end ;
5903: GO 5680
5905: POP
5906: POP
// vc_chassis := 15 ;
5907: LD_ADDR_OWVAR 37
5911: PUSH
5912: LD_INT 15
5914: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5915: LD_ADDR_VAR 0 3
5919: PUSH
5920: LD_VAR 0 3
5924: PPUSH
5925: LD_INT 4
5927: PUSH
5928: LD_VAR 0 3
5932: PUSH
5933: LD_INT 4
5935: ARRAY
5936: PUSH
5937: LD_INT 1
5939: PLUS
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PPUSH
5945: CALL_OW 45
5949: PPUSH
5950: CALL 54503 0 3
5954: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5955: LD_VAR 0 3
5959: PUSH
5960: LD_INT 4
5962: ARRAY
5963: PUSH
5964: LD_VAR 0 3
5968: PUSH
5969: LD_INT 4
5971: ARRAY
5972: ARRAY
5973: PPUSH
5974: LD_INT 15
5976: PPUSH
5977: LD_INT 0
5979: PPUSH
5980: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5984: LD_INT 0
5986: PPUSH
5987: LD_INT 11
5989: PPUSH
5990: LD_VAR 0 4
5994: PPUSH
5995: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5999: LD_ADDR_VAR 0 3
6003: PUSH
6004: LD_VAR 0 3
6008: PPUSH
6009: LD_INT 4
6011: PUSH
6012: LD_VAR 0 3
6016: PUSH
6017: LD_INT 4
6019: ARRAY
6020: PUSH
6021: LD_INT 1
6023: PLUS
6024: PUSH
6025: EMPTY
6026: LIST
6027: LIST
6028: PPUSH
6029: CALL_OW 44
6033: PPUSH
6034: CALL 54503 0 3
6038: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6039: LD_VAR 0 3
6043: PUSH
6044: LD_INT 4
6046: ARRAY
6047: PUSH
6048: LD_VAR 0 3
6052: PUSH
6053: LD_INT 4
6055: ARRAY
6056: ARRAY
6057: PPUSH
6058: LD_VAR 0 3
6062: PUSH
6063: LD_INT 4
6065: ARRAY
6066: PUSH
6067: LD_VAR 0 3
6071: PUSH
6072: LD_INT 4
6074: ARRAY
6075: PUSH
6076: LD_INT 1
6078: MINUS
6079: ARRAY
6080: PPUSH
6081: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6085: LD_ADDR_VAR 0 5
6089: PUSH
6090: LD_INT 148
6092: PUSH
6093: LD_INT 140
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: EMPTY
6101: LIST
6102: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6103: LD_INT 1
6105: PPUSH
6106: LD_VAR 0 3
6110: PUSH
6111: LD_INT 4
6113: ARRAY
6114: PPUSH
6115: LD_VAR 0 5
6119: PPUSH
6120: LD_VAR 0 6
6124: PPUSH
6125: CALL 41107 0 4
// if gensher_active then
6129: LD_EXP 18
6133: IFFALSE 6535
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6135: LD_EXP 45
6139: PPUSH
6140: LD_STRING D10-Diet-1
6142: PPUSH
6143: CALL_OW 94
// for i = 1 to 2 do
6147: LD_ADDR_VAR 0 1
6151: PUSH
6152: DOUBLE
6153: LD_INT 1
6155: DEC
6156: ST_TO_ADDR
6157: LD_INT 2
6159: PUSH
6160: FOR_TO
6161: IFFALSE 6299
// begin uc_side := 2 ;
6163: LD_ADDR_OWVAR 20
6167: PUSH
6168: LD_INT 2
6170: ST_TO_ADDR
// uc_nation := 2 ;
6171: LD_ADDR_OWVAR 21
6175: PUSH
6176: LD_INT 2
6178: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6179: LD_INT 13
6181: PPUSH
6182: LD_INT 3
6184: PPUSH
6185: LD_INT 5
6187: PPUSH
6188: LD_INT 29
6190: PPUSH
6191: LD_INT 100
6193: PPUSH
6194: CALL 54381 0 5
// un := CreateVehicle ;
6198: LD_ADDR_VAR 0 2
6202: PUSH
6203: CALL_OW 45
6207: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6208: LD_ADDR_VAR 0 3
6212: PUSH
6213: LD_VAR 0 3
6217: PPUSH
6218: LD_INT 5
6220: PUSH
6221: LD_VAR 0 3
6225: PUSH
6226: LD_INT 5
6228: ARRAY
6229: PUSH
6230: LD_INT 1
6232: PLUS
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_VAR 0 2
6242: PPUSH
6243: CALL 54503 0 3
6247: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6248: LD_VAR 0 2
6252: PPUSH
6253: LD_INT 0
6255: PPUSH
6256: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6260: LD_VAR 0 2
6264: PPUSH
6265: LD_INT 23
6267: PPUSH
6268: LD_INT 0
6270: PPUSH
6271: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6275: LD_VAR 0 2
6279: PPUSH
6280: LD_INT 85
6282: PPUSH
6283: LD_INT 152
6285: PPUSH
6286: CALL_OW 111
// wait ( 0 0$2 ) ;
6290: LD_INT 70
6292: PPUSH
6293: CALL_OW 67
// end ;
6297: GO 6160
6299: POP
6300: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6301: LD_ADDR_VAR 0 1
6305: PUSH
6306: DOUBLE
6307: LD_INT 1
6309: DEC
6310: ST_TO_ADDR
6311: LD_INT 2
6313: PUSH
6314: LD_INT 3
6316: PUSH
6317: LD_INT 3
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_OWVAR 67
6329: ARRAY
6330: PUSH
6331: FOR_TO
6332: IFFALSE 6489
// begin uc_side := 2 ;
6334: LD_ADDR_OWVAR 20
6338: PUSH
6339: LD_INT 2
6341: ST_TO_ADDR
// uc_nation := 2 ;
6342: LD_ADDR_OWVAR 21
6346: PUSH
6347: LD_INT 2
6349: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6350: LD_INT 14
6352: PPUSH
6353: LD_INT 3
6355: PPUSH
6356: LD_INT 5
6358: PPUSH
6359: LD_INT 27
6361: PUSH
6362: LD_INT 28
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: PUSH
6369: LD_INT 1
6371: PPUSH
6372: LD_INT 2
6374: PPUSH
6375: CALL_OW 12
6379: ARRAY
6380: PPUSH
6381: LD_INT 100
6383: PPUSH
6384: CALL 54381 0 5
// un := CreateVehicle ;
6388: LD_ADDR_VAR 0 2
6392: PUSH
6393: CALL_OW 45
6397: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6398: LD_ADDR_VAR 0 3
6402: PUSH
6403: LD_VAR 0 3
6407: PPUSH
6408: LD_INT 5
6410: PUSH
6411: LD_VAR 0 3
6415: PUSH
6416: LD_INT 5
6418: ARRAY
6419: PUSH
6420: LD_INT 1
6422: PLUS
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: PPUSH
6428: LD_VAR 0 2
6432: PPUSH
6433: CALL 54503 0 3
6437: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6438: LD_VAR 0 2
6442: PPUSH
6443: LD_INT 0
6445: PPUSH
6446: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6450: LD_VAR 0 2
6454: PPUSH
6455: LD_INT 23
6457: PPUSH
6458: LD_INT 0
6460: PPUSH
6461: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6465: LD_VAR 0 2
6469: PPUSH
6470: LD_INT 85
6472: PPUSH
6473: LD_INT 152
6475: PPUSH
6476: CALL_OW 111
// wait ( 0 0$2 ) ;
6480: LD_INT 70
6482: PPUSH
6483: CALL_OW 67
// end ;
6487: GO 6331
6489: POP
6490: POP
// coords := [ [ 97 , 143 ] ] ;
6491: LD_ADDR_VAR 0 5
6495: PUSH
6496: LD_INT 97
6498: PUSH
6499: LD_INT 143
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: PUSH
6506: EMPTY
6507: LIST
6508: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6509: LD_INT 1
6511: PPUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 5
6519: ARRAY
6520: PPUSH
6521: LD_VAR 0 5
6525: PPUSH
6526: LD_VAR 0 6
6530: PPUSH
6531: CALL 41107 0 4
// end ; Wait ( 13 13$00 ) ;
6535: LD_INT 27300
6537: PPUSH
6538: CALL_OW 67
// tmp := [ ] ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: EMPTY
6548: ST_TO_ADDR
// w := 1 ;
6549: LD_ADDR_VAR 0 7
6553: PUSH
6554: LD_INT 1
6556: ST_TO_ADDR
// repeat tmp := [ ] ;
6557: LD_ADDR_VAR 0 3
6561: PUSH
6562: EMPTY
6563: ST_TO_ADDR
// if w mod 4 = 0 then
6564: LD_VAR 0 7
6568: PUSH
6569: LD_INT 4
6571: MOD
6572: PUSH
6573: LD_INT 0
6575: EQUAL
6576: IFFALSE 6663
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6578: LD_ADDR_VAR 0 8
6582: PUSH
6583: LD_INT 11
6585: PUSH
6586: LD_INT 1
6588: PUSH
6589: LD_INT 2
6591: PUSH
6592: LD_INT 24
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: PUSH
6601: LD_INT 11
6603: PUSH
6604: LD_INT 1
6606: PUSH
6607: LD_INT 2
6609: PUSH
6610: LD_INT 24
6612: PUSH
6613: EMPTY
6614: LIST
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_INT 11
6621: PUSH
6622: LD_INT 1
6624: PUSH
6625: LD_INT 2
6627: PUSH
6628: LD_INT 24
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_INT 11
6639: PUSH
6640: LD_INT 1
6642: PUSH
6643: LD_INT 2
6645: PUSH
6646: LD_INT 24
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: ST_TO_ADDR
6661: GO 6765
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6663: LD_ADDR_VAR 0 8
6667: PUSH
6668: LD_INT 14
6670: PUSH
6671: LD_INT 1
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: LD_INT 28
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 14
6688: PUSH
6689: LD_INT 1
6691: PUSH
6692: LD_INT 2
6694: PUSH
6695: LD_INT 25
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 14
6706: PUSH
6707: LD_INT 1
6709: PUSH
6710: LD_INT 2
6712: PUSH
6713: LD_INT 28
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: PUSH
6722: LD_INT 14
6724: PUSH
6725: LD_INT 1
6727: PUSH
6728: LD_INT 2
6730: PUSH
6731: LD_INT 29
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: LIST
6738: LIST
6739: PUSH
6740: LD_INT 11
6742: PUSH
6743: LD_INT 1
6745: PUSH
6746: LD_INT 2
6748: PUSH
6749: LD_INT 24
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: LIST
6756: LIST
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: ST_TO_ADDR
// if w mod 3 = 0 then
6765: LD_VAR 0 7
6769: PUSH
6770: LD_INT 3
6772: MOD
6773: PUSH
6774: LD_INT 0
6776: EQUAL
6777: IFFALSE 6853
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6779: LD_ADDR_VAR 0 8
6783: PUSH
6784: LD_VAR 0 8
6788: PPUSH
6789: LD_INT 1
6791: PUSH
6792: LD_VAR 0 8
6796: PUSH
6797: LD_VAR 0 1
6801: ARRAY
6802: PUSH
6803: LD_INT 1
6805: PLUS
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PPUSH
6811: LD_INT 14
6813: PUSH
6814: LD_INT 1
6816: PUSH
6817: LD_INT 2
6819: PUSH
6820: LD_INT 25
6822: PUSH
6823: LD_INT 28
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: PUSH
6830: LD_INT 1
6832: PPUSH
6833: LD_INT 2
6835: PPUSH
6836: CALL_OW 12
6840: ARRAY
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: LIST
6846: LIST
6847: PPUSH
6848: CALL 54503 0 3
6852: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6853: LD_INT 1
6855: PPUSH
6856: LD_VAR 0 8
6860: PPUSH
6861: CALL 40874 0 2
// if GetSide ( ar_dep_w ) = 2 then
6865: LD_INT 45
6867: PPUSH
6868: CALL_OW 255
6872: PUSH
6873: LD_INT 2
6875: EQUAL
6876: IFFALSE 6961
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6878: LD_ADDR_VAR 0 8
6882: PUSH
6883: LD_INT 14
6885: PUSH
6886: LD_INT 1
6888: PUSH
6889: LD_INT 2
6891: PUSH
6892: LD_INT 28
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 14
6903: PUSH
6904: LD_INT 1
6906: PUSH
6907: LD_INT 2
6909: PUSH
6910: LD_INT 27
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 14
6921: PUSH
6922: LD_INT 1
6924: PUSH
6925: LD_INT 2
6927: PUSH
6928: LD_INT 27
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: LIST
6941: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6942: LD_INT 2
6944: PPUSH
6945: LD_VAR 0 8
6949: PPUSH
6950: CALL 40874 0 2
// wait ( 0 0$50 ) ;
6954: LD_INT 1750
6956: PPUSH
6957: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6961: LD_INT 35
6963: PPUSH
6964: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6968: LD_EXP 69
6972: PUSH
6973: LD_INT 1
6975: ARRAY
6976: PPUSH
6977: LD_INT 3
6979: PUSH
6980: LD_INT 34
6982: PUSH
6983: LD_INT 32
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PPUSH
6994: CALL_OW 72
6998: PUSH
6999: LD_INT 4
7001: GREATEREQUAL
7002: IFFALSE 6961
// wait ( 0 0$10 ) ;
7004: LD_INT 350
7006: PPUSH
7007: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7011: LD_ADDR_VAR 0 3
7015: PUSH
7016: LD_EXP 69
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PPUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 34
7030: PUSH
7031: LD_INT 32
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: PPUSH
7042: CALL_OW 72
7046: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7047: LD_INT 100
7049: PPUSH
7050: CALL_OW 13
7054: PUSH
7055: LD_INT 50
7057: LESS
7058: IFFALSE 7091
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7060: LD_ADDR_VAR 0 5
7064: PUSH
7065: LD_INT 55
7067: PUSH
7068: LD_INT 7
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: LD_INT 75
7077: PUSH
7078: LD_INT 90
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: ST_TO_ADDR
7089: GO 7120
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7091: LD_ADDR_VAR 0 5
7095: PUSH
7096: LD_INT 128
7098: PUSH
7099: LD_INT 94
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: PUSH
7106: LD_INT 180
7108: PUSH
7109: LD_INT 135
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: ST_TO_ADDR
// if w mod 4 = 0 then
7120: LD_VAR 0 7
7124: PUSH
7125: LD_INT 4
7127: MOD
7128: PUSH
7129: LD_INT 0
7131: EQUAL
7132: IFFALSE 7163
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7134: LD_ADDR_VAR 0 5
7138: PUSH
7139: LD_INT 91
7141: PUSH
7142: LD_INT 58
7144: PUSH
7145: EMPTY
7146: LIST
7147: LIST
7148: PUSH
7149: LD_INT 117
7151: PUSH
7152: LD_INT 107
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
7163: LD_INT 1
7165: PPUSH
7166: LD_VAR 0 3
7170: PPUSH
7171: LD_VAR 0 5
7175: PPUSH
7176: LD_VAR 0 6
7180: PPUSH
7181: CALL 41107 0 4
// if mc_vehicles [ 2 ] then
7185: LD_EXP 69
7189: PUSH
7190: LD_INT 2
7192: ARRAY
7193: IFFALSE 7229
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7195: LD_INT 2
7197: PPUSH
7198: LD_EXP 69
7202: PUSH
7203: LD_INT 2
7205: ARRAY
7206: PPUSH
7207: LD_INT 73
7209: PUSH
7210: LD_INT 115
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: EMPTY
7218: LIST
7219: PPUSH
7220: LD_VAR 0 6
7224: PPUSH
7225: CALL 41107 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7229: LD_INT 22050
7231: PPUSH
7232: LD_INT 28350
7234: PPUSH
7235: CALL_OW 12
7239: PPUSH
7240: CALL_OW 67
// w := w + 1 ;
7244: LD_ADDR_VAR 0 7
7248: PUSH
7249: LD_VAR 0 7
7253: PUSH
7254: LD_INT 1
7256: PLUS
7257: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7258: LD_INT 94
7260: PPUSH
7261: CALL_OW 301
7265: PUSH
7266: LD_EXP 50
7270: PUSH
7271: LD_INT 1
7273: ARRAY
7274: PPUSH
7275: LD_INT 30
7277: PUSH
7278: LD_INT 3
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 72
7289: NOT
7290: OR
7291: IFFALSE 6557
// end ;
7293: PPOPN 8
7295: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7296: LD_INT 204
7298: IFFALSE 7764
7300: GO 7302
7302: DISABLE
7303: LD_INT 0
7305: PPUSH
7306: PPUSH
7307: PPUSH
7308: PPUSH
// begin enable ;
7309: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7310: LD_INT 35
7312: PPUSH
7313: LD_INT 1190
7315: PPUSH
7316: CALL_OW 12
7320: PPUSH
7321: CALL_OW 67
// tmp := [ ] ;
7325: LD_ADDR_VAR 0 2
7329: PUSH
7330: EMPTY
7331: ST_TO_ADDR
// uc_side := 8 ;
7332: LD_ADDR_OWVAR 20
7336: PUSH
7337: LD_INT 8
7339: ST_TO_ADDR
// uc_nation := 2 ;
7340: LD_ADDR_OWVAR 21
7344: PUSH
7345: LD_INT 2
7347: ST_TO_ADDR
// InitHc ;
7348: CALL_OW 19
// for i = 1 to 3 do
7352: LD_ADDR_VAR 0 1
7356: PUSH
7357: DOUBLE
7358: LD_INT 1
7360: DEC
7361: ST_TO_ADDR
7362: LD_INT 3
7364: PUSH
7365: FOR_TO
7366: IFFALSE 7493
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7368: LD_INT 13
7370: PUSH
7371: LD_INT 14
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: PUSH
7378: LD_INT 1
7380: PPUSH
7381: LD_INT 2
7383: PPUSH
7384: CALL_OW 12
7388: ARRAY
7389: PPUSH
7390: LD_INT 3
7392: PPUSH
7393: LD_INT 5
7395: PPUSH
7396: LD_INT 27
7398: PUSH
7399: LD_INT 28
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 1
7408: PPUSH
7409: LD_INT 2
7411: PPUSH
7412: CALL_OW 12
7416: ARRAY
7417: PPUSH
7418: LD_INT 100
7420: PPUSH
7421: CALL 54381 0 5
// un := CreateVehicle ;
7425: LD_ADDR_VAR 0 3
7429: PUSH
7430: CALL_OW 45
7434: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7435: LD_VAR 0 3
7439: PPUSH
7440: LD_INT 4
7442: PPUSH
7443: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7447: LD_VAR 0 3
7451: PPUSH
7452: LD_INT 15
7454: PPUSH
7455: LD_INT 0
7457: PPUSH
7458: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7462: LD_ADDR_VAR 0 2
7466: PUSH
7467: LD_VAR 0 2
7471: PPUSH
7472: LD_VAR 0 2
7476: PUSH
7477: LD_INT 1
7479: PLUS
7480: PPUSH
7481: LD_VAR 0 3
7485: PPUSH
7486: CALL_OW 1
7490: ST_TO_ADDR
// end ;
7491: GO 7365
7493: POP
7494: POP
// for i = 1 to 4 do
7495: LD_ADDR_VAR 0 1
7499: PUSH
7500: DOUBLE
7501: LD_INT 1
7503: DEC
7504: ST_TO_ADDR
7505: LD_INT 4
7507: PUSH
7508: FOR_TO
7509: IFFALSE 7580
// begin PrepareHuman ( false , 1 , 6 ) ;
7511: LD_INT 0
7513: PPUSH
7514: LD_INT 1
7516: PPUSH
7517: LD_INT 6
7519: PPUSH
7520: CALL_OW 380
// un := CreateHuman ;
7524: LD_ADDR_VAR 0 3
7528: PUSH
7529: CALL_OW 44
7533: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7534: LD_VAR 0 3
7538: PPUSH
7539: LD_INT 15
7541: PPUSH
7542: LD_INT 0
7544: PPUSH
7545: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7549: LD_ADDR_VAR 0 2
7553: PUSH
7554: LD_VAR 0 2
7558: PPUSH
7559: LD_VAR 0 2
7563: PUSH
7564: LD_INT 1
7566: PLUS
7567: PPUSH
7568: LD_VAR 0 3
7572: PPUSH
7573: CALL_OW 1
7577: ST_TO_ADDR
// end ;
7578: GO 7508
7580: POP
7581: POP
// wait ( 0 0$3 ) ;
7582: LD_INT 105
7584: PPUSH
7585: CALL_OW 67
// for i in tmp do
7589: LD_ADDR_VAR 0 1
7593: PUSH
7594: LD_VAR 0 2
7598: PUSH
7599: FOR_IN
7600: IFFALSE 7668
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7602: LD_VAR 0 1
7606: PPUSH
7607: CALL_OW 257
7611: PUSH
7612: LD_INT 1
7614: EQUAL
7615: PUSH
7616: LD_VAR 0 1
7620: PPUSH
7621: CALL_OW 247
7625: PUSH
7626: LD_INT 2
7628: EQUAL
7629: OR
7630: IFFALSE 7666
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7632: LD_VAR 0 1
7636: PPUSH
7637: LD_INT 81
7639: PUSH
7640: LD_INT 8
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PPUSH
7647: CALL_OW 69
7651: PPUSH
7652: LD_VAR 0 1
7656: PPUSH
7657: CALL_OW 74
7661: PPUSH
7662: CALL_OW 115
7666: GO 7599
7668: POP
7669: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7670: LD_VAR 0 2
7674: PPUSH
7675: LD_INT 210
7677: PPUSH
7678: LD_INT 178
7680: PPUSH
7681: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7685: LD_ADDR_VAR 0 4
7689: PUSH
7690: LD_INT 10
7692: PPUSH
7693: LD_INT 22
7695: PUSH
7696: LD_INT 8
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PPUSH
7703: CALL_OW 70
7707: ST_TO_ADDR
// if x then
7708: LD_VAR 0 4
7712: IFFALSE 7740
// for i in x do
7714: LD_ADDR_VAR 0 1
7718: PUSH
7719: LD_VAR 0 4
7723: PUSH
7724: FOR_IN
7725: IFFALSE 7738
// RemoveUnit ( i ) ;
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 64
7736: GO 7724
7738: POP
7739: POP
// wait ( 0 0$1 ) ;
7740: LD_INT 35
7742: PPUSH
7743: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7747: LD_INT 22
7749: PUSH
7750: LD_INT 8
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: PPUSH
7757: CALL_OW 69
7761: NOT
7762: IFFALSE 7670
// end ;
7764: PPOPN 4
7766: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7767: LD_INT 22
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: LD_INT 34
7779: PUSH
7780: LD_INT 31
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: PUSH
7787: LD_INT 3
7789: PUSH
7790: LD_INT 24
7792: PUSH
7793: LD_INT 1000
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: PUSH
7804: EMPTY
7805: LIST
7806: LIST
7807: LIST
7808: PPUSH
7809: CALL_OW 69
7813: IFFALSE 7916
7815: GO 7817
7817: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
7818: LD_INT 45
7820: PPUSH
7821: CALL_OW 302
7825: PUSH
7826: LD_INT 45
7828: PPUSH
7829: CALL_OW 255
7833: AND
7834: IFFALSE 7877
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
7836: LD_INT 22
7838: PUSH
7839: LD_INT 2
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 34
7848: PUSH
7849: LD_INT 31
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL_OW 69
7864: PPUSH
7865: LD_INT 18
7867: PPUSH
7868: LD_INT 8
7870: PPUSH
7871: CALL_OW 111
7875: GO 7916
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7877: LD_INT 22
7879: PUSH
7880: LD_INT 2
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PUSH
7887: LD_INT 34
7889: PUSH
7890: LD_INT 31
7892: PUSH
7893: EMPTY
7894: LIST
7895: LIST
7896: PUSH
7897: EMPTY
7898: LIST
7899: LIST
7900: PPUSH
7901: CALL_OW 69
7905: PPUSH
7906: LD_INT 106
7908: PPUSH
7909: LD_INT 14
7911: PPUSH
7912: CALL_OW 111
// end ; end_of_file
7916: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7917: LD_INT 0
7919: PPUSH
7920: PPUSH
7921: PPUSH
7922: PPUSH
7923: PPUSH
7924: PPUSH
// InGameOn ;
7925: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7929: LD_EXP 21
7933: PPUSH
7934: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7938: LD_INT 2
7940: PPUSH
7941: LD_INT 1
7943: PPUSH
7944: LD_INT 1
7946: PPUSH
7947: LD_INT 1
7949: PPUSH
7950: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7954: LD_ADDR_VAR 0 2
7958: PUSH
7959: LD_INT 22
7961: PUSH
7962: LD_INT 1
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: PUSH
7969: LD_INT 25
7971: PUSH
7972: LD_INT 1
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PPUSH
7983: CALL_OW 69
7987: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7988: LD_ADDR_VAR 0 4
7992: PUSH
7993: LD_INT 22
7995: PUSH
7996: LD_INT 1
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: LD_INT 34
8005: PUSH
8006: LD_INT 11
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PPUSH
8017: CALL_OW 69
8021: PUSH
8022: LD_INT 1
8024: ARRAY
8025: ST_TO_ADDR
// for i = 1 to tmp do
8026: LD_ADDR_VAR 0 6
8030: PUSH
8031: DOUBLE
8032: LD_INT 1
8034: DEC
8035: ST_TO_ADDR
8036: LD_VAR 0 2
8040: PUSH
8041: FOR_TO
8042: IFFALSE 8089
// begin if i = 5 then
8044: LD_VAR 0 6
8048: PUSH
8049: LD_INT 5
8051: EQUAL
8052: IFFALSE 8056
// break ;
8054: GO 8089
// sols := Replace ( sols , i , tmp [ i ] ) ;
8056: LD_ADDR_VAR 0 5
8060: PUSH
8061: LD_VAR 0 5
8065: PPUSH
8066: LD_VAR 0 6
8070: PPUSH
8071: LD_VAR 0 2
8075: PUSH
8076: LD_VAR 0 6
8080: ARRAY
8081: PPUSH
8082: CALL_OW 1
8086: ST_TO_ADDR
// end ;
8087: GO 8041
8089: POP
8090: POP
// tmp := ar_force_tmp ;
8091: LD_ADDR_VAR 0 2
8095: PUSH
8096: LD_EXP 40
8100: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8101: LD_VAR 0 2
8105: PUSH
8106: LD_INT 1
8108: ARRAY
8109: PPUSH
8110: LD_INT 108
8112: PPUSH
8113: LD_INT 139
8115: PPUSH
8116: LD_INT 0
8118: PPUSH
8119: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8123: LD_VAR 0 2
8127: PUSH
8128: LD_INT 1
8130: ARRAY
8131: PPUSH
8132: LD_EXP 21
8136: PPUSH
8137: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8141: LD_VAR 0 2
8145: PUSH
8146: LD_INT 2
8148: ARRAY
8149: PPUSH
8150: LD_INT 114
8152: PPUSH
8153: LD_INT 132
8155: PPUSH
8156: LD_INT 0
8158: PPUSH
8159: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8163: LD_VAR 0 2
8167: PUSH
8168: LD_INT 3
8170: ARRAY
8171: PPUSH
8172: LD_INT 115
8174: PPUSH
8175: LD_INT 132
8177: PPUSH
8178: LD_INT 0
8180: PPUSH
8181: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8185: LD_VAR 0 2
8189: PUSH
8190: LD_INT 2
8192: ARRAY
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 3
8201: ARRAY
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: PPUSH
8207: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8211: LD_VAR 0 4
8215: PPUSH
8216: LD_INT 83
8218: PPUSH
8219: LD_INT 123
8221: PPUSH
8222: CALL_OW 111
// Wait ( 0 0$01 ) ;
8226: LD_INT 35
8228: PPUSH
8229: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8233: LD_INT 90
8235: PPUSH
8236: LD_INT 144
8238: PPUSH
8239: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8243: LD_VAR 0 5
8247: PPUSH
8248: LD_INT 88
8250: PPUSH
8251: LD_INT 129
8253: PPUSH
8254: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8258: LD_ADDR_VAR 0 3
8262: PUSH
8263: LD_INT 92
8265: PUSH
8266: LD_INT 131
8268: PUSH
8269: EMPTY
8270: LIST
8271: LIST
8272: PUSH
8273: LD_INT 88
8275: PUSH
8276: LD_INT 127
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PUSH
8283: LD_INT 91
8285: PUSH
8286: LD_INT 132
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: PUSH
8293: LD_INT 92
8295: PUSH
8296: LD_INT 134
8298: PUSH
8299: EMPTY
8300: LIST
8301: LIST
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: ST_TO_ADDR
// for i = 1 to sols do
8309: LD_ADDR_VAR 0 6
8313: PUSH
8314: DOUBLE
8315: LD_INT 1
8317: DEC
8318: ST_TO_ADDR
8319: LD_VAR 0 5
8323: PUSH
8324: FOR_TO
8325: IFFALSE 8398
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8327: LD_VAR 0 5
8331: PUSH
8332: LD_VAR 0 6
8336: ARRAY
8337: PPUSH
8338: LD_VAR 0 3
8342: PUSH
8343: LD_VAR 0 6
8347: ARRAY
8348: PUSH
8349: LD_INT 1
8351: ARRAY
8352: PPUSH
8353: LD_VAR 0 3
8357: PUSH
8358: LD_VAR 0 6
8362: ARRAY
8363: PUSH
8364: LD_INT 2
8366: ARRAY
8367: PPUSH
8368: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8372: LD_VAR 0 5
8376: PUSH
8377: LD_VAR 0 6
8381: ARRAY
8382: PPUSH
8383: CALL_OW 197
// AddComHold ( sols ) ;
8387: LD_VAR 0 5
8391: PPUSH
8392: CALL_OW 200
// end ;
8396: GO 8324
8398: POP
8399: POP
// repeat wait ( 0 0$1 ) ;
8400: LD_INT 35
8402: PPUSH
8403: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8407: LD_VAR 0 5
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: PPUSH
8416: LD_INT 92
8418: PPUSH
8419: LD_INT 131
8421: PPUSH
8422: CALL_OW 297
8426: PUSH
8427: LD_INT 4
8429: LESS
8430: IFFALSE 8400
// CenterOnXY ( 96 , 139 ) ;
8432: LD_INT 96
8434: PPUSH
8435: LD_INT 139
8437: PPUSH
8438: CALL_OW 84
// wait ( 0 0$3 ) ;
8442: LD_INT 105
8444: PPUSH
8445: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8449: LD_INT 111
8451: PPUSH
8452: LD_INT 135
8454: PPUSH
8455: LD_INT 1
8457: PPUSH
8458: LD_INT 25
8460: NEG
8461: PPUSH
8462: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 2
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 2
8479: PUSH
8480: LD_INT 1
8482: ARRAY
8483: PPUSH
8484: CALL_OW 250
8488: PUSH
8489: LD_INT 3
8491: PLUS
8492: PPUSH
8493: LD_VAR 0 2
8497: PUSH
8498: LD_INT 1
8500: ARRAY
8501: PPUSH
8502: CALL_OW 251
8506: PPUSH
8507: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8511: LD_VAR 0 2
8515: PUSH
8516: LD_INT 3
8518: ARRAY
8519: PPUSH
8520: LD_INT 7
8522: PPUSH
8523: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8527: LD_VAR 0 2
8531: PUSH
8532: LD_INT 2
8534: ARRAY
8535: PPUSH
8536: LD_VAR 0 2
8540: PUSH
8541: LD_INT 1
8543: ARRAY
8544: PPUSH
8545: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8549: LD_INT 35
8551: PPUSH
8552: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8556: LD_VAR 0 2
8560: PUSH
8561: LD_INT 1
8563: ARRAY
8564: PPUSH
8565: LD_VAR 0 2
8569: PUSH
8570: LD_INT 2
8572: ARRAY
8573: PPUSH
8574: CALL_OW 296
8578: PUSH
8579: LD_INT 5
8581: LESS
8582: IFFALSE 8549
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8584: LD_VAR 0 2
8588: PUSH
8589: LD_INT 1
8591: ARRAY
8592: PPUSH
8593: LD_VAR 0 2
8597: PUSH
8598: LD_INT 2
8600: ARRAY
8601: PPUSH
8602: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8606: LD_VAR 0 2
8610: PUSH
8611: LD_INT 1
8613: ARRAY
8614: PPUSH
8615: LD_STRING D1a-Merc1-1
8617: PPUSH
8618: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8622: LD_VAR 0 2
8626: PUSH
8627: LD_INT 2
8629: ARRAY
8630: PPUSH
8631: LD_STRING D1a-FMerc2-1
8633: PPUSH
8634: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8638: LD_VAR 0 2
8642: PUSH
8643: LD_INT 2
8645: ARRAY
8646: PPUSH
8647: LD_VAR 0 2
8651: PUSH
8652: LD_INT 1
8654: ARRAY
8655: PPUSH
8656: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8660: LD_VAR 0 2
8664: PUSH
8665: LD_INT 1
8667: ARRAY
8668: PPUSH
8669: LD_INT 500
8671: PPUSH
8672: CALL_OW 234
// wait ( 0 0$2 ) ;
8676: LD_INT 70
8678: PPUSH
8679: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8683: LD_VAR 0 2
8687: PUSH
8688: LD_INT 1
8690: ARRAY
8691: PPUSH
8692: LD_INT 2
8694: PPUSH
8695: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8699: LD_INT 10
8701: PPUSH
8702: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8706: LD_VAR 0 2
8710: PUSH
8711: LD_INT 1
8713: ARRAY
8714: PPUSH
8715: LD_STRING D1a-Merc1-2
8717: PPUSH
8718: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8722: LD_INT 7
8724: PPUSH
8725: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8729: LD_VAR 0 2
8733: PUSH
8734: LD_INT 1
8736: ARRAY
8737: PPUSH
8738: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8742: LD_VAR 0 2
8746: PUSH
8747: LD_INT 2
8749: ARRAY
8750: PPUSH
8751: LD_INT 10
8753: PPUSH
8754: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8758: LD_VAR 0 2
8762: PUSH
8763: LD_INT 2
8765: ARRAY
8766: PPUSH
8767: LD_STRING D1a-FMerc2-2
8769: PPUSH
8770: CALL_OW 88
// wait ( 0 0$1 ) ;
8774: LD_INT 35
8776: PPUSH
8777: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8781: LD_INT 7
8783: PPUSH
8784: CALL_OW 85
// wait ( 0 0$2 ) ;
8788: LD_INT 70
8790: PPUSH
8791: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8795: LD_EXP 44
8799: PPUSH
8800: LD_STRING D1a-Saliba-1
8802: PPUSH
8803: CALL_OW 91
// KillUnit ( Saliba ) ;
8807: LD_EXP 44
8811: PPUSH
8812: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8816: LD_VAR 0 2
8820: PUSH
8821: LD_INT 3
8823: ARRAY
8824: PPUSH
8825: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8829: LD_EXP 21
8833: PPUSH
8834: CALL_OW 85
// wait ( 0 0$1 ) ;
8838: LD_INT 35
8840: PPUSH
8841: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8845: LD_VAR 0 5
8849: PPUSH
8850: LD_INT 88
8852: PPUSH
8853: LD_INT 141
8855: PPUSH
8856: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8860: LD_VAR 0 5
8864: PPUSH
8865: LD_INT 70
8867: PPUSH
8868: CALL_OW 202
// wait ( 0 0$2 ) ;
8872: LD_INT 70
8874: PPUSH
8875: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8879: LD_INT 2
8881: PPUSH
8882: LD_INT 1
8884: PPUSH
8885: LD_INT 2
8887: PPUSH
8888: LD_INT 1
8890: PPUSH
8891: CALL_OW 80
// InGameOff ;
8895: CALL_OW 9
// ComWalk ( sols ) ;
8899: LD_VAR 0 5
8903: PPUSH
8904: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8908: LD_STRING M1
8910: PPUSH
8911: CALL_OW 337
// game_speed := 4 ;
8915: LD_ADDR_OWVAR 65
8919: PUSH
8920: LD_INT 4
8922: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8923: LD_INT 111
8925: PPUSH
8926: LD_INT 135
8928: PPUSH
8929: LD_INT 1
8931: PPUSH
8932: CALL_OW 331
// SaveForQuickRestart ;
8936: CALL_OW 22
// ar_run := true ;
8940: LD_ADDR_EXP 5
8944: PUSH
8945: LD_INT 1
8947: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8948: LD_INT 35
8950: PPUSH
8951: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8955: LD_INT 22
8957: PUSH
8958: LD_INT 1
8960: PUSH
8961: EMPTY
8962: LIST
8963: LIST
8964: PUSH
8965: LD_INT 91
8967: PUSH
8968: LD_INT 7
8970: PUSH
8971: LD_INT 10
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: LIST
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PPUSH
8983: CALL_OW 69
8987: PUSH
8988: LD_INT 7
8990: PPUSH
8991: CALL_OW 256
8995: PUSH
8996: LD_INT 999
8998: LESS
8999: OR
9000: IFFALSE 8948
// if GetSide ( ar_dep_s ) = 2 then
9002: LD_INT 7
9004: PPUSH
9005: CALL_OW 255
9009: PUSH
9010: LD_INT 2
9012: EQUAL
9013: IFFALSE 9025
// SetSide ( ar_dep_s , 1 ) ;
9015: LD_INT 7
9017: PPUSH
9018: LD_INT 1
9020: PPUSH
9021: CALL_OW 235
// end ;
9025: LD_VAR 0 1
9029: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9030: LD_EXP 5
9034: IFFALSE 9394
9036: GO 9038
9038: DISABLE
9039: LD_INT 0
9041: PPUSH
9042: PPUSH
9043: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9044: LD_ADDR_VAR 0 2
9048: PUSH
9049: LD_EXP 40
9053: PUSH
9054: LD_EXP 36
9058: PPUSH
9059: LD_INT 2
9061: PUSH
9062: LD_INT 21
9064: PUSH
9065: LD_INT 2
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: LD_INT 21
9074: PUSH
9075: LD_INT 1
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: LIST
9086: PPUSH
9087: CALL_OW 72
9091: ADD
9092: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9093: LD_VAR 0 2
9097: PPUSH
9098: LD_INT 5
9100: PPUSH
9101: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9105: LD_INT 5
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 343
// k := 1 ;
9115: LD_ADDR_VAR 0 3
9119: PUSH
9120: LD_INT 1
9122: ST_TO_ADDR
// for i in tmp do
9123: LD_ADDR_VAR 0 1
9127: PUSH
9128: LD_VAR 0 2
9132: PUSH
9133: FOR_IN
9134: IFFALSE 9219
// begin if IsInUnit ( i ) then
9136: LD_VAR 0 1
9140: PPUSH
9141: CALL_OW 310
9145: IFFALSE 9156
// ComExitBuilding ( i ) ;
9147: LD_VAR 0 1
9151: PPUSH
9152: CALL_OW 122
// if GetClass ( i ) = 3 then
9156: LD_VAR 0 1
9160: PPUSH
9161: CALL_OW 257
9165: PUSH
9166: LD_INT 3
9168: EQUAL
9169: IFFALSE 9205
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9171: LD_VAR 0 1
9175: PPUSH
9176: LD_EXP 41
9180: PUSH
9181: LD_VAR 0 3
9185: ARRAY
9186: PPUSH
9187: CALL_OW 180
// k := k + 1 ;
9191: LD_ADDR_VAR 0 3
9195: PUSH
9196: LD_VAR 0 3
9200: PUSH
9201: LD_INT 1
9203: PLUS
9204: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9205: LD_VAR 0 1
9209: PPUSH
9210: LD_INT 10
9212: PPUSH
9213: CALL_OW 173
// end ;
9217: GO 9133
9219: POP
9220: POP
// ar_patrol := true ;
9221: LD_ADDR_EXP 7
9225: PUSH
9226: LD_INT 1
9228: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9229: LD_INT 10
9231: PPUSH
9232: CALL_OW 67
// for i in tmp do
9236: LD_ADDR_VAR 0 1
9240: PUSH
9241: LD_VAR 0 2
9245: PUSH
9246: FOR_IN
9247: IFFALSE 9275
// if not HasTask ( i ) then
9249: LD_VAR 0 1
9253: PPUSH
9254: CALL_OW 314
9258: NOT
9259: IFFALSE 9273
// ComMoveToArea ( i , escape_area ) ;
9261: LD_VAR 0 1
9265: PPUSH
9266: LD_INT 10
9268: PPUSH
9269: CALL_OW 113
9273: GO 9246
9275: POP
9276: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9277: LD_ADDR_VAR 0 3
9281: PUSH
9282: LD_VAR 0 2
9286: PPUSH
9287: LD_INT 95
9289: PUSH
9290: LD_INT 10
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: PPUSH
9297: CALL_OW 72
9301: ST_TO_ADDR
// if k then
9302: LD_VAR 0 3
9306: IFFALSE 9375
// for i in k do
9308: LD_ADDR_VAR 0 1
9312: PUSH
9313: LD_VAR 0 3
9317: PUSH
9318: FOR_IN
9319: IFFALSE 9373
// begin if IsInUnit ( i ) then
9321: LD_VAR 0 1
9325: PPUSH
9326: CALL_OW 310
9330: IFFALSE 9346
// RemoveUnit ( IsInUnit ( i ) ) ;
9332: LD_VAR 0 1
9336: PPUSH
9337: CALL_OW 310
9341: PPUSH
9342: CALL_OW 64
// RemoveUnit ( i ) ;
9346: LD_VAR 0 1
9350: PPUSH
9351: CALL_OW 64
// tmp := tmp diff i ;
9355: LD_ADDR_VAR 0 2
9359: PUSH
9360: LD_VAR 0 2
9364: PUSH
9365: LD_VAR 0 1
9369: DIFF
9370: ST_TO_ADDR
// end ;
9371: GO 9318
9373: POP
9374: POP
// until tmp = [ ] ;
9375: LD_VAR 0 2
9379: PUSH
9380: EMPTY
9381: EQUAL
9382: IFFALSE 9229
// ChangeSideFog ( 5 , 5 ) ;
9384: LD_INT 5
9386: PPUSH
9387: LD_INT 5
9389: PPUSH
9390: CALL_OW 343
// end ;
9394: PPOPN 3
9396: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9397: LD_EXP 7
9401: IFFALSE 9691
9403: GO 9405
9405: DISABLE
9406: LD_INT 0
9408: PPUSH
9409: PPUSH
9410: PPUSH
// begin uc_side := 2 ;
9411: LD_ADDR_OWVAR 20
9415: PUSH
9416: LD_INT 2
9418: ST_TO_ADDR
// uc_nation := 2 ;
9419: LD_ADDR_OWVAR 21
9423: PUSH
9424: LD_INT 2
9426: ST_TO_ADDR
// InitHc ;
9427: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9431: LD_INT 1
9433: PPUSH
9434: LD_INT 1
9436: PPUSH
9437: LD_INT 6
9439: PPUSH
9440: CALL_OW 380
// un := CreateHuman ;
9444: LD_ADDR_VAR 0 2
9448: PUSH
9449: CALL_OW 44
9453: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9454: LD_INT 14
9456: PPUSH
9457: LD_INT 1
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 27
9465: PPUSH
9466: LD_INT 98
9468: PPUSH
9469: CALL 54381 0 5
// veh := CreateVehicle ;
9473: LD_ADDR_VAR 0 3
9477: PUSH
9478: CALL_OW 45
9482: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9483: LD_VAR 0 3
9487: PPUSH
9488: LD_INT 4
9490: PPUSH
9491: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9495: LD_VAR 0 3
9499: PPUSH
9500: LD_INT 179
9502: PPUSH
9503: LD_INT 135
9505: PPUSH
9506: LD_INT 0
9508: PPUSH
9509: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9513: LD_VAR 0 2
9517: PPUSH
9518: LD_VAR 0 3
9522: PPUSH
9523: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9527: LD_VAR 0 2
9531: PPUSH
9532: LD_INT 126
9534: PPUSH
9535: LD_INT 133
9537: PPUSH
9538: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9542: LD_INT 10
9544: PPUSH
9545: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9549: LD_INT 1
9551: PPUSH
9552: LD_VAR 0 3
9556: PPUSH
9557: CALL_OW 292
9561: PUSH
9562: LD_VAR 0 3
9566: PPUSH
9567: LD_INT 7
9569: PPUSH
9570: CALL_OW 296
9574: PUSH
9575: LD_INT 9
9577: LESS
9578: OR
9579: IFFALSE 9542
// ComHold ( veh ) ;
9581: LD_VAR 0 3
9585: PPUSH
9586: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: LD_STRING D2aa-Ar1-1
9597: PPUSH
9598: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9602: LD_VAR 0 2
9606: PPUSH
9607: LD_INT 177
9609: PPUSH
9610: LD_INT 96
9612: PPUSH
9613: CALL_OW 111
// AddComExitVehicle ( un ) ;
9617: LD_VAR 0 2
9621: PPUSH
9622: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9626: LD_INT 35
9628: PPUSH
9629: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9633: LD_VAR 0 2
9637: PPUSH
9638: LD_INT 204
9640: PPUSH
9641: CALL_OW 296
9645: PUSH
9646: LD_INT 15
9648: LESS
9649: IFFALSE 9626
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9651: LD_ADDR_EXP 50
9655: PUSH
9656: LD_EXP 50
9660: PPUSH
9661: LD_INT 3
9663: PUSH
9664: LD_EXP 50
9668: PUSH
9669: LD_INT 3
9671: ARRAY
9672: PUSH
9673: LD_INT 1
9675: PLUS
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: PPUSH
9681: LD_VAR 0 2
9685: PPUSH
9686: CALL 54503 0 3
9690: ST_TO_ADDR
// end ;
9691: PPOPN 3
9693: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9694: LD_INT 7
9696: PPUSH
9697: CALL_OW 255
9701: PUSH
9702: LD_INT 1
9704: EQUAL
9705: PUSH
9706: LD_INT 7
9708: PPUSH
9709: CALL_OW 301
9713: OR
9714: IFFALSE 12138
9716: GO 9718
9718: DISABLE
9719: LD_INT 0
9721: PPUSH
9722: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9723: LD_ADDR_VAR 0 1
9727: PUSH
9728: LD_EXP 36
9732: PPUSH
9733: LD_INT 21
9735: PUSH
9736: LD_INT 3
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: PPUSH
9743: CALL_OW 72
9747: PUSH
9748: FOR_IN
9749: IFFALSE 9765
// SetSide ( i , 1 ) ;
9751: LD_VAR 0 1
9755: PPUSH
9756: LD_INT 1
9758: PPUSH
9759: CALL_OW 235
9763: GO 9748
9765: POP
9766: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9767: LD_ADDR_VAR 0 2
9771: PUSH
9772: LD_INT 46
9774: PUSH
9775: LD_INT 41
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: PUSH
9782: LD_INT 50
9784: PUSH
9785: LD_INT 25
9787: PUSH
9788: EMPTY
9789: LIST
9790: LIST
9791: PUSH
9792: LD_INT 57
9794: PUSH
9795: LD_INT 75
9797: PUSH
9798: EMPTY
9799: LIST
9800: LIST
9801: PUSH
9802: LD_INT 75
9804: PUSH
9805: LD_INT 89
9807: PUSH
9808: EMPTY
9809: LIST
9810: LIST
9811: PUSH
9812: LD_INT 51
9814: PUSH
9815: LD_INT 45
9817: PUSH
9818: EMPTY
9819: LIST
9820: LIST
9821: PUSH
9822: LD_INT 95
9824: PUSH
9825: LD_INT 95
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: PUSH
9832: LD_INT 84
9834: PUSH
9835: LD_INT 77
9837: PUSH
9838: EMPTY
9839: LIST
9840: LIST
9841: PUSH
9842: LD_INT 101
9844: PUSH
9845: LD_INT 76
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: PUSH
9852: LD_INT 118
9854: PUSH
9855: LD_INT 81
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PUSH
9862: LD_INT 139
9864: PUSH
9865: LD_INT 97
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: PUSH
9872: LD_INT 129
9874: PUSH
9875: LD_INT 114
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: PUSH
9882: LD_INT 154
9884: PUSH
9885: LD_INT 111
9887: PUSH
9888: EMPTY
9889: LIST
9890: LIST
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: LIST
9905: ST_TO_ADDR
// base_captured := true ;
9906: LD_ADDR_EXP 6
9910: PUSH
9911: LD_INT 1
9913: ST_TO_ADDR
// DialogueOn ;
9914: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9918: LD_EXP 21
9922: PPUSH
9923: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9927: LD_EXP 21
9931: PPUSH
9932: LD_STRING D2-JMM-1
9934: PPUSH
9935: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9939: LD_EXP 30
9943: PPUSH
9944: LD_STRING D2-Pow-1
9946: PPUSH
9947: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9951: LD_EXP 21
9955: PPUSH
9956: LD_STRING D2-JMM-2
9958: PPUSH
9959: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9963: LD_EXP 30
9967: PPUSH
9968: LD_STRING D2-Pow-2
9970: PPUSH
9971: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9975: LD_EXP 21
9979: PPUSH
9980: LD_STRING D2-JMM-3
9982: PPUSH
9983: CALL_OW 88
// DialogueOff ;
9987: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9991: LD_STRING M2
9993: PPUSH
9994: CALL_OW 337
// Wait ( 0 0$2 ) ;
9998: LD_INT 70
10000: PPUSH
10001: CALL_OW 67
// if IsOk ( Gary ) then
10005: LD_EXP 32
10009: PPUSH
10010: CALL_OW 302
10014: IFFALSE 10028
// Say ( Gary , D2a-Gary-1 ) ;
10016: LD_EXP 32
10020: PPUSH
10021: LD_STRING D2a-Gary-1
10023: PPUSH
10024: CALL_OW 88
// if IsOk ( Bobby ) then
10028: LD_EXP 24
10032: PPUSH
10033: CALL_OW 302
10037: IFFALSE 10051
// Say ( Bobby , D2a-Bobby-1 ) ;
10039: LD_EXP 24
10043: PPUSH
10044: LD_STRING D2a-Bobby-1
10046: PPUSH
10047: CALL_OW 88
// if IsOk ( Cyrus ) then
10051: LD_EXP 25
10055: PPUSH
10056: CALL_OW 302
10060: IFFALSE 10074
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10062: LD_EXP 25
10066: PPUSH
10067: LD_STRING D2a-Cyrus-1
10069: PPUSH
10070: CALL_OW 88
// if IsOk ( Lisa ) then
10074: LD_EXP 22
10078: PPUSH
10079: CALL_OW 302
10083: IFFALSE 10097
// Say ( Lisa , D2a-Lisa-1 ) ;
10085: LD_EXP 22
10089: PPUSH
10090: LD_STRING D2a-Lisa-1
10092: PPUSH
10093: CALL_OW 88
// if IsOk ( Frank ) then
10097: LD_EXP 33
10101: PPUSH
10102: CALL_OW 302
10106: IFFALSE 10120
// Say ( Frank , D2a-Frank-1 ) ;
10108: LD_EXP 33
10112: PPUSH
10113: LD_STRING D2a-Frank-1
10115: PPUSH
10116: CALL_OW 88
// if IsOk ( Cornel ) then
10120: LD_EXP 31
10124: PPUSH
10125: CALL_OW 302
10129: IFFALSE 10143
// Say ( Cornel , D2a-Corn-1 ) ;
10131: LD_EXP 31
10135: PPUSH
10136: LD_STRING D2a-Corn-1
10138: PPUSH
10139: CALL_OW 88
// if IsOk ( Donaldson ) then
10143: LD_EXP 23
10147: PPUSH
10148: CALL_OW 302
10152: IFFALSE 10166
// Say ( Donaldson , D2a-Don-1 ) ;
10154: LD_EXP 23
10158: PPUSH
10159: LD_STRING D2a-Don-1
10161: PPUSH
10162: CALL_OW 88
// if IsOk ( Brown ) then
10166: LD_EXP 27
10170: PPUSH
10171: CALL_OW 302
10175: IFFALSE 10189
// Say ( Brown , D2a-Brown-1 ) ;
10177: LD_EXP 27
10181: PPUSH
10182: LD_STRING D2a-Brown-1
10184: PPUSH
10185: CALL_OW 88
// Wait ( 0 0$30 ) ;
10189: LD_INT 1050
10191: PPUSH
10192: CALL_OW 67
// if IsOk ( Frank ) then
10196: LD_EXP 33
10200: PPUSH
10201: CALL_OW 302
10205: IFFALSE 10471
// begin DialogueOn ;
10207: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10211: LD_EXP 21
10215: PUSH
10216: LD_EXP 33
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PPUSH
10225: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10229: LD_EXP 33
10233: PPUSH
10234: LD_STRING D3F-Frank-1
10236: PPUSH
10237: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10241: LD_EXP 21
10245: PPUSH
10246: LD_STRING D3F-JMM-1
10248: PPUSH
10249: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10253: LD_EXP 33
10257: PPUSH
10258: LD_STRING D3F-Frank-2
10260: PPUSH
10261: CALL_OW 88
// case Query ( QFrank ) of 1 :
10265: LD_STRING QFrank
10267: PPUSH
10268: CALL_OW 97
10272: PUSH
10273: LD_INT 1
10275: DOUBLE
10276: EQUAL
10277: IFTRUE 10281
10279: GO 10304
10281: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10282: LD_EXP 21
10286: PPUSH
10287: LD_STRING D3Fa-JMM-1
10289: PPUSH
10290: CALL_OW 88
// us_scout := 1 ;
10294: LD_ADDR_EXP 8
10298: PUSH
10299: LD_INT 1
10301: ST_TO_ADDR
// end ; 2 :
10302: GO 10467
10304: LD_INT 2
10306: DOUBLE
10307: EQUAL
10308: IFTRUE 10312
10310: GO 10434
10312: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10313: LD_EXP 21
10317: PPUSH
10318: LD_STRING D3Fb-JMM-1
10320: PPUSH
10321: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10325: LD_EXP 33
10329: PPUSH
10330: LD_STRING D3Fb-Frank-1
10332: PPUSH
10333: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10337: LD_STRING QFrank2
10339: PPUSH
10340: CALL_OW 97
10344: PUSH
10345: LD_INT 1
10347: DOUBLE
10348: EQUAL
10349: IFTRUE 10353
10351: GO 10400
10353: POP
// begin us_scout := 2 ;
10354: LD_ADDR_EXP 8
10358: PUSH
10359: LD_INT 2
10361: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10362: LD_EXP 21
10366: PPUSH
10367: LD_STRING D3Fba-JMM-1
10369: PPUSH
10370: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10374: LD_EXP 33
10378: PPUSH
10379: LD_STRING D3Fba-Frank-1
10381: PPUSH
10382: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10386: LD_EXP 21
10390: PPUSH
10391: LD_STRING D3Fba-JMM-2
10393: PPUSH
10394: CALL_OW 88
// end ; 2 :
10398: GO 10432
10400: LD_INT 2
10402: DOUBLE
10403: EQUAL
10404: IFTRUE 10408
10406: GO 10431
10408: POP
// begin us_scout := 0 ;
10409: LD_ADDR_EXP 8
10413: PUSH
10414: LD_INT 0
10416: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10417: LD_EXP 21
10421: PPUSH
10422: LD_STRING D3Fbb-JMM-1
10424: PPUSH
10425: CALL_OW 88
// end ; end ;
10429: GO 10432
10431: POP
// end ; 3 :
10432: GO 10467
10434: LD_INT 3
10436: DOUBLE
10437: EQUAL
10438: IFTRUE 10442
10440: GO 10466
10442: POP
// begin us_scout := - 1 ;
10443: LD_ADDR_EXP 8
10447: PUSH
10448: LD_INT 1
10450: NEG
10451: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10452: LD_EXP 21
10456: PPUSH
10457: LD_STRING D3Fc-JMM-1
10459: PPUSH
10460: CALL_OW 88
// end ; end ;
10464: GO 10467
10466: POP
// DialogueOff ;
10467: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10471: LD_EXP 8
10475: PUSH
10476: LD_INT 1
10478: NEG
10479: PUSH
10480: LD_INT 0
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: IN
10487: IFFALSE 10491
// exit ;
10489: GO 12138
// if us_scout in [ 1 , 2 ] then
10491: LD_EXP 8
10495: PUSH
10496: LD_INT 1
10498: PUSH
10499: LD_INT 2
10501: PUSH
10502: EMPTY
10503: LIST
10504: LIST
10505: IN
10506: IFFALSE 11205
// begin if IsInUnit ( Frank ) then
10508: LD_EXP 33
10512: PPUSH
10513: CALL_OW 310
10517: IFFALSE 10528
// ComExitBuilding ( Frank ) ;
10519: LD_EXP 33
10523: PPUSH
10524: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10528: LD_EXP 33
10532: PPUSH
10533: CALL_OW 311
10537: IFFALSE 10548
// ComExitVehicle ( Frank ) ;
10539: LD_EXP 33
10543: PPUSH
10544: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10548: LD_EXP 33
10552: PPUSH
10553: LD_INT 4
10555: PPUSH
10556: CALL_OW 235
// wait ( 0 0$1 ) ;
10560: LD_INT 35
10562: PPUSH
10563: CALL_OW 67
// if us_scout = 2 then
10567: LD_EXP 8
10571: PUSH
10572: LD_INT 2
10574: EQUAL
10575: IFFALSE 10943
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10577: LD_EXP 33
10581: PPUSH
10582: LD_INT 75
10584: PPUSH
10585: LD_INT 63
10587: PPUSH
10588: CALL_OW 111
// AddComHold ( Frank ) ;
10592: LD_EXP 33
10596: PPUSH
10597: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10601: LD_EXP 33
10605: PPUSH
10606: LD_INT 770
10608: PPUSH
10609: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10613: LD_EXP 33
10617: PPUSH
10618: LD_INT 100
10620: PPUSH
10621: LD_INT 75
10623: PPUSH
10624: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10628: LD_EXP 33
10632: PPUSH
10633: LD_INT 123
10635: PPUSH
10636: LD_INT 103
10638: PPUSH
10639: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10643: LD_EXP 33
10647: PPUSH
10648: LD_INT 138
10650: PPUSH
10651: LD_INT 108
10653: PPUSH
10654: CALL_OW 171
// AddComHold ( Frank ) ;
10658: LD_EXP 33
10662: PPUSH
10663: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10667: LD_INT 35
10669: PPUSH
10670: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10674: LD_EXP 33
10678: PPUSH
10679: LD_INT 138
10681: PPUSH
10682: LD_INT 108
10684: PPUSH
10685: CALL_OW 307
10689: IFFALSE 10667
// AddComMoveXY ( Frank , 125 , 132 ) ;
10691: LD_EXP 33
10695: PPUSH
10696: LD_INT 125
10698: PPUSH
10699: LD_INT 132
10701: PPUSH
10702: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10706: LD_INT 35
10708: PPUSH
10709: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10713: LD_INT 1
10715: PPUSH
10716: LD_EXP 33
10720: PPUSH
10721: CALL_OW 292
10725: PUSH
10726: LD_EXP 33
10730: PPUSH
10731: LD_INT 7
10733: PPUSH
10734: CALL_OW 296
10738: PUSH
10739: LD_INT 7
10741: LESS
10742: OR
10743: IFFALSE 10706
// DialogueOn ;
10745: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10749: LD_EXP 33
10753: PPUSH
10754: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10758: LD_INT 10
10760: PPUSH
10761: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10765: LD_EXP 21
10769: PPUSH
10770: LD_STRING D4Fa-JMM-1
10772: PPUSH
10773: CALL_OW 88
// for i in points do
10777: LD_ADDR_VAR 0 1
10781: PUSH
10782: LD_VAR 0 2
10786: PUSH
10787: FOR_IN
10788: IFFALSE 10846
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10790: LD_VAR 0 1
10794: PUSH
10795: LD_INT 1
10797: ARRAY
10798: PPUSH
10799: LD_VAR 0 1
10803: PUSH
10804: LD_INT 2
10806: ARRAY
10807: PPUSH
10808: LD_INT 1
10810: PPUSH
10811: LD_INT 20
10813: NEG
10814: PPUSH
10815: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10819: LD_VAR 0 1
10823: PUSH
10824: LD_INT 1
10826: ARRAY
10827: PPUSH
10828: LD_VAR 0 1
10832: PUSH
10833: LD_INT 2
10835: ARRAY
10836: PPUSH
10837: LD_INT 1
10839: PPUSH
10840: CALL_OW 331
// end ;
10844: GO 10787
10846: POP
10847: POP
// dwait ( 0 0$0.5 ) ;
10848: LD_INT 18
10850: PPUSH
10851: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10855: LD_INT 42
10857: PPUSH
10858: LD_INT 27
10860: PPUSH
10861: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10865: LD_EXP 33
10869: PPUSH
10870: LD_STRING D4Fa-Frank-1
10872: PPUSH
10873: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10877: LD_INT 18
10879: PPUSH
10880: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10884: LD_EXP 21
10888: PPUSH
10889: LD_STRING D4Fa-JMM-2
10891: PPUSH
10892: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10896: LD_INT 118
10898: PPUSH
10899: LD_INT 80
10901: PPUSH
10902: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10906: LD_EXP 33
10910: PPUSH
10911: LD_STRING D4Fa-Frank-2
10913: PPUSH
10914: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10918: LD_INT 10
10920: PPUSH
10921: CALL_OW 68
// DialogueOff ;
10925: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10929: LD_EXP 33
10933: PPUSH
10934: LD_INT 1
10936: PPUSH
10937: CALL_OW 235
// end else
10941: GO 11205
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 4
10948: PPUSH
10949: LD_INT 2
10951: PPUSH
10952: LD_INT 1
10954: PPUSH
10955: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_INT 75
10966: PPUSH
10967: LD_INT 63
10969: PPUSH
10970: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10974: LD_EXP 33
10978: PPUSH
10979: LD_INT 175
10981: PPUSH
10982: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10986: LD_EXP 33
10990: PPUSH
10991: LD_INT 102
10993: PPUSH
10994: LD_INT 76
10996: PPUSH
10997: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11001: LD_EXP 33
11005: PPUSH
11006: LD_INT 108
11008: PPUSH
11009: LD_INT 70
11011: PPUSH
11012: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11016: LD_INT 35
11018: PPUSH
11019: CALL_OW 67
// until See ( 2 , Frank ) ;
11023: LD_INT 2
11025: PPUSH
11026: LD_EXP 33
11030: PPUSH
11031: CALL_OW 292
11035: IFFALSE 11016
// ComMoveXY ( Frank , 112 , 118 ) ;
11037: LD_EXP 33
11041: PPUSH
11042: LD_INT 112
11044: PPUSH
11045: LD_INT 118
11047: PPUSH
11048: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11052: LD_EXP 33
11056: PPUSH
11057: CALL_OW 256
11061: PUSH
11062: LD_INT 750
11064: GREATEREQUAL
11065: IFFALSE 11079
// SetLives ( Frank , 700 ) ;
11067: LD_EXP 33
11071: PPUSH
11072: LD_INT 700
11074: PPUSH
11075: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11079: LD_INT 35
11081: PPUSH
11082: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11086: LD_INT 1
11088: PPUSH
11089: LD_EXP 33
11093: PPUSH
11094: CALL_OW 292
11098: PUSH
11099: LD_EXP 33
11103: PPUSH
11104: LD_INT 7
11106: PPUSH
11107: CALL_OW 296
11111: PUSH
11112: LD_INT 17
11114: LESS
11115: OR
11116: IFFALSE 11079
// DialogueOn ;
11118: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11122: LD_EXP 33
11126: PPUSH
11127: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11131: LD_EXP 33
11135: PPUSH
11136: LD_STRING D4Fb-Frank-1
11138: PPUSH
11139: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11143: LD_EXP 21
11147: PPUSH
11148: LD_STRING D4Fb-JMM-1
11150: PPUSH
11151: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11155: LD_INT 2
11157: PPUSH
11158: LD_STRING D4Fb-FSci1-1
11160: PPUSH
11161: CALL 16042 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11165: LD_EXP 33
11169: PPUSH
11170: LD_STRING D4Fb-Frank-2
11172: PPUSH
11173: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11177: LD_EXP 21
11181: PPUSH
11182: LD_STRING D4Fb-JMM-2
11184: PPUSH
11185: CALL_OW 88
// DialogueOff ;
11189: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11193: LD_EXP 33
11197: PPUSH
11198: LD_INT 1
11200: PPUSH
11201: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11205: LD_EXP 34
11209: PPUSH
11210: CALL_OW 302
11214: PUSH
11215: LD_EXP 33
11219: NOT
11220: AND
11221: IFFALSE 11369
// begin DialogueOn ;
11223: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11227: LD_EXP 21
11231: PUSH
11232: LD_EXP 34
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PPUSH
11241: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11245: LD_EXP 34
11249: PPUSH
11250: LD_STRING D3Y-Yam-1
11252: PPUSH
11253: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11257: LD_EXP 21
11261: PPUSH
11262: LD_STRING D3Y-JMM-1
11264: PPUSH
11265: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11269: LD_EXP 34
11273: PPUSH
11274: LD_STRING D3Y-Yam-2
11276: PPUSH
11277: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11281: LD_STRING QYamoko
11283: PPUSH
11284: CALL_OW 97
11288: PUSH
11289: LD_INT 1
11291: DOUBLE
11292: EQUAL
11293: IFTRUE 11297
11295: GO 11332
11297: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11298: LD_EXP 21
11302: PPUSH
11303: LD_STRING D3Ya-JMM-1
11305: PPUSH
11306: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11310: LD_EXP 34
11314: PPUSH
11315: LD_STRING D3Ya-Yam-1
11317: PPUSH
11318: CALL_OW 88
// us_scout := 1 ;
11322: LD_ADDR_EXP 8
11326: PUSH
11327: LD_INT 1
11329: ST_TO_ADDR
// end ; 2 :
11330: GO 11365
11332: LD_INT 2
11334: DOUBLE
11335: EQUAL
11336: IFTRUE 11340
11338: GO 11364
11340: POP
// begin us_scout := - 1 ;
11341: LD_ADDR_EXP 8
11345: PUSH
11346: LD_INT 1
11348: NEG
11349: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11350: LD_EXP 21
11354: PPUSH
11355: LD_STRING D3Yb-JMM-1
11357: PPUSH
11358: CALL_OW 88
// end ; end ;
11362: GO 11365
11364: POP
// DialogueOff ;
11365: CALL_OW 7
// end ; if Frank then
11369: LD_EXP 33
11373: IFFALSE 11377
// exit ;
11375: GO 12138
// if us_scout in [ - 1 , 0 ] then
11377: LD_EXP 8
11381: PUSH
11382: LD_INT 1
11384: NEG
11385: PUSH
11386: LD_INT 0
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: IN
11393: IFFALSE 11397
// exit ;
11395: GO 12138
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11397: LD_ADDR_EXP 8
11401: PUSH
11402: LD_INT 2
11404: PUSH
11405: LD_INT 2
11407: PUSH
11408: LD_INT 1
11410: PUSH
11411: EMPTY
11412: LIST
11413: LIST
11414: LIST
11415: PUSH
11416: LD_OWVAR 67
11420: ARRAY
11421: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11422: LD_EXP 8
11426: PUSH
11427: LD_INT 1
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: IN
11437: IFFALSE 12138
// begin if IsInUnit ( Kikuchi ) then
11439: LD_EXP 34
11443: PPUSH
11444: CALL_OW 310
11448: IFFALSE 11459
// ComExitBuilding ( Kikuchi ) ;
11450: LD_EXP 34
11454: PPUSH
11455: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11459: LD_EXP 34
11463: PPUSH
11464: CALL_OW 311
11468: IFFALSE 11479
// ComExitVehicle ( Kikuchi ) ;
11470: LD_EXP 34
11474: PPUSH
11475: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11479: LD_EXP 34
11483: PPUSH
11484: LD_INT 4
11486: PPUSH
11487: CALL_OW 235
// wait ( 0 0$1 ) ;
11491: LD_INT 35
11493: PPUSH
11494: CALL_OW 67
// if us_scout = 2 then
11498: LD_EXP 8
11502: PUSH
11503: LD_INT 2
11505: EQUAL
11506: IFFALSE 11886
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11508: LD_EXP 34
11512: PPUSH
11513: LD_INT 75
11515: PPUSH
11516: LD_INT 63
11518: PPUSH
11519: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11523: LD_EXP 34
11527: PPUSH
11528: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11532: LD_EXP 34
11536: PPUSH
11537: LD_INT 770
11539: PPUSH
11540: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11544: LD_EXP 34
11548: PPUSH
11549: LD_INT 100
11551: PPUSH
11552: LD_INT 75
11554: PPUSH
11555: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11559: LD_EXP 34
11563: PPUSH
11564: LD_INT 123
11566: PPUSH
11567: LD_INT 103
11569: PPUSH
11570: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11574: LD_EXP 34
11578: PPUSH
11579: LD_INT 138
11581: PPUSH
11582: LD_INT 108
11584: PPUSH
11585: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11589: LD_EXP 34
11593: PPUSH
11594: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11598: LD_INT 35
11600: PPUSH
11601: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11605: LD_EXP 34
11609: PPUSH
11610: LD_INT 138
11612: PPUSH
11613: LD_INT 108
11615: PPUSH
11616: CALL_OW 307
11620: IFFALSE 11598
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11622: LD_EXP 34
11626: PPUSH
11627: LD_INT 125
11629: PPUSH
11630: LD_INT 132
11632: PPUSH
11633: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11637: LD_INT 35
11639: PPUSH
11640: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11644: LD_INT 1
11646: PPUSH
11647: LD_EXP 34
11651: PPUSH
11652: CALL_OW 292
11656: PUSH
11657: LD_EXP 34
11661: PPUSH
11662: LD_INT 7
11664: PPUSH
11665: CALL_OW 296
11669: PUSH
11670: LD_INT 7
11672: LESS
11673: OR
11674: IFFALSE 11637
// DialogueOn ;
11676: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11680: LD_EXP 34
11684: PPUSH
11685: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11689: LD_INT 10
11691: PPUSH
11692: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11696: LD_EXP 34
11700: PPUSH
11701: LD_STRING D4Ya-Yam-1
11703: PPUSH
11704: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11708: LD_EXP 21
11712: PPUSH
11713: LD_STRING D4Ya-JMM-1
11715: PPUSH
11716: CALL_OW 88
// for i in points do
11720: LD_ADDR_VAR 0 1
11724: PUSH
11725: LD_VAR 0 2
11729: PUSH
11730: FOR_IN
11731: IFFALSE 11789
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11733: LD_VAR 0 1
11737: PUSH
11738: LD_INT 1
11740: ARRAY
11741: PPUSH
11742: LD_VAR 0 1
11746: PUSH
11747: LD_INT 2
11749: ARRAY
11750: PPUSH
11751: LD_INT 1
11753: PPUSH
11754: LD_INT 20
11756: NEG
11757: PPUSH
11758: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11762: LD_VAR 0 1
11766: PUSH
11767: LD_INT 1
11769: ARRAY
11770: PPUSH
11771: LD_VAR 0 1
11775: PUSH
11776: LD_INT 2
11778: ARRAY
11779: PPUSH
11780: LD_INT 1
11782: PPUSH
11783: CALL_OW 331
// end ;
11787: GO 11730
11789: POP
11790: POP
// dwait ( 0 0$0.5 ) ;
11791: LD_INT 18
11793: PPUSH
11794: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11798: LD_INT 42
11800: PPUSH
11801: LD_INT 27
11803: PPUSH
11804: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11808: LD_EXP 34
11812: PPUSH
11813: LD_STRING D4Ya-Yam-2
11815: PPUSH
11816: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11820: LD_INT 18
11822: PPUSH
11823: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11827: LD_INT 118
11829: PPUSH
11830: LD_INT 80
11832: PPUSH
11833: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11837: LD_EXP 21
11841: PPUSH
11842: LD_STRING D4Ya-JMM-2
11844: PPUSH
11845: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11849: LD_EXP 34
11853: PPUSH
11854: LD_STRING D4Ya-Yam-3
11856: PPUSH
11857: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11861: LD_INT 10
11863: PPUSH
11864: CALL_OW 68
// DialogueOff ;
11868: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11872: LD_EXP 34
11876: PPUSH
11877: LD_INT 1
11879: PPUSH
11880: CALL_OW 235
// end else
11884: GO 12138
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11886: LD_INT 2
11888: PPUSH
11889: LD_INT 4
11891: PPUSH
11892: LD_INT 2
11894: PPUSH
11895: LD_INT 1
11897: PPUSH
11898: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11902: LD_EXP 34
11906: PPUSH
11907: LD_INT 75
11909: PPUSH
11910: LD_INT 63
11912: PPUSH
11913: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11917: LD_EXP 34
11921: PPUSH
11922: LD_INT 175
11924: PPUSH
11925: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11929: LD_EXP 34
11933: PPUSH
11934: LD_INT 102
11936: PPUSH
11937: LD_INT 76
11939: PPUSH
11940: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11944: LD_EXP 34
11948: PPUSH
11949: LD_INT 108
11951: PPUSH
11952: LD_INT 70
11954: PPUSH
11955: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11959: LD_INT 35
11961: PPUSH
11962: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11966: LD_INT 2
11968: PPUSH
11969: LD_EXP 34
11973: PPUSH
11974: CALL_OW 292
11978: IFFALSE 11959
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11980: LD_EXP 34
11984: PPUSH
11985: LD_INT 112
11987: PPUSH
11988: LD_INT 118
11990: PPUSH
11991: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11995: LD_EXP 34
11999: PPUSH
12000: CALL_OW 256
12004: PUSH
12005: LD_INT 750
12007: GREATEREQUAL
12008: IFFALSE 12022
// SetLives ( Kikuchi , 700 ) ;
12010: LD_EXP 34
12014: PPUSH
12015: LD_INT 700
12017: PPUSH
12018: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12022: LD_INT 35
12024: PPUSH
12025: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12029: LD_INT 1
12031: PPUSH
12032: LD_EXP 34
12036: PPUSH
12037: CALL_OW 292
12041: PUSH
12042: LD_EXP 34
12046: PPUSH
12047: LD_INT 7
12049: PPUSH
12050: CALL_OW 296
12054: PUSH
12055: LD_INT 17
12057: LESS
12058: OR
12059: IFFALSE 12022
// DialogueOn ;
12061: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12065: LD_EXP 34
12069: PPUSH
12070: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12074: LD_EXP 34
12078: PPUSH
12079: LD_STRING D4Yb-Yam-1
12081: PPUSH
12082: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12086: LD_EXP 21
12090: PPUSH
12091: LD_STRING D4Yb-JMM-1
12093: PPUSH
12094: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12098: LD_EXP 34
12102: PPUSH
12103: LD_STRING D4Yb-Yam-2
12105: PPUSH
12106: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12110: LD_EXP 21
12114: PPUSH
12115: LD_STRING D4Yb-JMM-2
12117: PPUSH
12118: CALL_OW 88
// DialogueOff ;
12122: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12126: LD_EXP 34
12130: PPUSH
12131: LD_INT 1
12133: PPUSH
12134: CALL_OW 235
// end ; end ; end ;
12138: PPOPN 2
12140: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12141: LD_EXP 6
12145: IFFALSE 13178
12147: GO 12149
12149: DISABLE
12150: LD_INT 0
12152: PPUSH
12153: PPUSH
12154: PPUSH
12155: PPUSH
// begin enable ;
12156: ENABLE
// if not seen [ 1 ] then
12157: LD_EXP 9
12161: PUSH
12162: LD_INT 1
12164: ARRAY
12165: NOT
12166: IFFALSE 12346
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12168: LD_ADDR_VAR 0 2
12172: PUSH
12173: LD_INT 22
12175: PUSH
12176: LD_INT 2
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PUSH
12183: LD_INT 2
12185: PUSH
12186: LD_INT 25
12188: PUSH
12189: LD_INT 11
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 33
12198: PUSH
12199: LD_INT 4
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: LIST
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: PPUSH
12215: CALL_OW 69
12219: ST_TO_ADDR
// if tmp then
12220: LD_VAR 0 2
12224: IFFALSE 12346
// for i in tmp do
12226: LD_ADDR_VAR 0 1
12230: PUSH
12231: LD_VAR 0 2
12235: PUSH
12236: FOR_IN
12237: IFFALSE 12344
// if See ( 1 , i ) then
12239: LD_INT 1
12241: PPUSH
12242: LD_VAR 0 1
12246: PPUSH
12247: CALL_OW 292
12251: IFFALSE 12342
// begin seen := Replace ( seen , 1 , true ) ;
12253: LD_ADDR_EXP 9
12257: PUSH
12258: LD_EXP 9
12262: PPUSH
12263: LD_INT 1
12265: PPUSH
12266: LD_INT 1
12268: PPUSH
12269: CALL_OW 1
12273: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12274: LD_INT 1
12276: PPUSH
12277: CALL 15864 0 1
12281: IFFALSE 12342
// begin DialogueOn ;
12283: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12287: LD_VAR 0 1
12291: PPUSH
12292: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12296: LD_INT 10
12298: PPUSH
12299: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12303: LD_ADDR_VAR 0 3
12307: PUSH
12308: LD_INT 1
12310: PPUSH
12311: LD_STRING D5a-Sol2-1
12313: PPUSH
12314: CALL 16042 0 2
12318: ST_TO_ADDR
// if not un then
12319: LD_VAR 0 3
12323: NOT
12324: IFFALSE 12336
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12326: LD_INT 2
12328: PPUSH
12329: LD_STRING D5a-FSol2-1
12331: PPUSH
12332: CALL 16042 0 2
// DialogueOff ;
12336: CALL_OW 7
// break ;
12340: GO 12344
// end ; end ;
12342: GO 12236
12344: POP
12345: POP
// end ; if not seen [ 2 ] then
12346: LD_EXP 9
12350: PUSH
12351: LD_INT 2
12353: ARRAY
12354: NOT
12355: IFFALSE 12580
// begin can_kamikazed := true ;
12357: LD_ADDR_EXP 10
12361: PUSH
12362: LD_INT 1
12364: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12365: LD_ADDR_VAR 0 2
12369: PUSH
12370: LD_INT 22
12372: PUSH
12373: LD_INT 2
12375: PUSH
12376: EMPTY
12377: LIST
12378: LIST
12379: PUSH
12380: LD_INT 25
12382: PUSH
12383: LD_INT 17
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PPUSH
12394: CALL_OW 69
12398: ST_TO_ADDR
// if tmp then
12399: LD_VAR 0 2
12403: IFFALSE 12580
// for i in tmp do
12405: LD_ADDR_VAR 0 1
12409: PUSH
12410: LD_VAR 0 2
12414: PUSH
12415: FOR_IN
12416: IFFALSE 12578
// if See ( 1 , i ) then
12418: LD_INT 1
12420: PPUSH
12421: LD_VAR 0 1
12425: PPUSH
12426: CALL_OW 292
12430: IFFALSE 12576
// begin seen := Replace ( seen , 2 , true ) ;
12432: LD_ADDR_EXP 9
12436: PUSH
12437: LD_EXP 9
12441: PPUSH
12442: LD_INT 2
12444: PPUSH
12445: LD_INT 1
12447: PPUSH
12448: CALL_OW 1
12452: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12453: LD_INT 1
12455: PPUSH
12456: CALL 15864 0 1
12460: IFFALSE 12576
// begin DialogueOn ;
12462: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12466: LD_VAR 0 1
12470: PPUSH
12471: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12475: LD_INT 10
12477: PPUSH
12478: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12482: LD_ADDR_VAR 0 3
12486: PUSH
12487: LD_INT 1
12489: PPUSH
12490: LD_STRING D5b-Sol1-1
12492: PPUSH
12493: CALL 16042 0 2
12497: ST_TO_ADDR
// if not un then
12498: LD_VAR 0 3
12502: NOT
12503: IFFALSE 12521
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12505: LD_ADDR_VAR 0 3
12509: PUSH
12510: LD_INT 2
12512: PPUSH
12513: LD_STRING D5b-FSol1-1
12515: PPUSH
12516: CALL 16042 0 2
12520: ST_TO_ADDR
// if un then
12521: LD_VAR 0 3
12525: IFFALSE 12570
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12527: LD_ADDR_VAR 0 4
12531: PUSH
12532: LD_INT 1
12534: PPUSH
12535: LD_STRING D5b-Sol2-1
12537: PPUSH
12538: LD_VAR 0 3
12542: PPUSH
12543: CALL 16268 0 3
12547: ST_TO_ADDR
// if not un2 then
12548: LD_VAR 0 4
12552: NOT
12553: IFFALSE 12570
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12555: LD_INT 2
12557: PPUSH
12558: LD_STRING D5b-FSol2-1
12560: PPUSH
12561: LD_VAR 0 3
12565: PPUSH
12566: CALL 16268 0 3
// end ; DialogueOff ;
12570: CALL_OW 7
// break ;
12574: GO 12578
// end ; end ;
12576: GO 12415
12578: POP
12579: POP
// end ; if not seen [ 3 ] then
12580: LD_EXP 9
12584: PUSH
12585: LD_INT 3
12587: ARRAY
12588: NOT
12589: IFFALSE 12763
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12591: LD_ADDR_VAR 0 2
12595: PUSH
12596: LD_INT 22
12598: PUSH
12599: LD_INT 2
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: PUSH
12606: LD_INT 33
12608: PUSH
12609: LD_INT 2
12611: PUSH
12612: EMPTY
12613: LIST
12614: LIST
12615: PUSH
12616: EMPTY
12617: LIST
12618: LIST
12619: PPUSH
12620: CALL_OW 69
12624: ST_TO_ADDR
// if tmp then
12625: LD_VAR 0 2
12629: IFFALSE 12763
// for i in tmp do
12631: LD_ADDR_VAR 0 1
12635: PUSH
12636: LD_VAR 0 2
12640: PUSH
12641: FOR_IN
12642: IFFALSE 12761
// if See ( 1 , i ) then
12644: LD_INT 1
12646: PPUSH
12647: LD_VAR 0 1
12651: PPUSH
12652: CALL_OW 292
12656: IFFALSE 12759
// begin seen := Replace ( seen , 3 , true ) ;
12658: LD_ADDR_EXP 9
12662: PUSH
12663: LD_EXP 9
12667: PPUSH
12668: LD_INT 3
12670: PPUSH
12671: LD_INT 1
12673: PPUSH
12674: CALL_OW 1
12678: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12679: LD_INT 1
12681: PPUSH
12682: CALL 15864 0 1
12686: IFFALSE 12759
// begin DialogueOn ;
12688: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12692: LD_VAR 0 1
12696: PPUSH
12697: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12701: LD_INT 10
12703: PPUSH
12704: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12708: LD_ADDR_VAR 0 3
12712: PUSH
12713: LD_INT 1
12715: PPUSH
12716: LD_STRING D8-Sol1-1
12718: PPUSH
12719: CALL 16042 0 2
12723: ST_TO_ADDR
// if not un then
12724: LD_VAR 0 3
12728: NOT
12729: IFFALSE 12741
// SayRand ( sex_female , D8-FSol1-1 ) ;
12731: LD_INT 2
12733: PPUSH
12734: LD_STRING D8-FSol1-1
12736: PPUSH
12737: CALL 16042 0 2
// Say ( JMM , D8-JMM-1 ) ;
12741: LD_EXP 21
12745: PPUSH
12746: LD_STRING D8-JMM-1
12748: PPUSH
12749: CALL_OW 88
// DialogueOff ;
12753: CALL_OW 7
// break ;
12757: GO 12761
// end ; end ;
12759: GO 12641
12761: POP
12762: POP
// end ; if not seen [ 4 ] then
12763: LD_EXP 9
12767: PUSH
12768: LD_INT 4
12770: ARRAY
12771: NOT
12772: IFFALSE 12934
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12774: LD_ADDR_VAR 0 2
12778: PUSH
12779: LD_INT 22
12781: PUSH
12782: LD_INT 2
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PUSH
12789: LD_INT 33
12791: PUSH
12792: LD_INT 5
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PPUSH
12803: CALL_OW 69
12807: ST_TO_ADDR
// if tmp then
12808: LD_VAR 0 2
12812: IFFALSE 12934
// for i in tmp do
12814: LD_ADDR_VAR 0 1
12818: PUSH
12819: LD_VAR 0 2
12823: PUSH
12824: FOR_IN
12825: IFFALSE 12932
// if See ( 1 , i ) then
12827: LD_INT 1
12829: PPUSH
12830: LD_VAR 0 1
12834: PPUSH
12835: CALL_OW 292
12839: IFFALSE 12930
// begin seen := Replace ( seen , 4 , true ) ;
12841: LD_ADDR_EXP 9
12845: PUSH
12846: LD_EXP 9
12850: PPUSH
12851: LD_INT 4
12853: PPUSH
12854: LD_INT 1
12856: PPUSH
12857: CALL_OW 1
12861: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12862: LD_INT 1
12864: PPUSH
12865: CALL 15864 0 1
12869: IFFALSE 12930
// begin DialogueOn ;
12871: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12875: LD_VAR 0 1
12879: PPUSH
12880: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12884: LD_INT 10
12886: PPUSH
12887: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12891: LD_ADDR_VAR 0 3
12895: PUSH
12896: LD_INT 1
12898: PPUSH
12899: LD_STRING D5a-Sol1-1
12901: PPUSH
12902: CALL 16042 0 2
12906: ST_TO_ADDR
// if not un then
12907: LD_VAR 0 3
12911: NOT
12912: IFFALSE 12924
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12914: LD_INT 2
12916: PPUSH
12917: LD_STRING D5a-FSol1-1
12919: PPUSH
12920: CALL 16042 0 2
// DialogueOff ;
12924: CALL_OW 7
// break ;
12928: GO 12932
// end ; end ;
12930: GO 12824
12932: POP
12933: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12934: LD_EXP 9
12938: PUSH
12939: LD_INT 5
12941: ARRAY
12942: NOT
12943: PUSH
12944: LD_EXP 9
12948: PUSH
12949: LD_INT 3
12951: ARRAY
12952: AND
12953: IFFALSE 13127
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12955: LD_ADDR_VAR 0 2
12959: PUSH
12960: LD_INT 22
12962: PUSH
12963: LD_INT 2
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 34
12972: PUSH
12973: LD_INT 31
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PPUSH
12984: CALL_OW 69
12988: ST_TO_ADDR
// if tmp then
12989: LD_VAR 0 2
12993: IFFALSE 13127
// for i in tmp do
12995: LD_ADDR_VAR 0 1
12999: PUSH
13000: LD_VAR 0 2
13004: PUSH
13005: FOR_IN
13006: IFFALSE 13125
// if See ( 1 , i ) then
13008: LD_INT 1
13010: PPUSH
13011: LD_VAR 0 1
13015: PPUSH
13016: CALL_OW 292
13020: IFFALSE 13123
// begin seen := Replace ( seen , 5 , true ) ;
13022: LD_ADDR_EXP 9
13026: PUSH
13027: LD_EXP 9
13031: PPUSH
13032: LD_INT 5
13034: PPUSH
13035: LD_INT 1
13037: PPUSH
13038: CALL_OW 1
13042: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13043: LD_INT 1
13045: PPUSH
13046: CALL 15864 0 1
13050: IFFALSE 13123
// begin DialogueOn ;
13052: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13056: LD_VAR 0 1
13060: PPUSH
13061: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13065: LD_INT 10
13067: PPUSH
13068: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13072: LD_ADDR_VAR 0 3
13076: PUSH
13077: LD_INT 1
13079: PPUSH
13080: LD_STRING D8a-Sol2-1
13082: PPUSH
13083: CALL 16042 0 2
13087: ST_TO_ADDR
// if not un then
13088: LD_VAR 0 3
13092: NOT
13093: IFFALSE 13105
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13095: LD_INT 2
13097: PPUSH
13098: LD_STRING D8a-FSol2-1
13100: PPUSH
13101: CALL 16042 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13105: LD_EXP 21
13109: PPUSH
13110: LD_STRING D8a-JMM-1
13112: PPUSH
13113: CALL_OW 88
// DialogueOff ;
13117: CALL_OW 7
// break ;
13121: GO 13125
// end ; end ;
13123: GO 13005
13125: POP
13126: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13127: LD_EXP 9
13131: PUSH
13132: LD_INT 1
13134: ARRAY
13135: PUSH
13136: LD_EXP 9
13140: PUSH
13141: LD_INT 2
13143: ARRAY
13144: AND
13145: PUSH
13146: LD_EXP 9
13150: PUSH
13151: LD_INT 3
13153: ARRAY
13154: AND
13155: PUSH
13156: LD_EXP 9
13160: PUSH
13161: LD_INT 4
13163: ARRAY
13164: AND
13165: PUSH
13166: LD_EXP 9
13170: PUSH
13171: LD_INT 5
13173: ARRAY
13174: AND
13175: IFFALSE 13178
// disable ;
13177: DISABLE
// end ;
13178: PPOPN 4
13180: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13181: LD_EXP 10
13185: PUSH
13186: LD_EXP 11
13190: AND
13191: IFFALSE 13389
13193: GO 13195
13195: DISABLE
13196: LD_INT 0
13198: PPUSH
// begin DialogueOn ;
13199: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13203: LD_EXP 11
13207: PPUSH
13208: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13212: LD_ADDR_VAR 0 1
13216: PUSH
13217: LD_INT 1
13219: PPUSH
13220: LD_STRING D5c-Sol1-1
13222: PPUSH
13223: CALL 16042 0 2
13227: ST_TO_ADDR
// if not un then
13228: LD_VAR 0 1
13232: NOT
13233: IFFALSE 13251
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13235: LD_ADDR_VAR 0 1
13239: PUSH
13240: LD_INT 2
13242: PPUSH
13243: LD_STRING D5c-FSol1-1
13245: PPUSH
13246: CALL 16042 0 2
13250: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13251: LD_EXP 21
13255: PPUSH
13256: LD_STRING D5c-JMM-1
13258: PPUSH
13259: CALL_OW 88
// if IsOk ( Lisa ) then
13263: LD_EXP 22
13267: PPUSH
13268: CALL_OW 302
13272: IFFALSE 13288
// Say ( Lisa , D5d-Lisa-1 ) else
13274: LD_EXP 22
13278: PPUSH
13279: LD_STRING D5d-Lisa-1
13281: PPUSH
13282: CALL_OW 88
13286: GO 13373
// if IsOk ( Cyrus ) then
13288: LD_EXP 25
13292: PPUSH
13293: CALL_OW 302
13297: IFFALSE 13313
// Say ( Cyrus , D5d-Cyrus-1 ) else
13299: LD_EXP 25
13303: PPUSH
13304: LD_STRING D5d-Cyrus-1
13306: PPUSH
13307: CALL_OW 88
13311: GO 13373
// if IsOk ( Gary ) then
13313: LD_EXP 32
13317: PPUSH
13318: CALL_OW 302
13322: IFFALSE 13338
// Say ( Gary , D5d-Gary-1 ) else
13324: LD_EXP 32
13328: PPUSH
13329: LD_STRING D5d-Gary-1
13331: PPUSH
13332: CALL_OW 88
13336: GO 13373
// if GetSex ( un ) = sex_male then
13338: LD_VAR 0 1
13342: PPUSH
13343: CALL_OW 258
13347: PUSH
13348: LD_INT 1
13350: EQUAL
13351: IFFALSE 13367
// Say ( un , D5d-Sol1-1 ) else
13353: LD_VAR 0 1
13357: PPUSH
13358: LD_STRING D5d-Sol1-1
13360: PPUSH
13361: CALL_OW 88
13365: GO 13373
// begin DialogueOff ;
13367: CALL_OW 7
// exit ;
13371: GO 13389
// end ; Say ( JMM , D5d-JMM-1 ) ;
13373: LD_EXP 21
13377: PPUSH
13378: LD_STRING D5d-JMM-1
13380: PPUSH
13381: CALL_OW 88
// DialogueOff ;
13385: CALL_OW 7
// end ;
13389: PPOPN 1
13391: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13392: LD_INT 1
13394: PPUSH
13395: LD_INT 17
13397: PPUSH
13398: CALL_OW 294
13402: PUSH
13403: LD_INT 2
13405: GREATEREQUAL
13406: IFFALSE 13527
13408: GO 13410
13410: DISABLE
13411: LD_INT 0
13413: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13414: LD_INT 10
13416: PPUSH
13417: LD_INT 5
13419: PPUSH
13420: LD_INT 1
13422: PPUSH
13423: LD_INT 10
13425: NEG
13426: PPUSH
13427: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13431: LD_INT 10
13433: PPUSH
13434: LD_INT 5
13436: PPUSH
13437: LD_INT 1
13439: PPUSH
13440: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13444: LD_INT 10
13446: PPUSH
13447: LD_INT 5
13449: PPUSH
13450: CALL_OW 86
// DialogueOn ;
13454: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13458: LD_ADDR_VAR 0 1
13462: PUSH
13463: LD_INT 1
13465: PPUSH
13466: LD_STRING D6-Sci1-1
13468: PPUSH
13469: CALL 16042 0 2
13473: ST_TO_ADDR
// if un then
13474: LD_VAR 0 1
13478: IFFALSE 13516
// begin Say ( JMM , D6-JMM-1 ) ;
13480: LD_EXP 21
13484: PPUSH
13485: LD_STRING D6-JMM-1
13487: PPUSH
13488: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13492: LD_VAR 0 1
13496: PPUSH
13497: LD_STRING D6-Sci1-2
13499: PPUSH
13500: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13504: LD_EXP 21
13508: PPUSH
13509: LD_STRING D6-JMM-2
13511: PPUSH
13512: CALL_OW 88
// end ; DialogueOff ;
13516: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13520: LD_STRING M3
13522: PPUSH
13523: CALL_OW 337
// end ;
13527: PPOPN 1
13529: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13530: LD_OWVAR 1
13534: PUSH
13535: LD_INT 42000
13537: GREATEREQUAL
13538: PUSH
13539: LD_INT 2
13541: PPUSH
13542: LD_INT 169
13544: PPUSH
13545: LD_INT 90
13547: PPUSH
13548: LD_INT 10
13550: PPUSH
13551: CALL 55399 0 4
13555: PUSH
13556: LD_INT 4
13558: ARRAY
13559: PUSH
13560: LD_INT 0
13562: EQUAL
13563: PUSH
13564: LD_INT 45
13566: PPUSH
13567: CALL_OW 301
13571: OR
13572: PUSH
13573: LD_INT 45
13575: PPUSH
13576: CALL_OW 255
13580: PUSH
13581: LD_INT 1
13583: EQUAL
13584: OR
13585: AND
13586: PUSH
13587: LD_INT 94
13589: PPUSH
13590: CALL_OW 301
13594: NOT
13595: AND
13596: IFFALSE 14801
13598: GO 13600
13600: DISABLE
13601: LD_INT 0
13603: PPUSH
13604: PPUSH
13605: PPUSH
13606: PPUSH
13607: PPUSH
// begin uc_side := 5 ;
13608: LD_ADDR_OWVAR 20
13612: PUSH
13613: LD_INT 5
13615: ST_TO_ADDR
// uc_nation := 2 ;
13616: LD_ADDR_OWVAR 21
13620: PUSH
13621: LD_INT 2
13623: ST_TO_ADDR
// InitHc ;
13624: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13628: LD_INT 1
13630: PPUSH
13631: LD_INT 3
13633: PPUSH
13634: LD_INT 8
13636: PPUSH
13637: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13641: LD_ADDR_OWVAR 29
13645: PUSH
13646: LD_INT 12
13648: PUSH
13649: LD_INT 12
13651: PUSH
13652: EMPTY
13653: LIST
13654: LIST
13655: ST_TO_ADDR
// hc_name := Hans Felige ;
13656: LD_ADDR_OWVAR 26
13660: PUSH
13661: LD_STRING Hans Felige
13663: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13664: LD_ADDR_OWVAR 33
13668: PUSH
13669: LD_STRING SecondCharsGal
13671: ST_TO_ADDR
// hc_face_number := 7 ;
13672: LD_ADDR_OWVAR 34
13676: PUSH
13677: LD_INT 7
13679: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13680: LD_ADDR_EXP 46
13684: PUSH
13685: CALL_OW 44
13689: ST_TO_ADDR
// InitHc ;
13690: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13694: LD_INT 1
13696: PPUSH
13697: LD_INT 16
13699: PPUSH
13700: LD_INT 2
13702: PPUSH
13703: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13707: LD_ADDR_OWVAR 29
13711: PUSH
13712: LD_INT 12
13714: PUSH
13715: LD_INT 12
13717: PUSH
13718: EMPTY
13719: LIST
13720: LIST
13721: ST_TO_ADDR
// hc_name :=  ;
13722: LD_ADDR_OWVAR 26
13726: PUSH
13727: LD_STRING 
13729: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13730: LD_ADDR_EXP 47
13734: PUSH
13735: CALL_OW 44
13739: ST_TO_ADDR
// InitHc ;
13740: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13744: LD_INT 35
13746: PPUSH
13747: CALL_OW 67
// until not InBattle ( 1 ) ;
13751: LD_INT 1
13753: PPUSH
13754: CALL_OW 463
13758: NOT
13759: IFFALSE 13744
// wait ( 0 0$5 ) ;
13761: LD_INT 175
13763: PPUSH
13764: CALL_OW 67
// DialogueOn ;
13768: CALL_OW 6
// InGameOn ;
13772: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13776: LD_ADDR_VAR 0 1
13780: PUSH
13781: LD_INT 22
13783: PUSH
13784: LD_INT 1
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PUSH
13791: LD_INT 2
13793: PUSH
13794: LD_INT 25
13796: PUSH
13797: LD_INT 1
13799: PUSH
13800: EMPTY
13801: LIST
13802: LIST
13803: PUSH
13804: LD_INT 25
13806: PUSH
13807: LD_INT 2
13809: PUSH
13810: EMPTY
13811: LIST
13812: LIST
13813: PUSH
13814: LD_INT 25
13816: PUSH
13817: LD_INT 3
13819: PUSH
13820: EMPTY
13821: LIST
13822: LIST
13823: PUSH
13824: LD_INT 25
13826: PUSH
13827: LD_INT 4
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: PUSH
13834: LD_INT 25
13836: PUSH
13837: LD_INT 5
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: PUSH
13844: LD_INT 25
13846: PUSH
13847: LD_INT 8
13849: PUSH
13850: EMPTY
13851: LIST
13852: LIST
13853: PUSH
13854: EMPTY
13855: LIST
13856: LIST
13857: LIST
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: PPUSH
13867: CALL_OW 69
13871: PUSH
13872: LD_EXP 21
13876: PUSH
13877: LD_EXP 22
13881: PUSH
13882: LD_EXP 23
13886: PUSH
13887: LD_EXP 24
13891: PUSH
13892: LD_EXP 25
13896: PUSH
13897: LD_EXP 26
13901: PUSH
13902: LD_EXP 27
13906: PUSH
13907: LD_EXP 28
13911: PUSH
13912: LD_EXP 29
13916: PUSH
13917: LD_EXP 31
13921: PUSH
13922: LD_EXP 32
13926: PUSH
13927: LD_EXP 33
13931: PUSH
13932: LD_EXP 34
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: DIFF
13952: PPUSH
13953: LD_INT 26
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: PPUSH
13963: CALL_OW 72
13967: PUSH
13968: LD_INT 1
13970: ARRAY
13971: ST_TO_ADDR
// if Brown then
13972: LD_EXP 27
13976: IFFALSE 13988
// un := Brown ;
13978: LD_ADDR_VAR 0 1
13982: PUSH
13983: LD_EXP 27
13987: ST_TO_ADDR
// if un then
13988: LD_VAR 0 1
13992: IFFALSE 14018
// begin Say ( un , D7-Sol1-1 ) ;
13994: LD_VAR 0 1
13998: PPUSH
13999: LD_STRING D7-Sol1-1
14001: PPUSH
14002: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14006: LD_EXP 21
14010: PPUSH
14011: LD_STRING D7-JMM-1
14013: PPUSH
14014: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14018: LD_EXP 46
14022: PPUSH
14023: LD_STRING D7-Ar1-1
14025: PPUSH
14026: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14030: LD_EXP 21
14034: PPUSH
14035: LD_STRING D7-JMM-2
14037: PPUSH
14038: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14042: LD_EXP 46
14046: PPUSH
14047: LD_STRING D7-Ar1-2
14049: PPUSH
14050: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14054: LD_EXP 21
14058: PPUSH
14059: LD_STRING D7-JMM-3
14061: PPUSH
14062: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14066: LD_EXP 46
14070: PPUSH
14071: LD_STRING D7-Ar1-3
14073: PPUSH
14074: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14078: LD_EXP 21
14082: PPUSH
14083: LD_STRING D7-JMM-4
14085: PPUSH
14086: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14090: LD_EXP 46
14094: PPUSH
14095: LD_STRING D7-Ar1-4
14097: PPUSH
14098: CALL_OW 94
// InGameOff ;
14102: CALL_OW 9
// DialogueOff ;
14106: CALL_OW 7
// case Query ( QCameras ) of 1 :
14110: LD_STRING QCameras
14112: PPUSH
14113: CALL_OW 97
14117: PUSH
14118: LD_INT 1
14120: DOUBLE
14121: EQUAL
14122: IFTRUE 14126
14124: GO 14129
14126: POP
// ; 2 :
14127: GO 14143
14129: LD_INT 2
14131: DOUBLE
14132: EQUAL
14133: IFTRUE 14137
14135: GO 14142
14137: POP
// exit ; end ;
14138: GO 14801
14140: GO 14143
14142: POP
// ChangeMissionObjectives ( MCar ) ;
14143: LD_STRING MCar
14145: PPUSH
14146: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14150: LD_INT 124
14152: PPUSH
14153: LD_INT 90
14155: PPUSH
14156: LD_INT 1
14158: PPUSH
14159: LD_INT 6
14161: NEG
14162: PPUSH
14163: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14167: LD_INT 124
14169: PPUSH
14170: LD_INT 90
14172: PPUSH
14173: LD_INT 1
14175: PPUSH
14176: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14180: LD_INT 12
14182: PPUSH
14183: LD_INT 1
14185: PPUSH
14186: CALL_OW 424
// wait ( 3 ) ;
14190: LD_INT 3
14192: PPUSH
14193: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14197: LD_INT 124
14199: PPUSH
14200: LD_INT 90
14202: PPUSH
14203: CALL_OW 86
// cargo := false ;
14207: LD_ADDR_VAR 0 3
14211: PUSH
14212: LD_INT 0
14214: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14215: LD_INT 35
14217: PPUSH
14218: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14222: LD_ADDR_VAR 0 3
14226: PUSH
14227: LD_INT 12
14229: PPUSH
14230: LD_INT 32
14232: PUSH
14233: LD_INT 3
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: PUSH
14240: LD_INT 34
14242: PUSH
14243: LD_INT 32
14245: PUSH
14246: EMPTY
14247: LIST
14248: LIST
14249: PUSH
14250: LD_INT 58
14252: PUSH
14253: EMPTY
14254: LIST
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: LIST
14260: PPUSH
14261: CALL_OW 70
14265: ST_TO_ADDR
// until cargo ;
14266: LD_VAR 0 3
14270: IFFALSE 14215
// cargo := cargo [ 1 ] ;
14272: LD_ADDR_VAR 0 3
14276: PUSH
14277: LD_VAR 0 3
14281: PUSH
14282: LD_INT 1
14284: ARRAY
14285: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14286: LD_VAR 0 3
14290: PPUSH
14291: LD_INT 5
14293: PPUSH
14294: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14298: LD_INT 12
14300: PPUSH
14301: LD_INT 0
14303: PPUSH
14304: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14308: LD_EXP 46
14312: PPUSH
14313: LD_INT 11
14315: PPUSH
14316: LD_INT 0
14318: PPUSH
14319: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14323: LD_EXP 47
14327: PPUSH
14328: LD_INT 11
14330: PPUSH
14331: LD_INT 0
14333: PPUSH
14334: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14338: LD_EXP 46
14342: PUSH
14343: LD_EXP 47
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PPUSH
14352: LD_INT 12
14354: PPUSH
14355: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14359: LD_EXP 46
14363: PPUSH
14364: LD_VAR 0 3
14368: PPUSH
14369: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14373: LD_EXP 46
14377: PUSH
14378: LD_EXP 47
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: PPUSH
14387: LD_INT 209
14389: PPUSH
14390: LD_INT 178
14392: PPUSH
14393: CALL_OW 171
// escaped := 0 ;
14397: LD_ADDR_VAR 0 5
14401: PUSH
14402: LD_INT 0
14404: ST_TO_ADDR
// while ( true ) do
14405: LD_INT 1
14407: IFFALSE 14623
// begin wait ( 0 0$1 ) ;
14409: LD_INT 35
14411: PPUSH
14412: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14416: LD_EXP 46
14420: PPUSH
14421: CALL_OW 314
14425: NOT
14426: PUSH
14427: LD_EXP 47
14431: PPUSH
14432: CALL_OW 314
14436: NOT
14437: OR
14438: IFFALSE 14464
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14440: LD_EXP 46
14444: PUSH
14445: LD_EXP 47
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: PPUSH
14454: LD_INT 209
14456: PPUSH
14457: LD_INT 178
14459: PPUSH
14460: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14464: LD_EXP 46
14468: PPUSH
14469: LD_INT 10
14471: PPUSH
14472: CALL_OW 308
14476: IFFALSE 14501
// begin RemoveUnit ( ar_mechanic ) ;
14478: LD_EXP 46
14482: PPUSH
14483: CALL_OW 64
// escaped := escaped + 1 ;
14487: LD_ADDR_VAR 0 5
14491: PUSH
14492: LD_VAR 0 5
14496: PUSH
14497: LD_INT 1
14499: PLUS
14500: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14501: LD_EXP 47
14505: PPUSH
14506: LD_INT 10
14508: PPUSH
14509: CALL_OW 308
14513: IFFALSE 14538
// begin RemoveUnit ( ar_mechanic_friend ) ;
14515: LD_EXP 47
14519: PPUSH
14520: CALL_OW 64
// escaped := escaped + 1 ;
14524: LD_ADDR_VAR 0 5
14528: PUSH
14529: LD_VAR 0 5
14533: PUSH
14534: LD_INT 1
14536: PLUS
14537: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14538: LD_VAR 0 3
14542: PPUSH
14543: LD_INT 10
14545: PPUSH
14546: CALL_OW 308
14550: IFFALSE 14561
// RemoveUnit ( cargo ) ;
14552: LD_VAR 0 3
14556: PPUSH
14557: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14561: LD_EXP 46
14565: PPUSH
14566: CALL_OW 305
14570: NOT
14571: PUSH
14572: LD_VAR 0 5
14576: PUSH
14577: LD_INT 2
14579: GREATEREQUAL
14580: AND
14581: IFFALSE 14585
// break ;
14583: GO 14623
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14585: LD_EXP 46
14589: PPUSH
14590: CALL_OW 305
14594: NOT
14595: PUSH
14596: LD_EXP 47
14600: PPUSH
14601: CALL_OW 305
14605: NOT
14606: AND
14607: PUSH
14608: LD_VAR 0 5
14612: PUSH
14613: LD_INT 2
14615: LESS
14616: AND
14617: IFFALSE 14621
// exit ;
14619: GO 14801
// end ;
14621: GO 14405
// wait ( 0 0$2 ) ;
14623: LD_INT 70
14625: PPUSH
14626: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14630: LD_EXP 46
14634: PPUSH
14635: LD_STRING D7a-Ar1-1
14637: PPUSH
14638: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14642: LD_ADDR_VAR 0 4
14646: PUSH
14647: LD_INT 129
14649: PUSH
14650: LD_INT 10
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 103
14659: PUSH
14660: LD_INT 6
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 148
14669: PUSH
14670: LD_INT 47
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 155
14679: PUSH
14680: LD_INT 16
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: ST_TO_ADDR
// if Difficulty = 1 then
14693: LD_OWVAR 67
14697: PUSH
14698: LD_INT 1
14700: EQUAL
14701: IFFALSE 14738
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14703: LD_ADDR_VAR 0 4
14707: PUSH
14708: LD_VAR 0 4
14712: PUSH
14713: LD_INT 78
14715: PUSH
14716: LD_INT 7
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: LD_INT 104
14725: PUSH
14726: LD_INT 43
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: ADD
14737: ST_TO_ADDR
// for i in tmp do
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_VAR 0 4
14747: PUSH
14748: FOR_IN
14749: IFFALSE 14782
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14751: LD_VAR 0 2
14755: PUSH
14756: LD_INT 1
14758: ARRAY
14759: PPUSH
14760: LD_VAR 0 2
14764: PUSH
14765: LD_INT 2
14767: ARRAY
14768: PPUSH
14769: LD_INT 1
14771: PPUSH
14772: LD_INT 9
14774: NEG
14775: PPUSH
14776: CALL_OW 330
14780: GO 14748
14782: POP
14783: POP
// SetAchievement ( ACH_FRIEND ) ;
14784: LD_STRING ACH_FRIEND
14786: PPUSH
14787: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
14791: LD_INT 129
14793: PPUSH
14794: LD_INT 10
14796: PPUSH
14797: CALL_OW 84
// end ;
14801: PPOPN 5
14803: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14804: LD_EXP 15
14808: PUSH
14809: LD_INT 21000
14811: MINUS
14812: PUSH
14813: LD_OWVAR 1
14817: LESSEQUAL
14818: IFFALSE 14858
14820: GO 14822
14822: DISABLE
// begin powell_warn := true ;
14823: LD_ADDR_EXP 16
14827: PUSH
14828: LD_INT 1
14830: ST_TO_ADDR
// DialogueOn ;
14831: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14835: LD_EXP 30
14839: PPUSH
14840: LD_STRING D9-Pow-1
14842: PPUSH
14843: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14847: LD_INT 10
14849: PPUSH
14850: CALL_OW 68
// DialogueOff ;
14854: CALL_OW 7
// end ;
14858: END
// every 0 0$1 trigger game_time <= tick do
14859: LD_EXP 15
14863: PUSH
14864: LD_OWVAR 1
14868: LESSEQUAL
14869: IFFALSE 14908
14871: GO 14873
14873: DISABLE
// begin DialogueOn ;
14874: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14878: LD_EXP 30
14882: PPUSH
14883: LD_STRING D9a-Pow-1
14885: PPUSH
14886: CALL_OW 94
// dwait ( 0 0$2 ) ;
14890: LD_INT 70
14892: PPUSH
14893: CALL_OW 68
// DialogueOff ;
14897: CALL_OW 7
// YouLost ( Command ) ;
14901: LD_STRING Command
14903: PPUSH
14904: CALL_OW 104
// end ;
14908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
14909: LD_INT 22
14911: PUSH
14912: LD_INT 2
14914: PUSH
14915: EMPTY
14916: LIST
14917: LIST
14918: PUSH
14919: LD_INT 30
14921: PUSH
14922: LD_INT 1
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PUSH
14929: EMPTY
14930: LIST
14931: LIST
14932: PPUSH
14933: CALL_OW 69
14937: PUSH
14938: LD_INT 0
14940: EQUAL
14941: PUSH
14942: LD_EXP 21
14946: PPUSH
14947: CALL_OW 302
14951: AND
14952: IFFALSE 15861
14954: GO 14956
14956: DISABLE
14957: LD_INT 0
14959: PPUSH
14960: PPUSH
14961: PPUSH
14962: PPUSH
// begin m1 := false ;
14963: LD_ADDR_VAR 0 2
14967: PUSH
14968: LD_INT 0
14970: ST_TO_ADDR
// m2 := false ;
14971: LD_ADDR_VAR 0 3
14975: PUSH
14976: LD_INT 0
14978: ST_TO_ADDR
// m3 := false ;
14979: LD_ADDR_VAR 0 4
14983: PUSH
14984: LD_INT 0
14986: ST_TO_ADDR
// if not am_veh_consturcted then
14987: LD_EXP 20
14991: NOT
14992: IFFALSE 15001
// SetAchievement ( ACH_ARABTECH ) ;
14994: LD_STRING ACH_ARABTECH
14996: PPUSH
14997: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15001: LD_OWVAR 1
15005: PUSH
15006: LD_INT 252000
15008: PUSH
15009: LD_INT 210000
15011: PUSH
15012: LD_INT 199500
15014: PUSH
15015: EMPTY
15016: LIST
15017: LIST
15018: LIST
15019: PUSH
15020: LD_OWVAR 67
15024: ARRAY
15025: LESS
15026: IFFALSE 15048
// begin m3 := true ;
15028: LD_ADDR_VAR 0 4
15032: PUSH
15033: LD_INT 1
15035: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15036: LD_STRING Time1
15038: PPUSH
15039: LD_INT 1
15041: PPUSH
15042: CALL_OW 101
// end else
15046: GO 15079
// if not powell_warn then
15048: LD_EXP 16
15052: NOT
15053: IFFALSE 15068
// AddMedal ( Time1 , - 1 ) else
15055: LD_STRING Time1
15057: PPUSH
15058: LD_INT 1
15060: NEG
15061: PPUSH
15062: CALL_OW 101
15066: GO 15079
// AddMedal ( Time1 , - 2 ) ;
15068: LD_STRING Time1
15070: PPUSH
15071: LD_INT 2
15073: NEG
15074: PPUSH
15075: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15079: LD_EXP 17
15083: PUSH
15084: LD_INT 5
15086: PUSH
15087: LD_INT 4
15089: PUSH
15090: LD_INT 3
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: LIST
15097: PUSH
15098: LD_OWVAR 67
15102: ARRAY
15103: GREATEREQUAL
15104: IFFALSE 15119
// AddMedal ( Destroy , - 2 ) else
15106: LD_STRING Destroy
15108: PPUSH
15109: LD_INT 2
15111: NEG
15112: PPUSH
15113: CALL_OW 101
15117: GO 15252
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15119: LD_INT 22
15121: PUSH
15122: LD_INT 2
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: LD_INT 21
15131: PUSH
15132: LD_INT 3
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 50
15141: PUSH
15142: EMPTY
15143: LIST
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: LIST
15149: PPUSH
15150: CALL_OW 69
15154: PUSH
15155: LD_INT 25
15157: GREATEREQUAL
15158: IFFALSE 15173
// AddMedal ( Destroy , - 1 ) else
15160: LD_STRING Destroy
15162: PPUSH
15163: LD_INT 1
15165: NEG
15166: PPUSH
15167: CALL_OW 101
15171: GO 15252
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15173: LD_INT 22
15175: PUSH
15176: LD_INT 2
15178: PUSH
15179: EMPTY
15180: LIST
15181: LIST
15182: PUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PUSH
15193: LD_INT 50
15195: PUSH
15196: EMPTY
15197: LIST
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL_OW 69
15208: PUSH
15209: LD_INT 15
15211: GREATEREQUAL
15212: IFFALSE 15234
// begin m1 := true ;
15214: LD_ADDR_VAR 0 2
15218: PUSH
15219: LD_INT 1
15221: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15222: LD_STRING Destroy
15224: PPUSH
15225: LD_INT 1
15227: PPUSH
15228: CALL_OW 101
// end else
15232: GO 15252
// begin m1 := true ;
15234: LD_ADDR_VAR 0 2
15238: PUSH
15239: LD_INT 1
15241: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15242: LD_STRING Destroy
15244: PPUSH
15245: LD_INT 2
15247: PPUSH
15248: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15252: LD_EXP 13
15256: PPUSH
15257: LD_STRING 11_artifact_captured
15259: PPUSH
15260: CALL_OW 39
// if artifact_get then
15264: LD_EXP 13
15268: IFFALSE 15290
// begin m2 := true ;
15270: LD_ADDR_VAR 0 3
15274: PUSH
15275: LD_INT 1
15277: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15278: LD_STRING Artefact
15280: PPUSH
15281: LD_INT 1
15283: PPUSH
15284: CALL_OW 101
// end else
15288: GO 15301
// AddMedal ( Artefact , - 1 ) ;
15290: LD_STRING Artefact
15292: PPUSH
15293: LD_INT 1
15295: NEG
15296: PPUSH
15297: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15301: LD_VAR 0 2
15305: PUSH
15306: LD_VAR 0 3
15310: AND
15311: PUSH
15312: LD_VAR 0 4
15316: AND
15317: PUSH
15318: LD_OWVAR 67
15322: PUSH
15323: LD_INT 3
15325: EQUAL
15326: AND
15327: IFFALSE 15339
// SetAchievementEX ( ACH_AMER , 11 ) ;
15329: LD_STRING ACH_AMER
15331: PPUSH
15332: LD_INT 11
15334: PPUSH
15335: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15339: LD_VAR 0 2
15343: PUSH
15344: LD_VAR 0 3
15348: AND
15349: PUSH
15350: LD_VAR 0 4
15354: AND
15355: PUSH
15356: LD_EXP 17
15360: PUSH
15361: LD_INT 0
15363: EQUAL
15364: AND
15365: IFFALSE 15381
// begin wait ( 3 ) ;
15367: LD_INT 3
15369: PPUSH
15370: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15374: LD_STRING ACH_GENERAL
15376: PPUSH
15377: CALL_OW 543
// end ; if tick <= 100 100$00 then
15381: LD_OWVAR 1
15385: PUSH
15386: LD_INT 210000
15388: LESSEQUAL
15389: IFFALSE 15405
// begin wait ( 3 ) ;
15391: LD_INT 3
15393: PPUSH
15394: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15398: LD_STRING ACH_ASPEED_11
15400: PPUSH
15401: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15405: LD_STRING MAIN
15407: PPUSH
15408: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15412: LD_ADDR_EXP 19
15416: PUSH
15417: LD_EXP 19
15421: PPUSH
15422: LD_INT 51
15424: PUSH
15425: EMPTY
15426: LIST
15427: PPUSH
15428: CALL_OW 72
15432: ST_TO_ADDR
// tmp := JMM ^ selected ;
15433: LD_ADDR_VAR 0 1
15437: PUSH
15438: LD_EXP 21
15442: PUSH
15443: LD_EXP 19
15447: ADD
15448: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15449: LD_VAR 0 1
15453: PPUSH
15454: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15458: LD_VAR 0 1
15462: PUSH
15463: LD_EXP 21
15467: PUSH
15468: LD_EXP 22
15472: PUSH
15473: LD_EXP 23
15477: PUSH
15478: LD_EXP 24
15482: PUSH
15483: LD_EXP 25
15487: PUSH
15488: LD_EXP 26
15492: PUSH
15493: LD_EXP 27
15497: PUSH
15498: LD_EXP 28
15502: PUSH
15503: LD_EXP 29
15507: PUSH
15508: LD_EXP 31
15512: PUSH
15513: LD_EXP 32
15517: PUSH
15518: LD_EXP 33
15522: PUSH
15523: LD_EXP 34
15527: PUSH
15528: EMPTY
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: LIST
15536: LIST
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: DIFF
15543: PPUSH
15544: LD_STRING 11c_others
15546: PPUSH
15547: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15551: LD_EXP 21
15555: PPUSH
15556: LD_EXP 3
15560: PUSH
15561: LD_STRING JMM
15563: STR
15564: PPUSH
15565: CALL_OW 38
// if Lisa then
15569: LD_EXP 22
15573: IFFALSE 15593
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15575: LD_EXP 22
15579: PPUSH
15580: LD_EXP 3
15584: PUSH
15585: LD_STRING Lisa
15587: STR
15588: PPUSH
15589: CALL_OW 38
// if Donaldson then
15593: LD_EXP 23
15597: IFFALSE 15617
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15599: LD_EXP 23
15603: PPUSH
15604: LD_EXP 3
15608: PUSH
15609: LD_STRING Donaldson
15611: STR
15612: PPUSH
15613: CALL_OW 38
// if Bobby then
15617: LD_EXP 24
15621: IFFALSE 15641
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15623: LD_EXP 24
15627: PPUSH
15628: LD_EXP 3
15632: PUSH
15633: LD_STRING Bobby
15635: STR
15636: PPUSH
15637: CALL_OW 38
// if Cyrus then
15641: LD_EXP 25
15645: IFFALSE 15665
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15647: LD_EXP 25
15651: PPUSH
15652: LD_EXP 3
15656: PUSH
15657: LD_STRING Cyrus
15659: STR
15660: PPUSH
15661: CALL_OW 38
// if Denis then
15665: LD_EXP 26
15669: IFFALSE 15689
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15671: LD_EXP 26
15675: PPUSH
15676: LD_EXP 3
15680: PUSH
15681: LD_STRING Denis
15683: STR
15684: PPUSH
15685: CALL_OW 38
// if Brown then
15689: LD_EXP 27
15693: IFFALSE 15713
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15695: LD_EXP 27
15699: PPUSH
15700: LD_EXP 3
15704: PUSH
15705: LD_STRING Brown
15707: STR
15708: PPUSH
15709: CALL_OW 38
// if Gladstone then
15713: LD_EXP 28
15717: IFFALSE 15737
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15719: LD_EXP 28
15723: PPUSH
15724: LD_EXP 3
15728: PUSH
15729: LD_STRING Gladstone
15731: STR
15732: PPUSH
15733: CALL_OW 38
// if Houten then
15737: LD_EXP 29
15741: IFFALSE 15761
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15743: LD_EXP 29
15747: PPUSH
15748: LD_EXP 3
15752: PUSH
15753: LD_STRING Houten
15755: STR
15756: PPUSH
15757: CALL_OW 38
// if Cornel then
15761: LD_EXP 31
15765: IFFALSE 15785
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15767: LD_EXP 31
15771: PPUSH
15772: LD_EXP 3
15776: PUSH
15777: LD_STRING Cornell
15779: STR
15780: PPUSH
15781: CALL_OW 38
// if Gary then
15785: LD_EXP 32
15789: IFFALSE 15809
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15791: LD_EXP 32
15795: PPUSH
15796: LD_EXP 3
15800: PUSH
15801: LD_STRING Gary
15803: STR
15804: PPUSH
15805: CALL_OW 38
// if Frank then
15809: LD_EXP 33
15813: IFFALSE 15833
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15815: LD_EXP 33
15819: PPUSH
15820: LD_EXP 3
15824: PUSH
15825: LD_STRING Frank
15827: STR
15828: PPUSH
15829: CALL_OW 38
// if Kikuchi then
15833: LD_EXP 34
15837: IFFALSE 15857
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15839: LD_EXP 34
15843: PPUSH
15844: LD_EXP 3
15848: PUSH
15849: LD_STRING Kikuchi
15851: STR
15852: PPUSH
15853: CALL_OW 38
// YouWin ;
15857: CALL_OW 103
// end ;
15861: PPOPN 4
15863: END
// export function CanSayRand ( side ) ; begin
15864: LD_INT 0
15866: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15867: LD_ADDR_VAR 0 2
15871: PUSH
15872: LD_INT 52
15874: PUSH
15875: EMPTY
15876: LIST
15877: PUSH
15878: LD_INT 22
15880: PUSH
15881: LD_VAR 0 1
15885: PUSH
15886: EMPTY
15887: LIST
15888: LIST
15889: PUSH
15890: LD_INT 2
15892: PUSH
15893: LD_INT 25
15895: PUSH
15896: LD_INT 1
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: PUSH
15903: LD_INT 25
15905: PUSH
15906: LD_INT 2
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 25
15915: PUSH
15916: LD_INT 3
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: PUSH
15923: LD_INT 25
15925: PUSH
15926: LD_INT 4
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: LIST
15938: LIST
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: LIST
15944: PPUSH
15945: CALL_OW 69
15949: PUSH
15950: LD_EXP 21
15954: PUSH
15955: LD_EXP 33
15959: PUSH
15960: LD_EXP 22
15964: PUSH
15965: LD_EXP 23
15969: PUSH
15970: LD_EXP 24
15974: PUSH
15975: LD_EXP 25
15979: PUSH
15980: LD_EXP 26
15984: PUSH
15985: LD_EXP 27
15989: PUSH
15990: LD_EXP 28
15994: PUSH
15995: LD_EXP 29
15999: PUSH
16000: LD_EXP 30
16004: PUSH
16005: LD_EXP 31
16009: PUSH
16010: LD_EXP 32
16014: PUSH
16015: LD_EXP 34
16019: PUSH
16020: EMPTY
16021: LIST
16022: LIST
16023: LIST
16024: LIST
16025: LIST
16026: LIST
16027: LIST
16028: LIST
16029: LIST
16030: LIST
16031: LIST
16032: LIST
16033: LIST
16034: LIST
16035: DIFF
16036: ST_TO_ADDR
// end ;
16037: LD_VAR 0 2
16041: RET
// export function SayRand ( sex , dial ) ; begin
16042: LD_INT 0
16044: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16045: LD_ADDR_VAR 0 3
16049: PUSH
16050: LD_INT 52
16052: PUSH
16053: EMPTY
16054: LIST
16055: PUSH
16056: LD_INT 22
16058: PUSH
16059: LD_INT 1
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: PUSH
16066: LD_INT 26
16068: PUSH
16069: LD_VAR 0 1
16073: PUSH
16074: EMPTY
16075: LIST
16076: LIST
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: LD_INT 25
16083: PUSH
16084: LD_INT 1
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 25
16093: PUSH
16094: LD_INT 2
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: LD_INT 25
16103: PUSH
16104: LD_INT 3
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: PUSH
16111: LD_INT 25
16113: PUSH
16114: LD_INT 4
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: PUSH
16121: EMPTY
16122: LIST
16123: LIST
16124: LIST
16125: LIST
16126: LIST
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: LIST
16132: LIST
16133: PPUSH
16134: CALL_OW 69
16138: PUSH
16139: LD_EXP 21
16143: PUSH
16144: LD_EXP 33
16148: PUSH
16149: LD_EXP 22
16153: PUSH
16154: LD_EXP 23
16158: PUSH
16159: LD_EXP 24
16163: PUSH
16164: LD_EXP 25
16168: PUSH
16169: LD_EXP 26
16173: PUSH
16174: LD_EXP 27
16178: PUSH
16179: LD_EXP 28
16183: PUSH
16184: LD_EXP 29
16188: PUSH
16189: LD_EXP 30
16193: PUSH
16194: LD_EXP 31
16198: PUSH
16199: LD_EXP 32
16203: PUSH
16204: LD_EXP 34
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: DIFF
16225: ST_TO_ADDR
// if not result then
16226: LD_VAR 0 3
16230: NOT
16231: IFFALSE 16235
// exit ;
16233: GO 16263
// result := result [ 1 ] ;
16235: LD_ADDR_VAR 0 3
16239: PUSH
16240: LD_VAR 0 3
16244: PUSH
16245: LD_INT 1
16247: ARRAY
16248: ST_TO_ADDR
// Say ( result , dial ) ;
16249: LD_VAR 0 3
16253: PPUSH
16254: LD_VAR 0 2
16258: PPUSH
16259: CALL_OW 88
// end ;
16263: LD_VAR 0 3
16267: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16268: LD_INT 0
16270: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16271: LD_ADDR_VAR 0 4
16275: PUSH
16276: LD_INT 22
16278: PUSH
16279: LD_INT 1
16281: PUSH
16282: EMPTY
16283: LIST
16284: LIST
16285: PUSH
16286: LD_INT 26
16288: PUSH
16289: LD_VAR 0 1
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PUSH
16298: LD_INT 2
16300: PUSH
16301: LD_INT 25
16303: PUSH
16304: LD_INT 1
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: LD_INT 25
16313: PUSH
16314: LD_INT 2
16316: PUSH
16317: EMPTY
16318: LIST
16319: LIST
16320: PUSH
16321: LD_INT 25
16323: PUSH
16324: LD_INT 3
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PUSH
16331: LD_INT 25
16333: PUSH
16334: LD_INT 4
16336: PUSH
16337: EMPTY
16338: LIST
16339: LIST
16340: PUSH
16341: EMPTY
16342: LIST
16343: LIST
16344: LIST
16345: LIST
16346: LIST
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: LIST
16352: PPUSH
16353: CALL_OW 69
16357: PUSH
16358: LD_EXP 21
16362: PUSH
16363: LD_EXP 33
16367: PUSH
16368: LD_EXP 22
16372: PUSH
16373: LD_EXP 23
16377: PUSH
16378: LD_EXP 24
16382: PUSH
16383: LD_EXP 25
16387: PUSH
16388: LD_EXP 26
16392: PUSH
16393: LD_EXP 27
16397: PUSH
16398: LD_EXP 28
16402: PUSH
16403: LD_EXP 29
16407: PUSH
16408: LD_EXP 30
16412: PUSH
16413: LD_EXP 31
16417: PUSH
16418: LD_EXP 32
16422: PUSH
16423: LD_EXP 34
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: LIST
16432: LIST
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: PUSH
16444: LD_VAR 0 3
16448: ADD
16449: DIFF
16450: ST_TO_ADDR
// if not result then
16451: LD_VAR 0 4
16455: NOT
16456: IFFALSE 16460
// exit ;
16458: GO 16488
// result := result [ 1 ] ;
16460: LD_ADDR_VAR 0 4
16464: PUSH
16465: LD_VAR 0 4
16469: PUSH
16470: LD_INT 1
16472: ARRAY
16473: ST_TO_ADDR
// Say ( result , dial ) ;
16474: LD_VAR 0 4
16478: PPUSH
16479: LD_VAR 0 2
16483: PPUSH
16484: CALL_OW 88
// end ; end_of_file
16488: LD_VAR 0 4
16492: RET
// export function CustomEvent ( event ) ; begin
16493: LD_INT 0
16495: PPUSH
// end ;
16496: LD_VAR 0 2
16500: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16501: LD_VAR 0 1
16505: PPUSH
16506: CALL_OW 255
16510: PUSH
16511: LD_INT 1
16513: EQUAL
16514: IFFALSE 16524
// artifact_get := true ;
16516: LD_ADDR_EXP 13
16520: PUSH
16521: LD_INT 1
16523: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16524: LD_VAR 0 1
16528: PPUSH
16529: CALL_OW 255
16533: PUSH
16534: LD_INT 2
16536: EQUAL
16537: IFFALSE 16555
// begin artifact_get := false ;
16539: LD_ADDR_EXP 13
16543: PUSH
16544: LD_INT 0
16546: ST_TO_ADDR
// artifact_stolen := true ;
16547: LD_ADDR_EXP 12
16551: PUSH
16552: LD_INT 1
16554: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16555: LD_ADDR_EXP 14
16559: PUSH
16560: LD_INT 1
16562: ST_TO_ADDR
// end ;
16563: PPOPN 2
16565: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16566: LD_ADDR_EXP 14
16570: PUSH
16571: LD_INT 0
16573: ST_TO_ADDR
// end ;
16574: PPOPN 2
16576: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16577: LD_VAR 0 1
16581: PUSH
16582: LD_EXP 21
16586: EQUAL
16587: IFFALSE 16598
// begin YouLost ( JMM ) ;
16589: LD_STRING JMM
16591: PPUSH
16592: CALL_OW 104
// exit ;
16596: GO 16730
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16598: LD_VAR 0 1
16602: PUSH
16603: LD_INT 22
16605: PUSH
16606: LD_INT 1
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: PUSH
16613: LD_INT 21
16615: PUSH
16616: LD_INT 1
16618: PUSH
16619: EMPTY
16620: LIST
16621: LIST
16622: PUSH
16623: LD_INT 2
16625: PUSH
16626: LD_INT 25
16628: PUSH
16629: LD_INT 1
16631: PUSH
16632: EMPTY
16633: LIST
16634: LIST
16635: PUSH
16636: LD_INT 25
16638: PUSH
16639: LD_INT 2
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 25
16648: PUSH
16649: LD_INT 3
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: LD_INT 25
16658: PUSH
16659: LD_INT 4
16661: PUSH
16662: EMPTY
16663: LIST
16664: LIST
16665: PUSH
16666: LD_INT 25
16668: PUSH
16669: LD_INT 5
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PUSH
16676: LD_INT 25
16678: PUSH
16679: LD_INT 8
16681: PUSH
16682: EMPTY
16683: LIST
16684: LIST
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: LIST
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: LIST
16699: PPUSH
16700: CALL_OW 69
16704: IN
16705: IFFALSE 16721
// loses_counter := loses_counter + 1 ;
16707: LD_ADDR_EXP 17
16711: PUSH
16712: LD_EXP 17
16716: PUSH
16717: LD_INT 1
16719: PLUS
16720: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16721: LD_VAR 0 1
16725: PPUSH
16726: CALL 44314 0 1
// end ;
16730: PPOPN 1
16732: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16733: LD_VAR 0 1
16737: PPUSH
16738: LD_VAR 0 2
16742: PPUSH
16743: CALL 46648 0 2
// end ;
16747: PPOPN 2
16749: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16750: LD_VAR 0 1
16754: PPUSH
16755: CALL 45957 0 1
// end ;
16759: PPOPN 1
16761: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16762: LD_VAR 0 1
16766: PPUSH
16767: LD_VAR 0 2
16771: PPUSH
16772: LD_VAR 0 3
16776: PPUSH
16777: LD_VAR 0 4
16781: PPUSH
16782: LD_VAR 0 5
16786: PPUSH
16787: CALL 43630 0 5
// end ;
16791: PPOPN 5
16793: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16794: LD_VAR 0 1
16798: PPUSH
16799: CALL_OW 248
16803: PUSH
16804: LD_INT 1
16806: EQUAL
16807: IFFALSE 16817
// am_veh_consturcted := true ;
16809: LD_ADDR_EXP 20
16813: PUSH
16814: LD_INT 1
16816: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16817: LD_VAR 0 1
16821: PPUSH
16822: LD_VAR 0 2
16826: PPUSH
16827: CALL 43226 0 2
// end ;
16831: PPOPN 2
16833: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16834: LD_VAR 0 1
16838: PPUSH
16839: CALL_OW 247
16843: PUSH
16844: LD_INT 2
16846: EQUAL
16847: IFFALSE 16851
// exit ;
16849: GO 16868
// if not kamikazed then
16851: LD_EXP 11
16855: NOT
16856: IFFALSE 16868
// kamikazed := unit ;
16858: LD_ADDR_EXP 11
16862: PUSH
16863: LD_VAR 0 1
16867: ST_TO_ADDR
// end ;
16868: PPOPN 1
16870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16871: LD_INT 0
16873: PPUSH
16874: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16875: LD_VAR 0 1
16879: PPUSH
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_VAR 0 3
16889: PPUSH
16890: LD_VAR 0 4
16894: PPUSH
16895: CALL 43064 0 4
// end ;
16899: PPOPN 6
16901: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16902: LD_VAR 0 1
16906: PPUSH
16907: LD_VAR 0 2
16911: PPUSH
16912: LD_VAR 0 3
16916: PPUSH
16917: CALL 42839 0 3
// end ;
16921: PPOPN 3
16923: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16924: LD_VAR 0 1
16928: PPUSH
16929: LD_VAR 0 2
16933: PPUSH
16934: CALL 44010 0 2
// end ;
16938: PPOPN 2
16940: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16941: LD_VAR 0 1
16945: PPUSH
16946: LD_VAR 0 2
16950: PPUSH
16951: CALL 42533 0 2
// end ;
16955: PPOPN 2
16957: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16958: LD_VAR 0 1
16962: PPUSH
16963: LD_VAR 0 2
16967: PPUSH
16968: CALL 42724 0 2
// end ;
16972: PPOPN 2
16974: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16975: LD_VAR 0 1
16979: PPUSH
16980: CALL 45716 0 1
// end ;
16984: PPOPN 1
16986: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16987: LD_VAR 0 1
16991: PPUSH
16992: LD_VAR 0 2
16996: PPUSH
16997: CALL 46909 0 2
// end ;
17001: PPOPN 2
17003: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17004: LD_VAR 0 1
17008: PPUSH
17009: LD_VAR 0 2
17013: PPUSH
17014: LD_VAR 0 3
17018: PPUSH
17019: LD_VAR 0 4
17023: PPUSH
17024: CALL 47125 0 4
// end ;
17028: PPOPN 4
17030: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17031: LD_VAR 0 1
17035: PPUSH
17036: CALL 90596 0 1
// end ; end_of_file
17040: PPOPN 1
17042: END
// every 0 0$1 trigger game do
17043: LD_EXP 2
17047: IFFALSE 17077
17049: GO 17051
17051: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17052: LD_INT 7
17054: PUSH
17055: LD_INT 6
17057: PUSH
17058: LD_INT 4
17060: PUSH
17061: LD_INT 6
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: LIST
17068: LIST
17069: PPUSH
17070: LD_INT 1750
17072: PPUSH
17073: CALL 17078 0 2
17077: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17078: LD_INT 0
17080: PPUSH
17081: PPUSH
17082: PPUSH
// if not areas then
17083: LD_VAR 0 1
17087: NOT
17088: IFFALSE 17092
// exit ;
17090: GO 17222
// repeat wait ( time ) ;
17092: LD_VAR 0 2
17096: PPUSH
17097: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17101: LD_ADDR_VAR 0 5
17105: PUSH
17106: LD_INT 1
17108: PPUSH
17109: LD_INT 90
17111: PPUSH
17112: CALL_OW 12
17116: ST_TO_ADDR
// for i in areas do
17117: LD_ADDR_VAR 0 4
17121: PUSH
17122: LD_VAR 0 1
17126: PUSH
17127: FOR_IN
17128: IFFALSE 17181
// begin if Prob ( p ) then
17130: LD_VAR 0 5
17134: PPUSH
17135: CALL_OW 13
17139: IFFALSE 17179
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17141: LD_INT 1
17143: PPUSH
17144: LD_INT 5
17146: PPUSH
17147: CALL_OW 12
17151: PPUSH
17152: LD_VAR 0 4
17156: PPUSH
17157: LD_INT 1
17159: PPUSH
17160: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17164: LD_INT 385
17166: PPUSH
17167: LD_INT 595
17169: PPUSH
17170: CALL_OW 12
17174: PPUSH
17175: CALL_OW 67
// end ; end ;
17179: GO 17127
17181: POP
17182: POP
// time := time + 0 0$3 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_VAR 0 2
17192: PUSH
17193: LD_INT 105
17195: PLUS
17196: ST_TO_ADDR
// if time > 7 7$00 then
17197: LD_VAR 0 2
17201: PUSH
17202: LD_INT 14700
17204: GREATER
17205: IFFALSE 17215
// time := 0 0$40 ;
17207: LD_ADDR_VAR 0 2
17211: PUSH
17212: LD_INT 1400
17214: ST_TO_ADDR
// until not game ;
17215: LD_EXP 2
17219: NOT
17220: IFFALSE 17092
// end ; end_of_file
17222: LD_VAR 0 3
17226: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17227: LD_INT 0
17229: PPUSH
17230: PPUSH
// skirmish := false ;
17231: LD_ADDR_EXP 48
17235: PUSH
17236: LD_INT 0
17238: ST_TO_ADDR
// debug_mc := false ;
17239: LD_ADDR_EXP 49
17243: PUSH
17244: LD_INT 0
17246: ST_TO_ADDR
// mc_bases := [ ] ;
17247: LD_ADDR_EXP 50
17251: PUSH
17252: EMPTY
17253: ST_TO_ADDR
// mc_sides := [ ] ;
17254: LD_ADDR_EXP 76
17258: PUSH
17259: EMPTY
17260: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17261: LD_ADDR_EXP 51
17265: PUSH
17266: EMPTY
17267: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17268: LD_ADDR_EXP 52
17272: PUSH
17273: EMPTY
17274: ST_TO_ADDR
// mc_need_heal := [ ] ;
17275: LD_ADDR_EXP 53
17279: PUSH
17280: EMPTY
17281: ST_TO_ADDR
// mc_healers := [ ] ;
17282: LD_ADDR_EXP 54
17286: PUSH
17287: EMPTY
17288: ST_TO_ADDR
// mc_build_list := [ ] ;
17289: LD_ADDR_EXP 55
17293: PUSH
17294: EMPTY
17295: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17296: LD_ADDR_EXP 82
17300: PUSH
17301: EMPTY
17302: ST_TO_ADDR
// mc_builders := [ ] ;
17303: LD_ADDR_EXP 56
17307: PUSH
17308: EMPTY
17309: ST_TO_ADDR
// mc_construct_list := [ ] ;
17310: LD_ADDR_EXP 57
17314: PUSH
17315: EMPTY
17316: ST_TO_ADDR
// mc_turret_list := [ ] ;
17317: LD_ADDR_EXP 58
17321: PUSH
17322: EMPTY
17323: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17324: LD_ADDR_EXP 59
17328: PUSH
17329: EMPTY
17330: ST_TO_ADDR
// mc_miners := [ ] ;
17331: LD_ADDR_EXP 64
17335: PUSH
17336: EMPTY
17337: ST_TO_ADDR
// mc_mines := [ ] ;
17338: LD_ADDR_EXP 63
17342: PUSH
17343: EMPTY
17344: ST_TO_ADDR
// mc_minefields := [ ] ;
17345: LD_ADDR_EXP 65
17349: PUSH
17350: EMPTY
17351: ST_TO_ADDR
// mc_crates := [ ] ;
17352: LD_ADDR_EXP 66
17356: PUSH
17357: EMPTY
17358: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17359: LD_ADDR_EXP 67
17363: PUSH
17364: EMPTY
17365: ST_TO_ADDR
// mc_crates_area := [ ] ;
17366: LD_ADDR_EXP 68
17370: PUSH
17371: EMPTY
17372: ST_TO_ADDR
// mc_vehicles := [ ] ;
17373: LD_ADDR_EXP 69
17377: PUSH
17378: EMPTY
17379: ST_TO_ADDR
// mc_attack := [ ] ;
17380: LD_ADDR_EXP 70
17384: PUSH
17385: EMPTY
17386: ST_TO_ADDR
// mc_produce := [ ] ;
17387: LD_ADDR_EXP 71
17391: PUSH
17392: EMPTY
17393: ST_TO_ADDR
// mc_defender := [ ] ;
17394: LD_ADDR_EXP 72
17398: PUSH
17399: EMPTY
17400: ST_TO_ADDR
// mc_parking := [ ] ;
17401: LD_ADDR_EXP 74
17405: PUSH
17406: EMPTY
17407: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17408: LD_ADDR_EXP 60
17412: PUSH
17413: EMPTY
17414: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17415: LD_ADDR_EXP 62
17419: PUSH
17420: EMPTY
17421: ST_TO_ADDR
// mc_scan := [ ] ;
17422: LD_ADDR_EXP 73
17426: PUSH
17427: EMPTY
17428: ST_TO_ADDR
// mc_scan_area := [ ] ;
17429: LD_ADDR_EXP 75
17433: PUSH
17434: EMPTY
17435: ST_TO_ADDR
// mc_tech := [ ] ;
17436: LD_ADDR_EXP 77
17440: PUSH
17441: EMPTY
17442: ST_TO_ADDR
// mc_class := [ ] ;
17443: LD_ADDR_EXP 91
17447: PUSH
17448: EMPTY
17449: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17450: LD_ADDR_EXP 92
17454: PUSH
17455: EMPTY
17456: ST_TO_ADDR
// end ;
17457: LD_VAR 0 1
17461: RET
// export function MC_Kill ( base ) ; begin
17462: LD_INT 0
17464: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17465: LD_ADDR_EXP 50
17469: PUSH
17470: LD_EXP 50
17474: PPUSH
17475: LD_VAR 0 1
17479: PPUSH
17480: EMPTY
17481: PPUSH
17482: CALL_OW 1
17486: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17487: LD_ADDR_EXP 51
17491: PUSH
17492: LD_EXP 51
17496: PPUSH
17497: LD_VAR 0 1
17501: PPUSH
17502: EMPTY
17503: PPUSH
17504: CALL_OW 1
17508: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17509: LD_ADDR_EXP 52
17513: PUSH
17514: LD_EXP 52
17518: PPUSH
17519: LD_VAR 0 1
17523: PPUSH
17524: EMPTY
17525: PPUSH
17526: CALL_OW 1
17530: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17531: LD_ADDR_EXP 53
17535: PUSH
17536: LD_EXP 53
17540: PPUSH
17541: LD_VAR 0 1
17545: PPUSH
17546: EMPTY
17547: PPUSH
17548: CALL_OW 1
17552: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17553: LD_ADDR_EXP 54
17557: PUSH
17558: LD_EXP 54
17562: PPUSH
17563: LD_VAR 0 1
17567: PPUSH
17568: EMPTY
17569: PPUSH
17570: CALL_OW 1
17574: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17575: LD_ADDR_EXP 55
17579: PUSH
17580: LD_EXP 55
17584: PPUSH
17585: LD_VAR 0 1
17589: PPUSH
17590: EMPTY
17591: PPUSH
17592: CALL_OW 1
17596: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17597: LD_ADDR_EXP 56
17601: PUSH
17602: LD_EXP 56
17606: PPUSH
17607: LD_VAR 0 1
17611: PPUSH
17612: EMPTY
17613: PPUSH
17614: CALL_OW 1
17618: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17619: LD_ADDR_EXP 57
17623: PUSH
17624: LD_EXP 57
17628: PPUSH
17629: LD_VAR 0 1
17633: PPUSH
17634: EMPTY
17635: PPUSH
17636: CALL_OW 1
17640: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17641: LD_ADDR_EXP 58
17645: PUSH
17646: LD_EXP 58
17650: PPUSH
17651: LD_VAR 0 1
17655: PPUSH
17656: EMPTY
17657: PPUSH
17658: CALL_OW 1
17662: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17663: LD_ADDR_EXP 59
17667: PUSH
17668: LD_EXP 59
17672: PPUSH
17673: LD_VAR 0 1
17677: PPUSH
17678: EMPTY
17679: PPUSH
17680: CALL_OW 1
17684: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17685: LD_ADDR_EXP 60
17689: PUSH
17690: LD_EXP 60
17694: PPUSH
17695: LD_VAR 0 1
17699: PPUSH
17700: EMPTY
17701: PPUSH
17702: CALL_OW 1
17706: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17707: LD_ADDR_EXP 61
17711: PUSH
17712: LD_EXP 61
17716: PPUSH
17717: LD_VAR 0 1
17721: PPUSH
17722: LD_INT 0
17724: PPUSH
17725: CALL_OW 1
17729: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17730: LD_ADDR_EXP 62
17734: PUSH
17735: LD_EXP 62
17739: PPUSH
17740: LD_VAR 0 1
17744: PPUSH
17745: EMPTY
17746: PPUSH
17747: CALL_OW 1
17751: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17752: LD_ADDR_EXP 63
17756: PUSH
17757: LD_EXP 63
17761: PPUSH
17762: LD_VAR 0 1
17766: PPUSH
17767: EMPTY
17768: PPUSH
17769: CALL_OW 1
17773: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17774: LD_ADDR_EXP 64
17778: PUSH
17779: LD_EXP 64
17783: PPUSH
17784: LD_VAR 0 1
17788: PPUSH
17789: EMPTY
17790: PPUSH
17791: CALL_OW 1
17795: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17796: LD_ADDR_EXP 65
17800: PUSH
17801: LD_EXP 65
17805: PPUSH
17806: LD_VAR 0 1
17810: PPUSH
17811: EMPTY
17812: PPUSH
17813: CALL_OW 1
17817: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17818: LD_ADDR_EXP 66
17822: PUSH
17823: LD_EXP 66
17827: PPUSH
17828: LD_VAR 0 1
17832: PPUSH
17833: EMPTY
17834: PPUSH
17835: CALL_OW 1
17839: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17840: LD_ADDR_EXP 67
17844: PUSH
17845: LD_EXP 67
17849: PPUSH
17850: LD_VAR 0 1
17854: PPUSH
17855: EMPTY
17856: PPUSH
17857: CALL_OW 1
17861: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17862: LD_ADDR_EXP 68
17866: PUSH
17867: LD_EXP 68
17871: PPUSH
17872: LD_VAR 0 1
17876: PPUSH
17877: EMPTY
17878: PPUSH
17879: CALL_OW 1
17883: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17884: LD_ADDR_EXP 69
17888: PUSH
17889: LD_EXP 69
17893: PPUSH
17894: LD_VAR 0 1
17898: PPUSH
17899: EMPTY
17900: PPUSH
17901: CALL_OW 1
17905: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17906: LD_ADDR_EXP 70
17910: PUSH
17911: LD_EXP 70
17915: PPUSH
17916: LD_VAR 0 1
17920: PPUSH
17921: EMPTY
17922: PPUSH
17923: CALL_OW 1
17927: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17928: LD_ADDR_EXP 71
17932: PUSH
17933: LD_EXP 71
17937: PPUSH
17938: LD_VAR 0 1
17942: PPUSH
17943: EMPTY
17944: PPUSH
17945: CALL_OW 1
17949: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17950: LD_ADDR_EXP 72
17954: PUSH
17955: LD_EXP 72
17959: PPUSH
17960: LD_VAR 0 1
17964: PPUSH
17965: EMPTY
17966: PPUSH
17967: CALL_OW 1
17971: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17972: LD_ADDR_EXP 73
17976: PUSH
17977: LD_EXP 73
17981: PPUSH
17982: LD_VAR 0 1
17986: PPUSH
17987: EMPTY
17988: PPUSH
17989: CALL_OW 1
17993: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17994: LD_ADDR_EXP 74
17998: PUSH
17999: LD_EXP 74
18003: PPUSH
18004: LD_VAR 0 1
18008: PPUSH
18009: EMPTY
18010: PPUSH
18011: CALL_OW 1
18015: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18016: LD_ADDR_EXP 75
18020: PUSH
18021: LD_EXP 75
18025: PPUSH
18026: LD_VAR 0 1
18030: PPUSH
18031: EMPTY
18032: PPUSH
18033: CALL_OW 1
18037: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18038: LD_ADDR_EXP 77
18042: PUSH
18043: LD_EXP 77
18047: PPUSH
18048: LD_VAR 0 1
18052: PPUSH
18053: EMPTY
18054: PPUSH
18055: CALL_OW 1
18059: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18060: LD_ADDR_EXP 79
18064: PUSH
18065: LD_EXP 79
18069: PPUSH
18070: LD_VAR 0 1
18074: PPUSH
18075: EMPTY
18076: PPUSH
18077: CALL_OW 1
18081: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18082: LD_ADDR_EXP 80
18086: PUSH
18087: LD_EXP 80
18091: PPUSH
18092: LD_VAR 0 1
18096: PPUSH
18097: EMPTY
18098: PPUSH
18099: CALL_OW 1
18103: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18104: LD_ADDR_EXP 81
18108: PUSH
18109: LD_EXP 81
18113: PPUSH
18114: LD_VAR 0 1
18118: PPUSH
18119: EMPTY
18120: PPUSH
18121: CALL_OW 1
18125: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18126: LD_ADDR_EXP 82
18130: PUSH
18131: LD_EXP 82
18135: PPUSH
18136: LD_VAR 0 1
18140: PPUSH
18141: EMPTY
18142: PPUSH
18143: CALL_OW 1
18147: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18148: LD_ADDR_EXP 83
18152: PUSH
18153: LD_EXP 83
18157: PPUSH
18158: LD_VAR 0 1
18162: PPUSH
18163: EMPTY
18164: PPUSH
18165: CALL_OW 1
18169: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18170: LD_ADDR_EXP 84
18174: PUSH
18175: LD_EXP 84
18179: PPUSH
18180: LD_VAR 0 1
18184: PPUSH
18185: EMPTY
18186: PPUSH
18187: CALL_OW 1
18191: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18192: LD_ADDR_EXP 85
18196: PUSH
18197: LD_EXP 85
18201: PPUSH
18202: LD_VAR 0 1
18206: PPUSH
18207: EMPTY
18208: PPUSH
18209: CALL_OW 1
18213: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18214: LD_ADDR_EXP 86
18218: PUSH
18219: LD_EXP 86
18223: PPUSH
18224: LD_VAR 0 1
18228: PPUSH
18229: EMPTY
18230: PPUSH
18231: CALL_OW 1
18235: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18236: LD_ADDR_EXP 87
18240: PUSH
18241: LD_EXP 87
18245: PPUSH
18246: LD_VAR 0 1
18250: PPUSH
18251: EMPTY
18252: PPUSH
18253: CALL_OW 1
18257: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18258: LD_ADDR_EXP 88
18262: PUSH
18263: LD_EXP 88
18267: PPUSH
18268: LD_VAR 0 1
18272: PPUSH
18273: EMPTY
18274: PPUSH
18275: CALL_OW 1
18279: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18280: LD_ADDR_EXP 89
18284: PUSH
18285: LD_EXP 89
18289: PPUSH
18290: LD_VAR 0 1
18294: PPUSH
18295: EMPTY
18296: PPUSH
18297: CALL_OW 1
18301: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18302: LD_ADDR_EXP 90
18306: PUSH
18307: LD_EXP 90
18311: PPUSH
18312: LD_VAR 0 1
18316: PPUSH
18317: EMPTY
18318: PPUSH
18319: CALL_OW 1
18323: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18324: LD_ADDR_EXP 91
18328: PUSH
18329: LD_EXP 91
18333: PPUSH
18334: LD_VAR 0 1
18338: PPUSH
18339: EMPTY
18340: PPUSH
18341: CALL_OW 1
18345: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18346: LD_ADDR_EXP 92
18350: PUSH
18351: LD_EXP 92
18355: PPUSH
18356: LD_VAR 0 1
18360: PPUSH
18361: LD_INT 0
18363: PPUSH
18364: CALL_OW 1
18368: ST_TO_ADDR
// end ;
18369: LD_VAR 0 2
18373: RET
// export function MC_Add ( side , units ) ; var base ; begin
18374: LD_INT 0
18376: PPUSH
18377: PPUSH
// base := mc_bases + 1 ;
18378: LD_ADDR_VAR 0 4
18382: PUSH
18383: LD_EXP 50
18387: PUSH
18388: LD_INT 1
18390: PLUS
18391: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18392: LD_ADDR_EXP 76
18396: PUSH
18397: LD_EXP 76
18401: PPUSH
18402: LD_VAR 0 4
18406: PPUSH
18407: LD_VAR 0 1
18411: PPUSH
18412: CALL_OW 1
18416: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18417: LD_ADDR_EXP 50
18421: PUSH
18422: LD_EXP 50
18426: PPUSH
18427: LD_VAR 0 4
18431: PPUSH
18432: LD_VAR 0 2
18436: PPUSH
18437: CALL_OW 1
18441: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18442: LD_ADDR_EXP 51
18446: PUSH
18447: LD_EXP 51
18451: PPUSH
18452: LD_VAR 0 4
18456: PPUSH
18457: EMPTY
18458: PPUSH
18459: CALL_OW 1
18463: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18464: LD_ADDR_EXP 52
18468: PUSH
18469: LD_EXP 52
18473: PPUSH
18474: LD_VAR 0 4
18478: PPUSH
18479: EMPTY
18480: PPUSH
18481: CALL_OW 1
18485: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18486: LD_ADDR_EXP 53
18490: PUSH
18491: LD_EXP 53
18495: PPUSH
18496: LD_VAR 0 4
18500: PPUSH
18501: EMPTY
18502: PPUSH
18503: CALL_OW 1
18507: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18508: LD_ADDR_EXP 54
18512: PUSH
18513: LD_EXP 54
18517: PPUSH
18518: LD_VAR 0 4
18522: PPUSH
18523: EMPTY
18524: PPUSH
18525: CALL_OW 1
18529: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18530: LD_ADDR_EXP 55
18534: PUSH
18535: LD_EXP 55
18539: PPUSH
18540: LD_VAR 0 4
18544: PPUSH
18545: EMPTY
18546: PPUSH
18547: CALL_OW 1
18551: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18552: LD_ADDR_EXP 56
18556: PUSH
18557: LD_EXP 56
18561: PPUSH
18562: LD_VAR 0 4
18566: PPUSH
18567: EMPTY
18568: PPUSH
18569: CALL_OW 1
18573: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18574: LD_ADDR_EXP 57
18578: PUSH
18579: LD_EXP 57
18583: PPUSH
18584: LD_VAR 0 4
18588: PPUSH
18589: EMPTY
18590: PPUSH
18591: CALL_OW 1
18595: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18596: LD_ADDR_EXP 58
18600: PUSH
18601: LD_EXP 58
18605: PPUSH
18606: LD_VAR 0 4
18610: PPUSH
18611: EMPTY
18612: PPUSH
18613: CALL_OW 1
18617: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18618: LD_ADDR_EXP 59
18622: PUSH
18623: LD_EXP 59
18627: PPUSH
18628: LD_VAR 0 4
18632: PPUSH
18633: EMPTY
18634: PPUSH
18635: CALL_OW 1
18639: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18640: LD_ADDR_EXP 60
18644: PUSH
18645: LD_EXP 60
18649: PPUSH
18650: LD_VAR 0 4
18654: PPUSH
18655: EMPTY
18656: PPUSH
18657: CALL_OW 1
18661: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18662: LD_ADDR_EXP 61
18666: PUSH
18667: LD_EXP 61
18671: PPUSH
18672: LD_VAR 0 4
18676: PPUSH
18677: LD_INT 0
18679: PPUSH
18680: CALL_OW 1
18684: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18685: LD_ADDR_EXP 62
18689: PUSH
18690: LD_EXP 62
18694: PPUSH
18695: LD_VAR 0 4
18699: PPUSH
18700: EMPTY
18701: PPUSH
18702: CALL_OW 1
18706: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18707: LD_ADDR_EXP 63
18711: PUSH
18712: LD_EXP 63
18716: PPUSH
18717: LD_VAR 0 4
18721: PPUSH
18722: EMPTY
18723: PPUSH
18724: CALL_OW 1
18728: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18729: LD_ADDR_EXP 64
18733: PUSH
18734: LD_EXP 64
18738: PPUSH
18739: LD_VAR 0 4
18743: PPUSH
18744: EMPTY
18745: PPUSH
18746: CALL_OW 1
18750: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18751: LD_ADDR_EXP 65
18755: PUSH
18756: LD_EXP 65
18760: PPUSH
18761: LD_VAR 0 4
18765: PPUSH
18766: EMPTY
18767: PPUSH
18768: CALL_OW 1
18772: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18773: LD_ADDR_EXP 66
18777: PUSH
18778: LD_EXP 66
18782: PPUSH
18783: LD_VAR 0 4
18787: PPUSH
18788: EMPTY
18789: PPUSH
18790: CALL_OW 1
18794: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18795: LD_ADDR_EXP 67
18799: PUSH
18800: LD_EXP 67
18804: PPUSH
18805: LD_VAR 0 4
18809: PPUSH
18810: EMPTY
18811: PPUSH
18812: CALL_OW 1
18816: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18817: LD_ADDR_EXP 68
18821: PUSH
18822: LD_EXP 68
18826: PPUSH
18827: LD_VAR 0 4
18831: PPUSH
18832: EMPTY
18833: PPUSH
18834: CALL_OW 1
18838: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18839: LD_ADDR_EXP 69
18843: PUSH
18844: LD_EXP 69
18848: PPUSH
18849: LD_VAR 0 4
18853: PPUSH
18854: EMPTY
18855: PPUSH
18856: CALL_OW 1
18860: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18861: LD_ADDR_EXP 70
18865: PUSH
18866: LD_EXP 70
18870: PPUSH
18871: LD_VAR 0 4
18875: PPUSH
18876: EMPTY
18877: PPUSH
18878: CALL_OW 1
18882: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18883: LD_ADDR_EXP 71
18887: PUSH
18888: LD_EXP 71
18892: PPUSH
18893: LD_VAR 0 4
18897: PPUSH
18898: EMPTY
18899: PPUSH
18900: CALL_OW 1
18904: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18905: LD_ADDR_EXP 72
18909: PUSH
18910: LD_EXP 72
18914: PPUSH
18915: LD_VAR 0 4
18919: PPUSH
18920: EMPTY
18921: PPUSH
18922: CALL_OW 1
18926: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18927: LD_ADDR_EXP 73
18931: PUSH
18932: LD_EXP 73
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: EMPTY
18943: PPUSH
18944: CALL_OW 1
18948: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18949: LD_ADDR_EXP 74
18953: PUSH
18954: LD_EXP 74
18958: PPUSH
18959: LD_VAR 0 4
18963: PPUSH
18964: EMPTY
18965: PPUSH
18966: CALL_OW 1
18970: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18971: LD_ADDR_EXP 75
18975: PUSH
18976: LD_EXP 75
18980: PPUSH
18981: LD_VAR 0 4
18985: PPUSH
18986: EMPTY
18987: PPUSH
18988: CALL_OW 1
18992: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18993: LD_ADDR_EXP 77
18997: PUSH
18998: LD_EXP 77
19002: PPUSH
19003: LD_VAR 0 4
19007: PPUSH
19008: EMPTY
19009: PPUSH
19010: CALL_OW 1
19014: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19015: LD_ADDR_EXP 79
19019: PUSH
19020: LD_EXP 79
19024: PPUSH
19025: LD_VAR 0 4
19029: PPUSH
19030: EMPTY
19031: PPUSH
19032: CALL_OW 1
19036: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19037: LD_ADDR_EXP 80
19041: PUSH
19042: LD_EXP 80
19046: PPUSH
19047: LD_VAR 0 4
19051: PPUSH
19052: EMPTY
19053: PPUSH
19054: CALL_OW 1
19058: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19059: LD_ADDR_EXP 81
19063: PUSH
19064: LD_EXP 81
19068: PPUSH
19069: LD_VAR 0 4
19073: PPUSH
19074: EMPTY
19075: PPUSH
19076: CALL_OW 1
19080: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19081: LD_ADDR_EXP 82
19085: PUSH
19086: LD_EXP 82
19090: PPUSH
19091: LD_VAR 0 4
19095: PPUSH
19096: EMPTY
19097: PPUSH
19098: CALL_OW 1
19102: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19103: LD_ADDR_EXP 83
19107: PUSH
19108: LD_EXP 83
19112: PPUSH
19113: LD_VAR 0 4
19117: PPUSH
19118: EMPTY
19119: PPUSH
19120: CALL_OW 1
19124: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19125: LD_ADDR_EXP 84
19129: PUSH
19130: LD_EXP 84
19134: PPUSH
19135: LD_VAR 0 4
19139: PPUSH
19140: EMPTY
19141: PPUSH
19142: CALL_OW 1
19146: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19147: LD_ADDR_EXP 85
19151: PUSH
19152: LD_EXP 85
19156: PPUSH
19157: LD_VAR 0 4
19161: PPUSH
19162: EMPTY
19163: PPUSH
19164: CALL_OW 1
19168: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19169: LD_ADDR_EXP 86
19173: PUSH
19174: LD_EXP 86
19178: PPUSH
19179: LD_VAR 0 4
19183: PPUSH
19184: EMPTY
19185: PPUSH
19186: CALL_OW 1
19190: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19191: LD_ADDR_EXP 87
19195: PUSH
19196: LD_EXP 87
19200: PPUSH
19201: LD_VAR 0 4
19205: PPUSH
19206: EMPTY
19207: PPUSH
19208: CALL_OW 1
19212: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19213: LD_ADDR_EXP 88
19217: PUSH
19218: LD_EXP 88
19222: PPUSH
19223: LD_VAR 0 4
19227: PPUSH
19228: EMPTY
19229: PPUSH
19230: CALL_OW 1
19234: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19235: LD_ADDR_EXP 89
19239: PUSH
19240: LD_EXP 89
19244: PPUSH
19245: LD_VAR 0 4
19249: PPUSH
19250: EMPTY
19251: PPUSH
19252: CALL_OW 1
19256: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19257: LD_ADDR_EXP 90
19261: PUSH
19262: LD_EXP 90
19266: PPUSH
19267: LD_VAR 0 4
19271: PPUSH
19272: EMPTY
19273: PPUSH
19274: CALL_OW 1
19278: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19279: LD_ADDR_EXP 91
19283: PUSH
19284: LD_EXP 91
19288: PPUSH
19289: LD_VAR 0 4
19293: PPUSH
19294: EMPTY
19295: PPUSH
19296: CALL_OW 1
19300: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19301: LD_ADDR_EXP 92
19305: PUSH
19306: LD_EXP 92
19310: PPUSH
19311: LD_VAR 0 4
19315: PPUSH
19316: LD_INT 0
19318: PPUSH
19319: CALL_OW 1
19323: ST_TO_ADDR
// result := base ;
19324: LD_ADDR_VAR 0 3
19328: PUSH
19329: LD_VAR 0 4
19333: ST_TO_ADDR
// end ;
19334: LD_VAR 0 3
19338: RET
// export function MC_Start ( ) ; var i ; begin
19339: LD_INT 0
19341: PPUSH
19342: PPUSH
// for i = 1 to mc_bases do
19343: LD_ADDR_VAR 0 2
19347: PUSH
19348: DOUBLE
19349: LD_INT 1
19351: DEC
19352: ST_TO_ADDR
19353: LD_EXP 50
19357: PUSH
19358: FOR_TO
19359: IFFALSE 20436
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19361: LD_ADDR_EXP 50
19365: PUSH
19366: LD_EXP 50
19370: PPUSH
19371: LD_VAR 0 2
19375: PPUSH
19376: LD_EXP 50
19380: PUSH
19381: LD_VAR 0 2
19385: ARRAY
19386: PUSH
19387: LD_INT 0
19389: DIFF
19390: PPUSH
19391: CALL_OW 1
19395: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19396: LD_ADDR_EXP 51
19400: PUSH
19401: LD_EXP 51
19405: PPUSH
19406: LD_VAR 0 2
19410: PPUSH
19411: EMPTY
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19418: LD_ADDR_EXP 52
19422: PUSH
19423: LD_EXP 52
19427: PPUSH
19428: LD_VAR 0 2
19432: PPUSH
19433: EMPTY
19434: PPUSH
19435: CALL_OW 1
19439: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19440: LD_ADDR_EXP 53
19444: PUSH
19445: LD_EXP 53
19449: PPUSH
19450: LD_VAR 0 2
19454: PPUSH
19455: EMPTY
19456: PPUSH
19457: CALL_OW 1
19461: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19462: LD_ADDR_EXP 54
19466: PUSH
19467: LD_EXP 54
19471: PPUSH
19472: LD_VAR 0 2
19476: PPUSH
19477: EMPTY
19478: PUSH
19479: EMPTY
19480: PUSH
19481: EMPTY
19482: LIST
19483: LIST
19484: PPUSH
19485: CALL_OW 1
19489: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19490: LD_ADDR_EXP 55
19494: PUSH
19495: LD_EXP 55
19499: PPUSH
19500: LD_VAR 0 2
19504: PPUSH
19505: EMPTY
19506: PPUSH
19507: CALL_OW 1
19511: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19512: LD_ADDR_EXP 82
19516: PUSH
19517: LD_EXP 82
19521: PPUSH
19522: LD_VAR 0 2
19526: PPUSH
19527: EMPTY
19528: PPUSH
19529: CALL_OW 1
19533: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19534: LD_ADDR_EXP 56
19538: PUSH
19539: LD_EXP 56
19543: PPUSH
19544: LD_VAR 0 2
19548: PPUSH
19549: EMPTY
19550: PPUSH
19551: CALL_OW 1
19555: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19556: LD_ADDR_EXP 57
19560: PUSH
19561: LD_EXP 57
19565: PPUSH
19566: LD_VAR 0 2
19570: PPUSH
19571: EMPTY
19572: PPUSH
19573: CALL_OW 1
19577: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19578: LD_ADDR_EXP 58
19582: PUSH
19583: LD_EXP 58
19587: PPUSH
19588: LD_VAR 0 2
19592: PPUSH
19593: LD_EXP 50
19597: PUSH
19598: LD_VAR 0 2
19602: ARRAY
19603: PPUSH
19604: LD_INT 2
19606: PUSH
19607: LD_INT 30
19609: PUSH
19610: LD_INT 32
19612: PUSH
19613: EMPTY
19614: LIST
19615: LIST
19616: PUSH
19617: LD_INT 30
19619: PUSH
19620: LD_INT 33
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: LIST
19631: PPUSH
19632: CALL_OW 72
19636: PPUSH
19637: CALL_OW 1
19641: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19642: LD_ADDR_EXP 59
19646: PUSH
19647: LD_EXP 59
19651: PPUSH
19652: LD_VAR 0 2
19656: PPUSH
19657: LD_EXP 50
19661: PUSH
19662: LD_VAR 0 2
19666: ARRAY
19667: PPUSH
19668: LD_INT 2
19670: PUSH
19671: LD_INT 30
19673: PUSH
19674: LD_INT 32
19676: PUSH
19677: EMPTY
19678: LIST
19679: LIST
19680: PUSH
19681: LD_INT 30
19683: PUSH
19684: LD_INT 31
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: PUSH
19691: EMPTY
19692: LIST
19693: LIST
19694: LIST
19695: PUSH
19696: LD_INT 58
19698: PUSH
19699: EMPTY
19700: LIST
19701: PUSH
19702: EMPTY
19703: LIST
19704: LIST
19705: PPUSH
19706: CALL_OW 72
19710: PPUSH
19711: CALL_OW 1
19715: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19716: LD_ADDR_EXP 60
19720: PUSH
19721: LD_EXP 60
19725: PPUSH
19726: LD_VAR 0 2
19730: PPUSH
19731: EMPTY
19732: PPUSH
19733: CALL_OW 1
19737: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19738: LD_ADDR_EXP 64
19742: PUSH
19743: LD_EXP 64
19747: PPUSH
19748: LD_VAR 0 2
19752: PPUSH
19753: EMPTY
19754: PPUSH
19755: CALL_OW 1
19759: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19760: LD_ADDR_EXP 63
19764: PUSH
19765: LD_EXP 63
19769: PPUSH
19770: LD_VAR 0 2
19774: PPUSH
19775: EMPTY
19776: PPUSH
19777: CALL_OW 1
19781: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19782: LD_ADDR_EXP 65
19786: PUSH
19787: LD_EXP 65
19791: PPUSH
19792: LD_VAR 0 2
19796: PPUSH
19797: EMPTY
19798: PPUSH
19799: CALL_OW 1
19803: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19804: LD_ADDR_EXP 66
19808: PUSH
19809: LD_EXP 66
19813: PPUSH
19814: LD_VAR 0 2
19818: PPUSH
19819: EMPTY
19820: PPUSH
19821: CALL_OW 1
19825: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19826: LD_ADDR_EXP 67
19830: PUSH
19831: LD_EXP 67
19835: PPUSH
19836: LD_VAR 0 2
19840: PPUSH
19841: EMPTY
19842: PPUSH
19843: CALL_OW 1
19847: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19848: LD_ADDR_EXP 68
19852: PUSH
19853: LD_EXP 68
19857: PPUSH
19858: LD_VAR 0 2
19862: PPUSH
19863: EMPTY
19864: PPUSH
19865: CALL_OW 1
19869: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
19870: LD_ADDR_EXP 69
19874: PUSH
19875: LD_EXP 69
19879: PPUSH
19880: LD_VAR 0 2
19884: PPUSH
19885: EMPTY
19886: PPUSH
19887: CALL_OW 1
19891: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
19892: LD_ADDR_EXP 70
19896: PUSH
19897: LD_EXP 70
19901: PPUSH
19902: LD_VAR 0 2
19906: PPUSH
19907: EMPTY
19908: PPUSH
19909: CALL_OW 1
19913: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
19914: LD_ADDR_EXP 71
19918: PUSH
19919: LD_EXP 71
19923: PPUSH
19924: LD_VAR 0 2
19928: PPUSH
19929: EMPTY
19930: PPUSH
19931: CALL_OW 1
19935: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
19936: LD_ADDR_EXP 72
19940: PUSH
19941: LD_EXP 72
19945: PPUSH
19946: LD_VAR 0 2
19950: PPUSH
19951: EMPTY
19952: PPUSH
19953: CALL_OW 1
19957: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
19958: LD_ADDR_EXP 61
19962: PUSH
19963: LD_EXP 61
19967: PPUSH
19968: LD_VAR 0 2
19972: PPUSH
19973: LD_INT 0
19975: PPUSH
19976: CALL_OW 1
19980: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
19981: LD_ADDR_EXP 74
19985: PUSH
19986: LD_EXP 74
19990: PPUSH
19991: LD_VAR 0 2
19995: PPUSH
19996: LD_INT 0
19998: PPUSH
19999: CALL_OW 1
20003: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20004: LD_ADDR_EXP 62
20008: PUSH
20009: LD_EXP 62
20013: PPUSH
20014: LD_VAR 0 2
20018: PPUSH
20019: EMPTY
20020: PPUSH
20021: CALL_OW 1
20025: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20026: LD_ADDR_EXP 73
20030: PUSH
20031: LD_EXP 73
20035: PPUSH
20036: LD_VAR 0 2
20040: PPUSH
20041: LD_INT 0
20043: PPUSH
20044: CALL_OW 1
20048: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20049: LD_ADDR_EXP 75
20053: PUSH
20054: LD_EXP 75
20058: PPUSH
20059: LD_VAR 0 2
20063: PPUSH
20064: EMPTY
20065: PPUSH
20066: CALL_OW 1
20070: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20071: LD_ADDR_EXP 78
20075: PUSH
20076: LD_EXP 78
20080: PPUSH
20081: LD_VAR 0 2
20085: PPUSH
20086: LD_INT 0
20088: PPUSH
20089: CALL_OW 1
20093: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20094: LD_ADDR_EXP 79
20098: PUSH
20099: LD_EXP 79
20103: PPUSH
20104: LD_VAR 0 2
20108: PPUSH
20109: EMPTY
20110: PPUSH
20111: CALL_OW 1
20115: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20116: LD_ADDR_EXP 80
20120: PUSH
20121: LD_EXP 80
20125: PPUSH
20126: LD_VAR 0 2
20130: PPUSH
20131: EMPTY
20132: PPUSH
20133: CALL_OW 1
20137: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20138: LD_ADDR_EXP 81
20142: PUSH
20143: LD_EXP 81
20147: PPUSH
20148: LD_VAR 0 2
20152: PPUSH
20153: EMPTY
20154: PPUSH
20155: CALL_OW 1
20159: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20160: LD_ADDR_EXP 83
20164: PUSH
20165: LD_EXP 83
20169: PPUSH
20170: LD_VAR 0 2
20174: PPUSH
20175: LD_EXP 50
20179: PUSH
20180: LD_VAR 0 2
20184: ARRAY
20185: PPUSH
20186: LD_INT 2
20188: PUSH
20189: LD_INT 30
20191: PUSH
20192: LD_INT 6
20194: PUSH
20195: EMPTY
20196: LIST
20197: LIST
20198: PUSH
20199: LD_INT 30
20201: PUSH
20202: LD_INT 7
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: PUSH
20209: LD_INT 30
20211: PUSH
20212: LD_INT 8
20214: PUSH
20215: EMPTY
20216: LIST
20217: LIST
20218: PUSH
20219: EMPTY
20220: LIST
20221: LIST
20222: LIST
20223: LIST
20224: PPUSH
20225: CALL_OW 72
20229: PPUSH
20230: CALL_OW 1
20234: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20235: LD_ADDR_EXP 84
20239: PUSH
20240: LD_EXP 84
20244: PPUSH
20245: LD_VAR 0 2
20249: PPUSH
20250: EMPTY
20251: PPUSH
20252: CALL_OW 1
20256: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20257: LD_ADDR_EXP 85
20261: PUSH
20262: LD_EXP 85
20266: PPUSH
20267: LD_VAR 0 2
20271: PPUSH
20272: EMPTY
20273: PPUSH
20274: CALL_OW 1
20278: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20279: LD_ADDR_EXP 86
20283: PUSH
20284: LD_EXP 86
20288: PPUSH
20289: LD_VAR 0 2
20293: PPUSH
20294: EMPTY
20295: PPUSH
20296: CALL_OW 1
20300: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20301: LD_ADDR_EXP 87
20305: PUSH
20306: LD_EXP 87
20310: PPUSH
20311: LD_VAR 0 2
20315: PPUSH
20316: EMPTY
20317: PPUSH
20318: CALL_OW 1
20322: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20323: LD_ADDR_EXP 88
20327: PUSH
20328: LD_EXP 88
20332: PPUSH
20333: LD_VAR 0 2
20337: PPUSH
20338: EMPTY
20339: PPUSH
20340: CALL_OW 1
20344: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20345: LD_ADDR_EXP 89
20349: PUSH
20350: LD_EXP 89
20354: PPUSH
20355: LD_VAR 0 2
20359: PPUSH
20360: EMPTY
20361: PPUSH
20362: CALL_OW 1
20366: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20367: LD_ADDR_EXP 90
20371: PUSH
20372: LD_EXP 90
20376: PPUSH
20377: LD_VAR 0 2
20381: PPUSH
20382: EMPTY
20383: PPUSH
20384: CALL_OW 1
20388: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20389: LD_ADDR_EXP 91
20393: PUSH
20394: LD_EXP 91
20398: PPUSH
20399: LD_VAR 0 2
20403: PPUSH
20404: EMPTY
20405: PPUSH
20406: CALL_OW 1
20410: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20411: LD_ADDR_EXP 92
20415: PUSH
20416: LD_EXP 92
20420: PPUSH
20421: LD_VAR 0 2
20425: PPUSH
20426: LD_INT 0
20428: PPUSH
20429: CALL_OW 1
20433: ST_TO_ADDR
// end ;
20434: GO 19358
20436: POP
20437: POP
// MC_InitSides ( ) ;
20438: CALL 20724 0 0
// MC_InitResearch ( ) ;
20442: CALL 20463 0 0
// CustomInitMacro ( ) ;
20446: CALL 300 0 0
// skirmish := true ;
20450: LD_ADDR_EXP 48
20454: PUSH
20455: LD_INT 1
20457: ST_TO_ADDR
// end ;
20458: LD_VAR 0 1
20462: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20463: LD_INT 0
20465: PPUSH
20466: PPUSH
20467: PPUSH
20468: PPUSH
20469: PPUSH
20470: PPUSH
// if not mc_bases then
20471: LD_EXP 50
20475: NOT
20476: IFFALSE 20480
// exit ;
20478: GO 20719
// for i = 1 to 8 do
20480: LD_ADDR_VAR 0 2
20484: PUSH
20485: DOUBLE
20486: LD_INT 1
20488: DEC
20489: ST_TO_ADDR
20490: LD_INT 8
20492: PUSH
20493: FOR_TO
20494: IFFALSE 20520
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20496: LD_ADDR_EXP 77
20500: PUSH
20501: LD_EXP 77
20505: PPUSH
20506: LD_VAR 0 2
20510: PPUSH
20511: EMPTY
20512: PPUSH
20513: CALL_OW 1
20517: ST_TO_ADDR
20518: GO 20493
20520: POP
20521: POP
// tmp := [ ] ;
20522: LD_ADDR_VAR 0 5
20526: PUSH
20527: EMPTY
20528: ST_TO_ADDR
// for i = 1 to mc_sides do
20529: LD_ADDR_VAR 0 2
20533: PUSH
20534: DOUBLE
20535: LD_INT 1
20537: DEC
20538: ST_TO_ADDR
20539: LD_EXP 76
20543: PUSH
20544: FOR_TO
20545: IFFALSE 20603
// if not mc_sides [ i ] in tmp then
20547: LD_EXP 76
20551: PUSH
20552: LD_VAR 0 2
20556: ARRAY
20557: PUSH
20558: LD_VAR 0 5
20562: IN
20563: NOT
20564: IFFALSE 20601
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20566: LD_ADDR_VAR 0 5
20570: PUSH
20571: LD_VAR 0 5
20575: PPUSH
20576: LD_VAR 0 5
20580: PUSH
20581: LD_INT 1
20583: PLUS
20584: PPUSH
20585: LD_EXP 76
20589: PUSH
20590: LD_VAR 0 2
20594: ARRAY
20595: PPUSH
20596: CALL_OW 2
20600: ST_TO_ADDR
20601: GO 20544
20603: POP
20604: POP
// if not tmp then
20605: LD_VAR 0 5
20609: NOT
20610: IFFALSE 20614
// exit ;
20612: GO 20719
// for j in tmp do
20614: LD_ADDR_VAR 0 3
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: FOR_IN
20625: IFFALSE 20717
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20627: LD_ADDR_VAR 0 6
20631: PUSH
20632: LD_INT 22
20634: PUSH
20635: LD_VAR 0 3
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PPUSH
20644: CALL_OW 69
20648: ST_TO_ADDR
// if not un then
20649: LD_VAR 0 6
20653: NOT
20654: IFFALSE 20658
// continue ;
20656: GO 20624
// nation := GetNation ( un [ 1 ] ) ;
20658: LD_ADDR_VAR 0 4
20662: PUSH
20663: LD_VAR 0 6
20667: PUSH
20668: LD_INT 1
20670: ARRAY
20671: PPUSH
20672: CALL_OW 248
20676: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20677: LD_ADDR_EXP 77
20681: PUSH
20682: LD_EXP 77
20686: PPUSH
20687: LD_VAR 0 3
20691: PPUSH
20692: LD_VAR 0 3
20696: PPUSH
20697: LD_VAR 0 4
20701: PPUSH
20702: LD_INT 1
20704: PPUSH
20705: CALL 47329 0 3
20709: PPUSH
20710: CALL_OW 1
20714: ST_TO_ADDR
// end ;
20715: GO 20624
20717: POP
20718: POP
// end ;
20719: LD_VAR 0 1
20723: RET
// export function MC_InitSides ( ) ; var i ; begin
20724: LD_INT 0
20726: PPUSH
20727: PPUSH
// if not mc_bases then
20728: LD_EXP 50
20732: NOT
20733: IFFALSE 20737
// exit ;
20735: GO 20811
// for i = 1 to mc_bases do
20737: LD_ADDR_VAR 0 2
20741: PUSH
20742: DOUBLE
20743: LD_INT 1
20745: DEC
20746: ST_TO_ADDR
20747: LD_EXP 50
20751: PUSH
20752: FOR_TO
20753: IFFALSE 20809
// if mc_bases [ i ] then
20755: LD_EXP 50
20759: PUSH
20760: LD_VAR 0 2
20764: ARRAY
20765: IFFALSE 20807
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20767: LD_ADDR_EXP 76
20771: PUSH
20772: LD_EXP 76
20776: PPUSH
20777: LD_VAR 0 2
20781: PPUSH
20782: LD_EXP 50
20786: PUSH
20787: LD_VAR 0 2
20791: ARRAY
20792: PUSH
20793: LD_INT 1
20795: ARRAY
20796: PPUSH
20797: CALL_OW 255
20801: PPUSH
20802: CALL_OW 1
20806: ST_TO_ADDR
20807: GO 20752
20809: POP
20810: POP
// end ;
20811: LD_VAR 0 1
20815: RET
// every 0 0$01 trigger skirmish do
20816: LD_EXP 48
20820: IFFALSE 20974
20822: GO 20824
20824: DISABLE
// begin enable ;
20825: ENABLE
// MC_CheckBuildings ( ) ;
20826: CALL 25472 0 0
// MC_CheckPeopleLife ( ) ;
20830: CALL 25597 0 0
// RaiseSailEvent ( 100 ) ;
20834: LD_INT 100
20836: PPUSH
20837: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20841: LD_INT 103
20843: PPUSH
20844: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20848: LD_INT 104
20850: PPUSH
20851: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20855: LD_INT 105
20857: PPUSH
20858: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20862: LD_INT 106
20864: PPUSH
20865: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
20869: LD_INT 107
20871: PPUSH
20872: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
20876: LD_INT 108
20878: PPUSH
20879: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
20883: LD_INT 109
20885: PPUSH
20886: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
20890: LD_INT 110
20892: PPUSH
20893: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
20897: LD_INT 111
20899: PPUSH
20900: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
20904: LD_INT 112
20906: PPUSH
20907: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
20911: LD_INT 113
20913: PPUSH
20914: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
20918: LD_INT 120
20920: PPUSH
20921: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
20925: LD_INT 121
20927: PPUSH
20928: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
20932: LD_INT 122
20934: PPUSH
20935: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
20939: LD_INT 123
20941: PPUSH
20942: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
20946: LD_INT 124
20948: PPUSH
20949: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
20953: LD_INT 125
20955: PPUSH
20956: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
20960: LD_INT 126
20962: PPUSH
20963: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
20967: LD_INT 200
20969: PPUSH
20970: CALL_OW 427
// end ;
20974: END
// on SailEvent ( event ) do begin if event < 100 then
20975: LD_VAR 0 1
20979: PUSH
20980: LD_INT 100
20982: LESS
20983: IFFALSE 20994
// CustomEvent ( event ) ;
20985: LD_VAR 0 1
20989: PPUSH
20990: CALL 16493 0 1
// if event = 100 then
20994: LD_VAR 0 1
20998: PUSH
20999: LD_INT 100
21001: EQUAL
21002: IFFALSE 21008
// MC_ClassManager ( ) ;
21004: CALL 21400 0 0
// if event = 101 then
21008: LD_VAR 0 1
21012: PUSH
21013: LD_INT 101
21015: EQUAL
21016: IFFALSE 21022
// MC_RepairBuildings ( ) ;
21018: CALL 26193 0 0
// if event = 102 then
21022: LD_VAR 0 1
21026: PUSH
21027: LD_INT 102
21029: EQUAL
21030: IFFALSE 21036
// MC_Heal ( ) ;
21032: CALL 27057 0 0
// if event = 103 then
21036: LD_VAR 0 1
21040: PUSH
21041: LD_INT 103
21043: EQUAL
21044: IFFALSE 21050
// MC_Build ( ) ;
21046: CALL 27479 0 0
// if event = 104 then
21050: LD_VAR 0 1
21054: PUSH
21055: LD_INT 104
21057: EQUAL
21058: IFFALSE 21064
// MC_TurretWeapon ( ) ;
21060: CALL 29092 0 0
// if event = 105 then
21064: LD_VAR 0 1
21068: PUSH
21069: LD_INT 105
21071: EQUAL
21072: IFFALSE 21078
// MC_BuildUpgrade ( ) ;
21074: CALL 28643 0 0
// if event = 106 then
21078: LD_VAR 0 1
21082: PUSH
21083: LD_INT 106
21085: EQUAL
21086: IFFALSE 21092
// MC_PlantMines ( ) ;
21088: CALL 29522 0 0
// if event = 107 then
21092: LD_VAR 0 1
21096: PUSH
21097: LD_INT 107
21099: EQUAL
21100: IFFALSE 21106
// MC_CollectCrates ( ) ;
21102: CALL 30320 0 0
// if event = 108 then
21106: LD_VAR 0 1
21110: PUSH
21111: LD_INT 108
21113: EQUAL
21114: IFFALSE 21120
// MC_LinkRemoteControl ( ) ;
21116: CALL 32096 0 0
// if event = 109 then
21120: LD_VAR 0 1
21124: PUSH
21125: LD_INT 109
21127: EQUAL
21128: IFFALSE 21134
// MC_ProduceVehicle ( ) ;
21130: CALL 32277 0 0
// if event = 110 then
21134: LD_VAR 0 1
21138: PUSH
21139: LD_INT 110
21141: EQUAL
21142: IFFALSE 21148
// MC_SendAttack ( ) ;
21144: CALL 32743 0 0
// if event = 111 then
21148: LD_VAR 0 1
21152: PUSH
21153: LD_INT 111
21155: EQUAL
21156: IFFALSE 21162
// MC_Defend ( ) ;
21158: CALL 32851 0 0
// if event = 112 then
21162: LD_VAR 0 1
21166: PUSH
21167: LD_INT 112
21169: EQUAL
21170: IFFALSE 21176
// MC_Research ( ) ;
21172: CALL 33456 0 0
// if event = 113 then
21176: LD_VAR 0 1
21180: PUSH
21181: LD_INT 113
21183: EQUAL
21184: IFFALSE 21190
// MC_MinesTrigger ( ) ;
21186: CALL 34570 0 0
// if event = 120 then
21190: LD_VAR 0 1
21194: PUSH
21195: LD_INT 120
21197: EQUAL
21198: IFFALSE 21204
// MC_RepairVehicle ( ) ;
21200: CALL 34669 0 0
// if event = 121 then
21204: LD_VAR 0 1
21208: PUSH
21209: LD_INT 121
21211: EQUAL
21212: IFFALSE 21218
// MC_TameApe ( ) ;
21214: CALL 35399 0 0
// if event = 122 then
21218: LD_VAR 0 1
21222: PUSH
21223: LD_INT 122
21225: EQUAL
21226: IFFALSE 21232
// MC_ChangeApeClass ( ) ;
21228: CALL 36228 0 0
// if event = 123 then
21232: LD_VAR 0 1
21236: PUSH
21237: LD_INT 123
21239: EQUAL
21240: IFFALSE 21246
// MC_Bazooka ( ) ;
21242: CALL 36878 0 0
// if event = 124 then
21246: LD_VAR 0 1
21250: PUSH
21251: LD_INT 124
21253: EQUAL
21254: IFFALSE 21260
// MC_TeleportExit ( ) ;
21256: CALL 37076 0 0
// if event = 125 then
21260: LD_VAR 0 1
21264: PUSH
21265: LD_INT 125
21267: EQUAL
21268: IFFALSE 21274
// MC_Deposits ( ) ;
21270: CALL 37723 0 0
// if event = 126 then
21274: LD_VAR 0 1
21278: PUSH
21279: LD_INT 126
21281: EQUAL
21282: IFFALSE 21288
// MC_RemoteDriver ( ) ;
21284: CALL 38348 0 0
// if event = 200 then
21288: LD_VAR 0 1
21292: PUSH
21293: LD_INT 200
21295: EQUAL
21296: IFFALSE 21302
// MC_Idle ( ) ;
21298: CALL 40297 0 0
// end ;
21302: PPOPN 1
21304: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21305: LD_INT 0
21307: PPUSH
21308: PPUSH
// if not mc_bases [ base ] or not tag then
21309: LD_EXP 50
21313: PUSH
21314: LD_VAR 0 1
21318: ARRAY
21319: NOT
21320: PUSH
21321: LD_VAR 0 2
21325: NOT
21326: OR
21327: IFFALSE 21331
// exit ;
21329: GO 21395
// for i in mc_bases [ base ] union mc_ape [ base ] do
21331: LD_ADDR_VAR 0 4
21335: PUSH
21336: LD_EXP 50
21340: PUSH
21341: LD_VAR 0 1
21345: ARRAY
21346: PUSH
21347: LD_EXP 79
21351: PUSH
21352: LD_VAR 0 1
21356: ARRAY
21357: UNION
21358: PUSH
21359: FOR_IN
21360: IFFALSE 21393
// if GetTag ( i ) = tag then
21362: LD_VAR 0 4
21366: PPUSH
21367: CALL_OW 110
21371: PUSH
21372: LD_VAR 0 2
21376: EQUAL
21377: IFFALSE 21391
// SetTag ( i , 0 ) ;
21379: LD_VAR 0 4
21383: PPUSH
21384: LD_INT 0
21386: PPUSH
21387: CALL_OW 109
21391: GO 21359
21393: POP
21394: POP
// end ;
21395: LD_VAR 0 3
21399: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21400: LD_INT 0
21402: PPUSH
21403: PPUSH
21404: PPUSH
21405: PPUSH
21406: PPUSH
21407: PPUSH
21408: PPUSH
21409: PPUSH
// if not mc_bases then
21410: LD_EXP 50
21414: NOT
21415: IFFALSE 21419
// exit ;
21417: GO 21877
// for i = 1 to mc_bases do
21419: LD_ADDR_VAR 0 2
21423: PUSH
21424: DOUBLE
21425: LD_INT 1
21427: DEC
21428: ST_TO_ADDR
21429: LD_EXP 50
21433: PUSH
21434: FOR_TO
21435: IFFALSE 21875
// begin tmp := MC_ClassCheckReq ( i ) ;
21437: LD_ADDR_VAR 0 4
21441: PUSH
21442: LD_VAR 0 2
21446: PPUSH
21447: CALL 21882 0 1
21451: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21452: LD_ADDR_EXP 91
21456: PUSH
21457: LD_EXP 91
21461: PPUSH
21462: LD_VAR 0 2
21466: PPUSH
21467: LD_VAR 0 4
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// if not tmp then
21477: LD_VAR 0 4
21481: NOT
21482: IFFALSE 21486
// continue ;
21484: GO 21434
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21486: LD_ADDR_VAR 0 6
21490: PUSH
21491: LD_EXP 50
21495: PUSH
21496: LD_VAR 0 2
21500: ARRAY
21501: PPUSH
21502: LD_INT 2
21504: PUSH
21505: LD_INT 30
21507: PUSH
21508: LD_INT 4
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: LD_INT 30
21517: PUSH
21518: LD_INT 5
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PUSH
21525: EMPTY
21526: LIST
21527: LIST
21528: LIST
21529: PPUSH
21530: CALL_OW 72
21534: PUSH
21535: LD_EXP 50
21539: PUSH
21540: LD_VAR 0 2
21544: ARRAY
21545: PPUSH
21546: LD_INT 2
21548: PUSH
21549: LD_INT 30
21551: PUSH
21552: LD_INT 0
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: PUSH
21559: LD_INT 30
21561: PUSH
21562: LD_INT 1
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: LIST
21573: PPUSH
21574: CALL_OW 72
21578: PUSH
21579: LD_EXP 50
21583: PUSH
21584: LD_VAR 0 2
21588: ARRAY
21589: PPUSH
21590: LD_INT 30
21592: PUSH
21593: LD_INT 3
21595: PUSH
21596: EMPTY
21597: LIST
21598: LIST
21599: PPUSH
21600: CALL_OW 72
21604: PUSH
21605: LD_EXP 50
21609: PUSH
21610: LD_VAR 0 2
21614: ARRAY
21615: PPUSH
21616: LD_INT 2
21618: PUSH
21619: LD_INT 30
21621: PUSH
21622: LD_INT 6
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: LD_INT 30
21631: PUSH
21632: LD_INT 7
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: LD_INT 30
21641: PUSH
21642: LD_INT 8
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: PUSH
21649: EMPTY
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: PPUSH
21655: CALL_OW 72
21659: PUSH
21660: EMPTY
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: ST_TO_ADDR
// for j = 1 to 4 do
21666: LD_ADDR_VAR 0 3
21670: PUSH
21671: DOUBLE
21672: LD_INT 1
21674: DEC
21675: ST_TO_ADDR
21676: LD_INT 4
21678: PUSH
21679: FOR_TO
21680: IFFALSE 21871
// begin if not tmp [ j ] then
21682: LD_VAR 0 4
21686: PUSH
21687: LD_VAR 0 3
21691: ARRAY
21692: NOT
21693: IFFALSE 21697
// continue ;
21695: GO 21679
// for p in tmp [ j ] do
21697: LD_ADDR_VAR 0 5
21701: PUSH
21702: LD_VAR 0 4
21706: PUSH
21707: LD_VAR 0 3
21711: ARRAY
21712: PUSH
21713: FOR_IN
21714: IFFALSE 21867
// begin if not b [ j ] then
21716: LD_VAR 0 6
21720: PUSH
21721: LD_VAR 0 3
21725: ARRAY
21726: NOT
21727: IFFALSE 21731
// break ;
21729: GO 21867
// e := 0 ;
21731: LD_ADDR_VAR 0 7
21735: PUSH
21736: LD_INT 0
21738: ST_TO_ADDR
// for k in b [ j ] do
21739: LD_ADDR_VAR 0 8
21743: PUSH
21744: LD_VAR 0 6
21748: PUSH
21749: LD_VAR 0 3
21753: ARRAY
21754: PUSH
21755: FOR_IN
21756: IFFALSE 21783
// if IsNotFull ( k ) then
21758: LD_VAR 0 8
21762: PPUSH
21763: CALL 51769 0 1
21767: IFFALSE 21781
// begin e := k ;
21769: LD_ADDR_VAR 0 7
21773: PUSH
21774: LD_VAR 0 8
21778: ST_TO_ADDR
// break ;
21779: GO 21783
// end ;
21781: GO 21755
21783: POP
21784: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21785: LD_VAR 0 7
21789: PUSH
21790: LD_VAR 0 5
21794: PPUSH
21795: LD_VAR 0 7
21799: PPUSH
21800: CALL 88914 0 2
21804: NOT
21805: AND
21806: IFFALSE 21865
// begin if IsInUnit ( p ) then
21808: LD_VAR 0 5
21812: PPUSH
21813: CALL_OW 310
21817: IFFALSE 21828
// ComExitBuilding ( p ) ;
21819: LD_VAR 0 5
21823: PPUSH
21824: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21828: LD_VAR 0 5
21832: PPUSH
21833: LD_VAR 0 7
21837: PPUSH
21838: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21842: LD_VAR 0 5
21846: PPUSH
21847: LD_VAR 0 3
21851: PPUSH
21852: CALL_OW 183
// AddComExitBuilding ( p ) ;
21856: LD_VAR 0 5
21860: PPUSH
21861: CALL_OW 182
// end ; end ;
21865: GO 21713
21867: POP
21868: POP
// end ;
21869: GO 21679
21871: POP
21872: POP
// end ;
21873: GO 21434
21875: POP
21876: POP
// end ;
21877: LD_VAR 0 1
21881: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
21882: LD_INT 0
21884: PPUSH
21885: PPUSH
21886: PPUSH
21887: PPUSH
21888: PPUSH
21889: PPUSH
21890: PPUSH
21891: PPUSH
21892: PPUSH
21893: PPUSH
21894: PPUSH
21895: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21896: LD_VAR 0 1
21900: NOT
21901: PUSH
21902: LD_EXP 50
21906: PUSH
21907: LD_VAR 0 1
21911: ARRAY
21912: NOT
21913: OR
21914: PUSH
21915: LD_EXP 50
21919: PUSH
21920: LD_VAR 0 1
21924: ARRAY
21925: PPUSH
21926: LD_INT 2
21928: PUSH
21929: LD_INT 30
21931: PUSH
21932: LD_INT 0
21934: PUSH
21935: EMPTY
21936: LIST
21937: LIST
21938: PUSH
21939: LD_INT 30
21941: PUSH
21942: LD_INT 1
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: PUSH
21949: EMPTY
21950: LIST
21951: LIST
21952: LIST
21953: PPUSH
21954: CALL_OW 72
21958: NOT
21959: OR
21960: IFFALSE 21964
// exit ;
21962: GO 25467
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21964: LD_ADDR_VAR 0 4
21968: PUSH
21969: LD_EXP 50
21973: PUSH
21974: LD_VAR 0 1
21978: ARRAY
21979: PPUSH
21980: LD_INT 2
21982: PUSH
21983: LD_INT 25
21985: PUSH
21986: LD_INT 1
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: PUSH
21993: LD_INT 25
21995: PUSH
21996: LD_INT 2
21998: PUSH
21999: EMPTY
22000: LIST
22001: LIST
22002: PUSH
22003: LD_INT 25
22005: PUSH
22006: LD_INT 3
22008: PUSH
22009: EMPTY
22010: LIST
22011: LIST
22012: PUSH
22013: LD_INT 25
22015: PUSH
22016: LD_INT 4
22018: PUSH
22019: EMPTY
22020: LIST
22021: LIST
22022: PUSH
22023: LD_INT 25
22025: PUSH
22026: LD_INT 5
22028: PUSH
22029: EMPTY
22030: LIST
22031: LIST
22032: PUSH
22033: LD_INT 25
22035: PUSH
22036: LD_INT 8
22038: PUSH
22039: EMPTY
22040: LIST
22041: LIST
22042: PUSH
22043: LD_INT 25
22045: PUSH
22046: LD_INT 9
22048: PUSH
22049: EMPTY
22050: LIST
22051: LIST
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: LIST
22059: LIST
22060: LIST
22061: LIST
22062: PPUSH
22063: CALL_OW 72
22067: ST_TO_ADDR
// if not tmp then
22068: LD_VAR 0 4
22072: NOT
22073: IFFALSE 22077
// exit ;
22075: GO 25467
// for i in tmp do
22077: LD_ADDR_VAR 0 3
22081: PUSH
22082: LD_VAR 0 4
22086: PUSH
22087: FOR_IN
22088: IFFALSE 22119
// if GetTag ( i ) then
22090: LD_VAR 0 3
22094: PPUSH
22095: CALL_OW 110
22099: IFFALSE 22117
// tmp := tmp diff i ;
22101: LD_ADDR_VAR 0 4
22105: PUSH
22106: LD_VAR 0 4
22110: PUSH
22111: LD_VAR 0 3
22115: DIFF
22116: ST_TO_ADDR
22117: GO 22087
22119: POP
22120: POP
// if not tmp then
22121: LD_VAR 0 4
22125: NOT
22126: IFFALSE 22130
// exit ;
22128: GO 25467
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22130: LD_ADDR_VAR 0 5
22134: PUSH
22135: LD_EXP 50
22139: PUSH
22140: LD_VAR 0 1
22144: ARRAY
22145: PPUSH
22146: LD_INT 2
22148: PUSH
22149: LD_INT 25
22151: PUSH
22152: LD_INT 1
22154: PUSH
22155: EMPTY
22156: LIST
22157: LIST
22158: PUSH
22159: LD_INT 25
22161: PUSH
22162: LD_INT 5
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: PUSH
22169: LD_INT 25
22171: PUSH
22172: LD_INT 8
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: PUSH
22179: LD_INT 25
22181: PUSH
22182: LD_INT 9
22184: PUSH
22185: EMPTY
22186: LIST
22187: LIST
22188: PUSH
22189: EMPTY
22190: LIST
22191: LIST
22192: LIST
22193: LIST
22194: LIST
22195: PPUSH
22196: CALL_OW 72
22200: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22201: LD_ADDR_VAR 0 6
22205: PUSH
22206: LD_EXP 50
22210: PUSH
22211: LD_VAR 0 1
22215: ARRAY
22216: PPUSH
22217: LD_INT 25
22219: PUSH
22220: LD_INT 2
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: PPUSH
22227: CALL_OW 72
22231: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22232: LD_ADDR_VAR 0 7
22236: PUSH
22237: LD_EXP 50
22241: PUSH
22242: LD_VAR 0 1
22246: ARRAY
22247: PPUSH
22248: LD_INT 25
22250: PUSH
22251: LD_INT 3
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: PPUSH
22258: CALL_OW 72
22262: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22263: LD_ADDR_VAR 0 8
22267: PUSH
22268: LD_EXP 50
22272: PUSH
22273: LD_VAR 0 1
22277: ARRAY
22278: PPUSH
22279: LD_INT 25
22281: PUSH
22282: LD_INT 4
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: PUSH
22289: LD_INT 24
22291: PUSH
22292: LD_INT 251
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: PPUSH
22303: CALL_OW 72
22307: ST_TO_ADDR
// if mc_scan [ base ] then
22308: LD_EXP 73
22312: PUSH
22313: LD_VAR 0 1
22317: ARRAY
22318: IFFALSE 22779
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22320: LD_ADDR_EXP 92
22324: PUSH
22325: LD_EXP 92
22329: PPUSH
22330: LD_VAR 0 1
22334: PPUSH
22335: LD_INT 4
22337: PPUSH
22338: CALL_OW 1
22342: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22343: LD_ADDR_VAR 0 12
22347: PUSH
22348: LD_EXP 50
22352: PUSH
22353: LD_VAR 0 1
22357: ARRAY
22358: PPUSH
22359: LD_INT 2
22361: PUSH
22362: LD_INT 30
22364: PUSH
22365: LD_INT 4
22367: PUSH
22368: EMPTY
22369: LIST
22370: LIST
22371: PUSH
22372: LD_INT 30
22374: PUSH
22375: LD_INT 5
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: PUSH
22382: EMPTY
22383: LIST
22384: LIST
22385: LIST
22386: PPUSH
22387: CALL_OW 72
22391: ST_TO_ADDR
// if not b then
22392: LD_VAR 0 12
22396: NOT
22397: IFFALSE 22401
// exit ;
22399: GO 25467
// p := [ ] ;
22401: LD_ADDR_VAR 0 11
22405: PUSH
22406: EMPTY
22407: ST_TO_ADDR
// if sci >= 2 then
22408: LD_VAR 0 8
22412: PUSH
22413: LD_INT 2
22415: GREATEREQUAL
22416: IFFALSE 22447
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22418: LD_ADDR_VAR 0 8
22422: PUSH
22423: LD_VAR 0 8
22427: PUSH
22428: LD_INT 1
22430: ARRAY
22431: PUSH
22432: LD_VAR 0 8
22436: PUSH
22437: LD_INT 2
22439: ARRAY
22440: PUSH
22441: EMPTY
22442: LIST
22443: LIST
22444: ST_TO_ADDR
22445: GO 22508
// if sci = 1 then
22447: LD_VAR 0 8
22451: PUSH
22452: LD_INT 1
22454: EQUAL
22455: IFFALSE 22476
// sci := [ sci [ 1 ] ] else
22457: LD_ADDR_VAR 0 8
22461: PUSH
22462: LD_VAR 0 8
22466: PUSH
22467: LD_INT 1
22469: ARRAY
22470: PUSH
22471: EMPTY
22472: LIST
22473: ST_TO_ADDR
22474: GO 22508
// if sci = 0 then
22476: LD_VAR 0 8
22480: PUSH
22481: LD_INT 0
22483: EQUAL
22484: IFFALSE 22508
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22486: LD_ADDR_VAR 0 11
22490: PUSH
22491: LD_VAR 0 4
22495: PPUSH
22496: LD_INT 4
22498: PPUSH
22499: CALL 88777 0 2
22503: PUSH
22504: LD_INT 1
22506: ARRAY
22507: ST_TO_ADDR
// if eng > 4 then
22508: LD_VAR 0 6
22512: PUSH
22513: LD_INT 4
22515: GREATER
22516: IFFALSE 22562
// for i = eng downto 4 do
22518: LD_ADDR_VAR 0 3
22522: PUSH
22523: DOUBLE
22524: LD_VAR 0 6
22528: INC
22529: ST_TO_ADDR
22530: LD_INT 4
22532: PUSH
22533: FOR_DOWNTO
22534: IFFALSE 22560
// eng := eng diff eng [ i ] ;
22536: LD_ADDR_VAR 0 6
22540: PUSH
22541: LD_VAR 0 6
22545: PUSH
22546: LD_VAR 0 6
22550: PUSH
22551: LD_VAR 0 3
22555: ARRAY
22556: DIFF
22557: ST_TO_ADDR
22558: GO 22533
22560: POP
22561: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22562: LD_ADDR_VAR 0 4
22566: PUSH
22567: LD_VAR 0 4
22571: PUSH
22572: LD_VAR 0 5
22576: PUSH
22577: LD_VAR 0 6
22581: UNION
22582: PUSH
22583: LD_VAR 0 7
22587: UNION
22588: PUSH
22589: LD_VAR 0 8
22593: UNION
22594: DIFF
22595: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22596: LD_ADDR_VAR 0 13
22600: PUSH
22601: LD_EXP 50
22605: PUSH
22606: LD_VAR 0 1
22610: ARRAY
22611: PPUSH
22612: LD_INT 2
22614: PUSH
22615: LD_INT 30
22617: PUSH
22618: LD_INT 32
22620: PUSH
22621: EMPTY
22622: LIST
22623: LIST
22624: PUSH
22625: LD_INT 30
22627: PUSH
22628: LD_INT 31
22630: PUSH
22631: EMPTY
22632: LIST
22633: LIST
22634: PUSH
22635: EMPTY
22636: LIST
22637: LIST
22638: LIST
22639: PPUSH
22640: CALL_OW 72
22644: PUSH
22645: LD_EXP 50
22649: PUSH
22650: LD_VAR 0 1
22654: ARRAY
22655: PPUSH
22656: LD_INT 2
22658: PUSH
22659: LD_INT 30
22661: PUSH
22662: LD_INT 4
22664: PUSH
22665: EMPTY
22666: LIST
22667: LIST
22668: PUSH
22669: LD_INT 30
22671: PUSH
22672: LD_INT 5
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: LIST
22683: PPUSH
22684: CALL_OW 72
22688: PUSH
22689: LD_INT 6
22691: MUL
22692: PLUS
22693: ST_TO_ADDR
// if bcount < tmp then
22694: LD_VAR 0 13
22698: PUSH
22699: LD_VAR 0 4
22703: LESS
22704: IFFALSE 22750
// for i = tmp downto bcount do
22706: LD_ADDR_VAR 0 3
22710: PUSH
22711: DOUBLE
22712: LD_VAR 0 4
22716: INC
22717: ST_TO_ADDR
22718: LD_VAR 0 13
22722: PUSH
22723: FOR_DOWNTO
22724: IFFALSE 22748
// tmp := Delete ( tmp , tmp ) ;
22726: LD_ADDR_VAR 0 4
22730: PUSH
22731: LD_VAR 0 4
22735: PPUSH
22736: LD_VAR 0 4
22740: PPUSH
22741: CALL_OW 3
22745: ST_TO_ADDR
22746: GO 22723
22748: POP
22749: POP
// result := [ tmp , 0 , 0 , p ] ;
22750: LD_ADDR_VAR 0 2
22754: PUSH
22755: LD_VAR 0 4
22759: PUSH
22760: LD_INT 0
22762: PUSH
22763: LD_INT 0
22765: PUSH
22766: LD_VAR 0 11
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: ST_TO_ADDR
// exit ;
22777: GO 25467
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22779: LD_EXP 50
22783: PUSH
22784: LD_VAR 0 1
22788: ARRAY
22789: PPUSH
22790: LD_INT 2
22792: PUSH
22793: LD_INT 30
22795: PUSH
22796: LD_INT 6
22798: PUSH
22799: EMPTY
22800: LIST
22801: LIST
22802: PUSH
22803: LD_INT 30
22805: PUSH
22806: LD_INT 7
22808: PUSH
22809: EMPTY
22810: LIST
22811: LIST
22812: PUSH
22813: LD_INT 30
22815: PUSH
22816: LD_INT 8
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: PUSH
22823: EMPTY
22824: LIST
22825: LIST
22826: LIST
22827: LIST
22828: PPUSH
22829: CALL_OW 72
22833: NOT
22834: PUSH
22835: LD_EXP 50
22839: PUSH
22840: LD_VAR 0 1
22844: ARRAY
22845: PPUSH
22846: LD_INT 30
22848: PUSH
22849: LD_INT 3
22851: PUSH
22852: EMPTY
22853: LIST
22854: LIST
22855: PPUSH
22856: CALL_OW 72
22860: NOT
22861: AND
22862: IFFALSE 22934
// begin if eng = tmp then
22864: LD_VAR 0 6
22868: PUSH
22869: LD_VAR 0 4
22873: EQUAL
22874: IFFALSE 22878
// exit ;
22876: GO 25467
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
22878: LD_ADDR_EXP 92
22882: PUSH
22883: LD_EXP 92
22887: PPUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: LD_INT 1
22895: PPUSH
22896: CALL_OW 1
22900: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
22901: LD_ADDR_VAR 0 2
22905: PUSH
22906: LD_INT 0
22908: PUSH
22909: LD_VAR 0 4
22913: PUSH
22914: LD_VAR 0 6
22918: DIFF
22919: PUSH
22920: LD_INT 0
22922: PUSH
22923: LD_INT 0
22925: PUSH
22926: EMPTY
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: ST_TO_ADDR
// exit ;
22932: GO 25467
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22934: LD_EXP 77
22938: PUSH
22939: LD_EXP 76
22943: PUSH
22944: LD_VAR 0 1
22948: ARRAY
22949: ARRAY
22950: PUSH
22951: LD_EXP 50
22955: PUSH
22956: LD_VAR 0 1
22960: ARRAY
22961: PPUSH
22962: LD_INT 2
22964: PUSH
22965: LD_INT 30
22967: PUSH
22968: LD_INT 6
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: PUSH
22975: LD_INT 30
22977: PUSH
22978: LD_INT 7
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: PUSH
22985: LD_INT 30
22987: PUSH
22988: LD_INT 8
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: PUSH
22995: EMPTY
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: PPUSH
23001: CALL_OW 72
23005: AND
23006: PUSH
23007: LD_EXP 50
23011: PUSH
23012: LD_VAR 0 1
23016: ARRAY
23017: PPUSH
23018: LD_INT 30
23020: PUSH
23021: LD_INT 3
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PPUSH
23028: CALL_OW 72
23032: NOT
23033: AND
23034: IFFALSE 23248
// begin if sci >= 6 then
23036: LD_VAR 0 8
23040: PUSH
23041: LD_INT 6
23043: GREATEREQUAL
23044: IFFALSE 23048
// exit ;
23046: GO 25467
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23048: LD_ADDR_EXP 92
23052: PUSH
23053: LD_EXP 92
23057: PPUSH
23058: LD_VAR 0 1
23062: PPUSH
23063: LD_INT 2
23065: PPUSH
23066: CALL_OW 1
23070: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23071: LD_ADDR_VAR 0 9
23075: PUSH
23076: LD_VAR 0 4
23080: PUSH
23081: LD_VAR 0 8
23085: DIFF
23086: PPUSH
23087: LD_INT 4
23089: PPUSH
23090: CALL 88777 0 2
23094: ST_TO_ADDR
// p := [ ] ;
23095: LD_ADDR_VAR 0 11
23099: PUSH
23100: EMPTY
23101: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23102: LD_VAR 0 8
23106: PUSH
23107: LD_INT 6
23109: LESS
23110: PUSH
23111: LD_VAR 0 9
23115: PUSH
23116: LD_INT 6
23118: GREATER
23119: AND
23120: IFFALSE 23201
// begin for i = 1 to 6 - sci do
23122: LD_ADDR_VAR 0 3
23126: PUSH
23127: DOUBLE
23128: LD_INT 1
23130: DEC
23131: ST_TO_ADDR
23132: LD_INT 6
23134: PUSH
23135: LD_VAR 0 8
23139: MINUS
23140: PUSH
23141: FOR_TO
23142: IFFALSE 23197
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23144: LD_ADDR_VAR 0 11
23148: PUSH
23149: LD_VAR 0 11
23153: PPUSH
23154: LD_VAR 0 11
23158: PUSH
23159: LD_INT 1
23161: PLUS
23162: PPUSH
23163: LD_VAR 0 9
23167: PUSH
23168: LD_INT 1
23170: ARRAY
23171: PPUSH
23172: CALL_OW 2
23176: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23177: LD_ADDR_VAR 0 9
23181: PUSH
23182: LD_VAR 0 9
23186: PPUSH
23187: LD_INT 1
23189: PPUSH
23190: CALL_OW 3
23194: ST_TO_ADDR
// end ;
23195: GO 23141
23197: POP
23198: POP
// end else
23199: GO 23221
// if sort then
23201: LD_VAR 0 9
23205: IFFALSE 23221
// p := sort [ 1 ] ;
23207: LD_ADDR_VAR 0 11
23211: PUSH
23212: LD_VAR 0 9
23216: PUSH
23217: LD_INT 1
23219: ARRAY
23220: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23221: LD_ADDR_VAR 0 2
23225: PUSH
23226: LD_INT 0
23228: PUSH
23229: LD_INT 0
23231: PUSH
23232: LD_INT 0
23234: PUSH
23235: LD_VAR 0 11
23239: PUSH
23240: EMPTY
23241: LIST
23242: LIST
23243: LIST
23244: LIST
23245: ST_TO_ADDR
// exit ;
23246: GO 25467
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23248: LD_EXP 77
23252: PUSH
23253: LD_EXP 76
23257: PUSH
23258: LD_VAR 0 1
23262: ARRAY
23263: ARRAY
23264: PUSH
23265: LD_EXP 50
23269: PUSH
23270: LD_VAR 0 1
23274: ARRAY
23275: PPUSH
23276: LD_INT 2
23278: PUSH
23279: LD_INT 30
23281: PUSH
23282: LD_INT 6
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PUSH
23289: LD_INT 30
23291: PUSH
23292: LD_INT 7
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: PUSH
23299: LD_INT 30
23301: PUSH
23302: LD_INT 8
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: LIST
23313: LIST
23314: PPUSH
23315: CALL_OW 72
23319: AND
23320: PUSH
23321: LD_EXP 50
23325: PUSH
23326: LD_VAR 0 1
23330: ARRAY
23331: PPUSH
23332: LD_INT 30
23334: PUSH
23335: LD_INT 3
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: PPUSH
23342: CALL_OW 72
23346: AND
23347: IFFALSE 24081
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23349: LD_ADDR_EXP 92
23353: PUSH
23354: LD_EXP 92
23358: PPUSH
23359: LD_VAR 0 1
23363: PPUSH
23364: LD_INT 3
23366: PPUSH
23367: CALL_OW 1
23371: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23372: LD_ADDR_VAR 0 2
23376: PUSH
23377: LD_INT 0
23379: PUSH
23380: LD_INT 0
23382: PUSH
23383: LD_INT 0
23385: PUSH
23386: LD_INT 0
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: LIST
23393: LIST
23394: ST_TO_ADDR
// if not eng then
23395: LD_VAR 0 6
23399: NOT
23400: IFFALSE 23463
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23402: LD_ADDR_VAR 0 11
23406: PUSH
23407: LD_VAR 0 4
23411: PPUSH
23412: LD_INT 2
23414: PPUSH
23415: CALL 88777 0 2
23419: PUSH
23420: LD_INT 1
23422: ARRAY
23423: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23424: LD_ADDR_VAR 0 2
23428: PUSH
23429: LD_VAR 0 2
23433: PPUSH
23434: LD_INT 2
23436: PPUSH
23437: LD_VAR 0 11
23441: PPUSH
23442: CALL_OW 1
23446: ST_TO_ADDR
// tmp := tmp diff p ;
23447: LD_ADDR_VAR 0 4
23451: PUSH
23452: LD_VAR 0 4
23456: PUSH
23457: LD_VAR 0 11
23461: DIFF
23462: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23463: LD_VAR 0 4
23467: PUSH
23468: LD_VAR 0 8
23472: PUSH
23473: LD_INT 6
23475: LESS
23476: AND
23477: IFFALSE 23665
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23479: LD_ADDR_VAR 0 9
23483: PUSH
23484: LD_VAR 0 4
23488: PUSH
23489: LD_VAR 0 8
23493: PUSH
23494: LD_VAR 0 7
23498: UNION
23499: DIFF
23500: PPUSH
23501: LD_INT 4
23503: PPUSH
23504: CALL 88777 0 2
23508: ST_TO_ADDR
// p := [ ] ;
23509: LD_ADDR_VAR 0 11
23513: PUSH
23514: EMPTY
23515: ST_TO_ADDR
// if sort then
23516: LD_VAR 0 9
23520: IFFALSE 23636
// for i = 1 to 6 - sci do
23522: LD_ADDR_VAR 0 3
23526: PUSH
23527: DOUBLE
23528: LD_INT 1
23530: DEC
23531: ST_TO_ADDR
23532: LD_INT 6
23534: PUSH
23535: LD_VAR 0 8
23539: MINUS
23540: PUSH
23541: FOR_TO
23542: IFFALSE 23634
// begin if i = sort then
23544: LD_VAR 0 3
23548: PUSH
23549: LD_VAR 0 9
23553: EQUAL
23554: IFFALSE 23558
// break ;
23556: GO 23634
// if GetClass ( i ) = 4 then
23558: LD_VAR 0 3
23562: PPUSH
23563: CALL_OW 257
23567: PUSH
23568: LD_INT 4
23570: EQUAL
23571: IFFALSE 23575
// continue ;
23573: GO 23541
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23575: LD_ADDR_VAR 0 11
23579: PUSH
23580: LD_VAR 0 11
23584: PPUSH
23585: LD_VAR 0 11
23589: PUSH
23590: LD_INT 1
23592: PLUS
23593: PPUSH
23594: LD_VAR 0 9
23598: PUSH
23599: LD_VAR 0 3
23603: ARRAY
23604: PPUSH
23605: CALL_OW 2
23609: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23610: LD_ADDR_VAR 0 4
23614: PUSH
23615: LD_VAR 0 4
23619: PUSH
23620: LD_VAR 0 9
23624: PUSH
23625: LD_VAR 0 3
23629: ARRAY
23630: DIFF
23631: ST_TO_ADDR
// end ;
23632: GO 23541
23634: POP
23635: POP
// if p then
23636: LD_VAR 0 11
23640: IFFALSE 23665
// result := Replace ( result , 4 , p ) ;
23642: LD_ADDR_VAR 0 2
23646: PUSH
23647: LD_VAR 0 2
23651: PPUSH
23652: LD_INT 4
23654: PPUSH
23655: LD_VAR 0 11
23659: PPUSH
23660: CALL_OW 1
23664: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23665: LD_VAR 0 4
23669: PUSH
23670: LD_VAR 0 7
23674: PUSH
23675: LD_INT 6
23677: LESS
23678: AND
23679: IFFALSE 23867
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23681: LD_ADDR_VAR 0 9
23685: PUSH
23686: LD_VAR 0 4
23690: PUSH
23691: LD_VAR 0 8
23695: PUSH
23696: LD_VAR 0 7
23700: UNION
23701: DIFF
23702: PPUSH
23703: LD_INT 3
23705: PPUSH
23706: CALL 88777 0 2
23710: ST_TO_ADDR
// p := [ ] ;
23711: LD_ADDR_VAR 0 11
23715: PUSH
23716: EMPTY
23717: ST_TO_ADDR
// if sort then
23718: LD_VAR 0 9
23722: IFFALSE 23838
// for i = 1 to 6 - mech do
23724: LD_ADDR_VAR 0 3
23728: PUSH
23729: DOUBLE
23730: LD_INT 1
23732: DEC
23733: ST_TO_ADDR
23734: LD_INT 6
23736: PUSH
23737: LD_VAR 0 7
23741: MINUS
23742: PUSH
23743: FOR_TO
23744: IFFALSE 23836
// begin if i = sort then
23746: LD_VAR 0 3
23750: PUSH
23751: LD_VAR 0 9
23755: EQUAL
23756: IFFALSE 23760
// break ;
23758: GO 23836
// if GetClass ( i ) = 3 then
23760: LD_VAR 0 3
23764: PPUSH
23765: CALL_OW 257
23769: PUSH
23770: LD_INT 3
23772: EQUAL
23773: IFFALSE 23777
// continue ;
23775: GO 23743
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23777: LD_ADDR_VAR 0 11
23781: PUSH
23782: LD_VAR 0 11
23786: PPUSH
23787: LD_VAR 0 11
23791: PUSH
23792: LD_INT 1
23794: PLUS
23795: PPUSH
23796: LD_VAR 0 9
23800: PUSH
23801: LD_VAR 0 3
23805: ARRAY
23806: PPUSH
23807: CALL_OW 2
23811: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23812: LD_ADDR_VAR 0 4
23816: PUSH
23817: LD_VAR 0 4
23821: PUSH
23822: LD_VAR 0 9
23826: PUSH
23827: LD_VAR 0 3
23831: ARRAY
23832: DIFF
23833: ST_TO_ADDR
// end ;
23834: GO 23743
23836: POP
23837: POP
// if p then
23838: LD_VAR 0 11
23842: IFFALSE 23867
// result := Replace ( result , 3 , p ) ;
23844: LD_ADDR_VAR 0 2
23848: PUSH
23849: LD_VAR 0 2
23853: PPUSH
23854: LD_INT 3
23856: PPUSH
23857: LD_VAR 0 11
23861: PPUSH
23862: CALL_OW 1
23866: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
23867: LD_VAR 0 4
23871: PUSH
23872: LD_INT 6
23874: GREATER
23875: PUSH
23876: LD_VAR 0 6
23880: PUSH
23881: LD_INT 6
23883: LESS
23884: AND
23885: IFFALSE 24079
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23887: LD_ADDR_VAR 0 9
23891: PUSH
23892: LD_VAR 0 4
23896: PUSH
23897: LD_VAR 0 8
23901: PUSH
23902: LD_VAR 0 7
23906: UNION
23907: PUSH
23908: LD_VAR 0 6
23912: UNION
23913: DIFF
23914: PPUSH
23915: LD_INT 2
23917: PPUSH
23918: CALL 88777 0 2
23922: ST_TO_ADDR
// p := [ ] ;
23923: LD_ADDR_VAR 0 11
23927: PUSH
23928: EMPTY
23929: ST_TO_ADDR
// if sort then
23930: LD_VAR 0 9
23934: IFFALSE 24050
// for i = 1 to 6 - eng do
23936: LD_ADDR_VAR 0 3
23940: PUSH
23941: DOUBLE
23942: LD_INT 1
23944: DEC
23945: ST_TO_ADDR
23946: LD_INT 6
23948: PUSH
23949: LD_VAR 0 6
23953: MINUS
23954: PUSH
23955: FOR_TO
23956: IFFALSE 24048
// begin if i = sort then
23958: LD_VAR 0 3
23962: PUSH
23963: LD_VAR 0 9
23967: EQUAL
23968: IFFALSE 23972
// break ;
23970: GO 24048
// if GetClass ( i ) = 2 then
23972: LD_VAR 0 3
23976: PPUSH
23977: CALL_OW 257
23981: PUSH
23982: LD_INT 2
23984: EQUAL
23985: IFFALSE 23989
// continue ;
23987: GO 23955
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23989: LD_ADDR_VAR 0 11
23993: PUSH
23994: LD_VAR 0 11
23998: PPUSH
23999: LD_VAR 0 11
24003: PUSH
24004: LD_INT 1
24006: PLUS
24007: PPUSH
24008: LD_VAR 0 9
24012: PUSH
24013: LD_VAR 0 3
24017: ARRAY
24018: PPUSH
24019: CALL_OW 2
24023: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24024: LD_ADDR_VAR 0 4
24028: PUSH
24029: LD_VAR 0 4
24033: PUSH
24034: LD_VAR 0 9
24038: PUSH
24039: LD_VAR 0 3
24043: ARRAY
24044: DIFF
24045: ST_TO_ADDR
// end ;
24046: GO 23955
24048: POP
24049: POP
// if p then
24050: LD_VAR 0 11
24054: IFFALSE 24079
// result := Replace ( result , 2 , p ) ;
24056: LD_ADDR_VAR 0 2
24060: PUSH
24061: LD_VAR 0 2
24065: PPUSH
24066: LD_INT 2
24068: PPUSH
24069: LD_VAR 0 11
24073: PPUSH
24074: CALL_OW 1
24078: ST_TO_ADDR
// end ; exit ;
24079: GO 25467
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24081: LD_EXP 77
24085: PUSH
24086: LD_EXP 76
24090: PUSH
24091: LD_VAR 0 1
24095: ARRAY
24096: ARRAY
24097: NOT
24098: PUSH
24099: LD_EXP 50
24103: PUSH
24104: LD_VAR 0 1
24108: ARRAY
24109: PPUSH
24110: LD_INT 30
24112: PUSH
24113: LD_INT 3
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PPUSH
24120: CALL_OW 72
24124: AND
24125: PUSH
24126: LD_EXP 55
24130: PUSH
24131: LD_VAR 0 1
24135: ARRAY
24136: AND
24137: IFFALSE 24745
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24139: LD_ADDR_EXP 92
24143: PUSH
24144: LD_EXP 92
24148: PPUSH
24149: LD_VAR 0 1
24153: PPUSH
24154: LD_INT 5
24156: PPUSH
24157: CALL_OW 1
24161: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24162: LD_ADDR_VAR 0 2
24166: PUSH
24167: LD_INT 0
24169: PUSH
24170: LD_INT 0
24172: PUSH
24173: LD_INT 0
24175: PUSH
24176: LD_INT 0
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: LIST
24183: LIST
24184: ST_TO_ADDR
// if sci > 1 then
24185: LD_VAR 0 8
24189: PUSH
24190: LD_INT 1
24192: GREATER
24193: IFFALSE 24221
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24195: LD_ADDR_VAR 0 4
24199: PUSH
24200: LD_VAR 0 4
24204: PUSH
24205: LD_VAR 0 8
24209: PUSH
24210: LD_VAR 0 8
24214: PUSH
24215: LD_INT 1
24217: ARRAY
24218: DIFF
24219: DIFF
24220: ST_TO_ADDR
// if tmp and not sci then
24221: LD_VAR 0 4
24225: PUSH
24226: LD_VAR 0 8
24230: NOT
24231: AND
24232: IFFALSE 24301
// begin sort := SortBySkill ( tmp , 4 ) ;
24234: LD_ADDR_VAR 0 9
24238: PUSH
24239: LD_VAR 0 4
24243: PPUSH
24244: LD_INT 4
24246: PPUSH
24247: CALL 88777 0 2
24251: ST_TO_ADDR
// if sort then
24252: LD_VAR 0 9
24256: IFFALSE 24272
// p := sort [ 1 ] ;
24258: LD_ADDR_VAR 0 11
24262: PUSH
24263: LD_VAR 0 9
24267: PUSH
24268: LD_INT 1
24270: ARRAY
24271: ST_TO_ADDR
// if p then
24272: LD_VAR 0 11
24276: IFFALSE 24301
// result := Replace ( result , 4 , p ) ;
24278: LD_ADDR_VAR 0 2
24282: PUSH
24283: LD_VAR 0 2
24287: PPUSH
24288: LD_INT 4
24290: PPUSH
24291: LD_VAR 0 11
24295: PPUSH
24296: CALL_OW 1
24300: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24301: LD_ADDR_VAR 0 4
24305: PUSH
24306: LD_VAR 0 4
24310: PUSH
24311: LD_VAR 0 7
24315: DIFF
24316: ST_TO_ADDR
// if tmp and mech < 6 then
24317: LD_VAR 0 4
24321: PUSH
24322: LD_VAR 0 7
24326: PUSH
24327: LD_INT 6
24329: LESS
24330: AND
24331: IFFALSE 24519
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24333: LD_ADDR_VAR 0 9
24337: PUSH
24338: LD_VAR 0 4
24342: PUSH
24343: LD_VAR 0 8
24347: PUSH
24348: LD_VAR 0 7
24352: UNION
24353: DIFF
24354: PPUSH
24355: LD_INT 3
24357: PPUSH
24358: CALL 88777 0 2
24362: ST_TO_ADDR
// p := [ ] ;
24363: LD_ADDR_VAR 0 11
24367: PUSH
24368: EMPTY
24369: ST_TO_ADDR
// if sort then
24370: LD_VAR 0 9
24374: IFFALSE 24490
// for i = 1 to 6 - mech do
24376: LD_ADDR_VAR 0 3
24380: PUSH
24381: DOUBLE
24382: LD_INT 1
24384: DEC
24385: ST_TO_ADDR
24386: LD_INT 6
24388: PUSH
24389: LD_VAR 0 7
24393: MINUS
24394: PUSH
24395: FOR_TO
24396: IFFALSE 24488
// begin if i = sort then
24398: LD_VAR 0 3
24402: PUSH
24403: LD_VAR 0 9
24407: EQUAL
24408: IFFALSE 24412
// break ;
24410: GO 24488
// if GetClass ( i ) = 3 then
24412: LD_VAR 0 3
24416: PPUSH
24417: CALL_OW 257
24421: PUSH
24422: LD_INT 3
24424: EQUAL
24425: IFFALSE 24429
// continue ;
24427: GO 24395
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24429: LD_ADDR_VAR 0 11
24433: PUSH
24434: LD_VAR 0 11
24438: PPUSH
24439: LD_VAR 0 11
24443: PUSH
24444: LD_INT 1
24446: PLUS
24447: PPUSH
24448: LD_VAR 0 9
24452: PUSH
24453: LD_VAR 0 3
24457: ARRAY
24458: PPUSH
24459: CALL_OW 2
24463: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24464: LD_ADDR_VAR 0 4
24468: PUSH
24469: LD_VAR 0 4
24473: PUSH
24474: LD_VAR 0 9
24478: PUSH
24479: LD_VAR 0 3
24483: ARRAY
24484: DIFF
24485: ST_TO_ADDR
// end ;
24486: GO 24395
24488: POP
24489: POP
// if p then
24490: LD_VAR 0 11
24494: IFFALSE 24519
// result := Replace ( result , 3 , p ) ;
24496: LD_ADDR_VAR 0 2
24500: PUSH
24501: LD_VAR 0 2
24505: PPUSH
24506: LD_INT 3
24508: PPUSH
24509: LD_VAR 0 11
24513: PPUSH
24514: CALL_OW 1
24518: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24519: LD_ADDR_VAR 0 4
24523: PUSH
24524: LD_VAR 0 4
24528: PUSH
24529: LD_VAR 0 6
24533: DIFF
24534: ST_TO_ADDR
// if tmp and eng < 6 then
24535: LD_VAR 0 4
24539: PUSH
24540: LD_VAR 0 6
24544: PUSH
24545: LD_INT 6
24547: LESS
24548: AND
24549: IFFALSE 24743
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24551: LD_ADDR_VAR 0 9
24555: PUSH
24556: LD_VAR 0 4
24560: PUSH
24561: LD_VAR 0 8
24565: PUSH
24566: LD_VAR 0 7
24570: UNION
24571: PUSH
24572: LD_VAR 0 6
24576: UNION
24577: DIFF
24578: PPUSH
24579: LD_INT 2
24581: PPUSH
24582: CALL 88777 0 2
24586: ST_TO_ADDR
// p := [ ] ;
24587: LD_ADDR_VAR 0 11
24591: PUSH
24592: EMPTY
24593: ST_TO_ADDR
// if sort then
24594: LD_VAR 0 9
24598: IFFALSE 24714
// for i = 1 to 6 - eng do
24600: LD_ADDR_VAR 0 3
24604: PUSH
24605: DOUBLE
24606: LD_INT 1
24608: DEC
24609: ST_TO_ADDR
24610: LD_INT 6
24612: PUSH
24613: LD_VAR 0 6
24617: MINUS
24618: PUSH
24619: FOR_TO
24620: IFFALSE 24712
// begin if i = sort then
24622: LD_VAR 0 3
24626: PUSH
24627: LD_VAR 0 9
24631: EQUAL
24632: IFFALSE 24636
// break ;
24634: GO 24712
// if GetClass ( i ) = 2 then
24636: LD_VAR 0 3
24640: PPUSH
24641: CALL_OW 257
24645: PUSH
24646: LD_INT 2
24648: EQUAL
24649: IFFALSE 24653
// continue ;
24651: GO 24619
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24653: LD_ADDR_VAR 0 11
24657: PUSH
24658: LD_VAR 0 11
24662: PPUSH
24663: LD_VAR 0 11
24667: PUSH
24668: LD_INT 1
24670: PLUS
24671: PPUSH
24672: LD_VAR 0 9
24676: PUSH
24677: LD_VAR 0 3
24681: ARRAY
24682: PPUSH
24683: CALL_OW 2
24687: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24688: LD_ADDR_VAR 0 4
24692: PUSH
24693: LD_VAR 0 4
24697: PUSH
24698: LD_VAR 0 9
24702: PUSH
24703: LD_VAR 0 3
24707: ARRAY
24708: DIFF
24709: ST_TO_ADDR
// end ;
24710: GO 24619
24712: POP
24713: POP
// if p then
24714: LD_VAR 0 11
24718: IFFALSE 24743
// result := Replace ( result , 2 , p ) ;
24720: LD_ADDR_VAR 0 2
24724: PUSH
24725: LD_VAR 0 2
24729: PPUSH
24730: LD_INT 2
24732: PPUSH
24733: LD_VAR 0 11
24737: PPUSH
24738: CALL_OW 1
24742: ST_TO_ADDR
// end ; exit ;
24743: GO 25467
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24745: LD_EXP 77
24749: PUSH
24750: LD_EXP 76
24754: PUSH
24755: LD_VAR 0 1
24759: ARRAY
24760: ARRAY
24761: NOT
24762: PUSH
24763: LD_EXP 50
24767: PUSH
24768: LD_VAR 0 1
24772: ARRAY
24773: PPUSH
24774: LD_INT 30
24776: PUSH
24777: LD_INT 3
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PPUSH
24784: CALL_OW 72
24788: AND
24789: PUSH
24790: LD_EXP 55
24794: PUSH
24795: LD_VAR 0 1
24799: ARRAY
24800: NOT
24801: AND
24802: IFFALSE 25467
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24804: LD_ADDR_EXP 92
24808: PUSH
24809: LD_EXP 92
24813: PPUSH
24814: LD_VAR 0 1
24818: PPUSH
24819: LD_INT 6
24821: PPUSH
24822: CALL_OW 1
24826: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24827: LD_ADDR_VAR 0 2
24831: PUSH
24832: LD_INT 0
24834: PUSH
24835: LD_INT 0
24837: PUSH
24838: LD_INT 0
24840: PUSH
24841: LD_INT 0
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: LIST
24848: LIST
24849: ST_TO_ADDR
// if sci >= 1 then
24850: LD_VAR 0 8
24854: PUSH
24855: LD_INT 1
24857: GREATEREQUAL
24858: IFFALSE 24880
// tmp := tmp diff sci [ 1 ] ;
24860: LD_ADDR_VAR 0 4
24864: PUSH
24865: LD_VAR 0 4
24869: PUSH
24870: LD_VAR 0 8
24874: PUSH
24875: LD_INT 1
24877: ARRAY
24878: DIFF
24879: ST_TO_ADDR
// if tmp and not sci then
24880: LD_VAR 0 4
24884: PUSH
24885: LD_VAR 0 8
24889: NOT
24890: AND
24891: IFFALSE 24960
// begin sort := SortBySkill ( tmp , 4 ) ;
24893: LD_ADDR_VAR 0 9
24897: PUSH
24898: LD_VAR 0 4
24902: PPUSH
24903: LD_INT 4
24905: PPUSH
24906: CALL 88777 0 2
24910: ST_TO_ADDR
// if sort then
24911: LD_VAR 0 9
24915: IFFALSE 24931
// p := sort [ 1 ] ;
24917: LD_ADDR_VAR 0 11
24921: PUSH
24922: LD_VAR 0 9
24926: PUSH
24927: LD_INT 1
24929: ARRAY
24930: ST_TO_ADDR
// if p then
24931: LD_VAR 0 11
24935: IFFALSE 24960
// result := Replace ( result , 4 , p ) ;
24937: LD_ADDR_VAR 0 2
24941: PUSH
24942: LD_VAR 0 2
24946: PPUSH
24947: LD_INT 4
24949: PPUSH
24950: LD_VAR 0 11
24954: PPUSH
24955: CALL_OW 1
24959: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24960: LD_ADDR_VAR 0 4
24964: PUSH
24965: LD_VAR 0 4
24969: PUSH
24970: LD_VAR 0 7
24974: DIFF
24975: ST_TO_ADDR
// if tmp and mech < 6 then
24976: LD_VAR 0 4
24980: PUSH
24981: LD_VAR 0 7
24985: PUSH
24986: LD_INT 6
24988: LESS
24989: AND
24990: IFFALSE 25172
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
24992: LD_ADDR_VAR 0 9
24996: PUSH
24997: LD_VAR 0 4
25001: PUSH
25002: LD_VAR 0 7
25006: DIFF
25007: PPUSH
25008: LD_INT 3
25010: PPUSH
25011: CALL 88777 0 2
25015: ST_TO_ADDR
// p := [ ] ;
25016: LD_ADDR_VAR 0 11
25020: PUSH
25021: EMPTY
25022: ST_TO_ADDR
// if sort then
25023: LD_VAR 0 9
25027: IFFALSE 25143
// for i = 1 to 6 - mech do
25029: LD_ADDR_VAR 0 3
25033: PUSH
25034: DOUBLE
25035: LD_INT 1
25037: DEC
25038: ST_TO_ADDR
25039: LD_INT 6
25041: PUSH
25042: LD_VAR 0 7
25046: MINUS
25047: PUSH
25048: FOR_TO
25049: IFFALSE 25141
// begin if i = sort then
25051: LD_VAR 0 3
25055: PUSH
25056: LD_VAR 0 9
25060: EQUAL
25061: IFFALSE 25065
// break ;
25063: GO 25141
// if GetClass ( i ) = 3 then
25065: LD_VAR 0 3
25069: PPUSH
25070: CALL_OW 257
25074: PUSH
25075: LD_INT 3
25077: EQUAL
25078: IFFALSE 25082
// continue ;
25080: GO 25048
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25082: LD_ADDR_VAR 0 11
25086: PUSH
25087: LD_VAR 0 11
25091: PPUSH
25092: LD_VAR 0 11
25096: PUSH
25097: LD_INT 1
25099: PLUS
25100: PPUSH
25101: LD_VAR 0 9
25105: PUSH
25106: LD_VAR 0 3
25110: ARRAY
25111: PPUSH
25112: CALL_OW 2
25116: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25117: LD_ADDR_VAR 0 4
25121: PUSH
25122: LD_VAR 0 4
25126: PUSH
25127: LD_VAR 0 9
25131: PUSH
25132: LD_VAR 0 3
25136: ARRAY
25137: DIFF
25138: ST_TO_ADDR
// end ;
25139: GO 25048
25141: POP
25142: POP
// if p then
25143: LD_VAR 0 11
25147: IFFALSE 25172
// result := Replace ( result , 3 , p ) ;
25149: LD_ADDR_VAR 0 2
25153: PUSH
25154: LD_VAR 0 2
25158: PPUSH
25159: LD_INT 3
25161: PPUSH
25162: LD_VAR 0 11
25166: PPUSH
25167: CALL_OW 1
25171: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25172: LD_ADDR_VAR 0 4
25176: PUSH
25177: LD_VAR 0 4
25181: PUSH
25182: LD_VAR 0 6
25186: DIFF
25187: ST_TO_ADDR
// if tmp and eng < 4 then
25188: LD_VAR 0 4
25192: PUSH
25193: LD_VAR 0 6
25197: PUSH
25198: LD_INT 4
25200: LESS
25201: AND
25202: IFFALSE 25392
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25204: LD_ADDR_VAR 0 9
25208: PUSH
25209: LD_VAR 0 4
25213: PUSH
25214: LD_VAR 0 7
25218: PUSH
25219: LD_VAR 0 6
25223: UNION
25224: DIFF
25225: PPUSH
25226: LD_INT 2
25228: PPUSH
25229: CALL 88777 0 2
25233: ST_TO_ADDR
// p := [ ] ;
25234: LD_ADDR_VAR 0 11
25238: PUSH
25239: EMPTY
25240: ST_TO_ADDR
// if sort then
25241: LD_VAR 0 9
25245: IFFALSE 25361
// for i = 1 to 4 - eng do
25247: LD_ADDR_VAR 0 3
25251: PUSH
25252: DOUBLE
25253: LD_INT 1
25255: DEC
25256: ST_TO_ADDR
25257: LD_INT 4
25259: PUSH
25260: LD_VAR 0 6
25264: MINUS
25265: PUSH
25266: FOR_TO
25267: IFFALSE 25359
// begin if i = sort then
25269: LD_VAR 0 3
25273: PUSH
25274: LD_VAR 0 9
25278: EQUAL
25279: IFFALSE 25283
// break ;
25281: GO 25359
// if GetClass ( i ) = 2 then
25283: LD_VAR 0 3
25287: PPUSH
25288: CALL_OW 257
25292: PUSH
25293: LD_INT 2
25295: EQUAL
25296: IFFALSE 25300
// continue ;
25298: GO 25266
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25300: LD_ADDR_VAR 0 11
25304: PUSH
25305: LD_VAR 0 11
25309: PPUSH
25310: LD_VAR 0 11
25314: PUSH
25315: LD_INT 1
25317: PLUS
25318: PPUSH
25319: LD_VAR 0 9
25323: PUSH
25324: LD_VAR 0 3
25328: ARRAY
25329: PPUSH
25330: CALL_OW 2
25334: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25335: LD_ADDR_VAR 0 4
25339: PUSH
25340: LD_VAR 0 4
25344: PUSH
25345: LD_VAR 0 9
25349: PUSH
25350: LD_VAR 0 3
25354: ARRAY
25355: DIFF
25356: ST_TO_ADDR
// end ;
25357: GO 25266
25359: POP
25360: POP
// if p then
25361: LD_VAR 0 11
25365: IFFALSE 25390
// result := Replace ( result , 2 , p ) ;
25367: LD_ADDR_VAR 0 2
25371: PUSH
25372: LD_VAR 0 2
25376: PPUSH
25377: LD_INT 2
25379: PPUSH
25380: LD_VAR 0 11
25384: PPUSH
25385: CALL_OW 1
25389: ST_TO_ADDR
// end else
25390: GO 25436
// for i = eng downto 5 do
25392: LD_ADDR_VAR 0 3
25396: PUSH
25397: DOUBLE
25398: LD_VAR 0 6
25402: INC
25403: ST_TO_ADDR
25404: LD_INT 5
25406: PUSH
25407: FOR_DOWNTO
25408: IFFALSE 25434
// tmp := tmp union eng [ i ] ;
25410: LD_ADDR_VAR 0 4
25414: PUSH
25415: LD_VAR 0 4
25419: PUSH
25420: LD_VAR 0 6
25424: PUSH
25425: LD_VAR 0 3
25429: ARRAY
25430: UNION
25431: ST_TO_ADDR
25432: GO 25407
25434: POP
25435: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25436: LD_ADDR_VAR 0 2
25440: PUSH
25441: LD_VAR 0 2
25445: PPUSH
25446: LD_INT 1
25448: PPUSH
25449: LD_VAR 0 4
25453: PUSH
25454: LD_VAR 0 5
25458: DIFF
25459: PPUSH
25460: CALL_OW 1
25464: ST_TO_ADDR
// exit ;
25465: GO 25467
// end ; end ;
25467: LD_VAR 0 2
25471: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25472: LD_INT 0
25474: PPUSH
25475: PPUSH
25476: PPUSH
// if not mc_bases then
25477: LD_EXP 50
25481: NOT
25482: IFFALSE 25486
// exit ;
25484: GO 25592
// for i = 1 to mc_bases do
25486: LD_ADDR_VAR 0 2
25490: PUSH
25491: DOUBLE
25492: LD_INT 1
25494: DEC
25495: ST_TO_ADDR
25496: LD_EXP 50
25500: PUSH
25501: FOR_TO
25502: IFFALSE 25583
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25504: LD_ADDR_VAR 0 3
25508: PUSH
25509: LD_EXP 50
25513: PUSH
25514: LD_VAR 0 2
25518: ARRAY
25519: PPUSH
25520: LD_INT 21
25522: PUSH
25523: LD_INT 3
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 3
25532: PUSH
25533: LD_INT 24
25535: PUSH
25536: LD_INT 1000
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: EMPTY
25548: LIST
25549: LIST
25550: PPUSH
25551: CALL_OW 72
25555: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25556: LD_ADDR_EXP 51
25560: PUSH
25561: LD_EXP 51
25565: PPUSH
25566: LD_VAR 0 2
25570: PPUSH
25571: LD_VAR 0 3
25575: PPUSH
25576: CALL_OW 1
25580: ST_TO_ADDR
// end ;
25581: GO 25501
25583: POP
25584: POP
// RaiseSailEvent ( 101 ) ;
25585: LD_INT 101
25587: PPUSH
25588: CALL_OW 427
// end ;
25592: LD_VAR 0 1
25596: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25597: LD_INT 0
25599: PPUSH
25600: PPUSH
25601: PPUSH
25602: PPUSH
25603: PPUSH
25604: PPUSH
25605: PPUSH
// if not mc_bases then
25606: LD_EXP 50
25610: NOT
25611: IFFALSE 25615
// exit ;
25613: GO 26188
// for i = 1 to mc_bases do
25615: LD_ADDR_VAR 0 2
25619: PUSH
25620: DOUBLE
25621: LD_INT 1
25623: DEC
25624: ST_TO_ADDR
25625: LD_EXP 50
25629: PUSH
25630: FOR_TO
25631: IFFALSE 26179
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25633: LD_ADDR_VAR 0 5
25637: PUSH
25638: LD_EXP 50
25642: PUSH
25643: LD_VAR 0 2
25647: ARRAY
25648: PUSH
25649: LD_EXP 79
25653: PUSH
25654: LD_VAR 0 2
25658: ARRAY
25659: UNION
25660: PPUSH
25661: LD_INT 21
25663: PUSH
25664: LD_INT 1
25666: PUSH
25667: EMPTY
25668: LIST
25669: LIST
25670: PUSH
25671: LD_INT 1
25673: PUSH
25674: LD_INT 3
25676: PUSH
25677: LD_INT 54
25679: PUSH
25680: EMPTY
25681: LIST
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: LD_INT 3
25689: PUSH
25690: LD_INT 24
25692: PUSH
25693: LD_INT 800
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: LIST
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PPUSH
25713: CALL_OW 72
25717: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25718: LD_ADDR_VAR 0 6
25722: PUSH
25723: LD_EXP 50
25727: PUSH
25728: LD_VAR 0 2
25732: ARRAY
25733: PPUSH
25734: LD_INT 21
25736: PUSH
25737: LD_INT 1
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 1
25746: PUSH
25747: LD_INT 3
25749: PUSH
25750: LD_INT 54
25752: PUSH
25753: EMPTY
25754: LIST
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 3
25762: PUSH
25763: LD_INT 24
25765: PUSH
25766: LD_INT 250
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: PUSH
25777: EMPTY
25778: LIST
25779: LIST
25780: LIST
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PPUSH
25786: CALL_OW 72
25790: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25791: LD_ADDR_VAR 0 7
25795: PUSH
25796: LD_VAR 0 5
25800: PUSH
25801: LD_VAR 0 6
25805: DIFF
25806: ST_TO_ADDR
// if not need_heal_1 then
25807: LD_VAR 0 6
25811: NOT
25812: IFFALSE 25845
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25814: LD_ADDR_EXP 53
25818: PUSH
25819: LD_EXP 53
25823: PPUSH
25824: LD_VAR 0 2
25828: PUSH
25829: LD_INT 1
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: PPUSH
25836: EMPTY
25837: PPUSH
25838: CALL 54503 0 3
25842: ST_TO_ADDR
25843: GO 25915
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25845: LD_ADDR_EXP 53
25849: PUSH
25850: LD_EXP 53
25854: PPUSH
25855: LD_VAR 0 2
25859: PUSH
25860: LD_INT 1
25862: PUSH
25863: EMPTY
25864: LIST
25865: LIST
25866: PPUSH
25867: LD_EXP 53
25871: PUSH
25872: LD_VAR 0 2
25876: ARRAY
25877: PUSH
25878: LD_INT 1
25880: ARRAY
25881: PPUSH
25882: LD_INT 3
25884: PUSH
25885: LD_INT 24
25887: PUSH
25888: LD_INT 1000
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: EMPTY
25896: LIST
25897: LIST
25898: PPUSH
25899: CALL_OW 72
25903: PUSH
25904: LD_VAR 0 6
25908: UNION
25909: PPUSH
25910: CALL 54503 0 3
25914: ST_TO_ADDR
// if not need_heal_2 then
25915: LD_VAR 0 7
25919: NOT
25920: IFFALSE 25953
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
25922: LD_ADDR_EXP 53
25926: PUSH
25927: LD_EXP 53
25931: PPUSH
25932: LD_VAR 0 2
25936: PUSH
25937: LD_INT 2
25939: PUSH
25940: EMPTY
25941: LIST
25942: LIST
25943: PPUSH
25944: EMPTY
25945: PPUSH
25946: CALL 54503 0 3
25950: ST_TO_ADDR
25951: GO 25985
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
25953: LD_ADDR_EXP 53
25957: PUSH
25958: LD_EXP 53
25962: PPUSH
25963: LD_VAR 0 2
25967: PUSH
25968: LD_INT 2
25970: PUSH
25971: EMPTY
25972: LIST
25973: LIST
25974: PPUSH
25975: LD_VAR 0 7
25979: PPUSH
25980: CALL 54503 0 3
25984: ST_TO_ADDR
// if need_heal_2 then
25985: LD_VAR 0 7
25989: IFFALSE 26161
// for j in need_heal_2 do
25991: LD_ADDR_VAR 0 3
25995: PUSH
25996: LD_VAR 0 7
26000: PUSH
26001: FOR_IN
26002: IFFALSE 26159
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
26004: LD_ADDR_VAR 0 5
26008: PUSH
26009: LD_EXP 50
26013: PUSH
26014: LD_VAR 0 2
26018: ARRAY
26019: PPUSH
26020: LD_INT 2
26022: PUSH
26023: LD_INT 30
26025: PUSH
26026: LD_INT 6
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PUSH
26033: LD_INT 30
26035: PUSH
26036: LD_INT 7
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: PUSH
26043: LD_INT 30
26045: PUSH
26046: LD_INT 8
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: PUSH
26053: LD_INT 30
26055: PUSH
26056: LD_INT 0
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 30
26065: PUSH
26066: LD_INT 1
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 25
26075: PUSH
26076: LD_INT 4
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: LIST
26087: LIST
26088: LIST
26089: LIST
26090: LIST
26091: PPUSH
26092: CALL_OW 72
26096: ST_TO_ADDR
// if tmp then
26097: LD_VAR 0 5
26101: IFFALSE 26157
// begin k := NearestUnitToUnit ( tmp , j ) ;
26103: LD_ADDR_VAR 0 4
26107: PUSH
26108: LD_VAR 0 5
26112: PPUSH
26113: LD_VAR 0 3
26117: PPUSH
26118: CALL_OW 74
26122: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
26123: LD_VAR 0 3
26127: PPUSH
26128: LD_VAR 0 4
26132: PPUSH
26133: CALL_OW 296
26137: PUSH
26138: LD_INT 7
26140: GREATER
26141: IFFALSE 26157
// ComMoveUnit ( j , k ) ;
26143: LD_VAR 0 3
26147: PPUSH
26148: LD_VAR 0 4
26152: PPUSH
26153: CALL_OW 112
// end ; end ;
26157: GO 26001
26159: POP
26160: POP
// if not need_heal_1 and not need_heal_2 then
26161: LD_VAR 0 6
26165: NOT
26166: PUSH
26167: LD_VAR 0 7
26171: NOT
26172: AND
26173: IFFALSE 26177
// continue ;
26175: GO 25630
// end ;
26177: GO 25630
26179: POP
26180: POP
// RaiseSailEvent ( 102 ) ;
26181: LD_INT 102
26183: PPUSH
26184: CALL_OW 427
// end ;
26188: LD_VAR 0 1
26192: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26193: LD_INT 0
26195: PPUSH
26196: PPUSH
26197: PPUSH
26198: PPUSH
26199: PPUSH
26200: PPUSH
26201: PPUSH
26202: PPUSH
// if not mc_bases then
26203: LD_EXP 50
26207: NOT
26208: IFFALSE 26212
// exit ;
26210: GO 27052
// for i = 1 to mc_bases do
26212: LD_ADDR_VAR 0 2
26216: PUSH
26217: DOUBLE
26218: LD_INT 1
26220: DEC
26221: ST_TO_ADDR
26222: LD_EXP 50
26226: PUSH
26227: FOR_TO
26228: IFFALSE 27050
// begin if not mc_building_need_repair [ i ] then
26230: LD_EXP 51
26234: PUSH
26235: LD_VAR 0 2
26239: ARRAY
26240: NOT
26241: IFFALSE 26415
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26243: LD_ADDR_VAR 0 6
26247: PUSH
26248: LD_EXP 69
26252: PUSH
26253: LD_VAR 0 2
26257: ARRAY
26258: PPUSH
26259: LD_INT 3
26261: PUSH
26262: LD_INT 24
26264: PUSH
26265: LD_INT 1000
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 2
26278: PUSH
26279: LD_INT 34
26281: PUSH
26282: LD_INT 13
26284: PUSH
26285: EMPTY
26286: LIST
26287: LIST
26288: PUSH
26289: LD_INT 34
26291: PUSH
26292: LD_INT 52
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: LIST
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PPUSH
26308: CALL_OW 72
26312: ST_TO_ADDR
// if cranes then
26313: LD_VAR 0 6
26317: IFFALSE 26379
// for j in cranes do
26319: LD_ADDR_VAR 0 3
26323: PUSH
26324: LD_VAR 0 6
26328: PUSH
26329: FOR_IN
26330: IFFALSE 26377
// if not IsInArea ( j , mc_parking [ i ] ) then
26332: LD_VAR 0 3
26336: PPUSH
26337: LD_EXP 74
26341: PUSH
26342: LD_VAR 0 2
26346: ARRAY
26347: PPUSH
26348: CALL_OW 308
26352: NOT
26353: IFFALSE 26375
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26355: LD_VAR 0 3
26359: PPUSH
26360: LD_EXP 74
26364: PUSH
26365: LD_VAR 0 2
26369: ARRAY
26370: PPUSH
26371: CALL_OW 113
26375: GO 26329
26377: POP
26378: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26379: LD_ADDR_EXP 52
26383: PUSH
26384: LD_EXP 52
26388: PPUSH
26389: LD_VAR 0 2
26393: PPUSH
26394: EMPTY
26395: PPUSH
26396: CALL_OW 1
26400: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26401: LD_VAR 0 2
26405: PPUSH
26406: LD_INT 101
26408: PPUSH
26409: CALL 21305 0 2
// continue ;
26413: GO 26227
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26415: LD_ADDR_EXP 56
26419: PUSH
26420: LD_EXP 56
26424: PPUSH
26425: LD_VAR 0 2
26429: PPUSH
26430: EMPTY
26431: PPUSH
26432: CALL_OW 1
26436: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26437: LD_VAR 0 2
26441: PPUSH
26442: LD_INT 103
26444: PPUSH
26445: CALL 21305 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26449: LD_ADDR_VAR 0 5
26453: PUSH
26454: LD_EXP 50
26458: PUSH
26459: LD_VAR 0 2
26463: ARRAY
26464: PUSH
26465: LD_EXP 79
26469: PUSH
26470: LD_VAR 0 2
26474: ARRAY
26475: UNION
26476: PPUSH
26477: LD_INT 2
26479: PUSH
26480: LD_INT 25
26482: PUSH
26483: LD_INT 2
26485: PUSH
26486: EMPTY
26487: LIST
26488: LIST
26489: PUSH
26490: LD_INT 25
26492: PUSH
26493: LD_INT 16
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: LIST
26504: PUSH
26505: EMPTY
26506: LIST
26507: PPUSH
26508: CALL_OW 72
26512: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26513: LD_ADDR_VAR 0 6
26517: PUSH
26518: LD_EXP 69
26522: PUSH
26523: LD_VAR 0 2
26527: ARRAY
26528: PPUSH
26529: LD_INT 2
26531: PUSH
26532: LD_INT 34
26534: PUSH
26535: LD_INT 13
26537: PUSH
26538: EMPTY
26539: LIST
26540: LIST
26541: PUSH
26542: LD_INT 34
26544: PUSH
26545: LD_INT 52
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: LIST
26556: PPUSH
26557: CALL_OW 72
26561: ST_TO_ADDR
// if cranes then
26562: LD_VAR 0 6
26566: IFFALSE 26702
// begin for j in cranes do
26568: LD_ADDR_VAR 0 3
26572: PUSH
26573: LD_VAR 0 6
26577: PUSH
26578: FOR_IN
26579: IFFALSE 26700
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26581: LD_VAR 0 3
26585: PPUSH
26586: CALL_OW 256
26590: PUSH
26591: LD_INT 500
26593: GREATEREQUAL
26594: PUSH
26595: LD_VAR 0 3
26599: PPUSH
26600: CALL_OW 314
26604: NOT
26605: AND
26606: IFFALSE 26640
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26608: LD_VAR 0 3
26612: PPUSH
26613: LD_EXP 51
26617: PUSH
26618: LD_VAR 0 2
26622: ARRAY
26623: PPUSH
26624: LD_VAR 0 3
26628: PPUSH
26629: CALL_OW 74
26633: PPUSH
26634: CALL_OW 130
26638: GO 26698
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26640: LD_VAR 0 3
26644: PPUSH
26645: CALL_OW 256
26649: PUSH
26650: LD_INT 500
26652: LESS
26653: PUSH
26654: LD_VAR 0 3
26658: PPUSH
26659: LD_EXP 74
26663: PUSH
26664: LD_VAR 0 2
26668: ARRAY
26669: PPUSH
26670: CALL_OW 308
26674: NOT
26675: AND
26676: IFFALSE 26698
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26678: LD_VAR 0 3
26682: PPUSH
26683: LD_EXP 74
26687: PUSH
26688: LD_VAR 0 2
26692: ARRAY
26693: PPUSH
26694: CALL_OW 113
26698: GO 26578
26700: POP
26701: POP
// end ; if not tmp then
26702: LD_VAR 0 5
26706: NOT
26707: IFFALSE 26711
// continue ;
26709: GO 26227
// for j in tmp do
26711: LD_ADDR_VAR 0 3
26715: PUSH
26716: LD_VAR 0 5
26720: PUSH
26721: FOR_IN
26722: IFFALSE 27046
// begin if mc_need_heal [ i ] then
26724: LD_EXP 53
26728: PUSH
26729: LD_VAR 0 2
26733: ARRAY
26734: IFFALSE 26782
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26736: LD_VAR 0 3
26740: PUSH
26741: LD_EXP 53
26745: PUSH
26746: LD_VAR 0 2
26750: ARRAY
26751: PUSH
26752: LD_INT 1
26754: ARRAY
26755: IN
26756: PUSH
26757: LD_VAR 0 3
26761: PUSH
26762: LD_EXP 53
26766: PUSH
26767: LD_VAR 0 2
26771: ARRAY
26772: PUSH
26773: LD_INT 2
26775: ARRAY
26776: IN
26777: OR
26778: IFFALSE 26782
// continue ;
26780: GO 26721
// if IsInUnit ( j ) then
26782: LD_VAR 0 3
26786: PPUSH
26787: CALL_OW 310
26791: IFFALSE 26802
// ComExitBuilding ( j ) ;
26793: LD_VAR 0 3
26797: PPUSH
26798: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26802: LD_VAR 0 3
26806: PUSH
26807: LD_EXP 52
26811: PUSH
26812: LD_VAR 0 2
26816: ARRAY
26817: IN
26818: NOT
26819: IFFALSE 26877
// begin SetTag ( j , 101 ) ;
26821: LD_VAR 0 3
26825: PPUSH
26826: LD_INT 101
26828: PPUSH
26829: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26833: LD_ADDR_EXP 52
26837: PUSH
26838: LD_EXP 52
26842: PPUSH
26843: LD_VAR 0 2
26847: PUSH
26848: LD_EXP 52
26852: PUSH
26853: LD_VAR 0 2
26857: ARRAY
26858: PUSH
26859: LD_INT 1
26861: PLUS
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PPUSH
26867: LD_VAR 0 3
26871: PPUSH
26872: CALL 54503 0 3
26876: ST_TO_ADDR
// end ; wait ( 1 ) ;
26877: LD_INT 1
26879: PPUSH
26880: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
26884: LD_ADDR_VAR 0 7
26888: PUSH
26889: LD_EXP 51
26893: PUSH
26894: LD_VAR 0 2
26898: ARRAY
26899: ST_TO_ADDR
// if mc_scan [ i ] then
26900: LD_EXP 73
26904: PUSH
26905: LD_VAR 0 2
26909: ARRAY
26910: IFFALSE 26979
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
26912: LD_ADDR_VAR 0 7
26916: PUSH
26917: LD_EXP 51
26921: PUSH
26922: LD_VAR 0 2
26926: ARRAY
26927: PPUSH
26928: LD_INT 3
26930: PUSH
26931: LD_INT 2
26933: PUSH
26934: LD_INT 30
26936: PUSH
26937: LD_INT 32
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 30
26946: PUSH
26947: LD_INT 33
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: LD_INT 30
26956: PUSH
26957: LD_INT 31
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: LIST
26968: LIST
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PPUSH
26974: CALL_OW 72
26978: ST_TO_ADDR
// if not to_repair_tmp then
26979: LD_VAR 0 7
26983: NOT
26984: IFFALSE 26988
// continue ;
26986: GO 26721
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
26988: LD_ADDR_VAR 0 8
26992: PUSH
26993: LD_VAR 0 7
26997: PPUSH
26998: LD_VAR 0 3
27002: PPUSH
27003: CALL_OW 74
27007: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
27008: LD_VAR 0 8
27012: PPUSH
27013: LD_INT 14
27015: PPUSH
27016: CALL 57096 0 2
27020: PUSH
27021: LD_INT 4
27023: ARRAY
27024: PUSH
27025: LD_INT 5
27027: LESS
27028: IFFALSE 27044
// ComRepairBuilding ( j , to_repair ) ;
27030: LD_VAR 0 3
27034: PPUSH
27035: LD_VAR 0 8
27039: PPUSH
27040: CALL_OW 130
// end ;
27044: GO 26721
27046: POP
27047: POP
// end ;
27048: GO 26227
27050: POP
27051: POP
// end ;
27052: LD_VAR 0 1
27056: RET
// export function MC_Heal ; var i , j , tmp ; begin
27057: LD_INT 0
27059: PPUSH
27060: PPUSH
27061: PPUSH
27062: PPUSH
// if not mc_bases then
27063: LD_EXP 50
27067: NOT
27068: IFFALSE 27072
// exit ;
27070: GO 27474
// for i = 1 to mc_bases do
27072: LD_ADDR_VAR 0 2
27076: PUSH
27077: DOUBLE
27078: LD_INT 1
27080: DEC
27081: ST_TO_ADDR
27082: LD_EXP 50
27086: PUSH
27087: FOR_TO
27088: IFFALSE 27472
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27090: LD_EXP 53
27094: PUSH
27095: LD_VAR 0 2
27099: ARRAY
27100: PUSH
27101: LD_INT 1
27103: ARRAY
27104: NOT
27105: PUSH
27106: LD_EXP 53
27110: PUSH
27111: LD_VAR 0 2
27115: ARRAY
27116: PUSH
27117: LD_INT 2
27119: ARRAY
27120: NOT
27121: AND
27122: IFFALSE 27160
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27124: LD_ADDR_EXP 54
27128: PUSH
27129: LD_EXP 54
27133: PPUSH
27134: LD_VAR 0 2
27138: PPUSH
27139: EMPTY
27140: PPUSH
27141: CALL_OW 1
27145: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27146: LD_VAR 0 2
27150: PPUSH
27151: LD_INT 102
27153: PPUSH
27154: CALL 21305 0 2
// continue ;
27158: GO 27087
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27160: LD_ADDR_VAR 0 4
27164: PUSH
27165: LD_EXP 50
27169: PUSH
27170: LD_VAR 0 2
27174: ARRAY
27175: PPUSH
27176: LD_INT 25
27178: PUSH
27179: LD_INT 4
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PPUSH
27186: CALL_OW 72
27190: ST_TO_ADDR
// if not tmp then
27191: LD_VAR 0 4
27195: NOT
27196: IFFALSE 27200
// continue ;
27198: GO 27087
// if mc_taming [ i ] then
27200: LD_EXP 81
27204: PUSH
27205: LD_VAR 0 2
27209: ARRAY
27210: IFFALSE 27234
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27212: LD_ADDR_EXP 81
27216: PUSH
27217: LD_EXP 81
27221: PPUSH
27222: LD_VAR 0 2
27226: PPUSH
27227: EMPTY
27228: PPUSH
27229: CALL_OW 1
27233: ST_TO_ADDR
// for j in tmp do
27234: LD_ADDR_VAR 0 3
27238: PUSH
27239: LD_VAR 0 4
27243: PUSH
27244: FOR_IN
27245: IFFALSE 27468
// begin if IsInUnit ( j ) then
27247: LD_VAR 0 3
27251: PPUSH
27252: CALL_OW 310
27256: IFFALSE 27267
// ComExitBuilding ( j ) ;
27258: LD_VAR 0 3
27262: PPUSH
27263: CALL_OW 122
// if not j in mc_healers [ i ] then
27267: LD_VAR 0 3
27271: PUSH
27272: LD_EXP 54
27276: PUSH
27277: LD_VAR 0 2
27281: ARRAY
27282: IN
27283: NOT
27284: IFFALSE 27330
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27286: LD_ADDR_EXP 54
27290: PUSH
27291: LD_EXP 54
27295: PPUSH
27296: LD_VAR 0 2
27300: PUSH
27301: LD_EXP 54
27305: PUSH
27306: LD_VAR 0 2
27310: ARRAY
27311: PUSH
27312: LD_INT 1
27314: PLUS
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: PPUSH
27320: LD_VAR 0 3
27324: PPUSH
27325: CALL 54503 0 3
27329: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27330: LD_VAR 0 3
27334: PPUSH
27335: CALL_OW 110
27339: PUSH
27340: LD_INT 102
27342: NONEQUAL
27343: IFFALSE 27357
// SetTag ( j , 102 ) ;
27345: LD_VAR 0 3
27349: PPUSH
27350: LD_INT 102
27352: PPUSH
27353: CALL_OW 109
// Wait ( 3 ) ;
27357: LD_INT 3
27359: PPUSH
27360: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27364: LD_EXP 53
27368: PUSH
27369: LD_VAR 0 2
27373: ARRAY
27374: PUSH
27375: LD_INT 1
27377: ARRAY
27378: IFFALSE 27410
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27380: LD_VAR 0 3
27384: PPUSH
27385: LD_EXP 53
27389: PUSH
27390: LD_VAR 0 2
27394: ARRAY
27395: PUSH
27396: LD_INT 1
27398: ARRAY
27399: PUSH
27400: LD_INT 1
27402: ARRAY
27403: PPUSH
27404: CALL_OW 128
27408: GO 27466
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27410: LD_VAR 0 3
27414: PPUSH
27415: CALL_OW 314
27419: NOT
27420: PUSH
27421: LD_EXP 53
27425: PUSH
27426: LD_VAR 0 2
27430: ARRAY
27431: PUSH
27432: LD_INT 2
27434: ARRAY
27435: AND
27436: IFFALSE 27466
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27438: LD_VAR 0 3
27442: PPUSH
27443: LD_EXP 53
27447: PUSH
27448: LD_VAR 0 2
27452: ARRAY
27453: PUSH
27454: LD_INT 2
27456: ARRAY
27457: PUSH
27458: LD_INT 1
27460: ARRAY
27461: PPUSH
27462: CALL_OW 128
// end ;
27466: GO 27244
27468: POP
27469: POP
// end ;
27470: GO 27087
27472: POP
27473: POP
// end ;
27474: LD_VAR 0 1
27478: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27479: LD_INT 0
27481: PPUSH
27482: PPUSH
27483: PPUSH
27484: PPUSH
27485: PPUSH
// if not mc_bases then
27486: LD_EXP 50
27490: NOT
27491: IFFALSE 27495
// exit ;
27493: GO 28638
// for i = 1 to mc_bases do
27495: LD_ADDR_VAR 0 2
27499: PUSH
27500: DOUBLE
27501: LD_INT 1
27503: DEC
27504: ST_TO_ADDR
27505: LD_EXP 50
27509: PUSH
27510: FOR_TO
27511: IFFALSE 28636
// begin if mc_scan [ i ] then
27513: LD_EXP 73
27517: PUSH
27518: LD_VAR 0 2
27522: ARRAY
27523: IFFALSE 27527
// continue ;
27525: GO 27510
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27527: LD_EXP 55
27531: PUSH
27532: LD_VAR 0 2
27536: ARRAY
27537: NOT
27538: PUSH
27539: LD_EXP 57
27543: PUSH
27544: LD_VAR 0 2
27548: ARRAY
27549: NOT
27550: AND
27551: PUSH
27552: LD_EXP 56
27556: PUSH
27557: LD_VAR 0 2
27561: ARRAY
27562: AND
27563: IFFALSE 27601
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27565: LD_ADDR_EXP 56
27569: PUSH
27570: LD_EXP 56
27574: PPUSH
27575: LD_VAR 0 2
27579: PPUSH
27580: EMPTY
27581: PPUSH
27582: CALL_OW 1
27586: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27587: LD_VAR 0 2
27591: PPUSH
27592: LD_INT 103
27594: PPUSH
27595: CALL 21305 0 2
// continue ;
27599: GO 27510
// end ; if mc_construct_list [ i ] then
27601: LD_EXP 57
27605: PUSH
27606: LD_VAR 0 2
27610: ARRAY
27611: IFFALSE 27831
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27613: LD_ADDR_VAR 0 4
27617: PUSH
27618: LD_EXP 50
27622: PUSH
27623: LD_VAR 0 2
27627: ARRAY
27628: PPUSH
27629: LD_INT 25
27631: PUSH
27632: LD_INT 2
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PPUSH
27639: CALL_OW 72
27643: PUSH
27644: LD_EXP 52
27648: PUSH
27649: LD_VAR 0 2
27653: ARRAY
27654: DIFF
27655: ST_TO_ADDR
// if not tmp then
27656: LD_VAR 0 4
27660: NOT
27661: IFFALSE 27665
// continue ;
27663: GO 27510
// for j in tmp do
27665: LD_ADDR_VAR 0 3
27669: PUSH
27670: LD_VAR 0 4
27674: PUSH
27675: FOR_IN
27676: IFFALSE 27827
// begin if not mc_builders [ i ] then
27678: LD_EXP 56
27682: PUSH
27683: LD_VAR 0 2
27687: ARRAY
27688: NOT
27689: IFFALSE 27747
// begin SetTag ( j , 103 ) ;
27691: LD_VAR 0 3
27695: PPUSH
27696: LD_INT 103
27698: PPUSH
27699: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27703: LD_ADDR_EXP 56
27707: PUSH
27708: LD_EXP 56
27712: PPUSH
27713: LD_VAR 0 2
27717: PUSH
27718: LD_EXP 56
27722: PUSH
27723: LD_VAR 0 2
27727: ARRAY
27728: PUSH
27729: LD_INT 1
27731: PLUS
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: PPUSH
27737: LD_VAR 0 3
27741: PPUSH
27742: CALL 54503 0 3
27746: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27747: LD_VAR 0 3
27751: PPUSH
27752: CALL_OW 310
27756: IFFALSE 27767
// ComExitBuilding ( j ) ;
27758: LD_VAR 0 3
27762: PPUSH
27763: CALL_OW 122
// wait ( 3 ) ;
27767: LD_INT 3
27769: PPUSH
27770: CALL_OW 67
// if not mc_construct_list [ i ] then
27774: LD_EXP 57
27778: PUSH
27779: LD_VAR 0 2
27783: ARRAY
27784: NOT
27785: IFFALSE 27789
// break ;
27787: GO 27827
// if not HasTask ( j ) then
27789: LD_VAR 0 3
27793: PPUSH
27794: CALL_OW 314
27798: NOT
27799: IFFALSE 27825
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27801: LD_VAR 0 3
27805: PPUSH
27806: LD_EXP 57
27810: PUSH
27811: LD_VAR 0 2
27815: ARRAY
27816: PUSH
27817: LD_INT 1
27819: ARRAY
27820: PPUSH
27821: CALL 57354 0 2
// end ;
27825: GO 27675
27827: POP
27828: POP
// end else
27829: GO 28634
// if mc_build_list [ i ] then
27831: LD_EXP 55
27835: PUSH
27836: LD_VAR 0 2
27840: ARRAY
27841: IFFALSE 28634
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27843: LD_ADDR_VAR 0 5
27847: PUSH
27848: LD_EXP 50
27852: PUSH
27853: LD_VAR 0 2
27857: ARRAY
27858: PPUSH
27859: LD_INT 2
27861: PUSH
27862: LD_INT 30
27864: PUSH
27865: LD_INT 0
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 30
27874: PUSH
27875: LD_INT 1
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: LIST
27886: PPUSH
27887: CALL_OW 72
27891: ST_TO_ADDR
// if depot then
27892: LD_VAR 0 5
27896: IFFALSE 27914
// depot := depot [ 1 ] else
27898: LD_ADDR_VAR 0 5
27902: PUSH
27903: LD_VAR 0 5
27907: PUSH
27908: LD_INT 1
27910: ARRAY
27911: ST_TO_ADDR
27912: GO 27922
// depot := 0 ;
27914: LD_ADDR_VAR 0 5
27918: PUSH
27919: LD_INT 0
27921: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
27922: LD_EXP 55
27926: PUSH
27927: LD_VAR 0 2
27931: ARRAY
27932: PUSH
27933: LD_INT 1
27935: ARRAY
27936: PUSH
27937: LD_INT 1
27939: ARRAY
27940: PPUSH
27941: CALL 57184 0 1
27945: PUSH
27946: LD_EXP 50
27950: PUSH
27951: LD_VAR 0 2
27955: ARRAY
27956: PPUSH
27957: LD_INT 2
27959: PUSH
27960: LD_INT 30
27962: PUSH
27963: LD_INT 2
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: PUSH
27970: LD_INT 30
27972: PUSH
27973: LD_INT 3
27975: PUSH
27976: EMPTY
27977: LIST
27978: LIST
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: LIST
27984: PPUSH
27985: CALL_OW 72
27989: NOT
27990: AND
27991: IFFALSE 28096
// begin for j = 1 to mc_build_list [ i ] do
27993: LD_ADDR_VAR 0 3
27997: PUSH
27998: DOUBLE
27999: LD_INT 1
28001: DEC
28002: ST_TO_ADDR
28003: LD_EXP 55
28007: PUSH
28008: LD_VAR 0 2
28012: ARRAY
28013: PUSH
28014: FOR_TO
28015: IFFALSE 28094
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28017: LD_EXP 55
28021: PUSH
28022: LD_VAR 0 2
28026: ARRAY
28027: PUSH
28028: LD_VAR 0 3
28032: ARRAY
28033: PUSH
28034: LD_INT 1
28036: ARRAY
28037: PUSH
28038: LD_INT 2
28040: EQUAL
28041: IFFALSE 28092
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28043: LD_ADDR_EXP 55
28047: PUSH
28048: LD_EXP 55
28052: PPUSH
28053: LD_VAR 0 2
28057: PPUSH
28058: LD_EXP 55
28062: PUSH
28063: LD_VAR 0 2
28067: ARRAY
28068: PPUSH
28069: LD_VAR 0 3
28073: PPUSH
28074: LD_INT 1
28076: PPUSH
28077: LD_INT 0
28079: PPUSH
28080: CALL 53921 0 4
28084: PPUSH
28085: CALL_OW 1
28089: ST_TO_ADDR
// break ;
28090: GO 28094
// end ;
28092: GO 28014
28094: POP
28095: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28096: LD_EXP 55
28100: PUSH
28101: LD_VAR 0 2
28105: ARRAY
28106: PUSH
28107: LD_INT 1
28109: ARRAY
28110: PUSH
28111: LD_INT 1
28113: ARRAY
28114: PUSH
28115: LD_INT 0
28117: EQUAL
28118: PUSH
28119: LD_VAR 0 5
28123: PUSH
28124: LD_VAR 0 5
28128: PPUSH
28129: LD_EXP 55
28133: PUSH
28134: LD_VAR 0 2
28138: ARRAY
28139: PUSH
28140: LD_INT 1
28142: ARRAY
28143: PUSH
28144: LD_INT 1
28146: ARRAY
28147: PPUSH
28148: LD_EXP 55
28152: PUSH
28153: LD_VAR 0 2
28157: ARRAY
28158: PUSH
28159: LD_INT 1
28161: ARRAY
28162: PUSH
28163: LD_INT 2
28165: ARRAY
28166: PPUSH
28167: LD_EXP 55
28171: PUSH
28172: LD_VAR 0 2
28176: ARRAY
28177: PUSH
28178: LD_INT 1
28180: ARRAY
28181: PUSH
28182: LD_INT 3
28184: ARRAY
28185: PPUSH
28186: LD_EXP 55
28190: PUSH
28191: LD_VAR 0 2
28195: ARRAY
28196: PUSH
28197: LD_INT 1
28199: ARRAY
28200: PUSH
28201: LD_INT 4
28203: ARRAY
28204: PPUSH
28205: CALL 61918 0 5
28209: AND
28210: OR
28211: IFFALSE 28492
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28213: LD_ADDR_VAR 0 4
28217: PUSH
28218: LD_EXP 50
28222: PUSH
28223: LD_VAR 0 2
28227: ARRAY
28228: PPUSH
28229: LD_INT 25
28231: PUSH
28232: LD_INT 2
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: PPUSH
28239: CALL_OW 72
28243: PUSH
28244: LD_EXP 52
28248: PUSH
28249: LD_VAR 0 2
28253: ARRAY
28254: DIFF
28255: ST_TO_ADDR
// if not tmp then
28256: LD_VAR 0 4
28260: NOT
28261: IFFALSE 28265
// continue ;
28263: GO 27510
// for j in tmp do
28265: LD_ADDR_VAR 0 3
28269: PUSH
28270: LD_VAR 0 4
28274: PUSH
28275: FOR_IN
28276: IFFALSE 28488
// begin if not mc_builders [ i ] then
28278: LD_EXP 56
28282: PUSH
28283: LD_VAR 0 2
28287: ARRAY
28288: NOT
28289: IFFALSE 28347
// begin SetTag ( j , 103 ) ;
28291: LD_VAR 0 3
28295: PPUSH
28296: LD_INT 103
28298: PPUSH
28299: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28303: LD_ADDR_EXP 56
28307: PUSH
28308: LD_EXP 56
28312: PPUSH
28313: LD_VAR 0 2
28317: PUSH
28318: LD_EXP 56
28322: PUSH
28323: LD_VAR 0 2
28327: ARRAY
28328: PUSH
28329: LD_INT 1
28331: PLUS
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PPUSH
28337: LD_VAR 0 3
28341: PPUSH
28342: CALL 54503 0 3
28346: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28347: LD_VAR 0 3
28351: PPUSH
28352: CALL_OW 310
28356: IFFALSE 28367
// ComExitBuilding ( j ) ;
28358: LD_VAR 0 3
28362: PPUSH
28363: CALL_OW 122
// wait ( 3 ) ;
28367: LD_INT 3
28369: PPUSH
28370: CALL_OW 67
// if not mc_build_list [ i ] then
28374: LD_EXP 55
28378: PUSH
28379: LD_VAR 0 2
28383: ARRAY
28384: NOT
28385: IFFALSE 28389
// break ;
28387: GO 28488
// if not HasTask ( j ) then
28389: LD_VAR 0 3
28393: PPUSH
28394: CALL_OW 314
28398: NOT
28399: IFFALSE 28486
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28401: LD_VAR 0 3
28405: PPUSH
28406: LD_EXP 55
28410: PUSH
28411: LD_VAR 0 2
28415: ARRAY
28416: PUSH
28417: LD_INT 1
28419: ARRAY
28420: PUSH
28421: LD_INT 1
28423: ARRAY
28424: PPUSH
28425: LD_EXP 55
28429: PUSH
28430: LD_VAR 0 2
28434: ARRAY
28435: PUSH
28436: LD_INT 1
28438: ARRAY
28439: PUSH
28440: LD_INT 2
28442: ARRAY
28443: PPUSH
28444: LD_EXP 55
28448: PUSH
28449: LD_VAR 0 2
28453: ARRAY
28454: PUSH
28455: LD_INT 1
28457: ARRAY
28458: PUSH
28459: LD_INT 3
28461: ARRAY
28462: PPUSH
28463: LD_EXP 55
28467: PUSH
28468: LD_VAR 0 2
28472: ARRAY
28473: PUSH
28474: LD_INT 1
28476: ARRAY
28477: PUSH
28478: LD_INT 4
28480: ARRAY
28481: PPUSH
28482: CALL_OW 145
// end ;
28486: GO 28275
28488: POP
28489: POP
// end else
28490: GO 28634
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28492: LD_EXP 50
28496: PUSH
28497: LD_VAR 0 2
28501: ARRAY
28502: PPUSH
28503: LD_EXP 55
28507: PUSH
28508: LD_VAR 0 2
28512: ARRAY
28513: PUSH
28514: LD_INT 1
28516: ARRAY
28517: PUSH
28518: LD_INT 1
28520: ARRAY
28521: PPUSH
28522: LD_EXP 55
28526: PUSH
28527: LD_VAR 0 2
28531: ARRAY
28532: PUSH
28533: LD_INT 1
28535: ARRAY
28536: PUSH
28537: LD_INT 2
28539: ARRAY
28540: PPUSH
28541: LD_EXP 55
28545: PUSH
28546: LD_VAR 0 2
28550: ARRAY
28551: PUSH
28552: LD_INT 1
28554: ARRAY
28555: PUSH
28556: LD_INT 3
28558: ARRAY
28559: PPUSH
28560: LD_EXP 55
28564: PUSH
28565: LD_VAR 0 2
28569: ARRAY
28570: PUSH
28571: LD_INT 1
28573: ARRAY
28574: PUSH
28575: LD_INT 4
28577: ARRAY
28578: PPUSH
28579: CALL 61254 0 5
28583: NOT
28584: IFFALSE 28634
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28586: LD_ADDR_EXP 55
28590: PUSH
28591: LD_EXP 55
28595: PPUSH
28596: LD_VAR 0 2
28600: PPUSH
28601: LD_EXP 55
28605: PUSH
28606: LD_VAR 0 2
28610: ARRAY
28611: PPUSH
28612: LD_INT 1
28614: PPUSH
28615: LD_INT 1
28617: NEG
28618: PPUSH
28619: LD_INT 0
28621: PPUSH
28622: CALL 53921 0 4
28626: PPUSH
28627: CALL_OW 1
28631: ST_TO_ADDR
// continue ;
28632: GO 27510
// end ; end ; end ;
28634: GO 27510
28636: POP
28637: POP
// end ;
28638: LD_VAR 0 1
28642: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28643: LD_INT 0
28645: PPUSH
28646: PPUSH
28647: PPUSH
28648: PPUSH
28649: PPUSH
28650: PPUSH
// if not mc_bases then
28651: LD_EXP 50
28655: NOT
28656: IFFALSE 28660
// exit ;
28658: GO 29087
// for i = 1 to mc_bases do
28660: LD_ADDR_VAR 0 2
28664: PUSH
28665: DOUBLE
28666: LD_INT 1
28668: DEC
28669: ST_TO_ADDR
28670: LD_EXP 50
28674: PUSH
28675: FOR_TO
28676: IFFALSE 29085
// begin tmp := mc_build_upgrade [ i ] ;
28678: LD_ADDR_VAR 0 4
28682: PUSH
28683: LD_EXP 82
28687: PUSH
28688: LD_VAR 0 2
28692: ARRAY
28693: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28694: LD_ADDR_VAR 0 6
28698: PUSH
28699: LD_EXP 83
28703: PUSH
28704: LD_VAR 0 2
28708: ARRAY
28709: PPUSH
28710: LD_INT 2
28712: PUSH
28713: LD_INT 30
28715: PUSH
28716: LD_INT 6
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: PUSH
28723: LD_INT 30
28725: PUSH
28726: LD_INT 7
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: LIST
28737: PPUSH
28738: CALL_OW 72
28742: ST_TO_ADDR
// if not tmp and not lab then
28743: LD_VAR 0 4
28747: NOT
28748: PUSH
28749: LD_VAR 0 6
28753: NOT
28754: AND
28755: IFFALSE 28759
// continue ;
28757: GO 28675
// if tmp then
28759: LD_VAR 0 4
28763: IFFALSE 28883
// for j in tmp do
28765: LD_ADDR_VAR 0 3
28769: PUSH
28770: LD_VAR 0 4
28774: PUSH
28775: FOR_IN
28776: IFFALSE 28881
// begin if UpgradeCost ( j ) then
28778: LD_VAR 0 3
28782: PPUSH
28783: CALL 60914 0 1
28787: IFFALSE 28879
// begin ComUpgrade ( j ) ;
28789: LD_VAR 0 3
28793: PPUSH
28794: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28798: LD_ADDR_EXP 82
28802: PUSH
28803: LD_EXP 82
28807: PPUSH
28808: LD_VAR 0 2
28812: PPUSH
28813: LD_EXP 82
28817: PUSH
28818: LD_VAR 0 2
28822: ARRAY
28823: PUSH
28824: LD_VAR 0 3
28828: DIFF
28829: PPUSH
28830: CALL_OW 1
28834: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28835: LD_ADDR_EXP 57
28839: PUSH
28840: LD_EXP 57
28844: PPUSH
28845: LD_VAR 0 2
28849: PUSH
28850: LD_EXP 57
28854: PUSH
28855: LD_VAR 0 2
28859: ARRAY
28860: PUSH
28861: LD_INT 1
28863: PLUS
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PPUSH
28869: LD_VAR 0 3
28873: PPUSH
28874: CALL 54503 0 3
28878: ST_TO_ADDR
// end ; end ;
28879: GO 28775
28881: POP
28882: POP
// if not lab or not mc_lab_upgrade [ i ] then
28883: LD_VAR 0 6
28887: NOT
28888: PUSH
28889: LD_EXP 84
28893: PUSH
28894: LD_VAR 0 2
28898: ARRAY
28899: NOT
28900: OR
28901: IFFALSE 28905
// continue ;
28903: GO 28675
// for j in lab do
28905: LD_ADDR_VAR 0 3
28909: PUSH
28910: LD_VAR 0 6
28914: PUSH
28915: FOR_IN
28916: IFFALSE 29081
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
28918: LD_VAR 0 3
28922: PPUSH
28923: CALL_OW 266
28927: PUSH
28928: LD_INT 6
28930: PUSH
28931: LD_INT 7
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: IN
28938: PUSH
28939: LD_VAR 0 3
28943: PPUSH
28944: CALL_OW 461
28948: PUSH
28949: LD_INT 1
28951: NONEQUAL
28952: AND
28953: IFFALSE 29079
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
28955: LD_VAR 0 3
28959: PPUSH
28960: LD_EXP 84
28964: PUSH
28965: LD_VAR 0 2
28969: ARRAY
28970: PUSH
28971: LD_INT 1
28973: ARRAY
28974: PPUSH
28975: CALL 61119 0 2
28979: IFFALSE 29079
// begin ComCancel ( j ) ;
28981: LD_VAR 0 3
28985: PPUSH
28986: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
28990: LD_VAR 0 3
28994: PPUSH
28995: LD_EXP 84
28999: PUSH
29000: LD_VAR 0 2
29004: ARRAY
29005: PUSH
29006: LD_INT 1
29008: ARRAY
29009: PPUSH
29010: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29014: LD_VAR 0 3
29018: PUSH
29019: LD_EXP 57
29023: PUSH
29024: LD_VAR 0 2
29028: ARRAY
29029: IN
29030: NOT
29031: IFFALSE 29077
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29033: LD_ADDR_EXP 57
29037: PUSH
29038: LD_EXP 57
29042: PPUSH
29043: LD_VAR 0 2
29047: PUSH
29048: LD_EXP 57
29052: PUSH
29053: LD_VAR 0 2
29057: ARRAY
29058: PUSH
29059: LD_INT 1
29061: PLUS
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PPUSH
29067: LD_VAR 0 3
29071: PPUSH
29072: CALL 54503 0 3
29076: ST_TO_ADDR
// break ;
29077: GO 29081
// end ; end ; end ;
29079: GO 28915
29081: POP
29082: POP
// end ;
29083: GO 28675
29085: POP
29086: POP
// end ;
29087: LD_VAR 0 1
29091: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29092: LD_INT 0
29094: PPUSH
29095: PPUSH
29096: PPUSH
29097: PPUSH
29098: PPUSH
29099: PPUSH
29100: PPUSH
29101: PPUSH
29102: PPUSH
// if not mc_bases then
29103: LD_EXP 50
29107: NOT
29108: IFFALSE 29112
// exit ;
29110: GO 29517
// for i = 1 to mc_bases do
29112: LD_ADDR_VAR 0 2
29116: PUSH
29117: DOUBLE
29118: LD_INT 1
29120: DEC
29121: ST_TO_ADDR
29122: LD_EXP 50
29126: PUSH
29127: FOR_TO
29128: IFFALSE 29515
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29130: LD_EXP 58
29134: PUSH
29135: LD_VAR 0 2
29139: ARRAY
29140: NOT
29141: PUSH
29142: LD_EXP 50
29146: PUSH
29147: LD_VAR 0 2
29151: ARRAY
29152: PPUSH
29153: LD_INT 30
29155: PUSH
29156: LD_INT 3
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PPUSH
29163: CALL_OW 72
29167: NOT
29168: OR
29169: IFFALSE 29173
// continue ;
29171: GO 29127
// busy := false ;
29173: LD_ADDR_VAR 0 8
29177: PUSH
29178: LD_INT 0
29180: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29181: LD_ADDR_VAR 0 4
29185: PUSH
29186: LD_EXP 50
29190: PUSH
29191: LD_VAR 0 2
29195: ARRAY
29196: PPUSH
29197: LD_INT 30
29199: PUSH
29200: LD_INT 3
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PPUSH
29207: CALL_OW 72
29211: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29212: LD_ADDR_VAR 0 6
29216: PUSH
29217: LD_EXP 58
29221: PUSH
29222: LD_VAR 0 2
29226: ARRAY
29227: PPUSH
29228: LD_INT 2
29230: PUSH
29231: LD_INT 30
29233: PUSH
29234: LD_INT 32
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 30
29243: PUSH
29244: LD_INT 33
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: LIST
29255: PPUSH
29256: CALL_OW 72
29260: ST_TO_ADDR
// if not t then
29261: LD_VAR 0 6
29265: NOT
29266: IFFALSE 29270
// continue ;
29268: GO 29127
// for j in tmp do
29270: LD_ADDR_VAR 0 3
29274: PUSH
29275: LD_VAR 0 4
29279: PUSH
29280: FOR_IN
29281: IFFALSE 29311
// if not BuildingStatus ( j ) = bs_idle then
29283: LD_VAR 0 3
29287: PPUSH
29288: CALL_OW 461
29292: PUSH
29293: LD_INT 2
29295: EQUAL
29296: NOT
29297: IFFALSE 29309
// begin busy := true ;
29299: LD_ADDR_VAR 0 8
29303: PUSH
29304: LD_INT 1
29306: ST_TO_ADDR
// break ;
29307: GO 29311
// end ;
29309: GO 29280
29311: POP
29312: POP
// if busy then
29313: LD_VAR 0 8
29317: IFFALSE 29321
// continue ;
29319: GO 29127
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29321: LD_ADDR_VAR 0 7
29325: PUSH
29326: LD_VAR 0 6
29330: PPUSH
29331: LD_INT 35
29333: PUSH
29334: LD_INT 0
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PPUSH
29341: CALL_OW 72
29345: ST_TO_ADDR
// if tw then
29346: LD_VAR 0 7
29350: IFFALSE 29427
// begin tw := tw [ 1 ] ;
29352: LD_ADDR_VAR 0 7
29356: PUSH
29357: LD_VAR 0 7
29361: PUSH
29362: LD_INT 1
29364: ARRAY
29365: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29366: LD_ADDR_VAR 0 9
29370: PUSH
29371: LD_VAR 0 7
29375: PPUSH
29376: LD_EXP 75
29380: PUSH
29381: LD_VAR 0 2
29385: ARRAY
29386: PPUSH
29387: CALL 59473 0 2
29391: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29392: LD_EXP 89
29396: PUSH
29397: LD_VAR 0 2
29401: ARRAY
29402: IFFALSE 29425
// if not weapon in mc_allowed_tower_weapons [ i ] then
29404: LD_VAR 0 9
29408: PUSH
29409: LD_EXP 89
29413: PUSH
29414: LD_VAR 0 2
29418: ARRAY
29419: IN
29420: NOT
29421: IFFALSE 29425
// continue ;
29423: GO 29127
// end else
29425: GO 29490
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29427: LD_ADDR_VAR 0 5
29431: PUSH
29432: LD_EXP 58
29436: PUSH
29437: LD_VAR 0 2
29441: ARRAY
29442: PPUSH
29443: LD_VAR 0 4
29447: PPUSH
29448: CALL 89700 0 2
29452: ST_TO_ADDR
// if not tmp2 then
29453: LD_VAR 0 5
29457: NOT
29458: IFFALSE 29462
// continue ;
29460: GO 29127
// tw := tmp2 [ 1 ] ;
29462: LD_ADDR_VAR 0 7
29466: PUSH
29467: LD_VAR 0 5
29471: PUSH
29472: LD_INT 1
29474: ARRAY
29475: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29476: LD_ADDR_VAR 0 9
29480: PUSH
29481: LD_VAR 0 5
29485: PUSH
29486: LD_INT 2
29488: ARRAY
29489: ST_TO_ADDR
// end ; if not weapon then
29490: LD_VAR 0 9
29494: NOT
29495: IFFALSE 29499
// continue ;
29497: GO 29127
// ComPlaceWeapon ( tw , weapon ) ;
29499: LD_VAR 0 7
29503: PPUSH
29504: LD_VAR 0 9
29508: PPUSH
29509: CALL_OW 148
// end ;
29513: GO 29127
29515: POP
29516: POP
// end ;
29517: LD_VAR 0 1
29521: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29522: LD_INT 0
29524: PPUSH
29525: PPUSH
29526: PPUSH
29527: PPUSH
29528: PPUSH
29529: PPUSH
// if not mc_bases then
29530: LD_EXP 50
29534: NOT
29535: IFFALSE 29539
// exit ;
29537: GO 30315
// for i = 1 to mc_bases do
29539: LD_ADDR_VAR 0 2
29543: PUSH
29544: DOUBLE
29545: LD_INT 1
29547: DEC
29548: ST_TO_ADDR
29549: LD_EXP 50
29553: PUSH
29554: FOR_TO
29555: IFFALSE 30313
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
29557: LD_EXP 63
29561: PUSH
29562: LD_VAR 0 2
29566: ARRAY
29567: NOT
29568: PUSH
29569: LD_EXP 63
29573: PUSH
29574: LD_VAR 0 2
29578: ARRAY
29579: PUSH
29580: LD_EXP 64
29584: PUSH
29585: LD_VAR 0 2
29589: ARRAY
29590: EQUAL
29591: OR
29592: PUSH
29593: LD_EXP 73
29597: PUSH
29598: LD_VAR 0 2
29602: ARRAY
29603: OR
29604: IFFALSE 29608
// continue ;
29606: GO 29554
// if mc_miners [ i ] then
29608: LD_EXP 64
29612: PUSH
29613: LD_VAR 0 2
29617: ARRAY
29618: IFFALSE 30000
// begin for j = mc_miners [ i ] downto 1 do
29620: LD_ADDR_VAR 0 3
29624: PUSH
29625: DOUBLE
29626: LD_EXP 64
29630: PUSH
29631: LD_VAR 0 2
29635: ARRAY
29636: INC
29637: ST_TO_ADDR
29638: LD_INT 1
29640: PUSH
29641: FOR_DOWNTO
29642: IFFALSE 29998
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29644: LD_EXP 64
29648: PUSH
29649: LD_VAR 0 2
29653: ARRAY
29654: PUSH
29655: LD_VAR 0 3
29659: ARRAY
29660: PPUSH
29661: CALL_OW 301
29665: PUSH
29666: LD_EXP 64
29670: PUSH
29671: LD_VAR 0 2
29675: ARRAY
29676: PUSH
29677: LD_VAR 0 3
29681: ARRAY
29682: PPUSH
29683: CALL_OW 257
29687: PUSH
29688: LD_INT 1
29690: NONEQUAL
29691: OR
29692: IFFALSE 29755
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29694: LD_ADDR_VAR 0 5
29698: PUSH
29699: LD_EXP 64
29703: PUSH
29704: LD_VAR 0 2
29708: ARRAY
29709: PUSH
29710: LD_EXP 64
29714: PUSH
29715: LD_VAR 0 2
29719: ARRAY
29720: PUSH
29721: LD_VAR 0 3
29725: ARRAY
29726: DIFF
29727: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29728: LD_ADDR_EXP 64
29732: PUSH
29733: LD_EXP 64
29737: PPUSH
29738: LD_VAR 0 2
29742: PPUSH
29743: LD_VAR 0 5
29747: PPUSH
29748: CALL_OW 1
29752: ST_TO_ADDR
// continue ;
29753: GO 29641
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
29755: LD_EXP 64
29759: PUSH
29760: LD_VAR 0 2
29764: ARRAY
29765: PUSH
29766: LD_VAR 0 3
29770: ARRAY
29771: PPUSH
29772: CALL_OW 257
29776: PUSH
29777: LD_INT 1
29779: EQUAL
29780: PUSH
29781: LD_EXP 64
29785: PUSH
29786: LD_VAR 0 2
29790: ARRAY
29791: PUSH
29792: LD_VAR 0 3
29796: ARRAY
29797: PPUSH
29798: CALL_OW 459
29802: NOT
29803: AND
29804: PUSH
29805: LD_EXP 64
29809: PUSH
29810: LD_VAR 0 2
29814: ARRAY
29815: PUSH
29816: LD_VAR 0 3
29820: ARRAY
29821: PPUSH
29822: CALL_OW 314
29826: NOT
29827: AND
29828: IFFALSE 29996
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29830: LD_EXP 64
29834: PUSH
29835: LD_VAR 0 2
29839: ARRAY
29840: PUSH
29841: LD_VAR 0 3
29845: ARRAY
29846: PPUSH
29847: CALL_OW 310
29851: IFFALSE 29874
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29853: LD_EXP 64
29857: PUSH
29858: LD_VAR 0 2
29862: ARRAY
29863: PUSH
29864: LD_VAR 0 3
29868: ARRAY
29869: PPUSH
29870: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29874: LD_EXP 64
29878: PUSH
29879: LD_VAR 0 2
29883: ARRAY
29884: PUSH
29885: LD_VAR 0 3
29889: ARRAY
29890: PPUSH
29891: CALL_OW 314
29895: NOT
29896: IFFALSE 29996
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
29898: LD_EXP 64
29902: PUSH
29903: LD_VAR 0 2
29907: ARRAY
29908: PUSH
29909: LD_VAR 0 3
29913: ARRAY
29914: PPUSH
29915: LD_EXP 63
29919: PUSH
29920: LD_VAR 0 2
29924: ARRAY
29925: PUSH
29926: LD_VAR 0 3
29930: PUSH
29931: LD_EXP 63
29935: PUSH
29936: LD_VAR 0 2
29940: ARRAY
29941: MOD
29942: PUSH
29943: LD_INT 1
29945: PLUS
29946: ARRAY
29947: PUSH
29948: LD_INT 1
29950: ARRAY
29951: PPUSH
29952: LD_EXP 63
29956: PUSH
29957: LD_VAR 0 2
29961: ARRAY
29962: PUSH
29963: LD_VAR 0 3
29967: PUSH
29968: LD_EXP 63
29972: PUSH
29973: LD_VAR 0 2
29977: ARRAY
29978: MOD
29979: PUSH
29980: LD_INT 1
29982: PLUS
29983: ARRAY
29984: PUSH
29985: LD_INT 2
29987: ARRAY
29988: PPUSH
29989: LD_INT 0
29991: PPUSH
29992: CALL_OW 193
// end ; end ;
29996: GO 29641
29998: POP
29999: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30000: LD_ADDR_VAR 0 5
30004: PUSH
30005: LD_EXP 50
30009: PUSH
30010: LD_VAR 0 2
30014: ARRAY
30015: PPUSH
30016: LD_INT 2
30018: PUSH
30019: LD_INT 30
30021: PUSH
30022: LD_INT 4
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 30
30031: PUSH
30032: LD_INT 5
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 30
30041: PUSH
30042: LD_INT 32
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: PPUSH
30055: CALL_OW 72
30059: ST_TO_ADDR
// if not tmp then
30060: LD_VAR 0 5
30064: NOT
30065: IFFALSE 30069
// continue ;
30067: GO 29554
// list := [ ] ;
30069: LD_ADDR_VAR 0 6
30073: PUSH
30074: EMPTY
30075: ST_TO_ADDR
// for j in tmp do
30076: LD_ADDR_VAR 0 3
30080: PUSH
30081: LD_VAR 0 5
30085: PUSH
30086: FOR_IN
30087: IFFALSE 30156
// begin for k in UnitsInside ( j ) do
30089: LD_ADDR_VAR 0 4
30093: PUSH
30094: LD_VAR 0 3
30098: PPUSH
30099: CALL_OW 313
30103: PUSH
30104: FOR_IN
30105: IFFALSE 30152
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30107: LD_VAR 0 4
30111: PPUSH
30112: CALL_OW 257
30116: PUSH
30117: LD_INT 1
30119: EQUAL
30120: PUSH
30121: LD_VAR 0 4
30125: PPUSH
30126: CALL_OW 459
30130: NOT
30131: AND
30132: IFFALSE 30150
// list := list ^ k ;
30134: LD_ADDR_VAR 0 6
30138: PUSH
30139: LD_VAR 0 6
30143: PUSH
30144: LD_VAR 0 4
30148: ADD
30149: ST_TO_ADDR
30150: GO 30104
30152: POP
30153: POP
// end ;
30154: GO 30086
30156: POP
30157: POP
// list := list diff mc_miners [ i ] ;
30158: LD_ADDR_VAR 0 6
30162: PUSH
30163: LD_VAR 0 6
30167: PUSH
30168: LD_EXP 64
30172: PUSH
30173: LD_VAR 0 2
30177: ARRAY
30178: DIFF
30179: ST_TO_ADDR
// if not list then
30180: LD_VAR 0 6
30184: NOT
30185: IFFALSE 30189
// continue ;
30187: GO 29554
// k := mc_mines [ i ] - mc_miners [ i ] ;
30189: LD_ADDR_VAR 0 4
30193: PUSH
30194: LD_EXP 63
30198: PUSH
30199: LD_VAR 0 2
30203: ARRAY
30204: PUSH
30205: LD_EXP 64
30209: PUSH
30210: LD_VAR 0 2
30214: ARRAY
30215: MINUS
30216: ST_TO_ADDR
// if k > list then
30217: LD_VAR 0 4
30221: PUSH
30222: LD_VAR 0 6
30226: GREATER
30227: IFFALSE 30239
// k := list ;
30229: LD_ADDR_VAR 0 4
30233: PUSH
30234: LD_VAR 0 6
30238: ST_TO_ADDR
// for j = 1 to k do
30239: LD_ADDR_VAR 0 3
30243: PUSH
30244: DOUBLE
30245: LD_INT 1
30247: DEC
30248: ST_TO_ADDR
30249: LD_VAR 0 4
30253: PUSH
30254: FOR_TO
30255: IFFALSE 30309
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30257: LD_ADDR_EXP 64
30261: PUSH
30262: LD_EXP 64
30266: PPUSH
30267: LD_VAR 0 2
30271: PUSH
30272: LD_EXP 64
30276: PUSH
30277: LD_VAR 0 2
30281: ARRAY
30282: PUSH
30283: LD_INT 1
30285: PLUS
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PPUSH
30291: LD_VAR 0 6
30295: PUSH
30296: LD_VAR 0 3
30300: ARRAY
30301: PPUSH
30302: CALL 54503 0 3
30306: ST_TO_ADDR
30307: GO 30254
30309: POP
30310: POP
// end ;
30311: GO 29554
30313: POP
30314: POP
// end ;
30315: LD_VAR 0 1
30319: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30320: LD_INT 0
30322: PPUSH
30323: PPUSH
30324: PPUSH
30325: PPUSH
30326: PPUSH
30327: PPUSH
30328: PPUSH
30329: PPUSH
30330: PPUSH
30331: PPUSH
// if not mc_bases then
30332: LD_EXP 50
30336: NOT
30337: IFFALSE 30341
// exit ;
30339: GO 32091
// for i = 1 to mc_bases do
30341: LD_ADDR_VAR 0 2
30345: PUSH
30346: DOUBLE
30347: LD_INT 1
30349: DEC
30350: ST_TO_ADDR
30351: LD_EXP 50
30355: PUSH
30356: FOR_TO
30357: IFFALSE 32089
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30359: LD_EXP 50
30363: PUSH
30364: LD_VAR 0 2
30368: ARRAY
30369: NOT
30370: PUSH
30371: LD_EXP 57
30375: PUSH
30376: LD_VAR 0 2
30380: ARRAY
30381: OR
30382: IFFALSE 30386
// continue ;
30384: GO 30356
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30386: LD_EXP 66
30390: PUSH
30391: LD_VAR 0 2
30395: ARRAY
30396: NOT
30397: PUSH
30398: LD_EXP 67
30402: PUSH
30403: LD_VAR 0 2
30407: ARRAY
30408: AND
30409: IFFALSE 30447
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30411: LD_ADDR_EXP 67
30415: PUSH
30416: LD_EXP 67
30420: PPUSH
30421: LD_VAR 0 2
30425: PPUSH
30426: EMPTY
30427: PPUSH
30428: CALL_OW 1
30432: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30433: LD_VAR 0 2
30437: PPUSH
30438: LD_INT 107
30440: PPUSH
30441: CALL 21305 0 2
// continue ;
30445: GO 30356
// end ; target := [ ] ;
30447: LD_ADDR_VAR 0 6
30451: PUSH
30452: EMPTY
30453: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30454: LD_ADDR_VAR 0 3
30458: PUSH
30459: DOUBLE
30460: LD_EXP 66
30464: PUSH
30465: LD_VAR 0 2
30469: ARRAY
30470: INC
30471: ST_TO_ADDR
30472: LD_INT 1
30474: PUSH
30475: FOR_DOWNTO
30476: IFFALSE 30736
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30478: LD_EXP 66
30482: PUSH
30483: LD_VAR 0 2
30487: ARRAY
30488: PUSH
30489: LD_VAR 0 3
30493: ARRAY
30494: PUSH
30495: LD_INT 2
30497: ARRAY
30498: PPUSH
30499: LD_EXP 66
30503: PUSH
30504: LD_VAR 0 2
30508: ARRAY
30509: PUSH
30510: LD_VAR 0 3
30514: ARRAY
30515: PUSH
30516: LD_INT 3
30518: ARRAY
30519: PPUSH
30520: CALL_OW 488
30524: PUSH
30525: LD_EXP 66
30529: PUSH
30530: LD_VAR 0 2
30534: ARRAY
30535: PUSH
30536: LD_VAR 0 3
30540: ARRAY
30541: PUSH
30542: LD_INT 2
30544: ARRAY
30545: PPUSH
30546: LD_EXP 66
30550: PUSH
30551: LD_VAR 0 2
30555: ARRAY
30556: PUSH
30557: LD_VAR 0 3
30561: ARRAY
30562: PUSH
30563: LD_INT 3
30565: ARRAY
30566: PPUSH
30567: CALL_OW 284
30571: PUSH
30572: LD_INT 0
30574: EQUAL
30575: AND
30576: IFFALSE 30631
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30578: LD_ADDR_VAR 0 5
30582: PUSH
30583: LD_EXP 66
30587: PUSH
30588: LD_VAR 0 2
30592: ARRAY
30593: PPUSH
30594: LD_VAR 0 3
30598: PPUSH
30599: CALL_OW 3
30603: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30604: LD_ADDR_EXP 66
30608: PUSH
30609: LD_EXP 66
30613: PPUSH
30614: LD_VAR 0 2
30618: PPUSH
30619: LD_VAR 0 5
30623: PPUSH
30624: CALL_OW 1
30628: ST_TO_ADDR
// continue ;
30629: GO 30475
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30631: LD_EXP 50
30635: PUSH
30636: LD_VAR 0 2
30640: ARRAY
30641: PUSH
30642: LD_INT 1
30644: ARRAY
30645: PPUSH
30646: CALL_OW 255
30650: PPUSH
30651: LD_EXP 66
30655: PUSH
30656: LD_VAR 0 2
30660: ARRAY
30661: PUSH
30662: LD_VAR 0 3
30666: ARRAY
30667: PUSH
30668: LD_INT 2
30670: ARRAY
30671: PPUSH
30672: LD_EXP 66
30676: PUSH
30677: LD_VAR 0 2
30681: ARRAY
30682: PUSH
30683: LD_VAR 0 3
30687: ARRAY
30688: PUSH
30689: LD_INT 3
30691: ARRAY
30692: PPUSH
30693: LD_INT 30
30695: PPUSH
30696: CALL 55399 0 4
30700: PUSH
30701: LD_INT 4
30703: ARRAY
30704: PUSH
30705: LD_INT 0
30707: EQUAL
30708: IFFALSE 30734
// begin target := mc_crates [ i ] [ j ] ;
30710: LD_ADDR_VAR 0 6
30714: PUSH
30715: LD_EXP 66
30719: PUSH
30720: LD_VAR 0 2
30724: ARRAY
30725: PUSH
30726: LD_VAR 0 3
30730: ARRAY
30731: ST_TO_ADDR
// break ;
30732: GO 30736
// end ; end ;
30734: GO 30475
30736: POP
30737: POP
// if not target then
30738: LD_VAR 0 6
30742: NOT
30743: IFFALSE 30747
// continue ;
30745: GO 30356
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30747: LD_ADDR_VAR 0 7
30751: PUSH
30752: LD_EXP 69
30756: PUSH
30757: LD_VAR 0 2
30761: ARRAY
30762: PPUSH
30763: LD_INT 2
30765: PUSH
30766: LD_INT 3
30768: PUSH
30769: LD_INT 58
30771: PUSH
30772: EMPTY
30773: LIST
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 61
30781: PUSH
30782: EMPTY
30783: LIST
30784: PUSH
30785: LD_INT 33
30787: PUSH
30788: LD_INT 5
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 33
30797: PUSH
30798: LD_INT 3
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 2
30814: PUSH
30815: LD_INT 34
30817: PUSH
30818: LD_INT 32
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 34
30827: PUSH
30828: LD_INT 51
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 34
30837: PUSH
30838: LD_INT 12
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PPUSH
30855: CALL_OW 72
30859: ST_TO_ADDR
// if not cargo then
30860: LD_VAR 0 7
30864: NOT
30865: IFFALSE 31508
// begin if mc_crates_collector [ i ] < 5 then
30867: LD_EXP 67
30871: PUSH
30872: LD_VAR 0 2
30876: ARRAY
30877: PUSH
30878: LD_INT 5
30880: LESS
30881: IFFALSE 31247
// begin if mc_ape [ i ] then
30883: LD_EXP 79
30887: PUSH
30888: LD_VAR 0 2
30892: ARRAY
30893: IFFALSE 30940
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
30895: LD_ADDR_VAR 0 5
30899: PUSH
30900: LD_EXP 79
30904: PUSH
30905: LD_VAR 0 2
30909: ARRAY
30910: PPUSH
30911: LD_INT 25
30913: PUSH
30914: LD_INT 16
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 24
30923: PUSH
30924: LD_INT 750
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PPUSH
30935: CALL_OW 72
30939: ST_TO_ADDR
// if not tmp then
30940: LD_VAR 0 5
30944: NOT
30945: IFFALSE 30992
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
30947: LD_ADDR_VAR 0 5
30951: PUSH
30952: LD_EXP 50
30956: PUSH
30957: LD_VAR 0 2
30961: ARRAY
30962: PPUSH
30963: LD_INT 25
30965: PUSH
30966: LD_INT 2
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 24
30975: PUSH
30976: LD_INT 750
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PPUSH
30987: CALL_OW 72
30991: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
30992: LD_EXP 79
30996: PUSH
30997: LD_VAR 0 2
31001: ARRAY
31002: PUSH
31003: LD_EXP 50
31007: PUSH
31008: LD_VAR 0 2
31012: ARRAY
31013: PPUSH
31014: LD_INT 25
31016: PUSH
31017: LD_INT 2
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 24
31026: PUSH
31027: LD_INT 750
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PPUSH
31038: CALL_OW 72
31042: AND
31043: PUSH
31044: LD_VAR 0 5
31048: PUSH
31049: LD_INT 5
31051: LESS
31052: AND
31053: IFFALSE 31135
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31055: LD_ADDR_VAR 0 3
31059: PUSH
31060: LD_EXP 50
31064: PUSH
31065: LD_VAR 0 2
31069: ARRAY
31070: PPUSH
31071: LD_INT 25
31073: PUSH
31074: LD_INT 2
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 24
31083: PUSH
31084: LD_INT 750
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PPUSH
31095: CALL_OW 72
31099: PUSH
31100: FOR_IN
31101: IFFALSE 31133
// begin tmp := tmp union j ;
31103: LD_ADDR_VAR 0 5
31107: PUSH
31108: LD_VAR 0 5
31112: PUSH
31113: LD_VAR 0 3
31117: UNION
31118: ST_TO_ADDR
// if tmp >= 5 then
31119: LD_VAR 0 5
31123: PUSH
31124: LD_INT 5
31126: GREATEREQUAL
31127: IFFALSE 31131
// break ;
31129: GO 31133
// end ;
31131: GO 31100
31133: POP
31134: POP
// end ; if not tmp then
31135: LD_VAR 0 5
31139: NOT
31140: IFFALSE 31144
// continue ;
31142: GO 30356
// for j in tmp do
31144: LD_ADDR_VAR 0 3
31148: PUSH
31149: LD_VAR 0 5
31153: PUSH
31154: FOR_IN
31155: IFFALSE 31245
// if not GetTag ( j ) then
31157: LD_VAR 0 3
31161: PPUSH
31162: CALL_OW 110
31166: NOT
31167: IFFALSE 31243
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31169: LD_ADDR_EXP 67
31173: PUSH
31174: LD_EXP 67
31178: PPUSH
31179: LD_VAR 0 2
31183: PUSH
31184: LD_EXP 67
31188: PUSH
31189: LD_VAR 0 2
31193: ARRAY
31194: PUSH
31195: LD_INT 1
31197: PLUS
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PPUSH
31203: LD_VAR 0 3
31207: PPUSH
31208: CALL 54503 0 3
31212: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31213: LD_VAR 0 3
31217: PPUSH
31218: LD_INT 107
31220: PPUSH
31221: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31225: LD_EXP 67
31229: PUSH
31230: LD_VAR 0 2
31234: ARRAY
31235: PUSH
31236: LD_INT 5
31238: GREATEREQUAL
31239: IFFALSE 31243
// break ;
31241: GO 31245
// end ;
31243: GO 31154
31245: POP
31246: POP
// end ; if mc_crates_collector [ i ] and target then
31247: LD_EXP 67
31251: PUSH
31252: LD_VAR 0 2
31256: ARRAY
31257: PUSH
31258: LD_VAR 0 6
31262: AND
31263: IFFALSE 31506
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31265: LD_EXP 67
31269: PUSH
31270: LD_VAR 0 2
31274: ARRAY
31275: PUSH
31276: LD_VAR 0 6
31280: PUSH
31281: LD_INT 1
31283: ARRAY
31284: LESS
31285: IFFALSE 31305
// tmp := mc_crates_collector [ i ] else
31287: LD_ADDR_VAR 0 5
31291: PUSH
31292: LD_EXP 67
31296: PUSH
31297: LD_VAR 0 2
31301: ARRAY
31302: ST_TO_ADDR
31303: GO 31319
// tmp := target [ 1 ] ;
31305: LD_ADDR_VAR 0 5
31309: PUSH
31310: LD_VAR 0 6
31314: PUSH
31315: LD_INT 1
31317: ARRAY
31318: ST_TO_ADDR
// k := 0 ;
31319: LD_ADDR_VAR 0 4
31323: PUSH
31324: LD_INT 0
31326: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31327: LD_ADDR_VAR 0 3
31331: PUSH
31332: LD_EXP 67
31336: PUSH
31337: LD_VAR 0 2
31341: ARRAY
31342: PUSH
31343: FOR_IN
31344: IFFALSE 31504
// begin k := k + 1 ;
31346: LD_ADDR_VAR 0 4
31350: PUSH
31351: LD_VAR 0 4
31355: PUSH
31356: LD_INT 1
31358: PLUS
31359: ST_TO_ADDR
// if k > tmp then
31360: LD_VAR 0 4
31364: PUSH
31365: LD_VAR 0 5
31369: GREATER
31370: IFFALSE 31374
// break ;
31372: GO 31504
// if not GetClass ( j ) in [ 2 , 16 ] then
31374: LD_VAR 0 3
31378: PPUSH
31379: CALL_OW 257
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: LD_INT 16
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: IN
31394: NOT
31395: IFFALSE 31448
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31397: LD_ADDR_EXP 67
31401: PUSH
31402: LD_EXP 67
31406: PPUSH
31407: LD_VAR 0 2
31411: PPUSH
31412: LD_EXP 67
31416: PUSH
31417: LD_VAR 0 2
31421: ARRAY
31422: PUSH
31423: LD_VAR 0 3
31427: DIFF
31428: PPUSH
31429: CALL_OW 1
31433: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31434: LD_VAR 0 3
31438: PPUSH
31439: LD_INT 0
31441: PPUSH
31442: CALL_OW 109
// continue ;
31446: GO 31343
// end ; if IsInUnit ( j ) then
31448: LD_VAR 0 3
31452: PPUSH
31453: CALL_OW 310
31457: IFFALSE 31468
// ComExitBuilding ( j ) ;
31459: LD_VAR 0 3
31463: PPUSH
31464: CALL_OW 122
// wait ( 3 ) ;
31468: LD_INT 3
31470: PPUSH
31471: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31475: LD_VAR 0 3
31479: PPUSH
31480: LD_VAR 0 6
31484: PUSH
31485: LD_INT 2
31487: ARRAY
31488: PPUSH
31489: LD_VAR 0 6
31493: PUSH
31494: LD_INT 3
31496: ARRAY
31497: PPUSH
31498: CALL_OW 117
// end ;
31502: GO 31343
31504: POP
31505: POP
// end ; end else
31506: GO 32087
// begin for j in cargo do
31508: LD_ADDR_VAR 0 3
31512: PUSH
31513: LD_VAR 0 7
31517: PUSH
31518: FOR_IN
31519: IFFALSE 32085
// begin if GetTag ( j ) <> 0 then
31521: LD_VAR 0 3
31525: PPUSH
31526: CALL_OW 110
31530: PUSH
31531: LD_INT 0
31533: NONEQUAL
31534: IFFALSE 31538
// continue ;
31536: GO 31518
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31538: LD_VAR 0 3
31542: PPUSH
31543: CALL_OW 256
31547: PUSH
31548: LD_INT 1000
31550: LESS
31551: PUSH
31552: LD_VAR 0 3
31556: PPUSH
31557: LD_EXP 74
31561: PUSH
31562: LD_VAR 0 2
31566: ARRAY
31567: PPUSH
31568: CALL_OW 308
31572: NOT
31573: AND
31574: IFFALSE 31596
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31576: LD_VAR 0 3
31580: PPUSH
31581: LD_EXP 74
31585: PUSH
31586: LD_VAR 0 2
31590: ARRAY
31591: PPUSH
31592: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31596: LD_VAR 0 3
31600: PPUSH
31601: CALL_OW 256
31605: PUSH
31606: LD_INT 1000
31608: LESS
31609: PUSH
31610: LD_VAR 0 3
31614: PPUSH
31615: LD_EXP 74
31619: PUSH
31620: LD_VAR 0 2
31624: ARRAY
31625: PPUSH
31626: CALL_OW 308
31630: AND
31631: IFFALSE 31635
// continue ;
31633: GO 31518
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31635: LD_VAR 0 3
31639: PPUSH
31640: CALL_OW 262
31644: PUSH
31645: LD_INT 2
31647: EQUAL
31648: PUSH
31649: LD_VAR 0 3
31653: PPUSH
31654: CALL_OW 261
31658: PUSH
31659: LD_INT 15
31661: LESS
31662: AND
31663: IFFALSE 31667
// continue ;
31665: GO 31518
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31667: LD_VAR 0 3
31671: PPUSH
31672: CALL_OW 262
31676: PUSH
31677: LD_INT 1
31679: EQUAL
31680: PUSH
31681: LD_VAR 0 3
31685: PPUSH
31686: CALL_OW 261
31690: PUSH
31691: LD_INT 10
31693: LESS
31694: AND
31695: IFFALSE 32024
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31697: LD_ADDR_VAR 0 8
31701: PUSH
31702: LD_EXP 50
31706: PUSH
31707: LD_VAR 0 2
31711: ARRAY
31712: PPUSH
31713: LD_INT 2
31715: PUSH
31716: LD_INT 30
31718: PUSH
31719: LD_INT 0
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 30
31728: PUSH
31729: LD_INT 1
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: LIST
31740: PPUSH
31741: CALL_OW 72
31745: ST_TO_ADDR
// if not depot then
31746: LD_VAR 0 8
31750: NOT
31751: IFFALSE 31755
// continue ;
31753: GO 31518
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31755: LD_VAR 0 3
31759: PPUSH
31760: LD_VAR 0 8
31764: PPUSH
31765: LD_VAR 0 3
31769: PPUSH
31770: CALL_OW 74
31774: PPUSH
31775: CALL_OW 296
31779: PUSH
31780: LD_INT 6
31782: LESS
31783: IFFALSE 31799
// SetFuel ( j , 100 ) else
31785: LD_VAR 0 3
31789: PPUSH
31790: LD_INT 100
31792: PPUSH
31793: CALL_OW 240
31797: GO 32024
// if GetFuel ( j ) = 0 then
31799: LD_VAR 0 3
31803: PPUSH
31804: CALL_OW 261
31808: PUSH
31809: LD_INT 0
31811: EQUAL
31812: IFFALSE 32024
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31814: LD_ADDR_EXP 69
31818: PUSH
31819: LD_EXP 69
31823: PPUSH
31824: LD_VAR 0 2
31828: PPUSH
31829: LD_EXP 69
31833: PUSH
31834: LD_VAR 0 2
31838: ARRAY
31839: PUSH
31840: LD_VAR 0 3
31844: DIFF
31845: PPUSH
31846: CALL_OW 1
31850: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31851: LD_VAR 0 3
31855: PPUSH
31856: CALL_OW 263
31860: PUSH
31861: LD_INT 1
31863: EQUAL
31864: IFFALSE 31880
// ComExitVehicle ( IsInUnit ( j ) ) ;
31866: LD_VAR 0 3
31870: PPUSH
31871: CALL_OW 310
31875: PPUSH
31876: CALL_OW 121
// if GetControl ( j ) = control_remote then
31880: LD_VAR 0 3
31884: PPUSH
31885: CALL_OW 263
31889: PUSH
31890: LD_INT 2
31892: EQUAL
31893: IFFALSE 31904
// ComUnlink ( j ) ;
31895: LD_VAR 0 3
31899: PPUSH
31900: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
31904: LD_ADDR_VAR 0 9
31908: PUSH
31909: LD_VAR 0 2
31913: PPUSH
31914: LD_INT 3
31916: PPUSH
31917: CALL 41377 0 2
31921: ST_TO_ADDR
// if fac then
31922: LD_VAR 0 9
31926: IFFALSE 32022
// begin for k in fac do
31928: LD_ADDR_VAR 0 4
31932: PUSH
31933: LD_VAR 0 9
31937: PUSH
31938: FOR_IN
31939: IFFALSE 32020
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
31941: LD_ADDR_VAR 0 10
31945: PUSH
31946: LD_VAR 0 9
31950: PPUSH
31951: LD_VAR 0 3
31955: PPUSH
31956: CALL_OW 265
31960: PPUSH
31961: LD_VAR 0 3
31965: PPUSH
31966: CALL_OW 262
31970: PPUSH
31971: LD_VAR 0 3
31975: PPUSH
31976: CALL_OW 263
31980: PPUSH
31981: LD_VAR 0 3
31985: PPUSH
31986: CALL_OW 264
31990: PPUSH
31991: CALL 52035 0 5
31995: ST_TO_ADDR
// if components then
31996: LD_VAR 0 10
32000: IFFALSE 32018
// begin MC_InsertProduceList ( i , components ) ;
32002: LD_VAR 0 2
32006: PPUSH
32007: LD_VAR 0 10
32011: PPUSH
32012: CALL 40922 0 2
// break ;
32016: GO 32020
// end ; end ;
32018: GO 31938
32020: POP
32021: POP
// end ; continue ;
32022: GO 31518
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32024: LD_VAR 0 3
32028: PPUSH
32029: LD_INT 1
32031: PPUSH
32032: CALL_OW 289
32036: PUSH
32037: LD_INT 100
32039: LESS
32040: PUSH
32041: LD_VAR 0 3
32045: PPUSH
32046: CALL_OW 314
32050: NOT
32051: AND
32052: IFFALSE 32081
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32054: LD_VAR 0 3
32058: PPUSH
32059: LD_VAR 0 6
32063: PUSH
32064: LD_INT 2
32066: ARRAY
32067: PPUSH
32068: LD_VAR 0 6
32072: PUSH
32073: LD_INT 3
32075: ARRAY
32076: PPUSH
32077: CALL_OW 117
// break ;
32081: GO 32085
// end ;
32083: GO 31518
32085: POP
32086: POP
// end ; end ;
32087: GO 30356
32089: POP
32090: POP
// end ;
32091: LD_VAR 0 1
32095: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32096: LD_INT 0
32098: PPUSH
32099: PPUSH
32100: PPUSH
32101: PPUSH
// if not mc_bases then
32102: LD_EXP 50
32106: NOT
32107: IFFALSE 32111
// exit ;
32109: GO 32272
// for i = 1 to mc_bases do
32111: LD_ADDR_VAR 0 2
32115: PUSH
32116: DOUBLE
32117: LD_INT 1
32119: DEC
32120: ST_TO_ADDR
32121: LD_EXP 50
32125: PUSH
32126: FOR_TO
32127: IFFALSE 32270
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32129: LD_ADDR_VAR 0 4
32133: PUSH
32134: LD_EXP 69
32138: PUSH
32139: LD_VAR 0 2
32143: ARRAY
32144: PUSH
32145: LD_EXP 72
32149: PUSH
32150: LD_VAR 0 2
32154: ARRAY
32155: UNION
32156: PPUSH
32157: LD_INT 33
32159: PUSH
32160: LD_INT 2
32162: PUSH
32163: EMPTY
32164: LIST
32165: LIST
32166: PPUSH
32167: CALL_OW 72
32171: ST_TO_ADDR
// if tmp then
32172: LD_VAR 0 4
32176: IFFALSE 32268
// for j in tmp do
32178: LD_ADDR_VAR 0 3
32182: PUSH
32183: LD_VAR 0 4
32187: PUSH
32188: FOR_IN
32189: IFFALSE 32266
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32191: LD_VAR 0 3
32195: PPUSH
32196: CALL_OW 312
32200: NOT
32201: PUSH
32202: LD_VAR 0 3
32206: PPUSH
32207: CALL_OW 256
32211: PUSH
32212: LD_INT 250
32214: GREATEREQUAL
32215: AND
32216: IFFALSE 32229
// Connect ( j ) else
32218: LD_VAR 0 3
32222: PPUSH
32223: CALL 57436 0 1
32227: GO 32264
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32229: LD_VAR 0 3
32233: PPUSH
32234: CALL_OW 256
32238: PUSH
32239: LD_INT 250
32241: LESS
32242: PUSH
32243: LD_VAR 0 3
32247: PPUSH
32248: CALL_OW 312
32252: AND
32253: IFFALSE 32264
// ComUnlink ( j ) ;
32255: LD_VAR 0 3
32259: PPUSH
32260: CALL_OW 136
32264: GO 32188
32266: POP
32267: POP
// end ;
32268: GO 32126
32270: POP
32271: POP
// end ;
32272: LD_VAR 0 1
32276: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32277: LD_INT 0
32279: PPUSH
32280: PPUSH
32281: PPUSH
32282: PPUSH
32283: PPUSH
// if not mc_bases then
32284: LD_EXP 50
32288: NOT
32289: IFFALSE 32293
// exit ;
32291: GO 32738
// for i = 1 to mc_bases do
32293: LD_ADDR_VAR 0 2
32297: PUSH
32298: DOUBLE
32299: LD_INT 1
32301: DEC
32302: ST_TO_ADDR
32303: LD_EXP 50
32307: PUSH
32308: FOR_TO
32309: IFFALSE 32736
// begin if not mc_produce [ i ] then
32311: LD_EXP 71
32315: PUSH
32316: LD_VAR 0 2
32320: ARRAY
32321: NOT
32322: IFFALSE 32326
// continue ;
32324: GO 32308
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32326: LD_ADDR_VAR 0 5
32330: PUSH
32331: LD_EXP 50
32335: PUSH
32336: LD_VAR 0 2
32340: ARRAY
32341: PPUSH
32342: LD_INT 30
32344: PUSH
32345: LD_INT 3
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PPUSH
32352: CALL_OW 72
32356: ST_TO_ADDR
// if not fac then
32357: LD_VAR 0 5
32361: NOT
32362: IFFALSE 32366
// continue ;
32364: GO 32308
// for j in fac do
32366: LD_ADDR_VAR 0 3
32370: PUSH
32371: LD_VAR 0 5
32375: PUSH
32376: FOR_IN
32377: IFFALSE 32732
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32379: LD_VAR 0 3
32383: PPUSH
32384: CALL_OW 461
32388: PUSH
32389: LD_INT 2
32391: NONEQUAL
32392: PUSH
32393: LD_VAR 0 3
32397: PPUSH
32398: LD_INT 15
32400: PPUSH
32401: CALL 57096 0 2
32405: PUSH
32406: LD_INT 4
32408: ARRAY
32409: OR
32410: IFFALSE 32414
// continue ;
32412: GO 32376
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32414: LD_VAR 0 3
32418: PPUSH
32419: LD_EXP 71
32423: PUSH
32424: LD_VAR 0 2
32428: ARRAY
32429: PUSH
32430: LD_INT 1
32432: ARRAY
32433: PUSH
32434: LD_INT 1
32436: ARRAY
32437: PPUSH
32438: LD_EXP 71
32442: PUSH
32443: LD_VAR 0 2
32447: ARRAY
32448: PUSH
32449: LD_INT 1
32451: ARRAY
32452: PUSH
32453: LD_INT 2
32455: ARRAY
32456: PPUSH
32457: LD_EXP 71
32461: PUSH
32462: LD_VAR 0 2
32466: ARRAY
32467: PUSH
32468: LD_INT 1
32470: ARRAY
32471: PUSH
32472: LD_INT 3
32474: ARRAY
32475: PPUSH
32476: LD_EXP 71
32480: PUSH
32481: LD_VAR 0 2
32485: ARRAY
32486: PUSH
32487: LD_INT 1
32489: ARRAY
32490: PUSH
32491: LD_INT 4
32493: ARRAY
32494: PPUSH
32495: CALL_OW 448
32499: PUSH
32500: LD_VAR 0 3
32504: PPUSH
32505: LD_EXP 71
32509: PUSH
32510: LD_VAR 0 2
32514: ARRAY
32515: PUSH
32516: LD_INT 1
32518: ARRAY
32519: PUSH
32520: LD_INT 1
32522: ARRAY
32523: PUSH
32524: LD_EXP 71
32528: PUSH
32529: LD_VAR 0 2
32533: ARRAY
32534: PUSH
32535: LD_INT 1
32537: ARRAY
32538: PUSH
32539: LD_INT 2
32541: ARRAY
32542: PUSH
32543: LD_EXP 71
32547: PUSH
32548: LD_VAR 0 2
32552: ARRAY
32553: PUSH
32554: LD_INT 1
32556: ARRAY
32557: PUSH
32558: LD_INT 3
32560: ARRAY
32561: PUSH
32562: LD_EXP 71
32566: PUSH
32567: LD_VAR 0 2
32571: ARRAY
32572: PUSH
32573: LD_INT 1
32575: ARRAY
32576: PUSH
32577: LD_INT 4
32579: ARRAY
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: PPUSH
32587: CALL 60767 0 2
32591: AND
32592: IFFALSE 32730
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32594: LD_VAR 0 3
32598: PPUSH
32599: LD_EXP 71
32603: PUSH
32604: LD_VAR 0 2
32608: ARRAY
32609: PUSH
32610: LD_INT 1
32612: ARRAY
32613: PUSH
32614: LD_INT 1
32616: ARRAY
32617: PPUSH
32618: LD_EXP 71
32622: PUSH
32623: LD_VAR 0 2
32627: ARRAY
32628: PUSH
32629: LD_INT 1
32631: ARRAY
32632: PUSH
32633: LD_INT 2
32635: ARRAY
32636: PPUSH
32637: LD_EXP 71
32641: PUSH
32642: LD_VAR 0 2
32646: ARRAY
32647: PUSH
32648: LD_INT 1
32650: ARRAY
32651: PUSH
32652: LD_INT 3
32654: ARRAY
32655: PPUSH
32656: LD_EXP 71
32660: PUSH
32661: LD_VAR 0 2
32665: ARRAY
32666: PUSH
32667: LD_INT 1
32669: ARRAY
32670: PUSH
32671: LD_INT 4
32673: ARRAY
32674: PPUSH
32675: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32679: LD_ADDR_VAR 0 4
32683: PUSH
32684: LD_EXP 71
32688: PUSH
32689: LD_VAR 0 2
32693: ARRAY
32694: PPUSH
32695: LD_INT 1
32697: PPUSH
32698: CALL_OW 3
32702: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32703: LD_ADDR_EXP 71
32707: PUSH
32708: LD_EXP 71
32712: PPUSH
32713: LD_VAR 0 2
32717: PPUSH
32718: LD_VAR 0 4
32722: PPUSH
32723: CALL_OW 1
32727: ST_TO_ADDR
// break ;
32728: GO 32732
// end ; end ;
32730: GO 32376
32732: POP
32733: POP
// end ;
32734: GO 32308
32736: POP
32737: POP
// end ;
32738: LD_VAR 0 1
32742: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32743: LD_INT 0
32745: PPUSH
32746: PPUSH
32747: PPUSH
// if not mc_bases then
32748: LD_EXP 50
32752: NOT
32753: IFFALSE 32757
// exit ;
32755: GO 32846
// for i = 1 to mc_bases do
32757: LD_ADDR_VAR 0 2
32761: PUSH
32762: DOUBLE
32763: LD_INT 1
32765: DEC
32766: ST_TO_ADDR
32767: LD_EXP 50
32771: PUSH
32772: FOR_TO
32773: IFFALSE 32844
// begin if mc_attack [ i ] then
32775: LD_EXP 70
32779: PUSH
32780: LD_VAR 0 2
32784: ARRAY
32785: IFFALSE 32842
// begin tmp := mc_attack [ i ] [ 1 ] ;
32787: LD_ADDR_VAR 0 3
32791: PUSH
32792: LD_EXP 70
32796: PUSH
32797: LD_VAR 0 2
32801: ARRAY
32802: PUSH
32803: LD_INT 1
32805: ARRAY
32806: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32807: LD_ADDR_EXP 70
32811: PUSH
32812: LD_EXP 70
32816: PPUSH
32817: LD_VAR 0 2
32821: PPUSH
32822: EMPTY
32823: PPUSH
32824: CALL_OW 1
32828: ST_TO_ADDR
// Attack ( tmp ) ;
32829: LD_VAR 0 3
32833: PPUSH
32834: CALL 82980 0 1
// exit ;
32838: POP
32839: POP
32840: GO 32846
// end ; end ;
32842: GO 32772
32844: POP
32845: POP
// end ;
32846: LD_VAR 0 1
32850: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32851: LD_INT 0
32853: PPUSH
32854: PPUSH
32855: PPUSH
32856: PPUSH
32857: PPUSH
32858: PPUSH
32859: PPUSH
// if not mc_bases then
32860: LD_EXP 50
32864: NOT
32865: IFFALSE 32869
// exit ;
32867: GO 33451
// for i = 1 to mc_bases do
32869: LD_ADDR_VAR 0 2
32873: PUSH
32874: DOUBLE
32875: LD_INT 1
32877: DEC
32878: ST_TO_ADDR
32879: LD_EXP 50
32883: PUSH
32884: FOR_TO
32885: IFFALSE 33449
// begin if not mc_bases [ i ] then
32887: LD_EXP 50
32891: PUSH
32892: LD_VAR 0 2
32896: ARRAY
32897: NOT
32898: IFFALSE 32902
// continue ;
32900: GO 32884
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
32902: LD_ADDR_VAR 0 7
32906: PUSH
32907: LD_EXP 50
32911: PUSH
32912: LD_VAR 0 2
32916: ARRAY
32917: PUSH
32918: LD_INT 1
32920: ARRAY
32921: PPUSH
32922: CALL 51339 0 1
32926: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
32927: LD_ADDR_EXP 73
32931: PUSH
32932: LD_EXP 73
32936: PPUSH
32937: LD_VAR 0 2
32941: PPUSH
32942: LD_EXP 50
32946: PUSH
32947: LD_VAR 0 2
32951: ARRAY
32952: PUSH
32953: LD_INT 1
32955: ARRAY
32956: PPUSH
32957: CALL_OW 255
32961: PPUSH
32962: LD_EXP 75
32966: PUSH
32967: LD_VAR 0 2
32971: ARRAY
32972: PPUSH
32973: CALL 48893 0 2
32977: PPUSH
32978: CALL_OW 1
32982: ST_TO_ADDR
// if not mc_scan [ i ] then
32983: LD_EXP 73
32987: PUSH
32988: LD_VAR 0 2
32992: ARRAY
32993: NOT
32994: IFFALSE 33149
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32996: LD_ADDR_VAR 0 4
33000: PUSH
33001: LD_EXP 50
33005: PUSH
33006: LD_VAR 0 2
33010: ARRAY
33011: PPUSH
33012: LD_INT 2
33014: PUSH
33015: LD_INT 25
33017: PUSH
33018: LD_INT 5
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 25
33027: PUSH
33028: LD_INT 8
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 25
33037: PUSH
33038: LD_INT 9
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: PPUSH
33051: CALL_OW 72
33055: ST_TO_ADDR
// if not tmp then
33056: LD_VAR 0 4
33060: NOT
33061: IFFALSE 33065
// continue ;
33063: GO 32884
// for j in tmp do
33065: LD_ADDR_VAR 0 3
33069: PUSH
33070: LD_VAR 0 4
33074: PUSH
33075: FOR_IN
33076: IFFALSE 33147
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33078: LD_VAR 0 3
33082: PPUSH
33083: CALL_OW 310
33087: PPUSH
33088: CALL_OW 266
33092: PUSH
33093: LD_INT 5
33095: EQUAL
33096: PUSH
33097: LD_VAR 0 3
33101: PPUSH
33102: CALL_OW 257
33106: PUSH
33107: LD_INT 1
33109: EQUAL
33110: AND
33111: PUSH
33112: LD_VAR 0 3
33116: PPUSH
33117: CALL_OW 459
33121: NOT
33122: AND
33123: PUSH
33124: LD_VAR 0 7
33128: AND
33129: IFFALSE 33145
// ComChangeProfession ( j , class ) ;
33131: LD_VAR 0 3
33135: PPUSH
33136: LD_VAR 0 7
33140: PPUSH
33141: CALL_OW 123
33145: GO 33075
33147: POP
33148: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33149: LD_EXP 73
33153: PUSH
33154: LD_VAR 0 2
33158: ARRAY
33159: PUSH
33160: LD_EXP 72
33164: PUSH
33165: LD_VAR 0 2
33169: ARRAY
33170: NOT
33171: AND
33172: PUSH
33173: LD_EXP 50
33177: PUSH
33178: LD_VAR 0 2
33182: ARRAY
33183: PPUSH
33184: LD_INT 30
33186: PUSH
33187: LD_INT 32
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PPUSH
33194: CALL_OW 72
33198: NOT
33199: AND
33200: PUSH
33201: LD_EXP 50
33205: PUSH
33206: LD_VAR 0 2
33210: ARRAY
33211: PPUSH
33212: LD_INT 2
33214: PUSH
33215: LD_INT 30
33217: PUSH
33218: LD_INT 4
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: LD_INT 30
33227: PUSH
33228: LD_INT 5
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: LIST
33239: PPUSH
33240: CALL_OW 72
33244: NOT
33245: AND
33246: IFFALSE 33378
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33248: LD_ADDR_VAR 0 4
33252: PUSH
33253: LD_EXP 50
33257: PUSH
33258: LD_VAR 0 2
33262: ARRAY
33263: PPUSH
33264: LD_INT 2
33266: PUSH
33267: LD_INT 25
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 25
33279: PUSH
33280: LD_INT 5
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 25
33289: PUSH
33290: LD_INT 8
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 25
33299: PUSH
33300: LD_INT 9
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: LIST
33311: LIST
33312: LIST
33313: PPUSH
33314: CALL_OW 72
33318: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33319: LD_ADDR_VAR 0 4
33323: PUSH
33324: LD_VAR 0 4
33328: PUSH
33329: LD_VAR 0 4
33333: PPUSH
33334: LD_INT 18
33336: PPUSH
33337: CALL 87789 0 2
33341: DIFF
33342: ST_TO_ADDR
// if tmp then
33343: LD_VAR 0 4
33347: IFFALSE 33378
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33349: LD_VAR 0 2
33353: PPUSH
33354: LD_VAR 0 4
33358: PPUSH
33359: LD_EXP 75
33363: PUSH
33364: LD_VAR 0 2
33368: ARRAY
33369: PPUSH
33370: CALL 48928 0 3
// exit ;
33374: POP
33375: POP
33376: GO 33451
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33378: LD_EXP 73
33382: PUSH
33383: LD_VAR 0 2
33387: ARRAY
33388: PUSH
33389: LD_EXP 72
33393: PUSH
33394: LD_VAR 0 2
33398: ARRAY
33399: AND
33400: IFFALSE 33447
// begin tmp := mc_defender [ i ] ;
33402: LD_ADDR_VAR 0 4
33406: PUSH
33407: LD_EXP 72
33411: PUSH
33412: LD_VAR 0 2
33416: ARRAY
33417: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33418: LD_VAR 0 2
33422: PPUSH
33423: LD_VAR 0 4
33427: PPUSH
33428: LD_EXP 73
33432: PUSH
33433: LD_VAR 0 2
33437: ARRAY
33438: PPUSH
33439: CALL 49489 0 3
// exit ;
33443: POP
33444: POP
33445: GO 33451
// end ; end ;
33447: GO 32884
33449: POP
33450: POP
// end ;
33451: LD_VAR 0 1
33455: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33456: LD_INT 0
33458: PPUSH
33459: PPUSH
33460: PPUSH
33461: PPUSH
33462: PPUSH
33463: PPUSH
33464: PPUSH
33465: PPUSH
33466: PPUSH
33467: PPUSH
33468: PPUSH
// if not mc_bases then
33469: LD_EXP 50
33473: NOT
33474: IFFALSE 33478
// exit ;
33476: GO 34565
// for i = 1 to mc_bases do
33478: LD_ADDR_VAR 0 2
33482: PUSH
33483: DOUBLE
33484: LD_INT 1
33486: DEC
33487: ST_TO_ADDR
33488: LD_EXP 50
33492: PUSH
33493: FOR_TO
33494: IFFALSE 34563
// begin tmp := mc_lab [ i ] ;
33496: LD_ADDR_VAR 0 6
33500: PUSH
33501: LD_EXP 83
33505: PUSH
33506: LD_VAR 0 2
33510: ARRAY
33511: ST_TO_ADDR
// if not tmp then
33512: LD_VAR 0 6
33516: NOT
33517: IFFALSE 33521
// continue ;
33519: GO 33493
// idle_lab := 0 ;
33521: LD_ADDR_VAR 0 11
33525: PUSH
33526: LD_INT 0
33528: ST_TO_ADDR
// for j in tmp do
33529: LD_ADDR_VAR 0 3
33533: PUSH
33534: LD_VAR 0 6
33538: PUSH
33539: FOR_IN
33540: IFFALSE 34559
// begin researching := false ;
33542: LD_ADDR_VAR 0 10
33546: PUSH
33547: LD_INT 0
33549: ST_TO_ADDR
// side := GetSide ( j ) ;
33550: LD_ADDR_VAR 0 4
33554: PUSH
33555: LD_VAR 0 3
33559: PPUSH
33560: CALL_OW 255
33564: ST_TO_ADDR
// if not mc_tech [ side ] then
33565: LD_EXP 77
33569: PUSH
33570: LD_VAR 0 4
33574: ARRAY
33575: NOT
33576: IFFALSE 33580
// continue ;
33578: GO 33539
// if BuildingStatus ( j ) = bs_idle then
33580: LD_VAR 0 3
33584: PPUSH
33585: CALL_OW 461
33589: PUSH
33590: LD_INT 2
33592: EQUAL
33593: IFFALSE 33781
// begin if idle_lab and UnitsInside ( j ) < 6 then
33595: LD_VAR 0 11
33599: PUSH
33600: LD_VAR 0 3
33604: PPUSH
33605: CALL_OW 313
33609: PUSH
33610: LD_INT 6
33612: LESS
33613: AND
33614: IFFALSE 33685
// begin tmp2 := UnitsInside ( idle_lab ) ;
33616: LD_ADDR_VAR 0 9
33620: PUSH
33621: LD_VAR 0 11
33625: PPUSH
33626: CALL_OW 313
33630: ST_TO_ADDR
// if tmp2 then
33631: LD_VAR 0 9
33635: IFFALSE 33677
// for x in tmp2 do
33637: LD_ADDR_VAR 0 7
33641: PUSH
33642: LD_VAR 0 9
33646: PUSH
33647: FOR_IN
33648: IFFALSE 33675
// begin ComExitBuilding ( x ) ;
33650: LD_VAR 0 7
33654: PPUSH
33655: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33659: LD_VAR 0 7
33663: PPUSH
33664: LD_VAR 0 3
33668: PPUSH
33669: CALL_OW 180
// end ;
33673: GO 33647
33675: POP
33676: POP
// idle_lab := 0 ;
33677: LD_ADDR_VAR 0 11
33681: PUSH
33682: LD_INT 0
33684: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33685: LD_ADDR_VAR 0 5
33689: PUSH
33690: LD_EXP 77
33694: PUSH
33695: LD_VAR 0 4
33699: ARRAY
33700: PUSH
33701: FOR_IN
33702: IFFALSE 33762
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33704: LD_VAR 0 3
33708: PPUSH
33709: LD_VAR 0 5
33713: PPUSH
33714: CALL_OW 430
33718: PUSH
33719: LD_VAR 0 4
33723: PPUSH
33724: LD_VAR 0 5
33728: PPUSH
33729: CALL 47998 0 2
33733: AND
33734: IFFALSE 33760
// begin researching := true ;
33736: LD_ADDR_VAR 0 10
33740: PUSH
33741: LD_INT 1
33743: ST_TO_ADDR
// ComResearch ( j , t ) ;
33744: LD_VAR 0 3
33748: PPUSH
33749: LD_VAR 0 5
33753: PPUSH
33754: CALL_OW 124
// break ;
33758: GO 33762
// end ;
33760: GO 33701
33762: POP
33763: POP
// if not researching then
33764: LD_VAR 0 10
33768: NOT
33769: IFFALSE 33781
// idle_lab := j ;
33771: LD_ADDR_VAR 0 11
33775: PUSH
33776: LD_VAR 0 3
33780: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33781: LD_VAR 0 3
33785: PPUSH
33786: CALL_OW 461
33790: PUSH
33791: LD_INT 10
33793: EQUAL
33794: IFFALSE 34382
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33796: LD_EXP 79
33800: PUSH
33801: LD_VAR 0 2
33805: ARRAY
33806: NOT
33807: PUSH
33808: LD_EXP 80
33812: PUSH
33813: LD_VAR 0 2
33817: ARRAY
33818: NOT
33819: AND
33820: PUSH
33821: LD_EXP 77
33825: PUSH
33826: LD_VAR 0 4
33830: ARRAY
33831: PUSH
33832: LD_INT 1
33834: GREATER
33835: AND
33836: IFFALSE 33967
// begin ComCancel ( j ) ;
33838: LD_VAR 0 3
33842: PPUSH
33843: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33847: LD_ADDR_EXP 77
33851: PUSH
33852: LD_EXP 77
33856: PPUSH
33857: LD_VAR 0 4
33861: PPUSH
33862: LD_EXP 77
33866: PUSH
33867: LD_VAR 0 4
33871: ARRAY
33872: PPUSH
33873: LD_EXP 77
33877: PUSH
33878: LD_VAR 0 4
33882: ARRAY
33883: PUSH
33884: LD_INT 1
33886: MINUS
33887: PPUSH
33888: LD_EXP 77
33892: PUSH
33893: LD_VAR 0 4
33897: ARRAY
33898: PPUSH
33899: LD_INT 0
33901: PPUSH
33902: CALL 53921 0 4
33906: PPUSH
33907: CALL_OW 1
33911: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
33912: LD_ADDR_EXP 77
33916: PUSH
33917: LD_EXP 77
33921: PPUSH
33922: LD_VAR 0 4
33926: PPUSH
33927: LD_EXP 77
33931: PUSH
33932: LD_VAR 0 4
33936: ARRAY
33937: PPUSH
33938: LD_EXP 77
33942: PUSH
33943: LD_VAR 0 4
33947: ARRAY
33948: PPUSH
33949: LD_INT 1
33951: PPUSH
33952: LD_INT 0
33954: PPUSH
33955: CALL 53921 0 4
33959: PPUSH
33960: CALL_OW 1
33964: ST_TO_ADDR
// continue ;
33965: GO 33539
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
33967: LD_EXP 79
33971: PUSH
33972: LD_VAR 0 2
33976: ARRAY
33977: PUSH
33978: LD_EXP 80
33982: PUSH
33983: LD_VAR 0 2
33987: ARRAY
33988: NOT
33989: AND
33990: IFFALSE 34117
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
33992: LD_ADDR_EXP 80
33996: PUSH
33997: LD_EXP 80
34001: PPUSH
34002: LD_VAR 0 2
34006: PUSH
34007: LD_EXP 80
34011: PUSH
34012: LD_VAR 0 2
34016: ARRAY
34017: PUSH
34018: LD_INT 1
34020: PLUS
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PPUSH
34026: LD_EXP 79
34030: PUSH
34031: LD_VAR 0 2
34035: ARRAY
34036: PUSH
34037: LD_INT 1
34039: ARRAY
34040: PPUSH
34041: CALL 54503 0 3
34045: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34046: LD_EXP 79
34050: PUSH
34051: LD_VAR 0 2
34055: ARRAY
34056: PUSH
34057: LD_INT 1
34059: ARRAY
34060: PPUSH
34061: LD_INT 112
34063: PPUSH
34064: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34068: LD_ADDR_VAR 0 9
34072: PUSH
34073: LD_EXP 79
34077: PUSH
34078: LD_VAR 0 2
34082: ARRAY
34083: PPUSH
34084: LD_INT 1
34086: PPUSH
34087: CALL_OW 3
34091: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34092: LD_ADDR_EXP 79
34096: PUSH
34097: LD_EXP 79
34101: PPUSH
34102: LD_VAR 0 2
34106: PPUSH
34107: LD_VAR 0 9
34111: PPUSH
34112: CALL_OW 1
34116: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34117: LD_EXP 79
34121: PUSH
34122: LD_VAR 0 2
34126: ARRAY
34127: PUSH
34128: LD_EXP 80
34132: PUSH
34133: LD_VAR 0 2
34137: ARRAY
34138: AND
34139: PUSH
34140: LD_EXP 80
34144: PUSH
34145: LD_VAR 0 2
34149: ARRAY
34150: PUSH
34151: LD_INT 1
34153: ARRAY
34154: PPUSH
34155: CALL_OW 310
34159: NOT
34160: AND
34161: PUSH
34162: LD_VAR 0 3
34166: PPUSH
34167: CALL_OW 313
34171: PUSH
34172: LD_INT 6
34174: EQUAL
34175: AND
34176: IFFALSE 34232
// begin tmp2 := UnitsInside ( j ) ;
34178: LD_ADDR_VAR 0 9
34182: PUSH
34183: LD_VAR 0 3
34187: PPUSH
34188: CALL_OW 313
34192: ST_TO_ADDR
// if tmp2 = 6 then
34193: LD_VAR 0 9
34197: PUSH
34198: LD_INT 6
34200: EQUAL
34201: IFFALSE 34232
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34203: LD_VAR 0 9
34207: PUSH
34208: LD_INT 1
34210: ARRAY
34211: PPUSH
34212: LD_INT 112
34214: PPUSH
34215: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34219: LD_VAR 0 9
34223: PUSH
34224: LD_INT 1
34226: ARRAY
34227: PPUSH
34228: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34232: LD_EXP 80
34236: PUSH
34237: LD_VAR 0 2
34241: ARRAY
34242: PUSH
34243: LD_EXP 80
34247: PUSH
34248: LD_VAR 0 2
34252: ARRAY
34253: PUSH
34254: LD_INT 1
34256: ARRAY
34257: PPUSH
34258: CALL_OW 314
34262: NOT
34263: AND
34264: PUSH
34265: LD_EXP 80
34269: PUSH
34270: LD_VAR 0 2
34274: ARRAY
34275: PUSH
34276: LD_INT 1
34278: ARRAY
34279: PPUSH
34280: CALL_OW 310
34284: NOT
34285: AND
34286: IFFALSE 34312
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34288: LD_EXP 80
34292: PUSH
34293: LD_VAR 0 2
34297: ARRAY
34298: PUSH
34299: LD_INT 1
34301: ARRAY
34302: PPUSH
34303: LD_VAR 0 3
34307: PPUSH
34308: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34312: LD_EXP 80
34316: PUSH
34317: LD_VAR 0 2
34321: ARRAY
34322: PUSH
34323: LD_INT 1
34325: ARRAY
34326: PPUSH
34327: CALL_OW 310
34331: PUSH
34332: LD_EXP 80
34336: PUSH
34337: LD_VAR 0 2
34341: ARRAY
34342: PUSH
34343: LD_INT 1
34345: ARRAY
34346: PPUSH
34347: CALL_OW 310
34351: PPUSH
34352: CALL_OW 461
34356: PUSH
34357: LD_INT 3
34359: NONEQUAL
34360: AND
34361: IFFALSE 34382
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34363: LD_EXP 80
34367: PUSH
34368: LD_VAR 0 2
34372: ARRAY
34373: PUSH
34374: LD_INT 1
34376: ARRAY
34377: PPUSH
34378: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34382: LD_VAR 0 3
34386: PPUSH
34387: CALL_OW 461
34391: PUSH
34392: LD_INT 6
34394: EQUAL
34395: PUSH
34396: LD_VAR 0 6
34400: PUSH
34401: LD_INT 1
34403: GREATER
34404: AND
34405: IFFALSE 34557
// begin sci := [ ] ;
34407: LD_ADDR_VAR 0 8
34411: PUSH
34412: EMPTY
34413: ST_TO_ADDR
// for x in ( tmp diff j ) do
34414: LD_ADDR_VAR 0 7
34418: PUSH
34419: LD_VAR 0 6
34423: PUSH
34424: LD_VAR 0 3
34428: DIFF
34429: PUSH
34430: FOR_IN
34431: IFFALSE 34483
// begin if sci = 6 then
34433: LD_VAR 0 8
34437: PUSH
34438: LD_INT 6
34440: EQUAL
34441: IFFALSE 34445
// break ;
34443: GO 34483
// if BuildingStatus ( x ) = bs_idle then
34445: LD_VAR 0 7
34449: PPUSH
34450: CALL_OW 461
34454: PUSH
34455: LD_INT 2
34457: EQUAL
34458: IFFALSE 34481
// sci := sci ^ UnitsInside ( x ) ;
34460: LD_ADDR_VAR 0 8
34464: PUSH
34465: LD_VAR 0 8
34469: PUSH
34470: LD_VAR 0 7
34474: PPUSH
34475: CALL_OW 313
34479: ADD
34480: ST_TO_ADDR
// end ;
34481: GO 34430
34483: POP
34484: POP
// if not sci then
34485: LD_VAR 0 8
34489: NOT
34490: IFFALSE 34494
// continue ;
34492: GO 33539
// for x in sci do
34494: LD_ADDR_VAR 0 7
34498: PUSH
34499: LD_VAR 0 8
34503: PUSH
34504: FOR_IN
34505: IFFALSE 34555
// if IsInUnit ( x ) and not HasTask ( x ) then
34507: LD_VAR 0 7
34511: PPUSH
34512: CALL_OW 310
34516: PUSH
34517: LD_VAR 0 7
34521: PPUSH
34522: CALL_OW 314
34526: NOT
34527: AND
34528: IFFALSE 34553
// begin ComExitBuilding ( x ) ;
34530: LD_VAR 0 7
34534: PPUSH
34535: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34539: LD_VAR 0 7
34543: PPUSH
34544: LD_VAR 0 3
34548: PPUSH
34549: CALL_OW 180
// end ;
34553: GO 34504
34555: POP
34556: POP
// end ; end ;
34557: GO 33539
34559: POP
34560: POP
// end ;
34561: GO 33493
34563: POP
34564: POP
// end ;
34565: LD_VAR 0 1
34569: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34570: LD_INT 0
34572: PPUSH
34573: PPUSH
// if not mc_bases then
34574: LD_EXP 50
34578: NOT
34579: IFFALSE 34583
// exit ;
34581: GO 34664
// for i = 1 to mc_bases do
34583: LD_ADDR_VAR 0 2
34587: PUSH
34588: DOUBLE
34589: LD_INT 1
34591: DEC
34592: ST_TO_ADDR
34593: LD_EXP 50
34597: PUSH
34598: FOR_TO
34599: IFFALSE 34662
// if mc_mines [ i ] and mc_miners [ i ] then
34601: LD_EXP 63
34605: PUSH
34606: LD_VAR 0 2
34610: ARRAY
34611: PUSH
34612: LD_EXP 64
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: AND
34623: IFFALSE 34660
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34625: LD_EXP 64
34629: PUSH
34630: LD_VAR 0 2
34634: ARRAY
34635: PUSH
34636: LD_INT 1
34638: ARRAY
34639: PPUSH
34640: CALL_OW 255
34644: PPUSH
34645: LD_EXP 63
34649: PUSH
34650: LD_VAR 0 2
34654: ARRAY
34655: PPUSH
34656: CALL 51492 0 2
34660: GO 34598
34662: POP
34663: POP
// end ;
34664: LD_VAR 0 1
34668: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34669: LD_INT 0
34671: PPUSH
34672: PPUSH
34673: PPUSH
34674: PPUSH
34675: PPUSH
34676: PPUSH
34677: PPUSH
34678: PPUSH
// if not mc_bases or not mc_parking then
34679: LD_EXP 50
34683: NOT
34684: PUSH
34685: LD_EXP 74
34689: NOT
34690: OR
34691: IFFALSE 34695
// exit ;
34693: GO 35394
// for i = 1 to mc_bases do
34695: LD_ADDR_VAR 0 2
34699: PUSH
34700: DOUBLE
34701: LD_INT 1
34703: DEC
34704: ST_TO_ADDR
34705: LD_EXP 50
34709: PUSH
34710: FOR_TO
34711: IFFALSE 35392
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34713: LD_EXP 50
34717: PUSH
34718: LD_VAR 0 2
34722: ARRAY
34723: NOT
34724: PUSH
34725: LD_EXP 74
34729: PUSH
34730: LD_VAR 0 2
34734: ARRAY
34735: NOT
34736: OR
34737: IFFALSE 34741
// continue ;
34739: GO 34710
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34741: LD_ADDR_VAR 0 5
34745: PUSH
34746: LD_EXP 50
34750: PUSH
34751: LD_VAR 0 2
34755: ARRAY
34756: PUSH
34757: LD_INT 1
34759: ARRAY
34760: PPUSH
34761: CALL_OW 255
34765: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34766: LD_ADDR_VAR 0 6
34770: PUSH
34771: LD_EXP 50
34775: PUSH
34776: LD_VAR 0 2
34780: ARRAY
34781: PPUSH
34782: LD_INT 30
34784: PUSH
34785: LD_INT 3
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PPUSH
34792: CALL_OW 72
34796: ST_TO_ADDR
// if not fac then
34797: LD_VAR 0 6
34801: NOT
34802: IFFALSE 34853
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34804: LD_ADDR_VAR 0 6
34808: PUSH
34809: LD_EXP 50
34813: PUSH
34814: LD_VAR 0 2
34818: ARRAY
34819: PPUSH
34820: LD_INT 2
34822: PUSH
34823: LD_INT 30
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 30
34835: PUSH
34836: LD_INT 1
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: LIST
34847: PPUSH
34848: CALL_OW 72
34852: ST_TO_ADDR
// if not fac then
34853: LD_VAR 0 6
34857: NOT
34858: IFFALSE 34862
// continue ;
34860: GO 34710
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34862: LD_ADDR_VAR 0 7
34866: PUSH
34867: LD_EXP 74
34871: PUSH
34872: LD_VAR 0 2
34876: ARRAY
34877: PPUSH
34878: LD_INT 22
34880: PUSH
34881: LD_VAR 0 5
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 21
34892: PUSH
34893: LD_INT 2
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 3
34902: PUSH
34903: LD_INT 24
34905: PUSH
34906: LD_INT 1000
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: LIST
34921: PPUSH
34922: CALL_OW 70
34926: ST_TO_ADDR
// for j in fac do
34927: LD_ADDR_VAR 0 3
34931: PUSH
34932: LD_VAR 0 6
34936: PUSH
34937: FOR_IN
34938: IFFALSE 35019
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34940: LD_ADDR_VAR 0 7
34944: PUSH
34945: LD_VAR 0 7
34949: PUSH
34950: LD_INT 22
34952: PUSH
34953: LD_VAR 0 5
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 91
34964: PUSH
34965: LD_VAR 0 3
34969: PUSH
34970: LD_INT 15
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 21
34980: PUSH
34981: LD_INT 2
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 3
34990: PUSH
34991: LD_INT 24
34993: PUSH
34994: LD_INT 1000
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: PPUSH
35011: CALL_OW 69
35015: UNION
35016: ST_TO_ADDR
35017: GO 34937
35019: POP
35020: POP
// if not vehs then
35021: LD_VAR 0 7
35025: NOT
35026: IFFALSE 35052
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35028: LD_ADDR_EXP 62
35032: PUSH
35033: LD_EXP 62
35037: PPUSH
35038: LD_VAR 0 2
35042: PPUSH
35043: EMPTY
35044: PPUSH
35045: CALL_OW 1
35049: ST_TO_ADDR
// continue ;
35050: GO 34710
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35052: LD_ADDR_VAR 0 8
35056: PUSH
35057: LD_EXP 50
35061: PUSH
35062: LD_VAR 0 2
35066: ARRAY
35067: PPUSH
35068: LD_INT 30
35070: PUSH
35071: LD_INT 3
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PPUSH
35078: CALL_OW 72
35082: ST_TO_ADDR
// if tmp then
35083: LD_VAR 0 8
35087: IFFALSE 35190
// begin for j in tmp do
35089: LD_ADDR_VAR 0 3
35093: PUSH
35094: LD_VAR 0 8
35098: PUSH
35099: FOR_IN
35100: IFFALSE 35188
// for k in UnitsInside ( j ) do
35102: LD_ADDR_VAR 0 4
35106: PUSH
35107: LD_VAR 0 3
35111: PPUSH
35112: CALL_OW 313
35116: PUSH
35117: FOR_IN
35118: IFFALSE 35184
// if k then
35120: LD_VAR 0 4
35124: IFFALSE 35182
// if not k in mc_repair_vehicle [ i ] then
35126: LD_VAR 0 4
35130: PUSH
35131: LD_EXP 62
35135: PUSH
35136: LD_VAR 0 2
35140: ARRAY
35141: IN
35142: NOT
35143: IFFALSE 35182
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35145: LD_ADDR_EXP 62
35149: PUSH
35150: LD_EXP 62
35154: PPUSH
35155: LD_VAR 0 2
35159: PPUSH
35160: LD_EXP 62
35164: PUSH
35165: LD_VAR 0 2
35169: ARRAY
35170: PUSH
35171: LD_VAR 0 4
35175: UNION
35176: PPUSH
35177: CALL_OW 1
35181: ST_TO_ADDR
35182: GO 35117
35184: POP
35185: POP
35186: GO 35099
35188: POP
35189: POP
// end ; if not mc_repair_vehicle [ i ] then
35190: LD_EXP 62
35194: PUSH
35195: LD_VAR 0 2
35199: ARRAY
35200: NOT
35201: IFFALSE 35205
// continue ;
35203: GO 34710
// for j in mc_repair_vehicle [ i ] do
35205: LD_ADDR_VAR 0 3
35209: PUSH
35210: LD_EXP 62
35214: PUSH
35215: LD_VAR 0 2
35219: ARRAY
35220: PUSH
35221: FOR_IN
35222: IFFALSE 35388
// begin if GetClass ( j ) <> 3 then
35224: LD_VAR 0 3
35228: PPUSH
35229: CALL_OW 257
35233: PUSH
35234: LD_INT 3
35236: NONEQUAL
35237: IFFALSE 35278
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35239: LD_ADDR_EXP 62
35243: PUSH
35244: LD_EXP 62
35248: PPUSH
35249: LD_VAR 0 2
35253: PPUSH
35254: LD_EXP 62
35258: PUSH
35259: LD_VAR 0 2
35263: ARRAY
35264: PUSH
35265: LD_VAR 0 3
35269: DIFF
35270: PPUSH
35271: CALL_OW 1
35275: ST_TO_ADDR
// continue ;
35276: GO 35221
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35278: LD_VAR 0 3
35282: PPUSH
35283: CALL_OW 311
35287: NOT
35288: PUSH
35289: LD_VAR 0 3
35293: PUSH
35294: LD_EXP 53
35298: PUSH
35299: LD_VAR 0 2
35303: ARRAY
35304: PUSH
35305: LD_INT 1
35307: ARRAY
35308: IN
35309: NOT
35310: AND
35311: PUSH
35312: LD_VAR 0 3
35316: PUSH
35317: LD_EXP 53
35321: PUSH
35322: LD_VAR 0 2
35326: ARRAY
35327: PUSH
35328: LD_INT 2
35330: ARRAY
35331: IN
35332: NOT
35333: AND
35334: IFFALSE 35386
// begin if IsInUnit ( j ) then
35336: LD_VAR 0 3
35340: PPUSH
35341: CALL_OW 310
35345: IFFALSE 35356
// ComExitBuilding ( j ) ;
35347: LD_VAR 0 3
35351: PPUSH
35352: CALL_OW 122
// if not HasTask ( j ) then
35356: LD_VAR 0 3
35360: PPUSH
35361: CALL_OW 314
35365: NOT
35366: IFFALSE 35386
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35368: LD_VAR 0 3
35372: PPUSH
35373: LD_VAR 0 7
35377: PUSH
35378: LD_INT 1
35380: ARRAY
35381: PPUSH
35382: CALL_OW 189
// end ; end ;
35386: GO 35221
35388: POP
35389: POP
// end ;
35390: GO 34710
35392: POP
35393: POP
// end ;
35394: LD_VAR 0 1
35398: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35399: LD_INT 0
35401: PPUSH
35402: PPUSH
35403: PPUSH
35404: PPUSH
35405: PPUSH
35406: PPUSH
35407: PPUSH
35408: PPUSH
35409: PPUSH
35410: PPUSH
35411: PPUSH
// if not mc_bases then
35412: LD_EXP 50
35416: NOT
35417: IFFALSE 35421
// exit ;
35419: GO 36223
// for i = 1 to mc_bases do
35421: LD_ADDR_VAR 0 2
35425: PUSH
35426: DOUBLE
35427: LD_INT 1
35429: DEC
35430: ST_TO_ADDR
35431: LD_EXP 50
35435: PUSH
35436: FOR_TO
35437: IFFALSE 36221
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35439: LD_EXP 78
35443: PUSH
35444: LD_VAR 0 2
35448: ARRAY
35449: NOT
35450: PUSH
35451: LD_EXP 53
35455: PUSH
35456: LD_VAR 0 2
35460: ARRAY
35461: PUSH
35462: LD_INT 1
35464: ARRAY
35465: OR
35466: PUSH
35467: LD_EXP 53
35471: PUSH
35472: LD_VAR 0 2
35476: ARRAY
35477: PUSH
35478: LD_INT 2
35480: ARRAY
35481: OR
35482: PUSH
35483: LD_EXP 76
35487: PUSH
35488: LD_VAR 0 2
35492: ARRAY
35493: PPUSH
35494: LD_INT 1
35496: PPUSH
35497: CALL_OW 325
35501: NOT
35502: OR
35503: PUSH
35504: LD_EXP 73
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: OR
35515: IFFALSE 35519
// continue ;
35517: GO 35436
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35519: LD_ADDR_VAR 0 8
35523: PUSH
35524: LD_EXP 50
35528: PUSH
35529: LD_VAR 0 2
35533: ARRAY
35534: PPUSH
35535: LD_INT 25
35537: PUSH
35538: LD_INT 4
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 50
35547: PUSH
35548: EMPTY
35549: LIST
35550: PUSH
35551: LD_INT 3
35553: PUSH
35554: LD_INT 60
35556: PUSH
35557: EMPTY
35558: LIST
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: LIST
35568: PPUSH
35569: CALL_OW 72
35573: PUSH
35574: LD_EXP 54
35578: PUSH
35579: LD_VAR 0 2
35583: ARRAY
35584: DIFF
35585: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35586: LD_ADDR_VAR 0 9
35590: PUSH
35591: LD_EXP 50
35595: PUSH
35596: LD_VAR 0 2
35600: ARRAY
35601: PPUSH
35602: LD_INT 2
35604: PUSH
35605: LD_INT 30
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 30
35617: PUSH
35618: LD_INT 1
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: LIST
35629: PPUSH
35630: CALL_OW 72
35634: ST_TO_ADDR
// if not tmp or not dep then
35635: LD_VAR 0 8
35639: NOT
35640: PUSH
35641: LD_VAR 0 9
35645: NOT
35646: OR
35647: IFFALSE 35651
// continue ;
35649: GO 35436
// side := GetSide ( tmp [ 1 ] ) ;
35651: LD_ADDR_VAR 0 11
35655: PUSH
35656: LD_VAR 0 8
35660: PUSH
35661: LD_INT 1
35663: ARRAY
35664: PPUSH
35665: CALL_OW 255
35669: ST_TO_ADDR
// dep := dep [ 1 ] ;
35670: LD_ADDR_VAR 0 9
35674: PUSH
35675: LD_VAR 0 9
35679: PUSH
35680: LD_INT 1
35682: ARRAY
35683: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35684: LD_ADDR_VAR 0 7
35688: PUSH
35689: LD_EXP 78
35693: PUSH
35694: LD_VAR 0 2
35698: ARRAY
35699: PPUSH
35700: LD_INT 22
35702: PUSH
35703: LD_INT 0
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 25
35712: PUSH
35713: LD_INT 12
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PPUSH
35724: CALL_OW 70
35728: PUSH
35729: LD_INT 22
35731: PUSH
35732: LD_INT 0
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: PUSH
35739: LD_INT 25
35741: PUSH
35742: LD_INT 12
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 91
35751: PUSH
35752: LD_VAR 0 9
35756: PUSH
35757: LD_INT 20
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: LIST
35764: PUSH
35765: EMPTY
35766: LIST
35767: LIST
35768: LIST
35769: PPUSH
35770: CALL_OW 69
35774: UNION
35775: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35776: LD_ADDR_VAR 0 10
35780: PUSH
35781: LD_EXP 78
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PPUSH
35792: LD_INT 81
35794: PUSH
35795: LD_VAR 0 11
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PPUSH
35804: CALL_OW 70
35808: ST_TO_ADDR
// if not apes or danger_at_area then
35809: LD_VAR 0 7
35813: NOT
35814: PUSH
35815: LD_VAR 0 10
35819: OR
35820: IFFALSE 35870
// begin if mc_taming [ i ] then
35822: LD_EXP 81
35826: PUSH
35827: LD_VAR 0 2
35831: ARRAY
35832: IFFALSE 35868
// begin MC_Reset ( i , 121 ) ;
35834: LD_VAR 0 2
35838: PPUSH
35839: LD_INT 121
35841: PPUSH
35842: CALL 21305 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35846: LD_ADDR_EXP 81
35850: PUSH
35851: LD_EXP 81
35855: PPUSH
35856: LD_VAR 0 2
35860: PPUSH
35861: EMPTY
35862: PPUSH
35863: CALL_OW 1
35867: ST_TO_ADDR
// end ; continue ;
35868: GO 35436
// end ; for j in tmp do
35870: LD_ADDR_VAR 0 3
35874: PUSH
35875: LD_VAR 0 8
35879: PUSH
35880: FOR_IN
35881: IFFALSE 36217
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
35883: LD_VAR 0 3
35887: PUSH
35888: LD_EXP 81
35892: PUSH
35893: LD_VAR 0 2
35897: ARRAY
35898: IN
35899: NOT
35900: PUSH
35901: LD_EXP 81
35905: PUSH
35906: LD_VAR 0 2
35910: ARRAY
35911: PUSH
35912: LD_INT 3
35914: LESS
35915: AND
35916: IFFALSE 35974
// begin SetTag ( j , 121 ) ;
35918: LD_VAR 0 3
35922: PPUSH
35923: LD_INT 121
35925: PPUSH
35926: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
35930: LD_ADDR_EXP 81
35934: PUSH
35935: LD_EXP 81
35939: PPUSH
35940: LD_VAR 0 2
35944: PUSH
35945: LD_EXP 81
35949: PUSH
35950: LD_VAR 0 2
35954: ARRAY
35955: PUSH
35956: LD_INT 1
35958: PLUS
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PPUSH
35964: LD_VAR 0 3
35968: PPUSH
35969: CALL 54503 0 3
35973: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
35974: LD_VAR 0 3
35978: PUSH
35979: LD_EXP 81
35983: PUSH
35984: LD_VAR 0 2
35988: ARRAY
35989: IN
35990: IFFALSE 36215
// begin if GetClass ( j ) <> 4 then
35992: LD_VAR 0 3
35996: PPUSH
35997: CALL_OW 257
36001: PUSH
36002: LD_INT 4
36004: NONEQUAL
36005: IFFALSE 36058
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36007: LD_ADDR_EXP 81
36011: PUSH
36012: LD_EXP 81
36016: PPUSH
36017: LD_VAR 0 2
36021: PPUSH
36022: LD_EXP 81
36026: PUSH
36027: LD_VAR 0 2
36031: ARRAY
36032: PUSH
36033: LD_VAR 0 3
36037: DIFF
36038: PPUSH
36039: CALL_OW 1
36043: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36044: LD_VAR 0 3
36048: PPUSH
36049: LD_INT 0
36051: PPUSH
36052: CALL_OW 109
// continue ;
36056: GO 35880
// end ; if IsInUnit ( j ) then
36058: LD_VAR 0 3
36062: PPUSH
36063: CALL_OW 310
36067: IFFALSE 36078
// ComExitBuilding ( j ) ;
36069: LD_VAR 0 3
36073: PPUSH
36074: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36078: LD_ADDR_VAR 0 6
36082: PUSH
36083: LD_VAR 0 7
36087: PPUSH
36088: LD_VAR 0 3
36092: PPUSH
36093: CALL_OW 74
36097: ST_TO_ADDR
// if not ape then
36098: LD_VAR 0 6
36102: NOT
36103: IFFALSE 36107
// break ;
36105: GO 36217
// x := GetX ( ape ) ;
36107: LD_ADDR_VAR 0 4
36111: PUSH
36112: LD_VAR 0 6
36116: PPUSH
36117: CALL_OW 250
36121: ST_TO_ADDR
// y := GetY ( ape ) ;
36122: LD_ADDR_VAR 0 5
36126: PUSH
36127: LD_VAR 0 6
36131: PPUSH
36132: CALL_OW 251
36136: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36137: LD_VAR 0 4
36141: PPUSH
36142: LD_VAR 0 5
36146: PPUSH
36147: CALL_OW 488
36151: NOT
36152: PUSH
36153: LD_VAR 0 11
36157: PPUSH
36158: LD_VAR 0 4
36162: PPUSH
36163: LD_VAR 0 5
36167: PPUSH
36168: LD_INT 20
36170: PPUSH
36171: CALL 55399 0 4
36175: PUSH
36176: LD_INT 4
36178: ARRAY
36179: OR
36180: IFFALSE 36184
// break ;
36182: GO 36217
// if not HasTask ( j ) then
36184: LD_VAR 0 3
36188: PPUSH
36189: CALL_OW 314
36193: NOT
36194: IFFALSE 36215
// ComTameXY ( j , x , y ) ;
36196: LD_VAR 0 3
36200: PPUSH
36201: LD_VAR 0 4
36205: PPUSH
36206: LD_VAR 0 5
36210: PPUSH
36211: CALL_OW 131
// end ; end ;
36215: GO 35880
36217: POP
36218: POP
// end ;
36219: GO 35436
36221: POP
36222: POP
// end ;
36223: LD_VAR 0 1
36227: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36228: LD_INT 0
36230: PPUSH
36231: PPUSH
36232: PPUSH
36233: PPUSH
36234: PPUSH
36235: PPUSH
36236: PPUSH
36237: PPUSH
// if not mc_bases then
36238: LD_EXP 50
36242: NOT
36243: IFFALSE 36247
// exit ;
36245: GO 36873
// for i = 1 to mc_bases do
36247: LD_ADDR_VAR 0 2
36251: PUSH
36252: DOUBLE
36253: LD_INT 1
36255: DEC
36256: ST_TO_ADDR
36257: LD_EXP 50
36261: PUSH
36262: FOR_TO
36263: IFFALSE 36871
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36265: LD_EXP 79
36269: PUSH
36270: LD_VAR 0 2
36274: ARRAY
36275: NOT
36276: PUSH
36277: LD_EXP 79
36281: PUSH
36282: LD_VAR 0 2
36286: ARRAY
36287: PPUSH
36288: LD_INT 25
36290: PUSH
36291: LD_INT 12
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PPUSH
36298: CALL_OW 72
36302: NOT
36303: OR
36304: IFFALSE 36308
// continue ;
36306: GO 36262
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36308: LD_ADDR_VAR 0 5
36312: PUSH
36313: LD_EXP 79
36317: PUSH
36318: LD_VAR 0 2
36322: ARRAY
36323: PUSH
36324: LD_INT 1
36326: ARRAY
36327: PPUSH
36328: CALL_OW 255
36332: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36333: LD_VAR 0 5
36337: PPUSH
36338: LD_INT 2
36340: PPUSH
36341: CALL_OW 325
36345: IFFALSE 36598
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36347: LD_ADDR_VAR 0 4
36351: PUSH
36352: LD_EXP 79
36356: PUSH
36357: LD_VAR 0 2
36361: ARRAY
36362: PPUSH
36363: LD_INT 25
36365: PUSH
36366: LD_INT 16
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PPUSH
36373: CALL_OW 72
36377: ST_TO_ADDR
// if tmp < 6 then
36378: LD_VAR 0 4
36382: PUSH
36383: LD_INT 6
36385: LESS
36386: IFFALSE 36598
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36388: LD_ADDR_VAR 0 6
36392: PUSH
36393: LD_EXP 50
36397: PUSH
36398: LD_VAR 0 2
36402: ARRAY
36403: PPUSH
36404: LD_INT 2
36406: PUSH
36407: LD_INT 30
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 30
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: LIST
36431: PPUSH
36432: CALL_OW 72
36436: ST_TO_ADDR
// if depot then
36437: LD_VAR 0 6
36441: IFFALSE 36598
// begin selected := 0 ;
36443: LD_ADDR_VAR 0 7
36447: PUSH
36448: LD_INT 0
36450: ST_TO_ADDR
// for j in depot do
36451: LD_ADDR_VAR 0 3
36455: PUSH
36456: LD_VAR 0 6
36460: PUSH
36461: FOR_IN
36462: IFFALSE 36493
// begin if UnitsInside ( j ) < 6 then
36464: LD_VAR 0 3
36468: PPUSH
36469: CALL_OW 313
36473: PUSH
36474: LD_INT 6
36476: LESS
36477: IFFALSE 36491
// begin selected := j ;
36479: LD_ADDR_VAR 0 7
36483: PUSH
36484: LD_VAR 0 3
36488: ST_TO_ADDR
// break ;
36489: GO 36493
// end ; end ;
36491: GO 36461
36493: POP
36494: POP
// if selected then
36495: LD_VAR 0 7
36499: IFFALSE 36598
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36501: LD_ADDR_VAR 0 3
36505: PUSH
36506: LD_EXP 79
36510: PUSH
36511: LD_VAR 0 2
36515: ARRAY
36516: PPUSH
36517: LD_INT 25
36519: PUSH
36520: LD_INT 12
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PPUSH
36527: CALL_OW 72
36531: PUSH
36532: FOR_IN
36533: IFFALSE 36596
// if not HasTask ( j ) then
36535: LD_VAR 0 3
36539: PPUSH
36540: CALL_OW 314
36544: NOT
36545: IFFALSE 36594
// begin if not IsInUnit ( j ) then
36547: LD_VAR 0 3
36551: PPUSH
36552: CALL_OW 310
36556: NOT
36557: IFFALSE 36573
// ComEnterUnit ( j , selected ) ;
36559: LD_VAR 0 3
36563: PPUSH
36564: LD_VAR 0 7
36568: PPUSH
36569: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36573: LD_VAR 0 3
36577: PPUSH
36578: LD_INT 16
36580: PPUSH
36581: CALL_OW 183
// AddComExitBuilding ( j ) ;
36585: LD_VAR 0 3
36589: PPUSH
36590: CALL_OW 182
// end ;
36594: GO 36532
36596: POP
36597: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36598: LD_VAR 0 5
36602: PPUSH
36603: LD_INT 11
36605: PPUSH
36606: CALL_OW 325
36610: IFFALSE 36869
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36612: LD_ADDR_VAR 0 4
36616: PUSH
36617: LD_EXP 79
36621: PUSH
36622: LD_VAR 0 2
36626: ARRAY
36627: PPUSH
36628: LD_INT 25
36630: PUSH
36631: LD_INT 16
36633: PUSH
36634: EMPTY
36635: LIST
36636: LIST
36637: PPUSH
36638: CALL_OW 72
36642: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36643: LD_VAR 0 4
36647: PUSH
36648: LD_INT 6
36650: GREATEREQUAL
36651: PUSH
36652: LD_VAR 0 5
36656: PPUSH
36657: LD_INT 2
36659: PPUSH
36660: CALL_OW 325
36664: NOT
36665: OR
36666: IFFALSE 36869
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36668: LD_ADDR_VAR 0 8
36672: PUSH
36673: LD_EXP 50
36677: PUSH
36678: LD_VAR 0 2
36682: ARRAY
36683: PPUSH
36684: LD_INT 2
36686: PUSH
36687: LD_INT 30
36689: PUSH
36690: LD_INT 4
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 30
36699: PUSH
36700: LD_INT 5
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: LIST
36711: PPUSH
36712: CALL_OW 72
36716: ST_TO_ADDR
// if barracks then
36717: LD_VAR 0 8
36721: IFFALSE 36869
// begin selected := 0 ;
36723: LD_ADDR_VAR 0 7
36727: PUSH
36728: LD_INT 0
36730: ST_TO_ADDR
// for j in barracks do
36731: LD_ADDR_VAR 0 3
36735: PUSH
36736: LD_VAR 0 8
36740: PUSH
36741: FOR_IN
36742: IFFALSE 36773
// begin if UnitsInside ( j ) < 6 then
36744: LD_VAR 0 3
36748: PPUSH
36749: CALL_OW 313
36753: PUSH
36754: LD_INT 6
36756: LESS
36757: IFFALSE 36771
// begin selected := j ;
36759: LD_ADDR_VAR 0 7
36763: PUSH
36764: LD_VAR 0 3
36768: ST_TO_ADDR
// break ;
36769: GO 36773
// end ; end ;
36771: GO 36741
36773: POP
36774: POP
// if selected then
36775: LD_VAR 0 7
36779: IFFALSE 36869
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36781: LD_ADDR_VAR 0 3
36785: PUSH
36786: LD_EXP 79
36790: PUSH
36791: LD_VAR 0 2
36795: ARRAY
36796: PPUSH
36797: LD_INT 25
36799: PUSH
36800: LD_INT 12
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PPUSH
36807: CALL_OW 72
36811: PUSH
36812: FOR_IN
36813: IFFALSE 36867
// if not IsInUnit ( j ) and not HasTask ( j ) then
36815: LD_VAR 0 3
36819: PPUSH
36820: CALL_OW 310
36824: NOT
36825: PUSH
36826: LD_VAR 0 3
36830: PPUSH
36831: CALL_OW 314
36835: NOT
36836: AND
36837: IFFALSE 36865
// begin ComEnterUnit ( j , selected ) ;
36839: LD_VAR 0 3
36843: PPUSH
36844: LD_VAR 0 7
36848: PPUSH
36849: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36853: LD_VAR 0 3
36857: PPUSH
36858: LD_INT 15
36860: PPUSH
36861: CALL_OW 183
// end ;
36865: GO 36812
36867: POP
36868: POP
// end ; end ; end ; end ; end ;
36869: GO 36262
36871: POP
36872: POP
// end ;
36873: LD_VAR 0 1
36877: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36878: LD_INT 0
36880: PPUSH
36881: PPUSH
36882: PPUSH
36883: PPUSH
// if not mc_bases then
36884: LD_EXP 50
36888: NOT
36889: IFFALSE 36893
// exit ;
36891: GO 37071
// for i = 1 to mc_bases do
36893: LD_ADDR_VAR 0 2
36897: PUSH
36898: DOUBLE
36899: LD_INT 1
36901: DEC
36902: ST_TO_ADDR
36903: LD_EXP 50
36907: PUSH
36908: FOR_TO
36909: IFFALSE 37069
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
36911: LD_ADDR_VAR 0 4
36915: PUSH
36916: LD_EXP 50
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: PPUSH
36927: LD_INT 25
36929: PUSH
36930: LD_INT 9
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PPUSH
36937: CALL_OW 72
36941: ST_TO_ADDR
// if not tmp then
36942: LD_VAR 0 4
36946: NOT
36947: IFFALSE 36951
// continue ;
36949: GO 36908
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
36951: LD_EXP 76
36955: PUSH
36956: LD_VAR 0 2
36960: ARRAY
36961: PPUSH
36962: LD_INT 29
36964: PPUSH
36965: CALL_OW 325
36969: NOT
36970: PUSH
36971: LD_EXP 76
36975: PUSH
36976: LD_VAR 0 2
36980: ARRAY
36981: PPUSH
36982: LD_INT 28
36984: PPUSH
36985: CALL_OW 325
36989: NOT
36990: AND
36991: IFFALSE 36995
// continue ;
36993: GO 36908
// for j in tmp do
36995: LD_ADDR_VAR 0 3
36999: PUSH
37000: LD_VAR 0 4
37004: PUSH
37005: FOR_IN
37006: IFFALSE 37065
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37008: LD_VAR 0 3
37012: PUSH
37013: LD_EXP 53
37017: PUSH
37018: LD_VAR 0 2
37022: ARRAY
37023: PUSH
37024: LD_INT 1
37026: ARRAY
37027: IN
37028: NOT
37029: PUSH
37030: LD_VAR 0 3
37034: PUSH
37035: LD_EXP 53
37039: PUSH
37040: LD_VAR 0 2
37044: ARRAY
37045: PUSH
37046: LD_INT 2
37048: ARRAY
37049: IN
37050: NOT
37051: AND
37052: IFFALSE 37063
// ComSpaceTimeShoot ( j ) ;
37054: LD_VAR 0 3
37058: PPUSH
37059: CALL 48089 0 1
37063: GO 37005
37065: POP
37066: POP
// end ;
37067: GO 36908
37069: POP
37070: POP
// end ;
37071: LD_VAR 0 1
37075: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37076: LD_INT 0
37078: PPUSH
37079: PPUSH
37080: PPUSH
37081: PPUSH
37082: PPUSH
37083: PPUSH
37084: PPUSH
37085: PPUSH
37086: PPUSH
// if not mc_bases then
37087: LD_EXP 50
37091: NOT
37092: IFFALSE 37096
// exit ;
37094: GO 37718
// for i = 1 to mc_bases do
37096: LD_ADDR_VAR 0 2
37100: PUSH
37101: DOUBLE
37102: LD_INT 1
37104: DEC
37105: ST_TO_ADDR
37106: LD_EXP 50
37110: PUSH
37111: FOR_TO
37112: IFFALSE 37716
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37114: LD_EXP 85
37118: PUSH
37119: LD_VAR 0 2
37123: ARRAY
37124: NOT
37125: PUSH
37126: LD_INT 38
37128: PPUSH
37129: LD_EXP 76
37133: PUSH
37134: LD_VAR 0 2
37138: ARRAY
37139: PPUSH
37140: CALL_OW 321
37144: PUSH
37145: LD_INT 2
37147: NONEQUAL
37148: OR
37149: IFFALSE 37153
// continue ;
37151: GO 37111
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37153: LD_ADDR_VAR 0 8
37157: PUSH
37158: LD_EXP 50
37162: PUSH
37163: LD_VAR 0 2
37167: ARRAY
37168: PPUSH
37169: LD_INT 30
37171: PUSH
37172: LD_INT 34
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PPUSH
37179: CALL_OW 72
37183: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37184: LD_ADDR_VAR 0 9
37188: PUSH
37189: LD_EXP 50
37193: PUSH
37194: LD_VAR 0 2
37198: ARRAY
37199: PPUSH
37200: LD_INT 25
37202: PUSH
37203: LD_INT 4
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PPUSH
37210: CALL_OW 72
37214: PPUSH
37215: LD_INT 0
37217: PPUSH
37218: CALL 87789 0 2
37222: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37223: LD_VAR 0 9
37227: NOT
37228: PUSH
37229: LD_VAR 0 8
37233: NOT
37234: OR
37235: PUSH
37236: LD_EXP 50
37240: PUSH
37241: LD_VAR 0 2
37245: ARRAY
37246: PPUSH
37247: LD_INT 124
37249: PPUSH
37250: CALL 87789 0 2
37254: OR
37255: IFFALSE 37259
// continue ;
37257: GO 37111
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37259: LD_EXP 86
37263: PUSH
37264: LD_VAR 0 2
37268: ARRAY
37269: PUSH
37270: LD_EXP 85
37274: PUSH
37275: LD_VAR 0 2
37279: ARRAY
37280: LESS
37281: PUSH
37282: LD_EXP 86
37286: PUSH
37287: LD_VAR 0 2
37291: ARRAY
37292: PUSH
37293: LD_VAR 0 8
37297: LESS
37298: AND
37299: IFFALSE 37714
// begin tmp := sci [ 1 ] ;
37301: LD_ADDR_VAR 0 7
37305: PUSH
37306: LD_VAR 0 9
37310: PUSH
37311: LD_INT 1
37313: ARRAY
37314: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37315: LD_VAR 0 7
37319: PPUSH
37320: LD_INT 124
37322: PPUSH
37323: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37327: LD_ADDR_VAR 0 3
37331: PUSH
37332: DOUBLE
37333: LD_EXP 85
37337: PUSH
37338: LD_VAR 0 2
37342: ARRAY
37343: INC
37344: ST_TO_ADDR
37345: LD_EXP 85
37349: PUSH
37350: LD_VAR 0 2
37354: ARRAY
37355: PUSH
37356: FOR_DOWNTO
37357: IFFALSE 37700
// begin if IsInUnit ( tmp ) then
37359: LD_VAR 0 7
37363: PPUSH
37364: CALL_OW 310
37368: IFFALSE 37379
// ComExitBuilding ( tmp ) ;
37370: LD_VAR 0 7
37374: PPUSH
37375: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37379: LD_INT 35
37381: PPUSH
37382: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37386: LD_VAR 0 7
37390: PPUSH
37391: CALL_OW 310
37395: NOT
37396: PUSH
37397: LD_VAR 0 7
37401: PPUSH
37402: CALL_OW 314
37406: NOT
37407: AND
37408: IFFALSE 37379
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37410: LD_ADDR_VAR 0 6
37414: PUSH
37415: LD_VAR 0 7
37419: PPUSH
37420: CALL_OW 250
37424: PUSH
37425: LD_VAR 0 7
37429: PPUSH
37430: CALL_OW 251
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37439: LD_INT 35
37441: PPUSH
37442: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37446: LD_ADDR_VAR 0 4
37450: PUSH
37451: LD_EXP 85
37455: PUSH
37456: LD_VAR 0 2
37460: ARRAY
37461: PUSH
37462: LD_VAR 0 3
37466: ARRAY
37467: PUSH
37468: LD_INT 1
37470: ARRAY
37471: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37472: LD_ADDR_VAR 0 5
37476: PUSH
37477: LD_EXP 85
37481: PUSH
37482: LD_VAR 0 2
37486: ARRAY
37487: PUSH
37488: LD_VAR 0 3
37492: ARRAY
37493: PUSH
37494: LD_INT 2
37496: ARRAY
37497: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37498: LD_VAR 0 7
37502: PPUSH
37503: LD_INT 10
37505: PPUSH
37506: CALL 57096 0 2
37510: PUSH
37511: LD_INT 4
37513: ARRAY
37514: IFFALSE 37552
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37516: LD_VAR 0 7
37520: PPUSH
37521: LD_VAR 0 6
37525: PUSH
37526: LD_INT 1
37528: ARRAY
37529: PPUSH
37530: LD_VAR 0 6
37534: PUSH
37535: LD_INT 2
37537: ARRAY
37538: PPUSH
37539: CALL_OW 111
// wait ( 0 0$10 ) ;
37543: LD_INT 350
37545: PPUSH
37546: CALL_OW 67
// end else
37550: GO 37578
// begin ComMoveXY ( tmp , x , y ) ;
37552: LD_VAR 0 7
37556: PPUSH
37557: LD_VAR 0 4
37561: PPUSH
37562: LD_VAR 0 5
37566: PPUSH
37567: CALL_OW 111
// wait ( 0 0$3 ) ;
37571: LD_INT 105
37573: PPUSH
37574: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37578: LD_VAR 0 7
37582: PPUSH
37583: LD_VAR 0 4
37587: PPUSH
37588: LD_VAR 0 5
37592: PPUSH
37593: CALL_OW 307
37597: IFFALSE 37439
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37599: LD_VAR 0 7
37603: PPUSH
37604: LD_VAR 0 4
37608: PPUSH
37609: LD_VAR 0 5
37613: PPUSH
37614: LD_VAR 0 8
37618: PUSH
37619: LD_VAR 0 3
37623: ARRAY
37624: PPUSH
37625: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37629: LD_INT 35
37631: PPUSH
37632: CALL_OW 67
// until not HasTask ( tmp ) ;
37636: LD_VAR 0 7
37640: PPUSH
37641: CALL_OW 314
37645: NOT
37646: IFFALSE 37629
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37648: LD_ADDR_EXP 86
37652: PUSH
37653: LD_EXP 86
37657: PPUSH
37658: LD_VAR 0 2
37662: PUSH
37663: LD_EXP 86
37667: PUSH
37668: LD_VAR 0 2
37672: ARRAY
37673: PUSH
37674: LD_INT 1
37676: PLUS
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PPUSH
37682: LD_VAR 0 8
37686: PUSH
37687: LD_VAR 0 3
37691: ARRAY
37692: PPUSH
37693: CALL 54503 0 3
37697: ST_TO_ADDR
// end ;
37698: GO 37356
37700: POP
37701: POP
// MC_Reset ( i , 124 ) ;
37702: LD_VAR 0 2
37706: PPUSH
37707: LD_INT 124
37709: PPUSH
37710: CALL 21305 0 2
// end ; end ;
37714: GO 37111
37716: POP
37717: POP
// end ;
37718: LD_VAR 0 1
37722: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37723: LD_INT 0
37725: PPUSH
37726: PPUSH
37727: PPUSH
// if not mc_bases then
37728: LD_EXP 50
37732: NOT
37733: IFFALSE 37737
// exit ;
37735: GO 38343
// for i = 1 to mc_bases do
37737: LD_ADDR_VAR 0 2
37741: PUSH
37742: DOUBLE
37743: LD_INT 1
37745: DEC
37746: ST_TO_ADDR
37747: LD_EXP 50
37751: PUSH
37752: FOR_TO
37753: IFFALSE 38341
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37755: LD_ADDR_VAR 0 3
37759: PUSH
37760: LD_EXP 50
37764: PUSH
37765: LD_VAR 0 2
37769: ARRAY
37770: PPUSH
37771: LD_INT 25
37773: PUSH
37774: LD_INT 4
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PPUSH
37781: CALL_OW 72
37785: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37786: LD_VAR 0 3
37790: NOT
37791: PUSH
37792: LD_EXP 87
37796: PUSH
37797: LD_VAR 0 2
37801: ARRAY
37802: NOT
37803: OR
37804: PUSH
37805: LD_EXP 50
37809: PUSH
37810: LD_VAR 0 2
37814: ARRAY
37815: PPUSH
37816: LD_INT 2
37818: PUSH
37819: LD_INT 30
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 30
37831: PUSH
37832: LD_INT 1
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: LIST
37843: PPUSH
37844: CALL_OW 72
37848: NOT
37849: OR
37850: IFFALSE 37900
// begin if mc_deposits_finder [ i ] then
37852: LD_EXP 88
37856: PUSH
37857: LD_VAR 0 2
37861: ARRAY
37862: IFFALSE 37898
// begin MC_Reset ( i , 125 ) ;
37864: LD_VAR 0 2
37868: PPUSH
37869: LD_INT 125
37871: PPUSH
37872: CALL 21305 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37876: LD_ADDR_EXP 88
37880: PUSH
37881: LD_EXP 88
37885: PPUSH
37886: LD_VAR 0 2
37890: PPUSH
37891: EMPTY
37892: PPUSH
37893: CALL_OW 1
37897: ST_TO_ADDR
// end ; continue ;
37898: GO 37752
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
37900: LD_EXP 87
37904: PUSH
37905: LD_VAR 0 2
37909: ARRAY
37910: PUSH
37911: LD_INT 1
37913: ARRAY
37914: PUSH
37915: LD_INT 3
37917: ARRAY
37918: PUSH
37919: LD_INT 1
37921: EQUAL
37922: PUSH
37923: LD_INT 20
37925: PPUSH
37926: LD_EXP 76
37930: PUSH
37931: LD_VAR 0 2
37935: ARRAY
37936: PPUSH
37937: CALL_OW 321
37941: PUSH
37942: LD_INT 2
37944: NONEQUAL
37945: AND
37946: IFFALSE 37996
// begin if mc_deposits_finder [ i ] then
37948: LD_EXP 88
37952: PUSH
37953: LD_VAR 0 2
37957: ARRAY
37958: IFFALSE 37994
// begin MC_Reset ( i , 125 ) ;
37960: LD_VAR 0 2
37964: PPUSH
37965: LD_INT 125
37967: PPUSH
37968: CALL 21305 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37972: LD_ADDR_EXP 88
37976: PUSH
37977: LD_EXP 88
37981: PPUSH
37982: LD_VAR 0 2
37986: PPUSH
37987: EMPTY
37988: PPUSH
37989: CALL_OW 1
37993: ST_TO_ADDR
// end ; continue ;
37994: GO 37752
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
37996: LD_EXP 87
38000: PUSH
38001: LD_VAR 0 2
38005: ARRAY
38006: PUSH
38007: LD_INT 1
38009: ARRAY
38010: PUSH
38011: LD_INT 1
38013: ARRAY
38014: PPUSH
38015: LD_EXP 87
38019: PUSH
38020: LD_VAR 0 2
38024: ARRAY
38025: PUSH
38026: LD_INT 1
38028: ARRAY
38029: PUSH
38030: LD_INT 2
38032: ARRAY
38033: PPUSH
38034: LD_EXP 76
38038: PUSH
38039: LD_VAR 0 2
38043: ARRAY
38044: PPUSH
38045: CALL_OW 440
38049: IFFALSE 38092
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38051: LD_ADDR_EXP 87
38055: PUSH
38056: LD_EXP 87
38060: PPUSH
38061: LD_VAR 0 2
38065: PPUSH
38066: LD_EXP 87
38070: PUSH
38071: LD_VAR 0 2
38075: ARRAY
38076: PPUSH
38077: LD_INT 1
38079: PPUSH
38080: CALL_OW 3
38084: PPUSH
38085: CALL_OW 1
38089: ST_TO_ADDR
38090: GO 38339
// begin if not mc_deposits_finder [ i ] then
38092: LD_EXP 88
38096: PUSH
38097: LD_VAR 0 2
38101: ARRAY
38102: NOT
38103: IFFALSE 38155
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38105: LD_ADDR_EXP 88
38109: PUSH
38110: LD_EXP 88
38114: PPUSH
38115: LD_VAR 0 2
38119: PPUSH
38120: LD_VAR 0 3
38124: PUSH
38125: LD_INT 1
38127: ARRAY
38128: PUSH
38129: EMPTY
38130: LIST
38131: PPUSH
38132: CALL_OW 1
38136: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38137: LD_VAR 0 3
38141: PUSH
38142: LD_INT 1
38144: ARRAY
38145: PPUSH
38146: LD_INT 125
38148: PPUSH
38149: CALL_OW 109
// end else
38153: GO 38339
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38155: LD_EXP 88
38159: PUSH
38160: LD_VAR 0 2
38164: ARRAY
38165: PUSH
38166: LD_INT 1
38168: ARRAY
38169: PPUSH
38170: CALL_OW 310
38174: IFFALSE 38197
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38176: LD_EXP 88
38180: PUSH
38181: LD_VAR 0 2
38185: ARRAY
38186: PUSH
38187: LD_INT 1
38189: ARRAY
38190: PPUSH
38191: CALL_OW 122
38195: GO 38339
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38197: LD_EXP 88
38201: PUSH
38202: LD_VAR 0 2
38206: ARRAY
38207: PUSH
38208: LD_INT 1
38210: ARRAY
38211: PPUSH
38212: CALL_OW 314
38216: NOT
38217: PUSH
38218: LD_EXP 88
38222: PUSH
38223: LD_VAR 0 2
38227: ARRAY
38228: PUSH
38229: LD_INT 1
38231: ARRAY
38232: PPUSH
38233: LD_EXP 87
38237: PUSH
38238: LD_VAR 0 2
38242: ARRAY
38243: PUSH
38244: LD_INT 1
38246: ARRAY
38247: PUSH
38248: LD_INT 1
38250: ARRAY
38251: PPUSH
38252: LD_EXP 87
38256: PUSH
38257: LD_VAR 0 2
38261: ARRAY
38262: PUSH
38263: LD_INT 1
38265: ARRAY
38266: PUSH
38267: LD_INT 2
38269: ARRAY
38270: PPUSH
38271: CALL_OW 297
38275: PUSH
38276: LD_INT 6
38278: GREATER
38279: AND
38280: IFFALSE 38339
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38282: LD_EXP 88
38286: PUSH
38287: LD_VAR 0 2
38291: ARRAY
38292: PUSH
38293: LD_INT 1
38295: ARRAY
38296: PPUSH
38297: LD_EXP 87
38301: PUSH
38302: LD_VAR 0 2
38306: ARRAY
38307: PUSH
38308: LD_INT 1
38310: ARRAY
38311: PUSH
38312: LD_INT 1
38314: ARRAY
38315: PPUSH
38316: LD_EXP 87
38320: PUSH
38321: LD_VAR 0 2
38325: ARRAY
38326: PUSH
38327: LD_INT 1
38329: ARRAY
38330: PUSH
38331: LD_INT 2
38333: ARRAY
38334: PPUSH
38335: CALL_OW 111
// end ; end ; end ;
38339: GO 37752
38341: POP
38342: POP
// end ;
38343: LD_VAR 0 1
38347: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38348: LD_INT 0
38350: PPUSH
38351: PPUSH
38352: PPUSH
38353: PPUSH
38354: PPUSH
38355: PPUSH
38356: PPUSH
38357: PPUSH
38358: PPUSH
38359: PPUSH
38360: PPUSH
// if not mc_bases then
38361: LD_EXP 50
38365: NOT
38366: IFFALSE 38370
// exit ;
38368: GO 39310
// for i = 1 to mc_bases do
38370: LD_ADDR_VAR 0 2
38374: PUSH
38375: DOUBLE
38376: LD_INT 1
38378: DEC
38379: ST_TO_ADDR
38380: LD_EXP 50
38384: PUSH
38385: FOR_TO
38386: IFFALSE 39308
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38388: LD_EXP 50
38392: PUSH
38393: LD_VAR 0 2
38397: ARRAY
38398: NOT
38399: PUSH
38400: LD_EXP 73
38404: PUSH
38405: LD_VAR 0 2
38409: ARRAY
38410: OR
38411: IFFALSE 38415
// continue ;
38413: GO 38385
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38415: LD_ADDR_VAR 0 7
38419: PUSH
38420: LD_EXP 50
38424: PUSH
38425: LD_VAR 0 2
38429: ARRAY
38430: PUSH
38431: LD_INT 1
38433: ARRAY
38434: PPUSH
38435: CALL_OW 248
38439: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38440: LD_VAR 0 7
38444: PUSH
38445: LD_INT 3
38447: EQUAL
38448: PUSH
38449: LD_EXP 69
38453: PUSH
38454: LD_VAR 0 2
38458: ARRAY
38459: PUSH
38460: LD_EXP 72
38464: PUSH
38465: LD_VAR 0 2
38469: ARRAY
38470: UNION
38471: PPUSH
38472: LD_INT 33
38474: PUSH
38475: LD_INT 2
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PPUSH
38482: CALL_OW 72
38486: NOT
38487: OR
38488: IFFALSE 38492
// continue ;
38490: GO 38385
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38492: LD_ADDR_VAR 0 9
38496: PUSH
38497: LD_EXP 50
38501: PUSH
38502: LD_VAR 0 2
38506: ARRAY
38507: PPUSH
38508: LD_INT 30
38510: PUSH
38511: LD_INT 36
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PPUSH
38518: CALL_OW 72
38522: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38523: LD_ADDR_VAR 0 10
38527: PUSH
38528: LD_EXP 69
38532: PUSH
38533: LD_VAR 0 2
38537: ARRAY
38538: PPUSH
38539: LD_INT 34
38541: PUSH
38542: LD_INT 31
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PPUSH
38549: CALL_OW 72
38553: ST_TO_ADDR
// if not cts and not mcts then
38554: LD_VAR 0 9
38558: NOT
38559: PUSH
38560: LD_VAR 0 10
38564: NOT
38565: AND
38566: IFFALSE 38570
// continue ;
38568: GO 38385
// x := cts ;
38570: LD_ADDR_VAR 0 11
38574: PUSH
38575: LD_VAR 0 9
38579: ST_TO_ADDR
// if not x then
38580: LD_VAR 0 11
38584: NOT
38585: IFFALSE 38597
// x := mcts ;
38587: LD_ADDR_VAR 0 11
38591: PUSH
38592: LD_VAR 0 10
38596: ST_TO_ADDR
// if not x then
38597: LD_VAR 0 11
38601: NOT
38602: IFFALSE 38606
// continue ;
38604: GO 38385
// if mc_remote_driver [ i ] then
38606: LD_EXP 90
38610: PUSH
38611: LD_VAR 0 2
38615: ARRAY
38616: IFFALSE 39003
// for j in mc_remote_driver [ i ] do
38618: LD_ADDR_VAR 0 3
38622: PUSH
38623: LD_EXP 90
38627: PUSH
38628: LD_VAR 0 2
38632: ARRAY
38633: PUSH
38634: FOR_IN
38635: IFFALSE 39001
// begin if GetClass ( j ) <> 3 then
38637: LD_VAR 0 3
38641: PPUSH
38642: CALL_OW 257
38646: PUSH
38647: LD_INT 3
38649: NONEQUAL
38650: IFFALSE 38703
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38652: LD_ADDR_EXP 90
38656: PUSH
38657: LD_EXP 90
38661: PPUSH
38662: LD_VAR 0 2
38666: PPUSH
38667: LD_EXP 90
38671: PUSH
38672: LD_VAR 0 2
38676: ARRAY
38677: PUSH
38678: LD_VAR 0 3
38682: DIFF
38683: PPUSH
38684: CALL_OW 1
38688: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38689: LD_VAR 0 3
38693: PPUSH
38694: LD_INT 0
38696: PPUSH
38697: CALL_OW 109
// continue ;
38701: GO 38634
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38703: LD_EXP 69
38707: PUSH
38708: LD_VAR 0 2
38712: ARRAY
38713: PPUSH
38714: LD_INT 34
38716: PUSH
38717: LD_INT 31
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 58
38726: PUSH
38727: EMPTY
38728: LIST
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PPUSH
38734: CALL_OW 72
38738: PUSH
38739: LD_VAR 0 3
38743: PPUSH
38744: CALL 87877 0 1
38748: NOT
38749: AND
38750: IFFALSE 38821
// begin if IsInUnit ( j ) then
38752: LD_VAR 0 3
38756: PPUSH
38757: CALL_OW 310
38761: IFFALSE 38772
// ComExitBuilding ( j ) ;
38763: LD_VAR 0 3
38767: PPUSH
38768: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38772: LD_VAR 0 3
38776: PPUSH
38777: LD_EXP 69
38781: PUSH
38782: LD_VAR 0 2
38786: ARRAY
38787: PPUSH
38788: LD_INT 34
38790: PUSH
38791: LD_INT 31
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 58
38800: PUSH
38801: EMPTY
38802: LIST
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PPUSH
38808: CALL_OW 72
38812: PUSH
38813: LD_INT 1
38815: ARRAY
38816: PPUSH
38817: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38821: LD_VAR 0 3
38825: PPUSH
38826: CALL_OW 310
38830: NOT
38831: PUSH
38832: LD_VAR 0 3
38836: PPUSH
38837: CALL_OW 310
38841: PPUSH
38842: CALL_OW 266
38846: PUSH
38847: LD_INT 36
38849: NONEQUAL
38850: PUSH
38851: LD_VAR 0 3
38855: PPUSH
38856: CALL 87877 0 1
38860: NOT
38861: AND
38862: OR
38863: IFFALSE 38999
// begin if IsInUnit ( j ) then
38865: LD_VAR 0 3
38869: PPUSH
38870: CALL_OW 310
38874: IFFALSE 38885
// ComExitBuilding ( j ) ;
38876: LD_VAR 0 3
38880: PPUSH
38881: CALL_OW 122
// ct := 0 ;
38885: LD_ADDR_VAR 0 8
38889: PUSH
38890: LD_INT 0
38892: ST_TO_ADDR
// for k in x do
38893: LD_ADDR_VAR 0 4
38897: PUSH
38898: LD_VAR 0 11
38902: PUSH
38903: FOR_IN
38904: IFFALSE 38977
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
38906: LD_VAR 0 4
38910: PPUSH
38911: CALL_OW 264
38915: PUSH
38916: LD_INT 31
38918: EQUAL
38919: PUSH
38920: LD_VAR 0 4
38924: PPUSH
38925: CALL_OW 311
38929: NOT
38930: AND
38931: PUSH
38932: LD_VAR 0 4
38936: PPUSH
38937: CALL_OW 266
38941: PUSH
38942: LD_INT 36
38944: EQUAL
38945: PUSH
38946: LD_VAR 0 4
38950: PPUSH
38951: CALL_OW 313
38955: PUSH
38956: LD_INT 3
38958: LESS
38959: AND
38960: OR
38961: IFFALSE 38975
// begin ct := k ;
38963: LD_ADDR_VAR 0 8
38967: PUSH
38968: LD_VAR 0 4
38972: ST_TO_ADDR
// break ;
38973: GO 38977
// end ;
38975: GO 38903
38977: POP
38978: POP
// if ct then
38979: LD_VAR 0 8
38983: IFFALSE 38999
// ComEnterUnit ( j , ct ) ;
38985: LD_VAR 0 3
38989: PPUSH
38990: LD_VAR 0 8
38994: PPUSH
38995: CALL_OW 120
// end ; end ;
38999: GO 38634
39001: POP
39002: POP
// places := 0 ;
39003: LD_ADDR_VAR 0 5
39007: PUSH
39008: LD_INT 0
39010: ST_TO_ADDR
// for j = 1 to x do
39011: LD_ADDR_VAR 0 3
39015: PUSH
39016: DOUBLE
39017: LD_INT 1
39019: DEC
39020: ST_TO_ADDR
39021: LD_VAR 0 11
39025: PUSH
39026: FOR_TO
39027: IFFALSE 39103
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39029: LD_VAR 0 11
39033: PUSH
39034: LD_VAR 0 3
39038: ARRAY
39039: PPUSH
39040: CALL_OW 264
39044: PUSH
39045: LD_INT 31
39047: EQUAL
39048: IFFALSE 39066
// places := places + 1 else
39050: LD_ADDR_VAR 0 5
39054: PUSH
39055: LD_VAR 0 5
39059: PUSH
39060: LD_INT 1
39062: PLUS
39063: ST_TO_ADDR
39064: GO 39101
// if GetBType ( x [ j ] ) = b_control_tower then
39066: LD_VAR 0 11
39070: PUSH
39071: LD_VAR 0 3
39075: ARRAY
39076: PPUSH
39077: CALL_OW 266
39081: PUSH
39082: LD_INT 36
39084: EQUAL
39085: IFFALSE 39101
// places := places + 3 ;
39087: LD_ADDR_VAR 0 5
39091: PUSH
39092: LD_VAR 0 5
39096: PUSH
39097: LD_INT 3
39099: PLUS
39100: ST_TO_ADDR
39101: GO 39026
39103: POP
39104: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39105: LD_VAR 0 5
39109: PUSH
39110: LD_INT 0
39112: EQUAL
39113: PUSH
39114: LD_VAR 0 5
39118: PUSH
39119: LD_EXP 90
39123: PUSH
39124: LD_VAR 0 2
39128: ARRAY
39129: LESSEQUAL
39130: OR
39131: IFFALSE 39135
// continue ;
39133: GO 38385
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39135: LD_ADDR_VAR 0 6
39139: PUSH
39140: LD_EXP 50
39144: PUSH
39145: LD_VAR 0 2
39149: ARRAY
39150: PPUSH
39151: LD_INT 25
39153: PUSH
39154: LD_INT 3
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PPUSH
39161: CALL_OW 72
39165: PUSH
39166: LD_EXP 90
39170: PUSH
39171: LD_VAR 0 2
39175: ARRAY
39176: DIFF
39177: PPUSH
39178: LD_INT 3
39180: PPUSH
39181: CALL 88777 0 2
39185: ST_TO_ADDR
// for j in tmp do
39186: LD_ADDR_VAR 0 3
39190: PUSH
39191: LD_VAR 0 6
39195: PUSH
39196: FOR_IN
39197: IFFALSE 39232
// if GetTag ( j ) > 0 then
39199: LD_VAR 0 3
39203: PPUSH
39204: CALL_OW 110
39208: PUSH
39209: LD_INT 0
39211: GREATER
39212: IFFALSE 39230
// tmp := tmp diff j ;
39214: LD_ADDR_VAR 0 6
39218: PUSH
39219: LD_VAR 0 6
39223: PUSH
39224: LD_VAR 0 3
39228: DIFF
39229: ST_TO_ADDR
39230: GO 39196
39232: POP
39233: POP
// if not tmp then
39234: LD_VAR 0 6
39238: NOT
39239: IFFALSE 39243
// continue ;
39241: GO 38385
// if places then
39243: LD_VAR 0 5
39247: IFFALSE 39306
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39249: LD_ADDR_EXP 90
39253: PUSH
39254: LD_EXP 90
39258: PPUSH
39259: LD_VAR 0 2
39263: PPUSH
39264: LD_EXP 90
39268: PUSH
39269: LD_VAR 0 2
39273: ARRAY
39274: PUSH
39275: LD_VAR 0 6
39279: PUSH
39280: LD_INT 1
39282: ARRAY
39283: UNION
39284: PPUSH
39285: CALL_OW 1
39289: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39290: LD_VAR 0 6
39294: PUSH
39295: LD_INT 1
39297: ARRAY
39298: PPUSH
39299: LD_INT 126
39301: PPUSH
39302: CALL_OW 109
// end ; end ;
39306: GO 38385
39308: POP
39309: POP
// end ;
39310: LD_VAR 0 1
39314: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39315: LD_INT 0
39317: PPUSH
39318: PPUSH
39319: PPUSH
39320: PPUSH
39321: PPUSH
39322: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39323: LD_VAR 0 1
39327: NOT
39328: PUSH
39329: LD_VAR 0 2
39333: NOT
39334: OR
39335: PUSH
39336: LD_VAR 0 3
39340: NOT
39341: OR
39342: PUSH
39343: LD_VAR 0 4
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: LD_INT 2
39353: PUSH
39354: LD_INT 3
39356: PUSH
39357: LD_INT 4
39359: PUSH
39360: LD_INT 5
39362: PUSH
39363: LD_INT 8
39365: PUSH
39366: LD_INT 9
39368: PUSH
39369: LD_INT 15
39371: PUSH
39372: LD_INT 16
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: IN
39386: NOT
39387: OR
39388: IFFALSE 39392
// exit ;
39390: GO 40292
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39392: LD_ADDR_VAR 0 2
39396: PUSH
39397: LD_VAR 0 2
39401: PPUSH
39402: LD_INT 21
39404: PUSH
39405: LD_INT 3
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 24
39414: PUSH
39415: LD_INT 250
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PPUSH
39426: CALL_OW 72
39430: ST_TO_ADDR
// case class of 1 , 15 :
39431: LD_VAR 0 4
39435: PUSH
39436: LD_INT 1
39438: DOUBLE
39439: EQUAL
39440: IFTRUE 39450
39442: LD_INT 15
39444: DOUBLE
39445: EQUAL
39446: IFTRUE 39450
39448: GO 39535
39450: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39451: LD_ADDR_VAR 0 8
39455: PUSH
39456: LD_VAR 0 2
39460: PPUSH
39461: LD_INT 2
39463: PUSH
39464: LD_INT 30
39466: PUSH
39467: LD_INT 32
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 30
39476: PUSH
39477: LD_INT 31
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: LIST
39488: PPUSH
39489: CALL_OW 72
39493: PUSH
39494: LD_VAR 0 2
39498: PPUSH
39499: LD_INT 2
39501: PUSH
39502: LD_INT 30
39504: PUSH
39505: LD_INT 4
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 30
39514: PUSH
39515: LD_INT 5
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: LIST
39526: PPUSH
39527: CALL_OW 72
39531: ADD
39532: ST_TO_ADDR
39533: GO 39781
39535: LD_INT 2
39537: DOUBLE
39538: EQUAL
39539: IFTRUE 39549
39541: LD_INT 16
39543: DOUBLE
39544: EQUAL
39545: IFTRUE 39549
39547: GO 39595
39549: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39550: LD_ADDR_VAR 0 8
39554: PUSH
39555: LD_VAR 0 2
39559: PPUSH
39560: LD_INT 2
39562: PUSH
39563: LD_INT 30
39565: PUSH
39566: LD_INT 0
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 30
39575: PUSH
39576: LD_INT 1
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: LIST
39587: PPUSH
39588: CALL_OW 72
39592: ST_TO_ADDR
39593: GO 39781
39595: LD_INT 3
39597: DOUBLE
39598: EQUAL
39599: IFTRUE 39603
39601: GO 39649
39603: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39604: LD_ADDR_VAR 0 8
39608: PUSH
39609: LD_VAR 0 2
39613: PPUSH
39614: LD_INT 2
39616: PUSH
39617: LD_INT 30
39619: PUSH
39620: LD_INT 2
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 30
39629: PUSH
39630: LD_INT 3
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: LIST
39641: PPUSH
39642: CALL_OW 72
39646: ST_TO_ADDR
39647: GO 39781
39649: LD_INT 4
39651: DOUBLE
39652: EQUAL
39653: IFTRUE 39657
39655: GO 39714
39657: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39658: LD_ADDR_VAR 0 8
39662: PUSH
39663: LD_VAR 0 2
39667: PPUSH
39668: LD_INT 2
39670: PUSH
39671: LD_INT 30
39673: PUSH
39674: LD_INT 6
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 30
39683: PUSH
39684: LD_INT 7
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 30
39693: PUSH
39694: LD_INT 8
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: PPUSH
39707: CALL_OW 72
39711: ST_TO_ADDR
39712: GO 39781
39714: LD_INT 5
39716: DOUBLE
39717: EQUAL
39718: IFTRUE 39734
39720: LD_INT 8
39722: DOUBLE
39723: EQUAL
39724: IFTRUE 39734
39726: LD_INT 9
39728: DOUBLE
39729: EQUAL
39730: IFTRUE 39734
39732: GO 39780
39734: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39735: LD_ADDR_VAR 0 8
39739: PUSH
39740: LD_VAR 0 2
39744: PPUSH
39745: LD_INT 2
39747: PUSH
39748: LD_INT 30
39750: PUSH
39751: LD_INT 4
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 30
39760: PUSH
39761: LD_INT 5
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: LIST
39772: PPUSH
39773: CALL_OW 72
39777: ST_TO_ADDR
39778: GO 39781
39780: POP
// if not tmp then
39781: LD_VAR 0 8
39785: NOT
39786: IFFALSE 39790
// exit ;
39788: GO 40292
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39790: LD_VAR 0 4
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: LD_INT 15
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: IN
39805: PUSH
39806: LD_EXP 59
39810: PUSH
39811: LD_VAR 0 1
39815: ARRAY
39816: AND
39817: IFFALSE 39973
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39819: LD_ADDR_VAR 0 9
39823: PUSH
39824: LD_EXP 59
39828: PUSH
39829: LD_VAR 0 1
39833: ARRAY
39834: PUSH
39835: LD_INT 1
39837: ARRAY
39838: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39839: LD_VAR 0 9
39843: PUSH
39844: LD_EXP 60
39848: PUSH
39849: LD_VAR 0 1
39853: ARRAY
39854: IN
39855: NOT
39856: IFFALSE 39971
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39858: LD_ADDR_EXP 60
39862: PUSH
39863: LD_EXP 60
39867: PPUSH
39868: LD_VAR 0 1
39872: PUSH
39873: LD_EXP 60
39877: PUSH
39878: LD_VAR 0 1
39882: ARRAY
39883: PUSH
39884: LD_INT 1
39886: PLUS
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PPUSH
39892: LD_VAR 0 9
39896: PPUSH
39897: CALL 54503 0 3
39901: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
39902: LD_ADDR_EXP 59
39906: PUSH
39907: LD_EXP 59
39911: PPUSH
39912: LD_VAR 0 1
39916: PPUSH
39917: LD_EXP 59
39921: PUSH
39922: LD_VAR 0 1
39926: ARRAY
39927: PUSH
39928: LD_VAR 0 9
39932: DIFF
39933: PPUSH
39934: CALL_OW 1
39938: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
39939: LD_VAR 0 3
39943: PPUSH
39944: LD_EXP 60
39948: PUSH
39949: LD_VAR 0 1
39953: ARRAY
39954: PUSH
39955: LD_EXP 60
39959: PUSH
39960: LD_VAR 0 1
39964: ARRAY
39965: ARRAY
39966: PPUSH
39967: CALL_OW 120
// end ; exit ;
39971: GO 40292
// end ; if tmp > 1 then
39973: LD_VAR 0 8
39977: PUSH
39978: LD_INT 1
39980: GREATER
39981: IFFALSE 40085
// for i = 2 to tmp do
39983: LD_ADDR_VAR 0 6
39987: PUSH
39988: DOUBLE
39989: LD_INT 2
39991: DEC
39992: ST_TO_ADDR
39993: LD_VAR 0 8
39997: PUSH
39998: FOR_TO
39999: IFFALSE 40083
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40001: LD_VAR 0 8
40005: PUSH
40006: LD_VAR 0 6
40010: ARRAY
40011: PPUSH
40012: CALL_OW 461
40016: PUSH
40017: LD_INT 6
40019: EQUAL
40020: IFFALSE 40081
// begin x := tmp [ i ] ;
40022: LD_ADDR_VAR 0 9
40026: PUSH
40027: LD_VAR 0 8
40031: PUSH
40032: LD_VAR 0 6
40036: ARRAY
40037: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40038: LD_ADDR_VAR 0 8
40042: PUSH
40043: LD_VAR 0 8
40047: PPUSH
40048: LD_VAR 0 6
40052: PPUSH
40053: CALL_OW 3
40057: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40058: LD_ADDR_VAR 0 8
40062: PUSH
40063: LD_VAR 0 8
40067: PPUSH
40068: LD_INT 1
40070: PPUSH
40071: LD_VAR 0 9
40075: PPUSH
40076: CALL_OW 2
40080: ST_TO_ADDR
// end ;
40081: GO 39998
40083: POP
40084: POP
// for i in tmp do
40085: LD_ADDR_VAR 0 6
40089: PUSH
40090: LD_VAR 0 8
40094: PUSH
40095: FOR_IN
40096: IFFALSE 40165
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40098: LD_VAR 0 6
40102: PPUSH
40103: CALL_OW 313
40107: PUSH
40108: LD_INT 6
40110: LESS
40111: PUSH
40112: LD_VAR 0 6
40116: PPUSH
40117: CALL_OW 266
40121: PUSH
40122: LD_INT 31
40124: PUSH
40125: LD_INT 32
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: IN
40132: NOT
40133: AND
40134: PUSH
40135: LD_VAR 0 6
40139: PPUSH
40140: CALL_OW 313
40144: PUSH
40145: LD_INT 0
40147: EQUAL
40148: OR
40149: IFFALSE 40163
// begin j := i ;
40151: LD_ADDR_VAR 0 7
40155: PUSH
40156: LD_VAR 0 6
40160: ST_TO_ADDR
// break ;
40161: GO 40165
// end ; end ;
40163: GO 40095
40165: POP
40166: POP
// if j then
40167: LD_VAR 0 7
40171: IFFALSE 40189
// ComEnterUnit ( unit , j ) else
40173: LD_VAR 0 3
40177: PPUSH
40178: LD_VAR 0 7
40182: PPUSH
40183: CALL_OW 120
40187: GO 40292
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40189: LD_ADDR_VAR 0 10
40193: PUSH
40194: LD_VAR 0 2
40198: PPUSH
40199: LD_INT 2
40201: PUSH
40202: LD_INT 30
40204: PUSH
40205: LD_INT 0
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: PUSH
40212: LD_INT 30
40214: PUSH
40215: LD_INT 1
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: LIST
40226: PPUSH
40227: CALL_OW 72
40231: ST_TO_ADDR
// if depot then
40232: LD_VAR 0 10
40236: IFFALSE 40292
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40238: LD_ADDR_VAR 0 10
40242: PUSH
40243: LD_VAR 0 10
40247: PPUSH
40248: LD_VAR 0 3
40252: PPUSH
40253: CALL_OW 74
40257: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40258: LD_VAR 0 3
40262: PPUSH
40263: LD_VAR 0 10
40267: PPUSH
40268: CALL_OW 296
40272: PUSH
40273: LD_INT 10
40275: GREATER
40276: IFFALSE 40292
// ComStandNearbyBuilding ( unit , depot ) ;
40278: LD_VAR 0 3
40282: PPUSH
40283: LD_VAR 0 10
40287: PPUSH
40288: CALL 48706 0 2
// end ; end ; end ;
40292: LD_VAR 0 5
40296: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40297: LD_INT 0
40299: PPUSH
40300: PPUSH
40301: PPUSH
40302: PPUSH
// if not mc_bases then
40303: LD_EXP 50
40307: NOT
40308: IFFALSE 40312
// exit ;
40310: GO 40551
// for i = 1 to mc_bases do
40312: LD_ADDR_VAR 0 2
40316: PUSH
40317: DOUBLE
40318: LD_INT 1
40320: DEC
40321: ST_TO_ADDR
40322: LD_EXP 50
40326: PUSH
40327: FOR_TO
40328: IFFALSE 40549
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40330: LD_ADDR_VAR 0 4
40334: PUSH
40335: LD_EXP 50
40339: PUSH
40340: LD_VAR 0 2
40344: ARRAY
40345: PPUSH
40346: LD_INT 21
40348: PUSH
40349: LD_INT 1
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PPUSH
40356: CALL_OW 72
40360: PUSH
40361: LD_EXP 79
40365: PUSH
40366: LD_VAR 0 2
40370: ARRAY
40371: UNION
40372: ST_TO_ADDR
// if not tmp then
40373: LD_VAR 0 4
40377: NOT
40378: IFFALSE 40382
// continue ;
40380: GO 40327
// for j in tmp do
40382: LD_ADDR_VAR 0 3
40386: PUSH
40387: LD_VAR 0 4
40391: PUSH
40392: FOR_IN
40393: IFFALSE 40545
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40395: LD_VAR 0 3
40399: PPUSH
40400: CALL_OW 110
40404: NOT
40405: PUSH
40406: LD_VAR 0 3
40410: PPUSH
40411: CALL_OW 314
40415: NOT
40416: AND
40417: PUSH
40418: LD_VAR 0 3
40422: PPUSH
40423: CALL_OW 311
40427: NOT
40428: AND
40429: PUSH
40430: LD_VAR 0 3
40434: PPUSH
40435: CALL_OW 310
40439: NOT
40440: AND
40441: PUSH
40442: LD_VAR 0 3
40446: PUSH
40447: LD_EXP 53
40451: PUSH
40452: LD_VAR 0 2
40456: ARRAY
40457: PUSH
40458: LD_INT 1
40460: ARRAY
40461: IN
40462: NOT
40463: AND
40464: PUSH
40465: LD_VAR 0 3
40469: PUSH
40470: LD_EXP 53
40474: PUSH
40475: LD_VAR 0 2
40479: ARRAY
40480: PUSH
40481: LD_INT 2
40483: ARRAY
40484: IN
40485: NOT
40486: AND
40487: PUSH
40488: LD_VAR 0 3
40492: PUSH
40493: LD_EXP 62
40497: PUSH
40498: LD_VAR 0 2
40502: ARRAY
40503: IN
40504: NOT
40505: AND
40506: IFFALSE 40543
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40508: LD_VAR 0 2
40512: PPUSH
40513: LD_EXP 50
40517: PUSH
40518: LD_VAR 0 2
40522: ARRAY
40523: PPUSH
40524: LD_VAR 0 3
40528: PPUSH
40529: LD_VAR 0 3
40533: PPUSH
40534: CALL_OW 257
40538: PPUSH
40539: CALL 39315 0 4
// end ;
40543: GO 40392
40545: POP
40546: POP
// end ;
40547: GO 40327
40549: POP
40550: POP
// end ;
40551: LD_VAR 0 1
40555: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40556: LD_INT 0
40558: PPUSH
40559: PPUSH
40560: PPUSH
40561: PPUSH
40562: PPUSH
40563: PPUSH
// if not mc_bases [ base ] then
40564: LD_EXP 50
40568: PUSH
40569: LD_VAR 0 1
40573: ARRAY
40574: NOT
40575: IFFALSE 40579
// exit ;
40577: GO 40761
// tmp := [ ] ;
40579: LD_ADDR_VAR 0 6
40583: PUSH
40584: EMPTY
40585: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40586: LD_ADDR_VAR 0 7
40590: PUSH
40591: LD_VAR 0 3
40595: PPUSH
40596: LD_INT 0
40598: PPUSH
40599: CALL_OW 517
40603: ST_TO_ADDR
// if not list then
40604: LD_VAR 0 7
40608: NOT
40609: IFFALSE 40613
// exit ;
40611: GO 40761
// for i = 1 to amount do
40613: LD_ADDR_VAR 0 5
40617: PUSH
40618: DOUBLE
40619: LD_INT 1
40621: DEC
40622: ST_TO_ADDR
40623: LD_VAR 0 2
40627: PUSH
40628: FOR_TO
40629: IFFALSE 40709
// begin x := rand ( 1 , list [ 1 ] ) ;
40631: LD_ADDR_VAR 0 8
40635: PUSH
40636: LD_INT 1
40638: PPUSH
40639: LD_VAR 0 7
40643: PUSH
40644: LD_INT 1
40646: ARRAY
40647: PPUSH
40648: CALL_OW 12
40652: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40653: LD_ADDR_VAR 0 6
40657: PUSH
40658: LD_VAR 0 6
40662: PPUSH
40663: LD_VAR 0 5
40667: PPUSH
40668: LD_VAR 0 7
40672: PUSH
40673: LD_INT 1
40675: ARRAY
40676: PUSH
40677: LD_VAR 0 8
40681: ARRAY
40682: PUSH
40683: LD_VAR 0 7
40687: PUSH
40688: LD_INT 2
40690: ARRAY
40691: PUSH
40692: LD_VAR 0 8
40696: ARRAY
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PPUSH
40702: CALL_OW 1
40706: ST_TO_ADDR
// end ;
40707: GO 40628
40709: POP
40710: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40711: LD_ADDR_EXP 63
40715: PUSH
40716: LD_EXP 63
40720: PPUSH
40721: LD_VAR 0 1
40725: PPUSH
40726: LD_VAR 0 6
40730: PPUSH
40731: CALL_OW 1
40735: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40736: LD_ADDR_EXP 65
40740: PUSH
40741: LD_EXP 65
40745: PPUSH
40746: LD_VAR 0 1
40750: PPUSH
40751: LD_VAR 0 3
40755: PPUSH
40756: CALL_OW 1
40760: ST_TO_ADDR
// end ;
40761: LD_VAR 0 4
40765: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40766: LD_INT 0
40768: PPUSH
// if not mc_bases [ base ] then
40769: LD_EXP 50
40773: PUSH
40774: LD_VAR 0 1
40778: ARRAY
40779: NOT
40780: IFFALSE 40784
// exit ;
40782: GO 40809
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40784: LD_ADDR_EXP 55
40788: PUSH
40789: LD_EXP 55
40793: PPUSH
40794: LD_VAR 0 1
40798: PPUSH
40799: LD_VAR 0 2
40803: PPUSH
40804: CALL_OW 1
40808: ST_TO_ADDR
// end ;
40809: LD_VAR 0 3
40813: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40814: LD_INT 0
40816: PPUSH
// if not mc_bases [ base ] then
40817: LD_EXP 50
40821: PUSH
40822: LD_VAR 0 1
40826: ARRAY
40827: NOT
40828: IFFALSE 40832
// exit ;
40830: GO 40869
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40832: LD_ADDR_EXP 55
40836: PUSH
40837: LD_EXP 55
40841: PPUSH
40842: LD_VAR 0 1
40846: PPUSH
40847: LD_EXP 55
40851: PUSH
40852: LD_VAR 0 1
40856: ARRAY
40857: PUSH
40858: LD_VAR 0 2
40862: UNION
40863: PPUSH
40864: CALL_OW 1
40868: ST_TO_ADDR
// end ;
40869: LD_VAR 0 3
40873: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40874: LD_INT 0
40876: PPUSH
// if not mc_bases [ base ] then
40877: LD_EXP 50
40881: PUSH
40882: LD_VAR 0 1
40886: ARRAY
40887: NOT
40888: IFFALSE 40892
// exit ;
40890: GO 40917
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
40892: LD_ADDR_EXP 71
40896: PUSH
40897: LD_EXP 71
40901: PPUSH
40902: LD_VAR 0 1
40906: PPUSH
40907: LD_VAR 0 2
40911: PPUSH
40912: CALL_OW 1
40916: ST_TO_ADDR
// end ;
40917: LD_VAR 0 3
40921: RET
// export function MC_InsertProduceList ( base , components ) ; begin
40922: LD_INT 0
40924: PPUSH
// if not mc_bases [ base ] then
40925: LD_EXP 50
40929: PUSH
40930: LD_VAR 0 1
40934: ARRAY
40935: NOT
40936: IFFALSE 40940
// exit ;
40938: GO 40977
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
40940: LD_ADDR_EXP 71
40944: PUSH
40945: LD_EXP 71
40949: PPUSH
40950: LD_VAR 0 1
40954: PPUSH
40955: LD_EXP 71
40959: PUSH
40960: LD_VAR 0 1
40964: ARRAY
40965: PUSH
40966: LD_VAR 0 2
40970: ADD
40971: PPUSH
40972: CALL_OW 1
40976: ST_TO_ADDR
// end ;
40977: LD_VAR 0 3
40981: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
40982: LD_INT 0
40984: PPUSH
// if not mc_bases [ base ] then
40985: LD_EXP 50
40989: PUSH
40990: LD_VAR 0 1
40994: ARRAY
40995: NOT
40996: IFFALSE 41000
// exit ;
40998: GO 41054
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41000: LD_ADDR_EXP 72
41004: PUSH
41005: LD_EXP 72
41009: PPUSH
41010: LD_VAR 0 1
41014: PPUSH
41015: LD_VAR 0 2
41019: PPUSH
41020: CALL_OW 1
41024: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41025: LD_ADDR_EXP 61
41029: PUSH
41030: LD_EXP 61
41034: PPUSH
41035: LD_VAR 0 1
41039: PPUSH
41040: LD_VAR 0 2
41044: PUSH
41045: LD_INT 0
41047: PLUS
41048: PPUSH
41049: CALL_OW 1
41053: ST_TO_ADDR
// end ;
41054: LD_VAR 0 3
41058: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41059: LD_INT 0
41061: PPUSH
// if not mc_bases [ base ] then
41062: LD_EXP 50
41066: PUSH
41067: LD_VAR 0 1
41071: ARRAY
41072: NOT
41073: IFFALSE 41077
// exit ;
41075: GO 41102
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41077: LD_ADDR_EXP 61
41081: PUSH
41082: LD_EXP 61
41086: PPUSH
41087: LD_VAR 0 1
41091: PPUSH
41092: LD_VAR 0 2
41096: PPUSH
41097: CALL_OW 1
41101: ST_TO_ADDR
// end ;
41102: LD_VAR 0 3
41106: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41107: LD_INT 0
41109: PPUSH
41110: PPUSH
41111: PPUSH
41112: PPUSH
// if not mc_bases [ base ] then
41113: LD_EXP 50
41117: PUSH
41118: LD_VAR 0 1
41122: ARRAY
41123: NOT
41124: IFFALSE 41128
// exit ;
41126: GO 41193
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41128: LD_ADDR_EXP 70
41132: PUSH
41133: LD_EXP 70
41137: PPUSH
41138: LD_VAR 0 1
41142: PUSH
41143: LD_EXP 70
41147: PUSH
41148: LD_VAR 0 1
41152: ARRAY
41153: PUSH
41154: LD_INT 1
41156: PLUS
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PPUSH
41162: LD_VAR 0 1
41166: PUSH
41167: LD_VAR 0 2
41171: PUSH
41172: LD_VAR 0 3
41176: PUSH
41177: LD_VAR 0 4
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: LIST
41186: LIST
41187: PPUSH
41188: CALL 54503 0 3
41192: ST_TO_ADDR
// end ;
41193: LD_VAR 0 5
41197: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41198: LD_INT 0
41200: PPUSH
// if not mc_bases [ base ] then
41201: LD_EXP 50
41205: PUSH
41206: LD_VAR 0 1
41210: ARRAY
41211: NOT
41212: IFFALSE 41216
// exit ;
41214: GO 41241
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41216: LD_ADDR_EXP 87
41220: PUSH
41221: LD_EXP 87
41225: PPUSH
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_VAR 0 2
41235: PPUSH
41236: CALL_OW 1
41240: ST_TO_ADDR
// end ;
41241: LD_VAR 0 3
41245: RET
// export function MC_GetMinesField ( base ) ; begin
41246: LD_INT 0
41248: PPUSH
// result := mc_mines [ base ] ;
41249: LD_ADDR_VAR 0 2
41253: PUSH
41254: LD_EXP 63
41258: PUSH
41259: LD_VAR 0 1
41263: ARRAY
41264: ST_TO_ADDR
// end ;
41265: LD_VAR 0 2
41269: RET
// export function MC_GetProduceList ( base ) ; begin
41270: LD_INT 0
41272: PPUSH
// result := mc_produce [ base ] ;
41273: LD_ADDR_VAR 0 2
41277: PUSH
41278: LD_EXP 71
41282: PUSH
41283: LD_VAR 0 1
41287: ARRAY
41288: ST_TO_ADDR
// end ;
41289: LD_VAR 0 2
41293: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41294: LD_INT 0
41296: PPUSH
41297: PPUSH
// if not mc_bases then
41298: LD_EXP 50
41302: NOT
41303: IFFALSE 41307
// exit ;
41305: GO 41372
// if mc_bases [ base ] then
41307: LD_EXP 50
41311: PUSH
41312: LD_VAR 0 1
41316: ARRAY
41317: IFFALSE 41372
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41319: LD_ADDR_VAR 0 3
41323: PUSH
41324: LD_EXP 50
41328: PUSH
41329: LD_VAR 0 1
41333: ARRAY
41334: PPUSH
41335: LD_INT 30
41337: PUSH
41338: LD_VAR 0 2
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PPUSH
41347: CALL_OW 72
41351: ST_TO_ADDR
// if result then
41352: LD_VAR 0 3
41356: IFFALSE 41372
// result := result [ 1 ] ;
41358: LD_ADDR_VAR 0 3
41362: PUSH
41363: LD_VAR 0 3
41367: PUSH
41368: LD_INT 1
41370: ARRAY
41371: ST_TO_ADDR
// end ; end ;
41372: LD_VAR 0 3
41376: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41377: LD_INT 0
41379: PPUSH
41380: PPUSH
// if not mc_bases then
41381: LD_EXP 50
41385: NOT
41386: IFFALSE 41390
// exit ;
41388: GO 41435
// if mc_bases [ base ] then
41390: LD_EXP 50
41394: PUSH
41395: LD_VAR 0 1
41399: ARRAY
41400: IFFALSE 41435
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41402: LD_ADDR_VAR 0 3
41406: PUSH
41407: LD_EXP 50
41411: PUSH
41412: LD_VAR 0 1
41416: ARRAY
41417: PPUSH
41418: LD_INT 30
41420: PUSH
41421: LD_VAR 0 2
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PPUSH
41430: CALL_OW 72
41434: ST_TO_ADDR
// end ;
41435: LD_VAR 0 3
41439: RET
// export function MC_SetTame ( base , area ) ; begin
41440: LD_INT 0
41442: PPUSH
// if not mc_bases or not base then
41443: LD_EXP 50
41447: NOT
41448: PUSH
41449: LD_VAR 0 1
41453: NOT
41454: OR
41455: IFFALSE 41459
// exit ;
41457: GO 41484
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41459: LD_ADDR_EXP 78
41463: PUSH
41464: LD_EXP 78
41468: PPUSH
41469: LD_VAR 0 1
41473: PPUSH
41474: LD_VAR 0 2
41478: PPUSH
41479: CALL_OW 1
41483: ST_TO_ADDR
// end ;
41484: LD_VAR 0 3
41488: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41489: LD_INT 0
41491: PPUSH
41492: PPUSH
// if not mc_bases or not base then
41493: LD_EXP 50
41497: NOT
41498: PUSH
41499: LD_VAR 0 1
41503: NOT
41504: OR
41505: IFFALSE 41509
// exit ;
41507: GO 41611
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41509: LD_ADDR_VAR 0 4
41513: PUSH
41514: LD_EXP 50
41518: PUSH
41519: LD_VAR 0 1
41523: ARRAY
41524: PPUSH
41525: LD_INT 30
41527: PUSH
41528: LD_VAR 0 2
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PPUSH
41537: CALL_OW 72
41541: ST_TO_ADDR
// if not tmp then
41542: LD_VAR 0 4
41546: NOT
41547: IFFALSE 41551
// exit ;
41549: GO 41611
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41551: LD_ADDR_EXP 82
41555: PUSH
41556: LD_EXP 82
41560: PPUSH
41561: LD_VAR 0 1
41565: PPUSH
41566: LD_EXP 82
41570: PUSH
41571: LD_VAR 0 1
41575: ARRAY
41576: PPUSH
41577: LD_EXP 82
41581: PUSH
41582: LD_VAR 0 1
41586: ARRAY
41587: PUSH
41588: LD_INT 1
41590: PLUS
41591: PPUSH
41592: LD_VAR 0 4
41596: PUSH
41597: LD_INT 1
41599: ARRAY
41600: PPUSH
41601: CALL_OW 2
41605: PPUSH
41606: CALL_OW 1
41610: ST_TO_ADDR
// end ;
41611: LD_VAR 0 3
41615: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41616: LD_INT 0
41618: PPUSH
41619: PPUSH
// if not mc_bases or not base or not kinds then
41620: LD_EXP 50
41624: NOT
41625: PUSH
41626: LD_VAR 0 1
41630: NOT
41631: OR
41632: PUSH
41633: LD_VAR 0 2
41637: NOT
41638: OR
41639: IFFALSE 41643
// exit ;
41641: GO 41704
// for i in kinds do
41643: LD_ADDR_VAR 0 4
41647: PUSH
41648: LD_VAR 0 2
41652: PUSH
41653: FOR_IN
41654: IFFALSE 41702
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41656: LD_ADDR_EXP 84
41660: PUSH
41661: LD_EXP 84
41665: PPUSH
41666: LD_VAR 0 1
41670: PUSH
41671: LD_EXP 84
41675: PUSH
41676: LD_VAR 0 1
41680: ARRAY
41681: PUSH
41682: LD_INT 1
41684: PLUS
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PPUSH
41690: LD_VAR 0 4
41694: PPUSH
41695: CALL 54503 0 3
41699: ST_TO_ADDR
41700: GO 41653
41702: POP
41703: POP
// end ;
41704: LD_VAR 0 3
41708: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41709: LD_INT 0
41711: PPUSH
// if not mc_bases or not base or not areas then
41712: LD_EXP 50
41716: NOT
41717: PUSH
41718: LD_VAR 0 1
41722: NOT
41723: OR
41724: PUSH
41725: LD_VAR 0 2
41729: NOT
41730: OR
41731: IFFALSE 41735
// exit ;
41733: GO 41760
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41735: LD_ADDR_EXP 68
41739: PUSH
41740: LD_EXP 68
41744: PPUSH
41745: LD_VAR 0 1
41749: PPUSH
41750: LD_VAR 0 2
41754: PPUSH
41755: CALL_OW 1
41759: ST_TO_ADDR
// end ;
41760: LD_VAR 0 3
41764: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41765: LD_INT 0
41767: PPUSH
// if not mc_bases or not base or not teleports_exit then
41768: LD_EXP 50
41772: NOT
41773: PUSH
41774: LD_VAR 0 1
41778: NOT
41779: OR
41780: PUSH
41781: LD_VAR 0 2
41785: NOT
41786: OR
41787: IFFALSE 41791
// exit ;
41789: GO 41816
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41791: LD_ADDR_EXP 85
41795: PUSH
41796: LD_EXP 85
41800: PPUSH
41801: LD_VAR 0 1
41805: PPUSH
41806: LD_VAR 0 2
41810: PPUSH
41811: CALL_OW 1
41815: ST_TO_ADDR
// end ;
41816: LD_VAR 0 3
41820: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41821: LD_INT 0
41823: PPUSH
41824: PPUSH
41825: PPUSH
// if not mc_bases or not base or not ext_list then
41826: LD_EXP 50
41830: NOT
41831: PUSH
41832: LD_VAR 0 1
41836: NOT
41837: OR
41838: PUSH
41839: LD_VAR 0 5
41843: NOT
41844: OR
41845: IFFALSE 41849
// exit ;
41847: GO 42022
// tmp := GetFacExtXYD ( x , y , d ) ;
41849: LD_ADDR_VAR 0 8
41853: PUSH
41854: LD_VAR 0 2
41858: PPUSH
41859: LD_VAR 0 3
41863: PPUSH
41864: LD_VAR 0 4
41868: PPUSH
41869: CALL 87907 0 3
41873: ST_TO_ADDR
// if not tmp then
41874: LD_VAR 0 8
41878: NOT
41879: IFFALSE 41883
// exit ;
41881: GO 42022
// for i in tmp do
41883: LD_ADDR_VAR 0 7
41887: PUSH
41888: LD_VAR 0 8
41892: PUSH
41893: FOR_IN
41894: IFFALSE 42020
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
41896: LD_ADDR_EXP 55
41900: PUSH
41901: LD_EXP 55
41905: PPUSH
41906: LD_VAR 0 1
41910: PPUSH
41911: LD_EXP 55
41915: PUSH
41916: LD_VAR 0 1
41920: ARRAY
41921: PPUSH
41922: LD_EXP 55
41926: PUSH
41927: LD_VAR 0 1
41931: ARRAY
41932: PUSH
41933: LD_INT 1
41935: PLUS
41936: PPUSH
41937: LD_VAR 0 5
41941: PUSH
41942: LD_INT 1
41944: ARRAY
41945: PUSH
41946: LD_VAR 0 7
41950: PUSH
41951: LD_INT 1
41953: ARRAY
41954: PUSH
41955: LD_VAR 0 7
41959: PUSH
41960: LD_INT 2
41962: ARRAY
41963: PUSH
41964: LD_VAR 0 7
41968: PUSH
41969: LD_INT 3
41971: ARRAY
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: LIST
41977: LIST
41978: PPUSH
41979: CALL_OW 2
41983: PPUSH
41984: CALL_OW 1
41988: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
41989: LD_ADDR_VAR 0 5
41993: PUSH
41994: LD_VAR 0 5
41998: PPUSH
41999: LD_INT 1
42001: PPUSH
42002: CALL_OW 3
42006: ST_TO_ADDR
// if not ext_list then
42007: LD_VAR 0 5
42011: NOT
42012: IFFALSE 42018
// exit ;
42014: POP
42015: POP
42016: GO 42022
// end ;
42018: GO 41893
42020: POP
42021: POP
// end ;
42022: LD_VAR 0 6
42026: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42027: LD_INT 0
42029: PPUSH
// if not mc_bases or not base or not weapon_list then
42030: LD_EXP 50
42034: NOT
42035: PUSH
42036: LD_VAR 0 1
42040: NOT
42041: OR
42042: PUSH
42043: LD_VAR 0 2
42047: NOT
42048: OR
42049: IFFALSE 42053
// exit ;
42051: GO 42078
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42053: LD_ADDR_EXP 89
42057: PUSH
42058: LD_EXP 89
42062: PPUSH
42063: LD_VAR 0 1
42067: PPUSH
42068: LD_VAR 0 2
42072: PPUSH
42073: CALL_OW 1
42077: ST_TO_ADDR
// end ;
42078: LD_VAR 0 3
42082: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42083: LD_INT 0
42085: PPUSH
// if not mc_bases or not base or not tech_list then
42086: LD_EXP 50
42090: NOT
42091: PUSH
42092: LD_VAR 0 1
42096: NOT
42097: OR
42098: PUSH
42099: LD_VAR 0 2
42103: NOT
42104: OR
42105: IFFALSE 42109
// exit ;
42107: GO 42134
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42109: LD_ADDR_EXP 77
42113: PUSH
42114: LD_EXP 77
42118: PPUSH
42119: LD_VAR 0 1
42123: PPUSH
42124: LD_VAR 0 2
42128: PPUSH
42129: CALL_OW 1
42133: ST_TO_ADDR
// end ;
42134: LD_VAR 0 3
42138: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42139: LD_INT 0
42141: PPUSH
// if not mc_bases or not parking_area or not base then
42142: LD_EXP 50
42146: NOT
42147: PUSH
42148: LD_VAR 0 2
42152: NOT
42153: OR
42154: PUSH
42155: LD_VAR 0 1
42159: NOT
42160: OR
42161: IFFALSE 42165
// exit ;
42163: GO 42190
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42165: LD_ADDR_EXP 74
42169: PUSH
42170: LD_EXP 74
42174: PPUSH
42175: LD_VAR 0 1
42179: PPUSH
42180: LD_VAR 0 2
42184: PPUSH
42185: CALL_OW 1
42189: ST_TO_ADDR
// end ;
42190: LD_VAR 0 3
42194: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42195: LD_INT 0
42197: PPUSH
// if not mc_bases or not base or not scan_area then
42198: LD_EXP 50
42202: NOT
42203: PUSH
42204: LD_VAR 0 1
42208: NOT
42209: OR
42210: PUSH
42211: LD_VAR 0 2
42215: NOT
42216: OR
42217: IFFALSE 42221
// exit ;
42219: GO 42246
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42221: LD_ADDR_EXP 75
42225: PUSH
42226: LD_EXP 75
42230: PPUSH
42231: LD_VAR 0 1
42235: PPUSH
42236: LD_VAR 0 2
42240: PPUSH
42241: CALL_OW 1
42245: ST_TO_ADDR
// end ;
42246: LD_VAR 0 3
42250: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42251: LD_INT 0
42253: PPUSH
42254: PPUSH
// if not mc_bases or not base then
42255: LD_EXP 50
42259: NOT
42260: PUSH
42261: LD_VAR 0 1
42265: NOT
42266: OR
42267: IFFALSE 42271
// exit ;
42269: GO 42335
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42271: LD_ADDR_VAR 0 3
42275: PUSH
42276: LD_INT 1
42278: PUSH
42279: LD_INT 2
42281: PUSH
42282: LD_INT 3
42284: PUSH
42285: LD_INT 4
42287: PUSH
42288: LD_INT 11
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42298: LD_ADDR_EXP 77
42302: PUSH
42303: LD_EXP 77
42307: PPUSH
42308: LD_VAR 0 1
42312: PPUSH
42313: LD_EXP 77
42317: PUSH
42318: LD_VAR 0 1
42322: ARRAY
42323: PUSH
42324: LD_VAR 0 3
42328: DIFF
42329: PPUSH
42330: CALL_OW 1
42334: ST_TO_ADDR
// end ;
42335: LD_VAR 0 2
42339: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42340: LD_INT 0
42342: PPUSH
// result := mc_vehicles [ base ] ;
42343: LD_ADDR_VAR 0 3
42347: PUSH
42348: LD_EXP 69
42352: PUSH
42353: LD_VAR 0 1
42357: ARRAY
42358: ST_TO_ADDR
// if onlyCombat then
42359: LD_VAR 0 2
42363: IFFALSE 42528
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42365: LD_ADDR_VAR 0 3
42369: PUSH
42370: LD_VAR 0 3
42374: PUSH
42375: LD_VAR 0 3
42379: PPUSH
42380: LD_INT 2
42382: PUSH
42383: LD_INT 34
42385: PUSH
42386: LD_INT 12
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 34
42395: PUSH
42396: LD_INT 51
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 34
42405: PUSH
42406: LD_EXP 94
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 34
42417: PUSH
42418: LD_INT 32
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 34
42427: PUSH
42428: LD_INT 13
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 34
42437: PUSH
42438: LD_INT 52
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 34
42447: PUSH
42448: LD_INT 14
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 34
42457: PUSH
42458: LD_INT 53
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 34
42467: PUSH
42468: LD_EXP 93
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 34
42479: PUSH
42480: LD_INT 31
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 34
42489: PUSH
42490: LD_INT 48
42492: PUSH
42493: EMPTY
42494: LIST
42495: LIST
42496: PUSH
42497: LD_INT 34
42499: PUSH
42500: LD_INT 8
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: LIST
42511: LIST
42512: LIST
42513: LIST
42514: LIST
42515: LIST
42516: LIST
42517: LIST
42518: LIST
42519: LIST
42520: LIST
42521: PPUSH
42522: CALL_OW 72
42526: DIFF
42527: ST_TO_ADDR
// end ; end_of_file
42528: LD_VAR 0 3
42532: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42533: LD_INT 0
42535: PPUSH
42536: PPUSH
42537: PPUSH
// if not mc_bases or not skirmish then
42538: LD_EXP 50
42542: NOT
42543: PUSH
42544: LD_EXP 48
42548: NOT
42549: OR
42550: IFFALSE 42554
// exit ;
42552: GO 42719
// for i = 1 to mc_bases do
42554: LD_ADDR_VAR 0 4
42558: PUSH
42559: DOUBLE
42560: LD_INT 1
42562: DEC
42563: ST_TO_ADDR
42564: LD_EXP 50
42568: PUSH
42569: FOR_TO
42570: IFFALSE 42717
// begin if sci in mc_bases [ i ] then
42572: LD_VAR 0 2
42576: PUSH
42577: LD_EXP 50
42581: PUSH
42582: LD_VAR 0 4
42586: ARRAY
42587: IN
42588: IFFALSE 42715
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42590: LD_ADDR_EXP 79
42594: PUSH
42595: LD_EXP 79
42599: PPUSH
42600: LD_VAR 0 4
42604: PUSH
42605: LD_EXP 79
42609: PUSH
42610: LD_VAR 0 4
42614: ARRAY
42615: PUSH
42616: LD_INT 1
42618: PLUS
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PPUSH
42624: LD_VAR 0 1
42628: PPUSH
42629: CALL 54503 0 3
42633: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42634: LD_ADDR_VAR 0 5
42638: PUSH
42639: LD_EXP 50
42643: PUSH
42644: LD_VAR 0 4
42648: ARRAY
42649: PPUSH
42650: LD_INT 2
42652: PUSH
42653: LD_INT 30
42655: PUSH
42656: LD_INT 0
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 30
42665: PUSH
42666: LD_INT 1
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: LIST
42677: PPUSH
42678: CALL_OW 72
42682: PPUSH
42683: LD_VAR 0 1
42687: PPUSH
42688: CALL_OW 74
42692: ST_TO_ADDR
// if tmp then
42693: LD_VAR 0 5
42697: IFFALSE 42713
// ComStandNearbyBuilding ( ape , tmp ) ;
42699: LD_VAR 0 1
42703: PPUSH
42704: LD_VAR 0 5
42708: PPUSH
42709: CALL 48706 0 2
// break ;
42713: GO 42717
// end ; end ;
42715: GO 42569
42717: POP
42718: POP
// end ;
42719: LD_VAR 0 3
42723: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42724: LD_INT 0
42726: PPUSH
42727: PPUSH
42728: PPUSH
// if not mc_bases or not skirmish then
42729: LD_EXP 50
42733: NOT
42734: PUSH
42735: LD_EXP 48
42739: NOT
42740: OR
42741: IFFALSE 42745
// exit ;
42743: GO 42834
// for i = 1 to mc_bases do
42745: LD_ADDR_VAR 0 4
42749: PUSH
42750: DOUBLE
42751: LD_INT 1
42753: DEC
42754: ST_TO_ADDR
42755: LD_EXP 50
42759: PUSH
42760: FOR_TO
42761: IFFALSE 42832
// begin if building in mc_busy_turret_list [ i ] then
42763: LD_VAR 0 1
42767: PUSH
42768: LD_EXP 60
42772: PUSH
42773: LD_VAR 0 4
42777: ARRAY
42778: IN
42779: IFFALSE 42830
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42781: LD_ADDR_VAR 0 5
42785: PUSH
42786: LD_EXP 60
42790: PUSH
42791: LD_VAR 0 4
42795: ARRAY
42796: PUSH
42797: LD_VAR 0 1
42801: DIFF
42802: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42803: LD_ADDR_EXP 60
42807: PUSH
42808: LD_EXP 60
42812: PPUSH
42813: LD_VAR 0 4
42817: PPUSH
42818: LD_VAR 0 5
42822: PPUSH
42823: CALL_OW 1
42827: ST_TO_ADDR
// break ;
42828: GO 42832
// end ; end ;
42830: GO 42760
42832: POP
42833: POP
// end ;
42834: LD_VAR 0 3
42838: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42839: LD_INT 0
42841: PPUSH
42842: PPUSH
42843: PPUSH
// if not mc_bases or not skirmish then
42844: LD_EXP 50
42848: NOT
42849: PUSH
42850: LD_EXP 48
42854: NOT
42855: OR
42856: IFFALSE 42860
// exit ;
42858: GO 43059
// for i = 1 to mc_bases do
42860: LD_ADDR_VAR 0 5
42864: PUSH
42865: DOUBLE
42866: LD_INT 1
42868: DEC
42869: ST_TO_ADDR
42870: LD_EXP 50
42874: PUSH
42875: FOR_TO
42876: IFFALSE 43057
// if building in mc_bases [ i ] then
42878: LD_VAR 0 1
42882: PUSH
42883: LD_EXP 50
42887: PUSH
42888: LD_VAR 0 5
42892: ARRAY
42893: IN
42894: IFFALSE 43055
// begin tmp := mc_bases [ i ] diff building ;
42896: LD_ADDR_VAR 0 6
42900: PUSH
42901: LD_EXP 50
42905: PUSH
42906: LD_VAR 0 5
42910: ARRAY
42911: PUSH
42912: LD_VAR 0 1
42916: DIFF
42917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
42918: LD_ADDR_EXP 50
42922: PUSH
42923: LD_EXP 50
42927: PPUSH
42928: LD_VAR 0 5
42932: PPUSH
42933: LD_VAR 0 6
42937: PPUSH
42938: CALL_OW 1
42942: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
42943: LD_VAR 0 1
42947: PUSH
42948: LD_EXP 58
42952: PUSH
42953: LD_VAR 0 5
42957: ARRAY
42958: IN
42959: IFFALSE 42998
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
42961: LD_ADDR_EXP 58
42965: PUSH
42966: LD_EXP 58
42970: PPUSH
42971: LD_VAR 0 5
42975: PPUSH
42976: LD_EXP 58
42980: PUSH
42981: LD_VAR 0 5
42985: ARRAY
42986: PUSH
42987: LD_VAR 0 1
42991: DIFF
42992: PPUSH
42993: CALL_OW 1
42997: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
42998: LD_VAR 0 1
43002: PUSH
43003: LD_EXP 59
43007: PUSH
43008: LD_VAR 0 5
43012: ARRAY
43013: IN
43014: IFFALSE 43053
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43016: LD_ADDR_EXP 59
43020: PUSH
43021: LD_EXP 59
43025: PPUSH
43026: LD_VAR 0 5
43030: PPUSH
43031: LD_EXP 59
43035: PUSH
43036: LD_VAR 0 5
43040: ARRAY
43041: PUSH
43042: LD_VAR 0 1
43046: DIFF
43047: PPUSH
43048: CALL_OW 1
43052: ST_TO_ADDR
// break ;
43053: GO 43057
// end ;
43055: GO 42875
43057: POP
43058: POP
// end ;
43059: LD_VAR 0 4
43063: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43064: LD_INT 0
43066: PPUSH
43067: PPUSH
43068: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43069: LD_EXP 50
43073: NOT
43074: PUSH
43075: LD_EXP 48
43079: NOT
43080: OR
43081: PUSH
43082: LD_VAR 0 3
43086: PUSH
43087: LD_EXP 76
43091: IN
43092: NOT
43093: OR
43094: IFFALSE 43098
// exit ;
43096: GO 43221
// for i = 1 to mc_vehicles do
43098: LD_ADDR_VAR 0 6
43102: PUSH
43103: DOUBLE
43104: LD_INT 1
43106: DEC
43107: ST_TO_ADDR
43108: LD_EXP 69
43112: PUSH
43113: FOR_TO
43114: IFFALSE 43219
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43116: LD_VAR 0 2
43120: PUSH
43121: LD_EXP 69
43125: PUSH
43126: LD_VAR 0 6
43130: ARRAY
43131: IN
43132: PUSH
43133: LD_VAR 0 1
43137: PUSH
43138: LD_EXP 69
43142: PUSH
43143: LD_VAR 0 6
43147: ARRAY
43148: IN
43149: OR
43150: IFFALSE 43217
// begin tmp := mc_vehicles [ i ] diff old ;
43152: LD_ADDR_VAR 0 7
43156: PUSH
43157: LD_EXP 69
43161: PUSH
43162: LD_VAR 0 6
43166: ARRAY
43167: PUSH
43168: LD_VAR 0 2
43172: DIFF
43173: ST_TO_ADDR
// tmp := tmp diff new ;
43174: LD_ADDR_VAR 0 7
43178: PUSH
43179: LD_VAR 0 7
43183: PUSH
43184: LD_VAR 0 1
43188: DIFF
43189: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43190: LD_ADDR_EXP 69
43194: PUSH
43195: LD_EXP 69
43199: PPUSH
43200: LD_VAR 0 6
43204: PPUSH
43205: LD_VAR 0 7
43209: PPUSH
43210: CALL_OW 1
43214: ST_TO_ADDR
// break ;
43215: GO 43219
// end ;
43217: GO 43113
43219: POP
43220: POP
// end ;
43221: LD_VAR 0 5
43225: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43226: LD_INT 0
43228: PPUSH
43229: PPUSH
43230: PPUSH
43231: PPUSH
// if not mc_bases or not skirmish then
43232: LD_EXP 50
43236: NOT
43237: PUSH
43238: LD_EXP 48
43242: NOT
43243: OR
43244: IFFALSE 43248
// exit ;
43246: GO 43625
// side := GetSide ( vehicle ) ;
43248: LD_ADDR_VAR 0 5
43252: PUSH
43253: LD_VAR 0 1
43257: PPUSH
43258: CALL_OW 255
43262: ST_TO_ADDR
// for i = 1 to mc_bases do
43263: LD_ADDR_VAR 0 4
43267: PUSH
43268: DOUBLE
43269: LD_INT 1
43271: DEC
43272: ST_TO_ADDR
43273: LD_EXP 50
43277: PUSH
43278: FOR_TO
43279: IFFALSE 43623
// begin if factory in mc_bases [ i ] then
43281: LD_VAR 0 2
43285: PUSH
43286: LD_EXP 50
43290: PUSH
43291: LD_VAR 0 4
43295: ARRAY
43296: IN
43297: IFFALSE 43621
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43299: LD_EXP 72
43303: PUSH
43304: LD_VAR 0 4
43308: ARRAY
43309: PUSH
43310: LD_EXP 61
43314: PUSH
43315: LD_VAR 0 4
43319: ARRAY
43320: LESS
43321: PUSH
43322: LD_VAR 0 1
43326: PPUSH
43327: CALL_OW 264
43331: PUSH
43332: LD_INT 31
43334: PUSH
43335: LD_INT 32
43337: PUSH
43338: LD_INT 51
43340: PUSH
43341: LD_EXP 94
43345: PUSH
43346: LD_INT 12
43348: PUSH
43349: LD_INT 30
43351: PUSH
43352: LD_EXP 93
43356: PUSH
43357: LD_INT 11
43359: PUSH
43360: LD_INT 53
43362: PUSH
43363: LD_INT 14
43365: PUSH
43366: LD_EXP 97
43370: PUSH
43371: LD_INT 29
43373: PUSH
43374: LD_EXP 95
43378: PUSH
43379: LD_INT 13
43381: PUSH
43382: LD_INT 52
43384: PUSH
43385: LD_INT 48
43387: PUSH
43388: LD_INT 8
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: LIST
43408: LIST
43409: IN
43410: NOT
43411: AND
43412: IFFALSE 43460
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43414: LD_ADDR_EXP 72
43418: PUSH
43419: LD_EXP 72
43423: PPUSH
43424: LD_VAR 0 4
43428: PUSH
43429: LD_EXP 72
43433: PUSH
43434: LD_VAR 0 4
43438: ARRAY
43439: PUSH
43440: LD_INT 1
43442: PLUS
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PPUSH
43448: LD_VAR 0 1
43452: PPUSH
43453: CALL 54503 0 3
43457: ST_TO_ADDR
43458: GO 43504
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43460: LD_ADDR_EXP 69
43464: PUSH
43465: LD_EXP 69
43469: PPUSH
43470: LD_VAR 0 4
43474: PUSH
43475: LD_EXP 69
43479: PUSH
43480: LD_VAR 0 4
43484: ARRAY
43485: PUSH
43486: LD_INT 1
43488: PLUS
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PPUSH
43494: LD_VAR 0 1
43498: PPUSH
43499: CALL 54503 0 3
43503: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43504: LD_VAR 0 1
43508: PPUSH
43509: CALL_OW 263
43513: PUSH
43514: LD_INT 2
43516: EQUAL
43517: IFFALSE 43537
// begin repeat wait ( 0 0$1 ) ;
43519: LD_INT 35
43521: PPUSH
43522: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43526: LD_VAR 0 1
43530: PPUSH
43531: CALL_OW 312
43535: IFFALSE 43519
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43537: LD_VAR 0 1
43541: PPUSH
43542: LD_EXP 74
43546: PUSH
43547: LD_VAR 0 4
43551: ARRAY
43552: PPUSH
43553: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43557: LD_VAR 0 1
43561: PPUSH
43562: CALL_OW 263
43566: PUSH
43567: LD_INT 1
43569: NONEQUAL
43570: IFFALSE 43574
// break ;
43572: GO 43623
// repeat wait ( 0 0$1 ) ;
43574: LD_INT 35
43576: PPUSH
43577: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43581: LD_VAR 0 1
43585: PPUSH
43586: LD_EXP 74
43590: PUSH
43591: LD_VAR 0 4
43595: ARRAY
43596: PPUSH
43597: CALL_OW 308
43601: IFFALSE 43574
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43603: LD_VAR 0 1
43607: PPUSH
43608: CALL_OW 311
43612: PPUSH
43613: CALL_OW 121
// exit ;
43617: POP
43618: POP
43619: GO 43625
// end ; end ;
43621: GO 43278
43623: POP
43624: POP
// end ;
43625: LD_VAR 0 3
43629: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43630: LD_INT 0
43632: PPUSH
43633: PPUSH
43634: PPUSH
43635: PPUSH
// if not mc_bases or not skirmish then
43636: LD_EXP 50
43640: NOT
43641: PUSH
43642: LD_EXP 48
43646: NOT
43647: OR
43648: IFFALSE 43652
// exit ;
43650: GO 44005
// repeat wait ( 0 0$1 ) ;
43652: LD_INT 35
43654: PPUSH
43655: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43659: LD_VAR 0 2
43663: PPUSH
43664: LD_VAR 0 3
43668: PPUSH
43669: CALL_OW 284
43673: IFFALSE 43652
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43675: LD_VAR 0 2
43679: PPUSH
43680: LD_VAR 0 3
43684: PPUSH
43685: CALL_OW 283
43689: PUSH
43690: LD_INT 4
43692: EQUAL
43693: IFFALSE 43697
// exit ;
43695: GO 44005
// for i = 1 to mc_bases do
43697: LD_ADDR_VAR 0 7
43701: PUSH
43702: DOUBLE
43703: LD_INT 1
43705: DEC
43706: ST_TO_ADDR
43707: LD_EXP 50
43711: PUSH
43712: FOR_TO
43713: IFFALSE 44003
// begin if mc_crates_area [ i ] then
43715: LD_EXP 68
43719: PUSH
43720: LD_VAR 0 7
43724: ARRAY
43725: IFFALSE 43836
// for j in mc_crates_area [ i ] do
43727: LD_ADDR_VAR 0 8
43731: PUSH
43732: LD_EXP 68
43736: PUSH
43737: LD_VAR 0 7
43741: ARRAY
43742: PUSH
43743: FOR_IN
43744: IFFALSE 43834
// if InArea ( x , y , j ) then
43746: LD_VAR 0 2
43750: PPUSH
43751: LD_VAR 0 3
43755: PPUSH
43756: LD_VAR 0 8
43760: PPUSH
43761: CALL_OW 309
43765: IFFALSE 43832
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43767: LD_ADDR_EXP 66
43771: PUSH
43772: LD_EXP 66
43776: PPUSH
43777: LD_VAR 0 7
43781: PUSH
43782: LD_EXP 66
43786: PUSH
43787: LD_VAR 0 7
43791: ARRAY
43792: PUSH
43793: LD_INT 1
43795: PLUS
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PPUSH
43801: LD_VAR 0 4
43805: PUSH
43806: LD_VAR 0 2
43810: PUSH
43811: LD_VAR 0 3
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: LIST
43820: PPUSH
43821: CALL 54503 0 3
43825: ST_TO_ADDR
// exit ;
43826: POP
43827: POP
43828: POP
43829: POP
43830: GO 44005
// end ;
43832: GO 43743
43834: POP
43835: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43836: LD_ADDR_VAR 0 9
43840: PUSH
43841: LD_EXP 50
43845: PUSH
43846: LD_VAR 0 7
43850: ARRAY
43851: PPUSH
43852: LD_INT 2
43854: PUSH
43855: LD_INT 30
43857: PUSH
43858: LD_INT 0
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 30
43867: PUSH
43868: LD_INT 1
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: LIST
43879: PPUSH
43880: CALL_OW 72
43884: ST_TO_ADDR
// if not depot then
43885: LD_VAR 0 9
43889: NOT
43890: IFFALSE 43894
// continue ;
43892: GO 43712
// for j in depot do
43894: LD_ADDR_VAR 0 8
43898: PUSH
43899: LD_VAR 0 9
43903: PUSH
43904: FOR_IN
43905: IFFALSE 43999
// if GetDistUnitXY ( j , x , y ) < 30 then
43907: LD_VAR 0 8
43911: PPUSH
43912: LD_VAR 0 2
43916: PPUSH
43917: LD_VAR 0 3
43921: PPUSH
43922: CALL_OW 297
43926: PUSH
43927: LD_INT 30
43929: LESS
43930: IFFALSE 43997
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43932: LD_ADDR_EXP 66
43936: PUSH
43937: LD_EXP 66
43941: PPUSH
43942: LD_VAR 0 7
43946: PUSH
43947: LD_EXP 66
43951: PUSH
43952: LD_VAR 0 7
43956: ARRAY
43957: PUSH
43958: LD_INT 1
43960: PLUS
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PPUSH
43966: LD_VAR 0 4
43970: PUSH
43971: LD_VAR 0 2
43975: PUSH
43976: LD_VAR 0 3
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: LIST
43985: PPUSH
43986: CALL 54503 0 3
43990: ST_TO_ADDR
// exit ;
43991: POP
43992: POP
43993: POP
43994: POP
43995: GO 44005
// end ;
43997: GO 43904
43999: POP
44000: POP
// end ;
44001: GO 43712
44003: POP
44004: POP
// end ;
44005: LD_VAR 0 6
44009: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44010: LD_INT 0
44012: PPUSH
44013: PPUSH
44014: PPUSH
44015: PPUSH
// if not mc_bases or not skirmish then
44016: LD_EXP 50
44020: NOT
44021: PUSH
44022: LD_EXP 48
44026: NOT
44027: OR
44028: IFFALSE 44032
// exit ;
44030: GO 44309
// side := GetSide ( lab ) ;
44032: LD_ADDR_VAR 0 4
44036: PUSH
44037: LD_VAR 0 2
44041: PPUSH
44042: CALL_OW 255
44046: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44047: LD_VAR 0 4
44051: PUSH
44052: LD_EXP 76
44056: IN
44057: NOT
44058: PUSH
44059: LD_EXP 77
44063: NOT
44064: OR
44065: PUSH
44066: LD_EXP 50
44070: NOT
44071: OR
44072: IFFALSE 44076
// exit ;
44074: GO 44309
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44076: LD_ADDR_EXP 77
44080: PUSH
44081: LD_EXP 77
44085: PPUSH
44086: LD_VAR 0 4
44090: PPUSH
44091: LD_EXP 77
44095: PUSH
44096: LD_VAR 0 4
44100: ARRAY
44101: PUSH
44102: LD_VAR 0 1
44106: DIFF
44107: PPUSH
44108: CALL_OW 1
44112: ST_TO_ADDR
// for i = 1 to mc_bases do
44113: LD_ADDR_VAR 0 5
44117: PUSH
44118: DOUBLE
44119: LD_INT 1
44121: DEC
44122: ST_TO_ADDR
44123: LD_EXP 50
44127: PUSH
44128: FOR_TO
44129: IFFALSE 44307
// begin if lab in mc_bases [ i ] then
44131: LD_VAR 0 2
44135: PUSH
44136: LD_EXP 50
44140: PUSH
44141: LD_VAR 0 5
44145: ARRAY
44146: IN
44147: IFFALSE 44305
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44149: LD_VAR 0 1
44153: PUSH
44154: LD_INT 11
44156: PUSH
44157: LD_INT 4
44159: PUSH
44160: LD_INT 3
44162: PUSH
44163: LD_INT 2
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: LIST
44170: LIST
44171: IN
44172: PUSH
44173: LD_EXP 80
44177: PUSH
44178: LD_VAR 0 5
44182: ARRAY
44183: AND
44184: IFFALSE 44305
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44186: LD_ADDR_VAR 0 6
44190: PUSH
44191: LD_EXP 80
44195: PUSH
44196: LD_VAR 0 5
44200: ARRAY
44201: PUSH
44202: LD_INT 1
44204: ARRAY
44205: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44206: LD_ADDR_EXP 80
44210: PUSH
44211: LD_EXP 80
44215: PPUSH
44216: LD_VAR 0 5
44220: PPUSH
44221: EMPTY
44222: PPUSH
44223: CALL_OW 1
44227: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44228: LD_VAR 0 6
44232: PPUSH
44233: LD_INT 0
44235: PPUSH
44236: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44240: LD_VAR 0 6
44244: PPUSH
44245: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44249: LD_ADDR_EXP 79
44253: PUSH
44254: LD_EXP 79
44258: PPUSH
44259: LD_VAR 0 5
44263: PPUSH
44264: LD_EXP 79
44268: PUSH
44269: LD_VAR 0 5
44273: ARRAY
44274: PPUSH
44275: LD_INT 1
44277: PPUSH
44278: LD_VAR 0 6
44282: PPUSH
44283: CALL_OW 2
44287: PPUSH
44288: CALL_OW 1
44292: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44293: LD_VAR 0 5
44297: PPUSH
44298: LD_INT 112
44300: PPUSH
44301: CALL 21305 0 2
// end ; end ; end ;
44305: GO 44128
44307: POP
44308: POP
// end ;
44309: LD_VAR 0 3
44313: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44314: LD_INT 0
44316: PPUSH
44317: PPUSH
44318: PPUSH
44319: PPUSH
44320: PPUSH
44321: PPUSH
44322: PPUSH
44323: PPUSH
// if not mc_bases or not skirmish then
44324: LD_EXP 50
44328: NOT
44329: PUSH
44330: LD_EXP 48
44334: NOT
44335: OR
44336: IFFALSE 44340
// exit ;
44338: GO 45711
// for i = 1 to mc_bases do
44340: LD_ADDR_VAR 0 3
44344: PUSH
44345: DOUBLE
44346: LD_INT 1
44348: DEC
44349: ST_TO_ADDR
44350: LD_EXP 50
44354: PUSH
44355: FOR_TO
44356: IFFALSE 45709
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44358: LD_VAR 0 1
44362: PUSH
44363: LD_EXP 50
44367: PUSH
44368: LD_VAR 0 3
44372: ARRAY
44373: IN
44374: PUSH
44375: LD_VAR 0 1
44379: PUSH
44380: LD_EXP 57
44384: PUSH
44385: LD_VAR 0 3
44389: ARRAY
44390: IN
44391: OR
44392: PUSH
44393: LD_VAR 0 1
44397: PUSH
44398: LD_EXP 72
44402: PUSH
44403: LD_VAR 0 3
44407: ARRAY
44408: IN
44409: OR
44410: PUSH
44411: LD_VAR 0 1
44415: PUSH
44416: LD_EXP 69
44420: PUSH
44421: LD_VAR 0 3
44425: ARRAY
44426: IN
44427: OR
44428: PUSH
44429: LD_VAR 0 1
44433: PUSH
44434: LD_EXP 79
44438: PUSH
44439: LD_VAR 0 3
44443: ARRAY
44444: IN
44445: OR
44446: PUSH
44447: LD_VAR 0 1
44451: PUSH
44452: LD_EXP 80
44456: PUSH
44457: LD_VAR 0 3
44461: ARRAY
44462: IN
44463: OR
44464: IFFALSE 45707
// begin if un in mc_ape [ i ] then
44466: LD_VAR 0 1
44470: PUSH
44471: LD_EXP 79
44475: PUSH
44476: LD_VAR 0 3
44480: ARRAY
44481: IN
44482: IFFALSE 44521
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44484: LD_ADDR_EXP 79
44488: PUSH
44489: LD_EXP 79
44493: PPUSH
44494: LD_VAR 0 3
44498: PPUSH
44499: LD_EXP 79
44503: PUSH
44504: LD_VAR 0 3
44508: ARRAY
44509: PUSH
44510: LD_VAR 0 1
44514: DIFF
44515: PPUSH
44516: CALL_OW 1
44520: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44521: LD_VAR 0 1
44525: PUSH
44526: LD_EXP 80
44530: PUSH
44531: LD_VAR 0 3
44535: ARRAY
44536: IN
44537: IFFALSE 44561
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44539: LD_ADDR_EXP 80
44543: PUSH
44544: LD_EXP 80
44548: PPUSH
44549: LD_VAR 0 3
44553: PPUSH
44554: EMPTY
44555: PPUSH
44556: CALL_OW 1
44560: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44561: LD_VAR 0 1
44565: PPUSH
44566: CALL_OW 247
44570: PUSH
44571: LD_INT 2
44573: EQUAL
44574: PUSH
44575: LD_VAR 0 1
44579: PPUSH
44580: CALL_OW 110
44584: PUSH
44585: LD_INT 20
44587: EQUAL
44588: PUSH
44589: LD_VAR 0 1
44593: PUSH
44594: LD_EXP 72
44598: PUSH
44599: LD_VAR 0 3
44603: ARRAY
44604: IN
44605: OR
44606: PUSH
44607: LD_VAR 0 1
44611: PPUSH
44612: CALL_OW 264
44616: PUSH
44617: LD_INT 12
44619: PUSH
44620: LD_INT 51
44622: PUSH
44623: LD_EXP 94
44627: PUSH
44628: LD_INT 32
44630: PUSH
44631: LD_INT 13
44633: PUSH
44634: LD_INT 52
44636: PUSH
44637: LD_INT 31
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: LIST
44644: LIST
44645: LIST
44646: LIST
44647: LIST
44648: IN
44649: OR
44650: AND
44651: IFFALSE 44959
// begin if un in mc_defender [ i ] then
44653: LD_VAR 0 1
44657: PUSH
44658: LD_EXP 72
44662: PUSH
44663: LD_VAR 0 3
44667: ARRAY
44668: IN
44669: IFFALSE 44708
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44671: LD_ADDR_EXP 72
44675: PUSH
44676: LD_EXP 72
44680: PPUSH
44681: LD_VAR 0 3
44685: PPUSH
44686: LD_EXP 72
44690: PUSH
44691: LD_VAR 0 3
44695: ARRAY
44696: PUSH
44697: LD_VAR 0 1
44701: DIFF
44702: PPUSH
44703: CALL_OW 1
44707: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44708: LD_ADDR_VAR 0 8
44712: PUSH
44713: LD_VAR 0 3
44717: PPUSH
44718: LD_INT 3
44720: PPUSH
44721: CALL 41377 0 2
44725: ST_TO_ADDR
// if fac then
44726: LD_VAR 0 8
44730: IFFALSE 44959
// begin for j in fac do
44732: LD_ADDR_VAR 0 4
44736: PUSH
44737: LD_VAR 0 8
44741: PUSH
44742: FOR_IN
44743: IFFALSE 44957
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44745: LD_ADDR_VAR 0 9
44749: PUSH
44750: LD_VAR 0 8
44754: PPUSH
44755: LD_VAR 0 1
44759: PPUSH
44760: CALL_OW 265
44764: PPUSH
44765: LD_VAR 0 1
44769: PPUSH
44770: CALL_OW 262
44774: PPUSH
44775: LD_VAR 0 1
44779: PPUSH
44780: CALL_OW 263
44784: PPUSH
44785: LD_VAR 0 1
44789: PPUSH
44790: CALL_OW 264
44794: PPUSH
44795: CALL 52035 0 5
44799: ST_TO_ADDR
// if components then
44800: LD_VAR 0 9
44804: IFFALSE 44955
// begin if GetWeapon ( un ) = ar_control_tower then
44806: LD_VAR 0 1
44810: PPUSH
44811: CALL_OW 264
44815: PUSH
44816: LD_INT 31
44818: EQUAL
44819: IFFALSE 44936
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44821: LD_VAR 0 1
44825: PPUSH
44826: CALL_OW 311
44830: PPUSH
44831: LD_INT 0
44833: PPUSH
44834: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44838: LD_ADDR_EXP 90
44842: PUSH
44843: LD_EXP 90
44847: PPUSH
44848: LD_VAR 0 3
44852: PPUSH
44853: LD_EXP 90
44857: PUSH
44858: LD_VAR 0 3
44862: ARRAY
44863: PUSH
44864: LD_VAR 0 1
44868: PPUSH
44869: CALL_OW 311
44873: DIFF
44874: PPUSH
44875: CALL_OW 1
44879: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
44880: LD_ADDR_VAR 0 7
44884: PUSH
44885: LD_EXP 71
44889: PUSH
44890: LD_VAR 0 3
44894: ARRAY
44895: PPUSH
44896: LD_INT 1
44898: PPUSH
44899: LD_VAR 0 9
44903: PPUSH
44904: CALL_OW 2
44908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
44909: LD_ADDR_EXP 71
44913: PUSH
44914: LD_EXP 71
44918: PPUSH
44919: LD_VAR 0 3
44923: PPUSH
44924: LD_VAR 0 7
44928: PPUSH
44929: CALL_OW 1
44933: ST_TO_ADDR
// end else
44934: GO 44953
// MC_InsertProduceList ( i , [ components ] ) ;
44936: LD_VAR 0 3
44940: PPUSH
44941: LD_VAR 0 9
44945: PUSH
44946: EMPTY
44947: LIST
44948: PPUSH
44949: CALL 40922 0 2
// break ;
44953: GO 44957
// end ; end ;
44955: GO 44742
44957: POP
44958: POP
// end ; end ; if GetType ( un ) = unit_building then
44959: LD_VAR 0 1
44963: PPUSH
44964: CALL_OW 247
44968: PUSH
44969: LD_INT 3
44971: EQUAL
44972: IFFALSE 45375
// begin btype := GetBType ( un ) ;
44974: LD_ADDR_VAR 0 5
44978: PUSH
44979: LD_VAR 0 1
44983: PPUSH
44984: CALL_OW 266
44988: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
44989: LD_VAR 0 5
44993: PUSH
44994: LD_INT 29
44996: PUSH
44997: LD_INT 30
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: IN
45004: IFFALSE 45077
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45006: LD_VAR 0 1
45010: PPUSH
45011: CALL_OW 250
45015: PPUSH
45016: LD_VAR 0 1
45020: PPUSH
45021: CALL_OW 251
45025: PPUSH
45026: LD_VAR 0 1
45030: PPUSH
45031: CALL_OW 255
45035: PPUSH
45036: CALL_OW 440
45040: NOT
45041: IFFALSE 45077
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45043: LD_VAR 0 1
45047: PPUSH
45048: CALL_OW 250
45052: PPUSH
45053: LD_VAR 0 1
45057: PPUSH
45058: CALL_OW 251
45062: PPUSH
45063: LD_VAR 0 1
45067: PPUSH
45068: CALL_OW 255
45072: PPUSH
45073: CALL_OW 441
// end ; if btype = b_warehouse then
45077: LD_VAR 0 5
45081: PUSH
45082: LD_INT 1
45084: EQUAL
45085: IFFALSE 45103
// begin btype := b_depot ;
45087: LD_ADDR_VAR 0 5
45091: PUSH
45092: LD_INT 0
45094: ST_TO_ADDR
// pos := 1 ;
45095: LD_ADDR_VAR 0 6
45099: PUSH
45100: LD_INT 1
45102: ST_TO_ADDR
// end ; if btype = b_factory then
45103: LD_VAR 0 5
45107: PUSH
45108: LD_INT 3
45110: EQUAL
45111: IFFALSE 45129
// begin btype := b_workshop ;
45113: LD_ADDR_VAR 0 5
45117: PUSH
45118: LD_INT 2
45120: ST_TO_ADDR
// pos := 1 ;
45121: LD_ADDR_VAR 0 6
45125: PUSH
45126: LD_INT 1
45128: ST_TO_ADDR
// end ; if btype = b_barracks then
45129: LD_VAR 0 5
45133: PUSH
45134: LD_INT 5
45136: EQUAL
45137: IFFALSE 45147
// btype := b_armoury ;
45139: LD_ADDR_VAR 0 5
45143: PUSH
45144: LD_INT 4
45146: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45147: LD_VAR 0 5
45151: PUSH
45152: LD_INT 7
45154: PUSH
45155: LD_INT 8
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: IN
45162: IFFALSE 45172
// btype := b_lab ;
45164: LD_ADDR_VAR 0 5
45168: PUSH
45169: LD_INT 6
45171: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45172: LD_ADDR_EXP 55
45176: PUSH
45177: LD_EXP 55
45181: PPUSH
45182: LD_VAR 0 3
45186: PUSH
45187: LD_EXP 55
45191: PUSH
45192: LD_VAR 0 3
45196: ARRAY
45197: PUSH
45198: LD_INT 1
45200: PLUS
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: PPUSH
45206: LD_VAR 0 5
45210: PUSH
45211: LD_VAR 0 1
45215: PPUSH
45216: CALL_OW 250
45220: PUSH
45221: LD_VAR 0 1
45225: PPUSH
45226: CALL_OW 251
45230: PUSH
45231: LD_VAR 0 1
45235: PPUSH
45236: CALL_OW 254
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: PPUSH
45247: CALL 54503 0 3
45251: ST_TO_ADDR
// if pos = 1 then
45252: LD_VAR 0 6
45256: PUSH
45257: LD_INT 1
45259: EQUAL
45260: IFFALSE 45375
// begin tmp := mc_build_list [ i ] ;
45262: LD_ADDR_VAR 0 7
45266: PUSH
45267: LD_EXP 55
45271: PUSH
45272: LD_VAR 0 3
45276: ARRAY
45277: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45278: LD_VAR 0 7
45282: PPUSH
45283: LD_INT 2
45285: PUSH
45286: LD_INT 30
45288: PUSH
45289: LD_INT 0
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: PUSH
45296: LD_INT 30
45298: PUSH
45299: LD_INT 1
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: LIST
45310: PPUSH
45311: CALL_OW 72
45315: IFFALSE 45325
// pos := 2 ;
45317: LD_ADDR_VAR 0 6
45321: PUSH
45322: LD_INT 2
45324: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45325: LD_ADDR_VAR 0 7
45329: PUSH
45330: LD_VAR 0 7
45334: PPUSH
45335: LD_VAR 0 6
45339: PPUSH
45340: LD_VAR 0 7
45344: PPUSH
45345: CALL 54829 0 3
45349: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45350: LD_ADDR_EXP 55
45354: PUSH
45355: LD_EXP 55
45359: PPUSH
45360: LD_VAR 0 3
45364: PPUSH
45365: LD_VAR 0 7
45369: PPUSH
45370: CALL_OW 1
45374: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45375: LD_VAR 0 1
45379: PUSH
45380: LD_EXP 50
45384: PUSH
45385: LD_VAR 0 3
45389: ARRAY
45390: IN
45391: IFFALSE 45430
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45393: LD_ADDR_EXP 50
45397: PUSH
45398: LD_EXP 50
45402: PPUSH
45403: LD_VAR 0 3
45407: PPUSH
45408: LD_EXP 50
45412: PUSH
45413: LD_VAR 0 3
45417: ARRAY
45418: PUSH
45419: LD_VAR 0 1
45423: DIFF
45424: PPUSH
45425: CALL_OW 1
45429: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45430: LD_VAR 0 1
45434: PUSH
45435: LD_EXP 57
45439: PUSH
45440: LD_VAR 0 3
45444: ARRAY
45445: IN
45446: IFFALSE 45485
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45448: LD_ADDR_EXP 57
45452: PUSH
45453: LD_EXP 57
45457: PPUSH
45458: LD_VAR 0 3
45462: PPUSH
45463: LD_EXP 57
45467: PUSH
45468: LD_VAR 0 3
45472: ARRAY
45473: PUSH
45474: LD_VAR 0 1
45478: DIFF
45479: PPUSH
45480: CALL_OW 1
45484: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45485: LD_VAR 0 1
45489: PUSH
45490: LD_EXP 69
45494: PUSH
45495: LD_VAR 0 3
45499: ARRAY
45500: IN
45501: IFFALSE 45540
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45503: LD_ADDR_EXP 69
45507: PUSH
45508: LD_EXP 69
45512: PPUSH
45513: LD_VAR 0 3
45517: PPUSH
45518: LD_EXP 69
45522: PUSH
45523: LD_VAR 0 3
45527: ARRAY
45528: PUSH
45529: LD_VAR 0 1
45533: DIFF
45534: PPUSH
45535: CALL_OW 1
45539: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45540: LD_VAR 0 1
45544: PUSH
45545: LD_EXP 72
45549: PUSH
45550: LD_VAR 0 3
45554: ARRAY
45555: IN
45556: IFFALSE 45595
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45558: LD_ADDR_EXP 72
45562: PUSH
45563: LD_EXP 72
45567: PPUSH
45568: LD_VAR 0 3
45572: PPUSH
45573: LD_EXP 72
45577: PUSH
45578: LD_VAR 0 3
45582: ARRAY
45583: PUSH
45584: LD_VAR 0 1
45588: DIFF
45589: PPUSH
45590: CALL_OW 1
45594: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45595: LD_VAR 0 1
45599: PUSH
45600: LD_EXP 59
45604: PUSH
45605: LD_VAR 0 3
45609: ARRAY
45610: IN
45611: IFFALSE 45650
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45613: LD_ADDR_EXP 59
45617: PUSH
45618: LD_EXP 59
45622: PPUSH
45623: LD_VAR 0 3
45627: PPUSH
45628: LD_EXP 59
45632: PUSH
45633: LD_VAR 0 3
45637: ARRAY
45638: PUSH
45639: LD_VAR 0 1
45643: DIFF
45644: PPUSH
45645: CALL_OW 1
45649: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45650: LD_VAR 0 1
45654: PUSH
45655: LD_EXP 58
45659: PUSH
45660: LD_VAR 0 3
45664: ARRAY
45665: IN
45666: IFFALSE 45705
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45668: LD_ADDR_EXP 58
45672: PUSH
45673: LD_EXP 58
45677: PPUSH
45678: LD_VAR 0 3
45682: PPUSH
45683: LD_EXP 58
45687: PUSH
45688: LD_VAR 0 3
45692: ARRAY
45693: PUSH
45694: LD_VAR 0 1
45698: DIFF
45699: PPUSH
45700: CALL_OW 1
45704: ST_TO_ADDR
// end ; break ;
45705: GO 45709
// end ;
45707: GO 44355
45709: POP
45710: POP
// end ;
45711: LD_VAR 0 2
45715: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45716: LD_INT 0
45718: PPUSH
45719: PPUSH
45720: PPUSH
// if not mc_bases or not skirmish then
45721: LD_EXP 50
45725: NOT
45726: PUSH
45727: LD_EXP 48
45731: NOT
45732: OR
45733: IFFALSE 45737
// exit ;
45735: GO 45952
// for i = 1 to mc_bases do
45737: LD_ADDR_VAR 0 3
45741: PUSH
45742: DOUBLE
45743: LD_INT 1
45745: DEC
45746: ST_TO_ADDR
45747: LD_EXP 50
45751: PUSH
45752: FOR_TO
45753: IFFALSE 45950
// begin if building in mc_construct_list [ i ] then
45755: LD_VAR 0 1
45759: PUSH
45760: LD_EXP 57
45764: PUSH
45765: LD_VAR 0 3
45769: ARRAY
45770: IN
45771: IFFALSE 45948
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45773: LD_ADDR_EXP 57
45777: PUSH
45778: LD_EXP 57
45782: PPUSH
45783: LD_VAR 0 3
45787: PPUSH
45788: LD_EXP 57
45792: PUSH
45793: LD_VAR 0 3
45797: ARRAY
45798: PUSH
45799: LD_VAR 0 1
45803: DIFF
45804: PPUSH
45805: CALL_OW 1
45809: ST_TO_ADDR
// if building in mc_lab [ i ] then
45810: LD_VAR 0 1
45814: PUSH
45815: LD_EXP 83
45819: PUSH
45820: LD_VAR 0 3
45824: ARRAY
45825: IN
45826: IFFALSE 45881
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45828: LD_ADDR_EXP 84
45832: PUSH
45833: LD_EXP 84
45837: PPUSH
45838: LD_VAR 0 3
45842: PPUSH
45843: LD_EXP 84
45847: PUSH
45848: LD_VAR 0 3
45852: ARRAY
45853: PPUSH
45854: LD_INT 1
45856: PPUSH
45857: LD_EXP 84
45861: PUSH
45862: LD_VAR 0 3
45866: ARRAY
45867: PPUSH
45868: LD_INT 0
45870: PPUSH
45871: CALL 53921 0 4
45875: PPUSH
45876: CALL_OW 1
45880: ST_TO_ADDR
// if not building in mc_bases [ i ] then
45881: LD_VAR 0 1
45885: PUSH
45886: LD_EXP 50
45890: PUSH
45891: LD_VAR 0 3
45895: ARRAY
45896: IN
45897: NOT
45898: IFFALSE 45944
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45900: LD_ADDR_EXP 50
45904: PUSH
45905: LD_EXP 50
45909: PPUSH
45910: LD_VAR 0 3
45914: PUSH
45915: LD_EXP 50
45919: PUSH
45920: LD_VAR 0 3
45924: ARRAY
45925: PUSH
45926: LD_INT 1
45928: PLUS
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PPUSH
45934: LD_VAR 0 1
45938: PPUSH
45939: CALL 54503 0 3
45943: ST_TO_ADDR
// exit ;
45944: POP
45945: POP
45946: GO 45952
// end ; end ;
45948: GO 45752
45950: POP
45951: POP
// end ;
45952: LD_VAR 0 2
45956: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
45957: LD_INT 0
45959: PPUSH
45960: PPUSH
45961: PPUSH
45962: PPUSH
45963: PPUSH
45964: PPUSH
45965: PPUSH
// if not mc_bases or not skirmish then
45966: LD_EXP 50
45970: NOT
45971: PUSH
45972: LD_EXP 48
45976: NOT
45977: OR
45978: IFFALSE 45982
// exit ;
45980: GO 46643
// for i = 1 to mc_bases do
45982: LD_ADDR_VAR 0 3
45986: PUSH
45987: DOUBLE
45988: LD_INT 1
45990: DEC
45991: ST_TO_ADDR
45992: LD_EXP 50
45996: PUSH
45997: FOR_TO
45998: IFFALSE 46641
// begin if building in mc_construct_list [ i ] then
46000: LD_VAR 0 1
46004: PUSH
46005: LD_EXP 57
46009: PUSH
46010: LD_VAR 0 3
46014: ARRAY
46015: IN
46016: IFFALSE 46639
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46018: LD_ADDR_EXP 57
46022: PUSH
46023: LD_EXP 57
46027: PPUSH
46028: LD_VAR 0 3
46032: PPUSH
46033: LD_EXP 57
46037: PUSH
46038: LD_VAR 0 3
46042: ARRAY
46043: PUSH
46044: LD_VAR 0 1
46048: DIFF
46049: PPUSH
46050: CALL_OW 1
46054: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46055: LD_ADDR_EXP 50
46059: PUSH
46060: LD_EXP 50
46064: PPUSH
46065: LD_VAR 0 3
46069: PUSH
46070: LD_EXP 50
46074: PUSH
46075: LD_VAR 0 3
46079: ARRAY
46080: PUSH
46081: LD_INT 1
46083: PLUS
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PPUSH
46089: LD_VAR 0 1
46093: PPUSH
46094: CALL 54503 0 3
46098: ST_TO_ADDR
// btype := GetBType ( building ) ;
46099: LD_ADDR_VAR 0 5
46103: PUSH
46104: LD_VAR 0 1
46108: PPUSH
46109: CALL_OW 266
46113: ST_TO_ADDR
// side := GetSide ( building ) ;
46114: LD_ADDR_VAR 0 8
46118: PUSH
46119: LD_VAR 0 1
46123: PPUSH
46124: CALL_OW 255
46128: ST_TO_ADDR
// if btype = b_lab then
46129: LD_VAR 0 5
46133: PUSH
46134: LD_INT 6
46136: EQUAL
46137: IFFALSE 46187
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46139: LD_ADDR_EXP 83
46143: PUSH
46144: LD_EXP 83
46148: PPUSH
46149: LD_VAR 0 3
46153: PUSH
46154: LD_EXP 83
46158: PUSH
46159: LD_VAR 0 3
46163: ARRAY
46164: PUSH
46165: LD_INT 1
46167: PLUS
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: PPUSH
46173: LD_VAR 0 1
46177: PPUSH
46178: CALL 54503 0 3
46182: ST_TO_ADDR
// exit ;
46183: POP
46184: POP
46185: GO 46643
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46187: LD_VAR 0 5
46191: PUSH
46192: LD_INT 0
46194: PUSH
46195: LD_INT 2
46197: PUSH
46198: LD_INT 4
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: LIST
46205: IN
46206: IFFALSE 46330
// begin if btype = b_armoury then
46208: LD_VAR 0 5
46212: PUSH
46213: LD_INT 4
46215: EQUAL
46216: IFFALSE 46226
// btype := b_barracks ;
46218: LD_ADDR_VAR 0 5
46222: PUSH
46223: LD_INT 5
46225: ST_TO_ADDR
// if btype = b_depot then
46226: LD_VAR 0 5
46230: PUSH
46231: LD_INT 0
46233: EQUAL
46234: IFFALSE 46244
// btype := b_warehouse ;
46236: LD_ADDR_VAR 0 5
46240: PUSH
46241: LD_INT 1
46243: ST_TO_ADDR
// if btype = b_workshop then
46244: LD_VAR 0 5
46248: PUSH
46249: LD_INT 2
46251: EQUAL
46252: IFFALSE 46262
// btype := b_factory ;
46254: LD_ADDR_VAR 0 5
46258: PUSH
46259: LD_INT 3
46261: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46262: LD_VAR 0 5
46266: PPUSH
46267: LD_VAR 0 8
46271: PPUSH
46272: CALL_OW 323
46276: PUSH
46277: LD_INT 1
46279: EQUAL
46280: IFFALSE 46326
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46282: LD_ADDR_EXP 82
46286: PUSH
46287: LD_EXP 82
46291: PPUSH
46292: LD_VAR 0 3
46296: PUSH
46297: LD_EXP 82
46301: PUSH
46302: LD_VAR 0 3
46306: ARRAY
46307: PUSH
46308: LD_INT 1
46310: PLUS
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PPUSH
46316: LD_VAR 0 1
46320: PPUSH
46321: CALL 54503 0 3
46325: ST_TO_ADDR
// exit ;
46326: POP
46327: POP
46328: GO 46643
// end ; if btype in [ b_bunker , b_turret ] then
46330: LD_VAR 0 5
46334: PUSH
46335: LD_INT 32
46337: PUSH
46338: LD_INT 33
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: IN
46345: IFFALSE 46635
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46347: LD_ADDR_EXP 58
46351: PUSH
46352: LD_EXP 58
46356: PPUSH
46357: LD_VAR 0 3
46361: PUSH
46362: LD_EXP 58
46366: PUSH
46367: LD_VAR 0 3
46371: ARRAY
46372: PUSH
46373: LD_INT 1
46375: PLUS
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PPUSH
46381: LD_VAR 0 1
46385: PPUSH
46386: CALL 54503 0 3
46390: ST_TO_ADDR
// if btype = b_bunker then
46391: LD_VAR 0 5
46395: PUSH
46396: LD_INT 32
46398: EQUAL
46399: IFFALSE 46635
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46401: LD_ADDR_EXP 59
46405: PUSH
46406: LD_EXP 59
46410: PPUSH
46411: LD_VAR 0 3
46415: PUSH
46416: LD_EXP 59
46420: PUSH
46421: LD_VAR 0 3
46425: ARRAY
46426: PUSH
46427: LD_INT 1
46429: PLUS
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PPUSH
46435: LD_VAR 0 1
46439: PPUSH
46440: CALL 54503 0 3
46444: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46445: LD_ADDR_VAR 0 6
46449: PUSH
46450: LD_EXP 50
46454: PUSH
46455: LD_VAR 0 3
46459: ARRAY
46460: PPUSH
46461: LD_INT 25
46463: PUSH
46464: LD_INT 1
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: PUSH
46471: LD_INT 3
46473: PUSH
46474: LD_INT 54
46476: PUSH
46477: EMPTY
46478: LIST
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PPUSH
46488: CALL_OW 72
46492: ST_TO_ADDR
// if tmp then
46493: LD_VAR 0 6
46497: IFFALSE 46503
// exit ;
46499: POP
46500: POP
46501: GO 46643
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46503: LD_ADDR_VAR 0 6
46507: PUSH
46508: LD_EXP 50
46512: PUSH
46513: LD_VAR 0 3
46517: ARRAY
46518: PPUSH
46519: LD_INT 2
46521: PUSH
46522: LD_INT 30
46524: PUSH
46525: LD_INT 4
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: LD_INT 30
46534: PUSH
46535: LD_INT 5
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PUSH
46542: EMPTY
46543: LIST
46544: LIST
46545: LIST
46546: PPUSH
46547: CALL_OW 72
46551: ST_TO_ADDR
// if not tmp then
46552: LD_VAR 0 6
46556: NOT
46557: IFFALSE 46563
// exit ;
46559: POP
46560: POP
46561: GO 46643
// for j in tmp do
46563: LD_ADDR_VAR 0 4
46567: PUSH
46568: LD_VAR 0 6
46572: PUSH
46573: FOR_IN
46574: IFFALSE 46633
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46576: LD_ADDR_VAR 0 7
46580: PUSH
46581: LD_VAR 0 4
46585: PPUSH
46586: CALL_OW 313
46590: PPUSH
46591: LD_INT 25
46593: PUSH
46594: LD_INT 1
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: PPUSH
46601: CALL_OW 72
46605: ST_TO_ADDR
// if units then
46606: LD_VAR 0 7
46610: IFFALSE 46631
// begin ComExitBuilding ( units [ 1 ] ) ;
46612: LD_VAR 0 7
46616: PUSH
46617: LD_INT 1
46619: ARRAY
46620: PPUSH
46621: CALL_OW 122
// exit ;
46625: POP
46626: POP
46627: POP
46628: POP
46629: GO 46643
// end ; end ;
46631: GO 46573
46633: POP
46634: POP
// end ; end ; exit ;
46635: POP
46636: POP
46637: GO 46643
// end ; end ;
46639: GO 45997
46641: POP
46642: POP
// end ;
46643: LD_VAR 0 2
46647: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46648: LD_INT 0
46650: PPUSH
46651: PPUSH
46652: PPUSH
46653: PPUSH
46654: PPUSH
46655: PPUSH
46656: PPUSH
// if not mc_bases or not skirmish then
46657: LD_EXP 50
46661: NOT
46662: PUSH
46663: LD_EXP 48
46667: NOT
46668: OR
46669: IFFALSE 46673
// exit ;
46671: GO 46904
// btype := GetBType ( building ) ;
46673: LD_ADDR_VAR 0 6
46677: PUSH
46678: LD_VAR 0 1
46682: PPUSH
46683: CALL_OW 266
46687: ST_TO_ADDR
// x := GetX ( building ) ;
46688: LD_ADDR_VAR 0 7
46692: PUSH
46693: LD_VAR 0 1
46697: PPUSH
46698: CALL_OW 250
46702: ST_TO_ADDR
// y := GetY ( building ) ;
46703: LD_ADDR_VAR 0 8
46707: PUSH
46708: LD_VAR 0 1
46712: PPUSH
46713: CALL_OW 251
46717: ST_TO_ADDR
// d := GetDir ( building ) ;
46718: LD_ADDR_VAR 0 9
46722: PUSH
46723: LD_VAR 0 1
46727: PPUSH
46728: CALL_OW 254
46732: ST_TO_ADDR
// for i = 1 to mc_bases do
46733: LD_ADDR_VAR 0 4
46737: PUSH
46738: DOUBLE
46739: LD_INT 1
46741: DEC
46742: ST_TO_ADDR
46743: LD_EXP 50
46747: PUSH
46748: FOR_TO
46749: IFFALSE 46902
// begin if not mc_build_list [ i ] then
46751: LD_EXP 55
46755: PUSH
46756: LD_VAR 0 4
46760: ARRAY
46761: NOT
46762: IFFALSE 46766
// continue ;
46764: GO 46748
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46766: LD_VAR 0 6
46770: PUSH
46771: LD_VAR 0 7
46775: PUSH
46776: LD_VAR 0 8
46780: PUSH
46781: LD_VAR 0 9
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: PPUSH
46792: LD_EXP 55
46796: PUSH
46797: LD_VAR 0 4
46801: ARRAY
46802: PUSH
46803: LD_INT 1
46805: ARRAY
46806: PPUSH
46807: CALL 60672 0 2
46811: IFFALSE 46900
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46813: LD_ADDR_EXP 55
46817: PUSH
46818: LD_EXP 55
46822: PPUSH
46823: LD_VAR 0 4
46827: PPUSH
46828: LD_EXP 55
46832: PUSH
46833: LD_VAR 0 4
46837: ARRAY
46838: PPUSH
46839: LD_INT 1
46841: PPUSH
46842: CALL_OW 3
46846: PPUSH
46847: CALL_OW 1
46851: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46852: LD_ADDR_EXP 57
46856: PUSH
46857: LD_EXP 57
46861: PPUSH
46862: LD_VAR 0 4
46866: PUSH
46867: LD_EXP 57
46871: PUSH
46872: LD_VAR 0 4
46876: ARRAY
46877: PUSH
46878: LD_INT 1
46880: PLUS
46881: PUSH
46882: EMPTY
46883: LIST
46884: LIST
46885: PPUSH
46886: LD_VAR 0 1
46890: PPUSH
46891: CALL 54503 0 3
46895: ST_TO_ADDR
// exit ;
46896: POP
46897: POP
46898: GO 46904
// end ; end ;
46900: GO 46748
46902: POP
46903: POP
// end ;
46904: LD_VAR 0 3
46908: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
46909: LD_INT 0
46911: PPUSH
46912: PPUSH
46913: PPUSH
// if not mc_bases or not skirmish then
46914: LD_EXP 50
46918: NOT
46919: PUSH
46920: LD_EXP 48
46924: NOT
46925: OR
46926: IFFALSE 46930
// exit ;
46928: GO 47120
// for i = 1 to mc_bases do
46930: LD_ADDR_VAR 0 4
46934: PUSH
46935: DOUBLE
46936: LD_INT 1
46938: DEC
46939: ST_TO_ADDR
46940: LD_EXP 50
46944: PUSH
46945: FOR_TO
46946: IFFALSE 47033
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
46948: LD_VAR 0 1
46952: PUSH
46953: LD_EXP 58
46957: PUSH
46958: LD_VAR 0 4
46962: ARRAY
46963: IN
46964: PUSH
46965: LD_VAR 0 1
46969: PUSH
46970: LD_EXP 59
46974: PUSH
46975: LD_VAR 0 4
46979: ARRAY
46980: IN
46981: NOT
46982: AND
46983: IFFALSE 47031
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46985: LD_ADDR_EXP 59
46989: PUSH
46990: LD_EXP 59
46994: PPUSH
46995: LD_VAR 0 4
46999: PUSH
47000: LD_EXP 59
47004: PUSH
47005: LD_VAR 0 4
47009: ARRAY
47010: PUSH
47011: LD_INT 1
47013: PLUS
47014: PUSH
47015: EMPTY
47016: LIST
47017: LIST
47018: PPUSH
47019: LD_VAR 0 1
47023: PPUSH
47024: CALL 54503 0 3
47028: ST_TO_ADDR
// break ;
47029: GO 47033
// end ; end ;
47031: GO 46945
47033: POP
47034: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47035: LD_VAR 0 1
47039: PPUSH
47040: CALL_OW 257
47044: PUSH
47045: LD_EXP 76
47049: IN
47050: PUSH
47051: LD_VAR 0 1
47055: PPUSH
47056: CALL_OW 266
47060: PUSH
47061: LD_INT 5
47063: EQUAL
47064: AND
47065: PUSH
47066: LD_VAR 0 2
47070: PPUSH
47071: CALL_OW 110
47075: PUSH
47076: LD_INT 18
47078: NONEQUAL
47079: AND
47080: IFFALSE 47120
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47082: LD_VAR 0 2
47086: PPUSH
47087: CALL_OW 257
47091: PUSH
47092: LD_INT 5
47094: PUSH
47095: LD_INT 8
47097: PUSH
47098: LD_INT 9
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: LIST
47105: IN
47106: IFFALSE 47120
// SetClass ( unit , 1 ) ;
47108: LD_VAR 0 2
47112: PPUSH
47113: LD_INT 1
47115: PPUSH
47116: CALL_OW 336
// end ;
47120: LD_VAR 0 3
47124: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47125: LD_INT 0
47127: PPUSH
47128: PPUSH
// if not mc_bases or not skirmish then
47129: LD_EXP 50
47133: NOT
47134: PUSH
47135: LD_EXP 48
47139: NOT
47140: OR
47141: IFFALSE 47145
// exit ;
47143: GO 47261
// if GetLives ( abandoned_vehicle ) > 250 then
47145: LD_VAR 0 2
47149: PPUSH
47150: CALL_OW 256
47154: PUSH
47155: LD_INT 250
47157: GREATER
47158: IFFALSE 47162
// exit ;
47160: GO 47261
// for i = 1 to mc_bases do
47162: LD_ADDR_VAR 0 6
47166: PUSH
47167: DOUBLE
47168: LD_INT 1
47170: DEC
47171: ST_TO_ADDR
47172: LD_EXP 50
47176: PUSH
47177: FOR_TO
47178: IFFALSE 47259
// begin if driver in mc_bases [ i ] then
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 50
47189: PUSH
47190: LD_VAR 0 6
47194: ARRAY
47195: IN
47196: IFFALSE 47257
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47198: LD_VAR 0 1
47202: PPUSH
47203: LD_EXP 50
47207: PUSH
47208: LD_VAR 0 6
47212: ARRAY
47213: PPUSH
47214: LD_INT 2
47216: PUSH
47217: LD_INT 30
47219: PUSH
47220: LD_INT 0
47222: PUSH
47223: EMPTY
47224: LIST
47225: LIST
47226: PUSH
47227: LD_INT 30
47229: PUSH
47230: LD_INT 1
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: PUSH
47237: EMPTY
47238: LIST
47239: LIST
47240: LIST
47241: PPUSH
47242: CALL_OW 72
47246: PUSH
47247: LD_INT 1
47249: ARRAY
47250: PPUSH
47251: CALL_OW 112
// break ;
47255: GO 47259
// end ; end ;
47257: GO 47177
47259: POP
47260: POP
// end ; end_of_file
47261: LD_VAR 0 5
47265: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47266: LD_INT 0
47268: PPUSH
47269: PPUSH
// if exist_mode then
47270: LD_VAR 0 2
47274: IFFALSE 47299
// unit := CreateCharacter ( prefix & ident ) else
47276: LD_ADDR_VAR 0 5
47280: PUSH
47281: LD_VAR 0 3
47285: PUSH
47286: LD_VAR 0 1
47290: STR
47291: PPUSH
47292: CALL_OW 34
47296: ST_TO_ADDR
47297: GO 47314
// unit := NewCharacter ( ident ) ;
47299: LD_ADDR_VAR 0 5
47303: PUSH
47304: LD_VAR 0 1
47308: PPUSH
47309: CALL_OW 25
47313: ST_TO_ADDR
// result := unit ;
47314: LD_ADDR_VAR 0 4
47318: PUSH
47319: LD_VAR 0 5
47323: ST_TO_ADDR
// end ;
47324: LD_VAR 0 4
47328: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47329: LD_INT 0
47331: PPUSH
47332: PPUSH
// if not side or not nation then
47333: LD_VAR 0 1
47337: NOT
47338: PUSH
47339: LD_VAR 0 2
47343: NOT
47344: OR
47345: IFFALSE 47349
// exit ;
47347: GO 47993
// case nation of nation_american :
47349: LD_VAR 0 2
47353: PUSH
47354: LD_INT 1
47356: DOUBLE
47357: EQUAL
47358: IFTRUE 47362
47360: GO 47536
47362: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
47363: LD_ADDR_VAR 0 4
47367: PUSH
47368: LD_INT 35
47370: PUSH
47371: LD_INT 45
47373: PUSH
47374: LD_INT 46
47376: PUSH
47377: LD_INT 47
47379: PUSH
47380: LD_INT 1
47382: PUSH
47383: LD_INT 2
47385: PUSH
47386: LD_INT 6
47388: PUSH
47389: LD_INT 15
47391: PUSH
47392: LD_INT 16
47394: PUSH
47395: LD_INT 7
47397: PUSH
47398: LD_INT 12
47400: PUSH
47401: LD_INT 13
47403: PUSH
47404: LD_INT 10
47406: PUSH
47407: LD_INT 14
47409: PUSH
47410: LD_INT 20
47412: PUSH
47413: LD_INT 21
47415: PUSH
47416: LD_INT 22
47418: PUSH
47419: LD_INT 25
47421: PUSH
47422: LD_INT 32
47424: PUSH
47425: LD_INT 27
47427: PUSH
47428: LD_INT 36
47430: PUSH
47431: LD_INT 69
47433: PUSH
47434: LD_INT 39
47436: PUSH
47437: LD_INT 34
47439: PUSH
47440: LD_INT 40
47442: PUSH
47443: LD_INT 48
47445: PUSH
47446: LD_INT 49
47448: PUSH
47449: LD_INT 50
47451: PUSH
47452: LD_INT 51
47454: PUSH
47455: LD_INT 52
47457: PUSH
47458: LD_INT 53
47460: PUSH
47461: LD_INT 54
47463: PUSH
47464: LD_INT 55
47466: PUSH
47467: LD_INT 56
47469: PUSH
47470: LD_INT 57
47472: PUSH
47473: LD_INT 58
47475: PUSH
47476: LD_INT 59
47478: PUSH
47479: LD_INT 60
47481: PUSH
47482: LD_INT 61
47484: PUSH
47485: LD_INT 62
47487: PUSH
47488: LD_INT 80
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: LIST
47515: LIST
47516: LIST
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: LIST
47523: LIST
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: LIST
47530: LIST
47531: LIST
47532: LIST
47533: ST_TO_ADDR
47534: GO 47917
47536: LD_INT 2
47538: DOUBLE
47539: EQUAL
47540: IFTRUE 47544
47542: GO 47726
47544: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
47545: LD_ADDR_VAR 0 4
47549: PUSH
47550: LD_INT 35
47552: PUSH
47553: LD_INT 45
47555: PUSH
47556: LD_INT 46
47558: PUSH
47559: LD_INT 47
47561: PUSH
47562: LD_INT 70
47564: PUSH
47565: LD_INT 1
47567: PUSH
47568: LD_INT 11
47570: PUSH
47571: LD_INT 3
47573: PUSH
47574: LD_INT 4
47576: PUSH
47577: LD_INT 5
47579: PUSH
47580: LD_INT 6
47582: PUSH
47583: LD_INT 15
47585: PUSH
47586: LD_INT 18
47588: PUSH
47589: LD_INT 7
47591: PUSH
47592: LD_INT 17
47594: PUSH
47595: LD_INT 8
47597: PUSH
47598: LD_INT 20
47600: PUSH
47601: LD_INT 21
47603: PUSH
47604: LD_INT 22
47606: PUSH
47607: LD_INT 72
47609: PUSH
47610: LD_INT 26
47612: PUSH
47613: LD_INT 69
47615: PUSH
47616: LD_INT 39
47618: PUSH
47619: LD_INT 40
47621: PUSH
47622: LD_INT 41
47624: PUSH
47625: LD_INT 42
47627: PUSH
47628: LD_INT 43
47630: PUSH
47631: LD_INT 48
47633: PUSH
47634: LD_INT 49
47636: PUSH
47637: LD_INT 50
47639: PUSH
47640: LD_INT 51
47642: PUSH
47643: LD_INT 52
47645: PUSH
47646: LD_INT 53
47648: PUSH
47649: LD_INT 54
47651: PUSH
47652: LD_INT 55
47654: PUSH
47655: LD_INT 56
47657: PUSH
47658: LD_INT 60
47660: PUSH
47661: LD_INT 61
47663: PUSH
47664: LD_INT 62
47666: PUSH
47667: LD_INT 66
47669: PUSH
47670: LD_INT 67
47672: PUSH
47673: LD_INT 68
47675: PUSH
47676: LD_INT 81
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: LIST
47697: LIST
47698: LIST
47699: LIST
47700: LIST
47701: LIST
47702: LIST
47703: LIST
47704: LIST
47705: LIST
47706: LIST
47707: LIST
47708: LIST
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: LIST
47715: LIST
47716: LIST
47717: LIST
47718: LIST
47719: LIST
47720: LIST
47721: LIST
47722: LIST
47723: ST_TO_ADDR
47724: GO 47917
47726: LD_INT 3
47728: DOUBLE
47729: EQUAL
47730: IFTRUE 47734
47732: GO 47916
47734: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
47735: LD_ADDR_VAR 0 4
47739: PUSH
47740: LD_INT 46
47742: PUSH
47743: LD_INT 47
47745: PUSH
47746: LD_INT 1
47748: PUSH
47749: LD_INT 2
47751: PUSH
47752: LD_INT 11
47754: PUSH
47755: LD_INT 9
47757: PUSH
47758: LD_INT 20
47760: PUSH
47761: LD_INT 19
47763: PUSH
47764: LD_INT 21
47766: PUSH
47767: LD_INT 24
47769: PUSH
47770: LD_INT 22
47772: PUSH
47773: LD_INT 25
47775: PUSH
47776: LD_INT 28
47778: PUSH
47779: LD_INT 29
47781: PUSH
47782: LD_INT 30
47784: PUSH
47785: LD_INT 31
47787: PUSH
47788: LD_INT 37
47790: PUSH
47791: LD_INT 38
47793: PUSH
47794: LD_INT 32
47796: PUSH
47797: LD_INT 27
47799: PUSH
47800: LD_INT 33
47802: PUSH
47803: LD_INT 69
47805: PUSH
47806: LD_INT 39
47808: PUSH
47809: LD_INT 34
47811: PUSH
47812: LD_INT 40
47814: PUSH
47815: LD_INT 71
47817: PUSH
47818: LD_INT 23
47820: PUSH
47821: LD_INT 44
47823: PUSH
47824: LD_INT 48
47826: PUSH
47827: LD_INT 49
47829: PUSH
47830: LD_INT 50
47832: PUSH
47833: LD_INT 51
47835: PUSH
47836: LD_INT 52
47838: PUSH
47839: LD_INT 53
47841: PUSH
47842: LD_INT 54
47844: PUSH
47845: LD_INT 55
47847: PUSH
47848: LD_INT 56
47850: PUSH
47851: LD_INT 57
47853: PUSH
47854: LD_INT 58
47856: PUSH
47857: LD_INT 59
47859: PUSH
47860: LD_INT 63
47862: PUSH
47863: LD_INT 64
47865: PUSH
47866: LD_INT 65
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: LIST
47902: LIST
47903: LIST
47904: LIST
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: LIST
47913: ST_TO_ADDR
47914: GO 47917
47916: POP
// if state > - 1 and state < 3 then
47917: LD_VAR 0 3
47921: PUSH
47922: LD_INT 1
47924: NEG
47925: GREATER
47926: PUSH
47927: LD_VAR 0 3
47931: PUSH
47932: LD_INT 3
47934: LESS
47935: AND
47936: IFFALSE 47993
// for i in result do
47938: LD_ADDR_VAR 0 5
47942: PUSH
47943: LD_VAR 0 4
47947: PUSH
47948: FOR_IN
47949: IFFALSE 47991
// if GetTech ( i , side ) <> state then
47951: LD_VAR 0 5
47955: PPUSH
47956: LD_VAR 0 1
47960: PPUSH
47961: CALL_OW 321
47965: PUSH
47966: LD_VAR 0 3
47970: NONEQUAL
47971: IFFALSE 47989
// result := result diff i ;
47973: LD_ADDR_VAR 0 4
47977: PUSH
47978: LD_VAR 0 4
47982: PUSH
47983: LD_VAR 0 5
47987: DIFF
47988: ST_TO_ADDR
47989: GO 47948
47991: POP
47992: POP
// end ;
47993: LD_VAR 0 4
47997: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
47998: LD_INT 0
48000: PPUSH
48001: PPUSH
48002: PPUSH
// result := true ;
48003: LD_ADDR_VAR 0 3
48007: PUSH
48008: LD_INT 1
48010: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48011: LD_ADDR_VAR 0 5
48015: PUSH
48016: LD_VAR 0 2
48020: PPUSH
48021: CALL_OW 480
48025: ST_TO_ADDR
// if not tmp then
48026: LD_VAR 0 5
48030: NOT
48031: IFFALSE 48035
// exit ;
48033: GO 48084
// for i in tmp do
48035: LD_ADDR_VAR 0 4
48039: PUSH
48040: LD_VAR 0 5
48044: PUSH
48045: FOR_IN
48046: IFFALSE 48082
// if GetTech ( i , side ) <> state_researched then
48048: LD_VAR 0 4
48052: PPUSH
48053: LD_VAR 0 1
48057: PPUSH
48058: CALL_OW 321
48062: PUSH
48063: LD_INT 2
48065: NONEQUAL
48066: IFFALSE 48080
// begin result := false ;
48068: LD_ADDR_VAR 0 3
48072: PUSH
48073: LD_INT 0
48075: ST_TO_ADDR
// exit ;
48076: POP
48077: POP
48078: GO 48084
// end ;
48080: GO 48045
48082: POP
48083: POP
// end ;
48084: LD_VAR 0 3
48088: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48089: LD_INT 0
48091: PPUSH
48092: PPUSH
48093: PPUSH
48094: PPUSH
48095: PPUSH
48096: PPUSH
48097: PPUSH
48098: PPUSH
48099: PPUSH
48100: PPUSH
48101: PPUSH
48102: PPUSH
48103: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48104: LD_VAR 0 1
48108: NOT
48109: PUSH
48110: LD_VAR 0 1
48114: PPUSH
48115: CALL_OW 257
48119: PUSH
48120: LD_INT 9
48122: NONEQUAL
48123: OR
48124: IFFALSE 48128
// exit ;
48126: GO 48701
// side := GetSide ( unit ) ;
48128: LD_ADDR_VAR 0 9
48132: PUSH
48133: LD_VAR 0 1
48137: PPUSH
48138: CALL_OW 255
48142: ST_TO_ADDR
// tech_space := tech_spacanom ;
48143: LD_ADDR_VAR 0 12
48147: PUSH
48148: LD_INT 29
48150: ST_TO_ADDR
// tech_time := tech_taurad ;
48151: LD_ADDR_VAR 0 13
48155: PUSH
48156: LD_INT 28
48158: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48159: LD_ADDR_VAR 0 11
48163: PUSH
48164: LD_VAR 0 1
48168: PPUSH
48169: CALL_OW 310
48173: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48174: LD_VAR 0 11
48178: PPUSH
48179: CALL_OW 247
48183: PUSH
48184: LD_INT 2
48186: EQUAL
48187: IFFALSE 48191
// exit ;
48189: GO 48701
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48191: LD_ADDR_VAR 0 8
48195: PUSH
48196: LD_INT 81
48198: PUSH
48199: LD_VAR 0 9
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 3
48210: PUSH
48211: LD_INT 21
48213: PUSH
48214: LD_INT 3
48216: PUSH
48217: EMPTY
48218: LIST
48219: LIST
48220: PUSH
48221: EMPTY
48222: LIST
48223: LIST
48224: PUSH
48225: EMPTY
48226: LIST
48227: LIST
48228: PPUSH
48229: CALL_OW 69
48233: ST_TO_ADDR
// if not tmp then
48234: LD_VAR 0 8
48238: NOT
48239: IFFALSE 48243
// exit ;
48241: GO 48701
// if in_unit then
48243: LD_VAR 0 11
48247: IFFALSE 48271
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48249: LD_ADDR_VAR 0 10
48253: PUSH
48254: LD_VAR 0 8
48258: PPUSH
48259: LD_VAR 0 11
48263: PPUSH
48264: CALL_OW 74
48268: ST_TO_ADDR
48269: GO 48291
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48271: LD_ADDR_VAR 0 10
48275: PUSH
48276: LD_VAR 0 8
48280: PPUSH
48281: LD_VAR 0 1
48285: PPUSH
48286: CALL_OW 74
48290: ST_TO_ADDR
// if not enemy then
48291: LD_VAR 0 10
48295: NOT
48296: IFFALSE 48300
// exit ;
48298: GO 48701
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48300: LD_VAR 0 11
48304: PUSH
48305: LD_VAR 0 11
48309: PPUSH
48310: LD_VAR 0 10
48314: PPUSH
48315: CALL_OW 296
48319: PUSH
48320: LD_INT 13
48322: GREATER
48323: AND
48324: PUSH
48325: LD_VAR 0 1
48329: PPUSH
48330: LD_VAR 0 10
48334: PPUSH
48335: CALL_OW 296
48339: PUSH
48340: LD_INT 12
48342: GREATER
48343: OR
48344: IFFALSE 48348
// exit ;
48346: GO 48701
// missile := [ 1 ] ;
48348: LD_ADDR_VAR 0 14
48352: PUSH
48353: LD_INT 1
48355: PUSH
48356: EMPTY
48357: LIST
48358: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48359: LD_VAR 0 9
48363: PPUSH
48364: LD_VAR 0 12
48368: PPUSH
48369: CALL_OW 325
48373: IFFALSE 48402
// missile := Insert ( missile , missile + 1 , 2 ) ;
48375: LD_ADDR_VAR 0 14
48379: PUSH
48380: LD_VAR 0 14
48384: PPUSH
48385: LD_VAR 0 14
48389: PUSH
48390: LD_INT 1
48392: PLUS
48393: PPUSH
48394: LD_INT 2
48396: PPUSH
48397: CALL_OW 2
48401: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48402: LD_VAR 0 9
48406: PPUSH
48407: LD_VAR 0 13
48411: PPUSH
48412: CALL_OW 325
48416: PUSH
48417: LD_VAR 0 10
48421: PPUSH
48422: CALL_OW 255
48426: PPUSH
48427: LD_VAR 0 13
48431: PPUSH
48432: CALL_OW 325
48436: NOT
48437: AND
48438: IFFALSE 48467
// missile := Insert ( missile , missile + 1 , 3 ) ;
48440: LD_ADDR_VAR 0 14
48444: PUSH
48445: LD_VAR 0 14
48449: PPUSH
48450: LD_VAR 0 14
48454: PUSH
48455: LD_INT 1
48457: PLUS
48458: PPUSH
48459: LD_INT 3
48461: PPUSH
48462: CALL_OW 2
48466: ST_TO_ADDR
// if missile < 2 then
48467: LD_VAR 0 14
48471: PUSH
48472: LD_INT 2
48474: LESS
48475: IFFALSE 48479
// exit ;
48477: GO 48701
// x := GetX ( enemy ) ;
48479: LD_ADDR_VAR 0 4
48483: PUSH
48484: LD_VAR 0 10
48488: PPUSH
48489: CALL_OW 250
48493: ST_TO_ADDR
// y := GetY ( enemy ) ;
48494: LD_ADDR_VAR 0 5
48498: PUSH
48499: LD_VAR 0 10
48503: PPUSH
48504: CALL_OW 251
48508: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48509: LD_ADDR_VAR 0 6
48513: PUSH
48514: LD_VAR 0 4
48518: PUSH
48519: LD_INT 1
48521: NEG
48522: PPUSH
48523: LD_INT 1
48525: PPUSH
48526: CALL_OW 12
48530: PLUS
48531: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48532: LD_ADDR_VAR 0 7
48536: PUSH
48537: LD_VAR 0 5
48541: PUSH
48542: LD_INT 1
48544: NEG
48545: PPUSH
48546: LD_INT 1
48548: PPUSH
48549: CALL_OW 12
48553: PLUS
48554: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48555: LD_VAR 0 6
48559: PPUSH
48560: LD_VAR 0 7
48564: PPUSH
48565: CALL_OW 488
48569: NOT
48570: IFFALSE 48592
// begin _x := x ;
48572: LD_ADDR_VAR 0 6
48576: PUSH
48577: LD_VAR 0 4
48581: ST_TO_ADDR
// _y := y ;
48582: LD_ADDR_VAR 0 7
48586: PUSH
48587: LD_VAR 0 5
48591: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48592: LD_ADDR_VAR 0 3
48596: PUSH
48597: LD_INT 1
48599: PPUSH
48600: LD_VAR 0 14
48604: PPUSH
48605: CALL_OW 12
48609: ST_TO_ADDR
// case i of 1 :
48610: LD_VAR 0 3
48614: PUSH
48615: LD_INT 1
48617: DOUBLE
48618: EQUAL
48619: IFTRUE 48623
48621: GO 48640
48623: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48624: LD_VAR 0 1
48628: PPUSH
48629: LD_VAR 0 10
48633: PPUSH
48634: CALL_OW 115
48638: GO 48701
48640: LD_INT 2
48642: DOUBLE
48643: EQUAL
48644: IFTRUE 48648
48646: GO 48670
48648: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48649: LD_VAR 0 1
48653: PPUSH
48654: LD_VAR 0 6
48658: PPUSH
48659: LD_VAR 0 7
48663: PPUSH
48664: CALL_OW 153
48668: GO 48701
48670: LD_INT 3
48672: DOUBLE
48673: EQUAL
48674: IFTRUE 48678
48676: GO 48700
48678: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48679: LD_VAR 0 1
48683: PPUSH
48684: LD_VAR 0 6
48688: PPUSH
48689: LD_VAR 0 7
48693: PPUSH
48694: CALL_OW 154
48698: GO 48701
48700: POP
// end ;
48701: LD_VAR 0 2
48705: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48706: LD_INT 0
48708: PPUSH
48709: PPUSH
48710: PPUSH
48711: PPUSH
48712: PPUSH
48713: PPUSH
// if not unit or not building then
48714: LD_VAR 0 1
48718: NOT
48719: PUSH
48720: LD_VAR 0 2
48724: NOT
48725: OR
48726: IFFALSE 48730
// exit ;
48728: GO 48888
// x := GetX ( building ) ;
48730: LD_ADDR_VAR 0 5
48734: PUSH
48735: LD_VAR 0 2
48739: PPUSH
48740: CALL_OW 250
48744: ST_TO_ADDR
// y := GetY ( building ) ;
48745: LD_ADDR_VAR 0 6
48749: PUSH
48750: LD_VAR 0 2
48754: PPUSH
48755: CALL_OW 251
48759: ST_TO_ADDR
// for i = 0 to 5 do
48760: LD_ADDR_VAR 0 4
48764: PUSH
48765: DOUBLE
48766: LD_INT 0
48768: DEC
48769: ST_TO_ADDR
48770: LD_INT 5
48772: PUSH
48773: FOR_TO
48774: IFFALSE 48886
// begin _x := ShiftX ( x , i , 3 ) ;
48776: LD_ADDR_VAR 0 7
48780: PUSH
48781: LD_VAR 0 5
48785: PPUSH
48786: LD_VAR 0 4
48790: PPUSH
48791: LD_INT 3
48793: PPUSH
48794: CALL_OW 272
48798: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
48799: LD_ADDR_VAR 0 8
48803: PUSH
48804: LD_VAR 0 6
48808: PPUSH
48809: LD_VAR 0 4
48813: PPUSH
48814: LD_INT 3
48816: PPUSH
48817: CALL_OW 273
48821: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48822: LD_VAR 0 7
48826: PPUSH
48827: LD_VAR 0 8
48831: PPUSH
48832: CALL_OW 488
48836: NOT
48837: IFFALSE 48841
// continue ;
48839: GO 48773
// if HexInfo ( _x , _y ) = 0 then
48841: LD_VAR 0 7
48845: PPUSH
48846: LD_VAR 0 8
48850: PPUSH
48851: CALL_OW 428
48855: PUSH
48856: LD_INT 0
48858: EQUAL
48859: IFFALSE 48884
// begin ComMoveXY ( unit , _x , _y ) ;
48861: LD_VAR 0 1
48865: PPUSH
48866: LD_VAR 0 7
48870: PPUSH
48871: LD_VAR 0 8
48875: PPUSH
48876: CALL_OW 111
// exit ;
48880: POP
48881: POP
48882: GO 48888
// end ; end ;
48884: GO 48773
48886: POP
48887: POP
// end ;
48888: LD_VAR 0 3
48892: RET
// export function ScanBase ( side , base_area ) ; begin
48893: LD_INT 0
48895: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
48896: LD_ADDR_VAR 0 3
48900: PUSH
48901: LD_VAR 0 2
48905: PPUSH
48906: LD_INT 81
48908: PUSH
48909: LD_VAR 0 1
48913: PUSH
48914: EMPTY
48915: LIST
48916: LIST
48917: PPUSH
48918: CALL_OW 70
48922: ST_TO_ADDR
// end ;
48923: LD_VAR 0 3
48927: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
48928: LD_INT 0
48930: PPUSH
48931: PPUSH
48932: PPUSH
48933: PPUSH
48934: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
48935: LD_VAR 0 1
48939: NOT
48940: PUSH
48941: LD_EXP 50
48945: PUSH
48946: LD_VAR 0 1
48950: ARRAY
48951: NOT
48952: OR
48953: PUSH
48954: LD_VAR 0 2
48958: NOT
48959: OR
48960: PUSH
48961: LD_VAR 0 3
48965: NOT
48966: OR
48967: IFFALSE 48971
// exit ;
48969: GO 49484
// side := mc_sides [ base ] ;
48971: LD_ADDR_VAR 0 6
48975: PUSH
48976: LD_EXP 76
48980: PUSH
48981: LD_VAR 0 1
48985: ARRAY
48986: ST_TO_ADDR
// if not side then
48987: LD_VAR 0 6
48991: NOT
48992: IFFALSE 48996
// exit ;
48994: GO 49484
// for i in solds do
48996: LD_ADDR_VAR 0 7
49000: PUSH
49001: LD_VAR 0 2
49005: PUSH
49006: FOR_IN
49007: IFFALSE 49068
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
49009: LD_VAR 0 7
49013: PPUSH
49014: CALL_OW 310
49018: PPUSH
49019: CALL_OW 266
49023: PUSH
49024: LD_INT 32
49026: PUSH
49027: LD_INT 31
49029: PUSH
49030: EMPTY
49031: LIST
49032: LIST
49033: IN
49034: IFFALSE 49054
// solds := solds diff i else
49036: LD_ADDR_VAR 0 2
49040: PUSH
49041: LD_VAR 0 2
49045: PUSH
49046: LD_VAR 0 7
49050: DIFF
49051: ST_TO_ADDR
49052: GO 49066
// SetTag ( i , 18 ) ;
49054: LD_VAR 0 7
49058: PPUSH
49059: LD_INT 18
49061: PPUSH
49062: CALL_OW 109
49066: GO 49006
49068: POP
49069: POP
// if not solds then
49070: LD_VAR 0 2
49074: NOT
49075: IFFALSE 49079
// exit ;
49077: GO 49484
// repeat wait ( 0 0$1 ) ;
49079: LD_INT 35
49081: PPUSH
49082: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
49086: LD_ADDR_VAR 0 5
49090: PUSH
49091: LD_VAR 0 6
49095: PPUSH
49096: LD_VAR 0 3
49100: PPUSH
49101: CALL 48893 0 2
49105: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49106: LD_EXP 50
49110: PUSH
49111: LD_VAR 0 1
49115: ARRAY
49116: NOT
49117: PUSH
49118: LD_EXP 50
49122: PUSH
49123: LD_VAR 0 1
49127: ARRAY
49128: PUSH
49129: EMPTY
49130: EQUAL
49131: OR
49132: IFFALSE 49169
// begin for i in solds do
49134: LD_ADDR_VAR 0 7
49138: PUSH
49139: LD_VAR 0 2
49143: PUSH
49144: FOR_IN
49145: IFFALSE 49158
// ComStop ( i ) ;
49147: LD_VAR 0 7
49151: PPUSH
49152: CALL_OW 141
49156: GO 49144
49158: POP
49159: POP
// solds := [ ] ;
49160: LD_ADDR_VAR 0 2
49164: PUSH
49165: EMPTY
49166: ST_TO_ADDR
// exit ;
49167: GO 49484
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
49169: LD_VAR 0 5
49173: NOT
49174: PUSH
49175: LD_VAR 0 5
49179: PUSH
49180: LD_INT 3
49182: GREATER
49183: OR
49184: PUSH
49185: LD_EXP 72
49189: PUSH
49190: LD_VAR 0 1
49194: ARRAY
49195: OR
49196: IFFALSE 49237
// begin for i in solds do
49198: LD_ADDR_VAR 0 7
49202: PUSH
49203: LD_VAR 0 2
49207: PUSH
49208: FOR_IN
49209: IFFALSE 49233
// if HasTask ( i ) then
49211: LD_VAR 0 7
49215: PPUSH
49216: CALL_OW 314
49220: IFFALSE 49231
// ComStop ( i ) ;
49222: LD_VAR 0 7
49226: PPUSH
49227: CALL_OW 141
49231: GO 49208
49233: POP
49234: POP
// break ;
49235: GO 49472
// end ; for i in solds do
49237: LD_ADDR_VAR 0 7
49241: PUSH
49242: LD_VAR 0 2
49246: PUSH
49247: FOR_IN
49248: IFFALSE 49464
// begin if IsInUnit ( i ) then
49250: LD_VAR 0 7
49254: PPUSH
49255: CALL_OW 310
49259: IFFALSE 49270
// ComExitBuilding ( i ) ;
49261: LD_VAR 0 7
49265: PPUSH
49266: CALL_OW 122
// if GetLives ( i ) > 333 then
49270: LD_VAR 0 7
49274: PPUSH
49275: CALL_OW 256
49279: PUSH
49280: LD_INT 333
49282: GREATER
49283: IFFALSE 49311
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
49285: LD_VAR 0 7
49289: PPUSH
49290: LD_VAR 0 5
49294: PPUSH
49295: LD_VAR 0 7
49299: PPUSH
49300: CALL_OW 74
49304: PPUSH
49305: CALL_OW 115
49309: GO 49462
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
49311: LD_ADDR_VAR 0 8
49315: PUSH
49316: LD_EXP 50
49320: PUSH
49321: LD_VAR 0 1
49325: ARRAY
49326: PPUSH
49327: LD_INT 2
49329: PUSH
49330: LD_INT 30
49332: PUSH
49333: LD_INT 0
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: PUSH
49340: LD_INT 30
49342: PUSH
49343: LD_INT 1
49345: PUSH
49346: EMPTY
49347: LIST
49348: LIST
49349: PUSH
49350: LD_INT 30
49352: PUSH
49353: LD_INT 6
49355: PUSH
49356: EMPTY
49357: LIST
49358: LIST
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: PPUSH
49366: CALL_OW 72
49370: PPUSH
49371: LD_VAR 0 7
49375: PPUSH
49376: CALL_OW 74
49380: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
49381: LD_VAR 0 7
49385: PPUSH
49386: LD_VAR 0 8
49390: PPUSH
49391: CALL_OW 250
49395: PPUSH
49396: LD_INT 3
49398: PPUSH
49399: LD_INT 5
49401: PPUSH
49402: CALL_OW 272
49406: PPUSH
49407: LD_VAR 0 8
49411: PPUSH
49412: CALL_OW 251
49416: PPUSH
49417: LD_INT 3
49419: PPUSH
49420: LD_INT 5
49422: PPUSH
49423: CALL_OW 273
49427: PPUSH
49428: CALL_OW 111
// SetTag ( i , 0 ) ;
49432: LD_VAR 0 7
49436: PPUSH
49437: LD_INT 0
49439: PPUSH
49440: CALL_OW 109
// solds := solds diff i ;
49444: LD_ADDR_VAR 0 2
49448: PUSH
49449: LD_VAR 0 2
49453: PUSH
49454: LD_VAR 0 7
49458: DIFF
49459: ST_TO_ADDR
// continue ;
49460: GO 49247
// end ; end ;
49462: GO 49247
49464: POP
49465: POP
// until solds ;
49466: LD_VAR 0 2
49470: IFFALSE 49079
// MC_Reset ( base , 18 ) ;
49472: LD_VAR 0 1
49476: PPUSH
49477: LD_INT 18
49479: PPUSH
49480: CALL 21305 0 2
// end ;
49484: LD_VAR 0 4
49488: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
49489: LD_INT 0
49491: PPUSH
49492: PPUSH
49493: PPUSH
49494: PPUSH
49495: PPUSH
49496: PPUSH
49497: PPUSH
49498: PPUSH
49499: PPUSH
49500: PPUSH
49501: PPUSH
49502: PPUSH
49503: PPUSH
49504: PPUSH
49505: PPUSH
49506: PPUSH
49507: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
49508: LD_ADDR_VAR 0 13
49512: PUSH
49513: LD_EXP 50
49517: PUSH
49518: LD_VAR 0 1
49522: ARRAY
49523: PPUSH
49524: LD_INT 25
49526: PUSH
49527: LD_INT 3
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PPUSH
49534: CALL_OW 72
49538: ST_TO_ADDR
// if mc_remote_driver [ base ] then
49539: LD_EXP 90
49543: PUSH
49544: LD_VAR 0 1
49548: ARRAY
49549: IFFALSE 49573
// mechs := mechs diff mc_remote_driver [ base ] ;
49551: LD_ADDR_VAR 0 13
49555: PUSH
49556: LD_VAR 0 13
49560: PUSH
49561: LD_EXP 90
49565: PUSH
49566: LD_VAR 0 1
49570: ARRAY
49571: DIFF
49572: ST_TO_ADDR
// for i in mechs do
49573: LD_ADDR_VAR 0 5
49577: PUSH
49578: LD_VAR 0 13
49582: PUSH
49583: FOR_IN
49584: IFFALSE 49619
// if GetTag ( i ) > 0 then
49586: LD_VAR 0 5
49590: PPUSH
49591: CALL_OW 110
49595: PUSH
49596: LD_INT 0
49598: GREATER
49599: IFFALSE 49617
// mechs := mechs diff i ;
49601: LD_ADDR_VAR 0 13
49605: PUSH
49606: LD_VAR 0 13
49610: PUSH
49611: LD_VAR 0 5
49615: DIFF
49616: ST_TO_ADDR
49617: GO 49583
49619: POP
49620: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49621: LD_ADDR_VAR 0 9
49625: PUSH
49626: LD_EXP 50
49630: PUSH
49631: LD_VAR 0 1
49635: ARRAY
49636: PPUSH
49637: LD_INT 2
49639: PUSH
49640: LD_INT 25
49642: PUSH
49643: LD_INT 1
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 25
49652: PUSH
49653: LD_INT 5
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: LD_INT 25
49662: PUSH
49663: LD_INT 8
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PUSH
49670: LD_INT 25
49672: PUSH
49673: LD_INT 9
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: LIST
49686: PPUSH
49687: CALL_OW 72
49691: ST_TO_ADDR
// if not defenders and not solds then
49692: LD_VAR 0 2
49696: NOT
49697: PUSH
49698: LD_VAR 0 9
49702: NOT
49703: AND
49704: IFFALSE 49708
// exit ;
49706: GO 51334
// depot_under_attack := false ;
49708: LD_ADDR_VAR 0 17
49712: PUSH
49713: LD_INT 0
49715: ST_TO_ADDR
// sold_defenders := [ ] ;
49716: LD_ADDR_VAR 0 18
49720: PUSH
49721: EMPTY
49722: ST_TO_ADDR
// if mechs then
49723: LD_VAR 0 13
49727: IFFALSE 49856
// for i in defenders do
49729: LD_ADDR_VAR 0 5
49733: PUSH
49734: LD_VAR 0 2
49738: PUSH
49739: FOR_IN
49740: IFFALSE 49854
// begin SetTag ( i , 20 ) ;
49742: LD_VAR 0 5
49746: PPUSH
49747: LD_INT 20
49749: PPUSH
49750: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
49754: LD_VAR 0 5
49758: PPUSH
49759: CALL_OW 263
49763: PUSH
49764: LD_INT 1
49766: EQUAL
49767: PUSH
49768: LD_VAR 0 5
49772: PPUSH
49773: CALL_OW 311
49777: NOT
49778: AND
49779: PUSH
49780: LD_VAR 0 13
49784: AND
49785: IFFALSE 49852
// begin un := mechs [ 1 ] ;
49787: LD_ADDR_VAR 0 11
49791: PUSH
49792: LD_VAR 0 13
49796: PUSH
49797: LD_INT 1
49799: ARRAY
49800: ST_TO_ADDR
// ComExitBuilding ( un ) ;
49801: LD_VAR 0 11
49805: PPUSH
49806: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
49810: LD_VAR 0 11
49814: PPUSH
49815: LD_VAR 0 5
49819: PPUSH
49820: CALL_OW 180
// SetTag ( un , 19 ) ;
49824: LD_VAR 0 11
49828: PPUSH
49829: LD_INT 19
49831: PPUSH
49832: CALL_OW 109
// mechs := mechs diff un ;
49836: LD_ADDR_VAR 0 13
49840: PUSH
49841: LD_VAR 0 13
49845: PUSH
49846: LD_VAR 0 11
49850: DIFF
49851: ST_TO_ADDR
// end ; end ;
49852: GO 49739
49854: POP
49855: POP
// if solds then
49856: LD_VAR 0 9
49860: IFFALSE 49919
// for i in solds do
49862: LD_ADDR_VAR 0 5
49866: PUSH
49867: LD_VAR 0 9
49871: PUSH
49872: FOR_IN
49873: IFFALSE 49917
// if not GetTag ( i ) then
49875: LD_VAR 0 5
49879: PPUSH
49880: CALL_OW 110
49884: NOT
49885: IFFALSE 49915
// begin defenders := defenders union i ;
49887: LD_ADDR_VAR 0 2
49891: PUSH
49892: LD_VAR 0 2
49896: PUSH
49897: LD_VAR 0 5
49901: UNION
49902: ST_TO_ADDR
// SetTag ( i , 18 ) ;
49903: LD_VAR 0 5
49907: PPUSH
49908: LD_INT 18
49910: PPUSH
49911: CALL_OW 109
// end ;
49915: GO 49872
49917: POP
49918: POP
// repeat wait ( 0 0$1 ) ;
49919: LD_INT 35
49921: PPUSH
49922: CALL_OW 67
// enemy := mc_scan [ base ] ;
49926: LD_ADDR_VAR 0 3
49930: PUSH
49931: LD_EXP 73
49935: PUSH
49936: LD_VAR 0 1
49940: ARRAY
49941: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49942: LD_EXP 50
49946: PUSH
49947: LD_VAR 0 1
49951: ARRAY
49952: NOT
49953: PUSH
49954: LD_EXP 50
49958: PUSH
49959: LD_VAR 0 1
49963: ARRAY
49964: PUSH
49965: EMPTY
49966: EQUAL
49967: OR
49968: IFFALSE 50005
// begin for i in defenders do
49970: LD_ADDR_VAR 0 5
49974: PUSH
49975: LD_VAR 0 2
49979: PUSH
49980: FOR_IN
49981: IFFALSE 49994
// ComStop ( i ) ;
49983: LD_VAR 0 5
49987: PPUSH
49988: CALL_OW 141
49992: GO 49980
49994: POP
49995: POP
// defenders := [ ] ;
49996: LD_ADDR_VAR 0 2
50000: PUSH
50001: EMPTY
50002: ST_TO_ADDR
// exit ;
50003: GO 51334
// end ; for i in defenders do
50005: LD_ADDR_VAR 0 5
50009: PUSH
50010: LD_VAR 0 2
50014: PUSH
50015: FOR_IN
50016: IFFALSE 50834
// begin e := NearestUnitToUnit ( enemy , i ) ;
50018: LD_ADDR_VAR 0 14
50022: PUSH
50023: LD_VAR 0 3
50027: PPUSH
50028: LD_VAR 0 5
50032: PPUSH
50033: CALL_OW 74
50037: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50038: LD_ADDR_VAR 0 8
50042: PUSH
50043: LD_EXP 50
50047: PUSH
50048: LD_VAR 0 1
50052: ARRAY
50053: PPUSH
50054: LD_INT 2
50056: PUSH
50057: LD_INT 30
50059: PUSH
50060: LD_INT 0
50062: PUSH
50063: EMPTY
50064: LIST
50065: LIST
50066: PUSH
50067: LD_INT 30
50069: PUSH
50070: LD_INT 1
50072: PUSH
50073: EMPTY
50074: LIST
50075: LIST
50076: PUSH
50077: EMPTY
50078: LIST
50079: LIST
50080: LIST
50081: PPUSH
50082: CALL_OW 72
50086: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
50087: LD_ADDR_VAR 0 17
50091: PUSH
50092: LD_VAR 0 8
50096: NOT
50097: PUSH
50098: LD_VAR 0 8
50102: PPUSH
50103: LD_INT 3
50105: PUSH
50106: LD_INT 24
50108: PUSH
50109: LD_INT 600
50111: PUSH
50112: EMPTY
50113: LIST
50114: LIST
50115: PUSH
50116: EMPTY
50117: LIST
50118: LIST
50119: PPUSH
50120: CALL_OW 72
50124: OR
50125: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
50126: LD_VAR 0 5
50130: PPUSH
50131: CALL_OW 247
50135: PUSH
50136: LD_INT 2
50138: DOUBLE
50139: EQUAL
50140: IFTRUE 50144
50142: GO 50540
50144: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
50145: LD_VAR 0 5
50149: PPUSH
50150: CALL_OW 256
50154: PUSH
50155: LD_INT 650
50157: GREATER
50158: PUSH
50159: LD_VAR 0 5
50163: PPUSH
50164: LD_VAR 0 14
50168: PPUSH
50169: CALL_OW 296
50173: PUSH
50174: LD_INT 40
50176: LESS
50177: PUSH
50178: LD_VAR 0 14
50182: PPUSH
50183: LD_EXP 75
50187: PUSH
50188: LD_VAR 0 1
50192: ARRAY
50193: PPUSH
50194: CALL_OW 308
50198: OR
50199: AND
50200: IFFALSE 50322
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
50202: LD_VAR 0 5
50206: PPUSH
50207: CALL_OW 262
50211: PUSH
50212: LD_INT 1
50214: EQUAL
50215: PUSH
50216: LD_VAR 0 5
50220: PPUSH
50221: CALL_OW 261
50225: PUSH
50226: LD_INT 30
50228: LESS
50229: AND
50230: PUSH
50231: LD_VAR 0 8
50235: AND
50236: IFFALSE 50306
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
50238: LD_VAR 0 5
50242: PPUSH
50243: LD_VAR 0 8
50247: PPUSH
50248: LD_VAR 0 5
50252: PPUSH
50253: CALL_OW 74
50257: PPUSH
50258: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
50262: LD_VAR 0 5
50266: PPUSH
50267: LD_VAR 0 8
50271: PPUSH
50272: LD_VAR 0 5
50276: PPUSH
50277: CALL_OW 74
50281: PPUSH
50282: CALL_OW 296
50286: PUSH
50287: LD_INT 6
50289: LESS
50290: IFFALSE 50304
// SetFuel ( i , 100 ) ;
50292: LD_VAR 0 5
50296: PPUSH
50297: LD_INT 100
50299: PPUSH
50300: CALL_OW 240
// end else
50304: GO 50320
// ComAttackUnit ( i , e ) ;
50306: LD_VAR 0 5
50310: PPUSH
50311: LD_VAR 0 14
50315: PPUSH
50316: CALL_OW 115
// end else
50320: GO 50423
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
50322: LD_VAR 0 14
50326: PPUSH
50327: LD_EXP 75
50331: PUSH
50332: LD_VAR 0 1
50336: ARRAY
50337: PPUSH
50338: CALL_OW 308
50342: NOT
50343: PUSH
50344: LD_VAR 0 5
50348: PPUSH
50349: LD_VAR 0 14
50353: PPUSH
50354: CALL_OW 296
50358: PUSH
50359: LD_INT 40
50361: GREATEREQUAL
50362: AND
50363: PUSH
50364: LD_VAR 0 5
50368: PPUSH
50369: CALL_OW 256
50373: PUSH
50374: LD_INT 650
50376: LESSEQUAL
50377: OR
50378: PUSH
50379: LD_VAR 0 5
50383: PPUSH
50384: LD_EXP 74
50388: PUSH
50389: LD_VAR 0 1
50393: ARRAY
50394: PPUSH
50395: CALL_OW 308
50399: NOT
50400: AND
50401: IFFALSE 50423
// ComMoveToArea ( i , mc_parking [ base ] ) ;
50403: LD_VAR 0 5
50407: PPUSH
50408: LD_EXP 74
50412: PUSH
50413: LD_VAR 0 1
50417: ARRAY
50418: PPUSH
50419: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
50423: LD_VAR 0 5
50427: PPUSH
50428: CALL_OW 256
50432: PUSH
50433: LD_INT 998
50435: LESS
50436: PUSH
50437: LD_VAR 0 5
50441: PPUSH
50442: CALL_OW 263
50446: PUSH
50447: LD_INT 1
50449: EQUAL
50450: AND
50451: PUSH
50452: LD_VAR 0 5
50456: PPUSH
50457: CALL_OW 311
50461: AND
50462: PUSH
50463: LD_VAR 0 5
50467: PPUSH
50468: LD_EXP 74
50472: PUSH
50473: LD_VAR 0 1
50477: ARRAY
50478: PPUSH
50479: CALL_OW 308
50483: AND
50484: IFFALSE 50538
// begin mech := IsDrivenBy ( i ) ;
50486: LD_ADDR_VAR 0 10
50490: PUSH
50491: LD_VAR 0 5
50495: PPUSH
50496: CALL_OW 311
50500: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
50501: LD_VAR 0 10
50505: PPUSH
50506: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
50510: LD_VAR 0 10
50514: PPUSH
50515: LD_VAR 0 5
50519: PPUSH
50520: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
50524: LD_VAR 0 10
50528: PPUSH
50529: LD_VAR 0 5
50533: PPUSH
50534: CALL_OW 180
// end ; end ; unit_human :
50538: GO 50805
50540: LD_INT 1
50542: DOUBLE
50543: EQUAL
50544: IFTRUE 50548
50546: GO 50804
50548: POP
// begin b := IsInUnit ( i ) ;
50549: LD_ADDR_VAR 0 19
50553: PUSH
50554: LD_VAR 0 5
50558: PPUSH
50559: CALL_OW 310
50563: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
50564: LD_ADDR_VAR 0 20
50568: PUSH
50569: LD_VAR 0 19
50573: NOT
50574: PUSH
50575: LD_VAR 0 19
50579: PPUSH
50580: CALL_OW 266
50584: PUSH
50585: LD_INT 32
50587: PUSH
50588: LD_INT 31
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: IN
50595: OR
50596: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
50597: LD_VAR 0 17
50601: PUSH
50602: LD_VAR 0 2
50606: PPUSH
50607: LD_INT 21
50609: PUSH
50610: LD_INT 2
50612: PUSH
50613: EMPTY
50614: LIST
50615: LIST
50616: PPUSH
50617: CALL_OW 72
50621: PUSH
50622: LD_INT 1
50624: LESSEQUAL
50625: OR
50626: PUSH
50627: LD_VAR 0 20
50631: AND
50632: PUSH
50633: LD_VAR 0 5
50637: PUSH
50638: LD_VAR 0 18
50642: IN
50643: NOT
50644: AND
50645: IFFALSE 50738
// begin if b then
50647: LD_VAR 0 19
50651: IFFALSE 50700
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
50653: LD_VAR 0 19
50657: PPUSH
50658: LD_VAR 0 3
50662: PPUSH
50663: LD_VAR 0 19
50667: PPUSH
50668: CALL_OW 74
50672: PPUSH
50673: CALL_OW 296
50677: PUSH
50678: LD_INT 10
50680: LESS
50681: PUSH
50682: LD_VAR 0 19
50686: PPUSH
50687: CALL_OW 461
50691: PUSH
50692: LD_INT 7
50694: NONEQUAL
50695: AND
50696: IFFALSE 50700
// continue ;
50698: GO 50015
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
50700: LD_ADDR_VAR 0 18
50704: PUSH
50705: LD_VAR 0 18
50709: PPUSH
50710: LD_VAR 0 18
50714: PUSH
50715: LD_INT 1
50717: PLUS
50718: PPUSH
50719: LD_VAR 0 5
50723: PPUSH
50724: CALL_OW 1
50728: ST_TO_ADDR
// ComExitBuilding ( i ) ;
50729: LD_VAR 0 5
50733: PPUSH
50734: CALL_OW 122
// end ; if sold_defenders then
50738: LD_VAR 0 18
50742: IFFALSE 50802
// if i in sold_defenders then
50744: LD_VAR 0 5
50748: PUSH
50749: LD_VAR 0 18
50753: IN
50754: IFFALSE 50802
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
50756: LD_VAR 0 5
50760: PPUSH
50761: CALL_OW 314
50765: NOT
50766: PUSH
50767: LD_VAR 0 5
50771: PPUSH
50772: LD_VAR 0 14
50776: PPUSH
50777: CALL_OW 296
50781: PUSH
50782: LD_INT 30
50784: LESS
50785: AND
50786: IFFALSE 50802
// ComAttackUnit ( i , e ) ;
50788: LD_VAR 0 5
50792: PPUSH
50793: LD_VAR 0 14
50797: PPUSH
50798: CALL_OW 115
// end ; end ; end ;
50802: GO 50805
50804: POP
// if IsDead ( i ) then
50805: LD_VAR 0 5
50809: PPUSH
50810: CALL_OW 301
50814: IFFALSE 50832
// defenders := defenders diff i ;
50816: LD_ADDR_VAR 0 2
50820: PUSH
50821: LD_VAR 0 2
50825: PUSH
50826: LD_VAR 0 5
50830: DIFF
50831: ST_TO_ADDR
// end ;
50832: GO 50015
50834: POP
50835: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
50836: LD_VAR 0 3
50840: NOT
50841: PUSH
50842: LD_VAR 0 2
50846: NOT
50847: OR
50848: PUSH
50849: LD_EXP 50
50853: PUSH
50854: LD_VAR 0 1
50858: ARRAY
50859: NOT
50860: OR
50861: IFFALSE 49919
// MC_Reset ( base , 18 ) ;
50863: LD_VAR 0 1
50867: PPUSH
50868: LD_INT 18
50870: PPUSH
50871: CALL 21305 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50875: LD_ADDR_VAR 0 2
50879: PUSH
50880: LD_VAR 0 2
50884: PUSH
50885: LD_VAR 0 2
50889: PPUSH
50890: LD_INT 2
50892: PUSH
50893: LD_INT 25
50895: PUSH
50896: LD_INT 1
50898: PUSH
50899: EMPTY
50900: LIST
50901: LIST
50902: PUSH
50903: LD_INT 25
50905: PUSH
50906: LD_INT 5
50908: PUSH
50909: EMPTY
50910: LIST
50911: LIST
50912: PUSH
50913: LD_INT 25
50915: PUSH
50916: LD_INT 8
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: PUSH
50923: LD_INT 25
50925: PUSH
50926: LD_INT 9
50928: PUSH
50929: EMPTY
50930: LIST
50931: LIST
50932: PUSH
50933: EMPTY
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: PPUSH
50940: CALL_OW 72
50944: DIFF
50945: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
50946: LD_VAR 0 3
50950: NOT
50951: PUSH
50952: LD_VAR 0 2
50956: PPUSH
50957: LD_INT 21
50959: PUSH
50960: LD_INT 2
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: PPUSH
50967: CALL_OW 72
50971: AND
50972: IFFALSE 51310
// begin tmp := FilterByTag ( defenders , 19 ) ;
50974: LD_ADDR_VAR 0 12
50978: PUSH
50979: LD_VAR 0 2
50983: PPUSH
50984: LD_INT 19
50986: PPUSH
50987: CALL 87789 0 2
50991: ST_TO_ADDR
// if tmp then
50992: LD_VAR 0 12
50996: IFFALSE 51066
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
50998: LD_ADDR_VAR 0 12
51002: PUSH
51003: LD_VAR 0 12
51007: PPUSH
51008: LD_INT 25
51010: PUSH
51011: LD_INT 3
51013: PUSH
51014: EMPTY
51015: LIST
51016: LIST
51017: PPUSH
51018: CALL_OW 72
51022: ST_TO_ADDR
// if tmp then
51023: LD_VAR 0 12
51027: IFFALSE 51066
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
51029: LD_ADDR_EXP 62
51033: PUSH
51034: LD_EXP 62
51038: PPUSH
51039: LD_VAR 0 1
51043: PPUSH
51044: LD_EXP 62
51048: PUSH
51049: LD_VAR 0 1
51053: ARRAY
51054: PUSH
51055: LD_VAR 0 12
51059: UNION
51060: PPUSH
51061: CALL_OW 1
51065: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
51066: LD_VAR 0 1
51070: PPUSH
51071: LD_INT 19
51073: PPUSH
51074: CALL 21305 0 2
// repeat wait ( 0 0$1 ) ;
51078: LD_INT 35
51080: PPUSH
51081: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
51085: LD_EXP 50
51089: PUSH
51090: LD_VAR 0 1
51094: ARRAY
51095: NOT
51096: PUSH
51097: LD_EXP 50
51101: PUSH
51102: LD_VAR 0 1
51106: ARRAY
51107: PUSH
51108: EMPTY
51109: EQUAL
51110: OR
51111: IFFALSE 51148
// begin for i in defenders do
51113: LD_ADDR_VAR 0 5
51117: PUSH
51118: LD_VAR 0 2
51122: PUSH
51123: FOR_IN
51124: IFFALSE 51137
// ComStop ( i ) ;
51126: LD_VAR 0 5
51130: PPUSH
51131: CALL_OW 141
51135: GO 51123
51137: POP
51138: POP
// defenders := [ ] ;
51139: LD_ADDR_VAR 0 2
51143: PUSH
51144: EMPTY
51145: ST_TO_ADDR
// exit ;
51146: GO 51334
// end ; for i in defenders do
51148: LD_ADDR_VAR 0 5
51152: PUSH
51153: LD_VAR 0 2
51157: PUSH
51158: FOR_IN
51159: IFFALSE 51248
// begin if not IsInArea ( i , mc_parking [ base ] ) then
51161: LD_VAR 0 5
51165: PPUSH
51166: LD_EXP 74
51170: PUSH
51171: LD_VAR 0 1
51175: ARRAY
51176: PPUSH
51177: CALL_OW 308
51181: NOT
51182: IFFALSE 51206
// ComMoveToArea ( i , mc_parking [ base ] ) else
51184: LD_VAR 0 5
51188: PPUSH
51189: LD_EXP 74
51193: PUSH
51194: LD_VAR 0 1
51198: ARRAY
51199: PPUSH
51200: CALL_OW 113
51204: GO 51246
// if GetControl ( i ) = control_manual then
51206: LD_VAR 0 5
51210: PPUSH
51211: CALL_OW 263
51215: PUSH
51216: LD_INT 1
51218: EQUAL
51219: IFFALSE 51246
// if IsDrivenBy ( i ) then
51221: LD_VAR 0 5
51225: PPUSH
51226: CALL_OW 311
51230: IFFALSE 51246
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
51232: LD_VAR 0 5
51236: PPUSH
51237: CALL_OW 311
51241: PPUSH
51242: CALL_OW 121
// end ;
51246: GO 51158
51248: POP
51249: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
51250: LD_VAR 0 2
51254: PPUSH
51255: LD_INT 95
51257: PUSH
51258: LD_EXP 74
51262: PUSH
51263: LD_VAR 0 1
51267: ARRAY
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: PPUSH
51273: CALL_OW 72
51277: PUSH
51278: LD_VAR 0 2
51282: EQUAL
51283: PUSH
51284: LD_EXP 73
51288: PUSH
51289: LD_VAR 0 1
51293: ARRAY
51294: OR
51295: PUSH
51296: LD_EXP 50
51300: PUSH
51301: LD_VAR 0 1
51305: ARRAY
51306: NOT
51307: OR
51308: IFFALSE 51078
// end ; MC_Reset ( base , 19 ) ;
51310: LD_VAR 0 1
51314: PPUSH
51315: LD_INT 19
51317: PPUSH
51318: CALL 21305 0 2
// MC_Reset ( base , 20 ) ;
51322: LD_VAR 0 1
51326: PPUSH
51327: LD_INT 20
51329: PPUSH
51330: CALL 21305 0 2
// end ;
51334: LD_VAR 0 4
51338: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
51339: LD_INT 0
51341: PPUSH
51342: PPUSH
51343: PPUSH
51344: PPUSH
// result := false ;
51345: LD_ADDR_VAR 0 2
51349: PUSH
51350: LD_INT 0
51352: ST_TO_ADDR
// side := GetSide ( unit ) ;
51353: LD_ADDR_VAR 0 3
51357: PUSH
51358: LD_VAR 0 1
51362: PPUSH
51363: CALL_OW 255
51367: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51368: LD_ADDR_VAR 0 4
51372: PUSH
51373: LD_VAR 0 1
51377: PPUSH
51378: CALL_OW 248
51382: ST_TO_ADDR
// case nat of 1 :
51383: LD_VAR 0 4
51387: PUSH
51388: LD_INT 1
51390: DOUBLE
51391: EQUAL
51392: IFTRUE 51396
51394: GO 51407
51396: POP
// tech := tech_lassight ; 2 :
51397: LD_ADDR_VAR 0 5
51401: PUSH
51402: LD_INT 12
51404: ST_TO_ADDR
51405: GO 51446
51407: LD_INT 2
51409: DOUBLE
51410: EQUAL
51411: IFTRUE 51415
51413: GO 51426
51415: POP
// tech := tech_mortar ; 3 :
51416: LD_ADDR_VAR 0 5
51420: PUSH
51421: LD_INT 41
51423: ST_TO_ADDR
51424: GO 51446
51426: LD_INT 3
51428: DOUBLE
51429: EQUAL
51430: IFTRUE 51434
51432: GO 51445
51434: POP
// tech := tech_bazooka ; end ;
51435: LD_ADDR_VAR 0 5
51439: PUSH
51440: LD_INT 44
51442: ST_TO_ADDR
51443: GO 51446
51445: POP
// if Researched ( side , tech ) then
51446: LD_VAR 0 3
51450: PPUSH
51451: LD_VAR 0 5
51455: PPUSH
51456: CALL_OW 325
51460: IFFALSE 51487
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51462: LD_ADDR_VAR 0 2
51466: PUSH
51467: LD_INT 5
51469: PUSH
51470: LD_INT 8
51472: PUSH
51473: LD_INT 9
51475: PUSH
51476: EMPTY
51477: LIST
51478: LIST
51479: LIST
51480: PUSH
51481: LD_VAR 0 4
51485: ARRAY
51486: ST_TO_ADDR
// end ;
51487: LD_VAR 0 2
51491: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51492: LD_INT 0
51494: PPUSH
51495: PPUSH
51496: PPUSH
// if not mines then
51497: LD_VAR 0 2
51501: NOT
51502: IFFALSE 51506
// exit ;
51504: GO 51650
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51506: LD_ADDR_VAR 0 5
51510: PUSH
51511: LD_INT 81
51513: PUSH
51514: LD_VAR 0 1
51518: PUSH
51519: EMPTY
51520: LIST
51521: LIST
51522: PUSH
51523: LD_INT 3
51525: PUSH
51526: LD_INT 21
51528: PUSH
51529: LD_INT 3
51531: PUSH
51532: EMPTY
51533: LIST
51534: LIST
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: PUSH
51540: EMPTY
51541: LIST
51542: LIST
51543: PPUSH
51544: CALL_OW 69
51548: ST_TO_ADDR
// for i in mines do
51549: LD_ADDR_VAR 0 4
51553: PUSH
51554: LD_VAR 0 2
51558: PUSH
51559: FOR_IN
51560: IFFALSE 51648
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51562: LD_VAR 0 4
51566: PUSH
51567: LD_INT 1
51569: ARRAY
51570: PPUSH
51571: LD_VAR 0 4
51575: PUSH
51576: LD_INT 2
51578: ARRAY
51579: PPUSH
51580: CALL_OW 458
51584: NOT
51585: IFFALSE 51589
// continue ;
51587: GO 51559
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51589: LD_VAR 0 4
51593: PUSH
51594: LD_INT 1
51596: ARRAY
51597: PPUSH
51598: LD_VAR 0 4
51602: PUSH
51603: LD_INT 2
51605: ARRAY
51606: PPUSH
51607: CALL_OW 428
51611: PUSH
51612: LD_VAR 0 5
51616: IN
51617: IFFALSE 51646
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51619: LD_VAR 0 4
51623: PUSH
51624: LD_INT 1
51626: ARRAY
51627: PPUSH
51628: LD_VAR 0 4
51632: PUSH
51633: LD_INT 2
51635: ARRAY
51636: PPUSH
51637: LD_VAR 0 1
51641: PPUSH
51642: CALL_OW 456
// end ;
51646: GO 51559
51648: POP
51649: POP
// end ;
51650: LD_VAR 0 3
51654: RET
// export function Count ( array ) ; var i ; begin
51655: LD_INT 0
51657: PPUSH
51658: PPUSH
// result := 0 ;
51659: LD_ADDR_VAR 0 2
51663: PUSH
51664: LD_INT 0
51666: ST_TO_ADDR
// for i in array do
51667: LD_ADDR_VAR 0 3
51671: PUSH
51672: LD_VAR 0 1
51676: PUSH
51677: FOR_IN
51678: IFFALSE 51702
// if i then
51680: LD_VAR 0 3
51684: IFFALSE 51700
// result := result + 1 ;
51686: LD_ADDR_VAR 0 2
51690: PUSH
51691: LD_VAR 0 2
51695: PUSH
51696: LD_INT 1
51698: PLUS
51699: ST_TO_ADDR
51700: GO 51677
51702: POP
51703: POP
// end ;
51704: LD_VAR 0 2
51708: RET
// export function IsEmpty ( building ) ; begin
51709: LD_INT 0
51711: PPUSH
// if not building then
51712: LD_VAR 0 1
51716: NOT
51717: IFFALSE 51721
// exit ;
51719: GO 51764
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51721: LD_ADDR_VAR 0 2
51725: PUSH
51726: LD_VAR 0 1
51730: PUSH
51731: LD_INT 22
51733: PUSH
51734: LD_VAR 0 1
51738: PPUSH
51739: CALL_OW 255
51743: PUSH
51744: EMPTY
51745: LIST
51746: LIST
51747: PUSH
51748: LD_INT 58
51750: PUSH
51751: EMPTY
51752: LIST
51753: PUSH
51754: EMPTY
51755: LIST
51756: LIST
51757: PPUSH
51758: CALL_OW 69
51762: IN
51763: ST_TO_ADDR
// end ;
51764: LD_VAR 0 2
51768: RET
// export function IsNotFull ( building ) ; begin
51769: LD_INT 0
51771: PPUSH
// if not building then
51772: LD_VAR 0 1
51776: NOT
51777: IFFALSE 51781
// exit ;
51779: GO 51800
// result := UnitsInside ( building ) < 6 ;
51781: LD_ADDR_VAR 0 2
51785: PUSH
51786: LD_VAR 0 1
51790: PPUSH
51791: CALL_OW 313
51795: PUSH
51796: LD_INT 6
51798: LESS
51799: ST_TO_ADDR
// end ;
51800: LD_VAR 0 2
51804: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51805: LD_INT 0
51807: PPUSH
51808: PPUSH
51809: PPUSH
51810: PPUSH
// tmp := [ ] ;
51811: LD_ADDR_VAR 0 3
51815: PUSH
51816: EMPTY
51817: ST_TO_ADDR
// list := [ ] ;
51818: LD_ADDR_VAR 0 5
51822: PUSH
51823: EMPTY
51824: ST_TO_ADDR
// for i = 16 to 25 do
51825: LD_ADDR_VAR 0 4
51829: PUSH
51830: DOUBLE
51831: LD_INT 16
51833: DEC
51834: ST_TO_ADDR
51835: LD_INT 25
51837: PUSH
51838: FOR_TO
51839: IFFALSE 51912
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51841: LD_ADDR_VAR 0 3
51845: PUSH
51846: LD_VAR 0 3
51850: PUSH
51851: LD_INT 22
51853: PUSH
51854: LD_VAR 0 1
51858: PPUSH
51859: CALL_OW 255
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: PUSH
51868: LD_INT 91
51870: PUSH
51871: LD_VAR 0 1
51875: PUSH
51876: LD_INT 6
51878: PUSH
51879: EMPTY
51880: LIST
51881: LIST
51882: LIST
51883: PUSH
51884: LD_INT 30
51886: PUSH
51887: LD_VAR 0 4
51891: PUSH
51892: EMPTY
51893: LIST
51894: LIST
51895: PUSH
51896: EMPTY
51897: LIST
51898: LIST
51899: LIST
51900: PUSH
51901: EMPTY
51902: LIST
51903: PPUSH
51904: CALL_OW 69
51908: ADD
51909: ST_TO_ADDR
51910: GO 51838
51912: POP
51913: POP
// for i = 1 to tmp do
51914: LD_ADDR_VAR 0 4
51918: PUSH
51919: DOUBLE
51920: LD_INT 1
51922: DEC
51923: ST_TO_ADDR
51924: LD_VAR 0 3
51928: PUSH
51929: FOR_TO
51930: IFFALSE 52018
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51932: LD_ADDR_VAR 0 5
51936: PUSH
51937: LD_VAR 0 5
51941: PUSH
51942: LD_VAR 0 3
51946: PUSH
51947: LD_VAR 0 4
51951: ARRAY
51952: PPUSH
51953: CALL_OW 266
51957: PUSH
51958: LD_VAR 0 3
51962: PUSH
51963: LD_VAR 0 4
51967: ARRAY
51968: PPUSH
51969: CALL_OW 250
51973: PUSH
51974: LD_VAR 0 3
51978: PUSH
51979: LD_VAR 0 4
51983: ARRAY
51984: PPUSH
51985: CALL_OW 251
51989: PUSH
51990: LD_VAR 0 3
51994: PUSH
51995: LD_VAR 0 4
51999: ARRAY
52000: PPUSH
52001: CALL_OW 254
52005: PUSH
52006: EMPTY
52007: LIST
52008: LIST
52009: LIST
52010: LIST
52011: PUSH
52012: EMPTY
52013: LIST
52014: ADD
52015: ST_TO_ADDR
52016: GO 51929
52018: POP
52019: POP
// result := list ;
52020: LD_ADDR_VAR 0 2
52024: PUSH
52025: LD_VAR 0 5
52029: ST_TO_ADDR
// end ;
52030: LD_VAR 0 2
52034: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
52035: LD_INT 0
52037: PPUSH
52038: PPUSH
52039: PPUSH
52040: PPUSH
52041: PPUSH
52042: PPUSH
52043: PPUSH
// if not factory then
52044: LD_VAR 0 1
52048: NOT
52049: IFFALSE 52053
// exit ;
52051: GO 52646
// if control = control_apeman then
52053: LD_VAR 0 4
52057: PUSH
52058: LD_INT 5
52060: EQUAL
52061: IFFALSE 52170
// begin tmp := UnitsInside ( factory ) ;
52063: LD_ADDR_VAR 0 8
52067: PUSH
52068: LD_VAR 0 1
52072: PPUSH
52073: CALL_OW 313
52077: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
52078: LD_VAR 0 8
52082: PPUSH
52083: LD_INT 25
52085: PUSH
52086: LD_INT 12
52088: PUSH
52089: EMPTY
52090: LIST
52091: LIST
52092: PPUSH
52093: CALL_OW 72
52097: NOT
52098: IFFALSE 52108
// control := control_manual ;
52100: LD_ADDR_VAR 0 4
52104: PUSH
52105: LD_INT 1
52107: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
52108: LD_ADDR_VAR 0 8
52112: PUSH
52113: LD_VAR 0 1
52117: PPUSH
52118: CALL 51805 0 1
52122: ST_TO_ADDR
// if tmp then
52123: LD_VAR 0 8
52127: IFFALSE 52170
// begin for i in tmp do
52129: LD_ADDR_VAR 0 7
52133: PUSH
52134: LD_VAR 0 8
52138: PUSH
52139: FOR_IN
52140: IFFALSE 52168
// if i [ 1 ] = b_ext_radio then
52142: LD_VAR 0 7
52146: PUSH
52147: LD_INT 1
52149: ARRAY
52150: PUSH
52151: LD_INT 22
52153: EQUAL
52154: IFFALSE 52166
// begin control := control_remote ;
52156: LD_ADDR_VAR 0 4
52160: PUSH
52161: LD_INT 2
52163: ST_TO_ADDR
// break ;
52164: GO 52168
// end ;
52166: GO 52139
52168: POP
52169: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52170: LD_VAR 0 1
52174: PPUSH
52175: LD_VAR 0 2
52179: PPUSH
52180: LD_VAR 0 3
52184: PPUSH
52185: LD_VAR 0 4
52189: PPUSH
52190: LD_VAR 0 5
52194: PPUSH
52195: CALL_OW 448
52199: IFFALSE 52234
// begin result := [ chassis , engine , control , weapon ] ;
52201: LD_ADDR_VAR 0 6
52205: PUSH
52206: LD_VAR 0 2
52210: PUSH
52211: LD_VAR 0 3
52215: PUSH
52216: LD_VAR 0 4
52220: PUSH
52221: LD_VAR 0 5
52225: PUSH
52226: EMPTY
52227: LIST
52228: LIST
52229: LIST
52230: LIST
52231: ST_TO_ADDR
// exit ;
52232: GO 52646
// end ; _chassis := AvailableChassisList ( factory ) ;
52234: LD_ADDR_VAR 0 9
52238: PUSH
52239: LD_VAR 0 1
52243: PPUSH
52244: CALL_OW 475
52248: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
52249: LD_ADDR_VAR 0 11
52253: PUSH
52254: LD_VAR 0 1
52258: PPUSH
52259: CALL_OW 476
52263: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
52264: LD_ADDR_VAR 0 12
52268: PUSH
52269: LD_VAR 0 1
52273: PPUSH
52274: CALL_OW 477
52278: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
52279: LD_ADDR_VAR 0 10
52283: PUSH
52284: LD_VAR 0 1
52288: PPUSH
52289: CALL_OW 478
52293: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
52294: LD_VAR 0 9
52298: NOT
52299: PUSH
52300: LD_VAR 0 11
52304: NOT
52305: OR
52306: PUSH
52307: LD_VAR 0 12
52311: NOT
52312: OR
52313: PUSH
52314: LD_VAR 0 10
52318: NOT
52319: OR
52320: IFFALSE 52355
// begin result := [ chassis , engine , control , weapon ] ;
52322: LD_ADDR_VAR 0 6
52326: PUSH
52327: LD_VAR 0 2
52331: PUSH
52332: LD_VAR 0 3
52336: PUSH
52337: LD_VAR 0 4
52341: PUSH
52342: LD_VAR 0 5
52346: PUSH
52347: EMPTY
52348: LIST
52349: LIST
52350: LIST
52351: LIST
52352: ST_TO_ADDR
// exit ;
52353: GO 52646
// end ; if not chassis in _chassis then
52355: LD_VAR 0 2
52359: PUSH
52360: LD_VAR 0 9
52364: IN
52365: NOT
52366: IFFALSE 52392
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
52368: LD_ADDR_VAR 0 2
52372: PUSH
52373: LD_VAR 0 9
52377: PUSH
52378: LD_INT 1
52380: PPUSH
52381: LD_VAR 0 9
52385: PPUSH
52386: CALL_OW 12
52390: ARRAY
52391: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52392: LD_VAR 0 2
52396: PPUSH
52397: LD_VAR 0 3
52401: PPUSH
52402: CALL 52651 0 2
52406: NOT
52407: IFFALSE 52466
// repeat engine := _engine [ 1 ] ;
52409: LD_ADDR_VAR 0 3
52413: PUSH
52414: LD_VAR 0 11
52418: PUSH
52419: LD_INT 1
52421: ARRAY
52422: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52423: LD_ADDR_VAR 0 11
52427: PUSH
52428: LD_VAR 0 11
52432: PPUSH
52433: LD_INT 1
52435: PPUSH
52436: CALL_OW 3
52440: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52441: LD_VAR 0 2
52445: PPUSH
52446: LD_VAR 0 3
52450: PPUSH
52451: CALL 52651 0 2
52455: PUSH
52456: LD_VAR 0 11
52460: PUSH
52461: EMPTY
52462: EQUAL
52463: OR
52464: IFFALSE 52409
// if not control in _control then
52466: LD_VAR 0 4
52470: PUSH
52471: LD_VAR 0 12
52475: IN
52476: NOT
52477: IFFALSE 52503
// control := _control [ rand ( 1 , _control ) ] ;
52479: LD_ADDR_VAR 0 4
52483: PUSH
52484: LD_VAR 0 12
52488: PUSH
52489: LD_INT 1
52491: PPUSH
52492: LD_VAR 0 12
52496: PPUSH
52497: CALL_OW 12
52501: ARRAY
52502: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52503: LD_VAR 0 2
52507: PPUSH
52508: LD_VAR 0 5
52512: PPUSH
52513: CALL 52871 0 2
52517: NOT
52518: IFFALSE 52577
// repeat weapon := _weapon [ 1 ] ;
52520: LD_ADDR_VAR 0 5
52524: PUSH
52525: LD_VAR 0 10
52529: PUSH
52530: LD_INT 1
52532: ARRAY
52533: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52534: LD_ADDR_VAR 0 10
52538: PUSH
52539: LD_VAR 0 10
52543: PPUSH
52544: LD_INT 1
52546: PPUSH
52547: CALL_OW 3
52551: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52552: LD_VAR 0 2
52556: PPUSH
52557: LD_VAR 0 5
52561: PPUSH
52562: CALL 52871 0 2
52566: PUSH
52567: LD_VAR 0 10
52571: PUSH
52572: EMPTY
52573: EQUAL
52574: OR
52575: IFFALSE 52520
// result := [ ] ;
52577: LD_ADDR_VAR 0 6
52581: PUSH
52582: EMPTY
52583: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52584: LD_VAR 0 1
52588: PPUSH
52589: LD_VAR 0 2
52593: PPUSH
52594: LD_VAR 0 3
52598: PPUSH
52599: LD_VAR 0 4
52603: PPUSH
52604: LD_VAR 0 5
52608: PPUSH
52609: CALL_OW 448
52613: IFFALSE 52646
// result := [ chassis , engine , control , weapon ] ;
52615: LD_ADDR_VAR 0 6
52619: PUSH
52620: LD_VAR 0 2
52624: PUSH
52625: LD_VAR 0 3
52629: PUSH
52630: LD_VAR 0 4
52634: PUSH
52635: LD_VAR 0 5
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: LIST
52644: LIST
52645: ST_TO_ADDR
// end ;
52646: LD_VAR 0 6
52650: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52651: LD_INT 0
52653: PPUSH
// if not chassis or not engine then
52654: LD_VAR 0 1
52658: NOT
52659: PUSH
52660: LD_VAR 0 2
52664: NOT
52665: OR
52666: IFFALSE 52670
// exit ;
52668: GO 52866
// case engine of engine_solar :
52670: LD_VAR 0 2
52674: PUSH
52675: LD_INT 2
52677: DOUBLE
52678: EQUAL
52679: IFTRUE 52683
52681: GO 52721
52683: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52684: LD_ADDR_VAR 0 3
52688: PUSH
52689: LD_INT 11
52691: PUSH
52692: LD_INT 12
52694: PUSH
52695: LD_INT 13
52697: PUSH
52698: LD_INT 14
52700: PUSH
52701: LD_INT 1
52703: PUSH
52704: LD_INT 2
52706: PUSH
52707: LD_INT 3
52709: PUSH
52710: EMPTY
52711: LIST
52712: LIST
52713: LIST
52714: LIST
52715: LIST
52716: LIST
52717: LIST
52718: ST_TO_ADDR
52719: GO 52850
52721: LD_INT 1
52723: DOUBLE
52724: EQUAL
52725: IFTRUE 52729
52727: GO 52791
52729: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52730: LD_ADDR_VAR 0 3
52734: PUSH
52735: LD_INT 11
52737: PUSH
52738: LD_INT 12
52740: PUSH
52741: LD_INT 13
52743: PUSH
52744: LD_INT 14
52746: PUSH
52747: LD_INT 1
52749: PUSH
52750: LD_INT 2
52752: PUSH
52753: LD_INT 3
52755: PUSH
52756: LD_INT 4
52758: PUSH
52759: LD_INT 5
52761: PUSH
52762: LD_INT 21
52764: PUSH
52765: LD_INT 23
52767: PUSH
52768: LD_INT 22
52770: PUSH
52771: LD_INT 24
52773: PUSH
52774: EMPTY
52775: LIST
52776: LIST
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: ST_TO_ADDR
52789: GO 52850
52791: LD_INT 3
52793: DOUBLE
52794: EQUAL
52795: IFTRUE 52799
52797: GO 52849
52799: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52800: LD_ADDR_VAR 0 3
52804: PUSH
52805: LD_INT 13
52807: PUSH
52808: LD_INT 14
52810: PUSH
52811: LD_INT 2
52813: PUSH
52814: LD_INT 3
52816: PUSH
52817: LD_INT 4
52819: PUSH
52820: LD_INT 5
52822: PUSH
52823: LD_INT 21
52825: PUSH
52826: LD_INT 22
52828: PUSH
52829: LD_INT 23
52831: PUSH
52832: LD_INT 24
52834: PUSH
52835: EMPTY
52836: LIST
52837: LIST
52838: LIST
52839: LIST
52840: LIST
52841: LIST
52842: LIST
52843: LIST
52844: LIST
52845: LIST
52846: ST_TO_ADDR
52847: GO 52850
52849: POP
// result := ( chassis in result ) ;
52850: LD_ADDR_VAR 0 3
52854: PUSH
52855: LD_VAR 0 1
52859: PUSH
52860: LD_VAR 0 3
52864: IN
52865: ST_TO_ADDR
// end ;
52866: LD_VAR 0 3
52870: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52871: LD_INT 0
52873: PPUSH
// if not chassis or not weapon then
52874: LD_VAR 0 1
52878: NOT
52879: PUSH
52880: LD_VAR 0 2
52884: NOT
52885: OR
52886: IFFALSE 52890
// exit ;
52888: GO 53916
// case weapon of us_machine_gun :
52890: LD_VAR 0 2
52894: PUSH
52895: LD_INT 2
52897: DOUBLE
52898: EQUAL
52899: IFTRUE 52903
52901: GO 52933
52903: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52904: LD_ADDR_VAR 0 3
52908: PUSH
52909: LD_INT 1
52911: PUSH
52912: LD_INT 2
52914: PUSH
52915: LD_INT 3
52917: PUSH
52918: LD_INT 4
52920: PUSH
52921: LD_INT 5
52923: PUSH
52924: EMPTY
52925: LIST
52926: LIST
52927: LIST
52928: LIST
52929: LIST
52930: ST_TO_ADDR
52931: GO 53900
52933: LD_INT 3
52935: DOUBLE
52936: EQUAL
52937: IFTRUE 52941
52939: GO 52971
52941: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52942: LD_ADDR_VAR 0 3
52946: PUSH
52947: LD_INT 1
52949: PUSH
52950: LD_INT 2
52952: PUSH
52953: LD_INT 3
52955: PUSH
52956: LD_INT 4
52958: PUSH
52959: LD_INT 5
52961: PUSH
52962: EMPTY
52963: LIST
52964: LIST
52965: LIST
52966: LIST
52967: LIST
52968: ST_TO_ADDR
52969: GO 53900
52971: LD_INT 11
52973: DOUBLE
52974: EQUAL
52975: IFTRUE 52979
52977: GO 53009
52979: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52980: LD_ADDR_VAR 0 3
52984: PUSH
52985: LD_INT 1
52987: PUSH
52988: LD_INT 2
52990: PUSH
52991: LD_INT 3
52993: PUSH
52994: LD_INT 4
52996: PUSH
52997: LD_INT 5
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: LIST
53004: LIST
53005: LIST
53006: ST_TO_ADDR
53007: GO 53900
53009: LD_INT 4
53011: DOUBLE
53012: EQUAL
53013: IFTRUE 53017
53015: GO 53043
53017: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
53018: LD_ADDR_VAR 0 3
53022: PUSH
53023: LD_INT 2
53025: PUSH
53026: LD_INT 3
53028: PUSH
53029: LD_INT 4
53031: PUSH
53032: LD_INT 5
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: ST_TO_ADDR
53041: GO 53900
53043: LD_INT 5
53045: DOUBLE
53046: EQUAL
53047: IFTRUE 53051
53049: GO 53077
53051: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
53052: LD_ADDR_VAR 0 3
53056: PUSH
53057: LD_INT 2
53059: PUSH
53060: LD_INT 3
53062: PUSH
53063: LD_INT 4
53065: PUSH
53066: LD_INT 5
53068: PUSH
53069: EMPTY
53070: LIST
53071: LIST
53072: LIST
53073: LIST
53074: ST_TO_ADDR
53075: GO 53900
53077: LD_INT 9
53079: DOUBLE
53080: EQUAL
53081: IFTRUE 53085
53083: GO 53111
53085: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
53086: LD_ADDR_VAR 0 3
53090: PUSH
53091: LD_INT 2
53093: PUSH
53094: LD_INT 3
53096: PUSH
53097: LD_INT 4
53099: PUSH
53100: LD_INT 5
53102: PUSH
53103: EMPTY
53104: LIST
53105: LIST
53106: LIST
53107: LIST
53108: ST_TO_ADDR
53109: GO 53900
53111: LD_INT 7
53113: DOUBLE
53114: EQUAL
53115: IFTRUE 53119
53117: GO 53145
53119: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
53120: LD_ADDR_VAR 0 3
53124: PUSH
53125: LD_INT 2
53127: PUSH
53128: LD_INT 3
53130: PUSH
53131: LD_INT 4
53133: PUSH
53134: LD_INT 5
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: LIST
53141: LIST
53142: ST_TO_ADDR
53143: GO 53900
53145: LD_INT 12
53147: DOUBLE
53148: EQUAL
53149: IFTRUE 53153
53151: GO 53179
53153: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
53154: LD_ADDR_VAR 0 3
53158: PUSH
53159: LD_INT 2
53161: PUSH
53162: LD_INT 3
53164: PUSH
53165: LD_INT 4
53167: PUSH
53168: LD_INT 5
53170: PUSH
53171: EMPTY
53172: LIST
53173: LIST
53174: LIST
53175: LIST
53176: ST_TO_ADDR
53177: GO 53900
53179: LD_INT 13
53181: DOUBLE
53182: EQUAL
53183: IFTRUE 53187
53185: GO 53213
53187: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
53188: LD_ADDR_VAR 0 3
53192: PUSH
53193: LD_INT 2
53195: PUSH
53196: LD_INT 3
53198: PUSH
53199: LD_INT 4
53201: PUSH
53202: LD_INT 5
53204: PUSH
53205: EMPTY
53206: LIST
53207: LIST
53208: LIST
53209: LIST
53210: ST_TO_ADDR
53211: GO 53900
53213: LD_INT 14
53215: DOUBLE
53216: EQUAL
53217: IFTRUE 53221
53219: GO 53239
53221: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
53222: LD_ADDR_VAR 0 3
53226: PUSH
53227: LD_INT 4
53229: PUSH
53230: LD_INT 5
53232: PUSH
53233: EMPTY
53234: LIST
53235: LIST
53236: ST_TO_ADDR
53237: GO 53900
53239: LD_INT 6
53241: DOUBLE
53242: EQUAL
53243: IFTRUE 53247
53245: GO 53265
53247: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
53248: LD_ADDR_VAR 0 3
53252: PUSH
53253: LD_INT 4
53255: PUSH
53256: LD_INT 5
53258: PUSH
53259: EMPTY
53260: LIST
53261: LIST
53262: ST_TO_ADDR
53263: GO 53900
53265: LD_INT 10
53267: DOUBLE
53268: EQUAL
53269: IFTRUE 53273
53271: GO 53291
53273: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
53274: LD_ADDR_VAR 0 3
53278: PUSH
53279: LD_INT 4
53281: PUSH
53282: LD_INT 5
53284: PUSH
53285: EMPTY
53286: LIST
53287: LIST
53288: ST_TO_ADDR
53289: GO 53900
53291: LD_INT 22
53293: DOUBLE
53294: EQUAL
53295: IFTRUE 53299
53297: GO 53325
53299: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
53300: LD_ADDR_VAR 0 3
53304: PUSH
53305: LD_INT 11
53307: PUSH
53308: LD_INT 12
53310: PUSH
53311: LD_INT 13
53313: PUSH
53314: LD_INT 14
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: LIST
53321: LIST
53322: ST_TO_ADDR
53323: GO 53900
53325: LD_INT 23
53327: DOUBLE
53328: EQUAL
53329: IFTRUE 53333
53331: GO 53359
53333: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
53334: LD_ADDR_VAR 0 3
53338: PUSH
53339: LD_INT 11
53341: PUSH
53342: LD_INT 12
53344: PUSH
53345: LD_INT 13
53347: PUSH
53348: LD_INT 14
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: ST_TO_ADDR
53357: GO 53900
53359: LD_INT 24
53361: DOUBLE
53362: EQUAL
53363: IFTRUE 53367
53365: GO 53393
53367: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
53368: LD_ADDR_VAR 0 3
53372: PUSH
53373: LD_INT 11
53375: PUSH
53376: LD_INT 12
53378: PUSH
53379: LD_INT 13
53381: PUSH
53382: LD_INT 14
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: LIST
53389: LIST
53390: ST_TO_ADDR
53391: GO 53900
53393: LD_INT 30
53395: DOUBLE
53396: EQUAL
53397: IFTRUE 53401
53399: GO 53427
53401: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53402: LD_ADDR_VAR 0 3
53406: PUSH
53407: LD_INT 11
53409: PUSH
53410: LD_INT 12
53412: PUSH
53413: LD_INT 13
53415: PUSH
53416: LD_INT 14
53418: PUSH
53419: EMPTY
53420: LIST
53421: LIST
53422: LIST
53423: LIST
53424: ST_TO_ADDR
53425: GO 53900
53427: LD_INT 25
53429: DOUBLE
53430: EQUAL
53431: IFTRUE 53435
53433: GO 53453
53435: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53436: LD_ADDR_VAR 0 3
53440: PUSH
53441: LD_INT 13
53443: PUSH
53444: LD_INT 14
53446: PUSH
53447: EMPTY
53448: LIST
53449: LIST
53450: ST_TO_ADDR
53451: GO 53900
53453: LD_INT 27
53455: DOUBLE
53456: EQUAL
53457: IFTRUE 53461
53459: GO 53479
53461: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53462: LD_ADDR_VAR 0 3
53466: PUSH
53467: LD_INT 13
53469: PUSH
53470: LD_INT 14
53472: PUSH
53473: EMPTY
53474: LIST
53475: LIST
53476: ST_TO_ADDR
53477: GO 53900
53479: LD_INT 28
53481: DOUBLE
53482: EQUAL
53483: IFTRUE 53487
53485: GO 53505
53487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_INT 13
53495: PUSH
53496: LD_INT 14
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: ST_TO_ADDR
53503: GO 53900
53505: LD_INT 29
53507: DOUBLE
53508: EQUAL
53509: IFTRUE 53513
53511: GO 53531
53513: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53514: LD_ADDR_VAR 0 3
53518: PUSH
53519: LD_INT 13
53521: PUSH
53522: LD_INT 14
53524: PUSH
53525: EMPTY
53526: LIST
53527: LIST
53528: ST_TO_ADDR
53529: GO 53900
53531: LD_INT 31
53533: DOUBLE
53534: EQUAL
53535: IFTRUE 53539
53537: GO 53557
53539: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53540: LD_ADDR_VAR 0 3
53544: PUSH
53545: LD_INT 13
53547: PUSH
53548: LD_INT 14
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: ST_TO_ADDR
53555: GO 53900
53557: LD_INT 26
53559: DOUBLE
53560: EQUAL
53561: IFTRUE 53565
53563: GO 53583
53565: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53566: LD_ADDR_VAR 0 3
53570: PUSH
53571: LD_INT 13
53573: PUSH
53574: LD_INT 14
53576: PUSH
53577: EMPTY
53578: LIST
53579: LIST
53580: ST_TO_ADDR
53581: GO 53900
53583: LD_INT 42
53585: DOUBLE
53586: EQUAL
53587: IFTRUE 53591
53589: GO 53617
53591: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53592: LD_ADDR_VAR 0 3
53596: PUSH
53597: LD_INT 21
53599: PUSH
53600: LD_INT 22
53602: PUSH
53603: LD_INT 23
53605: PUSH
53606: LD_INT 24
53608: PUSH
53609: EMPTY
53610: LIST
53611: LIST
53612: LIST
53613: LIST
53614: ST_TO_ADDR
53615: GO 53900
53617: LD_INT 43
53619: DOUBLE
53620: EQUAL
53621: IFTRUE 53625
53623: GO 53651
53625: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53626: LD_ADDR_VAR 0 3
53630: PUSH
53631: LD_INT 21
53633: PUSH
53634: LD_INT 22
53636: PUSH
53637: LD_INT 23
53639: PUSH
53640: LD_INT 24
53642: PUSH
53643: EMPTY
53644: LIST
53645: LIST
53646: LIST
53647: LIST
53648: ST_TO_ADDR
53649: GO 53900
53651: LD_INT 44
53653: DOUBLE
53654: EQUAL
53655: IFTRUE 53659
53657: GO 53685
53659: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53660: LD_ADDR_VAR 0 3
53664: PUSH
53665: LD_INT 21
53667: PUSH
53668: LD_INT 22
53670: PUSH
53671: LD_INT 23
53673: PUSH
53674: LD_INT 24
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: LIST
53681: LIST
53682: ST_TO_ADDR
53683: GO 53900
53685: LD_INT 45
53687: DOUBLE
53688: EQUAL
53689: IFTRUE 53693
53691: GO 53719
53693: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53694: LD_ADDR_VAR 0 3
53698: PUSH
53699: LD_INT 21
53701: PUSH
53702: LD_INT 22
53704: PUSH
53705: LD_INT 23
53707: PUSH
53708: LD_INT 24
53710: PUSH
53711: EMPTY
53712: LIST
53713: LIST
53714: LIST
53715: LIST
53716: ST_TO_ADDR
53717: GO 53900
53719: LD_INT 49
53721: DOUBLE
53722: EQUAL
53723: IFTRUE 53727
53725: GO 53753
53727: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53728: LD_ADDR_VAR 0 3
53732: PUSH
53733: LD_INT 21
53735: PUSH
53736: LD_INT 22
53738: PUSH
53739: LD_INT 23
53741: PUSH
53742: LD_INT 24
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: ST_TO_ADDR
53751: GO 53900
53753: LD_INT 51
53755: DOUBLE
53756: EQUAL
53757: IFTRUE 53761
53759: GO 53787
53761: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53762: LD_ADDR_VAR 0 3
53766: PUSH
53767: LD_INT 21
53769: PUSH
53770: LD_INT 22
53772: PUSH
53773: LD_INT 23
53775: PUSH
53776: LD_INT 24
53778: PUSH
53779: EMPTY
53780: LIST
53781: LIST
53782: LIST
53783: LIST
53784: ST_TO_ADDR
53785: GO 53900
53787: LD_INT 52
53789: DOUBLE
53790: EQUAL
53791: IFTRUE 53795
53793: GO 53821
53795: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53796: LD_ADDR_VAR 0 3
53800: PUSH
53801: LD_INT 21
53803: PUSH
53804: LD_INT 22
53806: PUSH
53807: LD_INT 23
53809: PUSH
53810: LD_INT 24
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: LIST
53817: LIST
53818: ST_TO_ADDR
53819: GO 53900
53821: LD_INT 53
53823: DOUBLE
53824: EQUAL
53825: IFTRUE 53829
53827: GO 53847
53829: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53830: LD_ADDR_VAR 0 3
53834: PUSH
53835: LD_INT 23
53837: PUSH
53838: LD_INT 24
53840: PUSH
53841: EMPTY
53842: LIST
53843: LIST
53844: ST_TO_ADDR
53845: GO 53900
53847: LD_INT 46
53849: DOUBLE
53850: EQUAL
53851: IFTRUE 53855
53853: GO 53873
53855: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53856: LD_ADDR_VAR 0 3
53860: PUSH
53861: LD_INT 23
53863: PUSH
53864: LD_INT 24
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: ST_TO_ADDR
53871: GO 53900
53873: LD_INT 47
53875: DOUBLE
53876: EQUAL
53877: IFTRUE 53881
53879: GO 53899
53881: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53882: LD_ADDR_VAR 0 3
53886: PUSH
53887: LD_INT 23
53889: PUSH
53890: LD_INT 24
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: ST_TO_ADDR
53897: GO 53900
53899: POP
// result := ( chassis in result ) ;
53900: LD_ADDR_VAR 0 3
53904: PUSH
53905: LD_VAR 0 1
53909: PUSH
53910: LD_VAR 0 3
53914: IN
53915: ST_TO_ADDR
// end ;
53916: LD_VAR 0 3
53920: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53921: LD_INT 0
53923: PPUSH
53924: PPUSH
53925: PPUSH
53926: PPUSH
53927: PPUSH
53928: PPUSH
53929: PPUSH
// result := array ;
53930: LD_ADDR_VAR 0 5
53934: PUSH
53935: LD_VAR 0 1
53939: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53940: LD_VAR 0 1
53944: NOT
53945: PUSH
53946: LD_VAR 0 2
53950: NOT
53951: OR
53952: PUSH
53953: LD_VAR 0 3
53957: NOT
53958: OR
53959: PUSH
53960: LD_VAR 0 2
53964: PUSH
53965: LD_VAR 0 1
53969: GREATER
53970: OR
53971: PUSH
53972: LD_VAR 0 3
53976: PUSH
53977: LD_VAR 0 1
53981: GREATER
53982: OR
53983: IFFALSE 53987
// exit ;
53985: GO 54283
// if direction then
53987: LD_VAR 0 4
53991: IFFALSE 54055
// begin d := 1 ;
53993: LD_ADDR_VAR 0 9
53997: PUSH
53998: LD_INT 1
54000: ST_TO_ADDR
// if i_from > i_to then
54001: LD_VAR 0 2
54005: PUSH
54006: LD_VAR 0 3
54010: GREATER
54011: IFFALSE 54037
// length := ( array - i_from ) + i_to else
54013: LD_ADDR_VAR 0 11
54017: PUSH
54018: LD_VAR 0 1
54022: PUSH
54023: LD_VAR 0 2
54027: MINUS
54028: PUSH
54029: LD_VAR 0 3
54033: PLUS
54034: ST_TO_ADDR
54035: GO 54053
// length := i_to - i_from ;
54037: LD_ADDR_VAR 0 11
54041: PUSH
54042: LD_VAR 0 3
54046: PUSH
54047: LD_VAR 0 2
54051: MINUS
54052: ST_TO_ADDR
// end else
54053: GO 54116
// begin d := - 1 ;
54055: LD_ADDR_VAR 0 9
54059: PUSH
54060: LD_INT 1
54062: NEG
54063: ST_TO_ADDR
// if i_from > i_to then
54064: LD_VAR 0 2
54068: PUSH
54069: LD_VAR 0 3
54073: GREATER
54074: IFFALSE 54094
// length := i_from - i_to else
54076: LD_ADDR_VAR 0 11
54080: PUSH
54081: LD_VAR 0 2
54085: PUSH
54086: LD_VAR 0 3
54090: MINUS
54091: ST_TO_ADDR
54092: GO 54116
// length := ( array - i_to ) + i_from ;
54094: LD_ADDR_VAR 0 11
54098: PUSH
54099: LD_VAR 0 1
54103: PUSH
54104: LD_VAR 0 3
54108: MINUS
54109: PUSH
54110: LD_VAR 0 2
54114: PLUS
54115: ST_TO_ADDR
// end ; if not length then
54116: LD_VAR 0 11
54120: NOT
54121: IFFALSE 54125
// exit ;
54123: GO 54283
// tmp := array ;
54125: LD_ADDR_VAR 0 10
54129: PUSH
54130: LD_VAR 0 1
54134: ST_TO_ADDR
// for i = 1 to length do
54135: LD_ADDR_VAR 0 6
54139: PUSH
54140: DOUBLE
54141: LD_INT 1
54143: DEC
54144: ST_TO_ADDR
54145: LD_VAR 0 11
54149: PUSH
54150: FOR_TO
54151: IFFALSE 54271
// begin for j = 1 to array do
54153: LD_ADDR_VAR 0 7
54157: PUSH
54158: DOUBLE
54159: LD_INT 1
54161: DEC
54162: ST_TO_ADDR
54163: LD_VAR 0 1
54167: PUSH
54168: FOR_TO
54169: IFFALSE 54257
// begin k := j + d ;
54171: LD_ADDR_VAR 0 8
54175: PUSH
54176: LD_VAR 0 7
54180: PUSH
54181: LD_VAR 0 9
54185: PLUS
54186: ST_TO_ADDR
// if k > array then
54187: LD_VAR 0 8
54191: PUSH
54192: LD_VAR 0 1
54196: GREATER
54197: IFFALSE 54207
// k := 1 ;
54199: LD_ADDR_VAR 0 8
54203: PUSH
54204: LD_INT 1
54206: ST_TO_ADDR
// if not k then
54207: LD_VAR 0 8
54211: NOT
54212: IFFALSE 54224
// k := array ;
54214: LD_ADDR_VAR 0 8
54218: PUSH
54219: LD_VAR 0 1
54223: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
54224: LD_ADDR_VAR 0 10
54228: PUSH
54229: LD_VAR 0 10
54233: PPUSH
54234: LD_VAR 0 8
54238: PPUSH
54239: LD_VAR 0 1
54243: PUSH
54244: LD_VAR 0 7
54248: ARRAY
54249: PPUSH
54250: CALL_OW 1
54254: ST_TO_ADDR
// end ;
54255: GO 54168
54257: POP
54258: POP
// array := tmp ;
54259: LD_ADDR_VAR 0 1
54263: PUSH
54264: LD_VAR 0 10
54268: ST_TO_ADDR
// end ;
54269: GO 54150
54271: POP
54272: POP
// result := array ;
54273: LD_ADDR_VAR 0 5
54277: PUSH
54278: LD_VAR 0 1
54282: ST_TO_ADDR
// end ;
54283: LD_VAR 0 5
54287: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
54288: LD_INT 0
54290: PPUSH
54291: PPUSH
// result := 0 ;
54292: LD_ADDR_VAR 0 3
54296: PUSH
54297: LD_INT 0
54299: ST_TO_ADDR
// if not array or not value in array then
54300: LD_VAR 0 1
54304: NOT
54305: PUSH
54306: LD_VAR 0 2
54310: PUSH
54311: LD_VAR 0 1
54315: IN
54316: NOT
54317: OR
54318: IFFALSE 54322
// exit ;
54320: GO 54376
// for i = 1 to array do
54322: LD_ADDR_VAR 0 4
54326: PUSH
54327: DOUBLE
54328: LD_INT 1
54330: DEC
54331: ST_TO_ADDR
54332: LD_VAR 0 1
54336: PUSH
54337: FOR_TO
54338: IFFALSE 54374
// if value = array [ i ] then
54340: LD_VAR 0 2
54344: PUSH
54345: LD_VAR 0 1
54349: PUSH
54350: LD_VAR 0 4
54354: ARRAY
54355: EQUAL
54356: IFFALSE 54372
// begin result := i ;
54358: LD_ADDR_VAR 0 3
54362: PUSH
54363: LD_VAR 0 4
54367: ST_TO_ADDR
// exit ;
54368: POP
54369: POP
54370: GO 54376
// end ;
54372: GO 54337
54374: POP
54375: POP
// end ;
54376: LD_VAR 0 3
54380: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54381: LD_INT 0
54383: PPUSH
// vc_chassis := chassis ;
54384: LD_ADDR_OWVAR 37
54388: PUSH
54389: LD_VAR 0 1
54393: ST_TO_ADDR
// vc_engine := engine ;
54394: LD_ADDR_OWVAR 39
54398: PUSH
54399: LD_VAR 0 2
54403: ST_TO_ADDR
// vc_control := control ;
54404: LD_ADDR_OWVAR 38
54408: PUSH
54409: LD_VAR 0 3
54413: ST_TO_ADDR
// vc_weapon := weapon ;
54414: LD_ADDR_OWVAR 40
54418: PUSH
54419: LD_VAR 0 4
54423: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54424: LD_ADDR_OWVAR 41
54428: PUSH
54429: LD_VAR 0 5
54433: ST_TO_ADDR
// end ;
54434: LD_VAR 0 6
54438: RET
// export function WantPlant ( unit ) ; var task ; begin
54439: LD_INT 0
54441: PPUSH
54442: PPUSH
// result := false ;
54443: LD_ADDR_VAR 0 2
54447: PUSH
54448: LD_INT 0
54450: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54451: LD_ADDR_VAR 0 3
54455: PUSH
54456: LD_VAR 0 1
54460: PPUSH
54461: CALL_OW 437
54465: ST_TO_ADDR
// if task then
54466: LD_VAR 0 3
54470: IFFALSE 54498
// if task [ 1 ] [ 1 ] = p then
54472: LD_VAR 0 3
54476: PUSH
54477: LD_INT 1
54479: ARRAY
54480: PUSH
54481: LD_INT 1
54483: ARRAY
54484: PUSH
54485: LD_STRING p
54487: EQUAL
54488: IFFALSE 54498
// result := true ;
54490: LD_ADDR_VAR 0 2
54494: PUSH
54495: LD_INT 1
54497: ST_TO_ADDR
// end ;
54498: LD_VAR 0 2
54502: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54503: LD_INT 0
54505: PPUSH
54506: PPUSH
54507: PPUSH
54508: PPUSH
// if pos < 1 then
54509: LD_VAR 0 2
54513: PUSH
54514: LD_INT 1
54516: LESS
54517: IFFALSE 54521
// exit ;
54519: GO 54824
// if pos = 1 then
54521: LD_VAR 0 2
54525: PUSH
54526: LD_INT 1
54528: EQUAL
54529: IFFALSE 54562
// result := Replace ( arr , pos [ 1 ] , value ) else
54531: LD_ADDR_VAR 0 4
54535: PUSH
54536: LD_VAR 0 1
54540: PPUSH
54541: LD_VAR 0 2
54545: PUSH
54546: LD_INT 1
54548: ARRAY
54549: PPUSH
54550: LD_VAR 0 3
54554: PPUSH
54555: CALL_OW 1
54559: ST_TO_ADDR
54560: GO 54824
// begin tmp := arr ;
54562: LD_ADDR_VAR 0 6
54566: PUSH
54567: LD_VAR 0 1
54571: ST_TO_ADDR
// s_arr := [ tmp ] ;
54572: LD_ADDR_VAR 0 7
54576: PUSH
54577: LD_VAR 0 6
54581: PUSH
54582: EMPTY
54583: LIST
54584: ST_TO_ADDR
// for i = 1 to pos - 1 do
54585: LD_ADDR_VAR 0 5
54589: PUSH
54590: DOUBLE
54591: LD_INT 1
54593: DEC
54594: ST_TO_ADDR
54595: LD_VAR 0 2
54599: PUSH
54600: LD_INT 1
54602: MINUS
54603: PUSH
54604: FOR_TO
54605: IFFALSE 54650
// begin tmp := tmp [ pos [ i ] ] ;
54607: LD_ADDR_VAR 0 6
54611: PUSH
54612: LD_VAR 0 6
54616: PUSH
54617: LD_VAR 0 2
54621: PUSH
54622: LD_VAR 0 5
54626: ARRAY
54627: ARRAY
54628: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54629: LD_ADDR_VAR 0 7
54633: PUSH
54634: LD_VAR 0 7
54638: PUSH
54639: LD_VAR 0 6
54643: PUSH
54644: EMPTY
54645: LIST
54646: ADD
54647: ST_TO_ADDR
// end ;
54648: GO 54604
54650: POP
54651: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54652: LD_ADDR_VAR 0 6
54656: PUSH
54657: LD_VAR 0 6
54661: PPUSH
54662: LD_VAR 0 2
54666: PUSH
54667: LD_VAR 0 2
54671: ARRAY
54672: PPUSH
54673: LD_VAR 0 3
54677: PPUSH
54678: CALL_OW 1
54682: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54683: LD_ADDR_VAR 0 7
54687: PUSH
54688: LD_VAR 0 7
54692: PPUSH
54693: LD_VAR 0 7
54697: PPUSH
54698: LD_VAR 0 6
54702: PPUSH
54703: CALL_OW 1
54707: ST_TO_ADDR
// for i = s_arr downto 2 do
54708: LD_ADDR_VAR 0 5
54712: PUSH
54713: DOUBLE
54714: LD_VAR 0 7
54718: INC
54719: ST_TO_ADDR
54720: LD_INT 2
54722: PUSH
54723: FOR_DOWNTO
54724: IFFALSE 54808
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54726: LD_ADDR_VAR 0 6
54730: PUSH
54731: LD_VAR 0 7
54735: PUSH
54736: LD_VAR 0 5
54740: PUSH
54741: LD_INT 1
54743: MINUS
54744: ARRAY
54745: PPUSH
54746: LD_VAR 0 2
54750: PUSH
54751: LD_VAR 0 5
54755: PUSH
54756: LD_INT 1
54758: MINUS
54759: ARRAY
54760: PPUSH
54761: LD_VAR 0 7
54765: PUSH
54766: LD_VAR 0 5
54770: ARRAY
54771: PPUSH
54772: CALL_OW 1
54776: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54777: LD_ADDR_VAR 0 7
54781: PUSH
54782: LD_VAR 0 7
54786: PPUSH
54787: LD_VAR 0 5
54791: PUSH
54792: LD_INT 1
54794: MINUS
54795: PPUSH
54796: LD_VAR 0 6
54800: PPUSH
54801: CALL_OW 1
54805: ST_TO_ADDR
// end ;
54806: GO 54723
54808: POP
54809: POP
// result := s_arr [ 1 ] ;
54810: LD_ADDR_VAR 0 4
54814: PUSH
54815: LD_VAR 0 7
54819: PUSH
54820: LD_INT 1
54822: ARRAY
54823: ST_TO_ADDR
// end ; end ;
54824: LD_VAR 0 4
54828: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54829: LD_INT 0
54831: PPUSH
54832: PPUSH
// if not list then
54833: LD_VAR 0 1
54837: NOT
54838: IFFALSE 54842
// exit ;
54840: GO 54933
// i := list [ pos1 ] ;
54842: LD_ADDR_VAR 0 5
54846: PUSH
54847: LD_VAR 0 1
54851: PUSH
54852: LD_VAR 0 2
54856: ARRAY
54857: ST_TO_ADDR
// if not i then
54858: LD_VAR 0 5
54862: NOT
54863: IFFALSE 54867
// exit ;
54865: GO 54933
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54867: LD_ADDR_VAR 0 1
54871: PUSH
54872: LD_VAR 0 1
54876: PPUSH
54877: LD_VAR 0 2
54881: PPUSH
54882: LD_VAR 0 1
54886: PUSH
54887: LD_VAR 0 3
54891: ARRAY
54892: PPUSH
54893: CALL_OW 1
54897: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54898: LD_ADDR_VAR 0 1
54902: PUSH
54903: LD_VAR 0 1
54907: PPUSH
54908: LD_VAR 0 3
54912: PPUSH
54913: LD_VAR 0 5
54917: PPUSH
54918: CALL_OW 1
54922: ST_TO_ADDR
// result := list ;
54923: LD_ADDR_VAR 0 4
54927: PUSH
54928: LD_VAR 0 1
54932: ST_TO_ADDR
// end ;
54933: LD_VAR 0 4
54937: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54938: LD_INT 0
54940: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54941: LD_ADDR_VAR 0 5
54945: PUSH
54946: LD_VAR 0 1
54950: PPUSH
54951: CALL_OW 250
54955: PPUSH
54956: LD_VAR 0 1
54960: PPUSH
54961: CALL_OW 251
54965: PPUSH
54966: LD_VAR 0 2
54970: PPUSH
54971: LD_VAR 0 3
54975: PPUSH
54976: LD_VAR 0 4
54980: PPUSH
54981: CALL 54991 0 5
54985: ST_TO_ADDR
// end ;
54986: LD_VAR 0 5
54990: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54991: LD_INT 0
54993: PPUSH
54994: PPUSH
54995: PPUSH
54996: PPUSH
// if not list then
54997: LD_VAR 0 3
55001: NOT
55002: IFFALSE 55006
// exit ;
55004: GO 55394
// result := [ ] ;
55006: LD_ADDR_VAR 0 6
55010: PUSH
55011: EMPTY
55012: ST_TO_ADDR
// for i in list do
55013: LD_ADDR_VAR 0 7
55017: PUSH
55018: LD_VAR 0 3
55022: PUSH
55023: FOR_IN
55024: IFFALSE 55226
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55026: LD_ADDR_VAR 0 9
55030: PUSH
55031: LD_VAR 0 7
55035: PPUSH
55036: LD_VAR 0 1
55040: PPUSH
55041: LD_VAR 0 2
55045: PPUSH
55046: CALL_OW 297
55050: ST_TO_ADDR
// if not result then
55051: LD_VAR 0 6
55055: NOT
55056: IFFALSE 55082
// result := [ [ i , tmp ] ] else
55058: LD_ADDR_VAR 0 6
55062: PUSH
55063: LD_VAR 0 7
55067: PUSH
55068: LD_VAR 0 9
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: PUSH
55077: EMPTY
55078: LIST
55079: ST_TO_ADDR
55080: GO 55224
// begin if result [ result ] [ 2 ] < tmp then
55082: LD_VAR 0 6
55086: PUSH
55087: LD_VAR 0 6
55091: ARRAY
55092: PUSH
55093: LD_INT 2
55095: ARRAY
55096: PUSH
55097: LD_VAR 0 9
55101: LESS
55102: IFFALSE 55144
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55104: LD_ADDR_VAR 0 6
55108: PUSH
55109: LD_VAR 0 6
55113: PPUSH
55114: LD_VAR 0 6
55118: PUSH
55119: LD_INT 1
55121: PLUS
55122: PPUSH
55123: LD_VAR 0 7
55127: PUSH
55128: LD_VAR 0 9
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: PPUSH
55137: CALL_OW 2
55141: ST_TO_ADDR
55142: GO 55224
// for j = 1 to result do
55144: LD_ADDR_VAR 0 8
55148: PUSH
55149: DOUBLE
55150: LD_INT 1
55152: DEC
55153: ST_TO_ADDR
55154: LD_VAR 0 6
55158: PUSH
55159: FOR_TO
55160: IFFALSE 55222
// begin if tmp < result [ j ] [ 2 ] then
55162: LD_VAR 0 9
55166: PUSH
55167: LD_VAR 0 6
55171: PUSH
55172: LD_VAR 0 8
55176: ARRAY
55177: PUSH
55178: LD_INT 2
55180: ARRAY
55181: LESS
55182: IFFALSE 55220
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55184: LD_ADDR_VAR 0 6
55188: PUSH
55189: LD_VAR 0 6
55193: PPUSH
55194: LD_VAR 0 8
55198: PPUSH
55199: LD_VAR 0 7
55203: PUSH
55204: LD_VAR 0 9
55208: PUSH
55209: EMPTY
55210: LIST
55211: LIST
55212: PPUSH
55213: CALL_OW 2
55217: ST_TO_ADDR
// break ;
55218: GO 55222
// end ; end ;
55220: GO 55159
55222: POP
55223: POP
// end ; end ;
55224: GO 55023
55226: POP
55227: POP
// if result and not asc then
55228: LD_VAR 0 6
55232: PUSH
55233: LD_VAR 0 4
55237: NOT
55238: AND
55239: IFFALSE 55314
// begin tmp := result ;
55241: LD_ADDR_VAR 0 9
55245: PUSH
55246: LD_VAR 0 6
55250: ST_TO_ADDR
// for i = tmp downto 1 do
55251: LD_ADDR_VAR 0 7
55255: PUSH
55256: DOUBLE
55257: LD_VAR 0 9
55261: INC
55262: ST_TO_ADDR
55263: LD_INT 1
55265: PUSH
55266: FOR_DOWNTO
55267: IFFALSE 55312
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55269: LD_ADDR_VAR 0 6
55273: PUSH
55274: LD_VAR 0 6
55278: PPUSH
55279: LD_VAR 0 9
55283: PUSH
55284: LD_VAR 0 7
55288: MINUS
55289: PUSH
55290: LD_INT 1
55292: PLUS
55293: PPUSH
55294: LD_VAR 0 9
55298: PUSH
55299: LD_VAR 0 7
55303: ARRAY
55304: PPUSH
55305: CALL_OW 1
55309: ST_TO_ADDR
55310: GO 55266
55312: POP
55313: POP
// end ; tmp := [ ] ;
55314: LD_ADDR_VAR 0 9
55318: PUSH
55319: EMPTY
55320: ST_TO_ADDR
// if mode then
55321: LD_VAR 0 5
55325: IFFALSE 55394
// begin for i = 1 to result do
55327: LD_ADDR_VAR 0 7
55331: PUSH
55332: DOUBLE
55333: LD_INT 1
55335: DEC
55336: ST_TO_ADDR
55337: LD_VAR 0 6
55341: PUSH
55342: FOR_TO
55343: IFFALSE 55382
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55345: LD_ADDR_VAR 0 9
55349: PUSH
55350: LD_VAR 0 9
55354: PPUSH
55355: LD_VAR 0 7
55359: PPUSH
55360: LD_VAR 0 6
55364: PUSH
55365: LD_VAR 0 7
55369: ARRAY
55370: PUSH
55371: LD_INT 1
55373: ARRAY
55374: PPUSH
55375: CALL_OW 1
55379: ST_TO_ADDR
55380: GO 55342
55382: POP
55383: POP
// result := tmp ;
55384: LD_ADDR_VAR 0 6
55388: PUSH
55389: LD_VAR 0 9
55393: ST_TO_ADDR
// end ; end ;
55394: LD_VAR 0 6
55398: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55399: LD_INT 0
55401: PPUSH
55402: PPUSH
55403: PPUSH
55404: PPUSH
55405: PPUSH
55406: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55407: LD_ADDR_VAR 0 5
55411: PUSH
55412: LD_INT 0
55414: PUSH
55415: LD_INT 0
55417: PUSH
55418: LD_INT 0
55420: PUSH
55421: EMPTY
55422: PUSH
55423: EMPTY
55424: LIST
55425: LIST
55426: LIST
55427: LIST
55428: ST_TO_ADDR
// if not x or not y then
55429: LD_VAR 0 2
55433: NOT
55434: PUSH
55435: LD_VAR 0 3
55439: NOT
55440: OR
55441: IFFALSE 55445
// exit ;
55443: GO 57091
// if not range then
55445: LD_VAR 0 4
55449: NOT
55450: IFFALSE 55460
// range := 10 ;
55452: LD_ADDR_VAR 0 4
55456: PUSH
55457: LD_INT 10
55459: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55460: LD_ADDR_VAR 0 8
55464: PUSH
55465: LD_INT 81
55467: PUSH
55468: LD_VAR 0 1
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: PUSH
55477: LD_INT 92
55479: PUSH
55480: LD_VAR 0 2
55484: PUSH
55485: LD_VAR 0 3
55489: PUSH
55490: LD_VAR 0 4
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: LIST
55499: LIST
55500: PUSH
55501: LD_INT 3
55503: PUSH
55504: LD_INT 21
55506: PUSH
55507: LD_INT 3
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: PUSH
55518: EMPTY
55519: LIST
55520: LIST
55521: LIST
55522: PPUSH
55523: CALL_OW 69
55527: ST_TO_ADDR
// if not tmp then
55528: LD_VAR 0 8
55532: NOT
55533: IFFALSE 55537
// exit ;
55535: GO 57091
// for i in tmp do
55537: LD_ADDR_VAR 0 6
55541: PUSH
55542: LD_VAR 0 8
55546: PUSH
55547: FOR_IN
55548: IFFALSE 57066
// begin points := [ 0 , 0 , 0 ] ;
55550: LD_ADDR_VAR 0 9
55554: PUSH
55555: LD_INT 0
55557: PUSH
55558: LD_INT 0
55560: PUSH
55561: LD_INT 0
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: LIST
55568: ST_TO_ADDR
// bpoints := 1 ;
55569: LD_ADDR_VAR 0 10
55573: PUSH
55574: LD_INT 1
55576: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55577: LD_VAR 0 6
55581: PPUSH
55582: CALL_OW 247
55586: PUSH
55587: LD_INT 1
55589: DOUBLE
55590: EQUAL
55591: IFTRUE 55595
55593: GO 56173
55595: POP
// begin if GetClass ( i ) = 1 then
55596: LD_VAR 0 6
55600: PPUSH
55601: CALL_OW 257
55605: PUSH
55606: LD_INT 1
55608: EQUAL
55609: IFFALSE 55630
// points := [ 10 , 5 , 3 ] ;
55611: LD_ADDR_VAR 0 9
55615: PUSH
55616: LD_INT 10
55618: PUSH
55619: LD_INT 5
55621: PUSH
55622: LD_INT 3
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: LIST
55629: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55630: LD_VAR 0 6
55634: PPUSH
55635: CALL_OW 257
55639: PUSH
55640: LD_INT 2
55642: PUSH
55643: LD_INT 3
55645: PUSH
55646: LD_INT 4
55648: PUSH
55649: EMPTY
55650: LIST
55651: LIST
55652: LIST
55653: IN
55654: IFFALSE 55675
// points := [ 3 , 2 , 1 ] ;
55656: LD_ADDR_VAR 0 9
55660: PUSH
55661: LD_INT 3
55663: PUSH
55664: LD_INT 2
55666: PUSH
55667: LD_INT 1
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: LIST
55674: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55675: LD_VAR 0 6
55679: PPUSH
55680: CALL_OW 257
55684: PUSH
55685: LD_INT 5
55687: EQUAL
55688: IFFALSE 55709
// points := [ 130 , 5 , 2 ] ;
55690: LD_ADDR_VAR 0 9
55694: PUSH
55695: LD_INT 130
55697: PUSH
55698: LD_INT 5
55700: PUSH
55701: LD_INT 2
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: LIST
55708: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55709: LD_VAR 0 6
55713: PPUSH
55714: CALL_OW 257
55718: PUSH
55719: LD_INT 8
55721: EQUAL
55722: IFFALSE 55743
// points := [ 35 , 35 , 30 ] ;
55724: LD_ADDR_VAR 0 9
55728: PUSH
55729: LD_INT 35
55731: PUSH
55732: LD_INT 35
55734: PUSH
55735: LD_INT 30
55737: PUSH
55738: EMPTY
55739: LIST
55740: LIST
55741: LIST
55742: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55743: LD_VAR 0 6
55747: PPUSH
55748: CALL_OW 257
55752: PUSH
55753: LD_INT 9
55755: EQUAL
55756: IFFALSE 55777
// points := [ 20 , 55 , 40 ] ;
55758: LD_ADDR_VAR 0 9
55762: PUSH
55763: LD_INT 20
55765: PUSH
55766: LD_INT 55
55768: PUSH
55769: LD_INT 40
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: LIST
55776: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55777: LD_VAR 0 6
55781: PPUSH
55782: CALL_OW 257
55786: PUSH
55787: LD_INT 12
55789: PUSH
55790: LD_INT 16
55792: PUSH
55793: EMPTY
55794: LIST
55795: LIST
55796: IN
55797: IFFALSE 55818
// points := [ 5 , 3 , 2 ] ;
55799: LD_ADDR_VAR 0 9
55803: PUSH
55804: LD_INT 5
55806: PUSH
55807: LD_INT 3
55809: PUSH
55810: LD_INT 2
55812: PUSH
55813: EMPTY
55814: LIST
55815: LIST
55816: LIST
55817: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55818: LD_VAR 0 6
55822: PPUSH
55823: CALL_OW 257
55827: PUSH
55828: LD_INT 17
55830: EQUAL
55831: IFFALSE 55852
// points := [ 100 , 50 , 75 ] ;
55833: LD_ADDR_VAR 0 9
55837: PUSH
55838: LD_INT 100
55840: PUSH
55841: LD_INT 50
55843: PUSH
55844: LD_INT 75
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: LIST
55851: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55852: LD_VAR 0 6
55856: PPUSH
55857: CALL_OW 257
55861: PUSH
55862: LD_INT 15
55864: EQUAL
55865: IFFALSE 55886
// points := [ 10 , 5 , 3 ] ;
55867: LD_ADDR_VAR 0 9
55871: PUSH
55872: LD_INT 10
55874: PUSH
55875: LD_INT 5
55877: PUSH
55878: LD_INT 3
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: LIST
55885: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55886: LD_VAR 0 6
55890: PPUSH
55891: CALL_OW 257
55895: PUSH
55896: LD_INT 14
55898: EQUAL
55899: IFFALSE 55920
// points := [ 10 , 0 , 0 ] ;
55901: LD_ADDR_VAR 0 9
55905: PUSH
55906: LD_INT 10
55908: PUSH
55909: LD_INT 0
55911: PUSH
55912: LD_INT 0
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: LIST
55919: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55920: LD_VAR 0 6
55924: PPUSH
55925: CALL_OW 257
55929: PUSH
55930: LD_INT 11
55932: EQUAL
55933: IFFALSE 55954
// points := [ 30 , 10 , 5 ] ;
55935: LD_ADDR_VAR 0 9
55939: PUSH
55940: LD_INT 30
55942: PUSH
55943: LD_INT 10
55945: PUSH
55946: LD_INT 5
55948: PUSH
55949: EMPTY
55950: LIST
55951: LIST
55952: LIST
55953: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55954: LD_VAR 0 1
55958: PPUSH
55959: LD_INT 5
55961: PPUSH
55962: CALL_OW 321
55966: PUSH
55967: LD_INT 2
55969: EQUAL
55970: IFFALSE 55987
// bpoints := bpoints * 1.8 ;
55972: LD_ADDR_VAR 0 10
55976: PUSH
55977: LD_VAR 0 10
55981: PUSH
55982: LD_REAL  1.80000000000000E+0000
55985: MUL
55986: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55987: LD_VAR 0 6
55991: PPUSH
55992: CALL_OW 257
55996: PUSH
55997: LD_INT 1
55999: PUSH
56000: LD_INT 2
56002: PUSH
56003: LD_INT 3
56005: PUSH
56006: LD_INT 4
56008: PUSH
56009: EMPTY
56010: LIST
56011: LIST
56012: LIST
56013: LIST
56014: IN
56015: PUSH
56016: LD_VAR 0 1
56020: PPUSH
56021: LD_INT 51
56023: PPUSH
56024: CALL_OW 321
56028: PUSH
56029: LD_INT 2
56031: EQUAL
56032: AND
56033: IFFALSE 56050
// bpoints := bpoints * 1.2 ;
56035: LD_ADDR_VAR 0 10
56039: PUSH
56040: LD_VAR 0 10
56044: PUSH
56045: LD_REAL  1.20000000000000E+0000
56048: MUL
56049: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56050: LD_VAR 0 6
56054: PPUSH
56055: CALL_OW 257
56059: PUSH
56060: LD_INT 5
56062: PUSH
56063: LD_INT 7
56065: PUSH
56066: LD_INT 9
56068: PUSH
56069: EMPTY
56070: LIST
56071: LIST
56072: LIST
56073: IN
56074: PUSH
56075: LD_VAR 0 1
56079: PPUSH
56080: LD_INT 52
56082: PPUSH
56083: CALL_OW 321
56087: PUSH
56088: LD_INT 2
56090: EQUAL
56091: AND
56092: IFFALSE 56109
// bpoints := bpoints * 1.5 ;
56094: LD_ADDR_VAR 0 10
56098: PUSH
56099: LD_VAR 0 10
56103: PUSH
56104: LD_REAL  1.50000000000000E+0000
56107: MUL
56108: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56109: LD_VAR 0 1
56113: PPUSH
56114: LD_INT 66
56116: PPUSH
56117: CALL_OW 321
56121: PUSH
56122: LD_INT 2
56124: EQUAL
56125: IFFALSE 56142
// bpoints := bpoints * 1.1 ;
56127: LD_ADDR_VAR 0 10
56131: PUSH
56132: LD_VAR 0 10
56136: PUSH
56137: LD_REAL  1.10000000000000E+0000
56140: MUL
56141: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56142: LD_ADDR_VAR 0 10
56146: PUSH
56147: LD_VAR 0 10
56151: PUSH
56152: LD_VAR 0 6
56156: PPUSH
56157: LD_INT 1
56159: PPUSH
56160: CALL_OW 259
56164: PUSH
56165: LD_REAL  1.15000000000000E+0000
56168: MUL
56169: MUL
56170: ST_TO_ADDR
// end ; unit_vehicle :
56171: GO 56995
56173: LD_INT 2
56175: DOUBLE
56176: EQUAL
56177: IFTRUE 56181
56179: GO 56983
56181: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56182: LD_VAR 0 6
56186: PPUSH
56187: CALL_OW 264
56191: PUSH
56192: LD_INT 2
56194: PUSH
56195: LD_INT 42
56197: PUSH
56198: LD_INT 24
56200: PUSH
56201: EMPTY
56202: LIST
56203: LIST
56204: LIST
56205: IN
56206: IFFALSE 56227
// points := [ 25 , 5 , 3 ] ;
56208: LD_ADDR_VAR 0 9
56212: PUSH
56213: LD_INT 25
56215: PUSH
56216: LD_INT 5
56218: PUSH
56219: LD_INT 3
56221: PUSH
56222: EMPTY
56223: LIST
56224: LIST
56225: LIST
56226: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56227: LD_VAR 0 6
56231: PPUSH
56232: CALL_OW 264
56236: PUSH
56237: LD_INT 4
56239: PUSH
56240: LD_INT 43
56242: PUSH
56243: LD_INT 25
56245: PUSH
56246: EMPTY
56247: LIST
56248: LIST
56249: LIST
56250: IN
56251: IFFALSE 56272
// points := [ 40 , 15 , 5 ] ;
56253: LD_ADDR_VAR 0 9
56257: PUSH
56258: LD_INT 40
56260: PUSH
56261: LD_INT 15
56263: PUSH
56264: LD_INT 5
56266: PUSH
56267: EMPTY
56268: LIST
56269: LIST
56270: LIST
56271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56272: LD_VAR 0 6
56276: PPUSH
56277: CALL_OW 264
56281: PUSH
56282: LD_INT 3
56284: PUSH
56285: LD_INT 23
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: IN
56292: IFFALSE 56313
// points := [ 7 , 25 , 8 ] ;
56294: LD_ADDR_VAR 0 9
56298: PUSH
56299: LD_INT 7
56301: PUSH
56302: LD_INT 25
56304: PUSH
56305: LD_INT 8
56307: PUSH
56308: EMPTY
56309: LIST
56310: LIST
56311: LIST
56312: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56313: LD_VAR 0 6
56317: PPUSH
56318: CALL_OW 264
56322: PUSH
56323: LD_INT 5
56325: PUSH
56326: LD_INT 27
56328: PUSH
56329: LD_INT 44
56331: PUSH
56332: EMPTY
56333: LIST
56334: LIST
56335: LIST
56336: IN
56337: IFFALSE 56358
// points := [ 14 , 50 , 16 ] ;
56339: LD_ADDR_VAR 0 9
56343: PUSH
56344: LD_INT 14
56346: PUSH
56347: LD_INT 50
56349: PUSH
56350: LD_INT 16
56352: PUSH
56353: EMPTY
56354: LIST
56355: LIST
56356: LIST
56357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56358: LD_VAR 0 6
56362: PPUSH
56363: CALL_OW 264
56367: PUSH
56368: LD_INT 6
56370: PUSH
56371: LD_INT 46
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: IN
56378: IFFALSE 56399
// points := [ 32 , 120 , 70 ] ;
56380: LD_ADDR_VAR 0 9
56384: PUSH
56385: LD_INT 32
56387: PUSH
56388: LD_INT 120
56390: PUSH
56391: LD_INT 70
56393: PUSH
56394: EMPTY
56395: LIST
56396: LIST
56397: LIST
56398: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
56399: LD_VAR 0 6
56403: PPUSH
56404: CALL_OW 264
56408: PUSH
56409: LD_INT 7
56411: PUSH
56412: LD_INT 28
56414: PUSH
56415: LD_INT 45
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: LIST
56422: IN
56423: IFFALSE 56444
// points := [ 35 , 20 , 45 ] ;
56425: LD_ADDR_VAR 0 9
56429: PUSH
56430: LD_INT 35
56432: PUSH
56433: LD_INT 20
56435: PUSH
56436: LD_INT 45
56438: PUSH
56439: EMPTY
56440: LIST
56441: LIST
56442: LIST
56443: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56444: LD_VAR 0 6
56448: PPUSH
56449: CALL_OW 264
56453: PUSH
56454: LD_INT 47
56456: PUSH
56457: EMPTY
56458: LIST
56459: IN
56460: IFFALSE 56481
// points := [ 67 , 45 , 75 ] ;
56462: LD_ADDR_VAR 0 9
56466: PUSH
56467: LD_INT 67
56469: PUSH
56470: LD_INT 45
56472: PUSH
56473: LD_INT 75
56475: PUSH
56476: EMPTY
56477: LIST
56478: LIST
56479: LIST
56480: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56481: LD_VAR 0 6
56485: PPUSH
56486: CALL_OW 264
56490: PUSH
56491: LD_INT 26
56493: PUSH
56494: EMPTY
56495: LIST
56496: IN
56497: IFFALSE 56518
// points := [ 120 , 30 , 80 ] ;
56499: LD_ADDR_VAR 0 9
56503: PUSH
56504: LD_INT 120
56506: PUSH
56507: LD_INT 30
56509: PUSH
56510: LD_INT 80
56512: PUSH
56513: EMPTY
56514: LIST
56515: LIST
56516: LIST
56517: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56518: LD_VAR 0 6
56522: PPUSH
56523: CALL_OW 264
56527: PUSH
56528: LD_INT 22
56530: PUSH
56531: EMPTY
56532: LIST
56533: IN
56534: IFFALSE 56555
// points := [ 40 , 1 , 1 ] ;
56536: LD_ADDR_VAR 0 9
56540: PUSH
56541: LD_INT 40
56543: PUSH
56544: LD_INT 1
56546: PUSH
56547: LD_INT 1
56549: PUSH
56550: EMPTY
56551: LIST
56552: LIST
56553: LIST
56554: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56555: LD_VAR 0 6
56559: PPUSH
56560: CALL_OW 264
56564: PUSH
56565: LD_INT 29
56567: PUSH
56568: EMPTY
56569: LIST
56570: IN
56571: IFFALSE 56592
// points := [ 70 , 200 , 400 ] ;
56573: LD_ADDR_VAR 0 9
56577: PUSH
56578: LD_INT 70
56580: PUSH
56581: LD_INT 200
56583: PUSH
56584: LD_INT 400
56586: PUSH
56587: EMPTY
56588: LIST
56589: LIST
56590: LIST
56591: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56592: LD_VAR 0 6
56596: PPUSH
56597: CALL_OW 264
56601: PUSH
56602: LD_INT 14
56604: PUSH
56605: LD_INT 53
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: IN
56612: IFFALSE 56633
// points := [ 40 , 10 , 20 ] ;
56614: LD_ADDR_VAR 0 9
56618: PUSH
56619: LD_INT 40
56621: PUSH
56622: LD_INT 10
56624: PUSH
56625: LD_INT 20
56627: PUSH
56628: EMPTY
56629: LIST
56630: LIST
56631: LIST
56632: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56633: LD_VAR 0 6
56637: PPUSH
56638: CALL_OW 264
56642: PUSH
56643: LD_INT 9
56645: PUSH
56646: EMPTY
56647: LIST
56648: IN
56649: IFFALSE 56670
// points := [ 5 , 70 , 20 ] ;
56651: LD_ADDR_VAR 0 9
56655: PUSH
56656: LD_INT 5
56658: PUSH
56659: LD_INT 70
56661: PUSH
56662: LD_INT 20
56664: PUSH
56665: EMPTY
56666: LIST
56667: LIST
56668: LIST
56669: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56670: LD_VAR 0 6
56674: PPUSH
56675: CALL_OW 264
56679: PUSH
56680: LD_INT 10
56682: PUSH
56683: EMPTY
56684: LIST
56685: IN
56686: IFFALSE 56707
// points := [ 35 , 110 , 70 ] ;
56688: LD_ADDR_VAR 0 9
56692: PUSH
56693: LD_INT 35
56695: PUSH
56696: LD_INT 110
56698: PUSH
56699: LD_INT 70
56701: PUSH
56702: EMPTY
56703: LIST
56704: LIST
56705: LIST
56706: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56707: LD_VAR 0 6
56711: PPUSH
56712: CALL_OW 265
56716: PUSH
56717: LD_INT 25
56719: EQUAL
56720: IFFALSE 56741
// points := [ 80 , 65 , 100 ] ;
56722: LD_ADDR_VAR 0 9
56726: PUSH
56727: LD_INT 80
56729: PUSH
56730: LD_INT 65
56732: PUSH
56733: LD_INT 100
56735: PUSH
56736: EMPTY
56737: LIST
56738: LIST
56739: LIST
56740: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56741: LD_VAR 0 6
56745: PPUSH
56746: CALL_OW 263
56750: PUSH
56751: LD_INT 1
56753: EQUAL
56754: IFFALSE 56789
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56756: LD_ADDR_VAR 0 10
56760: PUSH
56761: LD_VAR 0 10
56765: PUSH
56766: LD_VAR 0 6
56770: PPUSH
56771: CALL_OW 311
56775: PPUSH
56776: LD_INT 3
56778: PPUSH
56779: CALL_OW 259
56783: PUSH
56784: LD_INT 4
56786: MUL
56787: MUL
56788: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56789: LD_VAR 0 6
56793: PPUSH
56794: CALL_OW 263
56798: PUSH
56799: LD_INT 2
56801: EQUAL
56802: IFFALSE 56853
// begin j := IsControledBy ( i ) ;
56804: LD_ADDR_VAR 0 7
56808: PUSH
56809: LD_VAR 0 6
56813: PPUSH
56814: CALL_OW 312
56818: ST_TO_ADDR
// if j then
56819: LD_VAR 0 7
56823: IFFALSE 56853
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56825: LD_ADDR_VAR 0 10
56829: PUSH
56830: LD_VAR 0 10
56834: PUSH
56835: LD_VAR 0 7
56839: PPUSH
56840: LD_INT 3
56842: PPUSH
56843: CALL_OW 259
56847: PUSH
56848: LD_INT 3
56850: MUL
56851: MUL
56852: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56853: LD_VAR 0 6
56857: PPUSH
56858: CALL_OW 264
56862: PUSH
56863: LD_INT 5
56865: PUSH
56866: LD_INT 6
56868: PUSH
56869: LD_INT 46
56871: PUSH
56872: LD_INT 44
56874: PUSH
56875: LD_INT 47
56877: PUSH
56878: LD_INT 45
56880: PUSH
56881: LD_INT 28
56883: PUSH
56884: LD_INT 7
56886: PUSH
56887: LD_INT 27
56889: PUSH
56890: LD_INT 29
56892: PUSH
56893: EMPTY
56894: LIST
56895: LIST
56896: LIST
56897: LIST
56898: LIST
56899: LIST
56900: LIST
56901: LIST
56902: LIST
56903: LIST
56904: IN
56905: PUSH
56906: LD_VAR 0 1
56910: PPUSH
56911: LD_INT 52
56913: PPUSH
56914: CALL_OW 321
56918: PUSH
56919: LD_INT 2
56921: EQUAL
56922: AND
56923: IFFALSE 56940
// bpoints := bpoints * 1.2 ;
56925: LD_ADDR_VAR 0 10
56929: PUSH
56930: LD_VAR 0 10
56934: PUSH
56935: LD_REAL  1.20000000000000E+0000
56938: MUL
56939: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56940: LD_VAR 0 6
56944: PPUSH
56945: CALL_OW 264
56949: PUSH
56950: LD_INT 6
56952: PUSH
56953: LD_INT 46
56955: PUSH
56956: LD_INT 47
56958: PUSH
56959: EMPTY
56960: LIST
56961: LIST
56962: LIST
56963: IN
56964: IFFALSE 56981
// bpoints := bpoints * 1.2 ;
56966: LD_ADDR_VAR 0 10
56970: PUSH
56971: LD_VAR 0 10
56975: PUSH
56976: LD_REAL  1.20000000000000E+0000
56979: MUL
56980: ST_TO_ADDR
// end ; unit_building :
56981: GO 56995
56983: LD_INT 3
56985: DOUBLE
56986: EQUAL
56987: IFTRUE 56991
56989: GO 56994
56991: POP
// ; end ;
56992: GO 56995
56994: POP
// for j = 1 to 3 do
56995: LD_ADDR_VAR 0 7
56999: PUSH
57000: DOUBLE
57001: LD_INT 1
57003: DEC
57004: ST_TO_ADDR
57005: LD_INT 3
57007: PUSH
57008: FOR_TO
57009: IFFALSE 57062
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57011: LD_ADDR_VAR 0 5
57015: PUSH
57016: LD_VAR 0 5
57020: PPUSH
57021: LD_VAR 0 7
57025: PPUSH
57026: LD_VAR 0 5
57030: PUSH
57031: LD_VAR 0 7
57035: ARRAY
57036: PUSH
57037: LD_VAR 0 9
57041: PUSH
57042: LD_VAR 0 7
57046: ARRAY
57047: PUSH
57048: LD_VAR 0 10
57052: MUL
57053: PLUS
57054: PPUSH
57055: CALL_OW 1
57059: ST_TO_ADDR
57060: GO 57008
57062: POP
57063: POP
// end ;
57064: GO 55547
57066: POP
57067: POP
// result := Replace ( result , 4 , tmp ) ;
57068: LD_ADDR_VAR 0 5
57072: PUSH
57073: LD_VAR 0 5
57077: PPUSH
57078: LD_INT 4
57080: PPUSH
57081: LD_VAR 0 8
57085: PPUSH
57086: CALL_OW 1
57090: ST_TO_ADDR
// end ;
57091: LD_VAR 0 5
57095: RET
// export function DangerAtRange ( unit , range ) ; begin
57096: LD_INT 0
57098: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57099: LD_ADDR_VAR 0 3
57103: PUSH
57104: LD_VAR 0 1
57108: PPUSH
57109: CALL_OW 255
57113: PPUSH
57114: LD_VAR 0 1
57118: PPUSH
57119: CALL_OW 250
57123: PPUSH
57124: LD_VAR 0 1
57128: PPUSH
57129: CALL_OW 251
57133: PPUSH
57134: LD_VAR 0 2
57138: PPUSH
57139: CALL 55399 0 4
57143: ST_TO_ADDR
// end ;
57144: LD_VAR 0 3
57148: RET
// export function DangerInArea ( side , area ) ; begin
57149: LD_INT 0
57151: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57152: LD_ADDR_VAR 0 3
57156: PUSH
57157: LD_VAR 0 2
57161: PPUSH
57162: LD_INT 81
57164: PUSH
57165: LD_VAR 0 1
57169: PUSH
57170: EMPTY
57171: LIST
57172: LIST
57173: PPUSH
57174: CALL_OW 70
57178: ST_TO_ADDR
// end ;
57179: LD_VAR 0 3
57183: RET
// export function IsExtension ( b ) ; begin
57184: LD_INT 0
57186: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57187: LD_ADDR_VAR 0 2
57191: PUSH
57192: LD_VAR 0 1
57196: PUSH
57197: LD_INT 23
57199: PUSH
57200: LD_INT 20
57202: PUSH
57203: LD_INT 22
57205: PUSH
57206: LD_INT 17
57208: PUSH
57209: LD_INT 24
57211: PUSH
57212: LD_INT 21
57214: PUSH
57215: LD_INT 19
57217: PUSH
57218: LD_INT 16
57220: PUSH
57221: LD_INT 25
57223: PUSH
57224: LD_INT 18
57226: PUSH
57227: EMPTY
57228: LIST
57229: LIST
57230: LIST
57231: LIST
57232: LIST
57233: LIST
57234: LIST
57235: LIST
57236: LIST
57237: LIST
57238: IN
57239: ST_TO_ADDR
// end ;
57240: LD_VAR 0 2
57244: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
57245: LD_INT 0
57247: PPUSH
57248: PPUSH
57249: PPUSH
// result := [ ] ;
57250: LD_ADDR_VAR 0 3
57254: PUSH
57255: EMPTY
57256: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57257: LD_ADDR_VAR 0 4
57261: PUSH
57262: LD_VAR 0 2
57266: PPUSH
57267: LD_INT 21
57269: PUSH
57270: LD_INT 3
57272: PUSH
57273: EMPTY
57274: LIST
57275: LIST
57276: PPUSH
57277: CALL_OW 70
57281: ST_TO_ADDR
// if not tmp then
57282: LD_VAR 0 4
57286: NOT
57287: IFFALSE 57291
// exit ;
57289: GO 57349
// for i in tmp do
57291: LD_ADDR_VAR 0 5
57295: PUSH
57296: LD_VAR 0 4
57300: PUSH
57301: FOR_IN
57302: IFFALSE 57337
// if GetBase ( i ) <> base then
57304: LD_VAR 0 5
57308: PPUSH
57309: CALL_OW 274
57313: PUSH
57314: LD_VAR 0 1
57318: NONEQUAL
57319: IFFALSE 57335
// ComLinkToBase ( base , i ) ;
57321: LD_VAR 0 1
57325: PPUSH
57326: LD_VAR 0 5
57330: PPUSH
57331: CALL_OW 169
57335: GO 57301
57337: POP
57338: POP
// result := tmp ;
57339: LD_ADDR_VAR 0 3
57343: PUSH
57344: LD_VAR 0 4
57348: ST_TO_ADDR
// end ;
57349: LD_VAR 0 3
57353: RET
// export function ComComplete ( unit , b ) ; var i ; begin
57354: LD_INT 0
57356: PPUSH
57357: PPUSH
// if BuildingStatus ( b ) = bs_build then
57358: LD_VAR 0 2
57362: PPUSH
57363: CALL_OW 461
57367: PUSH
57368: LD_INT 1
57370: EQUAL
57371: IFFALSE 57431
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57373: LD_VAR 0 1
57377: PPUSH
57378: LD_STRING h
57380: PUSH
57381: LD_VAR 0 2
57385: PPUSH
57386: CALL_OW 250
57390: PUSH
57391: LD_VAR 0 2
57395: PPUSH
57396: CALL_OW 251
57400: PUSH
57401: LD_VAR 0 2
57405: PUSH
57406: LD_INT 0
57408: PUSH
57409: LD_INT 0
57411: PUSH
57412: LD_INT 0
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: LIST
57419: LIST
57420: LIST
57421: LIST
57422: LIST
57423: PUSH
57424: EMPTY
57425: LIST
57426: PPUSH
57427: CALL_OW 446
// end ;
57431: LD_VAR 0 3
57435: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57436: LD_INT 0
57438: PPUSH
57439: PPUSH
57440: PPUSH
57441: PPUSH
57442: PPUSH
57443: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
57444: LD_VAR 0 1
57448: NOT
57449: PUSH
57450: LD_VAR 0 1
57454: PPUSH
57455: CALL_OW 263
57459: PUSH
57460: LD_INT 2
57462: EQUAL
57463: NOT
57464: OR
57465: IFFALSE 57469
// exit ;
57467: GO 57785
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57469: LD_ADDR_VAR 0 6
57473: PUSH
57474: LD_INT 22
57476: PUSH
57477: LD_VAR 0 1
57481: PPUSH
57482: CALL_OW 255
57486: PUSH
57487: EMPTY
57488: LIST
57489: LIST
57490: PUSH
57491: LD_INT 2
57493: PUSH
57494: LD_INT 30
57496: PUSH
57497: LD_INT 36
57499: PUSH
57500: EMPTY
57501: LIST
57502: LIST
57503: PUSH
57504: LD_INT 34
57506: PUSH
57507: LD_INT 31
57509: PUSH
57510: EMPTY
57511: LIST
57512: LIST
57513: PUSH
57514: EMPTY
57515: LIST
57516: LIST
57517: LIST
57518: PUSH
57519: EMPTY
57520: LIST
57521: LIST
57522: PPUSH
57523: CALL_OW 69
57527: ST_TO_ADDR
// if not tmp then
57528: LD_VAR 0 6
57532: NOT
57533: IFFALSE 57537
// exit ;
57535: GO 57785
// result := [ ] ;
57537: LD_ADDR_VAR 0 2
57541: PUSH
57542: EMPTY
57543: ST_TO_ADDR
// for i in tmp do
57544: LD_ADDR_VAR 0 3
57548: PUSH
57549: LD_VAR 0 6
57553: PUSH
57554: FOR_IN
57555: IFFALSE 57626
// begin t := UnitsInside ( i ) ;
57557: LD_ADDR_VAR 0 4
57561: PUSH
57562: LD_VAR 0 3
57566: PPUSH
57567: CALL_OW 313
57571: ST_TO_ADDR
// if t then
57572: LD_VAR 0 4
57576: IFFALSE 57624
// for j in t do
57578: LD_ADDR_VAR 0 7
57582: PUSH
57583: LD_VAR 0 4
57587: PUSH
57588: FOR_IN
57589: IFFALSE 57622
// result := Insert ( result , result + 1 , j ) ;
57591: LD_ADDR_VAR 0 2
57595: PUSH
57596: LD_VAR 0 2
57600: PPUSH
57601: LD_VAR 0 2
57605: PUSH
57606: LD_INT 1
57608: PLUS
57609: PPUSH
57610: LD_VAR 0 7
57614: PPUSH
57615: CALL_OW 2
57619: ST_TO_ADDR
57620: GO 57588
57622: POP
57623: POP
// end ;
57624: GO 57554
57626: POP
57627: POP
// if not result then
57628: LD_VAR 0 2
57632: NOT
57633: IFFALSE 57637
// exit ;
57635: GO 57785
// mech := result [ 1 ] ;
57637: LD_ADDR_VAR 0 5
57641: PUSH
57642: LD_VAR 0 2
57646: PUSH
57647: LD_INT 1
57649: ARRAY
57650: ST_TO_ADDR
// if result > 1 then
57651: LD_VAR 0 2
57655: PUSH
57656: LD_INT 1
57658: GREATER
57659: IFFALSE 57771
// for i = 2 to result do
57661: LD_ADDR_VAR 0 3
57665: PUSH
57666: DOUBLE
57667: LD_INT 2
57669: DEC
57670: ST_TO_ADDR
57671: LD_VAR 0 2
57675: PUSH
57676: FOR_TO
57677: IFFALSE 57769
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57679: LD_ADDR_VAR 0 4
57683: PUSH
57684: LD_VAR 0 2
57688: PUSH
57689: LD_VAR 0 3
57693: ARRAY
57694: PPUSH
57695: LD_INT 3
57697: PPUSH
57698: CALL_OW 259
57702: PUSH
57703: LD_VAR 0 2
57707: PUSH
57708: LD_VAR 0 3
57712: ARRAY
57713: PPUSH
57714: CALL_OW 432
57718: MINUS
57719: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57720: LD_VAR 0 4
57724: PUSH
57725: LD_VAR 0 5
57729: PPUSH
57730: LD_INT 3
57732: PPUSH
57733: CALL_OW 259
57737: PUSH
57738: LD_VAR 0 5
57742: PPUSH
57743: CALL_OW 432
57747: MINUS
57748: GREATEREQUAL
57749: IFFALSE 57767
// mech := result [ i ] ;
57751: LD_ADDR_VAR 0 5
57755: PUSH
57756: LD_VAR 0 2
57760: PUSH
57761: LD_VAR 0 3
57765: ARRAY
57766: ST_TO_ADDR
// end ;
57767: GO 57676
57769: POP
57770: POP
// ComLinkTo ( vehicle , mech ) ;
57771: LD_VAR 0 1
57775: PPUSH
57776: LD_VAR 0 5
57780: PPUSH
57781: CALL_OW 135
// end ;
57785: LD_VAR 0 2
57789: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57790: LD_INT 0
57792: PPUSH
57793: PPUSH
57794: PPUSH
57795: PPUSH
57796: PPUSH
57797: PPUSH
57798: PPUSH
57799: PPUSH
57800: PPUSH
57801: PPUSH
57802: PPUSH
57803: PPUSH
57804: PPUSH
// result := [ ] ;
57805: LD_ADDR_VAR 0 7
57809: PUSH
57810: EMPTY
57811: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57812: LD_VAR 0 1
57816: PPUSH
57817: CALL_OW 266
57821: PUSH
57822: LD_INT 0
57824: PUSH
57825: LD_INT 1
57827: PUSH
57828: EMPTY
57829: LIST
57830: LIST
57831: IN
57832: NOT
57833: IFFALSE 57837
// exit ;
57835: GO 59468
// if name then
57837: LD_VAR 0 3
57841: IFFALSE 57857
// SetBName ( base_dep , name ) ;
57843: LD_VAR 0 1
57847: PPUSH
57848: LD_VAR 0 3
57852: PPUSH
57853: CALL_OW 500
// base := GetBase ( base_dep ) ;
57857: LD_ADDR_VAR 0 15
57861: PUSH
57862: LD_VAR 0 1
57866: PPUSH
57867: CALL_OW 274
57871: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57872: LD_ADDR_VAR 0 16
57876: PUSH
57877: LD_VAR 0 1
57881: PPUSH
57882: CALL_OW 255
57886: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57887: LD_ADDR_VAR 0 17
57891: PUSH
57892: LD_VAR 0 1
57896: PPUSH
57897: CALL_OW 248
57901: ST_TO_ADDR
// if sources then
57902: LD_VAR 0 5
57906: IFFALSE 57953
// for i = 1 to 3 do
57908: LD_ADDR_VAR 0 8
57912: PUSH
57913: DOUBLE
57914: LD_INT 1
57916: DEC
57917: ST_TO_ADDR
57918: LD_INT 3
57920: PUSH
57921: FOR_TO
57922: IFFALSE 57951
// AddResourceType ( base , i , sources [ i ] ) ;
57924: LD_VAR 0 15
57928: PPUSH
57929: LD_VAR 0 8
57933: PPUSH
57934: LD_VAR 0 5
57938: PUSH
57939: LD_VAR 0 8
57943: ARRAY
57944: PPUSH
57945: CALL_OW 276
57949: GO 57921
57951: POP
57952: POP
// buildings := GetBaseBuildings ( base , area ) ;
57953: LD_ADDR_VAR 0 18
57957: PUSH
57958: LD_VAR 0 15
57962: PPUSH
57963: LD_VAR 0 2
57967: PPUSH
57968: CALL 57245 0 2
57972: ST_TO_ADDR
// InitHc ;
57973: CALL_OW 19
// InitUc ;
57977: CALL_OW 18
// uc_side := side ;
57981: LD_ADDR_OWVAR 20
57985: PUSH
57986: LD_VAR 0 16
57990: ST_TO_ADDR
// uc_nation := nation ;
57991: LD_ADDR_OWVAR 21
57995: PUSH
57996: LD_VAR 0 17
58000: ST_TO_ADDR
// if buildings then
58001: LD_VAR 0 18
58005: IFFALSE 59327
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58007: LD_ADDR_VAR 0 19
58011: PUSH
58012: LD_VAR 0 18
58016: PPUSH
58017: LD_INT 2
58019: PUSH
58020: LD_INT 30
58022: PUSH
58023: LD_INT 29
58025: PUSH
58026: EMPTY
58027: LIST
58028: LIST
58029: PUSH
58030: LD_INT 30
58032: PUSH
58033: LD_INT 30
58035: PUSH
58036: EMPTY
58037: LIST
58038: LIST
58039: PUSH
58040: EMPTY
58041: LIST
58042: LIST
58043: LIST
58044: PPUSH
58045: CALL_OW 72
58049: ST_TO_ADDR
// if tmp then
58050: LD_VAR 0 19
58054: IFFALSE 58102
// for i in tmp do
58056: LD_ADDR_VAR 0 8
58060: PUSH
58061: LD_VAR 0 19
58065: PUSH
58066: FOR_IN
58067: IFFALSE 58100
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58069: LD_VAR 0 8
58073: PPUSH
58074: CALL_OW 250
58078: PPUSH
58079: LD_VAR 0 8
58083: PPUSH
58084: CALL_OW 251
58088: PPUSH
58089: LD_VAR 0 16
58093: PPUSH
58094: CALL_OW 441
58098: GO 58066
58100: POP
58101: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58102: LD_VAR 0 18
58106: PPUSH
58107: LD_INT 2
58109: PUSH
58110: LD_INT 30
58112: PUSH
58113: LD_INT 32
58115: PUSH
58116: EMPTY
58117: LIST
58118: LIST
58119: PUSH
58120: LD_INT 30
58122: PUSH
58123: LD_INT 33
58125: PUSH
58126: EMPTY
58127: LIST
58128: LIST
58129: PUSH
58130: EMPTY
58131: LIST
58132: LIST
58133: LIST
58134: PPUSH
58135: CALL_OW 72
58139: IFFALSE 58227
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58141: LD_ADDR_VAR 0 8
58145: PUSH
58146: LD_VAR 0 18
58150: PPUSH
58151: LD_INT 2
58153: PUSH
58154: LD_INT 30
58156: PUSH
58157: LD_INT 32
58159: PUSH
58160: EMPTY
58161: LIST
58162: LIST
58163: PUSH
58164: LD_INT 30
58166: PUSH
58167: LD_INT 33
58169: PUSH
58170: EMPTY
58171: LIST
58172: LIST
58173: PUSH
58174: EMPTY
58175: LIST
58176: LIST
58177: LIST
58178: PPUSH
58179: CALL_OW 72
58183: PUSH
58184: FOR_IN
58185: IFFALSE 58225
// begin if not GetBWeapon ( i ) then
58187: LD_VAR 0 8
58191: PPUSH
58192: CALL_OW 269
58196: NOT
58197: IFFALSE 58223
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58199: LD_VAR 0 8
58203: PPUSH
58204: LD_VAR 0 8
58208: PPUSH
58209: LD_VAR 0 2
58213: PPUSH
58214: CALL 59473 0 2
58218: PPUSH
58219: CALL_OW 431
// end ;
58223: GO 58184
58225: POP
58226: POP
// end ; for i = 1 to personel do
58227: LD_ADDR_VAR 0 8
58231: PUSH
58232: DOUBLE
58233: LD_INT 1
58235: DEC
58236: ST_TO_ADDR
58237: LD_VAR 0 6
58241: PUSH
58242: FOR_TO
58243: IFFALSE 59307
// begin if i > 4 then
58245: LD_VAR 0 8
58249: PUSH
58250: LD_INT 4
58252: GREATER
58253: IFFALSE 58257
// break ;
58255: GO 59307
// case i of 1 :
58257: LD_VAR 0 8
58261: PUSH
58262: LD_INT 1
58264: DOUBLE
58265: EQUAL
58266: IFTRUE 58270
58268: GO 58350
58270: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58271: LD_ADDR_VAR 0 12
58275: PUSH
58276: LD_VAR 0 18
58280: PPUSH
58281: LD_INT 22
58283: PUSH
58284: LD_VAR 0 16
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: PUSH
58293: LD_INT 58
58295: PUSH
58296: EMPTY
58297: LIST
58298: PUSH
58299: LD_INT 2
58301: PUSH
58302: LD_INT 30
58304: PUSH
58305: LD_INT 32
58307: PUSH
58308: EMPTY
58309: LIST
58310: LIST
58311: PUSH
58312: LD_INT 30
58314: PUSH
58315: LD_INT 4
58317: PUSH
58318: EMPTY
58319: LIST
58320: LIST
58321: PUSH
58322: LD_INT 30
58324: PUSH
58325: LD_INT 5
58327: PUSH
58328: EMPTY
58329: LIST
58330: LIST
58331: PUSH
58332: EMPTY
58333: LIST
58334: LIST
58335: LIST
58336: LIST
58337: PUSH
58338: EMPTY
58339: LIST
58340: LIST
58341: LIST
58342: PPUSH
58343: CALL_OW 72
58347: ST_TO_ADDR
58348: GO 58572
58350: LD_INT 2
58352: DOUBLE
58353: EQUAL
58354: IFTRUE 58358
58356: GO 58420
58358: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58359: LD_ADDR_VAR 0 12
58363: PUSH
58364: LD_VAR 0 18
58368: PPUSH
58369: LD_INT 22
58371: PUSH
58372: LD_VAR 0 16
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 2
58383: PUSH
58384: LD_INT 30
58386: PUSH
58387: LD_INT 0
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: PUSH
58394: LD_INT 30
58396: PUSH
58397: LD_INT 1
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: PUSH
58404: EMPTY
58405: LIST
58406: LIST
58407: LIST
58408: PUSH
58409: EMPTY
58410: LIST
58411: LIST
58412: PPUSH
58413: CALL_OW 72
58417: ST_TO_ADDR
58418: GO 58572
58420: LD_INT 3
58422: DOUBLE
58423: EQUAL
58424: IFTRUE 58428
58426: GO 58490
58428: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58429: LD_ADDR_VAR 0 12
58433: PUSH
58434: LD_VAR 0 18
58438: PPUSH
58439: LD_INT 22
58441: PUSH
58442: LD_VAR 0 16
58446: PUSH
58447: EMPTY
58448: LIST
58449: LIST
58450: PUSH
58451: LD_INT 2
58453: PUSH
58454: LD_INT 30
58456: PUSH
58457: LD_INT 2
58459: PUSH
58460: EMPTY
58461: LIST
58462: LIST
58463: PUSH
58464: LD_INT 30
58466: PUSH
58467: LD_INT 3
58469: PUSH
58470: EMPTY
58471: LIST
58472: LIST
58473: PUSH
58474: EMPTY
58475: LIST
58476: LIST
58477: LIST
58478: PUSH
58479: EMPTY
58480: LIST
58481: LIST
58482: PPUSH
58483: CALL_OW 72
58487: ST_TO_ADDR
58488: GO 58572
58490: LD_INT 4
58492: DOUBLE
58493: EQUAL
58494: IFTRUE 58498
58496: GO 58571
58498: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58499: LD_ADDR_VAR 0 12
58503: PUSH
58504: LD_VAR 0 18
58508: PPUSH
58509: LD_INT 22
58511: PUSH
58512: LD_VAR 0 16
58516: PUSH
58517: EMPTY
58518: LIST
58519: LIST
58520: PUSH
58521: LD_INT 2
58523: PUSH
58524: LD_INT 30
58526: PUSH
58527: LD_INT 6
58529: PUSH
58530: EMPTY
58531: LIST
58532: LIST
58533: PUSH
58534: LD_INT 30
58536: PUSH
58537: LD_INT 7
58539: PUSH
58540: EMPTY
58541: LIST
58542: LIST
58543: PUSH
58544: LD_INT 30
58546: PUSH
58547: LD_INT 8
58549: PUSH
58550: EMPTY
58551: LIST
58552: LIST
58553: PUSH
58554: EMPTY
58555: LIST
58556: LIST
58557: LIST
58558: LIST
58559: PUSH
58560: EMPTY
58561: LIST
58562: LIST
58563: PPUSH
58564: CALL_OW 72
58568: ST_TO_ADDR
58569: GO 58572
58571: POP
// if i = 1 then
58572: LD_VAR 0 8
58576: PUSH
58577: LD_INT 1
58579: EQUAL
58580: IFFALSE 58691
// begin tmp := [ ] ;
58582: LD_ADDR_VAR 0 19
58586: PUSH
58587: EMPTY
58588: ST_TO_ADDR
// for j in f do
58589: LD_ADDR_VAR 0 9
58593: PUSH
58594: LD_VAR 0 12
58598: PUSH
58599: FOR_IN
58600: IFFALSE 58673
// if GetBType ( j ) = b_bunker then
58602: LD_VAR 0 9
58606: PPUSH
58607: CALL_OW 266
58611: PUSH
58612: LD_INT 32
58614: EQUAL
58615: IFFALSE 58642
// tmp := Insert ( tmp , 1 , j ) else
58617: LD_ADDR_VAR 0 19
58621: PUSH
58622: LD_VAR 0 19
58626: PPUSH
58627: LD_INT 1
58629: PPUSH
58630: LD_VAR 0 9
58634: PPUSH
58635: CALL_OW 2
58639: ST_TO_ADDR
58640: GO 58671
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58642: LD_ADDR_VAR 0 19
58646: PUSH
58647: LD_VAR 0 19
58651: PPUSH
58652: LD_VAR 0 19
58656: PUSH
58657: LD_INT 1
58659: PLUS
58660: PPUSH
58661: LD_VAR 0 9
58665: PPUSH
58666: CALL_OW 2
58670: ST_TO_ADDR
58671: GO 58599
58673: POP
58674: POP
// if tmp then
58675: LD_VAR 0 19
58679: IFFALSE 58691
// f := tmp ;
58681: LD_ADDR_VAR 0 12
58685: PUSH
58686: LD_VAR 0 19
58690: ST_TO_ADDR
// end ; x := personel [ i ] ;
58691: LD_ADDR_VAR 0 13
58695: PUSH
58696: LD_VAR 0 6
58700: PUSH
58701: LD_VAR 0 8
58705: ARRAY
58706: ST_TO_ADDR
// if x = - 1 then
58707: LD_VAR 0 13
58711: PUSH
58712: LD_INT 1
58714: NEG
58715: EQUAL
58716: IFFALSE 58925
// begin for j in f do
58718: LD_ADDR_VAR 0 9
58722: PUSH
58723: LD_VAR 0 12
58727: PUSH
58728: FOR_IN
58729: IFFALSE 58921
// repeat InitHc ;
58731: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58735: LD_VAR 0 9
58739: PPUSH
58740: CALL_OW 266
58744: PUSH
58745: LD_INT 5
58747: EQUAL
58748: IFFALSE 58818
// begin if UnitsInside ( j ) < 3 then
58750: LD_VAR 0 9
58754: PPUSH
58755: CALL_OW 313
58759: PUSH
58760: LD_INT 3
58762: LESS
58763: IFFALSE 58799
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58765: LD_INT 0
58767: PPUSH
58768: LD_INT 5
58770: PUSH
58771: LD_INT 8
58773: PUSH
58774: LD_INT 9
58776: PUSH
58777: EMPTY
58778: LIST
58779: LIST
58780: LIST
58781: PUSH
58782: LD_VAR 0 17
58786: ARRAY
58787: PPUSH
58788: LD_VAR 0 4
58792: PPUSH
58793: CALL_OW 380
58797: GO 58816
// PrepareHuman ( false , i , skill ) ;
58799: LD_INT 0
58801: PPUSH
58802: LD_VAR 0 8
58806: PPUSH
58807: LD_VAR 0 4
58811: PPUSH
58812: CALL_OW 380
// end else
58816: GO 58835
// PrepareHuman ( false , i , skill ) ;
58818: LD_INT 0
58820: PPUSH
58821: LD_VAR 0 8
58825: PPUSH
58826: LD_VAR 0 4
58830: PPUSH
58831: CALL_OW 380
// un := CreateHuman ;
58835: LD_ADDR_VAR 0 14
58839: PUSH
58840: CALL_OW 44
58844: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58845: LD_ADDR_VAR 0 7
58849: PUSH
58850: LD_VAR 0 7
58854: PPUSH
58855: LD_INT 1
58857: PPUSH
58858: LD_VAR 0 14
58862: PPUSH
58863: CALL_OW 2
58867: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58868: LD_VAR 0 14
58872: PPUSH
58873: LD_VAR 0 9
58877: PPUSH
58878: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58882: LD_VAR 0 9
58886: PPUSH
58887: CALL_OW 313
58891: PUSH
58892: LD_INT 6
58894: EQUAL
58895: PUSH
58896: LD_VAR 0 9
58900: PPUSH
58901: CALL_OW 266
58905: PUSH
58906: LD_INT 32
58908: PUSH
58909: LD_INT 31
58911: PUSH
58912: EMPTY
58913: LIST
58914: LIST
58915: IN
58916: OR
58917: IFFALSE 58731
58919: GO 58728
58921: POP
58922: POP
// end else
58923: GO 59305
// for j = 1 to x do
58925: LD_ADDR_VAR 0 9
58929: PUSH
58930: DOUBLE
58931: LD_INT 1
58933: DEC
58934: ST_TO_ADDR
58935: LD_VAR 0 13
58939: PUSH
58940: FOR_TO
58941: IFFALSE 59303
// begin InitHc ;
58943: CALL_OW 19
// if not f then
58947: LD_VAR 0 12
58951: NOT
58952: IFFALSE 59041
// begin PrepareHuman ( false , i , skill ) ;
58954: LD_INT 0
58956: PPUSH
58957: LD_VAR 0 8
58961: PPUSH
58962: LD_VAR 0 4
58966: PPUSH
58967: CALL_OW 380
// un := CreateHuman ;
58971: LD_ADDR_VAR 0 14
58975: PUSH
58976: CALL_OW 44
58980: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58981: LD_ADDR_VAR 0 7
58985: PUSH
58986: LD_VAR 0 7
58990: PPUSH
58991: LD_INT 1
58993: PPUSH
58994: LD_VAR 0 14
58998: PPUSH
58999: CALL_OW 2
59003: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59004: LD_VAR 0 14
59008: PPUSH
59009: LD_VAR 0 1
59013: PPUSH
59014: CALL_OW 250
59018: PPUSH
59019: LD_VAR 0 1
59023: PPUSH
59024: CALL_OW 251
59028: PPUSH
59029: LD_INT 10
59031: PPUSH
59032: LD_INT 0
59034: PPUSH
59035: CALL_OW 50
// continue ;
59039: GO 58940
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59041: LD_VAR 0 12
59045: PUSH
59046: LD_INT 1
59048: ARRAY
59049: PPUSH
59050: CALL_OW 313
59054: PUSH
59055: LD_VAR 0 12
59059: PUSH
59060: LD_INT 1
59062: ARRAY
59063: PPUSH
59064: CALL_OW 266
59068: PUSH
59069: LD_INT 32
59071: PUSH
59072: LD_INT 31
59074: PUSH
59075: EMPTY
59076: LIST
59077: LIST
59078: IN
59079: AND
59080: PUSH
59081: LD_VAR 0 12
59085: PUSH
59086: LD_INT 1
59088: ARRAY
59089: PPUSH
59090: CALL_OW 313
59094: PUSH
59095: LD_INT 6
59097: EQUAL
59098: OR
59099: IFFALSE 59119
// f := Delete ( f , 1 ) ;
59101: LD_ADDR_VAR 0 12
59105: PUSH
59106: LD_VAR 0 12
59110: PPUSH
59111: LD_INT 1
59113: PPUSH
59114: CALL_OW 3
59118: ST_TO_ADDR
// if not f then
59119: LD_VAR 0 12
59123: NOT
59124: IFFALSE 59142
// begin x := x + 2 ;
59126: LD_ADDR_VAR 0 13
59130: PUSH
59131: LD_VAR 0 13
59135: PUSH
59136: LD_INT 2
59138: PLUS
59139: ST_TO_ADDR
// continue ;
59140: GO 58940
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59142: LD_VAR 0 12
59146: PUSH
59147: LD_INT 1
59149: ARRAY
59150: PPUSH
59151: CALL_OW 266
59155: PUSH
59156: LD_INT 5
59158: EQUAL
59159: IFFALSE 59233
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59161: LD_VAR 0 12
59165: PUSH
59166: LD_INT 1
59168: ARRAY
59169: PPUSH
59170: CALL_OW 313
59174: PUSH
59175: LD_INT 3
59177: LESS
59178: IFFALSE 59214
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59180: LD_INT 0
59182: PPUSH
59183: LD_INT 5
59185: PUSH
59186: LD_INT 8
59188: PUSH
59189: LD_INT 9
59191: PUSH
59192: EMPTY
59193: LIST
59194: LIST
59195: LIST
59196: PUSH
59197: LD_VAR 0 17
59201: ARRAY
59202: PPUSH
59203: LD_VAR 0 4
59207: PPUSH
59208: CALL_OW 380
59212: GO 59231
// PrepareHuman ( false , i , skill ) ;
59214: LD_INT 0
59216: PPUSH
59217: LD_VAR 0 8
59221: PPUSH
59222: LD_VAR 0 4
59226: PPUSH
59227: CALL_OW 380
// end else
59231: GO 59250
// PrepareHuman ( false , i , skill ) ;
59233: LD_INT 0
59235: PPUSH
59236: LD_VAR 0 8
59240: PPUSH
59241: LD_VAR 0 4
59245: PPUSH
59246: CALL_OW 380
// un := CreateHuman ;
59250: LD_ADDR_VAR 0 14
59254: PUSH
59255: CALL_OW 44
59259: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59260: LD_ADDR_VAR 0 7
59264: PUSH
59265: LD_VAR 0 7
59269: PPUSH
59270: LD_INT 1
59272: PPUSH
59273: LD_VAR 0 14
59277: PPUSH
59278: CALL_OW 2
59282: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59283: LD_VAR 0 14
59287: PPUSH
59288: LD_VAR 0 12
59292: PUSH
59293: LD_INT 1
59295: ARRAY
59296: PPUSH
59297: CALL_OW 52
// end ;
59301: GO 58940
59303: POP
59304: POP
// end ;
59305: GO 58242
59307: POP
59308: POP
// result := result ^ buildings ;
59309: LD_ADDR_VAR 0 7
59313: PUSH
59314: LD_VAR 0 7
59318: PUSH
59319: LD_VAR 0 18
59323: ADD
59324: ST_TO_ADDR
// end else
59325: GO 59468
// begin for i = 1 to personel do
59327: LD_ADDR_VAR 0 8
59331: PUSH
59332: DOUBLE
59333: LD_INT 1
59335: DEC
59336: ST_TO_ADDR
59337: LD_VAR 0 6
59341: PUSH
59342: FOR_TO
59343: IFFALSE 59466
// begin if i > 4 then
59345: LD_VAR 0 8
59349: PUSH
59350: LD_INT 4
59352: GREATER
59353: IFFALSE 59357
// break ;
59355: GO 59466
// x := personel [ i ] ;
59357: LD_ADDR_VAR 0 13
59361: PUSH
59362: LD_VAR 0 6
59366: PUSH
59367: LD_VAR 0 8
59371: ARRAY
59372: ST_TO_ADDR
// if x = - 1 then
59373: LD_VAR 0 13
59377: PUSH
59378: LD_INT 1
59380: NEG
59381: EQUAL
59382: IFFALSE 59386
// continue ;
59384: GO 59342
// PrepareHuman ( false , i , skill ) ;
59386: LD_INT 0
59388: PPUSH
59389: LD_VAR 0 8
59393: PPUSH
59394: LD_VAR 0 4
59398: PPUSH
59399: CALL_OW 380
// un := CreateHuman ;
59403: LD_ADDR_VAR 0 14
59407: PUSH
59408: CALL_OW 44
59412: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59413: LD_VAR 0 14
59417: PPUSH
59418: LD_VAR 0 1
59422: PPUSH
59423: CALL_OW 250
59427: PPUSH
59428: LD_VAR 0 1
59432: PPUSH
59433: CALL_OW 251
59437: PPUSH
59438: LD_INT 10
59440: PPUSH
59441: LD_INT 0
59443: PPUSH
59444: CALL_OW 50
// result := result ^ un ;
59448: LD_ADDR_VAR 0 7
59452: PUSH
59453: LD_VAR 0 7
59457: PUSH
59458: LD_VAR 0 14
59462: ADD
59463: ST_TO_ADDR
// end ;
59464: GO 59342
59466: POP
59467: POP
// end ; end ;
59468: LD_VAR 0 7
59472: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59473: LD_INT 0
59475: PPUSH
59476: PPUSH
59477: PPUSH
59478: PPUSH
59479: PPUSH
59480: PPUSH
59481: PPUSH
59482: PPUSH
59483: PPUSH
59484: PPUSH
59485: PPUSH
59486: PPUSH
59487: PPUSH
59488: PPUSH
59489: PPUSH
59490: PPUSH
// result := false ;
59491: LD_ADDR_VAR 0 3
59495: PUSH
59496: LD_INT 0
59498: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59499: LD_VAR 0 1
59503: NOT
59504: PUSH
59505: LD_VAR 0 1
59509: PPUSH
59510: CALL_OW 266
59514: PUSH
59515: LD_INT 32
59517: PUSH
59518: LD_INT 33
59520: PUSH
59521: EMPTY
59522: LIST
59523: LIST
59524: IN
59525: NOT
59526: OR
59527: IFFALSE 59531
// exit ;
59529: GO 60667
// nat := GetNation ( tower ) ;
59531: LD_ADDR_VAR 0 12
59535: PUSH
59536: LD_VAR 0 1
59540: PPUSH
59541: CALL_OW 248
59545: ST_TO_ADDR
// side := GetSide ( tower ) ;
59546: LD_ADDR_VAR 0 16
59550: PUSH
59551: LD_VAR 0 1
59555: PPUSH
59556: CALL_OW 255
59560: ST_TO_ADDR
// x := GetX ( tower ) ;
59561: LD_ADDR_VAR 0 10
59565: PUSH
59566: LD_VAR 0 1
59570: PPUSH
59571: CALL_OW 250
59575: ST_TO_ADDR
// y := GetY ( tower ) ;
59576: LD_ADDR_VAR 0 11
59580: PUSH
59581: LD_VAR 0 1
59585: PPUSH
59586: CALL_OW 251
59590: ST_TO_ADDR
// if not x or not y then
59591: LD_VAR 0 10
59595: NOT
59596: PUSH
59597: LD_VAR 0 11
59601: NOT
59602: OR
59603: IFFALSE 59607
// exit ;
59605: GO 60667
// weapon := 0 ;
59607: LD_ADDR_VAR 0 18
59611: PUSH
59612: LD_INT 0
59614: ST_TO_ADDR
// fac_list := [ ] ;
59615: LD_ADDR_VAR 0 17
59619: PUSH
59620: EMPTY
59621: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
59622: LD_ADDR_VAR 0 6
59626: PUSH
59627: LD_VAR 0 1
59631: PPUSH
59632: CALL_OW 274
59636: PPUSH
59637: LD_VAR 0 2
59641: PPUSH
59642: CALL 57245 0 2
59646: PPUSH
59647: LD_INT 30
59649: PUSH
59650: LD_INT 3
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: PPUSH
59657: CALL_OW 72
59661: ST_TO_ADDR
// if not factories then
59662: LD_VAR 0 6
59666: NOT
59667: IFFALSE 59671
// exit ;
59669: GO 60667
// for i in factories do
59671: LD_ADDR_VAR 0 8
59675: PUSH
59676: LD_VAR 0 6
59680: PUSH
59681: FOR_IN
59682: IFFALSE 59707
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59684: LD_ADDR_VAR 0 17
59688: PUSH
59689: LD_VAR 0 17
59693: PUSH
59694: LD_VAR 0 8
59698: PPUSH
59699: CALL_OW 478
59703: UNION
59704: ST_TO_ADDR
59705: GO 59681
59707: POP
59708: POP
// if not fac_list then
59709: LD_VAR 0 17
59713: NOT
59714: IFFALSE 59718
// exit ;
59716: GO 60667
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59718: LD_ADDR_VAR 0 5
59722: PUSH
59723: LD_INT 4
59725: PUSH
59726: LD_INT 5
59728: PUSH
59729: LD_INT 9
59731: PUSH
59732: LD_INT 10
59734: PUSH
59735: LD_INT 6
59737: PUSH
59738: LD_INT 7
59740: PUSH
59741: LD_INT 11
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: LIST
59748: LIST
59749: LIST
59750: LIST
59751: LIST
59752: PUSH
59753: LD_INT 27
59755: PUSH
59756: LD_INT 28
59758: PUSH
59759: LD_INT 26
59761: PUSH
59762: LD_INT 30
59764: PUSH
59765: EMPTY
59766: LIST
59767: LIST
59768: LIST
59769: LIST
59770: PUSH
59771: LD_INT 43
59773: PUSH
59774: LD_INT 44
59776: PUSH
59777: LD_INT 46
59779: PUSH
59780: LD_INT 45
59782: PUSH
59783: LD_INT 47
59785: PUSH
59786: LD_INT 49
59788: PUSH
59789: EMPTY
59790: LIST
59791: LIST
59792: LIST
59793: LIST
59794: LIST
59795: LIST
59796: PUSH
59797: EMPTY
59798: LIST
59799: LIST
59800: LIST
59801: PUSH
59802: LD_VAR 0 12
59806: ARRAY
59807: ST_TO_ADDR
// for i in list do
59808: LD_ADDR_VAR 0 8
59812: PUSH
59813: LD_VAR 0 5
59817: PUSH
59818: FOR_IN
59819: IFFALSE 59852
// if not i in fac_list then
59821: LD_VAR 0 8
59825: PUSH
59826: LD_VAR 0 17
59830: IN
59831: NOT
59832: IFFALSE 59850
// list := list diff i ;
59834: LD_ADDR_VAR 0 5
59838: PUSH
59839: LD_VAR 0 5
59843: PUSH
59844: LD_VAR 0 8
59848: DIFF
59849: ST_TO_ADDR
59850: GO 59818
59852: POP
59853: POP
// if not list then
59854: LD_VAR 0 5
59858: NOT
59859: IFFALSE 59863
// exit ;
59861: GO 60667
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59863: LD_VAR 0 12
59867: PUSH
59868: LD_INT 3
59870: EQUAL
59871: PUSH
59872: LD_INT 49
59874: PUSH
59875: LD_VAR 0 5
59879: IN
59880: AND
59881: PUSH
59882: LD_INT 31
59884: PPUSH
59885: LD_VAR 0 16
59889: PPUSH
59890: CALL_OW 321
59894: PUSH
59895: LD_INT 2
59897: EQUAL
59898: AND
59899: IFFALSE 59959
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59901: LD_INT 22
59903: PUSH
59904: LD_VAR 0 16
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: PUSH
59913: LD_INT 35
59915: PUSH
59916: LD_INT 49
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: PUSH
59923: LD_INT 91
59925: PUSH
59926: LD_VAR 0 1
59930: PUSH
59931: LD_INT 10
59933: PUSH
59934: EMPTY
59935: LIST
59936: LIST
59937: LIST
59938: PUSH
59939: EMPTY
59940: LIST
59941: LIST
59942: LIST
59943: PPUSH
59944: CALL_OW 69
59948: NOT
59949: IFFALSE 59959
// weapon := ru_time_lapser ;
59951: LD_ADDR_VAR 0 18
59955: PUSH
59956: LD_INT 49
59958: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59959: LD_VAR 0 12
59963: PUSH
59964: LD_INT 1
59966: PUSH
59967: LD_INT 2
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: IN
59974: PUSH
59975: LD_INT 11
59977: PUSH
59978: LD_VAR 0 5
59982: IN
59983: PUSH
59984: LD_INT 30
59986: PUSH
59987: LD_VAR 0 5
59991: IN
59992: OR
59993: AND
59994: PUSH
59995: LD_INT 6
59997: PPUSH
59998: LD_VAR 0 16
60002: PPUSH
60003: CALL_OW 321
60007: PUSH
60008: LD_INT 2
60010: EQUAL
60011: AND
60012: IFFALSE 60177
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60014: LD_INT 22
60016: PUSH
60017: LD_VAR 0 16
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: PUSH
60026: LD_INT 2
60028: PUSH
60029: LD_INT 35
60031: PUSH
60032: LD_INT 11
60034: PUSH
60035: EMPTY
60036: LIST
60037: LIST
60038: PUSH
60039: LD_INT 35
60041: PUSH
60042: LD_INT 30
60044: PUSH
60045: EMPTY
60046: LIST
60047: LIST
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: LIST
60053: PUSH
60054: LD_INT 91
60056: PUSH
60057: LD_VAR 0 1
60061: PUSH
60062: LD_INT 18
60064: PUSH
60065: EMPTY
60066: LIST
60067: LIST
60068: LIST
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: LIST
60074: PPUSH
60075: CALL_OW 69
60079: NOT
60080: PUSH
60081: LD_INT 22
60083: PUSH
60084: LD_VAR 0 16
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: PUSH
60093: LD_INT 2
60095: PUSH
60096: LD_INT 30
60098: PUSH
60099: LD_INT 32
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: PUSH
60106: LD_INT 30
60108: PUSH
60109: LD_INT 33
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: EMPTY
60117: LIST
60118: LIST
60119: LIST
60120: PUSH
60121: LD_INT 91
60123: PUSH
60124: LD_VAR 0 1
60128: PUSH
60129: LD_INT 12
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: LIST
60136: PUSH
60137: EMPTY
60138: LIST
60139: LIST
60140: LIST
60141: PUSH
60142: EMPTY
60143: LIST
60144: PPUSH
60145: CALL_OW 69
60149: PUSH
60150: LD_INT 2
60152: GREATER
60153: AND
60154: IFFALSE 60177
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60156: LD_ADDR_VAR 0 18
60160: PUSH
60161: LD_INT 11
60163: PUSH
60164: LD_INT 30
60166: PUSH
60167: EMPTY
60168: LIST
60169: LIST
60170: PUSH
60171: LD_VAR 0 12
60175: ARRAY
60176: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60177: LD_VAR 0 18
60181: NOT
60182: PUSH
60183: LD_INT 40
60185: PPUSH
60186: LD_VAR 0 16
60190: PPUSH
60191: CALL_OW 321
60195: PUSH
60196: LD_INT 2
60198: EQUAL
60199: AND
60200: PUSH
60201: LD_INT 7
60203: PUSH
60204: LD_VAR 0 5
60208: IN
60209: PUSH
60210: LD_INT 28
60212: PUSH
60213: LD_VAR 0 5
60217: IN
60218: OR
60219: PUSH
60220: LD_INT 45
60222: PUSH
60223: LD_VAR 0 5
60227: IN
60228: OR
60229: AND
60230: IFFALSE 60484
// begin hex := GetHexInfo ( x , y ) ;
60232: LD_ADDR_VAR 0 4
60236: PUSH
60237: LD_VAR 0 10
60241: PPUSH
60242: LD_VAR 0 11
60246: PPUSH
60247: CALL_OW 546
60251: ST_TO_ADDR
// if hex [ 1 ] then
60252: LD_VAR 0 4
60256: PUSH
60257: LD_INT 1
60259: ARRAY
60260: IFFALSE 60264
// exit ;
60262: GO 60667
// height := hex [ 2 ] ;
60264: LD_ADDR_VAR 0 15
60268: PUSH
60269: LD_VAR 0 4
60273: PUSH
60274: LD_INT 2
60276: ARRAY
60277: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60278: LD_ADDR_VAR 0 14
60282: PUSH
60283: LD_INT 0
60285: PUSH
60286: LD_INT 2
60288: PUSH
60289: LD_INT 3
60291: PUSH
60292: LD_INT 5
60294: PUSH
60295: EMPTY
60296: LIST
60297: LIST
60298: LIST
60299: LIST
60300: ST_TO_ADDR
// for i in tmp do
60301: LD_ADDR_VAR 0 8
60305: PUSH
60306: LD_VAR 0 14
60310: PUSH
60311: FOR_IN
60312: IFFALSE 60482
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60314: LD_ADDR_VAR 0 9
60318: PUSH
60319: LD_VAR 0 10
60323: PPUSH
60324: LD_VAR 0 8
60328: PPUSH
60329: LD_INT 5
60331: PPUSH
60332: CALL_OW 272
60336: PUSH
60337: LD_VAR 0 11
60341: PPUSH
60342: LD_VAR 0 8
60346: PPUSH
60347: LD_INT 5
60349: PPUSH
60350: CALL_OW 273
60354: PUSH
60355: EMPTY
60356: LIST
60357: LIST
60358: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60359: LD_VAR 0 9
60363: PUSH
60364: LD_INT 1
60366: ARRAY
60367: PPUSH
60368: LD_VAR 0 9
60372: PUSH
60373: LD_INT 2
60375: ARRAY
60376: PPUSH
60377: CALL_OW 488
60381: IFFALSE 60480
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60383: LD_ADDR_VAR 0 4
60387: PUSH
60388: LD_VAR 0 9
60392: PUSH
60393: LD_INT 1
60395: ARRAY
60396: PPUSH
60397: LD_VAR 0 9
60401: PUSH
60402: LD_INT 2
60404: ARRAY
60405: PPUSH
60406: CALL_OW 546
60410: ST_TO_ADDR
// if hex [ 1 ] then
60411: LD_VAR 0 4
60415: PUSH
60416: LD_INT 1
60418: ARRAY
60419: IFFALSE 60423
// continue ;
60421: GO 60311
// h := hex [ 2 ] ;
60423: LD_ADDR_VAR 0 13
60427: PUSH
60428: LD_VAR 0 4
60432: PUSH
60433: LD_INT 2
60435: ARRAY
60436: ST_TO_ADDR
// if h + 7 < height then
60437: LD_VAR 0 13
60441: PUSH
60442: LD_INT 7
60444: PLUS
60445: PUSH
60446: LD_VAR 0 15
60450: LESS
60451: IFFALSE 60480
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60453: LD_ADDR_VAR 0 18
60457: PUSH
60458: LD_INT 7
60460: PUSH
60461: LD_INT 28
60463: PUSH
60464: LD_INT 45
60466: PUSH
60467: EMPTY
60468: LIST
60469: LIST
60470: LIST
60471: PUSH
60472: LD_VAR 0 12
60476: ARRAY
60477: ST_TO_ADDR
// break ;
60478: GO 60482
// end ; end ; end ;
60480: GO 60311
60482: POP
60483: POP
// end ; if not weapon then
60484: LD_VAR 0 18
60488: NOT
60489: IFFALSE 60549
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60491: LD_ADDR_VAR 0 5
60495: PUSH
60496: LD_VAR 0 5
60500: PUSH
60501: LD_INT 11
60503: PUSH
60504: LD_INT 30
60506: PUSH
60507: LD_INT 49
60509: PUSH
60510: EMPTY
60511: LIST
60512: LIST
60513: LIST
60514: DIFF
60515: ST_TO_ADDR
// if not list then
60516: LD_VAR 0 5
60520: NOT
60521: IFFALSE 60525
// exit ;
60523: GO 60667
// weapon := list [ rand ( 1 , list ) ] ;
60525: LD_ADDR_VAR 0 18
60529: PUSH
60530: LD_VAR 0 5
60534: PUSH
60535: LD_INT 1
60537: PPUSH
60538: LD_VAR 0 5
60542: PPUSH
60543: CALL_OW 12
60547: ARRAY
60548: ST_TO_ADDR
// end ; if weapon then
60549: LD_VAR 0 18
60553: IFFALSE 60667
// begin tmp := CostOfWeapon ( weapon ) ;
60555: LD_ADDR_VAR 0 14
60559: PUSH
60560: LD_VAR 0 18
60564: PPUSH
60565: CALL_OW 451
60569: ST_TO_ADDR
// j := GetBase ( tower ) ;
60570: LD_ADDR_VAR 0 9
60574: PUSH
60575: LD_VAR 0 1
60579: PPUSH
60580: CALL_OW 274
60584: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60585: LD_VAR 0 9
60589: PPUSH
60590: LD_INT 1
60592: PPUSH
60593: CALL_OW 275
60597: PUSH
60598: LD_VAR 0 14
60602: PUSH
60603: LD_INT 1
60605: ARRAY
60606: GREATEREQUAL
60607: PUSH
60608: LD_VAR 0 9
60612: PPUSH
60613: LD_INT 2
60615: PPUSH
60616: CALL_OW 275
60620: PUSH
60621: LD_VAR 0 14
60625: PUSH
60626: LD_INT 2
60628: ARRAY
60629: GREATEREQUAL
60630: AND
60631: PUSH
60632: LD_VAR 0 9
60636: PPUSH
60637: LD_INT 3
60639: PPUSH
60640: CALL_OW 275
60644: PUSH
60645: LD_VAR 0 14
60649: PUSH
60650: LD_INT 3
60652: ARRAY
60653: GREATEREQUAL
60654: AND
60655: IFFALSE 60667
// result := weapon ;
60657: LD_ADDR_VAR 0 3
60661: PUSH
60662: LD_VAR 0 18
60666: ST_TO_ADDR
// end ; end ;
60667: LD_VAR 0 3
60671: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60672: LD_INT 0
60674: PPUSH
60675: PPUSH
// result := true ;
60676: LD_ADDR_VAR 0 3
60680: PUSH
60681: LD_INT 1
60683: ST_TO_ADDR
// if array1 = array2 then
60684: LD_VAR 0 1
60688: PUSH
60689: LD_VAR 0 2
60693: EQUAL
60694: IFFALSE 60754
// begin for i = 1 to array1 do
60696: LD_ADDR_VAR 0 4
60700: PUSH
60701: DOUBLE
60702: LD_INT 1
60704: DEC
60705: ST_TO_ADDR
60706: LD_VAR 0 1
60710: PUSH
60711: FOR_TO
60712: IFFALSE 60750
// if array1 [ i ] <> array2 [ i ] then
60714: LD_VAR 0 1
60718: PUSH
60719: LD_VAR 0 4
60723: ARRAY
60724: PUSH
60725: LD_VAR 0 2
60729: PUSH
60730: LD_VAR 0 4
60734: ARRAY
60735: NONEQUAL
60736: IFFALSE 60748
// begin result := false ;
60738: LD_ADDR_VAR 0 3
60742: PUSH
60743: LD_INT 0
60745: ST_TO_ADDR
// break ;
60746: GO 60750
// end ;
60748: GO 60711
60750: POP
60751: POP
// end else
60752: GO 60762
// result := false ;
60754: LD_ADDR_VAR 0 3
60758: PUSH
60759: LD_INT 0
60761: ST_TO_ADDR
// end ;
60762: LD_VAR 0 3
60766: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60767: LD_INT 0
60769: PPUSH
60770: PPUSH
60771: PPUSH
// pom := GetBase ( fac ) ;
60772: LD_ADDR_VAR 0 5
60776: PUSH
60777: LD_VAR 0 1
60781: PPUSH
60782: CALL_OW 274
60786: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60787: LD_ADDR_VAR 0 4
60791: PUSH
60792: LD_VAR 0 2
60796: PUSH
60797: LD_INT 1
60799: ARRAY
60800: PPUSH
60801: LD_VAR 0 2
60805: PUSH
60806: LD_INT 2
60808: ARRAY
60809: PPUSH
60810: LD_VAR 0 2
60814: PUSH
60815: LD_INT 3
60817: ARRAY
60818: PPUSH
60819: LD_VAR 0 2
60823: PUSH
60824: LD_INT 4
60826: ARRAY
60827: PPUSH
60828: CALL_OW 449
60832: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60833: LD_ADDR_VAR 0 3
60837: PUSH
60838: LD_VAR 0 5
60842: PPUSH
60843: LD_INT 1
60845: PPUSH
60846: CALL_OW 275
60850: PUSH
60851: LD_VAR 0 4
60855: PUSH
60856: LD_INT 1
60858: ARRAY
60859: GREATEREQUAL
60860: PUSH
60861: LD_VAR 0 5
60865: PPUSH
60866: LD_INT 2
60868: PPUSH
60869: CALL_OW 275
60873: PUSH
60874: LD_VAR 0 4
60878: PUSH
60879: LD_INT 2
60881: ARRAY
60882: GREATEREQUAL
60883: AND
60884: PUSH
60885: LD_VAR 0 5
60889: PPUSH
60890: LD_INT 3
60892: PPUSH
60893: CALL_OW 275
60897: PUSH
60898: LD_VAR 0 4
60902: PUSH
60903: LD_INT 3
60905: ARRAY
60906: GREATEREQUAL
60907: AND
60908: ST_TO_ADDR
// end ;
60909: LD_VAR 0 3
60913: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60914: LD_INT 0
60916: PPUSH
60917: PPUSH
60918: PPUSH
60919: PPUSH
// pom := GetBase ( building ) ;
60920: LD_ADDR_VAR 0 3
60924: PUSH
60925: LD_VAR 0 1
60929: PPUSH
60930: CALL_OW 274
60934: ST_TO_ADDR
// if not pom then
60935: LD_VAR 0 3
60939: NOT
60940: IFFALSE 60944
// exit ;
60942: GO 61114
// btype := GetBType ( building ) ;
60944: LD_ADDR_VAR 0 5
60948: PUSH
60949: LD_VAR 0 1
60953: PPUSH
60954: CALL_OW 266
60958: ST_TO_ADDR
// if btype = b_armoury then
60959: LD_VAR 0 5
60963: PUSH
60964: LD_INT 4
60966: EQUAL
60967: IFFALSE 60977
// btype := b_barracks ;
60969: LD_ADDR_VAR 0 5
60973: PUSH
60974: LD_INT 5
60976: ST_TO_ADDR
// if btype = b_depot then
60977: LD_VAR 0 5
60981: PUSH
60982: LD_INT 0
60984: EQUAL
60985: IFFALSE 60995
// btype := b_warehouse ;
60987: LD_ADDR_VAR 0 5
60991: PUSH
60992: LD_INT 1
60994: ST_TO_ADDR
// if btype = b_workshop then
60995: LD_VAR 0 5
60999: PUSH
61000: LD_INT 2
61002: EQUAL
61003: IFFALSE 61013
// btype := b_factory ;
61005: LD_ADDR_VAR 0 5
61009: PUSH
61010: LD_INT 3
61012: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61013: LD_ADDR_VAR 0 4
61017: PUSH
61018: LD_VAR 0 5
61022: PPUSH
61023: LD_VAR 0 1
61027: PPUSH
61028: CALL_OW 248
61032: PPUSH
61033: CALL_OW 450
61037: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61038: LD_ADDR_VAR 0 2
61042: PUSH
61043: LD_VAR 0 3
61047: PPUSH
61048: LD_INT 1
61050: PPUSH
61051: CALL_OW 275
61055: PUSH
61056: LD_VAR 0 4
61060: PUSH
61061: LD_INT 1
61063: ARRAY
61064: GREATEREQUAL
61065: PUSH
61066: LD_VAR 0 3
61070: PPUSH
61071: LD_INT 2
61073: PPUSH
61074: CALL_OW 275
61078: PUSH
61079: LD_VAR 0 4
61083: PUSH
61084: LD_INT 2
61086: ARRAY
61087: GREATEREQUAL
61088: AND
61089: PUSH
61090: LD_VAR 0 3
61094: PPUSH
61095: LD_INT 3
61097: PPUSH
61098: CALL_OW 275
61102: PUSH
61103: LD_VAR 0 4
61107: PUSH
61108: LD_INT 3
61110: ARRAY
61111: GREATEREQUAL
61112: AND
61113: ST_TO_ADDR
// end ;
61114: LD_VAR 0 2
61118: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61119: LD_INT 0
61121: PPUSH
61122: PPUSH
61123: PPUSH
// pom := GetBase ( building ) ;
61124: LD_ADDR_VAR 0 4
61128: PUSH
61129: LD_VAR 0 1
61133: PPUSH
61134: CALL_OW 274
61138: ST_TO_ADDR
// if not pom then
61139: LD_VAR 0 4
61143: NOT
61144: IFFALSE 61148
// exit ;
61146: GO 61249
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61148: LD_ADDR_VAR 0 5
61152: PUSH
61153: LD_VAR 0 2
61157: PPUSH
61158: LD_VAR 0 1
61162: PPUSH
61163: CALL_OW 248
61167: PPUSH
61168: CALL_OW 450
61172: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61173: LD_ADDR_VAR 0 3
61177: PUSH
61178: LD_VAR 0 4
61182: PPUSH
61183: LD_INT 1
61185: PPUSH
61186: CALL_OW 275
61190: PUSH
61191: LD_VAR 0 5
61195: PUSH
61196: LD_INT 1
61198: ARRAY
61199: GREATEREQUAL
61200: PUSH
61201: LD_VAR 0 4
61205: PPUSH
61206: LD_INT 2
61208: PPUSH
61209: CALL_OW 275
61213: PUSH
61214: LD_VAR 0 5
61218: PUSH
61219: LD_INT 2
61221: ARRAY
61222: GREATEREQUAL
61223: AND
61224: PUSH
61225: LD_VAR 0 4
61229: PPUSH
61230: LD_INT 3
61232: PPUSH
61233: CALL_OW 275
61237: PUSH
61238: LD_VAR 0 5
61242: PUSH
61243: LD_INT 3
61245: ARRAY
61246: GREATEREQUAL
61247: AND
61248: ST_TO_ADDR
// end ;
61249: LD_VAR 0 3
61253: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
61254: LD_INT 0
61256: PPUSH
61257: PPUSH
61258: PPUSH
61259: PPUSH
61260: PPUSH
61261: PPUSH
61262: PPUSH
61263: PPUSH
61264: PPUSH
61265: PPUSH
// result := false ;
61266: LD_ADDR_VAR 0 6
61270: PUSH
61271: LD_INT 0
61273: ST_TO_ADDR
// if not base or not btype or not x or not y then
61274: LD_VAR 0 1
61278: NOT
61279: PUSH
61280: LD_VAR 0 2
61284: NOT
61285: OR
61286: PUSH
61287: LD_VAR 0 3
61291: NOT
61292: OR
61293: PUSH
61294: LD_VAR 0 4
61298: NOT
61299: OR
61300: IFFALSE 61304
// exit ;
61302: GO 61913
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
61304: LD_ADDR_VAR 0 12
61308: PUSH
61309: LD_VAR 0 2
61313: PPUSH
61314: LD_VAR 0 3
61318: PPUSH
61319: LD_VAR 0 4
61323: PPUSH
61324: LD_VAR 0 5
61328: PPUSH
61329: LD_VAR 0 1
61333: PUSH
61334: LD_INT 1
61336: ARRAY
61337: PPUSH
61338: CALL_OW 248
61342: PPUSH
61343: LD_INT 0
61345: PPUSH
61346: CALL 62750 0 6
61350: ST_TO_ADDR
// if not hexes then
61351: LD_VAR 0 12
61355: NOT
61356: IFFALSE 61360
// exit ;
61358: GO 61913
// for i = 1 to hexes do
61360: LD_ADDR_VAR 0 7
61364: PUSH
61365: DOUBLE
61366: LD_INT 1
61368: DEC
61369: ST_TO_ADDR
61370: LD_VAR 0 12
61374: PUSH
61375: FOR_TO
61376: IFFALSE 61911
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61378: LD_ADDR_VAR 0 11
61382: PUSH
61383: LD_VAR 0 12
61387: PUSH
61388: LD_VAR 0 7
61392: ARRAY
61393: PUSH
61394: LD_INT 1
61396: ARRAY
61397: PPUSH
61398: LD_VAR 0 12
61402: PUSH
61403: LD_VAR 0 7
61407: ARRAY
61408: PUSH
61409: LD_INT 2
61411: ARRAY
61412: PPUSH
61413: CALL_OW 428
61417: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61418: LD_VAR 0 12
61422: PUSH
61423: LD_VAR 0 7
61427: ARRAY
61428: PUSH
61429: LD_INT 1
61431: ARRAY
61432: PPUSH
61433: LD_VAR 0 12
61437: PUSH
61438: LD_VAR 0 7
61442: ARRAY
61443: PUSH
61444: LD_INT 2
61446: ARRAY
61447: PPUSH
61448: CALL_OW 351
61452: PUSH
61453: LD_VAR 0 12
61457: PUSH
61458: LD_VAR 0 7
61462: ARRAY
61463: PUSH
61464: LD_INT 1
61466: ARRAY
61467: PPUSH
61468: LD_VAR 0 12
61472: PUSH
61473: LD_VAR 0 7
61477: ARRAY
61478: PUSH
61479: LD_INT 2
61481: ARRAY
61482: PPUSH
61483: CALL_OW 488
61487: NOT
61488: OR
61489: PUSH
61490: LD_VAR 0 11
61494: PPUSH
61495: CALL_OW 247
61499: PUSH
61500: LD_INT 3
61502: EQUAL
61503: OR
61504: IFFALSE 61510
// exit ;
61506: POP
61507: POP
61508: GO 61913
// if not tmp or not tmp in base then
61510: LD_VAR 0 11
61514: NOT
61515: PUSH
61516: LD_VAR 0 11
61520: PUSH
61521: LD_VAR 0 1
61525: IN
61526: NOT
61527: OR
61528: IFFALSE 61532
// continue ;
61530: GO 61375
// result := true ;
61532: LD_ADDR_VAR 0 6
61536: PUSH
61537: LD_INT 1
61539: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61540: LD_ADDR_VAR 0 15
61544: PUSH
61545: LD_VAR 0 1
61549: PPUSH
61550: LD_INT 22
61552: PUSH
61553: LD_VAR 0 11
61557: PPUSH
61558: CALL_OW 255
61562: PUSH
61563: EMPTY
61564: LIST
61565: LIST
61566: PUSH
61567: LD_INT 2
61569: PUSH
61570: LD_INT 30
61572: PUSH
61573: LD_INT 0
61575: PUSH
61576: EMPTY
61577: LIST
61578: LIST
61579: PUSH
61580: LD_INT 30
61582: PUSH
61583: LD_INT 1
61585: PUSH
61586: EMPTY
61587: LIST
61588: LIST
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: LIST
61594: PUSH
61595: EMPTY
61596: LIST
61597: LIST
61598: PPUSH
61599: CALL_OW 72
61603: ST_TO_ADDR
// if dep then
61604: LD_VAR 0 15
61608: IFFALSE 61744
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61610: LD_ADDR_VAR 0 14
61614: PUSH
61615: LD_VAR 0 15
61619: PUSH
61620: LD_INT 1
61622: ARRAY
61623: PPUSH
61624: CALL_OW 250
61628: PPUSH
61629: LD_VAR 0 15
61633: PUSH
61634: LD_INT 1
61636: ARRAY
61637: PPUSH
61638: CALL_OW 254
61642: PPUSH
61643: LD_INT 5
61645: PPUSH
61646: CALL_OW 272
61650: PUSH
61651: LD_VAR 0 15
61655: PUSH
61656: LD_INT 1
61658: ARRAY
61659: PPUSH
61660: CALL_OW 251
61664: PPUSH
61665: LD_VAR 0 15
61669: PUSH
61670: LD_INT 1
61672: ARRAY
61673: PPUSH
61674: CALL_OW 254
61678: PPUSH
61679: LD_INT 5
61681: PPUSH
61682: CALL_OW 273
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61691: LD_VAR 0 14
61695: PUSH
61696: LD_INT 1
61698: ARRAY
61699: PPUSH
61700: LD_VAR 0 14
61704: PUSH
61705: LD_INT 2
61707: ARRAY
61708: PPUSH
61709: CALL_OW 488
61713: IFFALSE 61744
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61715: LD_VAR 0 11
61719: PPUSH
61720: LD_VAR 0 14
61724: PUSH
61725: LD_INT 1
61727: ARRAY
61728: PPUSH
61729: LD_VAR 0 14
61733: PUSH
61734: LD_INT 2
61736: ARRAY
61737: PPUSH
61738: CALL_OW 111
// continue ;
61742: GO 61375
// end ; end ; r := GetDir ( tmp ) ;
61744: LD_ADDR_VAR 0 13
61748: PUSH
61749: LD_VAR 0 11
61753: PPUSH
61754: CALL_OW 254
61758: ST_TO_ADDR
// if r = 5 then
61759: LD_VAR 0 13
61763: PUSH
61764: LD_INT 5
61766: EQUAL
61767: IFFALSE 61777
// r := 0 ;
61769: LD_ADDR_VAR 0 13
61773: PUSH
61774: LD_INT 0
61776: ST_TO_ADDR
// for j = r to 5 do
61777: LD_ADDR_VAR 0 8
61781: PUSH
61782: DOUBLE
61783: LD_VAR 0 13
61787: DEC
61788: ST_TO_ADDR
61789: LD_INT 5
61791: PUSH
61792: FOR_TO
61793: IFFALSE 61907
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61795: LD_ADDR_VAR 0 9
61799: PUSH
61800: LD_VAR 0 11
61804: PPUSH
61805: CALL_OW 250
61809: PPUSH
61810: LD_VAR 0 8
61814: PPUSH
61815: LD_INT 2
61817: PPUSH
61818: CALL_OW 272
61822: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61823: LD_ADDR_VAR 0 10
61827: PUSH
61828: LD_VAR 0 11
61832: PPUSH
61833: CALL_OW 251
61837: PPUSH
61838: LD_VAR 0 8
61842: PPUSH
61843: LD_INT 2
61845: PPUSH
61846: CALL_OW 273
61850: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61851: LD_VAR 0 9
61855: PPUSH
61856: LD_VAR 0 10
61860: PPUSH
61861: CALL_OW 488
61865: PUSH
61866: LD_VAR 0 9
61870: PPUSH
61871: LD_VAR 0 10
61875: PPUSH
61876: CALL_OW 428
61880: NOT
61881: AND
61882: IFFALSE 61905
// begin ComMoveXY ( tmp , _x , _y ) ;
61884: LD_VAR 0 11
61888: PPUSH
61889: LD_VAR 0 9
61893: PPUSH
61894: LD_VAR 0 10
61898: PPUSH
61899: CALL_OW 111
// break ;
61903: GO 61907
// end ; end ;
61905: GO 61792
61907: POP
61908: POP
// end ;
61909: GO 61375
61911: POP
61912: POP
// end ;
61913: LD_VAR 0 6
61917: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
61918: LD_INT 0
61920: PPUSH
61921: PPUSH
61922: PPUSH
61923: PPUSH
61924: PPUSH
61925: PPUSH
61926: PPUSH
61927: PPUSH
61928: PPUSH
61929: PPUSH
// result := false ;
61930: LD_ADDR_VAR 0 6
61934: PUSH
61935: LD_INT 0
61937: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61938: LD_VAR 0 1
61942: NOT
61943: PUSH
61944: LD_VAR 0 1
61948: PPUSH
61949: CALL_OW 266
61953: PUSH
61954: LD_INT 0
61956: PUSH
61957: LD_INT 1
61959: PUSH
61960: EMPTY
61961: LIST
61962: LIST
61963: IN
61964: NOT
61965: OR
61966: PUSH
61967: LD_VAR 0 2
61971: NOT
61972: OR
61973: PUSH
61974: LD_VAR 0 5
61978: PUSH
61979: LD_INT 0
61981: PUSH
61982: LD_INT 1
61984: PUSH
61985: LD_INT 2
61987: PUSH
61988: LD_INT 3
61990: PUSH
61991: LD_INT 4
61993: PUSH
61994: LD_INT 5
61996: PUSH
61997: EMPTY
61998: LIST
61999: LIST
62000: LIST
62001: LIST
62002: LIST
62003: LIST
62004: IN
62005: NOT
62006: OR
62007: PUSH
62008: LD_VAR 0 3
62012: PPUSH
62013: LD_VAR 0 4
62017: PPUSH
62018: CALL_OW 488
62022: NOT
62023: OR
62024: IFFALSE 62028
// exit ;
62026: GO 62745
// pom := GetBase ( depot ) ;
62028: LD_ADDR_VAR 0 10
62032: PUSH
62033: LD_VAR 0 1
62037: PPUSH
62038: CALL_OW 274
62042: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62043: LD_ADDR_VAR 0 11
62047: PUSH
62048: LD_VAR 0 2
62052: PPUSH
62053: LD_VAR 0 1
62057: PPUSH
62058: CALL_OW 248
62062: PPUSH
62063: CALL_OW 450
62067: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62068: LD_VAR 0 10
62072: PPUSH
62073: LD_INT 1
62075: PPUSH
62076: CALL_OW 275
62080: PUSH
62081: LD_VAR 0 11
62085: PUSH
62086: LD_INT 1
62088: ARRAY
62089: GREATEREQUAL
62090: PUSH
62091: LD_VAR 0 10
62095: PPUSH
62096: LD_INT 2
62098: PPUSH
62099: CALL_OW 275
62103: PUSH
62104: LD_VAR 0 11
62108: PUSH
62109: LD_INT 2
62111: ARRAY
62112: GREATEREQUAL
62113: AND
62114: PUSH
62115: LD_VAR 0 10
62119: PPUSH
62120: LD_INT 3
62122: PPUSH
62123: CALL_OW 275
62127: PUSH
62128: LD_VAR 0 11
62132: PUSH
62133: LD_INT 3
62135: ARRAY
62136: GREATEREQUAL
62137: AND
62138: NOT
62139: IFFALSE 62143
// exit ;
62141: GO 62745
// if GetBType ( depot ) = b_depot then
62143: LD_VAR 0 1
62147: PPUSH
62148: CALL_OW 266
62152: PUSH
62153: LD_INT 0
62155: EQUAL
62156: IFFALSE 62168
// dist := 28 else
62158: LD_ADDR_VAR 0 14
62162: PUSH
62163: LD_INT 28
62165: ST_TO_ADDR
62166: GO 62176
// dist := 36 ;
62168: LD_ADDR_VAR 0 14
62172: PUSH
62173: LD_INT 36
62175: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62176: LD_VAR 0 1
62180: PPUSH
62181: LD_VAR 0 3
62185: PPUSH
62186: LD_VAR 0 4
62190: PPUSH
62191: CALL_OW 297
62195: PUSH
62196: LD_VAR 0 14
62200: GREATER
62201: IFFALSE 62205
// exit ;
62203: GO 62745
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62205: LD_ADDR_VAR 0 12
62209: PUSH
62210: LD_VAR 0 2
62214: PPUSH
62215: LD_VAR 0 3
62219: PPUSH
62220: LD_VAR 0 4
62224: PPUSH
62225: LD_VAR 0 5
62229: PPUSH
62230: LD_VAR 0 1
62234: PPUSH
62235: CALL_OW 248
62239: PPUSH
62240: LD_INT 0
62242: PPUSH
62243: CALL 62750 0 6
62247: ST_TO_ADDR
// if not hexes then
62248: LD_VAR 0 12
62252: NOT
62253: IFFALSE 62257
// exit ;
62255: GO 62745
// hex := GetHexInfo ( x , y ) ;
62257: LD_ADDR_VAR 0 15
62261: PUSH
62262: LD_VAR 0 3
62266: PPUSH
62267: LD_VAR 0 4
62271: PPUSH
62272: CALL_OW 546
62276: ST_TO_ADDR
// if hex [ 1 ] then
62277: LD_VAR 0 15
62281: PUSH
62282: LD_INT 1
62284: ARRAY
62285: IFFALSE 62289
// exit ;
62287: GO 62745
// height := hex [ 2 ] ;
62289: LD_ADDR_VAR 0 13
62293: PUSH
62294: LD_VAR 0 15
62298: PUSH
62299: LD_INT 2
62301: ARRAY
62302: ST_TO_ADDR
// for i = 1 to hexes do
62303: LD_ADDR_VAR 0 7
62307: PUSH
62308: DOUBLE
62309: LD_INT 1
62311: DEC
62312: ST_TO_ADDR
62313: LD_VAR 0 12
62317: PUSH
62318: FOR_TO
62319: IFFALSE 62649
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62321: LD_VAR 0 12
62325: PUSH
62326: LD_VAR 0 7
62330: ARRAY
62331: PUSH
62332: LD_INT 1
62334: ARRAY
62335: PPUSH
62336: LD_VAR 0 12
62340: PUSH
62341: LD_VAR 0 7
62345: ARRAY
62346: PUSH
62347: LD_INT 2
62349: ARRAY
62350: PPUSH
62351: CALL_OW 488
62355: NOT
62356: PUSH
62357: LD_VAR 0 12
62361: PUSH
62362: LD_VAR 0 7
62366: ARRAY
62367: PUSH
62368: LD_INT 1
62370: ARRAY
62371: PPUSH
62372: LD_VAR 0 12
62376: PUSH
62377: LD_VAR 0 7
62381: ARRAY
62382: PUSH
62383: LD_INT 2
62385: ARRAY
62386: PPUSH
62387: CALL_OW 428
62391: PUSH
62392: LD_INT 0
62394: GREATER
62395: OR
62396: PUSH
62397: LD_VAR 0 12
62401: PUSH
62402: LD_VAR 0 7
62406: ARRAY
62407: PUSH
62408: LD_INT 1
62410: ARRAY
62411: PPUSH
62412: LD_VAR 0 12
62416: PUSH
62417: LD_VAR 0 7
62421: ARRAY
62422: PUSH
62423: LD_INT 2
62425: ARRAY
62426: PPUSH
62427: CALL_OW 351
62431: OR
62432: IFFALSE 62438
// exit ;
62434: POP
62435: POP
62436: GO 62745
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62438: LD_ADDR_VAR 0 8
62442: PUSH
62443: LD_VAR 0 12
62447: PUSH
62448: LD_VAR 0 7
62452: ARRAY
62453: PUSH
62454: LD_INT 1
62456: ARRAY
62457: PPUSH
62458: LD_VAR 0 12
62462: PUSH
62463: LD_VAR 0 7
62467: ARRAY
62468: PUSH
62469: LD_INT 2
62471: ARRAY
62472: PPUSH
62473: CALL_OW 546
62477: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62478: LD_VAR 0 8
62482: PUSH
62483: LD_INT 1
62485: ARRAY
62486: PUSH
62487: LD_VAR 0 8
62491: PUSH
62492: LD_INT 2
62494: ARRAY
62495: PUSH
62496: LD_VAR 0 13
62500: PUSH
62501: LD_INT 2
62503: PLUS
62504: GREATER
62505: OR
62506: PUSH
62507: LD_VAR 0 8
62511: PUSH
62512: LD_INT 2
62514: ARRAY
62515: PUSH
62516: LD_VAR 0 13
62520: PUSH
62521: LD_INT 2
62523: MINUS
62524: LESS
62525: OR
62526: PUSH
62527: LD_VAR 0 8
62531: PUSH
62532: LD_INT 3
62534: ARRAY
62535: PUSH
62536: LD_INT 0
62538: PUSH
62539: LD_INT 8
62541: PUSH
62542: LD_INT 9
62544: PUSH
62545: LD_INT 10
62547: PUSH
62548: LD_INT 11
62550: PUSH
62551: LD_INT 12
62553: PUSH
62554: LD_INT 13
62556: PUSH
62557: LD_INT 16
62559: PUSH
62560: LD_INT 17
62562: PUSH
62563: LD_INT 18
62565: PUSH
62566: LD_INT 19
62568: PUSH
62569: LD_INT 20
62571: PUSH
62572: LD_INT 21
62574: PUSH
62575: EMPTY
62576: LIST
62577: LIST
62578: LIST
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: LIST
62587: LIST
62588: LIST
62589: IN
62590: NOT
62591: OR
62592: PUSH
62593: LD_VAR 0 8
62597: PUSH
62598: LD_INT 5
62600: ARRAY
62601: NOT
62602: OR
62603: PUSH
62604: LD_VAR 0 8
62608: PUSH
62609: LD_INT 6
62611: ARRAY
62612: PUSH
62613: LD_INT 1
62615: PUSH
62616: LD_INT 2
62618: PUSH
62619: LD_INT 7
62621: PUSH
62622: LD_INT 9
62624: PUSH
62625: LD_INT 10
62627: PUSH
62628: LD_INT 11
62630: PUSH
62631: EMPTY
62632: LIST
62633: LIST
62634: LIST
62635: LIST
62636: LIST
62637: LIST
62638: IN
62639: NOT
62640: OR
62641: IFFALSE 62647
// exit ;
62643: POP
62644: POP
62645: GO 62745
// end ;
62647: GO 62318
62649: POP
62650: POP
// side := GetSide ( depot ) ;
62651: LD_ADDR_VAR 0 9
62655: PUSH
62656: LD_VAR 0 1
62660: PPUSH
62661: CALL_OW 255
62665: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62666: LD_VAR 0 9
62670: PPUSH
62671: LD_VAR 0 3
62675: PPUSH
62676: LD_VAR 0 4
62680: PPUSH
62681: LD_INT 20
62683: PPUSH
62684: CALL 55399 0 4
62688: PUSH
62689: LD_INT 4
62691: ARRAY
62692: IFFALSE 62696
// exit ;
62694: GO 62745
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62696: LD_VAR 0 2
62700: PUSH
62701: LD_INT 29
62703: PUSH
62704: LD_INT 30
62706: PUSH
62707: EMPTY
62708: LIST
62709: LIST
62710: IN
62711: PUSH
62712: LD_VAR 0 3
62716: PPUSH
62717: LD_VAR 0 4
62721: PPUSH
62722: LD_VAR 0 9
62726: PPUSH
62727: CALL_OW 440
62731: NOT
62732: AND
62733: IFFALSE 62737
// exit ;
62735: GO 62745
// result := true ;
62737: LD_ADDR_VAR 0 6
62741: PUSH
62742: LD_INT 1
62744: ST_TO_ADDR
// end ;
62745: LD_VAR 0 6
62749: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
62750: LD_INT 0
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
62778: PPUSH
62779: PPUSH
62780: PPUSH
62781: PPUSH
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
62796: PPUSH
62797: PPUSH
62798: PPUSH
62799: PPUSH
62800: PPUSH
62801: PPUSH
62802: PPUSH
62803: PPUSH
62804: PPUSH
62805: PPUSH
62806: PPUSH
62807: PPUSH
62808: PPUSH
62809: PPUSH
// result = [ ] ;
62810: LD_ADDR_VAR 0 7
62814: PUSH
62815: EMPTY
62816: ST_TO_ADDR
// temp_list = [ ] ;
62817: LD_ADDR_VAR 0 9
62821: PUSH
62822: EMPTY
62823: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62824: LD_VAR 0 4
62828: PUSH
62829: LD_INT 0
62831: PUSH
62832: LD_INT 1
62834: PUSH
62835: LD_INT 2
62837: PUSH
62838: LD_INT 3
62840: PUSH
62841: LD_INT 4
62843: PUSH
62844: LD_INT 5
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: LIST
62851: LIST
62852: LIST
62853: LIST
62854: IN
62855: NOT
62856: PUSH
62857: LD_VAR 0 1
62861: PUSH
62862: LD_INT 0
62864: PUSH
62865: LD_INT 1
62867: PUSH
62868: EMPTY
62869: LIST
62870: LIST
62871: IN
62872: PUSH
62873: LD_VAR 0 5
62877: PUSH
62878: LD_INT 1
62880: PUSH
62881: LD_INT 2
62883: PUSH
62884: LD_INT 3
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: LIST
62891: IN
62892: NOT
62893: AND
62894: OR
62895: IFFALSE 62899
// exit ;
62897: GO 81290
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62899: LD_VAR 0 1
62903: PUSH
62904: LD_INT 6
62906: PUSH
62907: LD_INT 7
62909: PUSH
62910: LD_INT 8
62912: PUSH
62913: LD_INT 13
62915: PUSH
62916: LD_INT 12
62918: PUSH
62919: LD_INT 15
62921: PUSH
62922: LD_INT 11
62924: PUSH
62925: LD_INT 14
62927: PUSH
62928: LD_INT 10
62930: PUSH
62931: EMPTY
62932: LIST
62933: LIST
62934: LIST
62935: LIST
62936: LIST
62937: LIST
62938: LIST
62939: LIST
62940: LIST
62941: IN
62942: IFFALSE 62952
// btype = b_lab ;
62944: LD_ADDR_VAR 0 1
62948: PUSH
62949: LD_INT 6
62951: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62952: LD_VAR 0 6
62956: PUSH
62957: LD_INT 0
62959: PUSH
62960: LD_INT 1
62962: PUSH
62963: LD_INT 2
62965: PUSH
62966: EMPTY
62967: LIST
62968: LIST
62969: LIST
62970: IN
62971: NOT
62972: PUSH
62973: LD_VAR 0 1
62977: PUSH
62978: LD_INT 0
62980: PUSH
62981: LD_INT 1
62983: PUSH
62984: LD_INT 2
62986: PUSH
62987: LD_INT 3
62989: PUSH
62990: LD_INT 6
62992: PUSH
62993: LD_INT 36
62995: PUSH
62996: LD_INT 4
62998: PUSH
62999: LD_INT 5
63001: PUSH
63002: LD_INT 31
63004: PUSH
63005: LD_INT 32
63007: PUSH
63008: LD_INT 33
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: IN
63024: NOT
63025: PUSH
63026: LD_VAR 0 6
63030: PUSH
63031: LD_INT 1
63033: EQUAL
63034: AND
63035: OR
63036: PUSH
63037: LD_VAR 0 1
63041: PUSH
63042: LD_INT 2
63044: PUSH
63045: LD_INT 3
63047: PUSH
63048: EMPTY
63049: LIST
63050: LIST
63051: IN
63052: NOT
63053: PUSH
63054: LD_VAR 0 6
63058: PUSH
63059: LD_INT 2
63061: EQUAL
63062: AND
63063: OR
63064: IFFALSE 63074
// mode = 0 ;
63066: LD_ADDR_VAR 0 6
63070: PUSH
63071: LD_INT 0
63073: ST_TO_ADDR
// case mode of 0 :
63074: LD_VAR 0 6
63078: PUSH
63079: LD_INT 0
63081: DOUBLE
63082: EQUAL
63083: IFTRUE 63087
63085: GO 74540
63087: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63088: LD_ADDR_VAR 0 11
63092: PUSH
63093: LD_INT 0
63095: PUSH
63096: LD_INT 0
63098: PUSH
63099: EMPTY
63100: LIST
63101: LIST
63102: PUSH
63103: LD_INT 0
63105: PUSH
63106: LD_INT 1
63108: NEG
63109: PUSH
63110: EMPTY
63111: LIST
63112: LIST
63113: PUSH
63114: LD_INT 1
63116: PUSH
63117: LD_INT 0
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: PUSH
63124: LD_INT 1
63126: PUSH
63127: LD_INT 1
63129: PUSH
63130: EMPTY
63131: LIST
63132: LIST
63133: PUSH
63134: LD_INT 0
63136: PUSH
63137: LD_INT 1
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: PUSH
63144: LD_INT 1
63146: NEG
63147: PUSH
63148: LD_INT 0
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 1
63157: NEG
63158: PUSH
63159: LD_INT 1
63161: NEG
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: PUSH
63167: LD_INT 1
63169: NEG
63170: PUSH
63171: LD_INT 2
63173: NEG
63174: PUSH
63175: EMPTY
63176: LIST
63177: LIST
63178: PUSH
63179: LD_INT 0
63181: PUSH
63182: LD_INT 2
63184: NEG
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: PUSH
63190: LD_INT 1
63192: PUSH
63193: LD_INT 1
63195: NEG
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: PUSH
63201: LD_INT 1
63203: PUSH
63204: LD_INT 2
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 0
63213: PUSH
63214: LD_INT 2
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 1
63223: NEG
63224: PUSH
63225: LD_INT 1
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: PUSH
63232: LD_INT 1
63234: PUSH
63235: LD_INT 3
63237: PUSH
63238: EMPTY
63239: LIST
63240: LIST
63241: PUSH
63242: LD_INT 0
63244: PUSH
63245: LD_INT 3
63247: PUSH
63248: EMPTY
63249: LIST
63250: LIST
63251: PUSH
63252: LD_INT 1
63254: NEG
63255: PUSH
63256: LD_INT 2
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: EMPTY
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: LIST
63270: LIST
63271: LIST
63272: LIST
63273: LIST
63274: LIST
63275: LIST
63276: LIST
63277: LIST
63278: LIST
63279: LIST
63280: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63281: LD_ADDR_VAR 0 12
63285: PUSH
63286: LD_INT 0
63288: PUSH
63289: LD_INT 0
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 0
63298: PUSH
63299: LD_INT 1
63301: NEG
63302: PUSH
63303: EMPTY
63304: LIST
63305: LIST
63306: PUSH
63307: LD_INT 1
63309: PUSH
63310: LD_INT 0
63312: PUSH
63313: EMPTY
63314: LIST
63315: LIST
63316: PUSH
63317: LD_INT 1
63319: PUSH
63320: LD_INT 1
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 0
63329: PUSH
63330: LD_INT 1
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: LD_INT 1
63339: NEG
63340: PUSH
63341: LD_INT 0
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 1
63350: NEG
63351: PUSH
63352: LD_INT 1
63354: NEG
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: PUSH
63360: LD_INT 1
63362: PUSH
63363: LD_INT 1
63365: NEG
63366: PUSH
63367: EMPTY
63368: LIST
63369: LIST
63370: PUSH
63371: LD_INT 2
63373: PUSH
63374: LD_INT 0
63376: PUSH
63377: EMPTY
63378: LIST
63379: LIST
63380: PUSH
63381: LD_INT 2
63383: PUSH
63384: LD_INT 1
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: PUSH
63391: LD_INT 1
63393: NEG
63394: PUSH
63395: LD_INT 1
63397: PUSH
63398: EMPTY
63399: LIST
63400: LIST
63401: PUSH
63402: LD_INT 2
63404: NEG
63405: PUSH
63406: LD_INT 0
63408: PUSH
63409: EMPTY
63410: LIST
63411: LIST
63412: PUSH
63413: LD_INT 2
63415: NEG
63416: PUSH
63417: LD_INT 1
63419: NEG
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PUSH
63425: LD_INT 2
63427: NEG
63428: PUSH
63429: LD_INT 1
63431: PUSH
63432: EMPTY
63433: LIST
63434: LIST
63435: PUSH
63436: LD_INT 3
63438: NEG
63439: PUSH
63440: LD_INT 0
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: LD_INT 3
63449: NEG
63450: PUSH
63451: LD_INT 1
63453: NEG
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: PUSH
63459: EMPTY
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: LIST
63471: LIST
63472: LIST
63473: LIST
63474: LIST
63475: LIST
63476: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63477: LD_ADDR_VAR 0 13
63481: PUSH
63482: LD_INT 0
63484: PUSH
63485: LD_INT 0
63487: PUSH
63488: EMPTY
63489: LIST
63490: LIST
63491: PUSH
63492: LD_INT 0
63494: PUSH
63495: LD_INT 1
63497: NEG
63498: PUSH
63499: EMPTY
63500: LIST
63501: LIST
63502: PUSH
63503: LD_INT 1
63505: PUSH
63506: LD_INT 0
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PUSH
63513: LD_INT 1
63515: PUSH
63516: LD_INT 1
63518: PUSH
63519: EMPTY
63520: LIST
63521: LIST
63522: PUSH
63523: LD_INT 0
63525: PUSH
63526: LD_INT 1
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 1
63535: NEG
63536: PUSH
63537: LD_INT 0
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 1
63546: NEG
63547: PUSH
63548: LD_INT 1
63550: NEG
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 1
63558: NEG
63559: PUSH
63560: LD_INT 2
63562: NEG
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: PUSH
63568: LD_INT 2
63570: PUSH
63571: LD_INT 1
63573: PUSH
63574: EMPTY
63575: LIST
63576: LIST
63577: PUSH
63578: LD_INT 2
63580: PUSH
63581: LD_INT 2
63583: PUSH
63584: EMPTY
63585: LIST
63586: LIST
63587: PUSH
63588: LD_INT 1
63590: PUSH
63591: LD_INT 2
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: LD_INT 2
63600: NEG
63601: PUSH
63602: LD_INT 1
63604: NEG
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: LD_INT 2
63612: NEG
63613: PUSH
63614: LD_INT 2
63616: NEG
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 2
63624: NEG
63625: PUSH
63626: LD_INT 3
63628: NEG
63629: PUSH
63630: EMPTY
63631: LIST
63632: LIST
63633: PUSH
63634: LD_INT 3
63636: NEG
63637: PUSH
63638: LD_INT 2
63640: NEG
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: PUSH
63646: LD_INT 3
63648: NEG
63649: PUSH
63650: LD_INT 3
63652: NEG
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: LIST
63672: LIST
63673: LIST
63674: LIST
63675: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63676: LD_ADDR_VAR 0 14
63680: PUSH
63681: LD_INT 0
63683: PUSH
63684: LD_INT 0
63686: PUSH
63687: EMPTY
63688: LIST
63689: LIST
63690: PUSH
63691: LD_INT 0
63693: PUSH
63694: LD_INT 1
63696: NEG
63697: PUSH
63698: EMPTY
63699: LIST
63700: LIST
63701: PUSH
63702: LD_INT 1
63704: PUSH
63705: LD_INT 0
63707: PUSH
63708: EMPTY
63709: LIST
63710: LIST
63711: PUSH
63712: LD_INT 1
63714: PUSH
63715: LD_INT 1
63717: PUSH
63718: EMPTY
63719: LIST
63720: LIST
63721: PUSH
63722: LD_INT 0
63724: PUSH
63725: LD_INT 1
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 1
63734: NEG
63735: PUSH
63736: LD_INT 0
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: LD_INT 1
63745: NEG
63746: PUSH
63747: LD_INT 1
63749: NEG
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 1
63757: NEG
63758: PUSH
63759: LD_INT 2
63761: NEG
63762: PUSH
63763: EMPTY
63764: LIST
63765: LIST
63766: PUSH
63767: LD_INT 0
63769: PUSH
63770: LD_INT 2
63772: NEG
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: PUSH
63778: LD_INT 1
63780: PUSH
63781: LD_INT 1
63783: NEG
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: PUSH
63789: LD_INT 1
63791: PUSH
63792: LD_INT 2
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PUSH
63799: LD_INT 0
63801: PUSH
63802: LD_INT 2
63804: PUSH
63805: EMPTY
63806: LIST
63807: LIST
63808: PUSH
63809: LD_INT 1
63811: NEG
63812: PUSH
63813: LD_INT 1
63815: PUSH
63816: EMPTY
63817: LIST
63818: LIST
63819: PUSH
63820: LD_INT 1
63822: NEG
63823: PUSH
63824: LD_INT 3
63826: NEG
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: PUSH
63832: LD_INT 0
63834: PUSH
63835: LD_INT 3
63837: NEG
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: PUSH
63843: LD_INT 1
63845: PUSH
63846: LD_INT 2
63848: NEG
63849: PUSH
63850: EMPTY
63851: LIST
63852: LIST
63853: PUSH
63854: EMPTY
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63872: LD_ADDR_VAR 0 15
63876: PUSH
63877: LD_INT 0
63879: PUSH
63880: LD_INT 0
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: PUSH
63887: LD_INT 0
63889: PUSH
63890: LD_INT 1
63892: NEG
63893: PUSH
63894: EMPTY
63895: LIST
63896: LIST
63897: PUSH
63898: LD_INT 1
63900: PUSH
63901: LD_INT 0
63903: PUSH
63904: EMPTY
63905: LIST
63906: LIST
63907: PUSH
63908: LD_INT 1
63910: PUSH
63911: LD_INT 1
63913: PUSH
63914: EMPTY
63915: LIST
63916: LIST
63917: PUSH
63918: LD_INT 0
63920: PUSH
63921: LD_INT 1
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: PUSH
63928: LD_INT 1
63930: NEG
63931: PUSH
63932: LD_INT 0
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 1
63941: NEG
63942: PUSH
63943: LD_INT 1
63945: NEG
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: LD_INT 1
63953: PUSH
63954: LD_INT 1
63956: NEG
63957: PUSH
63958: EMPTY
63959: LIST
63960: LIST
63961: PUSH
63962: LD_INT 2
63964: PUSH
63965: LD_INT 0
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: PUSH
63972: LD_INT 2
63974: PUSH
63975: LD_INT 1
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: PUSH
63982: LD_INT 1
63984: NEG
63985: PUSH
63986: LD_INT 1
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 2
63995: NEG
63996: PUSH
63997: LD_INT 0
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PUSH
64004: LD_INT 2
64006: NEG
64007: PUSH
64008: LD_INT 1
64010: NEG
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 2
64018: PUSH
64019: LD_INT 1
64021: NEG
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 3
64029: PUSH
64030: LD_INT 0
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 3
64039: PUSH
64040: LD_INT 1
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: PUSH
64047: EMPTY
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: LIST
64064: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64065: LD_ADDR_VAR 0 16
64069: PUSH
64070: LD_INT 0
64072: PUSH
64073: LD_INT 0
64075: PUSH
64076: EMPTY
64077: LIST
64078: LIST
64079: PUSH
64080: LD_INT 0
64082: PUSH
64083: LD_INT 1
64085: NEG
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: PUSH
64091: LD_INT 1
64093: PUSH
64094: LD_INT 0
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 1
64103: PUSH
64104: LD_INT 1
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PUSH
64111: LD_INT 0
64113: PUSH
64114: LD_INT 1
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: PUSH
64121: LD_INT 1
64123: NEG
64124: PUSH
64125: LD_INT 0
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: PUSH
64136: LD_INT 1
64138: NEG
64139: PUSH
64140: EMPTY
64141: LIST
64142: LIST
64143: PUSH
64144: LD_INT 1
64146: NEG
64147: PUSH
64148: LD_INT 2
64150: NEG
64151: PUSH
64152: EMPTY
64153: LIST
64154: LIST
64155: PUSH
64156: LD_INT 2
64158: PUSH
64159: LD_INT 1
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 2
64168: PUSH
64169: LD_INT 2
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: PUSH
64176: LD_INT 1
64178: PUSH
64179: LD_INT 2
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 2
64188: NEG
64189: PUSH
64190: LD_INT 1
64192: NEG
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 2
64200: NEG
64201: PUSH
64202: LD_INT 2
64204: NEG
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: LD_INT 3
64212: PUSH
64213: LD_INT 2
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: PUSH
64220: LD_INT 3
64222: PUSH
64223: LD_INT 3
64225: PUSH
64226: EMPTY
64227: LIST
64228: LIST
64229: PUSH
64230: LD_INT 2
64232: PUSH
64233: LD_INT 3
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: LIST
64255: LIST
64256: LIST
64257: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64258: LD_ADDR_VAR 0 17
64262: PUSH
64263: LD_INT 0
64265: PUSH
64266: LD_INT 0
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: LD_INT 0
64275: PUSH
64276: LD_INT 1
64278: NEG
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: LD_INT 1
64286: PUSH
64287: LD_INT 0
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: LD_INT 1
64296: PUSH
64297: LD_INT 1
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 0
64306: PUSH
64307: LD_INT 1
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 1
64316: NEG
64317: PUSH
64318: LD_INT 0
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 1
64327: NEG
64328: PUSH
64329: LD_INT 1
64331: NEG
64332: PUSH
64333: EMPTY
64334: LIST
64335: LIST
64336: PUSH
64337: LD_INT 1
64339: NEG
64340: PUSH
64341: LD_INT 2
64343: NEG
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: PUSH
64349: LD_INT 0
64351: PUSH
64352: LD_INT 2
64354: NEG
64355: PUSH
64356: EMPTY
64357: LIST
64358: LIST
64359: PUSH
64360: LD_INT 1
64362: PUSH
64363: LD_INT 1
64365: NEG
64366: PUSH
64367: EMPTY
64368: LIST
64369: LIST
64370: PUSH
64371: LD_INT 2
64373: PUSH
64374: LD_INT 0
64376: PUSH
64377: EMPTY
64378: LIST
64379: LIST
64380: PUSH
64381: LD_INT 2
64383: PUSH
64384: LD_INT 1
64386: PUSH
64387: EMPTY
64388: LIST
64389: LIST
64390: PUSH
64391: LD_INT 2
64393: PUSH
64394: LD_INT 2
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: LD_INT 1
64403: PUSH
64404: LD_INT 2
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: LD_INT 0
64413: PUSH
64414: LD_INT 2
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 1
64423: NEG
64424: PUSH
64425: LD_INT 1
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 2
64434: NEG
64435: PUSH
64436: LD_INT 0
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 2
64445: NEG
64446: PUSH
64447: LD_INT 1
64449: NEG
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 2
64457: NEG
64458: PUSH
64459: LD_INT 2
64461: NEG
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64488: LD_ADDR_VAR 0 18
64492: PUSH
64493: LD_INT 0
64495: PUSH
64496: LD_INT 0
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: PUSH
64503: LD_INT 0
64505: PUSH
64506: LD_INT 1
64508: NEG
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PUSH
64514: LD_INT 1
64516: PUSH
64517: LD_INT 0
64519: PUSH
64520: EMPTY
64521: LIST
64522: LIST
64523: PUSH
64524: LD_INT 1
64526: PUSH
64527: LD_INT 1
64529: PUSH
64530: EMPTY
64531: LIST
64532: LIST
64533: PUSH
64534: LD_INT 0
64536: PUSH
64537: LD_INT 1
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: PUSH
64544: LD_INT 1
64546: NEG
64547: PUSH
64548: LD_INT 0
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 1
64557: NEG
64558: PUSH
64559: LD_INT 1
64561: NEG
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: LD_INT 1
64569: NEG
64570: PUSH
64571: LD_INT 2
64573: NEG
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 0
64581: PUSH
64582: LD_INT 2
64584: NEG
64585: PUSH
64586: EMPTY
64587: LIST
64588: LIST
64589: PUSH
64590: LD_INT 1
64592: PUSH
64593: LD_INT 1
64595: NEG
64596: PUSH
64597: EMPTY
64598: LIST
64599: LIST
64600: PUSH
64601: LD_INT 2
64603: PUSH
64604: LD_INT 0
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: PUSH
64611: LD_INT 2
64613: PUSH
64614: LD_INT 1
64616: PUSH
64617: EMPTY
64618: LIST
64619: LIST
64620: PUSH
64621: LD_INT 2
64623: PUSH
64624: LD_INT 2
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: LD_INT 2
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 0
64643: PUSH
64644: LD_INT 2
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 1
64653: NEG
64654: PUSH
64655: LD_INT 1
64657: PUSH
64658: EMPTY
64659: LIST
64660: LIST
64661: PUSH
64662: LD_INT 2
64664: NEG
64665: PUSH
64666: LD_INT 0
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: NEG
64676: PUSH
64677: LD_INT 1
64679: NEG
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: LD_INT 2
64687: NEG
64688: PUSH
64689: LD_INT 2
64691: NEG
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64718: LD_ADDR_VAR 0 19
64722: PUSH
64723: LD_INT 0
64725: PUSH
64726: LD_INT 0
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PUSH
64733: LD_INT 0
64735: PUSH
64736: LD_INT 1
64738: NEG
64739: PUSH
64740: EMPTY
64741: LIST
64742: LIST
64743: PUSH
64744: LD_INT 1
64746: PUSH
64747: LD_INT 0
64749: PUSH
64750: EMPTY
64751: LIST
64752: LIST
64753: PUSH
64754: LD_INT 1
64756: PUSH
64757: LD_INT 1
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 0
64766: PUSH
64767: LD_INT 1
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: LD_INT 1
64776: NEG
64777: PUSH
64778: LD_INT 0
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 1
64787: NEG
64788: PUSH
64789: LD_INT 1
64791: NEG
64792: PUSH
64793: EMPTY
64794: LIST
64795: LIST
64796: PUSH
64797: LD_INT 1
64799: NEG
64800: PUSH
64801: LD_INT 2
64803: NEG
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PUSH
64809: LD_INT 0
64811: PUSH
64812: LD_INT 2
64814: NEG
64815: PUSH
64816: EMPTY
64817: LIST
64818: LIST
64819: PUSH
64820: LD_INT 1
64822: PUSH
64823: LD_INT 1
64825: NEG
64826: PUSH
64827: EMPTY
64828: LIST
64829: LIST
64830: PUSH
64831: LD_INT 2
64833: PUSH
64834: LD_INT 0
64836: PUSH
64837: EMPTY
64838: LIST
64839: LIST
64840: PUSH
64841: LD_INT 2
64843: PUSH
64844: LD_INT 1
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: PUSH
64851: LD_INT 2
64853: PUSH
64854: LD_INT 2
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 1
64863: PUSH
64864: LD_INT 2
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PUSH
64871: LD_INT 0
64873: PUSH
64874: LD_INT 2
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 1
64883: NEG
64884: PUSH
64885: LD_INT 1
64887: PUSH
64888: EMPTY
64889: LIST
64890: LIST
64891: PUSH
64892: LD_INT 2
64894: NEG
64895: PUSH
64896: LD_INT 0
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 2
64905: NEG
64906: PUSH
64907: LD_INT 1
64909: NEG
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: LD_INT 2
64917: NEG
64918: PUSH
64919: LD_INT 2
64921: NEG
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: LIST
64947: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64948: LD_ADDR_VAR 0 20
64952: PUSH
64953: LD_INT 0
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 0
64965: PUSH
64966: LD_INT 1
64968: NEG
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: LD_INT 1
64976: PUSH
64977: LD_INT 0
64979: PUSH
64980: EMPTY
64981: LIST
64982: LIST
64983: PUSH
64984: LD_INT 1
64986: PUSH
64987: LD_INT 1
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 0
64996: PUSH
64997: LD_INT 1
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 1
65006: NEG
65007: PUSH
65008: LD_INT 0
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 1
65017: NEG
65018: PUSH
65019: LD_INT 1
65021: NEG
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: PUSH
65027: LD_INT 1
65029: NEG
65030: PUSH
65031: LD_INT 2
65033: NEG
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 0
65041: PUSH
65042: LD_INT 2
65044: NEG
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PUSH
65050: LD_INT 1
65052: PUSH
65053: LD_INT 1
65055: NEG
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: PUSH
65061: LD_INT 2
65063: PUSH
65064: LD_INT 0
65066: PUSH
65067: EMPTY
65068: LIST
65069: LIST
65070: PUSH
65071: LD_INT 2
65073: PUSH
65074: LD_INT 1
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PUSH
65081: LD_INT 2
65083: PUSH
65084: LD_INT 2
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: LD_INT 1
65093: PUSH
65094: LD_INT 2
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 0
65103: PUSH
65104: LD_INT 2
65106: PUSH
65107: EMPTY
65108: LIST
65109: LIST
65110: PUSH
65111: LD_INT 1
65113: NEG
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 2
65124: NEG
65125: PUSH
65126: LD_INT 0
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 2
65135: NEG
65136: PUSH
65137: LD_INT 1
65139: NEG
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 2
65147: NEG
65148: PUSH
65149: LD_INT 2
65151: NEG
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65178: LD_ADDR_VAR 0 21
65182: PUSH
65183: LD_INT 0
65185: PUSH
65186: LD_INT 0
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PUSH
65193: LD_INT 0
65195: PUSH
65196: LD_INT 1
65198: NEG
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: PUSH
65204: LD_INT 1
65206: PUSH
65207: LD_INT 0
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: PUSH
65214: LD_INT 1
65216: PUSH
65217: LD_INT 1
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PUSH
65224: LD_INT 0
65226: PUSH
65227: LD_INT 1
65229: PUSH
65230: EMPTY
65231: LIST
65232: LIST
65233: PUSH
65234: LD_INT 1
65236: NEG
65237: PUSH
65238: LD_INT 0
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 1
65247: NEG
65248: PUSH
65249: LD_INT 1
65251: NEG
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 1
65259: NEG
65260: PUSH
65261: LD_INT 2
65263: NEG
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 0
65271: PUSH
65272: LD_INT 2
65274: NEG
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: LD_INT 1
65285: NEG
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: PUSH
65291: LD_INT 2
65293: PUSH
65294: LD_INT 0
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PUSH
65301: LD_INT 2
65303: PUSH
65304: LD_INT 1
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 2
65313: PUSH
65314: LD_INT 2
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 1
65323: PUSH
65324: LD_INT 2
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 0
65333: PUSH
65334: LD_INT 2
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: LD_INT 1
65343: NEG
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: LD_INT 2
65354: NEG
65355: PUSH
65356: LD_INT 0
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: LD_INT 2
65365: NEG
65366: PUSH
65367: LD_INT 1
65369: NEG
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PUSH
65375: LD_INT 2
65377: NEG
65378: PUSH
65379: LD_INT 2
65381: NEG
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65408: LD_ADDR_VAR 0 22
65412: PUSH
65413: LD_INT 0
65415: PUSH
65416: LD_INT 0
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: PUSH
65423: LD_INT 0
65425: PUSH
65426: LD_INT 1
65428: NEG
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: PUSH
65434: LD_INT 1
65436: PUSH
65437: LD_INT 0
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: LD_INT 1
65446: PUSH
65447: LD_INT 1
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 0
65456: PUSH
65457: LD_INT 1
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 1
65466: NEG
65467: PUSH
65468: LD_INT 0
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 1
65477: NEG
65478: PUSH
65479: LD_INT 1
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 1
65489: NEG
65490: PUSH
65491: LD_INT 2
65493: NEG
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 0
65501: PUSH
65502: LD_INT 2
65504: NEG
65505: PUSH
65506: EMPTY
65507: LIST
65508: LIST
65509: PUSH
65510: LD_INT 1
65512: PUSH
65513: LD_INT 1
65515: NEG
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PUSH
65521: LD_INT 2
65523: PUSH
65524: LD_INT 0
65526: PUSH
65527: EMPTY
65528: LIST
65529: LIST
65530: PUSH
65531: LD_INT 2
65533: PUSH
65534: LD_INT 1
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: PUSH
65541: LD_INT 2
65543: PUSH
65544: LD_INT 2
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: LD_INT 2
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 0
65563: PUSH
65564: LD_INT 2
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 1
65573: NEG
65574: PUSH
65575: LD_INT 1
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 2
65584: NEG
65585: PUSH
65586: LD_INT 0
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: NEG
65596: PUSH
65597: LD_INT 1
65599: NEG
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 2
65607: NEG
65608: PUSH
65609: LD_INT 2
65611: NEG
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: EMPTY
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65638: LD_ADDR_VAR 0 23
65642: PUSH
65643: LD_INT 0
65645: PUSH
65646: LD_INT 0
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 0
65655: PUSH
65656: LD_INT 1
65658: NEG
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 1
65666: PUSH
65667: LD_INT 0
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 1
65676: PUSH
65677: LD_INT 1
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: PUSH
65684: LD_INT 0
65686: PUSH
65687: LD_INT 1
65689: PUSH
65690: EMPTY
65691: LIST
65692: LIST
65693: PUSH
65694: LD_INT 1
65696: NEG
65697: PUSH
65698: LD_INT 0
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: LD_INT 1
65707: NEG
65708: PUSH
65709: LD_INT 1
65711: NEG
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 1
65719: NEG
65720: PUSH
65721: LD_INT 2
65723: NEG
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 0
65731: PUSH
65732: LD_INT 2
65734: NEG
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: PUSH
65740: LD_INT 1
65742: PUSH
65743: LD_INT 1
65745: NEG
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: PUSH
65751: LD_INT 2
65753: PUSH
65754: LD_INT 0
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PUSH
65761: LD_INT 2
65763: PUSH
65764: LD_INT 1
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: PUSH
65771: LD_INT 2
65773: PUSH
65774: LD_INT 2
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: LD_INT 1
65783: PUSH
65784: LD_INT 2
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 0
65793: PUSH
65794: LD_INT 2
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PUSH
65801: LD_INT 1
65803: NEG
65804: PUSH
65805: LD_INT 1
65807: PUSH
65808: EMPTY
65809: LIST
65810: LIST
65811: PUSH
65812: LD_INT 2
65814: NEG
65815: PUSH
65816: LD_INT 0
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 2
65825: NEG
65826: PUSH
65827: LD_INT 1
65829: NEG
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 2
65837: NEG
65838: PUSH
65839: LD_INT 2
65841: NEG
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 2
65849: NEG
65850: PUSH
65851: LD_INT 3
65853: NEG
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: LD_INT 1
65861: NEG
65862: PUSH
65863: LD_INT 3
65865: NEG
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: PUSH
65871: LD_INT 1
65873: PUSH
65874: LD_INT 2
65876: NEG
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: LD_INT 2
65884: PUSH
65885: LD_INT 1
65887: NEG
65888: PUSH
65889: EMPTY
65890: LIST
65891: LIST
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65918: LD_ADDR_VAR 0 24
65922: PUSH
65923: LD_INT 0
65925: PUSH
65926: LD_INT 0
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: PUSH
65933: LD_INT 0
65935: PUSH
65936: LD_INT 1
65938: NEG
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: LD_INT 1
65946: PUSH
65947: LD_INT 0
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 1
65956: PUSH
65957: LD_INT 1
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 0
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 1
65976: NEG
65977: PUSH
65978: LD_INT 0
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 1
65987: NEG
65988: PUSH
65989: LD_INT 1
65991: NEG
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: PUSH
65997: LD_INT 1
65999: NEG
66000: PUSH
66001: LD_INT 2
66003: NEG
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PUSH
66009: LD_INT 0
66011: PUSH
66012: LD_INT 2
66014: NEG
66015: PUSH
66016: EMPTY
66017: LIST
66018: LIST
66019: PUSH
66020: LD_INT 1
66022: PUSH
66023: LD_INT 1
66025: NEG
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 2
66033: PUSH
66034: LD_INT 0
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 2
66043: PUSH
66044: LD_INT 1
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 2
66053: PUSH
66054: LD_INT 2
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 1
66063: PUSH
66064: LD_INT 2
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 0
66073: PUSH
66074: LD_INT 2
66076: PUSH
66077: EMPTY
66078: LIST
66079: LIST
66080: PUSH
66081: LD_INT 1
66083: NEG
66084: PUSH
66085: LD_INT 1
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 2
66094: NEG
66095: PUSH
66096: LD_INT 0
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 2
66105: NEG
66106: PUSH
66107: LD_INT 1
66109: NEG
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 2
66117: NEG
66118: PUSH
66119: LD_INT 2
66121: NEG
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: PUSH
66130: LD_INT 2
66132: NEG
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 2
66140: PUSH
66141: LD_INT 1
66143: NEG
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 3
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: LD_INT 3
66161: PUSH
66162: LD_INT 2
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66194: LD_ADDR_VAR 0 25
66198: PUSH
66199: LD_INT 0
66201: PUSH
66202: LD_INT 0
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 0
66211: PUSH
66212: LD_INT 1
66214: NEG
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 1
66222: PUSH
66223: LD_INT 0
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: PUSH
66233: LD_INT 1
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 0
66242: PUSH
66243: LD_INT 1
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: NEG
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 1
66263: NEG
66264: PUSH
66265: LD_INT 1
66267: NEG
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 1
66275: NEG
66276: PUSH
66277: LD_INT 2
66279: NEG
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 0
66287: PUSH
66288: LD_INT 2
66290: NEG
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: LD_INT 1
66298: PUSH
66299: LD_INT 1
66301: NEG
66302: PUSH
66303: EMPTY
66304: LIST
66305: LIST
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: LD_INT 0
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PUSH
66317: LD_INT 2
66319: PUSH
66320: LD_INT 1
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 2
66329: PUSH
66330: LD_INT 2
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 1
66339: PUSH
66340: LD_INT 2
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 0
66349: PUSH
66350: LD_INT 2
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 1
66359: NEG
66360: PUSH
66361: LD_INT 1
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: PUSH
66368: LD_INT 2
66370: NEG
66371: PUSH
66372: LD_INT 0
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 2
66381: NEG
66382: PUSH
66383: LD_INT 1
66385: NEG
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 2
66393: NEG
66394: PUSH
66395: LD_INT 2
66397: NEG
66398: PUSH
66399: EMPTY
66400: LIST
66401: LIST
66402: PUSH
66403: LD_INT 3
66405: PUSH
66406: LD_INT 1
66408: PUSH
66409: EMPTY
66410: LIST
66411: LIST
66412: PUSH
66413: LD_INT 3
66415: PUSH
66416: LD_INT 2
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 2
66425: PUSH
66426: LD_INT 3
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 1
66435: PUSH
66436: LD_INT 3
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: LIST
66465: LIST
66466: LIST
66467: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66468: LD_ADDR_VAR 0 26
66472: PUSH
66473: LD_INT 0
66475: PUSH
66476: LD_INT 0
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 0
66485: PUSH
66486: LD_INT 1
66488: NEG
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 1
66496: PUSH
66497: LD_INT 0
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 1
66506: PUSH
66507: LD_INT 1
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 0
66516: PUSH
66517: LD_INT 1
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 1
66526: NEG
66527: PUSH
66528: LD_INT 0
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 1
66537: NEG
66538: PUSH
66539: LD_INT 1
66541: NEG
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: LD_INT 1
66549: NEG
66550: PUSH
66551: LD_INT 2
66553: NEG
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 0
66561: PUSH
66562: LD_INT 2
66564: NEG
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 1
66572: PUSH
66573: LD_INT 1
66575: NEG
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 2
66583: PUSH
66584: LD_INT 0
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 2
66593: PUSH
66594: LD_INT 1
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: PUSH
66601: LD_INT 2
66603: PUSH
66604: LD_INT 2
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 1
66613: PUSH
66614: LD_INT 2
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: PUSH
66621: LD_INT 0
66623: PUSH
66624: LD_INT 2
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PUSH
66631: LD_INT 1
66633: NEG
66634: PUSH
66635: LD_INT 1
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 2
66644: NEG
66645: PUSH
66646: LD_INT 0
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 2
66655: NEG
66656: PUSH
66657: LD_INT 1
66659: NEG
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 2
66667: NEG
66668: PUSH
66669: LD_INT 2
66671: NEG
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 2
66679: PUSH
66680: LD_INT 3
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 1
66689: PUSH
66690: LD_INT 3
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 1
66699: NEG
66700: PUSH
66701: LD_INT 2
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 2
66710: NEG
66711: PUSH
66712: LD_INT 1
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66744: LD_ADDR_VAR 0 27
66748: PUSH
66749: LD_INT 0
66751: PUSH
66752: LD_INT 0
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: LD_INT 1
66764: NEG
66765: PUSH
66766: EMPTY
66767: LIST
66768: LIST
66769: PUSH
66770: LD_INT 1
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 1
66782: PUSH
66783: LD_INT 1
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 0
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: NEG
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: LD_INT 1
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 2
66829: NEG
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 0
66837: PUSH
66838: LD_INT 2
66840: NEG
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 2
66859: PUSH
66860: LD_INT 0
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: PUSH
66867: LD_INT 2
66869: PUSH
66870: LD_INT 1
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 2
66879: PUSH
66880: LD_INT 2
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PUSH
66887: LD_INT 1
66889: PUSH
66890: LD_INT 2
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PUSH
66897: LD_INT 0
66899: PUSH
66900: LD_INT 2
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 1
66909: NEG
66910: PUSH
66911: LD_INT 1
66913: PUSH
66914: EMPTY
66915: LIST
66916: LIST
66917: PUSH
66918: LD_INT 2
66920: NEG
66921: PUSH
66922: LD_INT 0
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 2
66931: NEG
66932: PUSH
66933: LD_INT 1
66935: NEG
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 2
66943: NEG
66944: PUSH
66945: LD_INT 2
66947: NEG
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PUSH
66953: LD_INT 1
66955: NEG
66956: PUSH
66957: LD_INT 2
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 2
66966: NEG
66967: PUSH
66968: LD_INT 1
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 3
66977: NEG
66978: PUSH
66979: LD_INT 1
66981: NEG
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: LD_INT 3
66989: NEG
66990: PUSH
66991: LD_INT 2
66993: NEG
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67024: LD_ADDR_VAR 0 28
67028: PUSH
67029: LD_INT 0
67031: PUSH
67032: LD_INT 0
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 0
67041: PUSH
67042: LD_INT 1
67044: NEG
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 1
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 1
67062: PUSH
67063: LD_INT 1
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 0
67072: PUSH
67073: LD_INT 1
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: NEG
67083: PUSH
67084: LD_INT 0
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: LD_INT 1
67097: NEG
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 1
67105: NEG
67106: PUSH
67107: LD_INT 2
67109: NEG
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 0
67117: PUSH
67118: LD_INT 2
67120: NEG
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: PUSH
67126: LD_INT 1
67128: PUSH
67129: LD_INT 1
67131: NEG
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 2
67139: PUSH
67140: LD_INT 0
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: PUSH
67147: LD_INT 2
67149: PUSH
67150: LD_INT 1
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 2
67159: PUSH
67160: LD_INT 2
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 1
67169: PUSH
67170: LD_INT 2
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: LD_INT 2
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: LD_INT 1
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 2
67200: NEG
67201: PUSH
67202: LD_INT 0
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 2
67211: NEG
67212: PUSH
67213: LD_INT 1
67215: NEG
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: LD_INT 2
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 2
67235: NEG
67236: PUSH
67237: LD_INT 3
67239: NEG
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 1
67247: NEG
67248: PUSH
67249: LD_INT 3
67251: NEG
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 3
67259: NEG
67260: PUSH
67261: LD_INT 1
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 3
67271: NEG
67272: PUSH
67273: LD_INT 2
67275: NEG
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67306: LD_ADDR_VAR 0 29
67310: PUSH
67311: LD_INT 0
67313: PUSH
67314: LD_INT 0
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 0
67323: PUSH
67324: LD_INT 1
67326: NEG
67327: PUSH
67328: EMPTY
67329: LIST
67330: LIST
67331: PUSH
67332: LD_INT 1
67334: PUSH
67335: LD_INT 0
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PUSH
67342: LD_INT 1
67344: PUSH
67345: LD_INT 1
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 0
67354: PUSH
67355: LD_INT 1
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 1
67364: NEG
67365: PUSH
67366: LD_INT 0
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 1
67375: NEG
67376: PUSH
67377: LD_INT 1
67379: NEG
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: LD_INT 1
67387: NEG
67388: PUSH
67389: LD_INT 2
67391: NEG
67392: PUSH
67393: EMPTY
67394: LIST
67395: LIST
67396: PUSH
67397: LD_INT 0
67399: PUSH
67400: LD_INT 2
67402: NEG
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 1
67410: PUSH
67411: LD_INT 1
67413: NEG
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 2
67421: PUSH
67422: LD_INT 0
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: LD_INT 2
67431: PUSH
67432: LD_INT 1
67434: PUSH
67435: EMPTY
67436: LIST
67437: LIST
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: LD_INT 2
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: LD_INT 2
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: LD_INT 1
67461: NEG
67462: PUSH
67463: LD_INT 1
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 2
67472: NEG
67473: PUSH
67474: LD_INT 1
67476: NEG
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: LD_INT 2
67488: NEG
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 2
67496: NEG
67497: PUSH
67498: LD_INT 3
67500: NEG
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 2
67508: PUSH
67509: LD_INT 1
67511: NEG
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 3
67519: PUSH
67520: LD_INT 1
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 1
67529: PUSH
67530: LD_INT 3
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: PUSH
67537: LD_INT 1
67539: NEG
67540: PUSH
67541: LD_INT 2
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 3
67550: NEG
67551: PUSH
67552: LD_INT 2
67554: NEG
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: LIST
67582: LIST
67583: LIST
67584: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67585: LD_ADDR_VAR 0 30
67589: PUSH
67590: LD_INT 0
67592: PUSH
67593: LD_INT 0
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 0
67602: PUSH
67603: LD_INT 1
67605: NEG
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 1
67613: PUSH
67614: LD_INT 0
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 1
67623: PUSH
67624: LD_INT 1
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 0
67633: PUSH
67634: LD_INT 1
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 1
67643: NEG
67644: PUSH
67645: LD_INT 0
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 1
67654: NEG
67655: PUSH
67656: LD_INT 1
67658: NEG
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 1
67666: NEG
67667: PUSH
67668: LD_INT 2
67670: NEG
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 0
67678: PUSH
67679: LD_INT 2
67681: NEG
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 1
67689: PUSH
67690: LD_INT 1
67692: NEG
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 2
67700: PUSH
67701: LD_INT 0
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: PUSH
67708: LD_INT 2
67710: PUSH
67711: LD_INT 1
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 2
67720: PUSH
67721: LD_INT 2
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 1
67730: PUSH
67731: LD_INT 2
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: PUSH
67738: LD_INT 1
67740: NEG
67741: PUSH
67742: LD_INT 1
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 2
67751: NEG
67752: PUSH
67753: LD_INT 0
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 2
67762: NEG
67763: PUSH
67764: LD_INT 1
67766: NEG
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: LD_INT 3
67778: NEG
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: PUSH
67787: LD_INT 2
67789: NEG
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 3
67797: PUSH
67798: LD_INT 2
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 2
67807: PUSH
67808: LD_INT 3
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 2
67817: NEG
67818: PUSH
67819: LD_INT 1
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 3
67828: NEG
67829: PUSH
67830: LD_INT 1
67832: NEG
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67863: LD_ADDR_VAR 0 31
67867: PUSH
67868: LD_INT 0
67870: PUSH
67871: LD_INT 0
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: PUSH
67878: LD_INT 0
67880: PUSH
67881: LD_INT 1
67883: NEG
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PUSH
67889: LD_INT 1
67891: PUSH
67892: LD_INT 0
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: LD_INT 1
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: PUSH
67909: LD_INT 0
67911: PUSH
67912: LD_INT 1
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: LD_INT 1
67921: NEG
67922: PUSH
67923: LD_INT 0
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: LD_INT 1
67936: NEG
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 1
67944: NEG
67945: PUSH
67946: LD_INT 2
67948: NEG
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PUSH
67954: LD_INT 1
67956: PUSH
67957: LD_INT 1
67959: NEG
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 2
67967: PUSH
67968: LD_INT 0
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: PUSH
67975: LD_INT 2
67977: PUSH
67978: LD_INT 1
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 2
67987: PUSH
67988: LD_INT 2
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 1
67997: PUSH
67998: LD_INT 2
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 0
68007: PUSH
68008: LD_INT 2
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 1
68017: NEG
68018: PUSH
68019: LD_INT 1
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 2
68028: NEG
68029: PUSH
68030: LD_INT 1
68032: NEG
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 2
68040: NEG
68041: PUSH
68042: LD_INT 2
68044: NEG
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 2
68052: NEG
68053: PUSH
68054: LD_INT 3
68056: NEG
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 2
68064: PUSH
68065: LD_INT 1
68067: NEG
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: PUSH
68073: LD_INT 3
68075: PUSH
68076: LD_INT 1
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 1
68085: PUSH
68086: LD_INT 3
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 1
68095: NEG
68096: PUSH
68097: LD_INT 2
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: LD_INT 3
68106: NEG
68107: PUSH
68108: LD_INT 2
68110: NEG
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: LIST
68132: LIST
68133: LIST
68134: LIST
68135: LIST
68136: LIST
68137: LIST
68138: LIST
68139: LIST
68140: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68141: LD_ADDR_VAR 0 32
68145: PUSH
68146: LD_INT 0
68148: PUSH
68149: LD_INT 0
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 0
68158: PUSH
68159: LD_INT 1
68161: NEG
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: LD_INT 1
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 1
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 0
68189: PUSH
68190: LD_INT 1
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 1
68199: NEG
68200: PUSH
68201: LD_INT 0
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 1
68210: NEG
68211: PUSH
68212: LD_INT 1
68214: NEG
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 1
68222: NEG
68223: PUSH
68224: LD_INT 2
68226: NEG
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: LD_INT 2
68237: NEG
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 1
68245: PUSH
68246: LD_INT 1
68248: NEG
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: LD_INT 2
68256: PUSH
68257: LD_INT 1
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 2
68266: PUSH
68267: LD_INT 2
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 1
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 0
68286: PUSH
68287: LD_INT 2
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 1
68296: NEG
68297: PUSH
68298: LD_INT 1
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 2
68307: NEG
68308: PUSH
68309: LD_INT 0
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 2
68318: NEG
68319: PUSH
68320: LD_INT 1
68322: NEG
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 1
68330: NEG
68331: PUSH
68332: LD_INT 3
68334: NEG
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PUSH
68340: LD_INT 1
68342: PUSH
68343: LD_INT 2
68345: NEG
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 3
68353: PUSH
68354: LD_INT 2
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 2
68363: PUSH
68364: LD_INT 3
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 2
68373: NEG
68374: PUSH
68375: LD_INT 1
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 3
68384: NEG
68385: PUSH
68386: LD_INT 1
68388: NEG
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68419: LD_ADDR_VAR 0 33
68423: PUSH
68424: LD_INT 0
68426: PUSH
68427: LD_INT 0
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 0
68436: PUSH
68437: LD_INT 1
68439: NEG
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: LD_INT 1
68447: PUSH
68448: LD_INT 0
68450: PUSH
68451: EMPTY
68452: LIST
68453: LIST
68454: PUSH
68455: LD_INT 1
68457: PUSH
68458: LD_INT 1
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: LD_INT 1
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 1
68477: NEG
68478: PUSH
68479: LD_INT 0
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: LD_INT 1
68492: NEG
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 1
68500: NEG
68501: PUSH
68502: LD_INT 2
68504: NEG
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 1
68512: PUSH
68513: LD_INT 1
68515: NEG
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: PUSH
68521: LD_INT 2
68523: PUSH
68524: LD_INT 0
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 2
68533: PUSH
68534: LD_INT 1
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 1
68543: PUSH
68544: LD_INT 2
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PUSH
68551: LD_INT 0
68553: PUSH
68554: LD_INT 2
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 1
68563: NEG
68564: PUSH
68565: LD_INT 1
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 2
68574: NEG
68575: PUSH
68576: LD_INT 0
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: NEG
68586: PUSH
68587: LD_INT 1
68589: NEG
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 2
68597: NEG
68598: PUSH
68599: LD_INT 2
68601: NEG
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 2
68609: NEG
68610: PUSH
68611: LD_INT 3
68613: NEG
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 2
68621: PUSH
68622: LD_INT 1
68624: NEG
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: LD_INT 3
68632: PUSH
68633: LD_INT 1
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 1
68642: PUSH
68643: LD_INT 3
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: LD_INT 1
68652: NEG
68653: PUSH
68654: LD_INT 2
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: LD_INT 3
68663: NEG
68664: PUSH
68665: LD_INT 2
68667: NEG
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68698: LD_ADDR_VAR 0 34
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: LD_INT 0
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: LD_INT 1
68718: NEG
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 1
68726: PUSH
68727: LD_INT 0
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 1
68736: PUSH
68737: LD_INT 1
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 0
68746: PUSH
68747: LD_INT 1
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 1
68756: NEG
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: LD_INT 1
68771: NEG
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 1
68779: NEG
68780: PUSH
68781: LD_INT 2
68783: NEG
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PUSH
68789: LD_INT 0
68791: PUSH
68792: LD_INT 2
68794: NEG
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: PUSH
68800: LD_INT 1
68802: PUSH
68803: LD_INT 1
68805: NEG
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 2
68813: PUSH
68814: LD_INT 1
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 2
68823: PUSH
68824: LD_INT 2
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 1
68833: PUSH
68834: LD_INT 2
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 1
68843: NEG
68844: PUSH
68845: LD_INT 1
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 2
68854: NEG
68855: PUSH
68856: LD_INT 0
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: LD_INT 1
68869: NEG
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 2
68877: NEG
68878: PUSH
68879: LD_INT 2
68881: NEG
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: LD_INT 1
68889: NEG
68890: PUSH
68891: LD_INT 3
68893: NEG
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 1
68901: PUSH
68902: LD_INT 2
68904: NEG
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: PUSH
68910: LD_INT 3
68912: PUSH
68913: LD_INT 2
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 2
68922: PUSH
68923: LD_INT 3
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PUSH
68930: LD_INT 2
68932: NEG
68933: PUSH
68934: LD_INT 1
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 3
68943: NEG
68944: PUSH
68945: LD_INT 1
68947: NEG
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68978: LD_ADDR_VAR 0 35
68982: PUSH
68983: LD_INT 0
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 0
68995: PUSH
68996: LD_INT 1
68998: NEG
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 1
69006: PUSH
69007: LD_INT 0
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 1
69016: PUSH
69017: LD_INT 1
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 0
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 1
69036: NEG
69037: PUSH
69038: LD_INT 0
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 1
69047: NEG
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 2
69059: PUSH
69060: LD_INT 1
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: LD_INT 2
69069: NEG
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69090: LD_ADDR_VAR 0 36
69094: PUSH
69095: LD_INT 0
69097: PUSH
69098: LD_INT 0
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: LD_INT 0
69107: PUSH
69108: LD_INT 1
69110: NEG
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 1
69118: PUSH
69119: LD_INT 0
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: LD_INT 1
69128: PUSH
69129: LD_INT 1
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: PUSH
69136: LD_INT 0
69138: PUSH
69139: LD_INT 1
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 1
69148: NEG
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 1
69159: NEG
69160: PUSH
69161: LD_INT 1
69163: NEG
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: NEG
69172: PUSH
69173: LD_INT 2
69175: NEG
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 1
69183: PUSH
69184: LD_INT 2
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69202: LD_ADDR_VAR 0 37
69206: PUSH
69207: LD_INT 0
69209: PUSH
69210: LD_INT 0
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 0
69219: PUSH
69220: LD_INT 1
69222: NEG
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PUSH
69238: LD_INT 1
69240: PUSH
69241: LD_INT 1
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 0
69250: PUSH
69251: LD_INT 1
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 1
69260: NEG
69261: PUSH
69262: LD_INT 0
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 1
69271: NEG
69272: PUSH
69273: LD_INT 1
69275: NEG
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: LD_INT 1
69286: NEG
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 1
69294: NEG
69295: PUSH
69296: LD_INT 1
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69314: LD_ADDR_VAR 0 38
69318: PUSH
69319: LD_INT 0
69321: PUSH
69322: LD_INT 0
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 0
69331: PUSH
69332: LD_INT 1
69334: NEG
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 1
69342: PUSH
69343: LD_INT 0
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: LD_INT 1
69352: PUSH
69353: LD_INT 1
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 0
69362: PUSH
69363: LD_INT 1
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 1
69372: NEG
69373: PUSH
69374: LD_INT 0
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 1
69383: NEG
69384: PUSH
69385: LD_INT 1
69387: NEG
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 2
69395: PUSH
69396: LD_INT 1
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: LD_INT 2
69405: NEG
69406: PUSH
69407: LD_INT 1
69409: NEG
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69426: LD_ADDR_VAR 0 39
69430: PUSH
69431: LD_INT 0
69433: PUSH
69434: LD_INT 0
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 0
69443: PUSH
69444: LD_INT 1
69446: NEG
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 1
69454: PUSH
69455: LD_INT 0
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: LD_INT 1
69464: PUSH
69465: LD_INT 1
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 0
69474: PUSH
69475: LD_INT 1
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 1
69484: NEG
69485: PUSH
69486: LD_INT 0
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: LD_INT 1
69499: NEG
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 1
69507: NEG
69508: PUSH
69509: LD_INT 2
69511: NEG
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 1
69519: PUSH
69520: LD_INT 2
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: LIST
69533: LIST
69534: LIST
69535: LIST
69536: LIST
69537: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69538: LD_ADDR_VAR 0 40
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: LD_INT 0
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 0
69555: PUSH
69556: LD_INT 1
69558: NEG
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 1
69566: PUSH
69567: LD_INT 0
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 1
69576: PUSH
69577: LD_INT 1
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: LD_INT 0
69586: PUSH
69587: LD_INT 1
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: PUSH
69594: LD_INT 1
69596: NEG
69597: PUSH
69598: LD_INT 0
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: LD_INT 1
69611: NEG
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 1
69619: PUSH
69620: LD_INT 1
69622: NEG
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PUSH
69628: LD_INT 1
69630: NEG
69631: PUSH
69632: LD_INT 1
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69650: LD_ADDR_VAR 0 41
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: LD_INT 0
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 0
69667: PUSH
69668: LD_INT 1
69670: NEG
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 1
69678: PUSH
69679: LD_INT 0
69681: PUSH
69682: EMPTY
69683: LIST
69684: LIST
69685: PUSH
69686: LD_INT 1
69688: PUSH
69689: LD_INT 1
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PUSH
69696: LD_INT 0
69698: PUSH
69699: LD_INT 1
69701: PUSH
69702: EMPTY
69703: LIST
69704: LIST
69705: PUSH
69706: LD_INT 1
69708: NEG
69709: PUSH
69710: LD_INT 0
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: LD_INT 1
69719: NEG
69720: PUSH
69721: LD_INT 1
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 1
69731: NEG
69732: PUSH
69733: LD_INT 2
69735: NEG
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: LD_INT 1
69746: NEG
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 2
69754: PUSH
69755: LD_INT 0
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PUSH
69762: LD_INT 2
69764: PUSH
69765: LD_INT 1
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 2
69774: PUSH
69775: LD_INT 2
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: PUSH
69785: LD_INT 2
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 1
69794: NEG
69795: PUSH
69796: LD_INT 1
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 2
69805: NEG
69806: PUSH
69807: LD_INT 0
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 2
69816: NEG
69817: PUSH
69818: LD_INT 1
69820: NEG
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 2
69828: NEG
69829: PUSH
69830: LD_INT 2
69832: NEG
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 2
69840: NEG
69841: PUSH
69842: LD_INT 3
69844: NEG
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 2
69852: PUSH
69853: LD_INT 1
69855: NEG
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 3
69863: PUSH
69864: LD_INT 0
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 3
69873: PUSH
69874: LD_INT 1
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 3
69883: PUSH
69884: LD_INT 2
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 3
69893: PUSH
69894: LD_INT 3
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 2
69903: PUSH
69904: LD_INT 3
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 2
69913: NEG
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 3
69924: NEG
69925: PUSH
69926: LD_INT 0
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 3
69935: NEG
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 3
69947: NEG
69948: PUSH
69949: LD_INT 2
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 3
69959: NEG
69960: PUSH
69961: LD_INT 3
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: LIST
69999: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70000: LD_ADDR_VAR 0 42
70004: PUSH
70005: LD_INT 0
70007: PUSH
70008: LD_INT 0
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 0
70017: PUSH
70018: LD_INT 1
70020: NEG
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: LD_INT 0
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 1
70038: PUSH
70039: LD_INT 1
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 0
70048: PUSH
70049: LD_INT 1
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 1
70058: NEG
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 1
70069: NEG
70070: PUSH
70071: LD_INT 1
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 1
70081: NEG
70082: PUSH
70083: LD_INT 2
70085: NEG
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 0
70093: PUSH
70094: LD_INT 2
70096: NEG
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 1
70104: PUSH
70105: LD_INT 1
70107: NEG
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 2
70115: PUSH
70116: LD_INT 1
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PUSH
70123: LD_INT 2
70125: PUSH
70126: LD_INT 2
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PUSH
70133: LD_INT 1
70135: PUSH
70136: LD_INT 2
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 0
70145: PUSH
70146: LD_INT 2
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PUSH
70153: LD_INT 1
70155: NEG
70156: PUSH
70157: LD_INT 1
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: NEG
70167: PUSH
70168: LD_INT 1
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 2
70178: NEG
70179: PUSH
70180: LD_INT 2
70182: NEG
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 2
70190: NEG
70191: PUSH
70192: LD_INT 3
70194: NEG
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 1
70202: NEG
70203: PUSH
70204: LD_INT 3
70206: NEG
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 0
70214: PUSH
70215: LD_INT 3
70217: NEG
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 1
70225: PUSH
70226: LD_INT 2
70228: NEG
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 3
70236: PUSH
70237: LD_INT 2
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 3
70246: PUSH
70247: LD_INT 3
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: PUSH
70254: LD_INT 2
70256: PUSH
70257: LD_INT 3
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 1
70266: PUSH
70267: LD_INT 3
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 0
70276: PUSH
70277: LD_INT 3
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 1
70286: NEG
70287: PUSH
70288: LD_INT 2
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 3
70297: NEG
70298: PUSH
70299: LD_INT 2
70301: NEG
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: LD_INT 3
70309: NEG
70310: PUSH
70311: LD_INT 3
70313: NEG
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: LIST
70345: LIST
70346: LIST
70347: LIST
70348: LIST
70349: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70350: LD_ADDR_VAR 0 43
70354: PUSH
70355: LD_INT 0
70357: PUSH
70358: LD_INT 0
70360: PUSH
70361: EMPTY
70362: LIST
70363: LIST
70364: PUSH
70365: LD_INT 0
70367: PUSH
70368: LD_INT 1
70370: NEG
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 1
70378: PUSH
70379: LD_INT 0
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 1
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 0
70398: PUSH
70399: LD_INT 1
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: LD_INT 0
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 1
70423: NEG
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 1
70431: NEG
70432: PUSH
70433: LD_INT 2
70435: NEG
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: PUSH
70441: LD_INT 0
70443: PUSH
70444: LD_INT 2
70446: NEG
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: LD_INT 1
70454: PUSH
70455: LD_INT 1
70457: NEG
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: LD_INT 2
70465: PUSH
70466: LD_INT 0
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: LD_INT 2
70475: PUSH
70476: LD_INT 1
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 1
70485: PUSH
70486: LD_INT 2
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: LD_INT 2
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: LD_INT 1
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 2
70516: NEG
70517: PUSH
70518: LD_INT 0
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 2
70527: NEG
70528: PUSH
70529: LD_INT 1
70531: NEG
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 1
70539: NEG
70540: PUSH
70541: LD_INT 3
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: LD_INT 3
70554: NEG
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 1
70562: PUSH
70563: LD_INT 2
70565: NEG
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: LD_INT 2
70573: PUSH
70574: LD_INT 1
70576: NEG
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 3
70584: PUSH
70585: LD_INT 0
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: LD_INT 3
70594: PUSH
70595: LD_INT 1
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 1
70604: PUSH
70605: LD_INT 3
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: PUSH
70612: LD_INT 0
70614: PUSH
70615: LD_INT 3
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 1
70624: NEG
70625: PUSH
70626: LD_INT 2
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 2
70635: NEG
70636: PUSH
70637: LD_INT 1
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 3
70646: NEG
70647: PUSH
70648: LD_INT 0
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 3
70657: NEG
70658: PUSH
70659: LD_INT 1
70661: NEG
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70698: LD_ADDR_VAR 0 44
70702: PUSH
70703: LD_INT 0
70705: PUSH
70706: LD_INT 0
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: PUSH
70713: LD_INT 0
70715: PUSH
70716: LD_INT 1
70718: NEG
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 1
70726: PUSH
70727: LD_INT 0
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 1
70736: PUSH
70737: LD_INT 1
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: LD_INT 1
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: LD_INT 0
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 1
70767: NEG
70768: PUSH
70769: LD_INT 1
70771: NEG
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 1
70779: NEG
70780: PUSH
70781: LD_INT 2
70783: NEG
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: LD_INT 1
70791: PUSH
70792: LD_INT 1
70794: NEG
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 2
70802: PUSH
70803: LD_INT 0
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 2
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 2
70822: PUSH
70823: LD_INT 2
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: LD_INT 2
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 1
70842: NEG
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 2
70853: NEG
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 2
70864: NEG
70865: PUSH
70866: LD_INT 1
70868: NEG
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 2
70876: NEG
70877: PUSH
70878: LD_INT 2
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: NEG
70889: PUSH
70890: LD_INT 3
70892: NEG
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 2
70900: PUSH
70901: LD_INT 1
70903: NEG
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: LD_INT 3
70911: PUSH
70912: LD_INT 0
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 3
70921: PUSH
70922: LD_INT 1
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: LD_INT 3
70931: PUSH
70932: LD_INT 2
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 3
70941: PUSH
70942: LD_INT 3
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: PUSH
70949: LD_INT 2
70951: PUSH
70952: LD_INT 3
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 2
70961: NEG
70962: PUSH
70963: LD_INT 1
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 3
70972: NEG
70973: PUSH
70974: LD_INT 0
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 3
70983: NEG
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 3
70995: NEG
70996: PUSH
70997: LD_INT 2
70999: NEG
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 3
71007: NEG
71008: PUSH
71009: LD_INT 3
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71048: LD_ADDR_VAR 0 45
71052: PUSH
71053: LD_INT 0
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 0
71065: PUSH
71066: LD_INT 1
71068: NEG
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: PUSH
71074: LD_INT 1
71076: PUSH
71077: LD_INT 0
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: PUSH
71084: LD_INT 1
71086: PUSH
71087: LD_INT 1
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: PUSH
71094: LD_INT 0
71096: PUSH
71097: LD_INT 1
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 1
71106: NEG
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: LD_INT 1
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 1
71129: NEG
71130: PUSH
71131: LD_INT 2
71133: NEG
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 0
71141: PUSH
71142: LD_INT 2
71144: NEG
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 1
71152: PUSH
71153: LD_INT 1
71155: NEG
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: LD_INT 2
71163: PUSH
71164: LD_INT 1
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 2
71173: PUSH
71174: LD_INT 2
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 1
71183: PUSH
71184: LD_INT 2
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 0
71193: PUSH
71194: LD_INT 2
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: PUSH
71201: LD_INT 1
71203: NEG
71204: PUSH
71205: LD_INT 1
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 2
71214: NEG
71215: PUSH
71216: LD_INT 1
71218: NEG
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 2
71226: NEG
71227: PUSH
71228: LD_INT 2
71230: NEG
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 2
71238: NEG
71239: PUSH
71240: LD_INT 3
71242: NEG
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 1
71250: NEG
71251: PUSH
71252: LD_INT 3
71254: NEG
71255: PUSH
71256: EMPTY
71257: LIST
71258: LIST
71259: PUSH
71260: LD_INT 0
71262: PUSH
71263: LD_INT 3
71265: NEG
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 1
71273: PUSH
71274: LD_INT 2
71276: NEG
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 3
71284: PUSH
71285: LD_INT 2
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 3
71294: PUSH
71295: LD_INT 3
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 2
71304: PUSH
71305: LD_INT 3
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 1
71314: PUSH
71315: LD_INT 3
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: LD_INT 0
71324: PUSH
71325: LD_INT 3
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 1
71334: NEG
71335: PUSH
71336: LD_INT 2
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 3
71345: NEG
71346: PUSH
71347: LD_INT 2
71349: NEG
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 3
71357: NEG
71358: PUSH
71359: LD_INT 3
71361: NEG
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71398: LD_ADDR_VAR 0 46
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 0
71415: PUSH
71416: LD_INT 1
71418: NEG
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 1
71426: PUSH
71427: LD_INT 0
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 1
71436: PUSH
71437: LD_INT 1
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 0
71446: PUSH
71447: LD_INT 1
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: NEG
71457: PUSH
71458: LD_INT 0
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: NEG
71468: PUSH
71469: LD_INT 1
71471: NEG
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 1
71479: NEG
71480: PUSH
71481: LD_INT 2
71483: NEG
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: LD_INT 0
71491: PUSH
71492: LD_INT 2
71494: NEG
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 1
71502: PUSH
71503: LD_INT 1
71505: NEG
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 2
71513: PUSH
71514: LD_INT 0
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 2
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 1
71533: PUSH
71534: LD_INT 2
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 0
71543: PUSH
71544: LD_INT 2
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 1
71553: NEG
71554: PUSH
71555: LD_INT 1
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: PUSH
71562: LD_INT 2
71564: NEG
71565: PUSH
71566: LD_INT 0
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 2
71575: NEG
71576: PUSH
71577: LD_INT 1
71579: NEG
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 1
71587: NEG
71588: PUSH
71589: LD_INT 3
71591: NEG
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 0
71599: PUSH
71600: LD_INT 3
71602: NEG
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 1
71610: PUSH
71611: LD_INT 2
71613: NEG
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: LD_INT 2
71621: PUSH
71622: LD_INT 1
71624: NEG
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 3
71632: PUSH
71633: LD_INT 0
71635: PUSH
71636: EMPTY
71637: LIST
71638: LIST
71639: PUSH
71640: LD_INT 3
71642: PUSH
71643: LD_INT 1
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: LD_INT 3
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 0
71662: PUSH
71663: LD_INT 3
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 1
71672: NEG
71673: PUSH
71674: LD_INT 2
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 2
71683: NEG
71684: PUSH
71685: LD_INT 1
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 3
71694: NEG
71695: PUSH
71696: LD_INT 0
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 3
71705: NEG
71706: PUSH
71707: LD_INT 1
71709: NEG
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: LIST
71737: LIST
71738: LIST
71739: LIST
71740: LIST
71741: LIST
71742: LIST
71743: LIST
71744: LIST
71745: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71746: LD_ADDR_VAR 0 47
71750: PUSH
71751: LD_INT 0
71753: PUSH
71754: LD_INT 0
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 0
71763: PUSH
71764: LD_INT 1
71766: NEG
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 1
71774: PUSH
71775: LD_INT 0
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 1
71784: PUSH
71785: LD_INT 1
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: LD_INT 0
71794: PUSH
71795: LD_INT 1
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 1
71804: NEG
71805: PUSH
71806: LD_INT 0
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 1
71815: NEG
71816: PUSH
71817: LD_INT 1
71819: NEG
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 1
71827: NEG
71828: PUSH
71829: LD_INT 2
71831: NEG
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: LD_INT 0
71839: PUSH
71840: LD_INT 2
71842: NEG
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: PUSH
71851: LD_INT 1
71853: NEG
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 2
71861: NEG
71862: PUSH
71863: LD_INT 1
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 2
71873: NEG
71874: PUSH
71875: LD_INT 2
71877: NEG
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: LIST
71887: LIST
71888: LIST
71889: LIST
71890: LIST
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71897: LD_ADDR_VAR 0 48
71901: PUSH
71902: LD_INT 0
71904: PUSH
71905: LD_INT 0
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 0
71914: PUSH
71915: LD_INT 1
71917: NEG
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 1
71925: PUSH
71926: LD_INT 0
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 1
71935: PUSH
71936: LD_INT 1
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 0
71945: PUSH
71946: LD_INT 1
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: LD_INT 1
71955: NEG
71956: PUSH
71957: LD_INT 0
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 1
71966: NEG
71967: PUSH
71968: LD_INT 1
71970: NEG
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 1
71978: NEG
71979: PUSH
71980: LD_INT 2
71982: NEG
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 0
71990: PUSH
71991: LD_INT 2
71993: NEG
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: LD_INT 1
72001: PUSH
72002: LD_INT 1
72004: NEG
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 2
72012: PUSH
72013: LD_INT 0
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 2
72022: PUSH
72023: LD_INT 1
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: LIST
72043: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72044: LD_ADDR_VAR 0 49
72048: PUSH
72049: LD_INT 0
72051: PUSH
72052: LD_INT 0
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: LD_INT 0
72061: PUSH
72062: LD_INT 1
72064: NEG
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 1
72072: PUSH
72073: LD_INT 0
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 1
72082: PUSH
72083: LD_INT 1
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: PUSH
72090: LD_INT 0
72092: PUSH
72093: LD_INT 1
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 1
72102: NEG
72103: PUSH
72104: LD_INT 0
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: NEG
72114: PUSH
72115: LD_INT 1
72117: NEG
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: PUSH
72123: LD_INT 1
72125: PUSH
72126: LD_INT 1
72128: NEG
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 2
72136: PUSH
72137: LD_INT 0
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PUSH
72144: LD_INT 2
72146: PUSH
72147: LD_INT 1
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 2
72156: PUSH
72157: LD_INT 2
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 1
72166: PUSH
72167: LD_INT 2
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72188: LD_ADDR_VAR 0 50
72192: PUSH
72193: LD_INT 0
72195: PUSH
72196: LD_INT 0
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: LD_INT 1
72208: NEG
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: LD_INT 1
72216: PUSH
72217: LD_INT 0
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 1
72226: PUSH
72227: LD_INT 1
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: LD_INT 0
72236: PUSH
72237: LD_INT 1
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 1
72246: NEG
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 1
72257: NEG
72258: PUSH
72259: LD_INT 1
72261: NEG
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 2
72269: PUSH
72270: LD_INT 1
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 2
72279: PUSH
72280: LD_INT 2
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 1
72289: PUSH
72290: LD_INT 2
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 0
72299: PUSH
72300: LD_INT 2
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: LD_INT 1
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72332: LD_ADDR_VAR 0 51
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: LD_INT 0
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 0
72349: PUSH
72350: LD_INT 1
72352: NEG
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 1
72360: PUSH
72361: LD_INT 0
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 1
72370: PUSH
72371: LD_INT 1
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 0
72380: PUSH
72381: LD_INT 1
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 1
72390: NEG
72391: PUSH
72392: LD_INT 0
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: NEG
72402: PUSH
72403: LD_INT 1
72405: NEG
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PUSH
72411: LD_INT 1
72413: PUSH
72414: LD_INT 2
72416: PUSH
72417: EMPTY
72418: LIST
72419: LIST
72420: PUSH
72421: LD_INT 0
72423: PUSH
72424: LD_INT 2
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PUSH
72431: LD_INT 1
72433: NEG
72434: PUSH
72435: LD_INT 1
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PUSH
72442: LD_INT 2
72444: NEG
72445: PUSH
72446: LD_INT 0
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: PUSH
72453: LD_INT 2
72455: NEG
72456: PUSH
72457: LD_INT 1
72459: NEG
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72479: LD_ADDR_VAR 0 52
72483: PUSH
72484: LD_INT 0
72486: PUSH
72487: LD_INT 0
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: PUSH
72494: LD_INT 0
72496: PUSH
72497: LD_INT 1
72499: NEG
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 1
72507: PUSH
72508: LD_INT 0
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 1
72517: PUSH
72518: LD_INT 1
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 0
72527: PUSH
72528: LD_INT 1
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PUSH
72535: LD_INT 1
72537: NEG
72538: PUSH
72539: LD_INT 0
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: LD_INT 1
72552: NEG
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 1
72560: NEG
72561: PUSH
72562: LD_INT 2
72564: NEG
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 1
72572: NEG
72573: PUSH
72574: LD_INT 1
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 2
72583: NEG
72584: PUSH
72585: LD_INT 0
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: LD_INT 1
72598: NEG
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 2
72606: NEG
72607: PUSH
72608: LD_INT 2
72610: NEG
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72630: LD_ADDR_VAR 0 53
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: LD_INT 0
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 0
72647: PUSH
72648: LD_INT 1
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 1
72658: PUSH
72659: LD_INT 0
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 1
72668: PUSH
72669: LD_INT 1
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 0
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 1
72688: NEG
72689: PUSH
72690: LD_INT 0
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: LD_INT 1
72703: NEG
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 1
72711: NEG
72712: PUSH
72713: LD_INT 2
72715: NEG
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 0
72723: PUSH
72724: LD_INT 2
72726: NEG
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 1
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 2
72745: PUSH
72746: LD_INT 0
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 2
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 2
72765: PUSH
72766: LD_INT 2
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: LD_INT 2
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 0
72785: PUSH
72786: LD_INT 2
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 1
72795: NEG
72796: PUSH
72797: LD_INT 1
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 2
72806: NEG
72807: PUSH
72808: LD_INT 0
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 2
72817: NEG
72818: PUSH
72819: LD_INT 1
72821: NEG
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 2
72829: NEG
72830: PUSH
72831: LD_INT 2
72833: NEG
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: LIST
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72860: LD_ADDR_VAR 0 54
72864: PUSH
72865: LD_INT 0
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: LD_INT 1
72880: NEG
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 1
72888: PUSH
72889: LD_INT 0
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 0
72908: PUSH
72909: LD_INT 1
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: NEG
72919: PUSH
72920: LD_INT 0
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: LD_INT 1
72933: NEG
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 1
72941: NEG
72942: PUSH
72943: LD_INT 2
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 0
72953: PUSH
72954: LD_INT 2
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: LD_INT 1
72967: NEG
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 2
72975: PUSH
72976: LD_INT 0
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 2
72985: PUSH
72986: LD_INT 1
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 2
72995: PUSH
72996: LD_INT 2
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 1
73005: PUSH
73006: LD_INT 2
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 0
73015: PUSH
73016: LD_INT 2
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 1
73025: NEG
73026: PUSH
73027: LD_INT 1
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 2
73036: NEG
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 2
73047: NEG
73048: PUSH
73049: LD_INT 1
73051: NEG
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 2
73059: NEG
73060: PUSH
73061: LD_INT 2
73063: NEG
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73090: LD_ADDR_VAR 0 55
73094: PUSH
73095: LD_INT 0
73097: PUSH
73098: LD_INT 0
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 0
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 1
73118: PUSH
73119: LD_INT 0
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 1
73128: PUSH
73129: LD_INT 1
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 0
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 1
73148: NEG
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: LD_INT 1
73163: NEG
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 1
73171: NEG
73172: PUSH
73173: LD_INT 2
73175: NEG
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 0
73183: PUSH
73184: LD_INT 2
73186: NEG
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 1
73194: PUSH
73195: LD_INT 1
73197: NEG
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 2
73205: PUSH
73206: LD_INT 0
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: LD_INT 2
73215: PUSH
73216: LD_INT 1
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 2
73225: PUSH
73226: LD_INT 2
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 1
73235: PUSH
73236: LD_INT 2
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 0
73245: PUSH
73246: LD_INT 2
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 2
73266: NEG
73267: PUSH
73268: LD_INT 0
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: NEG
73278: PUSH
73279: LD_INT 1
73281: NEG
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PUSH
73287: LD_INT 2
73289: NEG
73290: PUSH
73291: LD_INT 2
73293: NEG
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: EMPTY
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: LIST
73314: LIST
73315: LIST
73316: LIST
73317: LIST
73318: LIST
73319: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73320: LD_ADDR_VAR 0 56
73324: PUSH
73325: LD_INT 0
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 0
73337: PUSH
73338: LD_INT 1
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 1
73348: PUSH
73349: LD_INT 0
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 1
73358: PUSH
73359: LD_INT 1
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 0
73368: PUSH
73369: LD_INT 1
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 1
73378: NEG
73379: PUSH
73380: LD_INT 0
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 1
73389: NEG
73390: PUSH
73391: LD_INT 1
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 1
73401: NEG
73402: PUSH
73403: LD_INT 2
73405: NEG
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 0
73413: PUSH
73414: LD_INT 2
73416: NEG
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: LD_INT 1
73427: NEG
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: LD_INT 0
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 2
73445: PUSH
73446: LD_INT 1
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 2
73455: PUSH
73456: LD_INT 2
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: PUSH
73466: LD_INT 2
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 0
73475: PUSH
73476: LD_INT 2
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 1
73485: NEG
73486: PUSH
73487: LD_INT 1
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: LD_INT 2
73496: NEG
73497: PUSH
73498: LD_INT 0
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 2
73507: NEG
73508: PUSH
73509: LD_INT 1
73511: NEG
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 2
73519: NEG
73520: PUSH
73521: LD_INT 2
73523: NEG
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73550: LD_ADDR_VAR 0 57
73554: PUSH
73555: LD_INT 0
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 0
73567: PUSH
73568: LD_INT 1
73570: NEG
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 1
73578: PUSH
73579: LD_INT 0
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: LD_INT 1
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 0
73598: PUSH
73599: LD_INT 1
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 1
73608: NEG
73609: PUSH
73610: LD_INT 0
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: LD_INT 1
73623: NEG
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 1
73631: NEG
73632: PUSH
73633: LD_INT 2
73635: NEG
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 0
73643: PUSH
73644: LD_INT 2
73646: NEG
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 1
73654: PUSH
73655: LD_INT 1
73657: NEG
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: LD_INT 2
73665: PUSH
73666: LD_INT 0
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 2
73675: PUSH
73676: LD_INT 1
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: PUSH
73683: LD_INT 2
73685: PUSH
73686: LD_INT 2
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: LD_INT 2
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 0
73705: PUSH
73706: LD_INT 2
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 1
73715: NEG
73716: PUSH
73717: LD_INT 1
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 2
73726: NEG
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 2
73737: NEG
73738: PUSH
73739: LD_INT 1
73741: NEG
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 2
73749: NEG
73750: PUSH
73751: LD_INT 2
73753: NEG
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: LIST
73779: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73780: LD_ADDR_VAR 0 58
73784: PUSH
73785: LD_INT 0
73787: PUSH
73788: LD_INT 0
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: PUSH
73795: LD_INT 0
73797: PUSH
73798: LD_INT 1
73800: NEG
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: PUSH
73809: LD_INT 0
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 0
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 1
73838: NEG
73839: PUSH
73840: LD_INT 0
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 1
73849: NEG
73850: PUSH
73851: LD_INT 1
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 1
73861: NEG
73862: PUSH
73863: LD_INT 2
73865: NEG
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 0
73873: PUSH
73874: LD_INT 2
73876: NEG
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 2
73895: PUSH
73896: LD_INT 0
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 2
73905: PUSH
73906: LD_INT 1
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 2
73915: PUSH
73916: LD_INT 2
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 1
73925: PUSH
73926: LD_INT 2
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 0
73935: PUSH
73936: LD_INT 2
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 1
73945: NEG
73946: PUSH
73947: LD_INT 1
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 2
73956: NEG
73957: PUSH
73958: LD_INT 0
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 2
73967: NEG
73968: PUSH
73969: LD_INT 1
73971: NEG
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 2
73979: NEG
73980: PUSH
73981: LD_INT 2
73983: NEG
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74010: LD_ADDR_VAR 0 59
74014: PUSH
74015: LD_INT 0
74017: PUSH
74018: LD_INT 0
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: LD_INT 0
74027: PUSH
74028: LD_INT 1
74030: NEG
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 1
74038: PUSH
74039: LD_INT 0
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 1
74048: PUSH
74049: LD_INT 1
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 0
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 1
74068: NEG
74069: PUSH
74070: LD_INT 0
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: LD_INT 1
74079: NEG
74080: PUSH
74081: LD_INT 1
74083: NEG
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: LIST
74093: LIST
74094: LIST
74095: LIST
74096: LIST
74097: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74098: LD_ADDR_VAR 0 60
74102: PUSH
74103: LD_INT 0
74105: PUSH
74106: LD_INT 0
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 0
74115: PUSH
74116: LD_INT 1
74118: NEG
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: PUSH
74124: LD_INT 1
74126: PUSH
74127: LD_INT 0
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 1
74136: PUSH
74137: LD_INT 1
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 0
74146: PUSH
74147: LD_INT 1
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 1
74156: NEG
74157: PUSH
74158: LD_INT 0
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 1
74167: NEG
74168: PUSH
74169: LD_INT 1
74171: NEG
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: LIST
74185: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74186: LD_ADDR_VAR 0 61
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: LD_INT 0
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: LD_INT 1
74206: NEG
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 1
74214: PUSH
74215: LD_INT 0
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: LD_INT 1
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 0
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 1
74244: NEG
74245: PUSH
74246: LD_INT 0
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 1
74255: NEG
74256: PUSH
74257: LD_INT 1
74259: NEG
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74274: LD_ADDR_VAR 0 62
74278: PUSH
74279: LD_INT 0
74281: PUSH
74282: LD_INT 0
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: PUSH
74289: LD_INT 0
74291: PUSH
74292: LD_INT 1
74294: NEG
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 1
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 1
74312: PUSH
74313: LD_INT 1
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: LD_INT 1
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PUSH
74330: LD_INT 1
74332: NEG
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 1
74343: NEG
74344: PUSH
74345: LD_INT 1
74347: NEG
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: LIST
74361: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74362: LD_ADDR_VAR 0 63
74366: PUSH
74367: LD_INT 0
74369: PUSH
74370: LD_INT 0
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: LD_INT 0
74379: PUSH
74380: LD_INT 1
74382: NEG
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: LD_INT 1
74390: PUSH
74391: LD_INT 0
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 1
74400: PUSH
74401: LD_INT 1
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 0
74410: PUSH
74411: LD_INT 1
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 1
74420: NEG
74421: PUSH
74422: LD_INT 0
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 1
74431: NEG
74432: PUSH
74433: LD_INT 1
74435: NEG
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: LIST
74448: LIST
74449: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74450: LD_ADDR_VAR 0 64
74454: PUSH
74455: LD_INT 0
74457: PUSH
74458: LD_INT 0
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 0
74467: PUSH
74468: LD_INT 1
74470: NEG
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 1
74478: PUSH
74479: LD_INT 0
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 1
74488: PUSH
74489: LD_INT 1
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 0
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 1
74508: NEG
74509: PUSH
74510: LD_INT 0
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: LD_INT 1
74523: NEG
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: LIST
74533: LIST
74534: LIST
74535: LIST
74536: LIST
74537: ST_TO_ADDR
// end ; 1 :
74538: GO 80435
74540: LD_INT 1
74542: DOUBLE
74543: EQUAL
74544: IFTRUE 74548
74546: GO 77171
74548: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74549: LD_ADDR_VAR 0 11
74553: PUSH
74554: LD_INT 1
74556: NEG
74557: PUSH
74558: LD_INT 3
74560: NEG
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 0
74568: PUSH
74569: LD_INT 3
74571: NEG
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 1
74579: PUSH
74580: LD_INT 2
74582: NEG
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: LIST
74592: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74593: LD_ADDR_VAR 0 12
74597: PUSH
74598: LD_INT 2
74600: PUSH
74601: LD_INT 1
74603: NEG
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: PUSH
74609: LD_INT 3
74611: PUSH
74612: LD_INT 0
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: LD_INT 3
74621: PUSH
74622: LD_INT 1
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: LIST
74633: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74634: LD_ADDR_VAR 0 13
74638: PUSH
74639: LD_INT 3
74641: PUSH
74642: LD_INT 2
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 3
74651: PUSH
74652: LD_INT 3
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PUSH
74659: LD_INT 2
74661: PUSH
74662: LD_INT 3
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: LIST
74673: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74674: LD_ADDR_VAR 0 14
74678: PUSH
74679: LD_INT 1
74681: PUSH
74682: LD_INT 3
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 0
74691: PUSH
74692: LD_INT 3
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 1
74701: NEG
74702: PUSH
74703: LD_INT 2
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: LIST
74714: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74715: LD_ADDR_VAR 0 15
74719: PUSH
74720: LD_INT 2
74722: NEG
74723: PUSH
74724: LD_INT 1
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 3
74733: NEG
74734: PUSH
74735: LD_INT 0
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: LD_INT 3
74744: NEG
74745: PUSH
74746: LD_INT 1
74748: NEG
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: LIST
74758: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74759: LD_ADDR_VAR 0 16
74763: PUSH
74764: LD_INT 2
74766: NEG
74767: PUSH
74768: LD_INT 3
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 3
74778: NEG
74779: PUSH
74780: LD_INT 2
74782: NEG
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: LD_INT 3
74790: NEG
74791: PUSH
74792: LD_INT 3
74794: NEG
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: LIST
74804: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74805: LD_ADDR_VAR 0 17
74809: PUSH
74810: LD_INT 1
74812: NEG
74813: PUSH
74814: LD_INT 3
74816: NEG
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 0
74824: PUSH
74825: LD_INT 3
74827: NEG
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 1
74835: PUSH
74836: LD_INT 2
74838: NEG
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: LIST
74848: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74849: LD_ADDR_VAR 0 18
74853: PUSH
74854: LD_INT 2
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 3
74867: PUSH
74868: LD_INT 0
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 3
74877: PUSH
74878: LD_INT 1
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: LIST
74889: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74890: LD_ADDR_VAR 0 19
74894: PUSH
74895: LD_INT 3
74897: PUSH
74898: LD_INT 2
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 3
74907: PUSH
74908: LD_INT 3
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: LD_INT 2
74917: PUSH
74918: LD_INT 3
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: LIST
74929: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74930: LD_ADDR_VAR 0 20
74934: PUSH
74935: LD_INT 1
74937: PUSH
74938: LD_INT 3
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 0
74947: PUSH
74948: LD_INT 3
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 1
74957: NEG
74958: PUSH
74959: LD_INT 2
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: LIST
74970: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74971: LD_ADDR_VAR 0 21
74975: PUSH
74976: LD_INT 2
74978: NEG
74979: PUSH
74980: LD_INT 1
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 3
74989: NEG
74990: PUSH
74991: LD_INT 0
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: LD_INT 3
75000: NEG
75001: PUSH
75002: LD_INT 1
75004: NEG
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: LIST
75014: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75015: LD_ADDR_VAR 0 22
75019: PUSH
75020: LD_INT 2
75022: NEG
75023: PUSH
75024: LD_INT 3
75026: NEG
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 3
75034: NEG
75035: PUSH
75036: LD_INT 2
75038: NEG
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: PUSH
75044: LD_INT 3
75046: NEG
75047: PUSH
75048: LD_INT 3
75050: NEG
75051: PUSH
75052: EMPTY
75053: LIST
75054: LIST
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: LIST
75060: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75061: LD_ADDR_VAR 0 23
75065: PUSH
75066: LD_INT 0
75068: PUSH
75069: LD_INT 3
75071: NEG
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 1
75079: NEG
75080: PUSH
75081: LD_INT 4
75083: NEG
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PUSH
75089: LD_INT 1
75091: PUSH
75092: LD_INT 3
75094: NEG
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: LIST
75104: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75105: LD_ADDR_VAR 0 24
75109: PUSH
75110: LD_INT 3
75112: PUSH
75113: LD_INT 0
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 3
75122: PUSH
75123: LD_INT 1
75125: NEG
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 4
75133: PUSH
75134: LD_INT 1
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: LIST
75145: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75146: LD_ADDR_VAR 0 25
75150: PUSH
75151: LD_INT 3
75153: PUSH
75154: LD_INT 3
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 4
75163: PUSH
75164: LD_INT 3
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 3
75173: PUSH
75174: LD_INT 4
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: LIST
75185: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75186: LD_ADDR_VAR 0 26
75190: PUSH
75191: LD_INT 0
75193: PUSH
75194: LD_INT 3
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: LD_INT 1
75203: PUSH
75204: LD_INT 4
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 1
75213: NEG
75214: PUSH
75215: LD_INT 3
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: LIST
75226: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75227: LD_ADDR_VAR 0 27
75231: PUSH
75232: LD_INT 3
75234: NEG
75235: PUSH
75236: LD_INT 0
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 3
75245: NEG
75246: PUSH
75247: LD_INT 1
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 4
75256: NEG
75257: PUSH
75258: LD_INT 1
75260: NEG
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: LIST
75270: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75271: LD_ADDR_VAR 0 28
75275: PUSH
75276: LD_INT 3
75278: NEG
75279: PUSH
75280: LD_INT 3
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 3
75290: NEG
75291: PUSH
75292: LD_INT 4
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 4
75302: NEG
75303: PUSH
75304: LD_INT 3
75306: NEG
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: LIST
75316: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75317: LD_ADDR_VAR 0 29
75321: PUSH
75322: LD_INT 1
75324: NEG
75325: PUSH
75326: LD_INT 3
75328: NEG
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 0
75336: PUSH
75337: LD_INT 3
75339: NEG
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: LD_INT 2
75350: NEG
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 1
75358: NEG
75359: PUSH
75360: LD_INT 4
75362: NEG
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 0
75370: PUSH
75371: LD_INT 4
75373: NEG
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 1
75381: PUSH
75382: LD_INT 3
75384: NEG
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 1
75392: NEG
75393: PUSH
75394: LD_INT 5
75396: NEG
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 0
75404: PUSH
75405: LD_INT 5
75407: NEG
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 1
75415: PUSH
75416: LD_INT 4
75418: NEG
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 1
75426: NEG
75427: PUSH
75428: LD_INT 6
75430: NEG
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: LD_INT 6
75441: NEG
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 1
75449: PUSH
75450: LD_INT 5
75452: NEG
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75472: LD_ADDR_VAR 0 30
75476: PUSH
75477: LD_INT 2
75479: PUSH
75480: LD_INT 1
75482: NEG
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 3
75490: PUSH
75491: LD_INT 0
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 3
75500: PUSH
75501: LD_INT 1
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: PUSH
75508: LD_INT 3
75510: PUSH
75511: LD_INT 1
75513: NEG
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 4
75521: PUSH
75522: LD_INT 0
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 4
75531: PUSH
75532: LD_INT 1
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 4
75541: PUSH
75542: LD_INT 1
75544: NEG
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 5
75552: PUSH
75553: LD_INT 0
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 5
75562: PUSH
75563: LD_INT 1
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 5
75572: PUSH
75573: LD_INT 1
75575: NEG
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 6
75583: PUSH
75584: LD_INT 0
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 6
75593: PUSH
75594: LD_INT 1
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75615: LD_ADDR_VAR 0 31
75619: PUSH
75620: LD_INT 3
75622: PUSH
75623: LD_INT 2
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 3
75632: PUSH
75633: LD_INT 3
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 2
75642: PUSH
75643: LD_INT 3
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: PUSH
75650: LD_INT 4
75652: PUSH
75653: LD_INT 3
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 4
75662: PUSH
75663: LD_INT 4
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 3
75672: PUSH
75673: LD_INT 4
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 5
75682: PUSH
75683: LD_INT 4
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 5
75692: PUSH
75693: LD_INT 5
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 4
75702: PUSH
75703: LD_INT 5
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 6
75712: PUSH
75713: LD_INT 5
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: LD_INT 6
75722: PUSH
75723: LD_INT 6
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 5
75732: PUSH
75733: LD_INT 6
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: EMPTY
75741: LIST
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75754: LD_ADDR_VAR 0 32
75758: PUSH
75759: LD_INT 1
75761: PUSH
75762: LD_INT 3
75764: PUSH
75765: EMPTY
75766: LIST
75767: LIST
75768: PUSH
75769: LD_INT 0
75771: PUSH
75772: LD_INT 3
75774: PUSH
75775: EMPTY
75776: LIST
75777: LIST
75778: PUSH
75779: LD_INT 1
75781: NEG
75782: PUSH
75783: LD_INT 2
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 1
75792: PUSH
75793: LD_INT 4
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: LD_INT 0
75802: PUSH
75803: LD_INT 4
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 1
75812: NEG
75813: PUSH
75814: LD_INT 3
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 1
75823: PUSH
75824: LD_INT 5
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: LD_INT 0
75833: PUSH
75834: LD_INT 5
75836: PUSH
75837: EMPTY
75838: LIST
75839: LIST
75840: PUSH
75841: LD_INT 1
75843: NEG
75844: PUSH
75845: LD_INT 4
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 1
75854: PUSH
75855: LD_INT 6
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: LD_INT 6
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 1
75874: NEG
75875: PUSH
75876: LD_INT 5
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: LIST
75887: LIST
75888: LIST
75889: LIST
75890: LIST
75891: LIST
75892: LIST
75893: LIST
75894: LIST
75895: LIST
75896: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75897: LD_ADDR_VAR 0 33
75901: PUSH
75902: LD_INT 2
75904: NEG
75905: PUSH
75906: LD_INT 1
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: LD_INT 3
75915: NEG
75916: PUSH
75917: LD_INT 0
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 3
75926: NEG
75927: PUSH
75928: LD_INT 1
75930: NEG
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: LD_INT 3
75938: NEG
75939: PUSH
75940: LD_INT 1
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 4
75949: NEG
75950: PUSH
75951: LD_INT 0
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 4
75960: NEG
75961: PUSH
75962: LD_INT 1
75964: NEG
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 4
75972: NEG
75973: PUSH
75974: LD_INT 1
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 5
75983: NEG
75984: PUSH
75985: LD_INT 0
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 5
75994: NEG
75995: PUSH
75996: LD_INT 1
75998: NEG
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: PUSH
76004: LD_INT 5
76006: NEG
76007: PUSH
76008: LD_INT 1
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 6
76017: NEG
76018: PUSH
76019: LD_INT 0
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 6
76028: NEG
76029: PUSH
76030: LD_INT 1
76032: NEG
76033: PUSH
76034: EMPTY
76035: LIST
76036: LIST
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: LIST
76042: LIST
76043: LIST
76044: LIST
76045: LIST
76046: LIST
76047: LIST
76048: LIST
76049: LIST
76050: LIST
76051: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76052: LD_ADDR_VAR 0 34
76056: PUSH
76057: LD_INT 2
76059: NEG
76060: PUSH
76061: LD_INT 3
76063: NEG
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 3
76071: NEG
76072: PUSH
76073: LD_INT 2
76075: NEG
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: LD_INT 3
76083: NEG
76084: PUSH
76085: LD_INT 3
76087: NEG
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 3
76095: NEG
76096: PUSH
76097: LD_INT 4
76099: NEG
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 4
76107: NEG
76108: PUSH
76109: LD_INT 3
76111: NEG
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 4
76119: NEG
76120: PUSH
76121: LD_INT 4
76123: NEG
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: LD_INT 4
76131: NEG
76132: PUSH
76133: LD_INT 5
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 5
76143: NEG
76144: PUSH
76145: LD_INT 4
76147: NEG
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 5
76155: NEG
76156: PUSH
76157: LD_INT 5
76159: NEG
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 5
76167: NEG
76168: PUSH
76169: LD_INT 6
76171: NEG
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 6
76179: NEG
76180: PUSH
76181: LD_INT 5
76183: NEG
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: PUSH
76189: LD_INT 6
76191: NEG
76192: PUSH
76193: LD_INT 6
76195: NEG
76196: PUSH
76197: EMPTY
76198: LIST
76199: LIST
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76215: LD_ADDR_VAR 0 41
76219: PUSH
76220: LD_INT 0
76222: PUSH
76223: LD_INT 2
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 1
76233: NEG
76234: PUSH
76235: LD_INT 3
76237: NEG
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PUSH
76243: LD_INT 1
76245: PUSH
76246: LD_INT 2
76248: NEG
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: LIST
76258: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76259: LD_ADDR_VAR 0 42
76263: PUSH
76264: LD_INT 2
76266: PUSH
76267: LD_INT 0
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 2
76276: PUSH
76277: LD_INT 1
76279: NEG
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 3
76287: PUSH
76288: LD_INT 1
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: LIST
76299: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76300: LD_ADDR_VAR 0 43
76304: PUSH
76305: LD_INT 2
76307: PUSH
76308: LD_INT 2
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: PUSH
76315: LD_INT 3
76317: PUSH
76318: LD_INT 2
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 2
76327: PUSH
76328: LD_INT 3
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: LIST
76339: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76340: LD_ADDR_VAR 0 44
76344: PUSH
76345: LD_INT 0
76347: PUSH
76348: LD_INT 2
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 1
76357: PUSH
76358: LD_INT 3
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 1
76367: NEG
76368: PUSH
76369: LD_INT 2
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: LIST
76380: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76381: LD_ADDR_VAR 0 45
76385: PUSH
76386: LD_INT 2
76388: NEG
76389: PUSH
76390: LD_INT 0
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 2
76399: NEG
76400: PUSH
76401: LD_INT 1
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: LD_INT 3
76410: NEG
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: LIST
76424: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76425: LD_ADDR_VAR 0 46
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: LD_INT 2
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 2
76444: NEG
76445: PUSH
76446: LD_INT 3
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 3
76456: NEG
76457: PUSH
76458: LD_INT 2
76460: NEG
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: LIST
76470: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76471: LD_ADDR_VAR 0 47
76475: PUSH
76476: LD_INT 2
76478: NEG
76479: PUSH
76480: LD_INT 3
76482: NEG
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: PUSH
76488: LD_INT 1
76490: NEG
76491: PUSH
76492: LD_INT 3
76494: NEG
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76504: LD_ADDR_VAR 0 48
76508: PUSH
76509: LD_INT 1
76511: PUSH
76512: LD_INT 2
76514: NEG
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 2
76522: PUSH
76523: LD_INT 1
76525: NEG
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76535: LD_ADDR_VAR 0 49
76539: PUSH
76540: LD_INT 3
76542: PUSH
76543: LD_INT 1
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 3
76552: PUSH
76553: LD_INT 2
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76564: LD_ADDR_VAR 0 50
76568: PUSH
76569: LD_INT 2
76571: PUSH
76572: LD_INT 3
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 1
76581: PUSH
76582: LD_INT 3
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76593: LD_ADDR_VAR 0 51
76597: PUSH
76598: LD_INT 1
76600: NEG
76601: PUSH
76602: LD_INT 2
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 2
76611: NEG
76612: PUSH
76613: LD_INT 1
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76624: LD_ADDR_VAR 0 52
76628: PUSH
76629: LD_INT 3
76631: NEG
76632: PUSH
76633: LD_INT 1
76635: NEG
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 3
76643: NEG
76644: PUSH
76645: LD_INT 2
76647: NEG
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76657: LD_ADDR_VAR 0 53
76661: PUSH
76662: LD_INT 1
76664: NEG
76665: PUSH
76666: LD_INT 3
76668: NEG
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 0
76676: PUSH
76677: LD_INT 3
76679: NEG
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 1
76687: PUSH
76688: LD_INT 2
76690: NEG
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: LIST
76700: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76701: LD_ADDR_VAR 0 54
76705: PUSH
76706: LD_INT 2
76708: PUSH
76709: LD_INT 1
76711: NEG
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 3
76719: PUSH
76720: LD_INT 0
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 3
76729: PUSH
76730: LD_INT 1
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: LIST
76741: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76742: LD_ADDR_VAR 0 55
76746: PUSH
76747: LD_INT 3
76749: PUSH
76750: LD_INT 2
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: LD_INT 3
76759: PUSH
76760: LD_INT 3
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PUSH
76767: LD_INT 2
76769: PUSH
76770: LD_INT 3
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: LIST
76781: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76782: LD_ADDR_VAR 0 56
76786: PUSH
76787: LD_INT 1
76789: PUSH
76790: LD_INT 3
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 0
76799: PUSH
76800: LD_INT 3
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 1
76809: NEG
76810: PUSH
76811: LD_INT 2
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: LIST
76822: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76823: LD_ADDR_VAR 0 57
76827: PUSH
76828: LD_INT 2
76830: NEG
76831: PUSH
76832: LD_INT 1
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: LD_INT 3
76841: NEG
76842: PUSH
76843: LD_INT 0
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 3
76852: NEG
76853: PUSH
76854: LD_INT 1
76856: NEG
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: LIST
76866: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76867: LD_ADDR_VAR 0 58
76871: PUSH
76872: LD_INT 2
76874: NEG
76875: PUSH
76876: LD_INT 3
76878: NEG
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 3
76886: NEG
76887: PUSH
76888: LD_INT 2
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 3
76898: NEG
76899: PUSH
76900: LD_INT 3
76902: NEG
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: LIST
76912: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76913: LD_ADDR_VAR 0 59
76917: PUSH
76918: LD_INT 1
76920: NEG
76921: PUSH
76922: LD_INT 2
76924: NEG
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 0
76932: PUSH
76933: LD_INT 2
76935: NEG
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 1
76943: PUSH
76944: LD_INT 1
76946: NEG
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: EMPTY
76953: LIST
76954: LIST
76955: LIST
76956: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76957: LD_ADDR_VAR 0 60
76961: PUSH
76962: LD_INT 1
76964: PUSH
76965: LD_INT 1
76967: NEG
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: LD_INT 2
76975: PUSH
76976: LD_INT 0
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 2
76985: PUSH
76986: LD_INT 1
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: LIST
76997: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76998: LD_ADDR_VAR 0 61
77002: PUSH
77003: LD_INT 2
77005: PUSH
77006: LD_INT 1
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 2
77015: PUSH
77016: LD_INT 2
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: LD_INT 2
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: LIST
77037: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77038: LD_ADDR_VAR 0 62
77042: PUSH
77043: LD_INT 1
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 0
77055: PUSH
77056: LD_INT 2
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PUSH
77063: LD_INT 1
77065: NEG
77066: PUSH
77067: LD_INT 1
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: LIST
77078: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77079: LD_ADDR_VAR 0 63
77083: PUSH
77084: LD_INT 1
77086: NEG
77087: PUSH
77088: LD_INT 1
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: LD_INT 2
77097: NEG
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 2
77108: NEG
77109: PUSH
77110: LD_INT 1
77112: NEG
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: LIST
77122: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77123: LD_ADDR_VAR 0 64
77127: PUSH
77128: LD_INT 1
77130: NEG
77131: PUSH
77132: LD_INT 2
77134: NEG
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 2
77142: NEG
77143: PUSH
77144: LD_INT 1
77146: NEG
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: LD_INT 2
77154: NEG
77155: PUSH
77156: LD_INT 2
77158: NEG
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: LIST
77168: ST_TO_ADDR
// end ; 2 :
77169: GO 80435
77171: LD_INT 2
77173: DOUBLE
77174: EQUAL
77175: IFTRUE 77179
77177: GO 80434
77179: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77180: LD_ADDR_VAR 0 29
77184: PUSH
77185: LD_INT 4
77187: PUSH
77188: LD_INT 0
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 4
77197: PUSH
77198: LD_INT 1
77200: NEG
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 5
77208: PUSH
77209: LD_INT 0
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 5
77218: PUSH
77219: LD_INT 1
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 4
77228: PUSH
77229: LD_INT 1
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 3
77238: PUSH
77239: LD_INT 0
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 3
77248: PUSH
77249: LD_INT 1
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 3
77259: PUSH
77260: LD_INT 2
77262: NEG
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 5
77270: PUSH
77271: LD_INT 2
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 3
77280: PUSH
77281: LD_INT 3
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 3
77290: PUSH
77291: LD_INT 2
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 4
77300: PUSH
77301: LD_INT 3
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 4
77310: PUSH
77311: LD_INT 4
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 3
77320: PUSH
77321: LD_INT 4
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 2
77330: PUSH
77331: LD_INT 3
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 2
77340: PUSH
77341: LD_INT 2
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 4
77350: PUSH
77351: LD_INT 2
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 2
77360: PUSH
77361: LD_INT 4
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 0
77370: PUSH
77371: LD_INT 4
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 0
77380: PUSH
77381: LD_INT 3
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 1
77390: PUSH
77391: LD_INT 4
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 1
77400: PUSH
77401: LD_INT 5
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 0
77410: PUSH
77411: LD_INT 5
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 1
77420: NEG
77421: PUSH
77422: LD_INT 4
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 1
77431: NEG
77432: PUSH
77433: LD_INT 3
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 2
77442: PUSH
77443: LD_INT 5
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: PUSH
77450: LD_INT 2
77452: NEG
77453: PUSH
77454: LD_INT 3
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 3
77463: NEG
77464: PUSH
77465: LD_INT 0
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 3
77474: NEG
77475: PUSH
77476: LD_INT 1
77478: NEG
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: PUSH
77484: LD_INT 2
77486: NEG
77487: PUSH
77488: LD_INT 0
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 2
77497: NEG
77498: PUSH
77499: LD_INT 1
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 3
77508: NEG
77509: PUSH
77510: LD_INT 1
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: PUSH
77517: LD_INT 4
77519: NEG
77520: PUSH
77521: LD_INT 0
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 4
77530: NEG
77531: PUSH
77532: LD_INT 1
77534: NEG
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 4
77542: NEG
77543: PUSH
77544: LD_INT 2
77546: NEG
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 2
77554: NEG
77555: PUSH
77556: LD_INT 2
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 4
77565: NEG
77566: PUSH
77567: LD_INT 4
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 4
77577: NEG
77578: PUSH
77579: LD_INT 5
77581: NEG
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 3
77589: NEG
77590: PUSH
77591: LD_INT 4
77593: NEG
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 3
77601: NEG
77602: PUSH
77603: LD_INT 3
77605: NEG
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 4
77613: NEG
77614: PUSH
77615: LD_INT 3
77617: NEG
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 5
77625: NEG
77626: PUSH
77627: LD_INT 4
77629: NEG
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 5
77637: NEG
77638: PUSH
77639: LD_INT 5
77641: NEG
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 3
77649: NEG
77650: PUSH
77651: LD_INT 5
77653: NEG
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: PUSH
77659: LD_INT 5
77661: NEG
77662: PUSH
77663: LD_INT 3
77665: NEG
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77718: LD_ADDR_VAR 0 30
77722: PUSH
77723: LD_INT 4
77725: PUSH
77726: LD_INT 4
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 4
77735: PUSH
77736: LD_INT 3
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 5
77745: PUSH
77746: LD_INT 4
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PUSH
77753: LD_INT 5
77755: PUSH
77756: LD_INT 5
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 4
77765: PUSH
77766: LD_INT 5
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: LD_INT 3
77775: PUSH
77776: LD_INT 4
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 3
77785: PUSH
77786: LD_INT 3
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: PUSH
77793: LD_INT 5
77795: PUSH
77796: LD_INT 3
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: PUSH
77803: LD_INT 3
77805: PUSH
77806: LD_INT 5
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 0
77815: PUSH
77816: LD_INT 3
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 0
77825: PUSH
77826: LD_INT 2
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 1
77835: PUSH
77836: LD_INT 3
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 1
77845: PUSH
77846: LD_INT 4
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 0
77855: PUSH
77856: LD_INT 4
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 1
77865: NEG
77866: PUSH
77867: LD_INT 3
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 1
77876: NEG
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 2
77887: PUSH
77888: LD_INT 4
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 2
77897: NEG
77898: PUSH
77899: LD_INT 2
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 4
77908: NEG
77909: PUSH
77910: LD_INT 0
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 4
77919: NEG
77920: PUSH
77921: LD_INT 1
77923: NEG
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 3
77931: NEG
77932: PUSH
77933: LD_INT 0
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 3
77942: NEG
77943: PUSH
77944: LD_INT 1
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 4
77953: NEG
77954: PUSH
77955: LD_INT 1
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 5
77964: NEG
77965: PUSH
77966: LD_INT 0
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 5
77975: NEG
77976: PUSH
77977: LD_INT 1
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 5
77987: NEG
77988: PUSH
77989: LD_INT 2
77991: NEG
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: LD_INT 3
77999: NEG
78000: PUSH
78001: LD_INT 2
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: LD_INT 3
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 3
78022: NEG
78023: PUSH
78024: LD_INT 4
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 2
78034: NEG
78035: PUSH
78036: LD_INT 3
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 2
78046: NEG
78047: PUSH
78048: LD_INT 2
78050: NEG
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 3
78058: NEG
78059: PUSH
78060: LD_INT 2
78062: NEG
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 4
78070: NEG
78071: PUSH
78072: LD_INT 3
78074: NEG
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 4
78082: NEG
78083: PUSH
78084: LD_INT 4
78086: NEG
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 2
78094: NEG
78095: PUSH
78096: LD_INT 4
78098: NEG
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 4
78106: NEG
78107: PUSH
78108: LD_INT 2
78110: NEG
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: PUSH
78116: LD_INT 0
78118: PUSH
78119: LD_INT 4
78121: NEG
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 0
78129: PUSH
78130: LD_INT 5
78132: NEG
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 1
78140: PUSH
78141: LD_INT 4
78143: NEG
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 1
78151: PUSH
78152: LD_INT 3
78154: NEG
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 0
78162: PUSH
78163: LD_INT 3
78165: NEG
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 1
78173: NEG
78174: PUSH
78175: LD_INT 4
78177: NEG
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 1
78185: NEG
78186: PUSH
78187: LD_INT 5
78189: NEG
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 2
78197: PUSH
78198: LD_INT 3
78200: NEG
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 2
78208: NEG
78209: PUSH
78210: LD_INT 5
78212: NEG
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: LIST
78264: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78265: LD_ADDR_VAR 0 31
78269: PUSH
78270: LD_INT 0
78272: PUSH
78273: LD_INT 4
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 0
78282: PUSH
78283: LD_INT 3
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 1
78292: PUSH
78293: LD_INT 4
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: LD_INT 1
78302: PUSH
78303: LD_INT 5
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 0
78312: PUSH
78313: LD_INT 5
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 1
78322: NEG
78323: PUSH
78324: LD_INT 4
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 1
78333: NEG
78334: PUSH
78335: LD_INT 3
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 2
78344: PUSH
78345: LD_INT 5
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 2
78354: NEG
78355: PUSH
78356: LD_INT 3
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 3
78365: NEG
78366: PUSH
78367: LD_INT 0
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 3
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: NEG
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 2
78388: NEG
78389: PUSH
78390: LD_INT 0
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 2
78399: NEG
78400: PUSH
78401: LD_INT 1
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 3
78410: NEG
78411: PUSH
78412: LD_INT 1
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 4
78421: NEG
78422: PUSH
78423: LD_INT 0
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 4
78432: NEG
78433: PUSH
78434: LD_INT 1
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 4
78444: NEG
78445: PUSH
78446: LD_INT 2
78448: NEG
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 2
78456: NEG
78457: PUSH
78458: LD_INT 2
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 4
78467: NEG
78468: PUSH
78469: LD_INT 4
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 4
78479: NEG
78480: PUSH
78481: LD_INT 5
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 3
78491: NEG
78492: PUSH
78493: LD_INT 4
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 3
78503: NEG
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 4
78515: NEG
78516: PUSH
78517: LD_INT 3
78519: NEG
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 5
78527: NEG
78528: PUSH
78529: LD_INT 4
78531: NEG
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 5
78539: NEG
78540: PUSH
78541: LD_INT 5
78543: NEG
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 3
78551: NEG
78552: PUSH
78553: LD_INT 5
78555: NEG
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 5
78563: NEG
78564: PUSH
78565: LD_INT 3
78567: NEG
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 0
78575: PUSH
78576: LD_INT 3
78578: NEG
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 0
78586: PUSH
78587: LD_INT 4
78589: NEG
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 1
78597: PUSH
78598: LD_INT 3
78600: NEG
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 1
78608: PUSH
78609: LD_INT 2
78611: NEG
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 0
78619: PUSH
78620: LD_INT 2
78622: NEG
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 1
78630: NEG
78631: PUSH
78632: LD_INT 3
78634: NEG
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 1
78642: NEG
78643: PUSH
78644: LD_INT 4
78646: NEG
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 2
78654: PUSH
78655: LD_INT 2
78657: NEG
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 2
78665: NEG
78666: PUSH
78667: LD_INT 4
78669: NEG
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 4
78677: PUSH
78678: LD_INT 0
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 4
78687: PUSH
78688: LD_INT 1
78690: NEG
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 5
78698: PUSH
78699: LD_INT 0
78701: PUSH
78702: EMPTY
78703: LIST
78704: LIST
78705: PUSH
78706: LD_INT 5
78708: PUSH
78709: LD_INT 1
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 4
78718: PUSH
78719: LD_INT 1
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 3
78728: PUSH
78729: LD_INT 0
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 3
78738: PUSH
78739: LD_INT 1
78741: NEG
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PUSH
78747: LD_INT 3
78749: PUSH
78750: LD_INT 2
78752: NEG
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 5
78760: PUSH
78761: LD_INT 2
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78815: LD_ADDR_VAR 0 32
78819: PUSH
78820: LD_INT 4
78822: NEG
78823: PUSH
78824: LD_INT 0
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 4
78833: NEG
78834: PUSH
78835: LD_INT 1
78837: NEG
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 3
78845: NEG
78846: PUSH
78847: LD_INT 0
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 3
78856: NEG
78857: PUSH
78858: LD_INT 1
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: PUSH
78865: LD_INT 4
78867: NEG
78868: PUSH
78869: LD_INT 1
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PUSH
78876: LD_INT 5
78878: NEG
78879: PUSH
78880: LD_INT 0
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 5
78889: NEG
78890: PUSH
78891: LD_INT 1
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 5
78901: NEG
78902: PUSH
78903: LD_INT 2
78905: NEG
78906: PUSH
78907: EMPTY
78908: LIST
78909: LIST
78910: PUSH
78911: LD_INT 3
78913: NEG
78914: PUSH
78915: LD_INT 2
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 3
78924: NEG
78925: PUSH
78926: LD_INT 3
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 3
78936: NEG
78937: PUSH
78938: LD_INT 4
78940: NEG
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 2
78948: NEG
78949: PUSH
78950: LD_INT 3
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 2
78960: NEG
78961: PUSH
78962: LD_INT 2
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 3
78972: NEG
78973: PUSH
78974: LD_INT 2
78976: NEG
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 4
78984: NEG
78985: PUSH
78986: LD_INT 3
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 4
78996: NEG
78997: PUSH
78998: LD_INT 4
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 2
79008: NEG
79009: PUSH
79010: LD_INT 4
79012: NEG
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 4
79020: NEG
79021: PUSH
79022: LD_INT 2
79024: NEG
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 0
79032: PUSH
79033: LD_INT 4
79035: NEG
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 0
79043: PUSH
79044: LD_INT 5
79046: NEG
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 1
79054: PUSH
79055: LD_INT 4
79057: NEG
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: LD_INT 3
79068: NEG
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 0
79076: PUSH
79077: LD_INT 3
79079: NEG
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 1
79087: NEG
79088: PUSH
79089: LD_INT 4
79091: NEG
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 1
79099: NEG
79100: PUSH
79101: LD_INT 5
79103: NEG
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: LD_INT 2
79111: PUSH
79112: LD_INT 3
79114: NEG
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 2
79122: NEG
79123: PUSH
79124: LD_INT 5
79126: NEG
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 3
79134: PUSH
79135: LD_INT 0
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 3
79144: PUSH
79145: LD_INT 1
79147: NEG
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 4
79155: PUSH
79156: LD_INT 0
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: PUSH
79163: LD_INT 4
79165: PUSH
79166: LD_INT 1
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 3
79175: PUSH
79176: LD_INT 1
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 2
79185: PUSH
79186: LD_INT 0
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 2
79195: PUSH
79196: LD_INT 1
79198: NEG
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: LD_INT 2
79206: PUSH
79207: LD_INT 2
79209: NEG
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 4
79217: PUSH
79218: LD_INT 2
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 4
79227: PUSH
79228: LD_INT 4
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 4
79237: PUSH
79238: LD_INT 3
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 5
79247: PUSH
79248: LD_INT 4
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 5
79257: PUSH
79258: LD_INT 5
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 4
79267: PUSH
79268: LD_INT 5
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: PUSH
79275: LD_INT 3
79277: PUSH
79278: LD_INT 4
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 3
79287: PUSH
79288: LD_INT 3
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 5
79297: PUSH
79298: LD_INT 3
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 3
79307: PUSH
79308: LD_INT 5
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: LIST
79359: LIST
79360: LIST
79361: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79362: LD_ADDR_VAR 0 33
79366: PUSH
79367: LD_INT 4
79369: NEG
79370: PUSH
79371: LD_INT 4
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 4
79381: NEG
79382: PUSH
79383: LD_INT 5
79385: NEG
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 3
79393: NEG
79394: PUSH
79395: LD_INT 4
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 3
79405: NEG
79406: PUSH
79407: LD_INT 3
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 4
79417: NEG
79418: PUSH
79419: LD_INT 3
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 5
79429: NEG
79430: PUSH
79431: LD_INT 4
79433: NEG
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 5
79441: NEG
79442: PUSH
79443: LD_INT 5
79445: NEG
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: LD_INT 3
79453: NEG
79454: PUSH
79455: LD_INT 5
79457: NEG
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 5
79465: NEG
79466: PUSH
79467: LD_INT 3
79469: NEG
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 0
79477: PUSH
79478: LD_INT 3
79480: NEG
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 0
79488: PUSH
79489: LD_INT 4
79491: NEG
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 1
79499: PUSH
79500: LD_INT 3
79502: NEG
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 1
79510: PUSH
79511: LD_INT 2
79513: NEG
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 0
79521: PUSH
79522: LD_INT 2
79524: NEG
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 1
79532: NEG
79533: PUSH
79534: LD_INT 3
79536: NEG
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 1
79544: NEG
79545: PUSH
79546: LD_INT 4
79548: NEG
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 2
79556: PUSH
79557: LD_INT 2
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 2
79567: NEG
79568: PUSH
79569: LD_INT 4
79571: NEG
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 4
79579: PUSH
79580: LD_INT 0
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 4
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 5
79600: PUSH
79601: LD_INT 0
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 5
79610: PUSH
79611: LD_INT 1
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 4
79620: PUSH
79621: LD_INT 1
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 3
79630: PUSH
79631: LD_INT 0
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 3
79640: PUSH
79641: LD_INT 1
79643: NEG
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 3
79651: PUSH
79652: LD_INT 2
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 5
79662: PUSH
79663: LD_INT 2
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 3
79672: PUSH
79673: LD_INT 3
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 3
79682: PUSH
79683: LD_INT 2
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 4
79692: PUSH
79693: LD_INT 3
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: PUSH
79700: LD_INT 4
79702: PUSH
79703: LD_INT 4
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 3
79712: PUSH
79713: LD_INT 4
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 2
79722: PUSH
79723: LD_INT 3
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 2
79732: PUSH
79733: LD_INT 2
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 4
79742: PUSH
79743: LD_INT 2
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 2
79752: PUSH
79753: LD_INT 4
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 0
79762: PUSH
79763: LD_INT 4
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 0
79772: PUSH
79773: LD_INT 3
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: LD_INT 1
79782: PUSH
79783: LD_INT 4
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 1
79792: PUSH
79793: LD_INT 5
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 0
79802: PUSH
79803: LD_INT 5
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 1
79812: NEG
79813: PUSH
79814: LD_INT 4
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: LD_INT 1
79823: NEG
79824: PUSH
79825: LD_INT 3
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: LD_INT 2
79834: PUSH
79835: LD_INT 5
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 2
79844: NEG
79845: PUSH
79846: LD_INT 3
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79900: LD_ADDR_VAR 0 34
79904: PUSH
79905: LD_INT 0
79907: PUSH
79908: LD_INT 4
79910: NEG
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 0
79918: PUSH
79919: LD_INT 5
79921: NEG
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: LD_INT 1
79929: PUSH
79930: LD_INT 4
79932: NEG
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 1
79940: PUSH
79941: LD_INT 3
79943: NEG
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 0
79951: PUSH
79952: LD_INT 3
79954: NEG
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 1
79962: NEG
79963: PUSH
79964: LD_INT 4
79966: NEG
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 1
79974: NEG
79975: PUSH
79976: LD_INT 5
79978: NEG
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 2
79986: PUSH
79987: LD_INT 3
79989: NEG
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 2
79997: NEG
79998: PUSH
79999: LD_INT 5
80001: NEG
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: LD_INT 0
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 3
80019: PUSH
80020: LD_INT 1
80022: NEG
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 4
80030: PUSH
80031: LD_INT 0
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 4
80040: PUSH
80041: LD_INT 1
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 3
80050: PUSH
80051: LD_INT 1
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 2
80060: PUSH
80061: LD_INT 0
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 2
80070: PUSH
80071: LD_INT 1
80073: NEG
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 2
80081: PUSH
80082: LD_INT 2
80084: NEG
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 4
80092: PUSH
80093: LD_INT 2
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 4
80102: PUSH
80103: LD_INT 4
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 4
80112: PUSH
80113: LD_INT 3
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 5
80122: PUSH
80123: LD_INT 4
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 5
80132: PUSH
80133: LD_INT 5
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 4
80142: PUSH
80143: LD_INT 5
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 3
80152: PUSH
80153: LD_INT 4
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 3
80162: PUSH
80163: LD_INT 3
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 5
80172: PUSH
80173: LD_INT 3
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 3
80182: PUSH
80183: LD_INT 5
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 0
80192: PUSH
80193: LD_INT 3
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: LD_INT 2
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 1
80212: PUSH
80213: LD_INT 3
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 1
80222: PUSH
80223: LD_INT 4
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 0
80232: PUSH
80233: LD_INT 4
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: LD_INT 3
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 1
80253: NEG
80254: PUSH
80255: LD_INT 2
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 2
80264: PUSH
80265: LD_INT 4
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 2
80274: NEG
80275: PUSH
80276: LD_INT 2
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 4
80285: NEG
80286: PUSH
80287: LD_INT 0
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 4
80296: NEG
80297: PUSH
80298: LD_INT 1
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 3
80308: NEG
80309: PUSH
80310: LD_INT 0
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 3
80319: NEG
80320: PUSH
80321: LD_INT 1
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 4
80330: NEG
80331: PUSH
80332: LD_INT 1
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 5
80341: NEG
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 5
80352: NEG
80353: PUSH
80354: LD_INT 1
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 5
80364: NEG
80365: PUSH
80366: LD_INT 2
80368: NEG
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 3
80376: NEG
80377: PUSH
80378: LD_INT 2
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: LIST
80421: LIST
80422: LIST
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: LIST
80430: LIST
80431: ST_TO_ADDR
// end ; end ;
80432: GO 80435
80434: POP
// case btype of b_depot , b_warehouse :
80435: LD_VAR 0 1
80439: PUSH
80440: LD_INT 0
80442: DOUBLE
80443: EQUAL
80444: IFTRUE 80454
80446: LD_INT 1
80448: DOUBLE
80449: EQUAL
80450: IFTRUE 80454
80452: GO 80655
80454: POP
// case nation of nation_american :
80455: LD_VAR 0 5
80459: PUSH
80460: LD_INT 1
80462: DOUBLE
80463: EQUAL
80464: IFTRUE 80468
80466: GO 80524
80468: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
80469: LD_ADDR_VAR 0 9
80473: PUSH
80474: LD_VAR 0 11
80478: PUSH
80479: LD_VAR 0 12
80483: PUSH
80484: LD_VAR 0 13
80488: PUSH
80489: LD_VAR 0 14
80493: PUSH
80494: LD_VAR 0 15
80498: PUSH
80499: LD_VAR 0 16
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: LIST
80511: PUSH
80512: LD_VAR 0 4
80516: PUSH
80517: LD_INT 1
80519: PLUS
80520: ARRAY
80521: ST_TO_ADDR
80522: GO 80653
80524: LD_INT 2
80526: DOUBLE
80527: EQUAL
80528: IFTRUE 80532
80530: GO 80588
80532: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
80533: LD_ADDR_VAR 0 9
80537: PUSH
80538: LD_VAR 0 17
80542: PUSH
80543: LD_VAR 0 18
80547: PUSH
80548: LD_VAR 0 19
80552: PUSH
80553: LD_VAR 0 20
80557: PUSH
80558: LD_VAR 0 21
80562: PUSH
80563: LD_VAR 0 22
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: PUSH
80576: LD_VAR 0 4
80580: PUSH
80581: LD_INT 1
80583: PLUS
80584: ARRAY
80585: ST_TO_ADDR
80586: GO 80653
80588: LD_INT 3
80590: DOUBLE
80591: EQUAL
80592: IFTRUE 80596
80594: GO 80652
80596: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80597: LD_ADDR_VAR 0 9
80601: PUSH
80602: LD_VAR 0 23
80606: PUSH
80607: LD_VAR 0 24
80611: PUSH
80612: LD_VAR 0 25
80616: PUSH
80617: LD_VAR 0 26
80621: PUSH
80622: LD_VAR 0 27
80626: PUSH
80627: LD_VAR 0 28
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: PUSH
80640: LD_VAR 0 4
80644: PUSH
80645: LD_INT 1
80647: PLUS
80648: ARRAY
80649: ST_TO_ADDR
80650: GO 80653
80652: POP
80653: GO 81208
80655: LD_INT 2
80657: DOUBLE
80658: EQUAL
80659: IFTRUE 80669
80661: LD_INT 3
80663: DOUBLE
80664: EQUAL
80665: IFTRUE 80669
80667: GO 80725
80669: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80670: LD_ADDR_VAR 0 9
80674: PUSH
80675: LD_VAR 0 29
80679: PUSH
80680: LD_VAR 0 30
80684: PUSH
80685: LD_VAR 0 31
80689: PUSH
80690: LD_VAR 0 32
80694: PUSH
80695: LD_VAR 0 33
80699: PUSH
80700: LD_VAR 0 34
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: PUSH
80713: LD_VAR 0 4
80717: PUSH
80718: LD_INT 1
80720: PLUS
80721: ARRAY
80722: ST_TO_ADDR
80723: GO 81208
80725: LD_INT 16
80727: DOUBLE
80728: EQUAL
80729: IFTRUE 80787
80731: LD_INT 17
80733: DOUBLE
80734: EQUAL
80735: IFTRUE 80787
80737: LD_INT 18
80739: DOUBLE
80740: EQUAL
80741: IFTRUE 80787
80743: LD_INT 19
80745: DOUBLE
80746: EQUAL
80747: IFTRUE 80787
80749: LD_INT 22
80751: DOUBLE
80752: EQUAL
80753: IFTRUE 80787
80755: LD_INT 20
80757: DOUBLE
80758: EQUAL
80759: IFTRUE 80787
80761: LD_INT 21
80763: DOUBLE
80764: EQUAL
80765: IFTRUE 80787
80767: LD_INT 23
80769: DOUBLE
80770: EQUAL
80771: IFTRUE 80787
80773: LD_INT 24
80775: DOUBLE
80776: EQUAL
80777: IFTRUE 80787
80779: LD_INT 25
80781: DOUBLE
80782: EQUAL
80783: IFTRUE 80787
80785: GO 80843
80787: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80788: LD_ADDR_VAR 0 9
80792: PUSH
80793: LD_VAR 0 35
80797: PUSH
80798: LD_VAR 0 36
80802: PUSH
80803: LD_VAR 0 37
80807: PUSH
80808: LD_VAR 0 38
80812: PUSH
80813: LD_VAR 0 39
80817: PUSH
80818: LD_VAR 0 40
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: PUSH
80831: LD_VAR 0 4
80835: PUSH
80836: LD_INT 1
80838: PLUS
80839: ARRAY
80840: ST_TO_ADDR
80841: GO 81208
80843: LD_INT 6
80845: DOUBLE
80846: EQUAL
80847: IFTRUE 80899
80849: LD_INT 7
80851: DOUBLE
80852: EQUAL
80853: IFTRUE 80899
80855: LD_INT 8
80857: DOUBLE
80858: EQUAL
80859: IFTRUE 80899
80861: LD_INT 13
80863: DOUBLE
80864: EQUAL
80865: IFTRUE 80899
80867: LD_INT 12
80869: DOUBLE
80870: EQUAL
80871: IFTRUE 80899
80873: LD_INT 15
80875: DOUBLE
80876: EQUAL
80877: IFTRUE 80899
80879: LD_INT 11
80881: DOUBLE
80882: EQUAL
80883: IFTRUE 80899
80885: LD_INT 14
80887: DOUBLE
80888: EQUAL
80889: IFTRUE 80899
80891: LD_INT 10
80893: DOUBLE
80894: EQUAL
80895: IFTRUE 80899
80897: GO 80955
80899: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
80900: LD_ADDR_VAR 0 9
80904: PUSH
80905: LD_VAR 0 41
80909: PUSH
80910: LD_VAR 0 42
80914: PUSH
80915: LD_VAR 0 43
80919: PUSH
80920: LD_VAR 0 44
80924: PUSH
80925: LD_VAR 0 45
80929: PUSH
80930: LD_VAR 0 46
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: PUSH
80943: LD_VAR 0 4
80947: PUSH
80948: LD_INT 1
80950: PLUS
80951: ARRAY
80952: ST_TO_ADDR
80953: GO 81208
80955: LD_INT 36
80957: DOUBLE
80958: EQUAL
80959: IFTRUE 80963
80961: GO 81019
80963: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80964: LD_ADDR_VAR 0 9
80968: PUSH
80969: LD_VAR 0 47
80973: PUSH
80974: LD_VAR 0 48
80978: PUSH
80979: LD_VAR 0 49
80983: PUSH
80984: LD_VAR 0 50
80988: PUSH
80989: LD_VAR 0 51
80993: PUSH
80994: LD_VAR 0 52
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: PUSH
81007: LD_VAR 0 4
81011: PUSH
81012: LD_INT 1
81014: PLUS
81015: ARRAY
81016: ST_TO_ADDR
81017: GO 81208
81019: LD_INT 4
81021: DOUBLE
81022: EQUAL
81023: IFTRUE 81045
81025: LD_INT 5
81027: DOUBLE
81028: EQUAL
81029: IFTRUE 81045
81031: LD_INT 34
81033: DOUBLE
81034: EQUAL
81035: IFTRUE 81045
81037: LD_INT 37
81039: DOUBLE
81040: EQUAL
81041: IFTRUE 81045
81043: GO 81101
81045: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81046: LD_ADDR_VAR 0 9
81050: PUSH
81051: LD_VAR 0 53
81055: PUSH
81056: LD_VAR 0 54
81060: PUSH
81061: LD_VAR 0 55
81065: PUSH
81066: LD_VAR 0 56
81070: PUSH
81071: LD_VAR 0 57
81075: PUSH
81076: LD_VAR 0 58
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: PUSH
81089: LD_VAR 0 4
81093: PUSH
81094: LD_INT 1
81096: PLUS
81097: ARRAY
81098: ST_TO_ADDR
81099: GO 81208
81101: LD_INT 31
81103: DOUBLE
81104: EQUAL
81105: IFTRUE 81151
81107: LD_INT 32
81109: DOUBLE
81110: EQUAL
81111: IFTRUE 81151
81113: LD_INT 33
81115: DOUBLE
81116: EQUAL
81117: IFTRUE 81151
81119: LD_INT 27
81121: DOUBLE
81122: EQUAL
81123: IFTRUE 81151
81125: LD_INT 26
81127: DOUBLE
81128: EQUAL
81129: IFTRUE 81151
81131: LD_INT 28
81133: DOUBLE
81134: EQUAL
81135: IFTRUE 81151
81137: LD_INT 29
81139: DOUBLE
81140: EQUAL
81141: IFTRUE 81151
81143: LD_INT 30
81145: DOUBLE
81146: EQUAL
81147: IFTRUE 81151
81149: GO 81207
81151: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
81152: LD_ADDR_VAR 0 9
81156: PUSH
81157: LD_VAR 0 59
81161: PUSH
81162: LD_VAR 0 60
81166: PUSH
81167: LD_VAR 0 61
81171: PUSH
81172: LD_VAR 0 62
81176: PUSH
81177: LD_VAR 0 63
81181: PUSH
81182: LD_VAR 0 64
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: PUSH
81195: LD_VAR 0 4
81199: PUSH
81200: LD_INT 1
81202: PLUS
81203: ARRAY
81204: ST_TO_ADDR
81205: GO 81208
81207: POP
// temp_list2 = [ ] ;
81208: LD_ADDR_VAR 0 10
81212: PUSH
81213: EMPTY
81214: ST_TO_ADDR
// for i in temp_list do
81215: LD_ADDR_VAR 0 8
81219: PUSH
81220: LD_VAR 0 9
81224: PUSH
81225: FOR_IN
81226: IFFALSE 81278
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81228: LD_ADDR_VAR 0 10
81232: PUSH
81233: LD_VAR 0 10
81237: PUSH
81238: LD_VAR 0 8
81242: PUSH
81243: LD_INT 1
81245: ARRAY
81246: PUSH
81247: LD_VAR 0 2
81251: PLUS
81252: PUSH
81253: LD_VAR 0 8
81257: PUSH
81258: LD_INT 2
81260: ARRAY
81261: PUSH
81262: LD_VAR 0 3
81266: PLUS
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: EMPTY
81273: LIST
81274: ADD
81275: ST_TO_ADDR
81276: GO 81225
81278: POP
81279: POP
// result = temp_list2 ;
81280: LD_ADDR_VAR 0 7
81284: PUSH
81285: LD_VAR 0 10
81289: ST_TO_ADDR
// end ;
81290: LD_VAR 0 7
81294: RET
// export function EnemyInRange ( unit , dist ) ; begin
81295: LD_INT 0
81297: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81298: LD_ADDR_VAR 0 3
81302: PUSH
81303: LD_VAR 0 1
81307: PPUSH
81308: CALL_OW 255
81312: PPUSH
81313: LD_VAR 0 1
81317: PPUSH
81318: CALL_OW 250
81322: PPUSH
81323: LD_VAR 0 1
81327: PPUSH
81328: CALL_OW 251
81332: PPUSH
81333: LD_VAR 0 2
81337: PPUSH
81338: CALL 55399 0 4
81342: PUSH
81343: LD_INT 4
81345: ARRAY
81346: ST_TO_ADDR
// end ;
81347: LD_VAR 0 3
81351: RET
// export function PlayerSeeMe ( unit ) ; begin
81352: LD_INT 0
81354: PPUSH
// result := See ( your_side , unit ) ;
81355: LD_ADDR_VAR 0 2
81359: PUSH
81360: LD_OWVAR 2
81364: PPUSH
81365: LD_VAR 0 1
81369: PPUSH
81370: CALL_OW 292
81374: ST_TO_ADDR
// end ;
81375: LD_VAR 0 2
81379: RET
// export function ReverseDir ( unit ) ; begin
81380: LD_INT 0
81382: PPUSH
// if not unit then
81383: LD_VAR 0 1
81387: NOT
81388: IFFALSE 81392
// exit ;
81390: GO 81438
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
81392: LD_ADDR_VAR 0 2
81396: PUSH
81397: LD_INT 3
81399: PUSH
81400: LD_INT 4
81402: PUSH
81403: LD_INT 5
81405: PUSH
81406: LD_INT 0
81408: PUSH
81409: LD_INT 1
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: PUSH
81423: LD_VAR 0 1
81427: PPUSH
81428: CALL_OW 254
81432: PUSH
81433: LD_INT 1
81435: PLUS
81436: ARRAY
81437: ST_TO_ADDR
// end ;
81438: LD_VAR 0 2
81442: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81443: LD_INT 0
81445: PPUSH
81446: PPUSH
81447: PPUSH
81448: PPUSH
81449: PPUSH
// if not hexes then
81450: LD_VAR 0 2
81454: NOT
81455: IFFALSE 81459
// exit ;
81457: GO 81607
// dist := 9999 ;
81459: LD_ADDR_VAR 0 5
81463: PUSH
81464: LD_INT 9999
81466: ST_TO_ADDR
// for i = 1 to hexes do
81467: LD_ADDR_VAR 0 4
81471: PUSH
81472: DOUBLE
81473: LD_INT 1
81475: DEC
81476: ST_TO_ADDR
81477: LD_VAR 0 2
81481: PUSH
81482: FOR_TO
81483: IFFALSE 81595
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81485: LD_VAR 0 1
81489: PPUSH
81490: LD_VAR 0 2
81494: PUSH
81495: LD_VAR 0 4
81499: ARRAY
81500: PUSH
81501: LD_INT 1
81503: ARRAY
81504: PPUSH
81505: LD_VAR 0 2
81509: PUSH
81510: LD_VAR 0 4
81514: ARRAY
81515: PUSH
81516: LD_INT 2
81518: ARRAY
81519: PPUSH
81520: CALL_OW 297
81524: PUSH
81525: LD_VAR 0 5
81529: LESS
81530: IFFALSE 81593
// begin hex := hexes [ i ] ;
81532: LD_ADDR_VAR 0 7
81536: PUSH
81537: LD_VAR 0 2
81541: PUSH
81542: LD_VAR 0 4
81546: ARRAY
81547: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81548: LD_ADDR_VAR 0 5
81552: PUSH
81553: LD_VAR 0 1
81557: PPUSH
81558: LD_VAR 0 2
81562: PUSH
81563: LD_VAR 0 4
81567: ARRAY
81568: PUSH
81569: LD_INT 1
81571: ARRAY
81572: PPUSH
81573: LD_VAR 0 2
81577: PUSH
81578: LD_VAR 0 4
81582: ARRAY
81583: PUSH
81584: LD_INT 2
81586: ARRAY
81587: PPUSH
81588: CALL_OW 297
81592: ST_TO_ADDR
// end ; end ;
81593: GO 81482
81595: POP
81596: POP
// result := hex ;
81597: LD_ADDR_VAR 0 3
81601: PUSH
81602: LD_VAR 0 7
81606: ST_TO_ADDR
// end ;
81607: LD_VAR 0 3
81611: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81612: LD_INT 0
81614: PPUSH
81615: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81616: LD_VAR 0 1
81620: NOT
81621: PUSH
81622: LD_VAR 0 1
81626: PUSH
81627: LD_INT 21
81629: PUSH
81630: LD_INT 2
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 23
81639: PUSH
81640: LD_INT 2
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PPUSH
81651: CALL_OW 69
81655: IN
81656: NOT
81657: OR
81658: IFFALSE 81662
// exit ;
81660: GO 81709
// for i = 1 to 3 do
81662: LD_ADDR_VAR 0 3
81666: PUSH
81667: DOUBLE
81668: LD_INT 1
81670: DEC
81671: ST_TO_ADDR
81672: LD_INT 3
81674: PUSH
81675: FOR_TO
81676: IFFALSE 81707
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81678: LD_VAR 0 1
81682: PPUSH
81683: CALL_OW 250
81687: PPUSH
81688: LD_VAR 0 1
81692: PPUSH
81693: CALL_OW 251
81697: PPUSH
81698: LD_INT 1
81700: PPUSH
81701: CALL_OW 453
81705: GO 81675
81707: POP
81708: POP
// end ;
81709: LD_VAR 0 2
81713: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81714: LD_INT 0
81716: PPUSH
81717: PPUSH
81718: PPUSH
81719: PPUSH
81720: PPUSH
81721: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81722: LD_VAR 0 1
81726: NOT
81727: PUSH
81728: LD_VAR 0 2
81732: NOT
81733: OR
81734: PUSH
81735: LD_VAR 0 1
81739: PPUSH
81740: CALL_OW 314
81744: OR
81745: IFFALSE 81749
// exit ;
81747: GO 82190
// x := GetX ( enemy_unit ) ;
81749: LD_ADDR_VAR 0 7
81753: PUSH
81754: LD_VAR 0 2
81758: PPUSH
81759: CALL_OW 250
81763: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81764: LD_ADDR_VAR 0 8
81768: PUSH
81769: LD_VAR 0 2
81773: PPUSH
81774: CALL_OW 251
81778: ST_TO_ADDR
// if not x or not y then
81779: LD_VAR 0 7
81783: NOT
81784: PUSH
81785: LD_VAR 0 8
81789: NOT
81790: OR
81791: IFFALSE 81795
// exit ;
81793: GO 82190
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81795: LD_ADDR_VAR 0 6
81799: PUSH
81800: LD_VAR 0 7
81804: PPUSH
81805: LD_INT 0
81807: PPUSH
81808: LD_INT 4
81810: PPUSH
81811: CALL_OW 272
81815: PUSH
81816: LD_VAR 0 8
81820: PPUSH
81821: LD_INT 0
81823: PPUSH
81824: LD_INT 4
81826: PPUSH
81827: CALL_OW 273
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_VAR 0 7
81840: PPUSH
81841: LD_INT 1
81843: PPUSH
81844: LD_INT 4
81846: PPUSH
81847: CALL_OW 272
81851: PUSH
81852: LD_VAR 0 8
81856: PPUSH
81857: LD_INT 1
81859: PPUSH
81860: LD_INT 4
81862: PPUSH
81863: CALL_OW 273
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_VAR 0 7
81876: PPUSH
81877: LD_INT 2
81879: PPUSH
81880: LD_INT 4
81882: PPUSH
81883: CALL_OW 272
81887: PUSH
81888: LD_VAR 0 8
81892: PPUSH
81893: LD_INT 2
81895: PPUSH
81896: LD_INT 4
81898: PPUSH
81899: CALL_OW 273
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_VAR 0 7
81912: PPUSH
81913: LD_INT 3
81915: PPUSH
81916: LD_INT 4
81918: PPUSH
81919: CALL_OW 272
81923: PUSH
81924: LD_VAR 0 8
81928: PPUSH
81929: LD_INT 3
81931: PPUSH
81932: LD_INT 4
81934: PPUSH
81935: CALL_OW 273
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_VAR 0 7
81948: PPUSH
81949: LD_INT 4
81951: PPUSH
81952: LD_INT 4
81954: PPUSH
81955: CALL_OW 272
81959: PUSH
81960: LD_VAR 0 8
81964: PPUSH
81965: LD_INT 4
81967: PPUSH
81968: LD_INT 4
81970: PPUSH
81971: CALL_OW 273
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_VAR 0 7
81984: PPUSH
81985: LD_INT 5
81987: PPUSH
81988: LD_INT 4
81990: PPUSH
81991: CALL_OW 272
81995: PUSH
81996: LD_VAR 0 8
82000: PPUSH
82001: LD_INT 5
82003: PPUSH
82004: LD_INT 4
82006: PPUSH
82007: CALL_OW 273
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: ST_TO_ADDR
// for i = tmp downto 1 do
82024: LD_ADDR_VAR 0 4
82028: PUSH
82029: DOUBLE
82030: LD_VAR 0 6
82034: INC
82035: ST_TO_ADDR
82036: LD_INT 1
82038: PUSH
82039: FOR_DOWNTO
82040: IFFALSE 82141
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82042: LD_VAR 0 6
82046: PUSH
82047: LD_VAR 0 4
82051: ARRAY
82052: PUSH
82053: LD_INT 1
82055: ARRAY
82056: PPUSH
82057: LD_VAR 0 6
82061: PUSH
82062: LD_VAR 0 4
82066: ARRAY
82067: PUSH
82068: LD_INT 2
82070: ARRAY
82071: PPUSH
82072: CALL_OW 488
82076: NOT
82077: PUSH
82078: LD_VAR 0 6
82082: PUSH
82083: LD_VAR 0 4
82087: ARRAY
82088: PUSH
82089: LD_INT 1
82091: ARRAY
82092: PPUSH
82093: LD_VAR 0 6
82097: PUSH
82098: LD_VAR 0 4
82102: ARRAY
82103: PUSH
82104: LD_INT 2
82106: ARRAY
82107: PPUSH
82108: CALL_OW 428
82112: PUSH
82113: LD_INT 0
82115: NONEQUAL
82116: OR
82117: IFFALSE 82139
// tmp := Delete ( tmp , i ) ;
82119: LD_ADDR_VAR 0 6
82123: PUSH
82124: LD_VAR 0 6
82128: PPUSH
82129: LD_VAR 0 4
82133: PPUSH
82134: CALL_OW 3
82138: ST_TO_ADDR
82139: GO 82039
82141: POP
82142: POP
// j := GetClosestHex ( unit , tmp ) ;
82143: LD_ADDR_VAR 0 5
82147: PUSH
82148: LD_VAR 0 1
82152: PPUSH
82153: LD_VAR 0 6
82157: PPUSH
82158: CALL 81443 0 2
82162: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82163: LD_VAR 0 1
82167: PPUSH
82168: LD_VAR 0 5
82172: PUSH
82173: LD_INT 1
82175: ARRAY
82176: PPUSH
82177: LD_VAR 0 5
82181: PUSH
82182: LD_INT 2
82184: ARRAY
82185: PPUSH
82186: CALL_OW 111
// end ;
82190: LD_VAR 0 3
82194: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82195: LD_INT 0
82197: PPUSH
82198: PPUSH
82199: PPUSH
// uc_side = 0 ;
82200: LD_ADDR_OWVAR 20
82204: PUSH
82205: LD_INT 0
82207: ST_TO_ADDR
// uc_nation = 0 ;
82208: LD_ADDR_OWVAR 21
82212: PUSH
82213: LD_INT 0
82215: ST_TO_ADDR
// InitHc ;
82216: CALL_OW 19
// InitVc ;
82220: CALL_OW 20
// if mastodonts then
82224: LD_VAR 0 6
82228: IFFALSE 82295
// for i = 1 to mastodonts do
82230: LD_ADDR_VAR 0 11
82234: PUSH
82235: DOUBLE
82236: LD_INT 1
82238: DEC
82239: ST_TO_ADDR
82240: LD_VAR 0 6
82244: PUSH
82245: FOR_TO
82246: IFFALSE 82293
// begin vc_chassis := 31 ;
82248: LD_ADDR_OWVAR 37
82252: PUSH
82253: LD_INT 31
82255: ST_TO_ADDR
// vc_control := control_rider ;
82256: LD_ADDR_OWVAR 38
82260: PUSH
82261: LD_INT 4
82263: ST_TO_ADDR
// animal := CreateVehicle ;
82264: LD_ADDR_VAR 0 12
82268: PUSH
82269: CALL_OW 45
82273: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82274: LD_VAR 0 12
82278: PPUSH
82279: LD_VAR 0 8
82283: PPUSH
82284: LD_INT 0
82286: PPUSH
82287: CALL 89066 0 3
// end ;
82291: GO 82245
82293: POP
82294: POP
// if horses then
82295: LD_VAR 0 5
82299: IFFALSE 82366
// for i = 1 to horses do
82301: LD_ADDR_VAR 0 11
82305: PUSH
82306: DOUBLE
82307: LD_INT 1
82309: DEC
82310: ST_TO_ADDR
82311: LD_VAR 0 5
82315: PUSH
82316: FOR_TO
82317: IFFALSE 82364
// begin hc_class := 21 ;
82319: LD_ADDR_OWVAR 28
82323: PUSH
82324: LD_INT 21
82326: ST_TO_ADDR
// hc_gallery :=  ;
82327: LD_ADDR_OWVAR 33
82331: PUSH
82332: LD_STRING 
82334: ST_TO_ADDR
// animal := CreateHuman ;
82335: LD_ADDR_VAR 0 12
82339: PUSH
82340: CALL_OW 44
82344: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82345: LD_VAR 0 12
82349: PPUSH
82350: LD_VAR 0 8
82354: PPUSH
82355: LD_INT 0
82357: PPUSH
82358: CALL 89066 0 3
// end ;
82362: GO 82316
82364: POP
82365: POP
// if birds then
82366: LD_VAR 0 1
82370: IFFALSE 82437
// for i = 1 to birds do
82372: LD_ADDR_VAR 0 11
82376: PUSH
82377: DOUBLE
82378: LD_INT 1
82380: DEC
82381: ST_TO_ADDR
82382: LD_VAR 0 1
82386: PUSH
82387: FOR_TO
82388: IFFALSE 82435
// begin hc_class = 18 ;
82390: LD_ADDR_OWVAR 28
82394: PUSH
82395: LD_INT 18
82397: ST_TO_ADDR
// hc_gallery =  ;
82398: LD_ADDR_OWVAR 33
82402: PUSH
82403: LD_STRING 
82405: ST_TO_ADDR
// animal := CreateHuman ;
82406: LD_ADDR_VAR 0 12
82410: PUSH
82411: CALL_OW 44
82415: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82416: LD_VAR 0 12
82420: PPUSH
82421: LD_VAR 0 8
82425: PPUSH
82426: LD_INT 0
82428: PPUSH
82429: CALL 89066 0 3
// end ;
82433: GO 82387
82435: POP
82436: POP
// if tigers then
82437: LD_VAR 0 2
82441: IFFALSE 82525
// for i = 1 to tigers do
82443: LD_ADDR_VAR 0 11
82447: PUSH
82448: DOUBLE
82449: LD_INT 1
82451: DEC
82452: ST_TO_ADDR
82453: LD_VAR 0 2
82457: PUSH
82458: FOR_TO
82459: IFFALSE 82523
// begin hc_class = class_tiger ;
82461: LD_ADDR_OWVAR 28
82465: PUSH
82466: LD_INT 14
82468: ST_TO_ADDR
// hc_gallery =  ;
82469: LD_ADDR_OWVAR 33
82473: PUSH
82474: LD_STRING 
82476: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82477: LD_ADDR_OWVAR 35
82481: PUSH
82482: LD_INT 7
82484: NEG
82485: PPUSH
82486: LD_INT 7
82488: PPUSH
82489: CALL_OW 12
82493: ST_TO_ADDR
// animal := CreateHuman ;
82494: LD_ADDR_VAR 0 12
82498: PUSH
82499: CALL_OW 44
82503: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82504: LD_VAR 0 12
82508: PPUSH
82509: LD_VAR 0 8
82513: PPUSH
82514: LD_INT 0
82516: PPUSH
82517: CALL 89066 0 3
// end ;
82521: GO 82458
82523: POP
82524: POP
// if apemans then
82525: LD_VAR 0 3
82529: IFFALSE 82652
// for i = 1 to apemans do
82531: LD_ADDR_VAR 0 11
82535: PUSH
82536: DOUBLE
82537: LD_INT 1
82539: DEC
82540: ST_TO_ADDR
82541: LD_VAR 0 3
82545: PUSH
82546: FOR_TO
82547: IFFALSE 82650
// begin hc_class = class_apeman ;
82549: LD_ADDR_OWVAR 28
82553: PUSH
82554: LD_INT 12
82556: ST_TO_ADDR
// hc_gallery =  ;
82557: LD_ADDR_OWVAR 33
82561: PUSH
82562: LD_STRING 
82564: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
82565: LD_ADDR_OWVAR 35
82569: PUSH
82570: LD_INT 5
82572: NEG
82573: PPUSH
82574: LD_INT 5
82576: PPUSH
82577: CALL_OW 12
82581: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82582: LD_ADDR_OWVAR 31
82586: PUSH
82587: LD_INT 1
82589: PPUSH
82590: LD_INT 3
82592: PPUSH
82593: CALL_OW 12
82597: PUSH
82598: LD_INT 1
82600: PPUSH
82601: LD_INT 3
82603: PPUSH
82604: CALL_OW 12
82608: PUSH
82609: LD_INT 0
82611: PUSH
82612: LD_INT 0
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: ST_TO_ADDR
// animal := CreateHuman ;
82621: LD_ADDR_VAR 0 12
82625: PUSH
82626: CALL_OW 44
82630: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82631: LD_VAR 0 12
82635: PPUSH
82636: LD_VAR 0 8
82640: PPUSH
82641: LD_INT 0
82643: PPUSH
82644: CALL 89066 0 3
// end ;
82648: GO 82546
82650: POP
82651: POP
// if enchidnas then
82652: LD_VAR 0 4
82656: IFFALSE 82723
// for i = 1 to enchidnas do
82658: LD_ADDR_VAR 0 11
82662: PUSH
82663: DOUBLE
82664: LD_INT 1
82666: DEC
82667: ST_TO_ADDR
82668: LD_VAR 0 4
82672: PUSH
82673: FOR_TO
82674: IFFALSE 82721
// begin hc_class = 13 ;
82676: LD_ADDR_OWVAR 28
82680: PUSH
82681: LD_INT 13
82683: ST_TO_ADDR
// hc_gallery =  ;
82684: LD_ADDR_OWVAR 33
82688: PUSH
82689: LD_STRING 
82691: ST_TO_ADDR
// animal := CreateHuman ;
82692: LD_ADDR_VAR 0 12
82696: PUSH
82697: CALL_OW 44
82701: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82702: LD_VAR 0 12
82706: PPUSH
82707: LD_VAR 0 8
82711: PPUSH
82712: LD_INT 0
82714: PPUSH
82715: CALL 89066 0 3
// end ;
82719: GO 82673
82721: POP
82722: POP
// if fishes then
82723: LD_VAR 0 7
82727: IFFALSE 82794
// for i = 1 to fishes do
82729: LD_ADDR_VAR 0 11
82733: PUSH
82734: DOUBLE
82735: LD_INT 1
82737: DEC
82738: ST_TO_ADDR
82739: LD_VAR 0 7
82743: PUSH
82744: FOR_TO
82745: IFFALSE 82792
// begin hc_class = 20 ;
82747: LD_ADDR_OWVAR 28
82751: PUSH
82752: LD_INT 20
82754: ST_TO_ADDR
// hc_gallery =  ;
82755: LD_ADDR_OWVAR 33
82759: PUSH
82760: LD_STRING 
82762: ST_TO_ADDR
// animal := CreateHuman ;
82763: LD_ADDR_VAR 0 12
82767: PUSH
82768: CALL_OW 44
82772: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82773: LD_VAR 0 12
82777: PPUSH
82778: LD_VAR 0 9
82782: PPUSH
82783: LD_INT 0
82785: PPUSH
82786: CALL 89066 0 3
// end ;
82790: GO 82744
82792: POP
82793: POP
// end ;
82794: LD_VAR 0 10
82798: RET
// export function WantHeal ( sci , unit ) ; begin
82799: LD_INT 0
82801: PPUSH
// if GetTaskList ( sci ) > 0 then
82802: LD_VAR 0 1
82806: PPUSH
82807: CALL_OW 437
82811: PUSH
82812: LD_INT 0
82814: GREATER
82815: IFFALSE 82885
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82817: LD_VAR 0 1
82821: PPUSH
82822: CALL_OW 437
82826: PUSH
82827: LD_INT 1
82829: ARRAY
82830: PUSH
82831: LD_INT 1
82833: ARRAY
82834: PUSH
82835: LD_STRING l
82837: EQUAL
82838: PUSH
82839: LD_VAR 0 1
82843: PPUSH
82844: CALL_OW 437
82848: PUSH
82849: LD_INT 1
82851: ARRAY
82852: PUSH
82853: LD_INT 4
82855: ARRAY
82856: PUSH
82857: LD_VAR 0 2
82861: EQUAL
82862: AND
82863: IFFALSE 82875
// result := true else
82865: LD_ADDR_VAR 0 3
82869: PUSH
82870: LD_INT 1
82872: ST_TO_ADDR
82873: GO 82883
// result := false ;
82875: LD_ADDR_VAR 0 3
82879: PUSH
82880: LD_INT 0
82882: ST_TO_ADDR
// end else
82883: GO 82893
// result := false ;
82885: LD_ADDR_VAR 0 3
82889: PUSH
82890: LD_INT 0
82892: ST_TO_ADDR
// end ;
82893: LD_VAR 0 3
82897: RET
// export function HealTarget ( sci ) ; begin
82898: LD_INT 0
82900: PPUSH
// if not sci then
82901: LD_VAR 0 1
82905: NOT
82906: IFFALSE 82910
// exit ;
82908: GO 82975
// result := 0 ;
82910: LD_ADDR_VAR 0 2
82914: PUSH
82915: LD_INT 0
82917: ST_TO_ADDR
// if GetTaskList ( sci ) then
82918: LD_VAR 0 1
82922: PPUSH
82923: CALL_OW 437
82927: IFFALSE 82975
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82929: LD_VAR 0 1
82933: PPUSH
82934: CALL_OW 437
82938: PUSH
82939: LD_INT 1
82941: ARRAY
82942: PUSH
82943: LD_INT 1
82945: ARRAY
82946: PUSH
82947: LD_STRING l
82949: EQUAL
82950: IFFALSE 82975
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82952: LD_ADDR_VAR 0 2
82956: PUSH
82957: LD_VAR 0 1
82961: PPUSH
82962: CALL_OW 437
82966: PUSH
82967: LD_INT 1
82969: ARRAY
82970: PUSH
82971: LD_INT 4
82973: ARRAY
82974: ST_TO_ADDR
// end ;
82975: LD_VAR 0 2
82979: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82980: LD_INT 0
82982: PPUSH
82983: PPUSH
82984: PPUSH
82985: PPUSH
82986: PPUSH
82987: PPUSH
82988: PPUSH
82989: PPUSH
82990: PPUSH
82991: PPUSH
82992: PPUSH
82993: PPUSH
82994: PPUSH
82995: PPUSH
82996: PPUSH
82997: PPUSH
82998: PPUSH
82999: PPUSH
83000: PPUSH
83001: PPUSH
83002: PPUSH
83003: PPUSH
83004: PPUSH
83005: PPUSH
83006: PPUSH
83007: PPUSH
83008: PPUSH
83009: PPUSH
83010: PPUSH
83011: PPUSH
83012: PPUSH
83013: PPUSH
83014: PPUSH
83015: PPUSH
// if not list then
83016: LD_VAR 0 1
83020: NOT
83021: IFFALSE 83025
// exit ;
83023: GO 87677
// base := list [ 1 ] ;
83025: LD_ADDR_VAR 0 3
83029: PUSH
83030: LD_VAR 0 1
83034: PUSH
83035: LD_INT 1
83037: ARRAY
83038: ST_TO_ADDR
// group := list [ 2 ] ;
83039: LD_ADDR_VAR 0 4
83043: PUSH
83044: LD_VAR 0 1
83048: PUSH
83049: LD_INT 2
83051: ARRAY
83052: ST_TO_ADDR
// path := list [ 3 ] ;
83053: LD_ADDR_VAR 0 5
83057: PUSH
83058: LD_VAR 0 1
83062: PUSH
83063: LD_INT 3
83065: ARRAY
83066: ST_TO_ADDR
// flags := list [ 4 ] ;
83067: LD_ADDR_VAR 0 6
83071: PUSH
83072: LD_VAR 0 1
83076: PUSH
83077: LD_INT 4
83079: ARRAY
83080: ST_TO_ADDR
// mined := [ ] ;
83081: LD_ADDR_VAR 0 27
83085: PUSH
83086: EMPTY
83087: ST_TO_ADDR
// bombed := [ ] ;
83088: LD_ADDR_VAR 0 28
83092: PUSH
83093: EMPTY
83094: ST_TO_ADDR
// healers := [ ] ;
83095: LD_ADDR_VAR 0 31
83099: PUSH
83100: EMPTY
83101: ST_TO_ADDR
// to_heal := [ ] ;
83102: LD_ADDR_VAR 0 30
83106: PUSH
83107: EMPTY
83108: ST_TO_ADDR
// repairs := [ ] ;
83109: LD_ADDR_VAR 0 33
83113: PUSH
83114: EMPTY
83115: ST_TO_ADDR
// to_repair := [ ] ;
83116: LD_ADDR_VAR 0 32
83120: PUSH
83121: EMPTY
83122: ST_TO_ADDR
// if not group or not path then
83123: LD_VAR 0 4
83127: NOT
83128: PUSH
83129: LD_VAR 0 5
83133: NOT
83134: OR
83135: IFFALSE 83139
// exit ;
83137: GO 87677
// side := GetSide ( group [ 1 ] ) ;
83139: LD_ADDR_VAR 0 35
83143: PUSH
83144: LD_VAR 0 4
83148: PUSH
83149: LD_INT 1
83151: ARRAY
83152: PPUSH
83153: CALL_OW 255
83157: ST_TO_ADDR
// if flags then
83158: LD_VAR 0 6
83162: IFFALSE 83306
// begin f_ignore_area := flags [ 1 ] ;
83164: LD_ADDR_VAR 0 17
83168: PUSH
83169: LD_VAR 0 6
83173: PUSH
83174: LD_INT 1
83176: ARRAY
83177: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83178: LD_ADDR_VAR 0 18
83182: PUSH
83183: LD_VAR 0 6
83187: PUSH
83188: LD_INT 2
83190: ARRAY
83191: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83192: LD_ADDR_VAR 0 19
83196: PUSH
83197: LD_VAR 0 6
83201: PUSH
83202: LD_INT 3
83204: ARRAY
83205: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83206: LD_ADDR_VAR 0 20
83210: PUSH
83211: LD_VAR 0 6
83215: PUSH
83216: LD_INT 4
83218: ARRAY
83219: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83220: LD_ADDR_VAR 0 21
83224: PUSH
83225: LD_VAR 0 6
83229: PUSH
83230: LD_INT 5
83232: ARRAY
83233: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83234: LD_ADDR_VAR 0 22
83238: PUSH
83239: LD_VAR 0 6
83243: PUSH
83244: LD_INT 6
83246: ARRAY
83247: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83248: LD_ADDR_VAR 0 23
83252: PUSH
83253: LD_VAR 0 6
83257: PUSH
83258: LD_INT 7
83260: ARRAY
83261: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83262: LD_ADDR_VAR 0 24
83266: PUSH
83267: LD_VAR 0 6
83271: PUSH
83272: LD_INT 8
83274: ARRAY
83275: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83276: LD_ADDR_VAR 0 25
83280: PUSH
83281: LD_VAR 0 6
83285: PUSH
83286: LD_INT 9
83288: ARRAY
83289: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83290: LD_ADDR_VAR 0 26
83294: PUSH
83295: LD_VAR 0 6
83299: PUSH
83300: LD_INT 10
83302: ARRAY
83303: ST_TO_ADDR
// end else
83304: GO 83386
// begin f_ignore_area := false ;
83306: LD_ADDR_VAR 0 17
83310: PUSH
83311: LD_INT 0
83313: ST_TO_ADDR
// f_capture := false ;
83314: LD_ADDR_VAR 0 18
83318: PUSH
83319: LD_INT 0
83321: ST_TO_ADDR
// f_ignore_civ := false ;
83322: LD_ADDR_VAR 0 19
83326: PUSH
83327: LD_INT 0
83329: ST_TO_ADDR
// f_murder := false ;
83330: LD_ADDR_VAR 0 20
83334: PUSH
83335: LD_INT 0
83337: ST_TO_ADDR
// f_mines := false ;
83338: LD_ADDR_VAR 0 21
83342: PUSH
83343: LD_INT 0
83345: ST_TO_ADDR
// f_repair := false ;
83346: LD_ADDR_VAR 0 22
83350: PUSH
83351: LD_INT 0
83353: ST_TO_ADDR
// f_heal := false ;
83354: LD_ADDR_VAR 0 23
83358: PUSH
83359: LD_INT 0
83361: ST_TO_ADDR
// f_spacetime := false ;
83362: LD_ADDR_VAR 0 24
83366: PUSH
83367: LD_INT 0
83369: ST_TO_ADDR
// f_attack_depot := false ;
83370: LD_ADDR_VAR 0 25
83374: PUSH
83375: LD_INT 0
83377: ST_TO_ADDR
// f_crawl := false ;
83378: LD_ADDR_VAR 0 26
83382: PUSH
83383: LD_INT 0
83385: ST_TO_ADDR
// end ; if f_heal then
83386: LD_VAR 0 23
83390: IFFALSE 83417
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83392: LD_ADDR_VAR 0 31
83396: PUSH
83397: LD_VAR 0 4
83401: PPUSH
83402: LD_INT 25
83404: PUSH
83405: LD_INT 4
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PPUSH
83412: CALL_OW 72
83416: ST_TO_ADDR
// if f_repair then
83417: LD_VAR 0 22
83421: IFFALSE 83448
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83423: LD_ADDR_VAR 0 33
83427: PUSH
83428: LD_VAR 0 4
83432: PPUSH
83433: LD_INT 25
83435: PUSH
83436: LD_INT 3
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PPUSH
83443: CALL_OW 72
83447: ST_TO_ADDR
// units_path := [ ] ;
83448: LD_ADDR_VAR 0 16
83452: PUSH
83453: EMPTY
83454: ST_TO_ADDR
// for i = 1 to group do
83455: LD_ADDR_VAR 0 7
83459: PUSH
83460: DOUBLE
83461: LD_INT 1
83463: DEC
83464: ST_TO_ADDR
83465: LD_VAR 0 4
83469: PUSH
83470: FOR_TO
83471: IFFALSE 83500
// units_path := Replace ( units_path , i , path ) ;
83473: LD_ADDR_VAR 0 16
83477: PUSH
83478: LD_VAR 0 16
83482: PPUSH
83483: LD_VAR 0 7
83487: PPUSH
83488: LD_VAR 0 5
83492: PPUSH
83493: CALL_OW 1
83497: ST_TO_ADDR
83498: GO 83470
83500: POP
83501: POP
// repeat for i = group downto 1 do
83502: LD_ADDR_VAR 0 7
83506: PUSH
83507: DOUBLE
83508: LD_VAR 0 4
83512: INC
83513: ST_TO_ADDR
83514: LD_INT 1
83516: PUSH
83517: FOR_DOWNTO
83518: IFFALSE 87640
// begin wait ( 5 ) ;
83520: LD_INT 5
83522: PPUSH
83523: CALL_OW 67
// tmp := [ ] ;
83527: LD_ADDR_VAR 0 14
83531: PUSH
83532: EMPTY
83533: ST_TO_ADDR
// attacking := false ;
83534: LD_ADDR_VAR 0 29
83538: PUSH
83539: LD_INT 0
83541: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83542: LD_VAR 0 4
83546: PUSH
83547: LD_VAR 0 7
83551: ARRAY
83552: PPUSH
83553: CALL_OW 301
83557: PUSH
83558: LD_VAR 0 4
83562: PUSH
83563: LD_VAR 0 7
83567: ARRAY
83568: NOT
83569: OR
83570: IFFALSE 83679
// begin if GetType ( group [ i ] ) = unit_human then
83572: LD_VAR 0 4
83576: PUSH
83577: LD_VAR 0 7
83581: ARRAY
83582: PPUSH
83583: CALL_OW 247
83587: PUSH
83588: LD_INT 1
83590: EQUAL
83591: IFFALSE 83637
// begin to_heal := to_heal diff group [ i ] ;
83593: LD_ADDR_VAR 0 30
83597: PUSH
83598: LD_VAR 0 30
83602: PUSH
83603: LD_VAR 0 4
83607: PUSH
83608: LD_VAR 0 7
83612: ARRAY
83613: DIFF
83614: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83615: LD_ADDR_VAR 0 31
83619: PUSH
83620: LD_VAR 0 31
83624: PUSH
83625: LD_VAR 0 4
83629: PUSH
83630: LD_VAR 0 7
83634: ARRAY
83635: DIFF
83636: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83637: LD_ADDR_VAR 0 4
83641: PUSH
83642: LD_VAR 0 4
83646: PPUSH
83647: LD_VAR 0 7
83651: PPUSH
83652: CALL_OW 3
83656: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83657: LD_ADDR_VAR 0 16
83661: PUSH
83662: LD_VAR 0 16
83666: PPUSH
83667: LD_VAR 0 7
83671: PPUSH
83672: CALL_OW 3
83676: ST_TO_ADDR
// continue ;
83677: GO 83517
// end ; if f_repair then
83679: LD_VAR 0 22
83683: IFFALSE 84172
// begin if GetType ( group [ i ] ) = unit_vehicle then
83685: LD_VAR 0 4
83689: PUSH
83690: LD_VAR 0 7
83694: ARRAY
83695: PPUSH
83696: CALL_OW 247
83700: PUSH
83701: LD_INT 2
83703: EQUAL
83704: IFFALSE 83894
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83706: LD_VAR 0 4
83710: PUSH
83711: LD_VAR 0 7
83715: ARRAY
83716: PPUSH
83717: CALL_OW 256
83721: PUSH
83722: LD_INT 700
83724: LESS
83725: PUSH
83726: LD_VAR 0 4
83730: PUSH
83731: LD_VAR 0 7
83735: ARRAY
83736: PUSH
83737: LD_VAR 0 32
83741: IN
83742: NOT
83743: AND
83744: IFFALSE 83768
// to_repair := to_repair union group [ i ] ;
83746: LD_ADDR_VAR 0 32
83750: PUSH
83751: LD_VAR 0 32
83755: PUSH
83756: LD_VAR 0 4
83760: PUSH
83761: LD_VAR 0 7
83765: ARRAY
83766: UNION
83767: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83768: LD_VAR 0 4
83772: PUSH
83773: LD_VAR 0 7
83777: ARRAY
83778: PPUSH
83779: CALL_OW 256
83783: PUSH
83784: LD_INT 1000
83786: EQUAL
83787: PUSH
83788: LD_VAR 0 4
83792: PUSH
83793: LD_VAR 0 7
83797: ARRAY
83798: PUSH
83799: LD_VAR 0 32
83803: IN
83804: AND
83805: IFFALSE 83829
// to_repair := to_repair diff group [ i ] ;
83807: LD_ADDR_VAR 0 32
83811: PUSH
83812: LD_VAR 0 32
83816: PUSH
83817: LD_VAR 0 4
83821: PUSH
83822: LD_VAR 0 7
83826: ARRAY
83827: DIFF
83828: ST_TO_ADDR
// if group [ i ] in to_repair then
83829: LD_VAR 0 4
83833: PUSH
83834: LD_VAR 0 7
83838: ARRAY
83839: PUSH
83840: LD_VAR 0 32
83844: IN
83845: IFFALSE 83892
// begin if not IsInArea ( group [ i ] , f_repair ) then
83847: LD_VAR 0 4
83851: PUSH
83852: LD_VAR 0 7
83856: ARRAY
83857: PPUSH
83858: LD_VAR 0 22
83862: PPUSH
83863: CALL_OW 308
83867: NOT
83868: IFFALSE 83890
// ComMoveToArea ( group [ i ] , f_repair ) ;
83870: LD_VAR 0 4
83874: PUSH
83875: LD_VAR 0 7
83879: ARRAY
83880: PPUSH
83881: LD_VAR 0 22
83885: PPUSH
83886: CALL_OW 113
// continue ;
83890: GO 83517
// end ; end else
83892: GO 84172
// if group [ i ] in repairs then
83894: LD_VAR 0 4
83898: PUSH
83899: LD_VAR 0 7
83903: ARRAY
83904: PUSH
83905: LD_VAR 0 33
83909: IN
83910: IFFALSE 84172
// begin if IsInUnit ( group [ i ] ) then
83912: LD_VAR 0 4
83916: PUSH
83917: LD_VAR 0 7
83921: ARRAY
83922: PPUSH
83923: CALL_OW 310
83927: IFFALSE 83995
// begin z := IsInUnit ( group [ i ] ) ;
83929: LD_ADDR_VAR 0 13
83933: PUSH
83934: LD_VAR 0 4
83938: PUSH
83939: LD_VAR 0 7
83943: ARRAY
83944: PPUSH
83945: CALL_OW 310
83949: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83950: LD_VAR 0 13
83954: PUSH
83955: LD_VAR 0 32
83959: IN
83960: PUSH
83961: LD_VAR 0 13
83965: PPUSH
83966: LD_VAR 0 22
83970: PPUSH
83971: CALL_OW 308
83975: AND
83976: IFFALSE 83993
// ComExitVehicle ( group [ i ] ) ;
83978: LD_VAR 0 4
83982: PUSH
83983: LD_VAR 0 7
83987: ARRAY
83988: PPUSH
83989: CALL_OW 121
// end else
83993: GO 84172
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83995: LD_ADDR_VAR 0 13
83999: PUSH
84000: LD_VAR 0 4
84004: PPUSH
84005: LD_INT 95
84007: PUSH
84008: LD_VAR 0 22
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 58
84019: PUSH
84020: EMPTY
84021: LIST
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PPUSH
84027: CALL_OW 72
84031: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84032: LD_VAR 0 4
84036: PUSH
84037: LD_VAR 0 7
84041: ARRAY
84042: PPUSH
84043: CALL_OW 314
84047: NOT
84048: IFFALSE 84170
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84050: LD_ADDR_VAR 0 10
84054: PUSH
84055: LD_VAR 0 13
84059: PPUSH
84060: LD_VAR 0 4
84064: PUSH
84065: LD_VAR 0 7
84069: ARRAY
84070: PPUSH
84071: CALL_OW 74
84075: ST_TO_ADDR
// if not x then
84076: LD_VAR 0 10
84080: NOT
84081: IFFALSE 84085
// continue ;
84083: GO 83517
// if GetLives ( x ) < 1000 then
84085: LD_VAR 0 10
84089: PPUSH
84090: CALL_OW 256
84094: PUSH
84095: LD_INT 1000
84097: LESS
84098: IFFALSE 84122
// ComRepairVehicle ( group [ i ] , x ) else
84100: LD_VAR 0 4
84104: PUSH
84105: LD_VAR 0 7
84109: ARRAY
84110: PPUSH
84111: LD_VAR 0 10
84115: PPUSH
84116: CALL_OW 129
84120: GO 84170
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84122: LD_VAR 0 23
84126: PUSH
84127: LD_VAR 0 4
84131: PUSH
84132: LD_VAR 0 7
84136: ARRAY
84137: PPUSH
84138: CALL_OW 256
84142: PUSH
84143: LD_INT 1000
84145: LESS
84146: AND
84147: NOT
84148: IFFALSE 84170
// ComEnterUnit ( group [ i ] , x ) ;
84150: LD_VAR 0 4
84154: PUSH
84155: LD_VAR 0 7
84159: ARRAY
84160: PPUSH
84161: LD_VAR 0 10
84165: PPUSH
84166: CALL_OW 120
// end ; continue ;
84170: GO 83517
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84172: LD_VAR 0 23
84176: PUSH
84177: LD_VAR 0 4
84181: PUSH
84182: LD_VAR 0 7
84186: ARRAY
84187: PPUSH
84188: CALL_OW 247
84192: PUSH
84193: LD_INT 1
84195: EQUAL
84196: AND
84197: IFFALSE 84675
// begin if group [ i ] in healers then
84199: LD_VAR 0 4
84203: PUSH
84204: LD_VAR 0 7
84208: ARRAY
84209: PUSH
84210: LD_VAR 0 31
84214: IN
84215: IFFALSE 84488
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84217: LD_VAR 0 4
84221: PUSH
84222: LD_VAR 0 7
84226: ARRAY
84227: PPUSH
84228: LD_VAR 0 23
84232: PPUSH
84233: CALL_OW 308
84237: NOT
84238: PUSH
84239: LD_VAR 0 4
84243: PUSH
84244: LD_VAR 0 7
84248: ARRAY
84249: PPUSH
84250: CALL_OW 314
84254: NOT
84255: AND
84256: IFFALSE 84280
// ComMoveToArea ( group [ i ] , f_heal ) else
84258: LD_VAR 0 4
84262: PUSH
84263: LD_VAR 0 7
84267: ARRAY
84268: PPUSH
84269: LD_VAR 0 23
84273: PPUSH
84274: CALL_OW 113
84278: GO 84486
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84280: LD_VAR 0 4
84284: PUSH
84285: LD_VAR 0 7
84289: ARRAY
84290: PPUSH
84291: CALL 82898 0 1
84295: PPUSH
84296: CALL_OW 256
84300: PUSH
84301: LD_INT 1000
84303: EQUAL
84304: IFFALSE 84323
// ComStop ( group [ i ] ) else
84306: LD_VAR 0 4
84310: PUSH
84311: LD_VAR 0 7
84315: ARRAY
84316: PPUSH
84317: CALL_OW 141
84321: GO 84486
// if not HasTask ( group [ i ] ) and to_heal then
84323: LD_VAR 0 4
84327: PUSH
84328: LD_VAR 0 7
84332: ARRAY
84333: PPUSH
84334: CALL_OW 314
84338: NOT
84339: PUSH
84340: LD_VAR 0 30
84344: AND
84345: IFFALSE 84486
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84347: LD_ADDR_VAR 0 13
84351: PUSH
84352: LD_VAR 0 30
84356: PPUSH
84357: LD_INT 3
84359: PUSH
84360: LD_INT 54
84362: PUSH
84363: EMPTY
84364: LIST
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PPUSH
84370: CALL_OW 72
84374: PPUSH
84375: LD_VAR 0 4
84379: PUSH
84380: LD_VAR 0 7
84384: ARRAY
84385: PPUSH
84386: CALL_OW 74
84390: ST_TO_ADDR
// if z then
84391: LD_VAR 0 13
84395: IFFALSE 84486
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84397: LD_INT 91
84399: PUSH
84400: LD_VAR 0 13
84404: PUSH
84405: LD_INT 10
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 81
84415: PUSH
84416: LD_VAR 0 13
84420: PPUSH
84421: CALL_OW 255
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PPUSH
84434: CALL_OW 69
84438: PUSH
84439: LD_INT 0
84441: EQUAL
84442: IFFALSE 84466
// ComHeal ( group [ i ] , z ) else
84444: LD_VAR 0 4
84448: PUSH
84449: LD_VAR 0 7
84453: ARRAY
84454: PPUSH
84455: LD_VAR 0 13
84459: PPUSH
84460: CALL_OW 128
84464: GO 84486
// ComMoveToArea ( group [ i ] , f_heal ) ;
84466: LD_VAR 0 4
84470: PUSH
84471: LD_VAR 0 7
84475: ARRAY
84476: PPUSH
84477: LD_VAR 0 23
84481: PPUSH
84482: CALL_OW 113
// end ; continue ;
84486: GO 83517
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84488: LD_VAR 0 4
84492: PUSH
84493: LD_VAR 0 7
84497: ARRAY
84498: PPUSH
84499: CALL_OW 256
84503: PUSH
84504: LD_INT 700
84506: LESS
84507: PUSH
84508: LD_VAR 0 4
84512: PUSH
84513: LD_VAR 0 7
84517: ARRAY
84518: PUSH
84519: LD_VAR 0 30
84523: IN
84524: NOT
84525: AND
84526: IFFALSE 84550
// to_heal := to_heal union group [ i ] ;
84528: LD_ADDR_VAR 0 30
84532: PUSH
84533: LD_VAR 0 30
84537: PUSH
84538: LD_VAR 0 4
84542: PUSH
84543: LD_VAR 0 7
84547: ARRAY
84548: UNION
84549: ST_TO_ADDR
// if group [ i ] in to_heal then
84550: LD_VAR 0 4
84554: PUSH
84555: LD_VAR 0 7
84559: ARRAY
84560: PUSH
84561: LD_VAR 0 30
84565: IN
84566: IFFALSE 84675
// begin if GetLives ( group [ i ] ) = 1000 then
84568: LD_VAR 0 4
84572: PUSH
84573: LD_VAR 0 7
84577: ARRAY
84578: PPUSH
84579: CALL_OW 256
84583: PUSH
84584: LD_INT 1000
84586: EQUAL
84587: IFFALSE 84613
// to_heal := to_heal diff group [ i ] else
84589: LD_ADDR_VAR 0 30
84593: PUSH
84594: LD_VAR 0 30
84598: PUSH
84599: LD_VAR 0 4
84603: PUSH
84604: LD_VAR 0 7
84608: ARRAY
84609: DIFF
84610: ST_TO_ADDR
84611: GO 84675
// begin if not IsInArea ( group [ i ] , to_heal ) then
84613: LD_VAR 0 4
84617: PUSH
84618: LD_VAR 0 7
84622: ARRAY
84623: PPUSH
84624: LD_VAR 0 30
84628: PPUSH
84629: CALL_OW 308
84633: NOT
84634: IFFALSE 84658
// ComMoveToArea ( group [ i ] , f_heal ) else
84636: LD_VAR 0 4
84640: PUSH
84641: LD_VAR 0 7
84645: ARRAY
84646: PPUSH
84647: LD_VAR 0 23
84651: PPUSH
84652: CALL_OW 113
84656: GO 84673
// ComHold ( group [ i ] ) ;
84658: LD_VAR 0 4
84662: PUSH
84663: LD_VAR 0 7
84667: ARRAY
84668: PPUSH
84669: CALL_OW 140
// continue ;
84673: GO 83517
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84675: LD_VAR 0 4
84679: PUSH
84680: LD_VAR 0 7
84684: ARRAY
84685: PPUSH
84686: LD_INT 10
84688: PPUSH
84689: CALL 81295 0 2
84693: NOT
84694: PUSH
84695: LD_VAR 0 16
84699: PUSH
84700: LD_VAR 0 7
84704: ARRAY
84705: PUSH
84706: EMPTY
84707: EQUAL
84708: NOT
84709: AND
84710: IFFALSE 84976
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84712: LD_VAR 0 4
84716: PUSH
84717: LD_VAR 0 7
84721: ARRAY
84722: PPUSH
84723: CALL_OW 262
84727: PUSH
84728: LD_INT 1
84730: PUSH
84731: LD_INT 2
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: IN
84738: IFFALSE 84779
// if GetFuel ( group [ i ] ) < 10 then
84740: LD_VAR 0 4
84744: PUSH
84745: LD_VAR 0 7
84749: ARRAY
84750: PPUSH
84751: CALL_OW 261
84755: PUSH
84756: LD_INT 10
84758: LESS
84759: IFFALSE 84779
// SetFuel ( group [ i ] , 12 ) ;
84761: LD_VAR 0 4
84765: PUSH
84766: LD_VAR 0 7
84770: ARRAY
84771: PPUSH
84772: LD_INT 12
84774: PPUSH
84775: CALL_OW 240
// if units_path [ i ] then
84779: LD_VAR 0 16
84783: PUSH
84784: LD_VAR 0 7
84788: ARRAY
84789: IFFALSE 84974
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84791: LD_VAR 0 4
84795: PUSH
84796: LD_VAR 0 7
84800: ARRAY
84801: PPUSH
84802: LD_VAR 0 16
84806: PUSH
84807: LD_VAR 0 7
84811: ARRAY
84812: PUSH
84813: LD_INT 1
84815: ARRAY
84816: PUSH
84817: LD_INT 1
84819: ARRAY
84820: PPUSH
84821: LD_VAR 0 16
84825: PUSH
84826: LD_VAR 0 7
84830: ARRAY
84831: PUSH
84832: LD_INT 1
84834: ARRAY
84835: PUSH
84836: LD_INT 2
84838: ARRAY
84839: PPUSH
84840: CALL_OW 297
84844: PUSH
84845: LD_INT 6
84847: GREATER
84848: IFFALSE 84923
// begin if not HasTask ( group [ i ] ) then
84850: LD_VAR 0 4
84854: PUSH
84855: LD_VAR 0 7
84859: ARRAY
84860: PPUSH
84861: CALL_OW 314
84865: NOT
84866: IFFALSE 84921
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84868: LD_VAR 0 4
84872: PUSH
84873: LD_VAR 0 7
84877: ARRAY
84878: PPUSH
84879: LD_VAR 0 16
84883: PUSH
84884: LD_VAR 0 7
84888: ARRAY
84889: PUSH
84890: LD_INT 1
84892: ARRAY
84893: PUSH
84894: LD_INT 1
84896: ARRAY
84897: PPUSH
84898: LD_VAR 0 16
84902: PUSH
84903: LD_VAR 0 7
84907: ARRAY
84908: PUSH
84909: LD_INT 1
84911: ARRAY
84912: PUSH
84913: LD_INT 2
84915: ARRAY
84916: PPUSH
84917: CALL_OW 114
// end else
84921: GO 84974
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84923: LD_ADDR_VAR 0 15
84927: PUSH
84928: LD_VAR 0 16
84932: PUSH
84933: LD_VAR 0 7
84937: ARRAY
84938: PPUSH
84939: LD_INT 1
84941: PPUSH
84942: CALL_OW 3
84946: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84947: LD_ADDR_VAR 0 16
84951: PUSH
84952: LD_VAR 0 16
84956: PPUSH
84957: LD_VAR 0 7
84961: PPUSH
84962: LD_VAR 0 15
84966: PPUSH
84967: CALL_OW 1
84971: ST_TO_ADDR
// continue ;
84972: GO 83517
// end ; end ; end else
84974: GO 87638
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84976: LD_ADDR_VAR 0 14
84980: PUSH
84981: LD_INT 81
84983: PUSH
84984: LD_VAR 0 4
84988: PUSH
84989: LD_VAR 0 7
84993: ARRAY
84994: PPUSH
84995: CALL_OW 255
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: PPUSH
85004: CALL_OW 69
85008: ST_TO_ADDR
// if not tmp then
85009: LD_VAR 0 14
85013: NOT
85014: IFFALSE 85018
// continue ;
85016: GO 83517
// if f_ignore_area then
85018: LD_VAR 0 17
85022: IFFALSE 85110
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85024: LD_ADDR_VAR 0 15
85028: PUSH
85029: LD_VAR 0 14
85033: PPUSH
85034: LD_INT 3
85036: PUSH
85037: LD_INT 92
85039: PUSH
85040: LD_VAR 0 17
85044: PUSH
85045: LD_INT 1
85047: ARRAY
85048: PUSH
85049: LD_VAR 0 17
85053: PUSH
85054: LD_INT 2
85056: ARRAY
85057: PUSH
85058: LD_VAR 0 17
85062: PUSH
85063: LD_INT 3
85065: ARRAY
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PPUSH
85077: CALL_OW 72
85081: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85082: LD_VAR 0 14
85086: PUSH
85087: LD_VAR 0 15
85091: DIFF
85092: IFFALSE 85110
// tmp := tmp diff tmp2 ;
85094: LD_ADDR_VAR 0 14
85098: PUSH
85099: LD_VAR 0 14
85103: PUSH
85104: LD_VAR 0 15
85108: DIFF
85109: ST_TO_ADDR
// end ; if not f_murder then
85110: LD_VAR 0 20
85114: NOT
85115: IFFALSE 85173
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85117: LD_ADDR_VAR 0 15
85121: PUSH
85122: LD_VAR 0 14
85126: PPUSH
85127: LD_INT 3
85129: PUSH
85130: LD_INT 50
85132: PUSH
85133: EMPTY
85134: LIST
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PPUSH
85140: CALL_OW 72
85144: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85145: LD_VAR 0 14
85149: PUSH
85150: LD_VAR 0 15
85154: DIFF
85155: IFFALSE 85173
// tmp := tmp diff tmp2 ;
85157: LD_ADDR_VAR 0 14
85161: PUSH
85162: LD_VAR 0 14
85166: PUSH
85167: LD_VAR 0 15
85171: DIFF
85172: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85173: LD_ADDR_VAR 0 14
85177: PUSH
85178: LD_VAR 0 4
85182: PUSH
85183: LD_VAR 0 7
85187: ARRAY
85188: PPUSH
85189: LD_VAR 0 14
85193: PPUSH
85194: LD_INT 1
85196: PPUSH
85197: LD_INT 1
85199: PPUSH
85200: CALL 54938 0 4
85204: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85205: LD_VAR 0 4
85209: PUSH
85210: LD_VAR 0 7
85214: ARRAY
85215: PPUSH
85216: CALL_OW 257
85220: PUSH
85221: LD_INT 1
85223: EQUAL
85224: IFFALSE 85672
// begin if WantPlant ( group [ i ] ) then
85226: LD_VAR 0 4
85230: PUSH
85231: LD_VAR 0 7
85235: ARRAY
85236: PPUSH
85237: CALL 54439 0 1
85241: IFFALSE 85245
// continue ;
85243: GO 83517
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85245: LD_VAR 0 18
85249: PUSH
85250: LD_VAR 0 4
85254: PUSH
85255: LD_VAR 0 7
85259: ARRAY
85260: PPUSH
85261: CALL_OW 310
85265: NOT
85266: AND
85267: PUSH
85268: LD_VAR 0 14
85272: PUSH
85273: LD_INT 1
85275: ARRAY
85276: PUSH
85277: LD_VAR 0 14
85281: PPUSH
85282: LD_INT 21
85284: PUSH
85285: LD_INT 2
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PUSH
85292: LD_INT 58
85294: PUSH
85295: EMPTY
85296: LIST
85297: PUSH
85298: EMPTY
85299: LIST
85300: LIST
85301: PPUSH
85302: CALL_OW 72
85306: IN
85307: AND
85308: IFFALSE 85344
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85310: LD_VAR 0 4
85314: PUSH
85315: LD_VAR 0 7
85319: ARRAY
85320: PPUSH
85321: LD_VAR 0 14
85325: PUSH
85326: LD_INT 1
85328: ARRAY
85329: PPUSH
85330: CALL_OW 120
// attacking := true ;
85334: LD_ADDR_VAR 0 29
85338: PUSH
85339: LD_INT 1
85341: ST_TO_ADDR
// continue ;
85342: GO 83517
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85344: LD_VAR 0 26
85348: PUSH
85349: LD_VAR 0 4
85353: PUSH
85354: LD_VAR 0 7
85358: ARRAY
85359: PPUSH
85360: CALL_OW 257
85364: PUSH
85365: LD_INT 1
85367: EQUAL
85368: AND
85369: PUSH
85370: LD_VAR 0 4
85374: PUSH
85375: LD_VAR 0 7
85379: ARRAY
85380: PPUSH
85381: CALL_OW 256
85385: PUSH
85386: LD_INT 800
85388: LESS
85389: AND
85390: PUSH
85391: LD_VAR 0 4
85395: PUSH
85396: LD_VAR 0 7
85400: ARRAY
85401: PPUSH
85402: CALL_OW 318
85406: NOT
85407: AND
85408: IFFALSE 85425
// ComCrawl ( group [ i ] ) ;
85410: LD_VAR 0 4
85414: PUSH
85415: LD_VAR 0 7
85419: ARRAY
85420: PPUSH
85421: CALL_OW 137
// if f_mines then
85425: LD_VAR 0 21
85429: IFFALSE 85672
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85431: LD_VAR 0 14
85435: PUSH
85436: LD_INT 1
85438: ARRAY
85439: PPUSH
85440: CALL_OW 247
85444: PUSH
85445: LD_INT 3
85447: EQUAL
85448: PUSH
85449: LD_VAR 0 14
85453: PUSH
85454: LD_INT 1
85456: ARRAY
85457: PUSH
85458: LD_VAR 0 27
85462: IN
85463: NOT
85464: AND
85465: IFFALSE 85672
// begin x := GetX ( tmp [ 1 ] ) ;
85467: LD_ADDR_VAR 0 10
85471: PUSH
85472: LD_VAR 0 14
85476: PUSH
85477: LD_INT 1
85479: ARRAY
85480: PPUSH
85481: CALL_OW 250
85485: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85486: LD_ADDR_VAR 0 11
85490: PUSH
85491: LD_VAR 0 14
85495: PUSH
85496: LD_INT 1
85498: ARRAY
85499: PPUSH
85500: CALL_OW 251
85504: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85505: LD_ADDR_VAR 0 12
85509: PUSH
85510: LD_VAR 0 4
85514: PUSH
85515: LD_VAR 0 7
85519: ARRAY
85520: PPUSH
85521: CALL 81380 0 1
85525: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85526: LD_VAR 0 4
85530: PUSH
85531: LD_VAR 0 7
85535: ARRAY
85536: PPUSH
85537: LD_VAR 0 10
85541: PPUSH
85542: LD_VAR 0 11
85546: PPUSH
85547: LD_VAR 0 14
85551: PUSH
85552: LD_INT 1
85554: ARRAY
85555: PPUSH
85556: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85560: LD_VAR 0 4
85564: PUSH
85565: LD_VAR 0 7
85569: ARRAY
85570: PPUSH
85571: LD_VAR 0 10
85575: PPUSH
85576: LD_VAR 0 12
85580: PPUSH
85581: LD_INT 7
85583: PPUSH
85584: CALL_OW 272
85588: PPUSH
85589: LD_VAR 0 11
85593: PPUSH
85594: LD_VAR 0 12
85598: PPUSH
85599: LD_INT 7
85601: PPUSH
85602: CALL_OW 273
85606: PPUSH
85607: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85611: LD_VAR 0 4
85615: PUSH
85616: LD_VAR 0 7
85620: ARRAY
85621: PPUSH
85622: LD_INT 71
85624: PPUSH
85625: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85629: LD_ADDR_VAR 0 27
85633: PUSH
85634: LD_VAR 0 27
85638: PPUSH
85639: LD_VAR 0 27
85643: PUSH
85644: LD_INT 1
85646: PLUS
85647: PPUSH
85648: LD_VAR 0 14
85652: PUSH
85653: LD_INT 1
85655: ARRAY
85656: PPUSH
85657: CALL_OW 1
85661: ST_TO_ADDR
// attacking := true ;
85662: LD_ADDR_VAR 0 29
85666: PUSH
85667: LD_INT 1
85669: ST_TO_ADDR
// continue ;
85670: GO 83517
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85672: LD_VAR 0 4
85676: PUSH
85677: LD_VAR 0 7
85681: ARRAY
85682: PPUSH
85683: CALL_OW 257
85687: PUSH
85688: LD_INT 17
85690: EQUAL
85691: PUSH
85692: LD_VAR 0 4
85696: PUSH
85697: LD_VAR 0 7
85701: ARRAY
85702: PPUSH
85703: CALL_OW 110
85707: PUSH
85708: LD_INT 71
85710: EQUAL
85711: NOT
85712: AND
85713: IFFALSE 85859
// begin attacking := false ;
85715: LD_ADDR_VAR 0 29
85719: PUSH
85720: LD_INT 0
85722: ST_TO_ADDR
// k := 5 ;
85723: LD_ADDR_VAR 0 9
85727: PUSH
85728: LD_INT 5
85730: ST_TO_ADDR
// if tmp < k then
85731: LD_VAR 0 14
85735: PUSH
85736: LD_VAR 0 9
85740: LESS
85741: IFFALSE 85753
// k := tmp ;
85743: LD_ADDR_VAR 0 9
85747: PUSH
85748: LD_VAR 0 14
85752: ST_TO_ADDR
// for j = 1 to k do
85753: LD_ADDR_VAR 0 8
85757: PUSH
85758: DOUBLE
85759: LD_INT 1
85761: DEC
85762: ST_TO_ADDR
85763: LD_VAR 0 9
85767: PUSH
85768: FOR_TO
85769: IFFALSE 85857
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85771: LD_VAR 0 14
85775: PUSH
85776: LD_VAR 0 8
85780: ARRAY
85781: PUSH
85782: LD_VAR 0 14
85786: PPUSH
85787: LD_INT 58
85789: PUSH
85790: EMPTY
85791: LIST
85792: PPUSH
85793: CALL_OW 72
85797: IN
85798: NOT
85799: IFFALSE 85855
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85801: LD_VAR 0 4
85805: PUSH
85806: LD_VAR 0 7
85810: ARRAY
85811: PPUSH
85812: LD_VAR 0 14
85816: PUSH
85817: LD_VAR 0 8
85821: ARRAY
85822: PPUSH
85823: CALL_OW 115
// attacking := true ;
85827: LD_ADDR_VAR 0 29
85831: PUSH
85832: LD_INT 1
85834: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85835: LD_VAR 0 4
85839: PUSH
85840: LD_VAR 0 7
85844: ARRAY
85845: PPUSH
85846: LD_INT 71
85848: PPUSH
85849: CALL_OW 109
// continue ;
85853: GO 85768
// end ; end ;
85855: GO 85768
85857: POP
85858: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85859: LD_VAR 0 4
85863: PUSH
85864: LD_VAR 0 7
85868: ARRAY
85869: PPUSH
85870: CALL_OW 257
85874: PUSH
85875: LD_INT 8
85877: EQUAL
85878: PUSH
85879: LD_VAR 0 4
85883: PUSH
85884: LD_VAR 0 7
85888: ARRAY
85889: PPUSH
85890: CALL_OW 264
85894: PUSH
85895: LD_INT 28
85897: PUSH
85898: LD_INT 45
85900: PUSH
85901: LD_INT 7
85903: PUSH
85904: LD_INT 47
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: IN
85913: OR
85914: IFFALSE 86170
// begin attacking := false ;
85916: LD_ADDR_VAR 0 29
85920: PUSH
85921: LD_INT 0
85923: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85924: LD_VAR 0 14
85928: PUSH
85929: LD_INT 1
85931: ARRAY
85932: PPUSH
85933: CALL_OW 266
85937: PUSH
85938: LD_INT 32
85940: PUSH
85941: LD_INT 31
85943: PUSH
85944: LD_INT 33
85946: PUSH
85947: LD_INT 4
85949: PUSH
85950: LD_INT 5
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: IN
85960: IFFALSE 86146
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85962: LD_ADDR_VAR 0 9
85966: PUSH
85967: LD_VAR 0 14
85971: PUSH
85972: LD_INT 1
85974: ARRAY
85975: PPUSH
85976: CALL_OW 266
85980: PPUSH
85981: LD_VAR 0 14
85985: PUSH
85986: LD_INT 1
85988: ARRAY
85989: PPUSH
85990: CALL_OW 250
85994: PPUSH
85995: LD_VAR 0 14
85999: PUSH
86000: LD_INT 1
86002: ARRAY
86003: PPUSH
86004: CALL_OW 251
86008: PPUSH
86009: LD_VAR 0 14
86013: PUSH
86014: LD_INT 1
86016: ARRAY
86017: PPUSH
86018: CALL_OW 254
86022: PPUSH
86023: LD_VAR 0 14
86027: PUSH
86028: LD_INT 1
86030: ARRAY
86031: PPUSH
86032: CALL_OW 248
86036: PPUSH
86037: LD_INT 0
86039: PPUSH
86040: CALL 62750 0 6
86044: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86045: LD_ADDR_VAR 0 8
86049: PUSH
86050: LD_VAR 0 4
86054: PUSH
86055: LD_VAR 0 7
86059: ARRAY
86060: PPUSH
86061: LD_VAR 0 9
86065: PPUSH
86066: CALL 81443 0 2
86070: ST_TO_ADDR
// if j then
86071: LD_VAR 0 8
86075: IFFALSE 86144
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86077: LD_VAR 0 8
86081: PUSH
86082: LD_INT 1
86084: ARRAY
86085: PPUSH
86086: LD_VAR 0 8
86090: PUSH
86091: LD_INT 2
86093: ARRAY
86094: PPUSH
86095: CALL_OW 488
86099: IFFALSE 86144
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86101: LD_VAR 0 4
86105: PUSH
86106: LD_VAR 0 7
86110: ARRAY
86111: PPUSH
86112: LD_VAR 0 8
86116: PUSH
86117: LD_INT 1
86119: ARRAY
86120: PPUSH
86121: LD_VAR 0 8
86125: PUSH
86126: LD_INT 2
86128: ARRAY
86129: PPUSH
86130: CALL_OW 116
// attacking := true ;
86134: LD_ADDR_VAR 0 29
86138: PUSH
86139: LD_INT 1
86141: ST_TO_ADDR
// continue ;
86142: GO 83517
// end ; end else
86144: GO 86170
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86146: LD_VAR 0 4
86150: PUSH
86151: LD_VAR 0 7
86155: ARRAY
86156: PPUSH
86157: LD_VAR 0 14
86161: PUSH
86162: LD_INT 1
86164: ARRAY
86165: PPUSH
86166: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86170: LD_VAR 0 4
86174: PUSH
86175: LD_VAR 0 7
86179: ARRAY
86180: PPUSH
86181: CALL_OW 265
86185: PUSH
86186: LD_INT 11
86188: EQUAL
86189: IFFALSE 86467
// begin k := 10 ;
86191: LD_ADDR_VAR 0 9
86195: PUSH
86196: LD_INT 10
86198: ST_TO_ADDR
// x := 0 ;
86199: LD_ADDR_VAR 0 10
86203: PUSH
86204: LD_INT 0
86206: ST_TO_ADDR
// if tmp < k then
86207: LD_VAR 0 14
86211: PUSH
86212: LD_VAR 0 9
86216: LESS
86217: IFFALSE 86229
// k := tmp ;
86219: LD_ADDR_VAR 0 9
86223: PUSH
86224: LD_VAR 0 14
86228: ST_TO_ADDR
// for j = k downto 1 do
86229: LD_ADDR_VAR 0 8
86233: PUSH
86234: DOUBLE
86235: LD_VAR 0 9
86239: INC
86240: ST_TO_ADDR
86241: LD_INT 1
86243: PUSH
86244: FOR_DOWNTO
86245: IFFALSE 86320
// begin if GetType ( tmp [ j ] ) = unit_human then
86247: LD_VAR 0 14
86251: PUSH
86252: LD_VAR 0 8
86256: ARRAY
86257: PPUSH
86258: CALL_OW 247
86262: PUSH
86263: LD_INT 1
86265: EQUAL
86266: IFFALSE 86318
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86268: LD_VAR 0 4
86272: PUSH
86273: LD_VAR 0 7
86277: ARRAY
86278: PPUSH
86279: LD_VAR 0 14
86283: PUSH
86284: LD_VAR 0 8
86288: ARRAY
86289: PPUSH
86290: CALL 81714 0 2
// x := tmp [ j ] ;
86294: LD_ADDR_VAR 0 10
86298: PUSH
86299: LD_VAR 0 14
86303: PUSH
86304: LD_VAR 0 8
86308: ARRAY
86309: ST_TO_ADDR
// attacking := true ;
86310: LD_ADDR_VAR 0 29
86314: PUSH
86315: LD_INT 1
86317: ST_TO_ADDR
// end ; end ;
86318: GO 86244
86320: POP
86321: POP
// if not x then
86322: LD_VAR 0 10
86326: NOT
86327: IFFALSE 86467
// begin attacking := true ;
86329: LD_ADDR_VAR 0 29
86333: PUSH
86334: LD_INT 1
86336: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86337: LD_VAR 0 4
86341: PUSH
86342: LD_VAR 0 7
86346: ARRAY
86347: PPUSH
86348: CALL_OW 250
86352: PPUSH
86353: LD_VAR 0 4
86357: PUSH
86358: LD_VAR 0 7
86362: ARRAY
86363: PPUSH
86364: CALL_OW 251
86368: PPUSH
86369: CALL_OW 546
86373: PUSH
86374: LD_INT 2
86376: ARRAY
86377: PUSH
86378: LD_VAR 0 14
86382: PUSH
86383: LD_INT 1
86385: ARRAY
86386: PPUSH
86387: CALL_OW 250
86391: PPUSH
86392: LD_VAR 0 14
86396: PUSH
86397: LD_INT 1
86399: ARRAY
86400: PPUSH
86401: CALL_OW 251
86405: PPUSH
86406: CALL_OW 546
86410: PUSH
86411: LD_INT 2
86413: ARRAY
86414: EQUAL
86415: IFFALSE 86443
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86417: LD_VAR 0 4
86421: PUSH
86422: LD_VAR 0 7
86426: ARRAY
86427: PPUSH
86428: LD_VAR 0 14
86432: PUSH
86433: LD_INT 1
86435: ARRAY
86436: PPUSH
86437: CALL 81714 0 2
86441: GO 86467
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86443: LD_VAR 0 4
86447: PUSH
86448: LD_VAR 0 7
86452: ARRAY
86453: PPUSH
86454: LD_VAR 0 14
86458: PUSH
86459: LD_INT 1
86461: ARRAY
86462: PPUSH
86463: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86467: LD_VAR 0 4
86471: PUSH
86472: LD_VAR 0 7
86476: ARRAY
86477: PPUSH
86478: CALL_OW 264
86482: PUSH
86483: LD_INT 29
86485: EQUAL
86486: IFFALSE 86852
// begin if WantsToAttack ( group [ i ] ) in bombed then
86488: LD_VAR 0 4
86492: PUSH
86493: LD_VAR 0 7
86497: ARRAY
86498: PPUSH
86499: CALL_OW 319
86503: PUSH
86504: LD_VAR 0 28
86508: IN
86509: IFFALSE 86513
// continue ;
86511: GO 83517
// k := 8 ;
86513: LD_ADDR_VAR 0 9
86517: PUSH
86518: LD_INT 8
86520: ST_TO_ADDR
// x := 0 ;
86521: LD_ADDR_VAR 0 10
86525: PUSH
86526: LD_INT 0
86528: ST_TO_ADDR
// if tmp < k then
86529: LD_VAR 0 14
86533: PUSH
86534: LD_VAR 0 9
86538: LESS
86539: IFFALSE 86551
// k := tmp ;
86541: LD_ADDR_VAR 0 9
86545: PUSH
86546: LD_VAR 0 14
86550: ST_TO_ADDR
// for j = 1 to k do
86551: LD_ADDR_VAR 0 8
86555: PUSH
86556: DOUBLE
86557: LD_INT 1
86559: DEC
86560: ST_TO_ADDR
86561: LD_VAR 0 9
86565: PUSH
86566: FOR_TO
86567: IFFALSE 86699
// begin if GetType ( tmp [ j ] ) = unit_building then
86569: LD_VAR 0 14
86573: PUSH
86574: LD_VAR 0 8
86578: ARRAY
86579: PPUSH
86580: CALL_OW 247
86584: PUSH
86585: LD_INT 3
86587: EQUAL
86588: IFFALSE 86697
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86590: LD_VAR 0 14
86594: PUSH
86595: LD_VAR 0 8
86599: ARRAY
86600: PUSH
86601: LD_VAR 0 28
86605: IN
86606: NOT
86607: PUSH
86608: LD_VAR 0 14
86612: PUSH
86613: LD_VAR 0 8
86617: ARRAY
86618: PPUSH
86619: CALL_OW 313
86623: AND
86624: IFFALSE 86697
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86626: LD_VAR 0 4
86630: PUSH
86631: LD_VAR 0 7
86635: ARRAY
86636: PPUSH
86637: LD_VAR 0 14
86641: PUSH
86642: LD_VAR 0 8
86646: ARRAY
86647: PPUSH
86648: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86652: LD_ADDR_VAR 0 28
86656: PUSH
86657: LD_VAR 0 28
86661: PPUSH
86662: LD_VAR 0 28
86666: PUSH
86667: LD_INT 1
86669: PLUS
86670: PPUSH
86671: LD_VAR 0 14
86675: PUSH
86676: LD_VAR 0 8
86680: ARRAY
86681: PPUSH
86682: CALL_OW 1
86686: ST_TO_ADDR
// attacking := true ;
86687: LD_ADDR_VAR 0 29
86691: PUSH
86692: LD_INT 1
86694: ST_TO_ADDR
// break ;
86695: GO 86699
// end ; end ;
86697: GO 86566
86699: POP
86700: POP
// if not attacking and f_attack_depot then
86701: LD_VAR 0 29
86705: NOT
86706: PUSH
86707: LD_VAR 0 25
86711: AND
86712: IFFALSE 86807
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86714: LD_ADDR_VAR 0 13
86718: PUSH
86719: LD_VAR 0 14
86723: PPUSH
86724: LD_INT 2
86726: PUSH
86727: LD_INT 30
86729: PUSH
86730: LD_INT 0
86732: PUSH
86733: EMPTY
86734: LIST
86735: LIST
86736: PUSH
86737: LD_INT 30
86739: PUSH
86740: LD_INT 1
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: LIST
86751: PPUSH
86752: CALL_OW 72
86756: ST_TO_ADDR
// if z then
86757: LD_VAR 0 13
86761: IFFALSE 86807
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86763: LD_VAR 0 4
86767: PUSH
86768: LD_VAR 0 7
86772: ARRAY
86773: PPUSH
86774: LD_VAR 0 13
86778: PPUSH
86779: LD_VAR 0 4
86783: PUSH
86784: LD_VAR 0 7
86788: ARRAY
86789: PPUSH
86790: CALL_OW 74
86794: PPUSH
86795: CALL_OW 115
// attacking := true ;
86799: LD_ADDR_VAR 0 29
86803: PUSH
86804: LD_INT 1
86806: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86807: LD_VAR 0 4
86811: PUSH
86812: LD_VAR 0 7
86816: ARRAY
86817: PPUSH
86818: CALL_OW 256
86822: PUSH
86823: LD_INT 500
86825: LESS
86826: IFFALSE 86852
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86828: LD_VAR 0 4
86832: PUSH
86833: LD_VAR 0 7
86837: ARRAY
86838: PPUSH
86839: LD_VAR 0 14
86843: PUSH
86844: LD_INT 1
86846: ARRAY
86847: PPUSH
86848: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86852: LD_VAR 0 4
86856: PUSH
86857: LD_VAR 0 7
86861: ARRAY
86862: PPUSH
86863: CALL_OW 264
86867: PUSH
86868: LD_INT 49
86870: EQUAL
86871: IFFALSE 86992
// begin if not HasTask ( group [ i ] ) then
86873: LD_VAR 0 4
86877: PUSH
86878: LD_VAR 0 7
86882: ARRAY
86883: PPUSH
86884: CALL_OW 314
86888: NOT
86889: IFFALSE 86992
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86891: LD_ADDR_VAR 0 9
86895: PUSH
86896: LD_INT 81
86898: PUSH
86899: LD_VAR 0 4
86903: PUSH
86904: LD_VAR 0 7
86908: ARRAY
86909: PPUSH
86910: CALL_OW 255
86914: PUSH
86915: EMPTY
86916: LIST
86917: LIST
86918: PPUSH
86919: CALL_OW 69
86923: PPUSH
86924: LD_VAR 0 4
86928: PUSH
86929: LD_VAR 0 7
86933: ARRAY
86934: PPUSH
86935: CALL_OW 74
86939: ST_TO_ADDR
// if k then
86940: LD_VAR 0 9
86944: IFFALSE 86992
// if GetDistUnits ( group [ i ] , k ) > 10 then
86946: LD_VAR 0 4
86950: PUSH
86951: LD_VAR 0 7
86955: ARRAY
86956: PPUSH
86957: LD_VAR 0 9
86961: PPUSH
86962: CALL_OW 296
86966: PUSH
86967: LD_INT 10
86969: GREATER
86970: IFFALSE 86992
// ComMoveUnit ( group [ i ] , k ) ;
86972: LD_VAR 0 4
86976: PUSH
86977: LD_VAR 0 7
86981: ARRAY
86982: PPUSH
86983: LD_VAR 0 9
86987: PPUSH
86988: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86992: LD_VAR 0 4
86996: PUSH
86997: LD_VAR 0 7
87001: ARRAY
87002: PPUSH
87003: CALL_OW 256
87007: PUSH
87008: LD_INT 250
87010: LESS
87011: PUSH
87012: LD_VAR 0 4
87016: PUSH
87017: LD_VAR 0 7
87021: ARRAY
87022: PUSH
87023: LD_INT 21
87025: PUSH
87026: LD_INT 2
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 23
87035: PUSH
87036: LD_INT 2
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PPUSH
87047: CALL_OW 69
87051: IN
87052: AND
87053: IFFALSE 87178
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87055: LD_ADDR_VAR 0 9
87059: PUSH
87060: LD_OWVAR 3
87064: PUSH
87065: LD_VAR 0 4
87069: PUSH
87070: LD_VAR 0 7
87074: ARRAY
87075: DIFF
87076: PPUSH
87077: LD_VAR 0 4
87081: PUSH
87082: LD_VAR 0 7
87086: ARRAY
87087: PPUSH
87088: CALL_OW 74
87092: ST_TO_ADDR
// if not k then
87093: LD_VAR 0 9
87097: NOT
87098: IFFALSE 87102
// continue ;
87100: GO 83517
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87102: LD_VAR 0 9
87106: PUSH
87107: LD_INT 81
87109: PUSH
87110: LD_VAR 0 4
87114: PUSH
87115: LD_VAR 0 7
87119: ARRAY
87120: PPUSH
87121: CALL_OW 255
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PPUSH
87130: CALL_OW 69
87134: IN
87135: PUSH
87136: LD_VAR 0 9
87140: PPUSH
87141: LD_VAR 0 4
87145: PUSH
87146: LD_VAR 0 7
87150: ARRAY
87151: PPUSH
87152: CALL_OW 296
87156: PUSH
87157: LD_INT 5
87159: LESS
87160: AND
87161: IFFALSE 87178
// ComAutodestruct ( group [ i ] ) ;
87163: LD_VAR 0 4
87167: PUSH
87168: LD_VAR 0 7
87172: ARRAY
87173: PPUSH
87174: CALL 81612 0 1
// end ; if f_attack_depot then
87178: LD_VAR 0 25
87182: IFFALSE 87294
// begin k := 6 ;
87184: LD_ADDR_VAR 0 9
87188: PUSH
87189: LD_INT 6
87191: ST_TO_ADDR
// if tmp < k then
87192: LD_VAR 0 14
87196: PUSH
87197: LD_VAR 0 9
87201: LESS
87202: IFFALSE 87214
// k := tmp ;
87204: LD_ADDR_VAR 0 9
87208: PUSH
87209: LD_VAR 0 14
87213: ST_TO_ADDR
// for j = 1 to k do
87214: LD_ADDR_VAR 0 8
87218: PUSH
87219: DOUBLE
87220: LD_INT 1
87222: DEC
87223: ST_TO_ADDR
87224: LD_VAR 0 9
87228: PUSH
87229: FOR_TO
87230: IFFALSE 87292
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87232: LD_VAR 0 8
87236: PPUSH
87237: CALL_OW 266
87241: PUSH
87242: LD_INT 0
87244: PUSH
87245: LD_INT 1
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: IN
87252: IFFALSE 87290
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87254: LD_VAR 0 4
87258: PUSH
87259: LD_VAR 0 7
87263: ARRAY
87264: PPUSH
87265: LD_VAR 0 14
87269: PUSH
87270: LD_VAR 0 8
87274: ARRAY
87275: PPUSH
87276: CALL_OW 115
// attacking := true ;
87280: LD_ADDR_VAR 0 29
87284: PUSH
87285: LD_INT 1
87287: ST_TO_ADDR
// break ;
87288: GO 87292
// end ;
87290: GO 87229
87292: POP
87293: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87294: LD_VAR 0 4
87298: PUSH
87299: LD_VAR 0 7
87303: ARRAY
87304: PPUSH
87305: CALL_OW 302
87309: PUSH
87310: LD_VAR 0 29
87314: NOT
87315: AND
87316: IFFALSE 87638
// begin if GetTag ( group [ i ] ) = 71 then
87318: LD_VAR 0 4
87322: PUSH
87323: LD_VAR 0 7
87327: ARRAY
87328: PPUSH
87329: CALL_OW 110
87333: PUSH
87334: LD_INT 71
87336: EQUAL
87337: IFFALSE 87378
// begin if HasTask ( group [ i ] ) then
87339: LD_VAR 0 4
87343: PUSH
87344: LD_VAR 0 7
87348: ARRAY
87349: PPUSH
87350: CALL_OW 314
87354: IFFALSE 87360
// continue else
87356: GO 83517
87358: GO 87378
// SetTag ( group [ i ] , 0 ) ;
87360: LD_VAR 0 4
87364: PUSH
87365: LD_VAR 0 7
87369: ARRAY
87370: PPUSH
87371: LD_INT 0
87373: PPUSH
87374: CALL_OW 109
// end ; k := 8 ;
87378: LD_ADDR_VAR 0 9
87382: PUSH
87383: LD_INT 8
87385: ST_TO_ADDR
// x := 0 ;
87386: LD_ADDR_VAR 0 10
87390: PUSH
87391: LD_INT 0
87393: ST_TO_ADDR
// if tmp < k then
87394: LD_VAR 0 14
87398: PUSH
87399: LD_VAR 0 9
87403: LESS
87404: IFFALSE 87416
// k := tmp ;
87406: LD_ADDR_VAR 0 9
87410: PUSH
87411: LD_VAR 0 14
87415: ST_TO_ADDR
// for j = 1 to k do
87416: LD_ADDR_VAR 0 8
87420: PUSH
87421: DOUBLE
87422: LD_INT 1
87424: DEC
87425: ST_TO_ADDR
87426: LD_VAR 0 9
87430: PUSH
87431: FOR_TO
87432: IFFALSE 87530
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87434: LD_VAR 0 14
87438: PUSH
87439: LD_VAR 0 8
87443: ARRAY
87444: PPUSH
87445: CALL_OW 247
87449: PUSH
87450: LD_INT 1
87452: EQUAL
87453: PUSH
87454: LD_VAR 0 14
87458: PUSH
87459: LD_VAR 0 8
87463: ARRAY
87464: PPUSH
87465: CALL_OW 256
87469: PUSH
87470: LD_INT 250
87472: LESS
87473: PUSH
87474: LD_VAR 0 20
87478: AND
87479: PUSH
87480: LD_VAR 0 20
87484: NOT
87485: PUSH
87486: LD_VAR 0 14
87490: PUSH
87491: LD_VAR 0 8
87495: ARRAY
87496: PPUSH
87497: CALL_OW 256
87501: PUSH
87502: LD_INT 250
87504: GREATEREQUAL
87505: AND
87506: OR
87507: AND
87508: IFFALSE 87528
// begin x := tmp [ j ] ;
87510: LD_ADDR_VAR 0 10
87514: PUSH
87515: LD_VAR 0 14
87519: PUSH
87520: LD_VAR 0 8
87524: ARRAY
87525: ST_TO_ADDR
// break ;
87526: GO 87530
// end ;
87528: GO 87431
87530: POP
87531: POP
// if x then
87532: LD_VAR 0 10
87536: IFFALSE 87560
// ComAttackUnit ( group [ i ] , x ) else
87538: LD_VAR 0 4
87542: PUSH
87543: LD_VAR 0 7
87547: ARRAY
87548: PPUSH
87549: LD_VAR 0 10
87553: PPUSH
87554: CALL_OW 115
87558: GO 87584
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87560: LD_VAR 0 4
87564: PUSH
87565: LD_VAR 0 7
87569: ARRAY
87570: PPUSH
87571: LD_VAR 0 14
87575: PUSH
87576: LD_INT 1
87578: ARRAY
87579: PPUSH
87580: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87584: LD_VAR 0 4
87588: PUSH
87589: LD_VAR 0 7
87593: ARRAY
87594: PPUSH
87595: CALL_OW 314
87599: NOT
87600: IFFALSE 87638
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87602: LD_VAR 0 4
87606: PUSH
87607: LD_VAR 0 7
87611: ARRAY
87612: PPUSH
87613: LD_VAR 0 14
87617: PPUSH
87618: LD_VAR 0 4
87622: PUSH
87623: LD_VAR 0 7
87627: ARRAY
87628: PPUSH
87629: CALL_OW 74
87633: PPUSH
87634: CALL_OW 115
// end ; end ; end ;
87638: GO 83517
87640: POP
87641: POP
// wait ( 0 0$1 ) ;
87642: LD_INT 35
87644: PPUSH
87645: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87649: LD_VAR 0 4
87653: PUSH
87654: EMPTY
87655: EQUAL
87656: PUSH
87657: LD_INT 81
87659: PUSH
87660: LD_VAR 0 35
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PPUSH
87669: CALL_OW 69
87673: NOT
87674: OR
87675: IFFALSE 83502
// end ;
87677: LD_VAR 0 2
87681: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87682: LD_INT 0
87684: PPUSH
87685: PPUSH
87686: PPUSH
87687: PPUSH
// if not base_units then
87688: LD_VAR 0 1
87692: NOT
87693: IFFALSE 87697
// exit ;
87695: GO 87784
// result := false ;
87697: LD_ADDR_VAR 0 2
87701: PUSH
87702: LD_INT 0
87704: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87705: LD_ADDR_VAR 0 5
87709: PUSH
87710: LD_VAR 0 1
87714: PPUSH
87715: LD_INT 21
87717: PUSH
87718: LD_INT 3
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PPUSH
87725: CALL_OW 72
87729: ST_TO_ADDR
// if not tmp then
87730: LD_VAR 0 5
87734: NOT
87735: IFFALSE 87739
// exit ;
87737: GO 87784
// for i in tmp do
87739: LD_ADDR_VAR 0 3
87743: PUSH
87744: LD_VAR 0 5
87748: PUSH
87749: FOR_IN
87750: IFFALSE 87782
// begin result := EnemyInRange ( i , 22 ) ;
87752: LD_ADDR_VAR 0 2
87756: PUSH
87757: LD_VAR 0 3
87761: PPUSH
87762: LD_INT 22
87764: PPUSH
87765: CALL 81295 0 2
87769: ST_TO_ADDR
// if result then
87770: LD_VAR 0 2
87774: IFFALSE 87780
// exit ;
87776: POP
87777: POP
87778: GO 87784
// end ;
87780: GO 87749
87782: POP
87783: POP
// end ;
87784: LD_VAR 0 2
87788: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
87789: LD_INT 0
87791: PPUSH
87792: PPUSH
// if not units then
87793: LD_VAR 0 1
87797: NOT
87798: IFFALSE 87802
// exit ;
87800: GO 87872
// result := [ ] ;
87802: LD_ADDR_VAR 0 3
87806: PUSH
87807: EMPTY
87808: ST_TO_ADDR
// for i in units do
87809: LD_ADDR_VAR 0 4
87813: PUSH
87814: LD_VAR 0 1
87818: PUSH
87819: FOR_IN
87820: IFFALSE 87870
// if GetTag ( i ) = tag then
87822: LD_VAR 0 4
87826: PPUSH
87827: CALL_OW 110
87831: PUSH
87832: LD_VAR 0 2
87836: EQUAL
87837: IFFALSE 87868
// result := Insert ( result , result + 1 , i ) ;
87839: LD_ADDR_VAR 0 3
87843: PUSH
87844: LD_VAR 0 3
87848: PPUSH
87849: LD_VAR 0 3
87853: PUSH
87854: LD_INT 1
87856: PLUS
87857: PPUSH
87858: LD_VAR 0 4
87862: PPUSH
87863: CALL_OW 2
87867: ST_TO_ADDR
87868: GO 87819
87870: POP
87871: POP
// end ;
87872: LD_VAR 0 3
87876: RET
// export function IsDriver ( un ) ; begin
87877: LD_INT 0
87879: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87880: LD_ADDR_VAR 0 2
87884: PUSH
87885: LD_VAR 0 1
87889: PUSH
87890: LD_INT 55
87892: PUSH
87893: EMPTY
87894: LIST
87895: PPUSH
87896: CALL_OW 69
87900: IN
87901: ST_TO_ADDR
// end ;
87902: LD_VAR 0 2
87906: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87907: LD_INT 0
87909: PPUSH
87910: PPUSH
// list := [ ] ;
87911: LD_ADDR_VAR 0 5
87915: PUSH
87916: EMPTY
87917: ST_TO_ADDR
// case d of 0 :
87918: LD_VAR 0 3
87922: PUSH
87923: LD_INT 0
87925: DOUBLE
87926: EQUAL
87927: IFTRUE 87931
87929: GO 88064
87931: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87932: LD_ADDR_VAR 0 5
87936: PUSH
87937: LD_VAR 0 1
87941: PUSH
87942: LD_INT 4
87944: MINUS
87945: PUSH
87946: LD_VAR 0 2
87950: PUSH
87951: LD_INT 4
87953: MINUS
87954: PUSH
87955: LD_INT 2
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: LIST
87962: PUSH
87963: LD_VAR 0 1
87967: PUSH
87968: LD_INT 3
87970: MINUS
87971: PUSH
87972: LD_VAR 0 2
87976: PUSH
87977: LD_INT 1
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: LIST
87984: PUSH
87985: LD_VAR 0 1
87989: PUSH
87990: LD_INT 4
87992: PLUS
87993: PUSH
87994: LD_VAR 0 2
87998: PUSH
87999: LD_INT 4
88001: PUSH
88002: EMPTY
88003: LIST
88004: LIST
88005: LIST
88006: PUSH
88007: LD_VAR 0 1
88011: PUSH
88012: LD_INT 3
88014: PLUS
88015: PUSH
88016: LD_VAR 0 2
88020: PUSH
88021: LD_INT 3
88023: PLUS
88024: PUSH
88025: LD_INT 5
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: LIST
88032: PUSH
88033: LD_VAR 0 1
88037: PUSH
88038: LD_VAR 0 2
88042: PUSH
88043: LD_INT 4
88045: PLUS
88046: PUSH
88047: LD_INT 0
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: LIST
88054: PUSH
88055: EMPTY
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: ST_TO_ADDR
// end ; 1 :
88062: GO 88762
88064: LD_INT 1
88066: DOUBLE
88067: EQUAL
88068: IFTRUE 88072
88070: GO 88205
88072: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88073: LD_ADDR_VAR 0 5
88077: PUSH
88078: LD_VAR 0 1
88082: PUSH
88083: LD_VAR 0 2
88087: PUSH
88088: LD_INT 4
88090: MINUS
88091: PUSH
88092: LD_INT 3
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: LIST
88099: PUSH
88100: LD_VAR 0 1
88104: PUSH
88105: LD_INT 3
88107: MINUS
88108: PUSH
88109: LD_VAR 0 2
88113: PUSH
88114: LD_INT 3
88116: MINUS
88117: PUSH
88118: LD_INT 2
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: LIST
88125: PUSH
88126: LD_VAR 0 1
88130: PUSH
88131: LD_INT 4
88133: MINUS
88134: PUSH
88135: LD_VAR 0 2
88139: PUSH
88140: LD_INT 1
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: LIST
88147: PUSH
88148: LD_VAR 0 1
88152: PUSH
88153: LD_VAR 0 2
88157: PUSH
88158: LD_INT 3
88160: PLUS
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: LIST
88169: PUSH
88170: LD_VAR 0 1
88174: PUSH
88175: LD_INT 4
88177: PLUS
88178: PUSH
88179: LD_VAR 0 2
88183: PUSH
88184: LD_INT 4
88186: PLUS
88187: PUSH
88188: LD_INT 5
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: LIST
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: ST_TO_ADDR
// end ; 2 :
88203: GO 88762
88205: LD_INT 2
88207: DOUBLE
88208: EQUAL
88209: IFTRUE 88213
88211: GO 88342
88213: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88214: LD_ADDR_VAR 0 5
88218: PUSH
88219: LD_VAR 0 1
88223: PUSH
88224: LD_VAR 0 2
88228: PUSH
88229: LD_INT 3
88231: MINUS
88232: PUSH
88233: LD_INT 3
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: LIST
88240: PUSH
88241: LD_VAR 0 1
88245: PUSH
88246: LD_INT 4
88248: PLUS
88249: PUSH
88250: LD_VAR 0 2
88254: PUSH
88255: LD_INT 4
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: LIST
88262: PUSH
88263: LD_VAR 0 1
88267: PUSH
88268: LD_VAR 0 2
88272: PUSH
88273: LD_INT 4
88275: PLUS
88276: PUSH
88277: LD_INT 0
88279: PUSH
88280: EMPTY
88281: LIST
88282: LIST
88283: LIST
88284: PUSH
88285: LD_VAR 0 1
88289: PUSH
88290: LD_INT 3
88292: MINUS
88293: PUSH
88294: LD_VAR 0 2
88298: PUSH
88299: LD_INT 1
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: LIST
88306: PUSH
88307: LD_VAR 0 1
88311: PUSH
88312: LD_INT 4
88314: MINUS
88315: PUSH
88316: LD_VAR 0 2
88320: PUSH
88321: LD_INT 4
88323: MINUS
88324: PUSH
88325: LD_INT 2
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: LIST
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: ST_TO_ADDR
// end ; 3 :
88340: GO 88762
88342: LD_INT 3
88344: DOUBLE
88345: EQUAL
88346: IFTRUE 88350
88348: GO 88483
88350: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88351: LD_ADDR_VAR 0 5
88355: PUSH
88356: LD_VAR 0 1
88360: PUSH
88361: LD_INT 3
88363: PLUS
88364: PUSH
88365: LD_VAR 0 2
88369: PUSH
88370: LD_INT 4
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: LIST
88377: PUSH
88378: LD_VAR 0 1
88382: PUSH
88383: LD_INT 4
88385: PLUS
88386: PUSH
88387: LD_VAR 0 2
88391: PUSH
88392: LD_INT 4
88394: PLUS
88395: PUSH
88396: LD_INT 5
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: LIST
88403: PUSH
88404: LD_VAR 0 1
88408: PUSH
88409: LD_INT 4
88411: MINUS
88412: PUSH
88413: LD_VAR 0 2
88417: PUSH
88418: LD_INT 1
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: LIST
88425: PUSH
88426: LD_VAR 0 1
88430: PUSH
88431: LD_VAR 0 2
88435: PUSH
88436: LD_INT 4
88438: MINUS
88439: PUSH
88440: LD_INT 3
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: LIST
88447: PUSH
88448: LD_VAR 0 1
88452: PUSH
88453: LD_INT 3
88455: MINUS
88456: PUSH
88457: LD_VAR 0 2
88461: PUSH
88462: LD_INT 3
88464: MINUS
88465: PUSH
88466: LD_INT 2
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: LIST
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: ST_TO_ADDR
// end ; 4 :
88481: GO 88762
88483: LD_INT 4
88485: DOUBLE
88486: EQUAL
88487: IFTRUE 88491
88489: GO 88624
88491: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88492: LD_ADDR_VAR 0 5
88496: PUSH
88497: LD_VAR 0 1
88501: PUSH
88502: LD_VAR 0 2
88506: PUSH
88507: LD_INT 4
88509: PLUS
88510: PUSH
88511: LD_INT 0
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: LIST
88518: PUSH
88519: LD_VAR 0 1
88523: PUSH
88524: LD_INT 3
88526: PLUS
88527: PUSH
88528: LD_VAR 0 2
88532: PUSH
88533: LD_INT 3
88535: PLUS
88536: PUSH
88537: LD_INT 5
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: LIST
88544: PUSH
88545: LD_VAR 0 1
88549: PUSH
88550: LD_INT 4
88552: PLUS
88553: PUSH
88554: LD_VAR 0 2
88558: PUSH
88559: LD_INT 4
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: LIST
88566: PUSH
88567: LD_VAR 0 1
88571: PUSH
88572: LD_VAR 0 2
88576: PUSH
88577: LD_INT 3
88579: MINUS
88580: PUSH
88581: LD_INT 3
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: LIST
88588: PUSH
88589: LD_VAR 0 1
88593: PUSH
88594: LD_INT 4
88596: MINUS
88597: PUSH
88598: LD_VAR 0 2
88602: PUSH
88603: LD_INT 4
88605: MINUS
88606: PUSH
88607: LD_INT 2
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: LIST
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: ST_TO_ADDR
// end ; 5 :
88622: GO 88762
88624: LD_INT 5
88626: DOUBLE
88627: EQUAL
88628: IFTRUE 88632
88630: GO 88761
88632: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88633: LD_ADDR_VAR 0 5
88637: PUSH
88638: LD_VAR 0 1
88642: PUSH
88643: LD_INT 4
88645: MINUS
88646: PUSH
88647: LD_VAR 0 2
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: LIST
88659: PUSH
88660: LD_VAR 0 1
88664: PUSH
88665: LD_VAR 0 2
88669: PUSH
88670: LD_INT 4
88672: MINUS
88673: PUSH
88674: LD_INT 3
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: LIST
88681: PUSH
88682: LD_VAR 0 1
88686: PUSH
88687: LD_INT 4
88689: PLUS
88690: PUSH
88691: LD_VAR 0 2
88695: PUSH
88696: LD_INT 4
88698: PLUS
88699: PUSH
88700: LD_INT 5
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: LIST
88707: PUSH
88708: LD_VAR 0 1
88712: PUSH
88713: LD_INT 3
88715: PLUS
88716: PUSH
88717: LD_VAR 0 2
88721: PUSH
88722: LD_INT 4
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: LIST
88729: PUSH
88730: LD_VAR 0 1
88734: PUSH
88735: LD_VAR 0 2
88739: PUSH
88740: LD_INT 3
88742: PLUS
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: LIST
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: ST_TO_ADDR
// end ; end ;
88759: GO 88762
88761: POP
// result := list ;
88762: LD_ADDR_VAR 0 4
88766: PUSH
88767: LD_VAR 0 5
88771: ST_TO_ADDR
// end ;
88772: LD_VAR 0 4
88776: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88777: LD_INT 0
88779: PPUSH
88780: PPUSH
88781: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88782: LD_VAR 0 1
88786: NOT
88787: PUSH
88788: LD_VAR 0 2
88792: PUSH
88793: LD_INT 1
88795: PUSH
88796: LD_INT 2
88798: PUSH
88799: LD_INT 3
88801: PUSH
88802: LD_INT 4
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: IN
88811: NOT
88812: OR
88813: IFFALSE 88817
// exit ;
88815: GO 88909
// tmp := [ ] ;
88817: LD_ADDR_VAR 0 5
88821: PUSH
88822: EMPTY
88823: ST_TO_ADDR
// for i in units do
88824: LD_ADDR_VAR 0 4
88828: PUSH
88829: LD_VAR 0 1
88833: PUSH
88834: FOR_IN
88835: IFFALSE 88878
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88837: LD_ADDR_VAR 0 5
88841: PUSH
88842: LD_VAR 0 5
88846: PPUSH
88847: LD_VAR 0 5
88851: PUSH
88852: LD_INT 1
88854: PLUS
88855: PPUSH
88856: LD_VAR 0 4
88860: PPUSH
88861: LD_VAR 0 2
88865: PPUSH
88866: CALL_OW 259
88870: PPUSH
88871: CALL_OW 2
88875: ST_TO_ADDR
88876: GO 88834
88878: POP
88879: POP
// if not tmp then
88880: LD_VAR 0 5
88884: NOT
88885: IFFALSE 88889
// exit ;
88887: GO 88909
// result := SortListByListDesc ( units , tmp ) ;
88889: LD_ADDR_VAR 0 3
88893: PUSH
88894: LD_VAR 0 1
88898: PPUSH
88899: LD_VAR 0 5
88903: PPUSH
88904: CALL_OW 77
88908: ST_TO_ADDR
// end ;
88909: LD_VAR 0 3
88913: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88914: LD_INT 0
88916: PPUSH
88917: PPUSH
88918: PPUSH
// x := GetX ( building ) ;
88919: LD_ADDR_VAR 0 4
88923: PUSH
88924: LD_VAR 0 2
88928: PPUSH
88929: CALL_OW 250
88933: ST_TO_ADDR
// y := GetY ( building ) ;
88934: LD_ADDR_VAR 0 5
88938: PUSH
88939: LD_VAR 0 2
88943: PPUSH
88944: CALL_OW 251
88948: ST_TO_ADDR
// if GetTaskList ( unit ) then
88949: LD_VAR 0 1
88953: PPUSH
88954: CALL_OW 437
88958: IFFALSE 89053
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88960: LD_STRING e
88962: PUSH
88963: LD_VAR 0 1
88967: PPUSH
88968: CALL_OW 437
88972: PUSH
88973: LD_INT 1
88975: ARRAY
88976: PUSH
88977: LD_INT 1
88979: ARRAY
88980: EQUAL
88981: PUSH
88982: LD_VAR 0 4
88986: PUSH
88987: LD_VAR 0 1
88991: PPUSH
88992: CALL_OW 437
88996: PUSH
88997: LD_INT 1
88999: ARRAY
89000: PUSH
89001: LD_INT 2
89003: ARRAY
89004: EQUAL
89005: AND
89006: PUSH
89007: LD_VAR 0 5
89011: PUSH
89012: LD_VAR 0 1
89016: PPUSH
89017: CALL_OW 437
89021: PUSH
89022: LD_INT 1
89024: ARRAY
89025: PUSH
89026: LD_INT 3
89028: ARRAY
89029: EQUAL
89030: AND
89031: IFFALSE 89043
// result := true else
89033: LD_ADDR_VAR 0 3
89037: PUSH
89038: LD_INT 1
89040: ST_TO_ADDR
89041: GO 89051
// result := false ;
89043: LD_ADDR_VAR 0 3
89047: PUSH
89048: LD_INT 0
89050: ST_TO_ADDR
// end else
89051: GO 89061
// result := false ;
89053: LD_ADDR_VAR 0 3
89057: PUSH
89058: LD_INT 0
89060: ST_TO_ADDR
// end ;
89061: LD_VAR 0 3
89065: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89066: LD_INT 0
89068: PPUSH
89069: PPUSH
89070: PPUSH
89071: PPUSH
// if not unit or not area then
89072: LD_VAR 0 1
89076: NOT
89077: PUSH
89078: LD_VAR 0 2
89082: NOT
89083: OR
89084: IFFALSE 89088
// exit ;
89086: GO 89252
// tmp := AreaToList ( area , i ) ;
89088: LD_ADDR_VAR 0 6
89092: PUSH
89093: LD_VAR 0 2
89097: PPUSH
89098: LD_VAR 0 5
89102: PPUSH
89103: CALL_OW 517
89107: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89108: LD_ADDR_VAR 0 5
89112: PUSH
89113: DOUBLE
89114: LD_INT 1
89116: DEC
89117: ST_TO_ADDR
89118: LD_VAR 0 6
89122: PUSH
89123: LD_INT 1
89125: ARRAY
89126: PUSH
89127: FOR_TO
89128: IFFALSE 89250
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89130: LD_ADDR_VAR 0 7
89134: PUSH
89135: LD_VAR 0 6
89139: PUSH
89140: LD_INT 1
89142: ARRAY
89143: PUSH
89144: LD_VAR 0 5
89148: ARRAY
89149: PUSH
89150: LD_VAR 0 6
89154: PUSH
89155: LD_INT 2
89157: ARRAY
89158: PUSH
89159: LD_VAR 0 5
89163: ARRAY
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
89169: LD_VAR 0 7
89173: PUSH
89174: LD_INT 1
89176: ARRAY
89177: PPUSH
89178: LD_VAR 0 7
89182: PUSH
89183: LD_INT 2
89185: ARRAY
89186: PPUSH
89187: CALL_OW 428
89191: PUSH
89192: LD_INT 0
89194: EQUAL
89195: IFFALSE 89248
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
89197: LD_VAR 0 1
89201: PPUSH
89202: LD_VAR 0 7
89206: PUSH
89207: LD_INT 1
89209: ARRAY
89210: PPUSH
89211: LD_VAR 0 7
89215: PUSH
89216: LD_INT 2
89218: ARRAY
89219: PPUSH
89220: LD_VAR 0 3
89224: PPUSH
89225: CALL_OW 48
// result := IsPlaced ( unit ) ;
89229: LD_ADDR_VAR 0 4
89233: PUSH
89234: LD_VAR 0 1
89238: PPUSH
89239: CALL_OW 305
89243: ST_TO_ADDR
// exit ;
89244: POP
89245: POP
89246: GO 89252
// end ; end ;
89248: GO 89127
89250: POP
89251: POP
// end ;
89252: LD_VAR 0 4
89256: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89257: LD_INT 0
89259: PPUSH
89260: PPUSH
89261: PPUSH
// if not side or side > 8 then
89262: LD_VAR 0 1
89266: NOT
89267: PUSH
89268: LD_VAR 0 1
89272: PUSH
89273: LD_INT 8
89275: GREATER
89276: OR
89277: IFFALSE 89281
// exit ;
89279: GO 89468
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89281: LD_ADDR_VAR 0 4
89285: PUSH
89286: LD_INT 22
89288: PUSH
89289: LD_VAR 0 1
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 21
89300: PUSH
89301: LD_INT 3
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PPUSH
89312: CALL_OW 69
89316: ST_TO_ADDR
// if not tmp then
89317: LD_VAR 0 4
89321: NOT
89322: IFFALSE 89326
// exit ;
89324: GO 89468
// enable_addtolog := true ;
89326: LD_ADDR_OWVAR 81
89330: PUSH
89331: LD_INT 1
89333: ST_TO_ADDR
// AddToLog ( [ ) ;
89334: LD_STRING [
89336: PPUSH
89337: CALL_OW 561
// for i in tmp do
89341: LD_ADDR_VAR 0 3
89345: PUSH
89346: LD_VAR 0 4
89350: PUSH
89351: FOR_IN
89352: IFFALSE 89459
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89354: LD_STRING [
89356: PUSH
89357: LD_VAR 0 3
89361: PPUSH
89362: CALL_OW 266
89366: STR
89367: PUSH
89368: LD_STRING , 
89370: STR
89371: PUSH
89372: LD_VAR 0 3
89376: PPUSH
89377: CALL_OW 250
89381: STR
89382: PUSH
89383: LD_STRING , 
89385: STR
89386: PUSH
89387: LD_VAR 0 3
89391: PPUSH
89392: CALL_OW 251
89396: STR
89397: PUSH
89398: LD_STRING , 
89400: STR
89401: PUSH
89402: LD_VAR 0 3
89406: PPUSH
89407: CALL_OW 254
89411: STR
89412: PUSH
89413: LD_STRING , 
89415: STR
89416: PUSH
89417: LD_VAR 0 3
89421: PPUSH
89422: LD_INT 1
89424: PPUSH
89425: CALL_OW 268
89429: STR
89430: PUSH
89431: LD_STRING , 
89433: STR
89434: PUSH
89435: LD_VAR 0 3
89439: PPUSH
89440: LD_INT 2
89442: PPUSH
89443: CALL_OW 268
89447: STR
89448: PUSH
89449: LD_STRING ],
89451: STR
89452: PPUSH
89453: CALL_OW 561
// end ;
89457: GO 89351
89459: POP
89460: POP
// AddToLog ( ]; ) ;
89461: LD_STRING ];
89463: PPUSH
89464: CALL_OW 561
// end ;
89468: LD_VAR 0 2
89472: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89473: LD_INT 0
89475: PPUSH
89476: PPUSH
89477: PPUSH
89478: PPUSH
89479: PPUSH
// if not area or not rate or not max then
89480: LD_VAR 0 1
89484: NOT
89485: PUSH
89486: LD_VAR 0 2
89490: NOT
89491: OR
89492: PUSH
89493: LD_VAR 0 4
89497: NOT
89498: OR
89499: IFFALSE 89503
// exit ;
89501: GO 89695
// while 1 do
89503: LD_INT 1
89505: IFFALSE 89695
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89507: LD_ADDR_VAR 0 9
89511: PUSH
89512: LD_VAR 0 1
89516: PPUSH
89517: LD_INT 1
89519: PPUSH
89520: CALL_OW 287
89524: PUSH
89525: LD_INT 10
89527: MUL
89528: ST_TO_ADDR
// r := rate / 10 ;
89529: LD_ADDR_VAR 0 7
89533: PUSH
89534: LD_VAR 0 2
89538: PUSH
89539: LD_INT 10
89541: DIVREAL
89542: ST_TO_ADDR
// time := 1 1$00 ;
89543: LD_ADDR_VAR 0 8
89547: PUSH
89548: LD_INT 2100
89550: ST_TO_ADDR
// if amount < min then
89551: LD_VAR 0 9
89555: PUSH
89556: LD_VAR 0 3
89560: LESS
89561: IFFALSE 89579
// r := r * 2 else
89563: LD_ADDR_VAR 0 7
89567: PUSH
89568: LD_VAR 0 7
89572: PUSH
89573: LD_INT 2
89575: MUL
89576: ST_TO_ADDR
89577: GO 89605
// if amount > max then
89579: LD_VAR 0 9
89583: PUSH
89584: LD_VAR 0 4
89588: GREATER
89589: IFFALSE 89605
// r := r / 2 ;
89591: LD_ADDR_VAR 0 7
89595: PUSH
89596: LD_VAR 0 7
89600: PUSH
89601: LD_INT 2
89603: DIVREAL
89604: ST_TO_ADDR
// time := time / r ;
89605: LD_ADDR_VAR 0 8
89609: PUSH
89610: LD_VAR 0 8
89614: PUSH
89615: LD_VAR 0 7
89619: DIVREAL
89620: ST_TO_ADDR
// if time < 0 then
89621: LD_VAR 0 8
89625: PUSH
89626: LD_INT 0
89628: LESS
89629: IFFALSE 89646
// time := time * - 1 ;
89631: LD_ADDR_VAR 0 8
89635: PUSH
89636: LD_VAR 0 8
89640: PUSH
89641: LD_INT 1
89643: NEG
89644: MUL
89645: ST_TO_ADDR
// wait ( time ) ;
89646: LD_VAR 0 8
89650: PPUSH
89651: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
89655: LD_INT 35
89657: PPUSH
89658: LD_INT 875
89660: PPUSH
89661: CALL_OW 12
89665: PPUSH
89666: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89670: LD_INT 1
89672: PPUSH
89673: LD_INT 5
89675: PPUSH
89676: CALL_OW 12
89680: PPUSH
89681: LD_VAR 0 1
89685: PPUSH
89686: LD_INT 1
89688: PPUSH
89689: CALL_OW 55
// end ;
89693: GO 89503
// end ;
89695: LD_VAR 0 5
89699: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89700: LD_INT 0
89702: PPUSH
89703: PPUSH
89704: PPUSH
89705: PPUSH
89706: PPUSH
89707: PPUSH
89708: PPUSH
89709: PPUSH
// if not turrets or not factories then
89710: LD_VAR 0 1
89714: NOT
89715: PUSH
89716: LD_VAR 0 2
89720: NOT
89721: OR
89722: IFFALSE 89726
// exit ;
89724: GO 90033
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89726: LD_ADDR_VAR 0 10
89730: PUSH
89731: LD_INT 5
89733: PUSH
89734: LD_INT 6
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 2
89743: PUSH
89744: LD_INT 4
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 3
89753: PUSH
89754: LD_INT 5
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: LIST
89765: PUSH
89766: LD_INT 24
89768: PUSH
89769: LD_INT 25
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: LD_INT 23
89778: PUSH
89779: LD_INT 27
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 42
89792: PUSH
89793: LD_INT 43
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 44
89802: PUSH
89803: LD_INT 46
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 45
89812: PUSH
89813: LD_INT 47
89815: PUSH
89816: EMPTY
89817: LIST
89818: LIST
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: LIST
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: LIST
89829: ST_TO_ADDR
// result := [ ] ;
89830: LD_ADDR_VAR 0 3
89834: PUSH
89835: EMPTY
89836: ST_TO_ADDR
// for i in turrets do
89837: LD_ADDR_VAR 0 4
89841: PUSH
89842: LD_VAR 0 1
89846: PUSH
89847: FOR_IN
89848: IFFALSE 90031
// begin nat := GetNation ( i ) ;
89850: LD_ADDR_VAR 0 7
89854: PUSH
89855: LD_VAR 0 4
89859: PPUSH
89860: CALL_OW 248
89864: ST_TO_ADDR
// weapon := 0 ;
89865: LD_ADDR_VAR 0 8
89869: PUSH
89870: LD_INT 0
89872: ST_TO_ADDR
// if not nat then
89873: LD_VAR 0 7
89877: NOT
89878: IFFALSE 89882
// continue ;
89880: GO 89847
// for j in list [ nat ] do
89882: LD_ADDR_VAR 0 5
89886: PUSH
89887: LD_VAR 0 10
89891: PUSH
89892: LD_VAR 0 7
89896: ARRAY
89897: PUSH
89898: FOR_IN
89899: IFFALSE 89940
// if GetBWeapon ( i ) = j [ 1 ] then
89901: LD_VAR 0 4
89905: PPUSH
89906: CALL_OW 269
89910: PUSH
89911: LD_VAR 0 5
89915: PUSH
89916: LD_INT 1
89918: ARRAY
89919: EQUAL
89920: IFFALSE 89938
// begin weapon := j [ 2 ] ;
89922: LD_ADDR_VAR 0 8
89926: PUSH
89927: LD_VAR 0 5
89931: PUSH
89932: LD_INT 2
89934: ARRAY
89935: ST_TO_ADDR
// break ;
89936: GO 89940
// end ;
89938: GO 89898
89940: POP
89941: POP
// if not weapon then
89942: LD_VAR 0 8
89946: NOT
89947: IFFALSE 89951
// continue ;
89949: GO 89847
// for k in factories do
89951: LD_ADDR_VAR 0 6
89955: PUSH
89956: LD_VAR 0 2
89960: PUSH
89961: FOR_IN
89962: IFFALSE 90027
// begin weapons := AvailableWeaponList ( k ) ;
89964: LD_ADDR_VAR 0 9
89968: PUSH
89969: LD_VAR 0 6
89973: PPUSH
89974: CALL_OW 478
89978: ST_TO_ADDR
// if not weapons then
89979: LD_VAR 0 9
89983: NOT
89984: IFFALSE 89988
// continue ;
89986: GO 89961
// if weapon in weapons then
89988: LD_VAR 0 8
89992: PUSH
89993: LD_VAR 0 9
89997: IN
89998: IFFALSE 90025
// begin result := [ i , weapon ] ;
90000: LD_ADDR_VAR 0 3
90004: PUSH
90005: LD_VAR 0 4
90009: PUSH
90010: LD_VAR 0 8
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: ST_TO_ADDR
// exit ;
90019: POP
90020: POP
90021: POP
90022: POP
90023: GO 90033
// end ; end ;
90025: GO 89961
90027: POP
90028: POP
// end ;
90029: GO 89847
90031: POP
90032: POP
// end ;
90033: LD_VAR 0 3
90037: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90038: LD_INT 0
90040: PPUSH
// if not side or side > 8 then
90041: LD_VAR 0 3
90045: NOT
90046: PUSH
90047: LD_VAR 0 3
90051: PUSH
90052: LD_INT 8
90054: GREATER
90055: OR
90056: IFFALSE 90060
// exit ;
90058: GO 90119
// if not range then
90060: LD_VAR 0 4
90064: NOT
90065: IFFALSE 90076
// range := - 12 ;
90067: LD_ADDR_VAR 0 4
90071: PUSH
90072: LD_INT 12
90074: NEG
90075: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90076: LD_VAR 0 1
90080: PPUSH
90081: LD_VAR 0 2
90085: PPUSH
90086: LD_VAR 0 3
90090: PPUSH
90091: LD_VAR 0 4
90095: PPUSH
90096: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90100: LD_VAR 0 1
90104: PPUSH
90105: LD_VAR 0 2
90109: PPUSH
90110: LD_VAR 0 3
90114: PPUSH
90115: CALL_OW 331
// end ;
90119: LD_VAR 0 5
90123: RET
// export function Video ( mode ) ; begin
90124: LD_INT 0
90126: PPUSH
// ingame_video = mode ;
90127: LD_ADDR_OWVAR 52
90131: PUSH
90132: LD_VAR 0 1
90136: ST_TO_ADDR
// interface_hidden = mode ;
90137: LD_ADDR_OWVAR 54
90141: PUSH
90142: LD_VAR 0 1
90146: ST_TO_ADDR
// end ;
90147: LD_VAR 0 2
90151: RET
// export function Join ( array , element ) ; begin
90152: LD_INT 0
90154: PPUSH
// result := array ^ element ;
90155: LD_ADDR_VAR 0 3
90159: PUSH
90160: LD_VAR 0 1
90164: PUSH
90165: LD_VAR 0 2
90169: ADD
90170: ST_TO_ADDR
// end ;
90171: LD_VAR 0 3
90175: RET
// export function JoinUnion ( array , element ) ; begin
90176: LD_INT 0
90178: PPUSH
// result := array union element ;
90179: LD_ADDR_VAR 0 3
90183: PUSH
90184: LD_VAR 0 1
90188: PUSH
90189: LD_VAR 0 2
90193: UNION
90194: ST_TO_ADDR
// end ;
90195: LD_VAR 0 3
90199: RET
// export function GetBehemoths ( side ) ; begin
90200: LD_INT 0
90202: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
90203: LD_ADDR_VAR 0 2
90207: PUSH
90208: LD_INT 22
90210: PUSH
90211: LD_VAR 0 1
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 31
90222: PUSH
90223: LD_INT 25
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PPUSH
90234: CALL_OW 69
90238: ST_TO_ADDR
// end ;
90239: LD_VAR 0 2
90243: RET
// export function Shuffle ( array ) ; var i , index ; begin
90244: LD_INT 0
90246: PPUSH
90247: PPUSH
90248: PPUSH
// result := [ ] ;
90249: LD_ADDR_VAR 0 2
90253: PUSH
90254: EMPTY
90255: ST_TO_ADDR
// if not array then
90256: LD_VAR 0 1
90260: NOT
90261: IFFALSE 90265
// exit ;
90263: GO 90364
// Randomize ;
90265: CALL_OW 10
// for i = array downto 1 do
90269: LD_ADDR_VAR 0 3
90273: PUSH
90274: DOUBLE
90275: LD_VAR 0 1
90279: INC
90280: ST_TO_ADDR
90281: LD_INT 1
90283: PUSH
90284: FOR_DOWNTO
90285: IFFALSE 90362
// begin index := rand ( 1 , array ) ;
90287: LD_ADDR_VAR 0 4
90291: PUSH
90292: LD_INT 1
90294: PPUSH
90295: LD_VAR 0 1
90299: PPUSH
90300: CALL_OW 12
90304: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90305: LD_ADDR_VAR 0 2
90309: PUSH
90310: LD_VAR 0 2
90314: PPUSH
90315: LD_VAR 0 2
90319: PUSH
90320: LD_INT 1
90322: PLUS
90323: PPUSH
90324: LD_VAR 0 1
90328: PUSH
90329: LD_VAR 0 4
90333: ARRAY
90334: PPUSH
90335: CALL_OW 2
90339: ST_TO_ADDR
// array := Delete ( array , index ) ;
90340: LD_ADDR_VAR 0 1
90344: PUSH
90345: LD_VAR 0 1
90349: PPUSH
90350: LD_VAR 0 4
90354: PPUSH
90355: CALL_OW 3
90359: ST_TO_ADDR
// end ;
90360: GO 90284
90362: POP
90363: POP
// end ;
90364: LD_VAR 0 2
90368: RET
// export function GetBaseMaterials ( base ) ; begin
90369: LD_INT 0
90371: PPUSH
// result := [ 0 , 0 , 0 ] ;
90372: LD_ADDR_VAR 0 2
90376: PUSH
90377: LD_INT 0
90379: PUSH
90380: LD_INT 0
90382: PUSH
90383: LD_INT 0
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: LIST
90390: ST_TO_ADDR
// if not base then
90391: LD_VAR 0 1
90395: NOT
90396: IFFALSE 90400
// exit ;
90398: GO 90449
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90400: LD_ADDR_VAR 0 2
90404: PUSH
90405: LD_VAR 0 1
90409: PPUSH
90410: LD_INT 1
90412: PPUSH
90413: CALL_OW 275
90417: PUSH
90418: LD_VAR 0 1
90422: PPUSH
90423: LD_INT 2
90425: PPUSH
90426: CALL_OW 275
90430: PUSH
90431: LD_VAR 0 1
90435: PPUSH
90436: LD_INT 3
90438: PPUSH
90439: CALL_OW 275
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: LIST
90448: ST_TO_ADDR
// end ; end_of_file
90449: LD_VAR 0 2
90453: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
90454: GO 90456
90456: DISABLE
// begin ru_radar := 98 ;
90457: LD_ADDR_EXP 93
90461: PUSH
90462: LD_INT 98
90464: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
90465: LD_ADDR_EXP 94
90469: PUSH
90470: LD_INT 89
90472: ST_TO_ADDR
// us_hack := 99 ;
90473: LD_ADDR_EXP 95
90477: PUSH
90478: LD_INT 99
90480: ST_TO_ADDR
// us_artillery := 97 ;
90481: LD_ADDR_EXP 96
90485: PUSH
90486: LD_INT 97
90488: ST_TO_ADDR
// ar_bio_bomb := 91 ;
90489: LD_ADDR_EXP 97
90493: PUSH
90494: LD_INT 91
90496: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
90497: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
90498: LD_INT 0
90500: PPUSH
90501: PPUSH
90502: PPUSH
90503: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90504: LD_VAR 0 1
90508: PPUSH
90509: CALL_OW 264
90513: PUSH
90514: LD_EXP 97
90518: EQUAL
90519: IFFALSE 90591
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90521: LD_INT 68
90523: PPUSH
90524: LD_VAR 0 1
90528: PPUSH
90529: CALL_OW 255
90533: PPUSH
90534: CALL_OW 321
90538: PUSH
90539: LD_INT 2
90541: EQUAL
90542: IFFALSE 90554
// eff := 70 else
90544: LD_ADDR_VAR 0 6
90548: PUSH
90549: LD_INT 70
90551: ST_TO_ADDR
90552: GO 90562
// eff := 30 ;
90554: LD_ADDR_VAR 0 6
90558: PUSH
90559: LD_INT 30
90561: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90562: LD_VAR 0 1
90566: PPUSH
90567: CALL_OW 250
90571: PPUSH
90572: LD_VAR 0 1
90576: PPUSH
90577: CALL_OW 251
90581: PPUSH
90582: LD_VAR 0 6
90586: PPUSH
90587: CALL_OW 495
// end ; end ;
90591: LD_VAR 0 4
90595: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
90596: LD_INT 0
90598: PPUSH
90599: PPUSH
90600: PPUSH
90601: PPUSH
90602: PPUSH
90603: PPUSH
// if cmd = 124 then
90604: LD_VAR 0 1
90608: PUSH
90609: LD_INT 124
90611: EQUAL
90612: IFFALSE 90818
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
90614: LD_ADDR_VAR 0 5
90618: PUSH
90619: LD_INT 2
90621: PUSH
90622: LD_INT 34
90624: PUSH
90625: LD_INT 53
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 34
90634: PUSH
90635: LD_INT 14
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: LIST
90646: PPUSH
90647: CALL_OW 69
90651: ST_TO_ADDR
// if not tmp then
90652: LD_VAR 0 5
90656: NOT
90657: IFFALSE 90661
// exit ;
90659: GO 90818
// for i in tmp do
90661: LD_ADDR_VAR 0 3
90665: PUSH
90666: LD_VAR 0 5
90670: PUSH
90671: FOR_IN
90672: IFFALSE 90816
// begin taskList := GetTaskList ( i ) ;
90674: LD_ADDR_VAR 0 6
90678: PUSH
90679: LD_VAR 0 3
90683: PPUSH
90684: CALL_OW 437
90688: ST_TO_ADDR
// if not taskList then
90689: LD_VAR 0 6
90693: NOT
90694: IFFALSE 90698
// continue ;
90696: GO 90671
// for j = 1 to taskList do
90698: LD_ADDR_VAR 0 4
90702: PUSH
90703: DOUBLE
90704: LD_INT 1
90706: DEC
90707: ST_TO_ADDR
90708: LD_VAR 0 6
90712: PUSH
90713: FOR_TO
90714: IFFALSE 90812
// if taskList [ j ] [ 1 ] = | then
90716: LD_VAR 0 6
90720: PUSH
90721: LD_VAR 0 4
90725: ARRAY
90726: PUSH
90727: LD_INT 1
90729: ARRAY
90730: PUSH
90731: LD_STRING |
90733: EQUAL
90734: IFFALSE 90810
// begin _taskList := Delete ( taskList , 1 ) ;
90736: LD_ADDR_VAR 0 7
90740: PUSH
90741: LD_VAR 0 6
90745: PPUSH
90746: LD_INT 1
90748: PPUSH
90749: CALL_OW 3
90753: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
90754: LD_VAR 0 3
90758: PPUSH
90759: LD_VAR 0 7
90763: PPUSH
90764: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
90768: LD_VAR 0 3
90772: PPUSH
90773: LD_VAR 0 6
90777: PUSH
90778: LD_VAR 0 4
90782: ARRAY
90783: PUSH
90784: LD_INT 2
90786: ARRAY
90787: PPUSH
90788: LD_VAR 0 6
90792: PUSH
90793: LD_VAR 0 4
90797: ARRAY
90798: PUSH
90799: LD_INT 3
90801: ARRAY
90802: PPUSH
90803: LD_INT 8
90805: PPUSH
90806: CALL 90823 0 4
// end ;
90810: GO 90713
90812: POP
90813: POP
// end ;
90814: GO 90671
90816: POP
90817: POP
// end ; end ;
90818: LD_VAR 0 2
90822: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90823: LD_INT 0
90825: PPUSH
90826: PPUSH
90827: PPUSH
90828: PPUSH
90829: PPUSH
90830: PPUSH
90831: PPUSH
90832: PPUSH
90833: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90834: LD_VAR 0 1
90838: NOT
90839: PUSH
90840: LD_VAR 0 2
90844: PPUSH
90845: LD_VAR 0 3
90849: PPUSH
90850: CALL_OW 488
90854: NOT
90855: OR
90856: PUSH
90857: LD_VAR 0 4
90861: NOT
90862: OR
90863: IFFALSE 90867
// exit ;
90865: GO 91207
// list := [ ] ;
90867: LD_ADDR_VAR 0 13
90871: PUSH
90872: EMPTY
90873: ST_TO_ADDR
// if x - r < 0 then
90874: LD_VAR 0 2
90878: PUSH
90879: LD_VAR 0 4
90883: MINUS
90884: PUSH
90885: LD_INT 0
90887: LESS
90888: IFFALSE 90900
// min_x := 0 else
90890: LD_ADDR_VAR 0 7
90894: PUSH
90895: LD_INT 0
90897: ST_TO_ADDR
90898: GO 90916
// min_x := x - r ;
90900: LD_ADDR_VAR 0 7
90904: PUSH
90905: LD_VAR 0 2
90909: PUSH
90910: LD_VAR 0 4
90914: MINUS
90915: ST_TO_ADDR
// if y - r < 0 then
90916: LD_VAR 0 3
90920: PUSH
90921: LD_VAR 0 4
90925: MINUS
90926: PUSH
90927: LD_INT 0
90929: LESS
90930: IFFALSE 90942
// min_y := 0 else
90932: LD_ADDR_VAR 0 8
90936: PUSH
90937: LD_INT 0
90939: ST_TO_ADDR
90940: GO 90958
// min_y := y - r ;
90942: LD_ADDR_VAR 0 8
90946: PUSH
90947: LD_VAR 0 3
90951: PUSH
90952: LD_VAR 0 4
90956: MINUS
90957: ST_TO_ADDR
// max_x := x + r ;
90958: LD_ADDR_VAR 0 9
90962: PUSH
90963: LD_VAR 0 2
90967: PUSH
90968: LD_VAR 0 4
90972: PLUS
90973: ST_TO_ADDR
// max_y := y + r ;
90974: LD_ADDR_VAR 0 10
90978: PUSH
90979: LD_VAR 0 3
90983: PUSH
90984: LD_VAR 0 4
90988: PLUS
90989: ST_TO_ADDR
// for _x = min_x to max_x do
90990: LD_ADDR_VAR 0 11
90994: PUSH
90995: DOUBLE
90996: LD_VAR 0 7
91000: DEC
91001: ST_TO_ADDR
91002: LD_VAR 0 9
91006: PUSH
91007: FOR_TO
91008: IFFALSE 91125
// for _y = min_y to max_y do
91010: LD_ADDR_VAR 0 12
91014: PUSH
91015: DOUBLE
91016: LD_VAR 0 8
91020: DEC
91021: ST_TO_ADDR
91022: LD_VAR 0 10
91026: PUSH
91027: FOR_TO
91028: IFFALSE 91121
// begin if not ValidHex ( _x , _y ) then
91030: LD_VAR 0 11
91034: PPUSH
91035: LD_VAR 0 12
91039: PPUSH
91040: CALL_OW 488
91044: NOT
91045: IFFALSE 91049
// continue ;
91047: GO 91027
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91049: LD_VAR 0 11
91053: PPUSH
91054: LD_VAR 0 12
91058: PPUSH
91059: CALL_OW 351
91063: PUSH
91064: LD_VAR 0 11
91068: PPUSH
91069: LD_VAR 0 12
91073: PPUSH
91074: CALL_OW 554
91078: AND
91079: IFFALSE 91119
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91081: LD_ADDR_VAR 0 13
91085: PUSH
91086: LD_VAR 0 13
91090: PPUSH
91091: LD_VAR 0 13
91095: PUSH
91096: LD_INT 1
91098: PLUS
91099: PPUSH
91100: LD_VAR 0 11
91104: PUSH
91105: LD_VAR 0 12
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PPUSH
91114: CALL_OW 2
91118: ST_TO_ADDR
// end ;
91119: GO 91027
91121: POP
91122: POP
91123: GO 91007
91125: POP
91126: POP
// if not list then
91127: LD_VAR 0 13
91131: NOT
91132: IFFALSE 91136
// exit ;
91134: GO 91207
// for i in list do
91136: LD_ADDR_VAR 0 6
91140: PUSH
91141: LD_VAR 0 13
91145: PUSH
91146: FOR_IN
91147: IFFALSE 91205
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91149: LD_VAR 0 1
91153: PPUSH
91154: LD_STRING M
91156: PUSH
91157: LD_VAR 0 6
91161: PUSH
91162: LD_INT 1
91164: ARRAY
91165: PUSH
91166: LD_VAR 0 6
91170: PUSH
91171: LD_INT 2
91173: ARRAY
91174: PUSH
91175: LD_INT 0
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: LD_INT 0
91183: PUSH
91184: LD_INT 0
91186: PUSH
91187: EMPTY
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: PUSH
91196: EMPTY
91197: LIST
91198: PPUSH
91199: CALL_OW 447
91203: GO 91146
91205: POP
91206: POP
// end ;
91207: LD_VAR 0 5
91211: RET
