// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 89795 0 0
// InitMacro ;
  23: CALL 17953 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 82662 0 9
// PrepareAmerican ;
  81: CALL 663 0 0
// PrepareArabian ;
  85: CALL 2615 0 0
// MC_Start ( ) ;
  89: CALL 20118 0 0
// Action ;
  93: CALL 8560 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: LD_INT 235200
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: ST_TO_ADDR
// powell_warn := false ;
 245: LD_ADDR_EXP 16
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// loses_counter := 0 ;
 253: LD_ADDR_EXP 17
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// artifact_oncargo := false ;
 261: LD_ADDR_EXP 14
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 269: LD_ADDR_EXP 18
 273: PUSH
 274: LD_STRING 10_GensherEscape_1
 276: PPUSH
 277: LD_EXP 1
 281: PPUSH
 282: CALL_OW 30
 286: ST_TO_ADDR
// can_kamikazed := false ;
 287: LD_ADDR_EXP 10
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// am_veh_consturcted := false ;
 295: LD_ADDR_EXP 20
 299: PUSH
 300: LD_INT 0
 302: ST_TO_ADDR
// end ;
 303: LD_VAR 0 1
 307: RET
// export function CustomInitMacro ; var i ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 312: LD_ADDR_EXP 74
 316: PUSH
 317: LD_INT 20
 319: PUSH
 320: LD_INT 21
 322: PUSH
 323: LD_INT 22
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 331: LD_ADDR_EXP 75
 335: PUSH
 336: LD_INT 28
 338: PUSH
 339: LD_INT 24
 341: PUSH
 342: LD_INT 26
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: LIST
 349: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PUSH
 356: LD_INT 6
 358: PUSH
 359: LD_INT 8
 361: PUSH
 362: LD_INT 9
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_OWVAR 67
 375: ARRAY
 376: PPUSH
 377: LD_INT 3
 379: PPUSH
 380: CALL 41807 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 384: LD_INT 2
 386: PPUSH
 387: LD_INT 4
 389: PUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 8
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: PUSH
 405: LD_OWVAR 67
 409: ARRAY
 410: PPUSH
 411: LD_INT 2
 413: PPUSH
 414: CALL 41807 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 418: LD_INT 3
 420: PPUSH
 421: LD_INT 4
 423: PUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 8
 429: PUSH
 430: LD_INT 9
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_OWVAR 67
 443: ARRAY
 444: PPUSH
 445: LD_INT 1
 447: PPUSH
 448: CALL 41807 0 3
// for i = 1 to mc_bases do
 452: LD_ADDR_VAR 0 2
 456: PUSH
 457: DOUBLE
 458: LD_INT 1
 460: DEC
 461: ST_TO_ADDR
 462: LD_EXP 50
 466: PUSH
 467: FOR_TO
 468: IFFALSE 492
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 470: LD_VAR 0 2
 474: PPUSH
 475: LD_EXP 43
 479: PUSH
 480: LD_VAR 0 2
 484: ARRAY
 485: PPUSH
 486: CALL 42233 0 2
 490: GO 467
 492: POP
 493: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 494: LD_INT 1
 496: PPUSH
 497: LD_INT 14
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_EXP 100
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: PUSH
 517: LD_INT 14
 519: PUSH
 520: LD_INT 1
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: LD_EXP 100
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL 42125 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 545: LD_INT 2
 547: PPUSH
 548: LD_INT 14
 550: PUSH
 551: LD_INT 1
 553: PUSH
 554: LD_INT 2
 556: PUSH
 557: LD_EXP 100
 561: PUSH
 562: EMPTY
 563: LIST
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: EMPTY
 569: LIST
 570: PPUSH
 571: CALL 42125 0 2
// end ;
 575: LD_VAR 0 1
 579: RET
// function Debuger ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// if not debug then
 584: LD_EXP 1
 588: NOT
 589: IFFALSE 593
// exit ;
 591: GO 629
// game_speed := 5 ;
 593: LD_ADDR_OWVAR 65
 597: PUSH
 598: LD_INT 5
 600: ST_TO_ADDR
// uc_side := 1 ;
 601: LD_ADDR_OWVAR 20
 605: PUSH
 606: LD_INT 1
 608: ST_TO_ADDR
// uc_nation := 1 ;
 609: LD_ADDR_OWVAR 21
 613: PUSH
 614: LD_INT 1
 616: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 617: LD_EXP 36
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 235
// end ;
 629: LD_VAR 0 1
 633: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 634: LD_INT 94
 636: PPUSH
 637: CALL_OW 301
 641: PUSH
 642: LD_INT 45
 644: PPUSH
 645: CALL_OW 302
 649: AND
 650: IFFALSE 662
 652: GO 654
 654: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 655: LD_STRING ACH_EAST
 657: PPUSH
 658: CALL_OW 543
 662: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 663: LD_INT 0
 665: PPUSH
 666: PPUSH
 667: PPUSH
 668: PPUSH
 669: PPUSH
 670: PPUSH
 671: PPUSH
 672: PPUSH
// uc_side := 4 ;
 673: LD_ADDR_OWVAR 20
 677: PUSH
 678: LD_INT 4
 680: ST_TO_ADDR
// uc_nation := 1 ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 1
 688: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 689: LD_ADDR_EXP 30
 693: PUSH
 694: LD_STRING Powell
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: LD_STRING 
 702: PPUSH
 703: CALL 48579 0 3
 707: ST_TO_ADDR
// uc_side := 1 ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 716: LD_ADDR_EXP 21
 720: PUSH
 721: LD_STRING JMM
 723: PPUSH
 724: LD_EXP 1
 728: NOT
 729: PPUSH
 730: LD_EXP 4
 734: PPUSH
 735: CALL 48579 0 3
 739: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 740: LD_EXP 21
 744: PPUSH
 745: CALL_OW 257
 749: PUSH
 750: LD_INT 4
 752: GREATER
 753: IFFALSE 767
// SetClass ( JMM , 1 ) ;
 755: LD_EXP 21
 759: PPUSH
 760: LD_INT 1
 762: PPUSH
 763: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 767: LD_ADDR_EXP 22
 771: PUSH
 772: LD_STRING Lisa
 774: PPUSH
 775: LD_EXP 1
 779: NOT
 780: PPUSH
 781: LD_EXP 4
 785: PPUSH
 786: CALL 48579 0 3
 790: ST_TO_ADDR
// if not Lisa then
 791: LD_EXP 22
 795: NOT
 796: IFFALSE 811
// Lisa := CreateCharacter ( 10_Lisa ) ;
 798: LD_ADDR_EXP 22
 802: PUSH
 803: LD_STRING 10_Lisa
 805: PPUSH
 806: CALL_OW 34
 810: ST_TO_ADDR
// if not Lisa then
 811: LD_EXP 22
 815: NOT
 816: IFFALSE 831
// Lisa := CreateCharacter ( 09_Lisa ) ;
 818: LD_ADDR_EXP 22
 822: PUSH
 823: LD_STRING 09_Lisa
 825: PPUSH
 826: CALL_OW 34
 830: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 831: LD_ADDR_EXP 31
 835: PUSH
 836: LD_STRING Cornel
 838: PPUSH
 839: LD_EXP 1
 843: NOT
 844: PPUSH
 845: LD_EXP 4
 849: PPUSH
 850: CALL 48579 0 3
 854: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_STRING Donaldson
 862: PPUSH
 863: LD_EXP 1
 867: NOT
 868: PPUSH
 869: LD_EXP 4
 873: PPUSH
 874: CALL 48579 0 3
 878: ST_TO_ADDR
// if not Donaldson then
 879: LD_EXP 23
 883: NOT
 884: IFFALSE 899
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 886: LD_ADDR_EXP 23
 890: PUSH
 891: LD_STRING 10_Donaldson
 893: PPUSH
 894: CALL_OW 34
 898: ST_TO_ADDR
// if not Donaldson then
 899: LD_EXP 23
 903: NOT
 904: IFFALSE 919
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 906: LD_ADDR_EXP 23
 910: PUSH
 911: LD_STRING 09_Donaldson
 913: PPUSH
 914: CALL_OW 34
 918: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 919: LD_ADDR_EXP 24
 923: PUSH
 924: LD_STRING Bobby
 926: PPUSH
 927: LD_EXP 1
 931: NOT
 932: PPUSH
 933: LD_EXP 4
 937: PPUSH
 938: CALL 48579 0 3
 942: ST_TO_ADDR
// if not Bobby then
 943: LD_EXP 24
 947: NOT
 948: IFFALSE 963
// Bobby := CreateCharacter ( 10_Bobby ) ;
 950: LD_ADDR_EXP 24
 954: PUSH
 955: LD_STRING 10_Bobby
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// if not Bobby then
 963: LD_EXP 24
 967: NOT
 968: IFFALSE 983
// Bobby := CreateCharacter ( 09_Bobby ) ;
 970: LD_ADDR_EXP 24
 974: PUSH
 975: LD_STRING 09_Bobby
 977: PPUSH
 978: CALL_OW 34
 982: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 983: LD_ADDR_EXP 25
 987: PUSH
 988: LD_STRING Cyrus
 990: PPUSH
 991: LD_EXP 1
 995: NOT
 996: PPUSH
 997: LD_EXP 4
1001: PPUSH
1002: CALL 48579 0 3
1006: ST_TO_ADDR
// if not Cyrus then
1007: LD_EXP 25
1011: NOT
1012: IFFALSE 1027
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1014: LD_ADDR_EXP 25
1018: PUSH
1019: LD_STRING 10_Cyrus
1021: PPUSH
1022: CALL_OW 34
1026: ST_TO_ADDR
// if not Cyrus then
1027: LD_EXP 25
1031: NOT
1032: IFFALSE 1047
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1034: LD_ADDR_EXP 25
1038: PUSH
1039: LD_STRING 09_Cyrus
1041: PPUSH
1042: CALL_OW 34
1046: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1047: LD_ADDR_EXP 26
1051: PUSH
1052: LD_STRING Denis
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_EXP 4
1065: PPUSH
1066: CALL 48579 0 3
1070: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1071: LD_ADDR_EXP 27
1075: PUSH
1076: LD_STRING Brown
1078: PPUSH
1079: LD_EXP 1
1083: NOT
1084: PPUSH
1085: LD_EXP 4
1089: PPUSH
1090: CALL 48579 0 3
1094: ST_TO_ADDR
// if not Brown then
1095: LD_EXP 27
1099: NOT
1100: IFFALSE 1115
// Brown := CreateCharacter ( 10_Brown ) ;
1102: LD_ADDR_EXP 27
1106: PUSH
1107: LD_STRING 10_Brown
1109: PPUSH
1110: CALL_OW 34
1114: ST_TO_ADDR
// if not Brown then
1115: LD_EXP 27
1119: NOT
1120: IFFALSE 1135
// Brown := CreateCharacter ( 08_Brown ) ;
1122: LD_ADDR_EXP 27
1126: PUSH
1127: LD_STRING 08_Brown
1129: PPUSH
1130: CALL_OW 34
1134: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1135: LD_ADDR_EXP 28
1139: PUSH
1140: LD_STRING Gladstone
1142: PPUSH
1143: LD_EXP 1
1147: NOT
1148: PPUSH
1149: LD_EXP 4
1153: PPUSH
1154: CALL 48579 0 3
1158: ST_TO_ADDR
// if not Gladstone then
1159: LD_EXP 28
1163: NOT
1164: IFFALSE 1179
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1166: LD_ADDR_EXP 28
1170: PUSH
1171: LD_STRING 10_Gladstone
1173: PPUSH
1174: CALL_OW 34
1178: ST_TO_ADDR
// if not Gladstone then
1179: LD_EXP 28
1183: NOT
1184: IFFALSE 1199
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1186: LD_ADDR_EXP 28
1190: PUSH
1191: LD_STRING 08_Gladstone
1193: PPUSH
1194: CALL_OW 34
1198: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1199: LD_ADDR_EXP 29
1203: PUSH
1204: LD_STRING Houten
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_EXP 4
1217: PPUSH
1218: CALL 48579 0 3
1222: ST_TO_ADDR
// if not Houten then
1223: LD_EXP 29
1227: NOT
1228: IFFALSE 1243
// Houten := CreateCharacter ( 10_Houten ) ;
1230: LD_ADDR_EXP 29
1234: PUSH
1235: LD_STRING 10_Houten
1237: PPUSH
1238: CALL_OW 34
1242: ST_TO_ADDR
// if not Houten then
1243: LD_EXP 29
1247: NOT
1248: IFFALSE 1263
// Houten := CreateCharacter ( 09_Houten ) ;
1250: LD_ADDR_EXP 29
1254: PUSH
1255: LD_STRING 09_Houten
1257: PPUSH
1258: CALL_OW 34
1262: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1263: LD_ADDR_EXP 31
1267: PUSH
1268: LD_STRING Cornell
1270: PPUSH
1271: LD_EXP 1
1275: NOT
1276: PPUSH
1277: LD_EXP 4
1281: PPUSH
1282: CALL 48579 0 3
1286: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1287: LD_ADDR_EXP 32
1291: PUSH
1292: LD_STRING Gary
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: LD_EXP 4
1305: PPUSH
1306: CALL 48579 0 3
1310: ST_TO_ADDR
// if not Gary then
1311: LD_EXP 32
1315: NOT
1316: IFFALSE 1331
// Gary := CreateCharacter ( 10_Gary ) ;
1318: LD_ADDR_EXP 32
1322: PUSH
1323: LD_STRING 10_Gary
1325: PPUSH
1326: CALL_OW 34
1330: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1331: LD_ADDR_EXP 33
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: LD_EXP 4
1349: PPUSH
1350: CALL 48579 0 3
1354: ST_TO_ADDR
// if not Frank then
1355: LD_EXP 33
1359: NOT
1360: IFFALSE 1375
// Frank := CreateCharacter ( 08_Frank ) ;
1362: LD_ADDR_EXP 33
1366: PUSH
1367: LD_STRING 08_Frank
1369: PPUSH
1370: CALL_OW 34
1374: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1375: LD_ADDR_EXP 34
1379: PUSH
1380: LD_STRING Kikuchi
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_EXP 4
1393: PPUSH
1394: CALL 48579 0 3
1398: ST_TO_ADDR
// if not Kikuchi then
1399: LD_EXP 34
1403: NOT
1404: IFFALSE 1419
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1406: LD_ADDR_EXP 34
1410: PUSH
1411: LD_STRING 08_Kikuchi
1413: PPUSH
1414: CALL_OW 34
1418: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1419: LD_ADDR_VAR 0 5
1423: PUSH
1424: LD_EXP 22
1428: PUSH
1429: LD_EXP 23
1433: PUSH
1434: LD_EXP 24
1438: PUSH
1439: LD_EXP 25
1443: PUSH
1444: LD_EXP 26
1448: PUSH
1449: LD_EXP 27
1453: PUSH
1454: LD_EXP 28
1458: PUSH
1459: LD_EXP 29
1463: PUSH
1464: LD_EXP 31
1468: PUSH
1469: LD_EXP 32
1473: PUSH
1474: LD_EXP 33
1478: PUSH
1479: LD_EXP 34
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: ST_TO_ADDR
// tmp := tmp diff 0 ;
1498: LD_ADDR_VAR 0 5
1502: PUSH
1503: LD_VAR 0 5
1507: PUSH
1508: LD_INT 0
1510: DIFF
1511: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1512: LD_ADDR_VAR 0 5
1516: PUSH
1517: LD_VAR 0 5
1521: PUSH
1522: LD_STRING 10_lock
1524: PPUSH
1525: CALL_OW 31
1529: UNION
1530: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1531: LD_ADDR_VAR 0 5
1535: PUSH
1536: LD_VAR 0 5
1540: PUSH
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 31
1548: UNION
1549: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1550: LD_STRING 10_lock
1552: PPUSH
1553: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1557: LD_STRING 10c_lock
1559: PPUSH
1560: CALL_OW 40
// for i in tmp do
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: LD_VAR 0 5
1573: PUSH
1574: FOR_IN
1575: IFFALSE 1613
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1577: LD_VAR 0 2
1581: PPUSH
1582: CALL_OW 257
1586: PUSH
1587: LD_INT 8
1589: PUSH
1590: LD_INT 2
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: IN
1597: IFFALSE 1611
// SetClass ( i , class_soldier ) ;
1599: LD_VAR 0 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: CALL_OW 336
1611: GO 1574
1613: POP
1614: POP
// if tmp < 12 then
1615: LD_VAR 0 5
1619: PUSH
1620: LD_INT 12
1622: LESS
1623: IFFALSE 1717
// begin k := 16 - tmp ;
1625: LD_ADDR_VAR 0 3
1629: PUSH
1630: LD_INT 16
1632: PUSH
1633: LD_VAR 0 5
1637: MINUS
1638: ST_TO_ADDR
// for i = 1 to k do
1639: LD_ADDR_VAR 0 2
1643: PUSH
1644: DOUBLE
1645: LD_INT 1
1647: DEC
1648: ST_TO_ADDR
1649: LD_VAR 0 3
1653: PUSH
1654: FOR_TO
1655: IFFALSE 1715
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1657: LD_INT 0
1659: PPUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 1
1665: PUSH
1666: LD_INT 3
1668: PUSH
1669: LD_INT 4
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 1
1680: PPUSH
1681: LD_INT 4
1683: PPUSH
1684: CALL_OW 12
1688: ARRAY
1689: PPUSH
1690: LD_INT 6
1692: PPUSH
1693: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_VAR 0 5
1706: PUSH
1707: CALL_OW 44
1711: ADD
1712: ST_TO_ADDR
// end ;
1713: GO 1654
1715: POP
1716: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1717: LD_ADDR_EXP 19
1721: PUSH
1722: LD_STRING 1
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 12
1730: PPUSH
1731: LD_INT -5
1733: PUSH
1734: LD_EXP 21
1738: PUSH
1739: LD_INT -2
1741: PUSH
1742: LD_INT -3
1744: PUSH
1745: LD_INT -5
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PUSH
1755: LD_VAR 0 5
1759: ADD
1760: PUSH
1761: LD_INT -6
1763: PUSH
1764: LD_INT -4
1766: PUSH
1767: LD_EXP 30
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: LIST
1776: ADD
1777: PPUSH
1778: LD_INT 1
1780: PUSH
1781: LD_INT 4
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 3
1790: PUSH
1791: LD_INT 0
1793: PUSH
1794: LD_INT 5
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: PUSH
1802: LD_INT 4
1804: PUSH
1805: LD_INT 0
1807: PUSH
1808: LD_INT 3
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: LIST
1815: PUSH
1816: LD_INT 5
1818: PUSH
1819: LD_INT 0
1821: PUSH
1822: LD_INT 2
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL_OW 42
1840: ST_TO_ADDR
// others := tmp diff selected ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 5
1850: PUSH
1851: LD_EXP 19
1855: DIFF
1856: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1857: LD_ADDR_VAR 0 8
1861: PUSH
1862: LD_VAR 0 8
1866: PUSH
1867: LD_EXP 22
1871: PUSH
1872: LD_EXP 23
1876: PUSH
1877: LD_EXP 24
1881: PUSH
1882: LD_EXP 25
1886: PUSH
1887: LD_EXP 26
1891: PUSH
1892: LD_EXP 27
1896: PUSH
1897: LD_EXP 28
1901: PUSH
1902: LD_EXP 29
1906: PUSH
1907: LD_EXP 31
1911: PUSH
1912: LD_EXP 32
1916: PUSH
1917: LD_EXP 33
1921: PUSH
1922: LD_EXP 34
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: DIFF
1941: ST_TO_ADDR
// if others then
1942: LD_VAR 0 8
1946: IFFALSE 1960
// SaveCharacters ( others , 11_others ) ;
1948: LD_VAR 0 8
1952: PPUSH
1953: LD_STRING 11_others
1955: PPUSH
1956: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1960: LD_ADDR_VAR 0 6
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 1
1970: PUSH
1971: LD_INT 1
1973: PUSH
1974: LD_INT 4
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: PUSH
1983: LD_INT 2
1985: PUSH
1986: LD_INT 2
1988: PUSH
1989: LD_INT 1
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 1
2006: PUSH
2007: LD_INT 1
2009: PUSH
2010: LD_INT 5
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 2
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 1
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: PUSH
2037: LD_INT 3
2039: PUSH
2040: LD_INT 2
2042: PUSH
2043: LD_INT 1
2045: PUSH
2046: LD_INT 7
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: ST_TO_ADDR
// for i in JMM ^ selected do
2062: LD_ADDR_VAR 0 2
2066: PUSH
2067: LD_EXP 21
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: PUSH
2078: FOR_IN
2079: IFFALSE 2269
// begin if GetClass ( i ) = 3 then
2081: LD_VAR 0 2
2085: PPUSH
2086: CALL_OW 257
2090: PUSH
2091: LD_INT 3
2093: EQUAL
2094: IFFALSE 2252
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2096: LD_ADDR_OWVAR 37
2100: PUSH
2101: LD_VAR 0 6
2105: PUSH
2106: LD_INT 1
2108: ARRAY
2109: PUSH
2110: LD_INT 1
2112: ARRAY
2113: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2114: LD_ADDR_OWVAR 39
2118: PUSH
2119: LD_VAR 0 6
2123: PUSH
2124: LD_INT 1
2126: ARRAY
2127: PUSH
2128: LD_INT 2
2130: ARRAY
2131: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2132: LD_ADDR_OWVAR 38
2136: PUSH
2137: LD_VAR 0 6
2141: PUSH
2142: LD_INT 1
2144: ARRAY
2145: PUSH
2146: LD_INT 3
2148: ARRAY
2149: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2150: LD_ADDR_OWVAR 40
2154: PUSH
2155: LD_VAR 0 6
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2168: LD_ADDR_VAR 0 6
2172: PUSH
2173: LD_VAR 0 6
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: CALL_OW 3
2185: ST_TO_ADDR
// veh := CreateVehicle ;
2186: LD_ADDR_VAR 0 7
2190: PUSH
2191: CALL_OW 45
2195: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2196: LD_VAR 0 7
2200: PPUSH
2201: LD_INT 8
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_VAR 0 7
2220: PPUSH
2221: CALL_OW 52
// if i = JMM then
2225: LD_VAR 0 2
2229: PUSH
2230: LD_EXP 21
2234: EQUAL
2235: IFFALSE 2250
// SetMark ( veh , - 1 ) ;
2237: LD_VAR 0 7
2241: PPUSH
2242: LD_INT 1
2244: NEG
2245: PPUSH
2246: CALL_OW 242
// end else
2250: GO 2267
// PlaceUnitArea ( i , am_hum_start , false ) ;
2252: LD_VAR 0 2
2256: PPUSH
2257: LD_INT 9
2259: PPUSH
2260: LD_INT 0
2262: PPUSH
2263: CALL_OW 49
// end ;
2267: GO 2078
2269: POP
2270: POP
// vc_chassis := us_medium_tracked ;
2271: LD_ADDR_OWVAR 37
2275: PUSH
2276: LD_INT 3
2278: ST_TO_ADDR
// vc_engine := engine_solar ;
2279: LD_ADDR_OWVAR 39
2283: PUSH
2284: LD_INT 2
2286: ST_TO_ADDR
// vc_control := control_computer ;
2287: LD_ADDR_OWVAR 38
2291: PUSH
2292: LD_INT 3
2294: ST_TO_ADDR
// vc_weapon := us_radar ;
2295: LD_ADDR_OWVAR 40
2299: PUSH
2300: LD_INT 11
2302: ST_TO_ADDR
// veh := CreateVehicle ;
2303: LD_ADDR_VAR 0 7
2307: PUSH
2308: CALL_OW 45
2312: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2313: LD_VAR 0 7
2317: PPUSH
2318: LD_INT 87
2320: PPUSH
2321: LD_INT 142
2323: PPUSH
2324: LD_INT 0
2326: PPUSH
2327: CALL_OW 48
// end ;
2331: LD_VAR 0 1
2335: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2336: LD_INT 0
2338: PPUSH
2339: PPUSH
2340: PPUSH
2341: PPUSH
// uc_side := 1 ;
2342: LD_ADDR_OWVAR 20
2346: PUSH
2347: LD_INT 1
2349: ST_TO_ADDR
// uc_nation := 1 ;
2350: LD_ADDR_OWVAR 21
2354: PUSH
2355: LD_INT 1
2357: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2358: LD_ADDR_VAR 0 3
2362: PUSH
2363: LD_INT 3
2365: PUSH
2366: LD_INT 1
2368: PUSH
2369: LD_INT 3
2371: PUSH
2372: LD_INT 5
2374: PUSH
2375: EMPTY
2376: LIST
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 1
2386: PUSH
2387: LD_INT 3
2389: PUSH
2390: LD_INT 7
2392: PUSH
2393: EMPTY
2394: LIST
2395: LIST
2396: LIST
2397: LIST
2398: PUSH
2399: LD_INT 3
2401: PUSH
2402: LD_INT 1
2404: PUSH
2405: LD_INT 3
2407: PUSH
2408: LD_INT 7
2410: PUSH
2411: EMPTY
2412: LIST
2413: LIST
2414: LIST
2415: LIST
2416: PUSH
2417: LD_INT 3
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 11
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 4
2437: PUSH
2438: LD_INT 1
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 6
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 4
2455: PUSH
2456: LD_INT 1
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 5
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: LIST
2478: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2479: LD_ADDR_VAR 0 2
2483: PUSH
2484: DOUBLE
2485: LD_INT 1
2487: DEC
2488: ST_TO_ADDR
2489: LD_INT 7
2491: PUSH
2492: LD_OWVAR 67
2496: MINUS
2497: PUSH
2498: FOR_TO
2499: IFFALSE 2608
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2501: LD_ADDR_OWVAR 37
2505: PUSH
2506: LD_VAR 0 3
2510: PUSH
2511: LD_VAR 0 2
2515: ARRAY
2516: PUSH
2517: LD_INT 1
2519: ARRAY
2520: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2521: LD_ADDR_OWVAR 39
2525: PUSH
2526: LD_VAR 0 3
2530: PUSH
2531: LD_VAR 0 2
2535: ARRAY
2536: PUSH
2537: LD_INT 2
2539: ARRAY
2540: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2541: LD_ADDR_OWVAR 38
2545: PUSH
2546: LD_VAR 0 3
2550: PUSH
2551: LD_VAR 0 2
2555: ARRAY
2556: PUSH
2557: LD_INT 3
2559: ARRAY
2560: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2561: LD_ADDR_OWVAR 40
2565: PUSH
2566: LD_VAR 0 3
2570: PUSH
2571: LD_VAR 0 2
2575: ARRAY
2576: PUSH
2577: LD_INT 4
2579: ARRAY
2580: ST_TO_ADDR
// veh := CreateVehicle ;
2581: LD_ADDR_VAR 0 4
2585: PUSH
2586: CALL_OW 45
2590: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2591: LD_VAR 0 4
2595: PPUSH
2596: LD_INT 8
2598: PPUSH
2599: LD_INT 0
2601: PPUSH
2602: CALL_OW 49
// end ;
2606: GO 2498
2608: POP
2609: POP
// end ; end_of_file
2610: LD_VAR 0 1
2614: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2615: LD_INT 0
2617: PPUSH
2618: PPUSH
2619: PPUSH
2620: PPUSH
2621: PPUSH
2622: PPUSH
// if Difficulty = 1 then
2623: LD_OWVAR 67
2627: PUSH
2628: LD_INT 1
2630: EQUAL
2631: IFFALSE 2728
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2633: LD_ADDR_VAR 0 6
2637: PUSH
2638: LD_INT 129
2640: PUSH
2641: LD_INT 45
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 143
2650: PUSH
2651: LD_INT 58
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 184
2660: PUSH
2661: LD_INT 113
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: LD_INT 163
2670: PUSH
2671: LD_INT 107
2673: PUSH
2674: EMPTY
2675: LIST
2676: LIST
2677: PUSH
2678: EMPTY
2679: LIST
2680: LIST
2681: LIST
2682: LIST
2683: ST_TO_ADDR
// for i in tmp do
2684: LD_ADDR_VAR 0 2
2688: PUSH
2689: LD_VAR 0 6
2693: PUSH
2694: FOR_IN
2695: IFFALSE 2726
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2697: LD_VAR 0 2
2701: PUSH
2702: LD_INT 1
2704: ARRAY
2705: PPUSH
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 2
2713: ARRAY
2714: PPUSH
2715: CALL_OW 428
2719: PPUSH
2720: CALL_OW 64
2724: GO 2694
2726: POP
2727: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2728: LD_ADDR_VAR 0 2
2732: PUSH
2733: LD_INT 21
2735: PUSH
2736: LD_INT 3
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2786
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 5
2758: PUSH
2759: LD_INT 6
2761: PUSH
2762: LD_INT 7
2764: PUSH
2765: LD_INT 8
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: LIST
2772: LIST
2773: PUSH
2774: LD_OWVAR 67
2778: ARRAY
2779: PPUSH
2780: CALL_OW 241
2784: GO 2748
2786: POP
2787: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2788: LD_ADDR_VAR 0 5
2792: PUSH
2793: LD_INT 5
2795: PUSH
2796: LD_INT 6
2798: PUSH
2799: LD_INT 7
2801: PUSH
2802: LD_INT 8
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_OWVAR 67
2815: ARRAY
2816: ST_TO_ADDR
// uc_side := 2 ;
2817: LD_ADDR_OWVAR 20
2821: PUSH
2822: LD_INT 2
2824: ST_TO_ADDR
// uc_nation := 2 ;
2825: LD_ADDR_OWVAR 21
2829: PUSH
2830: LD_INT 2
2832: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2833: LD_ADDR_OWVAR 37
2837: PUSH
2838: LD_INT 14
2840: ST_TO_ADDR
// vc_engine := engine_siberite ;
2841: LD_ADDR_OWVAR 39
2845: PUSH
2846: LD_INT 3
2848: ST_TO_ADDR
// vc_control := control_manual ;
2849: LD_ADDR_OWVAR 38
2853: PUSH
2854: LD_INT 1
2856: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2857: LD_ADDR_OWVAR 40
2861: PUSH
2862: LD_INT 31
2864: ST_TO_ADDR
// for i = 1 to 3 do
2865: LD_ADDR_VAR 0 2
2869: PUSH
2870: DOUBLE
2871: LD_INT 1
2873: DEC
2874: ST_TO_ADDR
2875: LD_INT 3
2877: PUSH
2878: FOR_TO
2879: IFFALSE 2963
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2881: LD_INT 0
2883: PPUSH
2884: LD_INT 3
2886: PPUSH
2887: LD_VAR 0 5
2891: PPUSH
2892: CALL_OW 380
// un := CreateVehicle ;
2896: LD_ADDR_VAR 0 4
2900: PUSH
2901: CALL_OW 45
2905: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2906: LD_VAR 0 4
2910: PPUSH
2911: LD_INT 0
2913: PPUSH
2914: LD_INT 5
2916: PPUSH
2917: CALL_OW 12
2921: PPUSH
2922: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2926: LD_VAR 0 4
2930: PPUSH
2931: LD_INT 156
2933: PPUSH
2934: LD_INT 15
2936: PPUSH
2937: LD_INT 6
2939: PPUSH
2940: LD_INT 0
2942: PPUSH
2943: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2947: CALL_OW 44
2951: PPUSH
2952: LD_VAR 0 4
2956: PPUSH
2957: CALL_OW 52
// end ;
2961: GO 2878
2963: POP
2964: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2965: LD_ADDR_EXP 37
2969: PUSH
2970: LD_INT 94
2972: PPUSH
2973: LD_INT 28
2975: PPUSH
2976: LD_STRING dammam
2978: PPUSH
2979: LD_VAR 0 5
2983: PPUSH
2984: LD_INT 10000
2986: PUSH
2987: LD_INT 1000
2989: PUSH
2990: LD_INT 300
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: LIST
2997: PPUSH
2998: LD_INT 12
3000: PUSH
3001: LD_INT 2
3003: PUSH
3004: LD_INT 3
3006: PUSH
3007: LD_INT 4
3009: PUSH
3010: LD_INT 4
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_OWVAR 67
3023: ARRAY
3024: PUSH
3025: LD_INT 1
3027: NEG
3028: PUSH
3029: LD_INT 4
3031: PUSH
3032: EMPTY
3033: LIST
3034: LIST
3035: LIST
3036: LIST
3037: PPUSH
3038: CALL 57042 0 6
3042: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3043: LD_ADDR_EXP 37
3047: PUSH
3048: LD_EXP 37
3052: PUSH
3053: LD_INT 122
3055: PPUSH
3056: LD_INT 25
3058: PPUSH
3059: LD_STRING 
3061: PPUSH
3062: LD_VAR 0 5
3066: PPUSH
3067: LD_INT 500
3069: PUSH
3070: LD_INT 60
3072: PUSH
3073: LD_INT 0
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: PPUSH
3081: LD_INT 8
3083: PUSH
3084: LD_INT 2
3086: PUSH
3087: LD_INT 3
3089: PUSH
3090: LD_INT 4
3092: PUSH
3093: LD_INT 5
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: LIST
3100: LIST
3101: PUSH
3102: LD_OWVAR 67
3106: ARRAY
3107: PUSH
3108: LD_INT 2
3110: PUSH
3111: LD_INT 0
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL 57042 0 6
3124: UNION
3125: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3126: LD_ADDR_EXP 35
3130: PUSH
3131: LD_INT 45
3133: PPUSH
3134: LD_INT 24
3136: PPUSH
3137: LD_STRING jeddah
3139: PPUSH
3140: LD_VAR 0 5
3144: PPUSH
3145: LD_INT 700
3147: PUSH
3148: LD_INT 300
3150: PUSH
3151: LD_INT 10
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: PPUSH
3159: LD_INT 9
3161: PUSH
3162: LD_INT 4
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 2
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PPUSH
3177: CALL 57042 0 6
3181: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3182: LD_ADDR_EXP 36
3186: PUSH
3187: LD_INT 7
3189: PPUSH
3190: LD_INT 27
3192: PPUSH
3193: LD_STRING riyadh
3195: PPUSH
3196: LD_VAR 0 5
3200: PPUSH
3201: LD_INT 500
3203: PUSH
3204: LD_INT 60
3206: PUSH
3207: LD_INT 0
3209: PUSH
3210: EMPTY
3211: LIST
3212: LIST
3213: LIST
3214: PPUSH
3215: LD_INT 4
3217: PUSH
3218: LD_INT 2
3220: PUSH
3221: LD_INT 3
3223: PUSH
3224: LD_INT 1
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: PPUSH
3233: CALL 57042 0 6
3237: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3238: LD_ADDR_EXP 39
3242: PUSH
3243: LD_INT 204
3245: PPUSH
3246: LD_INT 26
3248: PPUSH
3249: LD_STRING 
3251: PPUSH
3252: LD_VAR 0 5
3256: PPUSH
3257: LD_INT 500
3259: PUSH
3260: LD_INT 50
3262: PUSH
3263: LD_INT 0
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: LIST
3270: PPUSH
3271: LD_INT 9
3273: PUSH
3274: LD_INT 2
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 1
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PPUSH
3289: CALL 57042 0 6
3293: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3294: LD_ADDR_EXP 50
3298: PUSH
3299: LD_EXP 37
3303: PUSH
3304: LD_EXP 35
3308: PUSH
3309: LD_EXP 39
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: LIST
3318: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3319: LD_ADDR_VAR 0 2
3323: PUSH
3324: LD_INT 22
3326: PUSH
3327: LD_INT 2
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 30
3336: PUSH
3337: LD_INT 31
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PUSH
3344: LD_INT 58
3346: PUSH
3347: EMPTY
3348: LIST
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: LIST
3354: PPUSH
3355: CALL_OW 69
3359: PUSH
3360: FOR_IN
3361: IFFALSE 3486
// begin if GetBase ( i ) then
3363: LD_VAR 0 2
3367: PPUSH
3368: CALL_OW 274
3372: IFFALSE 3376
// continue ;
3374: GO 3360
// d := GetDir ( i ) ;
3376: LD_ADDR_VAR 0 3
3380: PUSH
3381: LD_VAR 0 2
3385: PPUSH
3386: CALL_OW 254
3390: ST_TO_ADDR
// if d < 3 then
3391: LD_VAR 0 3
3395: PUSH
3396: LD_INT 3
3398: LESS
3399: IFFALSE 3417
// d := d + 3 else
3401: LD_ADDR_VAR 0 3
3405: PUSH
3406: LD_VAR 0 3
3410: PUSH
3411: LD_INT 3
3413: PLUS
3414: ST_TO_ADDR
3415: GO 3431
// d := d - 3 ;
3417: LD_ADDR_VAR 0 3
3421: PUSH
3422: LD_VAR 0 3
3426: PUSH
3427: LD_INT 3
3429: MINUS
3430: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3431: LD_INT 0
3433: PPUSH
3434: LD_INT 8
3436: PPUSH
3437: LD_VAR 0 5
3441: PPUSH
3442: CALL_OW 380
// un := CreateHuman ;
3446: LD_ADDR_VAR 0 4
3450: PUSH
3451: CALL_OW 44
3455: ST_TO_ADDR
// SetDir ( un , d ) ;
3456: LD_VAR 0 4
3460: PPUSH
3461: LD_VAR 0 3
3465: PPUSH
3466: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3470: LD_VAR 0 4
3474: PPUSH
3475: LD_VAR 0 2
3479: PPUSH
3480: CALL_OW 52
// end ;
3484: GO 3360
3486: POP
3487: POP
// if Difficulty > 1 then
3488: LD_OWVAR 67
3492: PUSH
3493: LD_INT 1
3495: GREATER
3496: IFFALSE 3867
// begin ar_kamikadze := [ ] ;
3498: LD_ADDR_EXP 42
3502: PUSH
3503: EMPTY
3504: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 1
3510: PPUSH
3511: LD_VAR 0 5
3515: PPUSH
3516: CALL_OW 380
// un := CreateHuman ;
3520: LD_ADDR_VAR 0 4
3524: PUSH
3525: CALL_OW 44
3529: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3530: LD_VAR 0 4
3534: PPUSH
3535: LD_INT 3
3537: PPUSH
3538: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3542: LD_VAR 0 4
3546: PPUSH
3547: LD_INT 23
3549: PPUSH
3550: LD_INT 44
3552: PPUSH
3553: LD_INT 0
3555: PPUSH
3556: CALL_OW 48
// ComCrawl ( un ) ;
3560: LD_VAR 0 4
3564: PPUSH
3565: CALL_OW 137
// un := CreateHuman ;
3569: LD_ADDR_VAR 0 4
3573: PUSH
3574: CALL_OW 44
3578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3579: LD_VAR 0 4
3583: PPUSH
3584: LD_INT 3
3586: PPUSH
3587: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3591: LD_VAR 0 4
3595: PPUSH
3596: LD_INT 30
3598: PPUSH
3599: LD_INT 39
3601: PPUSH
3602: LD_INT 0
3604: PPUSH
3605: CALL_OW 48
// ComCrawl ( un ) ;
3609: LD_VAR 0 4
3613: PPUSH
3614: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3618: LD_INT 0
3620: PPUSH
3621: LD_INT 17
3623: PPUSH
3624: LD_VAR 0 5
3628: PPUSH
3629: CALL_OW 380
// un := CreateHuman ;
3633: LD_ADDR_VAR 0 4
3637: PUSH
3638: CALL_OW 44
3642: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3643: LD_VAR 0 4
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3655: LD_VAR 0 4
3659: PPUSH
3660: LD_INT 45
3662: PPUSH
3663: LD_INT 86
3665: PPUSH
3666: LD_INT 0
3668: PPUSH
3669: CALL_OW 48
// ComHold ( un ) ;
3673: LD_VAR 0 4
3677: PPUSH
3678: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3682: LD_ADDR_EXP 42
3686: PUSH
3687: LD_EXP 42
3691: PPUSH
3692: LD_EXP 42
3696: PUSH
3697: LD_INT 1
3699: PLUS
3700: PPUSH
3701: LD_VAR 0 4
3705: PPUSH
3706: CALL_OW 1
3710: ST_TO_ADDR
// un := CreateHuman ;
3711: LD_ADDR_VAR 0 4
3715: PUSH
3716: CALL_OW 44
3720: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3721: LD_VAR 0 4
3725: PPUSH
3726: LD_INT 3
3728: PPUSH
3729: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3733: LD_VAR 0 4
3737: PPUSH
3738: LD_INT 60
3740: PPUSH
3741: LD_INT 85
3743: PPUSH
3744: LD_INT 0
3746: PPUSH
3747: CALL_OW 48
// ComHold ( un ) ;
3751: LD_VAR 0 4
3755: PPUSH
3756: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3760: LD_ADDR_EXP 42
3764: PUSH
3765: LD_EXP 42
3769: PPUSH
3770: LD_EXP 42
3774: PUSH
3775: LD_INT 1
3777: PLUS
3778: PPUSH
3779: LD_VAR 0 4
3783: PPUSH
3784: CALL_OW 1
3788: ST_TO_ADDR
// un := CreateHuman ;
3789: LD_ADDR_VAR 0 4
3793: PUSH
3794: CALL_OW 44
3798: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3799: LD_VAR 0 4
3803: PPUSH
3804: LD_INT 3
3806: PPUSH
3807: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3811: LD_VAR 0 4
3815: PPUSH
3816: LD_INT 222
3818: PPUSH
3819: LD_INT 166
3821: PPUSH
3822: LD_INT 0
3824: PPUSH
3825: CALL_OW 48
// ComHold ( un ) ;
3829: LD_VAR 0 4
3833: PPUSH
3834: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3838: LD_ADDR_EXP 42
3842: PUSH
3843: LD_EXP 42
3847: PPUSH
3848: LD_EXP 42
3852: PUSH
3853: LD_INT 1
3855: PLUS
3856: PPUSH
3857: LD_VAR 0 4
3861: PPUSH
3862: CALL_OW 1
3866: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3867: LD_ADDR_EXP 40
3871: PUSH
3872: EMPTY
3873: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3874: LD_INT 1
3876: PPUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_VAR 0 5
3884: PPUSH
3885: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3889: LD_ADDR_OWVAR 26
3893: PUSH
3894: LD_STRING Pavel Grigorovic
3896: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3897: LD_ADDR_OWVAR 33
3901: PUSH
3902: LD_STRING SecondCharsGal
3904: ST_TO_ADDR
// hc_face_number := 4 ;
3905: LD_ADDR_OWVAR 34
3909: PUSH
3910: LD_INT 4
3912: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3913: LD_ADDR_EXP 40
3917: PUSH
3918: LD_EXP 40
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: CALL_OW 44
3930: PPUSH
3931: CALL_OW 1
3935: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3936: LD_INT 2
3938: PPUSH
3939: LD_INT 4
3941: PPUSH
3942: LD_INT 2
3944: PPUSH
3945: CALL_OW 380
// hc_name := Lucy Sebel ;
3949: LD_ADDR_OWVAR 26
3953: PUSH
3954: LD_STRING Lucy Sebel
3956: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3957: LD_ADDR_OWVAR 33
3961: PUSH
3962: LD_STRING SecondCharsGal
3964: ST_TO_ADDR
// hc_face_number := 15 ;
3965: LD_ADDR_OWVAR 34
3969: PUSH
3970: LD_INT 15
3972: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3973: LD_ADDR_EXP 40
3977: PUSH
3978: LD_EXP 40
3982: PPUSH
3983: LD_INT 2
3985: PPUSH
3986: CALL_OW 44
3990: PPUSH
3991: CALL_OW 1
3995: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3996: LD_INT 2
3998: PPUSH
3999: LD_INT 4
4001: PPUSH
4002: LD_INT 2
4004: PPUSH
4005: CALL_OW 380
// hc_gallery :=  ;
4009: LD_ADDR_OWVAR 33
4013: PUSH
4014: LD_STRING 
4016: ST_TO_ADDR
// hc_name :=  ;
4017: LD_ADDR_OWVAR 26
4021: PUSH
4022: LD_STRING 
4024: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4025: LD_ADDR_EXP 40
4029: PUSH
4030: LD_EXP 40
4034: PPUSH
4035: LD_INT 3
4037: PPUSH
4038: CALL_OW 44
4042: PPUSH
4043: CALL_OW 1
4047: ST_TO_ADDR
// hc_sex := sex_male ;
4048: LD_ADDR_OWVAR 27
4052: PUSH
4053: LD_INT 1
4055: ST_TO_ADDR
// hc_class = 11 ;
4056: LD_ADDR_OWVAR 28
4060: PUSH
4061: LD_INT 11
4063: ST_TO_ADDR
// hc_gallery = sandar ;
4064: LD_ADDR_OWVAR 33
4068: PUSH
4069: LD_STRING sandar
4071: ST_TO_ADDR
// hc_face_number = 33 ;
4072: LD_ADDR_OWVAR 34
4076: PUSH
4077: LD_INT 33
4079: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4080: LD_ADDR_OWVAR 26
4084: PUSH
4085: LD_STRING Thabit Muhair Saliba
4087: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4088: LD_ADDR_OWVAR 31
4092: PUSH
4093: LD_INT 0
4095: PUSH
4096: LD_INT 0
4098: PUSH
4099: LD_INT 0
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: ST_TO_ADDR
// Saliba = CreateHuman ;
4111: LD_ADDR_EXP 44
4115: PUSH
4116: CALL_OW 44
4120: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4121: LD_EXP 44
4125: PPUSH
4126: LD_INT 7
4128: PPUSH
4129: CALL_OW 52
// if gensher_active then
4133: LD_EXP 18
4137: IFFALSE 4164
// begin Gensher = NewCharacter ( Dietrich ) ;
4139: LD_ADDR_EXP 45
4143: PUSH
4144: LD_STRING Dietrich
4146: PPUSH
4147: CALL_OW 25
4151: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4152: LD_EXP 45
4156: PPUSH
4157: LD_INT 94
4159: PPUSH
4160: CALL_OW 52
// end ; InitHc ;
4164: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4168: LD_ADDR_EXP 41
4172: PUSH
4173: EMPTY
4174: ST_TO_ADDR
// for i = 1 to 5 do
4175: LD_ADDR_VAR 0 2
4179: PUSH
4180: DOUBLE
4181: LD_INT 1
4183: DEC
4184: ST_TO_ADDR
4185: LD_INT 5
4187: PUSH
4188: FOR_TO
4189: IFFALSE 4361
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4191: LD_INT 13
4193: PUSH
4194: LD_INT 14
4196: PUSH
4197: EMPTY
4198: LIST
4199: LIST
4200: PUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 2
4206: PPUSH
4207: CALL_OW 12
4211: ARRAY
4212: PPUSH
4213: LD_INT 1
4215: PUSH
4216: LD_INT 2
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PUSH
4223: LD_INT 1
4225: PPUSH
4226: LD_INT 2
4228: PPUSH
4229: CALL_OW 12
4233: ARRAY
4234: PPUSH
4235: LD_INT 1
4237: PPUSH
4238: LD_INT 25
4240: PUSH
4241: LD_INT 27
4243: PUSH
4244: LD_INT 26
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: LIST
4251: PUSH
4252: LD_INT 1
4254: PPUSH
4255: LD_INT 3
4257: PPUSH
4258: CALL_OW 12
4262: ARRAY
4263: PPUSH
4264: LD_INT 60
4266: PPUSH
4267: LD_INT 100
4269: PPUSH
4270: CALL_OW 12
4274: PPUSH
4275: CALL 53596 0 5
// un := CreateVehicle ;
4279: LD_ADDR_VAR 0 4
4283: PUSH
4284: CALL_OW 45
4288: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4289: LD_ADDR_EXP 41
4293: PUSH
4294: LD_EXP 41
4298: PPUSH
4299: LD_EXP 41
4303: PUSH
4304: LD_INT 1
4306: PLUS
4307: PPUSH
4308: LD_VAR 0 4
4312: PPUSH
4313: CALL_OW 1
4317: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4318: LD_VAR 0 4
4322: PPUSH
4323: LD_INT 0
4325: PPUSH
4326: LD_INT 5
4328: PPUSH
4329: CALL_OW 12
4333: PPUSH
4334: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4338: LD_VAR 0 4
4342: PPUSH
4343: LD_INT 124
4345: PPUSH
4346: LD_INT 141
4348: PPUSH
4349: LD_INT 8
4351: PPUSH
4352: LD_INT 0
4354: PPUSH
4355: CALL_OW 50
// end ;
4359: GO 4188
4361: POP
4362: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4363: LD_ADDR_EXP 43
4367: PUSH
4368: EMPTY
4369: PUSH
4370: EMPTY
4371: PUSH
4372: EMPTY
4373: PUSH
4374: EMPTY
4375: LIST
4376: LIST
4377: LIST
4378: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4379: LD_ADDR_VAR 0 3
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: LD_INT 3
4394: PUSH
4395: LD_INT 4
4397: PUSH
4398: LD_INT 4
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: LIST
4405: LIST
4406: PUSH
4407: LD_OWVAR 67
4411: ARRAY
4412: PUSH
4413: FOR_TO
4414: IFFALSE 4628
// for i = 1 to 3 do
4416: LD_ADDR_VAR 0 2
4420: PUSH
4421: DOUBLE
4422: LD_INT 1
4424: DEC
4425: ST_TO_ADDR
4426: LD_INT 3
4428: PUSH
4429: FOR_TO
4430: IFFALSE 4624
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4432: LD_INT 14
4434: PPUSH
4435: LD_INT 3
4437: PUSH
4438: LD_INT 2
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PUSH
4445: LD_INT 1
4447: PPUSH
4448: LD_INT 2
4450: PPUSH
4451: CALL_OW 12
4455: ARRAY
4456: PPUSH
4457: LD_INT 1
4459: PUSH
4460: LD_INT 5
4462: PUSH
4463: EMPTY
4464: LIST
4465: LIST
4466: PUSH
4467: LD_INT 1
4469: PPUSH
4470: LD_INT 2
4472: PPUSH
4473: CALL_OW 12
4477: ARRAY
4478: PPUSH
4479: LD_INT 25
4481: PUSH
4482: LD_INT 27
4484: PUSH
4485: LD_INT 26
4487: PUSH
4488: LD_INT 28
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: PUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 4
4502: PPUSH
4503: CALL_OW 12
4507: ARRAY
4508: PPUSH
4509: LD_INT 100
4511: PPUSH
4512: CALL 53596 0 5
// un := CreateVehicle ;
4516: LD_ADDR_VAR 0 4
4520: PUSH
4521: CALL_OW 45
4525: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4526: LD_ADDR_EXP 43
4530: PUSH
4531: LD_EXP 43
4535: PPUSH
4536: LD_VAR 0 2
4540: PUSH
4541: LD_EXP 43
4545: PUSH
4546: LD_VAR 0 2
4550: ARRAY
4551: PUSH
4552: LD_INT 1
4554: PLUS
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PPUSH
4560: LD_VAR 0 4
4564: PPUSH
4565: CALL 53718 0 3
4569: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4570: LD_VAR 0 4
4574: PPUSH
4575: LD_INT 0
4577: PPUSH
4578: LD_INT 5
4580: PPUSH
4581: CALL_OW 12
4585: PPUSH
4586: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4590: LD_VAR 0 4
4594: PPUSH
4595: LD_INT 20
4597: PUSH
4598: LD_INT 21
4600: PUSH
4601: LD_INT 22
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: LIST
4608: PUSH
4609: LD_VAR 0 2
4613: ARRAY
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 49
// end ;
4622: GO 4429
4624: POP
4625: POP
4626: GO 4413
4628: POP
4629: POP
// InitHc ;
4630: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4634: LD_INT 4
4636: PPUSH
4637: LD_INT 5
4639: PPUSH
4640: LD_INT 10
4642: PPUSH
4643: LD_INT 5
4645: PPUSH
4646: LD_INT 0
4648: PPUSH
4649: CALL_OW 58
// end ;
4653: LD_VAR 0 1
4657: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4658: LD_EXP 42
4662: IFFALSE 4736
4664: GO 4666
4666: DISABLE
4667: LD_INT 0
4669: PPUSH
// begin enable ;
4670: ENABLE
// for i in ar_kamikadze do
4671: LD_ADDR_VAR 0 1
4675: PUSH
4676: LD_EXP 42
4680: PUSH
4681: FOR_IN
4682: IFFALSE 4734
// if See ( 1 , i ) then
4684: LD_INT 1
4686: PPUSH
4687: LD_VAR 0 1
4691: PPUSH
4692: CALL_OW 292
4696: IFFALSE 4732
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4698: LD_VAR 0 1
4702: PPUSH
4703: LD_INT 81
4705: PUSH
4706: LD_INT 2
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: PPUSH
4713: CALL_OW 69
4717: PPUSH
4718: LD_VAR 0 1
4722: PPUSH
4723: CALL_OW 74
4727: PPUSH
4728: CALL_OW 115
4732: GO 4681
4734: POP
4735: POP
// end ;
4736: PPOPN 1
4738: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4739: LD_EXP 13
4743: IFFALSE 5060
4745: GO 4747
4747: DISABLE
4748: LD_INT 0
4750: PPUSH
4751: PPUSH
4752: PPUSH
4753: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4754: LD_INT 35
4756: PPUSH
4757: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4761: LD_INT 1
4763: PPUSH
4764: CALL 42521 0 1
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: IFFALSE 4754
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4774: LD_INT 1
4776: PPUSH
4777: LD_INT 14
4779: PUSH
4780: LD_INT 3
4782: PUSH
4783: LD_INT 2
4785: PUSH
4786: LD_INT 32
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: PPUSH
4798: CALL 42125 0 2
// repeat wait ( 0 0$1 ) ;
4802: LD_INT 35
4804: PPUSH
4805: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4809: LD_EXP 69
4813: PUSH
4814: LD_INT 1
4816: ARRAY
4817: PPUSH
4818: LD_INT 33
4820: PUSH
4821: LD_INT 2
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: LD_INT 34
4830: PUSH
4831: LD_INT 32
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PPUSH
4842: CALL_OW 72
4846: IFFALSE 4802
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4848: LD_ADDR_VAR 0 2
4852: PUSH
4853: LD_EXP 69
4857: PUSH
4858: LD_INT 1
4860: ARRAY
4861: PPUSH
4862: LD_INT 33
4864: PUSH
4865: LD_INT 2
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: LD_INT 34
4874: PUSH
4875: LD_INT 32
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PPUSH
4886: CALL_OW 72
4890: PUSH
4891: LD_INT 1
4893: ARRAY
4894: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4895: LD_ADDR_VAR 0 4
4899: PUSH
4900: LD_INT 5
4902: PPUSH
4903: CALL_OW 469
4907: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4908: LD_INT 35
4910: PPUSH
4911: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4915: LD_ADDR_VAR 0 4
4919: PUSH
4920: LD_INT 5
4922: PPUSH
4923: CALL_OW 469
4927: ST_TO_ADDR
// tmp := 100 ;
4928: LD_ADDR_VAR 0 3
4932: PUSH
4933: LD_INT 100
4935: ST_TO_ADDR
// if pos then
4936: LD_VAR 0 4
4940: IFFALSE 4980
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4942: LD_ADDR_VAR 0 3
4946: PUSH
4947: LD_INT 2
4949: PPUSH
4950: LD_VAR 0 4
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 2
4966: ARRAY
4967: PPUSH
4968: LD_INT 20
4970: PPUSH
4971: CALL 54614 0 4
4975: PUSH
4976: LD_INT 4
4978: ARRAY
4979: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4980: LD_VAR 0 4
4984: PUSH
4985: LD_EXP 14
4989: NOT
4990: AND
4991: PUSH
4992: LD_VAR 0 3
4996: PUSH
4997: LD_INT 10
4999: LESS
5000: AND
5001: IFFALSE 4908
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5003: LD_VAR 0 2
5007: PPUSH
5008: LD_VAR 0 4
5012: PUSH
5013: LD_INT 1
5015: ARRAY
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 2
5024: ARRAY
5025: PPUSH
5026: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5030: LD_VAR 0 2
5034: PPUSH
5035: LD_INT 198
5037: PPUSH
5038: LD_INT 113
5040: PPUSH
5041: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5045: LD_VAR 0 2
5049: PPUSH
5050: LD_INT 124
5052: PPUSH
5053: LD_INT 7
5055: PPUSH
5056: CALL_OW 171
// end ;
5060: PPOPN 4
5062: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5063: LD_EXP 6
5067: IFFALSE 7936
5069: GO 5071
5071: DISABLE
5072: LD_INT 0
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
5079: PPUSH
5080: PPUSH
5081: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5082: LD_ADDR_VAR 0 4
5086: PUSH
5087: LD_INT 5
5089: PUSH
5090: LD_INT 6
5092: PUSH
5093: LD_INT 7
5095: PUSH
5096: LD_INT 8
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_OWVAR 67
5109: ARRAY
5110: ST_TO_ADDR
// coords := [ ] ;
5111: LD_ADDR_VAR 0 5
5115: PUSH
5116: EMPTY
5117: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5118: LD_ADDR_VAR 0 6
5122: PUSH
5123: LD_INT 0
5125: PUSH
5126: LD_INT 0
5128: PUSH
5129: LD_INT 0
5131: PUSH
5132: LD_INT 0
5134: PUSH
5135: LD_INT 1
5137: PUSH
5138: LD_INT 0
5140: PUSH
5141: LD_INT 0
5143: PUSH
5144: LD_INT 0
5146: PUSH
5147: LD_INT 1
5149: PUSH
5150: LD_INT 0
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: LIST
5164: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5165: LD_INT 1
5167: PPUSH
5168: LD_INT 14
5170: PUSH
5171: LD_INT 1
5173: PUSH
5174: LD_INT 2
5176: PUSH
5177: LD_INT 28
5179: PUSH
5180: EMPTY
5181: LIST
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 14
5188: PUSH
5189: LD_INT 1
5191: PUSH
5192: LD_INT 2
5194: PUSH
5195: LD_INT 25
5197: PUSH
5198: EMPTY
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: PUSH
5204: LD_INT 14
5206: PUSH
5207: LD_INT 1
5209: PUSH
5210: LD_INT 2
5212: PUSH
5213: LD_INT 28
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_INT 14
5224: PUSH
5225: LD_INT 1
5227: PUSH
5228: LD_INT 2
5230: PUSH
5231: LD_INT 29
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: PPUSH
5246: CALL 42125 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5250: LD_INT 21000
5252: PUSH
5253: LD_INT 19950
5255: PUSH
5256: LD_INT 18900
5258: PUSH
5259: LD_INT 18200
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: LIST
5266: LIST
5267: PUSH
5268: LD_OWVAR 67
5272: ARRAY
5273: PPUSH
5274: CALL_OW 67
// InitHc ;
5278: CALL_OW 19
// InitUc ;
5282: CALL_OW 18
// uc_side := 2 ;
5286: LD_ADDR_OWVAR 20
5290: PUSH
5291: LD_INT 2
5293: ST_TO_ADDR
// uc_nation := 2 ;
5294: LD_ADDR_OWVAR 21
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5302: LD_ADDR_VAR 0 3
5306: PUSH
5307: EMPTY
5308: PUSH
5309: EMPTY
5310: PUSH
5311: EMPTY
5312: PUSH
5313: EMPTY
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: LIST
5323: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5324: LD_ADDR_VAR 0 3
5328: PUSH
5329: LD_VAR 0 3
5333: PPUSH
5334: LD_INT 1
5336: PPUSH
5337: LD_EXP 69
5341: PUSH
5342: LD_INT 1
5344: ARRAY
5345: PUSH
5346: LD_INT 2
5348: PUSH
5349: LD_INT 34
5351: PUSH
5352: LD_EXP 100
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: PUSH
5361: LD_INT 34
5363: PUSH
5364: LD_INT 32
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL_OW 69
5380: DIFF
5381: PPUSH
5382: CALL_OW 1
5386: ST_TO_ADDR
// for i = 1 to Difficulty do
5387: LD_ADDR_VAR 0 1
5391: PUSH
5392: DOUBLE
5393: LD_INT 1
5395: DEC
5396: ST_TO_ADDR
5397: LD_OWVAR 67
5401: PUSH
5402: FOR_TO
5403: IFFALSE 5541
// begin uc_side := 2 ;
5405: LD_ADDR_OWVAR 20
5409: PUSH
5410: LD_INT 2
5412: ST_TO_ADDR
// uc_nation := 2 ;
5413: LD_ADDR_OWVAR 21
5417: PUSH
5418: LD_INT 2
5420: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5421: LD_INT 13
5423: PPUSH
5424: LD_INT 3
5426: PPUSH
5427: LD_INT 5
5429: PPUSH
5430: LD_INT 29
5432: PPUSH
5433: LD_INT 100
5435: PPUSH
5436: CALL 53596 0 5
// un := CreateVehicle ;
5440: LD_ADDR_VAR 0 2
5444: PUSH
5445: CALL_OW 45
5449: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5450: LD_ADDR_VAR 0 3
5454: PUSH
5455: LD_VAR 0 3
5459: PPUSH
5460: LD_INT 1
5462: PUSH
5463: LD_VAR 0 3
5467: PUSH
5468: LD_INT 1
5470: ARRAY
5471: PUSH
5472: LD_INT 1
5474: PLUS
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_VAR 0 2
5484: PPUSH
5485: CALL 53718 0 3
5489: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5490: LD_VAR 0 2
5494: PPUSH
5495: LD_INT 3
5497: PPUSH
5498: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5502: LD_VAR 0 2
5506: PPUSH
5507: LD_INT 16
5509: PPUSH
5510: LD_INT 0
5512: PPUSH
5513: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5517: LD_VAR 0 2
5521: PPUSH
5522: LD_INT 51
5524: PPUSH
5525: LD_INT 10
5527: PPUSH
5528: CALL_OW 111
// wait ( 0 0$2 ) ;
5532: LD_INT 70
5534: PPUSH
5535: CALL_OW 67
// end ;
5539: GO 5402
5541: POP
5542: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5543: LD_ADDR_VAR 0 5
5547: PUSH
5548: LD_INT 51
5550: PUSH
5551: LD_INT 24
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PUSH
5558: LD_INT 75
5560: PUSH
5561: LD_INT 90
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5572: LD_INT 1
5574: PPUSH
5575: LD_VAR 0 3
5579: PUSH
5580: LD_INT 1
5582: ARRAY
5583: PPUSH
5584: LD_VAR 0 5
5588: PPUSH
5589: LD_VAR 0 6
5593: PPUSH
5594: CALL 42358 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5598: LD_ADDR_VAR 0 1
5602: PUSH
5603: DOUBLE
5604: LD_INT 1
5606: DEC
5607: ST_TO_ADDR
5608: LD_INT 1
5610: PUSH
5611: LD_INT 3
5613: PUSH
5614: LD_INT 3
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: LIST
5624: LIST
5625: PUSH
5626: LD_OWVAR 67
5630: ARRAY
5631: PUSH
5632: FOR_TO
5633: IFFALSE 5733
// begin uc_side := 2 ;
5635: LD_ADDR_OWVAR 20
5639: PUSH
5640: LD_INT 2
5642: ST_TO_ADDR
// uc_nation := 2 ;
5643: LD_ADDR_OWVAR 21
5647: PUSH
5648: LD_INT 2
5650: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5651: LD_INT 0
5653: PPUSH
5654: LD_INT 17
5656: PPUSH
5657: LD_VAR 0 4
5661: PPUSH
5662: CALL_OW 380
// un := CreateHuman ;
5666: LD_ADDR_VAR 0 2
5670: PUSH
5671: CALL_OW 44
5675: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5676: LD_ADDR_VAR 0 3
5680: PUSH
5681: LD_VAR 0 3
5685: PPUSH
5686: LD_INT 2
5688: PUSH
5689: LD_VAR 0 3
5693: PUSH
5694: LD_INT 2
5696: ARRAY
5697: PUSH
5698: LD_INT 1
5700: PLUS
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: PPUSH
5706: LD_VAR 0 2
5710: PPUSH
5711: CALL 53718 0 3
5715: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5716: LD_VAR 0 2
5720: PPUSH
5721: LD_INT 13
5723: PPUSH
5724: LD_INT 0
5726: PPUSH
5727: CALL_OW 49
// end ;
5731: GO 5632
5733: POP
5734: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5735: LD_ADDR_VAR 0 1
5739: PUSH
5740: DOUBLE
5741: LD_INT 1
5743: DEC
5744: ST_TO_ADDR
5745: LD_INT 3
5747: PUSH
5748: LD_INT 4
5750: PUSH
5751: LD_INT 4
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: LIST
5761: LIST
5762: PUSH
5763: LD_OWVAR 67
5767: ARRAY
5768: PUSH
5769: FOR_TO
5770: IFFALSE 5891
// begin uc_side := 2 ;
5772: LD_ADDR_OWVAR 20
5776: PUSH
5777: LD_INT 2
5779: ST_TO_ADDR
// uc_nation := 2 ;
5780: LD_ADDR_OWVAR 21
5784: PUSH
5785: LD_INT 2
5787: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5788: LD_INT 0
5790: PPUSH
5791: LD_INT 1
5793: PUSH
5794: LD_INT 8
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: PUSH
5801: LD_VAR 0 1
5805: PUSH
5806: LD_INT 2
5808: MOD
5809: PUSH
5810: LD_INT 1
5812: PLUS
5813: ARRAY
5814: PPUSH
5815: LD_VAR 0 4
5819: PPUSH
5820: CALL_OW 380
// un := CreateHuman ;
5824: LD_ADDR_VAR 0 2
5828: PUSH
5829: CALL_OW 44
5833: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5834: LD_ADDR_VAR 0 3
5838: PUSH
5839: LD_VAR 0 3
5843: PPUSH
5844: LD_INT 2
5846: PUSH
5847: LD_VAR 0 3
5851: PUSH
5852: LD_INT 2
5854: ARRAY
5855: PUSH
5856: LD_INT 1
5858: PLUS
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: PPUSH
5864: LD_VAR 0 2
5868: PPUSH
5869: CALL 53718 0 3
5873: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5874: LD_VAR 0 2
5878: PPUSH
5879: LD_INT 13
5881: PPUSH
5882: LD_INT 0
5884: PPUSH
5885: CALL_OW 49
// end ;
5889: GO 5769
5891: POP
5892: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5893: LD_ADDR_VAR 0 5
5897: PUSH
5898: LD_INT 67
5900: PUSH
5901: LD_INT 112
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 85
5910: PUSH
5911: LD_INT 130
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5922: LD_INT 2
5924: PPUSH
5925: LD_VAR 0 3
5929: PUSH
5930: LD_INT 2
5932: ARRAY
5933: PPUSH
5934: LD_VAR 0 5
5938: PPUSH
5939: LD_VAR 0 6
5943: PPUSH
5944: CALL 42358 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5948: LD_ADDR_VAR 0 1
5952: PUSH
5953: DOUBLE
5954: LD_INT 1
5956: DEC
5957: ST_TO_ADDR
5958: LD_INT 1
5960: PUSH
5961: LD_INT 2
5963: PUSH
5964: LD_INT 3
5966: PUSH
5967: LD_INT 4
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: PUSH
5976: LD_OWVAR 67
5980: ARRAY
5981: PUSH
5982: FOR_TO
5983: IFFALSE 6083
// begin uc_side := 2 ;
5985: LD_ADDR_OWVAR 20
5989: PUSH
5990: LD_INT 2
5992: ST_TO_ADDR
// uc_nation := 2 ;
5993: LD_ADDR_OWVAR 21
5997: PUSH
5998: LD_INT 2
6000: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6001: LD_INT 0
6003: PPUSH
6004: LD_INT 17
6006: PPUSH
6007: LD_VAR 0 4
6011: PPUSH
6012: CALL_OW 380
// un := CreateHuman ;
6016: LD_ADDR_VAR 0 2
6020: PUSH
6021: CALL_OW 44
6025: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6026: LD_ADDR_VAR 0 3
6030: PUSH
6031: LD_VAR 0 3
6035: PPUSH
6036: LD_INT 3
6038: PUSH
6039: LD_VAR 0 3
6043: PUSH
6044: LD_INT 3
6046: ARRAY
6047: PUSH
6048: LD_INT 1
6050: PLUS
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PPUSH
6056: LD_VAR 0 2
6060: PPUSH
6061: CALL 53718 0 3
6065: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6066: LD_VAR 0 2
6070: PPUSH
6071: LD_INT 14
6073: PPUSH
6074: LD_INT 0
6076: PPUSH
6077: CALL_OW 49
// end ;
6081: GO 5982
6083: POP
6084: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6085: LD_ADDR_VAR 0 5
6089: PUSH
6090: LD_INT 148
6092: PUSH
6093: LD_INT 158
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 148
6102: PUSH
6103: LD_INT 158
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6114: LD_INT 3
6116: PPUSH
6117: LD_VAR 0 3
6121: PUSH
6122: LD_INT 3
6124: ARRAY
6125: PPUSH
6126: LD_VAR 0 5
6130: PPUSH
6131: LD_VAR 0 6
6135: PPUSH
6136: CALL 42358 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6140: LD_ADDR_VAR 0 1
6144: PUSH
6145: DOUBLE
6146: LD_INT 1
6148: DEC
6149: ST_TO_ADDR
6150: LD_INT 2
6152: PUSH
6153: LD_INT 3
6155: PUSH
6156: LD_INT 4
6158: PUSH
6159: LD_INT 4
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: LIST
6166: LIST
6167: PUSH
6168: LD_OWVAR 67
6172: ARRAY
6173: PUSH
6174: FOR_TO
6175: IFFALSE 6399
// begin uc_side := 2 ;
6177: LD_ADDR_OWVAR 20
6181: PUSH
6182: LD_INT 2
6184: ST_TO_ADDR
// uc_nation := 2 ;
6185: LD_ADDR_OWVAR 21
6189: PUSH
6190: LD_INT 2
6192: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6193: LD_INT 14
6195: PPUSH
6196: LD_INT 3
6198: PPUSH
6199: LD_INT 1
6201: PUSH
6202: LD_INT 5
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 1
6211: PPUSH
6212: LD_INT 2
6214: PPUSH
6215: CALL_OW 12
6219: ARRAY
6220: PPUSH
6221: LD_INT 27
6223: PUSH
6224: LD_INT 26
6226: PUSH
6227: LD_INT 28
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 1
6237: PPUSH
6238: LD_INT 3
6240: PPUSH
6241: CALL_OW 12
6245: ARRAY
6246: PPUSH
6247: LD_INT 100
6249: PPUSH
6250: CALL 53596 0 5
// un := CreateVehicle ;
6254: LD_ADDR_VAR 0 2
6258: PUSH
6259: CALL_OW 45
6263: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6264: LD_ADDR_VAR 0 3
6268: PUSH
6269: LD_VAR 0 3
6273: PPUSH
6274: LD_INT 4
6276: PUSH
6277: LD_VAR 0 3
6281: PUSH
6282: LD_INT 4
6284: ARRAY
6285: PUSH
6286: LD_INT 1
6288: PLUS
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_VAR 0 2
6298: PPUSH
6299: CALL 53718 0 3
6303: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6304: LD_VAR 0 2
6308: PPUSH
6309: LD_INT 5
6311: PPUSH
6312: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6316: LD_VAR 0 2
6320: PPUSH
6321: LD_INT 15
6323: PPUSH
6324: LD_INT 0
6326: PPUSH
6327: CALL_OW 49
// if GetControl ( un ) = control_manual then
6331: LD_VAR 0 2
6335: PPUSH
6336: CALL_OW 263
6340: PUSH
6341: LD_INT 1
6343: EQUAL
6344: IFFALSE 6375
// begin PrepareHuman ( false , 3 , skill ) ;
6346: LD_INT 0
6348: PPUSH
6349: LD_INT 3
6351: PPUSH
6352: LD_VAR 0 4
6356: PPUSH
6357: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6361: CALL_OW 44
6365: PPUSH
6366: LD_VAR 0 2
6370: PPUSH
6371: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6375: LD_VAR 0 2
6379: PPUSH
6380: LD_INT 179
6382: PPUSH
6383: LD_INT 135
6385: PPUSH
6386: CALL_OW 111
// wait ( 0 0$2 ) ;
6390: LD_INT 70
6392: PPUSH
6393: CALL_OW 67
// end ;
6397: GO 6174
6399: POP
6400: POP
// vc_chassis := 15 ;
6401: LD_ADDR_OWVAR 37
6405: PUSH
6406: LD_INT 15
6408: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6409: LD_ADDR_VAR 0 3
6413: PUSH
6414: LD_VAR 0 3
6418: PPUSH
6419: LD_INT 4
6421: PUSH
6422: LD_VAR 0 3
6426: PUSH
6427: LD_INT 4
6429: ARRAY
6430: PUSH
6431: LD_INT 1
6433: PLUS
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: PPUSH
6439: CALL_OW 45
6443: PPUSH
6444: CALL 53718 0 3
6448: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6449: LD_VAR 0 3
6453: PUSH
6454: LD_INT 4
6456: ARRAY
6457: PUSH
6458: LD_VAR 0 3
6462: PUSH
6463: LD_INT 4
6465: ARRAY
6466: ARRAY
6467: PPUSH
6468: LD_INT 15
6470: PPUSH
6471: LD_INT 0
6473: PPUSH
6474: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6478: LD_INT 0
6480: PPUSH
6481: LD_INT 11
6483: PPUSH
6484: LD_VAR 0 4
6488: PPUSH
6489: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6493: LD_ADDR_VAR 0 3
6497: PUSH
6498: LD_VAR 0 3
6502: PPUSH
6503: LD_INT 4
6505: PUSH
6506: LD_VAR 0 3
6510: PUSH
6511: LD_INT 4
6513: ARRAY
6514: PUSH
6515: LD_INT 1
6517: PLUS
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PPUSH
6523: CALL_OW 44
6527: PPUSH
6528: CALL 53718 0 3
6532: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6533: LD_VAR 0 3
6537: PUSH
6538: LD_INT 4
6540: ARRAY
6541: PUSH
6542: LD_VAR 0 3
6546: PUSH
6547: LD_INT 4
6549: ARRAY
6550: ARRAY
6551: PPUSH
6552: LD_VAR 0 3
6556: PUSH
6557: LD_INT 4
6559: ARRAY
6560: PUSH
6561: LD_VAR 0 3
6565: PUSH
6566: LD_INT 4
6568: ARRAY
6569: PUSH
6570: LD_INT 1
6572: MINUS
6573: ARRAY
6574: PPUSH
6575: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6579: LD_ADDR_VAR 0 5
6583: PUSH
6584: LD_INT 148
6586: PUSH
6587: LD_INT 140
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6597: LD_INT 1
6599: PPUSH
6600: LD_VAR 0 3
6604: PUSH
6605: LD_INT 4
6607: ARRAY
6608: PPUSH
6609: LD_VAR 0 5
6613: PPUSH
6614: LD_VAR 0 6
6618: PPUSH
6619: CALL 42358 0 4
// if gensher_active then
6623: LD_EXP 18
6627: IFFALSE 7033
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6629: LD_EXP 45
6633: PPUSH
6634: LD_STRING D10-Diet-1
6636: PPUSH
6637: CALL_OW 94
// for i = 1 to 2 do
6641: LD_ADDR_VAR 0 1
6645: PUSH
6646: DOUBLE
6647: LD_INT 1
6649: DEC
6650: ST_TO_ADDR
6651: LD_INT 2
6653: PUSH
6654: FOR_TO
6655: IFFALSE 6793
// begin uc_side := 2 ;
6657: LD_ADDR_OWVAR 20
6661: PUSH
6662: LD_INT 2
6664: ST_TO_ADDR
// uc_nation := 2 ;
6665: LD_ADDR_OWVAR 21
6669: PUSH
6670: LD_INT 2
6672: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6673: LD_INT 13
6675: PPUSH
6676: LD_INT 3
6678: PPUSH
6679: LD_INT 5
6681: PPUSH
6682: LD_INT 29
6684: PPUSH
6685: LD_INT 100
6687: PPUSH
6688: CALL 53596 0 5
// un := CreateVehicle ;
6692: LD_ADDR_VAR 0 2
6696: PUSH
6697: CALL_OW 45
6701: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6702: LD_ADDR_VAR 0 3
6706: PUSH
6707: LD_VAR 0 3
6711: PPUSH
6712: LD_INT 5
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_INT 5
6722: ARRAY
6723: PUSH
6724: LD_INT 1
6726: PLUS
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PPUSH
6732: LD_VAR 0 2
6736: PPUSH
6737: CALL 53718 0 3
6741: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6742: LD_VAR 0 2
6746: PPUSH
6747: LD_INT 0
6749: PPUSH
6750: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6754: LD_VAR 0 2
6758: PPUSH
6759: LD_INT 23
6761: PPUSH
6762: LD_INT 0
6764: PPUSH
6765: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6769: LD_VAR 0 2
6773: PPUSH
6774: LD_INT 85
6776: PPUSH
6777: LD_INT 152
6779: PPUSH
6780: CALL_OW 111
// wait ( 0 0$2 ) ;
6784: LD_INT 70
6786: PPUSH
6787: CALL_OW 67
// end ;
6791: GO 6654
6793: POP
6794: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6795: LD_ADDR_VAR 0 1
6799: PUSH
6800: DOUBLE
6801: LD_INT 1
6803: DEC
6804: ST_TO_ADDR
6805: LD_INT 2
6807: PUSH
6808: LD_INT 3
6810: PUSH
6811: LD_INT 3
6813: PUSH
6814: LD_INT 4
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: PUSH
6823: LD_OWVAR 67
6827: ARRAY
6828: PUSH
6829: FOR_TO
6830: IFFALSE 6987
// begin uc_side := 2 ;
6832: LD_ADDR_OWVAR 20
6836: PUSH
6837: LD_INT 2
6839: ST_TO_ADDR
// uc_nation := 2 ;
6840: LD_ADDR_OWVAR 21
6844: PUSH
6845: LD_INT 2
6847: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6848: LD_INT 14
6850: PPUSH
6851: LD_INT 3
6853: PPUSH
6854: LD_INT 5
6856: PPUSH
6857: LD_INT 27
6859: PUSH
6860: LD_INT 28
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: PUSH
6867: LD_INT 1
6869: PPUSH
6870: LD_INT 2
6872: PPUSH
6873: CALL_OW 12
6877: ARRAY
6878: PPUSH
6879: LD_INT 100
6881: PPUSH
6882: CALL 53596 0 5
// un := CreateVehicle ;
6886: LD_ADDR_VAR 0 2
6890: PUSH
6891: CALL_OW 45
6895: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6896: LD_ADDR_VAR 0 3
6900: PUSH
6901: LD_VAR 0 3
6905: PPUSH
6906: LD_INT 5
6908: PUSH
6909: LD_VAR 0 3
6913: PUSH
6914: LD_INT 5
6916: ARRAY
6917: PUSH
6918: LD_INT 1
6920: PLUS
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PPUSH
6926: LD_VAR 0 2
6930: PPUSH
6931: CALL 53718 0 3
6935: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6936: LD_VAR 0 2
6940: PPUSH
6941: LD_INT 0
6943: PPUSH
6944: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6948: LD_VAR 0 2
6952: PPUSH
6953: LD_INT 23
6955: PPUSH
6956: LD_INT 0
6958: PPUSH
6959: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6963: LD_VAR 0 2
6967: PPUSH
6968: LD_INT 85
6970: PPUSH
6971: LD_INT 152
6973: PPUSH
6974: CALL_OW 111
// wait ( 0 0$2 ) ;
6978: LD_INT 70
6980: PPUSH
6981: CALL_OW 67
// end ;
6985: GO 6829
6987: POP
6988: POP
// coords := [ [ 97 , 143 ] ] ;
6989: LD_ADDR_VAR 0 5
6993: PUSH
6994: LD_INT 97
6996: PUSH
6997: LD_INT 143
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7007: LD_INT 1
7009: PPUSH
7010: LD_VAR 0 3
7014: PUSH
7015: LD_INT 5
7017: ARRAY
7018: PPUSH
7019: LD_VAR 0 5
7023: PPUSH
7024: LD_VAR 0 6
7028: PPUSH
7029: CALL 42358 0 4
// end ; Wait ( 13 13$00 ) ;
7033: LD_INT 27300
7035: PPUSH
7036: CALL_OW 67
// tmp := [ ] ;
7040: LD_ADDR_VAR 0 3
7044: PUSH
7045: EMPTY
7046: ST_TO_ADDR
// w := 1 ;
7047: LD_ADDR_VAR 0 7
7051: PUSH
7052: LD_INT 1
7054: ST_TO_ADDR
// repeat tmp := [ ] ;
7055: LD_ADDR_VAR 0 3
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// if w mod 4 = 0 then
7062: LD_VAR 0 7
7066: PUSH
7067: LD_INT 4
7069: MOD
7070: PUSH
7071: LD_INT 0
7073: EQUAL
7074: IFFALSE 7161
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7076: LD_ADDR_VAR 0 8
7080: PUSH
7081: LD_INT 11
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: LD_INT 2
7089: PUSH
7090: LD_INT 24
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: PUSH
7099: LD_INT 11
7101: PUSH
7102: LD_INT 1
7104: PUSH
7105: LD_INT 2
7107: PUSH
7108: LD_INT 24
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 11
7119: PUSH
7120: LD_INT 1
7122: PUSH
7123: LD_INT 2
7125: PUSH
7126: LD_INT 24
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: LIST
7133: LIST
7134: PUSH
7135: LD_INT 11
7137: PUSH
7138: LD_INT 1
7140: PUSH
7141: LD_INT 2
7143: PUSH
7144: LD_INT 24
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: LIST
7151: LIST
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: ST_TO_ADDR
7159: GO 7263
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7161: LD_ADDR_VAR 0 8
7165: PUSH
7166: LD_INT 14
7168: PUSH
7169: LD_INT 1
7171: PUSH
7172: LD_INT 2
7174: PUSH
7175: LD_INT 28
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_INT 14
7186: PUSH
7187: LD_INT 1
7189: PUSH
7190: LD_INT 2
7192: PUSH
7193: LD_INT 25
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: LIST
7200: LIST
7201: PUSH
7202: LD_INT 14
7204: PUSH
7205: LD_INT 1
7207: PUSH
7208: LD_INT 2
7210: PUSH
7211: LD_INT 28
7213: PUSH
7214: EMPTY
7215: LIST
7216: LIST
7217: LIST
7218: LIST
7219: PUSH
7220: LD_INT 14
7222: PUSH
7223: LD_INT 1
7225: PUSH
7226: LD_INT 2
7228: PUSH
7229: LD_INT 29
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PUSH
7238: LD_INT 11
7240: PUSH
7241: LD_INT 1
7243: PUSH
7244: LD_INT 2
7246: PUSH
7247: LD_INT 24
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: LIST
7254: LIST
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: LIST
7262: ST_TO_ADDR
// if w mod 3 = 0 then
7263: LD_VAR 0 7
7267: PUSH
7268: LD_INT 3
7270: MOD
7271: PUSH
7272: LD_INT 0
7274: EQUAL
7275: IFFALSE 7351
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7277: LD_ADDR_VAR 0 8
7281: PUSH
7282: LD_VAR 0 8
7286: PPUSH
7287: LD_INT 1
7289: PUSH
7290: LD_VAR 0 8
7294: PUSH
7295: LD_VAR 0 1
7299: ARRAY
7300: PUSH
7301: LD_INT 1
7303: PLUS
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: PPUSH
7309: LD_INT 14
7311: PUSH
7312: LD_INT 1
7314: PUSH
7315: LD_INT 2
7317: PUSH
7318: LD_INT 25
7320: PUSH
7321: LD_INT 28
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: CALL_OW 12
7338: ARRAY
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: LIST
7344: LIST
7345: PPUSH
7346: CALL 53718 0 3
7350: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7351: LD_INT 1
7353: PPUSH
7354: LD_VAR 0 8
7358: PPUSH
7359: CALL 42125 0 2
// if GetSide ( ar_dep_w ) = 2 then
7363: LD_INT 45
7365: PPUSH
7366: CALL_OW 255
7370: PUSH
7371: LD_INT 2
7373: EQUAL
7374: IFFALSE 7459
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7376: LD_ADDR_VAR 0 8
7380: PUSH
7381: LD_INT 14
7383: PUSH
7384: LD_INT 1
7386: PUSH
7387: LD_INT 2
7389: PUSH
7390: LD_INT 28
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: LIST
7398: PUSH
7399: LD_INT 14
7401: PUSH
7402: LD_INT 1
7404: PUSH
7405: LD_INT 2
7407: PUSH
7408: LD_INT 27
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 14
7419: PUSH
7420: LD_INT 1
7422: PUSH
7423: LD_INT 2
7425: PUSH
7426: LD_INT 27
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: LIST
7433: LIST
7434: PUSH
7435: EMPTY
7436: LIST
7437: LIST
7438: LIST
7439: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7440: LD_INT 2
7442: PPUSH
7443: LD_VAR 0 8
7447: PPUSH
7448: CALL 42125 0 2
// wait ( 0 0$50 ) ;
7452: LD_INT 1750
7454: PPUSH
7455: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7459: LD_INT 35
7461: PPUSH
7462: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7466: LD_EXP 69
7470: PUSH
7471: LD_INT 1
7473: ARRAY
7474: PPUSH
7475: LD_INT 3
7477: PUSH
7478: LD_INT 2
7480: PUSH
7481: LD_INT 34
7483: PUSH
7484: LD_INT 32
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 34
7493: PUSH
7494: LD_EXP 100
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: LIST
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: PPUSH
7512: CALL_OW 72
7516: PUSH
7517: LD_INT 4
7519: GREATEREQUAL
7520: IFFALSE 7459
// wait ( 0 0$10 ) ;
7522: LD_INT 350
7524: PPUSH
7525: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7529: LD_ADDR_VAR 0 3
7533: PUSH
7534: LD_EXP 69
7538: PUSH
7539: LD_INT 1
7541: ARRAY
7542: PPUSH
7543: LD_INT 3
7545: PUSH
7546: LD_INT 2
7548: PUSH
7549: LD_INT 34
7551: PUSH
7552: LD_INT 32
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 34
7561: PUSH
7562: LD_EXP 100
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PPUSH
7580: CALL_OW 72
7584: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7585: LD_INT 100
7587: PPUSH
7588: CALL_OW 13
7592: PUSH
7593: LD_INT 50
7595: LESS
7596: IFFALSE 7629
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7598: LD_ADDR_VAR 0 5
7602: PUSH
7603: LD_INT 55
7605: PUSH
7606: LD_INT 7
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 75
7615: PUSH
7616: LD_INT 90
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: ST_TO_ADDR
7627: GO 7658
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7629: LD_ADDR_VAR 0 5
7633: PUSH
7634: LD_INT 128
7636: PUSH
7637: LD_INT 94
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: LD_INT 180
7646: PUSH
7647: LD_INT 135
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: ST_TO_ADDR
// if w mod 4 = 0 then
7658: LD_VAR 0 7
7662: PUSH
7663: LD_INT 4
7665: MOD
7666: PUSH
7667: LD_INT 0
7669: EQUAL
7670: IFFALSE 7701
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7672: LD_ADDR_VAR 0 5
7676: PUSH
7677: LD_INT 91
7679: PUSH
7680: LD_INT 58
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 117
7689: PUSH
7690: LD_INT 107
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: EMPTY
7698: LIST
7699: LIST
7700: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7701: LD_VAR 0 3
7705: PPUSH
7706: LD_VAR 0 5
7710: PUSH
7711: LD_INT 1
7713: ARRAY
7714: PPUSH
7715: LD_VAR 0 5
7719: PUSH
7720: LD_INT 2
7722: ARRAY
7723: PPUSH
7724: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7728: LD_INT 35
7730: PPUSH
7731: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7735: LD_VAR 0 3
7739: PPUSH
7740: LD_INT 60
7742: PUSH
7743: EMPTY
7744: LIST
7745: PPUSH
7746: CALL_OW 72
7750: PUSH
7751: LD_INT 0
7753: EQUAL
7754: IFFALSE 7728
// repeat wait ( 0 0$2 ) ;
7756: LD_INT 70
7758: PPUSH
7759: CALL_OW 67
// for i in tmp do
7763: LD_ADDR_VAR 0 1
7767: PUSH
7768: LD_VAR 0 3
7772: PUSH
7773: FOR_IN
7774: IFFALSE 7863
// if GetChassis ( i ) = ar_hovercraft then
7776: LD_VAR 0 1
7780: PPUSH
7781: CALL_OW 265
7785: PUSH
7786: LD_INT 11
7788: EQUAL
7789: IFFALSE 7827
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7791: LD_VAR 0 1
7795: PPUSH
7796: LD_INT 22
7798: PUSH
7799: LD_INT 1
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PPUSH
7806: CALL_OW 69
7810: PPUSH
7811: LD_VAR 0 1
7815: PPUSH
7816: CALL_OW 74
7820: PPUSH
7821: CALL 81614 0 2
7825: GO 7861
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7827: LD_VAR 0 1
7831: PPUSH
7832: LD_INT 22
7834: PUSH
7835: LD_INT 1
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 69
7846: PPUSH
7847: LD_VAR 0 1
7851: PPUSH
7852: CALL_OW 74
7856: PPUSH
7857: CALL_OW 115
7861: GO 7773
7863: POP
7864: POP
// until not tmp ;
7865: LD_VAR 0 3
7869: NOT
7870: IFFALSE 7756
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7872: LD_INT 22050
7874: PPUSH
7875: LD_INT 28350
7877: PPUSH
7878: CALL_OW 12
7882: PPUSH
7883: CALL_OW 67
// w := w + 1 ;
7887: LD_ADDR_VAR 0 7
7891: PUSH
7892: LD_VAR 0 7
7896: PUSH
7897: LD_INT 1
7899: PLUS
7900: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7901: LD_INT 94
7903: PPUSH
7904: CALL_OW 301
7908: PUSH
7909: LD_EXP 50
7913: PUSH
7914: LD_INT 1
7916: ARRAY
7917: PPUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 3
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PPUSH
7928: CALL_OW 72
7932: NOT
7933: OR
7934: IFFALSE 7055
// end ;
7936: PPOPN 8
7938: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7939: LD_INT 204
7941: IFFALSE 8407
7943: GO 7945
7945: DISABLE
7946: LD_INT 0
7948: PPUSH
7949: PPUSH
7950: PPUSH
7951: PPUSH
// begin enable ;
7952: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7953: LD_INT 35
7955: PPUSH
7956: LD_INT 1190
7958: PPUSH
7959: CALL_OW 12
7963: PPUSH
7964: CALL_OW 67
// tmp := [ ] ;
7968: LD_ADDR_VAR 0 2
7972: PUSH
7973: EMPTY
7974: ST_TO_ADDR
// uc_side := 8 ;
7975: LD_ADDR_OWVAR 20
7979: PUSH
7980: LD_INT 8
7982: ST_TO_ADDR
// uc_nation := 2 ;
7983: LD_ADDR_OWVAR 21
7987: PUSH
7988: LD_INT 2
7990: ST_TO_ADDR
// InitHc ;
7991: CALL_OW 19
// for i = 1 to 3 do
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: DOUBLE
8001: LD_INT 1
8003: DEC
8004: ST_TO_ADDR
8005: LD_INT 3
8007: PUSH
8008: FOR_TO
8009: IFFALSE 8136
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8011: LD_INT 13
8013: PUSH
8014: LD_INT 14
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: LD_INT 1
8023: PPUSH
8024: LD_INT 2
8026: PPUSH
8027: CALL_OW 12
8031: ARRAY
8032: PPUSH
8033: LD_INT 3
8035: PPUSH
8036: LD_INT 5
8038: PPUSH
8039: LD_INT 27
8041: PUSH
8042: LD_INT 28
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: LD_INT 1
8051: PPUSH
8052: LD_INT 2
8054: PPUSH
8055: CALL_OW 12
8059: ARRAY
8060: PPUSH
8061: LD_INT 100
8063: PPUSH
8064: CALL 53596 0 5
// un := CreateVehicle ;
8068: LD_ADDR_VAR 0 3
8072: PUSH
8073: CALL_OW 45
8077: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8078: LD_VAR 0 3
8082: PPUSH
8083: LD_INT 4
8085: PPUSH
8086: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8090: LD_VAR 0 3
8094: PPUSH
8095: LD_INT 15
8097: PPUSH
8098: LD_INT 0
8100: PPUSH
8101: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8105: LD_ADDR_VAR 0 2
8109: PUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: LD_VAR 0 2
8119: PUSH
8120: LD_INT 1
8122: PLUS
8123: PPUSH
8124: LD_VAR 0 3
8128: PPUSH
8129: CALL_OW 1
8133: ST_TO_ADDR
// end ;
8134: GO 8008
8136: POP
8137: POP
// for i = 1 to 4 do
8138: LD_ADDR_VAR 0 1
8142: PUSH
8143: DOUBLE
8144: LD_INT 1
8146: DEC
8147: ST_TO_ADDR
8148: LD_INT 4
8150: PUSH
8151: FOR_TO
8152: IFFALSE 8223
// begin PrepareHuman ( false , 1 , 6 ) ;
8154: LD_INT 0
8156: PPUSH
8157: LD_INT 1
8159: PPUSH
8160: LD_INT 6
8162: PPUSH
8163: CALL_OW 380
// un := CreateHuman ;
8167: LD_ADDR_VAR 0 3
8171: PUSH
8172: CALL_OW 44
8176: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8177: LD_VAR 0 3
8181: PPUSH
8182: LD_INT 15
8184: PPUSH
8185: LD_INT 0
8187: PPUSH
8188: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8192: LD_ADDR_VAR 0 2
8196: PUSH
8197: LD_VAR 0 2
8201: PPUSH
8202: LD_VAR 0 2
8206: PUSH
8207: LD_INT 1
8209: PLUS
8210: PPUSH
8211: LD_VAR 0 3
8215: PPUSH
8216: CALL_OW 1
8220: ST_TO_ADDR
// end ;
8221: GO 8151
8223: POP
8224: POP
// wait ( 0 0$3 ) ;
8225: LD_INT 105
8227: PPUSH
8228: CALL_OW 67
// for i in tmp do
8232: LD_ADDR_VAR 0 1
8236: PUSH
8237: LD_VAR 0 2
8241: PUSH
8242: FOR_IN
8243: IFFALSE 8311
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8245: LD_VAR 0 1
8249: PPUSH
8250: CALL_OW 257
8254: PUSH
8255: LD_INT 1
8257: EQUAL
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 247
8268: PUSH
8269: LD_INT 2
8271: EQUAL
8272: OR
8273: IFFALSE 8309
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8275: LD_VAR 0 1
8279: PPUSH
8280: LD_INT 81
8282: PUSH
8283: LD_INT 8
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL_OW 69
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 74
8304: PPUSH
8305: CALL_OW 115
8309: GO 8242
8311: POP
8312: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8313: LD_VAR 0 2
8317: PPUSH
8318: LD_INT 210
8320: PPUSH
8321: LD_INT 178
8323: PPUSH
8324: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8328: LD_ADDR_VAR 0 4
8332: PUSH
8333: LD_INT 10
8335: PPUSH
8336: LD_INT 22
8338: PUSH
8339: LD_INT 8
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PPUSH
8346: CALL_OW 70
8350: ST_TO_ADDR
// if x then
8351: LD_VAR 0 4
8355: IFFALSE 8383
// for i in x do
8357: LD_ADDR_VAR 0 1
8361: PUSH
8362: LD_VAR 0 4
8366: PUSH
8367: FOR_IN
8368: IFFALSE 8381
// RemoveUnit ( i ) ;
8370: LD_VAR 0 1
8374: PPUSH
8375: CALL_OW 64
8379: GO 8367
8381: POP
8382: POP
// wait ( 0 0$1 ) ;
8383: LD_INT 35
8385: PPUSH
8386: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8390: LD_INT 22
8392: PUSH
8393: LD_INT 8
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PPUSH
8400: CALL_OW 69
8404: NOT
8405: IFFALSE 8313
// end ;
8407: PPOPN 4
8409: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8410: LD_INT 22
8412: PUSH
8413: LD_INT 2
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 34
8422: PUSH
8423: LD_INT 31
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: LD_INT 3
8432: PUSH
8433: LD_INT 24
8435: PUSH
8436: LD_INT 1000
8438: PUSH
8439: EMPTY
8440: LIST
8441: LIST
8442: PUSH
8443: EMPTY
8444: LIST
8445: LIST
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: PPUSH
8452: CALL_OW 69
8456: IFFALSE 8559
8458: GO 8460
8460: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8461: LD_INT 45
8463: PPUSH
8464: CALL_OW 302
8468: PUSH
8469: LD_INT 45
8471: PPUSH
8472: CALL_OW 255
8476: AND
8477: IFFALSE 8520
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8479: LD_INT 22
8481: PUSH
8482: LD_INT 2
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PUSH
8489: LD_INT 34
8491: PUSH
8492: LD_INT 31
8494: PUSH
8495: EMPTY
8496: LIST
8497: LIST
8498: PUSH
8499: EMPTY
8500: LIST
8501: LIST
8502: PPUSH
8503: CALL_OW 69
8507: PPUSH
8508: LD_INT 18
8510: PPUSH
8511: LD_INT 8
8513: PPUSH
8514: CALL_OW 111
8518: GO 8559
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8520: LD_INT 22
8522: PUSH
8523: LD_INT 2
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: LD_INT 34
8532: PUSH
8533: LD_INT 31
8535: PUSH
8536: EMPTY
8537: LIST
8538: LIST
8539: PUSH
8540: EMPTY
8541: LIST
8542: LIST
8543: PPUSH
8544: CALL_OW 69
8548: PPUSH
8549: LD_INT 106
8551: PPUSH
8552: LD_INT 14
8554: PPUSH
8555: CALL_OW 111
// end ; end_of_file
8559: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8560: LD_INT 0
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
8567: PPUSH
// InGameOn ;
8568: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8572: LD_EXP 21
8576: PPUSH
8577: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8581: LD_INT 2
8583: PPUSH
8584: LD_INT 1
8586: PPUSH
8587: LD_INT 1
8589: PPUSH
8590: LD_INT 1
8592: PPUSH
8593: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: LD_INT 22
8604: PUSH
8605: LD_INT 1
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PUSH
8612: LD_INT 25
8614: PUSH
8615: LD_INT 1
8617: PUSH
8618: EMPTY
8619: LIST
8620: LIST
8621: PUSH
8622: EMPTY
8623: LIST
8624: LIST
8625: PPUSH
8626: CALL_OW 69
8630: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8631: LD_ADDR_VAR 0 4
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: LD_INT 34
8648: PUSH
8649: LD_INT 11
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: PUSH
8665: LD_INT 1
8667: ARRAY
8668: ST_TO_ADDR
// for i = 1 to tmp do
8669: LD_ADDR_VAR 0 6
8673: PUSH
8674: DOUBLE
8675: LD_INT 1
8677: DEC
8678: ST_TO_ADDR
8679: LD_VAR 0 2
8683: PUSH
8684: FOR_TO
8685: IFFALSE 8732
// begin if i = 5 then
8687: LD_VAR 0 6
8691: PUSH
8692: LD_INT 5
8694: EQUAL
8695: IFFALSE 8699
// break ;
8697: GO 8732
// sols := Replace ( sols , i , tmp [ i ] ) ;
8699: LD_ADDR_VAR 0 5
8703: PUSH
8704: LD_VAR 0 5
8708: PPUSH
8709: LD_VAR 0 6
8713: PPUSH
8714: LD_VAR 0 2
8718: PUSH
8719: LD_VAR 0 6
8723: ARRAY
8724: PPUSH
8725: CALL_OW 1
8729: ST_TO_ADDR
// end ;
8730: GO 8684
8732: POP
8733: POP
// tmp := ar_force_tmp ;
8734: LD_ADDR_VAR 0 2
8738: PUSH
8739: LD_EXP 40
8743: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8744: LD_VAR 0 2
8748: PUSH
8749: LD_INT 1
8751: ARRAY
8752: PPUSH
8753: LD_INT 108
8755: PPUSH
8756: LD_INT 139
8758: PPUSH
8759: LD_INT 0
8761: PPUSH
8762: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8766: LD_VAR 0 2
8770: PUSH
8771: LD_INT 1
8773: ARRAY
8774: PPUSH
8775: LD_EXP 21
8779: PPUSH
8780: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8784: LD_VAR 0 2
8788: PUSH
8789: LD_INT 2
8791: ARRAY
8792: PPUSH
8793: LD_INT 114
8795: PPUSH
8796: LD_INT 132
8798: PPUSH
8799: LD_INT 0
8801: PPUSH
8802: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8806: LD_VAR 0 2
8810: PUSH
8811: LD_INT 3
8813: ARRAY
8814: PPUSH
8815: LD_INT 115
8817: PPUSH
8818: LD_INT 132
8820: PPUSH
8821: LD_INT 0
8823: PPUSH
8824: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8828: LD_VAR 0 2
8832: PUSH
8833: LD_INT 2
8835: ARRAY
8836: PUSH
8837: LD_VAR 0 2
8841: PUSH
8842: LD_INT 3
8844: ARRAY
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PPUSH
8850: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8854: LD_VAR 0 4
8858: PPUSH
8859: LD_INT 83
8861: PPUSH
8862: LD_INT 123
8864: PPUSH
8865: CALL_OW 111
// Wait ( 0 0$01 ) ;
8869: LD_INT 35
8871: PPUSH
8872: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8876: LD_INT 90
8878: PPUSH
8879: LD_INT 144
8881: PPUSH
8882: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8886: LD_VAR 0 5
8890: PPUSH
8891: LD_INT 88
8893: PPUSH
8894: LD_INT 129
8896: PPUSH
8897: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8901: LD_ADDR_VAR 0 3
8905: PUSH
8906: LD_INT 92
8908: PUSH
8909: LD_INT 131
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: LD_INT 88
8918: PUSH
8919: LD_INT 127
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: LD_INT 91
8928: PUSH
8929: LD_INT 132
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: PUSH
8936: LD_INT 92
8938: PUSH
8939: LD_INT 134
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: PUSH
8946: EMPTY
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: ST_TO_ADDR
// for i = 1 to sols do
8952: LD_ADDR_VAR 0 6
8956: PUSH
8957: DOUBLE
8958: LD_INT 1
8960: DEC
8961: ST_TO_ADDR
8962: LD_VAR 0 5
8966: PUSH
8967: FOR_TO
8968: IFFALSE 9041
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8970: LD_VAR 0 5
8974: PUSH
8975: LD_VAR 0 6
8979: ARRAY
8980: PPUSH
8981: LD_VAR 0 3
8985: PUSH
8986: LD_VAR 0 6
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PPUSH
8996: LD_VAR 0 3
9000: PUSH
9001: LD_VAR 0 6
9005: ARRAY
9006: PUSH
9007: LD_INT 2
9009: ARRAY
9010: PPUSH
9011: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9015: LD_VAR 0 5
9019: PUSH
9020: LD_VAR 0 6
9024: ARRAY
9025: PPUSH
9026: CALL_OW 197
// AddComHold ( sols ) ;
9030: LD_VAR 0 5
9034: PPUSH
9035: CALL_OW 200
// end ;
9039: GO 8967
9041: POP
9042: POP
// repeat wait ( 0 0$1 ) ;
9043: LD_INT 35
9045: PPUSH
9046: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9050: LD_VAR 0 5
9054: PUSH
9055: LD_INT 1
9057: ARRAY
9058: PPUSH
9059: LD_INT 92
9061: PPUSH
9062: LD_INT 131
9064: PPUSH
9065: CALL_OW 297
9069: PUSH
9070: LD_INT 4
9072: LESS
9073: IFFALSE 9043
// CenterOnXY ( 96 , 139 ) ;
9075: LD_INT 96
9077: PPUSH
9078: LD_INT 139
9080: PPUSH
9081: CALL_OW 84
// wait ( 0 0$3 ) ;
9085: LD_INT 105
9087: PPUSH
9088: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9092: LD_INT 111
9094: PPUSH
9095: LD_INT 135
9097: PPUSH
9098: LD_INT 1
9100: PPUSH
9101: LD_INT 25
9103: NEG
9104: PPUSH
9105: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9109: LD_VAR 0 2
9113: PUSH
9114: LD_INT 2
9116: ARRAY
9117: PPUSH
9118: LD_VAR 0 2
9122: PUSH
9123: LD_INT 1
9125: ARRAY
9126: PPUSH
9127: CALL_OW 250
9131: PUSH
9132: LD_INT 3
9134: PLUS
9135: PPUSH
9136: LD_VAR 0 2
9140: PUSH
9141: LD_INT 1
9143: ARRAY
9144: PPUSH
9145: CALL_OW 251
9149: PPUSH
9150: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9154: LD_VAR 0 2
9158: PUSH
9159: LD_INT 3
9161: ARRAY
9162: PPUSH
9163: LD_INT 7
9165: PPUSH
9166: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9170: LD_VAR 0 2
9174: PUSH
9175: LD_INT 2
9177: ARRAY
9178: PPUSH
9179: LD_VAR 0 2
9183: PUSH
9184: LD_INT 1
9186: ARRAY
9187: PPUSH
9188: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9192: LD_INT 35
9194: PPUSH
9195: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9199: LD_VAR 0 2
9203: PUSH
9204: LD_INT 1
9206: ARRAY
9207: PPUSH
9208: LD_VAR 0 2
9212: PUSH
9213: LD_INT 2
9215: ARRAY
9216: PPUSH
9217: CALL_OW 296
9221: PUSH
9222: LD_INT 5
9224: LESS
9225: IFFALSE 9192
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9227: LD_VAR 0 2
9231: PUSH
9232: LD_INT 1
9234: ARRAY
9235: PPUSH
9236: LD_VAR 0 2
9240: PUSH
9241: LD_INT 2
9243: ARRAY
9244: PPUSH
9245: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9249: LD_VAR 0 2
9253: PUSH
9254: LD_INT 1
9256: ARRAY
9257: PPUSH
9258: LD_STRING D1a-Merc1-1
9260: PPUSH
9261: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9265: LD_VAR 0 2
9269: PUSH
9270: LD_INT 2
9272: ARRAY
9273: PPUSH
9274: LD_STRING D1a-FMerc2-1
9276: PPUSH
9277: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9281: LD_VAR 0 2
9285: PUSH
9286: LD_INT 2
9288: ARRAY
9289: PPUSH
9290: LD_VAR 0 2
9294: PUSH
9295: LD_INT 1
9297: ARRAY
9298: PPUSH
9299: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9303: LD_VAR 0 2
9307: PUSH
9308: LD_INT 1
9310: ARRAY
9311: PPUSH
9312: LD_INT 500
9314: PPUSH
9315: CALL_OW 234
// wait ( 0 0$2 ) ;
9319: LD_INT 70
9321: PPUSH
9322: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: LD_INT 2
9337: PPUSH
9338: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9342: LD_INT 10
9344: PPUSH
9345: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9349: LD_VAR 0 2
9353: PUSH
9354: LD_INT 1
9356: ARRAY
9357: PPUSH
9358: LD_STRING D1a-Merc1-2
9360: PPUSH
9361: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9365: LD_INT 7
9367: PPUSH
9368: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9372: LD_VAR 0 2
9376: PUSH
9377: LD_INT 1
9379: ARRAY
9380: PPUSH
9381: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9385: LD_VAR 0 2
9389: PUSH
9390: LD_INT 2
9392: ARRAY
9393: PPUSH
9394: LD_INT 10
9396: PPUSH
9397: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9401: LD_VAR 0 2
9405: PUSH
9406: LD_INT 2
9408: ARRAY
9409: PPUSH
9410: LD_STRING D1a-FMerc2-2
9412: PPUSH
9413: CALL_OW 88
// wait ( 0 0$1 ) ;
9417: LD_INT 35
9419: PPUSH
9420: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9424: LD_INT 7
9426: PPUSH
9427: CALL_OW 85
// wait ( 0 0$2 ) ;
9431: LD_INT 70
9433: PPUSH
9434: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9438: LD_EXP 44
9442: PPUSH
9443: LD_STRING D1a-Saliba-1
9445: PPUSH
9446: CALL_OW 91
// KillUnit ( Saliba ) ;
9450: LD_EXP 44
9454: PPUSH
9455: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: ARRAY
9467: PPUSH
9468: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9472: LD_EXP 21
9476: PPUSH
9477: CALL_OW 85
// wait ( 0 0$1 ) ;
9481: LD_INT 35
9483: PPUSH
9484: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9488: LD_VAR 0 5
9492: PPUSH
9493: LD_INT 88
9495: PPUSH
9496: LD_INT 141
9498: PPUSH
9499: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9503: LD_VAR 0 5
9507: PPUSH
9508: LD_INT 70
9510: PPUSH
9511: CALL_OW 202
// wait ( 0 0$2 ) ;
9515: LD_INT 70
9517: PPUSH
9518: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9522: LD_INT 2
9524: PPUSH
9525: LD_INT 1
9527: PPUSH
9528: LD_INT 2
9530: PPUSH
9531: LD_INT 1
9533: PPUSH
9534: CALL_OW 80
// InGameOff ;
9538: CALL_OW 9
// ComWalk ( sols ) ;
9542: LD_VAR 0 5
9546: PPUSH
9547: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9551: LD_STRING M1
9553: PPUSH
9554: CALL_OW 337
// game_speed := 4 ;
9558: LD_ADDR_OWVAR 65
9562: PUSH
9563: LD_INT 4
9565: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9566: LD_INT 111
9568: PPUSH
9569: LD_INT 135
9571: PPUSH
9572: LD_INT 1
9574: PPUSH
9575: CALL_OW 331
// SaveForQuickRestart ;
9579: CALL_OW 22
// ar_run := true ;
9583: LD_ADDR_EXP 5
9587: PUSH
9588: LD_INT 1
9590: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9591: LD_INT 35
9593: PPUSH
9594: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9598: LD_INT 22
9600: PUSH
9601: LD_INT 1
9603: PUSH
9604: EMPTY
9605: LIST
9606: LIST
9607: PUSH
9608: LD_INT 91
9610: PUSH
9611: LD_INT 7
9613: PUSH
9614: LD_INT 10
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: PPUSH
9626: CALL_OW 69
9630: PUSH
9631: LD_INT 7
9633: PPUSH
9634: CALL_OW 256
9638: PUSH
9639: LD_INT 999
9641: LESS
9642: OR
9643: IFFALSE 9591
// if GetSide ( ar_dep_s ) = 2 then
9645: LD_INT 7
9647: PPUSH
9648: CALL_OW 255
9652: PUSH
9653: LD_INT 2
9655: EQUAL
9656: IFFALSE 9668
// SetSide ( ar_dep_s , 1 ) ;
9658: LD_INT 7
9660: PPUSH
9661: LD_INT 1
9663: PPUSH
9664: CALL_OW 235
// end ;
9668: LD_VAR 0 1
9672: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9673: LD_EXP 5
9677: IFFALSE 10037
9679: GO 9681
9681: DISABLE
9682: LD_INT 0
9684: PPUSH
9685: PPUSH
9686: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9687: LD_ADDR_VAR 0 2
9691: PUSH
9692: LD_EXP 40
9696: PUSH
9697: LD_EXP 36
9701: PPUSH
9702: LD_INT 2
9704: PUSH
9705: LD_INT 21
9707: PUSH
9708: LD_INT 2
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PUSH
9715: LD_INT 21
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: LIST
9729: PPUSH
9730: CALL_OW 72
9734: ADD
9735: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9736: LD_VAR 0 2
9740: PPUSH
9741: LD_INT 5
9743: PPUSH
9744: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9748: LD_INT 5
9750: PPUSH
9751: LD_INT 1
9753: PPUSH
9754: CALL_OW 343
// k := 1 ;
9758: LD_ADDR_VAR 0 3
9762: PUSH
9763: LD_INT 1
9765: ST_TO_ADDR
// for i in tmp do
9766: LD_ADDR_VAR 0 1
9770: PUSH
9771: LD_VAR 0 2
9775: PUSH
9776: FOR_IN
9777: IFFALSE 9862
// begin if IsInUnit ( i ) then
9779: LD_VAR 0 1
9783: PPUSH
9784: CALL_OW 310
9788: IFFALSE 9799
// ComExitBuilding ( i ) ;
9790: LD_VAR 0 1
9794: PPUSH
9795: CALL_OW 122
// if GetClass ( i ) = 3 then
9799: LD_VAR 0 1
9803: PPUSH
9804: CALL_OW 257
9808: PUSH
9809: LD_INT 3
9811: EQUAL
9812: IFFALSE 9848
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_EXP 41
9823: PUSH
9824: LD_VAR 0 3
9828: ARRAY
9829: PPUSH
9830: CALL_OW 180
// k := k + 1 ;
9834: LD_ADDR_VAR 0 3
9838: PUSH
9839: LD_VAR 0 3
9843: PUSH
9844: LD_INT 1
9846: PLUS
9847: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9848: LD_VAR 0 1
9852: PPUSH
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 173
// end ;
9860: GO 9776
9862: POP
9863: POP
// ar_patrol := true ;
9864: LD_ADDR_EXP 7
9868: PUSH
9869: LD_INT 1
9871: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9872: LD_INT 10
9874: PPUSH
9875: CALL_OW 67
// for i in tmp do
9879: LD_ADDR_VAR 0 1
9883: PUSH
9884: LD_VAR 0 2
9888: PUSH
9889: FOR_IN
9890: IFFALSE 9918
// if not HasTask ( i ) then
9892: LD_VAR 0 1
9896: PPUSH
9897: CALL_OW 314
9901: NOT
9902: IFFALSE 9916
// ComMoveToArea ( i , escape_area ) ;
9904: LD_VAR 0 1
9908: PPUSH
9909: LD_INT 10
9911: PPUSH
9912: CALL_OW 113
9916: GO 9889
9918: POP
9919: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9920: LD_ADDR_VAR 0 3
9924: PUSH
9925: LD_VAR 0 2
9929: PPUSH
9930: LD_INT 95
9932: PUSH
9933: LD_INT 10
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: PPUSH
9940: CALL_OW 72
9944: ST_TO_ADDR
// if k then
9945: LD_VAR 0 3
9949: IFFALSE 10018
// for i in k do
9951: LD_ADDR_VAR 0 1
9955: PUSH
9956: LD_VAR 0 3
9960: PUSH
9961: FOR_IN
9962: IFFALSE 10016
// begin if IsInUnit ( i ) then
9964: LD_VAR 0 1
9968: PPUSH
9969: CALL_OW 310
9973: IFFALSE 9989
// RemoveUnit ( IsInUnit ( i ) ) ;
9975: LD_VAR 0 1
9979: PPUSH
9980: CALL_OW 310
9984: PPUSH
9985: CALL_OW 64
// RemoveUnit ( i ) ;
9989: LD_VAR 0 1
9993: PPUSH
9994: CALL_OW 64
// tmp := tmp diff i ;
9998: LD_ADDR_VAR 0 2
10002: PUSH
10003: LD_VAR 0 2
10007: PUSH
10008: LD_VAR 0 1
10012: DIFF
10013: ST_TO_ADDR
// end ;
10014: GO 9961
10016: POP
10017: POP
// until tmp = [ ] ;
10018: LD_VAR 0 2
10022: PUSH
10023: EMPTY
10024: EQUAL
10025: IFFALSE 9872
// ChangeSideFog ( 5 , 5 ) ;
10027: LD_INT 5
10029: PPUSH
10030: LD_INT 5
10032: PPUSH
10033: CALL_OW 343
// end ;
10037: PPOPN 3
10039: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10040: LD_EXP 7
10044: IFFALSE 10334
10046: GO 10048
10048: DISABLE
10049: LD_INT 0
10051: PPUSH
10052: PPUSH
10053: PPUSH
// begin uc_side := 2 ;
10054: LD_ADDR_OWVAR 20
10058: PUSH
10059: LD_INT 2
10061: ST_TO_ADDR
// uc_nation := 2 ;
10062: LD_ADDR_OWVAR 21
10066: PUSH
10067: LD_INT 2
10069: ST_TO_ADDR
// InitHc ;
10070: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10074: LD_INT 1
10076: PPUSH
10077: LD_INT 1
10079: PPUSH
10080: LD_INT 6
10082: PPUSH
10083: CALL_OW 380
// un := CreateHuman ;
10087: LD_ADDR_VAR 0 2
10091: PUSH
10092: CALL_OW 44
10096: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10097: LD_INT 14
10099: PPUSH
10100: LD_INT 1
10102: PPUSH
10103: LD_INT 1
10105: PPUSH
10106: LD_INT 27
10108: PPUSH
10109: LD_INT 98
10111: PPUSH
10112: CALL 53596 0 5
// veh := CreateVehicle ;
10116: LD_ADDR_VAR 0 3
10120: PUSH
10121: CALL_OW 45
10125: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10126: LD_VAR 0 3
10130: PPUSH
10131: LD_INT 4
10133: PPUSH
10134: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10138: LD_VAR 0 3
10142: PPUSH
10143: LD_INT 179
10145: PPUSH
10146: LD_INT 135
10148: PPUSH
10149: LD_INT 0
10151: PPUSH
10152: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10156: LD_VAR 0 2
10160: PPUSH
10161: LD_VAR 0 3
10165: PPUSH
10166: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10170: LD_VAR 0 2
10174: PPUSH
10175: LD_INT 126
10177: PPUSH
10178: LD_INT 133
10180: PPUSH
10181: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10185: LD_INT 10
10187: PPUSH
10188: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10192: LD_INT 1
10194: PPUSH
10195: LD_VAR 0 3
10199: PPUSH
10200: CALL_OW 292
10204: PUSH
10205: LD_VAR 0 3
10209: PPUSH
10210: LD_INT 7
10212: PPUSH
10213: CALL_OW 296
10217: PUSH
10218: LD_INT 9
10220: LESS
10221: OR
10222: IFFALSE 10185
// ComHold ( veh ) ;
10224: LD_VAR 0 3
10228: PPUSH
10229: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10233: LD_VAR 0 2
10237: PPUSH
10238: LD_STRING D2aa-Ar1-1
10240: PPUSH
10241: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10245: LD_VAR 0 2
10249: PPUSH
10250: LD_INT 177
10252: PPUSH
10253: LD_INT 96
10255: PPUSH
10256: CALL_OW 111
// AddComExitVehicle ( un ) ;
10260: LD_VAR 0 2
10264: PPUSH
10265: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10269: LD_INT 35
10271: PPUSH
10272: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10276: LD_VAR 0 2
10280: PPUSH
10281: LD_INT 204
10283: PPUSH
10284: CALL_OW 296
10288: PUSH
10289: LD_INT 15
10291: LESS
10292: IFFALSE 10269
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10294: LD_ADDR_EXP 50
10298: PUSH
10299: LD_EXP 50
10303: PPUSH
10304: LD_INT 3
10306: PUSH
10307: LD_EXP 50
10311: PUSH
10312: LD_INT 3
10314: ARRAY
10315: PUSH
10316: LD_INT 1
10318: PLUS
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PPUSH
10324: LD_VAR 0 2
10328: PPUSH
10329: CALL 53718 0 3
10333: ST_TO_ADDR
// end ;
10334: PPOPN 3
10336: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10337: LD_INT 7
10339: PPUSH
10340: CALL_OW 255
10344: PUSH
10345: LD_INT 1
10347: EQUAL
10348: PUSH
10349: LD_INT 7
10351: PPUSH
10352: CALL_OW 301
10356: OR
10357: IFFALSE 12765
10359: GO 10361
10361: DISABLE
10362: LD_INT 0
10364: PPUSH
10365: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10366: LD_ADDR_VAR 0 1
10370: PUSH
10371: LD_EXP 36
10375: PPUSH
10376: LD_INT 21
10378: PUSH
10379: LD_INT 3
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PPUSH
10386: CALL_OW 72
10390: PUSH
10391: FOR_IN
10392: IFFALSE 10408
// SetSide ( i , 1 ) ;
10394: LD_VAR 0 1
10398: PPUSH
10399: LD_INT 1
10401: PPUSH
10402: CALL_OW 235
10406: GO 10391
10408: POP
10409: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10410: LD_ADDR_VAR 0 2
10414: PUSH
10415: LD_INT 46
10417: PUSH
10418: LD_INT 41
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 50
10427: PUSH
10428: LD_INT 25
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PUSH
10435: LD_INT 57
10437: PUSH
10438: LD_INT 75
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 75
10447: PUSH
10448: LD_INT 89
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: PUSH
10455: LD_INT 51
10457: PUSH
10458: LD_INT 45
10460: PUSH
10461: EMPTY
10462: LIST
10463: LIST
10464: PUSH
10465: LD_INT 95
10467: PUSH
10468: LD_INT 95
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: PUSH
10475: LD_INT 84
10477: PUSH
10478: LD_INT 77
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PUSH
10485: LD_INT 101
10487: PUSH
10488: LD_INT 76
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: PUSH
10495: LD_INT 118
10497: PUSH
10498: LD_INT 81
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: PUSH
10505: LD_INT 139
10507: PUSH
10508: LD_INT 97
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PUSH
10515: LD_INT 129
10517: PUSH
10518: LD_INT 114
10520: PUSH
10521: EMPTY
10522: LIST
10523: LIST
10524: PUSH
10525: LD_INT 154
10527: PUSH
10528: LD_INT 111
10530: PUSH
10531: EMPTY
10532: LIST
10533: LIST
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: ST_TO_ADDR
// base_captured := true ;
10549: LD_ADDR_EXP 6
10553: PUSH
10554: LD_INT 1
10556: ST_TO_ADDR
// DialogueOn ;
10557: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10561: LD_EXP 21
10565: PPUSH
10566: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10570: LD_EXP 21
10574: PPUSH
10575: LD_STRING D2-JMM-1
10577: PPUSH
10578: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10582: LD_EXP 30
10586: PPUSH
10587: LD_STRING D2-Pow-1
10589: PPUSH
10590: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10594: LD_EXP 21
10598: PPUSH
10599: LD_STRING D2-JMM-2
10601: PPUSH
10602: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10606: LD_EXP 30
10610: PPUSH
10611: LD_STRING D2-Pow-2
10613: PPUSH
10614: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10618: LD_EXP 21
10622: PPUSH
10623: LD_STRING D2-JMM-3
10625: PPUSH
10626: CALL_OW 88
// DialogueOff ;
10630: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10634: LD_STRING M2
10636: PPUSH
10637: CALL_OW 337
// Wait ( 0 0$2 ) ;
10641: LD_INT 70
10643: PPUSH
10644: CALL_OW 67
// if IsOk ( Gary ) then
10648: LD_EXP 32
10652: PPUSH
10653: CALL_OW 302
10657: IFFALSE 10671
// Say ( Gary , D2a-Gary-1 ) ;
10659: LD_EXP 32
10663: PPUSH
10664: LD_STRING D2a-Gary-1
10666: PPUSH
10667: CALL_OW 88
// if IsOk ( Bobby ) then
10671: LD_EXP 24
10675: PPUSH
10676: CALL_OW 302
10680: IFFALSE 10694
// Say ( Bobby , D2a-Bobby-1 ) ;
10682: LD_EXP 24
10686: PPUSH
10687: LD_STRING D2a-Bobby-1
10689: PPUSH
10690: CALL_OW 88
// if IsOk ( Cyrus ) then
10694: LD_EXP 25
10698: PPUSH
10699: CALL_OW 302
10703: IFFALSE 10717
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10705: LD_EXP 25
10709: PPUSH
10710: LD_STRING D2a-Cyrus-1
10712: PPUSH
10713: CALL_OW 88
// if IsOk ( Lisa ) then
10717: LD_EXP 22
10721: PPUSH
10722: CALL_OW 302
10726: IFFALSE 10740
// Say ( Lisa , D2a-Lisa-1 ) ;
10728: LD_EXP 22
10732: PPUSH
10733: LD_STRING D2a-Lisa-1
10735: PPUSH
10736: CALL_OW 88
// if IsOk ( Frank ) then
10740: LD_EXP 33
10744: PPUSH
10745: CALL_OW 302
10749: IFFALSE 10763
// Say ( Frank , D2a-Frank-1 ) ;
10751: LD_EXP 33
10755: PPUSH
10756: LD_STRING D2a-Frank-1
10758: PPUSH
10759: CALL_OW 88
// if IsOk ( Cornel ) then
10763: LD_EXP 31
10767: PPUSH
10768: CALL_OW 302
10772: IFFALSE 10786
// Say ( Cornel , D2a-Corn-1 ) ;
10774: LD_EXP 31
10778: PPUSH
10779: LD_STRING D2a-Corn-1
10781: PPUSH
10782: CALL_OW 88
// if IsOk ( Donaldson ) then
10786: LD_EXP 23
10790: PPUSH
10791: CALL_OW 302
10795: IFFALSE 10809
// Say ( Donaldson , D2a-Don-1 ) ;
10797: LD_EXP 23
10801: PPUSH
10802: LD_STRING D2a-Don-1
10804: PPUSH
10805: CALL_OW 88
// if IsOk ( Brown ) then
10809: LD_EXP 27
10813: PPUSH
10814: CALL_OW 302
10818: IFFALSE 10832
// Say ( Brown , D2a-Brown-1 ) ;
10820: LD_EXP 27
10824: PPUSH
10825: LD_STRING D2a-Brown-1
10827: PPUSH
10828: CALL_OW 88
// Wait ( 0 0$30 ) ;
10832: LD_INT 1050
10834: PPUSH
10835: CALL_OW 67
// if IsOk ( Frank ) then
10839: LD_EXP 33
10843: PPUSH
10844: CALL_OW 302
10848: IFFALSE 11114
// begin DialogueOn ;
10850: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10854: LD_EXP 21
10858: PUSH
10859: LD_EXP 33
10863: PUSH
10864: EMPTY
10865: LIST
10866: LIST
10867: PPUSH
10868: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10872: LD_EXP 33
10876: PPUSH
10877: LD_STRING D3F-Frank-1
10879: PPUSH
10880: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10884: LD_EXP 21
10888: PPUSH
10889: LD_STRING D3F-JMM-1
10891: PPUSH
10892: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10896: LD_EXP 33
10900: PPUSH
10901: LD_STRING D3F-Frank-2
10903: PPUSH
10904: CALL_OW 88
// case Query ( QFrank ) of 1 :
10908: LD_STRING QFrank
10910: PPUSH
10911: CALL_OW 97
10915: PUSH
10916: LD_INT 1
10918: DOUBLE
10919: EQUAL
10920: IFTRUE 10924
10922: GO 10947
10924: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10925: LD_EXP 21
10929: PPUSH
10930: LD_STRING D3Fa-JMM-1
10932: PPUSH
10933: CALL_OW 88
// us_scout := 1 ;
10937: LD_ADDR_EXP 8
10941: PUSH
10942: LD_INT 1
10944: ST_TO_ADDR
// end ; 2 :
10945: GO 11110
10947: LD_INT 2
10949: DOUBLE
10950: EQUAL
10951: IFTRUE 10955
10953: GO 11077
10955: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10956: LD_EXP 21
10960: PPUSH
10961: LD_STRING D3Fb-JMM-1
10963: PPUSH
10964: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10968: LD_EXP 33
10972: PPUSH
10973: LD_STRING D3Fb-Frank-1
10975: PPUSH
10976: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10980: LD_STRING QFrank2
10982: PPUSH
10983: CALL_OW 97
10987: PUSH
10988: LD_INT 1
10990: DOUBLE
10991: EQUAL
10992: IFTRUE 10996
10994: GO 11043
10996: POP
// begin us_scout := 2 ;
10997: LD_ADDR_EXP 8
11001: PUSH
11002: LD_INT 2
11004: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11005: LD_EXP 21
11009: PPUSH
11010: LD_STRING D3Fba-JMM-1
11012: PPUSH
11013: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11017: LD_EXP 33
11021: PPUSH
11022: LD_STRING D3Fba-Frank-1
11024: PPUSH
11025: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11029: LD_EXP 21
11033: PPUSH
11034: LD_STRING D3Fba-JMM-2
11036: PPUSH
11037: CALL_OW 88
// end ; 2 :
11041: GO 11075
11043: LD_INT 2
11045: DOUBLE
11046: EQUAL
11047: IFTRUE 11051
11049: GO 11074
11051: POP
// begin us_scout := 0 ;
11052: LD_ADDR_EXP 8
11056: PUSH
11057: LD_INT 0
11059: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11060: LD_EXP 21
11064: PPUSH
11065: LD_STRING D3Fbb-JMM-1
11067: PPUSH
11068: CALL_OW 88
// end ; end ;
11072: GO 11075
11074: POP
// end ; 3 :
11075: GO 11110
11077: LD_INT 3
11079: DOUBLE
11080: EQUAL
11081: IFTRUE 11085
11083: GO 11109
11085: POP
// begin us_scout := - 1 ;
11086: LD_ADDR_EXP 8
11090: PUSH
11091: LD_INT 1
11093: NEG
11094: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11095: LD_EXP 21
11099: PPUSH
11100: LD_STRING D3Fc-JMM-1
11102: PPUSH
11103: CALL_OW 88
// end ; end ;
11107: GO 11110
11109: POP
// DialogueOff ;
11110: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11114: LD_EXP 8
11118: PUSH
11119: LD_INT 1
11121: NEG
11122: PUSH
11123: LD_INT 0
11125: PUSH
11126: EMPTY
11127: LIST
11128: LIST
11129: IN
11130: IFFALSE 11134
// exit ;
11132: GO 12765
// if us_scout in [ 1 , 2 ] then
11134: LD_EXP 8
11138: PUSH
11139: LD_INT 1
11141: PUSH
11142: LD_INT 2
11144: PUSH
11145: EMPTY
11146: LIST
11147: LIST
11148: IN
11149: IFFALSE 11828
// begin if IsInUnit ( Frank ) then
11151: LD_EXP 33
11155: PPUSH
11156: CALL_OW 310
11160: IFFALSE 11171
// ComExit ( Frank ) ;
11162: LD_EXP 33
11166: PPUSH
11167: CALL 86378 0 1
// SetSide ( Frank , 4 ) ;
11171: LD_EXP 33
11175: PPUSH
11176: LD_INT 4
11178: PPUSH
11179: CALL_OW 235
// wait ( 0 0$1 ) ;
11183: LD_INT 35
11185: PPUSH
11186: CALL_OW 67
// if us_scout = 2 then
11190: LD_EXP 8
11194: PUSH
11195: LD_INT 2
11197: EQUAL
11198: IFFALSE 11566
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11200: LD_EXP 33
11204: PPUSH
11205: LD_INT 75
11207: PPUSH
11208: LD_INT 63
11210: PPUSH
11211: CALL_OW 111
// AddComHold ( Frank ) ;
11215: LD_EXP 33
11219: PPUSH
11220: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11224: LD_EXP 33
11228: PPUSH
11229: LD_INT 770
11231: PPUSH
11232: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11236: LD_EXP 33
11240: PPUSH
11241: LD_INT 100
11243: PPUSH
11244: LD_INT 75
11246: PPUSH
11247: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11251: LD_EXP 33
11255: PPUSH
11256: LD_INT 123
11258: PPUSH
11259: LD_INT 103
11261: PPUSH
11262: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11266: LD_EXP 33
11270: PPUSH
11271: LD_INT 138
11273: PPUSH
11274: LD_INT 108
11276: PPUSH
11277: CALL_OW 171
// AddComHold ( Frank ) ;
11281: LD_EXP 33
11285: PPUSH
11286: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11290: LD_INT 35
11292: PPUSH
11293: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11297: LD_EXP 33
11301: PPUSH
11302: LD_INT 138
11304: PPUSH
11305: LD_INT 108
11307: PPUSH
11308: CALL_OW 307
11312: IFFALSE 11290
// AddComMoveXY ( Frank , 125 , 132 ) ;
11314: LD_EXP 33
11318: PPUSH
11319: LD_INT 125
11321: PPUSH
11322: LD_INT 132
11324: PPUSH
11325: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11329: LD_INT 35
11331: PPUSH
11332: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11336: LD_INT 1
11338: PPUSH
11339: LD_EXP 33
11343: PPUSH
11344: CALL_OW 292
11348: PUSH
11349: LD_EXP 33
11353: PPUSH
11354: LD_INT 7
11356: PPUSH
11357: CALL_OW 296
11361: PUSH
11362: LD_INT 7
11364: LESS
11365: OR
11366: IFFALSE 11329
// DialogueOn ;
11368: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11372: LD_EXP 33
11376: PPUSH
11377: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11381: LD_INT 10
11383: PPUSH
11384: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11388: LD_EXP 21
11392: PPUSH
11393: LD_STRING D4Fa-JMM-1
11395: PPUSH
11396: CALL_OW 88
// for i in points do
11400: LD_ADDR_VAR 0 1
11404: PUSH
11405: LD_VAR 0 2
11409: PUSH
11410: FOR_IN
11411: IFFALSE 11469
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11413: LD_VAR 0 1
11417: PUSH
11418: LD_INT 1
11420: ARRAY
11421: PPUSH
11422: LD_VAR 0 1
11426: PUSH
11427: LD_INT 2
11429: ARRAY
11430: PPUSH
11431: LD_INT 1
11433: PPUSH
11434: LD_INT 20
11436: NEG
11437: PPUSH
11438: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11442: LD_VAR 0 1
11446: PUSH
11447: LD_INT 1
11449: ARRAY
11450: PPUSH
11451: LD_VAR 0 1
11455: PUSH
11456: LD_INT 2
11458: ARRAY
11459: PPUSH
11460: LD_INT 1
11462: PPUSH
11463: CALL_OW 331
// end ;
11467: GO 11410
11469: POP
11470: POP
// dwait ( 0 0$0.5 ) ;
11471: LD_INT 18
11473: PPUSH
11474: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11478: LD_INT 42
11480: PPUSH
11481: LD_INT 27
11483: PPUSH
11484: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11488: LD_EXP 33
11492: PPUSH
11493: LD_STRING D4Fa-Frank-1
11495: PPUSH
11496: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11500: LD_INT 18
11502: PPUSH
11503: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11507: LD_EXP 21
11511: PPUSH
11512: LD_STRING D4Fa-JMM-2
11514: PPUSH
11515: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11519: LD_INT 118
11521: PPUSH
11522: LD_INT 80
11524: PPUSH
11525: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11529: LD_EXP 33
11533: PPUSH
11534: LD_STRING D4Fa-Frank-2
11536: PPUSH
11537: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11541: LD_INT 10
11543: PPUSH
11544: CALL_OW 68
// DialogueOff ;
11548: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11552: LD_EXP 33
11556: PPUSH
11557: LD_INT 1
11559: PPUSH
11560: CALL_OW 235
// end else
11564: GO 11828
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11566: LD_INT 2
11568: PPUSH
11569: LD_INT 4
11571: PPUSH
11572: LD_INT 2
11574: PPUSH
11575: LD_INT 1
11577: PPUSH
11578: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11582: LD_EXP 33
11586: PPUSH
11587: LD_INT 75
11589: PPUSH
11590: LD_INT 63
11592: PPUSH
11593: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11597: LD_EXP 33
11601: PPUSH
11602: LD_INT 175
11604: PPUSH
11605: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11609: LD_EXP 33
11613: PPUSH
11614: LD_INT 102
11616: PPUSH
11617: LD_INT 76
11619: PPUSH
11620: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11624: LD_EXP 33
11628: PPUSH
11629: LD_INT 108
11631: PPUSH
11632: LD_INT 70
11634: PPUSH
11635: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11639: LD_INT 35
11641: PPUSH
11642: CALL_OW 67
// until See ( 2 , Frank ) ;
11646: LD_INT 2
11648: PPUSH
11649: LD_EXP 33
11653: PPUSH
11654: CALL_OW 292
11658: IFFALSE 11639
// ComMoveXY ( Frank , 112 , 118 ) ;
11660: LD_EXP 33
11664: PPUSH
11665: LD_INT 112
11667: PPUSH
11668: LD_INT 118
11670: PPUSH
11671: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11675: LD_EXP 33
11679: PPUSH
11680: CALL_OW 256
11684: PUSH
11685: LD_INT 750
11687: GREATEREQUAL
11688: IFFALSE 11702
// SetLives ( Frank , 700 ) ;
11690: LD_EXP 33
11694: PPUSH
11695: LD_INT 700
11697: PPUSH
11698: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11702: LD_INT 35
11704: PPUSH
11705: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11709: LD_INT 1
11711: PPUSH
11712: LD_EXP 33
11716: PPUSH
11717: CALL_OW 292
11721: PUSH
11722: LD_EXP 33
11726: PPUSH
11727: LD_INT 7
11729: PPUSH
11730: CALL_OW 296
11734: PUSH
11735: LD_INT 17
11737: LESS
11738: OR
11739: IFFALSE 11702
// DialogueOn ;
11741: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11745: LD_EXP 33
11749: PPUSH
11750: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11754: LD_EXP 33
11758: PPUSH
11759: LD_STRING D4Fb-Frank-1
11761: PPUSH
11762: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11766: LD_EXP 21
11770: PPUSH
11771: LD_STRING D4Fb-JMM-1
11773: PPUSH
11774: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11778: LD_INT 2
11780: PPUSH
11781: LD_STRING D4Fb-FSci1-1
11783: PPUSH
11784: CALL 16688 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11788: LD_EXP 33
11792: PPUSH
11793: LD_STRING D4Fb-Frank-2
11795: PPUSH
11796: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11800: LD_EXP 21
11804: PPUSH
11805: LD_STRING D4Fb-JMM-2
11807: PPUSH
11808: CALL_OW 88
// DialogueOff ;
11812: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11816: LD_EXP 33
11820: PPUSH
11821: LD_INT 1
11823: PPUSH
11824: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11828: LD_EXP 34
11832: PPUSH
11833: CALL_OW 302
11837: PUSH
11838: LD_EXP 33
11842: NOT
11843: AND
11844: IFFALSE 11992
// begin DialogueOn ;
11846: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11850: LD_EXP 21
11854: PUSH
11855: LD_EXP 34
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11868: LD_EXP 34
11872: PPUSH
11873: LD_STRING D3Y-Yam-1
11875: PPUSH
11876: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11880: LD_EXP 21
11884: PPUSH
11885: LD_STRING D3Y-JMM-1
11887: PPUSH
11888: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_STRING D3Y-Yam-2
11899: PPUSH
11900: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11904: LD_STRING QYamoko
11906: PPUSH
11907: CALL_OW 97
11911: PUSH
11912: LD_INT 1
11914: DOUBLE
11915: EQUAL
11916: IFTRUE 11920
11918: GO 11955
11920: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11921: LD_EXP 21
11925: PPUSH
11926: LD_STRING D3Ya-JMM-1
11928: PPUSH
11929: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11933: LD_EXP 34
11937: PPUSH
11938: LD_STRING D3Ya-Yam-1
11940: PPUSH
11941: CALL_OW 88
// us_scout := 1 ;
11945: LD_ADDR_EXP 8
11949: PUSH
11950: LD_INT 1
11952: ST_TO_ADDR
// end ; 2 :
11953: GO 11988
11955: LD_INT 2
11957: DOUBLE
11958: EQUAL
11959: IFTRUE 11963
11961: GO 11987
11963: POP
// begin us_scout := - 1 ;
11964: LD_ADDR_EXP 8
11968: PUSH
11969: LD_INT 1
11971: NEG
11972: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11973: LD_EXP 21
11977: PPUSH
11978: LD_STRING D3Yb-JMM-1
11980: PPUSH
11981: CALL_OW 88
// end ; end ;
11985: GO 11988
11987: POP
// DialogueOff ;
11988: CALL_OW 7
// end ; if Frank then
11992: LD_EXP 33
11996: IFFALSE 12000
// exit ;
11998: GO 12765
// if us_scout in [ - 1 , 0 ] then
12000: LD_EXP 8
12004: PUSH
12005: LD_INT 1
12007: NEG
12008: PUSH
12009: LD_INT 0
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: IN
12016: IFFALSE 12020
// exit ;
12018: GO 12765
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12020: LD_ADDR_EXP 8
12024: PUSH
12025: LD_INT 2
12027: PUSH
12028: LD_INT 2
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: LD_INT 1
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: LIST
12041: LIST
12042: PUSH
12043: LD_OWVAR 67
12047: ARRAY
12048: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12049: LD_EXP 8
12053: PUSH
12054: LD_INT 1
12056: PUSH
12057: LD_INT 2
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: IN
12064: IFFALSE 12765
// begin if IsInUnit ( Kikuchi ) then
12066: LD_EXP 34
12070: PPUSH
12071: CALL_OW 310
12075: IFFALSE 12086
// ComExitBuilding ( Kikuchi ) ;
12077: LD_EXP 34
12081: PPUSH
12082: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12086: LD_EXP 34
12090: PPUSH
12091: CALL_OW 311
12095: IFFALSE 12106
// ComExitVehicle ( Kikuchi ) ;
12097: LD_EXP 34
12101: PPUSH
12102: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12106: LD_EXP 34
12110: PPUSH
12111: LD_INT 4
12113: PPUSH
12114: CALL_OW 235
// wait ( 0 0$1 ) ;
12118: LD_INT 35
12120: PPUSH
12121: CALL_OW 67
// if us_scout = 2 then
12125: LD_EXP 8
12129: PUSH
12130: LD_INT 2
12132: EQUAL
12133: IFFALSE 12513
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12135: LD_EXP 34
12139: PPUSH
12140: LD_INT 75
12142: PPUSH
12143: LD_INT 63
12145: PPUSH
12146: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12150: LD_EXP 34
12154: PPUSH
12155: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12159: LD_EXP 34
12163: PPUSH
12164: LD_INT 770
12166: PPUSH
12167: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12171: LD_EXP 34
12175: PPUSH
12176: LD_INT 100
12178: PPUSH
12179: LD_INT 75
12181: PPUSH
12182: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12186: LD_EXP 34
12190: PPUSH
12191: LD_INT 123
12193: PPUSH
12194: LD_INT 103
12196: PPUSH
12197: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12201: LD_EXP 34
12205: PPUSH
12206: LD_INT 138
12208: PPUSH
12209: LD_INT 108
12211: PPUSH
12212: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12216: LD_EXP 34
12220: PPUSH
12221: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12225: LD_INT 35
12227: PPUSH
12228: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12232: LD_EXP 34
12236: PPUSH
12237: LD_INT 138
12239: PPUSH
12240: LD_INT 108
12242: PPUSH
12243: CALL_OW 307
12247: IFFALSE 12225
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12249: LD_EXP 34
12253: PPUSH
12254: LD_INT 125
12256: PPUSH
12257: LD_INT 132
12259: PPUSH
12260: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12264: LD_INT 35
12266: PPUSH
12267: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12271: LD_INT 1
12273: PPUSH
12274: LD_EXP 34
12278: PPUSH
12279: CALL_OW 292
12283: PUSH
12284: LD_EXP 34
12288: PPUSH
12289: LD_INT 7
12291: PPUSH
12292: CALL_OW 296
12296: PUSH
12297: LD_INT 7
12299: LESS
12300: OR
12301: IFFALSE 12264
// DialogueOn ;
12303: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12307: LD_EXP 34
12311: PPUSH
12312: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12316: LD_INT 10
12318: PPUSH
12319: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12323: LD_EXP 34
12327: PPUSH
12328: LD_STRING D4Ya-Yam-1
12330: PPUSH
12331: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12335: LD_EXP 21
12339: PPUSH
12340: LD_STRING D4Ya-JMM-1
12342: PPUSH
12343: CALL_OW 88
// for i in points do
12347: LD_ADDR_VAR 0 1
12351: PUSH
12352: LD_VAR 0 2
12356: PUSH
12357: FOR_IN
12358: IFFALSE 12416
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12360: LD_VAR 0 1
12364: PUSH
12365: LD_INT 1
12367: ARRAY
12368: PPUSH
12369: LD_VAR 0 1
12373: PUSH
12374: LD_INT 2
12376: ARRAY
12377: PPUSH
12378: LD_INT 1
12380: PPUSH
12381: LD_INT 20
12383: NEG
12384: PPUSH
12385: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12389: LD_VAR 0 1
12393: PUSH
12394: LD_INT 1
12396: ARRAY
12397: PPUSH
12398: LD_VAR 0 1
12402: PUSH
12403: LD_INT 2
12405: ARRAY
12406: PPUSH
12407: LD_INT 1
12409: PPUSH
12410: CALL_OW 331
// end ;
12414: GO 12357
12416: POP
12417: POP
// dwait ( 0 0$0.5 ) ;
12418: LD_INT 18
12420: PPUSH
12421: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12425: LD_INT 42
12427: PPUSH
12428: LD_INT 27
12430: PPUSH
12431: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12435: LD_EXP 34
12439: PPUSH
12440: LD_STRING D4Ya-Yam-2
12442: PPUSH
12443: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12447: LD_INT 18
12449: PPUSH
12450: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12454: LD_INT 118
12456: PPUSH
12457: LD_INT 80
12459: PPUSH
12460: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12464: LD_EXP 21
12468: PPUSH
12469: LD_STRING D4Ya-JMM-2
12471: PPUSH
12472: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12476: LD_EXP 34
12480: PPUSH
12481: LD_STRING D4Ya-Yam-3
12483: PPUSH
12484: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12488: LD_INT 10
12490: PPUSH
12491: CALL_OW 68
// DialogueOff ;
12495: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12499: LD_EXP 34
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 235
// end else
12511: GO 12765
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12513: LD_INT 2
12515: PPUSH
12516: LD_INT 4
12518: PPUSH
12519: LD_INT 2
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12529: LD_EXP 34
12533: PPUSH
12534: LD_INT 75
12536: PPUSH
12537: LD_INT 63
12539: PPUSH
12540: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12544: LD_EXP 34
12548: PPUSH
12549: LD_INT 175
12551: PPUSH
12552: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12556: LD_EXP 34
12560: PPUSH
12561: LD_INT 102
12563: PPUSH
12564: LD_INT 76
12566: PPUSH
12567: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12571: LD_EXP 34
12575: PPUSH
12576: LD_INT 108
12578: PPUSH
12579: LD_INT 70
12581: PPUSH
12582: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12586: LD_INT 35
12588: PPUSH
12589: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12593: LD_INT 2
12595: PPUSH
12596: LD_EXP 34
12600: PPUSH
12601: CALL_OW 292
12605: IFFALSE 12586
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12607: LD_EXP 34
12611: PPUSH
12612: LD_INT 112
12614: PPUSH
12615: LD_INT 118
12617: PPUSH
12618: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12622: LD_EXP 34
12626: PPUSH
12627: CALL_OW 256
12631: PUSH
12632: LD_INT 750
12634: GREATEREQUAL
12635: IFFALSE 12649
// SetLives ( Kikuchi , 700 ) ;
12637: LD_EXP 34
12641: PPUSH
12642: LD_INT 700
12644: PPUSH
12645: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12649: LD_INT 35
12651: PPUSH
12652: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12656: LD_INT 1
12658: PPUSH
12659: LD_EXP 34
12663: PPUSH
12664: CALL_OW 292
12668: PUSH
12669: LD_EXP 34
12673: PPUSH
12674: LD_INT 7
12676: PPUSH
12677: CALL_OW 296
12681: PUSH
12682: LD_INT 17
12684: LESS
12685: OR
12686: IFFALSE 12649
// DialogueOn ;
12688: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12692: LD_EXP 34
12696: PPUSH
12697: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12701: LD_EXP 34
12705: PPUSH
12706: LD_STRING D4Yb-Yam-1
12708: PPUSH
12709: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12713: LD_EXP 21
12717: PPUSH
12718: LD_STRING D4Yb-JMM-1
12720: PPUSH
12721: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12725: LD_EXP 34
12729: PPUSH
12730: LD_STRING D4Yb-Yam-2
12732: PPUSH
12733: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12737: LD_EXP 21
12741: PPUSH
12742: LD_STRING D4Yb-JMM-2
12744: PPUSH
12745: CALL_OW 88
// DialogueOff ;
12749: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12753: LD_EXP 34
12757: PPUSH
12758: LD_INT 1
12760: PPUSH
12761: CALL_OW 235
// end ; end ; end ;
12765: PPOPN 2
12767: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12768: LD_EXP 6
12772: IFFALSE 13805
12774: GO 12776
12776: DISABLE
12777: LD_INT 0
12779: PPUSH
12780: PPUSH
12781: PPUSH
12782: PPUSH
// begin enable ;
12783: ENABLE
// if not seen [ 1 ] then
12784: LD_EXP 9
12788: PUSH
12789: LD_INT 1
12791: ARRAY
12792: NOT
12793: IFFALSE 12973
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12795: LD_ADDR_VAR 0 2
12799: PUSH
12800: LD_INT 22
12802: PUSH
12803: LD_INT 2
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 2
12812: PUSH
12813: LD_INT 25
12815: PUSH
12816: LD_INT 11
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: LD_INT 33
12825: PUSH
12826: LD_INT 4
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PPUSH
12842: CALL_OW 69
12846: ST_TO_ADDR
// if tmp then
12847: LD_VAR 0 2
12851: IFFALSE 12973
// for i in tmp do
12853: LD_ADDR_VAR 0 1
12857: PUSH
12858: LD_VAR 0 2
12862: PUSH
12863: FOR_IN
12864: IFFALSE 12971
// if See ( 1 , i ) then
12866: LD_INT 1
12868: PPUSH
12869: LD_VAR 0 1
12873: PPUSH
12874: CALL_OW 292
12878: IFFALSE 12969
// begin seen := Replace ( seen , 1 , true ) ;
12880: LD_ADDR_EXP 9
12884: PUSH
12885: LD_EXP 9
12889: PPUSH
12890: LD_INT 1
12892: PPUSH
12893: LD_INT 1
12895: PPUSH
12896: CALL_OW 1
12900: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12901: LD_INT 1
12903: PPUSH
12904: CALL 16510 0 1
12908: IFFALSE 12969
// begin DialogueOn ;
12910: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12914: LD_VAR 0 1
12918: PPUSH
12919: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12923: LD_INT 10
12925: PPUSH
12926: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: LD_INT 1
12937: PPUSH
12938: LD_STRING D5a-Sol2-1
12940: PPUSH
12941: CALL 16688 0 2
12945: ST_TO_ADDR
// if not un then
12946: LD_VAR 0 3
12950: NOT
12951: IFFALSE 12963
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12953: LD_INT 2
12955: PPUSH
12956: LD_STRING D5a-FSol2-1
12958: PPUSH
12959: CALL 16688 0 2
// DialogueOff ;
12963: CALL_OW 7
// break ;
12967: GO 12971
// end ; end ;
12969: GO 12863
12971: POP
12972: POP
// end ; if not seen [ 2 ] then
12973: LD_EXP 9
12977: PUSH
12978: LD_INT 2
12980: ARRAY
12981: NOT
12982: IFFALSE 13207
// begin can_kamikazed := true ;
12984: LD_ADDR_EXP 10
12988: PUSH
12989: LD_INT 1
12991: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12992: LD_ADDR_VAR 0 2
12996: PUSH
12997: LD_INT 22
12999: PUSH
13000: LD_INT 2
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PUSH
13007: LD_INT 25
13009: PUSH
13010: LD_INT 17
13012: PUSH
13013: EMPTY
13014: LIST
13015: LIST
13016: PUSH
13017: EMPTY
13018: LIST
13019: LIST
13020: PPUSH
13021: CALL_OW 69
13025: ST_TO_ADDR
// if tmp then
13026: LD_VAR 0 2
13030: IFFALSE 13207
// for i in tmp do
13032: LD_ADDR_VAR 0 1
13036: PUSH
13037: LD_VAR 0 2
13041: PUSH
13042: FOR_IN
13043: IFFALSE 13205
// if See ( 1 , i ) then
13045: LD_INT 1
13047: PPUSH
13048: LD_VAR 0 1
13052: PPUSH
13053: CALL_OW 292
13057: IFFALSE 13203
// begin seen := Replace ( seen , 2 , true ) ;
13059: LD_ADDR_EXP 9
13063: PUSH
13064: LD_EXP 9
13068: PPUSH
13069: LD_INT 2
13071: PPUSH
13072: LD_INT 1
13074: PPUSH
13075: CALL_OW 1
13079: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13080: LD_INT 1
13082: PPUSH
13083: CALL 16510 0 1
13087: IFFALSE 13203
// begin DialogueOn ;
13089: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13093: LD_VAR 0 1
13097: PPUSH
13098: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13102: LD_INT 10
13104: PPUSH
13105: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13109: LD_ADDR_VAR 0 3
13113: PUSH
13114: LD_INT 1
13116: PPUSH
13117: LD_STRING D5b-Sol1-1
13119: PPUSH
13120: CALL 16688 0 2
13124: ST_TO_ADDR
// if not un then
13125: LD_VAR 0 3
13129: NOT
13130: IFFALSE 13148
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13132: LD_ADDR_VAR 0 3
13136: PUSH
13137: LD_INT 2
13139: PPUSH
13140: LD_STRING D5b-FSol1-1
13142: PPUSH
13143: CALL 16688 0 2
13147: ST_TO_ADDR
// if un then
13148: LD_VAR 0 3
13152: IFFALSE 13197
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13154: LD_ADDR_VAR 0 4
13158: PUSH
13159: LD_INT 1
13161: PPUSH
13162: LD_STRING D5b-Sol2-1
13164: PPUSH
13165: LD_VAR 0 3
13169: PPUSH
13170: CALL 16914 0 3
13174: ST_TO_ADDR
// if not un2 then
13175: LD_VAR 0 4
13179: NOT
13180: IFFALSE 13197
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13182: LD_INT 2
13184: PPUSH
13185: LD_STRING D5b-FSol2-1
13187: PPUSH
13188: LD_VAR 0 3
13192: PPUSH
13193: CALL 16914 0 3
// end ; DialogueOff ;
13197: CALL_OW 7
// break ;
13201: GO 13205
// end ; end ;
13203: GO 13042
13205: POP
13206: POP
// end ; if not seen [ 3 ] then
13207: LD_EXP 9
13211: PUSH
13212: LD_INT 3
13214: ARRAY
13215: NOT
13216: IFFALSE 13390
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13218: LD_ADDR_VAR 0 2
13222: PUSH
13223: LD_INT 22
13225: PUSH
13226: LD_INT 2
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: PUSH
13233: LD_INT 33
13235: PUSH
13236: LD_INT 2
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: PUSH
13243: EMPTY
13244: LIST
13245: LIST
13246: PPUSH
13247: CALL_OW 69
13251: ST_TO_ADDR
// if tmp then
13252: LD_VAR 0 2
13256: IFFALSE 13390
// for i in tmp do
13258: LD_ADDR_VAR 0 1
13262: PUSH
13263: LD_VAR 0 2
13267: PUSH
13268: FOR_IN
13269: IFFALSE 13388
// if See ( 1 , i ) then
13271: LD_INT 1
13273: PPUSH
13274: LD_VAR 0 1
13278: PPUSH
13279: CALL_OW 292
13283: IFFALSE 13386
// begin seen := Replace ( seen , 3 , true ) ;
13285: LD_ADDR_EXP 9
13289: PUSH
13290: LD_EXP 9
13294: PPUSH
13295: LD_INT 3
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: CALL_OW 1
13305: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13306: LD_INT 1
13308: PPUSH
13309: CALL 16510 0 1
13313: IFFALSE 13386
// begin DialogueOn ;
13315: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13328: LD_INT 10
13330: PPUSH
13331: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13335: LD_ADDR_VAR 0 3
13339: PUSH
13340: LD_INT 1
13342: PPUSH
13343: LD_STRING D8-Sol1-1
13345: PPUSH
13346: CALL 16688 0 2
13350: ST_TO_ADDR
// if not un then
13351: LD_VAR 0 3
13355: NOT
13356: IFFALSE 13368
// SayRand ( sex_female , D8-FSol1-1 ) ;
13358: LD_INT 2
13360: PPUSH
13361: LD_STRING D8-FSol1-1
13363: PPUSH
13364: CALL 16688 0 2
// Say ( JMM , D8-JMM-1 ) ;
13368: LD_EXP 21
13372: PPUSH
13373: LD_STRING D8-JMM-1
13375: PPUSH
13376: CALL_OW 88
// DialogueOff ;
13380: CALL_OW 7
// break ;
13384: GO 13388
// end ; end ;
13386: GO 13268
13388: POP
13389: POP
// end ; if not seen [ 4 ] then
13390: LD_EXP 9
13394: PUSH
13395: LD_INT 4
13397: ARRAY
13398: NOT
13399: IFFALSE 13561
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13401: LD_ADDR_VAR 0 2
13405: PUSH
13406: LD_INT 22
13408: PUSH
13409: LD_INT 2
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: LD_INT 33
13418: PUSH
13419: LD_INT 5
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PPUSH
13430: CALL_OW 69
13434: ST_TO_ADDR
// if tmp then
13435: LD_VAR 0 2
13439: IFFALSE 13561
// for i in tmp do
13441: LD_ADDR_VAR 0 1
13445: PUSH
13446: LD_VAR 0 2
13450: PUSH
13451: FOR_IN
13452: IFFALSE 13559
// if See ( 1 , i ) then
13454: LD_INT 1
13456: PPUSH
13457: LD_VAR 0 1
13461: PPUSH
13462: CALL_OW 292
13466: IFFALSE 13557
// begin seen := Replace ( seen , 4 , true ) ;
13468: LD_ADDR_EXP 9
13472: PUSH
13473: LD_EXP 9
13477: PPUSH
13478: LD_INT 4
13480: PPUSH
13481: LD_INT 1
13483: PPUSH
13484: CALL_OW 1
13488: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13489: LD_INT 1
13491: PPUSH
13492: CALL 16510 0 1
13496: IFFALSE 13557
// begin DialogueOn ;
13498: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13502: LD_VAR 0 1
13506: PPUSH
13507: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13511: LD_INT 10
13513: PPUSH
13514: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13518: LD_ADDR_VAR 0 3
13522: PUSH
13523: LD_INT 1
13525: PPUSH
13526: LD_STRING D5a-Sol1-1
13528: PPUSH
13529: CALL 16688 0 2
13533: ST_TO_ADDR
// if not un then
13534: LD_VAR 0 3
13538: NOT
13539: IFFALSE 13551
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13541: LD_INT 2
13543: PPUSH
13544: LD_STRING D5a-FSol1-1
13546: PPUSH
13547: CALL 16688 0 2
// DialogueOff ;
13551: CALL_OW 7
// break ;
13555: GO 13559
// end ; end ;
13557: GO 13451
13559: POP
13560: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13561: LD_EXP 9
13565: PUSH
13566: LD_INT 5
13568: ARRAY
13569: NOT
13570: PUSH
13571: LD_EXP 9
13575: PUSH
13576: LD_INT 3
13578: ARRAY
13579: AND
13580: IFFALSE 13754
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_INT 22
13589: PUSH
13590: LD_INT 2
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 34
13599: PUSH
13600: LD_INT 31
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 69
13615: ST_TO_ADDR
// if tmp then
13616: LD_VAR 0 2
13620: IFFALSE 13754
// for i in tmp do
13622: LD_ADDR_VAR 0 1
13626: PUSH
13627: LD_VAR 0 2
13631: PUSH
13632: FOR_IN
13633: IFFALSE 13752
// if See ( 1 , i ) then
13635: LD_INT 1
13637: PPUSH
13638: LD_VAR 0 1
13642: PPUSH
13643: CALL_OW 292
13647: IFFALSE 13750
// begin seen := Replace ( seen , 5 , true ) ;
13649: LD_ADDR_EXP 9
13653: PUSH
13654: LD_EXP 9
13658: PPUSH
13659: LD_INT 5
13661: PPUSH
13662: LD_INT 1
13664: PPUSH
13665: CALL_OW 1
13669: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13670: LD_INT 1
13672: PPUSH
13673: CALL 16510 0 1
13677: IFFALSE 13750
// begin DialogueOn ;
13679: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13683: LD_VAR 0 1
13687: PPUSH
13688: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13692: LD_INT 10
13694: PPUSH
13695: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13699: LD_ADDR_VAR 0 3
13703: PUSH
13704: LD_INT 1
13706: PPUSH
13707: LD_STRING D8a-Sol2-1
13709: PPUSH
13710: CALL 16688 0 2
13714: ST_TO_ADDR
// if not un then
13715: LD_VAR 0 3
13719: NOT
13720: IFFALSE 13732
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13722: LD_INT 2
13724: PPUSH
13725: LD_STRING D8a-FSol2-1
13727: PPUSH
13728: CALL 16688 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13732: LD_EXP 21
13736: PPUSH
13737: LD_STRING D8a-JMM-1
13739: PPUSH
13740: CALL_OW 88
// DialogueOff ;
13744: CALL_OW 7
// break ;
13748: GO 13752
// end ; end ;
13750: GO 13632
13752: POP
13753: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13754: LD_EXP 9
13758: PUSH
13759: LD_INT 1
13761: ARRAY
13762: PUSH
13763: LD_EXP 9
13767: PUSH
13768: LD_INT 2
13770: ARRAY
13771: AND
13772: PUSH
13773: LD_EXP 9
13777: PUSH
13778: LD_INT 3
13780: ARRAY
13781: AND
13782: PUSH
13783: LD_EXP 9
13787: PUSH
13788: LD_INT 4
13790: ARRAY
13791: AND
13792: PUSH
13793: LD_EXP 9
13797: PUSH
13798: LD_INT 5
13800: ARRAY
13801: AND
13802: IFFALSE 13805
// disable ;
13804: DISABLE
// end ;
13805: PPOPN 4
13807: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13808: LD_EXP 10
13812: PUSH
13813: LD_EXP 11
13817: AND
13818: IFFALSE 14016
13820: GO 13822
13822: DISABLE
13823: LD_INT 0
13825: PPUSH
// begin DialogueOn ;
13826: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13830: LD_EXP 11
13834: PPUSH
13835: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13839: LD_ADDR_VAR 0 1
13843: PUSH
13844: LD_INT 1
13846: PPUSH
13847: LD_STRING D5c-Sol1-1
13849: PPUSH
13850: CALL 16688 0 2
13854: ST_TO_ADDR
// if not un then
13855: LD_VAR 0 1
13859: NOT
13860: IFFALSE 13878
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13862: LD_ADDR_VAR 0 1
13866: PUSH
13867: LD_INT 2
13869: PPUSH
13870: LD_STRING D5c-FSol1-1
13872: PPUSH
13873: CALL 16688 0 2
13877: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13878: LD_EXP 21
13882: PPUSH
13883: LD_STRING D5c-JMM-1
13885: PPUSH
13886: CALL_OW 88
// if IsOk ( Lisa ) then
13890: LD_EXP 22
13894: PPUSH
13895: CALL_OW 302
13899: IFFALSE 13915
// Say ( Lisa , D5d-Lisa-1 ) else
13901: LD_EXP 22
13905: PPUSH
13906: LD_STRING D5d-Lisa-1
13908: PPUSH
13909: CALL_OW 88
13913: GO 14000
// if IsOk ( Cyrus ) then
13915: LD_EXP 25
13919: PPUSH
13920: CALL_OW 302
13924: IFFALSE 13940
// Say ( Cyrus , D5d-Cyrus-1 ) else
13926: LD_EXP 25
13930: PPUSH
13931: LD_STRING D5d-Cyrus-1
13933: PPUSH
13934: CALL_OW 88
13938: GO 14000
// if IsOk ( Gary ) then
13940: LD_EXP 32
13944: PPUSH
13945: CALL_OW 302
13949: IFFALSE 13965
// Say ( Gary , D5d-Gary-1 ) else
13951: LD_EXP 32
13955: PPUSH
13956: LD_STRING D5d-Gary-1
13958: PPUSH
13959: CALL_OW 88
13963: GO 14000
// if GetSex ( un ) = sex_male then
13965: LD_VAR 0 1
13969: PPUSH
13970: CALL_OW 258
13974: PUSH
13975: LD_INT 1
13977: EQUAL
13978: IFFALSE 13994
// Say ( un , D5d-Sol1-1 ) else
13980: LD_VAR 0 1
13984: PPUSH
13985: LD_STRING D5d-Sol1-1
13987: PPUSH
13988: CALL_OW 88
13992: GO 14000
// begin DialogueOff ;
13994: CALL_OW 7
// exit ;
13998: GO 14016
// end ; Say ( JMM , D5d-JMM-1 ) ;
14000: LD_EXP 21
14004: PPUSH
14005: LD_STRING D5d-JMM-1
14007: PPUSH
14008: CALL_OW 88
// DialogueOff ;
14012: CALL_OW 7
// end ;
14016: PPOPN 1
14018: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14019: LD_INT 1
14021: PPUSH
14022: LD_INT 17
14024: PPUSH
14025: CALL_OW 294
14029: PUSH
14030: LD_INT 2
14032: GREATEREQUAL
14033: IFFALSE 14165
14035: GO 14037
14037: DISABLE
14038: LD_INT 0
14040: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14041: LD_INT 10
14043: PPUSH
14044: LD_INT 5
14046: PPUSH
14047: LD_INT 1
14049: PPUSH
14050: LD_INT 10
14052: NEG
14053: PPUSH
14054: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14058: LD_INT 10
14060: PPUSH
14061: LD_INT 5
14063: PPUSH
14064: LD_INT 1
14066: PPUSH
14067: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14071: LD_INT 10
14073: PPUSH
14074: LD_INT 5
14076: PPUSH
14077: CALL_OW 86
// DialogueOn ;
14081: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14085: LD_ADDR_VAR 0 1
14089: PUSH
14090: LD_INT 1
14092: PPUSH
14093: LD_STRING D6-Sci1-1
14095: PPUSH
14096: CALL 16688 0 2
14100: ST_TO_ADDR
// if un then
14101: LD_VAR 0 1
14105: IFFALSE 14143
// begin Say ( JMM , D6-JMM-1 ) ;
14107: LD_EXP 21
14111: PPUSH
14112: LD_STRING D6-JMM-1
14114: PPUSH
14115: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_STRING D6-Sci1-2
14126: PPUSH
14127: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14131: LD_EXP 21
14135: PPUSH
14136: LD_STRING D6-JMM-2
14138: PPUSH
14139: CALL_OW 88
// end ; DialogueOff ;
14143: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14147: LD_STRING M3
14149: PPUSH
14150: CALL_OW 337
// wait ( 0 0$30 ) ;
14154: LD_INT 1050
14156: PPUSH
14157: CALL_OW 67
// AmericanReinforcements ;
14161: CALL 2336 0 0
// end ;
14165: PPOPN 1
14167: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14168: LD_OWVAR 1
14172: PUSH
14173: LD_INT 42000
14175: GREATEREQUAL
14176: PUSH
14177: LD_INT 2
14179: PPUSH
14180: LD_INT 169
14182: PPUSH
14183: LD_INT 90
14185: PPUSH
14186: LD_INT 10
14188: PPUSH
14189: CALL 54614 0 4
14193: PUSH
14194: LD_INT 4
14196: ARRAY
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: PUSH
14202: LD_INT 45
14204: PPUSH
14205: CALL_OW 301
14209: OR
14210: PUSH
14211: LD_INT 45
14213: PPUSH
14214: CALL_OW 255
14218: PUSH
14219: LD_INT 1
14221: EQUAL
14222: OR
14223: AND
14224: PUSH
14225: LD_INT 94
14227: PPUSH
14228: CALL_OW 301
14232: NOT
14233: AND
14234: IFFALSE 15439
14236: GO 14238
14238: DISABLE
14239: LD_INT 0
14241: PPUSH
14242: PPUSH
14243: PPUSH
14244: PPUSH
14245: PPUSH
// begin uc_side := 5 ;
14246: LD_ADDR_OWVAR 20
14250: PUSH
14251: LD_INT 5
14253: ST_TO_ADDR
// uc_nation := 2 ;
14254: LD_ADDR_OWVAR 21
14258: PUSH
14259: LD_INT 2
14261: ST_TO_ADDR
// InitHc ;
14262: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14266: LD_INT 1
14268: PPUSH
14269: LD_INT 3
14271: PPUSH
14272: LD_INT 8
14274: PPUSH
14275: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14279: LD_ADDR_OWVAR 29
14283: PUSH
14284: LD_INT 12
14286: PUSH
14287: LD_INT 12
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: ST_TO_ADDR
// hc_name := Hans Fliege ;
14294: LD_ADDR_OWVAR 26
14298: PUSH
14299: LD_STRING Hans Fliege
14301: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14302: LD_ADDR_OWVAR 33
14306: PUSH
14307: LD_STRING SecondCharsGal
14309: ST_TO_ADDR
// hc_face_number := 7 ;
14310: LD_ADDR_OWVAR 34
14314: PUSH
14315: LD_INT 7
14317: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14318: LD_ADDR_EXP 46
14322: PUSH
14323: CALL_OW 44
14327: ST_TO_ADDR
// InitHc ;
14328: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14332: LD_INT 1
14334: PPUSH
14335: LD_INT 16
14337: PPUSH
14338: LD_INT 2
14340: PPUSH
14341: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14345: LD_ADDR_OWVAR 29
14349: PUSH
14350: LD_INT 12
14352: PUSH
14353: LD_INT 12
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: ST_TO_ADDR
// hc_name :=  ;
14360: LD_ADDR_OWVAR 26
14364: PUSH
14365: LD_STRING 
14367: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14368: LD_ADDR_EXP 47
14372: PUSH
14373: CALL_OW 44
14377: ST_TO_ADDR
// InitHc ;
14378: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14382: LD_INT 35
14384: PPUSH
14385: CALL_OW 67
// until not InBattle ( 1 ) ;
14389: LD_INT 1
14391: PPUSH
14392: CALL_OW 463
14396: NOT
14397: IFFALSE 14382
// wait ( 0 0$5 ) ;
14399: LD_INT 175
14401: PPUSH
14402: CALL_OW 67
// DialogueOn ;
14406: CALL_OW 6
// InGameOn ;
14410: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14414: LD_ADDR_VAR 0 1
14418: PUSH
14419: LD_INT 22
14421: PUSH
14422: LD_INT 1
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 2
14431: PUSH
14432: LD_INT 25
14434: PUSH
14435: LD_INT 1
14437: PUSH
14438: EMPTY
14439: LIST
14440: LIST
14441: PUSH
14442: LD_INT 25
14444: PUSH
14445: LD_INT 2
14447: PUSH
14448: EMPTY
14449: LIST
14450: LIST
14451: PUSH
14452: LD_INT 25
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PUSH
14462: LD_INT 25
14464: PUSH
14465: LD_INT 4
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PUSH
14472: LD_INT 25
14474: PUSH
14475: LD_INT 5
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: PUSH
14482: LD_INT 25
14484: PUSH
14485: LD_INT 8
14487: PUSH
14488: EMPTY
14489: LIST
14490: LIST
14491: PUSH
14492: EMPTY
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: EMPTY
14502: LIST
14503: LIST
14504: PPUSH
14505: CALL_OW 69
14509: PUSH
14510: LD_EXP 21
14514: PUSH
14515: LD_EXP 22
14519: PUSH
14520: LD_EXP 23
14524: PUSH
14525: LD_EXP 24
14529: PUSH
14530: LD_EXP 25
14534: PUSH
14535: LD_EXP 26
14539: PUSH
14540: LD_EXP 27
14544: PUSH
14545: LD_EXP 28
14549: PUSH
14550: LD_EXP 29
14554: PUSH
14555: LD_EXP 31
14559: PUSH
14560: LD_EXP 32
14564: PUSH
14565: LD_EXP 33
14569: PUSH
14570: LD_EXP 34
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: DIFF
14590: PPUSH
14591: LD_INT 26
14593: PUSH
14594: LD_INT 1
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 72
14605: PUSH
14606: LD_INT 1
14608: ARRAY
14609: ST_TO_ADDR
// if Brown then
14610: LD_EXP 27
14614: IFFALSE 14626
// un := Brown ;
14616: LD_ADDR_VAR 0 1
14620: PUSH
14621: LD_EXP 27
14625: ST_TO_ADDR
// if un then
14626: LD_VAR 0 1
14630: IFFALSE 14656
// begin Say ( un , D7-Sol1-1 ) ;
14632: LD_VAR 0 1
14636: PPUSH
14637: LD_STRING D7-Sol1-1
14639: PPUSH
14640: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14644: LD_EXP 21
14648: PPUSH
14649: LD_STRING D7-JMM-1
14651: PPUSH
14652: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14656: LD_EXP 46
14660: PPUSH
14661: LD_STRING D7-Ar1-1
14663: PPUSH
14664: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14668: LD_EXP 21
14672: PPUSH
14673: LD_STRING D7-JMM-2
14675: PPUSH
14676: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14680: LD_EXP 46
14684: PPUSH
14685: LD_STRING D7-Ar1-2
14687: PPUSH
14688: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14692: LD_EXP 21
14696: PPUSH
14697: LD_STRING D7-JMM-3
14699: PPUSH
14700: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14704: LD_EXP 46
14708: PPUSH
14709: LD_STRING D7-Ar1-3
14711: PPUSH
14712: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14716: LD_EXP 21
14720: PPUSH
14721: LD_STRING D7-JMM-4
14723: PPUSH
14724: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14728: LD_EXP 46
14732: PPUSH
14733: LD_STRING D7-Ar1-4
14735: PPUSH
14736: CALL_OW 94
// InGameOff ;
14740: CALL_OW 9
// DialogueOff ;
14744: CALL_OW 7
// case Query ( QCameras ) of 1 :
14748: LD_STRING QCameras
14750: PPUSH
14751: CALL_OW 97
14755: PUSH
14756: LD_INT 1
14758: DOUBLE
14759: EQUAL
14760: IFTRUE 14764
14762: GO 14767
14764: POP
// ; 2 :
14765: GO 14781
14767: LD_INT 2
14769: DOUBLE
14770: EQUAL
14771: IFTRUE 14775
14773: GO 14780
14775: POP
// exit ; end ;
14776: GO 15439
14778: GO 14781
14780: POP
// ChangeMissionObjectives ( MCar ) ;
14781: LD_STRING MCar
14783: PPUSH
14784: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14788: LD_INT 124
14790: PPUSH
14791: LD_INT 90
14793: PPUSH
14794: LD_INT 1
14796: PPUSH
14797: LD_INT 6
14799: NEG
14800: PPUSH
14801: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14805: LD_INT 124
14807: PPUSH
14808: LD_INT 90
14810: PPUSH
14811: LD_INT 1
14813: PPUSH
14814: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14818: LD_INT 12
14820: PPUSH
14821: LD_INT 1
14823: PPUSH
14824: CALL_OW 424
// wait ( 3 ) ;
14828: LD_INT 3
14830: PPUSH
14831: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14835: LD_INT 124
14837: PPUSH
14838: LD_INT 90
14840: PPUSH
14841: CALL_OW 86
// cargo := false ;
14845: LD_ADDR_VAR 0 3
14849: PUSH
14850: LD_INT 0
14852: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14853: LD_INT 35
14855: PPUSH
14856: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14860: LD_ADDR_VAR 0 3
14864: PUSH
14865: LD_INT 12
14867: PPUSH
14868: LD_INT 32
14870: PUSH
14871: LD_INT 3
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: LD_INT 34
14880: PUSH
14881: LD_INT 32
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PUSH
14888: LD_INT 58
14890: PUSH
14891: EMPTY
14892: LIST
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: LIST
14898: PPUSH
14899: CALL_OW 70
14903: ST_TO_ADDR
// until cargo ;
14904: LD_VAR 0 3
14908: IFFALSE 14853
// cargo := cargo [ 1 ] ;
14910: LD_ADDR_VAR 0 3
14914: PUSH
14915: LD_VAR 0 3
14919: PUSH
14920: LD_INT 1
14922: ARRAY
14923: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14924: LD_VAR 0 3
14928: PPUSH
14929: LD_INT 5
14931: PPUSH
14932: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14936: LD_INT 12
14938: PPUSH
14939: LD_INT 0
14941: PPUSH
14942: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14946: LD_EXP 46
14950: PPUSH
14951: LD_INT 11
14953: PPUSH
14954: LD_INT 0
14956: PPUSH
14957: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14961: LD_EXP 47
14965: PPUSH
14966: LD_INT 11
14968: PPUSH
14969: LD_INT 0
14971: PPUSH
14972: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14976: LD_EXP 46
14980: PUSH
14981: LD_EXP 47
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: PPUSH
14990: LD_INT 12
14992: PPUSH
14993: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14997: LD_EXP 46
15001: PPUSH
15002: LD_VAR 0 3
15006: PPUSH
15007: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15011: LD_EXP 46
15015: PUSH
15016: LD_EXP 47
15020: PUSH
15021: EMPTY
15022: LIST
15023: LIST
15024: PPUSH
15025: LD_INT 209
15027: PPUSH
15028: LD_INT 178
15030: PPUSH
15031: CALL_OW 171
// escaped := 0 ;
15035: LD_ADDR_VAR 0 5
15039: PUSH
15040: LD_INT 0
15042: ST_TO_ADDR
// while ( true ) do
15043: LD_INT 1
15045: IFFALSE 15261
// begin wait ( 0 0$1 ) ;
15047: LD_INT 35
15049: PPUSH
15050: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15054: LD_EXP 46
15058: PPUSH
15059: CALL_OW 314
15063: NOT
15064: PUSH
15065: LD_EXP 47
15069: PPUSH
15070: CALL_OW 314
15074: NOT
15075: OR
15076: IFFALSE 15102
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15078: LD_EXP 46
15082: PUSH
15083: LD_EXP 47
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: PPUSH
15092: LD_INT 209
15094: PPUSH
15095: LD_INT 178
15097: PPUSH
15098: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15102: LD_EXP 46
15106: PPUSH
15107: LD_INT 10
15109: PPUSH
15110: CALL_OW 308
15114: IFFALSE 15139
// begin RemoveUnit ( ar_mechanic ) ;
15116: LD_EXP 46
15120: PPUSH
15121: CALL_OW 64
// escaped := escaped + 1 ;
15125: LD_ADDR_VAR 0 5
15129: PUSH
15130: LD_VAR 0 5
15134: PUSH
15135: LD_INT 1
15137: PLUS
15138: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15139: LD_EXP 47
15143: PPUSH
15144: LD_INT 10
15146: PPUSH
15147: CALL_OW 308
15151: IFFALSE 15176
// begin RemoveUnit ( ar_mechanic_friend ) ;
15153: LD_EXP 47
15157: PPUSH
15158: CALL_OW 64
// escaped := escaped + 1 ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 5
15171: PUSH
15172: LD_INT 1
15174: PLUS
15175: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15176: LD_VAR 0 3
15180: PPUSH
15181: LD_INT 10
15183: PPUSH
15184: CALL_OW 308
15188: IFFALSE 15199
// RemoveUnit ( cargo ) ;
15190: LD_VAR 0 3
15194: PPUSH
15195: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15199: LD_EXP 46
15203: PPUSH
15204: CALL_OW 305
15208: NOT
15209: PUSH
15210: LD_VAR 0 5
15214: PUSH
15215: LD_INT 2
15217: GREATEREQUAL
15218: AND
15219: IFFALSE 15223
// break ;
15221: GO 15261
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15223: LD_EXP 46
15227: PPUSH
15228: CALL_OW 305
15232: NOT
15233: PUSH
15234: LD_EXP 47
15238: PPUSH
15239: CALL_OW 305
15243: NOT
15244: AND
15245: PUSH
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: LESS
15254: AND
15255: IFFALSE 15259
// exit ;
15257: GO 15439
// end ;
15259: GO 15043
// wait ( 0 0$2 ) ;
15261: LD_INT 70
15263: PPUSH
15264: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15268: LD_EXP 46
15272: PPUSH
15273: LD_STRING D7a-Ar1-1
15275: PPUSH
15276: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15280: LD_ADDR_VAR 0 4
15284: PUSH
15285: LD_INT 129
15287: PUSH
15288: LD_INT 10
15290: PUSH
15291: EMPTY
15292: LIST
15293: LIST
15294: PUSH
15295: LD_INT 103
15297: PUSH
15298: LD_INT 6
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: PUSH
15305: LD_INT 148
15307: PUSH
15308: LD_INT 47
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: PUSH
15315: LD_INT 155
15317: PUSH
15318: LD_INT 16
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: PUSH
15325: EMPTY
15326: LIST
15327: LIST
15328: LIST
15329: LIST
15330: ST_TO_ADDR
// if Difficulty = 1 then
15331: LD_OWVAR 67
15335: PUSH
15336: LD_INT 1
15338: EQUAL
15339: IFFALSE 15376
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15341: LD_ADDR_VAR 0 4
15345: PUSH
15346: LD_VAR 0 4
15350: PUSH
15351: LD_INT 78
15353: PUSH
15354: LD_INT 7
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: PUSH
15361: LD_INT 104
15363: PUSH
15364: LD_INT 43
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: ADD
15375: ST_TO_ADDR
// for i in tmp do
15376: LD_ADDR_VAR 0 2
15380: PUSH
15381: LD_VAR 0 4
15385: PUSH
15386: FOR_IN
15387: IFFALSE 15420
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15389: LD_VAR 0 2
15393: PUSH
15394: LD_INT 1
15396: ARRAY
15397: PPUSH
15398: LD_VAR 0 2
15402: PUSH
15403: LD_INT 2
15405: ARRAY
15406: PPUSH
15407: LD_INT 1
15409: PPUSH
15410: LD_INT 9
15412: NEG
15413: PPUSH
15414: CALL_OW 330
15418: GO 15386
15420: POP
15421: POP
// SetAchievement ( ACH_FRIEND ) ;
15422: LD_STRING ACH_FRIEND
15424: PPUSH
15425: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15429: LD_INT 129
15431: PPUSH
15432: LD_INT 10
15434: PPUSH
15435: CALL_OW 84
// end ;
15439: PPOPN 5
15441: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15442: LD_EXP 15
15446: PUSH
15447: LD_INT 21000
15449: MINUS
15450: PUSH
15451: LD_OWVAR 1
15455: LESSEQUAL
15456: IFFALSE 15496
15458: GO 15460
15460: DISABLE
// begin powell_warn := true ;
15461: LD_ADDR_EXP 16
15465: PUSH
15466: LD_INT 1
15468: ST_TO_ADDR
// DialogueOn ;
15469: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15473: LD_EXP 30
15477: PPUSH
15478: LD_STRING D9-Pow-1
15480: PPUSH
15481: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15485: LD_INT 10
15487: PPUSH
15488: CALL_OW 68
// DialogueOff ;
15492: CALL_OW 7
// end ;
15496: END
// every 0 0$1 trigger game_time <= tick do
15497: LD_EXP 15
15501: PUSH
15502: LD_OWVAR 1
15506: LESSEQUAL
15507: IFFALSE 15546
15509: GO 15511
15511: DISABLE
// begin DialogueOn ;
15512: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15516: LD_EXP 30
15520: PPUSH
15521: LD_STRING D9a-Pow-1
15523: PPUSH
15524: CALL_OW 94
// dwait ( 0 0$2 ) ;
15528: LD_INT 70
15530: PPUSH
15531: CALL_OW 68
// DialogueOff ;
15535: CALL_OW 7
// YouLost ( Command ) ;
15539: LD_STRING Command
15541: PPUSH
15542: CALL_OW 104
// end ;
15546: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15547: LD_INT 22
15549: PUSH
15550: LD_INT 2
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: LD_INT 30
15559: PUSH
15560: LD_INT 1
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: PPUSH
15571: CALL_OW 69
15575: PUSH
15576: LD_INT 0
15578: EQUAL
15579: PUSH
15580: LD_EXP 21
15584: PPUSH
15585: CALL_OW 302
15589: AND
15590: IFFALSE 16507
15592: GO 15594
15594: DISABLE
15595: LD_INT 0
15597: PPUSH
15598: PPUSH
15599: PPUSH
15600: PPUSH
// begin m1 := false ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 0
15608: ST_TO_ADDR
// m2 := false ;
15609: LD_ADDR_VAR 0 3
15613: PUSH
15614: LD_INT 0
15616: ST_TO_ADDR
// m3 := false ;
15617: LD_ADDR_VAR 0 4
15621: PUSH
15622: LD_INT 0
15624: ST_TO_ADDR
// if not am_veh_consturcted then
15625: LD_EXP 20
15629: NOT
15630: IFFALSE 15639
// SetAchievement ( ACH_ARABTECH ) ;
15632: LD_STRING ACH_ARABTECH
15634: PPUSH
15635: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15639: LD_OWVAR 1
15643: PUSH
15644: LD_INT 252000
15646: PUSH
15647: LD_INT 210000
15649: PUSH
15650: LD_INT 199500
15652: PUSH
15653: LD_INT 193200
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: LIST
15660: LIST
15661: PUSH
15662: LD_OWVAR 67
15666: ARRAY
15667: LESS
15668: IFFALSE 15690
// begin m3 := true ;
15670: LD_ADDR_VAR 0 4
15674: PUSH
15675: LD_INT 1
15677: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15678: LD_STRING Time1
15680: PPUSH
15681: LD_INT 1
15683: PPUSH
15684: CALL_OW 101
// end else
15688: GO 15721
// if not powell_warn then
15690: LD_EXP 16
15694: NOT
15695: IFFALSE 15710
// AddMedal ( Time1 , - 1 ) else
15697: LD_STRING Time1
15699: PPUSH
15700: LD_INT 1
15702: NEG
15703: PPUSH
15704: CALL_OW 101
15708: GO 15721
// AddMedal ( Time1 , - 2 ) ;
15710: LD_STRING Time1
15712: PPUSH
15713: LD_INT 2
15715: NEG
15716: PPUSH
15717: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15721: LD_EXP 17
15725: PUSH
15726: LD_INT 5
15728: PUSH
15729: LD_INT 4
15731: PUSH
15732: LD_INT 3
15734: PUSH
15735: LD_INT 3
15737: PUSH
15738: EMPTY
15739: LIST
15740: LIST
15741: LIST
15742: LIST
15743: PUSH
15744: LD_OWVAR 67
15748: ARRAY
15749: GREATEREQUAL
15750: IFFALSE 15765
// AddMedal ( Destroy , - 2 ) else
15752: LD_STRING Destroy
15754: PPUSH
15755: LD_INT 2
15757: NEG
15758: PPUSH
15759: CALL_OW 101
15763: GO 15898
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15765: LD_INT 22
15767: PUSH
15768: LD_INT 2
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: PUSH
15775: LD_INT 21
15777: PUSH
15778: LD_INT 3
15780: PUSH
15781: EMPTY
15782: LIST
15783: LIST
15784: PUSH
15785: LD_INT 50
15787: PUSH
15788: EMPTY
15789: LIST
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: LIST
15795: PPUSH
15796: CALL_OW 69
15800: PUSH
15801: LD_INT 25
15803: GREATEREQUAL
15804: IFFALSE 15819
// AddMedal ( Destroy , - 1 ) else
15806: LD_STRING Destroy
15808: PPUSH
15809: LD_INT 1
15811: NEG
15812: PPUSH
15813: CALL_OW 101
15817: GO 15898
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15819: LD_INT 22
15821: PUSH
15822: LD_INT 2
15824: PUSH
15825: EMPTY
15826: LIST
15827: LIST
15828: PUSH
15829: LD_INT 21
15831: PUSH
15832: LD_INT 3
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: PUSH
15839: LD_INT 50
15841: PUSH
15842: EMPTY
15843: LIST
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: LIST
15849: PPUSH
15850: CALL_OW 69
15854: PUSH
15855: LD_INT 15
15857: GREATEREQUAL
15858: IFFALSE 15880
// begin m1 := true ;
15860: LD_ADDR_VAR 0 2
15864: PUSH
15865: LD_INT 1
15867: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15868: LD_STRING Destroy
15870: PPUSH
15871: LD_INT 1
15873: PPUSH
15874: CALL_OW 101
// end else
15878: GO 15898
// begin m1 := true ;
15880: LD_ADDR_VAR 0 2
15884: PUSH
15885: LD_INT 1
15887: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15888: LD_STRING Destroy
15890: PPUSH
15891: LD_INT 2
15893: PPUSH
15894: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15898: LD_EXP 13
15902: PPUSH
15903: LD_STRING 11_artifact_captured
15905: PPUSH
15906: CALL_OW 39
// if artifact_get then
15910: LD_EXP 13
15914: IFFALSE 15936
// begin m2 := true ;
15916: LD_ADDR_VAR 0 3
15920: PUSH
15921: LD_INT 1
15923: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15924: LD_STRING Artefact
15926: PPUSH
15927: LD_INT 1
15929: PPUSH
15930: CALL_OW 101
// end else
15934: GO 15947
// AddMedal ( Artefact , - 1 ) ;
15936: LD_STRING Artefact
15938: PPUSH
15939: LD_INT 1
15941: NEG
15942: PPUSH
15943: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15947: LD_VAR 0 2
15951: PUSH
15952: LD_VAR 0 3
15956: AND
15957: PUSH
15958: LD_VAR 0 4
15962: AND
15963: PUSH
15964: LD_OWVAR 67
15968: PUSH
15969: LD_INT 3
15971: GREATEREQUAL
15972: AND
15973: IFFALSE 15985
// SetAchievementEX ( ACH_AMER , 11 ) ;
15975: LD_STRING ACH_AMER
15977: PPUSH
15978: LD_INT 11
15980: PPUSH
15981: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15985: LD_VAR 0 2
15989: PUSH
15990: LD_VAR 0 3
15994: AND
15995: PUSH
15996: LD_VAR 0 4
16000: AND
16001: PUSH
16002: LD_EXP 17
16006: PUSH
16007: LD_INT 0
16009: EQUAL
16010: AND
16011: IFFALSE 16027
// begin wait ( 3 ) ;
16013: LD_INT 3
16015: PPUSH
16016: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16020: LD_STRING ACH_GENERAL
16022: PPUSH
16023: CALL_OW 543
// end ; if tick <= 100 100$00 then
16027: LD_OWVAR 1
16031: PUSH
16032: LD_INT 210000
16034: LESSEQUAL
16035: IFFALSE 16051
// begin wait ( 3 ) ;
16037: LD_INT 3
16039: PPUSH
16040: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16044: LD_STRING ACH_ASPEED_11
16046: PPUSH
16047: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16051: LD_STRING MAIN
16053: PPUSH
16054: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16058: LD_ADDR_EXP 19
16062: PUSH
16063: LD_EXP 19
16067: PPUSH
16068: LD_INT 51
16070: PUSH
16071: EMPTY
16072: LIST
16073: PPUSH
16074: CALL_OW 72
16078: ST_TO_ADDR
// tmp := JMM ^ selected ;
16079: LD_ADDR_VAR 0 1
16083: PUSH
16084: LD_EXP 21
16088: PUSH
16089: LD_EXP 19
16093: ADD
16094: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16095: LD_VAR 0 1
16099: PPUSH
16100: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16104: LD_VAR 0 1
16108: PUSH
16109: LD_EXP 21
16113: PUSH
16114: LD_EXP 22
16118: PUSH
16119: LD_EXP 23
16123: PUSH
16124: LD_EXP 24
16128: PUSH
16129: LD_EXP 25
16133: PUSH
16134: LD_EXP 26
16138: PUSH
16139: LD_EXP 27
16143: PUSH
16144: LD_EXP 28
16148: PUSH
16149: LD_EXP 29
16153: PUSH
16154: LD_EXP 31
16158: PUSH
16159: LD_EXP 32
16163: PUSH
16164: LD_EXP 33
16168: PUSH
16169: LD_EXP 34
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: LIST
16188: DIFF
16189: PPUSH
16190: LD_STRING 11c_others
16192: PPUSH
16193: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16197: LD_EXP 21
16201: PPUSH
16202: LD_EXP 3
16206: PUSH
16207: LD_STRING JMM
16209: STR
16210: PPUSH
16211: CALL_OW 38
// if Lisa then
16215: LD_EXP 22
16219: IFFALSE 16239
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16221: LD_EXP 22
16225: PPUSH
16226: LD_EXP 3
16230: PUSH
16231: LD_STRING Lisa
16233: STR
16234: PPUSH
16235: CALL_OW 38
// if Donaldson then
16239: LD_EXP 23
16243: IFFALSE 16263
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16245: LD_EXP 23
16249: PPUSH
16250: LD_EXP 3
16254: PUSH
16255: LD_STRING Donaldson
16257: STR
16258: PPUSH
16259: CALL_OW 38
// if Bobby then
16263: LD_EXP 24
16267: IFFALSE 16287
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16269: LD_EXP 24
16273: PPUSH
16274: LD_EXP 3
16278: PUSH
16279: LD_STRING Bobby
16281: STR
16282: PPUSH
16283: CALL_OW 38
// if Cyrus then
16287: LD_EXP 25
16291: IFFALSE 16311
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16293: LD_EXP 25
16297: PPUSH
16298: LD_EXP 3
16302: PUSH
16303: LD_STRING Cyrus
16305: STR
16306: PPUSH
16307: CALL_OW 38
// if Denis then
16311: LD_EXP 26
16315: IFFALSE 16335
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16317: LD_EXP 26
16321: PPUSH
16322: LD_EXP 3
16326: PUSH
16327: LD_STRING Denis
16329: STR
16330: PPUSH
16331: CALL_OW 38
// if Brown then
16335: LD_EXP 27
16339: IFFALSE 16359
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16341: LD_EXP 27
16345: PPUSH
16346: LD_EXP 3
16350: PUSH
16351: LD_STRING Brown
16353: STR
16354: PPUSH
16355: CALL_OW 38
// if Gladstone then
16359: LD_EXP 28
16363: IFFALSE 16383
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16365: LD_EXP 28
16369: PPUSH
16370: LD_EXP 3
16374: PUSH
16375: LD_STRING Gladstone
16377: STR
16378: PPUSH
16379: CALL_OW 38
// if Houten then
16383: LD_EXP 29
16387: IFFALSE 16407
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16389: LD_EXP 29
16393: PPUSH
16394: LD_EXP 3
16398: PUSH
16399: LD_STRING Houten
16401: STR
16402: PPUSH
16403: CALL_OW 38
// if Cornel then
16407: LD_EXP 31
16411: IFFALSE 16431
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16413: LD_EXP 31
16417: PPUSH
16418: LD_EXP 3
16422: PUSH
16423: LD_STRING Cornell
16425: STR
16426: PPUSH
16427: CALL_OW 38
// if Gary then
16431: LD_EXP 32
16435: IFFALSE 16455
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16437: LD_EXP 32
16441: PPUSH
16442: LD_EXP 3
16446: PUSH
16447: LD_STRING Gary
16449: STR
16450: PPUSH
16451: CALL_OW 38
// if Frank then
16455: LD_EXP 33
16459: IFFALSE 16479
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16461: LD_EXP 33
16465: PPUSH
16466: LD_EXP 3
16470: PUSH
16471: LD_STRING Frank
16473: STR
16474: PPUSH
16475: CALL_OW 38
// if Kikuchi then
16479: LD_EXP 34
16483: IFFALSE 16503
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16485: LD_EXP 34
16489: PPUSH
16490: LD_EXP 3
16494: PUSH
16495: LD_STRING Kikuchi
16497: STR
16498: PPUSH
16499: CALL_OW 38
// YouWin ;
16503: CALL_OW 103
// end ;
16507: PPOPN 4
16509: END
// export function CanSayRand ( side ) ; begin
16510: LD_INT 0
16512: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16513: LD_ADDR_VAR 0 2
16517: PUSH
16518: LD_INT 52
16520: PUSH
16521: EMPTY
16522: LIST
16523: PUSH
16524: LD_INT 22
16526: PUSH
16527: LD_VAR 0 1
16531: PUSH
16532: EMPTY
16533: LIST
16534: LIST
16535: PUSH
16536: LD_INT 2
16538: PUSH
16539: LD_INT 25
16541: PUSH
16542: LD_INT 1
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: LD_INT 25
16551: PUSH
16552: LD_INT 2
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PUSH
16559: LD_INT 25
16561: PUSH
16562: LD_INT 3
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PUSH
16569: LD_INT 25
16571: PUSH
16572: LD_INT 4
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: LIST
16583: LIST
16584: LIST
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: LIST
16590: PPUSH
16591: CALL_OW 69
16595: PUSH
16596: LD_EXP 21
16600: PUSH
16601: LD_EXP 33
16605: PUSH
16606: LD_EXP 22
16610: PUSH
16611: LD_EXP 23
16615: PUSH
16616: LD_EXP 24
16620: PUSH
16621: LD_EXP 25
16625: PUSH
16626: LD_EXP 26
16630: PUSH
16631: LD_EXP 27
16635: PUSH
16636: LD_EXP 28
16640: PUSH
16641: LD_EXP 29
16645: PUSH
16646: LD_EXP 30
16650: PUSH
16651: LD_EXP 31
16655: PUSH
16656: LD_EXP 32
16660: PUSH
16661: LD_EXP 34
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: LIST
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: LIST
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: LIST
16680: LIST
16681: DIFF
16682: ST_TO_ADDR
// end ;
16683: LD_VAR 0 2
16687: RET
// export function SayRand ( sex , dial ) ; begin
16688: LD_INT 0
16690: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16691: LD_ADDR_VAR 0 3
16695: PUSH
16696: LD_INT 52
16698: PUSH
16699: EMPTY
16700: LIST
16701: PUSH
16702: LD_INT 22
16704: PUSH
16705: LD_INT 1
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: PUSH
16712: LD_INT 26
16714: PUSH
16715: LD_VAR 0 1
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PUSH
16724: LD_INT 2
16726: PUSH
16727: LD_INT 25
16729: PUSH
16730: LD_INT 1
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: PUSH
16737: LD_INT 25
16739: PUSH
16740: LD_INT 2
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: PUSH
16747: LD_INT 25
16749: PUSH
16750: LD_INT 3
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: PUSH
16757: LD_INT 25
16759: PUSH
16760: LD_INT 4
16762: PUSH
16763: EMPTY
16764: LIST
16765: LIST
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: LIST
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: LIST
16778: LIST
16779: PPUSH
16780: CALL_OW 69
16784: PUSH
16785: LD_EXP 21
16789: PUSH
16790: LD_EXP 33
16794: PUSH
16795: LD_EXP 22
16799: PUSH
16800: LD_EXP 23
16804: PUSH
16805: LD_EXP 24
16809: PUSH
16810: LD_EXP 25
16814: PUSH
16815: LD_EXP 26
16819: PUSH
16820: LD_EXP 27
16824: PUSH
16825: LD_EXP 28
16829: PUSH
16830: LD_EXP 29
16834: PUSH
16835: LD_EXP 30
16839: PUSH
16840: LD_EXP 31
16844: PUSH
16845: LD_EXP 32
16849: PUSH
16850: LD_EXP 34
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: LIST
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: LIST
16870: DIFF
16871: ST_TO_ADDR
// if not result then
16872: LD_VAR 0 3
16876: NOT
16877: IFFALSE 16881
// exit ;
16879: GO 16909
// result := result [ 1 ] ;
16881: LD_ADDR_VAR 0 3
16885: PUSH
16886: LD_VAR 0 3
16890: PUSH
16891: LD_INT 1
16893: ARRAY
16894: ST_TO_ADDR
// Say ( result , dial ) ;
16895: LD_VAR 0 3
16899: PPUSH
16900: LD_VAR 0 2
16904: PPUSH
16905: CALL_OW 88
// end ;
16909: LD_VAR 0 3
16913: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16914: LD_INT 0
16916: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16917: LD_ADDR_VAR 0 4
16921: PUSH
16922: LD_INT 22
16924: PUSH
16925: LD_INT 1
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PUSH
16932: LD_INT 26
16934: PUSH
16935: LD_VAR 0 1
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: PUSH
16944: LD_INT 2
16946: PUSH
16947: LD_INT 25
16949: PUSH
16950: LD_INT 1
16952: PUSH
16953: EMPTY
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 25
16959: PUSH
16960: LD_INT 2
16962: PUSH
16963: EMPTY
16964: LIST
16965: LIST
16966: PUSH
16967: LD_INT 25
16969: PUSH
16970: LD_INT 3
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 25
16979: PUSH
16980: LD_INT 4
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: LIST
16998: PPUSH
16999: CALL_OW 69
17003: PUSH
17004: LD_EXP 21
17008: PUSH
17009: LD_EXP 33
17013: PUSH
17014: LD_EXP 22
17018: PUSH
17019: LD_EXP 23
17023: PUSH
17024: LD_EXP 24
17028: PUSH
17029: LD_EXP 25
17033: PUSH
17034: LD_EXP 26
17038: PUSH
17039: LD_EXP 27
17043: PUSH
17044: LD_EXP 28
17048: PUSH
17049: LD_EXP 29
17053: PUSH
17054: LD_EXP 30
17058: PUSH
17059: LD_EXP 31
17063: PUSH
17064: LD_EXP 32
17068: PUSH
17069: LD_EXP 34
17073: PUSH
17074: EMPTY
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: PUSH
17090: LD_VAR 0 3
17094: ADD
17095: DIFF
17096: ST_TO_ADDR
// if not result then
17097: LD_VAR 0 4
17101: NOT
17102: IFFALSE 17106
// exit ;
17104: GO 17134
// result := result [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_VAR 0 4
17115: PUSH
17116: LD_INT 1
17118: ARRAY
17119: ST_TO_ADDR
// Say ( result , dial ) ;
17120: LD_VAR 0 4
17124: PPUSH
17125: LD_VAR 0 2
17129: PPUSH
17130: CALL_OW 88
// end ; end_of_file
17134: LD_VAR 0 4
17138: RET
// export function CustomEvent ( event ) ; begin
17139: LD_INT 0
17141: PPUSH
// end ;
17142: LD_VAR 0 2
17146: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17147: LD_VAR 0 1
17151: PPUSH
17152: CALL_OW 255
17156: PUSH
17157: LD_INT 1
17159: EQUAL
17160: IFFALSE 17170
// artifact_get := true ;
17162: LD_ADDR_EXP 13
17166: PUSH
17167: LD_INT 1
17169: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL_OW 255
17179: PUSH
17180: LD_INT 2
17182: EQUAL
17183: IFFALSE 17201
// begin artifact_get := false ;
17185: LD_ADDR_EXP 13
17189: PUSH
17190: LD_INT 0
17192: ST_TO_ADDR
// artifact_stolen := true ;
17193: LD_ADDR_EXP 12
17197: PUSH
17198: LD_INT 1
17200: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17201: LD_ADDR_EXP 14
17205: PUSH
17206: LD_INT 1
17208: ST_TO_ADDR
// end ;
17209: PPOPN 2
17211: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17212: LD_ADDR_EXP 14
17216: PUSH
17217: LD_INT 0
17219: ST_TO_ADDR
// end ;
17220: PPOPN 2
17222: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17223: LD_VAR 0 1
17227: PPUSH
17228: CALL 105606 0 1
// if un = JMM then
17232: LD_VAR 0 1
17236: PUSH
17237: LD_EXP 21
17241: EQUAL
17242: IFFALSE 17253
// begin YouLost ( JMM ) ;
17244: LD_STRING JMM
17246: PPUSH
17247: CALL_OW 104
// exit ;
17251: GO 17385
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17253: LD_VAR 0 1
17257: PUSH
17258: LD_INT 22
17260: PUSH
17261: LD_INT 1
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: PUSH
17268: LD_INT 21
17270: PUSH
17271: LD_INT 1
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PUSH
17278: LD_INT 2
17280: PUSH
17281: LD_INT 25
17283: PUSH
17284: LD_INT 1
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 25
17293: PUSH
17294: LD_INT 2
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 3
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 25
17313: PUSH
17314: LD_INT 4
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: LD_INT 25
17323: PUSH
17324: LD_INT 5
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: LD_INT 25
17333: PUSH
17334: LD_INT 8
17336: PUSH
17337: EMPTY
17338: LIST
17339: LIST
17340: PUSH
17341: EMPTY
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: LIST
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: LIST
17354: PPUSH
17355: CALL_OW 69
17359: IN
17360: IFFALSE 17376
// loses_counter := loses_counter + 1 ;
17362: LD_ADDR_EXP 17
17366: PUSH
17367: LD_EXP 17
17371: PUSH
17372: LD_INT 1
17374: PLUS
17375: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 45593 0 1
// end ;
17385: PPOPN 1
17387: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17388: LD_VAR 0 1
17392: PPUSH
17393: LD_VAR 0 2
17397: PPUSH
17398: CALL 47927 0 2
// end ;
17402: PPOPN 2
17404: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17405: LD_VAR 0 1
17409: PPUSH
17410: CALL 47236 0 1
// end ;
17414: PPOPN 1
17416: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17417: LD_VAR 0 1
17421: PPUSH
17422: LD_VAR 0 2
17426: PPUSH
17427: LD_VAR 0 3
17431: PPUSH
17432: LD_VAR 0 4
17436: PPUSH
17437: LD_VAR 0 5
17441: PPUSH
17442: CALL 44909 0 5
// end ;
17446: PPOPN 5
17448: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17449: LD_VAR 0 1
17453: PPUSH
17454: LD_VAR 0 2
17458: PPUSH
17459: CALL 105728 0 2
// if GetNation ( vehicle ) = nation_american then
17463: LD_VAR 0 1
17467: PPUSH
17468: CALL_OW 248
17472: PUSH
17473: LD_INT 1
17475: EQUAL
17476: IFFALSE 17486
// am_veh_consturcted := true ;
17478: LD_ADDR_EXP 20
17482: PUSH
17483: LD_INT 1
17485: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17486: LD_VAR 0 1
17490: PPUSH
17491: LD_VAR 0 2
17495: PPUSH
17496: CALL 44490 0 2
// end ;
17500: PPOPN 2
17502: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17503: LD_VAR 0 1
17507: PPUSH
17508: CALL_OW 247
17512: PUSH
17513: LD_INT 2
17515: EQUAL
17516: IFFALSE 17520
// exit ;
17518: GO 17537
// if not kamikazed then
17520: LD_EXP 11
17524: NOT
17525: IFFALSE 17537
// kamikazed := unit ;
17527: LD_ADDR_EXP 11
17531: PUSH
17532: LD_VAR 0 1
17536: ST_TO_ADDR
// end ;
17537: PPOPN 1
17539: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17540: LD_INT 0
17542: PPUSH
17543: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17544: LD_VAR 0 1
17548: PPUSH
17549: LD_VAR 0 2
17553: PPUSH
17554: LD_VAR 0 3
17558: PPUSH
17559: LD_VAR 0 4
17563: PPUSH
17564: CALL 44328 0 4
// end ;
17568: PPOPN 6
17570: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17571: LD_VAR 0 1
17575: PPUSH
17576: LD_VAR 0 2
17580: PPUSH
17581: LD_VAR 0 3
17585: PPUSH
17586: CALL 44103 0 3
// end ;
17590: PPOPN 3
17592: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17593: LD_VAR 0 1
17597: PPUSH
17598: LD_VAR 0 2
17602: PPUSH
17603: CALL 45289 0 2
// end ;
17607: PPOPN 2
17609: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17610: LD_VAR 0 1
17614: PPUSH
17615: LD_VAR 0 2
17619: PPUSH
17620: CALL 43797 0 2
// end ;
17624: PPOPN 2
17626: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17627: LD_VAR 0 1
17631: PPUSH
17632: LD_VAR 0 2
17636: PPUSH
17637: CALL 43988 0 2
// end ;
17641: PPOPN 2
17643: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17644: LD_VAR 0 1
17648: PPUSH
17649: CALL 46995 0 1
// end ;
17653: PPOPN 1
17655: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17656: LD_VAR 0 1
17660: PPUSH
17661: LD_VAR 0 2
17665: PPUSH
17666: CALL 48222 0 2
// end ;
17670: PPOPN 2
17672: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17673: LD_VAR 0 1
17677: PPUSH
17678: LD_VAR 0 2
17682: PPUSH
17683: LD_VAR 0 3
17687: PPUSH
17688: LD_VAR 0 4
17692: PPUSH
17693: CALL 48438 0 4
// end ;
17697: PPOPN 4
17699: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17700: LD_VAR 0 1
17704: PPUSH
17705: CALL 105712 0 1
// end ; end_of_file
17709: PPOPN 1
17711: END
// every 0 0$1 trigger game do
17712: LD_EXP 2
17716: IFFALSE 17746
17718: GO 17720
17720: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17721: LD_INT 7
17723: PUSH
17724: LD_INT 6
17726: PUSH
17727: LD_INT 4
17729: PUSH
17730: LD_INT 6
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: LIST
17738: PPUSH
17739: LD_INT 1750
17741: PPUSH
17742: CALL 17747 0 2
17746: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17747: LD_INT 0
17749: PPUSH
17750: PPUSH
17751: PPUSH
// if not areas then
17752: LD_VAR 0 1
17756: NOT
17757: IFFALSE 17761
// exit ;
17759: GO 17891
// repeat wait ( time ) ;
17761: LD_VAR 0 2
17765: PPUSH
17766: CALL_OW 67
// for i in areas do
17770: LD_ADDR_VAR 0 4
17774: PUSH
17775: LD_VAR 0 1
17779: PUSH
17780: FOR_IN
17781: IFFALSE 17850
// begin p := rand ( 1 , 90 ) ;
17783: LD_ADDR_VAR 0 5
17787: PUSH
17788: LD_INT 1
17790: PPUSH
17791: LD_INT 90
17793: PPUSH
17794: CALL_OW 12
17798: ST_TO_ADDR
// if Prob ( p ) then
17799: LD_VAR 0 5
17803: PPUSH
17804: CALL_OW 13
17808: IFFALSE 17848
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17810: LD_INT 2
17812: PPUSH
17813: LD_INT 5
17815: PPUSH
17816: CALL_OW 12
17820: PPUSH
17821: LD_VAR 0 4
17825: PPUSH
17826: LD_INT 1
17828: PPUSH
17829: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17833: LD_INT 735
17835: PPUSH
17836: LD_INT 1295
17838: PPUSH
17839: CALL_OW 12
17843: PPUSH
17844: CALL_OW 67
// end ; end ;
17848: GO 17780
17850: POP
17851: POP
// time := time + 0 0$3 ;
17852: LD_ADDR_VAR 0 2
17856: PUSH
17857: LD_VAR 0 2
17861: PUSH
17862: LD_INT 105
17864: PLUS
17865: ST_TO_ADDR
// if time > 6 6$00 then
17866: LD_VAR 0 2
17870: PUSH
17871: LD_INT 12600
17873: GREATER
17874: IFFALSE 17884
// time := 0 0$40 ;
17876: LD_ADDR_VAR 0 2
17880: PUSH
17881: LD_INT 1400
17883: ST_TO_ADDR
// until not game ;
17884: LD_EXP 2
17888: NOT
17889: IFFALSE 17761
// end ;
17891: LD_VAR 0 3
17895: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17896: LD_OWVAR 1
17900: PUSH
17901: LD_INT 84000
17903: PUSH
17904: LD_INT 73500
17906: PUSH
17907: LD_INT 63000
17909: PUSH
17910: LD_INT 52500
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: LIST
17917: LIST
17918: PUSH
17919: LD_OWVAR 67
17923: ARRAY
17924: LESS
17925: IFFALSE 17952
17927: GO 17929
17929: DISABLE
// begin enable ;
17930: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17931: LD_INT 1
17933: PPUSH
17934: LD_INT 5
17936: PPUSH
17937: CALL_OW 12
17941: PPUSH
17942: LD_INT 7
17944: PPUSH
17945: LD_INT 1
17947: PPUSH
17948: CALL_OW 55
// end ; end_of_file
17952: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17953: LD_INT 0
17955: PPUSH
17956: PPUSH
// skirmish := false ;
17957: LD_ADDR_EXP 48
17961: PUSH
17962: LD_INT 0
17964: ST_TO_ADDR
// debug_mc := false ;
17965: LD_ADDR_EXP 49
17969: PUSH
17970: LD_INT 0
17972: ST_TO_ADDR
// mc_bases := [ ] ;
17973: LD_ADDR_EXP 50
17977: PUSH
17978: EMPTY
17979: ST_TO_ADDR
// mc_sides := [ ] ;
17980: LD_ADDR_EXP 76
17984: PUSH
17985: EMPTY
17986: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17987: LD_ADDR_EXP 51
17991: PUSH
17992: EMPTY
17993: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17994: LD_ADDR_EXP 52
17998: PUSH
17999: EMPTY
18000: ST_TO_ADDR
// mc_need_heal := [ ] ;
18001: LD_ADDR_EXP 53
18005: PUSH
18006: EMPTY
18007: ST_TO_ADDR
// mc_healers := [ ] ;
18008: LD_ADDR_EXP 54
18012: PUSH
18013: EMPTY
18014: ST_TO_ADDR
// mc_build_list := [ ] ;
18015: LD_ADDR_EXP 55
18019: PUSH
18020: EMPTY
18021: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18022: LD_ADDR_EXP 82
18026: PUSH
18027: EMPTY
18028: ST_TO_ADDR
// mc_builders := [ ] ;
18029: LD_ADDR_EXP 56
18033: PUSH
18034: EMPTY
18035: ST_TO_ADDR
// mc_construct_list := [ ] ;
18036: LD_ADDR_EXP 57
18040: PUSH
18041: EMPTY
18042: ST_TO_ADDR
// mc_turret_list := [ ] ;
18043: LD_ADDR_EXP 58
18047: PUSH
18048: EMPTY
18049: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18050: LD_ADDR_EXP 59
18054: PUSH
18055: EMPTY
18056: ST_TO_ADDR
// mc_miners := [ ] ;
18057: LD_ADDR_EXP 64
18061: PUSH
18062: EMPTY
18063: ST_TO_ADDR
// mc_mines := [ ] ;
18064: LD_ADDR_EXP 63
18068: PUSH
18069: EMPTY
18070: ST_TO_ADDR
// mc_minefields := [ ] ;
18071: LD_ADDR_EXP 65
18075: PUSH
18076: EMPTY
18077: ST_TO_ADDR
// mc_crates := [ ] ;
18078: LD_ADDR_EXP 66
18082: PUSH
18083: EMPTY
18084: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18085: LD_ADDR_EXP 67
18089: PUSH
18090: EMPTY
18091: ST_TO_ADDR
// mc_crates_area := [ ] ;
18092: LD_ADDR_EXP 68
18096: PUSH
18097: EMPTY
18098: ST_TO_ADDR
// mc_vehicles := [ ] ;
18099: LD_ADDR_EXP 69
18103: PUSH
18104: EMPTY
18105: ST_TO_ADDR
// mc_attack := [ ] ;
18106: LD_ADDR_EXP 70
18110: PUSH
18111: EMPTY
18112: ST_TO_ADDR
// mc_produce := [ ] ;
18113: LD_ADDR_EXP 71
18117: PUSH
18118: EMPTY
18119: ST_TO_ADDR
// mc_defender := [ ] ;
18120: LD_ADDR_EXP 72
18124: PUSH
18125: EMPTY
18126: ST_TO_ADDR
// mc_parking := [ ] ;
18127: LD_ADDR_EXP 74
18131: PUSH
18132: EMPTY
18133: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18134: LD_ADDR_EXP 60
18138: PUSH
18139: EMPTY
18140: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18141: LD_ADDR_EXP 62
18145: PUSH
18146: EMPTY
18147: ST_TO_ADDR
// mc_scan := [ ] ;
18148: LD_ADDR_EXP 73
18152: PUSH
18153: EMPTY
18154: ST_TO_ADDR
// mc_scan_area := [ ] ;
18155: LD_ADDR_EXP 75
18159: PUSH
18160: EMPTY
18161: ST_TO_ADDR
// mc_tech := [ ] ;
18162: LD_ADDR_EXP 77
18166: PUSH
18167: EMPTY
18168: ST_TO_ADDR
// mc_class := [ ] ;
18169: LD_ADDR_EXP 91
18173: PUSH
18174: EMPTY
18175: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18176: LD_ADDR_EXP 92
18180: PUSH
18181: EMPTY
18182: ST_TO_ADDR
// mc_is_defending := [ ] ;
18183: LD_ADDR_EXP 93
18187: PUSH
18188: EMPTY
18189: ST_TO_ADDR
// end ;
18190: LD_VAR 0 1
18194: RET
// export function MC_Kill ( base ) ; begin
18195: LD_INT 0
18197: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: EMPTY
18214: PPUSH
18215: CALL_OW 1
18219: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18220: LD_ADDR_EXP 51
18224: PUSH
18225: LD_EXP 51
18229: PPUSH
18230: LD_VAR 0 1
18234: PPUSH
18235: EMPTY
18236: PPUSH
18237: CALL_OW 1
18241: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18242: LD_ADDR_EXP 52
18246: PUSH
18247: LD_EXP 52
18251: PPUSH
18252: LD_VAR 0 1
18256: PPUSH
18257: EMPTY
18258: PPUSH
18259: CALL_OW 1
18263: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18264: LD_ADDR_EXP 53
18268: PUSH
18269: LD_EXP 53
18273: PPUSH
18274: LD_VAR 0 1
18278: PPUSH
18279: EMPTY
18280: PPUSH
18281: CALL_OW 1
18285: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18286: LD_ADDR_EXP 54
18290: PUSH
18291: LD_EXP 54
18295: PPUSH
18296: LD_VAR 0 1
18300: PPUSH
18301: EMPTY
18302: PPUSH
18303: CALL_OW 1
18307: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18308: LD_ADDR_EXP 55
18312: PUSH
18313: LD_EXP 55
18317: PPUSH
18318: LD_VAR 0 1
18322: PPUSH
18323: EMPTY
18324: PPUSH
18325: CALL_OW 1
18329: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18330: LD_ADDR_EXP 56
18334: PUSH
18335: LD_EXP 56
18339: PPUSH
18340: LD_VAR 0 1
18344: PPUSH
18345: EMPTY
18346: PPUSH
18347: CALL_OW 1
18351: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18352: LD_ADDR_EXP 57
18356: PUSH
18357: LD_EXP 57
18361: PPUSH
18362: LD_VAR 0 1
18366: PPUSH
18367: EMPTY
18368: PPUSH
18369: CALL_OW 1
18373: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18374: LD_ADDR_EXP 58
18378: PUSH
18379: LD_EXP 58
18383: PPUSH
18384: LD_VAR 0 1
18388: PPUSH
18389: EMPTY
18390: PPUSH
18391: CALL_OW 1
18395: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18396: LD_ADDR_EXP 59
18400: PUSH
18401: LD_EXP 59
18405: PPUSH
18406: LD_VAR 0 1
18410: PPUSH
18411: EMPTY
18412: PPUSH
18413: CALL_OW 1
18417: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18418: LD_ADDR_EXP 60
18422: PUSH
18423: LD_EXP 60
18427: PPUSH
18428: LD_VAR 0 1
18432: PPUSH
18433: EMPTY
18434: PPUSH
18435: CALL_OW 1
18439: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18440: LD_ADDR_EXP 61
18444: PUSH
18445: LD_EXP 61
18449: PPUSH
18450: LD_VAR 0 1
18454: PPUSH
18455: LD_INT 0
18457: PPUSH
18458: CALL_OW 1
18462: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18463: LD_ADDR_EXP 62
18467: PUSH
18468: LD_EXP 62
18472: PPUSH
18473: LD_VAR 0 1
18477: PPUSH
18478: EMPTY
18479: PPUSH
18480: CALL_OW 1
18484: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18485: LD_ADDR_EXP 63
18489: PUSH
18490: LD_EXP 63
18494: PPUSH
18495: LD_VAR 0 1
18499: PPUSH
18500: EMPTY
18501: PPUSH
18502: CALL_OW 1
18506: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18507: LD_ADDR_EXP 64
18511: PUSH
18512: LD_EXP 64
18516: PPUSH
18517: LD_VAR 0 1
18521: PPUSH
18522: EMPTY
18523: PPUSH
18524: CALL_OW 1
18528: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18529: LD_ADDR_EXP 65
18533: PUSH
18534: LD_EXP 65
18538: PPUSH
18539: LD_VAR 0 1
18543: PPUSH
18544: EMPTY
18545: PPUSH
18546: CALL_OW 1
18550: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18551: LD_ADDR_EXP 66
18555: PUSH
18556: LD_EXP 66
18560: PPUSH
18561: LD_VAR 0 1
18565: PPUSH
18566: EMPTY
18567: PPUSH
18568: CALL_OW 1
18572: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18573: LD_ADDR_EXP 67
18577: PUSH
18578: LD_EXP 67
18582: PPUSH
18583: LD_VAR 0 1
18587: PPUSH
18588: EMPTY
18589: PPUSH
18590: CALL_OW 1
18594: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18595: LD_ADDR_EXP 68
18599: PUSH
18600: LD_EXP 68
18604: PPUSH
18605: LD_VAR 0 1
18609: PPUSH
18610: EMPTY
18611: PPUSH
18612: CALL_OW 1
18616: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18617: LD_ADDR_EXP 69
18621: PUSH
18622: LD_EXP 69
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: EMPTY
18633: PPUSH
18634: CALL_OW 1
18638: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18639: LD_ADDR_EXP 70
18643: PUSH
18644: LD_EXP 70
18648: PPUSH
18649: LD_VAR 0 1
18653: PPUSH
18654: EMPTY
18655: PPUSH
18656: CALL_OW 1
18660: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18661: LD_ADDR_EXP 71
18665: PUSH
18666: LD_EXP 71
18670: PPUSH
18671: LD_VAR 0 1
18675: PPUSH
18676: EMPTY
18677: PPUSH
18678: CALL_OW 1
18682: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18683: LD_ADDR_EXP 72
18687: PUSH
18688: LD_EXP 72
18692: PPUSH
18693: LD_VAR 0 1
18697: PPUSH
18698: EMPTY
18699: PPUSH
18700: CALL_OW 1
18704: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18705: LD_ADDR_EXP 73
18709: PUSH
18710: LD_EXP 73
18714: PPUSH
18715: LD_VAR 0 1
18719: PPUSH
18720: EMPTY
18721: PPUSH
18722: CALL_OW 1
18726: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18727: LD_ADDR_EXP 74
18731: PUSH
18732: LD_EXP 74
18736: PPUSH
18737: LD_VAR 0 1
18741: PPUSH
18742: EMPTY
18743: PPUSH
18744: CALL_OW 1
18748: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18749: LD_ADDR_EXP 75
18753: PUSH
18754: LD_EXP 75
18758: PPUSH
18759: LD_VAR 0 1
18763: PPUSH
18764: EMPTY
18765: PPUSH
18766: CALL_OW 1
18770: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18771: LD_ADDR_EXP 77
18775: PUSH
18776: LD_EXP 77
18780: PPUSH
18781: LD_VAR 0 1
18785: PPUSH
18786: EMPTY
18787: PPUSH
18788: CALL_OW 1
18792: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18793: LD_ADDR_EXP 79
18797: PUSH
18798: LD_EXP 79
18802: PPUSH
18803: LD_VAR 0 1
18807: PPUSH
18808: EMPTY
18809: PPUSH
18810: CALL_OW 1
18814: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18815: LD_ADDR_EXP 80
18819: PUSH
18820: LD_EXP 80
18824: PPUSH
18825: LD_VAR 0 1
18829: PPUSH
18830: EMPTY
18831: PPUSH
18832: CALL_OW 1
18836: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18837: LD_ADDR_EXP 81
18841: PUSH
18842: LD_EXP 81
18846: PPUSH
18847: LD_VAR 0 1
18851: PPUSH
18852: EMPTY
18853: PPUSH
18854: CALL_OW 1
18858: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18859: LD_ADDR_EXP 82
18863: PUSH
18864: LD_EXP 82
18868: PPUSH
18869: LD_VAR 0 1
18873: PPUSH
18874: EMPTY
18875: PPUSH
18876: CALL_OW 1
18880: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18881: LD_ADDR_EXP 83
18885: PUSH
18886: LD_EXP 83
18890: PPUSH
18891: LD_VAR 0 1
18895: PPUSH
18896: EMPTY
18897: PPUSH
18898: CALL_OW 1
18902: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18903: LD_ADDR_EXP 84
18907: PUSH
18908: LD_EXP 84
18912: PPUSH
18913: LD_VAR 0 1
18917: PPUSH
18918: EMPTY
18919: PPUSH
18920: CALL_OW 1
18924: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18925: LD_ADDR_EXP 85
18929: PUSH
18930: LD_EXP 85
18934: PPUSH
18935: LD_VAR 0 1
18939: PPUSH
18940: EMPTY
18941: PPUSH
18942: CALL_OW 1
18946: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18947: LD_ADDR_EXP 86
18951: PUSH
18952: LD_EXP 86
18956: PPUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: EMPTY
18963: PPUSH
18964: CALL_OW 1
18968: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18969: LD_ADDR_EXP 87
18973: PUSH
18974: LD_EXP 87
18978: PPUSH
18979: LD_VAR 0 1
18983: PPUSH
18984: EMPTY
18985: PPUSH
18986: CALL_OW 1
18990: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18991: LD_ADDR_EXP 88
18995: PUSH
18996: LD_EXP 88
19000: PPUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: EMPTY
19007: PPUSH
19008: CALL_OW 1
19012: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19013: LD_ADDR_EXP 89
19017: PUSH
19018: LD_EXP 89
19022: PPUSH
19023: LD_VAR 0 1
19027: PPUSH
19028: EMPTY
19029: PPUSH
19030: CALL_OW 1
19034: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19035: LD_ADDR_EXP 90
19039: PUSH
19040: LD_EXP 90
19044: PPUSH
19045: LD_VAR 0 1
19049: PPUSH
19050: EMPTY
19051: PPUSH
19052: CALL_OW 1
19056: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19057: LD_ADDR_EXP 91
19061: PUSH
19062: LD_EXP 91
19066: PPUSH
19067: LD_VAR 0 1
19071: PPUSH
19072: EMPTY
19073: PPUSH
19074: CALL_OW 1
19078: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19079: LD_ADDR_EXP 92
19083: PUSH
19084: LD_EXP 92
19088: PPUSH
19089: LD_VAR 0 1
19093: PPUSH
19094: LD_INT 0
19096: PPUSH
19097: CALL_OW 1
19101: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19102: LD_ADDR_EXP 93
19106: PUSH
19107: LD_EXP 93
19111: PPUSH
19112: LD_VAR 0 1
19116: PPUSH
19117: LD_INT 0
19119: PPUSH
19120: CALL_OW 1
19124: ST_TO_ADDR
// end ;
19125: LD_VAR 0 2
19129: RET
// export function MC_Add ( side , units ) ; var base ; begin
19130: LD_INT 0
19132: PPUSH
19133: PPUSH
// base := mc_bases + 1 ;
19134: LD_ADDR_VAR 0 4
19138: PUSH
19139: LD_EXP 50
19143: PUSH
19144: LD_INT 1
19146: PLUS
19147: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19148: LD_ADDR_EXP 76
19152: PUSH
19153: LD_EXP 76
19157: PPUSH
19158: LD_VAR 0 4
19162: PPUSH
19163: LD_VAR 0 1
19167: PPUSH
19168: CALL_OW 1
19172: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19173: LD_ADDR_EXP 50
19177: PUSH
19178: LD_EXP 50
19182: PPUSH
19183: LD_VAR 0 4
19187: PPUSH
19188: LD_VAR 0 2
19192: PPUSH
19193: CALL_OW 1
19197: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19198: LD_ADDR_EXP 51
19202: PUSH
19203: LD_EXP 51
19207: PPUSH
19208: LD_VAR 0 4
19212: PPUSH
19213: EMPTY
19214: PPUSH
19215: CALL_OW 1
19219: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19220: LD_ADDR_EXP 52
19224: PUSH
19225: LD_EXP 52
19229: PPUSH
19230: LD_VAR 0 4
19234: PPUSH
19235: EMPTY
19236: PPUSH
19237: CALL_OW 1
19241: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19242: LD_ADDR_EXP 53
19246: PUSH
19247: LD_EXP 53
19251: PPUSH
19252: LD_VAR 0 4
19256: PPUSH
19257: EMPTY
19258: PPUSH
19259: CALL_OW 1
19263: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19264: LD_ADDR_EXP 54
19268: PUSH
19269: LD_EXP 54
19273: PPUSH
19274: LD_VAR 0 4
19278: PPUSH
19279: EMPTY
19280: PPUSH
19281: CALL_OW 1
19285: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19286: LD_ADDR_EXP 55
19290: PUSH
19291: LD_EXP 55
19295: PPUSH
19296: LD_VAR 0 4
19300: PPUSH
19301: EMPTY
19302: PPUSH
19303: CALL_OW 1
19307: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19308: LD_ADDR_EXP 56
19312: PUSH
19313: LD_EXP 56
19317: PPUSH
19318: LD_VAR 0 4
19322: PPUSH
19323: EMPTY
19324: PPUSH
19325: CALL_OW 1
19329: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19330: LD_ADDR_EXP 57
19334: PUSH
19335: LD_EXP 57
19339: PPUSH
19340: LD_VAR 0 4
19344: PPUSH
19345: EMPTY
19346: PPUSH
19347: CALL_OW 1
19351: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19352: LD_ADDR_EXP 58
19356: PUSH
19357: LD_EXP 58
19361: PPUSH
19362: LD_VAR 0 4
19366: PPUSH
19367: EMPTY
19368: PPUSH
19369: CALL_OW 1
19373: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19374: LD_ADDR_EXP 59
19378: PUSH
19379: LD_EXP 59
19383: PPUSH
19384: LD_VAR 0 4
19388: PPUSH
19389: EMPTY
19390: PPUSH
19391: CALL_OW 1
19395: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19396: LD_ADDR_EXP 60
19400: PUSH
19401: LD_EXP 60
19405: PPUSH
19406: LD_VAR 0 4
19410: PPUSH
19411: EMPTY
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19418: LD_ADDR_EXP 61
19422: PUSH
19423: LD_EXP 61
19427: PPUSH
19428: LD_VAR 0 4
19432: PPUSH
19433: LD_INT 0
19435: PPUSH
19436: CALL_OW 1
19440: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19441: LD_ADDR_EXP 62
19445: PUSH
19446: LD_EXP 62
19450: PPUSH
19451: LD_VAR 0 4
19455: PPUSH
19456: EMPTY
19457: PPUSH
19458: CALL_OW 1
19462: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19463: LD_ADDR_EXP 63
19467: PUSH
19468: LD_EXP 63
19472: PPUSH
19473: LD_VAR 0 4
19477: PPUSH
19478: EMPTY
19479: PPUSH
19480: CALL_OW 1
19484: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19485: LD_ADDR_EXP 64
19489: PUSH
19490: LD_EXP 64
19494: PPUSH
19495: LD_VAR 0 4
19499: PPUSH
19500: EMPTY
19501: PPUSH
19502: CALL_OW 1
19506: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19507: LD_ADDR_EXP 65
19511: PUSH
19512: LD_EXP 65
19516: PPUSH
19517: LD_VAR 0 4
19521: PPUSH
19522: EMPTY
19523: PPUSH
19524: CALL_OW 1
19528: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19529: LD_ADDR_EXP 66
19533: PUSH
19534: LD_EXP 66
19538: PPUSH
19539: LD_VAR 0 4
19543: PPUSH
19544: EMPTY
19545: PPUSH
19546: CALL_OW 1
19550: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19551: LD_ADDR_EXP 67
19555: PUSH
19556: LD_EXP 67
19560: PPUSH
19561: LD_VAR 0 4
19565: PPUSH
19566: EMPTY
19567: PPUSH
19568: CALL_OW 1
19572: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19573: LD_ADDR_EXP 68
19577: PUSH
19578: LD_EXP 68
19582: PPUSH
19583: LD_VAR 0 4
19587: PPUSH
19588: EMPTY
19589: PPUSH
19590: CALL_OW 1
19594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19595: LD_ADDR_EXP 69
19599: PUSH
19600: LD_EXP 69
19604: PPUSH
19605: LD_VAR 0 4
19609: PPUSH
19610: EMPTY
19611: PPUSH
19612: CALL_OW 1
19616: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19617: LD_ADDR_EXP 70
19621: PUSH
19622: LD_EXP 70
19626: PPUSH
19627: LD_VAR 0 4
19631: PPUSH
19632: EMPTY
19633: PPUSH
19634: CALL_OW 1
19638: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19639: LD_ADDR_EXP 71
19643: PUSH
19644: LD_EXP 71
19648: PPUSH
19649: LD_VAR 0 4
19653: PPUSH
19654: EMPTY
19655: PPUSH
19656: CALL_OW 1
19660: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19661: LD_ADDR_EXP 72
19665: PUSH
19666: LD_EXP 72
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: EMPTY
19677: PPUSH
19678: CALL_OW 1
19682: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19683: LD_ADDR_EXP 73
19687: PUSH
19688: LD_EXP 73
19692: PPUSH
19693: LD_VAR 0 4
19697: PPUSH
19698: EMPTY
19699: PPUSH
19700: CALL_OW 1
19704: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19705: LD_ADDR_EXP 74
19709: PUSH
19710: LD_EXP 74
19714: PPUSH
19715: LD_VAR 0 4
19719: PPUSH
19720: EMPTY
19721: PPUSH
19722: CALL_OW 1
19726: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19727: LD_ADDR_EXP 75
19731: PUSH
19732: LD_EXP 75
19736: PPUSH
19737: LD_VAR 0 4
19741: PPUSH
19742: EMPTY
19743: PPUSH
19744: CALL_OW 1
19748: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19749: LD_ADDR_EXP 77
19753: PUSH
19754: LD_EXP 77
19758: PPUSH
19759: LD_VAR 0 4
19763: PPUSH
19764: EMPTY
19765: PPUSH
19766: CALL_OW 1
19770: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19771: LD_ADDR_EXP 79
19775: PUSH
19776: LD_EXP 79
19780: PPUSH
19781: LD_VAR 0 4
19785: PPUSH
19786: EMPTY
19787: PPUSH
19788: CALL_OW 1
19792: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19793: LD_ADDR_EXP 80
19797: PUSH
19798: LD_EXP 80
19802: PPUSH
19803: LD_VAR 0 4
19807: PPUSH
19808: EMPTY
19809: PPUSH
19810: CALL_OW 1
19814: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19815: LD_ADDR_EXP 81
19819: PUSH
19820: LD_EXP 81
19824: PPUSH
19825: LD_VAR 0 4
19829: PPUSH
19830: EMPTY
19831: PPUSH
19832: CALL_OW 1
19836: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19837: LD_ADDR_EXP 82
19841: PUSH
19842: LD_EXP 82
19846: PPUSH
19847: LD_VAR 0 4
19851: PPUSH
19852: EMPTY
19853: PPUSH
19854: CALL_OW 1
19858: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19859: LD_ADDR_EXP 83
19863: PUSH
19864: LD_EXP 83
19868: PPUSH
19869: LD_VAR 0 4
19873: PPUSH
19874: EMPTY
19875: PPUSH
19876: CALL_OW 1
19880: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19881: LD_ADDR_EXP 84
19885: PUSH
19886: LD_EXP 84
19890: PPUSH
19891: LD_VAR 0 4
19895: PPUSH
19896: EMPTY
19897: PPUSH
19898: CALL_OW 1
19902: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19903: LD_ADDR_EXP 85
19907: PUSH
19908: LD_EXP 85
19912: PPUSH
19913: LD_VAR 0 4
19917: PPUSH
19918: EMPTY
19919: PPUSH
19920: CALL_OW 1
19924: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19925: LD_ADDR_EXP 86
19929: PUSH
19930: LD_EXP 86
19934: PPUSH
19935: LD_VAR 0 4
19939: PPUSH
19940: EMPTY
19941: PPUSH
19942: CALL_OW 1
19946: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19947: LD_ADDR_EXP 87
19951: PUSH
19952: LD_EXP 87
19956: PPUSH
19957: LD_VAR 0 4
19961: PPUSH
19962: EMPTY
19963: PPUSH
19964: CALL_OW 1
19968: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19969: LD_ADDR_EXP 88
19973: PUSH
19974: LD_EXP 88
19978: PPUSH
19979: LD_VAR 0 4
19983: PPUSH
19984: EMPTY
19985: PPUSH
19986: CALL_OW 1
19990: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19991: LD_ADDR_EXP 89
19995: PUSH
19996: LD_EXP 89
20000: PPUSH
20001: LD_VAR 0 4
20005: PPUSH
20006: EMPTY
20007: PPUSH
20008: CALL_OW 1
20012: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20013: LD_ADDR_EXP 90
20017: PUSH
20018: LD_EXP 90
20022: PPUSH
20023: LD_VAR 0 4
20027: PPUSH
20028: EMPTY
20029: PPUSH
20030: CALL_OW 1
20034: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20035: LD_ADDR_EXP 91
20039: PUSH
20040: LD_EXP 91
20044: PPUSH
20045: LD_VAR 0 4
20049: PPUSH
20050: EMPTY
20051: PPUSH
20052: CALL_OW 1
20056: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20057: LD_ADDR_EXP 92
20061: PUSH
20062: LD_EXP 92
20066: PPUSH
20067: LD_VAR 0 4
20071: PPUSH
20072: LD_INT 0
20074: PPUSH
20075: CALL_OW 1
20079: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20080: LD_ADDR_EXP 93
20084: PUSH
20085: LD_EXP 93
20089: PPUSH
20090: LD_VAR 0 4
20094: PPUSH
20095: LD_INT 0
20097: PPUSH
20098: CALL_OW 1
20102: ST_TO_ADDR
// result := base ;
20103: LD_ADDR_VAR 0 3
20107: PUSH
20108: LD_VAR 0 4
20112: ST_TO_ADDR
// end ;
20113: LD_VAR 0 3
20117: RET
// export function MC_Start ( ) ; var i ; begin
20118: LD_INT 0
20120: PPUSH
20121: PPUSH
// for i = 1 to mc_bases do
20122: LD_ADDR_VAR 0 2
20126: PUSH
20127: DOUBLE
20128: LD_INT 1
20130: DEC
20131: ST_TO_ADDR
20132: LD_EXP 50
20136: PUSH
20137: FOR_TO
20138: IFFALSE 21238
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20140: LD_ADDR_EXP 50
20144: PUSH
20145: LD_EXP 50
20149: PPUSH
20150: LD_VAR 0 2
20154: PPUSH
20155: LD_EXP 50
20159: PUSH
20160: LD_VAR 0 2
20164: ARRAY
20165: PUSH
20166: LD_INT 0
20168: DIFF
20169: PPUSH
20170: CALL_OW 1
20174: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20175: LD_ADDR_EXP 51
20179: PUSH
20180: LD_EXP 51
20184: PPUSH
20185: LD_VAR 0 2
20189: PPUSH
20190: EMPTY
20191: PPUSH
20192: CALL_OW 1
20196: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20197: LD_ADDR_EXP 52
20201: PUSH
20202: LD_EXP 52
20206: PPUSH
20207: LD_VAR 0 2
20211: PPUSH
20212: EMPTY
20213: PPUSH
20214: CALL_OW 1
20218: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20219: LD_ADDR_EXP 53
20223: PUSH
20224: LD_EXP 53
20228: PPUSH
20229: LD_VAR 0 2
20233: PPUSH
20234: EMPTY
20235: PPUSH
20236: CALL_OW 1
20240: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20241: LD_ADDR_EXP 54
20245: PUSH
20246: LD_EXP 54
20250: PPUSH
20251: LD_VAR 0 2
20255: PPUSH
20256: EMPTY
20257: PUSH
20258: EMPTY
20259: PUSH
20260: EMPTY
20261: LIST
20262: LIST
20263: PPUSH
20264: CALL_OW 1
20268: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20269: LD_ADDR_EXP 55
20273: PUSH
20274: LD_EXP 55
20278: PPUSH
20279: LD_VAR 0 2
20283: PPUSH
20284: EMPTY
20285: PPUSH
20286: CALL_OW 1
20290: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20291: LD_ADDR_EXP 82
20295: PUSH
20296: LD_EXP 82
20300: PPUSH
20301: LD_VAR 0 2
20305: PPUSH
20306: EMPTY
20307: PPUSH
20308: CALL_OW 1
20312: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20313: LD_ADDR_EXP 56
20317: PUSH
20318: LD_EXP 56
20322: PPUSH
20323: LD_VAR 0 2
20327: PPUSH
20328: EMPTY
20329: PPUSH
20330: CALL_OW 1
20334: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20335: LD_ADDR_EXP 57
20339: PUSH
20340: LD_EXP 57
20344: PPUSH
20345: LD_VAR 0 2
20349: PPUSH
20350: EMPTY
20351: PPUSH
20352: CALL_OW 1
20356: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20357: LD_ADDR_EXP 58
20361: PUSH
20362: LD_EXP 58
20366: PPUSH
20367: LD_VAR 0 2
20371: PPUSH
20372: LD_EXP 50
20376: PUSH
20377: LD_VAR 0 2
20381: ARRAY
20382: PPUSH
20383: LD_INT 2
20385: PUSH
20386: LD_INT 30
20388: PUSH
20389: LD_INT 32
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: LD_INT 30
20398: PUSH
20399: LD_INT 33
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: LIST
20410: PPUSH
20411: CALL_OW 72
20415: PPUSH
20416: CALL_OW 1
20420: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20421: LD_ADDR_EXP 59
20425: PUSH
20426: LD_EXP 59
20430: PPUSH
20431: LD_VAR 0 2
20435: PPUSH
20436: LD_EXP 50
20440: PUSH
20441: LD_VAR 0 2
20445: ARRAY
20446: PPUSH
20447: LD_INT 2
20449: PUSH
20450: LD_INT 30
20452: PUSH
20453: LD_INT 32
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PUSH
20460: LD_INT 30
20462: PUSH
20463: LD_INT 31
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: LIST
20474: PUSH
20475: LD_INT 58
20477: PUSH
20478: EMPTY
20479: LIST
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PPUSH
20485: CALL_OW 72
20489: PPUSH
20490: CALL_OW 1
20494: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20495: LD_ADDR_EXP 60
20499: PUSH
20500: LD_EXP 60
20504: PPUSH
20505: LD_VAR 0 2
20509: PPUSH
20510: EMPTY
20511: PPUSH
20512: CALL_OW 1
20516: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20517: LD_ADDR_EXP 64
20521: PUSH
20522: LD_EXP 64
20526: PPUSH
20527: LD_VAR 0 2
20531: PPUSH
20532: EMPTY
20533: PPUSH
20534: CALL_OW 1
20538: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20539: LD_ADDR_EXP 63
20543: PUSH
20544: LD_EXP 63
20548: PPUSH
20549: LD_VAR 0 2
20553: PPUSH
20554: EMPTY
20555: PPUSH
20556: CALL_OW 1
20560: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20561: LD_ADDR_EXP 65
20565: PUSH
20566: LD_EXP 65
20570: PPUSH
20571: LD_VAR 0 2
20575: PPUSH
20576: EMPTY
20577: PPUSH
20578: CALL_OW 1
20582: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20583: LD_ADDR_EXP 66
20587: PUSH
20588: LD_EXP 66
20592: PPUSH
20593: LD_VAR 0 2
20597: PPUSH
20598: EMPTY
20599: PPUSH
20600: CALL_OW 1
20604: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20605: LD_ADDR_EXP 67
20609: PUSH
20610: LD_EXP 67
20614: PPUSH
20615: LD_VAR 0 2
20619: PPUSH
20620: EMPTY
20621: PPUSH
20622: CALL_OW 1
20626: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20627: LD_ADDR_EXP 68
20631: PUSH
20632: LD_EXP 68
20636: PPUSH
20637: LD_VAR 0 2
20641: PPUSH
20642: EMPTY
20643: PPUSH
20644: CALL_OW 1
20648: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20649: LD_ADDR_EXP 69
20653: PUSH
20654: LD_EXP 69
20658: PPUSH
20659: LD_VAR 0 2
20663: PPUSH
20664: EMPTY
20665: PPUSH
20666: CALL_OW 1
20670: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20671: LD_ADDR_EXP 70
20675: PUSH
20676: LD_EXP 70
20680: PPUSH
20681: LD_VAR 0 2
20685: PPUSH
20686: EMPTY
20687: PPUSH
20688: CALL_OW 1
20692: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20693: LD_ADDR_EXP 71
20697: PUSH
20698: LD_EXP 71
20702: PPUSH
20703: LD_VAR 0 2
20707: PPUSH
20708: EMPTY
20709: PPUSH
20710: CALL_OW 1
20714: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20715: LD_ADDR_EXP 72
20719: PUSH
20720: LD_EXP 72
20724: PPUSH
20725: LD_VAR 0 2
20729: PPUSH
20730: EMPTY
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20737: LD_ADDR_EXP 61
20741: PUSH
20742: LD_EXP 61
20746: PPUSH
20747: LD_VAR 0 2
20751: PPUSH
20752: LD_INT 0
20754: PPUSH
20755: CALL_OW 1
20759: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20760: LD_ADDR_EXP 74
20764: PUSH
20765: LD_EXP 74
20769: PPUSH
20770: LD_VAR 0 2
20774: PPUSH
20775: LD_INT 0
20777: PPUSH
20778: CALL_OW 1
20782: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20783: LD_ADDR_EXP 62
20787: PUSH
20788: LD_EXP 62
20792: PPUSH
20793: LD_VAR 0 2
20797: PPUSH
20798: EMPTY
20799: PPUSH
20800: CALL_OW 1
20804: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20805: LD_ADDR_EXP 73
20809: PUSH
20810: LD_EXP 73
20814: PPUSH
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_INT 0
20822: PPUSH
20823: CALL_OW 1
20827: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20828: LD_ADDR_EXP 75
20832: PUSH
20833: LD_EXP 75
20837: PPUSH
20838: LD_VAR 0 2
20842: PPUSH
20843: EMPTY
20844: PPUSH
20845: CALL_OW 1
20849: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20850: LD_ADDR_EXP 78
20854: PUSH
20855: LD_EXP 78
20859: PPUSH
20860: LD_VAR 0 2
20864: PPUSH
20865: LD_INT 0
20867: PPUSH
20868: CALL_OW 1
20872: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20873: LD_ADDR_EXP 79
20877: PUSH
20878: LD_EXP 79
20882: PPUSH
20883: LD_VAR 0 2
20887: PPUSH
20888: EMPTY
20889: PPUSH
20890: CALL_OW 1
20894: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20895: LD_ADDR_EXP 80
20899: PUSH
20900: LD_EXP 80
20904: PPUSH
20905: LD_VAR 0 2
20909: PPUSH
20910: EMPTY
20911: PPUSH
20912: CALL_OW 1
20916: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20917: LD_ADDR_EXP 81
20921: PUSH
20922: LD_EXP 81
20926: PPUSH
20927: LD_VAR 0 2
20931: PPUSH
20932: EMPTY
20933: PPUSH
20934: CALL_OW 1
20938: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20939: LD_ADDR_EXP 83
20943: PUSH
20944: LD_EXP 83
20948: PPUSH
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_EXP 50
20958: PUSH
20959: LD_VAR 0 2
20963: ARRAY
20964: PPUSH
20965: LD_INT 2
20967: PUSH
20968: LD_INT 30
20970: PUSH
20971: LD_INT 6
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: PUSH
20978: LD_INT 30
20980: PUSH
20981: LD_INT 7
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: PUSH
20988: LD_INT 30
20990: PUSH
20991: LD_INT 8
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: PUSH
20998: EMPTY
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: PPUSH
21004: CALL_OW 72
21008: PPUSH
21009: CALL_OW 1
21013: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21014: LD_ADDR_EXP 84
21018: PUSH
21019: LD_EXP 84
21023: PPUSH
21024: LD_VAR 0 2
21028: PPUSH
21029: EMPTY
21030: PPUSH
21031: CALL_OW 1
21035: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21036: LD_ADDR_EXP 85
21040: PUSH
21041: LD_EXP 85
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: EMPTY
21052: PPUSH
21053: CALL_OW 1
21057: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21058: LD_ADDR_EXP 86
21062: PUSH
21063: LD_EXP 86
21067: PPUSH
21068: LD_VAR 0 2
21072: PPUSH
21073: EMPTY
21074: PPUSH
21075: CALL_OW 1
21079: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21080: LD_ADDR_EXP 87
21084: PUSH
21085: LD_EXP 87
21089: PPUSH
21090: LD_VAR 0 2
21094: PPUSH
21095: EMPTY
21096: PPUSH
21097: CALL_OW 1
21101: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21102: LD_ADDR_EXP 88
21106: PUSH
21107: LD_EXP 88
21111: PPUSH
21112: LD_VAR 0 2
21116: PPUSH
21117: EMPTY
21118: PPUSH
21119: CALL_OW 1
21123: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21124: LD_ADDR_EXP 89
21128: PUSH
21129: LD_EXP 89
21133: PPUSH
21134: LD_VAR 0 2
21138: PPUSH
21139: EMPTY
21140: PPUSH
21141: CALL_OW 1
21145: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21146: LD_ADDR_EXP 90
21150: PUSH
21151: LD_EXP 90
21155: PPUSH
21156: LD_VAR 0 2
21160: PPUSH
21161: EMPTY
21162: PPUSH
21163: CALL_OW 1
21167: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21168: LD_ADDR_EXP 91
21172: PUSH
21173: LD_EXP 91
21177: PPUSH
21178: LD_VAR 0 2
21182: PPUSH
21183: EMPTY
21184: PPUSH
21185: CALL_OW 1
21189: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21190: LD_ADDR_EXP 92
21194: PUSH
21195: LD_EXP 92
21199: PPUSH
21200: LD_VAR 0 2
21204: PPUSH
21205: LD_INT 0
21207: PPUSH
21208: CALL_OW 1
21212: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21213: LD_ADDR_EXP 93
21217: PUSH
21218: LD_EXP 93
21222: PPUSH
21223: LD_VAR 0 2
21227: PPUSH
21228: LD_INT 0
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: GO 20137
21238: POP
21239: POP
// MC_InitSides ( ) ;
21240: CALL 21526 0 0
// MC_InitResearch ( ) ;
21244: CALL 21265 0 0
// CustomInitMacro ( ) ;
21248: CALL 308 0 0
// skirmish := true ;
21252: LD_ADDR_EXP 48
21256: PUSH
21257: LD_INT 1
21259: ST_TO_ADDR
// end ;
21260: LD_VAR 0 1
21264: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21265: LD_INT 0
21267: PPUSH
21268: PPUSH
21269: PPUSH
21270: PPUSH
21271: PPUSH
21272: PPUSH
// if not mc_bases then
21273: LD_EXP 50
21277: NOT
21278: IFFALSE 21282
// exit ;
21280: GO 21521
// for i = 1 to 8 do
21282: LD_ADDR_VAR 0 2
21286: PUSH
21287: DOUBLE
21288: LD_INT 1
21290: DEC
21291: ST_TO_ADDR
21292: LD_INT 8
21294: PUSH
21295: FOR_TO
21296: IFFALSE 21322
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21298: LD_ADDR_EXP 77
21302: PUSH
21303: LD_EXP 77
21307: PPUSH
21308: LD_VAR 0 2
21312: PPUSH
21313: EMPTY
21314: PPUSH
21315: CALL_OW 1
21319: ST_TO_ADDR
21320: GO 21295
21322: POP
21323: POP
// tmp := [ ] ;
21324: LD_ADDR_VAR 0 5
21328: PUSH
21329: EMPTY
21330: ST_TO_ADDR
// for i = 1 to mc_sides do
21331: LD_ADDR_VAR 0 2
21335: PUSH
21336: DOUBLE
21337: LD_INT 1
21339: DEC
21340: ST_TO_ADDR
21341: LD_EXP 76
21345: PUSH
21346: FOR_TO
21347: IFFALSE 21405
// if not mc_sides [ i ] in tmp then
21349: LD_EXP 76
21353: PUSH
21354: LD_VAR 0 2
21358: ARRAY
21359: PUSH
21360: LD_VAR 0 5
21364: IN
21365: NOT
21366: IFFALSE 21403
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21368: LD_ADDR_VAR 0 5
21372: PUSH
21373: LD_VAR 0 5
21377: PPUSH
21378: LD_VAR 0 5
21382: PUSH
21383: LD_INT 1
21385: PLUS
21386: PPUSH
21387: LD_EXP 76
21391: PUSH
21392: LD_VAR 0 2
21396: ARRAY
21397: PPUSH
21398: CALL_OW 2
21402: ST_TO_ADDR
21403: GO 21346
21405: POP
21406: POP
// if not tmp then
21407: LD_VAR 0 5
21411: NOT
21412: IFFALSE 21416
// exit ;
21414: GO 21521
// for j in tmp do
21416: LD_ADDR_VAR 0 3
21420: PUSH
21421: LD_VAR 0 5
21425: PUSH
21426: FOR_IN
21427: IFFALSE 21519
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21429: LD_ADDR_VAR 0 6
21433: PUSH
21434: LD_INT 22
21436: PUSH
21437: LD_VAR 0 3
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: PPUSH
21446: CALL_OW 69
21450: ST_TO_ADDR
// if not un then
21451: LD_VAR 0 6
21455: NOT
21456: IFFALSE 21460
// continue ;
21458: GO 21426
// nation := GetNation ( un [ 1 ] ) ;
21460: LD_ADDR_VAR 0 4
21464: PUSH
21465: LD_VAR 0 6
21469: PUSH
21470: LD_INT 1
21472: ARRAY
21473: PPUSH
21474: CALL_OW 248
21478: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21479: LD_ADDR_EXP 77
21483: PUSH
21484: LD_EXP 77
21488: PPUSH
21489: LD_VAR 0 3
21493: PPUSH
21494: LD_VAR 0 3
21498: PPUSH
21499: LD_VAR 0 4
21503: PPUSH
21504: LD_INT 1
21506: PPUSH
21507: CALL 48642 0 3
21511: PPUSH
21512: CALL_OW 1
21516: ST_TO_ADDR
// end ;
21517: GO 21426
21519: POP
21520: POP
// end ;
21521: LD_VAR 0 1
21525: RET
// export function MC_InitSides ( ) ; var i ; begin
21526: LD_INT 0
21528: PPUSH
21529: PPUSH
// if not mc_bases then
21530: LD_EXP 50
21534: NOT
21535: IFFALSE 21539
// exit ;
21537: GO 21613
// for i = 1 to mc_bases do
21539: LD_ADDR_VAR 0 2
21543: PUSH
21544: DOUBLE
21545: LD_INT 1
21547: DEC
21548: ST_TO_ADDR
21549: LD_EXP 50
21553: PUSH
21554: FOR_TO
21555: IFFALSE 21611
// if mc_bases [ i ] then
21557: LD_EXP 50
21561: PUSH
21562: LD_VAR 0 2
21566: ARRAY
21567: IFFALSE 21609
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21569: LD_ADDR_EXP 76
21573: PUSH
21574: LD_EXP 76
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: LD_EXP 50
21588: PUSH
21589: LD_VAR 0 2
21593: ARRAY
21594: PUSH
21595: LD_INT 1
21597: ARRAY
21598: PPUSH
21599: CALL_OW 255
21603: PPUSH
21604: CALL_OW 1
21608: ST_TO_ADDR
21609: GO 21554
21611: POP
21612: POP
// end ;
21613: LD_VAR 0 1
21617: RET
// every 0 0$03 trigger skirmish do
21618: LD_EXP 48
21622: IFFALSE 21776
21624: GO 21626
21626: DISABLE
// begin enable ;
21627: ENABLE
// MC_CheckBuildings ( ) ;
21628: CALL 26274 0 0
// MC_CheckPeopleLife ( ) ;
21632: CALL 26435 0 0
// RaiseSailEvent ( 100 ) ;
21636: LD_INT 100
21638: PPUSH
21639: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21643: LD_INT 103
21645: PPUSH
21646: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21650: LD_INT 104
21652: PPUSH
21653: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21657: LD_INT 105
21659: PPUSH
21660: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21664: LD_INT 106
21666: PPUSH
21667: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21671: LD_INT 107
21673: PPUSH
21674: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21678: LD_INT 108
21680: PPUSH
21681: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21685: LD_INT 109
21687: PPUSH
21688: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21692: LD_INT 110
21694: PPUSH
21695: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21699: LD_INT 111
21701: PPUSH
21702: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21706: LD_INT 112
21708: PPUSH
21709: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21713: LD_INT 113
21715: PPUSH
21716: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21720: LD_INT 120
21722: PPUSH
21723: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21727: LD_INT 121
21729: PPUSH
21730: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21734: LD_INT 122
21736: PPUSH
21737: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21741: LD_INT 123
21743: PPUSH
21744: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21748: LD_INT 124
21750: PPUSH
21751: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21755: LD_INT 125
21757: PPUSH
21758: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21762: LD_INT 126
21764: PPUSH
21765: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21769: LD_INT 200
21771: PPUSH
21772: CALL_OW 427
// end ;
21776: END
// on SailEvent ( event ) do begin if event < 100 then
21777: LD_VAR 0 1
21781: PUSH
21782: LD_INT 100
21784: LESS
21785: IFFALSE 21796
// CustomEvent ( event ) ;
21787: LD_VAR 0 1
21791: PPUSH
21792: CALL 17139 0 1
// if event = 100 then
21796: LD_VAR 0 1
21800: PUSH
21801: LD_INT 100
21803: EQUAL
21804: IFFALSE 21810
// MC_ClassManager ( ) ;
21806: CALL 22202 0 0
// if event = 101 then
21810: LD_VAR 0 1
21814: PUSH
21815: LD_INT 101
21817: EQUAL
21818: IFFALSE 21824
// MC_RepairBuildings ( ) ;
21820: CALL 27020 0 0
// if event = 102 then
21824: LD_VAR 0 1
21828: PUSH
21829: LD_INT 102
21831: EQUAL
21832: IFFALSE 21838
// MC_Heal ( ) ;
21834: CALL 27927 0 0
// if event = 103 then
21838: LD_VAR 0 1
21842: PUSH
21843: LD_INT 103
21845: EQUAL
21846: IFFALSE 21852
// MC_Build ( ) ;
21848: CALL 28349 0 0
// if event = 104 then
21852: LD_VAR 0 1
21856: PUSH
21857: LD_INT 104
21859: EQUAL
21860: IFFALSE 21866
// MC_TurretWeapon ( ) ;
21862: CALL 29990 0 0
// if event = 105 then
21866: LD_VAR 0 1
21870: PUSH
21871: LD_INT 105
21873: EQUAL
21874: IFFALSE 21880
// MC_BuildUpgrade ( ) ;
21876: CALL 29541 0 0
// if event = 106 then
21880: LD_VAR 0 1
21884: PUSH
21885: LD_INT 106
21887: EQUAL
21888: IFFALSE 21894
// MC_PlantMines ( ) ;
21890: CALL 30420 0 0
// if event = 107 then
21894: LD_VAR 0 1
21898: PUSH
21899: LD_INT 107
21901: EQUAL
21902: IFFALSE 21908
// MC_CollectCrates ( ) ;
21904: CALL 31211 0 0
// if event = 108 then
21908: LD_VAR 0 1
21912: PUSH
21913: LD_INT 108
21915: EQUAL
21916: IFFALSE 21922
// MC_LinkRemoteControl ( ) ;
21918: CALL 33061 0 0
// if event = 109 then
21922: LD_VAR 0 1
21926: PUSH
21927: LD_INT 109
21929: EQUAL
21930: IFFALSE 21936
// MC_ProduceVehicle ( ) ;
21932: CALL 33242 0 0
// if event = 110 then
21936: LD_VAR 0 1
21940: PUSH
21941: LD_INT 110
21943: EQUAL
21944: IFFALSE 21950
// MC_SendAttack ( ) ;
21946: CALL 33708 0 0
// if event = 111 then
21950: LD_VAR 0 1
21954: PUSH
21955: LD_INT 111
21957: EQUAL
21958: IFFALSE 21964
// MC_Defend ( ) ;
21960: CALL 33816 0 0
// if event = 112 then
21964: LD_VAR 0 1
21968: PUSH
21969: LD_INT 112
21971: EQUAL
21972: IFFALSE 21978
// MC_Research ( ) ;
21974: CALL 34696 0 0
// if event = 113 then
21978: LD_VAR 0 1
21982: PUSH
21983: LD_INT 113
21985: EQUAL
21986: IFFALSE 21992
// MC_MinesTrigger ( ) ;
21988: CALL 35810 0 0
// if event = 120 then
21992: LD_VAR 0 1
21996: PUSH
21997: LD_INT 120
21999: EQUAL
22000: IFFALSE 22006
// MC_RepairVehicle ( ) ;
22002: CALL 35909 0 0
// if event = 121 then
22006: LD_VAR 0 1
22010: PUSH
22011: LD_INT 121
22013: EQUAL
22014: IFFALSE 22020
// MC_TameApe ( ) ;
22016: CALL 36650 0 0
// if event = 122 then
22020: LD_VAR 0 1
22024: PUSH
22025: LD_INT 122
22027: EQUAL
22028: IFFALSE 22034
// MC_ChangeApeClass ( ) ;
22030: CALL 37479 0 0
// if event = 123 then
22034: LD_VAR 0 1
22038: PUSH
22039: LD_INT 123
22041: EQUAL
22042: IFFALSE 22048
// MC_Bazooka ( ) ;
22044: CALL 38129 0 0
// if event = 124 then
22048: LD_VAR 0 1
22052: PUSH
22053: LD_INT 124
22055: EQUAL
22056: IFFALSE 22062
// MC_TeleportExit ( ) ;
22058: CALL 38327 0 0
// if event = 125 then
22062: LD_VAR 0 1
22066: PUSH
22067: LD_INT 125
22069: EQUAL
22070: IFFALSE 22076
// MC_Deposits ( ) ;
22072: CALL 38974 0 0
// if event = 126 then
22076: LD_VAR 0 1
22080: PUSH
22081: LD_INT 126
22083: EQUAL
22084: IFFALSE 22090
// MC_RemoteDriver ( ) ;
22086: CALL 39599 0 0
// if event = 200 then
22090: LD_VAR 0 1
22094: PUSH
22095: LD_INT 200
22097: EQUAL
22098: IFFALSE 22104
// MC_Idle ( ) ;
22100: CALL 41548 0 0
// end ;
22104: PPOPN 1
22106: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22107: LD_INT 0
22109: PPUSH
22110: PPUSH
// if not mc_bases [ base ] or not tag then
22111: LD_EXP 50
22115: PUSH
22116: LD_VAR 0 1
22120: ARRAY
22121: NOT
22122: PUSH
22123: LD_VAR 0 2
22127: NOT
22128: OR
22129: IFFALSE 22133
// exit ;
22131: GO 22197
// for i in mc_bases [ base ] union mc_ape [ base ] do
22133: LD_ADDR_VAR 0 4
22137: PUSH
22138: LD_EXP 50
22142: PUSH
22143: LD_VAR 0 1
22147: ARRAY
22148: PUSH
22149: LD_EXP 79
22153: PUSH
22154: LD_VAR 0 1
22158: ARRAY
22159: UNION
22160: PUSH
22161: FOR_IN
22162: IFFALSE 22195
// if GetTag ( i ) = tag then
22164: LD_VAR 0 4
22168: PPUSH
22169: CALL_OW 110
22173: PUSH
22174: LD_VAR 0 2
22178: EQUAL
22179: IFFALSE 22193
// SetTag ( i , 0 ) ;
22181: LD_VAR 0 4
22185: PPUSH
22186: LD_INT 0
22188: PPUSH
22189: CALL_OW 109
22193: GO 22161
22195: POP
22196: POP
// end ;
22197: LD_VAR 0 3
22201: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22202: LD_INT 0
22204: PPUSH
22205: PPUSH
22206: PPUSH
22207: PPUSH
22208: PPUSH
22209: PPUSH
22210: PPUSH
22211: PPUSH
// if not mc_bases then
22212: LD_EXP 50
22216: NOT
22217: IFFALSE 22221
// exit ;
22219: GO 22679
// for i = 1 to mc_bases do
22221: LD_ADDR_VAR 0 2
22225: PUSH
22226: DOUBLE
22227: LD_INT 1
22229: DEC
22230: ST_TO_ADDR
22231: LD_EXP 50
22235: PUSH
22236: FOR_TO
22237: IFFALSE 22677
// begin tmp := MC_ClassCheckReq ( i ) ;
22239: LD_ADDR_VAR 0 4
22243: PUSH
22244: LD_VAR 0 2
22248: PPUSH
22249: CALL 22684 0 1
22253: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22254: LD_ADDR_EXP 91
22258: PUSH
22259: LD_EXP 91
22263: PPUSH
22264: LD_VAR 0 2
22268: PPUSH
22269: LD_VAR 0 4
22273: PPUSH
22274: CALL_OW 1
22278: ST_TO_ADDR
// if not tmp then
22279: LD_VAR 0 4
22283: NOT
22284: IFFALSE 22288
// continue ;
22286: GO 22236
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22288: LD_ADDR_VAR 0 6
22292: PUSH
22293: LD_EXP 50
22297: PUSH
22298: LD_VAR 0 2
22302: ARRAY
22303: PPUSH
22304: LD_INT 2
22306: PUSH
22307: LD_INT 30
22309: PUSH
22310: LD_INT 4
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: PUSH
22317: LD_INT 30
22319: PUSH
22320: LD_INT 5
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: EMPTY
22328: LIST
22329: LIST
22330: LIST
22331: PPUSH
22332: CALL_OW 72
22336: PUSH
22337: LD_EXP 50
22341: PUSH
22342: LD_VAR 0 2
22346: ARRAY
22347: PPUSH
22348: LD_INT 2
22350: PUSH
22351: LD_INT 30
22353: PUSH
22354: LD_INT 0
22356: PUSH
22357: EMPTY
22358: LIST
22359: LIST
22360: PUSH
22361: LD_INT 30
22363: PUSH
22364: LD_INT 1
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: PUSH
22371: EMPTY
22372: LIST
22373: LIST
22374: LIST
22375: PPUSH
22376: CALL_OW 72
22380: PUSH
22381: LD_EXP 50
22385: PUSH
22386: LD_VAR 0 2
22390: ARRAY
22391: PPUSH
22392: LD_INT 30
22394: PUSH
22395: LD_INT 3
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PPUSH
22402: CALL_OW 72
22406: PUSH
22407: LD_EXP 50
22411: PUSH
22412: LD_VAR 0 2
22416: ARRAY
22417: PPUSH
22418: LD_INT 2
22420: PUSH
22421: LD_INT 30
22423: PUSH
22424: LD_INT 6
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: LD_INT 30
22433: PUSH
22434: LD_INT 7
22436: PUSH
22437: EMPTY
22438: LIST
22439: LIST
22440: PUSH
22441: LD_INT 30
22443: PUSH
22444: LD_INT 8
22446: PUSH
22447: EMPTY
22448: LIST
22449: LIST
22450: PUSH
22451: EMPTY
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: PPUSH
22457: CALL_OW 72
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: ST_TO_ADDR
// for j = 1 to 4 do
22468: LD_ADDR_VAR 0 3
22472: PUSH
22473: DOUBLE
22474: LD_INT 1
22476: DEC
22477: ST_TO_ADDR
22478: LD_INT 4
22480: PUSH
22481: FOR_TO
22482: IFFALSE 22673
// begin if not tmp [ j ] then
22484: LD_VAR 0 4
22488: PUSH
22489: LD_VAR 0 3
22493: ARRAY
22494: NOT
22495: IFFALSE 22499
// continue ;
22497: GO 22481
// for p in tmp [ j ] do
22499: LD_ADDR_VAR 0 5
22503: PUSH
22504: LD_VAR 0 4
22508: PUSH
22509: LD_VAR 0 3
22513: ARRAY
22514: PUSH
22515: FOR_IN
22516: IFFALSE 22669
// begin if not b [ j ] then
22518: LD_VAR 0 6
22522: PUSH
22523: LD_VAR 0 3
22527: ARRAY
22528: NOT
22529: IFFALSE 22533
// break ;
22531: GO 22669
// e := 0 ;
22533: LD_ADDR_VAR 0 7
22537: PUSH
22538: LD_INT 0
22540: ST_TO_ADDR
// for k in b [ j ] do
22541: LD_ADDR_VAR 0 8
22545: PUSH
22546: LD_VAR 0 6
22550: PUSH
22551: LD_VAR 0 3
22555: ARRAY
22556: PUSH
22557: FOR_IN
22558: IFFALSE 22585
// if IsNotFull ( k ) then
22560: LD_VAR 0 8
22564: PPUSH
22565: CALL 50795 0 1
22569: IFFALSE 22583
// begin e := k ;
22571: LD_ADDR_VAR 0 7
22575: PUSH
22576: LD_VAR 0 8
22580: ST_TO_ADDR
// break ;
22581: GO 22585
// end ;
22583: GO 22557
22585: POP
22586: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22587: LD_VAR 0 7
22591: PUSH
22592: LD_VAR 0 5
22596: PPUSH
22597: LD_VAR 0 7
22601: PPUSH
22602: CALL 84626 0 2
22606: NOT
22607: AND
22608: IFFALSE 22667
// begin if IsInUnit ( p ) then
22610: LD_VAR 0 5
22614: PPUSH
22615: CALL_OW 310
22619: IFFALSE 22630
// ComExitBuilding ( p ) ;
22621: LD_VAR 0 5
22625: PPUSH
22626: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22630: LD_VAR 0 5
22634: PPUSH
22635: LD_VAR 0 7
22639: PPUSH
22640: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22644: LD_VAR 0 5
22648: PPUSH
22649: LD_VAR 0 3
22653: PPUSH
22654: CALL_OW 183
// AddComExitBuilding ( p ) ;
22658: LD_VAR 0 5
22662: PPUSH
22663: CALL_OW 182
// end ; end ;
22667: GO 22515
22669: POP
22670: POP
// end ;
22671: GO 22481
22673: POP
22674: POP
// end ;
22675: GO 22236
22677: POP
22678: POP
// end ;
22679: LD_VAR 0 1
22683: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22684: LD_INT 0
22686: PPUSH
22687: PPUSH
22688: PPUSH
22689: PPUSH
22690: PPUSH
22691: PPUSH
22692: PPUSH
22693: PPUSH
22694: PPUSH
22695: PPUSH
22696: PPUSH
22697: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22698: LD_VAR 0 1
22702: NOT
22703: PUSH
22704: LD_EXP 50
22708: PUSH
22709: LD_VAR 0 1
22713: ARRAY
22714: NOT
22715: OR
22716: PUSH
22717: LD_EXP 50
22721: PUSH
22722: LD_VAR 0 1
22726: ARRAY
22727: PPUSH
22728: LD_INT 2
22730: PUSH
22731: LD_INT 30
22733: PUSH
22734: LD_INT 0
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 30
22743: PUSH
22744: LD_INT 1
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: LIST
22755: PPUSH
22756: CALL_OW 72
22760: NOT
22761: OR
22762: IFFALSE 22766
// exit ;
22764: GO 26269
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22766: LD_ADDR_VAR 0 4
22770: PUSH
22771: LD_EXP 50
22775: PUSH
22776: LD_VAR 0 1
22780: ARRAY
22781: PPUSH
22782: LD_INT 2
22784: PUSH
22785: LD_INT 25
22787: PUSH
22788: LD_INT 1
22790: PUSH
22791: EMPTY
22792: LIST
22793: LIST
22794: PUSH
22795: LD_INT 25
22797: PUSH
22798: LD_INT 2
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PUSH
22805: LD_INT 25
22807: PUSH
22808: LD_INT 3
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: LD_INT 25
22817: PUSH
22818: LD_INT 4
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: PUSH
22825: LD_INT 25
22827: PUSH
22828: LD_INT 5
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: PUSH
22835: LD_INT 25
22837: PUSH
22838: LD_INT 8
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: PUSH
22845: LD_INT 25
22847: PUSH
22848: LD_INT 9
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PPUSH
22865: CALL_OW 72
22869: ST_TO_ADDR
// if not tmp then
22870: LD_VAR 0 4
22874: NOT
22875: IFFALSE 22879
// exit ;
22877: GO 26269
// for i in tmp do
22879: LD_ADDR_VAR 0 3
22883: PUSH
22884: LD_VAR 0 4
22888: PUSH
22889: FOR_IN
22890: IFFALSE 22921
// if GetTag ( i ) then
22892: LD_VAR 0 3
22896: PPUSH
22897: CALL_OW 110
22901: IFFALSE 22919
// tmp := tmp diff i ;
22903: LD_ADDR_VAR 0 4
22907: PUSH
22908: LD_VAR 0 4
22912: PUSH
22913: LD_VAR 0 3
22917: DIFF
22918: ST_TO_ADDR
22919: GO 22889
22921: POP
22922: POP
// if not tmp then
22923: LD_VAR 0 4
22927: NOT
22928: IFFALSE 22932
// exit ;
22930: GO 26269
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22932: LD_ADDR_VAR 0 5
22936: PUSH
22937: LD_EXP 50
22941: PUSH
22942: LD_VAR 0 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 2
22950: PUSH
22951: LD_INT 25
22953: PUSH
22954: LD_INT 1
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: PUSH
22961: LD_INT 25
22963: PUSH
22964: LD_INT 5
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: LD_INT 25
22973: PUSH
22974: LD_INT 8
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: LD_INT 25
22983: PUSH
22984: LD_INT 9
22986: PUSH
22987: EMPTY
22988: LIST
22989: LIST
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: LIST
22995: LIST
22996: LIST
22997: PPUSH
22998: CALL_OW 72
23002: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23003: LD_ADDR_VAR 0 6
23007: PUSH
23008: LD_EXP 50
23012: PUSH
23013: LD_VAR 0 1
23017: ARRAY
23018: PPUSH
23019: LD_INT 25
23021: PUSH
23022: LD_INT 2
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: PPUSH
23029: CALL_OW 72
23033: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23034: LD_ADDR_VAR 0 7
23038: PUSH
23039: LD_EXP 50
23043: PUSH
23044: LD_VAR 0 1
23048: ARRAY
23049: PPUSH
23050: LD_INT 25
23052: PUSH
23053: LD_INT 3
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PPUSH
23060: CALL_OW 72
23064: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23065: LD_ADDR_VAR 0 8
23069: PUSH
23070: LD_EXP 50
23074: PUSH
23075: LD_VAR 0 1
23079: ARRAY
23080: PPUSH
23081: LD_INT 25
23083: PUSH
23084: LD_INT 4
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: PUSH
23091: LD_INT 24
23093: PUSH
23094: LD_INT 251
23096: PUSH
23097: EMPTY
23098: LIST
23099: LIST
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: PPUSH
23105: CALL_OW 72
23109: ST_TO_ADDR
// if mc_is_defending [ base ] then
23110: LD_EXP 93
23114: PUSH
23115: LD_VAR 0 1
23119: ARRAY
23120: IFFALSE 23581
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23122: LD_ADDR_EXP 92
23126: PUSH
23127: LD_EXP 92
23131: PPUSH
23132: LD_VAR 0 1
23136: PPUSH
23137: LD_INT 4
23139: PPUSH
23140: CALL_OW 1
23144: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23145: LD_ADDR_VAR 0 12
23149: PUSH
23150: LD_EXP 50
23154: PUSH
23155: LD_VAR 0 1
23159: ARRAY
23160: PPUSH
23161: LD_INT 2
23163: PUSH
23164: LD_INT 30
23166: PUSH
23167: LD_INT 4
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: PUSH
23174: LD_INT 30
23176: PUSH
23177: LD_INT 5
23179: PUSH
23180: EMPTY
23181: LIST
23182: LIST
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: LIST
23188: PPUSH
23189: CALL_OW 72
23193: ST_TO_ADDR
// if not b then
23194: LD_VAR 0 12
23198: NOT
23199: IFFALSE 23203
// exit ;
23201: GO 26269
// p := [ ] ;
23203: LD_ADDR_VAR 0 11
23207: PUSH
23208: EMPTY
23209: ST_TO_ADDR
// if sci >= 2 then
23210: LD_VAR 0 8
23214: PUSH
23215: LD_INT 2
23217: GREATEREQUAL
23218: IFFALSE 23249
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23220: LD_ADDR_VAR 0 8
23224: PUSH
23225: LD_VAR 0 8
23229: PUSH
23230: LD_INT 1
23232: ARRAY
23233: PUSH
23234: LD_VAR 0 8
23238: PUSH
23239: LD_INT 2
23241: ARRAY
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: ST_TO_ADDR
23247: GO 23310
// if sci = 1 then
23249: LD_VAR 0 8
23253: PUSH
23254: LD_INT 1
23256: EQUAL
23257: IFFALSE 23278
// sci := [ sci [ 1 ] ] else
23259: LD_ADDR_VAR 0 8
23263: PUSH
23264: LD_VAR 0 8
23268: PUSH
23269: LD_INT 1
23271: ARRAY
23272: PUSH
23273: EMPTY
23274: LIST
23275: ST_TO_ADDR
23276: GO 23310
// if sci = 0 then
23278: LD_VAR 0 8
23282: PUSH
23283: LD_INT 0
23285: EQUAL
23286: IFFALSE 23310
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23288: LD_ADDR_VAR 0 11
23292: PUSH
23293: LD_VAR 0 4
23297: PPUSH
23298: LD_INT 4
23300: PPUSH
23301: CALL 84489 0 2
23305: PUSH
23306: LD_INT 1
23308: ARRAY
23309: ST_TO_ADDR
// if eng > 4 then
23310: LD_VAR 0 6
23314: PUSH
23315: LD_INT 4
23317: GREATER
23318: IFFALSE 23364
// for i = eng downto 4 do
23320: LD_ADDR_VAR 0 3
23324: PUSH
23325: DOUBLE
23326: LD_VAR 0 6
23330: INC
23331: ST_TO_ADDR
23332: LD_INT 4
23334: PUSH
23335: FOR_DOWNTO
23336: IFFALSE 23362
// eng := eng diff eng [ i ] ;
23338: LD_ADDR_VAR 0 6
23342: PUSH
23343: LD_VAR 0 6
23347: PUSH
23348: LD_VAR 0 6
23352: PUSH
23353: LD_VAR 0 3
23357: ARRAY
23358: DIFF
23359: ST_TO_ADDR
23360: GO 23335
23362: POP
23363: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23364: LD_ADDR_VAR 0 4
23368: PUSH
23369: LD_VAR 0 4
23373: PUSH
23374: LD_VAR 0 5
23378: PUSH
23379: LD_VAR 0 6
23383: UNION
23384: PUSH
23385: LD_VAR 0 7
23389: UNION
23390: PUSH
23391: LD_VAR 0 8
23395: UNION
23396: DIFF
23397: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23398: LD_ADDR_VAR 0 13
23402: PUSH
23403: LD_EXP 50
23407: PUSH
23408: LD_VAR 0 1
23412: ARRAY
23413: PPUSH
23414: LD_INT 2
23416: PUSH
23417: LD_INT 30
23419: PUSH
23420: LD_INT 32
23422: PUSH
23423: EMPTY
23424: LIST
23425: LIST
23426: PUSH
23427: LD_INT 30
23429: PUSH
23430: LD_INT 31
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: LIST
23441: PPUSH
23442: CALL_OW 72
23446: PUSH
23447: LD_EXP 50
23451: PUSH
23452: LD_VAR 0 1
23456: ARRAY
23457: PPUSH
23458: LD_INT 2
23460: PUSH
23461: LD_INT 30
23463: PUSH
23464: LD_INT 4
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PUSH
23471: LD_INT 30
23473: PUSH
23474: LD_INT 5
23476: PUSH
23477: EMPTY
23478: LIST
23479: LIST
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: LIST
23485: PPUSH
23486: CALL_OW 72
23490: PUSH
23491: LD_INT 6
23493: MUL
23494: PLUS
23495: ST_TO_ADDR
// if bcount < tmp then
23496: LD_VAR 0 13
23500: PUSH
23501: LD_VAR 0 4
23505: LESS
23506: IFFALSE 23552
// for i = tmp downto bcount do
23508: LD_ADDR_VAR 0 3
23512: PUSH
23513: DOUBLE
23514: LD_VAR 0 4
23518: INC
23519: ST_TO_ADDR
23520: LD_VAR 0 13
23524: PUSH
23525: FOR_DOWNTO
23526: IFFALSE 23550
// tmp := Delete ( tmp , tmp ) ;
23528: LD_ADDR_VAR 0 4
23532: PUSH
23533: LD_VAR 0 4
23537: PPUSH
23538: LD_VAR 0 4
23542: PPUSH
23543: CALL_OW 3
23547: ST_TO_ADDR
23548: GO 23525
23550: POP
23551: POP
// result := [ tmp , 0 , 0 , p ] ;
23552: LD_ADDR_VAR 0 2
23556: PUSH
23557: LD_VAR 0 4
23561: PUSH
23562: LD_INT 0
23564: PUSH
23565: LD_INT 0
23567: PUSH
23568: LD_VAR 0 11
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: ST_TO_ADDR
// exit ;
23579: GO 26269
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23581: LD_EXP 50
23585: PUSH
23586: LD_VAR 0 1
23590: ARRAY
23591: PPUSH
23592: LD_INT 2
23594: PUSH
23595: LD_INT 30
23597: PUSH
23598: LD_INT 6
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: PUSH
23605: LD_INT 30
23607: PUSH
23608: LD_INT 7
23610: PUSH
23611: EMPTY
23612: LIST
23613: LIST
23614: PUSH
23615: LD_INT 30
23617: PUSH
23618: LD_INT 8
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: PUSH
23625: EMPTY
23626: LIST
23627: LIST
23628: LIST
23629: LIST
23630: PPUSH
23631: CALL_OW 72
23635: NOT
23636: PUSH
23637: LD_EXP 50
23641: PUSH
23642: LD_VAR 0 1
23646: ARRAY
23647: PPUSH
23648: LD_INT 30
23650: PUSH
23651: LD_INT 3
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PPUSH
23658: CALL_OW 72
23662: NOT
23663: AND
23664: IFFALSE 23736
// begin if eng = tmp then
23666: LD_VAR 0 6
23670: PUSH
23671: LD_VAR 0 4
23675: EQUAL
23676: IFFALSE 23680
// exit ;
23678: GO 26269
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23680: LD_ADDR_EXP 92
23684: PUSH
23685: LD_EXP 92
23689: PPUSH
23690: LD_VAR 0 1
23694: PPUSH
23695: LD_INT 1
23697: PPUSH
23698: CALL_OW 1
23702: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23703: LD_ADDR_VAR 0 2
23707: PUSH
23708: LD_INT 0
23710: PUSH
23711: LD_VAR 0 4
23715: PUSH
23716: LD_VAR 0 6
23720: DIFF
23721: PUSH
23722: LD_INT 0
23724: PUSH
23725: LD_INT 0
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: ST_TO_ADDR
// exit ;
23734: GO 26269
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23736: LD_EXP 77
23740: PUSH
23741: LD_EXP 76
23745: PUSH
23746: LD_VAR 0 1
23750: ARRAY
23751: ARRAY
23752: PUSH
23753: LD_EXP 50
23757: PUSH
23758: LD_VAR 0 1
23762: ARRAY
23763: PPUSH
23764: LD_INT 2
23766: PUSH
23767: LD_INT 30
23769: PUSH
23770: LD_INT 6
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: PUSH
23777: LD_INT 30
23779: PUSH
23780: LD_INT 7
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PUSH
23787: LD_INT 30
23789: PUSH
23790: LD_INT 8
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: LIST
23801: LIST
23802: PPUSH
23803: CALL_OW 72
23807: AND
23808: PUSH
23809: LD_EXP 50
23813: PUSH
23814: LD_VAR 0 1
23818: ARRAY
23819: PPUSH
23820: LD_INT 30
23822: PUSH
23823: LD_INT 3
23825: PUSH
23826: EMPTY
23827: LIST
23828: LIST
23829: PPUSH
23830: CALL_OW 72
23834: NOT
23835: AND
23836: IFFALSE 24050
// begin if sci >= 6 then
23838: LD_VAR 0 8
23842: PUSH
23843: LD_INT 6
23845: GREATEREQUAL
23846: IFFALSE 23850
// exit ;
23848: GO 26269
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23850: LD_ADDR_EXP 92
23854: PUSH
23855: LD_EXP 92
23859: PPUSH
23860: LD_VAR 0 1
23864: PPUSH
23865: LD_INT 2
23867: PPUSH
23868: CALL_OW 1
23872: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23873: LD_ADDR_VAR 0 9
23877: PUSH
23878: LD_VAR 0 4
23882: PUSH
23883: LD_VAR 0 8
23887: DIFF
23888: PPUSH
23889: LD_INT 4
23891: PPUSH
23892: CALL 84489 0 2
23896: ST_TO_ADDR
// p := [ ] ;
23897: LD_ADDR_VAR 0 11
23901: PUSH
23902: EMPTY
23903: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23904: LD_VAR 0 8
23908: PUSH
23909: LD_INT 6
23911: LESS
23912: PUSH
23913: LD_VAR 0 9
23917: PUSH
23918: LD_INT 6
23920: GREATER
23921: AND
23922: IFFALSE 24003
// begin for i = 1 to 6 - sci do
23924: LD_ADDR_VAR 0 3
23928: PUSH
23929: DOUBLE
23930: LD_INT 1
23932: DEC
23933: ST_TO_ADDR
23934: LD_INT 6
23936: PUSH
23937: LD_VAR 0 8
23941: MINUS
23942: PUSH
23943: FOR_TO
23944: IFFALSE 23999
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23946: LD_ADDR_VAR 0 11
23950: PUSH
23951: LD_VAR 0 11
23955: PPUSH
23956: LD_VAR 0 11
23960: PUSH
23961: LD_INT 1
23963: PLUS
23964: PPUSH
23965: LD_VAR 0 9
23969: PUSH
23970: LD_INT 1
23972: ARRAY
23973: PPUSH
23974: CALL_OW 2
23978: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23979: LD_ADDR_VAR 0 9
23983: PUSH
23984: LD_VAR 0 9
23988: PPUSH
23989: LD_INT 1
23991: PPUSH
23992: CALL_OW 3
23996: ST_TO_ADDR
// end ;
23997: GO 23943
23999: POP
24000: POP
// end else
24001: GO 24023
// if sort then
24003: LD_VAR 0 9
24007: IFFALSE 24023
// p := sort [ 1 ] ;
24009: LD_ADDR_VAR 0 11
24013: PUSH
24014: LD_VAR 0 9
24018: PUSH
24019: LD_INT 1
24021: ARRAY
24022: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24023: LD_ADDR_VAR 0 2
24027: PUSH
24028: LD_INT 0
24030: PUSH
24031: LD_INT 0
24033: PUSH
24034: LD_INT 0
24036: PUSH
24037: LD_VAR 0 11
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: LIST
24047: ST_TO_ADDR
// exit ;
24048: GO 26269
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24050: LD_EXP 77
24054: PUSH
24055: LD_EXP 76
24059: PUSH
24060: LD_VAR 0 1
24064: ARRAY
24065: ARRAY
24066: PUSH
24067: LD_EXP 50
24071: PUSH
24072: LD_VAR 0 1
24076: ARRAY
24077: PPUSH
24078: LD_INT 2
24080: PUSH
24081: LD_INT 30
24083: PUSH
24084: LD_INT 6
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: PUSH
24091: LD_INT 30
24093: PUSH
24094: LD_INT 7
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: PUSH
24101: LD_INT 30
24103: PUSH
24104: LD_INT 8
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: PUSH
24111: EMPTY
24112: LIST
24113: LIST
24114: LIST
24115: LIST
24116: PPUSH
24117: CALL_OW 72
24121: AND
24122: PUSH
24123: LD_EXP 50
24127: PUSH
24128: LD_VAR 0 1
24132: ARRAY
24133: PPUSH
24134: LD_INT 30
24136: PUSH
24137: LD_INT 3
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PPUSH
24144: CALL_OW 72
24148: AND
24149: IFFALSE 24883
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24151: LD_ADDR_EXP 92
24155: PUSH
24156: LD_EXP 92
24160: PPUSH
24161: LD_VAR 0 1
24165: PPUSH
24166: LD_INT 3
24168: PPUSH
24169: CALL_OW 1
24173: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24174: LD_ADDR_VAR 0 2
24178: PUSH
24179: LD_INT 0
24181: PUSH
24182: LD_INT 0
24184: PUSH
24185: LD_INT 0
24187: PUSH
24188: LD_INT 0
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: LIST
24195: LIST
24196: ST_TO_ADDR
// if not eng then
24197: LD_VAR 0 6
24201: NOT
24202: IFFALSE 24265
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24204: LD_ADDR_VAR 0 11
24208: PUSH
24209: LD_VAR 0 4
24213: PPUSH
24214: LD_INT 2
24216: PPUSH
24217: CALL 84489 0 2
24221: PUSH
24222: LD_INT 1
24224: ARRAY
24225: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24226: LD_ADDR_VAR 0 2
24230: PUSH
24231: LD_VAR 0 2
24235: PPUSH
24236: LD_INT 2
24238: PPUSH
24239: LD_VAR 0 11
24243: PPUSH
24244: CALL_OW 1
24248: ST_TO_ADDR
// tmp := tmp diff p ;
24249: LD_ADDR_VAR 0 4
24253: PUSH
24254: LD_VAR 0 4
24258: PUSH
24259: LD_VAR 0 11
24263: DIFF
24264: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24265: LD_VAR 0 4
24269: PUSH
24270: LD_VAR 0 8
24274: PUSH
24275: LD_INT 6
24277: LESS
24278: AND
24279: IFFALSE 24467
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24281: LD_ADDR_VAR 0 9
24285: PUSH
24286: LD_VAR 0 4
24290: PUSH
24291: LD_VAR 0 8
24295: PUSH
24296: LD_VAR 0 7
24300: UNION
24301: DIFF
24302: PPUSH
24303: LD_INT 4
24305: PPUSH
24306: CALL 84489 0 2
24310: ST_TO_ADDR
// p := [ ] ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: EMPTY
24317: ST_TO_ADDR
// if sort then
24318: LD_VAR 0 9
24322: IFFALSE 24438
// for i = 1 to 6 - sci do
24324: LD_ADDR_VAR 0 3
24328: PUSH
24329: DOUBLE
24330: LD_INT 1
24332: DEC
24333: ST_TO_ADDR
24334: LD_INT 6
24336: PUSH
24337: LD_VAR 0 8
24341: MINUS
24342: PUSH
24343: FOR_TO
24344: IFFALSE 24436
// begin if i = sort then
24346: LD_VAR 0 3
24350: PUSH
24351: LD_VAR 0 9
24355: EQUAL
24356: IFFALSE 24360
// break ;
24358: GO 24436
// if GetClass ( i ) = 4 then
24360: LD_VAR 0 3
24364: PPUSH
24365: CALL_OW 257
24369: PUSH
24370: LD_INT 4
24372: EQUAL
24373: IFFALSE 24377
// continue ;
24375: GO 24343
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24377: LD_ADDR_VAR 0 11
24381: PUSH
24382: LD_VAR 0 11
24386: PPUSH
24387: LD_VAR 0 11
24391: PUSH
24392: LD_INT 1
24394: PLUS
24395: PPUSH
24396: LD_VAR 0 9
24400: PUSH
24401: LD_VAR 0 3
24405: ARRAY
24406: PPUSH
24407: CALL_OW 2
24411: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24412: LD_ADDR_VAR 0 4
24416: PUSH
24417: LD_VAR 0 4
24421: PUSH
24422: LD_VAR 0 9
24426: PUSH
24427: LD_VAR 0 3
24431: ARRAY
24432: DIFF
24433: ST_TO_ADDR
// end ;
24434: GO 24343
24436: POP
24437: POP
// if p then
24438: LD_VAR 0 11
24442: IFFALSE 24467
// result := Replace ( result , 4 , p ) ;
24444: LD_ADDR_VAR 0 2
24448: PUSH
24449: LD_VAR 0 2
24453: PPUSH
24454: LD_INT 4
24456: PPUSH
24457: LD_VAR 0 11
24461: PPUSH
24462: CALL_OW 1
24466: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24467: LD_VAR 0 4
24471: PUSH
24472: LD_VAR 0 7
24476: PUSH
24477: LD_INT 6
24479: LESS
24480: AND
24481: IFFALSE 24669
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24483: LD_ADDR_VAR 0 9
24487: PUSH
24488: LD_VAR 0 4
24492: PUSH
24493: LD_VAR 0 8
24497: PUSH
24498: LD_VAR 0 7
24502: UNION
24503: DIFF
24504: PPUSH
24505: LD_INT 3
24507: PPUSH
24508: CALL 84489 0 2
24512: ST_TO_ADDR
// p := [ ] ;
24513: LD_ADDR_VAR 0 11
24517: PUSH
24518: EMPTY
24519: ST_TO_ADDR
// if sort then
24520: LD_VAR 0 9
24524: IFFALSE 24640
// for i = 1 to 6 - mech do
24526: LD_ADDR_VAR 0 3
24530: PUSH
24531: DOUBLE
24532: LD_INT 1
24534: DEC
24535: ST_TO_ADDR
24536: LD_INT 6
24538: PUSH
24539: LD_VAR 0 7
24543: MINUS
24544: PUSH
24545: FOR_TO
24546: IFFALSE 24638
// begin if i = sort then
24548: LD_VAR 0 3
24552: PUSH
24553: LD_VAR 0 9
24557: EQUAL
24558: IFFALSE 24562
// break ;
24560: GO 24638
// if GetClass ( i ) = 3 then
24562: LD_VAR 0 3
24566: PPUSH
24567: CALL_OW 257
24571: PUSH
24572: LD_INT 3
24574: EQUAL
24575: IFFALSE 24579
// continue ;
24577: GO 24545
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24579: LD_ADDR_VAR 0 11
24583: PUSH
24584: LD_VAR 0 11
24588: PPUSH
24589: LD_VAR 0 11
24593: PUSH
24594: LD_INT 1
24596: PLUS
24597: PPUSH
24598: LD_VAR 0 9
24602: PUSH
24603: LD_VAR 0 3
24607: ARRAY
24608: PPUSH
24609: CALL_OW 2
24613: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24614: LD_ADDR_VAR 0 4
24618: PUSH
24619: LD_VAR 0 4
24623: PUSH
24624: LD_VAR 0 9
24628: PUSH
24629: LD_VAR 0 3
24633: ARRAY
24634: DIFF
24635: ST_TO_ADDR
// end ;
24636: GO 24545
24638: POP
24639: POP
// if p then
24640: LD_VAR 0 11
24644: IFFALSE 24669
// result := Replace ( result , 3 , p ) ;
24646: LD_ADDR_VAR 0 2
24650: PUSH
24651: LD_VAR 0 2
24655: PPUSH
24656: LD_INT 3
24658: PPUSH
24659: LD_VAR 0 11
24663: PPUSH
24664: CALL_OW 1
24668: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24669: LD_VAR 0 4
24673: PUSH
24674: LD_INT 6
24676: GREATER
24677: PUSH
24678: LD_VAR 0 6
24682: PUSH
24683: LD_INT 6
24685: LESS
24686: AND
24687: IFFALSE 24881
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24689: LD_ADDR_VAR 0 9
24693: PUSH
24694: LD_VAR 0 4
24698: PUSH
24699: LD_VAR 0 8
24703: PUSH
24704: LD_VAR 0 7
24708: UNION
24709: PUSH
24710: LD_VAR 0 6
24714: UNION
24715: DIFF
24716: PPUSH
24717: LD_INT 2
24719: PPUSH
24720: CALL 84489 0 2
24724: ST_TO_ADDR
// p := [ ] ;
24725: LD_ADDR_VAR 0 11
24729: PUSH
24730: EMPTY
24731: ST_TO_ADDR
// if sort then
24732: LD_VAR 0 9
24736: IFFALSE 24852
// for i = 1 to 6 - eng do
24738: LD_ADDR_VAR 0 3
24742: PUSH
24743: DOUBLE
24744: LD_INT 1
24746: DEC
24747: ST_TO_ADDR
24748: LD_INT 6
24750: PUSH
24751: LD_VAR 0 6
24755: MINUS
24756: PUSH
24757: FOR_TO
24758: IFFALSE 24850
// begin if i = sort then
24760: LD_VAR 0 3
24764: PUSH
24765: LD_VAR 0 9
24769: EQUAL
24770: IFFALSE 24774
// break ;
24772: GO 24850
// if GetClass ( i ) = 2 then
24774: LD_VAR 0 3
24778: PPUSH
24779: CALL_OW 257
24783: PUSH
24784: LD_INT 2
24786: EQUAL
24787: IFFALSE 24791
// continue ;
24789: GO 24757
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24791: LD_ADDR_VAR 0 11
24795: PUSH
24796: LD_VAR 0 11
24800: PPUSH
24801: LD_VAR 0 11
24805: PUSH
24806: LD_INT 1
24808: PLUS
24809: PPUSH
24810: LD_VAR 0 9
24814: PUSH
24815: LD_VAR 0 3
24819: ARRAY
24820: PPUSH
24821: CALL_OW 2
24825: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24826: LD_ADDR_VAR 0 4
24830: PUSH
24831: LD_VAR 0 4
24835: PUSH
24836: LD_VAR 0 9
24840: PUSH
24841: LD_VAR 0 3
24845: ARRAY
24846: DIFF
24847: ST_TO_ADDR
// end ;
24848: GO 24757
24850: POP
24851: POP
// if p then
24852: LD_VAR 0 11
24856: IFFALSE 24881
// result := Replace ( result , 2 , p ) ;
24858: LD_ADDR_VAR 0 2
24862: PUSH
24863: LD_VAR 0 2
24867: PPUSH
24868: LD_INT 2
24870: PPUSH
24871: LD_VAR 0 11
24875: PPUSH
24876: CALL_OW 1
24880: ST_TO_ADDR
// end ; exit ;
24881: GO 26269
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24883: LD_EXP 77
24887: PUSH
24888: LD_EXP 76
24892: PUSH
24893: LD_VAR 0 1
24897: ARRAY
24898: ARRAY
24899: NOT
24900: PUSH
24901: LD_EXP 50
24905: PUSH
24906: LD_VAR 0 1
24910: ARRAY
24911: PPUSH
24912: LD_INT 30
24914: PUSH
24915: LD_INT 3
24917: PUSH
24918: EMPTY
24919: LIST
24920: LIST
24921: PPUSH
24922: CALL_OW 72
24926: AND
24927: PUSH
24928: LD_EXP 55
24932: PUSH
24933: LD_VAR 0 1
24937: ARRAY
24938: AND
24939: IFFALSE 25547
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24941: LD_ADDR_EXP 92
24945: PUSH
24946: LD_EXP 92
24950: PPUSH
24951: LD_VAR 0 1
24955: PPUSH
24956: LD_INT 5
24958: PPUSH
24959: CALL_OW 1
24963: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24964: LD_ADDR_VAR 0 2
24968: PUSH
24969: LD_INT 0
24971: PUSH
24972: LD_INT 0
24974: PUSH
24975: LD_INT 0
24977: PUSH
24978: LD_INT 0
24980: PUSH
24981: EMPTY
24982: LIST
24983: LIST
24984: LIST
24985: LIST
24986: ST_TO_ADDR
// if sci > 1 then
24987: LD_VAR 0 8
24991: PUSH
24992: LD_INT 1
24994: GREATER
24995: IFFALSE 25023
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24997: LD_ADDR_VAR 0 4
25001: PUSH
25002: LD_VAR 0 4
25006: PUSH
25007: LD_VAR 0 8
25011: PUSH
25012: LD_VAR 0 8
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: DIFF
25021: DIFF
25022: ST_TO_ADDR
// if tmp and not sci then
25023: LD_VAR 0 4
25027: PUSH
25028: LD_VAR 0 8
25032: NOT
25033: AND
25034: IFFALSE 25103
// begin sort := SortBySkill ( tmp , 4 ) ;
25036: LD_ADDR_VAR 0 9
25040: PUSH
25041: LD_VAR 0 4
25045: PPUSH
25046: LD_INT 4
25048: PPUSH
25049: CALL 84489 0 2
25053: ST_TO_ADDR
// if sort then
25054: LD_VAR 0 9
25058: IFFALSE 25074
// p := sort [ 1 ] ;
25060: LD_ADDR_VAR 0 11
25064: PUSH
25065: LD_VAR 0 9
25069: PUSH
25070: LD_INT 1
25072: ARRAY
25073: ST_TO_ADDR
// if p then
25074: LD_VAR 0 11
25078: IFFALSE 25103
// result := Replace ( result , 4 , p ) ;
25080: LD_ADDR_VAR 0 2
25084: PUSH
25085: LD_VAR 0 2
25089: PPUSH
25090: LD_INT 4
25092: PPUSH
25093: LD_VAR 0 11
25097: PPUSH
25098: CALL_OW 1
25102: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25103: LD_ADDR_VAR 0 4
25107: PUSH
25108: LD_VAR 0 4
25112: PUSH
25113: LD_VAR 0 7
25117: DIFF
25118: ST_TO_ADDR
// if tmp and mech < 6 then
25119: LD_VAR 0 4
25123: PUSH
25124: LD_VAR 0 7
25128: PUSH
25129: LD_INT 6
25131: LESS
25132: AND
25133: IFFALSE 25321
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25135: LD_ADDR_VAR 0 9
25139: PUSH
25140: LD_VAR 0 4
25144: PUSH
25145: LD_VAR 0 8
25149: PUSH
25150: LD_VAR 0 7
25154: UNION
25155: DIFF
25156: PPUSH
25157: LD_INT 3
25159: PPUSH
25160: CALL 84489 0 2
25164: ST_TO_ADDR
// p := [ ] ;
25165: LD_ADDR_VAR 0 11
25169: PUSH
25170: EMPTY
25171: ST_TO_ADDR
// if sort then
25172: LD_VAR 0 9
25176: IFFALSE 25292
// for i = 1 to 6 - mech do
25178: LD_ADDR_VAR 0 3
25182: PUSH
25183: DOUBLE
25184: LD_INT 1
25186: DEC
25187: ST_TO_ADDR
25188: LD_INT 6
25190: PUSH
25191: LD_VAR 0 7
25195: MINUS
25196: PUSH
25197: FOR_TO
25198: IFFALSE 25290
// begin if i = sort then
25200: LD_VAR 0 3
25204: PUSH
25205: LD_VAR 0 9
25209: EQUAL
25210: IFFALSE 25214
// break ;
25212: GO 25290
// if GetClass ( i ) = 3 then
25214: LD_VAR 0 3
25218: PPUSH
25219: CALL_OW 257
25223: PUSH
25224: LD_INT 3
25226: EQUAL
25227: IFFALSE 25231
// continue ;
25229: GO 25197
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25231: LD_ADDR_VAR 0 11
25235: PUSH
25236: LD_VAR 0 11
25240: PPUSH
25241: LD_VAR 0 11
25245: PUSH
25246: LD_INT 1
25248: PLUS
25249: PPUSH
25250: LD_VAR 0 9
25254: PUSH
25255: LD_VAR 0 3
25259: ARRAY
25260: PPUSH
25261: CALL_OW 2
25265: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25266: LD_ADDR_VAR 0 4
25270: PUSH
25271: LD_VAR 0 4
25275: PUSH
25276: LD_VAR 0 9
25280: PUSH
25281: LD_VAR 0 3
25285: ARRAY
25286: DIFF
25287: ST_TO_ADDR
// end ;
25288: GO 25197
25290: POP
25291: POP
// if p then
25292: LD_VAR 0 11
25296: IFFALSE 25321
// result := Replace ( result , 3 , p ) ;
25298: LD_ADDR_VAR 0 2
25302: PUSH
25303: LD_VAR 0 2
25307: PPUSH
25308: LD_INT 3
25310: PPUSH
25311: LD_VAR 0 11
25315: PPUSH
25316: CALL_OW 1
25320: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25321: LD_ADDR_VAR 0 4
25325: PUSH
25326: LD_VAR 0 4
25330: PUSH
25331: LD_VAR 0 6
25335: DIFF
25336: ST_TO_ADDR
// if tmp and eng < 6 then
25337: LD_VAR 0 4
25341: PUSH
25342: LD_VAR 0 6
25346: PUSH
25347: LD_INT 6
25349: LESS
25350: AND
25351: IFFALSE 25545
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25353: LD_ADDR_VAR 0 9
25357: PUSH
25358: LD_VAR 0 4
25362: PUSH
25363: LD_VAR 0 8
25367: PUSH
25368: LD_VAR 0 7
25372: UNION
25373: PUSH
25374: LD_VAR 0 6
25378: UNION
25379: DIFF
25380: PPUSH
25381: LD_INT 2
25383: PPUSH
25384: CALL 84489 0 2
25388: ST_TO_ADDR
// p := [ ] ;
25389: LD_ADDR_VAR 0 11
25393: PUSH
25394: EMPTY
25395: ST_TO_ADDR
// if sort then
25396: LD_VAR 0 9
25400: IFFALSE 25516
// for i = 1 to 6 - eng do
25402: LD_ADDR_VAR 0 3
25406: PUSH
25407: DOUBLE
25408: LD_INT 1
25410: DEC
25411: ST_TO_ADDR
25412: LD_INT 6
25414: PUSH
25415: LD_VAR 0 6
25419: MINUS
25420: PUSH
25421: FOR_TO
25422: IFFALSE 25514
// begin if i = sort then
25424: LD_VAR 0 3
25428: PUSH
25429: LD_VAR 0 9
25433: EQUAL
25434: IFFALSE 25438
// break ;
25436: GO 25514
// if GetClass ( i ) = 2 then
25438: LD_VAR 0 3
25442: PPUSH
25443: CALL_OW 257
25447: PUSH
25448: LD_INT 2
25450: EQUAL
25451: IFFALSE 25455
// continue ;
25453: GO 25421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25455: LD_ADDR_VAR 0 11
25459: PUSH
25460: LD_VAR 0 11
25464: PPUSH
25465: LD_VAR 0 11
25469: PUSH
25470: LD_INT 1
25472: PLUS
25473: PPUSH
25474: LD_VAR 0 9
25478: PUSH
25479: LD_VAR 0 3
25483: ARRAY
25484: PPUSH
25485: CALL_OW 2
25489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25490: LD_ADDR_VAR 0 4
25494: PUSH
25495: LD_VAR 0 4
25499: PUSH
25500: LD_VAR 0 9
25504: PUSH
25505: LD_VAR 0 3
25509: ARRAY
25510: DIFF
25511: ST_TO_ADDR
// end ;
25512: GO 25421
25514: POP
25515: POP
// if p then
25516: LD_VAR 0 11
25520: IFFALSE 25545
// result := Replace ( result , 2 , p ) ;
25522: LD_ADDR_VAR 0 2
25526: PUSH
25527: LD_VAR 0 2
25531: PPUSH
25532: LD_INT 2
25534: PPUSH
25535: LD_VAR 0 11
25539: PPUSH
25540: CALL_OW 1
25544: ST_TO_ADDR
// end ; exit ;
25545: GO 26269
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25547: LD_EXP 77
25551: PUSH
25552: LD_EXP 76
25556: PUSH
25557: LD_VAR 0 1
25561: ARRAY
25562: ARRAY
25563: NOT
25564: PUSH
25565: LD_EXP 50
25569: PUSH
25570: LD_VAR 0 1
25574: ARRAY
25575: PPUSH
25576: LD_INT 30
25578: PUSH
25579: LD_INT 3
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PPUSH
25586: CALL_OW 72
25590: AND
25591: PUSH
25592: LD_EXP 55
25596: PUSH
25597: LD_VAR 0 1
25601: ARRAY
25602: NOT
25603: AND
25604: IFFALSE 26269
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25606: LD_ADDR_EXP 92
25610: PUSH
25611: LD_EXP 92
25615: PPUSH
25616: LD_VAR 0 1
25620: PPUSH
25621: LD_INT 6
25623: PPUSH
25624: CALL_OW 1
25628: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25629: LD_ADDR_VAR 0 2
25633: PUSH
25634: LD_INT 0
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 0
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: LIST
25650: LIST
25651: ST_TO_ADDR
// if sci >= 1 then
25652: LD_VAR 0 8
25656: PUSH
25657: LD_INT 1
25659: GREATEREQUAL
25660: IFFALSE 25682
// tmp := tmp diff sci [ 1 ] ;
25662: LD_ADDR_VAR 0 4
25666: PUSH
25667: LD_VAR 0 4
25671: PUSH
25672: LD_VAR 0 8
25676: PUSH
25677: LD_INT 1
25679: ARRAY
25680: DIFF
25681: ST_TO_ADDR
// if tmp and not sci then
25682: LD_VAR 0 4
25686: PUSH
25687: LD_VAR 0 8
25691: NOT
25692: AND
25693: IFFALSE 25762
// begin sort := SortBySkill ( tmp , 4 ) ;
25695: LD_ADDR_VAR 0 9
25699: PUSH
25700: LD_VAR 0 4
25704: PPUSH
25705: LD_INT 4
25707: PPUSH
25708: CALL 84489 0 2
25712: ST_TO_ADDR
// if sort then
25713: LD_VAR 0 9
25717: IFFALSE 25733
// p := sort [ 1 ] ;
25719: LD_ADDR_VAR 0 11
25723: PUSH
25724: LD_VAR 0 9
25728: PUSH
25729: LD_INT 1
25731: ARRAY
25732: ST_TO_ADDR
// if p then
25733: LD_VAR 0 11
25737: IFFALSE 25762
// result := Replace ( result , 4 , p ) ;
25739: LD_ADDR_VAR 0 2
25743: PUSH
25744: LD_VAR 0 2
25748: PPUSH
25749: LD_INT 4
25751: PPUSH
25752: LD_VAR 0 11
25756: PPUSH
25757: CALL_OW 1
25761: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25762: LD_ADDR_VAR 0 4
25766: PUSH
25767: LD_VAR 0 4
25771: PUSH
25772: LD_VAR 0 7
25776: DIFF
25777: ST_TO_ADDR
// if tmp and mech < 6 then
25778: LD_VAR 0 4
25782: PUSH
25783: LD_VAR 0 7
25787: PUSH
25788: LD_INT 6
25790: LESS
25791: AND
25792: IFFALSE 25974
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25794: LD_ADDR_VAR 0 9
25798: PUSH
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 7
25808: DIFF
25809: PPUSH
25810: LD_INT 3
25812: PPUSH
25813: CALL 84489 0 2
25817: ST_TO_ADDR
// p := [ ] ;
25818: LD_ADDR_VAR 0 11
25822: PUSH
25823: EMPTY
25824: ST_TO_ADDR
// if sort then
25825: LD_VAR 0 9
25829: IFFALSE 25945
// for i = 1 to 6 - mech do
25831: LD_ADDR_VAR 0 3
25835: PUSH
25836: DOUBLE
25837: LD_INT 1
25839: DEC
25840: ST_TO_ADDR
25841: LD_INT 6
25843: PUSH
25844: LD_VAR 0 7
25848: MINUS
25849: PUSH
25850: FOR_TO
25851: IFFALSE 25943
// begin if i = sort then
25853: LD_VAR 0 3
25857: PUSH
25858: LD_VAR 0 9
25862: EQUAL
25863: IFFALSE 25867
// break ;
25865: GO 25943
// if GetClass ( i ) = 3 then
25867: LD_VAR 0 3
25871: PPUSH
25872: CALL_OW 257
25876: PUSH
25877: LD_INT 3
25879: EQUAL
25880: IFFALSE 25884
// continue ;
25882: GO 25850
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25884: LD_ADDR_VAR 0 11
25888: PUSH
25889: LD_VAR 0 11
25893: PPUSH
25894: LD_VAR 0 11
25898: PUSH
25899: LD_INT 1
25901: PLUS
25902: PPUSH
25903: LD_VAR 0 9
25907: PUSH
25908: LD_VAR 0 3
25912: ARRAY
25913: PPUSH
25914: CALL_OW 2
25918: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25919: LD_ADDR_VAR 0 4
25923: PUSH
25924: LD_VAR 0 4
25928: PUSH
25929: LD_VAR 0 9
25933: PUSH
25934: LD_VAR 0 3
25938: ARRAY
25939: DIFF
25940: ST_TO_ADDR
// end ;
25941: GO 25850
25943: POP
25944: POP
// if p then
25945: LD_VAR 0 11
25949: IFFALSE 25974
// result := Replace ( result , 3 , p ) ;
25951: LD_ADDR_VAR 0 2
25955: PUSH
25956: LD_VAR 0 2
25960: PPUSH
25961: LD_INT 3
25963: PPUSH
25964: LD_VAR 0 11
25968: PPUSH
25969: CALL_OW 1
25973: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25974: LD_ADDR_VAR 0 4
25978: PUSH
25979: LD_VAR 0 4
25983: PUSH
25984: LD_VAR 0 6
25988: DIFF
25989: ST_TO_ADDR
// if tmp and eng < 4 then
25990: LD_VAR 0 4
25994: PUSH
25995: LD_VAR 0 6
25999: PUSH
26000: LD_INT 4
26002: LESS
26003: AND
26004: IFFALSE 26194
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26006: LD_ADDR_VAR 0 9
26010: PUSH
26011: LD_VAR 0 4
26015: PUSH
26016: LD_VAR 0 7
26020: PUSH
26021: LD_VAR 0 6
26025: UNION
26026: DIFF
26027: PPUSH
26028: LD_INT 2
26030: PPUSH
26031: CALL 84489 0 2
26035: ST_TO_ADDR
// p := [ ] ;
26036: LD_ADDR_VAR 0 11
26040: PUSH
26041: EMPTY
26042: ST_TO_ADDR
// if sort then
26043: LD_VAR 0 9
26047: IFFALSE 26163
// for i = 1 to 4 - eng do
26049: LD_ADDR_VAR 0 3
26053: PUSH
26054: DOUBLE
26055: LD_INT 1
26057: DEC
26058: ST_TO_ADDR
26059: LD_INT 4
26061: PUSH
26062: LD_VAR 0 6
26066: MINUS
26067: PUSH
26068: FOR_TO
26069: IFFALSE 26161
// begin if i = sort then
26071: LD_VAR 0 3
26075: PUSH
26076: LD_VAR 0 9
26080: EQUAL
26081: IFFALSE 26085
// break ;
26083: GO 26161
// if GetClass ( i ) = 2 then
26085: LD_VAR 0 3
26089: PPUSH
26090: CALL_OW 257
26094: PUSH
26095: LD_INT 2
26097: EQUAL
26098: IFFALSE 26102
// continue ;
26100: GO 26068
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26102: LD_ADDR_VAR 0 11
26106: PUSH
26107: LD_VAR 0 11
26111: PPUSH
26112: LD_VAR 0 11
26116: PUSH
26117: LD_INT 1
26119: PLUS
26120: PPUSH
26121: LD_VAR 0 9
26125: PUSH
26126: LD_VAR 0 3
26130: ARRAY
26131: PPUSH
26132: CALL_OW 2
26136: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26137: LD_ADDR_VAR 0 4
26141: PUSH
26142: LD_VAR 0 4
26146: PUSH
26147: LD_VAR 0 9
26151: PUSH
26152: LD_VAR 0 3
26156: ARRAY
26157: DIFF
26158: ST_TO_ADDR
// end ;
26159: GO 26068
26161: POP
26162: POP
// if p then
26163: LD_VAR 0 11
26167: IFFALSE 26192
// result := Replace ( result , 2 , p ) ;
26169: LD_ADDR_VAR 0 2
26173: PUSH
26174: LD_VAR 0 2
26178: PPUSH
26179: LD_INT 2
26181: PPUSH
26182: LD_VAR 0 11
26186: PPUSH
26187: CALL_OW 1
26191: ST_TO_ADDR
// end else
26192: GO 26238
// for i = eng downto 5 do
26194: LD_ADDR_VAR 0 3
26198: PUSH
26199: DOUBLE
26200: LD_VAR 0 6
26204: INC
26205: ST_TO_ADDR
26206: LD_INT 5
26208: PUSH
26209: FOR_DOWNTO
26210: IFFALSE 26236
// tmp := tmp union eng [ i ] ;
26212: LD_ADDR_VAR 0 4
26216: PUSH
26217: LD_VAR 0 4
26221: PUSH
26222: LD_VAR 0 6
26226: PUSH
26227: LD_VAR 0 3
26231: ARRAY
26232: UNION
26233: ST_TO_ADDR
26234: GO 26209
26236: POP
26237: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26238: LD_ADDR_VAR 0 2
26242: PUSH
26243: LD_VAR 0 2
26247: PPUSH
26248: LD_INT 1
26250: PPUSH
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 5
26260: DIFF
26261: PPUSH
26262: CALL_OW 1
26266: ST_TO_ADDR
// exit ;
26267: GO 26269
// end ; end ;
26269: LD_VAR 0 2
26273: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26274: LD_INT 0
26276: PPUSH
26277: PPUSH
26278: PPUSH
// if not mc_bases then
26279: LD_EXP 50
26283: NOT
26284: IFFALSE 26288
// exit ;
26286: GO 26430
// for i = 1 to mc_bases do
26288: LD_ADDR_VAR 0 2
26292: PUSH
26293: DOUBLE
26294: LD_INT 1
26296: DEC
26297: ST_TO_ADDR
26298: LD_EXP 50
26302: PUSH
26303: FOR_TO
26304: IFFALSE 26421
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26306: LD_ADDR_VAR 0 3
26310: PUSH
26311: LD_EXP 50
26315: PUSH
26316: LD_VAR 0 2
26320: ARRAY
26321: PPUSH
26322: LD_INT 21
26324: PUSH
26325: LD_INT 3
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 3
26334: PUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 29
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 30
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: LIST
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 3
26369: PUSH
26370: LD_INT 24
26372: PUSH
26373: LD_INT 1000
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: LIST
26388: PPUSH
26389: CALL_OW 72
26393: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26394: LD_ADDR_EXP 51
26398: PUSH
26399: LD_EXP 51
26403: PPUSH
26404: LD_VAR 0 2
26408: PPUSH
26409: LD_VAR 0 3
26413: PPUSH
26414: CALL_OW 1
26418: ST_TO_ADDR
// end ;
26419: GO 26303
26421: POP
26422: POP
// RaiseSailEvent ( 101 ) ;
26423: LD_INT 101
26425: PPUSH
26426: CALL_OW 427
// end ;
26430: LD_VAR 0 1
26434: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26435: LD_INT 0
26437: PPUSH
26438: PPUSH
26439: PPUSH
26440: PPUSH
26441: PPUSH
26442: PPUSH
26443: PPUSH
// if not mc_bases then
26444: LD_EXP 50
26448: NOT
26449: IFFALSE 26453
// exit ;
26451: GO 27015
// for i = 1 to mc_bases do
26453: LD_ADDR_VAR 0 2
26457: PUSH
26458: DOUBLE
26459: LD_INT 1
26461: DEC
26462: ST_TO_ADDR
26463: LD_EXP 50
26467: PUSH
26468: FOR_TO
26469: IFFALSE 27006
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26471: LD_ADDR_VAR 0 5
26475: PUSH
26476: LD_EXP 50
26480: PUSH
26481: LD_VAR 0 2
26485: ARRAY
26486: PUSH
26487: LD_EXP 79
26491: PUSH
26492: LD_VAR 0 2
26496: ARRAY
26497: UNION
26498: PPUSH
26499: LD_INT 21
26501: PUSH
26502: LD_INT 1
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: LD_INT 3
26514: PUSH
26515: LD_INT 54
26517: PUSH
26518: EMPTY
26519: LIST
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PUSH
26525: LD_INT 3
26527: PUSH
26528: LD_INT 24
26530: PUSH
26531: LD_INT 1000
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PUSH
26538: EMPTY
26539: LIST
26540: LIST
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: LIST
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PPUSH
26551: CALL_OW 72
26555: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26556: LD_ADDR_VAR 0 6
26560: PUSH
26561: LD_EXP 50
26565: PUSH
26566: LD_VAR 0 2
26570: ARRAY
26571: PPUSH
26572: LD_INT 21
26574: PUSH
26575: LD_INT 1
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 1
26584: PUSH
26585: LD_INT 3
26587: PUSH
26588: LD_INT 54
26590: PUSH
26591: EMPTY
26592: LIST
26593: PUSH
26594: EMPTY
26595: LIST
26596: LIST
26597: PUSH
26598: LD_INT 3
26600: PUSH
26601: LD_INT 24
26603: PUSH
26604: LD_INT 250
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: LIST
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PPUSH
26624: CALL_OW 72
26628: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26629: LD_ADDR_VAR 0 7
26633: PUSH
26634: LD_VAR 0 5
26638: PUSH
26639: LD_VAR 0 6
26643: DIFF
26644: ST_TO_ADDR
// if not need_heal_1 then
26645: LD_VAR 0 6
26649: NOT
26650: IFFALSE 26683
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26652: LD_ADDR_EXP 53
26656: PUSH
26657: LD_EXP 53
26661: PPUSH
26662: LD_VAR 0 2
26666: PUSH
26667: LD_INT 1
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PPUSH
26674: EMPTY
26675: PPUSH
26676: CALL 53718 0 3
26680: ST_TO_ADDR
26681: GO 26753
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26683: LD_ADDR_EXP 53
26687: PUSH
26688: LD_EXP 53
26692: PPUSH
26693: LD_VAR 0 2
26697: PUSH
26698: LD_INT 1
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PPUSH
26705: LD_EXP 53
26709: PUSH
26710: LD_VAR 0 2
26714: ARRAY
26715: PUSH
26716: LD_INT 1
26718: ARRAY
26719: PPUSH
26720: LD_INT 3
26722: PUSH
26723: LD_INT 24
26725: PUSH
26726: LD_INT 1000
26728: PUSH
26729: EMPTY
26730: LIST
26731: LIST
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PPUSH
26737: CALL_OW 72
26741: PUSH
26742: LD_VAR 0 6
26746: UNION
26747: PPUSH
26748: CALL 53718 0 3
26752: ST_TO_ADDR
// if not need_heal_2 then
26753: LD_VAR 0 7
26757: NOT
26758: IFFALSE 26791
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26760: LD_ADDR_EXP 53
26764: PUSH
26765: LD_EXP 53
26769: PPUSH
26770: LD_VAR 0 2
26774: PUSH
26775: LD_INT 2
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PPUSH
26782: EMPTY
26783: PPUSH
26784: CALL 53718 0 3
26788: ST_TO_ADDR
26789: GO 26823
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26791: LD_ADDR_EXP 53
26795: PUSH
26796: LD_EXP 53
26800: PPUSH
26801: LD_VAR 0 2
26805: PUSH
26806: LD_INT 2
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PPUSH
26813: LD_VAR 0 7
26817: PPUSH
26818: CALL 53718 0 3
26822: ST_TO_ADDR
// if need_heal_2 then
26823: LD_VAR 0 7
26827: IFFALSE 26988
// for j in need_heal_2 do
26829: LD_ADDR_VAR 0 3
26833: PUSH
26834: LD_VAR 0 7
26838: PUSH
26839: FOR_IN
26840: IFFALSE 26986
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26842: LD_ADDR_VAR 0 5
26846: PUSH
26847: LD_EXP 50
26851: PUSH
26852: LD_VAR 0 2
26856: ARRAY
26857: PPUSH
26858: LD_INT 2
26860: PUSH
26861: LD_INT 30
26863: PUSH
26864: LD_INT 6
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 30
26873: PUSH
26874: LD_INT 7
26876: PUSH
26877: EMPTY
26878: LIST
26879: LIST
26880: PUSH
26881: LD_INT 30
26883: PUSH
26884: LD_INT 8
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 30
26893: PUSH
26894: LD_INT 0
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 30
26903: PUSH
26904: LD_INT 1
26906: PUSH
26907: EMPTY
26908: LIST
26909: LIST
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: LIST
26916: LIST
26917: LIST
26918: PPUSH
26919: CALL_OW 72
26923: ST_TO_ADDR
// if tmp then
26924: LD_VAR 0 5
26928: IFFALSE 26984
// begin k := NearestUnitToUnit ( tmp , j ) ;
26930: LD_ADDR_VAR 0 4
26934: PUSH
26935: LD_VAR 0 5
26939: PPUSH
26940: LD_VAR 0 3
26944: PPUSH
26945: CALL_OW 74
26949: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26950: LD_VAR 0 3
26954: PPUSH
26955: LD_VAR 0 4
26959: PPUSH
26960: CALL_OW 296
26964: PUSH
26965: LD_INT 5
26967: GREATER
26968: IFFALSE 26984
// ComMoveToNearbyEntrance ( j , k ) ;
26970: LD_VAR 0 3
26974: PPUSH
26975: LD_VAR 0 4
26979: PPUSH
26980: CALL 86857 0 2
// end ; end ;
26984: GO 26839
26986: POP
26987: POP
// if not need_heal_1 and not need_heal_2 then
26988: LD_VAR 0 6
26992: NOT
26993: PUSH
26994: LD_VAR 0 7
26998: NOT
26999: AND
27000: IFFALSE 27004
// continue ;
27002: GO 26468
// end ;
27004: GO 26468
27006: POP
27007: POP
// RaiseSailEvent ( 102 ) ;
27008: LD_INT 102
27010: PPUSH
27011: CALL_OW 427
// end ;
27015: LD_VAR 0 1
27019: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27020: LD_INT 0
27022: PPUSH
27023: PPUSH
27024: PPUSH
27025: PPUSH
27026: PPUSH
27027: PPUSH
27028: PPUSH
27029: PPUSH
// if not mc_bases then
27030: LD_EXP 50
27034: NOT
27035: IFFALSE 27039
// exit ;
27037: GO 27922
// for i = 1 to mc_bases do
27039: LD_ADDR_VAR 0 2
27043: PUSH
27044: DOUBLE
27045: LD_INT 1
27047: DEC
27048: ST_TO_ADDR
27049: LD_EXP 50
27053: PUSH
27054: FOR_TO
27055: IFFALSE 27920
// begin if not mc_building_need_repair [ i ] then
27057: LD_EXP 51
27061: PUSH
27062: LD_VAR 0 2
27066: ARRAY
27067: NOT
27068: IFFALSE 27255
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27070: LD_ADDR_VAR 0 6
27074: PUSH
27075: LD_EXP 69
27079: PUSH
27080: LD_VAR 0 2
27084: ARRAY
27085: PPUSH
27086: LD_INT 3
27088: PUSH
27089: LD_INT 24
27091: PUSH
27092: LD_INT 1000
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: PUSH
27103: LD_INT 2
27105: PUSH
27106: LD_INT 34
27108: PUSH
27109: LD_INT 13
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 34
27118: PUSH
27119: LD_INT 52
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: PUSH
27126: LD_INT 34
27128: PUSH
27129: LD_EXP 100
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: LIST
27142: LIST
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PPUSH
27148: CALL_OW 72
27152: ST_TO_ADDR
// if cranes then
27153: LD_VAR 0 6
27157: IFFALSE 27219
// for j in cranes do
27159: LD_ADDR_VAR 0 3
27163: PUSH
27164: LD_VAR 0 6
27168: PUSH
27169: FOR_IN
27170: IFFALSE 27217
// if not IsInArea ( j , mc_parking [ i ] ) then
27172: LD_VAR 0 3
27176: PPUSH
27177: LD_EXP 74
27181: PUSH
27182: LD_VAR 0 2
27186: ARRAY
27187: PPUSH
27188: CALL_OW 308
27192: NOT
27193: IFFALSE 27215
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27195: LD_VAR 0 3
27199: PPUSH
27200: LD_EXP 74
27204: PUSH
27205: LD_VAR 0 2
27209: ARRAY
27210: PPUSH
27211: CALL_OW 113
27215: GO 27169
27217: POP
27218: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27219: LD_ADDR_EXP 52
27223: PUSH
27224: LD_EXP 52
27228: PPUSH
27229: LD_VAR 0 2
27233: PPUSH
27234: EMPTY
27235: PPUSH
27236: CALL_OW 1
27240: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27241: LD_VAR 0 2
27245: PPUSH
27246: LD_INT 101
27248: PPUSH
27249: CALL 22107 0 2
// continue ;
27253: GO 27054
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27255: LD_ADDR_EXP 56
27259: PUSH
27260: LD_EXP 56
27264: PPUSH
27265: LD_VAR 0 2
27269: PPUSH
27270: EMPTY
27271: PPUSH
27272: CALL_OW 1
27276: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27277: LD_VAR 0 2
27281: PPUSH
27282: LD_INT 103
27284: PPUSH
27285: CALL 22107 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27289: LD_ADDR_VAR 0 5
27293: PUSH
27294: LD_EXP 50
27298: PUSH
27299: LD_VAR 0 2
27303: ARRAY
27304: PUSH
27305: LD_EXP 79
27309: PUSH
27310: LD_VAR 0 2
27314: ARRAY
27315: UNION
27316: PPUSH
27317: LD_INT 2
27319: PUSH
27320: LD_INT 25
27322: PUSH
27323: LD_INT 2
27325: PUSH
27326: EMPTY
27327: LIST
27328: LIST
27329: PUSH
27330: LD_INT 25
27332: PUSH
27333: LD_INT 16
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: LIST
27344: PUSH
27345: EMPTY
27346: LIST
27347: PPUSH
27348: CALL_OW 72
27352: ST_TO_ADDR
// if mc_need_heal [ i ] then
27353: LD_EXP 53
27357: PUSH
27358: LD_VAR 0 2
27362: ARRAY
27363: IFFALSE 27407
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27365: LD_ADDR_VAR 0 5
27369: PUSH
27370: LD_VAR 0 5
27374: PUSH
27375: LD_EXP 53
27379: PUSH
27380: LD_VAR 0 2
27384: ARRAY
27385: PUSH
27386: LD_INT 1
27388: ARRAY
27389: PUSH
27390: LD_EXP 53
27394: PUSH
27395: LD_VAR 0 2
27399: ARRAY
27400: PUSH
27401: LD_INT 2
27403: ARRAY
27404: UNION
27405: DIFF
27406: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27407: LD_ADDR_VAR 0 6
27411: PUSH
27412: LD_EXP 69
27416: PUSH
27417: LD_VAR 0 2
27421: ARRAY
27422: PPUSH
27423: LD_INT 2
27425: PUSH
27426: LD_INT 34
27428: PUSH
27429: LD_INT 13
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 34
27438: PUSH
27439: LD_INT 52
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PUSH
27446: LD_INT 34
27448: PUSH
27449: LD_EXP 100
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: LIST
27462: LIST
27463: PPUSH
27464: CALL_OW 72
27468: ST_TO_ADDR
// if cranes then
27469: LD_VAR 0 6
27473: IFFALSE 27609
// begin for j in cranes do
27475: LD_ADDR_VAR 0 3
27479: PUSH
27480: LD_VAR 0 6
27484: PUSH
27485: FOR_IN
27486: IFFALSE 27607
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27488: LD_VAR 0 3
27492: PPUSH
27493: CALL_OW 256
27497: PUSH
27498: LD_INT 1000
27500: EQUAL
27501: PUSH
27502: LD_VAR 0 3
27506: PPUSH
27507: CALL_OW 314
27511: NOT
27512: AND
27513: IFFALSE 27547
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27515: LD_VAR 0 3
27519: PPUSH
27520: LD_EXP 51
27524: PUSH
27525: LD_VAR 0 2
27529: ARRAY
27530: PPUSH
27531: LD_VAR 0 3
27535: PPUSH
27536: CALL_OW 74
27540: PPUSH
27541: CALL_OW 130
27545: GO 27605
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27547: LD_VAR 0 3
27551: PPUSH
27552: CALL_OW 256
27556: PUSH
27557: LD_INT 500
27559: LESS
27560: PUSH
27561: LD_VAR 0 3
27565: PPUSH
27566: LD_EXP 74
27570: PUSH
27571: LD_VAR 0 2
27575: ARRAY
27576: PPUSH
27577: CALL_OW 308
27581: NOT
27582: AND
27583: IFFALSE 27605
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27585: LD_VAR 0 3
27589: PPUSH
27590: LD_EXP 74
27594: PUSH
27595: LD_VAR 0 2
27599: ARRAY
27600: PPUSH
27601: CALL_OW 113
// end ;
27605: GO 27485
27607: POP
27608: POP
// end ; if tmp > 3 then
27609: LD_VAR 0 5
27613: PUSH
27614: LD_INT 3
27616: GREATER
27617: IFFALSE 27637
// tmp := ShrinkArray ( tmp , 4 ) ;
27619: LD_ADDR_VAR 0 5
27623: PUSH
27624: LD_VAR 0 5
27628: PPUSH
27629: LD_INT 4
27631: PPUSH
27632: CALL 86295 0 2
27636: ST_TO_ADDR
// if not tmp then
27637: LD_VAR 0 5
27641: NOT
27642: IFFALSE 27646
// continue ;
27644: GO 27054
// for j in tmp do
27646: LD_ADDR_VAR 0 3
27650: PUSH
27651: LD_VAR 0 5
27655: PUSH
27656: FOR_IN
27657: IFFALSE 27916
// begin if IsInUnit ( j ) then
27659: LD_VAR 0 3
27663: PPUSH
27664: CALL_OW 310
27668: IFFALSE 27679
// ComExitBuilding ( j ) ;
27670: LD_VAR 0 3
27674: PPUSH
27675: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27679: LD_VAR 0 3
27683: PUSH
27684: LD_EXP 52
27688: PUSH
27689: LD_VAR 0 2
27693: ARRAY
27694: IN
27695: NOT
27696: IFFALSE 27754
// begin SetTag ( j , 101 ) ;
27698: LD_VAR 0 3
27702: PPUSH
27703: LD_INT 101
27705: PPUSH
27706: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27710: LD_ADDR_EXP 52
27714: PUSH
27715: LD_EXP 52
27719: PPUSH
27720: LD_VAR 0 2
27724: PUSH
27725: LD_EXP 52
27729: PUSH
27730: LD_VAR 0 2
27734: ARRAY
27735: PUSH
27736: LD_INT 1
27738: PLUS
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PPUSH
27744: LD_VAR 0 3
27748: PPUSH
27749: CALL 53718 0 3
27753: ST_TO_ADDR
// end ; wait ( 1 ) ;
27754: LD_INT 1
27756: PPUSH
27757: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27761: LD_ADDR_VAR 0 7
27765: PUSH
27766: LD_EXP 51
27770: PUSH
27771: LD_VAR 0 2
27775: ARRAY
27776: ST_TO_ADDR
// if mc_scan [ i ] then
27777: LD_EXP 73
27781: PUSH
27782: LD_VAR 0 2
27786: ARRAY
27787: IFFALSE 27849
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27789: LD_ADDR_VAR 0 7
27793: PUSH
27794: LD_EXP 51
27798: PUSH
27799: LD_VAR 0 2
27803: ARRAY
27804: PPUSH
27805: LD_INT 3
27807: PUSH
27808: LD_INT 30
27810: PUSH
27811: LD_INT 32
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 30
27820: PUSH
27821: LD_INT 33
27823: PUSH
27824: EMPTY
27825: LIST
27826: LIST
27827: PUSH
27828: LD_INT 30
27830: PUSH
27831: LD_INT 31
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: PPUSH
27844: CALL_OW 72
27848: ST_TO_ADDR
// if not to_repair_tmp then
27849: LD_VAR 0 7
27853: NOT
27854: IFFALSE 27858
// continue ;
27856: GO 27656
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27858: LD_ADDR_VAR 0 8
27862: PUSH
27863: LD_VAR 0 7
27867: PPUSH
27868: LD_VAR 0 3
27872: PPUSH
27873: CALL_OW 74
27877: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27878: LD_VAR 0 8
27882: PPUSH
27883: LD_INT 16
27885: PPUSH
27886: CALL 56317 0 2
27890: PUSH
27891: LD_INT 4
27893: ARRAY
27894: PUSH
27895: LD_INT 10
27897: LESS
27898: IFFALSE 27914
// ComRepairBuilding ( j , to_repair ) ;
27900: LD_VAR 0 3
27904: PPUSH
27905: LD_VAR 0 8
27909: PPUSH
27910: CALL_OW 130
// end ;
27914: GO 27656
27916: POP
27917: POP
// end ;
27918: GO 27054
27920: POP
27921: POP
// end ;
27922: LD_VAR 0 1
27926: RET
// export function MC_Heal ; var i , j , tmp ; begin
27927: LD_INT 0
27929: PPUSH
27930: PPUSH
27931: PPUSH
27932: PPUSH
// if not mc_bases then
27933: LD_EXP 50
27937: NOT
27938: IFFALSE 27942
// exit ;
27940: GO 28344
// for i = 1 to mc_bases do
27942: LD_ADDR_VAR 0 2
27946: PUSH
27947: DOUBLE
27948: LD_INT 1
27950: DEC
27951: ST_TO_ADDR
27952: LD_EXP 50
27956: PUSH
27957: FOR_TO
27958: IFFALSE 28342
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27960: LD_EXP 53
27964: PUSH
27965: LD_VAR 0 2
27969: ARRAY
27970: PUSH
27971: LD_INT 1
27973: ARRAY
27974: NOT
27975: PUSH
27976: LD_EXP 53
27980: PUSH
27981: LD_VAR 0 2
27985: ARRAY
27986: PUSH
27987: LD_INT 2
27989: ARRAY
27990: NOT
27991: AND
27992: IFFALSE 28030
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27994: LD_ADDR_EXP 54
27998: PUSH
27999: LD_EXP 54
28003: PPUSH
28004: LD_VAR 0 2
28008: PPUSH
28009: EMPTY
28010: PPUSH
28011: CALL_OW 1
28015: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28016: LD_VAR 0 2
28020: PPUSH
28021: LD_INT 102
28023: PPUSH
28024: CALL 22107 0 2
// continue ;
28028: GO 27957
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28030: LD_ADDR_VAR 0 4
28034: PUSH
28035: LD_EXP 50
28039: PUSH
28040: LD_VAR 0 2
28044: ARRAY
28045: PPUSH
28046: LD_INT 25
28048: PUSH
28049: LD_INT 4
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PPUSH
28056: CALL_OW 72
28060: ST_TO_ADDR
// if not tmp then
28061: LD_VAR 0 4
28065: NOT
28066: IFFALSE 28070
// continue ;
28068: GO 27957
// if mc_taming [ i ] then
28070: LD_EXP 81
28074: PUSH
28075: LD_VAR 0 2
28079: ARRAY
28080: IFFALSE 28104
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28082: LD_ADDR_EXP 81
28086: PUSH
28087: LD_EXP 81
28091: PPUSH
28092: LD_VAR 0 2
28096: PPUSH
28097: EMPTY
28098: PPUSH
28099: CALL_OW 1
28103: ST_TO_ADDR
// for j in tmp do
28104: LD_ADDR_VAR 0 3
28108: PUSH
28109: LD_VAR 0 4
28113: PUSH
28114: FOR_IN
28115: IFFALSE 28338
// begin if IsInUnit ( j ) then
28117: LD_VAR 0 3
28121: PPUSH
28122: CALL_OW 310
28126: IFFALSE 28137
// ComExitBuilding ( j ) ;
28128: LD_VAR 0 3
28132: PPUSH
28133: CALL_OW 122
// if not j in mc_healers [ i ] then
28137: LD_VAR 0 3
28141: PUSH
28142: LD_EXP 54
28146: PUSH
28147: LD_VAR 0 2
28151: ARRAY
28152: IN
28153: NOT
28154: IFFALSE 28200
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28156: LD_ADDR_EXP 54
28160: PUSH
28161: LD_EXP 54
28165: PPUSH
28166: LD_VAR 0 2
28170: PUSH
28171: LD_EXP 54
28175: PUSH
28176: LD_VAR 0 2
28180: ARRAY
28181: PUSH
28182: LD_INT 1
28184: PLUS
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: PPUSH
28190: LD_VAR 0 3
28194: PPUSH
28195: CALL 53718 0 3
28199: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28200: LD_VAR 0 3
28204: PPUSH
28205: CALL_OW 110
28209: PUSH
28210: LD_INT 102
28212: NONEQUAL
28213: IFFALSE 28227
// SetTag ( j , 102 ) ;
28215: LD_VAR 0 3
28219: PPUSH
28220: LD_INT 102
28222: PPUSH
28223: CALL_OW 109
// Wait ( 3 ) ;
28227: LD_INT 3
28229: PPUSH
28230: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28234: LD_EXP 53
28238: PUSH
28239: LD_VAR 0 2
28243: ARRAY
28244: PUSH
28245: LD_INT 1
28247: ARRAY
28248: IFFALSE 28280
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28250: LD_VAR 0 3
28254: PPUSH
28255: LD_EXP 53
28259: PUSH
28260: LD_VAR 0 2
28264: ARRAY
28265: PUSH
28266: LD_INT 1
28268: ARRAY
28269: PUSH
28270: LD_INT 1
28272: ARRAY
28273: PPUSH
28274: CALL_OW 128
28278: GO 28336
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28280: LD_VAR 0 3
28284: PPUSH
28285: CALL_OW 314
28289: NOT
28290: PUSH
28291: LD_EXP 53
28295: PUSH
28296: LD_VAR 0 2
28300: ARRAY
28301: PUSH
28302: LD_INT 2
28304: ARRAY
28305: AND
28306: IFFALSE 28336
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28308: LD_VAR 0 3
28312: PPUSH
28313: LD_EXP 53
28317: PUSH
28318: LD_VAR 0 2
28322: ARRAY
28323: PUSH
28324: LD_INT 2
28326: ARRAY
28327: PUSH
28328: LD_INT 1
28330: ARRAY
28331: PPUSH
28332: CALL_OW 128
// end ;
28336: GO 28114
28338: POP
28339: POP
// end ;
28340: GO 27957
28342: POP
28343: POP
// end ;
28344: LD_VAR 0 1
28348: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28349: LD_INT 0
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
// if not mc_bases then
28356: LD_EXP 50
28360: NOT
28361: IFFALSE 28365
// exit ;
28363: GO 29536
// for i = 1 to mc_bases do
28365: LD_ADDR_VAR 0 2
28369: PUSH
28370: DOUBLE
28371: LD_INT 1
28373: DEC
28374: ST_TO_ADDR
28375: LD_EXP 50
28379: PUSH
28380: FOR_TO
28381: IFFALSE 29534
// begin if mc_scan [ i ] then
28383: LD_EXP 73
28387: PUSH
28388: LD_VAR 0 2
28392: ARRAY
28393: IFFALSE 28397
// continue ;
28395: GO 28380
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28397: LD_EXP 55
28401: PUSH
28402: LD_VAR 0 2
28406: ARRAY
28407: NOT
28408: PUSH
28409: LD_EXP 57
28413: PUSH
28414: LD_VAR 0 2
28418: ARRAY
28419: NOT
28420: AND
28421: PUSH
28422: LD_EXP 56
28426: PUSH
28427: LD_VAR 0 2
28431: ARRAY
28432: AND
28433: IFFALSE 28471
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28435: LD_ADDR_EXP 56
28439: PUSH
28440: LD_EXP 56
28444: PPUSH
28445: LD_VAR 0 2
28449: PPUSH
28450: EMPTY
28451: PPUSH
28452: CALL_OW 1
28456: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28457: LD_VAR 0 2
28461: PPUSH
28462: LD_INT 103
28464: PPUSH
28465: CALL 22107 0 2
// continue ;
28469: GO 28380
// end ; if mc_construct_list [ i ] then
28471: LD_EXP 57
28475: PUSH
28476: LD_VAR 0 2
28480: ARRAY
28481: IFFALSE 28701
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28483: LD_ADDR_VAR 0 4
28487: PUSH
28488: LD_EXP 50
28492: PUSH
28493: LD_VAR 0 2
28497: ARRAY
28498: PPUSH
28499: LD_INT 25
28501: PUSH
28502: LD_INT 2
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: PPUSH
28509: CALL_OW 72
28513: PUSH
28514: LD_EXP 52
28518: PUSH
28519: LD_VAR 0 2
28523: ARRAY
28524: DIFF
28525: ST_TO_ADDR
// if not tmp then
28526: LD_VAR 0 4
28530: NOT
28531: IFFALSE 28535
// continue ;
28533: GO 28380
// for j in tmp do
28535: LD_ADDR_VAR 0 3
28539: PUSH
28540: LD_VAR 0 4
28544: PUSH
28545: FOR_IN
28546: IFFALSE 28697
// begin if not mc_builders [ i ] then
28548: LD_EXP 56
28552: PUSH
28553: LD_VAR 0 2
28557: ARRAY
28558: NOT
28559: IFFALSE 28617
// begin SetTag ( j , 103 ) ;
28561: LD_VAR 0 3
28565: PPUSH
28566: LD_INT 103
28568: PPUSH
28569: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28573: LD_ADDR_EXP 56
28577: PUSH
28578: LD_EXP 56
28582: PPUSH
28583: LD_VAR 0 2
28587: PUSH
28588: LD_EXP 56
28592: PUSH
28593: LD_VAR 0 2
28597: ARRAY
28598: PUSH
28599: LD_INT 1
28601: PLUS
28602: PUSH
28603: EMPTY
28604: LIST
28605: LIST
28606: PPUSH
28607: LD_VAR 0 3
28611: PPUSH
28612: CALL 53718 0 3
28616: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28617: LD_VAR 0 3
28621: PPUSH
28622: CALL_OW 310
28626: IFFALSE 28637
// ComExitBuilding ( j ) ;
28628: LD_VAR 0 3
28632: PPUSH
28633: CALL_OW 122
// wait ( 3 ) ;
28637: LD_INT 3
28639: PPUSH
28640: CALL_OW 67
// if not mc_construct_list [ i ] then
28644: LD_EXP 57
28648: PUSH
28649: LD_VAR 0 2
28653: ARRAY
28654: NOT
28655: IFFALSE 28659
// break ;
28657: GO 28697
// if not HasTask ( j ) then
28659: LD_VAR 0 3
28663: PPUSH
28664: CALL_OW 314
28668: NOT
28669: IFFALSE 28695
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28671: LD_VAR 0 3
28675: PPUSH
28676: LD_EXP 57
28680: PUSH
28681: LD_VAR 0 2
28685: ARRAY
28686: PUSH
28687: LD_INT 1
28689: ARRAY
28690: PPUSH
28691: CALL 56581 0 2
// end ;
28695: GO 28545
28697: POP
28698: POP
// end else
28699: GO 29532
// if mc_build_list [ i ] then
28701: LD_EXP 55
28705: PUSH
28706: LD_VAR 0 2
28710: ARRAY
28711: IFFALSE 29532
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28713: LD_ADDR_VAR 0 5
28717: PUSH
28718: LD_EXP 50
28722: PUSH
28723: LD_VAR 0 2
28727: ARRAY
28728: PPUSH
28729: LD_INT 2
28731: PUSH
28732: LD_INT 30
28734: PUSH
28735: LD_INT 0
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 30
28744: PUSH
28745: LD_INT 1
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: LIST
28756: PPUSH
28757: CALL_OW 72
28761: ST_TO_ADDR
// if depot then
28762: LD_VAR 0 5
28766: IFFALSE 28784
// depot := depot [ 1 ] else
28768: LD_ADDR_VAR 0 5
28772: PUSH
28773: LD_VAR 0 5
28777: PUSH
28778: LD_INT 1
28780: ARRAY
28781: ST_TO_ADDR
28782: GO 28792
// depot := 0 ;
28784: LD_ADDR_VAR 0 5
28788: PUSH
28789: LD_INT 0
28791: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28792: LD_EXP 55
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PUSH
28803: LD_INT 1
28805: ARRAY
28806: PUSH
28807: LD_INT 1
28809: ARRAY
28810: PPUSH
28811: CALL 56405 0 1
28815: PUSH
28816: LD_EXP 50
28820: PUSH
28821: LD_VAR 0 2
28825: ARRAY
28826: PPUSH
28827: LD_INT 2
28829: PUSH
28830: LD_INT 30
28832: PUSH
28833: LD_INT 2
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 30
28842: PUSH
28843: LD_INT 3
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: LIST
28854: PPUSH
28855: CALL_OW 72
28859: NOT
28860: AND
28861: IFFALSE 28966
// begin for j = 1 to mc_build_list [ i ] do
28863: LD_ADDR_VAR 0 3
28867: PUSH
28868: DOUBLE
28869: LD_INT 1
28871: DEC
28872: ST_TO_ADDR
28873: LD_EXP 55
28877: PUSH
28878: LD_VAR 0 2
28882: ARRAY
28883: PUSH
28884: FOR_TO
28885: IFFALSE 28964
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28887: LD_EXP 55
28891: PUSH
28892: LD_VAR 0 2
28896: ARRAY
28897: PUSH
28898: LD_VAR 0 3
28902: ARRAY
28903: PUSH
28904: LD_INT 1
28906: ARRAY
28907: PUSH
28908: LD_INT 2
28910: EQUAL
28911: IFFALSE 28962
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28913: LD_ADDR_EXP 55
28917: PUSH
28918: LD_EXP 55
28922: PPUSH
28923: LD_VAR 0 2
28927: PPUSH
28928: LD_EXP 55
28932: PUSH
28933: LD_VAR 0 2
28937: ARRAY
28938: PPUSH
28939: LD_VAR 0 3
28943: PPUSH
28944: LD_INT 1
28946: PPUSH
28947: LD_INT 0
28949: PPUSH
28950: CALL 53136 0 4
28954: PPUSH
28955: CALL_OW 1
28959: ST_TO_ADDR
// break ;
28960: GO 28964
// end ;
28962: GO 28884
28964: POP
28965: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28966: LD_EXP 55
28970: PUSH
28971: LD_VAR 0 2
28975: ARRAY
28976: PUSH
28977: LD_INT 1
28979: ARRAY
28980: PUSH
28981: LD_INT 1
28983: ARRAY
28984: PUSH
28985: LD_INT 0
28987: EQUAL
28988: PUSH
28989: LD_VAR 0 5
28993: PUSH
28994: LD_VAR 0 5
28998: PPUSH
28999: LD_EXP 55
29003: PUSH
29004: LD_VAR 0 2
29008: ARRAY
29009: PUSH
29010: LD_INT 1
29012: ARRAY
29013: PUSH
29014: LD_INT 1
29016: ARRAY
29017: PPUSH
29018: LD_EXP 55
29022: PUSH
29023: LD_VAR 0 2
29027: ARRAY
29028: PUSH
29029: LD_INT 1
29031: ARRAY
29032: PUSH
29033: LD_INT 2
29035: ARRAY
29036: PPUSH
29037: LD_EXP 55
29041: PUSH
29042: LD_VAR 0 2
29046: ARRAY
29047: PUSH
29048: LD_INT 1
29050: ARRAY
29051: PUSH
29052: LD_INT 3
29054: ARRAY
29055: PPUSH
29056: LD_EXP 55
29060: PUSH
29061: LD_VAR 0 2
29065: ARRAY
29066: PUSH
29067: LD_INT 1
29069: ARRAY
29070: PUSH
29071: LD_INT 4
29073: ARRAY
29074: PPUSH
29075: CALL 61821 0 5
29079: AND
29080: OR
29081: IFFALSE 29362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29083: LD_ADDR_VAR 0 4
29087: PUSH
29088: LD_EXP 50
29092: PUSH
29093: LD_VAR 0 2
29097: ARRAY
29098: PPUSH
29099: LD_INT 25
29101: PUSH
29102: LD_INT 2
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PPUSH
29109: CALL_OW 72
29113: PUSH
29114: LD_EXP 52
29118: PUSH
29119: LD_VAR 0 2
29123: ARRAY
29124: DIFF
29125: ST_TO_ADDR
// if not tmp then
29126: LD_VAR 0 4
29130: NOT
29131: IFFALSE 29135
// continue ;
29133: GO 28380
// for j in tmp do
29135: LD_ADDR_VAR 0 3
29139: PUSH
29140: LD_VAR 0 4
29144: PUSH
29145: FOR_IN
29146: IFFALSE 29358
// begin if not mc_builders [ i ] then
29148: LD_EXP 56
29152: PUSH
29153: LD_VAR 0 2
29157: ARRAY
29158: NOT
29159: IFFALSE 29217
// begin SetTag ( j , 103 ) ;
29161: LD_VAR 0 3
29165: PPUSH
29166: LD_INT 103
29168: PPUSH
29169: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29173: LD_ADDR_EXP 56
29177: PUSH
29178: LD_EXP 56
29182: PPUSH
29183: LD_VAR 0 2
29187: PUSH
29188: LD_EXP 56
29192: PUSH
29193: LD_VAR 0 2
29197: ARRAY
29198: PUSH
29199: LD_INT 1
29201: PLUS
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PPUSH
29207: LD_VAR 0 3
29211: PPUSH
29212: CALL 53718 0 3
29216: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29217: LD_VAR 0 3
29221: PPUSH
29222: CALL_OW 310
29226: IFFALSE 29237
// ComExitBuilding ( j ) ;
29228: LD_VAR 0 3
29232: PPUSH
29233: CALL_OW 122
// wait ( 3 ) ;
29237: LD_INT 3
29239: PPUSH
29240: CALL_OW 67
// if not mc_build_list [ i ] then
29244: LD_EXP 55
29248: PUSH
29249: LD_VAR 0 2
29253: ARRAY
29254: NOT
29255: IFFALSE 29259
// break ;
29257: GO 29358
// if not HasTask ( j ) then
29259: LD_VAR 0 3
29263: PPUSH
29264: CALL_OW 314
29268: NOT
29269: IFFALSE 29356
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29271: LD_VAR 0 3
29275: PPUSH
29276: LD_EXP 55
29280: PUSH
29281: LD_VAR 0 2
29285: ARRAY
29286: PUSH
29287: LD_INT 1
29289: ARRAY
29290: PUSH
29291: LD_INT 1
29293: ARRAY
29294: PPUSH
29295: LD_EXP 55
29299: PUSH
29300: LD_VAR 0 2
29304: ARRAY
29305: PUSH
29306: LD_INT 1
29308: ARRAY
29309: PUSH
29310: LD_INT 2
29312: ARRAY
29313: PPUSH
29314: LD_EXP 55
29318: PUSH
29319: LD_VAR 0 2
29323: ARRAY
29324: PUSH
29325: LD_INT 1
29327: ARRAY
29328: PUSH
29329: LD_INT 3
29331: ARRAY
29332: PPUSH
29333: LD_EXP 55
29337: PUSH
29338: LD_VAR 0 2
29342: ARRAY
29343: PUSH
29344: LD_INT 1
29346: ARRAY
29347: PUSH
29348: LD_INT 4
29350: ARRAY
29351: PPUSH
29352: CALL_OW 145
// end ;
29356: GO 29145
29358: POP
29359: POP
// end else
29360: GO 29532
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29362: LD_EXP 50
29366: PUSH
29367: LD_VAR 0 2
29371: ARRAY
29372: PPUSH
29373: LD_EXP 55
29377: PUSH
29378: LD_VAR 0 2
29382: ARRAY
29383: PUSH
29384: LD_INT 1
29386: ARRAY
29387: PUSH
29388: LD_INT 1
29390: ARRAY
29391: PPUSH
29392: LD_EXP 55
29396: PUSH
29397: LD_VAR 0 2
29401: ARRAY
29402: PUSH
29403: LD_INT 1
29405: ARRAY
29406: PUSH
29407: LD_INT 2
29409: ARRAY
29410: PPUSH
29411: LD_EXP 55
29415: PUSH
29416: LD_VAR 0 2
29420: ARRAY
29421: PUSH
29422: LD_INT 1
29424: ARRAY
29425: PUSH
29426: LD_INT 3
29428: ARRAY
29429: PPUSH
29430: LD_EXP 55
29434: PUSH
29435: LD_VAR 0 2
29439: ARRAY
29440: PUSH
29441: LD_INT 1
29443: ARRAY
29444: PUSH
29445: LD_INT 4
29447: ARRAY
29448: PPUSH
29449: LD_EXP 50
29453: PUSH
29454: LD_VAR 0 2
29458: ARRAY
29459: PPUSH
29460: LD_INT 21
29462: PUSH
29463: LD_INT 3
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PPUSH
29470: CALL_OW 72
29474: PPUSH
29475: EMPTY
29476: PPUSH
29477: CALL 60571 0 7
29481: NOT
29482: IFFALSE 29532
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29484: LD_ADDR_EXP 55
29488: PUSH
29489: LD_EXP 55
29493: PPUSH
29494: LD_VAR 0 2
29498: PPUSH
29499: LD_EXP 55
29503: PUSH
29504: LD_VAR 0 2
29508: ARRAY
29509: PPUSH
29510: LD_INT 1
29512: PPUSH
29513: LD_INT 1
29515: NEG
29516: PPUSH
29517: LD_INT 0
29519: PPUSH
29520: CALL 53136 0 4
29524: PPUSH
29525: CALL_OW 1
29529: ST_TO_ADDR
// continue ;
29530: GO 28380
// end ; end ; end ;
29532: GO 28380
29534: POP
29535: POP
// end ;
29536: LD_VAR 0 1
29540: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29541: LD_INT 0
29543: PPUSH
29544: PPUSH
29545: PPUSH
29546: PPUSH
29547: PPUSH
29548: PPUSH
// if not mc_bases then
29549: LD_EXP 50
29553: NOT
29554: IFFALSE 29558
// exit ;
29556: GO 29985
// for i = 1 to mc_bases do
29558: LD_ADDR_VAR 0 2
29562: PUSH
29563: DOUBLE
29564: LD_INT 1
29566: DEC
29567: ST_TO_ADDR
29568: LD_EXP 50
29572: PUSH
29573: FOR_TO
29574: IFFALSE 29983
// begin tmp := mc_build_upgrade [ i ] ;
29576: LD_ADDR_VAR 0 4
29580: PUSH
29581: LD_EXP 82
29585: PUSH
29586: LD_VAR 0 2
29590: ARRAY
29591: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29592: LD_ADDR_VAR 0 6
29596: PUSH
29597: LD_EXP 83
29601: PUSH
29602: LD_VAR 0 2
29606: ARRAY
29607: PPUSH
29608: LD_INT 2
29610: PUSH
29611: LD_INT 30
29613: PUSH
29614: LD_INT 6
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 30
29623: PUSH
29624: LD_INT 7
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: LIST
29635: PPUSH
29636: CALL_OW 72
29640: ST_TO_ADDR
// if not tmp and not lab then
29641: LD_VAR 0 4
29645: NOT
29646: PUSH
29647: LD_VAR 0 6
29651: NOT
29652: AND
29653: IFFALSE 29657
// continue ;
29655: GO 29573
// if tmp then
29657: LD_VAR 0 4
29661: IFFALSE 29781
// for j in tmp do
29663: LD_ADDR_VAR 0 3
29667: PUSH
29668: LD_VAR 0 4
29672: PUSH
29673: FOR_IN
29674: IFFALSE 29779
// begin if UpgradeCost ( j ) then
29676: LD_VAR 0 3
29680: PPUSH
29681: CALL 60231 0 1
29685: IFFALSE 29777
// begin ComUpgrade ( j ) ;
29687: LD_VAR 0 3
29691: PPUSH
29692: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29696: LD_ADDR_EXP 82
29700: PUSH
29701: LD_EXP 82
29705: PPUSH
29706: LD_VAR 0 2
29710: PPUSH
29711: LD_EXP 82
29715: PUSH
29716: LD_VAR 0 2
29720: ARRAY
29721: PUSH
29722: LD_VAR 0 3
29726: DIFF
29727: PPUSH
29728: CALL_OW 1
29732: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29733: LD_ADDR_EXP 57
29737: PUSH
29738: LD_EXP 57
29742: PPUSH
29743: LD_VAR 0 2
29747: PUSH
29748: LD_EXP 57
29752: PUSH
29753: LD_VAR 0 2
29757: ARRAY
29758: PUSH
29759: LD_INT 1
29761: PLUS
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PPUSH
29767: LD_VAR 0 3
29771: PPUSH
29772: CALL 53718 0 3
29776: ST_TO_ADDR
// end ; end ;
29777: GO 29673
29779: POP
29780: POP
// if not lab or not mc_lab_upgrade [ i ] then
29781: LD_VAR 0 6
29785: NOT
29786: PUSH
29787: LD_EXP 84
29791: PUSH
29792: LD_VAR 0 2
29796: ARRAY
29797: NOT
29798: OR
29799: IFFALSE 29803
// continue ;
29801: GO 29573
// for j in lab do
29803: LD_ADDR_VAR 0 3
29807: PUSH
29808: LD_VAR 0 6
29812: PUSH
29813: FOR_IN
29814: IFFALSE 29979
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29816: LD_VAR 0 3
29820: PPUSH
29821: CALL_OW 266
29825: PUSH
29826: LD_INT 6
29828: PUSH
29829: LD_INT 7
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: IN
29836: PUSH
29837: LD_VAR 0 3
29841: PPUSH
29842: CALL_OW 461
29846: PUSH
29847: LD_INT 1
29849: NONEQUAL
29850: AND
29851: IFFALSE 29977
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29853: LD_VAR 0 3
29857: PPUSH
29858: LD_EXP 84
29862: PUSH
29863: LD_VAR 0 2
29867: ARRAY
29868: PUSH
29869: LD_INT 1
29871: ARRAY
29872: PPUSH
29873: CALL 60436 0 2
29877: IFFALSE 29977
// begin ComCancel ( j ) ;
29879: LD_VAR 0 3
29883: PPUSH
29884: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29888: LD_VAR 0 3
29892: PPUSH
29893: LD_EXP 84
29897: PUSH
29898: LD_VAR 0 2
29902: ARRAY
29903: PUSH
29904: LD_INT 1
29906: ARRAY
29907: PPUSH
29908: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29912: LD_VAR 0 3
29916: PUSH
29917: LD_EXP 57
29921: PUSH
29922: LD_VAR 0 2
29926: ARRAY
29927: IN
29928: NOT
29929: IFFALSE 29975
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29931: LD_ADDR_EXP 57
29935: PUSH
29936: LD_EXP 57
29940: PPUSH
29941: LD_VAR 0 2
29945: PUSH
29946: LD_EXP 57
29950: PUSH
29951: LD_VAR 0 2
29955: ARRAY
29956: PUSH
29957: LD_INT 1
29959: PLUS
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PPUSH
29965: LD_VAR 0 3
29969: PPUSH
29970: CALL 53718 0 3
29974: ST_TO_ADDR
// break ;
29975: GO 29979
// end ; end ; end ;
29977: GO 29813
29979: POP
29980: POP
// end ;
29981: GO 29573
29983: POP
29984: POP
// end ;
29985: LD_VAR 0 1
29989: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29990: LD_INT 0
29992: PPUSH
29993: PPUSH
29994: PPUSH
29995: PPUSH
29996: PPUSH
29997: PPUSH
29998: PPUSH
29999: PPUSH
30000: PPUSH
// if not mc_bases then
30001: LD_EXP 50
30005: NOT
30006: IFFALSE 30010
// exit ;
30008: GO 30415
// for i = 1 to mc_bases do
30010: LD_ADDR_VAR 0 2
30014: PUSH
30015: DOUBLE
30016: LD_INT 1
30018: DEC
30019: ST_TO_ADDR
30020: LD_EXP 50
30024: PUSH
30025: FOR_TO
30026: IFFALSE 30413
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30028: LD_EXP 58
30032: PUSH
30033: LD_VAR 0 2
30037: ARRAY
30038: NOT
30039: PUSH
30040: LD_EXP 50
30044: PUSH
30045: LD_VAR 0 2
30049: ARRAY
30050: PPUSH
30051: LD_INT 30
30053: PUSH
30054: LD_INT 3
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PPUSH
30061: CALL_OW 72
30065: NOT
30066: OR
30067: IFFALSE 30071
// continue ;
30069: GO 30025
// busy := false ;
30071: LD_ADDR_VAR 0 8
30075: PUSH
30076: LD_INT 0
30078: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30079: LD_ADDR_VAR 0 4
30083: PUSH
30084: LD_EXP 50
30088: PUSH
30089: LD_VAR 0 2
30093: ARRAY
30094: PPUSH
30095: LD_INT 30
30097: PUSH
30098: LD_INT 3
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PPUSH
30105: CALL_OW 72
30109: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30110: LD_ADDR_VAR 0 6
30114: PUSH
30115: LD_EXP 58
30119: PUSH
30120: LD_VAR 0 2
30124: ARRAY
30125: PPUSH
30126: LD_INT 2
30128: PUSH
30129: LD_INT 30
30131: PUSH
30132: LD_INT 32
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 30
30141: PUSH
30142: LD_INT 33
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: LIST
30153: PPUSH
30154: CALL_OW 72
30158: ST_TO_ADDR
// if not t then
30159: LD_VAR 0 6
30163: NOT
30164: IFFALSE 30168
// continue ;
30166: GO 30025
// for j in tmp do
30168: LD_ADDR_VAR 0 3
30172: PUSH
30173: LD_VAR 0 4
30177: PUSH
30178: FOR_IN
30179: IFFALSE 30209
// if not BuildingStatus ( j ) = bs_idle then
30181: LD_VAR 0 3
30185: PPUSH
30186: CALL_OW 461
30190: PUSH
30191: LD_INT 2
30193: EQUAL
30194: NOT
30195: IFFALSE 30207
// begin busy := true ;
30197: LD_ADDR_VAR 0 8
30201: PUSH
30202: LD_INT 1
30204: ST_TO_ADDR
// break ;
30205: GO 30209
// end ;
30207: GO 30178
30209: POP
30210: POP
// if busy then
30211: LD_VAR 0 8
30215: IFFALSE 30219
// continue ;
30217: GO 30025
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30219: LD_ADDR_VAR 0 7
30223: PUSH
30224: LD_VAR 0 6
30228: PPUSH
30229: LD_INT 35
30231: PUSH
30232: LD_INT 0
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PPUSH
30239: CALL_OW 72
30243: ST_TO_ADDR
// if tw then
30244: LD_VAR 0 7
30248: IFFALSE 30325
// begin tw := tw [ 1 ] ;
30250: LD_ADDR_VAR 0 7
30254: PUSH
30255: LD_VAR 0 7
30259: PUSH
30260: LD_INT 1
30262: ARRAY
30263: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30264: LD_ADDR_VAR 0 9
30268: PUSH
30269: LD_VAR 0 7
30273: PPUSH
30274: LD_EXP 75
30278: PUSH
30279: LD_VAR 0 2
30283: ARRAY
30284: PPUSH
30285: CALL 58728 0 2
30289: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30290: LD_EXP 89
30294: PUSH
30295: LD_VAR 0 2
30299: ARRAY
30300: IFFALSE 30323
// if not weapon in mc_allowed_tower_weapons [ i ] then
30302: LD_VAR 0 9
30306: PUSH
30307: LD_EXP 89
30311: PUSH
30312: LD_VAR 0 2
30316: ARRAY
30317: IN
30318: NOT
30319: IFFALSE 30323
// continue ;
30321: GO 30025
// end else
30323: GO 30388
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30325: LD_ADDR_VAR 0 5
30329: PUSH
30330: LD_EXP 58
30334: PUSH
30335: LD_VAR 0 2
30339: ARRAY
30340: PPUSH
30341: LD_VAR 0 4
30345: PPUSH
30346: CALL 85528 0 2
30350: ST_TO_ADDR
// if not tmp2 then
30351: LD_VAR 0 5
30355: NOT
30356: IFFALSE 30360
// continue ;
30358: GO 30025
// tw := tmp2 [ 1 ] ;
30360: LD_ADDR_VAR 0 7
30364: PUSH
30365: LD_VAR 0 5
30369: PUSH
30370: LD_INT 1
30372: ARRAY
30373: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30374: LD_ADDR_VAR 0 9
30378: PUSH
30379: LD_VAR 0 5
30383: PUSH
30384: LD_INT 2
30386: ARRAY
30387: ST_TO_ADDR
// end ; if not weapon then
30388: LD_VAR 0 9
30392: NOT
30393: IFFALSE 30397
// continue ;
30395: GO 30025
// ComPlaceWeapon ( tw , weapon ) ;
30397: LD_VAR 0 7
30401: PPUSH
30402: LD_VAR 0 9
30406: PPUSH
30407: CALL_OW 148
// end ;
30411: GO 30025
30413: POP
30414: POP
// end ;
30415: LD_VAR 0 1
30419: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30420: LD_INT 0
30422: PPUSH
30423: PPUSH
30424: PPUSH
30425: PPUSH
30426: PPUSH
30427: PPUSH
30428: PPUSH
// if not mc_bases then
30429: LD_EXP 50
30433: NOT
30434: IFFALSE 30438
// exit ;
30436: GO 31206
// for i = 1 to mc_bases do
30438: LD_ADDR_VAR 0 2
30442: PUSH
30443: DOUBLE
30444: LD_INT 1
30446: DEC
30447: ST_TO_ADDR
30448: LD_EXP 50
30452: PUSH
30453: FOR_TO
30454: IFFALSE 31204
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30456: LD_EXP 63
30460: PUSH
30461: LD_VAR 0 2
30465: ARRAY
30466: NOT
30467: PUSH
30468: LD_EXP 63
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: PUSH
30479: LD_EXP 64
30483: PUSH
30484: LD_VAR 0 2
30488: ARRAY
30489: EQUAL
30490: OR
30491: PUSH
30492: LD_EXP 73
30496: PUSH
30497: LD_VAR 0 2
30501: ARRAY
30502: OR
30503: IFFALSE 30507
// continue ;
30505: GO 30453
// if mc_miners [ i ] then
30507: LD_EXP 64
30511: PUSH
30512: LD_VAR 0 2
30516: ARRAY
30517: IFFALSE 30891
// begin for j = mc_miners [ i ] downto 1 do
30519: LD_ADDR_VAR 0 3
30523: PUSH
30524: DOUBLE
30525: LD_EXP 64
30529: PUSH
30530: LD_VAR 0 2
30534: ARRAY
30535: INC
30536: ST_TO_ADDR
30537: LD_INT 1
30539: PUSH
30540: FOR_DOWNTO
30541: IFFALSE 30889
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30543: LD_EXP 64
30547: PUSH
30548: LD_VAR 0 2
30552: ARRAY
30553: PUSH
30554: LD_VAR 0 3
30558: ARRAY
30559: PPUSH
30560: CALL_OW 301
30564: PUSH
30565: LD_EXP 64
30569: PUSH
30570: LD_VAR 0 2
30574: ARRAY
30575: PUSH
30576: LD_VAR 0 3
30580: ARRAY
30581: PPUSH
30582: CALL_OW 257
30586: PUSH
30587: LD_INT 1
30589: NONEQUAL
30590: OR
30591: IFFALSE 30654
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30593: LD_ADDR_VAR 0 5
30597: PUSH
30598: LD_EXP 64
30602: PUSH
30603: LD_VAR 0 2
30607: ARRAY
30608: PUSH
30609: LD_EXP 64
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PUSH
30620: LD_VAR 0 3
30624: ARRAY
30625: DIFF
30626: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30627: LD_ADDR_EXP 64
30631: PUSH
30632: LD_EXP 64
30636: PPUSH
30637: LD_VAR 0 2
30641: PPUSH
30642: LD_VAR 0 5
30646: PPUSH
30647: CALL_OW 1
30651: ST_TO_ADDR
// continue ;
30652: GO 30540
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30654: LD_EXP 64
30658: PUSH
30659: LD_VAR 0 2
30663: ARRAY
30664: PUSH
30665: LD_VAR 0 3
30669: ARRAY
30670: PPUSH
30671: CALL_OW 257
30675: PUSH
30676: LD_INT 1
30678: EQUAL
30679: PUSH
30680: LD_EXP 64
30684: PUSH
30685: LD_VAR 0 2
30689: ARRAY
30690: PUSH
30691: LD_VAR 0 3
30695: ARRAY
30696: PPUSH
30697: CALL_OW 459
30701: NOT
30702: AND
30703: PUSH
30704: LD_EXP 64
30708: PUSH
30709: LD_VAR 0 2
30713: ARRAY
30714: PUSH
30715: LD_VAR 0 3
30719: ARRAY
30720: PPUSH
30721: CALL_OW 314
30725: NOT
30726: AND
30727: IFFALSE 30887
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30729: LD_EXP 64
30733: PUSH
30734: LD_VAR 0 2
30738: ARRAY
30739: PUSH
30740: LD_VAR 0 3
30744: ARRAY
30745: PPUSH
30746: CALL_OW 310
30750: IFFALSE 30773
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30752: LD_EXP 64
30756: PUSH
30757: LD_VAR 0 2
30761: ARRAY
30762: PUSH
30763: LD_VAR 0 3
30767: ARRAY
30768: PPUSH
30769: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30773: LD_EXP 64
30777: PUSH
30778: LD_VAR 0 2
30782: ARRAY
30783: PUSH
30784: LD_VAR 0 3
30788: ARRAY
30789: PPUSH
30790: CALL_OW 314
30794: NOT
30795: IFFALSE 30887
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30797: LD_ADDR_VAR 0 7
30801: PUSH
30802: LD_INT 1
30804: PPUSH
30805: LD_EXP 63
30809: PUSH
30810: LD_VAR 0 2
30814: ARRAY
30815: PPUSH
30816: CALL_OW 12
30820: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30821: LD_EXP 64
30825: PUSH
30826: LD_VAR 0 2
30830: ARRAY
30831: PUSH
30832: LD_VAR 0 3
30836: ARRAY
30837: PPUSH
30838: LD_EXP 63
30842: PUSH
30843: LD_VAR 0 2
30847: ARRAY
30848: PUSH
30849: LD_VAR 0 7
30853: ARRAY
30854: PUSH
30855: LD_INT 1
30857: ARRAY
30858: PPUSH
30859: LD_EXP 63
30863: PUSH
30864: LD_VAR 0 2
30868: ARRAY
30869: PUSH
30870: LD_VAR 0 7
30874: ARRAY
30875: PUSH
30876: LD_INT 2
30878: ARRAY
30879: PPUSH
30880: LD_INT 0
30882: PPUSH
30883: CALL_OW 193
// end ; end ; end ;
30887: GO 30540
30889: POP
30890: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30891: LD_ADDR_VAR 0 5
30895: PUSH
30896: LD_EXP 50
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: PPUSH
30907: LD_INT 2
30909: PUSH
30910: LD_INT 30
30912: PUSH
30913: LD_INT 4
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 30
30922: PUSH
30923: LD_INT 5
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 30
30932: PUSH
30933: LD_INT 32
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: PPUSH
30946: CALL_OW 72
30950: ST_TO_ADDR
// if not tmp then
30951: LD_VAR 0 5
30955: NOT
30956: IFFALSE 30960
// continue ;
30958: GO 30453
// list := [ ] ;
30960: LD_ADDR_VAR 0 6
30964: PUSH
30965: EMPTY
30966: ST_TO_ADDR
// for j in tmp do
30967: LD_ADDR_VAR 0 3
30971: PUSH
30972: LD_VAR 0 5
30976: PUSH
30977: FOR_IN
30978: IFFALSE 31047
// begin for k in UnitsInside ( j ) do
30980: LD_ADDR_VAR 0 4
30984: PUSH
30985: LD_VAR 0 3
30989: PPUSH
30990: CALL_OW 313
30994: PUSH
30995: FOR_IN
30996: IFFALSE 31043
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30998: LD_VAR 0 4
31002: PPUSH
31003: CALL_OW 257
31007: PUSH
31008: LD_INT 1
31010: EQUAL
31011: PUSH
31012: LD_VAR 0 4
31016: PPUSH
31017: CALL_OW 459
31021: NOT
31022: AND
31023: IFFALSE 31041
// list := list ^ k ;
31025: LD_ADDR_VAR 0 6
31029: PUSH
31030: LD_VAR 0 6
31034: PUSH
31035: LD_VAR 0 4
31039: ADD
31040: ST_TO_ADDR
31041: GO 30995
31043: POP
31044: POP
// end ;
31045: GO 30977
31047: POP
31048: POP
// list := list diff mc_miners [ i ] ;
31049: LD_ADDR_VAR 0 6
31053: PUSH
31054: LD_VAR 0 6
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: DIFF
31070: ST_TO_ADDR
// if not list then
31071: LD_VAR 0 6
31075: NOT
31076: IFFALSE 31080
// continue ;
31078: GO 30453
// k := mc_mines [ i ] - mc_miners [ i ] ;
31080: LD_ADDR_VAR 0 4
31084: PUSH
31085: LD_EXP 63
31089: PUSH
31090: LD_VAR 0 2
31094: ARRAY
31095: PUSH
31096: LD_EXP 64
31100: PUSH
31101: LD_VAR 0 2
31105: ARRAY
31106: MINUS
31107: ST_TO_ADDR
// if k > list then
31108: LD_VAR 0 4
31112: PUSH
31113: LD_VAR 0 6
31117: GREATER
31118: IFFALSE 31130
// k := list ;
31120: LD_ADDR_VAR 0 4
31124: PUSH
31125: LD_VAR 0 6
31129: ST_TO_ADDR
// for j = 1 to k do
31130: LD_ADDR_VAR 0 3
31134: PUSH
31135: DOUBLE
31136: LD_INT 1
31138: DEC
31139: ST_TO_ADDR
31140: LD_VAR 0 4
31144: PUSH
31145: FOR_TO
31146: IFFALSE 31200
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31148: LD_ADDR_EXP 64
31152: PUSH
31153: LD_EXP 64
31157: PPUSH
31158: LD_VAR 0 2
31162: PUSH
31163: LD_EXP 64
31167: PUSH
31168: LD_VAR 0 2
31172: ARRAY
31173: PUSH
31174: LD_INT 1
31176: PLUS
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PPUSH
31182: LD_VAR 0 6
31186: PUSH
31187: LD_VAR 0 3
31191: ARRAY
31192: PPUSH
31193: CALL 53718 0 3
31197: ST_TO_ADDR
31198: GO 31145
31200: POP
31201: POP
// end ;
31202: GO 30453
31204: POP
31205: POP
// end ;
31206: LD_VAR 0 1
31210: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31211: LD_INT 0
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
31217: PPUSH
31218: PPUSH
31219: PPUSH
31220: PPUSH
31221: PPUSH
31222: PPUSH
31223: PPUSH
// if not mc_bases then
31224: LD_EXP 50
31228: NOT
31229: IFFALSE 31233
// exit ;
31231: GO 33056
// for i = 1 to mc_bases do
31233: LD_ADDR_VAR 0 2
31237: PUSH
31238: DOUBLE
31239: LD_INT 1
31241: DEC
31242: ST_TO_ADDR
31243: LD_EXP 50
31247: PUSH
31248: FOR_TO
31249: IFFALSE 33054
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31251: LD_EXP 50
31255: PUSH
31256: LD_VAR 0 2
31260: ARRAY
31261: NOT
31262: PUSH
31263: LD_EXP 57
31267: PUSH
31268: LD_VAR 0 2
31272: ARRAY
31273: OR
31274: IFFALSE 31278
// continue ;
31276: GO 31248
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31278: LD_EXP 66
31282: PUSH
31283: LD_VAR 0 2
31287: ARRAY
31288: NOT
31289: PUSH
31290: LD_EXP 67
31294: PUSH
31295: LD_VAR 0 2
31299: ARRAY
31300: AND
31301: IFFALSE 31339
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31303: LD_ADDR_EXP 67
31307: PUSH
31308: LD_EXP 67
31312: PPUSH
31313: LD_VAR 0 2
31317: PPUSH
31318: EMPTY
31319: PPUSH
31320: CALL_OW 1
31324: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31325: LD_VAR 0 2
31329: PPUSH
31330: LD_INT 107
31332: PPUSH
31333: CALL 22107 0 2
// continue ;
31337: GO 31248
// end ; target := [ ] ;
31339: LD_ADDR_VAR 0 7
31343: PUSH
31344: EMPTY
31345: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31346: LD_ADDR_VAR 0 6
31350: PUSH
31351: LD_EXP 50
31355: PUSH
31356: LD_VAR 0 2
31360: ARRAY
31361: PUSH
31362: LD_INT 1
31364: ARRAY
31365: PPUSH
31366: CALL_OW 255
31370: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31371: LD_ADDR_VAR 0 9
31375: PUSH
31376: LD_EXP 50
31380: PUSH
31381: LD_VAR 0 2
31385: ARRAY
31386: PPUSH
31387: LD_INT 2
31389: PUSH
31390: LD_INT 30
31392: PUSH
31393: LD_INT 0
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 30
31402: PUSH
31403: LD_INT 1
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: LIST
31414: PPUSH
31415: CALL_OW 72
31419: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31420: LD_ADDR_VAR 0 3
31424: PUSH
31425: DOUBLE
31426: LD_EXP 66
31430: PUSH
31431: LD_VAR 0 2
31435: ARRAY
31436: INC
31437: ST_TO_ADDR
31438: LD_INT 1
31440: PUSH
31441: FOR_DOWNTO
31442: IFFALSE 31687
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31444: LD_EXP 66
31448: PUSH
31449: LD_VAR 0 2
31453: ARRAY
31454: PUSH
31455: LD_VAR 0 3
31459: ARRAY
31460: PUSH
31461: LD_INT 2
31463: ARRAY
31464: PPUSH
31465: LD_EXP 66
31469: PUSH
31470: LD_VAR 0 2
31474: ARRAY
31475: PUSH
31476: LD_VAR 0 3
31480: ARRAY
31481: PUSH
31482: LD_INT 3
31484: ARRAY
31485: PPUSH
31486: CALL_OW 488
31490: PUSH
31491: LD_EXP 66
31495: PUSH
31496: LD_VAR 0 2
31500: ARRAY
31501: PUSH
31502: LD_VAR 0 3
31506: ARRAY
31507: PUSH
31508: LD_INT 2
31510: ARRAY
31511: PPUSH
31512: LD_EXP 66
31516: PUSH
31517: LD_VAR 0 2
31521: ARRAY
31522: PUSH
31523: LD_VAR 0 3
31527: ARRAY
31528: PUSH
31529: LD_INT 3
31531: ARRAY
31532: PPUSH
31533: CALL_OW 284
31537: PUSH
31538: LD_INT 0
31540: EQUAL
31541: AND
31542: IFFALSE 31597
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31544: LD_ADDR_VAR 0 5
31548: PUSH
31549: LD_EXP 66
31553: PUSH
31554: LD_VAR 0 2
31558: ARRAY
31559: PPUSH
31560: LD_VAR 0 3
31564: PPUSH
31565: CALL_OW 3
31569: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31570: LD_ADDR_EXP 66
31574: PUSH
31575: LD_EXP 66
31579: PPUSH
31580: LD_VAR 0 2
31584: PPUSH
31585: LD_VAR 0 5
31589: PPUSH
31590: CALL_OW 1
31594: ST_TO_ADDR
// continue ;
31595: GO 31441
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31597: LD_VAR 0 6
31601: PPUSH
31602: LD_EXP 66
31606: PUSH
31607: LD_VAR 0 2
31611: ARRAY
31612: PUSH
31613: LD_VAR 0 3
31617: ARRAY
31618: PUSH
31619: LD_INT 2
31621: ARRAY
31622: PPUSH
31623: LD_EXP 66
31627: PUSH
31628: LD_VAR 0 2
31632: ARRAY
31633: PUSH
31634: LD_VAR 0 3
31638: ARRAY
31639: PUSH
31640: LD_INT 3
31642: ARRAY
31643: PPUSH
31644: LD_INT 30
31646: PPUSH
31647: CALL 54614 0 4
31651: PUSH
31652: LD_INT 4
31654: ARRAY
31655: PUSH
31656: LD_INT 0
31658: EQUAL
31659: IFFALSE 31685
// begin target := mc_crates [ i ] [ j ] ;
31661: LD_ADDR_VAR 0 7
31665: PUSH
31666: LD_EXP 66
31670: PUSH
31671: LD_VAR 0 2
31675: ARRAY
31676: PUSH
31677: LD_VAR 0 3
31681: ARRAY
31682: ST_TO_ADDR
// break ;
31683: GO 31687
// end ; end ;
31685: GO 31441
31687: POP
31688: POP
// if not target then
31689: LD_VAR 0 7
31693: NOT
31694: IFFALSE 31698
// continue ;
31696: GO 31248
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31698: LD_ADDR_VAR 0 8
31702: PUSH
31703: LD_EXP 69
31707: PUSH
31708: LD_VAR 0 2
31712: ARRAY
31713: PPUSH
31714: LD_INT 2
31716: PUSH
31717: LD_INT 3
31719: PUSH
31720: LD_INT 58
31722: PUSH
31723: EMPTY
31724: LIST
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 61
31732: PUSH
31733: EMPTY
31734: LIST
31735: PUSH
31736: LD_INT 33
31738: PUSH
31739: LD_INT 5
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 33
31748: PUSH
31749: LD_INT 3
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 2
31765: PUSH
31766: LD_INT 34
31768: PUSH
31769: LD_INT 32
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 34
31778: PUSH
31779: LD_INT 51
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 34
31788: PUSH
31789: LD_INT 12
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: PUSH
31802: EMPTY
31803: LIST
31804: LIST
31805: PPUSH
31806: CALL_OW 72
31810: ST_TO_ADDR
// if not cargo then
31811: LD_VAR 0 8
31815: NOT
31816: IFFALSE 32522
// begin if mc_crates_collector [ i ] < 5 then
31818: LD_EXP 67
31822: PUSH
31823: LD_VAR 0 2
31827: ARRAY
31828: PUSH
31829: LD_INT 5
31831: LESS
31832: IFFALSE 32198
// begin if mc_ape [ i ] then
31834: LD_EXP 79
31838: PUSH
31839: LD_VAR 0 2
31843: ARRAY
31844: IFFALSE 31891
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31846: LD_ADDR_VAR 0 5
31850: PUSH
31851: LD_EXP 79
31855: PUSH
31856: LD_VAR 0 2
31860: ARRAY
31861: PPUSH
31862: LD_INT 25
31864: PUSH
31865: LD_INT 16
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 24
31874: PUSH
31875: LD_INT 750
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PPUSH
31886: CALL_OW 72
31890: ST_TO_ADDR
// if not tmp then
31891: LD_VAR 0 5
31895: NOT
31896: IFFALSE 31943
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31898: LD_ADDR_VAR 0 5
31902: PUSH
31903: LD_EXP 50
31907: PUSH
31908: LD_VAR 0 2
31912: ARRAY
31913: PPUSH
31914: LD_INT 25
31916: PUSH
31917: LD_INT 2
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 24
31926: PUSH
31927: LD_INT 750
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PPUSH
31938: CALL_OW 72
31942: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31943: LD_EXP 79
31947: PUSH
31948: LD_VAR 0 2
31952: ARRAY
31953: PUSH
31954: LD_EXP 50
31958: PUSH
31959: LD_VAR 0 2
31963: ARRAY
31964: PPUSH
31965: LD_INT 25
31967: PUSH
31968: LD_INT 2
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 24
31977: PUSH
31978: LD_INT 750
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PPUSH
31989: CALL_OW 72
31993: AND
31994: PUSH
31995: LD_VAR 0 5
31999: PUSH
32000: LD_INT 5
32002: LESS
32003: AND
32004: IFFALSE 32086
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32006: LD_ADDR_VAR 0 3
32010: PUSH
32011: LD_EXP 50
32015: PUSH
32016: LD_VAR 0 2
32020: ARRAY
32021: PPUSH
32022: LD_INT 25
32024: PUSH
32025: LD_INT 2
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 24
32034: PUSH
32035: LD_INT 750
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PPUSH
32046: CALL_OW 72
32050: PUSH
32051: FOR_IN
32052: IFFALSE 32084
// begin tmp := tmp union j ;
32054: LD_ADDR_VAR 0 5
32058: PUSH
32059: LD_VAR 0 5
32063: PUSH
32064: LD_VAR 0 3
32068: UNION
32069: ST_TO_ADDR
// if tmp >= 5 then
32070: LD_VAR 0 5
32074: PUSH
32075: LD_INT 5
32077: GREATEREQUAL
32078: IFFALSE 32082
// break ;
32080: GO 32084
// end ;
32082: GO 32051
32084: POP
32085: POP
// end ; if not tmp then
32086: LD_VAR 0 5
32090: NOT
32091: IFFALSE 32095
// continue ;
32093: GO 31248
// for j in tmp do
32095: LD_ADDR_VAR 0 3
32099: PUSH
32100: LD_VAR 0 5
32104: PUSH
32105: FOR_IN
32106: IFFALSE 32196
// if not GetTag ( j ) then
32108: LD_VAR 0 3
32112: PPUSH
32113: CALL_OW 110
32117: NOT
32118: IFFALSE 32194
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32120: LD_ADDR_EXP 67
32124: PUSH
32125: LD_EXP 67
32129: PPUSH
32130: LD_VAR 0 2
32134: PUSH
32135: LD_EXP 67
32139: PUSH
32140: LD_VAR 0 2
32144: ARRAY
32145: PUSH
32146: LD_INT 1
32148: PLUS
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: LD_VAR 0 3
32158: PPUSH
32159: CALL 53718 0 3
32163: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32164: LD_VAR 0 3
32168: PPUSH
32169: LD_INT 107
32171: PPUSH
32172: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32176: LD_EXP 67
32180: PUSH
32181: LD_VAR 0 2
32185: ARRAY
32186: PUSH
32187: LD_INT 5
32189: GREATEREQUAL
32190: IFFALSE 32194
// break ;
32192: GO 32196
// end ;
32194: GO 32105
32196: POP
32197: POP
// end ; if mc_crates_collector [ i ] and target then
32198: LD_EXP 67
32202: PUSH
32203: LD_VAR 0 2
32207: ARRAY
32208: PUSH
32209: LD_VAR 0 7
32213: AND
32214: IFFALSE 32520
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32216: LD_EXP 67
32220: PUSH
32221: LD_VAR 0 2
32225: ARRAY
32226: PUSH
32227: LD_VAR 0 7
32231: PUSH
32232: LD_INT 1
32234: ARRAY
32235: LESS
32236: IFFALSE 32256
// tmp := mc_crates_collector [ i ] else
32238: LD_ADDR_VAR 0 5
32242: PUSH
32243: LD_EXP 67
32247: PUSH
32248: LD_VAR 0 2
32252: ARRAY
32253: ST_TO_ADDR
32254: GO 32270
// tmp := target [ 1 ] ;
32256: LD_ADDR_VAR 0 5
32260: PUSH
32261: LD_VAR 0 7
32265: PUSH
32266: LD_INT 1
32268: ARRAY
32269: ST_TO_ADDR
// k := 0 ;
32270: LD_ADDR_VAR 0 4
32274: PUSH
32275: LD_INT 0
32277: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32278: LD_ADDR_VAR 0 3
32282: PUSH
32283: LD_EXP 67
32287: PUSH
32288: LD_VAR 0 2
32292: ARRAY
32293: PUSH
32294: FOR_IN
32295: IFFALSE 32518
// begin k := k + 1 ;
32297: LD_ADDR_VAR 0 4
32301: PUSH
32302: LD_VAR 0 4
32306: PUSH
32307: LD_INT 1
32309: PLUS
32310: ST_TO_ADDR
// if k > tmp then
32311: LD_VAR 0 4
32315: PUSH
32316: LD_VAR 0 5
32320: GREATER
32321: IFFALSE 32325
// break ;
32323: GO 32518
// if not GetClass ( j ) in [ 2 , 16 ] then
32325: LD_VAR 0 3
32329: PPUSH
32330: CALL_OW 257
32334: PUSH
32335: LD_INT 2
32337: PUSH
32338: LD_INT 16
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: IN
32345: NOT
32346: IFFALSE 32399
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32348: LD_ADDR_EXP 67
32352: PUSH
32353: LD_EXP 67
32357: PPUSH
32358: LD_VAR 0 2
32362: PPUSH
32363: LD_EXP 67
32367: PUSH
32368: LD_VAR 0 2
32372: ARRAY
32373: PUSH
32374: LD_VAR 0 3
32378: DIFF
32379: PPUSH
32380: CALL_OW 1
32384: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32385: LD_VAR 0 3
32389: PPUSH
32390: LD_INT 0
32392: PPUSH
32393: CALL_OW 109
// continue ;
32397: GO 32294
// end ; if IsInUnit ( j ) then
32399: LD_VAR 0 3
32403: PPUSH
32404: CALL_OW 310
32408: IFFALSE 32419
// ComExitBuilding ( j ) ;
32410: LD_VAR 0 3
32414: PPUSH
32415: CALL_OW 122
// wait ( 3 ) ;
32419: LD_INT 3
32421: PPUSH
32422: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32426: LD_VAR 0 3
32430: PPUSH
32431: CALL_OW 314
32435: PUSH
32436: LD_VAR 0 6
32440: PPUSH
32441: LD_VAR 0 7
32445: PUSH
32446: LD_INT 2
32448: ARRAY
32449: PPUSH
32450: LD_VAR 0 7
32454: PUSH
32455: LD_INT 3
32457: ARRAY
32458: PPUSH
32459: LD_INT 30
32461: PPUSH
32462: CALL 54614 0 4
32466: PUSH
32467: LD_INT 4
32469: ARRAY
32470: AND
32471: IFFALSE 32489
// ComStandNearbyBuilding ( j , depot ) else
32473: LD_VAR 0 3
32477: PPUSH
32478: LD_VAR 0 9
32482: PPUSH
32483: CALL 50143 0 2
32487: GO 32516
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32489: LD_VAR 0 3
32493: PPUSH
32494: LD_VAR 0 7
32498: PUSH
32499: LD_INT 2
32501: ARRAY
32502: PPUSH
32503: LD_VAR 0 7
32507: PUSH
32508: LD_INT 3
32510: ARRAY
32511: PPUSH
32512: CALL_OW 117
// end ;
32516: GO 32294
32518: POP
32519: POP
// end ; end else
32520: GO 33052
// begin for j in cargo do
32522: LD_ADDR_VAR 0 3
32526: PUSH
32527: LD_VAR 0 8
32531: PUSH
32532: FOR_IN
32533: IFFALSE 33050
// begin if GetTag ( j ) <> 0 then
32535: LD_VAR 0 3
32539: PPUSH
32540: CALL_OW 110
32544: PUSH
32545: LD_INT 0
32547: NONEQUAL
32548: IFFALSE 32552
// continue ;
32550: GO 32532
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32552: LD_VAR 0 3
32556: PPUSH
32557: CALL_OW 256
32561: PUSH
32562: LD_INT 1000
32564: LESS
32565: PUSH
32566: LD_VAR 0 3
32570: PPUSH
32571: LD_EXP 74
32575: PUSH
32576: LD_VAR 0 2
32580: ARRAY
32581: PPUSH
32582: CALL_OW 308
32586: NOT
32587: AND
32588: IFFALSE 32610
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32590: LD_VAR 0 3
32594: PPUSH
32595: LD_EXP 74
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: PPUSH
32606: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32610: LD_VAR 0 3
32614: PPUSH
32615: CALL_OW 256
32619: PUSH
32620: LD_INT 1000
32622: LESS
32623: PUSH
32624: LD_VAR 0 3
32628: PPUSH
32629: LD_EXP 74
32633: PUSH
32634: LD_VAR 0 2
32638: ARRAY
32639: PPUSH
32640: CALL_OW 308
32644: AND
32645: IFFALSE 32649
// continue ;
32647: GO 32532
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32649: LD_VAR 0 3
32653: PPUSH
32654: CALL_OW 262
32658: PUSH
32659: LD_INT 2
32661: EQUAL
32662: PUSH
32663: LD_VAR 0 3
32667: PPUSH
32668: CALL_OW 261
32672: PUSH
32673: LD_INT 15
32675: LESS
32676: AND
32677: IFFALSE 32681
// continue ;
32679: GO 32532
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32681: LD_VAR 0 3
32685: PPUSH
32686: CALL_OW 262
32690: PUSH
32691: LD_INT 1
32693: EQUAL
32694: PUSH
32695: LD_VAR 0 3
32699: PPUSH
32700: CALL_OW 261
32704: PUSH
32705: LD_INT 10
32707: LESS
32708: AND
32709: IFFALSE 32989
// begin if not depot then
32711: LD_VAR 0 9
32715: NOT
32716: IFFALSE 32720
// continue ;
32718: GO 32532
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32720: LD_VAR 0 3
32724: PPUSH
32725: LD_VAR 0 9
32729: PPUSH
32730: LD_VAR 0 3
32734: PPUSH
32735: CALL_OW 74
32739: PPUSH
32740: CALL_OW 296
32744: PUSH
32745: LD_INT 6
32747: LESS
32748: IFFALSE 32764
// SetFuel ( j , 100 ) else
32750: LD_VAR 0 3
32754: PPUSH
32755: LD_INT 100
32757: PPUSH
32758: CALL_OW 240
32762: GO 32989
// if GetFuel ( j ) = 0 then
32764: LD_VAR 0 3
32768: PPUSH
32769: CALL_OW 261
32773: PUSH
32774: LD_INT 0
32776: EQUAL
32777: IFFALSE 32989
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32779: LD_ADDR_EXP 69
32783: PUSH
32784: LD_EXP 69
32788: PPUSH
32789: LD_VAR 0 2
32793: PPUSH
32794: LD_EXP 69
32798: PUSH
32799: LD_VAR 0 2
32803: ARRAY
32804: PUSH
32805: LD_VAR 0 3
32809: DIFF
32810: PPUSH
32811: CALL_OW 1
32815: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32816: LD_VAR 0 3
32820: PPUSH
32821: CALL_OW 263
32825: PUSH
32826: LD_INT 1
32828: EQUAL
32829: IFFALSE 32845
// ComExitVehicle ( IsInUnit ( j ) ) ;
32831: LD_VAR 0 3
32835: PPUSH
32836: CALL_OW 310
32840: PPUSH
32841: CALL_OW 121
// if GetControl ( j ) = control_remote then
32845: LD_VAR 0 3
32849: PPUSH
32850: CALL_OW 263
32854: PUSH
32855: LD_INT 2
32857: EQUAL
32858: IFFALSE 32869
// ComUnlink ( j ) ;
32860: LD_VAR 0 3
32864: PPUSH
32865: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32869: LD_ADDR_VAR 0 10
32873: PUSH
32874: LD_VAR 0 2
32878: PPUSH
32879: LD_INT 3
32881: PPUSH
32882: CALL 42628 0 2
32886: ST_TO_ADDR
// if fac then
32887: LD_VAR 0 10
32891: IFFALSE 32987
// begin for k in fac do
32893: LD_ADDR_VAR 0 4
32897: PUSH
32898: LD_VAR 0 10
32902: PUSH
32903: FOR_IN
32904: IFFALSE 32985
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32906: LD_ADDR_VAR 0 11
32910: PUSH
32911: LD_VAR 0 10
32915: PPUSH
32916: LD_VAR 0 3
32920: PPUSH
32921: CALL_OW 265
32925: PPUSH
32926: LD_VAR 0 3
32930: PPUSH
32931: CALL_OW 262
32935: PPUSH
32936: LD_VAR 0 3
32940: PPUSH
32941: CALL_OW 263
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 264
32955: PPUSH
32956: CALL 51214 0 5
32960: ST_TO_ADDR
// if components then
32961: LD_VAR 0 11
32965: IFFALSE 32983
// begin MC_InsertProduceList ( i , components ) ;
32967: LD_VAR 0 2
32971: PPUSH
32972: LD_VAR 0 11
32976: PPUSH
32977: CALL 42173 0 2
// break ;
32981: GO 32985
// end ; end ;
32983: GO 32903
32985: POP
32986: POP
// end ; continue ;
32987: GO 32532
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32989: LD_VAR 0 3
32993: PPUSH
32994: LD_INT 1
32996: PPUSH
32997: CALL_OW 289
33001: PUSH
33002: LD_INT 100
33004: LESS
33005: PUSH
33006: LD_VAR 0 3
33010: PPUSH
33011: CALL_OW 314
33015: NOT
33016: AND
33017: IFFALSE 33046
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33019: LD_VAR 0 3
33023: PPUSH
33024: LD_VAR 0 7
33028: PUSH
33029: LD_INT 2
33031: ARRAY
33032: PPUSH
33033: LD_VAR 0 7
33037: PUSH
33038: LD_INT 3
33040: ARRAY
33041: PPUSH
33042: CALL_OW 117
// break ;
33046: GO 33050
// end ;
33048: GO 32532
33050: POP
33051: POP
// end ; end ;
33052: GO 31248
33054: POP
33055: POP
// end ;
33056: LD_VAR 0 1
33060: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33061: LD_INT 0
33063: PPUSH
33064: PPUSH
33065: PPUSH
33066: PPUSH
// if not mc_bases then
33067: LD_EXP 50
33071: NOT
33072: IFFALSE 33076
// exit ;
33074: GO 33237
// for i = 1 to mc_bases do
33076: LD_ADDR_VAR 0 2
33080: PUSH
33081: DOUBLE
33082: LD_INT 1
33084: DEC
33085: ST_TO_ADDR
33086: LD_EXP 50
33090: PUSH
33091: FOR_TO
33092: IFFALSE 33235
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33094: LD_ADDR_VAR 0 4
33098: PUSH
33099: LD_EXP 69
33103: PUSH
33104: LD_VAR 0 2
33108: ARRAY
33109: PUSH
33110: LD_EXP 72
33114: PUSH
33115: LD_VAR 0 2
33119: ARRAY
33120: UNION
33121: PPUSH
33122: LD_INT 33
33124: PUSH
33125: LD_INT 2
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PPUSH
33132: CALL_OW 72
33136: ST_TO_ADDR
// if tmp then
33137: LD_VAR 0 4
33141: IFFALSE 33233
// for j in tmp do
33143: LD_ADDR_VAR 0 3
33147: PUSH
33148: LD_VAR 0 4
33152: PUSH
33153: FOR_IN
33154: IFFALSE 33231
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33156: LD_VAR 0 3
33160: PPUSH
33161: CALL_OW 312
33165: NOT
33166: PUSH
33167: LD_VAR 0 3
33171: PPUSH
33172: CALL_OW 256
33176: PUSH
33177: LD_INT 250
33179: GREATEREQUAL
33180: AND
33181: IFFALSE 33194
// Connect ( j ) else
33183: LD_VAR 0 3
33187: PPUSH
33188: CALL 56689 0 1
33192: GO 33229
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33194: LD_VAR 0 3
33198: PPUSH
33199: CALL_OW 256
33203: PUSH
33204: LD_INT 250
33206: LESS
33207: PUSH
33208: LD_VAR 0 3
33212: PPUSH
33213: CALL_OW 312
33217: AND
33218: IFFALSE 33229
// ComUnlink ( j ) ;
33220: LD_VAR 0 3
33224: PPUSH
33225: CALL_OW 136
33229: GO 33153
33231: POP
33232: POP
// end ;
33233: GO 33091
33235: POP
33236: POP
// end ;
33237: LD_VAR 0 1
33241: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33242: LD_INT 0
33244: PPUSH
33245: PPUSH
33246: PPUSH
33247: PPUSH
33248: PPUSH
// if not mc_bases then
33249: LD_EXP 50
33253: NOT
33254: IFFALSE 33258
// exit ;
33256: GO 33703
// for i = 1 to mc_bases do
33258: LD_ADDR_VAR 0 2
33262: PUSH
33263: DOUBLE
33264: LD_INT 1
33266: DEC
33267: ST_TO_ADDR
33268: LD_EXP 50
33272: PUSH
33273: FOR_TO
33274: IFFALSE 33701
// begin if not mc_produce [ i ] then
33276: LD_EXP 71
33280: PUSH
33281: LD_VAR 0 2
33285: ARRAY
33286: NOT
33287: IFFALSE 33291
// continue ;
33289: GO 33273
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33291: LD_ADDR_VAR 0 5
33295: PUSH
33296: LD_EXP 50
33300: PUSH
33301: LD_VAR 0 2
33305: ARRAY
33306: PPUSH
33307: LD_INT 30
33309: PUSH
33310: LD_INT 3
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PPUSH
33317: CALL_OW 72
33321: ST_TO_ADDR
// if not fac then
33322: LD_VAR 0 5
33326: NOT
33327: IFFALSE 33331
// continue ;
33329: GO 33273
// for j in fac do
33331: LD_ADDR_VAR 0 3
33335: PUSH
33336: LD_VAR 0 5
33340: PUSH
33341: FOR_IN
33342: IFFALSE 33697
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33344: LD_VAR 0 3
33348: PPUSH
33349: CALL_OW 461
33353: PUSH
33354: LD_INT 2
33356: NONEQUAL
33357: PUSH
33358: LD_VAR 0 3
33362: PPUSH
33363: LD_INT 15
33365: PPUSH
33366: CALL 56317 0 2
33370: PUSH
33371: LD_INT 4
33373: ARRAY
33374: OR
33375: IFFALSE 33379
// continue ;
33377: GO 33341
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33379: LD_VAR 0 3
33383: PPUSH
33384: LD_EXP 71
33388: PUSH
33389: LD_VAR 0 2
33393: ARRAY
33394: PUSH
33395: LD_INT 1
33397: ARRAY
33398: PUSH
33399: LD_INT 1
33401: ARRAY
33402: PPUSH
33403: LD_EXP 71
33407: PUSH
33408: LD_VAR 0 2
33412: ARRAY
33413: PUSH
33414: LD_INT 1
33416: ARRAY
33417: PUSH
33418: LD_INT 2
33420: ARRAY
33421: PPUSH
33422: LD_EXP 71
33426: PUSH
33427: LD_VAR 0 2
33431: ARRAY
33432: PUSH
33433: LD_INT 1
33435: ARRAY
33436: PUSH
33437: LD_INT 3
33439: ARRAY
33440: PPUSH
33441: LD_EXP 71
33445: PUSH
33446: LD_VAR 0 2
33450: ARRAY
33451: PUSH
33452: LD_INT 1
33454: ARRAY
33455: PUSH
33456: LD_INT 4
33458: ARRAY
33459: PPUSH
33460: CALL_OW 448
33464: PUSH
33465: LD_VAR 0 3
33469: PPUSH
33470: LD_EXP 71
33474: PUSH
33475: LD_VAR 0 2
33479: ARRAY
33480: PUSH
33481: LD_INT 1
33483: ARRAY
33484: PUSH
33485: LD_INT 1
33487: ARRAY
33488: PUSH
33489: LD_EXP 71
33493: PUSH
33494: LD_VAR 0 2
33498: ARRAY
33499: PUSH
33500: LD_INT 1
33502: ARRAY
33503: PUSH
33504: LD_INT 2
33506: ARRAY
33507: PUSH
33508: LD_EXP 71
33512: PUSH
33513: LD_VAR 0 2
33517: ARRAY
33518: PUSH
33519: LD_INT 1
33521: ARRAY
33522: PUSH
33523: LD_INT 3
33525: ARRAY
33526: PUSH
33527: LD_EXP 71
33531: PUSH
33532: LD_VAR 0 2
33536: ARRAY
33537: PUSH
33538: LD_INT 1
33540: ARRAY
33541: PUSH
33542: LD_INT 4
33544: ARRAY
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: PPUSH
33552: CALL 60084 0 2
33556: AND
33557: IFFALSE 33695
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33559: LD_VAR 0 3
33563: PPUSH
33564: LD_EXP 71
33568: PUSH
33569: LD_VAR 0 2
33573: ARRAY
33574: PUSH
33575: LD_INT 1
33577: ARRAY
33578: PUSH
33579: LD_INT 1
33581: ARRAY
33582: PPUSH
33583: LD_EXP 71
33587: PUSH
33588: LD_VAR 0 2
33592: ARRAY
33593: PUSH
33594: LD_INT 1
33596: ARRAY
33597: PUSH
33598: LD_INT 2
33600: ARRAY
33601: PPUSH
33602: LD_EXP 71
33606: PUSH
33607: LD_VAR 0 2
33611: ARRAY
33612: PUSH
33613: LD_INT 1
33615: ARRAY
33616: PUSH
33617: LD_INT 3
33619: ARRAY
33620: PPUSH
33621: LD_EXP 71
33625: PUSH
33626: LD_VAR 0 2
33630: ARRAY
33631: PUSH
33632: LD_INT 1
33634: ARRAY
33635: PUSH
33636: LD_INT 4
33638: ARRAY
33639: PPUSH
33640: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33644: LD_ADDR_VAR 0 4
33648: PUSH
33649: LD_EXP 71
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: PPUSH
33660: LD_INT 1
33662: PPUSH
33663: CALL_OW 3
33667: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33668: LD_ADDR_EXP 71
33672: PUSH
33673: LD_EXP 71
33677: PPUSH
33678: LD_VAR 0 2
33682: PPUSH
33683: LD_VAR 0 4
33687: PPUSH
33688: CALL_OW 1
33692: ST_TO_ADDR
// break ;
33693: GO 33697
// end ; end ;
33695: GO 33341
33697: POP
33698: POP
// end ;
33699: GO 33273
33701: POP
33702: POP
// end ;
33703: LD_VAR 0 1
33707: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33708: LD_INT 0
33710: PPUSH
33711: PPUSH
33712: PPUSH
// if not mc_bases then
33713: LD_EXP 50
33717: NOT
33718: IFFALSE 33722
// exit ;
33720: GO 33811
// for i = 1 to mc_bases do
33722: LD_ADDR_VAR 0 2
33726: PUSH
33727: DOUBLE
33728: LD_INT 1
33730: DEC
33731: ST_TO_ADDR
33732: LD_EXP 50
33736: PUSH
33737: FOR_TO
33738: IFFALSE 33809
// begin if mc_attack [ i ] then
33740: LD_EXP 70
33744: PUSH
33745: LD_VAR 0 2
33749: ARRAY
33750: IFFALSE 33807
// begin tmp := mc_attack [ i ] [ 1 ] ;
33752: LD_ADDR_VAR 0 3
33756: PUSH
33757: LD_EXP 70
33761: PUSH
33762: LD_VAR 0 2
33766: ARRAY
33767: PUSH
33768: LD_INT 1
33770: ARRAY
33771: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33772: LD_ADDR_EXP 70
33776: PUSH
33777: LD_EXP 70
33781: PPUSH
33782: LD_VAR 0 2
33786: PPUSH
33787: EMPTY
33788: PPUSH
33789: CALL_OW 1
33793: ST_TO_ADDR
// Attack ( tmp ) ;
33794: LD_VAR 0 3
33798: PPUSH
33799: CALL 109917 0 1
// exit ;
33803: POP
33804: POP
33805: GO 33811
// end ; end ;
33807: GO 33737
33809: POP
33810: POP
// end ;
33811: LD_VAR 0 1
33815: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33816: LD_INT 0
33818: PPUSH
33819: PPUSH
33820: PPUSH
33821: PPUSH
33822: PPUSH
33823: PPUSH
33824: PPUSH
// if not mc_bases then
33825: LD_EXP 50
33829: NOT
33830: IFFALSE 33834
// exit ;
33832: GO 34691
// for i = 1 to mc_bases do
33834: LD_ADDR_VAR 0 2
33838: PUSH
33839: DOUBLE
33840: LD_INT 1
33842: DEC
33843: ST_TO_ADDR
33844: LD_EXP 50
33848: PUSH
33849: FOR_TO
33850: IFFALSE 34689
// begin if not mc_bases [ i ] then
33852: LD_EXP 50
33856: PUSH
33857: LD_VAR 0 2
33861: ARRAY
33862: NOT
33863: IFFALSE 33867
// continue ;
33865: GO 33849
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33867: LD_ADDR_VAR 0 7
33871: PUSH
33872: LD_EXP 50
33876: PUSH
33877: LD_VAR 0 2
33881: ARRAY
33882: PUSH
33883: LD_INT 1
33885: ARRAY
33886: PPUSH
33887: CALL 50365 0 1
33891: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33892: LD_ADDR_EXP 73
33896: PUSH
33897: LD_EXP 73
33901: PPUSH
33902: LD_VAR 0 2
33906: PPUSH
33907: LD_EXP 50
33911: PUSH
33912: LD_VAR 0 2
33916: ARRAY
33917: PUSH
33918: LD_INT 1
33920: ARRAY
33921: PPUSH
33922: CALL_OW 255
33926: PPUSH
33927: LD_EXP 75
33931: PUSH
33932: LD_VAR 0 2
33936: ARRAY
33937: PPUSH
33938: CALL 50330 0 2
33942: PPUSH
33943: CALL_OW 1
33947: ST_TO_ADDR
// if not mc_scan [ i ] then
33948: LD_EXP 73
33952: PUSH
33953: LD_VAR 0 2
33957: ARRAY
33958: NOT
33959: IFFALSE 34137
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33961: LD_ADDR_EXP 93
33965: PUSH
33966: LD_EXP 93
33970: PPUSH
33971: LD_VAR 0 2
33975: PPUSH
33976: LD_INT 0
33978: PPUSH
33979: CALL_OW 1
33983: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33984: LD_ADDR_VAR 0 4
33988: PUSH
33989: LD_EXP 50
33993: PUSH
33994: LD_VAR 0 2
33998: ARRAY
33999: PPUSH
34000: LD_INT 2
34002: PUSH
34003: LD_INT 25
34005: PUSH
34006: LD_INT 5
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 25
34015: PUSH
34016: LD_INT 8
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 25
34025: PUSH
34026: LD_INT 9
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: PPUSH
34039: CALL_OW 72
34043: ST_TO_ADDR
// if not tmp then
34044: LD_VAR 0 4
34048: NOT
34049: IFFALSE 34053
// continue ;
34051: GO 33849
// for j in tmp do
34053: LD_ADDR_VAR 0 3
34057: PUSH
34058: LD_VAR 0 4
34062: PUSH
34063: FOR_IN
34064: IFFALSE 34135
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34066: LD_VAR 0 3
34070: PPUSH
34071: CALL_OW 310
34075: PPUSH
34076: CALL_OW 266
34080: PUSH
34081: LD_INT 5
34083: EQUAL
34084: PUSH
34085: LD_VAR 0 3
34089: PPUSH
34090: CALL_OW 257
34094: PUSH
34095: LD_INT 1
34097: EQUAL
34098: AND
34099: PUSH
34100: LD_VAR 0 3
34104: PPUSH
34105: CALL_OW 459
34109: NOT
34110: AND
34111: PUSH
34112: LD_VAR 0 7
34116: AND
34117: IFFALSE 34133
// ComChangeProfession ( j , class ) ;
34119: LD_VAR 0 3
34123: PPUSH
34124: LD_VAR 0 7
34128: PPUSH
34129: CALL_OW 123
34133: GO 34063
34135: POP
34136: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34137: LD_EXP 73
34141: PUSH
34142: LD_VAR 0 2
34146: ARRAY
34147: PUSH
34148: LD_EXP 93
34152: PUSH
34153: LD_VAR 0 2
34157: ARRAY
34158: NOT
34159: AND
34160: PUSH
34161: LD_EXP 72
34165: PUSH
34166: LD_VAR 0 2
34170: ARRAY
34171: NOT
34172: AND
34173: PUSH
34174: LD_EXP 50
34178: PUSH
34179: LD_VAR 0 2
34183: ARRAY
34184: PPUSH
34185: LD_INT 50
34187: PUSH
34188: EMPTY
34189: LIST
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: LD_INT 30
34196: PUSH
34197: LD_INT 32
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 30
34206: PUSH
34207: LD_INT 33
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 30
34216: PUSH
34217: LD_INT 4
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 30
34226: PUSH
34227: LD_INT 5
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PPUSH
34245: CALL_OW 72
34249: PUSH
34250: LD_INT 4
34252: LESS
34253: PUSH
34254: LD_EXP 50
34258: PUSH
34259: LD_VAR 0 2
34263: ARRAY
34264: PPUSH
34265: LD_INT 3
34267: PUSH
34268: LD_INT 24
34270: PUSH
34271: LD_INT 1000
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 2
34284: PUSH
34285: LD_INT 30
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 30
34297: PUSH
34298: LD_INT 1
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: LIST
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: PPUSH
34314: CALL_OW 72
34318: OR
34319: AND
34320: IFFALSE 34571
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34322: LD_ADDR_EXP 93
34326: PUSH
34327: LD_EXP 93
34331: PPUSH
34332: LD_VAR 0 2
34336: PPUSH
34337: LD_INT 1
34339: PPUSH
34340: CALL_OW 1
34344: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34345: LD_ADDR_VAR 0 4
34349: PUSH
34350: LD_EXP 50
34354: PUSH
34355: LD_VAR 0 2
34359: ARRAY
34360: PPUSH
34361: LD_INT 2
34363: PUSH
34364: LD_INT 25
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 25
34376: PUSH
34377: LD_INT 5
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 25
34386: PUSH
34387: LD_INT 8
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 25
34396: PUSH
34397: LD_INT 9
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: PPUSH
34411: CALL_OW 72
34415: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34416: LD_ADDR_VAR 0 4
34420: PUSH
34421: LD_VAR 0 4
34425: PUSH
34426: LD_VAR 0 4
34430: PPUSH
34431: LD_INT 18
34433: PPUSH
34434: CALL 83554 0 2
34438: DIFF
34439: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34440: LD_VAR 0 4
34444: NOT
34445: PUSH
34446: LD_EXP 50
34450: PUSH
34451: LD_VAR 0 2
34455: ARRAY
34456: PPUSH
34457: LD_INT 2
34459: PUSH
34460: LD_INT 30
34462: PUSH
34463: LD_INT 4
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 30
34472: PUSH
34473: LD_INT 5
34475: PUSH
34476: EMPTY
34477: LIST
34478: LIST
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: LIST
34484: PPUSH
34485: CALL_OW 72
34489: NOT
34490: AND
34491: IFFALSE 34553
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34493: LD_ADDR_VAR 0 4
34497: PUSH
34498: LD_EXP 50
34502: PUSH
34503: LD_VAR 0 2
34507: ARRAY
34508: PPUSH
34509: LD_INT 2
34511: PUSH
34512: LD_INT 25
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 25
34524: PUSH
34525: LD_INT 3
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 25
34534: PUSH
34535: LD_INT 4
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: PPUSH
34548: CALL_OW 72
34552: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34553: LD_VAR 0 2
34557: PPUSH
34558: LD_VAR 0 4
34562: PPUSH
34563: CALL 114626 0 2
// exit ;
34567: POP
34568: POP
34569: GO 34691
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34571: LD_EXP 73
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: PUSH
34582: LD_EXP 93
34586: PUSH
34587: LD_VAR 0 2
34591: ARRAY
34592: NOT
34593: AND
34594: PUSH
34595: LD_EXP 72
34599: PUSH
34600: LD_VAR 0 2
34604: ARRAY
34605: AND
34606: IFFALSE 34687
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34608: LD_ADDR_EXP 93
34612: PUSH
34613: LD_EXP 93
34617: PPUSH
34618: LD_VAR 0 2
34622: PPUSH
34623: LD_INT 1
34625: PPUSH
34626: CALL_OW 1
34630: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34631: LD_ADDR_VAR 0 4
34635: PUSH
34636: LD_EXP 72
34640: PUSH
34641: LD_VAR 0 2
34645: ARRAY
34646: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34647: LD_ADDR_EXP 72
34651: PUSH
34652: LD_EXP 72
34656: PPUSH
34657: LD_VAR 0 2
34661: PPUSH
34662: EMPTY
34663: PPUSH
34664: CALL_OW 1
34668: ST_TO_ADDR
// Defend ( i , tmp ) ;
34669: LD_VAR 0 2
34673: PPUSH
34674: LD_VAR 0 4
34678: PPUSH
34679: CALL 115222 0 2
// exit ;
34683: POP
34684: POP
34685: GO 34691
// end ; end ;
34687: GO 33849
34689: POP
34690: POP
// end ;
34691: LD_VAR 0 1
34695: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34696: LD_INT 0
34698: PPUSH
34699: PPUSH
34700: PPUSH
34701: PPUSH
34702: PPUSH
34703: PPUSH
34704: PPUSH
34705: PPUSH
34706: PPUSH
34707: PPUSH
34708: PPUSH
// if not mc_bases then
34709: LD_EXP 50
34713: NOT
34714: IFFALSE 34718
// exit ;
34716: GO 35805
// for i = 1 to mc_bases do
34718: LD_ADDR_VAR 0 2
34722: PUSH
34723: DOUBLE
34724: LD_INT 1
34726: DEC
34727: ST_TO_ADDR
34728: LD_EXP 50
34732: PUSH
34733: FOR_TO
34734: IFFALSE 35803
// begin tmp := mc_lab [ i ] ;
34736: LD_ADDR_VAR 0 6
34740: PUSH
34741: LD_EXP 83
34745: PUSH
34746: LD_VAR 0 2
34750: ARRAY
34751: ST_TO_ADDR
// if not tmp then
34752: LD_VAR 0 6
34756: NOT
34757: IFFALSE 34761
// continue ;
34759: GO 34733
// idle_lab := 0 ;
34761: LD_ADDR_VAR 0 11
34765: PUSH
34766: LD_INT 0
34768: ST_TO_ADDR
// for j in tmp do
34769: LD_ADDR_VAR 0 3
34773: PUSH
34774: LD_VAR 0 6
34778: PUSH
34779: FOR_IN
34780: IFFALSE 35799
// begin researching := false ;
34782: LD_ADDR_VAR 0 10
34786: PUSH
34787: LD_INT 0
34789: ST_TO_ADDR
// side := GetSide ( j ) ;
34790: LD_ADDR_VAR 0 4
34794: PUSH
34795: LD_VAR 0 3
34799: PPUSH
34800: CALL_OW 255
34804: ST_TO_ADDR
// if not mc_tech [ side ] then
34805: LD_EXP 77
34809: PUSH
34810: LD_VAR 0 4
34814: ARRAY
34815: NOT
34816: IFFALSE 34820
// continue ;
34818: GO 34779
// if BuildingStatus ( j ) = bs_idle then
34820: LD_VAR 0 3
34824: PPUSH
34825: CALL_OW 461
34829: PUSH
34830: LD_INT 2
34832: EQUAL
34833: IFFALSE 35021
// begin if idle_lab and UnitsInside ( j ) < 6 then
34835: LD_VAR 0 11
34839: PUSH
34840: LD_VAR 0 3
34844: PPUSH
34845: CALL_OW 313
34849: PUSH
34850: LD_INT 6
34852: LESS
34853: AND
34854: IFFALSE 34925
// begin tmp2 := UnitsInside ( idle_lab ) ;
34856: LD_ADDR_VAR 0 9
34860: PUSH
34861: LD_VAR 0 11
34865: PPUSH
34866: CALL_OW 313
34870: ST_TO_ADDR
// if tmp2 then
34871: LD_VAR 0 9
34875: IFFALSE 34917
// for x in tmp2 do
34877: LD_ADDR_VAR 0 7
34881: PUSH
34882: LD_VAR 0 9
34886: PUSH
34887: FOR_IN
34888: IFFALSE 34915
// begin ComExitBuilding ( x ) ;
34890: LD_VAR 0 7
34894: PPUSH
34895: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34899: LD_VAR 0 7
34903: PPUSH
34904: LD_VAR 0 3
34908: PPUSH
34909: CALL_OW 180
// end ;
34913: GO 34887
34915: POP
34916: POP
// idle_lab := 0 ;
34917: LD_ADDR_VAR 0 11
34921: PUSH
34922: LD_INT 0
34924: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34925: LD_ADDR_VAR 0 5
34929: PUSH
34930: LD_EXP 77
34934: PUSH
34935: LD_VAR 0 4
34939: ARRAY
34940: PUSH
34941: FOR_IN
34942: IFFALSE 35002
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34944: LD_VAR 0 3
34948: PPUSH
34949: LD_VAR 0 5
34953: PPUSH
34954: CALL_OW 430
34958: PUSH
34959: LD_VAR 0 4
34963: PPUSH
34964: LD_VAR 0 5
34968: PPUSH
34969: CALL 49435 0 2
34973: AND
34974: IFFALSE 35000
// begin researching := true ;
34976: LD_ADDR_VAR 0 10
34980: PUSH
34981: LD_INT 1
34983: ST_TO_ADDR
// ComResearch ( j , t ) ;
34984: LD_VAR 0 3
34988: PPUSH
34989: LD_VAR 0 5
34993: PPUSH
34994: CALL_OW 124
// break ;
34998: GO 35002
// end ;
35000: GO 34941
35002: POP
35003: POP
// if not researching then
35004: LD_VAR 0 10
35008: NOT
35009: IFFALSE 35021
// idle_lab := j ;
35011: LD_ADDR_VAR 0 11
35015: PUSH
35016: LD_VAR 0 3
35020: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35021: LD_VAR 0 3
35025: PPUSH
35026: CALL_OW 461
35030: PUSH
35031: LD_INT 10
35033: EQUAL
35034: IFFALSE 35622
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35036: LD_EXP 79
35040: PUSH
35041: LD_VAR 0 2
35045: ARRAY
35046: NOT
35047: PUSH
35048: LD_EXP 80
35052: PUSH
35053: LD_VAR 0 2
35057: ARRAY
35058: NOT
35059: AND
35060: PUSH
35061: LD_EXP 77
35065: PUSH
35066: LD_VAR 0 4
35070: ARRAY
35071: PUSH
35072: LD_INT 1
35074: GREATER
35075: AND
35076: IFFALSE 35207
// begin ComCancel ( j ) ;
35078: LD_VAR 0 3
35082: PPUSH
35083: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35087: LD_ADDR_EXP 77
35091: PUSH
35092: LD_EXP 77
35096: PPUSH
35097: LD_VAR 0 4
35101: PPUSH
35102: LD_EXP 77
35106: PUSH
35107: LD_VAR 0 4
35111: ARRAY
35112: PPUSH
35113: LD_EXP 77
35117: PUSH
35118: LD_VAR 0 4
35122: ARRAY
35123: PUSH
35124: LD_INT 1
35126: MINUS
35127: PPUSH
35128: LD_EXP 77
35132: PUSH
35133: LD_VAR 0 4
35137: ARRAY
35138: PPUSH
35139: LD_INT 0
35141: PPUSH
35142: CALL 53136 0 4
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35152: LD_ADDR_EXP 77
35156: PUSH
35157: LD_EXP 77
35161: PPUSH
35162: LD_VAR 0 4
35166: PPUSH
35167: LD_EXP 77
35171: PUSH
35172: LD_VAR 0 4
35176: ARRAY
35177: PPUSH
35178: LD_EXP 77
35182: PUSH
35183: LD_VAR 0 4
35187: ARRAY
35188: PPUSH
35189: LD_INT 1
35191: PPUSH
35192: LD_INT 0
35194: PPUSH
35195: CALL 53136 0 4
35199: PPUSH
35200: CALL_OW 1
35204: ST_TO_ADDR
// continue ;
35205: GO 34779
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35207: LD_EXP 79
35211: PUSH
35212: LD_VAR 0 2
35216: ARRAY
35217: PUSH
35218: LD_EXP 80
35222: PUSH
35223: LD_VAR 0 2
35227: ARRAY
35228: NOT
35229: AND
35230: IFFALSE 35357
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35232: LD_ADDR_EXP 80
35236: PUSH
35237: LD_EXP 80
35241: PPUSH
35242: LD_VAR 0 2
35246: PUSH
35247: LD_EXP 80
35251: PUSH
35252: LD_VAR 0 2
35256: ARRAY
35257: PUSH
35258: LD_INT 1
35260: PLUS
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PPUSH
35266: LD_EXP 79
35270: PUSH
35271: LD_VAR 0 2
35275: ARRAY
35276: PUSH
35277: LD_INT 1
35279: ARRAY
35280: PPUSH
35281: CALL 53718 0 3
35285: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35286: LD_EXP 79
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: PUSH
35297: LD_INT 1
35299: ARRAY
35300: PPUSH
35301: LD_INT 112
35303: PPUSH
35304: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35308: LD_ADDR_VAR 0 9
35312: PUSH
35313: LD_EXP 79
35317: PUSH
35318: LD_VAR 0 2
35322: ARRAY
35323: PPUSH
35324: LD_INT 1
35326: PPUSH
35327: CALL_OW 3
35331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35332: LD_ADDR_EXP 79
35336: PUSH
35337: LD_EXP 79
35341: PPUSH
35342: LD_VAR 0 2
35346: PPUSH
35347: LD_VAR 0 9
35351: PPUSH
35352: CALL_OW 1
35356: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35357: LD_EXP 79
35361: PUSH
35362: LD_VAR 0 2
35366: ARRAY
35367: PUSH
35368: LD_EXP 80
35372: PUSH
35373: LD_VAR 0 2
35377: ARRAY
35378: AND
35379: PUSH
35380: LD_EXP 80
35384: PUSH
35385: LD_VAR 0 2
35389: ARRAY
35390: PUSH
35391: LD_INT 1
35393: ARRAY
35394: PPUSH
35395: CALL_OW 310
35399: NOT
35400: AND
35401: PUSH
35402: LD_VAR 0 3
35406: PPUSH
35407: CALL_OW 313
35411: PUSH
35412: LD_INT 6
35414: EQUAL
35415: AND
35416: IFFALSE 35472
// begin tmp2 := UnitsInside ( j ) ;
35418: LD_ADDR_VAR 0 9
35422: PUSH
35423: LD_VAR 0 3
35427: PPUSH
35428: CALL_OW 313
35432: ST_TO_ADDR
// if tmp2 = 6 then
35433: LD_VAR 0 9
35437: PUSH
35438: LD_INT 6
35440: EQUAL
35441: IFFALSE 35472
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35443: LD_VAR 0 9
35447: PUSH
35448: LD_INT 1
35450: ARRAY
35451: PPUSH
35452: LD_INT 112
35454: PPUSH
35455: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35459: LD_VAR 0 9
35463: PUSH
35464: LD_INT 1
35466: ARRAY
35467: PPUSH
35468: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35472: LD_EXP 80
35476: PUSH
35477: LD_VAR 0 2
35481: ARRAY
35482: PUSH
35483: LD_EXP 80
35487: PUSH
35488: LD_VAR 0 2
35492: ARRAY
35493: PUSH
35494: LD_INT 1
35496: ARRAY
35497: PPUSH
35498: CALL_OW 314
35502: NOT
35503: AND
35504: PUSH
35505: LD_EXP 80
35509: PUSH
35510: LD_VAR 0 2
35514: ARRAY
35515: PUSH
35516: LD_INT 1
35518: ARRAY
35519: PPUSH
35520: CALL_OW 310
35524: NOT
35525: AND
35526: IFFALSE 35552
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35528: LD_EXP 80
35532: PUSH
35533: LD_VAR 0 2
35537: ARRAY
35538: PUSH
35539: LD_INT 1
35541: ARRAY
35542: PPUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35552: LD_EXP 80
35556: PUSH
35557: LD_VAR 0 2
35561: ARRAY
35562: PUSH
35563: LD_INT 1
35565: ARRAY
35566: PPUSH
35567: CALL_OW 310
35571: PUSH
35572: LD_EXP 80
35576: PUSH
35577: LD_VAR 0 2
35581: ARRAY
35582: PUSH
35583: LD_INT 1
35585: ARRAY
35586: PPUSH
35587: CALL_OW 310
35591: PPUSH
35592: CALL_OW 461
35596: PUSH
35597: LD_INT 3
35599: NONEQUAL
35600: AND
35601: IFFALSE 35622
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35603: LD_EXP 80
35607: PUSH
35608: LD_VAR 0 2
35612: ARRAY
35613: PUSH
35614: LD_INT 1
35616: ARRAY
35617: PPUSH
35618: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35622: LD_VAR 0 3
35626: PPUSH
35627: CALL_OW 461
35631: PUSH
35632: LD_INT 6
35634: EQUAL
35635: PUSH
35636: LD_VAR 0 6
35640: PUSH
35641: LD_INT 1
35643: GREATER
35644: AND
35645: IFFALSE 35797
// begin sci := [ ] ;
35647: LD_ADDR_VAR 0 8
35651: PUSH
35652: EMPTY
35653: ST_TO_ADDR
// for x in ( tmp diff j ) do
35654: LD_ADDR_VAR 0 7
35658: PUSH
35659: LD_VAR 0 6
35663: PUSH
35664: LD_VAR 0 3
35668: DIFF
35669: PUSH
35670: FOR_IN
35671: IFFALSE 35723
// begin if sci = 6 then
35673: LD_VAR 0 8
35677: PUSH
35678: LD_INT 6
35680: EQUAL
35681: IFFALSE 35685
// break ;
35683: GO 35723
// if BuildingStatus ( x ) = bs_idle then
35685: LD_VAR 0 7
35689: PPUSH
35690: CALL_OW 461
35694: PUSH
35695: LD_INT 2
35697: EQUAL
35698: IFFALSE 35721
// sci := sci ^ UnitsInside ( x ) ;
35700: LD_ADDR_VAR 0 8
35704: PUSH
35705: LD_VAR 0 8
35709: PUSH
35710: LD_VAR 0 7
35714: PPUSH
35715: CALL_OW 313
35719: ADD
35720: ST_TO_ADDR
// end ;
35721: GO 35670
35723: POP
35724: POP
// if not sci then
35725: LD_VAR 0 8
35729: NOT
35730: IFFALSE 35734
// continue ;
35732: GO 34779
// for x in sci do
35734: LD_ADDR_VAR 0 7
35738: PUSH
35739: LD_VAR 0 8
35743: PUSH
35744: FOR_IN
35745: IFFALSE 35795
// if IsInUnit ( x ) and not HasTask ( x ) then
35747: LD_VAR 0 7
35751: PPUSH
35752: CALL_OW 310
35756: PUSH
35757: LD_VAR 0 7
35761: PPUSH
35762: CALL_OW 314
35766: NOT
35767: AND
35768: IFFALSE 35793
// begin ComExitBuilding ( x ) ;
35770: LD_VAR 0 7
35774: PPUSH
35775: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35779: LD_VAR 0 7
35783: PPUSH
35784: LD_VAR 0 3
35788: PPUSH
35789: CALL_OW 180
// end ;
35793: GO 35744
35795: POP
35796: POP
// end ; end ;
35797: GO 34779
35799: POP
35800: POP
// end ;
35801: GO 34733
35803: POP
35804: POP
// end ;
35805: LD_VAR 0 1
35809: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35810: LD_INT 0
35812: PPUSH
35813: PPUSH
// if not mc_bases then
35814: LD_EXP 50
35818: NOT
35819: IFFALSE 35823
// exit ;
35821: GO 35904
// for i = 1 to mc_bases do
35823: LD_ADDR_VAR 0 2
35827: PUSH
35828: DOUBLE
35829: LD_INT 1
35831: DEC
35832: ST_TO_ADDR
35833: LD_EXP 50
35837: PUSH
35838: FOR_TO
35839: IFFALSE 35902
// if mc_mines [ i ] and mc_miners [ i ] then
35841: LD_EXP 63
35845: PUSH
35846: LD_VAR 0 2
35850: ARRAY
35851: PUSH
35852: LD_EXP 64
35856: PUSH
35857: LD_VAR 0 2
35861: ARRAY
35862: AND
35863: IFFALSE 35900
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35865: LD_EXP 64
35869: PUSH
35870: LD_VAR 0 2
35874: ARRAY
35875: PUSH
35876: LD_INT 1
35878: ARRAY
35879: PPUSH
35880: CALL_OW 255
35884: PPUSH
35885: LD_EXP 63
35889: PUSH
35890: LD_VAR 0 2
35894: ARRAY
35895: PPUSH
35896: CALL 50518 0 2
35900: GO 35838
35902: POP
35903: POP
// end ;
35904: LD_VAR 0 1
35908: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35909: LD_INT 0
35911: PPUSH
35912: PPUSH
35913: PPUSH
35914: PPUSH
35915: PPUSH
35916: PPUSH
35917: PPUSH
35918: PPUSH
// if not mc_bases or not mc_parking then
35919: LD_EXP 50
35923: NOT
35924: PUSH
35925: LD_EXP 74
35929: NOT
35930: OR
35931: IFFALSE 35935
// exit ;
35933: GO 36645
// for i = 1 to mc_bases do
35935: LD_ADDR_VAR 0 2
35939: PUSH
35940: DOUBLE
35941: LD_INT 1
35943: DEC
35944: ST_TO_ADDR
35945: LD_EXP 50
35949: PUSH
35950: FOR_TO
35951: IFFALSE 36643
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35953: LD_EXP 50
35957: PUSH
35958: LD_VAR 0 2
35962: ARRAY
35963: NOT
35964: PUSH
35965: LD_EXP 74
35969: PUSH
35970: LD_VAR 0 2
35974: ARRAY
35975: NOT
35976: OR
35977: IFFALSE 35981
// continue ;
35979: GO 35950
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35981: LD_ADDR_VAR 0 5
35985: PUSH
35986: LD_EXP 50
35990: PUSH
35991: LD_VAR 0 2
35995: ARRAY
35996: PUSH
35997: LD_INT 1
35999: ARRAY
36000: PPUSH
36001: CALL_OW 255
36005: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36006: LD_ADDR_VAR 0 6
36010: PUSH
36011: LD_EXP 50
36015: PUSH
36016: LD_VAR 0 2
36020: ARRAY
36021: PPUSH
36022: LD_INT 30
36024: PUSH
36025: LD_INT 3
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PPUSH
36032: CALL_OW 72
36036: ST_TO_ADDR
// if not fac then
36037: LD_VAR 0 6
36041: NOT
36042: IFFALSE 36093
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36044: LD_ADDR_VAR 0 6
36048: PUSH
36049: LD_EXP 50
36053: PUSH
36054: LD_VAR 0 2
36058: ARRAY
36059: PPUSH
36060: LD_INT 2
36062: PUSH
36063: LD_INT 30
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 30
36075: PUSH
36076: LD_INT 1
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: LIST
36087: PPUSH
36088: CALL_OW 72
36092: ST_TO_ADDR
// if not fac then
36093: LD_VAR 0 6
36097: NOT
36098: IFFALSE 36102
// continue ;
36100: GO 35950
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36102: LD_ADDR_VAR 0 7
36106: PUSH
36107: LD_EXP 74
36111: PUSH
36112: LD_VAR 0 2
36116: ARRAY
36117: PPUSH
36118: LD_INT 22
36120: PUSH
36121: LD_VAR 0 5
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 21
36132: PUSH
36133: LD_INT 2
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 3
36142: PUSH
36143: LD_INT 24
36145: PUSH
36146: LD_INT 1000
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: LIST
36161: PPUSH
36162: CALL_OW 70
36166: ST_TO_ADDR
// for j in fac do
36167: LD_ADDR_VAR 0 3
36171: PUSH
36172: LD_VAR 0 6
36176: PUSH
36177: FOR_IN
36178: IFFALSE 36259
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36180: LD_ADDR_VAR 0 7
36184: PUSH
36185: LD_VAR 0 7
36189: PUSH
36190: LD_INT 22
36192: PUSH
36193: LD_VAR 0 5
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 91
36204: PUSH
36205: LD_VAR 0 3
36209: PUSH
36210: LD_INT 15
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 21
36220: PUSH
36221: LD_INT 2
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 3
36230: PUSH
36231: LD_INT 24
36233: PUSH
36234: LD_INT 1000
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: LIST
36249: LIST
36250: PPUSH
36251: CALL_OW 69
36255: UNION
36256: ST_TO_ADDR
36257: GO 36177
36259: POP
36260: POP
// if not vehs then
36261: LD_VAR 0 7
36265: NOT
36266: IFFALSE 36292
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36268: LD_ADDR_EXP 62
36272: PUSH
36273: LD_EXP 62
36277: PPUSH
36278: LD_VAR 0 2
36282: PPUSH
36283: EMPTY
36284: PPUSH
36285: CALL_OW 1
36289: ST_TO_ADDR
// continue ;
36290: GO 35950
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36292: LD_ADDR_VAR 0 8
36296: PUSH
36297: LD_EXP 50
36301: PUSH
36302: LD_VAR 0 2
36306: ARRAY
36307: PPUSH
36308: LD_INT 30
36310: PUSH
36311: LD_INT 3
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PPUSH
36318: CALL_OW 72
36322: ST_TO_ADDR
// if tmp then
36323: LD_VAR 0 8
36327: IFFALSE 36430
// begin for j in tmp do
36329: LD_ADDR_VAR 0 3
36333: PUSH
36334: LD_VAR 0 8
36338: PUSH
36339: FOR_IN
36340: IFFALSE 36428
// for k in UnitsInside ( j ) do
36342: LD_ADDR_VAR 0 4
36346: PUSH
36347: LD_VAR 0 3
36351: PPUSH
36352: CALL_OW 313
36356: PUSH
36357: FOR_IN
36358: IFFALSE 36424
// if k then
36360: LD_VAR 0 4
36364: IFFALSE 36422
// if not k in mc_repair_vehicle [ i ] then
36366: LD_VAR 0 4
36370: PUSH
36371: LD_EXP 62
36375: PUSH
36376: LD_VAR 0 2
36380: ARRAY
36381: IN
36382: NOT
36383: IFFALSE 36422
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36385: LD_ADDR_EXP 62
36389: PUSH
36390: LD_EXP 62
36394: PPUSH
36395: LD_VAR 0 2
36399: PPUSH
36400: LD_EXP 62
36404: PUSH
36405: LD_VAR 0 2
36409: ARRAY
36410: PUSH
36411: LD_VAR 0 4
36415: UNION
36416: PPUSH
36417: CALL_OW 1
36421: ST_TO_ADDR
36422: GO 36357
36424: POP
36425: POP
36426: GO 36339
36428: POP
36429: POP
// end ; if not mc_repair_vehicle [ i ] then
36430: LD_EXP 62
36434: PUSH
36435: LD_VAR 0 2
36439: ARRAY
36440: NOT
36441: IFFALSE 36445
// continue ;
36443: GO 35950
// for j in mc_repair_vehicle [ i ] do
36445: LD_ADDR_VAR 0 3
36449: PUSH
36450: LD_EXP 62
36454: PUSH
36455: LD_VAR 0 2
36459: ARRAY
36460: PUSH
36461: FOR_IN
36462: IFFALSE 36639
// begin if GetClass ( j ) <> 3 then
36464: LD_VAR 0 3
36468: PPUSH
36469: CALL_OW 257
36473: PUSH
36474: LD_INT 3
36476: NONEQUAL
36477: IFFALSE 36518
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36479: LD_ADDR_EXP 62
36483: PUSH
36484: LD_EXP 62
36488: PPUSH
36489: LD_VAR 0 2
36493: PPUSH
36494: LD_EXP 62
36498: PUSH
36499: LD_VAR 0 2
36503: ARRAY
36504: PUSH
36505: LD_VAR 0 3
36509: DIFF
36510: PPUSH
36511: CALL_OW 1
36515: ST_TO_ADDR
// continue ;
36516: GO 36461
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36518: LD_VAR 0 3
36522: PPUSH
36523: CALL_OW 311
36527: NOT
36528: PUSH
36529: LD_VAR 0 3
36533: PUSH
36534: LD_EXP 53
36538: PUSH
36539: LD_VAR 0 2
36543: ARRAY
36544: PUSH
36545: LD_INT 1
36547: ARRAY
36548: IN
36549: NOT
36550: AND
36551: PUSH
36552: LD_VAR 0 3
36556: PUSH
36557: LD_EXP 53
36561: PUSH
36562: LD_VAR 0 2
36566: ARRAY
36567: PUSH
36568: LD_INT 2
36570: ARRAY
36571: IN
36572: NOT
36573: AND
36574: IFFALSE 36637
// begin if IsInUnit ( j ) then
36576: LD_VAR 0 3
36580: PPUSH
36581: CALL_OW 310
36585: IFFALSE 36598
// ComExitBuilding ( j ) else
36587: LD_VAR 0 3
36591: PPUSH
36592: CALL_OW 122
36596: GO 36637
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36598: LD_VAR 0 3
36602: PPUSH
36603: LD_VAR 0 7
36607: PUSH
36608: LD_INT 1
36610: ARRAY
36611: PPUSH
36612: CALL 88047 0 2
36616: NOT
36617: IFFALSE 36637
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36619: LD_VAR 0 3
36623: PPUSH
36624: LD_VAR 0 7
36628: PUSH
36629: LD_INT 1
36631: ARRAY
36632: PPUSH
36633: CALL_OW 129
// end ; end ;
36637: GO 36461
36639: POP
36640: POP
// end ;
36641: GO 35950
36643: POP
36644: POP
// end ;
36645: LD_VAR 0 1
36649: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36650: LD_INT 0
36652: PPUSH
36653: PPUSH
36654: PPUSH
36655: PPUSH
36656: PPUSH
36657: PPUSH
36658: PPUSH
36659: PPUSH
36660: PPUSH
36661: PPUSH
36662: PPUSH
// if not mc_bases then
36663: LD_EXP 50
36667: NOT
36668: IFFALSE 36672
// exit ;
36670: GO 37474
// for i = 1 to mc_bases do
36672: LD_ADDR_VAR 0 2
36676: PUSH
36677: DOUBLE
36678: LD_INT 1
36680: DEC
36681: ST_TO_ADDR
36682: LD_EXP 50
36686: PUSH
36687: FOR_TO
36688: IFFALSE 37472
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36690: LD_EXP 78
36694: PUSH
36695: LD_VAR 0 2
36699: ARRAY
36700: NOT
36701: PUSH
36702: LD_EXP 53
36706: PUSH
36707: LD_VAR 0 2
36711: ARRAY
36712: PUSH
36713: LD_INT 1
36715: ARRAY
36716: OR
36717: PUSH
36718: LD_EXP 53
36722: PUSH
36723: LD_VAR 0 2
36727: ARRAY
36728: PUSH
36729: LD_INT 2
36731: ARRAY
36732: OR
36733: PUSH
36734: LD_EXP 76
36738: PUSH
36739: LD_VAR 0 2
36743: ARRAY
36744: PPUSH
36745: LD_INT 1
36747: PPUSH
36748: CALL_OW 325
36752: NOT
36753: OR
36754: PUSH
36755: LD_EXP 73
36759: PUSH
36760: LD_VAR 0 2
36764: ARRAY
36765: OR
36766: IFFALSE 36770
// continue ;
36768: GO 36687
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36770: LD_ADDR_VAR 0 8
36774: PUSH
36775: LD_EXP 50
36779: PUSH
36780: LD_VAR 0 2
36784: ARRAY
36785: PPUSH
36786: LD_INT 25
36788: PUSH
36789: LD_INT 4
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 50
36798: PUSH
36799: EMPTY
36800: LIST
36801: PUSH
36802: LD_INT 3
36804: PUSH
36805: LD_INT 60
36807: PUSH
36808: EMPTY
36809: LIST
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: LIST
36819: PPUSH
36820: CALL_OW 72
36824: PUSH
36825: LD_EXP 54
36829: PUSH
36830: LD_VAR 0 2
36834: ARRAY
36835: DIFF
36836: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36837: LD_ADDR_VAR 0 9
36841: PUSH
36842: LD_EXP 50
36846: PUSH
36847: LD_VAR 0 2
36851: ARRAY
36852: PPUSH
36853: LD_INT 2
36855: PUSH
36856: LD_INT 30
36858: PUSH
36859: LD_INT 0
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: PUSH
36866: LD_INT 30
36868: PUSH
36869: LD_INT 1
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: LIST
36880: PPUSH
36881: CALL_OW 72
36885: ST_TO_ADDR
// if not tmp or not dep then
36886: LD_VAR 0 8
36890: NOT
36891: PUSH
36892: LD_VAR 0 9
36896: NOT
36897: OR
36898: IFFALSE 36902
// continue ;
36900: GO 36687
// side := GetSide ( tmp [ 1 ] ) ;
36902: LD_ADDR_VAR 0 11
36906: PUSH
36907: LD_VAR 0 8
36911: PUSH
36912: LD_INT 1
36914: ARRAY
36915: PPUSH
36916: CALL_OW 255
36920: ST_TO_ADDR
// dep := dep [ 1 ] ;
36921: LD_ADDR_VAR 0 9
36925: PUSH
36926: LD_VAR 0 9
36930: PUSH
36931: LD_INT 1
36933: ARRAY
36934: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36935: LD_ADDR_VAR 0 7
36939: PUSH
36940: LD_EXP 78
36944: PUSH
36945: LD_VAR 0 2
36949: ARRAY
36950: PPUSH
36951: LD_INT 22
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 25
36963: PUSH
36964: LD_INT 12
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PPUSH
36975: CALL_OW 70
36979: PUSH
36980: LD_INT 22
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 25
36992: PUSH
36993: LD_INT 12
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 91
37002: PUSH
37003: LD_VAR 0 9
37007: PUSH
37008: LD_INT 20
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: LIST
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: LIST
37020: PPUSH
37021: CALL_OW 69
37025: UNION
37026: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37027: LD_ADDR_VAR 0 10
37031: PUSH
37032: LD_EXP 78
37036: PUSH
37037: LD_VAR 0 2
37041: ARRAY
37042: PPUSH
37043: LD_INT 81
37045: PUSH
37046: LD_VAR 0 11
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PPUSH
37055: CALL_OW 70
37059: ST_TO_ADDR
// if not apes or danger_at_area then
37060: LD_VAR 0 7
37064: NOT
37065: PUSH
37066: LD_VAR 0 10
37070: OR
37071: IFFALSE 37121
// begin if mc_taming [ i ] then
37073: LD_EXP 81
37077: PUSH
37078: LD_VAR 0 2
37082: ARRAY
37083: IFFALSE 37119
// begin MC_Reset ( i , 121 ) ;
37085: LD_VAR 0 2
37089: PPUSH
37090: LD_INT 121
37092: PPUSH
37093: CALL 22107 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37097: LD_ADDR_EXP 81
37101: PUSH
37102: LD_EXP 81
37106: PPUSH
37107: LD_VAR 0 2
37111: PPUSH
37112: EMPTY
37113: PPUSH
37114: CALL_OW 1
37118: ST_TO_ADDR
// end ; continue ;
37119: GO 36687
// end ; for j in tmp do
37121: LD_ADDR_VAR 0 3
37125: PUSH
37126: LD_VAR 0 8
37130: PUSH
37131: FOR_IN
37132: IFFALSE 37468
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37134: LD_VAR 0 3
37138: PUSH
37139: LD_EXP 81
37143: PUSH
37144: LD_VAR 0 2
37148: ARRAY
37149: IN
37150: NOT
37151: PUSH
37152: LD_EXP 81
37156: PUSH
37157: LD_VAR 0 2
37161: ARRAY
37162: PUSH
37163: LD_INT 3
37165: LESS
37166: AND
37167: IFFALSE 37225
// begin SetTag ( j , 121 ) ;
37169: LD_VAR 0 3
37173: PPUSH
37174: LD_INT 121
37176: PPUSH
37177: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37181: LD_ADDR_EXP 81
37185: PUSH
37186: LD_EXP 81
37190: PPUSH
37191: LD_VAR 0 2
37195: PUSH
37196: LD_EXP 81
37200: PUSH
37201: LD_VAR 0 2
37205: ARRAY
37206: PUSH
37207: LD_INT 1
37209: PLUS
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PPUSH
37215: LD_VAR 0 3
37219: PPUSH
37220: CALL 53718 0 3
37224: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37225: LD_VAR 0 3
37229: PUSH
37230: LD_EXP 81
37234: PUSH
37235: LD_VAR 0 2
37239: ARRAY
37240: IN
37241: IFFALSE 37466
// begin if GetClass ( j ) <> 4 then
37243: LD_VAR 0 3
37247: PPUSH
37248: CALL_OW 257
37252: PUSH
37253: LD_INT 4
37255: NONEQUAL
37256: IFFALSE 37309
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37258: LD_ADDR_EXP 81
37262: PUSH
37263: LD_EXP 81
37267: PPUSH
37268: LD_VAR 0 2
37272: PPUSH
37273: LD_EXP 81
37277: PUSH
37278: LD_VAR 0 2
37282: ARRAY
37283: PUSH
37284: LD_VAR 0 3
37288: DIFF
37289: PPUSH
37290: CALL_OW 1
37294: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37295: LD_VAR 0 3
37299: PPUSH
37300: LD_INT 0
37302: PPUSH
37303: CALL_OW 109
// continue ;
37307: GO 37131
// end ; if IsInUnit ( j ) then
37309: LD_VAR 0 3
37313: PPUSH
37314: CALL_OW 310
37318: IFFALSE 37329
// ComExitBuilding ( j ) ;
37320: LD_VAR 0 3
37324: PPUSH
37325: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37329: LD_ADDR_VAR 0 6
37333: PUSH
37334: LD_VAR 0 7
37338: PPUSH
37339: LD_VAR 0 3
37343: PPUSH
37344: CALL_OW 74
37348: ST_TO_ADDR
// if not ape then
37349: LD_VAR 0 6
37353: NOT
37354: IFFALSE 37358
// break ;
37356: GO 37468
// x := GetX ( ape ) ;
37358: LD_ADDR_VAR 0 4
37362: PUSH
37363: LD_VAR 0 6
37367: PPUSH
37368: CALL_OW 250
37372: ST_TO_ADDR
// y := GetY ( ape ) ;
37373: LD_ADDR_VAR 0 5
37377: PUSH
37378: LD_VAR 0 6
37382: PPUSH
37383: CALL_OW 251
37387: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37388: LD_VAR 0 4
37392: PPUSH
37393: LD_VAR 0 5
37397: PPUSH
37398: CALL_OW 488
37402: NOT
37403: PUSH
37404: LD_VAR 0 11
37408: PPUSH
37409: LD_VAR 0 4
37413: PPUSH
37414: LD_VAR 0 5
37418: PPUSH
37419: LD_INT 20
37421: PPUSH
37422: CALL 54614 0 4
37426: PUSH
37427: LD_INT 4
37429: ARRAY
37430: OR
37431: IFFALSE 37435
// break ;
37433: GO 37468
// if not HasTask ( j ) then
37435: LD_VAR 0 3
37439: PPUSH
37440: CALL_OW 314
37444: NOT
37445: IFFALSE 37466
// ComTameXY ( j , x , y ) ;
37447: LD_VAR 0 3
37451: PPUSH
37452: LD_VAR 0 4
37456: PPUSH
37457: LD_VAR 0 5
37461: PPUSH
37462: CALL_OW 131
// end ; end ;
37466: GO 37131
37468: POP
37469: POP
// end ;
37470: GO 36687
37472: POP
37473: POP
// end ;
37474: LD_VAR 0 1
37478: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37479: LD_INT 0
37481: PPUSH
37482: PPUSH
37483: PPUSH
37484: PPUSH
37485: PPUSH
37486: PPUSH
37487: PPUSH
37488: PPUSH
// if not mc_bases then
37489: LD_EXP 50
37493: NOT
37494: IFFALSE 37498
// exit ;
37496: GO 38124
// for i = 1 to mc_bases do
37498: LD_ADDR_VAR 0 2
37502: PUSH
37503: DOUBLE
37504: LD_INT 1
37506: DEC
37507: ST_TO_ADDR
37508: LD_EXP 50
37512: PUSH
37513: FOR_TO
37514: IFFALSE 38122
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37516: LD_EXP 79
37520: PUSH
37521: LD_VAR 0 2
37525: ARRAY
37526: NOT
37527: PUSH
37528: LD_EXP 79
37532: PUSH
37533: LD_VAR 0 2
37537: ARRAY
37538: PPUSH
37539: LD_INT 25
37541: PUSH
37542: LD_INT 12
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PPUSH
37549: CALL_OW 72
37553: NOT
37554: OR
37555: IFFALSE 37559
// continue ;
37557: GO 37513
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37559: LD_ADDR_VAR 0 5
37563: PUSH
37564: LD_EXP 79
37568: PUSH
37569: LD_VAR 0 2
37573: ARRAY
37574: PUSH
37575: LD_INT 1
37577: ARRAY
37578: PPUSH
37579: CALL_OW 255
37583: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37584: LD_VAR 0 5
37588: PPUSH
37589: LD_INT 2
37591: PPUSH
37592: CALL_OW 325
37596: IFFALSE 37849
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37598: LD_ADDR_VAR 0 4
37602: PUSH
37603: LD_EXP 79
37607: PUSH
37608: LD_VAR 0 2
37612: ARRAY
37613: PPUSH
37614: LD_INT 25
37616: PUSH
37617: LD_INT 16
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PPUSH
37624: CALL_OW 72
37628: ST_TO_ADDR
// if tmp < 6 then
37629: LD_VAR 0 4
37633: PUSH
37634: LD_INT 6
37636: LESS
37637: IFFALSE 37849
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37639: LD_ADDR_VAR 0 6
37643: PUSH
37644: LD_EXP 50
37648: PUSH
37649: LD_VAR 0 2
37653: ARRAY
37654: PPUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 30
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 30
37670: PUSH
37671: LD_INT 1
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: LIST
37682: PPUSH
37683: CALL_OW 72
37687: ST_TO_ADDR
// if depot then
37688: LD_VAR 0 6
37692: IFFALSE 37849
// begin selected := 0 ;
37694: LD_ADDR_VAR 0 7
37698: PUSH
37699: LD_INT 0
37701: ST_TO_ADDR
// for j in depot do
37702: LD_ADDR_VAR 0 3
37706: PUSH
37707: LD_VAR 0 6
37711: PUSH
37712: FOR_IN
37713: IFFALSE 37744
// begin if UnitsInside ( j ) < 6 then
37715: LD_VAR 0 3
37719: PPUSH
37720: CALL_OW 313
37724: PUSH
37725: LD_INT 6
37727: LESS
37728: IFFALSE 37742
// begin selected := j ;
37730: LD_ADDR_VAR 0 7
37734: PUSH
37735: LD_VAR 0 3
37739: ST_TO_ADDR
// break ;
37740: GO 37744
// end ; end ;
37742: GO 37712
37744: POP
37745: POP
// if selected then
37746: LD_VAR 0 7
37750: IFFALSE 37849
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37752: LD_ADDR_VAR 0 3
37756: PUSH
37757: LD_EXP 79
37761: PUSH
37762: LD_VAR 0 2
37766: ARRAY
37767: PPUSH
37768: LD_INT 25
37770: PUSH
37771: LD_INT 12
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PPUSH
37778: CALL_OW 72
37782: PUSH
37783: FOR_IN
37784: IFFALSE 37847
// if not HasTask ( j ) then
37786: LD_VAR 0 3
37790: PPUSH
37791: CALL_OW 314
37795: NOT
37796: IFFALSE 37845
// begin if not IsInUnit ( j ) then
37798: LD_VAR 0 3
37802: PPUSH
37803: CALL_OW 310
37807: NOT
37808: IFFALSE 37824
// ComEnterUnit ( j , selected ) ;
37810: LD_VAR 0 3
37814: PPUSH
37815: LD_VAR 0 7
37819: PPUSH
37820: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37824: LD_VAR 0 3
37828: PPUSH
37829: LD_INT 16
37831: PPUSH
37832: CALL_OW 183
// AddComExitBuilding ( j ) ;
37836: LD_VAR 0 3
37840: PPUSH
37841: CALL_OW 182
// end ;
37845: GO 37783
37847: POP
37848: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37849: LD_VAR 0 5
37853: PPUSH
37854: LD_INT 11
37856: PPUSH
37857: CALL_OW 325
37861: IFFALSE 38120
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37863: LD_ADDR_VAR 0 4
37867: PUSH
37868: LD_EXP 79
37872: PUSH
37873: LD_VAR 0 2
37877: ARRAY
37878: PPUSH
37879: LD_INT 25
37881: PUSH
37882: LD_INT 16
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PPUSH
37889: CALL_OW 72
37893: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37894: LD_VAR 0 4
37898: PUSH
37899: LD_INT 6
37901: GREATEREQUAL
37902: PUSH
37903: LD_VAR 0 5
37907: PPUSH
37908: LD_INT 2
37910: PPUSH
37911: CALL_OW 325
37915: NOT
37916: OR
37917: IFFALSE 38120
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37919: LD_ADDR_VAR 0 8
37923: PUSH
37924: LD_EXP 50
37928: PUSH
37929: LD_VAR 0 2
37933: ARRAY
37934: PPUSH
37935: LD_INT 2
37937: PUSH
37938: LD_INT 30
37940: PUSH
37941: LD_INT 4
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 30
37950: PUSH
37951: LD_INT 5
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: LIST
37962: PPUSH
37963: CALL_OW 72
37967: ST_TO_ADDR
// if barracks then
37968: LD_VAR 0 8
37972: IFFALSE 38120
// begin selected := 0 ;
37974: LD_ADDR_VAR 0 7
37978: PUSH
37979: LD_INT 0
37981: ST_TO_ADDR
// for j in barracks do
37982: LD_ADDR_VAR 0 3
37986: PUSH
37987: LD_VAR 0 8
37991: PUSH
37992: FOR_IN
37993: IFFALSE 38024
// begin if UnitsInside ( j ) < 6 then
37995: LD_VAR 0 3
37999: PPUSH
38000: CALL_OW 313
38004: PUSH
38005: LD_INT 6
38007: LESS
38008: IFFALSE 38022
// begin selected := j ;
38010: LD_ADDR_VAR 0 7
38014: PUSH
38015: LD_VAR 0 3
38019: ST_TO_ADDR
// break ;
38020: GO 38024
// end ; end ;
38022: GO 37992
38024: POP
38025: POP
// if selected then
38026: LD_VAR 0 7
38030: IFFALSE 38120
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38032: LD_ADDR_VAR 0 3
38036: PUSH
38037: LD_EXP 79
38041: PUSH
38042: LD_VAR 0 2
38046: ARRAY
38047: PPUSH
38048: LD_INT 25
38050: PUSH
38051: LD_INT 12
38053: PUSH
38054: EMPTY
38055: LIST
38056: LIST
38057: PPUSH
38058: CALL_OW 72
38062: PUSH
38063: FOR_IN
38064: IFFALSE 38118
// if not IsInUnit ( j ) and not HasTask ( j ) then
38066: LD_VAR 0 3
38070: PPUSH
38071: CALL_OW 310
38075: NOT
38076: PUSH
38077: LD_VAR 0 3
38081: PPUSH
38082: CALL_OW 314
38086: NOT
38087: AND
38088: IFFALSE 38116
// begin ComEnterUnit ( j , selected ) ;
38090: LD_VAR 0 3
38094: PPUSH
38095: LD_VAR 0 7
38099: PPUSH
38100: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38104: LD_VAR 0 3
38108: PPUSH
38109: LD_INT 15
38111: PPUSH
38112: CALL_OW 183
// end ;
38116: GO 38063
38118: POP
38119: POP
// end ; end ; end ; end ; end ;
38120: GO 37513
38122: POP
38123: POP
// end ;
38124: LD_VAR 0 1
38128: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38129: LD_INT 0
38131: PPUSH
38132: PPUSH
38133: PPUSH
38134: PPUSH
// if not mc_bases then
38135: LD_EXP 50
38139: NOT
38140: IFFALSE 38144
// exit ;
38142: GO 38322
// for i = 1 to mc_bases do
38144: LD_ADDR_VAR 0 2
38148: PUSH
38149: DOUBLE
38150: LD_INT 1
38152: DEC
38153: ST_TO_ADDR
38154: LD_EXP 50
38158: PUSH
38159: FOR_TO
38160: IFFALSE 38320
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38162: LD_ADDR_VAR 0 4
38166: PUSH
38167: LD_EXP 50
38171: PUSH
38172: LD_VAR 0 2
38176: ARRAY
38177: PPUSH
38178: LD_INT 25
38180: PUSH
38181: LD_INT 9
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PPUSH
38188: CALL_OW 72
38192: ST_TO_ADDR
// if not tmp then
38193: LD_VAR 0 4
38197: NOT
38198: IFFALSE 38202
// continue ;
38200: GO 38159
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38202: LD_EXP 76
38206: PUSH
38207: LD_VAR 0 2
38211: ARRAY
38212: PPUSH
38213: LD_INT 29
38215: PPUSH
38216: CALL_OW 325
38220: NOT
38221: PUSH
38222: LD_EXP 76
38226: PUSH
38227: LD_VAR 0 2
38231: ARRAY
38232: PPUSH
38233: LD_INT 28
38235: PPUSH
38236: CALL_OW 325
38240: NOT
38241: AND
38242: IFFALSE 38246
// continue ;
38244: GO 38159
// for j in tmp do
38246: LD_ADDR_VAR 0 3
38250: PUSH
38251: LD_VAR 0 4
38255: PUSH
38256: FOR_IN
38257: IFFALSE 38316
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38259: LD_VAR 0 3
38263: PUSH
38264: LD_EXP 53
38268: PUSH
38269: LD_VAR 0 2
38273: ARRAY
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: IN
38279: NOT
38280: PUSH
38281: LD_VAR 0 3
38285: PUSH
38286: LD_EXP 53
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PUSH
38297: LD_INT 2
38299: ARRAY
38300: IN
38301: NOT
38302: AND
38303: IFFALSE 38314
// ComSpaceTimeShoot ( j ) ;
38305: LD_VAR 0 3
38309: PPUSH
38310: CALL 49526 0 1
38314: GO 38256
38316: POP
38317: POP
// end ;
38318: GO 38159
38320: POP
38321: POP
// end ;
38322: LD_VAR 0 1
38326: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38327: LD_INT 0
38329: PPUSH
38330: PPUSH
38331: PPUSH
38332: PPUSH
38333: PPUSH
38334: PPUSH
38335: PPUSH
38336: PPUSH
38337: PPUSH
// if not mc_bases then
38338: LD_EXP 50
38342: NOT
38343: IFFALSE 38347
// exit ;
38345: GO 38969
// for i = 1 to mc_bases do
38347: LD_ADDR_VAR 0 2
38351: PUSH
38352: DOUBLE
38353: LD_INT 1
38355: DEC
38356: ST_TO_ADDR
38357: LD_EXP 50
38361: PUSH
38362: FOR_TO
38363: IFFALSE 38967
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38365: LD_EXP 85
38369: PUSH
38370: LD_VAR 0 2
38374: ARRAY
38375: NOT
38376: PUSH
38377: LD_INT 38
38379: PPUSH
38380: LD_EXP 76
38384: PUSH
38385: LD_VAR 0 2
38389: ARRAY
38390: PPUSH
38391: CALL_OW 321
38395: PUSH
38396: LD_INT 2
38398: NONEQUAL
38399: OR
38400: IFFALSE 38404
// continue ;
38402: GO 38362
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38404: LD_ADDR_VAR 0 8
38408: PUSH
38409: LD_EXP 50
38413: PUSH
38414: LD_VAR 0 2
38418: ARRAY
38419: PPUSH
38420: LD_INT 30
38422: PUSH
38423: LD_INT 34
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PPUSH
38430: CALL_OW 72
38434: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38435: LD_ADDR_VAR 0 9
38439: PUSH
38440: LD_EXP 50
38444: PUSH
38445: LD_VAR 0 2
38449: ARRAY
38450: PPUSH
38451: LD_INT 25
38453: PUSH
38454: LD_INT 4
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PPUSH
38461: CALL_OW 72
38465: PPUSH
38466: LD_INT 0
38468: PPUSH
38469: CALL 83554 0 2
38473: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38474: LD_VAR 0 9
38478: NOT
38479: PUSH
38480: LD_VAR 0 8
38484: NOT
38485: OR
38486: PUSH
38487: LD_EXP 50
38491: PUSH
38492: LD_VAR 0 2
38496: ARRAY
38497: PPUSH
38498: LD_INT 124
38500: PPUSH
38501: CALL 83554 0 2
38505: OR
38506: IFFALSE 38510
// continue ;
38508: GO 38362
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38510: LD_EXP 86
38514: PUSH
38515: LD_VAR 0 2
38519: ARRAY
38520: PUSH
38521: LD_EXP 85
38525: PUSH
38526: LD_VAR 0 2
38530: ARRAY
38531: LESS
38532: PUSH
38533: LD_EXP 86
38537: PUSH
38538: LD_VAR 0 2
38542: ARRAY
38543: PUSH
38544: LD_VAR 0 8
38548: LESS
38549: AND
38550: IFFALSE 38965
// begin tmp := sci [ 1 ] ;
38552: LD_ADDR_VAR 0 7
38556: PUSH
38557: LD_VAR 0 9
38561: PUSH
38562: LD_INT 1
38564: ARRAY
38565: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38566: LD_VAR 0 7
38570: PPUSH
38571: LD_INT 124
38573: PPUSH
38574: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38578: LD_ADDR_VAR 0 3
38582: PUSH
38583: DOUBLE
38584: LD_EXP 85
38588: PUSH
38589: LD_VAR 0 2
38593: ARRAY
38594: INC
38595: ST_TO_ADDR
38596: LD_EXP 85
38600: PUSH
38601: LD_VAR 0 2
38605: ARRAY
38606: PUSH
38607: FOR_DOWNTO
38608: IFFALSE 38951
// begin if IsInUnit ( tmp ) then
38610: LD_VAR 0 7
38614: PPUSH
38615: CALL_OW 310
38619: IFFALSE 38630
// ComExitBuilding ( tmp ) ;
38621: LD_VAR 0 7
38625: PPUSH
38626: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38630: LD_INT 35
38632: PPUSH
38633: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38637: LD_VAR 0 7
38641: PPUSH
38642: CALL_OW 310
38646: NOT
38647: PUSH
38648: LD_VAR 0 7
38652: PPUSH
38653: CALL_OW 314
38657: NOT
38658: AND
38659: IFFALSE 38630
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38661: LD_ADDR_VAR 0 6
38665: PUSH
38666: LD_VAR 0 7
38670: PPUSH
38671: CALL_OW 250
38675: PUSH
38676: LD_VAR 0 7
38680: PPUSH
38681: CALL_OW 251
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38690: LD_INT 35
38692: PPUSH
38693: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38697: LD_ADDR_VAR 0 4
38701: PUSH
38702: LD_EXP 85
38706: PUSH
38707: LD_VAR 0 2
38711: ARRAY
38712: PUSH
38713: LD_VAR 0 3
38717: ARRAY
38718: PUSH
38719: LD_INT 1
38721: ARRAY
38722: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38723: LD_ADDR_VAR 0 5
38727: PUSH
38728: LD_EXP 85
38732: PUSH
38733: LD_VAR 0 2
38737: ARRAY
38738: PUSH
38739: LD_VAR 0 3
38743: ARRAY
38744: PUSH
38745: LD_INT 2
38747: ARRAY
38748: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38749: LD_VAR 0 7
38753: PPUSH
38754: LD_INT 10
38756: PPUSH
38757: CALL 56317 0 2
38761: PUSH
38762: LD_INT 4
38764: ARRAY
38765: IFFALSE 38803
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38767: LD_VAR 0 7
38771: PPUSH
38772: LD_VAR 0 6
38776: PUSH
38777: LD_INT 1
38779: ARRAY
38780: PPUSH
38781: LD_VAR 0 6
38785: PUSH
38786: LD_INT 2
38788: ARRAY
38789: PPUSH
38790: CALL_OW 111
// wait ( 0 0$10 ) ;
38794: LD_INT 350
38796: PPUSH
38797: CALL_OW 67
// end else
38801: GO 38829
// begin ComMoveXY ( tmp , x , y ) ;
38803: LD_VAR 0 7
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_VAR 0 5
38817: PPUSH
38818: CALL_OW 111
// wait ( 0 0$3 ) ;
38822: LD_INT 105
38824: PPUSH
38825: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38829: LD_VAR 0 7
38833: PPUSH
38834: LD_VAR 0 4
38838: PPUSH
38839: LD_VAR 0 5
38843: PPUSH
38844: CALL_OW 307
38848: IFFALSE 38690
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38850: LD_VAR 0 7
38854: PPUSH
38855: LD_VAR 0 4
38859: PPUSH
38860: LD_VAR 0 5
38864: PPUSH
38865: LD_VAR 0 8
38869: PUSH
38870: LD_VAR 0 3
38874: ARRAY
38875: PPUSH
38876: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38880: LD_INT 35
38882: PPUSH
38883: CALL_OW 67
// until not HasTask ( tmp ) ;
38887: LD_VAR 0 7
38891: PPUSH
38892: CALL_OW 314
38896: NOT
38897: IFFALSE 38880
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38899: LD_ADDR_EXP 86
38903: PUSH
38904: LD_EXP 86
38908: PPUSH
38909: LD_VAR 0 2
38913: PUSH
38914: LD_EXP 86
38918: PUSH
38919: LD_VAR 0 2
38923: ARRAY
38924: PUSH
38925: LD_INT 1
38927: PLUS
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PPUSH
38933: LD_VAR 0 8
38937: PUSH
38938: LD_VAR 0 3
38942: ARRAY
38943: PPUSH
38944: CALL 53718 0 3
38948: ST_TO_ADDR
// end ;
38949: GO 38607
38951: POP
38952: POP
// MC_Reset ( i , 124 ) ;
38953: LD_VAR 0 2
38957: PPUSH
38958: LD_INT 124
38960: PPUSH
38961: CALL 22107 0 2
// end ; end ;
38965: GO 38362
38967: POP
38968: POP
// end ;
38969: LD_VAR 0 1
38973: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38974: LD_INT 0
38976: PPUSH
38977: PPUSH
38978: PPUSH
// if not mc_bases then
38979: LD_EXP 50
38983: NOT
38984: IFFALSE 38988
// exit ;
38986: GO 39594
// for i = 1 to mc_bases do
38988: LD_ADDR_VAR 0 2
38992: PUSH
38993: DOUBLE
38994: LD_INT 1
38996: DEC
38997: ST_TO_ADDR
38998: LD_EXP 50
39002: PUSH
39003: FOR_TO
39004: IFFALSE 39592
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39006: LD_ADDR_VAR 0 3
39010: PUSH
39011: LD_EXP 50
39015: PUSH
39016: LD_VAR 0 2
39020: ARRAY
39021: PPUSH
39022: LD_INT 25
39024: PUSH
39025: LD_INT 4
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PPUSH
39032: CALL_OW 72
39036: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39037: LD_VAR 0 3
39041: NOT
39042: PUSH
39043: LD_EXP 87
39047: PUSH
39048: LD_VAR 0 2
39052: ARRAY
39053: NOT
39054: OR
39055: PUSH
39056: LD_EXP 50
39060: PUSH
39061: LD_VAR 0 2
39065: ARRAY
39066: PPUSH
39067: LD_INT 2
39069: PUSH
39070: LD_INT 30
39072: PUSH
39073: LD_INT 0
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 30
39082: PUSH
39083: LD_INT 1
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: LIST
39094: PPUSH
39095: CALL_OW 72
39099: NOT
39100: OR
39101: IFFALSE 39151
// begin if mc_deposits_finder [ i ] then
39103: LD_EXP 88
39107: PUSH
39108: LD_VAR 0 2
39112: ARRAY
39113: IFFALSE 39149
// begin MC_Reset ( i , 125 ) ;
39115: LD_VAR 0 2
39119: PPUSH
39120: LD_INT 125
39122: PPUSH
39123: CALL 22107 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39127: LD_ADDR_EXP 88
39131: PUSH
39132: LD_EXP 88
39136: PPUSH
39137: LD_VAR 0 2
39141: PPUSH
39142: EMPTY
39143: PPUSH
39144: CALL_OW 1
39148: ST_TO_ADDR
// end ; continue ;
39149: GO 39003
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39151: LD_EXP 87
39155: PUSH
39156: LD_VAR 0 2
39160: ARRAY
39161: PUSH
39162: LD_INT 1
39164: ARRAY
39165: PUSH
39166: LD_INT 3
39168: ARRAY
39169: PUSH
39170: LD_INT 1
39172: EQUAL
39173: PUSH
39174: LD_INT 20
39176: PPUSH
39177: LD_EXP 76
39181: PUSH
39182: LD_VAR 0 2
39186: ARRAY
39187: PPUSH
39188: CALL_OW 321
39192: PUSH
39193: LD_INT 2
39195: NONEQUAL
39196: AND
39197: IFFALSE 39247
// begin if mc_deposits_finder [ i ] then
39199: LD_EXP 88
39203: PUSH
39204: LD_VAR 0 2
39208: ARRAY
39209: IFFALSE 39245
// begin MC_Reset ( i , 125 ) ;
39211: LD_VAR 0 2
39215: PPUSH
39216: LD_INT 125
39218: PPUSH
39219: CALL 22107 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39223: LD_ADDR_EXP 88
39227: PUSH
39228: LD_EXP 88
39232: PPUSH
39233: LD_VAR 0 2
39237: PPUSH
39238: EMPTY
39239: PPUSH
39240: CALL_OW 1
39244: ST_TO_ADDR
// end ; continue ;
39245: GO 39003
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39247: LD_EXP 87
39251: PUSH
39252: LD_VAR 0 2
39256: ARRAY
39257: PUSH
39258: LD_INT 1
39260: ARRAY
39261: PUSH
39262: LD_INT 1
39264: ARRAY
39265: PPUSH
39266: LD_EXP 87
39270: PUSH
39271: LD_VAR 0 2
39275: ARRAY
39276: PUSH
39277: LD_INT 1
39279: ARRAY
39280: PUSH
39281: LD_INT 2
39283: ARRAY
39284: PPUSH
39285: LD_EXP 76
39289: PUSH
39290: LD_VAR 0 2
39294: ARRAY
39295: PPUSH
39296: CALL_OW 440
39300: IFFALSE 39343
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39302: LD_ADDR_EXP 87
39306: PUSH
39307: LD_EXP 87
39311: PPUSH
39312: LD_VAR 0 2
39316: PPUSH
39317: LD_EXP 87
39321: PUSH
39322: LD_VAR 0 2
39326: ARRAY
39327: PPUSH
39328: LD_INT 1
39330: PPUSH
39331: CALL_OW 3
39335: PPUSH
39336: CALL_OW 1
39340: ST_TO_ADDR
39341: GO 39590
// begin if not mc_deposits_finder [ i ] then
39343: LD_EXP 88
39347: PUSH
39348: LD_VAR 0 2
39352: ARRAY
39353: NOT
39354: IFFALSE 39406
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39356: LD_ADDR_EXP 88
39360: PUSH
39361: LD_EXP 88
39365: PPUSH
39366: LD_VAR 0 2
39370: PPUSH
39371: LD_VAR 0 3
39375: PUSH
39376: LD_INT 1
39378: ARRAY
39379: PUSH
39380: EMPTY
39381: LIST
39382: PPUSH
39383: CALL_OW 1
39387: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39388: LD_VAR 0 3
39392: PUSH
39393: LD_INT 1
39395: ARRAY
39396: PPUSH
39397: LD_INT 125
39399: PPUSH
39400: CALL_OW 109
// end else
39404: GO 39590
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39406: LD_EXP 88
39410: PUSH
39411: LD_VAR 0 2
39415: ARRAY
39416: PUSH
39417: LD_INT 1
39419: ARRAY
39420: PPUSH
39421: CALL_OW 310
39425: IFFALSE 39448
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39427: LD_EXP 88
39431: PUSH
39432: LD_VAR 0 2
39436: ARRAY
39437: PUSH
39438: LD_INT 1
39440: ARRAY
39441: PPUSH
39442: CALL_OW 122
39446: GO 39590
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39448: LD_EXP 88
39452: PUSH
39453: LD_VAR 0 2
39457: ARRAY
39458: PUSH
39459: LD_INT 1
39461: ARRAY
39462: PPUSH
39463: CALL_OW 314
39467: NOT
39468: PUSH
39469: LD_EXP 88
39473: PUSH
39474: LD_VAR 0 2
39478: ARRAY
39479: PUSH
39480: LD_INT 1
39482: ARRAY
39483: PPUSH
39484: LD_EXP 87
39488: PUSH
39489: LD_VAR 0 2
39493: ARRAY
39494: PUSH
39495: LD_INT 1
39497: ARRAY
39498: PUSH
39499: LD_INT 1
39501: ARRAY
39502: PPUSH
39503: LD_EXP 87
39507: PUSH
39508: LD_VAR 0 2
39512: ARRAY
39513: PUSH
39514: LD_INT 1
39516: ARRAY
39517: PUSH
39518: LD_INT 2
39520: ARRAY
39521: PPUSH
39522: CALL_OW 297
39526: PUSH
39527: LD_INT 6
39529: GREATER
39530: AND
39531: IFFALSE 39590
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39533: LD_EXP 88
39537: PUSH
39538: LD_VAR 0 2
39542: ARRAY
39543: PUSH
39544: LD_INT 1
39546: ARRAY
39547: PPUSH
39548: LD_EXP 87
39552: PUSH
39553: LD_VAR 0 2
39557: ARRAY
39558: PUSH
39559: LD_INT 1
39561: ARRAY
39562: PUSH
39563: LD_INT 1
39565: ARRAY
39566: PPUSH
39567: LD_EXP 87
39571: PUSH
39572: LD_VAR 0 2
39576: ARRAY
39577: PUSH
39578: LD_INT 1
39580: ARRAY
39581: PUSH
39582: LD_INT 2
39584: ARRAY
39585: PPUSH
39586: CALL_OW 111
// end ; end ; end ;
39590: GO 39003
39592: POP
39593: POP
// end ;
39594: LD_VAR 0 1
39598: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39599: LD_INT 0
39601: PPUSH
39602: PPUSH
39603: PPUSH
39604: PPUSH
39605: PPUSH
39606: PPUSH
39607: PPUSH
39608: PPUSH
39609: PPUSH
39610: PPUSH
39611: PPUSH
// if not mc_bases then
39612: LD_EXP 50
39616: NOT
39617: IFFALSE 39621
// exit ;
39619: GO 40561
// for i = 1 to mc_bases do
39621: LD_ADDR_VAR 0 2
39625: PUSH
39626: DOUBLE
39627: LD_INT 1
39629: DEC
39630: ST_TO_ADDR
39631: LD_EXP 50
39635: PUSH
39636: FOR_TO
39637: IFFALSE 40559
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39639: LD_EXP 50
39643: PUSH
39644: LD_VAR 0 2
39648: ARRAY
39649: NOT
39650: PUSH
39651: LD_EXP 73
39655: PUSH
39656: LD_VAR 0 2
39660: ARRAY
39661: OR
39662: IFFALSE 39666
// continue ;
39664: GO 39636
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39666: LD_ADDR_VAR 0 7
39670: PUSH
39671: LD_EXP 50
39675: PUSH
39676: LD_VAR 0 2
39680: ARRAY
39681: PUSH
39682: LD_INT 1
39684: ARRAY
39685: PPUSH
39686: CALL_OW 248
39690: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39691: LD_VAR 0 7
39695: PUSH
39696: LD_INT 3
39698: EQUAL
39699: PUSH
39700: LD_EXP 69
39704: PUSH
39705: LD_VAR 0 2
39709: ARRAY
39710: PUSH
39711: LD_EXP 72
39715: PUSH
39716: LD_VAR 0 2
39720: ARRAY
39721: UNION
39722: PPUSH
39723: LD_INT 33
39725: PUSH
39726: LD_INT 2
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PPUSH
39733: CALL_OW 72
39737: NOT
39738: OR
39739: IFFALSE 39743
// continue ;
39741: GO 39636
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39743: LD_ADDR_VAR 0 9
39747: PUSH
39748: LD_EXP 50
39752: PUSH
39753: LD_VAR 0 2
39757: ARRAY
39758: PPUSH
39759: LD_INT 30
39761: PUSH
39762: LD_INT 36
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PPUSH
39769: CALL_OW 72
39773: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39774: LD_ADDR_VAR 0 10
39778: PUSH
39779: LD_EXP 69
39783: PUSH
39784: LD_VAR 0 2
39788: ARRAY
39789: PPUSH
39790: LD_INT 34
39792: PUSH
39793: LD_INT 31
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PPUSH
39800: CALL_OW 72
39804: ST_TO_ADDR
// if not cts and not mcts then
39805: LD_VAR 0 9
39809: NOT
39810: PUSH
39811: LD_VAR 0 10
39815: NOT
39816: AND
39817: IFFALSE 39821
// continue ;
39819: GO 39636
// x := cts ;
39821: LD_ADDR_VAR 0 11
39825: PUSH
39826: LD_VAR 0 9
39830: ST_TO_ADDR
// if not x then
39831: LD_VAR 0 11
39835: NOT
39836: IFFALSE 39848
// x := mcts ;
39838: LD_ADDR_VAR 0 11
39842: PUSH
39843: LD_VAR 0 10
39847: ST_TO_ADDR
// if not x then
39848: LD_VAR 0 11
39852: NOT
39853: IFFALSE 39857
// continue ;
39855: GO 39636
// if mc_remote_driver [ i ] then
39857: LD_EXP 90
39861: PUSH
39862: LD_VAR 0 2
39866: ARRAY
39867: IFFALSE 40254
// for j in mc_remote_driver [ i ] do
39869: LD_ADDR_VAR 0 3
39873: PUSH
39874: LD_EXP 90
39878: PUSH
39879: LD_VAR 0 2
39883: ARRAY
39884: PUSH
39885: FOR_IN
39886: IFFALSE 40252
// begin if GetClass ( j ) <> 3 then
39888: LD_VAR 0 3
39892: PPUSH
39893: CALL_OW 257
39897: PUSH
39898: LD_INT 3
39900: NONEQUAL
39901: IFFALSE 39954
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39903: LD_ADDR_EXP 90
39907: PUSH
39908: LD_EXP 90
39912: PPUSH
39913: LD_VAR 0 2
39917: PPUSH
39918: LD_EXP 90
39922: PUSH
39923: LD_VAR 0 2
39927: ARRAY
39928: PUSH
39929: LD_VAR 0 3
39933: DIFF
39934: PPUSH
39935: CALL_OW 1
39939: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39940: LD_VAR 0 3
39944: PPUSH
39945: LD_INT 0
39947: PPUSH
39948: CALL_OW 109
// continue ;
39952: GO 39885
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39954: LD_EXP 69
39958: PUSH
39959: LD_VAR 0 2
39963: ARRAY
39964: PPUSH
39965: LD_INT 34
39967: PUSH
39968: LD_INT 31
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 58
39977: PUSH
39978: EMPTY
39979: LIST
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PPUSH
39985: CALL_OW 72
39989: PUSH
39990: LD_VAR 0 3
39994: PPUSH
39995: CALL 83589 0 1
39999: NOT
40000: AND
40001: IFFALSE 40072
// begin if IsInUnit ( j ) then
40003: LD_VAR 0 3
40007: PPUSH
40008: CALL_OW 310
40012: IFFALSE 40023
// ComExitBuilding ( j ) ;
40014: LD_VAR 0 3
40018: PPUSH
40019: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40023: LD_VAR 0 3
40027: PPUSH
40028: LD_EXP 69
40032: PUSH
40033: LD_VAR 0 2
40037: ARRAY
40038: PPUSH
40039: LD_INT 34
40041: PUSH
40042: LD_INT 31
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 58
40051: PUSH
40052: EMPTY
40053: LIST
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PPUSH
40059: CALL_OW 72
40063: PUSH
40064: LD_INT 1
40066: ARRAY
40067: PPUSH
40068: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40072: LD_VAR 0 3
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: PUSH
40083: LD_VAR 0 3
40087: PPUSH
40088: CALL_OW 310
40092: PPUSH
40093: CALL_OW 266
40097: PUSH
40098: LD_INT 36
40100: NONEQUAL
40101: PUSH
40102: LD_VAR 0 3
40106: PPUSH
40107: CALL 83589 0 1
40111: NOT
40112: AND
40113: OR
40114: IFFALSE 40250
// begin if IsInUnit ( j ) then
40116: LD_VAR 0 3
40120: PPUSH
40121: CALL_OW 310
40125: IFFALSE 40136
// ComExitBuilding ( j ) ;
40127: LD_VAR 0 3
40131: PPUSH
40132: CALL_OW 122
// ct := 0 ;
40136: LD_ADDR_VAR 0 8
40140: PUSH
40141: LD_INT 0
40143: ST_TO_ADDR
// for k in x do
40144: LD_ADDR_VAR 0 4
40148: PUSH
40149: LD_VAR 0 11
40153: PUSH
40154: FOR_IN
40155: IFFALSE 40228
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40157: LD_VAR 0 4
40161: PPUSH
40162: CALL_OW 264
40166: PUSH
40167: LD_INT 31
40169: EQUAL
40170: PUSH
40171: LD_VAR 0 4
40175: PPUSH
40176: CALL_OW 311
40180: NOT
40181: AND
40182: PUSH
40183: LD_VAR 0 4
40187: PPUSH
40188: CALL_OW 266
40192: PUSH
40193: LD_INT 36
40195: EQUAL
40196: PUSH
40197: LD_VAR 0 4
40201: PPUSH
40202: CALL_OW 313
40206: PUSH
40207: LD_INT 3
40209: LESS
40210: AND
40211: OR
40212: IFFALSE 40226
// begin ct := k ;
40214: LD_ADDR_VAR 0 8
40218: PUSH
40219: LD_VAR 0 4
40223: ST_TO_ADDR
// break ;
40224: GO 40228
// end ;
40226: GO 40154
40228: POP
40229: POP
// if ct then
40230: LD_VAR 0 8
40234: IFFALSE 40250
// ComEnterUnit ( j , ct ) ;
40236: LD_VAR 0 3
40240: PPUSH
40241: LD_VAR 0 8
40245: PPUSH
40246: CALL_OW 120
// end ; end ;
40250: GO 39885
40252: POP
40253: POP
// places := 0 ;
40254: LD_ADDR_VAR 0 5
40258: PUSH
40259: LD_INT 0
40261: ST_TO_ADDR
// for j = 1 to x do
40262: LD_ADDR_VAR 0 3
40266: PUSH
40267: DOUBLE
40268: LD_INT 1
40270: DEC
40271: ST_TO_ADDR
40272: LD_VAR 0 11
40276: PUSH
40277: FOR_TO
40278: IFFALSE 40354
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40280: LD_VAR 0 11
40284: PUSH
40285: LD_VAR 0 3
40289: ARRAY
40290: PPUSH
40291: CALL_OW 264
40295: PUSH
40296: LD_INT 31
40298: EQUAL
40299: IFFALSE 40317
// places := places + 1 else
40301: LD_ADDR_VAR 0 5
40305: PUSH
40306: LD_VAR 0 5
40310: PUSH
40311: LD_INT 1
40313: PLUS
40314: ST_TO_ADDR
40315: GO 40352
// if GetBType ( x [ j ] ) = b_control_tower then
40317: LD_VAR 0 11
40321: PUSH
40322: LD_VAR 0 3
40326: ARRAY
40327: PPUSH
40328: CALL_OW 266
40332: PUSH
40333: LD_INT 36
40335: EQUAL
40336: IFFALSE 40352
// places := places + 3 ;
40338: LD_ADDR_VAR 0 5
40342: PUSH
40343: LD_VAR 0 5
40347: PUSH
40348: LD_INT 3
40350: PLUS
40351: ST_TO_ADDR
40352: GO 40277
40354: POP
40355: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40356: LD_VAR 0 5
40360: PUSH
40361: LD_INT 0
40363: EQUAL
40364: PUSH
40365: LD_VAR 0 5
40369: PUSH
40370: LD_EXP 90
40374: PUSH
40375: LD_VAR 0 2
40379: ARRAY
40380: LESSEQUAL
40381: OR
40382: IFFALSE 40386
// continue ;
40384: GO 39636
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40386: LD_ADDR_VAR 0 6
40390: PUSH
40391: LD_EXP 50
40395: PUSH
40396: LD_VAR 0 2
40400: ARRAY
40401: PPUSH
40402: LD_INT 25
40404: PUSH
40405: LD_INT 3
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PPUSH
40412: CALL_OW 72
40416: PUSH
40417: LD_EXP 90
40421: PUSH
40422: LD_VAR 0 2
40426: ARRAY
40427: DIFF
40428: PPUSH
40429: LD_INT 3
40431: PPUSH
40432: CALL 84489 0 2
40436: ST_TO_ADDR
// for j in tmp do
40437: LD_ADDR_VAR 0 3
40441: PUSH
40442: LD_VAR 0 6
40446: PUSH
40447: FOR_IN
40448: IFFALSE 40483
// if GetTag ( j ) > 0 then
40450: LD_VAR 0 3
40454: PPUSH
40455: CALL_OW 110
40459: PUSH
40460: LD_INT 0
40462: GREATER
40463: IFFALSE 40481
// tmp := tmp diff j ;
40465: LD_ADDR_VAR 0 6
40469: PUSH
40470: LD_VAR 0 6
40474: PUSH
40475: LD_VAR 0 3
40479: DIFF
40480: ST_TO_ADDR
40481: GO 40447
40483: POP
40484: POP
// if not tmp then
40485: LD_VAR 0 6
40489: NOT
40490: IFFALSE 40494
// continue ;
40492: GO 39636
// if places then
40494: LD_VAR 0 5
40498: IFFALSE 40557
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40500: LD_ADDR_EXP 90
40504: PUSH
40505: LD_EXP 90
40509: PPUSH
40510: LD_VAR 0 2
40514: PPUSH
40515: LD_EXP 90
40519: PUSH
40520: LD_VAR 0 2
40524: ARRAY
40525: PUSH
40526: LD_VAR 0 6
40530: PUSH
40531: LD_INT 1
40533: ARRAY
40534: UNION
40535: PPUSH
40536: CALL_OW 1
40540: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40541: LD_VAR 0 6
40545: PUSH
40546: LD_INT 1
40548: ARRAY
40549: PPUSH
40550: LD_INT 126
40552: PPUSH
40553: CALL_OW 109
// end ; end ;
40557: GO 39636
40559: POP
40560: POP
// end ;
40561: LD_VAR 0 1
40565: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40566: LD_INT 0
40568: PPUSH
40569: PPUSH
40570: PPUSH
40571: PPUSH
40572: PPUSH
40573: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40574: LD_VAR 0 1
40578: NOT
40579: PUSH
40580: LD_VAR 0 2
40584: NOT
40585: OR
40586: PUSH
40587: LD_VAR 0 3
40591: NOT
40592: OR
40593: PUSH
40594: LD_VAR 0 4
40598: PUSH
40599: LD_INT 1
40601: PUSH
40602: LD_INT 2
40604: PUSH
40605: LD_INT 3
40607: PUSH
40608: LD_INT 4
40610: PUSH
40611: LD_INT 5
40613: PUSH
40614: LD_INT 8
40616: PUSH
40617: LD_INT 9
40619: PUSH
40620: LD_INT 15
40622: PUSH
40623: LD_INT 16
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: LIST
40636: IN
40637: NOT
40638: OR
40639: IFFALSE 40643
// exit ;
40641: GO 41543
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40643: LD_ADDR_VAR 0 2
40647: PUSH
40648: LD_VAR 0 2
40652: PPUSH
40653: LD_INT 21
40655: PUSH
40656: LD_INT 3
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 24
40665: PUSH
40666: LD_INT 250
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PPUSH
40677: CALL_OW 72
40681: ST_TO_ADDR
// case class of 1 , 15 :
40682: LD_VAR 0 4
40686: PUSH
40687: LD_INT 1
40689: DOUBLE
40690: EQUAL
40691: IFTRUE 40701
40693: LD_INT 15
40695: DOUBLE
40696: EQUAL
40697: IFTRUE 40701
40699: GO 40786
40701: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40702: LD_ADDR_VAR 0 8
40706: PUSH
40707: LD_VAR 0 2
40711: PPUSH
40712: LD_INT 2
40714: PUSH
40715: LD_INT 30
40717: PUSH
40718: LD_INT 32
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 30
40727: PUSH
40728: LD_INT 31
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: LIST
40739: PPUSH
40740: CALL_OW 72
40744: PUSH
40745: LD_VAR 0 2
40749: PPUSH
40750: LD_INT 2
40752: PUSH
40753: LD_INT 30
40755: PUSH
40756: LD_INT 4
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 30
40765: PUSH
40766: LD_INT 5
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: PPUSH
40778: CALL_OW 72
40782: ADD
40783: ST_TO_ADDR
40784: GO 41032
40786: LD_INT 2
40788: DOUBLE
40789: EQUAL
40790: IFTRUE 40800
40792: LD_INT 16
40794: DOUBLE
40795: EQUAL
40796: IFTRUE 40800
40798: GO 40846
40800: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40801: LD_ADDR_VAR 0 8
40805: PUSH
40806: LD_VAR 0 2
40810: PPUSH
40811: LD_INT 2
40813: PUSH
40814: LD_INT 30
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 30
40826: PUSH
40827: LD_INT 1
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: LIST
40838: PPUSH
40839: CALL_OW 72
40843: ST_TO_ADDR
40844: GO 41032
40846: LD_INT 3
40848: DOUBLE
40849: EQUAL
40850: IFTRUE 40854
40852: GO 40900
40854: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40855: LD_ADDR_VAR 0 8
40859: PUSH
40860: LD_VAR 0 2
40864: PPUSH
40865: LD_INT 2
40867: PUSH
40868: LD_INT 30
40870: PUSH
40871: LD_INT 2
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 30
40880: PUSH
40881: LD_INT 3
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: LIST
40892: PPUSH
40893: CALL_OW 72
40897: ST_TO_ADDR
40898: GO 41032
40900: LD_INT 4
40902: DOUBLE
40903: EQUAL
40904: IFTRUE 40908
40906: GO 40965
40908: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40909: LD_ADDR_VAR 0 8
40913: PUSH
40914: LD_VAR 0 2
40918: PPUSH
40919: LD_INT 2
40921: PUSH
40922: LD_INT 30
40924: PUSH
40925: LD_INT 6
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 30
40934: PUSH
40935: LD_INT 7
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 30
40944: PUSH
40945: LD_INT 8
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: PPUSH
40958: CALL_OW 72
40962: ST_TO_ADDR
40963: GO 41032
40965: LD_INT 5
40967: DOUBLE
40968: EQUAL
40969: IFTRUE 40985
40971: LD_INT 8
40973: DOUBLE
40974: EQUAL
40975: IFTRUE 40985
40977: LD_INT 9
40979: DOUBLE
40980: EQUAL
40981: IFTRUE 40985
40983: GO 41031
40985: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40986: LD_ADDR_VAR 0 8
40990: PUSH
40991: LD_VAR 0 2
40995: PPUSH
40996: LD_INT 2
40998: PUSH
40999: LD_INT 30
41001: PUSH
41002: LD_INT 4
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 30
41011: PUSH
41012: LD_INT 5
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: LIST
41023: PPUSH
41024: CALL_OW 72
41028: ST_TO_ADDR
41029: GO 41032
41031: POP
// if not tmp then
41032: LD_VAR 0 8
41036: NOT
41037: IFFALSE 41041
// exit ;
41039: GO 41543
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41041: LD_VAR 0 4
41045: PUSH
41046: LD_INT 1
41048: PUSH
41049: LD_INT 15
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: IN
41056: PUSH
41057: LD_EXP 59
41061: PUSH
41062: LD_VAR 0 1
41066: ARRAY
41067: AND
41068: IFFALSE 41224
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41070: LD_ADDR_VAR 0 9
41074: PUSH
41075: LD_EXP 59
41079: PUSH
41080: LD_VAR 0 1
41084: ARRAY
41085: PUSH
41086: LD_INT 1
41088: ARRAY
41089: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41090: LD_VAR 0 9
41094: PUSH
41095: LD_EXP 60
41099: PUSH
41100: LD_VAR 0 1
41104: ARRAY
41105: IN
41106: NOT
41107: IFFALSE 41222
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41109: LD_ADDR_EXP 60
41113: PUSH
41114: LD_EXP 60
41118: PPUSH
41119: LD_VAR 0 1
41123: PUSH
41124: LD_EXP 60
41128: PUSH
41129: LD_VAR 0 1
41133: ARRAY
41134: PUSH
41135: LD_INT 1
41137: PLUS
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PPUSH
41143: LD_VAR 0 9
41147: PPUSH
41148: CALL 53718 0 3
41152: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41153: LD_ADDR_EXP 59
41157: PUSH
41158: LD_EXP 59
41162: PPUSH
41163: LD_VAR 0 1
41167: PPUSH
41168: LD_EXP 59
41172: PUSH
41173: LD_VAR 0 1
41177: ARRAY
41178: PUSH
41179: LD_VAR 0 9
41183: DIFF
41184: PPUSH
41185: CALL_OW 1
41189: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41190: LD_VAR 0 3
41194: PPUSH
41195: LD_EXP 60
41199: PUSH
41200: LD_VAR 0 1
41204: ARRAY
41205: PUSH
41206: LD_EXP 60
41210: PUSH
41211: LD_VAR 0 1
41215: ARRAY
41216: ARRAY
41217: PPUSH
41218: CALL_OW 120
// end ; exit ;
41222: GO 41543
// end ; if tmp > 1 then
41224: LD_VAR 0 8
41228: PUSH
41229: LD_INT 1
41231: GREATER
41232: IFFALSE 41336
// for i = 2 to tmp do
41234: LD_ADDR_VAR 0 6
41238: PUSH
41239: DOUBLE
41240: LD_INT 2
41242: DEC
41243: ST_TO_ADDR
41244: LD_VAR 0 8
41248: PUSH
41249: FOR_TO
41250: IFFALSE 41334
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41252: LD_VAR 0 8
41256: PUSH
41257: LD_VAR 0 6
41261: ARRAY
41262: PPUSH
41263: CALL_OW 461
41267: PUSH
41268: LD_INT 6
41270: EQUAL
41271: IFFALSE 41332
// begin x := tmp [ i ] ;
41273: LD_ADDR_VAR 0 9
41277: PUSH
41278: LD_VAR 0 8
41282: PUSH
41283: LD_VAR 0 6
41287: ARRAY
41288: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41289: LD_ADDR_VAR 0 8
41293: PUSH
41294: LD_VAR 0 8
41298: PPUSH
41299: LD_VAR 0 6
41303: PPUSH
41304: CALL_OW 3
41308: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41309: LD_ADDR_VAR 0 8
41313: PUSH
41314: LD_VAR 0 8
41318: PPUSH
41319: LD_INT 1
41321: PPUSH
41322: LD_VAR 0 9
41326: PPUSH
41327: CALL_OW 2
41331: ST_TO_ADDR
// end ;
41332: GO 41249
41334: POP
41335: POP
// for i in tmp do
41336: LD_ADDR_VAR 0 6
41340: PUSH
41341: LD_VAR 0 8
41345: PUSH
41346: FOR_IN
41347: IFFALSE 41416
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41349: LD_VAR 0 6
41353: PPUSH
41354: CALL_OW 313
41358: PUSH
41359: LD_INT 6
41361: LESS
41362: PUSH
41363: LD_VAR 0 6
41367: PPUSH
41368: CALL_OW 266
41372: PUSH
41373: LD_INT 31
41375: PUSH
41376: LD_INT 32
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: IN
41383: NOT
41384: AND
41385: PUSH
41386: LD_VAR 0 6
41390: PPUSH
41391: CALL_OW 313
41395: PUSH
41396: LD_INT 0
41398: EQUAL
41399: OR
41400: IFFALSE 41414
// begin j := i ;
41402: LD_ADDR_VAR 0 7
41406: PUSH
41407: LD_VAR 0 6
41411: ST_TO_ADDR
// break ;
41412: GO 41416
// end ; end ;
41414: GO 41346
41416: POP
41417: POP
// if j then
41418: LD_VAR 0 7
41422: IFFALSE 41440
// ComEnterUnit ( unit , j ) else
41424: LD_VAR 0 3
41428: PPUSH
41429: LD_VAR 0 7
41433: PPUSH
41434: CALL_OW 120
41438: GO 41543
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41440: LD_ADDR_VAR 0 10
41444: PUSH
41445: LD_VAR 0 2
41449: PPUSH
41450: LD_INT 2
41452: PUSH
41453: LD_INT 30
41455: PUSH
41456: LD_INT 0
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 30
41465: PUSH
41466: LD_INT 1
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: LIST
41477: PPUSH
41478: CALL_OW 72
41482: ST_TO_ADDR
// if depot then
41483: LD_VAR 0 10
41487: IFFALSE 41543
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41489: LD_ADDR_VAR 0 10
41493: PUSH
41494: LD_VAR 0 10
41498: PPUSH
41499: LD_VAR 0 3
41503: PPUSH
41504: CALL_OW 74
41508: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41509: LD_VAR 0 3
41513: PPUSH
41514: LD_VAR 0 10
41518: PPUSH
41519: CALL_OW 296
41523: PUSH
41524: LD_INT 10
41526: GREATER
41527: IFFALSE 41543
// ComStandNearbyBuilding ( unit , depot ) ;
41529: LD_VAR 0 3
41533: PPUSH
41534: LD_VAR 0 10
41538: PPUSH
41539: CALL 50143 0 2
// end ; end ; end ;
41543: LD_VAR 0 5
41547: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41548: LD_INT 0
41550: PPUSH
41551: PPUSH
41552: PPUSH
41553: PPUSH
// if not mc_bases then
41554: LD_EXP 50
41558: NOT
41559: IFFALSE 41563
// exit ;
41561: GO 41802
// for i = 1 to mc_bases do
41563: LD_ADDR_VAR 0 2
41567: PUSH
41568: DOUBLE
41569: LD_INT 1
41571: DEC
41572: ST_TO_ADDR
41573: LD_EXP 50
41577: PUSH
41578: FOR_TO
41579: IFFALSE 41800
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41581: LD_ADDR_VAR 0 4
41585: PUSH
41586: LD_EXP 50
41590: PUSH
41591: LD_VAR 0 2
41595: ARRAY
41596: PPUSH
41597: LD_INT 21
41599: PUSH
41600: LD_INT 1
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PPUSH
41607: CALL_OW 72
41611: PUSH
41612: LD_EXP 79
41616: PUSH
41617: LD_VAR 0 2
41621: ARRAY
41622: UNION
41623: ST_TO_ADDR
// if not tmp then
41624: LD_VAR 0 4
41628: NOT
41629: IFFALSE 41633
// continue ;
41631: GO 41578
// for j in tmp do
41633: LD_ADDR_VAR 0 3
41637: PUSH
41638: LD_VAR 0 4
41642: PUSH
41643: FOR_IN
41644: IFFALSE 41796
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41646: LD_VAR 0 3
41650: PPUSH
41651: CALL_OW 110
41655: NOT
41656: PUSH
41657: LD_VAR 0 3
41661: PPUSH
41662: CALL_OW 314
41666: NOT
41667: AND
41668: PUSH
41669: LD_VAR 0 3
41673: PPUSH
41674: CALL_OW 311
41678: NOT
41679: AND
41680: PUSH
41681: LD_VAR 0 3
41685: PPUSH
41686: CALL_OW 310
41690: NOT
41691: AND
41692: PUSH
41693: LD_VAR 0 3
41697: PUSH
41698: LD_EXP 53
41702: PUSH
41703: LD_VAR 0 2
41707: ARRAY
41708: PUSH
41709: LD_INT 1
41711: ARRAY
41712: IN
41713: NOT
41714: AND
41715: PUSH
41716: LD_VAR 0 3
41720: PUSH
41721: LD_EXP 53
41725: PUSH
41726: LD_VAR 0 2
41730: ARRAY
41731: PUSH
41732: LD_INT 2
41734: ARRAY
41735: IN
41736: NOT
41737: AND
41738: PUSH
41739: LD_VAR 0 3
41743: PUSH
41744: LD_EXP 62
41748: PUSH
41749: LD_VAR 0 2
41753: ARRAY
41754: IN
41755: NOT
41756: AND
41757: IFFALSE 41794
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41759: LD_VAR 0 2
41763: PPUSH
41764: LD_EXP 50
41768: PUSH
41769: LD_VAR 0 2
41773: ARRAY
41774: PPUSH
41775: LD_VAR 0 3
41779: PPUSH
41780: LD_VAR 0 3
41784: PPUSH
41785: CALL_OW 257
41789: PPUSH
41790: CALL 40566 0 4
// end ;
41794: GO 41643
41796: POP
41797: POP
// end ;
41798: GO 41578
41800: POP
41801: POP
// end ;
41802: LD_VAR 0 1
41806: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41807: LD_INT 0
41809: PPUSH
41810: PPUSH
41811: PPUSH
41812: PPUSH
41813: PPUSH
41814: PPUSH
// if not mc_bases [ base ] then
41815: LD_EXP 50
41819: PUSH
41820: LD_VAR 0 1
41824: ARRAY
41825: NOT
41826: IFFALSE 41830
// exit ;
41828: GO 42012
// tmp := [ ] ;
41830: LD_ADDR_VAR 0 6
41834: PUSH
41835: EMPTY
41836: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41837: LD_ADDR_VAR 0 7
41841: PUSH
41842: LD_VAR 0 3
41846: PPUSH
41847: LD_INT 0
41849: PPUSH
41850: CALL_OW 517
41854: ST_TO_ADDR
// if not list then
41855: LD_VAR 0 7
41859: NOT
41860: IFFALSE 41864
// exit ;
41862: GO 42012
// for i = 1 to amount do
41864: LD_ADDR_VAR 0 5
41868: PUSH
41869: DOUBLE
41870: LD_INT 1
41872: DEC
41873: ST_TO_ADDR
41874: LD_VAR 0 2
41878: PUSH
41879: FOR_TO
41880: IFFALSE 41960
// begin x := rand ( 1 , list [ 1 ] ) ;
41882: LD_ADDR_VAR 0 8
41886: PUSH
41887: LD_INT 1
41889: PPUSH
41890: LD_VAR 0 7
41894: PUSH
41895: LD_INT 1
41897: ARRAY
41898: PPUSH
41899: CALL_OW 12
41903: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41904: LD_ADDR_VAR 0 6
41908: PUSH
41909: LD_VAR 0 6
41913: PPUSH
41914: LD_VAR 0 5
41918: PPUSH
41919: LD_VAR 0 7
41923: PUSH
41924: LD_INT 1
41926: ARRAY
41927: PUSH
41928: LD_VAR 0 8
41932: ARRAY
41933: PUSH
41934: LD_VAR 0 7
41938: PUSH
41939: LD_INT 2
41941: ARRAY
41942: PUSH
41943: LD_VAR 0 8
41947: ARRAY
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PPUSH
41953: CALL_OW 1
41957: ST_TO_ADDR
// end ;
41958: GO 41879
41960: POP
41961: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41962: LD_ADDR_EXP 63
41966: PUSH
41967: LD_EXP 63
41971: PPUSH
41972: LD_VAR 0 1
41976: PPUSH
41977: LD_VAR 0 6
41981: PPUSH
41982: CALL_OW 1
41986: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41987: LD_ADDR_EXP 65
41991: PUSH
41992: LD_EXP 65
41996: PPUSH
41997: LD_VAR 0 1
42001: PPUSH
42002: LD_VAR 0 3
42006: PPUSH
42007: CALL_OW 1
42011: ST_TO_ADDR
// end ;
42012: LD_VAR 0 4
42016: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42017: LD_INT 0
42019: PPUSH
// if not mc_bases [ base ] then
42020: LD_EXP 50
42024: PUSH
42025: LD_VAR 0 1
42029: ARRAY
42030: NOT
42031: IFFALSE 42035
// exit ;
42033: GO 42060
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42035: LD_ADDR_EXP 55
42039: PUSH
42040: LD_EXP 55
42044: PPUSH
42045: LD_VAR 0 1
42049: PPUSH
42050: LD_VAR 0 2
42054: PPUSH
42055: CALL_OW 1
42059: ST_TO_ADDR
// end ;
42060: LD_VAR 0 3
42064: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42065: LD_INT 0
42067: PPUSH
// if not mc_bases [ base ] then
42068: LD_EXP 50
42072: PUSH
42073: LD_VAR 0 1
42077: ARRAY
42078: NOT
42079: IFFALSE 42083
// exit ;
42081: GO 42120
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42083: LD_ADDR_EXP 55
42087: PUSH
42088: LD_EXP 55
42092: PPUSH
42093: LD_VAR 0 1
42097: PPUSH
42098: LD_EXP 55
42102: PUSH
42103: LD_VAR 0 1
42107: ARRAY
42108: PUSH
42109: LD_VAR 0 2
42113: UNION
42114: PPUSH
42115: CALL_OW 1
42119: ST_TO_ADDR
// end ;
42120: LD_VAR 0 3
42124: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42125: LD_INT 0
42127: PPUSH
// if not mc_bases [ base ] then
42128: LD_EXP 50
42132: PUSH
42133: LD_VAR 0 1
42137: ARRAY
42138: NOT
42139: IFFALSE 42143
// exit ;
42141: GO 42168
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42143: LD_ADDR_EXP 71
42147: PUSH
42148: LD_EXP 71
42152: PPUSH
42153: LD_VAR 0 1
42157: PPUSH
42158: LD_VAR 0 2
42162: PPUSH
42163: CALL_OW 1
42167: ST_TO_ADDR
// end ;
42168: LD_VAR 0 3
42172: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42173: LD_INT 0
42175: PPUSH
// if not mc_bases [ base ] then
42176: LD_EXP 50
42180: PUSH
42181: LD_VAR 0 1
42185: ARRAY
42186: NOT
42187: IFFALSE 42191
// exit ;
42189: GO 42228
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42191: LD_ADDR_EXP 71
42195: PUSH
42196: LD_EXP 71
42200: PPUSH
42201: LD_VAR 0 1
42205: PPUSH
42206: LD_EXP 71
42210: PUSH
42211: LD_VAR 0 1
42215: ARRAY
42216: PUSH
42217: LD_VAR 0 2
42221: ADD
42222: PPUSH
42223: CALL_OW 1
42227: ST_TO_ADDR
// end ;
42228: LD_VAR 0 3
42232: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42233: LD_INT 0
42235: PPUSH
// if not mc_bases [ base ] then
42236: LD_EXP 50
42240: PUSH
42241: LD_VAR 0 1
42245: ARRAY
42246: NOT
42247: IFFALSE 42251
// exit ;
42249: GO 42305
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42251: LD_ADDR_EXP 72
42255: PUSH
42256: LD_EXP 72
42260: PPUSH
42261: LD_VAR 0 1
42265: PPUSH
42266: LD_VAR 0 2
42270: PPUSH
42271: CALL_OW 1
42275: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42276: LD_ADDR_EXP 61
42280: PUSH
42281: LD_EXP 61
42285: PPUSH
42286: LD_VAR 0 1
42290: PPUSH
42291: LD_VAR 0 2
42295: PUSH
42296: LD_INT 0
42298: PLUS
42299: PPUSH
42300: CALL_OW 1
42304: ST_TO_ADDR
// end ;
42305: LD_VAR 0 3
42309: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42310: LD_INT 0
42312: PPUSH
// if not mc_bases [ base ] then
42313: LD_EXP 50
42317: PUSH
42318: LD_VAR 0 1
42322: ARRAY
42323: NOT
42324: IFFALSE 42328
// exit ;
42326: GO 42353
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42328: LD_ADDR_EXP 61
42332: PUSH
42333: LD_EXP 61
42337: PPUSH
42338: LD_VAR 0 1
42342: PPUSH
42343: LD_VAR 0 2
42347: PPUSH
42348: CALL_OW 1
42352: ST_TO_ADDR
// end ;
42353: LD_VAR 0 3
42357: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42358: LD_INT 0
42360: PPUSH
42361: PPUSH
42362: PPUSH
42363: PPUSH
// if not mc_bases [ base ] then
42364: LD_EXP 50
42368: PUSH
42369: LD_VAR 0 1
42373: ARRAY
42374: NOT
42375: IFFALSE 42379
// exit ;
42377: GO 42444
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42379: LD_ADDR_EXP 70
42383: PUSH
42384: LD_EXP 70
42388: PPUSH
42389: LD_VAR 0 1
42393: PUSH
42394: LD_EXP 70
42398: PUSH
42399: LD_VAR 0 1
42403: ARRAY
42404: PUSH
42405: LD_INT 1
42407: PLUS
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PPUSH
42413: LD_VAR 0 1
42417: PUSH
42418: LD_VAR 0 2
42422: PUSH
42423: LD_VAR 0 3
42427: PUSH
42428: LD_VAR 0 4
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: PPUSH
42439: CALL 53718 0 3
42443: ST_TO_ADDR
// end ;
42444: LD_VAR 0 5
42448: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42449: LD_INT 0
42451: PPUSH
// if not mc_bases [ base ] then
42452: LD_EXP 50
42456: PUSH
42457: LD_VAR 0 1
42461: ARRAY
42462: NOT
42463: IFFALSE 42467
// exit ;
42465: GO 42492
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42467: LD_ADDR_EXP 87
42471: PUSH
42472: LD_EXP 87
42476: PPUSH
42477: LD_VAR 0 1
42481: PPUSH
42482: LD_VAR 0 2
42486: PPUSH
42487: CALL_OW 1
42491: ST_TO_ADDR
// end ;
42492: LD_VAR 0 3
42496: RET
// export function MC_GetMinesField ( base ) ; begin
42497: LD_INT 0
42499: PPUSH
// result := mc_mines [ base ] ;
42500: LD_ADDR_VAR 0 2
42504: PUSH
42505: LD_EXP 63
42509: PUSH
42510: LD_VAR 0 1
42514: ARRAY
42515: ST_TO_ADDR
// end ;
42516: LD_VAR 0 2
42520: RET
// export function MC_GetProduceList ( base ) ; begin
42521: LD_INT 0
42523: PPUSH
// result := mc_produce [ base ] ;
42524: LD_ADDR_VAR 0 2
42528: PUSH
42529: LD_EXP 71
42533: PUSH
42534: LD_VAR 0 1
42538: ARRAY
42539: ST_TO_ADDR
// end ;
42540: LD_VAR 0 2
42544: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42545: LD_INT 0
42547: PPUSH
42548: PPUSH
// if not mc_bases then
42549: LD_EXP 50
42553: NOT
42554: IFFALSE 42558
// exit ;
42556: GO 42623
// if mc_bases [ base ] then
42558: LD_EXP 50
42562: PUSH
42563: LD_VAR 0 1
42567: ARRAY
42568: IFFALSE 42623
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42570: LD_ADDR_VAR 0 3
42574: PUSH
42575: LD_EXP 50
42579: PUSH
42580: LD_VAR 0 1
42584: ARRAY
42585: PPUSH
42586: LD_INT 30
42588: PUSH
42589: LD_VAR 0 2
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PPUSH
42598: CALL_OW 72
42602: ST_TO_ADDR
// if result then
42603: LD_VAR 0 3
42607: IFFALSE 42623
// result := result [ 1 ] ;
42609: LD_ADDR_VAR 0 3
42613: PUSH
42614: LD_VAR 0 3
42618: PUSH
42619: LD_INT 1
42621: ARRAY
42622: ST_TO_ADDR
// end ; end ;
42623: LD_VAR 0 3
42627: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42628: LD_INT 0
42630: PPUSH
42631: PPUSH
// if not mc_bases then
42632: LD_EXP 50
42636: NOT
42637: IFFALSE 42641
// exit ;
42639: GO 42686
// if mc_bases [ base ] then
42641: LD_EXP 50
42645: PUSH
42646: LD_VAR 0 1
42650: ARRAY
42651: IFFALSE 42686
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42653: LD_ADDR_VAR 0 3
42657: PUSH
42658: LD_EXP 50
42662: PUSH
42663: LD_VAR 0 1
42667: ARRAY
42668: PPUSH
42669: LD_INT 30
42671: PUSH
42672: LD_VAR 0 2
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: PPUSH
42681: CALL_OW 72
42685: ST_TO_ADDR
// end ;
42686: LD_VAR 0 3
42690: RET
// export function MC_SetTame ( base , area ) ; begin
42691: LD_INT 0
42693: PPUSH
// if not mc_bases or not base then
42694: LD_EXP 50
42698: NOT
42699: PUSH
42700: LD_VAR 0 1
42704: NOT
42705: OR
42706: IFFALSE 42710
// exit ;
42708: GO 42735
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42710: LD_ADDR_EXP 78
42714: PUSH
42715: LD_EXP 78
42719: PPUSH
42720: LD_VAR 0 1
42724: PPUSH
42725: LD_VAR 0 2
42729: PPUSH
42730: CALL_OW 1
42734: ST_TO_ADDR
// end ;
42735: LD_VAR 0 3
42739: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42740: LD_INT 0
42742: PPUSH
42743: PPUSH
// if not mc_bases or not base then
42744: LD_EXP 50
42748: NOT
42749: PUSH
42750: LD_VAR 0 1
42754: NOT
42755: OR
42756: IFFALSE 42760
// exit ;
42758: GO 42862
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42760: LD_ADDR_VAR 0 4
42764: PUSH
42765: LD_EXP 50
42769: PUSH
42770: LD_VAR 0 1
42774: ARRAY
42775: PPUSH
42776: LD_INT 30
42778: PUSH
42779: LD_VAR 0 2
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PPUSH
42788: CALL_OW 72
42792: ST_TO_ADDR
// if not tmp then
42793: LD_VAR 0 4
42797: NOT
42798: IFFALSE 42802
// exit ;
42800: GO 42862
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42802: LD_ADDR_EXP 82
42806: PUSH
42807: LD_EXP 82
42811: PPUSH
42812: LD_VAR 0 1
42816: PPUSH
42817: LD_EXP 82
42821: PUSH
42822: LD_VAR 0 1
42826: ARRAY
42827: PPUSH
42828: LD_EXP 82
42832: PUSH
42833: LD_VAR 0 1
42837: ARRAY
42838: PUSH
42839: LD_INT 1
42841: PLUS
42842: PPUSH
42843: LD_VAR 0 4
42847: PUSH
42848: LD_INT 1
42850: ARRAY
42851: PPUSH
42852: CALL_OW 2
42856: PPUSH
42857: CALL_OW 1
42861: ST_TO_ADDR
// end ;
42862: LD_VAR 0 3
42866: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42867: LD_INT 0
42869: PPUSH
42870: PPUSH
// if not mc_bases or not base or not kinds then
42871: LD_EXP 50
42875: NOT
42876: PUSH
42877: LD_VAR 0 1
42881: NOT
42882: OR
42883: PUSH
42884: LD_VAR 0 2
42888: NOT
42889: OR
42890: IFFALSE 42894
// exit ;
42892: GO 42955
// for i in kinds do
42894: LD_ADDR_VAR 0 4
42898: PUSH
42899: LD_VAR 0 2
42903: PUSH
42904: FOR_IN
42905: IFFALSE 42953
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42907: LD_ADDR_EXP 84
42911: PUSH
42912: LD_EXP 84
42916: PPUSH
42917: LD_VAR 0 1
42921: PUSH
42922: LD_EXP 84
42926: PUSH
42927: LD_VAR 0 1
42931: ARRAY
42932: PUSH
42933: LD_INT 1
42935: PLUS
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PPUSH
42941: LD_VAR 0 4
42945: PPUSH
42946: CALL 53718 0 3
42950: ST_TO_ADDR
42951: GO 42904
42953: POP
42954: POP
// end ;
42955: LD_VAR 0 3
42959: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42960: LD_INT 0
42962: PPUSH
// if not mc_bases or not base or not areas then
42963: LD_EXP 50
42967: NOT
42968: PUSH
42969: LD_VAR 0 1
42973: NOT
42974: OR
42975: PUSH
42976: LD_VAR 0 2
42980: NOT
42981: OR
42982: IFFALSE 42986
// exit ;
42984: GO 43011
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42986: LD_ADDR_EXP 68
42990: PUSH
42991: LD_EXP 68
42995: PPUSH
42996: LD_VAR 0 1
43000: PPUSH
43001: LD_VAR 0 2
43005: PPUSH
43006: CALL_OW 1
43010: ST_TO_ADDR
// end ;
43011: LD_VAR 0 3
43015: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43016: LD_INT 0
43018: PPUSH
// if not mc_bases or not base or not teleports_exit then
43019: LD_EXP 50
43023: NOT
43024: PUSH
43025: LD_VAR 0 1
43029: NOT
43030: OR
43031: PUSH
43032: LD_VAR 0 2
43036: NOT
43037: OR
43038: IFFALSE 43042
// exit ;
43040: GO 43067
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43042: LD_ADDR_EXP 85
43046: PUSH
43047: LD_EXP 85
43051: PPUSH
43052: LD_VAR 0 1
43056: PPUSH
43057: LD_VAR 0 2
43061: PPUSH
43062: CALL_OW 1
43066: ST_TO_ADDR
// end ;
43067: LD_VAR 0 3
43071: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43072: LD_INT 0
43074: PPUSH
43075: PPUSH
43076: PPUSH
// if not mc_bases or not base or not ext_list then
43077: LD_EXP 50
43081: NOT
43082: PUSH
43083: LD_VAR 0 1
43087: NOT
43088: OR
43089: PUSH
43090: LD_VAR 0 5
43094: NOT
43095: OR
43096: IFFALSE 43100
// exit ;
43098: GO 43273
// tmp := GetFacExtXYD ( x , y , d ) ;
43100: LD_ADDR_VAR 0 8
43104: PUSH
43105: LD_VAR 0 2
43109: PPUSH
43110: LD_VAR 0 3
43114: PPUSH
43115: LD_VAR 0 4
43119: PPUSH
43120: CALL 83619 0 3
43124: ST_TO_ADDR
// if not tmp then
43125: LD_VAR 0 8
43129: NOT
43130: IFFALSE 43134
// exit ;
43132: GO 43273
// for i in tmp do
43134: LD_ADDR_VAR 0 7
43138: PUSH
43139: LD_VAR 0 8
43143: PUSH
43144: FOR_IN
43145: IFFALSE 43271
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43147: LD_ADDR_EXP 55
43151: PUSH
43152: LD_EXP 55
43156: PPUSH
43157: LD_VAR 0 1
43161: PPUSH
43162: LD_EXP 55
43166: PUSH
43167: LD_VAR 0 1
43171: ARRAY
43172: PPUSH
43173: LD_EXP 55
43177: PUSH
43178: LD_VAR 0 1
43182: ARRAY
43183: PUSH
43184: LD_INT 1
43186: PLUS
43187: PPUSH
43188: LD_VAR 0 5
43192: PUSH
43193: LD_INT 1
43195: ARRAY
43196: PUSH
43197: LD_VAR 0 7
43201: PUSH
43202: LD_INT 1
43204: ARRAY
43205: PUSH
43206: LD_VAR 0 7
43210: PUSH
43211: LD_INT 2
43213: ARRAY
43214: PUSH
43215: LD_VAR 0 7
43219: PUSH
43220: LD_INT 3
43222: ARRAY
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: PPUSH
43230: CALL_OW 2
43234: PPUSH
43235: CALL_OW 1
43239: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43240: LD_ADDR_VAR 0 5
43244: PUSH
43245: LD_VAR 0 5
43249: PPUSH
43250: LD_INT 1
43252: PPUSH
43253: CALL_OW 3
43257: ST_TO_ADDR
// if not ext_list then
43258: LD_VAR 0 5
43262: NOT
43263: IFFALSE 43269
// exit ;
43265: POP
43266: POP
43267: GO 43273
// end ;
43269: GO 43144
43271: POP
43272: POP
// end ;
43273: LD_VAR 0 6
43277: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43278: LD_INT 0
43280: PPUSH
// if not mc_bases or not base or not weapon_list then
43281: LD_EXP 50
43285: NOT
43286: PUSH
43287: LD_VAR 0 1
43291: NOT
43292: OR
43293: PUSH
43294: LD_VAR 0 2
43298: NOT
43299: OR
43300: IFFALSE 43304
// exit ;
43302: GO 43329
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43304: LD_ADDR_EXP 89
43308: PUSH
43309: LD_EXP 89
43313: PPUSH
43314: LD_VAR 0 1
43318: PPUSH
43319: LD_VAR 0 2
43323: PPUSH
43324: CALL_OW 1
43328: ST_TO_ADDR
// end ;
43329: LD_VAR 0 3
43333: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43334: LD_INT 0
43336: PPUSH
// if not mc_bases or not base or not tech_list then
43337: LD_EXP 50
43341: NOT
43342: PUSH
43343: LD_VAR 0 1
43347: NOT
43348: OR
43349: PUSH
43350: LD_VAR 0 2
43354: NOT
43355: OR
43356: IFFALSE 43360
// exit ;
43358: GO 43385
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43360: LD_ADDR_EXP 77
43364: PUSH
43365: LD_EXP 77
43369: PPUSH
43370: LD_VAR 0 1
43374: PPUSH
43375: LD_VAR 0 2
43379: PPUSH
43380: CALL_OW 1
43384: ST_TO_ADDR
// end ;
43385: LD_VAR 0 3
43389: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43390: LD_INT 0
43392: PPUSH
// if not mc_bases or not parking_area or not base then
43393: LD_EXP 50
43397: NOT
43398: PUSH
43399: LD_VAR 0 2
43403: NOT
43404: OR
43405: PUSH
43406: LD_VAR 0 1
43410: NOT
43411: OR
43412: IFFALSE 43416
// exit ;
43414: GO 43441
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43416: LD_ADDR_EXP 74
43420: PUSH
43421: LD_EXP 74
43425: PPUSH
43426: LD_VAR 0 1
43430: PPUSH
43431: LD_VAR 0 2
43435: PPUSH
43436: CALL_OW 1
43440: ST_TO_ADDR
// end ;
43441: LD_VAR 0 3
43445: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43446: LD_INT 0
43448: PPUSH
// if not mc_bases or not base or not scan_area then
43449: LD_EXP 50
43453: NOT
43454: PUSH
43455: LD_VAR 0 1
43459: NOT
43460: OR
43461: PUSH
43462: LD_VAR 0 2
43466: NOT
43467: OR
43468: IFFALSE 43472
// exit ;
43470: GO 43497
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43472: LD_ADDR_EXP 75
43476: PUSH
43477: LD_EXP 75
43481: PPUSH
43482: LD_VAR 0 1
43486: PPUSH
43487: LD_VAR 0 2
43491: PPUSH
43492: CALL_OW 1
43496: ST_TO_ADDR
// end ;
43497: LD_VAR 0 3
43501: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43502: LD_INT 0
43504: PPUSH
43505: PPUSH
// if not mc_bases or not base then
43506: LD_EXP 50
43510: NOT
43511: PUSH
43512: LD_VAR 0 1
43516: NOT
43517: OR
43518: IFFALSE 43522
// exit ;
43520: GO 43586
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43522: LD_ADDR_VAR 0 3
43526: PUSH
43527: LD_INT 1
43529: PUSH
43530: LD_INT 2
43532: PUSH
43533: LD_INT 3
43535: PUSH
43536: LD_INT 4
43538: PUSH
43539: LD_INT 11
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43549: LD_ADDR_EXP 77
43553: PUSH
43554: LD_EXP 77
43558: PPUSH
43559: LD_VAR 0 1
43563: PPUSH
43564: LD_EXP 77
43568: PUSH
43569: LD_VAR 0 1
43573: ARRAY
43574: PUSH
43575: LD_VAR 0 3
43579: DIFF
43580: PPUSH
43581: CALL_OW 1
43585: ST_TO_ADDR
// end ;
43586: LD_VAR 0 2
43590: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43591: LD_INT 0
43593: PPUSH
// result := mc_vehicles [ base ] ;
43594: LD_ADDR_VAR 0 3
43598: PUSH
43599: LD_EXP 69
43603: PUSH
43604: LD_VAR 0 1
43608: ARRAY
43609: ST_TO_ADDR
// if onlyCombat then
43610: LD_VAR 0 2
43614: IFFALSE 43792
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43616: LD_ADDR_VAR 0 3
43620: PUSH
43621: LD_VAR 0 3
43625: PUSH
43626: LD_VAR 0 3
43630: PPUSH
43631: LD_INT 2
43633: PUSH
43634: LD_INT 34
43636: PUSH
43637: LD_INT 12
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 34
43646: PUSH
43647: LD_INT 51
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 34
43656: PUSH
43657: LD_EXP 95
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 34
43668: PUSH
43669: LD_INT 32
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 34
43678: PUSH
43679: LD_INT 13
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 34
43688: PUSH
43689: LD_INT 52
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 34
43698: PUSH
43699: LD_EXP 100
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 34
43710: PUSH
43711: LD_INT 14
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 34
43720: PUSH
43721: LD_INT 53
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: PUSH
43728: LD_INT 34
43730: PUSH
43731: LD_EXP 94
43735: PUSH
43736: EMPTY
43737: LIST
43738: LIST
43739: PUSH
43740: LD_INT 34
43742: PUSH
43743: LD_INT 31
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 34
43752: PUSH
43753: LD_INT 48
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 34
43762: PUSH
43763: LD_INT 8
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: LIST
43778: LIST
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: LIST
43784: LIST
43785: PPUSH
43786: CALL_OW 72
43790: DIFF
43791: ST_TO_ADDR
// end ; end_of_file
43792: LD_VAR 0 3
43796: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43797: LD_INT 0
43799: PPUSH
43800: PPUSH
43801: PPUSH
// if not mc_bases or not skirmish then
43802: LD_EXP 50
43806: NOT
43807: PUSH
43808: LD_EXP 48
43812: NOT
43813: OR
43814: IFFALSE 43818
// exit ;
43816: GO 43983
// for i = 1 to mc_bases do
43818: LD_ADDR_VAR 0 4
43822: PUSH
43823: DOUBLE
43824: LD_INT 1
43826: DEC
43827: ST_TO_ADDR
43828: LD_EXP 50
43832: PUSH
43833: FOR_TO
43834: IFFALSE 43981
// begin if sci in mc_bases [ i ] then
43836: LD_VAR 0 2
43840: PUSH
43841: LD_EXP 50
43845: PUSH
43846: LD_VAR 0 4
43850: ARRAY
43851: IN
43852: IFFALSE 43979
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43854: LD_ADDR_EXP 79
43858: PUSH
43859: LD_EXP 79
43863: PPUSH
43864: LD_VAR 0 4
43868: PUSH
43869: LD_EXP 79
43873: PUSH
43874: LD_VAR 0 4
43878: ARRAY
43879: PUSH
43880: LD_INT 1
43882: PLUS
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PPUSH
43888: LD_VAR 0 1
43892: PPUSH
43893: CALL 53718 0 3
43897: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43898: LD_ADDR_VAR 0 5
43902: PUSH
43903: LD_EXP 50
43907: PUSH
43908: LD_VAR 0 4
43912: ARRAY
43913: PPUSH
43914: LD_INT 2
43916: PUSH
43917: LD_INT 30
43919: PUSH
43920: LD_INT 0
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 30
43929: PUSH
43930: LD_INT 1
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: LIST
43941: PPUSH
43942: CALL_OW 72
43946: PPUSH
43947: LD_VAR 0 1
43951: PPUSH
43952: CALL_OW 74
43956: ST_TO_ADDR
// if tmp then
43957: LD_VAR 0 5
43961: IFFALSE 43977
// ComStandNearbyBuilding ( ape , tmp ) ;
43963: LD_VAR 0 1
43967: PPUSH
43968: LD_VAR 0 5
43972: PPUSH
43973: CALL 50143 0 2
// break ;
43977: GO 43981
// end ; end ;
43979: GO 43833
43981: POP
43982: POP
// end ;
43983: LD_VAR 0 3
43987: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43988: LD_INT 0
43990: PPUSH
43991: PPUSH
43992: PPUSH
// if not mc_bases or not skirmish then
43993: LD_EXP 50
43997: NOT
43998: PUSH
43999: LD_EXP 48
44003: NOT
44004: OR
44005: IFFALSE 44009
// exit ;
44007: GO 44098
// for i = 1 to mc_bases do
44009: LD_ADDR_VAR 0 4
44013: PUSH
44014: DOUBLE
44015: LD_INT 1
44017: DEC
44018: ST_TO_ADDR
44019: LD_EXP 50
44023: PUSH
44024: FOR_TO
44025: IFFALSE 44096
// begin if building in mc_busy_turret_list [ i ] then
44027: LD_VAR 0 1
44031: PUSH
44032: LD_EXP 60
44036: PUSH
44037: LD_VAR 0 4
44041: ARRAY
44042: IN
44043: IFFALSE 44094
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44045: LD_ADDR_VAR 0 5
44049: PUSH
44050: LD_EXP 60
44054: PUSH
44055: LD_VAR 0 4
44059: ARRAY
44060: PUSH
44061: LD_VAR 0 1
44065: DIFF
44066: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44067: LD_ADDR_EXP 60
44071: PUSH
44072: LD_EXP 60
44076: PPUSH
44077: LD_VAR 0 4
44081: PPUSH
44082: LD_VAR 0 5
44086: PPUSH
44087: CALL_OW 1
44091: ST_TO_ADDR
// break ;
44092: GO 44096
// end ; end ;
44094: GO 44024
44096: POP
44097: POP
// end ;
44098: LD_VAR 0 3
44102: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44103: LD_INT 0
44105: PPUSH
44106: PPUSH
44107: PPUSH
// if not mc_bases or not skirmish then
44108: LD_EXP 50
44112: NOT
44113: PUSH
44114: LD_EXP 48
44118: NOT
44119: OR
44120: IFFALSE 44124
// exit ;
44122: GO 44323
// for i = 1 to mc_bases do
44124: LD_ADDR_VAR 0 5
44128: PUSH
44129: DOUBLE
44130: LD_INT 1
44132: DEC
44133: ST_TO_ADDR
44134: LD_EXP 50
44138: PUSH
44139: FOR_TO
44140: IFFALSE 44321
// if building in mc_bases [ i ] then
44142: LD_VAR 0 1
44146: PUSH
44147: LD_EXP 50
44151: PUSH
44152: LD_VAR 0 5
44156: ARRAY
44157: IN
44158: IFFALSE 44319
// begin tmp := mc_bases [ i ] diff building ;
44160: LD_ADDR_VAR 0 6
44164: PUSH
44165: LD_EXP 50
44169: PUSH
44170: LD_VAR 0 5
44174: ARRAY
44175: PUSH
44176: LD_VAR 0 1
44180: DIFF
44181: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44182: LD_ADDR_EXP 50
44186: PUSH
44187: LD_EXP 50
44191: PPUSH
44192: LD_VAR 0 5
44196: PPUSH
44197: LD_VAR 0 6
44201: PPUSH
44202: CALL_OW 1
44206: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44207: LD_VAR 0 1
44211: PUSH
44212: LD_EXP 58
44216: PUSH
44217: LD_VAR 0 5
44221: ARRAY
44222: IN
44223: IFFALSE 44262
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44225: LD_ADDR_EXP 58
44229: PUSH
44230: LD_EXP 58
44234: PPUSH
44235: LD_VAR 0 5
44239: PPUSH
44240: LD_EXP 58
44244: PUSH
44245: LD_VAR 0 5
44249: ARRAY
44250: PUSH
44251: LD_VAR 0 1
44255: DIFF
44256: PPUSH
44257: CALL_OW 1
44261: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44262: LD_VAR 0 1
44266: PUSH
44267: LD_EXP 59
44271: PUSH
44272: LD_VAR 0 5
44276: ARRAY
44277: IN
44278: IFFALSE 44317
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44280: LD_ADDR_EXP 59
44284: PUSH
44285: LD_EXP 59
44289: PPUSH
44290: LD_VAR 0 5
44294: PPUSH
44295: LD_EXP 59
44299: PUSH
44300: LD_VAR 0 5
44304: ARRAY
44305: PUSH
44306: LD_VAR 0 1
44310: DIFF
44311: PPUSH
44312: CALL_OW 1
44316: ST_TO_ADDR
// break ;
44317: GO 44321
// end ;
44319: GO 44139
44321: POP
44322: POP
// end ;
44323: LD_VAR 0 4
44327: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44328: LD_INT 0
44330: PPUSH
44331: PPUSH
44332: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44333: LD_EXP 50
44337: NOT
44338: PUSH
44339: LD_EXP 48
44343: NOT
44344: OR
44345: PUSH
44346: LD_VAR 0 3
44350: PUSH
44351: LD_EXP 76
44355: IN
44356: NOT
44357: OR
44358: IFFALSE 44362
// exit ;
44360: GO 44485
// for i = 1 to mc_vehicles do
44362: LD_ADDR_VAR 0 6
44366: PUSH
44367: DOUBLE
44368: LD_INT 1
44370: DEC
44371: ST_TO_ADDR
44372: LD_EXP 69
44376: PUSH
44377: FOR_TO
44378: IFFALSE 44483
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44380: LD_VAR 0 2
44384: PUSH
44385: LD_EXP 69
44389: PUSH
44390: LD_VAR 0 6
44394: ARRAY
44395: IN
44396: PUSH
44397: LD_VAR 0 1
44401: PUSH
44402: LD_EXP 69
44406: PUSH
44407: LD_VAR 0 6
44411: ARRAY
44412: IN
44413: OR
44414: IFFALSE 44481
// begin tmp := mc_vehicles [ i ] diff old ;
44416: LD_ADDR_VAR 0 7
44420: PUSH
44421: LD_EXP 69
44425: PUSH
44426: LD_VAR 0 6
44430: ARRAY
44431: PUSH
44432: LD_VAR 0 2
44436: DIFF
44437: ST_TO_ADDR
// tmp := tmp diff new ;
44438: LD_ADDR_VAR 0 7
44442: PUSH
44443: LD_VAR 0 7
44447: PUSH
44448: LD_VAR 0 1
44452: DIFF
44453: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44454: LD_ADDR_EXP 69
44458: PUSH
44459: LD_EXP 69
44463: PPUSH
44464: LD_VAR 0 6
44468: PPUSH
44469: LD_VAR 0 7
44473: PPUSH
44474: CALL_OW 1
44478: ST_TO_ADDR
// break ;
44479: GO 44483
// end ;
44481: GO 44377
44483: POP
44484: POP
// end ;
44485: LD_VAR 0 5
44489: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44490: LD_INT 0
44492: PPUSH
44493: PPUSH
44494: PPUSH
44495: PPUSH
// if not mc_bases or not skirmish then
44496: LD_EXP 50
44500: NOT
44501: PUSH
44502: LD_EXP 48
44506: NOT
44507: OR
44508: IFFALSE 44512
// exit ;
44510: GO 44904
// side := GetSide ( vehicle ) ;
44512: LD_ADDR_VAR 0 5
44516: PUSH
44517: LD_VAR 0 1
44521: PPUSH
44522: CALL_OW 255
44526: ST_TO_ADDR
// for i = 1 to mc_bases do
44527: LD_ADDR_VAR 0 4
44531: PUSH
44532: DOUBLE
44533: LD_INT 1
44535: DEC
44536: ST_TO_ADDR
44537: LD_EXP 50
44541: PUSH
44542: FOR_TO
44543: IFFALSE 44902
// begin if factory in mc_bases [ i ] then
44545: LD_VAR 0 2
44549: PUSH
44550: LD_EXP 50
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: IN
44561: IFFALSE 44900
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44563: LD_EXP 72
44567: PUSH
44568: LD_VAR 0 4
44572: ARRAY
44573: PUSH
44574: LD_EXP 61
44578: PUSH
44579: LD_VAR 0 4
44583: ARRAY
44584: LESS
44585: PUSH
44586: LD_VAR 0 1
44590: PPUSH
44591: CALL_OW 264
44595: PUSH
44596: LD_INT 31
44598: PUSH
44599: LD_INT 32
44601: PUSH
44602: LD_INT 51
44604: PUSH
44605: LD_EXP 95
44609: PUSH
44610: LD_INT 12
44612: PUSH
44613: LD_INT 30
44615: PUSH
44616: LD_EXP 94
44620: PUSH
44621: LD_INT 11
44623: PUSH
44624: LD_INT 53
44626: PUSH
44627: LD_INT 14
44629: PUSH
44630: LD_EXP 98
44634: PUSH
44635: LD_INT 29
44637: PUSH
44638: LD_EXP 96
44642: PUSH
44643: LD_INT 13
44645: PUSH
44646: LD_INT 52
44648: PUSH
44649: LD_EXP 100
44653: PUSH
44654: LD_INT 48
44656: PUSH
44657: LD_INT 8
44659: PUSH
44660: EMPTY
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: LIST
44679: IN
44680: NOT
44681: AND
44682: IFFALSE 44730
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44684: LD_ADDR_EXP 72
44688: PUSH
44689: LD_EXP 72
44693: PPUSH
44694: LD_VAR 0 4
44698: PUSH
44699: LD_EXP 72
44703: PUSH
44704: LD_VAR 0 4
44708: ARRAY
44709: PUSH
44710: LD_INT 1
44712: PLUS
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PPUSH
44718: LD_VAR 0 1
44722: PPUSH
44723: CALL 53718 0 3
44727: ST_TO_ADDR
44728: GO 44774
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44730: LD_ADDR_EXP 69
44734: PUSH
44735: LD_EXP 69
44739: PPUSH
44740: LD_VAR 0 4
44744: PUSH
44745: LD_EXP 69
44749: PUSH
44750: LD_VAR 0 4
44754: ARRAY
44755: PUSH
44756: LD_INT 1
44758: PLUS
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PPUSH
44764: LD_VAR 0 1
44768: PPUSH
44769: CALL 53718 0 3
44773: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44774: LD_VAR 0 1
44778: PPUSH
44779: CALL_OW 263
44783: PUSH
44784: LD_INT 2
44786: EQUAL
44787: IFFALSE 44816
// begin repeat wait ( 0 0$3 ) ;
44789: LD_INT 105
44791: PPUSH
44792: CALL_OW 67
// Connect ( vehicle ) ;
44796: LD_VAR 0 1
44800: PPUSH
44801: CALL 56689 0 1
// until IsControledBy ( vehicle ) ;
44805: LD_VAR 0 1
44809: PPUSH
44810: CALL_OW 312
44814: IFFALSE 44789
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44816: LD_VAR 0 1
44820: PPUSH
44821: LD_EXP 74
44825: PUSH
44826: LD_VAR 0 4
44830: ARRAY
44831: PPUSH
44832: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44836: LD_VAR 0 1
44840: PPUSH
44841: CALL_OW 263
44845: PUSH
44846: LD_INT 1
44848: NONEQUAL
44849: IFFALSE 44853
// break ;
44851: GO 44902
// repeat wait ( 0 0$1 ) ;
44853: LD_INT 35
44855: PPUSH
44856: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44860: LD_VAR 0 1
44864: PPUSH
44865: LD_EXP 74
44869: PUSH
44870: LD_VAR 0 4
44874: ARRAY
44875: PPUSH
44876: CALL_OW 308
44880: IFFALSE 44853
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44882: LD_VAR 0 1
44886: PPUSH
44887: CALL_OW 311
44891: PPUSH
44892: CALL_OW 121
// exit ;
44896: POP
44897: POP
44898: GO 44904
// end ; end ;
44900: GO 44542
44902: POP
44903: POP
// end ;
44904: LD_VAR 0 3
44908: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44909: LD_INT 0
44911: PPUSH
44912: PPUSH
44913: PPUSH
44914: PPUSH
// if not mc_bases or not skirmish then
44915: LD_EXP 50
44919: NOT
44920: PUSH
44921: LD_EXP 48
44925: NOT
44926: OR
44927: IFFALSE 44931
// exit ;
44929: GO 45284
// repeat wait ( 0 0$1 ) ;
44931: LD_INT 35
44933: PPUSH
44934: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44938: LD_VAR 0 2
44942: PPUSH
44943: LD_VAR 0 3
44947: PPUSH
44948: CALL_OW 284
44952: IFFALSE 44931
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44954: LD_VAR 0 2
44958: PPUSH
44959: LD_VAR 0 3
44963: PPUSH
44964: CALL_OW 283
44968: PUSH
44969: LD_INT 4
44971: EQUAL
44972: IFFALSE 44976
// exit ;
44974: GO 45284
// for i = 1 to mc_bases do
44976: LD_ADDR_VAR 0 7
44980: PUSH
44981: DOUBLE
44982: LD_INT 1
44984: DEC
44985: ST_TO_ADDR
44986: LD_EXP 50
44990: PUSH
44991: FOR_TO
44992: IFFALSE 45282
// begin if mc_crates_area [ i ] then
44994: LD_EXP 68
44998: PUSH
44999: LD_VAR 0 7
45003: ARRAY
45004: IFFALSE 45115
// for j in mc_crates_area [ i ] do
45006: LD_ADDR_VAR 0 8
45010: PUSH
45011: LD_EXP 68
45015: PUSH
45016: LD_VAR 0 7
45020: ARRAY
45021: PUSH
45022: FOR_IN
45023: IFFALSE 45113
// if InArea ( x , y , j ) then
45025: LD_VAR 0 2
45029: PPUSH
45030: LD_VAR 0 3
45034: PPUSH
45035: LD_VAR 0 8
45039: PPUSH
45040: CALL_OW 309
45044: IFFALSE 45111
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45046: LD_ADDR_EXP 66
45050: PUSH
45051: LD_EXP 66
45055: PPUSH
45056: LD_VAR 0 7
45060: PUSH
45061: LD_EXP 66
45065: PUSH
45066: LD_VAR 0 7
45070: ARRAY
45071: PUSH
45072: LD_INT 1
45074: PLUS
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PPUSH
45080: LD_VAR 0 4
45084: PUSH
45085: LD_VAR 0 2
45089: PUSH
45090: LD_VAR 0 3
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: LIST
45099: PPUSH
45100: CALL 53718 0 3
45104: ST_TO_ADDR
// exit ;
45105: POP
45106: POP
45107: POP
45108: POP
45109: GO 45284
// end ;
45111: GO 45022
45113: POP
45114: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45115: LD_ADDR_VAR 0 9
45119: PUSH
45120: LD_EXP 50
45124: PUSH
45125: LD_VAR 0 7
45129: ARRAY
45130: PPUSH
45131: LD_INT 2
45133: PUSH
45134: LD_INT 30
45136: PUSH
45137: LD_INT 0
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: LD_INT 30
45146: PUSH
45147: LD_INT 1
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: LIST
45158: PPUSH
45159: CALL_OW 72
45163: ST_TO_ADDR
// if not depot then
45164: LD_VAR 0 9
45168: NOT
45169: IFFALSE 45173
// continue ;
45171: GO 44991
// for j in depot do
45173: LD_ADDR_VAR 0 8
45177: PUSH
45178: LD_VAR 0 9
45182: PUSH
45183: FOR_IN
45184: IFFALSE 45278
// if GetDistUnitXY ( j , x , y ) < 30 then
45186: LD_VAR 0 8
45190: PPUSH
45191: LD_VAR 0 2
45195: PPUSH
45196: LD_VAR 0 3
45200: PPUSH
45201: CALL_OW 297
45205: PUSH
45206: LD_INT 30
45208: LESS
45209: IFFALSE 45276
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45211: LD_ADDR_EXP 66
45215: PUSH
45216: LD_EXP 66
45220: PPUSH
45221: LD_VAR 0 7
45225: PUSH
45226: LD_EXP 66
45230: PUSH
45231: LD_VAR 0 7
45235: ARRAY
45236: PUSH
45237: LD_INT 1
45239: PLUS
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PPUSH
45245: LD_VAR 0 4
45249: PUSH
45250: LD_VAR 0 2
45254: PUSH
45255: LD_VAR 0 3
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: LIST
45264: PPUSH
45265: CALL 53718 0 3
45269: ST_TO_ADDR
// exit ;
45270: POP
45271: POP
45272: POP
45273: POP
45274: GO 45284
// end ;
45276: GO 45183
45278: POP
45279: POP
// end ;
45280: GO 44991
45282: POP
45283: POP
// end ;
45284: LD_VAR 0 6
45288: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45289: LD_INT 0
45291: PPUSH
45292: PPUSH
45293: PPUSH
45294: PPUSH
// if not mc_bases or not skirmish then
45295: LD_EXP 50
45299: NOT
45300: PUSH
45301: LD_EXP 48
45305: NOT
45306: OR
45307: IFFALSE 45311
// exit ;
45309: GO 45588
// side := GetSide ( lab ) ;
45311: LD_ADDR_VAR 0 4
45315: PUSH
45316: LD_VAR 0 2
45320: PPUSH
45321: CALL_OW 255
45325: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45326: LD_VAR 0 4
45330: PUSH
45331: LD_EXP 76
45335: IN
45336: NOT
45337: PUSH
45338: LD_EXP 77
45342: NOT
45343: OR
45344: PUSH
45345: LD_EXP 50
45349: NOT
45350: OR
45351: IFFALSE 45355
// exit ;
45353: GO 45588
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45355: LD_ADDR_EXP 77
45359: PUSH
45360: LD_EXP 77
45364: PPUSH
45365: LD_VAR 0 4
45369: PPUSH
45370: LD_EXP 77
45374: PUSH
45375: LD_VAR 0 4
45379: ARRAY
45380: PUSH
45381: LD_VAR 0 1
45385: DIFF
45386: PPUSH
45387: CALL_OW 1
45391: ST_TO_ADDR
// for i = 1 to mc_bases do
45392: LD_ADDR_VAR 0 5
45396: PUSH
45397: DOUBLE
45398: LD_INT 1
45400: DEC
45401: ST_TO_ADDR
45402: LD_EXP 50
45406: PUSH
45407: FOR_TO
45408: IFFALSE 45586
// begin if lab in mc_bases [ i ] then
45410: LD_VAR 0 2
45414: PUSH
45415: LD_EXP 50
45419: PUSH
45420: LD_VAR 0 5
45424: ARRAY
45425: IN
45426: IFFALSE 45584
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45428: LD_VAR 0 1
45432: PUSH
45433: LD_INT 11
45435: PUSH
45436: LD_INT 4
45438: PUSH
45439: LD_INT 3
45441: PUSH
45442: LD_INT 2
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: IN
45451: PUSH
45452: LD_EXP 80
45456: PUSH
45457: LD_VAR 0 5
45461: ARRAY
45462: AND
45463: IFFALSE 45584
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45465: LD_ADDR_VAR 0 6
45469: PUSH
45470: LD_EXP 80
45474: PUSH
45475: LD_VAR 0 5
45479: ARRAY
45480: PUSH
45481: LD_INT 1
45483: ARRAY
45484: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45485: LD_ADDR_EXP 80
45489: PUSH
45490: LD_EXP 80
45494: PPUSH
45495: LD_VAR 0 5
45499: PPUSH
45500: EMPTY
45501: PPUSH
45502: CALL_OW 1
45506: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45507: LD_VAR 0 6
45511: PPUSH
45512: LD_INT 0
45514: PPUSH
45515: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45519: LD_VAR 0 6
45523: PPUSH
45524: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45528: LD_ADDR_EXP 79
45532: PUSH
45533: LD_EXP 79
45537: PPUSH
45538: LD_VAR 0 5
45542: PPUSH
45543: LD_EXP 79
45547: PUSH
45548: LD_VAR 0 5
45552: ARRAY
45553: PPUSH
45554: LD_INT 1
45556: PPUSH
45557: LD_VAR 0 6
45561: PPUSH
45562: CALL_OW 2
45566: PPUSH
45567: CALL_OW 1
45571: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45572: LD_VAR 0 5
45576: PPUSH
45577: LD_INT 112
45579: PPUSH
45580: CALL 22107 0 2
// end ; end ; end ;
45584: GO 45407
45586: POP
45587: POP
// end ;
45588: LD_VAR 0 3
45592: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45593: LD_INT 0
45595: PPUSH
45596: PPUSH
45597: PPUSH
45598: PPUSH
45599: PPUSH
45600: PPUSH
45601: PPUSH
45602: PPUSH
// if not mc_bases or not skirmish then
45603: LD_EXP 50
45607: NOT
45608: PUSH
45609: LD_EXP 48
45613: NOT
45614: OR
45615: IFFALSE 45619
// exit ;
45617: GO 46990
// for i = 1 to mc_bases do
45619: LD_ADDR_VAR 0 3
45623: PUSH
45624: DOUBLE
45625: LD_INT 1
45627: DEC
45628: ST_TO_ADDR
45629: LD_EXP 50
45633: PUSH
45634: FOR_TO
45635: IFFALSE 46988
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45637: LD_VAR 0 1
45641: PUSH
45642: LD_EXP 50
45646: PUSH
45647: LD_VAR 0 3
45651: ARRAY
45652: IN
45653: PUSH
45654: LD_VAR 0 1
45658: PUSH
45659: LD_EXP 57
45663: PUSH
45664: LD_VAR 0 3
45668: ARRAY
45669: IN
45670: OR
45671: PUSH
45672: LD_VAR 0 1
45676: PUSH
45677: LD_EXP 72
45681: PUSH
45682: LD_VAR 0 3
45686: ARRAY
45687: IN
45688: OR
45689: PUSH
45690: LD_VAR 0 1
45694: PUSH
45695: LD_EXP 69
45699: PUSH
45700: LD_VAR 0 3
45704: ARRAY
45705: IN
45706: OR
45707: PUSH
45708: LD_VAR 0 1
45712: PUSH
45713: LD_EXP 79
45717: PUSH
45718: LD_VAR 0 3
45722: ARRAY
45723: IN
45724: OR
45725: PUSH
45726: LD_VAR 0 1
45730: PUSH
45731: LD_EXP 80
45735: PUSH
45736: LD_VAR 0 3
45740: ARRAY
45741: IN
45742: OR
45743: IFFALSE 46986
// begin if un in mc_ape [ i ] then
45745: LD_VAR 0 1
45749: PUSH
45750: LD_EXP 79
45754: PUSH
45755: LD_VAR 0 3
45759: ARRAY
45760: IN
45761: IFFALSE 45800
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45763: LD_ADDR_EXP 79
45767: PUSH
45768: LD_EXP 79
45772: PPUSH
45773: LD_VAR 0 3
45777: PPUSH
45778: LD_EXP 79
45782: PUSH
45783: LD_VAR 0 3
45787: ARRAY
45788: PUSH
45789: LD_VAR 0 1
45793: DIFF
45794: PPUSH
45795: CALL_OW 1
45799: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45800: LD_VAR 0 1
45804: PUSH
45805: LD_EXP 80
45809: PUSH
45810: LD_VAR 0 3
45814: ARRAY
45815: IN
45816: IFFALSE 45840
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45818: LD_ADDR_EXP 80
45822: PUSH
45823: LD_EXP 80
45827: PPUSH
45828: LD_VAR 0 3
45832: PPUSH
45833: EMPTY
45834: PPUSH
45835: CALL_OW 1
45839: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45840: LD_VAR 0 1
45844: PPUSH
45845: CALL_OW 247
45849: PUSH
45850: LD_INT 2
45852: EQUAL
45853: PUSH
45854: LD_VAR 0 1
45858: PPUSH
45859: CALL_OW 110
45863: PUSH
45864: LD_INT 20
45866: EQUAL
45867: PUSH
45868: LD_VAR 0 1
45872: PUSH
45873: LD_EXP 72
45877: PUSH
45878: LD_VAR 0 3
45882: ARRAY
45883: IN
45884: OR
45885: PUSH
45886: LD_VAR 0 1
45890: PPUSH
45891: CALL_OW 264
45895: PUSH
45896: LD_INT 12
45898: PUSH
45899: LD_INT 51
45901: PUSH
45902: LD_EXP 95
45906: PUSH
45907: LD_INT 32
45909: PUSH
45910: LD_INT 13
45912: PUSH
45913: LD_INT 52
45915: PUSH
45916: LD_INT 31
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: IN
45928: OR
45929: AND
45930: IFFALSE 46238
// begin if un in mc_defender [ i ] then
45932: LD_VAR 0 1
45936: PUSH
45937: LD_EXP 72
45941: PUSH
45942: LD_VAR 0 3
45946: ARRAY
45947: IN
45948: IFFALSE 45987
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45950: LD_ADDR_EXP 72
45954: PUSH
45955: LD_EXP 72
45959: PPUSH
45960: LD_VAR 0 3
45964: PPUSH
45965: LD_EXP 72
45969: PUSH
45970: LD_VAR 0 3
45974: ARRAY
45975: PUSH
45976: LD_VAR 0 1
45980: DIFF
45981: PPUSH
45982: CALL_OW 1
45986: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45987: LD_ADDR_VAR 0 8
45991: PUSH
45992: LD_VAR 0 3
45996: PPUSH
45997: LD_INT 3
45999: PPUSH
46000: CALL 42628 0 2
46004: ST_TO_ADDR
// if fac then
46005: LD_VAR 0 8
46009: IFFALSE 46238
// begin for j in fac do
46011: LD_ADDR_VAR 0 4
46015: PUSH
46016: LD_VAR 0 8
46020: PUSH
46021: FOR_IN
46022: IFFALSE 46236
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46024: LD_ADDR_VAR 0 9
46028: PUSH
46029: LD_VAR 0 8
46033: PPUSH
46034: LD_VAR 0 1
46038: PPUSH
46039: CALL_OW 265
46043: PPUSH
46044: LD_VAR 0 1
46048: PPUSH
46049: CALL_OW 262
46053: PPUSH
46054: LD_VAR 0 1
46058: PPUSH
46059: CALL_OW 263
46063: PPUSH
46064: LD_VAR 0 1
46068: PPUSH
46069: CALL_OW 264
46073: PPUSH
46074: CALL 51214 0 5
46078: ST_TO_ADDR
// if components then
46079: LD_VAR 0 9
46083: IFFALSE 46234
// begin if GetWeapon ( un ) = ar_control_tower then
46085: LD_VAR 0 1
46089: PPUSH
46090: CALL_OW 264
46094: PUSH
46095: LD_INT 31
46097: EQUAL
46098: IFFALSE 46215
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 311
46109: PPUSH
46110: LD_INT 0
46112: PPUSH
46113: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46117: LD_ADDR_EXP 90
46121: PUSH
46122: LD_EXP 90
46126: PPUSH
46127: LD_VAR 0 3
46131: PPUSH
46132: LD_EXP 90
46136: PUSH
46137: LD_VAR 0 3
46141: ARRAY
46142: PUSH
46143: LD_VAR 0 1
46147: PPUSH
46148: CALL_OW 311
46152: DIFF
46153: PPUSH
46154: CALL_OW 1
46158: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46159: LD_ADDR_VAR 0 7
46163: PUSH
46164: LD_EXP 71
46168: PUSH
46169: LD_VAR 0 3
46173: ARRAY
46174: PPUSH
46175: LD_INT 1
46177: PPUSH
46178: LD_VAR 0 9
46182: PPUSH
46183: CALL_OW 2
46187: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46188: LD_ADDR_EXP 71
46192: PUSH
46193: LD_EXP 71
46197: PPUSH
46198: LD_VAR 0 3
46202: PPUSH
46203: LD_VAR 0 7
46207: PPUSH
46208: CALL_OW 1
46212: ST_TO_ADDR
// end else
46213: GO 46232
// MC_InsertProduceList ( i , [ components ] ) ;
46215: LD_VAR 0 3
46219: PPUSH
46220: LD_VAR 0 9
46224: PUSH
46225: EMPTY
46226: LIST
46227: PPUSH
46228: CALL 42173 0 2
// break ;
46232: GO 46236
// end ; end ;
46234: GO 46021
46236: POP
46237: POP
// end ; end ; if GetType ( un ) = unit_building then
46238: LD_VAR 0 1
46242: PPUSH
46243: CALL_OW 247
46247: PUSH
46248: LD_INT 3
46250: EQUAL
46251: IFFALSE 46654
// begin btype := GetBType ( un ) ;
46253: LD_ADDR_VAR 0 5
46257: PUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: CALL_OW 266
46267: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46268: LD_VAR 0 5
46272: PUSH
46273: LD_INT 29
46275: PUSH
46276: LD_INT 30
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: IN
46283: IFFALSE 46356
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46285: LD_VAR 0 1
46289: PPUSH
46290: CALL_OW 250
46294: PPUSH
46295: LD_VAR 0 1
46299: PPUSH
46300: CALL_OW 251
46304: PPUSH
46305: LD_VAR 0 1
46309: PPUSH
46310: CALL_OW 255
46314: PPUSH
46315: CALL_OW 440
46319: NOT
46320: IFFALSE 46356
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46322: LD_VAR 0 1
46326: PPUSH
46327: CALL_OW 250
46331: PPUSH
46332: LD_VAR 0 1
46336: PPUSH
46337: CALL_OW 251
46341: PPUSH
46342: LD_VAR 0 1
46346: PPUSH
46347: CALL_OW 255
46351: PPUSH
46352: CALL_OW 441
// end ; if btype = b_warehouse then
46356: LD_VAR 0 5
46360: PUSH
46361: LD_INT 1
46363: EQUAL
46364: IFFALSE 46382
// begin btype := b_depot ;
46366: LD_ADDR_VAR 0 5
46370: PUSH
46371: LD_INT 0
46373: ST_TO_ADDR
// pos := 1 ;
46374: LD_ADDR_VAR 0 6
46378: PUSH
46379: LD_INT 1
46381: ST_TO_ADDR
// end ; if btype = b_factory then
46382: LD_VAR 0 5
46386: PUSH
46387: LD_INT 3
46389: EQUAL
46390: IFFALSE 46408
// begin btype := b_workshop ;
46392: LD_ADDR_VAR 0 5
46396: PUSH
46397: LD_INT 2
46399: ST_TO_ADDR
// pos := 1 ;
46400: LD_ADDR_VAR 0 6
46404: PUSH
46405: LD_INT 1
46407: ST_TO_ADDR
// end ; if btype = b_barracks then
46408: LD_VAR 0 5
46412: PUSH
46413: LD_INT 5
46415: EQUAL
46416: IFFALSE 46426
// btype := b_armoury ;
46418: LD_ADDR_VAR 0 5
46422: PUSH
46423: LD_INT 4
46425: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46426: LD_VAR 0 5
46430: PUSH
46431: LD_INT 7
46433: PUSH
46434: LD_INT 8
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: IN
46441: IFFALSE 46451
// btype := b_lab ;
46443: LD_ADDR_VAR 0 5
46447: PUSH
46448: LD_INT 6
46450: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46451: LD_ADDR_EXP 55
46455: PUSH
46456: LD_EXP 55
46460: PPUSH
46461: LD_VAR 0 3
46465: PUSH
46466: LD_EXP 55
46470: PUSH
46471: LD_VAR 0 3
46475: ARRAY
46476: PUSH
46477: LD_INT 1
46479: PLUS
46480: PUSH
46481: EMPTY
46482: LIST
46483: LIST
46484: PPUSH
46485: LD_VAR 0 5
46489: PUSH
46490: LD_VAR 0 1
46494: PPUSH
46495: CALL_OW 250
46499: PUSH
46500: LD_VAR 0 1
46504: PPUSH
46505: CALL_OW 251
46509: PUSH
46510: LD_VAR 0 1
46514: PPUSH
46515: CALL_OW 254
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: PPUSH
46526: CALL 53718 0 3
46530: ST_TO_ADDR
// if pos = 1 then
46531: LD_VAR 0 6
46535: PUSH
46536: LD_INT 1
46538: EQUAL
46539: IFFALSE 46654
// begin tmp := mc_build_list [ i ] ;
46541: LD_ADDR_VAR 0 7
46545: PUSH
46546: LD_EXP 55
46550: PUSH
46551: LD_VAR 0 3
46555: ARRAY
46556: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46557: LD_VAR 0 7
46561: PPUSH
46562: LD_INT 2
46564: PUSH
46565: LD_INT 30
46567: PUSH
46568: LD_INT 0
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 30
46577: PUSH
46578: LD_INT 1
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: LIST
46589: PPUSH
46590: CALL_OW 72
46594: IFFALSE 46604
// pos := 2 ;
46596: LD_ADDR_VAR 0 6
46600: PUSH
46601: LD_INT 2
46603: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46604: LD_ADDR_VAR 0 7
46608: PUSH
46609: LD_VAR 0 7
46613: PPUSH
46614: LD_VAR 0 6
46618: PPUSH
46619: LD_VAR 0 7
46623: PPUSH
46624: CALL 54044 0 3
46628: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46629: LD_ADDR_EXP 55
46633: PUSH
46634: LD_EXP 55
46638: PPUSH
46639: LD_VAR 0 3
46643: PPUSH
46644: LD_VAR 0 7
46648: PPUSH
46649: CALL_OW 1
46653: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46654: LD_VAR 0 1
46658: PUSH
46659: LD_EXP 50
46663: PUSH
46664: LD_VAR 0 3
46668: ARRAY
46669: IN
46670: IFFALSE 46709
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46672: LD_ADDR_EXP 50
46676: PUSH
46677: LD_EXP 50
46681: PPUSH
46682: LD_VAR 0 3
46686: PPUSH
46687: LD_EXP 50
46691: PUSH
46692: LD_VAR 0 3
46696: ARRAY
46697: PUSH
46698: LD_VAR 0 1
46702: DIFF
46703: PPUSH
46704: CALL_OW 1
46708: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46709: LD_VAR 0 1
46713: PUSH
46714: LD_EXP 57
46718: PUSH
46719: LD_VAR 0 3
46723: ARRAY
46724: IN
46725: IFFALSE 46764
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46727: LD_ADDR_EXP 57
46731: PUSH
46732: LD_EXP 57
46736: PPUSH
46737: LD_VAR 0 3
46741: PPUSH
46742: LD_EXP 57
46746: PUSH
46747: LD_VAR 0 3
46751: ARRAY
46752: PUSH
46753: LD_VAR 0 1
46757: DIFF
46758: PPUSH
46759: CALL_OW 1
46763: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46764: LD_VAR 0 1
46768: PUSH
46769: LD_EXP 69
46773: PUSH
46774: LD_VAR 0 3
46778: ARRAY
46779: IN
46780: IFFALSE 46819
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46782: LD_ADDR_EXP 69
46786: PUSH
46787: LD_EXP 69
46791: PPUSH
46792: LD_VAR 0 3
46796: PPUSH
46797: LD_EXP 69
46801: PUSH
46802: LD_VAR 0 3
46806: ARRAY
46807: PUSH
46808: LD_VAR 0 1
46812: DIFF
46813: PPUSH
46814: CALL_OW 1
46818: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46819: LD_VAR 0 1
46823: PUSH
46824: LD_EXP 72
46828: PUSH
46829: LD_VAR 0 3
46833: ARRAY
46834: IN
46835: IFFALSE 46874
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46837: LD_ADDR_EXP 72
46841: PUSH
46842: LD_EXP 72
46846: PPUSH
46847: LD_VAR 0 3
46851: PPUSH
46852: LD_EXP 72
46856: PUSH
46857: LD_VAR 0 3
46861: ARRAY
46862: PUSH
46863: LD_VAR 0 1
46867: DIFF
46868: PPUSH
46869: CALL_OW 1
46873: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46874: LD_VAR 0 1
46878: PUSH
46879: LD_EXP 59
46883: PUSH
46884: LD_VAR 0 3
46888: ARRAY
46889: IN
46890: IFFALSE 46929
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46892: LD_ADDR_EXP 59
46896: PUSH
46897: LD_EXP 59
46901: PPUSH
46902: LD_VAR 0 3
46906: PPUSH
46907: LD_EXP 59
46911: PUSH
46912: LD_VAR 0 3
46916: ARRAY
46917: PUSH
46918: LD_VAR 0 1
46922: DIFF
46923: PPUSH
46924: CALL_OW 1
46928: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46929: LD_VAR 0 1
46933: PUSH
46934: LD_EXP 58
46938: PUSH
46939: LD_VAR 0 3
46943: ARRAY
46944: IN
46945: IFFALSE 46984
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46947: LD_ADDR_EXP 58
46951: PUSH
46952: LD_EXP 58
46956: PPUSH
46957: LD_VAR 0 3
46961: PPUSH
46962: LD_EXP 58
46966: PUSH
46967: LD_VAR 0 3
46971: ARRAY
46972: PUSH
46973: LD_VAR 0 1
46977: DIFF
46978: PPUSH
46979: CALL_OW 1
46983: ST_TO_ADDR
// end ; break ;
46984: GO 46988
// end ;
46986: GO 45634
46988: POP
46989: POP
// end ;
46990: LD_VAR 0 2
46994: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46995: LD_INT 0
46997: PPUSH
46998: PPUSH
46999: PPUSH
// if not mc_bases or not skirmish then
47000: LD_EXP 50
47004: NOT
47005: PUSH
47006: LD_EXP 48
47010: NOT
47011: OR
47012: IFFALSE 47016
// exit ;
47014: GO 47231
// for i = 1 to mc_bases do
47016: LD_ADDR_VAR 0 3
47020: PUSH
47021: DOUBLE
47022: LD_INT 1
47024: DEC
47025: ST_TO_ADDR
47026: LD_EXP 50
47030: PUSH
47031: FOR_TO
47032: IFFALSE 47229
// begin if building in mc_construct_list [ i ] then
47034: LD_VAR 0 1
47038: PUSH
47039: LD_EXP 57
47043: PUSH
47044: LD_VAR 0 3
47048: ARRAY
47049: IN
47050: IFFALSE 47227
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47052: LD_ADDR_EXP 57
47056: PUSH
47057: LD_EXP 57
47061: PPUSH
47062: LD_VAR 0 3
47066: PPUSH
47067: LD_EXP 57
47071: PUSH
47072: LD_VAR 0 3
47076: ARRAY
47077: PUSH
47078: LD_VAR 0 1
47082: DIFF
47083: PPUSH
47084: CALL_OW 1
47088: ST_TO_ADDR
// if building in mc_lab [ i ] then
47089: LD_VAR 0 1
47093: PUSH
47094: LD_EXP 83
47098: PUSH
47099: LD_VAR 0 3
47103: ARRAY
47104: IN
47105: IFFALSE 47160
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47107: LD_ADDR_EXP 84
47111: PUSH
47112: LD_EXP 84
47116: PPUSH
47117: LD_VAR 0 3
47121: PPUSH
47122: LD_EXP 84
47126: PUSH
47127: LD_VAR 0 3
47131: ARRAY
47132: PPUSH
47133: LD_INT 1
47135: PPUSH
47136: LD_EXP 84
47140: PUSH
47141: LD_VAR 0 3
47145: ARRAY
47146: PPUSH
47147: LD_INT 0
47149: PPUSH
47150: CALL 53136 0 4
47154: PPUSH
47155: CALL_OW 1
47159: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47160: LD_VAR 0 1
47164: PUSH
47165: LD_EXP 50
47169: PUSH
47170: LD_VAR 0 3
47174: ARRAY
47175: IN
47176: NOT
47177: IFFALSE 47223
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47179: LD_ADDR_EXP 50
47183: PUSH
47184: LD_EXP 50
47188: PPUSH
47189: LD_VAR 0 3
47193: PUSH
47194: LD_EXP 50
47198: PUSH
47199: LD_VAR 0 3
47203: ARRAY
47204: PUSH
47205: LD_INT 1
47207: PLUS
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PPUSH
47213: LD_VAR 0 1
47217: PPUSH
47218: CALL 53718 0 3
47222: ST_TO_ADDR
// exit ;
47223: POP
47224: POP
47225: GO 47231
// end ; end ;
47227: GO 47031
47229: POP
47230: POP
// end ;
47231: LD_VAR 0 2
47235: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47236: LD_INT 0
47238: PPUSH
47239: PPUSH
47240: PPUSH
47241: PPUSH
47242: PPUSH
47243: PPUSH
47244: PPUSH
// if not mc_bases or not skirmish then
47245: LD_EXP 50
47249: NOT
47250: PUSH
47251: LD_EXP 48
47255: NOT
47256: OR
47257: IFFALSE 47261
// exit ;
47259: GO 47922
// for i = 1 to mc_bases do
47261: LD_ADDR_VAR 0 3
47265: PUSH
47266: DOUBLE
47267: LD_INT 1
47269: DEC
47270: ST_TO_ADDR
47271: LD_EXP 50
47275: PUSH
47276: FOR_TO
47277: IFFALSE 47920
// begin if building in mc_construct_list [ i ] then
47279: LD_VAR 0 1
47283: PUSH
47284: LD_EXP 57
47288: PUSH
47289: LD_VAR 0 3
47293: ARRAY
47294: IN
47295: IFFALSE 47918
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47297: LD_ADDR_EXP 57
47301: PUSH
47302: LD_EXP 57
47306: PPUSH
47307: LD_VAR 0 3
47311: PPUSH
47312: LD_EXP 57
47316: PUSH
47317: LD_VAR 0 3
47321: ARRAY
47322: PUSH
47323: LD_VAR 0 1
47327: DIFF
47328: PPUSH
47329: CALL_OW 1
47333: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47334: LD_ADDR_EXP 50
47338: PUSH
47339: LD_EXP 50
47343: PPUSH
47344: LD_VAR 0 3
47348: PUSH
47349: LD_EXP 50
47353: PUSH
47354: LD_VAR 0 3
47358: ARRAY
47359: PUSH
47360: LD_INT 1
47362: PLUS
47363: PUSH
47364: EMPTY
47365: LIST
47366: LIST
47367: PPUSH
47368: LD_VAR 0 1
47372: PPUSH
47373: CALL 53718 0 3
47377: ST_TO_ADDR
// btype := GetBType ( building ) ;
47378: LD_ADDR_VAR 0 5
47382: PUSH
47383: LD_VAR 0 1
47387: PPUSH
47388: CALL_OW 266
47392: ST_TO_ADDR
// side := GetSide ( building ) ;
47393: LD_ADDR_VAR 0 8
47397: PUSH
47398: LD_VAR 0 1
47402: PPUSH
47403: CALL_OW 255
47407: ST_TO_ADDR
// if btype = b_lab then
47408: LD_VAR 0 5
47412: PUSH
47413: LD_INT 6
47415: EQUAL
47416: IFFALSE 47466
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47418: LD_ADDR_EXP 83
47422: PUSH
47423: LD_EXP 83
47427: PPUSH
47428: LD_VAR 0 3
47432: PUSH
47433: LD_EXP 83
47437: PUSH
47438: LD_VAR 0 3
47442: ARRAY
47443: PUSH
47444: LD_INT 1
47446: PLUS
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: PPUSH
47452: LD_VAR 0 1
47456: PPUSH
47457: CALL 53718 0 3
47461: ST_TO_ADDR
// exit ;
47462: POP
47463: POP
47464: GO 47922
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47466: LD_VAR 0 5
47470: PUSH
47471: LD_INT 0
47473: PUSH
47474: LD_INT 2
47476: PUSH
47477: LD_INT 4
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: LIST
47484: IN
47485: IFFALSE 47609
// begin if btype = b_armoury then
47487: LD_VAR 0 5
47491: PUSH
47492: LD_INT 4
47494: EQUAL
47495: IFFALSE 47505
// btype := b_barracks ;
47497: LD_ADDR_VAR 0 5
47501: PUSH
47502: LD_INT 5
47504: ST_TO_ADDR
// if btype = b_depot then
47505: LD_VAR 0 5
47509: PUSH
47510: LD_INT 0
47512: EQUAL
47513: IFFALSE 47523
// btype := b_warehouse ;
47515: LD_ADDR_VAR 0 5
47519: PUSH
47520: LD_INT 1
47522: ST_TO_ADDR
// if btype = b_workshop then
47523: LD_VAR 0 5
47527: PUSH
47528: LD_INT 2
47530: EQUAL
47531: IFFALSE 47541
// btype := b_factory ;
47533: LD_ADDR_VAR 0 5
47537: PUSH
47538: LD_INT 3
47540: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47541: LD_VAR 0 5
47545: PPUSH
47546: LD_VAR 0 8
47550: PPUSH
47551: CALL_OW 323
47555: PUSH
47556: LD_INT 1
47558: EQUAL
47559: IFFALSE 47605
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47561: LD_ADDR_EXP 82
47565: PUSH
47566: LD_EXP 82
47570: PPUSH
47571: LD_VAR 0 3
47575: PUSH
47576: LD_EXP 82
47580: PUSH
47581: LD_VAR 0 3
47585: ARRAY
47586: PUSH
47587: LD_INT 1
47589: PLUS
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PPUSH
47595: LD_VAR 0 1
47599: PPUSH
47600: CALL 53718 0 3
47604: ST_TO_ADDR
// exit ;
47605: POP
47606: POP
47607: GO 47922
// end ; if btype in [ b_bunker , b_turret ] then
47609: LD_VAR 0 5
47613: PUSH
47614: LD_INT 32
47616: PUSH
47617: LD_INT 33
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: IN
47624: IFFALSE 47914
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47626: LD_ADDR_EXP 58
47630: PUSH
47631: LD_EXP 58
47635: PPUSH
47636: LD_VAR 0 3
47640: PUSH
47641: LD_EXP 58
47645: PUSH
47646: LD_VAR 0 3
47650: ARRAY
47651: PUSH
47652: LD_INT 1
47654: PLUS
47655: PUSH
47656: EMPTY
47657: LIST
47658: LIST
47659: PPUSH
47660: LD_VAR 0 1
47664: PPUSH
47665: CALL 53718 0 3
47669: ST_TO_ADDR
// if btype = b_bunker then
47670: LD_VAR 0 5
47674: PUSH
47675: LD_INT 32
47677: EQUAL
47678: IFFALSE 47914
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47680: LD_ADDR_EXP 59
47684: PUSH
47685: LD_EXP 59
47689: PPUSH
47690: LD_VAR 0 3
47694: PUSH
47695: LD_EXP 59
47699: PUSH
47700: LD_VAR 0 3
47704: ARRAY
47705: PUSH
47706: LD_INT 1
47708: PLUS
47709: PUSH
47710: EMPTY
47711: LIST
47712: LIST
47713: PPUSH
47714: LD_VAR 0 1
47718: PPUSH
47719: CALL 53718 0 3
47723: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47724: LD_ADDR_VAR 0 6
47728: PUSH
47729: LD_EXP 50
47733: PUSH
47734: LD_VAR 0 3
47738: ARRAY
47739: PPUSH
47740: LD_INT 25
47742: PUSH
47743: LD_INT 1
47745: PUSH
47746: EMPTY
47747: LIST
47748: LIST
47749: PUSH
47750: LD_INT 3
47752: PUSH
47753: LD_INT 54
47755: PUSH
47756: EMPTY
47757: LIST
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: PPUSH
47767: CALL_OW 72
47771: ST_TO_ADDR
// if tmp then
47772: LD_VAR 0 6
47776: IFFALSE 47782
// exit ;
47778: POP
47779: POP
47780: GO 47922
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47782: LD_ADDR_VAR 0 6
47786: PUSH
47787: LD_EXP 50
47791: PUSH
47792: LD_VAR 0 3
47796: ARRAY
47797: PPUSH
47798: LD_INT 2
47800: PUSH
47801: LD_INT 30
47803: PUSH
47804: LD_INT 4
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: PUSH
47811: LD_INT 30
47813: PUSH
47814: LD_INT 5
47816: PUSH
47817: EMPTY
47818: LIST
47819: LIST
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: LIST
47825: PPUSH
47826: CALL_OW 72
47830: ST_TO_ADDR
// if not tmp then
47831: LD_VAR 0 6
47835: NOT
47836: IFFALSE 47842
// exit ;
47838: POP
47839: POP
47840: GO 47922
// for j in tmp do
47842: LD_ADDR_VAR 0 4
47846: PUSH
47847: LD_VAR 0 6
47851: PUSH
47852: FOR_IN
47853: IFFALSE 47912
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47855: LD_ADDR_VAR 0 7
47859: PUSH
47860: LD_VAR 0 4
47864: PPUSH
47865: CALL_OW 313
47869: PPUSH
47870: LD_INT 25
47872: PUSH
47873: LD_INT 1
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PPUSH
47880: CALL_OW 72
47884: ST_TO_ADDR
// if units then
47885: LD_VAR 0 7
47889: IFFALSE 47910
// begin ComExitBuilding ( units [ 1 ] ) ;
47891: LD_VAR 0 7
47895: PUSH
47896: LD_INT 1
47898: ARRAY
47899: PPUSH
47900: CALL_OW 122
// exit ;
47904: POP
47905: POP
47906: POP
47907: POP
47908: GO 47922
// end ; end ;
47910: GO 47852
47912: POP
47913: POP
// end ; end ; exit ;
47914: POP
47915: POP
47916: GO 47922
// end ; end ;
47918: GO 47276
47920: POP
47921: POP
// end ;
47922: LD_VAR 0 2
47926: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47927: LD_INT 0
47929: PPUSH
47930: PPUSH
47931: PPUSH
47932: PPUSH
47933: PPUSH
47934: PPUSH
47935: PPUSH
// if not mc_bases or not skirmish then
47936: LD_EXP 50
47940: NOT
47941: PUSH
47942: LD_EXP 48
47946: NOT
47947: OR
47948: IFFALSE 47952
// exit ;
47950: GO 48217
// btype := GetBType ( building ) ;
47952: LD_ADDR_VAR 0 6
47956: PUSH
47957: LD_VAR 0 1
47961: PPUSH
47962: CALL_OW 266
47966: ST_TO_ADDR
// x := GetX ( building ) ;
47967: LD_ADDR_VAR 0 7
47971: PUSH
47972: LD_VAR 0 1
47976: PPUSH
47977: CALL_OW 250
47981: ST_TO_ADDR
// y := GetY ( building ) ;
47982: LD_ADDR_VAR 0 8
47986: PUSH
47987: LD_VAR 0 1
47991: PPUSH
47992: CALL_OW 251
47996: ST_TO_ADDR
// d := GetDir ( building ) ;
47997: LD_ADDR_VAR 0 9
48001: PUSH
48002: LD_VAR 0 1
48006: PPUSH
48007: CALL_OW 254
48011: ST_TO_ADDR
// for i = 1 to mc_bases do
48012: LD_ADDR_VAR 0 4
48016: PUSH
48017: DOUBLE
48018: LD_INT 1
48020: DEC
48021: ST_TO_ADDR
48022: LD_EXP 50
48026: PUSH
48027: FOR_TO
48028: IFFALSE 48215
// begin if not mc_build_list [ i ] then
48030: LD_EXP 55
48034: PUSH
48035: LD_VAR 0 4
48039: ARRAY
48040: NOT
48041: IFFALSE 48045
// continue ;
48043: GO 48027
// for j := 1 to mc_build_list [ i ] do
48045: LD_ADDR_VAR 0 5
48049: PUSH
48050: DOUBLE
48051: LD_INT 1
48053: DEC
48054: ST_TO_ADDR
48055: LD_EXP 55
48059: PUSH
48060: LD_VAR 0 4
48064: ARRAY
48065: PUSH
48066: FOR_TO
48067: IFFALSE 48211
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48069: LD_VAR 0 6
48073: PUSH
48074: LD_VAR 0 7
48078: PUSH
48079: LD_VAR 0 8
48083: PUSH
48084: LD_VAR 0 9
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: PPUSH
48095: LD_EXP 55
48099: PUSH
48100: LD_VAR 0 4
48104: ARRAY
48105: PUSH
48106: LD_VAR 0 5
48110: ARRAY
48111: PPUSH
48112: CALL 59900 0 2
48116: IFFALSE 48209
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48118: LD_ADDR_EXP 55
48122: PUSH
48123: LD_EXP 55
48127: PPUSH
48128: LD_VAR 0 4
48132: PPUSH
48133: LD_EXP 55
48137: PUSH
48138: LD_VAR 0 4
48142: ARRAY
48143: PPUSH
48144: LD_VAR 0 5
48148: PPUSH
48149: CALL_OW 3
48153: PPUSH
48154: CALL_OW 1
48158: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48159: LD_ADDR_EXP 57
48163: PUSH
48164: LD_EXP 57
48168: PPUSH
48169: LD_VAR 0 4
48173: PUSH
48174: LD_EXP 57
48178: PUSH
48179: LD_VAR 0 4
48183: ARRAY
48184: PUSH
48185: LD_INT 1
48187: PLUS
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PPUSH
48193: LD_VAR 0 1
48197: PPUSH
48198: CALL 53718 0 3
48202: ST_TO_ADDR
// exit ;
48203: POP
48204: POP
48205: POP
48206: POP
48207: GO 48217
// end ;
48209: GO 48066
48211: POP
48212: POP
// end ;
48213: GO 48027
48215: POP
48216: POP
// end ;
48217: LD_VAR 0 3
48221: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48222: LD_INT 0
48224: PPUSH
48225: PPUSH
48226: PPUSH
// if not mc_bases or not skirmish then
48227: LD_EXP 50
48231: NOT
48232: PUSH
48233: LD_EXP 48
48237: NOT
48238: OR
48239: IFFALSE 48243
// exit ;
48241: GO 48433
// for i = 1 to mc_bases do
48243: LD_ADDR_VAR 0 4
48247: PUSH
48248: DOUBLE
48249: LD_INT 1
48251: DEC
48252: ST_TO_ADDR
48253: LD_EXP 50
48257: PUSH
48258: FOR_TO
48259: IFFALSE 48346
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48261: LD_VAR 0 1
48265: PUSH
48266: LD_EXP 58
48270: PUSH
48271: LD_VAR 0 4
48275: ARRAY
48276: IN
48277: PUSH
48278: LD_VAR 0 1
48282: PUSH
48283: LD_EXP 59
48287: PUSH
48288: LD_VAR 0 4
48292: ARRAY
48293: IN
48294: NOT
48295: AND
48296: IFFALSE 48344
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48298: LD_ADDR_EXP 59
48302: PUSH
48303: LD_EXP 59
48307: PPUSH
48308: LD_VAR 0 4
48312: PUSH
48313: LD_EXP 59
48317: PUSH
48318: LD_VAR 0 4
48322: ARRAY
48323: PUSH
48324: LD_INT 1
48326: PLUS
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PPUSH
48332: LD_VAR 0 1
48336: PPUSH
48337: CALL 53718 0 3
48341: ST_TO_ADDR
// break ;
48342: GO 48346
// end ; end ;
48344: GO 48258
48346: POP
48347: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48348: LD_VAR 0 1
48352: PPUSH
48353: CALL_OW 257
48357: PUSH
48358: LD_EXP 76
48362: IN
48363: PUSH
48364: LD_VAR 0 1
48368: PPUSH
48369: CALL_OW 266
48373: PUSH
48374: LD_INT 5
48376: EQUAL
48377: AND
48378: PUSH
48379: LD_VAR 0 2
48383: PPUSH
48384: CALL_OW 110
48388: PUSH
48389: LD_INT 18
48391: NONEQUAL
48392: AND
48393: IFFALSE 48433
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48395: LD_VAR 0 2
48399: PPUSH
48400: CALL_OW 257
48404: PUSH
48405: LD_INT 5
48407: PUSH
48408: LD_INT 8
48410: PUSH
48411: LD_INT 9
48413: PUSH
48414: EMPTY
48415: LIST
48416: LIST
48417: LIST
48418: IN
48419: IFFALSE 48433
// SetClass ( unit , 1 ) ;
48421: LD_VAR 0 2
48425: PPUSH
48426: LD_INT 1
48428: PPUSH
48429: CALL_OW 336
// end ;
48433: LD_VAR 0 3
48437: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48438: LD_INT 0
48440: PPUSH
48441: PPUSH
// if not mc_bases or not skirmish then
48442: LD_EXP 50
48446: NOT
48447: PUSH
48448: LD_EXP 48
48452: NOT
48453: OR
48454: IFFALSE 48458
// exit ;
48456: GO 48574
// if GetLives ( abandoned_vehicle ) > 250 then
48458: LD_VAR 0 2
48462: PPUSH
48463: CALL_OW 256
48467: PUSH
48468: LD_INT 250
48470: GREATER
48471: IFFALSE 48475
// exit ;
48473: GO 48574
// for i = 1 to mc_bases do
48475: LD_ADDR_VAR 0 6
48479: PUSH
48480: DOUBLE
48481: LD_INT 1
48483: DEC
48484: ST_TO_ADDR
48485: LD_EXP 50
48489: PUSH
48490: FOR_TO
48491: IFFALSE 48572
// begin if driver in mc_bases [ i ] then
48493: LD_VAR 0 1
48497: PUSH
48498: LD_EXP 50
48502: PUSH
48503: LD_VAR 0 6
48507: ARRAY
48508: IN
48509: IFFALSE 48570
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48511: LD_VAR 0 1
48515: PPUSH
48516: LD_EXP 50
48520: PUSH
48521: LD_VAR 0 6
48525: ARRAY
48526: PPUSH
48527: LD_INT 2
48529: PUSH
48530: LD_INT 30
48532: PUSH
48533: LD_INT 0
48535: PUSH
48536: EMPTY
48537: LIST
48538: LIST
48539: PUSH
48540: LD_INT 30
48542: PUSH
48543: LD_INT 1
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: LIST
48554: PPUSH
48555: CALL_OW 72
48559: PUSH
48560: LD_INT 1
48562: ARRAY
48563: PPUSH
48564: CALL 86857 0 2
// break ;
48568: GO 48572
// end ; end ;
48570: GO 48490
48572: POP
48573: POP
// end ; end_of_file
48574: LD_VAR 0 5
48578: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48579: LD_INT 0
48581: PPUSH
48582: PPUSH
// if exist_mode then
48583: LD_VAR 0 2
48587: IFFALSE 48612
// unit := CreateCharacter ( prefix & ident ) else
48589: LD_ADDR_VAR 0 5
48593: PUSH
48594: LD_VAR 0 3
48598: PUSH
48599: LD_VAR 0 1
48603: STR
48604: PPUSH
48605: CALL_OW 34
48609: ST_TO_ADDR
48610: GO 48627
// unit := NewCharacter ( ident ) ;
48612: LD_ADDR_VAR 0 5
48616: PUSH
48617: LD_VAR 0 1
48621: PPUSH
48622: CALL_OW 25
48626: ST_TO_ADDR
// result := unit ;
48627: LD_ADDR_VAR 0 4
48631: PUSH
48632: LD_VAR 0 5
48636: ST_TO_ADDR
// end ;
48637: LD_VAR 0 4
48641: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48642: LD_INT 0
48644: PPUSH
48645: PPUSH
// if not side or not nation then
48646: LD_VAR 0 1
48650: NOT
48651: PUSH
48652: LD_VAR 0 2
48656: NOT
48657: OR
48658: IFFALSE 48662
// exit ;
48660: GO 49430
// case nation of nation_american :
48662: LD_VAR 0 2
48666: PUSH
48667: LD_INT 1
48669: DOUBLE
48670: EQUAL
48671: IFTRUE 48675
48673: GO 48889
48675: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48676: LD_ADDR_VAR 0 4
48680: PUSH
48681: LD_INT 35
48683: PUSH
48684: LD_INT 45
48686: PUSH
48687: LD_INT 46
48689: PUSH
48690: LD_INT 47
48692: PUSH
48693: LD_INT 82
48695: PUSH
48696: LD_INT 83
48698: PUSH
48699: LD_INT 84
48701: PUSH
48702: LD_INT 85
48704: PUSH
48705: LD_INT 86
48707: PUSH
48708: LD_INT 1
48710: PUSH
48711: LD_INT 2
48713: PUSH
48714: LD_INT 6
48716: PUSH
48717: LD_INT 15
48719: PUSH
48720: LD_INT 16
48722: PUSH
48723: LD_INT 7
48725: PUSH
48726: LD_INT 12
48728: PUSH
48729: LD_INT 13
48731: PUSH
48732: LD_INT 10
48734: PUSH
48735: LD_INT 14
48737: PUSH
48738: LD_INT 20
48740: PUSH
48741: LD_INT 21
48743: PUSH
48744: LD_INT 22
48746: PUSH
48747: LD_INT 25
48749: PUSH
48750: LD_INT 32
48752: PUSH
48753: LD_INT 27
48755: PUSH
48756: LD_INT 36
48758: PUSH
48759: LD_INT 69
48761: PUSH
48762: LD_INT 39
48764: PUSH
48765: LD_INT 34
48767: PUSH
48768: LD_INT 40
48770: PUSH
48771: LD_INT 48
48773: PUSH
48774: LD_INT 49
48776: PUSH
48777: LD_INT 50
48779: PUSH
48780: LD_INT 51
48782: PUSH
48783: LD_INT 52
48785: PUSH
48786: LD_INT 53
48788: PUSH
48789: LD_INT 54
48791: PUSH
48792: LD_INT 55
48794: PUSH
48795: LD_INT 56
48797: PUSH
48798: LD_INT 57
48800: PUSH
48801: LD_INT 58
48803: PUSH
48804: LD_INT 59
48806: PUSH
48807: LD_INT 60
48809: PUSH
48810: LD_INT 61
48812: PUSH
48813: LD_INT 62
48815: PUSH
48816: LD_INT 80
48818: PUSH
48819: LD_INT 82
48821: PUSH
48822: LD_INT 83
48824: PUSH
48825: LD_INT 84
48827: PUSH
48828: LD_INT 85
48830: PUSH
48831: LD_INT 86
48833: PUSH
48834: EMPTY
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: LIST
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: LIST
48863: LIST
48864: LIST
48865: LIST
48866: LIST
48867: LIST
48868: LIST
48869: LIST
48870: LIST
48871: LIST
48872: LIST
48873: LIST
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: LIST
48879: LIST
48880: LIST
48881: LIST
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: ST_TO_ADDR
48887: GO 49354
48889: LD_INT 2
48891: DOUBLE
48892: EQUAL
48893: IFTRUE 48897
48895: GO 49123
48897: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48898: LD_ADDR_VAR 0 4
48902: PUSH
48903: LD_INT 35
48905: PUSH
48906: LD_INT 45
48908: PUSH
48909: LD_INT 46
48911: PUSH
48912: LD_INT 47
48914: PUSH
48915: LD_INT 82
48917: PUSH
48918: LD_INT 83
48920: PUSH
48921: LD_INT 84
48923: PUSH
48924: LD_INT 85
48926: PUSH
48927: LD_INT 87
48929: PUSH
48930: LD_INT 70
48932: PUSH
48933: LD_INT 1
48935: PUSH
48936: LD_INT 11
48938: PUSH
48939: LD_INT 3
48941: PUSH
48942: LD_INT 4
48944: PUSH
48945: LD_INT 5
48947: PUSH
48948: LD_INT 6
48950: PUSH
48951: LD_INT 15
48953: PUSH
48954: LD_INT 18
48956: PUSH
48957: LD_INT 7
48959: PUSH
48960: LD_INT 17
48962: PUSH
48963: LD_INT 8
48965: PUSH
48966: LD_INT 20
48968: PUSH
48969: LD_INT 21
48971: PUSH
48972: LD_INT 22
48974: PUSH
48975: LD_INT 72
48977: PUSH
48978: LD_INT 26
48980: PUSH
48981: LD_INT 69
48983: PUSH
48984: LD_INT 39
48986: PUSH
48987: LD_INT 40
48989: PUSH
48990: LD_INT 41
48992: PUSH
48993: LD_INT 42
48995: PUSH
48996: LD_INT 43
48998: PUSH
48999: LD_INT 48
49001: PUSH
49002: LD_INT 49
49004: PUSH
49005: LD_INT 50
49007: PUSH
49008: LD_INT 51
49010: PUSH
49011: LD_INT 52
49013: PUSH
49014: LD_INT 53
49016: PUSH
49017: LD_INT 54
49019: PUSH
49020: LD_INT 55
49022: PUSH
49023: LD_INT 56
49025: PUSH
49026: LD_INT 60
49028: PUSH
49029: LD_INT 61
49031: PUSH
49032: LD_INT 62
49034: PUSH
49035: LD_INT 66
49037: PUSH
49038: LD_INT 67
49040: PUSH
49041: LD_INT 68
49043: PUSH
49044: LD_INT 81
49046: PUSH
49047: LD_INT 82
49049: PUSH
49050: LD_INT 83
49052: PUSH
49053: LD_INT 84
49055: PUSH
49056: LD_INT 85
49058: PUSH
49059: LD_INT 87
49061: PUSH
49062: LD_INT 88
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: ST_TO_ADDR
49121: GO 49354
49123: LD_INT 3
49125: DOUBLE
49126: EQUAL
49127: IFTRUE 49131
49129: GO 49353
49131: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49132: LD_ADDR_VAR 0 4
49136: PUSH
49137: LD_INT 46
49139: PUSH
49140: LD_INT 47
49142: PUSH
49143: LD_INT 1
49145: PUSH
49146: LD_INT 2
49148: PUSH
49149: LD_INT 82
49151: PUSH
49152: LD_INT 83
49154: PUSH
49155: LD_INT 84
49157: PUSH
49158: LD_INT 85
49160: PUSH
49161: LD_INT 86
49163: PUSH
49164: LD_INT 11
49166: PUSH
49167: LD_INT 9
49169: PUSH
49170: LD_INT 20
49172: PUSH
49173: LD_INT 19
49175: PUSH
49176: LD_INT 21
49178: PUSH
49179: LD_INT 24
49181: PUSH
49182: LD_INT 22
49184: PUSH
49185: LD_INT 25
49187: PUSH
49188: LD_INT 28
49190: PUSH
49191: LD_INT 29
49193: PUSH
49194: LD_INT 30
49196: PUSH
49197: LD_INT 31
49199: PUSH
49200: LD_INT 37
49202: PUSH
49203: LD_INT 38
49205: PUSH
49206: LD_INT 32
49208: PUSH
49209: LD_INT 27
49211: PUSH
49212: LD_INT 33
49214: PUSH
49215: LD_INT 69
49217: PUSH
49218: LD_INT 39
49220: PUSH
49221: LD_INT 34
49223: PUSH
49224: LD_INT 40
49226: PUSH
49227: LD_INT 71
49229: PUSH
49230: LD_INT 23
49232: PUSH
49233: LD_INT 44
49235: PUSH
49236: LD_INT 48
49238: PUSH
49239: LD_INT 49
49241: PUSH
49242: LD_INT 50
49244: PUSH
49245: LD_INT 51
49247: PUSH
49248: LD_INT 52
49250: PUSH
49251: LD_INT 53
49253: PUSH
49254: LD_INT 54
49256: PUSH
49257: LD_INT 55
49259: PUSH
49260: LD_INT 56
49262: PUSH
49263: LD_INT 57
49265: PUSH
49266: LD_INT 58
49268: PUSH
49269: LD_INT 59
49271: PUSH
49272: LD_INT 63
49274: PUSH
49275: LD_INT 64
49277: PUSH
49278: LD_INT 65
49280: PUSH
49281: LD_INT 82
49283: PUSH
49284: LD_INT 83
49286: PUSH
49287: LD_INT 84
49289: PUSH
49290: LD_INT 85
49292: PUSH
49293: LD_INT 86
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: ST_TO_ADDR
49351: GO 49354
49353: POP
// if state > - 1 and state < 3 then
49354: LD_VAR 0 3
49358: PUSH
49359: LD_INT 1
49361: NEG
49362: GREATER
49363: PUSH
49364: LD_VAR 0 3
49368: PUSH
49369: LD_INT 3
49371: LESS
49372: AND
49373: IFFALSE 49430
// for i in result do
49375: LD_ADDR_VAR 0 5
49379: PUSH
49380: LD_VAR 0 4
49384: PUSH
49385: FOR_IN
49386: IFFALSE 49428
// if GetTech ( i , side ) <> state then
49388: LD_VAR 0 5
49392: PPUSH
49393: LD_VAR 0 1
49397: PPUSH
49398: CALL_OW 321
49402: PUSH
49403: LD_VAR 0 3
49407: NONEQUAL
49408: IFFALSE 49426
// result := result diff i ;
49410: LD_ADDR_VAR 0 4
49414: PUSH
49415: LD_VAR 0 4
49419: PUSH
49420: LD_VAR 0 5
49424: DIFF
49425: ST_TO_ADDR
49426: GO 49385
49428: POP
49429: POP
// end ;
49430: LD_VAR 0 4
49434: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49435: LD_INT 0
49437: PPUSH
49438: PPUSH
49439: PPUSH
// result := true ;
49440: LD_ADDR_VAR 0 3
49444: PUSH
49445: LD_INT 1
49447: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49448: LD_ADDR_VAR 0 5
49452: PUSH
49453: LD_VAR 0 2
49457: PPUSH
49458: CALL_OW 480
49462: ST_TO_ADDR
// if not tmp then
49463: LD_VAR 0 5
49467: NOT
49468: IFFALSE 49472
// exit ;
49470: GO 49521
// for i in tmp do
49472: LD_ADDR_VAR 0 4
49476: PUSH
49477: LD_VAR 0 5
49481: PUSH
49482: FOR_IN
49483: IFFALSE 49519
// if GetTech ( i , side ) <> state_researched then
49485: LD_VAR 0 4
49489: PPUSH
49490: LD_VAR 0 1
49494: PPUSH
49495: CALL_OW 321
49499: PUSH
49500: LD_INT 2
49502: NONEQUAL
49503: IFFALSE 49517
// begin result := false ;
49505: LD_ADDR_VAR 0 3
49509: PUSH
49510: LD_INT 0
49512: ST_TO_ADDR
// exit ;
49513: POP
49514: POP
49515: GO 49521
// end ;
49517: GO 49482
49519: POP
49520: POP
// end ;
49521: LD_VAR 0 3
49525: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49526: LD_INT 0
49528: PPUSH
49529: PPUSH
49530: PPUSH
49531: PPUSH
49532: PPUSH
49533: PPUSH
49534: PPUSH
49535: PPUSH
49536: PPUSH
49537: PPUSH
49538: PPUSH
49539: PPUSH
49540: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49541: LD_VAR 0 1
49545: NOT
49546: PUSH
49547: LD_VAR 0 1
49551: PPUSH
49552: CALL_OW 257
49556: PUSH
49557: LD_INT 9
49559: NONEQUAL
49560: OR
49561: IFFALSE 49565
// exit ;
49563: GO 50138
// side := GetSide ( unit ) ;
49565: LD_ADDR_VAR 0 9
49569: PUSH
49570: LD_VAR 0 1
49574: PPUSH
49575: CALL_OW 255
49579: ST_TO_ADDR
// tech_space := tech_spacanom ;
49580: LD_ADDR_VAR 0 12
49584: PUSH
49585: LD_INT 29
49587: ST_TO_ADDR
// tech_time := tech_taurad ;
49588: LD_ADDR_VAR 0 13
49592: PUSH
49593: LD_INT 28
49595: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49596: LD_ADDR_VAR 0 11
49600: PUSH
49601: LD_VAR 0 1
49605: PPUSH
49606: CALL_OW 310
49610: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49611: LD_VAR 0 11
49615: PPUSH
49616: CALL_OW 247
49620: PUSH
49621: LD_INT 2
49623: EQUAL
49624: IFFALSE 49628
// exit ;
49626: GO 50138
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49628: LD_ADDR_VAR 0 8
49632: PUSH
49633: LD_INT 81
49635: PUSH
49636: LD_VAR 0 9
49640: PUSH
49641: EMPTY
49642: LIST
49643: LIST
49644: PUSH
49645: LD_INT 3
49647: PUSH
49648: LD_INT 21
49650: PUSH
49651: LD_INT 3
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PPUSH
49666: CALL_OW 69
49670: ST_TO_ADDR
// if not tmp then
49671: LD_VAR 0 8
49675: NOT
49676: IFFALSE 49680
// exit ;
49678: GO 50138
// if in_unit then
49680: LD_VAR 0 11
49684: IFFALSE 49708
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49686: LD_ADDR_VAR 0 10
49690: PUSH
49691: LD_VAR 0 8
49695: PPUSH
49696: LD_VAR 0 11
49700: PPUSH
49701: CALL_OW 74
49705: ST_TO_ADDR
49706: GO 49728
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49708: LD_ADDR_VAR 0 10
49712: PUSH
49713: LD_VAR 0 8
49717: PPUSH
49718: LD_VAR 0 1
49722: PPUSH
49723: CALL_OW 74
49727: ST_TO_ADDR
// if not enemy then
49728: LD_VAR 0 10
49732: NOT
49733: IFFALSE 49737
// exit ;
49735: GO 50138
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49737: LD_VAR 0 11
49741: PUSH
49742: LD_VAR 0 11
49746: PPUSH
49747: LD_VAR 0 10
49751: PPUSH
49752: CALL_OW 296
49756: PUSH
49757: LD_INT 13
49759: GREATER
49760: AND
49761: PUSH
49762: LD_VAR 0 1
49766: PPUSH
49767: LD_VAR 0 10
49771: PPUSH
49772: CALL_OW 296
49776: PUSH
49777: LD_INT 12
49779: GREATER
49780: OR
49781: IFFALSE 49785
// exit ;
49783: GO 50138
// missile := [ 1 ] ;
49785: LD_ADDR_VAR 0 14
49789: PUSH
49790: LD_INT 1
49792: PUSH
49793: EMPTY
49794: LIST
49795: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49796: LD_VAR 0 9
49800: PPUSH
49801: LD_VAR 0 12
49805: PPUSH
49806: CALL_OW 325
49810: IFFALSE 49839
// missile := Replace ( missile , missile + 1 , 2 ) ;
49812: LD_ADDR_VAR 0 14
49816: PUSH
49817: LD_VAR 0 14
49821: PPUSH
49822: LD_VAR 0 14
49826: PUSH
49827: LD_INT 1
49829: PLUS
49830: PPUSH
49831: LD_INT 2
49833: PPUSH
49834: CALL_OW 1
49838: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49839: LD_VAR 0 9
49843: PPUSH
49844: LD_VAR 0 13
49848: PPUSH
49849: CALL_OW 325
49853: PUSH
49854: LD_VAR 0 10
49858: PPUSH
49859: CALL_OW 255
49863: PPUSH
49864: LD_VAR 0 13
49868: PPUSH
49869: CALL_OW 325
49873: NOT
49874: AND
49875: IFFALSE 49904
// missile := Replace ( missile , missile + 1 , 3 ) ;
49877: LD_ADDR_VAR 0 14
49881: PUSH
49882: LD_VAR 0 14
49886: PPUSH
49887: LD_VAR 0 14
49891: PUSH
49892: LD_INT 1
49894: PLUS
49895: PPUSH
49896: LD_INT 3
49898: PPUSH
49899: CALL_OW 1
49903: ST_TO_ADDR
// if missile < 2 then
49904: LD_VAR 0 14
49908: PUSH
49909: LD_INT 2
49911: LESS
49912: IFFALSE 49916
// exit ;
49914: GO 50138
// x := GetX ( enemy ) ;
49916: LD_ADDR_VAR 0 4
49920: PUSH
49921: LD_VAR 0 10
49925: PPUSH
49926: CALL_OW 250
49930: ST_TO_ADDR
// y := GetY ( enemy ) ;
49931: LD_ADDR_VAR 0 5
49935: PUSH
49936: LD_VAR 0 10
49940: PPUSH
49941: CALL_OW 251
49945: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49946: LD_ADDR_VAR 0 6
49950: PUSH
49951: LD_VAR 0 4
49955: PUSH
49956: LD_INT 1
49958: NEG
49959: PPUSH
49960: LD_INT 1
49962: PPUSH
49963: CALL_OW 12
49967: PLUS
49968: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49969: LD_ADDR_VAR 0 7
49973: PUSH
49974: LD_VAR 0 5
49978: PUSH
49979: LD_INT 1
49981: NEG
49982: PPUSH
49983: LD_INT 1
49985: PPUSH
49986: CALL_OW 12
49990: PLUS
49991: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49992: LD_VAR 0 6
49996: PPUSH
49997: LD_VAR 0 7
50001: PPUSH
50002: CALL_OW 488
50006: NOT
50007: IFFALSE 50029
// begin _x := x ;
50009: LD_ADDR_VAR 0 6
50013: PUSH
50014: LD_VAR 0 4
50018: ST_TO_ADDR
// _y := y ;
50019: LD_ADDR_VAR 0 7
50023: PUSH
50024: LD_VAR 0 5
50028: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50029: LD_ADDR_VAR 0 3
50033: PUSH
50034: LD_INT 1
50036: PPUSH
50037: LD_VAR 0 14
50041: PPUSH
50042: CALL_OW 12
50046: ST_TO_ADDR
// case i of 1 :
50047: LD_VAR 0 3
50051: PUSH
50052: LD_INT 1
50054: DOUBLE
50055: EQUAL
50056: IFTRUE 50060
50058: GO 50077
50060: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50061: LD_VAR 0 1
50065: PPUSH
50066: LD_VAR 0 10
50070: PPUSH
50071: CALL_OW 115
50075: GO 50138
50077: LD_INT 2
50079: DOUBLE
50080: EQUAL
50081: IFTRUE 50085
50083: GO 50107
50085: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50086: LD_VAR 0 1
50090: PPUSH
50091: LD_VAR 0 6
50095: PPUSH
50096: LD_VAR 0 7
50100: PPUSH
50101: CALL_OW 153
50105: GO 50138
50107: LD_INT 3
50109: DOUBLE
50110: EQUAL
50111: IFTRUE 50115
50113: GO 50137
50115: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50116: LD_VAR 0 1
50120: PPUSH
50121: LD_VAR 0 6
50125: PPUSH
50126: LD_VAR 0 7
50130: PPUSH
50131: CALL_OW 154
50135: GO 50138
50137: POP
// end ;
50138: LD_VAR 0 2
50142: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50143: LD_INT 0
50145: PPUSH
50146: PPUSH
50147: PPUSH
50148: PPUSH
50149: PPUSH
50150: PPUSH
// if not unit or not building then
50151: LD_VAR 0 1
50155: NOT
50156: PUSH
50157: LD_VAR 0 2
50161: NOT
50162: OR
50163: IFFALSE 50167
// exit ;
50165: GO 50325
// x := GetX ( building ) ;
50167: LD_ADDR_VAR 0 5
50171: PUSH
50172: LD_VAR 0 2
50176: PPUSH
50177: CALL_OW 250
50181: ST_TO_ADDR
// y := GetY ( building ) ;
50182: LD_ADDR_VAR 0 6
50186: PUSH
50187: LD_VAR 0 2
50191: PPUSH
50192: CALL_OW 251
50196: ST_TO_ADDR
// for i = 0 to 5 do
50197: LD_ADDR_VAR 0 4
50201: PUSH
50202: DOUBLE
50203: LD_INT 0
50205: DEC
50206: ST_TO_ADDR
50207: LD_INT 5
50209: PUSH
50210: FOR_TO
50211: IFFALSE 50323
// begin _x := ShiftX ( x , i , 3 ) ;
50213: LD_ADDR_VAR 0 7
50217: PUSH
50218: LD_VAR 0 5
50222: PPUSH
50223: LD_VAR 0 4
50227: PPUSH
50228: LD_INT 3
50230: PPUSH
50231: CALL_OW 272
50235: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50236: LD_ADDR_VAR 0 8
50240: PUSH
50241: LD_VAR 0 6
50245: PPUSH
50246: LD_VAR 0 4
50250: PPUSH
50251: LD_INT 3
50253: PPUSH
50254: CALL_OW 273
50258: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50259: LD_VAR 0 7
50263: PPUSH
50264: LD_VAR 0 8
50268: PPUSH
50269: CALL_OW 488
50273: NOT
50274: IFFALSE 50278
// continue ;
50276: GO 50210
// if HexInfo ( _x , _y ) = 0 then
50278: LD_VAR 0 7
50282: PPUSH
50283: LD_VAR 0 8
50287: PPUSH
50288: CALL_OW 428
50292: PUSH
50293: LD_INT 0
50295: EQUAL
50296: IFFALSE 50321
// begin ComMoveXY ( unit , _x , _y ) ;
50298: LD_VAR 0 1
50302: PPUSH
50303: LD_VAR 0 7
50307: PPUSH
50308: LD_VAR 0 8
50312: PPUSH
50313: CALL_OW 111
// exit ;
50317: POP
50318: POP
50319: GO 50325
// end ; end ;
50321: GO 50210
50323: POP
50324: POP
// end ;
50325: LD_VAR 0 3
50329: RET
// export function ScanBase ( side , base_area ) ; begin
50330: LD_INT 0
50332: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50333: LD_ADDR_VAR 0 3
50337: PUSH
50338: LD_VAR 0 2
50342: PPUSH
50343: LD_INT 81
50345: PUSH
50346: LD_VAR 0 1
50350: PUSH
50351: EMPTY
50352: LIST
50353: LIST
50354: PPUSH
50355: CALL_OW 70
50359: ST_TO_ADDR
// end ;
50360: LD_VAR 0 3
50364: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50365: LD_INT 0
50367: PPUSH
50368: PPUSH
50369: PPUSH
50370: PPUSH
// result := false ;
50371: LD_ADDR_VAR 0 2
50375: PUSH
50376: LD_INT 0
50378: ST_TO_ADDR
// side := GetSide ( unit ) ;
50379: LD_ADDR_VAR 0 3
50383: PUSH
50384: LD_VAR 0 1
50388: PPUSH
50389: CALL_OW 255
50393: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50394: LD_ADDR_VAR 0 4
50398: PUSH
50399: LD_VAR 0 1
50403: PPUSH
50404: CALL_OW 248
50408: ST_TO_ADDR
// case nat of 1 :
50409: LD_VAR 0 4
50413: PUSH
50414: LD_INT 1
50416: DOUBLE
50417: EQUAL
50418: IFTRUE 50422
50420: GO 50433
50422: POP
// tech := tech_lassight ; 2 :
50423: LD_ADDR_VAR 0 5
50427: PUSH
50428: LD_INT 12
50430: ST_TO_ADDR
50431: GO 50472
50433: LD_INT 2
50435: DOUBLE
50436: EQUAL
50437: IFTRUE 50441
50439: GO 50452
50441: POP
// tech := tech_mortar ; 3 :
50442: LD_ADDR_VAR 0 5
50446: PUSH
50447: LD_INT 41
50449: ST_TO_ADDR
50450: GO 50472
50452: LD_INT 3
50454: DOUBLE
50455: EQUAL
50456: IFTRUE 50460
50458: GO 50471
50460: POP
// tech := tech_bazooka ; end ;
50461: LD_ADDR_VAR 0 5
50465: PUSH
50466: LD_INT 44
50468: ST_TO_ADDR
50469: GO 50472
50471: POP
// if Researched ( side , tech ) then
50472: LD_VAR 0 3
50476: PPUSH
50477: LD_VAR 0 5
50481: PPUSH
50482: CALL_OW 325
50486: IFFALSE 50513
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50488: LD_ADDR_VAR 0 2
50492: PUSH
50493: LD_INT 5
50495: PUSH
50496: LD_INT 8
50498: PUSH
50499: LD_INT 9
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: LIST
50506: PUSH
50507: LD_VAR 0 4
50511: ARRAY
50512: ST_TO_ADDR
// end ;
50513: LD_VAR 0 2
50517: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50518: LD_INT 0
50520: PPUSH
50521: PPUSH
50522: PPUSH
// if not mines then
50523: LD_VAR 0 2
50527: NOT
50528: IFFALSE 50532
// exit ;
50530: GO 50676
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50532: LD_ADDR_VAR 0 5
50536: PUSH
50537: LD_INT 81
50539: PUSH
50540: LD_VAR 0 1
50544: PUSH
50545: EMPTY
50546: LIST
50547: LIST
50548: PUSH
50549: LD_INT 3
50551: PUSH
50552: LD_INT 21
50554: PUSH
50555: LD_INT 3
50557: PUSH
50558: EMPTY
50559: LIST
50560: LIST
50561: PUSH
50562: EMPTY
50563: LIST
50564: LIST
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: PPUSH
50570: CALL_OW 69
50574: ST_TO_ADDR
// for i in mines do
50575: LD_ADDR_VAR 0 4
50579: PUSH
50580: LD_VAR 0 2
50584: PUSH
50585: FOR_IN
50586: IFFALSE 50674
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50588: LD_VAR 0 4
50592: PUSH
50593: LD_INT 1
50595: ARRAY
50596: PPUSH
50597: LD_VAR 0 4
50601: PUSH
50602: LD_INT 2
50604: ARRAY
50605: PPUSH
50606: CALL_OW 458
50610: NOT
50611: IFFALSE 50615
// continue ;
50613: GO 50585
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50615: LD_VAR 0 4
50619: PUSH
50620: LD_INT 1
50622: ARRAY
50623: PPUSH
50624: LD_VAR 0 4
50628: PUSH
50629: LD_INT 2
50631: ARRAY
50632: PPUSH
50633: CALL_OW 428
50637: PUSH
50638: LD_VAR 0 5
50642: IN
50643: IFFALSE 50672
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50645: LD_VAR 0 4
50649: PUSH
50650: LD_INT 1
50652: ARRAY
50653: PPUSH
50654: LD_VAR 0 4
50658: PUSH
50659: LD_INT 2
50661: ARRAY
50662: PPUSH
50663: LD_VAR 0 1
50667: PPUSH
50668: CALL_OW 456
// end ;
50672: GO 50585
50674: POP
50675: POP
// end ;
50676: LD_VAR 0 3
50680: RET
// export function Count ( array ) ; var i ; begin
50681: LD_INT 0
50683: PPUSH
50684: PPUSH
// result := 0 ;
50685: LD_ADDR_VAR 0 2
50689: PUSH
50690: LD_INT 0
50692: ST_TO_ADDR
// for i in array do
50693: LD_ADDR_VAR 0 3
50697: PUSH
50698: LD_VAR 0 1
50702: PUSH
50703: FOR_IN
50704: IFFALSE 50728
// if i then
50706: LD_VAR 0 3
50710: IFFALSE 50726
// result := result + 1 ;
50712: LD_ADDR_VAR 0 2
50716: PUSH
50717: LD_VAR 0 2
50721: PUSH
50722: LD_INT 1
50724: PLUS
50725: ST_TO_ADDR
50726: GO 50703
50728: POP
50729: POP
// end ;
50730: LD_VAR 0 2
50734: RET
// export function IsEmpty ( building ) ; begin
50735: LD_INT 0
50737: PPUSH
// if not building then
50738: LD_VAR 0 1
50742: NOT
50743: IFFALSE 50747
// exit ;
50745: GO 50790
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50747: LD_ADDR_VAR 0 2
50751: PUSH
50752: LD_VAR 0 1
50756: PUSH
50757: LD_INT 22
50759: PUSH
50760: LD_VAR 0 1
50764: PPUSH
50765: CALL_OW 255
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 58
50776: PUSH
50777: EMPTY
50778: LIST
50779: PUSH
50780: EMPTY
50781: LIST
50782: LIST
50783: PPUSH
50784: CALL_OW 69
50788: IN
50789: ST_TO_ADDR
// end ;
50790: LD_VAR 0 2
50794: RET
// export function IsNotFull ( building ) ; var places ; begin
50795: LD_INT 0
50797: PPUSH
50798: PPUSH
// if not building then
50799: LD_VAR 0 1
50803: NOT
50804: IFFALSE 50808
// exit ;
50806: GO 50979
// result := false ;
50808: LD_ADDR_VAR 0 2
50812: PUSH
50813: LD_INT 0
50815: ST_TO_ADDR
// places := 0 ;
50816: LD_ADDR_VAR 0 3
50820: PUSH
50821: LD_INT 0
50823: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
50824: LD_VAR 0 1
50828: PPUSH
50829: CALL_OW 266
50833: PUSH
50834: LD_INT 0
50836: DOUBLE
50837: EQUAL
50838: IFTRUE 50896
50840: LD_INT 1
50842: DOUBLE
50843: EQUAL
50844: IFTRUE 50896
50846: LD_INT 6
50848: DOUBLE
50849: EQUAL
50850: IFTRUE 50896
50852: LD_INT 7
50854: DOUBLE
50855: EQUAL
50856: IFTRUE 50896
50858: LD_INT 8
50860: DOUBLE
50861: EQUAL
50862: IFTRUE 50896
50864: LD_INT 4
50866: DOUBLE
50867: EQUAL
50868: IFTRUE 50896
50870: LD_INT 5
50872: DOUBLE
50873: EQUAL
50874: IFTRUE 50896
50876: LD_INT 2
50878: DOUBLE
50879: EQUAL
50880: IFTRUE 50896
50882: LD_INT 3
50884: DOUBLE
50885: EQUAL
50886: IFTRUE 50896
50888: LD_INT 35
50890: DOUBLE
50891: EQUAL
50892: IFTRUE 50896
50894: GO 50907
50896: POP
// places := 6 ; b_bunker , b_breastwork :
50897: LD_ADDR_VAR 0 3
50901: PUSH
50902: LD_INT 6
50904: ST_TO_ADDR
50905: GO 50952
50907: LD_INT 32
50909: DOUBLE
50910: EQUAL
50911: IFTRUE 50921
50913: LD_INT 31
50915: DOUBLE
50916: EQUAL
50917: IFTRUE 50921
50919: GO 50932
50921: POP
// places := 1 ; b_control_tower :
50922: LD_ADDR_VAR 0 3
50926: PUSH
50927: LD_INT 1
50929: ST_TO_ADDR
50930: GO 50952
50932: LD_INT 36
50934: DOUBLE
50935: EQUAL
50936: IFTRUE 50940
50938: GO 50951
50940: POP
// places := 3 ; end ;
50941: LD_ADDR_VAR 0 3
50945: PUSH
50946: LD_INT 3
50948: ST_TO_ADDR
50949: GO 50952
50951: POP
// if places then
50952: LD_VAR 0 3
50956: IFFALSE 50979
// result := UnitsInside ( building ) < places ;
50958: LD_ADDR_VAR 0 2
50962: PUSH
50963: LD_VAR 0 1
50967: PPUSH
50968: CALL_OW 313
50972: PUSH
50973: LD_VAR 0 3
50977: LESS
50978: ST_TO_ADDR
// end ;
50979: LD_VAR 0 2
50983: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50984: LD_INT 0
50986: PPUSH
50987: PPUSH
50988: PPUSH
50989: PPUSH
// tmp := [ ] ;
50990: LD_ADDR_VAR 0 3
50994: PUSH
50995: EMPTY
50996: ST_TO_ADDR
// list := [ ] ;
50997: LD_ADDR_VAR 0 5
51001: PUSH
51002: EMPTY
51003: ST_TO_ADDR
// for i = 16 to 25 do
51004: LD_ADDR_VAR 0 4
51008: PUSH
51009: DOUBLE
51010: LD_INT 16
51012: DEC
51013: ST_TO_ADDR
51014: LD_INT 25
51016: PUSH
51017: FOR_TO
51018: IFFALSE 51091
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51020: LD_ADDR_VAR 0 3
51024: PUSH
51025: LD_VAR 0 3
51029: PUSH
51030: LD_INT 22
51032: PUSH
51033: LD_VAR 0 1
51037: PPUSH
51038: CALL_OW 255
51042: PUSH
51043: EMPTY
51044: LIST
51045: LIST
51046: PUSH
51047: LD_INT 91
51049: PUSH
51050: LD_VAR 0 1
51054: PUSH
51055: LD_INT 6
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: LIST
51062: PUSH
51063: LD_INT 30
51065: PUSH
51066: LD_VAR 0 4
51070: PUSH
51071: EMPTY
51072: LIST
51073: LIST
51074: PUSH
51075: EMPTY
51076: LIST
51077: LIST
51078: LIST
51079: PUSH
51080: EMPTY
51081: LIST
51082: PPUSH
51083: CALL_OW 69
51087: ADD
51088: ST_TO_ADDR
51089: GO 51017
51091: POP
51092: POP
// for i = 1 to tmp do
51093: LD_ADDR_VAR 0 4
51097: PUSH
51098: DOUBLE
51099: LD_INT 1
51101: DEC
51102: ST_TO_ADDR
51103: LD_VAR 0 3
51107: PUSH
51108: FOR_TO
51109: IFFALSE 51197
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51111: LD_ADDR_VAR 0 5
51115: PUSH
51116: LD_VAR 0 5
51120: PUSH
51121: LD_VAR 0 3
51125: PUSH
51126: LD_VAR 0 4
51130: ARRAY
51131: PPUSH
51132: CALL_OW 266
51136: PUSH
51137: LD_VAR 0 3
51141: PUSH
51142: LD_VAR 0 4
51146: ARRAY
51147: PPUSH
51148: CALL_OW 250
51152: PUSH
51153: LD_VAR 0 3
51157: PUSH
51158: LD_VAR 0 4
51162: ARRAY
51163: PPUSH
51164: CALL_OW 251
51168: PUSH
51169: LD_VAR 0 3
51173: PUSH
51174: LD_VAR 0 4
51178: ARRAY
51179: PPUSH
51180: CALL_OW 254
51184: PUSH
51185: EMPTY
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: PUSH
51191: EMPTY
51192: LIST
51193: ADD
51194: ST_TO_ADDR
51195: GO 51108
51197: POP
51198: POP
// result := list ;
51199: LD_ADDR_VAR 0 2
51203: PUSH
51204: LD_VAR 0 5
51208: ST_TO_ADDR
// end ;
51209: LD_VAR 0 2
51213: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51214: LD_INT 0
51216: PPUSH
51217: PPUSH
51218: PPUSH
51219: PPUSH
51220: PPUSH
51221: PPUSH
51222: PPUSH
// if not factory then
51223: LD_VAR 0 1
51227: NOT
51228: IFFALSE 51232
// exit ;
51230: GO 51825
// if control = control_apeman then
51232: LD_VAR 0 4
51236: PUSH
51237: LD_INT 5
51239: EQUAL
51240: IFFALSE 51349
// begin tmp := UnitsInside ( factory ) ;
51242: LD_ADDR_VAR 0 8
51246: PUSH
51247: LD_VAR 0 1
51251: PPUSH
51252: CALL_OW 313
51256: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51257: LD_VAR 0 8
51261: PPUSH
51262: LD_INT 25
51264: PUSH
51265: LD_INT 12
51267: PUSH
51268: EMPTY
51269: LIST
51270: LIST
51271: PPUSH
51272: CALL_OW 72
51276: NOT
51277: IFFALSE 51287
// control := control_manual ;
51279: LD_ADDR_VAR 0 4
51283: PUSH
51284: LD_INT 1
51286: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51287: LD_ADDR_VAR 0 8
51291: PUSH
51292: LD_VAR 0 1
51296: PPUSH
51297: CALL 50984 0 1
51301: ST_TO_ADDR
// if tmp then
51302: LD_VAR 0 8
51306: IFFALSE 51349
// begin for i in tmp do
51308: LD_ADDR_VAR 0 7
51312: PUSH
51313: LD_VAR 0 8
51317: PUSH
51318: FOR_IN
51319: IFFALSE 51347
// if i [ 1 ] = b_ext_radio then
51321: LD_VAR 0 7
51325: PUSH
51326: LD_INT 1
51328: ARRAY
51329: PUSH
51330: LD_INT 22
51332: EQUAL
51333: IFFALSE 51345
// begin control := control_remote ;
51335: LD_ADDR_VAR 0 4
51339: PUSH
51340: LD_INT 2
51342: ST_TO_ADDR
// break ;
51343: GO 51347
// end ;
51345: GO 51318
51347: POP
51348: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51349: LD_VAR 0 1
51353: PPUSH
51354: LD_VAR 0 2
51358: PPUSH
51359: LD_VAR 0 3
51363: PPUSH
51364: LD_VAR 0 4
51368: PPUSH
51369: LD_VAR 0 5
51373: PPUSH
51374: CALL_OW 448
51378: IFFALSE 51413
// begin result := [ chassis , engine , control , weapon ] ;
51380: LD_ADDR_VAR 0 6
51384: PUSH
51385: LD_VAR 0 2
51389: PUSH
51390: LD_VAR 0 3
51394: PUSH
51395: LD_VAR 0 4
51399: PUSH
51400: LD_VAR 0 5
51404: PUSH
51405: EMPTY
51406: LIST
51407: LIST
51408: LIST
51409: LIST
51410: ST_TO_ADDR
// exit ;
51411: GO 51825
// end ; _chassis := AvailableChassisList ( factory ) ;
51413: LD_ADDR_VAR 0 9
51417: PUSH
51418: LD_VAR 0 1
51422: PPUSH
51423: CALL_OW 475
51427: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51428: LD_ADDR_VAR 0 11
51432: PUSH
51433: LD_VAR 0 1
51437: PPUSH
51438: CALL_OW 476
51442: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51443: LD_ADDR_VAR 0 12
51447: PUSH
51448: LD_VAR 0 1
51452: PPUSH
51453: CALL_OW 477
51457: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51458: LD_ADDR_VAR 0 10
51462: PUSH
51463: LD_VAR 0 1
51467: PPUSH
51468: CALL_OW 478
51472: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51473: LD_VAR 0 9
51477: NOT
51478: PUSH
51479: LD_VAR 0 11
51483: NOT
51484: OR
51485: PUSH
51486: LD_VAR 0 12
51490: NOT
51491: OR
51492: PUSH
51493: LD_VAR 0 10
51497: NOT
51498: OR
51499: IFFALSE 51534
// begin result := [ chassis , engine , control , weapon ] ;
51501: LD_ADDR_VAR 0 6
51505: PUSH
51506: LD_VAR 0 2
51510: PUSH
51511: LD_VAR 0 3
51515: PUSH
51516: LD_VAR 0 4
51520: PUSH
51521: LD_VAR 0 5
51525: PUSH
51526: EMPTY
51527: LIST
51528: LIST
51529: LIST
51530: LIST
51531: ST_TO_ADDR
// exit ;
51532: GO 51825
// end ; if not chassis in _chassis then
51534: LD_VAR 0 2
51538: PUSH
51539: LD_VAR 0 9
51543: IN
51544: NOT
51545: IFFALSE 51571
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51547: LD_ADDR_VAR 0 2
51551: PUSH
51552: LD_VAR 0 9
51556: PUSH
51557: LD_INT 1
51559: PPUSH
51560: LD_VAR 0 9
51564: PPUSH
51565: CALL_OW 12
51569: ARRAY
51570: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51571: LD_VAR 0 2
51575: PPUSH
51576: LD_VAR 0 3
51580: PPUSH
51581: CALL 51830 0 2
51585: NOT
51586: IFFALSE 51645
// repeat engine := _engine [ 1 ] ;
51588: LD_ADDR_VAR 0 3
51592: PUSH
51593: LD_VAR 0 11
51597: PUSH
51598: LD_INT 1
51600: ARRAY
51601: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51602: LD_ADDR_VAR 0 11
51606: PUSH
51607: LD_VAR 0 11
51611: PPUSH
51612: LD_INT 1
51614: PPUSH
51615: CALL_OW 3
51619: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51620: LD_VAR 0 2
51624: PPUSH
51625: LD_VAR 0 3
51629: PPUSH
51630: CALL 51830 0 2
51634: PUSH
51635: LD_VAR 0 11
51639: PUSH
51640: EMPTY
51641: EQUAL
51642: OR
51643: IFFALSE 51588
// if not control in _control then
51645: LD_VAR 0 4
51649: PUSH
51650: LD_VAR 0 12
51654: IN
51655: NOT
51656: IFFALSE 51682
// control := _control [ rand ( 1 , _control ) ] ;
51658: LD_ADDR_VAR 0 4
51662: PUSH
51663: LD_VAR 0 12
51667: PUSH
51668: LD_INT 1
51670: PPUSH
51671: LD_VAR 0 12
51675: PPUSH
51676: CALL_OW 12
51680: ARRAY
51681: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51682: LD_VAR 0 2
51686: PPUSH
51687: LD_VAR 0 5
51691: PPUSH
51692: CALL 52050 0 2
51696: NOT
51697: IFFALSE 51756
// repeat weapon := _weapon [ 1 ] ;
51699: LD_ADDR_VAR 0 5
51703: PUSH
51704: LD_VAR 0 10
51708: PUSH
51709: LD_INT 1
51711: ARRAY
51712: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51713: LD_ADDR_VAR 0 10
51717: PUSH
51718: LD_VAR 0 10
51722: PPUSH
51723: LD_INT 1
51725: PPUSH
51726: CALL_OW 3
51730: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51731: LD_VAR 0 2
51735: PPUSH
51736: LD_VAR 0 5
51740: PPUSH
51741: CALL 52050 0 2
51745: PUSH
51746: LD_VAR 0 10
51750: PUSH
51751: EMPTY
51752: EQUAL
51753: OR
51754: IFFALSE 51699
// result := [ ] ;
51756: LD_ADDR_VAR 0 6
51760: PUSH
51761: EMPTY
51762: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51763: LD_VAR 0 1
51767: PPUSH
51768: LD_VAR 0 2
51772: PPUSH
51773: LD_VAR 0 3
51777: PPUSH
51778: LD_VAR 0 4
51782: PPUSH
51783: LD_VAR 0 5
51787: PPUSH
51788: CALL_OW 448
51792: IFFALSE 51825
// result := [ chassis , engine , control , weapon ] ;
51794: LD_ADDR_VAR 0 6
51798: PUSH
51799: LD_VAR 0 2
51803: PUSH
51804: LD_VAR 0 3
51808: PUSH
51809: LD_VAR 0 4
51813: PUSH
51814: LD_VAR 0 5
51818: PUSH
51819: EMPTY
51820: LIST
51821: LIST
51822: LIST
51823: LIST
51824: ST_TO_ADDR
// end ;
51825: LD_VAR 0 6
51829: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51830: LD_INT 0
51832: PPUSH
// if not chassis or not engine then
51833: LD_VAR 0 1
51837: NOT
51838: PUSH
51839: LD_VAR 0 2
51843: NOT
51844: OR
51845: IFFALSE 51849
// exit ;
51847: GO 52045
// case engine of engine_solar :
51849: LD_VAR 0 2
51853: PUSH
51854: LD_INT 2
51856: DOUBLE
51857: EQUAL
51858: IFTRUE 51862
51860: GO 51900
51862: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51863: LD_ADDR_VAR 0 3
51867: PUSH
51868: LD_INT 11
51870: PUSH
51871: LD_INT 12
51873: PUSH
51874: LD_INT 13
51876: PUSH
51877: LD_INT 14
51879: PUSH
51880: LD_INT 1
51882: PUSH
51883: LD_INT 2
51885: PUSH
51886: LD_INT 3
51888: PUSH
51889: EMPTY
51890: LIST
51891: LIST
51892: LIST
51893: LIST
51894: LIST
51895: LIST
51896: LIST
51897: ST_TO_ADDR
51898: GO 52029
51900: LD_INT 1
51902: DOUBLE
51903: EQUAL
51904: IFTRUE 51908
51906: GO 51970
51908: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51909: LD_ADDR_VAR 0 3
51913: PUSH
51914: LD_INT 11
51916: PUSH
51917: LD_INT 12
51919: PUSH
51920: LD_INT 13
51922: PUSH
51923: LD_INT 14
51925: PUSH
51926: LD_INT 1
51928: PUSH
51929: LD_INT 2
51931: PUSH
51932: LD_INT 3
51934: PUSH
51935: LD_INT 4
51937: PUSH
51938: LD_INT 5
51940: PUSH
51941: LD_INT 21
51943: PUSH
51944: LD_INT 23
51946: PUSH
51947: LD_INT 22
51949: PUSH
51950: LD_INT 24
51952: PUSH
51953: EMPTY
51954: LIST
51955: LIST
51956: LIST
51957: LIST
51958: LIST
51959: LIST
51960: LIST
51961: LIST
51962: LIST
51963: LIST
51964: LIST
51965: LIST
51966: LIST
51967: ST_TO_ADDR
51968: GO 52029
51970: LD_INT 3
51972: DOUBLE
51973: EQUAL
51974: IFTRUE 51978
51976: GO 52028
51978: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51979: LD_ADDR_VAR 0 3
51983: PUSH
51984: LD_INT 13
51986: PUSH
51987: LD_INT 14
51989: PUSH
51990: LD_INT 2
51992: PUSH
51993: LD_INT 3
51995: PUSH
51996: LD_INT 4
51998: PUSH
51999: LD_INT 5
52001: PUSH
52002: LD_INT 21
52004: PUSH
52005: LD_INT 22
52007: PUSH
52008: LD_INT 23
52010: PUSH
52011: LD_INT 24
52013: PUSH
52014: EMPTY
52015: LIST
52016: LIST
52017: LIST
52018: LIST
52019: LIST
52020: LIST
52021: LIST
52022: LIST
52023: LIST
52024: LIST
52025: ST_TO_ADDR
52026: GO 52029
52028: POP
// result := ( chassis in result ) ;
52029: LD_ADDR_VAR 0 3
52033: PUSH
52034: LD_VAR 0 1
52038: PUSH
52039: LD_VAR 0 3
52043: IN
52044: ST_TO_ADDR
// end ;
52045: LD_VAR 0 3
52049: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52050: LD_INT 0
52052: PPUSH
// if not chassis or not weapon then
52053: LD_VAR 0 1
52057: NOT
52058: PUSH
52059: LD_VAR 0 2
52063: NOT
52064: OR
52065: IFFALSE 52069
// exit ;
52067: GO 53131
// case weapon of us_machine_gun :
52069: LD_VAR 0 2
52073: PUSH
52074: LD_INT 2
52076: DOUBLE
52077: EQUAL
52078: IFTRUE 52082
52080: GO 52112
52082: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52083: LD_ADDR_VAR 0 3
52087: PUSH
52088: LD_INT 1
52090: PUSH
52091: LD_INT 2
52093: PUSH
52094: LD_INT 3
52096: PUSH
52097: LD_INT 4
52099: PUSH
52100: LD_INT 5
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: ST_TO_ADDR
52110: GO 53115
52112: LD_INT 3
52114: DOUBLE
52115: EQUAL
52116: IFTRUE 52120
52118: GO 52150
52120: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52121: LD_ADDR_VAR 0 3
52125: PUSH
52126: LD_INT 1
52128: PUSH
52129: LD_INT 2
52131: PUSH
52132: LD_INT 3
52134: PUSH
52135: LD_INT 4
52137: PUSH
52138: LD_INT 5
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: LIST
52145: LIST
52146: LIST
52147: ST_TO_ADDR
52148: GO 53115
52150: LD_INT 11
52152: DOUBLE
52153: EQUAL
52154: IFTRUE 52158
52156: GO 52188
52158: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52159: LD_ADDR_VAR 0 3
52163: PUSH
52164: LD_INT 1
52166: PUSH
52167: LD_INT 2
52169: PUSH
52170: LD_INT 3
52172: PUSH
52173: LD_INT 4
52175: PUSH
52176: LD_INT 5
52178: PUSH
52179: EMPTY
52180: LIST
52181: LIST
52182: LIST
52183: LIST
52184: LIST
52185: ST_TO_ADDR
52186: GO 53115
52188: LD_INT 4
52190: DOUBLE
52191: EQUAL
52192: IFTRUE 52196
52194: GO 52222
52196: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52197: LD_ADDR_VAR 0 3
52201: PUSH
52202: LD_INT 2
52204: PUSH
52205: LD_INT 3
52207: PUSH
52208: LD_INT 4
52210: PUSH
52211: LD_INT 5
52213: PUSH
52214: EMPTY
52215: LIST
52216: LIST
52217: LIST
52218: LIST
52219: ST_TO_ADDR
52220: GO 53115
52222: LD_INT 5
52224: DOUBLE
52225: EQUAL
52226: IFTRUE 52230
52228: GO 52256
52230: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52231: LD_ADDR_VAR 0 3
52235: PUSH
52236: LD_INT 2
52238: PUSH
52239: LD_INT 3
52241: PUSH
52242: LD_INT 4
52244: PUSH
52245: LD_INT 5
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: ST_TO_ADDR
52254: GO 53115
52256: LD_INT 9
52258: DOUBLE
52259: EQUAL
52260: IFTRUE 52264
52262: GO 52290
52264: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52265: LD_ADDR_VAR 0 3
52269: PUSH
52270: LD_INT 2
52272: PUSH
52273: LD_INT 3
52275: PUSH
52276: LD_INT 4
52278: PUSH
52279: LD_INT 5
52281: PUSH
52282: EMPTY
52283: LIST
52284: LIST
52285: LIST
52286: LIST
52287: ST_TO_ADDR
52288: GO 53115
52290: LD_INT 7
52292: DOUBLE
52293: EQUAL
52294: IFTRUE 52298
52296: GO 52324
52298: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52299: LD_ADDR_VAR 0 3
52303: PUSH
52304: LD_INT 2
52306: PUSH
52307: LD_INT 3
52309: PUSH
52310: LD_INT 4
52312: PUSH
52313: LD_INT 5
52315: PUSH
52316: EMPTY
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: ST_TO_ADDR
52322: GO 53115
52324: LD_INT 12
52326: DOUBLE
52327: EQUAL
52328: IFTRUE 52332
52330: GO 52358
52332: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52333: LD_ADDR_VAR 0 3
52337: PUSH
52338: LD_INT 2
52340: PUSH
52341: LD_INT 3
52343: PUSH
52344: LD_INT 4
52346: PUSH
52347: LD_INT 5
52349: PUSH
52350: EMPTY
52351: LIST
52352: LIST
52353: LIST
52354: LIST
52355: ST_TO_ADDR
52356: GO 53115
52358: LD_INT 13
52360: DOUBLE
52361: EQUAL
52362: IFTRUE 52366
52364: GO 52392
52366: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52367: LD_ADDR_VAR 0 3
52371: PUSH
52372: LD_INT 2
52374: PUSH
52375: LD_INT 3
52377: PUSH
52378: LD_INT 4
52380: PUSH
52381: LD_INT 5
52383: PUSH
52384: EMPTY
52385: LIST
52386: LIST
52387: LIST
52388: LIST
52389: ST_TO_ADDR
52390: GO 53115
52392: LD_INT 14
52394: DOUBLE
52395: EQUAL
52396: IFTRUE 52400
52398: GO 52418
52400: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52401: LD_ADDR_VAR 0 3
52405: PUSH
52406: LD_INT 4
52408: PUSH
52409: LD_INT 5
52411: PUSH
52412: EMPTY
52413: LIST
52414: LIST
52415: ST_TO_ADDR
52416: GO 53115
52418: LD_INT 6
52420: DOUBLE
52421: EQUAL
52422: IFTRUE 52426
52424: GO 52444
52426: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52427: LD_ADDR_VAR 0 3
52431: PUSH
52432: LD_INT 4
52434: PUSH
52435: LD_INT 5
52437: PUSH
52438: EMPTY
52439: LIST
52440: LIST
52441: ST_TO_ADDR
52442: GO 53115
52444: LD_INT 10
52446: DOUBLE
52447: EQUAL
52448: IFTRUE 52452
52450: GO 52470
52452: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52453: LD_ADDR_VAR 0 3
52457: PUSH
52458: LD_INT 4
52460: PUSH
52461: LD_INT 5
52463: PUSH
52464: EMPTY
52465: LIST
52466: LIST
52467: ST_TO_ADDR
52468: GO 53115
52470: LD_INT 22
52472: DOUBLE
52473: EQUAL
52474: IFTRUE 52478
52476: GO 52504
52478: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52479: LD_ADDR_VAR 0 3
52483: PUSH
52484: LD_INT 11
52486: PUSH
52487: LD_INT 12
52489: PUSH
52490: LD_INT 13
52492: PUSH
52493: LD_INT 14
52495: PUSH
52496: EMPTY
52497: LIST
52498: LIST
52499: LIST
52500: LIST
52501: ST_TO_ADDR
52502: GO 53115
52504: LD_INT 23
52506: DOUBLE
52507: EQUAL
52508: IFTRUE 52512
52510: GO 52538
52512: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52513: LD_ADDR_VAR 0 3
52517: PUSH
52518: LD_INT 11
52520: PUSH
52521: LD_INT 12
52523: PUSH
52524: LD_INT 13
52526: PUSH
52527: LD_INT 14
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: ST_TO_ADDR
52536: GO 53115
52538: LD_INT 24
52540: DOUBLE
52541: EQUAL
52542: IFTRUE 52546
52544: GO 52572
52546: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52547: LD_ADDR_VAR 0 3
52551: PUSH
52552: LD_INT 11
52554: PUSH
52555: LD_INT 12
52557: PUSH
52558: LD_INT 13
52560: PUSH
52561: LD_INT 14
52563: PUSH
52564: EMPTY
52565: LIST
52566: LIST
52567: LIST
52568: LIST
52569: ST_TO_ADDR
52570: GO 53115
52572: LD_INT 30
52574: DOUBLE
52575: EQUAL
52576: IFTRUE 52580
52578: GO 52606
52580: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52581: LD_ADDR_VAR 0 3
52585: PUSH
52586: LD_INT 11
52588: PUSH
52589: LD_INT 12
52591: PUSH
52592: LD_INT 13
52594: PUSH
52595: LD_INT 14
52597: PUSH
52598: EMPTY
52599: LIST
52600: LIST
52601: LIST
52602: LIST
52603: ST_TO_ADDR
52604: GO 53115
52606: LD_INT 25
52608: DOUBLE
52609: EQUAL
52610: IFTRUE 52614
52612: GO 52632
52614: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52615: LD_ADDR_VAR 0 3
52619: PUSH
52620: LD_INT 13
52622: PUSH
52623: LD_INT 14
52625: PUSH
52626: EMPTY
52627: LIST
52628: LIST
52629: ST_TO_ADDR
52630: GO 53115
52632: LD_INT 27
52634: DOUBLE
52635: EQUAL
52636: IFTRUE 52640
52638: GO 52658
52640: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52641: LD_ADDR_VAR 0 3
52645: PUSH
52646: LD_INT 13
52648: PUSH
52649: LD_INT 14
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: ST_TO_ADDR
52656: GO 53115
52658: LD_EXP 99
52662: DOUBLE
52663: EQUAL
52664: IFTRUE 52668
52666: GO 52694
52668: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52669: LD_ADDR_VAR 0 3
52673: PUSH
52674: LD_INT 11
52676: PUSH
52677: LD_INT 12
52679: PUSH
52680: LD_INT 13
52682: PUSH
52683: LD_INT 14
52685: PUSH
52686: EMPTY
52687: LIST
52688: LIST
52689: LIST
52690: LIST
52691: ST_TO_ADDR
52692: GO 53115
52694: LD_INT 28
52696: DOUBLE
52697: EQUAL
52698: IFTRUE 52702
52700: GO 52720
52702: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52703: LD_ADDR_VAR 0 3
52707: PUSH
52708: LD_INT 13
52710: PUSH
52711: LD_INT 14
52713: PUSH
52714: EMPTY
52715: LIST
52716: LIST
52717: ST_TO_ADDR
52718: GO 53115
52720: LD_INT 29
52722: DOUBLE
52723: EQUAL
52724: IFTRUE 52728
52726: GO 52746
52728: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52729: LD_ADDR_VAR 0 3
52733: PUSH
52734: LD_INT 13
52736: PUSH
52737: LD_INT 14
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: ST_TO_ADDR
52744: GO 53115
52746: LD_INT 31
52748: DOUBLE
52749: EQUAL
52750: IFTRUE 52754
52752: GO 52772
52754: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52755: LD_ADDR_VAR 0 3
52759: PUSH
52760: LD_INT 13
52762: PUSH
52763: LD_INT 14
52765: PUSH
52766: EMPTY
52767: LIST
52768: LIST
52769: ST_TO_ADDR
52770: GO 53115
52772: LD_INT 26
52774: DOUBLE
52775: EQUAL
52776: IFTRUE 52780
52778: GO 52798
52780: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52781: LD_ADDR_VAR 0 3
52785: PUSH
52786: LD_INT 13
52788: PUSH
52789: LD_INT 14
52791: PUSH
52792: EMPTY
52793: LIST
52794: LIST
52795: ST_TO_ADDR
52796: GO 53115
52798: LD_INT 42
52800: DOUBLE
52801: EQUAL
52802: IFTRUE 52806
52804: GO 52832
52806: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52807: LD_ADDR_VAR 0 3
52811: PUSH
52812: LD_INT 21
52814: PUSH
52815: LD_INT 22
52817: PUSH
52818: LD_INT 23
52820: PUSH
52821: LD_INT 24
52823: PUSH
52824: EMPTY
52825: LIST
52826: LIST
52827: LIST
52828: LIST
52829: ST_TO_ADDR
52830: GO 53115
52832: LD_INT 43
52834: DOUBLE
52835: EQUAL
52836: IFTRUE 52840
52838: GO 52866
52840: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52841: LD_ADDR_VAR 0 3
52845: PUSH
52846: LD_INT 21
52848: PUSH
52849: LD_INT 22
52851: PUSH
52852: LD_INT 23
52854: PUSH
52855: LD_INT 24
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: LIST
52862: LIST
52863: ST_TO_ADDR
52864: GO 53115
52866: LD_INT 44
52868: DOUBLE
52869: EQUAL
52870: IFTRUE 52874
52872: GO 52900
52874: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52875: LD_ADDR_VAR 0 3
52879: PUSH
52880: LD_INT 21
52882: PUSH
52883: LD_INT 22
52885: PUSH
52886: LD_INT 23
52888: PUSH
52889: LD_INT 24
52891: PUSH
52892: EMPTY
52893: LIST
52894: LIST
52895: LIST
52896: LIST
52897: ST_TO_ADDR
52898: GO 53115
52900: LD_INT 45
52902: DOUBLE
52903: EQUAL
52904: IFTRUE 52908
52906: GO 52934
52908: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52909: LD_ADDR_VAR 0 3
52913: PUSH
52914: LD_INT 21
52916: PUSH
52917: LD_INT 22
52919: PUSH
52920: LD_INT 23
52922: PUSH
52923: LD_INT 24
52925: PUSH
52926: EMPTY
52927: LIST
52928: LIST
52929: LIST
52930: LIST
52931: ST_TO_ADDR
52932: GO 53115
52934: LD_INT 49
52936: DOUBLE
52937: EQUAL
52938: IFTRUE 52942
52940: GO 52968
52942: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52943: LD_ADDR_VAR 0 3
52947: PUSH
52948: LD_INT 21
52950: PUSH
52951: LD_INT 22
52953: PUSH
52954: LD_INT 23
52956: PUSH
52957: LD_INT 24
52959: PUSH
52960: EMPTY
52961: LIST
52962: LIST
52963: LIST
52964: LIST
52965: ST_TO_ADDR
52966: GO 53115
52968: LD_INT 51
52970: DOUBLE
52971: EQUAL
52972: IFTRUE 52976
52974: GO 53002
52976: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52977: LD_ADDR_VAR 0 3
52981: PUSH
52982: LD_INT 21
52984: PUSH
52985: LD_INT 22
52987: PUSH
52988: LD_INT 23
52990: PUSH
52991: LD_INT 24
52993: PUSH
52994: EMPTY
52995: LIST
52996: LIST
52997: LIST
52998: LIST
52999: ST_TO_ADDR
53000: GO 53115
53002: LD_INT 52
53004: DOUBLE
53005: EQUAL
53006: IFTRUE 53010
53008: GO 53036
53010: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53011: LD_ADDR_VAR 0 3
53015: PUSH
53016: LD_INT 21
53018: PUSH
53019: LD_INT 22
53021: PUSH
53022: LD_INT 23
53024: PUSH
53025: LD_INT 24
53027: PUSH
53028: EMPTY
53029: LIST
53030: LIST
53031: LIST
53032: LIST
53033: ST_TO_ADDR
53034: GO 53115
53036: LD_INT 53
53038: DOUBLE
53039: EQUAL
53040: IFTRUE 53044
53042: GO 53062
53044: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53045: LD_ADDR_VAR 0 3
53049: PUSH
53050: LD_INT 23
53052: PUSH
53053: LD_INT 24
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: ST_TO_ADDR
53060: GO 53115
53062: LD_INT 46
53064: DOUBLE
53065: EQUAL
53066: IFTRUE 53070
53068: GO 53088
53070: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53071: LD_ADDR_VAR 0 3
53075: PUSH
53076: LD_INT 23
53078: PUSH
53079: LD_INT 24
53081: PUSH
53082: EMPTY
53083: LIST
53084: LIST
53085: ST_TO_ADDR
53086: GO 53115
53088: LD_INT 47
53090: DOUBLE
53091: EQUAL
53092: IFTRUE 53096
53094: GO 53114
53096: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53097: LD_ADDR_VAR 0 3
53101: PUSH
53102: LD_INT 23
53104: PUSH
53105: LD_INT 24
53107: PUSH
53108: EMPTY
53109: LIST
53110: LIST
53111: ST_TO_ADDR
53112: GO 53115
53114: POP
// result := ( chassis in result ) ;
53115: LD_ADDR_VAR 0 3
53119: PUSH
53120: LD_VAR 0 1
53124: PUSH
53125: LD_VAR 0 3
53129: IN
53130: ST_TO_ADDR
// end ;
53131: LD_VAR 0 3
53135: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53136: LD_INT 0
53138: PPUSH
53139: PPUSH
53140: PPUSH
53141: PPUSH
53142: PPUSH
53143: PPUSH
53144: PPUSH
// result := array ;
53145: LD_ADDR_VAR 0 5
53149: PUSH
53150: LD_VAR 0 1
53154: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53155: LD_VAR 0 1
53159: NOT
53160: PUSH
53161: LD_VAR 0 2
53165: NOT
53166: OR
53167: PUSH
53168: LD_VAR 0 3
53172: NOT
53173: OR
53174: PUSH
53175: LD_VAR 0 2
53179: PUSH
53180: LD_VAR 0 1
53184: GREATER
53185: OR
53186: PUSH
53187: LD_VAR 0 3
53191: PUSH
53192: LD_VAR 0 1
53196: GREATER
53197: OR
53198: IFFALSE 53202
// exit ;
53200: GO 53498
// if direction then
53202: LD_VAR 0 4
53206: IFFALSE 53270
// begin d := 1 ;
53208: LD_ADDR_VAR 0 9
53212: PUSH
53213: LD_INT 1
53215: ST_TO_ADDR
// if i_from > i_to then
53216: LD_VAR 0 2
53220: PUSH
53221: LD_VAR 0 3
53225: GREATER
53226: IFFALSE 53252
// length := ( array - i_from ) + i_to else
53228: LD_ADDR_VAR 0 11
53232: PUSH
53233: LD_VAR 0 1
53237: PUSH
53238: LD_VAR 0 2
53242: MINUS
53243: PUSH
53244: LD_VAR 0 3
53248: PLUS
53249: ST_TO_ADDR
53250: GO 53268
// length := i_to - i_from ;
53252: LD_ADDR_VAR 0 11
53256: PUSH
53257: LD_VAR 0 3
53261: PUSH
53262: LD_VAR 0 2
53266: MINUS
53267: ST_TO_ADDR
// end else
53268: GO 53331
// begin d := - 1 ;
53270: LD_ADDR_VAR 0 9
53274: PUSH
53275: LD_INT 1
53277: NEG
53278: ST_TO_ADDR
// if i_from > i_to then
53279: LD_VAR 0 2
53283: PUSH
53284: LD_VAR 0 3
53288: GREATER
53289: IFFALSE 53309
// length := i_from - i_to else
53291: LD_ADDR_VAR 0 11
53295: PUSH
53296: LD_VAR 0 2
53300: PUSH
53301: LD_VAR 0 3
53305: MINUS
53306: ST_TO_ADDR
53307: GO 53331
// length := ( array - i_to ) + i_from ;
53309: LD_ADDR_VAR 0 11
53313: PUSH
53314: LD_VAR 0 1
53318: PUSH
53319: LD_VAR 0 3
53323: MINUS
53324: PUSH
53325: LD_VAR 0 2
53329: PLUS
53330: ST_TO_ADDR
// end ; if not length then
53331: LD_VAR 0 11
53335: NOT
53336: IFFALSE 53340
// exit ;
53338: GO 53498
// tmp := array ;
53340: LD_ADDR_VAR 0 10
53344: PUSH
53345: LD_VAR 0 1
53349: ST_TO_ADDR
// for i = 1 to length do
53350: LD_ADDR_VAR 0 6
53354: PUSH
53355: DOUBLE
53356: LD_INT 1
53358: DEC
53359: ST_TO_ADDR
53360: LD_VAR 0 11
53364: PUSH
53365: FOR_TO
53366: IFFALSE 53486
// begin for j = 1 to array do
53368: LD_ADDR_VAR 0 7
53372: PUSH
53373: DOUBLE
53374: LD_INT 1
53376: DEC
53377: ST_TO_ADDR
53378: LD_VAR 0 1
53382: PUSH
53383: FOR_TO
53384: IFFALSE 53472
// begin k := j + d ;
53386: LD_ADDR_VAR 0 8
53390: PUSH
53391: LD_VAR 0 7
53395: PUSH
53396: LD_VAR 0 9
53400: PLUS
53401: ST_TO_ADDR
// if k > array then
53402: LD_VAR 0 8
53406: PUSH
53407: LD_VAR 0 1
53411: GREATER
53412: IFFALSE 53422
// k := 1 ;
53414: LD_ADDR_VAR 0 8
53418: PUSH
53419: LD_INT 1
53421: ST_TO_ADDR
// if not k then
53422: LD_VAR 0 8
53426: NOT
53427: IFFALSE 53439
// k := array ;
53429: LD_ADDR_VAR 0 8
53433: PUSH
53434: LD_VAR 0 1
53438: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53439: LD_ADDR_VAR 0 10
53443: PUSH
53444: LD_VAR 0 10
53448: PPUSH
53449: LD_VAR 0 8
53453: PPUSH
53454: LD_VAR 0 1
53458: PUSH
53459: LD_VAR 0 7
53463: ARRAY
53464: PPUSH
53465: CALL_OW 1
53469: ST_TO_ADDR
// end ;
53470: GO 53383
53472: POP
53473: POP
// array := tmp ;
53474: LD_ADDR_VAR 0 1
53478: PUSH
53479: LD_VAR 0 10
53483: ST_TO_ADDR
// end ;
53484: GO 53365
53486: POP
53487: POP
// result := array ;
53488: LD_ADDR_VAR 0 5
53492: PUSH
53493: LD_VAR 0 1
53497: ST_TO_ADDR
// end ;
53498: LD_VAR 0 5
53502: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53503: LD_INT 0
53505: PPUSH
53506: PPUSH
// result := 0 ;
53507: LD_ADDR_VAR 0 3
53511: PUSH
53512: LD_INT 0
53514: ST_TO_ADDR
// if not array or not value in array then
53515: LD_VAR 0 1
53519: NOT
53520: PUSH
53521: LD_VAR 0 2
53525: PUSH
53526: LD_VAR 0 1
53530: IN
53531: NOT
53532: OR
53533: IFFALSE 53537
// exit ;
53535: GO 53591
// for i = 1 to array do
53537: LD_ADDR_VAR 0 4
53541: PUSH
53542: DOUBLE
53543: LD_INT 1
53545: DEC
53546: ST_TO_ADDR
53547: LD_VAR 0 1
53551: PUSH
53552: FOR_TO
53553: IFFALSE 53589
// if value = array [ i ] then
53555: LD_VAR 0 2
53559: PUSH
53560: LD_VAR 0 1
53564: PUSH
53565: LD_VAR 0 4
53569: ARRAY
53570: EQUAL
53571: IFFALSE 53587
// begin result := i ;
53573: LD_ADDR_VAR 0 3
53577: PUSH
53578: LD_VAR 0 4
53582: ST_TO_ADDR
// exit ;
53583: POP
53584: POP
53585: GO 53591
// end ;
53587: GO 53552
53589: POP
53590: POP
// end ;
53591: LD_VAR 0 3
53595: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53596: LD_INT 0
53598: PPUSH
// vc_chassis := chassis ;
53599: LD_ADDR_OWVAR 37
53603: PUSH
53604: LD_VAR 0 1
53608: ST_TO_ADDR
// vc_engine := engine ;
53609: LD_ADDR_OWVAR 39
53613: PUSH
53614: LD_VAR 0 2
53618: ST_TO_ADDR
// vc_control := control ;
53619: LD_ADDR_OWVAR 38
53623: PUSH
53624: LD_VAR 0 3
53628: ST_TO_ADDR
// vc_weapon := weapon ;
53629: LD_ADDR_OWVAR 40
53633: PUSH
53634: LD_VAR 0 4
53638: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53639: LD_ADDR_OWVAR 41
53643: PUSH
53644: LD_VAR 0 5
53648: ST_TO_ADDR
// end ;
53649: LD_VAR 0 6
53653: RET
// export function WantPlant ( unit ) ; var task ; begin
53654: LD_INT 0
53656: PPUSH
53657: PPUSH
// result := false ;
53658: LD_ADDR_VAR 0 2
53662: PUSH
53663: LD_INT 0
53665: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53666: LD_ADDR_VAR 0 3
53670: PUSH
53671: LD_VAR 0 1
53675: PPUSH
53676: CALL_OW 437
53680: ST_TO_ADDR
// if task then
53681: LD_VAR 0 3
53685: IFFALSE 53713
// if task [ 1 ] [ 1 ] = p then
53687: LD_VAR 0 3
53691: PUSH
53692: LD_INT 1
53694: ARRAY
53695: PUSH
53696: LD_INT 1
53698: ARRAY
53699: PUSH
53700: LD_STRING p
53702: EQUAL
53703: IFFALSE 53713
// result := true ;
53705: LD_ADDR_VAR 0 2
53709: PUSH
53710: LD_INT 1
53712: ST_TO_ADDR
// end ;
53713: LD_VAR 0 2
53717: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53718: LD_INT 0
53720: PPUSH
53721: PPUSH
53722: PPUSH
53723: PPUSH
// if pos < 1 then
53724: LD_VAR 0 2
53728: PUSH
53729: LD_INT 1
53731: LESS
53732: IFFALSE 53736
// exit ;
53734: GO 54039
// if pos = 1 then
53736: LD_VAR 0 2
53740: PUSH
53741: LD_INT 1
53743: EQUAL
53744: IFFALSE 53777
// result := Replace ( arr , pos [ 1 ] , value ) else
53746: LD_ADDR_VAR 0 4
53750: PUSH
53751: LD_VAR 0 1
53755: PPUSH
53756: LD_VAR 0 2
53760: PUSH
53761: LD_INT 1
53763: ARRAY
53764: PPUSH
53765: LD_VAR 0 3
53769: PPUSH
53770: CALL_OW 1
53774: ST_TO_ADDR
53775: GO 54039
// begin tmp := arr ;
53777: LD_ADDR_VAR 0 6
53781: PUSH
53782: LD_VAR 0 1
53786: ST_TO_ADDR
// s_arr := [ tmp ] ;
53787: LD_ADDR_VAR 0 7
53791: PUSH
53792: LD_VAR 0 6
53796: PUSH
53797: EMPTY
53798: LIST
53799: ST_TO_ADDR
// for i = 1 to pos - 1 do
53800: LD_ADDR_VAR 0 5
53804: PUSH
53805: DOUBLE
53806: LD_INT 1
53808: DEC
53809: ST_TO_ADDR
53810: LD_VAR 0 2
53814: PUSH
53815: LD_INT 1
53817: MINUS
53818: PUSH
53819: FOR_TO
53820: IFFALSE 53865
// begin tmp := tmp [ pos [ i ] ] ;
53822: LD_ADDR_VAR 0 6
53826: PUSH
53827: LD_VAR 0 6
53831: PUSH
53832: LD_VAR 0 2
53836: PUSH
53837: LD_VAR 0 5
53841: ARRAY
53842: ARRAY
53843: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53844: LD_ADDR_VAR 0 7
53848: PUSH
53849: LD_VAR 0 7
53853: PUSH
53854: LD_VAR 0 6
53858: PUSH
53859: EMPTY
53860: LIST
53861: ADD
53862: ST_TO_ADDR
// end ;
53863: GO 53819
53865: POP
53866: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53867: LD_ADDR_VAR 0 6
53871: PUSH
53872: LD_VAR 0 6
53876: PPUSH
53877: LD_VAR 0 2
53881: PUSH
53882: LD_VAR 0 2
53886: ARRAY
53887: PPUSH
53888: LD_VAR 0 3
53892: PPUSH
53893: CALL_OW 1
53897: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53898: LD_ADDR_VAR 0 7
53902: PUSH
53903: LD_VAR 0 7
53907: PPUSH
53908: LD_VAR 0 7
53912: PPUSH
53913: LD_VAR 0 6
53917: PPUSH
53918: CALL_OW 1
53922: ST_TO_ADDR
// for i = s_arr downto 2 do
53923: LD_ADDR_VAR 0 5
53927: PUSH
53928: DOUBLE
53929: LD_VAR 0 7
53933: INC
53934: ST_TO_ADDR
53935: LD_INT 2
53937: PUSH
53938: FOR_DOWNTO
53939: IFFALSE 54023
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53941: LD_ADDR_VAR 0 6
53945: PUSH
53946: LD_VAR 0 7
53950: PUSH
53951: LD_VAR 0 5
53955: PUSH
53956: LD_INT 1
53958: MINUS
53959: ARRAY
53960: PPUSH
53961: LD_VAR 0 2
53965: PUSH
53966: LD_VAR 0 5
53970: PUSH
53971: LD_INT 1
53973: MINUS
53974: ARRAY
53975: PPUSH
53976: LD_VAR 0 7
53980: PUSH
53981: LD_VAR 0 5
53985: ARRAY
53986: PPUSH
53987: CALL_OW 1
53991: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53992: LD_ADDR_VAR 0 7
53996: PUSH
53997: LD_VAR 0 7
54001: PPUSH
54002: LD_VAR 0 5
54006: PUSH
54007: LD_INT 1
54009: MINUS
54010: PPUSH
54011: LD_VAR 0 6
54015: PPUSH
54016: CALL_OW 1
54020: ST_TO_ADDR
// end ;
54021: GO 53938
54023: POP
54024: POP
// result := s_arr [ 1 ] ;
54025: LD_ADDR_VAR 0 4
54029: PUSH
54030: LD_VAR 0 7
54034: PUSH
54035: LD_INT 1
54037: ARRAY
54038: ST_TO_ADDR
// end ; end ;
54039: LD_VAR 0 4
54043: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54044: LD_INT 0
54046: PPUSH
54047: PPUSH
// if not list then
54048: LD_VAR 0 1
54052: NOT
54053: IFFALSE 54057
// exit ;
54055: GO 54148
// i := list [ pos1 ] ;
54057: LD_ADDR_VAR 0 5
54061: PUSH
54062: LD_VAR 0 1
54066: PUSH
54067: LD_VAR 0 2
54071: ARRAY
54072: ST_TO_ADDR
// if not i then
54073: LD_VAR 0 5
54077: NOT
54078: IFFALSE 54082
// exit ;
54080: GO 54148
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54082: LD_ADDR_VAR 0 1
54086: PUSH
54087: LD_VAR 0 1
54091: PPUSH
54092: LD_VAR 0 2
54096: PPUSH
54097: LD_VAR 0 1
54101: PUSH
54102: LD_VAR 0 3
54106: ARRAY
54107: PPUSH
54108: CALL_OW 1
54112: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54113: LD_ADDR_VAR 0 1
54117: PUSH
54118: LD_VAR 0 1
54122: PPUSH
54123: LD_VAR 0 3
54127: PPUSH
54128: LD_VAR 0 5
54132: PPUSH
54133: CALL_OW 1
54137: ST_TO_ADDR
// result := list ;
54138: LD_ADDR_VAR 0 4
54142: PUSH
54143: LD_VAR 0 1
54147: ST_TO_ADDR
// end ;
54148: LD_VAR 0 4
54152: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54153: LD_INT 0
54155: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54156: LD_ADDR_VAR 0 5
54160: PUSH
54161: LD_VAR 0 1
54165: PPUSH
54166: CALL_OW 250
54170: PPUSH
54171: LD_VAR 0 1
54175: PPUSH
54176: CALL_OW 251
54180: PPUSH
54181: LD_VAR 0 2
54185: PPUSH
54186: LD_VAR 0 3
54190: PPUSH
54191: LD_VAR 0 4
54195: PPUSH
54196: CALL 54206 0 5
54200: ST_TO_ADDR
// end ;
54201: LD_VAR 0 5
54205: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54206: LD_INT 0
54208: PPUSH
54209: PPUSH
54210: PPUSH
54211: PPUSH
// if not list then
54212: LD_VAR 0 3
54216: NOT
54217: IFFALSE 54221
// exit ;
54219: GO 54609
// result := [ ] ;
54221: LD_ADDR_VAR 0 6
54225: PUSH
54226: EMPTY
54227: ST_TO_ADDR
// for i in list do
54228: LD_ADDR_VAR 0 7
54232: PUSH
54233: LD_VAR 0 3
54237: PUSH
54238: FOR_IN
54239: IFFALSE 54441
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54241: LD_ADDR_VAR 0 9
54245: PUSH
54246: LD_VAR 0 7
54250: PPUSH
54251: LD_VAR 0 1
54255: PPUSH
54256: LD_VAR 0 2
54260: PPUSH
54261: CALL_OW 297
54265: ST_TO_ADDR
// if not result then
54266: LD_VAR 0 6
54270: NOT
54271: IFFALSE 54297
// result := [ [ i , tmp ] ] else
54273: LD_ADDR_VAR 0 6
54277: PUSH
54278: LD_VAR 0 7
54282: PUSH
54283: LD_VAR 0 9
54287: PUSH
54288: EMPTY
54289: LIST
54290: LIST
54291: PUSH
54292: EMPTY
54293: LIST
54294: ST_TO_ADDR
54295: GO 54439
// begin if result [ result ] [ 2 ] < tmp then
54297: LD_VAR 0 6
54301: PUSH
54302: LD_VAR 0 6
54306: ARRAY
54307: PUSH
54308: LD_INT 2
54310: ARRAY
54311: PUSH
54312: LD_VAR 0 9
54316: LESS
54317: IFFALSE 54359
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54319: LD_ADDR_VAR 0 6
54323: PUSH
54324: LD_VAR 0 6
54328: PPUSH
54329: LD_VAR 0 6
54333: PUSH
54334: LD_INT 1
54336: PLUS
54337: PPUSH
54338: LD_VAR 0 7
54342: PUSH
54343: LD_VAR 0 9
54347: PUSH
54348: EMPTY
54349: LIST
54350: LIST
54351: PPUSH
54352: CALL_OW 2
54356: ST_TO_ADDR
54357: GO 54439
// for j = 1 to result do
54359: LD_ADDR_VAR 0 8
54363: PUSH
54364: DOUBLE
54365: LD_INT 1
54367: DEC
54368: ST_TO_ADDR
54369: LD_VAR 0 6
54373: PUSH
54374: FOR_TO
54375: IFFALSE 54437
// begin if tmp < result [ j ] [ 2 ] then
54377: LD_VAR 0 9
54381: PUSH
54382: LD_VAR 0 6
54386: PUSH
54387: LD_VAR 0 8
54391: ARRAY
54392: PUSH
54393: LD_INT 2
54395: ARRAY
54396: LESS
54397: IFFALSE 54435
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54399: LD_ADDR_VAR 0 6
54403: PUSH
54404: LD_VAR 0 6
54408: PPUSH
54409: LD_VAR 0 8
54413: PPUSH
54414: LD_VAR 0 7
54418: PUSH
54419: LD_VAR 0 9
54423: PUSH
54424: EMPTY
54425: LIST
54426: LIST
54427: PPUSH
54428: CALL_OW 2
54432: ST_TO_ADDR
// break ;
54433: GO 54437
// end ; end ;
54435: GO 54374
54437: POP
54438: POP
// end ; end ;
54439: GO 54238
54441: POP
54442: POP
// if result and not asc then
54443: LD_VAR 0 6
54447: PUSH
54448: LD_VAR 0 4
54452: NOT
54453: AND
54454: IFFALSE 54529
// begin tmp := result ;
54456: LD_ADDR_VAR 0 9
54460: PUSH
54461: LD_VAR 0 6
54465: ST_TO_ADDR
// for i = tmp downto 1 do
54466: LD_ADDR_VAR 0 7
54470: PUSH
54471: DOUBLE
54472: LD_VAR 0 9
54476: INC
54477: ST_TO_ADDR
54478: LD_INT 1
54480: PUSH
54481: FOR_DOWNTO
54482: IFFALSE 54527
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54484: LD_ADDR_VAR 0 6
54488: PUSH
54489: LD_VAR 0 6
54493: PPUSH
54494: LD_VAR 0 9
54498: PUSH
54499: LD_VAR 0 7
54503: MINUS
54504: PUSH
54505: LD_INT 1
54507: PLUS
54508: PPUSH
54509: LD_VAR 0 9
54513: PUSH
54514: LD_VAR 0 7
54518: ARRAY
54519: PPUSH
54520: CALL_OW 1
54524: ST_TO_ADDR
54525: GO 54481
54527: POP
54528: POP
// end ; tmp := [ ] ;
54529: LD_ADDR_VAR 0 9
54533: PUSH
54534: EMPTY
54535: ST_TO_ADDR
// if mode then
54536: LD_VAR 0 5
54540: IFFALSE 54609
// begin for i = 1 to result do
54542: LD_ADDR_VAR 0 7
54546: PUSH
54547: DOUBLE
54548: LD_INT 1
54550: DEC
54551: ST_TO_ADDR
54552: LD_VAR 0 6
54556: PUSH
54557: FOR_TO
54558: IFFALSE 54597
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54560: LD_ADDR_VAR 0 9
54564: PUSH
54565: LD_VAR 0 9
54569: PPUSH
54570: LD_VAR 0 7
54574: PPUSH
54575: LD_VAR 0 6
54579: PUSH
54580: LD_VAR 0 7
54584: ARRAY
54585: PUSH
54586: LD_INT 1
54588: ARRAY
54589: PPUSH
54590: CALL_OW 1
54594: ST_TO_ADDR
54595: GO 54557
54597: POP
54598: POP
// result := tmp ;
54599: LD_ADDR_VAR 0 6
54603: PUSH
54604: LD_VAR 0 9
54608: ST_TO_ADDR
// end ; end ;
54609: LD_VAR 0 6
54613: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54614: LD_INT 0
54616: PPUSH
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54622: LD_ADDR_VAR 0 5
54626: PUSH
54627: LD_INT 0
54629: PUSH
54630: LD_INT 0
54632: PUSH
54633: LD_INT 0
54635: PUSH
54636: EMPTY
54637: PUSH
54638: EMPTY
54639: LIST
54640: LIST
54641: LIST
54642: LIST
54643: ST_TO_ADDR
// if not x or not y then
54644: LD_VAR 0 2
54648: NOT
54649: PUSH
54650: LD_VAR 0 3
54654: NOT
54655: OR
54656: IFFALSE 54660
// exit ;
54658: GO 56312
// if not range then
54660: LD_VAR 0 4
54664: NOT
54665: IFFALSE 54675
// range := 10 ;
54667: LD_ADDR_VAR 0 4
54671: PUSH
54672: LD_INT 10
54674: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54675: LD_ADDR_VAR 0 8
54679: PUSH
54680: LD_INT 81
54682: PUSH
54683: LD_VAR 0 1
54687: PUSH
54688: EMPTY
54689: LIST
54690: LIST
54691: PUSH
54692: LD_INT 92
54694: PUSH
54695: LD_VAR 0 2
54699: PUSH
54700: LD_VAR 0 3
54704: PUSH
54705: LD_VAR 0 4
54709: PUSH
54710: EMPTY
54711: LIST
54712: LIST
54713: LIST
54714: LIST
54715: PUSH
54716: LD_INT 3
54718: PUSH
54719: LD_INT 21
54721: PUSH
54722: LD_INT 3
54724: PUSH
54725: EMPTY
54726: LIST
54727: LIST
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: PUSH
54733: EMPTY
54734: LIST
54735: LIST
54736: LIST
54737: PPUSH
54738: CALL_OW 69
54742: ST_TO_ADDR
// if not tmp then
54743: LD_VAR 0 8
54747: NOT
54748: IFFALSE 54752
// exit ;
54750: GO 56312
// for i in tmp do
54752: LD_ADDR_VAR 0 6
54756: PUSH
54757: LD_VAR 0 8
54761: PUSH
54762: FOR_IN
54763: IFFALSE 56287
// begin points := [ 0 , 0 , 0 ] ;
54765: LD_ADDR_VAR 0 9
54769: PUSH
54770: LD_INT 0
54772: PUSH
54773: LD_INT 0
54775: PUSH
54776: LD_INT 0
54778: PUSH
54779: EMPTY
54780: LIST
54781: LIST
54782: LIST
54783: ST_TO_ADDR
// bpoints := 1 ;
54784: LD_ADDR_VAR 0 10
54788: PUSH
54789: LD_INT 1
54791: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54792: LD_VAR 0 6
54796: PPUSH
54797: CALL_OW 247
54801: PUSH
54802: LD_INT 1
54804: DOUBLE
54805: EQUAL
54806: IFTRUE 54810
54808: GO 55388
54810: POP
// begin if GetClass ( i ) = 1 then
54811: LD_VAR 0 6
54815: PPUSH
54816: CALL_OW 257
54820: PUSH
54821: LD_INT 1
54823: EQUAL
54824: IFFALSE 54845
// points := [ 10 , 5 , 3 ] ;
54826: LD_ADDR_VAR 0 9
54830: PUSH
54831: LD_INT 10
54833: PUSH
54834: LD_INT 5
54836: PUSH
54837: LD_INT 3
54839: PUSH
54840: EMPTY
54841: LIST
54842: LIST
54843: LIST
54844: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54845: LD_VAR 0 6
54849: PPUSH
54850: CALL_OW 257
54854: PUSH
54855: LD_INT 2
54857: PUSH
54858: LD_INT 3
54860: PUSH
54861: LD_INT 4
54863: PUSH
54864: EMPTY
54865: LIST
54866: LIST
54867: LIST
54868: IN
54869: IFFALSE 54890
// points := [ 3 , 2 , 1 ] ;
54871: LD_ADDR_VAR 0 9
54875: PUSH
54876: LD_INT 3
54878: PUSH
54879: LD_INT 2
54881: PUSH
54882: LD_INT 1
54884: PUSH
54885: EMPTY
54886: LIST
54887: LIST
54888: LIST
54889: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54890: LD_VAR 0 6
54894: PPUSH
54895: CALL_OW 257
54899: PUSH
54900: LD_INT 5
54902: EQUAL
54903: IFFALSE 54924
// points := [ 130 , 5 , 2 ] ;
54905: LD_ADDR_VAR 0 9
54909: PUSH
54910: LD_INT 130
54912: PUSH
54913: LD_INT 5
54915: PUSH
54916: LD_INT 2
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54924: LD_VAR 0 6
54928: PPUSH
54929: CALL_OW 257
54933: PUSH
54934: LD_INT 8
54936: EQUAL
54937: IFFALSE 54958
// points := [ 35 , 35 , 30 ] ;
54939: LD_ADDR_VAR 0 9
54943: PUSH
54944: LD_INT 35
54946: PUSH
54947: LD_INT 35
54949: PUSH
54950: LD_INT 30
54952: PUSH
54953: EMPTY
54954: LIST
54955: LIST
54956: LIST
54957: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54958: LD_VAR 0 6
54962: PPUSH
54963: CALL_OW 257
54967: PUSH
54968: LD_INT 9
54970: EQUAL
54971: IFFALSE 54992
// points := [ 20 , 55 , 40 ] ;
54973: LD_ADDR_VAR 0 9
54977: PUSH
54978: LD_INT 20
54980: PUSH
54981: LD_INT 55
54983: PUSH
54984: LD_INT 40
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: LIST
54991: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54992: LD_VAR 0 6
54996: PPUSH
54997: CALL_OW 257
55001: PUSH
55002: LD_INT 12
55004: PUSH
55005: LD_INT 16
55007: PUSH
55008: EMPTY
55009: LIST
55010: LIST
55011: IN
55012: IFFALSE 55033
// points := [ 5 , 3 , 2 ] ;
55014: LD_ADDR_VAR 0 9
55018: PUSH
55019: LD_INT 5
55021: PUSH
55022: LD_INT 3
55024: PUSH
55025: LD_INT 2
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: LIST
55032: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55033: LD_VAR 0 6
55037: PPUSH
55038: CALL_OW 257
55042: PUSH
55043: LD_INT 17
55045: EQUAL
55046: IFFALSE 55067
// points := [ 100 , 50 , 75 ] ;
55048: LD_ADDR_VAR 0 9
55052: PUSH
55053: LD_INT 100
55055: PUSH
55056: LD_INT 50
55058: PUSH
55059: LD_INT 75
55061: PUSH
55062: EMPTY
55063: LIST
55064: LIST
55065: LIST
55066: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55067: LD_VAR 0 6
55071: PPUSH
55072: CALL_OW 257
55076: PUSH
55077: LD_INT 15
55079: EQUAL
55080: IFFALSE 55101
// points := [ 10 , 5 , 3 ] ;
55082: LD_ADDR_VAR 0 9
55086: PUSH
55087: LD_INT 10
55089: PUSH
55090: LD_INT 5
55092: PUSH
55093: LD_INT 3
55095: PUSH
55096: EMPTY
55097: LIST
55098: LIST
55099: LIST
55100: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55101: LD_VAR 0 6
55105: PPUSH
55106: CALL_OW 257
55110: PUSH
55111: LD_INT 14
55113: EQUAL
55114: IFFALSE 55135
// points := [ 10 , 0 , 0 ] ;
55116: LD_ADDR_VAR 0 9
55120: PUSH
55121: LD_INT 10
55123: PUSH
55124: LD_INT 0
55126: PUSH
55127: LD_INT 0
55129: PUSH
55130: EMPTY
55131: LIST
55132: LIST
55133: LIST
55134: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55135: LD_VAR 0 6
55139: PPUSH
55140: CALL_OW 257
55144: PUSH
55145: LD_INT 11
55147: EQUAL
55148: IFFALSE 55169
// points := [ 30 , 10 , 5 ] ;
55150: LD_ADDR_VAR 0 9
55154: PUSH
55155: LD_INT 30
55157: PUSH
55158: LD_INT 10
55160: PUSH
55161: LD_INT 5
55163: PUSH
55164: EMPTY
55165: LIST
55166: LIST
55167: LIST
55168: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55169: LD_VAR 0 1
55173: PPUSH
55174: LD_INT 5
55176: PPUSH
55177: CALL_OW 321
55181: PUSH
55182: LD_INT 2
55184: EQUAL
55185: IFFALSE 55202
// bpoints := bpoints * 1.8 ;
55187: LD_ADDR_VAR 0 10
55191: PUSH
55192: LD_VAR 0 10
55196: PUSH
55197: LD_REAL  1.80000000000000E+0000
55200: MUL
55201: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55202: LD_VAR 0 6
55206: PPUSH
55207: CALL_OW 257
55211: PUSH
55212: LD_INT 1
55214: PUSH
55215: LD_INT 2
55217: PUSH
55218: LD_INT 3
55220: PUSH
55221: LD_INT 4
55223: PUSH
55224: EMPTY
55225: LIST
55226: LIST
55227: LIST
55228: LIST
55229: IN
55230: PUSH
55231: LD_VAR 0 1
55235: PPUSH
55236: LD_INT 51
55238: PPUSH
55239: CALL_OW 321
55243: PUSH
55244: LD_INT 2
55246: EQUAL
55247: AND
55248: IFFALSE 55265
// bpoints := bpoints * 1.2 ;
55250: LD_ADDR_VAR 0 10
55254: PUSH
55255: LD_VAR 0 10
55259: PUSH
55260: LD_REAL  1.20000000000000E+0000
55263: MUL
55264: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55265: LD_VAR 0 6
55269: PPUSH
55270: CALL_OW 257
55274: PUSH
55275: LD_INT 5
55277: PUSH
55278: LD_INT 7
55280: PUSH
55281: LD_INT 9
55283: PUSH
55284: EMPTY
55285: LIST
55286: LIST
55287: LIST
55288: IN
55289: PUSH
55290: LD_VAR 0 1
55294: PPUSH
55295: LD_INT 52
55297: PPUSH
55298: CALL_OW 321
55302: PUSH
55303: LD_INT 2
55305: EQUAL
55306: AND
55307: IFFALSE 55324
// bpoints := bpoints * 1.5 ;
55309: LD_ADDR_VAR 0 10
55313: PUSH
55314: LD_VAR 0 10
55318: PUSH
55319: LD_REAL  1.50000000000000E+0000
55322: MUL
55323: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55324: LD_VAR 0 1
55328: PPUSH
55329: LD_INT 66
55331: PPUSH
55332: CALL_OW 321
55336: PUSH
55337: LD_INT 2
55339: EQUAL
55340: IFFALSE 55357
// bpoints := bpoints * 1.1 ;
55342: LD_ADDR_VAR 0 10
55346: PUSH
55347: LD_VAR 0 10
55351: PUSH
55352: LD_REAL  1.10000000000000E+0000
55355: MUL
55356: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55357: LD_ADDR_VAR 0 10
55361: PUSH
55362: LD_VAR 0 10
55366: PUSH
55367: LD_VAR 0 6
55371: PPUSH
55372: LD_INT 1
55374: PPUSH
55375: CALL_OW 259
55379: PUSH
55380: LD_REAL  1.15000000000000E+0000
55383: MUL
55384: MUL
55385: ST_TO_ADDR
// end ; unit_vehicle :
55386: GO 56216
55388: LD_INT 2
55390: DOUBLE
55391: EQUAL
55392: IFTRUE 55396
55394: GO 56204
55396: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55397: LD_VAR 0 6
55401: PPUSH
55402: CALL_OW 264
55406: PUSH
55407: LD_INT 2
55409: PUSH
55410: LD_INT 42
55412: PUSH
55413: LD_INT 24
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: LIST
55420: IN
55421: IFFALSE 55442
// points := [ 25 , 5 , 3 ] ;
55423: LD_ADDR_VAR 0 9
55427: PUSH
55428: LD_INT 25
55430: PUSH
55431: LD_INT 5
55433: PUSH
55434: LD_INT 3
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: LIST
55441: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55442: LD_VAR 0 6
55446: PPUSH
55447: CALL_OW 264
55451: PUSH
55452: LD_INT 4
55454: PUSH
55455: LD_INT 43
55457: PUSH
55458: LD_INT 25
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: LIST
55465: IN
55466: IFFALSE 55487
// points := [ 40 , 15 , 5 ] ;
55468: LD_ADDR_VAR 0 9
55472: PUSH
55473: LD_INT 40
55475: PUSH
55476: LD_INT 15
55478: PUSH
55479: LD_INT 5
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: LIST
55486: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55487: LD_VAR 0 6
55491: PPUSH
55492: CALL_OW 264
55496: PUSH
55497: LD_INT 3
55499: PUSH
55500: LD_INT 23
55502: PUSH
55503: EMPTY
55504: LIST
55505: LIST
55506: IN
55507: IFFALSE 55528
// points := [ 7 , 25 , 8 ] ;
55509: LD_ADDR_VAR 0 9
55513: PUSH
55514: LD_INT 7
55516: PUSH
55517: LD_INT 25
55519: PUSH
55520: LD_INT 8
55522: PUSH
55523: EMPTY
55524: LIST
55525: LIST
55526: LIST
55527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55528: LD_VAR 0 6
55532: PPUSH
55533: CALL_OW 264
55537: PUSH
55538: LD_INT 5
55540: PUSH
55541: LD_INT 27
55543: PUSH
55544: LD_INT 44
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: LIST
55551: IN
55552: IFFALSE 55573
// points := [ 14 , 50 , 16 ] ;
55554: LD_ADDR_VAR 0 9
55558: PUSH
55559: LD_INT 14
55561: PUSH
55562: LD_INT 50
55564: PUSH
55565: LD_INT 16
55567: PUSH
55568: EMPTY
55569: LIST
55570: LIST
55571: LIST
55572: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55573: LD_VAR 0 6
55577: PPUSH
55578: CALL_OW 264
55582: PUSH
55583: LD_INT 6
55585: PUSH
55586: LD_INT 46
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: IN
55593: IFFALSE 55614
// points := [ 32 , 120 , 70 ] ;
55595: LD_ADDR_VAR 0 9
55599: PUSH
55600: LD_INT 32
55602: PUSH
55603: LD_INT 120
55605: PUSH
55606: LD_INT 70
55608: PUSH
55609: EMPTY
55610: LIST
55611: LIST
55612: LIST
55613: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55614: LD_VAR 0 6
55618: PPUSH
55619: CALL_OW 264
55623: PUSH
55624: LD_INT 7
55626: PUSH
55627: LD_INT 28
55629: PUSH
55630: LD_INT 45
55632: PUSH
55633: LD_EXP 99
55637: PUSH
55638: EMPTY
55639: LIST
55640: LIST
55641: LIST
55642: LIST
55643: IN
55644: IFFALSE 55665
// points := [ 35 , 20 , 45 ] ;
55646: LD_ADDR_VAR 0 9
55650: PUSH
55651: LD_INT 35
55653: PUSH
55654: LD_INT 20
55656: PUSH
55657: LD_INT 45
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: LIST
55664: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55665: LD_VAR 0 6
55669: PPUSH
55670: CALL_OW 264
55674: PUSH
55675: LD_INT 47
55677: PUSH
55678: EMPTY
55679: LIST
55680: IN
55681: IFFALSE 55702
// points := [ 67 , 45 , 75 ] ;
55683: LD_ADDR_VAR 0 9
55687: PUSH
55688: LD_INT 67
55690: PUSH
55691: LD_INT 45
55693: PUSH
55694: LD_INT 75
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: LIST
55701: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55702: LD_VAR 0 6
55706: PPUSH
55707: CALL_OW 264
55711: PUSH
55712: LD_INT 26
55714: PUSH
55715: EMPTY
55716: LIST
55717: IN
55718: IFFALSE 55739
// points := [ 120 , 30 , 80 ] ;
55720: LD_ADDR_VAR 0 9
55724: PUSH
55725: LD_INT 120
55727: PUSH
55728: LD_INT 30
55730: PUSH
55731: LD_INT 80
55733: PUSH
55734: EMPTY
55735: LIST
55736: LIST
55737: LIST
55738: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55739: LD_VAR 0 6
55743: PPUSH
55744: CALL_OW 264
55748: PUSH
55749: LD_INT 22
55751: PUSH
55752: EMPTY
55753: LIST
55754: IN
55755: IFFALSE 55776
// points := [ 40 , 1 , 1 ] ;
55757: LD_ADDR_VAR 0 9
55761: PUSH
55762: LD_INT 40
55764: PUSH
55765: LD_INT 1
55767: PUSH
55768: LD_INT 1
55770: PUSH
55771: EMPTY
55772: LIST
55773: LIST
55774: LIST
55775: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55776: LD_VAR 0 6
55780: PPUSH
55781: CALL_OW 264
55785: PUSH
55786: LD_INT 29
55788: PUSH
55789: EMPTY
55790: LIST
55791: IN
55792: IFFALSE 55813
// points := [ 70 , 200 , 400 ] ;
55794: LD_ADDR_VAR 0 9
55798: PUSH
55799: LD_INT 70
55801: PUSH
55802: LD_INT 200
55804: PUSH
55805: LD_INT 400
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55813: LD_VAR 0 6
55817: PPUSH
55818: CALL_OW 264
55822: PUSH
55823: LD_INT 14
55825: PUSH
55826: LD_INT 53
55828: PUSH
55829: EMPTY
55830: LIST
55831: LIST
55832: IN
55833: IFFALSE 55854
// points := [ 40 , 10 , 20 ] ;
55835: LD_ADDR_VAR 0 9
55839: PUSH
55840: LD_INT 40
55842: PUSH
55843: LD_INT 10
55845: PUSH
55846: LD_INT 20
55848: PUSH
55849: EMPTY
55850: LIST
55851: LIST
55852: LIST
55853: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55854: LD_VAR 0 6
55858: PPUSH
55859: CALL_OW 264
55863: PUSH
55864: LD_INT 9
55866: PUSH
55867: EMPTY
55868: LIST
55869: IN
55870: IFFALSE 55891
// points := [ 5 , 70 , 20 ] ;
55872: LD_ADDR_VAR 0 9
55876: PUSH
55877: LD_INT 5
55879: PUSH
55880: LD_INT 70
55882: PUSH
55883: LD_INT 20
55885: PUSH
55886: EMPTY
55887: LIST
55888: LIST
55889: LIST
55890: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55891: LD_VAR 0 6
55895: PPUSH
55896: CALL_OW 264
55900: PUSH
55901: LD_INT 10
55903: PUSH
55904: EMPTY
55905: LIST
55906: IN
55907: IFFALSE 55928
// points := [ 35 , 110 , 70 ] ;
55909: LD_ADDR_VAR 0 9
55913: PUSH
55914: LD_INT 35
55916: PUSH
55917: LD_INT 110
55919: PUSH
55920: LD_INT 70
55922: PUSH
55923: EMPTY
55924: LIST
55925: LIST
55926: LIST
55927: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55928: LD_VAR 0 6
55932: PPUSH
55933: CALL_OW 265
55937: PUSH
55938: LD_INT 25
55940: EQUAL
55941: IFFALSE 55962
// points := [ 80 , 65 , 100 ] ;
55943: LD_ADDR_VAR 0 9
55947: PUSH
55948: LD_INT 80
55950: PUSH
55951: LD_INT 65
55953: PUSH
55954: LD_INT 100
55956: PUSH
55957: EMPTY
55958: LIST
55959: LIST
55960: LIST
55961: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55962: LD_VAR 0 6
55966: PPUSH
55967: CALL_OW 263
55971: PUSH
55972: LD_INT 1
55974: EQUAL
55975: IFFALSE 56010
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55977: LD_ADDR_VAR 0 10
55981: PUSH
55982: LD_VAR 0 10
55986: PUSH
55987: LD_VAR 0 6
55991: PPUSH
55992: CALL_OW 311
55996: PPUSH
55997: LD_INT 3
55999: PPUSH
56000: CALL_OW 259
56004: PUSH
56005: LD_INT 4
56007: MUL
56008: MUL
56009: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56010: LD_VAR 0 6
56014: PPUSH
56015: CALL_OW 263
56019: PUSH
56020: LD_INT 2
56022: EQUAL
56023: IFFALSE 56074
// begin j := IsControledBy ( i ) ;
56025: LD_ADDR_VAR 0 7
56029: PUSH
56030: LD_VAR 0 6
56034: PPUSH
56035: CALL_OW 312
56039: ST_TO_ADDR
// if j then
56040: LD_VAR 0 7
56044: IFFALSE 56074
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56046: LD_ADDR_VAR 0 10
56050: PUSH
56051: LD_VAR 0 10
56055: PUSH
56056: LD_VAR 0 7
56060: PPUSH
56061: LD_INT 3
56063: PPUSH
56064: CALL_OW 259
56068: PUSH
56069: LD_INT 3
56071: MUL
56072: MUL
56073: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56074: LD_VAR 0 6
56078: PPUSH
56079: CALL_OW 264
56083: PUSH
56084: LD_INT 5
56086: PUSH
56087: LD_INT 6
56089: PUSH
56090: LD_INT 46
56092: PUSH
56093: LD_INT 44
56095: PUSH
56096: LD_INT 47
56098: PUSH
56099: LD_INT 45
56101: PUSH
56102: LD_INT 28
56104: PUSH
56105: LD_INT 7
56107: PUSH
56108: LD_INT 27
56110: PUSH
56111: LD_INT 29
56113: PUSH
56114: EMPTY
56115: LIST
56116: LIST
56117: LIST
56118: LIST
56119: LIST
56120: LIST
56121: LIST
56122: LIST
56123: LIST
56124: LIST
56125: IN
56126: PUSH
56127: LD_VAR 0 1
56131: PPUSH
56132: LD_INT 52
56134: PPUSH
56135: CALL_OW 321
56139: PUSH
56140: LD_INT 2
56142: EQUAL
56143: AND
56144: IFFALSE 56161
// bpoints := bpoints * 1.2 ;
56146: LD_ADDR_VAR 0 10
56150: PUSH
56151: LD_VAR 0 10
56155: PUSH
56156: LD_REAL  1.20000000000000E+0000
56159: MUL
56160: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56161: LD_VAR 0 6
56165: PPUSH
56166: CALL_OW 264
56170: PUSH
56171: LD_INT 6
56173: PUSH
56174: LD_INT 46
56176: PUSH
56177: LD_INT 47
56179: PUSH
56180: EMPTY
56181: LIST
56182: LIST
56183: LIST
56184: IN
56185: IFFALSE 56202
// bpoints := bpoints * 1.2 ;
56187: LD_ADDR_VAR 0 10
56191: PUSH
56192: LD_VAR 0 10
56196: PUSH
56197: LD_REAL  1.20000000000000E+0000
56200: MUL
56201: ST_TO_ADDR
// end ; unit_building :
56202: GO 56216
56204: LD_INT 3
56206: DOUBLE
56207: EQUAL
56208: IFTRUE 56212
56210: GO 56215
56212: POP
// ; end ;
56213: GO 56216
56215: POP
// for j = 1 to 3 do
56216: LD_ADDR_VAR 0 7
56220: PUSH
56221: DOUBLE
56222: LD_INT 1
56224: DEC
56225: ST_TO_ADDR
56226: LD_INT 3
56228: PUSH
56229: FOR_TO
56230: IFFALSE 56283
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56232: LD_ADDR_VAR 0 5
56236: PUSH
56237: LD_VAR 0 5
56241: PPUSH
56242: LD_VAR 0 7
56246: PPUSH
56247: LD_VAR 0 5
56251: PUSH
56252: LD_VAR 0 7
56256: ARRAY
56257: PUSH
56258: LD_VAR 0 9
56262: PUSH
56263: LD_VAR 0 7
56267: ARRAY
56268: PUSH
56269: LD_VAR 0 10
56273: MUL
56274: PLUS
56275: PPUSH
56276: CALL_OW 1
56280: ST_TO_ADDR
56281: GO 56229
56283: POP
56284: POP
// end ;
56285: GO 54762
56287: POP
56288: POP
// result := Replace ( result , 4 , tmp ) ;
56289: LD_ADDR_VAR 0 5
56293: PUSH
56294: LD_VAR 0 5
56298: PPUSH
56299: LD_INT 4
56301: PPUSH
56302: LD_VAR 0 8
56306: PPUSH
56307: CALL_OW 1
56311: ST_TO_ADDR
// end ;
56312: LD_VAR 0 5
56316: RET
// export function DangerAtRange ( unit , range ) ; begin
56317: LD_INT 0
56319: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56320: LD_ADDR_VAR 0 3
56324: PUSH
56325: LD_VAR 0 1
56329: PPUSH
56330: CALL_OW 255
56334: PPUSH
56335: LD_VAR 0 1
56339: PPUSH
56340: CALL_OW 250
56344: PPUSH
56345: LD_VAR 0 1
56349: PPUSH
56350: CALL_OW 251
56354: PPUSH
56355: LD_VAR 0 2
56359: PPUSH
56360: CALL 54614 0 4
56364: ST_TO_ADDR
// end ;
56365: LD_VAR 0 3
56369: RET
// export function DangerInArea ( side , area ) ; begin
56370: LD_INT 0
56372: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56373: LD_ADDR_VAR 0 3
56377: PUSH
56378: LD_VAR 0 2
56382: PPUSH
56383: LD_INT 81
56385: PUSH
56386: LD_VAR 0 1
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: PPUSH
56395: CALL_OW 70
56399: ST_TO_ADDR
// end ;
56400: LD_VAR 0 3
56404: RET
// export function IsExtension ( b ) ; begin
56405: LD_INT 0
56407: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56408: LD_ADDR_VAR 0 2
56412: PUSH
56413: LD_VAR 0 1
56417: PUSH
56418: LD_INT 23
56420: PUSH
56421: LD_INT 20
56423: PUSH
56424: LD_INT 22
56426: PUSH
56427: LD_INT 17
56429: PUSH
56430: LD_INT 24
56432: PUSH
56433: LD_INT 21
56435: PUSH
56436: LD_INT 19
56438: PUSH
56439: LD_INT 16
56441: PUSH
56442: LD_INT 25
56444: PUSH
56445: LD_INT 18
56447: PUSH
56448: EMPTY
56449: LIST
56450: LIST
56451: LIST
56452: LIST
56453: LIST
56454: LIST
56455: LIST
56456: LIST
56457: LIST
56458: LIST
56459: IN
56460: ST_TO_ADDR
// end ;
56461: LD_VAR 0 2
56465: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56466: LD_INT 0
56468: PPUSH
56469: PPUSH
56470: PPUSH
// result := [ ] ;
56471: LD_ADDR_VAR 0 4
56475: PUSH
56476: EMPTY
56477: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56478: LD_ADDR_VAR 0 5
56482: PUSH
56483: LD_VAR 0 2
56487: PPUSH
56488: LD_INT 21
56490: PUSH
56491: LD_INT 3
56493: PUSH
56494: EMPTY
56495: LIST
56496: LIST
56497: PPUSH
56498: CALL_OW 70
56502: ST_TO_ADDR
// if not tmp then
56503: LD_VAR 0 5
56507: NOT
56508: IFFALSE 56512
// exit ;
56510: GO 56576
// if checkLink then
56512: LD_VAR 0 3
56516: IFFALSE 56566
// begin for i in tmp do
56518: LD_ADDR_VAR 0 6
56522: PUSH
56523: LD_VAR 0 5
56527: PUSH
56528: FOR_IN
56529: IFFALSE 56564
// if GetBase ( i ) <> base then
56531: LD_VAR 0 6
56535: PPUSH
56536: CALL_OW 274
56540: PUSH
56541: LD_VAR 0 1
56545: NONEQUAL
56546: IFFALSE 56562
// ComLinkToBase ( base , i ) ;
56548: LD_VAR 0 1
56552: PPUSH
56553: LD_VAR 0 6
56557: PPUSH
56558: CALL_OW 169
56562: GO 56528
56564: POP
56565: POP
// end ; result := tmp ;
56566: LD_ADDR_VAR 0 4
56570: PUSH
56571: LD_VAR 0 5
56575: ST_TO_ADDR
// end ;
56576: LD_VAR 0 4
56580: RET
// export function ComComplete ( units , b ) ; var i ; begin
56581: LD_INT 0
56583: PPUSH
56584: PPUSH
// if not units then
56585: LD_VAR 0 1
56589: NOT
56590: IFFALSE 56594
// exit ;
56592: GO 56684
// for i in units do
56594: LD_ADDR_VAR 0 4
56598: PUSH
56599: LD_VAR 0 1
56603: PUSH
56604: FOR_IN
56605: IFFALSE 56682
// if BuildingStatus ( b ) = bs_build then
56607: LD_VAR 0 2
56611: PPUSH
56612: CALL_OW 461
56616: PUSH
56617: LD_INT 1
56619: EQUAL
56620: IFFALSE 56680
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56622: LD_VAR 0 4
56626: PPUSH
56627: LD_STRING h
56629: PUSH
56630: LD_VAR 0 2
56634: PPUSH
56635: CALL_OW 250
56639: PUSH
56640: LD_VAR 0 2
56644: PPUSH
56645: CALL_OW 251
56649: PUSH
56650: LD_VAR 0 2
56654: PUSH
56655: LD_INT 0
56657: PUSH
56658: LD_INT 0
56660: PUSH
56661: LD_INT 0
56663: PUSH
56664: EMPTY
56665: LIST
56666: LIST
56667: LIST
56668: LIST
56669: LIST
56670: LIST
56671: LIST
56672: PUSH
56673: EMPTY
56674: LIST
56675: PPUSH
56676: CALL_OW 446
56680: GO 56604
56682: POP
56683: POP
// end ;
56684: LD_VAR 0 3
56688: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56689: LD_INT 0
56691: PPUSH
56692: PPUSH
56693: PPUSH
56694: PPUSH
56695: PPUSH
56696: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56697: LD_VAR 0 1
56701: NOT
56702: PUSH
56703: LD_VAR 0 1
56707: PPUSH
56708: CALL_OW 263
56712: PUSH
56713: LD_INT 2
56715: NONEQUAL
56716: OR
56717: IFFALSE 56721
// exit ;
56719: GO 57037
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56721: LD_ADDR_VAR 0 6
56725: PUSH
56726: LD_INT 22
56728: PUSH
56729: LD_VAR 0 1
56733: PPUSH
56734: CALL_OW 255
56738: PUSH
56739: EMPTY
56740: LIST
56741: LIST
56742: PUSH
56743: LD_INT 2
56745: PUSH
56746: LD_INT 30
56748: PUSH
56749: LD_INT 36
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: PUSH
56756: LD_INT 34
56758: PUSH
56759: LD_INT 31
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: PUSH
56766: EMPTY
56767: LIST
56768: LIST
56769: LIST
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: PPUSH
56775: CALL_OW 69
56779: ST_TO_ADDR
// if not tmp then
56780: LD_VAR 0 6
56784: NOT
56785: IFFALSE 56789
// exit ;
56787: GO 57037
// result := [ ] ;
56789: LD_ADDR_VAR 0 2
56793: PUSH
56794: EMPTY
56795: ST_TO_ADDR
// for i in tmp do
56796: LD_ADDR_VAR 0 3
56800: PUSH
56801: LD_VAR 0 6
56805: PUSH
56806: FOR_IN
56807: IFFALSE 56878
// begin t := UnitsInside ( i ) ;
56809: LD_ADDR_VAR 0 4
56813: PUSH
56814: LD_VAR 0 3
56818: PPUSH
56819: CALL_OW 313
56823: ST_TO_ADDR
// if t then
56824: LD_VAR 0 4
56828: IFFALSE 56876
// for j in t do
56830: LD_ADDR_VAR 0 7
56834: PUSH
56835: LD_VAR 0 4
56839: PUSH
56840: FOR_IN
56841: IFFALSE 56874
// result := Replace ( result , result + 1 , j ) ;
56843: LD_ADDR_VAR 0 2
56847: PUSH
56848: LD_VAR 0 2
56852: PPUSH
56853: LD_VAR 0 2
56857: PUSH
56858: LD_INT 1
56860: PLUS
56861: PPUSH
56862: LD_VAR 0 7
56866: PPUSH
56867: CALL_OW 1
56871: ST_TO_ADDR
56872: GO 56840
56874: POP
56875: POP
// end ;
56876: GO 56806
56878: POP
56879: POP
// if not result then
56880: LD_VAR 0 2
56884: NOT
56885: IFFALSE 56889
// exit ;
56887: GO 57037
// mech := result [ 1 ] ;
56889: LD_ADDR_VAR 0 5
56893: PUSH
56894: LD_VAR 0 2
56898: PUSH
56899: LD_INT 1
56901: ARRAY
56902: ST_TO_ADDR
// if result > 1 then
56903: LD_VAR 0 2
56907: PUSH
56908: LD_INT 1
56910: GREATER
56911: IFFALSE 57023
// begin for i = 2 to result do
56913: LD_ADDR_VAR 0 3
56917: PUSH
56918: DOUBLE
56919: LD_INT 2
56921: DEC
56922: ST_TO_ADDR
56923: LD_VAR 0 2
56927: PUSH
56928: FOR_TO
56929: IFFALSE 57021
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56931: LD_ADDR_VAR 0 4
56935: PUSH
56936: LD_VAR 0 2
56940: PUSH
56941: LD_VAR 0 3
56945: ARRAY
56946: PPUSH
56947: LD_INT 3
56949: PPUSH
56950: CALL_OW 259
56954: PUSH
56955: LD_VAR 0 2
56959: PUSH
56960: LD_VAR 0 3
56964: ARRAY
56965: PPUSH
56966: CALL_OW 432
56970: MINUS
56971: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56972: LD_VAR 0 4
56976: PUSH
56977: LD_VAR 0 5
56981: PPUSH
56982: LD_INT 3
56984: PPUSH
56985: CALL_OW 259
56989: PUSH
56990: LD_VAR 0 5
56994: PPUSH
56995: CALL_OW 432
56999: MINUS
57000: GREATEREQUAL
57001: IFFALSE 57019
// mech := result [ i ] ;
57003: LD_ADDR_VAR 0 5
57007: PUSH
57008: LD_VAR 0 2
57012: PUSH
57013: LD_VAR 0 3
57017: ARRAY
57018: ST_TO_ADDR
// end ;
57019: GO 56928
57021: POP
57022: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57023: LD_VAR 0 1
57027: PPUSH
57028: LD_VAR 0 5
57032: PPUSH
57033: CALL_OW 135
// end ;
57037: LD_VAR 0 2
57041: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57042: LD_INT 0
57044: PPUSH
57045: PPUSH
57046: PPUSH
57047: PPUSH
57048: PPUSH
57049: PPUSH
57050: PPUSH
57051: PPUSH
57052: PPUSH
57053: PPUSH
57054: PPUSH
57055: PPUSH
57056: PPUSH
// result := [ ] ;
57057: LD_ADDR_VAR 0 7
57061: PUSH
57062: EMPTY
57063: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57064: LD_VAR 0 1
57068: PPUSH
57069: CALL_OW 266
57073: PUSH
57074: LD_INT 0
57076: PUSH
57077: LD_INT 1
57079: PUSH
57080: EMPTY
57081: LIST
57082: LIST
57083: IN
57084: NOT
57085: IFFALSE 57089
// exit ;
57087: GO 58723
// if name then
57089: LD_VAR 0 3
57093: IFFALSE 57109
// SetBName ( base_dep , name ) ;
57095: LD_VAR 0 1
57099: PPUSH
57100: LD_VAR 0 3
57104: PPUSH
57105: CALL_OW 500
// base := GetBase ( base_dep ) ;
57109: LD_ADDR_VAR 0 15
57113: PUSH
57114: LD_VAR 0 1
57118: PPUSH
57119: CALL_OW 274
57123: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57124: LD_ADDR_VAR 0 16
57128: PUSH
57129: LD_VAR 0 1
57133: PPUSH
57134: CALL_OW 255
57138: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57139: LD_ADDR_VAR 0 17
57143: PUSH
57144: LD_VAR 0 1
57148: PPUSH
57149: CALL_OW 248
57153: ST_TO_ADDR
// if sources then
57154: LD_VAR 0 5
57158: IFFALSE 57205
// for i = 1 to 3 do
57160: LD_ADDR_VAR 0 8
57164: PUSH
57165: DOUBLE
57166: LD_INT 1
57168: DEC
57169: ST_TO_ADDR
57170: LD_INT 3
57172: PUSH
57173: FOR_TO
57174: IFFALSE 57203
// AddResourceType ( base , i , sources [ i ] ) ;
57176: LD_VAR 0 15
57180: PPUSH
57181: LD_VAR 0 8
57185: PPUSH
57186: LD_VAR 0 5
57190: PUSH
57191: LD_VAR 0 8
57195: ARRAY
57196: PPUSH
57197: CALL_OW 276
57201: GO 57173
57203: POP
57204: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57205: LD_ADDR_VAR 0 18
57209: PUSH
57210: LD_VAR 0 15
57214: PPUSH
57215: LD_VAR 0 2
57219: PPUSH
57220: LD_INT 1
57222: PPUSH
57223: CALL 56466 0 3
57227: ST_TO_ADDR
// InitHc ;
57228: CALL_OW 19
// InitUc ;
57232: CALL_OW 18
// uc_side := side ;
57236: LD_ADDR_OWVAR 20
57240: PUSH
57241: LD_VAR 0 16
57245: ST_TO_ADDR
// uc_nation := nation ;
57246: LD_ADDR_OWVAR 21
57250: PUSH
57251: LD_VAR 0 17
57255: ST_TO_ADDR
// if buildings then
57256: LD_VAR 0 18
57260: IFFALSE 58582
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57262: LD_ADDR_VAR 0 19
57266: PUSH
57267: LD_VAR 0 18
57271: PPUSH
57272: LD_INT 2
57274: PUSH
57275: LD_INT 30
57277: PUSH
57278: LD_INT 29
57280: PUSH
57281: EMPTY
57282: LIST
57283: LIST
57284: PUSH
57285: LD_INT 30
57287: PUSH
57288: LD_INT 30
57290: PUSH
57291: EMPTY
57292: LIST
57293: LIST
57294: PUSH
57295: EMPTY
57296: LIST
57297: LIST
57298: LIST
57299: PPUSH
57300: CALL_OW 72
57304: ST_TO_ADDR
// if tmp then
57305: LD_VAR 0 19
57309: IFFALSE 57357
// for i in tmp do
57311: LD_ADDR_VAR 0 8
57315: PUSH
57316: LD_VAR 0 19
57320: PUSH
57321: FOR_IN
57322: IFFALSE 57355
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57324: LD_VAR 0 8
57328: PPUSH
57329: CALL_OW 250
57333: PPUSH
57334: LD_VAR 0 8
57338: PPUSH
57339: CALL_OW 251
57343: PPUSH
57344: LD_VAR 0 16
57348: PPUSH
57349: CALL_OW 441
57353: GO 57321
57355: POP
57356: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57357: LD_VAR 0 18
57361: PPUSH
57362: LD_INT 2
57364: PUSH
57365: LD_INT 30
57367: PUSH
57368: LD_INT 32
57370: PUSH
57371: EMPTY
57372: LIST
57373: LIST
57374: PUSH
57375: LD_INT 30
57377: PUSH
57378: LD_INT 33
57380: PUSH
57381: EMPTY
57382: LIST
57383: LIST
57384: PUSH
57385: EMPTY
57386: LIST
57387: LIST
57388: LIST
57389: PPUSH
57390: CALL_OW 72
57394: IFFALSE 57482
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57396: LD_ADDR_VAR 0 8
57400: PUSH
57401: LD_VAR 0 18
57405: PPUSH
57406: LD_INT 2
57408: PUSH
57409: LD_INT 30
57411: PUSH
57412: LD_INT 32
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PUSH
57419: LD_INT 30
57421: PUSH
57422: LD_INT 33
57424: PUSH
57425: EMPTY
57426: LIST
57427: LIST
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: LIST
57433: PPUSH
57434: CALL_OW 72
57438: PUSH
57439: FOR_IN
57440: IFFALSE 57480
// begin if not GetBWeapon ( i ) then
57442: LD_VAR 0 8
57446: PPUSH
57447: CALL_OW 269
57451: NOT
57452: IFFALSE 57478
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57454: LD_VAR 0 8
57458: PPUSH
57459: LD_VAR 0 8
57463: PPUSH
57464: LD_VAR 0 2
57468: PPUSH
57469: CALL 58728 0 2
57473: PPUSH
57474: CALL_OW 431
// end ;
57478: GO 57439
57480: POP
57481: POP
// end ; for i = 1 to personel do
57482: LD_ADDR_VAR 0 8
57486: PUSH
57487: DOUBLE
57488: LD_INT 1
57490: DEC
57491: ST_TO_ADDR
57492: LD_VAR 0 6
57496: PUSH
57497: FOR_TO
57498: IFFALSE 58562
// begin if i > 4 then
57500: LD_VAR 0 8
57504: PUSH
57505: LD_INT 4
57507: GREATER
57508: IFFALSE 57512
// break ;
57510: GO 58562
// case i of 1 :
57512: LD_VAR 0 8
57516: PUSH
57517: LD_INT 1
57519: DOUBLE
57520: EQUAL
57521: IFTRUE 57525
57523: GO 57605
57525: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57526: LD_ADDR_VAR 0 12
57530: PUSH
57531: LD_VAR 0 18
57535: PPUSH
57536: LD_INT 22
57538: PUSH
57539: LD_VAR 0 16
57543: PUSH
57544: EMPTY
57545: LIST
57546: LIST
57547: PUSH
57548: LD_INT 58
57550: PUSH
57551: EMPTY
57552: LIST
57553: PUSH
57554: LD_INT 2
57556: PUSH
57557: LD_INT 30
57559: PUSH
57560: LD_INT 32
57562: PUSH
57563: EMPTY
57564: LIST
57565: LIST
57566: PUSH
57567: LD_INT 30
57569: PUSH
57570: LD_INT 4
57572: PUSH
57573: EMPTY
57574: LIST
57575: LIST
57576: PUSH
57577: LD_INT 30
57579: PUSH
57580: LD_INT 5
57582: PUSH
57583: EMPTY
57584: LIST
57585: LIST
57586: PUSH
57587: EMPTY
57588: LIST
57589: LIST
57590: LIST
57591: LIST
57592: PUSH
57593: EMPTY
57594: LIST
57595: LIST
57596: LIST
57597: PPUSH
57598: CALL_OW 72
57602: ST_TO_ADDR
57603: GO 57827
57605: LD_INT 2
57607: DOUBLE
57608: EQUAL
57609: IFTRUE 57613
57611: GO 57675
57613: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57614: LD_ADDR_VAR 0 12
57618: PUSH
57619: LD_VAR 0 18
57623: PPUSH
57624: LD_INT 22
57626: PUSH
57627: LD_VAR 0 16
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: PUSH
57636: LD_INT 2
57638: PUSH
57639: LD_INT 30
57641: PUSH
57642: LD_INT 0
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: PUSH
57649: LD_INT 30
57651: PUSH
57652: LD_INT 1
57654: PUSH
57655: EMPTY
57656: LIST
57657: LIST
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: LIST
57663: PUSH
57664: EMPTY
57665: LIST
57666: LIST
57667: PPUSH
57668: CALL_OW 72
57672: ST_TO_ADDR
57673: GO 57827
57675: LD_INT 3
57677: DOUBLE
57678: EQUAL
57679: IFTRUE 57683
57681: GO 57745
57683: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57684: LD_ADDR_VAR 0 12
57688: PUSH
57689: LD_VAR 0 18
57693: PPUSH
57694: LD_INT 22
57696: PUSH
57697: LD_VAR 0 16
57701: PUSH
57702: EMPTY
57703: LIST
57704: LIST
57705: PUSH
57706: LD_INT 2
57708: PUSH
57709: LD_INT 30
57711: PUSH
57712: LD_INT 2
57714: PUSH
57715: EMPTY
57716: LIST
57717: LIST
57718: PUSH
57719: LD_INT 30
57721: PUSH
57722: LD_INT 3
57724: PUSH
57725: EMPTY
57726: LIST
57727: LIST
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: LIST
57733: PUSH
57734: EMPTY
57735: LIST
57736: LIST
57737: PPUSH
57738: CALL_OW 72
57742: ST_TO_ADDR
57743: GO 57827
57745: LD_INT 4
57747: DOUBLE
57748: EQUAL
57749: IFTRUE 57753
57751: GO 57826
57753: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57754: LD_ADDR_VAR 0 12
57758: PUSH
57759: LD_VAR 0 18
57763: PPUSH
57764: LD_INT 22
57766: PUSH
57767: LD_VAR 0 16
57771: PUSH
57772: EMPTY
57773: LIST
57774: LIST
57775: PUSH
57776: LD_INT 2
57778: PUSH
57779: LD_INT 30
57781: PUSH
57782: LD_INT 6
57784: PUSH
57785: EMPTY
57786: LIST
57787: LIST
57788: PUSH
57789: LD_INT 30
57791: PUSH
57792: LD_INT 7
57794: PUSH
57795: EMPTY
57796: LIST
57797: LIST
57798: PUSH
57799: LD_INT 30
57801: PUSH
57802: LD_INT 8
57804: PUSH
57805: EMPTY
57806: LIST
57807: LIST
57808: PUSH
57809: EMPTY
57810: LIST
57811: LIST
57812: LIST
57813: LIST
57814: PUSH
57815: EMPTY
57816: LIST
57817: LIST
57818: PPUSH
57819: CALL_OW 72
57823: ST_TO_ADDR
57824: GO 57827
57826: POP
// if i = 1 then
57827: LD_VAR 0 8
57831: PUSH
57832: LD_INT 1
57834: EQUAL
57835: IFFALSE 57946
// begin tmp := [ ] ;
57837: LD_ADDR_VAR 0 19
57841: PUSH
57842: EMPTY
57843: ST_TO_ADDR
// for j in f do
57844: LD_ADDR_VAR 0 9
57848: PUSH
57849: LD_VAR 0 12
57853: PUSH
57854: FOR_IN
57855: IFFALSE 57928
// if GetBType ( j ) = b_bunker then
57857: LD_VAR 0 9
57861: PPUSH
57862: CALL_OW 266
57866: PUSH
57867: LD_INT 32
57869: EQUAL
57870: IFFALSE 57897
// tmp := Insert ( tmp , 1 , j ) else
57872: LD_ADDR_VAR 0 19
57876: PUSH
57877: LD_VAR 0 19
57881: PPUSH
57882: LD_INT 1
57884: PPUSH
57885: LD_VAR 0 9
57889: PPUSH
57890: CALL_OW 2
57894: ST_TO_ADDR
57895: GO 57926
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57897: LD_ADDR_VAR 0 19
57901: PUSH
57902: LD_VAR 0 19
57906: PPUSH
57907: LD_VAR 0 19
57911: PUSH
57912: LD_INT 1
57914: PLUS
57915: PPUSH
57916: LD_VAR 0 9
57920: PPUSH
57921: CALL_OW 2
57925: ST_TO_ADDR
57926: GO 57854
57928: POP
57929: POP
// if tmp then
57930: LD_VAR 0 19
57934: IFFALSE 57946
// f := tmp ;
57936: LD_ADDR_VAR 0 12
57940: PUSH
57941: LD_VAR 0 19
57945: ST_TO_ADDR
// end ; x := personel [ i ] ;
57946: LD_ADDR_VAR 0 13
57950: PUSH
57951: LD_VAR 0 6
57955: PUSH
57956: LD_VAR 0 8
57960: ARRAY
57961: ST_TO_ADDR
// if x = - 1 then
57962: LD_VAR 0 13
57966: PUSH
57967: LD_INT 1
57969: NEG
57970: EQUAL
57971: IFFALSE 58180
// begin for j in f do
57973: LD_ADDR_VAR 0 9
57977: PUSH
57978: LD_VAR 0 12
57982: PUSH
57983: FOR_IN
57984: IFFALSE 58176
// repeat InitHc ;
57986: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57990: LD_VAR 0 9
57994: PPUSH
57995: CALL_OW 266
57999: PUSH
58000: LD_INT 5
58002: EQUAL
58003: IFFALSE 58073
// begin if UnitsInside ( j ) < 3 then
58005: LD_VAR 0 9
58009: PPUSH
58010: CALL_OW 313
58014: PUSH
58015: LD_INT 3
58017: LESS
58018: IFFALSE 58054
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58020: LD_INT 0
58022: PPUSH
58023: LD_INT 5
58025: PUSH
58026: LD_INT 8
58028: PUSH
58029: LD_INT 9
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: LIST
58036: PUSH
58037: LD_VAR 0 17
58041: ARRAY
58042: PPUSH
58043: LD_VAR 0 4
58047: PPUSH
58048: CALL_OW 380
58052: GO 58071
// PrepareHuman ( false , i , skill ) ;
58054: LD_INT 0
58056: PPUSH
58057: LD_VAR 0 8
58061: PPUSH
58062: LD_VAR 0 4
58066: PPUSH
58067: CALL_OW 380
// end else
58071: GO 58090
// PrepareHuman ( false , i , skill ) ;
58073: LD_INT 0
58075: PPUSH
58076: LD_VAR 0 8
58080: PPUSH
58081: LD_VAR 0 4
58085: PPUSH
58086: CALL_OW 380
// un := CreateHuman ;
58090: LD_ADDR_VAR 0 14
58094: PUSH
58095: CALL_OW 44
58099: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58100: LD_ADDR_VAR 0 7
58104: PUSH
58105: LD_VAR 0 7
58109: PPUSH
58110: LD_INT 1
58112: PPUSH
58113: LD_VAR 0 14
58117: PPUSH
58118: CALL_OW 2
58122: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58123: LD_VAR 0 14
58127: PPUSH
58128: LD_VAR 0 9
58132: PPUSH
58133: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58137: LD_VAR 0 9
58141: PPUSH
58142: CALL_OW 313
58146: PUSH
58147: LD_INT 6
58149: EQUAL
58150: PUSH
58151: LD_VAR 0 9
58155: PPUSH
58156: CALL_OW 266
58160: PUSH
58161: LD_INT 32
58163: PUSH
58164: LD_INT 31
58166: PUSH
58167: EMPTY
58168: LIST
58169: LIST
58170: IN
58171: OR
58172: IFFALSE 57986
58174: GO 57983
58176: POP
58177: POP
// end else
58178: GO 58560
// for j = 1 to x do
58180: LD_ADDR_VAR 0 9
58184: PUSH
58185: DOUBLE
58186: LD_INT 1
58188: DEC
58189: ST_TO_ADDR
58190: LD_VAR 0 13
58194: PUSH
58195: FOR_TO
58196: IFFALSE 58558
// begin InitHc ;
58198: CALL_OW 19
// if not f then
58202: LD_VAR 0 12
58206: NOT
58207: IFFALSE 58296
// begin PrepareHuman ( false , i , skill ) ;
58209: LD_INT 0
58211: PPUSH
58212: LD_VAR 0 8
58216: PPUSH
58217: LD_VAR 0 4
58221: PPUSH
58222: CALL_OW 380
// un := CreateHuman ;
58226: LD_ADDR_VAR 0 14
58230: PUSH
58231: CALL_OW 44
58235: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58236: LD_ADDR_VAR 0 7
58240: PUSH
58241: LD_VAR 0 7
58245: PPUSH
58246: LD_INT 1
58248: PPUSH
58249: LD_VAR 0 14
58253: PPUSH
58254: CALL_OW 2
58258: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58259: LD_VAR 0 14
58263: PPUSH
58264: LD_VAR 0 1
58268: PPUSH
58269: CALL_OW 250
58273: PPUSH
58274: LD_VAR 0 1
58278: PPUSH
58279: CALL_OW 251
58283: PPUSH
58284: LD_INT 10
58286: PPUSH
58287: LD_INT 0
58289: PPUSH
58290: CALL_OW 50
// continue ;
58294: GO 58195
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58296: LD_VAR 0 12
58300: PUSH
58301: LD_INT 1
58303: ARRAY
58304: PPUSH
58305: CALL_OW 313
58309: PUSH
58310: LD_VAR 0 12
58314: PUSH
58315: LD_INT 1
58317: ARRAY
58318: PPUSH
58319: CALL_OW 266
58323: PUSH
58324: LD_INT 32
58326: PUSH
58327: LD_INT 31
58329: PUSH
58330: EMPTY
58331: LIST
58332: LIST
58333: IN
58334: AND
58335: PUSH
58336: LD_VAR 0 12
58340: PUSH
58341: LD_INT 1
58343: ARRAY
58344: PPUSH
58345: CALL_OW 313
58349: PUSH
58350: LD_INT 6
58352: EQUAL
58353: OR
58354: IFFALSE 58374
// f := Delete ( f , 1 ) ;
58356: LD_ADDR_VAR 0 12
58360: PUSH
58361: LD_VAR 0 12
58365: PPUSH
58366: LD_INT 1
58368: PPUSH
58369: CALL_OW 3
58373: ST_TO_ADDR
// if not f then
58374: LD_VAR 0 12
58378: NOT
58379: IFFALSE 58397
// begin x := x + 2 ;
58381: LD_ADDR_VAR 0 13
58385: PUSH
58386: LD_VAR 0 13
58390: PUSH
58391: LD_INT 2
58393: PLUS
58394: ST_TO_ADDR
// continue ;
58395: GO 58195
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58397: LD_VAR 0 12
58401: PUSH
58402: LD_INT 1
58404: ARRAY
58405: PPUSH
58406: CALL_OW 266
58410: PUSH
58411: LD_INT 5
58413: EQUAL
58414: IFFALSE 58488
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58416: LD_VAR 0 12
58420: PUSH
58421: LD_INT 1
58423: ARRAY
58424: PPUSH
58425: CALL_OW 313
58429: PUSH
58430: LD_INT 3
58432: LESS
58433: IFFALSE 58469
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58435: LD_INT 0
58437: PPUSH
58438: LD_INT 5
58440: PUSH
58441: LD_INT 8
58443: PUSH
58444: LD_INT 9
58446: PUSH
58447: EMPTY
58448: LIST
58449: LIST
58450: LIST
58451: PUSH
58452: LD_VAR 0 17
58456: ARRAY
58457: PPUSH
58458: LD_VAR 0 4
58462: PPUSH
58463: CALL_OW 380
58467: GO 58486
// PrepareHuman ( false , i , skill ) ;
58469: LD_INT 0
58471: PPUSH
58472: LD_VAR 0 8
58476: PPUSH
58477: LD_VAR 0 4
58481: PPUSH
58482: CALL_OW 380
// end else
58486: GO 58505
// PrepareHuman ( false , i , skill ) ;
58488: LD_INT 0
58490: PPUSH
58491: LD_VAR 0 8
58495: PPUSH
58496: LD_VAR 0 4
58500: PPUSH
58501: CALL_OW 380
// un := CreateHuman ;
58505: LD_ADDR_VAR 0 14
58509: PUSH
58510: CALL_OW 44
58514: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58515: LD_ADDR_VAR 0 7
58519: PUSH
58520: LD_VAR 0 7
58524: PPUSH
58525: LD_INT 1
58527: PPUSH
58528: LD_VAR 0 14
58532: PPUSH
58533: CALL_OW 2
58537: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58538: LD_VAR 0 14
58542: PPUSH
58543: LD_VAR 0 12
58547: PUSH
58548: LD_INT 1
58550: ARRAY
58551: PPUSH
58552: CALL_OW 52
// end ;
58556: GO 58195
58558: POP
58559: POP
// end ;
58560: GO 57497
58562: POP
58563: POP
// result := result ^ buildings ;
58564: LD_ADDR_VAR 0 7
58568: PUSH
58569: LD_VAR 0 7
58573: PUSH
58574: LD_VAR 0 18
58578: ADD
58579: ST_TO_ADDR
// end else
58580: GO 58723
// begin for i = 1 to personel do
58582: LD_ADDR_VAR 0 8
58586: PUSH
58587: DOUBLE
58588: LD_INT 1
58590: DEC
58591: ST_TO_ADDR
58592: LD_VAR 0 6
58596: PUSH
58597: FOR_TO
58598: IFFALSE 58721
// begin if i > 4 then
58600: LD_VAR 0 8
58604: PUSH
58605: LD_INT 4
58607: GREATER
58608: IFFALSE 58612
// break ;
58610: GO 58721
// x := personel [ i ] ;
58612: LD_ADDR_VAR 0 13
58616: PUSH
58617: LD_VAR 0 6
58621: PUSH
58622: LD_VAR 0 8
58626: ARRAY
58627: ST_TO_ADDR
// if x = - 1 then
58628: LD_VAR 0 13
58632: PUSH
58633: LD_INT 1
58635: NEG
58636: EQUAL
58637: IFFALSE 58641
// continue ;
58639: GO 58597
// PrepareHuman ( false , i , skill ) ;
58641: LD_INT 0
58643: PPUSH
58644: LD_VAR 0 8
58648: PPUSH
58649: LD_VAR 0 4
58653: PPUSH
58654: CALL_OW 380
// un := CreateHuman ;
58658: LD_ADDR_VAR 0 14
58662: PUSH
58663: CALL_OW 44
58667: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58668: LD_VAR 0 14
58672: PPUSH
58673: LD_VAR 0 1
58677: PPUSH
58678: CALL_OW 250
58682: PPUSH
58683: LD_VAR 0 1
58687: PPUSH
58688: CALL_OW 251
58692: PPUSH
58693: LD_INT 10
58695: PPUSH
58696: LD_INT 0
58698: PPUSH
58699: CALL_OW 50
// result := result ^ un ;
58703: LD_ADDR_VAR 0 7
58707: PUSH
58708: LD_VAR 0 7
58712: PUSH
58713: LD_VAR 0 14
58717: ADD
58718: ST_TO_ADDR
// end ;
58719: GO 58597
58721: POP
58722: POP
// end ; end ;
58723: LD_VAR 0 7
58727: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58728: LD_INT 0
58730: PPUSH
58731: PPUSH
58732: PPUSH
58733: PPUSH
58734: PPUSH
58735: PPUSH
58736: PPUSH
58737: PPUSH
58738: PPUSH
58739: PPUSH
58740: PPUSH
58741: PPUSH
58742: PPUSH
58743: PPUSH
58744: PPUSH
58745: PPUSH
// result := false ;
58746: LD_ADDR_VAR 0 3
58750: PUSH
58751: LD_INT 0
58753: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58754: LD_VAR 0 1
58758: NOT
58759: PUSH
58760: LD_VAR 0 1
58764: PPUSH
58765: CALL_OW 266
58769: PUSH
58770: LD_INT 32
58772: PUSH
58773: LD_INT 33
58775: PUSH
58776: EMPTY
58777: LIST
58778: LIST
58779: IN
58780: NOT
58781: OR
58782: IFFALSE 58786
// exit ;
58784: GO 59895
// nat := GetNation ( tower ) ;
58786: LD_ADDR_VAR 0 12
58790: PUSH
58791: LD_VAR 0 1
58795: PPUSH
58796: CALL_OW 248
58800: ST_TO_ADDR
// side := GetSide ( tower ) ;
58801: LD_ADDR_VAR 0 16
58805: PUSH
58806: LD_VAR 0 1
58810: PPUSH
58811: CALL_OW 255
58815: ST_TO_ADDR
// x := GetX ( tower ) ;
58816: LD_ADDR_VAR 0 10
58820: PUSH
58821: LD_VAR 0 1
58825: PPUSH
58826: CALL_OW 250
58830: ST_TO_ADDR
// y := GetY ( tower ) ;
58831: LD_ADDR_VAR 0 11
58835: PUSH
58836: LD_VAR 0 1
58840: PPUSH
58841: CALL_OW 251
58845: ST_TO_ADDR
// if not x or not y then
58846: LD_VAR 0 10
58850: NOT
58851: PUSH
58852: LD_VAR 0 11
58856: NOT
58857: OR
58858: IFFALSE 58862
// exit ;
58860: GO 59895
// weapon := 0 ;
58862: LD_ADDR_VAR 0 18
58866: PUSH
58867: LD_INT 0
58869: ST_TO_ADDR
// fac_list := [ ] ;
58870: LD_ADDR_VAR 0 17
58874: PUSH
58875: EMPTY
58876: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58877: LD_ADDR_VAR 0 6
58881: PUSH
58882: LD_VAR 0 1
58886: PPUSH
58887: CALL_OW 274
58891: PPUSH
58892: LD_VAR 0 2
58896: PPUSH
58897: LD_INT 0
58899: PPUSH
58900: CALL 56466 0 3
58904: PPUSH
58905: LD_INT 30
58907: PUSH
58908: LD_INT 3
58910: PUSH
58911: EMPTY
58912: LIST
58913: LIST
58914: PPUSH
58915: CALL_OW 72
58919: ST_TO_ADDR
// if not factories then
58920: LD_VAR 0 6
58924: NOT
58925: IFFALSE 58929
// exit ;
58927: GO 59895
// for i in factories do
58929: LD_ADDR_VAR 0 8
58933: PUSH
58934: LD_VAR 0 6
58938: PUSH
58939: FOR_IN
58940: IFFALSE 58965
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58942: LD_ADDR_VAR 0 17
58946: PUSH
58947: LD_VAR 0 17
58951: PUSH
58952: LD_VAR 0 8
58956: PPUSH
58957: CALL_OW 478
58961: UNION
58962: ST_TO_ADDR
58963: GO 58939
58965: POP
58966: POP
// if not fac_list then
58967: LD_VAR 0 17
58971: NOT
58972: IFFALSE 58976
// exit ;
58974: GO 59895
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58976: LD_ADDR_VAR 0 5
58980: PUSH
58981: LD_INT 4
58983: PUSH
58984: LD_INT 5
58986: PUSH
58987: LD_INT 9
58989: PUSH
58990: LD_INT 10
58992: PUSH
58993: LD_INT 6
58995: PUSH
58996: LD_INT 7
58998: PUSH
58999: LD_INT 11
59001: PUSH
59002: EMPTY
59003: LIST
59004: LIST
59005: LIST
59006: LIST
59007: LIST
59008: LIST
59009: LIST
59010: PUSH
59011: LD_INT 27
59013: PUSH
59014: LD_INT 28
59016: PUSH
59017: LD_INT 26
59019: PUSH
59020: LD_INT 30
59022: PUSH
59023: EMPTY
59024: LIST
59025: LIST
59026: LIST
59027: LIST
59028: PUSH
59029: LD_INT 43
59031: PUSH
59032: LD_INT 44
59034: PUSH
59035: LD_INT 46
59037: PUSH
59038: LD_INT 45
59040: PUSH
59041: LD_INT 47
59043: PUSH
59044: LD_INT 49
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: LIST
59051: LIST
59052: LIST
59053: LIST
59054: PUSH
59055: EMPTY
59056: LIST
59057: LIST
59058: LIST
59059: PUSH
59060: LD_VAR 0 12
59064: ARRAY
59065: ST_TO_ADDR
// list := list isect fac_list ;
59066: LD_ADDR_VAR 0 5
59070: PUSH
59071: LD_VAR 0 5
59075: PUSH
59076: LD_VAR 0 17
59080: ISECT
59081: ST_TO_ADDR
// if not list then
59082: LD_VAR 0 5
59086: NOT
59087: IFFALSE 59091
// exit ;
59089: GO 59895
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59091: LD_VAR 0 12
59095: PUSH
59096: LD_INT 3
59098: EQUAL
59099: PUSH
59100: LD_INT 49
59102: PUSH
59103: LD_VAR 0 5
59107: IN
59108: AND
59109: PUSH
59110: LD_INT 31
59112: PPUSH
59113: LD_VAR 0 16
59117: PPUSH
59118: CALL_OW 321
59122: PUSH
59123: LD_INT 2
59125: EQUAL
59126: AND
59127: IFFALSE 59187
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59129: LD_INT 22
59131: PUSH
59132: LD_VAR 0 16
59136: PUSH
59137: EMPTY
59138: LIST
59139: LIST
59140: PUSH
59141: LD_INT 35
59143: PUSH
59144: LD_INT 49
59146: PUSH
59147: EMPTY
59148: LIST
59149: LIST
59150: PUSH
59151: LD_INT 91
59153: PUSH
59154: LD_VAR 0 1
59158: PUSH
59159: LD_INT 10
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: LIST
59166: PUSH
59167: EMPTY
59168: LIST
59169: LIST
59170: LIST
59171: PPUSH
59172: CALL_OW 69
59176: NOT
59177: IFFALSE 59187
// weapon := ru_time_lapser ;
59179: LD_ADDR_VAR 0 18
59183: PUSH
59184: LD_INT 49
59186: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59187: LD_VAR 0 12
59191: PUSH
59192: LD_INT 1
59194: PUSH
59195: LD_INT 2
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: IN
59202: PUSH
59203: LD_INT 11
59205: PUSH
59206: LD_VAR 0 5
59210: IN
59211: PUSH
59212: LD_INT 30
59214: PUSH
59215: LD_VAR 0 5
59219: IN
59220: OR
59221: AND
59222: PUSH
59223: LD_INT 6
59225: PPUSH
59226: LD_VAR 0 16
59230: PPUSH
59231: CALL_OW 321
59235: PUSH
59236: LD_INT 2
59238: EQUAL
59239: AND
59240: IFFALSE 59405
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59242: LD_INT 22
59244: PUSH
59245: LD_VAR 0 16
59249: PUSH
59250: EMPTY
59251: LIST
59252: LIST
59253: PUSH
59254: LD_INT 2
59256: PUSH
59257: LD_INT 35
59259: PUSH
59260: LD_INT 11
59262: PUSH
59263: EMPTY
59264: LIST
59265: LIST
59266: PUSH
59267: LD_INT 35
59269: PUSH
59270: LD_INT 30
59272: PUSH
59273: EMPTY
59274: LIST
59275: LIST
59276: PUSH
59277: EMPTY
59278: LIST
59279: LIST
59280: LIST
59281: PUSH
59282: LD_INT 91
59284: PUSH
59285: LD_VAR 0 1
59289: PUSH
59290: LD_INT 18
59292: PUSH
59293: EMPTY
59294: LIST
59295: LIST
59296: LIST
59297: PUSH
59298: EMPTY
59299: LIST
59300: LIST
59301: LIST
59302: PPUSH
59303: CALL_OW 69
59307: NOT
59308: PUSH
59309: LD_INT 22
59311: PUSH
59312: LD_VAR 0 16
59316: PUSH
59317: EMPTY
59318: LIST
59319: LIST
59320: PUSH
59321: LD_INT 2
59323: PUSH
59324: LD_INT 30
59326: PUSH
59327: LD_INT 32
59329: PUSH
59330: EMPTY
59331: LIST
59332: LIST
59333: PUSH
59334: LD_INT 30
59336: PUSH
59337: LD_INT 33
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: PUSH
59344: EMPTY
59345: LIST
59346: LIST
59347: LIST
59348: PUSH
59349: LD_INT 91
59351: PUSH
59352: LD_VAR 0 1
59356: PUSH
59357: LD_INT 12
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: LIST
59364: PUSH
59365: EMPTY
59366: LIST
59367: LIST
59368: LIST
59369: PUSH
59370: EMPTY
59371: LIST
59372: PPUSH
59373: CALL_OW 69
59377: PUSH
59378: LD_INT 2
59380: GREATER
59381: AND
59382: IFFALSE 59405
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59384: LD_ADDR_VAR 0 18
59388: PUSH
59389: LD_INT 11
59391: PUSH
59392: LD_INT 30
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PUSH
59399: LD_VAR 0 12
59403: ARRAY
59404: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59405: LD_VAR 0 18
59409: NOT
59410: PUSH
59411: LD_INT 40
59413: PPUSH
59414: LD_VAR 0 16
59418: PPUSH
59419: CALL_OW 321
59423: PUSH
59424: LD_INT 2
59426: EQUAL
59427: AND
59428: PUSH
59429: LD_INT 7
59431: PUSH
59432: LD_VAR 0 5
59436: IN
59437: PUSH
59438: LD_INT 28
59440: PUSH
59441: LD_VAR 0 5
59445: IN
59446: OR
59447: PUSH
59448: LD_INT 45
59450: PUSH
59451: LD_VAR 0 5
59455: IN
59456: OR
59457: AND
59458: IFFALSE 59712
// begin hex := GetHexInfo ( x , y ) ;
59460: LD_ADDR_VAR 0 4
59464: PUSH
59465: LD_VAR 0 10
59469: PPUSH
59470: LD_VAR 0 11
59474: PPUSH
59475: CALL_OW 546
59479: ST_TO_ADDR
// if hex [ 1 ] then
59480: LD_VAR 0 4
59484: PUSH
59485: LD_INT 1
59487: ARRAY
59488: IFFALSE 59492
// exit ;
59490: GO 59895
// height := hex [ 2 ] ;
59492: LD_ADDR_VAR 0 15
59496: PUSH
59497: LD_VAR 0 4
59501: PUSH
59502: LD_INT 2
59504: ARRAY
59505: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59506: LD_ADDR_VAR 0 14
59510: PUSH
59511: LD_INT 0
59513: PUSH
59514: LD_INT 2
59516: PUSH
59517: LD_INT 3
59519: PUSH
59520: LD_INT 5
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: LIST
59527: LIST
59528: ST_TO_ADDR
// for i in tmp do
59529: LD_ADDR_VAR 0 8
59533: PUSH
59534: LD_VAR 0 14
59538: PUSH
59539: FOR_IN
59540: IFFALSE 59710
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59542: LD_ADDR_VAR 0 9
59546: PUSH
59547: LD_VAR 0 10
59551: PPUSH
59552: LD_VAR 0 8
59556: PPUSH
59557: LD_INT 5
59559: PPUSH
59560: CALL_OW 272
59564: PUSH
59565: LD_VAR 0 11
59569: PPUSH
59570: LD_VAR 0 8
59574: PPUSH
59575: LD_INT 5
59577: PPUSH
59578: CALL_OW 273
59582: PUSH
59583: EMPTY
59584: LIST
59585: LIST
59586: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59587: LD_VAR 0 9
59591: PUSH
59592: LD_INT 1
59594: ARRAY
59595: PPUSH
59596: LD_VAR 0 9
59600: PUSH
59601: LD_INT 2
59603: ARRAY
59604: PPUSH
59605: CALL_OW 488
59609: IFFALSE 59708
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59611: LD_ADDR_VAR 0 4
59615: PUSH
59616: LD_VAR 0 9
59620: PUSH
59621: LD_INT 1
59623: ARRAY
59624: PPUSH
59625: LD_VAR 0 9
59629: PUSH
59630: LD_INT 2
59632: ARRAY
59633: PPUSH
59634: CALL_OW 546
59638: ST_TO_ADDR
// if hex [ 1 ] then
59639: LD_VAR 0 4
59643: PUSH
59644: LD_INT 1
59646: ARRAY
59647: IFFALSE 59651
// continue ;
59649: GO 59539
// h := hex [ 2 ] ;
59651: LD_ADDR_VAR 0 13
59655: PUSH
59656: LD_VAR 0 4
59660: PUSH
59661: LD_INT 2
59663: ARRAY
59664: ST_TO_ADDR
// if h + 7 < height then
59665: LD_VAR 0 13
59669: PUSH
59670: LD_INT 7
59672: PLUS
59673: PUSH
59674: LD_VAR 0 15
59678: LESS
59679: IFFALSE 59708
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59681: LD_ADDR_VAR 0 18
59685: PUSH
59686: LD_INT 7
59688: PUSH
59689: LD_INT 28
59691: PUSH
59692: LD_INT 45
59694: PUSH
59695: EMPTY
59696: LIST
59697: LIST
59698: LIST
59699: PUSH
59700: LD_VAR 0 12
59704: ARRAY
59705: ST_TO_ADDR
// break ;
59706: GO 59710
// end ; end ; end ;
59708: GO 59539
59710: POP
59711: POP
// end ; if not weapon then
59712: LD_VAR 0 18
59716: NOT
59717: IFFALSE 59777
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59719: LD_ADDR_VAR 0 5
59723: PUSH
59724: LD_VAR 0 5
59728: PUSH
59729: LD_INT 11
59731: PUSH
59732: LD_INT 30
59734: PUSH
59735: LD_INT 49
59737: PUSH
59738: EMPTY
59739: LIST
59740: LIST
59741: LIST
59742: DIFF
59743: ST_TO_ADDR
// if not list then
59744: LD_VAR 0 5
59748: NOT
59749: IFFALSE 59753
// exit ;
59751: GO 59895
// weapon := list [ rand ( 1 , list ) ] ;
59753: LD_ADDR_VAR 0 18
59757: PUSH
59758: LD_VAR 0 5
59762: PUSH
59763: LD_INT 1
59765: PPUSH
59766: LD_VAR 0 5
59770: PPUSH
59771: CALL_OW 12
59775: ARRAY
59776: ST_TO_ADDR
// end ; if weapon then
59777: LD_VAR 0 18
59781: IFFALSE 59895
// begin tmp := CostOfWeapon ( weapon ) ;
59783: LD_ADDR_VAR 0 14
59787: PUSH
59788: LD_VAR 0 18
59792: PPUSH
59793: CALL_OW 451
59797: ST_TO_ADDR
// j := GetBase ( tower ) ;
59798: LD_ADDR_VAR 0 9
59802: PUSH
59803: LD_VAR 0 1
59807: PPUSH
59808: CALL_OW 274
59812: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59813: LD_VAR 0 9
59817: PPUSH
59818: LD_INT 1
59820: PPUSH
59821: CALL_OW 275
59825: PUSH
59826: LD_VAR 0 14
59830: PUSH
59831: LD_INT 1
59833: ARRAY
59834: GREATEREQUAL
59835: PUSH
59836: LD_VAR 0 9
59840: PPUSH
59841: LD_INT 2
59843: PPUSH
59844: CALL_OW 275
59848: PUSH
59849: LD_VAR 0 14
59853: PUSH
59854: LD_INT 2
59856: ARRAY
59857: GREATEREQUAL
59858: AND
59859: PUSH
59860: LD_VAR 0 9
59864: PPUSH
59865: LD_INT 3
59867: PPUSH
59868: CALL_OW 275
59872: PUSH
59873: LD_VAR 0 14
59877: PUSH
59878: LD_INT 3
59880: ARRAY
59881: GREATEREQUAL
59882: AND
59883: IFFALSE 59895
// result := weapon ;
59885: LD_ADDR_VAR 0 3
59889: PUSH
59890: LD_VAR 0 18
59894: ST_TO_ADDR
// end ; end ;
59895: LD_VAR 0 3
59899: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59900: LD_INT 0
59902: PPUSH
59903: PPUSH
// result := true ;
59904: LD_ADDR_VAR 0 3
59908: PUSH
59909: LD_INT 1
59911: ST_TO_ADDR
// if array1 = array2 then
59912: LD_VAR 0 1
59916: PUSH
59917: LD_VAR 0 2
59921: EQUAL
59922: IFFALSE 59982
// begin for i = 1 to array1 do
59924: LD_ADDR_VAR 0 4
59928: PUSH
59929: DOUBLE
59930: LD_INT 1
59932: DEC
59933: ST_TO_ADDR
59934: LD_VAR 0 1
59938: PUSH
59939: FOR_TO
59940: IFFALSE 59978
// if array1 [ i ] <> array2 [ i ] then
59942: LD_VAR 0 1
59946: PUSH
59947: LD_VAR 0 4
59951: ARRAY
59952: PUSH
59953: LD_VAR 0 2
59957: PUSH
59958: LD_VAR 0 4
59962: ARRAY
59963: NONEQUAL
59964: IFFALSE 59976
// begin result := false ;
59966: LD_ADDR_VAR 0 3
59970: PUSH
59971: LD_INT 0
59973: ST_TO_ADDR
// break ;
59974: GO 59978
// end ;
59976: GO 59939
59978: POP
59979: POP
// end else
59980: GO 59990
// result := false ;
59982: LD_ADDR_VAR 0 3
59986: PUSH
59987: LD_INT 0
59989: ST_TO_ADDR
// end ;
59990: LD_VAR 0 3
59994: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59995: LD_INT 0
59997: PPUSH
59998: PPUSH
// if not array1 or not array2 then
59999: LD_VAR 0 1
60003: NOT
60004: PUSH
60005: LD_VAR 0 2
60009: NOT
60010: OR
60011: IFFALSE 60015
// exit ;
60013: GO 60079
// result := true ;
60015: LD_ADDR_VAR 0 3
60019: PUSH
60020: LD_INT 1
60022: ST_TO_ADDR
// for i = 1 to array1 do
60023: LD_ADDR_VAR 0 4
60027: PUSH
60028: DOUBLE
60029: LD_INT 1
60031: DEC
60032: ST_TO_ADDR
60033: LD_VAR 0 1
60037: PUSH
60038: FOR_TO
60039: IFFALSE 60077
// if array1 [ i ] <> array2 [ i ] then
60041: LD_VAR 0 1
60045: PUSH
60046: LD_VAR 0 4
60050: ARRAY
60051: PUSH
60052: LD_VAR 0 2
60056: PUSH
60057: LD_VAR 0 4
60061: ARRAY
60062: NONEQUAL
60063: IFFALSE 60075
// begin result := false ;
60065: LD_ADDR_VAR 0 3
60069: PUSH
60070: LD_INT 0
60072: ST_TO_ADDR
// break ;
60073: GO 60077
// end ;
60075: GO 60038
60077: POP
60078: POP
// end ;
60079: LD_VAR 0 3
60083: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60084: LD_INT 0
60086: PPUSH
60087: PPUSH
60088: PPUSH
// pom := GetBase ( fac ) ;
60089: LD_ADDR_VAR 0 5
60093: PUSH
60094: LD_VAR 0 1
60098: PPUSH
60099: CALL_OW 274
60103: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60104: LD_ADDR_VAR 0 4
60108: PUSH
60109: LD_VAR 0 2
60113: PUSH
60114: LD_INT 1
60116: ARRAY
60117: PPUSH
60118: LD_VAR 0 2
60122: PUSH
60123: LD_INT 2
60125: ARRAY
60126: PPUSH
60127: LD_VAR 0 2
60131: PUSH
60132: LD_INT 3
60134: ARRAY
60135: PPUSH
60136: LD_VAR 0 2
60140: PUSH
60141: LD_INT 4
60143: ARRAY
60144: PPUSH
60145: CALL_OW 449
60149: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60150: LD_ADDR_VAR 0 3
60154: PUSH
60155: LD_VAR 0 5
60159: PPUSH
60160: LD_INT 1
60162: PPUSH
60163: CALL_OW 275
60167: PUSH
60168: LD_VAR 0 4
60172: PUSH
60173: LD_INT 1
60175: ARRAY
60176: GREATEREQUAL
60177: PUSH
60178: LD_VAR 0 5
60182: PPUSH
60183: LD_INT 2
60185: PPUSH
60186: CALL_OW 275
60190: PUSH
60191: LD_VAR 0 4
60195: PUSH
60196: LD_INT 2
60198: ARRAY
60199: GREATEREQUAL
60200: AND
60201: PUSH
60202: LD_VAR 0 5
60206: PPUSH
60207: LD_INT 3
60209: PPUSH
60210: CALL_OW 275
60214: PUSH
60215: LD_VAR 0 4
60219: PUSH
60220: LD_INT 3
60222: ARRAY
60223: GREATEREQUAL
60224: AND
60225: ST_TO_ADDR
// end ;
60226: LD_VAR 0 3
60230: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60231: LD_INT 0
60233: PPUSH
60234: PPUSH
60235: PPUSH
60236: PPUSH
// pom := GetBase ( building ) ;
60237: LD_ADDR_VAR 0 3
60241: PUSH
60242: LD_VAR 0 1
60246: PPUSH
60247: CALL_OW 274
60251: ST_TO_ADDR
// if not pom then
60252: LD_VAR 0 3
60256: NOT
60257: IFFALSE 60261
// exit ;
60259: GO 60431
// btype := GetBType ( building ) ;
60261: LD_ADDR_VAR 0 5
60265: PUSH
60266: LD_VAR 0 1
60270: PPUSH
60271: CALL_OW 266
60275: ST_TO_ADDR
// if btype = b_armoury then
60276: LD_VAR 0 5
60280: PUSH
60281: LD_INT 4
60283: EQUAL
60284: IFFALSE 60294
// btype := b_barracks ;
60286: LD_ADDR_VAR 0 5
60290: PUSH
60291: LD_INT 5
60293: ST_TO_ADDR
// if btype = b_depot then
60294: LD_VAR 0 5
60298: PUSH
60299: LD_INT 0
60301: EQUAL
60302: IFFALSE 60312
// btype := b_warehouse ;
60304: LD_ADDR_VAR 0 5
60308: PUSH
60309: LD_INT 1
60311: ST_TO_ADDR
// if btype = b_workshop then
60312: LD_VAR 0 5
60316: PUSH
60317: LD_INT 2
60319: EQUAL
60320: IFFALSE 60330
// btype := b_factory ;
60322: LD_ADDR_VAR 0 5
60326: PUSH
60327: LD_INT 3
60329: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60330: LD_ADDR_VAR 0 4
60334: PUSH
60335: LD_VAR 0 5
60339: PPUSH
60340: LD_VAR 0 1
60344: PPUSH
60345: CALL_OW 248
60349: PPUSH
60350: CALL_OW 450
60354: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60355: LD_ADDR_VAR 0 2
60359: PUSH
60360: LD_VAR 0 3
60364: PPUSH
60365: LD_INT 1
60367: PPUSH
60368: CALL_OW 275
60372: PUSH
60373: LD_VAR 0 4
60377: PUSH
60378: LD_INT 1
60380: ARRAY
60381: GREATEREQUAL
60382: PUSH
60383: LD_VAR 0 3
60387: PPUSH
60388: LD_INT 2
60390: PPUSH
60391: CALL_OW 275
60395: PUSH
60396: LD_VAR 0 4
60400: PUSH
60401: LD_INT 2
60403: ARRAY
60404: GREATEREQUAL
60405: AND
60406: PUSH
60407: LD_VAR 0 3
60411: PPUSH
60412: LD_INT 3
60414: PPUSH
60415: CALL_OW 275
60419: PUSH
60420: LD_VAR 0 4
60424: PUSH
60425: LD_INT 3
60427: ARRAY
60428: GREATEREQUAL
60429: AND
60430: ST_TO_ADDR
// end ;
60431: LD_VAR 0 2
60435: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60436: LD_INT 0
60438: PPUSH
60439: PPUSH
60440: PPUSH
// pom := GetBase ( building ) ;
60441: LD_ADDR_VAR 0 4
60445: PUSH
60446: LD_VAR 0 1
60450: PPUSH
60451: CALL_OW 274
60455: ST_TO_ADDR
// if not pom then
60456: LD_VAR 0 4
60460: NOT
60461: IFFALSE 60465
// exit ;
60463: GO 60566
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60465: LD_ADDR_VAR 0 5
60469: PUSH
60470: LD_VAR 0 2
60474: PPUSH
60475: LD_VAR 0 1
60479: PPUSH
60480: CALL_OW 248
60484: PPUSH
60485: CALL_OW 450
60489: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60490: LD_ADDR_VAR 0 3
60494: PUSH
60495: LD_VAR 0 4
60499: PPUSH
60500: LD_INT 1
60502: PPUSH
60503: CALL_OW 275
60507: PUSH
60508: LD_VAR 0 5
60512: PUSH
60513: LD_INT 1
60515: ARRAY
60516: GREATEREQUAL
60517: PUSH
60518: LD_VAR 0 4
60522: PPUSH
60523: LD_INT 2
60525: PPUSH
60526: CALL_OW 275
60530: PUSH
60531: LD_VAR 0 5
60535: PUSH
60536: LD_INT 2
60538: ARRAY
60539: GREATEREQUAL
60540: AND
60541: PUSH
60542: LD_VAR 0 4
60546: PPUSH
60547: LD_INT 3
60549: PPUSH
60550: CALL_OW 275
60554: PUSH
60555: LD_VAR 0 5
60559: PUSH
60560: LD_INT 3
60562: ARRAY
60563: GREATEREQUAL
60564: AND
60565: ST_TO_ADDR
// end ;
60566: LD_VAR 0 3
60570: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60571: LD_INT 0
60573: PPUSH
60574: PPUSH
60575: PPUSH
60576: PPUSH
60577: PPUSH
60578: PPUSH
60579: PPUSH
60580: PPUSH
60581: PPUSH
60582: PPUSH
60583: PPUSH
// result := false ;
60584: LD_ADDR_VAR 0 8
60588: PUSH
60589: LD_INT 0
60591: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60592: LD_VAR 0 5
60596: NOT
60597: PUSH
60598: LD_VAR 0 1
60602: NOT
60603: OR
60604: PUSH
60605: LD_VAR 0 2
60609: NOT
60610: OR
60611: PUSH
60612: LD_VAR 0 3
60616: NOT
60617: OR
60618: IFFALSE 60622
// exit ;
60620: GO 61436
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60622: LD_ADDR_VAR 0 14
60626: PUSH
60627: LD_VAR 0 1
60631: PPUSH
60632: LD_VAR 0 2
60636: PPUSH
60637: LD_VAR 0 3
60641: PPUSH
60642: LD_VAR 0 4
60646: PPUSH
60647: LD_VAR 0 5
60651: PUSH
60652: LD_INT 1
60654: ARRAY
60655: PPUSH
60656: CALL_OW 248
60660: PPUSH
60661: LD_INT 0
60663: PPUSH
60664: CALL 62673 0 6
60668: ST_TO_ADDR
// if not hexes then
60669: LD_VAR 0 14
60673: NOT
60674: IFFALSE 60678
// exit ;
60676: GO 61436
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60678: LD_ADDR_VAR 0 17
60682: PUSH
60683: LD_VAR 0 5
60687: PPUSH
60688: LD_INT 22
60690: PUSH
60691: LD_VAR 0 13
60695: PPUSH
60696: CALL_OW 255
60700: PUSH
60701: EMPTY
60702: LIST
60703: LIST
60704: PUSH
60705: LD_INT 2
60707: PUSH
60708: LD_INT 30
60710: PUSH
60711: LD_INT 0
60713: PUSH
60714: EMPTY
60715: LIST
60716: LIST
60717: PUSH
60718: LD_INT 30
60720: PUSH
60721: LD_INT 1
60723: PUSH
60724: EMPTY
60725: LIST
60726: LIST
60727: PUSH
60728: EMPTY
60729: LIST
60730: LIST
60731: LIST
60732: PUSH
60733: EMPTY
60734: LIST
60735: LIST
60736: PPUSH
60737: CALL_OW 72
60741: ST_TO_ADDR
// for i = 1 to hexes do
60742: LD_ADDR_VAR 0 9
60746: PUSH
60747: DOUBLE
60748: LD_INT 1
60750: DEC
60751: ST_TO_ADDR
60752: LD_VAR 0 14
60756: PUSH
60757: FOR_TO
60758: IFFALSE 61434
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60760: LD_ADDR_VAR 0 13
60764: PUSH
60765: LD_VAR 0 14
60769: PUSH
60770: LD_VAR 0 9
60774: ARRAY
60775: PUSH
60776: LD_INT 1
60778: ARRAY
60779: PPUSH
60780: LD_VAR 0 14
60784: PUSH
60785: LD_VAR 0 9
60789: ARRAY
60790: PUSH
60791: LD_INT 2
60793: ARRAY
60794: PPUSH
60795: CALL_OW 428
60799: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60800: LD_VAR 0 14
60804: PUSH
60805: LD_VAR 0 9
60809: ARRAY
60810: PUSH
60811: LD_INT 1
60813: ARRAY
60814: PPUSH
60815: LD_VAR 0 14
60819: PUSH
60820: LD_VAR 0 9
60824: ARRAY
60825: PUSH
60826: LD_INT 2
60828: ARRAY
60829: PPUSH
60830: CALL_OW 351
60834: PUSH
60835: LD_VAR 0 14
60839: PUSH
60840: LD_VAR 0 9
60844: ARRAY
60845: PUSH
60846: LD_INT 1
60848: ARRAY
60849: PPUSH
60850: LD_VAR 0 14
60854: PUSH
60855: LD_VAR 0 9
60859: ARRAY
60860: PUSH
60861: LD_INT 2
60863: ARRAY
60864: PPUSH
60865: CALL_OW 488
60869: NOT
60870: OR
60871: PUSH
60872: LD_VAR 0 13
60876: PPUSH
60877: CALL_OW 247
60881: PUSH
60882: LD_INT 3
60884: EQUAL
60885: OR
60886: IFFALSE 60892
// exit ;
60888: POP
60889: POP
60890: GO 61436
// if not tmp then
60892: LD_VAR 0 13
60896: NOT
60897: IFFALSE 60901
// continue ;
60899: GO 60757
// result := true ;
60901: LD_ADDR_VAR 0 8
60905: PUSH
60906: LD_INT 1
60908: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60909: LD_VAR 0 6
60913: PUSH
60914: LD_VAR 0 13
60918: PPUSH
60919: CALL_OW 247
60923: PUSH
60924: LD_INT 2
60926: EQUAL
60927: AND
60928: PUSH
60929: LD_VAR 0 13
60933: PPUSH
60934: CALL_OW 263
60938: PUSH
60939: LD_INT 1
60941: EQUAL
60942: AND
60943: IFFALSE 61107
// begin if IsDrivenBy ( tmp ) then
60945: LD_VAR 0 13
60949: PPUSH
60950: CALL_OW 311
60954: IFFALSE 60958
// continue ;
60956: GO 60757
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60958: LD_VAR 0 6
60962: PPUSH
60963: LD_INT 3
60965: PUSH
60966: LD_INT 60
60968: PUSH
60969: EMPTY
60970: LIST
60971: PUSH
60972: EMPTY
60973: LIST
60974: LIST
60975: PUSH
60976: LD_INT 3
60978: PUSH
60979: LD_INT 55
60981: PUSH
60982: EMPTY
60983: LIST
60984: PUSH
60985: EMPTY
60986: LIST
60987: LIST
60988: PUSH
60989: EMPTY
60990: LIST
60991: LIST
60992: PPUSH
60993: CALL_OW 72
60997: IFFALSE 61105
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60999: LD_ADDR_VAR 0 18
61003: PUSH
61004: LD_VAR 0 6
61008: PPUSH
61009: LD_INT 3
61011: PUSH
61012: LD_INT 60
61014: PUSH
61015: EMPTY
61016: LIST
61017: PUSH
61018: EMPTY
61019: LIST
61020: LIST
61021: PUSH
61022: LD_INT 3
61024: PUSH
61025: LD_INT 55
61027: PUSH
61028: EMPTY
61029: LIST
61030: PUSH
61031: EMPTY
61032: LIST
61033: LIST
61034: PUSH
61035: EMPTY
61036: LIST
61037: LIST
61038: PPUSH
61039: CALL_OW 72
61043: PUSH
61044: LD_INT 1
61046: ARRAY
61047: ST_TO_ADDR
// if IsInUnit ( driver ) then
61048: LD_VAR 0 18
61052: PPUSH
61053: CALL_OW 310
61057: IFFALSE 61068
// ComExit ( driver ) ;
61059: LD_VAR 0 18
61063: PPUSH
61064: CALL 86378 0 1
// AddComEnterUnit ( driver , tmp ) ;
61068: LD_VAR 0 18
61072: PPUSH
61073: LD_VAR 0 13
61077: PPUSH
61078: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61082: LD_VAR 0 18
61086: PPUSH
61087: LD_VAR 0 7
61091: PPUSH
61092: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61096: LD_VAR 0 18
61100: PPUSH
61101: CALL_OW 181
// end ; continue ;
61105: GO 60757
// end ; if not cleaners or not tmp in cleaners then
61107: LD_VAR 0 6
61111: NOT
61112: PUSH
61113: LD_VAR 0 13
61117: PUSH
61118: LD_VAR 0 6
61122: IN
61123: NOT
61124: OR
61125: IFFALSE 61432
// begin if dep then
61127: LD_VAR 0 17
61131: IFFALSE 61267
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61133: LD_ADDR_VAR 0 16
61137: PUSH
61138: LD_VAR 0 17
61142: PUSH
61143: LD_INT 1
61145: ARRAY
61146: PPUSH
61147: CALL_OW 250
61151: PPUSH
61152: LD_VAR 0 17
61156: PUSH
61157: LD_INT 1
61159: ARRAY
61160: PPUSH
61161: CALL_OW 254
61165: PPUSH
61166: LD_INT 5
61168: PPUSH
61169: CALL_OW 272
61173: PUSH
61174: LD_VAR 0 17
61178: PUSH
61179: LD_INT 1
61181: ARRAY
61182: PPUSH
61183: CALL_OW 251
61187: PPUSH
61188: LD_VAR 0 17
61192: PUSH
61193: LD_INT 1
61195: ARRAY
61196: PPUSH
61197: CALL_OW 254
61201: PPUSH
61202: LD_INT 5
61204: PPUSH
61205: CALL_OW 273
61209: PUSH
61210: EMPTY
61211: LIST
61212: LIST
61213: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61214: LD_VAR 0 16
61218: PUSH
61219: LD_INT 1
61221: ARRAY
61222: PPUSH
61223: LD_VAR 0 16
61227: PUSH
61228: LD_INT 2
61230: ARRAY
61231: PPUSH
61232: CALL_OW 488
61236: IFFALSE 61267
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61238: LD_VAR 0 13
61242: PPUSH
61243: LD_VAR 0 16
61247: PUSH
61248: LD_INT 1
61250: ARRAY
61251: PPUSH
61252: LD_VAR 0 16
61256: PUSH
61257: LD_INT 2
61259: ARRAY
61260: PPUSH
61261: CALL_OW 111
// continue ;
61265: GO 60757
// end ; end ; r := GetDir ( tmp ) ;
61267: LD_ADDR_VAR 0 15
61271: PUSH
61272: LD_VAR 0 13
61276: PPUSH
61277: CALL_OW 254
61281: ST_TO_ADDR
// if r = 5 then
61282: LD_VAR 0 15
61286: PUSH
61287: LD_INT 5
61289: EQUAL
61290: IFFALSE 61300
// r := 0 ;
61292: LD_ADDR_VAR 0 15
61296: PUSH
61297: LD_INT 0
61299: ST_TO_ADDR
// for j = r to 5 do
61300: LD_ADDR_VAR 0 10
61304: PUSH
61305: DOUBLE
61306: LD_VAR 0 15
61310: DEC
61311: ST_TO_ADDR
61312: LD_INT 5
61314: PUSH
61315: FOR_TO
61316: IFFALSE 61430
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61318: LD_ADDR_VAR 0 11
61322: PUSH
61323: LD_VAR 0 13
61327: PPUSH
61328: CALL_OW 250
61332: PPUSH
61333: LD_VAR 0 10
61337: PPUSH
61338: LD_INT 2
61340: PPUSH
61341: CALL_OW 272
61345: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61346: LD_ADDR_VAR 0 12
61350: PUSH
61351: LD_VAR 0 13
61355: PPUSH
61356: CALL_OW 251
61360: PPUSH
61361: LD_VAR 0 10
61365: PPUSH
61366: LD_INT 2
61368: PPUSH
61369: CALL_OW 273
61373: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61374: LD_VAR 0 11
61378: PPUSH
61379: LD_VAR 0 12
61383: PPUSH
61384: CALL_OW 488
61388: PUSH
61389: LD_VAR 0 11
61393: PPUSH
61394: LD_VAR 0 12
61398: PPUSH
61399: CALL_OW 428
61403: NOT
61404: AND
61405: IFFALSE 61428
// begin ComMoveXY ( tmp , _x , _y ) ;
61407: LD_VAR 0 13
61411: PPUSH
61412: LD_VAR 0 11
61416: PPUSH
61417: LD_VAR 0 12
61421: PPUSH
61422: CALL_OW 111
// break ;
61426: GO 61430
// end ; end ;
61428: GO 61315
61430: POP
61431: POP
// end ; end ;
61432: GO 60757
61434: POP
61435: POP
// end ;
61436: LD_VAR 0 8
61440: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61441: LD_INT 0
61443: PPUSH
// result := true ;
61444: LD_ADDR_VAR 0 3
61448: PUSH
61449: LD_INT 1
61451: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61452: LD_VAR 0 2
61456: PUSH
61457: LD_INT 24
61459: DOUBLE
61460: EQUAL
61461: IFTRUE 61471
61463: LD_INT 33
61465: DOUBLE
61466: EQUAL
61467: IFTRUE 61471
61469: GO 61496
61471: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61472: LD_ADDR_VAR 0 3
61476: PUSH
61477: LD_INT 32
61479: PPUSH
61480: LD_VAR 0 1
61484: PPUSH
61485: CALL_OW 321
61489: PUSH
61490: LD_INT 2
61492: EQUAL
61493: ST_TO_ADDR
61494: GO 61816
61496: LD_INT 20
61498: DOUBLE
61499: EQUAL
61500: IFTRUE 61504
61502: GO 61529
61504: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61505: LD_ADDR_VAR 0 3
61509: PUSH
61510: LD_INT 6
61512: PPUSH
61513: LD_VAR 0 1
61517: PPUSH
61518: CALL_OW 321
61522: PUSH
61523: LD_INT 2
61525: EQUAL
61526: ST_TO_ADDR
61527: GO 61816
61529: LD_INT 22
61531: DOUBLE
61532: EQUAL
61533: IFTRUE 61543
61535: LD_INT 36
61537: DOUBLE
61538: EQUAL
61539: IFTRUE 61543
61541: GO 61568
61543: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61544: LD_ADDR_VAR 0 3
61548: PUSH
61549: LD_INT 15
61551: PPUSH
61552: LD_VAR 0 1
61556: PPUSH
61557: CALL_OW 321
61561: PUSH
61562: LD_INT 2
61564: EQUAL
61565: ST_TO_ADDR
61566: GO 61816
61568: LD_INT 30
61570: DOUBLE
61571: EQUAL
61572: IFTRUE 61576
61574: GO 61601
61576: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61577: LD_ADDR_VAR 0 3
61581: PUSH
61582: LD_INT 20
61584: PPUSH
61585: LD_VAR 0 1
61589: PPUSH
61590: CALL_OW 321
61594: PUSH
61595: LD_INT 2
61597: EQUAL
61598: ST_TO_ADDR
61599: GO 61816
61601: LD_INT 28
61603: DOUBLE
61604: EQUAL
61605: IFTRUE 61615
61607: LD_INT 21
61609: DOUBLE
61610: EQUAL
61611: IFTRUE 61615
61613: GO 61640
61615: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61616: LD_ADDR_VAR 0 3
61620: PUSH
61621: LD_INT 21
61623: PPUSH
61624: LD_VAR 0 1
61628: PPUSH
61629: CALL_OW 321
61633: PUSH
61634: LD_INT 2
61636: EQUAL
61637: ST_TO_ADDR
61638: GO 61816
61640: LD_INT 16
61642: DOUBLE
61643: EQUAL
61644: IFTRUE 61648
61646: GO 61675
61648: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61649: LD_ADDR_VAR 0 3
61653: PUSH
61654: LD_EXP 107
61658: PPUSH
61659: LD_VAR 0 1
61663: PPUSH
61664: CALL_OW 321
61668: PUSH
61669: LD_INT 2
61671: EQUAL
61672: ST_TO_ADDR
61673: GO 61816
61675: LD_INT 19
61677: DOUBLE
61678: EQUAL
61679: IFTRUE 61689
61681: LD_INT 23
61683: DOUBLE
61684: EQUAL
61685: IFTRUE 61689
61687: GO 61716
61689: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61690: LD_ADDR_VAR 0 3
61694: PUSH
61695: LD_EXP 106
61699: PPUSH
61700: LD_VAR 0 1
61704: PPUSH
61705: CALL_OW 321
61709: PUSH
61710: LD_INT 2
61712: EQUAL
61713: ST_TO_ADDR
61714: GO 61816
61716: LD_INT 17
61718: DOUBLE
61719: EQUAL
61720: IFTRUE 61724
61722: GO 61749
61724: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61725: LD_ADDR_VAR 0 3
61729: PUSH
61730: LD_INT 39
61732: PPUSH
61733: LD_VAR 0 1
61737: PPUSH
61738: CALL_OW 321
61742: PUSH
61743: LD_INT 2
61745: EQUAL
61746: ST_TO_ADDR
61747: GO 61816
61749: LD_INT 18
61751: DOUBLE
61752: EQUAL
61753: IFTRUE 61757
61755: GO 61782
61757: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61758: LD_ADDR_VAR 0 3
61762: PUSH
61763: LD_INT 40
61765: PPUSH
61766: LD_VAR 0 1
61770: PPUSH
61771: CALL_OW 321
61775: PUSH
61776: LD_INT 2
61778: EQUAL
61779: ST_TO_ADDR
61780: GO 61816
61782: LD_INT 27
61784: DOUBLE
61785: EQUAL
61786: IFTRUE 61790
61788: GO 61815
61790: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61791: LD_ADDR_VAR 0 3
61795: PUSH
61796: LD_INT 35
61798: PPUSH
61799: LD_VAR 0 1
61803: PPUSH
61804: CALL_OW 321
61808: PUSH
61809: LD_INT 2
61811: EQUAL
61812: ST_TO_ADDR
61813: GO 61816
61815: POP
// end ;
61816: LD_VAR 0 3
61820: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61821: LD_INT 0
61823: PPUSH
61824: PPUSH
61825: PPUSH
61826: PPUSH
61827: PPUSH
61828: PPUSH
61829: PPUSH
61830: PPUSH
61831: PPUSH
61832: PPUSH
61833: PPUSH
// result := false ;
61834: LD_ADDR_VAR 0 6
61838: PUSH
61839: LD_INT 0
61841: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61842: LD_VAR 0 1
61846: NOT
61847: PUSH
61848: LD_VAR 0 1
61852: PPUSH
61853: CALL_OW 266
61857: PUSH
61858: LD_INT 0
61860: PUSH
61861: LD_INT 1
61863: PUSH
61864: EMPTY
61865: LIST
61866: LIST
61867: IN
61868: NOT
61869: OR
61870: PUSH
61871: LD_VAR 0 2
61875: NOT
61876: OR
61877: PUSH
61878: LD_VAR 0 5
61882: PUSH
61883: LD_INT 0
61885: PUSH
61886: LD_INT 1
61888: PUSH
61889: LD_INT 2
61891: PUSH
61892: LD_INT 3
61894: PUSH
61895: LD_INT 4
61897: PUSH
61898: LD_INT 5
61900: PUSH
61901: EMPTY
61902: LIST
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: LIST
61908: IN
61909: NOT
61910: OR
61911: PUSH
61912: LD_VAR 0 3
61916: PPUSH
61917: LD_VAR 0 4
61921: PPUSH
61922: CALL_OW 488
61926: NOT
61927: OR
61928: IFFALSE 61932
// exit ;
61930: GO 62668
// side := GetSide ( depot ) ;
61932: LD_ADDR_VAR 0 9
61936: PUSH
61937: LD_VAR 0 1
61941: PPUSH
61942: CALL_OW 255
61946: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61947: LD_VAR 0 9
61951: PPUSH
61952: LD_VAR 0 2
61956: PPUSH
61957: CALL 61441 0 2
61961: NOT
61962: IFFALSE 61966
// exit ;
61964: GO 62668
// pom := GetBase ( depot ) ;
61966: LD_ADDR_VAR 0 10
61970: PUSH
61971: LD_VAR 0 1
61975: PPUSH
61976: CALL_OW 274
61980: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61981: LD_ADDR_VAR 0 11
61985: PUSH
61986: LD_VAR 0 2
61990: PPUSH
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL_OW 248
62000: PPUSH
62001: CALL_OW 450
62005: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62006: LD_VAR 0 10
62010: PPUSH
62011: LD_INT 1
62013: PPUSH
62014: CALL_OW 275
62018: PUSH
62019: LD_VAR 0 11
62023: PUSH
62024: LD_INT 1
62026: ARRAY
62027: GREATEREQUAL
62028: PUSH
62029: LD_VAR 0 10
62033: PPUSH
62034: LD_INT 2
62036: PPUSH
62037: CALL_OW 275
62041: PUSH
62042: LD_VAR 0 11
62046: PUSH
62047: LD_INT 2
62049: ARRAY
62050: GREATEREQUAL
62051: AND
62052: PUSH
62053: LD_VAR 0 10
62057: PPUSH
62058: LD_INT 3
62060: PPUSH
62061: CALL_OW 275
62065: PUSH
62066: LD_VAR 0 11
62070: PUSH
62071: LD_INT 3
62073: ARRAY
62074: GREATEREQUAL
62075: AND
62076: NOT
62077: IFFALSE 62081
// exit ;
62079: GO 62668
// if GetBType ( depot ) = b_depot then
62081: LD_VAR 0 1
62085: PPUSH
62086: CALL_OW 266
62090: PUSH
62091: LD_INT 0
62093: EQUAL
62094: IFFALSE 62106
// dist := 28 else
62096: LD_ADDR_VAR 0 14
62100: PUSH
62101: LD_INT 28
62103: ST_TO_ADDR
62104: GO 62114
// dist := 36 ;
62106: LD_ADDR_VAR 0 14
62110: PUSH
62111: LD_INT 36
62113: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62114: LD_VAR 0 1
62118: PPUSH
62119: LD_VAR 0 3
62123: PPUSH
62124: LD_VAR 0 4
62128: PPUSH
62129: CALL_OW 297
62133: PUSH
62134: LD_VAR 0 14
62138: GREATER
62139: IFFALSE 62143
// exit ;
62141: GO 62668
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62143: LD_ADDR_VAR 0 12
62147: PUSH
62148: LD_VAR 0 2
62152: PPUSH
62153: LD_VAR 0 3
62157: PPUSH
62158: LD_VAR 0 4
62162: PPUSH
62163: LD_VAR 0 5
62167: PPUSH
62168: LD_VAR 0 1
62172: PPUSH
62173: CALL_OW 248
62177: PPUSH
62178: LD_INT 0
62180: PPUSH
62181: CALL 62673 0 6
62185: ST_TO_ADDR
// if not hexes then
62186: LD_VAR 0 12
62190: NOT
62191: IFFALSE 62195
// exit ;
62193: GO 62668
// hex := GetHexInfo ( x , y ) ;
62195: LD_ADDR_VAR 0 15
62199: PUSH
62200: LD_VAR 0 3
62204: PPUSH
62205: LD_VAR 0 4
62209: PPUSH
62210: CALL_OW 546
62214: ST_TO_ADDR
// if hex [ 1 ] then
62215: LD_VAR 0 15
62219: PUSH
62220: LD_INT 1
62222: ARRAY
62223: IFFALSE 62227
// exit ;
62225: GO 62668
// height := hex [ 2 ] ;
62227: LD_ADDR_VAR 0 13
62231: PUSH
62232: LD_VAR 0 15
62236: PUSH
62237: LD_INT 2
62239: ARRAY
62240: ST_TO_ADDR
// for i = 1 to hexes do
62241: LD_ADDR_VAR 0 7
62245: PUSH
62246: DOUBLE
62247: LD_INT 1
62249: DEC
62250: ST_TO_ADDR
62251: LD_VAR 0 12
62255: PUSH
62256: FOR_TO
62257: IFFALSE 62587
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62259: LD_VAR 0 12
62263: PUSH
62264: LD_VAR 0 7
62268: ARRAY
62269: PUSH
62270: LD_INT 1
62272: ARRAY
62273: PPUSH
62274: LD_VAR 0 12
62278: PUSH
62279: LD_VAR 0 7
62283: ARRAY
62284: PUSH
62285: LD_INT 2
62287: ARRAY
62288: PPUSH
62289: CALL_OW 488
62293: NOT
62294: PUSH
62295: LD_VAR 0 12
62299: PUSH
62300: LD_VAR 0 7
62304: ARRAY
62305: PUSH
62306: LD_INT 1
62308: ARRAY
62309: PPUSH
62310: LD_VAR 0 12
62314: PUSH
62315: LD_VAR 0 7
62319: ARRAY
62320: PUSH
62321: LD_INT 2
62323: ARRAY
62324: PPUSH
62325: CALL_OW 428
62329: PUSH
62330: LD_INT 0
62332: GREATER
62333: OR
62334: PUSH
62335: LD_VAR 0 12
62339: PUSH
62340: LD_VAR 0 7
62344: ARRAY
62345: PUSH
62346: LD_INT 1
62348: ARRAY
62349: PPUSH
62350: LD_VAR 0 12
62354: PUSH
62355: LD_VAR 0 7
62359: ARRAY
62360: PUSH
62361: LD_INT 2
62363: ARRAY
62364: PPUSH
62365: CALL_OW 351
62369: OR
62370: IFFALSE 62376
// exit ;
62372: POP
62373: POP
62374: GO 62668
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62376: LD_ADDR_VAR 0 8
62380: PUSH
62381: LD_VAR 0 12
62385: PUSH
62386: LD_VAR 0 7
62390: ARRAY
62391: PUSH
62392: LD_INT 1
62394: ARRAY
62395: PPUSH
62396: LD_VAR 0 12
62400: PUSH
62401: LD_VAR 0 7
62405: ARRAY
62406: PUSH
62407: LD_INT 2
62409: ARRAY
62410: PPUSH
62411: CALL_OW 546
62415: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62416: LD_VAR 0 8
62420: PUSH
62421: LD_INT 1
62423: ARRAY
62424: PUSH
62425: LD_VAR 0 8
62429: PUSH
62430: LD_INT 2
62432: ARRAY
62433: PUSH
62434: LD_VAR 0 13
62438: PUSH
62439: LD_INT 2
62441: PLUS
62442: GREATER
62443: OR
62444: PUSH
62445: LD_VAR 0 8
62449: PUSH
62450: LD_INT 2
62452: ARRAY
62453: PUSH
62454: LD_VAR 0 13
62458: PUSH
62459: LD_INT 2
62461: MINUS
62462: LESS
62463: OR
62464: PUSH
62465: LD_VAR 0 8
62469: PUSH
62470: LD_INT 3
62472: ARRAY
62473: PUSH
62474: LD_INT 0
62476: PUSH
62477: LD_INT 8
62479: PUSH
62480: LD_INT 9
62482: PUSH
62483: LD_INT 10
62485: PUSH
62486: LD_INT 11
62488: PUSH
62489: LD_INT 12
62491: PUSH
62492: LD_INT 13
62494: PUSH
62495: LD_INT 16
62497: PUSH
62498: LD_INT 17
62500: PUSH
62501: LD_INT 18
62503: PUSH
62504: LD_INT 19
62506: PUSH
62507: LD_INT 20
62509: PUSH
62510: LD_INT 21
62512: PUSH
62513: EMPTY
62514: LIST
62515: LIST
62516: LIST
62517: LIST
62518: LIST
62519: LIST
62520: LIST
62521: LIST
62522: LIST
62523: LIST
62524: LIST
62525: LIST
62526: LIST
62527: IN
62528: NOT
62529: OR
62530: PUSH
62531: LD_VAR 0 8
62535: PUSH
62536: LD_INT 5
62538: ARRAY
62539: NOT
62540: OR
62541: PUSH
62542: LD_VAR 0 8
62546: PUSH
62547: LD_INT 6
62549: ARRAY
62550: PUSH
62551: LD_INT 1
62553: PUSH
62554: LD_INT 2
62556: PUSH
62557: LD_INT 7
62559: PUSH
62560: LD_INT 9
62562: PUSH
62563: LD_INT 10
62565: PUSH
62566: LD_INT 11
62568: PUSH
62569: EMPTY
62570: LIST
62571: LIST
62572: LIST
62573: LIST
62574: LIST
62575: LIST
62576: IN
62577: NOT
62578: OR
62579: IFFALSE 62585
// exit ;
62581: POP
62582: POP
62583: GO 62668
// end ;
62585: GO 62256
62587: POP
62588: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62589: LD_VAR 0 9
62593: PPUSH
62594: LD_VAR 0 3
62598: PPUSH
62599: LD_VAR 0 4
62603: PPUSH
62604: LD_INT 20
62606: PPUSH
62607: CALL 54614 0 4
62611: PUSH
62612: LD_INT 4
62614: ARRAY
62615: IFFALSE 62619
// exit ;
62617: GO 62668
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62619: LD_VAR 0 2
62623: PUSH
62624: LD_INT 29
62626: PUSH
62627: LD_INT 30
62629: PUSH
62630: EMPTY
62631: LIST
62632: LIST
62633: IN
62634: PUSH
62635: LD_VAR 0 3
62639: PPUSH
62640: LD_VAR 0 4
62644: PPUSH
62645: LD_VAR 0 9
62649: PPUSH
62650: CALL_OW 440
62654: NOT
62655: AND
62656: IFFALSE 62660
// exit ;
62658: GO 62668
// result := true ;
62660: LD_ADDR_VAR 0 6
62664: PUSH
62665: LD_INT 1
62667: ST_TO_ADDR
// end ;
62668: LD_VAR 0 6
62672: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62673: LD_INT 0
62675: PPUSH
62676: PPUSH
62677: PPUSH
62678: PPUSH
62679: PPUSH
62680: PPUSH
62681: PPUSH
62682: PPUSH
62683: PPUSH
62684: PPUSH
62685: PPUSH
62686: PPUSH
62687: PPUSH
62688: PPUSH
62689: PPUSH
62690: PPUSH
62691: PPUSH
62692: PPUSH
62693: PPUSH
62694: PPUSH
62695: PPUSH
62696: PPUSH
62697: PPUSH
62698: PPUSH
62699: PPUSH
62700: PPUSH
62701: PPUSH
62702: PPUSH
62703: PPUSH
62704: PPUSH
62705: PPUSH
62706: PPUSH
62707: PPUSH
62708: PPUSH
62709: PPUSH
62710: PPUSH
62711: PPUSH
62712: PPUSH
62713: PPUSH
62714: PPUSH
62715: PPUSH
62716: PPUSH
62717: PPUSH
62718: PPUSH
62719: PPUSH
62720: PPUSH
62721: PPUSH
62722: PPUSH
62723: PPUSH
62724: PPUSH
62725: PPUSH
62726: PPUSH
62727: PPUSH
62728: PPUSH
62729: PPUSH
62730: PPUSH
62731: PPUSH
62732: PPUSH
// result = [ ] ;
62733: LD_ADDR_VAR 0 7
62737: PUSH
62738: EMPTY
62739: ST_TO_ADDR
// temp_list = [ ] ;
62740: LD_ADDR_VAR 0 9
62744: PUSH
62745: EMPTY
62746: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62747: LD_VAR 0 4
62751: PUSH
62752: LD_INT 0
62754: PUSH
62755: LD_INT 1
62757: PUSH
62758: LD_INT 2
62760: PUSH
62761: LD_INT 3
62763: PUSH
62764: LD_INT 4
62766: PUSH
62767: LD_INT 5
62769: PUSH
62770: EMPTY
62771: LIST
62772: LIST
62773: LIST
62774: LIST
62775: LIST
62776: LIST
62777: IN
62778: NOT
62779: PUSH
62780: LD_VAR 0 1
62784: PUSH
62785: LD_INT 0
62787: PUSH
62788: LD_INT 1
62790: PUSH
62791: EMPTY
62792: LIST
62793: LIST
62794: IN
62795: PUSH
62796: LD_VAR 0 5
62800: PUSH
62801: LD_INT 1
62803: PUSH
62804: LD_INT 2
62806: PUSH
62807: LD_INT 3
62809: PUSH
62810: EMPTY
62811: LIST
62812: LIST
62813: LIST
62814: IN
62815: NOT
62816: AND
62817: OR
62818: IFFALSE 62822
// exit ;
62820: GO 81213
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62822: LD_VAR 0 1
62826: PUSH
62827: LD_INT 6
62829: PUSH
62830: LD_INT 7
62832: PUSH
62833: LD_INT 8
62835: PUSH
62836: LD_INT 13
62838: PUSH
62839: LD_INT 12
62841: PUSH
62842: LD_INT 15
62844: PUSH
62845: LD_INT 11
62847: PUSH
62848: LD_INT 14
62850: PUSH
62851: LD_INT 10
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: LIST
62858: LIST
62859: LIST
62860: LIST
62861: LIST
62862: LIST
62863: LIST
62864: IN
62865: IFFALSE 62875
// btype = b_lab ;
62867: LD_ADDR_VAR 0 1
62871: PUSH
62872: LD_INT 6
62874: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62875: LD_VAR 0 6
62879: PUSH
62880: LD_INT 0
62882: PUSH
62883: LD_INT 1
62885: PUSH
62886: LD_INT 2
62888: PUSH
62889: EMPTY
62890: LIST
62891: LIST
62892: LIST
62893: IN
62894: NOT
62895: PUSH
62896: LD_VAR 0 1
62900: PUSH
62901: LD_INT 0
62903: PUSH
62904: LD_INT 1
62906: PUSH
62907: LD_INT 2
62909: PUSH
62910: LD_INT 3
62912: PUSH
62913: LD_INT 6
62915: PUSH
62916: LD_INT 36
62918: PUSH
62919: LD_INT 4
62921: PUSH
62922: LD_INT 5
62924: PUSH
62925: LD_INT 31
62927: PUSH
62928: LD_INT 32
62930: PUSH
62931: LD_INT 33
62933: PUSH
62934: EMPTY
62935: LIST
62936: LIST
62937: LIST
62938: LIST
62939: LIST
62940: LIST
62941: LIST
62942: LIST
62943: LIST
62944: LIST
62945: LIST
62946: IN
62947: NOT
62948: PUSH
62949: LD_VAR 0 6
62953: PUSH
62954: LD_INT 1
62956: EQUAL
62957: AND
62958: OR
62959: PUSH
62960: LD_VAR 0 1
62964: PUSH
62965: LD_INT 2
62967: PUSH
62968: LD_INT 3
62970: PUSH
62971: EMPTY
62972: LIST
62973: LIST
62974: IN
62975: NOT
62976: PUSH
62977: LD_VAR 0 6
62981: PUSH
62982: LD_INT 2
62984: EQUAL
62985: AND
62986: OR
62987: IFFALSE 62997
// mode = 0 ;
62989: LD_ADDR_VAR 0 6
62993: PUSH
62994: LD_INT 0
62996: ST_TO_ADDR
// case mode of 0 :
62997: LD_VAR 0 6
63001: PUSH
63002: LD_INT 0
63004: DOUBLE
63005: EQUAL
63006: IFTRUE 63010
63008: GO 74463
63010: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63011: LD_ADDR_VAR 0 11
63015: PUSH
63016: LD_INT 0
63018: PUSH
63019: LD_INT 0
63021: PUSH
63022: EMPTY
63023: LIST
63024: LIST
63025: PUSH
63026: LD_INT 0
63028: PUSH
63029: LD_INT 1
63031: NEG
63032: PUSH
63033: EMPTY
63034: LIST
63035: LIST
63036: PUSH
63037: LD_INT 1
63039: PUSH
63040: LD_INT 0
63042: PUSH
63043: EMPTY
63044: LIST
63045: LIST
63046: PUSH
63047: LD_INT 1
63049: PUSH
63050: LD_INT 1
63052: PUSH
63053: EMPTY
63054: LIST
63055: LIST
63056: PUSH
63057: LD_INT 0
63059: PUSH
63060: LD_INT 1
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: PUSH
63067: LD_INT 1
63069: NEG
63070: PUSH
63071: LD_INT 0
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PUSH
63078: LD_INT 1
63080: NEG
63081: PUSH
63082: LD_INT 1
63084: NEG
63085: PUSH
63086: EMPTY
63087: LIST
63088: LIST
63089: PUSH
63090: LD_INT 1
63092: NEG
63093: PUSH
63094: LD_INT 2
63096: NEG
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: PUSH
63102: LD_INT 0
63104: PUSH
63105: LD_INT 2
63107: NEG
63108: PUSH
63109: EMPTY
63110: LIST
63111: LIST
63112: PUSH
63113: LD_INT 1
63115: PUSH
63116: LD_INT 1
63118: NEG
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: PUSH
63124: LD_INT 1
63126: PUSH
63127: LD_INT 2
63129: PUSH
63130: EMPTY
63131: LIST
63132: LIST
63133: PUSH
63134: LD_INT 0
63136: PUSH
63137: LD_INT 2
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: PUSH
63144: LD_INT 1
63146: NEG
63147: PUSH
63148: LD_INT 1
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 1
63157: PUSH
63158: LD_INT 3
63160: PUSH
63161: EMPTY
63162: LIST
63163: LIST
63164: PUSH
63165: LD_INT 0
63167: PUSH
63168: LD_INT 3
63170: PUSH
63171: EMPTY
63172: LIST
63173: LIST
63174: PUSH
63175: LD_INT 1
63177: NEG
63178: PUSH
63179: LD_INT 2
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: LIST
63190: LIST
63191: LIST
63192: LIST
63193: LIST
63194: LIST
63195: LIST
63196: LIST
63197: LIST
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: LIST
63203: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63204: LD_ADDR_VAR 0 12
63208: PUSH
63209: LD_INT 0
63211: PUSH
63212: LD_INT 0
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PUSH
63219: LD_INT 0
63221: PUSH
63222: LD_INT 1
63224: NEG
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PUSH
63230: LD_INT 1
63232: PUSH
63233: LD_INT 0
63235: PUSH
63236: EMPTY
63237: LIST
63238: LIST
63239: PUSH
63240: LD_INT 1
63242: PUSH
63243: LD_INT 1
63245: PUSH
63246: EMPTY
63247: LIST
63248: LIST
63249: PUSH
63250: LD_INT 0
63252: PUSH
63253: LD_INT 1
63255: PUSH
63256: EMPTY
63257: LIST
63258: LIST
63259: PUSH
63260: LD_INT 1
63262: NEG
63263: PUSH
63264: LD_INT 0
63266: PUSH
63267: EMPTY
63268: LIST
63269: LIST
63270: PUSH
63271: LD_INT 1
63273: NEG
63274: PUSH
63275: LD_INT 1
63277: NEG
63278: PUSH
63279: EMPTY
63280: LIST
63281: LIST
63282: PUSH
63283: LD_INT 1
63285: PUSH
63286: LD_INT 1
63288: NEG
63289: PUSH
63290: EMPTY
63291: LIST
63292: LIST
63293: PUSH
63294: LD_INT 2
63296: PUSH
63297: LD_INT 0
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: PUSH
63304: LD_INT 2
63306: PUSH
63307: LD_INT 1
63309: PUSH
63310: EMPTY
63311: LIST
63312: LIST
63313: PUSH
63314: LD_INT 1
63316: NEG
63317: PUSH
63318: LD_INT 1
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: LD_INT 2
63327: NEG
63328: PUSH
63329: LD_INT 0
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PUSH
63336: LD_INT 2
63338: NEG
63339: PUSH
63340: LD_INT 1
63342: NEG
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 2
63350: NEG
63351: PUSH
63352: LD_INT 1
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: PUSH
63359: LD_INT 3
63361: NEG
63362: PUSH
63363: LD_INT 0
63365: PUSH
63366: EMPTY
63367: LIST
63368: LIST
63369: PUSH
63370: LD_INT 3
63372: NEG
63373: PUSH
63374: LD_INT 1
63376: NEG
63377: PUSH
63378: EMPTY
63379: LIST
63380: LIST
63381: PUSH
63382: EMPTY
63383: LIST
63384: LIST
63385: LIST
63386: LIST
63387: LIST
63388: LIST
63389: LIST
63390: LIST
63391: LIST
63392: LIST
63393: LIST
63394: LIST
63395: LIST
63396: LIST
63397: LIST
63398: LIST
63399: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63400: LD_ADDR_VAR 0 13
63404: PUSH
63405: LD_INT 0
63407: PUSH
63408: LD_INT 0
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: PUSH
63415: LD_INT 0
63417: PUSH
63418: LD_INT 1
63420: NEG
63421: PUSH
63422: EMPTY
63423: LIST
63424: LIST
63425: PUSH
63426: LD_INT 1
63428: PUSH
63429: LD_INT 0
63431: PUSH
63432: EMPTY
63433: LIST
63434: LIST
63435: PUSH
63436: LD_INT 1
63438: PUSH
63439: LD_INT 1
63441: PUSH
63442: EMPTY
63443: LIST
63444: LIST
63445: PUSH
63446: LD_INT 0
63448: PUSH
63449: LD_INT 1
63451: PUSH
63452: EMPTY
63453: LIST
63454: LIST
63455: PUSH
63456: LD_INT 1
63458: NEG
63459: PUSH
63460: LD_INT 0
63462: PUSH
63463: EMPTY
63464: LIST
63465: LIST
63466: PUSH
63467: LD_INT 1
63469: NEG
63470: PUSH
63471: LD_INT 1
63473: NEG
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: LD_INT 1
63481: NEG
63482: PUSH
63483: LD_INT 2
63485: NEG
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 2
63493: PUSH
63494: LD_INT 1
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 2
63503: PUSH
63504: LD_INT 2
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 1
63513: PUSH
63514: LD_INT 2
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 2
63523: NEG
63524: PUSH
63525: LD_INT 1
63527: NEG
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 2
63535: NEG
63536: PUSH
63537: LD_INT 2
63539: NEG
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 2
63547: NEG
63548: PUSH
63549: LD_INT 3
63551: NEG
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PUSH
63557: LD_INT 3
63559: NEG
63560: PUSH
63561: LD_INT 2
63563: NEG
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PUSH
63569: LD_INT 3
63571: NEG
63572: PUSH
63573: LD_INT 3
63575: NEG
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: LIST
63585: LIST
63586: LIST
63587: LIST
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: LIST
63593: LIST
63594: LIST
63595: LIST
63596: LIST
63597: LIST
63598: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63599: LD_ADDR_VAR 0 14
63603: PUSH
63604: LD_INT 0
63606: PUSH
63607: LD_INT 0
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: PUSH
63614: LD_INT 0
63616: PUSH
63617: LD_INT 1
63619: NEG
63620: PUSH
63621: EMPTY
63622: LIST
63623: LIST
63624: PUSH
63625: LD_INT 1
63627: PUSH
63628: LD_INT 0
63630: PUSH
63631: EMPTY
63632: LIST
63633: LIST
63634: PUSH
63635: LD_INT 1
63637: PUSH
63638: LD_INT 1
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PUSH
63645: LD_INT 0
63647: PUSH
63648: LD_INT 1
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 1
63657: NEG
63658: PUSH
63659: LD_INT 0
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: PUSH
63666: LD_INT 1
63668: NEG
63669: PUSH
63670: LD_INT 1
63672: NEG
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: PUSH
63678: LD_INT 1
63680: NEG
63681: PUSH
63682: LD_INT 2
63684: NEG
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PUSH
63690: LD_INT 0
63692: PUSH
63693: LD_INT 2
63695: NEG
63696: PUSH
63697: EMPTY
63698: LIST
63699: LIST
63700: PUSH
63701: LD_INT 1
63703: PUSH
63704: LD_INT 1
63706: NEG
63707: PUSH
63708: EMPTY
63709: LIST
63710: LIST
63711: PUSH
63712: LD_INT 1
63714: PUSH
63715: LD_INT 2
63717: PUSH
63718: EMPTY
63719: LIST
63720: LIST
63721: PUSH
63722: LD_INT 0
63724: PUSH
63725: LD_INT 2
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 1
63734: NEG
63735: PUSH
63736: LD_INT 1
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: LD_INT 1
63745: NEG
63746: PUSH
63747: LD_INT 3
63749: NEG
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 0
63757: PUSH
63758: LD_INT 3
63760: NEG
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 1
63768: PUSH
63769: LD_INT 2
63771: NEG
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: EMPTY
63778: LIST
63779: LIST
63780: LIST
63781: LIST
63782: LIST
63783: LIST
63784: LIST
63785: LIST
63786: LIST
63787: LIST
63788: LIST
63789: LIST
63790: LIST
63791: LIST
63792: LIST
63793: LIST
63794: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63795: LD_ADDR_VAR 0 15
63799: PUSH
63800: LD_INT 0
63802: PUSH
63803: LD_INT 0
63805: PUSH
63806: EMPTY
63807: LIST
63808: LIST
63809: PUSH
63810: LD_INT 0
63812: PUSH
63813: LD_INT 1
63815: NEG
63816: PUSH
63817: EMPTY
63818: LIST
63819: LIST
63820: PUSH
63821: LD_INT 1
63823: PUSH
63824: LD_INT 0
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: PUSH
63831: LD_INT 1
63833: PUSH
63834: LD_INT 1
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: PUSH
63841: LD_INT 0
63843: PUSH
63844: LD_INT 1
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: LD_INT 1
63853: NEG
63854: PUSH
63855: LD_INT 0
63857: PUSH
63858: EMPTY
63859: LIST
63860: LIST
63861: PUSH
63862: LD_INT 1
63864: NEG
63865: PUSH
63866: LD_INT 1
63868: NEG
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: PUSH
63874: LD_INT 1
63876: PUSH
63877: LD_INT 1
63879: NEG
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: PUSH
63885: LD_INT 2
63887: PUSH
63888: LD_INT 0
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: LD_INT 2
63897: PUSH
63898: LD_INT 1
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 1
63907: NEG
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: PUSH
63916: LD_INT 2
63918: NEG
63919: PUSH
63920: LD_INT 0
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PUSH
63927: LD_INT 2
63929: NEG
63930: PUSH
63931: LD_INT 1
63933: NEG
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 2
63941: PUSH
63942: LD_INT 1
63944: NEG
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 3
63952: PUSH
63953: LD_INT 0
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 3
63962: PUSH
63963: LD_INT 1
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: EMPTY
63971: LIST
63972: LIST
63973: LIST
63974: LIST
63975: LIST
63976: LIST
63977: LIST
63978: LIST
63979: LIST
63980: LIST
63981: LIST
63982: LIST
63983: LIST
63984: LIST
63985: LIST
63986: LIST
63987: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63988: LD_ADDR_VAR 0 16
63992: PUSH
63993: LD_INT 0
63995: PUSH
63996: LD_INT 0
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PUSH
64003: LD_INT 0
64005: PUSH
64006: LD_INT 1
64008: NEG
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PUSH
64014: LD_INT 1
64016: PUSH
64017: LD_INT 0
64019: PUSH
64020: EMPTY
64021: LIST
64022: LIST
64023: PUSH
64024: LD_INT 1
64026: PUSH
64027: LD_INT 1
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 0
64036: PUSH
64037: LD_INT 1
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: PUSH
64044: LD_INT 1
64046: NEG
64047: PUSH
64048: LD_INT 0
64050: PUSH
64051: EMPTY
64052: LIST
64053: LIST
64054: PUSH
64055: LD_INT 1
64057: NEG
64058: PUSH
64059: LD_INT 1
64061: NEG
64062: PUSH
64063: EMPTY
64064: LIST
64065: LIST
64066: PUSH
64067: LD_INT 1
64069: NEG
64070: PUSH
64071: LD_INT 2
64073: NEG
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 2
64081: PUSH
64082: LD_INT 1
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 2
64091: PUSH
64092: LD_INT 2
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 1
64101: PUSH
64102: LD_INT 2
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: PUSH
64109: LD_INT 2
64111: NEG
64112: PUSH
64113: LD_INT 1
64115: NEG
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: PUSH
64121: LD_INT 2
64123: NEG
64124: PUSH
64125: LD_INT 2
64127: NEG
64128: PUSH
64129: EMPTY
64130: LIST
64131: LIST
64132: PUSH
64133: LD_INT 3
64135: PUSH
64136: LD_INT 2
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PUSH
64143: LD_INT 3
64145: PUSH
64146: LD_INT 3
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: PUSH
64153: LD_INT 2
64155: PUSH
64156: LD_INT 3
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: EMPTY
64164: LIST
64165: LIST
64166: LIST
64167: LIST
64168: LIST
64169: LIST
64170: LIST
64171: LIST
64172: LIST
64173: LIST
64174: LIST
64175: LIST
64176: LIST
64177: LIST
64178: LIST
64179: LIST
64180: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64181: LD_ADDR_VAR 0 17
64185: PUSH
64186: LD_INT 0
64188: PUSH
64189: LD_INT 0
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 0
64198: PUSH
64199: LD_INT 1
64201: NEG
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: PUSH
64207: LD_INT 1
64209: PUSH
64210: LD_INT 0
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: PUSH
64217: LD_INT 1
64219: PUSH
64220: LD_INT 1
64222: PUSH
64223: EMPTY
64224: LIST
64225: LIST
64226: PUSH
64227: LD_INT 0
64229: PUSH
64230: LD_INT 1
64232: PUSH
64233: EMPTY
64234: LIST
64235: LIST
64236: PUSH
64237: LD_INT 1
64239: NEG
64240: PUSH
64241: LD_INT 0
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: PUSH
64248: LD_INT 1
64250: NEG
64251: PUSH
64252: LD_INT 1
64254: NEG
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 1
64262: NEG
64263: PUSH
64264: LD_INT 2
64266: NEG
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 0
64274: PUSH
64275: LD_INT 2
64277: NEG
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: LD_INT 1
64285: PUSH
64286: LD_INT 1
64288: NEG
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: LD_INT 2
64296: PUSH
64297: LD_INT 0
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 2
64306: PUSH
64307: LD_INT 1
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 2
64316: PUSH
64317: LD_INT 2
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PUSH
64324: LD_INT 1
64326: PUSH
64327: LD_INT 2
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: PUSH
64334: LD_INT 0
64336: PUSH
64337: LD_INT 2
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: LD_INT 1
64346: NEG
64347: PUSH
64348: LD_INT 1
64350: PUSH
64351: EMPTY
64352: LIST
64353: LIST
64354: PUSH
64355: LD_INT 2
64357: NEG
64358: PUSH
64359: LD_INT 0
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PUSH
64366: LD_INT 2
64368: NEG
64369: PUSH
64370: LD_INT 1
64372: NEG
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: PUSH
64378: LD_INT 2
64380: NEG
64381: PUSH
64382: LD_INT 2
64384: NEG
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: EMPTY
64391: LIST
64392: LIST
64393: LIST
64394: LIST
64395: LIST
64396: LIST
64397: LIST
64398: LIST
64399: LIST
64400: LIST
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64411: LD_ADDR_VAR 0 18
64415: PUSH
64416: LD_INT 0
64418: PUSH
64419: LD_INT 0
64421: PUSH
64422: EMPTY
64423: LIST
64424: LIST
64425: PUSH
64426: LD_INT 0
64428: PUSH
64429: LD_INT 1
64431: NEG
64432: PUSH
64433: EMPTY
64434: LIST
64435: LIST
64436: PUSH
64437: LD_INT 1
64439: PUSH
64440: LD_INT 0
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: PUSH
64447: LD_INT 1
64449: PUSH
64450: LD_INT 1
64452: PUSH
64453: EMPTY
64454: LIST
64455: LIST
64456: PUSH
64457: LD_INT 0
64459: PUSH
64460: LD_INT 1
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: PUSH
64467: LD_INT 1
64469: NEG
64470: PUSH
64471: LD_INT 0
64473: PUSH
64474: EMPTY
64475: LIST
64476: LIST
64477: PUSH
64478: LD_INT 1
64480: NEG
64481: PUSH
64482: LD_INT 1
64484: NEG
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: LD_INT 1
64492: NEG
64493: PUSH
64494: LD_INT 2
64496: NEG
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PUSH
64502: LD_INT 0
64504: PUSH
64505: LD_INT 2
64507: NEG
64508: PUSH
64509: EMPTY
64510: LIST
64511: LIST
64512: PUSH
64513: LD_INT 1
64515: PUSH
64516: LD_INT 1
64518: NEG
64519: PUSH
64520: EMPTY
64521: LIST
64522: LIST
64523: PUSH
64524: LD_INT 2
64526: PUSH
64527: LD_INT 0
64529: PUSH
64530: EMPTY
64531: LIST
64532: LIST
64533: PUSH
64534: LD_INT 2
64536: PUSH
64537: LD_INT 1
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: PUSH
64544: LD_INT 2
64546: PUSH
64547: LD_INT 2
64549: PUSH
64550: EMPTY
64551: LIST
64552: LIST
64553: PUSH
64554: LD_INT 1
64556: PUSH
64557: LD_INT 2
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: LD_INT 2
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: LD_INT 1
64576: NEG
64577: PUSH
64578: LD_INT 1
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: LD_INT 2
64587: NEG
64588: PUSH
64589: LD_INT 0
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 2
64598: NEG
64599: PUSH
64600: LD_INT 1
64602: NEG
64603: PUSH
64604: EMPTY
64605: LIST
64606: LIST
64607: PUSH
64608: LD_INT 2
64610: NEG
64611: PUSH
64612: LD_INT 2
64614: NEG
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: LIST
64624: LIST
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: LIST
64632: LIST
64633: LIST
64634: LIST
64635: LIST
64636: LIST
64637: LIST
64638: LIST
64639: LIST
64640: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64641: LD_ADDR_VAR 0 19
64645: PUSH
64646: LD_INT 0
64648: PUSH
64649: LD_INT 0
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: LD_INT 0
64658: PUSH
64659: LD_INT 1
64661: NEG
64662: PUSH
64663: EMPTY
64664: LIST
64665: LIST
64666: PUSH
64667: LD_INT 1
64669: PUSH
64670: LD_INT 0
64672: PUSH
64673: EMPTY
64674: LIST
64675: LIST
64676: PUSH
64677: LD_INT 1
64679: PUSH
64680: LD_INT 1
64682: PUSH
64683: EMPTY
64684: LIST
64685: LIST
64686: PUSH
64687: LD_INT 0
64689: PUSH
64690: LD_INT 1
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PUSH
64697: LD_INT 1
64699: NEG
64700: PUSH
64701: LD_INT 0
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PUSH
64708: LD_INT 1
64710: NEG
64711: PUSH
64712: LD_INT 1
64714: NEG
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: PUSH
64720: LD_INT 1
64722: NEG
64723: PUSH
64724: LD_INT 2
64726: NEG
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 0
64734: PUSH
64735: LD_INT 2
64737: NEG
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 1
64745: PUSH
64746: LD_INT 1
64748: NEG
64749: PUSH
64750: EMPTY
64751: LIST
64752: LIST
64753: PUSH
64754: LD_INT 2
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 2
64766: PUSH
64767: LD_INT 1
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: LD_INT 2
64776: PUSH
64777: LD_INT 2
64779: PUSH
64780: EMPTY
64781: LIST
64782: LIST
64783: PUSH
64784: LD_INT 1
64786: PUSH
64787: LD_INT 2
64789: PUSH
64790: EMPTY
64791: LIST
64792: LIST
64793: PUSH
64794: LD_INT 0
64796: PUSH
64797: LD_INT 2
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: PUSH
64804: LD_INT 1
64806: NEG
64807: PUSH
64808: LD_INT 1
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: PUSH
64815: LD_INT 2
64817: NEG
64818: PUSH
64819: LD_INT 0
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 2
64828: NEG
64829: PUSH
64830: LD_INT 1
64832: NEG
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: PUSH
64838: LD_INT 2
64840: NEG
64841: PUSH
64842: LD_INT 2
64844: NEG
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: LIST
64854: LIST
64855: LIST
64856: LIST
64857: LIST
64858: LIST
64859: LIST
64860: LIST
64861: LIST
64862: LIST
64863: LIST
64864: LIST
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64871: LD_ADDR_VAR 0 20
64875: PUSH
64876: LD_INT 0
64878: PUSH
64879: LD_INT 0
64881: PUSH
64882: EMPTY
64883: LIST
64884: LIST
64885: PUSH
64886: LD_INT 0
64888: PUSH
64889: LD_INT 1
64891: NEG
64892: PUSH
64893: EMPTY
64894: LIST
64895: LIST
64896: PUSH
64897: LD_INT 1
64899: PUSH
64900: LD_INT 0
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: PUSH
64907: LD_INT 1
64909: PUSH
64910: LD_INT 1
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: LD_INT 0
64919: PUSH
64920: LD_INT 1
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: LD_INT 1
64929: NEG
64930: PUSH
64931: LD_INT 0
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: PUSH
64938: LD_INT 1
64940: NEG
64941: PUSH
64942: LD_INT 1
64944: NEG
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: LD_INT 1
64952: NEG
64953: PUSH
64954: LD_INT 2
64956: NEG
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 0
64964: PUSH
64965: LD_INT 2
64967: NEG
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: LD_INT 1
64975: PUSH
64976: LD_INT 1
64978: NEG
64979: PUSH
64980: EMPTY
64981: LIST
64982: LIST
64983: PUSH
64984: LD_INT 2
64986: PUSH
64987: LD_INT 0
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 2
64996: PUSH
64997: LD_INT 1
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 2
65006: PUSH
65007: LD_INT 2
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: LD_INT 1
65016: PUSH
65017: LD_INT 2
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PUSH
65024: LD_INT 0
65026: PUSH
65027: LD_INT 2
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: LD_INT 1
65036: NEG
65037: PUSH
65038: LD_INT 1
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: PUSH
65045: LD_INT 2
65047: NEG
65048: PUSH
65049: LD_INT 0
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: LD_INT 2
65058: NEG
65059: PUSH
65060: LD_INT 1
65062: NEG
65063: PUSH
65064: EMPTY
65065: LIST
65066: LIST
65067: PUSH
65068: LD_INT 2
65070: NEG
65071: PUSH
65072: LD_INT 2
65074: NEG
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: LIST
65087: LIST
65088: LIST
65089: LIST
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: LIST
65095: LIST
65096: LIST
65097: LIST
65098: LIST
65099: LIST
65100: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65101: LD_ADDR_VAR 0 21
65105: PUSH
65106: LD_INT 0
65108: PUSH
65109: LD_INT 0
65111: PUSH
65112: EMPTY
65113: LIST
65114: LIST
65115: PUSH
65116: LD_INT 0
65118: PUSH
65119: LD_INT 1
65121: NEG
65122: PUSH
65123: EMPTY
65124: LIST
65125: LIST
65126: PUSH
65127: LD_INT 1
65129: PUSH
65130: LD_INT 0
65132: PUSH
65133: EMPTY
65134: LIST
65135: LIST
65136: PUSH
65137: LD_INT 1
65139: PUSH
65140: LD_INT 1
65142: PUSH
65143: EMPTY
65144: LIST
65145: LIST
65146: PUSH
65147: LD_INT 0
65149: PUSH
65150: LD_INT 1
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: LD_INT 1
65159: NEG
65160: PUSH
65161: LD_INT 0
65163: PUSH
65164: EMPTY
65165: LIST
65166: LIST
65167: PUSH
65168: LD_INT 1
65170: NEG
65171: PUSH
65172: LD_INT 1
65174: NEG
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 1
65182: NEG
65183: PUSH
65184: LD_INT 2
65186: NEG
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 0
65194: PUSH
65195: LD_INT 2
65197: NEG
65198: PUSH
65199: EMPTY
65200: LIST
65201: LIST
65202: PUSH
65203: LD_INT 1
65205: PUSH
65206: LD_INT 1
65208: NEG
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: PUSH
65214: LD_INT 2
65216: PUSH
65217: LD_INT 0
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PUSH
65224: LD_INT 2
65226: PUSH
65227: LD_INT 1
65229: PUSH
65230: EMPTY
65231: LIST
65232: LIST
65233: PUSH
65234: LD_INT 2
65236: PUSH
65237: LD_INT 2
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: PUSH
65244: LD_INT 1
65246: PUSH
65247: LD_INT 2
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: PUSH
65254: LD_INT 0
65256: PUSH
65257: LD_INT 2
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 1
65266: NEG
65267: PUSH
65268: LD_INT 1
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 2
65277: NEG
65278: PUSH
65279: LD_INT 0
65281: PUSH
65282: EMPTY
65283: LIST
65284: LIST
65285: PUSH
65286: LD_INT 2
65288: NEG
65289: PUSH
65290: LD_INT 1
65292: NEG
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 2
65300: NEG
65301: PUSH
65302: LD_INT 2
65304: NEG
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: LIST
65314: LIST
65315: LIST
65316: LIST
65317: LIST
65318: LIST
65319: LIST
65320: LIST
65321: LIST
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65331: LD_ADDR_VAR 0 22
65335: PUSH
65336: LD_INT 0
65338: PUSH
65339: LD_INT 0
65341: PUSH
65342: EMPTY
65343: LIST
65344: LIST
65345: PUSH
65346: LD_INT 0
65348: PUSH
65349: LD_INT 1
65351: NEG
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: PUSH
65357: LD_INT 1
65359: PUSH
65360: LD_INT 0
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 1
65369: PUSH
65370: LD_INT 1
65372: PUSH
65373: EMPTY
65374: LIST
65375: LIST
65376: PUSH
65377: LD_INT 0
65379: PUSH
65380: LD_INT 1
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 1
65389: NEG
65390: PUSH
65391: LD_INT 0
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: LD_INT 1
65400: NEG
65401: PUSH
65402: LD_INT 1
65404: NEG
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 1
65412: NEG
65413: PUSH
65414: LD_INT 2
65416: NEG
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 0
65424: PUSH
65425: LD_INT 2
65427: NEG
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PUSH
65433: LD_INT 1
65435: PUSH
65436: LD_INT 1
65438: NEG
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: LD_INT 2
65446: PUSH
65447: LD_INT 0
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 2
65456: PUSH
65457: LD_INT 1
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 2
65466: PUSH
65467: LD_INT 2
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 1
65476: PUSH
65477: LD_INT 2
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: PUSH
65484: LD_INT 0
65486: PUSH
65487: LD_INT 2
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 1
65496: NEG
65497: PUSH
65498: LD_INT 1
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 2
65507: NEG
65508: PUSH
65509: LD_INT 0
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: LD_INT 2
65518: NEG
65519: PUSH
65520: LD_INT 1
65522: NEG
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 2
65530: NEG
65531: PUSH
65532: LD_INT 2
65534: NEG
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: LIST
65544: LIST
65545: LIST
65546: LIST
65547: LIST
65548: LIST
65549: LIST
65550: LIST
65551: LIST
65552: LIST
65553: LIST
65554: LIST
65555: LIST
65556: LIST
65557: LIST
65558: LIST
65559: LIST
65560: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65561: LD_ADDR_VAR 0 23
65565: PUSH
65566: LD_INT 0
65568: PUSH
65569: LD_INT 0
65571: PUSH
65572: EMPTY
65573: LIST
65574: LIST
65575: PUSH
65576: LD_INT 0
65578: PUSH
65579: LD_INT 1
65581: NEG
65582: PUSH
65583: EMPTY
65584: LIST
65585: LIST
65586: PUSH
65587: LD_INT 1
65589: PUSH
65590: LD_INT 0
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 1
65599: PUSH
65600: LD_INT 1
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: PUSH
65607: LD_INT 0
65609: PUSH
65610: LD_INT 1
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 1
65619: NEG
65620: PUSH
65621: LD_INT 0
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 1
65630: NEG
65631: PUSH
65632: LD_INT 1
65634: NEG
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PUSH
65640: LD_INT 1
65642: NEG
65643: PUSH
65644: LD_INT 2
65646: NEG
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 0
65654: PUSH
65655: LD_INT 2
65657: NEG
65658: PUSH
65659: EMPTY
65660: LIST
65661: LIST
65662: PUSH
65663: LD_INT 1
65665: PUSH
65666: LD_INT 1
65668: NEG
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 2
65676: PUSH
65677: LD_INT 0
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: PUSH
65684: LD_INT 2
65686: PUSH
65687: LD_INT 1
65689: PUSH
65690: EMPTY
65691: LIST
65692: LIST
65693: PUSH
65694: LD_INT 2
65696: PUSH
65697: LD_INT 2
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 1
65706: PUSH
65707: LD_INT 2
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: LD_INT 0
65716: PUSH
65717: LD_INT 2
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 1
65726: NEG
65727: PUSH
65728: LD_INT 1
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 2
65737: NEG
65738: PUSH
65739: LD_INT 0
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: PUSH
65746: LD_INT 2
65748: NEG
65749: PUSH
65750: LD_INT 1
65752: NEG
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: LD_INT 2
65760: NEG
65761: PUSH
65762: LD_INT 2
65764: NEG
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 2
65772: NEG
65773: PUSH
65774: LD_INT 3
65776: NEG
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 1
65784: NEG
65785: PUSH
65786: LD_INT 3
65788: NEG
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: LD_INT 1
65796: PUSH
65797: LD_INT 2
65799: NEG
65800: PUSH
65801: EMPTY
65802: LIST
65803: LIST
65804: PUSH
65805: LD_INT 2
65807: PUSH
65808: LD_INT 1
65810: NEG
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65841: LD_ADDR_VAR 0 24
65845: PUSH
65846: LD_INT 0
65848: PUSH
65849: LD_INT 0
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: LD_INT 1
65861: NEG
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: LD_INT 1
65869: PUSH
65870: LD_INT 0
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 1
65879: PUSH
65880: LD_INT 1
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 0
65889: PUSH
65890: LD_INT 1
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 1
65899: NEG
65900: PUSH
65901: LD_INT 0
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 1
65910: NEG
65911: PUSH
65912: LD_INT 1
65914: NEG
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: LD_INT 1
65922: NEG
65923: PUSH
65924: LD_INT 2
65926: NEG
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 0
65934: PUSH
65935: LD_INT 2
65937: NEG
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: PUSH
65943: LD_INT 1
65945: PUSH
65946: LD_INT 1
65948: NEG
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 2
65956: PUSH
65957: LD_INT 0
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 2
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 2
65976: PUSH
65977: LD_INT 2
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 1
65986: PUSH
65987: LD_INT 2
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 0
65996: PUSH
65997: LD_INT 2
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: LD_INT 1
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 2
66017: NEG
66018: PUSH
66019: LD_INT 0
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 2
66028: NEG
66029: PUSH
66030: LD_INT 1
66032: NEG
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 2
66040: NEG
66041: PUSH
66042: LD_INT 2
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 1
66052: PUSH
66053: LD_INT 2
66055: NEG
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 2
66063: PUSH
66064: LD_INT 1
66066: NEG
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 3
66074: PUSH
66075: LD_INT 1
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 3
66084: PUSH
66085: LD_INT 2
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: LIST
66096: LIST
66097: LIST
66098: LIST
66099: LIST
66100: LIST
66101: LIST
66102: LIST
66103: LIST
66104: LIST
66105: LIST
66106: LIST
66107: LIST
66108: LIST
66109: LIST
66110: LIST
66111: LIST
66112: LIST
66113: LIST
66114: LIST
66115: LIST
66116: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66117: LD_ADDR_VAR 0 25
66121: PUSH
66122: LD_INT 0
66124: PUSH
66125: LD_INT 0
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: LD_INT 0
66134: PUSH
66135: LD_INT 1
66137: NEG
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PUSH
66143: LD_INT 1
66145: PUSH
66146: LD_INT 0
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: LD_INT 1
66155: PUSH
66156: LD_INT 1
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: PUSH
66163: LD_INT 0
66165: PUSH
66166: LD_INT 1
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PUSH
66173: LD_INT 1
66175: NEG
66176: PUSH
66177: LD_INT 0
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 1
66186: NEG
66187: PUSH
66188: LD_INT 1
66190: NEG
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 1
66198: NEG
66199: PUSH
66200: LD_INT 2
66202: NEG
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 0
66210: PUSH
66211: LD_INT 2
66213: NEG
66214: PUSH
66215: EMPTY
66216: LIST
66217: LIST
66218: PUSH
66219: LD_INT 1
66221: PUSH
66222: LD_INT 1
66224: NEG
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 2
66232: PUSH
66233: LD_INT 0
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 2
66242: PUSH
66243: LD_INT 1
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 2
66252: PUSH
66253: LD_INT 2
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 1
66262: PUSH
66263: LD_INT 2
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 0
66272: PUSH
66273: LD_INT 2
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 1
66282: NEG
66283: PUSH
66284: LD_INT 1
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 2
66293: NEG
66294: PUSH
66295: LD_INT 0
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 2
66304: NEG
66305: PUSH
66306: LD_INT 1
66308: NEG
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PUSH
66314: LD_INT 2
66316: NEG
66317: PUSH
66318: LD_INT 2
66320: NEG
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 3
66328: PUSH
66329: LD_INT 1
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 3
66338: PUSH
66339: LD_INT 2
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 2
66348: PUSH
66349: LD_INT 3
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 1
66358: PUSH
66359: LD_INT 3
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66391: LD_ADDR_VAR 0 26
66395: PUSH
66396: LD_INT 0
66398: PUSH
66399: LD_INT 0
66401: PUSH
66402: EMPTY
66403: LIST
66404: LIST
66405: PUSH
66406: LD_INT 0
66408: PUSH
66409: LD_INT 1
66411: NEG
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: LD_INT 0
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PUSH
66427: LD_INT 1
66429: PUSH
66430: LD_INT 1
66432: PUSH
66433: EMPTY
66434: LIST
66435: LIST
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: LD_INT 1
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 1
66449: NEG
66450: PUSH
66451: LD_INT 0
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 1
66460: NEG
66461: PUSH
66462: LD_INT 1
66464: NEG
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 1
66472: NEG
66473: PUSH
66474: LD_INT 2
66476: NEG
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 0
66484: PUSH
66485: LD_INT 2
66487: NEG
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 1
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: LD_INT 0
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 2
66516: PUSH
66517: LD_INT 1
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 2
66526: PUSH
66527: LD_INT 2
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: PUSH
66537: LD_INT 2
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 0
66546: PUSH
66547: LD_INT 2
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 1
66556: NEG
66557: PUSH
66558: LD_INT 1
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 2
66567: NEG
66568: PUSH
66569: LD_INT 0
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 2
66578: NEG
66579: PUSH
66580: LD_INT 1
66582: NEG
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 2
66590: NEG
66591: PUSH
66592: LD_INT 2
66594: NEG
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 2
66602: PUSH
66603: LD_INT 3
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: PUSH
66610: LD_INT 1
66612: PUSH
66613: LD_INT 3
66615: PUSH
66616: EMPTY
66617: LIST
66618: LIST
66619: PUSH
66620: LD_INT 1
66622: NEG
66623: PUSH
66624: LD_INT 2
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PUSH
66631: LD_INT 2
66633: NEG
66634: PUSH
66635: LD_INT 1
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66667: LD_ADDR_VAR 0 27
66671: PUSH
66672: LD_INT 0
66674: PUSH
66675: LD_INT 0
66677: PUSH
66678: EMPTY
66679: LIST
66680: LIST
66681: PUSH
66682: LD_INT 0
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: PUSH
66693: LD_INT 1
66695: PUSH
66696: LD_INT 0
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: PUSH
66703: LD_INT 1
66705: PUSH
66706: LD_INT 1
66708: PUSH
66709: EMPTY
66710: LIST
66711: LIST
66712: PUSH
66713: LD_INT 0
66715: PUSH
66716: LD_INT 1
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 1
66725: NEG
66726: PUSH
66727: LD_INT 0
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 1
66736: NEG
66737: PUSH
66738: LD_INT 1
66740: NEG
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: LD_INT 1
66748: NEG
66749: PUSH
66750: LD_INT 2
66752: NEG
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 0
66760: PUSH
66761: LD_INT 2
66763: NEG
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 1
66771: PUSH
66772: LD_INT 1
66774: NEG
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 2
66782: PUSH
66783: LD_INT 0
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 2
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 2
66802: PUSH
66803: LD_INT 2
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 1
66812: PUSH
66813: LD_INT 2
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 0
66822: PUSH
66823: LD_INT 2
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 1
66832: NEG
66833: PUSH
66834: LD_INT 1
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 2
66843: NEG
66844: PUSH
66845: LD_INT 0
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 2
66854: NEG
66855: PUSH
66856: LD_INT 1
66858: NEG
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: PUSH
66864: LD_INT 2
66866: NEG
66867: PUSH
66868: LD_INT 2
66870: NEG
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: LD_INT 1
66878: NEG
66879: PUSH
66880: LD_INT 2
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PUSH
66887: LD_INT 2
66889: NEG
66890: PUSH
66891: LD_INT 1
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 3
66900: NEG
66901: PUSH
66902: LD_INT 1
66904: NEG
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 3
66912: NEG
66913: PUSH
66914: LD_INT 2
66916: NEG
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66947: LD_ADDR_VAR 0 28
66951: PUSH
66952: LD_INT 0
66954: PUSH
66955: LD_INT 0
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 0
66964: PUSH
66965: LD_INT 1
66967: NEG
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: LD_INT 0
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 1
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 0
66995: PUSH
66996: LD_INT 1
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 1
67005: NEG
67006: PUSH
67007: LD_INT 0
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 1
67016: NEG
67017: PUSH
67018: LD_INT 1
67020: NEG
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PUSH
67026: LD_INT 1
67028: NEG
67029: PUSH
67030: LD_INT 2
67032: NEG
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 0
67040: PUSH
67041: LD_INT 2
67043: NEG
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 1
67051: PUSH
67052: LD_INT 1
67054: NEG
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: LD_INT 0
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 2
67072: PUSH
67073: LD_INT 1
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 2
67082: PUSH
67083: LD_INT 2
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 1
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 0
67102: PUSH
67103: LD_INT 2
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 1
67112: NEG
67113: PUSH
67114: LD_INT 1
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 2
67123: NEG
67124: PUSH
67125: LD_INT 0
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 2
67134: NEG
67135: PUSH
67136: LD_INT 1
67138: NEG
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: PUSH
67144: LD_INT 2
67146: NEG
67147: PUSH
67148: LD_INT 2
67150: NEG
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 2
67158: NEG
67159: PUSH
67160: LD_INT 3
67162: NEG
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 1
67170: NEG
67171: PUSH
67172: LD_INT 3
67174: NEG
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: PUSH
67180: LD_INT 3
67182: NEG
67183: PUSH
67184: LD_INT 1
67186: NEG
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: LD_INT 3
67194: NEG
67195: PUSH
67196: LD_INT 2
67198: NEG
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: LIST
67208: LIST
67209: LIST
67210: LIST
67211: LIST
67212: LIST
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67229: LD_ADDR_VAR 0 29
67233: PUSH
67234: LD_INT 0
67236: PUSH
67237: LD_INT 0
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 0
67246: PUSH
67247: LD_INT 1
67249: NEG
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 1
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 1
67267: PUSH
67268: LD_INT 1
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 0
67277: PUSH
67278: LD_INT 1
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 1
67287: NEG
67288: PUSH
67289: LD_INT 0
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 1
67298: NEG
67299: PUSH
67300: LD_INT 1
67302: NEG
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 1
67310: NEG
67311: PUSH
67312: LD_INT 2
67314: NEG
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_INT 2
67325: NEG
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 1
67333: PUSH
67334: LD_INT 1
67336: NEG
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PUSH
67342: LD_INT 2
67344: PUSH
67345: LD_INT 0
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 2
67354: PUSH
67355: LD_INT 1
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 1
67364: PUSH
67365: LD_INT 2
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 0
67374: PUSH
67375: LD_INT 2
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 1
67384: NEG
67385: PUSH
67386: LD_INT 1
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PUSH
67393: LD_INT 2
67395: NEG
67396: PUSH
67397: LD_INT 1
67399: NEG
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PUSH
67405: LD_INT 2
67407: NEG
67408: PUSH
67409: LD_INT 2
67411: NEG
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: LD_INT 2
67419: NEG
67420: PUSH
67421: LD_INT 3
67423: NEG
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: LD_INT 2
67431: PUSH
67432: LD_INT 1
67434: NEG
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 3
67442: PUSH
67443: LD_INT 1
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 1
67452: PUSH
67453: LD_INT 3
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 1
67462: NEG
67463: PUSH
67464: LD_INT 2
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 3
67473: NEG
67474: PUSH
67475: LD_INT 2
67477: NEG
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67508: LD_ADDR_VAR 0 30
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: LD_INT 0
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: LD_INT 1
67528: NEG
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 0
67556: PUSH
67557: LD_INT 1
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 1
67566: NEG
67567: PUSH
67568: LD_INT 0
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 1
67577: NEG
67578: PUSH
67579: LD_INT 1
67581: NEG
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: PUSH
67587: LD_INT 1
67589: NEG
67590: PUSH
67591: LD_INT 2
67593: NEG
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 0
67601: PUSH
67602: LD_INT 2
67604: NEG
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 1
67612: PUSH
67613: LD_INT 1
67615: NEG
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: LD_INT 0
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 2
67633: PUSH
67634: LD_INT 1
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 2
67643: PUSH
67644: LD_INT 2
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 1
67653: PUSH
67654: LD_INT 2
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 1
67663: NEG
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 2
67674: NEG
67675: PUSH
67676: LD_INT 0
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 2
67685: NEG
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 1
67697: NEG
67698: PUSH
67699: LD_INT 3
67701: NEG
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: LD_INT 1
67709: PUSH
67710: LD_INT 2
67712: NEG
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 3
67720: PUSH
67721: LD_INT 2
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 2
67730: PUSH
67731: LD_INT 3
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: PUSH
67738: LD_INT 2
67740: NEG
67741: PUSH
67742: LD_INT 1
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 3
67751: NEG
67752: PUSH
67753: LD_INT 1
67755: NEG
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: EMPTY
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: LIST
67783: LIST
67784: LIST
67785: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67786: LD_ADDR_VAR 0 31
67790: PUSH
67791: LD_INT 0
67793: PUSH
67794: LD_INT 0
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 0
67803: PUSH
67804: LD_INT 1
67806: NEG
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 1
67814: PUSH
67815: LD_INT 0
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 1
67824: PUSH
67825: LD_INT 1
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 0
67834: PUSH
67835: LD_INT 1
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 1
67844: NEG
67845: PUSH
67846: LD_INT 0
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 1
67855: NEG
67856: PUSH
67857: LD_INT 1
67859: NEG
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: LD_INT 1
67867: NEG
67868: PUSH
67869: LD_INT 2
67871: NEG
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: LD_INT 1
67882: NEG
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 2
67890: PUSH
67891: LD_INT 0
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 2
67900: PUSH
67901: LD_INT 1
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 2
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: PUSH
67921: LD_INT 2
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 0
67930: PUSH
67931: LD_INT 2
67933: PUSH
67934: EMPTY
67935: LIST
67936: LIST
67937: PUSH
67938: LD_INT 1
67940: NEG
67941: PUSH
67942: LD_INT 1
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 2
67951: NEG
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 2
67963: NEG
67964: PUSH
67965: LD_INT 2
67967: NEG
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 2
67975: NEG
67976: PUSH
67977: LD_INT 3
67979: NEG
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 2
67987: PUSH
67988: LD_INT 1
67990: NEG
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 3
67998: PUSH
67999: LD_INT 1
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: LD_INT 3
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PUSH
68016: LD_INT 1
68018: NEG
68019: PUSH
68020: LD_INT 2
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PUSH
68027: LD_INT 3
68029: NEG
68030: PUSH
68031: LD_INT 2
68033: NEG
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68064: LD_ADDR_VAR 0 32
68068: PUSH
68069: LD_INT 0
68071: PUSH
68072: LD_INT 0
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 0
68081: PUSH
68082: LD_INT 1
68084: NEG
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 1
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 1
68102: PUSH
68103: LD_INT 1
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 0
68112: PUSH
68113: LD_INT 1
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 1
68122: NEG
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 1
68133: NEG
68134: PUSH
68135: LD_INT 1
68137: NEG
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 1
68145: NEG
68146: PUSH
68147: LD_INT 2
68149: NEG
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 0
68157: PUSH
68158: LD_INT 2
68160: NEG
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: PUSH
68169: LD_INT 1
68171: NEG
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 2
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 2
68189: PUSH
68190: LD_INT 2
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 1
68199: PUSH
68200: LD_INT 2
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 0
68209: PUSH
68210: LD_INT 2
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: LD_INT 1
68219: NEG
68220: PUSH
68221: LD_INT 1
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 2
68230: NEG
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 2
68241: NEG
68242: PUSH
68243: LD_INT 1
68245: NEG
68246: PUSH
68247: EMPTY
68248: LIST
68249: LIST
68250: PUSH
68251: LD_INT 1
68253: NEG
68254: PUSH
68255: LD_INT 3
68257: NEG
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 1
68265: PUSH
68266: LD_INT 2
68268: NEG
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 3
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 2
68286: PUSH
68287: LD_INT 3
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 2
68296: NEG
68297: PUSH
68298: LD_INT 1
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 3
68307: NEG
68308: PUSH
68309: LD_INT 1
68311: NEG
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68342: LD_ADDR_VAR 0 33
68346: PUSH
68347: LD_INT 0
68349: PUSH
68350: LD_INT 0
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: LD_INT 1
68362: NEG
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 1
68370: PUSH
68371: LD_INT 0
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 1
68380: PUSH
68381: LD_INT 1
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 0
68390: PUSH
68391: LD_INT 1
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 1
68400: NEG
68401: PUSH
68402: LD_INT 0
68404: PUSH
68405: EMPTY
68406: LIST
68407: LIST
68408: PUSH
68409: LD_INT 1
68411: NEG
68412: PUSH
68413: LD_INT 1
68415: NEG
68416: PUSH
68417: EMPTY
68418: LIST
68419: LIST
68420: PUSH
68421: LD_INT 1
68423: NEG
68424: PUSH
68425: LD_INT 2
68427: NEG
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 1
68435: PUSH
68436: LD_INT 1
68438: NEG
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: LD_INT 2
68446: PUSH
68447: LD_INT 0
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 2
68456: PUSH
68457: LD_INT 1
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: LD_INT 2
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 0
68476: PUSH
68477: LD_INT 2
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: LD_INT 1
68486: NEG
68487: PUSH
68488: LD_INT 1
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: LD_INT 2
68497: NEG
68498: PUSH
68499: LD_INT 0
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 2
68508: NEG
68509: PUSH
68510: LD_INT 1
68512: NEG
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 2
68520: NEG
68521: PUSH
68522: LD_INT 2
68524: NEG
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: LD_INT 2
68532: NEG
68533: PUSH
68534: LD_INT 3
68536: NEG
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 2
68544: PUSH
68545: LD_INT 1
68547: NEG
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 3
68555: PUSH
68556: LD_INT 1
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 1
68565: PUSH
68566: LD_INT 3
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: LD_INT 2
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 3
68586: NEG
68587: PUSH
68588: LD_INT 2
68590: NEG
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: LIST
68600: LIST
68601: LIST
68602: LIST
68603: LIST
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68621: LD_ADDR_VAR 0 34
68625: PUSH
68626: LD_INT 0
68628: PUSH
68629: LD_INT 0
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: LD_INT 1
68641: NEG
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 1
68649: PUSH
68650: LD_INT 0
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 1
68659: PUSH
68660: LD_INT 1
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: LD_INT 1
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 1
68679: NEG
68680: PUSH
68681: LD_INT 0
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 1
68690: NEG
68691: PUSH
68692: LD_INT 1
68694: NEG
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: LD_INT 2
68706: NEG
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 0
68714: PUSH
68715: LD_INT 2
68717: NEG
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 1
68725: PUSH
68726: LD_INT 1
68728: NEG
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 2
68736: PUSH
68737: LD_INT 1
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 2
68746: PUSH
68747: LD_INT 2
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 1
68756: PUSH
68757: LD_INT 2
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 1
68766: NEG
68767: PUSH
68768: LD_INT 1
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 2
68777: NEG
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 2
68788: NEG
68789: PUSH
68790: LD_INT 1
68792: NEG
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 2
68800: NEG
68801: PUSH
68802: LD_INT 2
68804: NEG
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: PUSH
68810: LD_INT 1
68812: NEG
68813: PUSH
68814: LD_INT 3
68816: NEG
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 1
68824: PUSH
68825: LD_INT 2
68827: NEG
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 3
68835: PUSH
68836: LD_INT 2
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 2
68845: PUSH
68846: LD_INT 3
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 2
68855: NEG
68856: PUSH
68857: LD_INT 1
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PUSH
68864: LD_INT 3
68866: NEG
68867: PUSH
68868: LD_INT 1
68870: NEG
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68901: LD_ADDR_VAR 0 35
68905: PUSH
68906: LD_INT 0
68908: PUSH
68909: LD_INT 0
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: LD_INT 0
68918: PUSH
68919: LD_INT 1
68921: NEG
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 1
68929: PUSH
68930: LD_INT 0
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: LD_INT 1
68939: PUSH
68940: LD_INT 1
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 0
68949: PUSH
68950: LD_INT 1
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: NEG
68960: PUSH
68961: LD_INT 0
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 1
68970: NEG
68971: PUSH
68972: LD_INT 1
68974: NEG
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 2
68982: PUSH
68983: LD_INT 1
68985: PUSH
68986: EMPTY
68987: LIST
68988: LIST
68989: PUSH
68990: LD_INT 2
68992: NEG
68993: PUSH
68994: LD_INT 1
68996: NEG
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: LIST
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: LIST
69011: LIST
69012: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69013: LD_ADDR_VAR 0 36
69017: PUSH
69018: LD_INT 0
69020: PUSH
69021: LD_INT 0
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 0
69030: PUSH
69031: LD_INT 1
69033: NEG
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: LD_INT 0
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 1
69051: PUSH
69052: LD_INT 1
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 0
69061: PUSH
69062: LD_INT 1
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 1
69071: NEG
69072: PUSH
69073: LD_INT 0
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PUSH
69080: LD_INT 1
69082: NEG
69083: PUSH
69084: LD_INT 1
69086: NEG
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: LD_INT 2
69098: NEG
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 1
69106: PUSH
69107: LD_INT 2
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: LIST
69123: LIST
69124: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69125: LD_ADDR_VAR 0 37
69129: PUSH
69130: LD_INT 0
69132: PUSH
69133: LD_INT 0
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 0
69142: PUSH
69143: LD_INT 1
69145: NEG
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: LD_INT 1
69153: PUSH
69154: LD_INT 0
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 1
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 0
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 1
69183: NEG
69184: PUSH
69185: LD_INT 0
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: LD_INT 1
69194: NEG
69195: PUSH
69196: LD_INT 1
69198: NEG
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: LD_INT 1
69209: NEG
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 1
69217: NEG
69218: PUSH
69219: LD_INT 1
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69237: LD_ADDR_VAR 0 38
69241: PUSH
69242: LD_INT 0
69244: PUSH
69245: LD_INT 0
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 0
69254: PUSH
69255: LD_INT 1
69257: NEG
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 1
69265: PUSH
69266: LD_INT 0
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: LD_INT 1
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 0
69285: PUSH
69286: LD_INT 1
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 1
69295: NEG
69296: PUSH
69297: LD_INT 0
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: LD_INT 1
69306: NEG
69307: PUSH
69308: LD_INT 1
69310: NEG
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: PUSH
69316: LD_INT 2
69318: PUSH
69319: LD_INT 1
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: LD_INT 2
69328: NEG
69329: PUSH
69330: LD_INT 1
69332: NEG
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69349: LD_ADDR_VAR 0 39
69353: PUSH
69354: LD_INT 0
69356: PUSH
69357: LD_INT 0
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 0
69366: PUSH
69367: LD_INT 1
69369: NEG
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: LD_INT 1
69377: PUSH
69378: LD_INT 0
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 1
69387: PUSH
69388: LD_INT 1
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 0
69397: PUSH
69398: LD_INT 1
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 1
69407: NEG
69408: PUSH
69409: LD_INT 0
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: PUSH
69416: LD_INT 1
69418: NEG
69419: PUSH
69420: LD_INT 1
69422: NEG
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 1
69430: NEG
69431: PUSH
69432: LD_INT 2
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: PUSH
69443: LD_INT 2
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69461: LD_ADDR_VAR 0 40
69465: PUSH
69466: LD_INT 0
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 0
69478: PUSH
69479: LD_INT 1
69481: NEG
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 1
69489: PUSH
69490: LD_INT 0
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: LD_INT 1
69499: PUSH
69500: LD_INT 1
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PUSH
69507: LD_INT 0
69509: PUSH
69510: LD_INT 1
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 1
69519: NEG
69520: PUSH
69521: LD_INT 0
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: PUSH
69528: LD_INT 1
69530: NEG
69531: PUSH
69532: LD_INT 1
69534: NEG
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 1
69542: PUSH
69543: LD_INT 1
69545: NEG
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 1
69553: NEG
69554: PUSH
69555: LD_INT 1
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69573: LD_ADDR_VAR 0 41
69577: PUSH
69578: LD_INT 0
69580: PUSH
69581: LD_INT 0
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: LD_INT 0
69590: PUSH
69591: LD_INT 1
69593: NEG
69594: PUSH
69595: EMPTY
69596: LIST
69597: LIST
69598: PUSH
69599: LD_INT 1
69601: PUSH
69602: LD_INT 0
69604: PUSH
69605: EMPTY
69606: LIST
69607: LIST
69608: PUSH
69609: LD_INT 1
69611: PUSH
69612: LD_INT 1
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 0
69621: PUSH
69622: LD_INT 1
69624: PUSH
69625: EMPTY
69626: LIST
69627: LIST
69628: PUSH
69629: LD_INT 1
69631: NEG
69632: PUSH
69633: LD_INT 0
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 1
69642: NEG
69643: PUSH
69644: LD_INT 1
69646: NEG
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 1
69654: NEG
69655: PUSH
69656: LD_INT 2
69658: NEG
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: LD_INT 1
69666: PUSH
69667: LD_INT 1
69669: NEG
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 2
69677: PUSH
69678: LD_INT 0
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: LD_INT 2
69687: PUSH
69688: LD_INT 1
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 2
69697: PUSH
69698: LD_INT 2
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 1
69707: PUSH
69708: LD_INT 2
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 1
69717: NEG
69718: PUSH
69719: LD_INT 1
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 2
69728: NEG
69729: PUSH
69730: LD_INT 0
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: PUSH
69737: LD_INT 2
69739: NEG
69740: PUSH
69741: LD_INT 1
69743: NEG
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 2
69751: NEG
69752: PUSH
69753: LD_INT 2
69755: NEG
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 2
69763: NEG
69764: PUSH
69765: LD_INT 3
69767: NEG
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 2
69775: PUSH
69776: LD_INT 1
69778: NEG
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 3
69786: PUSH
69787: LD_INT 0
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 3
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 3
69806: PUSH
69807: LD_INT 2
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 3
69816: PUSH
69817: LD_INT 3
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 2
69826: PUSH
69827: LD_INT 3
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 2
69836: NEG
69837: PUSH
69838: LD_INT 1
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 3
69847: NEG
69848: PUSH
69849: LD_INT 0
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 3
69858: NEG
69859: PUSH
69860: LD_INT 1
69862: NEG
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 3
69870: NEG
69871: PUSH
69872: LD_INT 2
69874: NEG
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 3
69882: NEG
69883: PUSH
69884: LD_INT 3
69886: NEG
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: LIST
69896: LIST
69897: LIST
69898: LIST
69899: LIST
69900: LIST
69901: LIST
69902: LIST
69903: LIST
69904: LIST
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69923: LD_ADDR_VAR 0 42
69927: PUSH
69928: LD_INT 0
69930: PUSH
69931: LD_INT 0
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: PUSH
69938: LD_INT 0
69940: PUSH
69941: LD_INT 1
69943: NEG
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 1
69951: PUSH
69952: LD_INT 0
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: LD_INT 1
69961: PUSH
69962: LD_INT 1
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 0
69971: PUSH
69972: LD_INT 1
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 1
69981: NEG
69982: PUSH
69983: LD_INT 0
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 1
69992: NEG
69993: PUSH
69994: LD_INT 1
69996: NEG
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 1
70004: NEG
70005: PUSH
70006: LD_INT 2
70008: NEG
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 0
70016: PUSH
70017: LD_INT 2
70019: NEG
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 1
70027: PUSH
70028: LD_INT 1
70030: NEG
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 2
70038: PUSH
70039: LD_INT 1
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 2
70048: PUSH
70049: LD_INT 2
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 1
70058: PUSH
70059: LD_INT 2
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 0
70068: PUSH
70069: LD_INT 2
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 1
70078: NEG
70079: PUSH
70080: LD_INT 1
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 2
70089: NEG
70090: PUSH
70091: LD_INT 1
70093: NEG
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: PUSH
70099: LD_INT 2
70101: NEG
70102: PUSH
70103: LD_INT 2
70105: NEG
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: NEG
70114: PUSH
70115: LD_INT 3
70117: NEG
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PUSH
70123: LD_INT 1
70125: NEG
70126: PUSH
70127: LD_INT 3
70129: NEG
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 0
70137: PUSH
70138: LD_INT 3
70140: NEG
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 1
70148: PUSH
70149: LD_INT 2
70151: NEG
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 3
70159: PUSH
70160: LD_INT 2
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 3
70169: PUSH
70170: LD_INT 3
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 2
70179: PUSH
70180: LD_INT 3
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 1
70189: PUSH
70190: LD_INT 3
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 0
70199: PUSH
70200: LD_INT 3
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PUSH
70207: LD_INT 1
70209: NEG
70210: PUSH
70211: LD_INT 2
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: LD_INT 3
70220: NEG
70221: PUSH
70222: LD_INT 2
70224: NEG
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 3
70232: NEG
70233: PUSH
70234: LD_INT 3
70236: NEG
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: LIST
70264: LIST
70265: LIST
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70273: LD_ADDR_VAR 0 43
70277: PUSH
70278: LD_INT 0
70280: PUSH
70281: LD_INT 0
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: LD_INT 0
70290: PUSH
70291: LD_INT 1
70293: NEG
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: PUSH
70299: LD_INT 1
70301: PUSH
70302: LD_INT 0
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: PUSH
70309: LD_INT 1
70311: PUSH
70312: LD_INT 1
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: LD_INT 1
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 1
70331: NEG
70332: PUSH
70333: LD_INT 0
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PUSH
70340: LD_INT 1
70342: NEG
70343: PUSH
70344: LD_INT 1
70346: NEG
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: LD_INT 1
70354: NEG
70355: PUSH
70356: LD_INT 2
70358: NEG
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 0
70366: PUSH
70367: LD_INT 2
70369: NEG
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: PUSH
70375: LD_INT 1
70377: PUSH
70378: LD_INT 1
70380: NEG
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 2
70388: PUSH
70389: LD_INT 0
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 2
70398: PUSH
70399: LD_INT 1
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: PUSH
70409: LD_INT 2
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: PUSH
70416: LD_INT 0
70418: PUSH
70419: LD_INT 2
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 1
70428: NEG
70429: PUSH
70430: LD_INT 1
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 2
70439: NEG
70440: PUSH
70441: LD_INT 0
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 2
70450: NEG
70451: PUSH
70452: LD_INT 1
70454: NEG
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: LD_INT 1
70462: NEG
70463: PUSH
70464: LD_INT 3
70466: NEG
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: PUSH
70472: LD_INT 0
70474: PUSH
70475: LD_INT 3
70477: NEG
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 1
70485: PUSH
70486: LD_INT 2
70488: NEG
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PUSH
70494: LD_INT 2
70496: PUSH
70497: LD_INT 1
70499: NEG
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 3
70507: PUSH
70508: LD_INT 0
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 3
70517: PUSH
70518: LD_INT 1
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 1
70527: PUSH
70528: LD_INT 3
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 0
70537: PUSH
70538: LD_INT 3
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 1
70547: NEG
70548: PUSH
70549: LD_INT 2
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 2
70558: NEG
70559: PUSH
70560: LD_INT 1
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 3
70569: NEG
70570: PUSH
70571: LD_INT 0
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 3
70580: NEG
70581: PUSH
70582: LD_INT 1
70584: NEG
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: LIST
70596: LIST
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: LIST
70602: LIST
70603: LIST
70604: LIST
70605: LIST
70606: LIST
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70621: LD_ADDR_VAR 0 44
70625: PUSH
70626: LD_INT 0
70628: PUSH
70629: LD_INT 0
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: LD_INT 1
70641: NEG
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 1
70649: PUSH
70650: LD_INT 0
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: PUSH
70657: LD_INT 1
70659: PUSH
70660: LD_INT 1
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 0
70669: PUSH
70670: LD_INT 1
70672: PUSH
70673: EMPTY
70674: LIST
70675: LIST
70676: PUSH
70677: LD_INT 1
70679: NEG
70680: PUSH
70681: LD_INT 0
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 1
70690: NEG
70691: PUSH
70692: LD_INT 1
70694: NEG
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 1
70702: NEG
70703: PUSH
70704: LD_INT 2
70706: NEG
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: LD_INT 1
70717: NEG
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: LD_INT 2
70725: PUSH
70726: LD_INT 0
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 2
70735: PUSH
70736: LD_INT 1
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: LD_INT 2
70745: PUSH
70746: LD_INT 2
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: LD_INT 2
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: LD_INT 1
70765: NEG
70766: PUSH
70767: LD_INT 1
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 2
70776: NEG
70777: PUSH
70778: LD_INT 0
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 2
70787: NEG
70788: PUSH
70789: LD_INT 1
70791: NEG
70792: PUSH
70793: EMPTY
70794: LIST
70795: LIST
70796: PUSH
70797: LD_INT 2
70799: NEG
70800: PUSH
70801: LD_INT 2
70803: NEG
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 2
70811: NEG
70812: PUSH
70813: LD_INT 3
70815: NEG
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: LD_INT 1
70826: NEG
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 3
70834: PUSH
70835: LD_INT 0
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 3
70844: PUSH
70845: LD_INT 1
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 3
70854: PUSH
70855: LD_INT 2
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 3
70864: PUSH
70865: LD_INT 3
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 2
70874: PUSH
70875: LD_INT 3
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: NEG
70885: PUSH
70886: LD_INT 1
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 3
70895: NEG
70896: PUSH
70897: LD_INT 0
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 3
70906: NEG
70907: PUSH
70908: LD_INT 1
70910: NEG
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 3
70918: NEG
70919: PUSH
70920: LD_INT 2
70922: NEG
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 3
70930: NEG
70931: PUSH
70932: LD_INT 3
70934: NEG
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: LIST
70956: LIST
70957: LIST
70958: LIST
70959: LIST
70960: LIST
70961: LIST
70962: LIST
70963: LIST
70964: LIST
70965: LIST
70966: LIST
70967: LIST
70968: LIST
70969: LIST
70970: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70971: LD_ADDR_VAR 0 45
70975: PUSH
70976: LD_INT 0
70978: PUSH
70979: LD_INT 0
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: PUSH
70986: LD_INT 0
70988: PUSH
70989: LD_INT 1
70991: NEG
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 1
70999: PUSH
71000: LD_INT 0
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: PUSH
71010: LD_INT 1
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 0
71019: PUSH
71020: LD_INT 1
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 1
71029: NEG
71030: PUSH
71031: LD_INT 0
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 1
71040: NEG
71041: PUSH
71042: LD_INT 1
71044: NEG
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 1
71052: NEG
71053: PUSH
71054: LD_INT 2
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: LD_INT 2
71067: NEG
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 1
71075: PUSH
71076: LD_INT 1
71078: NEG
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: PUSH
71084: LD_INT 2
71086: PUSH
71087: LD_INT 1
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: PUSH
71094: LD_INT 2
71096: PUSH
71097: LD_INT 2
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 1
71106: PUSH
71107: LD_INT 2
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 0
71116: PUSH
71117: LD_INT 2
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 1
71126: NEG
71127: PUSH
71128: LD_INT 1
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 2
71137: NEG
71138: PUSH
71139: LD_INT 1
71141: NEG
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 2
71149: NEG
71150: PUSH
71151: LD_INT 2
71153: NEG
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 2
71161: NEG
71162: PUSH
71163: LD_INT 3
71165: NEG
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: LD_INT 3
71177: NEG
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: PUSH
71183: LD_INT 0
71185: PUSH
71186: LD_INT 3
71188: NEG
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: LD_INT 2
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 3
71207: PUSH
71208: LD_INT 2
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 3
71217: PUSH
71218: LD_INT 3
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: LD_INT 2
71227: PUSH
71228: LD_INT 3
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 1
71237: PUSH
71238: LD_INT 3
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 0
71247: PUSH
71248: LD_INT 3
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 1
71257: NEG
71258: PUSH
71259: LD_INT 2
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 3
71268: NEG
71269: PUSH
71270: LD_INT 2
71272: NEG
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 3
71280: NEG
71281: PUSH
71282: LD_INT 3
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71321: LD_ADDR_VAR 0 46
71325: PUSH
71326: LD_INT 0
71328: PUSH
71329: LD_INT 0
71331: PUSH
71332: EMPTY
71333: LIST
71334: LIST
71335: PUSH
71336: LD_INT 0
71338: PUSH
71339: LD_INT 1
71341: NEG
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: LD_INT 1
71349: PUSH
71350: LD_INT 0
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 1
71359: PUSH
71360: LD_INT 1
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 0
71369: PUSH
71370: LD_INT 1
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 1
71379: NEG
71380: PUSH
71381: LD_INT 0
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: LD_INT 1
71390: NEG
71391: PUSH
71392: LD_INT 1
71394: NEG
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 1
71402: NEG
71403: PUSH
71404: LD_INT 2
71406: NEG
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 0
71414: PUSH
71415: LD_INT 2
71417: NEG
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 1
71425: PUSH
71426: LD_INT 1
71428: NEG
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 2
71436: PUSH
71437: LD_INT 0
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 2
71446: PUSH
71447: LD_INT 1
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: PUSH
71457: LD_INT 2
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 0
71466: PUSH
71467: LD_INT 2
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 1
71476: NEG
71477: PUSH
71478: LD_INT 1
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 2
71487: NEG
71488: PUSH
71489: LD_INT 0
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 2
71498: NEG
71499: PUSH
71500: LD_INT 1
71502: NEG
71503: PUSH
71504: EMPTY
71505: LIST
71506: LIST
71507: PUSH
71508: LD_INT 1
71510: NEG
71511: PUSH
71512: LD_INT 3
71514: NEG
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: PUSH
71520: LD_INT 0
71522: PUSH
71523: LD_INT 3
71525: NEG
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 1
71533: PUSH
71534: LD_INT 2
71536: NEG
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 2
71544: PUSH
71545: LD_INT 1
71547: NEG
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 3
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 3
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 1
71575: PUSH
71576: LD_INT 3
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 0
71585: PUSH
71586: LD_INT 3
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 1
71595: NEG
71596: PUSH
71597: LD_INT 2
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 2
71606: NEG
71607: PUSH
71608: LD_INT 1
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 3
71617: NEG
71618: PUSH
71619: LD_INT 0
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 3
71628: NEG
71629: PUSH
71630: LD_INT 1
71632: NEG
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: LIST
71655: LIST
71656: LIST
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71669: LD_ADDR_VAR 0 47
71673: PUSH
71674: LD_INT 0
71676: PUSH
71677: LD_INT 0
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: LD_INT 1
71689: NEG
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: LD_INT 1
71697: PUSH
71698: LD_INT 0
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 1
71707: PUSH
71708: LD_INT 1
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 0
71717: PUSH
71718: LD_INT 1
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: LD_INT 1
71727: NEG
71728: PUSH
71729: LD_INT 0
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 1
71738: NEG
71739: PUSH
71740: LD_INT 1
71742: NEG
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 1
71750: NEG
71751: PUSH
71752: LD_INT 2
71754: NEG
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 0
71762: PUSH
71763: LD_INT 2
71765: NEG
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 1
71773: PUSH
71774: LD_INT 1
71776: NEG
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 2
71784: NEG
71785: PUSH
71786: LD_INT 1
71788: NEG
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 2
71796: NEG
71797: PUSH
71798: LD_INT 2
71800: NEG
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71820: LD_ADDR_VAR 0 48
71824: PUSH
71825: LD_INT 0
71827: PUSH
71828: LD_INT 0
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 0
71837: PUSH
71838: LD_INT 1
71840: NEG
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 1
71848: PUSH
71849: LD_INT 0
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: PUSH
71856: LD_INT 1
71858: PUSH
71859: LD_INT 1
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: PUSH
71866: LD_INT 0
71868: PUSH
71869: LD_INT 1
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 1
71878: NEG
71879: PUSH
71880: LD_INT 0
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 1
71889: NEG
71890: PUSH
71891: LD_INT 1
71893: NEG
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 1
71901: NEG
71902: PUSH
71903: LD_INT 2
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 0
71913: PUSH
71914: LD_INT 2
71916: NEG
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 1
71924: PUSH
71925: LD_INT 1
71927: NEG
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 2
71935: PUSH
71936: LD_INT 0
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 2
71945: PUSH
71946: LD_INT 1
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71967: LD_ADDR_VAR 0 49
71971: PUSH
71972: LD_INT 0
71974: PUSH
71975: LD_INT 0
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 0
71984: PUSH
71985: LD_INT 1
71987: NEG
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 1
71995: PUSH
71996: LD_INT 0
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 1
72005: PUSH
72006: LD_INT 1
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 0
72015: PUSH
72016: LD_INT 1
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 1
72025: NEG
72026: PUSH
72027: LD_INT 0
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 1
72036: NEG
72037: PUSH
72038: LD_INT 1
72040: NEG
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 1
72048: PUSH
72049: LD_INT 1
72051: NEG
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 2
72059: PUSH
72060: LD_INT 0
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 2
72069: PUSH
72070: LD_INT 1
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: LD_INT 2
72079: PUSH
72080: LD_INT 2
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 1
72089: PUSH
72090: LD_INT 2
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72111: LD_ADDR_VAR 0 50
72115: PUSH
72116: LD_INT 0
72118: PUSH
72119: LD_INT 0
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 0
72128: PUSH
72129: LD_INT 1
72131: NEG
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 1
72139: PUSH
72140: LD_INT 0
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 1
72149: PUSH
72150: LD_INT 1
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 0
72159: PUSH
72160: LD_INT 1
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: LD_INT 0
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: LD_INT 1
72184: NEG
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 2
72192: PUSH
72193: LD_INT 1
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 2
72202: PUSH
72203: LD_INT 2
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 1
72212: PUSH
72213: LD_INT 2
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: LD_INT 0
72222: PUSH
72223: LD_INT 2
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 1
72232: NEG
72233: PUSH
72234: LD_INT 1
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: LIST
72248: LIST
72249: LIST
72250: LIST
72251: LIST
72252: LIST
72253: LIST
72254: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72255: LD_ADDR_VAR 0 51
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 0
72272: PUSH
72273: LD_INT 1
72275: NEG
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: PUSH
72284: LD_INT 0
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 1
72293: PUSH
72294: LD_INT 1
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: LD_INT 0
72303: PUSH
72304: LD_INT 1
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 1
72313: NEG
72314: PUSH
72315: LD_INT 0
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 1
72324: NEG
72325: PUSH
72326: LD_INT 1
72328: NEG
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 1
72336: PUSH
72337: LD_INT 2
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 2
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 1
72356: NEG
72357: PUSH
72358: LD_INT 1
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 2
72367: NEG
72368: PUSH
72369: LD_INT 0
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 2
72378: NEG
72379: PUSH
72380: LD_INT 1
72382: NEG
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72402: LD_ADDR_VAR 0 52
72406: PUSH
72407: LD_INT 0
72409: PUSH
72410: LD_INT 0
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 0
72419: PUSH
72420: LD_INT 1
72422: NEG
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PUSH
72428: LD_INT 1
72430: PUSH
72431: LD_INT 0
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 1
72440: PUSH
72441: LD_INT 1
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 0
72450: PUSH
72451: LD_INT 1
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: LD_INT 1
72460: NEG
72461: PUSH
72462: LD_INT 0
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: LD_INT 1
72471: NEG
72472: PUSH
72473: LD_INT 1
72475: NEG
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PUSH
72481: LD_INT 1
72483: NEG
72484: PUSH
72485: LD_INT 2
72487: NEG
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 1
72495: NEG
72496: PUSH
72497: LD_INT 1
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PUSH
72504: LD_INT 2
72506: NEG
72507: PUSH
72508: LD_INT 0
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 2
72517: NEG
72518: PUSH
72519: LD_INT 1
72521: NEG
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 2
72529: NEG
72530: PUSH
72531: LD_INT 2
72533: NEG
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: LIST
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72553: LD_ADDR_VAR 0 53
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: LD_INT 0
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 0
72570: PUSH
72571: LD_INT 1
72573: NEG
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: LD_INT 1
72581: PUSH
72582: LD_INT 0
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 1
72591: PUSH
72592: LD_INT 1
72594: PUSH
72595: EMPTY
72596: LIST
72597: LIST
72598: PUSH
72599: LD_INT 0
72601: PUSH
72602: LD_INT 1
72604: PUSH
72605: EMPTY
72606: LIST
72607: LIST
72608: PUSH
72609: LD_INT 1
72611: NEG
72612: PUSH
72613: LD_INT 0
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 1
72622: NEG
72623: PUSH
72624: LD_INT 1
72626: NEG
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 1
72634: NEG
72635: PUSH
72636: LD_INT 2
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 0
72646: PUSH
72647: LD_INT 2
72649: NEG
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 1
72657: PUSH
72658: LD_INT 1
72660: NEG
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 2
72668: PUSH
72669: LD_INT 0
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 2
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 2
72688: PUSH
72689: LD_INT 2
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 1
72698: PUSH
72699: LD_INT 2
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 0
72708: PUSH
72709: LD_INT 2
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 1
72718: NEG
72719: PUSH
72720: LD_INT 1
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 2
72729: NEG
72730: PUSH
72731: LD_INT 0
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 2
72740: NEG
72741: PUSH
72742: LD_INT 1
72744: NEG
72745: PUSH
72746: EMPTY
72747: LIST
72748: LIST
72749: PUSH
72750: LD_INT 2
72752: NEG
72753: PUSH
72754: LD_INT 2
72756: NEG
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: LIST
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72783: LD_ADDR_VAR 0 54
72787: PUSH
72788: LD_INT 0
72790: PUSH
72791: LD_INT 0
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: LD_INT 1
72803: NEG
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 1
72811: PUSH
72812: LD_INT 0
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: PUSH
72819: LD_INT 1
72821: PUSH
72822: LD_INT 1
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: LD_INT 1
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 1
72841: NEG
72842: PUSH
72843: LD_INT 0
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 1
72852: NEG
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 1
72864: NEG
72865: PUSH
72866: LD_INT 2
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 0
72876: PUSH
72877: LD_INT 2
72879: NEG
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 1
72887: PUSH
72888: LD_INT 1
72890: NEG
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 2
72898: PUSH
72899: LD_INT 0
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 2
72908: PUSH
72909: LD_INT 1
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 2
72918: PUSH
72919: LD_INT 2
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 1
72928: PUSH
72929: LD_INT 2
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 0
72938: PUSH
72939: LD_INT 2
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: NEG
72949: PUSH
72950: LD_INT 1
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 2
72959: NEG
72960: PUSH
72961: LD_INT 0
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: PUSH
72968: LD_INT 2
72970: NEG
72971: PUSH
72972: LD_INT 1
72974: NEG
72975: PUSH
72976: EMPTY
72977: LIST
72978: LIST
72979: PUSH
72980: LD_INT 2
72982: NEG
72983: PUSH
72984: LD_INT 2
72986: NEG
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: LIST
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73013: LD_ADDR_VAR 0 55
73017: PUSH
73018: LD_INT 0
73020: PUSH
73021: LD_INT 0
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: LD_INT 1
73033: NEG
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 1
73041: PUSH
73042: LD_INT 0
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 1
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 0
73061: PUSH
73062: LD_INT 1
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 1
73071: NEG
73072: PUSH
73073: LD_INT 0
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 1
73082: NEG
73083: PUSH
73084: LD_INT 1
73086: NEG
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 1
73094: NEG
73095: PUSH
73096: LD_INT 2
73098: NEG
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 0
73106: PUSH
73107: LD_INT 2
73109: NEG
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: PUSH
73115: LD_INT 1
73117: PUSH
73118: LD_INT 1
73120: NEG
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 2
73128: PUSH
73129: LD_INT 0
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 2
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 2
73148: PUSH
73149: LD_INT 2
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 1
73158: PUSH
73159: LD_INT 2
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: LD_INT 2
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 1
73178: NEG
73179: PUSH
73180: LD_INT 1
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 2
73189: NEG
73190: PUSH
73191: LD_INT 0
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 2
73200: NEG
73201: PUSH
73202: LD_INT 1
73204: NEG
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PUSH
73210: LD_INT 2
73212: NEG
73213: PUSH
73214: LD_INT 2
73216: NEG
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73243: LD_ADDR_VAR 0 56
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 0
73260: PUSH
73261: LD_INT 1
73263: NEG
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 1
73271: PUSH
73272: LD_INT 0
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 1
73281: PUSH
73282: LD_INT 1
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 0
73291: PUSH
73292: LD_INT 1
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 1
73301: NEG
73302: PUSH
73303: LD_INT 0
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 1
73312: NEG
73313: PUSH
73314: LD_INT 1
73316: NEG
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 1
73324: NEG
73325: PUSH
73326: LD_INT 2
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 0
73336: PUSH
73337: LD_INT 2
73339: NEG
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 1
73347: PUSH
73348: LD_INT 1
73350: NEG
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 2
73358: PUSH
73359: LD_INT 0
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 2
73368: PUSH
73369: LD_INT 1
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 2
73378: PUSH
73379: LD_INT 2
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 1
73388: PUSH
73389: LD_INT 2
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: LD_INT 0
73398: PUSH
73399: LD_INT 2
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: LD_INT 1
73408: NEG
73409: PUSH
73410: LD_INT 1
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 2
73419: NEG
73420: PUSH
73421: LD_INT 0
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 2
73430: NEG
73431: PUSH
73432: LD_INT 1
73434: NEG
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 2
73442: NEG
73443: PUSH
73444: LD_INT 2
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73473: LD_ADDR_VAR 0 57
73477: PUSH
73478: LD_INT 0
73480: PUSH
73481: LD_INT 0
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: PUSH
73488: LD_INT 0
73490: PUSH
73491: LD_INT 1
73493: NEG
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: LD_INT 1
73501: PUSH
73502: LD_INT 0
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: LD_INT 1
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 0
73521: PUSH
73522: LD_INT 1
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: LD_INT 1
73531: NEG
73532: PUSH
73533: LD_INT 0
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PUSH
73540: LD_INT 1
73542: NEG
73543: PUSH
73544: LD_INT 1
73546: NEG
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 1
73554: NEG
73555: PUSH
73556: LD_INT 2
73558: NEG
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 0
73566: PUSH
73567: LD_INT 2
73569: NEG
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PUSH
73575: LD_INT 1
73577: PUSH
73578: LD_INT 1
73580: NEG
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 2
73588: PUSH
73589: LD_INT 0
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 2
73598: PUSH
73599: LD_INT 1
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 2
73608: PUSH
73609: LD_INT 2
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 2
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 0
73628: PUSH
73629: LD_INT 2
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 1
73638: NEG
73639: PUSH
73640: LD_INT 1
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 2
73649: NEG
73650: PUSH
73651: LD_INT 0
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 2
73660: NEG
73661: PUSH
73662: LD_INT 1
73664: NEG
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 2
73672: NEG
73673: PUSH
73674: LD_INT 2
73676: NEG
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: LIST
73686: LIST
73687: LIST
73688: LIST
73689: LIST
73690: LIST
73691: LIST
73692: LIST
73693: LIST
73694: LIST
73695: LIST
73696: LIST
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73703: LD_ADDR_VAR 0 58
73707: PUSH
73708: LD_INT 0
73710: PUSH
73711: LD_INT 0
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 0
73720: PUSH
73721: LD_INT 1
73723: NEG
73724: PUSH
73725: EMPTY
73726: LIST
73727: LIST
73728: PUSH
73729: LD_INT 1
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 1
73741: PUSH
73742: LD_INT 1
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 0
73751: PUSH
73752: LD_INT 1
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 1
73761: NEG
73762: PUSH
73763: LD_INT 0
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 1
73772: NEG
73773: PUSH
73774: LD_INT 1
73776: NEG
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 1
73784: NEG
73785: PUSH
73786: LD_INT 2
73788: NEG
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: LD_INT 2
73799: NEG
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 1
73807: PUSH
73808: LD_INT 1
73810: NEG
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: PUSH
73816: LD_INT 2
73818: PUSH
73819: LD_INT 0
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 2
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 2
73838: PUSH
73839: LD_INT 2
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: PUSH
73849: LD_INT 2
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 0
73858: PUSH
73859: LD_INT 2
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 1
73868: NEG
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 2
73879: NEG
73880: PUSH
73881: LD_INT 0
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 2
73890: NEG
73891: PUSH
73892: LD_INT 1
73894: NEG
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 2
73902: NEG
73903: PUSH
73904: LD_INT 2
73906: NEG
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73933: LD_ADDR_VAR 0 59
73937: PUSH
73938: LD_INT 0
73940: PUSH
73941: LD_INT 0
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PUSH
73948: LD_INT 0
73950: PUSH
73951: LD_INT 1
73953: NEG
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 1
73961: PUSH
73962: LD_INT 0
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 1
73971: PUSH
73972: LD_INT 1
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 0
73981: PUSH
73982: LD_INT 1
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 1
73991: NEG
73992: PUSH
73993: LD_INT 0
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 1
74002: NEG
74003: PUSH
74004: LD_INT 1
74006: NEG
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: LIST
74020: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74021: LD_ADDR_VAR 0 60
74025: PUSH
74026: LD_INT 0
74028: PUSH
74029: LD_INT 0
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 0
74038: PUSH
74039: LD_INT 1
74041: NEG
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: LD_INT 0
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 1
74059: PUSH
74060: LD_INT 1
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: PUSH
74067: LD_INT 0
74069: PUSH
74070: LD_INT 1
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: LD_INT 1
74079: NEG
74080: PUSH
74081: LD_INT 0
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: LD_INT 1
74094: NEG
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: LIST
74104: LIST
74105: LIST
74106: LIST
74107: LIST
74108: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74109: LD_ADDR_VAR 0 61
74113: PUSH
74114: LD_INT 0
74116: PUSH
74117: LD_INT 0
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: PUSH
74124: LD_INT 0
74126: PUSH
74127: LD_INT 1
74129: NEG
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: PUSH
74135: LD_INT 1
74137: PUSH
74138: LD_INT 0
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: PUSH
74145: LD_INT 1
74147: PUSH
74148: LD_INT 1
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: PUSH
74155: LD_INT 0
74157: PUSH
74158: LD_INT 1
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 1
74167: NEG
74168: PUSH
74169: LD_INT 0
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 1
74178: NEG
74179: PUSH
74180: LD_INT 1
74182: NEG
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: LIST
74196: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74197: LD_ADDR_VAR 0 62
74201: PUSH
74202: LD_INT 0
74204: PUSH
74205: LD_INT 0
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 0
74214: PUSH
74215: LD_INT 1
74217: NEG
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: PUSH
74223: LD_INT 1
74225: PUSH
74226: LD_INT 0
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 1
74235: PUSH
74236: LD_INT 1
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PUSH
74243: LD_INT 0
74245: PUSH
74246: LD_INT 1
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 1
74255: NEG
74256: PUSH
74257: LD_INT 0
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: LD_INT 1
74270: NEG
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74285: LD_ADDR_VAR 0 63
74289: PUSH
74290: LD_INT 0
74292: PUSH
74293: LD_INT 0
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 0
74302: PUSH
74303: LD_INT 1
74305: NEG
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 1
74313: PUSH
74314: LD_INT 0
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 1
74323: PUSH
74324: LD_INT 1
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 0
74333: PUSH
74334: LD_INT 1
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 1
74343: NEG
74344: PUSH
74345: LD_INT 0
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 1
74354: NEG
74355: PUSH
74356: LD_INT 1
74358: NEG
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: LIST
74368: LIST
74369: LIST
74370: LIST
74371: LIST
74372: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74373: LD_ADDR_VAR 0 64
74377: PUSH
74378: LD_INT 0
74380: PUSH
74381: LD_INT 0
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: LD_INT 0
74390: PUSH
74391: LD_INT 1
74393: NEG
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: LD_INT 1
74401: PUSH
74402: LD_INT 0
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: PUSH
74409: LD_INT 1
74411: PUSH
74412: LD_INT 1
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 0
74421: PUSH
74422: LD_INT 1
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 1
74431: NEG
74432: PUSH
74433: LD_INT 0
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: LD_INT 1
74442: NEG
74443: PUSH
74444: LD_INT 1
74446: NEG
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: ST_TO_ADDR
// end ; 1 :
74461: GO 80358
74463: LD_INT 1
74465: DOUBLE
74466: EQUAL
74467: IFTRUE 74471
74469: GO 77094
74471: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74472: LD_ADDR_VAR 0 11
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: LD_INT 3
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: LD_INT 3
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 1
74502: PUSH
74503: LD_INT 2
74505: NEG
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: LIST
74515: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74516: LD_ADDR_VAR 0 12
74520: PUSH
74521: LD_INT 2
74523: PUSH
74524: LD_INT 1
74526: NEG
74527: PUSH
74528: EMPTY
74529: LIST
74530: LIST
74531: PUSH
74532: LD_INT 3
74534: PUSH
74535: LD_INT 0
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 3
74544: PUSH
74545: LD_INT 1
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: EMPTY
74553: LIST
74554: LIST
74555: LIST
74556: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74557: LD_ADDR_VAR 0 13
74561: PUSH
74562: LD_INT 3
74564: PUSH
74565: LD_INT 2
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 3
74574: PUSH
74575: LD_INT 3
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: LD_INT 2
74584: PUSH
74585: LD_INT 3
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: LIST
74596: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74597: LD_ADDR_VAR 0 14
74601: PUSH
74602: LD_INT 1
74604: PUSH
74605: LD_INT 3
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 0
74614: PUSH
74615: LD_INT 3
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 1
74624: NEG
74625: PUSH
74626: LD_INT 2
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: LIST
74637: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74638: LD_ADDR_VAR 0 15
74642: PUSH
74643: LD_INT 2
74645: NEG
74646: PUSH
74647: LD_INT 1
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 3
74656: NEG
74657: PUSH
74658: LD_INT 0
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 3
74667: NEG
74668: PUSH
74669: LD_INT 1
74671: NEG
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: LIST
74681: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74682: LD_ADDR_VAR 0 16
74686: PUSH
74687: LD_INT 2
74689: NEG
74690: PUSH
74691: LD_INT 3
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 3
74701: NEG
74702: PUSH
74703: LD_INT 2
74705: NEG
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 3
74713: NEG
74714: PUSH
74715: LD_INT 3
74717: NEG
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: LIST
74727: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74728: LD_ADDR_VAR 0 17
74732: PUSH
74733: LD_INT 1
74735: NEG
74736: PUSH
74737: LD_INT 3
74739: NEG
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 0
74747: PUSH
74748: LD_INT 3
74750: NEG
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 1
74758: PUSH
74759: LD_INT 2
74761: NEG
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: LIST
74771: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74772: LD_ADDR_VAR 0 18
74776: PUSH
74777: LD_INT 2
74779: PUSH
74780: LD_INT 1
74782: NEG
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: LD_INT 3
74790: PUSH
74791: LD_INT 0
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: LD_INT 3
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: LIST
74812: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74813: LD_ADDR_VAR 0 19
74817: PUSH
74818: LD_INT 3
74820: PUSH
74821: LD_INT 2
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 3
74830: PUSH
74831: LD_INT 3
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 2
74840: PUSH
74841: LD_INT 3
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: LIST
74852: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74853: LD_ADDR_VAR 0 20
74857: PUSH
74858: LD_INT 1
74860: PUSH
74861: LD_INT 3
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 0
74870: PUSH
74871: LD_INT 3
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 1
74880: NEG
74881: PUSH
74882: LD_INT 2
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: LIST
74893: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74894: LD_ADDR_VAR 0 21
74898: PUSH
74899: LD_INT 2
74901: NEG
74902: PUSH
74903: LD_INT 1
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 3
74912: NEG
74913: PUSH
74914: LD_INT 0
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 3
74923: NEG
74924: PUSH
74925: LD_INT 1
74927: NEG
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: LIST
74937: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74938: LD_ADDR_VAR 0 22
74942: PUSH
74943: LD_INT 2
74945: NEG
74946: PUSH
74947: LD_INT 3
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 3
74957: NEG
74958: PUSH
74959: LD_INT 2
74961: NEG
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 3
74969: NEG
74970: PUSH
74971: LD_INT 3
74973: NEG
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: LIST
74983: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74984: LD_ADDR_VAR 0 23
74988: PUSH
74989: LD_INT 0
74991: PUSH
74992: LD_INT 3
74994: NEG
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 1
75002: NEG
75003: PUSH
75004: LD_INT 4
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: LD_INT 1
75014: PUSH
75015: LD_INT 3
75017: NEG
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: LIST
75027: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75028: LD_ADDR_VAR 0 24
75032: PUSH
75033: LD_INT 3
75035: PUSH
75036: LD_INT 0
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 3
75045: PUSH
75046: LD_INT 1
75048: NEG
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 4
75056: PUSH
75057: LD_INT 1
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: LIST
75068: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75069: LD_ADDR_VAR 0 25
75073: PUSH
75074: LD_INT 3
75076: PUSH
75077: LD_INT 3
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 4
75086: PUSH
75087: LD_INT 3
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 3
75096: PUSH
75097: LD_INT 4
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: LIST
75108: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75109: LD_ADDR_VAR 0 26
75113: PUSH
75114: LD_INT 0
75116: PUSH
75117: LD_INT 3
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 1
75126: PUSH
75127: LD_INT 4
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 1
75136: NEG
75137: PUSH
75138: LD_INT 3
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: LIST
75149: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75150: LD_ADDR_VAR 0 27
75154: PUSH
75155: LD_INT 3
75157: NEG
75158: PUSH
75159: LD_INT 0
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: PUSH
75166: LD_INT 3
75168: NEG
75169: PUSH
75170: LD_INT 1
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: LD_INT 4
75179: NEG
75180: PUSH
75181: LD_INT 1
75183: NEG
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: LIST
75193: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75194: LD_ADDR_VAR 0 28
75198: PUSH
75199: LD_INT 3
75201: NEG
75202: PUSH
75203: LD_INT 3
75205: NEG
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 3
75213: NEG
75214: PUSH
75215: LD_INT 4
75217: NEG
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 4
75225: NEG
75226: PUSH
75227: LD_INT 3
75229: NEG
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: LIST
75239: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75240: LD_ADDR_VAR 0 29
75244: PUSH
75245: LD_INT 1
75247: NEG
75248: PUSH
75249: LD_INT 3
75251: NEG
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 0
75259: PUSH
75260: LD_INT 3
75262: NEG
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 1
75270: PUSH
75271: LD_INT 2
75273: NEG
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 1
75281: NEG
75282: PUSH
75283: LD_INT 4
75285: NEG
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 0
75293: PUSH
75294: LD_INT 4
75296: NEG
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 1
75304: PUSH
75305: LD_INT 3
75307: NEG
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 1
75315: NEG
75316: PUSH
75317: LD_INT 5
75319: NEG
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: LD_INT 5
75330: NEG
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 1
75338: PUSH
75339: LD_INT 4
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 1
75349: NEG
75350: PUSH
75351: LD_INT 6
75353: NEG
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 0
75361: PUSH
75362: LD_INT 6
75364: NEG
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 1
75372: PUSH
75373: LD_INT 5
75375: NEG
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: LIST
75389: LIST
75390: LIST
75391: LIST
75392: LIST
75393: LIST
75394: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75395: LD_ADDR_VAR 0 30
75399: PUSH
75400: LD_INT 2
75402: PUSH
75403: LD_INT 1
75405: NEG
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 3
75413: PUSH
75414: LD_INT 0
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 3
75423: PUSH
75424: LD_INT 1
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 3
75433: PUSH
75434: LD_INT 1
75436: NEG
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 4
75444: PUSH
75445: LD_INT 0
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 4
75454: PUSH
75455: LD_INT 1
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 4
75464: PUSH
75465: LD_INT 1
75467: NEG
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 5
75475: PUSH
75476: LD_INT 0
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 5
75485: PUSH
75486: LD_INT 1
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 5
75495: PUSH
75496: LD_INT 1
75498: NEG
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 6
75506: PUSH
75507: LD_INT 0
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 6
75516: PUSH
75517: LD_INT 1
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75538: LD_ADDR_VAR 0 31
75542: PUSH
75543: LD_INT 3
75545: PUSH
75546: LD_INT 2
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 3
75555: PUSH
75556: LD_INT 3
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 2
75565: PUSH
75566: LD_INT 3
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 4
75575: PUSH
75576: LD_INT 3
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 4
75585: PUSH
75586: LD_INT 4
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: PUSH
75593: LD_INT 3
75595: PUSH
75596: LD_INT 4
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: PUSH
75603: LD_INT 5
75605: PUSH
75606: LD_INT 4
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: PUSH
75613: LD_INT 5
75615: PUSH
75616: LD_INT 5
75618: PUSH
75619: EMPTY
75620: LIST
75621: LIST
75622: PUSH
75623: LD_INT 4
75625: PUSH
75626: LD_INT 5
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 6
75635: PUSH
75636: LD_INT 5
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 6
75645: PUSH
75646: LD_INT 6
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 5
75655: PUSH
75656: LD_INT 6
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: LIST
75667: LIST
75668: LIST
75669: LIST
75670: LIST
75671: LIST
75672: LIST
75673: LIST
75674: LIST
75675: LIST
75676: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75677: LD_ADDR_VAR 0 32
75681: PUSH
75682: LD_INT 1
75684: PUSH
75685: LD_INT 3
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 0
75694: PUSH
75695: LD_INT 3
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 1
75704: NEG
75705: PUSH
75706: LD_INT 2
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 1
75715: PUSH
75716: LD_INT 4
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 0
75725: PUSH
75726: LD_INT 4
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 1
75735: NEG
75736: PUSH
75737: LD_INT 3
75739: PUSH
75740: EMPTY
75741: LIST
75742: LIST
75743: PUSH
75744: LD_INT 1
75746: PUSH
75747: LD_INT 5
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 0
75756: PUSH
75757: LD_INT 5
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 1
75766: NEG
75767: PUSH
75768: LD_INT 4
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: PUSH
75778: LD_INT 6
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 0
75787: PUSH
75788: LD_INT 6
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: NEG
75798: PUSH
75799: LD_INT 5
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: LIST
75818: LIST
75819: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75820: LD_ADDR_VAR 0 33
75824: PUSH
75825: LD_INT 2
75827: NEG
75828: PUSH
75829: LD_INT 1
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 3
75838: NEG
75839: PUSH
75840: LD_INT 0
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: LD_INT 3
75849: NEG
75850: PUSH
75851: LD_INT 1
75853: NEG
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 3
75861: NEG
75862: PUSH
75863: LD_INT 1
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: PUSH
75870: LD_INT 4
75872: NEG
75873: PUSH
75874: LD_INT 0
75876: PUSH
75877: EMPTY
75878: LIST
75879: LIST
75880: PUSH
75881: LD_INT 4
75883: NEG
75884: PUSH
75885: LD_INT 1
75887: NEG
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 4
75895: NEG
75896: PUSH
75897: LD_INT 1
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 5
75906: NEG
75907: PUSH
75908: LD_INT 0
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: LD_INT 5
75917: NEG
75918: PUSH
75919: LD_INT 1
75921: NEG
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 5
75929: NEG
75930: PUSH
75931: LD_INT 1
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 6
75940: NEG
75941: PUSH
75942: LD_INT 0
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 6
75951: NEG
75952: PUSH
75953: LD_INT 1
75955: NEG
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: LIST
75965: LIST
75966: LIST
75967: LIST
75968: LIST
75969: LIST
75970: LIST
75971: LIST
75972: LIST
75973: LIST
75974: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75975: LD_ADDR_VAR 0 34
75979: PUSH
75980: LD_INT 2
75982: NEG
75983: PUSH
75984: LD_INT 3
75986: NEG
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 3
75994: NEG
75995: PUSH
75996: LD_INT 2
75998: NEG
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: PUSH
76004: LD_INT 3
76006: NEG
76007: PUSH
76008: LD_INT 3
76010: NEG
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: PUSH
76016: LD_INT 3
76018: NEG
76019: PUSH
76020: LD_INT 4
76022: NEG
76023: PUSH
76024: EMPTY
76025: LIST
76026: LIST
76027: PUSH
76028: LD_INT 4
76030: NEG
76031: PUSH
76032: LD_INT 3
76034: NEG
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: LD_INT 4
76042: NEG
76043: PUSH
76044: LD_INT 4
76046: NEG
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 4
76054: NEG
76055: PUSH
76056: LD_INT 5
76058: NEG
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 5
76066: NEG
76067: PUSH
76068: LD_INT 4
76070: NEG
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 5
76078: NEG
76079: PUSH
76080: LD_INT 5
76082: NEG
76083: PUSH
76084: EMPTY
76085: LIST
76086: LIST
76087: PUSH
76088: LD_INT 5
76090: NEG
76091: PUSH
76092: LD_INT 6
76094: NEG
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: PUSH
76100: LD_INT 6
76102: NEG
76103: PUSH
76104: LD_INT 5
76106: NEG
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: LD_INT 6
76114: NEG
76115: PUSH
76116: LD_INT 6
76118: NEG
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: LIST
76135: LIST
76136: LIST
76137: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76138: LD_ADDR_VAR 0 41
76142: PUSH
76143: LD_INT 0
76145: PUSH
76146: LD_INT 2
76148: NEG
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 1
76156: NEG
76157: PUSH
76158: LD_INT 3
76160: NEG
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: LD_INT 1
76168: PUSH
76169: LD_INT 2
76171: NEG
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: LIST
76181: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76182: LD_ADDR_VAR 0 42
76186: PUSH
76187: LD_INT 2
76189: PUSH
76190: LD_INT 0
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 2
76199: PUSH
76200: LD_INT 1
76202: NEG
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: LD_INT 3
76210: PUSH
76211: LD_INT 1
76213: PUSH
76214: EMPTY
76215: LIST
76216: LIST
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: LIST
76222: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76223: LD_ADDR_VAR 0 43
76227: PUSH
76228: LD_INT 2
76230: PUSH
76231: LD_INT 2
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: LD_INT 3
76240: PUSH
76241: LD_INT 2
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: LD_INT 2
76250: PUSH
76251: LD_INT 3
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: LIST
76262: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76263: LD_ADDR_VAR 0 44
76267: PUSH
76268: LD_INT 0
76270: PUSH
76271: LD_INT 2
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: LD_INT 3
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PUSH
76288: LD_INT 1
76290: NEG
76291: PUSH
76292: LD_INT 2
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: LIST
76303: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76304: LD_ADDR_VAR 0 45
76308: PUSH
76309: LD_INT 2
76311: NEG
76312: PUSH
76313: LD_INT 0
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 2
76322: NEG
76323: PUSH
76324: LD_INT 1
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 3
76333: NEG
76334: PUSH
76335: LD_INT 1
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: LIST
76347: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76348: LD_ADDR_VAR 0 46
76352: PUSH
76353: LD_INT 2
76355: NEG
76356: PUSH
76357: LD_INT 2
76359: NEG
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 2
76367: NEG
76368: PUSH
76369: LD_INT 3
76371: NEG
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 3
76379: NEG
76380: PUSH
76381: LD_INT 2
76383: NEG
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: LIST
76393: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76394: LD_ADDR_VAR 0 47
76398: PUSH
76399: LD_INT 2
76401: NEG
76402: PUSH
76403: LD_INT 3
76405: NEG
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 1
76413: NEG
76414: PUSH
76415: LD_INT 3
76417: NEG
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76427: LD_ADDR_VAR 0 48
76431: PUSH
76432: LD_INT 1
76434: PUSH
76435: LD_INT 2
76437: NEG
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 2
76445: PUSH
76446: LD_INT 1
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76458: LD_ADDR_VAR 0 49
76462: PUSH
76463: LD_INT 3
76465: PUSH
76466: LD_INT 1
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 3
76475: PUSH
76476: LD_INT 2
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76487: LD_ADDR_VAR 0 50
76491: PUSH
76492: LD_INT 2
76494: PUSH
76495: LD_INT 3
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 1
76504: PUSH
76505: LD_INT 3
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76516: LD_ADDR_VAR 0 51
76520: PUSH
76521: LD_INT 1
76523: NEG
76524: PUSH
76525: LD_INT 2
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 2
76534: NEG
76535: PUSH
76536: LD_INT 1
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76547: LD_ADDR_VAR 0 52
76551: PUSH
76552: LD_INT 3
76554: NEG
76555: PUSH
76556: LD_INT 1
76558: NEG
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: LD_INT 3
76566: NEG
76567: PUSH
76568: LD_INT 2
76570: NEG
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76580: LD_ADDR_VAR 0 53
76584: PUSH
76585: LD_INT 1
76587: NEG
76588: PUSH
76589: LD_INT 3
76591: NEG
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: LD_INT 0
76599: PUSH
76600: LD_INT 3
76602: NEG
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: LD_INT 1
76610: PUSH
76611: LD_INT 2
76613: NEG
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: LIST
76623: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76624: LD_ADDR_VAR 0 54
76628: PUSH
76629: LD_INT 2
76631: PUSH
76632: LD_INT 1
76634: NEG
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: LD_INT 3
76642: PUSH
76643: LD_INT 0
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 3
76652: PUSH
76653: LD_INT 1
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: LIST
76664: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76665: LD_ADDR_VAR 0 55
76669: PUSH
76670: LD_INT 3
76672: PUSH
76673: LD_INT 2
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: LD_INT 3
76682: PUSH
76683: LD_INT 3
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 2
76692: PUSH
76693: LD_INT 3
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: LIST
76704: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76705: LD_ADDR_VAR 0 56
76709: PUSH
76710: LD_INT 1
76712: PUSH
76713: LD_INT 3
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: LD_INT 0
76722: PUSH
76723: LD_INT 3
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 1
76732: NEG
76733: PUSH
76734: LD_INT 2
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: LIST
76745: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76746: LD_ADDR_VAR 0 57
76750: PUSH
76751: LD_INT 2
76753: NEG
76754: PUSH
76755: LD_INT 1
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: LD_INT 3
76764: NEG
76765: PUSH
76766: LD_INT 0
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 3
76775: NEG
76776: PUSH
76777: LD_INT 1
76779: NEG
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: LIST
76789: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76790: LD_ADDR_VAR 0 58
76794: PUSH
76795: LD_INT 2
76797: NEG
76798: PUSH
76799: LD_INT 3
76801: NEG
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 3
76809: NEG
76810: PUSH
76811: LD_INT 2
76813: NEG
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 3
76821: NEG
76822: PUSH
76823: LD_INT 3
76825: NEG
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: LIST
76835: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76836: LD_ADDR_VAR 0 59
76840: PUSH
76841: LD_INT 1
76843: NEG
76844: PUSH
76845: LD_INT 2
76847: NEG
76848: PUSH
76849: EMPTY
76850: LIST
76851: LIST
76852: PUSH
76853: LD_INT 0
76855: PUSH
76856: LD_INT 2
76858: NEG
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: LD_INT 1
76866: PUSH
76867: LD_INT 1
76869: NEG
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: LIST
76879: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76880: LD_ADDR_VAR 0 60
76884: PUSH
76885: LD_INT 1
76887: PUSH
76888: LD_INT 1
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 2
76898: PUSH
76899: LD_INT 0
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 2
76908: PUSH
76909: LD_INT 1
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: LIST
76920: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76921: LD_ADDR_VAR 0 61
76925: PUSH
76926: LD_INT 2
76928: PUSH
76929: LD_INT 1
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 2
76938: PUSH
76939: LD_INT 2
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 1
76948: PUSH
76949: LD_INT 2
76951: PUSH
76952: EMPTY
76953: LIST
76954: LIST
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: LIST
76960: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76961: LD_ADDR_VAR 0 62
76965: PUSH
76966: LD_INT 1
76968: PUSH
76969: LD_INT 2
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 0
76978: PUSH
76979: LD_INT 2
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 1
76988: NEG
76989: PUSH
76990: LD_INT 1
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: LIST
77001: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77002: LD_ADDR_VAR 0 63
77006: PUSH
77007: LD_INT 1
77009: NEG
77010: PUSH
77011: LD_INT 1
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 2
77020: NEG
77021: PUSH
77022: LD_INT 0
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 2
77031: NEG
77032: PUSH
77033: LD_INT 1
77035: NEG
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: LIST
77045: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77046: LD_ADDR_VAR 0 64
77050: PUSH
77051: LD_INT 1
77053: NEG
77054: PUSH
77055: LD_INT 2
77057: NEG
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PUSH
77063: LD_INT 2
77065: NEG
77066: PUSH
77067: LD_INT 1
77069: NEG
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 2
77077: NEG
77078: PUSH
77079: LD_INT 2
77081: NEG
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: LIST
77091: ST_TO_ADDR
// end ; 2 :
77092: GO 80358
77094: LD_INT 2
77096: DOUBLE
77097: EQUAL
77098: IFTRUE 77102
77100: GO 80357
77102: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77103: LD_ADDR_VAR 0 29
77107: PUSH
77108: LD_INT 4
77110: PUSH
77111: LD_INT 0
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 4
77120: PUSH
77121: LD_INT 1
77123: NEG
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 5
77131: PUSH
77132: LD_INT 0
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: LD_INT 5
77141: PUSH
77142: LD_INT 1
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 4
77151: PUSH
77152: LD_INT 1
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 3
77161: PUSH
77162: LD_INT 0
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 3
77171: PUSH
77172: LD_INT 1
77174: NEG
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 3
77182: PUSH
77183: LD_INT 2
77185: NEG
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 5
77193: PUSH
77194: LD_INT 2
77196: PUSH
77197: EMPTY
77198: LIST
77199: LIST
77200: PUSH
77201: LD_INT 3
77203: PUSH
77204: LD_INT 3
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 3
77213: PUSH
77214: LD_INT 2
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 4
77223: PUSH
77224: LD_INT 3
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 4
77233: PUSH
77234: LD_INT 4
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 3
77243: PUSH
77244: LD_INT 4
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: PUSH
77251: LD_INT 2
77253: PUSH
77254: LD_INT 3
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: PUSH
77261: LD_INT 2
77263: PUSH
77264: LD_INT 2
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: PUSH
77271: LD_INT 4
77273: PUSH
77274: LD_INT 2
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 2
77283: PUSH
77284: LD_INT 4
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: LD_INT 4
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: PUSH
77301: LD_INT 0
77303: PUSH
77304: LD_INT 3
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: LD_INT 1
77313: PUSH
77314: LD_INT 4
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 1
77323: PUSH
77324: LD_INT 5
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: LD_INT 0
77333: PUSH
77334: LD_INT 5
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: LD_INT 4
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 1
77354: NEG
77355: PUSH
77356: LD_INT 3
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 2
77365: PUSH
77366: LD_INT 5
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: LD_INT 2
77375: NEG
77376: PUSH
77377: LD_INT 3
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 3
77386: NEG
77387: PUSH
77388: LD_INT 0
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 3
77397: NEG
77398: PUSH
77399: LD_INT 1
77401: NEG
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 2
77409: NEG
77410: PUSH
77411: LD_INT 0
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 2
77420: NEG
77421: PUSH
77422: LD_INT 1
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 3
77431: NEG
77432: PUSH
77433: LD_INT 1
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 4
77442: NEG
77443: PUSH
77444: LD_INT 0
77446: PUSH
77447: EMPTY
77448: LIST
77449: LIST
77450: PUSH
77451: LD_INT 4
77453: NEG
77454: PUSH
77455: LD_INT 1
77457: NEG
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 4
77465: NEG
77466: PUSH
77467: LD_INT 2
77469: NEG
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 2
77477: NEG
77478: PUSH
77479: LD_INT 2
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 4
77488: NEG
77489: PUSH
77490: LD_INT 4
77492: NEG
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: LD_INT 4
77500: NEG
77501: PUSH
77502: LD_INT 5
77504: NEG
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 3
77512: NEG
77513: PUSH
77514: LD_INT 4
77516: NEG
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 3
77524: NEG
77525: PUSH
77526: LD_INT 3
77528: NEG
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 4
77536: NEG
77537: PUSH
77538: LD_INT 3
77540: NEG
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: LD_INT 5
77548: NEG
77549: PUSH
77550: LD_INT 4
77552: NEG
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 5
77560: NEG
77561: PUSH
77562: LD_INT 5
77564: NEG
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 3
77572: NEG
77573: PUSH
77574: LD_INT 5
77576: NEG
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 5
77584: NEG
77585: PUSH
77586: LD_INT 3
77588: NEG
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: LIST
77606: LIST
77607: LIST
77608: LIST
77609: LIST
77610: LIST
77611: LIST
77612: LIST
77613: LIST
77614: LIST
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: LIST
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: LIST
77630: LIST
77631: LIST
77632: LIST
77633: LIST
77634: LIST
77635: LIST
77636: LIST
77637: LIST
77638: LIST
77639: LIST
77640: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77641: LD_ADDR_VAR 0 30
77645: PUSH
77646: LD_INT 4
77648: PUSH
77649: LD_INT 4
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: LD_INT 4
77658: PUSH
77659: LD_INT 3
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 5
77668: PUSH
77669: LD_INT 4
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 5
77678: PUSH
77679: LD_INT 5
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 4
77688: PUSH
77689: LD_INT 5
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 3
77698: PUSH
77699: LD_INT 4
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 3
77708: PUSH
77709: LD_INT 3
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 5
77718: PUSH
77719: LD_INT 3
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 3
77728: PUSH
77729: LD_INT 5
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: LD_INT 0
77738: PUSH
77739: LD_INT 3
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 0
77748: PUSH
77749: LD_INT 2
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 1
77758: PUSH
77759: LD_INT 3
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 1
77768: PUSH
77769: LD_INT 4
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 0
77778: PUSH
77779: LD_INT 4
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 1
77788: NEG
77789: PUSH
77790: LD_INT 3
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 1
77799: NEG
77800: PUSH
77801: LD_INT 2
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 2
77810: PUSH
77811: LD_INT 4
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: LD_INT 2
77820: NEG
77821: PUSH
77822: LD_INT 2
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 4
77831: NEG
77832: PUSH
77833: LD_INT 0
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 4
77842: NEG
77843: PUSH
77844: LD_INT 1
77846: NEG
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: LD_INT 3
77854: NEG
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 3
77865: NEG
77866: PUSH
77867: LD_INT 1
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 4
77876: NEG
77877: PUSH
77878: LD_INT 1
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 5
77887: NEG
77888: PUSH
77889: LD_INT 0
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 5
77898: NEG
77899: PUSH
77900: LD_INT 1
77902: NEG
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 5
77910: NEG
77911: PUSH
77912: LD_INT 2
77914: NEG
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 3
77922: NEG
77923: PUSH
77924: LD_INT 2
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 3
77933: NEG
77934: PUSH
77935: LD_INT 3
77937: NEG
77938: PUSH
77939: EMPTY
77940: LIST
77941: LIST
77942: PUSH
77943: LD_INT 3
77945: NEG
77946: PUSH
77947: LD_INT 4
77949: NEG
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 2
77957: NEG
77958: PUSH
77959: LD_INT 3
77961: NEG
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: LD_INT 2
77969: NEG
77970: PUSH
77971: LD_INT 2
77973: NEG
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 3
77981: NEG
77982: PUSH
77983: LD_INT 2
77985: NEG
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 4
77993: NEG
77994: PUSH
77995: LD_INT 3
77997: NEG
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PUSH
78003: LD_INT 4
78005: NEG
78006: PUSH
78007: LD_INT 4
78009: NEG
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 2
78017: NEG
78018: PUSH
78019: LD_INT 4
78021: NEG
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: PUSH
78027: LD_INT 4
78029: NEG
78030: PUSH
78031: LD_INT 2
78033: NEG
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: LD_INT 4
78044: NEG
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 0
78052: PUSH
78053: LD_INT 5
78055: NEG
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 1
78063: PUSH
78064: LD_INT 4
78066: NEG
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 1
78074: PUSH
78075: LD_INT 3
78077: NEG
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 0
78085: PUSH
78086: LD_INT 3
78088: NEG
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 1
78096: NEG
78097: PUSH
78098: LD_INT 4
78100: NEG
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 1
78108: NEG
78109: PUSH
78110: LD_INT 5
78112: NEG
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: LD_INT 3
78123: NEG
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 2
78131: NEG
78132: PUSH
78133: LD_INT 5
78135: NEG
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: LIST
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: LIST
78165: LIST
78166: LIST
78167: LIST
78168: LIST
78169: LIST
78170: LIST
78171: LIST
78172: LIST
78173: LIST
78174: LIST
78175: LIST
78176: LIST
78177: LIST
78178: LIST
78179: LIST
78180: LIST
78181: LIST
78182: LIST
78183: LIST
78184: LIST
78185: LIST
78186: LIST
78187: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78188: LD_ADDR_VAR 0 31
78192: PUSH
78193: LD_INT 0
78195: PUSH
78196: LD_INT 4
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 0
78205: PUSH
78206: LD_INT 3
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 1
78215: PUSH
78216: LD_INT 4
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 1
78225: PUSH
78226: LD_INT 5
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: PUSH
78233: LD_INT 0
78235: PUSH
78236: LD_INT 5
78238: PUSH
78239: EMPTY
78240: LIST
78241: LIST
78242: PUSH
78243: LD_INT 1
78245: NEG
78246: PUSH
78247: LD_INT 4
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: LD_INT 1
78256: NEG
78257: PUSH
78258: LD_INT 3
78260: PUSH
78261: EMPTY
78262: LIST
78263: LIST
78264: PUSH
78265: LD_INT 2
78267: PUSH
78268: LD_INT 5
78270: PUSH
78271: EMPTY
78272: LIST
78273: LIST
78274: PUSH
78275: LD_INT 2
78277: NEG
78278: PUSH
78279: LD_INT 3
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 3
78288: NEG
78289: PUSH
78290: LD_INT 0
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 3
78299: NEG
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 2
78311: NEG
78312: PUSH
78313: LD_INT 0
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 2
78322: NEG
78323: PUSH
78324: LD_INT 1
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 3
78333: NEG
78334: PUSH
78335: LD_INT 1
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 4
78344: NEG
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 4
78355: NEG
78356: PUSH
78357: LD_INT 1
78359: NEG
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: LD_INT 4
78367: NEG
78368: PUSH
78369: LD_INT 2
78371: NEG
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PUSH
78377: LD_INT 2
78379: NEG
78380: PUSH
78381: LD_INT 2
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 4
78390: NEG
78391: PUSH
78392: LD_INT 4
78394: NEG
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 4
78402: NEG
78403: PUSH
78404: LD_INT 5
78406: NEG
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 3
78414: NEG
78415: PUSH
78416: LD_INT 4
78418: NEG
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 3
78426: NEG
78427: PUSH
78428: LD_INT 3
78430: NEG
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 4
78438: NEG
78439: PUSH
78440: LD_INT 3
78442: NEG
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: LD_INT 5
78450: NEG
78451: PUSH
78452: LD_INT 4
78454: NEG
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 5
78462: NEG
78463: PUSH
78464: LD_INT 5
78466: NEG
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 3
78474: NEG
78475: PUSH
78476: LD_INT 5
78478: NEG
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 5
78486: NEG
78487: PUSH
78488: LD_INT 3
78490: NEG
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 0
78498: PUSH
78499: LD_INT 3
78501: NEG
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 0
78509: PUSH
78510: LD_INT 4
78512: NEG
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 1
78520: PUSH
78521: LD_INT 3
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 1
78531: PUSH
78532: LD_INT 2
78534: NEG
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 0
78542: PUSH
78543: LD_INT 2
78545: NEG
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 1
78553: NEG
78554: PUSH
78555: LD_INT 3
78557: NEG
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 1
78565: NEG
78566: PUSH
78567: LD_INT 4
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 2
78577: PUSH
78578: LD_INT 2
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 2
78588: NEG
78589: PUSH
78590: LD_INT 4
78592: NEG
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 4
78600: PUSH
78601: LD_INT 0
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: LD_INT 4
78610: PUSH
78611: LD_INT 1
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 5
78621: PUSH
78622: LD_INT 0
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 5
78631: PUSH
78632: LD_INT 1
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 4
78641: PUSH
78642: LD_INT 1
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 3
78651: PUSH
78652: LD_INT 0
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 3
78661: PUSH
78662: LD_INT 1
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 3
78672: PUSH
78673: LD_INT 2
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 5
78683: PUSH
78684: LD_INT 2
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: LIST
78716: LIST
78717: LIST
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: LIST
78723: LIST
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78738: LD_ADDR_VAR 0 32
78742: PUSH
78743: LD_INT 4
78745: NEG
78746: PUSH
78747: LD_INT 0
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 4
78756: NEG
78757: PUSH
78758: LD_INT 1
78760: NEG
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 3
78768: NEG
78769: PUSH
78770: LD_INT 0
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 3
78779: NEG
78780: PUSH
78781: LD_INT 1
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 4
78790: NEG
78791: PUSH
78792: LD_INT 1
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 5
78801: NEG
78802: PUSH
78803: LD_INT 0
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 5
78812: NEG
78813: PUSH
78814: LD_INT 1
78816: NEG
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 5
78824: NEG
78825: PUSH
78826: LD_INT 2
78828: NEG
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 3
78836: NEG
78837: PUSH
78838: LD_INT 2
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 3
78847: NEG
78848: PUSH
78849: LD_INT 3
78851: NEG
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 3
78859: NEG
78860: PUSH
78861: LD_INT 4
78863: NEG
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 2
78871: NEG
78872: PUSH
78873: LD_INT 3
78875: NEG
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 2
78883: NEG
78884: PUSH
78885: LD_INT 2
78887: NEG
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: LD_INT 3
78895: NEG
78896: PUSH
78897: LD_INT 2
78899: NEG
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PUSH
78905: LD_INT 4
78907: NEG
78908: PUSH
78909: LD_INT 3
78911: NEG
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 4
78919: NEG
78920: PUSH
78921: LD_INT 4
78923: NEG
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: NEG
78932: PUSH
78933: LD_INT 4
78935: NEG
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 4
78943: NEG
78944: PUSH
78945: LD_INT 2
78947: NEG
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 0
78955: PUSH
78956: LD_INT 4
78958: NEG
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 0
78966: PUSH
78967: LD_INT 5
78969: NEG
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PUSH
78975: LD_INT 1
78977: PUSH
78978: LD_INT 4
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 1
78988: PUSH
78989: LD_INT 3
78991: NEG
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 0
78999: PUSH
79000: LD_INT 3
79002: NEG
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: LD_INT 1
79010: NEG
79011: PUSH
79012: LD_INT 4
79014: NEG
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 1
79022: NEG
79023: PUSH
79024: LD_INT 5
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 2
79034: PUSH
79035: LD_INT 3
79037: NEG
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 2
79045: NEG
79046: PUSH
79047: LD_INT 5
79049: NEG
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 3
79057: PUSH
79058: LD_INT 0
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 3
79067: PUSH
79068: LD_INT 1
79070: NEG
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 4
79078: PUSH
79079: LD_INT 0
79081: PUSH
79082: EMPTY
79083: LIST
79084: LIST
79085: PUSH
79086: LD_INT 4
79088: PUSH
79089: LD_INT 1
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 3
79098: PUSH
79099: LD_INT 1
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 2
79108: PUSH
79109: LD_INT 0
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 2
79118: PUSH
79119: LD_INT 1
79121: NEG
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 2
79129: PUSH
79130: LD_INT 2
79132: NEG
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 4
79140: PUSH
79141: LD_INT 2
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 4
79150: PUSH
79151: LD_INT 4
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PUSH
79158: LD_INT 4
79160: PUSH
79161: LD_INT 3
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: LD_INT 5
79170: PUSH
79171: LD_INT 4
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 5
79180: PUSH
79181: LD_INT 5
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 4
79190: PUSH
79191: LD_INT 5
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 3
79200: PUSH
79201: LD_INT 4
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 3
79210: PUSH
79211: LD_INT 3
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 5
79220: PUSH
79221: LD_INT 3
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: PUSH
79228: LD_INT 3
79230: PUSH
79231: LD_INT 5
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: LIST
79251: LIST
79252: LIST
79253: LIST
79254: LIST
79255: LIST
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: LIST
79269: LIST
79270: LIST
79271: LIST
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: LIST
79277: LIST
79278: LIST
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79285: LD_ADDR_VAR 0 33
79289: PUSH
79290: LD_INT 4
79292: NEG
79293: PUSH
79294: LD_INT 4
79296: NEG
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 4
79304: NEG
79305: PUSH
79306: LD_INT 5
79308: NEG
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 3
79316: NEG
79317: PUSH
79318: LD_INT 4
79320: NEG
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 3
79328: NEG
79329: PUSH
79330: LD_INT 3
79332: NEG
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 4
79340: NEG
79341: PUSH
79342: LD_INT 3
79344: NEG
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: LD_INT 5
79352: NEG
79353: PUSH
79354: LD_INT 4
79356: NEG
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: PUSH
79362: LD_INT 5
79364: NEG
79365: PUSH
79366: LD_INT 5
79368: NEG
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 3
79376: NEG
79377: PUSH
79378: LD_INT 5
79380: NEG
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 5
79388: NEG
79389: PUSH
79390: LD_INT 3
79392: NEG
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 0
79400: PUSH
79401: LD_INT 3
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: LD_INT 4
79414: NEG
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 1
79422: PUSH
79423: LD_INT 3
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 1
79433: PUSH
79434: LD_INT 2
79436: NEG
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 0
79444: PUSH
79445: LD_INT 2
79447: NEG
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 1
79455: NEG
79456: PUSH
79457: LD_INT 3
79459: NEG
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: NEG
79468: PUSH
79469: LD_INT 4
79471: NEG
79472: PUSH
79473: EMPTY
79474: LIST
79475: LIST
79476: PUSH
79477: LD_INT 2
79479: PUSH
79480: LD_INT 2
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 2
79490: NEG
79491: PUSH
79492: LD_INT 4
79494: NEG
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 4
79502: PUSH
79503: LD_INT 0
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 4
79512: PUSH
79513: LD_INT 1
79515: NEG
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 5
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 5
79533: PUSH
79534: LD_INT 1
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 4
79543: PUSH
79544: LD_INT 1
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 3
79553: PUSH
79554: LD_INT 0
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: LD_INT 3
79563: PUSH
79564: LD_INT 1
79566: NEG
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 3
79574: PUSH
79575: LD_INT 2
79577: NEG
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: LD_INT 5
79585: PUSH
79586: LD_INT 2
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 3
79595: PUSH
79596: LD_INT 3
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 3
79605: PUSH
79606: LD_INT 2
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 4
79615: PUSH
79616: LD_INT 3
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: LD_INT 4
79625: PUSH
79626: LD_INT 4
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 3
79635: PUSH
79636: LD_INT 4
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 2
79645: PUSH
79646: LD_INT 3
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 2
79655: PUSH
79656: LD_INT 2
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 4
79665: PUSH
79666: LD_INT 2
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 2
79675: PUSH
79676: LD_INT 4
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 0
79685: PUSH
79686: LD_INT 4
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: LD_INT 0
79695: PUSH
79696: LD_INT 3
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 1
79705: PUSH
79706: LD_INT 4
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 1
79715: PUSH
79716: LD_INT 5
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 0
79725: PUSH
79726: LD_INT 5
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 1
79735: NEG
79736: PUSH
79737: LD_INT 4
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 1
79746: NEG
79747: PUSH
79748: LD_INT 3
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 2
79757: PUSH
79758: LD_INT 5
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 2
79767: NEG
79768: PUSH
79769: LD_INT 3
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: LIST
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: LIST
79804: LIST
79805: LIST
79806: LIST
79807: LIST
79808: LIST
79809: LIST
79810: LIST
79811: LIST
79812: LIST
79813: LIST
79814: LIST
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: LIST
79820: LIST
79821: LIST
79822: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79823: LD_ADDR_VAR 0 34
79827: PUSH
79828: LD_INT 0
79830: PUSH
79831: LD_INT 4
79833: NEG
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 0
79841: PUSH
79842: LD_INT 5
79844: NEG
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 1
79852: PUSH
79853: LD_INT 4
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 1
79863: PUSH
79864: LD_INT 3
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 0
79874: PUSH
79875: LD_INT 3
79877: NEG
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 1
79885: NEG
79886: PUSH
79887: LD_INT 4
79889: NEG
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 1
79897: NEG
79898: PUSH
79899: LD_INT 5
79901: NEG
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 2
79909: PUSH
79910: LD_INT 3
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 2
79920: NEG
79921: PUSH
79922: LD_INT 5
79924: NEG
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 3
79932: PUSH
79933: LD_INT 0
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 3
79942: PUSH
79943: LD_INT 1
79945: NEG
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 4
79953: PUSH
79954: LD_INT 0
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 4
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: LD_INT 3
79973: PUSH
79974: LD_INT 1
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: LD_INT 2
79983: PUSH
79984: LD_INT 0
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 2
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 2
80004: PUSH
80005: LD_INT 2
80007: NEG
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 4
80015: PUSH
80016: LD_INT 2
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 4
80025: PUSH
80026: LD_INT 4
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 4
80035: PUSH
80036: LD_INT 3
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 5
80045: PUSH
80046: LD_INT 4
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 5
80055: PUSH
80056: LD_INT 5
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 4
80065: PUSH
80066: LD_INT 5
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: LD_INT 3
80075: PUSH
80076: LD_INT 4
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 3
80085: PUSH
80086: LD_INT 3
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 5
80095: PUSH
80096: LD_INT 3
80098: PUSH
80099: EMPTY
80100: LIST
80101: LIST
80102: PUSH
80103: LD_INT 3
80105: PUSH
80106: LD_INT 5
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 0
80115: PUSH
80116: LD_INT 3
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: LD_INT 0
80125: PUSH
80126: LD_INT 2
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: LD_INT 1
80135: PUSH
80136: LD_INT 3
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 1
80145: PUSH
80146: LD_INT 4
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 0
80155: PUSH
80156: LD_INT 4
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 1
80165: NEG
80166: PUSH
80167: LD_INT 3
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 1
80176: NEG
80177: PUSH
80178: LD_INT 2
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 2
80187: PUSH
80188: LD_INT 4
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 2
80197: NEG
80198: PUSH
80199: LD_INT 2
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 4
80208: NEG
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 4
80219: NEG
80220: PUSH
80221: LD_INT 1
80223: NEG
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 3
80231: NEG
80232: PUSH
80233: LD_INT 0
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 3
80242: NEG
80243: PUSH
80244: LD_INT 1
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 4
80253: NEG
80254: PUSH
80255: LD_INT 1
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 5
80264: NEG
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 5
80275: NEG
80276: PUSH
80277: LD_INT 1
80279: NEG
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 5
80287: NEG
80288: PUSH
80289: LD_INT 2
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 3
80299: NEG
80300: PUSH
80301: LD_INT 2
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: LIST
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: LIST
80321: LIST
80322: LIST
80323: LIST
80324: LIST
80325: LIST
80326: LIST
80327: LIST
80328: LIST
80329: LIST
80330: LIST
80331: LIST
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: ST_TO_ADDR
// end ; end ;
80355: GO 80358
80357: POP
// case btype of b_depot , b_warehouse :
80358: LD_VAR 0 1
80362: PUSH
80363: LD_INT 0
80365: DOUBLE
80366: EQUAL
80367: IFTRUE 80377
80369: LD_INT 1
80371: DOUBLE
80372: EQUAL
80373: IFTRUE 80377
80375: GO 80578
80377: POP
// case nation of nation_american :
80378: LD_VAR 0 5
80382: PUSH
80383: LD_INT 1
80385: DOUBLE
80386: EQUAL
80387: IFTRUE 80391
80389: GO 80447
80391: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80392: LD_ADDR_VAR 0 9
80396: PUSH
80397: LD_VAR 0 11
80401: PUSH
80402: LD_VAR 0 12
80406: PUSH
80407: LD_VAR 0 13
80411: PUSH
80412: LD_VAR 0 14
80416: PUSH
80417: LD_VAR 0 15
80421: PUSH
80422: LD_VAR 0 16
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: LIST
80431: LIST
80432: LIST
80433: LIST
80434: PUSH
80435: LD_VAR 0 4
80439: PUSH
80440: LD_INT 1
80442: PLUS
80443: ARRAY
80444: ST_TO_ADDR
80445: GO 80576
80447: LD_INT 2
80449: DOUBLE
80450: EQUAL
80451: IFTRUE 80455
80453: GO 80511
80455: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80456: LD_ADDR_VAR 0 9
80460: PUSH
80461: LD_VAR 0 17
80465: PUSH
80466: LD_VAR 0 18
80470: PUSH
80471: LD_VAR 0 19
80475: PUSH
80476: LD_VAR 0 20
80480: PUSH
80481: LD_VAR 0 21
80485: PUSH
80486: LD_VAR 0 22
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: PUSH
80499: LD_VAR 0 4
80503: PUSH
80504: LD_INT 1
80506: PLUS
80507: ARRAY
80508: ST_TO_ADDR
80509: GO 80576
80511: LD_INT 3
80513: DOUBLE
80514: EQUAL
80515: IFTRUE 80519
80517: GO 80575
80519: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80520: LD_ADDR_VAR 0 9
80524: PUSH
80525: LD_VAR 0 23
80529: PUSH
80530: LD_VAR 0 24
80534: PUSH
80535: LD_VAR 0 25
80539: PUSH
80540: LD_VAR 0 26
80544: PUSH
80545: LD_VAR 0 27
80549: PUSH
80550: LD_VAR 0 28
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: PUSH
80563: LD_VAR 0 4
80567: PUSH
80568: LD_INT 1
80570: PLUS
80571: ARRAY
80572: ST_TO_ADDR
80573: GO 80576
80575: POP
80576: GO 81131
80578: LD_INT 2
80580: DOUBLE
80581: EQUAL
80582: IFTRUE 80592
80584: LD_INT 3
80586: DOUBLE
80587: EQUAL
80588: IFTRUE 80592
80590: GO 80648
80592: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80593: LD_ADDR_VAR 0 9
80597: PUSH
80598: LD_VAR 0 29
80602: PUSH
80603: LD_VAR 0 30
80607: PUSH
80608: LD_VAR 0 31
80612: PUSH
80613: LD_VAR 0 32
80617: PUSH
80618: LD_VAR 0 33
80622: PUSH
80623: LD_VAR 0 34
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: PUSH
80636: LD_VAR 0 4
80640: PUSH
80641: LD_INT 1
80643: PLUS
80644: ARRAY
80645: ST_TO_ADDR
80646: GO 81131
80648: LD_INT 16
80650: DOUBLE
80651: EQUAL
80652: IFTRUE 80710
80654: LD_INT 17
80656: DOUBLE
80657: EQUAL
80658: IFTRUE 80710
80660: LD_INT 18
80662: DOUBLE
80663: EQUAL
80664: IFTRUE 80710
80666: LD_INT 19
80668: DOUBLE
80669: EQUAL
80670: IFTRUE 80710
80672: LD_INT 22
80674: DOUBLE
80675: EQUAL
80676: IFTRUE 80710
80678: LD_INT 20
80680: DOUBLE
80681: EQUAL
80682: IFTRUE 80710
80684: LD_INT 21
80686: DOUBLE
80687: EQUAL
80688: IFTRUE 80710
80690: LD_INT 23
80692: DOUBLE
80693: EQUAL
80694: IFTRUE 80710
80696: LD_INT 24
80698: DOUBLE
80699: EQUAL
80700: IFTRUE 80710
80702: LD_INT 25
80704: DOUBLE
80705: EQUAL
80706: IFTRUE 80710
80708: GO 80766
80710: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80711: LD_ADDR_VAR 0 9
80715: PUSH
80716: LD_VAR 0 35
80720: PUSH
80721: LD_VAR 0 36
80725: PUSH
80726: LD_VAR 0 37
80730: PUSH
80731: LD_VAR 0 38
80735: PUSH
80736: LD_VAR 0 39
80740: PUSH
80741: LD_VAR 0 40
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: PUSH
80754: LD_VAR 0 4
80758: PUSH
80759: LD_INT 1
80761: PLUS
80762: ARRAY
80763: ST_TO_ADDR
80764: GO 81131
80766: LD_INT 6
80768: DOUBLE
80769: EQUAL
80770: IFTRUE 80822
80772: LD_INT 7
80774: DOUBLE
80775: EQUAL
80776: IFTRUE 80822
80778: LD_INT 8
80780: DOUBLE
80781: EQUAL
80782: IFTRUE 80822
80784: LD_INT 13
80786: DOUBLE
80787: EQUAL
80788: IFTRUE 80822
80790: LD_INT 12
80792: DOUBLE
80793: EQUAL
80794: IFTRUE 80822
80796: LD_INT 15
80798: DOUBLE
80799: EQUAL
80800: IFTRUE 80822
80802: LD_INT 11
80804: DOUBLE
80805: EQUAL
80806: IFTRUE 80822
80808: LD_INT 14
80810: DOUBLE
80811: EQUAL
80812: IFTRUE 80822
80814: LD_INT 10
80816: DOUBLE
80817: EQUAL
80818: IFTRUE 80822
80820: GO 80878
80822: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80823: LD_ADDR_VAR 0 9
80827: PUSH
80828: LD_VAR 0 41
80832: PUSH
80833: LD_VAR 0 42
80837: PUSH
80838: LD_VAR 0 43
80842: PUSH
80843: LD_VAR 0 44
80847: PUSH
80848: LD_VAR 0 45
80852: PUSH
80853: LD_VAR 0 46
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: PUSH
80866: LD_VAR 0 4
80870: PUSH
80871: LD_INT 1
80873: PLUS
80874: ARRAY
80875: ST_TO_ADDR
80876: GO 81131
80878: LD_INT 36
80880: DOUBLE
80881: EQUAL
80882: IFTRUE 80886
80884: GO 80942
80886: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80887: LD_ADDR_VAR 0 9
80891: PUSH
80892: LD_VAR 0 47
80896: PUSH
80897: LD_VAR 0 48
80901: PUSH
80902: LD_VAR 0 49
80906: PUSH
80907: LD_VAR 0 50
80911: PUSH
80912: LD_VAR 0 51
80916: PUSH
80917: LD_VAR 0 52
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: PUSH
80930: LD_VAR 0 4
80934: PUSH
80935: LD_INT 1
80937: PLUS
80938: ARRAY
80939: ST_TO_ADDR
80940: GO 81131
80942: LD_INT 4
80944: DOUBLE
80945: EQUAL
80946: IFTRUE 80968
80948: LD_INT 5
80950: DOUBLE
80951: EQUAL
80952: IFTRUE 80968
80954: LD_INT 34
80956: DOUBLE
80957: EQUAL
80958: IFTRUE 80968
80960: LD_INT 37
80962: DOUBLE
80963: EQUAL
80964: IFTRUE 80968
80966: GO 81024
80968: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80969: LD_ADDR_VAR 0 9
80973: PUSH
80974: LD_VAR 0 53
80978: PUSH
80979: LD_VAR 0 54
80983: PUSH
80984: LD_VAR 0 55
80988: PUSH
80989: LD_VAR 0 56
80993: PUSH
80994: LD_VAR 0 57
80998: PUSH
80999: LD_VAR 0 58
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: PUSH
81012: LD_VAR 0 4
81016: PUSH
81017: LD_INT 1
81019: PLUS
81020: ARRAY
81021: ST_TO_ADDR
81022: GO 81131
81024: LD_INT 31
81026: DOUBLE
81027: EQUAL
81028: IFTRUE 81074
81030: LD_INT 32
81032: DOUBLE
81033: EQUAL
81034: IFTRUE 81074
81036: LD_INT 33
81038: DOUBLE
81039: EQUAL
81040: IFTRUE 81074
81042: LD_INT 27
81044: DOUBLE
81045: EQUAL
81046: IFTRUE 81074
81048: LD_INT 26
81050: DOUBLE
81051: EQUAL
81052: IFTRUE 81074
81054: LD_INT 28
81056: DOUBLE
81057: EQUAL
81058: IFTRUE 81074
81060: LD_INT 29
81062: DOUBLE
81063: EQUAL
81064: IFTRUE 81074
81066: LD_INT 30
81068: DOUBLE
81069: EQUAL
81070: IFTRUE 81074
81072: GO 81130
81074: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81075: LD_ADDR_VAR 0 9
81079: PUSH
81080: LD_VAR 0 59
81084: PUSH
81085: LD_VAR 0 60
81089: PUSH
81090: LD_VAR 0 61
81094: PUSH
81095: LD_VAR 0 62
81099: PUSH
81100: LD_VAR 0 63
81104: PUSH
81105: LD_VAR 0 64
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: PUSH
81118: LD_VAR 0 4
81122: PUSH
81123: LD_INT 1
81125: PLUS
81126: ARRAY
81127: ST_TO_ADDR
81128: GO 81131
81130: POP
// temp_list2 = [ ] ;
81131: LD_ADDR_VAR 0 10
81135: PUSH
81136: EMPTY
81137: ST_TO_ADDR
// for i in temp_list do
81138: LD_ADDR_VAR 0 8
81142: PUSH
81143: LD_VAR 0 9
81147: PUSH
81148: FOR_IN
81149: IFFALSE 81201
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81151: LD_ADDR_VAR 0 10
81155: PUSH
81156: LD_VAR 0 10
81160: PUSH
81161: LD_VAR 0 8
81165: PUSH
81166: LD_INT 1
81168: ARRAY
81169: PUSH
81170: LD_VAR 0 2
81174: PLUS
81175: PUSH
81176: LD_VAR 0 8
81180: PUSH
81181: LD_INT 2
81183: ARRAY
81184: PUSH
81185: LD_VAR 0 3
81189: PLUS
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: EMPTY
81196: LIST
81197: ADD
81198: ST_TO_ADDR
81199: GO 81148
81201: POP
81202: POP
// result = temp_list2 ;
81203: LD_ADDR_VAR 0 7
81207: PUSH
81208: LD_VAR 0 10
81212: ST_TO_ADDR
// end ;
81213: LD_VAR 0 7
81217: RET
// export function EnemyInRange ( unit , dist ) ; begin
81218: LD_INT 0
81220: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81221: LD_ADDR_VAR 0 3
81225: PUSH
81226: LD_VAR 0 1
81230: PPUSH
81231: CALL_OW 255
81235: PPUSH
81236: LD_VAR 0 1
81240: PPUSH
81241: CALL_OW 250
81245: PPUSH
81246: LD_VAR 0 1
81250: PPUSH
81251: CALL_OW 251
81255: PPUSH
81256: LD_VAR 0 2
81260: PPUSH
81261: CALL 54614 0 4
81265: PUSH
81266: LD_INT 4
81268: ARRAY
81269: ST_TO_ADDR
// end ;
81270: LD_VAR 0 3
81274: RET
// export function PlayerSeeMe ( unit ) ; begin
81275: LD_INT 0
81277: PPUSH
// result := See ( your_side , unit ) ;
81278: LD_ADDR_VAR 0 2
81282: PUSH
81283: LD_OWVAR 2
81287: PPUSH
81288: LD_VAR 0 1
81292: PPUSH
81293: CALL_OW 292
81297: ST_TO_ADDR
// end ;
81298: LD_VAR 0 2
81302: RET
// export function ReverseDir ( unit ) ; begin
81303: LD_INT 0
81305: PPUSH
// if not unit then
81306: LD_VAR 0 1
81310: NOT
81311: IFFALSE 81315
// exit ;
81313: GO 81338
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81315: LD_ADDR_VAR 0 2
81319: PUSH
81320: LD_VAR 0 1
81324: PPUSH
81325: CALL_OW 254
81329: PUSH
81330: LD_INT 3
81332: PLUS
81333: PUSH
81334: LD_INT 6
81336: MOD
81337: ST_TO_ADDR
// end ;
81338: LD_VAR 0 2
81342: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81343: LD_INT 0
81345: PPUSH
81346: PPUSH
81347: PPUSH
81348: PPUSH
81349: PPUSH
// if not hexes then
81350: LD_VAR 0 2
81354: NOT
81355: IFFALSE 81359
// exit ;
81357: GO 81507
// dist := 9999 ;
81359: LD_ADDR_VAR 0 5
81363: PUSH
81364: LD_INT 9999
81366: ST_TO_ADDR
// for i = 1 to hexes do
81367: LD_ADDR_VAR 0 4
81371: PUSH
81372: DOUBLE
81373: LD_INT 1
81375: DEC
81376: ST_TO_ADDR
81377: LD_VAR 0 2
81381: PUSH
81382: FOR_TO
81383: IFFALSE 81495
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81385: LD_VAR 0 1
81389: PPUSH
81390: LD_VAR 0 2
81394: PUSH
81395: LD_VAR 0 4
81399: ARRAY
81400: PUSH
81401: LD_INT 1
81403: ARRAY
81404: PPUSH
81405: LD_VAR 0 2
81409: PUSH
81410: LD_VAR 0 4
81414: ARRAY
81415: PUSH
81416: LD_INT 2
81418: ARRAY
81419: PPUSH
81420: CALL_OW 297
81424: PUSH
81425: LD_VAR 0 5
81429: LESS
81430: IFFALSE 81493
// begin hex := hexes [ i ] ;
81432: LD_ADDR_VAR 0 7
81436: PUSH
81437: LD_VAR 0 2
81441: PUSH
81442: LD_VAR 0 4
81446: ARRAY
81447: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81448: LD_ADDR_VAR 0 5
81452: PUSH
81453: LD_VAR 0 1
81457: PPUSH
81458: LD_VAR 0 2
81462: PUSH
81463: LD_VAR 0 4
81467: ARRAY
81468: PUSH
81469: LD_INT 1
81471: ARRAY
81472: PPUSH
81473: LD_VAR 0 2
81477: PUSH
81478: LD_VAR 0 4
81482: ARRAY
81483: PUSH
81484: LD_INT 2
81486: ARRAY
81487: PPUSH
81488: CALL_OW 297
81492: ST_TO_ADDR
// end ; end ;
81493: GO 81382
81495: POP
81496: POP
// result := hex ;
81497: LD_ADDR_VAR 0 3
81501: PUSH
81502: LD_VAR 0 7
81506: ST_TO_ADDR
// end ;
81507: LD_VAR 0 3
81511: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81512: LD_INT 0
81514: PPUSH
81515: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81516: LD_VAR 0 1
81520: NOT
81521: PUSH
81522: LD_VAR 0 1
81526: PUSH
81527: LD_INT 21
81529: PUSH
81530: LD_INT 2
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 23
81539: PUSH
81540: LD_INT 2
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: PPUSH
81551: CALL_OW 69
81555: IN
81556: NOT
81557: OR
81558: IFFALSE 81562
// exit ;
81560: GO 81609
// for i = 1 to 3 do
81562: LD_ADDR_VAR 0 3
81566: PUSH
81567: DOUBLE
81568: LD_INT 1
81570: DEC
81571: ST_TO_ADDR
81572: LD_INT 3
81574: PUSH
81575: FOR_TO
81576: IFFALSE 81607
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81578: LD_VAR 0 1
81582: PPUSH
81583: CALL_OW 250
81587: PPUSH
81588: LD_VAR 0 1
81592: PPUSH
81593: CALL_OW 251
81597: PPUSH
81598: LD_INT 1
81600: PPUSH
81601: CALL_OW 453
81605: GO 81575
81607: POP
81608: POP
// end ;
81609: LD_VAR 0 2
81613: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81614: LD_INT 0
81616: PPUSH
81617: PPUSH
81618: PPUSH
81619: PPUSH
81620: PPUSH
81621: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81622: LD_VAR 0 1
81626: NOT
81627: PUSH
81628: LD_VAR 0 2
81632: NOT
81633: OR
81634: PUSH
81635: LD_VAR 0 1
81639: PPUSH
81640: CALL_OW 314
81644: OR
81645: IFFALSE 81649
// exit ;
81647: GO 82090
// x := GetX ( enemy_unit ) ;
81649: LD_ADDR_VAR 0 7
81653: PUSH
81654: LD_VAR 0 2
81658: PPUSH
81659: CALL_OW 250
81663: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81664: LD_ADDR_VAR 0 8
81668: PUSH
81669: LD_VAR 0 2
81673: PPUSH
81674: CALL_OW 251
81678: ST_TO_ADDR
// if not x or not y then
81679: LD_VAR 0 7
81683: NOT
81684: PUSH
81685: LD_VAR 0 8
81689: NOT
81690: OR
81691: IFFALSE 81695
// exit ;
81693: GO 82090
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81695: LD_ADDR_VAR 0 6
81699: PUSH
81700: LD_VAR 0 7
81704: PPUSH
81705: LD_INT 0
81707: PPUSH
81708: LD_INT 4
81710: PPUSH
81711: CALL_OW 272
81715: PUSH
81716: LD_VAR 0 8
81720: PPUSH
81721: LD_INT 0
81723: PPUSH
81724: LD_INT 4
81726: PPUSH
81727: CALL_OW 273
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_VAR 0 7
81740: PPUSH
81741: LD_INT 1
81743: PPUSH
81744: LD_INT 4
81746: PPUSH
81747: CALL_OW 272
81751: PUSH
81752: LD_VAR 0 8
81756: PPUSH
81757: LD_INT 1
81759: PPUSH
81760: LD_INT 4
81762: PPUSH
81763: CALL_OW 273
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_VAR 0 7
81776: PPUSH
81777: LD_INT 2
81779: PPUSH
81780: LD_INT 4
81782: PPUSH
81783: CALL_OW 272
81787: PUSH
81788: LD_VAR 0 8
81792: PPUSH
81793: LD_INT 2
81795: PPUSH
81796: LD_INT 4
81798: PPUSH
81799: CALL_OW 273
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_VAR 0 7
81812: PPUSH
81813: LD_INT 3
81815: PPUSH
81816: LD_INT 4
81818: PPUSH
81819: CALL_OW 272
81823: PUSH
81824: LD_VAR 0 8
81828: PPUSH
81829: LD_INT 3
81831: PPUSH
81832: LD_INT 4
81834: PPUSH
81835: CALL_OW 273
81839: PUSH
81840: EMPTY
81841: LIST
81842: LIST
81843: PUSH
81844: LD_VAR 0 7
81848: PPUSH
81849: LD_INT 4
81851: PPUSH
81852: LD_INT 4
81854: PPUSH
81855: CALL_OW 272
81859: PUSH
81860: LD_VAR 0 8
81864: PPUSH
81865: LD_INT 4
81867: PPUSH
81868: LD_INT 4
81870: PPUSH
81871: CALL_OW 273
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_VAR 0 7
81884: PPUSH
81885: LD_INT 5
81887: PPUSH
81888: LD_INT 4
81890: PPUSH
81891: CALL_OW 272
81895: PUSH
81896: LD_VAR 0 8
81900: PPUSH
81901: LD_INT 5
81903: PPUSH
81904: LD_INT 4
81906: PPUSH
81907: CALL_OW 273
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: LIST
81923: ST_TO_ADDR
// for i = tmp downto 1 do
81924: LD_ADDR_VAR 0 4
81928: PUSH
81929: DOUBLE
81930: LD_VAR 0 6
81934: INC
81935: ST_TO_ADDR
81936: LD_INT 1
81938: PUSH
81939: FOR_DOWNTO
81940: IFFALSE 82041
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81942: LD_VAR 0 6
81946: PUSH
81947: LD_VAR 0 4
81951: ARRAY
81952: PUSH
81953: LD_INT 1
81955: ARRAY
81956: PPUSH
81957: LD_VAR 0 6
81961: PUSH
81962: LD_VAR 0 4
81966: ARRAY
81967: PUSH
81968: LD_INT 2
81970: ARRAY
81971: PPUSH
81972: CALL_OW 488
81976: NOT
81977: PUSH
81978: LD_VAR 0 6
81982: PUSH
81983: LD_VAR 0 4
81987: ARRAY
81988: PUSH
81989: LD_INT 1
81991: ARRAY
81992: PPUSH
81993: LD_VAR 0 6
81997: PUSH
81998: LD_VAR 0 4
82002: ARRAY
82003: PUSH
82004: LD_INT 2
82006: ARRAY
82007: PPUSH
82008: CALL_OW 428
82012: PUSH
82013: LD_INT 0
82015: NONEQUAL
82016: OR
82017: IFFALSE 82039
// tmp := Delete ( tmp , i ) ;
82019: LD_ADDR_VAR 0 6
82023: PUSH
82024: LD_VAR 0 6
82028: PPUSH
82029: LD_VAR 0 4
82033: PPUSH
82034: CALL_OW 3
82038: ST_TO_ADDR
82039: GO 81939
82041: POP
82042: POP
// j := GetClosestHex ( unit , tmp ) ;
82043: LD_ADDR_VAR 0 5
82047: PUSH
82048: LD_VAR 0 1
82052: PPUSH
82053: LD_VAR 0 6
82057: PPUSH
82058: CALL 81343 0 2
82062: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82063: LD_VAR 0 1
82067: PPUSH
82068: LD_VAR 0 5
82072: PUSH
82073: LD_INT 1
82075: ARRAY
82076: PPUSH
82077: LD_VAR 0 5
82081: PUSH
82082: LD_INT 2
82084: ARRAY
82085: PPUSH
82086: CALL_OW 111
// end ;
82090: LD_VAR 0 3
82094: RET
// export function PrepareApemanSoldier ( ) ; begin
82095: LD_INT 0
82097: PPUSH
// uc_nation := 0 ;
82098: LD_ADDR_OWVAR 21
82102: PUSH
82103: LD_INT 0
82105: ST_TO_ADDR
// hc_sex := sex_male ;
82106: LD_ADDR_OWVAR 27
82110: PUSH
82111: LD_INT 1
82113: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82114: LD_ADDR_OWVAR 28
82118: PUSH
82119: LD_INT 15
82121: ST_TO_ADDR
// hc_gallery :=  ;
82122: LD_ADDR_OWVAR 33
82126: PUSH
82127: LD_STRING 
82129: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82130: LD_ADDR_OWVAR 31
82134: PUSH
82135: LD_INT 0
82137: PPUSH
82138: LD_INT 3
82140: PPUSH
82141: CALL_OW 12
82145: PUSH
82146: LD_INT 0
82148: PPUSH
82149: LD_INT 3
82151: PPUSH
82152: CALL_OW 12
82156: PUSH
82157: LD_INT 0
82159: PUSH
82160: LD_INT 0
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: ST_TO_ADDR
// end ;
82169: LD_VAR 0 1
82173: RET
// export function PrepareApemanEngineer ( ) ; begin
82174: LD_INT 0
82176: PPUSH
// uc_nation := 0 ;
82177: LD_ADDR_OWVAR 21
82181: PUSH
82182: LD_INT 0
82184: ST_TO_ADDR
// hc_sex := sex_male ;
82185: LD_ADDR_OWVAR 27
82189: PUSH
82190: LD_INT 1
82192: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82193: LD_ADDR_OWVAR 28
82197: PUSH
82198: LD_INT 16
82200: ST_TO_ADDR
// hc_gallery :=  ;
82201: LD_ADDR_OWVAR 33
82205: PUSH
82206: LD_STRING 
82208: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82209: LD_ADDR_OWVAR 31
82213: PUSH
82214: LD_INT 0
82216: PPUSH
82217: LD_INT 3
82219: PPUSH
82220: CALL_OW 12
82224: PUSH
82225: LD_INT 0
82227: PPUSH
82228: LD_INT 3
82230: PPUSH
82231: CALL_OW 12
82235: PUSH
82236: LD_INT 0
82238: PUSH
82239: LD_INT 0
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: ST_TO_ADDR
// end ;
82248: LD_VAR 0 1
82252: RET
// export function PrepareApeman ( agressivity ) ; begin
82253: LD_INT 0
82255: PPUSH
// uc_side := 0 ;
82256: LD_ADDR_OWVAR 20
82260: PUSH
82261: LD_INT 0
82263: ST_TO_ADDR
// uc_nation := 0 ;
82264: LD_ADDR_OWVAR 21
82268: PUSH
82269: LD_INT 0
82271: ST_TO_ADDR
// hc_sex := sex_male ;
82272: LD_ADDR_OWVAR 27
82276: PUSH
82277: LD_INT 1
82279: ST_TO_ADDR
// hc_class := class_apeman ;
82280: LD_ADDR_OWVAR 28
82284: PUSH
82285: LD_INT 12
82287: ST_TO_ADDR
// hc_gallery :=  ;
82288: LD_ADDR_OWVAR 33
82292: PUSH
82293: LD_STRING 
82295: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82296: LD_ADDR_OWVAR 35
82300: PUSH
82301: LD_VAR 0 1
82305: NEG
82306: PPUSH
82307: LD_VAR 0 1
82311: PPUSH
82312: CALL_OW 12
82316: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82317: LD_ADDR_OWVAR 31
82321: PUSH
82322: LD_INT 0
82324: PPUSH
82325: LD_INT 3
82327: PPUSH
82328: CALL_OW 12
82332: PUSH
82333: LD_INT 0
82335: PPUSH
82336: LD_INT 3
82338: PPUSH
82339: CALL_OW 12
82343: PUSH
82344: LD_INT 0
82346: PUSH
82347: LD_INT 0
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: ST_TO_ADDR
// end ;
82356: LD_VAR 0 2
82360: RET
// export function PrepareTiger ( agressivity ) ; begin
82361: LD_INT 0
82363: PPUSH
// uc_side := 0 ;
82364: LD_ADDR_OWVAR 20
82368: PUSH
82369: LD_INT 0
82371: ST_TO_ADDR
// uc_nation := 0 ;
82372: LD_ADDR_OWVAR 21
82376: PUSH
82377: LD_INT 0
82379: ST_TO_ADDR
// hc_class := class_tiger ;
82380: LD_ADDR_OWVAR 28
82384: PUSH
82385: LD_INT 14
82387: ST_TO_ADDR
// hc_gallery :=  ;
82388: LD_ADDR_OWVAR 33
82392: PUSH
82393: LD_STRING 
82395: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82396: LD_ADDR_OWVAR 35
82400: PUSH
82401: LD_VAR 0 1
82405: NEG
82406: PPUSH
82407: LD_VAR 0 1
82411: PPUSH
82412: CALL_OW 12
82416: ST_TO_ADDR
// end ;
82417: LD_VAR 0 2
82421: RET
// export function PrepareEnchidna ( ) ; begin
82422: LD_INT 0
82424: PPUSH
// uc_side := 0 ;
82425: LD_ADDR_OWVAR 20
82429: PUSH
82430: LD_INT 0
82432: ST_TO_ADDR
// uc_nation := 0 ;
82433: LD_ADDR_OWVAR 21
82437: PUSH
82438: LD_INT 0
82440: ST_TO_ADDR
// hc_class := class_baggie ;
82441: LD_ADDR_OWVAR 28
82445: PUSH
82446: LD_INT 13
82448: ST_TO_ADDR
// hc_gallery :=  ;
82449: LD_ADDR_OWVAR 33
82453: PUSH
82454: LD_STRING 
82456: ST_TO_ADDR
// end ;
82457: LD_VAR 0 1
82461: RET
// export function PrepareFrog ( ) ; begin
82462: LD_INT 0
82464: PPUSH
// uc_side := 0 ;
82465: LD_ADDR_OWVAR 20
82469: PUSH
82470: LD_INT 0
82472: ST_TO_ADDR
// uc_nation := 0 ;
82473: LD_ADDR_OWVAR 21
82477: PUSH
82478: LD_INT 0
82480: ST_TO_ADDR
// hc_class := class_frog ;
82481: LD_ADDR_OWVAR 28
82485: PUSH
82486: LD_INT 19
82488: ST_TO_ADDR
// hc_gallery :=  ;
82489: LD_ADDR_OWVAR 33
82493: PUSH
82494: LD_STRING 
82496: ST_TO_ADDR
// end ;
82497: LD_VAR 0 1
82501: RET
// export function PrepareFish ( ) ; begin
82502: LD_INT 0
82504: PPUSH
// uc_side := 0 ;
82505: LD_ADDR_OWVAR 20
82509: PUSH
82510: LD_INT 0
82512: ST_TO_ADDR
// uc_nation := 0 ;
82513: LD_ADDR_OWVAR 21
82517: PUSH
82518: LD_INT 0
82520: ST_TO_ADDR
// hc_class := class_fish ;
82521: LD_ADDR_OWVAR 28
82525: PUSH
82526: LD_INT 20
82528: ST_TO_ADDR
// hc_gallery :=  ;
82529: LD_ADDR_OWVAR 33
82533: PUSH
82534: LD_STRING 
82536: ST_TO_ADDR
// end ;
82537: LD_VAR 0 1
82541: RET
// export function PrepareBird ( ) ; begin
82542: LD_INT 0
82544: PPUSH
// uc_side := 0 ;
82545: LD_ADDR_OWVAR 20
82549: PUSH
82550: LD_INT 0
82552: ST_TO_ADDR
// uc_nation := 0 ;
82553: LD_ADDR_OWVAR 21
82557: PUSH
82558: LD_INT 0
82560: ST_TO_ADDR
// hc_class := class_phororhacos ;
82561: LD_ADDR_OWVAR 28
82565: PUSH
82566: LD_INT 18
82568: ST_TO_ADDR
// hc_gallery :=  ;
82569: LD_ADDR_OWVAR 33
82573: PUSH
82574: LD_STRING 
82576: ST_TO_ADDR
// end ;
82577: LD_VAR 0 1
82581: RET
// export function PrepareHorse ( ) ; begin
82582: LD_INT 0
82584: PPUSH
// uc_side := 0 ;
82585: LD_ADDR_OWVAR 20
82589: PUSH
82590: LD_INT 0
82592: ST_TO_ADDR
// uc_nation := 0 ;
82593: LD_ADDR_OWVAR 21
82597: PUSH
82598: LD_INT 0
82600: ST_TO_ADDR
// hc_class := class_horse ;
82601: LD_ADDR_OWVAR 28
82605: PUSH
82606: LD_INT 21
82608: ST_TO_ADDR
// hc_gallery :=  ;
82609: LD_ADDR_OWVAR 33
82613: PUSH
82614: LD_STRING 
82616: ST_TO_ADDR
// end ;
82617: LD_VAR 0 1
82621: RET
// export function PrepareMastodont ( ) ; begin
82622: LD_INT 0
82624: PPUSH
// uc_side := 0 ;
82625: LD_ADDR_OWVAR 20
82629: PUSH
82630: LD_INT 0
82632: ST_TO_ADDR
// uc_nation := 0 ;
82633: LD_ADDR_OWVAR 21
82637: PUSH
82638: LD_INT 0
82640: ST_TO_ADDR
// vc_chassis := class_mastodont ;
82641: LD_ADDR_OWVAR 37
82645: PUSH
82646: LD_INT 31
82648: ST_TO_ADDR
// vc_control := control_rider ;
82649: LD_ADDR_OWVAR 38
82653: PUSH
82654: LD_INT 4
82656: ST_TO_ADDR
// end ;
82657: LD_VAR 0 1
82661: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82662: LD_INT 0
82664: PPUSH
82665: PPUSH
82666: PPUSH
// uc_side = 0 ;
82667: LD_ADDR_OWVAR 20
82671: PUSH
82672: LD_INT 0
82674: ST_TO_ADDR
// uc_nation = 0 ;
82675: LD_ADDR_OWVAR 21
82679: PUSH
82680: LD_INT 0
82682: ST_TO_ADDR
// InitHc_All ( ) ;
82683: CALL_OW 584
// InitVc ;
82687: CALL_OW 20
// if mastodonts then
82691: LD_VAR 0 6
82695: IFFALSE 82762
// for i = 1 to mastodonts do
82697: LD_ADDR_VAR 0 11
82701: PUSH
82702: DOUBLE
82703: LD_INT 1
82705: DEC
82706: ST_TO_ADDR
82707: LD_VAR 0 6
82711: PUSH
82712: FOR_TO
82713: IFFALSE 82760
// begin vc_chassis := 31 ;
82715: LD_ADDR_OWVAR 37
82719: PUSH
82720: LD_INT 31
82722: ST_TO_ADDR
// vc_control := control_rider ;
82723: LD_ADDR_OWVAR 38
82727: PUSH
82728: LD_INT 4
82730: ST_TO_ADDR
// animal := CreateVehicle ;
82731: LD_ADDR_VAR 0 12
82735: PUSH
82736: CALL_OW 45
82740: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82741: LD_VAR 0 12
82745: PPUSH
82746: LD_VAR 0 8
82750: PPUSH
82751: LD_INT 0
82753: PPUSH
82754: CALL 84897 0 3
// end ;
82758: GO 82712
82760: POP
82761: POP
// if horses then
82762: LD_VAR 0 5
82766: IFFALSE 82833
// for i = 1 to horses do
82768: LD_ADDR_VAR 0 11
82772: PUSH
82773: DOUBLE
82774: LD_INT 1
82776: DEC
82777: ST_TO_ADDR
82778: LD_VAR 0 5
82782: PUSH
82783: FOR_TO
82784: IFFALSE 82831
// begin hc_class := 21 ;
82786: LD_ADDR_OWVAR 28
82790: PUSH
82791: LD_INT 21
82793: ST_TO_ADDR
// hc_gallery :=  ;
82794: LD_ADDR_OWVAR 33
82798: PUSH
82799: LD_STRING 
82801: ST_TO_ADDR
// animal := CreateHuman ;
82802: LD_ADDR_VAR 0 12
82806: PUSH
82807: CALL_OW 44
82811: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82812: LD_VAR 0 12
82816: PPUSH
82817: LD_VAR 0 8
82821: PPUSH
82822: LD_INT 0
82824: PPUSH
82825: CALL 84897 0 3
// end ;
82829: GO 82783
82831: POP
82832: POP
// if birds then
82833: LD_VAR 0 1
82837: IFFALSE 82904
// for i = 1 to birds do
82839: LD_ADDR_VAR 0 11
82843: PUSH
82844: DOUBLE
82845: LD_INT 1
82847: DEC
82848: ST_TO_ADDR
82849: LD_VAR 0 1
82853: PUSH
82854: FOR_TO
82855: IFFALSE 82902
// begin hc_class = 18 ;
82857: LD_ADDR_OWVAR 28
82861: PUSH
82862: LD_INT 18
82864: ST_TO_ADDR
// hc_gallery =  ;
82865: LD_ADDR_OWVAR 33
82869: PUSH
82870: LD_STRING 
82872: ST_TO_ADDR
// animal := CreateHuman ;
82873: LD_ADDR_VAR 0 12
82877: PUSH
82878: CALL_OW 44
82882: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82883: LD_VAR 0 12
82887: PPUSH
82888: LD_VAR 0 8
82892: PPUSH
82893: LD_INT 0
82895: PPUSH
82896: CALL 84897 0 3
// end ;
82900: GO 82854
82902: POP
82903: POP
// if tigers then
82904: LD_VAR 0 2
82908: IFFALSE 82992
// for i = 1 to tigers do
82910: LD_ADDR_VAR 0 11
82914: PUSH
82915: DOUBLE
82916: LD_INT 1
82918: DEC
82919: ST_TO_ADDR
82920: LD_VAR 0 2
82924: PUSH
82925: FOR_TO
82926: IFFALSE 82990
// begin hc_class = class_tiger ;
82928: LD_ADDR_OWVAR 28
82932: PUSH
82933: LD_INT 14
82935: ST_TO_ADDR
// hc_gallery =  ;
82936: LD_ADDR_OWVAR 33
82940: PUSH
82941: LD_STRING 
82943: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82944: LD_ADDR_OWVAR 35
82948: PUSH
82949: LD_INT 7
82951: NEG
82952: PPUSH
82953: LD_INT 7
82955: PPUSH
82956: CALL_OW 12
82960: ST_TO_ADDR
// animal := CreateHuman ;
82961: LD_ADDR_VAR 0 12
82965: PUSH
82966: CALL_OW 44
82970: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82971: LD_VAR 0 12
82975: PPUSH
82976: LD_VAR 0 8
82980: PPUSH
82981: LD_INT 0
82983: PPUSH
82984: CALL 84897 0 3
// end ;
82988: GO 82925
82990: POP
82991: POP
// if apemans then
82992: LD_VAR 0 3
82996: IFFALSE 83119
// for i = 1 to apemans do
82998: LD_ADDR_VAR 0 11
83002: PUSH
83003: DOUBLE
83004: LD_INT 1
83006: DEC
83007: ST_TO_ADDR
83008: LD_VAR 0 3
83012: PUSH
83013: FOR_TO
83014: IFFALSE 83117
// begin hc_class = class_apeman ;
83016: LD_ADDR_OWVAR 28
83020: PUSH
83021: LD_INT 12
83023: ST_TO_ADDR
// hc_gallery =  ;
83024: LD_ADDR_OWVAR 33
83028: PUSH
83029: LD_STRING 
83031: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83032: LD_ADDR_OWVAR 35
83036: PUSH
83037: LD_INT 2
83039: NEG
83040: PPUSH
83041: LD_INT 2
83043: PPUSH
83044: CALL_OW 12
83048: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83049: LD_ADDR_OWVAR 31
83053: PUSH
83054: LD_INT 1
83056: PPUSH
83057: LD_INT 3
83059: PPUSH
83060: CALL_OW 12
83064: PUSH
83065: LD_INT 1
83067: PPUSH
83068: LD_INT 3
83070: PPUSH
83071: CALL_OW 12
83075: PUSH
83076: LD_INT 0
83078: PUSH
83079: LD_INT 0
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: ST_TO_ADDR
// animal := CreateHuman ;
83088: LD_ADDR_VAR 0 12
83092: PUSH
83093: CALL_OW 44
83097: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83098: LD_VAR 0 12
83102: PPUSH
83103: LD_VAR 0 8
83107: PPUSH
83108: LD_INT 0
83110: PPUSH
83111: CALL 84897 0 3
// end ;
83115: GO 83013
83117: POP
83118: POP
// if enchidnas then
83119: LD_VAR 0 4
83123: IFFALSE 83190
// for i = 1 to enchidnas do
83125: LD_ADDR_VAR 0 11
83129: PUSH
83130: DOUBLE
83131: LD_INT 1
83133: DEC
83134: ST_TO_ADDR
83135: LD_VAR 0 4
83139: PUSH
83140: FOR_TO
83141: IFFALSE 83188
// begin hc_class = 13 ;
83143: LD_ADDR_OWVAR 28
83147: PUSH
83148: LD_INT 13
83150: ST_TO_ADDR
// hc_gallery =  ;
83151: LD_ADDR_OWVAR 33
83155: PUSH
83156: LD_STRING 
83158: ST_TO_ADDR
// animal := CreateHuman ;
83159: LD_ADDR_VAR 0 12
83163: PUSH
83164: CALL_OW 44
83168: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83169: LD_VAR 0 12
83173: PPUSH
83174: LD_VAR 0 8
83178: PPUSH
83179: LD_INT 0
83181: PPUSH
83182: CALL 84897 0 3
// end ;
83186: GO 83140
83188: POP
83189: POP
// if fishes then
83190: LD_VAR 0 7
83194: IFFALSE 83261
// for i = 1 to fishes do
83196: LD_ADDR_VAR 0 11
83200: PUSH
83201: DOUBLE
83202: LD_INT 1
83204: DEC
83205: ST_TO_ADDR
83206: LD_VAR 0 7
83210: PUSH
83211: FOR_TO
83212: IFFALSE 83259
// begin hc_class = 20 ;
83214: LD_ADDR_OWVAR 28
83218: PUSH
83219: LD_INT 20
83221: ST_TO_ADDR
// hc_gallery =  ;
83222: LD_ADDR_OWVAR 33
83226: PUSH
83227: LD_STRING 
83229: ST_TO_ADDR
// animal := CreateHuman ;
83230: LD_ADDR_VAR 0 12
83234: PUSH
83235: CALL_OW 44
83239: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83240: LD_VAR 0 12
83244: PPUSH
83245: LD_VAR 0 9
83249: PPUSH
83250: LD_INT 0
83252: PPUSH
83253: CALL 84897 0 3
// end ;
83257: GO 83211
83259: POP
83260: POP
// end ;
83261: LD_VAR 0 10
83265: RET
// export function WantHeal ( sci , unit ) ; begin
83266: LD_INT 0
83268: PPUSH
// if GetTaskList ( sci ) > 0 then
83269: LD_VAR 0 1
83273: PPUSH
83274: CALL_OW 437
83278: PUSH
83279: LD_INT 0
83281: GREATER
83282: IFFALSE 83352
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83284: LD_VAR 0 1
83288: PPUSH
83289: CALL_OW 437
83293: PUSH
83294: LD_INT 1
83296: ARRAY
83297: PUSH
83298: LD_INT 1
83300: ARRAY
83301: PUSH
83302: LD_STRING l
83304: EQUAL
83305: PUSH
83306: LD_VAR 0 1
83310: PPUSH
83311: CALL_OW 437
83315: PUSH
83316: LD_INT 1
83318: ARRAY
83319: PUSH
83320: LD_INT 4
83322: ARRAY
83323: PUSH
83324: LD_VAR 0 2
83328: EQUAL
83329: AND
83330: IFFALSE 83342
// result := true else
83332: LD_ADDR_VAR 0 3
83336: PUSH
83337: LD_INT 1
83339: ST_TO_ADDR
83340: GO 83350
// result := false ;
83342: LD_ADDR_VAR 0 3
83346: PUSH
83347: LD_INT 0
83349: ST_TO_ADDR
// end else
83350: GO 83360
// result := false ;
83352: LD_ADDR_VAR 0 3
83356: PUSH
83357: LD_INT 0
83359: ST_TO_ADDR
// end ;
83360: LD_VAR 0 3
83364: RET
// export function HealTarget ( sci ) ; begin
83365: LD_INT 0
83367: PPUSH
// if not sci then
83368: LD_VAR 0 1
83372: NOT
83373: IFFALSE 83377
// exit ;
83375: GO 83442
// result := 0 ;
83377: LD_ADDR_VAR 0 2
83381: PUSH
83382: LD_INT 0
83384: ST_TO_ADDR
// if GetTaskList ( sci ) then
83385: LD_VAR 0 1
83389: PPUSH
83390: CALL_OW 437
83394: IFFALSE 83442
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83396: LD_VAR 0 1
83400: PPUSH
83401: CALL_OW 437
83405: PUSH
83406: LD_INT 1
83408: ARRAY
83409: PUSH
83410: LD_INT 1
83412: ARRAY
83413: PUSH
83414: LD_STRING l
83416: EQUAL
83417: IFFALSE 83442
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83419: LD_ADDR_VAR 0 2
83423: PUSH
83424: LD_VAR 0 1
83428: PPUSH
83429: CALL_OW 437
83433: PUSH
83434: LD_INT 1
83436: ARRAY
83437: PUSH
83438: LD_INT 4
83440: ARRAY
83441: ST_TO_ADDR
// end ;
83442: LD_VAR 0 2
83446: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83447: LD_INT 0
83449: PPUSH
83450: PPUSH
83451: PPUSH
83452: PPUSH
// if not base_units then
83453: LD_VAR 0 1
83457: NOT
83458: IFFALSE 83462
// exit ;
83460: GO 83549
// result := false ;
83462: LD_ADDR_VAR 0 2
83466: PUSH
83467: LD_INT 0
83469: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83470: LD_ADDR_VAR 0 5
83474: PUSH
83475: LD_VAR 0 1
83479: PPUSH
83480: LD_INT 21
83482: PUSH
83483: LD_INT 3
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PPUSH
83490: CALL_OW 72
83494: ST_TO_ADDR
// if not tmp then
83495: LD_VAR 0 5
83499: NOT
83500: IFFALSE 83504
// exit ;
83502: GO 83549
// for i in tmp do
83504: LD_ADDR_VAR 0 3
83508: PUSH
83509: LD_VAR 0 5
83513: PUSH
83514: FOR_IN
83515: IFFALSE 83547
// begin result := EnemyInRange ( i , 22 ) ;
83517: LD_ADDR_VAR 0 2
83521: PUSH
83522: LD_VAR 0 3
83526: PPUSH
83527: LD_INT 22
83529: PPUSH
83530: CALL 81218 0 2
83534: ST_TO_ADDR
// if result then
83535: LD_VAR 0 2
83539: IFFALSE 83545
// exit ;
83541: POP
83542: POP
83543: GO 83549
// end ;
83545: GO 83514
83547: POP
83548: POP
// end ;
83549: LD_VAR 0 2
83553: RET
// export function FilterByTag ( units , tag ) ; begin
83554: LD_INT 0
83556: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83557: LD_ADDR_VAR 0 3
83561: PUSH
83562: LD_VAR 0 1
83566: PPUSH
83567: LD_INT 120
83569: PUSH
83570: LD_VAR 0 2
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PPUSH
83579: CALL_OW 72
83583: ST_TO_ADDR
// end ;
83584: LD_VAR 0 3
83588: RET
// export function IsDriver ( un ) ; begin
83589: LD_INT 0
83591: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83592: LD_ADDR_VAR 0 2
83596: PUSH
83597: LD_VAR 0 1
83601: PUSH
83602: LD_INT 55
83604: PUSH
83605: EMPTY
83606: LIST
83607: PPUSH
83608: CALL_OW 69
83612: IN
83613: ST_TO_ADDR
// end ;
83614: LD_VAR 0 2
83618: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83619: LD_INT 0
83621: PPUSH
83622: PPUSH
// list := [ ] ;
83623: LD_ADDR_VAR 0 5
83627: PUSH
83628: EMPTY
83629: ST_TO_ADDR
// case d of 0 :
83630: LD_VAR 0 3
83634: PUSH
83635: LD_INT 0
83637: DOUBLE
83638: EQUAL
83639: IFTRUE 83643
83641: GO 83776
83643: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83644: LD_ADDR_VAR 0 5
83648: PUSH
83649: LD_VAR 0 1
83653: PUSH
83654: LD_INT 4
83656: MINUS
83657: PUSH
83658: LD_VAR 0 2
83662: PUSH
83663: LD_INT 4
83665: MINUS
83666: PUSH
83667: LD_INT 2
83669: PUSH
83670: EMPTY
83671: LIST
83672: LIST
83673: LIST
83674: PUSH
83675: LD_VAR 0 1
83679: PUSH
83680: LD_INT 3
83682: MINUS
83683: PUSH
83684: LD_VAR 0 2
83688: PUSH
83689: LD_INT 1
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: LIST
83696: PUSH
83697: LD_VAR 0 1
83701: PUSH
83702: LD_INT 4
83704: PLUS
83705: PUSH
83706: LD_VAR 0 2
83710: PUSH
83711: LD_INT 4
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: LIST
83718: PUSH
83719: LD_VAR 0 1
83723: PUSH
83724: LD_INT 3
83726: PLUS
83727: PUSH
83728: LD_VAR 0 2
83732: PUSH
83733: LD_INT 3
83735: PLUS
83736: PUSH
83737: LD_INT 5
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: LIST
83744: PUSH
83745: LD_VAR 0 1
83749: PUSH
83750: LD_VAR 0 2
83754: PUSH
83755: LD_INT 4
83757: PLUS
83758: PUSH
83759: LD_INT 0
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: LIST
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: ST_TO_ADDR
// end ; 1 :
83774: GO 84474
83776: LD_INT 1
83778: DOUBLE
83779: EQUAL
83780: IFTRUE 83784
83782: GO 83917
83784: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83785: LD_ADDR_VAR 0 5
83789: PUSH
83790: LD_VAR 0 1
83794: PUSH
83795: LD_VAR 0 2
83799: PUSH
83800: LD_INT 4
83802: MINUS
83803: PUSH
83804: LD_INT 3
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: LIST
83811: PUSH
83812: LD_VAR 0 1
83816: PUSH
83817: LD_INT 3
83819: MINUS
83820: PUSH
83821: LD_VAR 0 2
83825: PUSH
83826: LD_INT 3
83828: MINUS
83829: PUSH
83830: LD_INT 2
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: LIST
83837: PUSH
83838: LD_VAR 0 1
83842: PUSH
83843: LD_INT 4
83845: MINUS
83846: PUSH
83847: LD_VAR 0 2
83851: PUSH
83852: LD_INT 1
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: LIST
83859: PUSH
83860: LD_VAR 0 1
83864: PUSH
83865: LD_VAR 0 2
83869: PUSH
83870: LD_INT 3
83872: PLUS
83873: PUSH
83874: LD_INT 0
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: LIST
83881: PUSH
83882: LD_VAR 0 1
83886: PUSH
83887: LD_INT 4
83889: PLUS
83890: PUSH
83891: LD_VAR 0 2
83895: PUSH
83896: LD_INT 4
83898: PLUS
83899: PUSH
83900: LD_INT 5
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: LIST
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: ST_TO_ADDR
// end ; 2 :
83915: GO 84474
83917: LD_INT 2
83919: DOUBLE
83920: EQUAL
83921: IFTRUE 83925
83923: GO 84054
83925: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83926: LD_ADDR_VAR 0 5
83930: PUSH
83931: LD_VAR 0 1
83935: PUSH
83936: LD_VAR 0 2
83940: PUSH
83941: LD_INT 3
83943: MINUS
83944: PUSH
83945: LD_INT 3
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: LIST
83952: PUSH
83953: LD_VAR 0 1
83957: PUSH
83958: LD_INT 4
83960: PLUS
83961: PUSH
83962: LD_VAR 0 2
83966: PUSH
83967: LD_INT 4
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: LIST
83974: PUSH
83975: LD_VAR 0 1
83979: PUSH
83980: LD_VAR 0 2
83984: PUSH
83985: LD_INT 4
83987: PLUS
83988: PUSH
83989: LD_INT 0
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: LIST
83996: PUSH
83997: LD_VAR 0 1
84001: PUSH
84002: LD_INT 3
84004: MINUS
84005: PUSH
84006: LD_VAR 0 2
84010: PUSH
84011: LD_INT 1
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: LIST
84018: PUSH
84019: LD_VAR 0 1
84023: PUSH
84024: LD_INT 4
84026: MINUS
84027: PUSH
84028: LD_VAR 0 2
84032: PUSH
84033: LD_INT 4
84035: MINUS
84036: PUSH
84037: LD_INT 2
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: LIST
84044: PUSH
84045: EMPTY
84046: LIST
84047: LIST
84048: LIST
84049: LIST
84050: LIST
84051: ST_TO_ADDR
// end ; 3 :
84052: GO 84474
84054: LD_INT 3
84056: DOUBLE
84057: EQUAL
84058: IFTRUE 84062
84060: GO 84195
84062: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84063: LD_ADDR_VAR 0 5
84067: PUSH
84068: LD_VAR 0 1
84072: PUSH
84073: LD_INT 3
84075: PLUS
84076: PUSH
84077: LD_VAR 0 2
84081: PUSH
84082: LD_INT 4
84084: PUSH
84085: EMPTY
84086: LIST
84087: LIST
84088: LIST
84089: PUSH
84090: LD_VAR 0 1
84094: PUSH
84095: LD_INT 4
84097: PLUS
84098: PUSH
84099: LD_VAR 0 2
84103: PUSH
84104: LD_INT 4
84106: PLUS
84107: PUSH
84108: LD_INT 5
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: LIST
84115: PUSH
84116: LD_VAR 0 1
84120: PUSH
84121: LD_INT 4
84123: MINUS
84124: PUSH
84125: LD_VAR 0 2
84129: PUSH
84130: LD_INT 1
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: LIST
84137: PUSH
84138: LD_VAR 0 1
84142: PUSH
84143: LD_VAR 0 2
84147: PUSH
84148: LD_INT 4
84150: MINUS
84151: PUSH
84152: LD_INT 3
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: LIST
84159: PUSH
84160: LD_VAR 0 1
84164: PUSH
84165: LD_INT 3
84167: MINUS
84168: PUSH
84169: LD_VAR 0 2
84173: PUSH
84174: LD_INT 3
84176: MINUS
84177: PUSH
84178: LD_INT 2
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: LIST
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: ST_TO_ADDR
// end ; 4 :
84193: GO 84474
84195: LD_INT 4
84197: DOUBLE
84198: EQUAL
84199: IFTRUE 84203
84201: GO 84336
84203: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84204: LD_ADDR_VAR 0 5
84208: PUSH
84209: LD_VAR 0 1
84213: PUSH
84214: LD_VAR 0 2
84218: PUSH
84219: LD_INT 4
84221: PLUS
84222: PUSH
84223: LD_INT 0
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: LIST
84230: PUSH
84231: LD_VAR 0 1
84235: PUSH
84236: LD_INT 3
84238: PLUS
84239: PUSH
84240: LD_VAR 0 2
84244: PUSH
84245: LD_INT 3
84247: PLUS
84248: PUSH
84249: LD_INT 5
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: LIST
84256: PUSH
84257: LD_VAR 0 1
84261: PUSH
84262: LD_INT 4
84264: PLUS
84265: PUSH
84266: LD_VAR 0 2
84270: PUSH
84271: LD_INT 4
84273: PUSH
84274: EMPTY
84275: LIST
84276: LIST
84277: LIST
84278: PUSH
84279: LD_VAR 0 1
84283: PUSH
84284: LD_VAR 0 2
84288: PUSH
84289: LD_INT 3
84291: MINUS
84292: PUSH
84293: LD_INT 3
84295: PUSH
84296: EMPTY
84297: LIST
84298: LIST
84299: LIST
84300: PUSH
84301: LD_VAR 0 1
84305: PUSH
84306: LD_INT 4
84308: MINUS
84309: PUSH
84310: LD_VAR 0 2
84314: PUSH
84315: LD_INT 4
84317: MINUS
84318: PUSH
84319: LD_INT 2
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: LIST
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: ST_TO_ADDR
// end ; 5 :
84334: GO 84474
84336: LD_INT 5
84338: DOUBLE
84339: EQUAL
84340: IFTRUE 84344
84342: GO 84473
84344: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84345: LD_ADDR_VAR 0 5
84349: PUSH
84350: LD_VAR 0 1
84354: PUSH
84355: LD_INT 4
84357: MINUS
84358: PUSH
84359: LD_VAR 0 2
84363: PUSH
84364: LD_INT 1
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: LIST
84371: PUSH
84372: LD_VAR 0 1
84376: PUSH
84377: LD_VAR 0 2
84381: PUSH
84382: LD_INT 4
84384: MINUS
84385: PUSH
84386: LD_INT 3
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: LIST
84393: PUSH
84394: LD_VAR 0 1
84398: PUSH
84399: LD_INT 4
84401: PLUS
84402: PUSH
84403: LD_VAR 0 2
84407: PUSH
84408: LD_INT 4
84410: PLUS
84411: PUSH
84412: LD_INT 5
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: LIST
84419: PUSH
84420: LD_VAR 0 1
84424: PUSH
84425: LD_INT 3
84427: PLUS
84428: PUSH
84429: LD_VAR 0 2
84433: PUSH
84434: LD_INT 4
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: LIST
84441: PUSH
84442: LD_VAR 0 1
84446: PUSH
84447: LD_VAR 0 2
84451: PUSH
84452: LD_INT 3
84454: PLUS
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: LIST
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: ST_TO_ADDR
// end ; end ;
84471: GO 84474
84473: POP
// result := list ;
84474: LD_ADDR_VAR 0 4
84478: PUSH
84479: LD_VAR 0 5
84483: ST_TO_ADDR
// end ;
84484: LD_VAR 0 4
84488: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84489: LD_INT 0
84491: PPUSH
84492: PPUSH
84493: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84494: LD_VAR 0 1
84498: NOT
84499: PUSH
84500: LD_VAR 0 2
84504: PUSH
84505: LD_INT 1
84507: PUSH
84508: LD_INT 2
84510: PUSH
84511: LD_INT 3
84513: PUSH
84514: LD_INT 4
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: IN
84523: NOT
84524: OR
84525: IFFALSE 84529
// exit ;
84527: GO 84621
// tmp := [ ] ;
84529: LD_ADDR_VAR 0 5
84533: PUSH
84534: EMPTY
84535: ST_TO_ADDR
// for i in units do
84536: LD_ADDR_VAR 0 4
84540: PUSH
84541: LD_VAR 0 1
84545: PUSH
84546: FOR_IN
84547: IFFALSE 84590
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
84549: LD_ADDR_VAR 0 5
84553: PUSH
84554: LD_VAR 0 5
84558: PPUSH
84559: LD_VAR 0 5
84563: PUSH
84564: LD_INT 1
84566: PLUS
84567: PPUSH
84568: LD_VAR 0 4
84572: PPUSH
84573: LD_VAR 0 2
84577: PPUSH
84578: CALL_OW 259
84582: PPUSH
84583: CALL_OW 2
84587: ST_TO_ADDR
84588: GO 84546
84590: POP
84591: POP
// if not tmp then
84592: LD_VAR 0 5
84596: NOT
84597: IFFALSE 84601
// exit ;
84599: GO 84621
// result := SortListByListDesc ( units , tmp ) ;
84601: LD_ADDR_VAR 0 3
84605: PUSH
84606: LD_VAR 0 1
84610: PPUSH
84611: LD_VAR 0 5
84615: PPUSH
84616: CALL_OW 77
84620: ST_TO_ADDR
// end ;
84621: LD_VAR 0 3
84625: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84626: LD_INT 0
84628: PPUSH
84629: PPUSH
84630: PPUSH
// result := false ;
84631: LD_ADDR_VAR 0 3
84635: PUSH
84636: LD_INT 0
84638: ST_TO_ADDR
// x := GetX ( building ) ;
84639: LD_ADDR_VAR 0 4
84643: PUSH
84644: LD_VAR 0 2
84648: PPUSH
84649: CALL_OW 250
84653: ST_TO_ADDR
// y := GetY ( building ) ;
84654: LD_ADDR_VAR 0 5
84658: PUSH
84659: LD_VAR 0 2
84663: PPUSH
84664: CALL_OW 251
84668: ST_TO_ADDR
// if not building or not x or not y then
84669: LD_VAR 0 2
84673: NOT
84674: PUSH
84675: LD_VAR 0 4
84679: NOT
84680: OR
84681: PUSH
84682: LD_VAR 0 5
84686: NOT
84687: OR
84688: IFFALSE 84692
// exit ;
84690: GO 84784
// if GetTaskList ( unit ) then
84692: LD_VAR 0 1
84696: PPUSH
84697: CALL_OW 437
84701: IFFALSE 84784
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84703: LD_STRING e
84705: PUSH
84706: LD_VAR 0 1
84710: PPUSH
84711: CALL_OW 437
84715: PUSH
84716: LD_INT 1
84718: ARRAY
84719: PUSH
84720: LD_INT 1
84722: ARRAY
84723: EQUAL
84724: PUSH
84725: LD_VAR 0 4
84729: PUSH
84730: LD_VAR 0 1
84734: PPUSH
84735: CALL_OW 437
84739: PUSH
84740: LD_INT 1
84742: ARRAY
84743: PUSH
84744: LD_INT 2
84746: ARRAY
84747: EQUAL
84748: AND
84749: PUSH
84750: LD_VAR 0 5
84754: PUSH
84755: LD_VAR 0 1
84759: PPUSH
84760: CALL_OW 437
84764: PUSH
84765: LD_INT 1
84767: ARRAY
84768: PUSH
84769: LD_INT 3
84771: ARRAY
84772: EQUAL
84773: AND
84774: IFFALSE 84784
// result := true end ;
84776: LD_ADDR_VAR 0 3
84780: PUSH
84781: LD_INT 1
84783: ST_TO_ADDR
// end ;
84784: LD_VAR 0 3
84788: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84789: LD_INT 0
84791: PPUSH
// result := false ;
84792: LD_ADDR_VAR 0 4
84796: PUSH
84797: LD_INT 0
84799: ST_TO_ADDR
// if GetTaskList ( unit ) then
84800: LD_VAR 0 1
84804: PPUSH
84805: CALL_OW 437
84809: IFFALSE 84892
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84811: LD_STRING M
84813: PUSH
84814: LD_VAR 0 1
84818: PPUSH
84819: CALL_OW 437
84823: PUSH
84824: LD_INT 1
84826: ARRAY
84827: PUSH
84828: LD_INT 1
84830: ARRAY
84831: EQUAL
84832: PUSH
84833: LD_VAR 0 2
84837: PUSH
84838: LD_VAR 0 1
84842: PPUSH
84843: CALL_OW 437
84847: PUSH
84848: LD_INT 1
84850: ARRAY
84851: PUSH
84852: LD_INT 2
84854: ARRAY
84855: EQUAL
84856: AND
84857: PUSH
84858: LD_VAR 0 3
84862: PUSH
84863: LD_VAR 0 1
84867: PPUSH
84868: CALL_OW 437
84872: PUSH
84873: LD_INT 1
84875: ARRAY
84876: PUSH
84877: LD_INT 3
84879: ARRAY
84880: EQUAL
84881: AND
84882: IFFALSE 84892
// result := true ;
84884: LD_ADDR_VAR 0 4
84888: PUSH
84889: LD_INT 1
84891: ST_TO_ADDR
// end ; end ;
84892: LD_VAR 0 4
84896: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84897: LD_INT 0
84899: PPUSH
84900: PPUSH
84901: PPUSH
84902: PPUSH
// if not unit or not area then
84903: LD_VAR 0 1
84907: NOT
84908: PUSH
84909: LD_VAR 0 2
84913: NOT
84914: OR
84915: IFFALSE 84919
// exit ;
84917: GO 85083
// tmp := AreaToList ( area , i ) ;
84919: LD_ADDR_VAR 0 6
84923: PUSH
84924: LD_VAR 0 2
84928: PPUSH
84929: LD_VAR 0 5
84933: PPUSH
84934: CALL_OW 517
84938: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84939: LD_ADDR_VAR 0 5
84943: PUSH
84944: DOUBLE
84945: LD_INT 1
84947: DEC
84948: ST_TO_ADDR
84949: LD_VAR 0 6
84953: PUSH
84954: LD_INT 1
84956: ARRAY
84957: PUSH
84958: FOR_TO
84959: IFFALSE 85081
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84961: LD_ADDR_VAR 0 7
84965: PUSH
84966: LD_VAR 0 6
84970: PUSH
84971: LD_INT 1
84973: ARRAY
84974: PUSH
84975: LD_VAR 0 5
84979: ARRAY
84980: PUSH
84981: LD_VAR 0 6
84985: PUSH
84986: LD_INT 2
84988: ARRAY
84989: PUSH
84990: LD_VAR 0 5
84994: ARRAY
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85000: LD_VAR 0 7
85004: PUSH
85005: LD_INT 1
85007: ARRAY
85008: PPUSH
85009: LD_VAR 0 7
85013: PUSH
85014: LD_INT 2
85016: ARRAY
85017: PPUSH
85018: CALL_OW 428
85022: PUSH
85023: LD_INT 0
85025: EQUAL
85026: IFFALSE 85079
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85028: LD_VAR 0 1
85032: PPUSH
85033: LD_VAR 0 7
85037: PUSH
85038: LD_INT 1
85040: ARRAY
85041: PPUSH
85042: LD_VAR 0 7
85046: PUSH
85047: LD_INT 2
85049: ARRAY
85050: PPUSH
85051: LD_VAR 0 3
85055: PPUSH
85056: CALL_OW 48
// result := IsPlaced ( unit ) ;
85060: LD_ADDR_VAR 0 4
85064: PUSH
85065: LD_VAR 0 1
85069: PPUSH
85070: CALL_OW 305
85074: ST_TO_ADDR
// exit ;
85075: POP
85076: POP
85077: GO 85083
// end ; end ;
85079: GO 84958
85081: POP
85082: POP
// end ;
85083: LD_VAR 0 4
85087: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85088: LD_INT 0
85090: PPUSH
85091: PPUSH
85092: PPUSH
// if not side or side > 8 then
85093: LD_VAR 0 1
85097: NOT
85098: PUSH
85099: LD_VAR 0 1
85103: PUSH
85104: LD_INT 8
85106: GREATER
85107: OR
85108: IFFALSE 85112
// exit ;
85110: GO 85299
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85112: LD_ADDR_VAR 0 4
85116: PUSH
85117: LD_INT 22
85119: PUSH
85120: LD_VAR 0 1
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 21
85131: PUSH
85132: LD_INT 3
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: EMPTY
85140: LIST
85141: LIST
85142: PPUSH
85143: CALL_OW 69
85147: ST_TO_ADDR
// if not tmp then
85148: LD_VAR 0 4
85152: NOT
85153: IFFALSE 85157
// exit ;
85155: GO 85299
// enable_addtolog := true ;
85157: LD_ADDR_OWVAR 81
85161: PUSH
85162: LD_INT 1
85164: ST_TO_ADDR
// AddToLog ( [ ) ;
85165: LD_STRING [
85167: PPUSH
85168: CALL_OW 561
// for i in tmp do
85172: LD_ADDR_VAR 0 3
85176: PUSH
85177: LD_VAR 0 4
85181: PUSH
85182: FOR_IN
85183: IFFALSE 85290
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85185: LD_STRING [
85187: PUSH
85188: LD_VAR 0 3
85192: PPUSH
85193: CALL_OW 266
85197: STR
85198: PUSH
85199: LD_STRING , 
85201: STR
85202: PUSH
85203: LD_VAR 0 3
85207: PPUSH
85208: CALL_OW 250
85212: STR
85213: PUSH
85214: LD_STRING , 
85216: STR
85217: PUSH
85218: LD_VAR 0 3
85222: PPUSH
85223: CALL_OW 251
85227: STR
85228: PUSH
85229: LD_STRING , 
85231: STR
85232: PUSH
85233: LD_VAR 0 3
85237: PPUSH
85238: CALL_OW 254
85242: STR
85243: PUSH
85244: LD_STRING , 
85246: STR
85247: PUSH
85248: LD_VAR 0 3
85252: PPUSH
85253: LD_INT 1
85255: PPUSH
85256: CALL_OW 268
85260: STR
85261: PUSH
85262: LD_STRING , 
85264: STR
85265: PUSH
85266: LD_VAR 0 3
85270: PPUSH
85271: LD_INT 2
85273: PPUSH
85274: CALL_OW 268
85278: STR
85279: PUSH
85280: LD_STRING ],
85282: STR
85283: PPUSH
85284: CALL_OW 561
// end ;
85288: GO 85182
85290: POP
85291: POP
// AddToLog ( ]; ) ;
85292: LD_STRING ];
85294: PPUSH
85295: CALL_OW 561
// end ;
85299: LD_VAR 0 2
85303: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85304: LD_INT 0
85306: PPUSH
85307: PPUSH
85308: PPUSH
85309: PPUSH
85310: PPUSH
// if not area or not rate or not max then
85311: LD_VAR 0 1
85315: NOT
85316: PUSH
85317: LD_VAR 0 2
85321: NOT
85322: OR
85323: PUSH
85324: LD_VAR 0 4
85328: NOT
85329: OR
85330: IFFALSE 85334
// exit ;
85332: GO 85523
// while 1 do
85334: LD_INT 1
85336: IFFALSE 85523
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85338: LD_ADDR_VAR 0 9
85342: PUSH
85343: LD_VAR 0 1
85347: PPUSH
85348: LD_INT 1
85350: PPUSH
85351: CALL_OW 287
85355: PUSH
85356: LD_INT 10
85358: MUL
85359: ST_TO_ADDR
// r := rate / 10 ;
85360: LD_ADDR_VAR 0 7
85364: PUSH
85365: LD_VAR 0 2
85369: PUSH
85370: LD_INT 10
85372: DIVREAL
85373: ST_TO_ADDR
// time := 1 1$00 ;
85374: LD_ADDR_VAR 0 8
85378: PUSH
85379: LD_INT 2100
85381: ST_TO_ADDR
// if amount < min then
85382: LD_VAR 0 9
85386: PUSH
85387: LD_VAR 0 3
85391: LESS
85392: IFFALSE 85410
// r := r * 2 else
85394: LD_ADDR_VAR 0 7
85398: PUSH
85399: LD_VAR 0 7
85403: PUSH
85404: LD_INT 2
85406: MUL
85407: ST_TO_ADDR
85408: GO 85436
// if amount > max then
85410: LD_VAR 0 9
85414: PUSH
85415: LD_VAR 0 4
85419: GREATER
85420: IFFALSE 85436
// r := r / 2 ;
85422: LD_ADDR_VAR 0 7
85426: PUSH
85427: LD_VAR 0 7
85431: PUSH
85432: LD_INT 2
85434: DIVREAL
85435: ST_TO_ADDR
// time := time / r ;
85436: LD_ADDR_VAR 0 8
85440: PUSH
85441: LD_VAR 0 8
85445: PUSH
85446: LD_VAR 0 7
85450: DIVREAL
85451: ST_TO_ADDR
// if time < 0 then
85452: LD_VAR 0 8
85456: PUSH
85457: LD_INT 0
85459: LESS
85460: IFFALSE 85477
// time := time * - 1 ;
85462: LD_ADDR_VAR 0 8
85466: PUSH
85467: LD_VAR 0 8
85471: PUSH
85472: LD_INT 1
85474: NEG
85475: MUL
85476: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85477: LD_VAR 0 8
85481: PUSH
85482: LD_INT 35
85484: PPUSH
85485: LD_INT 875
85487: PPUSH
85488: CALL_OW 12
85492: PLUS
85493: PPUSH
85494: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85498: LD_INT 1
85500: PPUSH
85501: LD_INT 5
85503: PPUSH
85504: CALL_OW 12
85508: PPUSH
85509: LD_VAR 0 1
85513: PPUSH
85514: LD_INT 1
85516: PPUSH
85517: CALL_OW 55
// end ;
85521: GO 85334
// end ;
85523: LD_VAR 0 5
85527: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85528: LD_INT 0
85530: PPUSH
85531: PPUSH
85532: PPUSH
85533: PPUSH
85534: PPUSH
85535: PPUSH
85536: PPUSH
85537: PPUSH
// if not turrets or not factories then
85538: LD_VAR 0 1
85542: NOT
85543: PUSH
85544: LD_VAR 0 2
85548: NOT
85549: OR
85550: IFFALSE 85554
// exit ;
85552: GO 85861
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85554: LD_ADDR_VAR 0 10
85558: PUSH
85559: LD_INT 5
85561: PUSH
85562: LD_INT 6
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 2
85571: PUSH
85572: LD_INT 4
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PUSH
85579: LD_INT 3
85581: PUSH
85582: LD_INT 5
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 24
85596: PUSH
85597: LD_INT 25
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 23
85606: PUSH
85607: LD_INT 27
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 42
85620: PUSH
85621: LD_INT 43
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: LD_INT 44
85630: PUSH
85631: LD_INT 46
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: PUSH
85638: LD_INT 45
85640: PUSH
85641: LD_INT 47
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: LIST
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: LIST
85657: ST_TO_ADDR
// result := [ ] ;
85658: LD_ADDR_VAR 0 3
85662: PUSH
85663: EMPTY
85664: ST_TO_ADDR
// for i in turrets do
85665: LD_ADDR_VAR 0 4
85669: PUSH
85670: LD_VAR 0 1
85674: PUSH
85675: FOR_IN
85676: IFFALSE 85859
// begin nat := GetNation ( i ) ;
85678: LD_ADDR_VAR 0 7
85682: PUSH
85683: LD_VAR 0 4
85687: PPUSH
85688: CALL_OW 248
85692: ST_TO_ADDR
// weapon := 0 ;
85693: LD_ADDR_VAR 0 8
85697: PUSH
85698: LD_INT 0
85700: ST_TO_ADDR
// if not nat then
85701: LD_VAR 0 7
85705: NOT
85706: IFFALSE 85710
// continue ;
85708: GO 85675
// for j in list [ nat ] do
85710: LD_ADDR_VAR 0 5
85714: PUSH
85715: LD_VAR 0 10
85719: PUSH
85720: LD_VAR 0 7
85724: ARRAY
85725: PUSH
85726: FOR_IN
85727: IFFALSE 85768
// if GetBWeapon ( i ) = j [ 1 ] then
85729: LD_VAR 0 4
85733: PPUSH
85734: CALL_OW 269
85738: PUSH
85739: LD_VAR 0 5
85743: PUSH
85744: LD_INT 1
85746: ARRAY
85747: EQUAL
85748: IFFALSE 85766
// begin weapon := j [ 2 ] ;
85750: LD_ADDR_VAR 0 8
85754: PUSH
85755: LD_VAR 0 5
85759: PUSH
85760: LD_INT 2
85762: ARRAY
85763: ST_TO_ADDR
// break ;
85764: GO 85768
// end ;
85766: GO 85726
85768: POP
85769: POP
// if not weapon then
85770: LD_VAR 0 8
85774: NOT
85775: IFFALSE 85779
// continue ;
85777: GO 85675
// for k in factories do
85779: LD_ADDR_VAR 0 6
85783: PUSH
85784: LD_VAR 0 2
85788: PUSH
85789: FOR_IN
85790: IFFALSE 85855
// begin weapons := AvailableWeaponList ( k ) ;
85792: LD_ADDR_VAR 0 9
85796: PUSH
85797: LD_VAR 0 6
85801: PPUSH
85802: CALL_OW 478
85806: ST_TO_ADDR
// if not weapons then
85807: LD_VAR 0 9
85811: NOT
85812: IFFALSE 85816
// continue ;
85814: GO 85789
// if weapon in weapons then
85816: LD_VAR 0 8
85820: PUSH
85821: LD_VAR 0 9
85825: IN
85826: IFFALSE 85853
// begin result := [ i , weapon ] ;
85828: LD_ADDR_VAR 0 3
85832: PUSH
85833: LD_VAR 0 4
85837: PUSH
85838: LD_VAR 0 8
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: ST_TO_ADDR
// exit ;
85847: POP
85848: POP
85849: POP
85850: POP
85851: GO 85861
// end ; end ;
85853: GO 85789
85855: POP
85856: POP
// end ;
85857: GO 85675
85859: POP
85860: POP
// end ;
85861: LD_VAR 0 3
85865: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85866: LD_INT 0
85868: PPUSH
// if not side or side > 8 then
85869: LD_VAR 0 3
85873: NOT
85874: PUSH
85875: LD_VAR 0 3
85879: PUSH
85880: LD_INT 8
85882: GREATER
85883: OR
85884: IFFALSE 85888
// exit ;
85886: GO 85947
// if not range then
85888: LD_VAR 0 4
85892: NOT
85893: IFFALSE 85904
// range := - 12 ;
85895: LD_ADDR_VAR 0 4
85899: PUSH
85900: LD_INT 12
85902: NEG
85903: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
85904: LD_VAR 0 1
85908: PPUSH
85909: LD_VAR 0 2
85913: PPUSH
85914: LD_VAR 0 3
85918: PPUSH
85919: LD_VAR 0 4
85923: PPUSH
85924: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85928: LD_VAR 0 1
85932: PPUSH
85933: LD_VAR 0 2
85937: PPUSH
85938: LD_VAR 0 3
85942: PPUSH
85943: CALL_OW 331
// end ;
85947: LD_VAR 0 5
85951: RET
// export function Video ( mode ) ; begin
85952: LD_INT 0
85954: PPUSH
// ingame_video = mode ;
85955: LD_ADDR_OWVAR 52
85959: PUSH
85960: LD_VAR 0 1
85964: ST_TO_ADDR
// interface_hidden = mode ;
85965: LD_ADDR_OWVAR 54
85969: PUSH
85970: LD_VAR 0 1
85974: ST_TO_ADDR
// end ;
85975: LD_VAR 0 2
85979: RET
// export function Join ( array , element ) ; begin
85980: LD_INT 0
85982: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85983: LD_ADDR_VAR 0 3
85987: PUSH
85988: LD_VAR 0 1
85992: PPUSH
85993: LD_VAR 0 1
85997: PUSH
85998: LD_INT 1
86000: PLUS
86001: PPUSH
86002: LD_VAR 0 2
86006: PPUSH
86007: CALL_OW 1
86011: ST_TO_ADDR
// end ;
86012: LD_VAR 0 3
86016: RET
// export function JoinUnion ( array , element ) ; begin
86017: LD_INT 0
86019: PPUSH
// result := array union element ;
86020: LD_ADDR_VAR 0 3
86024: PUSH
86025: LD_VAR 0 1
86029: PUSH
86030: LD_VAR 0 2
86034: UNION
86035: ST_TO_ADDR
// end ;
86036: LD_VAR 0 3
86040: RET
// export function GetBehemoths ( side ) ; begin
86041: LD_INT 0
86043: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86044: LD_ADDR_VAR 0 2
86048: PUSH
86049: LD_INT 22
86051: PUSH
86052: LD_VAR 0 1
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 31
86063: PUSH
86064: LD_INT 25
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PPUSH
86075: CALL_OW 69
86079: ST_TO_ADDR
// end ;
86080: LD_VAR 0 2
86084: RET
// export function Shuffle ( array ) ; var i , index ; begin
86085: LD_INT 0
86087: PPUSH
86088: PPUSH
86089: PPUSH
// result := [ ] ;
86090: LD_ADDR_VAR 0 2
86094: PUSH
86095: EMPTY
86096: ST_TO_ADDR
// if not array then
86097: LD_VAR 0 1
86101: NOT
86102: IFFALSE 86106
// exit ;
86104: GO 86205
// Randomize ;
86106: CALL_OW 10
// for i = array downto 1 do
86110: LD_ADDR_VAR 0 3
86114: PUSH
86115: DOUBLE
86116: LD_VAR 0 1
86120: INC
86121: ST_TO_ADDR
86122: LD_INT 1
86124: PUSH
86125: FOR_DOWNTO
86126: IFFALSE 86203
// begin index := rand ( 1 , array ) ;
86128: LD_ADDR_VAR 0 4
86132: PUSH
86133: LD_INT 1
86135: PPUSH
86136: LD_VAR 0 1
86140: PPUSH
86141: CALL_OW 12
86145: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86146: LD_ADDR_VAR 0 2
86150: PUSH
86151: LD_VAR 0 2
86155: PPUSH
86156: LD_VAR 0 2
86160: PUSH
86161: LD_INT 1
86163: PLUS
86164: PPUSH
86165: LD_VAR 0 1
86169: PUSH
86170: LD_VAR 0 4
86174: ARRAY
86175: PPUSH
86176: CALL_OW 2
86180: ST_TO_ADDR
// array := Delete ( array , index ) ;
86181: LD_ADDR_VAR 0 1
86185: PUSH
86186: LD_VAR 0 1
86190: PPUSH
86191: LD_VAR 0 4
86195: PPUSH
86196: CALL_OW 3
86200: ST_TO_ADDR
// end ;
86201: GO 86125
86203: POP
86204: POP
// end ;
86205: LD_VAR 0 2
86209: RET
// export function GetBaseMaterials ( base ) ; begin
86210: LD_INT 0
86212: PPUSH
// result := [ 0 , 0 , 0 ] ;
86213: LD_ADDR_VAR 0 2
86217: PUSH
86218: LD_INT 0
86220: PUSH
86221: LD_INT 0
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: LIST
86231: ST_TO_ADDR
// if not base then
86232: LD_VAR 0 1
86236: NOT
86237: IFFALSE 86241
// exit ;
86239: GO 86290
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86241: LD_ADDR_VAR 0 2
86245: PUSH
86246: LD_VAR 0 1
86250: PPUSH
86251: LD_INT 1
86253: PPUSH
86254: CALL_OW 275
86258: PUSH
86259: LD_VAR 0 1
86263: PPUSH
86264: LD_INT 2
86266: PPUSH
86267: CALL_OW 275
86271: PUSH
86272: LD_VAR 0 1
86276: PPUSH
86277: LD_INT 3
86279: PPUSH
86280: CALL_OW 275
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: LIST
86289: ST_TO_ADDR
// end ;
86290: LD_VAR 0 2
86294: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86295: LD_INT 0
86297: PPUSH
86298: PPUSH
// result := array ;
86299: LD_ADDR_VAR 0 3
86303: PUSH
86304: LD_VAR 0 1
86308: ST_TO_ADDR
// if size >= result then
86309: LD_VAR 0 2
86313: PUSH
86314: LD_VAR 0 3
86318: GREATEREQUAL
86319: IFFALSE 86323
// exit ;
86321: GO 86373
// if size then
86323: LD_VAR 0 2
86327: IFFALSE 86373
// for i := array downto size do
86329: LD_ADDR_VAR 0 4
86333: PUSH
86334: DOUBLE
86335: LD_VAR 0 1
86339: INC
86340: ST_TO_ADDR
86341: LD_VAR 0 2
86345: PUSH
86346: FOR_DOWNTO
86347: IFFALSE 86371
// result := Delete ( result , result ) ;
86349: LD_ADDR_VAR 0 3
86353: PUSH
86354: LD_VAR 0 3
86358: PPUSH
86359: LD_VAR 0 3
86363: PPUSH
86364: CALL_OW 3
86368: ST_TO_ADDR
86369: GO 86346
86371: POP
86372: POP
// end ;
86373: LD_VAR 0 3
86377: RET
// export function ComExit ( unit ) ; var tmp ; begin
86378: LD_INT 0
86380: PPUSH
86381: PPUSH
// if not IsInUnit ( unit ) then
86382: LD_VAR 0 1
86386: PPUSH
86387: CALL_OW 310
86391: NOT
86392: IFFALSE 86396
// exit ;
86394: GO 86456
// tmp := IsInUnit ( unit ) ;
86396: LD_ADDR_VAR 0 3
86400: PUSH
86401: LD_VAR 0 1
86405: PPUSH
86406: CALL_OW 310
86410: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86411: LD_VAR 0 3
86415: PPUSH
86416: CALL_OW 247
86420: PUSH
86421: LD_INT 2
86423: EQUAL
86424: IFFALSE 86437
// ComExitVehicle ( unit ) else
86426: LD_VAR 0 1
86430: PPUSH
86431: CALL_OW 121
86435: GO 86446
// ComExitBuilding ( unit ) ;
86437: LD_VAR 0 1
86441: PPUSH
86442: CALL_OW 122
// result := tmp ;
86446: LD_ADDR_VAR 0 2
86450: PUSH
86451: LD_VAR 0 3
86455: ST_TO_ADDR
// end ;
86456: LD_VAR 0 2
86460: RET
// export function ComExitAll ( units ) ; var i ; begin
86461: LD_INT 0
86463: PPUSH
86464: PPUSH
// if not units then
86465: LD_VAR 0 1
86469: NOT
86470: IFFALSE 86474
// exit ;
86472: GO 86500
// for i in units do
86474: LD_ADDR_VAR 0 3
86478: PUSH
86479: LD_VAR 0 1
86483: PUSH
86484: FOR_IN
86485: IFFALSE 86498
// ComExit ( i ) ;
86487: LD_VAR 0 3
86491: PPUSH
86492: CALL 86378 0 1
86496: GO 86484
86498: POP
86499: POP
// end ;
86500: LD_VAR 0 2
86504: RET
// export function ResetHc ; begin
86505: LD_INT 0
86507: PPUSH
// InitHc ;
86508: CALL_OW 19
// hc_importance := 0 ;
86512: LD_ADDR_OWVAR 32
86516: PUSH
86517: LD_INT 0
86519: ST_TO_ADDR
// end ;
86520: LD_VAR 0 1
86524: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86525: LD_INT 0
86527: PPUSH
86528: PPUSH
86529: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86530: LD_ADDR_VAR 0 6
86534: PUSH
86535: LD_VAR 0 1
86539: PUSH
86540: LD_VAR 0 3
86544: PLUS
86545: PUSH
86546: LD_INT 2
86548: DIV
86549: ST_TO_ADDR
// if _x < 0 then
86550: LD_VAR 0 6
86554: PUSH
86555: LD_INT 0
86557: LESS
86558: IFFALSE 86575
// _x := _x * - 1 ;
86560: LD_ADDR_VAR 0 6
86564: PUSH
86565: LD_VAR 0 6
86569: PUSH
86570: LD_INT 1
86572: NEG
86573: MUL
86574: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86575: LD_ADDR_VAR 0 7
86579: PUSH
86580: LD_VAR 0 2
86584: PUSH
86585: LD_VAR 0 4
86589: PLUS
86590: PUSH
86591: LD_INT 2
86593: DIV
86594: ST_TO_ADDR
// if _y < 0 then
86595: LD_VAR 0 7
86599: PUSH
86600: LD_INT 0
86602: LESS
86603: IFFALSE 86620
// _y := _y * - 1 ;
86605: LD_ADDR_VAR 0 7
86609: PUSH
86610: LD_VAR 0 7
86614: PUSH
86615: LD_INT 1
86617: NEG
86618: MUL
86619: ST_TO_ADDR
// result := [ _x , _y ] ;
86620: LD_ADDR_VAR 0 5
86624: PUSH
86625: LD_VAR 0 6
86629: PUSH
86630: LD_VAR 0 7
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: ST_TO_ADDR
// end ;
86639: LD_VAR 0 5
86643: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
86644: LD_INT 0
86646: PPUSH
86647: PPUSH
86648: PPUSH
86649: PPUSH
// task := GetTaskList ( unit ) ;
86650: LD_ADDR_VAR 0 7
86654: PUSH
86655: LD_VAR 0 1
86659: PPUSH
86660: CALL_OW 437
86664: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
86665: LD_VAR 0 7
86669: NOT
86670: PUSH
86671: LD_VAR 0 1
86675: PPUSH
86676: LD_VAR 0 2
86680: PPUSH
86681: CALL_OW 308
86685: NOT
86686: AND
86687: IFFALSE 86691
// exit ;
86689: GO 86809
// if IsInArea ( unit , area ) then
86691: LD_VAR 0 1
86695: PPUSH
86696: LD_VAR 0 2
86700: PPUSH
86701: CALL_OW 308
86705: IFFALSE 86723
// begin ComMoveToArea ( unit , goAway ) ;
86707: LD_VAR 0 1
86711: PPUSH
86712: LD_VAR 0 3
86716: PPUSH
86717: CALL_OW 113
// exit ;
86721: GO 86809
// end ; if task [ 1 ] [ 1 ] <> M then
86723: LD_VAR 0 7
86727: PUSH
86728: LD_INT 1
86730: ARRAY
86731: PUSH
86732: LD_INT 1
86734: ARRAY
86735: PUSH
86736: LD_STRING M
86738: NONEQUAL
86739: IFFALSE 86743
// exit ;
86741: GO 86809
// x := task [ 1 ] [ 2 ] ;
86743: LD_ADDR_VAR 0 5
86747: PUSH
86748: LD_VAR 0 7
86752: PUSH
86753: LD_INT 1
86755: ARRAY
86756: PUSH
86757: LD_INT 2
86759: ARRAY
86760: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86761: LD_ADDR_VAR 0 6
86765: PUSH
86766: LD_VAR 0 7
86770: PUSH
86771: LD_INT 1
86773: ARRAY
86774: PUSH
86775: LD_INT 3
86777: ARRAY
86778: ST_TO_ADDR
// if InArea ( x , y , area ) then
86779: LD_VAR 0 5
86783: PPUSH
86784: LD_VAR 0 6
86788: PPUSH
86789: LD_VAR 0 2
86793: PPUSH
86794: CALL_OW 309
86798: IFFALSE 86809
// ComStop ( unit ) ;
86800: LD_VAR 0 1
86804: PPUSH
86805: CALL_OW 141
// end ;
86809: LD_VAR 0 4
86813: RET
// export function Abs ( value ) ; begin
86814: LD_INT 0
86816: PPUSH
// result := value ;
86817: LD_ADDR_VAR 0 2
86821: PUSH
86822: LD_VAR 0 1
86826: ST_TO_ADDR
// if value < 0 then
86827: LD_VAR 0 1
86831: PUSH
86832: LD_INT 0
86834: LESS
86835: IFFALSE 86852
// result := value * - 1 ;
86837: LD_ADDR_VAR 0 2
86841: PUSH
86842: LD_VAR 0 1
86846: PUSH
86847: LD_INT 1
86849: NEG
86850: MUL
86851: ST_TO_ADDR
// end ;
86852: LD_VAR 0 2
86856: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86857: LD_INT 0
86859: PPUSH
86860: PPUSH
86861: PPUSH
86862: PPUSH
86863: PPUSH
86864: PPUSH
86865: PPUSH
86866: PPUSH
// if not unit or not building then
86867: LD_VAR 0 1
86871: NOT
86872: PUSH
86873: LD_VAR 0 2
86877: NOT
86878: OR
86879: IFFALSE 86883
// exit ;
86881: GO 87109
// x := GetX ( building ) ;
86883: LD_ADDR_VAR 0 4
86887: PUSH
86888: LD_VAR 0 2
86892: PPUSH
86893: CALL_OW 250
86897: ST_TO_ADDR
// y := GetY ( building ) ;
86898: LD_ADDR_VAR 0 6
86902: PUSH
86903: LD_VAR 0 2
86907: PPUSH
86908: CALL_OW 251
86912: ST_TO_ADDR
// d := GetDir ( building ) ;
86913: LD_ADDR_VAR 0 8
86917: PUSH
86918: LD_VAR 0 2
86922: PPUSH
86923: CALL_OW 254
86927: ST_TO_ADDR
// r := 4 ;
86928: LD_ADDR_VAR 0 9
86932: PUSH
86933: LD_INT 4
86935: ST_TO_ADDR
// for i := 1 to 5 do
86936: LD_ADDR_VAR 0 10
86940: PUSH
86941: DOUBLE
86942: LD_INT 1
86944: DEC
86945: ST_TO_ADDR
86946: LD_INT 5
86948: PUSH
86949: FOR_TO
86950: IFFALSE 87107
// begin _x := ShiftX ( x , d , r + i ) ;
86952: LD_ADDR_VAR 0 5
86956: PUSH
86957: LD_VAR 0 4
86961: PPUSH
86962: LD_VAR 0 8
86966: PPUSH
86967: LD_VAR 0 9
86971: PUSH
86972: LD_VAR 0 10
86976: PLUS
86977: PPUSH
86978: CALL_OW 272
86982: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86983: LD_ADDR_VAR 0 7
86987: PUSH
86988: LD_VAR 0 6
86992: PPUSH
86993: LD_VAR 0 8
86997: PPUSH
86998: LD_VAR 0 9
87002: PUSH
87003: LD_VAR 0 10
87007: PLUS
87008: PPUSH
87009: CALL_OW 273
87013: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87014: LD_VAR 0 5
87018: PPUSH
87019: LD_VAR 0 7
87023: PPUSH
87024: CALL_OW 488
87028: PUSH
87029: LD_VAR 0 5
87033: PPUSH
87034: LD_VAR 0 7
87038: PPUSH
87039: CALL_OW 428
87043: PPUSH
87044: CALL_OW 247
87048: PUSH
87049: LD_INT 3
87051: PUSH
87052: LD_INT 2
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: IN
87059: NOT
87060: AND
87061: IFFALSE 87105
// begin ComMoveXY ( unit , _x , _y ) ;
87063: LD_VAR 0 1
87067: PPUSH
87068: LD_VAR 0 5
87072: PPUSH
87073: LD_VAR 0 7
87077: PPUSH
87078: CALL_OW 111
// result := [ _x , _y ] ;
87082: LD_ADDR_VAR 0 3
87086: PUSH
87087: LD_VAR 0 5
87091: PUSH
87092: LD_VAR 0 7
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: ST_TO_ADDR
// exit ;
87101: POP
87102: POP
87103: GO 87109
// end ; end ;
87105: GO 86949
87107: POP
87108: POP
// end ;
87109: LD_VAR 0 3
87113: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87114: LD_INT 0
87116: PPUSH
87117: PPUSH
87118: PPUSH
// result := 0 ;
87119: LD_ADDR_VAR 0 3
87123: PUSH
87124: LD_INT 0
87126: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87127: LD_VAR 0 1
87131: PUSH
87132: LD_INT 0
87134: LESS
87135: PUSH
87136: LD_VAR 0 1
87140: PUSH
87141: LD_INT 8
87143: GREATER
87144: OR
87145: PUSH
87146: LD_VAR 0 2
87150: PUSH
87151: LD_INT 0
87153: LESS
87154: OR
87155: PUSH
87156: LD_VAR 0 2
87160: PUSH
87161: LD_INT 8
87163: GREATER
87164: OR
87165: IFFALSE 87169
// exit ;
87167: GO 87244
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87169: LD_ADDR_VAR 0 4
87173: PUSH
87174: LD_INT 22
87176: PUSH
87177: LD_VAR 0 2
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PPUSH
87186: CALL_OW 69
87190: PUSH
87191: FOR_IN
87192: IFFALSE 87242
// begin un := UnitShoot ( i ) ;
87194: LD_ADDR_VAR 0 5
87198: PUSH
87199: LD_VAR 0 4
87203: PPUSH
87204: CALL_OW 504
87208: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87209: LD_VAR 0 5
87213: PPUSH
87214: CALL_OW 255
87218: PUSH
87219: LD_VAR 0 1
87223: EQUAL
87224: IFFALSE 87240
// begin result := un ;
87226: LD_ADDR_VAR 0 3
87230: PUSH
87231: LD_VAR 0 5
87235: ST_TO_ADDR
// exit ;
87236: POP
87237: POP
87238: GO 87244
// end ; end ;
87240: GO 87191
87242: POP
87243: POP
// end ;
87244: LD_VAR 0 3
87248: RET
// export function GetCargoBay ( units ) ; begin
87249: LD_INT 0
87251: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87252: LD_ADDR_VAR 0 2
87256: PUSH
87257: LD_VAR 0 1
87261: PPUSH
87262: LD_INT 2
87264: PUSH
87265: LD_INT 34
87267: PUSH
87268: LD_INT 12
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 34
87277: PUSH
87278: LD_INT 51
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 34
87287: PUSH
87288: LD_INT 32
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PUSH
87295: LD_INT 34
87297: PUSH
87298: LD_EXP 95
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: PPUSH
87314: CALL_OW 72
87318: ST_TO_ADDR
// end ;
87319: LD_VAR 0 2
87323: RET
// export function Negate ( value ) ; begin
87324: LD_INT 0
87326: PPUSH
// result := not value ;
87327: LD_ADDR_VAR 0 2
87331: PUSH
87332: LD_VAR 0 1
87336: NOT
87337: ST_TO_ADDR
// end ;
87338: LD_VAR 0 2
87342: RET
// export function Inc ( value ) ; begin
87343: LD_INT 0
87345: PPUSH
// result := value + 1 ;
87346: LD_ADDR_VAR 0 2
87350: PUSH
87351: LD_VAR 0 1
87355: PUSH
87356: LD_INT 1
87358: PLUS
87359: ST_TO_ADDR
// end ;
87360: LD_VAR 0 2
87364: RET
// export function Dec ( value ) ; begin
87365: LD_INT 0
87367: PPUSH
// result := value - 1 ;
87368: LD_ADDR_VAR 0 2
87372: PUSH
87373: LD_VAR 0 1
87377: PUSH
87378: LD_INT 1
87380: MINUS
87381: ST_TO_ADDR
// end ;
87382: LD_VAR 0 2
87386: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87387: LD_INT 0
87389: PPUSH
87390: PPUSH
87391: PPUSH
87392: PPUSH
87393: PPUSH
87394: PPUSH
87395: PPUSH
87396: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87397: LD_VAR 0 1
87401: PPUSH
87402: LD_VAR 0 2
87406: PPUSH
87407: CALL_OW 488
87411: NOT
87412: PUSH
87413: LD_VAR 0 3
87417: PPUSH
87418: LD_VAR 0 4
87422: PPUSH
87423: CALL_OW 488
87427: NOT
87428: OR
87429: IFFALSE 87442
// begin result := - 1 ;
87431: LD_ADDR_VAR 0 5
87435: PUSH
87436: LD_INT 1
87438: NEG
87439: ST_TO_ADDR
// exit ;
87440: GO 87677
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87442: LD_ADDR_VAR 0 12
87446: PUSH
87447: LD_VAR 0 1
87451: PPUSH
87452: LD_VAR 0 2
87456: PPUSH
87457: LD_VAR 0 3
87461: PPUSH
87462: LD_VAR 0 4
87466: PPUSH
87467: CALL 86525 0 4
87471: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87472: LD_ADDR_VAR 0 11
87476: PUSH
87477: LD_VAR 0 1
87481: PPUSH
87482: LD_VAR 0 2
87486: PPUSH
87487: LD_VAR 0 12
87491: PUSH
87492: LD_INT 1
87494: ARRAY
87495: PPUSH
87496: LD_VAR 0 12
87500: PUSH
87501: LD_INT 2
87503: ARRAY
87504: PPUSH
87505: CALL_OW 298
87509: ST_TO_ADDR
// distance := 9999 ;
87510: LD_ADDR_VAR 0 10
87514: PUSH
87515: LD_INT 9999
87517: ST_TO_ADDR
// for i := 0 to 5 do
87518: LD_ADDR_VAR 0 6
87522: PUSH
87523: DOUBLE
87524: LD_INT 0
87526: DEC
87527: ST_TO_ADDR
87528: LD_INT 5
87530: PUSH
87531: FOR_TO
87532: IFFALSE 87675
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87534: LD_ADDR_VAR 0 7
87538: PUSH
87539: LD_VAR 0 1
87543: PPUSH
87544: LD_VAR 0 6
87548: PPUSH
87549: LD_VAR 0 11
87553: PPUSH
87554: CALL_OW 272
87558: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87559: LD_ADDR_VAR 0 8
87563: PUSH
87564: LD_VAR 0 2
87568: PPUSH
87569: LD_VAR 0 6
87573: PPUSH
87574: LD_VAR 0 11
87578: PPUSH
87579: CALL_OW 273
87583: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87584: LD_VAR 0 7
87588: PPUSH
87589: LD_VAR 0 8
87593: PPUSH
87594: CALL_OW 488
87598: NOT
87599: IFFALSE 87603
// continue ;
87601: GO 87531
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87603: LD_ADDR_VAR 0 9
87607: PUSH
87608: LD_VAR 0 12
87612: PUSH
87613: LD_INT 1
87615: ARRAY
87616: PPUSH
87617: LD_VAR 0 12
87621: PUSH
87622: LD_INT 2
87624: ARRAY
87625: PPUSH
87626: LD_VAR 0 7
87630: PPUSH
87631: LD_VAR 0 8
87635: PPUSH
87636: CALL_OW 298
87640: ST_TO_ADDR
// if tmp < distance then
87641: LD_VAR 0 9
87645: PUSH
87646: LD_VAR 0 10
87650: LESS
87651: IFFALSE 87673
// begin result := i ;
87653: LD_ADDR_VAR 0 5
87657: PUSH
87658: LD_VAR 0 6
87662: ST_TO_ADDR
// distance := tmp ;
87663: LD_ADDR_VAR 0 10
87667: PUSH
87668: LD_VAR 0 9
87672: ST_TO_ADDR
// end ; end ;
87673: GO 87531
87675: POP
87676: POP
// end ;
87677: LD_VAR 0 5
87681: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87682: LD_INT 0
87684: PPUSH
87685: PPUSH
// if not driver or not IsInUnit ( driver ) then
87686: LD_VAR 0 1
87690: NOT
87691: PUSH
87692: LD_VAR 0 1
87696: PPUSH
87697: CALL_OW 310
87701: NOT
87702: OR
87703: IFFALSE 87707
// exit ;
87705: GO 87797
// vehicle := IsInUnit ( driver ) ;
87707: LD_ADDR_VAR 0 3
87711: PUSH
87712: LD_VAR 0 1
87716: PPUSH
87717: CALL_OW 310
87721: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87722: LD_VAR 0 1
87726: PPUSH
87727: LD_STRING \
87729: PUSH
87730: LD_INT 0
87732: PUSH
87733: LD_INT 0
87735: PUSH
87736: LD_INT 0
87738: PUSH
87739: LD_INT 0
87741: PUSH
87742: LD_INT 0
87744: PUSH
87745: LD_INT 0
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: PUSH
87757: LD_STRING E
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: LD_INT 0
87765: PUSH
87766: LD_VAR 0 3
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: LD_INT 0
87776: PUSH
87777: LD_INT 0
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: PUSH
87789: EMPTY
87790: LIST
87791: LIST
87792: PPUSH
87793: CALL_OW 446
// end ;
87797: LD_VAR 0 2
87801: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87802: LD_INT 0
87804: PPUSH
87805: PPUSH
// if not driver or not IsInUnit ( driver ) then
87806: LD_VAR 0 1
87810: NOT
87811: PUSH
87812: LD_VAR 0 1
87816: PPUSH
87817: CALL_OW 310
87821: NOT
87822: OR
87823: IFFALSE 87827
// exit ;
87825: GO 87917
// vehicle := IsInUnit ( driver ) ;
87827: LD_ADDR_VAR 0 3
87831: PUSH
87832: LD_VAR 0 1
87836: PPUSH
87837: CALL_OW 310
87841: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87842: LD_VAR 0 1
87846: PPUSH
87847: LD_STRING \
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: LD_INT 0
87855: PUSH
87856: LD_INT 0
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: LD_INT 0
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: EMPTY
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: PUSH
87877: LD_STRING E
87879: PUSH
87880: LD_INT 0
87882: PUSH
87883: LD_INT 0
87885: PUSH
87886: LD_VAR 0 3
87890: PUSH
87891: LD_INT 0
87893: PUSH
87894: LD_INT 0
87896: PUSH
87897: LD_INT 0
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PPUSH
87913: CALL_OW 447
// end ;
87917: LD_VAR 0 2
87921: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
87922: LD_INT 0
87924: PPUSH
87925: PPUSH
87926: PPUSH
// tmp := [ ] ;
87927: LD_ADDR_VAR 0 5
87931: PUSH
87932: EMPTY
87933: ST_TO_ADDR
// for i in units do
87934: LD_ADDR_VAR 0 4
87938: PUSH
87939: LD_VAR 0 1
87943: PUSH
87944: FOR_IN
87945: IFFALSE 87983
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
87947: LD_ADDR_VAR 0 5
87951: PUSH
87952: LD_VAR 0 5
87956: PPUSH
87957: LD_VAR 0 5
87961: PUSH
87962: LD_INT 1
87964: PLUS
87965: PPUSH
87966: LD_VAR 0 4
87970: PPUSH
87971: CALL_OW 256
87975: PPUSH
87976: CALL_OW 2
87980: ST_TO_ADDR
87981: GO 87944
87983: POP
87984: POP
// if not tmp then
87985: LD_VAR 0 5
87989: NOT
87990: IFFALSE 87994
// exit ;
87992: GO 88042
// if asc then
87994: LD_VAR 0 2
87998: IFFALSE 88022
// result := SortListByListAsc ( units , tmp ) else
88000: LD_ADDR_VAR 0 3
88004: PUSH
88005: LD_VAR 0 1
88009: PPUSH
88010: LD_VAR 0 5
88014: PPUSH
88015: CALL_OW 76
88019: ST_TO_ADDR
88020: GO 88042
// result := SortListByListDesc ( units , tmp ) ;
88022: LD_ADDR_VAR 0 3
88026: PUSH
88027: LD_VAR 0 1
88031: PPUSH
88032: LD_VAR 0 5
88036: PPUSH
88037: CALL_OW 77
88041: ST_TO_ADDR
// end ;
88042: LD_VAR 0 3
88046: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88047: LD_INT 0
88049: PPUSH
88050: PPUSH
// task := GetTaskList ( mech ) ;
88051: LD_ADDR_VAR 0 4
88055: PUSH
88056: LD_VAR 0 1
88060: PPUSH
88061: CALL_OW 437
88065: ST_TO_ADDR
// if not task then
88066: LD_VAR 0 4
88070: NOT
88071: IFFALSE 88075
// exit ;
88073: GO 88117
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88075: LD_ADDR_VAR 0 3
88079: PUSH
88080: LD_VAR 0 4
88084: PUSH
88085: LD_INT 1
88087: ARRAY
88088: PUSH
88089: LD_INT 1
88091: ARRAY
88092: PUSH
88093: LD_STRING r
88095: EQUAL
88096: PUSH
88097: LD_VAR 0 4
88101: PUSH
88102: LD_INT 1
88104: ARRAY
88105: PUSH
88106: LD_INT 4
88108: ARRAY
88109: PUSH
88110: LD_VAR 0 2
88114: EQUAL
88115: AND
88116: ST_TO_ADDR
// end ;
88117: LD_VAR 0 3
88121: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88122: LD_INT 0
88124: PPUSH
// SetDir ( unit , d ) ;
88125: LD_VAR 0 1
88129: PPUSH
88130: LD_VAR 0 4
88134: PPUSH
88135: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88139: LD_VAR 0 1
88143: PPUSH
88144: LD_VAR 0 2
88148: PPUSH
88149: LD_VAR 0 3
88153: PPUSH
88154: LD_VAR 0 5
88158: PPUSH
88159: CALL_OW 48
// end ;
88163: LD_VAR 0 6
88167: RET
// export function ToNaturalNumber ( number ) ; begin
88168: LD_INT 0
88170: PPUSH
// result := number div 1 ;
88171: LD_ADDR_VAR 0 2
88175: PUSH
88176: LD_VAR 0 1
88180: PUSH
88181: LD_INT 1
88183: DIV
88184: ST_TO_ADDR
// if number < 0 then
88185: LD_VAR 0 1
88189: PUSH
88190: LD_INT 0
88192: LESS
88193: IFFALSE 88203
// result := 0 ;
88195: LD_ADDR_VAR 0 2
88199: PUSH
88200: LD_INT 0
88202: ST_TO_ADDR
// end ;
88203: LD_VAR 0 2
88207: RET
// export function SortByClass ( units , class ) ; var un ; begin
88208: LD_INT 0
88210: PPUSH
88211: PPUSH
// if not units or not class then
88212: LD_VAR 0 1
88216: NOT
88217: PUSH
88218: LD_VAR 0 2
88222: NOT
88223: OR
88224: IFFALSE 88228
// exit ;
88226: GO 88323
// result := [ ] ;
88228: LD_ADDR_VAR 0 3
88232: PUSH
88233: EMPTY
88234: ST_TO_ADDR
// for un in units do
88235: LD_ADDR_VAR 0 4
88239: PUSH
88240: LD_VAR 0 1
88244: PUSH
88245: FOR_IN
88246: IFFALSE 88321
// if GetClass ( un ) = class then
88248: LD_VAR 0 4
88252: PPUSH
88253: CALL_OW 257
88257: PUSH
88258: LD_VAR 0 2
88262: EQUAL
88263: IFFALSE 88290
// result := Insert ( result , 1 , un ) else
88265: LD_ADDR_VAR 0 3
88269: PUSH
88270: LD_VAR 0 3
88274: PPUSH
88275: LD_INT 1
88277: PPUSH
88278: LD_VAR 0 4
88282: PPUSH
88283: CALL_OW 2
88287: ST_TO_ADDR
88288: GO 88319
// result := Replace ( result , result + 1 , un ) ;
88290: LD_ADDR_VAR 0 3
88294: PUSH
88295: LD_VAR 0 3
88299: PPUSH
88300: LD_VAR 0 3
88304: PUSH
88305: LD_INT 1
88307: PLUS
88308: PPUSH
88309: LD_VAR 0 4
88313: PPUSH
88314: CALL_OW 1
88318: ST_TO_ADDR
88319: GO 88245
88321: POP
88322: POP
// end ;
88323: LD_VAR 0 3
88327: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88328: LD_INT 0
88330: PPUSH
88331: PPUSH
88332: PPUSH
88333: PPUSH
88334: PPUSH
88335: PPUSH
88336: PPUSH
// result := [ ] ;
88337: LD_ADDR_VAR 0 4
88341: PUSH
88342: EMPTY
88343: ST_TO_ADDR
// if x - r < 0 then
88344: LD_VAR 0 1
88348: PUSH
88349: LD_VAR 0 3
88353: MINUS
88354: PUSH
88355: LD_INT 0
88357: LESS
88358: IFFALSE 88370
// min_x := 0 else
88360: LD_ADDR_VAR 0 8
88364: PUSH
88365: LD_INT 0
88367: ST_TO_ADDR
88368: GO 88386
// min_x := x - r ;
88370: LD_ADDR_VAR 0 8
88374: PUSH
88375: LD_VAR 0 1
88379: PUSH
88380: LD_VAR 0 3
88384: MINUS
88385: ST_TO_ADDR
// if y - r < 0 then
88386: LD_VAR 0 2
88390: PUSH
88391: LD_VAR 0 3
88395: MINUS
88396: PUSH
88397: LD_INT 0
88399: LESS
88400: IFFALSE 88412
// min_y := 0 else
88402: LD_ADDR_VAR 0 7
88406: PUSH
88407: LD_INT 0
88409: ST_TO_ADDR
88410: GO 88428
// min_y := y - r ;
88412: LD_ADDR_VAR 0 7
88416: PUSH
88417: LD_VAR 0 2
88421: PUSH
88422: LD_VAR 0 3
88426: MINUS
88427: ST_TO_ADDR
// max_x := x + r ;
88428: LD_ADDR_VAR 0 9
88432: PUSH
88433: LD_VAR 0 1
88437: PUSH
88438: LD_VAR 0 3
88442: PLUS
88443: ST_TO_ADDR
// max_y := y + r ;
88444: LD_ADDR_VAR 0 10
88448: PUSH
88449: LD_VAR 0 2
88453: PUSH
88454: LD_VAR 0 3
88458: PLUS
88459: ST_TO_ADDR
// for _x = min_x to max_x do
88460: LD_ADDR_VAR 0 5
88464: PUSH
88465: DOUBLE
88466: LD_VAR 0 8
88470: DEC
88471: ST_TO_ADDR
88472: LD_VAR 0 9
88476: PUSH
88477: FOR_TO
88478: IFFALSE 88579
// for _y = min_y to max_y do
88480: LD_ADDR_VAR 0 6
88484: PUSH
88485: DOUBLE
88486: LD_VAR 0 7
88490: DEC
88491: ST_TO_ADDR
88492: LD_VAR 0 10
88496: PUSH
88497: FOR_TO
88498: IFFALSE 88575
// begin if not ValidHex ( _x , _y ) then
88500: LD_VAR 0 5
88504: PPUSH
88505: LD_VAR 0 6
88509: PPUSH
88510: CALL_OW 488
88514: NOT
88515: IFFALSE 88519
// continue ;
88517: GO 88497
// if GetResourceTypeXY ( _x , _y ) then
88519: LD_VAR 0 5
88523: PPUSH
88524: LD_VAR 0 6
88528: PPUSH
88529: CALL_OW 283
88533: IFFALSE 88573
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88535: LD_ADDR_VAR 0 4
88539: PUSH
88540: LD_VAR 0 4
88544: PPUSH
88545: LD_VAR 0 4
88549: PUSH
88550: LD_INT 1
88552: PLUS
88553: PPUSH
88554: LD_VAR 0 5
88558: PUSH
88559: LD_VAR 0 6
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PPUSH
88568: CALL_OW 1
88572: ST_TO_ADDR
// end ;
88573: GO 88497
88575: POP
88576: POP
88577: GO 88477
88579: POP
88580: POP
// end ;
88581: LD_VAR 0 4
88585: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88586: LD_INT 0
88588: PPUSH
88589: PPUSH
88590: PPUSH
88591: PPUSH
88592: PPUSH
88593: PPUSH
88594: PPUSH
88595: PPUSH
// if not units then
88596: LD_VAR 0 1
88600: NOT
88601: IFFALSE 88605
// exit ;
88603: GO 89131
// result := UnitFilter ( units , [ f_ok ] ) ;
88605: LD_ADDR_VAR 0 3
88609: PUSH
88610: LD_VAR 0 1
88614: PPUSH
88615: LD_INT 50
88617: PUSH
88618: EMPTY
88619: LIST
88620: PPUSH
88621: CALL_OW 72
88625: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
88626: LD_ADDR_VAR 0 8
88630: PUSH
88631: LD_VAR 0 1
88635: PUSH
88636: LD_INT 1
88638: ARRAY
88639: PPUSH
88640: CALL_OW 255
88644: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
88645: LD_ADDR_VAR 0 10
88649: PUSH
88650: LD_INT 29
88652: PUSH
88653: LD_EXP 98
88657: PUSH
88658: LD_INT 49
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: LIST
88665: ST_TO_ADDR
// if not result then
88666: LD_VAR 0 3
88670: NOT
88671: IFFALSE 88675
// exit ;
88673: GO 89131
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88675: LD_ADDR_VAR 0 5
88679: PUSH
88680: LD_INT 81
88682: PUSH
88683: LD_VAR 0 8
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PPUSH
88692: CALL_OW 69
88696: ST_TO_ADDR
// for i in result do
88697: LD_ADDR_VAR 0 4
88701: PUSH
88702: LD_VAR 0 3
88706: PUSH
88707: FOR_IN
88708: IFFALSE 89129
// begin tag := GetTag ( i ) + 1 ;
88710: LD_ADDR_VAR 0 9
88714: PUSH
88715: LD_VAR 0 4
88719: PPUSH
88720: CALL_OW 110
88724: PUSH
88725: LD_INT 1
88727: PLUS
88728: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88729: LD_ADDR_VAR 0 7
88733: PUSH
88734: LD_VAR 0 4
88738: PPUSH
88739: CALL_OW 250
88743: PPUSH
88744: LD_VAR 0 4
88748: PPUSH
88749: CALL_OW 251
88753: PPUSH
88754: LD_INT 6
88756: PPUSH
88757: CALL 88328 0 3
88761: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88762: LD_VAR 0 4
88766: PPUSH
88767: CALL_OW 247
88771: PUSH
88772: LD_INT 2
88774: EQUAL
88775: PUSH
88776: LD_VAR 0 7
88780: AND
88781: PUSH
88782: LD_VAR 0 4
88786: PPUSH
88787: CALL_OW 264
88791: PUSH
88792: LD_VAR 0 10
88796: IN
88797: NOT
88798: AND
88799: IFFALSE 88838
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88801: LD_VAR 0 4
88805: PPUSH
88806: LD_VAR 0 7
88810: PUSH
88811: LD_INT 1
88813: ARRAY
88814: PUSH
88815: LD_INT 1
88817: ARRAY
88818: PPUSH
88819: LD_VAR 0 7
88823: PUSH
88824: LD_INT 1
88826: ARRAY
88827: PUSH
88828: LD_INT 2
88830: ARRAY
88831: PPUSH
88832: CALL_OW 116
88836: GO 89127
// if path > tag then
88838: LD_VAR 0 2
88842: PUSH
88843: LD_VAR 0 9
88847: GREATER
88848: IFFALSE 89056
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
88850: LD_ADDR_VAR 0 6
88854: PUSH
88855: LD_VAR 0 5
88859: PPUSH
88860: LD_INT 91
88862: PUSH
88863: LD_VAR 0 4
88867: PUSH
88868: LD_INT 8
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: LIST
88875: PPUSH
88876: CALL_OW 72
88880: ST_TO_ADDR
// if nearEnemy then
88881: LD_VAR 0 6
88885: IFFALSE 88954
// begin if GetWeapon ( i ) = ru_time_lapser then
88887: LD_VAR 0 4
88891: PPUSH
88892: CALL_OW 264
88896: PUSH
88897: LD_INT 49
88899: EQUAL
88900: IFFALSE 88928
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
88902: LD_VAR 0 4
88906: PPUSH
88907: LD_VAR 0 6
88911: PPUSH
88912: LD_VAR 0 4
88916: PPUSH
88917: CALL_OW 74
88921: PPUSH
88922: CALL_OW 112
88926: GO 88952
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
88928: LD_VAR 0 4
88932: PPUSH
88933: LD_VAR 0 6
88937: PPUSH
88938: LD_VAR 0 4
88942: PPUSH
88943: CALL_OW 74
88947: PPUSH
88948: CALL_OW 115
// end else
88952: GO 89054
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
88954: LD_VAR 0 4
88958: PPUSH
88959: LD_VAR 0 2
88963: PUSH
88964: LD_VAR 0 9
88968: ARRAY
88969: PUSH
88970: LD_INT 1
88972: ARRAY
88973: PPUSH
88974: LD_VAR 0 2
88978: PUSH
88979: LD_VAR 0 9
88983: ARRAY
88984: PUSH
88985: LD_INT 2
88987: ARRAY
88988: PPUSH
88989: CALL_OW 297
88993: PUSH
88994: LD_INT 6
88996: GREATER
88997: IFFALSE 89040
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
88999: LD_VAR 0 4
89003: PPUSH
89004: LD_VAR 0 2
89008: PUSH
89009: LD_VAR 0 9
89013: ARRAY
89014: PUSH
89015: LD_INT 1
89017: ARRAY
89018: PPUSH
89019: LD_VAR 0 2
89023: PUSH
89024: LD_VAR 0 9
89028: ARRAY
89029: PUSH
89030: LD_INT 2
89032: ARRAY
89033: PPUSH
89034: CALL_OW 114
89038: GO 89054
// SetTag ( i , tag ) ;
89040: LD_VAR 0 4
89044: PPUSH
89045: LD_VAR 0 9
89049: PPUSH
89050: CALL_OW 109
// end else
89054: GO 89127
// if enemy then
89056: LD_VAR 0 5
89060: IFFALSE 89127
// begin if GetWeapon ( i ) = ru_time_lapser then
89062: LD_VAR 0 4
89066: PPUSH
89067: CALL_OW 264
89071: PUSH
89072: LD_INT 49
89074: EQUAL
89075: IFFALSE 89103
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89077: LD_VAR 0 4
89081: PPUSH
89082: LD_VAR 0 5
89086: PPUSH
89087: LD_VAR 0 4
89091: PPUSH
89092: CALL_OW 74
89096: PPUSH
89097: CALL_OW 112
89101: GO 89127
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89103: LD_VAR 0 4
89107: PPUSH
89108: LD_VAR 0 5
89112: PPUSH
89113: LD_VAR 0 4
89117: PPUSH
89118: CALL_OW 74
89122: PPUSH
89123: CALL_OW 115
// end ; end ;
89127: GO 88707
89129: POP
89130: POP
// end ;
89131: LD_VAR 0 3
89135: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89136: LD_INT 0
89138: PPUSH
89139: PPUSH
89140: PPUSH
// if not unit or IsInUnit ( unit ) then
89141: LD_VAR 0 1
89145: NOT
89146: PUSH
89147: LD_VAR 0 1
89151: PPUSH
89152: CALL_OW 310
89156: OR
89157: IFFALSE 89161
// exit ;
89159: GO 89252
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89161: LD_ADDR_VAR 0 4
89165: PUSH
89166: LD_VAR 0 1
89170: PPUSH
89171: CALL_OW 250
89175: PPUSH
89176: LD_VAR 0 2
89180: PPUSH
89181: LD_INT 1
89183: PPUSH
89184: CALL_OW 272
89188: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89189: LD_ADDR_VAR 0 5
89193: PUSH
89194: LD_VAR 0 1
89198: PPUSH
89199: CALL_OW 251
89203: PPUSH
89204: LD_VAR 0 2
89208: PPUSH
89209: LD_INT 1
89211: PPUSH
89212: CALL_OW 273
89216: ST_TO_ADDR
// if ValidHex ( x , y ) then
89217: LD_VAR 0 4
89221: PPUSH
89222: LD_VAR 0 5
89226: PPUSH
89227: CALL_OW 488
89231: IFFALSE 89252
// ComTurnXY ( unit , x , y ) ;
89233: LD_VAR 0 1
89237: PPUSH
89238: LD_VAR 0 4
89242: PPUSH
89243: LD_VAR 0 5
89247: PPUSH
89248: CALL_OW 118
// end ;
89252: LD_VAR 0 3
89256: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89257: LD_INT 0
89259: PPUSH
89260: PPUSH
// result := false ;
89261: LD_ADDR_VAR 0 3
89265: PUSH
89266: LD_INT 0
89268: ST_TO_ADDR
// if not units then
89269: LD_VAR 0 2
89273: NOT
89274: IFFALSE 89278
// exit ;
89276: GO 89323
// for i in units do
89278: LD_ADDR_VAR 0 4
89282: PUSH
89283: LD_VAR 0 2
89287: PUSH
89288: FOR_IN
89289: IFFALSE 89321
// if See ( side , i ) then
89291: LD_VAR 0 1
89295: PPUSH
89296: LD_VAR 0 4
89300: PPUSH
89301: CALL_OW 292
89305: IFFALSE 89319
// begin result := true ;
89307: LD_ADDR_VAR 0 3
89311: PUSH
89312: LD_INT 1
89314: ST_TO_ADDR
// exit ;
89315: POP
89316: POP
89317: GO 89323
// end ;
89319: GO 89288
89321: POP
89322: POP
// end ;
89323: LD_VAR 0 3
89327: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89328: LD_INT 0
89330: PPUSH
89331: PPUSH
89332: PPUSH
89333: PPUSH
// if not unit or not points then
89334: LD_VAR 0 1
89338: NOT
89339: PUSH
89340: LD_VAR 0 2
89344: NOT
89345: OR
89346: IFFALSE 89350
// exit ;
89348: GO 89440
// dist := 99999 ;
89350: LD_ADDR_VAR 0 5
89354: PUSH
89355: LD_INT 99999
89357: ST_TO_ADDR
// for i in points do
89358: LD_ADDR_VAR 0 4
89362: PUSH
89363: LD_VAR 0 2
89367: PUSH
89368: FOR_IN
89369: IFFALSE 89438
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89371: LD_ADDR_VAR 0 6
89375: PUSH
89376: LD_VAR 0 1
89380: PPUSH
89381: LD_VAR 0 4
89385: PUSH
89386: LD_INT 1
89388: ARRAY
89389: PPUSH
89390: LD_VAR 0 4
89394: PUSH
89395: LD_INT 2
89397: ARRAY
89398: PPUSH
89399: CALL_OW 297
89403: ST_TO_ADDR
// if tmpDist < dist then
89404: LD_VAR 0 6
89408: PUSH
89409: LD_VAR 0 5
89413: LESS
89414: IFFALSE 89436
// begin result := i ;
89416: LD_ADDR_VAR 0 3
89420: PUSH
89421: LD_VAR 0 4
89425: ST_TO_ADDR
// dist := tmpDist ;
89426: LD_ADDR_VAR 0 5
89430: PUSH
89431: LD_VAR 0 6
89435: ST_TO_ADDR
// end ; end ;
89436: GO 89368
89438: POP
89439: POP
// end ;
89440: LD_VAR 0 3
89444: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89445: LD_INT 0
89447: PPUSH
// uc_side := side ;
89448: LD_ADDR_OWVAR 20
89452: PUSH
89453: LD_VAR 0 1
89457: ST_TO_ADDR
// uc_nation := 3 ;
89458: LD_ADDR_OWVAR 21
89462: PUSH
89463: LD_INT 3
89465: ST_TO_ADDR
// vc_chassis := 25 ;
89466: LD_ADDR_OWVAR 37
89470: PUSH
89471: LD_INT 25
89473: ST_TO_ADDR
// vc_engine := engine_siberite ;
89474: LD_ADDR_OWVAR 39
89478: PUSH
89479: LD_INT 3
89481: ST_TO_ADDR
// vc_control := control_computer ;
89482: LD_ADDR_OWVAR 38
89486: PUSH
89487: LD_INT 3
89489: ST_TO_ADDR
// vc_weapon := 59 ;
89490: LD_ADDR_OWVAR 40
89494: PUSH
89495: LD_INT 59
89497: ST_TO_ADDR
// result := CreateVehicle ;
89498: LD_ADDR_VAR 0 5
89502: PUSH
89503: CALL_OW 45
89507: ST_TO_ADDR
// SetDir ( result , d ) ;
89508: LD_VAR 0 5
89512: PPUSH
89513: LD_VAR 0 4
89517: PPUSH
89518: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89522: LD_VAR 0 5
89526: PPUSH
89527: LD_VAR 0 2
89531: PPUSH
89532: LD_VAR 0 3
89536: PPUSH
89537: LD_INT 0
89539: PPUSH
89540: CALL_OW 48
// end ;
89544: LD_VAR 0 5
89548: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89549: LD_INT 0
89551: PPUSH
89552: PPUSH
89553: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89554: LD_ADDR_VAR 0 2
89558: PUSH
89559: LD_INT 0
89561: PUSH
89562: LD_INT 0
89564: PUSH
89565: LD_INT 0
89567: PUSH
89568: LD_INT 0
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89577: LD_VAR 0 1
89581: NOT
89582: PUSH
89583: LD_VAR 0 1
89587: PPUSH
89588: CALL_OW 264
89592: PUSH
89593: LD_INT 12
89595: PUSH
89596: LD_INT 51
89598: PUSH
89599: LD_INT 32
89601: PUSH
89602: LD_EXP 95
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: IN
89613: NOT
89614: OR
89615: IFFALSE 89619
// exit ;
89617: GO 89717
// for i := 1 to 3 do
89619: LD_ADDR_VAR 0 3
89623: PUSH
89624: DOUBLE
89625: LD_INT 1
89627: DEC
89628: ST_TO_ADDR
89629: LD_INT 3
89631: PUSH
89632: FOR_TO
89633: IFFALSE 89715
// begin tmp := GetCargo ( cargo , i ) ;
89635: LD_ADDR_VAR 0 4
89639: PUSH
89640: LD_VAR 0 1
89644: PPUSH
89645: LD_VAR 0 3
89649: PPUSH
89650: CALL_OW 289
89654: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
89655: LD_ADDR_VAR 0 2
89659: PUSH
89660: LD_VAR 0 2
89664: PPUSH
89665: LD_VAR 0 3
89669: PPUSH
89670: LD_VAR 0 4
89674: PPUSH
89675: CALL_OW 1
89679: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
89680: LD_ADDR_VAR 0 2
89684: PUSH
89685: LD_VAR 0 2
89689: PPUSH
89690: LD_INT 4
89692: PPUSH
89693: LD_VAR 0 2
89697: PUSH
89698: LD_INT 4
89700: ARRAY
89701: PUSH
89702: LD_VAR 0 4
89706: PLUS
89707: PPUSH
89708: CALL_OW 1
89712: ST_TO_ADDR
// end ;
89713: GO 89632
89715: POP
89716: POP
// end ;
89717: LD_VAR 0 2
89721: RET
// export function Length ( array ) ; begin
89722: LD_INT 0
89724: PPUSH
// result := array + 0 ;
89725: LD_ADDR_VAR 0 2
89729: PUSH
89730: LD_VAR 0 1
89734: PUSH
89735: LD_INT 0
89737: PLUS
89738: ST_TO_ADDR
// end ;
89739: LD_VAR 0 2
89743: RET
// export function PrepareArray ( array ) ; begin
89744: LD_INT 0
89746: PPUSH
// result := array diff 0 ;
89747: LD_ADDR_VAR 0 2
89751: PUSH
89752: LD_VAR 0 1
89756: PUSH
89757: LD_INT 0
89759: DIFF
89760: ST_TO_ADDR
// if not result [ 1 ] then
89761: LD_VAR 0 2
89765: PUSH
89766: LD_INT 1
89768: ARRAY
89769: NOT
89770: IFFALSE 89790
// result := Delete ( result , 1 ) ;
89772: LD_ADDR_VAR 0 2
89776: PUSH
89777: LD_VAR 0 2
89781: PPUSH
89782: LD_INT 1
89784: PPUSH
89785: CALL_OW 3
89789: ST_TO_ADDR
// end ; end_of_file
89790: LD_VAR 0 2
89794: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
89795: LD_INT 0
89797: PPUSH
// ar_miner := 81 ;
89798: LD_ADDR_EXP 101
89802: PUSH
89803: LD_INT 81
89805: ST_TO_ADDR
// ar_crane := 88 ;
89806: LD_ADDR_EXP 100
89810: PUSH
89811: LD_INT 88
89813: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
89814: LD_ADDR_EXP 95
89818: PUSH
89819: LD_INT 89
89821: ST_TO_ADDR
// us_hack := 99 ;
89822: LD_ADDR_EXP 96
89826: PUSH
89827: LD_INT 99
89829: ST_TO_ADDR
// us_artillery := 97 ;
89830: LD_ADDR_EXP 97
89834: PUSH
89835: LD_INT 97
89837: ST_TO_ADDR
// ar_bio_bomb := 91 ;
89838: LD_ADDR_EXP 98
89842: PUSH
89843: LD_INT 91
89845: ST_TO_ADDR
// ar_mortar := 92 ;
89846: LD_ADDR_EXP 99
89850: PUSH
89851: LD_INT 92
89853: ST_TO_ADDR
// ru_flamethrower := 93 ;
89854: LD_ADDR_EXP 102
89858: PUSH
89859: LD_INT 93
89861: ST_TO_ADDR
// ru_radar := 98 ;
89862: LD_ADDR_EXP 94
89866: PUSH
89867: LD_INT 98
89869: ST_TO_ADDR
// tech_Artillery := 80 ;
89870: LD_ADDR_EXP 103
89874: PUSH
89875: LD_INT 80
89877: ST_TO_ADDR
// tech_RadMat := 81 ;
89878: LD_ADDR_EXP 104
89882: PUSH
89883: LD_INT 81
89885: ST_TO_ADDR
// tech_BasicTools := 82 ;
89886: LD_ADDR_EXP 105
89890: PUSH
89891: LD_INT 82
89893: ST_TO_ADDR
// tech_Cargo := 83 ;
89894: LD_ADDR_EXP 106
89898: PUSH
89899: LD_INT 83
89901: ST_TO_ADDR
// tech_Track := 84 ;
89902: LD_ADDR_EXP 107
89906: PUSH
89907: LD_INT 84
89909: ST_TO_ADDR
// tech_Crane := 85 ;
89910: LD_ADDR_EXP 108
89914: PUSH
89915: LD_INT 85
89917: ST_TO_ADDR
// tech_Bulldozer := 86 ;
89918: LD_ADDR_EXP 109
89922: PUSH
89923: LD_INT 86
89925: ST_TO_ADDR
// tech_Hovercraft := 87 ;
89926: LD_ADDR_EXP 110
89930: PUSH
89931: LD_INT 87
89933: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
89934: LD_ADDR_EXP 111
89938: PUSH
89939: LD_INT 88
89941: ST_TO_ADDR
// end ;
89942: LD_VAR 0 1
89946: RET
// every 1 do
89947: GO 89949
89949: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
89950: CALL 89795 0 0
89954: END
// every 0 0$1 do
89955: GO 89957
89957: DISABLE
// begin enable ;
89958: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89959: LD_STRING updateTimer(
89961: PUSH
89962: LD_OWVAR 1
89966: STR
89967: PUSH
89968: LD_STRING );
89970: STR
89971: PPUSH
89972: CALL_OW 559
// end ;
89976: END
// export function SOS_MapStart ( ) ; begin
89977: LD_INT 0
89979: PPUSH
// if streamModeActive then
89980: LD_EXP 112
89984: IFFALSE 89993
// DefineStreamItems ( true ) ;
89986: LD_INT 1
89988: PPUSH
89989: CALL 91647 0 1
// UpdateFactoryWaypoints ( ) ;
89993: CALL 104508 0 0
// UpdateWarehouseGatheringPoints ( ) ;
89997: CALL 104765 0 0
// end ;
90001: LD_VAR 0 1
90005: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90006: LD_INT 0
90008: PPUSH
// if p2 = 100 then
90009: LD_VAR 0 2
90013: PUSH
90014: LD_INT 100
90016: EQUAL
90017: IFFALSE 91020
// begin if not StreamModeActive then
90019: LD_EXP 112
90023: NOT
90024: IFFALSE 90034
// StreamModeActive := true ;
90026: LD_ADDR_EXP 112
90030: PUSH
90031: LD_INT 1
90033: ST_TO_ADDR
// if p3 = 0 then
90034: LD_VAR 0 3
90038: PUSH
90039: LD_INT 0
90041: EQUAL
90042: IFFALSE 90048
// InitStreamMode ;
90044: CALL 91183 0 0
// if p3 = 1 then
90048: LD_VAR 0 3
90052: PUSH
90053: LD_INT 1
90055: EQUAL
90056: IFFALSE 90066
// sRocket := true ;
90058: LD_ADDR_EXP 117
90062: PUSH
90063: LD_INT 1
90065: ST_TO_ADDR
// if p3 = 2 then
90066: LD_VAR 0 3
90070: PUSH
90071: LD_INT 2
90073: EQUAL
90074: IFFALSE 90084
// sSpeed := true ;
90076: LD_ADDR_EXP 116
90080: PUSH
90081: LD_INT 1
90083: ST_TO_ADDR
// if p3 = 3 then
90084: LD_VAR 0 3
90088: PUSH
90089: LD_INT 3
90091: EQUAL
90092: IFFALSE 90102
// sEngine := true ;
90094: LD_ADDR_EXP 118
90098: PUSH
90099: LD_INT 1
90101: ST_TO_ADDR
// if p3 = 4 then
90102: LD_VAR 0 3
90106: PUSH
90107: LD_INT 4
90109: EQUAL
90110: IFFALSE 90120
// sSpec := true ;
90112: LD_ADDR_EXP 115
90116: PUSH
90117: LD_INT 1
90119: ST_TO_ADDR
// if p3 = 5 then
90120: LD_VAR 0 3
90124: PUSH
90125: LD_INT 5
90127: EQUAL
90128: IFFALSE 90138
// sLevel := true ;
90130: LD_ADDR_EXP 119
90134: PUSH
90135: LD_INT 1
90137: ST_TO_ADDR
// if p3 = 6 then
90138: LD_VAR 0 3
90142: PUSH
90143: LD_INT 6
90145: EQUAL
90146: IFFALSE 90156
// sArmoury := true ;
90148: LD_ADDR_EXP 120
90152: PUSH
90153: LD_INT 1
90155: ST_TO_ADDR
// if p3 = 7 then
90156: LD_VAR 0 3
90160: PUSH
90161: LD_INT 7
90163: EQUAL
90164: IFFALSE 90174
// sRadar := true ;
90166: LD_ADDR_EXP 121
90170: PUSH
90171: LD_INT 1
90173: ST_TO_ADDR
// if p3 = 8 then
90174: LD_VAR 0 3
90178: PUSH
90179: LD_INT 8
90181: EQUAL
90182: IFFALSE 90192
// sBunker := true ;
90184: LD_ADDR_EXP 122
90188: PUSH
90189: LD_INT 1
90191: ST_TO_ADDR
// if p3 = 9 then
90192: LD_VAR 0 3
90196: PUSH
90197: LD_INT 9
90199: EQUAL
90200: IFFALSE 90210
// sHack := true ;
90202: LD_ADDR_EXP 123
90206: PUSH
90207: LD_INT 1
90209: ST_TO_ADDR
// if p3 = 10 then
90210: LD_VAR 0 3
90214: PUSH
90215: LD_INT 10
90217: EQUAL
90218: IFFALSE 90228
// sFire := true ;
90220: LD_ADDR_EXP 124
90224: PUSH
90225: LD_INT 1
90227: ST_TO_ADDR
// if p3 = 11 then
90228: LD_VAR 0 3
90232: PUSH
90233: LD_INT 11
90235: EQUAL
90236: IFFALSE 90246
// sRefresh := true ;
90238: LD_ADDR_EXP 125
90242: PUSH
90243: LD_INT 1
90245: ST_TO_ADDR
// if p3 = 12 then
90246: LD_VAR 0 3
90250: PUSH
90251: LD_INT 12
90253: EQUAL
90254: IFFALSE 90264
// sExp := true ;
90256: LD_ADDR_EXP 126
90260: PUSH
90261: LD_INT 1
90263: ST_TO_ADDR
// if p3 = 13 then
90264: LD_VAR 0 3
90268: PUSH
90269: LD_INT 13
90271: EQUAL
90272: IFFALSE 90282
// sDepot := true ;
90274: LD_ADDR_EXP 127
90278: PUSH
90279: LD_INT 1
90281: ST_TO_ADDR
// if p3 = 14 then
90282: LD_VAR 0 3
90286: PUSH
90287: LD_INT 14
90289: EQUAL
90290: IFFALSE 90300
// sFlag := true ;
90292: LD_ADDR_EXP 128
90296: PUSH
90297: LD_INT 1
90299: ST_TO_ADDR
// if p3 = 15 then
90300: LD_VAR 0 3
90304: PUSH
90305: LD_INT 15
90307: EQUAL
90308: IFFALSE 90318
// sKamikadze := true ;
90310: LD_ADDR_EXP 136
90314: PUSH
90315: LD_INT 1
90317: ST_TO_ADDR
// if p3 = 16 then
90318: LD_VAR 0 3
90322: PUSH
90323: LD_INT 16
90325: EQUAL
90326: IFFALSE 90336
// sTroll := true ;
90328: LD_ADDR_EXP 137
90332: PUSH
90333: LD_INT 1
90335: ST_TO_ADDR
// if p3 = 17 then
90336: LD_VAR 0 3
90340: PUSH
90341: LD_INT 17
90343: EQUAL
90344: IFFALSE 90354
// sSlow := true ;
90346: LD_ADDR_EXP 138
90350: PUSH
90351: LD_INT 1
90353: ST_TO_ADDR
// if p3 = 18 then
90354: LD_VAR 0 3
90358: PUSH
90359: LD_INT 18
90361: EQUAL
90362: IFFALSE 90372
// sLack := true ;
90364: LD_ADDR_EXP 139
90368: PUSH
90369: LD_INT 1
90371: ST_TO_ADDR
// if p3 = 19 then
90372: LD_VAR 0 3
90376: PUSH
90377: LD_INT 19
90379: EQUAL
90380: IFFALSE 90390
// sTank := true ;
90382: LD_ADDR_EXP 141
90386: PUSH
90387: LD_INT 1
90389: ST_TO_ADDR
// if p3 = 20 then
90390: LD_VAR 0 3
90394: PUSH
90395: LD_INT 20
90397: EQUAL
90398: IFFALSE 90408
// sRemote := true ;
90400: LD_ADDR_EXP 142
90404: PUSH
90405: LD_INT 1
90407: ST_TO_ADDR
// if p3 = 21 then
90408: LD_VAR 0 3
90412: PUSH
90413: LD_INT 21
90415: EQUAL
90416: IFFALSE 90426
// sPowell := true ;
90418: LD_ADDR_EXP 143
90422: PUSH
90423: LD_INT 1
90425: ST_TO_ADDR
// if p3 = 22 then
90426: LD_VAR 0 3
90430: PUSH
90431: LD_INT 22
90433: EQUAL
90434: IFFALSE 90444
// sTeleport := true ;
90436: LD_ADDR_EXP 146
90440: PUSH
90441: LD_INT 1
90443: ST_TO_ADDR
// if p3 = 23 then
90444: LD_VAR 0 3
90448: PUSH
90449: LD_INT 23
90451: EQUAL
90452: IFFALSE 90462
// sOilTower := true ;
90454: LD_ADDR_EXP 148
90458: PUSH
90459: LD_INT 1
90461: ST_TO_ADDR
// if p3 = 24 then
90462: LD_VAR 0 3
90466: PUSH
90467: LD_INT 24
90469: EQUAL
90470: IFFALSE 90480
// sShovel := true ;
90472: LD_ADDR_EXP 149
90476: PUSH
90477: LD_INT 1
90479: ST_TO_ADDR
// if p3 = 25 then
90480: LD_VAR 0 3
90484: PUSH
90485: LD_INT 25
90487: EQUAL
90488: IFFALSE 90498
// sSheik := true ;
90490: LD_ADDR_EXP 150
90494: PUSH
90495: LD_INT 1
90497: ST_TO_ADDR
// if p3 = 26 then
90498: LD_VAR 0 3
90502: PUSH
90503: LD_INT 26
90505: EQUAL
90506: IFFALSE 90516
// sEarthquake := true ;
90508: LD_ADDR_EXP 152
90512: PUSH
90513: LD_INT 1
90515: ST_TO_ADDR
// if p3 = 27 then
90516: LD_VAR 0 3
90520: PUSH
90521: LD_INT 27
90523: EQUAL
90524: IFFALSE 90534
// sAI := true ;
90526: LD_ADDR_EXP 153
90530: PUSH
90531: LD_INT 1
90533: ST_TO_ADDR
// if p3 = 28 then
90534: LD_VAR 0 3
90538: PUSH
90539: LD_INT 28
90541: EQUAL
90542: IFFALSE 90552
// sCargo := true ;
90544: LD_ADDR_EXP 156
90548: PUSH
90549: LD_INT 1
90551: ST_TO_ADDR
// if p3 = 29 then
90552: LD_VAR 0 3
90556: PUSH
90557: LD_INT 29
90559: EQUAL
90560: IFFALSE 90570
// sDLaser := true ;
90562: LD_ADDR_EXP 157
90566: PUSH
90567: LD_INT 1
90569: ST_TO_ADDR
// if p3 = 30 then
90570: LD_VAR 0 3
90574: PUSH
90575: LD_INT 30
90577: EQUAL
90578: IFFALSE 90588
// sExchange := true ;
90580: LD_ADDR_EXP 158
90584: PUSH
90585: LD_INT 1
90587: ST_TO_ADDR
// if p3 = 31 then
90588: LD_VAR 0 3
90592: PUSH
90593: LD_INT 31
90595: EQUAL
90596: IFFALSE 90606
// sFac := true ;
90598: LD_ADDR_EXP 159
90602: PUSH
90603: LD_INT 1
90605: ST_TO_ADDR
// if p3 = 32 then
90606: LD_VAR 0 3
90610: PUSH
90611: LD_INT 32
90613: EQUAL
90614: IFFALSE 90624
// sPower := true ;
90616: LD_ADDR_EXP 160
90620: PUSH
90621: LD_INT 1
90623: ST_TO_ADDR
// if p3 = 33 then
90624: LD_VAR 0 3
90628: PUSH
90629: LD_INT 33
90631: EQUAL
90632: IFFALSE 90642
// sRandom := true ;
90634: LD_ADDR_EXP 161
90638: PUSH
90639: LD_INT 1
90641: ST_TO_ADDR
// if p3 = 34 then
90642: LD_VAR 0 3
90646: PUSH
90647: LD_INT 34
90649: EQUAL
90650: IFFALSE 90660
// sShield := true ;
90652: LD_ADDR_EXP 162
90656: PUSH
90657: LD_INT 1
90659: ST_TO_ADDR
// if p3 = 35 then
90660: LD_VAR 0 3
90664: PUSH
90665: LD_INT 35
90667: EQUAL
90668: IFFALSE 90678
// sTime := true ;
90670: LD_ADDR_EXP 163
90674: PUSH
90675: LD_INT 1
90677: ST_TO_ADDR
// if p3 = 36 then
90678: LD_VAR 0 3
90682: PUSH
90683: LD_INT 36
90685: EQUAL
90686: IFFALSE 90696
// sTools := true ;
90688: LD_ADDR_EXP 164
90692: PUSH
90693: LD_INT 1
90695: ST_TO_ADDR
// if p3 = 101 then
90696: LD_VAR 0 3
90700: PUSH
90701: LD_INT 101
90703: EQUAL
90704: IFFALSE 90714
// sSold := true ;
90706: LD_ADDR_EXP 129
90710: PUSH
90711: LD_INT 1
90713: ST_TO_ADDR
// if p3 = 102 then
90714: LD_VAR 0 3
90718: PUSH
90719: LD_INT 102
90721: EQUAL
90722: IFFALSE 90732
// sDiff := true ;
90724: LD_ADDR_EXP 130
90728: PUSH
90729: LD_INT 1
90731: ST_TO_ADDR
// if p3 = 103 then
90732: LD_VAR 0 3
90736: PUSH
90737: LD_INT 103
90739: EQUAL
90740: IFFALSE 90750
// sFog := true ;
90742: LD_ADDR_EXP 133
90746: PUSH
90747: LD_INT 1
90749: ST_TO_ADDR
// if p3 = 104 then
90750: LD_VAR 0 3
90754: PUSH
90755: LD_INT 104
90757: EQUAL
90758: IFFALSE 90768
// sReset := true ;
90760: LD_ADDR_EXP 134
90764: PUSH
90765: LD_INT 1
90767: ST_TO_ADDR
// if p3 = 105 then
90768: LD_VAR 0 3
90772: PUSH
90773: LD_INT 105
90775: EQUAL
90776: IFFALSE 90786
// sSun := true ;
90778: LD_ADDR_EXP 135
90782: PUSH
90783: LD_INT 1
90785: ST_TO_ADDR
// if p3 = 106 then
90786: LD_VAR 0 3
90790: PUSH
90791: LD_INT 106
90793: EQUAL
90794: IFFALSE 90804
// sTiger := true ;
90796: LD_ADDR_EXP 131
90800: PUSH
90801: LD_INT 1
90803: ST_TO_ADDR
// if p3 = 107 then
90804: LD_VAR 0 3
90808: PUSH
90809: LD_INT 107
90811: EQUAL
90812: IFFALSE 90822
// sBomb := true ;
90814: LD_ADDR_EXP 132
90818: PUSH
90819: LD_INT 1
90821: ST_TO_ADDR
// if p3 = 108 then
90822: LD_VAR 0 3
90826: PUSH
90827: LD_INT 108
90829: EQUAL
90830: IFFALSE 90840
// sWound := true ;
90832: LD_ADDR_EXP 140
90836: PUSH
90837: LD_INT 1
90839: ST_TO_ADDR
// if p3 = 109 then
90840: LD_VAR 0 3
90844: PUSH
90845: LD_INT 109
90847: EQUAL
90848: IFFALSE 90858
// sBetray := true ;
90850: LD_ADDR_EXP 144
90854: PUSH
90855: LD_INT 1
90857: ST_TO_ADDR
// if p3 = 110 then
90858: LD_VAR 0 3
90862: PUSH
90863: LD_INT 110
90865: EQUAL
90866: IFFALSE 90876
// sContamin := true ;
90868: LD_ADDR_EXP 145
90872: PUSH
90873: LD_INT 1
90875: ST_TO_ADDR
// if p3 = 111 then
90876: LD_VAR 0 3
90880: PUSH
90881: LD_INT 111
90883: EQUAL
90884: IFFALSE 90894
// sOil := true ;
90886: LD_ADDR_EXP 147
90890: PUSH
90891: LD_INT 1
90893: ST_TO_ADDR
// if p3 = 112 then
90894: LD_VAR 0 3
90898: PUSH
90899: LD_INT 112
90901: EQUAL
90902: IFFALSE 90912
// sStu := true ;
90904: LD_ADDR_EXP 151
90908: PUSH
90909: LD_INT 1
90911: ST_TO_ADDR
// if p3 = 113 then
90912: LD_VAR 0 3
90916: PUSH
90917: LD_INT 113
90919: EQUAL
90920: IFFALSE 90930
// sBazooka := true ;
90922: LD_ADDR_EXP 154
90926: PUSH
90927: LD_INT 1
90929: ST_TO_ADDR
// if p3 = 114 then
90930: LD_VAR 0 3
90934: PUSH
90935: LD_INT 114
90937: EQUAL
90938: IFFALSE 90948
// sMortar := true ;
90940: LD_ADDR_EXP 155
90944: PUSH
90945: LD_INT 1
90947: ST_TO_ADDR
// if p3 = 115 then
90948: LD_VAR 0 3
90952: PUSH
90953: LD_INT 115
90955: EQUAL
90956: IFFALSE 90966
// sRanger := true ;
90958: LD_ADDR_EXP 165
90962: PUSH
90963: LD_INT 1
90965: ST_TO_ADDR
// if p3 = 116 then
90966: LD_VAR 0 3
90970: PUSH
90971: LD_INT 116
90973: EQUAL
90974: IFFALSE 90984
// sComputer := true ;
90976: LD_ADDR_EXP 166
90980: PUSH
90981: LD_INT 1
90983: ST_TO_ADDR
// if p3 = 117 then
90984: LD_VAR 0 3
90988: PUSH
90989: LD_INT 117
90991: EQUAL
90992: IFFALSE 91002
// s30 := true ;
90994: LD_ADDR_EXP 167
90998: PUSH
90999: LD_INT 1
91001: ST_TO_ADDR
// if p3 = 118 then
91002: LD_VAR 0 3
91006: PUSH
91007: LD_INT 118
91009: EQUAL
91010: IFFALSE 91020
// s60 := true ;
91012: LD_ADDR_EXP 168
91016: PUSH
91017: LD_INT 1
91019: ST_TO_ADDR
// end ; if p2 = 101 then
91020: LD_VAR 0 2
91024: PUSH
91025: LD_INT 101
91027: EQUAL
91028: IFFALSE 91156
// begin case p3 of 1 :
91030: LD_VAR 0 3
91034: PUSH
91035: LD_INT 1
91037: DOUBLE
91038: EQUAL
91039: IFTRUE 91043
91041: GO 91050
91043: POP
// hHackUnlimitedResources ; 2 :
91044: CALL 103254 0 0
91048: GO 91156
91050: LD_INT 2
91052: DOUBLE
91053: EQUAL
91054: IFTRUE 91058
91056: GO 91065
91058: POP
// hHackSetLevel10 ; 3 :
91059: CALL 103387 0 0
91063: GO 91156
91065: LD_INT 3
91067: DOUBLE
91068: EQUAL
91069: IFTRUE 91073
91071: GO 91080
91073: POP
// hHackSetLevel10YourUnits ; 4 :
91074: CALL 103472 0 0
91078: GO 91156
91080: LD_INT 4
91082: DOUBLE
91083: EQUAL
91084: IFTRUE 91088
91086: GO 91095
91088: POP
// hHackInvincible ; 5 :
91089: CALL 103920 0 0
91093: GO 91156
91095: LD_INT 5
91097: DOUBLE
91098: EQUAL
91099: IFTRUE 91103
91101: GO 91110
91103: POP
// hHackInvisible ; 6 :
91104: CALL 104031 0 0
91108: GO 91156
91110: LD_INT 6
91112: DOUBLE
91113: EQUAL
91114: IFTRUE 91118
91116: GO 91125
91118: POP
// hHackChangeYourSide ; 7 :
91119: CALL 104088 0 0
91123: GO 91156
91125: LD_INT 7
91127: DOUBLE
91128: EQUAL
91129: IFTRUE 91133
91131: GO 91140
91133: POP
// hHackChangeUnitSide ; 8 :
91134: CALL 104130 0 0
91138: GO 91156
91140: LD_INT 8
91142: DOUBLE
91143: EQUAL
91144: IFTRUE 91148
91146: GO 91155
91148: POP
// hHackFog ; end ;
91149: CALL 104231 0 0
91153: GO 91156
91155: POP
// end ; end ;
91156: LD_VAR 0 7
91160: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
91161: GO 91163
91163: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91164: LD_STRING initStreamRollete();
91166: PPUSH
91167: CALL_OW 559
// InitStreamMode ;
91171: CALL 91183 0 0
// DefineStreamItems ( false ) ;
91175: LD_INT 0
91177: PPUSH
91178: CALL 91647 0 1
// end ;
91182: END
// function InitStreamMode ; begin
91183: LD_INT 0
91185: PPUSH
// streamModeActive := false ;
91186: LD_ADDR_EXP 112
91190: PUSH
91191: LD_INT 0
91193: ST_TO_ADDR
// normalCounter := 36 ;
91194: LD_ADDR_EXP 113
91198: PUSH
91199: LD_INT 36
91201: ST_TO_ADDR
// hardcoreCounter := 18 ;
91202: LD_ADDR_EXP 114
91206: PUSH
91207: LD_INT 18
91209: ST_TO_ADDR
// sRocket := false ;
91210: LD_ADDR_EXP 117
91214: PUSH
91215: LD_INT 0
91217: ST_TO_ADDR
// sSpeed := false ;
91218: LD_ADDR_EXP 116
91222: PUSH
91223: LD_INT 0
91225: ST_TO_ADDR
// sEngine := false ;
91226: LD_ADDR_EXP 118
91230: PUSH
91231: LD_INT 0
91233: ST_TO_ADDR
// sSpec := false ;
91234: LD_ADDR_EXP 115
91238: PUSH
91239: LD_INT 0
91241: ST_TO_ADDR
// sLevel := false ;
91242: LD_ADDR_EXP 119
91246: PUSH
91247: LD_INT 0
91249: ST_TO_ADDR
// sArmoury := false ;
91250: LD_ADDR_EXP 120
91254: PUSH
91255: LD_INT 0
91257: ST_TO_ADDR
// sRadar := false ;
91258: LD_ADDR_EXP 121
91262: PUSH
91263: LD_INT 0
91265: ST_TO_ADDR
// sBunker := false ;
91266: LD_ADDR_EXP 122
91270: PUSH
91271: LD_INT 0
91273: ST_TO_ADDR
// sHack := false ;
91274: LD_ADDR_EXP 123
91278: PUSH
91279: LD_INT 0
91281: ST_TO_ADDR
// sFire := false ;
91282: LD_ADDR_EXP 124
91286: PUSH
91287: LD_INT 0
91289: ST_TO_ADDR
// sRefresh := false ;
91290: LD_ADDR_EXP 125
91294: PUSH
91295: LD_INT 0
91297: ST_TO_ADDR
// sExp := false ;
91298: LD_ADDR_EXP 126
91302: PUSH
91303: LD_INT 0
91305: ST_TO_ADDR
// sDepot := false ;
91306: LD_ADDR_EXP 127
91310: PUSH
91311: LD_INT 0
91313: ST_TO_ADDR
// sFlag := false ;
91314: LD_ADDR_EXP 128
91318: PUSH
91319: LD_INT 0
91321: ST_TO_ADDR
// sKamikadze := false ;
91322: LD_ADDR_EXP 136
91326: PUSH
91327: LD_INT 0
91329: ST_TO_ADDR
// sTroll := false ;
91330: LD_ADDR_EXP 137
91334: PUSH
91335: LD_INT 0
91337: ST_TO_ADDR
// sSlow := false ;
91338: LD_ADDR_EXP 138
91342: PUSH
91343: LD_INT 0
91345: ST_TO_ADDR
// sLack := false ;
91346: LD_ADDR_EXP 139
91350: PUSH
91351: LD_INT 0
91353: ST_TO_ADDR
// sTank := false ;
91354: LD_ADDR_EXP 141
91358: PUSH
91359: LD_INT 0
91361: ST_TO_ADDR
// sRemote := false ;
91362: LD_ADDR_EXP 142
91366: PUSH
91367: LD_INT 0
91369: ST_TO_ADDR
// sPowell := false ;
91370: LD_ADDR_EXP 143
91374: PUSH
91375: LD_INT 0
91377: ST_TO_ADDR
// sTeleport := false ;
91378: LD_ADDR_EXP 146
91382: PUSH
91383: LD_INT 0
91385: ST_TO_ADDR
// sOilTower := false ;
91386: LD_ADDR_EXP 148
91390: PUSH
91391: LD_INT 0
91393: ST_TO_ADDR
// sShovel := false ;
91394: LD_ADDR_EXP 149
91398: PUSH
91399: LD_INT 0
91401: ST_TO_ADDR
// sSheik := false ;
91402: LD_ADDR_EXP 150
91406: PUSH
91407: LD_INT 0
91409: ST_TO_ADDR
// sEarthquake := false ;
91410: LD_ADDR_EXP 152
91414: PUSH
91415: LD_INT 0
91417: ST_TO_ADDR
// sAI := false ;
91418: LD_ADDR_EXP 153
91422: PUSH
91423: LD_INT 0
91425: ST_TO_ADDR
// sCargo := false ;
91426: LD_ADDR_EXP 156
91430: PUSH
91431: LD_INT 0
91433: ST_TO_ADDR
// sDLaser := false ;
91434: LD_ADDR_EXP 157
91438: PUSH
91439: LD_INT 0
91441: ST_TO_ADDR
// sExchange := false ;
91442: LD_ADDR_EXP 158
91446: PUSH
91447: LD_INT 0
91449: ST_TO_ADDR
// sFac := false ;
91450: LD_ADDR_EXP 159
91454: PUSH
91455: LD_INT 0
91457: ST_TO_ADDR
// sPower := false ;
91458: LD_ADDR_EXP 160
91462: PUSH
91463: LD_INT 0
91465: ST_TO_ADDR
// sRandom := false ;
91466: LD_ADDR_EXP 161
91470: PUSH
91471: LD_INT 0
91473: ST_TO_ADDR
// sShield := false ;
91474: LD_ADDR_EXP 162
91478: PUSH
91479: LD_INT 0
91481: ST_TO_ADDR
// sTime := false ;
91482: LD_ADDR_EXP 163
91486: PUSH
91487: LD_INT 0
91489: ST_TO_ADDR
// sTools := false ;
91490: LD_ADDR_EXP 164
91494: PUSH
91495: LD_INT 0
91497: ST_TO_ADDR
// sSold := false ;
91498: LD_ADDR_EXP 129
91502: PUSH
91503: LD_INT 0
91505: ST_TO_ADDR
// sDiff := false ;
91506: LD_ADDR_EXP 130
91510: PUSH
91511: LD_INT 0
91513: ST_TO_ADDR
// sFog := false ;
91514: LD_ADDR_EXP 133
91518: PUSH
91519: LD_INT 0
91521: ST_TO_ADDR
// sReset := false ;
91522: LD_ADDR_EXP 134
91526: PUSH
91527: LD_INT 0
91529: ST_TO_ADDR
// sSun := false ;
91530: LD_ADDR_EXP 135
91534: PUSH
91535: LD_INT 0
91537: ST_TO_ADDR
// sTiger := false ;
91538: LD_ADDR_EXP 131
91542: PUSH
91543: LD_INT 0
91545: ST_TO_ADDR
// sBomb := false ;
91546: LD_ADDR_EXP 132
91550: PUSH
91551: LD_INT 0
91553: ST_TO_ADDR
// sWound := false ;
91554: LD_ADDR_EXP 140
91558: PUSH
91559: LD_INT 0
91561: ST_TO_ADDR
// sBetray := false ;
91562: LD_ADDR_EXP 144
91566: PUSH
91567: LD_INT 0
91569: ST_TO_ADDR
// sContamin := false ;
91570: LD_ADDR_EXP 145
91574: PUSH
91575: LD_INT 0
91577: ST_TO_ADDR
// sOil := false ;
91578: LD_ADDR_EXP 147
91582: PUSH
91583: LD_INT 0
91585: ST_TO_ADDR
// sStu := false ;
91586: LD_ADDR_EXP 151
91590: PUSH
91591: LD_INT 0
91593: ST_TO_ADDR
// sBazooka := false ;
91594: LD_ADDR_EXP 154
91598: PUSH
91599: LD_INT 0
91601: ST_TO_ADDR
// sMortar := false ;
91602: LD_ADDR_EXP 155
91606: PUSH
91607: LD_INT 0
91609: ST_TO_ADDR
// sRanger := false ;
91610: LD_ADDR_EXP 165
91614: PUSH
91615: LD_INT 0
91617: ST_TO_ADDR
// sComputer := false ;
91618: LD_ADDR_EXP 166
91622: PUSH
91623: LD_INT 0
91625: ST_TO_ADDR
// s30 := false ;
91626: LD_ADDR_EXP 167
91630: PUSH
91631: LD_INT 0
91633: ST_TO_ADDR
// s60 := false ;
91634: LD_ADDR_EXP 168
91638: PUSH
91639: LD_INT 0
91641: ST_TO_ADDR
// end ;
91642: LD_VAR 0 1
91646: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91647: LD_INT 0
91649: PPUSH
91650: PPUSH
91651: PPUSH
91652: PPUSH
91653: PPUSH
91654: PPUSH
91655: PPUSH
// result := [ ] ;
91656: LD_ADDR_VAR 0 2
91660: PUSH
91661: EMPTY
91662: ST_TO_ADDR
// if campaign_id = 1 then
91663: LD_OWVAR 69
91667: PUSH
91668: LD_INT 1
91670: EQUAL
91671: IFFALSE 94837
// begin case mission_number of 1 :
91673: LD_OWVAR 70
91677: PUSH
91678: LD_INT 1
91680: DOUBLE
91681: EQUAL
91682: IFTRUE 91686
91684: GO 91762
91686: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91687: LD_ADDR_VAR 0 2
91691: PUSH
91692: LD_INT 2
91694: PUSH
91695: LD_INT 4
91697: PUSH
91698: LD_INT 11
91700: PUSH
91701: LD_INT 12
91703: PUSH
91704: LD_INT 15
91706: PUSH
91707: LD_INT 16
91709: PUSH
91710: LD_INT 22
91712: PUSH
91713: LD_INT 23
91715: PUSH
91716: LD_INT 26
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: PUSH
91730: LD_INT 101
91732: PUSH
91733: LD_INT 102
91735: PUSH
91736: LD_INT 106
91738: PUSH
91739: LD_INT 116
91741: PUSH
91742: LD_INT 117
91744: PUSH
91745: LD_INT 118
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: ST_TO_ADDR
91760: GO 94835
91762: LD_INT 2
91764: DOUBLE
91765: EQUAL
91766: IFTRUE 91770
91768: GO 91854
91770: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91771: LD_ADDR_VAR 0 2
91775: PUSH
91776: LD_INT 2
91778: PUSH
91779: LD_INT 4
91781: PUSH
91782: LD_INT 11
91784: PUSH
91785: LD_INT 12
91787: PUSH
91788: LD_INT 15
91790: PUSH
91791: LD_INT 16
91793: PUSH
91794: LD_INT 22
91796: PUSH
91797: LD_INT 23
91799: PUSH
91800: LD_INT 26
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: PUSH
91814: LD_INT 101
91816: PUSH
91817: LD_INT 102
91819: PUSH
91820: LD_INT 105
91822: PUSH
91823: LD_INT 106
91825: PUSH
91826: LD_INT 108
91828: PUSH
91829: LD_INT 116
91831: PUSH
91832: LD_INT 117
91834: PUSH
91835: LD_INT 118
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: ST_TO_ADDR
91852: GO 94835
91854: LD_INT 3
91856: DOUBLE
91857: EQUAL
91858: IFTRUE 91862
91860: GO 91950
91862: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91863: LD_ADDR_VAR 0 2
91867: PUSH
91868: LD_INT 2
91870: PUSH
91871: LD_INT 4
91873: PUSH
91874: LD_INT 5
91876: PUSH
91877: LD_INT 11
91879: PUSH
91880: LD_INT 12
91882: PUSH
91883: LD_INT 15
91885: PUSH
91886: LD_INT 16
91888: PUSH
91889: LD_INT 22
91891: PUSH
91892: LD_INT 26
91894: PUSH
91895: LD_INT 36
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 101
91912: PUSH
91913: LD_INT 102
91915: PUSH
91916: LD_INT 105
91918: PUSH
91919: LD_INT 106
91921: PUSH
91922: LD_INT 108
91924: PUSH
91925: LD_INT 116
91927: PUSH
91928: LD_INT 117
91930: PUSH
91931: LD_INT 118
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: PUSH
91944: EMPTY
91945: LIST
91946: LIST
91947: ST_TO_ADDR
91948: GO 94835
91950: LD_INT 4
91952: DOUBLE
91953: EQUAL
91954: IFTRUE 91958
91956: GO 92054
91958: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
91959: LD_ADDR_VAR 0 2
91963: PUSH
91964: LD_INT 2
91966: PUSH
91967: LD_INT 4
91969: PUSH
91970: LD_INT 5
91972: PUSH
91973: LD_INT 8
91975: PUSH
91976: LD_INT 11
91978: PUSH
91979: LD_INT 12
91981: PUSH
91982: LD_INT 15
91984: PUSH
91985: LD_INT 16
91987: PUSH
91988: LD_INT 22
91990: PUSH
91991: LD_INT 23
91993: PUSH
91994: LD_INT 26
91996: PUSH
91997: LD_INT 36
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 101
92016: PUSH
92017: LD_INT 102
92019: PUSH
92020: LD_INT 105
92022: PUSH
92023: LD_INT 106
92025: PUSH
92026: LD_INT 108
92028: PUSH
92029: LD_INT 116
92031: PUSH
92032: LD_INT 117
92034: PUSH
92035: LD_INT 118
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: ST_TO_ADDR
92052: GO 94835
92054: LD_INT 5
92056: DOUBLE
92057: EQUAL
92058: IFTRUE 92062
92060: GO 92174
92062: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92063: LD_ADDR_VAR 0 2
92067: PUSH
92068: LD_INT 2
92070: PUSH
92071: LD_INT 4
92073: PUSH
92074: LD_INT 5
92076: PUSH
92077: LD_INT 6
92079: PUSH
92080: LD_INT 8
92082: PUSH
92083: LD_INT 11
92085: PUSH
92086: LD_INT 12
92088: PUSH
92089: LD_INT 15
92091: PUSH
92092: LD_INT 16
92094: PUSH
92095: LD_INT 22
92097: PUSH
92098: LD_INT 23
92100: PUSH
92101: LD_INT 25
92103: PUSH
92104: LD_INT 26
92106: PUSH
92107: LD_INT 36
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: LIST
92114: LIST
92115: LIST
92116: LIST
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: PUSH
92126: LD_INT 101
92128: PUSH
92129: LD_INT 102
92131: PUSH
92132: LD_INT 105
92134: PUSH
92135: LD_INT 106
92137: PUSH
92138: LD_INT 108
92140: PUSH
92141: LD_INT 109
92143: PUSH
92144: LD_INT 112
92146: PUSH
92147: LD_INT 116
92149: PUSH
92150: LD_INT 117
92152: PUSH
92153: LD_INT 118
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: ST_TO_ADDR
92172: GO 94835
92174: LD_INT 6
92176: DOUBLE
92177: EQUAL
92178: IFTRUE 92182
92180: GO 92314
92182: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92183: LD_ADDR_VAR 0 2
92187: PUSH
92188: LD_INT 2
92190: PUSH
92191: LD_INT 4
92193: PUSH
92194: LD_INT 5
92196: PUSH
92197: LD_INT 6
92199: PUSH
92200: LD_INT 8
92202: PUSH
92203: LD_INT 11
92205: PUSH
92206: LD_INT 12
92208: PUSH
92209: LD_INT 15
92211: PUSH
92212: LD_INT 16
92214: PUSH
92215: LD_INT 20
92217: PUSH
92218: LD_INT 21
92220: PUSH
92221: LD_INT 22
92223: PUSH
92224: LD_INT 23
92226: PUSH
92227: LD_INT 25
92229: PUSH
92230: LD_INT 26
92232: PUSH
92233: LD_INT 30
92235: PUSH
92236: LD_INT 31
92238: PUSH
92239: LD_INT 32
92241: PUSH
92242: LD_INT 36
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 101
92268: PUSH
92269: LD_INT 102
92271: PUSH
92272: LD_INT 105
92274: PUSH
92275: LD_INT 106
92277: PUSH
92278: LD_INT 108
92280: PUSH
92281: LD_INT 109
92283: PUSH
92284: LD_INT 112
92286: PUSH
92287: LD_INT 116
92289: PUSH
92290: LD_INT 117
92292: PUSH
92293: LD_INT 118
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: ST_TO_ADDR
92312: GO 94835
92314: LD_INT 7
92316: DOUBLE
92317: EQUAL
92318: IFTRUE 92322
92320: GO 92434
92322: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92323: LD_ADDR_VAR 0 2
92327: PUSH
92328: LD_INT 2
92330: PUSH
92331: LD_INT 4
92333: PUSH
92334: LD_INT 5
92336: PUSH
92337: LD_INT 7
92339: PUSH
92340: LD_INT 11
92342: PUSH
92343: LD_INT 12
92345: PUSH
92346: LD_INT 15
92348: PUSH
92349: LD_INT 16
92351: PUSH
92352: LD_INT 20
92354: PUSH
92355: LD_INT 21
92357: PUSH
92358: LD_INT 22
92360: PUSH
92361: LD_INT 23
92363: PUSH
92364: LD_INT 25
92366: PUSH
92367: LD_INT 26
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 101
92388: PUSH
92389: LD_INT 102
92391: PUSH
92392: LD_INT 103
92394: PUSH
92395: LD_INT 105
92397: PUSH
92398: LD_INT 106
92400: PUSH
92401: LD_INT 108
92403: PUSH
92404: LD_INT 112
92406: PUSH
92407: LD_INT 116
92409: PUSH
92410: LD_INT 117
92412: PUSH
92413: LD_INT 118
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: ST_TO_ADDR
92432: GO 94835
92434: LD_INT 8
92436: DOUBLE
92437: EQUAL
92438: IFTRUE 92442
92440: GO 92582
92442: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92443: LD_ADDR_VAR 0 2
92447: PUSH
92448: LD_INT 2
92450: PUSH
92451: LD_INT 4
92453: PUSH
92454: LD_INT 5
92456: PUSH
92457: LD_INT 6
92459: PUSH
92460: LD_INT 7
92462: PUSH
92463: LD_INT 8
92465: PUSH
92466: LD_INT 11
92468: PUSH
92469: LD_INT 12
92471: PUSH
92472: LD_INT 15
92474: PUSH
92475: LD_INT 16
92477: PUSH
92478: LD_INT 20
92480: PUSH
92481: LD_INT 21
92483: PUSH
92484: LD_INT 22
92486: PUSH
92487: LD_INT 23
92489: PUSH
92490: LD_INT 25
92492: PUSH
92493: LD_INT 26
92495: PUSH
92496: LD_INT 30
92498: PUSH
92499: LD_INT 31
92501: PUSH
92502: LD_INT 32
92504: PUSH
92505: LD_INT 36
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 101
92532: PUSH
92533: LD_INT 102
92535: PUSH
92536: LD_INT 103
92538: PUSH
92539: LD_INT 105
92541: PUSH
92542: LD_INT 106
92544: PUSH
92545: LD_INT 108
92547: PUSH
92548: LD_INT 109
92550: PUSH
92551: LD_INT 112
92553: PUSH
92554: LD_INT 116
92556: PUSH
92557: LD_INT 117
92559: PUSH
92560: LD_INT 118
92562: PUSH
92563: EMPTY
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: ST_TO_ADDR
92580: GO 94835
92582: LD_INT 9
92584: DOUBLE
92585: EQUAL
92586: IFTRUE 92590
92588: GO 92738
92590: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92591: LD_ADDR_VAR 0 2
92595: PUSH
92596: LD_INT 2
92598: PUSH
92599: LD_INT 4
92601: PUSH
92602: LD_INT 5
92604: PUSH
92605: LD_INT 6
92607: PUSH
92608: LD_INT 7
92610: PUSH
92611: LD_INT 8
92613: PUSH
92614: LD_INT 11
92616: PUSH
92617: LD_INT 12
92619: PUSH
92620: LD_INT 15
92622: PUSH
92623: LD_INT 16
92625: PUSH
92626: LD_INT 20
92628: PUSH
92629: LD_INT 21
92631: PUSH
92632: LD_INT 22
92634: PUSH
92635: LD_INT 23
92637: PUSH
92638: LD_INT 25
92640: PUSH
92641: LD_INT 26
92643: PUSH
92644: LD_INT 28
92646: PUSH
92647: LD_INT 30
92649: PUSH
92650: LD_INT 31
92652: PUSH
92653: LD_INT 32
92655: PUSH
92656: LD_INT 36
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 101
92684: PUSH
92685: LD_INT 102
92687: PUSH
92688: LD_INT 103
92690: PUSH
92691: LD_INT 105
92693: PUSH
92694: LD_INT 106
92696: PUSH
92697: LD_INT 108
92699: PUSH
92700: LD_INT 109
92702: PUSH
92703: LD_INT 112
92705: PUSH
92706: LD_INT 114
92708: PUSH
92709: LD_INT 116
92711: PUSH
92712: LD_INT 117
92714: PUSH
92715: LD_INT 118
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: ST_TO_ADDR
92736: GO 94835
92738: LD_INT 10
92740: DOUBLE
92741: EQUAL
92742: IFTRUE 92746
92744: GO 92942
92746: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92747: LD_ADDR_VAR 0 2
92751: PUSH
92752: LD_INT 2
92754: PUSH
92755: LD_INT 4
92757: PUSH
92758: LD_INT 5
92760: PUSH
92761: LD_INT 6
92763: PUSH
92764: LD_INT 7
92766: PUSH
92767: LD_INT 8
92769: PUSH
92770: LD_INT 9
92772: PUSH
92773: LD_INT 10
92775: PUSH
92776: LD_INT 11
92778: PUSH
92779: LD_INT 12
92781: PUSH
92782: LD_INT 13
92784: PUSH
92785: LD_INT 14
92787: PUSH
92788: LD_INT 15
92790: PUSH
92791: LD_INT 16
92793: PUSH
92794: LD_INT 17
92796: PUSH
92797: LD_INT 18
92799: PUSH
92800: LD_INT 19
92802: PUSH
92803: LD_INT 20
92805: PUSH
92806: LD_INT 21
92808: PUSH
92809: LD_INT 22
92811: PUSH
92812: LD_INT 23
92814: PUSH
92815: LD_INT 24
92817: PUSH
92818: LD_INT 25
92820: PUSH
92821: LD_INT 26
92823: PUSH
92824: LD_INT 28
92826: PUSH
92827: LD_INT 30
92829: PUSH
92830: LD_INT 31
92832: PUSH
92833: LD_INT 32
92835: PUSH
92836: LD_INT 36
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: PUSH
92870: LD_INT 101
92872: PUSH
92873: LD_INT 102
92875: PUSH
92876: LD_INT 103
92878: PUSH
92879: LD_INT 104
92881: PUSH
92882: LD_INT 105
92884: PUSH
92885: LD_INT 106
92887: PUSH
92888: LD_INT 107
92890: PUSH
92891: LD_INT 108
92893: PUSH
92894: LD_INT 109
92896: PUSH
92897: LD_INT 110
92899: PUSH
92900: LD_INT 111
92902: PUSH
92903: LD_INT 112
92905: PUSH
92906: LD_INT 114
92908: PUSH
92909: LD_INT 116
92911: PUSH
92912: LD_INT 117
92914: PUSH
92915: LD_INT 118
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: ST_TO_ADDR
92940: GO 94835
92942: LD_INT 11
92944: DOUBLE
92945: EQUAL
92946: IFTRUE 92950
92948: GO 93154
92950: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
92951: LD_ADDR_VAR 0 2
92955: PUSH
92956: LD_INT 2
92958: PUSH
92959: LD_INT 3
92961: PUSH
92962: LD_INT 4
92964: PUSH
92965: LD_INT 5
92967: PUSH
92968: LD_INT 6
92970: PUSH
92971: LD_INT 7
92973: PUSH
92974: LD_INT 8
92976: PUSH
92977: LD_INT 9
92979: PUSH
92980: LD_INT 10
92982: PUSH
92983: LD_INT 11
92985: PUSH
92986: LD_INT 12
92988: PUSH
92989: LD_INT 13
92991: PUSH
92992: LD_INT 14
92994: PUSH
92995: LD_INT 15
92997: PUSH
92998: LD_INT 16
93000: PUSH
93001: LD_INT 17
93003: PUSH
93004: LD_INT 18
93006: PUSH
93007: LD_INT 19
93009: PUSH
93010: LD_INT 20
93012: PUSH
93013: LD_INT 21
93015: PUSH
93016: LD_INT 22
93018: PUSH
93019: LD_INT 23
93021: PUSH
93022: LD_INT 24
93024: PUSH
93025: LD_INT 25
93027: PUSH
93028: LD_INT 26
93030: PUSH
93031: LD_INT 28
93033: PUSH
93034: LD_INT 30
93036: PUSH
93037: LD_INT 31
93039: PUSH
93040: LD_INT 32
93042: PUSH
93043: LD_INT 34
93045: PUSH
93046: LD_INT 36
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 101
93084: PUSH
93085: LD_INT 102
93087: PUSH
93088: LD_INT 103
93090: PUSH
93091: LD_INT 104
93093: PUSH
93094: LD_INT 105
93096: PUSH
93097: LD_INT 106
93099: PUSH
93100: LD_INT 107
93102: PUSH
93103: LD_INT 108
93105: PUSH
93106: LD_INT 109
93108: PUSH
93109: LD_INT 110
93111: PUSH
93112: LD_INT 111
93114: PUSH
93115: LD_INT 112
93117: PUSH
93118: LD_INT 114
93120: PUSH
93121: LD_INT 116
93123: PUSH
93124: LD_INT 117
93126: PUSH
93127: LD_INT 118
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: ST_TO_ADDR
93152: GO 94835
93154: LD_INT 12
93156: DOUBLE
93157: EQUAL
93158: IFTRUE 93162
93160: GO 93382
93162: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93163: LD_ADDR_VAR 0 2
93167: PUSH
93168: LD_INT 1
93170: PUSH
93171: LD_INT 2
93173: PUSH
93174: LD_INT 3
93176: PUSH
93177: LD_INT 4
93179: PUSH
93180: LD_INT 5
93182: PUSH
93183: LD_INT 6
93185: PUSH
93186: LD_INT 7
93188: PUSH
93189: LD_INT 8
93191: PUSH
93192: LD_INT 9
93194: PUSH
93195: LD_INT 10
93197: PUSH
93198: LD_INT 11
93200: PUSH
93201: LD_INT 12
93203: PUSH
93204: LD_INT 13
93206: PUSH
93207: LD_INT 14
93209: PUSH
93210: LD_INT 15
93212: PUSH
93213: LD_INT 16
93215: PUSH
93216: LD_INT 17
93218: PUSH
93219: LD_INT 18
93221: PUSH
93222: LD_INT 19
93224: PUSH
93225: LD_INT 20
93227: PUSH
93228: LD_INT 21
93230: PUSH
93231: LD_INT 22
93233: PUSH
93234: LD_INT 23
93236: PUSH
93237: LD_INT 24
93239: PUSH
93240: LD_INT 25
93242: PUSH
93243: LD_INT 26
93245: PUSH
93246: LD_INT 27
93248: PUSH
93249: LD_INT 28
93251: PUSH
93252: LD_INT 30
93254: PUSH
93255: LD_INT 31
93257: PUSH
93258: LD_INT 32
93260: PUSH
93261: LD_INT 33
93263: PUSH
93264: LD_INT 34
93266: PUSH
93267: LD_INT 36
93269: PUSH
93270: EMPTY
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 101
93308: PUSH
93309: LD_INT 102
93311: PUSH
93312: LD_INT 103
93314: PUSH
93315: LD_INT 104
93317: PUSH
93318: LD_INT 105
93320: PUSH
93321: LD_INT 106
93323: PUSH
93324: LD_INT 107
93326: PUSH
93327: LD_INT 108
93329: PUSH
93330: LD_INT 109
93332: PUSH
93333: LD_INT 110
93335: PUSH
93336: LD_INT 111
93338: PUSH
93339: LD_INT 112
93341: PUSH
93342: LD_INT 113
93344: PUSH
93345: LD_INT 114
93347: PUSH
93348: LD_INT 116
93350: PUSH
93351: LD_INT 117
93353: PUSH
93354: LD_INT 118
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: ST_TO_ADDR
93380: GO 94835
93382: LD_INT 13
93384: DOUBLE
93385: EQUAL
93386: IFTRUE 93390
93388: GO 93598
93390: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93391: LD_ADDR_VAR 0 2
93395: PUSH
93396: LD_INT 1
93398: PUSH
93399: LD_INT 2
93401: PUSH
93402: LD_INT 3
93404: PUSH
93405: LD_INT 4
93407: PUSH
93408: LD_INT 5
93410: PUSH
93411: LD_INT 8
93413: PUSH
93414: LD_INT 9
93416: PUSH
93417: LD_INT 10
93419: PUSH
93420: LD_INT 11
93422: PUSH
93423: LD_INT 12
93425: PUSH
93426: LD_INT 14
93428: PUSH
93429: LD_INT 15
93431: PUSH
93432: LD_INT 16
93434: PUSH
93435: LD_INT 17
93437: PUSH
93438: LD_INT 18
93440: PUSH
93441: LD_INT 19
93443: PUSH
93444: LD_INT 20
93446: PUSH
93447: LD_INT 21
93449: PUSH
93450: LD_INT 22
93452: PUSH
93453: LD_INT 23
93455: PUSH
93456: LD_INT 24
93458: PUSH
93459: LD_INT 25
93461: PUSH
93462: LD_INT 26
93464: PUSH
93465: LD_INT 27
93467: PUSH
93468: LD_INT 28
93470: PUSH
93471: LD_INT 30
93473: PUSH
93474: LD_INT 31
93476: PUSH
93477: LD_INT 32
93479: PUSH
93480: LD_INT 33
93482: PUSH
93483: LD_INT 34
93485: PUSH
93486: LD_INT 36
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 101
93524: PUSH
93525: LD_INT 102
93527: PUSH
93528: LD_INT 103
93530: PUSH
93531: LD_INT 104
93533: PUSH
93534: LD_INT 105
93536: PUSH
93537: LD_INT 106
93539: PUSH
93540: LD_INT 107
93542: PUSH
93543: LD_INT 108
93545: PUSH
93546: LD_INT 109
93548: PUSH
93549: LD_INT 110
93551: PUSH
93552: LD_INT 111
93554: PUSH
93555: LD_INT 112
93557: PUSH
93558: LD_INT 113
93560: PUSH
93561: LD_INT 114
93563: PUSH
93564: LD_INT 116
93566: PUSH
93567: LD_INT 117
93569: PUSH
93570: LD_INT 118
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: ST_TO_ADDR
93596: GO 94835
93598: LD_INT 14
93600: DOUBLE
93601: EQUAL
93602: IFTRUE 93606
93604: GO 93830
93606: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93607: LD_ADDR_VAR 0 2
93611: PUSH
93612: LD_INT 1
93614: PUSH
93615: LD_INT 2
93617: PUSH
93618: LD_INT 3
93620: PUSH
93621: LD_INT 4
93623: PUSH
93624: LD_INT 5
93626: PUSH
93627: LD_INT 6
93629: PUSH
93630: LD_INT 7
93632: PUSH
93633: LD_INT 8
93635: PUSH
93636: LD_INT 9
93638: PUSH
93639: LD_INT 10
93641: PUSH
93642: LD_INT 11
93644: PUSH
93645: LD_INT 12
93647: PUSH
93648: LD_INT 13
93650: PUSH
93651: LD_INT 14
93653: PUSH
93654: LD_INT 15
93656: PUSH
93657: LD_INT 16
93659: PUSH
93660: LD_INT 17
93662: PUSH
93663: LD_INT 18
93665: PUSH
93666: LD_INT 19
93668: PUSH
93669: LD_INT 20
93671: PUSH
93672: LD_INT 21
93674: PUSH
93675: LD_INT 22
93677: PUSH
93678: LD_INT 23
93680: PUSH
93681: LD_INT 24
93683: PUSH
93684: LD_INT 25
93686: PUSH
93687: LD_INT 26
93689: PUSH
93690: LD_INT 27
93692: PUSH
93693: LD_INT 28
93695: PUSH
93696: LD_INT 29
93698: PUSH
93699: LD_INT 30
93701: PUSH
93702: LD_INT 31
93704: PUSH
93705: LD_INT 32
93707: PUSH
93708: LD_INT 33
93710: PUSH
93711: LD_INT 34
93713: PUSH
93714: LD_INT 36
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: LIST
93736: LIST
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 101
93756: PUSH
93757: LD_INT 102
93759: PUSH
93760: LD_INT 103
93762: PUSH
93763: LD_INT 104
93765: PUSH
93766: LD_INT 105
93768: PUSH
93769: LD_INT 106
93771: PUSH
93772: LD_INT 107
93774: PUSH
93775: LD_INT 108
93777: PUSH
93778: LD_INT 109
93780: PUSH
93781: LD_INT 110
93783: PUSH
93784: LD_INT 111
93786: PUSH
93787: LD_INT 112
93789: PUSH
93790: LD_INT 113
93792: PUSH
93793: LD_INT 114
93795: PUSH
93796: LD_INT 116
93798: PUSH
93799: LD_INT 117
93801: PUSH
93802: LD_INT 118
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: ST_TO_ADDR
93828: GO 94835
93830: LD_INT 15
93832: DOUBLE
93833: EQUAL
93834: IFTRUE 93838
93836: GO 94062
93838: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93839: LD_ADDR_VAR 0 2
93843: PUSH
93844: LD_INT 1
93846: PUSH
93847: LD_INT 2
93849: PUSH
93850: LD_INT 3
93852: PUSH
93853: LD_INT 4
93855: PUSH
93856: LD_INT 5
93858: PUSH
93859: LD_INT 6
93861: PUSH
93862: LD_INT 7
93864: PUSH
93865: LD_INT 8
93867: PUSH
93868: LD_INT 9
93870: PUSH
93871: LD_INT 10
93873: PUSH
93874: LD_INT 11
93876: PUSH
93877: LD_INT 12
93879: PUSH
93880: LD_INT 13
93882: PUSH
93883: LD_INT 14
93885: PUSH
93886: LD_INT 15
93888: PUSH
93889: LD_INT 16
93891: PUSH
93892: LD_INT 17
93894: PUSH
93895: LD_INT 18
93897: PUSH
93898: LD_INT 19
93900: PUSH
93901: LD_INT 20
93903: PUSH
93904: LD_INT 21
93906: PUSH
93907: LD_INT 22
93909: PUSH
93910: LD_INT 23
93912: PUSH
93913: LD_INT 24
93915: PUSH
93916: LD_INT 25
93918: PUSH
93919: LD_INT 26
93921: PUSH
93922: LD_INT 27
93924: PUSH
93925: LD_INT 28
93927: PUSH
93928: LD_INT 29
93930: PUSH
93931: LD_INT 30
93933: PUSH
93934: LD_INT 31
93936: PUSH
93937: LD_INT 32
93939: PUSH
93940: LD_INT 33
93942: PUSH
93943: LD_INT 34
93945: PUSH
93946: LD_INT 36
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: PUSH
93986: LD_INT 101
93988: PUSH
93989: LD_INT 102
93991: PUSH
93992: LD_INT 103
93994: PUSH
93995: LD_INT 104
93997: PUSH
93998: LD_INT 105
94000: PUSH
94001: LD_INT 106
94003: PUSH
94004: LD_INT 107
94006: PUSH
94007: LD_INT 108
94009: PUSH
94010: LD_INT 109
94012: PUSH
94013: LD_INT 110
94015: PUSH
94016: LD_INT 111
94018: PUSH
94019: LD_INT 112
94021: PUSH
94022: LD_INT 113
94024: PUSH
94025: LD_INT 114
94027: PUSH
94028: LD_INT 116
94030: PUSH
94031: LD_INT 117
94033: PUSH
94034: LD_INT 118
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: ST_TO_ADDR
94060: GO 94835
94062: LD_INT 16
94064: DOUBLE
94065: EQUAL
94066: IFTRUE 94070
94068: GO 94206
94070: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94071: LD_ADDR_VAR 0 2
94075: PUSH
94076: LD_INT 2
94078: PUSH
94079: LD_INT 4
94081: PUSH
94082: LD_INT 5
94084: PUSH
94085: LD_INT 7
94087: PUSH
94088: LD_INT 11
94090: PUSH
94091: LD_INT 12
94093: PUSH
94094: LD_INT 15
94096: PUSH
94097: LD_INT 16
94099: PUSH
94100: LD_INT 20
94102: PUSH
94103: LD_INT 21
94105: PUSH
94106: LD_INT 22
94108: PUSH
94109: LD_INT 23
94111: PUSH
94112: LD_INT 25
94114: PUSH
94115: LD_INT 26
94117: PUSH
94118: LD_INT 30
94120: PUSH
94121: LD_INT 31
94123: PUSH
94124: LD_INT 32
94126: PUSH
94127: LD_INT 33
94129: PUSH
94130: LD_INT 34
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: PUSH
94154: LD_INT 101
94156: PUSH
94157: LD_INT 102
94159: PUSH
94160: LD_INT 103
94162: PUSH
94163: LD_INT 106
94165: PUSH
94166: LD_INT 108
94168: PUSH
94169: LD_INT 112
94171: PUSH
94172: LD_INT 113
94174: PUSH
94175: LD_INT 114
94177: PUSH
94178: LD_INT 116
94180: PUSH
94181: LD_INT 117
94183: PUSH
94184: LD_INT 118
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: ST_TO_ADDR
94204: GO 94835
94206: LD_INT 17
94208: DOUBLE
94209: EQUAL
94210: IFTRUE 94214
94212: GO 94438
94214: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94215: LD_ADDR_VAR 0 2
94219: PUSH
94220: LD_INT 1
94222: PUSH
94223: LD_INT 2
94225: PUSH
94226: LD_INT 3
94228: PUSH
94229: LD_INT 4
94231: PUSH
94232: LD_INT 5
94234: PUSH
94235: LD_INT 6
94237: PUSH
94238: LD_INT 7
94240: PUSH
94241: LD_INT 8
94243: PUSH
94244: LD_INT 9
94246: PUSH
94247: LD_INT 10
94249: PUSH
94250: LD_INT 11
94252: PUSH
94253: LD_INT 12
94255: PUSH
94256: LD_INT 13
94258: PUSH
94259: LD_INT 14
94261: PUSH
94262: LD_INT 15
94264: PUSH
94265: LD_INT 16
94267: PUSH
94268: LD_INT 17
94270: PUSH
94271: LD_INT 18
94273: PUSH
94274: LD_INT 19
94276: PUSH
94277: LD_INT 20
94279: PUSH
94280: LD_INT 21
94282: PUSH
94283: LD_INT 22
94285: PUSH
94286: LD_INT 23
94288: PUSH
94289: LD_INT 24
94291: PUSH
94292: LD_INT 25
94294: PUSH
94295: LD_INT 26
94297: PUSH
94298: LD_INT 27
94300: PUSH
94301: LD_INT 28
94303: PUSH
94304: LD_INT 29
94306: PUSH
94307: LD_INT 30
94309: PUSH
94310: LD_INT 31
94312: PUSH
94313: LD_INT 32
94315: PUSH
94316: LD_INT 33
94318: PUSH
94319: LD_INT 34
94321: PUSH
94322: LD_INT 36
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 101
94364: PUSH
94365: LD_INT 102
94367: PUSH
94368: LD_INT 103
94370: PUSH
94371: LD_INT 104
94373: PUSH
94374: LD_INT 105
94376: PUSH
94377: LD_INT 106
94379: PUSH
94380: LD_INT 107
94382: PUSH
94383: LD_INT 108
94385: PUSH
94386: LD_INT 109
94388: PUSH
94389: LD_INT 110
94391: PUSH
94392: LD_INT 111
94394: PUSH
94395: LD_INT 112
94397: PUSH
94398: LD_INT 113
94400: PUSH
94401: LD_INT 114
94403: PUSH
94404: LD_INT 116
94406: PUSH
94407: LD_INT 117
94409: PUSH
94410: LD_INT 118
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: ST_TO_ADDR
94436: GO 94835
94438: LD_INT 18
94440: DOUBLE
94441: EQUAL
94442: IFTRUE 94446
94444: GO 94594
94446: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94447: LD_ADDR_VAR 0 2
94451: PUSH
94452: LD_INT 2
94454: PUSH
94455: LD_INT 4
94457: PUSH
94458: LD_INT 5
94460: PUSH
94461: LD_INT 7
94463: PUSH
94464: LD_INT 11
94466: PUSH
94467: LD_INT 12
94469: PUSH
94470: LD_INT 15
94472: PUSH
94473: LD_INT 16
94475: PUSH
94476: LD_INT 20
94478: PUSH
94479: LD_INT 21
94481: PUSH
94482: LD_INT 22
94484: PUSH
94485: LD_INT 23
94487: PUSH
94488: LD_INT 25
94490: PUSH
94491: LD_INT 26
94493: PUSH
94494: LD_INT 30
94496: PUSH
94497: LD_INT 31
94499: PUSH
94500: LD_INT 32
94502: PUSH
94503: LD_INT 33
94505: PUSH
94506: LD_INT 34
94508: PUSH
94509: LD_INT 35
94511: PUSH
94512: LD_INT 36
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: PUSH
94538: LD_INT 101
94540: PUSH
94541: LD_INT 102
94543: PUSH
94544: LD_INT 103
94546: PUSH
94547: LD_INT 106
94549: PUSH
94550: LD_INT 108
94552: PUSH
94553: LD_INT 112
94555: PUSH
94556: LD_INT 113
94558: PUSH
94559: LD_INT 114
94561: PUSH
94562: LD_INT 115
94564: PUSH
94565: LD_INT 116
94567: PUSH
94568: LD_INT 117
94570: PUSH
94571: LD_INT 118
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: ST_TO_ADDR
94592: GO 94835
94594: LD_INT 19
94596: DOUBLE
94597: EQUAL
94598: IFTRUE 94602
94600: GO 94834
94602: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94603: LD_ADDR_VAR 0 2
94607: PUSH
94608: LD_INT 1
94610: PUSH
94611: LD_INT 2
94613: PUSH
94614: LD_INT 3
94616: PUSH
94617: LD_INT 4
94619: PUSH
94620: LD_INT 5
94622: PUSH
94623: LD_INT 6
94625: PUSH
94626: LD_INT 7
94628: PUSH
94629: LD_INT 8
94631: PUSH
94632: LD_INT 9
94634: PUSH
94635: LD_INT 10
94637: PUSH
94638: LD_INT 11
94640: PUSH
94641: LD_INT 12
94643: PUSH
94644: LD_INT 13
94646: PUSH
94647: LD_INT 14
94649: PUSH
94650: LD_INT 15
94652: PUSH
94653: LD_INT 16
94655: PUSH
94656: LD_INT 17
94658: PUSH
94659: LD_INT 18
94661: PUSH
94662: LD_INT 19
94664: PUSH
94665: LD_INT 20
94667: PUSH
94668: LD_INT 21
94670: PUSH
94671: LD_INT 22
94673: PUSH
94674: LD_INT 23
94676: PUSH
94677: LD_INT 24
94679: PUSH
94680: LD_INT 25
94682: PUSH
94683: LD_INT 26
94685: PUSH
94686: LD_INT 27
94688: PUSH
94689: LD_INT 28
94691: PUSH
94692: LD_INT 29
94694: PUSH
94695: LD_INT 30
94697: PUSH
94698: LD_INT 31
94700: PUSH
94701: LD_INT 32
94703: PUSH
94704: LD_INT 33
94706: PUSH
94707: LD_INT 34
94709: PUSH
94710: LD_INT 35
94712: PUSH
94713: LD_INT 36
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: PUSH
94754: LD_INT 101
94756: PUSH
94757: LD_INT 102
94759: PUSH
94760: LD_INT 103
94762: PUSH
94763: LD_INT 104
94765: PUSH
94766: LD_INT 105
94768: PUSH
94769: LD_INT 106
94771: PUSH
94772: LD_INT 107
94774: PUSH
94775: LD_INT 108
94777: PUSH
94778: LD_INT 109
94780: PUSH
94781: LD_INT 110
94783: PUSH
94784: LD_INT 111
94786: PUSH
94787: LD_INT 112
94789: PUSH
94790: LD_INT 113
94792: PUSH
94793: LD_INT 114
94795: PUSH
94796: LD_INT 115
94798: PUSH
94799: LD_INT 116
94801: PUSH
94802: LD_INT 117
94804: PUSH
94805: LD_INT 118
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: ST_TO_ADDR
94832: GO 94835
94834: POP
// end else
94835: GO 95066
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94837: LD_ADDR_VAR 0 2
94841: PUSH
94842: LD_INT 1
94844: PUSH
94845: LD_INT 2
94847: PUSH
94848: LD_INT 3
94850: PUSH
94851: LD_INT 4
94853: PUSH
94854: LD_INT 5
94856: PUSH
94857: LD_INT 6
94859: PUSH
94860: LD_INT 7
94862: PUSH
94863: LD_INT 8
94865: PUSH
94866: LD_INT 9
94868: PUSH
94869: LD_INT 10
94871: PUSH
94872: LD_INT 11
94874: PUSH
94875: LD_INT 12
94877: PUSH
94878: LD_INT 13
94880: PUSH
94881: LD_INT 14
94883: PUSH
94884: LD_INT 15
94886: PUSH
94887: LD_INT 16
94889: PUSH
94890: LD_INT 17
94892: PUSH
94893: LD_INT 18
94895: PUSH
94896: LD_INT 19
94898: PUSH
94899: LD_INT 20
94901: PUSH
94902: LD_INT 21
94904: PUSH
94905: LD_INT 22
94907: PUSH
94908: LD_INT 23
94910: PUSH
94911: LD_INT 24
94913: PUSH
94914: LD_INT 25
94916: PUSH
94917: LD_INT 26
94919: PUSH
94920: LD_INT 27
94922: PUSH
94923: LD_INT 28
94925: PUSH
94926: LD_INT 29
94928: PUSH
94929: LD_INT 30
94931: PUSH
94932: LD_INT 31
94934: PUSH
94935: LD_INT 32
94937: PUSH
94938: LD_INT 33
94940: PUSH
94941: LD_INT 34
94943: PUSH
94944: LD_INT 35
94946: PUSH
94947: LD_INT 36
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 101
94990: PUSH
94991: LD_INT 102
94993: PUSH
94994: LD_INT 103
94996: PUSH
94997: LD_INT 104
94999: PUSH
95000: LD_INT 105
95002: PUSH
95003: LD_INT 106
95005: PUSH
95006: LD_INT 107
95008: PUSH
95009: LD_INT 108
95011: PUSH
95012: LD_INT 109
95014: PUSH
95015: LD_INT 110
95017: PUSH
95018: LD_INT 111
95020: PUSH
95021: LD_INT 112
95023: PUSH
95024: LD_INT 113
95026: PUSH
95027: LD_INT 114
95029: PUSH
95030: LD_INT 115
95032: PUSH
95033: LD_INT 116
95035: PUSH
95036: LD_INT 117
95038: PUSH
95039: LD_INT 118
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: ST_TO_ADDR
// if result then
95066: LD_VAR 0 2
95070: IFFALSE 95856
// begin normal :=  ;
95072: LD_ADDR_VAR 0 5
95076: PUSH
95077: LD_STRING 
95079: ST_TO_ADDR
// hardcore :=  ;
95080: LD_ADDR_VAR 0 6
95084: PUSH
95085: LD_STRING 
95087: ST_TO_ADDR
// active :=  ;
95088: LD_ADDR_VAR 0 7
95092: PUSH
95093: LD_STRING 
95095: ST_TO_ADDR
// for i = 1 to normalCounter do
95096: LD_ADDR_VAR 0 8
95100: PUSH
95101: DOUBLE
95102: LD_INT 1
95104: DEC
95105: ST_TO_ADDR
95106: LD_EXP 113
95110: PUSH
95111: FOR_TO
95112: IFFALSE 95213
// begin tmp := 0 ;
95114: LD_ADDR_VAR 0 3
95118: PUSH
95119: LD_STRING 0
95121: ST_TO_ADDR
// if result [ 1 ] then
95122: LD_VAR 0 2
95126: PUSH
95127: LD_INT 1
95129: ARRAY
95130: IFFALSE 95195
// if result [ 1 ] [ 1 ] = i then
95132: LD_VAR 0 2
95136: PUSH
95137: LD_INT 1
95139: ARRAY
95140: PUSH
95141: LD_INT 1
95143: ARRAY
95144: PUSH
95145: LD_VAR 0 8
95149: EQUAL
95150: IFFALSE 95195
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95152: LD_ADDR_VAR 0 2
95156: PUSH
95157: LD_VAR 0 2
95161: PPUSH
95162: LD_INT 1
95164: PPUSH
95165: LD_VAR 0 2
95169: PUSH
95170: LD_INT 1
95172: ARRAY
95173: PPUSH
95174: LD_INT 1
95176: PPUSH
95177: CALL_OW 3
95181: PPUSH
95182: CALL_OW 1
95186: ST_TO_ADDR
// tmp := 1 ;
95187: LD_ADDR_VAR 0 3
95191: PUSH
95192: LD_STRING 1
95194: ST_TO_ADDR
// end ; normal := normal & tmp ;
95195: LD_ADDR_VAR 0 5
95199: PUSH
95200: LD_VAR 0 5
95204: PUSH
95205: LD_VAR 0 3
95209: STR
95210: ST_TO_ADDR
// end ;
95211: GO 95111
95213: POP
95214: POP
// for i = 1 to hardcoreCounter do
95215: LD_ADDR_VAR 0 8
95219: PUSH
95220: DOUBLE
95221: LD_INT 1
95223: DEC
95224: ST_TO_ADDR
95225: LD_EXP 114
95229: PUSH
95230: FOR_TO
95231: IFFALSE 95336
// begin tmp := 0 ;
95233: LD_ADDR_VAR 0 3
95237: PUSH
95238: LD_STRING 0
95240: ST_TO_ADDR
// if result [ 2 ] then
95241: LD_VAR 0 2
95245: PUSH
95246: LD_INT 2
95248: ARRAY
95249: IFFALSE 95318
// if result [ 2 ] [ 1 ] = 100 + i then
95251: LD_VAR 0 2
95255: PUSH
95256: LD_INT 2
95258: ARRAY
95259: PUSH
95260: LD_INT 1
95262: ARRAY
95263: PUSH
95264: LD_INT 100
95266: PUSH
95267: LD_VAR 0 8
95271: PLUS
95272: EQUAL
95273: IFFALSE 95318
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95275: LD_ADDR_VAR 0 2
95279: PUSH
95280: LD_VAR 0 2
95284: PPUSH
95285: LD_INT 2
95287: PPUSH
95288: LD_VAR 0 2
95292: PUSH
95293: LD_INT 2
95295: ARRAY
95296: PPUSH
95297: LD_INT 1
95299: PPUSH
95300: CALL_OW 3
95304: PPUSH
95305: CALL_OW 1
95309: ST_TO_ADDR
// tmp := 1 ;
95310: LD_ADDR_VAR 0 3
95314: PUSH
95315: LD_STRING 1
95317: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95318: LD_ADDR_VAR 0 6
95322: PUSH
95323: LD_VAR 0 6
95327: PUSH
95328: LD_VAR 0 3
95332: STR
95333: ST_TO_ADDR
// end ;
95334: GO 95230
95336: POP
95337: POP
// if isGameLoad then
95338: LD_VAR 0 1
95342: IFFALSE 95817
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95344: LD_ADDR_VAR 0 4
95348: PUSH
95349: LD_EXP 117
95353: PUSH
95354: LD_EXP 116
95358: PUSH
95359: LD_EXP 118
95363: PUSH
95364: LD_EXP 115
95368: PUSH
95369: LD_EXP 119
95373: PUSH
95374: LD_EXP 120
95378: PUSH
95379: LD_EXP 121
95383: PUSH
95384: LD_EXP 122
95388: PUSH
95389: LD_EXP 123
95393: PUSH
95394: LD_EXP 124
95398: PUSH
95399: LD_EXP 125
95403: PUSH
95404: LD_EXP 126
95408: PUSH
95409: LD_EXP 127
95413: PUSH
95414: LD_EXP 128
95418: PUSH
95419: LD_EXP 136
95423: PUSH
95424: LD_EXP 137
95428: PUSH
95429: LD_EXP 138
95433: PUSH
95434: LD_EXP 139
95438: PUSH
95439: LD_EXP 141
95443: PUSH
95444: LD_EXP 142
95448: PUSH
95449: LD_EXP 143
95453: PUSH
95454: LD_EXP 146
95458: PUSH
95459: LD_EXP 148
95463: PUSH
95464: LD_EXP 149
95468: PUSH
95469: LD_EXP 150
95473: PUSH
95474: LD_EXP 152
95478: PUSH
95479: LD_EXP 153
95483: PUSH
95484: LD_EXP 156
95488: PUSH
95489: LD_EXP 157
95493: PUSH
95494: LD_EXP 158
95498: PUSH
95499: LD_EXP 159
95503: PUSH
95504: LD_EXP 160
95508: PUSH
95509: LD_EXP 161
95513: PUSH
95514: LD_EXP 162
95518: PUSH
95519: LD_EXP 163
95523: PUSH
95524: LD_EXP 164
95528: PUSH
95529: LD_EXP 129
95533: PUSH
95534: LD_EXP 130
95538: PUSH
95539: LD_EXP 133
95543: PUSH
95544: LD_EXP 134
95548: PUSH
95549: LD_EXP 135
95553: PUSH
95554: LD_EXP 131
95558: PUSH
95559: LD_EXP 132
95563: PUSH
95564: LD_EXP 140
95568: PUSH
95569: LD_EXP 144
95573: PUSH
95574: LD_EXP 145
95578: PUSH
95579: LD_EXP 147
95583: PUSH
95584: LD_EXP 151
95588: PUSH
95589: LD_EXP 154
95593: PUSH
95594: LD_EXP 155
95598: PUSH
95599: LD_EXP 165
95603: PUSH
95604: LD_EXP 166
95608: PUSH
95609: LD_EXP 167
95613: PUSH
95614: LD_EXP 168
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: ST_TO_ADDR
// tmp :=  ;
95675: LD_ADDR_VAR 0 3
95679: PUSH
95680: LD_STRING 
95682: ST_TO_ADDR
// for i = 1 to normalCounter do
95683: LD_ADDR_VAR 0 8
95687: PUSH
95688: DOUBLE
95689: LD_INT 1
95691: DEC
95692: ST_TO_ADDR
95693: LD_EXP 113
95697: PUSH
95698: FOR_TO
95699: IFFALSE 95735
// begin if flags [ i ] then
95701: LD_VAR 0 4
95705: PUSH
95706: LD_VAR 0 8
95710: ARRAY
95711: IFFALSE 95733
// tmp := tmp & i & ; ;
95713: LD_ADDR_VAR 0 3
95717: PUSH
95718: LD_VAR 0 3
95722: PUSH
95723: LD_VAR 0 8
95727: STR
95728: PUSH
95729: LD_STRING ;
95731: STR
95732: ST_TO_ADDR
// end ;
95733: GO 95698
95735: POP
95736: POP
// for i = 1 to hardcoreCounter do
95737: LD_ADDR_VAR 0 8
95741: PUSH
95742: DOUBLE
95743: LD_INT 1
95745: DEC
95746: ST_TO_ADDR
95747: LD_EXP 114
95751: PUSH
95752: FOR_TO
95753: IFFALSE 95799
// begin if flags [ normalCounter + i ] then
95755: LD_VAR 0 4
95759: PUSH
95760: LD_EXP 113
95764: PUSH
95765: LD_VAR 0 8
95769: PLUS
95770: ARRAY
95771: IFFALSE 95797
// tmp := tmp & ( 100 + i ) & ; ;
95773: LD_ADDR_VAR 0 3
95777: PUSH
95778: LD_VAR 0 3
95782: PUSH
95783: LD_INT 100
95785: PUSH
95786: LD_VAR 0 8
95790: PLUS
95791: STR
95792: PUSH
95793: LD_STRING ;
95795: STR
95796: ST_TO_ADDR
// end ;
95797: GO 95752
95799: POP
95800: POP
// if tmp then
95801: LD_VAR 0 3
95805: IFFALSE 95817
// active := tmp ;
95807: LD_ADDR_VAR 0 7
95811: PUSH
95812: LD_VAR 0 3
95816: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95817: LD_STRING getStreamItemsFromMission("
95819: PUSH
95820: LD_VAR 0 5
95824: STR
95825: PUSH
95826: LD_STRING ","
95828: STR
95829: PUSH
95830: LD_VAR 0 6
95834: STR
95835: PUSH
95836: LD_STRING ","
95838: STR
95839: PUSH
95840: LD_VAR 0 7
95844: STR
95845: PUSH
95846: LD_STRING ")
95848: STR
95849: PPUSH
95850: CALL_OW 559
// end else
95854: GO 95863
// ToLua ( getStreamItemsFromMission("","","") ) ;
95856: LD_STRING getStreamItemsFromMission("","","")
95858: PPUSH
95859: CALL_OW 559
// end ;
95863: LD_VAR 0 2
95867: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95868: LD_EXP 112
95872: PUSH
95873: LD_EXP 117
95877: AND
95878: IFFALSE 96002
95880: GO 95882
95882: DISABLE
95883: LD_INT 0
95885: PPUSH
95886: PPUSH
// begin enable ;
95887: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95888: LD_ADDR_VAR 0 2
95892: PUSH
95893: LD_INT 22
95895: PUSH
95896: LD_OWVAR 2
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: LD_INT 2
95907: PUSH
95908: LD_INT 34
95910: PUSH
95911: LD_INT 7
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PUSH
95918: LD_INT 34
95920: PUSH
95921: LD_INT 45
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 34
95930: PUSH
95931: LD_INT 28
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: LD_INT 34
95940: PUSH
95941: LD_INT 47
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: PUSH
95955: EMPTY
95956: LIST
95957: LIST
95958: PPUSH
95959: CALL_OW 69
95963: ST_TO_ADDR
// if not tmp then
95964: LD_VAR 0 2
95968: NOT
95969: IFFALSE 95973
// exit ;
95971: GO 96002
// for i in tmp do
95973: LD_ADDR_VAR 0 1
95977: PUSH
95978: LD_VAR 0 2
95982: PUSH
95983: FOR_IN
95984: IFFALSE 96000
// begin SetLives ( i , 0 ) ;
95986: LD_VAR 0 1
95990: PPUSH
95991: LD_INT 0
95993: PPUSH
95994: CALL_OW 234
// end ;
95998: GO 95983
96000: POP
96001: POP
// end ;
96002: PPOPN 2
96004: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96005: LD_EXP 112
96009: PUSH
96010: LD_EXP 118
96014: AND
96015: IFFALSE 96099
96017: GO 96019
96019: DISABLE
96020: LD_INT 0
96022: PPUSH
96023: PPUSH
// begin enable ;
96024: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96025: LD_ADDR_VAR 0 2
96029: PUSH
96030: LD_INT 22
96032: PUSH
96033: LD_OWVAR 2
96037: PUSH
96038: EMPTY
96039: LIST
96040: LIST
96041: PUSH
96042: LD_INT 32
96044: PUSH
96045: LD_INT 3
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: EMPTY
96053: LIST
96054: LIST
96055: PPUSH
96056: CALL_OW 69
96060: ST_TO_ADDR
// if not tmp then
96061: LD_VAR 0 2
96065: NOT
96066: IFFALSE 96070
// exit ;
96068: GO 96099
// for i in tmp do
96070: LD_ADDR_VAR 0 1
96074: PUSH
96075: LD_VAR 0 2
96079: PUSH
96080: FOR_IN
96081: IFFALSE 96097
// begin SetLives ( i , 0 ) ;
96083: LD_VAR 0 1
96087: PPUSH
96088: LD_INT 0
96090: PPUSH
96091: CALL_OW 234
// end ;
96095: GO 96080
96097: POP
96098: POP
// end ;
96099: PPOPN 2
96101: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96102: LD_EXP 112
96106: PUSH
96107: LD_EXP 115
96111: AND
96112: IFFALSE 96205
96114: GO 96116
96116: DISABLE
96117: LD_INT 0
96119: PPUSH
// begin enable ;
96120: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96121: LD_ADDR_VAR 0 1
96125: PUSH
96126: LD_INT 22
96128: PUSH
96129: LD_OWVAR 2
96133: PUSH
96134: EMPTY
96135: LIST
96136: LIST
96137: PUSH
96138: LD_INT 2
96140: PUSH
96141: LD_INT 25
96143: PUSH
96144: LD_INT 5
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: PUSH
96151: LD_INT 25
96153: PUSH
96154: LD_INT 9
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: LD_INT 25
96163: PUSH
96164: LD_INT 8
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: PUSH
96171: EMPTY
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PPUSH
96181: CALL_OW 69
96185: PUSH
96186: FOR_IN
96187: IFFALSE 96203
// begin SetClass ( i , 1 ) ;
96189: LD_VAR 0 1
96193: PPUSH
96194: LD_INT 1
96196: PPUSH
96197: CALL_OW 336
// end ;
96201: GO 96186
96203: POP
96204: POP
// end ;
96205: PPOPN 1
96207: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96208: LD_EXP 112
96212: PUSH
96213: LD_EXP 116
96217: AND
96218: PUSH
96219: LD_OWVAR 65
96223: PUSH
96224: LD_INT 7
96226: LESS
96227: AND
96228: IFFALSE 96242
96230: GO 96232
96232: DISABLE
// begin enable ;
96233: ENABLE
// game_speed := 7 ;
96234: LD_ADDR_OWVAR 65
96238: PUSH
96239: LD_INT 7
96241: ST_TO_ADDR
// end ;
96242: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96243: LD_EXP 112
96247: PUSH
96248: LD_EXP 119
96252: AND
96253: IFFALSE 96455
96255: GO 96257
96257: DISABLE
96258: LD_INT 0
96260: PPUSH
96261: PPUSH
96262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96263: LD_ADDR_VAR 0 3
96267: PUSH
96268: LD_INT 81
96270: PUSH
96271: LD_OWVAR 2
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 21
96282: PUSH
96283: LD_INT 1
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PPUSH
96294: CALL_OW 69
96298: ST_TO_ADDR
// if not tmp then
96299: LD_VAR 0 3
96303: NOT
96304: IFFALSE 96308
// exit ;
96306: GO 96455
// if tmp > 5 then
96308: LD_VAR 0 3
96312: PUSH
96313: LD_INT 5
96315: GREATER
96316: IFFALSE 96328
// k := 5 else
96318: LD_ADDR_VAR 0 2
96322: PUSH
96323: LD_INT 5
96325: ST_TO_ADDR
96326: GO 96338
// k := tmp ;
96328: LD_ADDR_VAR 0 2
96332: PUSH
96333: LD_VAR 0 3
96337: ST_TO_ADDR
// for i := 1 to k do
96338: LD_ADDR_VAR 0 1
96342: PUSH
96343: DOUBLE
96344: LD_INT 1
96346: DEC
96347: ST_TO_ADDR
96348: LD_VAR 0 2
96352: PUSH
96353: FOR_TO
96354: IFFALSE 96453
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96356: LD_VAR 0 3
96360: PUSH
96361: LD_VAR 0 1
96365: ARRAY
96366: PPUSH
96367: LD_VAR 0 1
96371: PUSH
96372: LD_INT 4
96374: MOD
96375: PUSH
96376: LD_INT 1
96378: PLUS
96379: PPUSH
96380: CALL_OW 259
96384: PUSH
96385: LD_INT 10
96387: LESS
96388: IFFALSE 96451
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96390: LD_VAR 0 3
96394: PUSH
96395: LD_VAR 0 1
96399: ARRAY
96400: PPUSH
96401: LD_VAR 0 1
96405: PUSH
96406: LD_INT 4
96408: MOD
96409: PUSH
96410: LD_INT 1
96412: PLUS
96413: PPUSH
96414: LD_VAR 0 3
96418: PUSH
96419: LD_VAR 0 1
96423: ARRAY
96424: PPUSH
96425: LD_VAR 0 1
96429: PUSH
96430: LD_INT 4
96432: MOD
96433: PUSH
96434: LD_INT 1
96436: PLUS
96437: PPUSH
96438: CALL_OW 259
96442: PUSH
96443: LD_INT 1
96445: PLUS
96446: PPUSH
96447: CALL_OW 237
96451: GO 96353
96453: POP
96454: POP
// end ;
96455: PPOPN 3
96457: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96458: LD_EXP 112
96462: PUSH
96463: LD_EXP 120
96467: AND
96468: IFFALSE 96488
96470: GO 96472
96472: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96473: LD_INT 4
96475: PPUSH
96476: LD_OWVAR 2
96480: PPUSH
96481: LD_INT 0
96483: PPUSH
96484: CALL_OW 324
96488: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96489: LD_EXP 112
96493: PUSH
96494: LD_EXP 149
96498: AND
96499: IFFALSE 96519
96501: GO 96503
96503: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96504: LD_INT 19
96506: PPUSH
96507: LD_OWVAR 2
96511: PPUSH
96512: LD_INT 0
96514: PPUSH
96515: CALL_OW 324
96519: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96520: LD_EXP 112
96524: PUSH
96525: LD_EXP 121
96529: AND
96530: IFFALSE 96632
96532: GO 96534
96534: DISABLE
96535: LD_INT 0
96537: PPUSH
96538: PPUSH
// begin enable ;
96539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96540: LD_ADDR_VAR 0 2
96544: PUSH
96545: LD_INT 22
96547: PUSH
96548: LD_OWVAR 2
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 2
96559: PUSH
96560: LD_INT 34
96562: PUSH
96563: LD_INT 11
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PUSH
96570: LD_INT 34
96572: PUSH
96573: LD_INT 30
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: LIST
96584: PUSH
96585: EMPTY
96586: LIST
96587: LIST
96588: PPUSH
96589: CALL_OW 69
96593: ST_TO_ADDR
// if not tmp then
96594: LD_VAR 0 2
96598: NOT
96599: IFFALSE 96603
// exit ;
96601: GO 96632
// for i in tmp do
96603: LD_ADDR_VAR 0 1
96607: PUSH
96608: LD_VAR 0 2
96612: PUSH
96613: FOR_IN
96614: IFFALSE 96630
// begin SetLives ( i , 0 ) ;
96616: LD_VAR 0 1
96620: PPUSH
96621: LD_INT 0
96623: PPUSH
96624: CALL_OW 234
// end ;
96628: GO 96613
96630: POP
96631: POP
// end ;
96632: PPOPN 2
96634: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96635: LD_EXP 112
96639: PUSH
96640: LD_EXP 122
96644: AND
96645: IFFALSE 96665
96647: GO 96649
96649: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96650: LD_INT 32
96652: PPUSH
96653: LD_OWVAR 2
96657: PPUSH
96658: LD_INT 0
96660: PPUSH
96661: CALL_OW 324
96665: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96666: LD_EXP 112
96670: PUSH
96671: LD_EXP 123
96675: AND
96676: IFFALSE 96857
96678: GO 96680
96680: DISABLE
96681: LD_INT 0
96683: PPUSH
96684: PPUSH
96685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96686: LD_ADDR_VAR 0 2
96690: PUSH
96691: LD_INT 22
96693: PUSH
96694: LD_OWVAR 2
96698: PUSH
96699: EMPTY
96700: LIST
96701: LIST
96702: PUSH
96703: LD_INT 33
96705: PUSH
96706: LD_INT 3
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PPUSH
96717: CALL_OW 69
96721: ST_TO_ADDR
// if not tmp then
96722: LD_VAR 0 2
96726: NOT
96727: IFFALSE 96731
// exit ;
96729: GO 96857
// side := 0 ;
96731: LD_ADDR_VAR 0 3
96735: PUSH
96736: LD_INT 0
96738: ST_TO_ADDR
// for i := 1 to 8 do
96739: LD_ADDR_VAR 0 1
96743: PUSH
96744: DOUBLE
96745: LD_INT 1
96747: DEC
96748: ST_TO_ADDR
96749: LD_INT 8
96751: PUSH
96752: FOR_TO
96753: IFFALSE 96801
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96755: LD_OWVAR 2
96759: PUSH
96760: LD_VAR 0 1
96764: NONEQUAL
96765: PUSH
96766: LD_OWVAR 2
96770: PPUSH
96771: LD_VAR 0 1
96775: PPUSH
96776: CALL_OW 81
96780: PUSH
96781: LD_INT 2
96783: EQUAL
96784: AND
96785: IFFALSE 96799
// begin side := i ;
96787: LD_ADDR_VAR 0 3
96791: PUSH
96792: LD_VAR 0 1
96796: ST_TO_ADDR
// break ;
96797: GO 96801
// end ;
96799: GO 96752
96801: POP
96802: POP
// if not side then
96803: LD_VAR 0 3
96807: NOT
96808: IFFALSE 96812
// exit ;
96810: GO 96857
// for i := 1 to tmp do
96812: LD_ADDR_VAR 0 1
96816: PUSH
96817: DOUBLE
96818: LD_INT 1
96820: DEC
96821: ST_TO_ADDR
96822: LD_VAR 0 2
96826: PUSH
96827: FOR_TO
96828: IFFALSE 96855
// if Prob ( 60 ) then
96830: LD_INT 60
96832: PPUSH
96833: CALL_OW 13
96837: IFFALSE 96853
// SetSide ( i , side ) ;
96839: LD_VAR 0 1
96843: PPUSH
96844: LD_VAR 0 3
96848: PPUSH
96849: CALL_OW 235
96853: GO 96827
96855: POP
96856: POP
// end ;
96857: PPOPN 3
96859: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96860: LD_EXP 112
96864: PUSH
96865: LD_EXP 125
96869: AND
96870: IFFALSE 96989
96872: GO 96874
96874: DISABLE
96875: LD_INT 0
96877: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96878: LD_ADDR_VAR 0 1
96882: PUSH
96883: LD_INT 22
96885: PUSH
96886: LD_OWVAR 2
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: PUSH
96895: LD_INT 21
96897: PUSH
96898: LD_INT 1
96900: PUSH
96901: EMPTY
96902: LIST
96903: LIST
96904: PUSH
96905: LD_INT 3
96907: PUSH
96908: LD_INT 23
96910: PUSH
96911: LD_INT 0
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: LIST
96926: PPUSH
96927: CALL_OW 69
96931: PUSH
96932: FOR_IN
96933: IFFALSE 96987
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96935: LD_VAR 0 1
96939: PPUSH
96940: CALL_OW 257
96944: PUSH
96945: LD_INT 1
96947: PUSH
96948: LD_INT 2
96950: PUSH
96951: LD_INT 3
96953: PUSH
96954: LD_INT 4
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: IN
96963: IFFALSE 96985
// SetClass ( un , rand ( 1 , 4 ) ) ;
96965: LD_VAR 0 1
96969: PPUSH
96970: LD_INT 1
96972: PPUSH
96973: LD_INT 4
96975: PPUSH
96976: CALL_OW 12
96980: PPUSH
96981: CALL_OW 336
96985: GO 96932
96987: POP
96988: POP
// end ;
96989: PPOPN 1
96991: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96992: LD_EXP 112
96996: PUSH
96997: LD_EXP 124
97001: AND
97002: IFFALSE 97081
97004: GO 97006
97006: DISABLE
97007: LD_INT 0
97009: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97010: LD_ADDR_VAR 0 1
97014: PUSH
97015: LD_INT 22
97017: PUSH
97018: LD_OWVAR 2
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 21
97029: PUSH
97030: LD_INT 3
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PPUSH
97041: CALL_OW 69
97045: ST_TO_ADDR
// if not tmp then
97046: LD_VAR 0 1
97050: NOT
97051: IFFALSE 97055
// exit ;
97053: GO 97081
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97055: LD_VAR 0 1
97059: PUSH
97060: LD_INT 1
97062: PPUSH
97063: LD_VAR 0 1
97067: PPUSH
97068: CALL_OW 12
97072: ARRAY
97073: PPUSH
97074: LD_INT 100
97076: PPUSH
97077: CALL_OW 234
// end ;
97081: PPOPN 1
97083: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97084: LD_EXP 112
97088: PUSH
97089: LD_EXP 126
97093: AND
97094: IFFALSE 97192
97096: GO 97098
97098: DISABLE
97099: LD_INT 0
97101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97102: LD_ADDR_VAR 0 1
97106: PUSH
97107: LD_INT 22
97109: PUSH
97110: LD_OWVAR 2
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 21
97121: PUSH
97122: LD_INT 1
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: EMPTY
97130: LIST
97131: LIST
97132: PPUSH
97133: CALL_OW 69
97137: ST_TO_ADDR
// if not tmp then
97138: LD_VAR 0 1
97142: NOT
97143: IFFALSE 97147
// exit ;
97145: GO 97192
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97147: LD_VAR 0 1
97151: PUSH
97152: LD_INT 1
97154: PPUSH
97155: LD_VAR 0 1
97159: PPUSH
97160: CALL_OW 12
97164: ARRAY
97165: PPUSH
97166: LD_INT 1
97168: PPUSH
97169: LD_INT 4
97171: PPUSH
97172: CALL_OW 12
97176: PPUSH
97177: LD_INT 3000
97179: PPUSH
97180: LD_INT 9000
97182: PPUSH
97183: CALL_OW 12
97187: PPUSH
97188: CALL_OW 492
// end ;
97192: PPOPN 1
97194: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97195: LD_EXP 112
97199: PUSH
97200: LD_EXP 127
97204: AND
97205: IFFALSE 97225
97207: GO 97209
97209: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97210: LD_INT 1
97212: PPUSH
97213: LD_OWVAR 2
97217: PPUSH
97218: LD_INT 0
97220: PPUSH
97221: CALL_OW 324
97225: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97226: LD_EXP 112
97230: PUSH
97231: LD_EXP 128
97235: AND
97236: IFFALSE 97319
97238: GO 97240
97240: DISABLE
97241: LD_INT 0
97243: PPUSH
97244: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97245: LD_ADDR_VAR 0 2
97249: PUSH
97250: LD_INT 22
97252: PUSH
97253: LD_OWVAR 2
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: PUSH
97262: LD_INT 21
97264: PUSH
97265: LD_INT 3
97267: PUSH
97268: EMPTY
97269: LIST
97270: LIST
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PPUSH
97276: CALL_OW 69
97280: ST_TO_ADDR
// if not tmp then
97281: LD_VAR 0 2
97285: NOT
97286: IFFALSE 97290
// exit ;
97288: GO 97319
// for i in tmp do
97290: LD_ADDR_VAR 0 1
97294: PUSH
97295: LD_VAR 0 2
97299: PUSH
97300: FOR_IN
97301: IFFALSE 97317
// SetBLevel ( i , 10 ) ;
97303: LD_VAR 0 1
97307: PPUSH
97308: LD_INT 10
97310: PPUSH
97311: CALL_OW 241
97315: GO 97300
97317: POP
97318: POP
// end ;
97319: PPOPN 2
97321: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97322: LD_EXP 112
97326: PUSH
97327: LD_EXP 129
97331: AND
97332: IFFALSE 97443
97334: GO 97336
97336: DISABLE
97337: LD_INT 0
97339: PPUSH
97340: PPUSH
97341: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97342: LD_ADDR_VAR 0 3
97346: PUSH
97347: LD_INT 22
97349: PUSH
97350: LD_OWVAR 2
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 25
97361: PUSH
97362: LD_INT 1
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PPUSH
97373: CALL_OW 69
97377: ST_TO_ADDR
// if not tmp then
97378: LD_VAR 0 3
97382: NOT
97383: IFFALSE 97387
// exit ;
97385: GO 97443
// un := tmp [ rand ( 1 , tmp ) ] ;
97387: LD_ADDR_VAR 0 2
97391: PUSH
97392: LD_VAR 0 3
97396: PUSH
97397: LD_INT 1
97399: PPUSH
97400: LD_VAR 0 3
97404: PPUSH
97405: CALL_OW 12
97409: ARRAY
97410: ST_TO_ADDR
// if Crawls ( un ) then
97411: LD_VAR 0 2
97415: PPUSH
97416: CALL_OW 318
97420: IFFALSE 97431
// ComWalk ( un ) ;
97422: LD_VAR 0 2
97426: PPUSH
97427: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97431: LD_VAR 0 2
97435: PPUSH
97436: LD_INT 5
97438: PPUSH
97439: CALL_OW 336
// end ;
97443: PPOPN 3
97445: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97446: LD_EXP 112
97450: PUSH
97451: LD_EXP 130
97455: AND
97456: PUSH
97457: LD_OWVAR 67
97461: PUSH
97462: LD_INT 4
97464: LESS
97465: AND
97466: IFFALSE 97485
97468: GO 97470
97470: DISABLE
// begin Difficulty := Difficulty + 1 ;
97471: LD_ADDR_OWVAR 67
97475: PUSH
97476: LD_OWVAR 67
97480: PUSH
97481: LD_INT 1
97483: PLUS
97484: ST_TO_ADDR
// end ;
97485: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97486: LD_EXP 112
97490: PUSH
97491: LD_EXP 131
97495: AND
97496: IFFALSE 97599
97498: GO 97500
97500: DISABLE
97501: LD_INT 0
97503: PPUSH
// begin for i := 1 to 5 do
97504: LD_ADDR_VAR 0 1
97508: PUSH
97509: DOUBLE
97510: LD_INT 1
97512: DEC
97513: ST_TO_ADDR
97514: LD_INT 5
97516: PUSH
97517: FOR_TO
97518: IFFALSE 97597
// begin uc_nation := nation_nature ;
97520: LD_ADDR_OWVAR 21
97524: PUSH
97525: LD_INT 0
97527: ST_TO_ADDR
// uc_side := 0 ;
97528: LD_ADDR_OWVAR 20
97532: PUSH
97533: LD_INT 0
97535: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97536: LD_ADDR_OWVAR 29
97540: PUSH
97541: LD_INT 12
97543: PUSH
97544: LD_INT 12
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: ST_TO_ADDR
// hc_agressivity := 20 ;
97551: LD_ADDR_OWVAR 35
97555: PUSH
97556: LD_INT 20
97558: ST_TO_ADDR
// hc_class := class_tiger ;
97559: LD_ADDR_OWVAR 28
97563: PUSH
97564: LD_INT 14
97566: ST_TO_ADDR
// hc_gallery :=  ;
97567: LD_ADDR_OWVAR 33
97571: PUSH
97572: LD_STRING 
97574: ST_TO_ADDR
// hc_name :=  ;
97575: LD_ADDR_OWVAR 26
97579: PUSH
97580: LD_STRING 
97582: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97583: CALL_OW 44
97587: PPUSH
97588: LD_INT 0
97590: PPUSH
97591: CALL_OW 51
// end ;
97595: GO 97517
97597: POP
97598: POP
// end ;
97599: PPOPN 1
97601: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97602: LD_EXP 112
97606: PUSH
97607: LD_EXP 132
97611: AND
97612: IFFALSE 97621
97614: GO 97616
97616: DISABLE
// StreamSibBomb ;
97617: CALL 97622 0 0
97621: END
// export function StreamSibBomb ; var i , x , y ; begin
97622: LD_INT 0
97624: PPUSH
97625: PPUSH
97626: PPUSH
97627: PPUSH
// result := false ;
97628: LD_ADDR_VAR 0 1
97632: PUSH
97633: LD_INT 0
97635: ST_TO_ADDR
// for i := 1 to 16 do
97636: LD_ADDR_VAR 0 2
97640: PUSH
97641: DOUBLE
97642: LD_INT 1
97644: DEC
97645: ST_TO_ADDR
97646: LD_INT 16
97648: PUSH
97649: FOR_TO
97650: IFFALSE 97849
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97652: LD_ADDR_VAR 0 3
97656: PUSH
97657: LD_INT 10
97659: PUSH
97660: LD_INT 20
97662: PUSH
97663: LD_INT 30
97665: PUSH
97666: LD_INT 40
97668: PUSH
97669: LD_INT 50
97671: PUSH
97672: LD_INT 60
97674: PUSH
97675: LD_INT 70
97677: PUSH
97678: LD_INT 80
97680: PUSH
97681: LD_INT 90
97683: PUSH
97684: LD_INT 100
97686: PUSH
97687: LD_INT 110
97689: PUSH
97690: LD_INT 120
97692: PUSH
97693: LD_INT 130
97695: PUSH
97696: LD_INT 140
97698: PUSH
97699: LD_INT 150
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: PUSH
97719: LD_INT 1
97721: PPUSH
97722: LD_INT 15
97724: PPUSH
97725: CALL_OW 12
97729: ARRAY
97730: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97731: LD_ADDR_VAR 0 4
97735: PUSH
97736: LD_INT 10
97738: PUSH
97739: LD_INT 20
97741: PUSH
97742: LD_INT 30
97744: PUSH
97745: LD_INT 40
97747: PUSH
97748: LD_INT 50
97750: PUSH
97751: LD_INT 60
97753: PUSH
97754: LD_INT 70
97756: PUSH
97757: LD_INT 80
97759: PUSH
97760: LD_INT 90
97762: PUSH
97763: LD_INT 100
97765: PUSH
97766: LD_INT 110
97768: PUSH
97769: LD_INT 120
97771: PUSH
97772: LD_INT 130
97774: PUSH
97775: LD_INT 140
97777: PUSH
97778: LD_INT 150
97780: PUSH
97781: EMPTY
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 1
97800: PPUSH
97801: LD_INT 15
97803: PPUSH
97804: CALL_OW 12
97808: ARRAY
97809: ST_TO_ADDR
// if ValidHex ( x , y ) then
97810: LD_VAR 0 3
97814: PPUSH
97815: LD_VAR 0 4
97819: PPUSH
97820: CALL_OW 488
97824: IFFALSE 97847
// begin result := [ x , y ] ;
97826: LD_ADDR_VAR 0 1
97830: PUSH
97831: LD_VAR 0 3
97835: PUSH
97836: LD_VAR 0 4
97840: PUSH
97841: EMPTY
97842: LIST
97843: LIST
97844: ST_TO_ADDR
// break ;
97845: GO 97849
// end ; end ;
97847: GO 97649
97849: POP
97850: POP
// if result then
97851: LD_VAR 0 1
97855: IFFALSE 97915
// begin ToLua ( playSibBomb() ) ;
97857: LD_STRING playSibBomb()
97859: PPUSH
97860: CALL_OW 559
// wait ( 0 0$14 ) ;
97864: LD_INT 490
97866: PPUSH
97867: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97871: LD_VAR 0 1
97875: PUSH
97876: LD_INT 1
97878: ARRAY
97879: PPUSH
97880: LD_VAR 0 1
97884: PUSH
97885: LD_INT 2
97887: ARRAY
97888: PPUSH
97889: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97893: LD_VAR 0 1
97897: PUSH
97898: LD_INT 1
97900: ARRAY
97901: PPUSH
97902: LD_VAR 0 1
97906: PUSH
97907: LD_INT 2
97909: ARRAY
97910: PPUSH
97911: CALL_OW 429
// end ; end ;
97915: LD_VAR 0 1
97919: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97920: LD_EXP 112
97924: PUSH
97925: LD_EXP 134
97929: AND
97930: IFFALSE 97942
97932: GO 97934
97934: DISABLE
// YouLost (  ) ;
97935: LD_STRING 
97937: PPUSH
97938: CALL_OW 104
97942: END
// every 0 0$1 trigger StreamModeActive and sFog do
97943: LD_EXP 112
97947: PUSH
97948: LD_EXP 133
97952: AND
97953: IFFALSE 97967
97955: GO 97957
97957: DISABLE
// FogOff ( your_side ) ;
97958: LD_OWVAR 2
97962: PPUSH
97963: CALL_OW 344
97967: END
// every 0 0$1 trigger StreamModeActive and sSun do
97968: LD_EXP 112
97972: PUSH
97973: LD_EXP 135
97977: AND
97978: IFFALSE 98006
97980: GO 97982
97982: DISABLE
// begin solar_recharge_percent := 0 ;
97983: LD_ADDR_OWVAR 79
97987: PUSH
97988: LD_INT 0
97990: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97991: LD_INT 10500
97993: PPUSH
97994: CALL_OW 67
// solar_recharge_percent := 100 ;
97998: LD_ADDR_OWVAR 79
98002: PUSH
98003: LD_INT 100
98005: ST_TO_ADDR
// end ;
98006: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98007: LD_EXP 112
98011: PUSH
98012: LD_EXP 136
98016: AND
98017: IFFALSE 98256
98019: GO 98021
98021: DISABLE
98022: LD_INT 0
98024: PPUSH
98025: PPUSH
98026: PPUSH
// begin tmp := [ ] ;
98027: LD_ADDR_VAR 0 3
98031: PUSH
98032: EMPTY
98033: ST_TO_ADDR
// for i := 1 to 6 do
98034: LD_ADDR_VAR 0 1
98038: PUSH
98039: DOUBLE
98040: LD_INT 1
98042: DEC
98043: ST_TO_ADDR
98044: LD_INT 6
98046: PUSH
98047: FOR_TO
98048: IFFALSE 98153
// begin uc_nation := nation_nature ;
98050: LD_ADDR_OWVAR 21
98054: PUSH
98055: LD_INT 0
98057: ST_TO_ADDR
// uc_side := 0 ;
98058: LD_ADDR_OWVAR 20
98062: PUSH
98063: LD_INT 0
98065: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98066: LD_ADDR_OWVAR 29
98070: PUSH
98071: LD_INT 12
98073: PUSH
98074: LD_INT 12
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: ST_TO_ADDR
// hc_agressivity := 20 ;
98081: LD_ADDR_OWVAR 35
98085: PUSH
98086: LD_INT 20
98088: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98089: LD_ADDR_OWVAR 28
98093: PUSH
98094: LD_INT 17
98096: ST_TO_ADDR
// hc_gallery :=  ;
98097: LD_ADDR_OWVAR 33
98101: PUSH
98102: LD_STRING 
98104: ST_TO_ADDR
// hc_name :=  ;
98105: LD_ADDR_OWVAR 26
98109: PUSH
98110: LD_STRING 
98112: ST_TO_ADDR
// un := CreateHuman ;
98113: LD_ADDR_VAR 0 2
98117: PUSH
98118: CALL_OW 44
98122: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98123: LD_VAR 0 2
98127: PPUSH
98128: LD_INT 1
98130: PPUSH
98131: CALL_OW 51
// tmp := tmp ^ un ;
98135: LD_ADDR_VAR 0 3
98139: PUSH
98140: LD_VAR 0 3
98144: PUSH
98145: LD_VAR 0 2
98149: ADD
98150: ST_TO_ADDR
// end ;
98151: GO 98047
98153: POP
98154: POP
// repeat wait ( 0 0$1 ) ;
98155: LD_INT 35
98157: PPUSH
98158: CALL_OW 67
// for un in tmp do
98162: LD_ADDR_VAR 0 2
98166: PUSH
98167: LD_VAR 0 3
98171: PUSH
98172: FOR_IN
98173: IFFALSE 98247
// begin if IsDead ( un ) then
98175: LD_VAR 0 2
98179: PPUSH
98180: CALL_OW 301
98184: IFFALSE 98204
// begin tmp := tmp diff un ;
98186: LD_ADDR_VAR 0 3
98190: PUSH
98191: LD_VAR 0 3
98195: PUSH
98196: LD_VAR 0 2
98200: DIFF
98201: ST_TO_ADDR
// continue ;
98202: GO 98172
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98204: LD_VAR 0 2
98208: PPUSH
98209: LD_INT 3
98211: PUSH
98212: LD_INT 22
98214: PUSH
98215: LD_INT 0
98217: PUSH
98218: EMPTY
98219: LIST
98220: LIST
98221: PUSH
98222: EMPTY
98223: LIST
98224: LIST
98225: PPUSH
98226: CALL_OW 69
98230: PPUSH
98231: LD_VAR 0 2
98235: PPUSH
98236: CALL_OW 74
98240: PPUSH
98241: CALL_OW 115
// end ;
98245: GO 98172
98247: POP
98248: POP
// until not tmp ;
98249: LD_VAR 0 3
98253: NOT
98254: IFFALSE 98155
// end ;
98256: PPOPN 3
98258: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98259: LD_EXP 112
98263: PUSH
98264: LD_EXP 137
98268: AND
98269: IFFALSE 98323
98271: GO 98273
98273: DISABLE
// begin ToLua ( displayTroll(); ) ;
98274: LD_STRING displayTroll();
98276: PPUSH
98277: CALL_OW 559
// wait ( 3 3$00 ) ;
98281: LD_INT 6300
98283: PPUSH
98284: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98288: LD_STRING hideTroll();
98290: PPUSH
98291: CALL_OW 559
// wait ( 1 1$00 ) ;
98295: LD_INT 2100
98297: PPUSH
98298: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98302: LD_STRING displayTroll();
98304: PPUSH
98305: CALL_OW 559
// wait ( 1 1$00 ) ;
98309: LD_INT 2100
98311: PPUSH
98312: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98316: LD_STRING hideTroll();
98318: PPUSH
98319: CALL_OW 559
// end ;
98323: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98324: LD_EXP 112
98328: PUSH
98329: LD_EXP 138
98333: AND
98334: IFFALSE 98397
98336: GO 98338
98338: DISABLE
98339: LD_INT 0
98341: PPUSH
// begin p := 0 ;
98342: LD_ADDR_VAR 0 1
98346: PUSH
98347: LD_INT 0
98349: ST_TO_ADDR
// repeat game_speed := 1 ;
98350: LD_ADDR_OWVAR 65
98354: PUSH
98355: LD_INT 1
98357: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98358: LD_INT 35
98360: PPUSH
98361: CALL_OW 67
// p := p + 1 ;
98365: LD_ADDR_VAR 0 1
98369: PUSH
98370: LD_VAR 0 1
98374: PUSH
98375: LD_INT 1
98377: PLUS
98378: ST_TO_ADDR
// until p >= 60 ;
98379: LD_VAR 0 1
98383: PUSH
98384: LD_INT 60
98386: GREATEREQUAL
98387: IFFALSE 98350
// game_speed := 4 ;
98389: LD_ADDR_OWVAR 65
98393: PUSH
98394: LD_INT 4
98396: ST_TO_ADDR
// end ;
98397: PPOPN 1
98399: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98400: LD_EXP 112
98404: PUSH
98405: LD_EXP 139
98409: AND
98410: IFFALSE 98556
98412: GO 98414
98414: DISABLE
98415: LD_INT 0
98417: PPUSH
98418: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98419: LD_ADDR_VAR 0 1
98423: PUSH
98424: LD_INT 22
98426: PUSH
98427: LD_OWVAR 2
98431: PUSH
98432: EMPTY
98433: LIST
98434: LIST
98435: PUSH
98436: LD_INT 2
98438: PUSH
98439: LD_INT 30
98441: PUSH
98442: LD_INT 0
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PUSH
98449: LD_INT 30
98451: PUSH
98452: LD_INT 1
98454: PUSH
98455: EMPTY
98456: LIST
98457: LIST
98458: PUSH
98459: EMPTY
98460: LIST
98461: LIST
98462: LIST
98463: PUSH
98464: EMPTY
98465: LIST
98466: LIST
98467: PPUSH
98468: CALL_OW 69
98472: ST_TO_ADDR
// if not depot then
98473: LD_VAR 0 1
98477: NOT
98478: IFFALSE 98482
// exit ;
98480: GO 98556
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98482: LD_ADDR_VAR 0 2
98486: PUSH
98487: LD_VAR 0 1
98491: PUSH
98492: LD_INT 1
98494: PPUSH
98495: LD_VAR 0 1
98499: PPUSH
98500: CALL_OW 12
98504: ARRAY
98505: PPUSH
98506: CALL_OW 274
98510: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98511: LD_VAR 0 2
98515: PPUSH
98516: LD_INT 1
98518: PPUSH
98519: LD_INT 0
98521: PPUSH
98522: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98526: LD_VAR 0 2
98530: PPUSH
98531: LD_INT 2
98533: PPUSH
98534: LD_INT 0
98536: PPUSH
98537: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98541: LD_VAR 0 2
98545: PPUSH
98546: LD_INT 3
98548: PPUSH
98549: LD_INT 0
98551: PPUSH
98552: CALL_OW 277
// end ;
98556: PPOPN 2
98558: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98559: LD_EXP 112
98563: PUSH
98564: LD_EXP 140
98568: AND
98569: IFFALSE 98666
98571: GO 98573
98573: DISABLE
98574: LD_INT 0
98576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98577: LD_ADDR_VAR 0 1
98581: PUSH
98582: LD_INT 22
98584: PUSH
98585: LD_OWVAR 2
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: PUSH
98594: LD_INT 21
98596: PUSH
98597: LD_INT 1
98599: PUSH
98600: EMPTY
98601: LIST
98602: LIST
98603: PUSH
98604: LD_INT 3
98606: PUSH
98607: LD_INT 23
98609: PUSH
98610: LD_INT 0
98612: PUSH
98613: EMPTY
98614: LIST
98615: LIST
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: EMPTY
98622: LIST
98623: LIST
98624: LIST
98625: PPUSH
98626: CALL_OW 69
98630: ST_TO_ADDR
// if not tmp then
98631: LD_VAR 0 1
98635: NOT
98636: IFFALSE 98640
// exit ;
98638: GO 98666
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98640: LD_VAR 0 1
98644: PUSH
98645: LD_INT 1
98647: PPUSH
98648: LD_VAR 0 1
98652: PPUSH
98653: CALL_OW 12
98657: ARRAY
98658: PPUSH
98659: LD_INT 200
98661: PPUSH
98662: CALL_OW 234
// end ;
98666: PPOPN 1
98668: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98669: LD_EXP 112
98673: PUSH
98674: LD_EXP 141
98678: AND
98679: IFFALSE 98758
98681: GO 98683
98683: DISABLE
98684: LD_INT 0
98686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98687: LD_ADDR_VAR 0 1
98691: PUSH
98692: LD_INT 22
98694: PUSH
98695: LD_OWVAR 2
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: PUSH
98704: LD_INT 21
98706: PUSH
98707: LD_INT 2
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: PUSH
98714: EMPTY
98715: LIST
98716: LIST
98717: PPUSH
98718: CALL_OW 69
98722: ST_TO_ADDR
// if not tmp then
98723: LD_VAR 0 1
98727: NOT
98728: IFFALSE 98732
// exit ;
98730: GO 98758
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98732: LD_VAR 0 1
98736: PUSH
98737: LD_INT 1
98739: PPUSH
98740: LD_VAR 0 1
98744: PPUSH
98745: CALL_OW 12
98749: ARRAY
98750: PPUSH
98751: LD_INT 60
98753: PPUSH
98754: CALL_OW 234
// end ;
98758: PPOPN 1
98760: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98761: LD_EXP 112
98765: PUSH
98766: LD_EXP 142
98770: AND
98771: IFFALSE 98870
98773: GO 98775
98775: DISABLE
98776: LD_INT 0
98778: PPUSH
98779: PPUSH
// begin enable ;
98780: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98781: LD_ADDR_VAR 0 1
98785: PUSH
98786: LD_INT 22
98788: PUSH
98789: LD_OWVAR 2
98793: PUSH
98794: EMPTY
98795: LIST
98796: LIST
98797: PUSH
98798: LD_INT 61
98800: PUSH
98801: EMPTY
98802: LIST
98803: PUSH
98804: LD_INT 33
98806: PUSH
98807: LD_INT 2
98809: PUSH
98810: EMPTY
98811: LIST
98812: LIST
98813: PUSH
98814: EMPTY
98815: LIST
98816: LIST
98817: LIST
98818: PPUSH
98819: CALL_OW 69
98823: ST_TO_ADDR
// if not tmp then
98824: LD_VAR 0 1
98828: NOT
98829: IFFALSE 98833
// exit ;
98831: GO 98870
// for i in tmp do
98833: LD_ADDR_VAR 0 2
98837: PUSH
98838: LD_VAR 0 1
98842: PUSH
98843: FOR_IN
98844: IFFALSE 98868
// if IsControledBy ( i ) then
98846: LD_VAR 0 2
98850: PPUSH
98851: CALL_OW 312
98855: IFFALSE 98866
// ComUnlink ( i ) ;
98857: LD_VAR 0 2
98861: PPUSH
98862: CALL_OW 136
98866: GO 98843
98868: POP
98869: POP
// end ;
98870: PPOPN 2
98872: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98873: LD_EXP 112
98877: PUSH
98878: LD_EXP 143
98882: AND
98883: IFFALSE 99023
98885: GO 98887
98887: DISABLE
98888: LD_INT 0
98890: PPUSH
98891: PPUSH
// begin ToLua ( displayPowell(); ) ;
98892: LD_STRING displayPowell();
98894: PPUSH
98895: CALL_OW 559
// uc_side := 0 ;
98899: LD_ADDR_OWVAR 20
98903: PUSH
98904: LD_INT 0
98906: ST_TO_ADDR
// uc_nation := 2 ;
98907: LD_ADDR_OWVAR 21
98911: PUSH
98912: LD_INT 2
98914: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98915: LD_ADDR_OWVAR 37
98919: PUSH
98920: LD_INT 14
98922: ST_TO_ADDR
// vc_engine := engine_siberite ;
98923: LD_ADDR_OWVAR 39
98927: PUSH
98928: LD_INT 3
98930: ST_TO_ADDR
// vc_control := control_apeman ;
98931: LD_ADDR_OWVAR 38
98935: PUSH
98936: LD_INT 5
98938: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98939: LD_ADDR_OWVAR 40
98943: PUSH
98944: LD_INT 29
98946: ST_TO_ADDR
// un := CreateVehicle ;
98947: LD_ADDR_VAR 0 2
98951: PUSH
98952: CALL_OW 45
98956: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98957: LD_VAR 0 2
98961: PPUSH
98962: LD_INT 1
98964: PPUSH
98965: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98969: LD_INT 35
98971: PPUSH
98972: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98976: LD_VAR 0 2
98980: PPUSH
98981: LD_INT 22
98983: PUSH
98984: LD_OWVAR 2
98988: PUSH
98989: EMPTY
98990: LIST
98991: LIST
98992: PPUSH
98993: CALL_OW 69
98997: PPUSH
98998: LD_VAR 0 2
99002: PPUSH
99003: CALL_OW 74
99007: PPUSH
99008: CALL_OW 115
// until IsDead ( un ) ;
99012: LD_VAR 0 2
99016: PPUSH
99017: CALL_OW 301
99021: IFFALSE 98969
// end ;
99023: PPOPN 2
99025: END
// every 0 0$1 trigger StreamModeActive and sStu do
99026: LD_EXP 112
99030: PUSH
99031: LD_EXP 151
99035: AND
99036: IFFALSE 99052
99038: GO 99040
99040: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99041: LD_STRING displayStucuk();
99043: PPUSH
99044: CALL_OW 559
// ResetFog ;
99048: CALL_OW 335
// end ;
99052: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99053: LD_EXP 112
99057: PUSH
99058: LD_EXP 144
99062: AND
99063: IFFALSE 99204
99065: GO 99067
99067: DISABLE
99068: LD_INT 0
99070: PPUSH
99071: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99072: LD_ADDR_VAR 0 2
99076: PUSH
99077: LD_INT 22
99079: PUSH
99080: LD_OWVAR 2
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: PUSH
99089: LD_INT 21
99091: PUSH
99092: LD_INT 1
99094: PUSH
99095: EMPTY
99096: LIST
99097: LIST
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: PPUSH
99103: CALL_OW 69
99107: ST_TO_ADDR
// if not tmp then
99108: LD_VAR 0 2
99112: NOT
99113: IFFALSE 99117
// exit ;
99115: GO 99204
// un := tmp [ rand ( 1 , tmp ) ] ;
99117: LD_ADDR_VAR 0 1
99121: PUSH
99122: LD_VAR 0 2
99126: PUSH
99127: LD_INT 1
99129: PPUSH
99130: LD_VAR 0 2
99134: PPUSH
99135: CALL_OW 12
99139: ARRAY
99140: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99141: LD_VAR 0 1
99145: PPUSH
99146: LD_INT 0
99148: PPUSH
99149: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99153: LD_VAR 0 1
99157: PPUSH
99158: LD_OWVAR 3
99162: PUSH
99163: LD_VAR 0 1
99167: DIFF
99168: PPUSH
99169: LD_VAR 0 1
99173: PPUSH
99174: CALL_OW 74
99178: PPUSH
99179: CALL_OW 115
// wait ( 0 0$20 ) ;
99183: LD_INT 700
99185: PPUSH
99186: CALL_OW 67
// SetSide ( un , your_side ) ;
99190: LD_VAR 0 1
99194: PPUSH
99195: LD_OWVAR 2
99199: PPUSH
99200: CALL_OW 235
// end ;
99204: PPOPN 2
99206: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99207: LD_EXP 112
99211: PUSH
99212: LD_EXP 145
99216: AND
99217: IFFALSE 99323
99219: GO 99221
99221: DISABLE
99222: LD_INT 0
99224: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99225: LD_ADDR_VAR 0 1
99229: PUSH
99230: LD_INT 22
99232: PUSH
99233: LD_OWVAR 2
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PUSH
99242: LD_INT 2
99244: PUSH
99245: LD_INT 30
99247: PUSH
99248: LD_INT 0
99250: PUSH
99251: EMPTY
99252: LIST
99253: LIST
99254: PUSH
99255: LD_INT 30
99257: PUSH
99258: LD_INT 1
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: LIST
99269: PUSH
99270: EMPTY
99271: LIST
99272: LIST
99273: PPUSH
99274: CALL_OW 69
99278: ST_TO_ADDR
// if not depot then
99279: LD_VAR 0 1
99283: NOT
99284: IFFALSE 99288
// exit ;
99286: GO 99323
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99288: LD_VAR 0 1
99292: PUSH
99293: LD_INT 1
99295: ARRAY
99296: PPUSH
99297: CALL_OW 250
99301: PPUSH
99302: LD_VAR 0 1
99306: PUSH
99307: LD_INT 1
99309: ARRAY
99310: PPUSH
99311: CALL_OW 251
99315: PPUSH
99316: LD_INT 70
99318: PPUSH
99319: CALL_OW 495
// end ;
99323: PPOPN 1
99325: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99326: LD_EXP 112
99330: PUSH
99331: LD_EXP 146
99335: AND
99336: IFFALSE 99547
99338: GO 99340
99340: DISABLE
99341: LD_INT 0
99343: PPUSH
99344: PPUSH
99345: PPUSH
99346: PPUSH
99347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99348: LD_ADDR_VAR 0 5
99352: PUSH
99353: LD_INT 22
99355: PUSH
99356: LD_OWVAR 2
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: PUSH
99365: LD_INT 21
99367: PUSH
99368: LD_INT 1
99370: PUSH
99371: EMPTY
99372: LIST
99373: LIST
99374: PUSH
99375: EMPTY
99376: LIST
99377: LIST
99378: PPUSH
99379: CALL_OW 69
99383: ST_TO_ADDR
// if not tmp then
99384: LD_VAR 0 5
99388: NOT
99389: IFFALSE 99393
// exit ;
99391: GO 99547
// for i in tmp do
99393: LD_ADDR_VAR 0 1
99397: PUSH
99398: LD_VAR 0 5
99402: PUSH
99403: FOR_IN
99404: IFFALSE 99545
// begin d := rand ( 0 , 5 ) ;
99406: LD_ADDR_VAR 0 4
99410: PUSH
99411: LD_INT 0
99413: PPUSH
99414: LD_INT 5
99416: PPUSH
99417: CALL_OW 12
99421: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99422: LD_ADDR_VAR 0 2
99426: PUSH
99427: LD_VAR 0 1
99431: PPUSH
99432: CALL_OW 250
99436: PPUSH
99437: LD_VAR 0 4
99441: PPUSH
99442: LD_INT 3
99444: PPUSH
99445: LD_INT 12
99447: PPUSH
99448: CALL_OW 12
99452: PPUSH
99453: CALL_OW 272
99457: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99458: LD_ADDR_VAR 0 3
99462: PUSH
99463: LD_VAR 0 1
99467: PPUSH
99468: CALL_OW 251
99472: PPUSH
99473: LD_VAR 0 4
99477: PPUSH
99478: LD_INT 3
99480: PPUSH
99481: LD_INT 12
99483: PPUSH
99484: CALL_OW 12
99488: PPUSH
99489: CALL_OW 273
99493: ST_TO_ADDR
// if ValidHex ( x , y ) then
99494: LD_VAR 0 2
99498: PPUSH
99499: LD_VAR 0 3
99503: PPUSH
99504: CALL_OW 488
99508: IFFALSE 99543
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99510: LD_VAR 0 1
99514: PPUSH
99515: LD_VAR 0 2
99519: PPUSH
99520: LD_VAR 0 3
99524: PPUSH
99525: LD_INT 3
99527: PPUSH
99528: LD_INT 6
99530: PPUSH
99531: CALL_OW 12
99535: PPUSH
99536: LD_INT 1
99538: PPUSH
99539: CALL_OW 483
// end ;
99543: GO 99403
99545: POP
99546: POP
// end ;
99547: PPOPN 5
99549: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99550: LD_EXP 112
99554: PUSH
99555: LD_EXP 147
99559: AND
99560: IFFALSE 99654
99562: GO 99564
99564: DISABLE
99565: LD_INT 0
99567: PPUSH
99568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99569: LD_ADDR_VAR 0 2
99573: PUSH
99574: LD_INT 22
99576: PUSH
99577: LD_OWVAR 2
99581: PUSH
99582: EMPTY
99583: LIST
99584: LIST
99585: PUSH
99586: LD_INT 32
99588: PUSH
99589: LD_INT 1
99591: PUSH
99592: EMPTY
99593: LIST
99594: LIST
99595: PUSH
99596: LD_INT 21
99598: PUSH
99599: LD_INT 2
99601: PUSH
99602: EMPTY
99603: LIST
99604: LIST
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: LIST
99610: PPUSH
99611: CALL_OW 69
99615: ST_TO_ADDR
// if not tmp then
99616: LD_VAR 0 2
99620: NOT
99621: IFFALSE 99625
// exit ;
99623: GO 99654
// for i in tmp do
99625: LD_ADDR_VAR 0 1
99629: PUSH
99630: LD_VAR 0 2
99634: PUSH
99635: FOR_IN
99636: IFFALSE 99652
// SetFuel ( i , 0 ) ;
99638: LD_VAR 0 1
99642: PPUSH
99643: LD_INT 0
99645: PPUSH
99646: CALL_OW 240
99650: GO 99635
99652: POP
99653: POP
// end ;
99654: PPOPN 2
99656: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99657: LD_EXP 112
99661: PUSH
99662: LD_EXP 148
99666: AND
99667: IFFALSE 99733
99669: GO 99671
99671: DISABLE
99672: LD_INT 0
99674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99675: LD_ADDR_VAR 0 1
99679: PUSH
99680: LD_INT 22
99682: PUSH
99683: LD_OWVAR 2
99687: PUSH
99688: EMPTY
99689: LIST
99690: LIST
99691: PUSH
99692: LD_INT 30
99694: PUSH
99695: LD_INT 29
99697: PUSH
99698: EMPTY
99699: LIST
99700: LIST
99701: PUSH
99702: EMPTY
99703: LIST
99704: LIST
99705: PPUSH
99706: CALL_OW 69
99710: ST_TO_ADDR
// if not tmp then
99711: LD_VAR 0 1
99715: NOT
99716: IFFALSE 99720
// exit ;
99718: GO 99733
// DestroyUnit ( tmp [ 1 ] ) ;
99720: LD_VAR 0 1
99724: PUSH
99725: LD_INT 1
99727: ARRAY
99728: PPUSH
99729: CALL_OW 65
// end ;
99733: PPOPN 1
99735: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99736: LD_EXP 112
99740: PUSH
99741: LD_EXP 150
99745: AND
99746: IFFALSE 99875
99748: GO 99750
99750: DISABLE
99751: LD_INT 0
99753: PPUSH
// begin uc_side := 0 ;
99754: LD_ADDR_OWVAR 20
99758: PUSH
99759: LD_INT 0
99761: ST_TO_ADDR
// uc_nation := nation_arabian ;
99762: LD_ADDR_OWVAR 21
99766: PUSH
99767: LD_INT 2
99769: ST_TO_ADDR
// hc_gallery :=  ;
99770: LD_ADDR_OWVAR 33
99774: PUSH
99775: LD_STRING 
99777: ST_TO_ADDR
// hc_name :=  ;
99778: LD_ADDR_OWVAR 26
99782: PUSH
99783: LD_STRING 
99785: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99786: LD_INT 1
99788: PPUSH
99789: LD_INT 11
99791: PPUSH
99792: LD_INT 10
99794: PPUSH
99795: CALL_OW 380
// un := CreateHuman ;
99799: LD_ADDR_VAR 0 1
99803: PUSH
99804: CALL_OW 44
99808: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99809: LD_VAR 0 1
99813: PPUSH
99814: LD_INT 1
99816: PPUSH
99817: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99821: LD_INT 35
99823: PPUSH
99824: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99828: LD_VAR 0 1
99832: PPUSH
99833: LD_INT 22
99835: PUSH
99836: LD_OWVAR 2
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PPUSH
99845: CALL_OW 69
99849: PPUSH
99850: LD_VAR 0 1
99854: PPUSH
99855: CALL_OW 74
99859: PPUSH
99860: CALL_OW 115
// until IsDead ( un ) ;
99864: LD_VAR 0 1
99868: PPUSH
99869: CALL_OW 301
99873: IFFALSE 99821
// end ;
99875: PPOPN 1
99877: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99878: LD_EXP 112
99882: PUSH
99883: LD_EXP 152
99887: AND
99888: IFFALSE 99900
99890: GO 99892
99892: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99893: LD_STRING earthquake(getX(game), 0, 32)
99895: PPUSH
99896: CALL_OW 559
99900: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99901: LD_EXP 112
99905: PUSH
99906: LD_EXP 153
99910: AND
99911: IFFALSE 100002
99913: GO 99915
99915: DISABLE
99916: LD_INT 0
99918: PPUSH
// begin enable ;
99919: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99920: LD_ADDR_VAR 0 1
99924: PUSH
99925: LD_INT 22
99927: PUSH
99928: LD_OWVAR 2
99932: PUSH
99933: EMPTY
99934: LIST
99935: LIST
99936: PUSH
99937: LD_INT 21
99939: PUSH
99940: LD_INT 2
99942: PUSH
99943: EMPTY
99944: LIST
99945: LIST
99946: PUSH
99947: LD_INT 33
99949: PUSH
99950: LD_INT 3
99952: PUSH
99953: EMPTY
99954: LIST
99955: LIST
99956: PUSH
99957: EMPTY
99958: LIST
99959: LIST
99960: LIST
99961: PPUSH
99962: CALL_OW 69
99966: ST_TO_ADDR
// if not tmp then
99967: LD_VAR 0 1
99971: NOT
99972: IFFALSE 99976
// exit ;
99974: GO 100002
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99976: LD_VAR 0 1
99980: PUSH
99981: LD_INT 1
99983: PPUSH
99984: LD_VAR 0 1
99988: PPUSH
99989: CALL_OW 12
99993: ARRAY
99994: PPUSH
99995: LD_INT 1
99997: PPUSH
99998: CALL_OW 234
// end ;
100002: PPOPN 1
100004: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100005: LD_EXP 112
100009: PUSH
100010: LD_EXP 154
100014: AND
100015: IFFALSE 100156
100017: GO 100019
100019: DISABLE
100020: LD_INT 0
100022: PPUSH
100023: PPUSH
100024: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100025: LD_ADDR_VAR 0 3
100029: PUSH
100030: LD_INT 22
100032: PUSH
100033: LD_OWVAR 2
100037: PUSH
100038: EMPTY
100039: LIST
100040: LIST
100041: PUSH
100042: LD_INT 25
100044: PUSH
100045: LD_INT 1
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: PUSH
100052: EMPTY
100053: LIST
100054: LIST
100055: PPUSH
100056: CALL_OW 69
100060: ST_TO_ADDR
// if not tmp then
100061: LD_VAR 0 3
100065: NOT
100066: IFFALSE 100070
// exit ;
100068: GO 100156
// un := tmp [ rand ( 1 , tmp ) ] ;
100070: LD_ADDR_VAR 0 2
100074: PUSH
100075: LD_VAR 0 3
100079: PUSH
100080: LD_INT 1
100082: PPUSH
100083: LD_VAR 0 3
100087: PPUSH
100088: CALL_OW 12
100092: ARRAY
100093: ST_TO_ADDR
// if Crawls ( un ) then
100094: LD_VAR 0 2
100098: PPUSH
100099: CALL_OW 318
100103: IFFALSE 100114
// ComWalk ( un ) ;
100105: LD_VAR 0 2
100109: PPUSH
100110: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100114: LD_VAR 0 2
100118: PPUSH
100119: LD_INT 9
100121: PPUSH
100122: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100126: LD_INT 28
100128: PPUSH
100129: LD_OWVAR 2
100133: PPUSH
100134: LD_INT 2
100136: PPUSH
100137: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100141: LD_INT 29
100143: PPUSH
100144: LD_OWVAR 2
100148: PPUSH
100149: LD_INT 2
100151: PPUSH
100152: CALL_OW 322
// end ;
100156: PPOPN 3
100158: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100159: LD_EXP 112
100163: PUSH
100164: LD_EXP 155
100168: AND
100169: IFFALSE 100280
100171: GO 100173
100173: DISABLE
100174: LD_INT 0
100176: PPUSH
100177: PPUSH
100178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100179: LD_ADDR_VAR 0 3
100183: PUSH
100184: LD_INT 22
100186: PUSH
100187: LD_OWVAR 2
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PUSH
100196: LD_INT 25
100198: PUSH
100199: LD_INT 1
100201: PUSH
100202: EMPTY
100203: LIST
100204: LIST
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: PPUSH
100210: CALL_OW 69
100214: ST_TO_ADDR
// if not tmp then
100215: LD_VAR 0 3
100219: NOT
100220: IFFALSE 100224
// exit ;
100222: GO 100280
// un := tmp [ rand ( 1 , tmp ) ] ;
100224: LD_ADDR_VAR 0 2
100228: PUSH
100229: LD_VAR 0 3
100233: PUSH
100234: LD_INT 1
100236: PPUSH
100237: LD_VAR 0 3
100241: PPUSH
100242: CALL_OW 12
100246: ARRAY
100247: ST_TO_ADDR
// if Crawls ( un ) then
100248: LD_VAR 0 2
100252: PPUSH
100253: CALL_OW 318
100257: IFFALSE 100268
// ComWalk ( un ) ;
100259: LD_VAR 0 2
100263: PPUSH
100264: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100268: LD_VAR 0 2
100272: PPUSH
100273: LD_INT 8
100275: PPUSH
100276: CALL_OW 336
// end ;
100280: PPOPN 3
100282: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100283: LD_EXP 112
100287: PUSH
100288: LD_EXP 156
100292: AND
100293: IFFALSE 100437
100295: GO 100297
100297: DISABLE
100298: LD_INT 0
100300: PPUSH
100301: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100302: LD_ADDR_VAR 0 2
100306: PUSH
100307: LD_INT 22
100309: PUSH
100310: LD_OWVAR 2
100314: PUSH
100315: EMPTY
100316: LIST
100317: LIST
100318: PUSH
100319: LD_INT 21
100321: PUSH
100322: LD_INT 2
100324: PUSH
100325: EMPTY
100326: LIST
100327: LIST
100328: PUSH
100329: LD_INT 2
100331: PUSH
100332: LD_INT 34
100334: PUSH
100335: LD_INT 12
100337: PUSH
100338: EMPTY
100339: LIST
100340: LIST
100341: PUSH
100342: LD_INT 34
100344: PUSH
100345: LD_INT 51
100347: PUSH
100348: EMPTY
100349: LIST
100350: LIST
100351: PUSH
100352: LD_INT 34
100354: PUSH
100355: LD_INT 32
100357: PUSH
100358: EMPTY
100359: LIST
100360: LIST
100361: PUSH
100362: EMPTY
100363: LIST
100364: LIST
100365: LIST
100366: LIST
100367: PUSH
100368: EMPTY
100369: LIST
100370: LIST
100371: LIST
100372: PPUSH
100373: CALL_OW 69
100377: ST_TO_ADDR
// if not tmp then
100378: LD_VAR 0 2
100382: NOT
100383: IFFALSE 100387
// exit ;
100385: GO 100437
// for i in tmp do
100387: LD_ADDR_VAR 0 1
100391: PUSH
100392: LD_VAR 0 2
100396: PUSH
100397: FOR_IN
100398: IFFALSE 100435
// if GetCargo ( i , mat_artifact ) = 0 then
100400: LD_VAR 0 1
100404: PPUSH
100405: LD_INT 4
100407: PPUSH
100408: CALL_OW 289
100412: PUSH
100413: LD_INT 0
100415: EQUAL
100416: IFFALSE 100433
// SetCargo ( i , mat_siberit , 100 ) ;
100418: LD_VAR 0 1
100422: PPUSH
100423: LD_INT 3
100425: PPUSH
100426: LD_INT 100
100428: PPUSH
100429: CALL_OW 290
100433: GO 100397
100435: POP
100436: POP
// end ;
100437: PPOPN 2
100439: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100440: LD_EXP 112
100444: PUSH
100445: LD_EXP 157
100449: AND
100450: IFFALSE 100633
100452: GO 100454
100454: DISABLE
100455: LD_INT 0
100457: PPUSH
100458: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100459: LD_ADDR_VAR 0 2
100463: PUSH
100464: LD_INT 22
100466: PUSH
100467: LD_OWVAR 2
100471: PUSH
100472: EMPTY
100473: LIST
100474: LIST
100475: PPUSH
100476: CALL_OW 69
100480: ST_TO_ADDR
// if not tmp then
100481: LD_VAR 0 2
100485: NOT
100486: IFFALSE 100490
// exit ;
100488: GO 100633
// for i := 1 to 2 do
100490: LD_ADDR_VAR 0 1
100494: PUSH
100495: DOUBLE
100496: LD_INT 1
100498: DEC
100499: ST_TO_ADDR
100500: LD_INT 2
100502: PUSH
100503: FOR_TO
100504: IFFALSE 100631
// begin uc_side := your_side ;
100506: LD_ADDR_OWVAR 20
100510: PUSH
100511: LD_OWVAR 2
100515: ST_TO_ADDR
// uc_nation := nation_american ;
100516: LD_ADDR_OWVAR 21
100520: PUSH
100521: LD_INT 1
100523: ST_TO_ADDR
// vc_chassis := us_morphling ;
100524: LD_ADDR_OWVAR 37
100528: PUSH
100529: LD_INT 5
100531: ST_TO_ADDR
// vc_engine := engine_siberite ;
100532: LD_ADDR_OWVAR 39
100536: PUSH
100537: LD_INT 3
100539: ST_TO_ADDR
// vc_control := control_computer ;
100540: LD_ADDR_OWVAR 38
100544: PUSH
100545: LD_INT 3
100547: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100548: LD_ADDR_OWVAR 40
100552: PUSH
100553: LD_INT 10
100555: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100556: LD_VAR 0 2
100560: PUSH
100561: LD_INT 1
100563: ARRAY
100564: PPUSH
100565: CALL_OW 310
100569: NOT
100570: IFFALSE 100617
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100572: CALL_OW 45
100576: PPUSH
100577: LD_VAR 0 2
100581: PUSH
100582: LD_INT 1
100584: ARRAY
100585: PPUSH
100586: CALL_OW 250
100590: PPUSH
100591: LD_VAR 0 2
100595: PUSH
100596: LD_INT 1
100598: ARRAY
100599: PPUSH
100600: CALL_OW 251
100604: PPUSH
100605: LD_INT 12
100607: PPUSH
100608: LD_INT 1
100610: PPUSH
100611: CALL_OW 50
100615: GO 100629
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100617: CALL_OW 45
100621: PPUSH
100622: LD_INT 1
100624: PPUSH
100625: CALL_OW 51
// end ;
100629: GO 100503
100631: POP
100632: POP
// end ;
100633: PPOPN 2
100635: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100636: LD_EXP 112
100640: PUSH
100641: LD_EXP 158
100645: AND
100646: IFFALSE 100868
100648: GO 100650
100650: DISABLE
100651: LD_INT 0
100653: PPUSH
100654: PPUSH
100655: PPUSH
100656: PPUSH
100657: PPUSH
100658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100659: LD_ADDR_VAR 0 6
100663: PUSH
100664: LD_INT 22
100666: PUSH
100667: LD_OWVAR 2
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: PUSH
100676: LD_INT 21
100678: PUSH
100679: LD_INT 1
100681: PUSH
100682: EMPTY
100683: LIST
100684: LIST
100685: PUSH
100686: LD_INT 3
100688: PUSH
100689: LD_INT 23
100691: PUSH
100692: LD_INT 0
100694: PUSH
100695: EMPTY
100696: LIST
100697: LIST
100698: PUSH
100699: EMPTY
100700: LIST
100701: LIST
100702: PUSH
100703: EMPTY
100704: LIST
100705: LIST
100706: LIST
100707: PPUSH
100708: CALL_OW 69
100712: ST_TO_ADDR
// if not tmp then
100713: LD_VAR 0 6
100717: NOT
100718: IFFALSE 100722
// exit ;
100720: GO 100868
// s1 := rand ( 1 , 4 ) ;
100722: LD_ADDR_VAR 0 2
100726: PUSH
100727: LD_INT 1
100729: PPUSH
100730: LD_INT 4
100732: PPUSH
100733: CALL_OW 12
100737: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100738: LD_ADDR_VAR 0 4
100742: PUSH
100743: LD_VAR 0 6
100747: PUSH
100748: LD_INT 1
100750: ARRAY
100751: PPUSH
100752: LD_VAR 0 2
100756: PPUSH
100757: CALL_OW 259
100761: ST_TO_ADDR
// if s1 = 1 then
100762: LD_VAR 0 2
100766: PUSH
100767: LD_INT 1
100769: EQUAL
100770: IFFALSE 100790
// s2 := rand ( 2 , 4 ) else
100772: LD_ADDR_VAR 0 3
100776: PUSH
100777: LD_INT 2
100779: PPUSH
100780: LD_INT 4
100782: PPUSH
100783: CALL_OW 12
100787: ST_TO_ADDR
100788: GO 100798
// s2 := 1 ;
100790: LD_ADDR_VAR 0 3
100794: PUSH
100795: LD_INT 1
100797: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100798: LD_ADDR_VAR 0 5
100802: PUSH
100803: LD_VAR 0 6
100807: PUSH
100808: LD_INT 1
100810: ARRAY
100811: PPUSH
100812: LD_VAR 0 3
100816: PPUSH
100817: CALL_OW 259
100821: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100822: LD_VAR 0 6
100826: PUSH
100827: LD_INT 1
100829: ARRAY
100830: PPUSH
100831: LD_VAR 0 2
100835: PPUSH
100836: LD_VAR 0 5
100840: PPUSH
100841: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100845: LD_VAR 0 6
100849: PUSH
100850: LD_INT 1
100852: ARRAY
100853: PPUSH
100854: LD_VAR 0 3
100858: PPUSH
100859: LD_VAR 0 4
100863: PPUSH
100864: CALL_OW 237
// end ;
100868: PPOPN 6
100870: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100871: LD_EXP 112
100875: PUSH
100876: LD_EXP 159
100880: AND
100881: IFFALSE 100960
100883: GO 100885
100885: DISABLE
100886: LD_INT 0
100888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100889: LD_ADDR_VAR 0 1
100893: PUSH
100894: LD_INT 22
100896: PUSH
100897: LD_OWVAR 2
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: PUSH
100906: LD_INT 30
100908: PUSH
100909: LD_INT 3
100911: PUSH
100912: EMPTY
100913: LIST
100914: LIST
100915: PUSH
100916: EMPTY
100917: LIST
100918: LIST
100919: PPUSH
100920: CALL_OW 69
100924: ST_TO_ADDR
// if not tmp then
100925: LD_VAR 0 1
100929: NOT
100930: IFFALSE 100934
// exit ;
100932: GO 100960
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100934: LD_VAR 0 1
100938: PUSH
100939: LD_INT 1
100941: PPUSH
100942: LD_VAR 0 1
100946: PPUSH
100947: CALL_OW 12
100951: ARRAY
100952: PPUSH
100953: LD_INT 1
100955: PPUSH
100956: CALL_OW 234
// end ;
100960: PPOPN 1
100962: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100963: LD_EXP 112
100967: PUSH
100968: LD_EXP 160
100972: AND
100973: IFFALSE 101085
100975: GO 100977
100977: DISABLE
100978: LD_INT 0
100980: PPUSH
100981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100982: LD_ADDR_VAR 0 2
100986: PUSH
100987: LD_INT 22
100989: PUSH
100990: LD_OWVAR 2
100994: PUSH
100995: EMPTY
100996: LIST
100997: LIST
100998: PUSH
100999: LD_INT 2
101001: PUSH
101002: LD_INT 30
101004: PUSH
101005: LD_INT 27
101007: PUSH
101008: EMPTY
101009: LIST
101010: LIST
101011: PUSH
101012: LD_INT 30
101014: PUSH
101015: LD_INT 26
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PUSH
101022: LD_INT 30
101024: PUSH
101025: LD_INT 28
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: LIST
101036: LIST
101037: PUSH
101038: EMPTY
101039: LIST
101040: LIST
101041: PPUSH
101042: CALL_OW 69
101046: ST_TO_ADDR
// if not tmp then
101047: LD_VAR 0 2
101051: NOT
101052: IFFALSE 101056
// exit ;
101054: GO 101085
// for i in tmp do
101056: LD_ADDR_VAR 0 1
101060: PUSH
101061: LD_VAR 0 2
101065: PUSH
101066: FOR_IN
101067: IFFALSE 101083
// SetLives ( i , 1 ) ;
101069: LD_VAR 0 1
101073: PPUSH
101074: LD_INT 1
101076: PPUSH
101077: CALL_OW 234
101081: GO 101066
101083: POP
101084: POP
// end ;
101085: PPOPN 2
101087: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101088: LD_EXP 112
101092: PUSH
101093: LD_EXP 161
101097: AND
101098: IFFALSE 101385
101100: GO 101102
101102: DISABLE
101103: LD_INT 0
101105: PPUSH
101106: PPUSH
101107: PPUSH
// begin i := rand ( 1 , 7 ) ;
101108: LD_ADDR_VAR 0 1
101112: PUSH
101113: LD_INT 1
101115: PPUSH
101116: LD_INT 7
101118: PPUSH
101119: CALL_OW 12
101123: ST_TO_ADDR
// case i of 1 :
101124: LD_VAR 0 1
101128: PUSH
101129: LD_INT 1
101131: DOUBLE
101132: EQUAL
101133: IFTRUE 101137
101135: GO 101147
101137: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101138: LD_STRING earthquake(getX(game), 0, 32)
101140: PPUSH
101141: CALL_OW 559
101145: GO 101385
101147: LD_INT 2
101149: DOUBLE
101150: EQUAL
101151: IFTRUE 101155
101153: GO 101169
101155: POP
// begin ToLua ( displayStucuk(); ) ;
101156: LD_STRING displayStucuk();
101158: PPUSH
101159: CALL_OW 559
// ResetFog ;
101163: CALL_OW 335
// end ; 3 :
101167: GO 101385
101169: LD_INT 3
101171: DOUBLE
101172: EQUAL
101173: IFTRUE 101177
101175: GO 101281
101177: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101178: LD_ADDR_VAR 0 2
101182: PUSH
101183: LD_INT 22
101185: PUSH
101186: LD_OWVAR 2
101190: PUSH
101191: EMPTY
101192: LIST
101193: LIST
101194: PUSH
101195: LD_INT 25
101197: PUSH
101198: LD_INT 1
101200: PUSH
101201: EMPTY
101202: LIST
101203: LIST
101204: PUSH
101205: EMPTY
101206: LIST
101207: LIST
101208: PPUSH
101209: CALL_OW 69
101213: ST_TO_ADDR
// if not tmp then
101214: LD_VAR 0 2
101218: NOT
101219: IFFALSE 101223
// exit ;
101221: GO 101385
// un := tmp [ rand ( 1 , tmp ) ] ;
101223: LD_ADDR_VAR 0 3
101227: PUSH
101228: LD_VAR 0 2
101232: PUSH
101233: LD_INT 1
101235: PPUSH
101236: LD_VAR 0 2
101240: PPUSH
101241: CALL_OW 12
101245: ARRAY
101246: ST_TO_ADDR
// if Crawls ( un ) then
101247: LD_VAR 0 3
101251: PPUSH
101252: CALL_OW 318
101256: IFFALSE 101267
// ComWalk ( un ) ;
101258: LD_VAR 0 3
101262: PPUSH
101263: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101267: LD_VAR 0 3
101271: PPUSH
101272: LD_INT 8
101274: PPUSH
101275: CALL_OW 336
// end ; 4 :
101279: GO 101385
101281: LD_INT 4
101283: DOUBLE
101284: EQUAL
101285: IFTRUE 101289
101287: GO 101363
101289: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101290: LD_ADDR_VAR 0 2
101294: PUSH
101295: LD_INT 22
101297: PUSH
101298: LD_OWVAR 2
101302: PUSH
101303: EMPTY
101304: LIST
101305: LIST
101306: PUSH
101307: LD_INT 30
101309: PUSH
101310: LD_INT 29
101312: PUSH
101313: EMPTY
101314: LIST
101315: LIST
101316: PUSH
101317: EMPTY
101318: LIST
101319: LIST
101320: PPUSH
101321: CALL_OW 69
101325: ST_TO_ADDR
// if not tmp then
101326: LD_VAR 0 2
101330: NOT
101331: IFFALSE 101335
// exit ;
101333: GO 101385
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101335: LD_VAR 0 2
101339: PUSH
101340: LD_INT 1
101342: ARRAY
101343: PPUSH
101344: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101348: LD_VAR 0 2
101352: PUSH
101353: LD_INT 1
101355: ARRAY
101356: PPUSH
101357: CALL_OW 65
// end ; 5 .. 7 :
101361: GO 101385
101363: LD_INT 5
101365: DOUBLE
101366: GREATEREQUAL
101367: IFFALSE 101375
101369: LD_INT 7
101371: DOUBLE
101372: LESSEQUAL
101373: IFTRUE 101377
101375: GO 101384
101377: POP
// StreamSibBomb ; end ;
101378: CALL 97622 0 0
101382: GO 101385
101384: POP
// end ;
101385: PPOPN 3
101387: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101388: LD_EXP 112
101392: PUSH
101393: LD_EXP 162
101397: AND
101398: IFFALSE 101554
101400: GO 101402
101402: DISABLE
101403: LD_INT 0
101405: PPUSH
101406: PPUSH
101407: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101408: LD_ADDR_VAR 0 2
101412: PUSH
101413: LD_INT 81
101415: PUSH
101416: LD_OWVAR 2
101420: PUSH
101421: EMPTY
101422: LIST
101423: LIST
101424: PUSH
101425: LD_INT 2
101427: PUSH
101428: LD_INT 21
101430: PUSH
101431: LD_INT 1
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: LD_INT 21
101440: PUSH
101441: LD_INT 2
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: PUSH
101448: EMPTY
101449: LIST
101450: LIST
101451: LIST
101452: PUSH
101453: EMPTY
101454: LIST
101455: LIST
101456: PPUSH
101457: CALL_OW 69
101461: ST_TO_ADDR
// if not tmp then
101462: LD_VAR 0 2
101466: NOT
101467: IFFALSE 101471
// exit ;
101469: GO 101554
// p := 0 ;
101471: LD_ADDR_VAR 0 3
101475: PUSH
101476: LD_INT 0
101478: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101479: LD_INT 35
101481: PPUSH
101482: CALL_OW 67
// p := p + 1 ;
101486: LD_ADDR_VAR 0 3
101490: PUSH
101491: LD_VAR 0 3
101495: PUSH
101496: LD_INT 1
101498: PLUS
101499: ST_TO_ADDR
// for i in tmp do
101500: LD_ADDR_VAR 0 1
101504: PUSH
101505: LD_VAR 0 2
101509: PUSH
101510: FOR_IN
101511: IFFALSE 101542
// if GetLives ( i ) < 1000 then
101513: LD_VAR 0 1
101517: PPUSH
101518: CALL_OW 256
101522: PUSH
101523: LD_INT 1000
101525: LESS
101526: IFFALSE 101540
// SetLives ( i , 1000 ) ;
101528: LD_VAR 0 1
101532: PPUSH
101533: LD_INT 1000
101535: PPUSH
101536: CALL_OW 234
101540: GO 101510
101542: POP
101543: POP
// until p > 20 ;
101544: LD_VAR 0 3
101548: PUSH
101549: LD_INT 20
101551: GREATER
101552: IFFALSE 101479
// end ;
101554: PPOPN 3
101556: END
// every 0 0$1 trigger StreamModeActive and sTime do
101557: LD_EXP 112
101561: PUSH
101562: LD_EXP 163
101566: AND
101567: IFFALSE 101602
101569: GO 101571
101571: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101572: LD_INT 28
101574: PPUSH
101575: LD_OWVAR 2
101579: PPUSH
101580: LD_INT 2
101582: PPUSH
101583: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101587: LD_INT 30
101589: PPUSH
101590: LD_OWVAR 2
101594: PPUSH
101595: LD_INT 2
101597: PPUSH
101598: CALL_OW 322
// end ;
101602: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101603: LD_EXP 112
101607: PUSH
101608: LD_EXP 164
101612: AND
101613: IFFALSE 101734
101615: GO 101617
101617: DISABLE
101618: LD_INT 0
101620: PPUSH
101621: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101622: LD_ADDR_VAR 0 2
101626: PUSH
101627: LD_INT 22
101629: PUSH
101630: LD_OWVAR 2
101634: PUSH
101635: EMPTY
101636: LIST
101637: LIST
101638: PUSH
101639: LD_INT 21
101641: PUSH
101642: LD_INT 1
101644: PUSH
101645: EMPTY
101646: LIST
101647: LIST
101648: PUSH
101649: LD_INT 3
101651: PUSH
101652: LD_INT 23
101654: PUSH
101655: LD_INT 0
101657: PUSH
101658: EMPTY
101659: LIST
101660: LIST
101661: PUSH
101662: EMPTY
101663: LIST
101664: LIST
101665: PUSH
101666: EMPTY
101667: LIST
101668: LIST
101669: LIST
101670: PPUSH
101671: CALL_OW 69
101675: ST_TO_ADDR
// if not tmp then
101676: LD_VAR 0 2
101680: NOT
101681: IFFALSE 101685
// exit ;
101683: GO 101734
// for i in tmp do
101685: LD_ADDR_VAR 0 1
101689: PUSH
101690: LD_VAR 0 2
101694: PUSH
101695: FOR_IN
101696: IFFALSE 101732
// begin if Crawls ( i ) then
101698: LD_VAR 0 1
101702: PPUSH
101703: CALL_OW 318
101707: IFFALSE 101718
// ComWalk ( i ) ;
101709: LD_VAR 0 1
101713: PPUSH
101714: CALL_OW 138
// SetClass ( i , 2 ) ;
101718: LD_VAR 0 1
101722: PPUSH
101723: LD_INT 2
101725: PPUSH
101726: CALL_OW 336
// end ;
101730: GO 101695
101732: POP
101733: POP
// end ;
101734: PPOPN 2
101736: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101737: LD_EXP 112
101741: PUSH
101742: LD_EXP 165
101746: AND
101747: IFFALSE 102035
101749: GO 101751
101751: DISABLE
101752: LD_INT 0
101754: PPUSH
101755: PPUSH
101756: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101757: LD_OWVAR 2
101761: PPUSH
101762: LD_INT 9
101764: PPUSH
101765: LD_INT 1
101767: PPUSH
101768: LD_INT 1
101770: PPUSH
101771: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101775: LD_INT 9
101777: PPUSH
101778: LD_OWVAR 2
101782: PPUSH
101783: CALL_OW 343
// uc_side := 9 ;
101787: LD_ADDR_OWVAR 20
101791: PUSH
101792: LD_INT 9
101794: ST_TO_ADDR
// uc_nation := 2 ;
101795: LD_ADDR_OWVAR 21
101799: PUSH
101800: LD_INT 2
101802: ST_TO_ADDR
// hc_name := Dark Warrior ;
101803: LD_ADDR_OWVAR 26
101807: PUSH
101808: LD_STRING Dark Warrior
101810: ST_TO_ADDR
// hc_gallery :=  ;
101811: LD_ADDR_OWVAR 33
101815: PUSH
101816: LD_STRING 
101818: ST_TO_ADDR
// hc_noskilllimit := true ;
101819: LD_ADDR_OWVAR 76
101823: PUSH
101824: LD_INT 1
101826: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101827: LD_ADDR_OWVAR 31
101831: PUSH
101832: LD_INT 30
101834: PUSH
101835: LD_INT 30
101837: PUSH
101838: LD_INT 30
101840: PUSH
101841: LD_INT 30
101843: PUSH
101844: EMPTY
101845: LIST
101846: LIST
101847: LIST
101848: LIST
101849: ST_TO_ADDR
// un := CreateHuman ;
101850: LD_ADDR_VAR 0 3
101854: PUSH
101855: CALL_OW 44
101859: ST_TO_ADDR
// hc_noskilllimit := false ;
101860: LD_ADDR_OWVAR 76
101864: PUSH
101865: LD_INT 0
101867: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101868: LD_VAR 0 3
101872: PPUSH
101873: LD_INT 1
101875: PPUSH
101876: CALL_OW 51
// ToLua ( playRanger() ) ;
101880: LD_STRING playRanger()
101882: PPUSH
101883: CALL_OW 559
// p := 0 ;
101887: LD_ADDR_VAR 0 2
101891: PUSH
101892: LD_INT 0
101894: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101895: LD_INT 35
101897: PPUSH
101898: CALL_OW 67
// p := p + 1 ;
101902: LD_ADDR_VAR 0 2
101906: PUSH
101907: LD_VAR 0 2
101911: PUSH
101912: LD_INT 1
101914: PLUS
101915: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101916: LD_VAR 0 3
101920: PPUSH
101921: CALL_OW 256
101925: PUSH
101926: LD_INT 1000
101928: LESS
101929: IFFALSE 101943
// SetLives ( un , 1000 ) ;
101931: LD_VAR 0 3
101935: PPUSH
101936: LD_INT 1000
101938: PPUSH
101939: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101943: LD_VAR 0 3
101947: PPUSH
101948: LD_INT 81
101950: PUSH
101951: LD_OWVAR 2
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: PUSH
101960: LD_INT 91
101962: PUSH
101963: LD_VAR 0 3
101967: PUSH
101968: LD_INT 30
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: LIST
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: PPUSH
101980: CALL_OW 69
101984: PPUSH
101985: LD_VAR 0 3
101989: PPUSH
101990: CALL_OW 74
101994: PPUSH
101995: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
101999: LD_VAR 0 2
102003: PUSH
102004: LD_INT 80
102006: GREATER
102007: PUSH
102008: LD_VAR 0 3
102012: PPUSH
102013: CALL_OW 301
102017: OR
102018: IFFALSE 101895
// if un then
102020: LD_VAR 0 3
102024: IFFALSE 102035
// RemoveUnit ( un ) ;
102026: LD_VAR 0 3
102030: PPUSH
102031: CALL_OW 64
// end ;
102035: PPOPN 3
102037: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102038: LD_EXP 166
102042: IFFALSE 102158
102044: GO 102046
102046: DISABLE
102047: LD_INT 0
102049: PPUSH
102050: PPUSH
102051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102052: LD_ADDR_VAR 0 2
102056: PUSH
102057: LD_INT 81
102059: PUSH
102060: LD_OWVAR 2
102064: PUSH
102065: EMPTY
102066: LIST
102067: LIST
102068: PUSH
102069: LD_INT 21
102071: PUSH
102072: LD_INT 1
102074: PUSH
102075: EMPTY
102076: LIST
102077: LIST
102078: PUSH
102079: EMPTY
102080: LIST
102081: LIST
102082: PPUSH
102083: CALL_OW 69
102087: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102088: LD_STRING playComputer()
102090: PPUSH
102091: CALL_OW 559
// if not tmp then
102095: LD_VAR 0 2
102099: NOT
102100: IFFALSE 102104
// exit ;
102102: GO 102158
// for i in tmp do
102104: LD_ADDR_VAR 0 1
102108: PUSH
102109: LD_VAR 0 2
102113: PUSH
102114: FOR_IN
102115: IFFALSE 102156
// for j := 1 to 4 do
102117: LD_ADDR_VAR 0 3
102121: PUSH
102122: DOUBLE
102123: LD_INT 1
102125: DEC
102126: ST_TO_ADDR
102127: LD_INT 4
102129: PUSH
102130: FOR_TO
102131: IFFALSE 102152
// SetSkill ( i , j , 10 ) ;
102133: LD_VAR 0 1
102137: PPUSH
102138: LD_VAR 0 3
102142: PPUSH
102143: LD_INT 10
102145: PPUSH
102146: CALL_OW 237
102150: GO 102130
102152: POP
102153: POP
102154: GO 102114
102156: POP
102157: POP
// end ;
102158: PPOPN 3
102160: END
// every 0 0$1 trigger s30 do var i , tmp ;
102161: LD_EXP 167
102165: IFFALSE 102234
102167: GO 102169
102169: DISABLE
102170: LD_INT 0
102172: PPUSH
102173: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102174: LD_ADDR_VAR 0 2
102178: PUSH
102179: LD_INT 22
102181: PUSH
102182: LD_OWVAR 2
102186: PUSH
102187: EMPTY
102188: LIST
102189: LIST
102190: PPUSH
102191: CALL_OW 69
102195: ST_TO_ADDR
// if not tmp then
102196: LD_VAR 0 2
102200: NOT
102201: IFFALSE 102205
// exit ;
102203: GO 102234
// for i in tmp do
102205: LD_ADDR_VAR 0 1
102209: PUSH
102210: LD_VAR 0 2
102214: PUSH
102215: FOR_IN
102216: IFFALSE 102232
// SetLives ( i , 300 ) ;
102218: LD_VAR 0 1
102222: PPUSH
102223: LD_INT 300
102225: PPUSH
102226: CALL_OW 234
102230: GO 102215
102232: POP
102233: POP
// end ;
102234: PPOPN 2
102236: END
// every 0 0$1 trigger s60 do var i , tmp ;
102237: LD_EXP 168
102241: IFFALSE 102310
102243: GO 102245
102245: DISABLE
102246: LD_INT 0
102248: PPUSH
102249: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102250: LD_ADDR_VAR 0 2
102254: PUSH
102255: LD_INT 22
102257: PUSH
102258: LD_OWVAR 2
102262: PUSH
102263: EMPTY
102264: LIST
102265: LIST
102266: PPUSH
102267: CALL_OW 69
102271: ST_TO_ADDR
// if not tmp then
102272: LD_VAR 0 2
102276: NOT
102277: IFFALSE 102281
// exit ;
102279: GO 102310
// for i in tmp do
102281: LD_ADDR_VAR 0 1
102285: PUSH
102286: LD_VAR 0 2
102290: PUSH
102291: FOR_IN
102292: IFFALSE 102308
// SetLives ( i , 600 ) ;
102294: LD_VAR 0 1
102298: PPUSH
102299: LD_INT 600
102301: PPUSH
102302: CALL_OW 234
102306: GO 102291
102308: POP
102309: POP
// end ;
102310: PPOPN 2
102312: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102313: LD_INT 0
102315: PPUSH
// case cmd of 301 :
102316: LD_VAR 0 1
102320: PUSH
102321: LD_INT 301
102323: DOUBLE
102324: EQUAL
102325: IFTRUE 102329
102327: GO 102361
102329: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102330: LD_VAR 0 6
102334: PPUSH
102335: LD_VAR 0 7
102339: PPUSH
102340: LD_VAR 0 8
102344: PPUSH
102345: LD_VAR 0 4
102349: PPUSH
102350: LD_VAR 0 5
102354: PPUSH
102355: CALL 103562 0 5
102359: GO 102482
102361: LD_INT 302
102363: DOUBLE
102364: EQUAL
102365: IFTRUE 102369
102367: GO 102406
102369: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102370: LD_VAR 0 6
102374: PPUSH
102375: LD_VAR 0 7
102379: PPUSH
102380: LD_VAR 0 8
102384: PPUSH
102385: LD_VAR 0 9
102389: PPUSH
102390: LD_VAR 0 4
102394: PPUSH
102395: LD_VAR 0 5
102399: PPUSH
102400: CALL 103653 0 6
102404: GO 102482
102406: LD_INT 303
102408: DOUBLE
102409: EQUAL
102410: IFTRUE 102414
102412: GO 102451
102414: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102415: LD_VAR 0 6
102419: PPUSH
102420: LD_VAR 0 7
102424: PPUSH
102425: LD_VAR 0 8
102429: PPUSH
102430: LD_VAR 0 9
102434: PPUSH
102435: LD_VAR 0 4
102439: PPUSH
102440: LD_VAR 0 5
102444: PPUSH
102445: CALL 102487 0 6
102449: GO 102482
102451: LD_INT 304
102453: DOUBLE
102454: EQUAL
102455: IFTRUE 102459
102457: GO 102481
102459: POP
// hHackTeleport ( unit , x , y ) ; end ;
102460: LD_VAR 0 2
102464: PPUSH
102465: LD_VAR 0 4
102469: PPUSH
102470: LD_VAR 0 5
102474: PPUSH
102475: CALL 104246 0 3
102479: GO 102482
102481: POP
// end ;
102482: LD_VAR 0 12
102486: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102487: LD_INT 0
102489: PPUSH
102490: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102491: LD_VAR 0 1
102495: PUSH
102496: LD_INT 1
102498: LESS
102499: PUSH
102500: LD_VAR 0 1
102504: PUSH
102505: LD_INT 3
102507: GREATER
102508: OR
102509: PUSH
102510: LD_VAR 0 5
102514: PPUSH
102515: LD_VAR 0 6
102519: PPUSH
102520: CALL_OW 428
102524: OR
102525: IFFALSE 102529
// exit ;
102527: GO 103249
// uc_side := your_side ;
102529: LD_ADDR_OWVAR 20
102533: PUSH
102534: LD_OWVAR 2
102538: ST_TO_ADDR
// uc_nation := nation ;
102539: LD_ADDR_OWVAR 21
102543: PUSH
102544: LD_VAR 0 1
102548: ST_TO_ADDR
// bc_level = 1 ;
102549: LD_ADDR_OWVAR 43
102553: PUSH
102554: LD_INT 1
102556: ST_TO_ADDR
// case btype of 1 :
102557: LD_VAR 0 2
102561: PUSH
102562: LD_INT 1
102564: DOUBLE
102565: EQUAL
102566: IFTRUE 102570
102568: GO 102581
102570: POP
// bc_type := b_depot ; 2 :
102571: LD_ADDR_OWVAR 42
102575: PUSH
102576: LD_INT 0
102578: ST_TO_ADDR
102579: GO 103193
102581: LD_INT 2
102583: DOUBLE
102584: EQUAL
102585: IFTRUE 102589
102587: GO 102600
102589: POP
// bc_type := b_warehouse ; 3 :
102590: LD_ADDR_OWVAR 42
102594: PUSH
102595: LD_INT 1
102597: ST_TO_ADDR
102598: GO 103193
102600: LD_INT 3
102602: DOUBLE
102603: EQUAL
102604: IFTRUE 102608
102606: GO 102619
102608: POP
// bc_type := b_lab ; 4 .. 9 :
102609: LD_ADDR_OWVAR 42
102613: PUSH
102614: LD_INT 6
102616: ST_TO_ADDR
102617: GO 103193
102619: LD_INT 4
102621: DOUBLE
102622: GREATEREQUAL
102623: IFFALSE 102631
102625: LD_INT 9
102627: DOUBLE
102628: LESSEQUAL
102629: IFTRUE 102633
102631: GO 102685
102633: POP
// begin bc_type := b_lab_half ;
102634: LD_ADDR_OWVAR 42
102638: PUSH
102639: LD_INT 7
102641: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102642: LD_ADDR_OWVAR 44
102646: PUSH
102647: LD_INT 10
102649: PUSH
102650: LD_INT 11
102652: PUSH
102653: LD_INT 12
102655: PUSH
102656: LD_INT 15
102658: PUSH
102659: LD_INT 14
102661: PUSH
102662: LD_INT 13
102664: PUSH
102665: EMPTY
102666: LIST
102667: LIST
102668: LIST
102669: LIST
102670: LIST
102671: LIST
102672: PUSH
102673: LD_VAR 0 2
102677: PUSH
102678: LD_INT 3
102680: MINUS
102681: ARRAY
102682: ST_TO_ADDR
// end ; 10 .. 13 :
102683: GO 103193
102685: LD_INT 10
102687: DOUBLE
102688: GREATEREQUAL
102689: IFFALSE 102697
102691: LD_INT 13
102693: DOUBLE
102694: LESSEQUAL
102695: IFTRUE 102699
102697: GO 102776
102699: POP
// begin bc_type := b_lab_full ;
102700: LD_ADDR_OWVAR 42
102704: PUSH
102705: LD_INT 8
102707: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102708: LD_ADDR_OWVAR 44
102712: PUSH
102713: LD_INT 10
102715: PUSH
102716: LD_INT 12
102718: PUSH
102719: LD_INT 14
102721: PUSH
102722: LD_INT 13
102724: PUSH
102725: EMPTY
102726: LIST
102727: LIST
102728: LIST
102729: LIST
102730: PUSH
102731: LD_VAR 0 2
102735: PUSH
102736: LD_INT 9
102738: MINUS
102739: ARRAY
102740: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102741: LD_ADDR_OWVAR 45
102745: PUSH
102746: LD_INT 11
102748: PUSH
102749: LD_INT 15
102751: PUSH
102752: LD_INT 12
102754: PUSH
102755: LD_INT 15
102757: PUSH
102758: EMPTY
102759: LIST
102760: LIST
102761: LIST
102762: LIST
102763: PUSH
102764: LD_VAR 0 2
102768: PUSH
102769: LD_INT 9
102771: MINUS
102772: ARRAY
102773: ST_TO_ADDR
// end ; 14 :
102774: GO 103193
102776: LD_INT 14
102778: DOUBLE
102779: EQUAL
102780: IFTRUE 102784
102782: GO 102795
102784: POP
// bc_type := b_workshop ; 15 :
102785: LD_ADDR_OWVAR 42
102789: PUSH
102790: LD_INT 2
102792: ST_TO_ADDR
102793: GO 103193
102795: LD_INT 15
102797: DOUBLE
102798: EQUAL
102799: IFTRUE 102803
102801: GO 102814
102803: POP
// bc_type := b_factory ; 16 :
102804: LD_ADDR_OWVAR 42
102808: PUSH
102809: LD_INT 3
102811: ST_TO_ADDR
102812: GO 103193
102814: LD_INT 16
102816: DOUBLE
102817: EQUAL
102818: IFTRUE 102822
102820: GO 102833
102822: POP
// bc_type := b_ext_gun ; 17 :
102823: LD_ADDR_OWVAR 42
102827: PUSH
102828: LD_INT 17
102830: ST_TO_ADDR
102831: GO 103193
102833: LD_INT 17
102835: DOUBLE
102836: EQUAL
102837: IFTRUE 102841
102839: GO 102869
102841: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102842: LD_ADDR_OWVAR 42
102846: PUSH
102847: LD_INT 19
102849: PUSH
102850: LD_INT 23
102852: PUSH
102853: LD_INT 19
102855: PUSH
102856: EMPTY
102857: LIST
102858: LIST
102859: LIST
102860: PUSH
102861: LD_VAR 0 1
102865: ARRAY
102866: ST_TO_ADDR
102867: GO 103193
102869: LD_INT 18
102871: DOUBLE
102872: EQUAL
102873: IFTRUE 102877
102875: GO 102888
102877: POP
// bc_type := b_ext_radar ; 19 :
102878: LD_ADDR_OWVAR 42
102882: PUSH
102883: LD_INT 20
102885: ST_TO_ADDR
102886: GO 103193
102888: LD_INT 19
102890: DOUBLE
102891: EQUAL
102892: IFTRUE 102896
102894: GO 102907
102896: POP
// bc_type := b_ext_radio ; 20 :
102897: LD_ADDR_OWVAR 42
102901: PUSH
102902: LD_INT 22
102904: ST_TO_ADDR
102905: GO 103193
102907: LD_INT 20
102909: DOUBLE
102910: EQUAL
102911: IFTRUE 102915
102913: GO 102926
102915: POP
// bc_type := b_ext_siberium ; 21 :
102916: LD_ADDR_OWVAR 42
102920: PUSH
102921: LD_INT 21
102923: ST_TO_ADDR
102924: GO 103193
102926: LD_INT 21
102928: DOUBLE
102929: EQUAL
102930: IFTRUE 102934
102932: GO 102945
102934: POP
// bc_type := b_ext_computer ; 22 :
102935: LD_ADDR_OWVAR 42
102939: PUSH
102940: LD_INT 24
102942: ST_TO_ADDR
102943: GO 103193
102945: LD_INT 22
102947: DOUBLE
102948: EQUAL
102949: IFTRUE 102953
102951: GO 102964
102953: POP
// bc_type := b_ext_track ; 23 :
102954: LD_ADDR_OWVAR 42
102958: PUSH
102959: LD_INT 16
102961: ST_TO_ADDR
102962: GO 103193
102964: LD_INT 23
102966: DOUBLE
102967: EQUAL
102968: IFTRUE 102972
102970: GO 102983
102972: POP
// bc_type := b_ext_laser ; 24 :
102973: LD_ADDR_OWVAR 42
102977: PUSH
102978: LD_INT 25
102980: ST_TO_ADDR
102981: GO 103193
102983: LD_INT 24
102985: DOUBLE
102986: EQUAL
102987: IFTRUE 102991
102989: GO 103002
102991: POP
// bc_type := b_control_tower ; 25 :
102992: LD_ADDR_OWVAR 42
102996: PUSH
102997: LD_INT 36
102999: ST_TO_ADDR
103000: GO 103193
103002: LD_INT 25
103004: DOUBLE
103005: EQUAL
103006: IFTRUE 103010
103008: GO 103021
103010: POP
// bc_type := b_breastwork ; 26 :
103011: LD_ADDR_OWVAR 42
103015: PUSH
103016: LD_INT 31
103018: ST_TO_ADDR
103019: GO 103193
103021: LD_INT 26
103023: DOUBLE
103024: EQUAL
103025: IFTRUE 103029
103027: GO 103040
103029: POP
// bc_type := b_bunker ; 27 :
103030: LD_ADDR_OWVAR 42
103034: PUSH
103035: LD_INT 32
103037: ST_TO_ADDR
103038: GO 103193
103040: LD_INT 27
103042: DOUBLE
103043: EQUAL
103044: IFTRUE 103048
103046: GO 103059
103048: POP
// bc_type := b_turret ; 28 :
103049: LD_ADDR_OWVAR 42
103053: PUSH
103054: LD_INT 33
103056: ST_TO_ADDR
103057: GO 103193
103059: LD_INT 28
103061: DOUBLE
103062: EQUAL
103063: IFTRUE 103067
103065: GO 103078
103067: POP
// bc_type := b_armoury ; 29 :
103068: LD_ADDR_OWVAR 42
103072: PUSH
103073: LD_INT 4
103075: ST_TO_ADDR
103076: GO 103193
103078: LD_INT 29
103080: DOUBLE
103081: EQUAL
103082: IFTRUE 103086
103084: GO 103097
103086: POP
// bc_type := b_barracks ; 30 :
103087: LD_ADDR_OWVAR 42
103091: PUSH
103092: LD_INT 5
103094: ST_TO_ADDR
103095: GO 103193
103097: LD_INT 30
103099: DOUBLE
103100: EQUAL
103101: IFTRUE 103105
103103: GO 103116
103105: POP
// bc_type := b_solar_power ; 31 :
103106: LD_ADDR_OWVAR 42
103110: PUSH
103111: LD_INT 27
103113: ST_TO_ADDR
103114: GO 103193
103116: LD_INT 31
103118: DOUBLE
103119: EQUAL
103120: IFTRUE 103124
103122: GO 103135
103124: POP
// bc_type := b_oil_power ; 32 :
103125: LD_ADDR_OWVAR 42
103129: PUSH
103130: LD_INT 26
103132: ST_TO_ADDR
103133: GO 103193
103135: LD_INT 32
103137: DOUBLE
103138: EQUAL
103139: IFTRUE 103143
103141: GO 103154
103143: POP
// bc_type := b_siberite_power ; 33 :
103144: LD_ADDR_OWVAR 42
103148: PUSH
103149: LD_INT 28
103151: ST_TO_ADDR
103152: GO 103193
103154: LD_INT 33
103156: DOUBLE
103157: EQUAL
103158: IFTRUE 103162
103160: GO 103173
103162: POP
// bc_type := b_oil_mine ; 34 :
103163: LD_ADDR_OWVAR 42
103167: PUSH
103168: LD_INT 29
103170: ST_TO_ADDR
103171: GO 103193
103173: LD_INT 34
103175: DOUBLE
103176: EQUAL
103177: IFTRUE 103181
103179: GO 103192
103181: POP
// bc_type := b_siberite_mine ; end ;
103182: LD_ADDR_OWVAR 42
103186: PUSH
103187: LD_INT 30
103189: ST_TO_ADDR
103190: GO 103193
103192: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103193: LD_ADDR_VAR 0 8
103197: PUSH
103198: LD_VAR 0 5
103202: PPUSH
103203: LD_VAR 0 6
103207: PPUSH
103208: LD_VAR 0 3
103212: PPUSH
103213: CALL_OW 47
103217: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103218: LD_OWVAR 42
103222: PUSH
103223: LD_INT 32
103225: PUSH
103226: LD_INT 33
103228: PUSH
103229: EMPTY
103230: LIST
103231: LIST
103232: IN
103233: IFFALSE 103249
// PlaceWeaponTurret ( b , weapon ) ;
103235: LD_VAR 0 8
103239: PPUSH
103240: LD_VAR 0 4
103244: PPUSH
103245: CALL_OW 431
// end ;
103249: LD_VAR 0 7
103253: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103254: LD_INT 0
103256: PPUSH
103257: PPUSH
103258: PPUSH
103259: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103260: LD_ADDR_VAR 0 4
103264: PUSH
103265: LD_INT 22
103267: PUSH
103268: LD_OWVAR 2
103272: PUSH
103273: EMPTY
103274: LIST
103275: LIST
103276: PUSH
103277: LD_INT 2
103279: PUSH
103280: LD_INT 30
103282: PUSH
103283: LD_INT 0
103285: PUSH
103286: EMPTY
103287: LIST
103288: LIST
103289: PUSH
103290: LD_INT 30
103292: PUSH
103293: LD_INT 1
103295: PUSH
103296: EMPTY
103297: LIST
103298: LIST
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: LIST
103304: PUSH
103305: EMPTY
103306: LIST
103307: LIST
103308: PPUSH
103309: CALL_OW 69
103313: ST_TO_ADDR
// if not tmp then
103314: LD_VAR 0 4
103318: NOT
103319: IFFALSE 103323
// exit ;
103321: GO 103382
// for i in tmp do
103323: LD_ADDR_VAR 0 2
103327: PUSH
103328: LD_VAR 0 4
103332: PUSH
103333: FOR_IN
103334: IFFALSE 103380
// for j = 1 to 3 do
103336: LD_ADDR_VAR 0 3
103340: PUSH
103341: DOUBLE
103342: LD_INT 1
103344: DEC
103345: ST_TO_ADDR
103346: LD_INT 3
103348: PUSH
103349: FOR_TO
103350: IFFALSE 103376
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103352: LD_VAR 0 2
103356: PPUSH
103357: CALL_OW 274
103361: PPUSH
103362: LD_VAR 0 3
103366: PPUSH
103367: LD_INT 99999
103369: PPUSH
103370: CALL_OW 277
103374: GO 103349
103376: POP
103377: POP
103378: GO 103333
103380: POP
103381: POP
// end ;
103382: LD_VAR 0 1
103386: RET
// export function hHackSetLevel10 ; var i , j ; begin
103387: LD_INT 0
103389: PPUSH
103390: PPUSH
103391: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103392: LD_ADDR_VAR 0 2
103396: PUSH
103397: LD_INT 21
103399: PUSH
103400: LD_INT 1
103402: PUSH
103403: EMPTY
103404: LIST
103405: LIST
103406: PPUSH
103407: CALL_OW 69
103411: PUSH
103412: FOR_IN
103413: IFFALSE 103465
// if IsSelected ( i ) then
103415: LD_VAR 0 2
103419: PPUSH
103420: CALL_OW 306
103424: IFFALSE 103463
// begin for j := 1 to 4 do
103426: LD_ADDR_VAR 0 3
103430: PUSH
103431: DOUBLE
103432: LD_INT 1
103434: DEC
103435: ST_TO_ADDR
103436: LD_INT 4
103438: PUSH
103439: FOR_TO
103440: IFFALSE 103461
// SetSkill ( i , j , 10 ) ;
103442: LD_VAR 0 2
103446: PPUSH
103447: LD_VAR 0 3
103451: PPUSH
103452: LD_INT 10
103454: PPUSH
103455: CALL_OW 237
103459: GO 103439
103461: POP
103462: POP
// end ;
103463: GO 103412
103465: POP
103466: POP
// end ;
103467: LD_VAR 0 1
103471: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103472: LD_INT 0
103474: PPUSH
103475: PPUSH
103476: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103477: LD_ADDR_VAR 0 2
103481: PUSH
103482: LD_INT 22
103484: PUSH
103485: LD_OWVAR 2
103489: PUSH
103490: EMPTY
103491: LIST
103492: LIST
103493: PUSH
103494: LD_INT 21
103496: PUSH
103497: LD_INT 1
103499: PUSH
103500: EMPTY
103501: LIST
103502: LIST
103503: PUSH
103504: EMPTY
103505: LIST
103506: LIST
103507: PPUSH
103508: CALL_OW 69
103512: PUSH
103513: FOR_IN
103514: IFFALSE 103555
// begin for j := 1 to 4 do
103516: LD_ADDR_VAR 0 3
103520: PUSH
103521: DOUBLE
103522: LD_INT 1
103524: DEC
103525: ST_TO_ADDR
103526: LD_INT 4
103528: PUSH
103529: FOR_TO
103530: IFFALSE 103551
// SetSkill ( i , j , 10 ) ;
103532: LD_VAR 0 2
103536: PPUSH
103537: LD_VAR 0 3
103541: PPUSH
103542: LD_INT 10
103544: PPUSH
103545: CALL_OW 237
103549: GO 103529
103551: POP
103552: POP
// end ;
103553: GO 103513
103555: POP
103556: POP
// end ;
103557: LD_VAR 0 1
103561: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103562: LD_INT 0
103564: PPUSH
// uc_side := your_side ;
103565: LD_ADDR_OWVAR 20
103569: PUSH
103570: LD_OWVAR 2
103574: ST_TO_ADDR
// uc_nation := nation ;
103575: LD_ADDR_OWVAR 21
103579: PUSH
103580: LD_VAR 0 1
103584: ST_TO_ADDR
// InitHc ;
103585: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103589: LD_INT 0
103591: PPUSH
103592: LD_VAR 0 2
103596: PPUSH
103597: LD_VAR 0 3
103601: PPUSH
103602: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103606: LD_VAR 0 4
103610: PPUSH
103611: LD_VAR 0 5
103615: PPUSH
103616: CALL_OW 428
103620: PUSH
103621: LD_INT 0
103623: EQUAL
103624: IFFALSE 103648
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103626: CALL_OW 44
103630: PPUSH
103631: LD_VAR 0 4
103635: PPUSH
103636: LD_VAR 0 5
103640: PPUSH
103641: LD_INT 1
103643: PPUSH
103644: CALL_OW 48
// end ;
103648: LD_VAR 0 6
103652: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103653: LD_INT 0
103655: PPUSH
103656: PPUSH
// uc_side := your_side ;
103657: LD_ADDR_OWVAR 20
103661: PUSH
103662: LD_OWVAR 2
103666: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103667: LD_VAR 0 1
103671: PUSH
103672: LD_INT 1
103674: PUSH
103675: LD_INT 2
103677: PUSH
103678: LD_INT 3
103680: PUSH
103681: LD_INT 4
103683: PUSH
103684: LD_INT 5
103686: PUSH
103687: EMPTY
103688: LIST
103689: LIST
103690: LIST
103691: LIST
103692: LIST
103693: IN
103694: IFFALSE 103706
// uc_nation := nation_american else
103696: LD_ADDR_OWVAR 21
103700: PUSH
103701: LD_INT 1
103703: ST_TO_ADDR
103704: GO 103749
// if chassis in [ 11 , 12 , 13 , 14 ] then
103706: LD_VAR 0 1
103710: PUSH
103711: LD_INT 11
103713: PUSH
103714: LD_INT 12
103716: PUSH
103717: LD_INT 13
103719: PUSH
103720: LD_INT 14
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: LIST
103727: LIST
103728: IN
103729: IFFALSE 103741
// uc_nation := nation_arabian else
103731: LD_ADDR_OWVAR 21
103735: PUSH
103736: LD_INT 2
103738: ST_TO_ADDR
103739: GO 103749
// uc_nation := nation_russian ;
103741: LD_ADDR_OWVAR 21
103745: PUSH
103746: LD_INT 3
103748: ST_TO_ADDR
// vc_chassis := chassis ;
103749: LD_ADDR_OWVAR 37
103753: PUSH
103754: LD_VAR 0 1
103758: ST_TO_ADDR
// vc_engine := engine ;
103759: LD_ADDR_OWVAR 39
103763: PUSH
103764: LD_VAR 0 2
103768: ST_TO_ADDR
// vc_control := control ;
103769: LD_ADDR_OWVAR 38
103773: PUSH
103774: LD_VAR 0 3
103778: ST_TO_ADDR
// vc_weapon := weapon ;
103779: LD_ADDR_OWVAR 40
103783: PUSH
103784: LD_VAR 0 4
103788: ST_TO_ADDR
// un := CreateVehicle ;
103789: LD_ADDR_VAR 0 8
103793: PUSH
103794: CALL_OW 45
103798: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103799: LD_VAR 0 8
103803: PPUSH
103804: LD_INT 0
103806: PPUSH
103807: LD_INT 5
103809: PPUSH
103810: CALL_OW 12
103814: PPUSH
103815: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103819: LD_VAR 0 8
103823: PPUSH
103824: LD_VAR 0 5
103828: PPUSH
103829: LD_VAR 0 6
103833: PPUSH
103834: LD_INT 1
103836: PPUSH
103837: CALL_OW 48
// end ;
103841: LD_VAR 0 7
103845: RET
// export hInvincible ; every 1 do
103846: GO 103848
103848: DISABLE
// hInvincible := [ ] ;
103849: LD_ADDR_EXP 169
103853: PUSH
103854: EMPTY
103855: ST_TO_ADDR
103856: END
// every 10 do var i ;
103857: GO 103859
103859: DISABLE
103860: LD_INT 0
103862: PPUSH
// begin enable ;
103863: ENABLE
// if not hInvincible then
103864: LD_EXP 169
103868: NOT
103869: IFFALSE 103873
// exit ;
103871: GO 103917
// for i in hInvincible do
103873: LD_ADDR_VAR 0 1
103877: PUSH
103878: LD_EXP 169
103882: PUSH
103883: FOR_IN
103884: IFFALSE 103915
// if GetLives ( i ) < 1000 then
103886: LD_VAR 0 1
103890: PPUSH
103891: CALL_OW 256
103895: PUSH
103896: LD_INT 1000
103898: LESS
103899: IFFALSE 103913
// SetLives ( i , 1000 ) ;
103901: LD_VAR 0 1
103905: PPUSH
103906: LD_INT 1000
103908: PPUSH
103909: CALL_OW 234
103913: GO 103883
103915: POP
103916: POP
// end ;
103917: PPOPN 1
103919: END
// export function hHackInvincible ; var i ; begin
103920: LD_INT 0
103922: PPUSH
103923: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103924: LD_ADDR_VAR 0 2
103928: PUSH
103929: LD_INT 2
103931: PUSH
103932: LD_INT 21
103934: PUSH
103935: LD_INT 1
103937: PUSH
103938: EMPTY
103939: LIST
103940: LIST
103941: PUSH
103942: LD_INT 21
103944: PUSH
103945: LD_INT 2
103947: PUSH
103948: EMPTY
103949: LIST
103950: LIST
103951: PUSH
103952: EMPTY
103953: LIST
103954: LIST
103955: LIST
103956: PPUSH
103957: CALL_OW 69
103961: PUSH
103962: FOR_IN
103963: IFFALSE 104024
// if IsSelected ( i ) then
103965: LD_VAR 0 2
103969: PPUSH
103970: CALL_OW 306
103974: IFFALSE 104022
// begin if i in hInvincible then
103976: LD_VAR 0 2
103980: PUSH
103981: LD_EXP 169
103985: IN
103986: IFFALSE 104006
// hInvincible := hInvincible diff i else
103988: LD_ADDR_EXP 169
103992: PUSH
103993: LD_EXP 169
103997: PUSH
103998: LD_VAR 0 2
104002: DIFF
104003: ST_TO_ADDR
104004: GO 104022
// hInvincible := hInvincible union i ;
104006: LD_ADDR_EXP 169
104010: PUSH
104011: LD_EXP 169
104015: PUSH
104016: LD_VAR 0 2
104020: UNION
104021: ST_TO_ADDR
// end ;
104022: GO 103962
104024: POP
104025: POP
// end ;
104026: LD_VAR 0 1
104030: RET
// export function hHackInvisible ; var i , j ; begin
104031: LD_INT 0
104033: PPUSH
104034: PPUSH
104035: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104036: LD_ADDR_VAR 0 2
104040: PUSH
104041: LD_INT 21
104043: PUSH
104044: LD_INT 1
104046: PUSH
104047: EMPTY
104048: LIST
104049: LIST
104050: PPUSH
104051: CALL_OW 69
104055: PUSH
104056: FOR_IN
104057: IFFALSE 104081
// if IsSelected ( i ) then
104059: LD_VAR 0 2
104063: PPUSH
104064: CALL_OW 306
104068: IFFALSE 104079
// ComForceInvisible ( i ) ;
104070: LD_VAR 0 2
104074: PPUSH
104075: CALL_OW 496
104079: GO 104056
104081: POP
104082: POP
// end ;
104083: LD_VAR 0 1
104087: RET
// export function hHackChangeYourSide ; begin
104088: LD_INT 0
104090: PPUSH
// if your_side = 8 then
104091: LD_OWVAR 2
104095: PUSH
104096: LD_INT 8
104098: EQUAL
104099: IFFALSE 104111
// your_side := 0 else
104101: LD_ADDR_OWVAR 2
104105: PUSH
104106: LD_INT 0
104108: ST_TO_ADDR
104109: GO 104125
// your_side := your_side + 1 ;
104111: LD_ADDR_OWVAR 2
104115: PUSH
104116: LD_OWVAR 2
104120: PUSH
104121: LD_INT 1
104123: PLUS
104124: ST_TO_ADDR
// end ;
104125: LD_VAR 0 1
104129: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104130: LD_INT 0
104132: PPUSH
104133: PPUSH
104134: PPUSH
// for i in all_units do
104135: LD_ADDR_VAR 0 2
104139: PUSH
104140: LD_OWVAR 3
104144: PUSH
104145: FOR_IN
104146: IFFALSE 104224
// if IsSelected ( i ) then
104148: LD_VAR 0 2
104152: PPUSH
104153: CALL_OW 306
104157: IFFALSE 104222
// begin j := GetSide ( i ) ;
104159: LD_ADDR_VAR 0 3
104163: PUSH
104164: LD_VAR 0 2
104168: PPUSH
104169: CALL_OW 255
104173: ST_TO_ADDR
// if j = 8 then
104174: LD_VAR 0 3
104178: PUSH
104179: LD_INT 8
104181: EQUAL
104182: IFFALSE 104194
// j := 0 else
104184: LD_ADDR_VAR 0 3
104188: PUSH
104189: LD_INT 0
104191: ST_TO_ADDR
104192: GO 104208
// j := j + 1 ;
104194: LD_ADDR_VAR 0 3
104198: PUSH
104199: LD_VAR 0 3
104203: PUSH
104204: LD_INT 1
104206: PLUS
104207: ST_TO_ADDR
// SetSide ( i , j ) ;
104208: LD_VAR 0 2
104212: PPUSH
104213: LD_VAR 0 3
104217: PPUSH
104218: CALL_OW 235
// end ;
104222: GO 104145
104224: POP
104225: POP
// end ;
104226: LD_VAR 0 1
104230: RET
// export function hHackFog ; begin
104231: LD_INT 0
104233: PPUSH
// FogOff ( true ) ;
104234: LD_INT 1
104236: PPUSH
104237: CALL_OW 344
// end ;
104241: LD_VAR 0 1
104245: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104246: LD_INT 0
104248: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104249: LD_VAR 0 1
104253: PPUSH
104254: LD_VAR 0 2
104258: PPUSH
104259: LD_VAR 0 3
104263: PPUSH
104264: LD_INT 1
104266: PPUSH
104267: LD_INT 1
104269: PPUSH
104270: CALL_OW 483
// CenterOnXY ( x , y ) ;
104274: LD_VAR 0 2
104278: PPUSH
104279: LD_VAR 0 3
104283: PPUSH
104284: CALL_OW 84
// end ;
104288: LD_VAR 0 4
104292: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104293: LD_INT 0
104295: PPUSH
104296: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104297: LD_VAR 0 1
104301: NOT
104302: PUSH
104303: LD_VAR 0 2
104307: PPUSH
104308: LD_VAR 0 3
104312: PPUSH
104313: CALL_OW 488
104317: NOT
104318: OR
104319: PUSH
104320: LD_VAR 0 1
104324: PPUSH
104325: CALL_OW 266
104329: PUSH
104330: LD_INT 3
104332: NONEQUAL
104333: PUSH
104334: LD_VAR 0 1
104338: PPUSH
104339: CALL_OW 247
104343: PUSH
104344: LD_INT 1
104346: EQUAL
104347: NOT
104348: AND
104349: OR
104350: IFFALSE 104354
// exit ;
104352: GO 104503
// if GetType ( factory ) = unit_human then
104354: LD_VAR 0 1
104358: PPUSH
104359: CALL_OW 247
104363: PUSH
104364: LD_INT 1
104366: EQUAL
104367: IFFALSE 104384
// factory := IsInUnit ( factory ) ;
104369: LD_ADDR_VAR 0 1
104373: PUSH
104374: LD_VAR 0 1
104378: PPUSH
104379: CALL_OW 310
104383: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104384: LD_VAR 0 1
104388: PPUSH
104389: CALL_OW 266
104393: PUSH
104394: LD_INT 3
104396: NONEQUAL
104397: IFFALSE 104401
// exit ;
104399: GO 104503
// if HexInfo ( x , y ) = factory then
104401: LD_VAR 0 2
104405: PPUSH
104406: LD_VAR 0 3
104410: PPUSH
104411: CALL_OW 428
104415: PUSH
104416: LD_VAR 0 1
104420: EQUAL
104421: IFFALSE 104448
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104423: LD_ADDR_EXP 170
104427: PUSH
104428: LD_EXP 170
104432: PPUSH
104433: LD_VAR 0 1
104437: PPUSH
104438: LD_INT 0
104440: PPUSH
104441: CALL_OW 1
104445: ST_TO_ADDR
104446: GO 104499
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104448: LD_ADDR_EXP 170
104452: PUSH
104453: LD_EXP 170
104457: PPUSH
104458: LD_VAR 0 1
104462: PPUSH
104463: LD_VAR 0 1
104467: PPUSH
104468: CALL_OW 255
104472: PUSH
104473: LD_VAR 0 1
104477: PUSH
104478: LD_VAR 0 2
104482: PUSH
104483: LD_VAR 0 3
104487: PUSH
104488: EMPTY
104489: LIST
104490: LIST
104491: LIST
104492: LIST
104493: PPUSH
104494: CALL_OW 1
104498: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104499: CALL 104508 0 0
// end ;
104503: LD_VAR 0 4
104507: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104508: LD_INT 0
104510: PPUSH
104511: PPUSH
104512: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104513: LD_STRING resetFactoryWaypoint();
104515: PPUSH
104516: CALL_OW 559
// if factoryWaypoints then
104520: LD_EXP 170
104524: IFFALSE 104650
// begin list := PrepareArray ( factoryWaypoints ) ;
104526: LD_ADDR_VAR 0 3
104530: PUSH
104531: LD_EXP 170
104535: PPUSH
104536: CALL 89744 0 1
104540: ST_TO_ADDR
// for i := 1 to list do
104541: LD_ADDR_VAR 0 2
104545: PUSH
104546: DOUBLE
104547: LD_INT 1
104549: DEC
104550: ST_TO_ADDR
104551: LD_VAR 0 3
104555: PUSH
104556: FOR_TO
104557: IFFALSE 104648
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104559: LD_STRING setFactoryWaypointXY(
104561: PUSH
104562: LD_VAR 0 3
104566: PUSH
104567: LD_VAR 0 2
104571: ARRAY
104572: PUSH
104573: LD_INT 1
104575: ARRAY
104576: STR
104577: PUSH
104578: LD_STRING ,
104580: STR
104581: PUSH
104582: LD_VAR 0 3
104586: PUSH
104587: LD_VAR 0 2
104591: ARRAY
104592: PUSH
104593: LD_INT 2
104595: ARRAY
104596: STR
104597: PUSH
104598: LD_STRING ,
104600: STR
104601: PUSH
104602: LD_VAR 0 3
104606: PUSH
104607: LD_VAR 0 2
104611: ARRAY
104612: PUSH
104613: LD_INT 3
104615: ARRAY
104616: STR
104617: PUSH
104618: LD_STRING ,
104620: STR
104621: PUSH
104622: LD_VAR 0 3
104626: PUSH
104627: LD_VAR 0 2
104631: ARRAY
104632: PUSH
104633: LD_INT 4
104635: ARRAY
104636: STR
104637: PUSH
104638: LD_STRING )
104640: STR
104641: PPUSH
104642: CALL_OW 559
104646: GO 104556
104648: POP
104649: POP
// end ; end ;
104650: LD_VAR 0 1
104654: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104655: LD_INT 0
104657: PPUSH
// if HexInfo ( x , y ) = warehouse then
104658: LD_VAR 0 2
104662: PPUSH
104663: LD_VAR 0 3
104667: PPUSH
104668: CALL_OW 428
104672: PUSH
104673: LD_VAR 0 1
104677: EQUAL
104678: IFFALSE 104705
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104680: LD_ADDR_EXP 171
104684: PUSH
104685: LD_EXP 171
104689: PPUSH
104690: LD_VAR 0 1
104694: PPUSH
104695: LD_INT 0
104697: PPUSH
104698: CALL_OW 1
104702: ST_TO_ADDR
104703: GO 104756
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104705: LD_ADDR_EXP 171
104709: PUSH
104710: LD_EXP 171
104714: PPUSH
104715: LD_VAR 0 1
104719: PPUSH
104720: LD_VAR 0 1
104724: PPUSH
104725: CALL_OW 255
104729: PUSH
104730: LD_VAR 0 1
104734: PUSH
104735: LD_VAR 0 2
104739: PUSH
104740: LD_VAR 0 3
104744: PUSH
104745: EMPTY
104746: LIST
104747: LIST
104748: LIST
104749: LIST
104750: PPUSH
104751: CALL_OW 1
104755: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104756: CALL 104765 0 0
// end ;
104760: LD_VAR 0 4
104764: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104765: LD_INT 0
104767: PPUSH
104768: PPUSH
104769: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104770: LD_STRING resetWarehouseGatheringPoints();
104772: PPUSH
104773: CALL_OW 559
// if warehouseGatheringPoints then
104777: LD_EXP 171
104781: IFFALSE 104907
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104783: LD_ADDR_VAR 0 3
104787: PUSH
104788: LD_EXP 171
104792: PPUSH
104793: CALL 89744 0 1
104797: ST_TO_ADDR
// for i := 1 to list do
104798: LD_ADDR_VAR 0 2
104802: PUSH
104803: DOUBLE
104804: LD_INT 1
104806: DEC
104807: ST_TO_ADDR
104808: LD_VAR 0 3
104812: PUSH
104813: FOR_TO
104814: IFFALSE 104905
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104816: LD_STRING setWarehouseGatheringPointXY(
104818: PUSH
104819: LD_VAR 0 3
104823: PUSH
104824: LD_VAR 0 2
104828: ARRAY
104829: PUSH
104830: LD_INT 1
104832: ARRAY
104833: STR
104834: PUSH
104835: LD_STRING ,
104837: STR
104838: PUSH
104839: LD_VAR 0 3
104843: PUSH
104844: LD_VAR 0 2
104848: ARRAY
104849: PUSH
104850: LD_INT 2
104852: ARRAY
104853: STR
104854: PUSH
104855: LD_STRING ,
104857: STR
104858: PUSH
104859: LD_VAR 0 3
104863: PUSH
104864: LD_VAR 0 2
104868: ARRAY
104869: PUSH
104870: LD_INT 3
104872: ARRAY
104873: STR
104874: PUSH
104875: LD_STRING ,
104877: STR
104878: PUSH
104879: LD_VAR 0 3
104883: PUSH
104884: LD_VAR 0 2
104888: ARRAY
104889: PUSH
104890: LD_INT 4
104892: ARRAY
104893: STR
104894: PUSH
104895: LD_STRING )
104897: STR
104898: PPUSH
104899: CALL_OW 559
104903: GO 104813
104905: POP
104906: POP
// end ; end ;
104907: LD_VAR 0 1
104911: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
104912: LD_EXP 171
104916: IFFALSE 105603
104918: GO 104920
104920: DISABLE
104921: LD_INT 0
104923: PPUSH
104924: PPUSH
104925: PPUSH
104926: PPUSH
104927: PPUSH
104928: PPUSH
104929: PPUSH
104930: PPUSH
104931: PPUSH
// begin enable ;
104932: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
104933: LD_ADDR_VAR 0 3
104937: PUSH
104938: LD_EXP 171
104942: PPUSH
104943: CALL 89744 0 1
104947: ST_TO_ADDR
// if not list then
104948: LD_VAR 0 3
104952: NOT
104953: IFFALSE 104957
// exit ;
104955: GO 105603
// for i := 1 to list do
104957: LD_ADDR_VAR 0 1
104961: PUSH
104962: DOUBLE
104963: LD_INT 1
104965: DEC
104966: ST_TO_ADDR
104967: LD_VAR 0 3
104971: PUSH
104972: FOR_TO
104973: IFFALSE 105601
// begin depot := list [ i ] [ 2 ] ;
104975: LD_ADDR_VAR 0 8
104979: PUSH
104980: LD_VAR 0 3
104984: PUSH
104985: LD_VAR 0 1
104989: ARRAY
104990: PUSH
104991: LD_INT 2
104993: ARRAY
104994: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
104995: LD_ADDR_VAR 0 5
104999: PUSH
105000: LD_VAR 0 3
105004: PUSH
105005: LD_VAR 0 1
105009: ARRAY
105010: PUSH
105011: LD_INT 1
105013: ARRAY
105014: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105015: LD_VAR 0 8
105019: PPUSH
105020: CALL_OW 301
105024: PUSH
105025: LD_VAR 0 5
105029: PUSH
105030: LD_VAR 0 8
105034: PPUSH
105035: CALL_OW 255
105039: NONEQUAL
105040: OR
105041: IFFALSE 105070
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105043: LD_ADDR_EXP 171
105047: PUSH
105048: LD_EXP 171
105052: PPUSH
105053: LD_VAR 0 8
105057: PPUSH
105058: LD_INT 0
105060: PPUSH
105061: CALL_OW 1
105065: ST_TO_ADDR
// exit ;
105066: POP
105067: POP
105068: GO 105603
// end ; x := list [ i ] [ 3 ] ;
105070: LD_ADDR_VAR 0 6
105074: PUSH
105075: LD_VAR 0 3
105079: PUSH
105080: LD_VAR 0 1
105084: ARRAY
105085: PUSH
105086: LD_INT 3
105088: ARRAY
105089: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105090: LD_ADDR_VAR 0 7
105094: PUSH
105095: LD_VAR 0 3
105099: PUSH
105100: LD_VAR 0 1
105104: ARRAY
105105: PUSH
105106: LD_INT 4
105108: ARRAY
105109: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105110: LD_ADDR_VAR 0 9
105114: PUSH
105115: LD_VAR 0 6
105119: PPUSH
105120: LD_VAR 0 7
105124: PPUSH
105125: LD_INT 16
105127: PPUSH
105128: CALL 88328 0 3
105132: ST_TO_ADDR
// if not cratesNearbyPoint then
105133: LD_VAR 0 9
105137: NOT
105138: IFFALSE 105144
// exit ;
105140: POP
105141: POP
105142: GO 105603
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105144: LD_ADDR_VAR 0 4
105148: PUSH
105149: LD_INT 22
105151: PUSH
105152: LD_VAR 0 5
105156: PUSH
105157: EMPTY
105158: LIST
105159: LIST
105160: PUSH
105161: LD_INT 3
105163: PUSH
105164: LD_INT 60
105166: PUSH
105167: EMPTY
105168: LIST
105169: PUSH
105170: EMPTY
105171: LIST
105172: LIST
105173: PUSH
105174: LD_INT 91
105176: PUSH
105177: LD_VAR 0 8
105181: PUSH
105182: LD_INT 6
105184: PUSH
105185: EMPTY
105186: LIST
105187: LIST
105188: LIST
105189: PUSH
105190: LD_INT 2
105192: PUSH
105193: LD_INT 25
105195: PUSH
105196: LD_INT 2
105198: PUSH
105199: EMPTY
105200: LIST
105201: LIST
105202: PUSH
105203: LD_INT 25
105205: PUSH
105206: LD_INT 16
105208: PUSH
105209: EMPTY
105210: LIST
105211: LIST
105212: PUSH
105213: EMPTY
105214: LIST
105215: LIST
105216: LIST
105217: PUSH
105218: EMPTY
105219: LIST
105220: LIST
105221: LIST
105222: LIST
105223: PPUSH
105224: CALL_OW 69
105228: PUSH
105229: LD_VAR 0 8
105233: PPUSH
105234: CALL_OW 313
105238: PPUSH
105239: LD_INT 3
105241: PUSH
105242: LD_INT 60
105244: PUSH
105245: EMPTY
105246: LIST
105247: PUSH
105248: EMPTY
105249: LIST
105250: LIST
105251: PUSH
105252: LD_INT 2
105254: PUSH
105255: LD_INT 25
105257: PUSH
105258: LD_INT 2
105260: PUSH
105261: EMPTY
105262: LIST
105263: LIST
105264: PUSH
105265: LD_INT 25
105267: PUSH
105268: LD_INT 16
105270: PUSH
105271: EMPTY
105272: LIST
105273: LIST
105274: PUSH
105275: EMPTY
105276: LIST
105277: LIST
105278: LIST
105279: PUSH
105280: EMPTY
105281: LIST
105282: LIST
105283: PPUSH
105284: CALL_OW 72
105288: UNION
105289: ST_TO_ADDR
// if tmp then
105290: LD_VAR 0 4
105294: IFFALSE 105374
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105296: LD_ADDR_VAR 0 4
105300: PUSH
105301: LD_VAR 0 4
105305: PPUSH
105306: LD_INT 3
105308: PPUSH
105309: CALL 86295 0 2
105313: ST_TO_ADDR
// for j in tmp do
105314: LD_ADDR_VAR 0 2
105318: PUSH
105319: LD_VAR 0 4
105323: PUSH
105324: FOR_IN
105325: IFFALSE 105368
// begin if IsInUnit ( j ) then
105327: LD_VAR 0 2
105331: PPUSH
105332: CALL_OW 310
105336: IFFALSE 105347
// ComExit ( j ) ;
105338: LD_VAR 0 2
105342: PPUSH
105343: CALL 86378 0 1
// AddComCollect ( j , x , y ) ;
105347: LD_VAR 0 2
105351: PPUSH
105352: LD_VAR 0 6
105356: PPUSH
105357: LD_VAR 0 7
105361: PPUSH
105362: CALL_OW 177
// end ;
105366: GO 105324
105368: POP
105369: POP
// exit ;
105370: POP
105371: POP
105372: GO 105603
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105374: LD_ADDR_VAR 0 4
105378: PUSH
105379: LD_INT 22
105381: PUSH
105382: LD_VAR 0 5
105386: PUSH
105387: EMPTY
105388: LIST
105389: LIST
105390: PUSH
105391: LD_INT 91
105393: PUSH
105394: LD_VAR 0 8
105398: PUSH
105399: LD_INT 8
105401: PUSH
105402: EMPTY
105403: LIST
105404: LIST
105405: LIST
105406: PUSH
105407: LD_INT 2
105409: PUSH
105410: LD_INT 34
105412: PUSH
105413: LD_INT 12
105415: PUSH
105416: EMPTY
105417: LIST
105418: LIST
105419: PUSH
105420: LD_INT 34
105422: PUSH
105423: LD_INT 51
105425: PUSH
105426: EMPTY
105427: LIST
105428: LIST
105429: PUSH
105430: LD_INT 34
105432: PUSH
105433: LD_INT 32
105435: PUSH
105436: EMPTY
105437: LIST
105438: LIST
105439: PUSH
105440: LD_INT 34
105442: PUSH
105443: LD_EXP 95
105447: PUSH
105448: EMPTY
105449: LIST
105450: LIST
105451: PUSH
105452: EMPTY
105453: LIST
105454: LIST
105455: LIST
105456: LIST
105457: LIST
105458: PUSH
105459: EMPTY
105460: LIST
105461: LIST
105462: LIST
105463: PPUSH
105464: CALL_OW 69
105468: ST_TO_ADDR
// if tmp then
105469: LD_VAR 0 4
105473: IFFALSE 105599
// begin for j in tmp do
105475: LD_ADDR_VAR 0 2
105479: PUSH
105480: LD_VAR 0 4
105484: PUSH
105485: FOR_IN
105486: IFFALSE 105597
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105488: LD_VAR 0 2
105492: PPUSH
105493: CALL_OW 262
105497: PUSH
105498: LD_INT 3
105500: EQUAL
105501: PUSH
105502: LD_VAR 0 2
105506: PPUSH
105507: CALL_OW 261
105511: PUSH
105512: LD_INT 20
105514: GREATER
105515: OR
105516: PUSH
105517: LD_VAR 0 2
105521: PPUSH
105522: CALL_OW 314
105526: NOT
105527: AND
105528: PUSH
105529: LD_VAR 0 2
105533: PPUSH
105534: CALL_OW 263
105538: PUSH
105539: LD_INT 1
105541: NONEQUAL
105542: PUSH
105543: LD_VAR 0 2
105547: PPUSH
105548: CALL_OW 311
105552: OR
105553: AND
105554: IFFALSE 105595
// begin ComCollect ( j , x , y ) ;
105556: LD_VAR 0 2
105560: PPUSH
105561: LD_VAR 0 6
105565: PPUSH
105566: LD_VAR 0 7
105570: PPUSH
105571: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105575: LD_VAR 0 2
105579: PPUSH
105580: LD_VAR 0 8
105584: PPUSH
105585: CALL_OW 172
// exit ;
105589: POP
105590: POP
105591: POP
105592: POP
105593: GO 105603
// end ;
105595: GO 105485
105597: POP
105598: POP
// end ; end ;
105599: GO 104972
105601: POP
105602: POP
// end ; end_of_file
105603: PPOPN 9
105605: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105606: LD_INT 0
105608: PPUSH
105609: PPUSH
105610: PPUSH
105611: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105612: LD_VAR 0 1
105616: PPUSH
105617: CALL_OW 264
105621: PUSH
105622: LD_EXP 98
105626: EQUAL
105627: IFFALSE 105699
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105629: LD_INT 68
105631: PPUSH
105632: LD_VAR 0 1
105636: PPUSH
105637: CALL_OW 255
105641: PPUSH
105642: CALL_OW 321
105646: PUSH
105647: LD_INT 2
105649: EQUAL
105650: IFFALSE 105662
// eff := 70 else
105652: LD_ADDR_VAR 0 4
105656: PUSH
105657: LD_INT 70
105659: ST_TO_ADDR
105660: GO 105670
// eff := 30 ;
105662: LD_ADDR_VAR 0 4
105666: PUSH
105667: LD_INT 30
105669: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105670: LD_VAR 0 1
105674: PPUSH
105675: CALL_OW 250
105679: PPUSH
105680: LD_VAR 0 1
105684: PPUSH
105685: CALL_OW 251
105689: PPUSH
105690: LD_VAR 0 4
105694: PPUSH
105695: CALL_OW 495
// end ; end ;
105699: LD_VAR 0 2
105703: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105704: LD_INT 0
105706: PPUSH
// end ;
105707: LD_VAR 0 4
105711: RET
// export function SOS_Command ( cmd ) ; begin
105712: LD_INT 0
105714: PPUSH
// end ;
105715: LD_VAR 0 2
105719: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105720: LD_INT 0
105722: PPUSH
// end ;
105723: LD_VAR 0 6
105727: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105728: LD_INT 0
105730: PPUSH
105731: PPUSH
// if not vehicle or not factory then
105732: LD_VAR 0 1
105736: NOT
105737: PUSH
105738: LD_VAR 0 2
105742: NOT
105743: OR
105744: IFFALSE 105748
// exit ;
105746: GO 105979
// if factoryWaypoints >= factory then
105748: LD_EXP 170
105752: PUSH
105753: LD_VAR 0 2
105757: GREATEREQUAL
105758: IFFALSE 105979
// if factoryWaypoints [ factory ] then
105760: LD_EXP 170
105764: PUSH
105765: LD_VAR 0 2
105769: ARRAY
105770: IFFALSE 105979
// begin if GetControl ( vehicle ) = control_manual then
105772: LD_VAR 0 1
105776: PPUSH
105777: CALL_OW 263
105781: PUSH
105782: LD_INT 1
105784: EQUAL
105785: IFFALSE 105866
// begin driver := IsDrivenBy ( vehicle ) ;
105787: LD_ADDR_VAR 0 4
105791: PUSH
105792: LD_VAR 0 1
105796: PPUSH
105797: CALL_OW 311
105801: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105802: LD_VAR 0 4
105806: PPUSH
105807: LD_EXP 170
105811: PUSH
105812: LD_VAR 0 2
105816: ARRAY
105817: PUSH
105818: LD_INT 3
105820: ARRAY
105821: PPUSH
105822: LD_EXP 170
105826: PUSH
105827: LD_VAR 0 2
105831: ARRAY
105832: PUSH
105833: LD_INT 4
105835: ARRAY
105836: PPUSH
105837: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105841: LD_VAR 0 4
105845: PPUSH
105846: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105850: LD_VAR 0 4
105854: PPUSH
105855: LD_VAR 0 2
105859: PPUSH
105860: CALL_OW 180
// end else
105864: GO 105979
// if GetControl ( vehicle ) = control_remote then
105866: LD_VAR 0 1
105870: PPUSH
105871: CALL_OW 263
105875: PUSH
105876: LD_INT 2
105878: EQUAL
105879: IFFALSE 105940
// begin wait ( 0 0$2 ) ;
105881: LD_INT 70
105883: PPUSH
105884: CALL_OW 67
// if Connect ( vehicle ) then
105888: LD_VAR 0 1
105892: PPUSH
105893: CALL 56689 0 1
105897: IFFALSE 105938
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105899: LD_VAR 0 1
105903: PPUSH
105904: LD_EXP 170
105908: PUSH
105909: LD_VAR 0 2
105913: ARRAY
105914: PUSH
105915: LD_INT 3
105917: ARRAY
105918: PPUSH
105919: LD_EXP 170
105923: PUSH
105924: LD_VAR 0 2
105928: ARRAY
105929: PUSH
105930: LD_INT 4
105932: ARRAY
105933: PPUSH
105934: CALL_OW 171
// end else
105938: GO 105979
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105940: LD_VAR 0 1
105944: PPUSH
105945: LD_EXP 170
105949: PUSH
105950: LD_VAR 0 2
105954: ARRAY
105955: PUSH
105956: LD_INT 3
105958: ARRAY
105959: PPUSH
105960: LD_EXP 170
105964: PUSH
105965: LD_VAR 0 2
105969: ARRAY
105970: PUSH
105971: LD_INT 4
105973: ARRAY
105974: PPUSH
105975: CALL_OW 171
// end ; end ;
105979: LD_VAR 0 3
105983: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105984: LD_INT 0
105986: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105987: LD_VAR 0 1
105991: PUSH
105992: LD_INT 250
105994: EQUAL
105995: PUSH
105996: LD_VAR 0 2
106000: PPUSH
106001: CALL_OW 264
106005: PUSH
106006: LD_EXP 101
106010: EQUAL
106011: AND
106012: IFFALSE 106033
// MinerPlaceMine ( unit , x , y ) ;
106014: LD_VAR 0 2
106018: PPUSH
106019: LD_VAR 0 4
106023: PPUSH
106024: LD_VAR 0 5
106028: PPUSH
106029: CALL 108432 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106033: LD_VAR 0 1
106037: PUSH
106038: LD_INT 251
106040: EQUAL
106041: PUSH
106042: LD_VAR 0 2
106046: PPUSH
106047: CALL_OW 264
106051: PUSH
106052: LD_EXP 101
106056: EQUAL
106057: AND
106058: IFFALSE 106079
// MinerDetonateMine ( unit , x , y ) ;
106060: LD_VAR 0 2
106064: PPUSH
106065: LD_VAR 0 4
106069: PPUSH
106070: LD_VAR 0 5
106074: PPUSH
106075: CALL 108709 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106079: LD_VAR 0 1
106083: PUSH
106084: LD_INT 252
106086: EQUAL
106087: PUSH
106088: LD_VAR 0 2
106092: PPUSH
106093: CALL_OW 264
106097: PUSH
106098: LD_EXP 101
106102: EQUAL
106103: AND
106104: IFFALSE 106125
// MinerCreateMinefield ( unit , x , y ) ;
106106: LD_VAR 0 2
106110: PPUSH
106111: LD_VAR 0 4
106115: PPUSH
106116: LD_VAR 0 5
106120: PPUSH
106121: CALL 109126 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106125: LD_VAR 0 1
106129: PUSH
106130: LD_INT 253
106132: EQUAL
106133: PUSH
106134: LD_VAR 0 2
106138: PPUSH
106139: CALL_OW 257
106143: PUSH
106144: LD_INT 5
106146: EQUAL
106147: AND
106148: IFFALSE 106169
// ComBinocular ( unit , x , y ) ;
106150: LD_VAR 0 2
106154: PPUSH
106155: LD_VAR 0 4
106159: PPUSH
106160: LD_VAR 0 5
106164: PPUSH
106165: CALL 109497 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106169: LD_VAR 0 1
106173: PUSH
106174: LD_INT 254
106176: EQUAL
106177: PUSH
106178: LD_VAR 0 2
106182: PPUSH
106183: CALL_OW 264
106187: PUSH
106188: LD_EXP 96
106192: EQUAL
106193: AND
106194: PUSH
106195: LD_VAR 0 3
106199: PPUSH
106200: CALL_OW 263
106204: PUSH
106205: LD_INT 3
106207: EQUAL
106208: AND
106209: IFFALSE 106225
// HackDestroyVehicle ( unit , selectedUnit ) ;
106211: LD_VAR 0 2
106215: PPUSH
106216: LD_VAR 0 3
106220: PPUSH
106221: CALL 107792 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106225: LD_VAR 0 1
106229: PUSH
106230: LD_INT 255
106232: EQUAL
106233: PUSH
106234: LD_VAR 0 2
106238: PPUSH
106239: CALL_OW 264
106243: PUSH
106244: LD_INT 14
106246: PUSH
106247: LD_INT 53
106249: PUSH
106250: EMPTY
106251: LIST
106252: LIST
106253: IN
106254: AND
106255: PUSH
106256: LD_VAR 0 4
106260: PPUSH
106261: LD_VAR 0 5
106265: PPUSH
106266: CALL_OW 488
106270: AND
106271: IFFALSE 106295
// CutTreeXYR ( unit , x , y , 12 ) ;
106273: LD_VAR 0 2
106277: PPUSH
106278: LD_VAR 0 4
106282: PPUSH
106283: LD_VAR 0 5
106287: PPUSH
106288: LD_INT 12
106290: PPUSH
106291: CALL 106358 0 4
// if cmd = 256 then
106295: LD_VAR 0 1
106299: PUSH
106300: LD_INT 256
106302: EQUAL
106303: IFFALSE 106324
// SetFactoryWaypoint ( unit , x , y ) ;
106305: LD_VAR 0 2
106309: PPUSH
106310: LD_VAR 0 4
106314: PPUSH
106315: LD_VAR 0 5
106319: PPUSH
106320: CALL 104293 0 3
// if cmd = 257 then
106324: LD_VAR 0 1
106328: PUSH
106329: LD_INT 257
106331: EQUAL
106332: IFFALSE 106353
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106334: LD_VAR 0 2
106338: PPUSH
106339: LD_VAR 0 4
106343: PPUSH
106344: LD_VAR 0 5
106348: PPUSH
106349: CALL 104655 0 3
// end ;
106353: LD_VAR 0 6
106357: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106358: LD_INT 0
106360: PPUSH
106361: PPUSH
106362: PPUSH
106363: PPUSH
106364: PPUSH
106365: PPUSH
106366: PPUSH
106367: PPUSH
106368: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106369: LD_VAR 0 1
106373: NOT
106374: PUSH
106375: LD_VAR 0 2
106379: PPUSH
106380: LD_VAR 0 3
106384: PPUSH
106385: CALL_OW 488
106389: NOT
106390: OR
106391: PUSH
106392: LD_VAR 0 4
106396: NOT
106397: OR
106398: IFFALSE 106402
// exit ;
106400: GO 106742
// list := [ ] ;
106402: LD_ADDR_VAR 0 13
106406: PUSH
106407: EMPTY
106408: ST_TO_ADDR
// if x - r < 0 then
106409: LD_VAR 0 2
106413: PUSH
106414: LD_VAR 0 4
106418: MINUS
106419: PUSH
106420: LD_INT 0
106422: LESS
106423: IFFALSE 106435
// min_x := 0 else
106425: LD_ADDR_VAR 0 7
106429: PUSH
106430: LD_INT 0
106432: ST_TO_ADDR
106433: GO 106451
// min_x := x - r ;
106435: LD_ADDR_VAR 0 7
106439: PUSH
106440: LD_VAR 0 2
106444: PUSH
106445: LD_VAR 0 4
106449: MINUS
106450: ST_TO_ADDR
// if y - r < 0 then
106451: LD_VAR 0 3
106455: PUSH
106456: LD_VAR 0 4
106460: MINUS
106461: PUSH
106462: LD_INT 0
106464: LESS
106465: IFFALSE 106477
// min_y := 0 else
106467: LD_ADDR_VAR 0 8
106471: PUSH
106472: LD_INT 0
106474: ST_TO_ADDR
106475: GO 106493
// min_y := y - r ;
106477: LD_ADDR_VAR 0 8
106481: PUSH
106482: LD_VAR 0 3
106486: PUSH
106487: LD_VAR 0 4
106491: MINUS
106492: ST_TO_ADDR
// max_x := x + r ;
106493: LD_ADDR_VAR 0 9
106497: PUSH
106498: LD_VAR 0 2
106502: PUSH
106503: LD_VAR 0 4
106507: PLUS
106508: ST_TO_ADDR
// max_y := y + r ;
106509: LD_ADDR_VAR 0 10
106513: PUSH
106514: LD_VAR 0 3
106518: PUSH
106519: LD_VAR 0 4
106523: PLUS
106524: ST_TO_ADDR
// for _x = min_x to max_x do
106525: LD_ADDR_VAR 0 11
106529: PUSH
106530: DOUBLE
106531: LD_VAR 0 7
106535: DEC
106536: ST_TO_ADDR
106537: LD_VAR 0 9
106541: PUSH
106542: FOR_TO
106543: IFFALSE 106660
// for _y = min_y to max_y do
106545: LD_ADDR_VAR 0 12
106549: PUSH
106550: DOUBLE
106551: LD_VAR 0 8
106555: DEC
106556: ST_TO_ADDR
106557: LD_VAR 0 10
106561: PUSH
106562: FOR_TO
106563: IFFALSE 106656
// begin if not ValidHex ( _x , _y ) then
106565: LD_VAR 0 11
106569: PPUSH
106570: LD_VAR 0 12
106574: PPUSH
106575: CALL_OW 488
106579: NOT
106580: IFFALSE 106584
// continue ;
106582: GO 106562
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106584: LD_VAR 0 11
106588: PPUSH
106589: LD_VAR 0 12
106593: PPUSH
106594: CALL_OW 351
106598: PUSH
106599: LD_VAR 0 11
106603: PPUSH
106604: LD_VAR 0 12
106608: PPUSH
106609: CALL_OW 554
106613: AND
106614: IFFALSE 106654
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106616: LD_ADDR_VAR 0 13
106620: PUSH
106621: LD_VAR 0 13
106625: PPUSH
106626: LD_VAR 0 13
106630: PUSH
106631: LD_INT 1
106633: PLUS
106634: PPUSH
106635: LD_VAR 0 11
106639: PUSH
106640: LD_VAR 0 12
106644: PUSH
106645: EMPTY
106646: LIST
106647: LIST
106648: PPUSH
106649: CALL_OW 2
106653: ST_TO_ADDR
// end ;
106654: GO 106562
106656: POP
106657: POP
106658: GO 106542
106660: POP
106661: POP
// if not list then
106662: LD_VAR 0 13
106666: NOT
106667: IFFALSE 106671
// exit ;
106669: GO 106742
// for i in list do
106671: LD_ADDR_VAR 0 6
106675: PUSH
106676: LD_VAR 0 13
106680: PUSH
106681: FOR_IN
106682: IFFALSE 106740
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106684: LD_VAR 0 1
106688: PPUSH
106689: LD_STRING M
106691: PUSH
106692: LD_VAR 0 6
106696: PUSH
106697: LD_INT 1
106699: ARRAY
106700: PUSH
106701: LD_VAR 0 6
106705: PUSH
106706: LD_INT 2
106708: ARRAY
106709: PUSH
106710: LD_INT 0
106712: PUSH
106713: LD_INT 0
106715: PUSH
106716: LD_INT 0
106718: PUSH
106719: LD_INT 0
106721: PUSH
106722: EMPTY
106723: LIST
106724: LIST
106725: LIST
106726: LIST
106727: LIST
106728: LIST
106729: LIST
106730: PUSH
106731: EMPTY
106732: LIST
106733: PPUSH
106734: CALL_OW 447
106738: GO 106681
106740: POP
106741: POP
// end ;
106742: LD_VAR 0 5
106746: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106747: LD_EXP 173
106751: NOT
106752: IFFALSE 106802
106754: GO 106756
106756: DISABLE
// begin initHack := true ;
106757: LD_ADDR_EXP 173
106761: PUSH
106762: LD_INT 1
106764: ST_TO_ADDR
// hackTanks := [ ] ;
106765: LD_ADDR_EXP 174
106769: PUSH
106770: EMPTY
106771: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106772: LD_ADDR_EXP 175
106776: PUSH
106777: EMPTY
106778: ST_TO_ADDR
// hackLimit := 3 ;
106779: LD_ADDR_EXP 176
106783: PUSH
106784: LD_INT 3
106786: ST_TO_ADDR
// hackDist := 12 ;
106787: LD_ADDR_EXP 177
106791: PUSH
106792: LD_INT 12
106794: ST_TO_ADDR
// hackCounter := [ ] ;
106795: LD_ADDR_EXP 178
106799: PUSH
106800: EMPTY
106801: ST_TO_ADDR
// end ;
106802: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106803: LD_EXP 173
106807: PUSH
106808: LD_INT 34
106810: PUSH
106811: LD_EXP 96
106815: PUSH
106816: EMPTY
106817: LIST
106818: LIST
106819: PPUSH
106820: CALL_OW 69
106824: AND
106825: IFFALSE 107080
106827: GO 106829
106829: DISABLE
106830: LD_INT 0
106832: PPUSH
106833: PPUSH
// begin enable ;
106834: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106835: LD_ADDR_VAR 0 1
106839: PUSH
106840: LD_INT 34
106842: PUSH
106843: LD_EXP 96
106847: PUSH
106848: EMPTY
106849: LIST
106850: LIST
106851: PPUSH
106852: CALL_OW 69
106856: PUSH
106857: FOR_IN
106858: IFFALSE 107078
// begin if not i in hackTanks then
106860: LD_VAR 0 1
106864: PUSH
106865: LD_EXP 174
106869: IN
106870: NOT
106871: IFFALSE 106954
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106873: LD_ADDR_EXP 174
106877: PUSH
106878: LD_EXP 174
106882: PPUSH
106883: LD_EXP 174
106887: PUSH
106888: LD_INT 1
106890: PLUS
106891: PPUSH
106892: LD_VAR 0 1
106896: PPUSH
106897: CALL_OW 1
106901: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106902: LD_ADDR_EXP 175
106906: PUSH
106907: LD_EXP 175
106911: PPUSH
106912: LD_EXP 175
106916: PUSH
106917: LD_INT 1
106919: PLUS
106920: PPUSH
106921: EMPTY
106922: PPUSH
106923: CALL_OW 1
106927: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106928: LD_ADDR_EXP 178
106932: PUSH
106933: LD_EXP 178
106937: PPUSH
106938: LD_EXP 178
106942: PUSH
106943: LD_INT 1
106945: PLUS
106946: PPUSH
106947: EMPTY
106948: PPUSH
106949: CALL_OW 1
106953: ST_TO_ADDR
// end ; if not IsOk ( i ) then
106954: LD_VAR 0 1
106958: PPUSH
106959: CALL_OW 302
106963: NOT
106964: IFFALSE 106977
// begin HackUnlinkAll ( i ) ;
106966: LD_VAR 0 1
106970: PPUSH
106971: CALL 107083 0 1
// continue ;
106975: GO 106857
// end ; HackCheckCapturedStatus ( i ) ;
106977: LD_VAR 0 1
106981: PPUSH
106982: CALL 107526 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
106986: LD_ADDR_VAR 0 2
106990: PUSH
106991: LD_INT 81
106993: PUSH
106994: LD_VAR 0 1
106998: PPUSH
106999: CALL_OW 255
107003: PUSH
107004: EMPTY
107005: LIST
107006: LIST
107007: PUSH
107008: LD_INT 33
107010: PUSH
107011: LD_INT 3
107013: PUSH
107014: EMPTY
107015: LIST
107016: LIST
107017: PUSH
107018: LD_INT 91
107020: PUSH
107021: LD_VAR 0 1
107025: PUSH
107026: LD_EXP 177
107030: PUSH
107031: EMPTY
107032: LIST
107033: LIST
107034: LIST
107035: PUSH
107036: LD_INT 50
107038: PUSH
107039: EMPTY
107040: LIST
107041: PUSH
107042: EMPTY
107043: LIST
107044: LIST
107045: LIST
107046: LIST
107047: PPUSH
107048: CALL_OW 69
107052: ST_TO_ADDR
// if not tmp then
107053: LD_VAR 0 2
107057: NOT
107058: IFFALSE 107062
// continue ;
107060: GO 106857
// HackLink ( i , tmp ) ;
107062: LD_VAR 0 1
107066: PPUSH
107067: LD_VAR 0 2
107071: PPUSH
107072: CALL 107219 0 2
// end ;
107076: GO 106857
107078: POP
107079: POP
// end ;
107080: PPOPN 2
107082: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107083: LD_INT 0
107085: PPUSH
107086: PPUSH
107087: PPUSH
// if not hack in hackTanks then
107088: LD_VAR 0 1
107092: PUSH
107093: LD_EXP 174
107097: IN
107098: NOT
107099: IFFALSE 107103
// exit ;
107101: GO 107214
// index := GetElementIndex ( hackTanks , hack ) ;
107103: LD_ADDR_VAR 0 4
107107: PUSH
107108: LD_EXP 174
107112: PPUSH
107113: LD_VAR 0 1
107117: PPUSH
107118: CALL 53503 0 2
107122: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107123: LD_EXP 175
107127: PUSH
107128: LD_VAR 0 4
107132: ARRAY
107133: IFFALSE 107214
// begin for i in hackTanksCaptured [ index ] do
107135: LD_ADDR_VAR 0 3
107139: PUSH
107140: LD_EXP 175
107144: PUSH
107145: LD_VAR 0 4
107149: ARRAY
107150: PUSH
107151: FOR_IN
107152: IFFALSE 107178
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107154: LD_VAR 0 3
107158: PUSH
107159: LD_INT 1
107161: ARRAY
107162: PPUSH
107163: LD_VAR 0 3
107167: PUSH
107168: LD_INT 2
107170: ARRAY
107171: PPUSH
107172: CALL_OW 235
107176: GO 107151
107178: POP
107179: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107180: LD_ADDR_EXP 175
107184: PUSH
107185: LD_EXP 175
107189: PPUSH
107190: LD_VAR 0 4
107194: PPUSH
107195: EMPTY
107196: PPUSH
107197: CALL_OW 1
107201: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107202: LD_VAR 0 1
107206: PPUSH
107207: LD_INT 0
107209: PPUSH
107210: CALL_OW 505
// end ; end ;
107214: LD_VAR 0 2
107218: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107219: LD_INT 0
107221: PPUSH
107222: PPUSH
107223: PPUSH
// if not hack in hackTanks or not vehicles then
107224: LD_VAR 0 1
107228: PUSH
107229: LD_EXP 174
107233: IN
107234: NOT
107235: PUSH
107236: LD_VAR 0 2
107240: NOT
107241: OR
107242: IFFALSE 107246
// exit ;
107244: GO 107521
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107246: LD_ADDR_VAR 0 2
107250: PUSH
107251: LD_VAR 0 1
107255: PPUSH
107256: LD_VAR 0 2
107260: PPUSH
107261: LD_INT 1
107263: PPUSH
107264: LD_INT 1
107266: PPUSH
107267: CALL 54153 0 4
107271: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107272: LD_ADDR_VAR 0 5
107276: PUSH
107277: LD_EXP 174
107281: PPUSH
107282: LD_VAR 0 1
107286: PPUSH
107287: CALL 53503 0 2
107291: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107292: LD_EXP 175
107296: PUSH
107297: LD_VAR 0 5
107301: ARRAY
107302: PUSH
107303: LD_EXP 176
107307: LESS
107308: IFFALSE 107497
// begin for i := 1 to vehicles do
107310: LD_ADDR_VAR 0 4
107314: PUSH
107315: DOUBLE
107316: LD_INT 1
107318: DEC
107319: ST_TO_ADDR
107320: LD_VAR 0 2
107324: PUSH
107325: FOR_TO
107326: IFFALSE 107495
// begin if hackTanksCaptured [ index ] = hackLimit then
107328: LD_EXP 175
107332: PUSH
107333: LD_VAR 0 5
107337: ARRAY
107338: PUSH
107339: LD_EXP 176
107343: EQUAL
107344: IFFALSE 107348
// break ;
107346: GO 107495
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107348: LD_ADDR_EXP 178
107352: PUSH
107353: LD_EXP 178
107357: PPUSH
107358: LD_VAR 0 5
107362: PPUSH
107363: LD_EXP 178
107367: PUSH
107368: LD_VAR 0 5
107372: ARRAY
107373: PUSH
107374: LD_INT 1
107376: PLUS
107377: PPUSH
107378: CALL_OW 1
107382: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107383: LD_ADDR_EXP 175
107387: PUSH
107388: LD_EXP 175
107392: PPUSH
107393: LD_VAR 0 5
107397: PUSH
107398: LD_EXP 175
107402: PUSH
107403: LD_VAR 0 5
107407: ARRAY
107408: PUSH
107409: LD_INT 1
107411: PLUS
107412: PUSH
107413: EMPTY
107414: LIST
107415: LIST
107416: PPUSH
107417: LD_VAR 0 2
107421: PUSH
107422: LD_VAR 0 4
107426: ARRAY
107427: PUSH
107428: LD_VAR 0 2
107432: PUSH
107433: LD_VAR 0 4
107437: ARRAY
107438: PPUSH
107439: CALL_OW 255
107443: PUSH
107444: EMPTY
107445: LIST
107446: LIST
107447: PPUSH
107448: CALL 53718 0 3
107452: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107453: LD_VAR 0 2
107457: PUSH
107458: LD_VAR 0 4
107462: ARRAY
107463: PPUSH
107464: LD_VAR 0 1
107468: PPUSH
107469: CALL_OW 255
107473: PPUSH
107474: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107478: LD_VAR 0 2
107482: PUSH
107483: LD_VAR 0 4
107487: ARRAY
107488: PPUSH
107489: CALL_OW 141
// end ;
107493: GO 107325
107495: POP
107496: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107497: LD_VAR 0 1
107501: PPUSH
107502: LD_EXP 175
107506: PUSH
107507: LD_VAR 0 5
107511: ARRAY
107512: PUSH
107513: LD_INT 0
107515: PLUS
107516: PPUSH
107517: CALL_OW 505
// end ;
107521: LD_VAR 0 3
107525: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107526: LD_INT 0
107528: PPUSH
107529: PPUSH
107530: PPUSH
107531: PPUSH
// if not hack in hackTanks then
107532: LD_VAR 0 1
107536: PUSH
107537: LD_EXP 174
107541: IN
107542: NOT
107543: IFFALSE 107547
// exit ;
107545: GO 107787
// index := GetElementIndex ( hackTanks , hack ) ;
107547: LD_ADDR_VAR 0 4
107551: PUSH
107552: LD_EXP 174
107556: PPUSH
107557: LD_VAR 0 1
107561: PPUSH
107562: CALL 53503 0 2
107566: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107567: LD_ADDR_VAR 0 3
107571: PUSH
107572: DOUBLE
107573: LD_EXP 175
107577: PUSH
107578: LD_VAR 0 4
107582: ARRAY
107583: INC
107584: ST_TO_ADDR
107585: LD_INT 1
107587: PUSH
107588: FOR_DOWNTO
107589: IFFALSE 107761
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107591: LD_ADDR_VAR 0 5
107595: PUSH
107596: LD_EXP 175
107600: PUSH
107601: LD_VAR 0 4
107605: ARRAY
107606: PUSH
107607: LD_VAR 0 3
107611: ARRAY
107612: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107613: LD_VAR 0 5
107617: PUSH
107618: LD_INT 1
107620: ARRAY
107621: PPUSH
107622: CALL_OW 302
107626: NOT
107627: PUSH
107628: LD_VAR 0 5
107632: PUSH
107633: LD_INT 1
107635: ARRAY
107636: PPUSH
107637: CALL_OW 255
107641: PUSH
107642: LD_VAR 0 1
107646: PPUSH
107647: CALL_OW 255
107651: NONEQUAL
107652: OR
107653: IFFALSE 107759
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107655: LD_VAR 0 5
107659: PUSH
107660: LD_INT 1
107662: ARRAY
107663: PPUSH
107664: CALL_OW 305
107668: PUSH
107669: LD_VAR 0 5
107673: PUSH
107674: LD_INT 1
107676: ARRAY
107677: PPUSH
107678: CALL_OW 255
107682: PUSH
107683: LD_VAR 0 1
107687: PPUSH
107688: CALL_OW 255
107692: EQUAL
107693: AND
107694: IFFALSE 107718
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107696: LD_VAR 0 5
107700: PUSH
107701: LD_INT 1
107703: ARRAY
107704: PPUSH
107705: LD_VAR 0 5
107709: PUSH
107710: LD_INT 2
107712: ARRAY
107713: PPUSH
107714: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107718: LD_ADDR_EXP 175
107722: PUSH
107723: LD_EXP 175
107727: PPUSH
107728: LD_VAR 0 4
107732: PPUSH
107733: LD_EXP 175
107737: PUSH
107738: LD_VAR 0 4
107742: ARRAY
107743: PPUSH
107744: LD_VAR 0 3
107748: PPUSH
107749: CALL_OW 3
107753: PPUSH
107754: CALL_OW 1
107758: ST_TO_ADDR
// end ; end ;
107759: GO 107588
107761: POP
107762: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107763: LD_VAR 0 1
107767: PPUSH
107768: LD_EXP 175
107772: PUSH
107773: LD_VAR 0 4
107777: ARRAY
107778: PUSH
107779: LD_INT 0
107781: PLUS
107782: PPUSH
107783: CALL_OW 505
// end ;
107787: LD_VAR 0 2
107791: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107792: LD_INT 0
107794: PPUSH
107795: PPUSH
107796: PPUSH
107797: PPUSH
// if not hack in hackTanks then
107798: LD_VAR 0 1
107802: PUSH
107803: LD_EXP 174
107807: IN
107808: NOT
107809: IFFALSE 107813
// exit ;
107811: GO 107898
// index := GetElementIndex ( hackTanks , hack ) ;
107813: LD_ADDR_VAR 0 5
107817: PUSH
107818: LD_EXP 174
107822: PPUSH
107823: LD_VAR 0 1
107827: PPUSH
107828: CALL 53503 0 2
107832: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107833: LD_ADDR_VAR 0 4
107837: PUSH
107838: DOUBLE
107839: LD_INT 1
107841: DEC
107842: ST_TO_ADDR
107843: LD_EXP 175
107847: PUSH
107848: LD_VAR 0 5
107852: ARRAY
107853: PUSH
107854: FOR_TO
107855: IFFALSE 107896
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107857: LD_EXP 175
107861: PUSH
107862: LD_VAR 0 5
107866: ARRAY
107867: PUSH
107868: LD_VAR 0 4
107872: ARRAY
107873: PUSH
107874: LD_INT 1
107876: ARRAY
107877: PUSH
107878: LD_VAR 0 2
107882: EQUAL
107883: IFFALSE 107894
// KillUnit ( vehicle ) ;
107885: LD_VAR 0 2
107889: PPUSH
107890: CALL_OW 66
107894: GO 107854
107896: POP
107897: POP
// end ;
107898: LD_VAR 0 3
107902: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107903: LD_EXP 179
107907: NOT
107908: IFFALSE 107943
107910: GO 107912
107912: DISABLE
// begin initMiner := true ;
107913: LD_ADDR_EXP 179
107917: PUSH
107918: LD_INT 1
107920: ST_TO_ADDR
// minersList := [ ] ;
107921: LD_ADDR_EXP 180
107925: PUSH
107926: EMPTY
107927: ST_TO_ADDR
// minerMinesList := [ ] ;
107928: LD_ADDR_EXP 181
107932: PUSH
107933: EMPTY
107934: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107935: LD_ADDR_EXP 182
107939: PUSH
107940: LD_INT 5
107942: ST_TO_ADDR
// end ;
107943: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107944: LD_EXP 179
107948: PUSH
107949: LD_INT 34
107951: PUSH
107952: LD_EXP 101
107956: PUSH
107957: EMPTY
107958: LIST
107959: LIST
107960: PPUSH
107961: CALL_OW 69
107965: AND
107966: IFFALSE 108429
107968: GO 107970
107970: DISABLE
107971: LD_INT 0
107973: PPUSH
107974: PPUSH
107975: PPUSH
107976: PPUSH
// begin enable ;
107977: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
107978: LD_ADDR_VAR 0 1
107982: PUSH
107983: LD_INT 34
107985: PUSH
107986: LD_EXP 101
107990: PUSH
107991: EMPTY
107992: LIST
107993: LIST
107994: PPUSH
107995: CALL_OW 69
107999: PUSH
108000: FOR_IN
108001: IFFALSE 108073
// begin if not i in minersList then
108003: LD_VAR 0 1
108007: PUSH
108008: LD_EXP 180
108012: IN
108013: NOT
108014: IFFALSE 108071
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108016: LD_ADDR_EXP 180
108020: PUSH
108021: LD_EXP 180
108025: PPUSH
108026: LD_EXP 180
108030: PUSH
108031: LD_INT 1
108033: PLUS
108034: PPUSH
108035: LD_VAR 0 1
108039: PPUSH
108040: CALL_OW 1
108044: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108045: LD_ADDR_EXP 181
108049: PUSH
108050: LD_EXP 181
108054: PPUSH
108055: LD_EXP 181
108059: PUSH
108060: LD_INT 1
108062: PLUS
108063: PPUSH
108064: EMPTY
108065: PPUSH
108066: CALL_OW 1
108070: ST_TO_ADDR
// end end ;
108071: GO 108000
108073: POP
108074: POP
// for i := minerMinesList downto 1 do
108075: LD_ADDR_VAR 0 1
108079: PUSH
108080: DOUBLE
108081: LD_EXP 181
108085: INC
108086: ST_TO_ADDR
108087: LD_INT 1
108089: PUSH
108090: FOR_DOWNTO
108091: IFFALSE 108427
// begin if IsLive ( minersList [ i ] ) then
108093: LD_EXP 180
108097: PUSH
108098: LD_VAR 0 1
108102: ARRAY
108103: PPUSH
108104: CALL_OW 300
108108: IFFALSE 108136
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108110: LD_EXP 180
108114: PUSH
108115: LD_VAR 0 1
108119: ARRAY
108120: PPUSH
108121: LD_EXP 181
108125: PUSH
108126: LD_VAR 0 1
108130: ARRAY
108131: PPUSH
108132: CALL_OW 505
// if not minerMinesList [ i ] then
108136: LD_EXP 181
108140: PUSH
108141: LD_VAR 0 1
108145: ARRAY
108146: NOT
108147: IFFALSE 108151
// continue ;
108149: GO 108090
// for j := minerMinesList [ i ] downto 1 do
108151: LD_ADDR_VAR 0 2
108155: PUSH
108156: DOUBLE
108157: LD_EXP 181
108161: PUSH
108162: LD_VAR 0 1
108166: ARRAY
108167: INC
108168: ST_TO_ADDR
108169: LD_INT 1
108171: PUSH
108172: FOR_DOWNTO
108173: IFFALSE 108423
// begin side := GetSide ( minersList [ i ] ) ;
108175: LD_ADDR_VAR 0 3
108179: PUSH
108180: LD_EXP 180
108184: PUSH
108185: LD_VAR 0 1
108189: ARRAY
108190: PPUSH
108191: CALL_OW 255
108195: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108196: LD_ADDR_VAR 0 4
108200: PUSH
108201: LD_EXP 181
108205: PUSH
108206: LD_VAR 0 1
108210: ARRAY
108211: PUSH
108212: LD_VAR 0 2
108216: ARRAY
108217: PUSH
108218: LD_INT 1
108220: ARRAY
108221: PPUSH
108222: LD_EXP 181
108226: PUSH
108227: LD_VAR 0 1
108231: ARRAY
108232: PUSH
108233: LD_VAR 0 2
108237: ARRAY
108238: PUSH
108239: LD_INT 2
108241: ARRAY
108242: PPUSH
108243: CALL_OW 428
108247: ST_TO_ADDR
// if not tmp then
108248: LD_VAR 0 4
108252: NOT
108253: IFFALSE 108257
// continue ;
108255: GO 108172
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108257: LD_VAR 0 4
108261: PUSH
108262: LD_INT 81
108264: PUSH
108265: LD_VAR 0 3
108269: PUSH
108270: EMPTY
108271: LIST
108272: LIST
108273: PPUSH
108274: CALL_OW 69
108278: IN
108279: PUSH
108280: LD_EXP 181
108284: PUSH
108285: LD_VAR 0 1
108289: ARRAY
108290: PUSH
108291: LD_VAR 0 2
108295: ARRAY
108296: PUSH
108297: LD_INT 1
108299: ARRAY
108300: PPUSH
108301: LD_EXP 181
108305: PUSH
108306: LD_VAR 0 1
108310: ARRAY
108311: PUSH
108312: LD_VAR 0 2
108316: ARRAY
108317: PUSH
108318: LD_INT 2
108320: ARRAY
108321: PPUSH
108322: CALL_OW 458
108326: AND
108327: IFFALSE 108421
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108329: LD_EXP 181
108333: PUSH
108334: LD_VAR 0 1
108338: ARRAY
108339: PUSH
108340: LD_VAR 0 2
108344: ARRAY
108345: PUSH
108346: LD_INT 1
108348: ARRAY
108349: PPUSH
108350: LD_EXP 181
108354: PUSH
108355: LD_VAR 0 1
108359: ARRAY
108360: PUSH
108361: LD_VAR 0 2
108365: ARRAY
108366: PUSH
108367: LD_INT 2
108369: ARRAY
108370: PPUSH
108371: LD_VAR 0 3
108375: PPUSH
108376: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108380: LD_ADDR_EXP 181
108384: PUSH
108385: LD_EXP 181
108389: PPUSH
108390: LD_VAR 0 1
108394: PPUSH
108395: LD_EXP 181
108399: PUSH
108400: LD_VAR 0 1
108404: ARRAY
108405: PPUSH
108406: LD_VAR 0 2
108410: PPUSH
108411: CALL_OW 3
108415: PPUSH
108416: CALL_OW 1
108420: ST_TO_ADDR
// end ; end ;
108421: GO 108172
108423: POP
108424: POP
// end ;
108425: GO 108090
108427: POP
108428: POP
// end ;
108429: PPOPN 4
108431: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108432: LD_INT 0
108434: PPUSH
108435: PPUSH
// result := false ;
108436: LD_ADDR_VAR 0 4
108440: PUSH
108441: LD_INT 0
108443: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108444: LD_VAR 0 1
108448: PPUSH
108449: CALL_OW 264
108453: PUSH
108454: LD_EXP 101
108458: EQUAL
108459: NOT
108460: IFFALSE 108464
// exit ;
108462: GO 108704
// index := GetElementIndex ( minersList , unit ) ;
108464: LD_ADDR_VAR 0 5
108468: PUSH
108469: LD_EXP 180
108473: PPUSH
108474: LD_VAR 0 1
108478: PPUSH
108479: CALL 53503 0 2
108483: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108484: LD_EXP 181
108488: PUSH
108489: LD_VAR 0 5
108493: ARRAY
108494: PUSH
108495: LD_EXP 182
108499: GREATEREQUAL
108500: IFFALSE 108504
// exit ;
108502: GO 108704
// ComMoveXY ( unit , x , y ) ;
108504: LD_VAR 0 1
108508: PPUSH
108509: LD_VAR 0 2
108513: PPUSH
108514: LD_VAR 0 3
108518: PPUSH
108519: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108523: LD_INT 35
108525: PPUSH
108526: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108530: LD_VAR 0 1
108534: PPUSH
108535: LD_VAR 0 2
108539: PPUSH
108540: LD_VAR 0 3
108544: PPUSH
108545: CALL 84789 0 3
108549: NOT
108550: PUSH
108551: LD_VAR 0 1
108555: PPUSH
108556: CALL_OW 314
108560: AND
108561: IFFALSE 108565
// exit ;
108563: GO 108704
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108565: LD_VAR 0 2
108569: PPUSH
108570: LD_VAR 0 3
108574: PPUSH
108575: CALL_OW 428
108579: PUSH
108580: LD_VAR 0 1
108584: EQUAL
108585: PUSH
108586: LD_VAR 0 1
108590: PPUSH
108591: CALL_OW 314
108595: NOT
108596: AND
108597: IFFALSE 108523
// PlaySoundXY ( x , y , PlantMine ) ;
108599: LD_VAR 0 2
108603: PPUSH
108604: LD_VAR 0 3
108608: PPUSH
108609: LD_STRING PlantMine
108611: PPUSH
108612: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108616: LD_VAR 0 2
108620: PPUSH
108621: LD_VAR 0 3
108625: PPUSH
108626: LD_VAR 0 1
108630: PPUSH
108631: CALL_OW 255
108635: PPUSH
108636: LD_INT 0
108638: PPUSH
108639: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108643: LD_ADDR_EXP 181
108647: PUSH
108648: LD_EXP 181
108652: PPUSH
108653: LD_VAR 0 5
108657: PUSH
108658: LD_EXP 181
108662: PUSH
108663: LD_VAR 0 5
108667: ARRAY
108668: PUSH
108669: LD_INT 1
108671: PLUS
108672: PUSH
108673: EMPTY
108674: LIST
108675: LIST
108676: PPUSH
108677: LD_VAR 0 2
108681: PUSH
108682: LD_VAR 0 3
108686: PUSH
108687: EMPTY
108688: LIST
108689: LIST
108690: PPUSH
108691: CALL 53718 0 3
108695: ST_TO_ADDR
// result := true ;
108696: LD_ADDR_VAR 0 4
108700: PUSH
108701: LD_INT 1
108703: ST_TO_ADDR
// end ;
108704: LD_VAR 0 4
108708: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108709: LD_INT 0
108711: PPUSH
108712: PPUSH
108713: PPUSH
// if not unit in minersList then
108714: LD_VAR 0 1
108718: PUSH
108719: LD_EXP 180
108723: IN
108724: NOT
108725: IFFALSE 108729
// exit ;
108727: GO 109121
// index := GetElementIndex ( minersList , unit ) ;
108729: LD_ADDR_VAR 0 6
108733: PUSH
108734: LD_EXP 180
108738: PPUSH
108739: LD_VAR 0 1
108743: PPUSH
108744: CALL 53503 0 2
108748: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108749: LD_ADDR_VAR 0 5
108753: PUSH
108754: DOUBLE
108755: LD_EXP 181
108759: PUSH
108760: LD_VAR 0 6
108764: ARRAY
108765: INC
108766: ST_TO_ADDR
108767: LD_INT 1
108769: PUSH
108770: FOR_DOWNTO
108771: IFFALSE 108932
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108773: LD_EXP 181
108777: PUSH
108778: LD_VAR 0 6
108782: ARRAY
108783: PUSH
108784: LD_VAR 0 5
108788: ARRAY
108789: PUSH
108790: LD_INT 1
108792: ARRAY
108793: PUSH
108794: LD_VAR 0 2
108798: EQUAL
108799: PUSH
108800: LD_EXP 181
108804: PUSH
108805: LD_VAR 0 6
108809: ARRAY
108810: PUSH
108811: LD_VAR 0 5
108815: ARRAY
108816: PUSH
108817: LD_INT 2
108819: ARRAY
108820: PUSH
108821: LD_VAR 0 3
108825: EQUAL
108826: AND
108827: IFFALSE 108930
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108829: LD_EXP 181
108833: PUSH
108834: LD_VAR 0 6
108838: ARRAY
108839: PUSH
108840: LD_VAR 0 5
108844: ARRAY
108845: PUSH
108846: LD_INT 1
108848: ARRAY
108849: PPUSH
108850: LD_EXP 181
108854: PUSH
108855: LD_VAR 0 6
108859: ARRAY
108860: PUSH
108861: LD_VAR 0 5
108865: ARRAY
108866: PUSH
108867: LD_INT 2
108869: ARRAY
108870: PPUSH
108871: LD_VAR 0 1
108875: PPUSH
108876: CALL_OW 255
108880: PPUSH
108881: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108885: LD_ADDR_EXP 181
108889: PUSH
108890: LD_EXP 181
108894: PPUSH
108895: LD_VAR 0 6
108899: PPUSH
108900: LD_EXP 181
108904: PUSH
108905: LD_VAR 0 6
108909: ARRAY
108910: PPUSH
108911: LD_VAR 0 5
108915: PPUSH
108916: CALL_OW 3
108920: PPUSH
108921: CALL_OW 1
108925: ST_TO_ADDR
// exit ;
108926: POP
108927: POP
108928: GO 109121
// end ; end ;
108930: GO 108770
108932: POP
108933: POP
// for i := minerMinesList [ index ] downto 1 do
108934: LD_ADDR_VAR 0 5
108938: PUSH
108939: DOUBLE
108940: LD_EXP 181
108944: PUSH
108945: LD_VAR 0 6
108949: ARRAY
108950: INC
108951: ST_TO_ADDR
108952: LD_INT 1
108954: PUSH
108955: FOR_DOWNTO
108956: IFFALSE 109119
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
108958: LD_EXP 181
108962: PUSH
108963: LD_VAR 0 6
108967: ARRAY
108968: PUSH
108969: LD_VAR 0 5
108973: ARRAY
108974: PUSH
108975: LD_INT 1
108977: ARRAY
108978: PPUSH
108979: LD_EXP 181
108983: PUSH
108984: LD_VAR 0 6
108988: ARRAY
108989: PUSH
108990: LD_VAR 0 5
108994: ARRAY
108995: PUSH
108996: LD_INT 2
108998: ARRAY
108999: PPUSH
109000: LD_VAR 0 2
109004: PPUSH
109005: LD_VAR 0 3
109009: PPUSH
109010: CALL_OW 298
109014: PUSH
109015: LD_INT 6
109017: LESS
109018: IFFALSE 109117
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109020: LD_EXP 181
109024: PUSH
109025: LD_VAR 0 6
109029: ARRAY
109030: PUSH
109031: LD_VAR 0 5
109035: ARRAY
109036: PUSH
109037: LD_INT 1
109039: ARRAY
109040: PPUSH
109041: LD_EXP 181
109045: PUSH
109046: LD_VAR 0 6
109050: ARRAY
109051: PUSH
109052: LD_VAR 0 5
109056: ARRAY
109057: PUSH
109058: LD_INT 2
109060: ARRAY
109061: PPUSH
109062: LD_VAR 0 1
109066: PPUSH
109067: CALL_OW 255
109071: PPUSH
109072: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109076: LD_ADDR_EXP 181
109080: PUSH
109081: LD_EXP 181
109085: PPUSH
109086: LD_VAR 0 6
109090: PPUSH
109091: LD_EXP 181
109095: PUSH
109096: LD_VAR 0 6
109100: ARRAY
109101: PPUSH
109102: LD_VAR 0 5
109106: PPUSH
109107: CALL_OW 3
109111: PPUSH
109112: CALL_OW 1
109116: ST_TO_ADDR
// end ; end ;
109117: GO 108955
109119: POP
109120: POP
// end ;
109121: LD_VAR 0 4
109125: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109126: LD_INT 0
109128: PPUSH
109129: PPUSH
109130: PPUSH
109131: PPUSH
109132: PPUSH
109133: PPUSH
109134: PPUSH
109135: PPUSH
109136: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109137: LD_VAR 0 1
109141: PPUSH
109142: CALL_OW 264
109146: PUSH
109147: LD_EXP 101
109151: EQUAL
109152: NOT
109153: PUSH
109154: LD_VAR 0 1
109158: PUSH
109159: LD_EXP 180
109163: IN
109164: NOT
109165: OR
109166: IFFALSE 109170
// exit ;
109168: GO 109492
// index := GetElementIndex ( minersList , unit ) ;
109170: LD_ADDR_VAR 0 6
109174: PUSH
109175: LD_EXP 180
109179: PPUSH
109180: LD_VAR 0 1
109184: PPUSH
109185: CALL 53503 0 2
109189: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109190: LD_ADDR_VAR 0 8
109194: PUSH
109195: LD_EXP 182
109199: PUSH
109200: LD_EXP 181
109204: PUSH
109205: LD_VAR 0 6
109209: ARRAY
109210: MINUS
109211: ST_TO_ADDR
// if not minesFreeAmount then
109212: LD_VAR 0 8
109216: NOT
109217: IFFALSE 109221
// exit ;
109219: GO 109492
// tmp := [ ] ;
109221: LD_ADDR_VAR 0 7
109225: PUSH
109226: EMPTY
109227: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109228: LD_ADDR_VAR 0 5
109232: PUSH
109233: DOUBLE
109234: LD_INT 1
109236: DEC
109237: ST_TO_ADDR
109238: LD_VAR 0 8
109242: PUSH
109243: FOR_TO
109244: IFFALSE 109439
// begin _d := rand ( 0 , 5 ) ;
109246: LD_ADDR_VAR 0 11
109250: PUSH
109251: LD_INT 0
109253: PPUSH
109254: LD_INT 5
109256: PPUSH
109257: CALL_OW 12
109261: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109262: LD_ADDR_VAR 0 12
109266: PUSH
109267: LD_INT 2
109269: PPUSH
109270: LD_INT 6
109272: PPUSH
109273: CALL_OW 12
109277: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109278: LD_ADDR_VAR 0 9
109282: PUSH
109283: LD_VAR 0 2
109287: PPUSH
109288: LD_VAR 0 11
109292: PPUSH
109293: LD_VAR 0 12
109297: PPUSH
109298: CALL_OW 272
109302: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109303: LD_ADDR_VAR 0 10
109307: PUSH
109308: LD_VAR 0 3
109312: PPUSH
109313: LD_VAR 0 11
109317: PPUSH
109318: LD_VAR 0 12
109322: PPUSH
109323: CALL_OW 273
109327: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109328: LD_VAR 0 9
109332: PPUSH
109333: LD_VAR 0 10
109337: PPUSH
109338: CALL_OW 488
109342: PUSH
109343: LD_VAR 0 9
109347: PUSH
109348: LD_VAR 0 10
109352: PUSH
109353: EMPTY
109354: LIST
109355: LIST
109356: PUSH
109357: LD_VAR 0 7
109361: IN
109362: NOT
109363: AND
109364: PUSH
109365: LD_VAR 0 9
109369: PPUSH
109370: LD_VAR 0 10
109374: PPUSH
109375: CALL_OW 458
109379: NOT
109380: AND
109381: IFFALSE 109423
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109383: LD_ADDR_VAR 0 7
109387: PUSH
109388: LD_VAR 0 7
109392: PPUSH
109393: LD_VAR 0 7
109397: PUSH
109398: LD_INT 1
109400: PLUS
109401: PPUSH
109402: LD_VAR 0 9
109406: PUSH
109407: LD_VAR 0 10
109411: PUSH
109412: EMPTY
109413: LIST
109414: LIST
109415: PPUSH
109416: CALL_OW 1
109420: ST_TO_ADDR
109421: GO 109437
// i := i - 1 ;
109423: LD_ADDR_VAR 0 5
109427: PUSH
109428: LD_VAR 0 5
109432: PUSH
109433: LD_INT 1
109435: MINUS
109436: ST_TO_ADDR
// end ;
109437: GO 109243
109439: POP
109440: POP
// for i in tmp do
109441: LD_ADDR_VAR 0 5
109445: PUSH
109446: LD_VAR 0 7
109450: PUSH
109451: FOR_IN
109452: IFFALSE 109490
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109454: LD_VAR 0 1
109458: PPUSH
109459: LD_VAR 0 5
109463: PUSH
109464: LD_INT 1
109466: ARRAY
109467: PPUSH
109468: LD_VAR 0 5
109472: PUSH
109473: LD_INT 2
109475: ARRAY
109476: PPUSH
109477: CALL 108432 0 3
109481: NOT
109482: IFFALSE 109488
// exit ;
109484: POP
109485: POP
109486: GO 109492
109488: GO 109451
109490: POP
109491: POP
// end ;
109492: LD_VAR 0 4
109496: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109497: LD_INT 0
109499: PPUSH
109500: PPUSH
109501: PPUSH
109502: PPUSH
109503: PPUSH
109504: PPUSH
109505: PPUSH
// if not GetClass ( unit ) = class_sniper then
109506: LD_VAR 0 1
109510: PPUSH
109511: CALL_OW 257
109515: PUSH
109516: LD_INT 5
109518: EQUAL
109519: NOT
109520: IFFALSE 109524
// exit ;
109522: GO 109912
// dist := 8 ;
109524: LD_ADDR_VAR 0 5
109528: PUSH
109529: LD_INT 8
109531: ST_TO_ADDR
// viewRange := 12 ;
109532: LD_ADDR_VAR 0 7
109536: PUSH
109537: LD_INT 12
109539: ST_TO_ADDR
// side := GetSide ( unit ) ;
109540: LD_ADDR_VAR 0 6
109544: PUSH
109545: LD_VAR 0 1
109549: PPUSH
109550: CALL_OW 255
109554: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109555: LD_INT 61
109557: PPUSH
109558: LD_VAR 0 6
109562: PPUSH
109563: CALL_OW 321
109567: PUSH
109568: LD_INT 2
109570: EQUAL
109571: IFFALSE 109581
// viewRange := 16 ;
109573: LD_ADDR_VAR 0 7
109577: PUSH
109578: LD_INT 16
109580: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109581: LD_VAR 0 1
109585: PPUSH
109586: LD_VAR 0 2
109590: PPUSH
109591: LD_VAR 0 3
109595: PPUSH
109596: CALL_OW 297
109600: PUSH
109601: LD_VAR 0 5
109605: GREATER
109606: IFFALSE 109685
// begin ComMoveXY ( unit , x , y ) ;
109608: LD_VAR 0 1
109612: PPUSH
109613: LD_VAR 0 2
109617: PPUSH
109618: LD_VAR 0 3
109622: PPUSH
109623: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109627: LD_INT 35
109629: PPUSH
109630: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109634: LD_VAR 0 1
109638: PPUSH
109639: LD_VAR 0 2
109643: PPUSH
109644: LD_VAR 0 3
109648: PPUSH
109649: CALL 84789 0 3
109653: NOT
109654: IFFALSE 109658
// exit ;
109656: GO 109912
// until GetDistUnitXY ( unit , x , y ) < dist ;
109658: LD_VAR 0 1
109662: PPUSH
109663: LD_VAR 0 2
109667: PPUSH
109668: LD_VAR 0 3
109672: PPUSH
109673: CALL_OW 297
109677: PUSH
109678: LD_VAR 0 5
109682: LESS
109683: IFFALSE 109627
// end ; ComTurnXY ( unit , x , y ) ;
109685: LD_VAR 0 1
109689: PPUSH
109690: LD_VAR 0 2
109694: PPUSH
109695: LD_VAR 0 3
109699: PPUSH
109700: CALL_OW 118
// wait ( 5 ) ;
109704: LD_INT 5
109706: PPUSH
109707: CALL_OW 67
// _d := GetDir ( unit ) ;
109711: LD_ADDR_VAR 0 10
109715: PUSH
109716: LD_VAR 0 1
109720: PPUSH
109721: CALL_OW 254
109725: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109726: LD_ADDR_VAR 0 8
109730: PUSH
109731: LD_VAR 0 1
109735: PPUSH
109736: CALL_OW 250
109740: PPUSH
109741: LD_VAR 0 10
109745: PPUSH
109746: LD_VAR 0 5
109750: PPUSH
109751: CALL_OW 272
109755: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109756: LD_ADDR_VAR 0 9
109760: PUSH
109761: LD_VAR 0 1
109765: PPUSH
109766: CALL_OW 251
109770: PPUSH
109771: LD_VAR 0 10
109775: PPUSH
109776: LD_VAR 0 5
109780: PPUSH
109781: CALL_OW 273
109785: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109786: LD_VAR 0 8
109790: PPUSH
109791: LD_VAR 0 9
109795: PPUSH
109796: CALL_OW 488
109800: NOT
109801: IFFALSE 109805
// exit ;
109803: GO 109912
// ComAnimCustom ( unit , 1 ) ;
109805: LD_VAR 0 1
109809: PPUSH
109810: LD_INT 1
109812: PPUSH
109813: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109817: LD_VAR 0 8
109821: PPUSH
109822: LD_VAR 0 9
109826: PPUSH
109827: LD_VAR 0 6
109831: PPUSH
109832: LD_VAR 0 7
109836: PPUSH
109837: CALL_OW 330
// repeat wait ( 1 ) ;
109841: LD_INT 1
109843: PPUSH
109844: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109848: LD_VAR 0 1
109852: PPUSH
109853: CALL_OW 316
109857: PUSH
109858: LD_VAR 0 1
109862: PPUSH
109863: CALL_OW 314
109867: OR
109868: PUSH
109869: LD_VAR 0 1
109873: PPUSH
109874: CALL_OW 302
109878: NOT
109879: OR
109880: PUSH
109881: LD_VAR 0 1
109885: PPUSH
109886: CALL_OW 301
109890: OR
109891: IFFALSE 109841
// RemoveSeeing ( _x , _y , side ) ;
109893: LD_VAR 0 8
109897: PPUSH
109898: LD_VAR 0 9
109902: PPUSH
109903: LD_VAR 0 6
109907: PPUSH
109908: CALL_OW 331
// end ; end_of_file
109912: LD_VAR 0 4
109916: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109917: LD_INT 0
109919: PPUSH
109920: PPUSH
109921: PPUSH
109922: PPUSH
109923: PPUSH
109924: PPUSH
109925: PPUSH
109926: PPUSH
109927: PPUSH
109928: PPUSH
109929: PPUSH
109930: PPUSH
109931: PPUSH
109932: PPUSH
109933: PPUSH
109934: PPUSH
109935: PPUSH
109936: PPUSH
109937: PPUSH
109938: PPUSH
109939: PPUSH
109940: PPUSH
109941: PPUSH
109942: PPUSH
109943: PPUSH
109944: PPUSH
109945: PPUSH
109946: PPUSH
109947: PPUSH
109948: PPUSH
109949: PPUSH
109950: PPUSH
109951: PPUSH
109952: PPUSH
// if not list then
109953: LD_VAR 0 1
109957: NOT
109958: IFFALSE 109962
// exit ;
109960: GO 114621
// base := list [ 1 ] ;
109962: LD_ADDR_VAR 0 3
109966: PUSH
109967: LD_VAR 0 1
109971: PUSH
109972: LD_INT 1
109974: ARRAY
109975: ST_TO_ADDR
// group := list [ 2 ] ;
109976: LD_ADDR_VAR 0 4
109980: PUSH
109981: LD_VAR 0 1
109985: PUSH
109986: LD_INT 2
109988: ARRAY
109989: ST_TO_ADDR
// path := list [ 3 ] ;
109990: LD_ADDR_VAR 0 5
109994: PUSH
109995: LD_VAR 0 1
109999: PUSH
110000: LD_INT 3
110002: ARRAY
110003: ST_TO_ADDR
// flags := list [ 4 ] ;
110004: LD_ADDR_VAR 0 6
110008: PUSH
110009: LD_VAR 0 1
110013: PUSH
110014: LD_INT 4
110016: ARRAY
110017: ST_TO_ADDR
// mined := [ ] ;
110018: LD_ADDR_VAR 0 27
110022: PUSH
110023: EMPTY
110024: ST_TO_ADDR
// bombed := [ ] ;
110025: LD_ADDR_VAR 0 28
110029: PUSH
110030: EMPTY
110031: ST_TO_ADDR
// healers := [ ] ;
110032: LD_ADDR_VAR 0 31
110036: PUSH
110037: EMPTY
110038: ST_TO_ADDR
// to_heal := [ ] ;
110039: LD_ADDR_VAR 0 30
110043: PUSH
110044: EMPTY
110045: ST_TO_ADDR
// repairs := [ ] ;
110046: LD_ADDR_VAR 0 33
110050: PUSH
110051: EMPTY
110052: ST_TO_ADDR
// to_repair := [ ] ;
110053: LD_ADDR_VAR 0 32
110057: PUSH
110058: EMPTY
110059: ST_TO_ADDR
// if not group or not path then
110060: LD_VAR 0 4
110064: NOT
110065: PUSH
110066: LD_VAR 0 5
110070: NOT
110071: OR
110072: IFFALSE 110076
// exit ;
110074: GO 114621
// side := GetSide ( group [ 1 ] ) ;
110076: LD_ADDR_VAR 0 35
110080: PUSH
110081: LD_VAR 0 4
110085: PUSH
110086: LD_INT 1
110088: ARRAY
110089: PPUSH
110090: CALL_OW 255
110094: ST_TO_ADDR
// if flags then
110095: LD_VAR 0 6
110099: IFFALSE 110243
// begin f_ignore_area := flags [ 1 ] ;
110101: LD_ADDR_VAR 0 17
110105: PUSH
110106: LD_VAR 0 6
110110: PUSH
110111: LD_INT 1
110113: ARRAY
110114: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110115: LD_ADDR_VAR 0 18
110119: PUSH
110120: LD_VAR 0 6
110124: PUSH
110125: LD_INT 2
110127: ARRAY
110128: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110129: LD_ADDR_VAR 0 19
110133: PUSH
110134: LD_VAR 0 6
110138: PUSH
110139: LD_INT 3
110141: ARRAY
110142: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110143: LD_ADDR_VAR 0 20
110147: PUSH
110148: LD_VAR 0 6
110152: PUSH
110153: LD_INT 4
110155: ARRAY
110156: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110157: LD_ADDR_VAR 0 21
110161: PUSH
110162: LD_VAR 0 6
110166: PUSH
110167: LD_INT 5
110169: ARRAY
110170: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110171: LD_ADDR_VAR 0 22
110175: PUSH
110176: LD_VAR 0 6
110180: PUSH
110181: LD_INT 6
110183: ARRAY
110184: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110185: LD_ADDR_VAR 0 23
110189: PUSH
110190: LD_VAR 0 6
110194: PUSH
110195: LD_INT 7
110197: ARRAY
110198: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110199: LD_ADDR_VAR 0 24
110203: PUSH
110204: LD_VAR 0 6
110208: PUSH
110209: LD_INT 8
110211: ARRAY
110212: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110213: LD_ADDR_VAR 0 25
110217: PUSH
110218: LD_VAR 0 6
110222: PUSH
110223: LD_INT 9
110225: ARRAY
110226: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110227: LD_ADDR_VAR 0 26
110231: PUSH
110232: LD_VAR 0 6
110236: PUSH
110237: LD_INT 10
110239: ARRAY
110240: ST_TO_ADDR
// end else
110241: GO 110323
// begin f_ignore_area := false ;
110243: LD_ADDR_VAR 0 17
110247: PUSH
110248: LD_INT 0
110250: ST_TO_ADDR
// f_capture := false ;
110251: LD_ADDR_VAR 0 18
110255: PUSH
110256: LD_INT 0
110258: ST_TO_ADDR
// f_ignore_civ := false ;
110259: LD_ADDR_VAR 0 19
110263: PUSH
110264: LD_INT 0
110266: ST_TO_ADDR
// f_murder := false ;
110267: LD_ADDR_VAR 0 20
110271: PUSH
110272: LD_INT 0
110274: ST_TO_ADDR
// f_mines := false ;
110275: LD_ADDR_VAR 0 21
110279: PUSH
110280: LD_INT 0
110282: ST_TO_ADDR
// f_repair := false ;
110283: LD_ADDR_VAR 0 22
110287: PUSH
110288: LD_INT 0
110290: ST_TO_ADDR
// f_heal := false ;
110291: LD_ADDR_VAR 0 23
110295: PUSH
110296: LD_INT 0
110298: ST_TO_ADDR
// f_spacetime := false ;
110299: LD_ADDR_VAR 0 24
110303: PUSH
110304: LD_INT 0
110306: ST_TO_ADDR
// f_attack_depot := false ;
110307: LD_ADDR_VAR 0 25
110311: PUSH
110312: LD_INT 0
110314: ST_TO_ADDR
// f_crawl := false ;
110315: LD_ADDR_VAR 0 26
110319: PUSH
110320: LD_INT 0
110322: ST_TO_ADDR
// end ; if f_heal then
110323: LD_VAR 0 23
110327: IFFALSE 110354
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110329: LD_ADDR_VAR 0 31
110333: PUSH
110334: LD_VAR 0 4
110338: PPUSH
110339: LD_INT 25
110341: PUSH
110342: LD_INT 4
110344: PUSH
110345: EMPTY
110346: LIST
110347: LIST
110348: PPUSH
110349: CALL_OW 72
110353: ST_TO_ADDR
// if f_repair then
110354: LD_VAR 0 22
110358: IFFALSE 110385
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110360: LD_ADDR_VAR 0 33
110364: PUSH
110365: LD_VAR 0 4
110369: PPUSH
110370: LD_INT 25
110372: PUSH
110373: LD_INT 3
110375: PUSH
110376: EMPTY
110377: LIST
110378: LIST
110379: PPUSH
110380: CALL_OW 72
110384: ST_TO_ADDR
// units_path := [ ] ;
110385: LD_ADDR_VAR 0 16
110389: PUSH
110390: EMPTY
110391: ST_TO_ADDR
// for i = 1 to group do
110392: LD_ADDR_VAR 0 7
110396: PUSH
110397: DOUBLE
110398: LD_INT 1
110400: DEC
110401: ST_TO_ADDR
110402: LD_VAR 0 4
110406: PUSH
110407: FOR_TO
110408: IFFALSE 110437
// units_path := Replace ( units_path , i , path ) ;
110410: LD_ADDR_VAR 0 16
110414: PUSH
110415: LD_VAR 0 16
110419: PPUSH
110420: LD_VAR 0 7
110424: PPUSH
110425: LD_VAR 0 5
110429: PPUSH
110430: CALL_OW 1
110434: ST_TO_ADDR
110435: GO 110407
110437: POP
110438: POP
// repeat for i = group downto 1 do
110439: LD_ADDR_VAR 0 7
110443: PUSH
110444: DOUBLE
110445: LD_VAR 0 4
110449: INC
110450: ST_TO_ADDR
110451: LD_INT 1
110453: PUSH
110454: FOR_DOWNTO
110455: IFFALSE 114577
// begin wait ( 5 ) ;
110457: LD_INT 5
110459: PPUSH
110460: CALL_OW 67
// tmp := [ ] ;
110464: LD_ADDR_VAR 0 14
110468: PUSH
110469: EMPTY
110470: ST_TO_ADDR
// attacking := false ;
110471: LD_ADDR_VAR 0 29
110475: PUSH
110476: LD_INT 0
110478: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110479: LD_VAR 0 4
110483: PUSH
110484: LD_VAR 0 7
110488: ARRAY
110489: PPUSH
110490: CALL_OW 301
110494: PUSH
110495: LD_VAR 0 4
110499: PUSH
110500: LD_VAR 0 7
110504: ARRAY
110505: NOT
110506: OR
110507: IFFALSE 110616
// begin if GetType ( group [ i ] ) = unit_human then
110509: LD_VAR 0 4
110513: PUSH
110514: LD_VAR 0 7
110518: ARRAY
110519: PPUSH
110520: CALL_OW 247
110524: PUSH
110525: LD_INT 1
110527: EQUAL
110528: IFFALSE 110574
// begin to_heal := to_heal diff group [ i ] ;
110530: LD_ADDR_VAR 0 30
110534: PUSH
110535: LD_VAR 0 30
110539: PUSH
110540: LD_VAR 0 4
110544: PUSH
110545: LD_VAR 0 7
110549: ARRAY
110550: DIFF
110551: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110552: LD_ADDR_VAR 0 31
110556: PUSH
110557: LD_VAR 0 31
110561: PUSH
110562: LD_VAR 0 4
110566: PUSH
110567: LD_VAR 0 7
110571: ARRAY
110572: DIFF
110573: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110574: LD_ADDR_VAR 0 4
110578: PUSH
110579: LD_VAR 0 4
110583: PPUSH
110584: LD_VAR 0 7
110588: PPUSH
110589: CALL_OW 3
110593: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110594: LD_ADDR_VAR 0 16
110598: PUSH
110599: LD_VAR 0 16
110603: PPUSH
110604: LD_VAR 0 7
110608: PPUSH
110609: CALL_OW 3
110613: ST_TO_ADDR
// continue ;
110614: GO 110454
// end ; if f_repair then
110616: LD_VAR 0 22
110620: IFFALSE 111109
// begin if GetType ( group [ i ] ) = unit_vehicle then
110622: LD_VAR 0 4
110626: PUSH
110627: LD_VAR 0 7
110631: ARRAY
110632: PPUSH
110633: CALL_OW 247
110637: PUSH
110638: LD_INT 2
110640: EQUAL
110641: IFFALSE 110831
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110643: LD_VAR 0 4
110647: PUSH
110648: LD_VAR 0 7
110652: ARRAY
110653: PPUSH
110654: CALL_OW 256
110658: PUSH
110659: LD_INT 700
110661: LESS
110662: PUSH
110663: LD_VAR 0 4
110667: PUSH
110668: LD_VAR 0 7
110672: ARRAY
110673: PUSH
110674: LD_VAR 0 32
110678: IN
110679: NOT
110680: AND
110681: IFFALSE 110705
// to_repair := to_repair union group [ i ] ;
110683: LD_ADDR_VAR 0 32
110687: PUSH
110688: LD_VAR 0 32
110692: PUSH
110693: LD_VAR 0 4
110697: PUSH
110698: LD_VAR 0 7
110702: ARRAY
110703: UNION
110704: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110705: LD_VAR 0 4
110709: PUSH
110710: LD_VAR 0 7
110714: ARRAY
110715: PPUSH
110716: CALL_OW 256
110720: PUSH
110721: LD_INT 1000
110723: EQUAL
110724: PUSH
110725: LD_VAR 0 4
110729: PUSH
110730: LD_VAR 0 7
110734: ARRAY
110735: PUSH
110736: LD_VAR 0 32
110740: IN
110741: AND
110742: IFFALSE 110766
// to_repair := to_repair diff group [ i ] ;
110744: LD_ADDR_VAR 0 32
110748: PUSH
110749: LD_VAR 0 32
110753: PUSH
110754: LD_VAR 0 4
110758: PUSH
110759: LD_VAR 0 7
110763: ARRAY
110764: DIFF
110765: ST_TO_ADDR
// if group [ i ] in to_repair then
110766: LD_VAR 0 4
110770: PUSH
110771: LD_VAR 0 7
110775: ARRAY
110776: PUSH
110777: LD_VAR 0 32
110781: IN
110782: IFFALSE 110829
// begin if not IsInArea ( group [ i ] , f_repair ) then
110784: LD_VAR 0 4
110788: PUSH
110789: LD_VAR 0 7
110793: ARRAY
110794: PPUSH
110795: LD_VAR 0 22
110799: PPUSH
110800: CALL_OW 308
110804: NOT
110805: IFFALSE 110827
// ComMoveToArea ( group [ i ] , f_repair ) ;
110807: LD_VAR 0 4
110811: PUSH
110812: LD_VAR 0 7
110816: ARRAY
110817: PPUSH
110818: LD_VAR 0 22
110822: PPUSH
110823: CALL_OW 113
// continue ;
110827: GO 110454
// end ; end else
110829: GO 111109
// if group [ i ] in repairs then
110831: LD_VAR 0 4
110835: PUSH
110836: LD_VAR 0 7
110840: ARRAY
110841: PUSH
110842: LD_VAR 0 33
110846: IN
110847: IFFALSE 111109
// begin if IsInUnit ( group [ i ] ) then
110849: LD_VAR 0 4
110853: PUSH
110854: LD_VAR 0 7
110858: ARRAY
110859: PPUSH
110860: CALL_OW 310
110864: IFFALSE 110932
// begin z := IsInUnit ( group [ i ] ) ;
110866: LD_ADDR_VAR 0 13
110870: PUSH
110871: LD_VAR 0 4
110875: PUSH
110876: LD_VAR 0 7
110880: ARRAY
110881: PPUSH
110882: CALL_OW 310
110886: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110887: LD_VAR 0 13
110891: PUSH
110892: LD_VAR 0 32
110896: IN
110897: PUSH
110898: LD_VAR 0 13
110902: PPUSH
110903: LD_VAR 0 22
110907: PPUSH
110908: CALL_OW 308
110912: AND
110913: IFFALSE 110930
// ComExitVehicle ( group [ i ] ) ;
110915: LD_VAR 0 4
110919: PUSH
110920: LD_VAR 0 7
110924: ARRAY
110925: PPUSH
110926: CALL_OW 121
// end else
110930: GO 111109
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110932: LD_ADDR_VAR 0 13
110936: PUSH
110937: LD_VAR 0 4
110941: PPUSH
110942: LD_INT 95
110944: PUSH
110945: LD_VAR 0 22
110949: PUSH
110950: EMPTY
110951: LIST
110952: LIST
110953: PUSH
110954: LD_INT 58
110956: PUSH
110957: EMPTY
110958: LIST
110959: PUSH
110960: EMPTY
110961: LIST
110962: LIST
110963: PPUSH
110964: CALL_OW 72
110968: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
110969: LD_VAR 0 4
110973: PUSH
110974: LD_VAR 0 7
110978: ARRAY
110979: PPUSH
110980: CALL_OW 314
110984: NOT
110985: IFFALSE 111107
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
110987: LD_ADDR_VAR 0 10
110991: PUSH
110992: LD_VAR 0 13
110996: PPUSH
110997: LD_VAR 0 4
111001: PUSH
111002: LD_VAR 0 7
111006: ARRAY
111007: PPUSH
111008: CALL_OW 74
111012: ST_TO_ADDR
// if not x then
111013: LD_VAR 0 10
111017: NOT
111018: IFFALSE 111022
// continue ;
111020: GO 110454
// if GetLives ( x ) < 1000 then
111022: LD_VAR 0 10
111026: PPUSH
111027: CALL_OW 256
111031: PUSH
111032: LD_INT 1000
111034: LESS
111035: IFFALSE 111059
// ComRepairVehicle ( group [ i ] , x ) else
111037: LD_VAR 0 4
111041: PUSH
111042: LD_VAR 0 7
111046: ARRAY
111047: PPUSH
111048: LD_VAR 0 10
111052: PPUSH
111053: CALL_OW 129
111057: GO 111107
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111059: LD_VAR 0 23
111063: PUSH
111064: LD_VAR 0 4
111068: PUSH
111069: LD_VAR 0 7
111073: ARRAY
111074: PPUSH
111075: CALL_OW 256
111079: PUSH
111080: LD_INT 1000
111082: LESS
111083: AND
111084: NOT
111085: IFFALSE 111107
// ComEnterUnit ( group [ i ] , x ) ;
111087: LD_VAR 0 4
111091: PUSH
111092: LD_VAR 0 7
111096: ARRAY
111097: PPUSH
111098: LD_VAR 0 10
111102: PPUSH
111103: CALL_OW 120
// end ; continue ;
111107: GO 110454
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111109: LD_VAR 0 23
111113: PUSH
111114: LD_VAR 0 4
111118: PUSH
111119: LD_VAR 0 7
111123: ARRAY
111124: PPUSH
111125: CALL_OW 247
111129: PUSH
111130: LD_INT 1
111132: EQUAL
111133: AND
111134: IFFALSE 111612
// begin if group [ i ] in healers then
111136: LD_VAR 0 4
111140: PUSH
111141: LD_VAR 0 7
111145: ARRAY
111146: PUSH
111147: LD_VAR 0 31
111151: IN
111152: IFFALSE 111425
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111154: LD_VAR 0 4
111158: PUSH
111159: LD_VAR 0 7
111163: ARRAY
111164: PPUSH
111165: LD_VAR 0 23
111169: PPUSH
111170: CALL_OW 308
111174: NOT
111175: PUSH
111176: LD_VAR 0 4
111180: PUSH
111181: LD_VAR 0 7
111185: ARRAY
111186: PPUSH
111187: CALL_OW 314
111191: NOT
111192: AND
111193: IFFALSE 111217
// ComMoveToArea ( group [ i ] , f_heal ) else
111195: LD_VAR 0 4
111199: PUSH
111200: LD_VAR 0 7
111204: ARRAY
111205: PPUSH
111206: LD_VAR 0 23
111210: PPUSH
111211: CALL_OW 113
111215: GO 111423
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111217: LD_VAR 0 4
111221: PUSH
111222: LD_VAR 0 7
111226: ARRAY
111227: PPUSH
111228: CALL 83365 0 1
111232: PPUSH
111233: CALL_OW 256
111237: PUSH
111238: LD_INT 1000
111240: EQUAL
111241: IFFALSE 111260
// ComStop ( group [ i ] ) else
111243: LD_VAR 0 4
111247: PUSH
111248: LD_VAR 0 7
111252: ARRAY
111253: PPUSH
111254: CALL_OW 141
111258: GO 111423
// if not HasTask ( group [ i ] ) and to_heal then
111260: LD_VAR 0 4
111264: PUSH
111265: LD_VAR 0 7
111269: ARRAY
111270: PPUSH
111271: CALL_OW 314
111275: NOT
111276: PUSH
111277: LD_VAR 0 30
111281: AND
111282: IFFALSE 111423
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111284: LD_ADDR_VAR 0 13
111288: PUSH
111289: LD_VAR 0 30
111293: PPUSH
111294: LD_INT 3
111296: PUSH
111297: LD_INT 54
111299: PUSH
111300: EMPTY
111301: LIST
111302: PUSH
111303: EMPTY
111304: LIST
111305: LIST
111306: PPUSH
111307: CALL_OW 72
111311: PPUSH
111312: LD_VAR 0 4
111316: PUSH
111317: LD_VAR 0 7
111321: ARRAY
111322: PPUSH
111323: CALL_OW 74
111327: ST_TO_ADDR
// if z then
111328: LD_VAR 0 13
111332: IFFALSE 111423
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111334: LD_INT 91
111336: PUSH
111337: LD_VAR 0 13
111341: PUSH
111342: LD_INT 10
111344: PUSH
111345: EMPTY
111346: LIST
111347: LIST
111348: LIST
111349: PUSH
111350: LD_INT 81
111352: PUSH
111353: LD_VAR 0 13
111357: PPUSH
111358: CALL_OW 255
111362: PUSH
111363: EMPTY
111364: LIST
111365: LIST
111366: PUSH
111367: EMPTY
111368: LIST
111369: LIST
111370: PPUSH
111371: CALL_OW 69
111375: PUSH
111376: LD_INT 0
111378: EQUAL
111379: IFFALSE 111403
// ComHeal ( group [ i ] , z ) else
111381: LD_VAR 0 4
111385: PUSH
111386: LD_VAR 0 7
111390: ARRAY
111391: PPUSH
111392: LD_VAR 0 13
111396: PPUSH
111397: CALL_OW 128
111401: GO 111423
// ComMoveToArea ( group [ i ] , f_heal ) ;
111403: LD_VAR 0 4
111407: PUSH
111408: LD_VAR 0 7
111412: ARRAY
111413: PPUSH
111414: LD_VAR 0 23
111418: PPUSH
111419: CALL_OW 113
// end ; continue ;
111423: GO 110454
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111425: LD_VAR 0 4
111429: PUSH
111430: LD_VAR 0 7
111434: ARRAY
111435: PPUSH
111436: CALL_OW 256
111440: PUSH
111441: LD_INT 700
111443: LESS
111444: PUSH
111445: LD_VAR 0 4
111449: PUSH
111450: LD_VAR 0 7
111454: ARRAY
111455: PUSH
111456: LD_VAR 0 30
111460: IN
111461: NOT
111462: AND
111463: IFFALSE 111487
// to_heal := to_heal union group [ i ] ;
111465: LD_ADDR_VAR 0 30
111469: PUSH
111470: LD_VAR 0 30
111474: PUSH
111475: LD_VAR 0 4
111479: PUSH
111480: LD_VAR 0 7
111484: ARRAY
111485: UNION
111486: ST_TO_ADDR
// if group [ i ] in to_heal then
111487: LD_VAR 0 4
111491: PUSH
111492: LD_VAR 0 7
111496: ARRAY
111497: PUSH
111498: LD_VAR 0 30
111502: IN
111503: IFFALSE 111612
// begin if GetLives ( group [ i ] ) = 1000 then
111505: LD_VAR 0 4
111509: PUSH
111510: LD_VAR 0 7
111514: ARRAY
111515: PPUSH
111516: CALL_OW 256
111520: PUSH
111521: LD_INT 1000
111523: EQUAL
111524: IFFALSE 111550
// to_heal := to_heal diff group [ i ] else
111526: LD_ADDR_VAR 0 30
111530: PUSH
111531: LD_VAR 0 30
111535: PUSH
111536: LD_VAR 0 4
111540: PUSH
111541: LD_VAR 0 7
111545: ARRAY
111546: DIFF
111547: ST_TO_ADDR
111548: GO 111612
// begin if not IsInArea ( group [ i ] , to_heal ) then
111550: LD_VAR 0 4
111554: PUSH
111555: LD_VAR 0 7
111559: ARRAY
111560: PPUSH
111561: LD_VAR 0 30
111565: PPUSH
111566: CALL_OW 308
111570: NOT
111571: IFFALSE 111595
// ComMoveToArea ( group [ i ] , f_heal ) else
111573: LD_VAR 0 4
111577: PUSH
111578: LD_VAR 0 7
111582: ARRAY
111583: PPUSH
111584: LD_VAR 0 23
111588: PPUSH
111589: CALL_OW 113
111593: GO 111610
// ComHold ( group [ i ] ) ;
111595: LD_VAR 0 4
111599: PUSH
111600: LD_VAR 0 7
111604: ARRAY
111605: PPUSH
111606: CALL_OW 140
// continue ;
111610: GO 110454
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111612: LD_VAR 0 4
111616: PUSH
111617: LD_VAR 0 7
111621: ARRAY
111622: PPUSH
111623: LD_INT 10
111625: PPUSH
111626: CALL 81218 0 2
111630: NOT
111631: PUSH
111632: LD_VAR 0 16
111636: PUSH
111637: LD_VAR 0 7
111641: ARRAY
111642: PUSH
111643: EMPTY
111644: EQUAL
111645: NOT
111646: AND
111647: IFFALSE 111913
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111649: LD_VAR 0 4
111653: PUSH
111654: LD_VAR 0 7
111658: ARRAY
111659: PPUSH
111660: CALL_OW 262
111664: PUSH
111665: LD_INT 1
111667: PUSH
111668: LD_INT 2
111670: PUSH
111671: EMPTY
111672: LIST
111673: LIST
111674: IN
111675: IFFALSE 111716
// if GetFuel ( group [ i ] ) < 10 then
111677: LD_VAR 0 4
111681: PUSH
111682: LD_VAR 0 7
111686: ARRAY
111687: PPUSH
111688: CALL_OW 261
111692: PUSH
111693: LD_INT 10
111695: LESS
111696: IFFALSE 111716
// SetFuel ( group [ i ] , 12 ) ;
111698: LD_VAR 0 4
111702: PUSH
111703: LD_VAR 0 7
111707: ARRAY
111708: PPUSH
111709: LD_INT 12
111711: PPUSH
111712: CALL_OW 240
// if units_path [ i ] then
111716: LD_VAR 0 16
111720: PUSH
111721: LD_VAR 0 7
111725: ARRAY
111726: IFFALSE 111911
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111728: LD_VAR 0 4
111732: PUSH
111733: LD_VAR 0 7
111737: ARRAY
111738: PPUSH
111739: LD_VAR 0 16
111743: PUSH
111744: LD_VAR 0 7
111748: ARRAY
111749: PUSH
111750: LD_INT 1
111752: ARRAY
111753: PUSH
111754: LD_INT 1
111756: ARRAY
111757: PPUSH
111758: LD_VAR 0 16
111762: PUSH
111763: LD_VAR 0 7
111767: ARRAY
111768: PUSH
111769: LD_INT 1
111771: ARRAY
111772: PUSH
111773: LD_INT 2
111775: ARRAY
111776: PPUSH
111777: CALL_OW 297
111781: PUSH
111782: LD_INT 6
111784: GREATER
111785: IFFALSE 111860
// begin if not HasTask ( group [ i ] ) then
111787: LD_VAR 0 4
111791: PUSH
111792: LD_VAR 0 7
111796: ARRAY
111797: PPUSH
111798: CALL_OW 314
111802: NOT
111803: IFFALSE 111858
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111805: LD_VAR 0 4
111809: PUSH
111810: LD_VAR 0 7
111814: ARRAY
111815: PPUSH
111816: LD_VAR 0 16
111820: PUSH
111821: LD_VAR 0 7
111825: ARRAY
111826: PUSH
111827: LD_INT 1
111829: ARRAY
111830: PUSH
111831: LD_INT 1
111833: ARRAY
111834: PPUSH
111835: LD_VAR 0 16
111839: PUSH
111840: LD_VAR 0 7
111844: ARRAY
111845: PUSH
111846: LD_INT 1
111848: ARRAY
111849: PUSH
111850: LD_INT 2
111852: ARRAY
111853: PPUSH
111854: CALL_OW 114
// end else
111858: GO 111911
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111860: LD_ADDR_VAR 0 15
111864: PUSH
111865: LD_VAR 0 16
111869: PUSH
111870: LD_VAR 0 7
111874: ARRAY
111875: PPUSH
111876: LD_INT 1
111878: PPUSH
111879: CALL_OW 3
111883: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111884: LD_ADDR_VAR 0 16
111888: PUSH
111889: LD_VAR 0 16
111893: PPUSH
111894: LD_VAR 0 7
111898: PPUSH
111899: LD_VAR 0 15
111903: PPUSH
111904: CALL_OW 1
111908: ST_TO_ADDR
// continue ;
111909: GO 110454
// end ; end ; end else
111911: GO 114575
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111913: LD_ADDR_VAR 0 14
111917: PUSH
111918: LD_INT 81
111920: PUSH
111921: LD_VAR 0 4
111925: PUSH
111926: LD_VAR 0 7
111930: ARRAY
111931: PPUSH
111932: CALL_OW 255
111936: PUSH
111937: EMPTY
111938: LIST
111939: LIST
111940: PPUSH
111941: CALL_OW 69
111945: ST_TO_ADDR
// if not tmp then
111946: LD_VAR 0 14
111950: NOT
111951: IFFALSE 111955
// continue ;
111953: GO 110454
// if f_ignore_area then
111955: LD_VAR 0 17
111959: IFFALSE 112047
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
111961: LD_ADDR_VAR 0 15
111965: PUSH
111966: LD_VAR 0 14
111970: PPUSH
111971: LD_INT 3
111973: PUSH
111974: LD_INT 92
111976: PUSH
111977: LD_VAR 0 17
111981: PUSH
111982: LD_INT 1
111984: ARRAY
111985: PUSH
111986: LD_VAR 0 17
111990: PUSH
111991: LD_INT 2
111993: ARRAY
111994: PUSH
111995: LD_VAR 0 17
111999: PUSH
112000: LD_INT 3
112002: ARRAY
112003: PUSH
112004: EMPTY
112005: LIST
112006: LIST
112007: LIST
112008: LIST
112009: PUSH
112010: EMPTY
112011: LIST
112012: LIST
112013: PPUSH
112014: CALL_OW 72
112018: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112019: LD_VAR 0 14
112023: PUSH
112024: LD_VAR 0 15
112028: DIFF
112029: IFFALSE 112047
// tmp := tmp diff tmp2 ;
112031: LD_ADDR_VAR 0 14
112035: PUSH
112036: LD_VAR 0 14
112040: PUSH
112041: LD_VAR 0 15
112045: DIFF
112046: ST_TO_ADDR
// end ; if not f_murder then
112047: LD_VAR 0 20
112051: NOT
112052: IFFALSE 112110
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112054: LD_ADDR_VAR 0 15
112058: PUSH
112059: LD_VAR 0 14
112063: PPUSH
112064: LD_INT 3
112066: PUSH
112067: LD_INT 50
112069: PUSH
112070: EMPTY
112071: LIST
112072: PUSH
112073: EMPTY
112074: LIST
112075: LIST
112076: PPUSH
112077: CALL_OW 72
112081: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112082: LD_VAR 0 14
112086: PUSH
112087: LD_VAR 0 15
112091: DIFF
112092: IFFALSE 112110
// tmp := tmp diff tmp2 ;
112094: LD_ADDR_VAR 0 14
112098: PUSH
112099: LD_VAR 0 14
112103: PUSH
112104: LD_VAR 0 15
112108: DIFF
112109: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112110: LD_ADDR_VAR 0 14
112114: PUSH
112115: LD_VAR 0 4
112119: PUSH
112120: LD_VAR 0 7
112124: ARRAY
112125: PPUSH
112126: LD_VAR 0 14
112130: PPUSH
112131: LD_INT 1
112133: PPUSH
112134: LD_INT 1
112136: PPUSH
112137: CALL 54153 0 4
112141: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112142: LD_VAR 0 4
112146: PUSH
112147: LD_VAR 0 7
112151: ARRAY
112152: PPUSH
112153: CALL_OW 257
112157: PUSH
112158: LD_INT 1
112160: EQUAL
112161: IFFALSE 112609
// begin if WantPlant ( group [ i ] ) then
112163: LD_VAR 0 4
112167: PUSH
112168: LD_VAR 0 7
112172: ARRAY
112173: PPUSH
112174: CALL 53654 0 1
112178: IFFALSE 112182
// continue ;
112180: GO 110454
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112182: LD_VAR 0 18
112186: PUSH
112187: LD_VAR 0 4
112191: PUSH
112192: LD_VAR 0 7
112196: ARRAY
112197: PPUSH
112198: CALL_OW 310
112202: NOT
112203: AND
112204: PUSH
112205: LD_VAR 0 14
112209: PUSH
112210: LD_INT 1
112212: ARRAY
112213: PUSH
112214: LD_VAR 0 14
112218: PPUSH
112219: LD_INT 21
112221: PUSH
112222: LD_INT 2
112224: PUSH
112225: EMPTY
112226: LIST
112227: LIST
112228: PUSH
112229: LD_INT 58
112231: PUSH
112232: EMPTY
112233: LIST
112234: PUSH
112235: EMPTY
112236: LIST
112237: LIST
112238: PPUSH
112239: CALL_OW 72
112243: IN
112244: AND
112245: IFFALSE 112281
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112247: LD_VAR 0 4
112251: PUSH
112252: LD_VAR 0 7
112256: ARRAY
112257: PPUSH
112258: LD_VAR 0 14
112262: PUSH
112263: LD_INT 1
112265: ARRAY
112266: PPUSH
112267: CALL_OW 120
// attacking := true ;
112271: LD_ADDR_VAR 0 29
112275: PUSH
112276: LD_INT 1
112278: ST_TO_ADDR
// continue ;
112279: GO 110454
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112281: LD_VAR 0 26
112285: PUSH
112286: LD_VAR 0 4
112290: PUSH
112291: LD_VAR 0 7
112295: ARRAY
112296: PPUSH
112297: CALL_OW 257
112301: PUSH
112302: LD_INT 1
112304: EQUAL
112305: AND
112306: PUSH
112307: LD_VAR 0 4
112311: PUSH
112312: LD_VAR 0 7
112316: ARRAY
112317: PPUSH
112318: CALL_OW 256
112322: PUSH
112323: LD_INT 800
112325: LESS
112326: AND
112327: PUSH
112328: LD_VAR 0 4
112332: PUSH
112333: LD_VAR 0 7
112337: ARRAY
112338: PPUSH
112339: CALL_OW 318
112343: NOT
112344: AND
112345: IFFALSE 112362
// ComCrawl ( group [ i ] ) ;
112347: LD_VAR 0 4
112351: PUSH
112352: LD_VAR 0 7
112356: ARRAY
112357: PPUSH
112358: CALL_OW 137
// if f_mines then
112362: LD_VAR 0 21
112366: IFFALSE 112609
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112368: LD_VAR 0 14
112372: PUSH
112373: LD_INT 1
112375: ARRAY
112376: PPUSH
112377: CALL_OW 247
112381: PUSH
112382: LD_INT 3
112384: EQUAL
112385: PUSH
112386: LD_VAR 0 14
112390: PUSH
112391: LD_INT 1
112393: ARRAY
112394: PUSH
112395: LD_VAR 0 27
112399: IN
112400: NOT
112401: AND
112402: IFFALSE 112609
// begin x := GetX ( tmp [ 1 ] ) ;
112404: LD_ADDR_VAR 0 10
112408: PUSH
112409: LD_VAR 0 14
112413: PUSH
112414: LD_INT 1
112416: ARRAY
112417: PPUSH
112418: CALL_OW 250
112422: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112423: LD_ADDR_VAR 0 11
112427: PUSH
112428: LD_VAR 0 14
112432: PUSH
112433: LD_INT 1
112435: ARRAY
112436: PPUSH
112437: CALL_OW 251
112441: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112442: LD_ADDR_VAR 0 12
112446: PUSH
112447: LD_VAR 0 4
112451: PUSH
112452: LD_VAR 0 7
112456: ARRAY
112457: PPUSH
112458: CALL 81303 0 1
112462: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112463: LD_VAR 0 4
112467: PUSH
112468: LD_VAR 0 7
112472: ARRAY
112473: PPUSH
112474: LD_VAR 0 10
112478: PPUSH
112479: LD_VAR 0 11
112483: PPUSH
112484: LD_VAR 0 14
112488: PUSH
112489: LD_INT 1
112491: ARRAY
112492: PPUSH
112493: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112497: LD_VAR 0 4
112501: PUSH
112502: LD_VAR 0 7
112506: ARRAY
112507: PPUSH
112508: LD_VAR 0 10
112512: PPUSH
112513: LD_VAR 0 12
112517: PPUSH
112518: LD_INT 7
112520: PPUSH
112521: CALL_OW 272
112525: PPUSH
112526: LD_VAR 0 11
112530: PPUSH
112531: LD_VAR 0 12
112535: PPUSH
112536: LD_INT 7
112538: PPUSH
112539: CALL_OW 273
112543: PPUSH
112544: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112548: LD_VAR 0 4
112552: PUSH
112553: LD_VAR 0 7
112557: ARRAY
112558: PPUSH
112559: LD_INT 71
112561: PPUSH
112562: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112566: LD_ADDR_VAR 0 27
112570: PUSH
112571: LD_VAR 0 27
112575: PPUSH
112576: LD_VAR 0 27
112580: PUSH
112581: LD_INT 1
112583: PLUS
112584: PPUSH
112585: LD_VAR 0 14
112589: PUSH
112590: LD_INT 1
112592: ARRAY
112593: PPUSH
112594: CALL_OW 1
112598: ST_TO_ADDR
// attacking := true ;
112599: LD_ADDR_VAR 0 29
112603: PUSH
112604: LD_INT 1
112606: ST_TO_ADDR
// continue ;
112607: GO 110454
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112609: LD_VAR 0 4
112613: PUSH
112614: LD_VAR 0 7
112618: ARRAY
112619: PPUSH
112620: CALL_OW 257
112624: PUSH
112625: LD_INT 17
112627: EQUAL
112628: PUSH
112629: LD_VAR 0 4
112633: PUSH
112634: LD_VAR 0 7
112638: ARRAY
112639: PPUSH
112640: CALL_OW 110
112644: PUSH
112645: LD_INT 71
112647: EQUAL
112648: NOT
112649: AND
112650: IFFALSE 112796
// begin attacking := false ;
112652: LD_ADDR_VAR 0 29
112656: PUSH
112657: LD_INT 0
112659: ST_TO_ADDR
// k := 5 ;
112660: LD_ADDR_VAR 0 9
112664: PUSH
112665: LD_INT 5
112667: ST_TO_ADDR
// if tmp < k then
112668: LD_VAR 0 14
112672: PUSH
112673: LD_VAR 0 9
112677: LESS
112678: IFFALSE 112690
// k := tmp ;
112680: LD_ADDR_VAR 0 9
112684: PUSH
112685: LD_VAR 0 14
112689: ST_TO_ADDR
// for j = 1 to k do
112690: LD_ADDR_VAR 0 8
112694: PUSH
112695: DOUBLE
112696: LD_INT 1
112698: DEC
112699: ST_TO_ADDR
112700: LD_VAR 0 9
112704: PUSH
112705: FOR_TO
112706: IFFALSE 112794
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112708: LD_VAR 0 14
112712: PUSH
112713: LD_VAR 0 8
112717: ARRAY
112718: PUSH
112719: LD_VAR 0 14
112723: PPUSH
112724: LD_INT 58
112726: PUSH
112727: EMPTY
112728: LIST
112729: PPUSH
112730: CALL_OW 72
112734: IN
112735: NOT
112736: IFFALSE 112792
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112738: LD_VAR 0 4
112742: PUSH
112743: LD_VAR 0 7
112747: ARRAY
112748: PPUSH
112749: LD_VAR 0 14
112753: PUSH
112754: LD_VAR 0 8
112758: ARRAY
112759: PPUSH
112760: CALL_OW 115
// attacking := true ;
112764: LD_ADDR_VAR 0 29
112768: PUSH
112769: LD_INT 1
112771: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112772: LD_VAR 0 4
112776: PUSH
112777: LD_VAR 0 7
112781: ARRAY
112782: PPUSH
112783: LD_INT 71
112785: PPUSH
112786: CALL_OW 109
// continue ;
112790: GO 112705
// end ; end ;
112792: GO 112705
112794: POP
112795: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112796: LD_VAR 0 4
112800: PUSH
112801: LD_VAR 0 7
112805: ARRAY
112806: PPUSH
112807: CALL_OW 257
112811: PUSH
112812: LD_INT 8
112814: EQUAL
112815: PUSH
112816: LD_VAR 0 4
112820: PUSH
112821: LD_VAR 0 7
112825: ARRAY
112826: PPUSH
112827: CALL_OW 264
112831: PUSH
112832: LD_INT 28
112834: PUSH
112835: LD_INT 45
112837: PUSH
112838: LD_INT 7
112840: PUSH
112841: LD_INT 47
112843: PUSH
112844: EMPTY
112845: LIST
112846: LIST
112847: LIST
112848: LIST
112849: IN
112850: OR
112851: IFFALSE 113107
// begin attacking := false ;
112853: LD_ADDR_VAR 0 29
112857: PUSH
112858: LD_INT 0
112860: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112861: LD_VAR 0 14
112865: PUSH
112866: LD_INT 1
112868: ARRAY
112869: PPUSH
112870: CALL_OW 266
112874: PUSH
112875: LD_INT 32
112877: PUSH
112878: LD_INT 31
112880: PUSH
112881: LD_INT 33
112883: PUSH
112884: LD_INT 4
112886: PUSH
112887: LD_INT 5
112889: PUSH
112890: EMPTY
112891: LIST
112892: LIST
112893: LIST
112894: LIST
112895: LIST
112896: IN
112897: IFFALSE 113083
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112899: LD_ADDR_VAR 0 9
112903: PUSH
112904: LD_VAR 0 14
112908: PUSH
112909: LD_INT 1
112911: ARRAY
112912: PPUSH
112913: CALL_OW 266
112917: PPUSH
112918: LD_VAR 0 14
112922: PUSH
112923: LD_INT 1
112925: ARRAY
112926: PPUSH
112927: CALL_OW 250
112931: PPUSH
112932: LD_VAR 0 14
112936: PUSH
112937: LD_INT 1
112939: ARRAY
112940: PPUSH
112941: CALL_OW 251
112945: PPUSH
112946: LD_VAR 0 14
112950: PUSH
112951: LD_INT 1
112953: ARRAY
112954: PPUSH
112955: CALL_OW 254
112959: PPUSH
112960: LD_VAR 0 14
112964: PUSH
112965: LD_INT 1
112967: ARRAY
112968: PPUSH
112969: CALL_OW 248
112973: PPUSH
112974: LD_INT 0
112976: PPUSH
112977: CALL 62673 0 6
112981: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
112982: LD_ADDR_VAR 0 8
112986: PUSH
112987: LD_VAR 0 4
112991: PUSH
112992: LD_VAR 0 7
112996: ARRAY
112997: PPUSH
112998: LD_VAR 0 9
113002: PPUSH
113003: CALL 81343 0 2
113007: ST_TO_ADDR
// if j then
113008: LD_VAR 0 8
113012: IFFALSE 113081
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113014: LD_VAR 0 8
113018: PUSH
113019: LD_INT 1
113021: ARRAY
113022: PPUSH
113023: LD_VAR 0 8
113027: PUSH
113028: LD_INT 2
113030: ARRAY
113031: PPUSH
113032: CALL_OW 488
113036: IFFALSE 113081
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113038: LD_VAR 0 4
113042: PUSH
113043: LD_VAR 0 7
113047: ARRAY
113048: PPUSH
113049: LD_VAR 0 8
113053: PUSH
113054: LD_INT 1
113056: ARRAY
113057: PPUSH
113058: LD_VAR 0 8
113062: PUSH
113063: LD_INT 2
113065: ARRAY
113066: PPUSH
113067: CALL_OW 116
// attacking := true ;
113071: LD_ADDR_VAR 0 29
113075: PUSH
113076: LD_INT 1
113078: ST_TO_ADDR
// continue ;
113079: GO 110454
// end ; end else
113081: GO 113107
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113083: LD_VAR 0 4
113087: PUSH
113088: LD_VAR 0 7
113092: ARRAY
113093: PPUSH
113094: LD_VAR 0 14
113098: PUSH
113099: LD_INT 1
113101: ARRAY
113102: PPUSH
113103: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113107: LD_VAR 0 4
113111: PUSH
113112: LD_VAR 0 7
113116: ARRAY
113117: PPUSH
113118: CALL_OW 265
113122: PUSH
113123: LD_INT 11
113125: EQUAL
113126: IFFALSE 113404
// begin k := 10 ;
113128: LD_ADDR_VAR 0 9
113132: PUSH
113133: LD_INT 10
113135: ST_TO_ADDR
// x := 0 ;
113136: LD_ADDR_VAR 0 10
113140: PUSH
113141: LD_INT 0
113143: ST_TO_ADDR
// if tmp < k then
113144: LD_VAR 0 14
113148: PUSH
113149: LD_VAR 0 9
113153: LESS
113154: IFFALSE 113166
// k := tmp ;
113156: LD_ADDR_VAR 0 9
113160: PUSH
113161: LD_VAR 0 14
113165: ST_TO_ADDR
// for j = k downto 1 do
113166: LD_ADDR_VAR 0 8
113170: PUSH
113171: DOUBLE
113172: LD_VAR 0 9
113176: INC
113177: ST_TO_ADDR
113178: LD_INT 1
113180: PUSH
113181: FOR_DOWNTO
113182: IFFALSE 113257
// begin if GetType ( tmp [ j ] ) = unit_human then
113184: LD_VAR 0 14
113188: PUSH
113189: LD_VAR 0 8
113193: ARRAY
113194: PPUSH
113195: CALL_OW 247
113199: PUSH
113200: LD_INT 1
113202: EQUAL
113203: IFFALSE 113255
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113205: LD_VAR 0 4
113209: PUSH
113210: LD_VAR 0 7
113214: ARRAY
113215: PPUSH
113216: LD_VAR 0 14
113220: PUSH
113221: LD_VAR 0 8
113225: ARRAY
113226: PPUSH
113227: CALL 81614 0 2
// x := tmp [ j ] ;
113231: LD_ADDR_VAR 0 10
113235: PUSH
113236: LD_VAR 0 14
113240: PUSH
113241: LD_VAR 0 8
113245: ARRAY
113246: ST_TO_ADDR
// attacking := true ;
113247: LD_ADDR_VAR 0 29
113251: PUSH
113252: LD_INT 1
113254: ST_TO_ADDR
// end ; end ;
113255: GO 113181
113257: POP
113258: POP
// if not x then
113259: LD_VAR 0 10
113263: NOT
113264: IFFALSE 113404
// begin attacking := true ;
113266: LD_ADDR_VAR 0 29
113270: PUSH
113271: LD_INT 1
113273: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113274: LD_VAR 0 4
113278: PUSH
113279: LD_VAR 0 7
113283: ARRAY
113284: PPUSH
113285: CALL_OW 250
113289: PPUSH
113290: LD_VAR 0 4
113294: PUSH
113295: LD_VAR 0 7
113299: ARRAY
113300: PPUSH
113301: CALL_OW 251
113305: PPUSH
113306: CALL_OW 546
113310: PUSH
113311: LD_INT 2
113313: ARRAY
113314: PUSH
113315: LD_VAR 0 14
113319: PUSH
113320: LD_INT 1
113322: ARRAY
113323: PPUSH
113324: CALL_OW 250
113328: PPUSH
113329: LD_VAR 0 14
113333: PUSH
113334: LD_INT 1
113336: ARRAY
113337: PPUSH
113338: CALL_OW 251
113342: PPUSH
113343: CALL_OW 546
113347: PUSH
113348: LD_INT 2
113350: ARRAY
113351: EQUAL
113352: IFFALSE 113380
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113354: LD_VAR 0 4
113358: PUSH
113359: LD_VAR 0 7
113363: ARRAY
113364: PPUSH
113365: LD_VAR 0 14
113369: PUSH
113370: LD_INT 1
113372: ARRAY
113373: PPUSH
113374: CALL 81614 0 2
113378: GO 113404
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113380: LD_VAR 0 4
113384: PUSH
113385: LD_VAR 0 7
113389: ARRAY
113390: PPUSH
113391: LD_VAR 0 14
113395: PUSH
113396: LD_INT 1
113398: ARRAY
113399: PPUSH
113400: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113404: LD_VAR 0 4
113408: PUSH
113409: LD_VAR 0 7
113413: ARRAY
113414: PPUSH
113415: CALL_OW 264
113419: PUSH
113420: LD_INT 29
113422: EQUAL
113423: IFFALSE 113789
// begin if WantsToAttack ( group [ i ] ) in bombed then
113425: LD_VAR 0 4
113429: PUSH
113430: LD_VAR 0 7
113434: ARRAY
113435: PPUSH
113436: CALL_OW 319
113440: PUSH
113441: LD_VAR 0 28
113445: IN
113446: IFFALSE 113450
// continue ;
113448: GO 110454
// k := 8 ;
113450: LD_ADDR_VAR 0 9
113454: PUSH
113455: LD_INT 8
113457: ST_TO_ADDR
// x := 0 ;
113458: LD_ADDR_VAR 0 10
113462: PUSH
113463: LD_INT 0
113465: ST_TO_ADDR
// if tmp < k then
113466: LD_VAR 0 14
113470: PUSH
113471: LD_VAR 0 9
113475: LESS
113476: IFFALSE 113488
// k := tmp ;
113478: LD_ADDR_VAR 0 9
113482: PUSH
113483: LD_VAR 0 14
113487: ST_TO_ADDR
// for j = 1 to k do
113488: LD_ADDR_VAR 0 8
113492: PUSH
113493: DOUBLE
113494: LD_INT 1
113496: DEC
113497: ST_TO_ADDR
113498: LD_VAR 0 9
113502: PUSH
113503: FOR_TO
113504: IFFALSE 113636
// begin if GetType ( tmp [ j ] ) = unit_building then
113506: LD_VAR 0 14
113510: PUSH
113511: LD_VAR 0 8
113515: ARRAY
113516: PPUSH
113517: CALL_OW 247
113521: PUSH
113522: LD_INT 3
113524: EQUAL
113525: IFFALSE 113634
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113527: LD_VAR 0 14
113531: PUSH
113532: LD_VAR 0 8
113536: ARRAY
113537: PUSH
113538: LD_VAR 0 28
113542: IN
113543: NOT
113544: PUSH
113545: LD_VAR 0 14
113549: PUSH
113550: LD_VAR 0 8
113554: ARRAY
113555: PPUSH
113556: CALL_OW 313
113560: AND
113561: IFFALSE 113634
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113563: LD_VAR 0 4
113567: PUSH
113568: LD_VAR 0 7
113572: ARRAY
113573: PPUSH
113574: LD_VAR 0 14
113578: PUSH
113579: LD_VAR 0 8
113583: ARRAY
113584: PPUSH
113585: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113589: LD_ADDR_VAR 0 28
113593: PUSH
113594: LD_VAR 0 28
113598: PPUSH
113599: LD_VAR 0 28
113603: PUSH
113604: LD_INT 1
113606: PLUS
113607: PPUSH
113608: LD_VAR 0 14
113612: PUSH
113613: LD_VAR 0 8
113617: ARRAY
113618: PPUSH
113619: CALL_OW 1
113623: ST_TO_ADDR
// attacking := true ;
113624: LD_ADDR_VAR 0 29
113628: PUSH
113629: LD_INT 1
113631: ST_TO_ADDR
// break ;
113632: GO 113636
// end ; end ;
113634: GO 113503
113636: POP
113637: POP
// if not attacking and f_attack_depot then
113638: LD_VAR 0 29
113642: NOT
113643: PUSH
113644: LD_VAR 0 25
113648: AND
113649: IFFALSE 113744
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113651: LD_ADDR_VAR 0 13
113655: PUSH
113656: LD_VAR 0 14
113660: PPUSH
113661: LD_INT 2
113663: PUSH
113664: LD_INT 30
113666: PUSH
113667: LD_INT 0
113669: PUSH
113670: EMPTY
113671: LIST
113672: LIST
113673: PUSH
113674: LD_INT 30
113676: PUSH
113677: LD_INT 1
113679: PUSH
113680: EMPTY
113681: LIST
113682: LIST
113683: PUSH
113684: EMPTY
113685: LIST
113686: LIST
113687: LIST
113688: PPUSH
113689: CALL_OW 72
113693: ST_TO_ADDR
// if z then
113694: LD_VAR 0 13
113698: IFFALSE 113744
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113700: LD_VAR 0 4
113704: PUSH
113705: LD_VAR 0 7
113709: ARRAY
113710: PPUSH
113711: LD_VAR 0 13
113715: PPUSH
113716: LD_VAR 0 4
113720: PUSH
113721: LD_VAR 0 7
113725: ARRAY
113726: PPUSH
113727: CALL_OW 74
113731: PPUSH
113732: CALL_OW 115
// attacking := true ;
113736: LD_ADDR_VAR 0 29
113740: PUSH
113741: LD_INT 1
113743: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113744: LD_VAR 0 4
113748: PUSH
113749: LD_VAR 0 7
113753: ARRAY
113754: PPUSH
113755: CALL_OW 256
113759: PUSH
113760: LD_INT 500
113762: LESS
113763: IFFALSE 113789
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113765: LD_VAR 0 4
113769: PUSH
113770: LD_VAR 0 7
113774: ARRAY
113775: PPUSH
113776: LD_VAR 0 14
113780: PUSH
113781: LD_INT 1
113783: ARRAY
113784: PPUSH
113785: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113789: LD_VAR 0 4
113793: PUSH
113794: LD_VAR 0 7
113798: ARRAY
113799: PPUSH
113800: CALL_OW 264
113804: PUSH
113805: LD_INT 49
113807: EQUAL
113808: IFFALSE 113929
// begin if not HasTask ( group [ i ] ) then
113810: LD_VAR 0 4
113814: PUSH
113815: LD_VAR 0 7
113819: ARRAY
113820: PPUSH
113821: CALL_OW 314
113825: NOT
113826: IFFALSE 113929
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113828: LD_ADDR_VAR 0 9
113832: PUSH
113833: LD_INT 81
113835: PUSH
113836: LD_VAR 0 4
113840: PUSH
113841: LD_VAR 0 7
113845: ARRAY
113846: PPUSH
113847: CALL_OW 255
113851: PUSH
113852: EMPTY
113853: LIST
113854: LIST
113855: PPUSH
113856: CALL_OW 69
113860: PPUSH
113861: LD_VAR 0 4
113865: PUSH
113866: LD_VAR 0 7
113870: ARRAY
113871: PPUSH
113872: CALL_OW 74
113876: ST_TO_ADDR
// if k then
113877: LD_VAR 0 9
113881: IFFALSE 113929
// if GetDistUnits ( group [ i ] , k ) > 10 then
113883: LD_VAR 0 4
113887: PUSH
113888: LD_VAR 0 7
113892: ARRAY
113893: PPUSH
113894: LD_VAR 0 9
113898: PPUSH
113899: CALL_OW 296
113903: PUSH
113904: LD_INT 10
113906: GREATER
113907: IFFALSE 113929
// ComMoveUnit ( group [ i ] , k ) ;
113909: LD_VAR 0 4
113913: PUSH
113914: LD_VAR 0 7
113918: ARRAY
113919: PPUSH
113920: LD_VAR 0 9
113924: PPUSH
113925: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113929: LD_VAR 0 4
113933: PUSH
113934: LD_VAR 0 7
113938: ARRAY
113939: PPUSH
113940: CALL_OW 256
113944: PUSH
113945: LD_INT 250
113947: LESS
113948: PUSH
113949: LD_VAR 0 4
113953: PUSH
113954: LD_VAR 0 7
113958: ARRAY
113959: PUSH
113960: LD_INT 21
113962: PUSH
113963: LD_INT 2
113965: PUSH
113966: EMPTY
113967: LIST
113968: LIST
113969: PUSH
113970: LD_INT 23
113972: PUSH
113973: LD_INT 2
113975: PUSH
113976: EMPTY
113977: LIST
113978: LIST
113979: PUSH
113980: EMPTY
113981: LIST
113982: LIST
113983: PPUSH
113984: CALL_OW 69
113988: IN
113989: AND
113990: IFFALSE 114115
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
113992: LD_ADDR_VAR 0 9
113996: PUSH
113997: LD_OWVAR 3
114001: PUSH
114002: LD_VAR 0 4
114006: PUSH
114007: LD_VAR 0 7
114011: ARRAY
114012: DIFF
114013: PPUSH
114014: LD_VAR 0 4
114018: PUSH
114019: LD_VAR 0 7
114023: ARRAY
114024: PPUSH
114025: CALL_OW 74
114029: ST_TO_ADDR
// if not k then
114030: LD_VAR 0 9
114034: NOT
114035: IFFALSE 114039
// continue ;
114037: GO 110454
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114039: LD_VAR 0 9
114043: PUSH
114044: LD_INT 81
114046: PUSH
114047: LD_VAR 0 4
114051: PUSH
114052: LD_VAR 0 7
114056: ARRAY
114057: PPUSH
114058: CALL_OW 255
114062: PUSH
114063: EMPTY
114064: LIST
114065: LIST
114066: PPUSH
114067: CALL_OW 69
114071: IN
114072: PUSH
114073: LD_VAR 0 9
114077: PPUSH
114078: LD_VAR 0 4
114082: PUSH
114083: LD_VAR 0 7
114087: ARRAY
114088: PPUSH
114089: CALL_OW 296
114093: PUSH
114094: LD_INT 5
114096: LESS
114097: AND
114098: IFFALSE 114115
// ComAutodestruct ( group [ i ] ) ;
114100: LD_VAR 0 4
114104: PUSH
114105: LD_VAR 0 7
114109: ARRAY
114110: PPUSH
114111: CALL 81512 0 1
// end ; if f_attack_depot then
114115: LD_VAR 0 25
114119: IFFALSE 114231
// begin k := 6 ;
114121: LD_ADDR_VAR 0 9
114125: PUSH
114126: LD_INT 6
114128: ST_TO_ADDR
// if tmp < k then
114129: LD_VAR 0 14
114133: PUSH
114134: LD_VAR 0 9
114138: LESS
114139: IFFALSE 114151
// k := tmp ;
114141: LD_ADDR_VAR 0 9
114145: PUSH
114146: LD_VAR 0 14
114150: ST_TO_ADDR
// for j = 1 to k do
114151: LD_ADDR_VAR 0 8
114155: PUSH
114156: DOUBLE
114157: LD_INT 1
114159: DEC
114160: ST_TO_ADDR
114161: LD_VAR 0 9
114165: PUSH
114166: FOR_TO
114167: IFFALSE 114229
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114169: LD_VAR 0 8
114173: PPUSH
114174: CALL_OW 266
114178: PUSH
114179: LD_INT 0
114181: PUSH
114182: LD_INT 1
114184: PUSH
114185: EMPTY
114186: LIST
114187: LIST
114188: IN
114189: IFFALSE 114227
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114191: LD_VAR 0 4
114195: PUSH
114196: LD_VAR 0 7
114200: ARRAY
114201: PPUSH
114202: LD_VAR 0 14
114206: PUSH
114207: LD_VAR 0 8
114211: ARRAY
114212: PPUSH
114213: CALL_OW 115
// attacking := true ;
114217: LD_ADDR_VAR 0 29
114221: PUSH
114222: LD_INT 1
114224: ST_TO_ADDR
// break ;
114225: GO 114229
// end ;
114227: GO 114166
114229: POP
114230: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114231: LD_VAR 0 4
114235: PUSH
114236: LD_VAR 0 7
114240: ARRAY
114241: PPUSH
114242: CALL_OW 302
114246: PUSH
114247: LD_VAR 0 29
114251: NOT
114252: AND
114253: IFFALSE 114575
// begin if GetTag ( group [ i ] ) = 71 then
114255: LD_VAR 0 4
114259: PUSH
114260: LD_VAR 0 7
114264: ARRAY
114265: PPUSH
114266: CALL_OW 110
114270: PUSH
114271: LD_INT 71
114273: EQUAL
114274: IFFALSE 114315
// begin if HasTask ( group [ i ] ) then
114276: LD_VAR 0 4
114280: PUSH
114281: LD_VAR 0 7
114285: ARRAY
114286: PPUSH
114287: CALL_OW 314
114291: IFFALSE 114297
// continue else
114293: GO 110454
114295: GO 114315
// SetTag ( group [ i ] , 0 ) ;
114297: LD_VAR 0 4
114301: PUSH
114302: LD_VAR 0 7
114306: ARRAY
114307: PPUSH
114308: LD_INT 0
114310: PPUSH
114311: CALL_OW 109
// end ; k := 8 ;
114315: LD_ADDR_VAR 0 9
114319: PUSH
114320: LD_INT 8
114322: ST_TO_ADDR
// x := 0 ;
114323: LD_ADDR_VAR 0 10
114327: PUSH
114328: LD_INT 0
114330: ST_TO_ADDR
// if tmp < k then
114331: LD_VAR 0 14
114335: PUSH
114336: LD_VAR 0 9
114340: LESS
114341: IFFALSE 114353
// k := tmp ;
114343: LD_ADDR_VAR 0 9
114347: PUSH
114348: LD_VAR 0 14
114352: ST_TO_ADDR
// for j = 1 to k do
114353: LD_ADDR_VAR 0 8
114357: PUSH
114358: DOUBLE
114359: LD_INT 1
114361: DEC
114362: ST_TO_ADDR
114363: LD_VAR 0 9
114367: PUSH
114368: FOR_TO
114369: IFFALSE 114467
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114371: LD_VAR 0 14
114375: PUSH
114376: LD_VAR 0 8
114380: ARRAY
114381: PPUSH
114382: CALL_OW 247
114386: PUSH
114387: LD_INT 1
114389: EQUAL
114390: PUSH
114391: LD_VAR 0 14
114395: PUSH
114396: LD_VAR 0 8
114400: ARRAY
114401: PPUSH
114402: CALL_OW 256
114406: PUSH
114407: LD_INT 250
114409: LESS
114410: PUSH
114411: LD_VAR 0 20
114415: AND
114416: PUSH
114417: LD_VAR 0 20
114421: NOT
114422: PUSH
114423: LD_VAR 0 14
114427: PUSH
114428: LD_VAR 0 8
114432: ARRAY
114433: PPUSH
114434: CALL_OW 256
114438: PUSH
114439: LD_INT 250
114441: GREATEREQUAL
114442: AND
114443: OR
114444: AND
114445: IFFALSE 114465
// begin x := tmp [ j ] ;
114447: LD_ADDR_VAR 0 10
114451: PUSH
114452: LD_VAR 0 14
114456: PUSH
114457: LD_VAR 0 8
114461: ARRAY
114462: ST_TO_ADDR
// break ;
114463: GO 114467
// end ;
114465: GO 114368
114467: POP
114468: POP
// if x then
114469: LD_VAR 0 10
114473: IFFALSE 114497
// ComAttackUnit ( group [ i ] , x ) else
114475: LD_VAR 0 4
114479: PUSH
114480: LD_VAR 0 7
114484: ARRAY
114485: PPUSH
114486: LD_VAR 0 10
114490: PPUSH
114491: CALL_OW 115
114495: GO 114521
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114497: LD_VAR 0 4
114501: PUSH
114502: LD_VAR 0 7
114506: ARRAY
114507: PPUSH
114508: LD_VAR 0 14
114512: PUSH
114513: LD_INT 1
114515: ARRAY
114516: PPUSH
114517: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114521: LD_VAR 0 4
114525: PUSH
114526: LD_VAR 0 7
114530: ARRAY
114531: PPUSH
114532: CALL_OW 314
114536: NOT
114537: IFFALSE 114575
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114539: LD_VAR 0 4
114543: PUSH
114544: LD_VAR 0 7
114548: ARRAY
114549: PPUSH
114550: LD_VAR 0 14
114554: PPUSH
114555: LD_VAR 0 4
114559: PUSH
114560: LD_VAR 0 7
114564: ARRAY
114565: PPUSH
114566: CALL_OW 74
114570: PPUSH
114571: CALL_OW 115
// end ; end ; end ;
114575: GO 110454
114577: POP
114578: POP
// wait ( 0 0$2 ) ;
114579: LD_INT 70
114581: PPUSH
114582: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114586: LD_VAR 0 4
114590: NOT
114591: PUSH
114592: LD_VAR 0 4
114596: PUSH
114597: EMPTY
114598: EQUAL
114599: OR
114600: PUSH
114601: LD_INT 81
114603: PUSH
114604: LD_VAR 0 35
114608: PUSH
114609: EMPTY
114610: LIST
114611: LIST
114612: PPUSH
114613: CALL_OW 69
114617: NOT
114618: OR
114619: IFFALSE 110439
// end ;
114621: LD_VAR 0 2
114625: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114626: LD_INT 0
114628: PPUSH
114629: PPUSH
114630: PPUSH
114631: PPUSH
114632: PPUSH
114633: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114634: LD_VAR 0 1
114638: NOT
114639: PUSH
114640: LD_EXP 50
114644: PUSH
114645: LD_VAR 0 1
114649: ARRAY
114650: NOT
114651: OR
114652: PUSH
114653: LD_VAR 0 2
114657: NOT
114658: OR
114659: IFFALSE 114663
// exit ;
114661: GO 115217
// side := mc_sides [ base ] ;
114663: LD_ADDR_VAR 0 6
114667: PUSH
114668: LD_EXP 76
114672: PUSH
114673: LD_VAR 0 1
114677: ARRAY
114678: ST_TO_ADDR
// if not side then
114679: LD_VAR 0 6
114683: NOT
114684: IFFALSE 114688
// exit ;
114686: GO 115217
// for i in solds do
114688: LD_ADDR_VAR 0 7
114692: PUSH
114693: LD_VAR 0 2
114697: PUSH
114698: FOR_IN
114699: IFFALSE 114760
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114701: LD_VAR 0 7
114705: PPUSH
114706: CALL_OW 310
114710: PPUSH
114711: CALL_OW 266
114715: PUSH
114716: LD_INT 32
114718: PUSH
114719: LD_INT 31
114721: PUSH
114722: EMPTY
114723: LIST
114724: LIST
114725: IN
114726: IFFALSE 114746
// solds := solds diff i else
114728: LD_ADDR_VAR 0 2
114732: PUSH
114733: LD_VAR 0 2
114737: PUSH
114738: LD_VAR 0 7
114742: DIFF
114743: ST_TO_ADDR
114744: GO 114758
// SetTag ( i , 18 ) ;
114746: LD_VAR 0 7
114750: PPUSH
114751: LD_INT 18
114753: PPUSH
114754: CALL_OW 109
114758: GO 114698
114760: POP
114761: POP
// if not solds then
114762: LD_VAR 0 2
114766: NOT
114767: IFFALSE 114771
// exit ;
114769: GO 115217
// repeat wait ( 0 0$2 ) ;
114771: LD_INT 70
114773: PPUSH
114774: CALL_OW 67
// enemy := mc_scan [ base ] ;
114778: LD_ADDR_VAR 0 4
114782: PUSH
114783: LD_EXP 73
114787: PUSH
114788: LD_VAR 0 1
114792: ARRAY
114793: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114794: LD_EXP 50
114798: PUSH
114799: LD_VAR 0 1
114803: ARRAY
114804: NOT
114805: PUSH
114806: LD_EXP 50
114810: PUSH
114811: LD_VAR 0 1
114815: ARRAY
114816: PUSH
114817: EMPTY
114818: EQUAL
114819: OR
114820: IFFALSE 114857
// begin for i in solds do
114822: LD_ADDR_VAR 0 7
114826: PUSH
114827: LD_VAR 0 2
114831: PUSH
114832: FOR_IN
114833: IFFALSE 114846
// ComStop ( i ) ;
114835: LD_VAR 0 7
114839: PPUSH
114840: CALL_OW 141
114844: GO 114832
114846: POP
114847: POP
// solds := [ ] ;
114848: LD_ADDR_VAR 0 2
114852: PUSH
114853: EMPTY
114854: ST_TO_ADDR
// exit ;
114855: GO 115217
// end ; for i in solds do
114857: LD_ADDR_VAR 0 7
114861: PUSH
114862: LD_VAR 0 2
114866: PUSH
114867: FOR_IN
114868: IFFALSE 115189
// begin if IsInUnit ( i ) then
114870: LD_VAR 0 7
114874: PPUSH
114875: CALL_OW 310
114879: IFFALSE 114890
// ComExitBuilding ( i ) ;
114881: LD_VAR 0 7
114885: PPUSH
114886: CALL_OW 122
// if GetLives ( i ) > 500 then
114890: LD_VAR 0 7
114894: PPUSH
114895: CALL_OW 256
114899: PUSH
114900: LD_INT 500
114902: GREATER
114903: IFFALSE 114956
// begin e := NearestUnitToUnit ( enemy , i ) ;
114905: LD_ADDR_VAR 0 5
114909: PUSH
114910: LD_VAR 0 4
114914: PPUSH
114915: LD_VAR 0 7
114919: PPUSH
114920: CALL_OW 74
114924: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114925: LD_VAR 0 7
114929: PPUSH
114930: LD_VAR 0 5
114934: PPUSH
114935: CALL_OW 250
114939: PPUSH
114940: LD_VAR 0 5
114944: PPUSH
114945: CALL_OW 251
114949: PPUSH
114950: CALL_OW 114
// end else
114954: GO 115187
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
114956: LD_VAR 0 7
114960: PPUSH
114961: LD_EXP 50
114965: PUSH
114966: LD_VAR 0 1
114970: ARRAY
114971: PPUSH
114972: LD_INT 2
114974: PUSH
114975: LD_INT 30
114977: PUSH
114978: LD_INT 0
114980: PUSH
114981: EMPTY
114982: LIST
114983: LIST
114984: PUSH
114985: LD_INT 30
114987: PUSH
114988: LD_INT 1
114990: PUSH
114991: EMPTY
114992: LIST
114993: LIST
114994: PUSH
114995: LD_INT 30
114997: PUSH
114998: LD_INT 6
115000: PUSH
115001: EMPTY
115002: LIST
115003: LIST
115004: PUSH
115005: EMPTY
115006: LIST
115007: LIST
115008: LIST
115009: LIST
115010: PPUSH
115011: CALL_OW 72
115015: PPUSH
115016: LD_VAR 0 7
115020: PPUSH
115021: CALL_OW 74
115025: PPUSH
115026: CALL_OW 296
115030: PUSH
115031: LD_INT 10
115033: GREATER
115034: IFFALSE 115187
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115036: LD_ADDR_VAR 0 8
115040: PUSH
115041: LD_EXP 50
115045: PUSH
115046: LD_VAR 0 1
115050: ARRAY
115051: PPUSH
115052: LD_INT 2
115054: PUSH
115055: LD_INT 30
115057: PUSH
115058: LD_INT 0
115060: PUSH
115061: EMPTY
115062: LIST
115063: LIST
115064: PUSH
115065: LD_INT 30
115067: PUSH
115068: LD_INT 1
115070: PUSH
115071: EMPTY
115072: LIST
115073: LIST
115074: PUSH
115075: LD_INT 30
115077: PUSH
115078: LD_INT 6
115080: PUSH
115081: EMPTY
115082: LIST
115083: LIST
115084: PUSH
115085: EMPTY
115086: LIST
115087: LIST
115088: LIST
115089: LIST
115090: PPUSH
115091: CALL_OW 72
115095: PPUSH
115096: LD_VAR 0 7
115100: PPUSH
115101: CALL_OW 74
115105: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115106: LD_VAR 0 7
115110: PPUSH
115111: LD_VAR 0 8
115115: PPUSH
115116: CALL_OW 250
115120: PPUSH
115121: LD_INT 3
115123: PPUSH
115124: LD_INT 5
115126: PPUSH
115127: CALL_OW 272
115131: PPUSH
115132: LD_VAR 0 8
115136: PPUSH
115137: CALL_OW 251
115141: PPUSH
115142: LD_INT 3
115144: PPUSH
115145: LD_INT 5
115147: PPUSH
115148: CALL_OW 273
115152: PPUSH
115153: CALL_OW 111
// SetTag ( i , 0 ) ;
115157: LD_VAR 0 7
115161: PPUSH
115162: LD_INT 0
115164: PPUSH
115165: CALL_OW 109
// solds := solds diff i ;
115169: LD_ADDR_VAR 0 2
115173: PUSH
115174: LD_VAR 0 2
115178: PUSH
115179: LD_VAR 0 7
115183: DIFF
115184: ST_TO_ADDR
// continue ;
115185: GO 114867
// end ; end ;
115187: GO 114867
115189: POP
115190: POP
// until not solds or not enemy ;
115191: LD_VAR 0 2
115195: NOT
115196: PUSH
115197: LD_VAR 0 4
115201: NOT
115202: OR
115203: IFFALSE 114771
// MC_Reset ( base , 18 ) ;
115205: LD_VAR 0 1
115209: PPUSH
115210: LD_INT 18
115212: PPUSH
115213: CALL 22107 0 2
// end ;
115217: LD_VAR 0 3
115221: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115222: LD_INT 0
115224: PPUSH
115225: PPUSH
115226: PPUSH
115227: PPUSH
115228: PPUSH
115229: PPUSH
115230: PPUSH
115231: PPUSH
115232: PPUSH
115233: PPUSH
115234: PPUSH
115235: PPUSH
115236: PPUSH
115237: PPUSH
115238: PPUSH
115239: PPUSH
115240: PPUSH
115241: PPUSH
115242: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115243: LD_ADDR_VAR 0 12
115247: PUSH
115248: LD_EXP 50
115252: PUSH
115253: LD_VAR 0 1
115257: ARRAY
115258: PPUSH
115259: LD_INT 25
115261: PUSH
115262: LD_INT 3
115264: PUSH
115265: EMPTY
115266: LIST
115267: LIST
115268: PPUSH
115269: CALL_OW 72
115273: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115274: LD_EXP 90
115278: PUSH
115279: LD_VAR 0 1
115283: ARRAY
115284: IFFALSE 115308
// mechs := mechs diff mc_remote_driver [ base ] ;
115286: LD_ADDR_VAR 0 12
115290: PUSH
115291: LD_VAR 0 12
115295: PUSH
115296: LD_EXP 90
115300: PUSH
115301: LD_VAR 0 1
115305: ARRAY
115306: DIFF
115307: ST_TO_ADDR
// for i in mechs do
115308: LD_ADDR_VAR 0 4
115312: PUSH
115313: LD_VAR 0 12
115317: PUSH
115318: FOR_IN
115319: IFFALSE 115354
// if GetTag ( i ) > 0 then
115321: LD_VAR 0 4
115325: PPUSH
115326: CALL_OW 110
115330: PUSH
115331: LD_INT 0
115333: GREATER
115334: IFFALSE 115352
// mechs := mechs diff i ;
115336: LD_ADDR_VAR 0 12
115340: PUSH
115341: LD_VAR 0 12
115345: PUSH
115346: LD_VAR 0 4
115350: DIFF
115351: ST_TO_ADDR
115352: GO 115318
115354: POP
115355: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115356: LD_ADDR_VAR 0 8
115360: PUSH
115361: LD_EXP 50
115365: PUSH
115366: LD_VAR 0 1
115370: ARRAY
115371: PPUSH
115372: LD_INT 2
115374: PUSH
115375: LD_INT 25
115377: PUSH
115378: LD_INT 1
115380: PUSH
115381: EMPTY
115382: LIST
115383: LIST
115384: PUSH
115385: LD_INT 25
115387: PUSH
115388: LD_INT 5
115390: PUSH
115391: EMPTY
115392: LIST
115393: LIST
115394: PUSH
115395: LD_INT 25
115397: PUSH
115398: LD_INT 8
115400: PUSH
115401: EMPTY
115402: LIST
115403: LIST
115404: PUSH
115405: LD_INT 25
115407: PUSH
115408: LD_INT 9
115410: PUSH
115411: EMPTY
115412: LIST
115413: LIST
115414: PUSH
115415: EMPTY
115416: LIST
115417: LIST
115418: LIST
115419: LIST
115420: LIST
115421: PPUSH
115422: CALL_OW 72
115426: ST_TO_ADDR
// if not defenders and not solds then
115427: LD_VAR 0 2
115431: NOT
115432: PUSH
115433: LD_VAR 0 8
115437: NOT
115438: AND
115439: IFFALSE 115443
// exit ;
115441: GO 117213
// depot_under_attack := false ;
115443: LD_ADDR_VAR 0 16
115447: PUSH
115448: LD_INT 0
115450: ST_TO_ADDR
// sold_defenders := [ ] ;
115451: LD_ADDR_VAR 0 17
115455: PUSH
115456: EMPTY
115457: ST_TO_ADDR
// if mechs then
115458: LD_VAR 0 12
115462: IFFALSE 115615
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115464: LD_ADDR_VAR 0 4
115468: PUSH
115469: LD_VAR 0 2
115473: PPUSH
115474: LD_INT 21
115476: PUSH
115477: LD_INT 2
115479: PUSH
115480: EMPTY
115481: LIST
115482: LIST
115483: PPUSH
115484: CALL_OW 72
115488: PUSH
115489: FOR_IN
115490: IFFALSE 115613
// begin if GetTag ( i ) <> 20 then
115492: LD_VAR 0 4
115496: PPUSH
115497: CALL_OW 110
115501: PUSH
115502: LD_INT 20
115504: NONEQUAL
115505: IFFALSE 115519
// SetTag ( i , 20 ) ;
115507: LD_VAR 0 4
115511: PPUSH
115512: LD_INT 20
115514: PPUSH
115515: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115519: LD_VAR 0 4
115523: PPUSH
115524: CALL_OW 263
115528: PUSH
115529: LD_INT 1
115531: EQUAL
115532: PUSH
115533: LD_VAR 0 4
115537: PPUSH
115538: CALL_OW 311
115542: NOT
115543: AND
115544: IFFALSE 115611
// begin un := mechs [ 1 ] ;
115546: LD_ADDR_VAR 0 10
115550: PUSH
115551: LD_VAR 0 12
115555: PUSH
115556: LD_INT 1
115558: ARRAY
115559: ST_TO_ADDR
// ComExit ( un ) ;
115560: LD_VAR 0 10
115564: PPUSH
115565: CALL 86378 0 1
// AddComEnterUnit ( un , i ) ;
115569: LD_VAR 0 10
115573: PPUSH
115574: LD_VAR 0 4
115578: PPUSH
115579: CALL_OW 180
// SetTag ( un , 19 ) ;
115583: LD_VAR 0 10
115587: PPUSH
115588: LD_INT 19
115590: PPUSH
115591: CALL_OW 109
// mechs := mechs diff un ;
115595: LD_ADDR_VAR 0 12
115599: PUSH
115600: LD_VAR 0 12
115604: PUSH
115605: LD_VAR 0 10
115609: DIFF
115610: ST_TO_ADDR
// end ; end ;
115611: GO 115489
115613: POP
115614: POP
// if solds then
115615: LD_VAR 0 8
115619: IFFALSE 115678
// for i in solds do
115621: LD_ADDR_VAR 0 4
115625: PUSH
115626: LD_VAR 0 8
115630: PUSH
115631: FOR_IN
115632: IFFALSE 115676
// if not GetTag ( i ) then
115634: LD_VAR 0 4
115638: PPUSH
115639: CALL_OW 110
115643: NOT
115644: IFFALSE 115674
// begin defenders := defenders union i ;
115646: LD_ADDR_VAR 0 2
115650: PUSH
115651: LD_VAR 0 2
115655: PUSH
115656: LD_VAR 0 4
115660: UNION
115661: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115662: LD_VAR 0 4
115666: PPUSH
115667: LD_INT 18
115669: PPUSH
115670: CALL_OW 109
// end ;
115674: GO 115631
115676: POP
115677: POP
// repeat wait ( 0 0$2 ) ;
115678: LD_INT 70
115680: PPUSH
115681: CALL_OW 67
// enemy := mc_scan [ base ] ;
115685: LD_ADDR_VAR 0 21
115689: PUSH
115690: LD_EXP 73
115694: PUSH
115695: LD_VAR 0 1
115699: ARRAY
115700: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115701: LD_EXP 50
115705: PUSH
115706: LD_VAR 0 1
115710: ARRAY
115711: NOT
115712: PUSH
115713: LD_EXP 50
115717: PUSH
115718: LD_VAR 0 1
115722: ARRAY
115723: PUSH
115724: EMPTY
115725: EQUAL
115726: OR
115727: IFFALSE 115764
// begin for i in defenders do
115729: LD_ADDR_VAR 0 4
115733: PUSH
115734: LD_VAR 0 2
115738: PUSH
115739: FOR_IN
115740: IFFALSE 115753
// ComStop ( i ) ;
115742: LD_VAR 0 4
115746: PPUSH
115747: CALL_OW 141
115751: GO 115739
115753: POP
115754: POP
// defenders := [ ] ;
115755: LD_ADDR_VAR 0 2
115759: PUSH
115760: EMPTY
115761: ST_TO_ADDR
// exit ;
115762: GO 117213
// end ; for i in defenders do
115764: LD_ADDR_VAR 0 4
115768: PUSH
115769: LD_VAR 0 2
115773: PUSH
115774: FOR_IN
115775: IFFALSE 116673
// begin e := NearestUnitToUnit ( enemy , i ) ;
115777: LD_ADDR_VAR 0 13
115781: PUSH
115782: LD_VAR 0 21
115786: PPUSH
115787: LD_VAR 0 4
115791: PPUSH
115792: CALL_OW 74
115796: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115797: LD_ADDR_VAR 0 7
115801: PUSH
115802: LD_EXP 50
115806: PUSH
115807: LD_VAR 0 1
115811: ARRAY
115812: PPUSH
115813: LD_INT 2
115815: PUSH
115816: LD_INT 30
115818: PUSH
115819: LD_INT 0
115821: PUSH
115822: EMPTY
115823: LIST
115824: LIST
115825: PUSH
115826: LD_INT 30
115828: PUSH
115829: LD_INT 1
115831: PUSH
115832: EMPTY
115833: LIST
115834: LIST
115835: PUSH
115836: EMPTY
115837: LIST
115838: LIST
115839: LIST
115840: PPUSH
115841: CALL_OW 72
115845: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115846: LD_ADDR_VAR 0 16
115850: PUSH
115851: LD_VAR 0 7
115855: NOT
115856: PUSH
115857: LD_VAR 0 7
115861: PPUSH
115862: LD_INT 3
115864: PUSH
115865: LD_INT 24
115867: PUSH
115868: LD_INT 600
115870: PUSH
115871: EMPTY
115872: LIST
115873: LIST
115874: PUSH
115875: EMPTY
115876: LIST
115877: LIST
115878: PPUSH
115879: CALL_OW 72
115883: OR
115884: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115885: LD_VAR 0 4
115889: PPUSH
115890: CALL_OW 247
115894: PUSH
115895: LD_INT 2
115897: DOUBLE
115898: EQUAL
115899: IFTRUE 115903
115901: GO 116299
115903: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115904: LD_VAR 0 4
115908: PPUSH
115909: CALL_OW 256
115913: PUSH
115914: LD_INT 1000
115916: EQUAL
115917: PUSH
115918: LD_VAR 0 4
115922: PPUSH
115923: LD_VAR 0 13
115927: PPUSH
115928: CALL_OW 296
115932: PUSH
115933: LD_INT 40
115935: LESS
115936: PUSH
115937: LD_VAR 0 13
115941: PPUSH
115942: LD_EXP 75
115946: PUSH
115947: LD_VAR 0 1
115951: ARRAY
115952: PPUSH
115953: CALL_OW 308
115957: OR
115958: AND
115959: IFFALSE 116081
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
115961: LD_VAR 0 4
115965: PPUSH
115966: CALL_OW 262
115970: PUSH
115971: LD_INT 1
115973: EQUAL
115974: PUSH
115975: LD_VAR 0 4
115979: PPUSH
115980: CALL_OW 261
115984: PUSH
115985: LD_INT 30
115987: LESS
115988: AND
115989: PUSH
115990: LD_VAR 0 7
115994: AND
115995: IFFALSE 116065
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
115997: LD_VAR 0 4
116001: PPUSH
116002: LD_VAR 0 7
116006: PPUSH
116007: LD_VAR 0 4
116011: PPUSH
116012: CALL_OW 74
116016: PPUSH
116017: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116021: LD_VAR 0 4
116025: PPUSH
116026: LD_VAR 0 7
116030: PPUSH
116031: LD_VAR 0 4
116035: PPUSH
116036: CALL_OW 74
116040: PPUSH
116041: CALL_OW 296
116045: PUSH
116046: LD_INT 6
116048: LESS
116049: IFFALSE 116063
// SetFuel ( i , 100 ) ;
116051: LD_VAR 0 4
116055: PPUSH
116056: LD_INT 100
116058: PPUSH
116059: CALL_OW 240
// end else
116063: GO 116079
// ComAttackUnit ( i , e ) ;
116065: LD_VAR 0 4
116069: PPUSH
116070: LD_VAR 0 13
116074: PPUSH
116075: CALL_OW 115
// end else
116079: GO 116182
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116081: LD_VAR 0 13
116085: PPUSH
116086: LD_EXP 75
116090: PUSH
116091: LD_VAR 0 1
116095: ARRAY
116096: PPUSH
116097: CALL_OW 308
116101: NOT
116102: PUSH
116103: LD_VAR 0 4
116107: PPUSH
116108: LD_VAR 0 13
116112: PPUSH
116113: CALL_OW 296
116117: PUSH
116118: LD_INT 40
116120: GREATEREQUAL
116121: AND
116122: PUSH
116123: LD_VAR 0 4
116127: PPUSH
116128: CALL_OW 256
116132: PUSH
116133: LD_INT 650
116135: LESSEQUAL
116136: OR
116137: PUSH
116138: LD_VAR 0 4
116142: PPUSH
116143: LD_EXP 74
116147: PUSH
116148: LD_VAR 0 1
116152: ARRAY
116153: PPUSH
116154: CALL_OW 308
116158: NOT
116159: AND
116160: IFFALSE 116182
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116162: LD_VAR 0 4
116166: PPUSH
116167: LD_EXP 74
116171: PUSH
116172: LD_VAR 0 1
116176: ARRAY
116177: PPUSH
116178: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116182: LD_VAR 0 4
116186: PPUSH
116187: CALL_OW 256
116191: PUSH
116192: LD_INT 1000
116194: LESS
116195: PUSH
116196: LD_VAR 0 4
116200: PPUSH
116201: CALL_OW 263
116205: PUSH
116206: LD_INT 1
116208: EQUAL
116209: AND
116210: PUSH
116211: LD_VAR 0 4
116215: PPUSH
116216: CALL_OW 311
116220: AND
116221: PUSH
116222: LD_VAR 0 4
116226: PPUSH
116227: LD_EXP 74
116231: PUSH
116232: LD_VAR 0 1
116236: ARRAY
116237: PPUSH
116238: CALL_OW 308
116242: AND
116243: IFFALSE 116297
// begin mech := IsDrivenBy ( i ) ;
116245: LD_ADDR_VAR 0 9
116249: PUSH
116250: LD_VAR 0 4
116254: PPUSH
116255: CALL_OW 311
116259: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116260: LD_VAR 0 9
116264: PPUSH
116265: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116269: LD_VAR 0 9
116273: PPUSH
116274: LD_VAR 0 4
116278: PPUSH
116279: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116283: LD_VAR 0 9
116287: PPUSH
116288: LD_VAR 0 4
116292: PPUSH
116293: CALL_OW 180
// end ; end ; unit_human :
116297: GO 116644
116299: LD_INT 1
116301: DOUBLE
116302: EQUAL
116303: IFTRUE 116307
116305: GO 116643
116307: POP
// begin b := IsInUnit ( i ) ;
116308: LD_ADDR_VAR 0 18
116312: PUSH
116313: LD_VAR 0 4
116317: PPUSH
116318: CALL_OW 310
116322: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116323: LD_ADDR_VAR 0 19
116327: PUSH
116328: LD_VAR 0 18
116332: NOT
116333: PUSH
116334: LD_VAR 0 18
116338: PPUSH
116339: CALL_OW 266
116343: PUSH
116344: LD_INT 32
116346: PUSH
116347: LD_INT 31
116349: PUSH
116350: EMPTY
116351: LIST
116352: LIST
116353: IN
116354: OR
116355: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116356: LD_VAR 0 18
116360: PPUSH
116361: CALL_OW 266
116365: PUSH
116366: LD_INT 5
116368: EQUAL
116369: PUSH
116370: LD_VAR 0 4
116374: PPUSH
116375: CALL_OW 257
116379: PUSH
116380: LD_INT 1
116382: PUSH
116383: LD_INT 2
116385: PUSH
116386: LD_INT 3
116388: PUSH
116389: LD_INT 4
116391: PUSH
116392: EMPTY
116393: LIST
116394: LIST
116395: LIST
116396: LIST
116397: IN
116398: AND
116399: IFFALSE 116436
// begin class := AllowSpecClass ( i ) ;
116401: LD_ADDR_VAR 0 20
116405: PUSH
116406: LD_VAR 0 4
116410: PPUSH
116411: CALL 50365 0 1
116415: ST_TO_ADDR
// if class then
116416: LD_VAR 0 20
116420: IFFALSE 116436
// ComChangeProfession ( i , class ) ;
116422: LD_VAR 0 4
116426: PPUSH
116427: LD_VAR 0 20
116431: PPUSH
116432: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116436: LD_VAR 0 16
116440: PUSH
116441: LD_VAR 0 2
116445: PPUSH
116446: LD_INT 21
116448: PUSH
116449: LD_INT 2
116451: PUSH
116452: EMPTY
116453: LIST
116454: LIST
116455: PPUSH
116456: CALL_OW 72
116460: PUSH
116461: LD_INT 1
116463: LESSEQUAL
116464: OR
116465: PUSH
116466: LD_VAR 0 19
116470: AND
116471: PUSH
116472: LD_VAR 0 4
116476: PUSH
116477: LD_VAR 0 17
116481: IN
116482: NOT
116483: AND
116484: IFFALSE 116577
// begin if b then
116486: LD_VAR 0 18
116490: IFFALSE 116539
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116492: LD_VAR 0 18
116496: PPUSH
116497: LD_VAR 0 21
116501: PPUSH
116502: LD_VAR 0 18
116506: PPUSH
116507: CALL_OW 74
116511: PPUSH
116512: CALL_OW 296
116516: PUSH
116517: LD_INT 10
116519: LESS
116520: PUSH
116521: LD_VAR 0 18
116525: PPUSH
116526: CALL_OW 461
116530: PUSH
116531: LD_INT 7
116533: NONEQUAL
116534: AND
116535: IFFALSE 116539
// continue ;
116537: GO 115774
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116539: LD_ADDR_VAR 0 17
116543: PUSH
116544: LD_VAR 0 17
116548: PPUSH
116549: LD_VAR 0 17
116553: PUSH
116554: LD_INT 1
116556: PLUS
116557: PPUSH
116558: LD_VAR 0 4
116562: PPUSH
116563: CALL_OW 1
116567: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116568: LD_VAR 0 4
116572: PPUSH
116573: CALL_OW 122
// end ; if sold_defenders then
116577: LD_VAR 0 17
116581: IFFALSE 116641
// if i in sold_defenders then
116583: LD_VAR 0 4
116587: PUSH
116588: LD_VAR 0 17
116592: IN
116593: IFFALSE 116641
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116595: LD_VAR 0 4
116599: PPUSH
116600: CALL_OW 314
116604: NOT
116605: PUSH
116606: LD_VAR 0 4
116610: PPUSH
116611: LD_VAR 0 13
116615: PPUSH
116616: CALL_OW 296
116620: PUSH
116621: LD_INT 30
116623: LESS
116624: AND
116625: IFFALSE 116641
// ComAttackUnit ( i , e ) ;
116627: LD_VAR 0 4
116631: PPUSH
116632: LD_VAR 0 13
116636: PPUSH
116637: CALL_OW 115
// end ; end ; end ;
116641: GO 116644
116643: POP
// if IsDead ( i ) then
116644: LD_VAR 0 4
116648: PPUSH
116649: CALL_OW 301
116653: IFFALSE 116671
// defenders := defenders diff i ;
116655: LD_ADDR_VAR 0 2
116659: PUSH
116660: LD_VAR 0 2
116664: PUSH
116665: LD_VAR 0 4
116669: DIFF
116670: ST_TO_ADDR
// end ;
116671: GO 115774
116673: POP
116674: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116675: LD_VAR 0 21
116679: NOT
116680: PUSH
116681: LD_VAR 0 2
116685: NOT
116686: OR
116687: PUSH
116688: LD_EXP 50
116692: PUSH
116693: LD_VAR 0 1
116697: ARRAY
116698: NOT
116699: OR
116700: IFFALSE 115678
// MC_Reset ( base , 18 ) ;
116702: LD_VAR 0 1
116706: PPUSH
116707: LD_INT 18
116709: PPUSH
116710: CALL 22107 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116714: LD_ADDR_VAR 0 2
116718: PUSH
116719: LD_VAR 0 2
116723: PUSH
116724: LD_VAR 0 2
116728: PPUSH
116729: LD_INT 2
116731: PUSH
116732: LD_INT 25
116734: PUSH
116735: LD_INT 1
116737: PUSH
116738: EMPTY
116739: LIST
116740: LIST
116741: PUSH
116742: LD_INT 25
116744: PUSH
116745: LD_INT 5
116747: PUSH
116748: EMPTY
116749: LIST
116750: LIST
116751: PUSH
116752: LD_INT 25
116754: PUSH
116755: LD_INT 8
116757: PUSH
116758: EMPTY
116759: LIST
116760: LIST
116761: PUSH
116762: LD_INT 25
116764: PUSH
116765: LD_INT 9
116767: PUSH
116768: EMPTY
116769: LIST
116770: LIST
116771: PUSH
116772: EMPTY
116773: LIST
116774: LIST
116775: LIST
116776: LIST
116777: LIST
116778: PPUSH
116779: CALL_OW 72
116783: DIFF
116784: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116785: LD_VAR 0 21
116789: NOT
116790: PUSH
116791: LD_VAR 0 2
116795: PPUSH
116796: LD_INT 21
116798: PUSH
116799: LD_INT 2
116801: PUSH
116802: EMPTY
116803: LIST
116804: LIST
116805: PPUSH
116806: CALL_OW 72
116810: AND
116811: IFFALSE 117149
// begin tmp := FilterByTag ( defenders , 19 ) ;
116813: LD_ADDR_VAR 0 11
116817: PUSH
116818: LD_VAR 0 2
116822: PPUSH
116823: LD_INT 19
116825: PPUSH
116826: CALL 83554 0 2
116830: ST_TO_ADDR
// if tmp then
116831: LD_VAR 0 11
116835: IFFALSE 116905
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116837: LD_ADDR_VAR 0 11
116841: PUSH
116842: LD_VAR 0 11
116846: PPUSH
116847: LD_INT 25
116849: PUSH
116850: LD_INT 3
116852: PUSH
116853: EMPTY
116854: LIST
116855: LIST
116856: PPUSH
116857: CALL_OW 72
116861: ST_TO_ADDR
// if tmp then
116862: LD_VAR 0 11
116866: IFFALSE 116905
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116868: LD_ADDR_EXP 62
116872: PUSH
116873: LD_EXP 62
116877: PPUSH
116878: LD_VAR 0 1
116882: PPUSH
116883: LD_EXP 62
116887: PUSH
116888: LD_VAR 0 1
116892: ARRAY
116893: PUSH
116894: LD_VAR 0 11
116898: UNION
116899: PPUSH
116900: CALL_OW 1
116904: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116905: LD_VAR 0 1
116909: PPUSH
116910: LD_INT 19
116912: PPUSH
116913: CALL 22107 0 2
// repeat wait ( 0 0$1 ) ;
116917: LD_INT 35
116919: PPUSH
116920: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116924: LD_EXP 50
116928: PUSH
116929: LD_VAR 0 1
116933: ARRAY
116934: NOT
116935: PUSH
116936: LD_EXP 50
116940: PUSH
116941: LD_VAR 0 1
116945: ARRAY
116946: PUSH
116947: EMPTY
116948: EQUAL
116949: OR
116950: IFFALSE 116987
// begin for i in defenders do
116952: LD_ADDR_VAR 0 4
116956: PUSH
116957: LD_VAR 0 2
116961: PUSH
116962: FOR_IN
116963: IFFALSE 116976
// ComStop ( i ) ;
116965: LD_VAR 0 4
116969: PPUSH
116970: CALL_OW 141
116974: GO 116962
116976: POP
116977: POP
// defenders := [ ] ;
116978: LD_ADDR_VAR 0 2
116982: PUSH
116983: EMPTY
116984: ST_TO_ADDR
// exit ;
116985: GO 117213
// end ; for i in defenders do
116987: LD_ADDR_VAR 0 4
116991: PUSH
116992: LD_VAR 0 2
116996: PUSH
116997: FOR_IN
116998: IFFALSE 117087
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117000: LD_VAR 0 4
117004: PPUSH
117005: LD_EXP 74
117009: PUSH
117010: LD_VAR 0 1
117014: ARRAY
117015: PPUSH
117016: CALL_OW 308
117020: NOT
117021: IFFALSE 117045
// ComMoveToArea ( i , mc_parking [ base ] ) else
117023: LD_VAR 0 4
117027: PPUSH
117028: LD_EXP 74
117032: PUSH
117033: LD_VAR 0 1
117037: ARRAY
117038: PPUSH
117039: CALL_OW 113
117043: GO 117085
// if GetControl ( i ) = control_manual then
117045: LD_VAR 0 4
117049: PPUSH
117050: CALL_OW 263
117054: PUSH
117055: LD_INT 1
117057: EQUAL
117058: IFFALSE 117085
// if IsDrivenBy ( i ) then
117060: LD_VAR 0 4
117064: PPUSH
117065: CALL_OW 311
117069: IFFALSE 117085
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117071: LD_VAR 0 4
117075: PPUSH
117076: CALL_OW 311
117080: PPUSH
117081: CALL_OW 121
// end ;
117085: GO 116997
117087: POP
117088: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117089: LD_VAR 0 2
117093: PPUSH
117094: LD_INT 95
117096: PUSH
117097: LD_EXP 74
117101: PUSH
117102: LD_VAR 0 1
117106: ARRAY
117107: PUSH
117108: EMPTY
117109: LIST
117110: LIST
117111: PPUSH
117112: CALL_OW 72
117116: PUSH
117117: LD_VAR 0 2
117121: EQUAL
117122: PUSH
117123: LD_EXP 73
117127: PUSH
117128: LD_VAR 0 1
117132: ARRAY
117133: OR
117134: PUSH
117135: LD_EXP 50
117139: PUSH
117140: LD_VAR 0 1
117144: ARRAY
117145: NOT
117146: OR
117147: IFFALSE 116917
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117149: LD_ADDR_EXP 72
117153: PUSH
117154: LD_EXP 72
117158: PPUSH
117159: LD_VAR 0 1
117163: PPUSH
117164: LD_VAR 0 2
117168: PPUSH
117169: LD_INT 21
117171: PUSH
117172: LD_INT 2
117174: PUSH
117175: EMPTY
117176: LIST
117177: LIST
117178: PPUSH
117179: CALL_OW 72
117183: PPUSH
117184: CALL_OW 1
117188: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117189: LD_VAR 0 1
117193: PPUSH
117194: LD_INT 19
117196: PPUSH
117197: CALL 22107 0 2
// MC_Reset ( base , 20 ) ;
117201: LD_VAR 0 1
117205: PPUSH
117206: LD_INT 20
117208: PPUSH
117209: CALL 22107 0 2
// end ; end_of_file
117213: LD_VAR 0 3
117217: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117218: LD_VAR 0 1
117222: PUSH
117223: LD_INT 200
117225: DOUBLE
117226: GREATEREQUAL
117227: IFFALSE 117235
117229: LD_INT 299
117231: DOUBLE
117232: LESSEQUAL
117233: IFTRUE 117237
117235: GO 117269
117237: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117238: LD_VAR 0 1
117242: PPUSH
117243: LD_VAR 0 2
117247: PPUSH
117248: LD_VAR 0 3
117252: PPUSH
117253: LD_VAR 0 4
117257: PPUSH
117258: LD_VAR 0 5
117262: PPUSH
117263: CALL 105984 0 5
117267: GO 117346
117269: LD_INT 300
117271: DOUBLE
117272: GREATEREQUAL
117273: IFFALSE 117281
117275: LD_INT 399
117277: DOUBLE
117278: LESSEQUAL
117279: IFTRUE 117283
117281: GO 117345
117283: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117284: LD_VAR 0 1
117288: PPUSH
117289: LD_VAR 0 2
117293: PPUSH
117294: LD_VAR 0 3
117298: PPUSH
117299: LD_VAR 0 4
117303: PPUSH
117304: LD_VAR 0 5
117308: PPUSH
117309: LD_VAR 0 6
117313: PPUSH
117314: LD_VAR 0 7
117318: PPUSH
117319: LD_VAR 0 8
117323: PPUSH
117324: LD_VAR 0 9
117328: PPUSH
117329: LD_VAR 0 10
117333: PPUSH
117334: LD_VAR 0 11
117338: PPUSH
117339: CALL 102313 0 11
117343: GO 117346
117345: POP
// end ;
117346: PPOPN 11
117348: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117349: LD_VAR 0 1
117353: PPUSH
117354: LD_VAR 0 2
117358: PPUSH
117359: LD_VAR 0 3
117363: PPUSH
117364: LD_VAR 0 4
117368: PPUSH
117369: LD_VAR 0 5
117373: PPUSH
117374: CALL 105720 0 5
// end ; end_of_file
117378: PPOPN 5
117380: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117381: LD_VAR 0 1
117385: PPUSH
117386: LD_VAR 0 2
117390: PPUSH
117391: LD_VAR 0 3
117395: PPUSH
117396: LD_VAR 0 4
117400: PPUSH
117401: LD_VAR 0 5
117405: PPUSH
117406: LD_VAR 0 6
117410: PPUSH
117411: CALL 90006 0 6
// end ;
117415: PPOPN 6
117417: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117418: LD_INT 0
117420: PPUSH
// begin if not units then
117421: LD_VAR 0 1
117425: NOT
117426: IFFALSE 117430
// exit ;
117428: GO 117430
// end ;
117430: PPOPN 7
117432: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117433: CALL 89977 0 0
// end ;
117437: PPOPN 1
117439: END
