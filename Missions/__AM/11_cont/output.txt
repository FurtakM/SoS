// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18397 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83484 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20577 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42294 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42294 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42294 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42739 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42631 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42631 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49105 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49105 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49105 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49105 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49105 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49105 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49105 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49105 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49105 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49105 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49105 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49105 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49105 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49105 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49105 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57766 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57766 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57766 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57766 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57766 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 53945 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 53945 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54067 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43027 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42631 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 55331 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42631 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 53945 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54067 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42864 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54067 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54067 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42864 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54067 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42864 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 53945 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54067 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54067 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54067 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42864 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 53945 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54067 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 53945 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54067 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42864 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 9 9$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54067 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42631 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42631 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 88190 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: PUSH
7569: LD_INT 4
7571: GREATEREQUAL
7572: PUSH
7573: LD_VAR 0 7
7577: PUSH
7578: LD_INT 0
7580: LESSEQUAL
7581: OR
7582: IFFALSE 7498
// wait ( 0 0$10 ) ;
7584: LD_INT 350
7586: PPUSH
7587: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7591: LD_ADDR_VAR 0 2
7595: PUSH
7596: LD_EXP 69
7600: PUSH
7601: LD_INT 1
7603: ARRAY
7604: PPUSH
7605: LD_INT 3
7607: PUSH
7608: LD_INT 2
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 32
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 34
7623: PUSH
7624: LD_INT 88
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 72
7644: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7645: LD_ADDR_VAR 0 3
7649: PUSH
7650: LD_EXP 69
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: LD_INT 3
7661: PUSH
7662: LD_INT 2
7664: PUSH
7665: LD_INT 34
7667: PUSH
7668: LD_INT 32
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 34
7677: PUSH
7678: LD_INT 88
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL_OW 72
7698: ST_TO_ADDR
// if tmp2 then
7699: LD_VAR 0 3
7703: IFFALSE 7721
// tmp := tmp union tmp2 ;
7705: LD_ADDR_VAR 0 2
7709: PUSH
7710: LD_VAR 0 2
7714: PUSH
7715: LD_VAR 0 3
7719: UNION
7720: ST_TO_ADDR
// if not tmp then
7721: LD_VAR 0 2
7725: NOT
7726: IFFALSE 7730
// exit ;
7728: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7730: LD_VAR 0 3
7734: PPUSH
7735: CALL 51207 0 1
7739: PUSH
7740: LD_INT 50
7742: PPUSH
7743: CALL_OW 13
7747: OR
7748: IFFALSE 7781
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7750: LD_ADDR_VAR 0 4
7754: PUSH
7755: LD_INT 48
7757: PUSH
7758: LD_INT 33
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 71
7767: PUSH
7768: LD_INT 88
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: ST_TO_ADDR
7779: GO 7810
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7781: LD_ADDR_VAR 0 4
7785: PUSH
7786: LD_INT 128
7788: PUSH
7789: LD_INT 94
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 180
7798: PUSH
7799: LD_INT 135
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: ST_TO_ADDR
// if w = 3 then
7810: LD_VAR 0 5
7814: PUSH
7815: LD_INT 3
7817: EQUAL
7818: IFFALSE 7849
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7820: LD_ADDR_VAR 0 4
7824: PUSH
7825: LD_INT 91
7827: PUSH
7828: LD_INT 58
7830: PUSH
7831: EMPTY
7832: LIST
7833: LIST
7834: PUSH
7835: LD_INT 117
7837: PUSH
7838: LD_INT 107
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7849: LD_INT 28
7851: PPUSH
7852: LD_INT 22
7854: PUSH
7855: LD_INT 1
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 70
7866: IFFALSE 7886
// coords := [ [ 163 , 41 ] ] ;
7868: LD_ADDR_VAR 0 4
7872: PUSH
7873: LD_INT 163
7875: PUSH
7876: LD_INT 41
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: EMPTY
7884: LIST
7885: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7886: LD_VAR 0 2
7890: PPUSH
7891: LD_VAR 0 4
7895: PUSH
7896: LD_INT 1
7898: ARRAY
7899: PPUSH
7900: LD_VAR 0 4
7904: PUSH
7905: LD_INT 2
7907: ARRAY
7908: PPUSH
7909: CALL_OW 114
// p := 90 ;
7913: LD_ADDR_VAR 0 7
7917: PUSH
7918: LD_INT 90
7920: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7921: LD_INT 35
7923: PPUSH
7924: CALL_OW 67
// p := Dec ( p ) ;
7928: LD_ADDR_VAR 0 7
7932: PUSH
7933: LD_VAR 0 7
7937: PPUSH
7938: CALL 88190 0 1
7942: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7943: LD_VAR 0 2
7947: PPUSH
7948: LD_INT 60
7950: PUSH
7951: EMPTY
7952: LIST
7953: PPUSH
7954: CALL_OW 72
7958: PUSH
7959: LD_INT 0
7961: EQUAL
7962: PUSH
7963: LD_VAR 0 7
7967: PUSH
7968: LD_INT 0
7970: LESSEQUAL
7971: OR
7972: IFFALSE 7921
// repeat wait ( 0 0$2 ) ;
7974: LD_INT 70
7976: PPUSH
7977: CALL_OW 67
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82410 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7974
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 53945 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 53945 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54067 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 87205 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 16947 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16769 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 16947 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 16947 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16769 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 16947 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 16947 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17173 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17173 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16769 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 16947 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 16947 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16769 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 16947 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 16947 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16769 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 16947 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 16947 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 16947 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 16947 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 16947 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 55331 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15851 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15844: CALL 15851 0 0
// end ;
15848: PPOPN 1
15850: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15851: LD_INT 0
15853: PPUSH
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// m1 := false ;
15858: LD_ADDR_VAR 0 3
15862: PUSH
15863: LD_INT 0
15865: ST_TO_ADDR
// m2 := false ;
15866: LD_ADDR_VAR 0 4
15870: PUSH
15871: LD_INT 0
15873: ST_TO_ADDR
// m3 := false ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_INT 0
15881: ST_TO_ADDR
// if not am_veh_consturcted then
15882: LD_EXP 20
15886: NOT
15887: IFFALSE 15896
// SetAchievement ( ACH_ARABTECH ) ;
15889: LD_STRING ACH_ARABTECH
15891: PPUSH
15892: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15896: LD_OWVAR 1
15900: PUSH
15901: LD_INT 252000
15903: PUSH
15904: LD_INT 210000
15906: PUSH
15907: LD_INT 199500
15909: PUSH
15910: LD_INT 193200
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: LIST
15917: LIST
15918: PUSH
15919: LD_OWVAR 67
15923: ARRAY
15924: LESS
15925: IFFALSE 15947
// begin m3 := true ;
15927: LD_ADDR_VAR 0 5
15931: PUSH
15932: LD_INT 1
15934: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15935: LD_STRING Time1
15937: PPUSH
15938: LD_INT 1
15940: PPUSH
15941: CALL_OW 101
// end else
15945: GO 15978
// if not powell_warn then
15947: LD_EXP 16
15951: NOT
15952: IFFALSE 15967
// AddMedal ( Time1 , - 1 ) else
15954: LD_STRING Time1
15956: PPUSH
15957: LD_INT 1
15959: NEG
15960: PPUSH
15961: CALL_OW 101
15965: GO 15978
// AddMedal ( Time1 , - 2 ) ;
15967: LD_STRING Time1
15969: PPUSH
15970: LD_INT 2
15972: NEG
15973: PPUSH
15974: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15978: LD_EXP 17
15982: PUSH
15983: LD_INT 5
15985: PUSH
15986: LD_INT 4
15988: PUSH
15989: LD_INT 3
15991: PUSH
15992: LD_INT 3
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: PUSH
16001: LD_OWVAR 67
16005: ARRAY
16006: GREATEREQUAL
16007: IFFALSE 16022
// AddMedal ( Destroy , - 2 ) else
16009: LD_STRING Destroy
16011: PPUSH
16012: LD_INT 2
16014: NEG
16015: PPUSH
16016: CALL_OW 101
16020: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16022: LD_INT 22
16024: PUSH
16025: LD_INT 2
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PUSH
16032: LD_INT 21
16034: PUSH
16035: LD_INT 3
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: PUSH
16042: LD_INT 50
16044: PUSH
16045: EMPTY
16046: LIST
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: LIST
16052: PPUSH
16053: CALL_OW 69
16057: PUSH
16058: LD_INT 25
16060: GREATEREQUAL
16061: IFFALSE 16076
// AddMedal ( Destroy , - 1 ) else
16063: LD_STRING Destroy
16065: PPUSH
16066: LD_INT 1
16068: NEG
16069: PPUSH
16070: CALL_OW 101
16074: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16076: LD_INT 22
16078: PUSH
16079: LD_INT 2
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PUSH
16086: LD_INT 21
16088: PUSH
16089: LD_INT 3
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: LD_INT 50
16098: PUSH
16099: EMPTY
16100: LIST
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: PPUSH
16107: CALL_OW 69
16111: PUSH
16112: LD_INT 15
16114: GREATEREQUAL
16115: IFFALSE 16137
// begin m1 := true ;
16117: LD_ADDR_VAR 0 3
16121: PUSH
16122: LD_INT 1
16124: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16125: LD_STRING Destroy
16127: PPUSH
16128: LD_INT 1
16130: PPUSH
16131: CALL_OW 101
// end else
16135: GO 16155
// begin m1 := true ;
16137: LD_ADDR_VAR 0 3
16141: PUSH
16142: LD_INT 1
16144: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16145: LD_STRING Destroy
16147: PPUSH
16148: LD_INT 2
16150: PPUSH
16151: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16155: LD_EXP 13
16159: PPUSH
16160: LD_STRING 11_artifact_captured
16162: PPUSH
16163: CALL_OW 39
// if artifact_get then
16167: LD_EXP 13
16171: IFFALSE 16193
// begin m2 := true ;
16173: LD_ADDR_VAR 0 4
16177: PUSH
16178: LD_INT 1
16180: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16181: LD_STRING Artefact
16183: PPUSH
16184: LD_INT 1
16186: PPUSH
16187: CALL_OW 101
// end else
16191: GO 16204
// AddMedal ( Artefact , - 1 ) ;
16193: LD_STRING Artefact
16195: PPUSH
16196: LD_INT 1
16198: NEG
16199: PPUSH
16200: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16204: LD_VAR 0 3
16208: PUSH
16209: LD_VAR 0 4
16213: AND
16214: PUSH
16215: LD_VAR 0 5
16219: AND
16220: PUSH
16221: LD_OWVAR 67
16225: PUSH
16226: LD_INT 3
16228: GREATEREQUAL
16229: AND
16230: IFFALSE 16242
// SetAchievementEX ( ACH_AMER , 11 ) ;
16232: LD_STRING ACH_AMER
16234: PPUSH
16235: LD_INT 11
16237: PPUSH
16238: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16242: LD_VAR 0 3
16246: PUSH
16247: LD_VAR 0 4
16251: AND
16252: PUSH
16253: LD_VAR 0 5
16257: AND
16258: PUSH
16259: LD_EXP 17
16263: PUSH
16264: LD_INT 0
16266: EQUAL
16267: AND
16268: IFFALSE 16284
// begin wait ( 3 ) ;
16270: LD_INT 3
16272: PPUSH
16273: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16277: LD_STRING ACH_GENERAL
16279: PPUSH
16280: CALL_OW 543
// end ; if tick <= 100 100$00 then
16284: LD_OWVAR 1
16288: PUSH
16289: LD_INT 210000
16291: LESSEQUAL
16292: IFFALSE 16308
// begin wait ( 3 ) ;
16294: LD_INT 3
16296: PPUSH
16297: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16301: LD_STRING ACH_ASPEED_11
16303: PPUSH
16304: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16308: LD_STRING MAIN
16310: PPUSH
16311: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16315: LD_ADDR_EXP 19
16319: PUSH
16320: LD_EXP 19
16324: PPUSH
16325: LD_INT 51
16327: PUSH
16328: EMPTY
16329: LIST
16330: PPUSH
16331: CALL_OW 72
16335: ST_TO_ADDR
// tmp := JMM ^ selected ;
16336: LD_ADDR_VAR 0 2
16340: PUSH
16341: LD_EXP 21
16345: PUSH
16346: LD_EXP 19
16350: ADD
16351: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16352: LD_VAR 0 2
16356: PPUSH
16357: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16361: LD_VAR 0 2
16365: PUSH
16366: LD_EXP 21
16370: PUSH
16371: LD_EXP 22
16375: PUSH
16376: LD_EXP 23
16380: PUSH
16381: LD_EXP 24
16385: PUSH
16386: LD_EXP 25
16390: PUSH
16391: LD_EXP 26
16395: PUSH
16396: LD_EXP 27
16400: PUSH
16401: LD_EXP 28
16405: PUSH
16406: LD_EXP 29
16410: PUSH
16411: LD_EXP 31
16415: PUSH
16416: LD_EXP 32
16420: PUSH
16421: LD_EXP 33
16425: PUSH
16426: LD_EXP 34
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: DIFF
16446: PPUSH
16447: LD_STRING 11c_others
16449: PPUSH
16450: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16454: LD_EXP 21
16458: PPUSH
16459: LD_EXP 3
16463: PUSH
16464: LD_STRING JMM
16466: STR
16467: PPUSH
16468: CALL_OW 38
// if Lisa then
16472: LD_EXP 22
16476: IFFALSE 16496
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16478: LD_EXP 22
16482: PPUSH
16483: LD_EXP 3
16487: PUSH
16488: LD_STRING Lisa
16490: STR
16491: PPUSH
16492: CALL_OW 38
// if Donaldson then
16496: LD_EXP 23
16500: IFFALSE 16520
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16502: LD_EXP 23
16506: PPUSH
16507: LD_EXP 3
16511: PUSH
16512: LD_STRING Donaldson
16514: STR
16515: PPUSH
16516: CALL_OW 38
// if Bobby then
16520: LD_EXP 24
16524: IFFALSE 16544
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16526: LD_EXP 24
16530: PPUSH
16531: LD_EXP 3
16535: PUSH
16536: LD_STRING Bobby
16538: STR
16539: PPUSH
16540: CALL_OW 38
// if Cyrus then
16544: LD_EXP 25
16548: IFFALSE 16568
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16550: LD_EXP 25
16554: PPUSH
16555: LD_EXP 3
16559: PUSH
16560: LD_STRING Cyrus
16562: STR
16563: PPUSH
16564: CALL_OW 38
// if Denis then
16568: LD_EXP 26
16572: IFFALSE 16592
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16574: LD_EXP 26
16578: PPUSH
16579: LD_EXP 3
16583: PUSH
16584: LD_STRING Denis
16586: STR
16587: PPUSH
16588: CALL_OW 38
// if Brown then
16592: LD_EXP 27
16596: IFFALSE 16616
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16598: LD_EXP 27
16602: PPUSH
16603: LD_EXP 3
16607: PUSH
16608: LD_STRING Brown
16610: STR
16611: PPUSH
16612: CALL_OW 38
// if Gladstone then
16616: LD_EXP 28
16620: IFFALSE 16640
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16622: LD_EXP 28
16626: PPUSH
16627: LD_EXP 3
16631: PUSH
16632: LD_STRING Gladstone
16634: STR
16635: PPUSH
16636: CALL_OW 38
// if Houten then
16640: LD_EXP 29
16644: IFFALSE 16664
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16646: LD_EXP 29
16650: PPUSH
16651: LD_EXP 3
16655: PUSH
16656: LD_STRING Houten
16658: STR
16659: PPUSH
16660: CALL_OW 38
// if Cornel then
16664: LD_EXP 31
16668: IFFALSE 16688
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16670: LD_EXP 31
16674: PPUSH
16675: LD_EXP 3
16679: PUSH
16680: LD_STRING Cornell
16682: STR
16683: PPUSH
16684: CALL_OW 38
// if Gary then
16688: LD_EXP 32
16692: IFFALSE 16712
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16694: LD_EXP 32
16698: PPUSH
16699: LD_EXP 3
16703: PUSH
16704: LD_STRING Gary
16706: STR
16707: PPUSH
16708: CALL_OW 38
// if Frank then
16712: LD_EXP 33
16716: IFFALSE 16736
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16718: LD_EXP 33
16722: PPUSH
16723: LD_EXP 3
16727: PUSH
16728: LD_STRING Frank
16730: STR
16731: PPUSH
16732: CALL_OW 38
// if Kikuchi then
16736: LD_EXP 34
16740: IFFALSE 16760
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16742: LD_EXP 34
16746: PPUSH
16747: LD_EXP 3
16751: PUSH
16752: LD_STRING Kikuchi
16754: STR
16755: PPUSH
16756: CALL_OW 38
// YouWin ;
16760: CALL_OW 103
// end ;
16764: LD_VAR 0 1
16768: RET
// export function CanSayRand ( side ) ; begin
16769: LD_INT 0
16771: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16772: LD_ADDR_VAR 0 2
16776: PUSH
16777: LD_INT 52
16779: PUSH
16780: EMPTY
16781: LIST
16782: PUSH
16783: LD_INT 22
16785: PUSH
16786: LD_VAR 0 1
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 25
16800: PUSH
16801: LD_INT 1
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 25
16810: PUSH
16811: LD_INT 2
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 3
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: LD_INT 25
16830: PUSH
16831: LD_INT 4
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: LIST
16849: PPUSH
16850: CALL_OW 69
16854: PUSH
16855: LD_EXP 21
16859: PUSH
16860: LD_EXP 33
16864: PUSH
16865: LD_EXP 22
16869: PUSH
16870: LD_EXP 23
16874: PUSH
16875: LD_EXP 24
16879: PUSH
16880: LD_EXP 25
16884: PUSH
16885: LD_EXP 26
16889: PUSH
16890: LD_EXP 27
16894: PUSH
16895: LD_EXP 28
16899: PUSH
16900: LD_EXP 29
16904: PUSH
16905: LD_EXP 30
16909: PUSH
16910: LD_EXP 31
16914: PUSH
16915: LD_EXP 32
16919: PUSH
16920: LD_EXP 34
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: DIFF
16941: ST_TO_ADDR
// end ;
16942: LD_VAR 0 2
16946: RET
// export function SayRand ( sex , dial ) ; begin
16947: LD_INT 0
16949: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16950: LD_ADDR_VAR 0 3
16954: PUSH
16955: LD_INT 52
16957: PUSH
16958: EMPTY
16959: LIST
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_INT 1
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 26
16973: PUSH
16974: LD_VAR 0 1
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PUSH
16983: LD_INT 2
16985: PUSH
16986: LD_INT 25
16988: PUSH
16989: LD_INT 1
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: PUSH
16996: LD_INT 25
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: PUSH
17006: LD_INT 25
17008: PUSH
17009: LD_INT 3
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: PUSH
17016: LD_INT 25
17018: PUSH
17019: LD_INT 4
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: LIST
17030: LIST
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: LIST
17037: LIST
17038: PPUSH
17039: CALL_OW 69
17043: PUSH
17044: LD_EXP 21
17048: PUSH
17049: LD_EXP 33
17053: PUSH
17054: LD_EXP 22
17058: PUSH
17059: LD_EXP 23
17063: PUSH
17064: LD_EXP 24
17068: PUSH
17069: LD_EXP 25
17073: PUSH
17074: LD_EXP 26
17078: PUSH
17079: LD_EXP 27
17083: PUSH
17084: LD_EXP 28
17088: PUSH
17089: LD_EXP 29
17093: PUSH
17094: LD_EXP 30
17098: PUSH
17099: LD_EXP 31
17103: PUSH
17104: LD_EXP 32
17108: PUSH
17109: LD_EXP 34
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: LIST
17128: LIST
17129: DIFF
17130: ST_TO_ADDR
// if not result then
17131: LD_VAR 0 3
17135: NOT
17136: IFFALSE 17140
// exit ;
17138: GO 17168
// result := result [ 1 ] ;
17140: LD_ADDR_VAR 0 3
17144: PUSH
17145: LD_VAR 0 3
17149: PUSH
17150: LD_INT 1
17152: ARRAY
17153: ST_TO_ADDR
// Say ( result , dial ) ;
17154: LD_VAR 0 3
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL_OW 88
// end ;
17168: LD_VAR 0 3
17172: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17173: LD_INT 0
17175: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17176: LD_ADDR_VAR 0 4
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 26
17193: PUSH
17194: LD_VAR 0 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: LD_INT 2
17205: PUSH
17206: LD_INT 25
17208: PUSH
17209: LD_INT 1
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PUSH
17216: LD_INT 25
17218: PUSH
17219: LD_INT 2
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 25
17228: PUSH
17229: LD_INT 3
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: LD_INT 25
17238: PUSH
17239: LD_INT 4
17241: PUSH
17242: EMPTY
17243: LIST
17244: LIST
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: PPUSH
17258: CALL_OW 69
17262: PUSH
17263: LD_EXP 21
17267: PUSH
17268: LD_EXP 33
17272: PUSH
17273: LD_EXP 22
17277: PUSH
17278: LD_EXP 23
17282: PUSH
17283: LD_EXP 24
17287: PUSH
17288: LD_EXP 25
17292: PUSH
17293: LD_EXP 26
17297: PUSH
17298: LD_EXP 27
17302: PUSH
17303: LD_EXP 28
17307: PUSH
17308: LD_EXP 29
17312: PUSH
17313: LD_EXP 30
17317: PUSH
17318: LD_EXP 31
17322: PUSH
17323: LD_EXP 32
17327: PUSH
17328: LD_EXP 34
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: LIST
17340: LIST
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: PUSH
17349: LD_VAR 0 3
17353: ADD
17354: DIFF
17355: ST_TO_ADDR
// if not result then
17356: LD_VAR 0 4
17360: NOT
17361: IFFALSE 17365
// exit ;
17363: GO 17393
// result := result [ 1 ] ;
17365: LD_ADDR_VAR 0 4
17369: PUSH
17370: LD_VAR 0 4
17374: PUSH
17375: LD_INT 1
17377: ARRAY
17378: ST_TO_ADDR
// Say ( result , dial ) ;
17379: LD_VAR 0 4
17383: PPUSH
17384: LD_VAR 0 2
17388: PPUSH
17389: CALL_OW 88
// end ; end_of_file
17393: LD_VAR 0 4
17397: RET
// export function CustomEvent ( event ) ; begin
17398: LD_INT 0
17400: PPUSH
// end ;
17401: LD_VAR 0 2
17405: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17406: LD_VAR 0 1
17410: PPUSH
17411: CALL_OW 255
17415: PUSH
17416: LD_INT 1
17418: EQUAL
17419: IFFALSE 17429
// artifact_get := true ;
17421: LD_ADDR_EXP 13
17425: PUSH
17426: LD_INT 1
17428: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17429: LD_VAR 0 1
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 2
17441: EQUAL
17442: IFFALSE 17460
// begin artifact_get := false ;
17444: LD_ADDR_EXP 13
17448: PUSH
17449: LD_INT 0
17451: ST_TO_ADDR
// artifact_stolen := true ;
17452: LD_ADDR_EXP 12
17456: PUSH
17457: LD_INT 1
17459: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17460: LD_ADDR_EXP 14
17464: PUSH
17465: LD_INT 1
17467: ST_TO_ADDR
// end ;
17468: PPOPN 2
17470: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17471: LD_ADDR_EXP 14
17475: PUSH
17476: LD_INT 0
17478: ST_TO_ADDR
// end ;
17479: PPOPN 2
17481: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17482: LD_VAR 0 1
17486: PPUSH
17487: CALL 107072 0 1
// if un = JMM then
17491: LD_VAR 0 1
17495: PUSH
17496: LD_EXP 21
17500: EQUAL
17501: IFFALSE 17512
// begin YouLost ( JMM ) ;
17503: LD_STRING JMM
17505: PPUSH
17506: CALL_OW 104
// exit ;
17510: GO 17644
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17512: LD_VAR 0 1
17516: PUSH
17517: LD_INT 22
17519: PUSH
17520: LD_INT 1
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: PUSH
17527: LD_INT 21
17529: PUSH
17530: LD_INT 1
17532: PUSH
17533: EMPTY
17534: LIST
17535: LIST
17536: PUSH
17537: LD_INT 2
17539: PUSH
17540: LD_INT 25
17542: PUSH
17543: LD_INT 1
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: PUSH
17550: LD_INT 25
17552: PUSH
17553: LD_INT 2
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PUSH
17560: LD_INT 25
17562: PUSH
17563: LD_INT 3
17565: PUSH
17566: EMPTY
17567: LIST
17568: LIST
17569: PUSH
17570: LD_INT 25
17572: PUSH
17573: LD_INT 4
17575: PUSH
17576: EMPTY
17577: LIST
17578: LIST
17579: PUSH
17580: LD_INT 25
17582: PUSH
17583: LD_INT 5
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: PUSH
17590: LD_INT 25
17592: PUSH
17593: LD_INT 8
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: PPUSH
17614: CALL_OW 69
17618: IN
17619: IFFALSE 17635
// loses_counter := loses_counter + 1 ;
17621: LD_ADDR_EXP 17
17625: PUSH
17626: LD_EXP 17
17630: PUSH
17631: LD_INT 1
17633: PLUS
17634: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL 46121 0 1
// end ;
17644: PPOPN 1
17646: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17647: LD_VAR 0 1
17651: PPUSH
17652: LD_VAR 0 2
17656: PPUSH
17657: CALL 48453 0 2
// end ;
17661: PPOPN 2
17663: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17664: LD_VAR 0 1
17668: PPUSH
17669: CALL 47762 0 1
// end ;
17673: PPOPN 1
17675: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: LD_VAR 0 2
17685: PPUSH
17686: LD_VAR 0 3
17690: PPUSH
17691: LD_VAR 0 4
17695: PPUSH
17696: LD_VAR 0 5
17700: PPUSH
17701: CALL 45437 0 5
// end ;
17705: PPOPN 5
17707: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17708: LD_VAR 0 1
17712: PPUSH
17713: LD_VAR 0 2
17717: PPUSH
17718: CALL 107192 0 2
// if GetNation ( vehicle ) = nation_american then
17722: LD_VAR 0 1
17726: PPUSH
17727: CALL_OW 248
17731: PUSH
17732: LD_INT 1
17734: EQUAL
17735: IFFALSE 17745
// am_veh_consturcted := true ;
17737: LD_ADDR_EXP 20
17741: PUSH
17742: LD_INT 1
17744: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_VAR 0 2
17754: PPUSH
17755: CALL 44990 0 2
// end ;
17759: PPOPN 2
17761: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17762: LD_VAR 0 1
17766: PPUSH
17767: CALL_OW 247
17771: PUSH
17772: LD_INT 2
17774: EQUAL
17775: IFFALSE 17779
// exit ;
17777: GO 17796
// if not kamikazed then
17779: LD_EXP 11
17783: NOT
17784: IFFALSE 17796
// kamikazed := unit ;
17786: LD_ADDR_EXP 11
17790: PUSH
17791: LD_VAR 0 1
17795: ST_TO_ADDR
// end ;
17796: PPOPN 1
17798: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17799: LD_INT 0
17801: PPUSH
17802: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17803: LD_VAR 0 1
17807: PPUSH
17808: LD_VAR 0 2
17812: PPUSH
17813: LD_VAR 0 3
17817: PPUSH
17818: LD_VAR 0 4
17822: PPUSH
17823: CALL 44828 0 4
// end ;
17827: PPOPN 6
17829: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17830: LD_INT 0
17832: PPUSH
// begin if building = ar_dep_n then
17833: LD_VAR 0 1
17837: PUSH
17838: LD_INT 94
17840: EQUAL
17841: IFFALSE 17893
// begin for i := 1 to 3 do
17843: LD_ADDR_VAR 0 4
17847: PUSH
17848: DOUBLE
17849: LD_INT 1
17851: DEC
17852: ST_TO_ADDR
17853: LD_INT 3
17855: PUSH
17856: FOR_TO
17857: IFFALSE 17891
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17859: LD_INT 115
17861: PUSH
17862: LD_VAR 0 4
17866: PUSH
17867: LD_INT 2
17869: MUL
17870: PLUS
17871: PPUSH
17872: LD_INT 6
17874: PPUSH
17875: LD_INT 1
17877: PPUSH
17878: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17882: LD_INT 10
17884: PPUSH
17885: CALL_OW 67
// end ;
17889: GO 17856
17891: POP
17892: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17893: LD_VAR 0 1
17897: PPUSH
17898: LD_VAR 0 2
17902: PPUSH
17903: LD_VAR 0 3
17907: PPUSH
17908: CALL 44603 0 3
// end ;
17912: PPOPN 4
17914: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17915: LD_VAR 0 1
17919: PPUSH
17920: LD_VAR 0 2
17924: PPUSH
17925: CALL 45817 0 2
// end ;
17929: PPOPN 2
17931: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17932: LD_VAR 0 1
17936: PPUSH
17937: LD_VAR 0 2
17941: PPUSH
17942: CALL 44297 0 2
// end ;
17946: PPOPN 2
17948: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17949: LD_VAR 0 1
17953: PPUSH
17954: LD_VAR 0 2
17958: PPUSH
17959: CALL 44488 0 2
// end ;
17963: PPOPN 2
17965: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17966: LD_VAR 0 1
17970: PPUSH
17971: CALL 47521 0 1
// end ;
17975: PPOPN 1
17977: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17978: LD_VAR 0 1
17982: PPUSH
17983: LD_VAR 0 2
17987: PPUSH
17988: CALL 48748 0 2
// end ;
17992: PPOPN 2
17994: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17995: LD_VAR 0 1
17999: PPUSH
18000: LD_VAR 0 2
18004: PPUSH
18005: LD_VAR 0 3
18009: PPUSH
18010: LD_VAR 0 4
18014: PPUSH
18015: CALL 48964 0 4
// end ;
18019: PPOPN 4
18021: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: CALL 107176 0 1
// end ;
18031: PPOPN 1
18033: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18034: LD_INT 22
18036: PUSH
18037: LD_INT 2
18039: PUSH
18040: EMPTY
18041: LIST
18042: LIST
18043: PUSH
18044: LD_INT 50
18046: PUSH
18047: EMPTY
18048: LIST
18049: PUSH
18050: LD_INT 21
18052: PUSH
18053: LD_INT 1
18055: PUSH
18056: EMPTY
18057: LIST
18058: LIST
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: PPUSH
18065: CALL_OW 69
18069: IFFALSE 18153
18071: GO 18073
18073: DISABLE
18074: LD_INT 0
18076: PPUSH
// begin enable ;
18077: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18078: LD_ADDR_VAR 0 1
18082: PUSH
18083: LD_INT 22
18085: PUSH
18086: LD_INT 2
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: LD_INT 50
18095: PUSH
18096: EMPTY
18097: LIST
18098: PUSH
18099: LD_INT 21
18101: PUSH
18102: LD_INT 1
18104: PUSH
18105: EMPTY
18106: LIST
18107: LIST
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PPUSH
18114: CALL_OW 69
18118: PUSH
18119: FOR_IN
18120: IFFALSE 18151
// if GetFuel ( i ) < 3 then
18122: LD_VAR 0 1
18126: PPUSH
18127: CALL_OW 261
18131: PUSH
18132: LD_INT 3
18134: LESS
18135: IFFALSE 18149
// SetFuel ( i , 5 ) ;
18137: LD_VAR 0 1
18141: PPUSH
18142: LD_INT 5
18144: PPUSH
18145: CALL_OW 240
18149: GO 18119
18151: POP
18152: POP
// end ; end_of_file
18153: PPOPN 1
18155: END
// every 0 0$1 trigger game do
18156: LD_EXP 2
18160: IFFALSE 18190
18162: GO 18164
18164: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18165: LD_INT 7
18167: PUSH
18168: LD_INT 6
18170: PUSH
18171: LD_INT 4
18173: PUSH
18174: LD_INT 6
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: PPUSH
18183: LD_INT 1750
18185: PPUSH
18186: CALL 18191 0 2
18190: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18191: LD_INT 0
18193: PPUSH
18194: PPUSH
18195: PPUSH
// if not areas then
18196: LD_VAR 0 1
18200: NOT
18201: IFFALSE 18205
// exit ;
18203: GO 18335
// repeat wait ( time ) ;
18205: LD_VAR 0 2
18209: PPUSH
18210: CALL_OW 67
// for i in areas do
18214: LD_ADDR_VAR 0 4
18218: PUSH
18219: LD_VAR 0 1
18223: PUSH
18224: FOR_IN
18225: IFFALSE 18294
// begin p := rand ( 1 , 90 ) ;
18227: LD_ADDR_VAR 0 5
18231: PUSH
18232: LD_INT 1
18234: PPUSH
18235: LD_INT 90
18237: PPUSH
18238: CALL_OW 12
18242: ST_TO_ADDR
// if Prob ( p ) then
18243: LD_VAR 0 5
18247: PPUSH
18248: CALL_OW 13
18252: IFFALSE 18292
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18254: LD_INT 2
18256: PPUSH
18257: LD_INT 5
18259: PPUSH
18260: CALL_OW 12
18264: PPUSH
18265: LD_VAR 0 4
18269: PPUSH
18270: LD_INT 1
18272: PPUSH
18273: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18277: LD_INT 735
18279: PPUSH
18280: LD_INT 1295
18282: PPUSH
18283: CALL_OW 12
18287: PPUSH
18288: CALL_OW 67
// end ; end ;
18292: GO 18224
18294: POP
18295: POP
// time := time + 0 0$3 ;
18296: LD_ADDR_VAR 0 2
18300: PUSH
18301: LD_VAR 0 2
18305: PUSH
18306: LD_INT 105
18308: PLUS
18309: ST_TO_ADDR
// if time > 3 3$00 then
18310: LD_VAR 0 2
18314: PUSH
18315: LD_INT 6300
18317: GREATER
18318: IFFALSE 18328
// time := 0 0$40 ;
18320: LD_ADDR_VAR 0 2
18324: PUSH
18325: LD_INT 1400
18327: ST_TO_ADDR
// until not game ;
18328: LD_EXP 2
18332: NOT
18333: IFFALSE 18205
// end ;
18335: LD_VAR 0 3
18339: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18340: LD_OWVAR 1
18344: PUSH
18345: LD_INT 84000
18347: PUSH
18348: LD_INT 73500
18350: PUSH
18351: LD_INT 63000
18353: PUSH
18354: LD_INT 52500
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: PUSH
18363: LD_OWVAR 67
18367: ARRAY
18368: LESS
18369: IFFALSE 18396
18371: GO 18373
18373: DISABLE
// begin enable ;
18374: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18375: LD_INT 1
18377: PPUSH
18378: LD_INT 5
18380: PPUSH
18381: CALL_OW 12
18385: PPUSH
18386: LD_INT 7
18388: PPUSH
18389: LD_INT 1
18391: PPUSH
18392: CALL_OW 55
// end ; end_of_file
18396: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18397: LD_INT 0
18399: PPUSH
18400: PPUSH
// skirmish := false ;
18401: LD_ADDR_EXP 48
18405: PUSH
18406: LD_INT 0
18408: ST_TO_ADDR
// debug_mc := false ;
18409: LD_ADDR_EXP 49
18413: PUSH
18414: LD_INT 0
18416: ST_TO_ADDR
// mc_bases := [ ] ;
18417: LD_ADDR_EXP 50
18421: PUSH
18422: EMPTY
18423: ST_TO_ADDR
// mc_sides := [ ] ;
18424: LD_ADDR_EXP 76
18428: PUSH
18429: EMPTY
18430: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18431: LD_ADDR_EXP 51
18435: PUSH
18436: EMPTY
18437: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18438: LD_ADDR_EXP 52
18442: PUSH
18443: EMPTY
18444: ST_TO_ADDR
// mc_need_heal := [ ] ;
18445: LD_ADDR_EXP 53
18449: PUSH
18450: EMPTY
18451: ST_TO_ADDR
// mc_healers := [ ] ;
18452: LD_ADDR_EXP 54
18456: PUSH
18457: EMPTY
18458: ST_TO_ADDR
// mc_build_list := [ ] ;
18459: LD_ADDR_EXP 55
18463: PUSH
18464: EMPTY
18465: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18466: LD_ADDR_EXP 82
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// mc_builders := [ ] ;
18473: LD_ADDR_EXP 56
18477: PUSH
18478: EMPTY
18479: ST_TO_ADDR
// mc_construct_list := [ ] ;
18480: LD_ADDR_EXP 57
18484: PUSH
18485: EMPTY
18486: ST_TO_ADDR
// mc_turret_list := [ ] ;
18487: LD_ADDR_EXP 58
18491: PUSH
18492: EMPTY
18493: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18494: LD_ADDR_EXP 59
18498: PUSH
18499: EMPTY
18500: ST_TO_ADDR
// mc_miners := [ ] ;
18501: LD_ADDR_EXP 64
18505: PUSH
18506: EMPTY
18507: ST_TO_ADDR
// mc_mines := [ ] ;
18508: LD_ADDR_EXP 63
18512: PUSH
18513: EMPTY
18514: ST_TO_ADDR
// mc_minefields := [ ] ;
18515: LD_ADDR_EXP 65
18519: PUSH
18520: EMPTY
18521: ST_TO_ADDR
// mc_crates := [ ] ;
18522: LD_ADDR_EXP 66
18526: PUSH
18527: EMPTY
18528: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18529: LD_ADDR_EXP 67
18533: PUSH
18534: EMPTY
18535: ST_TO_ADDR
// mc_crates_area := [ ] ;
18536: LD_ADDR_EXP 68
18540: PUSH
18541: EMPTY
18542: ST_TO_ADDR
// mc_vehicles := [ ] ;
18543: LD_ADDR_EXP 69
18547: PUSH
18548: EMPTY
18549: ST_TO_ADDR
// mc_attack := [ ] ;
18550: LD_ADDR_EXP 70
18554: PUSH
18555: EMPTY
18556: ST_TO_ADDR
// mc_produce := [ ] ;
18557: LD_ADDR_EXP 71
18561: PUSH
18562: EMPTY
18563: ST_TO_ADDR
// mc_defender := [ ] ;
18564: LD_ADDR_EXP 72
18568: PUSH
18569: EMPTY
18570: ST_TO_ADDR
// mc_parking := [ ] ;
18571: LD_ADDR_EXP 74
18575: PUSH
18576: EMPTY
18577: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18578: LD_ADDR_EXP 60
18582: PUSH
18583: EMPTY
18584: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18585: LD_ADDR_EXP 62
18589: PUSH
18590: EMPTY
18591: ST_TO_ADDR
// mc_scan := [ ] ;
18592: LD_ADDR_EXP 73
18596: PUSH
18597: EMPTY
18598: ST_TO_ADDR
// mc_scan_area := [ ] ;
18599: LD_ADDR_EXP 75
18603: PUSH
18604: EMPTY
18605: ST_TO_ADDR
// mc_tech := [ ] ;
18606: LD_ADDR_EXP 77
18610: PUSH
18611: EMPTY
18612: ST_TO_ADDR
// mc_class := [ ] ;
18613: LD_ADDR_EXP 91
18617: PUSH
18618: EMPTY
18619: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18620: LD_ADDR_EXP 92
18624: PUSH
18625: EMPTY
18626: ST_TO_ADDR
// mc_is_defending := [ ] ;
18627: LD_ADDR_EXP 93
18631: PUSH
18632: EMPTY
18633: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18634: LD_ADDR_EXP 84
18638: PUSH
18639: EMPTY
18640: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18641: LD_ADDR_EXP 94
18645: PUSH
18646: LD_INT 0
18648: ST_TO_ADDR
// end ;
18649: LD_VAR 0 1
18653: RET
// export function MC_Kill ( base ) ; begin
18654: LD_INT 0
18656: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18657: LD_ADDR_EXP 50
18661: PUSH
18662: LD_EXP 50
18666: PPUSH
18667: LD_VAR 0 1
18671: PPUSH
18672: EMPTY
18673: PPUSH
18674: CALL_OW 1
18678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18679: LD_ADDR_EXP 51
18683: PUSH
18684: LD_EXP 51
18688: PPUSH
18689: LD_VAR 0 1
18693: PPUSH
18694: EMPTY
18695: PPUSH
18696: CALL_OW 1
18700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18701: LD_ADDR_EXP 52
18705: PUSH
18706: LD_EXP 52
18710: PPUSH
18711: LD_VAR 0 1
18715: PPUSH
18716: EMPTY
18717: PPUSH
18718: CALL_OW 1
18722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18723: LD_ADDR_EXP 53
18727: PUSH
18728: LD_EXP 53
18732: PPUSH
18733: LD_VAR 0 1
18737: PPUSH
18738: EMPTY
18739: PPUSH
18740: CALL_OW 1
18744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18745: LD_ADDR_EXP 54
18749: PUSH
18750: LD_EXP 54
18754: PPUSH
18755: LD_VAR 0 1
18759: PPUSH
18760: EMPTY
18761: PPUSH
18762: CALL_OW 1
18766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18767: LD_ADDR_EXP 55
18771: PUSH
18772: LD_EXP 55
18776: PPUSH
18777: LD_VAR 0 1
18781: PPUSH
18782: EMPTY
18783: PPUSH
18784: CALL_OW 1
18788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18789: LD_ADDR_EXP 56
18793: PUSH
18794: LD_EXP 56
18798: PPUSH
18799: LD_VAR 0 1
18803: PPUSH
18804: EMPTY
18805: PPUSH
18806: CALL_OW 1
18810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18811: LD_ADDR_EXP 57
18815: PUSH
18816: LD_EXP 57
18820: PPUSH
18821: LD_VAR 0 1
18825: PPUSH
18826: EMPTY
18827: PPUSH
18828: CALL_OW 1
18832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18833: LD_ADDR_EXP 58
18837: PUSH
18838: LD_EXP 58
18842: PPUSH
18843: LD_VAR 0 1
18847: PPUSH
18848: EMPTY
18849: PPUSH
18850: CALL_OW 1
18854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18855: LD_ADDR_EXP 59
18859: PUSH
18860: LD_EXP 59
18864: PPUSH
18865: LD_VAR 0 1
18869: PPUSH
18870: EMPTY
18871: PPUSH
18872: CALL_OW 1
18876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18877: LD_ADDR_EXP 60
18881: PUSH
18882: LD_EXP 60
18886: PPUSH
18887: LD_VAR 0 1
18891: PPUSH
18892: EMPTY
18893: PPUSH
18894: CALL_OW 1
18898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18899: LD_ADDR_EXP 61
18903: PUSH
18904: LD_EXP 61
18908: PPUSH
18909: LD_VAR 0 1
18913: PPUSH
18914: LD_INT 0
18916: PPUSH
18917: CALL_OW 1
18921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18922: LD_ADDR_EXP 62
18926: PUSH
18927: LD_EXP 62
18931: PPUSH
18932: LD_VAR 0 1
18936: PPUSH
18937: EMPTY
18938: PPUSH
18939: CALL_OW 1
18943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18944: LD_ADDR_EXP 63
18948: PUSH
18949: LD_EXP 63
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: EMPTY
18960: PPUSH
18961: CALL_OW 1
18965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18966: LD_ADDR_EXP 64
18970: PUSH
18971: LD_EXP 64
18975: PPUSH
18976: LD_VAR 0 1
18980: PPUSH
18981: EMPTY
18982: PPUSH
18983: CALL_OW 1
18987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18988: LD_ADDR_EXP 65
18992: PUSH
18993: LD_EXP 65
18997: PPUSH
18998: LD_VAR 0 1
19002: PPUSH
19003: EMPTY
19004: PPUSH
19005: CALL_OW 1
19009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19010: LD_ADDR_EXP 66
19014: PUSH
19015: LD_EXP 66
19019: PPUSH
19020: LD_VAR 0 1
19024: PPUSH
19025: EMPTY
19026: PPUSH
19027: CALL_OW 1
19031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19032: LD_ADDR_EXP 67
19036: PUSH
19037: LD_EXP 67
19041: PPUSH
19042: LD_VAR 0 1
19046: PPUSH
19047: EMPTY
19048: PPUSH
19049: CALL_OW 1
19053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19054: LD_ADDR_EXP 68
19058: PUSH
19059: LD_EXP 68
19063: PPUSH
19064: LD_VAR 0 1
19068: PPUSH
19069: EMPTY
19070: PPUSH
19071: CALL_OW 1
19075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19076: LD_ADDR_EXP 69
19080: PUSH
19081: LD_EXP 69
19085: PPUSH
19086: LD_VAR 0 1
19090: PPUSH
19091: EMPTY
19092: PPUSH
19093: CALL_OW 1
19097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19098: LD_ADDR_EXP 70
19102: PUSH
19103: LD_EXP 70
19107: PPUSH
19108: LD_VAR 0 1
19112: PPUSH
19113: EMPTY
19114: PPUSH
19115: CALL_OW 1
19119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19120: LD_ADDR_EXP 71
19124: PUSH
19125: LD_EXP 71
19129: PPUSH
19130: LD_VAR 0 1
19134: PPUSH
19135: EMPTY
19136: PPUSH
19137: CALL_OW 1
19141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19142: LD_ADDR_EXP 72
19146: PUSH
19147: LD_EXP 72
19151: PPUSH
19152: LD_VAR 0 1
19156: PPUSH
19157: EMPTY
19158: PPUSH
19159: CALL_OW 1
19163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19164: LD_ADDR_EXP 73
19168: PUSH
19169: LD_EXP 73
19173: PPUSH
19174: LD_VAR 0 1
19178: PPUSH
19179: EMPTY
19180: PPUSH
19181: CALL_OW 1
19185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19186: LD_ADDR_EXP 74
19190: PUSH
19191: LD_EXP 74
19195: PPUSH
19196: LD_VAR 0 1
19200: PPUSH
19201: EMPTY
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19208: LD_ADDR_EXP 75
19212: PUSH
19213: LD_EXP 75
19217: PPUSH
19218: LD_VAR 0 1
19222: PPUSH
19223: EMPTY
19224: PPUSH
19225: CALL_OW 1
19229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19230: LD_ADDR_EXP 77
19234: PUSH
19235: LD_EXP 77
19239: PPUSH
19240: LD_VAR 0 1
19244: PPUSH
19245: EMPTY
19246: PPUSH
19247: CALL_OW 1
19251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19252: LD_ADDR_EXP 79
19256: PUSH
19257: LD_EXP 79
19261: PPUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: EMPTY
19268: PPUSH
19269: CALL_OW 1
19273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19274: LD_ADDR_EXP 80
19278: PUSH
19279: LD_EXP 80
19283: PPUSH
19284: LD_VAR 0 1
19288: PPUSH
19289: EMPTY
19290: PPUSH
19291: CALL_OW 1
19295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19296: LD_ADDR_EXP 81
19300: PUSH
19301: LD_EXP 81
19305: PPUSH
19306: LD_VAR 0 1
19310: PPUSH
19311: EMPTY
19312: PPUSH
19313: CALL_OW 1
19317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19318: LD_ADDR_EXP 82
19322: PUSH
19323: LD_EXP 82
19327: PPUSH
19328: LD_VAR 0 1
19332: PPUSH
19333: EMPTY
19334: PPUSH
19335: CALL_OW 1
19339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19340: LD_ADDR_EXP 83
19344: PUSH
19345: LD_EXP 83
19349: PPUSH
19350: LD_VAR 0 1
19354: PPUSH
19355: EMPTY
19356: PPUSH
19357: CALL_OW 1
19361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19362: LD_ADDR_EXP 84
19366: PUSH
19367: LD_EXP 84
19371: PPUSH
19372: LD_VAR 0 1
19376: PPUSH
19377: EMPTY
19378: PPUSH
19379: CALL_OW 1
19383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19384: LD_ADDR_EXP 85
19388: PUSH
19389: LD_EXP 85
19393: PPUSH
19394: LD_VAR 0 1
19398: PPUSH
19399: EMPTY
19400: PPUSH
19401: CALL_OW 1
19405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19406: LD_ADDR_EXP 86
19410: PUSH
19411: LD_EXP 86
19415: PPUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: EMPTY
19422: PPUSH
19423: CALL_OW 1
19427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19428: LD_ADDR_EXP 87
19432: PUSH
19433: LD_EXP 87
19437: PPUSH
19438: LD_VAR 0 1
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL_OW 1
19449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19450: LD_ADDR_EXP 88
19454: PUSH
19455: LD_EXP 88
19459: PPUSH
19460: LD_VAR 0 1
19464: PPUSH
19465: EMPTY
19466: PPUSH
19467: CALL_OW 1
19471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19472: LD_ADDR_EXP 89
19476: PUSH
19477: LD_EXP 89
19481: PPUSH
19482: LD_VAR 0 1
19486: PPUSH
19487: EMPTY
19488: PPUSH
19489: CALL_OW 1
19493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19494: LD_ADDR_EXP 90
19498: PUSH
19499: LD_EXP 90
19503: PPUSH
19504: LD_VAR 0 1
19508: PPUSH
19509: EMPTY
19510: PPUSH
19511: CALL_OW 1
19515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19516: LD_ADDR_EXP 91
19520: PUSH
19521: LD_EXP 91
19525: PPUSH
19526: LD_VAR 0 1
19530: PPUSH
19531: EMPTY
19532: PPUSH
19533: CALL_OW 1
19537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19538: LD_ADDR_EXP 92
19542: PUSH
19543: LD_EXP 92
19547: PPUSH
19548: LD_VAR 0 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: CALL_OW 1
19560: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19561: LD_ADDR_EXP 93
19565: PUSH
19566: LD_EXP 93
19570: PPUSH
19571: LD_VAR 0 1
19575: PPUSH
19576: LD_INT 0
19578: PPUSH
19579: CALL_OW 1
19583: ST_TO_ADDR
// end ;
19584: LD_VAR 0 2
19588: RET
// export function MC_Add ( side , units ) ; var base ; begin
19589: LD_INT 0
19591: PPUSH
19592: PPUSH
// base := mc_bases + 1 ;
19593: LD_ADDR_VAR 0 4
19597: PUSH
19598: LD_EXP 50
19602: PUSH
19603: LD_INT 1
19605: PLUS
19606: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19607: LD_ADDR_EXP 76
19611: PUSH
19612: LD_EXP 76
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: LD_VAR 0 1
19626: PPUSH
19627: CALL_OW 1
19631: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19632: LD_ADDR_EXP 50
19636: PUSH
19637: LD_EXP 50
19641: PPUSH
19642: LD_VAR 0 4
19646: PPUSH
19647: LD_VAR 0 2
19651: PPUSH
19652: CALL_OW 1
19656: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19657: LD_ADDR_EXP 51
19661: PUSH
19662: LD_EXP 51
19666: PPUSH
19667: LD_VAR 0 4
19671: PPUSH
19672: EMPTY
19673: PPUSH
19674: CALL_OW 1
19678: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19679: LD_ADDR_EXP 52
19683: PUSH
19684: LD_EXP 52
19688: PPUSH
19689: LD_VAR 0 4
19693: PPUSH
19694: EMPTY
19695: PPUSH
19696: CALL_OW 1
19700: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19701: LD_ADDR_EXP 53
19705: PUSH
19706: LD_EXP 53
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: EMPTY
19717: PPUSH
19718: CALL_OW 1
19722: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19723: LD_ADDR_EXP 54
19727: PUSH
19728: LD_EXP 54
19732: PPUSH
19733: LD_VAR 0 4
19737: PPUSH
19738: EMPTY
19739: PPUSH
19740: CALL_OW 1
19744: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19745: LD_ADDR_EXP 55
19749: PUSH
19750: LD_EXP 55
19754: PPUSH
19755: LD_VAR 0 4
19759: PPUSH
19760: EMPTY
19761: PPUSH
19762: CALL_OW 1
19766: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19767: LD_ADDR_EXP 56
19771: PUSH
19772: LD_EXP 56
19776: PPUSH
19777: LD_VAR 0 4
19781: PPUSH
19782: EMPTY
19783: PPUSH
19784: CALL_OW 1
19788: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19789: LD_ADDR_EXP 57
19793: PUSH
19794: LD_EXP 57
19798: PPUSH
19799: LD_VAR 0 4
19803: PPUSH
19804: EMPTY
19805: PPUSH
19806: CALL_OW 1
19810: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19811: LD_ADDR_EXP 58
19815: PUSH
19816: LD_EXP 58
19820: PPUSH
19821: LD_VAR 0 4
19825: PPUSH
19826: EMPTY
19827: PPUSH
19828: CALL_OW 1
19832: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19833: LD_ADDR_EXP 59
19837: PUSH
19838: LD_EXP 59
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: EMPTY
19849: PPUSH
19850: CALL_OW 1
19854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19855: LD_ADDR_EXP 60
19859: PUSH
19860: LD_EXP 60
19864: PPUSH
19865: LD_VAR 0 4
19869: PPUSH
19870: EMPTY
19871: PPUSH
19872: CALL_OW 1
19876: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19877: LD_ADDR_EXP 61
19881: PUSH
19882: LD_EXP 61
19886: PPUSH
19887: LD_VAR 0 4
19891: PPUSH
19892: LD_INT 0
19894: PPUSH
19895: CALL_OW 1
19899: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19900: LD_ADDR_EXP 62
19904: PUSH
19905: LD_EXP 62
19909: PPUSH
19910: LD_VAR 0 4
19914: PPUSH
19915: EMPTY
19916: PPUSH
19917: CALL_OW 1
19921: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19922: LD_ADDR_EXP 63
19926: PUSH
19927: LD_EXP 63
19931: PPUSH
19932: LD_VAR 0 4
19936: PPUSH
19937: EMPTY
19938: PPUSH
19939: CALL_OW 1
19943: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19944: LD_ADDR_EXP 64
19948: PUSH
19949: LD_EXP 64
19953: PPUSH
19954: LD_VAR 0 4
19958: PPUSH
19959: EMPTY
19960: PPUSH
19961: CALL_OW 1
19965: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19966: LD_ADDR_EXP 65
19970: PUSH
19971: LD_EXP 65
19975: PPUSH
19976: LD_VAR 0 4
19980: PPUSH
19981: EMPTY
19982: PPUSH
19983: CALL_OW 1
19987: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19988: LD_ADDR_EXP 66
19992: PUSH
19993: LD_EXP 66
19997: PPUSH
19998: LD_VAR 0 4
20002: PPUSH
20003: EMPTY
20004: PPUSH
20005: CALL_OW 1
20009: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20010: LD_ADDR_EXP 67
20014: PUSH
20015: LD_EXP 67
20019: PPUSH
20020: LD_VAR 0 4
20024: PPUSH
20025: EMPTY
20026: PPUSH
20027: CALL_OW 1
20031: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20032: LD_ADDR_EXP 68
20036: PUSH
20037: LD_EXP 68
20041: PPUSH
20042: LD_VAR 0 4
20046: PPUSH
20047: EMPTY
20048: PPUSH
20049: CALL_OW 1
20053: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20054: LD_ADDR_EXP 69
20058: PUSH
20059: LD_EXP 69
20063: PPUSH
20064: LD_VAR 0 4
20068: PPUSH
20069: EMPTY
20070: PPUSH
20071: CALL_OW 1
20075: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20076: LD_ADDR_EXP 70
20080: PUSH
20081: LD_EXP 70
20085: PPUSH
20086: LD_VAR 0 4
20090: PPUSH
20091: EMPTY
20092: PPUSH
20093: CALL_OW 1
20097: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20098: LD_ADDR_EXP 71
20102: PUSH
20103: LD_EXP 71
20107: PPUSH
20108: LD_VAR 0 4
20112: PPUSH
20113: EMPTY
20114: PPUSH
20115: CALL_OW 1
20119: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20120: LD_ADDR_EXP 72
20124: PUSH
20125: LD_EXP 72
20129: PPUSH
20130: LD_VAR 0 4
20134: PPUSH
20135: EMPTY
20136: PPUSH
20137: CALL_OW 1
20141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20142: LD_ADDR_EXP 73
20146: PUSH
20147: LD_EXP 73
20151: PPUSH
20152: LD_VAR 0 4
20156: PPUSH
20157: EMPTY
20158: PPUSH
20159: CALL_OW 1
20163: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20164: LD_ADDR_EXP 74
20168: PUSH
20169: LD_EXP 74
20173: PPUSH
20174: LD_VAR 0 4
20178: PPUSH
20179: EMPTY
20180: PPUSH
20181: CALL_OW 1
20185: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20186: LD_ADDR_EXP 75
20190: PUSH
20191: LD_EXP 75
20195: PPUSH
20196: LD_VAR 0 4
20200: PPUSH
20201: EMPTY
20202: PPUSH
20203: CALL_OW 1
20207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20208: LD_ADDR_EXP 77
20212: PUSH
20213: LD_EXP 77
20217: PPUSH
20218: LD_VAR 0 4
20222: PPUSH
20223: EMPTY
20224: PPUSH
20225: CALL_OW 1
20229: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20230: LD_ADDR_EXP 79
20234: PUSH
20235: LD_EXP 79
20239: PPUSH
20240: LD_VAR 0 4
20244: PPUSH
20245: EMPTY
20246: PPUSH
20247: CALL_OW 1
20251: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20252: LD_ADDR_EXP 80
20256: PUSH
20257: LD_EXP 80
20261: PPUSH
20262: LD_VAR 0 4
20266: PPUSH
20267: EMPTY
20268: PPUSH
20269: CALL_OW 1
20273: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20274: LD_ADDR_EXP 81
20278: PUSH
20279: LD_EXP 81
20283: PPUSH
20284: LD_VAR 0 4
20288: PPUSH
20289: EMPTY
20290: PPUSH
20291: CALL_OW 1
20295: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20296: LD_ADDR_EXP 82
20300: PUSH
20301: LD_EXP 82
20305: PPUSH
20306: LD_VAR 0 4
20310: PPUSH
20311: EMPTY
20312: PPUSH
20313: CALL_OW 1
20317: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20318: LD_ADDR_EXP 83
20322: PUSH
20323: LD_EXP 83
20327: PPUSH
20328: LD_VAR 0 4
20332: PPUSH
20333: EMPTY
20334: PPUSH
20335: CALL_OW 1
20339: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20340: LD_ADDR_EXP 84
20344: PUSH
20345: LD_EXP 84
20349: PPUSH
20350: LD_VAR 0 4
20354: PPUSH
20355: EMPTY
20356: PPUSH
20357: CALL_OW 1
20361: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20362: LD_ADDR_EXP 85
20366: PUSH
20367: LD_EXP 85
20371: PPUSH
20372: LD_VAR 0 4
20376: PPUSH
20377: EMPTY
20378: PPUSH
20379: CALL_OW 1
20383: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20384: LD_ADDR_EXP 86
20388: PUSH
20389: LD_EXP 86
20393: PPUSH
20394: LD_VAR 0 4
20398: PPUSH
20399: EMPTY
20400: PPUSH
20401: CALL_OW 1
20405: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20406: LD_ADDR_EXP 87
20410: PUSH
20411: LD_EXP 87
20415: PPUSH
20416: LD_VAR 0 4
20420: PPUSH
20421: EMPTY
20422: PPUSH
20423: CALL_OW 1
20427: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20428: LD_ADDR_EXP 88
20432: PUSH
20433: LD_EXP 88
20437: PPUSH
20438: LD_VAR 0 4
20442: PPUSH
20443: EMPTY
20444: PPUSH
20445: CALL_OW 1
20449: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20450: LD_ADDR_EXP 89
20454: PUSH
20455: LD_EXP 89
20459: PPUSH
20460: LD_VAR 0 4
20464: PPUSH
20465: EMPTY
20466: PPUSH
20467: CALL_OW 1
20471: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20472: LD_ADDR_EXP 90
20476: PUSH
20477: LD_EXP 90
20481: PPUSH
20482: LD_VAR 0 4
20486: PPUSH
20487: EMPTY
20488: PPUSH
20489: CALL_OW 1
20493: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20494: LD_ADDR_EXP 91
20498: PUSH
20499: LD_EXP 91
20503: PPUSH
20504: LD_VAR 0 4
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20516: LD_ADDR_EXP 92
20520: PUSH
20521: LD_EXP 92
20525: PPUSH
20526: LD_VAR 0 4
20530: PPUSH
20531: LD_INT 0
20533: PPUSH
20534: CALL_OW 1
20538: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20539: LD_ADDR_EXP 93
20543: PUSH
20544: LD_EXP 93
20548: PPUSH
20549: LD_VAR 0 4
20553: PPUSH
20554: LD_INT 0
20556: PPUSH
20557: CALL_OW 1
20561: ST_TO_ADDR
// result := base ;
20562: LD_ADDR_VAR 0 3
20566: PUSH
20567: LD_VAR 0 4
20571: ST_TO_ADDR
// end ;
20572: LD_VAR 0 3
20576: RET
// export function MC_Start ( ) ; var i ; begin
20577: LD_INT 0
20579: PPUSH
20580: PPUSH
// for i = 1 to mc_bases do
20581: LD_ADDR_VAR 0 2
20585: PUSH
20586: DOUBLE
20587: LD_INT 1
20589: DEC
20590: ST_TO_ADDR
20591: LD_EXP 50
20595: PUSH
20596: FOR_TO
20597: IFFALSE 21697
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20599: LD_ADDR_EXP 50
20603: PUSH
20604: LD_EXP 50
20608: PPUSH
20609: LD_VAR 0 2
20613: PPUSH
20614: LD_EXP 50
20618: PUSH
20619: LD_VAR 0 2
20623: ARRAY
20624: PUSH
20625: LD_INT 0
20627: DIFF
20628: PPUSH
20629: CALL_OW 1
20633: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20634: LD_ADDR_EXP 51
20638: PUSH
20639: LD_EXP 51
20643: PPUSH
20644: LD_VAR 0 2
20648: PPUSH
20649: EMPTY
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20656: LD_ADDR_EXP 52
20660: PUSH
20661: LD_EXP 52
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: EMPTY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20678: LD_ADDR_EXP 53
20682: PUSH
20683: LD_EXP 53
20687: PPUSH
20688: LD_VAR 0 2
20692: PPUSH
20693: EMPTY
20694: PPUSH
20695: CALL_OW 1
20699: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20700: LD_ADDR_EXP 54
20704: PUSH
20705: LD_EXP 54
20709: PPUSH
20710: LD_VAR 0 2
20714: PPUSH
20715: EMPTY
20716: PUSH
20717: EMPTY
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: PPUSH
20723: CALL_OW 1
20727: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20728: LD_ADDR_EXP 55
20732: PUSH
20733: LD_EXP 55
20737: PPUSH
20738: LD_VAR 0 2
20742: PPUSH
20743: EMPTY
20744: PPUSH
20745: CALL_OW 1
20749: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20750: LD_ADDR_EXP 82
20754: PUSH
20755: LD_EXP 82
20759: PPUSH
20760: LD_VAR 0 2
20764: PPUSH
20765: EMPTY
20766: PPUSH
20767: CALL_OW 1
20771: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20772: LD_ADDR_EXP 56
20776: PUSH
20777: LD_EXP 56
20781: PPUSH
20782: LD_VAR 0 2
20786: PPUSH
20787: EMPTY
20788: PPUSH
20789: CALL_OW 1
20793: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20794: LD_ADDR_EXP 57
20798: PUSH
20799: LD_EXP 57
20803: PPUSH
20804: LD_VAR 0 2
20808: PPUSH
20809: EMPTY
20810: PPUSH
20811: CALL_OW 1
20815: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20816: LD_ADDR_EXP 58
20820: PUSH
20821: LD_EXP 58
20825: PPUSH
20826: LD_VAR 0 2
20830: PPUSH
20831: LD_EXP 50
20835: PUSH
20836: LD_VAR 0 2
20840: ARRAY
20841: PPUSH
20842: LD_INT 2
20844: PUSH
20845: LD_INT 30
20847: PUSH
20848: LD_INT 32
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: PUSH
20855: LD_INT 30
20857: PUSH
20858: LD_INT 33
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: LIST
20869: PPUSH
20870: CALL_OW 72
20874: PPUSH
20875: CALL_OW 1
20879: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20880: LD_ADDR_EXP 59
20884: PUSH
20885: LD_EXP 59
20889: PPUSH
20890: LD_VAR 0 2
20894: PPUSH
20895: LD_EXP 50
20899: PUSH
20900: LD_VAR 0 2
20904: ARRAY
20905: PPUSH
20906: LD_INT 2
20908: PUSH
20909: LD_INT 30
20911: PUSH
20912: LD_INT 32
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: PUSH
20919: LD_INT 30
20921: PUSH
20922: LD_INT 31
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: LIST
20933: PUSH
20934: LD_INT 58
20936: PUSH
20937: EMPTY
20938: LIST
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: PPUSH
20944: CALL_OW 72
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20954: LD_ADDR_EXP 60
20958: PUSH
20959: LD_EXP 60
20963: PPUSH
20964: LD_VAR 0 2
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20976: LD_ADDR_EXP 64
20980: PUSH
20981: LD_EXP 64
20985: PPUSH
20986: LD_VAR 0 2
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20998: LD_ADDR_EXP 63
21002: PUSH
21003: LD_EXP 63
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21020: LD_ADDR_EXP 65
21024: PUSH
21025: LD_EXP 65
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21042: LD_ADDR_EXP 66
21046: PUSH
21047: LD_EXP 66
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21064: LD_ADDR_EXP 67
21068: PUSH
21069: LD_EXP 67
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21086: LD_ADDR_EXP 68
21090: PUSH
21091: LD_EXP 68
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: EMPTY
21102: PPUSH
21103: CALL_OW 1
21107: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21108: LD_ADDR_EXP 69
21112: PUSH
21113: LD_EXP 69
21117: PPUSH
21118: LD_VAR 0 2
21122: PPUSH
21123: EMPTY
21124: PPUSH
21125: CALL_OW 1
21129: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21130: LD_ADDR_EXP 70
21134: PUSH
21135: LD_EXP 70
21139: PPUSH
21140: LD_VAR 0 2
21144: PPUSH
21145: EMPTY
21146: PPUSH
21147: CALL_OW 1
21151: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21152: LD_ADDR_EXP 71
21156: PUSH
21157: LD_EXP 71
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: EMPTY
21168: PPUSH
21169: CALL_OW 1
21173: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21174: LD_ADDR_EXP 72
21178: PUSH
21179: LD_EXP 72
21183: PPUSH
21184: LD_VAR 0 2
21188: PPUSH
21189: EMPTY
21190: PPUSH
21191: CALL_OW 1
21195: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21196: LD_ADDR_EXP 61
21200: PUSH
21201: LD_EXP 61
21205: PPUSH
21206: LD_VAR 0 2
21210: PPUSH
21211: LD_INT 0
21213: PPUSH
21214: CALL_OW 1
21218: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21219: LD_ADDR_EXP 74
21223: PUSH
21224: LD_EXP 74
21228: PPUSH
21229: LD_VAR 0 2
21233: PPUSH
21234: LD_INT 0
21236: PPUSH
21237: CALL_OW 1
21241: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21242: LD_ADDR_EXP 62
21246: PUSH
21247: LD_EXP 62
21251: PPUSH
21252: LD_VAR 0 2
21256: PPUSH
21257: EMPTY
21258: PPUSH
21259: CALL_OW 1
21263: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21264: LD_ADDR_EXP 73
21268: PUSH
21269: LD_EXP 73
21273: PPUSH
21274: LD_VAR 0 2
21278: PPUSH
21279: LD_INT 0
21281: PPUSH
21282: CALL_OW 1
21286: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21287: LD_ADDR_EXP 75
21291: PUSH
21292: LD_EXP 75
21296: PPUSH
21297: LD_VAR 0 2
21301: PPUSH
21302: EMPTY
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21309: LD_ADDR_EXP 78
21313: PUSH
21314: LD_EXP 78
21318: PPUSH
21319: LD_VAR 0 2
21323: PPUSH
21324: LD_INT 0
21326: PPUSH
21327: CALL_OW 1
21331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21332: LD_ADDR_EXP 79
21336: PUSH
21337: LD_EXP 79
21341: PPUSH
21342: LD_VAR 0 2
21346: PPUSH
21347: EMPTY
21348: PPUSH
21349: CALL_OW 1
21353: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21354: LD_ADDR_EXP 80
21358: PUSH
21359: LD_EXP 80
21363: PPUSH
21364: LD_VAR 0 2
21368: PPUSH
21369: EMPTY
21370: PPUSH
21371: CALL_OW 1
21375: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21376: LD_ADDR_EXP 81
21380: PUSH
21381: LD_EXP 81
21385: PPUSH
21386: LD_VAR 0 2
21390: PPUSH
21391: EMPTY
21392: PPUSH
21393: CALL_OW 1
21397: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21398: LD_ADDR_EXP 83
21402: PUSH
21403: LD_EXP 83
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: LD_EXP 50
21417: PUSH
21418: LD_VAR 0 2
21422: ARRAY
21423: PPUSH
21424: LD_INT 2
21426: PUSH
21427: LD_INT 30
21429: PUSH
21430: LD_INT 6
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: PUSH
21437: LD_INT 30
21439: PUSH
21440: LD_INT 7
21442: PUSH
21443: EMPTY
21444: LIST
21445: LIST
21446: PUSH
21447: LD_INT 30
21449: PUSH
21450: LD_INT 8
21452: PUSH
21453: EMPTY
21454: LIST
21455: LIST
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: LIST
21461: LIST
21462: PPUSH
21463: CALL_OW 72
21467: PPUSH
21468: CALL_OW 1
21472: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21473: LD_ADDR_EXP 84
21477: PUSH
21478: LD_EXP 84
21482: PPUSH
21483: LD_VAR 0 2
21487: PPUSH
21488: EMPTY
21489: PPUSH
21490: CALL_OW 1
21494: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21495: LD_ADDR_EXP 85
21499: PUSH
21500: LD_EXP 85
21504: PPUSH
21505: LD_VAR 0 2
21509: PPUSH
21510: EMPTY
21511: PPUSH
21512: CALL_OW 1
21516: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21517: LD_ADDR_EXP 86
21521: PUSH
21522: LD_EXP 86
21526: PPUSH
21527: LD_VAR 0 2
21531: PPUSH
21532: EMPTY
21533: PPUSH
21534: CALL_OW 1
21538: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21539: LD_ADDR_EXP 87
21543: PUSH
21544: LD_EXP 87
21548: PPUSH
21549: LD_VAR 0 2
21553: PPUSH
21554: EMPTY
21555: PPUSH
21556: CALL_OW 1
21560: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21561: LD_ADDR_EXP 88
21565: PUSH
21566: LD_EXP 88
21570: PPUSH
21571: LD_VAR 0 2
21575: PPUSH
21576: EMPTY
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21583: LD_ADDR_EXP 89
21587: PUSH
21588: LD_EXP 89
21592: PPUSH
21593: LD_VAR 0 2
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21605: LD_ADDR_EXP 90
21609: PUSH
21610: LD_EXP 90
21614: PPUSH
21615: LD_VAR 0 2
21619: PPUSH
21620: EMPTY
21621: PPUSH
21622: CALL_OW 1
21626: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21627: LD_ADDR_EXP 91
21631: PUSH
21632: LD_EXP 91
21636: PPUSH
21637: LD_VAR 0 2
21641: PPUSH
21642: EMPTY
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21649: LD_ADDR_EXP 92
21653: PUSH
21654: LD_EXP 92
21658: PPUSH
21659: LD_VAR 0 2
21663: PPUSH
21664: LD_INT 0
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21672: LD_ADDR_EXP 93
21676: PUSH
21677: LD_EXP 93
21681: PPUSH
21682: LD_VAR 0 2
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 1
21694: ST_TO_ADDR
// end ;
21695: GO 20596
21697: POP
21698: POP
// MC_InitSides ( ) ;
21699: CALL 21985 0 0
// MC_InitResearch ( ) ;
21703: CALL 21724 0 0
// CustomInitMacro ( ) ;
21707: CALL 304 0 0
// skirmish := true ;
21711: LD_ADDR_EXP 48
21715: PUSH
21716: LD_INT 1
21718: ST_TO_ADDR
// end ;
21719: LD_VAR 0 1
21723: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21724: LD_INT 0
21726: PPUSH
21727: PPUSH
21728: PPUSH
21729: PPUSH
21730: PPUSH
21731: PPUSH
// if not mc_bases then
21732: LD_EXP 50
21736: NOT
21737: IFFALSE 21741
// exit ;
21739: GO 21980
// for i = 1 to 8 do
21741: LD_ADDR_VAR 0 2
21745: PUSH
21746: DOUBLE
21747: LD_INT 1
21749: DEC
21750: ST_TO_ADDR
21751: LD_INT 8
21753: PUSH
21754: FOR_TO
21755: IFFALSE 21781
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21757: LD_ADDR_EXP 77
21761: PUSH
21762: LD_EXP 77
21766: PPUSH
21767: LD_VAR 0 2
21771: PPUSH
21772: EMPTY
21773: PPUSH
21774: CALL_OW 1
21778: ST_TO_ADDR
21779: GO 21754
21781: POP
21782: POP
// tmp := [ ] ;
21783: LD_ADDR_VAR 0 5
21787: PUSH
21788: EMPTY
21789: ST_TO_ADDR
// for i = 1 to mc_sides do
21790: LD_ADDR_VAR 0 2
21794: PUSH
21795: DOUBLE
21796: LD_INT 1
21798: DEC
21799: ST_TO_ADDR
21800: LD_EXP 76
21804: PUSH
21805: FOR_TO
21806: IFFALSE 21864
// if not mc_sides [ i ] in tmp then
21808: LD_EXP 76
21812: PUSH
21813: LD_VAR 0 2
21817: ARRAY
21818: PUSH
21819: LD_VAR 0 5
21823: IN
21824: NOT
21825: IFFALSE 21862
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21827: LD_ADDR_VAR 0 5
21831: PUSH
21832: LD_VAR 0 5
21836: PPUSH
21837: LD_VAR 0 5
21841: PUSH
21842: LD_INT 1
21844: PLUS
21845: PPUSH
21846: LD_EXP 76
21850: PUSH
21851: LD_VAR 0 2
21855: ARRAY
21856: PPUSH
21857: CALL_OW 2
21861: ST_TO_ADDR
21862: GO 21805
21864: POP
21865: POP
// if not tmp then
21866: LD_VAR 0 5
21870: NOT
21871: IFFALSE 21875
// exit ;
21873: GO 21980
// for j in tmp do
21875: LD_ADDR_VAR 0 3
21879: PUSH
21880: LD_VAR 0 5
21884: PUSH
21885: FOR_IN
21886: IFFALSE 21978
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21888: LD_ADDR_VAR 0 6
21892: PUSH
21893: LD_INT 22
21895: PUSH
21896: LD_VAR 0 3
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: ST_TO_ADDR
// if not un then
21910: LD_VAR 0 6
21914: NOT
21915: IFFALSE 21919
// continue ;
21917: GO 21885
// nation := GetNation ( un [ 1 ] ) ;
21919: LD_ADDR_VAR 0 4
21923: PUSH
21924: LD_VAR 0 6
21928: PUSH
21929: LD_INT 1
21931: ARRAY
21932: PPUSH
21933: CALL_OW 248
21937: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21938: LD_ADDR_EXP 77
21942: PUSH
21943: LD_EXP 77
21947: PPUSH
21948: LD_VAR 0 3
21952: PPUSH
21953: LD_VAR 0 3
21957: PPUSH
21958: LD_VAR 0 4
21962: PPUSH
21963: LD_INT 1
21965: PPUSH
21966: CALL 49168 0 3
21970: PPUSH
21971: CALL_OW 1
21975: ST_TO_ADDR
// end ;
21976: GO 21885
21978: POP
21979: POP
// end ;
21980: LD_VAR 0 1
21984: RET
// export function MC_InitSides ( ) ; var i ; begin
21985: LD_INT 0
21987: PPUSH
21988: PPUSH
// if not mc_bases then
21989: LD_EXP 50
21993: NOT
21994: IFFALSE 21998
// exit ;
21996: GO 22072
// for i = 1 to mc_bases do
21998: LD_ADDR_VAR 0 2
22002: PUSH
22003: DOUBLE
22004: LD_INT 1
22006: DEC
22007: ST_TO_ADDR
22008: LD_EXP 50
22012: PUSH
22013: FOR_TO
22014: IFFALSE 22070
// if mc_bases [ i ] then
22016: LD_EXP 50
22020: PUSH
22021: LD_VAR 0 2
22025: ARRAY
22026: IFFALSE 22068
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22028: LD_ADDR_EXP 76
22032: PUSH
22033: LD_EXP 76
22037: PPUSH
22038: LD_VAR 0 2
22042: PPUSH
22043: LD_EXP 50
22047: PUSH
22048: LD_VAR 0 2
22052: ARRAY
22053: PUSH
22054: LD_INT 1
22056: ARRAY
22057: PPUSH
22058: CALL_OW 255
22062: PPUSH
22063: CALL_OW 1
22067: ST_TO_ADDR
22068: GO 22013
22070: POP
22071: POP
// end ;
22072: LD_VAR 0 1
22076: RET
// every 0 0$03 trigger skirmish do
22077: LD_EXP 48
22081: IFFALSE 22235
22083: GO 22085
22085: DISABLE
// begin enable ;
22086: ENABLE
// MC_CheckBuildings ( ) ;
22087: CALL 26747 0 0
// MC_CheckPeopleLife ( ) ;
22091: CALL 26908 0 0
// RaiseSailEvent ( 100 ) ;
22095: LD_INT 100
22097: PPUSH
22098: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22102: LD_INT 103
22104: PPUSH
22105: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22109: LD_INT 104
22111: PPUSH
22112: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22116: LD_INT 105
22118: PPUSH
22119: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22123: LD_INT 106
22125: PPUSH
22126: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22130: LD_INT 107
22132: PPUSH
22133: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22137: LD_INT 108
22139: PPUSH
22140: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22144: LD_INT 109
22146: PPUSH
22147: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22151: LD_INT 110
22153: PPUSH
22154: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22158: LD_INT 111
22160: PPUSH
22161: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22165: LD_INT 112
22167: PPUSH
22168: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22172: LD_INT 113
22174: PPUSH
22175: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22179: LD_INT 120
22181: PPUSH
22182: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22186: LD_INT 121
22188: PPUSH
22189: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22193: LD_INT 122
22195: PPUSH
22196: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22200: LD_INT 123
22202: PPUSH
22203: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22207: LD_INT 124
22209: PPUSH
22210: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22214: LD_INT 125
22216: PPUSH
22217: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22221: LD_INT 126
22223: PPUSH
22224: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22228: LD_INT 200
22230: PPUSH
22231: CALL_OW 427
// end ;
22235: END
// on SailEvent ( event ) do begin if event < 100 then
22236: LD_VAR 0 1
22240: PUSH
22241: LD_INT 100
22243: LESS
22244: IFFALSE 22255
// CustomEvent ( event ) ;
22246: LD_VAR 0 1
22250: PPUSH
22251: CALL 17398 0 1
// if event = 100 then
22255: LD_VAR 0 1
22259: PUSH
22260: LD_INT 100
22262: EQUAL
22263: IFFALSE 22269
// MC_ClassManager ( ) ;
22265: CALL 22661 0 0
// if event = 101 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 101
22276: EQUAL
22277: IFFALSE 22283
// MC_RepairBuildings ( ) ;
22279: CALL 27493 0 0
// if event = 102 then
22283: LD_VAR 0 1
22287: PUSH
22288: LD_INT 102
22290: EQUAL
22291: IFFALSE 22297
// MC_Heal ( ) ;
22293: CALL 28428 0 0
// if event = 103 then
22297: LD_VAR 0 1
22301: PUSH
22302: LD_INT 103
22304: EQUAL
22305: IFFALSE 22311
// MC_Build ( ) ;
22307: CALL 28850 0 0
// if event = 104 then
22311: LD_VAR 0 1
22315: PUSH
22316: LD_INT 104
22318: EQUAL
22319: IFFALSE 22325
// MC_TurretWeapon ( ) ;
22321: CALL 30484 0 0
// if event = 105 then
22325: LD_VAR 0 1
22329: PUSH
22330: LD_INT 105
22332: EQUAL
22333: IFFALSE 22339
// MC_BuildUpgrade ( ) ;
22335: CALL 30035 0 0
// if event = 106 then
22339: LD_VAR 0 1
22343: PUSH
22344: LD_INT 106
22346: EQUAL
22347: IFFALSE 22353
// MC_PlantMines ( ) ;
22349: CALL 30914 0 0
// if event = 107 then
22353: LD_VAR 0 1
22357: PUSH
22358: LD_INT 107
22360: EQUAL
22361: IFFALSE 22367
// MC_CollectCrates ( ) ;
22363: CALL 31712 0 0
// if event = 108 then
22367: LD_VAR 0 1
22371: PUSH
22372: LD_INT 108
22374: EQUAL
22375: IFFALSE 22381
// MC_LinkRemoteControl ( ) ;
22377: CALL 33562 0 0
// if event = 109 then
22381: LD_VAR 0 1
22385: PUSH
22386: LD_INT 109
22388: EQUAL
22389: IFFALSE 22395
// MC_ProduceVehicle ( ) ;
22391: CALL 33743 0 0
// if event = 110 then
22395: LD_VAR 0 1
22399: PUSH
22400: LD_INT 110
22402: EQUAL
22403: IFFALSE 22409
// MC_SendAttack ( ) ;
22405: CALL 34209 0 0
// if event = 111 then
22409: LD_VAR 0 1
22413: PUSH
22414: LD_INT 111
22416: EQUAL
22417: IFFALSE 22423
// MC_Defend ( ) ;
22419: CALL 34317 0 0
// if event = 112 then
22423: LD_VAR 0 1
22427: PUSH
22428: LD_INT 112
22430: EQUAL
22431: IFFALSE 22437
// MC_Research ( ) ;
22433: CALL 35197 0 0
// if event = 113 then
22437: LD_VAR 0 1
22441: PUSH
22442: LD_INT 113
22444: EQUAL
22445: IFFALSE 22451
// MC_MinesTrigger ( ) ;
22447: CALL 36311 0 0
// if event = 120 then
22451: LD_VAR 0 1
22455: PUSH
22456: LD_INT 120
22458: EQUAL
22459: IFFALSE 22465
// MC_RepairVehicle ( ) ;
22461: CALL 36410 0 0
// if event = 121 then
22465: LD_VAR 0 1
22469: PUSH
22470: LD_INT 121
22472: EQUAL
22473: IFFALSE 22479
// MC_TameApe ( ) ;
22475: CALL 37179 0 0
// if event = 122 then
22479: LD_VAR 0 1
22483: PUSH
22484: LD_INT 122
22486: EQUAL
22487: IFFALSE 22493
// MC_ChangeApeClass ( ) ;
22489: CALL 38008 0 0
// if event = 123 then
22493: LD_VAR 0 1
22497: PUSH
22498: LD_INT 123
22500: EQUAL
22501: IFFALSE 22507
// MC_Bazooka ( ) ;
22503: CALL 38658 0 0
// if event = 124 then
22507: LD_VAR 0 1
22511: PUSH
22512: LD_INT 124
22514: EQUAL
22515: IFFALSE 22521
// MC_TeleportExit ( ) ;
22517: CALL 38856 0 0
// if event = 125 then
22521: LD_VAR 0 1
22525: PUSH
22526: LD_INT 125
22528: EQUAL
22529: IFFALSE 22535
// MC_Deposits ( ) ;
22531: CALL 39503 0 0
// if event = 126 then
22535: LD_VAR 0 1
22539: PUSH
22540: LD_INT 126
22542: EQUAL
22543: IFFALSE 22549
// MC_RemoteDriver ( ) ;
22545: CALL 40128 0 0
// if event = 200 then
22549: LD_VAR 0 1
22553: PUSH
22554: LD_INT 200
22556: EQUAL
22557: IFFALSE 22563
// MC_Idle ( ) ;
22559: CALL 42035 0 0
// end ;
22563: PPOPN 1
22565: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22566: LD_INT 0
22568: PPUSH
22569: PPUSH
// if not mc_bases [ base ] or not tag then
22570: LD_EXP 50
22574: PUSH
22575: LD_VAR 0 1
22579: ARRAY
22580: NOT
22581: PUSH
22582: LD_VAR 0 2
22586: NOT
22587: OR
22588: IFFALSE 22592
// exit ;
22590: GO 22656
// for i in mc_bases [ base ] union mc_ape [ base ] do
22592: LD_ADDR_VAR 0 4
22596: PUSH
22597: LD_EXP 50
22601: PUSH
22602: LD_VAR 0 1
22606: ARRAY
22607: PUSH
22608: LD_EXP 79
22612: PUSH
22613: LD_VAR 0 1
22617: ARRAY
22618: UNION
22619: PUSH
22620: FOR_IN
22621: IFFALSE 22654
// if GetTag ( i ) = tag then
22623: LD_VAR 0 4
22627: PPUSH
22628: CALL_OW 110
22632: PUSH
22633: LD_VAR 0 2
22637: EQUAL
22638: IFFALSE 22652
// SetTag ( i , 0 ) ;
22640: LD_VAR 0 4
22644: PPUSH
22645: LD_INT 0
22647: PPUSH
22648: CALL_OW 109
22652: GO 22620
22654: POP
22655: POP
// end ;
22656: LD_VAR 0 3
22660: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22661: LD_INT 0
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
22669: PPUSH
22670: PPUSH
// if not mc_bases then
22671: LD_EXP 50
22675: NOT
22676: IFFALSE 22680
// exit ;
22678: GO 23129
// for i = 1 to mc_bases do
22680: LD_ADDR_VAR 0 2
22684: PUSH
22685: DOUBLE
22686: LD_INT 1
22688: DEC
22689: ST_TO_ADDR
22690: LD_EXP 50
22694: PUSH
22695: FOR_TO
22696: IFFALSE 23127
// begin tmp := MC_ClassCheckReq ( i ) ;
22698: LD_ADDR_VAR 0 4
22702: PUSH
22703: LD_VAR 0 2
22707: PPUSH
22708: CALL 23134 0 1
22712: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22713: LD_ADDR_EXP 91
22717: PUSH
22718: LD_EXP 91
22722: PPUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: LD_VAR 0 4
22732: PPUSH
22733: CALL_OW 1
22737: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22738: LD_ADDR_VAR 0 6
22742: PUSH
22743: LD_EXP 50
22747: PUSH
22748: LD_VAR 0 2
22752: ARRAY
22753: PPUSH
22754: LD_INT 2
22756: PUSH
22757: LD_INT 30
22759: PUSH
22760: LD_INT 4
22762: PUSH
22763: EMPTY
22764: LIST
22765: LIST
22766: PUSH
22767: LD_INT 30
22769: PUSH
22770: LD_INT 5
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: PPUSH
22782: CALL_OW 72
22786: PUSH
22787: LD_EXP 50
22791: PUSH
22792: LD_VAR 0 2
22796: ARRAY
22797: PPUSH
22798: LD_INT 2
22800: PUSH
22801: LD_INT 30
22803: PUSH
22804: LD_INT 0
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: LD_INT 30
22813: PUSH
22814: LD_INT 1
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: LIST
22825: PPUSH
22826: CALL_OW 72
22830: PUSH
22831: LD_EXP 50
22835: PUSH
22836: LD_VAR 0 2
22840: ARRAY
22841: PPUSH
22842: LD_INT 30
22844: PUSH
22845: LD_INT 3
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PPUSH
22852: CALL_OW 72
22856: PUSH
22857: LD_EXP 50
22861: PUSH
22862: LD_VAR 0 2
22866: ARRAY
22867: PPUSH
22868: LD_INT 2
22870: PUSH
22871: LD_INT 30
22873: PUSH
22874: LD_INT 6
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: LD_INT 7
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: LD_INT 30
22893: PUSH
22894: LD_INT 8
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: PPUSH
22907: CALL_OW 72
22911: PUSH
22912: EMPTY
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: ST_TO_ADDR
// for j := 1 to 4 do
22918: LD_ADDR_VAR 0 3
22922: PUSH
22923: DOUBLE
22924: LD_INT 1
22926: DEC
22927: ST_TO_ADDR
22928: LD_INT 4
22930: PUSH
22931: FOR_TO
22932: IFFALSE 23123
// begin if not tmp [ j ] then
22934: LD_VAR 0 4
22938: PUSH
22939: LD_VAR 0 3
22943: ARRAY
22944: NOT
22945: IFFALSE 22949
// continue ;
22947: GO 22931
// for p in tmp [ j ] do
22949: LD_ADDR_VAR 0 5
22953: PUSH
22954: LD_VAR 0 4
22958: PUSH
22959: LD_VAR 0 3
22963: ARRAY
22964: PUSH
22965: FOR_IN
22966: IFFALSE 23119
// begin if not b [ j ] then
22968: LD_VAR 0 6
22972: PUSH
22973: LD_VAR 0 3
22977: ARRAY
22978: NOT
22979: IFFALSE 22983
// break ;
22981: GO 23119
// e := 0 ;
22983: LD_ADDR_VAR 0 7
22987: PUSH
22988: LD_INT 0
22990: ST_TO_ADDR
// for k in b [ j ] do
22991: LD_ADDR_VAR 0 8
22995: PUSH
22996: LD_VAR 0 6
23000: PUSH
23001: LD_VAR 0 3
23005: ARRAY
23006: PUSH
23007: FOR_IN
23008: IFFALSE 23035
// if IsNotFull ( k ) then
23010: LD_VAR 0 8
23014: PPUSH
23015: CALL 51289 0 1
23019: IFFALSE 23033
// begin e := k ;
23021: LD_ADDR_VAR 0 7
23025: PUSH
23026: LD_VAR 0 8
23030: ST_TO_ADDR
// break ;
23031: GO 23035
// end ;
23033: GO 23007
23035: POP
23036: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23037: LD_VAR 0 7
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 7
23051: PPUSH
23052: CALL 85439 0 2
23056: NOT
23057: AND
23058: IFFALSE 23117
// begin if IsInUnit ( p ) then
23060: LD_VAR 0 5
23064: PPUSH
23065: CALL_OW 310
23069: IFFALSE 23080
// ComExitBuilding ( p ) ;
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23080: LD_VAR 0 5
23084: PPUSH
23085: LD_VAR 0 7
23089: PPUSH
23090: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23094: LD_VAR 0 5
23098: PPUSH
23099: LD_VAR 0 3
23103: PPUSH
23104: CALL_OW 183
// AddComExitBuilding ( p ) ;
23108: LD_VAR 0 5
23112: PPUSH
23113: CALL_OW 182
// end ; end ;
23117: GO 22965
23119: POP
23120: POP
// end ;
23121: GO 22931
23123: POP
23124: POP
// end ;
23125: GO 22695
23127: POP
23128: POP
// end ;
23129: LD_VAR 0 1
23133: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23134: LD_INT 0
23136: PPUSH
23137: PPUSH
23138: PPUSH
23139: PPUSH
23140: PPUSH
23141: PPUSH
23142: PPUSH
23143: PPUSH
23144: PPUSH
23145: PPUSH
23146: PPUSH
23147: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23148: LD_ADDR_VAR 0 2
23152: PUSH
23153: LD_INT 0
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 0
23161: PUSH
23162: LD_INT 0
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: LIST
23169: LIST
23170: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23171: LD_VAR 0 1
23175: NOT
23176: PUSH
23177: LD_EXP 50
23181: PUSH
23182: LD_VAR 0 1
23186: ARRAY
23187: NOT
23188: OR
23189: PUSH
23190: LD_EXP 50
23194: PUSH
23195: LD_VAR 0 1
23199: ARRAY
23200: PPUSH
23201: LD_INT 2
23203: PUSH
23204: LD_INT 30
23206: PUSH
23207: LD_INT 0
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 30
23216: PUSH
23217: LD_INT 1
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: LIST
23228: PPUSH
23229: CALL_OW 72
23233: NOT
23234: OR
23235: IFFALSE 23239
// exit ;
23237: GO 26742
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23239: LD_ADDR_VAR 0 4
23243: PUSH
23244: LD_EXP 50
23248: PUSH
23249: LD_VAR 0 1
23253: ARRAY
23254: PPUSH
23255: LD_INT 2
23257: PUSH
23258: LD_INT 25
23260: PUSH
23261: LD_INT 1
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: LD_INT 25
23270: PUSH
23271: LD_INT 2
23273: PUSH
23274: EMPTY
23275: LIST
23276: LIST
23277: PUSH
23278: LD_INT 25
23280: PUSH
23281: LD_INT 3
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: LD_INT 25
23290: PUSH
23291: LD_INT 4
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PUSH
23298: LD_INT 25
23300: PUSH
23301: LD_INT 5
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: LD_INT 25
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: LD_INT 25
23320: PUSH
23321: LD_INT 9
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: PUSH
23328: EMPTY
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: LIST
23337: PPUSH
23338: CALL_OW 72
23342: ST_TO_ADDR
// if not tmp then
23343: LD_VAR 0 4
23347: NOT
23348: IFFALSE 23352
// exit ;
23350: GO 26742
// for i in tmp do
23352: LD_ADDR_VAR 0 3
23356: PUSH
23357: LD_VAR 0 4
23361: PUSH
23362: FOR_IN
23363: IFFALSE 23394
// if GetTag ( i ) then
23365: LD_VAR 0 3
23369: PPUSH
23370: CALL_OW 110
23374: IFFALSE 23392
// tmp := tmp diff i ;
23376: LD_ADDR_VAR 0 4
23380: PUSH
23381: LD_VAR 0 4
23385: PUSH
23386: LD_VAR 0 3
23390: DIFF
23391: ST_TO_ADDR
23392: GO 23362
23394: POP
23395: POP
// if not tmp then
23396: LD_VAR 0 4
23400: NOT
23401: IFFALSE 23405
// exit ;
23403: GO 26742
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23405: LD_ADDR_VAR 0 5
23409: PUSH
23410: LD_EXP 50
23414: PUSH
23415: LD_VAR 0 1
23419: ARRAY
23420: PPUSH
23421: LD_INT 2
23423: PUSH
23424: LD_INT 25
23426: PUSH
23427: LD_INT 1
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 25
23436: PUSH
23437: LD_INT 5
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 25
23446: PUSH
23447: LD_INT 8
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 25
23456: PUSH
23457: LD_INT 9
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23476: LD_ADDR_VAR 0 6
23480: PUSH
23481: LD_EXP 50
23485: PUSH
23486: LD_VAR 0 1
23490: ARRAY
23491: PPUSH
23492: LD_INT 25
23494: PUSH
23495: LD_INT 2
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PPUSH
23502: CALL_OW 72
23506: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23507: LD_ADDR_VAR 0 7
23511: PUSH
23512: LD_EXP 50
23516: PUSH
23517: LD_VAR 0 1
23521: ARRAY
23522: PPUSH
23523: LD_INT 25
23525: PUSH
23526: LD_INT 3
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PPUSH
23533: CALL_OW 72
23537: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23538: LD_ADDR_VAR 0 8
23542: PUSH
23543: LD_EXP 50
23547: PUSH
23548: LD_VAR 0 1
23552: ARRAY
23553: PPUSH
23554: LD_INT 25
23556: PUSH
23557: LD_INT 4
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 24
23566: PUSH
23567: LD_INT 251
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PPUSH
23578: CALL_OW 72
23582: ST_TO_ADDR
// if mc_is_defending [ base ] then
23583: LD_EXP 93
23587: PUSH
23588: LD_VAR 0 1
23592: ARRAY
23593: IFFALSE 24054
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23595: LD_ADDR_EXP 92
23599: PUSH
23600: LD_EXP 92
23604: PPUSH
23605: LD_VAR 0 1
23609: PPUSH
23610: LD_INT 4
23612: PPUSH
23613: CALL_OW 1
23617: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 2
23636: PUSH
23637: LD_INT 30
23639: PUSH
23640: LD_INT 4
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 5
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: LIST
23661: PPUSH
23662: CALL_OW 72
23666: ST_TO_ADDR
// if not b then
23667: LD_VAR 0 12
23671: NOT
23672: IFFALSE 23676
// exit ;
23674: GO 26742
// p := [ ] ;
23676: LD_ADDR_VAR 0 11
23680: PUSH
23681: EMPTY
23682: ST_TO_ADDR
// if sci >= 2 then
23683: LD_VAR 0 8
23687: PUSH
23688: LD_INT 2
23690: GREATEREQUAL
23691: IFFALSE 23722
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23693: LD_ADDR_VAR 0 8
23697: PUSH
23698: LD_VAR 0 8
23702: PUSH
23703: LD_INT 1
23705: ARRAY
23706: PUSH
23707: LD_VAR 0 8
23711: PUSH
23712: LD_INT 2
23714: ARRAY
23715: PUSH
23716: EMPTY
23717: LIST
23718: LIST
23719: ST_TO_ADDR
23720: GO 23783
// if sci = 1 then
23722: LD_VAR 0 8
23726: PUSH
23727: LD_INT 1
23729: EQUAL
23730: IFFALSE 23751
// sci := [ sci [ 1 ] ] else
23732: LD_ADDR_VAR 0 8
23736: PUSH
23737: LD_VAR 0 8
23741: PUSH
23742: LD_INT 1
23744: ARRAY
23745: PUSH
23746: EMPTY
23747: LIST
23748: ST_TO_ADDR
23749: GO 23783
// if sci = 0 then
23751: LD_VAR 0 8
23755: PUSH
23756: LD_INT 0
23758: EQUAL
23759: IFFALSE 23783
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23761: LD_ADDR_VAR 0 11
23765: PUSH
23766: LD_VAR 0 4
23770: PPUSH
23771: LD_INT 4
23773: PPUSH
23774: CALL 85311 0 2
23778: PUSH
23779: LD_INT 1
23781: ARRAY
23782: ST_TO_ADDR
// if eng > 4 then
23783: LD_VAR 0 6
23787: PUSH
23788: LD_INT 4
23790: GREATER
23791: IFFALSE 23837
// for i = eng downto 4 do
23793: LD_ADDR_VAR 0 3
23797: PUSH
23798: DOUBLE
23799: LD_VAR 0 6
23803: INC
23804: ST_TO_ADDR
23805: LD_INT 4
23807: PUSH
23808: FOR_DOWNTO
23809: IFFALSE 23835
// eng := eng diff eng [ i ] ;
23811: LD_ADDR_VAR 0 6
23815: PUSH
23816: LD_VAR 0 6
23820: PUSH
23821: LD_VAR 0 6
23825: PUSH
23826: LD_VAR 0 3
23830: ARRAY
23831: DIFF
23832: ST_TO_ADDR
23833: GO 23808
23835: POP
23836: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23837: LD_ADDR_VAR 0 4
23841: PUSH
23842: LD_VAR 0 4
23846: PUSH
23847: LD_VAR 0 5
23851: PUSH
23852: LD_VAR 0 6
23856: UNION
23857: PUSH
23858: LD_VAR 0 7
23862: UNION
23863: PUSH
23864: LD_VAR 0 8
23868: UNION
23869: DIFF
23870: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23871: LD_ADDR_VAR 0 13
23875: PUSH
23876: LD_EXP 50
23880: PUSH
23881: LD_VAR 0 1
23885: ARRAY
23886: PPUSH
23887: LD_INT 2
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: LD_INT 32
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 30
23902: PUSH
23903: LD_INT 31
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: LIST
23914: PPUSH
23915: CALL_OW 72
23919: PUSH
23920: LD_EXP 50
23924: PUSH
23925: LD_VAR 0 1
23929: ARRAY
23930: PPUSH
23931: LD_INT 2
23933: PUSH
23934: LD_INT 30
23936: PUSH
23937: LD_INT 4
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: LD_INT 30
23946: PUSH
23947: LD_INT 5
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: LIST
23958: PPUSH
23959: CALL_OW 72
23963: PUSH
23964: LD_INT 6
23966: MUL
23967: PLUS
23968: ST_TO_ADDR
// if bcount < tmp then
23969: LD_VAR 0 13
23973: PUSH
23974: LD_VAR 0 4
23978: LESS
23979: IFFALSE 24025
// for i = tmp downto bcount do
23981: LD_ADDR_VAR 0 3
23985: PUSH
23986: DOUBLE
23987: LD_VAR 0 4
23991: INC
23992: ST_TO_ADDR
23993: LD_VAR 0 13
23997: PUSH
23998: FOR_DOWNTO
23999: IFFALSE 24023
// tmp := Delete ( tmp , tmp ) ;
24001: LD_ADDR_VAR 0 4
24005: PUSH
24006: LD_VAR 0 4
24010: PPUSH
24011: LD_VAR 0 4
24015: PPUSH
24016: CALL_OW 3
24020: ST_TO_ADDR
24021: GO 23998
24023: POP
24024: POP
// result := [ tmp , 0 , 0 , p ] ;
24025: LD_ADDR_VAR 0 2
24029: PUSH
24030: LD_VAR 0 4
24034: PUSH
24035: LD_INT 0
24037: PUSH
24038: LD_INT 0
24040: PUSH
24041: LD_VAR 0 11
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: LIST
24050: LIST
24051: ST_TO_ADDR
// exit ;
24052: GO 26742
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24054: LD_EXP 50
24058: PUSH
24059: LD_VAR 0 1
24063: ARRAY
24064: PPUSH
24065: LD_INT 2
24067: PUSH
24068: LD_INT 30
24070: PUSH
24071: LD_INT 6
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 30
24080: PUSH
24081: LD_INT 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: LD_INT 30
24090: PUSH
24091: LD_INT 8
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: PPUSH
24104: CALL_OW 72
24108: NOT
24109: PUSH
24110: LD_EXP 50
24114: PUSH
24115: LD_VAR 0 1
24119: ARRAY
24120: PPUSH
24121: LD_INT 30
24123: PUSH
24124: LD_INT 3
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PPUSH
24131: CALL_OW 72
24135: NOT
24136: AND
24137: IFFALSE 24209
// begin if eng = tmp then
24139: LD_VAR 0 6
24143: PUSH
24144: LD_VAR 0 4
24148: EQUAL
24149: IFFALSE 24153
// exit ;
24151: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24153: LD_ADDR_EXP 92
24157: PUSH
24158: LD_EXP 92
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: LD_INT 1
24170: PPUSH
24171: CALL_OW 1
24175: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24176: LD_ADDR_VAR 0 2
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: LD_VAR 0 4
24188: PUSH
24189: LD_VAR 0 6
24193: DIFF
24194: PUSH
24195: LD_INT 0
24197: PUSH
24198: LD_INT 0
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: ST_TO_ADDR
// exit ;
24207: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24209: LD_EXP 77
24213: PUSH
24214: LD_EXP 76
24218: PUSH
24219: LD_VAR 0 1
24223: ARRAY
24224: ARRAY
24225: PUSH
24226: LD_EXP 50
24230: PUSH
24231: LD_VAR 0 1
24235: ARRAY
24236: PPUSH
24237: LD_INT 2
24239: PUSH
24240: LD_INT 30
24242: PUSH
24243: LD_INT 6
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 30
24252: PUSH
24253: LD_INT 7
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PUSH
24260: LD_INT 30
24262: PUSH
24263: LD_INT 8
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: LIST
24274: LIST
24275: PPUSH
24276: CALL_OW 72
24280: AND
24281: PUSH
24282: LD_EXP 50
24286: PUSH
24287: LD_VAR 0 1
24291: ARRAY
24292: PPUSH
24293: LD_INT 30
24295: PUSH
24296: LD_INT 3
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PPUSH
24303: CALL_OW 72
24307: NOT
24308: AND
24309: IFFALSE 24523
// begin if sci >= 6 then
24311: LD_VAR 0 8
24315: PUSH
24316: LD_INT 6
24318: GREATEREQUAL
24319: IFFALSE 24323
// exit ;
24321: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24323: LD_ADDR_EXP 92
24327: PUSH
24328: LD_EXP 92
24332: PPUSH
24333: LD_VAR 0 1
24337: PPUSH
24338: LD_INT 2
24340: PPUSH
24341: CALL_OW 1
24345: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24346: LD_ADDR_VAR 0 9
24350: PUSH
24351: LD_VAR 0 4
24355: PUSH
24356: LD_VAR 0 8
24360: DIFF
24361: PPUSH
24362: LD_INT 4
24364: PPUSH
24365: CALL 85311 0 2
24369: ST_TO_ADDR
// p := [ ] ;
24370: LD_ADDR_VAR 0 11
24374: PUSH
24375: EMPTY
24376: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24377: LD_VAR 0 8
24381: PUSH
24382: LD_INT 6
24384: LESS
24385: PUSH
24386: LD_VAR 0 9
24390: PUSH
24391: LD_INT 6
24393: GREATER
24394: AND
24395: IFFALSE 24476
// begin for i = 1 to 6 - sci do
24397: LD_ADDR_VAR 0 3
24401: PUSH
24402: DOUBLE
24403: LD_INT 1
24405: DEC
24406: ST_TO_ADDR
24407: LD_INT 6
24409: PUSH
24410: LD_VAR 0 8
24414: MINUS
24415: PUSH
24416: FOR_TO
24417: IFFALSE 24472
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 11
24428: PPUSH
24429: LD_VAR 0 11
24433: PUSH
24434: LD_INT 1
24436: PLUS
24437: PPUSH
24438: LD_VAR 0 9
24442: PUSH
24443: LD_INT 1
24445: ARRAY
24446: PPUSH
24447: CALL_OW 2
24451: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24452: LD_ADDR_VAR 0 9
24456: PUSH
24457: LD_VAR 0 9
24461: PPUSH
24462: LD_INT 1
24464: PPUSH
24465: CALL_OW 3
24469: ST_TO_ADDR
// end ;
24470: GO 24416
24472: POP
24473: POP
// end else
24474: GO 24496
// if sort then
24476: LD_VAR 0 9
24480: IFFALSE 24496
// p := sort [ 1 ] ;
24482: LD_ADDR_VAR 0 11
24486: PUSH
24487: LD_VAR 0 9
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24496: LD_ADDR_VAR 0 2
24500: PUSH
24501: LD_INT 0
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: LD_INT 0
24509: PUSH
24510: LD_VAR 0 11
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: LIST
24519: LIST
24520: ST_TO_ADDR
// exit ;
24521: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24523: LD_EXP 77
24527: PUSH
24528: LD_EXP 76
24532: PUSH
24533: LD_VAR 0 1
24537: ARRAY
24538: ARRAY
24539: PUSH
24540: LD_EXP 50
24544: PUSH
24545: LD_VAR 0 1
24549: ARRAY
24550: PPUSH
24551: LD_INT 2
24553: PUSH
24554: LD_INT 30
24556: PUSH
24557: LD_INT 6
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 30
24566: PUSH
24567: LD_INT 7
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: LD_INT 30
24576: PUSH
24577: LD_INT 8
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 72
24594: AND
24595: PUSH
24596: LD_EXP 50
24600: PUSH
24601: LD_VAR 0 1
24605: ARRAY
24606: PPUSH
24607: LD_INT 30
24609: PUSH
24610: LD_INT 3
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: PPUSH
24617: CALL_OW 72
24621: AND
24622: IFFALSE 25356
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24624: LD_ADDR_EXP 92
24628: PUSH
24629: LD_EXP 92
24633: PPUSH
24634: LD_VAR 0 1
24638: PPUSH
24639: LD_INT 3
24641: PPUSH
24642: CALL_OW 1
24646: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24647: LD_ADDR_VAR 0 2
24651: PUSH
24652: LD_INT 0
24654: PUSH
24655: LD_INT 0
24657: PUSH
24658: LD_INT 0
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: ST_TO_ADDR
// if not eng then
24670: LD_VAR 0 6
24674: NOT
24675: IFFALSE 24738
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24677: LD_ADDR_VAR 0 11
24681: PUSH
24682: LD_VAR 0 4
24686: PPUSH
24687: LD_INT 2
24689: PPUSH
24690: CALL 85311 0 2
24694: PUSH
24695: LD_INT 1
24697: ARRAY
24698: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24699: LD_ADDR_VAR 0 2
24703: PUSH
24704: LD_VAR 0 2
24708: PPUSH
24709: LD_INT 2
24711: PPUSH
24712: LD_VAR 0 11
24716: PPUSH
24717: CALL_OW 1
24721: ST_TO_ADDR
// tmp := tmp diff p ;
24722: LD_ADDR_VAR 0 4
24726: PUSH
24727: LD_VAR 0 4
24731: PUSH
24732: LD_VAR 0 11
24736: DIFF
24737: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24738: LD_VAR 0 4
24742: PUSH
24743: LD_VAR 0 8
24747: PUSH
24748: LD_INT 6
24750: LESS
24751: AND
24752: IFFALSE 24940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24754: LD_ADDR_VAR 0 9
24758: PUSH
24759: LD_VAR 0 4
24763: PUSH
24764: LD_VAR 0 8
24768: PUSH
24769: LD_VAR 0 7
24773: UNION
24774: DIFF
24775: PPUSH
24776: LD_INT 4
24778: PPUSH
24779: CALL 85311 0 2
24783: ST_TO_ADDR
// p := [ ] ;
24784: LD_ADDR_VAR 0 11
24788: PUSH
24789: EMPTY
24790: ST_TO_ADDR
// if sort then
24791: LD_VAR 0 9
24795: IFFALSE 24911
// for i = 1 to 6 - sci do
24797: LD_ADDR_VAR 0 3
24801: PUSH
24802: DOUBLE
24803: LD_INT 1
24805: DEC
24806: ST_TO_ADDR
24807: LD_INT 6
24809: PUSH
24810: LD_VAR 0 8
24814: MINUS
24815: PUSH
24816: FOR_TO
24817: IFFALSE 24909
// begin if i = sort then
24819: LD_VAR 0 3
24823: PUSH
24824: LD_VAR 0 9
24828: EQUAL
24829: IFFALSE 24833
// break ;
24831: GO 24909
// if GetClass ( i ) = 4 then
24833: LD_VAR 0 3
24837: PPUSH
24838: CALL_OW 257
24842: PUSH
24843: LD_INT 4
24845: EQUAL
24846: IFFALSE 24850
// continue ;
24848: GO 24816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24850: LD_ADDR_VAR 0 11
24854: PUSH
24855: LD_VAR 0 11
24859: PPUSH
24860: LD_VAR 0 11
24864: PUSH
24865: LD_INT 1
24867: PLUS
24868: PPUSH
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 3
24878: ARRAY
24879: PPUSH
24880: CALL_OW 2
24884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24885: LD_ADDR_VAR 0 4
24889: PUSH
24890: LD_VAR 0 4
24894: PUSH
24895: LD_VAR 0 9
24899: PUSH
24900: LD_VAR 0 3
24904: ARRAY
24905: DIFF
24906: ST_TO_ADDR
// end ;
24907: GO 24816
24909: POP
24910: POP
// if p then
24911: LD_VAR 0 11
24915: IFFALSE 24940
// result := Replace ( result , 4 , p ) ;
24917: LD_ADDR_VAR 0 2
24921: PUSH
24922: LD_VAR 0 2
24926: PPUSH
24927: LD_INT 4
24929: PPUSH
24930: LD_VAR 0 11
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24940: LD_VAR 0 4
24944: PUSH
24945: LD_VAR 0 7
24949: PUSH
24950: LD_INT 6
24952: LESS
24953: AND
24954: IFFALSE 25142
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24956: LD_ADDR_VAR 0 9
24960: PUSH
24961: LD_VAR 0 4
24965: PUSH
24966: LD_VAR 0 8
24970: PUSH
24971: LD_VAR 0 7
24975: UNION
24976: DIFF
24977: PPUSH
24978: LD_INT 3
24980: PPUSH
24981: CALL 85311 0 2
24985: ST_TO_ADDR
// p := [ ] ;
24986: LD_ADDR_VAR 0 11
24990: PUSH
24991: EMPTY
24992: ST_TO_ADDR
// if sort then
24993: LD_VAR 0 9
24997: IFFALSE 25113
// for i = 1 to 6 - mech do
24999: LD_ADDR_VAR 0 3
25003: PUSH
25004: DOUBLE
25005: LD_INT 1
25007: DEC
25008: ST_TO_ADDR
25009: LD_INT 6
25011: PUSH
25012: LD_VAR 0 7
25016: MINUS
25017: PUSH
25018: FOR_TO
25019: IFFALSE 25111
// begin if i = sort then
25021: LD_VAR 0 3
25025: PUSH
25026: LD_VAR 0 9
25030: EQUAL
25031: IFFALSE 25035
// break ;
25033: GO 25111
// if GetClass ( i ) = 3 then
25035: LD_VAR 0 3
25039: PPUSH
25040: CALL_OW 257
25044: PUSH
25045: LD_INT 3
25047: EQUAL
25048: IFFALSE 25052
// continue ;
25050: GO 25018
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25052: LD_ADDR_VAR 0 11
25056: PUSH
25057: LD_VAR 0 11
25061: PPUSH
25062: LD_VAR 0 11
25066: PUSH
25067: LD_INT 1
25069: PLUS
25070: PPUSH
25071: LD_VAR 0 9
25075: PUSH
25076: LD_VAR 0 3
25080: ARRAY
25081: PPUSH
25082: CALL_OW 2
25086: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_VAR 0 4
25096: PUSH
25097: LD_VAR 0 9
25101: PUSH
25102: LD_VAR 0 3
25106: ARRAY
25107: DIFF
25108: ST_TO_ADDR
// end ;
25109: GO 25018
25111: POP
25112: POP
// if p then
25113: LD_VAR 0 11
25117: IFFALSE 25142
// result := Replace ( result , 3 , p ) ;
25119: LD_ADDR_VAR 0 2
25123: PUSH
25124: LD_VAR 0 2
25128: PPUSH
25129: LD_INT 3
25131: PPUSH
25132: LD_VAR 0 11
25136: PPUSH
25137: CALL_OW 1
25141: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25142: LD_VAR 0 4
25146: PUSH
25147: LD_INT 6
25149: GREATER
25150: PUSH
25151: LD_VAR 0 6
25155: PUSH
25156: LD_INT 6
25158: LESS
25159: AND
25160: IFFALSE 25354
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25162: LD_ADDR_VAR 0 9
25166: PUSH
25167: LD_VAR 0 4
25171: PUSH
25172: LD_VAR 0 8
25176: PUSH
25177: LD_VAR 0 7
25181: UNION
25182: PUSH
25183: LD_VAR 0 6
25187: UNION
25188: DIFF
25189: PPUSH
25190: LD_INT 2
25192: PPUSH
25193: CALL 85311 0 2
25197: ST_TO_ADDR
// p := [ ] ;
25198: LD_ADDR_VAR 0 11
25202: PUSH
25203: EMPTY
25204: ST_TO_ADDR
// if sort then
25205: LD_VAR 0 9
25209: IFFALSE 25325
// for i = 1 to 6 - eng do
25211: LD_ADDR_VAR 0 3
25215: PUSH
25216: DOUBLE
25217: LD_INT 1
25219: DEC
25220: ST_TO_ADDR
25221: LD_INT 6
25223: PUSH
25224: LD_VAR 0 6
25228: MINUS
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25323
// begin if i = sort then
25233: LD_VAR 0 3
25237: PUSH
25238: LD_VAR 0 9
25242: EQUAL
25243: IFFALSE 25247
// break ;
25245: GO 25323
// if GetClass ( i ) = 2 then
25247: LD_VAR 0 3
25251: PPUSH
25252: CALL_OW 257
25256: PUSH
25257: LD_INT 2
25259: EQUAL
25260: IFFALSE 25264
// continue ;
25262: GO 25230
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25264: LD_ADDR_VAR 0 11
25268: PUSH
25269: LD_VAR 0 11
25273: PPUSH
25274: LD_VAR 0 11
25278: PUSH
25279: LD_INT 1
25281: PLUS
25282: PPUSH
25283: LD_VAR 0 9
25287: PUSH
25288: LD_VAR 0 3
25292: ARRAY
25293: PPUSH
25294: CALL_OW 2
25298: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25299: LD_ADDR_VAR 0 4
25303: PUSH
25304: LD_VAR 0 4
25308: PUSH
25309: LD_VAR 0 9
25313: PUSH
25314: LD_VAR 0 3
25318: ARRAY
25319: DIFF
25320: ST_TO_ADDR
// end ;
25321: GO 25230
25323: POP
25324: POP
// if p then
25325: LD_VAR 0 11
25329: IFFALSE 25354
// result := Replace ( result , 2 , p ) ;
25331: LD_ADDR_VAR 0 2
25335: PUSH
25336: LD_VAR 0 2
25340: PPUSH
25341: LD_INT 2
25343: PPUSH
25344: LD_VAR 0 11
25348: PPUSH
25349: CALL_OW 1
25353: ST_TO_ADDR
// end ; exit ;
25354: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25356: LD_EXP 77
25360: PUSH
25361: LD_EXP 76
25365: PUSH
25366: LD_VAR 0 1
25370: ARRAY
25371: ARRAY
25372: NOT
25373: PUSH
25374: LD_EXP 50
25378: PUSH
25379: LD_VAR 0 1
25383: ARRAY
25384: PPUSH
25385: LD_INT 30
25387: PUSH
25388: LD_INT 3
25390: PUSH
25391: EMPTY
25392: LIST
25393: LIST
25394: PPUSH
25395: CALL_OW 72
25399: AND
25400: PUSH
25401: LD_EXP 55
25405: PUSH
25406: LD_VAR 0 1
25410: ARRAY
25411: AND
25412: IFFALSE 26020
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25414: LD_ADDR_EXP 92
25418: PUSH
25419: LD_EXP 92
25423: PPUSH
25424: LD_VAR 0 1
25428: PPUSH
25429: LD_INT 5
25431: PPUSH
25432: CALL_OW 1
25436: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25437: LD_ADDR_VAR 0 2
25441: PUSH
25442: LD_INT 0
25444: PUSH
25445: LD_INT 0
25447: PUSH
25448: LD_INT 0
25450: PUSH
25451: LD_INT 0
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: ST_TO_ADDR
// if sci > 1 then
25460: LD_VAR 0 8
25464: PUSH
25465: LD_INT 1
25467: GREATER
25468: IFFALSE 25496
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25470: LD_ADDR_VAR 0 4
25474: PUSH
25475: LD_VAR 0 4
25479: PUSH
25480: LD_VAR 0 8
25484: PUSH
25485: LD_VAR 0 8
25489: PUSH
25490: LD_INT 1
25492: ARRAY
25493: DIFF
25494: DIFF
25495: ST_TO_ADDR
// if tmp and not sci then
25496: LD_VAR 0 4
25500: PUSH
25501: LD_VAR 0 8
25505: NOT
25506: AND
25507: IFFALSE 25576
// begin sort := SortBySkill ( tmp , 4 ) ;
25509: LD_ADDR_VAR 0 9
25513: PUSH
25514: LD_VAR 0 4
25518: PPUSH
25519: LD_INT 4
25521: PPUSH
25522: CALL 85311 0 2
25526: ST_TO_ADDR
// if sort then
25527: LD_VAR 0 9
25531: IFFALSE 25547
// p := sort [ 1 ] ;
25533: LD_ADDR_VAR 0 11
25537: PUSH
25538: LD_VAR 0 9
25542: PUSH
25543: LD_INT 1
25545: ARRAY
25546: ST_TO_ADDR
// if p then
25547: LD_VAR 0 11
25551: IFFALSE 25576
// result := Replace ( result , 4 , p ) ;
25553: LD_ADDR_VAR 0 2
25557: PUSH
25558: LD_VAR 0 2
25562: PPUSH
25563: LD_INT 4
25565: PPUSH
25566: LD_VAR 0 11
25570: PPUSH
25571: CALL_OW 1
25575: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25576: LD_ADDR_VAR 0 4
25580: PUSH
25581: LD_VAR 0 4
25585: PUSH
25586: LD_VAR 0 7
25590: DIFF
25591: ST_TO_ADDR
// if tmp and mech < 6 then
25592: LD_VAR 0 4
25596: PUSH
25597: LD_VAR 0 7
25601: PUSH
25602: LD_INT 6
25604: LESS
25605: AND
25606: IFFALSE 25794
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_VAR 0 4
25617: PUSH
25618: LD_VAR 0 8
25622: PUSH
25623: LD_VAR 0 7
25627: UNION
25628: DIFF
25629: PPUSH
25630: LD_INT 3
25632: PPUSH
25633: CALL 85311 0 2
25637: ST_TO_ADDR
// p := [ ] ;
25638: LD_ADDR_VAR 0 11
25642: PUSH
25643: EMPTY
25644: ST_TO_ADDR
// if sort then
25645: LD_VAR 0 9
25649: IFFALSE 25765
// for i = 1 to 6 - mech do
25651: LD_ADDR_VAR 0 3
25655: PUSH
25656: DOUBLE
25657: LD_INT 1
25659: DEC
25660: ST_TO_ADDR
25661: LD_INT 6
25663: PUSH
25664: LD_VAR 0 7
25668: MINUS
25669: PUSH
25670: FOR_TO
25671: IFFALSE 25763
// begin if i = sort then
25673: LD_VAR 0 3
25677: PUSH
25678: LD_VAR 0 9
25682: EQUAL
25683: IFFALSE 25687
// break ;
25685: GO 25763
// if GetClass ( i ) = 3 then
25687: LD_VAR 0 3
25691: PPUSH
25692: CALL_OW 257
25696: PUSH
25697: LD_INT 3
25699: EQUAL
25700: IFFALSE 25704
// continue ;
25702: GO 25670
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25704: LD_ADDR_VAR 0 11
25708: PUSH
25709: LD_VAR 0 11
25713: PPUSH
25714: LD_VAR 0 11
25718: PUSH
25719: LD_INT 1
25721: PLUS
25722: PPUSH
25723: LD_VAR 0 9
25727: PUSH
25728: LD_VAR 0 3
25732: ARRAY
25733: PPUSH
25734: CALL_OW 2
25738: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25739: LD_ADDR_VAR 0 4
25743: PUSH
25744: LD_VAR 0 4
25748: PUSH
25749: LD_VAR 0 9
25753: PUSH
25754: LD_VAR 0 3
25758: ARRAY
25759: DIFF
25760: ST_TO_ADDR
// end ;
25761: GO 25670
25763: POP
25764: POP
// if p then
25765: LD_VAR 0 11
25769: IFFALSE 25794
// result := Replace ( result , 3 , p ) ;
25771: LD_ADDR_VAR 0 2
25775: PUSH
25776: LD_VAR 0 2
25780: PPUSH
25781: LD_INT 3
25783: PPUSH
25784: LD_VAR 0 11
25788: PPUSH
25789: CALL_OW 1
25793: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25794: LD_ADDR_VAR 0 4
25798: PUSH
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 6
25808: DIFF
25809: ST_TO_ADDR
// if tmp and eng < 6 then
25810: LD_VAR 0 4
25814: PUSH
25815: LD_VAR 0 6
25819: PUSH
25820: LD_INT 6
25822: LESS
25823: AND
25824: IFFALSE 26018
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25826: LD_ADDR_VAR 0 9
25830: PUSH
25831: LD_VAR 0 4
25835: PUSH
25836: LD_VAR 0 8
25840: PUSH
25841: LD_VAR 0 7
25845: UNION
25846: PUSH
25847: LD_VAR 0 6
25851: UNION
25852: DIFF
25853: PPUSH
25854: LD_INT 2
25856: PPUSH
25857: CALL 85311 0 2
25861: ST_TO_ADDR
// p := [ ] ;
25862: LD_ADDR_VAR 0 11
25866: PUSH
25867: EMPTY
25868: ST_TO_ADDR
// if sort then
25869: LD_VAR 0 9
25873: IFFALSE 25989
// for i = 1 to 6 - eng do
25875: LD_ADDR_VAR 0 3
25879: PUSH
25880: DOUBLE
25881: LD_INT 1
25883: DEC
25884: ST_TO_ADDR
25885: LD_INT 6
25887: PUSH
25888: LD_VAR 0 6
25892: MINUS
25893: PUSH
25894: FOR_TO
25895: IFFALSE 25987
// begin if i = sort then
25897: LD_VAR 0 3
25901: PUSH
25902: LD_VAR 0 9
25906: EQUAL
25907: IFFALSE 25911
// break ;
25909: GO 25987
// if GetClass ( i ) = 2 then
25911: LD_VAR 0 3
25915: PPUSH
25916: CALL_OW 257
25920: PUSH
25921: LD_INT 2
25923: EQUAL
25924: IFFALSE 25928
// continue ;
25926: GO 25894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25928: LD_ADDR_VAR 0 11
25932: PUSH
25933: LD_VAR 0 11
25937: PPUSH
25938: LD_VAR 0 11
25942: PUSH
25943: LD_INT 1
25945: PLUS
25946: PPUSH
25947: LD_VAR 0 9
25951: PUSH
25952: LD_VAR 0 3
25956: ARRAY
25957: PPUSH
25958: CALL_OW 2
25962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25963: LD_ADDR_VAR 0 4
25967: PUSH
25968: LD_VAR 0 4
25972: PUSH
25973: LD_VAR 0 9
25977: PUSH
25978: LD_VAR 0 3
25982: ARRAY
25983: DIFF
25984: ST_TO_ADDR
// end ;
25985: GO 25894
25987: POP
25988: POP
// if p then
25989: LD_VAR 0 11
25993: IFFALSE 26018
// result := Replace ( result , 2 , p ) ;
25995: LD_ADDR_VAR 0 2
25999: PUSH
26000: LD_VAR 0 2
26004: PPUSH
26005: LD_INT 2
26007: PPUSH
26008: LD_VAR 0 11
26012: PPUSH
26013: CALL_OW 1
26017: ST_TO_ADDR
// end ; exit ;
26018: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26020: LD_EXP 77
26024: PUSH
26025: LD_EXP 76
26029: PUSH
26030: LD_VAR 0 1
26034: ARRAY
26035: ARRAY
26036: NOT
26037: PUSH
26038: LD_EXP 50
26042: PUSH
26043: LD_VAR 0 1
26047: ARRAY
26048: PPUSH
26049: LD_INT 30
26051: PUSH
26052: LD_INT 3
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: PPUSH
26059: CALL_OW 72
26063: AND
26064: PUSH
26065: LD_EXP 55
26069: PUSH
26070: LD_VAR 0 1
26074: ARRAY
26075: NOT
26076: AND
26077: IFFALSE 26742
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26079: LD_ADDR_EXP 92
26083: PUSH
26084: LD_EXP 92
26088: PPUSH
26089: LD_VAR 0 1
26093: PPUSH
26094: LD_INT 6
26096: PPUSH
26097: CALL_OW 1
26101: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26102: LD_ADDR_VAR 0 2
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 0
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: ST_TO_ADDR
// if sci >= 1 then
26125: LD_VAR 0 8
26129: PUSH
26130: LD_INT 1
26132: GREATEREQUAL
26133: IFFALSE 26155
// tmp := tmp diff sci [ 1 ] ;
26135: LD_ADDR_VAR 0 4
26139: PUSH
26140: LD_VAR 0 4
26144: PUSH
26145: LD_VAR 0 8
26149: PUSH
26150: LD_INT 1
26152: ARRAY
26153: DIFF
26154: ST_TO_ADDR
// if tmp and not sci then
26155: LD_VAR 0 4
26159: PUSH
26160: LD_VAR 0 8
26164: NOT
26165: AND
26166: IFFALSE 26235
// begin sort := SortBySkill ( tmp , 4 ) ;
26168: LD_ADDR_VAR 0 9
26172: PUSH
26173: LD_VAR 0 4
26177: PPUSH
26178: LD_INT 4
26180: PPUSH
26181: CALL 85311 0 2
26185: ST_TO_ADDR
// if sort then
26186: LD_VAR 0 9
26190: IFFALSE 26206
// p := sort [ 1 ] ;
26192: LD_ADDR_VAR 0 11
26196: PUSH
26197: LD_VAR 0 9
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: ST_TO_ADDR
// if p then
26206: LD_VAR 0 11
26210: IFFALSE 26235
// result := Replace ( result , 4 , p ) ;
26212: LD_ADDR_VAR 0 2
26216: PUSH
26217: LD_VAR 0 2
26221: PPUSH
26222: LD_INT 4
26224: PPUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 1
26234: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26235: LD_ADDR_VAR 0 4
26239: PUSH
26240: LD_VAR 0 4
26244: PUSH
26245: LD_VAR 0 7
26249: DIFF
26250: ST_TO_ADDR
// if tmp and mech < 6 then
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 7
26260: PUSH
26261: LD_INT 6
26263: LESS
26264: AND
26265: IFFALSE 26447
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26267: LD_ADDR_VAR 0 9
26271: PUSH
26272: LD_VAR 0 4
26276: PUSH
26277: LD_VAR 0 7
26281: DIFF
26282: PPUSH
26283: LD_INT 3
26285: PPUSH
26286: CALL 85311 0 2
26290: ST_TO_ADDR
// p := [ ] ;
26291: LD_ADDR_VAR 0 11
26295: PUSH
26296: EMPTY
26297: ST_TO_ADDR
// if sort then
26298: LD_VAR 0 9
26302: IFFALSE 26418
// for i = 1 to 6 - mech do
26304: LD_ADDR_VAR 0 3
26308: PUSH
26309: DOUBLE
26310: LD_INT 1
26312: DEC
26313: ST_TO_ADDR
26314: LD_INT 6
26316: PUSH
26317: LD_VAR 0 7
26321: MINUS
26322: PUSH
26323: FOR_TO
26324: IFFALSE 26416
// begin if i = sort then
26326: LD_VAR 0 3
26330: PUSH
26331: LD_VAR 0 9
26335: EQUAL
26336: IFFALSE 26340
// break ;
26338: GO 26416
// if GetClass ( i ) = 3 then
26340: LD_VAR 0 3
26344: PPUSH
26345: CALL_OW 257
26349: PUSH
26350: LD_INT 3
26352: EQUAL
26353: IFFALSE 26357
// continue ;
26355: GO 26323
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26357: LD_ADDR_VAR 0 11
26361: PUSH
26362: LD_VAR 0 11
26366: PPUSH
26367: LD_VAR 0 11
26371: PUSH
26372: LD_INT 1
26374: PLUS
26375: PPUSH
26376: LD_VAR 0 9
26380: PUSH
26381: LD_VAR 0 3
26385: ARRAY
26386: PPUSH
26387: CALL_OW 2
26391: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26392: LD_ADDR_VAR 0 4
26396: PUSH
26397: LD_VAR 0 4
26401: PUSH
26402: LD_VAR 0 9
26406: PUSH
26407: LD_VAR 0 3
26411: ARRAY
26412: DIFF
26413: ST_TO_ADDR
// end ;
26414: GO 26323
26416: POP
26417: POP
// if p then
26418: LD_VAR 0 11
26422: IFFALSE 26447
// result := Replace ( result , 3 , p ) ;
26424: LD_ADDR_VAR 0 2
26428: PUSH
26429: LD_VAR 0 2
26433: PPUSH
26434: LD_INT 3
26436: PPUSH
26437: LD_VAR 0 11
26441: PPUSH
26442: CALL_OW 1
26446: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26447: LD_ADDR_VAR 0 4
26451: PUSH
26452: LD_VAR 0 4
26456: PUSH
26457: LD_VAR 0 6
26461: DIFF
26462: ST_TO_ADDR
// if tmp and eng < 4 then
26463: LD_VAR 0 4
26467: PUSH
26468: LD_VAR 0 6
26472: PUSH
26473: LD_INT 4
26475: LESS
26476: AND
26477: IFFALSE 26667
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26479: LD_ADDR_VAR 0 9
26483: PUSH
26484: LD_VAR 0 4
26488: PUSH
26489: LD_VAR 0 7
26493: PUSH
26494: LD_VAR 0 6
26498: UNION
26499: DIFF
26500: PPUSH
26501: LD_INT 2
26503: PPUSH
26504: CALL 85311 0 2
26508: ST_TO_ADDR
// p := [ ] ;
26509: LD_ADDR_VAR 0 11
26513: PUSH
26514: EMPTY
26515: ST_TO_ADDR
// if sort then
26516: LD_VAR 0 9
26520: IFFALSE 26636
// for i = 1 to 4 - eng do
26522: LD_ADDR_VAR 0 3
26526: PUSH
26527: DOUBLE
26528: LD_INT 1
26530: DEC
26531: ST_TO_ADDR
26532: LD_INT 4
26534: PUSH
26535: LD_VAR 0 6
26539: MINUS
26540: PUSH
26541: FOR_TO
26542: IFFALSE 26634
// begin if i = sort then
26544: LD_VAR 0 3
26548: PUSH
26549: LD_VAR 0 9
26553: EQUAL
26554: IFFALSE 26558
// break ;
26556: GO 26634
// if GetClass ( i ) = 2 then
26558: LD_VAR 0 3
26562: PPUSH
26563: CALL_OW 257
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26575
// continue ;
26573: GO 26541
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26575: LD_ADDR_VAR 0 11
26579: PUSH
26580: LD_VAR 0 11
26584: PPUSH
26585: LD_VAR 0 11
26589: PUSH
26590: LD_INT 1
26592: PLUS
26593: PPUSH
26594: LD_VAR 0 9
26598: PUSH
26599: LD_VAR 0 3
26603: ARRAY
26604: PPUSH
26605: CALL_OW 2
26609: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26610: LD_ADDR_VAR 0 4
26614: PUSH
26615: LD_VAR 0 4
26619: PUSH
26620: LD_VAR 0 9
26624: PUSH
26625: LD_VAR 0 3
26629: ARRAY
26630: DIFF
26631: ST_TO_ADDR
// end ;
26632: GO 26541
26634: POP
26635: POP
// if p then
26636: LD_VAR 0 11
26640: IFFALSE 26665
// result := Replace ( result , 2 , p ) ;
26642: LD_ADDR_VAR 0 2
26646: PUSH
26647: LD_VAR 0 2
26651: PPUSH
26652: LD_INT 2
26654: PPUSH
26655: LD_VAR 0 11
26659: PPUSH
26660: CALL_OW 1
26664: ST_TO_ADDR
// end else
26665: GO 26711
// for i = eng downto 5 do
26667: LD_ADDR_VAR 0 3
26671: PUSH
26672: DOUBLE
26673: LD_VAR 0 6
26677: INC
26678: ST_TO_ADDR
26679: LD_INT 5
26681: PUSH
26682: FOR_DOWNTO
26683: IFFALSE 26709
// tmp := tmp union eng [ i ] ;
26685: LD_ADDR_VAR 0 4
26689: PUSH
26690: LD_VAR 0 4
26694: PUSH
26695: LD_VAR 0 6
26699: PUSH
26700: LD_VAR 0 3
26704: ARRAY
26705: UNION
26706: ST_TO_ADDR
26707: GO 26682
26709: POP
26710: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26711: LD_ADDR_VAR 0 2
26715: PUSH
26716: LD_VAR 0 2
26720: PPUSH
26721: LD_INT 1
26723: PPUSH
26724: LD_VAR 0 4
26728: PUSH
26729: LD_VAR 0 5
26733: DIFF
26734: PPUSH
26735: CALL_OW 1
26739: ST_TO_ADDR
// exit ;
26740: GO 26742
// end ; end ;
26742: LD_VAR 0 2
26746: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26747: LD_INT 0
26749: PPUSH
26750: PPUSH
26751: PPUSH
// if not mc_bases then
26752: LD_EXP 50
26756: NOT
26757: IFFALSE 26761
// exit ;
26759: GO 26903
// for i = 1 to mc_bases do
26761: LD_ADDR_VAR 0 2
26765: PUSH
26766: DOUBLE
26767: LD_INT 1
26769: DEC
26770: ST_TO_ADDR
26771: LD_EXP 50
26775: PUSH
26776: FOR_TO
26777: IFFALSE 26894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26779: LD_ADDR_VAR 0 3
26783: PUSH
26784: LD_EXP 50
26788: PUSH
26789: LD_VAR 0 2
26793: ARRAY
26794: PPUSH
26795: LD_INT 21
26797: PUSH
26798: LD_INT 3
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 3
26807: PUSH
26808: LD_INT 2
26810: PUSH
26811: LD_INT 30
26813: PUSH
26814: LD_INT 29
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 30
26823: PUSH
26824: LD_INT 30
26826: PUSH
26827: EMPTY
26828: LIST
26829: LIST
26830: PUSH
26831: EMPTY
26832: LIST
26833: LIST
26834: LIST
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 3
26842: PUSH
26843: LD_INT 24
26845: PUSH
26846: LD_INT 1000
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: LIST
26861: PPUSH
26862: CALL_OW 72
26866: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26867: LD_ADDR_EXP 51
26871: PUSH
26872: LD_EXP 51
26876: PPUSH
26877: LD_VAR 0 2
26881: PPUSH
26882: LD_VAR 0 3
26886: PPUSH
26887: CALL_OW 1
26891: ST_TO_ADDR
// end ;
26892: GO 26776
26894: POP
26895: POP
// RaiseSailEvent ( 101 ) ;
26896: LD_INT 101
26898: PPUSH
26899: CALL_OW 427
// end ;
26903: LD_VAR 0 1
26907: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26908: LD_INT 0
26910: PPUSH
26911: PPUSH
26912: PPUSH
26913: PPUSH
26914: PPUSH
26915: PPUSH
26916: PPUSH
// if not mc_bases then
26917: LD_EXP 50
26921: NOT
26922: IFFALSE 26926
// exit ;
26924: GO 27488
// for i = 1 to mc_bases do
26926: LD_ADDR_VAR 0 2
26930: PUSH
26931: DOUBLE
26932: LD_INT 1
26934: DEC
26935: ST_TO_ADDR
26936: LD_EXP 50
26940: PUSH
26941: FOR_TO
26942: IFFALSE 27479
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26944: LD_ADDR_VAR 0 5
26948: PUSH
26949: LD_EXP 50
26953: PUSH
26954: LD_VAR 0 2
26958: ARRAY
26959: PUSH
26960: LD_EXP 79
26964: PUSH
26965: LD_VAR 0 2
26969: ARRAY
26970: UNION
26971: PPUSH
26972: LD_INT 21
26974: PUSH
26975: LD_INT 1
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 3
26987: PUSH
26988: LD_INT 54
26990: PUSH
26991: EMPTY
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: LD_INT 24
27003: PUSH
27004: LD_INT 1000
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PPUSH
27024: CALL_OW 72
27028: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27029: LD_ADDR_VAR 0 6
27033: PUSH
27034: LD_EXP 50
27038: PUSH
27039: LD_VAR 0 2
27043: ARRAY
27044: PPUSH
27045: LD_INT 21
27047: PUSH
27048: LD_INT 1
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 1
27057: PUSH
27058: LD_INT 3
27060: PUSH
27061: LD_INT 54
27063: PUSH
27064: EMPTY
27065: LIST
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 3
27073: PUSH
27074: LD_INT 24
27076: PUSH
27077: LD_INT 250
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PPUSH
27097: CALL_OW 72
27101: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27102: LD_ADDR_VAR 0 7
27106: PUSH
27107: LD_VAR 0 5
27111: PUSH
27112: LD_VAR 0 6
27116: DIFF
27117: ST_TO_ADDR
// if not need_heal_1 then
27118: LD_VAR 0 6
27122: NOT
27123: IFFALSE 27156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27125: LD_ADDR_EXP 53
27129: PUSH
27130: LD_EXP 53
27134: PPUSH
27135: LD_VAR 0 2
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PPUSH
27147: EMPTY
27148: PPUSH
27149: CALL 54067 0 3
27153: ST_TO_ADDR
27154: GO 27226
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27156: LD_ADDR_EXP 53
27160: PUSH
27161: LD_EXP 53
27165: PPUSH
27166: LD_VAR 0 2
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PPUSH
27178: LD_EXP 53
27182: PUSH
27183: LD_VAR 0 2
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_INT 3
27195: PUSH
27196: LD_INT 24
27198: PUSH
27199: LD_INT 1000
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PPUSH
27210: CALL_OW 72
27214: PUSH
27215: LD_VAR 0 6
27219: UNION
27220: PPUSH
27221: CALL 54067 0 3
27225: ST_TO_ADDR
// if not need_heal_2 then
27226: LD_VAR 0 7
27230: NOT
27231: IFFALSE 27264
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27233: LD_ADDR_EXP 53
27237: PUSH
27238: LD_EXP 53
27242: PPUSH
27243: LD_VAR 0 2
27247: PUSH
27248: LD_INT 2
27250: PUSH
27251: EMPTY
27252: LIST
27253: LIST
27254: PPUSH
27255: EMPTY
27256: PPUSH
27257: CALL 54067 0 3
27261: ST_TO_ADDR
27262: GO 27296
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27264: LD_ADDR_EXP 53
27268: PUSH
27269: LD_EXP 53
27273: PPUSH
27274: LD_VAR 0 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PPUSH
27286: LD_VAR 0 7
27290: PPUSH
27291: CALL 54067 0 3
27295: ST_TO_ADDR
// if need_heal_2 then
27296: LD_VAR 0 7
27300: IFFALSE 27461
// for j in need_heal_2 do
27302: LD_ADDR_VAR 0 3
27306: PUSH
27307: LD_VAR 0 7
27311: PUSH
27312: FOR_IN
27313: IFFALSE 27459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27315: LD_ADDR_VAR 0 5
27319: PUSH
27320: LD_EXP 50
27324: PUSH
27325: LD_VAR 0 2
27329: ARRAY
27330: PPUSH
27331: LD_INT 2
27333: PUSH
27334: LD_INT 30
27336: PUSH
27337: LD_INT 6
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 30
27346: PUSH
27347: LD_INT 7
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 30
27356: PUSH
27357: LD_INT 8
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 30
27366: PUSH
27367: LD_INT 0
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 30
27376: PUSH
27377: LD_INT 1
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: PPUSH
27392: CALL_OW 72
27396: ST_TO_ADDR
// if tmp then
27397: LD_VAR 0 5
27401: IFFALSE 27457
// begin k := NearestUnitToUnit ( tmp , j ) ;
27403: LD_ADDR_VAR 0 4
27407: PUSH
27408: LD_VAR 0 5
27412: PPUSH
27413: LD_VAR 0 3
27417: PPUSH
27418: CALL_OW 74
27422: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27423: LD_VAR 0 3
27427: PPUSH
27428: LD_VAR 0 4
27432: PPUSH
27433: CALL_OW 296
27437: PUSH
27438: LD_INT 5
27440: GREATER
27441: IFFALSE 27457
// ComMoveToNearbyEntrance ( j , k ) ;
27443: LD_VAR 0 3
27447: PPUSH
27448: LD_VAR 0 4
27452: PPUSH
27453: CALL 87684 0 2
// end ; end ;
27457: GO 27312
27459: POP
27460: POP
// if not need_heal_1 and not need_heal_2 then
27461: LD_VAR 0 6
27465: NOT
27466: PUSH
27467: LD_VAR 0 7
27471: NOT
27472: AND
27473: IFFALSE 27477
// continue ;
27475: GO 26941
// end ;
27477: GO 26941
27479: POP
27480: POP
// RaiseSailEvent ( 102 ) ;
27481: LD_INT 102
27483: PPUSH
27484: CALL_OW 427
// end ;
27488: LD_VAR 0 1
27492: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27493: LD_INT 0
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
// if not mc_bases then
27503: LD_EXP 50
27507: NOT
27508: IFFALSE 27512
// exit ;
27510: GO 28423
// for i = 1 to mc_bases do
27512: LD_ADDR_VAR 0 2
27516: PUSH
27517: DOUBLE
27518: LD_INT 1
27520: DEC
27521: ST_TO_ADDR
27522: LD_EXP 50
27526: PUSH
27527: FOR_TO
27528: IFFALSE 28421
// begin if not mc_building_need_repair [ i ] then
27530: LD_EXP 51
27534: PUSH
27535: LD_VAR 0 2
27539: ARRAY
27540: NOT
27541: IFFALSE 27726
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27543: LD_ADDR_VAR 0 6
27547: PUSH
27548: LD_EXP 69
27552: PUSH
27553: LD_VAR 0 2
27557: ARRAY
27558: PPUSH
27559: LD_INT 3
27561: PUSH
27562: LD_INT 24
27564: PUSH
27565: LD_INT 1000
27567: PUSH
27568: EMPTY
27569: LIST
27570: LIST
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: LD_INT 2
27578: PUSH
27579: LD_INT 34
27581: PUSH
27582: LD_INT 13
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 34
27591: PUSH
27592: LD_INT 52
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 34
27601: PUSH
27602: LD_INT 88
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: PUSH
27615: EMPTY
27616: LIST
27617: LIST
27618: PPUSH
27619: CALL_OW 72
27623: ST_TO_ADDR
// if cranes then
27624: LD_VAR 0 6
27628: IFFALSE 27690
// for j in cranes do
27630: LD_ADDR_VAR 0 3
27634: PUSH
27635: LD_VAR 0 6
27639: PUSH
27640: FOR_IN
27641: IFFALSE 27688
// if not IsInArea ( j , mc_parking [ i ] ) then
27643: LD_VAR 0 3
27647: PPUSH
27648: LD_EXP 74
27652: PUSH
27653: LD_VAR 0 2
27657: ARRAY
27658: PPUSH
27659: CALL_OW 308
27663: NOT
27664: IFFALSE 27686
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27666: LD_VAR 0 3
27670: PPUSH
27671: LD_EXP 74
27675: PUSH
27676: LD_VAR 0 2
27680: ARRAY
27681: PPUSH
27682: CALL_OW 113
27686: GO 27640
27688: POP
27689: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27690: LD_ADDR_EXP 52
27694: PUSH
27695: LD_EXP 52
27699: PPUSH
27700: LD_VAR 0 2
27704: PPUSH
27705: EMPTY
27706: PPUSH
27707: CALL_OW 1
27711: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27712: LD_VAR 0 2
27716: PPUSH
27717: LD_INT 101
27719: PPUSH
27720: CALL 22566 0 2
// continue ;
27724: GO 27527
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27726: LD_ADDR_EXP 56
27730: PUSH
27731: LD_EXP 56
27735: PPUSH
27736: LD_VAR 0 2
27740: PPUSH
27741: EMPTY
27742: PPUSH
27743: CALL_OW 1
27747: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27748: LD_VAR 0 2
27752: PPUSH
27753: LD_INT 103
27755: PPUSH
27756: CALL 22566 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27760: LD_ADDR_VAR 0 5
27764: PUSH
27765: LD_EXP 50
27769: PUSH
27770: LD_VAR 0 2
27774: ARRAY
27775: PUSH
27776: LD_EXP 79
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: UNION
27787: PPUSH
27788: LD_INT 2
27790: PUSH
27791: LD_INT 25
27793: PUSH
27794: LD_INT 2
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 25
27803: PUSH
27804: LD_INT 16
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: LIST
27815: PUSH
27816: EMPTY
27817: LIST
27818: PPUSH
27819: CALL_OW 72
27823: ST_TO_ADDR
// if mc_need_heal [ i ] then
27824: LD_EXP 53
27828: PUSH
27829: LD_VAR 0 2
27833: ARRAY
27834: IFFALSE 27878
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27836: LD_ADDR_VAR 0 5
27840: PUSH
27841: LD_VAR 0 5
27845: PUSH
27846: LD_EXP 53
27850: PUSH
27851: LD_VAR 0 2
27855: ARRAY
27856: PUSH
27857: LD_INT 1
27859: ARRAY
27860: PUSH
27861: LD_EXP 53
27865: PUSH
27866: LD_VAR 0 2
27870: ARRAY
27871: PUSH
27872: LD_INT 2
27874: ARRAY
27875: UNION
27876: DIFF
27877: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27878: LD_ADDR_VAR 0 6
27882: PUSH
27883: LD_EXP 69
27887: PUSH
27888: LD_VAR 0 2
27892: ARRAY
27893: PPUSH
27894: LD_INT 2
27896: PUSH
27897: LD_INT 34
27899: PUSH
27900: LD_INT 13
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 34
27909: PUSH
27910: LD_INT 52
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 34
27919: PUSH
27920: LD_INT 88
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: PPUSH
27933: CALL_OW 72
27937: ST_TO_ADDR
// if cranes then
27938: LD_VAR 0 6
27942: IFFALSE 28110
// begin for j in cranes do
27944: LD_ADDR_VAR 0 3
27948: PUSH
27949: LD_VAR 0 6
27953: PUSH
27954: FOR_IN
27955: IFFALSE 28108
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27957: LD_VAR 0 3
27961: PPUSH
27962: CALL_OW 256
27966: PUSH
27967: LD_INT 1000
27969: EQUAL
27970: PUSH
27971: LD_VAR 0 3
27975: PPUSH
27976: CALL_OW 314
27980: NOT
27981: AND
27982: IFFALSE 28048
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27984: LD_ADDR_VAR 0 8
27988: PUSH
27989: LD_EXP 51
27993: PUSH
27994: LD_VAR 0 2
27998: ARRAY
27999: PPUSH
28000: LD_VAR 0 3
28004: PPUSH
28005: CALL_OW 74
28009: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28010: LD_VAR 0 8
28014: PPUSH
28015: LD_INT 16
28017: PPUSH
28018: CALL 57032 0 2
28022: PUSH
28023: LD_INT 4
28025: ARRAY
28026: PUSH
28027: LD_INT 10
28029: LESS
28030: IFFALSE 28046
// ComRepairBuilding ( j , to_repair ) ;
28032: LD_VAR 0 3
28036: PPUSH
28037: LD_VAR 0 8
28041: PPUSH
28042: CALL_OW 130
// end else
28046: GO 28106
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28048: LD_VAR 0 3
28052: PPUSH
28053: CALL_OW 256
28057: PUSH
28058: LD_INT 500
28060: LESS
28061: PUSH
28062: LD_VAR 0 3
28066: PPUSH
28067: LD_EXP 74
28071: PUSH
28072: LD_VAR 0 2
28076: ARRAY
28077: PPUSH
28078: CALL_OW 308
28082: NOT
28083: AND
28084: IFFALSE 28106
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28086: LD_VAR 0 3
28090: PPUSH
28091: LD_EXP 74
28095: PUSH
28096: LD_VAR 0 2
28100: ARRAY
28101: PPUSH
28102: CALL_OW 113
// end ;
28106: GO 27954
28108: POP
28109: POP
// end ; if tmp > 3 then
28110: LD_VAR 0 5
28114: PUSH
28115: LD_INT 3
28117: GREATER
28118: IFFALSE 28138
// tmp := ShrinkArray ( tmp , 4 ) ;
28120: LD_ADDR_VAR 0 5
28124: PUSH
28125: LD_VAR 0 5
28129: PPUSH
28130: LD_INT 4
28132: PPUSH
28133: CALL 87122 0 2
28137: ST_TO_ADDR
// if not tmp then
28138: LD_VAR 0 5
28142: NOT
28143: IFFALSE 28147
// continue ;
28145: GO 27527
// for j in tmp do
28147: LD_ADDR_VAR 0 3
28151: PUSH
28152: LD_VAR 0 5
28156: PUSH
28157: FOR_IN
28158: IFFALSE 28417
// begin if IsInUnit ( j ) then
28160: LD_VAR 0 3
28164: PPUSH
28165: CALL_OW 310
28169: IFFALSE 28180
// ComExitBuilding ( j ) ;
28171: LD_VAR 0 3
28175: PPUSH
28176: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28180: LD_VAR 0 3
28184: PUSH
28185: LD_EXP 52
28189: PUSH
28190: LD_VAR 0 2
28194: ARRAY
28195: IN
28196: NOT
28197: IFFALSE 28255
// begin SetTag ( j , 101 ) ;
28199: LD_VAR 0 3
28203: PPUSH
28204: LD_INT 101
28206: PPUSH
28207: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28211: LD_ADDR_EXP 52
28215: PUSH
28216: LD_EXP 52
28220: PPUSH
28221: LD_VAR 0 2
28225: PUSH
28226: LD_EXP 52
28230: PUSH
28231: LD_VAR 0 2
28235: ARRAY
28236: PUSH
28237: LD_INT 1
28239: PLUS
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PPUSH
28245: LD_VAR 0 3
28249: PPUSH
28250: CALL 54067 0 3
28254: ST_TO_ADDR
// end ; wait ( 1 ) ;
28255: LD_INT 1
28257: PPUSH
28258: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28262: LD_ADDR_VAR 0 7
28266: PUSH
28267: LD_EXP 51
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: ST_TO_ADDR
// if mc_scan [ i ] then
28278: LD_EXP 73
28282: PUSH
28283: LD_VAR 0 2
28287: ARRAY
28288: IFFALSE 28350
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28290: LD_ADDR_VAR 0 7
28294: PUSH
28295: LD_EXP 51
28299: PUSH
28300: LD_VAR 0 2
28304: ARRAY
28305: PPUSH
28306: LD_INT 3
28308: PUSH
28309: LD_INT 30
28311: PUSH
28312: LD_INT 32
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: LD_INT 30
28321: PUSH
28322: LD_INT 33
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 30
28331: PUSH
28332: LD_INT 31
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: PPUSH
28345: CALL_OW 72
28349: ST_TO_ADDR
// if not to_repair_tmp then
28350: LD_VAR 0 7
28354: NOT
28355: IFFALSE 28359
// continue ;
28357: GO 28157
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28359: LD_ADDR_VAR 0 8
28363: PUSH
28364: LD_VAR 0 7
28368: PPUSH
28369: LD_VAR 0 3
28373: PPUSH
28374: CALL_OW 74
28378: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28379: LD_VAR 0 8
28383: PPUSH
28384: LD_INT 16
28386: PPUSH
28387: CALL 57032 0 2
28391: PUSH
28392: LD_INT 4
28394: ARRAY
28395: PUSH
28396: LD_INT 14
28398: LESS
28399: IFFALSE 28415
// ComRepairBuilding ( j , to_repair ) ;
28401: LD_VAR 0 3
28405: PPUSH
28406: LD_VAR 0 8
28410: PPUSH
28411: CALL_OW 130
// end ;
28415: GO 28157
28417: POP
28418: POP
// end ;
28419: GO 27527
28421: POP
28422: POP
// end ;
28423: LD_VAR 0 1
28427: RET
// export function MC_Heal ; var i , j , tmp ; begin
28428: LD_INT 0
28430: PPUSH
28431: PPUSH
28432: PPUSH
28433: PPUSH
// if not mc_bases then
28434: LD_EXP 50
28438: NOT
28439: IFFALSE 28443
// exit ;
28441: GO 28845
// for i = 1 to mc_bases do
28443: LD_ADDR_VAR 0 2
28447: PUSH
28448: DOUBLE
28449: LD_INT 1
28451: DEC
28452: ST_TO_ADDR
28453: LD_EXP 50
28457: PUSH
28458: FOR_TO
28459: IFFALSE 28843
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28461: LD_EXP 53
28465: PUSH
28466: LD_VAR 0 2
28470: ARRAY
28471: PUSH
28472: LD_INT 1
28474: ARRAY
28475: NOT
28476: PUSH
28477: LD_EXP 53
28481: PUSH
28482: LD_VAR 0 2
28486: ARRAY
28487: PUSH
28488: LD_INT 2
28490: ARRAY
28491: NOT
28492: AND
28493: IFFALSE 28531
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28495: LD_ADDR_EXP 54
28499: PUSH
28500: LD_EXP 54
28504: PPUSH
28505: LD_VAR 0 2
28509: PPUSH
28510: EMPTY
28511: PPUSH
28512: CALL_OW 1
28516: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28517: LD_VAR 0 2
28521: PPUSH
28522: LD_INT 102
28524: PPUSH
28525: CALL 22566 0 2
// continue ;
28529: GO 28458
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28531: LD_ADDR_VAR 0 4
28535: PUSH
28536: LD_EXP 50
28540: PUSH
28541: LD_VAR 0 2
28545: ARRAY
28546: PPUSH
28547: LD_INT 25
28549: PUSH
28550: LD_INT 4
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PPUSH
28557: CALL_OW 72
28561: ST_TO_ADDR
// if not tmp then
28562: LD_VAR 0 4
28566: NOT
28567: IFFALSE 28571
// continue ;
28569: GO 28458
// if mc_taming [ i ] then
28571: LD_EXP 81
28575: PUSH
28576: LD_VAR 0 2
28580: ARRAY
28581: IFFALSE 28605
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28583: LD_ADDR_EXP 81
28587: PUSH
28588: LD_EXP 81
28592: PPUSH
28593: LD_VAR 0 2
28597: PPUSH
28598: EMPTY
28599: PPUSH
28600: CALL_OW 1
28604: ST_TO_ADDR
// for j in tmp do
28605: LD_ADDR_VAR 0 3
28609: PUSH
28610: LD_VAR 0 4
28614: PUSH
28615: FOR_IN
28616: IFFALSE 28839
// begin if IsInUnit ( j ) then
28618: LD_VAR 0 3
28622: PPUSH
28623: CALL_OW 310
28627: IFFALSE 28638
// ComExitBuilding ( j ) ;
28629: LD_VAR 0 3
28633: PPUSH
28634: CALL_OW 122
// if not j in mc_healers [ i ] then
28638: LD_VAR 0 3
28642: PUSH
28643: LD_EXP 54
28647: PUSH
28648: LD_VAR 0 2
28652: ARRAY
28653: IN
28654: NOT
28655: IFFALSE 28701
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28657: LD_ADDR_EXP 54
28661: PUSH
28662: LD_EXP 54
28666: PPUSH
28667: LD_VAR 0 2
28671: PUSH
28672: LD_EXP 54
28676: PUSH
28677: LD_VAR 0 2
28681: ARRAY
28682: PUSH
28683: LD_INT 1
28685: PLUS
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: CALL 54067 0 3
28700: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28701: LD_VAR 0 3
28705: PPUSH
28706: CALL_OW 110
28710: PUSH
28711: LD_INT 102
28713: NONEQUAL
28714: IFFALSE 28728
// SetTag ( j , 102 ) ;
28716: LD_VAR 0 3
28720: PPUSH
28721: LD_INT 102
28723: PPUSH
28724: CALL_OW 109
// Wait ( 3 ) ;
28728: LD_INT 3
28730: PPUSH
28731: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28735: LD_EXP 53
28739: PUSH
28740: LD_VAR 0 2
28744: ARRAY
28745: PUSH
28746: LD_INT 1
28748: ARRAY
28749: IFFALSE 28781
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28751: LD_VAR 0 3
28755: PPUSH
28756: LD_EXP 53
28760: PUSH
28761: LD_VAR 0 2
28765: ARRAY
28766: PUSH
28767: LD_INT 1
28769: ARRAY
28770: PUSH
28771: LD_INT 1
28773: ARRAY
28774: PPUSH
28775: CALL_OW 128
28779: GO 28837
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28781: LD_VAR 0 3
28785: PPUSH
28786: CALL_OW 314
28790: NOT
28791: PUSH
28792: LD_EXP 53
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PUSH
28803: LD_INT 2
28805: ARRAY
28806: AND
28807: IFFALSE 28837
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28809: LD_VAR 0 3
28813: PPUSH
28814: LD_EXP 53
28818: PUSH
28819: LD_VAR 0 2
28823: ARRAY
28824: PUSH
28825: LD_INT 2
28827: ARRAY
28828: PUSH
28829: LD_INT 1
28831: ARRAY
28832: PPUSH
28833: CALL_OW 128
// end ;
28837: GO 28615
28839: POP
28840: POP
// end ;
28841: GO 28458
28843: POP
28844: POP
// end ;
28845: LD_VAR 0 1
28849: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28850: LD_INT 0
28852: PPUSH
28853: PPUSH
28854: PPUSH
28855: PPUSH
28856: PPUSH
28857: PPUSH
// if not mc_bases then
28858: LD_EXP 50
28862: NOT
28863: IFFALSE 28867
// exit ;
28865: GO 30030
// for i = 1 to mc_bases do
28867: LD_ADDR_VAR 0 2
28871: PUSH
28872: DOUBLE
28873: LD_INT 1
28875: DEC
28876: ST_TO_ADDR
28877: LD_EXP 50
28881: PUSH
28882: FOR_TO
28883: IFFALSE 30028
// begin if mc_scan [ i ] then
28885: LD_EXP 73
28889: PUSH
28890: LD_VAR 0 2
28894: ARRAY
28895: IFFALSE 28899
// continue ;
28897: GO 28882
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28899: LD_EXP 55
28903: PUSH
28904: LD_VAR 0 2
28908: ARRAY
28909: NOT
28910: PUSH
28911: LD_EXP 57
28915: PUSH
28916: LD_VAR 0 2
28920: ARRAY
28921: NOT
28922: AND
28923: PUSH
28924: LD_EXP 56
28928: PUSH
28929: LD_VAR 0 2
28933: ARRAY
28934: AND
28935: IFFALSE 28973
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28937: LD_ADDR_EXP 56
28941: PUSH
28942: LD_EXP 56
28946: PPUSH
28947: LD_VAR 0 2
28951: PPUSH
28952: EMPTY
28953: PPUSH
28954: CALL_OW 1
28958: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28959: LD_VAR 0 2
28963: PPUSH
28964: LD_INT 103
28966: PPUSH
28967: CALL 22566 0 2
// continue ;
28971: GO 28882
// end ; if mc_construct_list [ i ] then
28973: LD_EXP 57
28977: PUSH
28978: LD_VAR 0 2
28982: ARRAY
28983: IFFALSE 29203
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28985: LD_ADDR_VAR 0 5
28989: PUSH
28990: LD_EXP 50
28994: PUSH
28995: LD_VAR 0 2
28999: ARRAY
29000: PPUSH
29001: LD_INT 25
29003: PUSH
29004: LD_INT 2
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: PPUSH
29011: CALL_OW 72
29015: PUSH
29016: LD_EXP 52
29020: PUSH
29021: LD_VAR 0 2
29025: ARRAY
29026: DIFF
29027: ST_TO_ADDR
// if not tmp then
29028: LD_VAR 0 5
29032: NOT
29033: IFFALSE 29037
// continue ;
29035: GO 28882
// for j in tmp do
29037: LD_ADDR_VAR 0 3
29041: PUSH
29042: LD_VAR 0 5
29046: PUSH
29047: FOR_IN
29048: IFFALSE 29199
// begin if not mc_builders [ i ] then
29050: LD_EXP 56
29054: PUSH
29055: LD_VAR 0 2
29059: ARRAY
29060: NOT
29061: IFFALSE 29119
// begin SetTag ( j , 103 ) ;
29063: LD_VAR 0 3
29067: PPUSH
29068: LD_INT 103
29070: PPUSH
29071: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29075: LD_ADDR_EXP 56
29079: PUSH
29080: LD_EXP 56
29084: PPUSH
29085: LD_VAR 0 2
29089: PUSH
29090: LD_EXP 56
29094: PUSH
29095: LD_VAR 0 2
29099: ARRAY
29100: PUSH
29101: LD_INT 1
29103: PLUS
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PPUSH
29109: LD_VAR 0 3
29113: PPUSH
29114: CALL 54067 0 3
29118: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29119: LD_VAR 0 3
29123: PPUSH
29124: CALL_OW 310
29128: IFFALSE 29139
// ComExitBuilding ( j ) ;
29130: LD_VAR 0 3
29134: PPUSH
29135: CALL_OW 122
// wait ( 3 ) ;
29139: LD_INT 3
29141: PPUSH
29142: CALL_OW 67
// if not mc_construct_list [ i ] then
29146: LD_EXP 57
29150: PUSH
29151: LD_VAR 0 2
29155: ARRAY
29156: NOT
29157: IFFALSE 29161
// break ;
29159: GO 29199
// if not HasTask ( j ) then
29161: LD_VAR 0 3
29165: PPUSH
29166: CALL_OW 314
29170: NOT
29171: IFFALSE 29197
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29173: LD_VAR 0 3
29177: PPUSH
29178: LD_EXP 57
29182: PUSH
29183: LD_VAR 0 2
29187: ARRAY
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PPUSH
29193: CALL 57305 0 2
// end ;
29197: GO 29047
29199: POP
29200: POP
// end else
29201: GO 30026
// if mc_build_list [ i ] then
29203: LD_EXP 55
29207: PUSH
29208: LD_VAR 0 2
29212: ARRAY
29213: IFFALSE 30026
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29215: LD_EXP 55
29219: PUSH
29220: LD_VAR 0 2
29224: ARRAY
29225: PUSH
29226: LD_INT 1
29228: ARRAY
29229: PUSH
29230: LD_INT 1
29232: ARRAY
29233: PPUSH
29234: CALL 57129 0 1
29238: PUSH
29239: LD_EXP 50
29243: PUSH
29244: LD_VAR 0 2
29248: ARRAY
29249: PPUSH
29250: LD_INT 2
29252: PUSH
29253: LD_INT 30
29255: PUSH
29256: LD_INT 2
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 30
29265: PUSH
29266: LD_INT 3
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: LIST
29277: PPUSH
29278: CALL_OW 72
29282: NOT
29283: AND
29284: IFFALSE 29389
// begin for j = 1 to mc_build_list [ i ] do
29286: LD_ADDR_VAR 0 3
29290: PUSH
29291: DOUBLE
29292: LD_INT 1
29294: DEC
29295: ST_TO_ADDR
29296: LD_EXP 55
29300: PUSH
29301: LD_VAR 0 2
29305: ARRAY
29306: PUSH
29307: FOR_TO
29308: IFFALSE 29387
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29310: LD_EXP 55
29314: PUSH
29315: LD_VAR 0 2
29319: ARRAY
29320: PUSH
29321: LD_VAR 0 3
29325: ARRAY
29326: PUSH
29327: LD_INT 1
29329: ARRAY
29330: PUSH
29331: LD_INT 2
29333: EQUAL
29334: IFFALSE 29385
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29336: LD_ADDR_EXP 55
29340: PUSH
29341: LD_EXP 55
29345: PPUSH
29346: LD_VAR 0 2
29350: PPUSH
29351: LD_EXP 55
29355: PUSH
29356: LD_VAR 0 2
29360: ARRAY
29361: PPUSH
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_INT 1
29369: PPUSH
29370: LD_INT 0
29372: PPUSH
29373: CALL 53485 0 4
29377: PPUSH
29378: CALL_OW 1
29382: ST_TO_ADDR
// break ;
29383: GO 29387
// end ;
29385: GO 29307
29387: POP
29388: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29389: LD_ADDR_VAR 0 6
29393: PUSH
29394: LD_EXP 50
29398: PUSH
29399: LD_VAR 0 2
29403: ARRAY
29404: PPUSH
29405: LD_INT 2
29407: PUSH
29408: LD_INT 30
29410: PUSH
29411: LD_INT 0
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 30
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: LIST
29432: PPUSH
29433: CALL_OW 72
29437: ST_TO_ADDR
// for k := 1 to depot do
29438: LD_ADDR_VAR 0 4
29442: PUSH
29443: DOUBLE
29444: LD_INT 1
29446: DEC
29447: ST_TO_ADDR
29448: LD_VAR 0 6
29452: PUSH
29453: FOR_TO
29454: IFFALSE 30024
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29456: LD_EXP 55
29460: PUSH
29461: LD_VAR 0 2
29465: ARRAY
29466: PUSH
29467: LD_INT 1
29469: ARRAY
29470: PUSH
29471: LD_INT 1
29473: ARRAY
29474: PUSH
29475: LD_INT 0
29477: EQUAL
29478: PUSH
29479: LD_VAR 0 6
29483: PUSH
29484: LD_VAR 0 4
29488: ARRAY
29489: PPUSH
29490: LD_EXP 55
29494: PUSH
29495: LD_VAR 0 2
29499: ARRAY
29500: PUSH
29501: LD_INT 1
29503: ARRAY
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: LD_EXP 55
29513: PUSH
29514: LD_VAR 0 2
29518: ARRAY
29519: PUSH
29520: LD_INT 1
29522: ARRAY
29523: PUSH
29524: LD_INT 2
29526: ARRAY
29527: PPUSH
29528: LD_EXP 55
29532: PUSH
29533: LD_VAR 0 2
29537: ARRAY
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PUSH
29543: LD_INT 3
29545: ARRAY
29546: PPUSH
29547: LD_EXP 55
29551: PUSH
29552: LD_VAR 0 2
29556: ARRAY
29557: PUSH
29558: LD_INT 1
29560: ARRAY
29561: PUSH
29562: LD_INT 4
29564: ARRAY
29565: PPUSH
29566: CALL 62541 0 5
29570: OR
29571: IFFALSE 29852
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29573: LD_ADDR_VAR 0 5
29577: PUSH
29578: LD_EXP 50
29582: PUSH
29583: LD_VAR 0 2
29587: ARRAY
29588: PPUSH
29589: LD_INT 25
29591: PUSH
29592: LD_INT 2
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PPUSH
29599: CALL_OW 72
29603: PUSH
29604: LD_EXP 52
29608: PUSH
29609: LD_VAR 0 2
29613: ARRAY
29614: DIFF
29615: ST_TO_ADDR
// if not tmp then
29616: LD_VAR 0 5
29620: NOT
29621: IFFALSE 29625
// continue ;
29623: GO 29453
// for j in tmp do
29625: LD_ADDR_VAR 0 3
29629: PUSH
29630: LD_VAR 0 5
29634: PUSH
29635: FOR_IN
29636: IFFALSE 29848
// begin if not mc_builders [ i ] then
29638: LD_EXP 56
29642: PUSH
29643: LD_VAR 0 2
29647: ARRAY
29648: NOT
29649: IFFALSE 29707
// begin SetTag ( j , 103 ) ;
29651: LD_VAR 0 3
29655: PPUSH
29656: LD_INT 103
29658: PPUSH
29659: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29663: LD_ADDR_EXP 56
29667: PUSH
29668: LD_EXP 56
29672: PPUSH
29673: LD_VAR 0 2
29677: PUSH
29678: LD_EXP 56
29682: PUSH
29683: LD_VAR 0 2
29687: ARRAY
29688: PUSH
29689: LD_INT 1
29691: PLUS
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PPUSH
29697: LD_VAR 0 3
29701: PPUSH
29702: CALL 54067 0 3
29706: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29707: LD_VAR 0 3
29711: PPUSH
29712: CALL_OW 310
29716: IFFALSE 29727
// ComExitBuilding ( j ) ;
29718: LD_VAR 0 3
29722: PPUSH
29723: CALL_OW 122
// wait ( 3 ) ;
29727: LD_INT 3
29729: PPUSH
29730: CALL_OW 67
// if not mc_build_list [ i ] then
29734: LD_EXP 55
29738: PUSH
29739: LD_VAR 0 2
29743: ARRAY
29744: NOT
29745: IFFALSE 29749
// break ;
29747: GO 29848
// if not HasTask ( j ) then
29749: LD_VAR 0 3
29753: PPUSH
29754: CALL_OW 314
29758: NOT
29759: IFFALSE 29846
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29761: LD_VAR 0 3
29765: PPUSH
29766: LD_EXP 55
29770: PUSH
29771: LD_VAR 0 2
29775: ARRAY
29776: PUSH
29777: LD_INT 1
29779: ARRAY
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: PPUSH
29785: LD_EXP 55
29789: PUSH
29790: LD_VAR 0 2
29794: ARRAY
29795: PUSH
29796: LD_INT 1
29798: ARRAY
29799: PUSH
29800: LD_INT 2
29802: ARRAY
29803: PPUSH
29804: LD_EXP 55
29808: PUSH
29809: LD_VAR 0 2
29813: ARRAY
29814: PUSH
29815: LD_INT 1
29817: ARRAY
29818: PUSH
29819: LD_INT 3
29821: ARRAY
29822: PPUSH
29823: LD_EXP 55
29827: PUSH
29828: LD_VAR 0 2
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: ARRAY
29837: PUSH
29838: LD_INT 4
29840: ARRAY
29841: PPUSH
29842: CALL_OW 145
// end ;
29846: GO 29635
29848: POP
29849: POP
// end else
29850: GO 30022
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29852: LD_EXP 50
29856: PUSH
29857: LD_VAR 0 2
29861: ARRAY
29862: PPUSH
29863: LD_EXP 55
29867: PUSH
29868: LD_VAR 0 2
29872: ARRAY
29873: PUSH
29874: LD_INT 1
29876: ARRAY
29877: PUSH
29878: LD_INT 1
29880: ARRAY
29881: PPUSH
29882: LD_EXP 55
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: PUSH
29893: LD_INT 1
29895: ARRAY
29896: PUSH
29897: LD_INT 2
29899: ARRAY
29900: PPUSH
29901: LD_EXP 55
29905: PUSH
29906: LD_VAR 0 2
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: ARRAY
29915: PUSH
29916: LD_INT 3
29918: ARRAY
29919: PPUSH
29920: LD_EXP 55
29924: PUSH
29925: LD_VAR 0 2
29929: ARRAY
29930: PUSH
29931: LD_INT 1
29933: ARRAY
29934: PUSH
29935: LD_INT 4
29937: ARRAY
29938: PPUSH
29939: LD_EXP 50
29943: PUSH
29944: LD_VAR 0 2
29948: ARRAY
29949: PPUSH
29950: LD_INT 21
29952: PUSH
29953: LD_INT 3
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PPUSH
29960: CALL_OW 72
29964: PPUSH
29965: EMPTY
29966: PPUSH
29967: CALL 61295 0 7
29971: NOT
29972: IFFALSE 30022
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29974: LD_ADDR_EXP 55
29978: PUSH
29979: LD_EXP 55
29983: PPUSH
29984: LD_VAR 0 2
29988: PPUSH
29989: LD_EXP 55
29993: PUSH
29994: LD_VAR 0 2
29998: ARRAY
29999: PPUSH
30000: LD_INT 1
30002: PPUSH
30003: LD_INT 1
30005: NEG
30006: PPUSH
30007: LD_INT 0
30009: PPUSH
30010: CALL 53485 0 4
30014: PPUSH
30015: CALL_OW 1
30019: ST_TO_ADDR
// continue ;
30020: GO 29453
// end ; end ;
30022: GO 29453
30024: POP
30025: POP
// end ; end ;
30026: GO 28882
30028: POP
30029: POP
// end ;
30030: LD_VAR 0 1
30034: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30035: LD_INT 0
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
// if not mc_bases then
30043: LD_EXP 50
30047: NOT
30048: IFFALSE 30052
// exit ;
30050: GO 30479
// for i = 1 to mc_bases do
30052: LD_ADDR_VAR 0 2
30056: PUSH
30057: DOUBLE
30058: LD_INT 1
30060: DEC
30061: ST_TO_ADDR
30062: LD_EXP 50
30066: PUSH
30067: FOR_TO
30068: IFFALSE 30477
// begin tmp := mc_build_upgrade [ i ] ;
30070: LD_ADDR_VAR 0 4
30074: PUSH
30075: LD_EXP 82
30079: PUSH
30080: LD_VAR 0 2
30084: ARRAY
30085: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30086: LD_ADDR_VAR 0 6
30090: PUSH
30091: LD_EXP 83
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PPUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 30
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 30
30117: PUSH
30118: LD_INT 7
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ST_TO_ADDR
// if not tmp and not lab then
30135: LD_VAR 0 4
30139: NOT
30140: PUSH
30141: LD_VAR 0 6
30145: NOT
30146: AND
30147: IFFALSE 30151
// continue ;
30149: GO 30067
// if tmp then
30151: LD_VAR 0 4
30155: IFFALSE 30275
// for j in tmp do
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_VAR 0 4
30166: PUSH
30167: FOR_IN
30168: IFFALSE 30273
// begin if UpgradeCost ( j ) then
30170: LD_VAR 0 3
30174: PPUSH
30175: CALL 60955 0 1
30179: IFFALSE 30271
// begin ComUpgrade ( j ) ;
30181: LD_VAR 0 3
30185: PPUSH
30186: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30190: LD_ADDR_EXP 82
30194: PUSH
30195: LD_EXP 82
30199: PPUSH
30200: LD_VAR 0 2
30204: PPUSH
30205: LD_EXP 82
30209: PUSH
30210: LD_VAR 0 2
30214: ARRAY
30215: PUSH
30216: LD_VAR 0 3
30220: DIFF
30221: PPUSH
30222: CALL_OW 1
30226: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30227: LD_ADDR_EXP 57
30231: PUSH
30232: LD_EXP 57
30236: PPUSH
30237: LD_VAR 0 2
30241: PUSH
30242: LD_EXP 57
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: PUSH
30253: LD_INT 1
30255: PLUS
30256: PUSH
30257: EMPTY
30258: LIST
30259: LIST
30260: PPUSH
30261: LD_VAR 0 3
30265: PPUSH
30266: CALL 54067 0 3
30270: ST_TO_ADDR
// end ; end ;
30271: GO 30167
30273: POP
30274: POP
// if not lab or not mc_lab_upgrade [ i ] then
30275: LD_VAR 0 6
30279: NOT
30280: PUSH
30281: LD_EXP 84
30285: PUSH
30286: LD_VAR 0 2
30290: ARRAY
30291: NOT
30292: OR
30293: IFFALSE 30297
// continue ;
30295: GO 30067
// for j in lab do
30297: LD_ADDR_VAR 0 3
30301: PUSH
30302: LD_VAR 0 6
30306: PUSH
30307: FOR_IN
30308: IFFALSE 30473
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30310: LD_VAR 0 3
30314: PPUSH
30315: CALL_OW 266
30319: PUSH
30320: LD_INT 6
30322: PUSH
30323: LD_INT 7
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: IN
30330: PUSH
30331: LD_VAR 0 3
30335: PPUSH
30336: CALL_OW 461
30340: PUSH
30341: LD_INT 1
30343: NONEQUAL
30344: AND
30345: IFFALSE 30471
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30347: LD_VAR 0 3
30351: PPUSH
30352: LD_EXP 84
30356: PUSH
30357: LD_VAR 0 2
30361: ARRAY
30362: PUSH
30363: LD_INT 1
30365: ARRAY
30366: PPUSH
30367: CALL 61160 0 2
30371: IFFALSE 30471
// begin ComCancel ( j ) ;
30373: LD_VAR 0 3
30377: PPUSH
30378: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30382: LD_VAR 0 3
30386: PPUSH
30387: LD_EXP 84
30391: PUSH
30392: LD_VAR 0 2
30396: ARRAY
30397: PUSH
30398: LD_INT 1
30400: ARRAY
30401: PPUSH
30402: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30406: LD_VAR 0 3
30410: PUSH
30411: LD_EXP 57
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: IN
30422: NOT
30423: IFFALSE 30469
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30425: LD_ADDR_EXP 57
30429: PUSH
30430: LD_EXP 57
30434: PPUSH
30435: LD_VAR 0 2
30439: PUSH
30440: LD_EXP 57
30444: PUSH
30445: LD_VAR 0 2
30449: ARRAY
30450: PUSH
30451: LD_INT 1
30453: PLUS
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PPUSH
30459: LD_VAR 0 3
30463: PPUSH
30464: CALL 54067 0 3
30468: ST_TO_ADDR
// break ;
30469: GO 30473
// end ; end ; end ;
30471: GO 30307
30473: POP
30474: POP
// end ;
30475: GO 30067
30477: POP
30478: POP
// end ;
30479: LD_VAR 0 1
30483: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30484: LD_INT 0
30486: PPUSH
30487: PPUSH
30488: PPUSH
30489: PPUSH
30490: PPUSH
30491: PPUSH
30492: PPUSH
30493: PPUSH
30494: PPUSH
// if not mc_bases then
30495: LD_EXP 50
30499: NOT
30500: IFFALSE 30504
// exit ;
30502: GO 30909
// for i = 1 to mc_bases do
30504: LD_ADDR_VAR 0 2
30508: PUSH
30509: DOUBLE
30510: LD_INT 1
30512: DEC
30513: ST_TO_ADDR
30514: LD_EXP 50
30518: PUSH
30519: FOR_TO
30520: IFFALSE 30907
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30522: LD_EXP 58
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: NOT
30533: PUSH
30534: LD_EXP 50
30538: PUSH
30539: LD_VAR 0 2
30543: ARRAY
30544: PPUSH
30545: LD_INT 30
30547: PUSH
30548: LD_INT 3
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PPUSH
30555: CALL_OW 72
30559: NOT
30560: OR
30561: IFFALSE 30565
// continue ;
30563: GO 30519
// busy := false ;
30565: LD_ADDR_VAR 0 8
30569: PUSH
30570: LD_INT 0
30572: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30573: LD_ADDR_VAR 0 4
30577: PUSH
30578: LD_EXP 50
30582: PUSH
30583: LD_VAR 0 2
30587: ARRAY
30588: PPUSH
30589: LD_INT 30
30591: PUSH
30592: LD_INT 3
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PPUSH
30599: CALL_OW 72
30603: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30604: LD_ADDR_VAR 0 6
30608: PUSH
30609: LD_EXP 58
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PPUSH
30620: LD_INT 2
30622: PUSH
30623: LD_INT 30
30625: PUSH
30626: LD_INT 32
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 30
30635: PUSH
30636: LD_INT 33
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: LIST
30647: PPUSH
30648: CALL_OW 72
30652: ST_TO_ADDR
// if not t then
30653: LD_VAR 0 6
30657: NOT
30658: IFFALSE 30662
// continue ;
30660: GO 30519
// for j in tmp do
30662: LD_ADDR_VAR 0 3
30666: PUSH
30667: LD_VAR 0 4
30671: PUSH
30672: FOR_IN
30673: IFFALSE 30703
// if not BuildingStatus ( j ) = bs_idle then
30675: LD_VAR 0 3
30679: PPUSH
30680: CALL_OW 461
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: NOT
30689: IFFALSE 30701
// begin busy := true ;
30691: LD_ADDR_VAR 0 8
30695: PUSH
30696: LD_INT 1
30698: ST_TO_ADDR
// break ;
30699: GO 30703
// end ;
30701: GO 30672
30703: POP
30704: POP
// if busy then
30705: LD_VAR 0 8
30709: IFFALSE 30713
// continue ;
30711: GO 30519
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30713: LD_ADDR_VAR 0 7
30717: PUSH
30718: LD_VAR 0 6
30722: PPUSH
30723: LD_INT 35
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PPUSH
30733: CALL_OW 72
30737: ST_TO_ADDR
// if tw then
30738: LD_VAR 0 7
30742: IFFALSE 30819
// begin tw := tw [ 1 ] ;
30744: LD_ADDR_VAR 0 7
30748: PUSH
30749: LD_VAR 0 7
30753: PUSH
30754: LD_INT 1
30756: ARRAY
30757: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30758: LD_ADDR_VAR 0 9
30762: PUSH
30763: LD_VAR 0 7
30767: PPUSH
30768: LD_EXP 75
30772: PUSH
30773: LD_VAR 0 2
30777: ARRAY
30778: PPUSH
30779: CALL 59452 0 2
30783: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30784: LD_EXP 89
30788: PUSH
30789: LD_VAR 0 2
30793: ARRAY
30794: IFFALSE 30817
// if not weapon in mc_allowed_tower_weapons [ i ] then
30796: LD_VAR 0 9
30800: PUSH
30801: LD_EXP 89
30805: PUSH
30806: LD_VAR 0 2
30810: ARRAY
30811: IN
30812: NOT
30813: IFFALSE 30817
// continue ;
30815: GO 30519
// end else
30817: GO 30882
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30819: LD_ADDR_VAR 0 5
30823: PUSH
30824: LD_EXP 58
30828: PUSH
30829: LD_VAR 0 2
30833: ARRAY
30834: PPUSH
30835: LD_VAR 0 4
30839: PPUSH
30840: CALL 86355 0 2
30844: ST_TO_ADDR
// if not tmp2 then
30845: LD_VAR 0 5
30849: NOT
30850: IFFALSE 30854
// continue ;
30852: GO 30519
// tw := tmp2 [ 1 ] ;
30854: LD_ADDR_VAR 0 7
30858: PUSH
30859: LD_VAR 0 5
30863: PUSH
30864: LD_INT 1
30866: ARRAY
30867: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30868: LD_ADDR_VAR 0 9
30872: PUSH
30873: LD_VAR 0 5
30877: PUSH
30878: LD_INT 2
30880: ARRAY
30881: ST_TO_ADDR
// end ; if not weapon then
30882: LD_VAR 0 9
30886: NOT
30887: IFFALSE 30891
// continue ;
30889: GO 30519
// ComPlaceWeapon ( tw , weapon ) ;
30891: LD_VAR 0 7
30895: PPUSH
30896: LD_VAR 0 9
30900: PPUSH
30901: CALL_OW 148
// end ;
30905: GO 30519
30907: POP
30908: POP
// end ;
30909: LD_VAR 0 1
30913: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30914: LD_INT 0
30916: PPUSH
30917: PPUSH
30918: PPUSH
30919: PPUSH
30920: PPUSH
30921: PPUSH
30922: PPUSH
// if not mc_bases then
30923: LD_EXP 50
30927: NOT
30928: IFFALSE 30932
// exit ;
30930: GO 31707
// for i = 1 to mc_bases do
30932: LD_ADDR_VAR 0 2
30936: PUSH
30937: DOUBLE
30938: LD_INT 1
30940: DEC
30941: ST_TO_ADDR
30942: LD_EXP 50
30946: PUSH
30947: FOR_TO
30948: IFFALSE 31705
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30950: LD_EXP 63
30954: PUSH
30955: LD_VAR 0 2
30959: ARRAY
30960: NOT
30961: PUSH
30962: LD_EXP 63
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PUSH
30973: LD_EXP 64
30977: PUSH
30978: LD_VAR 0 2
30982: ARRAY
30983: EQUAL
30984: OR
30985: PUSH
30986: LD_EXP 73
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: OR
30997: IFFALSE 31001
// continue ;
30999: GO 30947
// if mc_miners [ i ] then
31001: LD_EXP 64
31005: PUSH
31006: LD_VAR 0 2
31010: ARRAY
31011: IFFALSE 31392
// begin for j = mc_miners [ i ] downto 1 do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: DOUBLE
31019: LD_EXP 64
31023: PUSH
31024: LD_VAR 0 2
31028: ARRAY
31029: INC
31030: ST_TO_ADDR
31031: LD_INT 1
31033: PUSH
31034: FOR_DOWNTO
31035: IFFALSE 31390
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31037: LD_EXP 64
31041: PUSH
31042: LD_VAR 0 2
31046: ARRAY
31047: PUSH
31048: LD_VAR 0 3
31052: ARRAY
31053: PPUSH
31054: CALL_OW 301
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: PUSH
31070: LD_VAR 0 3
31074: ARRAY
31075: PPUSH
31076: CALL_OW 257
31080: PUSH
31081: LD_INT 1
31083: NONEQUAL
31084: OR
31085: IFFALSE 31148
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31087: LD_ADDR_VAR 0 5
31091: PUSH
31092: LD_EXP 64
31096: PUSH
31097: LD_VAR 0 2
31101: ARRAY
31102: PUSH
31103: LD_EXP 64
31107: PUSH
31108: LD_VAR 0 2
31112: ARRAY
31113: PUSH
31114: LD_VAR 0 3
31118: ARRAY
31119: DIFF
31120: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31121: LD_ADDR_EXP 64
31125: PUSH
31126: LD_EXP 64
31130: PPUSH
31131: LD_VAR 0 2
31135: PPUSH
31136: LD_VAR 0 5
31140: PPUSH
31141: CALL_OW 1
31145: ST_TO_ADDR
// continue ;
31146: GO 31034
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31148: LD_EXP 64
31152: PUSH
31153: LD_VAR 0 2
31157: ARRAY
31158: PUSH
31159: LD_VAR 0 3
31163: ARRAY
31164: PPUSH
31165: CALL_OW 257
31169: PUSH
31170: LD_INT 1
31172: EQUAL
31173: PUSH
31174: LD_EXP 64
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: PUSH
31185: LD_VAR 0 3
31189: ARRAY
31190: PPUSH
31191: CALL_OW 459
31195: NOT
31196: AND
31197: PUSH
31198: LD_EXP 64
31202: PUSH
31203: LD_VAR 0 2
31207: ARRAY
31208: PUSH
31209: LD_VAR 0 3
31213: ARRAY
31214: PPUSH
31215: CALL_OW 314
31219: NOT
31220: AND
31221: IFFALSE 31388
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31223: LD_EXP 64
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: PUSH
31234: LD_VAR 0 3
31238: ARRAY
31239: PPUSH
31240: CALL_OW 310
31244: IFFALSE 31267
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31246: LD_EXP 64
31250: PUSH
31251: LD_VAR 0 2
31255: ARRAY
31256: PUSH
31257: LD_VAR 0 3
31261: ARRAY
31262: PPUSH
31263: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31267: LD_EXP 64
31271: PUSH
31272: LD_VAR 0 2
31276: ARRAY
31277: PUSH
31278: LD_VAR 0 3
31282: ARRAY
31283: PPUSH
31284: CALL_OW 314
31288: NOT
31289: IFFALSE 31388
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31291: LD_ADDR_VAR 0 7
31295: PUSH
31296: LD_VAR 0 3
31300: PUSH
31301: LD_EXP 63
31305: PUSH
31306: LD_VAR 0 2
31310: ARRAY
31311: PPUSH
31312: CALL 51207 0 1
31316: MOD
31317: PUSH
31318: LD_INT 1
31320: PLUS
31321: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31322: LD_EXP 64
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: PUSH
31333: LD_VAR 0 3
31337: ARRAY
31338: PPUSH
31339: LD_EXP 63
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: PUSH
31350: LD_VAR 0 7
31354: ARRAY
31355: PUSH
31356: LD_INT 1
31358: ARRAY
31359: PPUSH
31360: LD_EXP 63
31364: PUSH
31365: LD_VAR 0 2
31369: ARRAY
31370: PUSH
31371: LD_VAR 0 7
31375: ARRAY
31376: PUSH
31377: LD_INT 2
31379: ARRAY
31380: PPUSH
31381: LD_INT 0
31383: PPUSH
31384: CALL_OW 193
// end ; end ; end ;
31388: GO 31034
31390: POP
31391: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31392: LD_ADDR_VAR 0 5
31396: PUSH
31397: LD_EXP 50
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PPUSH
31408: LD_INT 2
31410: PUSH
31411: LD_INT 30
31413: PUSH
31414: LD_INT 4
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 30
31423: PUSH
31424: LD_INT 5
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 30
31433: PUSH
31434: LD_INT 32
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: PPUSH
31447: CALL_OW 72
31451: ST_TO_ADDR
// if not tmp then
31452: LD_VAR 0 5
31456: NOT
31457: IFFALSE 31461
// continue ;
31459: GO 30947
// list := [ ] ;
31461: LD_ADDR_VAR 0 6
31465: PUSH
31466: EMPTY
31467: ST_TO_ADDR
// for j in tmp do
31468: LD_ADDR_VAR 0 3
31472: PUSH
31473: LD_VAR 0 5
31477: PUSH
31478: FOR_IN
31479: IFFALSE 31548
// begin for k in UnitsInside ( j ) do
31481: LD_ADDR_VAR 0 4
31485: PUSH
31486: LD_VAR 0 3
31490: PPUSH
31491: CALL_OW 313
31495: PUSH
31496: FOR_IN
31497: IFFALSE 31544
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31499: LD_VAR 0 4
31503: PPUSH
31504: CALL_OW 257
31508: PUSH
31509: LD_INT 1
31511: EQUAL
31512: PUSH
31513: LD_VAR 0 4
31517: PPUSH
31518: CALL_OW 459
31522: NOT
31523: AND
31524: IFFALSE 31542
// list := list ^ k ;
31526: LD_ADDR_VAR 0 6
31530: PUSH
31531: LD_VAR 0 6
31535: PUSH
31536: LD_VAR 0 4
31540: ADD
31541: ST_TO_ADDR
31542: GO 31496
31544: POP
31545: POP
// end ;
31546: GO 31478
31548: POP
31549: POP
// list := list diff mc_miners [ i ] ;
31550: LD_ADDR_VAR 0 6
31554: PUSH
31555: LD_VAR 0 6
31559: PUSH
31560: LD_EXP 64
31564: PUSH
31565: LD_VAR 0 2
31569: ARRAY
31570: DIFF
31571: ST_TO_ADDR
// if not list then
31572: LD_VAR 0 6
31576: NOT
31577: IFFALSE 31581
// continue ;
31579: GO 30947
// k := mc_mines [ i ] - mc_miners [ i ] ;
31581: LD_ADDR_VAR 0 4
31585: PUSH
31586: LD_EXP 63
31590: PUSH
31591: LD_VAR 0 2
31595: ARRAY
31596: PUSH
31597: LD_EXP 64
31601: PUSH
31602: LD_VAR 0 2
31606: ARRAY
31607: MINUS
31608: ST_TO_ADDR
// if k > list then
31609: LD_VAR 0 4
31613: PUSH
31614: LD_VAR 0 6
31618: GREATER
31619: IFFALSE 31631
// k := list ;
31621: LD_ADDR_VAR 0 4
31625: PUSH
31626: LD_VAR 0 6
31630: ST_TO_ADDR
// for j = 1 to k do
31631: LD_ADDR_VAR 0 3
31635: PUSH
31636: DOUBLE
31637: LD_INT 1
31639: DEC
31640: ST_TO_ADDR
31641: LD_VAR 0 4
31645: PUSH
31646: FOR_TO
31647: IFFALSE 31701
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31649: LD_ADDR_EXP 64
31653: PUSH
31654: LD_EXP 64
31658: PPUSH
31659: LD_VAR 0 2
31663: PUSH
31664: LD_EXP 64
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: LD_INT 1
31677: PLUS
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PPUSH
31683: LD_VAR 0 6
31687: PUSH
31688: LD_VAR 0 3
31692: ARRAY
31693: PPUSH
31694: CALL 54067 0 3
31698: ST_TO_ADDR
31699: GO 31646
31701: POP
31702: POP
// end ;
31703: GO 30947
31705: POP
31706: POP
// end ;
31707: LD_VAR 0 1
31711: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31712: LD_INT 0
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
31724: PPUSH
// if not mc_bases then
31725: LD_EXP 50
31729: NOT
31730: IFFALSE 31734
// exit ;
31732: GO 33557
// for i = 1 to mc_bases do
31734: LD_ADDR_VAR 0 2
31738: PUSH
31739: DOUBLE
31740: LD_INT 1
31742: DEC
31743: ST_TO_ADDR
31744: LD_EXP 50
31748: PUSH
31749: FOR_TO
31750: IFFALSE 33555
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31752: LD_EXP 50
31756: PUSH
31757: LD_VAR 0 2
31761: ARRAY
31762: NOT
31763: PUSH
31764: LD_EXP 57
31768: PUSH
31769: LD_VAR 0 2
31773: ARRAY
31774: OR
31775: IFFALSE 31779
// continue ;
31777: GO 31749
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31779: LD_EXP 66
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: NOT
31790: PUSH
31791: LD_EXP 67
31795: PUSH
31796: LD_VAR 0 2
31800: ARRAY
31801: AND
31802: IFFALSE 31840
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31804: LD_ADDR_EXP 67
31808: PUSH
31809: LD_EXP 67
31813: PPUSH
31814: LD_VAR 0 2
31818: PPUSH
31819: EMPTY
31820: PPUSH
31821: CALL_OW 1
31825: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31826: LD_VAR 0 2
31830: PPUSH
31831: LD_INT 107
31833: PPUSH
31834: CALL 22566 0 2
// continue ;
31838: GO 31749
// end ; target := [ ] ;
31840: LD_ADDR_VAR 0 7
31844: PUSH
31845: EMPTY
31846: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31847: LD_ADDR_VAR 0 6
31851: PUSH
31852: LD_EXP 50
31856: PUSH
31857: LD_VAR 0 2
31861: ARRAY
31862: PUSH
31863: LD_INT 1
31865: ARRAY
31866: PPUSH
31867: CALL_OW 255
31871: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31872: LD_ADDR_VAR 0 9
31876: PUSH
31877: LD_EXP 50
31881: PUSH
31882: LD_VAR 0 2
31886: ARRAY
31887: PPUSH
31888: LD_INT 2
31890: PUSH
31891: LD_INT 30
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 30
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 72
31920: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31921: LD_ADDR_VAR 0 3
31925: PUSH
31926: DOUBLE
31927: LD_EXP 66
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: INC
31938: ST_TO_ADDR
31939: LD_INT 1
31941: PUSH
31942: FOR_DOWNTO
31943: IFFALSE 32188
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31945: LD_EXP 66
31949: PUSH
31950: LD_VAR 0 2
31954: ARRAY
31955: PUSH
31956: LD_VAR 0 3
31960: ARRAY
31961: PUSH
31962: LD_INT 2
31964: ARRAY
31965: PPUSH
31966: LD_EXP 66
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: PUSH
31977: LD_VAR 0 3
31981: ARRAY
31982: PUSH
31983: LD_INT 3
31985: ARRAY
31986: PPUSH
31987: CALL_OW 488
31991: PUSH
31992: LD_EXP 66
31996: PUSH
31997: LD_VAR 0 2
32001: ARRAY
32002: PUSH
32003: LD_VAR 0 3
32007: ARRAY
32008: PUSH
32009: LD_INT 2
32011: ARRAY
32012: PPUSH
32013: LD_EXP 66
32017: PUSH
32018: LD_VAR 0 2
32022: ARRAY
32023: PUSH
32024: LD_VAR 0 3
32028: ARRAY
32029: PUSH
32030: LD_INT 3
32032: ARRAY
32033: PPUSH
32034: CALL_OW 284
32038: PUSH
32039: LD_INT 0
32041: EQUAL
32042: AND
32043: IFFALSE 32098
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32045: LD_ADDR_VAR 0 5
32049: PUSH
32050: LD_EXP 66
32054: PUSH
32055: LD_VAR 0 2
32059: ARRAY
32060: PPUSH
32061: LD_VAR 0 3
32065: PPUSH
32066: CALL_OW 3
32070: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32071: LD_ADDR_EXP 66
32075: PUSH
32076: LD_EXP 66
32080: PPUSH
32081: LD_VAR 0 2
32085: PPUSH
32086: LD_VAR 0 5
32090: PPUSH
32091: CALL_OW 1
32095: ST_TO_ADDR
// continue ;
32096: GO 31942
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32098: LD_VAR 0 6
32102: PPUSH
32103: LD_EXP 66
32107: PUSH
32108: LD_VAR 0 2
32112: ARRAY
32113: PUSH
32114: LD_VAR 0 3
32118: ARRAY
32119: PUSH
32120: LD_INT 2
32122: ARRAY
32123: PPUSH
32124: LD_EXP 66
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PUSH
32135: LD_VAR 0 3
32139: ARRAY
32140: PUSH
32141: LD_INT 3
32143: ARRAY
32144: PPUSH
32145: LD_INT 30
32147: PPUSH
32148: CALL 55331 0 4
32152: PUSH
32153: LD_INT 4
32155: ARRAY
32156: PUSH
32157: LD_INT 0
32159: EQUAL
32160: IFFALSE 32186
// begin target := mc_crates [ i ] [ j ] ;
32162: LD_ADDR_VAR 0 7
32166: PUSH
32167: LD_EXP 66
32171: PUSH
32172: LD_VAR 0 2
32176: ARRAY
32177: PUSH
32178: LD_VAR 0 3
32182: ARRAY
32183: ST_TO_ADDR
// break ;
32184: GO 32188
// end ; end ;
32186: GO 31942
32188: POP
32189: POP
// if not target then
32190: LD_VAR 0 7
32194: NOT
32195: IFFALSE 32199
// continue ;
32197: GO 31749
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32199: LD_ADDR_VAR 0 8
32203: PUSH
32204: LD_EXP 69
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PPUSH
32215: LD_INT 2
32217: PUSH
32218: LD_INT 3
32220: PUSH
32221: LD_INT 58
32223: PUSH
32224: EMPTY
32225: LIST
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 61
32233: PUSH
32234: EMPTY
32235: LIST
32236: PUSH
32237: LD_INT 33
32239: PUSH
32240: LD_INT 5
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 33
32249: PUSH
32250: LD_INT 3
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: LIST
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 2
32266: PUSH
32267: LD_INT 34
32269: PUSH
32270: LD_INT 32
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 34
32279: PUSH
32280: LD_INT 51
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 34
32289: PUSH
32290: LD_INT 12
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PPUSH
32307: CALL_OW 72
32311: ST_TO_ADDR
// if not cargo then
32312: LD_VAR 0 8
32316: NOT
32317: IFFALSE 33023
// begin if mc_crates_collector [ i ] < 5 then
32319: LD_EXP 67
32323: PUSH
32324: LD_VAR 0 2
32328: ARRAY
32329: PUSH
32330: LD_INT 5
32332: LESS
32333: IFFALSE 32699
// begin if mc_ape [ i ] then
32335: LD_EXP 79
32339: PUSH
32340: LD_VAR 0 2
32344: ARRAY
32345: IFFALSE 32392
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_EXP 79
32356: PUSH
32357: LD_VAR 0 2
32361: ARRAY
32362: PPUSH
32363: LD_INT 25
32365: PUSH
32366: LD_INT 16
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 24
32375: PUSH
32376: LD_INT 750
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PPUSH
32387: CALL_OW 72
32391: ST_TO_ADDR
// if not tmp then
32392: LD_VAR 0 5
32396: NOT
32397: IFFALSE 32444
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32399: LD_ADDR_VAR 0 5
32403: PUSH
32404: LD_EXP 50
32408: PUSH
32409: LD_VAR 0 2
32413: ARRAY
32414: PPUSH
32415: LD_INT 25
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 24
32427: PUSH
32428: LD_INT 750
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PPUSH
32439: CALL_OW 72
32443: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32444: LD_EXP 79
32448: PUSH
32449: LD_VAR 0 2
32453: ARRAY
32454: PUSH
32455: LD_EXP 50
32459: PUSH
32460: LD_VAR 0 2
32464: ARRAY
32465: PPUSH
32466: LD_INT 25
32468: PUSH
32469: LD_INT 2
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 24
32478: PUSH
32479: LD_INT 750
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PPUSH
32490: CALL_OW 72
32494: AND
32495: PUSH
32496: LD_VAR 0 5
32500: PUSH
32501: LD_INT 5
32503: LESS
32504: AND
32505: IFFALSE 32587
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32507: LD_ADDR_VAR 0 3
32511: PUSH
32512: LD_EXP 50
32516: PUSH
32517: LD_VAR 0 2
32521: ARRAY
32522: PPUSH
32523: LD_INT 25
32525: PUSH
32526: LD_INT 2
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 24
32535: PUSH
32536: LD_INT 750
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PPUSH
32547: CALL_OW 72
32551: PUSH
32552: FOR_IN
32553: IFFALSE 32585
// begin tmp := tmp union j ;
32555: LD_ADDR_VAR 0 5
32559: PUSH
32560: LD_VAR 0 5
32564: PUSH
32565: LD_VAR 0 3
32569: UNION
32570: ST_TO_ADDR
// if tmp >= 5 then
32571: LD_VAR 0 5
32575: PUSH
32576: LD_INT 5
32578: GREATEREQUAL
32579: IFFALSE 32583
// break ;
32581: GO 32585
// end ;
32583: GO 32552
32585: POP
32586: POP
// end ; if not tmp then
32587: LD_VAR 0 5
32591: NOT
32592: IFFALSE 32596
// continue ;
32594: GO 31749
// for j in tmp do
32596: LD_ADDR_VAR 0 3
32600: PUSH
32601: LD_VAR 0 5
32605: PUSH
32606: FOR_IN
32607: IFFALSE 32697
// if not GetTag ( j ) then
32609: LD_VAR 0 3
32613: PPUSH
32614: CALL_OW 110
32618: NOT
32619: IFFALSE 32695
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32621: LD_ADDR_EXP 67
32625: PUSH
32626: LD_EXP 67
32630: PPUSH
32631: LD_VAR 0 2
32635: PUSH
32636: LD_EXP 67
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: PUSH
32647: LD_INT 1
32649: PLUS
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PPUSH
32655: LD_VAR 0 3
32659: PPUSH
32660: CALL 54067 0 3
32664: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32665: LD_VAR 0 3
32669: PPUSH
32670: LD_INT 107
32672: PPUSH
32673: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32677: LD_EXP 67
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: PUSH
32688: LD_INT 5
32690: GREATEREQUAL
32691: IFFALSE 32695
// break ;
32693: GO 32697
// end ;
32695: GO 32606
32697: POP
32698: POP
// end ; if mc_crates_collector [ i ] and target then
32699: LD_EXP 67
32703: PUSH
32704: LD_VAR 0 2
32708: ARRAY
32709: PUSH
32710: LD_VAR 0 7
32714: AND
32715: IFFALSE 33021
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32717: LD_EXP 67
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: PUSH
32728: LD_VAR 0 7
32732: PUSH
32733: LD_INT 1
32735: ARRAY
32736: LESS
32737: IFFALSE 32757
// tmp := mc_crates_collector [ i ] else
32739: LD_ADDR_VAR 0 5
32743: PUSH
32744: LD_EXP 67
32748: PUSH
32749: LD_VAR 0 2
32753: ARRAY
32754: ST_TO_ADDR
32755: GO 32771
// tmp := target [ 1 ] ;
32757: LD_ADDR_VAR 0 5
32761: PUSH
32762: LD_VAR 0 7
32766: PUSH
32767: LD_INT 1
32769: ARRAY
32770: ST_TO_ADDR
// k := 0 ;
32771: LD_ADDR_VAR 0 4
32775: PUSH
32776: LD_INT 0
32778: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32779: LD_ADDR_VAR 0 3
32783: PUSH
32784: LD_EXP 67
32788: PUSH
32789: LD_VAR 0 2
32793: ARRAY
32794: PUSH
32795: FOR_IN
32796: IFFALSE 33019
// begin k := k + 1 ;
32798: LD_ADDR_VAR 0 4
32802: PUSH
32803: LD_VAR 0 4
32807: PUSH
32808: LD_INT 1
32810: PLUS
32811: ST_TO_ADDR
// if k > tmp then
32812: LD_VAR 0 4
32816: PUSH
32817: LD_VAR 0 5
32821: GREATER
32822: IFFALSE 32826
// break ;
32824: GO 33019
// if not GetClass ( j ) in [ 2 , 16 ] then
32826: LD_VAR 0 3
32830: PPUSH
32831: CALL_OW 257
32835: PUSH
32836: LD_INT 2
32838: PUSH
32839: LD_INT 16
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: IN
32846: NOT
32847: IFFALSE 32900
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32849: LD_ADDR_EXP 67
32853: PUSH
32854: LD_EXP 67
32858: PPUSH
32859: LD_VAR 0 2
32863: PPUSH
32864: LD_EXP 67
32868: PUSH
32869: LD_VAR 0 2
32873: ARRAY
32874: PUSH
32875: LD_VAR 0 3
32879: DIFF
32880: PPUSH
32881: CALL_OW 1
32885: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32886: LD_VAR 0 3
32890: PPUSH
32891: LD_INT 0
32893: PPUSH
32894: CALL_OW 109
// continue ;
32898: GO 32795
// end ; if IsInUnit ( j ) then
32900: LD_VAR 0 3
32904: PPUSH
32905: CALL_OW 310
32909: IFFALSE 32920
// ComExitBuilding ( j ) ;
32911: LD_VAR 0 3
32915: PPUSH
32916: CALL_OW 122
// wait ( 3 ) ;
32920: LD_INT 3
32922: PPUSH
32923: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32927: LD_VAR 0 3
32931: PPUSH
32932: CALL_OW 314
32936: PUSH
32937: LD_VAR 0 6
32941: PPUSH
32942: LD_VAR 0 7
32946: PUSH
32947: LD_INT 2
32949: ARRAY
32950: PPUSH
32951: LD_VAR 0 7
32955: PUSH
32956: LD_INT 3
32958: ARRAY
32959: PPUSH
32960: LD_INT 30
32962: PPUSH
32963: CALL 55331 0 4
32967: PUSH
32968: LD_INT 4
32970: ARRAY
32971: AND
32972: IFFALSE 32990
// ComStandNearbyBuilding ( j , depot ) else
32974: LD_VAR 0 3
32978: PPUSH
32979: LD_VAR 0 9
32983: PPUSH
32984: CALL 50669 0 2
32988: GO 33017
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32990: LD_VAR 0 3
32994: PPUSH
32995: LD_VAR 0 7
32999: PUSH
33000: LD_INT 2
33002: ARRAY
33003: PPUSH
33004: LD_VAR 0 7
33008: PUSH
33009: LD_INT 3
33011: ARRAY
33012: PPUSH
33013: CALL_OW 117
// end ;
33017: GO 32795
33019: POP
33020: POP
// end ; end else
33021: GO 33553
// begin for j in cargo do
33023: LD_ADDR_VAR 0 3
33027: PUSH
33028: LD_VAR 0 8
33032: PUSH
33033: FOR_IN
33034: IFFALSE 33551
// begin if GetTag ( j ) <> 0 then
33036: LD_VAR 0 3
33040: PPUSH
33041: CALL_OW 110
33045: PUSH
33046: LD_INT 0
33048: NONEQUAL
33049: IFFALSE 33053
// continue ;
33051: GO 33033
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33053: LD_VAR 0 3
33057: PPUSH
33058: CALL_OW 256
33062: PUSH
33063: LD_INT 1000
33065: LESS
33066: PUSH
33067: LD_VAR 0 3
33071: PPUSH
33072: LD_EXP 74
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PPUSH
33083: CALL_OW 308
33087: NOT
33088: AND
33089: IFFALSE 33111
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33091: LD_VAR 0 3
33095: PPUSH
33096: LD_EXP 74
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PPUSH
33107: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33111: LD_VAR 0 3
33115: PPUSH
33116: CALL_OW 256
33120: PUSH
33121: LD_INT 1000
33123: LESS
33124: PUSH
33125: LD_VAR 0 3
33129: PPUSH
33130: LD_EXP 74
33134: PUSH
33135: LD_VAR 0 2
33139: ARRAY
33140: PPUSH
33141: CALL_OW 308
33145: AND
33146: IFFALSE 33150
// continue ;
33148: GO 33033
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33150: LD_VAR 0 3
33154: PPUSH
33155: CALL_OW 262
33159: PUSH
33160: LD_INT 2
33162: EQUAL
33163: PUSH
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 261
33173: PUSH
33174: LD_INT 15
33176: LESS
33177: AND
33178: IFFALSE 33182
// continue ;
33180: GO 33033
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33182: LD_VAR 0 3
33186: PPUSH
33187: CALL_OW 262
33191: PUSH
33192: LD_INT 1
33194: EQUAL
33195: PUSH
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 261
33205: PUSH
33206: LD_INT 10
33208: LESS
33209: AND
33210: IFFALSE 33490
// begin if not depot then
33212: LD_VAR 0 9
33216: NOT
33217: IFFALSE 33221
// continue ;
33219: GO 33033
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33221: LD_VAR 0 3
33225: PPUSH
33226: LD_VAR 0 9
33230: PPUSH
33231: LD_VAR 0 3
33235: PPUSH
33236: CALL_OW 74
33240: PPUSH
33241: CALL_OW 296
33245: PUSH
33246: LD_INT 6
33248: LESS
33249: IFFALSE 33265
// SetFuel ( j , 100 ) else
33251: LD_VAR 0 3
33255: PPUSH
33256: LD_INT 100
33258: PPUSH
33259: CALL_OW 240
33263: GO 33490
// if GetFuel ( j ) = 0 then
33265: LD_VAR 0 3
33269: PPUSH
33270: CALL_OW 261
33274: PUSH
33275: LD_INT 0
33277: EQUAL
33278: IFFALSE 33490
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33280: LD_ADDR_EXP 69
33284: PUSH
33285: LD_EXP 69
33289: PPUSH
33290: LD_VAR 0 2
33294: PPUSH
33295: LD_EXP 69
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PUSH
33306: LD_VAR 0 3
33310: DIFF
33311: PPUSH
33312: CALL_OW 1
33316: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33317: LD_VAR 0 3
33321: PPUSH
33322: CALL_OW 263
33326: PUSH
33327: LD_INT 1
33329: EQUAL
33330: IFFALSE 33346
// ComExitVehicle ( IsInUnit ( j ) ) ;
33332: LD_VAR 0 3
33336: PPUSH
33337: CALL_OW 310
33341: PPUSH
33342: CALL_OW 121
// if GetControl ( j ) = control_remote then
33346: LD_VAR 0 3
33350: PPUSH
33351: CALL_OW 263
33355: PUSH
33356: LD_INT 2
33358: EQUAL
33359: IFFALSE 33370
// ComUnlink ( j ) ;
33361: LD_VAR 0 3
33365: PPUSH
33366: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33370: LD_ADDR_VAR 0 10
33374: PUSH
33375: LD_VAR 0 2
33379: PPUSH
33380: LD_INT 3
33382: PPUSH
33383: CALL 43134 0 2
33387: ST_TO_ADDR
// if fac then
33388: LD_VAR 0 10
33392: IFFALSE 33488
// begin for k in fac do
33394: LD_ADDR_VAR 0 4
33398: PUSH
33399: LD_VAR 0 10
33403: PUSH
33404: FOR_IN
33405: IFFALSE 33486
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33407: LD_ADDR_VAR 0 11
33411: PUSH
33412: LD_VAR 0 10
33416: PPUSH
33417: LD_VAR 0 3
33421: PPUSH
33422: CALL_OW 265
33426: PPUSH
33427: LD_VAR 0 3
33431: PPUSH
33432: CALL_OW 262
33436: PPUSH
33437: LD_VAR 0 3
33441: PPUSH
33442: CALL_OW 263
33446: PPUSH
33447: LD_VAR 0 3
33451: PPUSH
33452: CALL_OW 264
33456: PPUSH
33457: CALL 51565 0 5
33461: ST_TO_ADDR
// if components then
33462: LD_VAR 0 11
33466: IFFALSE 33484
// begin MC_InsertProduceList ( i , components ) ;
33468: LD_VAR 0 2
33472: PPUSH
33473: LD_VAR 0 11
33477: PPUSH
33478: CALL 42679 0 2
// break ;
33482: GO 33486
// end ; end ;
33484: GO 33404
33486: POP
33487: POP
// end ; continue ;
33488: GO 33033
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33490: LD_VAR 0 3
33494: PPUSH
33495: LD_INT 1
33497: PPUSH
33498: CALL_OW 289
33502: PUSH
33503: LD_INT 100
33505: LESS
33506: PUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: CALL_OW 314
33516: NOT
33517: AND
33518: IFFALSE 33547
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33520: LD_VAR 0 3
33524: PPUSH
33525: LD_VAR 0 7
33529: PUSH
33530: LD_INT 2
33532: ARRAY
33533: PPUSH
33534: LD_VAR 0 7
33538: PUSH
33539: LD_INT 3
33541: ARRAY
33542: PPUSH
33543: CALL_OW 117
// break ;
33547: GO 33551
// end ;
33549: GO 33033
33551: POP
33552: POP
// end ; end ;
33553: GO 31749
33555: POP
33556: POP
// end ;
33557: LD_VAR 0 1
33561: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33562: LD_INT 0
33564: PPUSH
33565: PPUSH
33566: PPUSH
33567: PPUSH
// if not mc_bases then
33568: LD_EXP 50
33572: NOT
33573: IFFALSE 33577
// exit ;
33575: GO 33738
// for i = 1 to mc_bases do
33577: LD_ADDR_VAR 0 2
33581: PUSH
33582: DOUBLE
33583: LD_INT 1
33585: DEC
33586: ST_TO_ADDR
33587: LD_EXP 50
33591: PUSH
33592: FOR_TO
33593: IFFALSE 33736
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33595: LD_ADDR_VAR 0 4
33599: PUSH
33600: LD_EXP 69
33604: PUSH
33605: LD_VAR 0 2
33609: ARRAY
33610: PUSH
33611: LD_EXP 72
33615: PUSH
33616: LD_VAR 0 2
33620: ARRAY
33621: UNION
33622: PPUSH
33623: LD_INT 33
33625: PUSH
33626: LD_INT 2
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PPUSH
33633: CALL_OW 72
33637: ST_TO_ADDR
// if tmp then
33638: LD_VAR 0 4
33642: IFFALSE 33734
// for j in tmp do
33644: LD_ADDR_VAR 0 3
33648: PUSH
33649: LD_VAR 0 4
33653: PUSH
33654: FOR_IN
33655: IFFALSE 33732
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33657: LD_VAR 0 3
33661: PPUSH
33662: CALL_OW 312
33666: NOT
33667: PUSH
33668: LD_VAR 0 3
33672: PPUSH
33673: CALL_OW 256
33677: PUSH
33678: LD_INT 250
33680: GREATEREQUAL
33681: AND
33682: IFFALSE 33695
// Connect ( j ) else
33684: LD_VAR 0 3
33688: PPUSH
33689: CALL 57413 0 1
33693: GO 33730
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33695: LD_VAR 0 3
33699: PPUSH
33700: CALL_OW 256
33704: PUSH
33705: LD_INT 250
33707: LESS
33708: PUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: CALL_OW 312
33718: AND
33719: IFFALSE 33730
// ComUnlink ( j ) ;
33721: LD_VAR 0 3
33725: PPUSH
33726: CALL_OW 136
33730: GO 33654
33732: POP
33733: POP
// end ;
33734: GO 33592
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 1
33742: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
33749: PPUSH
// if not mc_bases then
33750: LD_EXP 50
33754: NOT
33755: IFFALSE 33759
// exit ;
33757: GO 34204
// for i = 1 to mc_bases do
33759: LD_ADDR_VAR 0 2
33763: PUSH
33764: DOUBLE
33765: LD_INT 1
33767: DEC
33768: ST_TO_ADDR
33769: LD_EXP 50
33773: PUSH
33774: FOR_TO
33775: IFFALSE 34202
// begin if not mc_produce [ i ] then
33777: LD_EXP 71
33781: PUSH
33782: LD_VAR 0 2
33786: ARRAY
33787: NOT
33788: IFFALSE 33792
// continue ;
33790: GO 33774
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33792: LD_ADDR_VAR 0 5
33796: PUSH
33797: LD_EXP 50
33801: PUSH
33802: LD_VAR 0 2
33806: ARRAY
33807: PPUSH
33808: LD_INT 30
33810: PUSH
33811: LD_INT 3
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PPUSH
33818: CALL_OW 72
33822: ST_TO_ADDR
// if not fac then
33823: LD_VAR 0 5
33827: NOT
33828: IFFALSE 33832
// continue ;
33830: GO 33774
// for j in fac do
33832: LD_ADDR_VAR 0 3
33836: PUSH
33837: LD_VAR 0 5
33841: PUSH
33842: FOR_IN
33843: IFFALSE 34198
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33845: LD_VAR 0 3
33849: PPUSH
33850: CALL_OW 461
33854: PUSH
33855: LD_INT 2
33857: NONEQUAL
33858: PUSH
33859: LD_VAR 0 3
33863: PPUSH
33864: LD_INT 15
33866: PPUSH
33867: CALL 57032 0 2
33871: PUSH
33872: LD_INT 4
33874: ARRAY
33875: OR
33876: IFFALSE 33880
// continue ;
33878: GO 33842
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33880: LD_VAR 0 3
33884: PPUSH
33885: LD_EXP 71
33889: PUSH
33890: LD_VAR 0 2
33894: ARRAY
33895: PUSH
33896: LD_INT 1
33898: ARRAY
33899: PUSH
33900: LD_INT 1
33902: ARRAY
33903: PPUSH
33904: LD_EXP 71
33908: PUSH
33909: LD_VAR 0 2
33913: ARRAY
33914: PUSH
33915: LD_INT 1
33917: ARRAY
33918: PUSH
33919: LD_INT 2
33921: ARRAY
33922: PPUSH
33923: LD_EXP 71
33927: PUSH
33928: LD_VAR 0 2
33932: ARRAY
33933: PUSH
33934: LD_INT 1
33936: ARRAY
33937: PUSH
33938: LD_INT 3
33940: ARRAY
33941: PPUSH
33942: LD_EXP 71
33946: PUSH
33947: LD_VAR 0 2
33951: ARRAY
33952: PUSH
33953: LD_INT 1
33955: ARRAY
33956: PUSH
33957: LD_INT 4
33959: ARRAY
33960: PPUSH
33961: CALL_OW 448
33965: PUSH
33966: LD_VAR 0 3
33970: PPUSH
33971: LD_EXP 71
33975: PUSH
33976: LD_VAR 0 2
33980: ARRAY
33981: PUSH
33982: LD_INT 1
33984: ARRAY
33985: PUSH
33986: LD_INT 1
33988: ARRAY
33989: PUSH
33990: LD_EXP 71
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PUSH
34001: LD_INT 1
34003: ARRAY
34004: PUSH
34005: LD_INT 2
34007: ARRAY
34008: PUSH
34009: LD_EXP 71
34013: PUSH
34014: LD_VAR 0 2
34018: ARRAY
34019: PUSH
34020: LD_INT 1
34022: ARRAY
34023: PUSH
34024: LD_INT 3
34026: ARRAY
34027: PUSH
34028: LD_EXP 71
34032: PUSH
34033: LD_VAR 0 2
34037: ARRAY
34038: PUSH
34039: LD_INT 1
34041: ARRAY
34042: PUSH
34043: LD_INT 4
34045: ARRAY
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: PPUSH
34053: CALL 60808 0 2
34057: AND
34058: IFFALSE 34196
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34060: LD_VAR 0 3
34064: PPUSH
34065: LD_EXP 71
34069: PUSH
34070: LD_VAR 0 2
34074: ARRAY
34075: PUSH
34076: LD_INT 1
34078: ARRAY
34079: PUSH
34080: LD_INT 1
34082: ARRAY
34083: PPUSH
34084: LD_EXP 71
34088: PUSH
34089: LD_VAR 0 2
34093: ARRAY
34094: PUSH
34095: LD_INT 1
34097: ARRAY
34098: PUSH
34099: LD_INT 2
34101: ARRAY
34102: PPUSH
34103: LD_EXP 71
34107: PUSH
34108: LD_VAR 0 2
34112: ARRAY
34113: PUSH
34114: LD_INT 1
34116: ARRAY
34117: PUSH
34118: LD_INT 3
34120: ARRAY
34121: PPUSH
34122: LD_EXP 71
34126: PUSH
34127: LD_VAR 0 2
34131: ARRAY
34132: PUSH
34133: LD_INT 1
34135: ARRAY
34136: PUSH
34137: LD_INT 4
34139: ARRAY
34140: PPUSH
34141: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34145: LD_ADDR_VAR 0 4
34149: PUSH
34150: LD_EXP 71
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PPUSH
34161: LD_INT 1
34163: PPUSH
34164: CALL_OW 3
34168: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34169: LD_ADDR_EXP 71
34173: PUSH
34174: LD_EXP 71
34178: PPUSH
34179: LD_VAR 0 2
34183: PPUSH
34184: LD_VAR 0 4
34188: PPUSH
34189: CALL_OW 1
34193: ST_TO_ADDR
// break ;
34194: GO 34198
// end ; end ;
34196: GO 33842
34198: POP
34199: POP
// end ;
34200: GO 33774
34202: POP
34203: POP
// end ;
34204: LD_VAR 0 1
34208: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34209: LD_INT 0
34211: PPUSH
34212: PPUSH
34213: PPUSH
// if not mc_bases then
34214: LD_EXP 50
34218: NOT
34219: IFFALSE 34223
// exit ;
34221: GO 34312
// for i = 1 to mc_bases do
34223: LD_ADDR_VAR 0 2
34227: PUSH
34228: DOUBLE
34229: LD_INT 1
34231: DEC
34232: ST_TO_ADDR
34233: LD_EXP 50
34237: PUSH
34238: FOR_TO
34239: IFFALSE 34310
// begin if mc_attack [ i ] then
34241: LD_EXP 70
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: IFFALSE 34308
// begin tmp := mc_attack [ i ] [ 1 ] ;
34253: LD_ADDR_VAR 0 3
34257: PUSH
34258: LD_EXP 70
34262: PUSH
34263: LD_VAR 0 2
34267: ARRAY
34268: PUSH
34269: LD_INT 1
34271: ARRAY
34272: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34273: LD_ADDR_EXP 70
34277: PUSH
34278: LD_EXP 70
34282: PPUSH
34283: LD_VAR 0 2
34287: PPUSH
34288: EMPTY
34289: PPUSH
34290: CALL_OW 1
34294: ST_TO_ADDR
// Attack ( tmp ) ;
34295: LD_VAR 0 3
34299: PPUSH
34300: CALL 111800 0 1
// exit ;
34304: POP
34305: POP
34306: GO 34312
// end ; end ;
34308: GO 34238
34310: POP
34311: POP
// end ;
34312: LD_VAR 0 1
34316: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34317: LD_INT 0
34319: PPUSH
34320: PPUSH
34321: PPUSH
34322: PPUSH
34323: PPUSH
34324: PPUSH
34325: PPUSH
// if not mc_bases then
34326: LD_EXP 50
34330: NOT
34331: IFFALSE 34335
// exit ;
34333: GO 35192
// for i = 1 to mc_bases do
34335: LD_ADDR_VAR 0 2
34339: PUSH
34340: DOUBLE
34341: LD_INT 1
34343: DEC
34344: ST_TO_ADDR
34345: LD_EXP 50
34349: PUSH
34350: FOR_TO
34351: IFFALSE 35190
// begin if not mc_bases [ i ] then
34353: LD_EXP 50
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: NOT
34364: IFFALSE 34368
// continue ;
34366: GO 34350
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34368: LD_ADDR_VAR 0 7
34372: PUSH
34373: LD_EXP 50
34377: PUSH
34378: LD_VAR 0 2
34382: ARRAY
34383: PUSH
34384: LD_INT 1
34386: ARRAY
34387: PPUSH
34388: CALL 50891 0 1
34392: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34393: LD_ADDR_EXP 73
34397: PUSH
34398: LD_EXP 73
34402: PPUSH
34403: LD_VAR 0 2
34407: PPUSH
34408: LD_EXP 50
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PUSH
34419: LD_INT 1
34421: ARRAY
34422: PPUSH
34423: CALL_OW 255
34427: PPUSH
34428: LD_EXP 75
34432: PUSH
34433: LD_VAR 0 2
34437: ARRAY
34438: PPUSH
34439: CALL 50856 0 2
34443: PPUSH
34444: CALL_OW 1
34448: ST_TO_ADDR
// if not mc_scan [ i ] then
34449: LD_EXP 73
34453: PUSH
34454: LD_VAR 0 2
34458: ARRAY
34459: NOT
34460: IFFALSE 34638
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34462: LD_ADDR_EXP 93
34466: PUSH
34467: LD_EXP 93
34471: PPUSH
34472: LD_VAR 0 2
34476: PPUSH
34477: LD_INT 0
34479: PPUSH
34480: CALL_OW 1
34484: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34485: LD_ADDR_VAR 0 4
34489: PUSH
34490: LD_EXP 50
34494: PUSH
34495: LD_VAR 0 2
34499: ARRAY
34500: PPUSH
34501: LD_INT 2
34503: PUSH
34504: LD_INT 25
34506: PUSH
34507: LD_INT 5
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 25
34516: PUSH
34517: LD_INT 8
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 25
34526: PUSH
34527: LD_INT 9
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: PPUSH
34540: CALL_OW 72
34544: ST_TO_ADDR
// if not tmp then
34545: LD_VAR 0 4
34549: NOT
34550: IFFALSE 34554
// continue ;
34552: GO 34350
// for j in tmp do
34554: LD_ADDR_VAR 0 3
34558: PUSH
34559: LD_VAR 0 4
34563: PUSH
34564: FOR_IN
34565: IFFALSE 34636
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34567: LD_VAR 0 3
34571: PPUSH
34572: CALL_OW 310
34576: PPUSH
34577: CALL_OW 266
34581: PUSH
34582: LD_INT 5
34584: EQUAL
34585: PUSH
34586: LD_VAR 0 3
34590: PPUSH
34591: CALL_OW 257
34595: PUSH
34596: LD_INT 1
34598: EQUAL
34599: AND
34600: PUSH
34601: LD_VAR 0 3
34605: PPUSH
34606: CALL_OW 459
34610: NOT
34611: AND
34612: PUSH
34613: LD_VAR 0 7
34617: AND
34618: IFFALSE 34634
// ComChangeProfession ( j , class ) ;
34620: LD_VAR 0 3
34624: PPUSH
34625: LD_VAR 0 7
34629: PPUSH
34630: CALL_OW 123
34634: GO 34564
34636: POP
34637: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34638: LD_EXP 73
34642: PUSH
34643: LD_VAR 0 2
34647: ARRAY
34648: PUSH
34649: LD_EXP 93
34653: PUSH
34654: LD_VAR 0 2
34658: ARRAY
34659: NOT
34660: AND
34661: PUSH
34662: LD_EXP 72
34666: PUSH
34667: LD_VAR 0 2
34671: ARRAY
34672: NOT
34673: AND
34674: PUSH
34675: LD_EXP 50
34679: PUSH
34680: LD_VAR 0 2
34684: ARRAY
34685: PPUSH
34686: LD_INT 50
34688: PUSH
34689: EMPTY
34690: LIST
34691: PUSH
34692: LD_INT 2
34694: PUSH
34695: LD_INT 30
34697: PUSH
34698: LD_INT 32
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 30
34707: PUSH
34708: LD_INT 33
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 30
34717: PUSH
34718: LD_INT 4
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 30
34727: PUSH
34728: LD_INT 5
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PPUSH
34746: CALL_OW 72
34750: PUSH
34751: LD_INT 4
34753: LESS
34754: PUSH
34755: LD_EXP 50
34759: PUSH
34760: LD_VAR 0 2
34764: ARRAY
34765: PPUSH
34766: LD_INT 3
34768: PUSH
34769: LD_INT 24
34771: PUSH
34772: LD_INT 1000
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 2
34785: PUSH
34786: LD_INT 30
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 30
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PPUSH
34815: CALL_OW 72
34819: OR
34820: AND
34821: IFFALSE 35072
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34823: LD_ADDR_EXP 93
34827: PUSH
34828: LD_EXP 93
34832: PPUSH
34833: LD_VAR 0 2
34837: PPUSH
34838: LD_INT 1
34840: PPUSH
34841: CALL_OW 1
34845: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34846: LD_ADDR_VAR 0 4
34850: PUSH
34851: LD_EXP 50
34855: PUSH
34856: LD_VAR 0 2
34860: ARRAY
34861: PPUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 25
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 25
34877: PUSH
34878: LD_INT 5
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 25
34887: PUSH
34888: LD_INT 8
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 25
34897: PUSH
34898: LD_INT 9
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: PPUSH
34912: CALL_OW 72
34916: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34917: LD_ADDR_VAR 0 4
34921: PUSH
34922: LD_VAR 0 4
34926: PUSH
34927: LD_VAR 0 4
34931: PPUSH
34932: LD_INT 18
34934: PPUSH
34935: CALL 84376 0 2
34939: DIFF
34940: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34941: LD_VAR 0 4
34945: NOT
34946: PUSH
34947: LD_EXP 50
34951: PUSH
34952: LD_VAR 0 2
34956: ARRAY
34957: PPUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 30
34963: PUSH
34964: LD_INT 4
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 30
34973: PUSH
34974: LD_INT 5
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: LIST
34985: PPUSH
34986: CALL_OW 72
34990: NOT
34991: AND
34992: IFFALSE 35054
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34994: LD_ADDR_VAR 0 4
34998: PUSH
34999: LD_EXP 50
35003: PUSH
35004: LD_VAR 0 2
35008: ARRAY
35009: PPUSH
35010: LD_INT 2
35012: PUSH
35013: LD_INT 25
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 25
35025: PUSH
35026: LD_INT 3
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 25
35035: PUSH
35036: LD_INT 4
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: PPUSH
35049: CALL_OW 72
35053: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35054: LD_VAR 0 2
35058: PPUSH
35059: LD_VAR 0 4
35063: PPUSH
35064: CALL 116509 0 2
// exit ;
35068: POP
35069: POP
35070: GO 35192
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35072: LD_EXP 73
35076: PUSH
35077: LD_VAR 0 2
35081: ARRAY
35082: PUSH
35083: LD_EXP 93
35087: PUSH
35088: LD_VAR 0 2
35092: ARRAY
35093: NOT
35094: AND
35095: PUSH
35096: LD_EXP 72
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: AND
35107: IFFALSE 35188
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35109: LD_ADDR_EXP 93
35113: PUSH
35114: LD_EXP 93
35118: PPUSH
35119: LD_VAR 0 2
35123: PPUSH
35124: LD_INT 1
35126: PPUSH
35127: CALL_OW 1
35131: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35132: LD_ADDR_VAR 0 4
35136: PUSH
35137: LD_EXP 72
35141: PUSH
35142: LD_VAR 0 2
35146: ARRAY
35147: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35148: LD_ADDR_EXP 72
35152: PUSH
35153: LD_EXP 72
35157: PPUSH
35158: LD_VAR 0 2
35162: PPUSH
35163: EMPTY
35164: PPUSH
35165: CALL_OW 1
35169: ST_TO_ADDR
// Defend ( i , tmp ) ;
35170: LD_VAR 0 2
35174: PPUSH
35175: LD_VAR 0 4
35179: PPUSH
35180: CALL 117105 0 2
// exit ;
35184: POP
35185: POP
35186: GO 35192
// end ; end ;
35188: GO 34350
35190: POP
35191: POP
// end ;
35192: LD_VAR 0 1
35196: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35197: LD_INT 0
35199: PPUSH
35200: PPUSH
35201: PPUSH
35202: PPUSH
35203: PPUSH
35204: PPUSH
35205: PPUSH
35206: PPUSH
35207: PPUSH
35208: PPUSH
35209: PPUSH
// if not mc_bases then
35210: LD_EXP 50
35214: NOT
35215: IFFALSE 35219
// exit ;
35217: GO 36306
// for i = 1 to mc_bases do
35219: LD_ADDR_VAR 0 2
35223: PUSH
35224: DOUBLE
35225: LD_INT 1
35227: DEC
35228: ST_TO_ADDR
35229: LD_EXP 50
35233: PUSH
35234: FOR_TO
35235: IFFALSE 36304
// begin tmp := mc_lab [ i ] ;
35237: LD_ADDR_VAR 0 6
35241: PUSH
35242: LD_EXP 83
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: ST_TO_ADDR
// if not tmp then
35253: LD_VAR 0 6
35257: NOT
35258: IFFALSE 35262
// continue ;
35260: GO 35234
// idle_lab := 0 ;
35262: LD_ADDR_VAR 0 11
35266: PUSH
35267: LD_INT 0
35269: ST_TO_ADDR
// for j in tmp do
35270: LD_ADDR_VAR 0 3
35274: PUSH
35275: LD_VAR 0 6
35279: PUSH
35280: FOR_IN
35281: IFFALSE 36300
// begin researching := false ;
35283: LD_ADDR_VAR 0 10
35287: PUSH
35288: LD_INT 0
35290: ST_TO_ADDR
// side := GetSide ( j ) ;
35291: LD_ADDR_VAR 0 4
35295: PUSH
35296: LD_VAR 0 3
35300: PPUSH
35301: CALL_OW 255
35305: ST_TO_ADDR
// if not mc_tech [ side ] then
35306: LD_EXP 77
35310: PUSH
35311: LD_VAR 0 4
35315: ARRAY
35316: NOT
35317: IFFALSE 35321
// continue ;
35319: GO 35280
// if BuildingStatus ( j ) = bs_idle then
35321: LD_VAR 0 3
35325: PPUSH
35326: CALL_OW 461
35330: PUSH
35331: LD_INT 2
35333: EQUAL
35334: IFFALSE 35522
// begin if idle_lab and UnitsInside ( j ) < 6 then
35336: LD_VAR 0 11
35340: PUSH
35341: LD_VAR 0 3
35345: PPUSH
35346: CALL_OW 313
35350: PUSH
35351: LD_INT 6
35353: LESS
35354: AND
35355: IFFALSE 35426
// begin tmp2 := UnitsInside ( idle_lab ) ;
35357: LD_ADDR_VAR 0 9
35361: PUSH
35362: LD_VAR 0 11
35366: PPUSH
35367: CALL_OW 313
35371: ST_TO_ADDR
// if tmp2 then
35372: LD_VAR 0 9
35376: IFFALSE 35418
// for x in tmp2 do
35378: LD_ADDR_VAR 0 7
35382: PUSH
35383: LD_VAR 0 9
35387: PUSH
35388: FOR_IN
35389: IFFALSE 35416
// begin ComExitBuilding ( x ) ;
35391: LD_VAR 0 7
35395: PPUSH
35396: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35400: LD_VAR 0 7
35404: PPUSH
35405: LD_VAR 0 3
35409: PPUSH
35410: CALL_OW 180
// end ;
35414: GO 35388
35416: POP
35417: POP
// idle_lab := 0 ;
35418: LD_ADDR_VAR 0 11
35422: PUSH
35423: LD_INT 0
35425: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35426: LD_ADDR_VAR 0 5
35430: PUSH
35431: LD_EXP 77
35435: PUSH
35436: LD_VAR 0 4
35440: ARRAY
35441: PUSH
35442: FOR_IN
35443: IFFALSE 35503
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35445: LD_VAR 0 3
35449: PPUSH
35450: LD_VAR 0 5
35454: PPUSH
35455: CALL_OW 430
35459: PUSH
35460: LD_VAR 0 4
35464: PPUSH
35465: LD_VAR 0 5
35469: PPUSH
35470: CALL 49961 0 2
35474: AND
35475: IFFALSE 35501
// begin researching := true ;
35477: LD_ADDR_VAR 0 10
35481: PUSH
35482: LD_INT 1
35484: ST_TO_ADDR
// ComResearch ( j , t ) ;
35485: LD_VAR 0 3
35489: PPUSH
35490: LD_VAR 0 5
35494: PPUSH
35495: CALL_OW 124
// break ;
35499: GO 35503
// end ;
35501: GO 35442
35503: POP
35504: POP
// if not researching then
35505: LD_VAR 0 10
35509: NOT
35510: IFFALSE 35522
// idle_lab := j ;
35512: LD_ADDR_VAR 0 11
35516: PUSH
35517: LD_VAR 0 3
35521: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35522: LD_VAR 0 3
35526: PPUSH
35527: CALL_OW 461
35531: PUSH
35532: LD_INT 10
35534: EQUAL
35535: IFFALSE 36123
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35537: LD_EXP 79
35541: PUSH
35542: LD_VAR 0 2
35546: ARRAY
35547: NOT
35548: PUSH
35549: LD_EXP 80
35553: PUSH
35554: LD_VAR 0 2
35558: ARRAY
35559: NOT
35560: AND
35561: PUSH
35562: LD_EXP 77
35566: PUSH
35567: LD_VAR 0 4
35571: ARRAY
35572: PUSH
35573: LD_INT 1
35575: GREATER
35576: AND
35577: IFFALSE 35708
// begin ComCancel ( j ) ;
35579: LD_VAR 0 3
35583: PPUSH
35584: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35588: LD_ADDR_EXP 77
35592: PUSH
35593: LD_EXP 77
35597: PPUSH
35598: LD_VAR 0 4
35602: PPUSH
35603: LD_EXP 77
35607: PUSH
35608: LD_VAR 0 4
35612: ARRAY
35613: PPUSH
35614: LD_EXP 77
35618: PUSH
35619: LD_VAR 0 4
35623: ARRAY
35624: PUSH
35625: LD_INT 1
35627: MINUS
35628: PPUSH
35629: LD_EXP 77
35633: PUSH
35634: LD_VAR 0 4
35638: ARRAY
35639: PPUSH
35640: LD_INT 0
35642: PPUSH
35643: CALL 53485 0 4
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35653: LD_ADDR_EXP 77
35657: PUSH
35658: LD_EXP 77
35662: PPUSH
35663: LD_VAR 0 4
35667: PPUSH
35668: LD_EXP 77
35672: PUSH
35673: LD_VAR 0 4
35677: ARRAY
35678: PPUSH
35679: LD_EXP 77
35683: PUSH
35684: LD_VAR 0 4
35688: ARRAY
35689: PPUSH
35690: LD_INT 1
35692: PPUSH
35693: LD_INT 0
35695: PPUSH
35696: CALL 53485 0 4
35700: PPUSH
35701: CALL_OW 1
35705: ST_TO_ADDR
// continue ;
35706: GO 35280
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35708: LD_EXP 79
35712: PUSH
35713: LD_VAR 0 2
35717: ARRAY
35718: PUSH
35719: LD_EXP 80
35723: PUSH
35724: LD_VAR 0 2
35728: ARRAY
35729: NOT
35730: AND
35731: IFFALSE 35858
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35733: LD_ADDR_EXP 80
35737: PUSH
35738: LD_EXP 80
35742: PPUSH
35743: LD_VAR 0 2
35747: PUSH
35748: LD_EXP 80
35752: PUSH
35753: LD_VAR 0 2
35757: ARRAY
35758: PUSH
35759: LD_INT 1
35761: PLUS
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PPUSH
35767: LD_EXP 79
35771: PUSH
35772: LD_VAR 0 2
35776: ARRAY
35777: PUSH
35778: LD_INT 1
35780: ARRAY
35781: PPUSH
35782: CALL 54067 0 3
35786: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35787: LD_EXP 79
35791: PUSH
35792: LD_VAR 0 2
35796: ARRAY
35797: PUSH
35798: LD_INT 1
35800: ARRAY
35801: PPUSH
35802: LD_INT 112
35804: PPUSH
35805: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35809: LD_ADDR_VAR 0 9
35813: PUSH
35814: LD_EXP 79
35818: PUSH
35819: LD_VAR 0 2
35823: ARRAY
35824: PPUSH
35825: LD_INT 1
35827: PPUSH
35828: CALL_OW 3
35832: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35833: LD_ADDR_EXP 79
35837: PUSH
35838: LD_EXP 79
35842: PPUSH
35843: LD_VAR 0 2
35847: PPUSH
35848: LD_VAR 0 9
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35858: LD_EXP 79
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PUSH
35869: LD_EXP 80
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: AND
35880: PUSH
35881: LD_EXP 80
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_INT 1
35894: ARRAY
35895: PPUSH
35896: CALL_OW 310
35900: NOT
35901: AND
35902: PUSH
35903: LD_VAR 0 3
35907: PPUSH
35908: CALL_OW 313
35912: PUSH
35913: LD_INT 6
35915: EQUAL
35916: AND
35917: IFFALSE 35973
// begin tmp2 := UnitsInside ( j ) ;
35919: LD_ADDR_VAR 0 9
35923: PUSH
35924: LD_VAR 0 3
35928: PPUSH
35929: CALL_OW 313
35933: ST_TO_ADDR
// if tmp2 = 6 then
35934: LD_VAR 0 9
35938: PUSH
35939: LD_INT 6
35941: EQUAL
35942: IFFALSE 35973
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35944: LD_VAR 0 9
35948: PUSH
35949: LD_INT 1
35951: ARRAY
35952: PPUSH
35953: LD_INT 112
35955: PPUSH
35956: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35960: LD_VAR 0 9
35964: PUSH
35965: LD_INT 1
35967: ARRAY
35968: PPUSH
35969: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35973: LD_EXP 80
35977: PUSH
35978: LD_VAR 0 2
35982: ARRAY
35983: PUSH
35984: LD_EXP 80
35988: PUSH
35989: LD_VAR 0 2
35993: ARRAY
35994: PUSH
35995: LD_INT 1
35997: ARRAY
35998: PPUSH
35999: CALL_OW 314
36003: NOT
36004: AND
36005: PUSH
36006: LD_EXP 80
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PUSH
36017: LD_INT 1
36019: ARRAY
36020: PPUSH
36021: CALL_OW 310
36025: NOT
36026: AND
36027: IFFALSE 36053
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36029: LD_EXP 80
36033: PUSH
36034: LD_VAR 0 2
36038: ARRAY
36039: PUSH
36040: LD_INT 1
36042: ARRAY
36043: PPUSH
36044: LD_VAR 0 3
36048: PPUSH
36049: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36053: LD_EXP 80
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_INT 1
36066: ARRAY
36067: PPUSH
36068: CALL_OW 310
36072: PUSH
36073: LD_EXP 80
36077: PUSH
36078: LD_VAR 0 2
36082: ARRAY
36083: PUSH
36084: LD_INT 1
36086: ARRAY
36087: PPUSH
36088: CALL_OW 310
36092: PPUSH
36093: CALL_OW 461
36097: PUSH
36098: LD_INT 3
36100: NONEQUAL
36101: AND
36102: IFFALSE 36123
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36104: LD_EXP 80
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PUSH
36115: LD_INT 1
36117: ARRAY
36118: PPUSH
36119: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36123: LD_VAR 0 3
36127: PPUSH
36128: CALL_OW 461
36132: PUSH
36133: LD_INT 6
36135: EQUAL
36136: PUSH
36137: LD_VAR 0 6
36141: PUSH
36142: LD_INT 1
36144: GREATER
36145: AND
36146: IFFALSE 36298
// begin sci := [ ] ;
36148: LD_ADDR_VAR 0 8
36152: PUSH
36153: EMPTY
36154: ST_TO_ADDR
// for x in ( tmp diff j ) do
36155: LD_ADDR_VAR 0 7
36159: PUSH
36160: LD_VAR 0 6
36164: PUSH
36165: LD_VAR 0 3
36169: DIFF
36170: PUSH
36171: FOR_IN
36172: IFFALSE 36224
// begin if sci = 6 then
36174: LD_VAR 0 8
36178: PUSH
36179: LD_INT 6
36181: EQUAL
36182: IFFALSE 36186
// break ;
36184: GO 36224
// if BuildingStatus ( x ) = bs_idle then
36186: LD_VAR 0 7
36190: PPUSH
36191: CALL_OW 461
36195: PUSH
36196: LD_INT 2
36198: EQUAL
36199: IFFALSE 36222
// sci := sci ^ UnitsInside ( x ) ;
36201: LD_ADDR_VAR 0 8
36205: PUSH
36206: LD_VAR 0 8
36210: PUSH
36211: LD_VAR 0 7
36215: PPUSH
36216: CALL_OW 313
36220: ADD
36221: ST_TO_ADDR
// end ;
36222: GO 36171
36224: POP
36225: POP
// if not sci then
36226: LD_VAR 0 8
36230: NOT
36231: IFFALSE 36235
// continue ;
36233: GO 35280
// for x in sci do
36235: LD_ADDR_VAR 0 7
36239: PUSH
36240: LD_VAR 0 8
36244: PUSH
36245: FOR_IN
36246: IFFALSE 36296
// if IsInUnit ( x ) and not HasTask ( x ) then
36248: LD_VAR 0 7
36252: PPUSH
36253: CALL_OW 310
36257: PUSH
36258: LD_VAR 0 7
36262: PPUSH
36263: CALL_OW 314
36267: NOT
36268: AND
36269: IFFALSE 36294
// begin ComExitBuilding ( x ) ;
36271: LD_VAR 0 7
36275: PPUSH
36276: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36280: LD_VAR 0 7
36284: PPUSH
36285: LD_VAR 0 3
36289: PPUSH
36290: CALL_OW 180
// end ;
36294: GO 36245
36296: POP
36297: POP
// end ; end ;
36298: GO 35280
36300: POP
36301: POP
// end ;
36302: GO 35234
36304: POP
36305: POP
// end ;
36306: LD_VAR 0 1
36310: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36311: LD_INT 0
36313: PPUSH
36314: PPUSH
// if not mc_bases then
36315: LD_EXP 50
36319: NOT
36320: IFFALSE 36324
// exit ;
36322: GO 36405
// for i = 1 to mc_bases do
36324: LD_ADDR_VAR 0 2
36328: PUSH
36329: DOUBLE
36330: LD_INT 1
36332: DEC
36333: ST_TO_ADDR
36334: LD_EXP 50
36338: PUSH
36339: FOR_TO
36340: IFFALSE 36403
// if mc_mines [ i ] and mc_miners [ i ] then
36342: LD_EXP 63
36346: PUSH
36347: LD_VAR 0 2
36351: ARRAY
36352: PUSH
36353: LD_EXP 64
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: AND
36364: IFFALSE 36401
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36366: LD_EXP 64
36370: PUSH
36371: LD_VAR 0 2
36375: ARRAY
36376: PUSH
36377: LD_INT 1
36379: ARRAY
36380: PPUSH
36381: CALL_OW 255
36385: PPUSH
36386: LD_EXP 63
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PPUSH
36397: CALL 51044 0 2
36401: GO 36339
36403: POP
36404: POP
// end ;
36405: LD_VAR 0 1
36409: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36410: LD_INT 0
36412: PPUSH
36413: PPUSH
36414: PPUSH
36415: PPUSH
36416: PPUSH
36417: PPUSH
36418: PPUSH
36419: PPUSH
// if not mc_bases or not mc_parking then
36420: LD_EXP 50
36424: NOT
36425: PUSH
36426: LD_EXP 74
36430: NOT
36431: OR
36432: IFFALSE 36436
// exit ;
36434: GO 37174
// for i = 1 to mc_bases do
36436: LD_ADDR_VAR 0 2
36440: PUSH
36441: DOUBLE
36442: LD_INT 1
36444: DEC
36445: ST_TO_ADDR
36446: LD_EXP 50
36450: PUSH
36451: FOR_TO
36452: IFFALSE 37172
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36454: LD_EXP 50
36458: PUSH
36459: LD_VAR 0 2
36463: ARRAY
36464: NOT
36465: PUSH
36466: LD_EXP 74
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: NOT
36477: OR
36478: IFFALSE 36482
// continue ;
36480: GO 36451
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36482: LD_ADDR_VAR 0 5
36486: PUSH
36487: LD_EXP 50
36491: PUSH
36492: LD_VAR 0 2
36496: ARRAY
36497: PUSH
36498: LD_INT 1
36500: ARRAY
36501: PPUSH
36502: CALL_OW 255
36506: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36507: LD_ADDR_VAR 0 6
36511: PUSH
36512: LD_EXP 50
36516: PUSH
36517: LD_VAR 0 2
36521: ARRAY
36522: PPUSH
36523: LD_INT 30
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PPUSH
36533: CALL_OW 72
36537: ST_TO_ADDR
// if not fac then
36538: LD_VAR 0 6
36542: NOT
36543: IFFALSE 36594
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36545: LD_ADDR_VAR 0 6
36549: PUSH
36550: LD_EXP 50
36554: PUSH
36555: LD_VAR 0 2
36559: ARRAY
36560: PPUSH
36561: LD_INT 2
36563: PUSH
36564: LD_INT 30
36566: PUSH
36567: LD_INT 0
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 30
36576: PUSH
36577: LD_INT 1
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: PPUSH
36589: CALL_OW 72
36593: ST_TO_ADDR
// if not fac then
36594: LD_VAR 0 6
36598: NOT
36599: IFFALSE 36603
// continue ;
36601: GO 36451
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36603: LD_ADDR_VAR 0 7
36607: PUSH
36608: LD_EXP 74
36612: PUSH
36613: LD_VAR 0 2
36617: ARRAY
36618: PPUSH
36619: LD_INT 22
36621: PUSH
36622: LD_VAR 0 5
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 21
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 3
36643: PUSH
36644: LD_INT 60
36646: PUSH
36647: EMPTY
36648: LIST
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 3
36656: PUSH
36657: LD_INT 24
36659: PUSH
36660: LD_INT 1000
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: PPUSH
36677: CALL_OW 70
36681: ST_TO_ADDR
// for j in fac do
36682: LD_ADDR_VAR 0 3
36686: PUSH
36687: LD_VAR 0 6
36691: PUSH
36692: FOR_IN
36693: IFFALSE 36788
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36695: LD_ADDR_VAR 0 7
36699: PUSH
36700: LD_VAR 0 7
36704: PUSH
36705: LD_INT 22
36707: PUSH
36708: LD_VAR 0 5
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 91
36719: PUSH
36720: LD_VAR 0 3
36724: PUSH
36725: LD_INT 15
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 21
36735: PUSH
36736: LD_INT 2
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 60
36748: PUSH
36749: EMPTY
36750: LIST
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 3
36758: PUSH
36759: LD_INT 24
36761: PUSH
36762: LD_INT 1000
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: PPUSH
36780: CALL_OW 69
36784: UNION
36785: ST_TO_ADDR
36786: GO 36692
36788: POP
36789: POP
// if not vehs then
36790: LD_VAR 0 7
36794: NOT
36795: IFFALSE 36821
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36797: LD_ADDR_EXP 62
36801: PUSH
36802: LD_EXP 62
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// continue ;
36819: GO 36451
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36821: LD_ADDR_VAR 0 8
36825: PUSH
36826: LD_EXP 50
36830: PUSH
36831: LD_VAR 0 2
36835: ARRAY
36836: PPUSH
36837: LD_INT 30
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PPUSH
36847: CALL_OW 72
36851: ST_TO_ADDR
// if tmp then
36852: LD_VAR 0 8
36856: IFFALSE 36959
// begin for j in tmp do
36858: LD_ADDR_VAR 0 3
36862: PUSH
36863: LD_VAR 0 8
36867: PUSH
36868: FOR_IN
36869: IFFALSE 36957
// for k in UnitsInside ( j ) do
36871: LD_ADDR_VAR 0 4
36875: PUSH
36876: LD_VAR 0 3
36880: PPUSH
36881: CALL_OW 313
36885: PUSH
36886: FOR_IN
36887: IFFALSE 36953
// if k then
36889: LD_VAR 0 4
36893: IFFALSE 36951
// if not k in mc_repair_vehicle [ i ] then
36895: LD_VAR 0 4
36899: PUSH
36900: LD_EXP 62
36904: PUSH
36905: LD_VAR 0 2
36909: ARRAY
36910: IN
36911: NOT
36912: IFFALSE 36951
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36914: LD_ADDR_EXP 62
36918: PUSH
36919: LD_EXP 62
36923: PPUSH
36924: LD_VAR 0 2
36928: PPUSH
36929: LD_EXP 62
36933: PUSH
36934: LD_VAR 0 2
36938: ARRAY
36939: PUSH
36940: LD_VAR 0 4
36944: UNION
36945: PPUSH
36946: CALL_OW 1
36950: ST_TO_ADDR
36951: GO 36886
36953: POP
36954: POP
36955: GO 36868
36957: POP
36958: POP
// end ; if not mc_repair_vehicle [ i ] then
36959: LD_EXP 62
36963: PUSH
36964: LD_VAR 0 2
36968: ARRAY
36969: NOT
36970: IFFALSE 36974
// continue ;
36972: GO 36451
// for j in mc_repair_vehicle [ i ] do
36974: LD_ADDR_VAR 0 3
36978: PUSH
36979: LD_EXP 62
36983: PUSH
36984: LD_VAR 0 2
36988: ARRAY
36989: PUSH
36990: FOR_IN
36991: IFFALSE 37168
// begin if GetClass ( j ) <> 3 then
36993: LD_VAR 0 3
36997: PPUSH
36998: CALL_OW 257
37002: PUSH
37003: LD_INT 3
37005: NONEQUAL
37006: IFFALSE 37047
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37008: LD_ADDR_EXP 62
37012: PUSH
37013: LD_EXP 62
37017: PPUSH
37018: LD_VAR 0 2
37022: PPUSH
37023: LD_EXP 62
37027: PUSH
37028: LD_VAR 0 2
37032: ARRAY
37033: PUSH
37034: LD_VAR 0 3
37038: DIFF
37039: PPUSH
37040: CALL_OW 1
37044: ST_TO_ADDR
// continue ;
37045: GO 36990
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37047: LD_VAR 0 3
37051: PPUSH
37052: CALL_OW 311
37056: NOT
37057: PUSH
37058: LD_VAR 0 3
37062: PUSH
37063: LD_EXP 53
37067: PUSH
37068: LD_VAR 0 2
37072: ARRAY
37073: PUSH
37074: LD_INT 1
37076: ARRAY
37077: IN
37078: NOT
37079: AND
37080: PUSH
37081: LD_VAR 0 3
37085: PUSH
37086: LD_EXP 53
37090: PUSH
37091: LD_VAR 0 2
37095: ARRAY
37096: PUSH
37097: LD_INT 2
37099: ARRAY
37100: IN
37101: NOT
37102: AND
37103: IFFALSE 37166
// begin if IsInUnit ( j ) then
37105: LD_VAR 0 3
37109: PPUSH
37110: CALL_OW 310
37114: IFFALSE 37127
// ComExitBuilding ( j ) else
37116: LD_VAR 0 3
37120: PPUSH
37121: CALL_OW 122
37125: GO 37166
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37127: LD_VAR 0 3
37131: PPUSH
37132: LD_VAR 0 7
37136: PUSH
37137: LD_INT 1
37139: ARRAY
37140: PPUSH
37141: CALL 88872 0 2
37145: NOT
37146: IFFALSE 37166
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37148: LD_VAR 0 3
37152: PPUSH
37153: LD_VAR 0 7
37157: PUSH
37158: LD_INT 1
37160: ARRAY
37161: PPUSH
37162: CALL_OW 129
// end ; end ;
37166: GO 36990
37168: POP
37169: POP
// end ;
37170: GO 36451
37172: POP
37173: POP
// end ;
37174: LD_VAR 0 1
37178: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37179: LD_INT 0
37181: PPUSH
37182: PPUSH
37183: PPUSH
37184: PPUSH
37185: PPUSH
37186: PPUSH
37187: PPUSH
37188: PPUSH
37189: PPUSH
37190: PPUSH
37191: PPUSH
// if not mc_bases then
37192: LD_EXP 50
37196: NOT
37197: IFFALSE 37201
// exit ;
37199: GO 38003
// for i = 1 to mc_bases do
37201: LD_ADDR_VAR 0 2
37205: PUSH
37206: DOUBLE
37207: LD_INT 1
37209: DEC
37210: ST_TO_ADDR
37211: LD_EXP 50
37215: PUSH
37216: FOR_TO
37217: IFFALSE 38001
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37219: LD_EXP 78
37223: PUSH
37224: LD_VAR 0 2
37228: ARRAY
37229: NOT
37230: PUSH
37231: LD_EXP 53
37235: PUSH
37236: LD_VAR 0 2
37240: ARRAY
37241: PUSH
37242: LD_INT 1
37244: ARRAY
37245: OR
37246: PUSH
37247: LD_EXP 53
37251: PUSH
37252: LD_VAR 0 2
37256: ARRAY
37257: PUSH
37258: LD_INT 2
37260: ARRAY
37261: OR
37262: PUSH
37263: LD_EXP 76
37267: PUSH
37268: LD_VAR 0 2
37272: ARRAY
37273: PPUSH
37274: LD_INT 1
37276: PPUSH
37277: CALL_OW 325
37281: NOT
37282: OR
37283: PUSH
37284: LD_EXP 73
37288: PUSH
37289: LD_VAR 0 2
37293: ARRAY
37294: OR
37295: IFFALSE 37299
// continue ;
37297: GO 37216
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37299: LD_ADDR_VAR 0 8
37303: PUSH
37304: LD_EXP 50
37308: PUSH
37309: LD_VAR 0 2
37313: ARRAY
37314: PPUSH
37315: LD_INT 25
37317: PUSH
37318: LD_INT 4
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 50
37327: PUSH
37328: EMPTY
37329: LIST
37330: PUSH
37331: LD_INT 3
37333: PUSH
37334: LD_INT 60
37336: PUSH
37337: EMPTY
37338: LIST
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: LIST
37348: PPUSH
37349: CALL_OW 72
37353: PUSH
37354: LD_EXP 54
37358: PUSH
37359: LD_VAR 0 2
37363: ARRAY
37364: DIFF
37365: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37366: LD_ADDR_VAR 0 9
37370: PUSH
37371: LD_EXP 50
37375: PUSH
37376: LD_VAR 0 2
37380: ARRAY
37381: PPUSH
37382: LD_INT 2
37384: PUSH
37385: LD_INT 30
37387: PUSH
37388: LD_INT 0
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 30
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: PPUSH
37410: CALL_OW 72
37414: ST_TO_ADDR
// if not tmp or not dep then
37415: LD_VAR 0 8
37419: NOT
37420: PUSH
37421: LD_VAR 0 9
37425: NOT
37426: OR
37427: IFFALSE 37431
// continue ;
37429: GO 37216
// side := GetSide ( tmp [ 1 ] ) ;
37431: LD_ADDR_VAR 0 11
37435: PUSH
37436: LD_VAR 0 8
37440: PUSH
37441: LD_INT 1
37443: ARRAY
37444: PPUSH
37445: CALL_OW 255
37449: ST_TO_ADDR
// dep := dep [ 1 ] ;
37450: LD_ADDR_VAR 0 9
37454: PUSH
37455: LD_VAR 0 9
37459: PUSH
37460: LD_INT 1
37462: ARRAY
37463: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37464: LD_ADDR_VAR 0 7
37468: PUSH
37469: LD_EXP 78
37473: PUSH
37474: LD_VAR 0 2
37478: ARRAY
37479: PPUSH
37480: LD_INT 22
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 25
37492: PUSH
37493: LD_INT 12
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PPUSH
37504: CALL_OW 70
37508: PUSH
37509: LD_INT 22
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 25
37521: PUSH
37522: LD_INT 12
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 91
37531: PUSH
37532: LD_VAR 0 9
37536: PUSH
37537: LD_INT 20
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: LIST
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: LIST
37549: PPUSH
37550: CALL_OW 69
37554: UNION
37555: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37556: LD_ADDR_VAR 0 10
37560: PUSH
37561: LD_EXP 78
37565: PUSH
37566: LD_VAR 0 2
37570: ARRAY
37571: PPUSH
37572: LD_INT 81
37574: PUSH
37575: LD_VAR 0 11
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PPUSH
37584: CALL_OW 70
37588: ST_TO_ADDR
// if not apes or danger_at_area then
37589: LD_VAR 0 7
37593: NOT
37594: PUSH
37595: LD_VAR 0 10
37599: OR
37600: IFFALSE 37650
// begin if mc_taming [ i ] then
37602: LD_EXP 81
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: IFFALSE 37648
// begin MC_Reset ( i , 121 ) ;
37614: LD_VAR 0 2
37618: PPUSH
37619: LD_INT 121
37621: PPUSH
37622: CALL 22566 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37626: LD_ADDR_EXP 81
37630: PUSH
37631: LD_EXP 81
37635: PPUSH
37636: LD_VAR 0 2
37640: PPUSH
37641: EMPTY
37642: PPUSH
37643: CALL_OW 1
37647: ST_TO_ADDR
// end ; continue ;
37648: GO 37216
// end ; for j in tmp do
37650: LD_ADDR_VAR 0 3
37654: PUSH
37655: LD_VAR 0 8
37659: PUSH
37660: FOR_IN
37661: IFFALSE 37997
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37663: LD_VAR 0 3
37667: PUSH
37668: LD_EXP 81
37672: PUSH
37673: LD_VAR 0 2
37677: ARRAY
37678: IN
37679: NOT
37680: PUSH
37681: LD_EXP 81
37685: PUSH
37686: LD_VAR 0 2
37690: ARRAY
37691: PUSH
37692: LD_INT 3
37694: LESS
37695: AND
37696: IFFALSE 37754
// begin SetTag ( j , 121 ) ;
37698: LD_VAR 0 3
37702: PPUSH
37703: LD_INT 121
37705: PPUSH
37706: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37710: LD_ADDR_EXP 81
37714: PUSH
37715: LD_EXP 81
37719: PPUSH
37720: LD_VAR 0 2
37724: PUSH
37725: LD_EXP 81
37729: PUSH
37730: LD_VAR 0 2
37734: ARRAY
37735: PUSH
37736: LD_INT 1
37738: PLUS
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PPUSH
37744: LD_VAR 0 3
37748: PPUSH
37749: CALL 54067 0 3
37753: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37754: LD_VAR 0 3
37758: PUSH
37759: LD_EXP 81
37763: PUSH
37764: LD_VAR 0 2
37768: ARRAY
37769: IN
37770: IFFALSE 37995
// begin if GetClass ( j ) <> 4 then
37772: LD_VAR 0 3
37776: PPUSH
37777: CALL_OW 257
37781: PUSH
37782: LD_INT 4
37784: NONEQUAL
37785: IFFALSE 37838
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37787: LD_ADDR_EXP 81
37791: PUSH
37792: LD_EXP 81
37796: PPUSH
37797: LD_VAR 0 2
37801: PPUSH
37802: LD_EXP 81
37806: PUSH
37807: LD_VAR 0 2
37811: ARRAY
37812: PUSH
37813: LD_VAR 0 3
37817: DIFF
37818: PPUSH
37819: CALL_OW 1
37823: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37824: LD_VAR 0 3
37828: PPUSH
37829: LD_INT 0
37831: PPUSH
37832: CALL_OW 109
// continue ;
37836: GO 37660
// end ; if IsInUnit ( j ) then
37838: LD_VAR 0 3
37842: PPUSH
37843: CALL_OW 310
37847: IFFALSE 37858
// ComExitBuilding ( j ) ;
37849: LD_VAR 0 3
37853: PPUSH
37854: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37858: LD_ADDR_VAR 0 6
37862: PUSH
37863: LD_VAR 0 7
37867: PPUSH
37868: LD_VAR 0 3
37872: PPUSH
37873: CALL_OW 74
37877: ST_TO_ADDR
// if not ape then
37878: LD_VAR 0 6
37882: NOT
37883: IFFALSE 37887
// break ;
37885: GO 37997
// x := GetX ( ape ) ;
37887: LD_ADDR_VAR 0 4
37891: PUSH
37892: LD_VAR 0 6
37896: PPUSH
37897: CALL_OW 250
37901: ST_TO_ADDR
// y := GetY ( ape ) ;
37902: LD_ADDR_VAR 0 5
37906: PUSH
37907: LD_VAR 0 6
37911: PPUSH
37912: CALL_OW 251
37916: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37917: LD_VAR 0 4
37921: PPUSH
37922: LD_VAR 0 5
37926: PPUSH
37927: CALL_OW 488
37931: NOT
37932: PUSH
37933: LD_VAR 0 11
37937: PPUSH
37938: LD_VAR 0 4
37942: PPUSH
37943: LD_VAR 0 5
37947: PPUSH
37948: LD_INT 20
37950: PPUSH
37951: CALL 55331 0 4
37955: PUSH
37956: LD_INT 4
37958: ARRAY
37959: OR
37960: IFFALSE 37964
// break ;
37962: GO 37997
// if not HasTask ( j ) then
37964: LD_VAR 0 3
37968: PPUSH
37969: CALL_OW 314
37973: NOT
37974: IFFALSE 37995
// ComTameXY ( j , x , y ) ;
37976: LD_VAR 0 3
37980: PPUSH
37981: LD_VAR 0 4
37985: PPUSH
37986: LD_VAR 0 5
37990: PPUSH
37991: CALL_OW 131
// end ; end ;
37995: GO 37660
37997: POP
37998: POP
// end ;
37999: GO 37216
38001: POP
38002: POP
// end ;
38003: LD_VAR 0 1
38007: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38008: LD_INT 0
38010: PPUSH
38011: PPUSH
38012: PPUSH
38013: PPUSH
38014: PPUSH
38015: PPUSH
38016: PPUSH
38017: PPUSH
// if not mc_bases then
38018: LD_EXP 50
38022: NOT
38023: IFFALSE 38027
// exit ;
38025: GO 38653
// for i = 1 to mc_bases do
38027: LD_ADDR_VAR 0 2
38031: PUSH
38032: DOUBLE
38033: LD_INT 1
38035: DEC
38036: ST_TO_ADDR
38037: LD_EXP 50
38041: PUSH
38042: FOR_TO
38043: IFFALSE 38651
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38045: LD_EXP 79
38049: PUSH
38050: LD_VAR 0 2
38054: ARRAY
38055: NOT
38056: PUSH
38057: LD_EXP 79
38061: PUSH
38062: LD_VAR 0 2
38066: ARRAY
38067: PPUSH
38068: LD_INT 25
38070: PUSH
38071: LD_INT 12
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PPUSH
38078: CALL_OW 72
38082: NOT
38083: OR
38084: IFFALSE 38088
// continue ;
38086: GO 38042
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38088: LD_ADDR_VAR 0 5
38092: PUSH
38093: LD_EXP 79
38097: PUSH
38098: LD_VAR 0 2
38102: ARRAY
38103: PUSH
38104: LD_INT 1
38106: ARRAY
38107: PPUSH
38108: CALL_OW 255
38112: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38113: LD_VAR 0 5
38117: PPUSH
38118: LD_INT 2
38120: PPUSH
38121: CALL_OW 325
38125: IFFALSE 38378
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38127: LD_ADDR_VAR 0 4
38131: PUSH
38132: LD_EXP 79
38136: PUSH
38137: LD_VAR 0 2
38141: ARRAY
38142: PPUSH
38143: LD_INT 25
38145: PUSH
38146: LD_INT 16
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PPUSH
38153: CALL_OW 72
38157: ST_TO_ADDR
// if tmp < 6 then
38158: LD_VAR 0 4
38162: PUSH
38163: LD_INT 6
38165: LESS
38166: IFFALSE 38378
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38168: LD_ADDR_VAR 0 6
38172: PUSH
38173: LD_EXP 50
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: PPUSH
38184: LD_INT 2
38186: PUSH
38187: LD_INT 30
38189: PUSH
38190: LD_INT 0
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 30
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: LIST
38211: PPUSH
38212: CALL_OW 72
38216: ST_TO_ADDR
// if depot then
38217: LD_VAR 0 6
38221: IFFALSE 38378
// begin selected := 0 ;
38223: LD_ADDR_VAR 0 7
38227: PUSH
38228: LD_INT 0
38230: ST_TO_ADDR
// for j in depot do
38231: LD_ADDR_VAR 0 3
38235: PUSH
38236: LD_VAR 0 6
38240: PUSH
38241: FOR_IN
38242: IFFALSE 38273
// begin if UnitsInside ( j ) < 6 then
38244: LD_VAR 0 3
38248: PPUSH
38249: CALL_OW 313
38253: PUSH
38254: LD_INT 6
38256: LESS
38257: IFFALSE 38271
// begin selected := j ;
38259: LD_ADDR_VAR 0 7
38263: PUSH
38264: LD_VAR 0 3
38268: ST_TO_ADDR
// break ;
38269: GO 38273
// end ; end ;
38271: GO 38241
38273: POP
38274: POP
// if selected then
38275: LD_VAR 0 7
38279: IFFALSE 38378
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38281: LD_ADDR_VAR 0 3
38285: PUSH
38286: LD_EXP 79
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PPUSH
38297: LD_INT 25
38299: PUSH
38300: LD_INT 12
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PPUSH
38307: CALL_OW 72
38311: PUSH
38312: FOR_IN
38313: IFFALSE 38376
// if not HasTask ( j ) then
38315: LD_VAR 0 3
38319: PPUSH
38320: CALL_OW 314
38324: NOT
38325: IFFALSE 38374
// begin if not IsInUnit ( j ) then
38327: LD_VAR 0 3
38331: PPUSH
38332: CALL_OW 310
38336: NOT
38337: IFFALSE 38353
// ComEnterUnit ( j , selected ) ;
38339: LD_VAR 0 3
38343: PPUSH
38344: LD_VAR 0 7
38348: PPUSH
38349: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38353: LD_VAR 0 3
38357: PPUSH
38358: LD_INT 16
38360: PPUSH
38361: CALL_OW 183
// AddComExitBuilding ( j ) ;
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 182
// end ;
38374: GO 38312
38376: POP
38377: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38378: LD_VAR 0 5
38382: PPUSH
38383: LD_INT 11
38385: PPUSH
38386: CALL_OW 325
38390: IFFALSE 38649
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38392: LD_ADDR_VAR 0 4
38396: PUSH
38397: LD_EXP 79
38401: PUSH
38402: LD_VAR 0 2
38406: ARRAY
38407: PPUSH
38408: LD_INT 25
38410: PUSH
38411: LD_INT 16
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PPUSH
38418: CALL_OW 72
38422: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38423: LD_VAR 0 4
38427: PUSH
38428: LD_INT 6
38430: GREATEREQUAL
38431: PUSH
38432: LD_VAR 0 5
38436: PPUSH
38437: LD_INT 2
38439: PPUSH
38440: CALL_OW 325
38444: NOT
38445: OR
38446: IFFALSE 38649
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38448: LD_ADDR_VAR 0 8
38452: PUSH
38453: LD_EXP 50
38457: PUSH
38458: LD_VAR 0 2
38462: ARRAY
38463: PPUSH
38464: LD_INT 2
38466: PUSH
38467: LD_INT 30
38469: PUSH
38470: LD_INT 4
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 30
38479: PUSH
38480: LD_INT 5
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: LIST
38491: PPUSH
38492: CALL_OW 72
38496: ST_TO_ADDR
// if barracks then
38497: LD_VAR 0 8
38501: IFFALSE 38649
// begin selected := 0 ;
38503: LD_ADDR_VAR 0 7
38507: PUSH
38508: LD_INT 0
38510: ST_TO_ADDR
// for j in barracks do
38511: LD_ADDR_VAR 0 3
38515: PUSH
38516: LD_VAR 0 8
38520: PUSH
38521: FOR_IN
38522: IFFALSE 38553
// begin if UnitsInside ( j ) < 6 then
38524: LD_VAR 0 3
38528: PPUSH
38529: CALL_OW 313
38533: PUSH
38534: LD_INT 6
38536: LESS
38537: IFFALSE 38551
// begin selected := j ;
38539: LD_ADDR_VAR 0 7
38543: PUSH
38544: LD_VAR 0 3
38548: ST_TO_ADDR
// break ;
38549: GO 38553
// end ; end ;
38551: GO 38521
38553: POP
38554: POP
// if selected then
38555: LD_VAR 0 7
38559: IFFALSE 38649
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38561: LD_ADDR_VAR 0 3
38565: PUSH
38566: LD_EXP 79
38570: PUSH
38571: LD_VAR 0 2
38575: ARRAY
38576: PPUSH
38577: LD_INT 25
38579: PUSH
38580: LD_INT 12
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PPUSH
38587: CALL_OW 72
38591: PUSH
38592: FOR_IN
38593: IFFALSE 38647
// if not IsInUnit ( j ) and not HasTask ( j ) then
38595: LD_VAR 0 3
38599: PPUSH
38600: CALL_OW 310
38604: NOT
38605: PUSH
38606: LD_VAR 0 3
38610: PPUSH
38611: CALL_OW 314
38615: NOT
38616: AND
38617: IFFALSE 38645
// begin ComEnterUnit ( j , selected ) ;
38619: LD_VAR 0 3
38623: PPUSH
38624: LD_VAR 0 7
38628: PPUSH
38629: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38633: LD_VAR 0 3
38637: PPUSH
38638: LD_INT 15
38640: PPUSH
38641: CALL_OW 183
// end ;
38645: GO 38592
38647: POP
38648: POP
// end ; end ; end ; end ; end ;
38649: GO 38042
38651: POP
38652: POP
// end ;
38653: LD_VAR 0 1
38657: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38658: LD_INT 0
38660: PPUSH
38661: PPUSH
38662: PPUSH
38663: PPUSH
// if not mc_bases then
38664: LD_EXP 50
38668: NOT
38669: IFFALSE 38673
// exit ;
38671: GO 38851
// for i = 1 to mc_bases do
38673: LD_ADDR_VAR 0 2
38677: PUSH
38678: DOUBLE
38679: LD_INT 1
38681: DEC
38682: ST_TO_ADDR
38683: LD_EXP 50
38687: PUSH
38688: FOR_TO
38689: IFFALSE 38849
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38691: LD_ADDR_VAR 0 4
38695: PUSH
38696: LD_EXP 50
38700: PUSH
38701: LD_VAR 0 2
38705: ARRAY
38706: PPUSH
38707: LD_INT 25
38709: PUSH
38710: LD_INT 9
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PPUSH
38717: CALL_OW 72
38721: ST_TO_ADDR
// if not tmp then
38722: LD_VAR 0 4
38726: NOT
38727: IFFALSE 38731
// continue ;
38729: GO 38688
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38731: LD_EXP 76
38735: PUSH
38736: LD_VAR 0 2
38740: ARRAY
38741: PPUSH
38742: LD_INT 29
38744: PPUSH
38745: CALL_OW 325
38749: NOT
38750: PUSH
38751: LD_EXP 76
38755: PUSH
38756: LD_VAR 0 2
38760: ARRAY
38761: PPUSH
38762: LD_INT 28
38764: PPUSH
38765: CALL_OW 325
38769: NOT
38770: AND
38771: IFFALSE 38775
// continue ;
38773: GO 38688
// for j in tmp do
38775: LD_ADDR_VAR 0 3
38779: PUSH
38780: LD_VAR 0 4
38784: PUSH
38785: FOR_IN
38786: IFFALSE 38845
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38788: LD_VAR 0 3
38792: PUSH
38793: LD_EXP 53
38797: PUSH
38798: LD_VAR 0 2
38802: ARRAY
38803: PUSH
38804: LD_INT 1
38806: ARRAY
38807: IN
38808: NOT
38809: PUSH
38810: LD_VAR 0 3
38814: PUSH
38815: LD_EXP 53
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_INT 2
38828: ARRAY
38829: IN
38830: NOT
38831: AND
38832: IFFALSE 38843
// ComSpaceTimeShoot ( j ) ;
38834: LD_VAR 0 3
38838: PPUSH
38839: CALL 50052 0 1
38843: GO 38785
38845: POP
38846: POP
// end ;
38847: GO 38688
38849: POP
38850: POP
// end ;
38851: LD_VAR 0 1
38855: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38856: LD_INT 0
38858: PPUSH
38859: PPUSH
38860: PPUSH
38861: PPUSH
38862: PPUSH
38863: PPUSH
38864: PPUSH
38865: PPUSH
38866: PPUSH
// if not mc_bases then
38867: LD_EXP 50
38871: NOT
38872: IFFALSE 38876
// exit ;
38874: GO 39498
// for i = 1 to mc_bases do
38876: LD_ADDR_VAR 0 2
38880: PUSH
38881: DOUBLE
38882: LD_INT 1
38884: DEC
38885: ST_TO_ADDR
38886: LD_EXP 50
38890: PUSH
38891: FOR_TO
38892: IFFALSE 39496
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38894: LD_EXP 85
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: NOT
38905: PUSH
38906: LD_INT 38
38908: PPUSH
38909: LD_EXP 76
38913: PUSH
38914: LD_VAR 0 2
38918: ARRAY
38919: PPUSH
38920: CALL_OW 321
38924: PUSH
38925: LD_INT 2
38927: NONEQUAL
38928: OR
38929: IFFALSE 38933
// continue ;
38931: GO 38891
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38933: LD_ADDR_VAR 0 8
38937: PUSH
38938: LD_EXP 50
38942: PUSH
38943: LD_VAR 0 2
38947: ARRAY
38948: PPUSH
38949: LD_INT 30
38951: PUSH
38952: LD_INT 34
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PPUSH
38959: CALL_OW 72
38963: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38964: LD_ADDR_VAR 0 9
38968: PUSH
38969: LD_EXP 50
38973: PUSH
38974: LD_VAR 0 2
38978: ARRAY
38979: PPUSH
38980: LD_INT 25
38982: PUSH
38983: LD_INT 4
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PPUSH
38990: CALL_OW 72
38994: PPUSH
38995: LD_INT 0
38997: PPUSH
38998: CALL 84376 0 2
39002: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39003: LD_VAR 0 9
39007: NOT
39008: PUSH
39009: LD_VAR 0 8
39013: NOT
39014: OR
39015: PUSH
39016: LD_EXP 50
39020: PUSH
39021: LD_VAR 0 2
39025: ARRAY
39026: PPUSH
39027: LD_INT 124
39029: PPUSH
39030: CALL 84376 0 2
39034: OR
39035: IFFALSE 39039
// continue ;
39037: GO 38891
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39039: LD_EXP 86
39043: PUSH
39044: LD_VAR 0 2
39048: ARRAY
39049: PUSH
39050: LD_EXP 85
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: LESS
39061: PUSH
39062: LD_EXP 86
39066: PUSH
39067: LD_VAR 0 2
39071: ARRAY
39072: PUSH
39073: LD_VAR 0 8
39077: LESS
39078: AND
39079: IFFALSE 39494
// begin tmp := sci [ 1 ] ;
39081: LD_ADDR_VAR 0 7
39085: PUSH
39086: LD_VAR 0 9
39090: PUSH
39091: LD_INT 1
39093: ARRAY
39094: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39095: LD_VAR 0 7
39099: PPUSH
39100: LD_INT 124
39102: PPUSH
39103: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39107: LD_ADDR_VAR 0 3
39111: PUSH
39112: DOUBLE
39113: LD_EXP 85
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: INC
39124: ST_TO_ADDR
39125: LD_EXP 85
39129: PUSH
39130: LD_VAR 0 2
39134: ARRAY
39135: PUSH
39136: FOR_DOWNTO
39137: IFFALSE 39480
// begin if IsInUnit ( tmp ) then
39139: LD_VAR 0 7
39143: PPUSH
39144: CALL_OW 310
39148: IFFALSE 39159
// ComExitBuilding ( tmp ) ;
39150: LD_VAR 0 7
39154: PPUSH
39155: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39159: LD_INT 35
39161: PPUSH
39162: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39166: LD_VAR 0 7
39170: PPUSH
39171: CALL_OW 310
39175: NOT
39176: PUSH
39177: LD_VAR 0 7
39181: PPUSH
39182: CALL_OW 314
39186: NOT
39187: AND
39188: IFFALSE 39159
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39190: LD_ADDR_VAR 0 6
39194: PUSH
39195: LD_VAR 0 7
39199: PPUSH
39200: CALL_OW 250
39204: PUSH
39205: LD_VAR 0 7
39209: PPUSH
39210: CALL_OW 251
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39219: LD_INT 35
39221: PPUSH
39222: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39226: LD_ADDR_VAR 0 4
39230: PUSH
39231: LD_EXP 85
39235: PUSH
39236: LD_VAR 0 2
39240: ARRAY
39241: PUSH
39242: LD_VAR 0 3
39246: ARRAY
39247: PUSH
39248: LD_INT 1
39250: ARRAY
39251: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39252: LD_ADDR_VAR 0 5
39256: PUSH
39257: LD_EXP 85
39261: PUSH
39262: LD_VAR 0 2
39266: ARRAY
39267: PUSH
39268: LD_VAR 0 3
39272: ARRAY
39273: PUSH
39274: LD_INT 2
39276: ARRAY
39277: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39278: LD_VAR 0 7
39282: PPUSH
39283: LD_INT 10
39285: PPUSH
39286: CALL 57032 0 2
39290: PUSH
39291: LD_INT 4
39293: ARRAY
39294: IFFALSE 39332
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39296: LD_VAR 0 7
39300: PPUSH
39301: LD_VAR 0 6
39305: PUSH
39306: LD_INT 1
39308: ARRAY
39309: PPUSH
39310: LD_VAR 0 6
39314: PUSH
39315: LD_INT 2
39317: ARRAY
39318: PPUSH
39319: CALL_OW 111
// wait ( 0 0$10 ) ;
39323: LD_INT 350
39325: PPUSH
39326: CALL_OW 67
// end else
39330: GO 39358
// begin ComMoveXY ( tmp , x , y ) ;
39332: LD_VAR 0 7
39336: PPUSH
39337: LD_VAR 0 4
39341: PPUSH
39342: LD_VAR 0 5
39346: PPUSH
39347: CALL_OW 111
// wait ( 0 0$3 ) ;
39351: LD_INT 105
39353: PPUSH
39354: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39358: LD_VAR 0 7
39362: PPUSH
39363: LD_VAR 0 4
39367: PPUSH
39368: LD_VAR 0 5
39372: PPUSH
39373: CALL_OW 307
39377: IFFALSE 39219
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39379: LD_VAR 0 7
39383: PPUSH
39384: LD_VAR 0 4
39388: PPUSH
39389: LD_VAR 0 5
39393: PPUSH
39394: LD_VAR 0 8
39398: PUSH
39399: LD_VAR 0 3
39403: ARRAY
39404: PPUSH
39405: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39409: LD_INT 35
39411: PPUSH
39412: CALL_OW 67
// until not HasTask ( tmp ) ;
39416: LD_VAR 0 7
39420: PPUSH
39421: CALL_OW 314
39425: NOT
39426: IFFALSE 39409
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39428: LD_ADDR_EXP 86
39432: PUSH
39433: LD_EXP 86
39437: PPUSH
39438: LD_VAR 0 2
39442: PUSH
39443: LD_EXP 86
39447: PUSH
39448: LD_VAR 0 2
39452: ARRAY
39453: PUSH
39454: LD_INT 1
39456: PLUS
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PPUSH
39462: LD_VAR 0 8
39466: PUSH
39467: LD_VAR 0 3
39471: ARRAY
39472: PPUSH
39473: CALL 54067 0 3
39477: ST_TO_ADDR
// end ;
39478: GO 39136
39480: POP
39481: POP
// MC_Reset ( i , 124 ) ;
39482: LD_VAR 0 2
39486: PPUSH
39487: LD_INT 124
39489: PPUSH
39490: CALL 22566 0 2
// end ; end ;
39494: GO 38891
39496: POP
39497: POP
// end ;
39498: LD_VAR 0 1
39502: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39503: LD_INT 0
39505: PPUSH
39506: PPUSH
39507: PPUSH
// if not mc_bases then
39508: LD_EXP 50
39512: NOT
39513: IFFALSE 39517
// exit ;
39515: GO 40123
// for i = 1 to mc_bases do
39517: LD_ADDR_VAR 0 2
39521: PUSH
39522: DOUBLE
39523: LD_INT 1
39525: DEC
39526: ST_TO_ADDR
39527: LD_EXP 50
39531: PUSH
39532: FOR_TO
39533: IFFALSE 40121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39535: LD_ADDR_VAR 0 3
39539: PUSH
39540: LD_EXP 50
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: PPUSH
39551: LD_INT 25
39553: PUSH
39554: LD_INT 4
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PPUSH
39561: CALL_OW 72
39565: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39566: LD_VAR 0 3
39570: NOT
39571: PUSH
39572: LD_EXP 87
39576: PUSH
39577: LD_VAR 0 2
39581: ARRAY
39582: NOT
39583: OR
39584: PUSH
39585: LD_EXP 50
39589: PUSH
39590: LD_VAR 0 2
39594: ARRAY
39595: PPUSH
39596: LD_INT 2
39598: PUSH
39599: LD_INT 30
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 30
39611: PUSH
39612: LD_INT 1
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: LIST
39623: PPUSH
39624: CALL_OW 72
39628: NOT
39629: OR
39630: IFFALSE 39680
// begin if mc_deposits_finder [ i ] then
39632: LD_EXP 88
39636: PUSH
39637: LD_VAR 0 2
39641: ARRAY
39642: IFFALSE 39678
// begin MC_Reset ( i , 125 ) ;
39644: LD_VAR 0 2
39648: PPUSH
39649: LD_INT 125
39651: PPUSH
39652: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39656: LD_ADDR_EXP 88
39660: PUSH
39661: LD_EXP 88
39665: PPUSH
39666: LD_VAR 0 2
39670: PPUSH
39671: EMPTY
39672: PPUSH
39673: CALL_OW 1
39677: ST_TO_ADDR
// end ; continue ;
39678: GO 39532
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39680: LD_EXP 87
39684: PUSH
39685: LD_VAR 0 2
39689: ARRAY
39690: PUSH
39691: LD_INT 1
39693: ARRAY
39694: PUSH
39695: LD_INT 3
39697: ARRAY
39698: PUSH
39699: LD_INT 1
39701: EQUAL
39702: PUSH
39703: LD_INT 20
39705: PPUSH
39706: LD_EXP 76
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: PPUSH
39717: CALL_OW 321
39721: PUSH
39722: LD_INT 2
39724: NONEQUAL
39725: AND
39726: IFFALSE 39776
// begin if mc_deposits_finder [ i ] then
39728: LD_EXP 88
39732: PUSH
39733: LD_VAR 0 2
39737: ARRAY
39738: IFFALSE 39774
// begin MC_Reset ( i , 125 ) ;
39740: LD_VAR 0 2
39744: PPUSH
39745: LD_INT 125
39747: PPUSH
39748: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39752: LD_ADDR_EXP 88
39756: PUSH
39757: LD_EXP 88
39761: PPUSH
39762: LD_VAR 0 2
39766: PPUSH
39767: EMPTY
39768: PPUSH
39769: CALL_OW 1
39773: ST_TO_ADDR
// end ; continue ;
39774: GO 39532
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39776: LD_EXP 87
39780: PUSH
39781: LD_VAR 0 2
39785: ARRAY
39786: PUSH
39787: LD_INT 1
39789: ARRAY
39790: PUSH
39791: LD_INT 1
39793: ARRAY
39794: PPUSH
39795: LD_EXP 87
39799: PUSH
39800: LD_VAR 0 2
39804: ARRAY
39805: PUSH
39806: LD_INT 1
39808: ARRAY
39809: PUSH
39810: LD_INT 2
39812: ARRAY
39813: PPUSH
39814: LD_EXP 76
39818: PUSH
39819: LD_VAR 0 2
39823: ARRAY
39824: PPUSH
39825: CALL_OW 440
39829: IFFALSE 39872
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39831: LD_ADDR_EXP 87
39835: PUSH
39836: LD_EXP 87
39840: PPUSH
39841: LD_VAR 0 2
39845: PPUSH
39846: LD_EXP 87
39850: PUSH
39851: LD_VAR 0 2
39855: ARRAY
39856: PPUSH
39857: LD_INT 1
39859: PPUSH
39860: CALL_OW 3
39864: PPUSH
39865: CALL_OW 1
39869: ST_TO_ADDR
39870: GO 40119
// begin if not mc_deposits_finder [ i ] then
39872: LD_EXP 88
39876: PUSH
39877: LD_VAR 0 2
39881: ARRAY
39882: NOT
39883: IFFALSE 39935
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39885: LD_ADDR_EXP 88
39889: PUSH
39890: LD_EXP 88
39894: PPUSH
39895: LD_VAR 0 2
39899: PPUSH
39900: LD_VAR 0 3
39904: PUSH
39905: LD_INT 1
39907: ARRAY
39908: PUSH
39909: EMPTY
39910: LIST
39911: PPUSH
39912: CALL_OW 1
39916: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39917: LD_VAR 0 3
39921: PUSH
39922: LD_INT 1
39924: ARRAY
39925: PPUSH
39926: LD_INT 125
39928: PPUSH
39929: CALL_OW 109
// end else
39933: GO 40119
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39935: LD_EXP 88
39939: PUSH
39940: LD_VAR 0 2
39944: ARRAY
39945: PUSH
39946: LD_INT 1
39948: ARRAY
39949: PPUSH
39950: CALL_OW 310
39954: IFFALSE 39977
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39956: LD_EXP 88
39960: PUSH
39961: LD_VAR 0 2
39965: ARRAY
39966: PUSH
39967: LD_INT 1
39969: ARRAY
39970: PPUSH
39971: CALL_OW 122
39975: GO 40119
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39977: LD_EXP 88
39981: PUSH
39982: LD_VAR 0 2
39986: ARRAY
39987: PUSH
39988: LD_INT 1
39990: ARRAY
39991: PPUSH
39992: CALL_OW 314
39996: NOT
39997: PUSH
39998: LD_EXP 88
40002: PUSH
40003: LD_VAR 0 2
40007: ARRAY
40008: PUSH
40009: LD_INT 1
40011: ARRAY
40012: PPUSH
40013: LD_EXP 87
40017: PUSH
40018: LD_VAR 0 2
40022: ARRAY
40023: PUSH
40024: LD_INT 1
40026: ARRAY
40027: PUSH
40028: LD_INT 1
40030: ARRAY
40031: PPUSH
40032: LD_EXP 87
40036: PUSH
40037: LD_VAR 0 2
40041: ARRAY
40042: PUSH
40043: LD_INT 1
40045: ARRAY
40046: PUSH
40047: LD_INT 2
40049: ARRAY
40050: PPUSH
40051: CALL_OW 297
40055: PUSH
40056: LD_INT 6
40058: GREATER
40059: AND
40060: IFFALSE 40119
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40062: LD_EXP 88
40066: PUSH
40067: LD_VAR 0 2
40071: ARRAY
40072: PUSH
40073: LD_INT 1
40075: ARRAY
40076: PPUSH
40077: LD_EXP 87
40081: PUSH
40082: LD_VAR 0 2
40086: ARRAY
40087: PUSH
40088: LD_INT 1
40090: ARRAY
40091: PUSH
40092: LD_INT 1
40094: ARRAY
40095: PPUSH
40096: LD_EXP 87
40100: PUSH
40101: LD_VAR 0 2
40105: ARRAY
40106: PUSH
40107: LD_INT 1
40109: ARRAY
40110: PUSH
40111: LD_INT 2
40113: ARRAY
40114: PPUSH
40115: CALL_OW 111
// end ; end ; end ;
40119: GO 39532
40121: POP
40122: POP
// end ;
40123: LD_VAR 0 1
40127: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40128: LD_INT 0
40130: PPUSH
40131: PPUSH
40132: PPUSH
40133: PPUSH
40134: PPUSH
40135: PPUSH
40136: PPUSH
40137: PPUSH
40138: PPUSH
40139: PPUSH
40140: PPUSH
// if not mc_bases then
40141: LD_EXP 50
40145: NOT
40146: IFFALSE 40150
// exit ;
40148: GO 41090
// for i = 1 to mc_bases do
40150: LD_ADDR_VAR 0 2
40154: PUSH
40155: DOUBLE
40156: LD_INT 1
40158: DEC
40159: ST_TO_ADDR
40160: LD_EXP 50
40164: PUSH
40165: FOR_TO
40166: IFFALSE 41088
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40168: LD_EXP 50
40172: PUSH
40173: LD_VAR 0 2
40177: ARRAY
40178: NOT
40179: PUSH
40180: LD_EXP 73
40184: PUSH
40185: LD_VAR 0 2
40189: ARRAY
40190: OR
40191: IFFALSE 40195
// continue ;
40193: GO 40165
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40195: LD_ADDR_VAR 0 7
40199: PUSH
40200: LD_EXP 50
40204: PUSH
40205: LD_VAR 0 2
40209: ARRAY
40210: PUSH
40211: LD_INT 1
40213: ARRAY
40214: PPUSH
40215: CALL_OW 248
40219: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40220: LD_VAR 0 7
40224: PUSH
40225: LD_INT 3
40227: EQUAL
40228: PUSH
40229: LD_EXP 69
40233: PUSH
40234: LD_VAR 0 2
40238: ARRAY
40239: PUSH
40240: LD_EXP 72
40244: PUSH
40245: LD_VAR 0 2
40249: ARRAY
40250: UNION
40251: PPUSH
40252: LD_INT 33
40254: PUSH
40255: LD_INT 2
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PPUSH
40262: CALL_OW 72
40266: NOT
40267: OR
40268: IFFALSE 40272
// continue ;
40270: GO 40165
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40272: LD_ADDR_VAR 0 9
40276: PUSH
40277: LD_EXP 50
40281: PUSH
40282: LD_VAR 0 2
40286: ARRAY
40287: PPUSH
40288: LD_INT 30
40290: PUSH
40291: LD_INT 36
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PPUSH
40298: CALL_OW 72
40302: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40303: LD_ADDR_VAR 0 10
40307: PUSH
40308: LD_EXP 69
40312: PUSH
40313: LD_VAR 0 2
40317: ARRAY
40318: PPUSH
40319: LD_INT 34
40321: PUSH
40322: LD_INT 31
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PPUSH
40329: CALL_OW 72
40333: ST_TO_ADDR
// if not cts and not mcts then
40334: LD_VAR 0 9
40338: NOT
40339: PUSH
40340: LD_VAR 0 10
40344: NOT
40345: AND
40346: IFFALSE 40350
// continue ;
40348: GO 40165
// x := cts ;
40350: LD_ADDR_VAR 0 11
40354: PUSH
40355: LD_VAR 0 9
40359: ST_TO_ADDR
// if not x then
40360: LD_VAR 0 11
40364: NOT
40365: IFFALSE 40377
// x := mcts ;
40367: LD_ADDR_VAR 0 11
40371: PUSH
40372: LD_VAR 0 10
40376: ST_TO_ADDR
// if not x then
40377: LD_VAR 0 11
40381: NOT
40382: IFFALSE 40386
// continue ;
40384: GO 40165
// if mc_remote_driver [ i ] then
40386: LD_EXP 90
40390: PUSH
40391: LD_VAR 0 2
40395: ARRAY
40396: IFFALSE 40783
// for j in mc_remote_driver [ i ] do
40398: LD_ADDR_VAR 0 3
40402: PUSH
40403: LD_EXP 90
40407: PUSH
40408: LD_VAR 0 2
40412: ARRAY
40413: PUSH
40414: FOR_IN
40415: IFFALSE 40781
// begin if GetClass ( j ) <> 3 then
40417: LD_VAR 0 3
40421: PPUSH
40422: CALL_OW 257
40426: PUSH
40427: LD_INT 3
40429: NONEQUAL
40430: IFFALSE 40483
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40432: LD_ADDR_EXP 90
40436: PUSH
40437: LD_EXP 90
40441: PPUSH
40442: LD_VAR 0 2
40446: PPUSH
40447: LD_EXP 90
40451: PUSH
40452: LD_VAR 0 2
40456: ARRAY
40457: PUSH
40458: LD_VAR 0 3
40462: DIFF
40463: PPUSH
40464: CALL_OW 1
40468: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40469: LD_VAR 0 3
40473: PPUSH
40474: LD_INT 0
40476: PPUSH
40477: CALL_OW 109
// continue ;
40481: GO 40414
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40483: LD_EXP 69
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PPUSH
40494: LD_INT 34
40496: PUSH
40497: LD_INT 31
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 58
40506: PUSH
40507: EMPTY
40508: LIST
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PPUSH
40514: CALL_OW 72
40518: PUSH
40519: LD_VAR 0 3
40523: PPUSH
40524: CALL 84411 0 1
40528: NOT
40529: AND
40530: IFFALSE 40601
// begin if IsInUnit ( j ) then
40532: LD_VAR 0 3
40536: PPUSH
40537: CALL_OW 310
40541: IFFALSE 40552
// ComExitBuilding ( j ) ;
40543: LD_VAR 0 3
40547: PPUSH
40548: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40552: LD_VAR 0 3
40556: PPUSH
40557: LD_EXP 69
40561: PUSH
40562: LD_VAR 0 2
40566: ARRAY
40567: PPUSH
40568: LD_INT 34
40570: PUSH
40571: LD_INT 31
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 58
40580: PUSH
40581: EMPTY
40582: LIST
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PPUSH
40588: CALL_OW 72
40592: PUSH
40593: LD_INT 1
40595: ARRAY
40596: PPUSH
40597: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40601: LD_VAR 0 3
40605: PPUSH
40606: CALL_OW 310
40610: NOT
40611: PUSH
40612: LD_VAR 0 3
40616: PPUSH
40617: CALL_OW 310
40621: PPUSH
40622: CALL_OW 266
40626: PUSH
40627: LD_INT 36
40629: NONEQUAL
40630: PUSH
40631: LD_VAR 0 3
40635: PPUSH
40636: CALL 84411 0 1
40640: NOT
40641: AND
40642: OR
40643: IFFALSE 40779
// begin if IsInUnit ( j ) then
40645: LD_VAR 0 3
40649: PPUSH
40650: CALL_OW 310
40654: IFFALSE 40665
// ComExitBuilding ( j ) ;
40656: LD_VAR 0 3
40660: PPUSH
40661: CALL_OW 122
// ct := 0 ;
40665: LD_ADDR_VAR 0 8
40669: PUSH
40670: LD_INT 0
40672: ST_TO_ADDR
// for k in x do
40673: LD_ADDR_VAR 0 4
40677: PUSH
40678: LD_VAR 0 11
40682: PUSH
40683: FOR_IN
40684: IFFALSE 40757
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40686: LD_VAR 0 4
40690: PPUSH
40691: CALL_OW 264
40695: PUSH
40696: LD_INT 31
40698: EQUAL
40699: PUSH
40700: LD_VAR 0 4
40704: PPUSH
40705: CALL_OW 311
40709: NOT
40710: AND
40711: PUSH
40712: LD_VAR 0 4
40716: PPUSH
40717: CALL_OW 266
40721: PUSH
40722: LD_INT 36
40724: EQUAL
40725: PUSH
40726: LD_VAR 0 4
40730: PPUSH
40731: CALL_OW 313
40735: PUSH
40736: LD_INT 3
40738: LESS
40739: AND
40740: OR
40741: IFFALSE 40755
// begin ct := k ;
40743: LD_ADDR_VAR 0 8
40747: PUSH
40748: LD_VAR 0 4
40752: ST_TO_ADDR
// break ;
40753: GO 40757
// end ;
40755: GO 40683
40757: POP
40758: POP
// if ct then
40759: LD_VAR 0 8
40763: IFFALSE 40779
// ComEnterUnit ( j , ct ) ;
40765: LD_VAR 0 3
40769: PPUSH
40770: LD_VAR 0 8
40774: PPUSH
40775: CALL_OW 120
// end ; end ;
40779: GO 40414
40781: POP
40782: POP
// places := 0 ;
40783: LD_ADDR_VAR 0 5
40787: PUSH
40788: LD_INT 0
40790: ST_TO_ADDR
// for j = 1 to x do
40791: LD_ADDR_VAR 0 3
40795: PUSH
40796: DOUBLE
40797: LD_INT 1
40799: DEC
40800: ST_TO_ADDR
40801: LD_VAR 0 11
40805: PUSH
40806: FOR_TO
40807: IFFALSE 40883
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40809: LD_VAR 0 11
40813: PUSH
40814: LD_VAR 0 3
40818: ARRAY
40819: PPUSH
40820: CALL_OW 264
40824: PUSH
40825: LD_INT 31
40827: EQUAL
40828: IFFALSE 40846
// places := places + 1 else
40830: LD_ADDR_VAR 0 5
40834: PUSH
40835: LD_VAR 0 5
40839: PUSH
40840: LD_INT 1
40842: PLUS
40843: ST_TO_ADDR
40844: GO 40881
// if GetBType ( x [ j ] ) = b_control_tower then
40846: LD_VAR 0 11
40850: PUSH
40851: LD_VAR 0 3
40855: ARRAY
40856: PPUSH
40857: CALL_OW 266
40861: PUSH
40862: LD_INT 36
40864: EQUAL
40865: IFFALSE 40881
// places := places + 3 ;
40867: LD_ADDR_VAR 0 5
40871: PUSH
40872: LD_VAR 0 5
40876: PUSH
40877: LD_INT 3
40879: PLUS
40880: ST_TO_ADDR
40881: GO 40806
40883: POP
40884: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40885: LD_VAR 0 5
40889: PUSH
40890: LD_INT 0
40892: EQUAL
40893: PUSH
40894: LD_VAR 0 5
40898: PUSH
40899: LD_EXP 90
40903: PUSH
40904: LD_VAR 0 2
40908: ARRAY
40909: LESSEQUAL
40910: OR
40911: IFFALSE 40915
// continue ;
40913: GO 40165
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40915: LD_ADDR_VAR 0 6
40919: PUSH
40920: LD_EXP 50
40924: PUSH
40925: LD_VAR 0 2
40929: ARRAY
40930: PPUSH
40931: LD_INT 25
40933: PUSH
40934: LD_INT 3
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PPUSH
40941: CALL_OW 72
40945: PUSH
40946: LD_EXP 90
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: DIFF
40957: PPUSH
40958: LD_INT 3
40960: PPUSH
40961: CALL 85311 0 2
40965: ST_TO_ADDR
// for j in tmp do
40966: LD_ADDR_VAR 0 3
40970: PUSH
40971: LD_VAR 0 6
40975: PUSH
40976: FOR_IN
40977: IFFALSE 41012
// if GetTag ( j ) > 0 then
40979: LD_VAR 0 3
40983: PPUSH
40984: CALL_OW 110
40988: PUSH
40989: LD_INT 0
40991: GREATER
40992: IFFALSE 41010
// tmp := tmp diff j ;
40994: LD_ADDR_VAR 0 6
40998: PUSH
40999: LD_VAR 0 6
41003: PUSH
41004: LD_VAR 0 3
41008: DIFF
41009: ST_TO_ADDR
41010: GO 40976
41012: POP
41013: POP
// if not tmp then
41014: LD_VAR 0 6
41018: NOT
41019: IFFALSE 41023
// continue ;
41021: GO 40165
// if places then
41023: LD_VAR 0 5
41027: IFFALSE 41086
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41029: LD_ADDR_EXP 90
41033: PUSH
41034: LD_EXP 90
41038: PPUSH
41039: LD_VAR 0 2
41043: PPUSH
41044: LD_EXP 90
41048: PUSH
41049: LD_VAR 0 2
41053: ARRAY
41054: PUSH
41055: LD_VAR 0 6
41059: PUSH
41060: LD_INT 1
41062: ARRAY
41063: UNION
41064: PPUSH
41065: CALL_OW 1
41069: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41070: LD_VAR 0 6
41074: PUSH
41075: LD_INT 1
41077: ARRAY
41078: PPUSH
41079: LD_INT 126
41081: PPUSH
41082: CALL_OW 109
// end ; end ;
41086: GO 40165
41088: POP
41089: POP
// end ;
41090: LD_VAR 0 1
41094: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41095: LD_INT 0
41097: PPUSH
41098: PPUSH
41099: PPUSH
41100: PPUSH
41101: PPUSH
41102: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41103: LD_VAR 0 1
41107: NOT
41108: PUSH
41109: LD_VAR 0 2
41113: NOT
41114: OR
41115: PUSH
41116: LD_VAR 0 3
41120: NOT
41121: OR
41122: PUSH
41123: LD_VAR 0 4
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: LD_INT 3
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: LD_INT 5
41142: PUSH
41143: LD_INT 8
41145: PUSH
41146: LD_INT 9
41148: PUSH
41149: LD_INT 15
41151: PUSH
41152: LD_INT 16
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: IN
41166: NOT
41167: OR
41168: IFFALSE 41172
// exit ;
41170: GO 42030
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41172: LD_ADDR_VAR 0 2
41176: PUSH
41177: LD_VAR 0 2
41181: PPUSH
41182: LD_INT 21
41184: PUSH
41185: LD_INT 3
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 24
41194: PUSH
41195: LD_INT 250
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PPUSH
41206: CALL_OW 72
41210: ST_TO_ADDR
// case class of 1 , 15 :
41211: LD_VAR 0 4
41215: PUSH
41216: LD_INT 1
41218: DOUBLE
41219: EQUAL
41220: IFTRUE 41230
41222: LD_INT 15
41224: DOUBLE
41225: EQUAL
41226: IFTRUE 41230
41228: GO 41315
41230: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41231: LD_ADDR_VAR 0 8
41235: PUSH
41236: LD_VAR 0 2
41240: PPUSH
41241: LD_INT 2
41243: PUSH
41244: LD_INT 30
41246: PUSH
41247: LD_INT 32
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 30
41256: PUSH
41257: LD_INT 31
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: LIST
41268: PPUSH
41269: CALL_OW 72
41273: PUSH
41274: LD_VAR 0 2
41278: PPUSH
41279: LD_INT 2
41281: PUSH
41282: LD_INT 30
41284: PUSH
41285: LD_INT 4
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 30
41294: PUSH
41295: LD_INT 5
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 72
41311: ADD
41312: ST_TO_ADDR
41313: GO 41561
41315: LD_INT 2
41317: DOUBLE
41318: EQUAL
41319: IFTRUE 41329
41321: LD_INT 16
41323: DOUBLE
41324: EQUAL
41325: IFTRUE 41329
41327: GO 41375
41329: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41330: LD_ADDR_VAR 0 8
41334: PUSH
41335: LD_VAR 0 2
41339: PPUSH
41340: LD_INT 2
41342: PUSH
41343: LD_INT 30
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 30
41355: PUSH
41356: LD_INT 1
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: LIST
41367: PPUSH
41368: CALL_OW 72
41372: ST_TO_ADDR
41373: GO 41561
41375: LD_INT 3
41377: DOUBLE
41378: EQUAL
41379: IFTRUE 41383
41381: GO 41429
41383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41384: LD_ADDR_VAR 0 8
41388: PUSH
41389: LD_VAR 0 2
41393: PPUSH
41394: LD_INT 2
41396: PUSH
41397: LD_INT 30
41399: PUSH
41400: LD_INT 2
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 3
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL_OW 72
41426: ST_TO_ADDR
41427: GO 41561
41429: LD_INT 4
41431: DOUBLE
41432: EQUAL
41433: IFTRUE 41437
41435: GO 41494
41437: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41438: LD_ADDR_VAR 0 8
41442: PUSH
41443: LD_VAR 0 2
41447: PPUSH
41448: LD_INT 2
41450: PUSH
41451: LD_INT 30
41453: PUSH
41454: LD_INT 6
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 30
41463: PUSH
41464: LD_INT 7
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 30
41473: PUSH
41474: LD_INT 8
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: PPUSH
41487: CALL_OW 72
41491: ST_TO_ADDR
41492: GO 41561
41494: LD_INT 5
41496: DOUBLE
41497: EQUAL
41498: IFTRUE 41514
41500: LD_INT 8
41502: DOUBLE
41503: EQUAL
41504: IFTRUE 41514
41506: LD_INT 9
41508: DOUBLE
41509: EQUAL
41510: IFTRUE 41514
41512: GO 41560
41514: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41515: LD_ADDR_VAR 0 8
41519: PUSH
41520: LD_VAR 0 2
41524: PPUSH
41525: LD_INT 2
41527: PUSH
41528: LD_INT 30
41530: PUSH
41531: LD_INT 4
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 30
41540: PUSH
41541: LD_INT 5
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: LIST
41552: PPUSH
41553: CALL_OW 72
41557: ST_TO_ADDR
41558: GO 41561
41560: POP
// if not tmp then
41561: LD_VAR 0 8
41565: NOT
41566: IFFALSE 41570
// exit ;
41568: GO 42030
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41570: LD_VAR 0 4
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: LD_INT 15
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: IN
41585: PUSH
41586: LD_EXP 59
41590: PUSH
41591: LD_VAR 0 1
41595: ARRAY
41596: AND
41597: IFFALSE 41753
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41599: LD_ADDR_VAR 0 9
41603: PUSH
41604: LD_EXP 59
41608: PUSH
41609: LD_VAR 0 1
41613: ARRAY
41614: PUSH
41615: LD_INT 1
41617: ARRAY
41618: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41619: LD_VAR 0 9
41623: PUSH
41624: LD_EXP 60
41628: PUSH
41629: LD_VAR 0 1
41633: ARRAY
41634: IN
41635: NOT
41636: IFFALSE 41751
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41638: LD_ADDR_EXP 60
41642: PUSH
41643: LD_EXP 60
41647: PPUSH
41648: LD_VAR 0 1
41652: PUSH
41653: LD_EXP 60
41657: PUSH
41658: LD_VAR 0 1
41662: ARRAY
41663: PUSH
41664: LD_INT 1
41666: PLUS
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PPUSH
41672: LD_VAR 0 9
41676: PPUSH
41677: CALL 54067 0 3
41681: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41682: LD_ADDR_EXP 59
41686: PUSH
41687: LD_EXP 59
41691: PPUSH
41692: LD_VAR 0 1
41696: PPUSH
41697: LD_EXP 59
41701: PUSH
41702: LD_VAR 0 1
41706: ARRAY
41707: PUSH
41708: LD_VAR 0 9
41712: DIFF
41713: PPUSH
41714: CALL_OW 1
41718: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41719: LD_VAR 0 3
41723: PPUSH
41724: LD_EXP 60
41728: PUSH
41729: LD_VAR 0 1
41733: ARRAY
41734: PUSH
41735: LD_EXP 60
41739: PUSH
41740: LD_VAR 0 1
41744: ARRAY
41745: ARRAY
41746: PPUSH
41747: CALL_OW 120
// end ; exit ;
41751: GO 42030
// end ; if tmp > 1 then
41753: LD_VAR 0 8
41757: PUSH
41758: LD_INT 1
41760: GREATER
41761: IFFALSE 41865
// for i = 2 to tmp do
41763: LD_ADDR_VAR 0 6
41767: PUSH
41768: DOUBLE
41769: LD_INT 2
41771: DEC
41772: ST_TO_ADDR
41773: LD_VAR 0 8
41777: PUSH
41778: FOR_TO
41779: IFFALSE 41863
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41781: LD_VAR 0 8
41785: PUSH
41786: LD_VAR 0 6
41790: ARRAY
41791: PPUSH
41792: CALL_OW 461
41796: PUSH
41797: LD_INT 6
41799: EQUAL
41800: IFFALSE 41861
// begin x := tmp [ i ] ;
41802: LD_ADDR_VAR 0 9
41806: PUSH
41807: LD_VAR 0 8
41811: PUSH
41812: LD_VAR 0 6
41816: ARRAY
41817: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41818: LD_ADDR_VAR 0 8
41822: PUSH
41823: LD_VAR 0 8
41827: PPUSH
41828: LD_VAR 0 6
41832: PPUSH
41833: CALL_OW 3
41837: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41838: LD_ADDR_VAR 0 8
41842: PUSH
41843: LD_VAR 0 8
41847: PPUSH
41848: LD_INT 1
41850: PPUSH
41851: LD_VAR 0 9
41855: PPUSH
41856: CALL_OW 2
41860: ST_TO_ADDR
// end ;
41861: GO 41778
41863: POP
41864: POP
// for i in tmp do
41865: LD_ADDR_VAR 0 6
41869: PUSH
41870: LD_VAR 0 8
41874: PUSH
41875: FOR_IN
41876: IFFALSE 41903
// begin if IsNotFull ( i ) then
41878: LD_VAR 0 6
41882: PPUSH
41883: CALL 51289 0 1
41887: IFFALSE 41901
// begin j := i ;
41889: LD_ADDR_VAR 0 7
41893: PUSH
41894: LD_VAR 0 6
41898: ST_TO_ADDR
// break ;
41899: GO 41903
// end ; end ;
41901: GO 41875
41903: POP
41904: POP
// if j then
41905: LD_VAR 0 7
41909: IFFALSE 41927
// ComEnterUnit ( unit , j ) else
41911: LD_VAR 0 3
41915: PPUSH
41916: LD_VAR 0 7
41920: PPUSH
41921: CALL_OW 120
41925: GO 42030
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41927: LD_ADDR_VAR 0 10
41931: PUSH
41932: LD_VAR 0 2
41936: PPUSH
41937: LD_INT 2
41939: PUSH
41940: LD_INT 30
41942: PUSH
41943: LD_INT 0
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: LD_INT 30
41952: PUSH
41953: LD_INT 1
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: LIST
41964: PPUSH
41965: CALL_OW 72
41969: ST_TO_ADDR
// if depot then
41970: LD_VAR 0 10
41974: IFFALSE 42030
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41976: LD_ADDR_VAR 0 10
41980: PUSH
41981: LD_VAR 0 10
41985: PPUSH
41986: LD_VAR 0 3
41990: PPUSH
41991: CALL_OW 74
41995: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41996: LD_VAR 0 3
42000: PPUSH
42001: LD_VAR 0 10
42005: PPUSH
42006: CALL_OW 296
42010: PUSH
42011: LD_INT 10
42013: GREATER
42014: IFFALSE 42030
// ComStandNearbyBuilding ( unit , depot ) ;
42016: LD_VAR 0 3
42020: PPUSH
42021: LD_VAR 0 10
42025: PPUSH
42026: CALL 50669 0 2
// end ; end ; end ;
42030: LD_VAR 0 5
42034: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42035: LD_INT 0
42037: PPUSH
42038: PPUSH
42039: PPUSH
42040: PPUSH
// if not mc_bases then
42041: LD_EXP 50
42045: NOT
42046: IFFALSE 42050
// exit ;
42048: GO 42289
// for i = 1 to mc_bases do
42050: LD_ADDR_VAR 0 2
42054: PUSH
42055: DOUBLE
42056: LD_INT 1
42058: DEC
42059: ST_TO_ADDR
42060: LD_EXP 50
42064: PUSH
42065: FOR_TO
42066: IFFALSE 42287
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42068: LD_ADDR_VAR 0 4
42072: PUSH
42073: LD_EXP 50
42077: PUSH
42078: LD_VAR 0 2
42082: ARRAY
42083: PPUSH
42084: LD_INT 21
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PPUSH
42094: CALL_OW 72
42098: PUSH
42099: LD_EXP 79
42103: PUSH
42104: LD_VAR 0 2
42108: ARRAY
42109: UNION
42110: ST_TO_ADDR
// if not tmp then
42111: LD_VAR 0 4
42115: NOT
42116: IFFALSE 42120
// continue ;
42118: GO 42065
// for j in tmp do
42120: LD_ADDR_VAR 0 3
42124: PUSH
42125: LD_VAR 0 4
42129: PUSH
42130: FOR_IN
42131: IFFALSE 42283
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42133: LD_VAR 0 3
42137: PPUSH
42138: CALL_OW 110
42142: NOT
42143: PUSH
42144: LD_VAR 0 3
42148: PPUSH
42149: CALL_OW 314
42153: NOT
42154: AND
42155: PUSH
42156: LD_VAR 0 3
42160: PPUSH
42161: CALL_OW 311
42165: NOT
42166: AND
42167: PUSH
42168: LD_VAR 0 3
42172: PPUSH
42173: CALL_OW 310
42177: NOT
42178: AND
42179: PUSH
42180: LD_VAR 0 3
42184: PUSH
42185: LD_EXP 53
42189: PUSH
42190: LD_VAR 0 2
42194: ARRAY
42195: PUSH
42196: LD_INT 1
42198: ARRAY
42199: IN
42200: NOT
42201: AND
42202: PUSH
42203: LD_VAR 0 3
42207: PUSH
42208: LD_EXP 53
42212: PUSH
42213: LD_VAR 0 2
42217: ARRAY
42218: PUSH
42219: LD_INT 2
42221: ARRAY
42222: IN
42223: NOT
42224: AND
42225: PUSH
42226: LD_VAR 0 3
42230: PUSH
42231: LD_EXP 62
42235: PUSH
42236: LD_VAR 0 2
42240: ARRAY
42241: IN
42242: NOT
42243: AND
42244: IFFALSE 42281
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42246: LD_VAR 0 2
42250: PPUSH
42251: LD_EXP 50
42255: PUSH
42256: LD_VAR 0 2
42260: ARRAY
42261: PPUSH
42262: LD_VAR 0 3
42266: PPUSH
42267: LD_VAR 0 3
42271: PPUSH
42272: CALL_OW 257
42276: PPUSH
42277: CALL 41095 0 4
// end ;
42281: GO 42130
42283: POP
42284: POP
// end ;
42285: GO 42065
42287: POP
42288: POP
// end ;
42289: LD_VAR 0 1
42293: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42294: LD_INT 0
42296: PPUSH
42297: PPUSH
42298: PPUSH
42299: PPUSH
42300: PPUSH
42301: PPUSH
// if not mc_bases [ base ] then
42302: LD_EXP 50
42306: PUSH
42307: LD_VAR 0 1
42311: ARRAY
42312: NOT
42313: IFFALSE 42317
// exit ;
42315: GO 42518
// tmp := [ ] ;
42317: LD_ADDR_VAR 0 6
42321: PUSH
42322: EMPTY
42323: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42324: LD_ADDR_VAR 0 7
42328: PUSH
42329: LD_VAR 0 3
42333: PPUSH
42334: LD_INT 0
42336: PPUSH
42337: CALL_OW 517
42341: ST_TO_ADDR
// if not list then
42342: LD_VAR 0 7
42346: NOT
42347: IFFALSE 42351
// exit ;
42349: GO 42518
// c := Count ( list [ 1 ] ) ;
42351: LD_ADDR_VAR 0 9
42355: PUSH
42356: LD_VAR 0 7
42360: PUSH
42361: LD_INT 1
42363: ARRAY
42364: PPUSH
42365: CALL 51207 0 1
42369: ST_TO_ADDR
// if amount > c then
42370: LD_VAR 0 2
42374: PUSH
42375: LD_VAR 0 9
42379: GREATER
42380: IFFALSE 42392
// amount := c ;
42382: LD_ADDR_VAR 0 2
42386: PUSH
42387: LD_VAR 0 9
42391: ST_TO_ADDR
// for i := 1 to amount do
42392: LD_ADDR_VAR 0 5
42396: PUSH
42397: DOUBLE
42398: LD_INT 1
42400: DEC
42401: ST_TO_ADDR
42402: LD_VAR 0 2
42406: PUSH
42407: FOR_TO
42408: IFFALSE 42466
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42410: LD_ADDR_VAR 0 6
42414: PUSH
42415: LD_VAR 0 6
42419: PPUSH
42420: LD_VAR 0 5
42424: PPUSH
42425: LD_VAR 0 7
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: PUSH
42434: LD_VAR 0 5
42438: ARRAY
42439: PUSH
42440: LD_VAR 0 7
42444: PUSH
42445: LD_INT 2
42447: ARRAY
42448: PUSH
42449: LD_VAR 0 5
42453: ARRAY
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PPUSH
42459: CALL_OW 1
42463: ST_TO_ADDR
42464: GO 42407
42466: POP
42467: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42468: LD_ADDR_EXP 63
42472: PUSH
42473: LD_EXP 63
42477: PPUSH
42478: LD_VAR 0 1
42482: PPUSH
42483: LD_VAR 0 6
42487: PPUSH
42488: CALL_OW 1
42492: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42493: LD_ADDR_EXP 65
42497: PUSH
42498: LD_EXP 65
42502: PPUSH
42503: LD_VAR 0 1
42507: PPUSH
42508: LD_VAR 0 3
42512: PPUSH
42513: CALL_OW 1
42517: ST_TO_ADDR
// end ;
42518: LD_VAR 0 4
42522: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42523: LD_INT 0
42525: PPUSH
// if not mc_bases [ base ] then
42526: LD_EXP 50
42530: PUSH
42531: LD_VAR 0 1
42535: ARRAY
42536: NOT
42537: IFFALSE 42541
// exit ;
42539: GO 42566
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42541: LD_ADDR_EXP 55
42545: PUSH
42546: LD_EXP 55
42550: PPUSH
42551: LD_VAR 0 1
42555: PPUSH
42556: LD_VAR 0 2
42560: PPUSH
42561: CALL_OW 1
42565: ST_TO_ADDR
// end ;
42566: LD_VAR 0 3
42570: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42571: LD_INT 0
42573: PPUSH
// if not mc_bases [ base ] then
42574: LD_EXP 50
42578: PUSH
42579: LD_VAR 0 1
42583: ARRAY
42584: NOT
42585: IFFALSE 42589
// exit ;
42587: GO 42626
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42589: LD_ADDR_EXP 55
42593: PUSH
42594: LD_EXP 55
42598: PPUSH
42599: LD_VAR 0 1
42603: PPUSH
42604: LD_EXP 55
42608: PUSH
42609: LD_VAR 0 1
42613: ARRAY
42614: PUSH
42615: LD_VAR 0 2
42619: UNION
42620: PPUSH
42621: CALL_OW 1
42625: ST_TO_ADDR
// end ;
42626: LD_VAR 0 3
42630: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42631: LD_INT 0
42633: PPUSH
// if not mc_bases [ base ] then
42634: LD_EXP 50
42638: PUSH
42639: LD_VAR 0 1
42643: ARRAY
42644: NOT
42645: IFFALSE 42649
// exit ;
42647: GO 42674
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42649: LD_ADDR_EXP 71
42653: PUSH
42654: LD_EXP 71
42658: PPUSH
42659: LD_VAR 0 1
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: CALL_OW 1
42673: ST_TO_ADDR
// end ;
42674: LD_VAR 0 3
42678: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42679: LD_INT 0
42681: PPUSH
// if not mc_bases [ base ] then
42682: LD_EXP 50
42686: PUSH
42687: LD_VAR 0 1
42691: ARRAY
42692: NOT
42693: IFFALSE 42697
// exit ;
42695: GO 42734
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42697: LD_ADDR_EXP 71
42701: PUSH
42702: LD_EXP 71
42706: PPUSH
42707: LD_VAR 0 1
42711: PPUSH
42712: LD_EXP 71
42716: PUSH
42717: LD_VAR 0 1
42721: ARRAY
42722: PUSH
42723: LD_VAR 0 2
42727: ADD
42728: PPUSH
42729: CALL_OW 1
42733: ST_TO_ADDR
// end ;
42734: LD_VAR 0 3
42738: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42739: LD_INT 0
42741: PPUSH
// if not mc_bases [ base ] then
42742: LD_EXP 50
42746: PUSH
42747: LD_VAR 0 1
42751: ARRAY
42752: NOT
42753: IFFALSE 42757
// exit ;
42755: GO 42811
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42757: LD_ADDR_EXP 72
42761: PUSH
42762: LD_EXP 72
42766: PPUSH
42767: LD_VAR 0 1
42771: PPUSH
42772: LD_VAR 0 2
42776: PPUSH
42777: CALL_OW 1
42781: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42782: LD_ADDR_EXP 61
42786: PUSH
42787: LD_EXP 61
42791: PPUSH
42792: LD_VAR 0 1
42796: PPUSH
42797: LD_VAR 0 2
42801: PUSH
42802: LD_INT 0
42804: PLUS
42805: PPUSH
42806: CALL_OW 1
42810: ST_TO_ADDR
// end ;
42811: LD_VAR 0 3
42815: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42816: LD_INT 0
42818: PPUSH
// if not mc_bases [ base ] then
42819: LD_EXP 50
42823: PUSH
42824: LD_VAR 0 1
42828: ARRAY
42829: NOT
42830: IFFALSE 42834
// exit ;
42832: GO 42859
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42834: LD_ADDR_EXP 61
42838: PUSH
42839: LD_EXP 61
42843: PPUSH
42844: LD_VAR 0 1
42848: PPUSH
42849: LD_VAR 0 2
42853: PPUSH
42854: CALL_OW 1
42858: ST_TO_ADDR
// end ;
42859: LD_VAR 0 3
42863: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42864: LD_INT 0
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
// if not mc_bases [ base ] then
42870: LD_EXP 50
42874: PUSH
42875: LD_VAR 0 1
42879: ARRAY
42880: NOT
42881: IFFALSE 42885
// exit ;
42883: GO 42950
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42885: LD_ADDR_EXP 70
42889: PUSH
42890: LD_EXP 70
42894: PPUSH
42895: LD_VAR 0 1
42899: PUSH
42900: LD_EXP 70
42904: PUSH
42905: LD_VAR 0 1
42909: ARRAY
42910: PUSH
42911: LD_INT 1
42913: PLUS
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PPUSH
42919: LD_VAR 0 1
42923: PUSH
42924: LD_VAR 0 2
42928: PUSH
42929: LD_VAR 0 3
42933: PUSH
42934: LD_VAR 0 4
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: PPUSH
42945: CALL 54067 0 3
42949: ST_TO_ADDR
// end ;
42950: LD_VAR 0 5
42954: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42955: LD_INT 0
42957: PPUSH
// if not mc_bases [ base ] then
42958: LD_EXP 50
42962: PUSH
42963: LD_VAR 0 1
42967: ARRAY
42968: NOT
42969: IFFALSE 42973
// exit ;
42971: GO 42998
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42973: LD_ADDR_EXP 87
42977: PUSH
42978: LD_EXP 87
42982: PPUSH
42983: LD_VAR 0 1
42987: PPUSH
42988: LD_VAR 0 2
42992: PPUSH
42993: CALL_OW 1
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MC_GetMinesField ( base ) ; begin
43003: LD_INT 0
43005: PPUSH
// result := mc_mines [ base ] ;
43006: LD_ADDR_VAR 0 2
43010: PUSH
43011: LD_EXP 63
43015: PUSH
43016: LD_VAR 0 1
43020: ARRAY
43021: ST_TO_ADDR
// end ;
43022: LD_VAR 0 2
43026: RET
// export function MC_GetProduceList ( base ) ; begin
43027: LD_INT 0
43029: PPUSH
// result := mc_produce [ base ] ;
43030: LD_ADDR_VAR 0 2
43034: PUSH
43035: LD_EXP 71
43039: PUSH
43040: LD_VAR 0 1
43044: ARRAY
43045: ST_TO_ADDR
// end ;
43046: LD_VAR 0 2
43050: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43051: LD_INT 0
43053: PPUSH
43054: PPUSH
// if not mc_bases then
43055: LD_EXP 50
43059: NOT
43060: IFFALSE 43064
// exit ;
43062: GO 43129
// if mc_bases [ base ] then
43064: LD_EXP 50
43068: PUSH
43069: LD_VAR 0 1
43073: ARRAY
43074: IFFALSE 43129
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43076: LD_ADDR_VAR 0 3
43080: PUSH
43081: LD_EXP 50
43085: PUSH
43086: LD_VAR 0 1
43090: ARRAY
43091: PPUSH
43092: LD_INT 30
43094: PUSH
43095: LD_VAR 0 2
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PPUSH
43104: CALL_OW 72
43108: ST_TO_ADDR
// if result then
43109: LD_VAR 0 3
43113: IFFALSE 43129
// result := result [ 1 ] ;
43115: LD_ADDR_VAR 0 3
43119: PUSH
43120: LD_VAR 0 3
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: ST_TO_ADDR
// end ; end ;
43129: LD_VAR 0 3
43133: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43134: LD_INT 0
43136: PPUSH
43137: PPUSH
// if not mc_bases then
43138: LD_EXP 50
43142: NOT
43143: IFFALSE 43147
// exit ;
43145: GO 43192
// if mc_bases [ base ] then
43147: LD_EXP 50
43151: PUSH
43152: LD_VAR 0 1
43156: ARRAY
43157: IFFALSE 43192
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43159: LD_ADDR_VAR 0 3
43163: PUSH
43164: LD_EXP 50
43168: PUSH
43169: LD_VAR 0 1
43173: ARRAY
43174: PPUSH
43175: LD_INT 30
43177: PUSH
43178: LD_VAR 0 2
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PPUSH
43187: CALL_OW 72
43191: ST_TO_ADDR
// end ;
43192: LD_VAR 0 3
43196: RET
// export function MC_SetTame ( base , area ) ; begin
43197: LD_INT 0
43199: PPUSH
// if not mc_bases or not base then
43200: LD_EXP 50
43204: NOT
43205: PUSH
43206: LD_VAR 0 1
43210: NOT
43211: OR
43212: IFFALSE 43216
// exit ;
43214: GO 43241
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43216: LD_ADDR_EXP 78
43220: PUSH
43221: LD_EXP 78
43225: PPUSH
43226: LD_VAR 0 1
43230: PPUSH
43231: LD_VAR 0 2
43235: PPUSH
43236: CALL_OW 1
43240: ST_TO_ADDR
// end ;
43241: LD_VAR 0 3
43245: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43246: LD_INT 0
43248: PPUSH
43249: PPUSH
// if not mc_bases or not base then
43250: LD_EXP 50
43254: NOT
43255: PUSH
43256: LD_VAR 0 1
43260: NOT
43261: OR
43262: IFFALSE 43266
// exit ;
43264: GO 43368
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43266: LD_ADDR_VAR 0 4
43270: PUSH
43271: LD_EXP 50
43275: PUSH
43276: LD_VAR 0 1
43280: ARRAY
43281: PPUSH
43282: LD_INT 30
43284: PUSH
43285: LD_VAR 0 2
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PPUSH
43294: CALL_OW 72
43298: ST_TO_ADDR
// if not tmp then
43299: LD_VAR 0 4
43303: NOT
43304: IFFALSE 43308
// exit ;
43306: GO 43368
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43308: LD_ADDR_EXP 82
43312: PUSH
43313: LD_EXP 82
43317: PPUSH
43318: LD_VAR 0 1
43322: PPUSH
43323: LD_EXP 82
43327: PUSH
43328: LD_VAR 0 1
43332: ARRAY
43333: PPUSH
43334: LD_EXP 82
43338: PUSH
43339: LD_VAR 0 1
43343: ARRAY
43344: PUSH
43345: LD_INT 1
43347: PLUS
43348: PPUSH
43349: LD_VAR 0 4
43353: PUSH
43354: LD_INT 1
43356: ARRAY
43357: PPUSH
43358: CALL_OW 2
43362: PPUSH
43363: CALL_OW 1
43367: ST_TO_ADDR
// end ;
43368: LD_VAR 0 3
43372: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43373: LD_INT 0
43375: PPUSH
43376: PPUSH
// if not mc_bases or not base or not kinds then
43377: LD_EXP 50
43381: NOT
43382: PUSH
43383: LD_VAR 0 1
43387: NOT
43388: OR
43389: PUSH
43390: LD_VAR 0 2
43394: NOT
43395: OR
43396: IFFALSE 43400
// exit ;
43398: GO 43461
// for i in kinds do
43400: LD_ADDR_VAR 0 4
43404: PUSH
43405: LD_VAR 0 2
43409: PUSH
43410: FOR_IN
43411: IFFALSE 43459
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43413: LD_ADDR_EXP 84
43417: PUSH
43418: LD_EXP 84
43422: PPUSH
43423: LD_VAR 0 1
43427: PUSH
43428: LD_EXP 84
43432: PUSH
43433: LD_VAR 0 1
43437: ARRAY
43438: PUSH
43439: LD_INT 1
43441: PLUS
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PPUSH
43447: LD_VAR 0 4
43451: PPUSH
43452: CALL 54067 0 3
43456: ST_TO_ADDR
43457: GO 43410
43459: POP
43460: POP
// end ;
43461: LD_VAR 0 3
43465: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43466: LD_INT 0
43468: PPUSH
// if not mc_bases or not base or not areas then
43469: LD_EXP 50
43473: NOT
43474: PUSH
43475: LD_VAR 0 1
43479: NOT
43480: OR
43481: PUSH
43482: LD_VAR 0 2
43486: NOT
43487: OR
43488: IFFALSE 43492
// exit ;
43490: GO 43517
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43492: LD_ADDR_EXP 68
43496: PUSH
43497: LD_EXP 68
43501: PPUSH
43502: LD_VAR 0 1
43506: PPUSH
43507: LD_VAR 0 2
43511: PPUSH
43512: CALL_OW 1
43516: ST_TO_ADDR
// end ;
43517: LD_VAR 0 3
43521: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43522: LD_INT 0
43524: PPUSH
// if not mc_bases or not base or not teleports_exit then
43525: LD_EXP 50
43529: NOT
43530: PUSH
43531: LD_VAR 0 1
43535: NOT
43536: OR
43537: PUSH
43538: LD_VAR 0 2
43542: NOT
43543: OR
43544: IFFALSE 43548
// exit ;
43546: GO 43573
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43548: LD_ADDR_EXP 85
43552: PUSH
43553: LD_EXP 85
43557: PPUSH
43558: LD_VAR 0 1
43562: PPUSH
43563: LD_VAR 0 2
43567: PPUSH
43568: CALL_OW 1
43572: ST_TO_ADDR
// end ;
43573: LD_VAR 0 3
43577: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43578: LD_INT 0
43580: PPUSH
43581: PPUSH
43582: PPUSH
// if not mc_bases or not base or not ext_list then
43583: LD_EXP 50
43587: NOT
43588: PUSH
43589: LD_VAR 0 1
43593: NOT
43594: OR
43595: PUSH
43596: LD_VAR 0 5
43600: NOT
43601: OR
43602: IFFALSE 43606
// exit ;
43604: GO 43779
// tmp := GetFacExtXYD ( x , y , d ) ;
43606: LD_ADDR_VAR 0 8
43610: PUSH
43611: LD_VAR 0 2
43615: PPUSH
43616: LD_VAR 0 3
43620: PPUSH
43621: LD_VAR 0 4
43625: PPUSH
43626: CALL 84441 0 3
43630: ST_TO_ADDR
// if not tmp then
43631: LD_VAR 0 8
43635: NOT
43636: IFFALSE 43640
// exit ;
43638: GO 43779
// for i in tmp do
43640: LD_ADDR_VAR 0 7
43644: PUSH
43645: LD_VAR 0 8
43649: PUSH
43650: FOR_IN
43651: IFFALSE 43777
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43653: LD_ADDR_EXP 55
43657: PUSH
43658: LD_EXP 55
43662: PPUSH
43663: LD_VAR 0 1
43667: PPUSH
43668: LD_EXP 55
43672: PUSH
43673: LD_VAR 0 1
43677: ARRAY
43678: PPUSH
43679: LD_EXP 55
43683: PUSH
43684: LD_VAR 0 1
43688: ARRAY
43689: PUSH
43690: LD_INT 1
43692: PLUS
43693: PPUSH
43694: LD_VAR 0 5
43698: PUSH
43699: LD_INT 1
43701: ARRAY
43702: PUSH
43703: LD_VAR 0 7
43707: PUSH
43708: LD_INT 1
43710: ARRAY
43711: PUSH
43712: LD_VAR 0 7
43716: PUSH
43717: LD_INT 2
43719: ARRAY
43720: PUSH
43721: LD_VAR 0 7
43725: PUSH
43726: LD_INT 3
43728: ARRAY
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: PPUSH
43736: CALL_OW 2
43740: PPUSH
43741: CALL_OW 1
43745: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43746: LD_ADDR_VAR 0 5
43750: PUSH
43751: LD_VAR 0 5
43755: PPUSH
43756: LD_INT 1
43758: PPUSH
43759: CALL_OW 3
43763: ST_TO_ADDR
// if not ext_list then
43764: LD_VAR 0 5
43768: NOT
43769: IFFALSE 43775
// exit ;
43771: POP
43772: POP
43773: GO 43779
// end ;
43775: GO 43650
43777: POP
43778: POP
// end ;
43779: LD_VAR 0 6
43783: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43784: LD_INT 0
43786: PPUSH
// if not mc_bases or not base or not weapon_list then
43787: LD_EXP 50
43791: NOT
43792: PUSH
43793: LD_VAR 0 1
43797: NOT
43798: OR
43799: PUSH
43800: LD_VAR 0 2
43804: NOT
43805: OR
43806: IFFALSE 43810
// exit ;
43808: GO 43835
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43810: LD_ADDR_EXP 89
43814: PUSH
43815: LD_EXP 89
43819: PPUSH
43820: LD_VAR 0 1
43824: PPUSH
43825: LD_VAR 0 2
43829: PPUSH
43830: CALL_OW 1
43834: ST_TO_ADDR
// end ;
43835: LD_VAR 0 3
43839: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43840: LD_INT 0
43842: PPUSH
// if not mc_bases or not base or not tech_list then
43843: LD_EXP 50
43847: NOT
43848: PUSH
43849: LD_VAR 0 1
43853: NOT
43854: OR
43855: PUSH
43856: LD_VAR 0 2
43860: NOT
43861: OR
43862: IFFALSE 43866
// exit ;
43864: GO 43891
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43866: LD_ADDR_EXP 77
43870: PUSH
43871: LD_EXP 77
43875: PPUSH
43876: LD_VAR 0 1
43880: PPUSH
43881: LD_VAR 0 2
43885: PPUSH
43886: CALL_OW 1
43890: ST_TO_ADDR
// end ;
43891: LD_VAR 0 3
43895: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43896: LD_INT 0
43898: PPUSH
// if not mc_bases or not parking_area or not base then
43899: LD_EXP 50
43903: NOT
43904: PUSH
43905: LD_VAR 0 2
43909: NOT
43910: OR
43911: PUSH
43912: LD_VAR 0 1
43916: NOT
43917: OR
43918: IFFALSE 43922
// exit ;
43920: GO 43947
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43922: LD_ADDR_EXP 74
43926: PUSH
43927: LD_EXP 74
43931: PPUSH
43932: LD_VAR 0 1
43936: PPUSH
43937: LD_VAR 0 2
43941: PPUSH
43942: CALL_OW 1
43946: ST_TO_ADDR
// end ;
43947: LD_VAR 0 3
43951: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43952: LD_INT 0
43954: PPUSH
// if not mc_bases or not base or not scan_area then
43955: LD_EXP 50
43959: NOT
43960: PUSH
43961: LD_VAR 0 1
43965: NOT
43966: OR
43967: PUSH
43968: LD_VAR 0 2
43972: NOT
43973: OR
43974: IFFALSE 43978
// exit ;
43976: GO 44003
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43978: LD_ADDR_EXP 75
43982: PUSH
43983: LD_EXP 75
43987: PPUSH
43988: LD_VAR 0 1
43992: PPUSH
43993: LD_VAR 0 2
43997: PPUSH
43998: CALL_OW 1
44002: ST_TO_ADDR
// end ;
44003: LD_VAR 0 3
44007: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
// if not mc_bases or not base then
44012: LD_EXP 50
44016: NOT
44017: PUSH
44018: LD_VAR 0 1
44022: NOT
44023: OR
44024: IFFALSE 44028
// exit ;
44026: GO 44092
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44028: LD_ADDR_VAR 0 3
44032: PUSH
44033: LD_INT 1
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 3
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: LD_INT 11
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: LIST
44054: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44055: LD_ADDR_EXP 77
44059: PUSH
44060: LD_EXP 77
44064: PPUSH
44065: LD_VAR 0 1
44069: PPUSH
44070: LD_EXP 77
44074: PUSH
44075: LD_VAR 0 1
44079: ARRAY
44080: PUSH
44081: LD_VAR 0 3
44085: DIFF
44086: PPUSH
44087: CALL_OW 1
44091: ST_TO_ADDR
// end ;
44092: LD_VAR 0 2
44096: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44097: LD_INT 0
44099: PPUSH
// result := mc_vehicles [ base ] ;
44100: LD_ADDR_VAR 0 3
44104: PUSH
44105: LD_EXP 69
44109: PUSH
44110: LD_VAR 0 1
44114: ARRAY
44115: ST_TO_ADDR
// if onlyCombat then
44116: LD_VAR 0 2
44120: IFFALSE 44292
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44122: LD_ADDR_VAR 0 3
44126: PUSH
44127: LD_VAR 0 3
44131: PUSH
44132: LD_VAR 0 3
44136: PPUSH
44137: LD_INT 2
44139: PUSH
44140: LD_INT 34
44142: PUSH
44143: LD_INT 12
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 34
44152: PUSH
44153: LD_INT 51
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 34
44162: PUSH
44163: LD_INT 89
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 34
44172: PUSH
44173: LD_INT 32
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 34
44182: PUSH
44183: LD_INT 13
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 34
44192: PUSH
44193: LD_INT 52
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 34
44202: PUSH
44203: LD_INT 88
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 34
44212: PUSH
44213: LD_INT 14
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 34
44222: PUSH
44223: LD_INT 53
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 34
44232: PUSH
44233: LD_INT 98
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 34
44242: PUSH
44243: LD_INT 31
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 34
44252: PUSH
44253: LD_INT 48
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 34
44262: PUSH
44263: LD_INT 8
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: PPUSH
44286: CALL_OW 72
44290: DIFF
44291: ST_TO_ADDR
// end ; end_of_file
44292: LD_VAR 0 3
44296: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44297: LD_INT 0
44299: PPUSH
44300: PPUSH
44301: PPUSH
// if not mc_bases or not skirmish then
44302: LD_EXP 50
44306: NOT
44307: PUSH
44308: LD_EXP 48
44312: NOT
44313: OR
44314: IFFALSE 44318
// exit ;
44316: GO 44483
// for i = 1 to mc_bases do
44318: LD_ADDR_VAR 0 4
44322: PUSH
44323: DOUBLE
44324: LD_INT 1
44326: DEC
44327: ST_TO_ADDR
44328: LD_EXP 50
44332: PUSH
44333: FOR_TO
44334: IFFALSE 44481
// begin if sci in mc_bases [ i ] then
44336: LD_VAR 0 2
44340: PUSH
44341: LD_EXP 50
44345: PUSH
44346: LD_VAR 0 4
44350: ARRAY
44351: IN
44352: IFFALSE 44479
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44354: LD_ADDR_EXP 79
44358: PUSH
44359: LD_EXP 79
44363: PPUSH
44364: LD_VAR 0 4
44368: PUSH
44369: LD_EXP 79
44373: PUSH
44374: LD_VAR 0 4
44378: ARRAY
44379: PUSH
44380: LD_INT 1
44382: PLUS
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PPUSH
44388: LD_VAR 0 1
44392: PPUSH
44393: CALL 54067 0 3
44397: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44398: LD_ADDR_VAR 0 5
44402: PUSH
44403: LD_EXP 50
44407: PUSH
44408: LD_VAR 0 4
44412: ARRAY
44413: PPUSH
44414: LD_INT 2
44416: PUSH
44417: LD_INT 30
44419: PUSH
44420: LD_INT 0
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 30
44429: PUSH
44430: LD_INT 1
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: LIST
44441: PPUSH
44442: CALL_OW 72
44446: PPUSH
44447: LD_VAR 0 1
44451: PPUSH
44452: CALL_OW 74
44456: ST_TO_ADDR
// if tmp then
44457: LD_VAR 0 5
44461: IFFALSE 44477
// ComStandNearbyBuilding ( ape , tmp ) ;
44463: LD_VAR 0 1
44467: PPUSH
44468: LD_VAR 0 5
44472: PPUSH
44473: CALL 50669 0 2
// break ;
44477: GO 44481
// end ; end ;
44479: GO 44333
44481: POP
44482: POP
// end ;
44483: LD_VAR 0 3
44487: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44488: LD_INT 0
44490: PPUSH
44491: PPUSH
44492: PPUSH
// if not mc_bases or not skirmish then
44493: LD_EXP 50
44497: NOT
44498: PUSH
44499: LD_EXP 48
44503: NOT
44504: OR
44505: IFFALSE 44509
// exit ;
44507: GO 44598
// for i = 1 to mc_bases do
44509: LD_ADDR_VAR 0 4
44513: PUSH
44514: DOUBLE
44515: LD_INT 1
44517: DEC
44518: ST_TO_ADDR
44519: LD_EXP 50
44523: PUSH
44524: FOR_TO
44525: IFFALSE 44596
// begin if building in mc_busy_turret_list [ i ] then
44527: LD_VAR 0 1
44531: PUSH
44532: LD_EXP 60
44536: PUSH
44537: LD_VAR 0 4
44541: ARRAY
44542: IN
44543: IFFALSE 44594
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44545: LD_ADDR_VAR 0 5
44549: PUSH
44550: LD_EXP 60
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: PUSH
44561: LD_VAR 0 1
44565: DIFF
44566: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44567: LD_ADDR_EXP 60
44571: PUSH
44572: LD_EXP 60
44576: PPUSH
44577: LD_VAR 0 4
44581: PPUSH
44582: LD_VAR 0 5
44586: PPUSH
44587: CALL_OW 1
44591: ST_TO_ADDR
// break ;
44592: GO 44596
// end ; end ;
44594: GO 44524
44596: POP
44597: POP
// end ;
44598: LD_VAR 0 3
44602: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44603: LD_INT 0
44605: PPUSH
44606: PPUSH
44607: PPUSH
// if not mc_bases or not skirmish then
44608: LD_EXP 50
44612: NOT
44613: PUSH
44614: LD_EXP 48
44618: NOT
44619: OR
44620: IFFALSE 44624
// exit ;
44622: GO 44823
// for i = 1 to mc_bases do
44624: LD_ADDR_VAR 0 5
44628: PUSH
44629: DOUBLE
44630: LD_INT 1
44632: DEC
44633: ST_TO_ADDR
44634: LD_EXP 50
44638: PUSH
44639: FOR_TO
44640: IFFALSE 44821
// if building in mc_bases [ i ] then
44642: LD_VAR 0 1
44646: PUSH
44647: LD_EXP 50
44651: PUSH
44652: LD_VAR 0 5
44656: ARRAY
44657: IN
44658: IFFALSE 44819
// begin tmp := mc_bases [ i ] diff building ;
44660: LD_ADDR_VAR 0 6
44664: PUSH
44665: LD_EXP 50
44669: PUSH
44670: LD_VAR 0 5
44674: ARRAY
44675: PUSH
44676: LD_VAR 0 1
44680: DIFF
44681: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44682: LD_ADDR_EXP 50
44686: PUSH
44687: LD_EXP 50
44691: PPUSH
44692: LD_VAR 0 5
44696: PPUSH
44697: LD_VAR 0 6
44701: PPUSH
44702: CALL_OW 1
44706: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44707: LD_VAR 0 1
44711: PUSH
44712: LD_EXP 58
44716: PUSH
44717: LD_VAR 0 5
44721: ARRAY
44722: IN
44723: IFFALSE 44762
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44725: LD_ADDR_EXP 58
44729: PUSH
44730: LD_EXP 58
44734: PPUSH
44735: LD_VAR 0 5
44739: PPUSH
44740: LD_EXP 58
44744: PUSH
44745: LD_VAR 0 5
44749: ARRAY
44750: PUSH
44751: LD_VAR 0 1
44755: DIFF
44756: PPUSH
44757: CALL_OW 1
44761: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44762: LD_VAR 0 1
44766: PUSH
44767: LD_EXP 59
44771: PUSH
44772: LD_VAR 0 5
44776: ARRAY
44777: IN
44778: IFFALSE 44817
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44780: LD_ADDR_EXP 59
44784: PUSH
44785: LD_EXP 59
44789: PPUSH
44790: LD_VAR 0 5
44794: PPUSH
44795: LD_EXP 59
44799: PUSH
44800: LD_VAR 0 5
44804: ARRAY
44805: PUSH
44806: LD_VAR 0 1
44810: DIFF
44811: PPUSH
44812: CALL_OW 1
44816: ST_TO_ADDR
// break ;
44817: GO 44821
// end ;
44819: GO 44639
44821: POP
44822: POP
// end ;
44823: LD_VAR 0 4
44827: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44828: LD_INT 0
44830: PPUSH
44831: PPUSH
44832: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44833: LD_EXP 50
44837: NOT
44838: PUSH
44839: LD_EXP 48
44843: NOT
44844: OR
44845: PUSH
44846: LD_VAR 0 3
44850: PUSH
44851: LD_EXP 76
44855: IN
44856: NOT
44857: OR
44858: IFFALSE 44862
// exit ;
44860: GO 44985
// for i = 1 to mc_vehicles do
44862: LD_ADDR_VAR 0 6
44866: PUSH
44867: DOUBLE
44868: LD_INT 1
44870: DEC
44871: ST_TO_ADDR
44872: LD_EXP 69
44876: PUSH
44877: FOR_TO
44878: IFFALSE 44983
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44880: LD_VAR 0 2
44884: PUSH
44885: LD_EXP 69
44889: PUSH
44890: LD_VAR 0 6
44894: ARRAY
44895: IN
44896: PUSH
44897: LD_VAR 0 1
44901: PUSH
44902: LD_EXP 69
44906: PUSH
44907: LD_VAR 0 6
44911: ARRAY
44912: IN
44913: OR
44914: IFFALSE 44981
// begin tmp := mc_vehicles [ i ] diff old ;
44916: LD_ADDR_VAR 0 7
44920: PUSH
44921: LD_EXP 69
44925: PUSH
44926: LD_VAR 0 6
44930: ARRAY
44931: PUSH
44932: LD_VAR 0 2
44936: DIFF
44937: ST_TO_ADDR
// tmp := tmp diff new ;
44938: LD_ADDR_VAR 0 7
44942: PUSH
44943: LD_VAR 0 7
44947: PUSH
44948: LD_VAR 0 1
44952: DIFF
44953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44954: LD_ADDR_EXP 69
44958: PUSH
44959: LD_EXP 69
44963: PPUSH
44964: LD_VAR 0 6
44968: PPUSH
44969: LD_VAR 0 7
44973: PPUSH
44974: CALL_OW 1
44978: ST_TO_ADDR
// break ;
44979: GO 44983
// end ;
44981: GO 44877
44983: POP
44984: POP
// end ;
44985: LD_VAR 0 5
44989: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44990: LD_INT 0
44992: PPUSH
44993: PPUSH
44994: PPUSH
44995: PPUSH
// if not mc_bases or not skirmish then
44996: LD_EXP 50
45000: NOT
45001: PUSH
45002: LD_EXP 48
45006: NOT
45007: OR
45008: IFFALSE 45012
// exit ;
45010: GO 45432
// repeat wait ( 0 0$1 ) ;
45012: LD_INT 35
45014: PPUSH
45015: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45019: LD_EXP 94
45023: NOT
45024: IFFALSE 45012
// mc_block_vehicle_constructed_thread := true ;
45026: LD_ADDR_EXP 94
45030: PUSH
45031: LD_INT 1
45033: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45034: LD_ADDR_VAR 0 5
45038: PUSH
45039: LD_VAR 0 1
45043: PPUSH
45044: CALL_OW 255
45048: ST_TO_ADDR
// for i = 1 to mc_bases do
45049: LD_ADDR_VAR 0 4
45053: PUSH
45054: DOUBLE
45055: LD_INT 1
45057: DEC
45058: ST_TO_ADDR
45059: LD_EXP 50
45063: PUSH
45064: FOR_TO
45065: IFFALSE 45422
// begin if factory in mc_bases [ i ] then
45067: LD_VAR 0 2
45071: PUSH
45072: LD_EXP 50
45076: PUSH
45077: LD_VAR 0 4
45081: ARRAY
45082: IN
45083: IFFALSE 45420
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45085: LD_EXP 72
45089: PUSH
45090: LD_VAR 0 4
45094: ARRAY
45095: PUSH
45096: LD_EXP 61
45100: PUSH
45101: LD_VAR 0 4
45105: ARRAY
45106: LESS
45107: PUSH
45108: LD_VAR 0 1
45112: PPUSH
45113: CALL_OW 264
45117: PUSH
45118: LD_INT 31
45120: PUSH
45121: LD_INT 32
45123: PUSH
45124: LD_INT 51
45126: PUSH
45127: LD_INT 89
45129: PUSH
45130: LD_INT 12
45132: PUSH
45133: LD_INT 30
45135: PUSH
45136: LD_INT 98
45138: PUSH
45139: LD_INT 11
45141: PUSH
45142: LD_INT 53
45144: PUSH
45145: LD_INT 14
45147: PUSH
45148: LD_INT 91
45150: PUSH
45151: LD_INT 29
45153: PUSH
45154: LD_INT 99
45156: PUSH
45157: LD_INT 13
45159: PUSH
45160: LD_INT 52
45162: PUSH
45163: LD_INT 88
45165: PUSH
45166: LD_INT 48
45168: PUSH
45169: LD_INT 8
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: IN
45192: NOT
45193: AND
45194: IFFALSE 45242
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45196: LD_ADDR_EXP 72
45200: PUSH
45201: LD_EXP 72
45205: PPUSH
45206: LD_VAR 0 4
45210: PUSH
45211: LD_EXP 72
45215: PUSH
45216: LD_VAR 0 4
45220: ARRAY
45221: PUSH
45222: LD_INT 1
45224: PLUS
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PPUSH
45230: LD_VAR 0 1
45234: PPUSH
45235: CALL 54067 0 3
45239: ST_TO_ADDR
45240: GO 45286
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45242: LD_ADDR_EXP 69
45246: PUSH
45247: LD_EXP 69
45251: PPUSH
45252: LD_VAR 0 4
45256: PUSH
45257: LD_EXP 69
45261: PUSH
45262: LD_VAR 0 4
45266: ARRAY
45267: PUSH
45268: LD_INT 1
45270: PLUS
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PPUSH
45276: LD_VAR 0 1
45280: PPUSH
45281: CALL 54067 0 3
45285: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45286: LD_ADDR_EXP 94
45290: PUSH
45291: LD_INT 0
45293: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45294: LD_VAR 0 1
45298: PPUSH
45299: CALL_OW 263
45303: PUSH
45304: LD_INT 2
45306: EQUAL
45307: IFFALSE 45336
// begin repeat wait ( 0 0$3 ) ;
45309: LD_INT 105
45311: PPUSH
45312: CALL_OW 67
// Connect ( vehicle ) ;
45316: LD_VAR 0 1
45320: PPUSH
45321: CALL 57413 0 1
// until IsControledBy ( vehicle ) ;
45325: LD_VAR 0 1
45329: PPUSH
45330: CALL_OW 312
45334: IFFALSE 45309
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45336: LD_VAR 0 1
45340: PPUSH
45341: LD_EXP 74
45345: PUSH
45346: LD_VAR 0 4
45350: ARRAY
45351: PPUSH
45352: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45356: LD_VAR 0 1
45360: PPUSH
45361: CALL_OW 263
45365: PUSH
45366: LD_INT 1
45368: NONEQUAL
45369: IFFALSE 45373
// break ;
45371: GO 45422
// repeat wait ( 0 0$1 ) ;
45373: LD_INT 35
45375: PPUSH
45376: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45380: LD_VAR 0 1
45384: PPUSH
45385: LD_EXP 74
45389: PUSH
45390: LD_VAR 0 4
45394: ARRAY
45395: PPUSH
45396: CALL_OW 308
45400: IFFALSE 45373
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45402: LD_VAR 0 1
45406: PPUSH
45407: CALL_OW 311
45411: PPUSH
45412: CALL_OW 121
// exit ;
45416: POP
45417: POP
45418: GO 45432
// end ; end ;
45420: GO 45064
45422: POP
45423: POP
// mc_block_vehicle_constructed_thread := false ;
45424: LD_ADDR_EXP 94
45428: PUSH
45429: LD_INT 0
45431: ST_TO_ADDR
// end ;
45432: LD_VAR 0 3
45436: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45437: LD_INT 0
45439: PPUSH
45440: PPUSH
45441: PPUSH
45442: PPUSH
// if not mc_bases or not skirmish then
45443: LD_EXP 50
45447: NOT
45448: PUSH
45449: LD_EXP 48
45453: NOT
45454: OR
45455: IFFALSE 45459
// exit ;
45457: GO 45812
// repeat wait ( 0 0$1 ) ;
45459: LD_INT 35
45461: PPUSH
45462: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45466: LD_VAR 0 2
45470: PPUSH
45471: LD_VAR 0 3
45475: PPUSH
45476: CALL_OW 284
45480: IFFALSE 45459
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45482: LD_VAR 0 2
45486: PPUSH
45487: LD_VAR 0 3
45491: PPUSH
45492: CALL_OW 283
45496: PUSH
45497: LD_INT 4
45499: EQUAL
45500: IFFALSE 45504
// exit ;
45502: GO 45812
// for i = 1 to mc_bases do
45504: LD_ADDR_VAR 0 7
45508: PUSH
45509: DOUBLE
45510: LD_INT 1
45512: DEC
45513: ST_TO_ADDR
45514: LD_EXP 50
45518: PUSH
45519: FOR_TO
45520: IFFALSE 45810
// begin if mc_crates_area [ i ] then
45522: LD_EXP 68
45526: PUSH
45527: LD_VAR 0 7
45531: ARRAY
45532: IFFALSE 45643
// for j in mc_crates_area [ i ] do
45534: LD_ADDR_VAR 0 8
45538: PUSH
45539: LD_EXP 68
45543: PUSH
45544: LD_VAR 0 7
45548: ARRAY
45549: PUSH
45550: FOR_IN
45551: IFFALSE 45641
// if InArea ( x , y , j ) then
45553: LD_VAR 0 2
45557: PPUSH
45558: LD_VAR 0 3
45562: PPUSH
45563: LD_VAR 0 8
45567: PPUSH
45568: CALL_OW 309
45572: IFFALSE 45639
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45574: LD_ADDR_EXP 66
45578: PUSH
45579: LD_EXP 66
45583: PPUSH
45584: LD_VAR 0 7
45588: PUSH
45589: LD_EXP 66
45593: PUSH
45594: LD_VAR 0 7
45598: ARRAY
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PPUSH
45608: LD_VAR 0 4
45612: PUSH
45613: LD_VAR 0 2
45617: PUSH
45618: LD_VAR 0 3
45622: PUSH
45623: EMPTY
45624: LIST
45625: LIST
45626: LIST
45627: PPUSH
45628: CALL 54067 0 3
45632: ST_TO_ADDR
// exit ;
45633: POP
45634: POP
45635: POP
45636: POP
45637: GO 45812
// end ;
45639: GO 45550
45641: POP
45642: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45643: LD_ADDR_VAR 0 9
45647: PUSH
45648: LD_EXP 50
45652: PUSH
45653: LD_VAR 0 7
45657: ARRAY
45658: PPUSH
45659: LD_INT 2
45661: PUSH
45662: LD_INT 30
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 30
45674: PUSH
45675: LD_INT 1
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: LIST
45686: PPUSH
45687: CALL_OW 72
45691: ST_TO_ADDR
// if not depot then
45692: LD_VAR 0 9
45696: NOT
45697: IFFALSE 45701
// continue ;
45699: GO 45519
// for j in depot do
45701: LD_ADDR_VAR 0 8
45705: PUSH
45706: LD_VAR 0 9
45710: PUSH
45711: FOR_IN
45712: IFFALSE 45806
// if GetDistUnitXY ( j , x , y ) < 30 then
45714: LD_VAR 0 8
45718: PPUSH
45719: LD_VAR 0 2
45723: PPUSH
45724: LD_VAR 0 3
45728: PPUSH
45729: CALL_OW 297
45733: PUSH
45734: LD_INT 30
45736: LESS
45737: IFFALSE 45804
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45739: LD_ADDR_EXP 66
45743: PUSH
45744: LD_EXP 66
45748: PPUSH
45749: LD_VAR 0 7
45753: PUSH
45754: LD_EXP 66
45758: PUSH
45759: LD_VAR 0 7
45763: ARRAY
45764: PUSH
45765: LD_INT 1
45767: PLUS
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PPUSH
45773: LD_VAR 0 4
45777: PUSH
45778: LD_VAR 0 2
45782: PUSH
45783: LD_VAR 0 3
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: LIST
45792: PPUSH
45793: CALL 54067 0 3
45797: ST_TO_ADDR
// exit ;
45798: POP
45799: POP
45800: POP
45801: POP
45802: GO 45812
// end ;
45804: GO 45711
45806: POP
45807: POP
// end ;
45808: GO 45519
45810: POP
45811: POP
// end ;
45812: LD_VAR 0 6
45816: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45817: LD_INT 0
45819: PPUSH
45820: PPUSH
45821: PPUSH
45822: PPUSH
// if not mc_bases or not skirmish then
45823: LD_EXP 50
45827: NOT
45828: PUSH
45829: LD_EXP 48
45833: NOT
45834: OR
45835: IFFALSE 45839
// exit ;
45837: GO 46116
// side := GetSide ( lab ) ;
45839: LD_ADDR_VAR 0 4
45843: PUSH
45844: LD_VAR 0 2
45848: PPUSH
45849: CALL_OW 255
45853: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45854: LD_VAR 0 4
45858: PUSH
45859: LD_EXP 76
45863: IN
45864: NOT
45865: PUSH
45866: LD_EXP 77
45870: NOT
45871: OR
45872: PUSH
45873: LD_EXP 50
45877: NOT
45878: OR
45879: IFFALSE 45883
// exit ;
45881: GO 46116
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45883: LD_ADDR_EXP 77
45887: PUSH
45888: LD_EXP 77
45892: PPUSH
45893: LD_VAR 0 4
45897: PPUSH
45898: LD_EXP 77
45902: PUSH
45903: LD_VAR 0 4
45907: ARRAY
45908: PUSH
45909: LD_VAR 0 1
45913: DIFF
45914: PPUSH
45915: CALL_OW 1
45919: ST_TO_ADDR
// for i = 1 to mc_bases do
45920: LD_ADDR_VAR 0 5
45924: PUSH
45925: DOUBLE
45926: LD_INT 1
45928: DEC
45929: ST_TO_ADDR
45930: LD_EXP 50
45934: PUSH
45935: FOR_TO
45936: IFFALSE 46114
// begin if lab in mc_bases [ i ] then
45938: LD_VAR 0 2
45942: PUSH
45943: LD_EXP 50
45947: PUSH
45948: LD_VAR 0 5
45952: ARRAY
45953: IN
45954: IFFALSE 46112
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45956: LD_VAR 0 1
45960: PUSH
45961: LD_INT 11
45963: PUSH
45964: LD_INT 4
45966: PUSH
45967: LD_INT 3
45969: PUSH
45970: LD_INT 2
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: IN
45979: PUSH
45980: LD_EXP 80
45984: PUSH
45985: LD_VAR 0 5
45989: ARRAY
45990: AND
45991: IFFALSE 46112
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45993: LD_ADDR_VAR 0 6
45997: PUSH
45998: LD_EXP 80
46002: PUSH
46003: LD_VAR 0 5
46007: ARRAY
46008: PUSH
46009: LD_INT 1
46011: ARRAY
46012: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46013: LD_ADDR_EXP 80
46017: PUSH
46018: LD_EXP 80
46022: PPUSH
46023: LD_VAR 0 5
46027: PPUSH
46028: EMPTY
46029: PPUSH
46030: CALL_OW 1
46034: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46035: LD_VAR 0 6
46039: PPUSH
46040: LD_INT 0
46042: PPUSH
46043: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46047: LD_VAR 0 6
46051: PPUSH
46052: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46056: LD_ADDR_EXP 79
46060: PUSH
46061: LD_EXP 79
46065: PPUSH
46066: LD_VAR 0 5
46070: PPUSH
46071: LD_EXP 79
46075: PUSH
46076: LD_VAR 0 5
46080: ARRAY
46081: PPUSH
46082: LD_INT 1
46084: PPUSH
46085: LD_VAR 0 6
46089: PPUSH
46090: CALL_OW 2
46094: PPUSH
46095: CALL_OW 1
46099: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46100: LD_VAR 0 5
46104: PPUSH
46105: LD_INT 112
46107: PPUSH
46108: CALL 22566 0 2
// end ; end ; end ;
46112: GO 45935
46114: POP
46115: POP
// end ;
46116: LD_VAR 0 3
46120: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46121: LD_INT 0
46123: PPUSH
46124: PPUSH
46125: PPUSH
46126: PPUSH
46127: PPUSH
46128: PPUSH
46129: PPUSH
46130: PPUSH
// if not mc_bases or not skirmish then
46131: LD_EXP 50
46135: NOT
46136: PUSH
46137: LD_EXP 48
46141: NOT
46142: OR
46143: IFFALSE 46147
// exit ;
46145: GO 47516
// for i = 1 to mc_bases do
46147: LD_ADDR_VAR 0 3
46151: PUSH
46152: DOUBLE
46153: LD_INT 1
46155: DEC
46156: ST_TO_ADDR
46157: LD_EXP 50
46161: PUSH
46162: FOR_TO
46163: IFFALSE 47514
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46165: LD_VAR 0 1
46169: PUSH
46170: LD_EXP 50
46174: PUSH
46175: LD_VAR 0 3
46179: ARRAY
46180: IN
46181: PUSH
46182: LD_VAR 0 1
46186: PUSH
46187: LD_EXP 57
46191: PUSH
46192: LD_VAR 0 3
46196: ARRAY
46197: IN
46198: OR
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_EXP 72
46209: PUSH
46210: LD_VAR 0 3
46214: ARRAY
46215: IN
46216: OR
46217: PUSH
46218: LD_VAR 0 1
46222: PUSH
46223: LD_EXP 69
46227: PUSH
46228: LD_VAR 0 3
46232: ARRAY
46233: IN
46234: OR
46235: PUSH
46236: LD_VAR 0 1
46240: PUSH
46241: LD_EXP 79
46245: PUSH
46246: LD_VAR 0 3
46250: ARRAY
46251: IN
46252: OR
46253: PUSH
46254: LD_VAR 0 1
46258: PUSH
46259: LD_EXP 80
46263: PUSH
46264: LD_VAR 0 3
46268: ARRAY
46269: IN
46270: OR
46271: IFFALSE 47512
// begin if un in mc_ape [ i ] then
46273: LD_VAR 0 1
46277: PUSH
46278: LD_EXP 79
46282: PUSH
46283: LD_VAR 0 3
46287: ARRAY
46288: IN
46289: IFFALSE 46328
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46291: LD_ADDR_EXP 79
46295: PUSH
46296: LD_EXP 79
46300: PPUSH
46301: LD_VAR 0 3
46305: PPUSH
46306: LD_EXP 79
46310: PUSH
46311: LD_VAR 0 3
46315: ARRAY
46316: PUSH
46317: LD_VAR 0 1
46321: DIFF
46322: PPUSH
46323: CALL_OW 1
46327: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46328: LD_VAR 0 1
46332: PUSH
46333: LD_EXP 80
46337: PUSH
46338: LD_VAR 0 3
46342: ARRAY
46343: IN
46344: IFFALSE 46368
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46346: LD_ADDR_EXP 80
46350: PUSH
46351: LD_EXP 80
46355: PPUSH
46356: LD_VAR 0 3
46360: PPUSH
46361: EMPTY
46362: PPUSH
46363: CALL_OW 1
46367: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL_OW 247
46377: PUSH
46378: LD_INT 2
46380: EQUAL
46381: PUSH
46382: LD_VAR 0 1
46386: PPUSH
46387: CALL_OW 110
46391: PUSH
46392: LD_INT 20
46394: EQUAL
46395: PUSH
46396: LD_VAR 0 1
46400: PUSH
46401: LD_EXP 72
46405: PUSH
46406: LD_VAR 0 3
46410: ARRAY
46411: IN
46412: OR
46413: PUSH
46414: LD_VAR 0 1
46418: PPUSH
46419: CALL_OW 264
46423: PUSH
46424: LD_INT 12
46426: PUSH
46427: LD_INT 51
46429: PUSH
46430: LD_INT 89
46432: PUSH
46433: LD_INT 32
46435: PUSH
46436: LD_INT 13
46438: PUSH
46439: LD_INT 52
46441: PUSH
46442: LD_INT 31
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: IN
46454: OR
46455: AND
46456: IFFALSE 46764
// begin if un in mc_defender [ i ] then
46458: LD_VAR 0 1
46462: PUSH
46463: LD_EXP 72
46467: PUSH
46468: LD_VAR 0 3
46472: ARRAY
46473: IN
46474: IFFALSE 46513
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46476: LD_ADDR_EXP 72
46480: PUSH
46481: LD_EXP 72
46485: PPUSH
46486: LD_VAR 0 3
46490: PPUSH
46491: LD_EXP 72
46495: PUSH
46496: LD_VAR 0 3
46500: ARRAY
46501: PUSH
46502: LD_VAR 0 1
46506: DIFF
46507: PPUSH
46508: CALL_OW 1
46512: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46513: LD_ADDR_VAR 0 8
46517: PUSH
46518: LD_VAR 0 3
46522: PPUSH
46523: LD_INT 3
46525: PPUSH
46526: CALL 43134 0 2
46530: ST_TO_ADDR
// if fac then
46531: LD_VAR 0 8
46535: IFFALSE 46764
// begin for j in fac do
46537: LD_ADDR_VAR 0 4
46541: PUSH
46542: LD_VAR 0 8
46546: PUSH
46547: FOR_IN
46548: IFFALSE 46762
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46550: LD_ADDR_VAR 0 9
46554: PUSH
46555: LD_VAR 0 8
46559: PPUSH
46560: LD_VAR 0 1
46564: PPUSH
46565: CALL_OW 265
46569: PPUSH
46570: LD_VAR 0 1
46574: PPUSH
46575: CALL_OW 262
46579: PPUSH
46580: LD_VAR 0 1
46584: PPUSH
46585: CALL_OW 263
46589: PPUSH
46590: LD_VAR 0 1
46594: PPUSH
46595: CALL_OW 264
46599: PPUSH
46600: CALL 51565 0 5
46604: ST_TO_ADDR
// if components then
46605: LD_VAR 0 9
46609: IFFALSE 46760
// begin if GetWeapon ( un ) = ar_control_tower then
46611: LD_VAR 0 1
46615: PPUSH
46616: CALL_OW 264
46620: PUSH
46621: LD_INT 31
46623: EQUAL
46624: IFFALSE 46741
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46626: LD_VAR 0 1
46630: PPUSH
46631: CALL_OW 311
46635: PPUSH
46636: LD_INT 0
46638: PPUSH
46639: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46643: LD_ADDR_EXP 90
46647: PUSH
46648: LD_EXP 90
46652: PPUSH
46653: LD_VAR 0 3
46657: PPUSH
46658: LD_EXP 90
46662: PUSH
46663: LD_VAR 0 3
46667: ARRAY
46668: PUSH
46669: LD_VAR 0 1
46673: PPUSH
46674: CALL_OW 311
46678: DIFF
46679: PPUSH
46680: CALL_OW 1
46684: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46685: LD_ADDR_VAR 0 7
46689: PUSH
46690: LD_EXP 71
46694: PUSH
46695: LD_VAR 0 3
46699: ARRAY
46700: PPUSH
46701: LD_INT 1
46703: PPUSH
46704: LD_VAR 0 9
46708: PPUSH
46709: CALL_OW 2
46713: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46714: LD_ADDR_EXP 71
46718: PUSH
46719: LD_EXP 71
46723: PPUSH
46724: LD_VAR 0 3
46728: PPUSH
46729: LD_VAR 0 7
46733: PPUSH
46734: CALL_OW 1
46738: ST_TO_ADDR
// end else
46739: GO 46758
// MC_InsertProduceList ( i , [ components ] ) ;
46741: LD_VAR 0 3
46745: PPUSH
46746: LD_VAR 0 9
46750: PUSH
46751: EMPTY
46752: LIST
46753: PPUSH
46754: CALL 42679 0 2
// break ;
46758: GO 46762
// end ; end ;
46760: GO 46547
46762: POP
46763: POP
// end ; end ; if GetType ( un ) = unit_building then
46764: LD_VAR 0 1
46768: PPUSH
46769: CALL_OW 247
46773: PUSH
46774: LD_INT 3
46776: EQUAL
46777: IFFALSE 47180
// begin btype := GetBType ( un ) ;
46779: LD_ADDR_VAR 0 5
46783: PUSH
46784: LD_VAR 0 1
46788: PPUSH
46789: CALL_OW 266
46793: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46794: LD_VAR 0 5
46798: PUSH
46799: LD_INT 29
46801: PUSH
46802: LD_INT 30
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: IN
46809: IFFALSE 46882
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46811: LD_VAR 0 1
46815: PPUSH
46816: CALL_OW 250
46820: PPUSH
46821: LD_VAR 0 1
46825: PPUSH
46826: CALL_OW 251
46830: PPUSH
46831: LD_VAR 0 1
46835: PPUSH
46836: CALL_OW 255
46840: PPUSH
46841: CALL_OW 440
46845: NOT
46846: IFFALSE 46882
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46848: LD_VAR 0 1
46852: PPUSH
46853: CALL_OW 250
46857: PPUSH
46858: LD_VAR 0 1
46862: PPUSH
46863: CALL_OW 251
46867: PPUSH
46868: LD_VAR 0 1
46872: PPUSH
46873: CALL_OW 255
46877: PPUSH
46878: CALL_OW 441
// end ; if btype = b_warehouse then
46882: LD_VAR 0 5
46886: PUSH
46887: LD_INT 1
46889: EQUAL
46890: IFFALSE 46908
// begin btype := b_depot ;
46892: LD_ADDR_VAR 0 5
46896: PUSH
46897: LD_INT 0
46899: ST_TO_ADDR
// pos := 1 ;
46900: LD_ADDR_VAR 0 6
46904: PUSH
46905: LD_INT 1
46907: ST_TO_ADDR
// end ; if btype = b_factory then
46908: LD_VAR 0 5
46912: PUSH
46913: LD_INT 3
46915: EQUAL
46916: IFFALSE 46934
// begin btype := b_workshop ;
46918: LD_ADDR_VAR 0 5
46922: PUSH
46923: LD_INT 2
46925: ST_TO_ADDR
// pos := 1 ;
46926: LD_ADDR_VAR 0 6
46930: PUSH
46931: LD_INT 1
46933: ST_TO_ADDR
// end ; if btype = b_barracks then
46934: LD_VAR 0 5
46938: PUSH
46939: LD_INT 5
46941: EQUAL
46942: IFFALSE 46952
// btype := b_armoury ;
46944: LD_ADDR_VAR 0 5
46948: PUSH
46949: LD_INT 4
46951: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46952: LD_VAR 0 5
46956: PUSH
46957: LD_INT 7
46959: PUSH
46960: LD_INT 8
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: IN
46967: IFFALSE 46977
// btype := b_lab ;
46969: LD_ADDR_VAR 0 5
46973: PUSH
46974: LD_INT 6
46976: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46977: LD_ADDR_EXP 55
46981: PUSH
46982: LD_EXP 55
46986: PPUSH
46987: LD_VAR 0 3
46991: PUSH
46992: LD_EXP 55
46996: PUSH
46997: LD_VAR 0 3
47001: ARRAY
47002: PUSH
47003: LD_INT 1
47005: PLUS
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PPUSH
47011: LD_VAR 0 5
47015: PUSH
47016: LD_VAR 0 1
47020: PPUSH
47021: CALL_OW 250
47025: PUSH
47026: LD_VAR 0 1
47030: PPUSH
47031: CALL_OW 251
47035: PUSH
47036: LD_VAR 0 1
47040: PPUSH
47041: CALL_OW 254
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: PPUSH
47052: CALL 54067 0 3
47056: ST_TO_ADDR
// if pos = 1 then
47057: LD_VAR 0 6
47061: PUSH
47062: LD_INT 1
47064: EQUAL
47065: IFFALSE 47180
// begin tmp := mc_build_list [ i ] ;
47067: LD_ADDR_VAR 0 7
47071: PUSH
47072: LD_EXP 55
47076: PUSH
47077: LD_VAR 0 3
47081: ARRAY
47082: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47083: LD_VAR 0 7
47087: PPUSH
47088: LD_INT 2
47090: PUSH
47091: LD_INT 30
47093: PUSH
47094: LD_INT 0
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 30
47103: PUSH
47104: LD_INT 1
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: PPUSH
47116: CALL_OW 72
47120: IFFALSE 47130
// pos := 2 ;
47122: LD_ADDR_VAR 0 6
47126: PUSH
47127: LD_INT 2
47129: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47130: LD_ADDR_VAR 0 7
47134: PUSH
47135: LD_VAR 0 7
47139: PPUSH
47140: LD_VAR 0 6
47144: PPUSH
47145: LD_VAR 0 7
47149: PPUSH
47150: CALL 54393 0 3
47154: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47155: LD_ADDR_EXP 55
47159: PUSH
47160: LD_EXP 55
47164: PPUSH
47165: LD_VAR 0 3
47169: PPUSH
47170: LD_VAR 0 7
47174: PPUSH
47175: CALL_OW 1
47179: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 50
47189: PUSH
47190: LD_VAR 0 3
47194: ARRAY
47195: IN
47196: IFFALSE 47235
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47198: LD_ADDR_EXP 50
47202: PUSH
47203: LD_EXP 50
47207: PPUSH
47208: LD_VAR 0 3
47212: PPUSH
47213: LD_EXP 50
47217: PUSH
47218: LD_VAR 0 3
47222: ARRAY
47223: PUSH
47224: LD_VAR 0 1
47228: DIFF
47229: PPUSH
47230: CALL_OW 1
47234: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47235: LD_VAR 0 1
47239: PUSH
47240: LD_EXP 57
47244: PUSH
47245: LD_VAR 0 3
47249: ARRAY
47250: IN
47251: IFFALSE 47290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47253: LD_ADDR_EXP 57
47257: PUSH
47258: LD_EXP 57
47262: PPUSH
47263: LD_VAR 0 3
47267: PPUSH
47268: LD_EXP 57
47272: PUSH
47273: LD_VAR 0 3
47277: ARRAY
47278: PUSH
47279: LD_VAR 0 1
47283: DIFF
47284: PPUSH
47285: CALL_OW 1
47289: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47290: LD_VAR 0 1
47294: PUSH
47295: LD_EXP 69
47299: PUSH
47300: LD_VAR 0 3
47304: ARRAY
47305: IN
47306: IFFALSE 47345
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47308: LD_ADDR_EXP 69
47312: PUSH
47313: LD_EXP 69
47317: PPUSH
47318: LD_VAR 0 3
47322: PPUSH
47323: LD_EXP 69
47327: PUSH
47328: LD_VAR 0 3
47332: ARRAY
47333: PUSH
47334: LD_VAR 0 1
47338: DIFF
47339: PPUSH
47340: CALL_OW 1
47344: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47345: LD_VAR 0 1
47349: PUSH
47350: LD_EXP 72
47354: PUSH
47355: LD_VAR 0 3
47359: ARRAY
47360: IN
47361: IFFALSE 47400
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47363: LD_ADDR_EXP 72
47367: PUSH
47368: LD_EXP 72
47372: PPUSH
47373: LD_VAR 0 3
47377: PPUSH
47378: LD_EXP 72
47382: PUSH
47383: LD_VAR 0 3
47387: ARRAY
47388: PUSH
47389: LD_VAR 0 1
47393: DIFF
47394: PPUSH
47395: CALL_OW 1
47399: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47400: LD_VAR 0 1
47404: PUSH
47405: LD_EXP 59
47409: PUSH
47410: LD_VAR 0 3
47414: ARRAY
47415: IN
47416: IFFALSE 47455
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47418: LD_ADDR_EXP 59
47422: PUSH
47423: LD_EXP 59
47427: PPUSH
47428: LD_VAR 0 3
47432: PPUSH
47433: LD_EXP 59
47437: PUSH
47438: LD_VAR 0 3
47442: ARRAY
47443: PUSH
47444: LD_VAR 0 1
47448: DIFF
47449: PPUSH
47450: CALL_OW 1
47454: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47455: LD_VAR 0 1
47459: PUSH
47460: LD_EXP 58
47464: PUSH
47465: LD_VAR 0 3
47469: ARRAY
47470: IN
47471: IFFALSE 47510
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47473: LD_ADDR_EXP 58
47477: PUSH
47478: LD_EXP 58
47482: PPUSH
47483: LD_VAR 0 3
47487: PPUSH
47488: LD_EXP 58
47492: PUSH
47493: LD_VAR 0 3
47497: ARRAY
47498: PUSH
47499: LD_VAR 0 1
47503: DIFF
47504: PPUSH
47505: CALL_OW 1
47509: ST_TO_ADDR
// end ; break ;
47510: GO 47514
// end ;
47512: GO 46162
47514: POP
47515: POP
// end ;
47516: LD_VAR 0 2
47520: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47521: LD_INT 0
47523: PPUSH
47524: PPUSH
47525: PPUSH
// if not mc_bases or not skirmish then
47526: LD_EXP 50
47530: NOT
47531: PUSH
47532: LD_EXP 48
47536: NOT
47537: OR
47538: IFFALSE 47542
// exit ;
47540: GO 47757
// for i = 1 to mc_bases do
47542: LD_ADDR_VAR 0 3
47546: PUSH
47547: DOUBLE
47548: LD_INT 1
47550: DEC
47551: ST_TO_ADDR
47552: LD_EXP 50
47556: PUSH
47557: FOR_TO
47558: IFFALSE 47755
// begin if building in mc_construct_list [ i ] then
47560: LD_VAR 0 1
47564: PUSH
47565: LD_EXP 57
47569: PUSH
47570: LD_VAR 0 3
47574: ARRAY
47575: IN
47576: IFFALSE 47753
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47578: LD_ADDR_EXP 57
47582: PUSH
47583: LD_EXP 57
47587: PPUSH
47588: LD_VAR 0 3
47592: PPUSH
47593: LD_EXP 57
47597: PUSH
47598: LD_VAR 0 3
47602: ARRAY
47603: PUSH
47604: LD_VAR 0 1
47608: DIFF
47609: PPUSH
47610: CALL_OW 1
47614: ST_TO_ADDR
// if building in mc_lab [ i ] then
47615: LD_VAR 0 1
47619: PUSH
47620: LD_EXP 83
47624: PUSH
47625: LD_VAR 0 3
47629: ARRAY
47630: IN
47631: IFFALSE 47686
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47633: LD_ADDR_EXP 84
47637: PUSH
47638: LD_EXP 84
47642: PPUSH
47643: LD_VAR 0 3
47647: PPUSH
47648: LD_EXP 84
47652: PUSH
47653: LD_VAR 0 3
47657: ARRAY
47658: PPUSH
47659: LD_INT 1
47661: PPUSH
47662: LD_EXP 84
47666: PUSH
47667: LD_VAR 0 3
47671: ARRAY
47672: PPUSH
47673: LD_INT 0
47675: PPUSH
47676: CALL 53485 0 4
47680: PPUSH
47681: CALL_OW 1
47685: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47686: LD_VAR 0 1
47690: PUSH
47691: LD_EXP 50
47695: PUSH
47696: LD_VAR 0 3
47700: ARRAY
47701: IN
47702: NOT
47703: IFFALSE 47749
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47705: LD_ADDR_EXP 50
47709: PUSH
47710: LD_EXP 50
47714: PPUSH
47715: LD_VAR 0 3
47719: PUSH
47720: LD_EXP 50
47724: PUSH
47725: LD_VAR 0 3
47729: ARRAY
47730: PUSH
47731: LD_INT 1
47733: PLUS
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PPUSH
47739: LD_VAR 0 1
47743: PPUSH
47744: CALL 54067 0 3
47748: ST_TO_ADDR
// exit ;
47749: POP
47750: POP
47751: GO 47757
// end ; end ;
47753: GO 47557
47755: POP
47756: POP
// end ;
47757: LD_VAR 0 2
47761: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47762: LD_INT 0
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
47768: PPUSH
47769: PPUSH
47770: PPUSH
// if not mc_bases or not skirmish then
47771: LD_EXP 50
47775: NOT
47776: PUSH
47777: LD_EXP 48
47781: NOT
47782: OR
47783: IFFALSE 47787
// exit ;
47785: GO 48448
// for i = 1 to mc_bases do
47787: LD_ADDR_VAR 0 3
47791: PUSH
47792: DOUBLE
47793: LD_INT 1
47795: DEC
47796: ST_TO_ADDR
47797: LD_EXP 50
47801: PUSH
47802: FOR_TO
47803: IFFALSE 48446
// begin if building in mc_construct_list [ i ] then
47805: LD_VAR 0 1
47809: PUSH
47810: LD_EXP 57
47814: PUSH
47815: LD_VAR 0 3
47819: ARRAY
47820: IN
47821: IFFALSE 48444
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47823: LD_ADDR_EXP 57
47827: PUSH
47828: LD_EXP 57
47832: PPUSH
47833: LD_VAR 0 3
47837: PPUSH
47838: LD_EXP 57
47842: PUSH
47843: LD_VAR 0 3
47847: ARRAY
47848: PUSH
47849: LD_VAR 0 1
47853: DIFF
47854: PPUSH
47855: CALL_OW 1
47859: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47860: LD_ADDR_EXP 50
47864: PUSH
47865: LD_EXP 50
47869: PPUSH
47870: LD_VAR 0 3
47874: PUSH
47875: LD_EXP 50
47879: PUSH
47880: LD_VAR 0 3
47884: ARRAY
47885: PUSH
47886: LD_INT 1
47888: PLUS
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PPUSH
47894: LD_VAR 0 1
47898: PPUSH
47899: CALL 54067 0 3
47903: ST_TO_ADDR
// btype := GetBType ( building ) ;
47904: LD_ADDR_VAR 0 5
47908: PUSH
47909: LD_VAR 0 1
47913: PPUSH
47914: CALL_OW 266
47918: ST_TO_ADDR
// side := GetSide ( building ) ;
47919: LD_ADDR_VAR 0 8
47923: PUSH
47924: LD_VAR 0 1
47928: PPUSH
47929: CALL_OW 255
47933: ST_TO_ADDR
// if btype = b_lab then
47934: LD_VAR 0 5
47938: PUSH
47939: LD_INT 6
47941: EQUAL
47942: IFFALSE 47992
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47944: LD_ADDR_EXP 83
47948: PUSH
47949: LD_EXP 83
47953: PPUSH
47954: LD_VAR 0 3
47958: PUSH
47959: LD_EXP 83
47963: PUSH
47964: LD_VAR 0 3
47968: ARRAY
47969: PUSH
47970: LD_INT 1
47972: PLUS
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PPUSH
47978: LD_VAR 0 1
47982: PPUSH
47983: CALL 54067 0 3
47987: ST_TO_ADDR
// exit ;
47988: POP
47989: POP
47990: GO 48448
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47992: LD_VAR 0 5
47996: PUSH
47997: LD_INT 0
47999: PUSH
48000: LD_INT 2
48002: PUSH
48003: LD_INT 4
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: LIST
48010: IN
48011: IFFALSE 48135
// begin if btype = b_armoury then
48013: LD_VAR 0 5
48017: PUSH
48018: LD_INT 4
48020: EQUAL
48021: IFFALSE 48031
// btype := b_barracks ;
48023: LD_ADDR_VAR 0 5
48027: PUSH
48028: LD_INT 5
48030: ST_TO_ADDR
// if btype = b_depot then
48031: LD_VAR 0 5
48035: PUSH
48036: LD_INT 0
48038: EQUAL
48039: IFFALSE 48049
// btype := b_warehouse ;
48041: LD_ADDR_VAR 0 5
48045: PUSH
48046: LD_INT 1
48048: ST_TO_ADDR
// if btype = b_workshop then
48049: LD_VAR 0 5
48053: PUSH
48054: LD_INT 2
48056: EQUAL
48057: IFFALSE 48067
// btype := b_factory ;
48059: LD_ADDR_VAR 0 5
48063: PUSH
48064: LD_INT 3
48066: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48067: LD_VAR 0 5
48071: PPUSH
48072: LD_VAR 0 8
48076: PPUSH
48077: CALL_OW 323
48081: PUSH
48082: LD_INT 1
48084: EQUAL
48085: IFFALSE 48131
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48087: LD_ADDR_EXP 82
48091: PUSH
48092: LD_EXP 82
48096: PPUSH
48097: LD_VAR 0 3
48101: PUSH
48102: LD_EXP 82
48106: PUSH
48107: LD_VAR 0 3
48111: ARRAY
48112: PUSH
48113: LD_INT 1
48115: PLUS
48116: PUSH
48117: EMPTY
48118: LIST
48119: LIST
48120: PPUSH
48121: LD_VAR 0 1
48125: PPUSH
48126: CALL 54067 0 3
48130: ST_TO_ADDR
// exit ;
48131: POP
48132: POP
48133: GO 48448
// end ; if btype in [ b_bunker , b_turret ] then
48135: LD_VAR 0 5
48139: PUSH
48140: LD_INT 32
48142: PUSH
48143: LD_INT 33
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: IN
48150: IFFALSE 48440
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48152: LD_ADDR_EXP 58
48156: PUSH
48157: LD_EXP 58
48161: PPUSH
48162: LD_VAR 0 3
48166: PUSH
48167: LD_EXP 58
48171: PUSH
48172: LD_VAR 0 3
48176: ARRAY
48177: PUSH
48178: LD_INT 1
48180: PLUS
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PPUSH
48186: LD_VAR 0 1
48190: PPUSH
48191: CALL 54067 0 3
48195: ST_TO_ADDR
// if btype = b_bunker then
48196: LD_VAR 0 5
48200: PUSH
48201: LD_INT 32
48203: EQUAL
48204: IFFALSE 48440
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48206: LD_ADDR_EXP 59
48210: PUSH
48211: LD_EXP 59
48215: PPUSH
48216: LD_VAR 0 3
48220: PUSH
48221: LD_EXP 59
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: PUSH
48232: LD_INT 1
48234: PLUS
48235: PUSH
48236: EMPTY
48237: LIST
48238: LIST
48239: PPUSH
48240: LD_VAR 0 1
48244: PPUSH
48245: CALL 54067 0 3
48249: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48250: LD_ADDR_VAR 0 6
48254: PUSH
48255: LD_EXP 50
48259: PUSH
48260: LD_VAR 0 3
48264: ARRAY
48265: PPUSH
48266: LD_INT 25
48268: PUSH
48269: LD_INT 1
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 3
48278: PUSH
48279: LD_INT 54
48281: PUSH
48282: EMPTY
48283: LIST
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PPUSH
48293: CALL_OW 72
48297: ST_TO_ADDR
// if tmp then
48298: LD_VAR 0 6
48302: IFFALSE 48308
// exit ;
48304: POP
48305: POP
48306: GO 48448
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48308: LD_ADDR_VAR 0 6
48312: PUSH
48313: LD_EXP 50
48317: PUSH
48318: LD_VAR 0 3
48322: ARRAY
48323: PPUSH
48324: LD_INT 2
48326: PUSH
48327: LD_INT 30
48329: PUSH
48330: LD_INT 4
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: PUSH
48337: LD_INT 30
48339: PUSH
48340: LD_INT 5
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: LIST
48351: PPUSH
48352: CALL_OW 72
48356: ST_TO_ADDR
// if not tmp then
48357: LD_VAR 0 6
48361: NOT
48362: IFFALSE 48368
// exit ;
48364: POP
48365: POP
48366: GO 48448
// for j in tmp do
48368: LD_ADDR_VAR 0 4
48372: PUSH
48373: LD_VAR 0 6
48377: PUSH
48378: FOR_IN
48379: IFFALSE 48438
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48381: LD_ADDR_VAR 0 7
48385: PUSH
48386: LD_VAR 0 4
48390: PPUSH
48391: CALL_OW 313
48395: PPUSH
48396: LD_INT 25
48398: PUSH
48399: LD_INT 1
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: PPUSH
48406: CALL_OW 72
48410: ST_TO_ADDR
// if units then
48411: LD_VAR 0 7
48415: IFFALSE 48436
// begin ComExitBuilding ( units [ 1 ] ) ;
48417: LD_VAR 0 7
48421: PUSH
48422: LD_INT 1
48424: ARRAY
48425: PPUSH
48426: CALL_OW 122
// exit ;
48430: POP
48431: POP
48432: POP
48433: POP
48434: GO 48448
// end ; end ;
48436: GO 48378
48438: POP
48439: POP
// end ; end ; exit ;
48440: POP
48441: POP
48442: GO 48448
// end ; end ;
48444: GO 47802
48446: POP
48447: POP
// end ;
48448: LD_VAR 0 2
48452: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48453: LD_INT 0
48455: PPUSH
48456: PPUSH
48457: PPUSH
48458: PPUSH
48459: PPUSH
48460: PPUSH
48461: PPUSH
// if not mc_bases or not skirmish then
48462: LD_EXP 50
48466: NOT
48467: PUSH
48468: LD_EXP 48
48472: NOT
48473: OR
48474: IFFALSE 48478
// exit ;
48476: GO 48743
// btype := GetBType ( building ) ;
48478: LD_ADDR_VAR 0 6
48482: PUSH
48483: LD_VAR 0 1
48487: PPUSH
48488: CALL_OW 266
48492: ST_TO_ADDR
// x := GetX ( building ) ;
48493: LD_ADDR_VAR 0 7
48497: PUSH
48498: LD_VAR 0 1
48502: PPUSH
48503: CALL_OW 250
48507: ST_TO_ADDR
// y := GetY ( building ) ;
48508: LD_ADDR_VAR 0 8
48512: PUSH
48513: LD_VAR 0 1
48517: PPUSH
48518: CALL_OW 251
48522: ST_TO_ADDR
// d := GetDir ( building ) ;
48523: LD_ADDR_VAR 0 9
48527: PUSH
48528: LD_VAR 0 1
48532: PPUSH
48533: CALL_OW 254
48537: ST_TO_ADDR
// for i = 1 to mc_bases do
48538: LD_ADDR_VAR 0 4
48542: PUSH
48543: DOUBLE
48544: LD_INT 1
48546: DEC
48547: ST_TO_ADDR
48548: LD_EXP 50
48552: PUSH
48553: FOR_TO
48554: IFFALSE 48741
// begin if not mc_build_list [ i ] then
48556: LD_EXP 55
48560: PUSH
48561: LD_VAR 0 4
48565: ARRAY
48566: NOT
48567: IFFALSE 48571
// continue ;
48569: GO 48553
// for j := 1 to mc_build_list [ i ] do
48571: LD_ADDR_VAR 0 5
48575: PUSH
48576: DOUBLE
48577: LD_INT 1
48579: DEC
48580: ST_TO_ADDR
48581: LD_EXP 55
48585: PUSH
48586: LD_VAR 0 4
48590: ARRAY
48591: PUSH
48592: FOR_TO
48593: IFFALSE 48737
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48595: LD_VAR 0 6
48599: PUSH
48600: LD_VAR 0 7
48604: PUSH
48605: LD_VAR 0 8
48609: PUSH
48610: LD_VAR 0 9
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: PPUSH
48621: LD_EXP 55
48625: PUSH
48626: LD_VAR 0 4
48630: ARRAY
48631: PUSH
48632: LD_VAR 0 5
48636: ARRAY
48637: PPUSH
48638: CALL 60624 0 2
48642: IFFALSE 48735
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48644: LD_ADDR_EXP 55
48648: PUSH
48649: LD_EXP 55
48653: PPUSH
48654: LD_VAR 0 4
48658: PPUSH
48659: LD_EXP 55
48663: PUSH
48664: LD_VAR 0 4
48668: ARRAY
48669: PPUSH
48670: LD_VAR 0 5
48674: PPUSH
48675: CALL_OW 3
48679: PPUSH
48680: CALL_OW 1
48684: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48685: LD_ADDR_EXP 57
48689: PUSH
48690: LD_EXP 57
48694: PPUSH
48695: LD_VAR 0 4
48699: PUSH
48700: LD_EXP 57
48704: PUSH
48705: LD_VAR 0 4
48709: ARRAY
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PPUSH
48719: LD_VAR 0 1
48723: PPUSH
48724: CALL 54067 0 3
48728: ST_TO_ADDR
// exit ;
48729: POP
48730: POP
48731: POP
48732: POP
48733: GO 48743
// end ;
48735: GO 48592
48737: POP
48738: POP
// end ;
48739: GO 48553
48741: POP
48742: POP
// end ;
48743: LD_VAR 0 3
48747: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48748: LD_INT 0
48750: PPUSH
48751: PPUSH
48752: PPUSH
// if not mc_bases or not skirmish then
48753: LD_EXP 50
48757: NOT
48758: PUSH
48759: LD_EXP 48
48763: NOT
48764: OR
48765: IFFALSE 48769
// exit ;
48767: GO 48959
// for i = 1 to mc_bases do
48769: LD_ADDR_VAR 0 4
48773: PUSH
48774: DOUBLE
48775: LD_INT 1
48777: DEC
48778: ST_TO_ADDR
48779: LD_EXP 50
48783: PUSH
48784: FOR_TO
48785: IFFALSE 48872
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48787: LD_VAR 0 1
48791: PUSH
48792: LD_EXP 58
48796: PUSH
48797: LD_VAR 0 4
48801: ARRAY
48802: IN
48803: PUSH
48804: LD_VAR 0 1
48808: PUSH
48809: LD_EXP 59
48813: PUSH
48814: LD_VAR 0 4
48818: ARRAY
48819: IN
48820: NOT
48821: AND
48822: IFFALSE 48870
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48824: LD_ADDR_EXP 59
48828: PUSH
48829: LD_EXP 59
48833: PPUSH
48834: LD_VAR 0 4
48838: PUSH
48839: LD_EXP 59
48843: PUSH
48844: LD_VAR 0 4
48848: ARRAY
48849: PUSH
48850: LD_INT 1
48852: PLUS
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PPUSH
48858: LD_VAR 0 1
48862: PPUSH
48863: CALL 54067 0 3
48867: ST_TO_ADDR
// break ;
48868: GO 48872
// end ; end ;
48870: GO 48784
48872: POP
48873: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48874: LD_VAR 0 1
48878: PPUSH
48879: CALL_OW 257
48883: PUSH
48884: LD_EXP 76
48888: IN
48889: PUSH
48890: LD_VAR 0 1
48894: PPUSH
48895: CALL_OW 266
48899: PUSH
48900: LD_INT 5
48902: EQUAL
48903: AND
48904: PUSH
48905: LD_VAR 0 2
48909: PPUSH
48910: CALL_OW 110
48914: PUSH
48915: LD_INT 18
48917: NONEQUAL
48918: AND
48919: IFFALSE 48959
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48921: LD_VAR 0 2
48925: PPUSH
48926: CALL_OW 257
48930: PUSH
48931: LD_INT 5
48933: PUSH
48934: LD_INT 8
48936: PUSH
48937: LD_INT 9
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: LIST
48944: IN
48945: IFFALSE 48959
// SetClass ( unit , 1 ) ;
48947: LD_VAR 0 2
48951: PPUSH
48952: LD_INT 1
48954: PPUSH
48955: CALL_OW 336
// end ;
48959: LD_VAR 0 3
48963: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48964: LD_INT 0
48966: PPUSH
48967: PPUSH
// if not mc_bases or not skirmish then
48968: LD_EXP 50
48972: NOT
48973: PUSH
48974: LD_EXP 48
48978: NOT
48979: OR
48980: IFFALSE 48984
// exit ;
48982: GO 49100
// if GetLives ( abandoned_vehicle ) > 250 then
48984: LD_VAR 0 2
48988: PPUSH
48989: CALL_OW 256
48993: PUSH
48994: LD_INT 250
48996: GREATER
48997: IFFALSE 49001
// exit ;
48999: GO 49100
// for i = 1 to mc_bases do
49001: LD_ADDR_VAR 0 6
49005: PUSH
49006: DOUBLE
49007: LD_INT 1
49009: DEC
49010: ST_TO_ADDR
49011: LD_EXP 50
49015: PUSH
49016: FOR_TO
49017: IFFALSE 49098
// begin if driver in mc_bases [ i ] then
49019: LD_VAR 0 1
49023: PUSH
49024: LD_EXP 50
49028: PUSH
49029: LD_VAR 0 6
49033: ARRAY
49034: IN
49035: IFFALSE 49096
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49037: LD_VAR 0 1
49041: PPUSH
49042: LD_EXP 50
49046: PUSH
49047: LD_VAR 0 6
49051: ARRAY
49052: PPUSH
49053: LD_INT 2
49055: PUSH
49056: LD_INT 30
49058: PUSH
49059: LD_INT 0
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 30
49068: PUSH
49069: LD_INT 1
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: LIST
49080: PPUSH
49081: CALL_OW 72
49085: PUSH
49086: LD_INT 1
49088: ARRAY
49089: PPUSH
49090: CALL 87684 0 2
// break ;
49094: GO 49098
// end ; end ;
49096: GO 49016
49098: POP
49099: POP
// end ; end_of_file
49100: LD_VAR 0 5
49104: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49105: LD_INT 0
49107: PPUSH
49108: PPUSH
// if exist_mode then
49109: LD_VAR 0 2
49113: IFFALSE 49138
// unit := CreateCharacter ( prefix & ident ) else
49115: LD_ADDR_VAR 0 5
49119: PUSH
49120: LD_VAR 0 3
49124: PUSH
49125: LD_VAR 0 1
49129: STR
49130: PPUSH
49131: CALL_OW 34
49135: ST_TO_ADDR
49136: GO 49153
// unit := NewCharacter ( ident ) ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 1
49147: PPUSH
49148: CALL_OW 25
49152: ST_TO_ADDR
// result := unit ;
49153: LD_ADDR_VAR 0 4
49157: PUSH
49158: LD_VAR 0 5
49162: ST_TO_ADDR
// end ;
49163: LD_VAR 0 4
49167: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49168: LD_INT 0
49170: PPUSH
49171: PPUSH
// if not side or not nation then
49172: LD_VAR 0 1
49176: NOT
49177: PUSH
49178: LD_VAR 0 2
49182: NOT
49183: OR
49184: IFFALSE 49188
// exit ;
49186: GO 49956
// case nation of nation_american :
49188: LD_VAR 0 2
49192: PUSH
49193: LD_INT 1
49195: DOUBLE
49196: EQUAL
49197: IFTRUE 49201
49199: GO 49415
49201: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49202: LD_ADDR_VAR 0 4
49206: PUSH
49207: LD_INT 35
49209: PUSH
49210: LD_INT 45
49212: PUSH
49213: LD_INT 46
49215: PUSH
49216: LD_INT 47
49218: PUSH
49219: LD_INT 82
49221: PUSH
49222: LD_INT 83
49224: PUSH
49225: LD_INT 84
49227: PUSH
49228: LD_INT 85
49230: PUSH
49231: LD_INT 86
49233: PUSH
49234: LD_INT 1
49236: PUSH
49237: LD_INT 2
49239: PUSH
49240: LD_INT 6
49242: PUSH
49243: LD_INT 15
49245: PUSH
49246: LD_INT 16
49248: PUSH
49249: LD_INT 7
49251: PUSH
49252: LD_INT 12
49254: PUSH
49255: LD_INT 13
49257: PUSH
49258: LD_INT 10
49260: PUSH
49261: LD_INT 14
49263: PUSH
49264: LD_INT 20
49266: PUSH
49267: LD_INT 21
49269: PUSH
49270: LD_INT 22
49272: PUSH
49273: LD_INT 25
49275: PUSH
49276: LD_INT 32
49278: PUSH
49279: LD_INT 27
49281: PUSH
49282: LD_INT 36
49284: PUSH
49285: LD_INT 69
49287: PUSH
49288: LD_INT 39
49290: PUSH
49291: LD_INT 34
49293: PUSH
49294: LD_INT 40
49296: PUSH
49297: LD_INT 48
49299: PUSH
49300: LD_INT 49
49302: PUSH
49303: LD_INT 50
49305: PUSH
49306: LD_INT 51
49308: PUSH
49309: LD_INT 52
49311: PUSH
49312: LD_INT 53
49314: PUSH
49315: LD_INT 54
49317: PUSH
49318: LD_INT 55
49320: PUSH
49321: LD_INT 56
49323: PUSH
49324: LD_INT 57
49326: PUSH
49327: LD_INT 58
49329: PUSH
49330: LD_INT 59
49332: PUSH
49333: LD_INT 60
49335: PUSH
49336: LD_INT 61
49338: PUSH
49339: LD_INT 62
49341: PUSH
49342: LD_INT 80
49344: PUSH
49345: LD_INT 82
49347: PUSH
49348: LD_INT 83
49350: PUSH
49351: LD_INT 84
49353: PUSH
49354: LD_INT 85
49356: PUSH
49357: LD_INT 86
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: ST_TO_ADDR
49413: GO 49880
49415: LD_INT 2
49417: DOUBLE
49418: EQUAL
49419: IFTRUE 49423
49421: GO 49649
49423: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49424: LD_ADDR_VAR 0 4
49428: PUSH
49429: LD_INT 35
49431: PUSH
49432: LD_INT 45
49434: PUSH
49435: LD_INT 46
49437: PUSH
49438: LD_INT 47
49440: PUSH
49441: LD_INT 82
49443: PUSH
49444: LD_INT 83
49446: PUSH
49447: LD_INT 84
49449: PUSH
49450: LD_INT 85
49452: PUSH
49453: LD_INT 87
49455: PUSH
49456: LD_INT 70
49458: PUSH
49459: LD_INT 1
49461: PUSH
49462: LD_INT 11
49464: PUSH
49465: LD_INT 3
49467: PUSH
49468: LD_INT 4
49470: PUSH
49471: LD_INT 5
49473: PUSH
49474: LD_INT 6
49476: PUSH
49477: LD_INT 15
49479: PUSH
49480: LD_INT 18
49482: PUSH
49483: LD_INT 7
49485: PUSH
49486: LD_INT 17
49488: PUSH
49489: LD_INT 8
49491: PUSH
49492: LD_INT 20
49494: PUSH
49495: LD_INT 21
49497: PUSH
49498: LD_INT 22
49500: PUSH
49501: LD_INT 72
49503: PUSH
49504: LD_INT 26
49506: PUSH
49507: LD_INT 69
49509: PUSH
49510: LD_INT 39
49512: PUSH
49513: LD_INT 40
49515: PUSH
49516: LD_INT 41
49518: PUSH
49519: LD_INT 42
49521: PUSH
49522: LD_INT 43
49524: PUSH
49525: LD_INT 48
49527: PUSH
49528: LD_INT 49
49530: PUSH
49531: LD_INT 50
49533: PUSH
49534: LD_INT 51
49536: PUSH
49537: LD_INT 52
49539: PUSH
49540: LD_INT 53
49542: PUSH
49543: LD_INT 54
49545: PUSH
49546: LD_INT 55
49548: PUSH
49549: LD_INT 56
49551: PUSH
49552: LD_INT 60
49554: PUSH
49555: LD_INT 61
49557: PUSH
49558: LD_INT 62
49560: PUSH
49561: LD_INT 66
49563: PUSH
49564: LD_INT 67
49566: PUSH
49567: LD_INT 68
49569: PUSH
49570: LD_INT 81
49572: PUSH
49573: LD_INT 82
49575: PUSH
49576: LD_INT 83
49578: PUSH
49579: LD_INT 84
49581: PUSH
49582: LD_INT 85
49584: PUSH
49585: LD_INT 87
49587: PUSH
49588: LD_INT 88
49590: PUSH
49591: EMPTY
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: ST_TO_ADDR
49647: GO 49880
49649: LD_INT 3
49651: DOUBLE
49652: EQUAL
49653: IFTRUE 49657
49655: GO 49879
49657: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49658: LD_ADDR_VAR 0 4
49662: PUSH
49663: LD_INT 46
49665: PUSH
49666: LD_INT 47
49668: PUSH
49669: LD_INT 1
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: LD_INT 82
49677: PUSH
49678: LD_INT 83
49680: PUSH
49681: LD_INT 84
49683: PUSH
49684: LD_INT 85
49686: PUSH
49687: LD_INT 86
49689: PUSH
49690: LD_INT 11
49692: PUSH
49693: LD_INT 9
49695: PUSH
49696: LD_INT 20
49698: PUSH
49699: LD_INT 19
49701: PUSH
49702: LD_INT 21
49704: PUSH
49705: LD_INT 24
49707: PUSH
49708: LD_INT 22
49710: PUSH
49711: LD_INT 25
49713: PUSH
49714: LD_INT 28
49716: PUSH
49717: LD_INT 29
49719: PUSH
49720: LD_INT 30
49722: PUSH
49723: LD_INT 31
49725: PUSH
49726: LD_INT 37
49728: PUSH
49729: LD_INT 38
49731: PUSH
49732: LD_INT 32
49734: PUSH
49735: LD_INT 27
49737: PUSH
49738: LD_INT 33
49740: PUSH
49741: LD_INT 69
49743: PUSH
49744: LD_INT 39
49746: PUSH
49747: LD_INT 34
49749: PUSH
49750: LD_INT 40
49752: PUSH
49753: LD_INT 71
49755: PUSH
49756: LD_INT 23
49758: PUSH
49759: LD_INT 44
49761: PUSH
49762: LD_INT 48
49764: PUSH
49765: LD_INT 49
49767: PUSH
49768: LD_INT 50
49770: PUSH
49771: LD_INT 51
49773: PUSH
49774: LD_INT 52
49776: PUSH
49777: LD_INT 53
49779: PUSH
49780: LD_INT 54
49782: PUSH
49783: LD_INT 55
49785: PUSH
49786: LD_INT 56
49788: PUSH
49789: LD_INT 57
49791: PUSH
49792: LD_INT 58
49794: PUSH
49795: LD_INT 59
49797: PUSH
49798: LD_INT 63
49800: PUSH
49801: LD_INT 64
49803: PUSH
49804: LD_INT 65
49806: PUSH
49807: LD_INT 82
49809: PUSH
49810: LD_INT 83
49812: PUSH
49813: LD_INT 84
49815: PUSH
49816: LD_INT 85
49818: PUSH
49819: LD_INT 86
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: LIST
49829: LIST
49830: LIST
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: LIST
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: ST_TO_ADDR
49877: GO 49880
49879: POP
// if state > - 1 and state < 3 then
49880: LD_VAR 0 3
49884: PUSH
49885: LD_INT 1
49887: NEG
49888: GREATER
49889: PUSH
49890: LD_VAR 0 3
49894: PUSH
49895: LD_INT 3
49897: LESS
49898: AND
49899: IFFALSE 49956
// for i in result do
49901: LD_ADDR_VAR 0 5
49905: PUSH
49906: LD_VAR 0 4
49910: PUSH
49911: FOR_IN
49912: IFFALSE 49954
// if GetTech ( i , side ) <> state then
49914: LD_VAR 0 5
49918: PPUSH
49919: LD_VAR 0 1
49923: PPUSH
49924: CALL_OW 321
49928: PUSH
49929: LD_VAR 0 3
49933: NONEQUAL
49934: IFFALSE 49952
// result := result diff i ;
49936: LD_ADDR_VAR 0 4
49940: PUSH
49941: LD_VAR 0 4
49945: PUSH
49946: LD_VAR 0 5
49950: DIFF
49951: ST_TO_ADDR
49952: GO 49911
49954: POP
49955: POP
// end ;
49956: LD_VAR 0 4
49960: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49961: LD_INT 0
49963: PPUSH
49964: PPUSH
49965: PPUSH
// result := true ;
49966: LD_ADDR_VAR 0 3
49970: PUSH
49971: LD_INT 1
49973: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49974: LD_ADDR_VAR 0 5
49978: PUSH
49979: LD_VAR 0 2
49983: PPUSH
49984: CALL_OW 480
49988: ST_TO_ADDR
// if not tmp then
49989: LD_VAR 0 5
49993: NOT
49994: IFFALSE 49998
// exit ;
49996: GO 50047
// for i in tmp do
49998: LD_ADDR_VAR 0 4
50002: PUSH
50003: LD_VAR 0 5
50007: PUSH
50008: FOR_IN
50009: IFFALSE 50045
// if GetTech ( i , side ) <> state_researched then
50011: LD_VAR 0 4
50015: PPUSH
50016: LD_VAR 0 1
50020: PPUSH
50021: CALL_OW 321
50025: PUSH
50026: LD_INT 2
50028: NONEQUAL
50029: IFFALSE 50043
// begin result := false ;
50031: LD_ADDR_VAR 0 3
50035: PUSH
50036: LD_INT 0
50038: ST_TO_ADDR
// exit ;
50039: POP
50040: POP
50041: GO 50047
// end ;
50043: GO 50008
50045: POP
50046: POP
// end ;
50047: LD_VAR 0 3
50051: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50052: LD_INT 0
50054: PPUSH
50055: PPUSH
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
50061: PPUSH
50062: PPUSH
50063: PPUSH
50064: PPUSH
50065: PPUSH
50066: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50067: LD_VAR 0 1
50071: NOT
50072: PUSH
50073: LD_VAR 0 1
50077: PPUSH
50078: CALL_OW 257
50082: PUSH
50083: LD_INT 9
50085: NONEQUAL
50086: OR
50087: IFFALSE 50091
// exit ;
50089: GO 50664
// side := GetSide ( unit ) ;
50091: LD_ADDR_VAR 0 9
50095: PUSH
50096: LD_VAR 0 1
50100: PPUSH
50101: CALL_OW 255
50105: ST_TO_ADDR
// tech_space := tech_spacanom ;
50106: LD_ADDR_VAR 0 12
50110: PUSH
50111: LD_INT 29
50113: ST_TO_ADDR
// tech_time := tech_taurad ;
50114: LD_ADDR_VAR 0 13
50118: PUSH
50119: LD_INT 28
50121: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50122: LD_ADDR_VAR 0 11
50126: PUSH
50127: LD_VAR 0 1
50131: PPUSH
50132: CALL_OW 310
50136: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50137: LD_VAR 0 11
50141: PPUSH
50142: CALL_OW 247
50146: PUSH
50147: LD_INT 2
50149: EQUAL
50150: IFFALSE 50154
// exit ;
50152: GO 50664
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50154: LD_ADDR_VAR 0 8
50158: PUSH
50159: LD_INT 81
50161: PUSH
50162: LD_VAR 0 9
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: LD_INT 3
50173: PUSH
50174: LD_INT 21
50176: PUSH
50177: LD_INT 3
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: PPUSH
50192: CALL_OW 69
50196: ST_TO_ADDR
// if not tmp then
50197: LD_VAR 0 8
50201: NOT
50202: IFFALSE 50206
// exit ;
50204: GO 50664
// if in_unit then
50206: LD_VAR 0 11
50210: IFFALSE 50234
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50212: LD_ADDR_VAR 0 10
50216: PUSH
50217: LD_VAR 0 8
50221: PPUSH
50222: LD_VAR 0 11
50226: PPUSH
50227: CALL_OW 74
50231: ST_TO_ADDR
50232: GO 50254
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50234: LD_ADDR_VAR 0 10
50238: PUSH
50239: LD_VAR 0 8
50243: PPUSH
50244: LD_VAR 0 1
50248: PPUSH
50249: CALL_OW 74
50253: ST_TO_ADDR
// if not enemy then
50254: LD_VAR 0 10
50258: NOT
50259: IFFALSE 50263
// exit ;
50261: GO 50664
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50263: LD_VAR 0 11
50267: PUSH
50268: LD_VAR 0 11
50272: PPUSH
50273: LD_VAR 0 10
50277: PPUSH
50278: CALL_OW 296
50282: PUSH
50283: LD_INT 13
50285: GREATER
50286: AND
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: LD_VAR 0 10
50297: PPUSH
50298: CALL_OW 296
50302: PUSH
50303: LD_INT 12
50305: GREATER
50306: OR
50307: IFFALSE 50311
// exit ;
50309: GO 50664
// missile := [ 1 ] ;
50311: LD_ADDR_VAR 0 14
50315: PUSH
50316: LD_INT 1
50318: PUSH
50319: EMPTY
50320: LIST
50321: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50322: LD_VAR 0 9
50326: PPUSH
50327: LD_VAR 0 12
50331: PPUSH
50332: CALL_OW 325
50336: IFFALSE 50365
// missile := Replace ( missile , missile + 1 , 2 ) ;
50338: LD_ADDR_VAR 0 14
50342: PUSH
50343: LD_VAR 0 14
50347: PPUSH
50348: LD_VAR 0 14
50352: PUSH
50353: LD_INT 1
50355: PLUS
50356: PPUSH
50357: LD_INT 2
50359: PPUSH
50360: CALL_OW 1
50364: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50365: LD_VAR 0 9
50369: PPUSH
50370: LD_VAR 0 13
50374: PPUSH
50375: CALL_OW 325
50379: PUSH
50380: LD_VAR 0 10
50384: PPUSH
50385: CALL_OW 255
50389: PPUSH
50390: LD_VAR 0 13
50394: PPUSH
50395: CALL_OW 325
50399: NOT
50400: AND
50401: IFFALSE 50430
// missile := Replace ( missile , missile + 1 , 3 ) ;
50403: LD_ADDR_VAR 0 14
50407: PUSH
50408: LD_VAR 0 14
50412: PPUSH
50413: LD_VAR 0 14
50417: PUSH
50418: LD_INT 1
50420: PLUS
50421: PPUSH
50422: LD_INT 3
50424: PPUSH
50425: CALL_OW 1
50429: ST_TO_ADDR
// if missile < 2 then
50430: LD_VAR 0 14
50434: PUSH
50435: LD_INT 2
50437: LESS
50438: IFFALSE 50442
// exit ;
50440: GO 50664
// x := GetX ( enemy ) ;
50442: LD_ADDR_VAR 0 4
50446: PUSH
50447: LD_VAR 0 10
50451: PPUSH
50452: CALL_OW 250
50456: ST_TO_ADDR
// y := GetY ( enemy ) ;
50457: LD_ADDR_VAR 0 5
50461: PUSH
50462: LD_VAR 0 10
50466: PPUSH
50467: CALL_OW 251
50471: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50472: LD_ADDR_VAR 0 6
50476: PUSH
50477: LD_VAR 0 4
50481: PUSH
50482: LD_INT 1
50484: NEG
50485: PPUSH
50486: LD_INT 1
50488: PPUSH
50489: CALL_OW 12
50493: PLUS
50494: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50495: LD_ADDR_VAR 0 7
50499: PUSH
50500: LD_VAR 0 5
50504: PUSH
50505: LD_INT 1
50507: NEG
50508: PPUSH
50509: LD_INT 1
50511: PPUSH
50512: CALL_OW 12
50516: PLUS
50517: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50518: LD_VAR 0 6
50522: PPUSH
50523: LD_VAR 0 7
50527: PPUSH
50528: CALL_OW 488
50532: NOT
50533: IFFALSE 50555
// begin _x := x ;
50535: LD_ADDR_VAR 0 6
50539: PUSH
50540: LD_VAR 0 4
50544: ST_TO_ADDR
// _y := y ;
50545: LD_ADDR_VAR 0 7
50549: PUSH
50550: LD_VAR 0 5
50554: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50555: LD_ADDR_VAR 0 3
50559: PUSH
50560: LD_INT 1
50562: PPUSH
50563: LD_VAR 0 14
50567: PPUSH
50568: CALL_OW 12
50572: ST_TO_ADDR
// case i of 1 :
50573: LD_VAR 0 3
50577: PUSH
50578: LD_INT 1
50580: DOUBLE
50581: EQUAL
50582: IFTRUE 50586
50584: GO 50603
50586: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50587: LD_VAR 0 1
50591: PPUSH
50592: LD_VAR 0 10
50596: PPUSH
50597: CALL_OW 115
50601: GO 50664
50603: LD_INT 2
50605: DOUBLE
50606: EQUAL
50607: IFTRUE 50611
50609: GO 50633
50611: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50612: LD_VAR 0 1
50616: PPUSH
50617: LD_VAR 0 6
50621: PPUSH
50622: LD_VAR 0 7
50626: PPUSH
50627: CALL_OW 153
50631: GO 50664
50633: LD_INT 3
50635: DOUBLE
50636: EQUAL
50637: IFTRUE 50641
50639: GO 50663
50641: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50642: LD_VAR 0 1
50646: PPUSH
50647: LD_VAR 0 6
50651: PPUSH
50652: LD_VAR 0 7
50656: PPUSH
50657: CALL_OW 154
50661: GO 50664
50663: POP
// end ;
50664: LD_VAR 0 2
50668: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50669: LD_INT 0
50671: PPUSH
50672: PPUSH
50673: PPUSH
50674: PPUSH
50675: PPUSH
50676: PPUSH
// if not unit or not building then
50677: LD_VAR 0 1
50681: NOT
50682: PUSH
50683: LD_VAR 0 2
50687: NOT
50688: OR
50689: IFFALSE 50693
// exit ;
50691: GO 50851
// x := GetX ( building ) ;
50693: LD_ADDR_VAR 0 5
50697: PUSH
50698: LD_VAR 0 2
50702: PPUSH
50703: CALL_OW 250
50707: ST_TO_ADDR
// y := GetY ( building ) ;
50708: LD_ADDR_VAR 0 6
50712: PUSH
50713: LD_VAR 0 2
50717: PPUSH
50718: CALL_OW 251
50722: ST_TO_ADDR
// for i = 0 to 5 do
50723: LD_ADDR_VAR 0 4
50727: PUSH
50728: DOUBLE
50729: LD_INT 0
50731: DEC
50732: ST_TO_ADDR
50733: LD_INT 5
50735: PUSH
50736: FOR_TO
50737: IFFALSE 50849
// begin _x := ShiftX ( x , i , 3 ) ;
50739: LD_ADDR_VAR 0 7
50743: PUSH
50744: LD_VAR 0 5
50748: PPUSH
50749: LD_VAR 0 4
50753: PPUSH
50754: LD_INT 3
50756: PPUSH
50757: CALL_OW 272
50761: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50762: LD_ADDR_VAR 0 8
50766: PUSH
50767: LD_VAR 0 6
50771: PPUSH
50772: LD_VAR 0 4
50776: PPUSH
50777: LD_INT 3
50779: PPUSH
50780: CALL_OW 273
50784: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50785: LD_VAR 0 7
50789: PPUSH
50790: LD_VAR 0 8
50794: PPUSH
50795: CALL_OW 488
50799: NOT
50800: IFFALSE 50804
// continue ;
50802: GO 50736
// if HexInfo ( _x , _y ) = 0 then
50804: LD_VAR 0 7
50808: PPUSH
50809: LD_VAR 0 8
50813: PPUSH
50814: CALL_OW 428
50818: PUSH
50819: LD_INT 0
50821: EQUAL
50822: IFFALSE 50847
// begin ComMoveXY ( unit , _x , _y ) ;
50824: LD_VAR 0 1
50828: PPUSH
50829: LD_VAR 0 7
50833: PPUSH
50834: LD_VAR 0 8
50838: PPUSH
50839: CALL_OW 111
// exit ;
50843: POP
50844: POP
50845: GO 50851
// end ; end ;
50847: GO 50736
50849: POP
50850: POP
// end ;
50851: LD_VAR 0 3
50855: RET
// export function ScanBase ( side , base_area ) ; begin
50856: LD_INT 0
50858: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50859: LD_ADDR_VAR 0 3
50863: PUSH
50864: LD_VAR 0 2
50868: PPUSH
50869: LD_INT 81
50871: PUSH
50872: LD_VAR 0 1
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PPUSH
50881: CALL_OW 70
50885: ST_TO_ADDR
// end ;
50886: LD_VAR 0 3
50890: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50891: LD_INT 0
50893: PPUSH
50894: PPUSH
50895: PPUSH
50896: PPUSH
// result := false ;
50897: LD_ADDR_VAR 0 2
50901: PUSH
50902: LD_INT 0
50904: ST_TO_ADDR
// side := GetSide ( unit ) ;
50905: LD_ADDR_VAR 0 3
50909: PUSH
50910: LD_VAR 0 1
50914: PPUSH
50915: CALL_OW 255
50919: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50920: LD_ADDR_VAR 0 4
50924: PUSH
50925: LD_VAR 0 1
50929: PPUSH
50930: CALL_OW 248
50934: ST_TO_ADDR
// case nat of 1 :
50935: LD_VAR 0 4
50939: PUSH
50940: LD_INT 1
50942: DOUBLE
50943: EQUAL
50944: IFTRUE 50948
50946: GO 50959
50948: POP
// tech := tech_lassight ; 2 :
50949: LD_ADDR_VAR 0 5
50953: PUSH
50954: LD_INT 12
50956: ST_TO_ADDR
50957: GO 50998
50959: LD_INT 2
50961: DOUBLE
50962: EQUAL
50963: IFTRUE 50967
50965: GO 50978
50967: POP
// tech := tech_mortar ; 3 :
50968: LD_ADDR_VAR 0 5
50972: PUSH
50973: LD_INT 41
50975: ST_TO_ADDR
50976: GO 50998
50978: LD_INT 3
50980: DOUBLE
50981: EQUAL
50982: IFTRUE 50986
50984: GO 50997
50986: POP
// tech := tech_bazooka ; end ;
50987: LD_ADDR_VAR 0 5
50991: PUSH
50992: LD_INT 44
50994: ST_TO_ADDR
50995: GO 50998
50997: POP
// if Researched ( side , tech ) then
50998: LD_VAR 0 3
51002: PPUSH
51003: LD_VAR 0 5
51007: PPUSH
51008: CALL_OW 325
51012: IFFALSE 51039
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51014: LD_ADDR_VAR 0 2
51018: PUSH
51019: LD_INT 5
51021: PUSH
51022: LD_INT 8
51024: PUSH
51025: LD_INT 9
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: LIST
51032: PUSH
51033: LD_VAR 0 4
51037: ARRAY
51038: ST_TO_ADDR
// end ;
51039: LD_VAR 0 2
51043: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51044: LD_INT 0
51046: PPUSH
51047: PPUSH
51048: PPUSH
// if not mines then
51049: LD_VAR 0 2
51053: NOT
51054: IFFALSE 51058
// exit ;
51056: GO 51202
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51058: LD_ADDR_VAR 0 5
51062: PUSH
51063: LD_INT 81
51065: PUSH
51066: LD_VAR 0 1
51070: PUSH
51071: EMPTY
51072: LIST
51073: LIST
51074: PUSH
51075: LD_INT 3
51077: PUSH
51078: LD_INT 21
51080: PUSH
51081: LD_INT 3
51083: PUSH
51084: EMPTY
51085: LIST
51086: LIST
51087: PUSH
51088: EMPTY
51089: LIST
51090: LIST
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PPUSH
51096: CALL_OW 69
51100: ST_TO_ADDR
// for i in mines do
51101: LD_ADDR_VAR 0 4
51105: PUSH
51106: LD_VAR 0 2
51110: PUSH
51111: FOR_IN
51112: IFFALSE 51200
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51114: LD_VAR 0 4
51118: PUSH
51119: LD_INT 1
51121: ARRAY
51122: PPUSH
51123: LD_VAR 0 4
51127: PUSH
51128: LD_INT 2
51130: ARRAY
51131: PPUSH
51132: CALL_OW 458
51136: NOT
51137: IFFALSE 51141
// continue ;
51139: GO 51111
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51141: LD_VAR 0 4
51145: PUSH
51146: LD_INT 1
51148: ARRAY
51149: PPUSH
51150: LD_VAR 0 4
51154: PUSH
51155: LD_INT 2
51157: ARRAY
51158: PPUSH
51159: CALL_OW 428
51163: PUSH
51164: LD_VAR 0 5
51168: IN
51169: IFFALSE 51198
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51171: LD_VAR 0 4
51175: PUSH
51176: LD_INT 1
51178: ARRAY
51179: PPUSH
51180: LD_VAR 0 4
51184: PUSH
51185: LD_INT 2
51187: ARRAY
51188: PPUSH
51189: LD_VAR 0 1
51193: PPUSH
51194: CALL_OW 456
// end ;
51198: GO 51111
51200: POP
51201: POP
// end ;
51202: LD_VAR 0 3
51206: RET
// export function Count ( array ) ; begin
51207: LD_INT 0
51209: PPUSH
// result := array + 0 ;
51210: LD_ADDR_VAR 0 2
51214: PUSH
51215: LD_VAR 0 1
51219: PUSH
51220: LD_INT 0
51222: PLUS
51223: ST_TO_ADDR
// end ;
51224: LD_VAR 0 2
51228: RET
// export function IsEmpty ( building ) ; begin
51229: LD_INT 0
51231: PPUSH
// if not building then
51232: LD_VAR 0 1
51236: NOT
51237: IFFALSE 51241
// exit ;
51239: GO 51284
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51241: LD_ADDR_VAR 0 2
51245: PUSH
51246: LD_VAR 0 1
51250: PUSH
51251: LD_INT 22
51253: PUSH
51254: LD_VAR 0 1
51258: PPUSH
51259: CALL_OW 255
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 58
51270: PUSH
51271: EMPTY
51272: LIST
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PPUSH
51278: CALL_OW 69
51282: IN
51283: ST_TO_ADDR
// end ;
51284: LD_VAR 0 2
51288: RET
// export function IsNotFull ( building ) ; var places ; begin
51289: LD_INT 0
51291: PPUSH
51292: PPUSH
// if not building then
51293: LD_VAR 0 1
51297: NOT
51298: IFFALSE 51302
// exit ;
51300: GO 51330
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51302: LD_ADDR_VAR 0 2
51306: PUSH
51307: LD_VAR 0 1
51311: PPUSH
51312: LD_INT 3
51314: PUSH
51315: LD_INT 62
51317: PUSH
51318: EMPTY
51319: LIST
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PPUSH
51325: CALL_OW 72
51329: ST_TO_ADDR
// end ;
51330: LD_VAR 0 2
51334: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51335: LD_INT 0
51337: PPUSH
51338: PPUSH
51339: PPUSH
51340: PPUSH
// tmp := [ ] ;
51341: LD_ADDR_VAR 0 3
51345: PUSH
51346: EMPTY
51347: ST_TO_ADDR
// list := [ ] ;
51348: LD_ADDR_VAR 0 5
51352: PUSH
51353: EMPTY
51354: ST_TO_ADDR
// for i = 16 to 25 do
51355: LD_ADDR_VAR 0 4
51359: PUSH
51360: DOUBLE
51361: LD_INT 16
51363: DEC
51364: ST_TO_ADDR
51365: LD_INT 25
51367: PUSH
51368: FOR_TO
51369: IFFALSE 51442
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51371: LD_ADDR_VAR 0 3
51375: PUSH
51376: LD_VAR 0 3
51380: PUSH
51381: LD_INT 22
51383: PUSH
51384: LD_VAR 0 1
51388: PPUSH
51389: CALL_OW 255
51393: PUSH
51394: EMPTY
51395: LIST
51396: LIST
51397: PUSH
51398: LD_INT 91
51400: PUSH
51401: LD_VAR 0 1
51405: PUSH
51406: LD_INT 6
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: LIST
51413: PUSH
51414: LD_INT 30
51416: PUSH
51417: LD_VAR 0 4
51421: PUSH
51422: EMPTY
51423: LIST
51424: LIST
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: LIST
51430: PUSH
51431: EMPTY
51432: LIST
51433: PPUSH
51434: CALL_OW 69
51438: ADD
51439: ST_TO_ADDR
51440: GO 51368
51442: POP
51443: POP
// for i = 1 to tmp do
51444: LD_ADDR_VAR 0 4
51448: PUSH
51449: DOUBLE
51450: LD_INT 1
51452: DEC
51453: ST_TO_ADDR
51454: LD_VAR 0 3
51458: PUSH
51459: FOR_TO
51460: IFFALSE 51548
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51462: LD_ADDR_VAR 0 5
51466: PUSH
51467: LD_VAR 0 5
51471: PUSH
51472: LD_VAR 0 3
51476: PUSH
51477: LD_VAR 0 4
51481: ARRAY
51482: PPUSH
51483: CALL_OW 266
51487: PUSH
51488: LD_VAR 0 3
51492: PUSH
51493: LD_VAR 0 4
51497: ARRAY
51498: PPUSH
51499: CALL_OW 250
51503: PUSH
51504: LD_VAR 0 3
51508: PUSH
51509: LD_VAR 0 4
51513: ARRAY
51514: PPUSH
51515: CALL_OW 251
51519: PUSH
51520: LD_VAR 0 3
51524: PUSH
51525: LD_VAR 0 4
51529: ARRAY
51530: PPUSH
51531: CALL_OW 254
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: PUSH
51542: EMPTY
51543: LIST
51544: ADD
51545: ST_TO_ADDR
51546: GO 51459
51548: POP
51549: POP
// result := list ;
51550: LD_ADDR_VAR 0 2
51554: PUSH
51555: LD_VAR 0 5
51559: ST_TO_ADDR
// end ;
51560: LD_VAR 0 2
51564: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51565: LD_INT 0
51567: PPUSH
51568: PPUSH
51569: PPUSH
51570: PPUSH
51571: PPUSH
51572: PPUSH
51573: PPUSH
// if not factory then
51574: LD_VAR 0 1
51578: NOT
51579: IFFALSE 51583
// exit ;
51581: GO 52176
// if control = control_apeman then
51583: LD_VAR 0 4
51587: PUSH
51588: LD_INT 5
51590: EQUAL
51591: IFFALSE 51700
// begin tmp := UnitsInside ( factory ) ;
51593: LD_ADDR_VAR 0 8
51597: PUSH
51598: LD_VAR 0 1
51602: PPUSH
51603: CALL_OW 313
51607: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51608: LD_VAR 0 8
51612: PPUSH
51613: LD_INT 25
51615: PUSH
51616: LD_INT 12
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PPUSH
51623: CALL_OW 72
51627: NOT
51628: IFFALSE 51638
// control := control_manual ;
51630: LD_ADDR_VAR 0 4
51634: PUSH
51635: LD_INT 1
51637: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51638: LD_ADDR_VAR 0 8
51642: PUSH
51643: LD_VAR 0 1
51647: PPUSH
51648: CALL 51335 0 1
51652: ST_TO_ADDR
// if tmp then
51653: LD_VAR 0 8
51657: IFFALSE 51700
// begin for i in tmp do
51659: LD_ADDR_VAR 0 7
51663: PUSH
51664: LD_VAR 0 8
51668: PUSH
51669: FOR_IN
51670: IFFALSE 51698
// if i [ 1 ] = b_ext_radio then
51672: LD_VAR 0 7
51676: PUSH
51677: LD_INT 1
51679: ARRAY
51680: PUSH
51681: LD_INT 22
51683: EQUAL
51684: IFFALSE 51696
// begin control := control_remote ;
51686: LD_ADDR_VAR 0 4
51690: PUSH
51691: LD_INT 2
51693: ST_TO_ADDR
// break ;
51694: GO 51698
// end ;
51696: GO 51669
51698: POP
51699: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51700: LD_VAR 0 1
51704: PPUSH
51705: LD_VAR 0 2
51709: PPUSH
51710: LD_VAR 0 3
51714: PPUSH
51715: LD_VAR 0 4
51719: PPUSH
51720: LD_VAR 0 5
51724: PPUSH
51725: CALL_OW 448
51729: IFFALSE 51764
// begin result := [ chassis , engine , control , weapon ] ;
51731: LD_ADDR_VAR 0 6
51735: PUSH
51736: LD_VAR 0 2
51740: PUSH
51741: LD_VAR 0 3
51745: PUSH
51746: LD_VAR 0 4
51750: PUSH
51751: LD_VAR 0 5
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: ST_TO_ADDR
// exit ;
51762: GO 52176
// end ; _chassis := AvailableChassisList ( factory ) ;
51764: LD_ADDR_VAR 0 9
51768: PUSH
51769: LD_VAR 0 1
51773: PPUSH
51774: CALL_OW 475
51778: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51779: LD_ADDR_VAR 0 11
51783: PUSH
51784: LD_VAR 0 1
51788: PPUSH
51789: CALL_OW 476
51793: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51794: LD_ADDR_VAR 0 12
51798: PUSH
51799: LD_VAR 0 1
51803: PPUSH
51804: CALL_OW 477
51808: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51809: LD_ADDR_VAR 0 10
51813: PUSH
51814: LD_VAR 0 1
51818: PPUSH
51819: CALL_OW 478
51823: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51824: LD_VAR 0 9
51828: NOT
51829: PUSH
51830: LD_VAR 0 11
51834: NOT
51835: OR
51836: PUSH
51837: LD_VAR 0 12
51841: NOT
51842: OR
51843: PUSH
51844: LD_VAR 0 10
51848: NOT
51849: OR
51850: IFFALSE 51885
// begin result := [ chassis , engine , control , weapon ] ;
51852: LD_ADDR_VAR 0 6
51856: PUSH
51857: LD_VAR 0 2
51861: PUSH
51862: LD_VAR 0 3
51866: PUSH
51867: LD_VAR 0 4
51871: PUSH
51872: LD_VAR 0 5
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: LIST
51881: LIST
51882: ST_TO_ADDR
// exit ;
51883: GO 52176
// end ; if not chassis in _chassis then
51885: LD_VAR 0 2
51889: PUSH
51890: LD_VAR 0 9
51894: IN
51895: NOT
51896: IFFALSE 51922
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51898: LD_ADDR_VAR 0 2
51902: PUSH
51903: LD_VAR 0 9
51907: PUSH
51908: LD_INT 1
51910: PPUSH
51911: LD_VAR 0 9
51915: PPUSH
51916: CALL_OW 12
51920: ARRAY
51921: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51922: LD_VAR 0 2
51926: PPUSH
51927: LD_VAR 0 3
51931: PPUSH
51932: CALL 52181 0 2
51936: NOT
51937: IFFALSE 51996
// repeat engine := _engine [ 1 ] ;
51939: LD_ADDR_VAR 0 3
51943: PUSH
51944: LD_VAR 0 11
51948: PUSH
51949: LD_INT 1
51951: ARRAY
51952: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51953: LD_ADDR_VAR 0 11
51957: PUSH
51958: LD_VAR 0 11
51962: PPUSH
51963: LD_INT 1
51965: PPUSH
51966: CALL_OW 3
51970: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51971: LD_VAR 0 2
51975: PPUSH
51976: LD_VAR 0 3
51980: PPUSH
51981: CALL 52181 0 2
51985: PUSH
51986: LD_VAR 0 11
51990: PUSH
51991: EMPTY
51992: EQUAL
51993: OR
51994: IFFALSE 51939
// if not control in _control then
51996: LD_VAR 0 4
52000: PUSH
52001: LD_VAR 0 12
52005: IN
52006: NOT
52007: IFFALSE 52033
// control := _control [ rand ( 1 , _control ) ] ;
52009: LD_ADDR_VAR 0 4
52013: PUSH
52014: LD_VAR 0 12
52018: PUSH
52019: LD_INT 1
52021: PPUSH
52022: LD_VAR 0 12
52026: PPUSH
52027: CALL_OW 12
52031: ARRAY
52032: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52033: LD_VAR 0 2
52037: PPUSH
52038: LD_VAR 0 5
52042: PPUSH
52043: CALL 52401 0 2
52047: NOT
52048: IFFALSE 52107
// repeat weapon := _weapon [ 1 ] ;
52050: LD_ADDR_VAR 0 5
52054: PUSH
52055: LD_VAR 0 10
52059: PUSH
52060: LD_INT 1
52062: ARRAY
52063: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52064: LD_ADDR_VAR 0 10
52068: PUSH
52069: LD_VAR 0 10
52073: PPUSH
52074: LD_INT 1
52076: PPUSH
52077: CALL_OW 3
52081: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52082: LD_VAR 0 2
52086: PPUSH
52087: LD_VAR 0 5
52091: PPUSH
52092: CALL 52401 0 2
52096: PUSH
52097: LD_VAR 0 10
52101: PUSH
52102: EMPTY
52103: EQUAL
52104: OR
52105: IFFALSE 52050
// result := [ ] ;
52107: LD_ADDR_VAR 0 6
52111: PUSH
52112: EMPTY
52113: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52114: LD_VAR 0 1
52118: PPUSH
52119: LD_VAR 0 2
52123: PPUSH
52124: LD_VAR 0 3
52128: PPUSH
52129: LD_VAR 0 4
52133: PPUSH
52134: LD_VAR 0 5
52138: PPUSH
52139: CALL_OW 448
52143: IFFALSE 52176
// result := [ chassis , engine , control , weapon ] ;
52145: LD_ADDR_VAR 0 6
52149: PUSH
52150: LD_VAR 0 2
52154: PUSH
52155: LD_VAR 0 3
52159: PUSH
52160: LD_VAR 0 4
52164: PUSH
52165: LD_VAR 0 5
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: ST_TO_ADDR
// end ;
52176: LD_VAR 0 6
52180: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52181: LD_INT 0
52183: PPUSH
// if not chassis or not engine then
52184: LD_VAR 0 1
52188: NOT
52189: PUSH
52190: LD_VAR 0 2
52194: NOT
52195: OR
52196: IFFALSE 52200
// exit ;
52198: GO 52396
// case engine of engine_solar :
52200: LD_VAR 0 2
52204: PUSH
52205: LD_INT 2
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52213
52211: GO 52251
52213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_INT 11
52221: PUSH
52222: LD_INT 12
52224: PUSH
52225: LD_INT 13
52227: PUSH
52228: LD_INT 14
52230: PUSH
52231: LD_INT 1
52233: PUSH
52234: LD_INT 2
52236: PUSH
52237: LD_INT 3
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: ST_TO_ADDR
52249: GO 52380
52251: LD_INT 1
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52259
52257: GO 52321
52259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52260: LD_ADDR_VAR 0 3
52264: PUSH
52265: LD_INT 11
52267: PUSH
52268: LD_INT 12
52270: PUSH
52271: LD_INT 13
52273: PUSH
52274: LD_INT 14
52276: PUSH
52277: LD_INT 1
52279: PUSH
52280: LD_INT 2
52282: PUSH
52283: LD_INT 3
52285: PUSH
52286: LD_INT 4
52288: PUSH
52289: LD_INT 5
52291: PUSH
52292: LD_INT 21
52294: PUSH
52295: LD_INT 23
52297: PUSH
52298: LD_INT 22
52300: PUSH
52301: LD_INT 24
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: ST_TO_ADDR
52319: GO 52380
52321: LD_INT 3
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52329
52327: GO 52379
52329: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52330: LD_ADDR_VAR 0 3
52334: PUSH
52335: LD_INT 13
52337: PUSH
52338: LD_INT 14
52340: PUSH
52341: LD_INT 2
52343: PUSH
52344: LD_INT 3
52346: PUSH
52347: LD_INT 4
52349: PUSH
52350: LD_INT 5
52352: PUSH
52353: LD_INT 21
52355: PUSH
52356: LD_INT 22
52358: PUSH
52359: LD_INT 23
52361: PUSH
52362: LD_INT 24
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: LIST
52369: LIST
52370: LIST
52371: LIST
52372: LIST
52373: LIST
52374: LIST
52375: LIST
52376: ST_TO_ADDR
52377: GO 52380
52379: POP
// result := ( chassis in result ) ;
52380: LD_ADDR_VAR 0 3
52384: PUSH
52385: LD_VAR 0 1
52389: PUSH
52390: LD_VAR 0 3
52394: IN
52395: ST_TO_ADDR
// end ;
52396: LD_VAR 0 3
52400: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52401: LD_INT 0
52403: PPUSH
// if not chassis or not weapon then
52404: LD_VAR 0 1
52408: NOT
52409: PUSH
52410: LD_VAR 0 2
52414: NOT
52415: OR
52416: IFFALSE 52420
// exit ;
52418: GO 53480
// case weapon of us_machine_gun :
52420: LD_VAR 0 2
52424: PUSH
52425: LD_INT 2
52427: DOUBLE
52428: EQUAL
52429: IFTRUE 52433
52431: GO 52463
52433: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52434: LD_ADDR_VAR 0 3
52438: PUSH
52439: LD_INT 1
52441: PUSH
52442: LD_INT 2
52444: PUSH
52445: LD_INT 3
52447: PUSH
52448: LD_INT 4
52450: PUSH
52451: LD_INT 5
52453: PUSH
52454: EMPTY
52455: LIST
52456: LIST
52457: LIST
52458: LIST
52459: LIST
52460: ST_TO_ADDR
52461: GO 53464
52463: LD_INT 3
52465: DOUBLE
52466: EQUAL
52467: IFTRUE 52471
52469: GO 52501
52471: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52472: LD_ADDR_VAR 0 3
52476: PUSH
52477: LD_INT 1
52479: PUSH
52480: LD_INT 2
52482: PUSH
52483: LD_INT 3
52485: PUSH
52486: LD_INT 4
52488: PUSH
52489: LD_INT 5
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: ST_TO_ADDR
52499: GO 53464
52501: LD_INT 11
52503: DOUBLE
52504: EQUAL
52505: IFTRUE 52509
52507: GO 52539
52509: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52510: LD_ADDR_VAR 0 3
52514: PUSH
52515: LD_INT 1
52517: PUSH
52518: LD_INT 2
52520: PUSH
52521: LD_INT 3
52523: PUSH
52524: LD_INT 4
52526: PUSH
52527: LD_INT 5
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: ST_TO_ADDR
52537: GO 53464
52539: LD_INT 4
52541: DOUBLE
52542: EQUAL
52543: IFTRUE 52547
52545: GO 52573
52547: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52548: LD_ADDR_VAR 0 3
52552: PUSH
52553: LD_INT 2
52555: PUSH
52556: LD_INT 3
52558: PUSH
52559: LD_INT 4
52561: PUSH
52562: LD_INT 5
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: ST_TO_ADDR
52571: GO 53464
52573: LD_INT 5
52575: DOUBLE
52576: EQUAL
52577: IFTRUE 52581
52579: GO 52607
52581: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52582: LD_ADDR_VAR 0 3
52586: PUSH
52587: LD_INT 2
52589: PUSH
52590: LD_INT 3
52592: PUSH
52593: LD_INT 4
52595: PUSH
52596: LD_INT 5
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: ST_TO_ADDR
52605: GO 53464
52607: LD_INT 9
52609: DOUBLE
52610: EQUAL
52611: IFTRUE 52615
52613: GO 52641
52615: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52616: LD_ADDR_VAR 0 3
52620: PUSH
52621: LD_INT 2
52623: PUSH
52624: LD_INT 3
52626: PUSH
52627: LD_INT 4
52629: PUSH
52630: LD_INT 5
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: ST_TO_ADDR
52639: GO 53464
52641: LD_INT 7
52643: DOUBLE
52644: EQUAL
52645: IFTRUE 52649
52647: GO 52675
52649: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52650: LD_ADDR_VAR 0 3
52654: PUSH
52655: LD_INT 2
52657: PUSH
52658: LD_INT 3
52660: PUSH
52661: LD_INT 4
52663: PUSH
52664: LD_INT 5
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: ST_TO_ADDR
52673: GO 53464
52675: LD_INT 12
52677: DOUBLE
52678: EQUAL
52679: IFTRUE 52683
52681: GO 52709
52683: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52684: LD_ADDR_VAR 0 3
52688: PUSH
52689: LD_INT 2
52691: PUSH
52692: LD_INT 3
52694: PUSH
52695: LD_INT 4
52697: PUSH
52698: LD_INT 5
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: LIST
52705: LIST
52706: ST_TO_ADDR
52707: GO 53464
52709: LD_INT 13
52711: DOUBLE
52712: EQUAL
52713: IFTRUE 52717
52715: GO 52743
52717: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52718: LD_ADDR_VAR 0 3
52722: PUSH
52723: LD_INT 2
52725: PUSH
52726: LD_INT 3
52728: PUSH
52729: LD_INT 4
52731: PUSH
52732: LD_INT 5
52734: PUSH
52735: EMPTY
52736: LIST
52737: LIST
52738: LIST
52739: LIST
52740: ST_TO_ADDR
52741: GO 53464
52743: LD_INT 14
52745: DOUBLE
52746: EQUAL
52747: IFTRUE 52751
52749: GO 52769
52751: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52752: LD_ADDR_VAR 0 3
52756: PUSH
52757: LD_INT 4
52759: PUSH
52760: LD_INT 5
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: ST_TO_ADDR
52767: GO 53464
52769: LD_INT 6
52771: DOUBLE
52772: EQUAL
52773: IFTRUE 52777
52775: GO 52795
52777: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52778: LD_ADDR_VAR 0 3
52782: PUSH
52783: LD_INT 4
52785: PUSH
52786: LD_INT 5
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: ST_TO_ADDR
52793: GO 53464
52795: LD_INT 10
52797: DOUBLE
52798: EQUAL
52799: IFTRUE 52803
52801: GO 52821
52803: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52804: LD_ADDR_VAR 0 3
52808: PUSH
52809: LD_INT 4
52811: PUSH
52812: LD_INT 5
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: ST_TO_ADDR
52819: GO 53464
52821: LD_INT 22
52823: DOUBLE
52824: EQUAL
52825: IFTRUE 52829
52827: GO 52855
52829: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52830: LD_ADDR_VAR 0 3
52834: PUSH
52835: LD_INT 11
52837: PUSH
52838: LD_INT 12
52840: PUSH
52841: LD_INT 13
52843: PUSH
52844: LD_INT 14
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: LIST
52851: LIST
52852: ST_TO_ADDR
52853: GO 53464
52855: LD_INT 23
52857: DOUBLE
52858: EQUAL
52859: IFTRUE 52863
52861: GO 52889
52863: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52864: LD_ADDR_VAR 0 3
52868: PUSH
52869: LD_INT 11
52871: PUSH
52872: LD_INT 12
52874: PUSH
52875: LD_INT 13
52877: PUSH
52878: LD_INT 14
52880: PUSH
52881: EMPTY
52882: LIST
52883: LIST
52884: LIST
52885: LIST
52886: ST_TO_ADDR
52887: GO 53464
52889: LD_INT 24
52891: DOUBLE
52892: EQUAL
52893: IFTRUE 52897
52895: GO 52923
52897: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52898: LD_ADDR_VAR 0 3
52902: PUSH
52903: LD_INT 11
52905: PUSH
52906: LD_INT 12
52908: PUSH
52909: LD_INT 13
52911: PUSH
52912: LD_INT 14
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: LIST
52920: ST_TO_ADDR
52921: GO 53464
52923: LD_INT 30
52925: DOUBLE
52926: EQUAL
52927: IFTRUE 52931
52929: GO 52957
52931: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52932: LD_ADDR_VAR 0 3
52936: PUSH
52937: LD_INT 11
52939: PUSH
52940: LD_INT 12
52942: PUSH
52943: LD_INT 13
52945: PUSH
52946: LD_INT 14
52948: PUSH
52949: EMPTY
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: ST_TO_ADDR
52955: GO 53464
52957: LD_INT 25
52959: DOUBLE
52960: EQUAL
52961: IFTRUE 52965
52963: GO 52983
52965: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52966: LD_ADDR_VAR 0 3
52970: PUSH
52971: LD_INT 13
52973: PUSH
52974: LD_INT 14
52976: PUSH
52977: EMPTY
52978: LIST
52979: LIST
52980: ST_TO_ADDR
52981: GO 53464
52983: LD_INT 27
52985: DOUBLE
52986: EQUAL
52987: IFTRUE 52991
52989: GO 53009
52991: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52992: LD_ADDR_VAR 0 3
52996: PUSH
52997: LD_INT 13
52999: PUSH
53000: LD_INT 14
53002: PUSH
53003: EMPTY
53004: LIST
53005: LIST
53006: ST_TO_ADDR
53007: GO 53464
53009: LD_INT 92
53011: DOUBLE
53012: EQUAL
53013: IFTRUE 53017
53015: GO 53043
53017: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53018: LD_ADDR_VAR 0 3
53022: PUSH
53023: LD_INT 11
53025: PUSH
53026: LD_INT 12
53028: PUSH
53029: LD_INT 13
53031: PUSH
53032: LD_INT 14
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: ST_TO_ADDR
53041: GO 53464
53043: LD_INT 28
53045: DOUBLE
53046: EQUAL
53047: IFTRUE 53051
53049: GO 53069
53051: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53052: LD_ADDR_VAR 0 3
53056: PUSH
53057: LD_INT 13
53059: PUSH
53060: LD_INT 14
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: ST_TO_ADDR
53067: GO 53464
53069: LD_INT 29
53071: DOUBLE
53072: EQUAL
53073: IFTRUE 53077
53075: GO 53095
53077: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53078: LD_ADDR_VAR 0 3
53082: PUSH
53083: LD_INT 13
53085: PUSH
53086: LD_INT 14
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: ST_TO_ADDR
53093: GO 53464
53095: LD_INT 31
53097: DOUBLE
53098: EQUAL
53099: IFTRUE 53103
53101: GO 53121
53103: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53104: LD_ADDR_VAR 0 3
53108: PUSH
53109: LD_INT 13
53111: PUSH
53112: LD_INT 14
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: ST_TO_ADDR
53119: GO 53464
53121: LD_INT 26
53123: DOUBLE
53124: EQUAL
53125: IFTRUE 53129
53127: GO 53147
53129: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53130: LD_ADDR_VAR 0 3
53134: PUSH
53135: LD_INT 13
53137: PUSH
53138: LD_INT 14
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: ST_TO_ADDR
53145: GO 53464
53147: LD_INT 42
53149: DOUBLE
53150: EQUAL
53151: IFTRUE 53155
53153: GO 53181
53155: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53156: LD_ADDR_VAR 0 3
53160: PUSH
53161: LD_INT 21
53163: PUSH
53164: LD_INT 22
53166: PUSH
53167: LD_INT 23
53169: PUSH
53170: LD_INT 24
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: LIST
53177: LIST
53178: ST_TO_ADDR
53179: GO 53464
53181: LD_INT 43
53183: DOUBLE
53184: EQUAL
53185: IFTRUE 53189
53187: GO 53215
53189: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53190: LD_ADDR_VAR 0 3
53194: PUSH
53195: LD_INT 21
53197: PUSH
53198: LD_INT 22
53200: PUSH
53201: LD_INT 23
53203: PUSH
53204: LD_INT 24
53206: PUSH
53207: EMPTY
53208: LIST
53209: LIST
53210: LIST
53211: LIST
53212: ST_TO_ADDR
53213: GO 53464
53215: LD_INT 44
53217: DOUBLE
53218: EQUAL
53219: IFTRUE 53223
53221: GO 53249
53223: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53224: LD_ADDR_VAR 0 3
53228: PUSH
53229: LD_INT 21
53231: PUSH
53232: LD_INT 22
53234: PUSH
53235: LD_INT 23
53237: PUSH
53238: LD_INT 24
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: LIST
53245: LIST
53246: ST_TO_ADDR
53247: GO 53464
53249: LD_INT 45
53251: DOUBLE
53252: EQUAL
53253: IFTRUE 53257
53255: GO 53283
53257: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53258: LD_ADDR_VAR 0 3
53262: PUSH
53263: LD_INT 21
53265: PUSH
53266: LD_INT 22
53268: PUSH
53269: LD_INT 23
53271: PUSH
53272: LD_INT 24
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: LIST
53279: LIST
53280: ST_TO_ADDR
53281: GO 53464
53283: LD_INT 49
53285: DOUBLE
53286: EQUAL
53287: IFTRUE 53291
53289: GO 53317
53291: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53292: LD_ADDR_VAR 0 3
53296: PUSH
53297: LD_INT 21
53299: PUSH
53300: LD_INT 22
53302: PUSH
53303: LD_INT 23
53305: PUSH
53306: LD_INT 24
53308: PUSH
53309: EMPTY
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: ST_TO_ADDR
53315: GO 53464
53317: LD_INT 51
53319: DOUBLE
53320: EQUAL
53321: IFTRUE 53325
53323: GO 53351
53325: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53326: LD_ADDR_VAR 0 3
53330: PUSH
53331: LD_INT 21
53333: PUSH
53334: LD_INT 22
53336: PUSH
53337: LD_INT 23
53339: PUSH
53340: LD_INT 24
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: ST_TO_ADDR
53349: GO 53464
53351: LD_INT 52
53353: DOUBLE
53354: EQUAL
53355: IFTRUE 53359
53357: GO 53385
53359: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53360: LD_ADDR_VAR 0 3
53364: PUSH
53365: LD_INT 21
53367: PUSH
53368: LD_INT 22
53370: PUSH
53371: LD_INT 23
53373: PUSH
53374: LD_INT 24
53376: PUSH
53377: EMPTY
53378: LIST
53379: LIST
53380: LIST
53381: LIST
53382: ST_TO_ADDR
53383: GO 53464
53385: LD_INT 53
53387: DOUBLE
53388: EQUAL
53389: IFTRUE 53393
53391: GO 53411
53393: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53394: LD_ADDR_VAR 0 3
53398: PUSH
53399: LD_INT 23
53401: PUSH
53402: LD_INT 24
53404: PUSH
53405: EMPTY
53406: LIST
53407: LIST
53408: ST_TO_ADDR
53409: GO 53464
53411: LD_INT 46
53413: DOUBLE
53414: EQUAL
53415: IFTRUE 53419
53417: GO 53437
53419: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53420: LD_ADDR_VAR 0 3
53424: PUSH
53425: LD_INT 23
53427: PUSH
53428: LD_INT 24
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: ST_TO_ADDR
53435: GO 53464
53437: LD_INT 47
53439: DOUBLE
53440: EQUAL
53441: IFTRUE 53445
53443: GO 53463
53445: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53446: LD_ADDR_VAR 0 3
53450: PUSH
53451: LD_INT 23
53453: PUSH
53454: LD_INT 24
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: ST_TO_ADDR
53461: GO 53464
53463: POP
// result := ( chassis in result ) ;
53464: LD_ADDR_VAR 0 3
53468: PUSH
53469: LD_VAR 0 1
53473: PUSH
53474: LD_VAR 0 3
53478: IN
53479: ST_TO_ADDR
// end ;
53480: LD_VAR 0 3
53484: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53485: LD_INT 0
53487: PPUSH
53488: PPUSH
53489: PPUSH
53490: PPUSH
53491: PPUSH
53492: PPUSH
53493: PPUSH
// result := array ;
53494: LD_ADDR_VAR 0 5
53498: PUSH
53499: LD_VAR 0 1
53503: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53504: LD_VAR 0 1
53508: NOT
53509: PUSH
53510: LD_VAR 0 2
53514: NOT
53515: OR
53516: PUSH
53517: LD_VAR 0 3
53521: NOT
53522: OR
53523: PUSH
53524: LD_VAR 0 2
53528: PUSH
53529: LD_VAR 0 1
53533: GREATER
53534: OR
53535: PUSH
53536: LD_VAR 0 3
53540: PUSH
53541: LD_VAR 0 1
53545: GREATER
53546: OR
53547: IFFALSE 53551
// exit ;
53549: GO 53847
// if direction then
53551: LD_VAR 0 4
53555: IFFALSE 53619
// begin d := 1 ;
53557: LD_ADDR_VAR 0 9
53561: PUSH
53562: LD_INT 1
53564: ST_TO_ADDR
// if i_from > i_to then
53565: LD_VAR 0 2
53569: PUSH
53570: LD_VAR 0 3
53574: GREATER
53575: IFFALSE 53601
// length := ( array - i_from ) + i_to else
53577: LD_ADDR_VAR 0 11
53581: PUSH
53582: LD_VAR 0 1
53586: PUSH
53587: LD_VAR 0 2
53591: MINUS
53592: PUSH
53593: LD_VAR 0 3
53597: PLUS
53598: ST_TO_ADDR
53599: GO 53617
// length := i_to - i_from ;
53601: LD_ADDR_VAR 0 11
53605: PUSH
53606: LD_VAR 0 3
53610: PUSH
53611: LD_VAR 0 2
53615: MINUS
53616: ST_TO_ADDR
// end else
53617: GO 53680
// begin d := - 1 ;
53619: LD_ADDR_VAR 0 9
53623: PUSH
53624: LD_INT 1
53626: NEG
53627: ST_TO_ADDR
// if i_from > i_to then
53628: LD_VAR 0 2
53632: PUSH
53633: LD_VAR 0 3
53637: GREATER
53638: IFFALSE 53658
// length := i_from - i_to else
53640: LD_ADDR_VAR 0 11
53644: PUSH
53645: LD_VAR 0 2
53649: PUSH
53650: LD_VAR 0 3
53654: MINUS
53655: ST_TO_ADDR
53656: GO 53680
// length := ( array - i_to ) + i_from ;
53658: LD_ADDR_VAR 0 11
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_VAR 0 3
53672: MINUS
53673: PUSH
53674: LD_VAR 0 2
53678: PLUS
53679: ST_TO_ADDR
// end ; if not length then
53680: LD_VAR 0 11
53684: NOT
53685: IFFALSE 53689
// exit ;
53687: GO 53847
// tmp := array ;
53689: LD_ADDR_VAR 0 10
53693: PUSH
53694: LD_VAR 0 1
53698: ST_TO_ADDR
// for i = 1 to length do
53699: LD_ADDR_VAR 0 6
53703: PUSH
53704: DOUBLE
53705: LD_INT 1
53707: DEC
53708: ST_TO_ADDR
53709: LD_VAR 0 11
53713: PUSH
53714: FOR_TO
53715: IFFALSE 53835
// begin for j = 1 to array do
53717: LD_ADDR_VAR 0 7
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_VAR 0 1
53731: PUSH
53732: FOR_TO
53733: IFFALSE 53821
// begin k := j + d ;
53735: LD_ADDR_VAR 0 8
53739: PUSH
53740: LD_VAR 0 7
53744: PUSH
53745: LD_VAR 0 9
53749: PLUS
53750: ST_TO_ADDR
// if k > array then
53751: LD_VAR 0 8
53755: PUSH
53756: LD_VAR 0 1
53760: GREATER
53761: IFFALSE 53771
// k := 1 ;
53763: LD_ADDR_VAR 0 8
53767: PUSH
53768: LD_INT 1
53770: ST_TO_ADDR
// if not k then
53771: LD_VAR 0 8
53775: NOT
53776: IFFALSE 53788
// k := array ;
53778: LD_ADDR_VAR 0 8
53782: PUSH
53783: LD_VAR 0 1
53787: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53788: LD_ADDR_VAR 0 10
53792: PUSH
53793: LD_VAR 0 10
53797: PPUSH
53798: LD_VAR 0 8
53802: PPUSH
53803: LD_VAR 0 1
53807: PUSH
53808: LD_VAR 0 7
53812: ARRAY
53813: PPUSH
53814: CALL_OW 1
53818: ST_TO_ADDR
// end ;
53819: GO 53732
53821: POP
53822: POP
// array := tmp ;
53823: LD_ADDR_VAR 0 1
53827: PUSH
53828: LD_VAR 0 10
53832: ST_TO_ADDR
// end ;
53833: GO 53714
53835: POP
53836: POP
// result := array ;
53837: LD_ADDR_VAR 0 5
53841: PUSH
53842: LD_VAR 0 1
53846: ST_TO_ADDR
// end ;
53847: LD_VAR 0 5
53851: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53852: LD_INT 0
53854: PPUSH
53855: PPUSH
// result := 0 ;
53856: LD_ADDR_VAR 0 3
53860: PUSH
53861: LD_INT 0
53863: ST_TO_ADDR
// if not array or not value in array then
53864: LD_VAR 0 1
53868: NOT
53869: PUSH
53870: LD_VAR 0 2
53874: PUSH
53875: LD_VAR 0 1
53879: IN
53880: NOT
53881: OR
53882: IFFALSE 53886
// exit ;
53884: GO 53940
// for i = 1 to array do
53886: LD_ADDR_VAR 0 4
53890: PUSH
53891: DOUBLE
53892: LD_INT 1
53894: DEC
53895: ST_TO_ADDR
53896: LD_VAR 0 1
53900: PUSH
53901: FOR_TO
53902: IFFALSE 53938
// if value = array [ i ] then
53904: LD_VAR 0 2
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 4
53918: ARRAY
53919: EQUAL
53920: IFFALSE 53936
// begin result := i ;
53922: LD_ADDR_VAR 0 3
53926: PUSH
53927: LD_VAR 0 4
53931: ST_TO_ADDR
// exit ;
53932: POP
53933: POP
53934: GO 53940
// end ;
53936: GO 53901
53938: POP
53939: POP
// end ;
53940: LD_VAR 0 3
53944: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53945: LD_INT 0
53947: PPUSH
// vc_chassis := chassis ;
53948: LD_ADDR_OWVAR 37
53952: PUSH
53953: LD_VAR 0 1
53957: ST_TO_ADDR
// vc_engine := engine ;
53958: LD_ADDR_OWVAR 39
53962: PUSH
53963: LD_VAR 0 2
53967: ST_TO_ADDR
// vc_control := control ;
53968: LD_ADDR_OWVAR 38
53972: PUSH
53973: LD_VAR 0 3
53977: ST_TO_ADDR
// vc_weapon := weapon ;
53978: LD_ADDR_OWVAR 40
53982: PUSH
53983: LD_VAR 0 4
53987: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53988: LD_ADDR_OWVAR 41
53992: PUSH
53993: LD_VAR 0 5
53997: ST_TO_ADDR
// end ;
53998: LD_VAR 0 6
54002: RET
// export function WantPlant ( unit ) ; var task ; begin
54003: LD_INT 0
54005: PPUSH
54006: PPUSH
// result := false ;
54007: LD_ADDR_VAR 0 2
54011: PUSH
54012: LD_INT 0
54014: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54015: LD_ADDR_VAR 0 3
54019: PUSH
54020: LD_VAR 0 1
54024: PPUSH
54025: CALL_OW 437
54029: ST_TO_ADDR
// if task then
54030: LD_VAR 0 3
54034: IFFALSE 54062
// if task [ 1 ] [ 1 ] = p then
54036: LD_VAR 0 3
54040: PUSH
54041: LD_INT 1
54043: ARRAY
54044: PUSH
54045: LD_INT 1
54047: ARRAY
54048: PUSH
54049: LD_STRING p
54051: EQUAL
54052: IFFALSE 54062
// result := true ;
54054: LD_ADDR_VAR 0 2
54058: PUSH
54059: LD_INT 1
54061: ST_TO_ADDR
// end ;
54062: LD_VAR 0 2
54066: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54067: LD_INT 0
54069: PPUSH
54070: PPUSH
54071: PPUSH
54072: PPUSH
// if pos < 1 then
54073: LD_VAR 0 2
54077: PUSH
54078: LD_INT 1
54080: LESS
54081: IFFALSE 54085
// exit ;
54083: GO 54388
// if pos = 1 then
54085: LD_VAR 0 2
54089: PUSH
54090: LD_INT 1
54092: EQUAL
54093: IFFALSE 54126
// result := Replace ( arr , pos [ 1 ] , value ) else
54095: LD_ADDR_VAR 0 4
54099: PUSH
54100: LD_VAR 0 1
54104: PPUSH
54105: LD_VAR 0 2
54109: PUSH
54110: LD_INT 1
54112: ARRAY
54113: PPUSH
54114: LD_VAR 0 3
54118: PPUSH
54119: CALL_OW 1
54123: ST_TO_ADDR
54124: GO 54388
// begin tmp := arr ;
54126: LD_ADDR_VAR 0 6
54130: PUSH
54131: LD_VAR 0 1
54135: ST_TO_ADDR
// s_arr := [ tmp ] ;
54136: LD_ADDR_VAR 0 7
54140: PUSH
54141: LD_VAR 0 6
54145: PUSH
54146: EMPTY
54147: LIST
54148: ST_TO_ADDR
// for i = 1 to pos - 1 do
54149: LD_ADDR_VAR 0 5
54153: PUSH
54154: DOUBLE
54155: LD_INT 1
54157: DEC
54158: ST_TO_ADDR
54159: LD_VAR 0 2
54163: PUSH
54164: LD_INT 1
54166: MINUS
54167: PUSH
54168: FOR_TO
54169: IFFALSE 54214
// begin tmp := tmp [ pos [ i ] ] ;
54171: LD_ADDR_VAR 0 6
54175: PUSH
54176: LD_VAR 0 6
54180: PUSH
54181: LD_VAR 0 2
54185: PUSH
54186: LD_VAR 0 5
54190: ARRAY
54191: ARRAY
54192: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54193: LD_ADDR_VAR 0 7
54197: PUSH
54198: LD_VAR 0 7
54202: PUSH
54203: LD_VAR 0 6
54207: PUSH
54208: EMPTY
54209: LIST
54210: ADD
54211: ST_TO_ADDR
// end ;
54212: GO 54168
54214: POP
54215: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54216: LD_ADDR_VAR 0 6
54220: PUSH
54221: LD_VAR 0 6
54225: PPUSH
54226: LD_VAR 0 2
54230: PUSH
54231: LD_VAR 0 2
54235: ARRAY
54236: PPUSH
54237: LD_VAR 0 3
54241: PPUSH
54242: CALL_OW 1
54246: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54247: LD_ADDR_VAR 0 7
54251: PUSH
54252: LD_VAR 0 7
54256: PPUSH
54257: LD_VAR 0 7
54261: PPUSH
54262: LD_VAR 0 6
54266: PPUSH
54267: CALL_OW 1
54271: ST_TO_ADDR
// for i = s_arr downto 2 do
54272: LD_ADDR_VAR 0 5
54276: PUSH
54277: DOUBLE
54278: LD_VAR 0 7
54282: INC
54283: ST_TO_ADDR
54284: LD_INT 2
54286: PUSH
54287: FOR_DOWNTO
54288: IFFALSE 54372
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54290: LD_ADDR_VAR 0 6
54294: PUSH
54295: LD_VAR 0 7
54299: PUSH
54300: LD_VAR 0 5
54304: PUSH
54305: LD_INT 1
54307: MINUS
54308: ARRAY
54309: PPUSH
54310: LD_VAR 0 2
54314: PUSH
54315: LD_VAR 0 5
54319: PUSH
54320: LD_INT 1
54322: MINUS
54323: ARRAY
54324: PPUSH
54325: LD_VAR 0 7
54329: PUSH
54330: LD_VAR 0 5
54334: ARRAY
54335: PPUSH
54336: CALL_OW 1
54340: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54341: LD_ADDR_VAR 0 7
54345: PUSH
54346: LD_VAR 0 7
54350: PPUSH
54351: LD_VAR 0 5
54355: PUSH
54356: LD_INT 1
54358: MINUS
54359: PPUSH
54360: LD_VAR 0 6
54364: PPUSH
54365: CALL_OW 1
54369: ST_TO_ADDR
// end ;
54370: GO 54287
54372: POP
54373: POP
// result := s_arr [ 1 ] ;
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: LD_VAR 0 7
54383: PUSH
54384: LD_INT 1
54386: ARRAY
54387: ST_TO_ADDR
// end ; end ;
54388: LD_VAR 0 4
54392: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54393: LD_INT 0
54395: PPUSH
54396: PPUSH
// if not list then
54397: LD_VAR 0 1
54401: NOT
54402: IFFALSE 54406
// exit ;
54404: GO 54497
// i := list [ pos1 ] ;
54406: LD_ADDR_VAR 0 5
54410: PUSH
54411: LD_VAR 0 1
54415: PUSH
54416: LD_VAR 0 2
54420: ARRAY
54421: ST_TO_ADDR
// if not i then
54422: LD_VAR 0 5
54426: NOT
54427: IFFALSE 54431
// exit ;
54429: GO 54497
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54431: LD_ADDR_VAR 0 1
54435: PUSH
54436: LD_VAR 0 1
54440: PPUSH
54441: LD_VAR 0 2
54445: PPUSH
54446: LD_VAR 0 1
54450: PUSH
54451: LD_VAR 0 3
54455: ARRAY
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54462: LD_ADDR_VAR 0 1
54466: PUSH
54467: LD_VAR 0 1
54471: PPUSH
54472: LD_VAR 0 3
54476: PPUSH
54477: LD_VAR 0 5
54481: PPUSH
54482: CALL_OW 1
54486: ST_TO_ADDR
// result := list ;
54487: LD_ADDR_VAR 0 4
54491: PUSH
54492: LD_VAR 0 1
54496: ST_TO_ADDR
// end ;
54497: LD_VAR 0 4
54501: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54502: LD_INT 0
54504: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54505: LD_ADDR_VAR 0 5
54509: PUSH
54510: LD_VAR 0 1
54514: PPUSH
54515: CALL_OW 250
54519: PPUSH
54520: LD_VAR 0 1
54524: PPUSH
54525: CALL_OW 251
54529: PPUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: LD_VAR 0 3
54539: PPUSH
54540: LD_VAR 0 4
54544: PPUSH
54545: CALL 54923 0 5
54549: ST_TO_ADDR
// end ;
54550: LD_VAR 0 5
54554: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
// if not list or not unit then
54561: LD_VAR 0 2
54565: NOT
54566: PUSH
54567: LD_VAR 0 1
54571: NOT
54572: OR
54573: IFFALSE 54577
// exit ;
54575: GO 54918
// result := [ ] ;
54577: LD_ADDR_VAR 0 5
54581: PUSH
54582: EMPTY
54583: ST_TO_ADDR
// for i in list do
54584: LD_ADDR_VAR 0 6
54588: PUSH
54589: LD_VAR 0 2
54593: PUSH
54594: FOR_IN
54595: IFFALSE 54813
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54597: LD_ADDR_VAR 0 8
54601: PUSH
54602: LD_VAR 0 1
54606: PPUSH
54607: LD_VAR 0 6
54611: PUSH
54612: LD_INT 1
54614: ARRAY
54615: PPUSH
54616: LD_VAR 0 6
54620: PUSH
54621: LD_INT 2
54623: ARRAY
54624: PPUSH
54625: CALL_OW 297
54629: ST_TO_ADDR
// if not Count ( result ) then
54630: LD_VAR 0 5
54634: PPUSH
54635: CALL 51207 0 1
54639: NOT
54640: IFFALSE 54673
// begin result := Join ( result , [ i , tmp ] ) ;
54642: LD_ADDR_VAR 0 5
54646: PUSH
54647: LD_VAR 0 5
54651: PPUSH
54652: LD_VAR 0 6
54656: PUSH
54657: LD_VAR 0 8
54661: PUSH
54662: EMPTY
54663: LIST
54664: LIST
54665: PPUSH
54666: CALL 86807 0 2
54670: ST_TO_ADDR
// continue ;
54671: GO 54594
// end ; if result [ result ] [ 2 ] <= tmp then
54673: LD_VAR 0 5
54677: PUSH
54678: LD_VAR 0 5
54682: ARRAY
54683: PUSH
54684: LD_INT 2
54686: ARRAY
54687: PUSH
54688: LD_VAR 0 8
54692: LESSEQUAL
54693: IFFALSE 54726
// result := Join ( result , [ i , tmp ] ) else
54695: LD_ADDR_VAR 0 5
54699: PUSH
54700: LD_VAR 0 5
54704: PPUSH
54705: LD_VAR 0 6
54709: PUSH
54710: LD_VAR 0 8
54714: PUSH
54715: EMPTY
54716: LIST
54717: LIST
54718: PPUSH
54719: CALL 86807 0 2
54723: ST_TO_ADDR
54724: GO 54811
// begin for j := 1 to Count ( result ) do
54726: LD_ADDR_VAR 0 7
54730: PUSH
54731: DOUBLE
54732: LD_INT 1
54734: DEC
54735: ST_TO_ADDR
54736: LD_VAR 0 5
54740: PPUSH
54741: CALL 51207 0 1
54745: PUSH
54746: FOR_TO
54747: IFFALSE 54809
// begin if tmp < result [ j ] [ 2 ] then
54749: LD_VAR 0 8
54753: PUSH
54754: LD_VAR 0 5
54758: PUSH
54759: LD_VAR 0 7
54763: ARRAY
54764: PUSH
54765: LD_INT 2
54767: ARRAY
54768: LESS
54769: IFFALSE 54807
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54771: LD_ADDR_VAR 0 5
54775: PUSH
54776: LD_VAR 0 5
54780: PPUSH
54781: LD_VAR 0 7
54785: PPUSH
54786: LD_VAR 0 6
54790: PUSH
54791: LD_VAR 0 8
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PPUSH
54800: CALL_OW 2
54804: ST_TO_ADDR
// break ;
54805: GO 54809
// end ; end ;
54807: GO 54746
54809: POP
54810: POP
// end ; end ;
54811: GO 54594
54813: POP
54814: POP
// if result and not asc then
54815: LD_VAR 0 5
54819: PUSH
54820: LD_VAR 0 3
54824: NOT
54825: AND
54826: IFFALSE 54843
// result := ReverseArray ( result ) ;
54828: LD_ADDR_VAR 0 5
54832: PUSH
54833: LD_VAR 0 5
54837: PPUSH
54838: CALL 82083 0 1
54842: ST_TO_ADDR
// tmp := [ ] ;
54843: LD_ADDR_VAR 0 8
54847: PUSH
54848: EMPTY
54849: ST_TO_ADDR
// if mode then
54850: LD_VAR 0 4
54854: IFFALSE 54918
// begin for i := 1 to result do
54856: LD_ADDR_VAR 0 6
54860: PUSH
54861: DOUBLE
54862: LD_INT 1
54864: DEC
54865: ST_TO_ADDR
54866: LD_VAR 0 5
54870: PUSH
54871: FOR_TO
54872: IFFALSE 54906
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
54874: LD_ADDR_VAR 0 8
54878: PUSH
54879: LD_VAR 0 8
54883: PPUSH
54884: LD_VAR 0 5
54888: PUSH
54889: LD_VAR 0 6
54893: ARRAY
54894: PUSH
54895: LD_INT 1
54897: ARRAY
54898: PPUSH
54899: CALL 86807 0 2
54903: ST_TO_ADDR
54904: GO 54871
54906: POP
54907: POP
// result := tmp ;
54908: LD_ADDR_VAR 0 5
54912: PUSH
54913: LD_VAR 0 8
54917: ST_TO_ADDR
// end ; end ;
54918: LD_VAR 0 5
54922: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54923: LD_INT 0
54925: PPUSH
54926: PPUSH
54927: PPUSH
54928: PPUSH
// if not list then
54929: LD_VAR 0 3
54933: NOT
54934: IFFALSE 54938
// exit ;
54936: GO 55326
// result := [ ] ;
54938: LD_ADDR_VAR 0 6
54942: PUSH
54943: EMPTY
54944: ST_TO_ADDR
// for i in list do
54945: LD_ADDR_VAR 0 7
54949: PUSH
54950: LD_VAR 0 3
54954: PUSH
54955: FOR_IN
54956: IFFALSE 55158
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54958: LD_ADDR_VAR 0 9
54962: PUSH
54963: LD_VAR 0 7
54967: PPUSH
54968: LD_VAR 0 1
54972: PPUSH
54973: LD_VAR 0 2
54977: PPUSH
54978: CALL_OW 297
54982: ST_TO_ADDR
// if not result then
54983: LD_VAR 0 6
54987: NOT
54988: IFFALSE 55014
// result := [ [ i , tmp ] ] else
54990: LD_ADDR_VAR 0 6
54994: PUSH
54995: LD_VAR 0 7
54999: PUSH
55000: LD_VAR 0 9
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PUSH
55009: EMPTY
55010: LIST
55011: ST_TO_ADDR
55012: GO 55156
// begin if result [ result ] [ 2 ] < tmp then
55014: LD_VAR 0 6
55018: PUSH
55019: LD_VAR 0 6
55023: ARRAY
55024: PUSH
55025: LD_INT 2
55027: ARRAY
55028: PUSH
55029: LD_VAR 0 9
55033: LESS
55034: IFFALSE 55076
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55036: LD_ADDR_VAR 0 6
55040: PUSH
55041: LD_VAR 0 6
55045: PPUSH
55046: LD_VAR 0 6
55050: PUSH
55051: LD_INT 1
55053: PLUS
55054: PPUSH
55055: LD_VAR 0 7
55059: PUSH
55060: LD_VAR 0 9
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: PPUSH
55069: CALL_OW 2
55073: ST_TO_ADDR
55074: GO 55156
// for j = 1 to result do
55076: LD_ADDR_VAR 0 8
55080: PUSH
55081: DOUBLE
55082: LD_INT 1
55084: DEC
55085: ST_TO_ADDR
55086: LD_VAR 0 6
55090: PUSH
55091: FOR_TO
55092: IFFALSE 55154
// begin if tmp < result [ j ] [ 2 ] then
55094: LD_VAR 0 9
55098: PUSH
55099: LD_VAR 0 6
55103: PUSH
55104: LD_VAR 0 8
55108: ARRAY
55109: PUSH
55110: LD_INT 2
55112: ARRAY
55113: LESS
55114: IFFALSE 55152
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55116: LD_ADDR_VAR 0 6
55120: PUSH
55121: LD_VAR 0 6
55125: PPUSH
55126: LD_VAR 0 8
55130: PPUSH
55131: LD_VAR 0 7
55135: PUSH
55136: LD_VAR 0 9
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: PPUSH
55145: CALL_OW 2
55149: ST_TO_ADDR
// break ;
55150: GO 55154
// end ; end ;
55152: GO 55091
55154: POP
55155: POP
// end ; end ;
55156: GO 54955
55158: POP
55159: POP
// if result and not asc then
55160: LD_VAR 0 6
55164: PUSH
55165: LD_VAR 0 4
55169: NOT
55170: AND
55171: IFFALSE 55246
// begin tmp := result ;
55173: LD_ADDR_VAR 0 9
55177: PUSH
55178: LD_VAR 0 6
55182: ST_TO_ADDR
// for i = tmp downto 1 do
55183: LD_ADDR_VAR 0 7
55187: PUSH
55188: DOUBLE
55189: LD_VAR 0 9
55193: INC
55194: ST_TO_ADDR
55195: LD_INT 1
55197: PUSH
55198: FOR_DOWNTO
55199: IFFALSE 55244
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55201: LD_ADDR_VAR 0 6
55205: PUSH
55206: LD_VAR 0 6
55210: PPUSH
55211: LD_VAR 0 9
55215: PUSH
55216: LD_VAR 0 7
55220: MINUS
55221: PUSH
55222: LD_INT 1
55224: PLUS
55225: PPUSH
55226: LD_VAR 0 9
55230: PUSH
55231: LD_VAR 0 7
55235: ARRAY
55236: PPUSH
55237: CALL_OW 1
55241: ST_TO_ADDR
55242: GO 55198
55244: POP
55245: POP
// end ; tmp := [ ] ;
55246: LD_ADDR_VAR 0 9
55250: PUSH
55251: EMPTY
55252: ST_TO_ADDR
// if mode then
55253: LD_VAR 0 5
55257: IFFALSE 55326
// begin for i = 1 to result do
55259: LD_ADDR_VAR 0 7
55263: PUSH
55264: DOUBLE
55265: LD_INT 1
55267: DEC
55268: ST_TO_ADDR
55269: LD_VAR 0 6
55273: PUSH
55274: FOR_TO
55275: IFFALSE 55314
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55277: LD_ADDR_VAR 0 9
55281: PUSH
55282: LD_VAR 0 9
55286: PPUSH
55287: LD_VAR 0 7
55291: PPUSH
55292: LD_VAR 0 6
55296: PUSH
55297: LD_VAR 0 7
55301: ARRAY
55302: PUSH
55303: LD_INT 1
55305: ARRAY
55306: PPUSH
55307: CALL_OW 1
55311: ST_TO_ADDR
55312: GO 55274
55314: POP
55315: POP
// result := tmp ;
55316: LD_ADDR_VAR 0 6
55320: PUSH
55321: LD_VAR 0 9
55325: ST_TO_ADDR
// end ; end ;
55326: LD_VAR 0 6
55330: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55331: LD_INT 0
55333: PPUSH
55334: PPUSH
55335: PPUSH
55336: PPUSH
55337: PPUSH
55338: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55339: LD_ADDR_VAR 0 5
55343: PUSH
55344: LD_INT 0
55346: PUSH
55347: LD_INT 0
55349: PUSH
55350: LD_INT 0
55352: PUSH
55353: EMPTY
55354: PUSH
55355: EMPTY
55356: LIST
55357: LIST
55358: LIST
55359: LIST
55360: ST_TO_ADDR
// if not x or not y then
55361: LD_VAR 0 2
55365: NOT
55366: PUSH
55367: LD_VAR 0 3
55371: NOT
55372: OR
55373: IFFALSE 55377
// exit ;
55375: GO 57027
// if not range then
55377: LD_VAR 0 4
55381: NOT
55382: IFFALSE 55392
// range := 10 ;
55384: LD_ADDR_VAR 0 4
55388: PUSH
55389: LD_INT 10
55391: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55392: LD_ADDR_VAR 0 8
55396: PUSH
55397: LD_INT 81
55399: PUSH
55400: LD_VAR 0 1
55404: PUSH
55405: EMPTY
55406: LIST
55407: LIST
55408: PUSH
55409: LD_INT 92
55411: PUSH
55412: LD_VAR 0 2
55416: PUSH
55417: LD_VAR 0 3
55421: PUSH
55422: LD_VAR 0 4
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: LIST
55431: LIST
55432: PUSH
55433: LD_INT 3
55435: PUSH
55436: LD_INT 21
55438: PUSH
55439: LD_INT 3
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: PUSH
55450: EMPTY
55451: LIST
55452: LIST
55453: LIST
55454: PPUSH
55455: CALL_OW 69
55459: ST_TO_ADDR
// if not tmp then
55460: LD_VAR 0 8
55464: NOT
55465: IFFALSE 55469
// exit ;
55467: GO 57027
// for i in tmp do
55469: LD_ADDR_VAR 0 6
55473: PUSH
55474: LD_VAR 0 8
55478: PUSH
55479: FOR_IN
55480: IFFALSE 57002
// begin points := [ 0 , 0 , 0 ] ;
55482: LD_ADDR_VAR 0 9
55486: PUSH
55487: LD_INT 0
55489: PUSH
55490: LD_INT 0
55492: PUSH
55493: LD_INT 0
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: LIST
55500: ST_TO_ADDR
// bpoints := 1 ;
55501: LD_ADDR_VAR 0 10
55505: PUSH
55506: LD_INT 1
55508: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55509: LD_VAR 0 6
55513: PPUSH
55514: CALL_OW 247
55518: PUSH
55519: LD_INT 1
55521: DOUBLE
55522: EQUAL
55523: IFTRUE 55527
55525: GO 56105
55527: POP
// begin if GetClass ( i ) = 1 then
55528: LD_VAR 0 6
55532: PPUSH
55533: CALL_OW 257
55537: PUSH
55538: LD_INT 1
55540: EQUAL
55541: IFFALSE 55562
// points := [ 10 , 5 , 3 ] ;
55543: LD_ADDR_VAR 0 9
55547: PUSH
55548: LD_INT 10
55550: PUSH
55551: LD_INT 5
55553: PUSH
55554: LD_INT 3
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: LIST
55561: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55562: LD_VAR 0 6
55566: PPUSH
55567: CALL_OW 257
55571: PUSH
55572: LD_INT 2
55574: PUSH
55575: LD_INT 3
55577: PUSH
55578: LD_INT 4
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: LIST
55585: IN
55586: IFFALSE 55607
// points := [ 3 , 2 , 1 ] ;
55588: LD_ADDR_VAR 0 9
55592: PUSH
55593: LD_INT 3
55595: PUSH
55596: LD_INT 2
55598: PUSH
55599: LD_INT 1
55601: PUSH
55602: EMPTY
55603: LIST
55604: LIST
55605: LIST
55606: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55607: LD_VAR 0 6
55611: PPUSH
55612: CALL_OW 257
55616: PUSH
55617: LD_INT 5
55619: EQUAL
55620: IFFALSE 55641
// points := [ 130 , 5 , 2 ] ;
55622: LD_ADDR_VAR 0 9
55626: PUSH
55627: LD_INT 130
55629: PUSH
55630: LD_INT 5
55632: PUSH
55633: LD_INT 2
55635: PUSH
55636: EMPTY
55637: LIST
55638: LIST
55639: LIST
55640: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55641: LD_VAR 0 6
55645: PPUSH
55646: CALL_OW 257
55650: PUSH
55651: LD_INT 8
55653: EQUAL
55654: IFFALSE 55675
// points := [ 35 , 35 , 30 ] ;
55656: LD_ADDR_VAR 0 9
55660: PUSH
55661: LD_INT 35
55663: PUSH
55664: LD_INT 35
55666: PUSH
55667: LD_INT 30
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: LIST
55674: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55675: LD_VAR 0 6
55679: PPUSH
55680: CALL_OW 257
55684: PUSH
55685: LD_INT 9
55687: EQUAL
55688: IFFALSE 55709
// points := [ 20 , 55 , 40 ] ;
55690: LD_ADDR_VAR 0 9
55694: PUSH
55695: LD_INT 20
55697: PUSH
55698: LD_INT 55
55700: PUSH
55701: LD_INT 40
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: LIST
55708: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55709: LD_VAR 0 6
55713: PPUSH
55714: CALL_OW 257
55718: PUSH
55719: LD_INT 12
55721: PUSH
55722: LD_INT 16
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: IN
55729: IFFALSE 55750
// points := [ 5 , 3 , 2 ] ;
55731: LD_ADDR_VAR 0 9
55735: PUSH
55736: LD_INT 5
55738: PUSH
55739: LD_INT 3
55741: PUSH
55742: LD_INT 2
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: LIST
55749: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55750: LD_VAR 0 6
55754: PPUSH
55755: CALL_OW 257
55759: PUSH
55760: LD_INT 17
55762: EQUAL
55763: IFFALSE 55784
// points := [ 100 , 50 , 75 ] ;
55765: LD_ADDR_VAR 0 9
55769: PUSH
55770: LD_INT 100
55772: PUSH
55773: LD_INT 50
55775: PUSH
55776: LD_INT 75
55778: PUSH
55779: EMPTY
55780: LIST
55781: LIST
55782: LIST
55783: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55784: LD_VAR 0 6
55788: PPUSH
55789: CALL_OW 257
55793: PUSH
55794: LD_INT 15
55796: EQUAL
55797: IFFALSE 55818
// points := [ 10 , 5 , 3 ] ;
55799: LD_ADDR_VAR 0 9
55803: PUSH
55804: LD_INT 10
55806: PUSH
55807: LD_INT 5
55809: PUSH
55810: LD_INT 3
55812: PUSH
55813: EMPTY
55814: LIST
55815: LIST
55816: LIST
55817: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55818: LD_VAR 0 6
55822: PPUSH
55823: CALL_OW 257
55827: PUSH
55828: LD_INT 14
55830: EQUAL
55831: IFFALSE 55852
// points := [ 10 , 0 , 0 ] ;
55833: LD_ADDR_VAR 0 9
55837: PUSH
55838: LD_INT 10
55840: PUSH
55841: LD_INT 0
55843: PUSH
55844: LD_INT 0
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: LIST
55851: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55852: LD_VAR 0 6
55856: PPUSH
55857: CALL_OW 257
55861: PUSH
55862: LD_INT 11
55864: EQUAL
55865: IFFALSE 55886
// points := [ 30 , 10 , 5 ] ;
55867: LD_ADDR_VAR 0 9
55871: PUSH
55872: LD_INT 30
55874: PUSH
55875: LD_INT 10
55877: PUSH
55878: LD_INT 5
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: LIST
55885: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55886: LD_VAR 0 1
55890: PPUSH
55891: LD_INT 5
55893: PPUSH
55894: CALL_OW 321
55898: PUSH
55899: LD_INT 2
55901: EQUAL
55902: IFFALSE 55919
// bpoints := bpoints * 1.8 ;
55904: LD_ADDR_VAR 0 10
55908: PUSH
55909: LD_VAR 0 10
55913: PUSH
55914: LD_REAL  1.80000000000000E+0000
55917: MUL
55918: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55919: LD_VAR 0 6
55923: PPUSH
55924: CALL_OW 257
55928: PUSH
55929: LD_INT 1
55931: PUSH
55932: LD_INT 2
55934: PUSH
55935: LD_INT 3
55937: PUSH
55938: LD_INT 4
55940: PUSH
55941: EMPTY
55942: LIST
55943: LIST
55944: LIST
55945: LIST
55946: IN
55947: PUSH
55948: LD_VAR 0 1
55952: PPUSH
55953: LD_INT 51
55955: PPUSH
55956: CALL_OW 321
55960: PUSH
55961: LD_INT 2
55963: EQUAL
55964: AND
55965: IFFALSE 55982
// bpoints := bpoints * 1.2 ;
55967: LD_ADDR_VAR 0 10
55971: PUSH
55972: LD_VAR 0 10
55976: PUSH
55977: LD_REAL  1.20000000000000E+0000
55980: MUL
55981: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55982: LD_VAR 0 6
55986: PPUSH
55987: CALL_OW 257
55991: PUSH
55992: LD_INT 5
55994: PUSH
55995: LD_INT 7
55997: PUSH
55998: LD_INT 9
56000: PUSH
56001: EMPTY
56002: LIST
56003: LIST
56004: LIST
56005: IN
56006: PUSH
56007: LD_VAR 0 1
56011: PPUSH
56012: LD_INT 52
56014: PPUSH
56015: CALL_OW 321
56019: PUSH
56020: LD_INT 2
56022: EQUAL
56023: AND
56024: IFFALSE 56041
// bpoints := bpoints * 1.5 ;
56026: LD_ADDR_VAR 0 10
56030: PUSH
56031: LD_VAR 0 10
56035: PUSH
56036: LD_REAL  1.50000000000000E+0000
56039: MUL
56040: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56041: LD_VAR 0 1
56045: PPUSH
56046: LD_INT 66
56048: PPUSH
56049: CALL_OW 321
56053: PUSH
56054: LD_INT 2
56056: EQUAL
56057: IFFALSE 56074
// bpoints := bpoints * 1.1 ;
56059: LD_ADDR_VAR 0 10
56063: PUSH
56064: LD_VAR 0 10
56068: PUSH
56069: LD_REAL  1.10000000000000E+0000
56072: MUL
56073: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56074: LD_ADDR_VAR 0 10
56078: PUSH
56079: LD_VAR 0 10
56083: PUSH
56084: LD_VAR 0 6
56088: PPUSH
56089: LD_INT 1
56091: PPUSH
56092: CALL_OW 259
56096: PUSH
56097: LD_REAL  1.15000000000000E+0000
56100: MUL
56101: MUL
56102: ST_TO_ADDR
// end ; unit_vehicle :
56103: GO 56931
56105: LD_INT 2
56107: DOUBLE
56108: EQUAL
56109: IFTRUE 56113
56111: GO 56919
56113: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56114: LD_VAR 0 6
56118: PPUSH
56119: CALL_OW 264
56123: PUSH
56124: LD_INT 2
56126: PUSH
56127: LD_INT 42
56129: PUSH
56130: LD_INT 24
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: IN
56138: IFFALSE 56159
// points := [ 25 , 5 , 3 ] ;
56140: LD_ADDR_VAR 0 9
56144: PUSH
56145: LD_INT 25
56147: PUSH
56148: LD_INT 5
56150: PUSH
56151: LD_INT 3
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: LIST
56158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56159: LD_VAR 0 6
56163: PPUSH
56164: CALL_OW 264
56168: PUSH
56169: LD_INT 4
56171: PUSH
56172: LD_INT 43
56174: PUSH
56175: LD_INT 25
56177: PUSH
56178: EMPTY
56179: LIST
56180: LIST
56181: LIST
56182: IN
56183: IFFALSE 56204
// points := [ 40 , 15 , 5 ] ;
56185: LD_ADDR_VAR 0 9
56189: PUSH
56190: LD_INT 40
56192: PUSH
56193: LD_INT 15
56195: PUSH
56196: LD_INT 5
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: LIST
56203: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56204: LD_VAR 0 6
56208: PPUSH
56209: CALL_OW 264
56213: PUSH
56214: LD_INT 3
56216: PUSH
56217: LD_INT 23
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: IN
56224: IFFALSE 56245
// points := [ 7 , 25 , 8 ] ;
56226: LD_ADDR_VAR 0 9
56230: PUSH
56231: LD_INT 7
56233: PUSH
56234: LD_INT 25
56236: PUSH
56237: LD_INT 8
56239: PUSH
56240: EMPTY
56241: LIST
56242: LIST
56243: LIST
56244: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56245: LD_VAR 0 6
56249: PPUSH
56250: CALL_OW 264
56254: PUSH
56255: LD_INT 5
56257: PUSH
56258: LD_INT 27
56260: PUSH
56261: LD_INT 44
56263: PUSH
56264: EMPTY
56265: LIST
56266: LIST
56267: LIST
56268: IN
56269: IFFALSE 56290
// points := [ 14 , 50 , 16 ] ;
56271: LD_ADDR_VAR 0 9
56275: PUSH
56276: LD_INT 14
56278: PUSH
56279: LD_INT 50
56281: PUSH
56282: LD_INT 16
56284: PUSH
56285: EMPTY
56286: LIST
56287: LIST
56288: LIST
56289: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56290: LD_VAR 0 6
56294: PPUSH
56295: CALL_OW 264
56299: PUSH
56300: LD_INT 6
56302: PUSH
56303: LD_INT 46
56305: PUSH
56306: EMPTY
56307: LIST
56308: LIST
56309: IN
56310: IFFALSE 56331
// points := [ 32 , 120 , 70 ] ;
56312: LD_ADDR_VAR 0 9
56316: PUSH
56317: LD_INT 32
56319: PUSH
56320: LD_INT 120
56322: PUSH
56323: LD_INT 70
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: LIST
56330: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56331: LD_VAR 0 6
56335: PPUSH
56336: CALL_OW 264
56340: PUSH
56341: LD_INT 7
56343: PUSH
56344: LD_INT 28
56346: PUSH
56347: LD_INT 45
56349: PUSH
56350: LD_INT 92
56352: PUSH
56353: EMPTY
56354: LIST
56355: LIST
56356: LIST
56357: LIST
56358: IN
56359: IFFALSE 56380
// points := [ 35 , 20 , 45 ] ;
56361: LD_ADDR_VAR 0 9
56365: PUSH
56366: LD_INT 35
56368: PUSH
56369: LD_INT 20
56371: PUSH
56372: LD_INT 45
56374: PUSH
56375: EMPTY
56376: LIST
56377: LIST
56378: LIST
56379: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56380: LD_VAR 0 6
56384: PPUSH
56385: CALL_OW 264
56389: PUSH
56390: LD_INT 47
56392: PUSH
56393: EMPTY
56394: LIST
56395: IN
56396: IFFALSE 56417
// points := [ 67 , 45 , 75 ] ;
56398: LD_ADDR_VAR 0 9
56402: PUSH
56403: LD_INT 67
56405: PUSH
56406: LD_INT 45
56408: PUSH
56409: LD_INT 75
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: LIST
56416: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56417: LD_VAR 0 6
56421: PPUSH
56422: CALL_OW 264
56426: PUSH
56427: LD_INT 26
56429: PUSH
56430: EMPTY
56431: LIST
56432: IN
56433: IFFALSE 56454
// points := [ 120 , 30 , 80 ] ;
56435: LD_ADDR_VAR 0 9
56439: PUSH
56440: LD_INT 120
56442: PUSH
56443: LD_INT 30
56445: PUSH
56446: LD_INT 80
56448: PUSH
56449: EMPTY
56450: LIST
56451: LIST
56452: LIST
56453: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56454: LD_VAR 0 6
56458: PPUSH
56459: CALL_OW 264
56463: PUSH
56464: LD_INT 22
56466: PUSH
56467: EMPTY
56468: LIST
56469: IN
56470: IFFALSE 56491
// points := [ 40 , 1 , 1 ] ;
56472: LD_ADDR_VAR 0 9
56476: PUSH
56477: LD_INT 40
56479: PUSH
56480: LD_INT 1
56482: PUSH
56483: LD_INT 1
56485: PUSH
56486: EMPTY
56487: LIST
56488: LIST
56489: LIST
56490: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56491: LD_VAR 0 6
56495: PPUSH
56496: CALL_OW 264
56500: PUSH
56501: LD_INT 29
56503: PUSH
56504: EMPTY
56505: LIST
56506: IN
56507: IFFALSE 56528
// points := [ 70 , 200 , 400 ] ;
56509: LD_ADDR_VAR 0 9
56513: PUSH
56514: LD_INT 70
56516: PUSH
56517: LD_INT 200
56519: PUSH
56520: LD_INT 400
56522: PUSH
56523: EMPTY
56524: LIST
56525: LIST
56526: LIST
56527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56528: LD_VAR 0 6
56532: PPUSH
56533: CALL_OW 264
56537: PUSH
56538: LD_INT 14
56540: PUSH
56541: LD_INT 53
56543: PUSH
56544: EMPTY
56545: LIST
56546: LIST
56547: IN
56548: IFFALSE 56569
// points := [ 40 , 10 , 20 ] ;
56550: LD_ADDR_VAR 0 9
56554: PUSH
56555: LD_INT 40
56557: PUSH
56558: LD_INT 10
56560: PUSH
56561: LD_INT 20
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: LIST
56568: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56569: LD_VAR 0 6
56573: PPUSH
56574: CALL_OW 264
56578: PUSH
56579: LD_INT 9
56581: PUSH
56582: EMPTY
56583: LIST
56584: IN
56585: IFFALSE 56606
// points := [ 5 , 70 , 20 ] ;
56587: LD_ADDR_VAR 0 9
56591: PUSH
56592: LD_INT 5
56594: PUSH
56595: LD_INT 70
56597: PUSH
56598: LD_INT 20
56600: PUSH
56601: EMPTY
56602: LIST
56603: LIST
56604: LIST
56605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56606: LD_VAR 0 6
56610: PPUSH
56611: CALL_OW 264
56615: PUSH
56616: LD_INT 10
56618: PUSH
56619: EMPTY
56620: LIST
56621: IN
56622: IFFALSE 56643
// points := [ 35 , 110 , 70 ] ;
56624: LD_ADDR_VAR 0 9
56628: PUSH
56629: LD_INT 35
56631: PUSH
56632: LD_INT 110
56634: PUSH
56635: LD_INT 70
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56643: LD_VAR 0 6
56647: PPUSH
56648: CALL_OW 265
56652: PUSH
56653: LD_INT 25
56655: EQUAL
56656: IFFALSE 56677
// points := [ 80 , 65 , 100 ] ;
56658: LD_ADDR_VAR 0 9
56662: PUSH
56663: LD_INT 80
56665: PUSH
56666: LD_INT 65
56668: PUSH
56669: LD_INT 100
56671: PUSH
56672: EMPTY
56673: LIST
56674: LIST
56675: LIST
56676: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56677: LD_VAR 0 6
56681: PPUSH
56682: CALL_OW 263
56686: PUSH
56687: LD_INT 1
56689: EQUAL
56690: IFFALSE 56725
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56692: LD_ADDR_VAR 0 10
56696: PUSH
56697: LD_VAR 0 10
56701: PUSH
56702: LD_VAR 0 6
56706: PPUSH
56707: CALL_OW 311
56711: PPUSH
56712: LD_INT 3
56714: PPUSH
56715: CALL_OW 259
56719: PUSH
56720: LD_INT 4
56722: MUL
56723: MUL
56724: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56725: LD_VAR 0 6
56729: PPUSH
56730: CALL_OW 263
56734: PUSH
56735: LD_INT 2
56737: EQUAL
56738: IFFALSE 56789
// begin j := IsControledBy ( i ) ;
56740: LD_ADDR_VAR 0 7
56744: PUSH
56745: LD_VAR 0 6
56749: PPUSH
56750: CALL_OW 312
56754: ST_TO_ADDR
// if j then
56755: LD_VAR 0 7
56759: IFFALSE 56789
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56761: LD_ADDR_VAR 0 10
56765: PUSH
56766: LD_VAR 0 10
56770: PUSH
56771: LD_VAR 0 7
56775: PPUSH
56776: LD_INT 3
56778: PPUSH
56779: CALL_OW 259
56783: PUSH
56784: LD_INT 3
56786: MUL
56787: MUL
56788: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56789: LD_VAR 0 6
56793: PPUSH
56794: CALL_OW 264
56798: PUSH
56799: LD_INT 5
56801: PUSH
56802: LD_INT 6
56804: PUSH
56805: LD_INT 46
56807: PUSH
56808: LD_INT 44
56810: PUSH
56811: LD_INT 47
56813: PUSH
56814: LD_INT 45
56816: PUSH
56817: LD_INT 28
56819: PUSH
56820: LD_INT 7
56822: PUSH
56823: LD_INT 27
56825: PUSH
56826: LD_INT 29
56828: PUSH
56829: EMPTY
56830: LIST
56831: LIST
56832: LIST
56833: LIST
56834: LIST
56835: LIST
56836: LIST
56837: LIST
56838: LIST
56839: LIST
56840: IN
56841: PUSH
56842: LD_VAR 0 1
56846: PPUSH
56847: LD_INT 52
56849: PPUSH
56850: CALL_OW 321
56854: PUSH
56855: LD_INT 2
56857: EQUAL
56858: AND
56859: IFFALSE 56876
// bpoints := bpoints * 1.2 ;
56861: LD_ADDR_VAR 0 10
56865: PUSH
56866: LD_VAR 0 10
56870: PUSH
56871: LD_REAL  1.20000000000000E+0000
56874: MUL
56875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56876: LD_VAR 0 6
56880: PPUSH
56881: CALL_OW 264
56885: PUSH
56886: LD_INT 6
56888: PUSH
56889: LD_INT 46
56891: PUSH
56892: LD_INT 47
56894: PUSH
56895: EMPTY
56896: LIST
56897: LIST
56898: LIST
56899: IN
56900: IFFALSE 56917
// bpoints := bpoints * 1.2 ;
56902: LD_ADDR_VAR 0 10
56906: PUSH
56907: LD_VAR 0 10
56911: PUSH
56912: LD_REAL  1.20000000000000E+0000
56915: MUL
56916: ST_TO_ADDR
// end ; unit_building :
56917: GO 56931
56919: LD_INT 3
56921: DOUBLE
56922: EQUAL
56923: IFTRUE 56927
56925: GO 56930
56927: POP
// ; end ;
56928: GO 56931
56930: POP
// for j = 1 to 3 do
56931: LD_ADDR_VAR 0 7
56935: PUSH
56936: DOUBLE
56937: LD_INT 1
56939: DEC
56940: ST_TO_ADDR
56941: LD_INT 3
56943: PUSH
56944: FOR_TO
56945: IFFALSE 56998
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56947: LD_ADDR_VAR 0 5
56951: PUSH
56952: LD_VAR 0 5
56956: PPUSH
56957: LD_VAR 0 7
56961: PPUSH
56962: LD_VAR 0 5
56966: PUSH
56967: LD_VAR 0 7
56971: ARRAY
56972: PUSH
56973: LD_VAR 0 9
56977: PUSH
56978: LD_VAR 0 7
56982: ARRAY
56983: PUSH
56984: LD_VAR 0 10
56988: MUL
56989: PLUS
56990: PPUSH
56991: CALL_OW 1
56995: ST_TO_ADDR
56996: GO 56944
56998: POP
56999: POP
// end ;
57000: GO 55479
57002: POP
57003: POP
// result := Replace ( result , 4 , tmp ) ;
57004: LD_ADDR_VAR 0 5
57008: PUSH
57009: LD_VAR 0 5
57013: PPUSH
57014: LD_INT 4
57016: PPUSH
57017: LD_VAR 0 8
57021: PPUSH
57022: CALL_OW 1
57026: ST_TO_ADDR
// end ;
57027: LD_VAR 0 5
57031: RET
// export function DangerAtRange ( unit , range ) ; begin
57032: LD_INT 0
57034: PPUSH
// if not unit then
57035: LD_VAR 0 1
57039: NOT
57040: IFFALSE 57044
// exit ;
57042: GO 57089
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57044: LD_ADDR_VAR 0 3
57048: PUSH
57049: LD_VAR 0 1
57053: PPUSH
57054: CALL_OW 255
57058: PPUSH
57059: LD_VAR 0 1
57063: PPUSH
57064: CALL_OW 250
57068: PPUSH
57069: LD_VAR 0 1
57073: PPUSH
57074: CALL_OW 251
57078: PPUSH
57079: LD_VAR 0 2
57083: PPUSH
57084: CALL 55331 0 4
57088: ST_TO_ADDR
// end ;
57089: LD_VAR 0 3
57093: RET
// export function DangerInArea ( side , area ) ; begin
57094: LD_INT 0
57096: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57097: LD_ADDR_VAR 0 3
57101: PUSH
57102: LD_VAR 0 2
57106: PPUSH
57107: LD_INT 81
57109: PUSH
57110: LD_VAR 0 1
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: PPUSH
57119: CALL_OW 70
57123: ST_TO_ADDR
// end ;
57124: LD_VAR 0 3
57128: RET
// export function IsExtension ( b ) ; begin
57129: LD_INT 0
57131: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57132: LD_ADDR_VAR 0 2
57136: PUSH
57137: LD_VAR 0 1
57141: PUSH
57142: LD_INT 23
57144: PUSH
57145: LD_INT 20
57147: PUSH
57148: LD_INT 22
57150: PUSH
57151: LD_INT 17
57153: PUSH
57154: LD_INT 24
57156: PUSH
57157: LD_INT 21
57159: PUSH
57160: LD_INT 19
57162: PUSH
57163: LD_INT 16
57165: PUSH
57166: LD_INT 25
57168: PUSH
57169: LD_INT 18
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: LIST
57176: LIST
57177: LIST
57178: LIST
57179: LIST
57180: LIST
57181: LIST
57182: LIST
57183: IN
57184: ST_TO_ADDR
// end ;
57185: LD_VAR 0 2
57189: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
57190: LD_INT 0
57192: PPUSH
57193: PPUSH
57194: PPUSH
// result := [ ] ;
57195: LD_ADDR_VAR 0 4
57199: PUSH
57200: EMPTY
57201: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57202: LD_ADDR_VAR 0 5
57206: PUSH
57207: LD_VAR 0 2
57211: PPUSH
57212: LD_INT 21
57214: PUSH
57215: LD_INT 3
57217: PUSH
57218: EMPTY
57219: LIST
57220: LIST
57221: PPUSH
57222: CALL_OW 70
57226: ST_TO_ADDR
// if not tmp then
57227: LD_VAR 0 5
57231: NOT
57232: IFFALSE 57236
// exit ;
57234: GO 57300
// if checkLink then
57236: LD_VAR 0 3
57240: IFFALSE 57290
// begin for i in tmp do
57242: LD_ADDR_VAR 0 6
57246: PUSH
57247: LD_VAR 0 5
57251: PUSH
57252: FOR_IN
57253: IFFALSE 57288
// if GetBase ( i ) <> base then
57255: LD_VAR 0 6
57259: PPUSH
57260: CALL_OW 274
57264: PUSH
57265: LD_VAR 0 1
57269: NONEQUAL
57270: IFFALSE 57286
// ComLinkToBase ( base , i ) ;
57272: LD_VAR 0 1
57276: PPUSH
57277: LD_VAR 0 6
57281: PPUSH
57282: CALL_OW 169
57286: GO 57252
57288: POP
57289: POP
// end ; result := tmp ;
57290: LD_ADDR_VAR 0 4
57294: PUSH
57295: LD_VAR 0 5
57299: ST_TO_ADDR
// end ;
57300: LD_VAR 0 4
57304: RET
// export function ComComplete ( units , b ) ; var i ; begin
57305: LD_INT 0
57307: PPUSH
57308: PPUSH
// if not units then
57309: LD_VAR 0 1
57313: NOT
57314: IFFALSE 57318
// exit ;
57316: GO 57408
// for i in units do
57318: LD_ADDR_VAR 0 4
57322: PUSH
57323: LD_VAR 0 1
57327: PUSH
57328: FOR_IN
57329: IFFALSE 57406
// if BuildingStatus ( b ) = bs_build then
57331: LD_VAR 0 2
57335: PPUSH
57336: CALL_OW 461
57340: PUSH
57341: LD_INT 1
57343: EQUAL
57344: IFFALSE 57404
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57346: LD_VAR 0 4
57350: PPUSH
57351: LD_STRING h
57353: PUSH
57354: LD_VAR 0 2
57358: PPUSH
57359: CALL_OW 250
57363: PUSH
57364: LD_VAR 0 2
57368: PPUSH
57369: CALL_OW 251
57373: PUSH
57374: LD_VAR 0 2
57378: PUSH
57379: LD_INT 0
57381: PUSH
57382: LD_INT 0
57384: PUSH
57385: LD_INT 0
57387: PUSH
57388: EMPTY
57389: LIST
57390: LIST
57391: LIST
57392: LIST
57393: LIST
57394: LIST
57395: LIST
57396: PUSH
57397: EMPTY
57398: LIST
57399: PPUSH
57400: CALL_OW 446
57404: GO 57328
57406: POP
57407: POP
// end ;
57408: LD_VAR 0 3
57412: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57413: LD_INT 0
57415: PPUSH
57416: PPUSH
57417: PPUSH
57418: PPUSH
57419: PPUSH
57420: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57421: LD_VAR 0 1
57425: NOT
57426: PUSH
57427: LD_VAR 0 1
57431: PPUSH
57432: CALL_OW 263
57436: PUSH
57437: LD_INT 2
57439: NONEQUAL
57440: OR
57441: IFFALSE 57445
// exit ;
57443: GO 57761
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57445: LD_ADDR_VAR 0 6
57449: PUSH
57450: LD_INT 22
57452: PUSH
57453: LD_VAR 0 1
57457: PPUSH
57458: CALL_OW 255
57462: PUSH
57463: EMPTY
57464: LIST
57465: LIST
57466: PUSH
57467: LD_INT 2
57469: PUSH
57470: LD_INT 30
57472: PUSH
57473: LD_INT 36
57475: PUSH
57476: EMPTY
57477: LIST
57478: LIST
57479: PUSH
57480: LD_INT 34
57482: PUSH
57483: LD_INT 31
57485: PUSH
57486: EMPTY
57487: LIST
57488: LIST
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: LIST
57494: PUSH
57495: EMPTY
57496: LIST
57497: LIST
57498: PPUSH
57499: CALL_OW 69
57503: ST_TO_ADDR
// if not tmp then
57504: LD_VAR 0 6
57508: NOT
57509: IFFALSE 57513
// exit ;
57511: GO 57761
// result := [ ] ;
57513: LD_ADDR_VAR 0 2
57517: PUSH
57518: EMPTY
57519: ST_TO_ADDR
// for i in tmp do
57520: LD_ADDR_VAR 0 3
57524: PUSH
57525: LD_VAR 0 6
57529: PUSH
57530: FOR_IN
57531: IFFALSE 57602
// begin t := UnitsInside ( i ) ;
57533: LD_ADDR_VAR 0 4
57537: PUSH
57538: LD_VAR 0 3
57542: PPUSH
57543: CALL_OW 313
57547: ST_TO_ADDR
// if t then
57548: LD_VAR 0 4
57552: IFFALSE 57600
// for j in t do
57554: LD_ADDR_VAR 0 7
57558: PUSH
57559: LD_VAR 0 4
57563: PUSH
57564: FOR_IN
57565: IFFALSE 57598
// result := Replace ( result , result + 1 , j ) ;
57567: LD_ADDR_VAR 0 2
57571: PUSH
57572: LD_VAR 0 2
57576: PPUSH
57577: LD_VAR 0 2
57581: PUSH
57582: LD_INT 1
57584: PLUS
57585: PPUSH
57586: LD_VAR 0 7
57590: PPUSH
57591: CALL_OW 1
57595: ST_TO_ADDR
57596: GO 57564
57598: POP
57599: POP
// end ;
57600: GO 57530
57602: POP
57603: POP
// if not result then
57604: LD_VAR 0 2
57608: NOT
57609: IFFALSE 57613
// exit ;
57611: GO 57761
// mech := result [ 1 ] ;
57613: LD_ADDR_VAR 0 5
57617: PUSH
57618: LD_VAR 0 2
57622: PUSH
57623: LD_INT 1
57625: ARRAY
57626: ST_TO_ADDR
// if result > 1 then
57627: LD_VAR 0 2
57631: PUSH
57632: LD_INT 1
57634: GREATER
57635: IFFALSE 57747
// begin for i = 2 to result do
57637: LD_ADDR_VAR 0 3
57641: PUSH
57642: DOUBLE
57643: LD_INT 2
57645: DEC
57646: ST_TO_ADDR
57647: LD_VAR 0 2
57651: PUSH
57652: FOR_TO
57653: IFFALSE 57745
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57655: LD_ADDR_VAR 0 4
57659: PUSH
57660: LD_VAR 0 2
57664: PUSH
57665: LD_VAR 0 3
57669: ARRAY
57670: PPUSH
57671: LD_INT 3
57673: PPUSH
57674: CALL_OW 259
57678: PUSH
57679: LD_VAR 0 2
57683: PUSH
57684: LD_VAR 0 3
57688: ARRAY
57689: PPUSH
57690: CALL_OW 432
57694: MINUS
57695: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57696: LD_VAR 0 4
57700: PUSH
57701: LD_VAR 0 5
57705: PPUSH
57706: LD_INT 3
57708: PPUSH
57709: CALL_OW 259
57713: PUSH
57714: LD_VAR 0 5
57718: PPUSH
57719: CALL_OW 432
57723: MINUS
57724: GREATEREQUAL
57725: IFFALSE 57743
// mech := result [ i ] ;
57727: LD_ADDR_VAR 0 5
57731: PUSH
57732: LD_VAR 0 2
57736: PUSH
57737: LD_VAR 0 3
57741: ARRAY
57742: ST_TO_ADDR
// end ;
57743: GO 57652
57745: POP
57746: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57747: LD_VAR 0 1
57751: PPUSH
57752: LD_VAR 0 5
57756: PPUSH
57757: CALL_OW 135
// end ;
57761: LD_VAR 0 2
57765: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57766: LD_INT 0
57768: PPUSH
57769: PPUSH
57770: PPUSH
57771: PPUSH
57772: PPUSH
57773: PPUSH
57774: PPUSH
57775: PPUSH
57776: PPUSH
57777: PPUSH
57778: PPUSH
57779: PPUSH
57780: PPUSH
// result := [ ] ;
57781: LD_ADDR_VAR 0 7
57785: PUSH
57786: EMPTY
57787: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57788: LD_VAR 0 1
57792: PPUSH
57793: CALL_OW 266
57797: PUSH
57798: LD_INT 0
57800: PUSH
57801: LD_INT 1
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: IN
57808: NOT
57809: IFFALSE 57813
// exit ;
57811: GO 59447
// if name then
57813: LD_VAR 0 3
57817: IFFALSE 57833
// SetBName ( base_dep , name ) ;
57819: LD_VAR 0 1
57823: PPUSH
57824: LD_VAR 0 3
57828: PPUSH
57829: CALL_OW 500
// base := GetBase ( base_dep ) ;
57833: LD_ADDR_VAR 0 15
57837: PUSH
57838: LD_VAR 0 1
57842: PPUSH
57843: CALL_OW 274
57847: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57848: LD_ADDR_VAR 0 16
57852: PUSH
57853: LD_VAR 0 1
57857: PPUSH
57858: CALL_OW 255
57862: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57863: LD_ADDR_VAR 0 17
57867: PUSH
57868: LD_VAR 0 1
57872: PPUSH
57873: CALL_OW 248
57877: ST_TO_ADDR
// if sources then
57878: LD_VAR 0 5
57882: IFFALSE 57929
// for i = 1 to 3 do
57884: LD_ADDR_VAR 0 8
57888: PUSH
57889: DOUBLE
57890: LD_INT 1
57892: DEC
57893: ST_TO_ADDR
57894: LD_INT 3
57896: PUSH
57897: FOR_TO
57898: IFFALSE 57927
// AddResourceType ( base , i , sources [ i ] ) ;
57900: LD_VAR 0 15
57904: PPUSH
57905: LD_VAR 0 8
57909: PPUSH
57910: LD_VAR 0 5
57914: PUSH
57915: LD_VAR 0 8
57919: ARRAY
57920: PPUSH
57921: CALL_OW 276
57925: GO 57897
57927: POP
57928: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57929: LD_ADDR_VAR 0 18
57933: PUSH
57934: LD_VAR 0 15
57938: PPUSH
57939: LD_VAR 0 2
57943: PPUSH
57944: LD_INT 1
57946: PPUSH
57947: CALL 57190 0 3
57951: ST_TO_ADDR
// InitHc ;
57952: CALL_OW 19
// InitUc ;
57956: CALL_OW 18
// uc_side := side ;
57960: LD_ADDR_OWVAR 20
57964: PUSH
57965: LD_VAR 0 16
57969: ST_TO_ADDR
// uc_nation := nation ;
57970: LD_ADDR_OWVAR 21
57974: PUSH
57975: LD_VAR 0 17
57979: ST_TO_ADDR
// if buildings then
57980: LD_VAR 0 18
57984: IFFALSE 59306
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57986: LD_ADDR_VAR 0 19
57990: PUSH
57991: LD_VAR 0 18
57995: PPUSH
57996: LD_INT 2
57998: PUSH
57999: LD_INT 30
58001: PUSH
58002: LD_INT 29
58004: PUSH
58005: EMPTY
58006: LIST
58007: LIST
58008: PUSH
58009: LD_INT 30
58011: PUSH
58012: LD_INT 30
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 72
58028: ST_TO_ADDR
// if tmp then
58029: LD_VAR 0 19
58033: IFFALSE 58081
// for i in tmp do
58035: LD_ADDR_VAR 0 8
58039: PUSH
58040: LD_VAR 0 19
58044: PUSH
58045: FOR_IN
58046: IFFALSE 58079
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58048: LD_VAR 0 8
58052: PPUSH
58053: CALL_OW 250
58057: PPUSH
58058: LD_VAR 0 8
58062: PPUSH
58063: CALL_OW 251
58067: PPUSH
58068: LD_VAR 0 16
58072: PPUSH
58073: CALL_OW 441
58077: GO 58045
58079: POP
58080: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58081: LD_VAR 0 18
58085: PPUSH
58086: LD_INT 2
58088: PUSH
58089: LD_INT 30
58091: PUSH
58092: LD_INT 32
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: PUSH
58099: LD_INT 30
58101: PUSH
58102: LD_INT 33
58104: PUSH
58105: EMPTY
58106: LIST
58107: LIST
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: LIST
58113: PPUSH
58114: CALL_OW 72
58118: IFFALSE 58206
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58120: LD_ADDR_VAR 0 8
58124: PUSH
58125: LD_VAR 0 18
58129: PPUSH
58130: LD_INT 2
58132: PUSH
58133: LD_INT 30
58135: PUSH
58136: LD_INT 32
58138: PUSH
58139: EMPTY
58140: LIST
58141: LIST
58142: PUSH
58143: LD_INT 30
58145: PUSH
58146: LD_INT 33
58148: PUSH
58149: EMPTY
58150: LIST
58151: LIST
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: LIST
58157: PPUSH
58158: CALL_OW 72
58162: PUSH
58163: FOR_IN
58164: IFFALSE 58204
// begin if not GetBWeapon ( i ) then
58166: LD_VAR 0 8
58170: PPUSH
58171: CALL_OW 269
58175: NOT
58176: IFFALSE 58202
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58178: LD_VAR 0 8
58182: PPUSH
58183: LD_VAR 0 8
58187: PPUSH
58188: LD_VAR 0 2
58192: PPUSH
58193: CALL 59452 0 2
58197: PPUSH
58198: CALL_OW 431
// end ;
58202: GO 58163
58204: POP
58205: POP
// end ; for i = 1 to personel do
58206: LD_ADDR_VAR 0 8
58210: PUSH
58211: DOUBLE
58212: LD_INT 1
58214: DEC
58215: ST_TO_ADDR
58216: LD_VAR 0 6
58220: PUSH
58221: FOR_TO
58222: IFFALSE 59286
// begin if i > 4 then
58224: LD_VAR 0 8
58228: PUSH
58229: LD_INT 4
58231: GREATER
58232: IFFALSE 58236
// break ;
58234: GO 59286
// case i of 1 :
58236: LD_VAR 0 8
58240: PUSH
58241: LD_INT 1
58243: DOUBLE
58244: EQUAL
58245: IFTRUE 58249
58247: GO 58329
58249: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58250: LD_ADDR_VAR 0 12
58254: PUSH
58255: LD_VAR 0 18
58259: PPUSH
58260: LD_INT 22
58262: PUSH
58263: LD_VAR 0 16
58267: PUSH
58268: EMPTY
58269: LIST
58270: LIST
58271: PUSH
58272: LD_INT 58
58274: PUSH
58275: EMPTY
58276: LIST
58277: PUSH
58278: LD_INT 2
58280: PUSH
58281: LD_INT 30
58283: PUSH
58284: LD_INT 32
58286: PUSH
58287: EMPTY
58288: LIST
58289: LIST
58290: PUSH
58291: LD_INT 30
58293: PUSH
58294: LD_INT 4
58296: PUSH
58297: EMPTY
58298: LIST
58299: LIST
58300: PUSH
58301: LD_INT 30
58303: PUSH
58304: LD_INT 5
58306: PUSH
58307: EMPTY
58308: LIST
58309: LIST
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: LIST
58315: LIST
58316: PUSH
58317: EMPTY
58318: LIST
58319: LIST
58320: LIST
58321: PPUSH
58322: CALL_OW 72
58326: ST_TO_ADDR
58327: GO 58551
58329: LD_INT 2
58331: DOUBLE
58332: EQUAL
58333: IFTRUE 58337
58335: GO 58399
58337: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58338: LD_ADDR_VAR 0 12
58342: PUSH
58343: LD_VAR 0 18
58347: PPUSH
58348: LD_INT 22
58350: PUSH
58351: LD_VAR 0 16
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: PUSH
58360: LD_INT 2
58362: PUSH
58363: LD_INT 30
58365: PUSH
58366: LD_INT 0
58368: PUSH
58369: EMPTY
58370: LIST
58371: LIST
58372: PUSH
58373: LD_INT 30
58375: PUSH
58376: LD_INT 1
58378: PUSH
58379: EMPTY
58380: LIST
58381: LIST
58382: PUSH
58383: EMPTY
58384: LIST
58385: LIST
58386: LIST
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: PPUSH
58392: CALL_OW 72
58396: ST_TO_ADDR
58397: GO 58551
58399: LD_INT 3
58401: DOUBLE
58402: EQUAL
58403: IFTRUE 58407
58405: GO 58469
58407: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58408: LD_ADDR_VAR 0 12
58412: PUSH
58413: LD_VAR 0 18
58417: PPUSH
58418: LD_INT 22
58420: PUSH
58421: LD_VAR 0 16
58425: PUSH
58426: EMPTY
58427: LIST
58428: LIST
58429: PUSH
58430: LD_INT 2
58432: PUSH
58433: LD_INT 30
58435: PUSH
58436: LD_INT 2
58438: PUSH
58439: EMPTY
58440: LIST
58441: LIST
58442: PUSH
58443: LD_INT 30
58445: PUSH
58446: LD_INT 3
58448: PUSH
58449: EMPTY
58450: LIST
58451: LIST
58452: PUSH
58453: EMPTY
58454: LIST
58455: LIST
58456: LIST
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: PPUSH
58462: CALL_OW 72
58466: ST_TO_ADDR
58467: GO 58551
58469: LD_INT 4
58471: DOUBLE
58472: EQUAL
58473: IFTRUE 58477
58475: GO 58550
58477: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58478: LD_ADDR_VAR 0 12
58482: PUSH
58483: LD_VAR 0 18
58487: PPUSH
58488: LD_INT 22
58490: PUSH
58491: LD_VAR 0 16
58495: PUSH
58496: EMPTY
58497: LIST
58498: LIST
58499: PUSH
58500: LD_INT 2
58502: PUSH
58503: LD_INT 30
58505: PUSH
58506: LD_INT 6
58508: PUSH
58509: EMPTY
58510: LIST
58511: LIST
58512: PUSH
58513: LD_INT 30
58515: PUSH
58516: LD_INT 7
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: PUSH
58523: LD_INT 30
58525: PUSH
58526: LD_INT 8
58528: PUSH
58529: EMPTY
58530: LIST
58531: LIST
58532: PUSH
58533: EMPTY
58534: LIST
58535: LIST
58536: LIST
58537: LIST
58538: PUSH
58539: EMPTY
58540: LIST
58541: LIST
58542: PPUSH
58543: CALL_OW 72
58547: ST_TO_ADDR
58548: GO 58551
58550: POP
// if i = 1 then
58551: LD_VAR 0 8
58555: PUSH
58556: LD_INT 1
58558: EQUAL
58559: IFFALSE 58670
// begin tmp := [ ] ;
58561: LD_ADDR_VAR 0 19
58565: PUSH
58566: EMPTY
58567: ST_TO_ADDR
// for j in f do
58568: LD_ADDR_VAR 0 9
58572: PUSH
58573: LD_VAR 0 12
58577: PUSH
58578: FOR_IN
58579: IFFALSE 58652
// if GetBType ( j ) = b_bunker then
58581: LD_VAR 0 9
58585: PPUSH
58586: CALL_OW 266
58590: PUSH
58591: LD_INT 32
58593: EQUAL
58594: IFFALSE 58621
// tmp := Insert ( tmp , 1 , j ) else
58596: LD_ADDR_VAR 0 19
58600: PUSH
58601: LD_VAR 0 19
58605: PPUSH
58606: LD_INT 1
58608: PPUSH
58609: LD_VAR 0 9
58613: PPUSH
58614: CALL_OW 2
58618: ST_TO_ADDR
58619: GO 58650
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58621: LD_ADDR_VAR 0 19
58625: PUSH
58626: LD_VAR 0 19
58630: PPUSH
58631: LD_VAR 0 19
58635: PUSH
58636: LD_INT 1
58638: PLUS
58639: PPUSH
58640: LD_VAR 0 9
58644: PPUSH
58645: CALL_OW 2
58649: ST_TO_ADDR
58650: GO 58578
58652: POP
58653: POP
// if tmp then
58654: LD_VAR 0 19
58658: IFFALSE 58670
// f := tmp ;
58660: LD_ADDR_VAR 0 12
58664: PUSH
58665: LD_VAR 0 19
58669: ST_TO_ADDR
// end ; x := personel [ i ] ;
58670: LD_ADDR_VAR 0 13
58674: PUSH
58675: LD_VAR 0 6
58679: PUSH
58680: LD_VAR 0 8
58684: ARRAY
58685: ST_TO_ADDR
// if x = - 1 then
58686: LD_VAR 0 13
58690: PUSH
58691: LD_INT 1
58693: NEG
58694: EQUAL
58695: IFFALSE 58904
// begin for j in f do
58697: LD_ADDR_VAR 0 9
58701: PUSH
58702: LD_VAR 0 12
58706: PUSH
58707: FOR_IN
58708: IFFALSE 58900
// repeat InitHc ;
58710: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58714: LD_VAR 0 9
58718: PPUSH
58719: CALL_OW 266
58723: PUSH
58724: LD_INT 5
58726: EQUAL
58727: IFFALSE 58797
// begin if UnitsInside ( j ) < 3 then
58729: LD_VAR 0 9
58733: PPUSH
58734: CALL_OW 313
58738: PUSH
58739: LD_INT 3
58741: LESS
58742: IFFALSE 58778
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58744: LD_INT 0
58746: PPUSH
58747: LD_INT 5
58749: PUSH
58750: LD_INT 8
58752: PUSH
58753: LD_INT 9
58755: PUSH
58756: EMPTY
58757: LIST
58758: LIST
58759: LIST
58760: PUSH
58761: LD_VAR 0 17
58765: ARRAY
58766: PPUSH
58767: LD_VAR 0 4
58771: PPUSH
58772: CALL_OW 380
58776: GO 58795
// PrepareHuman ( false , i , skill ) ;
58778: LD_INT 0
58780: PPUSH
58781: LD_VAR 0 8
58785: PPUSH
58786: LD_VAR 0 4
58790: PPUSH
58791: CALL_OW 380
// end else
58795: GO 58814
// PrepareHuman ( false , i , skill ) ;
58797: LD_INT 0
58799: PPUSH
58800: LD_VAR 0 8
58804: PPUSH
58805: LD_VAR 0 4
58809: PPUSH
58810: CALL_OW 380
// un := CreateHuman ;
58814: LD_ADDR_VAR 0 14
58818: PUSH
58819: CALL_OW 44
58823: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58824: LD_ADDR_VAR 0 7
58828: PUSH
58829: LD_VAR 0 7
58833: PPUSH
58834: LD_INT 1
58836: PPUSH
58837: LD_VAR 0 14
58841: PPUSH
58842: CALL_OW 2
58846: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58847: LD_VAR 0 14
58851: PPUSH
58852: LD_VAR 0 9
58856: PPUSH
58857: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58861: LD_VAR 0 9
58865: PPUSH
58866: CALL_OW 313
58870: PUSH
58871: LD_INT 6
58873: EQUAL
58874: PUSH
58875: LD_VAR 0 9
58879: PPUSH
58880: CALL_OW 266
58884: PUSH
58885: LD_INT 32
58887: PUSH
58888: LD_INT 31
58890: PUSH
58891: EMPTY
58892: LIST
58893: LIST
58894: IN
58895: OR
58896: IFFALSE 58710
58898: GO 58707
58900: POP
58901: POP
// end else
58902: GO 59284
// for j = 1 to x do
58904: LD_ADDR_VAR 0 9
58908: PUSH
58909: DOUBLE
58910: LD_INT 1
58912: DEC
58913: ST_TO_ADDR
58914: LD_VAR 0 13
58918: PUSH
58919: FOR_TO
58920: IFFALSE 59282
// begin InitHc ;
58922: CALL_OW 19
// if not f then
58926: LD_VAR 0 12
58930: NOT
58931: IFFALSE 59020
// begin PrepareHuman ( false , i , skill ) ;
58933: LD_INT 0
58935: PPUSH
58936: LD_VAR 0 8
58940: PPUSH
58941: LD_VAR 0 4
58945: PPUSH
58946: CALL_OW 380
// un := CreateHuman ;
58950: LD_ADDR_VAR 0 14
58954: PUSH
58955: CALL_OW 44
58959: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58960: LD_ADDR_VAR 0 7
58964: PUSH
58965: LD_VAR 0 7
58969: PPUSH
58970: LD_INT 1
58972: PPUSH
58973: LD_VAR 0 14
58977: PPUSH
58978: CALL_OW 2
58982: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58983: LD_VAR 0 14
58987: PPUSH
58988: LD_VAR 0 1
58992: PPUSH
58993: CALL_OW 250
58997: PPUSH
58998: LD_VAR 0 1
59002: PPUSH
59003: CALL_OW 251
59007: PPUSH
59008: LD_INT 10
59010: PPUSH
59011: LD_INT 0
59013: PPUSH
59014: CALL_OW 50
// continue ;
59018: GO 58919
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59020: LD_VAR 0 12
59024: PUSH
59025: LD_INT 1
59027: ARRAY
59028: PPUSH
59029: CALL_OW 313
59033: PUSH
59034: LD_VAR 0 12
59038: PUSH
59039: LD_INT 1
59041: ARRAY
59042: PPUSH
59043: CALL_OW 266
59047: PUSH
59048: LD_INT 32
59050: PUSH
59051: LD_INT 31
59053: PUSH
59054: EMPTY
59055: LIST
59056: LIST
59057: IN
59058: AND
59059: PUSH
59060: LD_VAR 0 12
59064: PUSH
59065: LD_INT 1
59067: ARRAY
59068: PPUSH
59069: CALL_OW 313
59073: PUSH
59074: LD_INT 6
59076: EQUAL
59077: OR
59078: IFFALSE 59098
// f := Delete ( f , 1 ) ;
59080: LD_ADDR_VAR 0 12
59084: PUSH
59085: LD_VAR 0 12
59089: PPUSH
59090: LD_INT 1
59092: PPUSH
59093: CALL_OW 3
59097: ST_TO_ADDR
// if not f then
59098: LD_VAR 0 12
59102: NOT
59103: IFFALSE 59121
// begin x := x + 2 ;
59105: LD_ADDR_VAR 0 13
59109: PUSH
59110: LD_VAR 0 13
59114: PUSH
59115: LD_INT 2
59117: PLUS
59118: ST_TO_ADDR
// continue ;
59119: GO 58919
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59121: LD_VAR 0 12
59125: PUSH
59126: LD_INT 1
59128: ARRAY
59129: PPUSH
59130: CALL_OW 266
59134: PUSH
59135: LD_INT 5
59137: EQUAL
59138: IFFALSE 59212
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59140: LD_VAR 0 12
59144: PUSH
59145: LD_INT 1
59147: ARRAY
59148: PPUSH
59149: CALL_OW 313
59153: PUSH
59154: LD_INT 3
59156: LESS
59157: IFFALSE 59193
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59159: LD_INT 0
59161: PPUSH
59162: LD_INT 5
59164: PUSH
59165: LD_INT 8
59167: PUSH
59168: LD_INT 9
59170: PUSH
59171: EMPTY
59172: LIST
59173: LIST
59174: LIST
59175: PUSH
59176: LD_VAR 0 17
59180: ARRAY
59181: PPUSH
59182: LD_VAR 0 4
59186: PPUSH
59187: CALL_OW 380
59191: GO 59210
// PrepareHuman ( false , i , skill ) ;
59193: LD_INT 0
59195: PPUSH
59196: LD_VAR 0 8
59200: PPUSH
59201: LD_VAR 0 4
59205: PPUSH
59206: CALL_OW 380
// end else
59210: GO 59229
// PrepareHuman ( false , i , skill ) ;
59212: LD_INT 0
59214: PPUSH
59215: LD_VAR 0 8
59219: PPUSH
59220: LD_VAR 0 4
59224: PPUSH
59225: CALL_OW 380
// un := CreateHuman ;
59229: LD_ADDR_VAR 0 14
59233: PUSH
59234: CALL_OW 44
59238: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59239: LD_ADDR_VAR 0 7
59243: PUSH
59244: LD_VAR 0 7
59248: PPUSH
59249: LD_INT 1
59251: PPUSH
59252: LD_VAR 0 14
59256: PPUSH
59257: CALL_OW 2
59261: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59262: LD_VAR 0 14
59266: PPUSH
59267: LD_VAR 0 12
59271: PUSH
59272: LD_INT 1
59274: ARRAY
59275: PPUSH
59276: CALL_OW 52
// end ;
59280: GO 58919
59282: POP
59283: POP
// end ;
59284: GO 58221
59286: POP
59287: POP
// result := result ^ buildings ;
59288: LD_ADDR_VAR 0 7
59292: PUSH
59293: LD_VAR 0 7
59297: PUSH
59298: LD_VAR 0 18
59302: ADD
59303: ST_TO_ADDR
// end else
59304: GO 59447
// begin for i = 1 to personel do
59306: LD_ADDR_VAR 0 8
59310: PUSH
59311: DOUBLE
59312: LD_INT 1
59314: DEC
59315: ST_TO_ADDR
59316: LD_VAR 0 6
59320: PUSH
59321: FOR_TO
59322: IFFALSE 59445
// begin if i > 4 then
59324: LD_VAR 0 8
59328: PUSH
59329: LD_INT 4
59331: GREATER
59332: IFFALSE 59336
// break ;
59334: GO 59445
// x := personel [ i ] ;
59336: LD_ADDR_VAR 0 13
59340: PUSH
59341: LD_VAR 0 6
59345: PUSH
59346: LD_VAR 0 8
59350: ARRAY
59351: ST_TO_ADDR
// if x = - 1 then
59352: LD_VAR 0 13
59356: PUSH
59357: LD_INT 1
59359: NEG
59360: EQUAL
59361: IFFALSE 59365
// continue ;
59363: GO 59321
// PrepareHuman ( false , i , skill ) ;
59365: LD_INT 0
59367: PPUSH
59368: LD_VAR 0 8
59372: PPUSH
59373: LD_VAR 0 4
59377: PPUSH
59378: CALL_OW 380
// un := CreateHuman ;
59382: LD_ADDR_VAR 0 14
59386: PUSH
59387: CALL_OW 44
59391: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59392: LD_VAR 0 14
59396: PPUSH
59397: LD_VAR 0 1
59401: PPUSH
59402: CALL_OW 250
59406: PPUSH
59407: LD_VAR 0 1
59411: PPUSH
59412: CALL_OW 251
59416: PPUSH
59417: LD_INT 10
59419: PPUSH
59420: LD_INT 0
59422: PPUSH
59423: CALL_OW 50
// result := result ^ un ;
59427: LD_ADDR_VAR 0 7
59431: PUSH
59432: LD_VAR 0 7
59436: PUSH
59437: LD_VAR 0 14
59441: ADD
59442: ST_TO_ADDR
// end ;
59443: GO 59321
59445: POP
59446: POP
// end ; end ;
59447: LD_VAR 0 7
59451: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59452: LD_INT 0
59454: PPUSH
59455: PPUSH
59456: PPUSH
59457: PPUSH
59458: PPUSH
59459: PPUSH
59460: PPUSH
59461: PPUSH
59462: PPUSH
59463: PPUSH
59464: PPUSH
59465: PPUSH
59466: PPUSH
59467: PPUSH
59468: PPUSH
59469: PPUSH
// result := false ;
59470: LD_ADDR_VAR 0 3
59474: PUSH
59475: LD_INT 0
59477: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59478: LD_VAR 0 1
59482: NOT
59483: PUSH
59484: LD_VAR 0 1
59488: PPUSH
59489: CALL_OW 266
59493: PUSH
59494: LD_INT 32
59496: PUSH
59497: LD_INT 33
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: IN
59504: NOT
59505: OR
59506: IFFALSE 59510
// exit ;
59508: GO 60619
// nat := GetNation ( tower ) ;
59510: LD_ADDR_VAR 0 12
59514: PUSH
59515: LD_VAR 0 1
59519: PPUSH
59520: CALL_OW 248
59524: ST_TO_ADDR
// side := GetSide ( tower ) ;
59525: LD_ADDR_VAR 0 16
59529: PUSH
59530: LD_VAR 0 1
59534: PPUSH
59535: CALL_OW 255
59539: ST_TO_ADDR
// x := GetX ( tower ) ;
59540: LD_ADDR_VAR 0 10
59544: PUSH
59545: LD_VAR 0 1
59549: PPUSH
59550: CALL_OW 250
59554: ST_TO_ADDR
// y := GetY ( tower ) ;
59555: LD_ADDR_VAR 0 11
59559: PUSH
59560: LD_VAR 0 1
59564: PPUSH
59565: CALL_OW 251
59569: ST_TO_ADDR
// if not x or not y then
59570: LD_VAR 0 10
59574: NOT
59575: PUSH
59576: LD_VAR 0 11
59580: NOT
59581: OR
59582: IFFALSE 59586
// exit ;
59584: GO 60619
// weapon := 0 ;
59586: LD_ADDR_VAR 0 18
59590: PUSH
59591: LD_INT 0
59593: ST_TO_ADDR
// fac_list := [ ] ;
59594: LD_ADDR_VAR 0 17
59598: PUSH
59599: EMPTY
59600: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59601: LD_ADDR_VAR 0 6
59605: PUSH
59606: LD_VAR 0 1
59610: PPUSH
59611: CALL_OW 274
59615: PPUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: LD_INT 0
59623: PPUSH
59624: CALL 57190 0 3
59628: PPUSH
59629: LD_INT 30
59631: PUSH
59632: LD_INT 3
59634: PUSH
59635: EMPTY
59636: LIST
59637: LIST
59638: PPUSH
59639: CALL_OW 72
59643: ST_TO_ADDR
// if not factories then
59644: LD_VAR 0 6
59648: NOT
59649: IFFALSE 59653
// exit ;
59651: GO 60619
// for i in factories do
59653: LD_ADDR_VAR 0 8
59657: PUSH
59658: LD_VAR 0 6
59662: PUSH
59663: FOR_IN
59664: IFFALSE 59689
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59666: LD_ADDR_VAR 0 17
59670: PUSH
59671: LD_VAR 0 17
59675: PUSH
59676: LD_VAR 0 8
59680: PPUSH
59681: CALL_OW 478
59685: UNION
59686: ST_TO_ADDR
59687: GO 59663
59689: POP
59690: POP
// if not fac_list then
59691: LD_VAR 0 17
59695: NOT
59696: IFFALSE 59700
// exit ;
59698: GO 60619
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59700: LD_ADDR_VAR 0 5
59704: PUSH
59705: LD_INT 4
59707: PUSH
59708: LD_INT 5
59710: PUSH
59711: LD_INT 9
59713: PUSH
59714: LD_INT 10
59716: PUSH
59717: LD_INT 6
59719: PUSH
59720: LD_INT 7
59722: PUSH
59723: LD_INT 11
59725: PUSH
59726: EMPTY
59727: LIST
59728: LIST
59729: LIST
59730: LIST
59731: LIST
59732: LIST
59733: LIST
59734: PUSH
59735: LD_INT 27
59737: PUSH
59738: LD_INT 28
59740: PUSH
59741: LD_INT 26
59743: PUSH
59744: LD_INT 30
59746: PUSH
59747: EMPTY
59748: LIST
59749: LIST
59750: LIST
59751: LIST
59752: PUSH
59753: LD_INT 43
59755: PUSH
59756: LD_INT 44
59758: PUSH
59759: LD_INT 46
59761: PUSH
59762: LD_INT 45
59764: PUSH
59765: LD_INT 47
59767: PUSH
59768: LD_INT 49
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: LIST
59775: LIST
59776: LIST
59777: LIST
59778: PUSH
59779: EMPTY
59780: LIST
59781: LIST
59782: LIST
59783: PUSH
59784: LD_VAR 0 12
59788: ARRAY
59789: ST_TO_ADDR
// list := list isect fac_list ;
59790: LD_ADDR_VAR 0 5
59794: PUSH
59795: LD_VAR 0 5
59799: PUSH
59800: LD_VAR 0 17
59804: ISECT
59805: ST_TO_ADDR
// if not list then
59806: LD_VAR 0 5
59810: NOT
59811: IFFALSE 59815
// exit ;
59813: GO 60619
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59815: LD_VAR 0 12
59819: PUSH
59820: LD_INT 3
59822: EQUAL
59823: PUSH
59824: LD_INT 49
59826: PUSH
59827: LD_VAR 0 5
59831: IN
59832: AND
59833: PUSH
59834: LD_INT 31
59836: PPUSH
59837: LD_VAR 0 16
59841: PPUSH
59842: CALL_OW 321
59846: PUSH
59847: LD_INT 2
59849: EQUAL
59850: AND
59851: IFFALSE 59911
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59853: LD_INT 22
59855: PUSH
59856: LD_VAR 0 16
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: PUSH
59865: LD_INT 35
59867: PUSH
59868: LD_INT 49
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: LD_INT 91
59877: PUSH
59878: LD_VAR 0 1
59882: PUSH
59883: LD_INT 10
59885: PUSH
59886: EMPTY
59887: LIST
59888: LIST
59889: LIST
59890: PUSH
59891: EMPTY
59892: LIST
59893: LIST
59894: LIST
59895: PPUSH
59896: CALL_OW 69
59900: NOT
59901: IFFALSE 59911
// weapon := ru_time_lapser ;
59903: LD_ADDR_VAR 0 18
59907: PUSH
59908: LD_INT 49
59910: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59911: LD_VAR 0 12
59915: PUSH
59916: LD_INT 1
59918: PUSH
59919: LD_INT 2
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: IN
59926: PUSH
59927: LD_INT 11
59929: PUSH
59930: LD_VAR 0 5
59934: IN
59935: PUSH
59936: LD_INT 30
59938: PUSH
59939: LD_VAR 0 5
59943: IN
59944: OR
59945: AND
59946: PUSH
59947: LD_INT 6
59949: PPUSH
59950: LD_VAR 0 16
59954: PPUSH
59955: CALL_OW 321
59959: PUSH
59960: LD_INT 2
59962: EQUAL
59963: AND
59964: IFFALSE 60129
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59966: LD_INT 22
59968: PUSH
59969: LD_VAR 0 16
59973: PUSH
59974: EMPTY
59975: LIST
59976: LIST
59977: PUSH
59978: LD_INT 2
59980: PUSH
59981: LD_INT 35
59983: PUSH
59984: LD_INT 11
59986: PUSH
59987: EMPTY
59988: LIST
59989: LIST
59990: PUSH
59991: LD_INT 35
59993: PUSH
59994: LD_INT 30
59996: PUSH
59997: EMPTY
59998: LIST
59999: LIST
60000: PUSH
60001: EMPTY
60002: LIST
60003: LIST
60004: LIST
60005: PUSH
60006: LD_INT 91
60008: PUSH
60009: LD_VAR 0 1
60013: PUSH
60014: LD_INT 18
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: LIST
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: LIST
60026: PPUSH
60027: CALL_OW 69
60031: NOT
60032: PUSH
60033: LD_INT 22
60035: PUSH
60036: LD_VAR 0 16
60040: PUSH
60041: EMPTY
60042: LIST
60043: LIST
60044: PUSH
60045: LD_INT 2
60047: PUSH
60048: LD_INT 30
60050: PUSH
60051: LD_INT 32
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: LD_INT 30
60060: PUSH
60061: LD_INT 33
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: PUSH
60068: EMPTY
60069: LIST
60070: LIST
60071: LIST
60072: PUSH
60073: LD_INT 91
60075: PUSH
60076: LD_VAR 0 1
60080: PUSH
60081: LD_INT 12
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: LIST
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: LIST
60093: PUSH
60094: EMPTY
60095: LIST
60096: PPUSH
60097: CALL_OW 69
60101: PUSH
60102: LD_INT 2
60104: GREATER
60105: AND
60106: IFFALSE 60129
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60108: LD_ADDR_VAR 0 18
60112: PUSH
60113: LD_INT 11
60115: PUSH
60116: LD_INT 30
60118: PUSH
60119: EMPTY
60120: LIST
60121: LIST
60122: PUSH
60123: LD_VAR 0 12
60127: ARRAY
60128: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60129: LD_VAR 0 18
60133: NOT
60134: PUSH
60135: LD_INT 40
60137: PPUSH
60138: LD_VAR 0 16
60142: PPUSH
60143: CALL_OW 321
60147: PUSH
60148: LD_INT 2
60150: EQUAL
60151: AND
60152: PUSH
60153: LD_INT 7
60155: PUSH
60156: LD_VAR 0 5
60160: IN
60161: PUSH
60162: LD_INT 28
60164: PUSH
60165: LD_VAR 0 5
60169: IN
60170: OR
60171: PUSH
60172: LD_INT 45
60174: PUSH
60175: LD_VAR 0 5
60179: IN
60180: OR
60181: AND
60182: IFFALSE 60436
// begin hex := GetHexInfo ( x , y ) ;
60184: LD_ADDR_VAR 0 4
60188: PUSH
60189: LD_VAR 0 10
60193: PPUSH
60194: LD_VAR 0 11
60198: PPUSH
60199: CALL_OW 546
60203: ST_TO_ADDR
// if hex [ 1 ] then
60204: LD_VAR 0 4
60208: PUSH
60209: LD_INT 1
60211: ARRAY
60212: IFFALSE 60216
// exit ;
60214: GO 60619
// height := hex [ 2 ] ;
60216: LD_ADDR_VAR 0 15
60220: PUSH
60221: LD_VAR 0 4
60225: PUSH
60226: LD_INT 2
60228: ARRAY
60229: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60230: LD_ADDR_VAR 0 14
60234: PUSH
60235: LD_INT 0
60237: PUSH
60238: LD_INT 2
60240: PUSH
60241: LD_INT 3
60243: PUSH
60244: LD_INT 5
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: LIST
60251: LIST
60252: ST_TO_ADDR
// for i in tmp do
60253: LD_ADDR_VAR 0 8
60257: PUSH
60258: LD_VAR 0 14
60262: PUSH
60263: FOR_IN
60264: IFFALSE 60434
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60266: LD_ADDR_VAR 0 9
60270: PUSH
60271: LD_VAR 0 10
60275: PPUSH
60276: LD_VAR 0 8
60280: PPUSH
60281: LD_INT 5
60283: PPUSH
60284: CALL_OW 272
60288: PUSH
60289: LD_VAR 0 11
60293: PPUSH
60294: LD_VAR 0 8
60298: PPUSH
60299: LD_INT 5
60301: PPUSH
60302: CALL_OW 273
60306: PUSH
60307: EMPTY
60308: LIST
60309: LIST
60310: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60311: LD_VAR 0 9
60315: PUSH
60316: LD_INT 1
60318: ARRAY
60319: PPUSH
60320: LD_VAR 0 9
60324: PUSH
60325: LD_INT 2
60327: ARRAY
60328: PPUSH
60329: CALL_OW 488
60333: IFFALSE 60432
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60335: LD_ADDR_VAR 0 4
60339: PUSH
60340: LD_VAR 0 9
60344: PUSH
60345: LD_INT 1
60347: ARRAY
60348: PPUSH
60349: LD_VAR 0 9
60353: PUSH
60354: LD_INT 2
60356: ARRAY
60357: PPUSH
60358: CALL_OW 546
60362: ST_TO_ADDR
// if hex [ 1 ] then
60363: LD_VAR 0 4
60367: PUSH
60368: LD_INT 1
60370: ARRAY
60371: IFFALSE 60375
// continue ;
60373: GO 60263
// h := hex [ 2 ] ;
60375: LD_ADDR_VAR 0 13
60379: PUSH
60380: LD_VAR 0 4
60384: PUSH
60385: LD_INT 2
60387: ARRAY
60388: ST_TO_ADDR
// if h + 7 < height then
60389: LD_VAR 0 13
60393: PUSH
60394: LD_INT 7
60396: PLUS
60397: PUSH
60398: LD_VAR 0 15
60402: LESS
60403: IFFALSE 60432
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60405: LD_ADDR_VAR 0 18
60409: PUSH
60410: LD_INT 7
60412: PUSH
60413: LD_INT 28
60415: PUSH
60416: LD_INT 45
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: LIST
60423: PUSH
60424: LD_VAR 0 12
60428: ARRAY
60429: ST_TO_ADDR
// break ;
60430: GO 60434
// end ; end ; end ;
60432: GO 60263
60434: POP
60435: POP
// end ; if not weapon then
60436: LD_VAR 0 18
60440: NOT
60441: IFFALSE 60501
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60443: LD_ADDR_VAR 0 5
60447: PUSH
60448: LD_VAR 0 5
60452: PUSH
60453: LD_INT 11
60455: PUSH
60456: LD_INT 30
60458: PUSH
60459: LD_INT 49
60461: PUSH
60462: EMPTY
60463: LIST
60464: LIST
60465: LIST
60466: DIFF
60467: ST_TO_ADDR
// if not list then
60468: LD_VAR 0 5
60472: NOT
60473: IFFALSE 60477
// exit ;
60475: GO 60619
// weapon := list [ rand ( 1 , list ) ] ;
60477: LD_ADDR_VAR 0 18
60481: PUSH
60482: LD_VAR 0 5
60486: PUSH
60487: LD_INT 1
60489: PPUSH
60490: LD_VAR 0 5
60494: PPUSH
60495: CALL_OW 12
60499: ARRAY
60500: ST_TO_ADDR
// end ; if weapon then
60501: LD_VAR 0 18
60505: IFFALSE 60619
// begin tmp := CostOfWeapon ( weapon ) ;
60507: LD_ADDR_VAR 0 14
60511: PUSH
60512: LD_VAR 0 18
60516: PPUSH
60517: CALL_OW 451
60521: ST_TO_ADDR
// j := GetBase ( tower ) ;
60522: LD_ADDR_VAR 0 9
60526: PUSH
60527: LD_VAR 0 1
60531: PPUSH
60532: CALL_OW 274
60536: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60537: LD_VAR 0 9
60541: PPUSH
60542: LD_INT 1
60544: PPUSH
60545: CALL_OW 275
60549: PUSH
60550: LD_VAR 0 14
60554: PUSH
60555: LD_INT 1
60557: ARRAY
60558: GREATEREQUAL
60559: PUSH
60560: LD_VAR 0 9
60564: PPUSH
60565: LD_INT 2
60567: PPUSH
60568: CALL_OW 275
60572: PUSH
60573: LD_VAR 0 14
60577: PUSH
60578: LD_INT 2
60580: ARRAY
60581: GREATEREQUAL
60582: AND
60583: PUSH
60584: LD_VAR 0 9
60588: PPUSH
60589: LD_INT 3
60591: PPUSH
60592: CALL_OW 275
60596: PUSH
60597: LD_VAR 0 14
60601: PUSH
60602: LD_INT 3
60604: ARRAY
60605: GREATEREQUAL
60606: AND
60607: IFFALSE 60619
// result := weapon ;
60609: LD_ADDR_VAR 0 3
60613: PUSH
60614: LD_VAR 0 18
60618: ST_TO_ADDR
// end ; end ;
60619: LD_VAR 0 3
60623: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60624: LD_INT 0
60626: PPUSH
60627: PPUSH
// result := true ;
60628: LD_ADDR_VAR 0 3
60632: PUSH
60633: LD_INT 1
60635: ST_TO_ADDR
// if array1 = array2 then
60636: LD_VAR 0 1
60640: PUSH
60641: LD_VAR 0 2
60645: EQUAL
60646: IFFALSE 60706
// begin for i = 1 to array1 do
60648: LD_ADDR_VAR 0 4
60652: PUSH
60653: DOUBLE
60654: LD_INT 1
60656: DEC
60657: ST_TO_ADDR
60658: LD_VAR 0 1
60662: PUSH
60663: FOR_TO
60664: IFFALSE 60702
// if array1 [ i ] <> array2 [ i ] then
60666: LD_VAR 0 1
60670: PUSH
60671: LD_VAR 0 4
60675: ARRAY
60676: PUSH
60677: LD_VAR 0 2
60681: PUSH
60682: LD_VAR 0 4
60686: ARRAY
60687: NONEQUAL
60688: IFFALSE 60700
// begin result := false ;
60690: LD_ADDR_VAR 0 3
60694: PUSH
60695: LD_INT 0
60697: ST_TO_ADDR
// break ;
60698: GO 60702
// end ;
60700: GO 60663
60702: POP
60703: POP
// end else
60704: GO 60714
// result := false ;
60706: LD_ADDR_VAR 0 3
60710: PUSH
60711: LD_INT 0
60713: ST_TO_ADDR
// end ;
60714: LD_VAR 0 3
60718: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60719: LD_INT 0
60721: PPUSH
60722: PPUSH
// if not array1 or not array2 then
60723: LD_VAR 0 1
60727: NOT
60728: PUSH
60729: LD_VAR 0 2
60733: NOT
60734: OR
60735: IFFALSE 60739
// exit ;
60737: GO 60803
// result := true ;
60739: LD_ADDR_VAR 0 3
60743: PUSH
60744: LD_INT 1
60746: ST_TO_ADDR
// for i = 1 to array1 do
60747: LD_ADDR_VAR 0 4
60751: PUSH
60752: DOUBLE
60753: LD_INT 1
60755: DEC
60756: ST_TO_ADDR
60757: LD_VAR 0 1
60761: PUSH
60762: FOR_TO
60763: IFFALSE 60801
// if array1 [ i ] <> array2 [ i ] then
60765: LD_VAR 0 1
60769: PUSH
60770: LD_VAR 0 4
60774: ARRAY
60775: PUSH
60776: LD_VAR 0 2
60780: PUSH
60781: LD_VAR 0 4
60785: ARRAY
60786: NONEQUAL
60787: IFFALSE 60799
// begin result := false ;
60789: LD_ADDR_VAR 0 3
60793: PUSH
60794: LD_INT 0
60796: ST_TO_ADDR
// break ;
60797: GO 60801
// end ;
60799: GO 60762
60801: POP
60802: POP
// end ;
60803: LD_VAR 0 3
60807: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60808: LD_INT 0
60810: PPUSH
60811: PPUSH
60812: PPUSH
// pom := GetBase ( fac ) ;
60813: LD_ADDR_VAR 0 5
60817: PUSH
60818: LD_VAR 0 1
60822: PPUSH
60823: CALL_OW 274
60827: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60828: LD_ADDR_VAR 0 4
60832: PUSH
60833: LD_VAR 0 2
60837: PUSH
60838: LD_INT 1
60840: ARRAY
60841: PPUSH
60842: LD_VAR 0 2
60846: PUSH
60847: LD_INT 2
60849: ARRAY
60850: PPUSH
60851: LD_VAR 0 2
60855: PUSH
60856: LD_INT 3
60858: ARRAY
60859: PPUSH
60860: LD_VAR 0 2
60864: PUSH
60865: LD_INT 4
60867: ARRAY
60868: PPUSH
60869: CALL_OW 449
60873: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60874: LD_ADDR_VAR 0 3
60878: PUSH
60879: LD_VAR 0 5
60883: PPUSH
60884: LD_INT 1
60886: PPUSH
60887: CALL_OW 275
60891: PUSH
60892: LD_VAR 0 4
60896: PUSH
60897: LD_INT 1
60899: ARRAY
60900: GREATEREQUAL
60901: PUSH
60902: LD_VAR 0 5
60906: PPUSH
60907: LD_INT 2
60909: PPUSH
60910: CALL_OW 275
60914: PUSH
60915: LD_VAR 0 4
60919: PUSH
60920: LD_INT 2
60922: ARRAY
60923: GREATEREQUAL
60924: AND
60925: PUSH
60926: LD_VAR 0 5
60930: PPUSH
60931: LD_INT 3
60933: PPUSH
60934: CALL_OW 275
60938: PUSH
60939: LD_VAR 0 4
60943: PUSH
60944: LD_INT 3
60946: ARRAY
60947: GREATEREQUAL
60948: AND
60949: ST_TO_ADDR
// end ;
60950: LD_VAR 0 3
60954: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60955: LD_INT 0
60957: PPUSH
60958: PPUSH
60959: PPUSH
60960: PPUSH
// pom := GetBase ( building ) ;
60961: LD_ADDR_VAR 0 3
60965: PUSH
60966: LD_VAR 0 1
60970: PPUSH
60971: CALL_OW 274
60975: ST_TO_ADDR
// if not pom then
60976: LD_VAR 0 3
60980: NOT
60981: IFFALSE 60985
// exit ;
60983: GO 61155
// btype := GetBType ( building ) ;
60985: LD_ADDR_VAR 0 5
60989: PUSH
60990: LD_VAR 0 1
60994: PPUSH
60995: CALL_OW 266
60999: ST_TO_ADDR
// if btype = b_armoury then
61000: LD_VAR 0 5
61004: PUSH
61005: LD_INT 4
61007: EQUAL
61008: IFFALSE 61018
// btype := b_barracks ;
61010: LD_ADDR_VAR 0 5
61014: PUSH
61015: LD_INT 5
61017: ST_TO_ADDR
// if btype = b_depot then
61018: LD_VAR 0 5
61022: PUSH
61023: LD_INT 0
61025: EQUAL
61026: IFFALSE 61036
// btype := b_warehouse ;
61028: LD_ADDR_VAR 0 5
61032: PUSH
61033: LD_INT 1
61035: ST_TO_ADDR
// if btype = b_workshop then
61036: LD_VAR 0 5
61040: PUSH
61041: LD_INT 2
61043: EQUAL
61044: IFFALSE 61054
// btype := b_factory ;
61046: LD_ADDR_VAR 0 5
61050: PUSH
61051: LD_INT 3
61053: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61054: LD_ADDR_VAR 0 4
61058: PUSH
61059: LD_VAR 0 5
61063: PPUSH
61064: LD_VAR 0 1
61068: PPUSH
61069: CALL_OW 248
61073: PPUSH
61074: CALL_OW 450
61078: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61079: LD_ADDR_VAR 0 2
61083: PUSH
61084: LD_VAR 0 3
61088: PPUSH
61089: LD_INT 1
61091: PPUSH
61092: CALL_OW 275
61096: PUSH
61097: LD_VAR 0 4
61101: PUSH
61102: LD_INT 1
61104: ARRAY
61105: GREATEREQUAL
61106: PUSH
61107: LD_VAR 0 3
61111: PPUSH
61112: LD_INT 2
61114: PPUSH
61115: CALL_OW 275
61119: PUSH
61120: LD_VAR 0 4
61124: PUSH
61125: LD_INT 2
61127: ARRAY
61128: GREATEREQUAL
61129: AND
61130: PUSH
61131: LD_VAR 0 3
61135: PPUSH
61136: LD_INT 3
61138: PPUSH
61139: CALL_OW 275
61143: PUSH
61144: LD_VAR 0 4
61148: PUSH
61149: LD_INT 3
61151: ARRAY
61152: GREATEREQUAL
61153: AND
61154: ST_TO_ADDR
// end ;
61155: LD_VAR 0 2
61159: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61160: LD_INT 0
61162: PPUSH
61163: PPUSH
61164: PPUSH
// pom := GetBase ( building ) ;
61165: LD_ADDR_VAR 0 4
61169: PUSH
61170: LD_VAR 0 1
61174: PPUSH
61175: CALL_OW 274
61179: ST_TO_ADDR
// if not pom then
61180: LD_VAR 0 4
61184: NOT
61185: IFFALSE 61189
// exit ;
61187: GO 61290
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61189: LD_ADDR_VAR 0 5
61193: PUSH
61194: LD_VAR 0 2
61198: PPUSH
61199: LD_VAR 0 1
61203: PPUSH
61204: CALL_OW 248
61208: PPUSH
61209: CALL_OW 450
61213: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61214: LD_ADDR_VAR 0 3
61218: PUSH
61219: LD_VAR 0 4
61223: PPUSH
61224: LD_INT 1
61226: PPUSH
61227: CALL_OW 275
61231: PUSH
61232: LD_VAR 0 5
61236: PUSH
61237: LD_INT 1
61239: ARRAY
61240: GREATEREQUAL
61241: PUSH
61242: LD_VAR 0 4
61246: PPUSH
61247: LD_INT 2
61249: PPUSH
61250: CALL_OW 275
61254: PUSH
61255: LD_VAR 0 5
61259: PUSH
61260: LD_INT 2
61262: ARRAY
61263: GREATEREQUAL
61264: AND
61265: PUSH
61266: LD_VAR 0 4
61270: PPUSH
61271: LD_INT 3
61273: PPUSH
61274: CALL_OW 275
61278: PUSH
61279: LD_VAR 0 5
61283: PUSH
61284: LD_INT 3
61286: ARRAY
61287: GREATEREQUAL
61288: AND
61289: ST_TO_ADDR
// end ;
61290: LD_VAR 0 3
61294: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61295: LD_INT 0
61297: PPUSH
61298: PPUSH
61299: PPUSH
61300: PPUSH
61301: PPUSH
61302: PPUSH
61303: PPUSH
61304: PPUSH
61305: PPUSH
61306: PPUSH
61307: PPUSH
// result := false ;
61308: LD_ADDR_VAR 0 8
61312: PUSH
61313: LD_INT 0
61315: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61316: LD_VAR 0 5
61320: NOT
61321: PUSH
61322: LD_VAR 0 1
61326: NOT
61327: OR
61328: PUSH
61329: LD_VAR 0 2
61333: NOT
61334: OR
61335: PUSH
61336: LD_VAR 0 3
61340: NOT
61341: OR
61342: IFFALSE 61346
// exit ;
61344: GO 62160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61346: LD_ADDR_VAR 0 14
61350: PUSH
61351: LD_VAR 0 1
61355: PPUSH
61356: LD_VAR 0 2
61360: PPUSH
61361: LD_VAR 0 3
61365: PPUSH
61366: LD_VAR 0 4
61370: PPUSH
61371: LD_VAR 0 5
61375: PUSH
61376: LD_INT 1
61378: ARRAY
61379: PPUSH
61380: CALL_OW 248
61384: PPUSH
61385: LD_INT 0
61387: PPUSH
61388: CALL 63413 0 6
61392: ST_TO_ADDR
// if not hexes then
61393: LD_VAR 0 14
61397: NOT
61398: IFFALSE 61402
// exit ;
61400: GO 62160
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61402: LD_ADDR_VAR 0 17
61406: PUSH
61407: LD_VAR 0 5
61411: PPUSH
61412: LD_INT 22
61414: PUSH
61415: LD_VAR 0 13
61419: PPUSH
61420: CALL_OW 255
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PUSH
61429: LD_INT 2
61431: PUSH
61432: LD_INT 30
61434: PUSH
61435: LD_INT 0
61437: PUSH
61438: EMPTY
61439: LIST
61440: LIST
61441: PUSH
61442: LD_INT 30
61444: PUSH
61445: LD_INT 1
61447: PUSH
61448: EMPTY
61449: LIST
61450: LIST
61451: PUSH
61452: EMPTY
61453: LIST
61454: LIST
61455: LIST
61456: PUSH
61457: EMPTY
61458: LIST
61459: LIST
61460: PPUSH
61461: CALL_OW 72
61465: ST_TO_ADDR
// for i = 1 to hexes do
61466: LD_ADDR_VAR 0 9
61470: PUSH
61471: DOUBLE
61472: LD_INT 1
61474: DEC
61475: ST_TO_ADDR
61476: LD_VAR 0 14
61480: PUSH
61481: FOR_TO
61482: IFFALSE 62158
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61484: LD_ADDR_VAR 0 13
61488: PUSH
61489: LD_VAR 0 14
61493: PUSH
61494: LD_VAR 0 9
61498: ARRAY
61499: PUSH
61500: LD_INT 1
61502: ARRAY
61503: PPUSH
61504: LD_VAR 0 14
61508: PUSH
61509: LD_VAR 0 9
61513: ARRAY
61514: PUSH
61515: LD_INT 2
61517: ARRAY
61518: PPUSH
61519: CALL_OW 428
61523: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61524: LD_VAR 0 14
61528: PUSH
61529: LD_VAR 0 9
61533: ARRAY
61534: PUSH
61535: LD_INT 1
61537: ARRAY
61538: PPUSH
61539: LD_VAR 0 14
61543: PUSH
61544: LD_VAR 0 9
61548: ARRAY
61549: PUSH
61550: LD_INT 2
61552: ARRAY
61553: PPUSH
61554: CALL_OW 351
61558: PUSH
61559: LD_VAR 0 14
61563: PUSH
61564: LD_VAR 0 9
61568: ARRAY
61569: PUSH
61570: LD_INT 1
61572: ARRAY
61573: PPUSH
61574: LD_VAR 0 14
61578: PUSH
61579: LD_VAR 0 9
61583: ARRAY
61584: PUSH
61585: LD_INT 2
61587: ARRAY
61588: PPUSH
61589: CALL_OW 488
61593: NOT
61594: OR
61595: PUSH
61596: LD_VAR 0 13
61600: PPUSH
61601: CALL_OW 247
61605: PUSH
61606: LD_INT 3
61608: EQUAL
61609: OR
61610: IFFALSE 61616
// exit ;
61612: POP
61613: POP
61614: GO 62160
// if not tmp then
61616: LD_VAR 0 13
61620: NOT
61621: IFFALSE 61625
// continue ;
61623: GO 61481
// result := true ;
61625: LD_ADDR_VAR 0 8
61629: PUSH
61630: LD_INT 1
61632: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61633: LD_VAR 0 6
61637: PUSH
61638: LD_VAR 0 13
61642: PPUSH
61643: CALL_OW 247
61647: PUSH
61648: LD_INT 2
61650: EQUAL
61651: AND
61652: PUSH
61653: LD_VAR 0 13
61657: PPUSH
61658: CALL_OW 263
61662: PUSH
61663: LD_INT 1
61665: EQUAL
61666: AND
61667: IFFALSE 61831
// begin if IsDrivenBy ( tmp ) then
61669: LD_VAR 0 13
61673: PPUSH
61674: CALL_OW 311
61678: IFFALSE 61682
// continue ;
61680: GO 61481
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61682: LD_VAR 0 6
61686: PPUSH
61687: LD_INT 3
61689: PUSH
61690: LD_INT 60
61692: PUSH
61693: EMPTY
61694: LIST
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: LD_INT 3
61702: PUSH
61703: LD_INT 55
61705: PUSH
61706: EMPTY
61707: LIST
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: EMPTY
61714: LIST
61715: LIST
61716: PPUSH
61717: CALL_OW 72
61721: IFFALSE 61829
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61723: LD_ADDR_VAR 0 18
61727: PUSH
61728: LD_VAR 0 6
61732: PPUSH
61733: LD_INT 3
61735: PUSH
61736: LD_INT 60
61738: PUSH
61739: EMPTY
61740: LIST
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: PUSH
61746: LD_INT 3
61748: PUSH
61749: LD_INT 55
61751: PUSH
61752: EMPTY
61753: LIST
61754: PUSH
61755: EMPTY
61756: LIST
61757: LIST
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PPUSH
61763: CALL_OW 72
61767: PUSH
61768: LD_INT 1
61770: ARRAY
61771: ST_TO_ADDR
// if IsInUnit ( driver ) then
61772: LD_VAR 0 18
61776: PPUSH
61777: CALL_OW 310
61781: IFFALSE 61792
// ComExit ( driver ) ;
61783: LD_VAR 0 18
61787: PPUSH
61788: CALL 87205 0 1
// AddComEnterUnit ( driver , tmp ) ;
61792: LD_VAR 0 18
61796: PPUSH
61797: LD_VAR 0 13
61801: PPUSH
61802: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61806: LD_VAR 0 18
61810: PPUSH
61811: LD_VAR 0 7
61815: PPUSH
61816: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61820: LD_VAR 0 18
61824: PPUSH
61825: CALL_OW 181
// end ; continue ;
61829: GO 61481
// end ; if not cleaners or not tmp in cleaners then
61831: LD_VAR 0 6
61835: NOT
61836: PUSH
61837: LD_VAR 0 13
61841: PUSH
61842: LD_VAR 0 6
61846: IN
61847: NOT
61848: OR
61849: IFFALSE 62156
// begin if dep then
61851: LD_VAR 0 17
61855: IFFALSE 61991
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61857: LD_ADDR_VAR 0 16
61861: PUSH
61862: LD_VAR 0 17
61866: PUSH
61867: LD_INT 1
61869: ARRAY
61870: PPUSH
61871: CALL_OW 250
61875: PPUSH
61876: LD_VAR 0 17
61880: PUSH
61881: LD_INT 1
61883: ARRAY
61884: PPUSH
61885: CALL_OW 254
61889: PPUSH
61890: LD_INT 5
61892: PPUSH
61893: CALL_OW 272
61897: PUSH
61898: LD_VAR 0 17
61902: PUSH
61903: LD_INT 1
61905: ARRAY
61906: PPUSH
61907: CALL_OW 251
61911: PPUSH
61912: LD_VAR 0 17
61916: PUSH
61917: LD_INT 1
61919: ARRAY
61920: PPUSH
61921: CALL_OW 254
61925: PPUSH
61926: LD_INT 5
61928: PPUSH
61929: CALL_OW 273
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61938: LD_VAR 0 16
61942: PUSH
61943: LD_INT 1
61945: ARRAY
61946: PPUSH
61947: LD_VAR 0 16
61951: PUSH
61952: LD_INT 2
61954: ARRAY
61955: PPUSH
61956: CALL_OW 488
61960: IFFALSE 61991
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61962: LD_VAR 0 13
61966: PPUSH
61967: LD_VAR 0 16
61971: PUSH
61972: LD_INT 1
61974: ARRAY
61975: PPUSH
61976: LD_VAR 0 16
61980: PUSH
61981: LD_INT 2
61983: ARRAY
61984: PPUSH
61985: CALL_OW 111
// continue ;
61989: GO 61481
// end ; end ; r := GetDir ( tmp ) ;
61991: LD_ADDR_VAR 0 15
61995: PUSH
61996: LD_VAR 0 13
62000: PPUSH
62001: CALL_OW 254
62005: ST_TO_ADDR
// if r = 5 then
62006: LD_VAR 0 15
62010: PUSH
62011: LD_INT 5
62013: EQUAL
62014: IFFALSE 62024
// r := 0 ;
62016: LD_ADDR_VAR 0 15
62020: PUSH
62021: LD_INT 0
62023: ST_TO_ADDR
// for j = r to 5 do
62024: LD_ADDR_VAR 0 10
62028: PUSH
62029: DOUBLE
62030: LD_VAR 0 15
62034: DEC
62035: ST_TO_ADDR
62036: LD_INT 5
62038: PUSH
62039: FOR_TO
62040: IFFALSE 62154
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62042: LD_ADDR_VAR 0 11
62046: PUSH
62047: LD_VAR 0 13
62051: PPUSH
62052: CALL_OW 250
62056: PPUSH
62057: LD_VAR 0 10
62061: PPUSH
62062: LD_INT 2
62064: PPUSH
62065: CALL_OW 272
62069: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62070: LD_ADDR_VAR 0 12
62074: PUSH
62075: LD_VAR 0 13
62079: PPUSH
62080: CALL_OW 251
62084: PPUSH
62085: LD_VAR 0 10
62089: PPUSH
62090: LD_INT 2
62092: PPUSH
62093: CALL_OW 273
62097: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62098: LD_VAR 0 11
62102: PPUSH
62103: LD_VAR 0 12
62107: PPUSH
62108: CALL_OW 488
62112: PUSH
62113: LD_VAR 0 11
62117: PPUSH
62118: LD_VAR 0 12
62122: PPUSH
62123: CALL_OW 428
62127: NOT
62128: AND
62129: IFFALSE 62152
// begin ComMoveXY ( tmp , _x , _y ) ;
62131: LD_VAR 0 13
62135: PPUSH
62136: LD_VAR 0 11
62140: PPUSH
62141: LD_VAR 0 12
62145: PPUSH
62146: CALL_OW 111
// break ;
62150: GO 62154
// end ; end ;
62152: GO 62039
62154: POP
62155: POP
// end ; end ;
62156: GO 61481
62158: POP
62159: POP
// end ;
62160: LD_VAR 0 8
62164: RET
// export function BuildingTechInvented ( side , btype ) ; begin
62165: LD_INT 0
62167: PPUSH
// result := true ;
62168: LD_ADDR_VAR 0 3
62172: PUSH
62173: LD_INT 1
62175: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
62176: LD_VAR 0 2
62180: PUSH
62181: LD_INT 24
62183: DOUBLE
62184: EQUAL
62185: IFTRUE 62195
62187: LD_INT 33
62189: DOUBLE
62190: EQUAL
62191: IFTRUE 62195
62193: GO 62220
62195: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
62196: LD_ADDR_VAR 0 3
62200: PUSH
62201: LD_INT 32
62203: PPUSH
62204: LD_VAR 0 1
62208: PPUSH
62209: CALL_OW 321
62213: PUSH
62214: LD_INT 2
62216: EQUAL
62217: ST_TO_ADDR
62218: GO 62536
62220: LD_INT 20
62222: DOUBLE
62223: EQUAL
62224: IFTRUE 62228
62226: GO 62253
62228: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
62229: LD_ADDR_VAR 0 3
62233: PUSH
62234: LD_INT 6
62236: PPUSH
62237: LD_VAR 0 1
62241: PPUSH
62242: CALL_OW 321
62246: PUSH
62247: LD_INT 2
62249: EQUAL
62250: ST_TO_ADDR
62251: GO 62536
62253: LD_INT 22
62255: DOUBLE
62256: EQUAL
62257: IFTRUE 62267
62259: LD_INT 36
62261: DOUBLE
62262: EQUAL
62263: IFTRUE 62267
62265: GO 62292
62267: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
62268: LD_ADDR_VAR 0 3
62272: PUSH
62273: LD_INT 15
62275: PPUSH
62276: LD_VAR 0 1
62280: PPUSH
62281: CALL_OW 321
62285: PUSH
62286: LD_INT 2
62288: EQUAL
62289: ST_TO_ADDR
62290: GO 62536
62292: LD_INT 30
62294: DOUBLE
62295: EQUAL
62296: IFTRUE 62300
62298: GO 62325
62300: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62301: LD_ADDR_VAR 0 3
62305: PUSH
62306: LD_INT 20
62308: PPUSH
62309: LD_VAR 0 1
62313: PPUSH
62314: CALL_OW 321
62318: PUSH
62319: LD_INT 2
62321: EQUAL
62322: ST_TO_ADDR
62323: GO 62536
62325: LD_INT 28
62327: DOUBLE
62328: EQUAL
62329: IFTRUE 62339
62331: LD_INT 21
62333: DOUBLE
62334: EQUAL
62335: IFTRUE 62339
62337: GO 62364
62339: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62340: LD_ADDR_VAR 0 3
62344: PUSH
62345: LD_INT 21
62347: PPUSH
62348: LD_VAR 0 1
62352: PPUSH
62353: CALL_OW 321
62357: PUSH
62358: LD_INT 2
62360: EQUAL
62361: ST_TO_ADDR
62362: GO 62536
62364: LD_INT 16
62366: DOUBLE
62367: EQUAL
62368: IFTRUE 62372
62370: GO 62397
62372: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62373: LD_ADDR_VAR 0 3
62377: PUSH
62378: LD_INT 84
62380: PPUSH
62381: LD_VAR 0 1
62385: PPUSH
62386: CALL_OW 321
62390: PUSH
62391: LD_INT 2
62393: EQUAL
62394: ST_TO_ADDR
62395: GO 62536
62397: LD_INT 19
62399: DOUBLE
62400: EQUAL
62401: IFTRUE 62411
62403: LD_INT 23
62405: DOUBLE
62406: EQUAL
62407: IFTRUE 62411
62409: GO 62436
62411: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62412: LD_ADDR_VAR 0 3
62416: PUSH
62417: LD_INT 83
62419: PPUSH
62420: LD_VAR 0 1
62424: PPUSH
62425: CALL_OW 321
62429: PUSH
62430: LD_INT 2
62432: EQUAL
62433: ST_TO_ADDR
62434: GO 62536
62436: LD_INT 17
62438: DOUBLE
62439: EQUAL
62440: IFTRUE 62444
62442: GO 62469
62444: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62445: LD_ADDR_VAR 0 3
62449: PUSH
62450: LD_INT 39
62452: PPUSH
62453: LD_VAR 0 1
62457: PPUSH
62458: CALL_OW 321
62462: PUSH
62463: LD_INT 2
62465: EQUAL
62466: ST_TO_ADDR
62467: GO 62536
62469: LD_INT 18
62471: DOUBLE
62472: EQUAL
62473: IFTRUE 62477
62475: GO 62502
62477: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62478: LD_ADDR_VAR 0 3
62482: PUSH
62483: LD_INT 40
62485: PPUSH
62486: LD_VAR 0 1
62490: PPUSH
62491: CALL_OW 321
62495: PUSH
62496: LD_INT 2
62498: EQUAL
62499: ST_TO_ADDR
62500: GO 62536
62502: LD_INT 27
62504: DOUBLE
62505: EQUAL
62506: IFTRUE 62510
62508: GO 62535
62510: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62511: LD_ADDR_VAR 0 3
62515: PUSH
62516: LD_INT 35
62518: PPUSH
62519: LD_VAR 0 1
62523: PPUSH
62524: CALL_OW 321
62528: PUSH
62529: LD_INT 2
62531: EQUAL
62532: ST_TO_ADDR
62533: GO 62536
62535: POP
// end ;
62536: LD_VAR 0 3
62540: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62541: LD_INT 0
62543: PPUSH
62544: PPUSH
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
62551: PPUSH
62552: PPUSH
62553: PPUSH
// result := false ;
62554: LD_ADDR_VAR 0 6
62558: PUSH
62559: LD_INT 0
62561: ST_TO_ADDR
// if btype = b_depot then
62562: LD_VAR 0 2
62566: PUSH
62567: LD_INT 0
62569: EQUAL
62570: IFFALSE 62582
// begin result := true ;
62572: LD_ADDR_VAR 0 6
62576: PUSH
62577: LD_INT 1
62579: ST_TO_ADDR
// exit ;
62580: GO 63408
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62582: LD_VAR 0 1
62586: NOT
62587: PUSH
62588: LD_VAR 0 1
62592: PPUSH
62593: CALL_OW 266
62597: PUSH
62598: LD_INT 0
62600: PUSH
62601: LD_INT 1
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: IN
62608: NOT
62609: OR
62610: PUSH
62611: LD_VAR 0 2
62615: NOT
62616: OR
62617: PUSH
62618: LD_VAR 0 5
62622: PUSH
62623: LD_INT 0
62625: PUSH
62626: LD_INT 1
62628: PUSH
62629: LD_INT 2
62631: PUSH
62632: LD_INT 3
62634: PUSH
62635: LD_INT 4
62637: PUSH
62638: LD_INT 5
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: LIST
62645: LIST
62646: LIST
62647: LIST
62648: IN
62649: NOT
62650: OR
62651: PUSH
62652: LD_VAR 0 3
62656: PPUSH
62657: LD_VAR 0 4
62661: PPUSH
62662: CALL_OW 488
62666: NOT
62667: OR
62668: IFFALSE 62672
// exit ;
62670: GO 63408
// side := GetSide ( depot ) ;
62672: LD_ADDR_VAR 0 9
62676: PUSH
62677: LD_VAR 0 1
62681: PPUSH
62682: CALL_OW 255
62686: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62687: LD_VAR 0 9
62691: PPUSH
62692: LD_VAR 0 2
62696: PPUSH
62697: CALL 62165 0 2
62701: NOT
62702: IFFALSE 62706
// exit ;
62704: GO 63408
// pom := GetBase ( depot ) ;
62706: LD_ADDR_VAR 0 10
62710: PUSH
62711: LD_VAR 0 1
62715: PPUSH
62716: CALL_OW 274
62720: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62721: LD_ADDR_VAR 0 11
62725: PUSH
62726: LD_VAR 0 2
62730: PPUSH
62731: LD_VAR 0 1
62735: PPUSH
62736: CALL_OW 248
62740: PPUSH
62741: CALL_OW 450
62745: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62746: LD_VAR 0 10
62750: PPUSH
62751: LD_INT 1
62753: PPUSH
62754: CALL_OW 275
62758: PUSH
62759: LD_VAR 0 11
62763: PUSH
62764: LD_INT 1
62766: ARRAY
62767: GREATEREQUAL
62768: PUSH
62769: LD_VAR 0 10
62773: PPUSH
62774: LD_INT 2
62776: PPUSH
62777: CALL_OW 275
62781: PUSH
62782: LD_VAR 0 11
62786: PUSH
62787: LD_INT 2
62789: ARRAY
62790: GREATEREQUAL
62791: AND
62792: PUSH
62793: LD_VAR 0 10
62797: PPUSH
62798: LD_INT 3
62800: PPUSH
62801: CALL_OW 275
62805: PUSH
62806: LD_VAR 0 11
62810: PUSH
62811: LD_INT 3
62813: ARRAY
62814: GREATEREQUAL
62815: AND
62816: NOT
62817: IFFALSE 62821
// exit ;
62819: GO 63408
// if GetBType ( depot ) = b_depot then
62821: LD_VAR 0 1
62825: PPUSH
62826: CALL_OW 266
62830: PUSH
62831: LD_INT 0
62833: EQUAL
62834: IFFALSE 62846
// dist := 28 else
62836: LD_ADDR_VAR 0 14
62840: PUSH
62841: LD_INT 28
62843: ST_TO_ADDR
62844: GO 62854
// dist := 36 ;
62846: LD_ADDR_VAR 0 14
62850: PUSH
62851: LD_INT 36
62853: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62854: LD_VAR 0 1
62858: PPUSH
62859: LD_VAR 0 3
62863: PPUSH
62864: LD_VAR 0 4
62868: PPUSH
62869: CALL_OW 297
62873: PUSH
62874: LD_VAR 0 14
62878: GREATER
62879: IFFALSE 62883
// exit ;
62881: GO 63408
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62883: LD_ADDR_VAR 0 12
62887: PUSH
62888: LD_VAR 0 2
62892: PPUSH
62893: LD_VAR 0 3
62897: PPUSH
62898: LD_VAR 0 4
62902: PPUSH
62903: LD_VAR 0 5
62907: PPUSH
62908: LD_VAR 0 1
62912: PPUSH
62913: CALL_OW 248
62917: PPUSH
62918: LD_INT 0
62920: PPUSH
62921: CALL 63413 0 6
62925: ST_TO_ADDR
// if not hexes then
62926: LD_VAR 0 12
62930: NOT
62931: IFFALSE 62935
// exit ;
62933: GO 63408
// hex := GetHexInfo ( x , y ) ;
62935: LD_ADDR_VAR 0 15
62939: PUSH
62940: LD_VAR 0 3
62944: PPUSH
62945: LD_VAR 0 4
62949: PPUSH
62950: CALL_OW 546
62954: ST_TO_ADDR
// if hex [ 1 ] then
62955: LD_VAR 0 15
62959: PUSH
62960: LD_INT 1
62962: ARRAY
62963: IFFALSE 62967
// exit ;
62965: GO 63408
// height := hex [ 2 ] ;
62967: LD_ADDR_VAR 0 13
62971: PUSH
62972: LD_VAR 0 15
62976: PUSH
62977: LD_INT 2
62979: ARRAY
62980: ST_TO_ADDR
// for i = 1 to hexes do
62981: LD_ADDR_VAR 0 7
62985: PUSH
62986: DOUBLE
62987: LD_INT 1
62989: DEC
62990: ST_TO_ADDR
62991: LD_VAR 0 12
62995: PUSH
62996: FOR_TO
62997: IFFALSE 63327
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62999: LD_VAR 0 12
63003: PUSH
63004: LD_VAR 0 7
63008: ARRAY
63009: PUSH
63010: LD_INT 1
63012: ARRAY
63013: PPUSH
63014: LD_VAR 0 12
63018: PUSH
63019: LD_VAR 0 7
63023: ARRAY
63024: PUSH
63025: LD_INT 2
63027: ARRAY
63028: PPUSH
63029: CALL_OW 488
63033: NOT
63034: PUSH
63035: LD_VAR 0 12
63039: PUSH
63040: LD_VAR 0 7
63044: ARRAY
63045: PUSH
63046: LD_INT 1
63048: ARRAY
63049: PPUSH
63050: LD_VAR 0 12
63054: PUSH
63055: LD_VAR 0 7
63059: ARRAY
63060: PUSH
63061: LD_INT 2
63063: ARRAY
63064: PPUSH
63065: CALL_OW 428
63069: PUSH
63070: LD_INT 0
63072: GREATER
63073: OR
63074: PUSH
63075: LD_VAR 0 12
63079: PUSH
63080: LD_VAR 0 7
63084: ARRAY
63085: PUSH
63086: LD_INT 1
63088: ARRAY
63089: PPUSH
63090: LD_VAR 0 12
63094: PUSH
63095: LD_VAR 0 7
63099: ARRAY
63100: PUSH
63101: LD_INT 2
63103: ARRAY
63104: PPUSH
63105: CALL_OW 351
63109: OR
63110: IFFALSE 63116
// exit ;
63112: POP
63113: POP
63114: GO 63408
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63116: LD_ADDR_VAR 0 8
63120: PUSH
63121: LD_VAR 0 12
63125: PUSH
63126: LD_VAR 0 7
63130: ARRAY
63131: PUSH
63132: LD_INT 1
63134: ARRAY
63135: PPUSH
63136: LD_VAR 0 12
63140: PUSH
63141: LD_VAR 0 7
63145: ARRAY
63146: PUSH
63147: LD_INT 2
63149: ARRAY
63150: PPUSH
63151: CALL_OW 546
63155: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63156: LD_VAR 0 8
63160: PUSH
63161: LD_INT 1
63163: ARRAY
63164: PUSH
63165: LD_VAR 0 8
63169: PUSH
63170: LD_INT 2
63172: ARRAY
63173: PUSH
63174: LD_VAR 0 13
63178: PUSH
63179: LD_INT 2
63181: PLUS
63182: GREATER
63183: OR
63184: PUSH
63185: LD_VAR 0 8
63189: PUSH
63190: LD_INT 2
63192: ARRAY
63193: PUSH
63194: LD_VAR 0 13
63198: PUSH
63199: LD_INT 2
63201: MINUS
63202: LESS
63203: OR
63204: PUSH
63205: LD_VAR 0 8
63209: PUSH
63210: LD_INT 3
63212: ARRAY
63213: PUSH
63214: LD_INT 0
63216: PUSH
63217: LD_INT 8
63219: PUSH
63220: LD_INT 9
63222: PUSH
63223: LD_INT 10
63225: PUSH
63226: LD_INT 11
63228: PUSH
63229: LD_INT 12
63231: PUSH
63232: LD_INT 13
63234: PUSH
63235: LD_INT 16
63237: PUSH
63238: LD_INT 17
63240: PUSH
63241: LD_INT 18
63243: PUSH
63244: LD_INT 19
63246: PUSH
63247: LD_INT 20
63249: PUSH
63250: LD_INT 21
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: IN
63268: NOT
63269: OR
63270: PUSH
63271: LD_VAR 0 8
63275: PUSH
63276: LD_INT 5
63278: ARRAY
63279: NOT
63280: OR
63281: PUSH
63282: LD_VAR 0 8
63286: PUSH
63287: LD_INT 6
63289: ARRAY
63290: PUSH
63291: LD_INT 1
63293: PUSH
63294: LD_INT 2
63296: PUSH
63297: LD_INT 7
63299: PUSH
63300: LD_INT 9
63302: PUSH
63303: LD_INT 10
63305: PUSH
63306: LD_INT 11
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: LIST
63313: LIST
63314: LIST
63315: LIST
63316: IN
63317: NOT
63318: OR
63319: IFFALSE 63325
// exit ;
63321: POP
63322: POP
63323: GO 63408
// end ;
63325: GO 62996
63327: POP
63328: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63329: LD_VAR 0 9
63333: PPUSH
63334: LD_VAR 0 3
63338: PPUSH
63339: LD_VAR 0 4
63343: PPUSH
63344: LD_INT 20
63346: PPUSH
63347: CALL 55331 0 4
63351: PUSH
63352: LD_INT 4
63354: ARRAY
63355: IFFALSE 63359
// exit ;
63357: GO 63408
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63359: LD_VAR 0 2
63363: PUSH
63364: LD_INT 29
63366: PUSH
63367: LD_INT 30
63369: PUSH
63370: EMPTY
63371: LIST
63372: LIST
63373: IN
63374: PUSH
63375: LD_VAR 0 3
63379: PPUSH
63380: LD_VAR 0 4
63384: PPUSH
63385: LD_VAR 0 9
63389: PPUSH
63390: CALL_OW 440
63394: NOT
63395: AND
63396: IFFALSE 63400
// exit ;
63398: GO 63408
// result := true ;
63400: LD_ADDR_VAR 0 6
63404: PUSH
63405: LD_INT 1
63407: ST_TO_ADDR
// end ;
63408: LD_VAR 0 6
63412: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63413: LD_INT 0
63415: PPUSH
63416: PPUSH
63417: PPUSH
63418: PPUSH
63419: PPUSH
63420: PPUSH
63421: PPUSH
63422: PPUSH
63423: PPUSH
63424: PPUSH
63425: PPUSH
63426: PPUSH
63427: PPUSH
63428: PPUSH
63429: PPUSH
63430: PPUSH
63431: PPUSH
63432: PPUSH
63433: PPUSH
63434: PPUSH
63435: PPUSH
63436: PPUSH
63437: PPUSH
63438: PPUSH
63439: PPUSH
63440: PPUSH
63441: PPUSH
63442: PPUSH
63443: PPUSH
63444: PPUSH
63445: PPUSH
63446: PPUSH
63447: PPUSH
63448: PPUSH
63449: PPUSH
63450: PPUSH
63451: PPUSH
63452: PPUSH
63453: PPUSH
63454: PPUSH
63455: PPUSH
63456: PPUSH
63457: PPUSH
63458: PPUSH
63459: PPUSH
63460: PPUSH
63461: PPUSH
63462: PPUSH
63463: PPUSH
63464: PPUSH
63465: PPUSH
63466: PPUSH
63467: PPUSH
63468: PPUSH
63469: PPUSH
63470: PPUSH
63471: PPUSH
63472: PPUSH
// result = [ ] ;
63473: LD_ADDR_VAR 0 7
63477: PUSH
63478: EMPTY
63479: ST_TO_ADDR
// temp_list = [ ] ;
63480: LD_ADDR_VAR 0 9
63484: PUSH
63485: EMPTY
63486: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63487: LD_VAR 0 4
63491: PUSH
63492: LD_INT 0
63494: PUSH
63495: LD_INT 1
63497: PUSH
63498: LD_INT 2
63500: PUSH
63501: LD_INT 3
63503: PUSH
63504: LD_INT 4
63506: PUSH
63507: LD_INT 5
63509: PUSH
63510: EMPTY
63511: LIST
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: IN
63518: NOT
63519: PUSH
63520: LD_VAR 0 1
63524: PUSH
63525: LD_INT 0
63527: PUSH
63528: LD_INT 1
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: IN
63535: PUSH
63536: LD_VAR 0 5
63540: PUSH
63541: LD_INT 1
63543: PUSH
63544: LD_INT 2
63546: PUSH
63547: LD_INT 3
63549: PUSH
63550: EMPTY
63551: LIST
63552: LIST
63553: LIST
63554: IN
63555: NOT
63556: AND
63557: OR
63558: IFFALSE 63562
// exit ;
63560: GO 81953
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63562: LD_VAR 0 1
63566: PUSH
63567: LD_INT 6
63569: PUSH
63570: LD_INT 7
63572: PUSH
63573: LD_INT 8
63575: PUSH
63576: LD_INT 13
63578: PUSH
63579: LD_INT 12
63581: PUSH
63582: LD_INT 15
63584: PUSH
63585: LD_INT 11
63587: PUSH
63588: LD_INT 14
63590: PUSH
63591: LD_INT 10
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: LIST
63598: LIST
63599: LIST
63600: LIST
63601: LIST
63602: LIST
63603: LIST
63604: IN
63605: IFFALSE 63615
// btype = b_lab ;
63607: LD_ADDR_VAR 0 1
63611: PUSH
63612: LD_INT 6
63614: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63615: LD_VAR 0 6
63619: PUSH
63620: LD_INT 0
63622: PUSH
63623: LD_INT 1
63625: PUSH
63626: LD_INT 2
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: LIST
63633: IN
63634: NOT
63635: PUSH
63636: LD_VAR 0 1
63640: PUSH
63641: LD_INT 0
63643: PUSH
63644: LD_INT 1
63646: PUSH
63647: LD_INT 2
63649: PUSH
63650: LD_INT 3
63652: PUSH
63653: LD_INT 6
63655: PUSH
63656: LD_INT 36
63658: PUSH
63659: LD_INT 4
63661: PUSH
63662: LD_INT 5
63664: PUSH
63665: LD_INT 31
63667: PUSH
63668: LD_INT 32
63670: PUSH
63671: LD_INT 33
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: LIST
63683: LIST
63684: LIST
63685: LIST
63686: IN
63687: NOT
63688: PUSH
63689: LD_VAR 0 6
63693: PUSH
63694: LD_INT 1
63696: EQUAL
63697: AND
63698: OR
63699: PUSH
63700: LD_VAR 0 1
63704: PUSH
63705: LD_INT 2
63707: PUSH
63708: LD_INT 3
63710: PUSH
63711: EMPTY
63712: LIST
63713: LIST
63714: IN
63715: NOT
63716: PUSH
63717: LD_VAR 0 6
63721: PUSH
63722: LD_INT 2
63724: EQUAL
63725: AND
63726: OR
63727: IFFALSE 63737
// mode = 0 ;
63729: LD_ADDR_VAR 0 6
63733: PUSH
63734: LD_INT 0
63736: ST_TO_ADDR
// case mode of 0 :
63737: LD_VAR 0 6
63741: PUSH
63742: LD_INT 0
63744: DOUBLE
63745: EQUAL
63746: IFTRUE 63750
63748: GO 75203
63750: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63751: LD_ADDR_VAR 0 11
63755: PUSH
63756: LD_INT 0
63758: PUSH
63759: LD_INT 0
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 0
63768: PUSH
63769: LD_INT 1
63771: NEG
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: LD_INT 1
63779: PUSH
63780: LD_INT 0
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 1
63789: PUSH
63790: LD_INT 1
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 0
63799: PUSH
63800: LD_INT 1
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PUSH
63807: LD_INT 1
63809: NEG
63810: PUSH
63811: LD_INT 0
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 1
63820: NEG
63821: PUSH
63822: LD_INT 1
63824: NEG
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PUSH
63830: LD_INT 1
63832: NEG
63833: PUSH
63834: LD_INT 2
63836: NEG
63837: PUSH
63838: EMPTY
63839: LIST
63840: LIST
63841: PUSH
63842: LD_INT 0
63844: PUSH
63845: LD_INT 2
63847: NEG
63848: PUSH
63849: EMPTY
63850: LIST
63851: LIST
63852: PUSH
63853: LD_INT 1
63855: PUSH
63856: LD_INT 1
63858: NEG
63859: PUSH
63860: EMPTY
63861: LIST
63862: LIST
63863: PUSH
63864: LD_INT 1
63866: PUSH
63867: LD_INT 2
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: LD_INT 2
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: LD_INT 1
63886: NEG
63887: PUSH
63888: LD_INT 1
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: LD_INT 1
63897: PUSH
63898: LD_INT 3
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 0
63907: PUSH
63908: LD_INT 3
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PUSH
63915: LD_INT 1
63917: NEG
63918: PUSH
63919: LD_INT 2
63921: PUSH
63922: EMPTY
63923: LIST
63924: LIST
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63944: LD_ADDR_VAR 0 12
63948: PUSH
63949: LD_INT 0
63951: PUSH
63952: LD_INT 0
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: PUSH
63959: LD_INT 0
63961: PUSH
63962: LD_INT 1
63964: NEG
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 1
63972: PUSH
63973: LD_INT 0
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: PUSH
63980: LD_INT 1
63982: PUSH
63983: LD_INT 1
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: PUSH
63990: LD_INT 0
63992: PUSH
63993: LD_INT 1
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: LD_INT 1
64002: NEG
64003: PUSH
64004: LD_INT 0
64006: PUSH
64007: EMPTY
64008: LIST
64009: LIST
64010: PUSH
64011: LD_INT 1
64013: NEG
64014: PUSH
64015: LD_INT 1
64017: NEG
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 1
64025: PUSH
64026: LD_INT 1
64028: NEG
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 2
64036: PUSH
64037: LD_INT 0
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: PUSH
64044: LD_INT 2
64046: PUSH
64047: LD_INT 1
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: LD_INT 1
64056: NEG
64057: PUSH
64058: LD_INT 1
64060: PUSH
64061: EMPTY
64062: LIST
64063: LIST
64064: PUSH
64065: LD_INT 2
64067: NEG
64068: PUSH
64069: LD_INT 0
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PUSH
64076: LD_INT 2
64078: NEG
64079: PUSH
64080: LD_INT 1
64082: NEG
64083: PUSH
64084: EMPTY
64085: LIST
64086: LIST
64087: PUSH
64088: LD_INT 2
64090: NEG
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 3
64101: NEG
64102: PUSH
64103: LD_INT 0
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PUSH
64110: LD_INT 3
64112: NEG
64113: PUSH
64114: LD_INT 1
64116: NEG
64117: PUSH
64118: EMPTY
64119: LIST
64120: LIST
64121: PUSH
64122: EMPTY
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64140: LD_ADDR_VAR 0 13
64144: PUSH
64145: LD_INT 0
64147: PUSH
64148: LD_INT 0
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: LD_INT 0
64157: PUSH
64158: LD_INT 1
64160: NEG
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 1
64168: PUSH
64169: LD_INT 0
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: PUSH
64176: LD_INT 1
64178: PUSH
64179: LD_INT 1
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 0
64188: PUSH
64189: LD_INT 1
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 1
64198: NEG
64199: PUSH
64200: LD_INT 0
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: PUSH
64207: LD_INT 1
64209: NEG
64210: PUSH
64211: LD_INT 1
64213: NEG
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: PUSH
64219: LD_INT 1
64221: NEG
64222: PUSH
64223: LD_INT 2
64225: NEG
64226: PUSH
64227: EMPTY
64228: LIST
64229: LIST
64230: PUSH
64231: LD_INT 2
64233: PUSH
64234: LD_INT 1
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: PUSH
64241: LD_INT 2
64243: PUSH
64244: LD_INT 2
64246: PUSH
64247: EMPTY
64248: LIST
64249: LIST
64250: PUSH
64251: LD_INT 1
64253: PUSH
64254: LD_INT 2
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 2
64263: NEG
64264: PUSH
64265: LD_INT 1
64267: NEG
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: LD_INT 2
64275: NEG
64276: PUSH
64277: LD_INT 2
64279: NEG
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 2
64287: NEG
64288: PUSH
64289: LD_INT 3
64291: NEG
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 3
64299: NEG
64300: PUSH
64301: LD_INT 2
64303: NEG
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 3
64311: NEG
64312: PUSH
64313: LD_INT 3
64315: NEG
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: LIST
64335: LIST
64336: LIST
64337: LIST
64338: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64339: LD_ADDR_VAR 0 14
64343: PUSH
64344: LD_INT 0
64346: PUSH
64347: LD_INT 0
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: PUSH
64354: LD_INT 0
64356: PUSH
64357: LD_INT 1
64359: NEG
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 1
64367: PUSH
64368: LD_INT 0
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 1
64377: PUSH
64378: LD_INT 1
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: LD_INT 0
64387: PUSH
64388: LD_INT 1
64390: PUSH
64391: EMPTY
64392: LIST
64393: LIST
64394: PUSH
64395: LD_INT 1
64397: NEG
64398: PUSH
64399: LD_INT 0
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PUSH
64406: LD_INT 1
64408: NEG
64409: PUSH
64410: LD_INT 1
64412: NEG
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 1
64420: NEG
64421: PUSH
64422: LD_INT 2
64424: NEG
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 0
64432: PUSH
64433: LD_INT 2
64435: NEG
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 1
64443: PUSH
64444: LD_INT 1
64446: NEG
64447: PUSH
64448: EMPTY
64449: LIST
64450: LIST
64451: PUSH
64452: LD_INT 1
64454: PUSH
64455: LD_INT 2
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 0
64464: PUSH
64465: LD_INT 2
64467: PUSH
64468: EMPTY
64469: LIST
64470: LIST
64471: PUSH
64472: LD_INT 1
64474: NEG
64475: PUSH
64476: LD_INT 1
64478: PUSH
64479: EMPTY
64480: LIST
64481: LIST
64482: PUSH
64483: LD_INT 1
64485: NEG
64486: PUSH
64487: LD_INT 3
64489: NEG
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 0
64497: PUSH
64498: LD_INT 3
64500: NEG
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PUSH
64506: LD_INT 1
64508: PUSH
64509: LD_INT 2
64511: NEG
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: EMPTY
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64535: LD_ADDR_VAR 0 15
64539: PUSH
64540: LD_INT 0
64542: PUSH
64543: LD_INT 0
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 0
64552: PUSH
64553: LD_INT 1
64555: NEG
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 1
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 1
64573: PUSH
64574: LD_INT 1
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 0
64583: PUSH
64584: LD_INT 1
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: PUSH
64591: LD_INT 1
64593: NEG
64594: PUSH
64595: LD_INT 0
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: PUSH
64602: LD_INT 1
64604: NEG
64605: PUSH
64606: LD_INT 1
64608: NEG
64609: PUSH
64610: EMPTY
64611: LIST
64612: LIST
64613: PUSH
64614: LD_INT 1
64616: PUSH
64617: LD_INT 1
64619: NEG
64620: PUSH
64621: EMPTY
64622: LIST
64623: LIST
64624: PUSH
64625: LD_INT 2
64627: PUSH
64628: LD_INT 0
64630: PUSH
64631: EMPTY
64632: LIST
64633: LIST
64634: PUSH
64635: LD_INT 2
64637: PUSH
64638: LD_INT 1
64640: PUSH
64641: EMPTY
64642: LIST
64643: LIST
64644: PUSH
64645: LD_INT 1
64647: NEG
64648: PUSH
64649: LD_INT 1
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: LD_INT 2
64658: NEG
64659: PUSH
64660: LD_INT 0
64662: PUSH
64663: EMPTY
64664: LIST
64665: LIST
64666: PUSH
64667: LD_INT 2
64669: NEG
64670: PUSH
64671: LD_INT 1
64673: NEG
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: PUSH
64679: LD_INT 2
64681: PUSH
64682: LD_INT 1
64684: NEG
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 3
64692: PUSH
64693: LD_INT 0
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 3
64702: PUSH
64703: LD_INT 1
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: LIST
64725: LIST
64726: LIST
64727: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64728: LD_ADDR_VAR 0 16
64732: PUSH
64733: LD_INT 0
64735: PUSH
64736: LD_INT 0
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 0
64745: PUSH
64746: LD_INT 1
64748: NEG
64749: PUSH
64750: EMPTY
64751: LIST
64752: LIST
64753: PUSH
64754: LD_INT 1
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 1
64766: PUSH
64767: LD_INT 1
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: LD_INT 0
64776: PUSH
64777: LD_INT 1
64779: PUSH
64780: EMPTY
64781: LIST
64782: LIST
64783: PUSH
64784: LD_INT 1
64786: NEG
64787: PUSH
64788: LD_INT 0
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PUSH
64795: LD_INT 1
64797: NEG
64798: PUSH
64799: LD_INT 1
64801: NEG
64802: PUSH
64803: EMPTY
64804: LIST
64805: LIST
64806: PUSH
64807: LD_INT 1
64809: NEG
64810: PUSH
64811: LD_INT 2
64813: NEG
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 2
64821: PUSH
64822: LD_INT 1
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 2
64831: PUSH
64832: LD_INT 2
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 1
64841: PUSH
64842: LD_INT 2
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 2
64851: NEG
64852: PUSH
64853: LD_INT 1
64855: NEG
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 2
64863: NEG
64864: PUSH
64865: LD_INT 2
64867: NEG
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: PUSH
64873: LD_INT 3
64875: PUSH
64876: LD_INT 2
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: LD_INT 3
64885: PUSH
64886: LD_INT 3
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PUSH
64893: LD_INT 2
64895: PUSH
64896: LD_INT 3
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64921: LD_ADDR_VAR 0 17
64925: PUSH
64926: LD_INT 0
64928: PUSH
64929: LD_INT 0
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 0
64938: PUSH
64939: LD_INT 1
64941: NEG
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: LD_INT 1
64949: PUSH
64950: LD_INT 0
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 1
64959: PUSH
64960: LD_INT 1
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 0
64969: PUSH
64970: LD_INT 1
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: LD_INT 1
64979: NEG
64980: PUSH
64981: LD_INT 0
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: LD_INT 1
64990: NEG
64991: PUSH
64992: LD_INT 1
64994: NEG
64995: PUSH
64996: EMPTY
64997: LIST
64998: LIST
64999: PUSH
65000: LD_INT 1
65002: NEG
65003: PUSH
65004: LD_INT 2
65006: NEG
65007: PUSH
65008: EMPTY
65009: LIST
65010: LIST
65011: PUSH
65012: LD_INT 0
65014: PUSH
65015: LD_INT 2
65017: NEG
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: LD_INT 1
65025: PUSH
65026: LD_INT 1
65028: NEG
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: LD_INT 2
65036: PUSH
65037: LD_INT 0
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: PUSH
65044: LD_INT 2
65046: PUSH
65047: LD_INT 1
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: LD_INT 2
65056: PUSH
65057: LD_INT 2
65059: PUSH
65060: EMPTY
65061: LIST
65062: LIST
65063: PUSH
65064: LD_INT 1
65066: PUSH
65067: LD_INT 2
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: LD_INT 0
65076: PUSH
65077: LD_INT 2
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: PUSH
65084: LD_INT 1
65086: NEG
65087: PUSH
65088: LD_INT 1
65090: PUSH
65091: EMPTY
65092: LIST
65093: LIST
65094: PUSH
65095: LD_INT 2
65097: NEG
65098: PUSH
65099: LD_INT 0
65101: PUSH
65102: EMPTY
65103: LIST
65104: LIST
65105: PUSH
65106: LD_INT 2
65108: NEG
65109: PUSH
65110: LD_INT 1
65112: NEG
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 2
65120: NEG
65121: PUSH
65122: LD_INT 2
65124: NEG
65125: PUSH
65126: EMPTY
65127: LIST
65128: LIST
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65151: LD_ADDR_VAR 0 18
65155: PUSH
65156: LD_INT 0
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 0
65168: PUSH
65169: LD_INT 1
65171: NEG
65172: PUSH
65173: EMPTY
65174: LIST
65175: LIST
65176: PUSH
65177: LD_INT 1
65179: PUSH
65180: LD_INT 0
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 1
65189: PUSH
65190: LD_INT 1
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 0
65199: PUSH
65200: LD_INT 1
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: LD_INT 1
65209: NEG
65210: PUSH
65211: LD_INT 0
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 1
65220: NEG
65221: PUSH
65222: LD_INT 1
65224: NEG
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 1
65232: NEG
65233: PUSH
65234: LD_INT 2
65236: NEG
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: PUSH
65242: LD_INT 0
65244: PUSH
65245: LD_INT 2
65247: NEG
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 1
65255: PUSH
65256: LD_INT 1
65258: NEG
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 2
65266: PUSH
65267: LD_INT 0
65269: PUSH
65270: EMPTY
65271: LIST
65272: LIST
65273: PUSH
65274: LD_INT 2
65276: PUSH
65277: LD_INT 1
65279: PUSH
65280: EMPTY
65281: LIST
65282: LIST
65283: PUSH
65284: LD_INT 2
65286: PUSH
65287: LD_INT 2
65289: PUSH
65290: EMPTY
65291: LIST
65292: LIST
65293: PUSH
65294: LD_INT 1
65296: PUSH
65297: LD_INT 2
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 0
65306: PUSH
65307: LD_INT 2
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 1
65316: NEG
65317: PUSH
65318: LD_INT 1
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: PUSH
65325: LD_INT 2
65327: NEG
65328: PUSH
65329: LD_INT 0
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PUSH
65336: LD_INT 2
65338: NEG
65339: PUSH
65340: LD_INT 1
65342: NEG
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 2
65350: NEG
65351: PUSH
65352: LD_INT 2
65354: NEG
65355: PUSH
65356: EMPTY
65357: LIST
65358: LIST
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65381: LD_ADDR_VAR 0 19
65385: PUSH
65386: LD_INT 0
65388: PUSH
65389: LD_INT 0
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 0
65398: PUSH
65399: LD_INT 1
65401: NEG
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 1
65409: PUSH
65410: LD_INT 0
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 1
65419: PUSH
65420: LD_INT 1
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 0
65429: PUSH
65430: LD_INT 1
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 1
65439: NEG
65440: PUSH
65441: LD_INT 0
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: NEG
65451: PUSH
65452: LD_INT 1
65454: NEG
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PUSH
65460: LD_INT 1
65462: NEG
65463: PUSH
65464: LD_INT 2
65466: NEG
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PUSH
65472: LD_INT 0
65474: PUSH
65475: LD_INT 2
65477: NEG
65478: PUSH
65479: EMPTY
65480: LIST
65481: LIST
65482: PUSH
65483: LD_INT 1
65485: PUSH
65486: LD_INT 1
65488: NEG
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 2
65496: PUSH
65497: LD_INT 0
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 2
65506: PUSH
65507: LD_INT 1
65509: PUSH
65510: EMPTY
65511: LIST
65512: LIST
65513: PUSH
65514: LD_INT 2
65516: PUSH
65517: LD_INT 2
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: LD_INT 1
65526: PUSH
65527: LD_INT 2
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PUSH
65534: LD_INT 0
65536: PUSH
65537: LD_INT 2
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 1
65546: NEG
65547: PUSH
65548: LD_INT 1
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PUSH
65555: LD_INT 2
65557: NEG
65558: PUSH
65559: LD_INT 0
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PUSH
65566: LD_INT 2
65568: NEG
65569: PUSH
65570: LD_INT 1
65572: NEG
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 2
65580: NEG
65581: PUSH
65582: LD_INT 2
65584: NEG
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65611: LD_ADDR_VAR 0 20
65615: PUSH
65616: LD_INT 0
65618: PUSH
65619: LD_INT 0
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: LD_INT 0
65628: PUSH
65629: LD_INT 1
65631: NEG
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: PUSH
65637: LD_INT 1
65639: PUSH
65640: LD_INT 0
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_INT 1
65649: PUSH
65650: LD_INT 1
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 0
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PUSH
65667: LD_INT 1
65669: NEG
65670: PUSH
65671: LD_INT 0
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: PUSH
65678: LD_INT 1
65680: NEG
65681: PUSH
65682: LD_INT 1
65684: NEG
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 1
65692: NEG
65693: PUSH
65694: LD_INT 2
65696: NEG
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 0
65704: PUSH
65705: LD_INT 2
65707: NEG
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: LD_INT 1
65715: PUSH
65716: LD_INT 1
65718: NEG
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 2
65726: PUSH
65727: LD_INT 0
65729: PUSH
65730: EMPTY
65731: LIST
65732: LIST
65733: PUSH
65734: LD_INT 2
65736: PUSH
65737: LD_INT 1
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: PUSH
65744: LD_INT 2
65746: PUSH
65747: LD_INT 2
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 1
65756: PUSH
65757: LD_INT 2
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 0
65766: PUSH
65767: LD_INT 2
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PUSH
65774: LD_INT 1
65776: NEG
65777: PUSH
65778: LD_INT 1
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PUSH
65785: LD_INT 2
65787: NEG
65788: PUSH
65789: LD_INT 0
65791: PUSH
65792: EMPTY
65793: LIST
65794: LIST
65795: PUSH
65796: LD_INT 2
65798: NEG
65799: PUSH
65800: LD_INT 1
65802: NEG
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PUSH
65808: LD_INT 2
65810: NEG
65811: PUSH
65812: LD_INT 2
65814: NEG
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: PUSH
65820: EMPTY
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65841: LD_ADDR_VAR 0 21
65845: PUSH
65846: LD_INT 0
65848: PUSH
65849: LD_INT 0
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: LD_INT 1
65861: NEG
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: LD_INT 1
65869: PUSH
65870: LD_INT 0
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 1
65879: PUSH
65880: LD_INT 1
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 0
65889: PUSH
65890: LD_INT 1
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 1
65899: NEG
65900: PUSH
65901: LD_INT 0
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 1
65910: NEG
65911: PUSH
65912: LD_INT 1
65914: NEG
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: LD_INT 1
65922: NEG
65923: PUSH
65924: LD_INT 2
65926: NEG
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 0
65934: PUSH
65935: LD_INT 2
65937: NEG
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: PUSH
65943: LD_INT 1
65945: PUSH
65946: LD_INT 1
65948: NEG
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 2
65956: PUSH
65957: LD_INT 0
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 2
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 2
65976: PUSH
65977: LD_INT 2
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 1
65986: PUSH
65987: LD_INT 2
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 0
65996: PUSH
65997: LD_INT 2
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: LD_INT 1
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 2
66017: NEG
66018: PUSH
66019: LD_INT 0
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 2
66028: NEG
66029: PUSH
66030: LD_INT 1
66032: NEG
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 2
66040: NEG
66041: PUSH
66042: LD_INT 2
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66071: LD_ADDR_VAR 0 22
66075: PUSH
66076: LD_INT 0
66078: PUSH
66079: LD_INT 0
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: LD_INT 1
66091: NEG
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 1
66099: PUSH
66100: LD_INT 0
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: LD_INT 1
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 0
66119: PUSH
66120: LD_INT 1
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: NEG
66130: PUSH
66131: LD_INT 0
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 1
66140: NEG
66141: PUSH
66142: LD_INT 1
66144: NEG
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: PUSH
66150: LD_INT 1
66152: NEG
66153: PUSH
66154: LD_INT 2
66156: NEG
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 0
66164: PUSH
66165: LD_INT 2
66167: NEG
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PUSH
66173: LD_INT 1
66175: PUSH
66176: LD_INT 1
66178: NEG
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 2
66186: PUSH
66187: LD_INT 0
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 2
66196: PUSH
66197: LD_INT 1
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 2
66206: PUSH
66207: LD_INT 2
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 1
66216: PUSH
66217: LD_INT 2
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 0
66226: PUSH
66227: LD_INT 2
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: LD_INT 1
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 2
66247: NEG
66248: PUSH
66249: LD_INT 0
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: LD_INT 2
66258: NEG
66259: PUSH
66260: LD_INT 1
66262: NEG
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: PUSH
66268: LD_INT 2
66270: NEG
66271: PUSH
66272: LD_INT 2
66274: NEG
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66301: LD_ADDR_VAR 0 23
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: LD_INT 0
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 0
66318: PUSH
66319: LD_INT 1
66321: NEG
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 1
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 1
66339: PUSH
66340: LD_INT 1
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 0
66349: PUSH
66350: LD_INT 1
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 1
66359: NEG
66360: PUSH
66361: LD_INT 0
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: PUSH
66368: LD_INT 1
66370: NEG
66371: PUSH
66372: LD_INT 1
66374: NEG
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: LD_INT 1
66382: NEG
66383: PUSH
66384: LD_INT 2
66386: NEG
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 0
66394: PUSH
66395: LD_INT 2
66397: NEG
66398: PUSH
66399: EMPTY
66400: LIST
66401: LIST
66402: PUSH
66403: LD_INT 1
66405: PUSH
66406: LD_INT 1
66408: NEG
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PUSH
66414: LD_INT 2
66416: PUSH
66417: LD_INT 0
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 2
66426: PUSH
66427: LD_INT 1
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 2
66436: PUSH
66437: LD_INT 2
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 1
66446: PUSH
66447: LD_INT 2
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 0
66456: PUSH
66457: LD_INT 2
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 1
66466: NEG
66467: PUSH
66468: LD_INT 1
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 2
66477: NEG
66478: PUSH
66479: LD_INT 0
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: LD_INT 2
66488: NEG
66489: PUSH
66490: LD_INT 1
66492: NEG
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 2
66500: NEG
66501: PUSH
66502: LD_INT 2
66504: NEG
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 2
66512: NEG
66513: PUSH
66514: LD_INT 3
66516: NEG
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: NEG
66525: PUSH
66526: LD_INT 3
66528: NEG
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: PUSH
66537: LD_INT 2
66539: NEG
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 2
66547: PUSH
66548: LD_INT 1
66550: NEG
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: LIST
66572: LIST
66573: LIST
66574: LIST
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: LIST
66580: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66581: LD_ADDR_VAR 0 24
66585: PUSH
66586: LD_INT 0
66588: PUSH
66589: LD_INT 0
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: PUSH
66596: LD_INT 0
66598: PUSH
66599: LD_INT 1
66601: NEG
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: LD_INT 0
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 1
66619: PUSH
66620: LD_INT 1
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 0
66629: PUSH
66630: LD_INT 1
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 1
66639: NEG
66640: PUSH
66641: LD_INT 0
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: LD_INT 1
66650: NEG
66651: PUSH
66652: LD_INT 1
66654: NEG
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PUSH
66660: LD_INT 1
66662: NEG
66663: PUSH
66664: LD_INT 2
66666: NEG
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: PUSH
66672: LD_INT 0
66674: PUSH
66675: LD_INT 2
66677: NEG
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 1
66685: PUSH
66686: LD_INT 1
66688: NEG
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 2
66696: PUSH
66697: LD_INT 0
66699: PUSH
66700: EMPTY
66701: LIST
66702: LIST
66703: PUSH
66704: LD_INT 2
66706: PUSH
66707: LD_INT 1
66709: PUSH
66710: EMPTY
66711: LIST
66712: LIST
66713: PUSH
66714: LD_INT 2
66716: PUSH
66717: LD_INT 2
66719: PUSH
66720: EMPTY
66721: LIST
66722: LIST
66723: PUSH
66724: LD_INT 1
66726: PUSH
66727: LD_INT 2
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 0
66736: PUSH
66737: LD_INT 2
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 1
66746: NEG
66747: PUSH
66748: LD_INT 1
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 2
66757: NEG
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 2
66768: NEG
66769: PUSH
66770: LD_INT 1
66772: NEG
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 2
66780: NEG
66781: PUSH
66782: LD_INT 2
66784: NEG
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 1
66792: PUSH
66793: LD_INT 2
66795: NEG
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: LD_INT 2
66803: PUSH
66804: LD_INT 1
66806: NEG
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: PUSH
66812: LD_INT 3
66814: PUSH
66815: LD_INT 1
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 3
66824: PUSH
66825: LD_INT 2
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66857: LD_ADDR_VAR 0 25
66861: PUSH
66862: LD_INT 0
66864: PUSH
66865: LD_INT 0
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 0
66874: PUSH
66875: LD_INT 1
66877: NEG
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 1
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 1
66895: PUSH
66896: LD_INT 1
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 0
66905: PUSH
66906: LD_INT 1
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 1
66915: NEG
66916: PUSH
66917: LD_INT 0
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: PUSH
66924: LD_INT 1
66926: NEG
66927: PUSH
66928: LD_INT 1
66930: NEG
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: PUSH
66936: LD_INT 1
66938: NEG
66939: PUSH
66940: LD_INT 2
66942: NEG
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 0
66950: PUSH
66951: LD_INT 2
66953: NEG
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 1
66961: PUSH
66962: LD_INT 1
66964: NEG
66965: PUSH
66966: EMPTY
66967: LIST
66968: LIST
66969: PUSH
66970: LD_INT 2
66972: PUSH
66973: LD_INT 0
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 2
66982: PUSH
66983: LD_INT 1
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 2
66992: PUSH
66993: LD_INT 2
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 1
67002: PUSH
67003: LD_INT 2
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 0
67012: PUSH
67013: LD_INT 2
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 1
67022: NEG
67023: PUSH
67024: LD_INT 1
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 2
67033: NEG
67034: PUSH
67035: LD_INT 0
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: PUSH
67042: LD_INT 2
67044: NEG
67045: PUSH
67046: LD_INT 1
67048: NEG
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 2
67056: NEG
67057: PUSH
67058: LD_INT 2
67060: NEG
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 3
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 3
67078: PUSH
67079: LD_INT 2
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 2
67088: PUSH
67089: LD_INT 3
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: LD_INT 1
67098: PUSH
67099: LD_INT 3
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: LIST
67120: LIST
67121: LIST
67122: LIST
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67131: LD_ADDR_VAR 0 26
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: LD_INT 0
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 0
67148: PUSH
67149: LD_INT 1
67151: NEG
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 1
67159: PUSH
67160: LD_INT 0
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 1
67169: PUSH
67170: LD_INT 1
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: LD_INT 1
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 1
67200: NEG
67201: PUSH
67202: LD_INT 1
67204: NEG
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 1
67212: NEG
67213: PUSH
67214: LD_INT 2
67216: NEG
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: LD_INT 0
67224: PUSH
67225: LD_INT 2
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 1
67235: PUSH
67236: LD_INT 1
67238: NEG
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 2
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: PUSH
67254: LD_INT 2
67256: PUSH
67257: LD_INT 1
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 2
67266: PUSH
67267: LD_INT 2
67269: PUSH
67270: EMPTY
67271: LIST
67272: LIST
67273: PUSH
67274: LD_INT 1
67276: PUSH
67277: LD_INT 2
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 0
67286: PUSH
67287: LD_INT 2
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 1
67296: NEG
67297: PUSH
67298: LD_INT 1
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 2
67307: NEG
67308: PUSH
67309: LD_INT 0
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 2
67318: NEG
67319: PUSH
67320: LD_INT 1
67322: NEG
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 2
67330: NEG
67331: PUSH
67332: LD_INT 2
67334: NEG
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 2
67342: PUSH
67343: LD_INT 3
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 1
67352: PUSH
67353: LD_INT 3
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 1
67362: NEG
67363: PUSH
67364: LD_INT 2
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 2
67373: NEG
67374: PUSH
67375: LD_INT 1
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: LIST
67397: LIST
67398: LIST
67399: LIST
67400: LIST
67401: LIST
67402: LIST
67403: LIST
67404: LIST
67405: LIST
67406: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67407: LD_ADDR_VAR 0 27
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 0
67424: PUSH
67425: LD_INT 1
67427: NEG
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: LD_INT 0
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 1
67445: PUSH
67446: LD_INT 1
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 0
67455: PUSH
67456: LD_INT 1
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PUSH
67463: LD_INT 1
67465: NEG
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: NEG
67477: PUSH
67478: LD_INT 1
67480: NEG
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: PUSH
67486: LD_INT 1
67488: NEG
67489: PUSH
67490: LD_INT 2
67492: NEG
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 0
67500: PUSH
67501: LD_INT 2
67503: NEG
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 1
67511: PUSH
67512: LD_INT 1
67514: NEG
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 2
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 2
67532: PUSH
67533: LD_INT 1
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 2
67542: PUSH
67543: LD_INT 2
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: LD_INT 2
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 0
67562: PUSH
67563: LD_INT 2
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 1
67572: NEG
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 2
67583: NEG
67584: PUSH
67585: LD_INT 0
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: LD_INT 2
67594: NEG
67595: PUSH
67596: LD_INT 1
67598: NEG
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PUSH
67604: LD_INT 2
67606: NEG
67607: PUSH
67608: LD_INT 2
67610: NEG
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 1
67618: NEG
67619: PUSH
67620: LD_INT 2
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 2
67629: NEG
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 3
67640: NEG
67641: PUSH
67642: LD_INT 1
67644: NEG
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 3
67652: NEG
67653: PUSH
67654: LD_INT 2
67656: NEG
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: LIST
67671: LIST
67672: LIST
67673: LIST
67674: LIST
67675: LIST
67676: LIST
67677: LIST
67678: LIST
67679: LIST
67680: LIST
67681: LIST
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67687: LD_ADDR_VAR 0 28
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: LD_INT 0
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 0
67704: PUSH
67705: LD_INT 1
67707: NEG
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 1
67715: PUSH
67716: LD_INT 0
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: PUSH
67726: LD_INT 1
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 0
67735: PUSH
67736: LD_INT 1
67738: PUSH
67739: EMPTY
67740: LIST
67741: LIST
67742: PUSH
67743: LD_INT 1
67745: NEG
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 1
67756: NEG
67757: PUSH
67758: LD_INT 1
67760: NEG
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 1
67768: NEG
67769: PUSH
67770: LD_INT 2
67772: NEG
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 0
67780: PUSH
67781: LD_INT 2
67783: NEG
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 1
67791: PUSH
67792: LD_INT 1
67794: NEG
67795: PUSH
67796: EMPTY
67797: LIST
67798: LIST
67799: PUSH
67800: LD_INT 2
67802: PUSH
67803: LD_INT 0
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PUSH
67810: LD_INT 2
67812: PUSH
67813: LD_INT 1
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: LD_INT 2
67822: PUSH
67823: LD_INT 2
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 1
67832: PUSH
67833: LD_INT 2
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 0
67842: PUSH
67843: LD_INT 2
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 1
67852: NEG
67853: PUSH
67854: LD_INT 1
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PUSH
67861: LD_INT 2
67863: NEG
67864: PUSH
67865: LD_INT 0
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 2
67874: NEG
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 2
67886: NEG
67887: PUSH
67888: LD_INT 2
67890: NEG
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 2
67898: NEG
67899: PUSH
67900: LD_INT 3
67902: NEG
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 1
67910: NEG
67911: PUSH
67912: LD_INT 3
67914: NEG
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: LD_INT 3
67922: NEG
67923: PUSH
67924: LD_INT 1
67926: NEG
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 3
67934: NEG
67935: PUSH
67936: LD_INT 2
67938: NEG
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: LIST
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: LIST
67957: LIST
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67969: LD_ADDR_VAR 0 29
67973: PUSH
67974: LD_INT 0
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 0
67986: PUSH
67987: LD_INT 1
67989: NEG
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 1
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 1
68007: PUSH
68008: LD_INT 1
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 0
68017: PUSH
68018: LD_INT 1
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 1
68027: NEG
68028: PUSH
68029: LD_INT 0
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 1
68038: NEG
68039: PUSH
68040: LD_INT 1
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 1
68050: NEG
68051: PUSH
68052: LD_INT 2
68054: NEG
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 0
68062: PUSH
68063: LD_INT 2
68065: NEG
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 2
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 2
68094: PUSH
68095: LD_INT 1
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 1
68104: PUSH
68105: LD_INT 2
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: LD_INT 0
68114: PUSH
68115: LD_INT 2
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 1
68124: NEG
68125: PUSH
68126: LD_INT 1
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 2
68135: NEG
68136: PUSH
68137: LD_INT 1
68139: NEG
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 2
68147: NEG
68148: PUSH
68149: LD_INT 2
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 2
68159: NEG
68160: PUSH
68161: LD_INT 3
68163: NEG
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 2
68171: PUSH
68172: LD_INT 1
68174: NEG
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 3
68182: PUSH
68183: LD_INT 1
68185: PUSH
68186: EMPTY
68187: LIST
68188: LIST
68189: PUSH
68190: LD_INT 1
68192: PUSH
68193: LD_INT 3
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: LD_INT 2
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 3
68213: NEG
68214: PUSH
68215: LD_INT 2
68217: NEG
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: LIST
68236: LIST
68237: LIST
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: LIST
68243: LIST
68244: LIST
68245: LIST
68246: LIST
68247: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68248: LD_ADDR_VAR 0 30
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: LD_INT 0
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 0
68265: PUSH
68266: LD_INT 1
68268: NEG
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 1
68276: PUSH
68277: LD_INT 0
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 1
68286: PUSH
68287: LD_INT 1
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 0
68296: PUSH
68297: LD_INT 1
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PUSH
68304: LD_INT 1
68306: NEG
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 1
68317: NEG
68318: PUSH
68319: LD_INT 1
68321: NEG
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 1
68329: NEG
68330: PUSH
68331: LD_INT 2
68333: NEG
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 0
68341: PUSH
68342: LD_INT 2
68344: NEG
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 1
68352: PUSH
68353: LD_INT 1
68355: NEG
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 2
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 2
68373: PUSH
68374: LD_INT 1
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 2
68383: PUSH
68384: LD_INT 2
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: PUSH
68394: LD_INT 2
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 1
68403: NEG
68404: PUSH
68405: LD_INT 1
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 2
68414: NEG
68415: PUSH
68416: LD_INT 0
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: NEG
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 1
68437: NEG
68438: PUSH
68439: LD_INT 3
68441: NEG
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PUSH
68447: LD_INT 1
68449: PUSH
68450: LD_INT 2
68452: NEG
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 3
68460: PUSH
68461: LD_INT 2
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 2
68470: PUSH
68471: LD_INT 3
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 2
68480: NEG
68481: PUSH
68482: LD_INT 1
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 3
68491: NEG
68492: PUSH
68493: LD_INT 1
68495: NEG
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68526: LD_ADDR_VAR 0 31
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: LD_INT 0
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 0
68543: PUSH
68544: LD_INT 1
68546: NEG
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: LD_INT 1
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 0
68574: PUSH
68575: LD_INT 1
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 1
68584: NEG
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 1
68595: NEG
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: LD_INT 1
68622: NEG
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 2
68630: PUSH
68631: LD_INT 0
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 2
68640: PUSH
68641: LD_INT 1
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: LD_INT 2
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 1
68660: PUSH
68661: LD_INT 2
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 0
68670: PUSH
68671: LD_INT 2
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: NEG
68681: PUSH
68682: LD_INT 1
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 2
68691: NEG
68692: PUSH
68693: LD_INT 1
68695: NEG
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 2
68703: NEG
68704: PUSH
68705: LD_INT 2
68707: NEG
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 2
68715: NEG
68716: PUSH
68717: LD_INT 3
68719: NEG
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 2
68727: PUSH
68728: LD_INT 1
68730: NEG
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 3
68738: PUSH
68739: LD_INT 1
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 1
68748: PUSH
68749: LD_INT 3
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 1
68758: NEG
68759: PUSH
68760: LD_INT 2
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 3
68769: NEG
68770: PUSH
68771: LD_INT 2
68773: NEG
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: LIST
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: LIST
68788: LIST
68789: LIST
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68804: LD_ADDR_VAR 0 32
68808: PUSH
68809: LD_INT 0
68811: PUSH
68812: LD_INT 0
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: LD_INT 1
68824: NEG
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PUSH
68830: LD_INT 1
68832: PUSH
68833: LD_INT 0
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PUSH
68840: LD_INT 1
68842: PUSH
68843: LD_INT 1
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 0
68852: PUSH
68853: LD_INT 1
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 1
68862: NEG
68863: PUSH
68864: LD_INT 0
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 1
68873: NEG
68874: PUSH
68875: LD_INT 1
68877: NEG
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: NEG
68886: PUSH
68887: LD_INT 2
68889: NEG
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 0
68897: PUSH
68898: LD_INT 2
68900: NEG
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 1
68908: PUSH
68909: LD_INT 1
68911: NEG
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PUSH
68917: LD_INT 2
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 2
68929: PUSH
68930: LD_INT 2
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: LD_INT 1
68939: PUSH
68940: LD_INT 2
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 0
68949: PUSH
68950: LD_INT 2
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: NEG
68960: PUSH
68961: LD_INT 1
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: NEG
68971: PUSH
68972: LD_INT 0
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: PUSH
68979: LD_INT 2
68981: NEG
68982: PUSH
68983: LD_INT 1
68985: NEG
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 1
68993: NEG
68994: PUSH
68995: LD_INT 3
68997: NEG
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 1
69005: PUSH
69006: LD_INT 2
69008: NEG
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 3
69016: PUSH
69017: LD_INT 2
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 2
69026: PUSH
69027: LD_INT 3
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 2
69036: NEG
69037: PUSH
69038: LD_INT 1
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 3
69047: NEG
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: LIST
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69082: LD_ADDR_VAR 0 33
69086: PUSH
69087: LD_INT 0
69089: PUSH
69090: LD_INT 0
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 0
69099: PUSH
69100: LD_INT 1
69102: NEG
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: PUSH
69108: LD_INT 1
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 1
69120: PUSH
69121: LD_INT 1
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 0
69130: PUSH
69131: LD_INT 1
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: NEG
69141: PUSH
69142: LD_INT 0
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 1
69151: NEG
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: NEG
69164: PUSH
69165: LD_INT 2
69167: NEG
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 1
69175: PUSH
69176: LD_INT 1
69178: NEG
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 2
69186: PUSH
69187: LD_INT 0
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 2
69196: PUSH
69197: LD_INT 1
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: LD_INT 2
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 0
69216: PUSH
69217: LD_INT 2
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 1
69226: NEG
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: LD_INT 2
69237: NEG
69238: PUSH
69239: LD_INT 0
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 2
69248: NEG
69249: PUSH
69250: LD_INT 1
69252: NEG
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 2
69260: NEG
69261: PUSH
69262: LD_INT 2
69264: NEG
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 2
69272: NEG
69273: PUSH
69274: LD_INT 3
69276: NEG
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 2
69284: PUSH
69285: LD_INT 1
69287: NEG
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 3
69295: PUSH
69296: LD_INT 1
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 1
69305: PUSH
69306: LD_INT 3
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 1
69315: NEG
69316: PUSH
69317: LD_INT 2
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PUSH
69324: LD_INT 3
69326: NEG
69327: PUSH
69328: LD_INT 2
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69361: LD_ADDR_VAR 0 34
69365: PUSH
69366: LD_INT 0
69368: PUSH
69369: LD_INT 0
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 1
69399: PUSH
69400: LD_INT 1
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: LD_INT 1
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 1
69419: NEG
69420: PUSH
69421: LD_INT 0
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 1
69430: NEG
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: NEG
69443: PUSH
69444: LD_INT 2
69446: NEG
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 0
69454: PUSH
69455: LD_INT 2
69457: NEG
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: LD_INT 1
69468: NEG
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: LD_INT 2
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 2
69486: PUSH
69487: LD_INT 2
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 1
69496: PUSH
69497: LD_INT 2
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 1
69506: NEG
69507: PUSH
69508: LD_INT 1
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: LD_INT 2
69517: NEG
69518: PUSH
69519: LD_INT 0
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 2
69528: NEG
69529: PUSH
69530: LD_INT 1
69532: NEG
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 2
69540: NEG
69541: PUSH
69542: LD_INT 2
69544: NEG
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 1
69552: NEG
69553: PUSH
69554: LD_INT 3
69556: NEG
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 1
69564: PUSH
69565: LD_INT 2
69567: NEG
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: LD_INT 3
69575: PUSH
69576: LD_INT 2
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 2
69585: PUSH
69586: LD_INT 3
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 2
69595: NEG
69596: PUSH
69597: LD_INT 1
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 3
69606: NEG
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69641: LD_ADDR_VAR 0 35
69645: PUSH
69646: LD_INT 0
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 0
69658: PUSH
69659: LD_INT 1
69661: NEG
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 1
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 0
69689: PUSH
69690: LD_INT 1
69692: PUSH
69693: EMPTY
69694: LIST
69695: LIST
69696: PUSH
69697: LD_INT 1
69699: NEG
69700: PUSH
69701: LD_INT 0
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 1
69710: NEG
69711: PUSH
69712: LD_INT 1
69714: NEG
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: PUSH
69720: LD_INT 2
69722: PUSH
69723: LD_INT 1
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 2
69732: NEG
69733: PUSH
69734: LD_INT 1
69736: NEG
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69753: LD_ADDR_VAR 0 36
69757: PUSH
69758: LD_INT 0
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 0
69770: PUSH
69771: LD_INT 1
69773: NEG
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: PUSH
69779: LD_INT 1
69781: PUSH
69782: LD_INT 0
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 1
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: LD_INT 1
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: NEG
69812: PUSH
69813: LD_INT 0
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 1
69822: NEG
69823: PUSH
69824: LD_INT 1
69826: NEG
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 1
69834: NEG
69835: PUSH
69836: LD_INT 2
69838: NEG
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 1
69846: PUSH
69847: LD_INT 2
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69865: LD_ADDR_VAR 0 37
69869: PUSH
69870: LD_INT 0
69872: PUSH
69873: LD_INT 0
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 0
69882: PUSH
69883: LD_INT 1
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 1
69893: PUSH
69894: LD_INT 0
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 1
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 0
69913: PUSH
69914: LD_INT 1
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: NEG
69924: PUSH
69925: LD_INT 0
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 1
69934: NEG
69935: PUSH
69936: LD_INT 1
69938: NEG
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 1
69946: PUSH
69947: LD_INT 1
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: LD_INT 1
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69977: LD_ADDR_VAR 0 38
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: LD_INT 1
69997: NEG
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 1
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 1
70015: PUSH
70016: LD_INT 1
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: LD_INT 0
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 1
70035: NEG
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 1
70046: NEG
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 2
70058: PUSH
70059: LD_INT 1
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 2
70068: NEG
70069: PUSH
70070: LD_INT 1
70072: NEG
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70089: LD_ADDR_VAR 0 39
70093: PUSH
70094: LD_INT 0
70096: PUSH
70097: LD_INT 0
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: LD_INT 1
70109: NEG
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 1
70117: PUSH
70118: LD_INT 0
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 1
70127: PUSH
70128: LD_INT 1
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 0
70137: PUSH
70138: LD_INT 1
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 1
70147: NEG
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 1
70158: NEG
70159: PUSH
70160: LD_INT 1
70162: NEG
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 1
70170: NEG
70171: PUSH
70172: LD_INT 2
70174: NEG
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 1
70182: PUSH
70183: LD_INT 2
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70201: LD_ADDR_VAR 0 40
70205: PUSH
70206: LD_INT 0
70208: PUSH
70209: LD_INT 0
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: LD_INT 1
70221: NEG
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 1
70229: PUSH
70230: LD_INT 0
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: LD_INT 1
70239: PUSH
70240: LD_INT 1
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 0
70249: PUSH
70250: LD_INT 1
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 1
70259: NEG
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 1
70270: NEG
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: PUSH
70283: LD_INT 1
70285: NEG
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 1
70293: NEG
70294: PUSH
70295: LD_INT 1
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70313: LD_ADDR_VAR 0 41
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 0
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 0
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: LD_INT 1
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 1
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: NEG
70383: PUSH
70384: LD_INT 1
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 2
70398: NEG
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 1
70406: PUSH
70407: LD_INT 1
70409: NEG
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 2
70417: PUSH
70418: LD_INT 0
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 2
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 2
70437: PUSH
70438: LD_INT 2
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 1
70447: PUSH
70448: LD_INT 2
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 1
70457: NEG
70458: PUSH
70459: LD_INT 1
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 2
70468: NEG
70469: PUSH
70470: LD_INT 0
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 2
70479: NEG
70480: PUSH
70481: LD_INT 1
70483: NEG
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 2
70491: NEG
70492: PUSH
70493: LD_INT 2
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 2
70503: NEG
70504: PUSH
70505: LD_INT 3
70507: NEG
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 2
70515: PUSH
70516: LD_INT 1
70518: NEG
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 3
70526: PUSH
70527: LD_INT 0
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 3
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 3
70546: PUSH
70547: LD_INT 2
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 3
70556: PUSH
70557: LD_INT 3
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 2
70566: PUSH
70567: LD_INT 3
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: PUSH
70574: LD_INT 2
70576: NEG
70577: PUSH
70578: LD_INT 1
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 3
70587: NEG
70588: PUSH
70589: LD_INT 0
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 3
70598: NEG
70599: PUSH
70600: LD_INT 1
70602: NEG
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 3
70610: NEG
70611: PUSH
70612: LD_INT 2
70614: NEG
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 3
70622: NEG
70623: PUSH
70624: LD_INT 3
70626: NEG
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70663: LD_ADDR_VAR 0 42
70667: PUSH
70668: LD_INT 0
70670: PUSH
70671: LD_INT 0
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 0
70680: PUSH
70681: LD_INT 1
70683: NEG
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 1
70691: PUSH
70692: LD_INT 0
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 1
70701: PUSH
70702: LD_INT 1
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 1
70721: NEG
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: NEG
70733: PUSH
70734: LD_INT 1
70736: NEG
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: PUSH
70742: LD_INT 1
70744: NEG
70745: PUSH
70746: LD_INT 2
70748: NEG
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 0
70756: PUSH
70757: LD_INT 2
70759: NEG
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 1
70767: PUSH
70768: LD_INT 1
70770: NEG
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 2
70778: PUSH
70779: LD_INT 1
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 2
70788: PUSH
70789: LD_INT 2
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 1
70798: PUSH
70799: LD_INT 2
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 0
70808: PUSH
70809: LD_INT 2
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 1
70818: NEG
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 2
70829: NEG
70830: PUSH
70831: LD_INT 1
70833: NEG
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: LD_INT 2
70841: NEG
70842: PUSH
70843: LD_INT 2
70845: NEG
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 2
70853: NEG
70854: PUSH
70855: LD_INT 3
70857: NEG
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 1
70865: NEG
70866: PUSH
70867: LD_INT 3
70869: NEG
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 0
70877: PUSH
70878: LD_INT 3
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 1
70888: PUSH
70889: LD_INT 2
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 3
70899: PUSH
70900: LD_INT 2
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 3
70909: PUSH
70910: LD_INT 3
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: PUSH
70920: LD_INT 3
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: LD_INT 3
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: LD_INT 3
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 1
70949: NEG
70950: PUSH
70951: LD_INT 2
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 3
70960: NEG
70961: PUSH
70962: LD_INT 2
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 3
70972: NEG
70973: PUSH
70974: LD_INT 3
70976: NEG
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71013: LD_ADDR_VAR 0 43
71017: PUSH
71018: LD_INT 0
71020: PUSH
71021: LD_INT 0
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 0
71030: PUSH
71031: LD_INT 1
71033: NEG
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 1
71041: PUSH
71042: LD_INT 0
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 1
71051: PUSH
71052: LD_INT 1
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: LD_INT 1
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: LD_INT 1
71071: NEG
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 1
71082: NEG
71083: PUSH
71084: LD_INT 1
71086: NEG
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: LD_INT 2
71098: NEG
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 0
71106: PUSH
71107: LD_INT 2
71109: NEG
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 2
71128: PUSH
71129: LD_INT 0
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 2
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 1
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 0
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 1
71168: NEG
71169: PUSH
71170: LD_INT 1
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 2
71179: NEG
71180: PUSH
71181: LD_INT 0
71183: PUSH
71184: EMPTY
71185: LIST
71186: LIST
71187: PUSH
71188: LD_INT 2
71190: NEG
71191: PUSH
71192: LD_INT 1
71194: NEG
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 1
71202: NEG
71203: PUSH
71204: LD_INT 3
71206: NEG
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 0
71214: PUSH
71215: LD_INT 3
71217: NEG
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 1
71225: PUSH
71226: LD_INT 2
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 2
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 3
71247: PUSH
71248: LD_INT 0
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 3
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 1
71267: PUSH
71268: LD_INT 3
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 0
71277: PUSH
71278: LD_INT 3
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 1
71287: NEG
71288: PUSH
71289: LD_INT 2
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: PUSH
71296: LD_INT 2
71298: NEG
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 3
71309: NEG
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 3
71320: NEG
71321: PUSH
71322: LD_INT 1
71324: NEG
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71361: LD_ADDR_VAR 0 44
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: LD_INT 0
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 0
71378: PUSH
71379: LD_INT 1
71381: NEG
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 1
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: LD_INT 1
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 0
71409: PUSH
71410: LD_INT 1
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 1
71419: NEG
71420: PUSH
71421: LD_INT 0
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 1
71430: NEG
71431: PUSH
71432: LD_INT 1
71434: NEG
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 1
71442: NEG
71443: PUSH
71444: LD_INT 2
71446: NEG
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 1
71454: PUSH
71455: LD_INT 1
71457: NEG
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: LD_INT 2
71465: PUSH
71466: LD_INT 0
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 2
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 2
71485: PUSH
71486: LD_INT 2
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: LD_INT 2
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 1
71505: NEG
71506: PUSH
71507: LD_INT 1
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 2
71516: NEG
71517: PUSH
71518: LD_INT 0
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 2
71527: NEG
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 2
71539: NEG
71540: PUSH
71541: LD_INT 2
71543: NEG
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: PUSH
71549: LD_INT 2
71551: NEG
71552: PUSH
71553: LD_INT 3
71555: NEG
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 2
71563: PUSH
71564: LD_INT 1
71566: NEG
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 3
71574: PUSH
71575: LD_INT 0
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PUSH
71582: LD_INT 3
71584: PUSH
71585: LD_INT 1
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: LD_INT 3
71594: PUSH
71595: LD_INT 2
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PUSH
71602: LD_INT 3
71604: PUSH
71605: LD_INT 3
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: LD_INT 2
71614: PUSH
71615: LD_INT 3
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PUSH
71622: LD_INT 2
71624: NEG
71625: PUSH
71626: LD_INT 1
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: PUSH
71633: LD_INT 3
71635: NEG
71636: PUSH
71637: LD_INT 0
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 3
71646: NEG
71647: PUSH
71648: LD_INT 1
71650: NEG
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 3
71658: NEG
71659: PUSH
71660: LD_INT 2
71662: NEG
71663: PUSH
71664: EMPTY
71665: LIST
71666: LIST
71667: PUSH
71668: LD_INT 3
71670: NEG
71671: PUSH
71672: LD_INT 3
71674: NEG
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: LIST
71693: LIST
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71711: LD_ADDR_VAR 0 45
71715: PUSH
71716: LD_INT 0
71718: PUSH
71719: LD_INT 0
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 0
71728: PUSH
71729: LD_INT 1
71731: NEG
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PUSH
71737: LD_INT 1
71739: PUSH
71740: LD_INT 0
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 1
71749: PUSH
71750: LD_INT 1
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 0
71759: PUSH
71760: LD_INT 1
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 1
71769: NEG
71770: PUSH
71771: LD_INT 0
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 1
71780: NEG
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: NEG
71793: PUSH
71794: LD_INT 2
71796: NEG
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 0
71804: PUSH
71805: LD_INT 2
71807: NEG
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 1
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 2
71826: PUSH
71827: LD_INT 1
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 2
71836: PUSH
71837: LD_INT 2
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 1
71846: PUSH
71847: LD_INT 2
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 0
71856: PUSH
71857: LD_INT 2
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 1
71866: NEG
71867: PUSH
71868: LD_INT 1
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: PUSH
71875: LD_INT 2
71877: NEG
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 2
71889: NEG
71890: PUSH
71891: LD_INT 2
71893: NEG
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 2
71901: NEG
71902: PUSH
71903: LD_INT 3
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 1
71913: NEG
71914: PUSH
71915: LD_INT 3
71917: NEG
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: LD_INT 3
71928: NEG
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 1
71936: PUSH
71937: LD_INT 2
71939: NEG
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 3
71947: PUSH
71948: LD_INT 2
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 3
71957: PUSH
71958: LD_INT 3
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 2
71967: PUSH
71968: LD_INT 3
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: LD_INT 3
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 0
71987: PUSH
71988: LD_INT 3
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 1
71997: NEG
71998: PUSH
71999: LD_INT 2
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 3
72008: NEG
72009: PUSH
72010: LD_INT 2
72012: NEG
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 3
72020: NEG
72021: PUSH
72022: LD_INT 3
72024: NEG
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72061: LD_ADDR_VAR 0 46
72065: PUSH
72066: LD_INT 0
72068: PUSH
72069: LD_INT 0
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 0
72078: PUSH
72079: LD_INT 1
72081: NEG
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 1
72089: PUSH
72090: LD_INT 0
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 1
72099: PUSH
72100: LD_INT 1
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: LD_INT 1
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 1
72119: NEG
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: NEG
72131: PUSH
72132: LD_INT 1
72134: NEG
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 1
72142: NEG
72143: PUSH
72144: LD_INT 2
72146: NEG
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 0
72154: PUSH
72155: LD_INT 2
72157: NEG
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: PUSH
72166: LD_INT 1
72168: NEG
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 2
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 2
72186: PUSH
72187: LD_INT 1
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: LD_INT 2
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 0
72206: PUSH
72207: LD_INT 2
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: LD_INT 1
72216: NEG
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 2
72227: NEG
72228: PUSH
72229: LD_INT 0
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 2
72238: NEG
72239: PUSH
72240: LD_INT 1
72242: NEG
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 1
72250: NEG
72251: PUSH
72252: LD_INT 3
72254: NEG
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: LD_INT 3
72265: NEG
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 1
72273: PUSH
72274: LD_INT 2
72276: NEG
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 2
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 3
72295: PUSH
72296: LD_INT 0
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 3
72305: PUSH
72306: LD_INT 1
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 1
72315: PUSH
72316: LD_INT 3
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 0
72325: PUSH
72326: LD_INT 3
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 1
72335: NEG
72336: PUSH
72337: LD_INT 2
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 2
72346: NEG
72347: PUSH
72348: LD_INT 1
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 3
72357: NEG
72358: PUSH
72359: LD_INT 0
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 3
72368: NEG
72369: PUSH
72370: LD_INT 1
72372: NEG
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72409: LD_ADDR_VAR 0 47
72413: PUSH
72414: LD_INT 0
72416: PUSH
72417: LD_INT 0
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 0
72426: PUSH
72427: LD_INT 1
72429: NEG
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 1
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 1
72447: PUSH
72448: LD_INT 1
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 0
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 1
72467: NEG
72468: PUSH
72469: LD_INT 0
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 1
72478: NEG
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 1
72490: NEG
72491: PUSH
72492: LD_INT 2
72494: NEG
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 0
72502: PUSH
72503: LD_INT 2
72505: NEG
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 1
72513: PUSH
72514: LD_INT 1
72516: NEG
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 2
72524: NEG
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 2
72536: NEG
72537: PUSH
72538: LD_INT 2
72540: NEG
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: LIST
72559: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72560: LD_ADDR_VAR 0 48
72564: PUSH
72565: LD_INT 0
72567: PUSH
72568: LD_INT 0
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 0
72577: PUSH
72578: LD_INT 1
72580: NEG
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PUSH
72586: LD_INT 1
72588: PUSH
72589: LD_INT 0
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PUSH
72596: LD_INT 1
72598: PUSH
72599: LD_INT 1
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 0
72608: PUSH
72609: LD_INT 1
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 1
72618: NEG
72619: PUSH
72620: LD_INT 0
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 1
72629: NEG
72630: PUSH
72631: LD_INT 1
72633: NEG
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 1
72641: NEG
72642: PUSH
72643: LD_INT 2
72645: NEG
72646: PUSH
72647: EMPTY
72648: LIST
72649: LIST
72650: PUSH
72651: LD_INT 0
72653: PUSH
72654: LD_INT 2
72656: NEG
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 1
72664: PUSH
72665: LD_INT 1
72667: NEG
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 2
72675: PUSH
72676: LD_INT 0
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 2
72685: PUSH
72686: LD_INT 1
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72707: LD_ADDR_VAR 0 49
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: LD_INT 0
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: LD_INT 1
72727: NEG
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 1
72735: PUSH
72736: LD_INT 0
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: PUSH
72746: LD_INT 1
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 0
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 1
72765: NEG
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 1
72776: NEG
72777: PUSH
72778: LD_INT 1
72780: NEG
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: LD_INT 1
72791: NEG
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 2
72799: PUSH
72800: LD_INT 0
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: LD_INT 2
72809: PUSH
72810: LD_INT 1
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 2
72819: PUSH
72820: LD_INT 2
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: LD_INT 2
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72851: LD_ADDR_VAR 0 50
72855: PUSH
72856: LD_INT 0
72858: PUSH
72859: LD_INT 0
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 0
72868: PUSH
72869: LD_INT 1
72871: NEG
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 0
72899: PUSH
72900: LD_INT 1
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 0
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: LD_INT 1
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 2
72932: PUSH
72933: LD_INT 1
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 2
72942: PUSH
72943: LD_INT 2
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 1
72952: PUSH
72953: LD_INT 2
72955: PUSH
72956: EMPTY
72957: LIST
72958: LIST
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: LD_INT 2
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PUSH
72970: LD_INT 1
72972: NEG
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: LIST
72985: LIST
72986: LIST
72987: LIST
72988: LIST
72989: LIST
72990: LIST
72991: LIST
72992: LIST
72993: LIST
72994: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72995: LD_ADDR_VAR 0 51
72999: PUSH
73000: LD_INT 0
73002: PUSH
73003: LD_INT 0
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 0
73012: PUSH
73013: LD_INT 1
73015: NEG
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 1
73023: PUSH
73024: LD_INT 0
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 1
73033: PUSH
73034: LD_INT 1
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: LD_INT 1
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PUSH
73051: LD_INT 1
73053: NEG
73054: PUSH
73055: LD_INT 0
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 1
73064: NEG
73065: PUSH
73066: LD_INT 1
73068: NEG
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 1
73076: PUSH
73077: LD_INT 2
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: PUSH
73084: LD_INT 0
73086: PUSH
73087: LD_INT 2
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 1
73096: NEG
73097: PUSH
73098: LD_INT 1
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 2
73107: NEG
73108: PUSH
73109: LD_INT 0
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 2
73118: NEG
73119: PUSH
73120: LD_INT 1
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73142: LD_ADDR_VAR 0 52
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: PUSH
73171: LD_INT 0
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 0
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 1
73200: NEG
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: NEG
73212: PUSH
73213: LD_INT 1
73215: NEG
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: LD_INT 2
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 1
73235: NEG
73236: PUSH
73237: LD_INT 1
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 2
73246: NEG
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 2
73257: NEG
73258: PUSH
73259: LD_INT 1
73261: NEG
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 2
73269: NEG
73270: PUSH
73271: LD_INT 2
73273: NEG
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73293: LD_ADDR_VAR 0 53
73297: PUSH
73298: LD_INT 0
73300: PUSH
73301: LD_INT 0
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 1
73321: PUSH
73322: LD_INT 0
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 1
73331: PUSH
73332: LD_INT 1
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 0
73341: PUSH
73342: LD_INT 1
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 1
73351: NEG
73352: PUSH
73353: LD_INT 0
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: NEG
73363: PUSH
73364: LD_INT 1
73366: NEG
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 1
73374: NEG
73375: PUSH
73376: LD_INT 2
73378: NEG
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 2
73389: NEG
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 1
73397: PUSH
73398: LD_INT 1
73400: NEG
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: LD_INT 2
73408: PUSH
73409: LD_INT 0
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: PUSH
73416: LD_INT 2
73418: PUSH
73419: LD_INT 1
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: PUSH
73426: LD_INT 2
73428: PUSH
73429: LD_INT 2
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PUSH
73436: LD_INT 1
73438: PUSH
73439: LD_INT 2
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 0
73448: PUSH
73449: LD_INT 2
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 2
73469: NEG
73470: PUSH
73471: LD_INT 0
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: LD_INT 1
73484: NEG
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 2
73492: NEG
73493: PUSH
73494: LD_INT 2
73496: NEG
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73523: LD_ADDR_VAR 0 54
73527: PUSH
73528: LD_INT 0
73530: PUSH
73531: LD_INT 0
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: LD_INT 1
73543: NEG
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 1
73551: PUSH
73552: LD_INT 0
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 1
73561: PUSH
73562: LD_INT 1
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 0
73571: PUSH
73572: LD_INT 1
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 1
73581: NEG
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: LD_INT 1
73596: NEG
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: LD_INT 1
73604: NEG
73605: PUSH
73606: LD_INT 2
73608: NEG
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 0
73616: PUSH
73617: LD_INT 2
73619: NEG
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 1
73627: PUSH
73628: LD_INT 1
73630: NEG
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 2
73638: PUSH
73639: LD_INT 0
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 2
73648: PUSH
73649: LD_INT 1
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 2
73658: PUSH
73659: LD_INT 2
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 1
73668: PUSH
73669: LD_INT 2
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 0
73678: PUSH
73679: LD_INT 2
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 1
73688: NEG
73689: PUSH
73690: LD_INT 1
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 2
73699: NEG
73700: PUSH
73701: LD_INT 0
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 2
73710: NEG
73711: PUSH
73712: LD_INT 1
73714: NEG
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 2
73722: NEG
73723: PUSH
73724: LD_INT 2
73726: NEG
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: LIST
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73753: LD_ADDR_VAR 0 55
73757: PUSH
73758: LD_INT 0
73760: PUSH
73761: LD_INT 0
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 0
73770: PUSH
73771: LD_INT 1
73773: NEG
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: PUSH
73779: LD_INT 1
73781: PUSH
73782: LD_INT 0
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 1
73791: PUSH
73792: LD_INT 1
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 0
73801: PUSH
73802: LD_INT 1
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 1
73811: NEG
73812: PUSH
73813: LD_INT 0
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 1
73822: NEG
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: LD_INT 1
73834: NEG
73835: PUSH
73836: LD_INT 2
73838: NEG
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 0
73846: PUSH
73847: LD_INT 2
73849: NEG
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 1
73857: PUSH
73858: LD_INT 1
73860: NEG
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 2
73868: PUSH
73869: LD_INT 0
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: LD_INT 2
73878: PUSH
73879: LD_INT 1
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: PUSH
73886: LD_INT 2
73888: PUSH
73889: LD_INT 2
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 1
73898: PUSH
73899: LD_INT 2
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: LD_INT 2
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: PUSH
73916: LD_INT 1
73918: NEG
73919: PUSH
73920: LD_INT 1
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 2
73929: NEG
73930: PUSH
73931: LD_INT 0
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 2
73940: NEG
73941: PUSH
73942: LD_INT 1
73944: NEG
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 2
73952: NEG
73953: PUSH
73954: LD_INT 2
73956: NEG
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73983: LD_ADDR_VAR 0 56
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: LD_INT 0
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: LD_INT 1
74003: NEG
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: PUSH
74012: LD_INT 0
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 1
74021: PUSH
74022: LD_INT 1
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 0
74031: PUSH
74032: LD_INT 1
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 1
74041: NEG
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 1
74052: NEG
74053: PUSH
74054: LD_INT 1
74056: NEG
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 1
74064: NEG
74065: PUSH
74066: LD_INT 2
74068: NEG
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 0
74076: PUSH
74077: LD_INT 2
74079: NEG
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 1
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 2
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 2
74108: PUSH
74109: LD_INT 1
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 2
74118: PUSH
74119: LD_INT 2
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 1
74128: PUSH
74129: LD_INT 2
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 0
74138: PUSH
74139: LD_INT 2
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 1
74148: NEG
74149: PUSH
74150: LD_INT 1
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: LD_INT 2
74159: NEG
74160: PUSH
74161: LD_INT 0
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 2
74170: NEG
74171: PUSH
74172: LD_INT 1
74174: NEG
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 2
74182: NEG
74183: PUSH
74184: LD_INT 2
74186: NEG
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74213: LD_ADDR_VAR 0 57
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: LD_INT 0
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: LD_INT 1
74233: NEG
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 1
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 1
74251: PUSH
74252: LD_INT 1
74254: PUSH
74255: EMPTY
74256: LIST
74257: LIST
74258: PUSH
74259: LD_INT 0
74261: PUSH
74262: LD_INT 1
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PUSH
74269: LD_INT 1
74271: NEG
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 1
74282: NEG
74283: PUSH
74284: LD_INT 1
74286: NEG
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 1
74294: NEG
74295: PUSH
74296: LD_INT 2
74298: NEG
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 0
74306: PUSH
74307: LD_INT 2
74309: NEG
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 1
74317: PUSH
74318: LD_INT 1
74320: NEG
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 2
74328: PUSH
74329: LD_INT 0
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 2
74338: PUSH
74339: LD_INT 1
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: PUSH
74346: LD_INT 2
74348: PUSH
74349: LD_INT 2
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: PUSH
74356: LD_INT 1
74358: PUSH
74359: LD_INT 2
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: LD_INT 0
74368: PUSH
74369: LD_INT 2
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 1
74378: NEG
74379: PUSH
74380: LD_INT 1
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 2
74389: NEG
74390: PUSH
74391: LD_INT 0
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 2
74400: NEG
74401: PUSH
74402: LD_INT 1
74404: NEG
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: LD_INT 2
74412: NEG
74413: PUSH
74414: LD_INT 2
74416: NEG
74417: PUSH
74418: EMPTY
74419: LIST
74420: LIST
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74443: LD_ADDR_VAR 0 58
74447: PUSH
74448: LD_INT 0
74450: PUSH
74451: LD_INT 0
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 0
74460: PUSH
74461: LD_INT 1
74463: NEG
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 1
74471: PUSH
74472: LD_INT 0
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PUSH
74479: LD_INT 1
74481: PUSH
74482: LD_INT 1
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: LD_INT 1
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 1
74501: NEG
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 1
74512: NEG
74513: PUSH
74514: LD_INT 1
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 1
74524: NEG
74525: PUSH
74526: LD_INT 2
74528: NEG
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 0
74536: PUSH
74537: LD_INT 2
74539: NEG
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 1
74547: PUSH
74548: LD_INT 1
74550: NEG
74551: PUSH
74552: EMPTY
74553: LIST
74554: LIST
74555: PUSH
74556: LD_INT 2
74558: PUSH
74559: LD_INT 0
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 2
74568: PUSH
74569: LD_INT 1
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 2
74578: PUSH
74579: LD_INT 2
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: PUSH
74586: LD_INT 1
74588: PUSH
74589: LD_INT 2
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 0
74598: PUSH
74599: LD_INT 2
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 1
74608: NEG
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: LD_INT 2
74619: NEG
74620: PUSH
74621: LD_INT 0
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 2
74630: NEG
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: LD_INT 2
74642: NEG
74643: PUSH
74644: LD_INT 2
74646: NEG
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74673: LD_ADDR_VAR 0 59
74677: PUSH
74678: LD_INT 0
74680: PUSH
74681: LD_INT 0
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 0
74690: PUSH
74691: LD_INT 1
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 1
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 1
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 0
74721: PUSH
74722: LD_INT 1
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 1
74731: NEG
74732: PUSH
74733: LD_INT 0
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: LD_INT 1
74742: NEG
74743: PUSH
74744: LD_INT 1
74746: NEG
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74761: LD_ADDR_VAR 0 60
74765: PUSH
74766: LD_INT 0
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: LD_INT 1
74781: NEG
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 1
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 1
74799: PUSH
74800: LD_INT 1
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 0
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 1
74819: NEG
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 1
74830: NEG
74831: PUSH
74832: LD_INT 1
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: LIST
74844: LIST
74845: LIST
74846: LIST
74847: LIST
74848: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74849: LD_ADDR_VAR 0 61
74853: PUSH
74854: LD_INT 0
74856: PUSH
74857: LD_INT 0
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 0
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: PUSH
74878: LD_INT 0
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 1
74887: PUSH
74888: LD_INT 1
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 0
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 1
74907: NEG
74908: PUSH
74909: LD_INT 0
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: LD_INT 1
74918: NEG
74919: PUSH
74920: LD_INT 1
74922: NEG
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: LIST
74936: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74937: LD_ADDR_VAR 0 62
74941: PUSH
74942: LD_INT 0
74944: PUSH
74945: LD_INT 0
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 0
74954: PUSH
74955: LD_INT 1
74957: NEG
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 1
74965: PUSH
74966: LD_INT 0
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 1
74975: PUSH
74976: LD_INT 1
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 0
74985: PUSH
74986: LD_INT 1
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 1
74995: NEG
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: LD_INT 1
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75025: LD_ADDR_VAR 0 63
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: LD_INT 0
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: LD_INT 1
75045: NEG
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: PUSH
75051: LD_INT 1
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 1
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 0
75073: PUSH
75074: LD_INT 1
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 1
75083: NEG
75084: PUSH
75085: LD_INT 0
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 1
75094: NEG
75095: PUSH
75096: LD_INT 1
75098: NEG
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75113: LD_ADDR_VAR 0 64
75117: PUSH
75118: LD_INT 0
75120: PUSH
75121: LD_INT 0
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 0
75130: PUSH
75131: LD_INT 1
75133: NEG
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 1
75141: PUSH
75142: LD_INT 0
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 1
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 0
75161: PUSH
75162: LD_INT 1
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 1
75171: NEG
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 1
75182: NEG
75183: PUSH
75184: LD_INT 1
75186: NEG
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: LIST
75196: LIST
75197: LIST
75198: LIST
75199: LIST
75200: ST_TO_ADDR
// end ; 1 :
75201: GO 81098
75203: LD_INT 1
75205: DOUBLE
75206: EQUAL
75207: IFTRUE 75211
75209: GO 77834
75211: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75212: LD_ADDR_VAR 0 11
75216: PUSH
75217: LD_INT 1
75219: NEG
75220: PUSH
75221: LD_INT 3
75223: NEG
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: LD_INT 3
75234: NEG
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 1
75242: PUSH
75243: LD_INT 2
75245: NEG
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: LIST
75255: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75256: LD_ADDR_VAR 0 12
75260: PUSH
75261: LD_INT 2
75263: PUSH
75264: LD_INT 1
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 3
75274: PUSH
75275: LD_INT 0
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 3
75284: PUSH
75285: LD_INT 1
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: LIST
75296: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75297: LD_ADDR_VAR 0 13
75301: PUSH
75302: LD_INT 3
75304: PUSH
75305: LD_INT 2
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 3
75314: PUSH
75315: LD_INT 3
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 2
75324: PUSH
75325: LD_INT 3
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: LIST
75336: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75337: LD_ADDR_VAR 0 14
75341: PUSH
75342: LD_INT 1
75344: PUSH
75345: LD_INT 3
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 0
75354: PUSH
75355: LD_INT 3
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 1
75364: NEG
75365: PUSH
75366: LD_INT 2
75368: PUSH
75369: EMPTY
75370: LIST
75371: LIST
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: LIST
75377: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75378: LD_ADDR_VAR 0 15
75382: PUSH
75383: LD_INT 2
75385: NEG
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 3
75396: NEG
75397: PUSH
75398: LD_INT 0
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PUSH
75405: LD_INT 3
75407: NEG
75408: PUSH
75409: LD_INT 1
75411: NEG
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: LIST
75421: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75422: LD_ADDR_VAR 0 16
75426: PUSH
75427: LD_INT 2
75429: NEG
75430: PUSH
75431: LD_INT 3
75433: NEG
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 3
75441: NEG
75442: PUSH
75443: LD_INT 2
75445: NEG
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 3
75453: NEG
75454: PUSH
75455: LD_INT 3
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: LIST
75467: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75468: LD_ADDR_VAR 0 17
75472: PUSH
75473: LD_INT 1
75475: NEG
75476: PUSH
75477: LD_INT 3
75479: NEG
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: LD_INT 0
75487: PUSH
75488: LD_INT 3
75490: NEG
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 1
75498: PUSH
75499: LD_INT 2
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: LIST
75511: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75512: LD_ADDR_VAR 0 18
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: LD_INT 1
75522: NEG
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 3
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 3
75540: PUSH
75541: LD_INT 1
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: LIST
75552: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75553: LD_ADDR_VAR 0 19
75557: PUSH
75558: LD_INT 3
75560: PUSH
75561: LD_INT 2
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 3
75570: PUSH
75571: LD_INT 3
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 2
75580: PUSH
75581: LD_INT 3
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: LIST
75592: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75593: LD_ADDR_VAR 0 20
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: LD_INT 3
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: LD_INT 3
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: NEG
75621: PUSH
75622: LD_INT 2
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: LIST
75633: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75634: LD_ADDR_VAR 0 21
75638: PUSH
75639: LD_INT 2
75641: NEG
75642: PUSH
75643: LD_INT 1
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: PUSH
75650: LD_INT 3
75652: NEG
75653: PUSH
75654: LD_INT 0
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 3
75663: NEG
75664: PUSH
75665: LD_INT 1
75667: NEG
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: LIST
75677: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75678: LD_ADDR_VAR 0 22
75682: PUSH
75683: LD_INT 2
75685: NEG
75686: PUSH
75687: LD_INT 3
75689: NEG
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 3
75697: NEG
75698: PUSH
75699: LD_INT 2
75701: NEG
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 3
75709: NEG
75710: PUSH
75711: LD_INT 3
75713: NEG
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: LIST
75723: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75724: LD_ADDR_VAR 0 23
75728: PUSH
75729: LD_INT 0
75731: PUSH
75732: LD_INT 3
75734: NEG
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 1
75742: NEG
75743: PUSH
75744: LD_INT 4
75746: NEG
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: PUSH
75755: LD_INT 3
75757: NEG
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: LIST
75767: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75768: LD_ADDR_VAR 0 24
75772: PUSH
75773: LD_INT 3
75775: PUSH
75776: LD_INT 0
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 3
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 4
75796: PUSH
75797: LD_INT 1
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: LIST
75808: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75809: LD_ADDR_VAR 0 25
75813: PUSH
75814: LD_INT 3
75816: PUSH
75817: LD_INT 3
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 4
75826: PUSH
75827: LD_INT 3
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 3
75836: PUSH
75837: LD_INT 4
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: LIST
75848: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75849: LD_ADDR_VAR 0 26
75853: PUSH
75854: LD_INT 0
75856: PUSH
75857: LD_INT 3
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: PUSH
75864: LD_INT 1
75866: PUSH
75867: LD_INT 4
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 1
75876: NEG
75877: PUSH
75878: LD_INT 3
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: LIST
75889: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75890: LD_ADDR_VAR 0 27
75894: PUSH
75895: LD_INT 3
75897: NEG
75898: PUSH
75899: LD_INT 0
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 3
75908: NEG
75909: PUSH
75910: LD_INT 1
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: LD_INT 4
75919: NEG
75920: PUSH
75921: LD_INT 1
75923: NEG
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: LIST
75933: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75934: LD_ADDR_VAR 0 28
75938: PUSH
75939: LD_INT 3
75941: NEG
75942: PUSH
75943: LD_INT 3
75945: NEG
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: PUSH
75951: LD_INT 3
75953: NEG
75954: PUSH
75955: LD_INT 4
75957: NEG
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 4
75965: NEG
75966: PUSH
75967: LD_INT 3
75969: NEG
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: LIST
75979: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75980: LD_ADDR_VAR 0 29
75984: PUSH
75985: LD_INT 1
75987: NEG
75988: PUSH
75989: LD_INT 3
75991: NEG
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 0
75999: PUSH
76000: LD_INT 3
76002: NEG
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 1
76010: PUSH
76011: LD_INT 2
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 1
76021: NEG
76022: PUSH
76023: LD_INT 4
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 0
76033: PUSH
76034: LD_INT 4
76036: NEG
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 1
76044: PUSH
76045: LD_INT 3
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 1
76055: NEG
76056: PUSH
76057: LD_INT 5
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 0
76067: PUSH
76068: LD_INT 5
76070: NEG
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: LD_INT 4
76081: NEG
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 1
76089: NEG
76090: PUSH
76091: LD_INT 6
76093: NEG
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: LD_INT 6
76104: NEG
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 1
76112: PUSH
76113: LD_INT 5
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76135: LD_ADDR_VAR 0 30
76139: PUSH
76140: LD_INT 2
76142: PUSH
76143: LD_INT 1
76145: NEG
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 3
76153: PUSH
76154: LD_INT 0
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 3
76163: PUSH
76164: LD_INT 1
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 3
76173: PUSH
76174: LD_INT 1
76176: NEG
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 4
76184: PUSH
76185: LD_INT 0
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 4
76194: PUSH
76195: LD_INT 1
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 4
76204: PUSH
76205: LD_INT 1
76207: NEG
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 5
76215: PUSH
76216: LD_INT 0
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: PUSH
76223: LD_INT 5
76225: PUSH
76226: LD_INT 1
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 5
76235: PUSH
76236: LD_INT 1
76238: NEG
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 6
76246: PUSH
76247: LD_INT 0
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: LD_INT 6
76256: PUSH
76257: LD_INT 1
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: LIST
76270: LIST
76271: LIST
76272: LIST
76273: LIST
76274: LIST
76275: LIST
76276: LIST
76277: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76278: LD_ADDR_VAR 0 31
76282: PUSH
76283: LD_INT 3
76285: PUSH
76286: LD_INT 2
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 3
76295: PUSH
76296: LD_INT 3
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 2
76305: PUSH
76306: LD_INT 3
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 4
76315: PUSH
76316: LD_INT 3
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: LD_INT 4
76325: PUSH
76326: LD_INT 4
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 3
76335: PUSH
76336: LD_INT 4
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 5
76345: PUSH
76346: LD_INT 4
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 5
76355: PUSH
76356: LD_INT 5
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 4
76365: PUSH
76366: LD_INT 5
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 6
76375: PUSH
76376: LD_INT 5
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 6
76385: PUSH
76386: LD_INT 6
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 5
76395: PUSH
76396: LD_INT 6
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: LIST
76414: LIST
76415: LIST
76416: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76417: LD_ADDR_VAR 0 32
76421: PUSH
76422: LD_INT 1
76424: PUSH
76425: LD_INT 3
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: LD_INT 0
76434: PUSH
76435: LD_INT 3
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 1
76444: NEG
76445: PUSH
76446: LD_INT 2
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: LD_INT 4
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 0
76465: PUSH
76466: LD_INT 4
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 1
76475: NEG
76476: PUSH
76477: LD_INT 3
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: LD_INT 1
76486: PUSH
76487: LD_INT 5
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 0
76496: PUSH
76497: LD_INT 5
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 1
76506: NEG
76507: PUSH
76508: LD_INT 4
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 1
76517: PUSH
76518: LD_INT 6
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: PUSH
76525: LD_INT 0
76527: PUSH
76528: LD_INT 6
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: LD_INT 1
76537: NEG
76538: PUSH
76539: LD_INT 5
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76560: LD_ADDR_VAR 0 33
76564: PUSH
76565: LD_INT 2
76567: NEG
76568: PUSH
76569: LD_INT 1
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 3
76578: NEG
76579: PUSH
76580: LD_INT 0
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PUSH
76587: LD_INT 3
76589: NEG
76590: PUSH
76591: LD_INT 1
76593: NEG
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 3
76601: NEG
76602: PUSH
76603: LD_INT 1
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 4
76612: NEG
76613: PUSH
76614: LD_INT 0
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 4
76623: NEG
76624: PUSH
76625: LD_INT 1
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 4
76635: NEG
76636: PUSH
76637: LD_INT 1
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 5
76646: NEG
76647: PUSH
76648: LD_INT 0
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 5
76657: NEG
76658: PUSH
76659: LD_INT 1
76661: NEG
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 5
76669: NEG
76670: PUSH
76671: LD_INT 1
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: PUSH
76678: LD_INT 6
76680: NEG
76681: PUSH
76682: LD_INT 0
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: PUSH
76689: LD_INT 6
76691: NEG
76692: PUSH
76693: LD_INT 1
76695: NEG
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76715: LD_ADDR_VAR 0 34
76719: PUSH
76720: LD_INT 2
76722: NEG
76723: PUSH
76724: LD_INT 3
76726: NEG
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 3
76734: NEG
76735: PUSH
76736: LD_INT 2
76738: NEG
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 3
76746: NEG
76747: PUSH
76748: LD_INT 3
76750: NEG
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 3
76758: NEG
76759: PUSH
76760: LD_INT 4
76762: NEG
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 4
76770: NEG
76771: PUSH
76772: LD_INT 3
76774: NEG
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 4
76782: NEG
76783: PUSH
76784: LD_INT 4
76786: NEG
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 4
76794: NEG
76795: PUSH
76796: LD_INT 5
76798: NEG
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 5
76806: NEG
76807: PUSH
76808: LD_INT 4
76810: NEG
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 5
76818: NEG
76819: PUSH
76820: LD_INT 5
76822: NEG
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 5
76830: NEG
76831: PUSH
76832: LD_INT 6
76834: NEG
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 6
76842: NEG
76843: PUSH
76844: LD_INT 5
76846: NEG
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 6
76854: NEG
76855: PUSH
76856: LD_INT 6
76858: NEG
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: LIST
76870: LIST
76871: LIST
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76878: LD_ADDR_VAR 0 41
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: LD_INT 2
76888: NEG
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 1
76896: NEG
76897: PUSH
76898: LD_INT 3
76900: NEG
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 1
76908: PUSH
76909: LD_INT 2
76911: NEG
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: LIST
76921: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76922: LD_ADDR_VAR 0 42
76926: PUSH
76927: LD_INT 2
76929: PUSH
76930: LD_INT 0
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 2
76939: PUSH
76940: LD_INT 1
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 3
76950: PUSH
76951: LD_INT 1
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: LIST
76962: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76963: LD_ADDR_VAR 0 43
76967: PUSH
76968: LD_INT 2
76970: PUSH
76971: LD_INT 2
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 3
76980: PUSH
76981: LD_INT 2
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 2
76990: PUSH
76991: LD_INT 3
76993: PUSH
76994: EMPTY
76995: LIST
76996: LIST
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: LIST
77002: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77003: LD_ADDR_VAR 0 44
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: LD_INT 2
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 1
77020: PUSH
77021: LD_INT 3
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 1
77030: NEG
77031: PUSH
77032: LD_INT 2
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: LIST
77043: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77044: LD_ADDR_VAR 0 45
77048: PUSH
77049: LD_INT 2
77051: NEG
77052: PUSH
77053: LD_INT 0
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 2
77062: NEG
77063: PUSH
77064: LD_INT 1
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 3
77073: NEG
77074: PUSH
77075: LD_INT 1
77077: NEG
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: LIST
77087: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77088: LD_ADDR_VAR 0 46
77092: PUSH
77093: LD_INT 2
77095: NEG
77096: PUSH
77097: LD_INT 2
77099: NEG
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 2
77107: NEG
77108: PUSH
77109: LD_INT 3
77111: NEG
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 3
77119: NEG
77120: PUSH
77121: LD_INT 2
77123: NEG
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: LIST
77133: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77134: LD_ADDR_VAR 0 47
77138: PUSH
77139: LD_INT 2
77141: NEG
77142: PUSH
77143: LD_INT 3
77145: NEG
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 1
77153: NEG
77154: PUSH
77155: LD_INT 3
77157: NEG
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77167: LD_ADDR_VAR 0 48
77171: PUSH
77172: LD_INT 1
77174: PUSH
77175: LD_INT 2
77177: NEG
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 2
77185: PUSH
77186: LD_INT 1
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77198: LD_ADDR_VAR 0 49
77202: PUSH
77203: LD_INT 3
77205: PUSH
77206: LD_INT 1
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 3
77215: PUSH
77216: LD_INT 2
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77227: LD_ADDR_VAR 0 50
77231: PUSH
77232: LD_INT 2
77234: PUSH
77235: LD_INT 3
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 1
77244: PUSH
77245: LD_INT 3
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77256: LD_ADDR_VAR 0 51
77260: PUSH
77261: LD_INT 1
77263: NEG
77264: PUSH
77265: LD_INT 2
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 2
77274: NEG
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77287: LD_ADDR_VAR 0 52
77291: PUSH
77292: LD_INT 3
77294: NEG
77295: PUSH
77296: LD_INT 1
77298: NEG
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 3
77306: NEG
77307: PUSH
77308: LD_INT 2
77310: NEG
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77320: LD_ADDR_VAR 0 53
77324: PUSH
77325: LD_INT 1
77327: NEG
77328: PUSH
77329: LD_INT 3
77331: NEG
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 0
77339: PUSH
77340: LD_INT 3
77342: NEG
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 1
77350: PUSH
77351: LD_INT 2
77353: NEG
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: LIST
77363: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77364: LD_ADDR_VAR 0 54
77368: PUSH
77369: LD_INT 2
77371: PUSH
77372: LD_INT 1
77374: NEG
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 3
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 3
77392: PUSH
77393: LD_INT 1
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: LIST
77404: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77405: LD_ADDR_VAR 0 55
77409: PUSH
77410: LD_INT 3
77412: PUSH
77413: LD_INT 2
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 3
77422: PUSH
77423: LD_INT 3
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 2
77432: PUSH
77433: LD_INT 3
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: LIST
77444: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77445: LD_ADDR_VAR 0 56
77449: PUSH
77450: LD_INT 1
77452: PUSH
77453: LD_INT 3
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 0
77462: PUSH
77463: LD_INT 3
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: NEG
77473: PUSH
77474: LD_INT 2
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: LIST
77485: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77486: LD_ADDR_VAR 0 57
77490: PUSH
77491: LD_INT 2
77493: NEG
77494: PUSH
77495: LD_INT 1
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 3
77504: NEG
77505: PUSH
77506: LD_INT 0
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 3
77515: NEG
77516: PUSH
77517: LD_INT 1
77519: NEG
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: LIST
77529: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77530: LD_ADDR_VAR 0 58
77534: PUSH
77535: LD_INT 2
77537: NEG
77538: PUSH
77539: LD_INT 3
77541: NEG
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 3
77549: NEG
77550: PUSH
77551: LD_INT 2
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 3
77561: NEG
77562: PUSH
77563: LD_INT 3
77565: NEG
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: LIST
77575: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77576: LD_ADDR_VAR 0 59
77580: PUSH
77581: LD_INT 1
77583: NEG
77584: PUSH
77585: LD_INT 2
77587: NEG
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 0
77595: PUSH
77596: LD_INT 2
77598: NEG
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 1
77606: PUSH
77607: LD_INT 1
77609: NEG
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: LIST
77619: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77620: LD_ADDR_VAR 0 60
77624: PUSH
77625: LD_INT 1
77627: PUSH
77628: LD_INT 1
77630: NEG
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: LD_INT 1
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: LIST
77660: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77661: LD_ADDR_VAR 0 61
77665: PUSH
77666: LD_INT 2
77668: PUSH
77669: LD_INT 1
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 2
77678: PUSH
77679: LD_INT 2
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 1
77688: PUSH
77689: LD_INT 2
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: LIST
77700: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77701: LD_ADDR_VAR 0 62
77705: PUSH
77706: LD_INT 1
77708: PUSH
77709: LD_INT 2
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 0
77718: PUSH
77719: LD_INT 2
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 1
77728: NEG
77729: PUSH
77730: LD_INT 1
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: LIST
77741: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77742: LD_ADDR_VAR 0 63
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: LD_INT 1
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 2
77760: NEG
77761: PUSH
77762: LD_INT 0
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 2
77771: NEG
77772: PUSH
77773: LD_INT 1
77775: NEG
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: LIST
77785: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77786: LD_ADDR_VAR 0 64
77790: PUSH
77791: LD_INT 1
77793: NEG
77794: PUSH
77795: LD_INT 2
77797: NEG
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: PUSH
77803: LD_INT 2
77805: NEG
77806: PUSH
77807: LD_INT 1
77809: NEG
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: LD_INT 2
77817: NEG
77818: PUSH
77819: LD_INT 2
77821: NEG
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: LIST
77831: ST_TO_ADDR
// end ; 2 :
77832: GO 81098
77834: LD_INT 2
77836: DOUBLE
77837: EQUAL
77838: IFTRUE 77842
77840: GO 81097
77842: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77843: LD_ADDR_VAR 0 29
77847: PUSH
77848: LD_INT 4
77850: PUSH
77851: LD_INT 0
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 4
77860: PUSH
77861: LD_INT 1
77863: NEG
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 5
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 5
77881: PUSH
77882: LD_INT 1
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 4
77891: PUSH
77892: LD_INT 1
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 3
77901: PUSH
77902: LD_INT 0
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 3
77911: PUSH
77912: LD_INT 1
77914: NEG
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 3
77922: PUSH
77923: LD_INT 2
77925: NEG
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 5
77933: PUSH
77934: LD_INT 2
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 3
77943: PUSH
77944: LD_INT 3
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 3
77953: PUSH
77954: LD_INT 2
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 4
77963: PUSH
77964: LD_INT 3
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 4
77973: PUSH
77974: LD_INT 4
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 3
77983: PUSH
77984: LD_INT 4
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 2
77993: PUSH
77994: LD_INT 3
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 2
78003: PUSH
78004: LD_INT 2
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 4
78013: PUSH
78014: LD_INT 2
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 2
78023: PUSH
78024: LD_INT 4
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 0
78033: PUSH
78034: LD_INT 4
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 0
78043: PUSH
78044: LD_INT 3
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 1
78053: PUSH
78054: LD_INT 4
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 1
78063: PUSH
78064: LD_INT 5
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 0
78073: PUSH
78074: LD_INT 5
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 1
78083: NEG
78084: PUSH
78085: LD_INT 4
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 1
78094: NEG
78095: PUSH
78096: LD_INT 3
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 2
78105: PUSH
78106: LD_INT 5
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 2
78115: NEG
78116: PUSH
78117: LD_INT 3
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 3
78126: NEG
78127: PUSH
78128: LD_INT 0
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 3
78137: NEG
78138: PUSH
78139: LD_INT 1
78141: NEG
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 2
78149: NEG
78150: PUSH
78151: LD_INT 0
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 2
78160: NEG
78161: PUSH
78162: LD_INT 1
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 3
78171: NEG
78172: PUSH
78173: LD_INT 1
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 4
78182: NEG
78183: PUSH
78184: LD_INT 0
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: LD_INT 4
78193: NEG
78194: PUSH
78195: LD_INT 1
78197: NEG
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 4
78205: NEG
78206: PUSH
78207: LD_INT 2
78209: NEG
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 2
78217: NEG
78218: PUSH
78219: LD_INT 2
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 4
78228: NEG
78229: PUSH
78230: LD_INT 4
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 4
78240: NEG
78241: PUSH
78242: LD_INT 5
78244: NEG
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 3
78252: NEG
78253: PUSH
78254: LD_INT 4
78256: NEG
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 3
78264: NEG
78265: PUSH
78266: LD_INT 3
78268: NEG
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 4
78276: NEG
78277: PUSH
78278: LD_INT 3
78280: NEG
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 5
78288: NEG
78289: PUSH
78290: LD_INT 4
78292: NEG
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 5
78300: NEG
78301: PUSH
78302: LD_INT 5
78304: NEG
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 3
78312: NEG
78313: PUSH
78314: LD_INT 5
78316: NEG
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 5
78324: NEG
78325: PUSH
78326: LD_INT 3
78328: NEG
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: LIST
78338: LIST
78339: LIST
78340: LIST
78341: LIST
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78381: LD_ADDR_VAR 0 30
78385: PUSH
78386: LD_INT 4
78388: PUSH
78389: LD_INT 4
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 4
78398: PUSH
78399: LD_INT 3
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 5
78408: PUSH
78409: LD_INT 4
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 5
78418: PUSH
78419: LD_INT 5
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 4
78428: PUSH
78429: LD_INT 5
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 3
78438: PUSH
78439: LD_INT 4
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 3
78448: PUSH
78449: LD_INT 3
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 5
78458: PUSH
78459: LD_INT 3
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 3
78468: PUSH
78469: LD_INT 5
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 3
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: PUSH
78499: LD_INT 3
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 1
78508: PUSH
78509: LD_INT 4
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 0
78518: PUSH
78519: LD_INT 4
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 1
78528: NEG
78529: PUSH
78530: LD_INT 3
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 1
78539: NEG
78540: PUSH
78541: LD_INT 2
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PUSH
78548: LD_INT 2
78550: PUSH
78551: LD_INT 4
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 2
78560: NEG
78561: PUSH
78562: LD_INT 2
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 4
78571: NEG
78572: PUSH
78573: LD_INT 0
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 4
78582: NEG
78583: PUSH
78584: LD_INT 1
78586: NEG
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 3
78594: NEG
78595: PUSH
78596: LD_INT 0
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 3
78605: NEG
78606: PUSH
78607: LD_INT 1
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: PUSH
78614: LD_INT 4
78616: NEG
78617: PUSH
78618: LD_INT 1
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 5
78627: NEG
78628: PUSH
78629: LD_INT 0
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 5
78638: NEG
78639: PUSH
78640: LD_INT 1
78642: NEG
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 5
78650: NEG
78651: PUSH
78652: LD_INT 2
78654: NEG
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: PUSH
78660: LD_INT 3
78662: NEG
78663: PUSH
78664: LD_INT 2
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 3
78673: NEG
78674: PUSH
78675: LD_INT 3
78677: NEG
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: LD_INT 3
78685: NEG
78686: PUSH
78687: LD_INT 4
78689: NEG
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: PUSH
78695: LD_INT 2
78697: NEG
78698: PUSH
78699: LD_INT 3
78701: NEG
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 2
78709: NEG
78710: PUSH
78711: LD_INT 2
78713: NEG
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 3
78721: NEG
78722: PUSH
78723: LD_INT 2
78725: NEG
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 4
78733: NEG
78734: PUSH
78735: LD_INT 3
78737: NEG
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 4
78745: NEG
78746: PUSH
78747: LD_INT 4
78749: NEG
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: LD_INT 2
78757: NEG
78758: PUSH
78759: LD_INT 4
78761: NEG
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 4
78769: NEG
78770: PUSH
78771: LD_INT 2
78773: NEG
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 0
78781: PUSH
78782: LD_INT 4
78784: NEG
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: LD_INT 0
78792: PUSH
78793: LD_INT 5
78795: NEG
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: PUSH
78801: LD_INT 1
78803: PUSH
78804: LD_INT 4
78806: NEG
78807: PUSH
78808: EMPTY
78809: LIST
78810: LIST
78811: PUSH
78812: LD_INT 1
78814: PUSH
78815: LD_INT 3
78817: NEG
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 0
78825: PUSH
78826: LD_INT 3
78828: NEG
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 1
78836: NEG
78837: PUSH
78838: LD_INT 4
78840: NEG
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 1
78848: NEG
78849: PUSH
78850: LD_INT 5
78852: NEG
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 2
78860: PUSH
78861: LD_INT 3
78863: NEG
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 2
78871: NEG
78872: PUSH
78873: LD_INT 5
78875: NEG
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: LIST
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78928: LD_ADDR_VAR 0 31
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: LD_INT 4
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 0
78945: PUSH
78946: LD_INT 3
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 1
78955: PUSH
78956: LD_INT 4
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 1
78965: PUSH
78966: LD_INT 5
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 0
78975: PUSH
78976: LD_INT 5
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 1
78985: NEG
78986: PUSH
78987: LD_INT 4
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 1
78996: NEG
78997: PUSH
78998: LD_INT 3
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 2
79007: PUSH
79008: LD_INT 5
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: LD_INT 2
79017: NEG
79018: PUSH
79019: LD_INT 3
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 3
79028: NEG
79029: PUSH
79030: LD_INT 0
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 3
79039: NEG
79040: PUSH
79041: LD_INT 1
79043: NEG
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 2
79051: NEG
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 2
79062: NEG
79063: PUSH
79064: LD_INT 1
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: LD_INT 3
79073: NEG
79074: PUSH
79075: LD_INT 1
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 4
79084: NEG
79085: PUSH
79086: LD_INT 0
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 4
79095: NEG
79096: PUSH
79097: LD_INT 1
79099: NEG
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 4
79107: NEG
79108: PUSH
79109: LD_INT 2
79111: NEG
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 2
79119: NEG
79120: PUSH
79121: LD_INT 2
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 4
79130: NEG
79131: PUSH
79132: LD_INT 4
79134: NEG
79135: PUSH
79136: EMPTY
79137: LIST
79138: LIST
79139: PUSH
79140: LD_INT 4
79142: NEG
79143: PUSH
79144: LD_INT 5
79146: NEG
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 3
79154: NEG
79155: PUSH
79156: LD_INT 4
79158: NEG
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 3
79166: NEG
79167: PUSH
79168: LD_INT 3
79170: NEG
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 4
79178: NEG
79179: PUSH
79180: LD_INT 3
79182: NEG
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 5
79190: NEG
79191: PUSH
79192: LD_INT 4
79194: NEG
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PUSH
79200: LD_INT 5
79202: NEG
79203: PUSH
79204: LD_INT 5
79206: NEG
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 3
79214: NEG
79215: PUSH
79216: LD_INT 5
79218: NEG
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: LD_INT 5
79226: NEG
79227: PUSH
79228: LD_INT 3
79230: NEG
79231: PUSH
79232: EMPTY
79233: LIST
79234: LIST
79235: PUSH
79236: LD_INT 0
79238: PUSH
79239: LD_INT 3
79241: NEG
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: LD_INT 4
79252: NEG
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 1
79260: PUSH
79261: LD_INT 3
79263: NEG
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 1
79271: PUSH
79272: LD_INT 2
79274: NEG
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 0
79282: PUSH
79283: LD_INT 2
79285: NEG
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 1
79293: NEG
79294: PUSH
79295: LD_INT 3
79297: NEG
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 1
79305: NEG
79306: PUSH
79307: LD_INT 4
79309: NEG
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: LD_INT 2
79317: PUSH
79318: LD_INT 2
79320: NEG
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 2
79328: NEG
79329: PUSH
79330: LD_INT 4
79332: NEG
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 4
79340: PUSH
79341: LD_INT 0
79343: PUSH
79344: EMPTY
79345: LIST
79346: LIST
79347: PUSH
79348: LD_INT 4
79350: PUSH
79351: LD_INT 1
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 5
79361: PUSH
79362: LD_INT 0
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 5
79371: PUSH
79372: LD_INT 1
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 4
79381: PUSH
79382: LD_INT 1
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: LD_INT 3
79391: PUSH
79392: LD_INT 0
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 3
79401: PUSH
79402: LD_INT 1
79404: NEG
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: PUSH
79410: LD_INT 3
79412: PUSH
79413: LD_INT 2
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: LD_INT 5
79423: PUSH
79424: LD_INT 2
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: LIST
79465: LIST
79466: LIST
79467: LIST
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79478: LD_ADDR_VAR 0 32
79482: PUSH
79483: LD_INT 4
79485: NEG
79486: PUSH
79487: LD_INT 0
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 4
79496: NEG
79497: PUSH
79498: LD_INT 1
79500: NEG
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 3
79508: NEG
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 3
79519: NEG
79520: PUSH
79521: LD_INT 1
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 4
79530: NEG
79531: PUSH
79532: LD_INT 1
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 5
79541: NEG
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 5
79552: NEG
79553: PUSH
79554: LD_INT 1
79556: NEG
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 5
79564: NEG
79565: PUSH
79566: LD_INT 2
79568: NEG
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 3
79576: NEG
79577: PUSH
79578: LD_INT 2
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 3
79587: NEG
79588: PUSH
79589: LD_INT 3
79591: NEG
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 3
79599: NEG
79600: PUSH
79601: LD_INT 4
79603: NEG
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 2
79611: NEG
79612: PUSH
79613: LD_INT 3
79615: NEG
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: LD_INT 2
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 3
79635: NEG
79636: PUSH
79637: LD_INT 2
79639: NEG
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 4
79647: NEG
79648: PUSH
79649: LD_INT 3
79651: NEG
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 4
79659: NEG
79660: PUSH
79661: LD_INT 4
79663: NEG
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 2
79671: NEG
79672: PUSH
79673: LD_INT 4
79675: NEG
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 4
79683: NEG
79684: PUSH
79685: LD_INT 2
79687: NEG
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: LD_INT 0
79695: PUSH
79696: LD_INT 4
79698: NEG
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 0
79706: PUSH
79707: LD_INT 5
79709: NEG
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: LD_INT 1
79717: PUSH
79718: LD_INT 4
79720: NEG
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 1
79728: PUSH
79729: LD_INT 3
79731: NEG
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 0
79739: PUSH
79740: LD_INT 3
79742: NEG
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 1
79750: NEG
79751: PUSH
79752: LD_INT 4
79754: NEG
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 1
79762: NEG
79763: PUSH
79764: LD_INT 5
79766: NEG
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 2
79774: PUSH
79775: LD_INT 3
79777: NEG
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: PUSH
79783: LD_INT 2
79785: NEG
79786: PUSH
79787: LD_INT 5
79789: NEG
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 3
79797: PUSH
79798: LD_INT 0
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 3
79807: PUSH
79808: LD_INT 1
79810: NEG
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 4
79818: PUSH
79819: LD_INT 0
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 4
79828: PUSH
79829: LD_INT 1
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 3
79838: PUSH
79839: LD_INT 1
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 2
79848: PUSH
79849: LD_INT 0
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 2
79858: PUSH
79859: LD_INT 1
79861: NEG
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 2
79869: PUSH
79870: LD_INT 2
79872: NEG
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 4
79880: PUSH
79881: LD_INT 2
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 4
79890: PUSH
79891: LD_INT 4
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 4
79900: PUSH
79901: LD_INT 3
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 5
79910: PUSH
79911: LD_INT 4
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 5
79920: PUSH
79921: LD_INT 5
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 4
79930: PUSH
79931: LD_INT 5
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 3
79940: PUSH
79941: LD_INT 4
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 3
79950: PUSH
79951: LD_INT 3
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: LD_INT 5
79960: PUSH
79961: LD_INT 3
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 3
79970: PUSH
79971: LD_INT 5
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80025: LD_ADDR_VAR 0 33
80029: PUSH
80030: LD_INT 4
80032: NEG
80033: PUSH
80034: LD_INT 4
80036: NEG
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 4
80044: NEG
80045: PUSH
80046: LD_INT 5
80048: NEG
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 3
80056: NEG
80057: PUSH
80058: LD_INT 4
80060: NEG
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 3
80068: NEG
80069: PUSH
80070: LD_INT 3
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 4
80080: NEG
80081: PUSH
80082: LD_INT 3
80084: NEG
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 5
80092: NEG
80093: PUSH
80094: LD_INT 4
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 5
80104: NEG
80105: PUSH
80106: LD_INT 5
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 3
80116: NEG
80117: PUSH
80118: LD_INT 5
80120: NEG
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 5
80128: NEG
80129: PUSH
80130: LD_INT 3
80132: NEG
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 0
80140: PUSH
80141: LD_INT 3
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: LD_INT 4
80154: NEG
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 1
80162: PUSH
80163: LD_INT 3
80165: NEG
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 1
80173: PUSH
80174: LD_INT 2
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 0
80184: PUSH
80185: LD_INT 2
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 1
80195: NEG
80196: PUSH
80197: LD_INT 3
80199: NEG
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: LD_INT 4
80211: NEG
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 2
80219: PUSH
80220: LD_INT 2
80222: NEG
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 2
80230: NEG
80231: PUSH
80232: LD_INT 4
80234: NEG
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 4
80242: PUSH
80243: LD_INT 0
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 4
80252: PUSH
80253: LD_INT 1
80255: NEG
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 5
80263: PUSH
80264: LD_INT 0
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 5
80273: PUSH
80274: LD_INT 1
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 4
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 3
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 3
80303: PUSH
80304: LD_INT 1
80306: NEG
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 3
80314: PUSH
80315: LD_INT 2
80317: NEG
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 5
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 3
80335: PUSH
80336: LD_INT 3
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 3
80345: PUSH
80346: LD_INT 2
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 4
80355: PUSH
80356: LD_INT 3
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 4
80365: PUSH
80366: LD_INT 4
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: LD_INT 3
80375: PUSH
80376: LD_INT 4
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: LD_INT 2
80385: PUSH
80386: LD_INT 3
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 2
80395: PUSH
80396: LD_INT 2
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 4
80405: PUSH
80406: LD_INT 2
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 2
80415: PUSH
80416: LD_INT 4
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 0
80425: PUSH
80426: LD_INT 4
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 0
80435: PUSH
80436: LD_INT 3
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 1
80445: PUSH
80446: LD_INT 4
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 1
80455: PUSH
80456: LD_INT 5
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 0
80465: PUSH
80466: LD_INT 5
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 1
80475: NEG
80476: PUSH
80477: LD_INT 4
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 1
80486: NEG
80487: PUSH
80488: LD_INT 3
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 2
80497: PUSH
80498: LD_INT 5
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 2
80507: NEG
80508: PUSH
80509: LD_INT 3
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80563: LD_ADDR_VAR 0 34
80567: PUSH
80568: LD_INT 0
80570: PUSH
80571: LD_INT 4
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 0
80581: PUSH
80582: LD_INT 5
80584: NEG
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 1
80592: PUSH
80593: LD_INT 4
80595: NEG
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: PUSH
80604: LD_INT 3
80606: NEG
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: LD_INT 3
80617: NEG
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 1
80625: NEG
80626: PUSH
80627: LD_INT 4
80629: NEG
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 5
80641: NEG
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 2
80649: PUSH
80650: LD_INT 3
80652: NEG
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 2
80660: NEG
80661: PUSH
80662: LD_INT 5
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 3
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 3
80682: PUSH
80683: LD_INT 1
80685: NEG
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 4
80693: PUSH
80694: LD_INT 0
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 4
80703: PUSH
80704: LD_INT 1
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 3
80713: PUSH
80714: LD_INT 1
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 2
80723: PUSH
80724: LD_INT 0
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 2
80733: PUSH
80734: LD_INT 1
80736: NEG
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 2
80744: PUSH
80745: LD_INT 2
80747: NEG
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 4
80755: PUSH
80756: LD_INT 2
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 4
80765: PUSH
80766: LD_INT 4
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 4
80775: PUSH
80776: LD_INT 3
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 5
80785: PUSH
80786: LD_INT 4
80788: PUSH
80789: EMPTY
80790: LIST
80791: LIST
80792: PUSH
80793: LD_INT 5
80795: PUSH
80796: LD_INT 5
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 4
80805: PUSH
80806: LD_INT 5
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PUSH
80813: LD_INT 3
80815: PUSH
80816: LD_INT 4
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 3
80825: PUSH
80826: LD_INT 3
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: PUSH
80833: LD_INT 5
80835: PUSH
80836: LD_INT 3
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 3
80845: PUSH
80846: LD_INT 5
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 0
80855: PUSH
80856: LD_INT 3
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: LD_INT 2
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: LD_INT 3
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 1
80885: PUSH
80886: LD_INT 4
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 0
80895: PUSH
80896: LD_INT 4
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: LD_INT 3
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 2
80927: PUSH
80928: LD_INT 4
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 2
80937: NEG
80938: PUSH
80939: LD_INT 2
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 4
80948: NEG
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 4
80959: NEG
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 3
80971: NEG
80972: PUSH
80973: LD_INT 0
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 3
80982: NEG
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 4
80993: NEG
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 5
81004: NEG
81005: PUSH
81006: LD_INT 0
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 5
81015: NEG
81016: PUSH
81017: LD_INT 1
81019: NEG
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 5
81027: NEG
81028: PUSH
81029: LD_INT 2
81031: NEG
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 3
81039: NEG
81040: PUSH
81041: LD_INT 2
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: ST_TO_ADDR
// end ; end ;
81095: GO 81098
81097: POP
// case btype of b_depot , b_warehouse :
81098: LD_VAR 0 1
81102: PUSH
81103: LD_INT 0
81105: DOUBLE
81106: EQUAL
81107: IFTRUE 81117
81109: LD_INT 1
81111: DOUBLE
81112: EQUAL
81113: IFTRUE 81117
81115: GO 81318
81117: POP
// case nation of nation_american :
81118: LD_VAR 0 5
81122: PUSH
81123: LD_INT 1
81125: DOUBLE
81126: EQUAL
81127: IFTRUE 81131
81129: GO 81187
81131: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81132: LD_ADDR_VAR 0 9
81136: PUSH
81137: LD_VAR 0 11
81141: PUSH
81142: LD_VAR 0 12
81146: PUSH
81147: LD_VAR 0 13
81151: PUSH
81152: LD_VAR 0 14
81156: PUSH
81157: LD_VAR 0 15
81161: PUSH
81162: LD_VAR 0 16
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: PUSH
81175: LD_VAR 0 4
81179: PUSH
81180: LD_INT 1
81182: PLUS
81183: ARRAY
81184: ST_TO_ADDR
81185: GO 81316
81187: LD_INT 2
81189: DOUBLE
81190: EQUAL
81191: IFTRUE 81195
81193: GO 81251
81195: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81196: LD_ADDR_VAR 0 9
81200: PUSH
81201: LD_VAR 0 17
81205: PUSH
81206: LD_VAR 0 18
81210: PUSH
81211: LD_VAR 0 19
81215: PUSH
81216: LD_VAR 0 20
81220: PUSH
81221: LD_VAR 0 21
81225: PUSH
81226: LD_VAR 0 22
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: PUSH
81239: LD_VAR 0 4
81243: PUSH
81244: LD_INT 1
81246: PLUS
81247: ARRAY
81248: ST_TO_ADDR
81249: GO 81316
81251: LD_INT 3
81253: DOUBLE
81254: EQUAL
81255: IFTRUE 81259
81257: GO 81315
81259: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81260: LD_ADDR_VAR 0 9
81264: PUSH
81265: LD_VAR 0 23
81269: PUSH
81270: LD_VAR 0 24
81274: PUSH
81275: LD_VAR 0 25
81279: PUSH
81280: LD_VAR 0 26
81284: PUSH
81285: LD_VAR 0 27
81289: PUSH
81290: LD_VAR 0 28
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: PUSH
81303: LD_VAR 0 4
81307: PUSH
81308: LD_INT 1
81310: PLUS
81311: ARRAY
81312: ST_TO_ADDR
81313: GO 81316
81315: POP
81316: GO 81871
81318: LD_INT 2
81320: DOUBLE
81321: EQUAL
81322: IFTRUE 81332
81324: LD_INT 3
81326: DOUBLE
81327: EQUAL
81328: IFTRUE 81332
81330: GO 81388
81332: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81333: LD_ADDR_VAR 0 9
81337: PUSH
81338: LD_VAR 0 29
81342: PUSH
81343: LD_VAR 0 30
81347: PUSH
81348: LD_VAR 0 31
81352: PUSH
81353: LD_VAR 0 32
81357: PUSH
81358: LD_VAR 0 33
81362: PUSH
81363: LD_VAR 0 34
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: PUSH
81376: LD_VAR 0 4
81380: PUSH
81381: LD_INT 1
81383: PLUS
81384: ARRAY
81385: ST_TO_ADDR
81386: GO 81871
81388: LD_INT 16
81390: DOUBLE
81391: EQUAL
81392: IFTRUE 81450
81394: LD_INT 17
81396: DOUBLE
81397: EQUAL
81398: IFTRUE 81450
81400: LD_INT 18
81402: DOUBLE
81403: EQUAL
81404: IFTRUE 81450
81406: LD_INT 19
81408: DOUBLE
81409: EQUAL
81410: IFTRUE 81450
81412: LD_INT 22
81414: DOUBLE
81415: EQUAL
81416: IFTRUE 81450
81418: LD_INT 20
81420: DOUBLE
81421: EQUAL
81422: IFTRUE 81450
81424: LD_INT 21
81426: DOUBLE
81427: EQUAL
81428: IFTRUE 81450
81430: LD_INT 23
81432: DOUBLE
81433: EQUAL
81434: IFTRUE 81450
81436: LD_INT 24
81438: DOUBLE
81439: EQUAL
81440: IFTRUE 81450
81442: LD_INT 25
81444: DOUBLE
81445: EQUAL
81446: IFTRUE 81450
81448: GO 81506
81450: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81451: LD_ADDR_VAR 0 9
81455: PUSH
81456: LD_VAR 0 35
81460: PUSH
81461: LD_VAR 0 36
81465: PUSH
81466: LD_VAR 0 37
81470: PUSH
81471: LD_VAR 0 38
81475: PUSH
81476: LD_VAR 0 39
81480: PUSH
81481: LD_VAR 0 40
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: PUSH
81494: LD_VAR 0 4
81498: PUSH
81499: LD_INT 1
81501: PLUS
81502: ARRAY
81503: ST_TO_ADDR
81504: GO 81871
81506: LD_INT 6
81508: DOUBLE
81509: EQUAL
81510: IFTRUE 81562
81512: LD_INT 7
81514: DOUBLE
81515: EQUAL
81516: IFTRUE 81562
81518: LD_INT 8
81520: DOUBLE
81521: EQUAL
81522: IFTRUE 81562
81524: LD_INT 13
81526: DOUBLE
81527: EQUAL
81528: IFTRUE 81562
81530: LD_INT 12
81532: DOUBLE
81533: EQUAL
81534: IFTRUE 81562
81536: LD_INT 15
81538: DOUBLE
81539: EQUAL
81540: IFTRUE 81562
81542: LD_INT 11
81544: DOUBLE
81545: EQUAL
81546: IFTRUE 81562
81548: LD_INT 14
81550: DOUBLE
81551: EQUAL
81552: IFTRUE 81562
81554: LD_INT 10
81556: DOUBLE
81557: EQUAL
81558: IFTRUE 81562
81560: GO 81618
81562: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81563: LD_ADDR_VAR 0 9
81567: PUSH
81568: LD_VAR 0 41
81572: PUSH
81573: LD_VAR 0 42
81577: PUSH
81578: LD_VAR 0 43
81582: PUSH
81583: LD_VAR 0 44
81587: PUSH
81588: LD_VAR 0 45
81592: PUSH
81593: LD_VAR 0 46
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: PUSH
81606: LD_VAR 0 4
81610: PUSH
81611: LD_INT 1
81613: PLUS
81614: ARRAY
81615: ST_TO_ADDR
81616: GO 81871
81618: LD_INT 36
81620: DOUBLE
81621: EQUAL
81622: IFTRUE 81626
81624: GO 81682
81626: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81627: LD_ADDR_VAR 0 9
81631: PUSH
81632: LD_VAR 0 47
81636: PUSH
81637: LD_VAR 0 48
81641: PUSH
81642: LD_VAR 0 49
81646: PUSH
81647: LD_VAR 0 50
81651: PUSH
81652: LD_VAR 0 51
81656: PUSH
81657: LD_VAR 0 52
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: PUSH
81670: LD_VAR 0 4
81674: PUSH
81675: LD_INT 1
81677: PLUS
81678: ARRAY
81679: ST_TO_ADDR
81680: GO 81871
81682: LD_INT 4
81684: DOUBLE
81685: EQUAL
81686: IFTRUE 81708
81688: LD_INT 5
81690: DOUBLE
81691: EQUAL
81692: IFTRUE 81708
81694: LD_INT 34
81696: DOUBLE
81697: EQUAL
81698: IFTRUE 81708
81700: LD_INT 37
81702: DOUBLE
81703: EQUAL
81704: IFTRUE 81708
81706: GO 81764
81708: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81709: LD_ADDR_VAR 0 9
81713: PUSH
81714: LD_VAR 0 53
81718: PUSH
81719: LD_VAR 0 54
81723: PUSH
81724: LD_VAR 0 55
81728: PUSH
81729: LD_VAR 0 56
81733: PUSH
81734: LD_VAR 0 57
81738: PUSH
81739: LD_VAR 0 58
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: PUSH
81752: LD_VAR 0 4
81756: PUSH
81757: LD_INT 1
81759: PLUS
81760: ARRAY
81761: ST_TO_ADDR
81762: GO 81871
81764: LD_INT 31
81766: DOUBLE
81767: EQUAL
81768: IFTRUE 81814
81770: LD_INT 32
81772: DOUBLE
81773: EQUAL
81774: IFTRUE 81814
81776: LD_INT 33
81778: DOUBLE
81779: EQUAL
81780: IFTRUE 81814
81782: LD_INT 27
81784: DOUBLE
81785: EQUAL
81786: IFTRUE 81814
81788: LD_INT 26
81790: DOUBLE
81791: EQUAL
81792: IFTRUE 81814
81794: LD_INT 28
81796: DOUBLE
81797: EQUAL
81798: IFTRUE 81814
81800: LD_INT 29
81802: DOUBLE
81803: EQUAL
81804: IFTRUE 81814
81806: LD_INT 30
81808: DOUBLE
81809: EQUAL
81810: IFTRUE 81814
81812: GO 81870
81814: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81815: LD_ADDR_VAR 0 9
81819: PUSH
81820: LD_VAR 0 59
81824: PUSH
81825: LD_VAR 0 60
81829: PUSH
81830: LD_VAR 0 61
81834: PUSH
81835: LD_VAR 0 62
81839: PUSH
81840: LD_VAR 0 63
81844: PUSH
81845: LD_VAR 0 64
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: PUSH
81858: LD_VAR 0 4
81862: PUSH
81863: LD_INT 1
81865: PLUS
81866: ARRAY
81867: ST_TO_ADDR
81868: GO 81871
81870: POP
// temp_list2 = [ ] ;
81871: LD_ADDR_VAR 0 10
81875: PUSH
81876: EMPTY
81877: ST_TO_ADDR
// for i in temp_list do
81878: LD_ADDR_VAR 0 8
81882: PUSH
81883: LD_VAR 0 9
81887: PUSH
81888: FOR_IN
81889: IFFALSE 81941
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81891: LD_ADDR_VAR 0 10
81895: PUSH
81896: LD_VAR 0 10
81900: PUSH
81901: LD_VAR 0 8
81905: PUSH
81906: LD_INT 1
81908: ARRAY
81909: PUSH
81910: LD_VAR 0 2
81914: PLUS
81915: PUSH
81916: LD_VAR 0 8
81920: PUSH
81921: LD_INT 2
81923: ARRAY
81924: PUSH
81925: LD_VAR 0 3
81929: PLUS
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: EMPTY
81936: LIST
81937: ADD
81938: ST_TO_ADDR
81939: GO 81888
81941: POP
81942: POP
// result = temp_list2 ;
81943: LD_ADDR_VAR 0 7
81947: PUSH
81948: LD_VAR 0 10
81952: ST_TO_ADDR
// end ;
81953: LD_VAR 0 7
81957: RET
// export function EnemyInRange ( unit , dist ) ; begin
81958: LD_INT 0
81960: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81961: LD_ADDR_VAR 0 3
81965: PUSH
81966: LD_VAR 0 1
81970: PPUSH
81971: CALL_OW 255
81975: PPUSH
81976: LD_VAR 0 1
81980: PPUSH
81981: CALL_OW 250
81985: PPUSH
81986: LD_VAR 0 1
81990: PPUSH
81991: CALL_OW 251
81995: PPUSH
81996: LD_VAR 0 2
82000: PPUSH
82001: CALL 55331 0 4
82005: PUSH
82006: LD_INT 4
82008: ARRAY
82009: ST_TO_ADDR
// end ;
82010: LD_VAR 0 3
82014: RET
// export function PlayerSeeMe ( unit ) ; begin
82015: LD_INT 0
82017: PPUSH
// result := See ( your_side , unit ) ;
82018: LD_ADDR_VAR 0 2
82022: PUSH
82023: LD_OWVAR 2
82027: PPUSH
82028: LD_VAR 0 1
82032: PPUSH
82033: CALL_OW 292
82037: ST_TO_ADDR
// end ;
82038: LD_VAR 0 2
82042: RET
// export function ReverseDir ( unit ) ; begin
82043: LD_INT 0
82045: PPUSH
// if not unit then
82046: LD_VAR 0 1
82050: NOT
82051: IFFALSE 82055
// exit ;
82053: GO 82078
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82055: LD_ADDR_VAR 0 2
82059: PUSH
82060: LD_VAR 0 1
82064: PPUSH
82065: CALL_OW 254
82069: PUSH
82070: LD_INT 3
82072: PLUS
82073: PUSH
82074: LD_INT 6
82076: MOD
82077: ST_TO_ADDR
// end ;
82078: LD_VAR 0 2
82082: RET
// export function ReverseArray ( array ) ; var i ; begin
82083: LD_INT 0
82085: PPUSH
82086: PPUSH
// if not array then
82087: LD_VAR 0 1
82091: NOT
82092: IFFALSE 82096
// exit ;
82094: GO 82151
// result := [ ] ;
82096: LD_ADDR_VAR 0 2
82100: PUSH
82101: EMPTY
82102: ST_TO_ADDR
// for i := array downto 1 do
82103: LD_ADDR_VAR 0 3
82107: PUSH
82108: DOUBLE
82109: LD_VAR 0 1
82113: INC
82114: ST_TO_ADDR
82115: LD_INT 1
82117: PUSH
82118: FOR_DOWNTO
82119: IFFALSE 82149
// result := Join ( result , array [ i ] ) ;
82121: LD_ADDR_VAR 0 2
82125: PUSH
82126: LD_VAR 0 2
82130: PPUSH
82131: LD_VAR 0 1
82135: PUSH
82136: LD_VAR 0 3
82140: ARRAY
82141: PPUSH
82142: CALL 86807 0 2
82146: ST_TO_ADDR
82147: GO 82118
82149: POP
82150: POP
// end ;
82151: LD_VAR 0 2
82155: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
82156: LD_INT 0
82158: PPUSH
82159: PPUSH
82160: PPUSH
82161: PPUSH
82162: PPUSH
82163: PPUSH
// if not unit or not hexes then
82164: LD_VAR 0 1
82168: NOT
82169: PUSH
82170: LD_VAR 0 2
82174: NOT
82175: OR
82176: IFFALSE 82180
// exit ;
82178: GO 82303
// dist := 9999 ;
82180: LD_ADDR_VAR 0 5
82184: PUSH
82185: LD_INT 9999
82187: ST_TO_ADDR
// for i = 1 to hexes do
82188: LD_ADDR_VAR 0 4
82192: PUSH
82193: DOUBLE
82194: LD_INT 1
82196: DEC
82197: ST_TO_ADDR
82198: LD_VAR 0 2
82202: PUSH
82203: FOR_TO
82204: IFFALSE 82291
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82206: LD_ADDR_VAR 0 6
82210: PUSH
82211: LD_VAR 0 1
82215: PPUSH
82216: LD_VAR 0 2
82220: PUSH
82221: LD_VAR 0 4
82225: ARRAY
82226: PUSH
82227: LD_INT 1
82229: ARRAY
82230: PPUSH
82231: LD_VAR 0 2
82235: PUSH
82236: LD_VAR 0 4
82240: ARRAY
82241: PUSH
82242: LD_INT 2
82244: ARRAY
82245: PPUSH
82246: CALL_OW 297
82250: ST_TO_ADDR
// if tdist < dist then
82251: LD_VAR 0 6
82255: PUSH
82256: LD_VAR 0 5
82260: LESS
82261: IFFALSE 82289
// begin hex := hexes [ i ] ;
82263: LD_ADDR_VAR 0 8
82267: PUSH
82268: LD_VAR 0 2
82272: PUSH
82273: LD_VAR 0 4
82277: ARRAY
82278: ST_TO_ADDR
// dist := tdist ;
82279: LD_ADDR_VAR 0 5
82283: PUSH
82284: LD_VAR 0 6
82288: ST_TO_ADDR
// end ; end ;
82289: GO 82203
82291: POP
82292: POP
// result := hex ;
82293: LD_ADDR_VAR 0 3
82297: PUSH
82298: LD_VAR 0 8
82302: ST_TO_ADDR
// end ;
82303: LD_VAR 0 3
82307: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82308: LD_INT 0
82310: PPUSH
82311: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82312: LD_VAR 0 1
82316: NOT
82317: PUSH
82318: LD_VAR 0 1
82322: PUSH
82323: LD_INT 21
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 23
82335: PUSH
82336: LD_INT 2
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PPUSH
82347: CALL_OW 69
82351: IN
82352: NOT
82353: OR
82354: IFFALSE 82358
// exit ;
82356: GO 82405
// for i = 1 to 3 do
82358: LD_ADDR_VAR 0 3
82362: PUSH
82363: DOUBLE
82364: LD_INT 1
82366: DEC
82367: ST_TO_ADDR
82368: LD_INT 3
82370: PUSH
82371: FOR_TO
82372: IFFALSE 82403
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82374: LD_VAR 0 1
82378: PPUSH
82379: CALL_OW 250
82383: PPUSH
82384: LD_VAR 0 1
82388: PPUSH
82389: CALL_OW 251
82393: PPUSH
82394: LD_INT 1
82396: PPUSH
82397: CALL_OW 453
82401: GO 82371
82403: POP
82404: POP
// end ;
82405: LD_VAR 0 2
82409: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82410: LD_INT 0
82412: PPUSH
82413: PPUSH
82414: PPUSH
82415: PPUSH
82416: PPUSH
82417: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82418: LD_VAR 0 1
82422: NOT
82423: PUSH
82424: LD_VAR 0 2
82428: NOT
82429: OR
82430: PUSH
82431: LD_VAR 0 1
82435: PPUSH
82436: CALL_OW 314
82440: OR
82441: IFFALSE 82445
// exit ;
82443: GO 82912
// if GetLives ( i ) < 250 then
82445: LD_VAR 0 4
82449: PPUSH
82450: CALL_OW 256
82454: PUSH
82455: LD_INT 250
82457: LESS
82458: IFFALSE 82471
// begin ComAutodestruct ( i ) ;
82460: LD_VAR 0 4
82464: PPUSH
82465: CALL 82308 0 1
// exit ;
82469: GO 82912
// end ; x := GetX ( enemy_unit ) ;
82471: LD_ADDR_VAR 0 7
82475: PUSH
82476: LD_VAR 0 2
82480: PPUSH
82481: CALL_OW 250
82485: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82486: LD_ADDR_VAR 0 8
82490: PUSH
82491: LD_VAR 0 2
82495: PPUSH
82496: CALL_OW 251
82500: ST_TO_ADDR
// if not x or not y then
82501: LD_VAR 0 7
82505: NOT
82506: PUSH
82507: LD_VAR 0 8
82511: NOT
82512: OR
82513: IFFALSE 82517
// exit ;
82515: GO 82912
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82517: LD_ADDR_VAR 0 6
82521: PUSH
82522: LD_VAR 0 7
82526: PPUSH
82527: LD_INT 0
82529: PPUSH
82530: LD_INT 4
82532: PPUSH
82533: CALL_OW 272
82537: PUSH
82538: LD_VAR 0 8
82542: PPUSH
82543: LD_INT 0
82545: PPUSH
82546: LD_INT 4
82548: PPUSH
82549: CALL_OW 273
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_VAR 0 7
82562: PPUSH
82563: LD_INT 1
82565: PPUSH
82566: LD_INT 4
82568: PPUSH
82569: CALL_OW 272
82573: PUSH
82574: LD_VAR 0 8
82578: PPUSH
82579: LD_INT 1
82581: PPUSH
82582: LD_INT 4
82584: PPUSH
82585: CALL_OW 273
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_VAR 0 7
82598: PPUSH
82599: LD_INT 2
82601: PPUSH
82602: LD_INT 4
82604: PPUSH
82605: CALL_OW 272
82609: PUSH
82610: LD_VAR 0 8
82614: PPUSH
82615: LD_INT 2
82617: PPUSH
82618: LD_INT 4
82620: PPUSH
82621: CALL_OW 273
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_VAR 0 7
82634: PPUSH
82635: LD_INT 3
82637: PPUSH
82638: LD_INT 4
82640: PPUSH
82641: CALL_OW 272
82645: PUSH
82646: LD_VAR 0 8
82650: PPUSH
82651: LD_INT 3
82653: PPUSH
82654: LD_INT 4
82656: PPUSH
82657: CALL_OW 273
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_VAR 0 7
82670: PPUSH
82671: LD_INT 4
82673: PPUSH
82674: LD_INT 4
82676: PPUSH
82677: CALL_OW 272
82681: PUSH
82682: LD_VAR 0 8
82686: PPUSH
82687: LD_INT 4
82689: PPUSH
82690: LD_INT 4
82692: PPUSH
82693: CALL_OW 273
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_VAR 0 7
82706: PPUSH
82707: LD_INT 5
82709: PPUSH
82710: LD_INT 4
82712: PPUSH
82713: CALL_OW 272
82717: PUSH
82718: LD_VAR 0 8
82722: PPUSH
82723: LD_INT 5
82725: PPUSH
82726: LD_INT 4
82728: PPUSH
82729: CALL_OW 273
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: ST_TO_ADDR
// for i = tmp downto 1 do
82746: LD_ADDR_VAR 0 4
82750: PUSH
82751: DOUBLE
82752: LD_VAR 0 6
82756: INC
82757: ST_TO_ADDR
82758: LD_INT 1
82760: PUSH
82761: FOR_DOWNTO
82762: IFFALSE 82863
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82764: LD_VAR 0 6
82768: PUSH
82769: LD_VAR 0 4
82773: ARRAY
82774: PUSH
82775: LD_INT 1
82777: ARRAY
82778: PPUSH
82779: LD_VAR 0 6
82783: PUSH
82784: LD_VAR 0 4
82788: ARRAY
82789: PUSH
82790: LD_INT 2
82792: ARRAY
82793: PPUSH
82794: CALL_OW 488
82798: NOT
82799: PUSH
82800: LD_VAR 0 6
82804: PUSH
82805: LD_VAR 0 4
82809: ARRAY
82810: PUSH
82811: LD_INT 1
82813: ARRAY
82814: PPUSH
82815: LD_VAR 0 6
82819: PUSH
82820: LD_VAR 0 4
82824: ARRAY
82825: PUSH
82826: LD_INT 2
82828: ARRAY
82829: PPUSH
82830: CALL_OW 428
82834: PUSH
82835: LD_INT 0
82837: NONEQUAL
82838: OR
82839: IFFALSE 82861
// tmp := Delete ( tmp , i ) ;
82841: LD_ADDR_VAR 0 6
82845: PUSH
82846: LD_VAR 0 6
82850: PPUSH
82851: LD_VAR 0 4
82855: PPUSH
82856: CALL_OW 3
82860: ST_TO_ADDR
82861: GO 82761
82863: POP
82864: POP
// j := GetClosestHex ( unit , tmp ) ;
82865: LD_ADDR_VAR 0 5
82869: PUSH
82870: LD_VAR 0 1
82874: PPUSH
82875: LD_VAR 0 6
82879: PPUSH
82880: CALL 82156 0 2
82884: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82885: LD_VAR 0 1
82889: PPUSH
82890: LD_VAR 0 5
82894: PUSH
82895: LD_INT 1
82897: ARRAY
82898: PPUSH
82899: LD_VAR 0 5
82903: PUSH
82904: LD_INT 2
82906: ARRAY
82907: PPUSH
82908: CALL_OW 111
// end ;
82912: LD_VAR 0 3
82916: RET
// export function PrepareApemanSoldier ( ) ; begin
82917: LD_INT 0
82919: PPUSH
// uc_nation := 0 ;
82920: LD_ADDR_OWVAR 21
82924: PUSH
82925: LD_INT 0
82927: ST_TO_ADDR
// hc_sex := sex_male ;
82928: LD_ADDR_OWVAR 27
82932: PUSH
82933: LD_INT 1
82935: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82936: LD_ADDR_OWVAR 28
82940: PUSH
82941: LD_INT 15
82943: ST_TO_ADDR
// hc_gallery :=  ;
82944: LD_ADDR_OWVAR 33
82948: PUSH
82949: LD_STRING 
82951: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82952: LD_ADDR_OWVAR 31
82956: PUSH
82957: LD_INT 0
82959: PPUSH
82960: LD_INT 3
82962: PPUSH
82963: CALL_OW 12
82967: PUSH
82968: LD_INT 0
82970: PPUSH
82971: LD_INT 3
82973: PPUSH
82974: CALL_OW 12
82978: PUSH
82979: LD_INT 0
82981: PUSH
82982: LD_INT 0
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: ST_TO_ADDR
// end ;
82991: LD_VAR 0 1
82995: RET
// export function PrepareApemanEngineer ( ) ; begin
82996: LD_INT 0
82998: PPUSH
// uc_nation := 0 ;
82999: LD_ADDR_OWVAR 21
83003: PUSH
83004: LD_INT 0
83006: ST_TO_ADDR
// hc_sex := sex_male ;
83007: LD_ADDR_OWVAR 27
83011: PUSH
83012: LD_INT 1
83014: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
83015: LD_ADDR_OWVAR 28
83019: PUSH
83020: LD_INT 16
83022: ST_TO_ADDR
// hc_gallery :=  ;
83023: LD_ADDR_OWVAR 33
83027: PUSH
83028: LD_STRING 
83030: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83031: LD_ADDR_OWVAR 31
83035: PUSH
83036: LD_INT 0
83038: PPUSH
83039: LD_INT 3
83041: PPUSH
83042: CALL_OW 12
83046: PUSH
83047: LD_INT 0
83049: PPUSH
83050: LD_INT 3
83052: PPUSH
83053: CALL_OW 12
83057: PUSH
83058: LD_INT 0
83060: PUSH
83061: LD_INT 0
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: ST_TO_ADDR
// end ;
83070: LD_VAR 0 1
83074: RET
// export function PrepareApeman ( agressivity ) ; begin
83075: LD_INT 0
83077: PPUSH
// uc_side := 0 ;
83078: LD_ADDR_OWVAR 20
83082: PUSH
83083: LD_INT 0
83085: ST_TO_ADDR
// uc_nation := 0 ;
83086: LD_ADDR_OWVAR 21
83090: PUSH
83091: LD_INT 0
83093: ST_TO_ADDR
// hc_sex := sex_male ;
83094: LD_ADDR_OWVAR 27
83098: PUSH
83099: LD_INT 1
83101: ST_TO_ADDR
// hc_class := class_apeman ;
83102: LD_ADDR_OWVAR 28
83106: PUSH
83107: LD_INT 12
83109: ST_TO_ADDR
// hc_gallery :=  ;
83110: LD_ADDR_OWVAR 33
83114: PUSH
83115: LD_STRING 
83117: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83118: LD_ADDR_OWVAR 35
83122: PUSH
83123: LD_VAR 0 1
83127: NEG
83128: PPUSH
83129: LD_VAR 0 1
83133: PPUSH
83134: CALL_OW 12
83138: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83139: LD_ADDR_OWVAR 31
83143: PUSH
83144: LD_INT 0
83146: PPUSH
83147: LD_INT 3
83149: PPUSH
83150: CALL_OW 12
83154: PUSH
83155: LD_INT 0
83157: PPUSH
83158: LD_INT 3
83160: PPUSH
83161: CALL_OW 12
83165: PUSH
83166: LD_INT 0
83168: PUSH
83169: LD_INT 0
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: ST_TO_ADDR
// end ;
83178: LD_VAR 0 2
83182: RET
// export function PrepareTiger ( agressivity ) ; begin
83183: LD_INT 0
83185: PPUSH
// uc_side := 0 ;
83186: LD_ADDR_OWVAR 20
83190: PUSH
83191: LD_INT 0
83193: ST_TO_ADDR
// uc_nation := 0 ;
83194: LD_ADDR_OWVAR 21
83198: PUSH
83199: LD_INT 0
83201: ST_TO_ADDR
// hc_class := class_tiger ;
83202: LD_ADDR_OWVAR 28
83206: PUSH
83207: LD_INT 14
83209: ST_TO_ADDR
// hc_gallery :=  ;
83210: LD_ADDR_OWVAR 33
83214: PUSH
83215: LD_STRING 
83217: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83218: LD_ADDR_OWVAR 35
83222: PUSH
83223: LD_VAR 0 1
83227: NEG
83228: PPUSH
83229: LD_VAR 0 1
83233: PPUSH
83234: CALL_OW 12
83238: ST_TO_ADDR
// end ;
83239: LD_VAR 0 2
83243: RET
// export function PrepareEnchidna ( ) ; begin
83244: LD_INT 0
83246: PPUSH
// uc_side := 0 ;
83247: LD_ADDR_OWVAR 20
83251: PUSH
83252: LD_INT 0
83254: ST_TO_ADDR
// uc_nation := 0 ;
83255: LD_ADDR_OWVAR 21
83259: PUSH
83260: LD_INT 0
83262: ST_TO_ADDR
// hc_class := class_baggie ;
83263: LD_ADDR_OWVAR 28
83267: PUSH
83268: LD_INT 13
83270: ST_TO_ADDR
// hc_gallery :=  ;
83271: LD_ADDR_OWVAR 33
83275: PUSH
83276: LD_STRING 
83278: ST_TO_ADDR
// end ;
83279: LD_VAR 0 1
83283: RET
// export function PrepareFrog ( ) ; begin
83284: LD_INT 0
83286: PPUSH
// uc_side := 0 ;
83287: LD_ADDR_OWVAR 20
83291: PUSH
83292: LD_INT 0
83294: ST_TO_ADDR
// uc_nation := 0 ;
83295: LD_ADDR_OWVAR 21
83299: PUSH
83300: LD_INT 0
83302: ST_TO_ADDR
// hc_class := class_frog ;
83303: LD_ADDR_OWVAR 28
83307: PUSH
83308: LD_INT 19
83310: ST_TO_ADDR
// hc_gallery :=  ;
83311: LD_ADDR_OWVAR 33
83315: PUSH
83316: LD_STRING 
83318: ST_TO_ADDR
// end ;
83319: LD_VAR 0 1
83323: RET
// export function PrepareFish ( ) ; begin
83324: LD_INT 0
83326: PPUSH
// uc_side := 0 ;
83327: LD_ADDR_OWVAR 20
83331: PUSH
83332: LD_INT 0
83334: ST_TO_ADDR
// uc_nation := 0 ;
83335: LD_ADDR_OWVAR 21
83339: PUSH
83340: LD_INT 0
83342: ST_TO_ADDR
// hc_class := class_fish ;
83343: LD_ADDR_OWVAR 28
83347: PUSH
83348: LD_INT 20
83350: ST_TO_ADDR
// hc_gallery :=  ;
83351: LD_ADDR_OWVAR 33
83355: PUSH
83356: LD_STRING 
83358: ST_TO_ADDR
// end ;
83359: LD_VAR 0 1
83363: RET
// export function PrepareBird ( ) ; begin
83364: LD_INT 0
83366: PPUSH
// uc_side := 0 ;
83367: LD_ADDR_OWVAR 20
83371: PUSH
83372: LD_INT 0
83374: ST_TO_ADDR
// uc_nation := 0 ;
83375: LD_ADDR_OWVAR 21
83379: PUSH
83380: LD_INT 0
83382: ST_TO_ADDR
// hc_class := class_phororhacos ;
83383: LD_ADDR_OWVAR 28
83387: PUSH
83388: LD_INT 18
83390: ST_TO_ADDR
// hc_gallery :=  ;
83391: LD_ADDR_OWVAR 33
83395: PUSH
83396: LD_STRING 
83398: ST_TO_ADDR
// end ;
83399: LD_VAR 0 1
83403: RET
// export function PrepareHorse ( ) ; begin
83404: LD_INT 0
83406: PPUSH
// uc_side := 0 ;
83407: LD_ADDR_OWVAR 20
83411: PUSH
83412: LD_INT 0
83414: ST_TO_ADDR
// uc_nation := 0 ;
83415: LD_ADDR_OWVAR 21
83419: PUSH
83420: LD_INT 0
83422: ST_TO_ADDR
// hc_class := class_horse ;
83423: LD_ADDR_OWVAR 28
83427: PUSH
83428: LD_INT 21
83430: ST_TO_ADDR
// hc_gallery :=  ;
83431: LD_ADDR_OWVAR 33
83435: PUSH
83436: LD_STRING 
83438: ST_TO_ADDR
// end ;
83439: LD_VAR 0 1
83443: RET
// export function PrepareMastodont ( ) ; begin
83444: LD_INT 0
83446: PPUSH
// uc_side := 0 ;
83447: LD_ADDR_OWVAR 20
83451: PUSH
83452: LD_INT 0
83454: ST_TO_ADDR
// uc_nation := 0 ;
83455: LD_ADDR_OWVAR 21
83459: PUSH
83460: LD_INT 0
83462: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83463: LD_ADDR_OWVAR 37
83467: PUSH
83468: LD_INT 31
83470: ST_TO_ADDR
// vc_control := control_rider ;
83471: LD_ADDR_OWVAR 38
83475: PUSH
83476: LD_INT 4
83478: ST_TO_ADDR
// end ;
83479: LD_VAR 0 1
83483: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83484: LD_INT 0
83486: PPUSH
83487: PPUSH
83488: PPUSH
// uc_side = 0 ;
83489: LD_ADDR_OWVAR 20
83493: PUSH
83494: LD_INT 0
83496: ST_TO_ADDR
// uc_nation = 0 ;
83497: LD_ADDR_OWVAR 21
83501: PUSH
83502: LD_INT 0
83504: ST_TO_ADDR
// InitHc_All ( ) ;
83505: CALL_OW 584
// InitVc ;
83509: CALL_OW 20
// if mastodonts then
83513: LD_VAR 0 6
83517: IFFALSE 83584
// for i = 1 to mastodonts do
83519: LD_ADDR_VAR 0 11
83523: PUSH
83524: DOUBLE
83525: LD_INT 1
83527: DEC
83528: ST_TO_ADDR
83529: LD_VAR 0 6
83533: PUSH
83534: FOR_TO
83535: IFFALSE 83582
// begin vc_chassis := 31 ;
83537: LD_ADDR_OWVAR 37
83541: PUSH
83542: LD_INT 31
83544: ST_TO_ADDR
// vc_control := control_rider ;
83545: LD_ADDR_OWVAR 38
83549: PUSH
83550: LD_INT 4
83552: ST_TO_ADDR
// animal := CreateVehicle ;
83553: LD_ADDR_VAR 0 12
83557: PUSH
83558: CALL_OW 45
83562: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83563: LD_VAR 0 12
83567: PPUSH
83568: LD_VAR 0 8
83572: PPUSH
83573: LD_INT 0
83575: PPUSH
83576: CALL 85712 0 3
// end ;
83580: GO 83534
83582: POP
83583: POP
// if horses then
83584: LD_VAR 0 5
83588: IFFALSE 83655
// for i = 1 to horses do
83590: LD_ADDR_VAR 0 11
83594: PUSH
83595: DOUBLE
83596: LD_INT 1
83598: DEC
83599: ST_TO_ADDR
83600: LD_VAR 0 5
83604: PUSH
83605: FOR_TO
83606: IFFALSE 83653
// begin hc_class := 21 ;
83608: LD_ADDR_OWVAR 28
83612: PUSH
83613: LD_INT 21
83615: ST_TO_ADDR
// hc_gallery :=  ;
83616: LD_ADDR_OWVAR 33
83620: PUSH
83621: LD_STRING 
83623: ST_TO_ADDR
// animal := CreateHuman ;
83624: LD_ADDR_VAR 0 12
83628: PUSH
83629: CALL_OW 44
83633: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83634: LD_VAR 0 12
83638: PPUSH
83639: LD_VAR 0 8
83643: PPUSH
83644: LD_INT 0
83646: PPUSH
83647: CALL 85712 0 3
// end ;
83651: GO 83605
83653: POP
83654: POP
// if birds then
83655: LD_VAR 0 1
83659: IFFALSE 83726
// for i = 1 to birds do
83661: LD_ADDR_VAR 0 11
83665: PUSH
83666: DOUBLE
83667: LD_INT 1
83669: DEC
83670: ST_TO_ADDR
83671: LD_VAR 0 1
83675: PUSH
83676: FOR_TO
83677: IFFALSE 83724
// begin hc_class := 18 ;
83679: LD_ADDR_OWVAR 28
83683: PUSH
83684: LD_INT 18
83686: ST_TO_ADDR
// hc_gallery =  ;
83687: LD_ADDR_OWVAR 33
83691: PUSH
83692: LD_STRING 
83694: ST_TO_ADDR
// animal := CreateHuman ;
83695: LD_ADDR_VAR 0 12
83699: PUSH
83700: CALL_OW 44
83704: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83705: LD_VAR 0 12
83709: PPUSH
83710: LD_VAR 0 8
83714: PPUSH
83715: LD_INT 0
83717: PPUSH
83718: CALL 85712 0 3
// end ;
83722: GO 83676
83724: POP
83725: POP
// if tigers then
83726: LD_VAR 0 2
83730: IFFALSE 83814
// for i = 1 to tigers do
83732: LD_ADDR_VAR 0 11
83736: PUSH
83737: DOUBLE
83738: LD_INT 1
83740: DEC
83741: ST_TO_ADDR
83742: LD_VAR 0 2
83746: PUSH
83747: FOR_TO
83748: IFFALSE 83812
// begin hc_class = class_tiger ;
83750: LD_ADDR_OWVAR 28
83754: PUSH
83755: LD_INT 14
83757: ST_TO_ADDR
// hc_gallery =  ;
83758: LD_ADDR_OWVAR 33
83762: PUSH
83763: LD_STRING 
83765: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83766: LD_ADDR_OWVAR 35
83770: PUSH
83771: LD_INT 7
83773: NEG
83774: PPUSH
83775: LD_INT 7
83777: PPUSH
83778: CALL_OW 12
83782: ST_TO_ADDR
// animal := CreateHuman ;
83783: LD_ADDR_VAR 0 12
83787: PUSH
83788: CALL_OW 44
83792: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83793: LD_VAR 0 12
83797: PPUSH
83798: LD_VAR 0 8
83802: PPUSH
83803: LD_INT 0
83805: PPUSH
83806: CALL 85712 0 3
// end ;
83810: GO 83747
83812: POP
83813: POP
// if apemans then
83814: LD_VAR 0 3
83818: IFFALSE 83941
// for i = 1 to apemans do
83820: LD_ADDR_VAR 0 11
83824: PUSH
83825: DOUBLE
83826: LD_INT 1
83828: DEC
83829: ST_TO_ADDR
83830: LD_VAR 0 3
83834: PUSH
83835: FOR_TO
83836: IFFALSE 83939
// begin hc_class = class_apeman ;
83838: LD_ADDR_OWVAR 28
83842: PUSH
83843: LD_INT 12
83845: ST_TO_ADDR
// hc_gallery =  ;
83846: LD_ADDR_OWVAR 33
83850: PUSH
83851: LD_STRING 
83853: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83854: LD_ADDR_OWVAR 35
83858: PUSH
83859: LD_INT 2
83861: NEG
83862: PPUSH
83863: LD_INT 2
83865: PPUSH
83866: CALL_OW 12
83870: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83871: LD_ADDR_OWVAR 31
83875: PUSH
83876: LD_INT 1
83878: PPUSH
83879: LD_INT 3
83881: PPUSH
83882: CALL_OW 12
83886: PUSH
83887: LD_INT 1
83889: PPUSH
83890: LD_INT 3
83892: PPUSH
83893: CALL_OW 12
83897: PUSH
83898: LD_INT 0
83900: PUSH
83901: LD_INT 0
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: ST_TO_ADDR
// animal := CreateHuman ;
83910: LD_ADDR_VAR 0 12
83914: PUSH
83915: CALL_OW 44
83919: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83920: LD_VAR 0 12
83924: PPUSH
83925: LD_VAR 0 8
83929: PPUSH
83930: LD_INT 0
83932: PPUSH
83933: CALL 85712 0 3
// end ;
83937: GO 83835
83939: POP
83940: POP
// if enchidnas then
83941: LD_VAR 0 4
83945: IFFALSE 84012
// for i = 1 to enchidnas do
83947: LD_ADDR_VAR 0 11
83951: PUSH
83952: DOUBLE
83953: LD_INT 1
83955: DEC
83956: ST_TO_ADDR
83957: LD_VAR 0 4
83961: PUSH
83962: FOR_TO
83963: IFFALSE 84010
// begin hc_class = 13 ;
83965: LD_ADDR_OWVAR 28
83969: PUSH
83970: LD_INT 13
83972: ST_TO_ADDR
// hc_gallery =  ;
83973: LD_ADDR_OWVAR 33
83977: PUSH
83978: LD_STRING 
83980: ST_TO_ADDR
// animal := CreateHuman ;
83981: LD_ADDR_VAR 0 12
83985: PUSH
83986: CALL_OW 44
83990: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83991: LD_VAR 0 12
83995: PPUSH
83996: LD_VAR 0 8
84000: PPUSH
84001: LD_INT 0
84003: PPUSH
84004: CALL 85712 0 3
// end ;
84008: GO 83962
84010: POP
84011: POP
// if fishes then
84012: LD_VAR 0 7
84016: IFFALSE 84083
// for i = 1 to fishes do
84018: LD_ADDR_VAR 0 11
84022: PUSH
84023: DOUBLE
84024: LD_INT 1
84026: DEC
84027: ST_TO_ADDR
84028: LD_VAR 0 7
84032: PUSH
84033: FOR_TO
84034: IFFALSE 84081
// begin hc_class = 20 ;
84036: LD_ADDR_OWVAR 28
84040: PUSH
84041: LD_INT 20
84043: ST_TO_ADDR
// hc_gallery =  ;
84044: LD_ADDR_OWVAR 33
84048: PUSH
84049: LD_STRING 
84051: ST_TO_ADDR
// animal := CreateHuman ;
84052: LD_ADDR_VAR 0 12
84056: PUSH
84057: CALL_OW 44
84061: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84062: LD_VAR 0 12
84066: PPUSH
84067: LD_VAR 0 9
84071: PPUSH
84072: LD_INT 0
84074: PPUSH
84075: CALL 85712 0 3
// end ;
84079: GO 84033
84081: POP
84082: POP
// end ;
84083: LD_VAR 0 10
84087: RET
// export function WantHeal ( sci , unit ) ; begin
84088: LD_INT 0
84090: PPUSH
// if GetTaskList ( sci ) > 0 then
84091: LD_VAR 0 1
84095: PPUSH
84096: CALL_OW 437
84100: PUSH
84101: LD_INT 0
84103: GREATER
84104: IFFALSE 84174
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84106: LD_VAR 0 1
84110: PPUSH
84111: CALL_OW 437
84115: PUSH
84116: LD_INT 1
84118: ARRAY
84119: PUSH
84120: LD_INT 1
84122: ARRAY
84123: PUSH
84124: LD_STRING l
84126: EQUAL
84127: PUSH
84128: LD_VAR 0 1
84132: PPUSH
84133: CALL_OW 437
84137: PUSH
84138: LD_INT 1
84140: ARRAY
84141: PUSH
84142: LD_INT 4
84144: ARRAY
84145: PUSH
84146: LD_VAR 0 2
84150: EQUAL
84151: AND
84152: IFFALSE 84164
// result := true else
84154: LD_ADDR_VAR 0 3
84158: PUSH
84159: LD_INT 1
84161: ST_TO_ADDR
84162: GO 84172
// result := false ;
84164: LD_ADDR_VAR 0 3
84168: PUSH
84169: LD_INT 0
84171: ST_TO_ADDR
// end else
84172: GO 84182
// result := false ;
84174: LD_ADDR_VAR 0 3
84178: PUSH
84179: LD_INT 0
84181: ST_TO_ADDR
// end ;
84182: LD_VAR 0 3
84186: RET
// export function HealTarget ( sci ) ; begin
84187: LD_INT 0
84189: PPUSH
// if not sci then
84190: LD_VAR 0 1
84194: NOT
84195: IFFALSE 84199
// exit ;
84197: GO 84264
// result := 0 ;
84199: LD_ADDR_VAR 0 2
84203: PUSH
84204: LD_INT 0
84206: ST_TO_ADDR
// if GetTaskList ( sci ) then
84207: LD_VAR 0 1
84211: PPUSH
84212: CALL_OW 437
84216: IFFALSE 84264
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84218: LD_VAR 0 1
84222: PPUSH
84223: CALL_OW 437
84227: PUSH
84228: LD_INT 1
84230: ARRAY
84231: PUSH
84232: LD_INT 1
84234: ARRAY
84235: PUSH
84236: LD_STRING l
84238: EQUAL
84239: IFFALSE 84264
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84241: LD_ADDR_VAR 0 2
84245: PUSH
84246: LD_VAR 0 1
84250: PPUSH
84251: CALL_OW 437
84255: PUSH
84256: LD_INT 1
84258: ARRAY
84259: PUSH
84260: LD_INT 4
84262: ARRAY
84263: ST_TO_ADDR
// end ;
84264: LD_VAR 0 2
84268: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84269: LD_INT 0
84271: PPUSH
84272: PPUSH
84273: PPUSH
84274: PPUSH
// if not base_units then
84275: LD_VAR 0 1
84279: NOT
84280: IFFALSE 84284
// exit ;
84282: GO 84371
// result := false ;
84284: LD_ADDR_VAR 0 2
84288: PUSH
84289: LD_INT 0
84291: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84292: LD_ADDR_VAR 0 5
84296: PUSH
84297: LD_VAR 0 1
84301: PPUSH
84302: LD_INT 21
84304: PUSH
84305: LD_INT 3
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PPUSH
84312: CALL_OW 72
84316: ST_TO_ADDR
// if not tmp then
84317: LD_VAR 0 5
84321: NOT
84322: IFFALSE 84326
// exit ;
84324: GO 84371
// for i in tmp do
84326: LD_ADDR_VAR 0 3
84330: PUSH
84331: LD_VAR 0 5
84335: PUSH
84336: FOR_IN
84337: IFFALSE 84369
// begin result := EnemyInRange ( i , 22 ) ;
84339: LD_ADDR_VAR 0 2
84343: PUSH
84344: LD_VAR 0 3
84348: PPUSH
84349: LD_INT 22
84351: PPUSH
84352: CALL 81958 0 2
84356: ST_TO_ADDR
// if result then
84357: LD_VAR 0 2
84361: IFFALSE 84367
// exit ;
84363: POP
84364: POP
84365: GO 84371
// end ;
84367: GO 84336
84369: POP
84370: POP
// end ;
84371: LD_VAR 0 2
84375: RET
// export function FilterByTag ( units , tag ) ; begin
84376: LD_INT 0
84378: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84379: LD_ADDR_VAR 0 3
84383: PUSH
84384: LD_VAR 0 1
84388: PPUSH
84389: LD_INT 120
84391: PUSH
84392: LD_VAR 0 2
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PPUSH
84401: CALL_OW 72
84405: ST_TO_ADDR
// end ;
84406: LD_VAR 0 3
84410: RET
// export function IsDriver ( un ) ; begin
84411: LD_INT 0
84413: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84414: LD_ADDR_VAR 0 2
84418: PUSH
84419: LD_VAR 0 1
84423: PUSH
84424: LD_INT 55
84426: PUSH
84427: EMPTY
84428: LIST
84429: PPUSH
84430: CALL_OW 69
84434: IN
84435: ST_TO_ADDR
// end ;
84436: LD_VAR 0 2
84440: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84441: LD_INT 0
84443: PPUSH
84444: PPUSH
// list := [ ] ;
84445: LD_ADDR_VAR 0 5
84449: PUSH
84450: EMPTY
84451: ST_TO_ADDR
// case d of 0 :
84452: LD_VAR 0 3
84456: PUSH
84457: LD_INT 0
84459: DOUBLE
84460: EQUAL
84461: IFTRUE 84465
84463: GO 84598
84465: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84466: LD_ADDR_VAR 0 5
84470: PUSH
84471: LD_VAR 0 1
84475: PUSH
84476: LD_INT 4
84478: MINUS
84479: PUSH
84480: LD_VAR 0 2
84484: PUSH
84485: LD_INT 4
84487: MINUS
84488: PUSH
84489: LD_INT 2
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: LIST
84496: PUSH
84497: LD_VAR 0 1
84501: PUSH
84502: LD_INT 3
84504: MINUS
84505: PUSH
84506: LD_VAR 0 2
84510: PUSH
84511: LD_INT 1
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: LIST
84518: PUSH
84519: LD_VAR 0 1
84523: PUSH
84524: LD_INT 4
84526: PLUS
84527: PUSH
84528: LD_VAR 0 2
84532: PUSH
84533: LD_INT 4
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: LIST
84540: PUSH
84541: LD_VAR 0 1
84545: PUSH
84546: LD_INT 3
84548: PLUS
84549: PUSH
84550: LD_VAR 0 2
84554: PUSH
84555: LD_INT 3
84557: PLUS
84558: PUSH
84559: LD_INT 5
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: LIST
84566: PUSH
84567: LD_VAR 0 1
84571: PUSH
84572: LD_VAR 0 2
84576: PUSH
84577: LD_INT 4
84579: PLUS
84580: PUSH
84581: LD_INT 0
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: LIST
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: ST_TO_ADDR
// end ; 1 :
84596: GO 85296
84598: LD_INT 1
84600: DOUBLE
84601: EQUAL
84602: IFTRUE 84606
84604: GO 84739
84606: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84607: LD_ADDR_VAR 0 5
84611: PUSH
84612: LD_VAR 0 1
84616: PUSH
84617: LD_VAR 0 2
84621: PUSH
84622: LD_INT 4
84624: MINUS
84625: PUSH
84626: LD_INT 3
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: LIST
84633: PUSH
84634: LD_VAR 0 1
84638: PUSH
84639: LD_INT 3
84641: MINUS
84642: PUSH
84643: LD_VAR 0 2
84647: PUSH
84648: LD_INT 3
84650: MINUS
84651: PUSH
84652: LD_INT 2
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: LIST
84659: PUSH
84660: LD_VAR 0 1
84664: PUSH
84665: LD_INT 4
84667: MINUS
84668: PUSH
84669: LD_VAR 0 2
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: LIST
84681: PUSH
84682: LD_VAR 0 1
84686: PUSH
84687: LD_VAR 0 2
84691: PUSH
84692: LD_INT 3
84694: PLUS
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: LIST
84703: PUSH
84704: LD_VAR 0 1
84708: PUSH
84709: LD_INT 4
84711: PLUS
84712: PUSH
84713: LD_VAR 0 2
84717: PUSH
84718: LD_INT 4
84720: PLUS
84721: PUSH
84722: LD_INT 5
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: LIST
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: ST_TO_ADDR
// end ; 2 :
84737: GO 85296
84739: LD_INT 2
84741: DOUBLE
84742: EQUAL
84743: IFTRUE 84747
84745: GO 84876
84747: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84748: LD_ADDR_VAR 0 5
84752: PUSH
84753: LD_VAR 0 1
84757: PUSH
84758: LD_VAR 0 2
84762: PUSH
84763: LD_INT 3
84765: MINUS
84766: PUSH
84767: LD_INT 3
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: LIST
84774: PUSH
84775: LD_VAR 0 1
84779: PUSH
84780: LD_INT 4
84782: PLUS
84783: PUSH
84784: LD_VAR 0 2
84788: PUSH
84789: LD_INT 4
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: LIST
84796: PUSH
84797: LD_VAR 0 1
84801: PUSH
84802: LD_VAR 0 2
84806: PUSH
84807: LD_INT 4
84809: PLUS
84810: PUSH
84811: LD_INT 0
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: LIST
84818: PUSH
84819: LD_VAR 0 1
84823: PUSH
84824: LD_INT 3
84826: MINUS
84827: PUSH
84828: LD_VAR 0 2
84832: PUSH
84833: LD_INT 1
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: LIST
84840: PUSH
84841: LD_VAR 0 1
84845: PUSH
84846: LD_INT 4
84848: MINUS
84849: PUSH
84850: LD_VAR 0 2
84854: PUSH
84855: LD_INT 4
84857: MINUS
84858: PUSH
84859: LD_INT 2
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: LIST
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: ST_TO_ADDR
// end ; 3 :
84874: GO 85296
84876: LD_INT 3
84878: DOUBLE
84879: EQUAL
84880: IFTRUE 84884
84882: GO 85017
84884: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84885: LD_ADDR_VAR 0 5
84889: PUSH
84890: LD_VAR 0 1
84894: PUSH
84895: LD_INT 3
84897: PLUS
84898: PUSH
84899: LD_VAR 0 2
84903: PUSH
84904: LD_INT 4
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: LIST
84911: PUSH
84912: LD_VAR 0 1
84916: PUSH
84917: LD_INT 4
84919: PLUS
84920: PUSH
84921: LD_VAR 0 2
84925: PUSH
84926: LD_INT 4
84928: PLUS
84929: PUSH
84930: LD_INT 5
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: LIST
84937: PUSH
84938: LD_VAR 0 1
84942: PUSH
84943: LD_INT 4
84945: MINUS
84946: PUSH
84947: LD_VAR 0 2
84951: PUSH
84952: LD_INT 1
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: LIST
84959: PUSH
84960: LD_VAR 0 1
84964: PUSH
84965: LD_VAR 0 2
84969: PUSH
84970: LD_INT 4
84972: MINUS
84973: PUSH
84974: LD_INT 3
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: LIST
84981: PUSH
84982: LD_VAR 0 1
84986: PUSH
84987: LD_INT 3
84989: MINUS
84990: PUSH
84991: LD_VAR 0 2
84995: PUSH
84996: LD_INT 3
84998: MINUS
84999: PUSH
85000: LD_INT 2
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: LIST
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: ST_TO_ADDR
// end ; 4 :
85015: GO 85296
85017: LD_INT 4
85019: DOUBLE
85020: EQUAL
85021: IFTRUE 85025
85023: GO 85158
85025: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85026: LD_ADDR_VAR 0 5
85030: PUSH
85031: LD_VAR 0 1
85035: PUSH
85036: LD_VAR 0 2
85040: PUSH
85041: LD_INT 4
85043: PLUS
85044: PUSH
85045: LD_INT 0
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: LIST
85052: PUSH
85053: LD_VAR 0 1
85057: PUSH
85058: LD_INT 3
85060: PLUS
85061: PUSH
85062: LD_VAR 0 2
85066: PUSH
85067: LD_INT 3
85069: PLUS
85070: PUSH
85071: LD_INT 5
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: LIST
85078: PUSH
85079: LD_VAR 0 1
85083: PUSH
85084: LD_INT 4
85086: PLUS
85087: PUSH
85088: LD_VAR 0 2
85092: PUSH
85093: LD_INT 4
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: LIST
85100: PUSH
85101: LD_VAR 0 1
85105: PUSH
85106: LD_VAR 0 2
85110: PUSH
85111: LD_INT 3
85113: MINUS
85114: PUSH
85115: LD_INT 3
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: LIST
85122: PUSH
85123: LD_VAR 0 1
85127: PUSH
85128: LD_INT 4
85130: MINUS
85131: PUSH
85132: LD_VAR 0 2
85136: PUSH
85137: LD_INT 4
85139: MINUS
85140: PUSH
85141: LD_INT 2
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: LIST
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: ST_TO_ADDR
// end ; 5 :
85156: GO 85296
85158: LD_INT 5
85160: DOUBLE
85161: EQUAL
85162: IFTRUE 85166
85164: GO 85295
85166: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85167: LD_ADDR_VAR 0 5
85171: PUSH
85172: LD_VAR 0 1
85176: PUSH
85177: LD_INT 4
85179: MINUS
85180: PUSH
85181: LD_VAR 0 2
85185: PUSH
85186: LD_INT 1
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: LIST
85193: PUSH
85194: LD_VAR 0 1
85198: PUSH
85199: LD_VAR 0 2
85203: PUSH
85204: LD_INT 4
85206: MINUS
85207: PUSH
85208: LD_INT 3
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: LIST
85215: PUSH
85216: LD_VAR 0 1
85220: PUSH
85221: LD_INT 4
85223: PLUS
85224: PUSH
85225: LD_VAR 0 2
85229: PUSH
85230: LD_INT 4
85232: PLUS
85233: PUSH
85234: LD_INT 5
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: LIST
85241: PUSH
85242: LD_VAR 0 1
85246: PUSH
85247: LD_INT 3
85249: PLUS
85250: PUSH
85251: LD_VAR 0 2
85255: PUSH
85256: LD_INT 4
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: LIST
85263: PUSH
85264: LD_VAR 0 1
85268: PUSH
85269: LD_VAR 0 2
85273: PUSH
85274: LD_INT 3
85276: PLUS
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: LIST
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: ST_TO_ADDR
// end ; end ;
85293: GO 85296
85295: POP
// result := list ;
85296: LD_ADDR_VAR 0 4
85300: PUSH
85301: LD_VAR 0 5
85305: ST_TO_ADDR
// end ;
85306: LD_VAR 0 4
85310: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85311: LD_INT 0
85313: PPUSH
85314: PPUSH
85315: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85316: LD_VAR 0 1
85320: NOT
85321: PUSH
85322: LD_VAR 0 2
85326: PUSH
85327: LD_INT 1
85329: PUSH
85330: LD_INT 2
85332: PUSH
85333: LD_INT 3
85335: PUSH
85336: LD_INT 4
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: IN
85345: NOT
85346: OR
85347: IFFALSE 85351
// exit ;
85349: GO 85434
// tmp := [ ] ;
85351: LD_ADDR_VAR 0 5
85355: PUSH
85356: EMPTY
85357: ST_TO_ADDR
// for i in units do
85358: LD_ADDR_VAR 0 4
85362: PUSH
85363: LD_VAR 0 1
85367: PUSH
85368: FOR_IN
85369: IFFALSE 85403
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85371: LD_ADDR_VAR 0 5
85375: PUSH
85376: LD_VAR 0 5
85380: PPUSH
85381: LD_VAR 0 4
85385: PPUSH
85386: LD_VAR 0 2
85390: PPUSH
85391: CALL_OW 259
85395: PPUSH
85396: CALL 86807 0 2
85400: ST_TO_ADDR
85401: GO 85368
85403: POP
85404: POP
// if not tmp then
85405: LD_VAR 0 5
85409: NOT
85410: IFFALSE 85414
// exit ;
85412: GO 85434
// result := SortListByListDesc ( units , tmp ) ;
85414: LD_ADDR_VAR 0 3
85418: PUSH
85419: LD_VAR 0 1
85423: PPUSH
85424: LD_VAR 0 5
85428: PPUSH
85429: CALL_OW 77
85433: ST_TO_ADDR
// end ;
85434: LD_VAR 0 3
85438: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85439: LD_INT 0
85441: PPUSH
85442: PPUSH
85443: PPUSH
// result := false ;
85444: LD_ADDR_VAR 0 3
85448: PUSH
85449: LD_INT 0
85451: ST_TO_ADDR
// if not building then
85452: LD_VAR 0 2
85456: NOT
85457: IFFALSE 85461
// exit ;
85459: GO 85599
// x := GetX ( building ) ;
85461: LD_ADDR_VAR 0 4
85465: PUSH
85466: LD_VAR 0 2
85470: PPUSH
85471: CALL_OW 250
85475: ST_TO_ADDR
// y := GetY ( building ) ;
85476: LD_ADDR_VAR 0 5
85480: PUSH
85481: LD_VAR 0 2
85485: PPUSH
85486: CALL_OW 251
85490: ST_TO_ADDR
// if not x or not y then
85491: LD_VAR 0 4
85495: NOT
85496: PUSH
85497: LD_VAR 0 5
85501: NOT
85502: OR
85503: IFFALSE 85507
// exit ;
85505: GO 85599
// if GetTaskList ( unit ) then
85507: LD_VAR 0 1
85511: PPUSH
85512: CALL_OW 437
85516: IFFALSE 85599
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85518: LD_STRING e
85520: PUSH
85521: LD_VAR 0 1
85525: PPUSH
85526: CALL_OW 437
85530: PUSH
85531: LD_INT 1
85533: ARRAY
85534: PUSH
85535: LD_INT 1
85537: ARRAY
85538: EQUAL
85539: PUSH
85540: LD_VAR 0 4
85544: PUSH
85545: LD_VAR 0 1
85549: PPUSH
85550: CALL_OW 437
85554: PUSH
85555: LD_INT 1
85557: ARRAY
85558: PUSH
85559: LD_INT 2
85561: ARRAY
85562: EQUAL
85563: AND
85564: PUSH
85565: LD_VAR 0 5
85569: PUSH
85570: LD_VAR 0 1
85574: PPUSH
85575: CALL_OW 437
85579: PUSH
85580: LD_INT 1
85582: ARRAY
85583: PUSH
85584: LD_INT 3
85586: ARRAY
85587: EQUAL
85588: AND
85589: IFFALSE 85599
// result := true end ;
85591: LD_ADDR_VAR 0 3
85595: PUSH
85596: LD_INT 1
85598: ST_TO_ADDR
// end ;
85599: LD_VAR 0 3
85603: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85604: LD_INT 0
85606: PPUSH
// result := false ;
85607: LD_ADDR_VAR 0 4
85611: PUSH
85612: LD_INT 0
85614: ST_TO_ADDR
// if GetTaskList ( unit ) then
85615: LD_VAR 0 1
85619: PPUSH
85620: CALL_OW 437
85624: IFFALSE 85707
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85626: LD_STRING M
85628: PUSH
85629: LD_VAR 0 1
85633: PPUSH
85634: CALL_OW 437
85638: PUSH
85639: LD_INT 1
85641: ARRAY
85642: PUSH
85643: LD_INT 1
85645: ARRAY
85646: EQUAL
85647: PUSH
85648: LD_VAR 0 2
85652: PUSH
85653: LD_VAR 0 1
85657: PPUSH
85658: CALL_OW 437
85662: PUSH
85663: LD_INT 1
85665: ARRAY
85666: PUSH
85667: LD_INT 2
85669: ARRAY
85670: EQUAL
85671: AND
85672: PUSH
85673: LD_VAR 0 3
85677: PUSH
85678: LD_VAR 0 1
85682: PPUSH
85683: CALL_OW 437
85687: PUSH
85688: LD_INT 1
85690: ARRAY
85691: PUSH
85692: LD_INT 3
85694: ARRAY
85695: EQUAL
85696: AND
85697: IFFALSE 85707
// result := true ;
85699: LD_ADDR_VAR 0 4
85703: PUSH
85704: LD_INT 1
85706: ST_TO_ADDR
// end ; end ;
85707: LD_VAR 0 4
85711: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85712: LD_INT 0
85714: PPUSH
85715: PPUSH
85716: PPUSH
85717: PPUSH
// if not unit or not area then
85718: LD_VAR 0 1
85722: NOT
85723: PUSH
85724: LD_VAR 0 2
85728: NOT
85729: OR
85730: IFFALSE 85734
// exit ;
85732: GO 85910
// tmp := AreaToList ( area , i ) ;
85734: LD_ADDR_VAR 0 6
85738: PUSH
85739: LD_VAR 0 2
85743: PPUSH
85744: LD_VAR 0 5
85748: PPUSH
85749: CALL_OW 517
85753: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85754: LD_ADDR_VAR 0 5
85758: PUSH
85759: DOUBLE
85760: LD_INT 1
85762: DEC
85763: ST_TO_ADDR
85764: LD_VAR 0 6
85768: PUSH
85769: LD_INT 1
85771: ARRAY
85772: PUSH
85773: FOR_TO
85774: IFFALSE 85908
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85776: LD_ADDR_VAR 0 7
85780: PUSH
85781: LD_VAR 0 6
85785: PUSH
85786: LD_INT 1
85788: ARRAY
85789: PUSH
85790: LD_VAR 0 5
85794: ARRAY
85795: PUSH
85796: LD_VAR 0 6
85800: PUSH
85801: LD_INT 2
85803: ARRAY
85804: PUSH
85805: LD_VAR 0 5
85809: ARRAY
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
85815: LD_INT 92
85817: PUSH
85818: LD_VAR 0 7
85822: PUSH
85823: LD_INT 1
85825: ARRAY
85826: PUSH
85827: LD_VAR 0 7
85831: PUSH
85832: LD_INT 2
85834: ARRAY
85835: PUSH
85836: LD_INT 2
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: PPUSH
85845: CALL_OW 69
85849: PUSH
85850: LD_INT 0
85852: EQUAL
85853: IFFALSE 85906
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85855: LD_VAR 0 1
85859: PPUSH
85860: LD_VAR 0 7
85864: PUSH
85865: LD_INT 1
85867: ARRAY
85868: PPUSH
85869: LD_VAR 0 7
85873: PUSH
85874: LD_INT 2
85876: ARRAY
85877: PPUSH
85878: LD_VAR 0 3
85882: PPUSH
85883: CALL_OW 48
// result := IsPlaced ( unit ) ;
85887: LD_ADDR_VAR 0 4
85891: PUSH
85892: LD_VAR 0 1
85896: PPUSH
85897: CALL_OW 305
85901: ST_TO_ADDR
// exit ;
85902: POP
85903: POP
85904: GO 85910
// end ; end ;
85906: GO 85773
85908: POP
85909: POP
// end ;
85910: LD_VAR 0 4
85914: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85915: LD_INT 0
85917: PPUSH
85918: PPUSH
85919: PPUSH
// if not side or side > 8 then
85920: LD_VAR 0 1
85924: NOT
85925: PUSH
85926: LD_VAR 0 1
85930: PUSH
85931: LD_INT 8
85933: GREATER
85934: OR
85935: IFFALSE 85939
// exit ;
85937: GO 86126
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85939: LD_ADDR_VAR 0 4
85943: PUSH
85944: LD_INT 22
85946: PUSH
85947: LD_VAR 0 1
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 21
85958: PUSH
85959: LD_INT 3
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PPUSH
85970: CALL_OW 69
85974: ST_TO_ADDR
// if not tmp then
85975: LD_VAR 0 4
85979: NOT
85980: IFFALSE 85984
// exit ;
85982: GO 86126
// enable_addtolog := true ;
85984: LD_ADDR_OWVAR 81
85988: PUSH
85989: LD_INT 1
85991: ST_TO_ADDR
// AddToLog ( [ ) ;
85992: LD_STRING [
85994: PPUSH
85995: CALL_OW 561
// for i in tmp do
85999: LD_ADDR_VAR 0 3
86003: PUSH
86004: LD_VAR 0 4
86008: PUSH
86009: FOR_IN
86010: IFFALSE 86117
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86012: LD_STRING [
86014: PUSH
86015: LD_VAR 0 3
86019: PPUSH
86020: CALL_OW 266
86024: STR
86025: PUSH
86026: LD_STRING , 
86028: STR
86029: PUSH
86030: LD_VAR 0 3
86034: PPUSH
86035: CALL_OW 250
86039: STR
86040: PUSH
86041: LD_STRING , 
86043: STR
86044: PUSH
86045: LD_VAR 0 3
86049: PPUSH
86050: CALL_OW 251
86054: STR
86055: PUSH
86056: LD_STRING , 
86058: STR
86059: PUSH
86060: LD_VAR 0 3
86064: PPUSH
86065: CALL_OW 254
86069: STR
86070: PUSH
86071: LD_STRING , 
86073: STR
86074: PUSH
86075: LD_VAR 0 3
86079: PPUSH
86080: LD_INT 1
86082: PPUSH
86083: CALL_OW 268
86087: STR
86088: PUSH
86089: LD_STRING , 
86091: STR
86092: PUSH
86093: LD_VAR 0 3
86097: PPUSH
86098: LD_INT 2
86100: PPUSH
86101: CALL_OW 268
86105: STR
86106: PUSH
86107: LD_STRING ],
86109: STR
86110: PPUSH
86111: CALL_OW 561
// end ;
86115: GO 86009
86117: POP
86118: POP
// AddToLog ( ]; ) ;
86119: LD_STRING ];
86121: PPUSH
86122: CALL_OW 561
// end ;
86126: LD_VAR 0 2
86130: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86131: LD_INT 0
86133: PPUSH
86134: PPUSH
86135: PPUSH
86136: PPUSH
86137: PPUSH
// if not area or not rate or not max then
86138: LD_VAR 0 1
86142: NOT
86143: PUSH
86144: LD_VAR 0 2
86148: NOT
86149: OR
86150: PUSH
86151: LD_VAR 0 4
86155: NOT
86156: OR
86157: IFFALSE 86161
// exit ;
86159: GO 86350
// while 1 do
86161: LD_INT 1
86163: IFFALSE 86350
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86165: LD_ADDR_VAR 0 9
86169: PUSH
86170: LD_VAR 0 1
86174: PPUSH
86175: LD_INT 1
86177: PPUSH
86178: CALL_OW 287
86182: PUSH
86183: LD_INT 10
86185: MUL
86186: ST_TO_ADDR
// r := rate / 10 ;
86187: LD_ADDR_VAR 0 7
86191: PUSH
86192: LD_VAR 0 2
86196: PUSH
86197: LD_INT 10
86199: DIVREAL
86200: ST_TO_ADDR
// time := 1 1$00 ;
86201: LD_ADDR_VAR 0 8
86205: PUSH
86206: LD_INT 2100
86208: ST_TO_ADDR
// if amount < min then
86209: LD_VAR 0 9
86213: PUSH
86214: LD_VAR 0 3
86218: LESS
86219: IFFALSE 86237
// r := r * 2 else
86221: LD_ADDR_VAR 0 7
86225: PUSH
86226: LD_VAR 0 7
86230: PUSH
86231: LD_INT 2
86233: MUL
86234: ST_TO_ADDR
86235: GO 86263
// if amount > max then
86237: LD_VAR 0 9
86241: PUSH
86242: LD_VAR 0 4
86246: GREATER
86247: IFFALSE 86263
// r := r / 2 ;
86249: LD_ADDR_VAR 0 7
86253: PUSH
86254: LD_VAR 0 7
86258: PUSH
86259: LD_INT 2
86261: DIVREAL
86262: ST_TO_ADDR
// time := time / r ;
86263: LD_ADDR_VAR 0 8
86267: PUSH
86268: LD_VAR 0 8
86272: PUSH
86273: LD_VAR 0 7
86277: DIVREAL
86278: ST_TO_ADDR
// if time < 0 then
86279: LD_VAR 0 8
86283: PUSH
86284: LD_INT 0
86286: LESS
86287: IFFALSE 86304
// time := time * - 1 ;
86289: LD_ADDR_VAR 0 8
86293: PUSH
86294: LD_VAR 0 8
86298: PUSH
86299: LD_INT 1
86301: NEG
86302: MUL
86303: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
86304: LD_VAR 0 8
86308: PUSH
86309: LD_INT 35
86311: PPUSH
86312: LD_INT 875
86314: PPUSH
86315: CALL_OW 12
86319: PLUS
86320: PPUSH
86321: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86325: LD_INT 1
86327: PPUSH
86328: LD_INT 5
86330: PPUSH
86331: CALL_OW 12
86335: PPUSH
86336: LD_VAR 0 1
86340: PPUSH
86341: LD_INT 1
86343: PPUSH
86344: CALL_OW 55
// end ;
86348: GO 86161
// end ;
86350: LD_VAR 0 5
86354: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86355: LD_INT 0
86357: PPUSH
86358: PPUSH
86359: PPUSH
86360: PPUSH
86361: PPUSH
86362: PPUSH
86363: PPUSH
86364: PPUSH
// if not turrets or not factories then
86365: LD_VAR 0 1
86369: NOT
86370: PUSH
86371: LD_VAR 0 2
86375: NOT
86376: OR
86377: IFFALSE 86381
// exit ;
86379: GO 86688
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86381: LD_ADDR_VAR 0 10
86385: PUSH
86386: LD_INT 5
86388: PUSH
86389: LD_INT 6
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 2
86398: PUSH
86399: LD_INT 4
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 3
86408: PUSH
86409: LD_INT 5
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 24
86423: PUSH
86424: LD_INT 25
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 23
86433: PUSH
86434: LD_INT 27
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 42
86447: PUSH
86448: LD_INT 43
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: LD_INT 44
86457: PUSH
86458: LD_INT 46
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 45
86467: PUSH
86468: LD_INT 47
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: LIST
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: LIST
86484: ST_TO_ADDR
// result := [ ] ;
86485: LD_ADDR_VAR 0 3
86489: PUSH
86490: EMPTY
86491: ST_TO_ADDR
// for i in turrets do
86492: LD_ADDR_VAR 0 4
86496: PUSH
86497: LD_VAR 0 1
86501: PUSH
86502: FOR_IN
86503: IFFALSE 86686
// begin nat := GetNation ( i ) ;
86505: LD_ADDR_VAR 0 7
86509: PUSH
86510: LD_VAR 0 4
86514: PPUSH
86515: CALL_OW 248
86519: ST_TO_ADDR
// weapon := 0 ;
86520: LD_ADDR_VAR 0 8
86524: PUSH
86525: LD_INT 0
86527: ST_TO_ADDR
// if not nat then
86528: LD_VAR 0 7
86532: NOT
86533: IFFALSE 86537
// continue ;
86535: GO 86502
// for j in list [ nat ] do
86537: LD_ADDR_VAR 0 5
86541: PUSH
86542: LD_VAR 0 10
86546: PUSH
86547: LD_VAR 0 7
86551: ARRAY
86552: PUSH
86553: FOR_IN
86554: IFFALSE 86595
// if GetBWeapon ( i ) = j [ 1 ] then
86556: LD_VAR 0 4
86560: PPUSH
86561: CALL_OW 269
86565: PUSH
86566: LD_VAR 0 5
86570: PUSH
86571: LD_INT 1
86573: ARRAY
86574: EQUAL
86575: IFFALSE 86593
// begin weapon := j [ 2 ] ;
86577: LD_ADDR_VAR 0 8
86581: PUSH
86582: LD_VAR 0 5
86586: PUSH
86587: LD_INT 2
86589: ARRAY
86590: ST_TO_ADDR
// break ;
86591: GO 86595
// end ;
86593: GO 86553
86595: POP
86596: POP
// if not weapon then
86597: LD_VAR 0 8
86601: NOT
86602: IFFALSE 86606
// continue ;
86604: GO 86502
// for k in factories do
86606: LD_ADDR_VAR 0 6
86610: PUSH
86611: LD_VAR 0 2
86615: PUSH
86616: FOR_IN
86617: IFFALSE 86682
// begin weapons := AvailableWeaponList ( k ) ;
86619: LD_ADDR_VAR 0 9
86623: PUSH
86624: LD_VAR 0 6
86628: PPUSH
86629: CALL_OW 478
86633: ST_TO_ADDR
// if not weapons then
86634: LD_VAR 0 9
86638: NOT
86639: IFFALSE 86643
// continue ;
86641: GO 86616
// if weapon in weapons then
86643: LD_VAR 0 8
86647: PUSH
86648: LD_VAR 0 9
86652: IN
86653: IFFALSE 86680
// begin result := [ i , weapon ] ;
86655: LD_ADDR_VAR 0 3
86659: PUSH
86660: LD_VAR 0 4
86664: PUSH
86665: LD_VAR 0 8
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: ST_TO_ADDR
// exit ;
86674: POP
86675: POP
86676: POP
86677: POP
86678: GO 86688
// end ; end ;
86680: GO 86616
86682: POP
86683: POP
// end ;
86684: GO 86502
86686: POP
86687: POP
// end ;
86688: LD_VAR 0 3
86692: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86693: LD_INT 0
86695: PPUSH
// if not side or side > 8 then
86696: LD_VAR 0 3
86700: NOT
86701: PUSH
86702: LD_VAR 0 3
86706: PUSH
86707: LD_INT 8
86709: GREATER
86710: OR
86711: IFFALSE 86715
// exit ;
86713: GO 86774
// if not range then
86715: LD_VAR 0 4
86719: NOT
86720: IFFALSE 86731
// range := - 12 ;
86722: LD_ADDR_VAR 0 4
86726: PUSH
86727: LD_INT 12
86729: NEG
86730: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86731: LD_VAR 0 1
86735: PPUSH
86736: LD_VAR 0 2
86740: PPUSH
86741: LD_VAR 0 3
86745: PPUSH
86746: LD_VAR 0 4
86750: PPUSH
86751: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86755: LD_VAR 0 1
86759: PPUSH
86760: LD_VAR 0 2
86764: PPUSH
86765: LD_VAR 0 3
86769: PPUSH
86770: CALL_OW 331
// end ;
86774: LD_VAR 0 5
86778: RET
// export function Video ( mode ) ; begin
86779: LD_INT 0
86781: PPUSH
// ingame_video = mode ;
86782: LD_ADDR_OWVAR 52
86786: PUSH
86787: LD_VAR 0 1
86791: ST_TO_ADDR
// interface_hidden = mode ;
86792: LD_ADDR_OWVAR 54
86796: PUSH
86797: LD_VAR 0 1
86801: ST_TO_ADDR
// end ;
86802: LD_VAR 0 2
86806: RET
// export function Join ( array , element ) ; begin
86807: LD_INT 0
86809: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86810: LD_ADDR_VAR 0 3
86814: PUSH
86815: LD_VAR 0 1
86819: PPUSH
86820: LD_VAR 0 1
86824: PUSH
86825: LD_INT 1
86827: PLUS
86828: PPUSH
86829: LD_VAR 0 2
86833: PPUSH
86834: CALL_OW 1
86838: ST_TO_ADDR
// end ;
86839: LD_VAR 0 3
86843: RET
// export function JoinUnion ( array , element ) ; begin
86844: LD_INT 0
86846: PPUSH
// result := array union element ;
86847: LD_ADDR_VAR 0 3
86851: PUSH
86852: LD_VAR 0 1
86856: PUSH
86857: LD_VAR 0 2
86861: UNION
86862: ST_TO_ADDR
// end ;
86863: LD_VAR 0 3
86867: RET
// export function GetBehemoths ( side ) ; begin
86868: LD_INT 0
86870: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86871: LD_ADDR_VAR 0 2
86875: PUSH
86876: LD_INT 22
86878: PUSH
86879: LD_VAR 0 1
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 31
86890: PUSH
86891: LD_INT 25
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PPUSH
86902: CALL_OW 69
86906: ST_TO_ADDR
// end ;
86907: LD_VAR 0 2
86911: RET
// export function Shuffle ( array ) ; var i , index ; begin
86912: LD_INT 0
86914: PPUSH
86915: PPUSH
86916: PPUSH
// result := [ ] ;
86917: LD_ADDR_VAR 0 2
86921: PUSH
86922: EMPTY
86923: ST_TO_ADDR
// if not array then
86924: LD_VAR 0 1
86928: NOT
86929: IFFALSE 86933
// exit ;
86931: GO 87032
// Randomize ;
86933: CALL_OW 10
// for i = array downto 1 do
86937: LD_ADDR_VAR 0 3
86941: PUSH
86942: DOUBLE
86943: LD_VAR 0 1
86947: INC
86948: ST_TO_ADDR
86949: LD_INT 1
86951: PUSH
86952: FOR_DOWNTO
86953: IFFALSE 87030
// begin index := rand ( 1 , array ) ;
86955: LD_ADDR_VAR 0 4
86959: PUSH
86960: LD_INT 1
86962: PPUSH
86963: LD_VAR 0 1
86967: PPUSH
86968: CALL_OW 12
86972: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86973: LD_ADDR_VAR 0 2
86977: PUSH
86978: LD_VAR 0 2
86982: PPUSH
86983: LD_VAR 0 2
86987: PUSH
86988: LD_INT 1
86990: PLUS
86991: PPUSH
86992: LD_VAR 0 1
86996: PUSH
86997: LD_VAR 0 4
87001: ARRAY
87002: PPUSH
87003: CALL_OW 2
87007: ST_TO_ADDR
// array := Delete ( array , index ) ;
87008: LD_ADDR_VAR 0 1
87012: PUSH
87013: LD_VAR 0 1
87017: PPUSH
87018: LD_VAR 0 4
87022: PPUSH
87023: CALL_OW 3
87027: ST_TO_ADDR
// end ;
87028: GO 86952
87030: POP
87031: POP
// end ;
87032: LD_VAR 0 2
87036: RET
// export function GetBaseMaterials ( base ) ; begin
87037: LD_INT 0
87039: PPUSH
// result := [ 0 , 0 , 0 ] ;
87040: LD_ADDR_VAR 0 2
87044: PUSH
87045: LD_INT 0
87047: PUSH
87048: LD_INT 0
87050: PUSH
87051: LD_INT 0
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: LIST
87058: ST_TO_ADDR
// if not base then
87059: LD_VAR 0 1
87063: NOT
87064: IFFALSE 87068
// exit ;
87066: GO 87117
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87068: LD_ADDR_VAR 0 2
87072: PUSH
87073: LD_VAR 0 1
87077: PPUSH
87078: LD_INT 1
87080: PPUSH
87081: CALL_OW 275
87085: PUSH
87086: LD_VAR 0 1
87090: PPUSH
87091: LD_INT 2
87093: PPUSH
87094: CALL_OW 275
87098: PUSH
87099: LD_VAR 0 1
87103: PPUSH
87104: LD_INT 3
87106: PPUSH
87107: CALL_OW 275
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: LIST
87116: ST_TO_ADDR
// end ;
87117: LD_VAR 0 2
87121: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87122: LD_INT 0
87124: PPUSH
87125: PPUSH
// result := array ;
87126: LD_ADDR_VAR 0 3
87130: PUSH
87131: LD_VAR 0 1
87135: ST_TO_ADDR
// if size >= result then
87136: LD_VAR 0 2
87140: PUSH
87141: LD_VAR 0 3
87145: GREATEREQUAL
87146: IFFALSE 87150
// exit ;
87148: GO 87200
// if size then
87150: LD_VAR 0 2
87154: IFFALSE 87200
// for i := array downto size do
87156: LD_ADDR_VAR 0 4
87160: PUSH
87161: DOUBLE
87162: LD_VAR 0 1
87166: INC
87167: ST_TO_ADDR
87168: LD_VAR 0 2
87172: PUSH
87173: FOR_DOWNTO
87174: IFFALSE 87198
// result := Delete ( result , result ) ;
87176: LD_ADDR_VAR 0 3
87180: PUSH
87181: LD_VAR 0 3
87185: PPUSH
87186: LD_VAR 0 3
87190: PPUSH
87191: CALL_OW 3
87195: ST_TO_ADDR
87196: GO 87173
87198: POP
87199: POP
// end ;
87200: LD_VAR 0 3
87204: RET
// export function ComExit ( unit ) ; var tmp ; begin
87205: LD_INT 0
87207: PPUSH
87208: PPUSH
// if not IsInUnit ( unit ) then
87209: LD_VAR 0 1
87213: PPUSH
87214: CALL_OW 310
87218: NOT
87219: IFFALSE 87223
// exit ;
87221: GO 87283
// tmp := IsInUnit ( unit ) ;
87223: LD_ADDR_VAR 0 3
87227: PUSH
87228: LD_VAR 0 1
87232: PPUSH
87233: CALL_OW 310
87237: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87238: LD_VAR 0 3
87242: PPUSH
87243: CALL_OW 247
87247: PUSH
87248: LD_INT 2
87250: EQUAL
87251: IFFALSE 87264
// ComExitVehicle ( unit ) else
87253: LD_VAR 0 1
87257: PPUSH
87258: CALL_OW 121
87262: GO 87273
// ComExitBuilding ( unit ) ;
87264: LD_VAR 0 1
87268: PPUSH
87269: CALL_OW 122
// result := tmp ;
87273: LD_ADDR_VAR 0 2
87277: PUSH
87278: LD_VAR 0 3
87282: ST_TO_ADDR
// end ;
87283: LD_VAR 0 2
87287: RET
// export function ComExitAll ( units ) ; var i ; begin
87288: LD_INT 0
87290: PPUSH
87291: PPUSH
// if not units then
87292: LD_VAR 0 1
87296: NOT
87297: IFFALSE 87301
// exit ;
87299: GO 87327
// for i in units do
87301: LD_ADDR_VAR 0 3
87305: PUSH
87306: LD_VAR 0 1
87310: PUSH
87311: FOR_IN
87312: IFFALSE 87325
// ComExit ( i ) ;
87314: LD_VAR 0 3
87318: PPUSH
87319: CALL 87205 0 1
87323: GO 87311
87325: POP
87326: POP
// end ;
87327: LD_VAR 0 2
87331: RET
// export function ResetHc ; begin
87332: LD_INT 0
87334: PPUSH
// InitHc ;
87335: CALL_OW 19
// hc_importance := 0 ;
87339: LD_ADDR_OWVAR 32
87343: PUSH
87344: LD_INT 0
87346: ST_TO_ADDR
// end ;
87347: LD_VAR 0 1
87351: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87352: LD_INT 0
87354: PPUSH
87355: PPUSH
87356: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87357: LD_ADDR_VAR 0 6
87361: PUSH
87362: LD_VAR 0 1
87366: PUSH
87367: LD_VAR 0 3
87371: PLUS
87372: PUSH
87373: LD_INT 2
87375: DIV
87376: ST_TO_ADDR
// if _x < 0 then
87377: LD_VAR 0 6
87381: PUSH
87382: LD_INT 0
87384: LESS
87385: IFFALSE 87402
// _x := _x * - 1 ;
87387: LD_ADDR_VAR 0 6
87391: PUSH
87392: LD_VAR 0 6
87396: PUSH
87397: LD_INT 1
87399: NEG
87400: MUL
87401: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87402: LD_ADDR_VAR 0 7
87406: PUSH
87407: LD_VAR 0 2
87411: PUSH
87412: LD_VAR 0 4
87416: PLUS
87417: PUSH
87418: LD_INT 2
87420: DIV
87421: ST_TO_ADDR
// if _y < 0 then
87422: LD_VAR 0 7
87426: PUSH
87427: LD_INT 0
87429: LESS
87430: IFFALSE 87447
// _y := _y * - 1 ;
87432: LD_ADDR_VAR 0 7
87436: PUSH
87437: LD_VAR 0 7
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: MUL
87446: ST_TO_ADDR
// result := [ _x , _y ] ;
87447: LD_ADDR_VAR 0 5
87451: PUSH
87452: LD_VAR 0 6
87456: PUSH
87457: LD_VAR 0 7
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: ST_TO_ADDR
// end ;
87466: LD_VAR 0 5
87470: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87471: LD_INT 0
87473: PPUSH
87474: PPUSH
87475: PPUSH
87476: PPUSH
// task := GetTaskList ( unit ) ;
87477: LD_ADDR_VAR 0 7
87481: PUSH
87482: LD_VAR 0 1
87486: PPUSH
87487: CALL_OW 437
87491: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87492: LD_VAR 0 7
87496: NOT
87497: PUSH
87498: LD_VAR 0 1
87502: PPUSH
87503: LD_VAR 0 2
87507: PPUSH
87508: CALL_OW 308
87512: NOT
87513: AND
87514: IFFALSE 87518
// exit ;
87516: GO 87636
// if IsInArea ( unit , area ) then
87518: LD_VAR 0 1
87522: PPUSH
87523: LD_VAR 0 2
87527: PPUSH
87528: CALL_OW 308
87532: IFFALSE 87550
// begin ComMoveToArea ( unit , goAway ) ;
87534: LD_VAR 0 1
87538: PPUSH
87539: LD_VAR 0 3
87543: PPUSH
87544: CALL_OW 113
// exit ;
87548: GO 87636
// end ; if task [ 1 ] [ 1 ] <> M then
87550: LD_VAR 0 7
87554: PUSH
87555: LD_INT 1
87557: ARRAY
87558: PUSH
87559: LD_INT 1
87561: ARRAY
87562: PUSH
87563: LD_STRING M
87565: NONEQUAL
87566: IFFALSE 87570
// exit ;
87568: GO 87636
// x := task [ 1 ] [ 2 ] ;
87570: LD_ADDR_VAR 0 5
87574: PUSH
87575: LD_VAR 0 7
87579: PUSH
87580: LD_INT 1
87582: ARRAY
87583: PUSH
87584: LD_INT 2
87586: ARRAY
87587: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87588: LD_ADDR_VAR 0 6
87592: PUSH
87593: LD_VAR 0 7
87597: PUSH
87598: LD_INT 1
87600: ARRAY
87601: PUSH
87602: LD_INT 3
87604: ARRAY
87605: ST_TO_ADDR
// if InArea ( x , y , area ) then
87606: LD_VAR 0 5
87610: PPUSH
87611: LD_VAR 0 6
87615: PPUSH
87616: LD_VAR 0 2
87620: PPUSH
87621: CALL_OW 309
87625: IFFALSE 87636
// ComStop ( unit ) ;
87627: LD_VAR 0 1
87631: PPUSH
87632: CALL_OW 141
// end ;
87636: LD_VAR 0 4
87640: RET
// export function Abs ( value ) ; begin
87641: LD_INT 0
87643: PPUSH
// result := value ;
87644: LD_ADDR_VAR 0 2
87648: PUSH
87649: LD_VAR 0 1
87653: ST_TO_ADDR
// if value < 0 then
87654: LD_VAR 0 1
87658: PUSH
87659: LD_INT 0
87661: LESS
87662: IFFALSE 87679
// result := value * - 1 ;
87664: LD_ADDR_VAR 0 2
87668: PUSH
87669: LD_VAR 0 1
87673: PUSH
87674: LD_INT 1
87676: NEG
87677: MUL
87678: ST_TO_ADDR
// end ;
87679: LD_VAR 0 2
87683: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87684: LD_INT 0
87686: PPUSH
87687: PPUSH
87688: PPUSH
87689: PPUSH
87690: PPUSH
87691: PPUSH
87692: PPUSH
87693: PPUSH
// if not unit or not building then
87694: LD_VAR 0 1
87698: NOT
87699: PUSH
87700: LD_VAR 0 2
87704: NOT
87705: OR
87706: IFFALSE 87710
// exit ;
87708: GO 87936
// x := GetX ( building ) ;
87710: LD_ADDR_VAR 0 4
87714: PUSH
87715: LD_VAR 0 2
87719: PPUSH
87720: CALL_OW 250
87724: ST_TO_ADDR
// y := GetY ( building ) ;
87725: LD_ADDR_VAR 0 6
87729: PUSH
87730: LD_VAR 0 2
87734: PPUSH
87735: CALL_OW 251
87739: ST_TO_ADDR
// d := GetDir ( building ) ;
87740: LD_ADDR_VAR 0 8
87744: PUSH
87745: LD_VAR 0 2
87749: PPUSH
87750: CALL_OW 254
87754: ST_TO_ADDR
// r := 4 ;
87755: LD_ADDR_VAR 0 9
87759: PUSH
87760: LD_INT 4
87762: ST_TO_ADDR
// for i := 1 to 5 do
87763: LD_ADDR_VAR 0 10
87767: PUSH
87768: DOUBLE
87769: LD_INT 1
87771: DEC
87772: ST_TO_ADDR
87773: LD_INT 5
87775: PUSH
87776: FOR_TO
87777: IFFALSE 87934
// begin _x := ShiftX ( x , d , r + i ) ;
87779: LD_ADDR_VAR 0 5
87783: PUSH
87784: LD_VAR 0 4
87788: PPUSH
87789: LD_VAR 0 8
87793: PPUSH
87794: LD_VAR 0 9
87798: PUSH
87799: LD_VAR 0 10
87803: PLUS
87804: PPUSH
87805: CALL_OW 272
87809: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87810: LD_ADDR_VAR 0 7
87814: PUSH
87815: LD_VAR 0 6
87819: PPUSH
87820: LD_VAR 0 8
87824: PPUSH
87825: LD_VAR 0 9
87829: PUSH
87830: LD_VAR 0 10
87834: PLUS
87835: PPUSH
87836: CALL_OW 273
87840: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87841: LD_VAR 0 5
87845: PPUSH
87846: LD_VAR 0 7
87850: PPUSH
87851: CALL_OW 488
87855: PUSH
87856: LD_VAR 0 5
87860: PPUSH
87861: LD_VAR 0 7
87865: PPUSH
87866: CALL_OW 428
87870: PPUSH
87871: CALL_OW 247
87875: PUSH
87876: LD_INT 3
87878: PUSH
87879: LD_INT 2
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: IN
87886: NOT
87887: AND
87888: IFFALSE 87932
// begin ComMoveXY ( unit , _x , _y ) ;
87890: LD_VAR 0 1
87894: PPUSH
87895: LD_VAR 0 5
87899: PPUSH
87900: LD_VAR 0 7
87904: PPUSH
87905: CALL_OW 111
// result := [ _x , _y ] ;
87909: LD_ADDR_VAR 0 3
87913: PUSH
87914: LD_VAR 0 5
87918: PUSH
87919: LD_VAR 0 7
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: ST_TO_ADDR
// exit ;
87928: POP
87929: POP
87930: GO 87936
// end ; end ;
87932: GO 87776
87934: POP
87935: POP
// end ;
87936: LD_VAR 0 3
87940: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87941: LD_INT 0
87943: PPUSH
87944: PPUSH
87945: PPUSH
// result := 0 ;
87946: LD_ADDR_VAR 0 3
87950: PUSH
87951: LD_INT 0
87953: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87954: LD_VAR 0 1
87958: PUSH
87959: LD_INT 0
87961: LESS
87962: PUSH
87963: LD_VAR 0 1
87967: PUSH
87968: LD_INT 8
87970: GREATER
87971: OR
87972: PUSH
87973: LD_VAR 0 2
87977: PUSH
87978: LD_INT 0
87980: LESS
87981: OR
87982: PUSH
87983: LD_VAR 0 2
87987: PUSH
87988: LD_INT 8
87990: GREATER
87991: OR
87992: IFFALSE 87996
// exit ;
87994: GO 88071
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87996: LD_ADDR_VAR 0 4
88000: PUSH
88001: LD_INT 22
88003: PUSH
88004: LD_VAR 0 2
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PPUSH
88013: CALL_OW 69
88017: PUSH
88018: FOR_IN
88019: IFFALSE 88069
// begin un := UnitShoot ( i ) ;
88021: LD_ADDR_VAR 0 5
88025: PUSH
88026: LD_VAR 0 4
88030: PPUSH
88031: CALL_OW 504
88035: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88036: LD_VAR 0 5
88040: PPUSH
88041: CALL_OW 255
88045: PUSH
88046: LD_VAR 0 1
88050: EQUAL
88051: IFFALSE 88067
// begin result := un ;
88053: LD_ADDR_VAR 0 3
88057: PUSH
88058: LD_VAR 0 5
88062: ST_TO_ADDR
// exit ;
88063: POP
88064: POP
88065: GO 88071
// end ; end ;
88067: GO 88018
88069: POP
88070: POP
// end ;
88071: LD_VAR 0 3
88075: RET
// export function GetCargoBay ( units ) ; begin
88076: LD_INT 0
88078: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88079: LD_ADDR_VAR 0 2
88083: PUSH
88084: LD_VAR 0 1
88088: PPUSH
88089: LD_INT 2
88091: PUSH
88092: LD_INT 34
88094: PUSH
88095: LD_INT 12
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PUSH
88102: LD_INT 34
88104: PUSH
88105: LD_INT 51
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 34
88114: PUSH
88115: LD_INT 32
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 34
88124: PUSH
88125: LD_INT 89
88127: PUSH
88128: EMPTY
88129: LIST
88130: LIST
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: PPUSH
88139: CALL_OW 72
88143: ST_TO_ADDR
// end ;
88144: LD_VAR 0 2
88148: RET
// export function Negate ( value ) ; begin
88149: LD_INT 0
88151: PPUSH
// result := not value ;
88152: LD_ADDR_VAR 0 2
88156: PUSH
88157: LD_VAR 0 1
88161: NOT
88162: ST_TO_ADDR
// end ;
88163: LD_VAR 0 2
88167: RET
// export function Inc ( value ) ; begin
88168: LD_INT 0
88170: PPUSH
// result := value + 1 ;
88171: LD_ADDR_VAR 0 2
88175: PUSH
88176: LD_VAR 0 1
88180: PUSH
88181: LD_INT 1
88183: PLUS
88184: ST_TO_ADDR
// end ;
88185: LD_VAR 0 2
88189: RET
// export function Dec ( value ) ; begin
88190: LD_INT 0
88192: PPUSH
// result := value - 1 ;
88193: LD_ADDR_VAR 0 2
88197: PUSH
88198: LD_VAR 0 1
88202: PUSH
88203: LD_INT 1
88205: MINUS
88206: ST_TO_ADDR
// end ;
88207: LD_VAR 0 2
88211: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
88212: LD_INT 0
88214: PPUSH
88215: PPUSH
88216: PPUSH
88217: PPUSH
88218: PPUSH
88219: PPUSH
88220: PPUSH
88221: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
88222: LD_VAR 0 1
88226: PPUSH
88227: LD_VAR 0 2
88231: PPUSH
88232: CALL_OW 488
88236: NOT
88237: PUSH
88238: LD_VAR 0 3
88242: PPUSH
88243: LD_VAR 0 4
88247: PPUSH
88248: CALL_OW 488
88252: NOT
88253: OR
88254: IFFALSE 88267
// begin result := - 1 ;
88256: LD_ADDR_VAR 0 5
88260: PUSH
88261: LD_INT 1
88263: NEG
88264: ST_TO_ADDR
// exit ;
88265: GO 88502
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
88267: LD_ADDR_VAR 0 12
88271: PUSH
88272: LD_VAR 0 1
88276: PPUSH
88277: LD_VAR 0 2
88281: PPUSH
88282: LD_VAR 0 3
88286: PPUSH
88287: LD_VAR 0 4
88291: PPUSH
88292: CALL 87352 0 4
88296: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
88297: LD_ADDR_VAR 0 11
88301: PUSH
88302: LD_VAR 0 1
88306: PPUSH
88307: LD_VAR 0 2
88311: PPUSH
88312: LD_VAR 0 12
88316: PUSH
88317: LD_INT 1
88319: ARRAY
88320: PPUSH
88321: LD_VAR 0 12
88325: PUSH
88326: LD_INT 2
88328: ARRAY
88329: PPUSH
88330: CALL_OW 298
88334: ST_TO_ADDR
// distance := 9999 ;
88335: LD_ADDR_VAR 0 10
88339: PUSH
88340: LD_INT 9999
88342: ST_TO_ADDR
// for i := 0 to 5 do
88343: LD_ADDR_VAR 0 6
88347: PUSH
88348: DOUBLE
88349: LD_INT 0
88351: DEC
88352: ST_TO_ADDR
88353: LD_INT 5
88355: PUSH
88356: FOR_TO
88357: IFFALSE 88500
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88359: LD_ADDR_VAR 0 7
88363: PUSH
88364: LD_VAR 0 1
88368: PPUSH
88369: LD_VAR 0 6
88373: PPUSH
88374: LD_VAR 0 11
88378: PPUSH
88379: CALL_OW 272
88383: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88384: LD_ADDR_VAR 0 8
88388: PUSH
88389: LD_VAR 0 2
88393: PPUSH
88394: LD_VAR 0 6
88398: PPUSH
88399: LD_VAR 0 11
88403: PPUSH
88404: CALL_OW 273
88408: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88409: LD_VAR 0 7
88413: PPUSH
88414: LD_VAR 0 8
88418: PPUSH
88419: CALL_OW 488
88423: NOT
88424: IFFALSE 88428
// continue ;
88426: GO 88356
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88428: LD_ADDR_VAR 0 9
88432: PUSH
88433: LD_VAR 0 12
88437: PUSH
88438: LD_INT 1
88440: ARRAY
88441: PPUSH
88442: LD_VAR 0 12
88446: PUSH
88447: LD_INT 2
88449: ARRAY
88450: PPUSH
88451: LD_VAR 0 7
88455: PPUSH
88456: LD_VAR 0 8
88460: PPUSH
88461: CALL_OW 298
88465: ST_TO_ADDR
// if tmp < distance then
88466: LD_VAR 0 9
88470: PUSH
88471: LD_VAR 0 10
88475: LESS
88476: IFFALSE 88498
// begin result := i ;
88478: LD_ADDR_VAR 0 5
88482: PUSH
88483: LD_VAR 0 6
88487: ST_TO_ADDR
// distance := tmp ;
88488: LD_ADDR_VAR 0 10
88492: PUSH
88493: LD_VAR 0 9
88497: ST_TO_ADDR
// end ; end ;
88498: GO 88356
88500: POP
88501: POP
// end ;
88502: LD_VAR 0 5
88506: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88507: LD_INT 0
88509: PPUSH
88510: PPUSH
// if not driver or not IsInUnit ( driver ) then
88511: LD_VAR 0 1
88515: NOT
88516: PUSH
88517: LD_VAR 0 1
88521: PPUSH
88522: CALL_OW 310
88526: NOT
88527: OR
88528: IFFALSE 88532
// exit ;
88530: GO 88622
// vehicle := IsInUnit ( driver ) ;
88532: LD_ADDR_VAR 0 3
88536: PUSH
88537: LD_VAR 0 1
88541: PPUSH
88542: CALL_OW 310
88546: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88547: LD_VAR 0 1
88551: PPUSH
88552: LD_STRING \
88554: PUSH
88555: LD_INT 0
88557: PUSH
88558: LD_INT 0
88560: PUSH
88561: LD_INT 0
88563: PUSH
88564: LD_INT 0
88566: PUSH
88567: LD_INT 0
88569: PUSH
88570: LD_INT 0
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: PUSH
88582: LD_STRING E
88584: PUSH
88585: LD_INT 0
88587: PUSH
88588: LD_INT 0
88590: PUSH
88591: LD_VAR 0 3
88595: PUSH
88596: LD_INT 0
88598: PUSH
88599: LD_INT 0
88601: PUSH
88602: LD_INT 0
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PPUSH
88618: CALL_OW 446
// end ;
88622: LD_VAR 0 2
88626: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88627: LD_INT 0
88629: PPUSH
88630: PPUSH
// if not driver or not IsInUnit ( driver ) then
88631: LD_VAR 0 1
88635: NOT
88636: PUSH
88637: LD_VAR 0 1
88641: PPUSH
88642: CALL_OW 310
88646: NOT
88647: OR
88648: IFFALSE 88652
// exit ;
88650: GO 88742
// vehicle := IsInUnit ( driver ) ;
88652: LD_ADDR_VAR 0 3
88656: PUSH
88657: LD_VAR 0 1
88661: PPUSH
88662: CALL_OW 310
88666: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88667: LD_VAR 0 1
88671: PPUSH
88672: LD_STRING \
88674: PUSH
88675: LD_INT 0
88677: PUSH
88678: LD_INT 0
88680: PUSH
88681: LD_INT 0
88683: PUSH
88684: LD_INT 0
88686: PUSH
88687: LD_INT 0
88689: PUSH
88690: LD_INT 0
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: PUSH
88702: LD_STRING E
88704: PUSH
88705: LD_INT 0
88707: PUSH
88708: LD_INT 0
88710: PUSH
88711: LD_VAR 0 3
88715: PUSH
88716: LD_INT 0
88718: PUSH
88719: LD_INT 0
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PPUSH
88738: CALL_OW 447
// end ;
88742: LD_VAR 0 2
88746: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88747: LD_INT 0
88749: PPUSH
88750: PPUSH
88751: PPUSH
// tmp := [ ] ;
88752: LD_ADDR_VAR 0 5
88756: PUSH
88757: EMPTY
88758: ST_TO_ADDR
// for i in units do
88759: LD_ADDR_VAR 0 4
88763: PUSH
88764: LD_VAR 0 1
88768: PUSH
88769: FOR_IN
88770: IFFALSE 88808
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88772: LD_ADDR_VAR 0 5
88776: PUSH
88777: LD_VAR 0 5
88781: PPUSH
88782: LD_VAR 0 5
88786: PUSH
88787: LD_INT 1
88789: PLUS
88790: PPUSH
88791: LD_VAR 0 4
88795: PPUSH
88796: CALL_OW 256
88800: PPUSH
88801: CALL_OW 2
88805: ST_TO_ADDR
88806: GO 88769
88808: POP
88809: POP
// if not tmp then
88810: LD_VAR 0 5
88814: NOT
88815: IFFALSE 88819
// exit ;
88817: GO 88867
// if asc then
88819: LD_VAR 0 2
88823: IFFALSE 88847
// result := SortListByListAsc ( units , tmp ) else
88825: LD_ADDR_VAR 0 3
88829: PUSH
88830: LD_VAR 0 1
88834: PPUSH
88835: LD_VAR 0 5
88839: PPUSH
88840: CALL_OW 76
88844: ST_TO_ADDR
88845: GO 88867
// result := SortListByListDesc ( units , tmp ) ;
88847: LD_ADDR_VAR 0 3
88851: PUSH
88852: LD_VAR 0 1
88856: PPUSH
88857: LD_VAR 0 5
88861: PPUSH
88862: CALL_OW 77
88866: ST_TO_ADDR
// end ;
88867: LD_VAR 0 3
88871: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88872: LD_INT 0
88874: PPUSH
88875: PPUSH
// task := GetTaskList ( mech ) ;
88876: LD_ADDR_VAR 0 4
88880: PUSH
88881: LD_VAR 0 1
88885: PPUSH
88886: CALL_OW 437
88890: ST_TO_ADDR
// if not task then
88891: LD_VAR 0 4
88895: NOT
88896: IFFALSE 88900
// exit ;
88898: GO 88942
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88900: LD_ADDR_VAR 0 3
88904: PUSH
88905: LD_VAR 0 4
88909: PUSH
88910: LD_INT 1
88912: ARRAY
88913: PUSH
88914: LD_INT 1
88916: ARRAY
88917: PUSH
88918: LD_STRING r
88920: EQUAL
88921: PUSH
88922: LD_VAR 0 4
88926: PUSH
88927: LD_INT 1
88929: ARRAY
88930: PUSH
88931: LD_INT 4
88933: ARRAY
88934: PUSH
88935: LD_VAR 0 2
88939: EQUAL
88940: AND
88941: ST_TO_ADDR
// end ;
88942: LD_VAR 0 3
88946: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88947: LD_INT 0
88949: PPUSH
// SetDir ( unit , d ) ;
88950: LD_VAR 0 1
88954: PPUSH
88955: LD_VAR 0 4
88959: PPUSH
88960: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88964: LD_VAR 0 1
88968: PPUSH
88969: LD_VAR 0 2
88973: PPUSH
88974: LD_VAR 0 3
88978: PPUSH
88979: LD_VAR 0 5
88983: PPUSH
88984: CALL_OW 48
// end ;
88988: LD_VAR 0 6
88992: RET
// export function ToNaturalNumber ( number ) ; begin
88993: LD_INT 0
88995: PPUSH
// result := number div 1 ;
88996: LD_ADDR_VAR 0 2
89000: PUSH
89001: LD_VAR 0 1
89005: PUSH
89006: LD_INT 1
89008: DIV
89009: ST_TO_ADDR
// if number < 0 then
89010: LD_VAR 0 1
89014: PUSH
89015: LD_INT 0
89017: LESS
89018: IFFALSE 89028
// result := 0 ;
89020: LD_ADDR_VAR 0 2
89024: PUSH
89025: LD_INT 0
89027: ST_TO_ADDR
// end ;
89028: LD_VAR 0 2
89032: RET
// export function SortByClass ( units , class ) ; var un ; begin
89033: LD_INT 0
89035: PPUSH
89036: PPUSH
// if not units or not class then
89037: LD_VAR 0 1
89041: NOT
89042: PUSH
89043: LD_VAR 0 2
89047: NOT
89048: OR
89049: IFFALSE 89053
// exit ;
89051: GO 89148
// result := [ ] ;
89053: LD_ADDR_VAR 0 3
89057: PUSH
89058: EMPTY
89059: ST_TO_ADDR
// for un in units do
89060: LD_ADDR_VAR 0 4
89064: PUSH
89065: LD_VAR 0 1
89069: PUSH
89070: FOR_IN
89071: IFFALSE 89146
// if GetClass ( un ) = class then
89073: LD_VAR 0 4
89077: PPUSH
89078: CALL_OW 257
89082: PUSH
89083: LD_VAR 0 2
89087: EQUAL
89088: IFFALSE 89115
// result := Insert ( result , 1 , un ) else
89090: LD_ADDR_VAR 0 3
89094: PUSH
89095: LD_VAR 0 3
89099: PPUSH
89100: LD_INT 1
89102: PPUSH
89103: LD_VAR 0 4
89107: PPUSH
89108: CALL_OW 2
89112: ST_TO_ADDR
89113: GO 89144
// result := Replace ( result , result + 1 , un ) ;
89115: LD_ADDR_VAR 0 3
89119: PUSH
89120: LD_VAR 0 3
89124: PPUSH
89125: LD_VAR 0 3
89129: PUSH
89130: LD_INT 1
89132: PLUS
89133: PPUSH
89134: LD_VAR 0 4
89138: PPUSH
89139: CALL_OW 1
89143: ST_TO_ADDR
89144: GO 89070
89146: POP
89147: POP
// end ;
89148: LD_VAR 0 3
89152: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
89153: LD_INT 0
89155: PPUSH
89156: PPUSH
89157: PPUSH
89158: PPUSH
89159: PPUSH
89160: PPUSH
89161: PPUSH
// result := [ ] ;
89162: LD_ADDR_VAR 0 4
89166: PUSH
89167: EMPTY
89168: ST_TO_ADDR
// if x - r < 0 then
89169: LD_VAR 0 1
89173: PUSH
89174: LD_VAR 0 3
89178: MINUS
89179: PUSH
89180: LD_INT 0
89182: LESS
89183: IFFALSE 89195
// min_x := 0 else
89185: LD_ADDR_VAR 0 8
89189: PUSH
89190: LD_INT 0
89192: ST_TO_ADDR
89193: GO 89211
// min_x := x - r ;
89195: LD_ADDR_VAR 0 8
89199: PUSH
89200: LD_VAR 0 1
89204: PUSH
89205: LD_VAR 0 3
89209: MINUS
89210: ST_TO_ADDR
// if y - r < 0 then
89211: LD_VAR 0 2
89215: PUSH
89216: LD_VAR 0 3
89220: MINUS
89221: PUSH
89222: LD_INT 0
89224: LESS
89225: IFFALSE 89237
// min_y := 0 else
89227: LD_ADDR_VAR 0 7
89231: PUSH
89232: LD_INT 0
89234: ST_TO_ADDR
89235: GO 89253
// min_y := y - r ;
89237: LD_ADDR_VAR 0 7
89241: PUSH
89242: LD_VAR 0 2
89246: PUSH
89247: LD_VAR 0 3
89251: MINUS
89252: ST_TO_ADDR
// max_x := x + r ;
89253: LD_ADDR_VAR 0 9
89257: PUSH
89258: LD_VAR 0 1
89262: PUSH
89263: LD_VAR 0 3
89267: PLUS
89268: ST_TO_ADDR
// max_y := y + r ;
89269: LD_ADDR_VAR 0 10
89273: PUSH
89274: LD_VAR 0 2
89278: PUSH
89279: LD_VAR 0 3
89283: PLUS
89284: ST_TO_ADDR
// for _x = min_x to max_x do
89285: LD_ADDR_VAR 0 5
89289: PUSH
89290: DOUBLE
89291: LD_VAR 0 8
89295: DEC
89296: ST_TO_ADDR
89297: LD_VAR 0 9
89301: PUSH
89302: FOR_TO
89303: IFFALSE 89404
// for _y = min_y to max_y do
89305: LD_ADDR_VAR 0 6
89309: PUSH
89310: DOUBLE
89311: LD_VAR 0 7
89315: DEC
89316: ST_TO_ADDR
89317: LD_VAR 0 10
89321: PUSH
89322: FOR_TO
89323: IFFALSE 89400
// begin if not ValidHex ( _x , _y ) then
89325: LD_VAR 0 5
89329: PPUSH
89330: LD_VAR 0 6
89334: PPUSH
89335: CALL_OW 488
89339: NOT
89340: IFFALSE 89344
// continue ;
89342: GO 89322
// if GetResourceTypeXY ( _x , _y ) then
89344: LD_VAR 0 5
89348: PPUSH
89349: LD_VAR 0 6
89353: PPUSH
89354: CALL_OW 283
89358: IFFALSE 89398
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89360: LD_ADDR_VAR 0 4
89364: PUSH
89365: LD_VAR 0 4
89369: PPUSH
89370: LD_VAR 0 4
89374: PUSH
89375: LD_INT 1
89377: PLUS
89378: PPUSH
89379: LD_VAR 0 5
89383: PUSH
89384: LD_VAR 0 6
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PPUSH
89393: CALL_OW 1
89397: ST_TO_ADDR
// end ;
89398: GO 89322
89400: POP
89401: POP
89402: GO 89302
89404: POP
89405: POP
// end ;
89406: LD_VAR 0 4
89410: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89411: LD_INT 0
89413: PPUSH
89414: PPUSH
89415: PPUSH
89416: PPUSH
89417: PPUSH
89418: PPUSH
89419: PPUSH
89420: PPUSH
// if not units then
89421: LD_VAR 0 1
89425: NOT
89426: IFFALSE 89430
// exit ;
89428: GO 89954
// result := UnitFilter ( units , [ f_ok ] ) ;
89430: LD_ADDR_VAR 0 3
89434: PUSH
89435: LD_VAR 0 1
89439: PPUSH
89440: LD_INT 50
89442: PUSH
89443: EMPTY
89444: LIST
89445: PPUSH
89446: CALL_OW 72
89450: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89451: LD_ADDR_VAR 0 8
89455: PUSH
89456: LD_VAR 0 1
89460: PUSH
89461: LD_INT 1
89463: ARRAY
89464: PPUSH
89465: CALL_OW 255
89469: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89470: LD_ADDR_VAR 0 10
89474: PUSH
89475: LD_INT 29
89477: PUSH
89478: LD_INT 91
89480: PUSH
89481: LD_INT 49
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: LIST
89488: ST_TO_ADDR
// if not result then
89489: LD_VAR 0 3
89493: NOT
89494: IFFALSE 89498
// exit ;
89496: GO 89954
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89498: LD_ADDR_VAR 0 5
89502: PUSH
89503: LD_INT 81
89505: PUSH
89506: LD_VAR 0 8
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PPUSH
89515: CALL_OW 69
89519: ST_TO_ADDR
// for i in result do
89520: LD_ADDR_VAR 0 4
89524: PUSH
89525: LD_VAR 0 3
89529: PUSH
89530: FOR_IN
89531: IFFALSE 89952
// begin tag := GetTag ( i ) + 1 ;
89533: LD_ADDR_VAR 0 9
89537: PUSH
89538: LD_VAR 0 4
89542: PPUSH
89543: CALL_OW 110
89547: PUSH
89548: LD_INT 1
89550: PLUS
89551: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89552: LD_ADDR_VAR 0 7
89556: PUSH
89557: LD_VAR 0 4
89561: PPUSH
89562: CALL_OW 250
89566: PPUSH
89567: LD_VAR 0 4
89571: PPUSH
89572: CALL_OW 251
89576: PPUSH
89577: LD_INT 6
89579: PPUSH
89580: CALL 89153 0 3
89584: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89585: LD_VAR 0 4
89589: PPUSH
89590: CALL_OW 247
89594: PUSH
89595: LD_INT 2
89597: EQUAL
89598: PUSH
89599: LD_VAR 0 7
89603: AND
89604: PUSH
89605: LD_VAR 0 4
89609: PPUSH
89610: CALL_OW 264
89614: PUSH
89615: LD_VAR 0 10
89619: IN
89620: NOT
89621: AND
89622: IFFALSE 89661
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89624: LD_VAR 0 4
89628: PPUSH
89629: LD_VAR 0 7
89633: PUSH
89634: LD_INT 1
89636: ARRAY
89637: PUSH
89638: LD_INT 1
89640: ARRAY
89641: PPUSH
89642: LD_VAR 0 7
89646: PUSH
89647: LD_INT 1
89649: ARRAY
89650: PUSH
89651: LD_INT 2
89653: ARRAY
89654: PPUSH
89655: CALL_OW 116
89659: GO 89950
// if path > tag then
89661: LD_VAR 0 2
89665: PUSH
89666: LD_VAR 0 9
89670: GREATER
89671: IFFALSE 89879
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89673: LD_ADDR_VAR 0 6
89677: PUSH
89678: LD_VAR 0 5
89682: PPUSH
89683: LD_INT 91
89685: PUSH
89686: LD_VAR 0 4
89690: PUSH
89691: LD_INT 8
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: LIST
89698: PPUSH
89699: CALL_OW 72
89703: ST_TO_ADDR
// if nearEnemy then
89704: LD_VAR 0 6
89708: IFFALSE 89777
// begin if GetWeapon ( i ) = ru_time_lapser then
89710: LD_VAR 0 4
89714: PPUSH
89715: CALL_OW 264
89719: PUSH
89720: LD_INT 49
89722: EQUAL
89723: IFFALSE 89751
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89725: LD_VAR 0 4
89729: PPUSH
89730: LD_VAR 0 6
89734: PPUSH
89735: LD_VAR 0 4
89739: PPUSH
89740: CALL_OW 74
89744: PPUSH
89745: CALL_OW 112
89749: GO 89775
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89751: LD_VAR 0 4
89755: PPUSH
89756: LD_VAR 0 6
89760: PPUSH
89761: LD_VAR 0 4
89765: PPUSH
89766: CALL_OW 74
89770: PPUSH
89771: CALL 90879 0 2
// end else
89775: GO 89877
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89777: LD_VAR 0 4
89781: PPUSH
89782: LD_VAR 0 2
89786: PUSH
89787: LD_VAR 0 9
89791: ARRAY
89792: PUSH
89793: LD_INT 1
89795: ARRAY
89796: PPUSH
89797: LD_VAR 0 2
89801: PUSH
89802: LD_VAR 0 9
89806: ARRAY
89807: PUSH
89808: LD_INT 2
89810: ARRAY
89811: PPUSH
89812: CALL_OW 297
89816: PUSH
89817: LD_INT 6
89819: GREATER
89820: IFFALSE 89863
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89822: LD_VAR 0 4
89826: PPUSH
89827: LD_VAR 0 2
89831: PUSH
89832: LD_VAR 0 9
89836: ARRAY
89837: PUSH
89838: LD_INT 1
89840: ARRAY
89841: PPUSH
89842: LD_VAR 0 2
89846: PUSH
89847: LD_VAR 0 9
89851: ARRAY
89852: PUSH
89853: LD_INT 2
89855: ARRAY
89856: PPUSH
89857: CALL_OW 114
89861: GO 89877
// SetTag ( i , tag ) ;
89863: LD_VAR 0 4
89867: PPUSH
89868: LD_VAR 0 9
89872: PPUSH
89873: CALL_OW 109
// end else
89877: GO 89950
// if enemy then
89879: LD_VAR 0 5
89883: IFFALSE 89950
// begin if GetWeapon ( i ) = ru_time_lapser then
89885: LD_VAR 0 4
89889: PPUSH
89890: CALL_OW 264
89894: PUSH
89895: LD_INT 49
89897: EQUAL
89898: IFFALSE 89926
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89900: LD_VAR 0 4
89904: PPUSH
89905: LD_VAR 0 5
89909: PPUSH
89910: LD_VAR 0 4
89914: PPUSH
89915: CALL_OW 74
89919: PPUSH
89920: CALL_OW 112
89924: GO 89950
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89926: LD_VAR 0 4
89930: PPUSH
89931: LD_VAR 0 5
89935: PPUSH
89936: LD_VAR 0 4
89940: PPUSH
89941: CALL_OW 74
89945: PPUSH
89946: CALL 90879 0 2
// end ; end ;
89950: GO 89530
89952: POP
89953: POP
// end ;
89954: LD_VAR 0 3
89958: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89959: LD_INT 0
89961: PPUSH
89962: PPUSH
89963: PPUSH
// if not unit or IsInUnit ( unit ) then
89964: LD_VAR 0 1
89968: NOT
89969: PUSH
89970: LD_VAR 0 1
89974: PPUSH
89975: CALL_OW 310
89979: OR
89980: IFFALSE 89984
// exit ;
89982: GO 90075
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89984: LD_ADDR_VAR 0 4
89988: PUSH
89989: LD_VAR 0 1
89993: PPUSH
89994: CALL_OW 250
89998: PPUSH
89999: LD_VAR 0 2
90003: PPUSH
90004: LD_INT 1
90006: PPUSH
90007: CALL_OW 272
90011: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
90012: LD_ADDR_VAR 0 5
90016: PUSH
90017: LD_VAR 0 1
90021: PPUSH
90022: CALL_OW 251
90026: PPUSH
90027: LD_VAR 0 2
90031: PPUSH
90032: LD_INT 1
90034: PPUSH
90035: CALL_OW 273
90039: ST_TO_ADDR
// if ValidHex ( x , y ) then
90040: LD_VAR 0 4
90044: PPUSH
90045: LD_VAR 0 5
90049: PPUSH
90050: CALL_OW 488
90054: IFFALSE 90075
// ComTurnXY ( unit , x , y ) ;
90056: LD_VAR 0 1
90060: PPUSH
90061: LD_VAR 0 4
90065: PPUSH
90066: LD_VAR 0 5
90070: PPUSH
90071: CALL_OW 118
// end ;
90075: LD_VAR 0 3
90079: RET
// export function SeeUnits ( side , units ) ; var i ; begin
90080: LD_INT 0
90082: PPUSH
90083: PPUSH
// result := false ;
90084: LD_ADDR_VAR 0 3
90088: PUSH
90089: LD_INT 0
90091: ST_TO_ADDR
// if not units then
90092: LD_VAR 0 2
90096: NOT
90097: IFFALSE 90101
// exit ;
90099: GO 90146
// for i in units do
90101: LD_ADDR_VAR 0 4
90105: PUSH
90106: LD_VAR 0 2
90110: PUSH
90111: FOR_IN
90112: IFFALSE 90144
// if See ( side , i ) then
90114: LD_VAR 0 1
90118: PPUSH
90119: LD_VAR 0 4
90123: PPUSH
90124: CALL_OW 292
90128: IFFALSE 90142
// begin result := true ;
90130: LD_ADDR_VAR 0 3
90134: PUSH
90135: LD_INT 1
90137: ST_TO_ADDR
// exit ;
90138: POP
90139: POP
90140: GO 90146
// end ;
90142: GO 90111
90144: POP
90145: POP
// end ;
90146: LD_VAR 0 3
90150: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
90151: LD_INT 0
90153: PPUSH
90154: PPUSH
90155: PPUSH
90156: PPUSH
// if not unit or not points then
90157: LD_VAR 0 1
90161: NOT
90162: PUSH
90163: LD_VAR 0 2
90167: NOT
90168: OR
90169: IFFALSE 90173
// exit ;
90171: GO 90263
// dist := 99999 ;
90173: LD_ADDR_VAR 0 5
90177: PUSH
90178: LD_INT 99999
90180: ST_TO_ADDR
// for i in points do
90181: LD_ADDR_VAR 0 4
90185: PUSH
90186: LD_VAR 0 2
90190: PUSH
90191: FOR_IN
90192: IFFALSE 90261
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
90194: LD_ADDR_VAR 0 6
90198: PUSH
90199: LD_VAR 0 1
90203: PPUSH
90204: LD_VAR 0 4
90208: PUSH
90209: LD_INT 1
90211: ARRAY
90212: PPUSH
90213: LD_VAR 0 4
90217: PUSH
90218: LD_INT 2
90220: ARRAY
90221: PPUSH
90222: CALL_OW 297
90226: ST_TO_ADDR
// if tmpDist < dist then
90227: LD_VAR 0 6
90231: PUSH
90232: LD_VAR 0 5
90236: LESS
90237: IFFALSE 90259
// begin result := i ;
90239: LD_ADDR_VAR 0 3
90243: PUSH
90244: LD_VAR 0 4
90248: ST_TO_ADDR
// dist := tmpDist ;
90249: LD_ADDR_VAR 0 5
90253: PUSH
90254: LD_VAR 0 6
90258: ST_TO_ADDR
// end ; end ;
90259: GO 90191
90261: POP
90262: POP
// end ;
90263: LD_VAR 0 3
90267: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
90268: LD_INT 0
90270: PPUSH
// uc_side := side ;
90271: LD_ADDR_OWVAR 20
90275: PUSH
90276: LD_VAR 0 1
90280: ST_TO_ADDR
// uc_nation := 3 ;
90281: LD_ADDR_OWVAR 21
90285: PUSH
90286: LD_INT 3
90288: ST_TO_ADDR
// vc_chassis := 25 ;
90289: LD_ADDR_OWVAR 37
90293: PUSH
90294: LD_INT 25
90296: ST_TO_ADDR
// vc_engine := engine_siberite ;
90297: LD_ADDR_OWVAR 39
90301: PUSH
90302: LD_INT 3
90304: ST_TO_ADDR
// vc_control := control_computer ;
90305: LD_ADDR_OWVAR 38
90309: PUSH
90310: LD_INT 3
90312: ST_TO_ADDR
// vc_weapon := 59 ;
90313: LD_ADDR_OWVAR 40
90317: PUSH
90318: LD_INT 59
90320: ST_TO_ADDR
// result := CreateVehicle ;
90321: LD_ADDR_VAR 0 5
90325: PUSH
90326: CALL_OW 45
90330: ST_TO_ADDR
// SetDir ( result , d ) ;
90331: LD_VAR 0 5
90335: PPUSH
90336: LD_VAR 0 4
90340: PPUSH
90341: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90345: LD_VAR 0 5
90349: PPUSH
90350: LD_VAR 0 2
90354: PPUSH
90355: LD_VAR 0 3
90359: PPUSH
90360: LD_INT 0
90362: PPUSH
90363: CALL_OW 48
// end ;
90367: LD_VAR 0 5
90371: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90372: LD_INT 0
90374: PPUSH
90375: PPUSH
90376: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90377: LD_ADDR_VAR 0 2
90381: PUSH
90382: LD_INT 0
90384: PUSH
90385: LD_INT 0
90387: PUSH
90388: LD_INT 0
90390: PUSH
90391: LD_INT 0
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90400: LD_VAR 0 1
90404: NOT
90405: PUSH
90406: LD_VAR 0 1
90410: PPUSH
90411: CALL_OW 264
90415: PUSH
90416: LD_INT 12
90418: PUSH
90419: LD_INT 51
90421: PUSH
90422: LD_INT 32
90424: PUSH
90425: LD_INT 89
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: IN
90434: NOT
90435: OR
90436: IFFALSE 90440
// exit ;
90438: GO 90538
// for i := 1 to 3 do
90440: LD_ADDR_VAR 0 3
90444: PUSH
90445: DOUBLE
90446: LD_INT 1
90448: DEC
90449: ST_TO_ADDR
90450: LD_INT 3
90452: PUSH
90453: FOR_TO
90454: IFFALSE 90536
// begin tmp := GetCargo ( cargo , i ) ;
90456: LD_ADDR_VAR 0 4
90460: PUSH
90461: LD_VAR 0 1
90465: PPUSH
90466: LD_VAR 0 3
90470: PPUSH
90471: CALL_OW 289
90475: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90476: LD_ADDR_VAR 0 2
90480: PUSH
90481: LD_VAR 0 2
90485: PPUSH
90486: LD_VAR 0 3
90490: PPUSH
90491: LD_VAR 0 4
90495: PPUSH
90496: CALL_OW 1
90500: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90501: LD_ADDR_VAR 0 2
90505: PUSH
90506: LD_VAR 0 2
90510: PPUSH
90511: LD_INT 4
90513: PPUSH
90514: LD_VAR 0 2
90518: PUSH
90519: LD_INT 4
90521: ARRAY
90522: PUSH
90523: LD_VAR 0 4
90527: PLUS
90528: PPUSH
90529: CALL_OW 1
90533: ST_TO_ADDR
// end ;
90534: GO 90453
90536: POP
90537: POP
// end ;
90538: LD_VAR 0 2
90542: RET
// export function Length ( array ) ; begin
90543: LD_INT 0
90545: PPUSH
// result := array + 0 ;
90546: LD_ADDR_VAR 0 2
90550: PUSH
90551: LD_VAR 0 1
90555: PUSH
90556: LD_INT 0
90558: PLUS
90559: ST_TO_ADDR
// end ;
90560: LD_VAR 0 2
90564: RET
// export function PrepareArray ( array ) ; begin
90565: LD_INT 0
90567: PPUSH
// result := array diff 0 ;
90568: LD_ADDR_VAR 0 2
90572: PUSH
90573: LD_VAR 0 1
90577: PUSH
90578: LD_INT 0
90580: DIFF
90581: ST_TO_ADDR
// if not result [ 1 ] then
90582: LD_VAR 0 2
90586: PUSH
90587: LD_INT 1
90589: ARRAY
90590: NOT
90591: IFFALSE 90611
// result := Delete ( result , 1 ) ;
90593: LD_ADDR_VAR 0 2
90597: PUSH
90598: LD_VAR 0 2
90602: PPUSH
90603: LD_INT 1
90605: PPUSH
90606: CALL_OW 3
90610: ST_TO_ADDR
// end ;
90611: LD_VAR 0 2
90615: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90616: LD_INT 0
90618: PPUSH
90619: PPUSH
90620: PPUSH
90621: PPUSH
// sibRocketRange := 25 ;
90622: LD_ADDR_VAR 0 6
90626: PUSH
90627: LD_INT 25
90629: ST_TO_ADDR
// result := false ;
90630: LD_ADDR_VAR 0 4
90634: PUSH
90635: LD_INT 0
90637: ST_TO_ADDR
// for i := 0 to 5 do
90638: LD_ADDR_VAR 0 5
90642: PUSH
90643: DOUBLE
90644: LD_INT 0
90646: DEC
90647: ST_TO_ADDR
90648: LD_INT 5
90650: PUSH
90651: FOR_TO
90652: IFFALSE 90719
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90654: LD_VAR 0 1
90658: PPUSH
90659: LD_VAR 0 5
90663: PPUSH
90664: LD_VAR 0 6
90668: PPUSH
90669: CALL_OW 272
90673: PPUSH
90674: LD_VAR 0 2
90678: PPUSH
90679: LD_VAR 0 5
90683: PPUSH
90684: LD_VAR 0 6
90688: PPUSH
90689: CALL_OW 273
90693: PPUSH
90694: LD_VAR 0 3
90698: PPUSH
90699: CALL_OW 309
90703: IFFALSE 90717
// begin result := true ;
90705: LD_ADDR_VAR 0 4
90709: PUSH
90710: LD_INT 1
90712: ST_TO_ADDR
// exit ;
90713: POP
90714: POP
90715: GO 90721
// end ;
90717: GO 90651
90719: POP
90720: POP
// end ;
90721: LD_VAR 0 4
90725: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90726: LD_INT 0
90728: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90729: LD_VAR 0 1
90733: PPUSH
90734: LD_VAR 0 2
90738: PPUSH
90739: LD_INT 0
90741: PPUSH
90742: LD_INT 0
90744: PPUSH
90745: LD_INT 1
90747: PPUSH
90748: LD_INT 0
90750: PPUSH
90751: CALL_OW 587
// end ;
90755: LD_VAR 0 3
90759: RET
// export function CenterOnNow ( unit ) ; begin
90760: LD_INT 0
90762: PPUSH
// result := IsInUnit ( unit ) ;
90763: LD_ADDR_VAR 0 2
90767: PUSH
90768: LD_VAR 0 1
90772: PPUSH
90773: CALL_OW 310
90777: ST_TO_ADDR
// if not result then
90778: LD_VAR 0 2
90782: NOT
90783: IFFALSE 90795
// result := unit ;
90785: LD_ADDR_VAR 0 2
90789: PUSH
90790: LD_VAR 0 1
90794: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90795: LD_VAR 0 1
90799: PPUSH
90800: CALL_OW 87
// end ;
90804: LD_VAR 0 2
90808: RET
// export function ComMoveHex ( unit , hex ) ; begin
90809: LD_INT 0
90811: PPUSH
// if not hex then
90812: LD_VAR 0 2
90816: NOT
90817: IFFALSE 90821
// exit ;
90819: GO 90874
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90821: LD_VAR 0 2
90825: PUSH
90826: LD_INT 1
90828: ARRAY
90829: PPUSH
90830: LD_VAR 0 2
90834: PUSH
90835: LD_INT 2
90837: ARRAY
90838: PPUSH
90839: CALL_OW 428
90843: IFFALSE 90847
// exit ;
90845: GO 90874
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90847: LD_VAR 0 1
90851: PPUSH
90852: LD_VAR 0 2
90856: PUSH
90857: LD_INT 1
90859: ARRAY
90860: PPUSH
90861: LD_VAR 0 2
90865: PUSH
90866: LD_INT 2
90868: ARRAY
90869: PPUSH
90870: CALL_OW 111
// end ;
90874: LD_VAR 0 3
90878: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
90879: LD_INT 0
90881: PPUSH
90882: PPUSH
90883: PPUSH
// if not unit or not enemy then
90884: LD_VAR 0 1
90888: NOT
90889: PUSH
90890: LD_VAR 0 2
90894: NOT
90895: OR
90896: IFFALSE 90900
// exit ;
90898: GO 91024
// x := GetX ( enemy ) ;
90900: LD_ADDR_VAR 0 4
90904: PUSH
90905: LD_VAR 0 2
90909: PPUSH
90910: CALL_OW 250
90914: ST_TO_ADDR
// y := GetY ( enemy ) ;
90915: LD_ADDR_VAR 0 5
90919: PUSH
90920: LD_VAR 0 2
90924: PPUSH
90925: CALL_OW 251
90929: ST_TO_ADDR
// if ValidHex ( x , y ) then
90930: LD_VAR 0 4
90934: PPUSH
90935: LD_VAR 0 5
90939: PPUSH
90940: CALL_OW 488
90944: IFFALSE 91024
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
90946: LD_VAR 0 2
90950: PPUSH
90951: CALL_OW 247
90955: PUSH
90956: LD_INT 3
90958: PUSH
90959: LD_INT 2
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: IN
90966: PUSH
90967: LD_VAR 0 1
90971: PPUSH
90972: CALL_OW 255
90976: PPUSH
90977: LD_VAR 0 2
90981: PPUSH
90982: CALL_OW 292
90986: AND
90987: IFFALSE 91005
// ComAttackUnit ( unit , enemy ) else
90989: LD_VAR 0 1
90993: PPUSH
90994: LD_VAR 0 2
90998: PPUSH
90999: CALL_OW 115
91003: GO 91024
// ComAgressiveMove ( unit , x , y ) ;
91005: LD_VAR 0 1
91009: PPUSH
91010: LD_VAR 0 4
91014: PPUSH
91015: LD_VAR 0 5
91019: PPUSH
91020: CALL_OW 114
// end ;
91024: LD_VAR 0 3
91028: RET
// function GetSourcesFromArea ( area , all ) ; var i , list ; begin
91029: LD_INT 0
91031: PPUSH
91032: PPUSH
91033: PPUSH
// list := AreaToList ( area , 0 ) ;
91034: LD_ADDR_VAR 0 5
91038: PUSH
91039: LD_VAR 0 1
91043: PPUSH
91044: LD_INT 0
91046: PPUSH
91047: CALL_OW 517
91051: ST_TO_ADDR
// if not list then
91052: LD_VAR 0 5
91056: NOT
91057: IFFALSE 91061
// exit ;
91059: GO 91188
// if all then
91061: LD_VAR 0 2
91065: IFFALSE 91153
// begin for i := 1 to list [ 1 ] do
91067: LD_ADDR_VAR 0 4
91071: PUSH
91072: DOUBLE
91073: LD_INT 1
91075: DEC
91076: ST_TO_ADDR
91077: LD_VAR 0 5
91081: PUSH
91082: LD_INT 1
91084: ARRAY
91085: PUSH
91086: FOR_TO
91087: IFFALSE 91149
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
91089: LD_ADDR_VAR 0 3
91093: PUSH
91094: LD_VAR 0 3
91098: PPUSH
91099: LD_VAR 0 3
91103: PUSH
91104: LD_INT 1
91106: PLUS
91107: PPUSH
91108: LD_VAR 0 5
91112: PUSH
91113: LD_INT 1
91115: ARRAY
91116: PUSH
91117: LD_VAR 0 4
91121: ARRAY
91122: PUSH
91123: LD_VAR 0 5
91127: PUSH
91128: LD_INT 2
91130: ARRAY
91131: PUSH
91132: LD_VAR 0 4
91136: ARRAY
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PPUSH
91142: CALL_OW 1
91146: ST_TO_ADDR
91147: GO 91086
91149: POP
91150: POP
// exit ;
91151: GO 91188
// end ; result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ;
91153: LD_ADDR_VAR 0 3
91157: PUSH
91158: LD_VAR 0 5
91162: PUSH
91163: LD_INT 1
91165: ARRAY
91166: PUSH
91167: LD_INT 1
91169: ARRAY
91170: PUSH
91171: LD_VAR 0 5
91175: PUSH
91176: LD_INT 2
91178: ARRAY
91179: PUSH
91180: LD_INT 1
91182: ARRAY
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: ST_TO_ADDR
// end ;
91188: LD_VAR 0 3
91192: RET
// function GetBuildingFromArea ( area , direction ) ; var list ; begin
91193: LD_INT 0
91195: PPUSH
91196: PPUSH
// list := AreaToList ( area , 0 ) ;
91197: LD_ADDR_VAR 0 4
91201: PUSH
91202: LD_VAR 0 1
91206: PPUSH
91207: LD_INT 0
91209: PPUSH
91210: CALL_OW 517
91214: ST_TO_ADDR
// if not list then
91215: LD_VAR 0 4
91219: NOT
91220: IFFALSE 91224
// exit ;
91222: GO 91265
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
91224: LD_ADDR_VAR 0 3
91228: PUSH
91229: LD_VAR 0 4
91233: PUSH
91234: LD_INT 1
91236: ARRAY
91237: PUSH
91238: LD_INT 1
91240: ARRAY
91241: PUSH
91242: LD_VAR 0 4
91246: PUSH
91247: LD_INT 2
91249: ARRAY
91250: PUSH
91251: LD_INT 1
91253: ARRAY
91254: PUSH
91255: LD_VAR 0 2
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: LIST
91264: ST_TO_ADDR
// end ; end_of_file end_of_file
91265: LD_VAR 0 3
91269: RET
// export globalGameSaveCounter ; every 0 0$1 do
91270: GO 91272
91272: DISABLE
// begin enable ;
91273: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91274: LD_STRING updateTimer(
91276: PUSH
91277: LD_OWVAR 1
91281: STR
91282: PUSH
91283: LD_STRING );
91285: STR
91286: PPUSH
91287: CALL_OW 559
// end ;
91291: END
// every 0 0$1 do
91292: GO 91294
91294: DISABLE
// begin globalGameSaveCounter := 0 ;
91295: LD_ADDR_EXP 95
91299: PUSH
91300: LD_INT 0
91302: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91303: LD_STRING setGameSaveCounter(0)
91305: PPUSH
91306: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91310: LD_STRING initStreamRollete();
91312: PPUSH
91313: CALL_OW 559
// InitStreamMode ;
91317: CALL 92643 0 0
// DefineStreamItems ( false ) ;
91321: LD_INT 0
91323: PPUSH
91324: CALL 93107 0 1
// end ;
91328: END
// export function SOS_MapStart ( ) ; begin
91329: LD_INT 0
91331: PPUSH
// if streamModeActive then
91332: LD_EXP 96
91336: IFFALSE 91345
// DefineStreamItems ( true ) ;
91338: LD_INT 1
91340: PPUSH
91341: CALL 93107 0 1
// UpdateLuaVariables ( ) ;
91345: CALL 91362 0 0
// UpdateFactoryWaypoints ( ) ;
91349: CALL 105976 0 0
// UpdateWarehouseGatheringPoints ( ) ;
91353: CALL 106233 0 0
// end ;
91357: LD_VAR 0 1
91361: RET
// function UpdateLuaVariables ( ) ; begin
91362: LD_INT 0
91364: PPUSH
// if globalGameSaveCounter then
91365: LD_EXP 95
91369: IFFALSE 91403
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
91371: LD_ADDR_EXP 95
91375: PUSH
91376: LD_EXP 95
91380: PPUSH
91381: CALL 88168 0 1
91385: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91386: LD_STRING setGameSaveCounter(
91388: PUSH
91389: LD_EXP 95
91393: STR
91394: PUSH
91395: LD_STRING )
91397: STR
91398: PPUSH
91399: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
91403: LD_STRING setGameDifficulty(
91405: PUSH
91406: LD_OWVAR 67
91410: STR
91411: PUSH
91412: LD_STRING )
91414: STR
91415: PPUSH
91416: CALL_OW 559
// end ;
91420: LD_VAR 0 1
91424: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91425: LD_INT 0
91427: PPUSH
// if p2 = stream_mode then
91428: LD_VAR 0 2
91432: PUSH
91433: LD_INT 100
91435: EQUAL
91436: IFFALSE 92439
// begin if not StreamModeActive then
91438: LD_EXP 96
91442: NOT
91443: IFFALSE 91453
// StreamModeActive := true ;
91445: LD_ADDR_EXP 96
91449: PUSH
91450: LD_INT 1
91452: ST_TO_ADDR
// if p3 = 0 then
91453: LD_VAR 0 3
91457: PUSH
91458: LD_INT 0
91460: EQUAL
91461: IFFALSE 91467
// InitStreamMode ;
91463: CALL 92643 0 0
// if p3 = 1 then
91467: LD_VAR 0 3
91471: PUSH
91472: LD_INT 1
91474: EQUAL
91475: IFFALSE 91485
// sRocket := true ;
91477: LD_ADDR_EXP 101
91481: PUSH
91482: LD_INT 1
91484: ST_TO_ADDR
// if p3 = 2 then
91485: LD_VAR 0 3
91489: PUSH
91490: LD_INT 2
91492: EQUAL
91493: IFFALSE 91503
// sSpeed := true ;
91495: LD_ADDR_EXP 100
91499: PUSH
91500: LD_INT 1
91502: ST_TO_ADDR
// if p3 = 3 then
91503: LD_VAR 0 3
91507: PUSH
91508: LD_INT 3
91510: EQUAL
91511: IFFALSE 91521
// sEngine := true ;
91513: LD_ADDR_EXP 102
91517: PUSH
91518: LD_INT 1
91520: ST_TO_ADDR
// if p3 = 4 then
91521: LD_VAR 0 3
91525: PUSH
91526: LD_INT 4
91528: EQUAL
91529: IFFALSE 91539
// sSpec := true ;
91531: LD_ADDR_EXP 99
91535: PUSH
91536: LD_INT 1
91538: ST_TO_ADDR
// if p3 = 5 then
91539: LD_VAR 0 3
91543: PUSH
91544: LD_INT 5
91546: EQUAL
91547: IFFALSE 91557
// sLevel := true ;
91549: LD_ADDR_EXP 103
91553: PUSH
91554: LD_INT 1
91556: ST_TO_ADDR
// if p3 = 6 then
91557: LD_VAR 0 3
91561: PUSH
91562: LD_INT 6
91564: EQUAL
91565: IFFALSE 91575
// sArmoury := true ;
91567: LD_ADDR_EXP 104
91571: PUSH
91572: LD_INT 1
91574: ST_TO_ADDR
// if p3 = 7 then
91575: LD_VAR 0 3
91579: PUSH
91580: LD_INT 7
91582: EQUAL
91583: IFFALSE 91593
// sRadar := true ;
91585: LD_ADDR_EXP 105
91589: PUSH
91590: LD_INT 1
91592: ST_TO_ADDR
// if p3 = 8 then
91593: LD_VAR 0 3
91597: PUSH
91598: LD_INT 8
91600: EQUAL
91601: IFFALSE 91611
// sBunker := true ;
91603: LD_ADDR_EXP 106
91607: PUSH
91608: LD_INT 1
91610: ST_TO_ADDR
// if p3 = 9 then
91611: LD_VAR 0 3
91615: PUSH
91616: LD_INT 9
91618: EQUAL
91619: IFFALSE 91629
// sHack := true ;
91621: LD_ADDR_EXP 107
91625: PUSH
91626: LD_INT 1
91628: ST_TO_ADDR
// if p3 = 10 then
91629: LD_VAR 0 3
91633: PUSH
91634: LD_INT 10
91636: EQUAL
91637: IFFALSE 91647
// sFire := true ;
91639: LD_ADDR_EXP 108
91643: PUSH
91644: LD_INT 1
91646: ST_TO_ADDR
// if p3 = 11 then
91647: LD_VAR 0 3
91651: PUSH
91652: LD_INT 11
91654: EQUAL
91655: IFFALSE 91665
// sRefresh := true ;
91657: LD_ADDR_EXP 109
91661: PUSH
91662: LD_INT 1
91664: ST_TO_ADDR
// if p3 = 12 then
91665: LD_VAR 0 3
91669: PUSH
91670: LD_INT 12
91672: EQUAL
91673: IFFALSE 91683
// sExp := true ;
91675: LD_ADDR_EXP 110
91679: PUSH
91680: LD_INT 1
91682: ST_TO_ADDR
// if p3 = 13 then
91683: LD_VAR 0 3
91687: PUSH
91688: LD_INT 13
91690: EQUAL
91691: IFFALSE 91701
// sDepot := true ;
91693: LD_ADDR_EXP 111
91697: PUSH
91698: LD_INT 1
91700: ST_TO_ADDR
// if p3 = 14 then
91701: LD_VAR 0 3
91705: PUSH
91706: LD_INT 14
91708: EQUAL
91709: IFFALSE 91719
// sFlag := true ;
91711: LD_ADDR_EXP 112
91715: PUSH
91716: LD_INT 1
91718: ST_TO_ADDR
// if p3 = 15 then
91719: LD_VAR 0 3
91723: PUSH
91724: LD_INT 15
91726: EQUAL
91727: IFFALSE 91737
// sKamikadze := true ;
91729: LD_ADDR_EXP 120
91733: PUSH
91734: LD_INT 1
91736: ST_TO_ADDR
// if p3 = 16 then
91737: LD_VAR 0 3
91741: PUSH
91742: LD_INT 16
91744: EQUAL
91745: IFFALSE 91755
// sTroll := true ;
91747: LD_ADDR_EXP 121
91751: PUSH
91752: LD_INT 1
91754: ST_TO_ADDR
// if p3 = 17 then
91755: LD_VAR 0 3
91759: PUSH
91760: LD_INT 17
91762: EQUAL
91763: IFFALSE 91773
// sSlow := true ;
91765: LD_ADDR_EXP 122
91769: PUSH
91770: LD_INT 1
91772: ST_TO_ADDR
// if p3 = 18 then
91773: LD_VAR 0 3
91777: PUSH
91778: LD_INT 18
91780: EQUAL
91781: IFFALSE 91791
// sLack := true ;
91783: LD_ADDR_EXP 123
91787: PUSH
91788: LD_INT 1
91790: ST_TO_ADDR
// if p3 = 19 then
91791: LD_VAR 0 3
91795: PUSH
91796: LD_INT 19
91798: EQUAL
91799: IFFALSE 91809
// sTank := true ;
91801: LD_ADDR_EXP 125
91805: PUSH
91806: LD_INT 1
91808: ST_TO_ADDR
// if p3 = 20 then
91809: LD_VAR 0 3
91813: PUSH
91814: LD_INT 20
91816: EQUAL
91817: IFFALSE 91827
// sRemote := true ;
91819: LD_ADDR_EXP 126
91823: PUSH
91824: LD_INT 1
91826: ST_TO_ADDR
// if p3 = 21 then
91827: LD_VAR 0 3
91831: PUSH
91832: LD_INT 21
91834: EQUAL
91835: IFFALSE 91845
// sPowell := true ;
91837: LD_ADDR_EXP 127
91841: PUSH
91842: LD_INT 1
91844: ST_TO_ADDR
// if p3 = 22 then
91845: LD_VAR 0 3
91849: PUSH
91850: LD_INT 22
91852: EQUAL
91853: IFFALSE 91863
// sTeleport := true ;
91855: LD_ADDR_EXP 130
91859: PUSH
91860: LD_INT 1
91862: ST_TO_ADDR
// if p3 = 23 then
91863: LD_VAR 0 3
91867: PUSH
91868: LD_INT 23
91870: EQUAL
91871: IFFALSE 91881
// sOilTower := true ;
91873: LD_ADDR_EXP 132
91877: PUSH
91878: LD_INT 1
91880: ST_TO_ADDR
// if p3 = 24 then
91881: LD_VAR 0 3
91885: PUSH
91886: LD_INT 24
91888: EQUAL
91889: IFFALSE 91899
// sShovel := true ;
91891: LD_ADDR_EXP 133
91895: PUSH
91896: LD_INT 1
91898: ST_TO_ADDR
// if p3 = 25 then
91899: LD_VAR 0 3
91903: PUSH
91904: LD_INT 25
91906: EQUAL
91907: IFFALSE 91917
// sSheik := true ;
91909: LD_ADDR_EXP 134
91913: PUSH
91914: LD_INT 1
91916: ST_TO_ADDR
// if p3 = 26 then
91917: LD_VAR 0 3
91921: PUSH
91922: LD_INT 26
91924: EQUAL
91925: IFFALSE 91935
// sEarthquake := true ;
91927: LD_ADDR_EXP 136
91931: PUSH
91932: LD_INT 1
91934: ST_TO_ADDR
// if p3 = 27 then
91935: LD_VAR 0 3
91939: PUSH
91940: LD_INT 27
91942: EQUAL
91943: IFFALSE 91953
// sAI := true ;
91945: LD_ADDR_EXP 137
91949: PUSH
91950: LD_INT 1
91952: ST_TO_ADDR
// if p3 = 28 then
91953: LD_VAR 0 3
91957: PUSH
91958: LD_INT 28
91960: EQUAL
91961: IFFALSE 91971
// sCargo := true ;
91963: LD_ADDR_EXP 140
91967: PUSH
91968: LD_INT 1
91970: ST_TO_ADDR
// if p3 = 29 then
91971: LD_VAR 0 3
91975: PUSH
91976: LD_INT 29
91978: EQUAL
91979: IFFALSE 91989
// sDLaser := true ;
91981: LD_ADDR_EXP 141
91985: PUSH
91986: LD_INT 1
91988: ST_TO_ADDR
// if p3 = 30 then
91989: LD_VAR 0 3
91993: PUSH
91994: LD_INT 30
91996: EQUAL
91997: IFFALSE 92007
// sExchange := true ;
91999: LD_ADDR_EXP 142
92003: PUSH
92004: LD_INT 1
92006: ST_TO_ADDR
// if p3 = 31 then
92007: LD_VAR 0 3
92011: PUSH
92012: LD_INT 31
92014: EQUAL
92015: IFFALSE 92025
// sFac := true ;
92017: LD_ADDR_EXP 143
92021: PUSH
92022: LD_INT 1
92024: ST_TO_ADDR
// if p3 = 32 then
92025: LD_VAR 0 3
92029: PUSH
92030: LD_INT 32
92032: EQUAL
92033: IFFALSE 92043
// sPower := true ;
92035: LD_ADDR_EXP 144
92039: PUSH
92040: LD_INT 1
92042: ST_TO_ADDR
// if p3 = 33 then
92043: LD_VAR 0 3
92047: PUSH
92048: LD_INT 33
92050: EQUAL
92051: IFFALSE 92061
// sRandom := true ;
92053: LD_ADDR_EXP 145
92057: PUSH
92058: LD_INT 1
92060: ST_TO_ADDR
// if p3 = 34 then
92061: LD_VAR 0 3
92065: PUSH
92066: LD_INT 34
92068: EQUAL
92069: IFFALSE 92079
// sShield := true ;
92071: LD_ADDR_EXP 146
92075: PUSH
92076: LD_INT 1
92078: ST_TO_ADDR
// if p3 = 35 then
92079: LD_VAR 0 3
92083: PUSH
92084: LD_INT 35
92086: EQUAL
92087: IFFALSE 92097
// sTime := true ;
92089: LD_ADDR_EXP 147
92093: PUSH
92094: LD_INT 1
92096: ST_TO_ADDR
// if p3 = 36 then
92097: LD_VAR 0 3
92101: PUSH
92102: LD_INT 36
92104: EQUAL
92105: IFFALSE 92115
// sTools := true ;
92107: LD_ADDR_EXP 148
92111: PUSH
92112: LD_INT 1
92114: ST_TO_ADDR
// if p3 = 101 then
92115: LD_VAR 0 3
92119: PUSH
92120: LD_INT 101
92122: EQUAL
92123: IFFALSE 92133
// sSold := true ;
92125: LD_ADDR_EXP 113
92129: PUSH
92130: LD_INT 1
92132: ST_TO_ADDR
// if p3 = 102 then
92133: LD_VAR 0 3
92137: PUSH
92138: LD_INT 102
92140: EQUAL
92141: IFFALSE 92151
// sDiff := true ;
92143: LD_ADDR_EXP 114
92147: PUSH
92148: LD_INT 1
92150: ST_TO_ADDR
// if p3 = 103 then
92151: LD_VAR 0 3
92155: PUSH
92156: LD_INT 103
92158: EQUAL
92159: IFFALSE 92169
// sFog := true ;
92161: LD_ADDR_EXP 117
92165: PUSH
92166: LD_INT 1
92168: ST_TO_ADDR
// if p3 = 104 then
92169: LD_VAR 0 3
92173: PUSH
92174: LD_INT 104
92176: EQUAL
92177: IFFALSE 92187
// sReset := true ;
92179: LD_ADDR_EXP 118
92183: PUSH
92184: LD_INT 1
92186: ST_TO_ADDR
// if p3 = 105 then
92187: LD_VAR 0 3
92191: PUSH
92192: LD_INT 105
92194: EQUAL
92195: IFFALSE 92205
// sSun := true ;
92197: LD_ADDR_EXP 119
92201: PUSH
92202: LD_INT 1
92204: ST_TO_ADDR
// if p3 = 106 then
92205: LD_VAR 0 3
92209: PUSH
92210: LD_INT 106
92212: EQUAL
92213: IFFALSE 92223
// sTiger := true ;
92215: LD_ADDR_EXP 115
92219: PUSH
92220: LD_INT 1
92222: ST_TO_ADDR
// if p3 = 107 then
92223: LD_VAR 0 3
92227: PUSH
92228: LD_INT 107
92230: EQUAL
92231: IFFALSE 92241
// sBomb := true ;
92233: LD_ADDR_EXP 116
92237: PUSH
92238: LD_INT 1
92240: ST_TO_ADDR
// if p3 = 108 then
92241: LD_VAR 0 3
92245: PUSH
92246: LD_INT 108
92248: EQUAL
92249: IFFALSE 92259
// sWound := true ;
92251: LD_ADDR_EXP 124
92255: PUSH
92256: LD_INT 1
92258: ST_TO_ADDR
// if p3 = 109 then
92259: LD_VAR 0 3
92263: PUSH
92264: LD_INT 109
92266: EQUAL
92267: IFFALSE 92277
// sBetray := true ;
92269: LD_ADDR_EXP 128
92273: PUSH
92274: LD_INT 1
92276: ST_TO_ADDR
// if p3 = 110 then
92277: LD_VAR 0 3
92281: PUSH
92282: LD_INT 110
92284: EQUAL
92285: IFFALSE 92295
// sContamin := true ;
92287: LD_ADDR_EXP 129
92291: PUSH
92292: LD_INT 1
92294: ST_TO_ADDR
// if p3 = 111 then
92295: LD_VAR 0 3
92299: PUSH
92300: LD_INT 111
92302: EQUAL
92303: IFFALSE 92313
// sOil := true ;
92305: LD_ADDR_EXP 131
92309: PUSH
92310: LD_INT 1
92312: ST_TO_ADDR
// if p3 = 112 then
92313: LD_VAR 0 3
92317: PUSH
92318: LD_INT 112
92320: EQUAL
92321: IFFALSE 92331
// sStu := true ;
92323: LD_ADDR_EXP 135
92327: PUSH
92328: LD_INT 1
92330: ST_TO_ADDR
// if p3 = 113 then
92331: LD_VAR 0 3
92335: PUSH
92336: LD_INT 113
92338: EQUAL
92339: IFFALSE 92349
// sBazooka := true ;
92341: LD_ADDR_EXP 138
92345: PUSH
92346: LD_INT 1
92348: ST_TO_ADDR
// if p3 = 114 then
92349: LD_VAR 0 3
92353: PUSH
92354: LD_INT 114
92356: EQUAL
92357: IFFALSE 92367
// sMortar := true ;
92359: LD_ADDR_EXP 139
92363: PUSH
92364: LD_INT 1
92366: ST_TO_ADDR
// if p3 = 115 then
92367: LD_VAR 0 3
92371: PUSH
92372: LD_INT 115
92374: EQUAL
92375: IFFALSE 92385
// sRanger := true ;
92377: LD_ADDR_EXP 149
92381: PUSH
92382: LD_INT 1
92384: ST_TO_ADDR
// if p3 = 116 then
92385: LD_VAR 0 3
92389: PUSH
92390: LD_INT 116
92392: EQUAL
92393: IFFALSE 92403
// sComputer := true ;
92395: LD_ADDR_EXP 150
92399: PUSH
92400: LD_INT 1
92402: ST_TO_ADDR
// if p3 = 117 then
92403: LD_VAR 0 3
92407: PUSH
92408: LD_INT 117
92410: EQUAL
92411: IFFALSE 92421
// s30 := true ;
92413: LD_ADDR_EXP 151
92417: PUSH
92418: LD_INT 1
92420: ST_TO_ADDR
// if p3 = 118 then
92421: LD_VAR 0 3
92425: PUSH
92426: LD_INT 118
92428: EQUAL
92429: IFFALSE 92439
// s60 := true ;
92431: LD_ADDR_EXP 152
92435: PUSH
92436: LD_INT 1
92438: ST_TO_ADDR
// end ; if p2 = hack_mode then
92439: LD_VAR 0 2
92443: PUSH
92444: LD_INT 101
92446: EQUAL
92447: IFFALSE 92575
// begin case p3 of 1 :
92449: LD_VAR 0 3
92453: PUSH
92454: LD_INT 1
92456: DOUBLE
92457: EQUAL
92458: IFTRUE 92462
92460: GO 92469
92462: POP
// hHackUnlimitedResources ; 2 :
92463: CALL 104722 0 0
92467: GO 92575
92469: LD_INT 2
92471: DOUBLE
92472: EQUAL
92473: IFTRUE 92477
92475: GO 92484
92477: POP
// hHackSetLevel10 ; 3 :
92478: CALL 104855 0 0
92482: GO 92575
92484: LD_INT 3
92486: DOUBLE
92487: EQUAL
92488: IFTRUE 92492
92490: GO 92499
92492: POP
// hHackSetLevel10YourUnits ; 4 :
92493: CALL 104940 0 0
92497: GO 92575
92499: LD_INT 4
92501: DOUBLE
92502: EQUAL
92503: IFTRUE 92507
92505: GO 92514
92507: POP
// hHackInvincible ; 5 :
92508: CALL 105388 0 0
92512: GO 92575
92514: LD_INT 5
92516: DOUBLE
92517: EQUAL
92518: IFTRUE 92522
92520: GO 92529
92522: POP
// hHackInvisible ; 6 :
92523: CALL 105499 0 0
92527: GO 92575
92529: LD_INT 6
92531: DOUBLE
92532: EQUAL
92533: IFTRUE 92537
92535: GO 92544
92537: POP
// hHackChangeYourSide ; 7 :
92538: CALL 105556 0 0
92542: GO 92575
92544: LD_INT 7
92546: DOUBLE
92547: EQUAL
92548: IFTRUE 92552
92550: GO 92559
92552: POP
// hHackChangeUnitSide ; 8 :
92553: CALL 105598 0 0
92557: GO 92575
92559: LD_INT 8
92561: DOUBLE
92562: EQUAL
92563: IFTRUE 92567
92565: GO 92574
92567: POP
// hHackFog ; end ;
92568: CALL 105699 0 0
92572: GO 92575
92574: POP
// end ; if p2 = game_save_mode then
92575: LD_VAR 0 2
92579: PUSH
92580: LD_INT 102
92582: EQUAL
92583: IFFALSE 92638
// begin if p3 = 1 then
92585: LD_VAR 0 3
92589: PUSH
92590: LD_INT 1
92592: EQUAL
92593: IFFALSE 92605
// globalGameSaveCounter := p4 ;
92595: LD_ADDR_EXP 95
92599: PUSH
92600: LD_VAR 0 4
92604: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
92605: LD_VAR 0 3
92609: PUSH
92610: LD_INT 2
92612: EQUAL
92613: PUSH
92614: LD_EXP 95
92618: AND
92619: IFFALSE 92638
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92621: LD_STRING setGameSaveCounter(
92623: PUSH
92624: LD_EXP 95
92628: STR
92629: PUSH
92630: LD_STRING )
92632: STR
92633: PPUSH
92634: CALL_OW 559
// end ; end ;
92638: LD_VAR 0 7
92642: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92643: LD_INT 0
92645: PPUSH
// streamModeActive := false ;
92646: LD_ADDR_EXP 96
92650: PUSH
92651: LD_INT 0
92653: ST_TO_ADDR
// normalCounter := 36 ;
92654: LD_ADDR_EXP 97
92658: PUSH
92659: LD_INT 36
92661: ST_TO_ADDR
// hardcoreCounter := 18 ;
92662: LD_ADDR_EXP 98
92666: PUSH
92667: LD_INT 18
92669: ST_TO_ADDR
// sRocket := false ;
92670: LD_ADDR_EXP 101
92674: PUSH
92675: LD_INT 0
92677: ST_TO_ADDR
// sSpeed := false ;
92678: LD_ADDR_EXP 100
92682: PUSH
92683: LD_INT 0
92685: ST_TO_ADDR
// sEngine := false ;
92686: LD_ADDR_EXP 102
92690: PUSH
92691: LD_INT 0
92693: ST_TO_ADDR
// sSpec := false ;
92694: LD_ADDR_EXP 99
92698: PUSH
92699: LD_INT 0
92701: ST_TO_ADDR
// sLevel := false ;
92702: LD_ADDR_EXP 103
92706: PUSH
92707: LD_INT 0
92709: ST_TO_ADDR
// sArmoury := false ;
92710: LD_ADDR_EXP 104
92714: PUSH
92715: LD_INT 0
92717: ST_TO_ADDR
// sRadar := false ;
92718: LD_ADDR_EXP 105
92722: PUSH
92723: LD_INT 0
92725: ST_TO_ADDR
// sBunker := false ;
92726: LD_ADDR_EXP 106
92730: PUSH
92731: LD_INT 0
92733: ST_TO_ADDR
// sHack := false ;
92734: LD_ADDR_EXP 107
92738: PUSH
92739: LD_INT 0
92741: ST_TO_ADDR
// sFire := false ;
92742: LD_ADDR_EXP 108
92746: PUSH
92747: LD_INT 0
92749: ST_TO_ADDR
// sRefresh := false ;
92750: LD_ADDR_EXP 109
92754: PUSH
92755: LD_INT 0
92757: ST_TO_ADDR
// sExp := false ;
92758: LD_ADDR_EXP 110
92762: PUSH
92763: LD_INT 0
92765: ST_TO_ADDR
// sDepot := false ;
92766: LD_ADDR_EXP 111
92770: PUSH
92771: LD_INT 0
92773: ST_TO_ADDR
// sFlag := false ;
92774: LD_ADDR_EXP 112
92778: PUSH
92779: LD_INT 0
92781: ST_TO_ADDR
// sKamikadze := false ;
92782: LD_ADDR_EXP 120
92786: PUSH
92787: LD_INT 0
92789: ST_TO_ADDR
// sTroll := false ;
92790: LD_ADDR_EXP 121
92794: PUSH
92795: LD_INT 0
92797: ST_TO_ADDR
// sSlow := false ;
92798: LD_ADDR_EXP 122
92802: PUSH
92803: LD_INT 0
92805: ST_TO_ADDR
// sLack := false ;
92806: LD_ADDR_EXP 123
92810: PUSH
92811: LD_INT 0
92813: ST_TO_ADDR
// sTank := false ;
92814: LD_ADDR_EXP 125
92818: PUSH
92819: LD_INT 0
92821: ST_TO_ADDR
// sRemote := false ;
92822: LD_ADDR_EXP 126
92826: PUSH
92827: LD_INT 0
92829: ST_TO_ADDR
// sPowell := false ;
92830: LD_ADDR_EXP 127
92834: PUSH
92835: LD_INT 0
92837: ST_TO_ADDR
// sTeleport := false ;
92838: LD_ADDR_EXP 130
92842: PUSH
92843: LD_INT 0
92845: ST_TO_ADDR
// sOilTower := false ;
92846: LD_ADDR_EXP 132
92850: PUSH
92851: LD_INT 0
92853: ST_TO_ADDR
// sShovel := false ;
92854: LD_ADDR_EXP 133
92858: PUSH
92859: LD_INT 0
92861: ST_TO_ADDR
// sSheik := false ;
92862: LD_ADDR_EXP 134
92866: PUSH
92867: LD_INT 0
92869: ST_TO_ADDR
// sEarthquake := false ;
92870: LD_ADDR_EXP 136
92874: PUSH
92875: LD_INT 0
92877: ST_TO_ADDR
// sAI := false ;
92878: LD_ADDR_EXP 137
92882: PUSH
92883: LD_INT 0
92885: ST_TO_ADDR
// sCargo := false ;
92886: LD_ADDR_EXP 140
92890: PUSH
92891: LD_INT 0
92893: ST_TO_ADDR
// sDLaser := false ;
92894: LD_ADDR_EXP 141
92898: PUSH
92899: LD_INT 0
92901: ST_TO_ADDR
// sExchange := false ;
92902: LD_ADDR_EXP 142
92906: PUSH
92907: LD_INT 0
92909: ST_TO_ADDR
// sFac := false ;
92910: LD_ADDR_EXP 143
92914: PUSH
92915: LD_INT 0
92917: ST_TO_ADDR
// sPower := false ;
92918: LD_ADDR_EXP 144
92922: PUSH
92923: LD_INT 0
92925: ST_TO_ADDR
// sRandom := false ;
92926: LD_ADDR_EXP 145
92930: PUSH
92931: LD_INT 0
92933: ST_TO_ADDR
// sShield := false ;
92934: LD_ADDR_EXP 146
92938: PUSH
92939: LD_INT 0
92941: ST_TO_ADDR
// sTime := false ;
92942: LD_ADDR_EXP 147
92946: PUSH
92947: LD_INT 0
92949: ST_TO_ADDR
// sTools := false ;
92950: LD_ADDR_EXP 148
92954: PUSH
92955: LD_INT 0
92957: ST_TO_ADDR
// sSold := false ;
92958: LD_ADDR_EXP 113
92962: PUSH
92963: LD_INT 0
92965: ST_TO_ADDR
// sDiff := false ;
92966: LD_ADDR_EXP 114
92970: PUSH
92971: LD_INT 0
92973: ST_TO_ADDR
// sFog := false ;
92974: LD_ADDR_EXP 117
92978: PUSH
92979: LD_INT 0
92981: ST_TO_ADDR
// sReset := false ;
92982: LD_ADDR_EXP 118
92986: PUSH
92987: LD_INT 0
92989: ST_TO_ADDR
// sSun := false ;
92990: LD_ADDR_EXP 119
92994: PUSH
92995: LD_INT 0
92997: ST_TO_ADDR
// sTiger := false ;
92998: LD_ADDR_EXP 115
93002: PUSH
93003: LD_INT 0
93005: ST_TO_ADDR
// sBomb := false ;
93006: LD_ADDR_EXP 116
93010: PUSH
93011: LD_INT 0
93013: ST_TO_ADDR
// sWound := false ;
93014: LD_ADDR_EXP 124
93018: PUSH
93019: LD_INT 0
93021: ST_TO_ADDR
// sBetray := false ;
93022: LD_ADDR_EXP 128
93026: PUSH
93027: LD_INT 0
93029: ST_TO_ADDR
// sContamin := false ;
93030: LD_ADDR_EXP 129
93034: PUSH
93035: LD_INT 0
93037: ST_TO_ADDR
// sOil := false ;
93038: LD_ADDR_EXP 131
93042: PUSH
93043: LD_INT 0
93045: ST_TO_ADDR
// sStu := false ;
93046: LD_ADDR_EXP 135
93050: PUSH
93051: LD_INT 0
93053: ST_TO_ADDR
// sBazooka := false ;
93054: LD_ADDR_EXP 138
93058: PUSH
93059: LD_INT 0
93061: ST_TO_ADDR
// sMortar := false ;
93062: LD_ADDR_EXP 139
93066: PUSH
93067: LD_INT 0
93069: ST_TO_ADDR
// sRanger := false ;
93070: LD_ADDR_EXP 149
93074: PUSH
93075: LD_INT 0
93077: ST_TO_ADDR
// sComputer := false ;
93078: LD_ADDR_EXP 150
93082: PUSH
93083: LD_INT 0
93085: ST_TO_ADDR
// s30 := false ;
93086: LD_ADDR_EXP 151
93090: PUSH
93091: LD_INT 0
93093: ST_TO_ADDR
// s60 := false ;
93094: LD_ADDR_EXP 152
93098: PUSH
93099: LD_INT 0
93101: ST_TO_ADDR
// end ;
93102: LD_VAR 0 1
93106: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93107: LD_INT 0
93109: PPUSH
93110: PPUSH
93111: PPUSH
93112: PPUSH
93113: PPUSH
93114: PPUSH
93115: PPUSH
// result := [ ] ;
93116: LD_ADDR_VAR 0 2
93120: PUSH
93121: EMPTY
93122: ST_TO_ADDR
// if campaign_id = 1 then
93123: LD_OWVAR 69
93127: PUSH
93128: LD_INT 1
93130: EQUAL
93131: IFFALSE 96297
// begin case mission_number of 1 :
93133: LD_OWVAR 70
93137: PUSH
93138: LD_INT 1
93140: DOUBLE
93141: EQUAL
93142: IFTRUE 93146
93144: GO 93222
93146: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93147: LD_ADDR_VAR 0 2
93151: PUSH
93152: LD_INT 2
93154: PUSH
93155: LD_INT 4
93157: PUSH
93158: LD_INT 11
93160: PUSH
93161: LD_INT 12
93163: PUSH
93164: LD_INT 15
93166: PUSH
93167: LD_INT 16
93169: PUSH
93170: LD_INT 22
93172: PUSH
93173: LD_INT 23
93175: PUSH
93176: LD_INT 26
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 101
93192: PUSH
93193: LD_INT 102
93195: PUSH
93196: LD_INT 106
93198: PUSH
93199: LD_INT 116
93201: PUSH
93202: LD_INT 117
93204: PUSH
93205: LD_INT 118
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: ST_TO_ADDR
93220: GO 96295
93222: LD_INT 2
93224: DOUBLE
93225: EQUAL
93226: IFTRUE 93230
93228: GO 93314
93230: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93231: LD_ADDR_VAR 0 2
93235: PUSH
93236: LD_INT 2
93238: PUSH
93239: LD_INT 4
93241: PUSH
93242: LD_INT 11
93244: PUSH
93245: LD_INT 12
93247: PUSH
93248: LD_INT 15
93250: PUSH
93251: LD_INT 16
93253: PUSH
93254: LD_INT 22
93256: PUSH
93257: LD_INT 23
93259: PUSH
93260: LD_INT 26
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: LIST
93273: PUSH
93274: LD_INT 101
93276: PUSH
93277: LD_INT 102
93279: PUSH
93280: LD_INT 105
93282: PUSH
93283: LD_INT 106
93285: PUSH
93286: LD_INT 108
93288: PUSH
93289: LD_INT 116
93291: PUSH
93292: LD_INT 117
93294: PUSH
93295: LD_INT 118
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: ST_TO_ADDR
93312: GO 96295
93314: LD_INT 3
93316: DOUBLE
93317: EQUAL
93318: IFTRUE 93322
93320: GO 93410
93322: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93323: LD_ADDR_VAR 0 2
93327: PUSH
93328: LD_INT 2
93330: PUSH
93331: LD_INT 4
93333: PUSH
93334: LD_INT 5
93336: PUSH
93337: LD_INT 11
93339: PUSH
93340: LD_INT 12
93342: PUSH
93343: LD_INT 15
93345: PUSH
93346: LD_INT 16
93348: PUSH
93349: LD_INT 22
93351: PUSH
93352: LD_INT 26
93354: PUSH
93355: LD_INT 36
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 101
93372: PUSH
93373: LD_INT 102
93375: PUSH
93376: LD_INT 105
93378: PUSH
93379: LD_INT 106
93381: PUSH
93382: LD_INT 108
93384: PUSH
93385: LD_INT 116
93387: PUSH
93388: LD_INT 117
93390: PUSH
93391: LD_INT 118
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: ST_TO_ADDR
93408: GO 96295
93410: LD_INT 4
93412: DOUBLE
93413: EQUAL
93414: IFTRUE 93418
93416: GO 93514
93418: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93419: LD_ADDR_VAR 0 2
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: LD_INT 4
93429: PUSH
93430: LD_INT 5
93432: PUSH
93433: LD_INT 8
93435: PUSH
93436: LD_INT 11
93438: PUSH
93439: LD_INT 12
93441: PUSH
93442: LD_INT 15
93444: PUSH
93445: LD_INT 16
93447: PUSH
93448: LD_INT 22
93450: PUSH
93451: LD_INT 23
93453: PUSH
93454: LD_INT 26
93456: PUSH
93457: LD_INT 36
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: PUSH
93474: LD_INT 101
93476: PUSH
93477: LD_INT 102
93479: PUSH
93480: LD_INT 105
93482: PUSH
93483: LD_INT 106
93485: PUSH
93486: LD_INT 108
93488: PUSH
93489: LD_INT 116
93491: PUSH
93492: LD_INT 117
93494: PUSH
93495: LD_INT 118
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: ST_TO_ADDR
93512: GO 96295
93514: LD_INT 5
93516: DOUBLE
93517: EQUAL
93518: IFTRUE 93522
93520: GO 93634
93522: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93523: LD_ADDR_VAR 0 2
93527: PUSH
93528: LD_INT 2
93530: PUSH
93531: LD_INT 4
93533: PUSH
93534: LD_INT 5
93536: PUSH
93537: LD_INT 6
93539: PUSH
93540: LD_INT 8
93542: PUSH
93543: LD_INT 11
93545: PUSH
93546: LD_INT 12
93548: PUSH
93549: LD_INT 15
93551: PUSH
93552: LD_INT 16
93554: PUSH
93555: LD_INT 22
93557: PUSH
93558: LD_INT 23
93560: PUSH
93561: LD_INT 25
93563: PUSH
93564: LD_INT 26
93566: PUSH
93567: LD_INT 36
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: PUSH
93586: LD_INT 101
93588: PUSH
93589: LD_INT 102
93591: PUSH
93592: LD_INT 105
93594: PUSH
93595: LD_INT 106
93597: PUSH
93598: LD_INT 108
93600: PUSH
93601: LD_INT 109
93603: PUSH
93604: LD_INT 112
93606: PUSH
93607: LD_INT 116
93609: PUSH
93610: LD_INT 117
93612: PUSH
93613: LD_INT 118
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: ST_TO_ADDR
93632: GO 96295
93634: LD_INT 6
93636: DOUBLE
93637: EQUAL
93638: IFTRUE 93642
93640: GO 93774
93642: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93643: LD_ADDR_VAR 0 2
93647: PUSH
93648: LD_INT 2
93650: PUSH
93651: LD_INT 4
93653: PUSH
93654: LD_INT 5
93656: PUSH
93657: LD_INT 6
93659: PUSH
93660: LD_INT 8
93662: PUSH
93663: LD_INT 11
93665: PUSH
93666: LD_INT 12
93668: PUSH
93669: LD_INT 15
93671: PUSH
93672: LD_INT 16
93674: PUSH
93675: LD_INT 20
93677: PUSH
93678: LD_INT 21
93680: PUSH
93681: LD_INT 22
93683: PUSH
93684: LD_INT 23
93686: PUSH
93687: LD_INT 25
93689: PUSH
93690: LD_INT 26
93692: PUSH
93693: LD_INT 30
93695: PUSH
93696: LD_INT 31
93698: PUSH
93699: LD_INT 32
93701: PUSH
93702: LD_INT 36
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: PUSH
93726: LD_INT 101
93728: PUSH
93729: LD_INT 102
93731: PUSH
93732: LD_INT 105
93734: PUSH
93735: LD_INT 106
93737: PUSH
93738: LD_INT 108
93740: PUSH
93741: LD_INT 109
93743: PUSH
93744: LD_INT 112
93746: PUSH
93747: LD_INT 116
93749: PUSH
93750: LD_INT 117
93752: PUSH
93753: LD_INT 118
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: ST_TO_ADDR
93772: GO 96295
93774: LD_INT 7
93776: DOUBLE
93777: EQUAL
93778: IFTRUE 93782
93780: GO 93894
93782: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93783: LD_ADDR_VAR 0 2
93787: PUSH
93788: LD_INT 2
93790: PUSH
93791: LD_INT 4
93793: PUSH
93794: LD_INT 5
93796: PUSH
93797: LD_INT 7
93799: PUSH
93800: LD_INT 11
93802: PUSH
93803: LD_INT 12
93805: PUSH
93806: LD_INT 15
93808: PUSH
93809: LD_INT 16
93811: PUSH
93812: LD_INT 20
93814: PUSH
93815: LD_INT 21
93817: PUSH
93818: LD_INT 22
93820: PUSH
93821: LD_INT 23
93823: PUSH
93824: LD_INT 25
93826: PUSH
93827: LD_INT 26
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 101
93848: PUSH
93849: LD_INT 102
93851: PUSH
93852: LD_INT 103
93854: PUSH
93855: LD_INT 105
93857: PUSH
93858: LD_INT 106
93860: PUSH
93861: LD_INT 108
93863: PUSH
93864: LD_INT 112
93866: PUSH
93867: LD_INT 116
93869: PUSH
93870: LD_INT 117
93872: PUSH
93873: LD_INT 118
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: ST_TO_ADDR
93892: GO 96295
93894: LD_INT 8
93896: DOUBLE
93897: EQUAL
93898: IFTRUE 93902
93900: GO 94042
93902: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93903: LD_ADDR_VAR 0 2
93907: PUSH
93908: LD_INT 2
93910: PUSH
93911: LD_INT 4
93913: PUSH
93914: LD_INT 5
93916: PUSH
93917: LD_INT 6
93919: PUSH
93920: LD_INT 7
93922: PUSH
93923: LD_INT 8
93925: PUSH
93926: LD_INT 11
93928: PUSH
93929: LD_INT 12
93931: PUSH
93932: LD_INT 15
93934: PUSH
93935: LD_INT 16
93937: PUSH
93938: LD_INT 20
93940: PUSH
93941: LD_INT 21
93943: PUSH
93944: LD_INT 22
93946: PUSH
93947: LD_INT 23
93949: PUSH
93950: LD_INT 25
93952: PUSH
93953: LD_INT 26
93955: PUSH
93956: LD_INT 30
93958: PUSH
93959: LD_INT 31
93961: PUSH
93962: LD_INT 32
93964: PUSH
93965: LD_INT 36
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: PUSH
93990: LD_INT 101
93992: PUSH
93993: LD_INT 102
93995: PUSH
93996: LD_INT 103
93998: PUSH
93999: LD_INT 105
94001: PUSH
94002: LD_INT 106
94004: PUSH
94005: LD_INT 108
94007: PUSH
94008: LD_INT 109
94010: PUSH
94011: LD_INT 112
94013: PUSH
94014: LD_INT 116
94016: PUSH
94017: LD_INT 117
94019: PUSH
94020: LD_INT 118
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: ST_TO_ADDR
94040: GO 96295
94042: LD_INT 9
94044: DOUBLE
94045: EQUAL
94046: IFTRUE 94050
94048: GO 94198
94050: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94051: LD_ADDR_VAR 0 2
94055: PUSH
94056: LD_INT 2
94058: PUSH
94059: LD_INT 4
94061: PUSH
94062: LD_INT 5
94064: PUSH
94065: LD_INT 6
94067: PUSH
94068: LD_INT 7
94070: PUSH
94071: LD_INT 8
94073: PUSH
94074: LD_INT 11
94076: PUSH
94077: LD_INT 12
94079: PUSH
94080: LD_INT 15
94082: PUSH
94083: LD_INT 16
94085: PUSH
94086: LD_INT 20
94088: PUSH
94089: LD_INT 21
94091: PUSH
94092: LD_INT 22
94094: PUSH
94095: LD_INT 23
94097: PUSH
94098: LD_INT 25
94100: PUSH
94101: LD_INT 26
94103: PUSH
94104: LD_INT 28
94106: PUSH
94107: LD_INT 30
94109: PUSH
94110: LD_INT 31
94112: PUSH
94113: LD_INT 32
94115: PUSH
94116: LD_INT 36
94118: PUSH
94119: EMPTY
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: PUSH
94142: LD_INT 101
94144: PUSH
94145: LD_INT 102
94147: PUSH
94148: LD_INT 103
94150: PUSH
94151: LD_INT 105
94153: PUSH
94154: LD_INT 106
94156: PUSH
94157: LD_INT 108
94159: PUSH
94160: LD_INT 109
94162: PUSH
94163: LD_INT 112
94165: PUSH
94166: LD_INT 114
94168: PUSH
94169: LD_INT 116
94171: PUSH
94172: LD_INT 117
94174: PUSH
94175: LD_INT 118
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: LIST
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: ST_TO_ADDR
94196: GO 96295
94198: LD_INT 10
94200: DOUBLE
94201: EQUAL
94202: IFTRUE 94206
94204: GO 94402
94206: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94207: LD_ADDR_VAR 0 2
94211: PUSH
94212: LD_INT 2
94214: PUSH
94215: LD_INT 4
94217: PUSH
94218: LD_INT 5
94220: PUSH
94221: LD_INT 6
94223: PUSH
94224: LD_INT 7
94226: PUSH
94227: LD_INT 8
94229: PUSH
94230: LD_INT 9
94232: PUSH
94233: LD_INT 10
94235: PUSH
94236: LD_INT 11
94238: PUSH
94239: LD_INT 12
94241: PUSH
94242: LD_INT 13
94244: PUSH
94245: LD_INT 14
94247: PUSH
94248: LD_INT 15
94250: PUSH
94251: LD_INT 16
94253: PUSH
94254: LD_INT 17
94256: PUSH
94257: LD_INT 18
94259: PUSH
94260: LD_INT 19
94262: PUSH
94263: LD_INT 20
94265: PUSH
94266: LD_INT 21
94268: PUSH
94269: LD_INT 22
94271: PUSH
94272: LD_INT 23
94274: PUSH
94275: LD_INT 24
94277: PUSH
94278: LD_INT 25
94280: PUSH
94281: LD_INT 26
94283: PUSH
94284: LD_INT 28
94286: PUSH
94287: LD_INT 30
94289: PUSH
94290: LD_INT 31
94292: PUSH
94293: LD_INT 32
94295: PUSH
94296: LD_INT 36
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 101
94332: PUSH
94333: LD_INT 102
94335: PUSH
94336: LD_INT 103
94338: PUSH
94339: LD_INT 104
94341: PUSH
94342: LD_INT 105
94344: PUSH
94345: LD_INT 106
94347: PUSH
94348: LD_INT 107
94350: PUSH
94351: LD_INT 108
94353: PUSH
94354: LD_INT 109
94356: PUSH
94357: LD_INT 110
94359: PUSH
94360: LD_INT 111
94362: PUSH
94363: LD_INT 112
94365: PUSH
94366: LD_INT 114
94368: PUSH
94369: LD_INT 116
94371: PUSH
94372: LD_INT 117
94374: PUSH
94375: LD_INT 118
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: ST_TO_ADDR
94400: GO 96295
94402: LD_INT 11
94404: DOUBLE
94405: EQUAL
94406: IFTRUE 94410
94408: GO 94614
94410: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94411: LD_ADDR_VAR 0 2
94415: PUSH
94416: LD_INT 2
94418: PUSH
94419: LD_INT 3
94421: PUSH
94422: LD_INT 4
94424: PUSH
94425: LD_INT 5
94427: PUSH
94428: LD_INT 6
94430: PUSH
94431: LD_INT 7
94433: PUSH
94434: LD_INT 8
94436: PUSH
94437: LD_INT 9
94439: PUSH
94440: LD_INT 10
94442: PUSH
94443: LD_INT 11
94445: PUSH
94446: LD_INT 12
94448: PUSH
94449: LD_INT 13
94451: PUSH
94452: LD_INT 14
94454: PUSH
94455: LD_INT 15
94457: PUSH
94458: LD_INT 16
94460: PUSH
94461: LD_INT 17
94463: PUSH
94464: LD_INT 18
94466: PUSH
94467: LD_INT 19
94469: PUSH
94470: LD_INT 20
94472: PUSH
94473: LD_INT 21
94475: PUSH
94476: LD_INT 22
94478: PUSH
94479: LD_INT 23
94481: PUSH
94482: LD_INT 24
94484: PUSH
94485: LD_INT 25
94487: PUSH
94488: LD_INT 26
94490: PUSH
94491: LD_INT 28
94493: PUSH
94494: LD_INT 30
94496: PUSH
94497: LD_INT 31
94499: PUSH
94500: LD_INT 32
94502: PUSH
94503: LD_INT 34
94505: PUSH
94506: LD_INT 36
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: PUSH
94542: LD_INT 101
94544: PUSH
94545: LD_INT 102
94547: PUSH
94548: LD_INT 103
94550: PUSH
94551: LD_INT 104
94553: PUSH
94554: LD_INT 105
94556: PUSH
94557: LD_INT 106
94559: PUSH
94560: LD_INT 107
94562: PUSH
94563: LD_INT 108
94565: PUSH
94566: LD_INT 109
94568: PUSH
94569: LD_INT 110
94571: PUSH
94572: LD_INT 111
94574: PUSH
94575: LD_INT 112
94577: PUSH
94578: LD_INT 114
94580: PUSH
94581: LD_INT 116
94583: PUSH
94584: LD_INT 117
94586: PUSH
94587: LD_INT 118
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: ST_TO_ADDR
94612: GO 96295
94614: LD_INT 12
94616: DOUBLE
94617: EQUAL
94618: IFTRUE 94622
94620: GO 94842
94622: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94623: LD_ADDR_VAR 0 2
94627: PUSH
94628: LD_INT 1
94630: PUSH
94631: LD_INT 2
94633: PUSH
94634: LD_INT 3
94636: PUSH
94637: LD_INT 4
94639: PUSH
94640: LD_INT 5
94642: PUSH
94643: LD_INT 6
94645: PUSH
94646: LD_INT 7
94648: PUSH
94649: LD_INT 8
94651: PUSH
94652: LD_INT 9
94654: PUSH
94655: LD_INT 10
94657: PUSH
94658: LD_INT 11
94660: PUSH
94661: LD_INT 12
94663: PUSH
94664: LD_INT 13
94666: PUSH
94667: LD_INT 14
94669: PUSH
94670: LD_INT 15
94672: PUSH
94673: LD_INT 16
94675: PUSH
94676: LD_INT 17
94678: PUSH
94679: LD_INT 18
94681: PUSH
94682: LD_INT 19
94684: PUSH
94685: LD_INT 20
94687: PUSH
94688: LD_INT 21
94690: PUSH
94691: LD_INT 22
94693: PUSH
94694: LD_INT 23
94696: PUSH
94697: LD_INT 24
94699: PUSH
94700: LD_INT 25
94702: PUSH
94703: LD_INT 26
94705: PUSH
94706: LD_INT 27
94708: PUSH
94709: LD_INT 28
94711: PUSH
94712: LD_INT 30
94714: PUSH
94715: LD_INT 31
94717: PUSH
94718: LD_INT 32
94720: PUSH
94721: LD_INT 33
94723: PUSH
94724: LD_INT 34
94726: PUSH
94727: LD_INT 36
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: PUSH
94766: LD_INT 101
94768: PUSH
94769: LD_INT 102
94771: PUSH
94772: LD_INT 103
94774: PUSH
94775: LD_INT 104
94777: PUSH
94778: LD_INT 105
94780: PUSH
94781: LD_INT 106
94783: PUSH
94784: LD_INT 107
94786: PUSH
94787: LD_INT 108
94789: PUSH
94790: LD_INT 109
94792: PUSH
94793: LD_INT 110
94795: PUSH
94796: LD_INT 111
94798: PUSH
94799: LD_INT 112
94801: PUSH
94802: LD_INT 113
94804: PUSH
94805: LD_INT 114
94807: PUSH
94808: LD_INT 116
94810: PUSH
94811: LD_INT 117
94813: PUSH
94814: LD_INT 118
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: ST_TO_ADDR
94840: GO 96295
94842: LD_INT 13
94844: DOUBLE
94845: EQUAL
94846: IFTRUE 94850
94848: GO 95058
94850: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94851: LD_ADDR_VAR 0 2
94855: PUSH
94856: LD_INT 1
94858: PUSH
94859: LD_INT 2
94861: PUSH
94862: LD_INT 3
94864: PUSH
94865: LD_INT 4
94867: PUSH
94868: LD_INT 5
94870: PUSH
94871: LD_INT 8
94873: PUSH
94874: LD_INT 9
94876: PUSH
94877: LD_INT 10
94879: PUSH
94880: LD_INT 11
94882: PUSH
94883: LD_INT 12
94885: PUSH
94886: LD_INT 14
94888: PUSH
94889: LD_INT 15
94891: PUSH
94892: LD_INT 16
94894: PUSH
94895: LD_INT 17
94897: PUSH
94898: LD_INT 18
94900: PUSH
94901: LD_INT 19
94903: PUSH
94904: LD_INT 20
94906: PUSH
94907: LD_INT 21
94909: PUSH
94910: LD_INT 22
94912: PUSH
94913: LD_INT 23
94915: PUSH
94916: LD_INT 24
94918: PUSH
94919: LD_INT 25
94921: PUSH
94922: LD_INT 26
94924: PUSH
94925: LD_INT 27
94927: PUSH
94928: LD_INT 28
94930: PUSH
94931: LD_INT 30
94933: PUSH
94934: LD_INT 31
94936: PUSH
94937: LD_INT 32
94939: PUSH
94940: LD_INT 33
94942: PUSH
94943: LD_INT 34
94945: PUSH
94946: LD_INT 36
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 101
94984: PUSH
94985: LD_INT 102
94987: PUSH
94988: LD_INT 103
94990: PUSH
94991: LD_INT 104
94993: PUSH
94994: LD_INT 105
94996: PUSH
94997: LD_INT 106
94999: PUSH
95000: LD_INT 107
95002: PUSH
95003: LD_INT 108
95005: PUSH
95006: LD_INT 109
95008: PUSH
95009: LD_INT 110
95011: PUSH
95012: LD_INT 111
95014: PUSH
95015: LD_INT 112
95017: PUSH
95018: LD_INT 113
95020: PUSH
95021: LD_INT 114
95023: PUSH
95024: LD_INT 116
95026: PUSH
95027: LD_INT 117
95029: PUSH
95030: LD_INT 118
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: ST_TO_ADDR
95056: GO 96295
95058: LD_INT 14
95060: DOUBLE
95061: EQUAL
95062: IFTRUE 95066
95064: GO 95290
95066: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95067: LD_ADDR_VAR 0 2
95071: PUSH
95072: LD_INT 1
95074: PUSH
95075: LD_INT 2
95077: PUSH
95078: LD_INT 3
95080: PUSH
95081: LD_INT 4
95083: PUSH
95084: LD_INT 5
95086: PUSH
95087: LD_INT 6
95089: PUSH
95090: LD_INT 7
95092: PUSH
95093: LD_INT 8
95095: PUSH
95096: LD_INT 9
95098: PUSH
95099: LD_INT 10
95101: PUSH
95102: LD_INT 11
95104: PUSH
95105: LD_INT 12
95107: PUSH
95108: LD_INT 13
95110: PUSH
95111: LD_INT 14
95113: PUSH
95114: LD_INT 15
95116: PUSH
95117: LD_INT 16
95119: PUSH
95120: LD_INT 17
95122: PUSH
95123: LD_INT 18
95125: PUSH
95126: LD_INT 19
95128: PUSH
95129: LD_INT 20
95131: PUSH
95132: LD_INT 21
95134: PUSH
95135: LD_INT 22
95137: PUSH
95138: LD_INT 23
95140: PUSH
95141: LD_INT 24
95143: PUSH
95144: LD_INT 25
95146: PUSH
95147: LD_INT 26
95149: PUSH
95150: LD_INT 27
95152: PUSH
95153: LD_INT 28
95155: PUSH
95156: LD_INT 29
95158: PUSH
95159: LD_INT 30
95161: PUSH
95162: LD_INT 31
95164: PUSH
95165: LD_INT 32
95167: PUSH
95168: LD_INT 33
95170: PUSH
95171: LD_INT 34
95173: PUSH
95174: LD_INT 36
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: PUSH
95214: LD_INT 101
95216: PUSH
95217: LD_INT 102
95219: PUSH
95220: LD_INT 103
95222: PUSH
95223: LD_INT 104
95225: PUSH
95226: LD_INT 105
95228: PUSH
95229: LD_INT 106
95231: PUSH
95232: LD_INT 107
95234: PUSH
95235: LD_INT 108
95237: PUSH
95238: LD_INT 109
95240: PUSH
95241: LD_INT 110
95243: PUSH
95244: LD_INT 111
95246: PUSH
95247: LD_INT 112
95249: PUSH
95250: LD_INT 113
95252: PUSH
95253: LD_INT 114
95255: PUSH
95256: LD_INT 116
95258: PUSH
95259: LD_INT 117
95261: PUSH
95262: LD_INT 118
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: ST_TO_ADDR
95288: GO 96295
95290: LD_INT 15
95292: DOUBLE
95293: EQUAL
95294: IFTRUE 95298
95296: GO 95522
95298: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95299: LD_ADDR_VAR 0 2
95303: PUSH
95304: LD_INT 1
95306: PUSH
95307: LD_INT 2
95309: PUSH
95310: LD_INT 3
95312: PUSH
95313: LD_INT 4
95315: PUSH
95316: LD_INT 5
95318: PUSH
95319: LD_INT 6
95321: PUSH
95322: LD_INT 7
95324: PUSH
95325: LD_INT 8
95327: PUSH
95328: LD_INT 9
95330: PUSH
95331: LD_INT 10
95333: PUSH
95334: LD_INT 11
95336: PUSH
95337: LD_INT 12
95339: PUSH
95340: LD_INT 13
95342: PUSH
95343: LD_INT 14
95345: PUSH
95346: LD_INT 15
95348: PUSH
95349: LD_INT 16
95351: PUSH
95352: LD_INT 17
95354: PUSH
95355: LD_INT 18
95357: PUSH
95358: LD_INT 19
95360: PUSH
95361: LD_INT 20
95363: PUSH
95364: LD_INT 21
95366: PUSH
95367: LD_INT 22
95369: PUSH
95370: LD_INT 23
95372: PUSH
95373: LD_INT 24
95375: PUSH
95376: LD_INT 25
95378: PUSH
95379: LD_INT 26
95381: PUSH
95382: LD_INT 27
95384: PUSH
95385: LD_INT 28
95387: PUSH
95388: LD_INT 29
95390: PUSH
95391: LD_INT 30
95393: PUSH
95394: LD_INT 31
95396: PUSH
95397: LD_INT 32
95399: PUSH
95400: LD_INT 33
95402: PUSH
95403: LD_INT 34
95405: PUSH
95406: LD_INT 36
95408: PUSH
95409: EMPTY
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: PUSH
95446: LD_INT 101
95448: PUSH
95449: LD_INT 102
95451: PUSH
95452: LD_INT 103
95454: PUSH
95455: LD_INT 104
95457: PUSH
95458: LD_INT 105
95460: PUSH
95461: LD_INT 106
95463: PUSH
95464: LD_INT 107
95466: PUSH
95467: LD_INT 108
95469: PUSH
95470: LD_INT 109
95472: PUSH
95473: LD_INT 110
95475: PUSH
95476: LD_INT 111
95478: PUSH
95479: LD_INT 112
95481: PUSH
95482: LD_INT 113
95484: PUSH
95485: LD_INT 114
95487: PUSH
95488: LD_INT 116
95490: PUSH
95491: LD_INT 117
95493: PUSH
95494: LD_INT 118
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: ST_TO_ADDR
95520: GO 96295
95522: LD_INT 16
95524: DOUBLE
95525: EQUAL
95526: IFTRUE 95530
95528: GO 95666
95530: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95531: LD_ADDR_VAR 0 2
95535: PUSH
95536: LD_INT 2
95538: PUSH
95539: LD_INT 4
95541: PUSH
95542: LD_INT 5
95544: PUSH
95545: LD_INT 7
95547: PUSH
95548: LD_INT 11
95550: PUSH
95551: LD_INT 12
95553: PUSH
95554: LD_INT 15
95556: PUSH
95557: LD_INT 16
95559: PUSH
95560: LD_INT 20
95562: PUSH
95563: LD_INT 21
95565: PUSH
95566: LD_INT 22
95568: PUSH
95569: LD_INT 23
95571: PUSH
95572: LD_INT 25
95574: PUSH
95575: LD_INT 26
95577: PUSH
95578: LD_INT 30
95580: PUSH
95581: LD_INT 31
95583: PUSH
95584: LD_INT 32
95586: PUSH
95587: LD_INT 33
95589: PUSH
95590: LD_INT 34
95592: PUSH
95593: EMPTY
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 101
95616: PUSH
95617: LD_INT 102
95619: PUSH
95620: LD_INT 103
95622: PUSH
95623: LD_INT 106
95625: PUSH
95626: LD_INT 108
95628: PUSH
95629: LD_INT 112
95631: PUSH
95632: LD_INT 113
95634: PUSH
95635: LD_INT 114
95637: PUSH
95638: LD_INT 116
95640: PUSH
95641: LD_INT 117
95643: PUSH
95644: LD_INT 118
95646: PUSH
95647: EMPTY
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: ST_TO_ADDR
95664: GO 96295
95666: LD_INT 17
95668: DOUBLE
95669: EQUAL
95670: IFTRUE 95674
95672: GO 95898
95674: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95675: LD_ADDR_VAR 0 2
95679: PUSH
95680: LD_INT 1
95682: PUSH
95683: LD_INT 2
95685: PUSH
95686: LD_INT 3
95688: PUSH
95689: LD_INT 4
95691: PUSH
95692: LD_INT 5
95694: PUSH
95695: LD_INT 6
95697: PUSH
95698: LD_INT 7
95700: PUSH
95701: LD_INT 8
95703: PUSH
95704: LD_INT 9
95706: PUSH
95707: LD_INT 10
95709: PUSH
95710: LD_INT 11
95712: PUSH
95713: LD_INT 12
95715: PUSH
95716: LD_INT 13
95718: PUSH
95719: LD_INT 14
95721: PUSH
95722: LD_INT 15
95724: PUSH
95725: LD_INT 16
95727: PUSH
95728: LD_INT 17
95730: PUSH
95731: LD_INT 18
95733: PUSH
95734: LD_INT 19
95736: PUSH
95737: LD_INT 20
95739: PUSH
95740: LD_INT 21
95742: PUSH
95743: LD_INT 22
95745: PUSH
95746: LD_INT 23
95748: PUSH
95749: LD_INT 24
95751: PUSH
95752: LD_INT 25
95754: PUSH
95755: LD_INT 26
95757: PUSH
95758: LD_INT 27
95760: PUSH
95761: LD_INT 28
95763: PUSH
95764: LD_INT 29
95766: PUSH
95767: LD_INT 30
95769: PUSH
95770: LD_INT 31
95772: PUSH
95773: LD_INT 32
95775: PUSH
95776: LD_INT 33
95778: PUSH
95779: LD_INT 34
95781: PUSH
95782: LD_INT 36
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 101
95824: PUSH
95825: LD_INT 102
95827: PUSH
95828: LD_INT 103
95830: PUSH
95831: LD_INT 104
95833: PUSH
95834: LD_INT 105
95836: PUSH
95837: LD_INT 106
95839: PUSH
95840: LD_INT 107
95842: PUSH
95843: LD_INT 108
95845: PUSH
95846: LD_INT 109
95848: PUSH
95849: LD_INT 110
95851: PUSH
95852: LD_INT 111
95854: PUSH
95855: LD_INT 112
95857: PUSH
95858: LD_INT 113
95860: PUSH
95861: LD_INT 114
95863: PUSH
95864: LD_INT 116
95866: PUSH
95867: LD_INT 117
95869: PUSH
95870: LD_INT 118
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: ST_TO_ADDR
95896: GO 96295
95898: LD_INT 18
95900: DOUBLE
95901: EQUAL
95902: IFTRUE 95906
95904: GO 96054
95906: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95907: LD_ADDR_VAR 0 2
95911: PUSH
95912: LD_INT 2
95914: PUSH
95915: LD_INT 4
95917: PUSH
95918: LD_INT 5
95920: PUSH
95921: LD_INT 7
95923: PUSH
95924: LD_INT 11
95926: PUSH
95927: LD_INT 12
95929: PUSH
95930: LD_INT 15
95932: PUSH
95933: LD_INT 16
95935: PUSH
95936: LD_INT 20
95938: PUSH
95939: LD_INT 21
95941: PUSH
95942: LD_INT 22
95944: PUSH
95945: LD_INT 23
95947: PUSH
95948: LD_INT 25
95950: PUSH
95951: LD_INT 26
95953: PUSH
95954: LD_INT 30
95956: PUSH
95957: LD_INT 31
95959: PUSH
95960: LD_INT 32
95962: PUSH
95963: LD_INT 33
95965: PUSH
95966: LD_INT 34
95968: PUSH
95969: LD_INT 35
95971: PUSH
95972: LD_INT 36
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: LIST
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 101
96000: PUSH
96001: LD_INT 102
96003: PUSH
96004: LD_INT 103
96006: PUSH
96007: LD_INT 106
96009: PUSH
96010: LD_INT 108
96012: PUSH
96013: LD_INT 112
96015: PUSH
96016: LD_INT 113
96018: PUSH
96019: LD_INT 114
96021: PUSH
96022: LD_INT 115
96024: PUSH
96025: LD_INT 116
96027: PUSH
96028: LD_INT 117
96030: PUSH
96031: LD_INT 118
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: ST_TO_ADDR
96052: GO 96295
96054: LD_INT 19
96056: DOUBLE
96057: EQUAL
96058: IFTRUE 96062
96060: GO 96294
96062: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96063: LD_ADDR_VAR 0 2
96067: PUSH
96068: LD_INT 1
96070: PUSH
96071: LD_INT 2
96073: PUSH
96074: LD_INT 3
96076: PUSH
96077: LD_INT 4
96079: PUSH
96080: LD_INT 5
96082: PUSH
96083: LD_INT 6
96085: PUSH
96086: LD_INT 7
96088: PUSH
96089: LD_INT 8
96091: PUSH
96092: LD_INT 9
96094: PUSH
96095: LD_INT 10
96097: PUSH
96098: LD_INT 11
96100: PUSH
96101: LD_INT 12
96103: PUSH
96104: LD_INT 13
96106: PUSH
96107: LD_INT 14
96109: PUSH
96110: LD_INT 15
96112: PUSH
96113: LD_INT 16
96115: PUSH
96116: LD_INT 17
96118: PUSH
96119: LD_INT 18
96121: PUSH
96122: LD_INT 19
96124: PUSH
96125: LD_INT 20
96127: PUSH
96128: LD_INT 21
96130: PUSH
96131: LD_INT 22
96133: PUSH
96134: LD_INT 23
96136: PUSH
96137: LD_INT 24
96139: PUSH
96140: LD_INT 25
96142: PUSH
96143: LD_INT 26
96145: PUSH
96146: LD_INT 27
96148: PUSH
96149: LD_INT 28
96151: PUSH
96152: LD_INT 29
96154: PUSH
96155: LD_INT 30
96157: PUSH
96158: LD_INT 31
96160: PUSH
96161: LD_INT 32
96163: PUSH
96164: LD_INT 33
96166: PUSH
96167: LD_INT 34
96169: PUSH
96170: LD_INT 35
96172: PUSH
96173: LD_INT 36
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: PUSH
96214: LD_INT 101
96216: PUSH
96217: LD_INT 102
96219: PUSH
96220: LD_INT 103
96222: PUSH
96223: LD_INT 104
96225: PUSH
96226: LD_INT 105
96228: PUSH
96229: LD_INT 106
96231: PUSH
96232: LD_INT 107
96234: PUSH
96235: LD_INT 108
96237: PUSH
96238: LD_INT 109
96240: PUSH
96241: LD_INT 110
96243: PUSH
96244: LD_INT 111
96246: PUSH
96247: LD_INT 112
96249: PUSH
96250: LD_INT 113
96252: PUSH
96253: LD_INT 114
96255: PUSH
96256: LD_INT 115
96258: PUSH
96259: LD_INT 116
96261: PUSH
96262: LD_INT 117
96264: PUSH
96265: LD_INT 118
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: ST_TO_ADDR
96292: GO 96295
96294: POP
// end else
96295: GO 96526
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96297: LD_ADDR_VAR 0 2
96301: PUSH
96302: LD_INT 1
96304: PUSH
96305: LD_INT 2
96307: PUSH
96308: LD_INT 3
96310: PUSH
96311: LD_INT 4
96313: PUSH
96314: LD_INT 5
96316: PUSH
96317: LD_INT 6
96319: PUSH
96320: LD_INT 7
96322: PUSH
96323: LD_INT 8
96325: PUSH
96326: LD_INT 9
96328: PUSH
96329: LD_INT 10
96331: PUSH
96332: LD_INT 11
96334: PUSH
96335: LD_INT 12
96337: PUSH
96338: LD_INT 13
96340: PUSH
96341: LD_INT 14
96343: PUSH
96344: LD_INT 15
96346: PUSH
96347: LD_INT 16
96349: PUSH
96350: LD_INT 17
96352: PUSH
96353: LD_INT 18
96355: PUSH
96356: LD_INT 19
96358: PUSH
96359: LD_INT 20
96361: PUSH
96362: LD_INT 21
96364: PUSH
96365: LD_INT 22
96367: PUSH
96368: LD_INT 23
96370: PUSH
96371: LD_INT 24
96373: PUSH
96374: LD_INT 25
96376: PUSH
96377: LD_INT 26
96379: PUSH
96380: LD_INT 27
96382: PUSH
96383: LD_INT 28
96385: PUSH
96386: LD_INT 29
96388: PUSH
96389: LD_INT 30
96391: PUSH
96392: LD_INT 31
96394: PUSH
96395: LD_INT 32
96397: PUSH
96398: LD_INT 33
96400: PUSH
96401: LD_INT 34
96403: PUSH
96404: LD_INT 35
96406: PUSH
96407: LD_INT 36
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 101
96450: PUSH
96451: LD_INT 102
96453: PUSH
96454: LD_INT 103
96456: PUSH
96457: LD_INT 104
96459: PUSH
96460: LD_INT 105
96462: PUSH
96463: LD_INT 106
96465: PUSH
96466: LD_INT 107
96468: PUSH
96469: LD_INT 108
96471: PUSH
96472: LD_INT 109
96474: PUSH
96475: LD_INT 110
96477: PUSH
96478: LD_INT 111
96480: PUSH
96481: LD_INT 112
96483: PUSH
96484: LD_INT 113
96486: PUSH
96487: LD_INT 114
96489: PUSH
96490: LD_INT 115
96492: PUSH
96493: LD_INT 116
96495: PUSH
96496: LD_INT 117
96498: PUSH
96499: LD_INT 118
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: ST_TO_ADDR
// if result then
96526: LD_VAR 0 2
96530: IFFALSE 97316
// begin normal :=  ;
96532: LD_ADDR_VAR 0 5
96536: PUSH
96537: LD_STRING 
96539: ST_TO_ADDR
// hardcore :=  ;
96540: LD_ADDR_VAR 0 6
96544: PUSH
96545: LD_STRING 
96547: ST_TO_ADDR
// active :=  ;
96548: LD_ADDR_VAR 0 7
96552: PUSH
96553: LD_STRING 
96555: ST_TO_ADDR
// for i = 1 to normalCounter do
96556: LD_ADDR_VAR 0 8
96560: PUSH
96561: DOUBLE
96562: LD_INT 1
96564: DEC
96565: ST_TO_ADDR
96566: LD_EXP 97
96570: PUSH
96571: FOR_TO
96572: IFFALSE 96673
// begin tmp := 0 ;
96574: LD_ADDR_VAR 0 3
96578: PUSH
96579: LD_STRING 0
96581: ST_TO_ADDR
// if result [ 1 ] then
96582: LD_VAR 0 2
96586: PUSH
96587: LD_INT 1
96589: ARRAY
96590: IFFALSE 96655
// if result [ 1 ] [ 1 ] = i then
96592: LD_VAR 0 2
96596: PUSH
96597: LD_INT 1
96599: ARRAY
96600: PUSH
96601: LD_INT 1
96603: ARRAY
96604: PUSH
96605: LD_VAR 0 8
96609: EQUAL
96610: IFFALSE 96655
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96612: LD_ADDR_VAR 0 2
96616: PUSH
96617: LD_VAR 0 2
96621: PPUSH
96622: LD_INT 1
96624: PPUSH
96625: LD_VAR 0 2
96629: PUSH
96630: LD_INT 1
96632: ARRAY
96633: PPUSH
96634: LD_INT 1
96636: PPUSH
96637: CALL_OW 3
96641: PPUSH
96642: CALL_OW 1
96646: ST_TO_ADDR
// tmp := 1 ;
96647: LD_ADDR_VAR 0 3
96651: PUSH
96652: LD_STRING 1
96654: ST_TO_ADDR
// end ; normal := normal & tmp ;
96655: LD_ADDR_VAR 0 5
96659: PUSH
96660: LD_VAR 0 5
96664: PUSH
96665: LD_VAR 0 3
96669: STR
96670: ST_TO_ADDR
// end ;
96671: GO 96571
96673: POP
96674: POP
// for i = 1 to hardcoreCounter do
96675: LD_ADDR_VAR 0 8
96679: PUSH
96680: DOUBLE
96681: LD_INT 1
96683: DEC
96684: ST_TO_ADDR
96685: LD_EXP 98
96689: PUSH
96690: FOR_TO
96691: IFFALSE 96796
// begin tmp := 0 ;
96693: LD_ADDR_VAR 0 3
96697: PUSH
96698: LD_STRING 0
96700: ST_TO_ADDR
// if result [ 2 ] then
96701: LD_VAR 0 2
96705: PUSH
96706: LD_INT 2
96708: ARRAY
96709: IFFALSE 96778
// if result [ 2 ] [ 1 ] = 100 + i then
96711: LD_VAR 0 2
96715: PUSH
96716: LD_INT 2
96718: ARRAY
96719: PUSH
96720: LD_INT 1
96722: ARRAY
96723: PUSH
96724: LD_INT 100
96726: PUSH
96727: LD_VAR 0 8
96731: PLUS
96732: EQUAL
96733: IFFALSE 96778
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96735: LD_ADDR_VAR 0 2
96739: PUSH
96740: LD_VAR 0 2
96744: PPUSH
96745: LD_INT 2
96747: PPUSH
96748: LD_VAR 0 2
96752: PUSH
96753: LD_INT 2
96755: ARRAY
96756: PPUSH
96757: LD_INT 1
96759: PPUSH
96760: CALL_OW 3
96764: PPUSH
96765: CALL_OW 1
96769: ST_TO_ADDR
// tmp := 1 ;
96770: LD_ADDR_VAR 0 3
96774: PUSH
96775: LD_STRING 1
96777: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96778: LD_ADDR_VAR 0 6
96782: PUSH
96783: LD_VAR 0 6
96787: PUSH
96788: LD_VAR 0 3
96792: STR
96793: ST_TO_ADDR
// end ;
96794: GO 96690
96796: POP
96797: POP
// if isGameLoad then
96798: LD_VAR 0 1
96802: IFFALSE 97277
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96804: LD_ADDR_VAR 0 4
96808: PUSH
96809: LD_EXP 101
96813: PUSH
96814: LD_EXP 100
96818: PUSH
96819: LD_EXP 102
96823: PUSH
96824: LD_EXP 99
96828: PUSH
96829: LD_EXP 103
96833: PUSH
96834: LD_EXP 104
96838: PUSH
96839: LD_EXP 105
96843: PUSH
96844: LD_EXP 106
96848: PUSH
96849: LD_EXP 107
96853: PUSH
96854: LD_EXP 108
96858: PUSH
96859: LD_EXP 109
96863: PUSH
96864: LD_EXP 110
96868: PUSH
96869: LD_EXP 111
96873: PUSH
96874: LD_EXP 112
96878: PUSH
96879: LD_EXP 120
96883: PUSH
96884: LD_EXP 121
96888: PUSH
96889: LD_EXP 122
96893: PUSH
96894: LD_EXP 123
96898: PUSH
96899: LD_EXP 125
96903: PUSH
96904: LD_EXP 126
96908: PUSH
96909: LD_EXP 127
96913: PUSH
96914: LD_EXP 130
96918: PUSH
96919: LD_EXP 132
96923: PUSH
96924: LD_EXP 133
96928: PUSH
96929: LD_EXP 134
96933: PUSH
96934: LD_EXP 136
96938: PUSH
96939: LD_EXP 137
96943: PUSH
96944: LD_EXP 140
96948: PUSH
96949: LD_EXP 141
96953: PUSH
96954: LD_EXP 142
96958: PUSH
96959: LD_EXP 143
96963: PUSH
96964: LD_EXP 144
96968: PUSH
96969: LD_EXP 145
96973: PUSH
96974: LD_EXP 146
96978: PUSH
96979: LD_EXP 147
96983: PUSH
96984: LD_EXP 148
96988: PUSH
96989: LD_EXP 113
96993: PUSH
96994: LD_EXP 114
96998: PUSH
96999: LD_EXP 117
97003: PUSH
97004: LD_EXP 118
97008: PUSH
97009: LD_EXP 119
97013: PUSH
97014: LD_EXP 115
97018: PUSH
97019: LD_EXP 116
97023: PUSH
97024: LD_EXP 124
97028: PUSH
97029: LD_EXP 128
97033: PUSH
97034: LD_EXP 129
97038: PUSH
97039: LD_EXP 131
97043: PUSH
97044: LD_EXP 135
97048: PUSH
97049: LD_EXP 138
97053: PUSH
97054: LD_EXP 139
97058: PUSH
97059: LD_EXP 149
97063: PUSH
97064: LD_EXP 150
97068: PUSH
97069: LD_EXP 151
97073: PUSH
97074: LD_EXP 152
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: ST_TO_ADDR
// tmp :=  ;
97135: LD_ADDR_VAR 0 3
97139: PUSH
97140: LD_STRING 
97142: ST_TO_ADDR
// for i = 1 to normalCounter do
97143: LD_ADDR_VAR 0 8
97147: PUSH
97148: DOUBLE
97149: LD_INT 1
97151: DEC
97152: ST_TO_ADDR
97153: LD_EXP 97
97157: PUSH
97158: FOR_TO
97159: IFFALSE 97195
// begin if flags [ i ] then
97161: LD_VAR 0 4
97165: PUSH
97166: LD_VAR 0 8
97170: ARRAY
97171: IFFALSE 97193
// tmp := tmp & i & ; ;
97173: LD_ADDR_VAR 0 3
97177: PUSH
97178: LD_VAR 0 3
97182: PUSH
97183: LD_VAR 0 8
97187: STR
97188: PUSH
97189: LD_STRING ;
97191: STR
97192: ST_TO_ADDR
// end ;
97193: GO 97158
97195: POP
97196: POP
// for i = 1 to hardcoreCounter do
97197: LD_ADDR_VAR 0 8
97201: PUSH
97202: DOUBLE
97203: LD_INT 1
97205: DEC
97206: ST_TO_ADDR
97207: LD_EXP 98
97211: PUSH
97212: FOR_TO
97213: IFFALSE 97259
// begin if flags [ normalCounter + i ] then
97215: LD_VAR 0 4
97219: PUSH
97220: LD_EXP 97
97224: PUSH
97225: LD_VAR 0 8
97229: PLUS
97230: ARRAY
97231: IFFALSE 97257
// tmp := tmp & ( 100 + i ) & ; ;
97233: LD_ADDR_VAR 0 3
97237: PUSH
97238: LD_VAR 0 3
97242: PUSH
97243: LD_INT 100
97245: PUSH
97246: LD_VAR 0 8
97250: PLUS
97251: STR
97252: PUSH
97253: LD_STRING ;
97255: STR
97256: ST_TO_ADDR
// end ;
97257: GO 97212
97259: POP
97260: POP
// if tmp then
97261: LD_VAR 0 3
97265: IFFALSE 97277
// active := tmp ;
97267: LD_ADDR_VAR 0 7
97271: PUSH
97272: LD_VAR 0 3
97276: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97277: LD_STRING getStreamItemsFromMission("
97279: PUSH
97280: LD_VAR 0 5
97284: STR
97285: PUSH
97286: LD_STRING ","
97288: STR
97289: PUSH
97290: LD_VAR 0 6
97294: STR
97295: PUSH
97296: LD_STRING ","
97298: STR
97299: PUSH
97300: LD_VAR 0 7
97304: STR
97305: PUSH
97306: LD_STRING ")
97308: STR
97309: PPUSH
97310: CALL_OW 559
// end else
97314: GO 97323
// ToLua ( getStreamItemsFromMission("","","") ) ;
97316: LD_STRING getStreamItemsFromMission("","","")
97318: PPUSH
97319: CALL_OW 559
// end ;
97323: LD_VAR 0 2
97327: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97328: LD_EXP 96
97332: PUSH
97333: LD_EXP 101
97337: AND
97338: IFFALSE 97462
97340: GO 97342
97342: DISABLE
97343: LD_INT 0
97345: PPUSH
97346: PPUSH
// begin enable ;
97347: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97348: LD_ADDR_VAR 0 2
97352: PUSH
97353: LD_INT 22
97355: PUSH
97356: LD_OWVAR 2
97360: PUSH
97361: EMPTY
97362: LIST
97363: LIST
97364: PUSH
97365: LD_INT 2
97367: PUSH
97368: LD_INT 34
97370: PUSH
97371: LD_INT 7
97373: PUSH
97374: EMPTY
97375: LIST
97376: LIST
97377: PUSH
97378: LD_INT 34
97380: PUSH
97381: LD_INT 45
97383: PUSH
97384: EMPTY
97385: LIST
97386: LIST
97387: PUSH
97388: LD_INT 34
97390: PUSH
97391: LD_INT 28
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: PUSH
97398: LD_INT 34
97400: PUSH
97401: LD_INT 47
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: PPUSH
97419: CALL_OW 69
97423: ST_TO_ADDR
// if not tmp then
97424: LD_VAR 0 2
97428: NOT
97429: IFFALSE 97433
// exit ;
97431: GO 97462
// for i in tmp do
97433: LD_ADDR_VAR 0 1
97437: PUSH
97438: LD_VAR 0 2
97442: PUSH
97443: FOR_IN
97444: IFFALSE 97460
// begin SetLives ( i , 0 ) ;
97446: LD_VAR 0 1
97450: PPUSH
97451: LD_INT 0
97453: PPUSH
97454: CALL_OW 234
// end ;
97458: GO 97443
97460: POP
97461: POP
// end ;
97462: PPOPN 2
97464: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97465: LD_EXP 96
97469: PUSH
97470: LD_EXP 102
97474: AND
97475: IFFALSE 97559
97477: GO 97479
97479: DISABLE
97480: LD_INT 0
97482: PPUSH
97483: PPUSH
// begin enable ;
97484: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97485: LD_ADDR_VAR 0 2
97489: PUSH
97490: LD_INT 22
97492: PUSH
97493: LD_OWVAR 2
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: LD_INT 32
97504: PUSH
97505: LD_INT 3
97507: PUSH
97508: EMPTY
97509: LIST
97510: LIST
97511: PUSH
97512: EMPTY
97513: LIST
97514: LIST
97515: PPUSH
97516: CALL_OW 69
97520: ST_TO_ADDR
// if not tmp then
97521: LD_VAR 0 2
97525: NOT
97526: IFFALSE 97530
// exit ;
97528: GO 97559
// for i in tmp do
97530: LD_ADDR_VAR 0 1
97534: PUSH
97535: LD_VAR 0 2
97539: PUSH
97540: FOR_IN
97541: IFFALSE 97557
// begin SetLives ( i , 0 ) ;
97543: LD_VAR 0 1
97547: PPUSH
97548: LD_INT 0
97550: PPUSH
97551: CALL_OW 234
// end ;
97555: GO 97540
97557: POP
97558: POP
// end ;
97559: PPOPN 2
97561: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97562: LD_EXP 96
97566: PUSH
97567: LD_EXP 99
97571: AND
97572: IFFALSE 97665
97574: GO 97576
97576: DISABLE
97577: LD_INT 0
97579: PPUSH
// begin enable ;
97580: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97581: LD_ADDR_VAR 0 1
97585: PUSH
97586: LD_INT 22
97588: PUSH
97589: LD_OWVAR 2
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: PUSH
97598: LD_INT 2
97600: PUSH
97601: LD_INT 25
97603: PUSH
97604: LD_INT 5
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: LD_INT 25
97613: PUSH
97614: LD_INT 9
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: PUSH
97621: LD_INT 25
97623: PUSH
97624: LD_INT 8
97626: PUSH
97627: EMPTY
97628: LIST
97629: LIST
97630: PUSH
97631: EMPTY
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PPUSH
97641: CALL_OW 69
97645: PUSH
97646: FOR_IN
97647: IFFALSE 97663
// begin SetClass ( i , 1 ) ;
97649: LD_VAR 0 1
97653: PPUSH
97654: LD_INT 1
97656: PPUSH
97657: CALL_OW 336
// end ;
97661: GO 97646
97663: POP
97664: POP
// end ;
97665: PPOPN 1
97667: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97668: LD_EXP 96
97672: PUSH
97673: LD_EXP 100
97677: AND
97678: PUSH
97679: LD_OWVAR 65
97683: PUSH
97684: LD_INT 7
97686: LESS
97687: AND
97688: IFFALSE 97702
97690: GO 97692
97692: DISABLE
// begin enable ;
97693: ENABLE
// game_speed := 7 ;
97694: LD_ADDR_OWVAR 65
97698: PUSH
97699: LD_INT 7
97701: ST_TO_ADDR
// end ;
97702: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97703: LD_EXP 96
97707: PUSH
97708: LD_EXP 103
97712: AND
97713: IFFALSE 97915
97715: GO 97717
97717: DISABLE
97718: LD_INT 0
97720: PPUSH
97721: PPUSH
97722: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97723: LD_ADDR_VAR 0 3
97727: PUSH
97728: LD_INT 81
97730: PUSH
97731: LD_OWVAR 2
97735: PUSH
97736: EMPTY
97737: LIST
97738: LIST
97739: PUSH
97740: LD_INT 21
97742: PUSH
97743: LD_INT 1
97745: PUSH
97746: EMPTY
97747: LIST
97748: LIST
97749: PUSH
97750: EMPTY
97751: LIST
97752: LIST
97753: PPUSH
97754: CALL_OW 69
97758: ST_TO_ADDR
// if not tmp then
97759: LD_VAR 0 3
97763: NOT
97764: IFFALSE 97768
// exit ;
97766: GO 97915
// if tmp > 5 then
97768: LD_VAR 0 3
97772: PUSH
97773: LD_INT 5
97775: GREATER
97776: IFFALSE 97788
// k := 5 else
97778: LD_ADDR_VAR 0 2
97782: PUSH
97783: LD_INT 5
97785: ST_TO_ADDR
97786: GO 97798
// k := tmp ;
97788: LD_ADDR_VAR 0 2
97792: PUSH
97793: LD_VAR 0 3
97797: ST_TO_ADDR
// for i := 1 to k do
97798: LD_ADDR_VAR 0 1
97802: PUSH
97803: DOUBLE
97804: LD_INT 1
97806: DEC
97807: ST_TO_ADDR
97808: LD_VAR 0 2
97812: PUSH
97813: FOR_TO
97814: IFFALSE 97913
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97816: LD_VAR 0 3
97820: PUSH
97821: LD_VAR 0 1
97825: ARRAY
97826: PPUSH
97827: LD_VAR 0 1
97831: PUSH
97832: LD_INT 4
97834: MOD
97835: PUSH
97836: LD_INT 1
97838: PLUS
97839: PPUSH
97840: CALL_OW 259
97844: PUSH
97845: LD_INT 10
97847: LESS
97848: IFFALSE 97911
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97850: LD_VAR 0 3
97854: PUSH
97855: LD_VAR 0 1
97859: ARRAY
97860: PPUSH
97861: LD_VAR 0 1
97865: PUSH
97866: LD_INT 4
97868: MOD
97869: PUSH
97870: LD_INT 1
97872: PLUS
97873: PPUSH
97874: LD_VAR 0 3
97878: PUSH
97879: LD_VAR 0 1
97883: ARRAY
97884: PPUSH
97885: LD_VAR 0 1
97889: PUSH
97890: LD_INT 4
97892: MOD
97893: PUSH
97894: LD_INT 1
97896: PLUS
97897: PPUSH
97898: CALL_OW 259
97902: PUSH
97903: LD_INT 1
97905: PLUS
97906: PPUSH
97907: CALL_OW 237
97911: GO 97813
97913: POP
97914: POP
// end ;
97915: PPOPN 3
97917: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97918: LD_EXP 96
97922: PUSH
97923: LD_EXP 104
97927: AND
97928: IFFALSE 97948
97930: GO 97932
97932: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97933: LD_INT 4
97935: PPUSH
97936: LD_OWVAR 2
97940: PPUSH
97941: LD_INT 0
97943: PPUSH
97944: CALL_OW 324
97948: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97949: LD_EXP 96
97953: PUSH
97954: LD_EXP 133
97958: AND
97959: IFFALSE 97979
97961: GO 97963
97963: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97964: LD_INT 19
97966: PPUSH
97967: LD_OWVAR 2
97971: PPUSH
97972: LD_INT 0
97974: PPUSH
97975: CALL_OW 324
97979: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97980: LD_EXP 96
97984: PUSH
97985: LD_EXP 105
97989: AND
97990: IFFALSE 98092
97992: GO 97994
97994: DISABLE
97995: LD_INT 0
97997: PPUSH
97998: PPUSH
// begin enable ;
97999: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98000: LD_ADDR_VAR 0 2
98004: PUSH
98005: LD_INT 22
98007: PUSH
98008: LD_OWVAR 2
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PUSH
98017: LD_INT 2
98019: PUSH
98020: LD_INT 34
98022: PUSH
98023: LD_INT 11
98025: PUSH
98026: EMPTY
98027: LIST
98028: LIST
98029: PUSH
98030: LD_INT 34
98032: PUSH
98033: LD_INT 30
98035: PUSH
98036: EMPTY
98037: LIST
98038: LIST
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: LIST
98044: PUSH
98045: EMPTY
98046: LIST
98047: LIST
98048: PPUSH
98049: CALL_OW 69
98053: ST_TO_ADDR
// if not tmp then
98054: LD_VAR 0 2
98058: NOT
98059: IFFALSE 98063
// exit ;
98061: GO 98092
// for i in tmp do
98063: LD_ADDR_VAR 0 1
98067: PUSH
98068: LD_VAR 0 2
98072: PUSH
98073: FOR_IN
98074: IFFALSE 98090
// begin SetLives ( i , 0 ) ;
98076: LD_VAR 0 1
98080: PPUSH
98081: LD_INT 0
98083: PPUSH
98084: CALL_OW 234
// end ;
98088: GO 98073
98090: POP
98091: POP
// end ;
98092: PPOPN 2
98094: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98095: LD_EXP 96
98099: PUSH
98100: LD_EXP 106
98104: AND
98105: IFFALSE 98125
98107: GO 98109
98109: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98110: LD_INT 32
98112: PPUSH
98113: LD_OWVAR 2
98117: PPUSH
98118: LD_INT 0
98120: PPUSH
98121: CALL_OW 324
98125: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98126: LD_EXP 96
98130: PUSH
98131: LD_EXP 107
98135: AND
98136: IFFALSE 98317
98138: GO 98140
98140: DISABLE
98141: LD_INT 0
98143: PPUSH
98144: PPUSH
98145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98146: LD_ADDR_VAR 0 2
98150: PUSH
98151: LD_INT 22
98153: PUSH
98154: LD_OWVAR 2
98158: PUSH
98159: EMPTY
98160: LIST
98161: LIST
98162: PUSH
98163: LD_INT 33
98165: PUSH
98166: LD_INT 3
98168: PUSH
98169: EMPTY
98170: LIST
98171: LIST
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: PPUSH
98177: CALL_OW 69
98181: ST_TO_ADDR
// if not tmp then
98182: LD_VAR 0 2
98186: NOT
98187: IFFALSE 98191
// exit ;
98189: GO 98317
// side := 0 ;
98191: LD_ADDR_VAR 0 3
98195: PUSH
98196: LD_INT 0
98198: ST_TO_ADDR
// for i := 1 to 8 do
98199: LD_ADDR_VAR 0 1
98203: PUSH
98204: DOUBLE
98205: LD_INT 1
98207: DEC
98208: ST_TO_ADDR
98209: LD_INT 8
98211: PUSH
98212: FOR_TO
98213: IFFALSE 98261
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98215: LD_OWVAR 2
98219: PUSH
98220: LD_VAR 0 1
98224: NONEQUAL
98225: PUSH
98226: LD_OWVAR 2
98230: PPUSH
98231: LD_VAR 0 1
98235: PPUSH
98236: CALL_OW 81
98240: PUSH
98241: LD_INT 2
98243: EQUAL
98244: AND
98245: IFFALSE 98259
// begin side := i ;
98247: LD_ADDR_VAR 0 3
98251: PUSH
98252: LD_VAR 0 1
98256: ST_TO_ADDR
// break ;
98257: GO 98261
// end ;
98259: GO 98212
98261: POP
98262: POP
// if not side then
98263: LD_VAR 0 3
98267: NOT
98268: IFFALSE 98272
// exit ;
98270: GO 98317
// for i := 1 to tmp do
98272: LD_ADDR_VAR 0 1
98276: PUSH
98277: DOUBLE
98278: LD_INT 1
98280: DEC
98281: ST_TO_ADDR
98282: LD_VAR 0 2
98286: PUSH
98287: FOR_TO
98288: IFFALSE 98315
// if Prob ( 60 ) then
98290: LD_INT 60
98292: PPUSH
98293: CALL_OW 13
98297: IFFALSE 98313
// SetSide ( i , side ) ;
98299: LD_VAR 0 1
98303: PPUSH
98304: LD_VAR 0 3
98308: PPUSH
98309: CALL_OW 235
98313: GO 98287
98315: POP
98316: POP
// end ;
98317: PPOPN 3
98319: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98320: LD_EXP 96
98324: PUSH
98325: LD_EXP 109
98329: AND
98330: IFFALSE 98449
98332: GO 98334
98334: DISABLE
98335: LD_INT 0
98337: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98338: LD_ADDR_VAR 0 1
98342: PUSH
98343: LD_INT 22
98345: PUSH
98346: LD_OWVAR 2
98350: PUSH
98351: EMPTY
98352: LIST
98353: LIST
98354: PUSH
98355: LD_INT 21
98357: PUSH
98358: LD_INT 1
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PUSH
98365: LD_INT 3
98367: PUSH
98368: LD_INT 23
98370: PUSH
98371: LD_INT 0
98373: PUSH
98374: EMPTY
98375: LIST
98376: LIST
98377: PUSH
98378: EMPTY
98379: LIST
98380: LIST
98381: PUSH
98382: EMPTY
98383: LIST
98384: LIST
98385: LIST
98386: PPUSH
98387: CALL_OW 69
98391: PUSH
98392: FOR_IN
98393: IFFALSE 98447
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98395: LD_VAR 0 1
98399: PPUSH
98400: CALL_OW 257
98404: PUSH
98405: LD_INT 1
98407: PUSH
98408: LD_INT 2
98410: PUSH
98411: LD_INT 3
98413: PUSH
98414: LD_INT 4
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: IN
98423: IFFALSE 98445
// SetClass ( un , rand ( 1 , 4 ) ) ;
98425: LD_VAR 0 1
98429: PPUSH
98430: LD_INT 1
98432: PPUSH
98433: LD_INT 4
98435: PPUSH
98436: CALL_OW 12
98440: PPUSH
98441: CALL_OW 336
98445: GO 98392
98447: POP
98448: POP
// end ;
98449: PPOPN 1
98451: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98452: LD_EXP 96
98456: PUSH
98457: LD_EXP 108
98461: AND
98462: IFFALSE 98541
98464: GO 98466
98466: DISABLE
98467: LD_INT 0
98469: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98470: LD_ADDR_VAR 0 1
98474: PUSH
98475: LD_INT 22
98477: PUSH
98478: LD_OWVAR 2
98482: PUSH
98483: EMPTY
98484: LIST
98485: LIST
98486: PUSH
98487: LD_INT 21
98489: PUSH
98490: LD_INT 3
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: PPUSH
98501: CALL_OW 69
98505: ST_TO_ADDR
// if not tmp then
98506: LD_VAR 0 1
98510: NOT
98511: IFFALSE 98515
// exit ;
98513: GO 98541
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98515: LD_VAR 0 1
98519: PUSH
98520: LD_INT 1
98522: PPUSH
98523: LD_VAR 0 1
98527: PPUSH
98528: CALL_OW 12
98532: ARRAY
98533: PPUSH
98534: LD_INT 100
98536: PPUSH
98537: CALL_OW 234
// end ;
98541: PPOPN 1
98543: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98544: LD_EXP 96
98548: PUSH
98549: LD_EXP 110
98553: AND
98554: IFFALSE 98652
98556: GO 98558
98558: DISABLE
98559: LD_INT 0
98561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98562: LD_ADDR_VAR 0 1
98566: PUSH
98567: LD_INT 22
98569: PUSH
98570: LD_OWVAR 2
98574: PUSH
98575: EMPTY
98576: LIST
98577: LIST
98578: PUSH
98579: LD_INT 21
98581: PUSH
98582: LD_INT 1
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PUSH
98589: EMPTY
98590: LIST
98591: LIST
98592: PPUSH
98593: CALL_OW 69
98597: ST_TO_ADDR
// if not tmp then
98598: LD_VAR 0 1
98602: NOT
98603: IFFALSE 98607
// exit ;
98605: GO 98652
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98607: LD_VAR 0 1
98611: PUSH
98612: LD_INT 1
98614: PPUSH
98615: LD_VAR 0 1
98619: PPUSH
98620: CALL_OW 12
98624: ARRAY
98625: PPUSH
98626: LD_INT 1
98628: PPUSH
98629: LD_INT 4
98631: PPUSH
98632: CALL_OW 12
98636: PPUSH
98637: LD_INT 3000
98639: PPUSH
98640: LD_INT 9000
98642: PPUSH
98643: CALL_OW 12
98647: PPUSH
98648: CALL_OW 492
// end ;
98652: PPOPN 1
98654: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98655: LD_EXP 96
98659: PUSH
98660: LD_EXP 111
98664: AND
98665: IFFALSE 98685
98667: GO 98669
98669: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98670: LD_INT 1
98672: PPUSH
98673: LD_OWVAR 2
98677: PPUSH
98678: LD_INT 0
98680: PPUSH
98681: CALL_OW 324
98685: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98686: LD_EXP 96
98690: PUSH
98691: LD_EXP 112
98695: AND
98696: IFFALSE 98779
98698: GO 98700
98700: DISABLE
98701: LD_INT 0
98703: PPUSH
98704: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98705: LD_ADDR_VAR 0 2
98709: PUSH
98710: LD_INT 22
98712: PUSH
98713: LD_OWVAR 2
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: PUSH
98722: LD_INT 21
98724: PUSH
98725: LD_INT 3
98727: PUSH
98728: EMPTY
98729: LIST
98730: LIST
98731: PUSH
98732: EMPTY
98733: LIST
98734: LIST
98735: PPUSH
98736: CALL_OW 69
98740: ST_TO_ADDR
// if not tmp then
98741: LD_VAR 0 2
98745: NOT
98746: IFFALSE 98750
// exit ;
98748: GO 98779
// for i in tmp do
98750: LD_ADDR_VAR 0 1
98754: PUSH
98755: LD_VAR 0 2
98759: PUSH
98760: FOR_IN
98761: IFFALSE 98777
// SetBLevel ( i , 10 ) ;
98763: LD_VAR 0 1
98767: PPUSH
98768: LD_INT 10
98770: PPUSH
98771: CALL_OW 241
98775: GO 98760
98777: POP
98778: POP
// end ;
98779: PPOPN 2
98781: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98782: LD_EXP 96
98786: PUSH
98787: LD_EXP 113
98791: AND
98792: IFFALSE 98903
98794: GO 98796
98796: DISABLE
98797: LD_INT 0
98799: PPUSH
98800: PPUSH
98801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98802: LD_ADDR_VAR 0 3
98806: PUSH
98807: LD_INT 22
98809: PUSH
98810: LD_OWVAR 2
98814: PUSH
98815: EMPTY
98816: LIST
98817: LIST
98818: PUSH
98819: LD_INT 25
98821: PUSH
98822: LD_INT 1
98824: PUSH
98825: EMPTY
98826: LIST
98827: LIST
98828: PUSH
98829: EMPTY
98830: LIST
98831: LIST
98832: PPUSH
98833: CALL_OW 69
98837: ST_TO_ADDR
// if not tmp then
98838: LD_VAR 0 3
98842: NOT
98843: IFFALSE 98847
// exit ;
98845: GO 98903
// un := tmp [ rand ( 1 , tmp ) ] ;
98847: LD_ADDR_VAR 0 2
98851: PUSH
98852: LD_VAR 0 3
98856: PUSH
98857: LD_INT 1
98859: PPUSH
98860: LD_VAR 0 3
98864: PPUSH
98865: CALL_OW 12
98869: ARRAY
98870: ST_TO_ADDR
// if Crawls ( un ) then
98871: LD_VAR 0 2
98875: PPUSH
98876: CALL_OW 318
98880: IFFALSE 98891
// ComWalk ( un ) ;
98882: LD_VAR 0 2
98886: PPUSH
98887: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98891: LD_VAR 0 2
98895: PPUSH
98896: LD_INT 5
98898: PPUSH
98899: CALL_OW 336
// end ;
98903: PPOPN 3
98905: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98906: LD_EXP 96
98910: PUSH
98911: LD_EXP 114
98915: AND
98916: PUSH
98917: LD_OWVAR 67
98921: PUSH
98922: LD_INT 4
98924: LESS
98925: AND
98926: IFFALSE 98945
98928: GO 98930
98930: DISABLE
// begin Difficulty := Difficulty + 1 ;
98931: LD_ADDR_OWVAR 67
98935: PUSH
98936: LD_OWVAR 67
98940: PUSH
98941: LD_INT 1
98943: PLUS
98944: ST_TO_ADDR
// end ;
98945: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98946: LD_EXP 96
98950: PUSH
98951: LD_EXP 115
98955: AND
98956: IFFALSE 99059
98958: GO 98960
98960: DISABLE
98961: LD_INT 0
98963: PPUSH
// begin for i := 1 to 5 do
98964: LD_ADDR_VAR 0 1
98968: PUSH
98969: DOUBLE
98970: LD_INT 1
98972: DEC
98973: ST_TO_ADDR
98974: LD_INT 5
98976: PUSH
98977: FOR_TO
98978: IFFALSE 99057
// begin uc_nation := nation_nature ;
98980: LD_ADDR_OWVAR 21
98984: PUSH
98985: LD_INT 0
98987: ST_TO_ADDR
// uc_side := 0 ;
98988: LD_ADDR_OWVAR 20
98992: PUSH
98993: LD_INT 0
98995: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98996: LD_ADDR_OWVAR 29
99000: PUSH
99001: LD_INT 12
99003: PUSH
99004: LD_INT 12
99006: PUSH
99007: EMPTY
99008: LIST
99009: LIST
99010: ST_TO_ADDR
// hc_agressivity := 20 ;
99011: LD_ADDR_OWVAR 35
99015: PUSH
99016: LD_INT 20
99018: ST_TO_ADDR
// hc_class := class_tiger ;
99019: LD_ADDR_OWVAR 28
99023: PUSH
99024: LD_INT 14
99026: ST_TO_ADDR
// hc_gallery :=  ;
99027: LD_ADDR_OWVAR 33
99031: PUSH
99032: LD_STRING 
99034: ST_TO_ADDR
// hc_name :=  ;
99035: LD_ADDR_OWVAR 26
99039: PUSH
99040: LD_STRING 
99042: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99043: CALL_OW 44
99047: PPUSH
99048: LD_INT 0
99050: PPUSH
99051: CALL_OW 51
// end ;
99055: GO 98977
99057: POP
99058: POP
// end ;
99059: PPOPN 1
99061: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99062: LD_EXP 96
99066: PUSH
99067: LD_EXP 116
99071: AND
99072: IFFALSE 99081
99074: GO 99076
99076: DISABLE
// StreamSibBomb ;
99077: CALL 99082 0 0
99081: END
// export function StreamSibBomb ; var i , x , y ; begin
99082: LD_INT 0
99084: PPUSH
99085: PPUSH
99086: PPUSH
99087: PPUSH
// result := false ;
99088: LD_ADDR_VAR 0 1
99092: PUSH
99093: LD_INT 0
99095: ST_TO_ADDR
// for i := 1 to 16 do
99096: LD_ADDR_VAR 0 2
99100: PUSH
99101: DOUBLE
99102: LD_INT 1
99104: DEC
99105: ST_TO_ADDR
99106: LD_INT 16
99108: PUSH
99109: FOR_TO
99110: IFFALSE 99309
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99112: LD_ADDR_VAR 0 3
99116: PUSH
99117: LD_INT 10
99119: PUSH
99120: LD_INT 20
99122: PUSH
99123: LD_INT 30
99125: PUSH
99126: LD_INT 40
99128: PUSH
99129: LD_INT 50
99131: PUSH
99132: LD_INT 60
99134: PUSH
99135: LD_INT 70
99137: PUSH
99138: LD_INT 80
99140: PUSH
99141: LD_INT 90
99143: PUSH
99144: LD_INT 100
99146: PUSH
99147: LD_INT 110
99149: PUSH
99150: LD_INT 120
99152: PUSH
99153: LD_INT 130
99155: PUSH
99156: LD_INT 140
99158: PUSH
99159: LD_INT 150
99161: PUSH
99162: EMPTY
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: PUSH
99179: LD_INT 1
99181: PPUSH
99182: LD_INT 15
99184: PPUSH
99185: CALL_OW 12
99189: ARRAY
99190: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99191: LD_ADDR_VAR 0 4
99195: PUSH
99196: LD_INT 10
99198: PUSH
99199: LD_INT 20
99201: PUSH
99202: LD_INT 30
99204: PUSH
99205: LD_INT 40
99207: PUSH
99208: LD_INT 50
99210: PUSH
99211: LD_INT 60
99213: PUSH
99214: LD_INT 70
99216: PUSH
99217: LD_INT 80
99219: PUSH
99220: LD_INT 90
99222: PUSH
99223: LD_INT 100
99225: PUSH
99226: LD_INT 110
99228: PUSH
99229: LD_INT 120
99231: PUSH
99232: LD_INT 130
99234: PUSH
99235: LD_INT 140
99237: PUSH
99238: LD_INT 150
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: LIST
99247: LIST
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: PUSH
99258: LD_INT 1
99260: PPUSH
99261: LD_INT 15
99263: PPUSH
99264: CALL_OW 12
99268: ARRAY
99269: ST_TO_ADDR
// if ValidHex ( x , y ) then
99270: LD_VAR 0 3
99274: PPUSH
99275: LD_VAR 0 4
99279: PPUSH
99280: CALL_OW 488
99284: IFFALSE 99307
// begin result := [ x , y ] ;
99286: LD_ADDR_VAR 0 1
99290: PUSH
99291: LD_VAR 0 3
99295: PUSH
99296: LD_VAR 0 4
99300: PUSH
99301: EMPTY
99302: LIST
99303: LIST
99304: ST_TO_ADDR
// break ;
99305: GO 99309
// end ; end ;
99307: GO 99109
99309: POP
99310: POP
// if result then
99311: LD_VAR 0 1
99315: IFFALSE 99375
// begin ToLua ( playSibBomb() ) ;
99317: LD_STRING playSibBomb()
99319: PPUSH
99320: CALL_OW 559
// wait ( 0 0$14 ) ;
99324: LD_INT 490
99326: PPUSH
99327: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99331: LD_VAR 0 1
99335: PUSH
99336: LD_INT 1
99338: ARRAY
99339: PPUSH
99340: LD_VAR 0 1
99344: PUSH
99345: LD_INT 2
99347: ARRAY
99348: PPUSH
99349: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99353: LD_VAR 0 1
99357: PUSH
99358: LD_INT 1
99360: ARRAY
99361: PPUSH
99362: LD_VAR 0 1
99366: PUSH
99367: LD_INT 2
99369: ARRAY
99370: PPUSH
99371: CALL_OW 429
// end ; end ;
99375: LD_VAR 0 1
99379: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99380: LD_EXP 96
99384: PUSH
99385: LD_EXP 118
99389: AND
99390: IFFALSE 99402
99392: GO 99394
99394: DISABLE
// YouLost (  ) ;
99395: LD_STRING 
99397: PPUSH
99398: CALL_OW 104
99402: END
// every 0 0$1 trigger StreamModeActive and sFog do
99403: LD_EXP 96
99407: PUSH
99408: LD_EXP 117
99412: AND
99413: IFFALSE 99427
99415: GO 99417
99417: DISABLE
// FogOff ( your_side ) ;
99418: LD_OWVAR 2
99422: PPUSH
99423: CALL_OW 344
99427: END
// every 0 0$1 trigger StreamModeActive and sSun do
99428: LD_EXP 96
99432: PUSH
99433: LD_EXP 119
99437: AND
99438: IFFALSE 99466
99440: GO 99442
99442: DISABLE
// begin solar_recharge_percent := 0 ;
99443: LD_ADDR_OWVAR 79
99447: PUSH
99448: LD_INT 0
99450: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99451: LD_INT 10500
99453: PPUSH
99454: CALL_OW 67
// solar_recharge_percent := 100 ;
99458: LD_ADDR_OWVAR 79
99462: PUSH
99463: LD_INT 100
99465: ST_TO_ADDR
// end ;
99466: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99467: LD_EXP 96
99471: PUSH
99472: LD_EXP 120
99476: AND
99477: IFFALSE 99716
99479: GO 99481
99481: DISABLE
99482: LD_INT 0
99484: PPUSH
99485: PPUSH
99486: PPUSH
// begin tmp := [ ] ;
99487: LD_ADDR_VAR 0 3
99491: PUSH
99492: EMPTY
99493: ST_TO_ADDR
// for i := 1 to 6 do
99494: LD_ADDR_VAR 0 1
99498: PUSH
99499: DOUBLE
99500: LD_INT 1
99502: DEC
99503: ST_TO_ADDR
99504: LD_INT 6
99506: PUSH
99507: FOR_TO
99508: IFFALSE 99613
// begin uc_nation := nation_nature ;
99510: LD_ADDR_OWVAR 21
99514: PUSH
99515: LD_INT 0
99517: ST_TO_ADDR
// uc_side := 0 ;
99518: LD_ADDR_OWVAR 20
99522: PUSH
99523: LD_INT 0
99525: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99526: LD_ADDR_OWVAR 29
99530: PUSH
99531: LD_INT 12
99533: PUSH
99534: LD_INT 12
99536: PUSH
99537: EMPTY
99538: LIST
99539: LIST
99540: ST_TO_ADDR
// hc_agressivity := 20 ;
99541: LD_ADDR_OWVAR 35
99545: PUSH
99546: LD_INT 20
99548: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99549: LD_ADDR_OWVAR 28
99553: PUSH
99554: LD_INT 17
99556: ST_TO_ADDR
// hc_gallery :=  ;
99557: LD_ADDR_OWVAR 33
99561: PUSH
99562: LD_STRING 
99564: ST_TO_ADDR
// hc_name :=  ;
99565: LD_ADDR_OWVAR 26
99569: PUSH
99570: LD_STRING 
99572: ST_TO_ADDR
// un := CreateHuman ;
99573: LD_ADDR_VAR 0 2
99577: PUSH
99578: CALL_OW 44
99582: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99583: LD_VAR 0 2
99587: PPUSH
99588: LD_INT 1
99590: PPUSH
99591: CALL_OW 51
// tmp := tmp ^ un ;
99595: LD_ADDR_VAR 0 3
99599: PUSH
99600: LD_VAR 0 3
99604: PUSH
99605: LD_VAR 0 2
99609: ADD
99610: ST_TO_ADDR
// end ;
99611: GO 99507
99613: POP
99614: POP
// repeat wait ( 0 0$1 ) ;
99615: LD_INT 35
99617: PPUSH
99618: CALL_OW 67
// for un in tmp do
99622: LD_ADDR_VAR 0 2
99626: PUSH
99627: LD_VAR 0 3
99631: PUSH
99632: FOR_IN
99633: IFFALSE 99707
// begin if IsDead ( un ) then
99635: LD_VAR 0 2
99639: PPUSH
99640: CALL_OW 301
99644: IFFALSE 99664
// begin tmp := tmp diff un ;
99646: LD_ADDR_VAR 0 3
99650: PUSH
99651: LD_VAR 0 3
99655: PUSH
99656: LD_VAR 0 2
99660: DIFF
99661: ST_TO_ADDR
// continue ;
99662: GO 99632
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99664: LD_VAR 0 2
99668: PPUSH
99669: LD_INT 3
99671: PUSH
99672: LD_INT 22
99674: PUSH
99675: LD_INT 0
99677: PUSH
99678: EMPTY
99679: LIST
99680: LIST
99681: PUSH
99682: EMPTY
99683: LIST
99684: LIST
99685: PPUSH
99686: CALL_OW 69
99690: PPUSH
99691: LD_VAR 0 2
99695: PPUSH
99696: CALL_OW 74
99700: PPUSH
99701: CALL_OW 115
// end ;
99705: GO 99632
99707: POP
99708: POP
// until not tmp ;
99709: LD_VAR 0 3
99713: NOT
99714: IFFALSE 99615
// end ;
99716: PPOPN 3
99718: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99719: LD_EXP 96
99723: PUSH
99724: LD_EXP 121
99728: AND
99729: IFFALSE 99783
99731: GO 99733
99733: DISABLE
// begin ToLua ( displayTroll(); ) ;
99734: LD_STRING displayTroll();
99736: PPUSH
99737: CALL_OW 559
// wait ( 3 3$00 ) ;
99741: LD_INT 6300
99743: PPUSH
99744: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99748: LD_STRING hideTroll();
99750: PPUSH
99751: CALL_OW 559
// wait ( 1 1$00 ) ;
99755: LD_INT 2100
99757: PPUSH
99758: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99762: LD_STRING displayTroll();
99764: PPUSH
99765: CALL_OW 559
// wait ( 1 1$00 ) ;
99769: LD_INT 2100
99771: PPUSH
99772: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99776: LD_STRING hideTroll();
99778: PPUSH
99779: CALL_OW 559
// end ;
99783: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99784: LD_EXP 96
99788: PUSH
99789: LD_EXP 122
99793: AND
99794: IFFALSE 99857
99796: GO 99798
99798: DISABLE
99799: LD_INT 0
99801: PPUSH
// begin p := 0 ;
99802: LD_ADDR_VAR 0 1
99806: PUSH
99807: LD_INT 0
99809: ST_TO_ADDR
// repeat game_speed := 1 ;
99810: LD_ADDR_OWVAR 65
99814: PUSH
99815: LD_INT 1
99817: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99818: LD_INT 35
99820: PPUSH
99821: CALL_OW 67
// p := p + 1 ;
99825: LD_ADDR_VAR 0 1
99829: PUSH
99830: LD_VAR 0 1
99834: PUSH
99835: LD_INT 1
99837: PLUS
99838: ST_TO_ADDR
// until p >= 60 ;
99839: LD_VAR 0 1
99843: PUSH
99844: LD_INT 60
99846: GREATEREQUAL
99847: IFFALSE 99810
// game_speed := 4 ;
99849: LD_ADDR_OWVAR 65
99853: PUSH
99854: LD_INT 4
99856: ST_TO_ADDR
// end ;
99857: PPOPN 1
99859: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99860: LD_EXP 96
99864: PUSH
99865: LD_EXP 123
99869: AND
99870: IFFALSE 100016
99872: GO 99874
99874: DISABLE
99875: LD_INT 0
99877: PPUSH
99878: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99879: LD_ADDR_VAR 0 1
99883: PUSH
99884: LD_INT 22
99886: PUSH
99887: LD_OWVAR 2
99891: PUSH
99892: EMPTY
99893: LIST
99894: LIST
99895: PUSH
99896: LD_INT 2
99898: PUSH
99899: LD_INT 30
99901: PUSH
99902: LD_INT 0
99904: PUSH
99905: EMPTY
99906: LIST
99907: LIST
99908: PUSH
99909: LD_INT 30
99911: PUSH
99912: LD_INT 1
99914: PUSH
99915: EMPTY
99916: LIST
99917: LIST
99918: PUSH
99919: EMPTY
99920: LIST
99921: LIST
99922: LIST
99923: PUSH
99924: EMPTY
99925: LIST
99926: LIST
99927: PPUSH
99928: CALL_OW 69
99932: ST_TO_ADDR
// if not depot then
99933: LD_VAR 0 1
99937: NOT
99938: IFFALSE 99942
// exit ;
99940: GO 100016
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99942: LD_ADDR_VAR 0 2
99946: PUSH
99947: LD_VAR 0 1
99951: PUSH
99952: LD_INT 1
99954: PPUSH
99955: LD_VAR 0 1
99959: PPUSH
99960: CALL_OW 12
99964: ARRAY
99965: PPUSH
99966: CALL_OW 274
99970: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99971: LD_VAR 0 2
99975: PPUSH
99976: LD_INT 1
99978: PPUSH
99979: LD_INT 0
99981: PPUSH
99982: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99986: LD_VAR 0 2
99990: PPUSH
99991: LD_INT 2
99993: PPUSH
99994: LD_INT 0
99996: PPUSH
99997: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100001: LD_VAR 0 2
100005: PPUSH
100006: LD_INT 3
100008: PPUSH
100009: LD_INT 0
100011: PPUSH
100012: CALL_OW 277
// end ;
100016: PPOPN 2
100018: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100019: LD_EXP 96
100023: PUSH
100024: LD_EXP 124
100028: AND
100029: IFFALSE 100126
100031: GO 100033
100033: DISABLE
100034: LD_INT 0
100036: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100037: LD_ADDR_VAR 0 1
100041: PUSH
100042: LD_INT 22
100044: PUSH
100045: LD_OWVAR 2
100049: PUSH
100050: EMPTY
100051: LIST
100052: LIST
100053: PUSH
100054: LD_INT 21
100056: PUSH
100057: LD_INT 1
100059: PUSH
100060: EMPTY
100061: LIST
100062: LIST
100063: PUSH
100064: LD_INT 3
100066: PUSH
100067: LD_INT 23
100069: PUSH
100070: LD_INT 0
100072: PUSH
100073: EMPTY
100074: LIST
100075: LIST
100076: PUSH
100077: EMPTY
100078: LIST
100079: LIST
100080: PUSH
100081: EMPTY
100082: LIST
100083: LIST
100084: LIST
100085: PPUSH
100086: CALL_OW 69
100090: ST_TO_ADDR
// if not tmp then
100091: LD_VAR 0 1
100095: NOT
100096: IFFALSE 100100
// exit ;
100098: GO 100126
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100100: LD_VAR 0 1
100104: PUSH
100105: LD_INT 1
100107: PPUSH
100108: LD_VAR 0 1
100112: PPUSH
100113: CALL_OW 12
100117: ARRAY
100118: PPUSH
100119: LD_INT 200
100121: PPUSH
100122: CALL_OW 234
// end ;
100126: PPOPN 1
100128: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100129: LD_EXP 96
100133: PUSH
100134: LD_EXP 125
100138: AND
100139: IFFALSE 100218
100141: GO 100143
100143: DISABLE
100144: LD_INT 0
100146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100147: LD_ADDR_VAR 0 1
100151: PUSH
100152: LD_INT 22
100154: PUSH
100155: LD_OWVAR 2
100159: PUSH
100160: EMPTY
100161: LIST
100162: LIST
100163: PUSH
100164: LD_INT 21
100166: PUSH
100167: LD_INT 2
100169: PUSH
100170: EMPTY
100171: LIST
100172: LIST
100173: PUSH
100174: EMPTY
100175: LIST
100176: LIST
100177: PPUSH
100178: CALL_OW 69
100182: ST_TO_ADDR
// if not tmp then
100183: LD_VAR 0 1
100187: NOT
100188: IFFALSE 100192
// exit ;
100190: GO 100218
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100192: LD_VAR 0 1
100196: PUSH
100197: LD_INT 1
100199: PPUSH
100200: LD_VAR 0 1
100204: PPUSH
100205: CALL_OW 12
100209: ARRAY
100210: PPUSH
100211: LD_INT 60
100213: PPUSH
100214: CALL_OW 234
// end ;
100218: PPOPN 1
100220: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100221: LD_EXP 96
100225: PUSH
100226: LD_EXP 126
100230: AND
100231: IFFALSE 100330
100233: GO 100235
100235: DISABLE
100236: LD_INT 0
100238: PPUSH
100239: PPUSH
// begin enable ;
100240: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100241: LD_ADDR_VAR 0 1
100245: PUSH
100246: LD_INT 22
100248: PUSH
100249: LD_OWVAR 2
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: PUSH
100258: LD_INT 61
100260: PUSH
100261: EMPTY
100262: LIST
100263: PUSH
100264: LD_INT 33
100266: PUSH
100267: LD_INT 2
100269: PUSH
100270: EMPTY
100271: LIST
100272: LIST
100273: PUSH
100274: EMPTY
100275: LIST
100276: LIST
100277: LIST
100278: PPUSH
100279: CALL_OW 69
100283: ST_TO_ADDR
// if not tmp then
100284: LD_VAR 0 1
100288: NOT
100289: IFFALSE 100293
// exit ;
100291: GO 100330
// for i in tmp do
100293: LD_ADDR_VAR 0 2
100297: PUSH
100298: LD_VAR 0 1
100302: PUSH
100303: FOR_IN
100304: IFFALSE 100328
// if IsControledBy ( i ) then
100306: LD_VAR 0 2
100310: PPUSH
100311: CALL_OW 312
100315: IFFALSE 100326
// ComUnlink ( i ) ;
100317: LD_VAR 0 2
100321: PPUSH
100322: CALL_OW 136
100326: GO 100303
100328: POP
100329: POP
// end ;
100330: PPOPN 2
100332: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100333: LD_EXP 96
100337: PUSH
100338: LD_EXP 127
100342: AND
100343: IFFALSE 100483
100345: GO 100347
100347: DISABLE
100348: LD_INT 0
100350: PPUSH
100351: PPUSH
// begin ToLua ( displayPowell(); ) ;
100352: LD_STRING displayPowell();
100354: PPUSH
100355: CALL_OW 559
// uc_side := 0 ;
100359: LD_ADDR_OWVAR 20
100363: PUSH
100364: LD_INT 0
100366: ST_TO_ADDR
// uc_nation := 2 ;
100367: LD_ADDR_OWVAR 21
100371: PUSH
100372: LD_INT 2
100374: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100375: LD_ADDR_OWVAR 37
100379: PUSH
100380: LD_INT 14
100382: ST_TO_ADDR
// vc_engine := engine_siberite ;
100383: LD_ADDR_OWVAR 39
100387: PUSH
100388: LD_INT 3
100390: ST_TO_ADDR
// vc_control := control_apeman ;
100391: LD_ADDR_OWVAR 38
100395: PUSH
100396: LD_INT 5
100398: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100399: LD_ADDR_OWVAR 40
100403: PUSH
100404: LD_INT 29
100406: ST_TO_ADDR
// un := CreateVehicle ;
100407: LD_ADDR_VAR 0 2
100411: PUSH
100412: CALL_OW 45
100416: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100417: LD_VAR 0 2
100421: PPUSH
100422: LD_INT 1
100424: PPUSH
100425: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100429: LD_INT 35
100431: PPUSH
100432: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100436: LD_VAR 0 2
100440: PPUSH
100441: LD_INT 22
100443: PUSH
100444: LD_OWVAR 2
100448: PUSH
100449: EMPTY
100450: LIST
100451: LIST
100452: PPUSH
100453: CALL_OW 69
100457: PPUSH
100458: LD_VAR 0 2
100462: PPUSH
100463: CALL_OW 74
100467: PPUSH
100468: CALL_OW 115
// until IsDead ( un ) ;
100472: LD_VAR 0 2
100476: PPUSH
100477: CALL_OW 301
100481: IFFALSE 100429
// end ;
100483: PPOPN 2
100485: END
// every 0 0$1 trigger StreamModeActive and sStu do
100486: LD_EXP 96
100490: PUSH
100491: LD_EXP 135
100495: AND
100496: IFFALSE 100512
100498: GO 100500
100500: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100501: LD_STRING displayStucuk();
100503: PPUSH
100504: CALL_OW 559
// ResetFog ;
100508: CALL_OW 335
// end ;
100512: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100513: LD_EXP 96
100517: PUSH
100518: LD_EXP 128
100522: AND
100523: IFFALSE 100664
100525: GO 100527
100527: DISABLE
100528: LD_INT 0
100530: PPUSH
100531: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100532: LD_ADDR_VAR 0 2
100536: PUSH
100537: LD_INT 22
100539: PUSH
100540: LD_OWVAR 2
100544: PUSH
100545: EMPTY
100546: LIST
100547: LIST
100548: PUSH
100549: LD_INT 21
100551: PUSH
100552: LD_INT 1
100554: PUSH
100555: EMPTY
100556: LIST
100557: LIST
100558: PUSH
100559: EMPTY
100560: LIST
100561: LIST
100562: PPUSH
100563: CALL_OW 69
100567: ST_TO_ADDR
// if not tmp then
100568: LD_VAR 0 2
100572: NOT
100573: IFFALSE 100577
// exit ;
100575: GO 100664
// un := tmp [ rand ( 1 , tmp ) ] ;
100577: LD_ADDR_VAR 0 1
100581: PUSH
100582: LD_VAR 0 2
100586: PUSH
100587: LD_INT 1
100589: PPUSH
100590: LD_VAR 0 2
100594: PPUSH
100595: CALL_OW 12
100599: ARRAY
100600: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100601: LD_VAR 0 1
100605: PPUSH
100606: LD_INT 0
100608: PPUSH
100609: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100613: LD_VAR 0 1
100617: PPUSH
100618: LD_OWVAR 3
100622: PUSH
100623: LD_VAR 0 1
100627: DIFF
100628: PPUSH
100629: LD_VAR 0 1
100633: PPUSH
100634: CALL_OW 74
100638: PPUSH
100639: CALL_OW 115
// wait ( 0 0$20 ) ;
100643: LD_INT 700
100645: PPUSH
100646: CALL_OW 67
// SetSide ( un , your_side ) ;
100650: LD_VAR 0 1
100654: PPUSH
100655: LD_OWVAR 2
100659: PPUSH
100660: CALL_OW 235
// end ;
100664: PPOPN 2
100666: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100667: LD_EXP 96
100671: PUSH
100672: LD_EXP 129
100676: AND
100677: IFFALSE 100783
100679: GO 100681
100681: DISABLE
100682: LD_INT 0
100684: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100685: LD_ADDR_VAR 0 1
100689: PUSH
100690: LD_INT 22
100692: PUSH
100693: LD_OWVAR 2
100697: PUSH
100698: EMPTY
100699: LIST
100700: LIST
100701: PUSH
100702: LD_INT 2
100704: PUSH
100705: LD_INT 30
100707: PUSH
100708: LD_INT 0
100710: PUSH
100711: EMPTY
100712: LIST
100713: LIST
100714: PUSH
100715: LD_INT 30
100717: PUSH
100718: LD_INT 1
100720: PUSH
100721: EMPTY
100722: LIST
100723: LIST
100724: PUSH
100725: EMPTY
100726: LIST
100727: LIST
100728: LIST
100729: PUSH
100730: EMPTY
100731: LIST
100732: LIST
100733: PPUSH
100734: CALL_OW 69
100738: ST_TO_ADDR
// if not depot then
100739: LD_VAR 0 1
100743: NOT
100744: IFFALSE 100748
// exit ;
100746: GO 100783
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100748: LD_VAR 0 1
100752: PUSH
100753: LD_INT 1
100755: ARRAY
100756: PPUSH
100757: CALL_OW 250
100761: PPUSH
100762: LD_VAR 0 1
100766: PUSH
100767: LD_INT 1
100769: ARRAY
100770: PPUSH
100771: CALL_OW 251
100775: PPUSH
100776: LD_INT 70
100778: PPUSH
100779: CALL_OW 495
// end ;
100783: PPOPN 1
100785: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100786: LD_EXP 96
100790: PUSH
100791: LD_EXP 130
100795: AND
100796: IFFALSE 101007
100798: GO 100800
100800: DISABLE
100801: LD_INT 0
100803: PPUSH
100804: PPUSH
100805: PPUSH
100806: PPUSH
100807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100808: LD_ADDR_VAR 0 5
100812: PUSH
100813: LD_INT 22
100815: PUSH
100816: LD_OWVAR 2
100820: PUSH
100821: EMPTY
100822: LIST
100823: LIST
100824: PUSH
100825: LD_INT 21
100827: PUSH
100828: LD_INT 1
100830: PUSH
100831: EMPTY
100832: LIST
100833: LIST
100834: PUSH
100835: EMPTY
100836: LIST
100837: LIST
100838: PPUSH
100839: CALL_OW 69
100843: ST_TO_ADDR
// if not tmp then
100844: LD_VAR 0 5
100848: NOT
100849: IFFALSE 100853
// exit ;
100851: GO 101007
// for i in tmp do
100853: LD_ADDR_VAR 0 1
100857: PUSH
100858: LD_VAR 0 5
100862: PUSH
100863: FOR_IN
100864: IFFALSE 101005
// begin d := rand ( 0 , 5 ) ;
100866: LD_ADDR_VAR 0 4
100870: PUSH
100871: LD_INT 0
100873: PPUSH
100874: LD_INT 5
100876: PPUSH
100877: CALL_OW 12
100881: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100882: LD_ADDR_VAR 0 2
100886: PUSH
100887: LD_VAR 0 1
100891: PPUSH
100892: CALL_OW 250
100896: PPUSH
100897: LD_VAR 0 4
100901: PPUSH
100902: LD_INT 3
100904: PPUSH
100905: LD_INT 12
100907: PPUSH
100908: CALL_OW 12
100912: PPUSH
100913: CALL_OW 272
100917: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100918: LD_ADDR_VAR 0 3
100922: PUSH
100923: LD_VAR 0 1
100927: PPUSH
100928: CALL_OW 251
100932: PPUSH
100933: LD_VAR 0 4
100937: PPUSH
100938: LD_INT 3
100940: PPUSH
100941: LD_INT 12
100943: PPUSH
100944: CALL_OW 12
100948: PPUSH
100949: CALL_OW 273
100953: ST_TO_ADDR
// if ValidHex ( x , y ) then
100954: LD_VAR 0 2
100958: PPUSH
100959: LD_VAR 0 3
100963: PPUSH
100964: CALL_OW 488
100968: IFFALSE 101003
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100970: LD_VAR 0 1
100974: PPUSH
100975: LD_VAR 0 2
100979: PPUSH
100980: LD_VAR 0 3
100984: PPUSH
100985: LD_INT 3
100987: PPUSH
100988: LD_INT 6
100990: PPUSH
100991: CALL_OW 12
100995: PPUSH
100996: LD_INT 1
100998: PPUSH
100999: CALL_OW 483
// end ;
101003: GO 100863
101005: POP
101006: POP
// end ;
101007: PPOPN 5
101009: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101010: LD_EXP 96
101014: PUSH
101015: LD_EXP 131
101019: AND
101020: IFFALSE 101114
101022: GO 101024
101024: DISABLE
101025: LD_INT 0
101027: PPUSH
101028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101029: LD_ADDR_VAR 0 2
101033: PUSH
101034: LD_INT 22
101036: PUSH
101037: LD_OWVAR 2
101041: PUSH
101042: EMPTY
101043: LIST
101044: LIST
101045: PUSH
101046: LD_INT 32
101048: PUSH
101049: LD_INT 1
101051: PUSH
101052: EMPTY
101053: LIST
101054: LIST
101055: PUSH
101056: LD_INT 21
101058: PUSH
101059: LD_INT 2
101061: PUSH
101062: EMPTY
101063: LIST
101064: LIST
101065: PUSH
101066: EMPTY
101067: LIST
101068: LIST
101069: LIST
101070: PPUSH
101071: CALL_OW 69
101075: ST_TO_ADDR
// if not tmp then
101076: LD_VAR 0 2
101080: NOT
101081: IFFALSE 101085
// exit ;
101083: GO 101114
// for i in tmp do
101085: LD_ADDR_VAR 0 1
101089: PUSH
101090: LD_VAR 0 2
101094: PUSH
101095: FOR_IN
101096: IFFALSE 101112
// SetFuel ( i , 0 ) ;
101098: LD_VAR 0 1
101102: PPUSH
101103: LD_INT 0
101105: PPUSH
101106: CALL_OW 240
101110: GO 101095
101112: POP
101113: POP
// end ;
101114: PPOPN 2
101116: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101117: LD_EXP 96
101121: PUSH
101122: LD_EXP 132
101126: AND
101127: IFFALSE 101193
101129: GO 101131
101131: DISABLE
101132: LD_INT 0
101134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101135: LD_ADDR_VAR 0 1
101139: PUSH
101140: LD_INT 22
101142: PUSH
101143: LD_OWVAR 2
101147: PUSH
101148: EMPTY
101149: LIST
101150: LIST
101151: PUSH
101152: LD_INT 30
101154: PUSH
101155: LD_INT 29
101157: PUSH
101158: EMPTY
101159: LIST
101160: LIST
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: PPUSH
101166: CALL_OW 69
101170: ST_TO_ADDR
// if not tmp then
101171: LD_VAR 0 1
101175: NOT
101176: IFFALSE 101180
// exit ;
101178: GO 101193
// DestroyUnit ( tmp [ 1 ] ) ;
101180: LD_VAR 0 1
101184: PUSH
101185: LD_INT 1
101187: ARRAY
101188: PPUSH
101189: CALL_OW 65
// end ;
101193: PPOPN 1
101195: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101196: LD_EXP 96
101200: PUSH
101201: LD_EXP 134
101205: AND
101206: IFFALSE 101335
101208: GO 101210
101210: DISABLE
101211: LD_INT 0
101213: PPUSH
// begin uc_side := 0 ;
101214: LD_ADDR_OWVAR 20
101218: PUSH
101219: LD_INT 0
101221: ST_TO_ADDR
// uc_nation := nation_arabian ;
101222: LD_ADDR_OWVAR 21
101226: PUSH
101227: LD_INT 2
101229: ST_TO_ADDR
// hc_gallery :=  ;
101230: LD_ADDR_OWVAR 33
101234: PUSH
101235: LD_STRING 
101237: ST_TO_ADDR
// hc_name :=  ;
101238: LD_ADDR_OWVAR 26
101242: PUSH
101243: LD_STRING 
101245: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101246: LD_INT 1
101248: PPUSH
101249: LD_INT 11
101251: PPUSH
101252: LD_INT 10
101254: PPUSH
101255: CALL_OW 380
// un := CreateHuman ;
101259: LD_ADDR_VAR 0 1
101263: PUSH
101264: CALL_OW 44
101268: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101269: LD_VAR 0 1
101273: PPUSH
101274: LD_INT 1
101276: PPUSH
101277: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101281: LD_INT 35
101283: PPUSH
101284: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101288: LD_VAR 0 1
101292: PPUSH
101293: LD_INT 22
101295: PUSH
101296: LD_OWVAR 2
101300: PUSH
101301: EMPTY
101302: LIST
101303: LIST
101304: PPUSH
101305: CALL_OW 69
101309: PPUSH
101310: LD_VAR 0 1
101314: PPUSH
101315: CALL_OW 74
101319: PPUSH
101320: CALL_OW 115
// until IsDead ( un ) ;
101324: LD_VAR 0 1
101328: PPUSH
101329: CALL_OW 301
101333: IFFALSE 101281
// end ;
101335: PPOPN 1
101337: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101338: LD_EXP 96
101342: PUSH
101343: LD_EXP 136
101347: AND
101348: IFFALSE 101360
101350: GO 101352
101352: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101353: LD_STRING earthquake(getX(game), 0, 32)
101355: PPUSH
101356: CALL_OW 559
101360: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101361: LD_EXP 96
101365: PUSH
101366: LD_EXP 137
101370: AND
101371: IFFALSE 101462
101373: GO 101375
101375: DISABLE
101376: LD_INT 0
101378: PPUSH
// begin enable ;
101379: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101380: LD_ADDR_VAR 0 1
101384: PUSH
101385: LD_INT 22
101387: PUSH
101388: LD_OWVAR 2
101392: PUSH
101393: EMPTY
101394: LIST
101395: LIST
101396: PUSH
101397: LD_INT 21
101399: PUSH
101400: LD_INT 2
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: PUSH
101407: LD_INT 33
101409: PUSH
101410: LD_INT 3
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PUSH
101417: EMPTY
101418: LIST
101419: LIST
101420: LIST
101421: PPUSH
101422: CALL_OW 69
101426: ST_TO_ADDR
// if not tmp then
101427: LD_VAR 0 1
101431: NOT
101432: IFFALSE 101436
// exit ;
101434: GO 101462
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101436: LD_VAR 0 1
101440: PUSH
101441: LD_INT 1
101443: PPUSH
101444: LD_VAR 0 1
101448: PPUSH
101449: CALL_OW 12
101453: ARRAY
101454: PPUSH
101455: LD_INT 1
101457: PPUSH
101458: CALL_OW 234
// end ;
101462: PPOPN 1
101464: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101465: LD_EXP 96
101469: PUSH
101470: LD_EXP 138
101474: AND
101475: IFFALSE 101616
101477: GO 101479
101479: DISABLE
101480: LD_INT 0
101482: PPUSH
101483: PPUSH
101484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101485: LD_ADDR_VAR 0 3
101489: PUSH
101490: LD_INT 22
101492: PUSH
101493: LD_OWVAR 2
101497: PUSH
101498: EMPTY
101499: LIST
101500: LIST
101501: PUSH
101502: LD_INT 25
101504: PUSH
101505: LD_INT 1
101507: PUSH
101508: EMPTY
101509: LIST
101510: LIST
101511: PUSH
101512: EMPTY
101513: LIST
101514: LIST
101515: PPUSH
101516: CALL_OW 69
101520: ST_TO_ADDR
// if not tmp then
101521: LD_VAR 0 3
101525: NOT
101526: IFFALSE 101530
// exit ;
101528: GO 101616
// un := tmp [ rand ( 1 , tmp ) ] ;
101530: LD_ADDR_VAR 0 2
101534: PUSH
101535: LD_VAR 0 3
101539: PUSH
101540: LD_INT 1
101542: PPUSH
101543: LD_VAR 0 3
101547: PPUSH
101548: CALL_OW 12
101552: ARRAY
101553: ST_TO_ADDR
// if Crawls ( un ) then
101554: LD_VAR 0 2
101558: PPUSH
101559: CALL_OW 318
101563: IFFALSE 101574
// ComWalk ( un ) ;
101565: LD_VAR 0 2
101569: PPUSH
101570: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101574: LD_VAR 0 2
101578: PPUSH
101579: LD_INT 9
101581: PPUSH
101582: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101586: LD_INT 28
101588: PPUSH
101589: LD_OWVAR 2
101593: PPUSH
101594: LD_INT 2
101596: PPUSH
101597: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101601: LD_INT 29
101603: PPUSH
101604: LD_OWVAR 2
101608: PPUSH
101609: LD_INT 2
101611: PPUSH
101612: CALL_OW 322
// end ;
101616: PPOPN 3
101618: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101619: LD_EXP 96
101623: PUSH
101624: LD_EXP 139
101628: AND
101629: IFFALSE 101740
101631: GO 101633
101633: DISABLE
101634: LD_INT 0
101636: PPUSH
101637: PPUSH
101638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101639: LD_ADDR_VAR 0 3
101643: PUSH
101644: LD_INT 22
101646: PUSH
101647: LD_OWVAR 2
101651: PUSH
101652: EMPTY
101653: LIST
101654: LIST
101655: PUSH
101656: LD_INT 25
101658: PUSH
101659: LD_INT 1
101661: PUSH
101662: EMPTY
101663: LIST
101664: LIST
101665: PUSH
101666: EMPTY
101667: LIST
101668: LIST
101669: PPUSH
101670: CALL_OW 69
101674: ST_TO_ADDR
// if not tmp then
101675: LD_VAR 0 3
101679: NOT
101680: IFFALSE 101684
// exit ;
101682: GO 101740
// un := tmp [ rand ( 1 , tmp ) ] ;
101684: LD_ADDR_VAR 0 2
101688: PUSH
101689: LD_VAR 0 3
101693: PUSH
101694: LD_INT 1
101696: PPUSH
101697: LD_VAR 0 3
101701: PPUSH
101702: CALL_OW 12
101706: ARRAY
101707: ST_TO_ADDR
// if Crawls ( un ) then
101708: LD_VAR 0 2
101712: PPUSH
101713: CALL_OW 318
101717: IFFALSE 101728
// ComWalk ( un ) ;
101719: LD_VAR 0 2
101723: PPUSH
101724: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101728: LD_VAR 0 2
101732: PPUSH
101733: LD_INT 8
101735: PPUSH
101736: CALL_OW 336
// end ;
101740: PPOPN 3
101742: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101743: LD_EXP 96
101747: PUSH
101748: LD_EXP 140
101752: AND
101753: IFFALSE 101897
101755: GO 101757
101757: DISABLE
101758: LD_INT 0
101760: PPUSH
101761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101762: LD_ADDR_VAR 0 2
101766: PUSH
101767: LD_INT 22
101769: PUSH
101770: LD_OWVAR 2
101774: PUSH
101775: EMPTY
101776: LIST
101777: LIST
101778: PUSH
101779: LD_INT 21
101781: PUSH
101782: LD_INT 2
101784: PUSH
101785: EMPTY
101786: LIST
101787: LIST
101788: PUSH
101789: LD_INT 2
101791: PUSH
101792: LD_INT 34
101794: PUSH
101795: LD_INT 12
101797: PUSH
101798: EMPTY
101799: LIST
101800: LIST
101801: PUSH
101802: LD_INT 34
101804: PUSH
101805: LD_INT 51
101807: PUSH
101808: EMPTY
101809: LIST
101810: LIST
101811: PUSH
101812: LD_INT 34
101814: PUSH
101815: LD_INT 32
101817: PUSH
101818: EMPTY
101819: LIST
101820: LIST
101821: PUSH
101822: EMPTY
101823: LIST
101824: LIST
101825: LIST
101826: LIST
101827: PUSH
101828: EMPTY
101829: LIST
101830: LIST
101831: LIST
101832: PPUSH
101833: CALL_OW 69
101837: ST_TO_ADDR
// if not tmp then
101838: LD_VAR 0 2
101842: NOT
101843: IFFALSE 101847
// exit ;
101845: GO 101897
// for i in tmp do
101847: LD_ADDR_VAR 0 1
101851: PUSH
101852: LD_VAR 0 2
101856: PUSH
101857: FOR_IN
101858: IFFALSE 101895
// if GetCargo ( i , mat_artifact ) = 0 then
101860: LD_VAR 0 1
101864: PPUSH
101865: LD_INT 4
101867: PPUSH
101868: CALL_OW 289
101872: PUSH
101873: LD_INT 0
101875: EQUAL
101876: IFFALSE 101893
// SetCargo ( i , mat_siberit , 100 ) ;
101878: LD_VAR 0 1
101882: PPUSH
101883: LD_INT 3
101885: PPUSH
101886: LD_INT 100
101888: PPUSH
101889: CALL_OW 290
101893: GO 101857
101895: POP
101896: POP
// end ;
101897: PPOPN 2
101899: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101900: LD_EXP 96
101904: PUSH
101905: LD_EXP 141
101909: AND
101910: IFFALSE 102093
101912: GO 101914
101914: DISABLE
101915: LD_INT 0
101917: PPUSH
101918: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101919: LD_ADDR_VAR 0 2
101923: PUSH
101924: LD_INT 22
101926: PUSH
101927: LD_OWVAR 2
101931: PUSH
101932: EMPTY
101933: LIST
101934: LIST
101935: PPUSH
101936: CALL_OW 69
101940: ST_TO_ADDR
// if not tmp then
101941: LD_VAR 0 2
101945: NOT
101946: IFFALSE 101950
// exit ;
101948: GO 102093
// for i := 1 to 2 do
101950: LD_ADDR_VAR 0 1
101954: PUSH
101955: DOUBLE
101956: LD_INT 1
101958: DEC
101959: ST_TO_ADDR
101960: LD_INT 2
101962: PUSH
101963: FOR_TO
101964: IFFALSE 102091
// begin uc_side := your_side ;
101966: LD_ADDR_OWVAR 20
101970: PUSH
101971: LD_OWVAR 2
101975: ST_TO_ADDR
// uc_nation := nation_american ;
101976: LD_ADDR_OWVAR 21
101980: PUSH
101981: LD_INT 1
101983: ST_TO_ADDR
// vc_chassis := us_morphling ;
101984: LD_ADDR_OWVAR 37
101988: PUSH
101989: LD_INT 5
101991: ST_TO_ADDR
// vc_engine := engine_siberite ;
101992: LD_ADDR_OWVAR 39
101996: PUSH
101997: LD_INT 3
101999: ST_TO_ADDR
// vc_control := control_computer ;
102000: LD_ADDR_OWVAR 38
102004: PUSH
102005: LD_INT 3
102007: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102008: LD_ADDR_OWVAR 40
102012: PUSH
102013: LD_INT 10
102015: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102016: LD_VAR 0 2
102020: PUSH
102021: LD_INT 1
102023: ARRAY
102024: PPUSH
102025: CALL_OW 310
102029: NOT
102030: IFFALSE 102077
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102032: CALL_OW 45
102036: PPUSH
102037: LD_VAR 0 2
102041: PUSH
102042: LD_INT 1
102044: ARRAY
102045: PPUSH
102046: CALL_OW 250
102050: PPUSH
102051: LD_VAR 0 2
102055: PUSH
102056: LD_INT 1
102058: ARRAY
102059: PPUSH
102060: CALL_OW 251
102064: PPUSH
102065: LD_INT 12
102067: PPUSH
102068: LD_INT 1
102070: PPUSH
102071: CALL_OW 50
102075: GO 102089
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102077: CALL_OW 45
102081: PPUSH
102082: LD_INT 1
102084: PPUSH
102085: CALL_OW 51
// end ;
102089: GO 101963
102091: POP
102092: POP
// end ;
102093: PPOPN 2
102095: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102096: LD_EXP 96
102100: PUSH
102101: LD_EXP 142
102105: AND
102106: IFFALSE 102328
102108: GO 102110
102110: DISABLE
102111: LD_INT 0
102113: PPUSH
102114: PPUSH
102115: PPUSH
102116: PPUSH
102117: PPUSH
102118: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102119: LD_ADDR_VAR 0 6
102123: PUSH
102124: LD_INT 22
102126: PUSH
102127: LD_OWVAR 2
102131: PUSH
102132: EMPTY
102133: LIST
102134: LIST
102135: PUSH
102136: LD_INT 21
102138: PUSH
102139: LD_INT 1
102141: PUSH
102142: EMPTY
102143: LIST
102144: LIST
102145: PUSH
102146: LD_INT 3
102148: PUSH
102149: LD_INT 23
102151: PUSH
102152: LD_INT 0
102154: PUSH
102155: EMPTY
102156: LIST
102157: LIST
102158: PUSH
102159: EMPTY
102160: LIST
102161: LIST
102162: PUSH
102163: EMPTY
102164: LIST
102165: LIST
102166: LIST
102167: PPUSH
102168: CALL_OW 69
102172: ST_TO_ADDR
// if not tmp then
102173: LD_VAR 0 6
102177: NOT
102178: IFFALSE 102182
// exit ;
102180: GO 102328
// s1 := rand ( 1 , 4 ) ;
102182: LD_ADDR_VAR 0 2
102186: PUSH
102187: LD_INT 1
102189: PPUSH
102190: LD_INT 4
102192: PPUSH
102193: CALL_OW 12
102197: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102198: LD_ADDR_VAR 0 4
102202: PUSH
102203: LD_VAR 0 6
102207: PUSH
102208: LD_INT 1
102210: ARRAY
102211: PPUSH
102212: LD_VAR 0 2
102216: PPUSH
102217: CALL_OW 259
102221: ST_TO_ADDR
// if s1 = 1 then
102222: LD_VAR 0 2
102226: PUSH
102227: LD_INT 1
102229: EQUAL
102230: IFFALSE 102250
// s2 := rand ( 2 , 4 ) else
102232: LD_ADDR_VAR 0 3
102236: PUSH
102237: LD_INT 2
102239: PPUSH
102240: LD_INT 4
102242: PPUSH
102243: CALL_OW 12
102247: ST_TO_ADDR
102248: GO 102258
// s2 := 1 ;
102250: LD_ADDR_VAR 0 3
102254: PUSH
102255: LD_INT 1
102257: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102258: LD_ADDR_VAR 0 5
102262: PUSH
102263: LD_VAR 0 6
102267: PUSH
102268: LD_INT 1
102270: ARRAY
102271: PPUSH
102272: LD_VAR 0 3
102276: PPUSH
102277: CALL_OW 259
102281: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102282: LD_VAR 0 6
102286: PUSH
102287: LD_INT 1
102289: ARRAY
102290: PPUSH
102291: LD_VAR 0 2
102295: PPUSH
102296: LD_VAR 0 5
102300: PPUSH
102301: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102305: LD_VAR 0 6
102309: PUSH
102310: LD_INT 1
102312: ARRAY
102313: PPUSH
102314: LD_VAR 0 3
102318: PPUSH
102319: LD_VAR 0 4
102323: PPUSH
102324: CALL_OW 237
// end ;
102328: PPOPN 6
102330: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102331: LD_EXP 96
102335: PUSH
102336: LD_EXP 143
102340: AND
102341: IFFALSE 102420
102343: GO 102345
102345: DISABLE
102346: LD_INT 0
102348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102349: LD_ADDR_VAR 0 1
102353: PUSH
102354: LD_INT 22
102356: PUSH
102357: LD_OWVAR 2
102361: PUSH
102362: EMPTY
102363: LIST
102364: LIST
102365: PUSH
102366: LD_INT 30
102368: PUSH
102369: LD_INT 3
102371: PUSH
102372: EMPTY
102373: LIST
102374: LIST
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: PPUSH
102380: CALL_OW 69
102384: ST_TO_ADDR
// if not tmp then
102385: LD_VAR 0 1
102389: NOT
102390: IFFALSE 102394
// exit ;
102392: GO 102420
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102394: LD_VAR 0 1
102398: PUSH
102399: LD_INT 1
102401: PPUSH
102402: LD_VAR 0 1
102406: PPUSH
102407: CALL_OW 12
102411: ARRAY
102412: PPUSH
102413: LD_INT 1
102415: PPUSH
102416: CALL_OW 234
// end ;
102420: PPOPN 1
102422: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102423: LD_EXP 96
102427: PUSH
102428: LD_EXP 144
102432: AND
102433: IFFALSE 102545
102435: GO 102437
102437: DISABLE
102438: LD_INT 0
102440: PPUSH
102441: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102442: LD_ADDR_VAR 0 2
102446: PUSH
102447: LD_INT 22
102449: PUSH
102450: LD_OWVAR 2
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: PUSH
102459: LD_INT 2
102461: PUSH
102462: LD_INT 30
102464: PUSH
102465: LD_INT 27
102467: PUSH
102468: EMPTY
102469: LIST
102470: LIST
102471: PUSH
102472: LD_INT 30
102474: PUSH
102475: LD_INT 26
102477: PUSH
102478: EMPTY
102479: LIST
102480: LIST
102481: PUSH
102482: LD_INT 30
102484: PUSH
102485: LD_INT 28
102487: PUSH
102488: EMPTY
102489: LIST
102490: LIST
102491: PUSH
102492: EMPTY
102493: LIST
102494: LIST
102495: LIST
102496: LIST
102497: PUSH
102498: EMPTY
102499: LIST
102500: LIST
102501: PPUSH
102502: CALL_OW 69
102506: ST_TO_ADDR
// if not tmp then
102507: LD_VAR 0 2
102511: NOT
102512: IFFALSE 102516
// exit ;
102514: GO 102545
// for i in tmp do
102516: LD_ADDR_VAR 0 1
102520: PUSH
102521: LD_VAR 0 2
102525: PUSH
102526: FOR_IN
102527: IFFALSE 102543
// SetLives ( i , 1 ) ;
102529: LD_VAR 0 1
102533: PPUSH
102534: LD_INT 1
102536: PPUSH
102537: CALL_OW 234
102541: GO 102526
102543: POP
102544: POP
// end ;
102545: PPOPN 2
102547: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102548: LD_EXP 96
102552: PUSH
102553: LD_EXP 145
102557: AND
102558: IFFALSE 102845
102560: GO 102562
102562: DISABLE
102563: LD_INT 0
102565: PPUSH
102566: PPUSH
102567: PPUSH
// begin i := rand ( 1 , 7 ) ;
102568: LD_ADDR_VAR 0 1
102572: PUSH
102573: LD_INT 1
102575: PPUSH
102576: LD_INT 7
102578: PPUSH
102579: CALL_OW 12
102583: ST_TO_ADDR
// case i of 1 :
102584: LD_VAR 0 1
102588: PUSH
102589: LD_INT 1
102591: DOUBLE
102592: EQUAL
102593: IFTRUE 102597
102595: GO 102607
102597: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102598: LD_STRING earthquake(getX(game), 0, 32)
102600: PPUSH
102601: CALL_OW 559
102605: GO 102845
102607: LD_INT 2
102609: DOUBLE
102610: EQUAL
102611: IFTRUE 102615
102613: GO 102629
102615: POP
// begin ToLua ( displayStucuk(); ) ;
102616: LD_STRING displayStucuk();
102618: PPUSH
102619: CALL_OW 559
// ResetFog ;
102623: CALL_OW 335
// end ; 3 :
102627: GO 102845
102629: LD_INT 3
102631: DOUBLE
102632: EQUAL
102633: IFTRUE 102637
102635: GO 102741
102637: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102638: LD_ADDR_VAR 0 2
102642: PUSH
102643: LD_INT 22
102645: PUSH
102646: LD_OWVAR 2
102650: PUSH
102651: EMPTY
102652: LIST
102653: LIST
102654: PUSH
102655: LD_INT 25
102657: PUSH
102658: LD_INT 1
102660: PUSH
102661: EMPTY
102662: LIST
102663: LIST
102664: PUSH
102665: EMPTY
102666: LIST
102667: LIST
102668: PPUSH
102669: CALL_OW 69
102673: ST_TO_ADDR
// if not tmp then
102674: LD_VAR 0 2
102678: NOT
102679: IFFALSE 102683
// exit ;
102681: GO 102845
// un := tmp [ rand ( 1 , tmp ) ] ;
102683: LD_ADDR_VAR 0 3
102687: PUSH
102688: LD_VAR 0 2
102692: PUSH
102693: LD_INT 1
102695: PPUSH
102696: LD_VAR 0 2
102700: PPUSH
102701: CALL_OW 12
102705: ARRAY
102706: ST_TO_ADDR
// if Crawls ( un ) then
102707: LD_VAR 0 3
102711: PPUSH
102712: CALL_OW 318
102716: IFFALSE 102727
// ComWalk ( un ) ;
102718: LD_VAR 0 3
102722: PPUSH
102723: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102727: LD_VAR 0 3
102731: PPUSH
102732: LD_INT 8
102734: PPUSH
102735: CALL_OW 336
// end ; 4 :
102739: GO 102845
102741: LD_INT 4
102743: DOUBLE
102744: EQUAL
102745: IFTRUE 102749
102747: GO 102823
102749: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102750: LD_ADDR_VAR 0 2
102754: PUSH
102755: LD_INT 22
102757: PUSH
102758: LD_OWVAR 2
102762: PUSH
102763: EMPTY
102764: LIST
102765: LIST
102766: PUSH
102767: LD_INT 30
102769: PUSH
102770: LD_INT 29
102772: PUSH
102773: EMPTY
102774: LIST
102775: LIST
102776: PUSH
102777: EMPTY
102778: LIST
102779: LIST
102780: PPUSH
102781: CALL_OW 69
102785: ST_TO_ADDR
// if not tmp then
102786: LD_VAR 0 2
102790: NOT
102791: IFFALSE 102795
// exit ;
102793: GO 102845
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102795: LD_VAR 0 2
102799: PUSH
102800: LD_INT 1
102802: ARRAY
102803: PPUSH
102804: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102808: LD_VAR 0 2
102812: PUSH
102813: LD_INT 1
102815: ARRAY
102816: PPUSH
102817: CALL_OW 65
// end ; 5 .. 7 :
102821: GO 102845
102823: LD_INT 5
102825: DOUBLE
102826: GREATEREQUAL
102827: IFFALSE 102835
102829: LD_INT 7
102831: DOUBLE
102832: LESSEQUAL
102833: IFTRUE 102837
102835: GO 102844
102837: POP
// StreamSibBomb ; end ;
102838: CALL 99082 0 0
102842: GO 102845
102844: POP
// end ;
102845: PPOPN 3
102847: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102848: LD_EXP 96
102852: PUSH
102853: LD_EXP 146
102857: AND
102858: IFFALSE 103014
102860: GO 102862
102862: DISABLE
102863: LD_INT 0
102865: PPUSH
102866: PPUSH
102867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102868: LD_ADDR_VAR 0 2
102872: PUSH
102873: LD_INT 81
102875: PUSH
102876: LD_OWVAR 2
102880: PUSH
102881: EMPTY
102882: LIST
102883: LIST
102884: PUSH
102885: LD_INT 2
102887: PUSH
102888: LD_INT 21
102890: PUSH
102891: LD_INT 1
102893: PUSH
102894: EMPTY
102895: LIST
102896: LIST
102897: PUSH
102898: LD_INT 21
102900: PUSH
102901: LD_INT 2
102903: PUSH
102904: EMPTY
102905: LIST
102906: LIST
102907: PUSH
102908: EMPTY
102909: LIST
102910: LIST
102911: LIST
102912: PUSH
102913: EMPTY
102914: LIST
102915: LIST
102916: PPUSH
102917: CALL_OW 69
102921: ST_TO_ADDR
// if not tmp then
102922: LD_VAR 0 2
102926: NOT
102927: IFFALSE 102931
// exit ;
102929: GO 103014
// p := 0 ;
102931: LD_ADDR_VAR 0 3
102935: PUSH
102936: LD_INT 0
102938: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102939: LD_INT 35
102941: PPUSH
102942: CALL_OW 67
// p := p + 1 ;
102946: LD_ADDR_VAR 0 3
102950: PUSH
102951: LD_VAR 0 3
102955: PUSH
102956: LD_INT 1
102958: PLUS
102959: ST_TO_ADDR
// for i in tmp do
102960: LD_ADDR_VAR 0 1
102964: PUSH
102965: LD_VAR 0 2
102969: PUSH
102970: FOR_IN
102971: IFFALSE 103002
// if GetLives ( i ) < 1000 then
102973: LD_VAR 0 1
102977: PPUSH
102978: CALL_OW 256
102982: PUSH
102983: LD_INT 1000
102985: LESS
102986: IFFALSE 103000
// SetLives ( i , 1000 ) ;
102988: LD_VAR 0 1
102992: PPUSH
102993: LD_INT 1000
102995: PPUSH
102996: CALL_OW 234
103000: GO 102970
103002: POP
103003: POP
// until p > 20 ;
103004: LD_VAR 0 3
103008: PUSH
103009: LD_INT 20
103011: GREATER
103012: IFFALSE 102939
// end ;
103014: PPOPN 3
103016: END
// every 0 0$1 trigger StreamModeActive and sTime do
103017: LD_EXP 96
103021: PUSH
103022: LD_EXP 147
103026: AND
103027: IFFALSE 103062
103029: GO 103031
103031: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103032: LD_INT 28
103034: PPUSH
103035: LD_OWVAR 2
103039: PPUSH
103040: LD_INT 2
103042: PPUSH
103043: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103047: LD_INT 30
103049: PPUSH
103050: LD_OWVAR 2
103054: PPUSH
103055: LD_INT 2
103057: PPUSH
103058: CALL_OW 322
// end ;
103062: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103063: LD_EXP 96
103067: PUSH
103068: LD_EXP 148
103072: AND
103073: IFFALSE 103194
103075: GO 103077
103077: DISABLE
103078: LD_INT 0
103080: PPUSH
103081: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103082: LD_ADDR_VAR 0 2
103086: PUSH
103087: LD_INT 22
103089: PUSH
103090: LD_OWVAR 2
103094: PUSH
103095: EMPTY
103096: LIST
103097: LIST
103098: PUSH
103099: LD_INT 21
103101: PUSH
103102: LD_INT 1
103104: PUSH
103105: EMPTY
103106: LIST
103107: LIST
103108: PUSH
103109: LD_INT 3
103111: PUSH
103112: LD_INT 23
103114: PUSH
103115: LD_INT 0
103117: PUSH
103118: EMPTY
103119: LIST
103120: LIST
103121: PUSH
103122: EMPTY
103123: LIST
103124: LIST
103125: PUSH
103126: EMPTY
103127: LIST
103128: LIST
103129: LIST
103130: PPUSH
103131: CALL_OW 69
103135: ST_TO_ADDR
// if not tmp then
103136: LD_VAR 0 2
103140: NOT
103141: IFFALSE 103145
// exit ;
103143: GO 103194
// for i in tmp do
103145: LD_ADDR_VAR 0 1
103149: PUSH
103150: LD_VAR 0 2
103154: PUSH
103155: FOR_IN
103156: IFFALSE 103192
// begin if Crawls ( i ) then
103158: LD_VAR 0 1
103162: PPUSH
103163: CALL_OW 318
103167: IFFALSE 103178
// ComWalk ( i ) ;
103169: LD_VAR 0 1
103173: PPUSH
103174: CALL_OW 138
// SetClass ( i , 2 ) ;
103178: LD_VAR 0 1
103182: PPUSH
103183: LD_INT 2
103185: PPUSH
103186: CALL_OW 336
// end ;
103190: GO 103155
103192: POP
103193: POP
// end ;
103194: PPOPN 2
103196: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103197: LD_EXP 96
103201: PUSH
103202: LD_EXP 149
103206: AND
103207: IFFALSE 103495
103209: GO 103211
103211: DISABLE
103212: LD_INT 0
103214: PPUSH
103215: PPUSH
103216: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103217: LD_OWVAR 2
103221: PPUSH
103222: LD_INT 9
103224: PPUSH
103225: LD_INT 1
103227: PPUSH
103228: LD_INT 1
103230: PPUSH
103231: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103235: LD_INT 9
103237: PPUSH
103238: LD_OWVAR 2
103242: PPUSH
103243: CALL_OW 343
// uc_side := 9 ;
103247: LD_ADDR_OWVAR 20
103251: PUSH
103252: LD_INT 9
103254: ST_TO_ADDR
// uc_nation := 2 ;
103255: LD_ADDR_OWVAR 21
103259: PUSH
103260: LD_INT 2
103262: ST_TO_ADDR
// hc_name := Dark Warrior ;
103263: LD_ADDR_OWVAR 26
103267: PUSH
103268: LD_STRING Dark Warrior
103270: ST_TO_ADDR
// hc_gallery :=  ;
103271: LD_ADDR_OWVAR 33
103275: PUSH
103276: LD_STRING 
103278: ST_TO_ADDR
// hc_noskilllimit := true ;
103279: LD_ADDR_OWVAR 76
103283: PUSH
103284: LD_INT 1
103286: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103287: LD_ADDR_OWVAR 31
103291: PUSH
103292: LD_INT 30
103294: PUSH
103295: LD_INT 30
103297: PUSH
103298: LD_INT 30
103300: PUSH
103301: LD_INT 30
103303: PUSH
103304: EMPTY
103305: LIST
103306: LIST
103307: LIST
103308: LIST
103309: ST_TO_ADDR
// un := CreateHuman ;
103310: LD_ADDR_VAR 0 3
103314: PUSH
103315: CALL_OW 44
103319: ST_TO_ADDR
// hc_noskilllimit := false ;
103320: LD_ADDR_OWVAR 76
103324: PUSH
103325: LD_INT 0
103327: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103328: LD_VAR 0 3
103332: PPUSH
103333: LD_INT 1
103335: PPUSH
103336: CALL_OW 51
// ToLua ( playRanger() ) ;
103340: LD_STRING playRanger()
103342: PPUSH
103343: CALL_OW 559
// p := 0 ;
103347: LD_ADDR_VAR 0 2
103351: PUSH
103352: LD_INT 0
103354: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103355: LD_INT 35
103357: PPUSH
103358: CALL_OW 67
// p := p + 1 ;
103362: LD_ADDR_VAR 0 2
103366: PUSH
103367: LD_VAR 0 2
103371: PUSH
103372: LD_INT 1
103374: PLUS
103375: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103376: LD_VAR 0 3
103380: PPUSH
103381: CALL_OW 256
103385: PUSH
103386: LD_INT 1000
103388: LESS
103389: IFFALSE 103403
// SetLives ( un , 1000 ) ;
103391: LD_VAR 0 3
103395: PPUSH
103396: LD_INT 1000
103398: PPUSH
103399: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103403: LD_VAR 0 3
103407: PPUSH
103408: LD_INT 81
103410: PUSH
103411: LD_OWVAR 2
103415: PUSH
103416: EMPTY
103417: LIST
103418: LIST
103419: PUSH
103420: LD_INT 91
103422: PUSH
103423: LD_VAR 0 3
103427: PUSH
103428: LD_INT 30
103430: PUSH
103431: EMPTY
103432: LIST
103433: LIST
103434: LIST
103435: PUSH
103436: EMPTY
103437: LIST
103438: LIST
103439: PPUSH
103440: CALL_OW 69
103444: PPUSH
103445: LD_VAR 0 3
103449: PPUSH
103450: CALL_OW 74
103454: PPUSH
103455: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103459: LD_VAR 0 2
103463: PUSH
103464: LD_INT 80
103466: GREATER
103467: PUSH
103468: LD_VAR 0 3
103472: PPUSH
103473: CALL_OW 301
103477: OR
103478: IFFALSE 103355
// if un then
103480: LD_VAR 0 3
103484: IFFALSE 103495
// RemoveUnit ( un ) ;
103486: LD_VAR 0 3
103490: PPUSH
103491: CALL_OW 64
// end ;
103495: PPOPN 3
103497: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103498: LD_EXP 150
103502: IFFALSE 103618
103504: GO 103506
103506: DISABLE
103507: LD_INT 0
103509: PPUSH
103510: PPUSH
103511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103512: LD_ADDR_VAR 0 2
103516: PUSH
103517: LD_INT 81
103519: PUSH
103520: LD_OWVAR 2
103524: PUSH
103525: EMPTY
103526: LIST
103527: LIST
103528: PUSH
103529: LD_INT 21
103531: PUSH
103532: LD_INT 1
103534: PUSH
103535: EMPTY
103536: LIST
103537: LIST
103538: PUSH
103539: EMPTY
103540: LIST
103541: LIST
103542: PPUSH
103543: CALL_OW 69
103547: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103548: LD_STRING playComputer()
103550: PPUSH
103551: CALL_OW 559
// if not tmp then
103555: LD_VAR 0 2
103559: NOT
103560: IFFALSE 103564
// exit ;
103562: GO 103618
// for i in tmp do
103564: LD_ADDR_VAR 0 1
103568: PUSH
103569: LD_VAR 0 2
103573: PUSH
103574: FOR_IN
103575: IFFALSE 103616
// for j := 1 to 4 do
103577: LD_ADDR_VAR 0 3
103581: PUSH
103582: DOUBLE
103583: LD_INT 1
103585: DEC
103586: ST_TO_ADDR
103587: LD_INT 4
103589: PUSH
103590: FOR_TO
103591: IFFALSE 103612
// SetSkill ( i , j , 10 ) ;
103593: LD_VAR 0 1
103597: PPUSH
103598: LD_VAR 0 3
103602: PPUSH
103603: LD_INT 10
103605: PPUSH
103606: CALL_OW 237
103610: GO 103590
103612: POP
103613: POP
103614: GO 103574
103616: POP
103617: POP
// end ;
103618: PPOPN 3
103620: END
// every 0 0$1 trigger s30 do var i , tmp ;
103621: LD_EXP 151
103625: IFFALSE 103694
103627: GO 103629
103629: DISABLE
103630: LD_INT 0
103632: PPUSH
103633: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103634: LD_ADDR_VAR 0 2
103638: PUSH
103639: LD_INT 22
103641: PUSH
103642: LD_OWVAR 2
103646: PUSH
103647: EMPTY
103648: LIST
103649: LIST
103650: PPUSH
103651: CALL_OW 69
103655: ST_TO_ADDR
// if not tmp then
103656: LD_VAR 0 2
103660: NOT
103661: IFFALSE 103665
// exit ;
103663: GO 103694
// for i in tmp do
103665: LD_ADDR_VAR 0 1
103669: PUSH
103670: LD_VAR 0 2
103674: PUSH
103675: FOR_IN
103676: IFFALSE 103692
// SetLives ( i , 300 ) ;
103678: LD_VAR 0 1
103682: PPUSH
103683: LD_INT 300
103685: PPUSH
103686: CALL_OW 234
103690: GO 103675
103692: POP
103693: POP
// end ;
103694: PPOPN 2
103696: END
// every 0 0$1 trigger s60 do var i , tmp ;
103697: LD_EXP 152
103701: IFFALSE 103770
103703: GO 103705
103705: DISABLE
103706: LD_INT 0
103708: PPUSH
103709: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103710: LD_ADDR_VAR 0 2
103714: PUSH
103715: LD_INT 22
103717: PUSH
103718: LD_OWVAR 2
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: PPUSH
103727: CALL_OW 69
103731: ST_TO_ADDR
// if not tmp then
103732: LD_VAR 0 2
103736: NOT
103737: IFFALSE 103741
// exit ;
103739: GO 103770
// for i in tmp do
103741: LD_ADDR_VAR 0 1
103745: PUSH
103746: LD_VAR 0 2
103750: PUSH
103751: FOR_IN
103752: IFFALSE 103768
// SetLives ( i , 600 ) ;
103754: LD_VAR 0 1
103758: PPUSH
103759: LD_INT 600
103761: PPUSH
103762: CALL_OW 234
103766: GO 103751
103768: POP
103769: POP
// end ;
103770: PPOPN 2
103772: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103773: LD_INT 0
103775: PPUSH
// case cmd of 301 :
103776: LD_VAR 0 1
103780: PUSH
103781: LD_INT 301
103783: DOUBLE
103784: EQUAL
103785: IFTRUE 103789
103787: GO 103821
103789: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103790: LD_VAR 0 6
103794: PPUSH
103795: LD_VAR 0 7
103799: PPUSH
103800: LD_VAR 0 8
103804: PPUSH
103805: LD_VAR 0 4
103809: PPUSH
103810: LD_VAR 0 5
103814: PPUSH
103815: CALL 105030 0 5
103819: GO 103942
103821: LD_INT 302
103823: DOUBLE
103824: EQUAL
103825: IFTRUE 103829
103827: GO 103866
103829: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103830: LD_VAR 0 6
103834: PPUSH
103835: LD_VAR 0 7
103839: PPUSH
103840: LD_VAR 0 8
103844: PPUSH
103845: LD_VAR 0 9
103849: PPUSH
103850: LD_VAR 0 4
103854: PPUSH
103855: LD_VAR 0 5
103859: PPUSH
103860: CALL 105121 0 6
103864: GO 103942
103866: LD_INT 303
103868: DOUBLE
103869: EQUAL
103870: IFTRUE 103874
103872: GO 103911
103874: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103875: LD_VAR 0 6
103879: PPUSH
103880: LD_VAR 0 7
103884: PPUSH
103885: LD_VAR 0 8
103889: PPUSH
103890: LD_VAR 0 9
103894: PPUSH
103895: LD_VAR 0 4
103899: PPUSH
103900: LD_VAR 0 5
103904: PPUSH
103905: CALL 103947 0 6
103909: GO 103942
103911: LD_INT 304
103913: DOUBLE
103914: EQUAL
103915: IFTRUE 103919
103917: GO 103941
103919: POP
// hHackTeleport ( unit , x , y ) ; end ;
103920: LD_VAR 0 2
103924: PPUSH
103925: LD_VAR 0 4
103929: PPUSH
103930: LD_VAR 0 5
103934: PPUSH
103935: CALL 105714 0 3
103939: GO 103942
103941: POP
// end ;
103942: LD_VAR 0 12
103946: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103947: LD_INT 0
103949: PPUSH
103950: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103951: LD_VAR 0 1
103955: PUSH
103956: LD_INT 1
103958: LESS
103959: PUSH
103960: LD_VAR 0 1
103964: PUSH
103965: LD_INT 3
103967: GREATER
103968: OR
103969: PUSH
103970: LD_VAR 0 5
103974: PPUSH
103975: LD_VAR 0 6
103979: PPUSH
103980: CALL_OW 428
103984: OR
103985: IFFALSE 103989
// exit ;
103987: GO 104717
// uc_side := your_side ;
103989: LD_ADDR_OWVAR 20
103993: PUSH
103994: LD_OWVAR 2
103998: ST_TO_ADDR
// uc_nation := nation ;
103999: LD_ADDR_OWVAR 21
104003: PUSH
104004: LD_VAR 0 1
104008: ST_TO_ADDR
// bc_level = 1 ;
104009: LD_ADDR_OWVAR 43
104013: PUSH
104014: LD_INT 1
104016: ST_TO_ADDR
// case btype of 1 :
104017: LD_VAR 0 2
104021: PUSH
104022: LD_INT 1
104024: DOUBLE
104025: EQUAL
104026: IFTRUE 104030
104028: GO 104041
104030: POP
// bc_type := b_depot ; 2 :
104031: LD_ADDR_OWVAR 42
104035: PUSH
104036: LD_INT 0
104038: ST_TO_ADDR
104039: GO 104661
104041: LD_INT 2
104043: DOUBLE
104044: EQUAL
104045: IFTRUE 104049
104047: GO 104060
104049: POP
// bc_type := b_warehouse ; 3 :
104050: LD_ADDR_OWVAR 42
104054: PUSH
104055: LD_INT 1
104057: ST_TO_ADDR
104058: GO 104661
104060: LD_INT 3
104062: DOUBLE
104063: EQUAL
104064: IFTRUE 104068
104066: GO 104079
104068: POP
// bc_type := b_lab ; 4 .. 9 :
104069: LD_ADDR_OWVAR 42
104073: PUSH
104074: LD_INT 6
104076: ST_TO_ADDR
104077: GO 104661
104079: LD_INT 4
104081: DOUBLE
104082: GREATEREQUAL
104083: IFFALSE 104091
104085: LD_INT 9
104087: DOUBLE
104088: LESSEQUAL
104089: IFTRUE 104093
104091: GO 104153
104093: POP
// begin bc_type := b_lab_half ;
104094: LD_ADDR_OWVAR 42
104098: PUSH
104099: LD_INT 7
104101: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104102: LD_ADDR_OWVAR 44
104106: PUSH
104107: LD_INT 10
104109: PUSH
104110: LD_INT 11
104112: PUSH
104113: LD_INT 12
104115: PUSH
104116: LD_INT 15
104118: PUSH
104119: LD_INT 14
104121: PUSH
104122: LD_INT 13
104124: PUSH
104125: EMPTY
104126: LIST
104127: LIST
104128: LIST
104129: LIST
104130: LIST
104131: LIST
104132: PUSH
104133: LD_VAR 0 2
104137: PUSH
104138: LD_INT 3
104140: MINUS
104141: ARRAY
104142: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104143: LD_ADDR_OWVAR 45
104147: PUSH
104148: LD_INT 9
104150: ST_TO_ADDR
// end ; 10 .. 13 :
104151: GO 104661
104153: LD_INT 10
104155: DOUBLE
104156: GREATEREQUAL
104157: IFFALSE 104165
104159: LD_INT 13
104161: DOUBLE
104162: LESSEQUAL
104163: IFTRUE 104167
104165: GO 104244
104167: POP
// begin bc_type := b_lab_full ;
104168: LD_ADDR_OWVAR 42
104172: PUSH
104173: LD_INT 8
104175: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104176: LD_ADDR_OWVAR 44
104180: PUSH
104181: LD_INT 10
104183: PUSH
104184: LD_INT 12
104186: PUSH
104187: LD_INT 14
104189: PUSH
104190: LD_INT 13
104192: PUSH
104193: EMPTY
104194: LIST
104195: LIST
104196: LIST
104197: LIST
104198: PUSH
104199: LD_VAR 0 2
104203: PUSH
104204: LD_INT 9
104206: MINUS
104207: ARRAY
104208: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104209: LD_ADDR_OWVAR 45
104213: PUSH
104214: LD_INT 11
104216: PUSH
104217: LD_INT 15
104219: PUSH
104220: LD_INT 12
104222: PUSH
104223: LD_INT 15
104225: PUSH
104226: EMPTY
104227: LIST
104228: LIST
104229: LIST
104230: LIST
104231: PUSH
104232: LD_VAR 0 2
104236: PUSH
104237: LD_INT 9
104239: MINUS
104240: ARRAY
104241: ST_TO_ADDR
// end ; 14 :
104242: GO 104661
104244: LD_INT 14
104246: DOUBLE
104247: EQUAL
104248: IFTRUE 104252
104250: GO 104263
104252: POP
// bc_type := b_workshop ; 15 :
104253: LD_ADDR_OWVAR 42
104257: PUSH
104258: LD_INT 2
104260: ST_TO_ADDR
104261: GO 104661
104263: LD_INT 15
104265: DOUBLE
104266: EQUAL
104267: IFTRUE 104271
104269: GO 104282
104271: POP
// bc_type := b_factory ; 16 :
104272: LD_ADDR_OWVAR 42
104276: PUSH
104277: LD_INT 3
104279: ST_TO_ADDR
104280: GO 104661
104282: LD_INT 16
104284: DOUBLE
104285: EQUAL
104286: IFTRUE 104290
104288: GO 104301
104290: POP
// bc_type := b_ext_gun ; 17 :
104291: LD_ADDR_OWVAR 42
104295: PUSH
104296: LD_INT 17
104298: ST_TO_ADDR
104299: GO 104661
104301: LD_INT 17
104303: DOUBLE
104304: EQUAL
104305: IFTRUE 104309
104307: GO 104337
104309: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104310: LD_ADDR_OWVAR 42
104314: PUSH
104315: LD_INT 19
104317: PUSH
104318: LD_INT 23
104320: PUSH
104321: LD_INT 19
104323: PUSH
104324: EMPTY
104325: LIST
104326: LIST
104327: LIST
104328: PUSH
104329: LD_VAR 0 1
104333: ARRAY
104334: ST_TO_ADDR
104335: GO 104661
104337: LD_INT 18
104339: DOUBLE
104340: EQUAL
104341: IFTRUE 104345
104343: GO 104356
104345: POP
// bc_type := b_ext_radar ; 19 :
104346: LD_ADDR_OWVAR 42
104350: PUSH
104351: LD_INT 20
104353: ST_TO_ADDR
104354: GO 104661
104356: LD_INT 19
104358: DOUBLE
104359: EQUAL
104360: IFTRUE 104364
104362: GO 104375
104364: POP
// bc_type := b_ext_radio ; 20 :
104365: LD_ADDR_OWVAR 42
104369: PUSH
104370: LD_INT 22
104372: ST_TO_ADDR
104373: GO 104661
104375: LD_INT 20
104377: DOUBLE
104378: EQUAL
104379: IFTRUE 104383
104381: GO 104394
104383: POP
// bc_type := b_ext_siberium ; 21 :
104384: LD_ADDR_OWVAR 42
104388: PUSH
104389: LD_INT 21
104391: ST_TO_ADDR
104392: GO 104661
104394: LD_INT 21
104396: DOUBLE
104397: EQUAL
104398: IFTRUE 104402
104400: GO 104413
104402: POP
// bc_type := b_ext_computer ; 22 :
104403: LD_ADDR_OWVAR 42
104407: PUSH
104408: LD_INT 24
104410: ST_TO_ADDR
104411: GO 104661
104413: LD_INT 22
104415: DOUBLE
104416: EQUAL
104417: IFTRUE 104421
104419: GO 104432
104421: POP
// bc_type := b_ext_track ; 23 :
104422: LD_ADDR_OWVAR 42
104426: PUSH
104427: LD_INT 16
104429: ST_TO_ADDR
104430: GO 104661
104432: LD_INT 23
104434: DOUBLE
104435: EQUAL
104436: IFTRUE 104440
104438: GO 104451
104440: POP
// bc_type := b_ext_laser ; 24 :
104441: LD_ADDR_OWVAR 42
104445: PUSH
104446: LD_INT 25
104448: ST_TO_ADDR
104449: GO 104661
104451: LD_INT 24
104453: DOUBLE
104454: EQUAL
104455: IFTRUE 104459
104457: GO 104470
104459: POP
// bc_type := b_control_tower ; 25 :
104460: LD_ADDR_OWVAR 42
104464: PUSH
104465: LD_INT 36
104467: ST_TO_ADDR
104468: GO 104661
104470: LD_INT 25
104472: DOUBLE
104473: EQUAL
104474: IFTRUE 104478
104476: GO 104489
104478: POP
// bc_type := b_breastwork ; 26 :
104479: LD_ADDR_OWVAR 42
104483: PUSH
104484: LD_INT 31
104486: ST_TO_ADDR
104487: GO 104661
104489: LD_INT 26
104491: DOUBLE
104492: EQUAL
104493: IFTRUE 104497
104495: GO 104508
104497: POP
// bc_type := b_bunker ; 27 :
104498: LD_ADDR_OWVAR 42
104502: PUSH
104503: LD_INT 32
104505: ST_TO_ADDR
104506: GO 104661
104508: LD_INT 27
104510: DOUBLE
104511: EQUAL
104512: IFTRUE 104516
104514: GO 104527
104516: POP
// bc_type := b_turret ; 28 :
104517: LD_ADDR_OWVAR 42
104521: PUSH
104522: LD_INT 33
104524: ST_TO_ADDR
104525: GO 104661
104527: LD_INT 28
104529: DOUBLE
104530: EQUAL
104531: IFTRUE 104535
104533: GO 104546
104535: POP
// bc_type := b_armoury ; 29 :
104536: LD_ADDR_OWVAR 42
104540: PUSH
104541: LD_INT 4
104543: ST_TO_ADDR
104544: GO 104661
104546: LD_INT 29
104548: DOUBLE
104549: EQUAL
104550: IFTRUE 104554
104552: GO 104565
104554: POP
// bc_type := b_barracks ; 30 :
104555: LD_ADDR_OWVAR 42
104559: PUSH
104560: LD_INT 5
104562: ST_TO_ADDR
104563: GO 104661
104565: LD_INT 30
104567: DOUBLE
104568: EQUAL
104569: IFTRUE 104573
104571: GO 104584
104573: POP
// bc_type := b_solar_power ; 31 :
104574: LD_ADDR_OWVAR 42
104578: PUSH
104579: LD_INT 27
104581: ST_TO_ADDR
104582: GO 104661
104584: LD_INT 31
104586: DOUBLE
104587: EQUAL
104588: IFTRUE 104592
104590: GO 104603
104592: POP
// bc_type := b_oil_power ; 32 :
104593: LD_ADDR_OWVAR 42
104597: PUSH
104598: LD_INT 26
104600: ST_TO_ADDR
104601: GO 104661
104603: LD_INT 32
104605: DOUBLE
104606: EQUAL
104607: IFTRUE 104611
104609: GO 104622
104611: POP
// bc_type := b_siberite_power ; 33 :
104612: LD_ADDR_OWVAR 42
104616: PUSH
104617: LD_INT 28
104619: ST_TO_ADDR
104620: GO 104661
104622: LD_INT 33
104624: DOUBLE
104625: EQUAL
104626: IFTRUE 104630
104628: GO 104641
104630: POP
// bc_type := b_oil_mine ; 34 :
104631: LD_ADDR_OWVAR 42
104635: PUSH
104636: LD_INT 29
104638: ST_TO_ADDR
104639: GO 104661
104641: LD_INT 34
104643: DOUBLE
104644: EQUAL
104645: IFTRUE 104649
104647: GO 104660
104649: POP
// bc_type := b_siberite_mine ; end ;
104650: LD_ADDR_OWVAR 42
104654: PUSH
104655: LD_INT 30
104657: ST_TO_ADDR
104658: GO 104661
104660: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104661: LD_ADDR_VAR 0 8
104665: PUSH
104666: LD_VAR 0 5
104670: PPUSH
104671: LD_VAR 0 6
104675: PPUSH
104676: LD_VAR 0 3
104680: PPUSH
104681: CALL_OW 47
104685: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104686: LD_OWVAR 42
104690: PUSH
104691: LD_INT 32
104693: PUSH
104694: LD_INT 33
104696: PUSH
104697: EMPTY
104698: LIST
104699: LIST
104700: IN
104701: IFFALSE 104717
// PlaceWeaponTurret ( b , weapon ) ;
104703: LD_VAR 0 8
104707: PPUSH
104708: LD_VAR 0 4
104712: PPUSH
104713: CALL_OW 431
// end ;
104717: LD_VAR 0 7
104721: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104722: LD_INT 0
104724: PPUSH
104725: PPUSH
104726: PPUSH
104727: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104728: LD_ADDR_VAR 0 4
104732: PUSH
104733: LD_INT 22
104735: PUSH
104736: LD_OWVAR 2
104740: PUSH
104741: EMPTY
104742: LIST
104743: LIST
104744: PUSH
104745: LD_INT 2
104747: PUSH
104748: LD_INT 30
104750: PUSH
104751: LD_INT 0
104753: PUSH
104754: EMPTY
104755: LIST
104756: LIST
104757: PUSH
104758: LD_INT 30
104760: PUSH
104761: LD_INT 1
104763: PUSH
104764: EMPTY
104765: LIST
104766: LIST
104767: PUSH
104768: EMPTY
104769: LIST
104770: LIST
104771: LIST
104772: PUSH
104773: EMPTY
104774: LIST
104775: LIST
104776: PPUSH
104777: CALL_OW 69
104781: ST_TO_ADDR
// if not tmp then
104782: LD_VAR 0 4
104786: NOT
104787: IFFALSE 104791
// exit ;
104789: GO 104850
// for i in tmp do
104791: LD_ADDR_VAR 0 2
104795: PUSH
104796: LD_VAR 0 4
104800: PUSH
104801: FOR_IN
104802: IFFALSE 104848
// for j = 1 to 3 do
104804: LD_ADDR_VAR 0 3
104808: PUSH
104809: DOUBLE
104810: LD_INT 1
104812: DEC
104813: ST_TO_ADDR
104814: LD_INT 3
104816: PUSH
104817: FOR_TO
104818: IFFALSE 104844
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104820: LD_VAR 0 2
104824: PPUSH
104825: CALL_OW 274
104829: PPUSH
104830: LD_VAR 0 3
104834: PPUSH
104835: LD_INT 99999
104837: PPUSH
104838: CALL_OW 277
104842: GO 104817
104844: POP
104845: POP
104846: GO 104801
104848: POP
104849: POP
// end ;
104850: LD_VAR 0 1
104854: RET
// export function hHackSetLevel10 ; var i , j ; begin
104855: LD_INT 0
104857: PPUSH
104858: PPUSH
104859: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104860: LD_ADDR_VAR 0 2
104864: PUSH
104865: LD_INT 21
104867: PUSH
104868: LD_INT 1
104870: PUSH
104871: EMPTY
104872: LIST
104873: LIST
104874: PPUSH
104875: CALL_OW 69
104879: PUSH
104880: FOR_IN
104881: IFFALSE 104933
// if IsSelected ( i ) then
104883: LD_VAR 0 2
104887: PPUSH
104888: CALL_OW 306
104892: IFFALSE 104931
// begin for j := 1 to 4 do
104894: LD_ADDR_VAR 0 3
104898: PUSH
104899: DOUBLE
104900: LD_INT 1
104902: DEC
104903: ST_TO_ADDR
104904: LD_INT 4
104906: PUSH
104907: FOR_TO
104908: IFFALSE 104929
// SetSkill ( i , j , 10 ) ;
104910: LD_VAR 0 2
104914: PPUSH
104915: LD_VAR 0 3
104919: PPUSH
104920: LD_INT 10
104922: PPUSH
104923: CALL_OW 237
104927: GO 104907
104929: POP
104930: POP
// end ;
104931: GO 104880
104933: POP
104934: POP
// end ;
104935: LD_VAR 0 1
104939: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104940: LD_INT 0
104942: PPUSH
104943: PPUSH
104944: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104945: LD_ADDR_VAR 0 2
104949: PUSH
104950: LD_INT 22
104952: PUSH
104953: LD_OWVAR 2
104957: PUSH
104958: EMPTY
104959: LIST
104960: LIST
104961: PUSH
104962: LD_INT 21
104964: PUSH
104965: LD_INT 1
104967: PUSH
104968: EMPTY
104969: LIST
104970: LIST
104971: PUSH
104972: EMPTY
104973: LIST
104974: LIST
104975: PPUSH
104976: CALL_OW 69
104980: PUSH
104981: FOR_IN
104982: IFFALSE 105023
// begin for j := 1 to 4 do
104984: LD_ADDR_VAR 0 3
104988: PUSH
104989: DOUBLE
104990: LD_INT 1
104992: DEC
104993: ST_TO_ADDR
104994: LD_INT 4
104996: PUSH
104997: FOR_TO
104998: IFFALSE 105019
// SetSkill ( i , j , 10 ) ;
105000: LD_VAR 0 2
105004: PPUSH
105005: LD_VAR 0 3
105009: PPUSH
105010: LD_INT 10
105012: PPUSH
105013: CALL_OW 237
105017: GO 104997
105019: POP
105020: POP
// end ;
105021: GO 104981
105023: POP
105024: POP
// end ;
105025: LD_VAR 0 1
105029: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105030: LD_INT 0
105032: PPUSH
// uc_side := your_side ;
105033: LD_ADDR_OWVAR 20
105037: PUSH
105038: LD_OWVAR 2
105042: ST_TO_ADDR
// uc_nation := nation ;
105043: LD_ADDR_OWVAR 21
105047: PUSH
105048: LD_VAR 0 1
105052: ST_TO_ADDR
// InitHc ;
105053: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105057: LD_INT 0
105059: PPUSH
105060: LD_VAR 0 2
105064: PPUSH
105065: LD_VAR 0 3
105069: PPUSH
105070: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105074: LD_VAR 0 4
105078: PPUSH
105079: LD_VAR 0 5
105083: PPUSH
105084: CALL_OW 428
105088: PUSH
105089: LD_INT 0
105091: EQUAL
105092: IFFALSE 105116
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105094: CALL_OW 44
105098: PPUSH
105099: LD_VAR 0 4
105103: PPUSH
105104: LD_VAR 0 5
105108: PPUSH
105109: LD_INT 1
105111: PPUSH
105112: CALL_OW 48
// end ;
105116: LD_VAR 0 6
105120: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105121: LD_INT 0
105123: PPUSH
105124: PPUSH
// uc_side := your_side ;
105125: LD_ADDR_OWVAR 20
105129: PUSH
105130: LD_OWVAR 2
105134: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105135: LD_VAR 0 1
105139: PUSH
105140: LD_INT 1
105142: PUSH
105143: LD_INT 2
105145: PUSH
105146: LD_INT 3
105148: PUSH
105149: LD_INT 4
105151: PUSH
105152: LD_INT 5
105154: PUSH
105155: EMPTY
105156: LIST
105157: LIST
105158: LIST
105159: LIST
105160: LIST
105161: IN
105162: IFFALSE 105174
// uc_nation := nation_american else
105164: LD_ADDR_OWVAR 21
105168: PUSH
105169: LD_INT 1
105171: ST_TO_ADDR
105172: GO 105217
// if chassis in [ 11 , 12 , 13 , 14 ] then
105174: LD_VAR 0 1
105178: PUSH
105179: LD_INT 11
105181: PUSH
105182: LD_INT 12
105184: PUSH
105185: LD_INT 13
105187: PUSH
105188: LD_INT 14
105190: PUSH
105191: EMPTY
105192: LIST
105193: LIST
105194: LIST
105195: LIST
105196: IN
105197: IFFALSE 105209
// uc_nation := nation_arabian else
105199: LD_ADDR_OWVAR 21
105203: PUSH
105204: LD_INT 2
105206: ST_TO_ADDR
105207: GO 105217
// uc_nation := nation_russian ;
105209: LD_ADDR_OWVAR 21
105213: PUSH
105214: LD_INT 3
105216: ST_TO_ADDR
// vc_chassis := chassis ;
105217: LD_ADDR_OWVAR 37
105221: PUSH
105222: LD_VAR 0 1
105226: ST_TO_ADDR
// vc_engine := engine ;
105227: LD_ADDR_OWVAR 39
105231: PUSH
105232: LD_VAR 0 2
105236: ST_TO_ADDR
// vc_control := control ;
105237: LD_ADDR_OWVAR 38
105241: PUSH
105242: LD_VAR 0 3
105246: ST_TO_ADDR
// vc_weapon := weapon ;
105247: LD_ADDR_OWVAR 40
105251: PUSH
105252: LD_VAR 0 4
105256: ST_TO_ADDR
// un := CreateVehicle ;
105257: LD_ADDR_VAR 0 8
105261: PUSH
105262: CALL_OW 45
105266: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105267: LD_VAR 0 8
105271: PPUSH
105272: LD_INT 0
105274: PPUSH
105275: LD_INT 5
105277: PPUSH
105278: CALL_OW 12
105282: PPUSH
105283: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105287: LD_VAR 0 8
105291: PPUSH
105292: LD_VAR 0 5
105296: PPUSH
105297: LD_VAR 0 6
105301: PPUSH
105302: LD_INT 1
105304: PPUSH
105305: CALL_OW 48
// end ;
105309: LD_VAR 0 7
105313: RET
// export hInvincible ; every 1 do
105314: GO 105316
105316: DISABLE
// hInvincible := [ ] ;
105317: LD_ADDR_EXP 153
105321: PUSH
105322: EMPTY
105323: ST_TO_ADDR
105324: END
// every 10 do var i ;
105325: GO 105327
105327: DISABLE
105328: LD_INT 0
105330: PPUSH
// begin enable ;
105331: ENABLE
// if not hInvincible then
105332: LD_EXP 153
105336: NOT
105337: IFFALSE 105341
// exit ;
105339: GO 105385
// for i in hInvincible do
105341: LD_ADDR_VAR 0 1
105345: PUSH
105346: LD_EXP 153
105350: PUSH
105351: FOR_IN
105352: IFFALSE 105383
// if GetLives ( i ) < 1000 then
105354: LD_VAR 0 1
105358: PPUSH
105359: CALL_OW 256
105363: PUSH
105364: LD_INT 1000
105366: LESS
105367: IFFALSE 105381
// SetLives ( i , 1000 ) ;
105369: LD_VAR 0 1
105373: PPUSH
105374: LD_INT 1000
105376: PPUSH
105377: CALL_OW 234
105381: GO 105351
105383: POP
105384: POP
// end ;
105385: PPOPN 1
105387: END
// export function hHackInvincible ; var i ; begin
105388: LD_INT 0
105390: PPUSH
105391: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105392: LD_ADDR_VAR 0 2
105396: PUSH
105397: LD_INT 2
105399: PUSH
105400: LD_INT 21
105402: PUSH
105403: LD_INT 1
105405: PUSH
105406: EMPTY
105407: LIST
105408: LIST
105409: PUSH
105410: LD_INT 21
105412: PUSH
105413: LD_INT 2
105415: PUSH
105416: EMPTY
105417: LIST
105418: LIST
105419: PUSH
105420: EMPTY
105421: LIST
105422: LIST
105423: LIST
105424: PPUSH
105425: CALL_OW 69
105429: PUSH
105430: FOR_IN
105431: IFFALSE 105492
// if IsSelected ( i ) then
105433: LD_VAR 0 2
105437: PPUSH
105438: CALL_OW 306
105442: IFFALSE 105490
// begin if i in hInvincible then
105444: LD_VAR 0 2
105448: PUSH
105449: LD_EXP 153
105453: IN
105454: IFFALSE 105474
// hInvincible := hInvincible diff i else
105456: LD_ADDR_EXP 153
105460: PUSH
105461: LD_EXP 153
105465: PUSH
105466: LD_VAR 0 2
105470: DIFF
105471: ST_TO_ADDR
105472: GO 105490
// hInvincible := hInvincible union i ;
105474: LD_ADDR_EXP 153
105478: PUSH
105479: LD_EXP 153
105483: PUSH
105484: LD_VAR 0 2
105488: UNION
105489: ST_TO_ADDR
// end ;
105490: GO 105430
105492: POP
105493: POP
// end ;
105494: LD_VAR 0 1
105498: RET
// export function hHackInvisible ; var i , j ; begin
105499: LD_INT 0
105501: PPUSH
105502: PPUSH
105503: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105504: LD_ADDR_VAR 0 2
105508: PUSH
105509: LD_INT 21
105511: PUSH
105512: LD_INT 1
105514: PUSH
105515: EMPTY
105516: LIST
105517: LIST
105518: PPUSH
105519: CALL_OW 69
105523: PUSH
105524: FOR_IN
105525: IFFALSE 105549
// if IsSelected ( i ) then
105527: LD_VAR 0 2
105531: PPUSH
105532: CALL_OW 306
105536: IFFALSE 105547
// ComForceInvisible ( i ) ;
105538: LD_VAR 0 2
105542: PPUSH
105543: CALL_OW 496
105547: GO 105524
105549: POP
105550: POP
// end ;
105551: LD_VAR 0 1
105555: RET
// export function hHackChangeYourSide ; begin
105556: LD_INT 0
105558: PPUSH
// if your_side = 8 then
105559: LD_OWVAR 2
105563: PUSH
105564: LD_INT 8
105566: EQUAL
105567: IFFALSE 105579
// your_side := 0 else
105569: LD_ADDR_OWVAR 2
105573: PUSH
105574: LD_INT 0
105576: ST_TO_ADDR
105577: GO 105593
// your_side := your_side + 1 ;
105579: LD_ADDR_OWVAR 2
105583: PUSH
105584: LD_OWVAR 2
105588: PUSH
105589: LD_INT 1
105591: PLUS
105592: ST_TO_ADDR
// end ;
105593: LD_VAR 0 1
105597: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105598: LD_INT 0
105600: PPUSH
105601: PPUSH
105602: PPUSH
// for i in all_units do
105603: LD_ADDR_VAR 0 2
105607: PUSH
105608: LD_OWVAR 3
105612: PUSH
105613: FOR_IN
105614: IFFALSE 105692
// if IsSelected ( i ) then
105616: LD_VAR 0 2
105620: PPUSH
105621: CALL_OW 306
105625: IFFALSE 105690
// begin j := GetSide ( i ) ;
105627: LD_ADDR_VAR 0 3
105631: PUSH
105632: LD_VAR 0 2
105636: PPUSH
105637: CALL_OW 255
105641: ST_TO_ADDR
// if j = 8 then
105642: LD_VAR 0 3
105646: PUSH
105647: LD_INT 8
105649: EQUAL
105650: IFFALSE 105662
// j := 0 else
105652: LD_ADDR_VAR 0 3
105656: PUSH
105657: LD_INT 0
105659: ST_TO_ADDR
105660: GO 105676
// j := j + 1 ;
105662: LD_ADDR_VAR 0 3
105666: PUSH
105667: LD_VAR 0 3
105671: PUSH
105672: LD_INT 1
105674: PLUS
105675: ST_TO_ADDR
// SetSide ( i , j ) ;
105676: LD_VAR 0 2
105680: PPUSH
105681: LD_VAR 0 3
105685: PPUSH
105686: CALL_OW 235
// end ;
105690: GO 105613
105692: POP
105693: POP
// end ;
105694: LD_VAR 0 1
105698: RET
// export function hHackFog ; begin
105699: LD_INT 0
105701: PPUSH
// FogOff ( true ) ;
105702: LD_INT 1
105704: PPUSH
105705: CALL_OW 344
// end ;
105709: LD_VAR 0 1
105713: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105714: LD_INT 0
105716: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105717: LD_VAR 0 1
105721: PPUSH
105722: LD_VAR 0 2
105726: PPUSH
105727: LD_VAR 0 3
105731: PPUSH
105732: LD_INT 1
105734: PPUSH
105735: LD_INT 1
105737: PPUSH
105738: CALL_OW 483
// CenterOnXY ( x , y ) ;
105742: LD_VAR 0 2
105746: PPUSH
105747: LD_VAR 0 3
105751: PPUSH
105752: CALL_OW 84
// end ;
105756: LD_VAR 0 4
105760: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105761: LD_INT 0
105763: PPUSH
105764: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105765: LD_VAR 0 1
105769: NOT
105770: PUSH
105771: LD_VAR 0 2
105775: PPUSH
105776: LD_VAR 0 3
105780: PPUSH
105781: CALL_OW 488
105785: NOT
105786: OR
105787: PUSH
105788: LD_VAR 0 1
105792: PPUSH
105793: CALL_OW 266
105797: PUSH
105798: LD_INT 3
105800: NONEQUAL
105801: PUSH
105802: LD_VAR 0 1
105806: PPUSH
105807: CALL_OW 247
105811: PUSH
105812: LD_INT 1
105814: EQUAL
105815: NOT
105816: AND
105817: OR
105818: IFFALSE 105822
// exit ;
105820: GO 105971
// if GetType ( factory ) = unit_human then
105822: LD_VAR 0 1
105826: PPUSH
105827: CALL_OW 247
105831: PUSH
105832: LD_INT 1
105834: EQUAL
105835: IFFALSE 105852
// factory := IsInUnit ( factory ) ;
105837: LD_ADDR_VAR 0 1
105841: PUSH
105842: LD_VAR 0 1
105846: PPUSH
105847: CALL_OW 310
105851: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105852: LD_VAR 0 1
105856: PPUSH
105857: CALL_OW 266
105861: PUSH
105862: LD_INT 3
105864: NONEQUAL
105865: IFFALSE 105869
// exit ;
105867: GO 105971
// if HexInfo ( x , y ) = factory then
105869: LD_VAR 0 2
105873: PPUSH
105874: LD_VAR 0 3
105878: PPUSH
105879: CALL_OW 428
105883: PUSH
105884: LD_VAR 0 1
105888: EQUAL
105889: IFFALSE 105916
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105891: LD_ADDR_EXP 154
105895: PUSH
105896: LD_EXP 154
105900: PPUSH
105901: LD_VAR 0 1
105905: PPUSH
105906: LD_INT 0
105908: PPUSH
105909: CALL_OW 1
105913: ST_TO_ADDR
105914: GO 105967
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105916: LD_ADDR_EXP 154
105920: PUSH
105921: LD_EXP 154
105925: PPUSH
105926: LD_VAR 0 1
105930: PPUSH
105931: LD_VAR 0 1
105935: PPUSH
105936: CALL_OW 255
105940: PUSH
105941: LD_VAR 0 1
105945: PUSH
105946: LD_VAR 0 2
105950: PUSH
105951: LD_VAR 0 3
105955: PUSH
105956: EMPTY
105957: LIST
105958: LIST
105959: LIST
105960: LIST
105961: PPUSH
105962: CALL_OW 1
105966: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105967: CALL 105976 0 0
// end ;
105971: LD_VAR 0 4
105975: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105976: LD_INT 0
105978: PPUSH
105979: PPUSH
105980: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105981: LD_STRING resetFactoryWaypoint();
105983: PPUSH
105984: CALL_OW 559
// if factoryWaypoints then
105988: LD_EXP 154
105992: IFFALSE 106118
// begin list := PrepareArray ( factoryWaypoints ) ;
105994: LD_ADDR_VAR 0 3
105998: PUSH
105999: LD_EXP 154
106003: PPUSH
106004: CALL 90565 0 1
106008: ST_TO_ADDR
// for i := 1 to list do
106009: LD_ADDR_VAR 0 2
106013: PUSH
106014: DOUBLE
106015: LD_INT 1
106017: DEC
106018: ST_TO_ADDR
106019: LD_VAR 0 3
106023: PUSH
106024: FOR_TO
106025: IFFALSE 106116
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106027: LD_STRING setFactoryWaypointXY(
106029: PUSH
106030: LD_VAR 0 3
106034: PUSH
106035: LD_VAR 0 2
106039: ARRAY
106040: PUSH
106041: LD_INT 1
106043: ARRAY
106044: STR
106045: PUSH
106046: LD_STRING ,
106048: STR
106049: PUSH
106050: LD_VAR 0 3
106054: PUSH
106055: LD_VAR 0 2
106059: ARRAY
106060: PUSH
106061: LD_INT 2
106063: ARRAY
106064: STR
106065: PUSH
106066: LD_STRING ,
106068: STR
106069: PUSH
106070: LD_VAR 0 3
106074: PUSH
106075: LD_VAR 0 2
106079: ARRAY
106080: PUSH
106081: LD_INT 3
106083: ARRAY
106084: STR
106085: PUSH
106086: LD_STRING ,
106088: STR
106089: PUSH
106090: LD_VAR 0 3
106094: PUSH
106095: LD_VAR 0 2
106099: ARRAY
106100: PUSH
106101: LD_INT 4
106103: ARRAY
106104: STR
106105: PUSH
106106: LD_STRING )
106108: STR
106109: PPUSH
106110: CALL_OW 559
106114: GO 106024
106116: POP
106117: POP
// end ; end ;
106118: LD_VAR 0 1
106122: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106123: LD_INT 0
106125: PPUSH
// if HexInfo ( x , y ) = warehouse then
106126: LD_VAR 0 2
106130: PPUSH
106131: LD_VAR 0 3
106135: PPUSH
106136: CALL_OW 428
106140: PUSH
106141: LD_VAR 0 1
106145: EQUAL
106146: IFFALSE 106173
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106148: LD_ADDR_EXP 155
106152: PUSH
106153: LD_EXP 155
106157: PPUSH
106158: LD_VAR 0 1
106162: PPUSH
106163: LD_INT 0
106165: PPUSH
106166: CALL_OW 1
106170: ST_TO_ADDR
106171: GO 106224
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106173: LD_ADDR_EXP 155
106177: PUSH
106178: LD_EXP 155
106182: PPUSH
106183: LD_VAR 0 1
106187: PPUSH
106188: LD_VAR 0 1
106192: PPUSH
106193: CALL_OW 255
106197: PUSH
106198: LD_VAR 0 1
106202: PUSH
106203: LD_VAR 0 2
106207: PUSH
106208: LD_VAR 0 3
106212: PUSH
106213: EMPTY
106214: LIST
106215: LIST
106216: LIST
106217: LIST
106218: PPUSH
106219: CALL_OW 1
106223: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106224: CALL 106233 0 0
// end ;
106228: LD_VAR 0 4
106232: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106233: LD_INT 0
106235: PPUSH
106236: PPUSH
106237: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106238: LD_STRING resetWarehouseGatheringPoints();
106240: PPUSH
106241: CALL_OW 559
// if warehouseGatheringPoints then
106245: LD_EXP 155
106249: IFFALSE 106375
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106251: LD_ADDR_VAR 0 3
106255: PUSH
106256: LD_EXP 155
106260: PPUSH
106261: CALL 90565 0 1
106265: ST_TO_ADDR
// for i := 1 to list do
106266: LD_ADDR_VAR 0 2
106270: PUSH
106271: DOUBLE
106272: LD_INT 1
106274: DEC
106275: ST_TO_ADDR
106276: LD_VAR 0 3
106280: PUSH
106281: FOR_TO
106282: IFFALSE 106373
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106284: LD_STRING setWarehouseGatheringPointXY(
106286: PUSH
106287: LD_VAR 0 3
106291: PUSH
106292: LD_VAR 0 2
106296: ARRAY
106297: PUSH
106298: LD_INT 1
106300: ARRAY
106301: STR
106302: PUSH
106303: LD_STRING ,
106305: STR
106306: PUSH
106307: LD_VAR 0 3
106311: PUSH
106312: LD_VAR 0 2
106316: ARRAY
106317: PUSH
106318: LD_INT 2
106320: ARRAY
106321: STR
106322: PUSH
106323: LD_STRING ,
106325: STR
106326: PUSH
106327: LD_VAR 0 3
106331: PUSH
106332: LD_VAR 0 2
106336: ARRAY
106337: PUSH
106338: LD_INT 3
106340: ARRAY
106341: STR
106342: PUSH
106343: LD_STRING ,
106345: STR
106346: PUSH
106347: LD_VAR 0 3
106351: PUSH
106352: LD_VAR 0 2
106356: ARRAY
106357: PUSH
106358: LD_INT 4
106360: ARRAY
106361: STR
106362: PUSH
106363: LD_STRING )
106365: STR
106366: PPUSH
106367: CALL_OW 559
106371: GO 106281
106373: POP
106374: POP
// end ; end ;
106375: LD_VAR 0 1
106379: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106380: LD_EXP 155
106384: IFFALSE 107069
106386: GO 106388
106388: DISABLE
106389: LD_INT 0
106391: PPUSH
106392: PPUSH
106393: PPUSH
106394: PPUSH
106395: PPUSH
106396: PPUSH
106397: PPUSH
106398: PPUSH
106399: PPUSH
// begin enable ;
106400: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106401: LD_ADDR_VAR 0 3
106405: PUSH
106406: LD_EXP 155
106410: PPUSH
106411: CALL 90565 0 1
106415: ST_TO_ADDR
// if not list then
106416: LD_VAR 0 3
106420: NOT
106421: IFFALSE 106425
// exit ;
106423: GO 107069
// for i := 1 to list do
106425: LD_ADDR_VAR 0 1
106429: PUSH
106430: DOUBLE
106431: LD_INT 1
106433: DEC
106434: ST_TO_ADDR
106435: LD_VAR 0 3
106439: PUSH
106440: FOR_TO
106441: IFFALSE 107067
// begin depot := list [ i ] [ 2 ] ;
106443: LD_ADDR_VAR 0 8
106447: PUSH
106448: LD_VAR 0 3
106452: PUSH
106453: LD_VAR 0 1
106457: ARRAY
106458: PUSH
106459: LD_INT 2
106461: ARRAY
106462: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106463: LD_ADDR_VAR 0 5
106467: PUSH
106468: LD_VAR 0 3
106472: PUSH
106473: LD_VAR 0 1
106477: ARRAY
106478: PUSH
106479: LD_INT 1
106481: ARRAY
106482: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106483: LD_VAR 0 8
106487: PPUSH
106488: CALL_OW 301
106492: PUSH
106493: LD_VAR 0 5
106497: PUSH
106498: LD_VAR 0 8
106502: PPUSH
106503: CALL_OW 255
106507: NONEQUAL
106508: OR
106509: IFFALSE 106538
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106511: LD_ADDR_EXP 155
106515: PUSH
106516: LD_EXP 155
106520: PPUSH
106521: LD_VAR 0 8
106525: PPUSH
106526: LD_INT 0
106528: PPUSH
106529: CALL_OW 1
106533: ST_TO_ADDR
// exit ;
106534: POP
106535: POP
106536: GO 107069
// end ; x := list [ i ] [ 3 ] ;
106538: LD_ADDR_VAR 0 6
106542: PUSH
106543: LD_VAR 0 3
106547: PUSH
106548: LD_VAR 0 1
106552: ARRAY
106553: PUSH
106554: LD_INT 3
106556: ARRAY
106557: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
106558: LD_ADDR_VAR 0 7
106562: PUSH
106563: LD_VAR 0 3
106567: PUSH
106568: LD_VAR 0 1
106572: ARRAY
106573: PUSH
106574: LD_INT 4
106576: ARRAY
106577: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
106578: LD_ADDR_VAR 0 9
106582: PUSH
106583: LD_VAR 0 6
106587: PPUSH
106588: LD_VAR 0 7
106592: PPUSH
106593: LD_INT 16
106595: PPUSH
106596: CALL 89153 0 3
106600: ST_TO_ADDR
// if not cratesNearbyPoint then
106601: LD_VAR 0 9
106605: NOT
106606: IFFALSE 106612
// exit ;
106608: POP
106609: POP
106610: GO 107069
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
106612: LD_ADDR_VAR 0 4
106616: PUSH
106617: LD_INT 22
106619: PUSH
106620: LD_VAR 0 5
106624: PUSH
106625: EMPTY
106626: LIST
106627: LIST
106628: PUSH
106629: LD_INT 3
106631: PUSH
106632: LD_INT 60
106634: PUSH
106635: EMPTY
106636: LIST
106637: PUSH
106638: EMPTY
106639: LIST
106640: LIST
106641: PUSH
106642: LD_INT 91
106644: PUSH
106645: LD_VAR 0 8
106649: PUSH
106650: LD_INT 6
106652: PUSH
106653: EMPTY
106654: LIST
106655: LIST
106656: LIST
106657: PUSH
106658: LD_INT 2
106660: PUSH
106661: LD_INT 25
106663: PUSH
106664: LD_INT 2
106666: PUSH
106667: EMPTY
106668: LIST
106669: LIST
106670: PUSH
106671: LD_INT 25
106673: PUSH
106674: LD_INT 16
106676: PUSH
106677: EMPTY
106678: LIST
106679: LIST
106680: PUSH
106681: EMPTY
106682: LIST
106683: LIST
106684: LIST
106685: PUSH
106686: EMPTY
106687: LIST
106688: LIST
106689: LIST
106690: LIST
106691: PPUSH
106692: CALL_OW 69
106696: PUSH
106697: LD_VAR 0 8
106701: PPUSH
106702: CALL_OW 313
106706: PPUSH
106707: LD_INT 3
106709: PUSH
106710: LD_INT 60
106712: PUSH
106713: EMPTY
106714: LIST
106715: PUSH
106716: EMPTY
106717: LIST
106718: LIST
106719: PUSH
106720: LD_INT 2
106722: PUSH
106723: LD_INT 25
106725: PUSH
106726: LD_INT 2
106728: PUSH
106729: EMPTY
106730: LIST
106731: LIST
106732: PUSH
106733: LD_INT 25
106735: PUSH
106736: LD_INT 16
106738: PUSH
106739: EMPTY
106740: LIST
106741: LIST
106742: PUSH
106743: EMPTY
106744: LIST
106745: LIST
106746: LIST
106747: PUSH
106748: EMPTY
106749: LIST
106750: LIST
106751: PPUSH
106752: CALL_OW 72
106756: UNION
106757: ST_TO_ADDR
// if tmp then
106758: LD_VAR 0 4
106762: IFFALSE 106842
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106764: LD_ADDR_VAR 0 4
106768: PUSH
106769: LD_VAR 0 4
106773: PPUSH
106774: LD_INT 3
106776: PPUSH
106777: CALL 87122 0 2
106781: ST_TO_ADDR
// for j in tmp do
106782: LD_ADDR_VAR 0 2
106786: PUSH
106787: LD_VAR 0 4
106791: PUSH
106792: FOR_IN
106793: IFFALSE 106836
// begin if IsInUnit ( j ) then
106795: LD_VAR 0 2
106799: PPUSH
106800: CALL_OW 310
106804: IFFALSE 106815
// ComExit ( j ) ;
106806: LD_VAR 0 2
106810: PPUSH
106811: CALL 87205 0 1
// AddComCollect ( j , x , y ) ;
106815: LD_VAR 0 2
106819: PPUSH
106820: LD_VAR 0 6
106824: PPUSH
106825: LD_VAR 0 7
106829: PPUSH
106830: CALL_OW 177
// end ;
106834: GO 106792
106836: POP
106837: POP
// exit ;
106838: POP
106839: POP
106840: GO 107069
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106842: LD_ADDR_VAR 0 4
106846: PUSH
106847: LD_INT 22
106849: PUSH
106850: LD_VAR 0 5
106854: PUSH
106855: EMPTY
106856: LIST
106857: LIST
106858: PUSH
106859: LD_INT 91
106861: PUSH
106862: LD_VAR 0 8
106866: PUSH
106867: LD_INT 8
106869: PUSH
106870: EMPTY
106871: LIST
106872: LIST
106873: LIST
106874: PUSH
106875: LD_INT 2
106877: PUSH
106878: LD_INT 34
106880: PUSH
106881: LD_INT 12
106883: PUSH
106884: EMPTY
106885: LIST
106886: LIST
106887: PUSH
106888: LD_INT 34
106890: PUSH
106891: LD_INT 51
106893: PUSH
106894: EMPTY
106895: LIST
106896: LIST
106897: PUSH
106898: LD_INT 34
106900: PUSH
106901: LD_INT 32
106903: PUSH
106904: EMPTY
106905: LIST
106906: LIST
106907: PUSH
106908: LD_INT 34
106910: PUSH
106911: LD_INT 89
106913: PUSH
106914: EMPTY
106915: LIST
106916: LIST
106917: PUSH
106918: EMPTY
106919: LIST
106920: LIST
106921: LIST
106922: LIST
106923: LIST
106924: PUSH
106925: EMPTY
106926: LIST
106927: LIST
106928: LIST
106929: PPUSH
106930: CALL_OW 69
106934: ST_TO_ADDR
// if tmp then
106935: LD_VAR 0 4
106939: IFFALSE 107065
// begin for j in tmp do
106941: LD_ADDR_VAR 0 2
106945: PUSH
106946: LD_VAR 0 4
106950: PUSH
106951: FOR_IN
106952: IFFALSE 107063
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106954: LD_VAR 0 2
106958: PPUSH
106959: CALL_OW 262
106963: PUSH
106964: LD_INT 3
106966: EQUAL
106967: PUSH
106968: LD_VAR 0 2
106972: PPUSH
106973: CALL_OW 261
106977: PUSH
106978: LD_INT 20
106980: GREATER
106981: OR
106982: PUSH
106983: LD_VAR 0 2
106987: PPUSH
106988: CALL_OW 314
106992: NOT
106993: AND
106994: PUSH
106995: LD_VAR 0 2
106999: PPUSH
107000: CALL_OW 263
107004: PUSH
107005: LD_INT 1
107007: NONEQUAL
107008: PUSH
107009: LD_VAR 0 2
107013: PPUSH
107014: CALL_OW 311
107018: OR
107019: AND
107020: IFFALSE 107061
// begin ComCollect ( j , x , y ) ;
107022: LD_VAR 0 2
107026: PPUSH
107027: LD_VAR 0 6
107031: PPUSH
107032: LD_VAR 0 7
107036: PPUSH
107037: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107041: LD_VAR 0 2
107045: PPUSH
107046: LD_VAR 0 8
107050: PPUSH
107051: CALL_OW 172
// exit ;
107055: POP
107056: POP
107057: POP
107058: POP
107059: GO 107069
// end ;
107061: GO 106951
107063: POP
107064: POP
// end ; end ;
107065: GO 106440
107067: POP
107068: POP
// end ; end_of_file
107069: PPOPN 9
107071: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107072: LD_INT 0
107074: PPUSH
107075: PPUSH
107076: PPUSH
107077: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107078: LD_VAR 0 1
107082: PPUSH
107083: CALL_OW 264
107087: PUSH
107088: LD_INT 91
107090: EQUAL
107091: IFFALSE 107163
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107093: LD_INT 68
107095: PPUSH
107096: LD_VAR 0 1
107100: PPUSH
107101: CALL_OW 255
107105: PPUSH
107106: CALL_OW 321
107110: PUSH
107111: LD_INT 2
107113: EQUAL
107114: IFFALSE 107126
// eff := 70 else
107116: LD_ADDR_VAR 0 4
107120: PUSH
107121: LD_INT 70
107123: ST_TO_ADDR
107124: GO 107134
// eff := 30 ;
107126: LD_ADDR_VAR 0 4
107130: PUSH
107131: LD_INT 30
107133: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107134: LD_VAR 0 1
107138: PPUSH
107139: CALL_OW 250
107143: PPUSH
107144: LD_VAR 0 1
107148: PPUSH
107149: CALL_OW 251
107153: PPUSH
107154: LD_VAR 0 4
107158: PPUSH
107159: CALL_OW 495
// end ; end ;
107163: LD_VAR 0 2
107167: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107168: LD_INT 0
107170: PPUSH
// end ;
107171: LD_VAR 0 4
107175: RET
// export function SOS_Command ( cmd ) ; begin
107176: LD_INT 0
107178: PPUSH
// end ;
107179: LD_VAR 0 2
107183: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107184: LD_INT 0
107186: PPUSH
// end ;
107187: LD_VAR 0 6
107191: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107192: LD_INT 0
107194: PPUSH
107195: PPUSH
// if not vehicle or not factory then
107196: LD_VAR 0 1
107200: NOT
107201: PUSH
107202: LD_VAR 0 2
107206: NOT
107207: OR
107208: IFFALSE 107212
// exit ;
107210: GO 107443
// if factoryWaypoints >= factory then
107212: LD_EXP 154
107216: PUSH
107217: LD_VAR 0 2
107221: GREATEREQUAL
107222: IFFALSE 107443
// if factoryWaypoints [ factory ] then
107224: LD_EXP 154
107228: PUSH
107229: LD_VAR 0 2
107233: ARRAY
107234: IFFALSE 107443
// begin if GetControl ( vehicle ) = control_manual then
107236: LD_VAR 0 1
107240: PPUSH
107241: CALL_OW 263
107245: PUSH
107246: LD_INT 1
107248: EQUAL
107249: IFFALSE 107330
// begin driver := IsDrivenBy ( vehicle ) ;
107251: LD_ADDR_VAR 0 4
107255: PUSH
107256: LD_VAR 0 1
107260: PPUSH
107261: CALL_OW 311
107265: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107266: LD_VAR 0 4
107270: PPUSH
107271: LD_EXP 154
107275: PUSH
107276: LD_VAR 0 2
107280: ARRAY
107281: PUSH
107282: LD_INT 3
107284: ARRAY
107285: PPUSH
107286: LD_EXP 154
107290: PUSH
107291: LD_VAR 0 2
107295: ARRAY
107296: PUSH
107297: LD_INT 4
107299: ARRAY
107300: PPUSH
107301: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107305: LD_VAR 0 4
107309: PPUSH
107310: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107314: LD_VAR 0 4
107318: PPUSH
107319: LD_VAR 0 2
107323: PPUSH
107324: CALL_OW 180
// end else
107328: GO 107443
// if GetControl ( vehicle ) = control_remote then
107330: LD_VAR 0 1
107334: PPUSH
107335: CALL_OW 263
107339: PUSH
107340: LD_INT 2
107342: EQUAL
107343: IFFALSE 107404
// begin wait ( 0 0$2 ) ;
107345: LD_INT 70
107347: PPUSH
107348: CALL_OW 67
// if Connect ( vehicle ) then
107352: LD_VAR 0 1
107356: PPUSH
107357: CALL 57413 0 1
107361: IFFALSE 107402
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107363: LD_VAR 0 1
107367: PPUSH
107368: LD_EXP 154
107372: PUSH
107373: LD_VAR 0 2
107377: ARRAY
107378: PUSH
107379: LD_INT 3
107381: ARRAY
107382: PPUSH
107383: LD_EXP 154
107387: PUSH
107388: LD_VAR 0 2
107392: ARRAY
107393: PUSH
107394: LD_INT 4
107396: ARRAY
107397: PPUSH
107398: CALL_OW 171
// end else
107402: GO 107443
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107404: LD_VAR 0 1
107408: PPUSH
107409: LD_EXP 154
107413: PUSH
107414: LD_VAR 0 2
107418: ARRAY
107419: PUSH
107420: LD_INT 3
107422: ARRAY
107423: PPUSH
107424: LD_EXP 154
107428: PUSH
107429: LD_VAR 0 2
107433: ARRAY
107434: PUSH
107435: LD_INT 4
107437: ARRAY
107438: PPUSH
107439: CALL_OW 171
// end ; end ;
107443: LD_VAR 0 3
107447: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107448: LD_INT 0
107450: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107451: LD_VAR 0 1
107455: PUSH
107456: LD_INT 250
107458: EQUAL
107459: PUSH
107460: LD_VAR 0 2
107464: PPUSH
107465: CALL_OW 264
107469: PUSH
107470: LD_INT 81
107472: EQUAL
107473: AND
107474: IFFALSE 107495
// MinerPlaceMine ( unit , x , y ) ;
107476: LD_VAR 0 2
107480: PPUSH
107481: LD_VAR 0 4
107485: PPUSH
107486: LD_VAR 0 5
107490: PPUSH
107491: CALL 110319 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107495: LD_VAR 0 1
107499: PUSH
107500: LD_INT 251
107502: EQUAL
107503: PUSH
107504: LD_VAR 0 2
107508: PPUSH
107509: CALL_OW 264
107513: PUSH
107514: LD_INT 81
107516: EQUAL
107517: AND
107518: IFFALSE 107539
// MinerDetonateMine ( unit , x , y ) ;
107520: LD_VAR 0 2
107524: PPUSH
107525: LD_VAR 0 4
107529: PPUSH
107530: LD_VAR 0 5
107534: PPUSH
107535: CALL 110594 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107539: LD_VAR 0 1
107543: PUSH
107544: LD_INT 252
107546: EQUAL
107547: PUSH
107548: LD_VAR 0 2
107552: PPUSH
107553: CALL_OW 264
107557: PUSH
107558: LD_INT 81
107560: EQUAL
107561: AND
107562: IFFALSE 107583
// MinerCreateMinefield ( unit , x , y ) ;
107564: LD_VAR 0 2
107568: PPUSH
107569: LD_VAR 0 4
107573: PPUSH
107574: LD_VAR 0 5
107578: PPUSH
107579: CALL 111011 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107583: LD_VAR 0 1
107587: PUSH
107588: LD_INT 253
107590: EQUAL
107591: PUSH
107592: LD_VAR 0 2
107596: PPUSH
107597: CALL_OW 257
107601: PUSH
107602: LD_INT 5
107604: EQUAL
107605: AND
107606: IFFALSE 107627
// ComBinocular ( unit , x , y ) ;
107608: LD_VAR 0 2
107612: PPUSH
107613: LD_VAR 0 4
107617: PPUSH
107618: LD_VAR 0 5
107622: PPUSH
107623: CALL 111380 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107627: LD_VAR 0 1
107631: PUSH
107632: LD_INT 254
107634: EQUAL
107635: PUSH
107636: LD_VAR 0 2
107640: PPUSH
107641: CALL_OW 264
107645: PUSH
107646: LD_INT 99
107648: EQUAL
107649: AND
107650: PUSH
107651: LD_VAR 0 3
107655: PPUSH
107656: CALL_OW 263
107660: PUSH
107661: LD_INT 3
107663: EQUAL
107664: AND
107665: IFFALSE 107681
// HackDestroyVehicle ( unit , selectedUnit ) ;
107667: LD_VAR 0 2
107671: PPUSH
107672: LD_VAR 0 3
107676: PPUSH
107677: CALL 109683 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107681: LD_VAR 0 1
107685: PUSH
107686: LD_INT 255
107688: EQUAL
107689: PUSH
107690: LD_VAR 0 2
107694: PPUSH
107695: CALL_OW 264
107699: PUSH
107700: LD_INT 14
107702: PUSH
107703: LD_INT 53
107705: PUSH
107706: EMPTY
107707: LIST
107708: LIST
107709: IN
107710: AND
107711: PUSH
107712: LD_VAR 0 4
107716: PPUSH
107717: LD_VAR 0 5
107721: PPUSH
107722: CALL_OW 488
107726: AND
107727: IFFALSE 107751
// CutTreeXYR ( unit , x , y , 12 ) ;
107729: LD_VAR 0 2
107733: PPUSH
107734: LD_VAR 0 4
107738: PPUSH
107739: LD_VAR 0 5
107743: PPUSH
107744: LD_INT 12
107746: PPUSH
107747: CALL 107846 0 4
// if cmd = 256 then
107751: LD_VAR 0 1
107755: PUSH
107756: LD_INT 256
107758: EQUAL
107759: IFFALSE 107780
// SetFactoryWaypoint ( unit , x , y ) ;
107761: LD_VAR 0 2
107765: PPUSH
107766: LD_VAR 0 4
107770: PPUSH
107771: LD_VAR 0 5
107775: PPUSH
107776: CALL 105761 0 3
// if cmd = 257 then
107780: LD_VAR 0 1
107784: PUSH
107785: LD_INT 257
107787: EQUAL
107788: IFFALSE 107809
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107790: LD_VAR 0 2
107794: PPUSH
107795: LD_VAR 0 4
107799: PPUSH
107800: LD_VAR 0 5
107804: PPUSH
107805: CALL 106123 0 3
// if cmd = 258 then
107809: LD_VAR 0 1
107813: PUSH
107814: LD_INT 258
107816: EQUAL
107817: IFFALSE 107841
// BurnTreeXYR ( unit , x , y , 8 ) ;
107819: LD_VAR 0 2
107823: PPUSH
107824: LD_VAR 0 4
107828: PPUSH
107829: LD_VAR 0 5
107833: PPUSH
107834: LD_INT 8
107836: PPUSH
107837: CALL 108240 0 4
// end ;
107841: LD_VAR 0 6
107845: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107846: LD_INT 0
107848: PPUSH
107849: PPUSH
107850: PPUSH
107851: PPUSH
107852: PPUSH
107853: PPUSH
107854: PPUSH
107855: PPUSH
107856: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
107857: LD_VAR 0 1
107861: PPUSH
107862: CALL_OW 302
107866: NOT
107867: PUSH
107868: LD_VAR 0 2
107872: PPUSH
107873: LD_VAR 0 3
107877: PPUSH
107878: CALL_OW 488
107882: NOT
107883: OR
107884: PUSH
107885: LD_VAR 0 4
107889: NOT
107890: OR
107891: IFFALSE 107895
// exit ;
107893: GO 108235
// list := [ ] ;
107895: LD_ADDR_VAR 0 13
107899: PUSH
107900: EMPTY
107901: ST_TO_ADDR
// if x - r < 0 then
107902: LD_VAR 0 2
107906: PUSH
107907: LD_VAR 0 4
107911: MINUS
107912: PUSH
107913: LD_INT 0
107915: LESS
107916: IFFALSE 107928
// min_x := 0 else
107918: LD_ADDR_VAR 0 7
107922: PUSH
107923: LD_INT 0
107925: ST_TO_ADDR
107926: GO 107944
// min_x := x - r ;
107928: LD_ADDR_VAR 0 7
107932: PUSH
107933: LD_VAR 0 2
107937: PUSH
107938: LD_VAR 0 4
107942: MINUS
107943: ST_TO_ADDR
// if y - r < 0 then
107944: LD_VAR 0 3
107948: PUSH
107949: LD_VAR 0 4
107953: MINUS
107954: PUSH
107955: LD_INT 0
107957: LESS
107958: IFFALSE 107970
// min_y := 0 else
107960: LD_ADDR_VAR 0 8
107964: PUSH
107965: LD_INT 0
107967: ST_TO_ADDR
107968: GO 107986
// min_y := y - r ;
107970: LD_ADDR_VAR 0 8
107974: PUSH
107975: LD_VAR 0 3
107979: PUSH
107980: LD_VAR 0 4
107984: MINUS
107985: ST_TO_ADDR
// max_x := x + r ;
107986: LD_ADDR_VAR 0 9
107990: PUSH
107991: LD_VAR 0 2
107995: PUSH
107996: LD_VAR 0 4
108000: PLUS
108001: ST_TO_ADDR
// max_y := y + r ;
108002: LD_ADDR_VAR 0 10
108006: PUSH
108007: LD_VAR 0 3
108011: PUSH
108012: LD_VAR 0 4
108016: PLUS
108017: ST_TO_ADDR
// for _x = min_x to max_x do
108018: LD_ADDR_VAR 0 11
108022: PUSH
108023: DOUBLE
108024: LD_VAR 0 7
108028: DEC
108029: ST_TO_ADDR
108030: LD_VAR 0 9
108034: PUSH
108035: FOR_TO
108036: IFFALSE 108153
// for _y = min_y to max_y do
108038: LD_ADDR_VAR 0 12
108042: PUSH
108043: DOUBLE
108044: LD_VAR 0 8
108048: DEC
108049: ST_TO_ADDR
108050: LD_VAR 0 10
108054: PUSH
108055: FOR_TO
108056: IFFALSE 108149
// begin if not ValidHex ( _x , _y ) then
108058: LD_VAR 0 11
108062: PPUSH
108063: LD_VAR 0 12
108067: PPUSH
108068: CALL_OW 488
108072: NOT
108073: IFFALSE 108077
// continue ;
108075: GO 108055
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108077: LD_VAR 0 11
108081: PPUSH
108082: LD_VAR 0 12
108086: PPUSH
108087: CALL_OW 351
108091: PUSH
108092: LD_VAR 0 11
108096: PPUSH
108097: LD_VAR 0 12
108101: PPUSH
108102: CALL_OW 554
108106: AND
108107: IFFALSE 108147
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108109: LD_ADDR_VAR 0 13
108113: PUSH
108114: LD_VAR 0 13
108118: PPUSH
108119: LD_VAR 0 13
108123: PUSH
108124: LD_INT 1
108126: PLUS
108127: PPUSH
108128: LD_VAR 0 11
108132: PUSH
108133: LD_VAR 0 12
108137: PUSH
108138: EMPTY
108139: LIST
108140: LIST
108141: PPUSH
108142: CALL_OW 2
108146: ST_TO_ADDR
// end ;
108147: GO 108055
108149: POP
108150: POP
108151: GO 108035
108153: POP
108154: POP
// if not list then
108155: LD_VAR 0 13
108159: NOT
108160: IFFALSE 108164
// exit ;
108162: GO 108235
// for i in list do
108164: LD_ADDR_VAR 0 6
108168: PUSH
108169: LD_VAR 0 13
108173: PUSH
108174: FOR_IN
108175: IFFALSE 108233
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108177: LD_VAR 0 1
108181: PPUSH
108182: LD_STRING M
108184: PUSH
108185: LD_VAR 0 6
108189: PUSH
108190: LD_INT 1
108192: ARRAY
108193: PUSH
108194: LD_VAR 0 6
108198: PUSH
108199: LD_INT 2
108201: ARRAY
108202: PUSH
108203: LD_INT 0
108205: PUSH
108206: LD_INT 0
108208: PUSH
108209: LD_INT 0
108211: PUSH
108212: LD_INT 0
108214: PUSH
108215: EMPTY
108216: LIST
108217: LIST
108218: LIST
108219: LIST
108220: LIST
108221: LIST
108222: LIST
108223: PUSH
108224: EMPTY
108225: LIST
108226: PPUSH
108227: CALL_OW 447
108231: GO 108174
108233: POP
108234: POP
// end ;
108235: LD_VAR 0 5
108239: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108240: LD_INT 0
108242: PPUSH
108243: PPUSH
108244: PPUSH
108245: PPUSH
108246: PPUSH
108247: PPUSH
108248: PPUSH
108249: PPUSH
108250: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
108251: LD_VAR 0 1
108255: PPUSH
108256: CALL_OW 302
108260: NOT
108261: PUSH
108262: LD_VAR 0 2
108266: PPUSH
108267: LD_VAR 0 3
108271: PPUSH
108272: CALL_OW 488
108276: NOT
108277: OR
108278: PUSH
108279: LD_VAR 0 4
108283: NOT
108284: OR
108285: IFFALSE 108289
// exit ;
108287: GO 108637
// list := [ ] ;
108289: LD_ADDR_VAR 0 13
108293: PUSH
108294: EMPTY
108295: ST_TO_ADDR
// if x - r < 0 then
108296: LD_VAR 0 2
108300: PUSH
108301: LD_VAR 0 4
108305: MINUS
108306: PUSH
108307: LD_INT 0
108309: LESS
108310: IFFALSE 108322
// min_x := 0 else
108312: LD_ADDR_VAR 0 7
108316: PUSH
108317: LD_INT 0
108319: ST_TO_ADDR
108320: GO 108338
// min_x := x - r ;
108322: LD_ADDR_VAR 0 7
108326: PUSH
108327: LD_VAR 0 2
108331: PUSH
108332: LD_VAR 0 4
108336: MINUS
108337: ST_TO_ADDR
// if y - r < 0 then
108338: LD_VAR 0 3
108342: PUSH
108343: LD_VAR 0 4
108347: MINUS
108348: PUSH
108349: LD_INT 0
108351: LESS
108352: IFFALSE 108364
// min_y := 0 else
108354: LD_ADDR_VAR 0 8
108358: PUSH
108359: LD_INT 0
108361: ST_TO_ADDR
108362: GO 108380
// min_y := y - r ;
108364: LD_ADDR_VAR 0 8
108368: PUSH
108369: LD_VAR 0 3
108373: PUSH
108374: LD_VAR 0 4
108378: MINUS
108379: ST_TO_ADDR
// max_x := x + r ;
108380: LD_ADDR_VAR 0 9
108384: PUSH
108385: LD_VAR 0 2
108389: PUSH
108390: LD_VAR 0 4
108394: PLUS
108395: ST_TO_ADDR
// max_y := y + r ;
108396: LD_ADDR_VAR 0 10
108400: PUSH
108401: LD_VAR 0 3
108405: PUSH
108406: LD_VAR 0 4
108410: PLUS
108411: ST_TO_ADDR
// for _x = min_x to max_x do
108412: LD_ADDR_VAR 0 11
108416: PUSH
108417: DOUBLE
108418: LD_VAR 0 7
108422: DEC
108423: ST_TO_ADDR
108424: LD_VAR 0 9
108428: PUSH
108429: FOR_TO
108430: IFFALSE 108547
// for _y = min_y to max_y do
108432: LD_ADDR_VAR 0 12
108436: PUSH
108437: DOUBLE
108438: LD_VAR 0 8
108442: DEC
108443: ST_TO_ADDR
108444: LD_VAR 0 10
108448: PUSH
108449: FOR_TO
108450: IFFALSE 108543
// begin if not ValidHex ( _x , _y ) then
108452: LD_VAR 0 11
108456: PPUSH
108457: LD_VAR 0 12
108461: PPUSH
108462: CALL_OW 488
108466: NOT
108467: IFFALSE 108471
// continue ;
108469: GO 108449
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108471: LD_VAR 0 11
108475: PPUSH
108476: LD_VAR 0 12
108480: PPUSH
108481: CALL_OW 351
108485: PUSH
108486: LD_VAR 0 11
108490: PPUSH
108491: LD_VAR 0 12
108495: PPUSH
108496: CALL_OW 554
108500: AND
108501: IFFALSE 108541
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108503: LD_ADDR_VAR 0 13
108507: PUSH
108508: LD_VAR 0 13
108512: PPUSH
108513: LD_VAR 0 13
108517: PUSH
108518: LD_INT 1
108520: PLUS
108521: PPUSH
108522: LD_VAR 0 11
108526: PUSH
108527: LD_VAR 0 12
108531: PUSH
108532: EMPTY
108533: LIST
108534: LIST
108535: PPUSH
108536: CALL_OW 2
108540: ST_TO_ADDR
// end ;
108541: GO 108449
108543: POP
108544: POP
108545: GO 108429
108547: POP
108548: POP
// if not list then
108549: LD_VAR 0 13
108553: NOT
108554: IFFALSE 108558
// exit ;
108556: GO 108637
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
108558: LD_ADDR_VAR 0 13
108562: PUSH
108563: LD_VAR 0 1
108567: PPUSH
108568: LD_VAR 0 13
108572: PPUSH
108573: LD_INT 1
108575: PPUSH
108576: LD_INT 1
108578: PPUSH
108579: CALL 54555 0 4
108583: ST_TO_ADDR
// ComStop ( flame ) ;
108584: LD_VAR 0 1
108588: PPUSH
108589: CALL_OW 141
// for i in list do
108593: LD_ADDR_VAR 0 6
108597: PUSH
108598: LD_VAR 0 13
108602: PUSH
108603: FOR_IN
108604: IFFALSE 108635
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
108606: LD_VAR 0 1
108610: PPUSH
108611: LD_VAR 0 6
108615: PUSH
108616: LD_INT 1
108618: ARRAY
108619: PPUSH
108620: LD_VAR 0 6
108624: PUSH
108625: LD_INT 2
108627: ARRAY
108628: PPUSH
108629: CALL_OW 176
108633: GO 108603
108635: POP
108636: POP
// end ;
108637: LD_VAR 0 5
108641: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108642: LD_EXP 157
108646: NOT
108647: IFFALSE 108697
108649: GO 108651
108651: DISABLE
// begin initHack := true ;
108652: LD_ADDR_EXP 157
108656: PUSH
108657: LD_INT 1
108659: ST_TO_ADDR
// hackTanks := [ ] ;
108660: LD_ADDR_EXP 158
108664: PUSH
108665: EMPTY
108666: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108667: LD_ADDR_EXP 159
108671: PUSH
108672: EMPTY
108673: ST_TO_ADDR
// hackLimit := 3 ;
108674: LD_ADDR_EXP 160
108678: PUSH
108679: LD_INT 3
108681: ST_TO_ADDR
// hackDist := 12 ;
108682: LD_ADDR_EXP 161
108686: PUSH
108687: LD_INT 12
108689: ST_TO_ADDR
// hackCounter := [ ] ;
108690: LD_ADDR_EXP 162
108694: PUSH
108695: EMPTY
108696: ST_TO_ADDR
// end ;
108697: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108698: LD_EXP 157
108702: PUSH
108703: LD_INT 34
108705: PUSH
108706: LD_INT 99
108708: PUSH
108709: EMPTY
108710: LIST
108711: LIST
108712: PPUSH
108713: CALL_OW 69
108717: AND
108718: IFFALSE 108971
108720: GO 108722
108722: DISABLE
108723: LD_INT 0
108725: PPUSH
108726: PPUSH
// begin enable ;
108727: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108728: LD_ADDR_VAR 0 1
108732: PUSH
108733: LD_INT 34
108735: PUSH
108736: LD_INT 99
108738: PUSH
108739: EMPTY
108740: LIST
108741: LIST
108742: PPUSH
108743: CALL_OW 69
108747: PUSH
108748: FOR_IN
108749: IFFALSE 108969
// begin if not i in hackTanks then
108751: LD_VAR 0 1
108755: PUSH
108756: LD_EXP 158
108760: IN
108761: NOT
108762: IFFALSE 108845
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108764: LD_ADDR_EXP 158
108768: PUSH
108769: LD_EXP 158
108773: PPUSH
108774: LD_EXP 158
108778: PUSH
108779: LD_INT 1
108781: PLUS
108782: PPUSH
108783: LD_VAR 0 1
108787: PPUSH
108788: CALL_OW 1
108792: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108793: LD_ADDR_EXP 159
108797: PUSH
108798: LD_EXP 159
108802: PPUSH
108803: LD_EXP 159
108807: PUSH
108808: LD_INT 1
108810: PLUS
108811: PPUSH
108812: EMPTY
108813: PPUSH
108814: CALL_OW 1
108818: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108819: LD_ADDR_EXP 162
108823: PUSH
108824: LD_EXP 162
108828: PPUSH
108829: LD_EXP 162
108833: PUSH
108834: LD_INT 1
108836: PLUS
108837: PPUSH
108838: EMPTY
108839: PPUSH
108840: CALL_OW 1
108844: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108845: LD_VAR 0 1
108849: PPUSH
108850: CALL_OW 302
108854: NOT
108855: IFFALSE 108868
// begin HackUnlinkAll ( i ) ;
108857: LD_VAR 0 1
108861: PPUSH
108862: CALL 108974 0 1
// continue ;
108866: GO 108748
// end ; HackCheckCapturedStatus ( i ) ;
108868: LD_VAR 0 1
108872: PPUSH
108873: CALL 109417 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108877: LD_ADDR_VAR 0 2
108881: PUSH
108882: LD_INT 81
108884: PUSH
108885: LD_VAR 0 1
108889: PPUSH
108890: CALL_OW 255
108894: PUSH
108895: EMPTY
108896: LIST
108897: LIST
108898: PUSH
108899: LD_INT 33
108901: PUSH
108902: LD_INT 3
108904: PUSH
108905: EMPTY
108906: LIST
108907: LIST
108908: PUSH
108909: LD_INT 91
108911: PUSH
108912: LD_VAR 0 1
108916: PUSH
108917: LD_EXP 161
108921: PUSH
108922: EMPTY
108923: LIST
108924: LIST
108925: LIST
108926: PUSH
108927: LD_INT 50
108929: PUSH
108930: EMPTY
108931: LIST
108932: PUSH
108933: EMPTY
108934: LIST
108935: LIST
108936: LIST
108937: LIST
108938: PPUSH
108939: CALL_OW 69
108943: ST_TO_ADDR
// if not tmp then
108944: LD_VAR 0 2
108948: NOT
108949: IFFALSE 108953
// continue ;
108951: GO 108748
// HackLink ( i , tmp ) ;
108953: LD_VAR 0 1
108957: PPUSH
108958: LD_VAR 0 2
108962: PPUSH
108963: CALL 109110 0 2
// end ;
108967: GO 108748
108969: POP
108970: POP
// end ;
108971: PPOPN 2
108973: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
108974: LD_INT 0
108976: PPUSH
108977: PPUSH
108978: PPUSH
// if not hack in hackTanks then
108979: LD_VAR 0 1
108983: PUSH
108984: LD_EXP 158
108988: IN
108989: NOT
108990: IFFALSE 108994
// exit ;
108992: GO 109105
// index := GetElementIndex ( hackTanks , hack ) ;
108994: LD_ADDR_VAR 0 4
108998: PUSH
108999: LD_EXP 158
109003: PPUSH
109004: LD_VAR 0 1
109008: PPUSH
109009: CALL 53852 0 2
109013: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109014: LD_EXP 159
109018: PUSH
109019: LD_VAR 0 4
109023: ARRAY
109024: IFFALSE 109105
// begin for i in hackTanksCaptured [ index ] do
109026: LD_ADDR_VAR 0 3
109030: PUSH
109031: LD_EXP 159
109035: PUSH
109036: LD_VAR 0 4
109040: ARRAY
109041: PUSH
109042: FOR_IN
109043: IFFALSE 109069
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109045: LD_VAR 0 3
109049: PUSH
109050: LD_INT 1
109052: ARRAY
109053: PPUSH
109054: LD_VAR 0 3
109058: PUSH
109059: LD_INT 2
109061: ARRAY
109062: PPUSH
109063: CALL_OW 235
109067: GO 109042
109069: POP
109070: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109071: LD_ADDR_EXP 159
109075: PUSH
109076: LD_EXP 159
109080: PPUSH
109081: LD_VAR 0 4
109085: PPUSH
109086: EMPTY
109087: PPUSH
109088: CALL_OW 1
109092: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109093: LD_VAR 0 1
109097: PPUSH
109098: LD_INT 0
109100: PPUSH
109101: CALL_OW 505
// end ; end ;
109105: LD_VAR 0 2
109109: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109110: LD_INT 0
109112: PPUSH
109113: PPUSH
109114: PPUSH
// if not hack in hackTanks or not vehicles then
109115: LD_VAR 0 1
109119: PUSH
109120: LD_EXP 158
109124: IN
109125: NOT
109126: PUSH
109127: LD_VAR 0 2
109131: NOT
109132: OR
109133: IFFALSE 109137
// exit ;
109135: GO 109412
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109137: LD_ADDR_VAR 0 2
109141: PUSH
109142: LD_VAR 0 1
109146: PPUSH
109147: LD_VAR 0 2
109151: PPUSH
109152: LD_INT 1
109154: PPUSH
109155: LD_INT 1
109157: PPUSH
109158: CALL 54502 0 4
109162: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109163: LD_ADDR_VAR 0 5
109167: PUSH
109168: LD_EXP 158
109172: PPUSH
109173: LD_VAR 0 1
109177: PPUSH
109178: CALL 53852 0 2
109182: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109183: LD_EXP 159
109187: PUSH
109188: LD_VAR 0 5
109192: ARRAY
109193: PUSH
109194: LD_EXP 160
109198: LESS
109199: IFFALSE 109388
// begin for i := 1 to vehicles do
109201: LD_ADDR_VAR 0 4
109205: PUSH
109206: DOUBLE
109207: LD_INT 1
109209: DEC
109210: ST_TO_ADDR
109211: LD_VAR 0 2
109215: PUSH
109216: FOR_TO
109217: IFFALSE 109386
// begin if hackTanksCaptured [ index ] = hackLimit then
109219: LD_EXP 159
109223: PUSH
109224: LD_VAR 0 5
109228: ARRAY
109229: PUSH
109230: LD_EXP 160
109234: EQUAL
109235: IFFALSE 109239
// break ;
109237: GO 109386
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109239: LD_ADDR_EXP 162
109243: PUSH
109244: LD_EXP 162
109248: PPUSH
109249: LD_VAR 0 5
109253: PPUSH
109254: LD_EXP 162
109258: PUSH
109259: LD_VAR 0 5
109263: ARRAY
109264: PUSH
109265: LD_INT 1
109267: PLUS
109268: PPUSH
109269: CALL_OW 1
109273: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109274: LD_ADDR_EXP 159
109278: PUSH
109279: LD_EXP 159
109283: PPUSH
109284: LD_VAR 0 5
109288: PUSH
109289: LD_EXP 159
109293: PUSH
109294: LD_VAR 0 5
109298: ARRAY
109299: PUSH
109300: LD_INT 1
109302: PLUS
109303: PUSH
109304: EMPTY
109305: LIST
109306: LIST
109307: PPUSH
109308: LD_VAR 0 2
109312: PUSH
109313: LD_VAR 0 4
109317: ARRAY
109318: PUSH
109319: LD_VAR 0 2
109323: PUSH
109324: LD_VAR 0 4
109328: ARRAY
109329: PPUSH
109330: CALL_OW 255
109334: PUSH
109335: EMPTY
109336: LIST
109337: LIST
109338: PPUSH
109339: CALL 54067 0 3
109343: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109344: LD_VAR 0 2
109348: PUSH
109349: LD_VAR 0 4
109353: ARRAY
109354: PPUSH
109355: LD_VAR 0 1
109359: PPUSH
109360: CALL_OW 255
109364: PPUSH
109365: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109369: LD_VAR 0 2
109373: PUSH
109374: LD_VAR 0 4
109378: ARRAY
109379: PPUSH
109380: CALL_OW 141
// end ;
109384: GO 109216
109386: POP
109387: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109388: LD_VAR 0 1
109392: PPUSH
109393: LD_EXP 159
109397: PUSH
109398: LD_VAR 0 5
109402: ARRAY
109403: PUSH
109404: LD_INT 0
109406: PLUS
109407: PPUSH
109408: CALL_OW 505
// end ;
109412: LD_VAR 0 3
109416: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109417: LD_INT 0
109419: PPUSH
109420: PPUSH
109421: PPUSH
109422: PPUSH
// if not hack in hackTanks then
109423: LD_VAR 0 1
109427: PUSH
109428: LD_EXP 158
109432: IN
109433: NOT
109434: IFFALSE 109438
// exit ;
109436: GO 109678
// index := GetElementIndex ( hackTanks , hack ) ;
109438: LD_ADDR_VAR 0 4
109442: PUSH
109443: LD_EXP 158
109447: PPUSH
109448: LD_VAR 0 1
109452: PPUSH
109453: CALL 53852 0 2
109457: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109458: LD_ADDR_VAR 0 3
109462: PUSH
109463: DOUBLE
109464: LD_EXP 159
109468: PUSH
109469: LD_VAR 0 4
109473: ARRAY
109474: INC
109475: ST_TO_ADDR
109476: LD_INT 1
109478: PUSH
109479: FOR_DOWNTO
109480: IFFALSE 109652
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109482: LD_ADDR_VAR 0 5
109486: PUSH
109487: LD_EXP 159
109491: PUSH
109492: LD_VAR 0 4
109496: ARRAY
109497: PUSH
109498: LD_VAR 0 3
109502: ARRAY
109503: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109504: LD_VAR 0 5
109508: PUSH
109509: LD_INT 1
109511: ARRAY
109512: PPUSH
109513: CALL_OW 302
109517: NOT
109518: PUSH
109519: LD_VAR 0 5
109523: PUSH
109524: LD_INT 1
109526: ARRAY
109527: PPUSH
109528: CALL_OW 255
109532: PUSH
109533: LD_VAR 0 1
109537: PPUSH
109538: CALL_OW 255
109542: NONEQUAL
109543: OR
109544: IFFALSE 109650
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109546: LD_VAR 0 5
109550: PUSH
109551: LD_INT 1
109553: ARRAY
109554: PPUSH
109555: CALL_OW 305
109559: PUSH
109560: LD_VAR 0 5
109564: PUSH
109565: LD_INT 1
109567: ARRAY
109568: PPUSH
109569: CALL_OW 255
109573: PUSH
109574: LD_VAR 0 1
109578: PPUSH
109579: CALL_OW 255
109583: EQUAL
109584: AND
109585: IFFALSE 109609
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109587: LD_VAR 0 5
109591: PUSH
109592: LD_INT 1
109594: ARRAY
109595: PPUSH
109596: LD_VAR 0 5
109600: PUSH
109601: LD_INT 2
109603: ARRAY
109604: PPUSH
109605: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109609: LD_ADDR_EXP 159
109613: PUSH
109614: LD_EXP 159
109618: PPUSH
109619: LD_VAR 0 4
109623: PPUSH
109624: LD_EXP 159
109628: PUSH
109629: LD_VAR 0 4
109633: ARRAY
109634: PPUSH
109635: LD_VAR 0 3
109639: PPUSH
109640: CALL_OW 3
109644: PPUSH
109645: CALL_OW 1
109649: ST_TO_ADDR
// end ; end ;
109650: GO 109479
109652: POP
109653: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109654: LD_VAR 0 1
109658: PPUSH
109659: LD_EXP 159
109663: PUSH
109664: LD_VAR 0 4
109668: ARRAY
109669: PUSH
109670: LD_INT 0
109672: PLUS
109673: PPUSH
109674: CALL_OW 505
// end ;
109678: LD_VAR 0 2
109682: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109683: LD_INT 0
109685: PPUSH
109686: PPUSH
109687: PPUSH
109688: PPUSH
// if not hack in hackTanks then
109689: LD_VAR 0 1
109693: PUSH
109694: LD_EXP 158
109698: IN
109699: NOT
109700: IFFALSE 109704
// exit ;
109702: GO 109789
// index := GetElementIndex ( hackTanks , hack ) ;
109704: LD_ADDR_VAR 0 5
109708: PUSH
109709: LD_EXP 158
109713: PPUSH
109714: LD_VAR 0 1
109718: PPUSH
109719: CALL 53852 0 2
109723: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109724: LD_ADDR_VAR 0 4
109728: PUSH
109729: DOUBLE
109730: LD_INT 1
109732: DEC
109733: ST_TO_ADDR
109734: LD_EXP 159
109738: PUSH
109739: LD_VAR 0 5
109743: ARRAY
109744: PUSH
109745: FOR_TO
109746: IFFALSE 109787
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109748: LD_EXP 159
109752: PUSH
109753: LD_VAR 0 5
109757: ARRAY
109758: PUSH
109759: LD_VAR 0 4
109763: ARRAY
109764: PUSH
109765: LD_INT 1
109767: ARRAY
109768: PUSH
109769: LD_VAR 0 2
109773: EQUAL
109774: IFFALSE 109785
// KillUnit ( vehicle ) ;
109776: LD_VAR 0 2
109780: PPUSH
109781: CALL_OW 66
109785: GO 109745
109787: POP
109788: POP
// end ;
109789: LD_VAR 0 3
109793: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109794: LD_EXP 163
109798: NOT
109799: IFFALSE 109834
109801: GO 109803
109803: DISABLE
// begin initMiner := true ;
109804: LD_ADDR_EXP 163
109808: PUSH
109809: LD_INT 1
109811: ST_TO_ADDR
// minersList := [ ] ;
109812: LD_ADDR_EXP 164
109816: PUSH
109817: EMPTY
109818: ST_TO_ADDR
// minerMinesList := [ ] ;
109819: LD_ADDR_EXP 165
109823: PUSH
109824: EMPTY
109825: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109826: LD_ADDR_EXP 166
109830: PUSH
109831: LD_INT 5
109833: ST_TO_ADDR
// end ;
109834: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109835: LD_EXP 163
109839: PUSH
109840: LD_INT 34
109842: PUSH
109843: LD_INT 81
109845: PUSH
109846: EMPTY
109847: LIST
109848: LIST
109849: PPUSH
109850: CALL_OW 69
109854: AND
109855: IFFALSE 110316
109857: GO 109859
109859: DISABLE
109860: LD_INT 0
109862: PPUSH
109863: PPUSH
109864: PPUSH
109865: PPUSH
// begin enable ;
109866: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109867: LD_ADDR_VAR 0 1
109871: PUSH
109872: LD_INT 34
109874: PUSH
109875: LD_INT 81
109877: PUSH
109878: EMPTY
109879: LIST
109880: LIST
109881: PPUSH
109882: CALL_OW 69
109886: PUSH
109887: FOR_IN
109888: IFFALSE 109960
// begin if not i in minersList then
109890: LD_VAR 0 1
109894: PUSH
109895: LD_EXP 164
109899: IN
109900: NOT
109901: IFFALSE 109958
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109903: LD_ADDR_EXP 164
109907: PUSH
109908: LD_EXP 164
109912: PPUSH
109913: LD_EXP 164
109917: PUSH
109918: LD_INT 1
109920: PLUS
109921: PPUSH
109922: LD_VAR 0 1
109926: PPUSH
109927: CALL_OW 1
109931: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109932: LD_ADDR_EXP 165
109936: PUSH
109937: LD_EXP 165
109941: PPUSH
109942: LD_EXP 165
109946: PUSH
109947: LD_INT 1
109949: PLUS
109950: PPUSH
109951: EMPTY
109952: PPUSH
109953: CALL_OW 1
109957: ST_TO_ADDR
// end end ;
109958: GO 109887
109960: POP
109961: POP
// for i := minerMinesList downto 1 do
109962: LD_ADDR_VAR 0 1
109966: PUSH
109967: DOUBLE
109968: LD_EXP 165
109972: INC
109973: ST_TO_ADDR
109974: LD_INT 1
109976: PUSH
109977: FOR_DOWNTO
109978: IFFALSE 110314
// begin if IsLive ( minersList [ i ] ) then
109980: LD_EXP 164
109984: PUSH
109985: LD_VAR 0 1
109989: ARRAY
109990: PPUSH
109991: CALL_OW 300
109995: IFFALSE 110023
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
109997: LD_EXP 164
110001: PUSH
110002: LD_VAR 0 1
110006: ARRAY
110007: PPUSH
110008: LD_EXP 165
110012: PUSH
110013: LD_VAR 0 1
110017: ARRAY
110018: PPUSH
110019: CALL_OW 505
// if not minerMinesList [ i ] then
110023: LD_EXP 165
110027: PUSH
110028: LD_VAR 0 1
110032: ARRAY
110033: NOT
110034: IFFALSE 110038
// continue ;
110036: GO 109977
// for j := minerMinesList [ i ] downto 1 do
110038: LD_ADDR_VAR 0 2
110042: PUSH
110043: DOUBLE
110044: LD_EXP 165
110048: PUSH
110049: LD_VAR 0 1
110053: ARRAY
110054: INC
110055: ST_TO_ADDR
110056: LD_INT 1
110058: PUSH
110059: FOR_DOWNTO
110060: IFFALSE 110310
// begin side := GetSide ( minersList [ i ] ) ;
110062: LD_ADDR_VAR 0 3
110066: PUSH
110067: LD_EXP 164
110071: PUSH
110072: LD_VAR 0 1
110076: ARRAY
110077: PPUSH
110078: CALL_OW 255
110082: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110083: LD_ADDR_VAR 0 4
110087: PUSH
110088: LD_EXP 165
110092: PUSH
110093: LD_VAR 0 1
110097: ARRAY
110098: PUSH
110099: LD_VAR 0 2
110103: ARRAY
110104: PUSH
110105: LD_INT 1
110107: ARRAY
110108: PPUSH
110109: LD_EXP 165
110113: PUSH
110114: LD_VAR 0 1
110118: ARRAY
110119: PUSH
110120: LD_VAR 0 2
110124: ARRAY
110125: PUSH
110126: LD_INT 2
110128: ARRAY
110129: PPUSH
110130: CALL_OW 428
110134: ST_TO_ADDR
// if not tmp then
110135: LD_VAR 0 4
110139: NOT
110140: IFFALSE 110144
// continue ;
110142: GO 110059
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110144: LD_VAR 0 4
110148: PUSH
110149: LD_INT 81
110151: PUSH
110152: LD_VAR 0 3
110156: PUSH
110157: EMPTY
110158: LIST
110159: LIST
110160: PPUSH
110161: CALL_OW 69
110165: IN
110166: PUSH
110167: LD_EXP 165
110171: PUSH
110172: LD_VAR 0 1
110176: ARRAY
110177: PUSH
110178: LD_VAR 0 2
110182: ARRAY
110183: PUSH
110184: LD_INT 1
110186: ARRAY
110187: PPUSH
110188: LD_EXP 165
110192: PUSH
110193: LD_VAR 0 1
110197: ARRAY
110198: PUSH
110199: LD_VAR 0 2
110203: ARRAY
110204: PUSH
110205: LD_INT 2
110207: ARRAY
110208: PPUSH
110209: CALL_OW 458
110213: AND
110214: IFFALSE 110308
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110216: LD_EXP 165
110220: PUSH
110221: LD_VAR 0 1
110225: ARRAY
110226: PUSH
110227: LD_VAR 0 2
110231: ARRAY
110232: PUSH
110233: LD_INT 1
110235: ARRAY
110236: PPUSH
110237: LD_EXP 165
110241: PUSH
110242: LD_VAR 0 1
110246: ARRAY
110247: PUSH
110248: LD_VAR 0 2
110252: ARRAY
110253: PUSH
110254: LD_INT 2
110256: ARRAY
110257: PPUSH
110258: LD_VAR 0 3
110262: PPUSH
110263: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110267: LD_ADDR_EXP 165
110271: PUSH
110272: LD_EXP 165
110276: PPUSH
110277: LD_VAR 0 1
110281: PPUSH
110282: LD_EXP 165
110286: PUSH
110287: LD_VAR 0 1
110291: ARRAY
110292: PPUSH
110293: LD_VAR 0 2
110297: PPUSH
110298: CALL_OW 3
110302: PPUSH
110303: CALL_OW 1
110307: ST_TO_ADDR
// end ; end ;
110308: GO 110059
110310: POP
110311: POP
// end ;
110312: GO 109977
110314: POP
110315: POP
// end ;
110316: PPOPN 4
110318: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110319: LD_INT 0
110321: PPUSH
110322: PPUSH
// result := false ;
110323: LD_ADDR_VAR 0 4
110327: PUSH
110328: LD_INT 0
110330: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110331: LD_VAR 0 1
110335: PPUSH
110336: CALL_OW 264
110340: PUSH
110341: LD_INT 81
110343: EQUAL
110344: NOT
110345: IFFALSE 110349
// exit ;
110347: GO 110589
// index := GetElementIndex ( minersList , unit ) ;
110349: LD_ADDR_VAR 0 5
110353: PUSH
110354: LD_EXP 164
110358: PPUSH
110359: LD_VAR 0 1
110363: PPUSH
110364: CALL 53852 0 2
110368: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110369: LD_EXP 165
110373: PUSH
110374: LD_VAR 0 5
110378: ARRAY
110379: PUSH
110380: LD_EXP 166
110384: GREATEREQUAL
110385: IFFALSE 110389
// exit ;
110387: GO 110589
// ComMoveXY ( unit , x , y ) ;
110389: LD_VAR 0 1
110393: PPUSH
110394: LD_VAR 0 2
110398: PPUSH
110399: LD_VAR 0 3
110403: PPUSH
110404: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110408: LD_INT 35
110410: PPUSH
110411: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110415: LD_VAR 0 1
110419: PPUSH
110420: LD_VAR 0 2
110424: PPUSH
110425: LD_VAR 0 3
110429: PPUSH
110430: CALL 85604 0 3
110434: NOT
110435: PUSH
110436: LD_VAR 0 1
110440: PPUSH
110441: CALL_OW 314
110445: AND
110446: IFFALSE 110450
// exit ;
110448: GO 110589
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110450: LD_VAR 0 2
110454: PPUSH
110455: LD_VAR 0 3
110459: PPUSH
110460: CALL_OW 428
110464: PUSH
110465: LD_VAR 0 1
110469: EQUAL
110470: PUSH
110471: LD_VAR 0 1
110475: PPUSH
110476: CALL_OW 314
110480: NOT
110481: AND
110482: IFFALSE 110408
// PlaySoundXY ( x , y , PlantMine ) ;
110484: LD_VAR 0 2
110488: PPUSH
110489: LD_VAR 0 3
110493: PPUSH
110494: LD_STRING PlantMine
110496: PPUSH
110497: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110501: LD_VAR 0 2
110505: PPUSH
110506: LD_VAR 0 3
110510: PPUSH
110511: LD_VAR 0 1
110515: PPUSH
110516: CALL_OW 255
110520: PPUSH
110521: LD_INT 0
110523: PPUSH
110524: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110528: LD_ADDR_EXP 165
110532: PUSH
110533: LD_EXP 165
110537: PPUSH
110538: LD_VAR 0 5
110542: PUSH
110543: LD_EXP 165
110547: PUSH
110548: LD_VAR 0 5
110552: ARRAY
110553: PUSH
110554: LD_INT 1
110556: PLUS
110557: PUSH
110558: EMPTY
110559: LIST
110560: LIST
110561: PPUSH
110562: LD_VAR 0 2
110566: PUSH
110567: LD_VAR 0 3
110571: PUSH
110572: EMPTY
110573: LIST
110574: LIST
110575: PPUSH
110576: CALL 54067 0 3
110580: ST_TO_ADDR
// result := true ;
110581: LD_ADDR_VAR 0 4
110585: PUSH
110586: LD_INT 1
110588: ST_TO_ADDR
// end ;
110589: LD_VAR 0 4
110593: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110594: LD_INT 0
110596: PPUSH
110597: PPUSH
110598: PPUSH
// if not unit in minersList then
110599: LD_VAR 0 1
110603: PUSH
110604: LD_EXP 164
110608: IN
110609: NOT
110610: IFFALSE 110614
// exit ;
110612: GO 111006
// index := GetElementIndex ( minersList , unit ) ;
110614: LD_ADDR_VAR 0 6
110618: PUSH
110619: LD_EXP 164
110623: PPUSH
110624: LD_VAR 0 1
110628: PPUSH
110629: CALL 53852 0 2
110633: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110634: LD_ADDR_VAR 0 5
110638: PUSH
110639: DOUBLE
110640: LD_EXP 165
110644: PUSH
110645: LD_VAR 0 6
110649: ARRAY
110650: INC
110651: ST_TO_ADDR
110652: LD_INT 1
110654: PUSH
110655: FOR_DOWNTO
110656: IFFALSE 110817
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110658: LD_EXP 165
110662: PUSH
110663: LD_VAR 0 6
110667: ARRAY
110668: PUSH
110669: LD_VAR 0 5
110673: ARRAY
110674: PUSH
110675: LD_INT 1
110677: ARRAY
110678: PUSH
110679: LD_VAR 0 2
110683: EQUAL
110684: PUSH
110685: LD_EXP 165
110689: PUSH
110690: LD_VAR 0 6
110694: ARRAY
110695: PUSH
110696: LD_VAR 0 5
110700: ARRAY
110701: PUSH
110702: LD_INT 2
110704: ARRAY
110705: PUSH
110706: LD_VAR 0 3
110710: EQUAL
110711: AND
110712: IFFALSE 110815
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110714: LD_EXP 165
110718: PUSH
110719: LD_VAR 0 6
110723: ARRAY
110724: PUSH
110725: LD_VAR 0 5
110729: ARRAY
110730: PUSH
110731: LD_INT 1
110733: ARRAY
110734: PPUSH
110735: LD_EXP 165
110739: PUSH
110740: LD_VAR 0 6
110744: ARRAY
110745: PUSH
110746: LD_VAR 0 5
110750: ARRAY
110751: PUSH
110752: LD_INT 2
110754: ARRAY
110755: PPUSH
110756: LD_VAR 0 1
110760: PPUSH
110761: CALL_OW 255
110765: PPUSH
110766: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110770: LD_ADDR_EXP 165
110774: PUSH
110775: LD_EXP 165
110779: PPUSH
110780: LD_VAR 0 6
110784: PPUSH
110785: LD_EXP 165
110789: PUSH
110790: LD_VAR 0 6
110794: ARRAY
110795: PPUSH
110796: LD_VAR 0 5
110800: PPUSH
110801: CALL_OW 3
110805: PPUSH
110806: CALL_OW 1
110810: ST_TO_ADDR
// exit ;
110811: POP
110812: POP
110813: GO 111006
// end ; end ;
110815: GO 110655
110817: POP
110818: POP
// for i := minerMinesList [ index ] downto 1 do
110819: LD_ADDR_VAR 0 5
110823: PUSH
110824: DOUBLE
110825: LD_EXP 165
110829: PUSH
110830: LD_VAR 0 6
110834: ARRAY
110835: INC
110836: ST_TO_ADDR
110837: LD_INT 1
110839: PUSH
110840: FOR_DOWNTO
110841: IFFALSE 111004
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110843: LD_EXP 165
110847: PUSH
110848: LD_VAR 0 6
110852: ARRAY
110853: PUSH
110854: LD_VAR 0 5
110858: ARRAY
110859: PUSH
110860: LD_INT 1
110862: ARRAY
110863: PPUSH
110864: LD_EXP 165
110868: PUSH
110869: LD_VAR 0 6
110873: ARRAY
110874: PUSH
110875: LD_VAR 0 5
110879: ARRAY
110880: PUSH
110881: LD_INT 2
110883: ARRAY
110884: PPUSH
110885: LD_VAR 0 2
110889: PPUSH
110890: LD_VAR 0 3
110894: PPUSH
110895: CALL_OW 298
110899: PUSH
110900: LD_INT 6
110902: LESS
110903: IFFALSE 111002
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110905: LD_EXP 165
110909: PUSH
110910: LD_VAR 0 6
110914: ARRAY
110915: PUSH
110916: LD_VAR 0 5
110920: ARRAY
110921: PUSH
110922: LD_INT 1
110924: ARRAY
110925: PPUSH
110926: LD_EXP 165
110930: PUSH
110931: LD_VAR 0 6
110935: ARRAY
110936: PUSH
110937: LD_VAR 0 5
110941: ARRAY
110942: PUSH
110943: LD_INT 2
110945: ARRAY
110946: PPUSH
110947: LD_VAR 0 1
110951: PPUSH
110952: CALL_OW 255
110956: PPUSH
110957: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110961: LD_ADDR_EXP 165
110965: PUSH
110966: LD_EXP 165
110970: PPUSH
110971: LD_VAR 0 6
110975: PPUSH
110976: LD_EXP 165
110980: PUSH
110981: LD_VAR 0 6
110985: ARRAY
110986: PPUSH
110987: LD_VAR 0 5
110991: PPUSH
110992: CALL_OW 3
110996: PPUSH
110997: CALL_OW 1
111001: ST_TO_ADDR
// end ; end ;
111002: GO 110840
111004: POP
111005: POP
// end ;
111006: LD_VAR 0 4
111010: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111011: LD_INT 0
111013: PPUSH
111014: PPUSH
111015: PPUSH
111016: PPUSH
111017: PPUSH
111018: PPUSH
111019: PPUSH
111020: PPUSH
111021: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111022: LD_VAR 0 1
111026: PPUSH
111027: CALL_OW 264
111031: PUSH
111032: LD_INT 81
111034: EQUAL
111035: NOT
111036: PUSH
111037: LD_VAR 0 1
111041: PUSH
111042: LD_EXP 164
111046: IN
111047: NOT
111048: OR
111049: IFFALSE 111053
// exit ;
111051: GO 111375
// index := GetElementIndex ( minersList , unit ) ;
111053: LD_ADDR_VAR 0 6
111057: PUSH
111058: LD_EXP 164
111062: PPUSH
111063: LD_VAR 0 1
111067: PPUSH
111068: CALL 53852 0 2
111072: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111073: LD_ADDR_VAR 0 8
111077: PUSH
111078: LD_EXP 166
111082: PUSH
111083: LD_EXP 165
111087: PUSH
111088: LD_VAR 0 6
111092: ARRAY
111093: MINUS
111094: ST_TO_ADDR
// if not minesFreeAmount then
111095: LD_VAR 0 8
111099: NOT
111100: IFFALSE 111104
// exit ;
111102: GO 111375
// tmp := [ ] ;
111104: LD_ADDR_VAR 0 7
111108: PUSH
111109: EMPTY
111110: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111111: LD_ADDR_VAR 0 5
111115: PUSH
111116: DOUBLE
111117: LD_INT 1
111119: DEC
111120: ST_TO_ADDR
111121: LD_VAR 0 8
111125: PUSH
111126: FOR_TO
111127: IFFALSE 111322
// begin _d := rand ( 0 , 5 ) ;
111129: LD_ADDR_VAR 0 11
111133: PUSH
111134: LD_INT 0
111136: PPUSH
111137: LD_INT 5
111139: PPUSH
111140: CALL_OW 12
111144: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111145: LD_ADDR_VAR 0 12
111149: PUSH
111150: LD_INT 2
111152: PPUSH
111153: LD_INT 6
111155: PPUSH
111156: CALL_OW 12
111160: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111161: LD_ADDR_VAR 0 9
111165: PUSH
111166: LD_VAR 0 2
111170: PPUSH
111171: LD_VAR 0 11
111175: PPUSH
111176: LD_VAR 0 12
111180: PPUSH
111181: CALL_OW 272
111185: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111186: LD_ADDR_VAR 0 10
111190: PUSH
111191: LD_VAR 0 3
111195: PPUSH
111196: LD_VAR 0 11
111200: PPUSH
111201: LD_VAR 0 12
111205: PPUSH
111206: CALL_OW 273
111210: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111211: LD_VAR 0 9
111215: PPUSH
111216: LD_VAR 0 10
111220: PPUSH
111221: CALL_OW 488
111225: PUSH
111226: LD_VAR 0 9
111230: PUSH
111231: LD_VAR 0 10
111235: PUSH
111236: EMPTY
111237: LIST
111238: LIST
111239: PUSH
111240: LD_VAR 0 7
111244: IN
111245: NOT
111246: AND
111247: PUSH
111248: LD_VAR 0 9
111252: PPUSH
111253: LD_VAR 0 10
111257: PPUSH
111258: CALL_OW 458
111262: NOT
111263: AND
111264: IFFALSE 111306
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111266: LD_ADDR_VAR 0 7
111270: PUSH
111271: LD_VAR 0 7
111275: PPUSH
111276: LD_VAR 0 7
111280: PUSH
111281: LD_INT 1
111283: PLUS
111284: PPUSH
111285: LD_VAR 0 9
111289: PUSH
111290: LD_VAR 0 10
111294: PUSH
111295: EMPTY
111296: LIST
111297: LIST
111298: PPUSH
111299: CALL_OW 1
111303: ST_TO_ADDR
111304: GO 111320
// i := i - 1 ;
111306: LD_ADDR_VAR 0 5
111310: PUSH
111311: LD_VAR 0 5
111315: PUSH
111316: LD_INT 1
111318: MINUS
111319: ST_TO_ADDR
// end ;
111320: GO 111126
111322: POP
111323: POP
// for i in tmp do
111324: LD_ADDR_VAR 0 5
111328: PUSH
111329: LD_VAR 0 7
111333: PUSH
111334: FOR_IN
111335: IFFALSE 111373
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111337: LD_VAR 0 1
111341: PPUSH
111342: LD_VAR 0 5
111346: PUSH
111347: LD_INT 1
111349: ARRAY
111350: PPUSH
111351: LD_VAR 0 5
111355: PUSH
111356: LD_INT 2
111358: ARRAY
111359: PPUSH
111360: CALL 110319 0 3
111364: NOT
111365: IFFALSE 111371
// exit ;
111367: POP
111368: POP
111369: GO 111375
111371: GO 111334
111373: POP
111374: POP
// end ;
111375: LD_VAR 0 4
111379: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111380: LD_INT 0
111382: PPUSH
111383: PPUSH
111384: PPUSH
111385: PPUSH
111386: PPUSH
111387: PPUSH
111388: PPUSH
// if not GetClass ( unit ) = class_sniper then
111389: LD_VAR 0 1
111393: PPUSH
111394: CALL_OW 257
111398: PUSH
111399: LD_INT 5
111401: EQUAL
111402: NOT
111403: IFFALSE 111407
// exit ;
111405: GO 111795
// dist := 8 ;
111407: LD_ADDR_VAR 0 5
111411: PUSH
111412: LD_INT 8
111414: ST_TO_ADDR
// viewRange := 12 ;
111415: LD_ADDR_VAR 0 7
111419: PUSH
111420: LD_INT 12
111422: ST_TO_ADDR
// side := GetSide ( unit ) ;
111423: LD_ADDR_VAR 0 6
111427: PUSH
111428: LD_VAR 0 1
111432: PPUSH
111433: CALL_OW 255
111437: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111438: LD_INT 61
111440: PPUSH
111441: LD_VAR 0 6
111445: PPUSH
111446: CALL_OW 321
111450: PUSH
111451: LD_INT 2
111453: EQUAL
111454: IFFALSE 111464
// viewRange := 16 ;
111456: LD_ADDR_VAR 0 7
111460: PUSH
111461: LD_INT 16
111463: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111464: LD_VAR 0 1
111468: PPUSH
111469: LD_VAR 0 2
111473: PPUSH
111474: LD_VAR 0 3
111478: PPUSH
111479: CALL_OW 297
111483: PUSH
111484: LD_VAR 0 5
111488: GREATER
111489: IFFALSE 111568
// begin ComMoveXY ( unit , x , y ) ;
111491: LD_VAR 0 1
111495: PPUSH
111496: LD_VAR 0 2
111500: PPUSH
111501: LD_VAR 0 3
111505: PPUSH
111506: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111510: LD_INT 35
111512: PPUSH
111513: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111517: LD_VAR 0 1
111521: PPUSH
111522: LD_VAR 0 2
111526: PPUSH
111527: LD_VAR 0 3
111531: PPUSH
111532: CALL 85604 0 3
111536: NOT
111537: IFFALSE 111541
// exit ;
111539: GO 111795
// until GetDistUnitXY ( unit , x , y ) < dist ;
111541: LD_VAR 0 1
111545: PPUSH
111546: LD_VAR 0 2
111550: PPUSH
111551: LD_VAR 0 3
111555: PPUSH
111556: CALL_OW 297
111560: PUSH
111561: LD_VAR 0 5
111565: LESS
111566: IFFALSE 111510
// end ; ComTurnXY ( unit , x , y ) ;
111568: LD_VAR 0 1
111572: PPUSH
111573: LD_VAR 0 2
111577: PPUSH
111578: LD_VAR 0 3
111582: PPUSH
111583: CALL_OW 118
// wait ( 5 ) ;
111587: LD_INT 5
111589: PPUSH
111590: CALL_OW 67
// _d := GetDir ( unit ) ;
111594: LD_ADDR_VAR 0 10
111598: PUSH
111599: LD_VAR 0 1
111603: PPUSH
111604: CALL_OW 254
111608: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111609: LD_ADDR_VAR 0 8
111613: PUSH
111614: LD_VAR 0 1
111618: PPUSH
111619: CALL_OW 250
111623: PPUSH
111624: LD_VAR 0 10
111628: PPUSH
111629: LD_VAR 0 5
111633: PPUSH
111634: CALL_OW 272
111638: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111639: LD_ADDR_VAR 0 9
111643: PUSH
111644: LD_VAR 0 1
111648: PPUSH
111649: CALL_OW 251
111653: PPUSH
111654: LD_VAR 0 10
111658: PPUSH
111659: LD_VAR 0 5
111663: PPUSH
111664: CALL_OW 273
111668: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111669: LD_VAR 0 8
111673: PPUSH
111674: LD_VAR 0 9
111678: PPUSH
111679: CALL_OW 488
111683: NOT
111684: IFFALSE 111688
// exit ;
111686: GO 111795
// ComAnimCustom ( unit , 1 ) ;
111688: LD_VAR 0 1
111692: PPUSH
111693: LD_INT 1
111695: PPUSH
111696: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111700: LD_VAR 0 8
111704: PPUSH
111705: LD_VAR 0 9
111709: PPUSH
111710: LD_VAR 0 6
111714: PPUSH
111715: LD_VAR 0 7
111719: PPUSH
111720: CALL_OW 330
// repeat wait ( 1 ) ;
111724: LD_INT 1
111726: PPUSH
111727: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111731: LD_VAR 0 1
111735: PPUSH
111736: CALL_OW 316
111740: PUSH
111741: LD_VAR 0 1
111745: PPUSH
111746: CALL_OW 314
111750: OR
111751: PUSH
111752: LD_VAR 0 1
111756: PPUSH
111757: CALL_OW 302
111761: NOT
111762: OR
111763: PUSH
111764: LD_VAR 0 1
111768: PPUSH
111769: CALL_OW 301
111773: OR
111774: IFFALSE 111724
// RemoveSeeing ( _x , _y , side ) ;
111776: LD_VAR 0 8
111780: PPUSH
111781: LD_VAR 0 9
111785: PPUSH
111786: LD_VAR 0 6
111790: PPUSH
111791: CALL_OW 331
// end ; end_of_file
111795: LD_VAR 0 4
111799: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111800: LD_INT 0
111802: PPUSH
111803: PPUSH
111804: PPUSH
111805: PPUSH
111806: PPUSH
111807: PPUSH
111808: PPUSH
111809: PPUSH
111810: PPUSH
111811: PPUSH
111812: PPUSH
111813: PPUSH
111814: PPUSH
111815: PPUSH
111816: PPUSH
111817: PPUSH
111818: PPUSH
111819: PPUSH
111820: PPUSH
111821: PPUSH
111822: PPUSH
111823: PPUSH
111824: PPUSH
111825: PPUSH
111826: PPUSH
111827: PPUSH
111828: PPUSH
111829: PPUSH
111830: PPUSH
111831: PPUSH
111832: PPUSH
111833: PPUSH
111834: PPUSH
111835: PPUSH
// if not list then
111836: LD_VAR 0 1
111840: NOT
111841: IFFALSE 111845
// exit ;
111843: GO 116504
// base := list [ 1 ] ;
111845: LD_ADDR_VAR 0 3
111849: PUSH
111850: LD_VAR 0 1
111854: PUSH
111855: LD_INT 1
111857: ARRAY
111858: ST_TO_ADDR
// group := list [ 2 ] ;
111859: LD_ADDR_VAR 0 4
111863: PUSH
111864: LD_VAR 0 1
111868: PUSH
111869: LD_INT 2
111871: ARRAY
111872: ST_TO_ADDR
// path := list [ 3 ] ;
111873: LD_ADDR_VAR 0 5
111877: PUSH
111878: LD_VAR 0 1
111882: PUSH
111883: LD_INT 3
111885: ARRAY
111886: ST_TO_ADDR
// flags := list [ 4 ] ;
111887: LD_ADDR_VAR 0 6
111891: PUSH
111892: LD_VAR 0 1
111896: PUSH
111897: LD_INT 4
111899: ARRAY
111900: ST_TO_ADDR
// mined := [ ] ;
111901: LD_ADDR_VAR 0 27
111905: PUSH
111906: EMPTY
111907: ST_TO_ADDR
// bombed := [ ] ;
111908: LD_ADDR_VAR 0 28
111912: PUSH
111913: EMPTY
111914: ST_TO_ADDR
// healers := [ ] ;
111915: LD_ADDR_VAR 0 31
111919: PUSH
111920: EMPTY
111921: ST_TO_ADDR
// to_heal := [ ] ;
111922: LD_ADDR_VAR 0 30
111926: PUSH
111927: EMPTY
111928: ST_TO_ADDR
// repairs := [ ] ;
111929: LD_ADDR_VAR 0 33
111933: PUSH
111934: EMPTY
111935: ST_TO_ADDR
// to_repair := [ ] ;
111936: LD_ADDR_VAR 0 32
111940: PUSH
111941: EMPTY
111942: ST_TO_ADDR
// if not group or not path then
111943: LD_VAR 0 4
111947: NOT
111948: PUSH
111949: LD_VAR 0 5
111953: NOT
111954: OR
111955: IFFALSE 111959
// exit ;
111957: GO 116504
// side := GetSide ( group [ 1 ] ) ;
111959: LD_ADDR_VAR 0 35
111963: PUSH
111964: LD_VAR 0 4
111968: PUSH
111969: LD_INT 1
111971: ARRAY
111972: PPUSH
111973: CALL_OW 255
111977: ST_TO_ADDR
// if flags then
111978: LD_VAR 0 6
111982: IFFALSE 112126
// begin f_ignore_area := flags [ 1 ] ;
111984: LD_ADDR_VAR 0 17
111988: PUSH
111989: LD_VAR 0 6
111993: PUSH
111994: LD_INT 1
111996: ARRAY
111997: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
111998: LD_ADDR_VAR 0 18
112002: PUSH
112003: LD_VAR 0 6
112007: PUSH
112008: LD_INT 2
112010: ARRAY
112011: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112012: LD_ADDR_VAR 0 19
112016: PUSH
112017: LD_VAR 0 6
112021: PUSH
112022: LD_INT 3
112024: ARRAY
112025: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112026: LD_ADDR_VAR 0 20
112030: PUSH
112031: LD_VAR 0 6
112035: PUSH
112036: LD_INT 4
112038: ARRAY
112039: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112040: LD_ADDR_VAR 0 21
112044: PUSH
112045: LD_VAR 0 6
112049: PUSH
112050: LD_INT 5
112052: ARRAY
112053: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112054: LD_ADDR_VAR 0 22
112058: PUSH
112059: LD_VAR 0 6
112063: PUSH
112064: LD_INT 6
112066: ARRAY
112067: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112068: LD_ADDR_VAR 0 23
112072: PUSH
112073: LD_VAR 0 6
112077: PUSH
112078: LD_INT 7
112080: ARRAY
112081: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112082: LD_ADDR_VAR 0 24
112086: PUSH
112087: LD_VAR 0 6
112091: PUSH
112092: LD_INT 8
112094: ARRAY
112095: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112096: LD_ADDR_VAR 0 25
112100: PUSH
112101: LD_VAR 0 6
112105: PUSH
112106: LD_INT 9
112108: ARRAY
112109: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112110: LD_ADDR_VAR 0 26
112114: PUSH
112115: LD_VAR 0 6
112119: PUSH
112120: LD_INT 10
112122: ARRAY
112123: ST_TO_ADDR
// end else
112124: GO 112206
// begin f_ignore_area := false ;
112126: LD_ADDR_VAR 0 17
112130: PUSH
112131: LD_INT 0
112133: ST_TO_ADDR
// f_capture := false ;
112134: LD_ADDR_VAR 0 18
112138: PUSH
112139: LD_INT 0
112141: ST_TO_ADDR
// f_ignore_civ := false ;
112142: LD_ADDR_VAR 0 19
112146: PUSH
112147: LD_INT 0
112149: ST_TO_ADDR
// f_murder := false ;
112150: LD_ADDR_VAR 0 20
112154: PUSH
112155: LD_INT 0
112157: ST_TO_ADDR
// f_mines := false ;
112158: LD_ADDR_VAR 0 21
112162: PUSH
112163: LD_INT 0
112165: ST_TO_ADDR
// f_repair := false ;
112166: LD_ADDR_VAR 0 22
112170: PUSH
112171: LD_INT 0
112173: ST_TO_ADDR
// f_heal := false ;
112174: LD_ADDR_VAR 0 23
112178: PUSH
112179: LD_INT 0
112181: ST_TO_ADDR
// f_spacetime := false ;
112182: LD_ADDR_VAR 0 24
112186: PUSH
112187: LD_INT 0
112189: ST_TO_ADDR
// f_attack_depot := false ;
112190: LD_ADDR_VAR 0 25
112194: PUSH
112195: LD_INT 0
112197: ST_TO_ADDR
// f_crawl := false ;
112198: LD_ADDR_VAR 0 26
112202: PUSH
112203: LD_INT 0
112205: ST_TO_ADDR
// end ; if f_heal then
112206: LD_VAR 0 23
112210: IFFALSE 112237
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112212: LD_ADDR_VAR 0 31
112216: PUSH
112217: LD_VAR 0 4
112221: PPUSH
112222: LD_INT 25
112224: PUSH
112225: LD_INT 4
112227: PUSH
112228: EMPTY
112229: LIST
112230: LIST
112231: PPUSH
112232: CALL_OW 72
112236: ST_TO_ADDR
// if f_repair then
112237: LD_VAR 0 22
112241: IFFALSE 112268
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112243: LD_ADDR_VAR 0 33
112247: PUSH
112248: LD_VAR 0 4
112252: PPUSH
112253: LD_INT 25
112255: PUSH
112256: LD_INT 3
112258: PUSH
112259: EMPTY
112260: LIST
112261: LIST
112262: PPUSH
112263: CALL_OW 72
112267: ST_TO_ADDR
// units_path := [ ] ;
112268: LD_ADDR_VAR 0 16
112272: PUSH
112273: EMPTY
112274: ST_TO_ADDR
// for i = 1 to group do
112275: LD_ADDR_VAR 0 7
112279: PUSH
112280: DOUBLE
112281: LD_INT 1
112283: DEC
112284: ST_TO_ADDR
112285: LD_VAR 0 4
112289: PUSH
112290: FOR_TO
112291: IFFALSE 112320
// units_path := Replace ( units_path , i , path ) ;
112293: LD_ADDR_VAR 0 16
112297: PUSH
112298: LD_VAR 0 16
112302: PPUSH
112303: LD_VAR 0 7
112307: PPUSH
112308: LD_VAR 0 5
112312: PPUSH
112313: CALL_OW 1
112317: ST_TO_ADDR
112318: GO 112290
112320: POP
112321: POP
// repeat for i = group downto 1 do
112322: LD_ADDR_VAR 0 7
112326: PUSH
112327: DOUBLE
112328: LD_VAR 0 4
112332: INC
112333: ST_TO_ADDR
112334: LD_INT 1
112336: PUSH
112337: FOR_DOWNTO
112338: IFFALSE 116460
// begin wait ( 5 ) ;
112340: LD_INT 5
112342: PPUSH
112343: CALL_OW 67
// tmp := [ ] ;
112347: LD_ADDR_VAR 0 14
112351: PUSH
112352: EMPTY
112353: ST_TO_ADDR
// attacking := false ;
112354: LD_ADDR_VAR 0 29
112358: PUSH
112359: LD_INT 0
112361: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112362: LD_VAR 0 4
112366: PUSH
112367: LD_VAR 0 7
112371: ARRAY
112372: PPUSH
112373: CALL_OW 301
112377: PUSH
112378: LD_VAR 0 4
112382: PUSH
112383: LD_VAR 0 7
112387: ARRAY
112388: NOT
112389: OR
112390: IFFALSE 112499
// begin if GetType ( group [ i ] ) = unit_human then
112392: LD_VAR 0 4
112396: PUSH
112397: LD_VAR 0 7
112401: ARRAY
112402: PPUSH
112403: CALL_OW 247
112407: PUSH
112408: LD_INT 1
112410: EQUAL
112411: IFFALSE 112457
// begin to_heal := to_heal diff group [ i ] ;
112413: LD_ADDR_VAR 0 30
112417: PUSH
112418: LD_VAR 0 30
112422: PUSH
112423: LD_VAR 0 4
112427: PUSH
112428: LD_VAR 0 7
112432: ARRAY
112433: DIFF
112434: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112435: LD_ADDR_VAR 0 31
112439: PUSH
112440: LD_VAR 0 31
112444: PUSH
112445: LD_VAR 0 4
112449: PUSH
112450: LD_VAR 0 7
112454: ARRAY
112455: DIFF
112456: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112457: LD_ADDR_VAR 0 4
112461: PUSH
112462: LD_VAR 0 4
112466: PPUSH
112467: LD_VAR 0 7
112471: PPUSH
112472: CALL_OW 3
112476: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112477: LD_ADDR_VAR 0 16
112481: PUSH
112482: LD_VAR 0 16
112486: PPUSH
112487: LD_VAR 0 7
112491: PPUSH
112492: CALL_OW 3
112496: ST_TO_ADDR
// continue ;
112497: GO 112337
// end ; if f_repair then
112499: LD_VAR 0 22
112503: IFFALSE 112992
// begin if GetType ( group [ i ] ) = unit_vehicle then
112505: LD_VAR 0 4
112509: PUSH
112510: LD_VAR 0 7
112514: ARRAY
112515: PPUSH
112516: CALL_OW 247
112520: PUSH
112521: LD_INT 2
112523: EQUAL
112524: IFFALSE 112714
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112526: LD_VAR 0 4
112530: PUSH
112531: LD_VAR 0 7
112535: ARRAY
112536: PPUSH
112537: CALL_OW 256
112541: PUSH
112542: LD_INT 700
112544: LESS
112545: PUSH
112546: LD_VAR 0 4
112550: PUSH
112551: LD_VAR 0 7
112555: ARRAY
112556: PUSH
112557: LD_VAR 0 32
112561: IN
112562: NOT
112563: AND
112564: IFFALSE 112588
// to_repair := to_repair union group [ i ] ;
112566: LD_ADDR_VAR 0 32
112570: PUSH
112571: LD_VAR 0 32
112575: PUSH
112576: LD_VAR 0 4
112580: PUSH
112581: LD_VAR 0 7
112585: ARRAY
112586: UNION
112587: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112588: LD_VAR 0 4
112592: PUSH
112593: LD_VAR 0 7
112597: ARRAY
112598: PPUSH
112599: CALL_OW 256
112603: PUSH
112604: LD_INT 1000
112606: EQUAL
112607: PUSH
112608: LD_VAR 0 4
112612: PUSH
112613: LD_VAR 0 7
112617: ARRAY
112618: PUSH
112619: LD_VAR 0 32
112623: IN
112624: AND
112625: IFFALSE 112649
// to_repair := to_repair diff group [ i ] ;
112627: LD_ADDR_VAR 0 32
112631: PUSH
112632: LD_VAR 0 32
112636: PUSH
112637: LD_VAR 0 4
112641: PUSH
112642: LD_VAR 0 7
112646: ARRAY
112647: DIFF
112648: ST_TO_ADDR
// if group [ i ] in to_repair then
112649: LD_VAR 0 4
112653: PUSH
112654: LD_VAR 0 7
112658: ARRAY
112659: PUSH
112660: LD_VAR 0 32
112664: IN
112665: IFFALSE 112712
// begin if not IsInArea ( group [ i ] , f_repair ) then
112667: LD_VAR 0 4
112671: PUSH
112672: LD_VAR 0 7
112676: ARRAY
112677: PPUSH
112678: LD_VAR 0 22
112682: PPUSH
112683: CALL_OW 308
112687: NOT
112688: IFFALSE 112710
// ComMoveToArea ( group [ i ] , f_repair ) ;
112690: LD_VAR 0 4
112694: PUSH
112695: LD_VAR 0 7
112699: ARRAY
112700: PPUSH
112701: LD_VAR 0 22
112705: PPUSH
112706: CALL_OW 113
// continue ;
112710: GO 112337
// end ; end else
112712: GO 112992
// if group [ i ] in repairs then
112714: LD_VAR 0 4
112718: PUSH
112719: LD_VAR 0 7
112723: ARRAY
112724: PUSH
112725: LD_VAR 0 33
112729: IN
112730: IFFALSE 112992
// begin if IsInUnit ( group [ i ] ) then
112732: LD_VAR 0 4
112736: PUSH
112737: LD_VAR 0 7
112741: ARRAY
112742: PPUSH
112743: CALL_OW 310
112747: IFFALSE 112815
// begin z := IsInUnit ( group [ i ] ) ;
112749: LD_ADDR_VAR 0 13
112753: PUSH
112754: LD_VAR 0 4
112758: PUSH
112759: LD_VAR 0 7
112763: ARRAY
112764: PPUSH
112765: CALL_OW 310
112769: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112770: LD_VAR 0 13
112774: PUSH
112775: LD_VAR 0 32
112779: IN
112780: PUSH
112781: LD_VAR 0 13
112785: PPUSH
112786: LD_VAR 0 22
112790: PPUSH
112791: CALL_OW 308
112795: AND
112796: IFFALSE 112813
// ComExitVehicle ( group [ i ] ) ;
112798: LD_VAR 0 4
112802: PUSH
112803: LD_VAR 0 7
112807: ARRAY
112808: PPUSH
112809: CALL_OW 121
// end else
112813: GO 112992
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112815: LD_ADDR_VAR 0 13
112819: PUSH
112820: LD_VAR 0 4
112824: PPUSH
112825: LD_INT 95
112827: PUSH
112828: LD_VAR 0 22
112832: PUSH
112833: EMPTY
112834: LIST
112835: LIST
112836: PUSH
112837: LD_INT 58
112839: PUSH
112840: EMPTY
112841: LIST
112842: PUSH
112843: EMPTY
112844: LIST
112845: LIST
112846: PPUSH
112847: CALL_OW 72
112851: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112852: LD_VAR 0 4
112856: PUSH
112857: LD_VAR 0 7
112861: ARRAY
112862: PPUSH
112863: CALL_OW 314
112867: NOT
112868: IFFALSE 112990
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112870: LD_ADDR_VAR 0 10
112874: PUSH
112875: LD_VAR 0 13
112879: PPUSH
112880: LD_VAR 0 4
112884: PUSH
112885: LD_VAR 0 7
112889: ARRAY
112890: PPUSH
112891: CALL_OW 74
112895: ST_TO_ADDR
// if not x then
112896: LD_VAR 0 10
112900: NOT
112901: IFFALSE 112905
// continue ;
112903: GO 112337
// if GetLives ( x ) < 1000 then
112905: LD_VAR 0 10
112909: PPUSH
112910: CALL_OW 256
112914: PUSH
112915: LD_INT 1000
112917: LESS
112918: IFFALSE 112942
// ComRepairVehicle ( group [ i ] , x ) else
112920: LD_VAR 0 4
112924: PUSH
112925: LD_VAR 0 7
112929: ARRAY
112930: PPUSH
112931: LD_VAR 0 10
112935: PPUSH
112936: CALL_OW 129
112940: GO 112990
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112942: LD_VAR 0 23
112946: PUSH
112947: LD_VAR 0 4
112951: PUSH
112952: LD_VAR 0 7
112956: ARRAY
112957: PPUSH
112958: CALL_OW 256
112962: PUSH
112963: LD_INT 1000
112965: LESS
112966: AND
112967: NOT
112968: IFFALSE 112990
// ComEnterUnit ( group [ i ] , x ) ;
112970: LD_VAR 0 4
112974: PUSH
112975: LD_VAR 0 7
112979: ARRAY
112980: PPUSH
112981: LD_VAR 0 10
112985: PPUSH
112986: CALL_OW 120
// end ; continue ;
112990: GO 112337
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
112992: LD_VAR 0 23
112996: PUSH
112997: LD_VAR 0 4
113001: PUSH
113002: LD_VAR 0 7
113006: ARRAY
113007: PPUSH
113008: CALL_OW 247
113012: PUSH
113013: LD_INT 1
113015: EQUAL
113016: AND
113017: IFFALSE 113495
// begin if group [ i ] in healers then
113019: LD_VAR 0 4
113023: PUSH
113024: LD_VAR 0 7
113028: ARRAY
113029: PUSH
113030: LD_VAR 0 31
113034: IN
113035: IFFALSE 113308
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113037: LD_VAR 0 4
113041: PUSH
113042: LD_VAR 0 7
113046: ARRAY
113047: PPUSH
113048: LD_VAR 0 23
113052: PPUSH
113053: CALL_OW 308
113057: NOT
113058: PUSH
113059: LD_VAR 0 4
113063: PUSH
113064: LD_VAR 0 7
113068: ARRAY
113069: PPUSH
113070: CALL_OW 314
113074: NOT
113075: AND
113076: IFFALSE 113100
// ComMoveToArea ( group [ i ] , f_heal ) else
113078: LD_VAR 0 4
113082: PUSH
113083: LD_VAR 0 7
113087: ARRAY
113088: PPUSH
113089: LD_VAR 0 23
113093: PPUSH
113094: CALL_OW 113
113098: GO 113306
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113100: LD_VAR 0 4
113104: PUSH
113105: LD_VAR 0 7
113109: ARRAY
113110: PPUSH
113111: CALL 84187 0 1
113115: PPUSH
113116: CALL_OW 256
113120: PUSH
113121: LD_INT 1000
113123: EQUAL
113124: IFFALSE 113143
// ComStop ( group [ i ] ) else
113126: LD_VAR 0 4
113130: PUSH
113131: LD_VAR 0 7
113135: ARRAY
113136: PPUSH
113137: CALL_OW 141
113141: GO 113306
// if not HasTask ( group [ i ] ) and to_heal then
113143: LD_VAR 0 4
113147: PUSH
113148: LD_VAR 0 7
113152: ARRAY
113153: PPUSH
113154: CALL_OW 314
113158: NOT
113159: PUSH
113160: LD_VAR 0 30
113164: AND
113165: IFFALSE 113306
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113167: LD_ADDR_VAR 0 13
113171: PUSH
113172: LD_VAR 0 30
113176: PPUSH
113177: LD_INT 3
113179: PUSH
113180: LD_INT 54
113182: PUSH
113183: EMPTY
113184: LIST
113185: PUSH
113186: EMPTY
113187: LIST
113188: LIST
113189: PPUSH
113190: CALL_OW 72
113194: PPUSH
113195: LD_VAR 0 4
113199: PUSH
113200: LD_VAR 0 7
113204: ARRAY
113205: PPUSH
113206: CALL_OW 74
113210: ST_TO_ADDR
// if z then
113211: LD_VAR 0 13
113215: IFFALSE 113306
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113217: LD_INT 91
113219: PUSH
113220: LD_VAR 0 13
113224: PUSH
113225: LD_INT 10
113227: PUSH
113228: EMPTY
113229: LIST
113230: LIST
113231: LIST
113232: PUSH
113233: LD_INT 81
113235: PUSH
113236: LD_VAR 0 13
113240: PPUSH
113241: CALL_OW 255
113245: PUSH
113246: EMPTY
113247: LIST
113248: LIST
113249: PUSH
113250: EMPTY
113251: LIST
113252: LIST
113253: PPUSH
113254: CALL_OW 69
113258: PUSH
113259: LD_INT 0
113261: EQUAL
113262: IFFALSE 113286
// ComHeal ( group [ i ] , z ) else
113264: LD_VAR 0 4
113268: PUSH
113269: LD_VAR 0 7
113273: ARRAY
113274: PPUSH
113275: LD_VAR 0 13
113279: PPUSH
113280: CALL_OW 128
113284: GO 113306
// ComMoveToArea ( group [ i ] , f_heal ) ;
113286: LD_VAR 0 4
113290: PUSH
113291: LD_VAR 0 7
113295: ARRAY
113296: PPUSH
113297: LD_VAR 0 23
113301: PPUSH
113302: CALL_OW 113
// end ; continue ;
113306: GO 112337
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113308: LD_VAR 0 4
113312: PUSH
113313: LD_VAR 0 7
113317: ARRAY
113318: PPUSH
113319: CALL_OW 256
113323: PUSH
113324: LD_INT 700
113326: LESS
113327: PUSH
113328: LD_VAR 0 4
113332: PUSH
113333: LD_VAR 0 7
113337: ARRAY
113338: PUSH
113339: LD_VAR 0 30
113343: IN
113344: NOT
113345: AND
113346: IFFALSE 113370
// to_heal := to_heal union group [ i ] ;
113348: LD_ADDR_VAR 0 30
113352: PUSH
113353: LD_VAR 0 30
113357: PUSH
113358: LD_VAR 0 4
113362: PUSH
113363: LD_VAR 0 7
113367: ARRAY
113368: UNION
113369: ST_TO_ADDR
// if group [ i ] in to_heal then
113370: LD_VAR 0 4
113374: PUSH
113375: LD_VAR 0 7
113379: ARRAY
113380: PUSH
113381: LD_VAR 0 30
113385: IN
113386: IFFALSE 113495
// begin if GetLives ( group [ i ] ) = 1000 then
113388: LD_VAR 0 4
113392: PUSH
113393: LD_VAR 0 7
113397: ARRAY
113398: PPUSH
113399: CALL_OW 256
113403: PUSH
113404: LD_INT 1000
113406: EQUAL
113407: IFFALSE 113433
// to_heal := to_heal diff group [ i ] else
113409: LD_ADDR_VAR 0 30
113413: PUSH
113414: LD_VAR 0 30
113418: PUSH
113419: LD_VAR 0 4
113423: PUSH
113424: LD_VAR 0 7
113428: ARRAY
113429: DIFF
113430: ST_TO_ADDR
113431: GO 113495
// begin if not IsInArea ( group [ i ] , to_heal ) then
113433: LD_VAR 0 4
113437: PUSH
113438: LD_VAR 0 7
113442: ARRAY
113443: PPUSH
113444: LD_VAR 0 30
113448: PPUSH
113449: CALL_OW 308
113453: NOT
113454: IFFALSE 113478
// ComMoveToArea ( group [ i ] , f_heal ) else
113456: LD_VAR 0 4
113460: PUSH
113461: LD_VAR 0 7
113465: ARRAY
113466: PPUSH
113467: LD_VAR 0 23
113471: PPUSH
113472: CALL_OW 113
113476: GO 113493
// ComHold ( group [ i ] ) ;
113478: LD_VAR 0 4
113482: PUSH
113483: LD_VAR 0 7
113487: ARRAY
113488: PPUSH
113489: CALL_OW 140
// continue ;
113493: GO 112337
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113495: LD_VAR 0 4
113499: PUSH
113500: LD_VAR 0 7
113504: ARRAY
113505: PPUSH
113506: LD_INT 10
113508: PPUSH
113509: CALL 81958 0 2
113513: NOT
113514: PUSH
113515: LD_VAR 0 16
113519: PUSH
113520: LD_VAR 0 7
113524: ARRAY
113525: PUSH
113526: EMPTY
113527: EQUAL
113528: NOT
113529: AND
113530: IFFALSE 113796
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113532: LD_VAR 0 4
113536: PUSH
113537: LD_VAR 0 7
113541: ARRAY
113542: PPUSH
113543: CALL_OW 262
113547: PUSH
113548: LD_INT 1
113550: PUSH
113551: LD_INT 2
113553: PUSH
113554: EMPTY
113555: LIST
113556: LIST
113557: IN
113558: IFFALSE 113599
// if GetFuel ( group [ i ] ) < 10 then
113560: LD_VAR 0 4
113564: PUSH
113565: LD_VAR 0 7
113569: ARRAY
113570: PPUSH
113571: CALL_OW 261
113575: PUSH
113576: LD_INT 10
113578: LESS
113579: IFFALSE 113599
// SetFuel ( group [ i ] , 12 ) ;
113581: LD_VAR 0 4
113585: PUSH
113586: LD_VAR 0 7
113590: ARRAY
113591: PPUSH
113592: LD_INT 12
113594: PPUSH
113595: CALL_OW 240
// if units_path [ i ] then
113599: LD_VAR 0 16
113603: PUSH
113604: LD_VAR 0 7
113608: ARRAY
113609: IFFALSE 113794
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113611: LD_VAR 0 4
113615: PUSH
113616: LD_VAR 0 7
113620: ARRAY
113621: PPUSH
113622: LD_VAR 0 16
113626: PUSH
113627: LD_VAR 0 7
113631: ARRAY
113632: PUSH
113633: LD_INT 1
113635: ARRAY
113636: PUSH
113637: LD_INT 1
113639: ARRAY
113640: PPUSH
113641: LD_VAR 0 16
113645: PUSH
113646: LD_VAR 0 7
113650: ARRAY
113651: PUSH
113652: LD_INT 1
113654: ARRAY
113655: PUSH
113656: LD_INT 2
113658: ARRAY
113659: PPUSH
113660: CALL_OW 297
113664: PUSH
113665: LD_INT 6
113667: GREATER
113668: IFFALSE 113743
// begin if not HasTask ( group [ i ] ) then
113670: LD_VAR 0 4
113674: PUSH
113675: LD_VAR 0 7
113679: ARRAY
113680: PPUSH
113681: CALL_OW 314
113685: NOT
113686: IFFALSE 113741
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113688: LD_VAR 0 4
113692: PUSH
113693: LD_VAR 0 7
113697: ARRAY
113698: PPUSH
113699: LD_VAR 0 16
113703: PUSH
113704: LD_VAR 0 7
113708: ARRAY
113709: PUSH
113710: LD_INT 1
113712: ARRAY
113713: PUSH
113714: LD_INT 1
113716: ARRAY
113717: PPUSH
113718: LD_VAR 0 16
113722: PUSH
113723: LD_VAR 0 7
113727: ARRAY
113728: PUSH
113729: LD_INT 1
113731: ARRAY
113732: PUSH
113733: LD_INT 2
113735: ARRAY
113736: PPUSH
113737: CALL_OW 114
// end else
113741: GO 113794
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113743: LD_ADDR_VAR 0 15
113747: PUSH
113748: LD_VAR 0 16
113752: PUSH
113753: LD_VAR 0 7
113757: ARRAY
113758: PPUSH
113759: LD_INT 1
113761: PPUSH
113762: CALL_OW 3
113766: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113767: LD_ADDR_VAR 0 16
113771: PUSH
113772: LD_VAR 0 16
113776: PPUSH
113777: LD_VAR 0 7
113781: PPUSH
113782: LD_VAR 0 15
113786: PPUSH
113787: CALL_OW 1
113791: ST_TO_ADDR
// continue ;
113792: GO 112337
// end ; end ; end else
113794: GO 116458
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113796: LD_ADDR_VAR 0 14
113800: PUSH
113801: LD_INT 81
113803: PUSH
113804: LD_VAR 0 4
113808: PUSH
113809: LD_VAR 0 7
113813: ARRAY
113814: PPUSH
113815: CALL_OW 255
113819: PUSH
113820: EMPTY
113821: LIST
113822: LIST
113823: PPUSH
113824: CALL_OW 69
113828: ST_TO_ADDR
// if not tmp then
113829: LD_VAR 0 14
113833: NOT
113834: IFFALSE 113838
// continue ;
113836: GO 112337
// if f_ignore_area then
113838: LD_VAR 0 17
113842: IFFALSE 113930
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113844: LD_ADDR_VAR 0 15
113848: PUSH
113849: LD_VAR 0 14
113853: PPUSH
113854: LD_INT 3
113856: PUSH
113857: LD_INT 92
113859: PUSH
113860: LD_VAR 0 17
113864: PUSH
113865: LD_INT 1
113867: ARRAY
113868: PUSH
113869: LD_VAR 0 17
113873: PUSH
113874: LD_INT 2
113876: ARRAY
113877: PUSH
113878: LD_VAR 0 17
113882: PUSH
113883: LD_INT 3
113885: ARRAY
113886: PUSH
113887: EMPTY
113888: LIST
113889: LIST
113890: LIST
113891: LIST
113892: PUSH
113893: EMPTY
113894: LIST
113895: LIST
113896: PPUSH
113897: CALL_OW 72
113901: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113902: LD_VAR 0 14
113906: PUSH
113907: LD_VAR 0 15
113911: DIFF
113912: IFFALSE 113930
// tmp := tmp diff tmp2 ;
113914: LD_ADDR_VAR 0 14
113918: PUSH
113919: LD_VAR 0 14
113923: PUSH
113924: LD_VAR 0 15
113928: DIFF
113929: ST_TO_ADDR
// end ; if not f_murder then
113930: LD_VAR 0 20
113934: NOT
113935: IFFALSE 113993
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113937: LD_ADDR_VAR 0 15
113941: PUSH
113942: LD_VAR 0 14
113946: PPUSH
113947: LD_INT 3
113949: PUSH
113950: LD_INT 50
113952: PUSH
113953: EMPTY
113954: LIST
113955: PUSH
113956: EMPTY
113957: LIST
113958: LIST
113959: PPUSH
113960: CALL_OW 72
113964: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113965: LD_VAR 0 14
113969: PUSH
113970: LD_VAR 0 15
113974: DIFF
113975: IFFALSE 113993
// tmp := tmp diff tmp2 ;
113977: LD_ADDR_VAR 0 14
113981: PUSH
113982: LD_VAR 0 14
113986: PUSH
113987: LD_VAR 0 15
113991: DIFF
113992: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
113993: LD_ADDR_VAR 0 14
113997: PUSH
113998: LD_VAR 0 4
114002: PUSH
114003: LD_VAR 0 7
114007: ARRAY
114008: PPUSH
114009: LD_VAR 0 14
114013: PPUSH
114014: LD_INT 1
114016: PPUSH
114017: LD_INT 1
114019: PPUSH
114020: CALL 54502 0 4
114024: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114025: LD_VAR 0 4
114029: PUSH
114030: LD_VAR 0 7
114034: ARRAY
114035: PPUSH
114036: CALL_OW 257
114040: PUSH
114041: LD_INT 1
114043: EQUAL
114044: IFFALSE 114492
// begin if WantPlant ( group [ i ] ) then
114046: LD_VAR 0 4
114050: PUSH
114051: LD_VAR 0 7
114055: ARRAY
114056: PPUSH
114057: CALL 54003 0 1
114061: IFFALSE 114065
// continue ;
114063: GO 112337
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114065: LD_VAR 0 18
114069: PUSH
114070: LD_VAR 0 4
114074: PUSH
114075: LD_VAR 0 7
114079: ARRAY
114080: PPUSH
114081: CALL_OW 310
114085: NOT
114086: AND
114087: PUSH
114088: LD_VAR 0 14
114092: PUSH
114093: LD_INT 1
114095: ARRAY
114096: PUSH
114097: LD_VAR 0 14
114101: PPUSH
114102: LD_INT 21
114104: PUSH
114105: LD_INT 2
114107: PUSH
114108: EMPTY
114109: LIST
114110: LIST
114111: PUSH
114112: LD_INT 58
114114: PUSH
114115: EMPTY
114116: LIST
114117: PUSH
114118: EMPTY
114119: LIST
114120: LIST
114121: PPUSH
114122: CALL_OW 72
114126: IN
114127: AND
114128: IFFALSE 114164
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114130: LD_VAR 0 4
114134: PUSH
114135: LD_VAR 0 7
114139: ARRAY
114140: PPUSH
114141: LD_VAR 0 14
114145: PUSH
114146: LD_INT 1
114148: ARRAY
114149: PPUSH
114150: CALL_OW 120
// attacking := true ;
114154: LD_ADDR_VAR 0 29
114158: PUSH
114159: LD_INT 1
114161: ST_TO_ADDR
// continue ;
114162: GO 112337
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114164: LD_VAR 0 26
114168: PUSH
114169: LD_VAR 0 4
114173: PUSH
114174: LD_VAR 0 7
114178: ARRAY
114179: PPUSH
114180: CALL_OW 257
114184: PUSH
114185: LD_INT 1
114187: EQUAL
114188: AND
114189: PUSH
114190: LD_VAR 0 4
114194: PUSH
114195: LD_VAR 0 7
114199: ARRAY
114200: PPUSH
114201: CALL_OW 256
114205: PUSH
114206: LD_INT 800
114208: LESS
114209: AND
114210: PUSH
114211: LD_VAR 0 4
114215: PUSH
114216: LD_VAR 0 7
114220: ARRAY
114221: PPUSH
114222: CALL_OW 318
114226: NOT
114227: AND
114228: IFFALSE 114245
// ComCrawl ( group [ i ] ) ;
114230: LD_VAR 0 4
114234: PUSH
114235: LD_VAR 0 7
114239: ARRAY
114240: PPUSH
114241: CALL_OW 137
// if f_mines then
114245: LD_VAR 0 21
114249: IFFALSE 114492
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114251: LD_VAR 0 14
114255: PUSH
114256: LD_INT 1
114258: ARRAY
114259: PPUSH
114260: CALL_OW 247
114264: PUSH
114265: LD_INT 3
114267: EQUAL
114268: PUSH
114269: LD_VAR 0 14
114273: PUSH
114274: LD_INT 1
114276: ARRAY
114277: PUSH
114278: LD_VAR 0 27
114282: IN
114283: NOT
114284: AND
114285: IFFALSE 114492
// begin x := GetX ( tmp [ 1 ] ) ;
114287: LD_ADDR_VAR 0 10
114291: PUSH
114292: LD_VAR 0 14
114296: PUSH
114297: LD_INT 1
114299: ARRAY
114300: PPUSH
114301: CALL_OW 250
114305: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114306: LD_ADDR_VAR 0 11
114310: PUSH
114311: LD_VAR 0 14
114315: PUSH
114316: LD_INT 1
114318: ARRAY
114319: PPUSH
114320: CALL_OW 251
114324: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114325: LD_ADDR_VAR 0 12
114329: PUSH
114330: LD_VAR 0 4
114334: PUSH
114335: LD_VAR 0 7
114339: ARRAY
114340: PPUSH
114341: CALL 82043 0 1
114345: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114346: LD_VAR 0 4
114350: PUSH
114351: LD_VAR 0 7
114355: ARRAY
114356: PPUSH
114357: LD_VAR 0 10
114361: PPUSH
114362: LD_VAR 0 11
114366: PPUSH
114367: LD_VAR 0 14
114371: PUSH
114372: LD_INT 1
114374: ARRAY
114375: PPUSH
114376: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114380: LD_VAR 0 4
114384: PUSH
114385: LD_VAR 0 7
114389: ARRAY
114390: PPUSH
114391: LD_VAR 0 10
114395: PPUSH
114396: LD_VAR 0 12
114400: PPUSH
114401: LD_INT 7
114403: PPUSH
114404: CALL_OW 272
114408: PPUSH
114409: LD_VAR 0 11
114413: PPUSH
114414: LD_VAR 0 12
114418: PPUSH
114419: LD_INT 7
114421: PPUSH
114422: CALL_OW 273
114426: PPUSH
114427: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114431: LD_VAR 0 4
114435: PUSH
114436: LD_VAR 0 7
114440: ARRAY
114441: PPUSH
114442: LD_INT 71
114444: PPUSH
114445: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114449: LD_ADDR_VAR 0 27
114453: PUSH
114454: LD_VAR 0 27
114458: PPUSH
114459: LD_VAR 0 27
114463: PUSH
114464: LD_INT 1
114466: PLUS
114467: PPUSH
114468: LD_VAR 0 14
114472: PUSH
114473: LD_INT 1
114475: ARRAY
114476: PPUSH
114477: CALL_OW 1
114481: ST_TO_ADDR
// attacking := true ;
114482: LD_ADDR_VAR 0 29
114486: PUSH
114487: LD_INT 1
114489: ST_TO_ADDR
// continue ;
114490: GO 112337
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114492: LD_VAR 0 4
114496: PUSH
114497: LD_VAR 0 7
114501: ARRAY
114502: PPUSH
114503: CALL_OW 257
114507: PUSH
114508: LD_INT 17
114510: EQUAL
114511: PUSH
114512: LD_VAR 0 4
114516: PUSH
114517: LD_VAR 0 7
114521: ARRAY
114522: PPUSH
114523: CALL_OW 110
114527: PUSH
114528: LD_INT 71
114530: EQUAL
114531: NOT
114532: AND
114533: IFFALSE 114679
// begin attacking := false ;
114535: LD_ADDR_VAR 0 29
114539: PUSH
114540: LD_INT 0
114542: ST_TO_ADDR
// k := 5 ;
114543: LD_ADDR_VAR 0 9
114547: PUSH
114548: LD_INT 5
114550: ST_TO_ADDR
// if tmp < k then
114551: LD_VAR 0 14
114555: PUSH
114556: LD_VAR 0 9
114560: LESS
114561: IFFALSE 114573
// k := tmp ;
114563: LD_ADDR_VAR 0 9
114567: PUSH
114568: LD_VAR 0 14
114572: ST_TO_ADDR
// for j = 1 to k do
114573: LD_ADDR_VAR 0 8
114577: PUSH
114578: DOUBLE
114579: LD_INT 1
114581: DEC
114582: ST_TO_ADDR
114583: LD_VAR 0 9
114587: PUSH
114588: FOR_TO
114589: IFFALSE 114677
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114591: LD_VAR 0 14
114595: PUSH
114596: LD_VAR 0 8
114600: ARRAY
114601: PUSH
114602: LD_VAR 0 14
114606: PPUSH
114607: LD_INT 58
114609: PUSH
114610: EMPTY
114611: LIST
114612: PPUSH
114613: CALL_OW 72
114617: IN
114618: NOT
114619: IFFALSE 114675
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114621: LD_VAR 0 4
114625: PUSH
114626: LD_VAR 0 7
114630: ARRAY
114631: PPUSH
114632: LD_VAR 0 14
114636: PUSH
114637: LD_VAR 0 8
114641: ARRAY
114642: PPUSH
114643: CALL_OW 115
// attacking := true ;
114647: LD_ADDR_VAR 0 29
114651: PUSH
114652: LD_INT 1
114654: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114655: LD_VAR 0 4
114659: PUSH
114660: LD_VAR 0 7
114664: ARRAY
114665: PPUSH
114666: LD_INT 71
114668: PPUSH
114669: CALL_OW 109
// continue ;
114673: GO 114588
// end ; end ;
114675: GO 114588
114677: POP
114678: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114679: LD_VAR 0 4
114683: PUSH
114684: LD_VAR 0 7
114688: ARRAY
114689: PPUSH
114690: CALL_OW 257
114694: PUSH
114695: LD_INT 8
114697: EQUAL
114698: PUSH
114699: LD_VAR 0 4
114703: PUSH
114704: LD_VAR 0 7
114708: ARRAY
114709: PPUSH
114710: CALL_OW 264
114714: PUSH
114715: LD_INT 28
114717: PUSH
114718: LD_INT 45
114720: PUSH
114721: LD_INT 7
114723: PUSH
114724: LD_INT 47
114726: PUSH
114727: EMPTY
114728: LIST
114729: LIST
114730: LIST
114731: LIST
114732: IN
114733: OR
114734: IFFALSE 114990
// begin attacking := false ;
114736: LD_ADDR_VAR 0 29
114740: PUSH
114741: LD_INT 0
114743: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114744: LD_VAR 0 14
114748: PUSH
114749: LD_INT 1
114751: ARRAY
114752: PPUSH
114753: CALL_OW 266
114757: PUSH
114758: LD_INT 32
114760: PUSH
114761: LD_INT 31
114763: PUSH
114764: LD_INT 33
114766: PUSH
114767: LD_INT 4
114769: PUSH
114770: LD_INT 5
114772: PUSH
114773: EMPTY
114774: LIST
114775: LIST
114776: LIST
114777: LIST
114778: LIST
114779: IN
114780: IFFALSE 114966
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114782: LD_ADDR_VAR 0 9
114786: PUSH
114787: LD_VAR 0 14
114791: PUSH
114792: LD_INT 1
114794: ARRAY
114795: PPUSH
114796: CALL_OW 266
114800: PPUSH
114801: LD_VAR 0 14
114805: PUSH
114806: LD_INT 1
114808: ARRAY
114809: PPUSH
114810: CALL_OW 250
114814: PPUSH
114815: LD_VAR 0 14
114819: PUSH
114820: LD_INT 1
114822: ARRAY
114823: PPUSH
114824: CALL_OW 251
114828: PPUSH
114829: LD_VAR 0 14
114833: PUSH
114834: LD_INT 1
114836: ARRAY
114837: PPUSH
114838: CALL_OW 254
114842: PPUSH
114843: LD_VAR 0 14
114847: PUSH
114848: LD_INT 1
114850: ARRAY
114851: PPUSH
114852: CALL_OW 248
114856: PPUSH
114857: LD_INT 0
114859: PPUSH
114860: CALL 63413 0 6
114864: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114865: LD_ADDR_VAR 0 8
114869: PUSH
114870: LD_VAR 0 4
114874: PUSH
114875: LD_VAR 0 7
114879: ARRAY
114880: PPUSH
114881: LD_VAR 0 9
114885: PPUSH
114886: CALL 82156 0 2
114890: ST_TO_ADDR
// if j then
114891: LD_VAR 0 8
114895: IFFALSE 114964
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114897: LD_VAR 0 8
114901: PUSH
114902: LD_INT 1
114904: ARRAY
114905: PPUSH
114906: LD_VAR 0 8
114910: PUSH
114911: LD_INT 2
114913: ARRAY
114914: PPUSH
114915: CALL_OW 488
114919: IFFALSE 114964
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114921: LD_VAR 0 4
114925: PUSH
114926: LD_VAR 0 7
114930: ARRAY
114931: PPUSH
114932: LD_VAR 0 8
114936: PUSH
114937: LD_INT 1
114939: ARRAY
114940: PPUSH
114941: LD_VAR 0 8
114945: PUSH
114946: LD_INT 2
114948: ARRAY
114949: PPUSH
114950: CALL_OW 116
// attacking := true ;
114954: LD_ADDR_VAR 0 29
114958: PUSH
114959: LD_INT 1
114961: ST_TO_ADDR
// continue ;
114962: GO 112337
// end ; end else
114964: GO 114990
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114966: LD_VAR 0 4
114970: PUSH
114971: LD_VAR 0 7
114975: ARRAY
114976: PPUSH
114977: LD_VAR 0 14
114981: PUSH
114982: LD_INT 1
114984: ARRAY
114985: PPUSH
114986: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
114990: LD_VAR 0 4
114994: PUSH
114995: LD_VAR 0 7
114999: ARRAY
115000: PPUSH
115001: CALL_OW 265
115005: PUSH
115006: LD_INT 11
115008: EQUAL
115009: IFFALSE 115287
// begin k := 10 ;
115011: LD_ADDR_VAR 0 9
115015: PUSH
115016: LD_INT 10
115018: ST_TO_ADDR
// x := 0 ;
115019: LD_ADDR_VAR 0 10
115023: PUSH
115024: LD_INT 0
115026: ST_TO_ADDR
// if tmp < k then
115027: LD_VAR 0 14
115031: PUSH
115032: LD_VAR 0 9
115036: LESS
115037: IFFALSE 115049
// k := tmp ;
115039: LD_ADDR_VAR 0 9
115043: PUSH
115044: LD_VAR 0 14
115048: ST_TO_ADDR
// for j = k downto 1 do
115049: LD_ADDR_VAR 0 8
115053: PUSH
115054: DOUBLE
115055: LD_VAR 0 9
115059: INC
115060: ST_TO_ADDR
115061: LD_INT 1
115063: PUSH
115064: FOR_DOWNTO
115065: IFFALSE 115140
// begin if GetType ( tmp [ j ] ) = unit_human then
115067: LD_VAR 0 14
115071: PUSH
115072: LD_VAR 0 8
115076: ARRAY
115077: PPUSH
115078: CALL_OW 247
115082: PUSH
115083: LD_INT 1
115085: EQUAL
115086: IFFALSE 115138
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115088: LD_VAR 0 4
115092: PUSH
115093: LD_VAR 0 7
115097: ARRAY
115098: PPUSH
115099: LD_VAR 0 14
115103: PUSH
115104: LD_VAR 0 8
115108: ARRAY
115109: PPUSH
115110: CALL 82410 0 2
// x := tmp [ j ] ;
115114: LD_ADDR_VAR 0 10
115118: PUSH
115119: LD_VAR 0 14
115123: PUSH
115124: LD_VAR 0 8
115128: ARRAY
115129: ST_TO_ADDR
// attacking := true ;
115130: LD_ADDR_VAR 0 29
115134: PUSH
115135: LD_INT 1
115137: ST_TO_ADDR
// end ; end ;
115138: GO 115064
115140: POP
115141: POP
// if not x then
115142: LD_VAR 0 10
115146: NOT
115147: IFFALSE 115287
// begin attacking := true ;
115149: LD_ADDR_VAR 0 29
115153: PUSH
115154: LD_INT 1
115156: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115157: LD_VAR 0 4
115161: PUSH
115162: LD_VAR 0 7
115166: ARRAY
115167: PPUSH
115168: CALL_OW 250
115172: PPUSH
115173: LD_VAR 0 4
115177: PUSH
115178: LD_VAR 0 7
115182: ARRAY
115183: PPUSH
115184: CALL_OW 251
115188: PPUSH
115189: CALL_OW 546
115193: PUSH
115194: LD_INT 2
115196: ARRAY
115197: PUSH
115198: LD_VAR 0 14
115202: PUSH
115203: LD_INT 1
115205: ARRAY
115206: PPUSH
115207: CALL_OW 250
115211: PPUSH
115212: LD_VAR 0 14
115216: PUSH
115217: LD_INT 1
115219: ARRAY
115220: PPUSH
115221: CALL_OW 251
115225: PPUSH
115226: CALL_OW 546
115230: PUSH
115231: LD_INT 2
115233: ARRAY
115234: EQUAL
115235: IFFALSE 115263
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115237: LD_VAR 0 4
115241: PUSH
115242: LD_VAR 0 7
115246: ARRAY
115247: PPUSH
115248: LD_VAR 0 14
115252: PUSH
115253: LD_INT 1
115255: ARRAY
115256: PPUSH
115257: CALL 82410 0 2
115261: GO 115287
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115263: LD_VAR 0 4
115267: PUSH
115268: LD_VAR 0 7
115272: ARRAY
115273: PPUSH
115274: LD_VAR 0 14
115278: PUSH
115279: LD_INT 1
115281: ARRAY
115282: PPUSH
115283: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115287: LD_VAR 0 4
115291: PUSH
115292: LD_VAR 0 7
115296: ARRAY
115297: PPUSH
115298: CALL_OW 264
115302: PUSH
115303: LD_INT 29
115305: EQUAL
115306: IFFALSE 115672
// begin if WantsToAttack ( group [ i ] ) in bombed then
115308: LD_VAR 0 4
115312: PUSH
115313: LD_VAR 0 7
115317: ARRAY
115318: PPUSH
115319: CALL_OW 319
115323: PUSH
115324: LD_VAR 0 28
115328: IN
115329: IFFALSE 115333
// continue ;
115331: GO 112337
// k := 8 ;
115333: LD_ADDR_VAR 0 9
115337: PUSH
115338: LD_INT 8
115340: ST_TO_ADDR
// x := 0 ;
115341: LD_ADDR_VAR 0 10
115345: PUSH
115346: LD_INT 0
115348: ST_TO_ADDR
// if tmp < k then
115349: LD_VAR 0 14
115353: PUSH
115354: LD_VAR 0 9
115358: LESS
115359: IFFALSE 115371
// k := tmp ;
115361: LD_ADDR_VAR 0 9
115365: PUSH
115366: LD_VAR 0 14
115370: ST_TO_ADDR
// for j = 1 to k do
115371: LD_ADDR_VAR 0 8
115375: PUSH
115376: DOUBLE
115377: LD_INT 1
115379: DEC
115380: ST_TO_ADDR
115381: LD_VAR 0 9
115385: PUSH
115386: FOR_TO
115387: IFFALSE 115519
// begin if GetType ( tmp [ j ] ) = unit_building then
115389: LD_VAR 0 14
115393: PUSH
115394: LD_VAR 0 8
115398: ARRAY
115399: PPUSH
115400: CALL_OW 247
115404: PUSH
115405: LD_INT 3
115407: EQUAL
115408: IFFALSE 115517
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115410: LD_VAR 0 14
115414: PUSH
115415: LD_VAR 0 8
115419: ARRAY
115420: PUSH
115421: LD_VAR 0 28
115425: IN
115426: NOT
115427: PUSH
115428: LD_VAR 0 14
115432: PUSH
115433: LD_VAR 0 8
115437: ARRAY
115438: PPUSH
115439: CALL_OW 313
115443: AND
115444: IFFALSE 115517
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115446: LD_VAR 0 4
115450: PUSH
115451: LD_VAR 0 7
115455: ARRAY
115456: PPUSH
115457: LD_VAR 0 14
115461: PUSH
115462: LD_VAR 0 8
115466: ARRAY
115467: PPUSH
115468: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115472: LD_ADDR_VAR 0 28
115476: PUSH
115477: LD_VAR 0 28
115481: PPUSH
115482: LD_VAR 0 28
115486: PUSH
115487: LD_INT 1
115489: PLUS
115490: PPUSH
115491: LD_VAR 0 14
115495: PUSH
115496: LD_VAR 0 8
115500: ARRAY
115501: PPUSH
115502: CALL_OW 1
115506: ST_TO_ADDR
// attacking := true ;
115507: LD_ADDR_VAR 0 29
115511: PUSH
115512: LD_INT 1
115514: ST_TO_ADDR
// break ;
115515: GO 115519
// end ; end ;
115517: GO 115386
115519: POP
115520: POP
// if not attacking and f_attack_depot then
115521: LD_VAR 0 29
115525: NOT
115526: PUSH
115527: LD_VAR 0 25
115531: AND
115532: IFFALSE 115627
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115534: LD_ADDR_VAR 0 13
115538: PUSH
115539: LD_VAR 0 14
115543: PPUSH
115544: LD_INT 2
115546: PUSH
115547: LD_INT 30
115549: PUSH
115550: LD_INT 0
115552: PUSH
115553: EMPTY
115554: LIST
115555: LIST
115556: PUSH
115557: LD_INT 30
115559: PUSH
115560: LD_INT 1
115562: PUSH
115563: EMPTY
115564: LIST
115565: LIST
115566: PUSH
115567: EMPTY
115568: LIST
115569: LIST
115570: LIST
115571: PPUSH
115572: CALL_OW 72
115576: ST_TO_ADDR
// if z then
115577: LD_VAR 0 13
115581: IFFALSE 115627
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115583: LD_VAR 0 4
115587: PUSH
115588: LD_VAR 0 7
115592: ARRAY
115593: PPUSH
115594: LD_VAR 0 13
115598: PPUSH
115599: LD_VAR 0 4
115603: PUSH
115604: LD_VAR 0 7
115608: ARRAY
115609: PPUSH
115610: CALL_OW 74
115614: PPUSH
115615: CALL_OW 115
// attacking := true ;
115619: LD_ADDR_VAR 0 29
115623: PUSH
115624: LD_INT 1
115626: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115627: LD_VAR 0 4
115631: PUSH
115632: LD_VAR 0 7
115636: ARRAY
115637: PPUSH
115638: CALL_OW 256
115642: PUSH
115643: LD_INT 500
115645: LESS
115646: IFFALSE 115672
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115648: LD_VAR 0 4
115652: PUSH
115653: LD_VAR 0 7
115657: ARRAY
115658: PPUSH
115659: LD_VAR 0 14
115663: PUSH
115664: LD_INT 1
115666: ARRAY
115667: PPUSH
115668: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115672: LD_VAR 0 4
115676: PUSH
115677: LD_VAR 0 7
115681: ARRAY
115682: PPUSH
115683: CALL_OW 264
115687: PUSH
115688: LD_INT 49
115690: EQUAL
115691: IFFALSE 115812
// begin if not HasTask ( group [ i ] ) then
115693: LD_VAR 0 4
115697: PUSH
115698: LD_VAR 0 7
115702: ARRAY
115703: PPUSH
115704: CALL_OW 314
115708: NOT
115709: IFFALSE 115812
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115711: LD_ADDR_VAR 0 9
115715: PUSH
115716: LD_INT 81
115718: PUSH
115719: LD_VAR 0 4
115723: PUSH
115724: LD_VAR 0 7
115728: ARRAY
115729: PPUSH
115730: CALL_OW 255
115734: PUSH
115735: EMPTY
115736: LIST
115737: LIST
115738: PPUSH
115739: CALL_OW 69
115743: PPUSH
115744: LD_VAR 0 4
115748: PUSH
115749: LD_VAR 0 7
115753: ARRAY
115754: PPUSH
115755: CALL_OW 74
115759: ST_TO_ADDR
// if k then
115760: LD_VAR 0 9
115764: IFFALSE 115812
// if GetDistUnits ( group [ i ] , k ) > 10 then
115766: LD_VAR 0 4
115770: PUSH
115771: LD_VAR 0 7
115775: ARRAY
115776: PPUSH
115777: LD_VAR 0 9
115781: PPUSH
115782: CALL_OW 296
115786: PUSH
115787: LD_INT 10
115789: GREATER
115790: IFFALSE 115812
// ComMoveUnit ( group [ i ] , k ) ;
115792: LD_VAR 0 4
115796: PUSH
115797: LD_VAR 0 7
115801: ARRAY
115802: PPUSH
115803: LD_VAR 0 9
115807: PPUSH
115808: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115812: LD_VAR 0 4
115816: PUSH
115817: LD_VAR 0 7
115821: ARRAY
115822: PPUSH
115823: CALL_OW 256
115827: PUSH
115828: LD_INT 250
115830: LESS
115831: PUSH
115832: LD_VAR 0 4
115836: PUSH
115837: LD_VAR 0 7
115841: ARRAY
115842: PUSH
115843: LD_INT 21
115845: PUSH
115846: LD_INT 2
115848: PUSH
115849: EMPTY
115850: LIST
115851: LIST
115852: PUSH
115853: LD_INT 23
115855: PUSH
115856: LD_INT 2
115858: PUSH
115859: EMPTY
115860: LIST
115861: LIST
115862: PUSH
115863: EMPTY
115864: LIST
115865: LIST
115866: PPUSH
115867: CALL_OW 69
115871: IN
115872: AND
115873: IFFALSE 115998
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115875: LD_ADDR_VAR 0 9
115879: PUSH
115880: LD_OWVAR 3
115884: PUSH
115885: LD_VAR 0 4
115889: PUSH
115890: LD_VAR 0 7
115894: ARRAY
115895: DIFF
115896: PPUSH
115897: LD_VAR 0 4
115901: PUSH
115902: LD_VAR 0 7
115906: ARRAY
115907: PPUSH
115908: CALL_OW 74
115912: ST_TO_ADDR
// if not k then
115913: LD_VAR 0 9
115917: NOT
115918: IFFALSE 115922
// continue ;
115920: GO 112337
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115922: LD_VAR 0 9
115926: PUSH
115927: LD_INT 81
115929: PUSH
115930: LD_VAR 0 4
115934: PUSH
115935: LD_VAR 0 7
115939: ARRAY
115940: PPUSH
115941: CALL_OW 255
115945: PUSH
115946: EMPTY
115947: LIST
115948: LIST
115949: PPUSH
115950: CALL_OW 69
115954: IN
115955: PUSH
115956: LD_VAR 0 9
115960: PPUSH
115961: LD_VAR 0 4
115965: PUSH
115966: LD_VAR 0 7
115970: ARRAY
115971: PPUSH
115972: CALL_OW 296
115976: PUSH
115977: LD_INT 5
115979: LESS
115980: AND
115981: IFFALSE 115998
// ComAutodestruct ( group [ i ] ) ;
115983: LD_VAR 0 4
115987: PUSH
115988: LD_VAR 0 7
115992: ARRAY
115993: PPUSH
115994: CALL 82308 0 1
// end ; if f_attack_depot then
115998: LD_VAR 0 25
116002: IFFALSE 116114
// begin k := 6 ;
116004: LD_ADDR_VAR 0 9
116008: PUSH
116009: LD_INT 6
116011: ST_TO_ADDR
// if tmp < k then
116012: LD_VAR 0 14
116016: PUSH
116017: LD_VAR 0 9
116021: LESS
116022: IFFALSE 116034
// k := tmp ;
116024: LD_ADDR_VAR 0 9
116028: PUSH
116029: LD_VAR 0 14
116033: ST_TO_ADDR
// for j = 1 to k do
116034: LD_ADDR_VAR 0 8
116038: PUSH
116039: DOUBLE
116040: LD_INT 1
116042: DEC
116043: ST_TO_ADDR
116044: LD_VAR 0 9
116048: PUSH
116049: FOR_TO
116050: IFFALSE 116112
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116052: LD_VAR 0 8
116056: PPUSH
116057: CALL_OW 266
116061: PUSH
116062: LD_INT 0
116064: PUSH
116065: LD_INT 1
116067: PUSH
116068: EMPTY
116069: LIST
116070: LIST
116071: IN
116072: IFFALSE 116110
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116074: LD_VAR 0 4
116078: PUSH
116079: LD_VAR 0 7
116083: ARRAY
116084: PPUSH
116085: LD_VAR 0 14
116089: PUSH
116090: LD_VAR 0 8
116094: ARRAY
116095: PPUSH
116096: CALL_OW 115
// attacking := true ;
116100: LD_ADDR_VAR 0 29
116104: PUSH
116105: LD_INT 1
116107: ST_TO_ADDR
// break ;
116108: GO 116112
// end ;
116110: GO 116049
116112: POP
116113: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116114: LD_VAR 0 4
116118: PUSH
116119: LD_VAR 0 7
116123: ARRAY
116124: PPUSH
116125: CALL_OW 302
116129: PUSH
116130: LD_VAR 0 29
116134: NOT
116135: AND
116136: IFFALSE 116458
// begin if GetTag ( group [ i ] ) = 71 then
116138: LD_VAR 0 4
116142: PUSH
116143: LD_VAR 0 7
116147: ARRAY
116148: PPUSH
116149: CALL_OW 110
116153: PUSH
116154: LD_INT 71
116156: EQUAL
116157: IFFALSE 116198
// begin if HasTask ( group [ i ] ) then
116159: LD_VAR 0 4
116163: PUSH
116164: LD_VAR 0 7
116168: ARRAY
116169: PPUSH
116170: CALL_OW 314
116174: IFFALSE 116180
// continue else
116176: GO 112337
116178: GO 116198
// SetTag ( group [ i ] , 0 ) ;
116180: LD_VAR 0 4
116184: PUSH
116185: LD_VAR 0 7
116189: ARRAY
116190: PPUSH
116191: LD_INT 0
116193: PPUSH
116194: CALL_OW 109
// end ; k := 8 ;
116198: LD_ADDR_VAR 0 9
116202: PUSH
116203: LD_INT 8
116205: ST_TO_ADDR
// x := 0 ;
116206: LD_ADDR_VAR 0 10
116210: PUSH
116211: LD_INT 0
116213: ST_TO_ADDR
// if tmp < k then
116214: LD_VAR 0 14
116218: PUSH
116219: LD_VAR 0 9
116223: LESS
116224: IFFALSE 116236
// k := tmp ;
116226: LD_ADDR_VAR 0 9
116230: PUSH
116231: LD_VAR 0 14
116235: ST_TO_ADDR
// for j = 1 to k do
116236: LD_ADDR_VAR 0 8
116240: PUSH
116241: DOUBLE
116242: LD_INT 1
116244: DEC
116245: ST_TO_ADDR
116246: LD_VAR 0 9
116250: PUSH
116251: FOR_TO
116252: IFFALSE 116350
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116254: LD_VAR 0 14
116258: PUSH
116259: LD_VAR 0 8
116263: ARRAY
116264: PPUSH
116265: CALL_OW 247
116269: PUSH
116270: LD_INT 1
116272: EQUAL
116273: PUSH
116274: LD_VAR 0 14
116278: PUSH
116279: LD_VAR 0 8
116283: ARRAY
116284: PPUSH
116285: CALL_OW 256
116289: PUSH
116290: LD_INT 250
116292: LESS
116293: PUSH
116294: LD_VAR 0 20
116298: AND
116299: PUSH
116300: LD_VAR 0 20
116304: NOT
116305: PUSH
116306: LD_VAR 0 14
116310: PUSH
116311: LD_VAR 0 8
116315: ARRAY
116316: PPUSH
116317: CALL_OW 256
116321: PUSH
116322: LD_INT 250
116324: GREATEREQUAL
116325: AND
116326: OR
116327: AND
116328: IFFALSE 116348
// begin x := tmp [ j ] ;
116330: LD_ADDR_VAR 0 10
116334: PUSH
116335: LD_VAR 0 14
116339: PUSH
116340: LD_VAR 0 8
116344: ARRAY
116345: ST_TO_ADDR
// break ;
116346: GO 116350
// end ;
116348: GO 116251
116350: POP
116351: POP
// if x then
116352: LD_VAR 0 10
116356: IFFALSE 116380
// ComAttackUnit ( group [ i ] , x ) else
116358: LD_VAR 0 4
116362: PUSH
116363: LD_VAR 0 7
116367: ARRAY
116368: PPUSH
116369: LD_VAR 0 10
116373: PPUSH
116374: CALL_OW 115
116378: GO 116404
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116380: LD_VAR 0 4
116384: PUSH
116385: LD_VAR 0 7
116389: ARRAY
116390: PPUSH
116391: LD_VAR 0 14
116395: PUSH
116396: LD_INT 1
116398: ARRAY
116399: PPUSH
116400: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116404: LD_VAR 0 4
116408: PUSH
116409: LD_VAR 0 7
116413: ARRAY
116414: PPUSH
116415: CALL_OW 314
116419: NOT
116420: IFFALSE 116458
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116422: LD_VAR 0 4
116426: PUSH
116427: LD_VAR 0 7
116431: ARRAY
116432: PPUSH
116433: LD_VAR 0 14
116437: PPUSH
116438: LD_VAR 0 4
116442: PUSH
116443: LD_VAR 0 7
116447: ARRAY
116448: PPUSH
116449: CALL_OW 74
116453: PPUSH
116454: CALL_OW 115
// end ; end ; end ;
116458: GO 112337
116460: POP
116461: POP
// wait ( 0 0$2 ) ;
116462: LD_INT 70
116464: PPUSH
116465: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116469: LD_VAR 0 4
116473: NOT
116474: PUSH
116475: LD_VAR 0 4
116479: PUSH
116480: EMPTY
116481: EQUAL
116482: OR
116483: PUSH
116484: LD_INT 81
116486: PUSH
116487: LD_VAR 0 35
116491: PUSH
116492: EMPTY
116493: LIST
116494: LIST
116495: PPUSH
116496: CALL_OW 69
116500: NOT
116501: OR
116502: IFFALSE 112322
// end ;
116504: LD_VAR 0 2
116508: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116509: LD_INT 0
116511: PPUSH
116512: PPUSH
116513: PPUSH
116514: PPUSH
116515: PPUSH
116516: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116517: LD_VAR 0 1
116521: NOT
116522: PUSH
116523: LD_EXP 50
116527: PUSH
116528: LD_VAR 0 1
116532: ARRAY
116533: NOT
116534: OR
116535: PUSH
116536: LD_VAR 0 2
116540: NOT
116541: OR
116542: IFFALSE 116546
// exit ;
116544: GO 117100
// side := mc_sides [ base ] ;
116546: LD_ADDR_VAR 0 6
116550: PUSH
116551: LD_EXP 76
116555: PUSH
116556: LD_VAR 0 1
116560: ARRAY
116561: ST_TO_ADDR
// if not side then
116562: LD_VAR 0 6
116566: NOT
116567: IFFALSE 116571
// exit ;
116569: GO 117100
// for i in solds do
116571: LD_ADDR_VAR 0 7
116575: PUSH
116576: LD_VAR 0 2
116580: PUSH
116581: FOR_IN
116582: IFFALSE 116643
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116584: LD_VAR 0 7
116588: PPUSH
116589: CALL_OW 310
116593: PPUSH
116594: CALL_OW 266
116598: PUSH
116599: LD_INT 32
116601: PUSH
116602: LD_INT 31
116604: PUSH
116605: EMPTY
116606: LIST
116607: LIST
116608: IN
116609: IFFALSE 116629
// solds := solds diff i else
116611: LD_ADDR_VAR 0 2
116615: PUSH
116616: LD_VAR 0 2
116620: PUSH
116621: LD_VAR 0 7
116625: DIFF
116626: ST_TO_ADDR
116627: GO 116641
// SetTag ( i , 18 ) ;
116629: LD_VAR 0 7
116633: PPUSH
116634: LD_INT 18
116636: PPUSH
116637: CALL_OW 109
116641: GO 116581
116643: POP
116644: POP
// if not solds then
116645: LD_VAR 0 2
116649: NOT
116650: IFFALSE 116654
// exit ;
116652: GO 117100
// repeat wait ( 0 0$2 ) ;
116654: LD_INT 70
116656: PPUSH
116657: CALL_OW 67
// enemy := mc_scan [ base ] ;
116661: LD_ADDR_VAR 0 4
116665: PUSH
116666: LD_EXP 73
116670: PUSH
116671: LD_VAR 0 1
116675: ARRAY
116676: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116677: LD_EXP 50
116681: PUSH
116682: LD_VAR 0 1
116686: ARRAY
116687: NOT
116688: PUSH
116689: LD_EXP 50
116693: PUSH
116694: LD_VAR 0 1
116698: ARRAY
116699: PUSH
116700: EMPTY
116701: EQUAL
116702: OR
116703: IFFALSE 116740
// begin for i in solds do
116705: LD_ADDR_VAR 0 7
116709: PUSH
116710: LD_VAR 0 2
116714: PUSH
116715: FOR_IN
116716: IFFALSE 116729
// ComStop ( i ) ;
116718: LD_VAR 0 7
116722: PPUSH
116723: CALL_OW 141
116727: GO 116715
116729: POP
116730: POP
// solds := [ ] ;
116731: LD_ADDR_VAR 0 2
116735: PUSH
116736: EMPTY
116737: ST_TO_ADDR
// exit ;
116738: GO 117100
// end ; for i in solds do
116740: LD_ADDR_VAR 0 7
116744: PUSH
116745: LD_VAR 0 2
116749: PUSH
116750: FOR_IN
116751: IFFALSE 117072
// begin if IsInUnit ( i ) then
116753: LD_VAR 0 7
116757: PPUSH
116758: CALL_OW 310
116762: IFFALSE 116773
// ComExitBuilding ( i ) ;
116764: LD_VAR 0 7
116768: PPUSH
116769: CALL_OW 122
// if GetLives ( i ) > 500 then
116773: LD_VAR 0 7
116777: PPUSH
116778: CALL_OW 256
116782: PUSH
116783: LD_INT 500
116785: GREATER
116786: IFFALSE 116839
// begin e := NearestUnitToUnit ( enemy , i ) ;
116788: LD_ADDR_VAR 0 5
116792: PUSH
116793: LD_VAR 0 4
116797: PPUSH
116798: LD_VAR 0 7
116802: PPUSH
116803: CALL_OW 74
116807: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116808: LD_VAR 0 7
116812: PPUSH
116813: LD_VAR 0 5
116817: PPUSH
116818: CALL_OW 250
116822: PPUSH
116823: LD_VAR 0 5
116827: PPUSH
116828: CALL_OW 251
116832: PPUSH
116833: CALL_OW 114
// end else
116837: GO 117070
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116839: LD_VAR 0 7
116843: PPUSH
116844: LD_EXP 50
116848: PUSH
116849: LD_VAR 0 1
116853: ARRAY
116854: PPUSH
116855: LD_INT 2
116857: PUSH
116858: LD_INT 30
116860: PUSH
116861: LD_INT 0
116863: PUSH
116864: EMPTY
116865: LIST
116866: LIST
116867: PUSH
116868: LD_INT 30
116870: PUSH
116871: LD_INT 1
116873: PUSH
116874: EMPTY
116875: LIST
116876: LIST
116877: PUSH
116878: LD_INT 30
116880: PUSH
116881: LD_INT 6
116883: PUSH
116884: EMPTY
116885: LIST
116886: LIST
116887: PUSH
116888: EMPTY
116889: LIST
116890: LIST
116891: LIST
116892: LIST
116893: PPUSH
116894: CALL_OW 72
116898: PPUSH
116899: LD_VAR 0 7
116903: PPUSH
116904: CALL_OW 74
116908: PPUSH
116909: CALL_OW 296
116913: PUSH
116914: LD_INT 10
116916: GREATER
116917: IFFALSE 117070
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116919: LD_ADDR_VAR 0 8
116923: PUSH
116924: LD_EXP 50
116928: PUSH
116929: LD_VAR 0 1
116933: ARRAY
116934: PPUSH
116935: LD_INT 2
116937: PUSH
116938: LD_INT 30
116940: PUSH
116941: LD_INT 0
116943: PUSH
116944: EMPTY
116945: LIST
116946: LIST
116947: PUSH
116948: LD_INT 30
116950: PUSH
116951: LD_INT 1
116953: PUSH
116954: EMPTY
116955: LIST
116956: LIST
116957: PUSH
116958: LD_INT 30
116960: PUSH
116961: LD_INT 6
116963: PUSH
116964: EMPTY
116965: LIST
116966: LIST
116967: PUSH
116968: EMPTY
116969: LIST
116970: LIST
116971: LIST
116972: LIST
116973: PPUSH
116974: CALL_OW 72
116978: PPUSH
116979: LD_VAR 0 7
116983: PPUSH
116984: CALL_OW 74
116988: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
116989: LD_VAR 0 7
116993: PPUSH
116994: LD_VAR 0 8
116998: PPUSH
116999: CALL_OW 250
117003: PPUSH
117004: LD_INT 3
117006: PPUSH
117007: LD_INT 5
117009: PPUSH
117010: CALL_OW 272
117014: PPUSH
117015: LD_VAR 0 8
117019: PPUSH
117020: CALL_OW 251
117024: PPUSH
117025: LD_INT 3
117027: PPUSH
117028: LD_INT 5
117030: PPUSH
117031: CALL_OW 273
117035: PPUSH
117036: CALL_OW 111
// SetTag ( i , 0 ) ;
117040: LD_VAR 0 7
117044: PPUSH
117045: LD_INT 0
117047: PPUSH
117048: CALL_OW 109
// solds := solds diff i ;
117052: LD_ADDR_VAR 0 2
117056: PUSH
117057: LD_VAR 0 2
117061: PUSH
117062: LD_VAR 0 7
117066: DIFF
117067: ST_TO_ADDR
// continue ;
117068: GO 116750
// end ; end ;
117070: GO 116750
117072: POP
117073: POP
// until not solds or not enemy ;
117074: LD_VAR 0 2
117078: NOT
117079: PUSH
117080: LD_VAR 0 4
117084: NOT
117085: OR
117086: IFFALSE 116654
// MC_Reset ( base , 18 ) ;
117088: LD_VAR 0 1
117092: PPUSH
117093: LD_INT 18
117095: PPUSH
117096: CALL 22566 0 2
// end ;
117100: LD_VAR 0 3
117104: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117105: LD_INT 0
117107: PPUSH
117108: PPUSH
117109: PPUSH
117110: PPUSH
117111: PPUSH
117112: PPUSH
117113: PPUSH
117114: PPUSH
117115: PPUSH
117116: PPUSH
117117: PPUSH
117118: PPUSH
117119: PPUSH
117120: PPUSH
117121: PPUSH
117122: PPUSH
117123: PPUSH
117124: PPUSH
117125: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117126: LD_ADDR_VAR 0 12
117130: PUSH
117131: LD_EXP 50
117135: PUSH
117136: LD_VAR 0 1
117140: ARRAY
117141: PPUSH
117142: LD_INT 25
117144: PUSH
117145: LD_INT 3
117147: PUSH
117148: EMPTY
117149: LIST
117150: LIST
117151: PPUSH
117152: CALL_OW 72
117156: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117157: LD_EXP 90
117161: PUSH
117162: LD_VAR 0 1
117166: ARRAY
117167: IFFALSE 117191
// mechs := mechs diff mc_remote_driver [ base ] ;
117169: LD_ADDR_VAR 0 12
117173: PUSH
117174: LD_VAR 0 12
117178: PUSH
117179: LD_EXP 90
117183: PUSH
117184: LD_VAR 0 1
117188: ARRAY
117189: DIFF
117190: ST_TO_ADDR
// for i in mechs do
117191: LD_ADDR_VAR 0 4
117195: PUSH
117196: LD_VAR 0 12
117200: PUSH
117201: FOR_IN
117202: IFFALSE 117237
// if GetTag ( i ) > 0 then
117204: LD_VAR 0 4
117208: PPUSH
117209: CALL_OW 110
117213: PUSH
117214: LD_INT 0
117216: GREATER
117217: IFFALSE 117235
// mechs := mechs diff i ;
117219: LD_ADDR_VAR 0 12
117223: PUSH
117224: LD_VAR 0 12
117228: PUSH
117229: LD_VAR 0 4
117233: DIFF
117234: ST_TO_ADDR
117235: GO 117201
117237: POP
117238: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117239: LD_ADDR_VAR 0 8
117243: PUSH
117244: LD_EXP 50
117248: PUSH
117249: LD_VAR 0 1
117253: ARRAY
117254: PPUSH
117255: LD_INT 2
117257: PUSH
117258: LD_INT 25
117260: PUSH
117261: LD_INT 1
117263: PUSH
117264: EMPTY
117265: LIST
117266: LIST
117267: PUSH
117268: LD_INT 25
117270: PUSH
117271: LD_INT 5
117273: PUSH
117274: EMPTY
117275: LIST
117276: LIST
117277: PUSH
117278: LD_INT 25
117280: PUSH
117281: LD_INT 8
117283: PUSH
117284: EMPTY
117285: LIST
117286: LIST
117287: PUSH
117288: LD_INT 25
117290: PUSH
117291: LD_INT 9
117293: PUSH
117294: EMPTY
117295: LIST
117296: LIST
117297: PUSH
117298: EMPTY
117299: LIST
117300: LIST
117301: LIST
117302: LIST
117303: LIST
117304: PPUSH
117305: CALL_OW 72
117309: ST_TO_ADDR
// if not defenders and not solds then
117310: LD_VAR 0 2
117314: NOT
117315: PUSH
117316: LD_VAR 0 8
117320: NOT
117321: AND
117322: IFFALSE 117326
// exit ;
117324: GO 119096
// depot_under_attack := false ;
117326: LD_ADDR_VAR 0 16
117330: PUSH
117331: LD_INT 0
117333: ST_TO_ADDR
// sold_defenders := [ ] ;
117334: LD_ADDR_VAR 0 17
117338: PUSH
117339: EMPTY
117340: ST_TO_ADDR
// if mechs then
117341: LD_VAR 0 12
117345: IFFALSE 117498
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117347: LD_ADDR_VAR 0 4
117351: PUSH
117352: LD_VAR 0 2
117356: PPUSH
117357: LD_INT 21
117359: PUSH
117360: LD_INT 2
117362: PUSH
117363: EMPTY
117364: LIST
117365: LIST
117366: PPUSH
117367: CALL_OW 72
117371: PUSH
117372: FOR_IN
117373: IFFALSE 117496
// begin if GetTag ( i ) <> 20 then
117375: LD_VAR 0 4
117379: PPUSH
117380: CALL_OW 110
117384: PUSH
117385: LD_INT 20
117387: NONEQUAL
117388: IFFALSE 117402
// SetTag ( i , 20 ) ;
117390: LD_VAR 0 4
117394: PPUSH
117395: LD_INT 20
117397: PPUSH
117398: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117402: LD_VAR 0 4
117406: PPUSH
117407: CALL_OW 263
117411: PUSH
117412: LD_INT 1
117414: EQUAL
117415: PUSH
117416: LD_VAR 0 4
117420: PPUSH
117421: CALL_OW 311
117425: NOT
117426: AND
117427: IFFALSE 117494
// begin un := mechs [ 1 ] ;
117429: LD_ADDR_VAR 0 10
117433: PUSH
117434: LD_VAR 0 12
117438: PUSH
117439: LD_INT 1
117441: ARRAY
117442: ST_TO_ADDR
// ComExit ( un ) ;
117443: LD_VAR 0 10
117447: PPUSH
117448: CALL 87205 0 1
// AddComEnterUnit ( un , i ) ;
117452: LD_VAR 0 10
117456: PPUSH
117457: LD_VAR 0 4
117461: PPUSH
117462: CALL_OW 180
// SetTag ( un , 19 ) ;
117466: LD_VAR 0 10
117470: PPUSH
117471: LD_INT 19
117473: PPUSH
117474: CALL_OW 109
// mechs := mechs diff un ;
117478: LD_ADDR_VAR 0 12
117482: PUSH
117483: LD_VAR 0 12
117487: PUSH
117488: LD_VAR 0 10
117492: DIFF
117493: ST_TO_ADDR
// end ; end ;
117494: GO 117372
117496: POP
117497: POP
// if solds then
117498: LD_VAR 0 8
117502: IFFALSE 117561
// for i in solds do
117504: LD_ADDR_VAR 0 4
117508: PUSH
117509: LD_VAR 0 8
117513: PUSH
117514: FOR_IN
117515: IFFALSE 117559
// if not GetTag ( i ) then
117517: LD_VAR 0 4
117521: PPUSH
117522: CALL_OW 110
117526: NOT
117527: IFFALSE 117557
// begin defenders := defenders union i ;
117529: LD_ADDR_VAR 0 2
117533: PUSH
117534: LD_VAR 0 2
117538: PUSH
117539: LD_VAR 0 4
117543: UNION
117544: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117545: LD_VAR 0 4
117549: PPUSH
117550: LD_INT 18
117552: PPUSH
117553: CALL_OW 109
// end ;
117557: GO 117514
117559: POP
117560: POP
// repeat wait ( 0 0$2 ) ;
117561: LD_INT 70
117563: PPUSH
117564: CALL_OW 67
// enemy := mc_scan [ base ] ;
117568: LD_ADDR_VAR 0 21
117572: PUSH
117573: LD_EXP 73
117577: PUSH
117578: LD_VAR 0 1
117582: ARRAY
117583: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117584: LD_EXP 50
117588: PUSH
117589: LD_VAR 0 1
117593: ARRAY
117594: NOT
117595: PUSH
117596: LD_EXP 50
117600: PUSH
117601: LD_VAR 0 1
117605: ARRAY
117606: PUSH
117607: EMPTY
117608: EQUAL
117609: OR
117610: IFFALSE 117647
// begin for i in defenders do
117612: LD_ADDR_VAR 0 4
117616: PUSH
117617: LD_VAR 0 2
117621: PUSH
117622: FOR_IN
117623: IFFALSE 117636
// ComStop ( i ) ;
117625: LD_VAR 0 4
117629: PPUSH
117630: CALL_OW 141
117634: GO 117622
117636: POP
117637: POP
// defenders := [ ] ;
117638: LD_ADDR_VAR 0 2
117642: PUSH
117643: EMPTY
117644: ST_TO_ADDR
// exit ;
117645: GO 119096
// end ; for i in defenders do
117647: LD_ADDR_VAR 0 4
117651: PUSH
117652: LD_VAR 0 2
117656: PUSH
117657: FOR_IN
117658: IFFALSE 118556
// begin e := NearestUnitToUnit ( enemy , i ) ;
117660: LD_ADDR_VAR 0 13
117664: PUSH
117665: LD_VAR 0 21
117669: PPUSH
117670: LD_VAR 0 4
117674: PPUSH
117675: CALL_OW 74
117679: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117680: LD_ADDR_VAR 0 7
117684: PUSH
117685: LD_EXP 50
117689: PUSH
117690: LD_VAR 0 1
117694: ARRAY
117695: PPUSH
117696: LD_INT 2
117698: PUSH
117699: LD_INT 30
117701: PUSH
117702: LD_INT 0
117704: PUSH
117705: EMPTY
117706: LIST
117707: LIST
117708: PUSH
117709: LD_INT 30
117711: PUSH
117712: LD_INT 1
117714: PUSH
117715: EMPTY
117716: LIST
117717: LIST
117718: PUSH
117719: EMPTY
117720: LIST
117721: LIST
117722: LIST
117723: PPUSH
117724: CALL_OW 72
117728: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117729: LD_ADDR_VAR 0 16
117733: PUSH
117734: LD_VAR 0 7
117738: NOT
117739: PUSH
117740: LD_VAR 0 7
117744: PPUSH
117745: LD_INT 3
117747: PUSH
117748: LD_INT 24
117750: PUSH
117751: LD_INT 600
117753: PUSH
117754: EMPTY
117755: LIST
117756: LIST
117757: PUSH
117758: EMPTY
117759: LIST
117760: LIST
117761: PPUSH
117762: CALL_OW 72
117766: OR
117767: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117768: LD_VAR 0 4
117772: PPUSH
117773: CALL_OW 247
117777: PUSH
117778: LD_INT 2
117780: DOUBLE
117781: EQUAL
117782: IFTRUE 117786
117784: GO 118182
117786: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117787: LD_VAR 0 4
117791: PPUSH
117792: CALL_OW 256
117796: PUSH
117797: LD_INT 1000
117799: EQUAL
117800: PUSH
117801: LD_VAR 0 4
117805: PPUSH
117806: LD_VAR 0 13
117810: PPUSH
117811: CALL_OW 296
117815: PUSH
117816: LD_INT 40
117818: LESS
117819: PUSH
117820: LD_VAR 0 13
117824: PPUSH
117825: LD_EXP 75
117829: PUSH
117830: LD_VAR 0 1
117834: ARRAY
117835: PPUSH
117836: CALL_OW 308
117840: OR
117841: AND
117842: IFFALSE 117964
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117844: LD_VAR 0 4
117848: PPUSH
117849: CALL_OW 262
117853: PUSH
117854: LD_INT 1
117856: EQUAL
117857: PUSH
117858: LD_VAR 0 4
117862: PPUSH
117863: CALL_OW 261
117867: PUSH
117868: LD_INT 30
117870: LESS
117871: AND
117872: PUSH
117873: LD_VAR 0 7
117877: AND
117878: IFFALSE 117948
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117880: LD_VAR 0 4
117884: PPUSH
117885: LD_VAR 0 7
117889: PPUSH
117890: LD_VAR 0 4
117894: PPUSH
117895: CALL_OW 74
117899: PPUSH
117900: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117904: LD_VAR 0 4
117908: PPUSH
117909: LD_VAR 0 7
117913: PPUSH
117914: LD_VAR 0 4
117918: PPUSH
117919: CALL_OW 74
117923: PPUSH
117924: CALL_OW 296
117928: PUSH
117929: LD_INT 6
117931: LESS
117932: IFFALSE 117946
// SetFuel ( i , 100 ) ;
117934: LD_VAR 0 4
117938: PPUSH
117939: LD_INT 100
117941: PPUSH
117942: CALL_OW 240
// end else
117946: GO 117962
// ComAttackUnit ( i , e ) ;
117948: LD_VAR 0 4
117952: PPUSH
117953: LD_VAR 0 13
117957: PPUSH
117958: CALL_OW 115
// end else
117962: GO 118065
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
117964: LD_VAR 0 13
117968: PPUSH
117969: LD_EXP 75
117973: PUSH
117974: LD_VAR 0 1
117978: ARRAY
117979: PPUSH
117980: CALL_OW 308
117984: NOT
117985: PUSH
117986: LD_VAR 0 4
117990: PPUSH
117991: LD_VAR 0 13
117995: PPUSH
117996: CALL_OW 296
118000: PUSH
118001: LD_INT 40
118003: GREATEREQUAL
118004: AND
118005: PUSH
118006: LD_VAR 0 4
118010: PPUSH
118011: CALL_OW 256
118015: PUSH
118016: LD_INT 650
118018: LESSEQUAL
118019: OR
118020: PUSH
118021: LD_VAR 0 4
118025: PPUSH
118026: LD_EXP 74
118030: PUSH
118031: LD_VAR 0 1
118035: ARRAY
118036: PPUSH
118037: CALL_OW 308
118041: NOT
118042: AND
118043: IFFALSE 118065
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118045: LD_VAR 0 4
118049: PPUSH
118050: LD_EXP 74
118054: PUSH
118055: LD_VAR 0 1
118059: ARRAY
118060: PPUSH
118061: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118065: LD_VAR 0 4
118069: PPUSH
118070: CALL_OW 256
118074: PUSH
118075: LD_INT 1000
118077: LESS
118078: PUSH
118079: LD_VAR 0 4
118083: PPUSH
118084: CALL_OW 263
118088: PUSH
118089: LD_INT 1
118091: EQUAL
118092: AND
118093: PUSH
118094: LD_VAR 0 4
118098: PPUSH
118099: CALL_OW 311
118103: AND
118104: PUSH
118105: LD_VAR 0 4
118109: PPUSH
118110: LD_EXP 74
118114: PUSH
118115: LD_VAR 0 1
118119: ARRAY
118120: PPUSH
118121: CALL_OW 308
118125: AND
118126: IFFALSE 118180
// begin mech := IsDrivenBy ( i ) ;
118128: LD_ADDR_VAR 0 9
118132: PUSH
118133: LD_VAR 0 4
118137: PPUSH
118138: CALL_OW 311
118142: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118143: LD_VAR 0 9
118147: PPUSH
118148: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118152: LD_VAR 0 9
118156: PPUSH
118157: LD_VAR 0 4
118161: PPUSH
118162: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118166: LD_VAR 0 9
118170: PPUSH
118171: LD_VAR 0 4
118175: PPUSH
118176: CALL_OW 180
// end ; end ; unit_human :
118180: GO 118527
118182: LD_INT 1
118184: DOUBLE
118185: EQUAL
118186: IFTRUE 118190
118188: GO 118526
118190: POP
// begin b := IsInUnit ( i ) ;
118191: LD_ADDR_VAR 0 18
118195: PUSH
118196: LD_VAR 0 4
118200: PPUSH
118201: CALL_OW 310
118205: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118206: LD_ADDR_VAR 0 19
118210: PUSH
118211: LD_VAR 0 18
118215: NOT
118216: PUSH
118217: LD_VAR 0 18
118221: PPUSH
118222: CALL_OW 266
118226: PUSH
118227: LD_INT 32
118229: PUSH
118230: LD_INT 31
118232: PUSH
118233: EMPTY
118234: LIST
118235: LIST
118236: IN
118237: OR
118238: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118239: LD_VAR 0 18
118243: PPUSH
118244: CALL_OW 266
118248: PUSH
118249: LD_INT 5
118251: EQUAL
118252: PUSH
118253: LD_VAR 0 4
118257: PPUSH
118258: CALL_OW 257
118262: PUSH
118263: LD_INT 1
118265: PUSH
118266: LD_INT 2
118268: PUSH
118269: LD_INT 3
118271: PUSH
118272: LD_INT 4
118274: PUSH
118275: EMPTY
118276: LIST
118277: LIST
118278: LIST
118279: LIST
118280: IN
118281: AND
118282: IFFALSE 118319
// begin class := AllowSpecClass ( i ) ;
118284: LD_ADDR_VAR 0 20
118288: PUSH
118289: LD_VAR 0 4
118293: PPUSH
118294: CALL 50891 0 1
118298: ST_TO_ADDR
// if class then
118299: LD_VAR 0 20
118303: IFFALSE 118319
// ComChangeProfession ( i , class ) ;
118305: LD_VAR 0 4
118309: PPUSH
118310: LD_VAR 0 20
118314: PPUSH
118315: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118319: LD_VAR 0 16
118323: PUSH
118324: LD_VAR 0 2
118328: PPUSH
118329: LD_INT 21
118331: PUSH
118332: LD_INT 2
118334: PUSH
118335: EMPTY
118336: LIST
118337: LIST
118338: PPUSH
118339: CALL_OW 72
118343: PUSH
118344: LD_INT 1
118346: LESSEQUAL
118347: OR
118348: PUSH
118349: LD_VAR 0 19
118353: AND
118354: PUSH
118355: LD_VAR 0 4
118359: PUSH
118360: LD_VAR 0 17
118364: IN
118365: NOT
118366: AND
118367: IFFALSE 118460
// begin if b then
118369: LD_VAR 0 18
118373: IFFALSE 118422
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118375: LD_VAR 0 18
118379: PPUSH
118380: LD_VAR 0 21
118384: PPUSH
118385: LD_VAR 0 18
118389: PPUSH
118390: CALL_OW 74
118394: PPUSH
118395: CALL_OW 296
118399: PUSH
118400: LD_INT 10
118402: LESS
118403: PUSH
118404: LD_VAR 0 18
118408: PPUSH
118409: CALL_OW 461
118413: PUSH
118414: LD_INT 7
118416: NONEQUAL
118417: AND
118418: IFFALSE 118422
// continue ;
118420: GO 117657
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118422: LD_ADDR_VAR 0 17
118426: PUSH
118427: LD_VAR 0 17
118431: PPUSH
118432: LD_VAR 0 17
118436: PUSH
118437: LD_INT 1
118439: PLUS
118440: PPUSH
118441: LD_VAR 0 4
118445: PPUSH
118446: CALL_OW 1
118450: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118451: LD_VAR 0 4
118455: PPUSH
118456: CALL_OW 122
// end ; if sold_defenders then
118460: LD_VAR 0 17
118464: IFFALSE 118524
// if i in sold_defenders then
118466: LD_VAR 0 4
118470: PUSH
118471: LD_VAR 0 17
118475: IN
118476: IFFALSE 118524
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118478: LD_VAR 0 4
118482: PPUSH
118483: CALL_OW 314
118487: NOT
118488: PUSH
118489: LD_VAR 0 4
118493: PPUSH
118494: LD_VAR 0 13
118498: PPUSH
118499: CALL_OW 296
118503: PUSH
118504: LD_INT 30
118506: LESS
118507: AND
118508: IFFALSE 118524
// ComAttackUnit ( i , e ) ;
118510: LD_VAR 0 4
118514: PPUSH
118515: LD_VAR 0 13
118519: PPUSH
118520: CALL_OW 115
// end ; end ; end ;
118524: GO 118527
118526: POP
// if IsDead ( i ) then
118527: LD_VAR 0 4
118531: PPUSH
118532: CALL_OW 301
118536: IFFALSE 118554
// defenders := defenders diff i ;
118538: LD_ADDR_VAR 0 2
118542: PUSH
118543: LD_VAR 0 2
118547: PUSH
118548: LD_VAR 0 4
118552: DIFF
118553: ST_TO_ADDR
// end ;
118554: GO 117657
118556: POP
118557: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118558: LD_VAR 0 21
118562: NOT
118563: PUSH
118564: LD_VAR 0 2
118568: NOT
118569: OR
118570: PUSH
118571: LD_EXP 50
118575: PUSH
118576: LD_VAR 0 1
118580: ARRAY
118581: NOT
118582: OR
118583: IFFALSE 117561
// MC_Reset ( base , 18 ) ;
118585: LD_VAR 0 1
118589: PPUSH
118590: LD_INT 18
118592: PPUSH
118593: CALL 22566 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118597: LD_ADDR_VAR 0 2
118601: PUSH
118602: LD_VAR 0 2
118606: PUSH
118607: LD_VAR 0 2
118611: PPUSH
118612: LD_INT 2
118614: PUSH
118615: LD_INT 25
118617: PUSH
118618: LD_INT 1
118620: PUSH
118621: EMPTY
118622: LIST
118623: LIST
118624: PUSH
118625: LD_INT 25
118627: PUSH
118628: LD_INT 5
118630: PUSH
118631: EMPTY
118632: LIST
118633: LIST
118634: PUSH
118635: LD_INT 25
118637: PUSH
118638: LD_INT 8
118640: PUSH
118641: EMPTY
118642: LIST
118643: LIST
118644: PUSH
118645: LD_INT 25
118647: PUSH
118648: LD_INT 9
118650: PUSH
118651: EMPTY
118652: LIST
118653: LIST
118654: PUSH
118655: EMPTY
118656: LIST
118657: LIST
118658: LIST
118659: LIST
118660: LIST
118661: PPUSH
118662: CALL_OW 72
118666: DIFF
118667: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118668: LD_VAR 0 21
118672: NOT
118673: PUSH
118674: LD_VAR 0 2
118678: PPUSH
118679: LD_INT 21
118681: PUSH
118682: LD_INT 2
118684: PUSH
118685: EMPTY
118686: LIST
118687: LIST
118688: PPUSH
118689: CALL_OW 72
118693: AND
118694: IFFALSE 119032
// begin tmp := FilterByTag ( defenders , 19 ) ;
118696: LD_ADDR_VAR 0 11
118700: PUSH
118701: LD_VAR 0 2
118705: PPUSH
118706: LD_INT 19
118708: PPUSH
118709: CALL 84376 0 2
118713: ST_TO_ADDR
// if tmp then
118714: LD_VAR 0 11
118718: IFFALSE 118788
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118720: LD_ADDR_VAR 0 11
118724: PUSH
118725: LD_VAR 0 11
118729: PPUSH
118730: LD_INT 25
118732: PUSH
118733: LD_INT 3
118735: PUSH
118736: EMPTY
118737: LIST
118738: LIST
118739: PPUSH
118740: CALL_OW 72
118744: ST_TO_ADDR
// if tmp then
118745: LD_VAR 0 11
118749: IFFALSE 118788
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118751: LD_ADDR_EXP 62
118755: PUSH
118756: LD_EXP 62
118760: PPUSH
118761: LD_VAR 0 1
118765: PPUSH
118766: LD_EXP 62
118770: PUSH
118771: LD_VAR 0 1
118775: ARRAY
118776: PUSH
118777: LD_VAR 0 11
118781: UNION
118782: PPUSH
118783: CALL_OW 1
118787: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118788: LD_VAR 0 1
118792: PPUSH
118793: LD_INT 19
118795: PPUSH
118796: CALL 22566 0 2
// repeat wait ( 0 0$1 ) ;
118800: LD_INT 35
118802: PPUSH
118803: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118807: LD_EXP 50
118811: PUSH
118812: LD_VAR 0 1
118816: ARRAY
118817: NOT
118818: PUSH
118819: LD_EXP 50
118823: PUSH
118824: LD_VAR 0 1
118828: ARRAY
118829: PUSH
118830: EMPTY
118831: EQUAL
118832: OR
118833: IFFALSE 118870
// begin for i in defenders do
118835: LD_ADDR_VAR 0 4
118839: PUSH
118840: LD_VAR 0 2
118844: PUSH
118845: FOR_IN
118846: IFFALSE 118859
// ComStop ( i ) ;
118848: LD_VAR 0 4
118852: PPUSH
118853: CALL_OW 141
118857: GO 118845
118859: POP
118860: POP
// defenders := [ ] ;
118861: LD_ADDR_VAR 0 2
118865: PUSH
118866: EMPTY
118867: ST_TO_ADDR
// exit ;
118868: GO 119096
// end ; for i in defenders do
118870: LD_ADDR_VAR 0 4
118874: PUSH
118875: LD_VAR 0 2
118879: PUSH
118880: FOR_IN
118881: IFFALSE 118970
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118883: LD_VAR 0 4
118887: PPUSH
118888: LD_EXP 74
118892: PUSH
118893: LD_VAR 0 1
118897: ARRAY
118898: PPUSH
118899: CALL_OW 308
118903: NOT
118904: IFFALSE 118928
// ComMoveToArea ( i , mc_parking [ base ] ) else
118906: LD_VAR 0 4
118910: PPUSH
118911: LD_EXP 74
118915: PUSH
118916: LD_VAR 0 1
118920: ARRAY
118921: PPUSH
118922: CALL_OW 113
118926: GO 118968
// if GetControl ( i ) = control_manual then
118928: LD_VAR 0 4
118932: PPUSH
118933: CALL_OW 263
118937: PUSH
118938: LD_INT 1
118940: EQUAL
118941: IFFALSE 118968
// if IsDrivenBy ( i ) then
118943: LD_VAR 0 4
118947: PPUSH
118948: CALL_OW 311
118952: IFFALSE 118968
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
118954: LD_VAR 0 4
118958: PPUSH
118959: CALL_OW 311
118963: PPUSH
118964: CALL_OW 121
// end ;
118968: GO 118880
118970: POP
118971: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
118972: LD_VAR 0 2
118976: PPUSH
118977: LD_INT 95
118979: PUSH
118980: LD_EXP 74
118984: PUSH
118985: LD_VAR 0 1
118989: ARRAY
118990: PUSH
118991: EMPTY
118992: LIST
118993: LIST
118994: PPUSH
118995: CALL_OW 72
118999: PUSH
119000: LD_VAR 0 2
119004: EQUAL
119005: PUSH
119006: LD_EXP 73
119010: PUSH
119011: LD_VAR 0 1
119015: ARRAY
119016: OR
119017: PUSH
119018: LD_EXP 50
119022: PUSH
119023: LD_VAR 0 1
119027: ARRAY
119028: NOT
119029: OR
119030: IFFALSE 118800
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119032: LD_ADDR_EXP 72
119036: PUSH
119037: LD_EXP 72
119041: PPUSH
119042: LD_VAR 0 1
119046: PPUSH
119047: LD_VAR 0 2
119051: PPUSH
119052: LD_INT 21
119054: PUSH
119055: LD_INT 2
119057: PUSH
119058: EMPTY
119059: LIST
119060: LIST
119061: PPUSH
119062: CALL_OW 72
119066: PPUSH
119067: CALL_OW 1
119071: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119072: LD_VAR 0 1
119076: PPUSH
119077: LD_INT 19
119079: PPUSH
119080: CALL 22566 0 2
// MC_Reset ( base , 20 ) ;
119084: LD_VAR 0 1
119088: PPUSH
119089: LD_INT 20
119091: PPUSH
119092: CALL 22566 0 2
// end ; end_of_file
119096: LD_VAR 0 3
119100: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119101: LD_VAR 0 1
119105: PUSH
119106: LD_INT 200
119108: DOUBLE
119109: GREATEREQUAL
119110: IFFALSE 119118
119112: LD_INT 299
119114: DOUBLE
119115: LESSEQUAL
119116: IFTRUE 119120
119118: GO 119152
119120: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119121: LD_VAR 0 1
119125: PPUSH
119126: LD_VAR 0 2
119130: PPUSH
119131: LD_VAR 0 3
119135: PPUSH
119136: LD_VAR 0 4
119140: PPUSH
119141: LD_VAR 0 5
119145: PPUSH
119146: CALL 107448 0 5
119150: GO 119229
119152: LD_INT 300
119154: DOUBLE
119155: GREATEREQUAL
119156: IFFALSE 119164
119158: LD_INT 399
119160: DOUBLE
119161: LESSEQUAL
119162: IFTRUE 119166
119164: GO 119228
119166: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119167: LD_VAR 0 1
119171: PPUSH
119172: LD_VAR 0 2
119176: PPUSH
119177: LD_VAR 0 3
119181: PPUSH
119182: LD_VAR 0 4
119186: PPUSH
119187: LD_VAR 0 5
119191: PPUSH
119192: LD_VAR 0 6
119196: PPUSH
119197: LD_VAR 0 7
119201: PPUSH
119202: LD_VAR 0 8
119206: PPUSH
119207: LD_VAR 0 9
119211: PPUSH
119212: LD_VAR 0 10
119216: PPUSH
119217: LD_VAR 0 11
119221: PPUSH
119222: CALL 103773 0 11
119226: GO 119229
119228: POP
// end ;
119229: PPOPN 11
119231: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119232: LD_VAR 0 1
119236: PPUSH
119237: LD_VAR 0 2
119241: PPUSH
119242: LD_VAR 0 3
119246: PPUSH
119247: LD_VAR 0 4
119251: PPUSH
119252: LD_VAR 0 5
119256: PPUSH
119257: CALL 107184 0 5
// end ; end_of_file
119261: PPOPN 5
119263: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119264: LD_VAR 0 1
119268: PPUSH
119269: LD_VAR 0 2
119273: PPUSH
119274: LD_VAR 0 3
119278: PPUSH
119279: LD_VAR 0 4
119283: PPUSH
119284: LD_VAR 0 5
119288: PPUSH
119289: LD_VAR 0 6
119293: PPUSH
119294: CALL 91425 0 6
// end ;
119298: PPOPN 6
119300: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119301: LD_INT 0
119303: PPUSH
// begin if not units then
119304: LD_VAR 0 1
119308: NOT
119309: IFFALSE 119313
// exit ;
119311: GO 119313
// end ;
119313: PPOPN 7
119315: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119316: CALL 91329 0 0
// end ;
119320: PPOPN 1
119322: END
