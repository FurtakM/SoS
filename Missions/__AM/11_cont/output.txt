// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17991 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82786 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20163 0 0
// Action ;
  89: CALL 8544 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 41901 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 41901 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 41901 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42327 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42219 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42219 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 48655 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 48655 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 48655 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 48655 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 48655 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 48655 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 48655 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 48655 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 48655 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 48655 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 48655 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 48655 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 48655 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 48655 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 48655 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 2
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57114 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57114 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57114 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57114 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57114 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 53670 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 53670 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 53792 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42615 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42219 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 54688 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5053: LD_EXP 6
5057: IFFALSE 7920
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
5071: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5072: LD_ADDR_VAR 0 4
5076: PUSH
5077: LD_INT 5
5079: PUSH
5080: LD_INT 6
5082: PUSH
5083: LD_INT 7
5085: PUSH
5086: LD_INT 8
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: ST_TO_ADDR
// coords := [ ] ;
5101: LD_ADDR_VAR 0 5
5105: PUSH
5106: EMPTY
5107: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5108: LD_ADDR_VAR 0 6
5112: PUSH
5113: LD_INT 0
5115: PUSH
5116: LD_INT 0
5118: PUSH
5119: LD_INT 0
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 1
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: LIST
5154: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5155: LD_INT 1
5157: PPUSH
5158: LD_INT 14
5160: PUSH
5161: LD_INT 1
5163: PUSH
5164: LD_INT 2
5166: PUSH
5167: LD_INT 28
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 25
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 28
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 29
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: PPUSH
5236: CALL 42219 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5240: LD_INT 21000
5242: PUSH
5243: LD_INT 19950
5245: PUSH
5246: LD_INT 18900
5248: PUSH
5249: LD_INT 18200
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: PUSH
5258: LD_OWVAR 67
5262: ARRAY
5263: PPUSH
5264: CALL_OW 67
// InitHc ;
5268: CALL_OW 19
// InitUc ;
5272: CALL_OW 18
// uc_side := 2 ;
5276: LD_ADDR_OWVAR 20
5280: PUSH
5281: LD_INT 2
5283: ST_TO_ADDR
// uc_nation := 2 ;
5284: LD_ADDR_OWVAR 21
5288: PUSH
5289: LD_INT 2
5291: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5292: LD_ADDR_VAR 0 3
5296: PUSH
5297: EMPTY
5298: PUSH
5299: EMPTY
5300: PUSH
5301: EMPTY
5302: PUSH
5303: EMPTY
5304: PUSH
5305: EMPTY
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: LIST
5313: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5314: LD_ADDR_VAR 0 3
5318: PUSH
5319: LD_VAR 0 3
5323: PPUSH
5324: LD_INT 1
5326: PPUSH
5327: LD_EXP 69
5331: PUSH
5332: LD_INT 1
5334: ARRAY
5335: PUSH
5336: LD_INT 2
5338: PUSH
5339: LD_INT 34
5341: PUSH
5342: LD_INT 88
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PUSH
5349: LD_INT 34
5351: PUSH
5352: LD_INT 32
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL_OW 69
5368: DIFF
5369: PPUSH
5370: CALL_OW 1
5374: ST_TO_ADDR
// for i = 1 to Difficulty do
5375: LD_ADDR_VAR 0 1
5379: PUSH
5380: DOUBLE
5381: LD_INT 1
5383: DEC
5384: ST_TO_ADDR
5385: LD_OWVAR 67
5389: PUSH
5390: FOR_TO
5391: IFFALSE 5529
// begin uc_side := 2 ;
5393: LD_ADDR_OWVAR 20
5397: PUSH
5398: LD_INT 2
5400: ST_TO_ADDR
// uc_nation := 2 ;
5401: LD_ADDR_OWVAR 21
5405: PUSH
5406: LD_INT 2
5408: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5409: LD_INT 13
5411: PPUSH
5412: LD_INT 3
5414: PPUSH
5415: LD_INT 5
5417: PPUSH
5418: LD_INT 29
5420: PPUSH
5421: LD_INT 100
5423: PPUSH
5424: CALL 53670 0 5
// un := CreateVehicle ;
5428: LD_ADDR_VAR 0 2
5432: PUSH
5433: CALL_OW 45
5437: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5438: LD_ADDR_VAR 0 3
5442: PUSH
5443: LD_VAR 0 3
5447: PPUSH
5448: LD_INT 1
5450: PUSH
5451: LD_VAR 0 3
5455: PUSH
5456: LD_INT 1
5458: ARRAY
5459: PUSH
5460: LD_INT 1
5462: PLUS
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PPUSH
5468: LD_VAR 0 2
5472: PPUSH
5473: CALL 53792 0 3
5477: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5478: LD_VAR 0 2
5482: PPUSH
5483: LD_INT 3
5485: PPUSH
5486: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5490: LD_VAR 0 2
5494: PPUSH
5495: LD_INT 16
5497: PPUSH
5498: LD_INT 0
5500: PPUSH
5501: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5505: LD_VAR 0 2
5509: PPUSH
5510: LD_INT 51
5512: PPUSH
5513: LD_INT 10
5515: PPUSH
5516: CALL_OW 111
// wait ( 0 0$2 ) ;
5520: LD_INT 70
5522: PPUSH
5523: CALL_OW 67
// end ;
5527: GO 5390
5529: POP
5530: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5531: LD_ADDR_VAR 0 5
5535: PUSH
5536: LD_INT 51
5538: PUSH
5539: LD_INT 24
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: PUSH
5546: LD_INT 75
5548: PUSH
5549: LD_INT 90
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5560: LD_INT 1
5562: PPUSH
5563: LD_VAR 0 3
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PPUSH
5572: LD_VAR 0 5
5576: PPUSH
5577: LD_VAR 0 6
5581: PPUSH
5582: CALL 42452 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5586: LD_ADDR_VAR 0 1
5590: PUSH
5591: DOUBLE
5592: LD_INT 1
5594: DEC
5595: ST_TO_ADDR
5596: LD_INT 1
5598: PUSH
5599: LD_INT 3
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: LD_INT 3
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_OWVAR 67
5618: ARRAY
5619: PUSH
5620: FOR_TO
5621: IFFALSE 5721
// begin uc_side := 2 ;
5623: LD_ADDR_OWVAR 20
5627: PUSH
5628: LD_INT 2
5630: ST_TO_ADDR
// uc_nation := 2 ;
5631: LD_ADDR_OWVAR 21
5635: PUSH
5636: LD_INT 2
5638: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5639: LD_INT 0
5641: PPUSH
5642: LD_INT 17
5644: PPUSH
5645: LD_VAR 0 4
5649: PPUSH
5650: CALL_OW 380
// un := CreateHuman ;
5654: LD_ADDR_VAR 0 2
5658: PUSH
5659: CALL_OW 44
5663: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5664: LD_ADDR_VAR 0 3
5668: PUSH
5669: LD_VAR 0 3
5673: PPUSH
5674: LD_INT 2
5676: PUSH
5677: LD_VAR 0 3
5681: PUSH
5682: LD_INT 2
5684: ARRAY
5685: PUSH
5686: LD_INT 1
5688: PLUS
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: PPUSH
5694: LD_VAR 0 2
5698: PPUSH
5699: CALL 53792 0 3
5703: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5704: LD_VAR 0 2
5708: PPUSH
5709: LD_INT 13
5711: PPUSH
5712: LD_INT 0
5714: PPUSH
5715: CALL_OW 49
// end ;
5719: GO 5620
5721: POP
5722: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5723: LD_ADDR_VAR 0 1
5727: PUSH
5728: DOUBLE
5729: LD_INT 1
5731: DEC
5732: ST_TO_ADDR
5733: LD_INT 3
5735: PUSH
5736: LD_INT 4
5738: PUSH
5739: LD_INT 4
5741: PUSH
5742: LD_INT 4
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: ARRAY
5756: PUSH
5757: FOR_TO
5758: IFFALSE 5879
// begin uc_side := 2 ;
5760: LD_ADDR_OWVAR 20
5764: PUSH
5765: LD_INT 2
5767: ST_TO_ADDR
// uc_nation := 2 ;
5768: LD_ADDR_OWVAR 21
5772: PUSH
5773: LD_INT 2
5775: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5776: LD_INT 0
5778: PPUSH
5779: LD_INT 1
5781: PUSH
5782: LD_INT 8
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: LD_VAR 0 1
5793: PUSH
5794: LD_INT 2
5796: MOD
5797: PUSH
5798: LD_INT 1
5800: PLUS
5801: ARRAY
5802: PPUSH
5803: LD_VAR 0 4
5807: PPUSH
5808: CALL_OW 380
// un := CreateHuman ;
5812: LD_ADDR_VAR 0 2
5816: PUSH
5817: CALL_OW 44
5821: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5822: LD_ADDR_VAR 0 3
5826: PUSH
5827: LD_VAR 0 3
5831: PPUSH
5832: LD_INT 2
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_INT 2
5842: ARRAY
5843: PUSH
5844: LD_INT 1
5846: PLUS
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: LD_VAR 0 2
5856: PPUSH
5857: CALL 53792 0 3
5861: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5862: LD_VAR 0 2
5866: PPUSH
5867: LD_INT 13
5869: PPUSH
5870: LD_INT 0
5872: PPUSH
5873: CALL_OW 49
// end ;
5877: GO 5757
5879: POP
5880: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5881: LD_ADDR_VAR 0 5
5885: PUSH
5886: LD_INT 67
5888: PUSH
5889: LD_INT 112
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: LD_INT 85
5898: PUSH
5899: LD_INT 130
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5910: LD_INT 2
5912: PPUSH
5913: LD_VAR 0 3
5917: PUSH
5918: LD_INT 2
5920: ARRAY
5921: PPUSH
5922: LD_VAR 0 5
5926: PPUSH
5927: LD_VAR 0 6
5931: PPUSH
5932: CALL 42452 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5936: LD_ADDR_VAR 0 1
5940: PUSH
5941: DOUBLE
5942: LD_INT 1
5944: DEC
5945: ST_TO_ADDR
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 3
5954: PUSH
5955: LD_INT 4
5957: PUSH
5958: EMPTY
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: PUSH
5964: LD_OWVAR 67
5968: ARRAY
5969: PUSH
5970: FOR_TO
5971: IFFALSE 6071
// begin uc_side := 2 ;
5973: LD_ADDR_OWVAR 20
5977: PUSH
5978: LD_INT 2
5980: ST_TO_ADDR
// uc_nation := 2 ;
5981: LD_ADDR_OWVAR 21
5985: PUSH
5986: LD_INT 2
5988: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5989: LD_INT 0
5991: PPUSH
5992: LD_INT 17
5994: PPUSH
5995: LD_VAR 0 4
5999: PPUSH
6000: CALL_OW 380
// un := CreateHuman ;
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: CALL_OW 44
6013: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6014: LD_ADDR_VAR 0 3
6018: PUSH
6019: LD_VAR 0 3
6023: PPUSH
6024: LD_INT 3
6026: PUSH
6027: LD_VAR 0 3
6031: PUSH
6032: LD_INT 3
6034: ARRAY
6035: PUSH
6036: LD_INT 1
6038: PLUS
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PPUSH
6044: LD_VAR 0 2
6048: PPUSH
6049: CALL 53792 0 3
6053: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 14
6061: PPUSH
6062: LD_INT 0
6064: PPUSH
6065: CALL_OW 49
// end ;
6069: GO 5970
6071: POP
6072: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6073: LD_ADDR_VAR 0 5
6077: PUSH
6078: LD_INT 148
6080: PUSH
6081: LD_INT 158
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: PUSH
6088: LD_INT 148
6090: PUSH
6091: LD_INT 158
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6102: LD_INT 3
6104: PPUSH
6105: LD_VAR 0 3
6109: PUSH
6110: LD_INT 3
6112: ARRAY
6113: PPUSH
6114: LD_VAR 0 5
6118: PPUSH
6119: LD_VAR 0 6
6123: PPUSH
6124: CALL 42452 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: DOUBLE
6134: LD_INT 1
6136: DEC
6137: ST_TO_ADDR
6138: LD_INT 2
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 4
6146: PUSH
6147: LD_INT 4
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_OWVAR 67
6160: ARRAY
6161: PUSH
6162: FOR_TO
6163: IFFALSE 6387
// begin uc_side := 2 ;
6165: LD_ADDR_OWVAR 20
6169: PUSH
6170: LD_INT 2
6172: ST_TO_ADDR
// uc_nation := 2 ;
6173: LD_ADDR_OWVAR 21
6177: PUSH
6178: LD_INT 2
6180: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6181: LD_INT 14
6183: PPUSH
6184: LD_INT 3
6186: PPUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 5
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 1
6199: PPUSH
6200: LD_INT 2
6202: PPUSH
6203: CALL_OW 12
6207: ARRAY
6208: PPUSH
6209: LD_INT 27
6211: PUSH
6212: LD_INT 26
6214: PUSH
6215: LD_INT 28
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: LIST
6222: PUSH
6223: LD_INT 1
6225: PPUSH
6226: LD_INT 3
6228: PPUSH
6229: CALL_OW 12
6233: ARRAY
6234: PPUSH
6235: LD_INT 100
6237: PPUSH
6238: CALL 53670 0 5
// un := CreateVehicle ;
6242: LD_ADDR_VAR 0 2
6246: PUSH
6247: CALL_OW 45
6251: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6252: LD_ADDR_VAR 0 3
6256: PUSH
6257: LD_VAR 0 3
6261: PPUSH
6262: LD_INT 4
6264: PUSH
6265: LD_VAR 0 3
6269: PUSH
6270: LD_INT 4
6272: ARRAY
6273: PUSH
6274: LD_INT 1
6276: PLUS
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PPUSH
6282: LD_VAR 0 2
6286: PPUSH
6287: CALL 53792 0 3
6291: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6292: LD_VAR 0 2
6296: PPUSH
6297: LD_INT 5
6299: PPUSH
6300: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6304: LD_VAR 0 2
6308: PPUSH
6309: LD_INT 15
6311: PPUSH
6312: LD_INT 0
6314: PPUSH
6315: CALL_OW 49
// if GetControl ( un ) = control_manual then
6319: LD_VAR 0 2
6323: PPUSH
6324: CALL_OW 263
6328: PUSH
6329: LD_INT 1
6331: EQUAL
6332: IFFALSE 6363
// begin PrepareHuman ( false , 3 , skill ) ;
6334: LD_INT 0
6336: PPUSH
6337: LD_INT 3
6339: PPUSH
6340: LD_VAR 0 4
6344: PPUSH
6345: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6349: CALL_OW 44
6353: PPUSH
6354: LD_VAR 0 2
6358: PPUSH
6359: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6363: LD_VAR 0 2
6367: PPUSH
6368: LD_INT 179
6370: PPUSH
6371: LD_INT 135
6373: PPUSH
6374: CALL_OW 111
// wait ( 0 0$2 ) ;
6378: LD_INT 70
6380: PPUSH
6381: CALL_OW 67
// end ;
6385: GO 6162
6387: POP
6388: POP
// vc_chassis := 15 ;
6389: LD_ADDR_OWVAR 37
6393: PUSH
6394: LD_INT 15
6396: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6397: LD_ADDR_VAR 0 3
6401: PUSH
6402: LD_VAR 0 3
6406: PPUSH
6407: LD_INT 4
6409: PUSH
6410: LD_VAR 0 3
6414: PUSH
6415: LD_INT 4
6417: ARRAY
6418: PUSH
6419: LD_INT 1
6421: PLUS
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PPUSH
6427: CALL_OW 45
6431: PPUSH
6432: CALL 53792 0 3
6436: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6437: LD_VAR 0 3
6441: PUSH
6442: LD_INT 4
6444: ARRAY
6445: PUSH
6446: LD_VAR 0 3
6450: PUSH
6451: LD_INT 4
6453: ARRAY
6454: ARRAY
6455: PPUSH
6456: LD_INT 15
6458: PPUSH
6459: LD_INT 0
6461: PPUSH
6462: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6466: LD_INT 0
6468: PPUSH
6469: LD_INT 11
6471: PPUSH
6472: LD_VAR 0 4
6476: PPUSH
6477: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6481: LD_ADDR_VAR 0 3
6485: PUSH
6486: LD_VAR 0 3
6490: PPUSH
6491: LD_INT 4
6493: PUSH
6494: LD_VAR 0 3
6498: PUSH
6499: LD_INT 4
6501: ARRAY
6502: PUSH
6503: LD_INT 1
6505: PLUS
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PPUSH
6511: CALL_OW 44
6515: PPUSH
6516: CALL 53792 0 3
6520: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6521: LD_VAR 0 3
6525: PUSH
6526: LD_INT 4
6528: ARRAY
6529: PUSH
6530: LD_VAR 0 3
6534: PUSH
6535: LD_INT 4
6537: ARRAY
6538: ARRAY
6539: PPUSH
6540: LD_VAR 0 3
6544: PUSH
6545: LD_INT 4
6547: ARRAY
6548: PUSH
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 4
6556: ARRAY
6557: PUSH
6558: LD_INT 1
6560: MINUS
6561: ARRAY
6562: PPUSH
6563: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6567: LD_ADDR_VAR 0 5
6571: PUSH
6572: LD_INT 148
6574: PUSH
6575: LD_INT 140
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: PUSH
6582: EMPTY
6583: LIST
6584: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6585: LD_INT 1
6587: PPUSH
6588: LD_VAR 0 3
6592: PUSH
6593: LD_INT 4
6595: ARRAY
6596: PPUSH
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 6
6606: PPUSH
6607: CALL 42452 0 4
// if gensher_active then
6611: LD_EXP 18
6615: IFFALSE 7021
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6617: LD_EXP 45
6621: PPUSH
6622: LD_STRING D10-Diet-1
6624: PPUSH
6625: CALL_OW 94
// for i = 1 to 2 do
6629: LD_ADDR_VAR 0 1
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_INT 2
6641: PUSH
6642: FOR_TO
6643: IFFALSE 6781
// begin uc_side := 2 ;
6645: LD_ADDR_OWVAR 20
6649: PUSH
6650: LD_INT 2
6652: ST_TO_ADDR
// uc_nation := 2 ;
6653: LD_ADDR_OWVAR 21
6657: PUSH
6658: LD_INT 2
6660: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6661: LD_INT 13
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: LD_INT 5
6669: PPUSH
6670: LD_INT 29
6672: PPUSH
6673: LD_INT 100
6675: PPUSH
6676: CALL 53670 0 5
// un := CreateVehicle ;
6680: LD_ADDR_VAR 0 2
6684: PUSH
6685: CALL_OW 45
6689: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6690: LD_ADDR_VAR 0 3
6694: PUSH
6695: LD_VAR 0 3
6699: PPUSH
6700: LD_INT 5
6702: PUSH
6703: LD_VAR 0 3
6707: PUSH
6708: LD_INT 5
6710: ARRAY
6711: PUSH
6712: LD_INT 1
6714: PLUS
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: PPUSH
6720: LD_VAR 0 2
6724: PPUSH
6725: CALL 53792 0 3
6729: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6730: LD_VAR 0 2
6734: PPUSH
6735: LD_INT 0
6737: PPUSH
6738: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6742: LD_VAR 0 2
6746: PPUSH
6747: LD_INT 23
6749: PPUSH
6750: LD_INT 0
6752: PPUSH
6753: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6757: LD_VAR 0 2
6761: PPUSH
6762: LD_INT 85
6764: PPUSH
6765: LD_INT 152
6767: PPUSH
6768: CALL_OW 111
// wait ( 0 0$2 ) ;
6772: LD_INT 70
6774: PPUSH
6775: CALL_OW 67
// end ;
6779: GO 6642
6781: POP
6782: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6783: LD_ADDR_VAR 0 1
6787: PUSH
6788: DOUBLE
6789: LD_INT 1
6791: DEC
6792: ST_TO_ADDR
6793: LD_INT 2
6795: PUSH
6796: LD_INT 3
6798: PUSH
6799: LD_INT 3
6801: PUSH
6802: LD_INT 4
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: LIST
6809: LIST
6810: PUSH
6811: LD_OWVAR 67
6815: ARRAY
6816: PUSH
6817: FOR_TO
6818: IFFALSE 6975
// begin uc_side := 2 ;
6820: LD_ADDR_OWVAR 20
6824: PUSH
6825: LD_INT 2
6827: ST_TO_ADDR
// uc_nation := 2 ;
6828: LD_ADDR_OWVAR 21
6832: PUSH
6833: LD_INT 2
6835: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6836: LD_INT 14
6838: PPUSH
6839: LD_INT 3
6841: PPUSH
6842: LD_INT 5
6844: PPUSH
6845: LD_INT 27
6847: PUSH
6848: LD_INT 28
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 1
6857: PPUSH
6858: LD_INT 2
6860: PPUSH
6861: CALL_OW 12
6865: ARRAY
6866: PPUSH
6867: LD_INT 100
6869: PPUSH
6870: CALL 53670 0 5
// un := CreateVehicle ;
6874: LD_ADDR_VAR 0 2
6878: PUSH
6879: CALL_OW 45
6883: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6884: LD_ADDR_VAR 0 3
6888: PUSH
6889: LD_VAR 0 3
6893: PPUSH
6894: LD_INT 5
6896: PUSH
6897: LD_VAR 0 3
6901: PUSH
6902: LD_INT 5
6904: ARRAY
6905: PUSH
6906: LD_INT 1
6908: PLUS
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PPUSH
6914: LD_VAR 0 2
6918: PPUSH
6919: CALL 53792 0 3
6923: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6924: LD_VAR 0 2
6928: PPUSH
6929: LD_INT 0
6931: PPUSH
6932: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6936: LD_VAR 0 2
6940: PPUSH
6941: LD_INT 23
6943: PPUSH
6944: LD_INT 0
6946: PPUSH
6947: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6951: LD_VAR 0 2
6955: PPUSH
6956: LD_INT 85
6958: PPUSH
6959: LD_INT 152
6961: PPUSH
6962: CALL_OW 111
// wait ( 0 0$2 ) ;
6966: LD_INT 70
6968: PPUSH
6969: CALL_OW 67
// end ;
6973: GO 6817
6975: POP
6976: POP
// coords := [ [ 97 , 143 ] ] ;
6977: LD_ADDR_VAR 0 5
6981: PUSH
6982: LD_INT 97
6984: PUSH
6985: LD_INT 143
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PUSH
6992: EMPTY
6993: LIST
6994: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6995: LD_INT 1
6997: PPUSH
6998: LD_VAR 0 3
7002: PUSH
7003: LD_INT 5
7005: ARRAY
7006: PPUSH
7007: LD_VAR 0 5
7011: PPUSH
7012: LD_VAR 0 6
7016: PPUSH
7017: CALL 42452 0 4
// end ; Wait ( 13 13$00 ) ;
7021: LD_INT 27300
7023: PPUSH
7024: CALL_OW 67
// tmp := [ ] ;
7028: LD_ADDR_VAR 0 3
7032: PUSH
7033: EMPTY
7034: ST_TO_ADDR
// w := 1 ;
7035: LD_ADDR_VAR 0 7
7039: PUSH
7040: LD_INT 1
7042: ST_TO_ADDR
// repeat tmp := [ ] ;
7043: LD_ADDR_VAR 0 3
7047: PUSH
7048: EMPTY
7049: ST_TO_ADDR
// if w mod 4 = 0 then
7050: LD_VAR 0 7
7054: PUSH
7055: LD_INT 4
7057: MOD
7058: PUSH
7059: LD_INT 0
7061: EQUAL
7062: IFFALSE 7149
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7064: LD_ADDR_VAR 0 8
7068: PUSH
7069: LD_INT 11
7071: PUSH
7072: LD_INT 1
7074: PUSH
7075: LD_INT 2
7077: PUSH
7078: LD_INT 24
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_INT 11
7089: PUSH
7090: LD_INT 1
7092: PUSH
7093: LD_INT 2
7095: PUSH
7096: LD_INT 24
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: LIST
7103: LIST
7104: PUSH
7105: LD_INT 11
7107: PUSH
7108: LD_INT 1
7110: PUSH
7111: LD_INT 2
7113: PUSH
7114: LD_INT 24
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 11
7125: PUSH
7126: LD_INT 1
7128: PUSH
7129: LD_INT 2
7131: PUSH
7132: LD_INT 24
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: ST_TO_ADDR
7147: GO 7251
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7149: LD_ADDR_VAR 0 8
7153: PUSH
7154: LD_INT 14
7156: PUSH
7157: LD_INT 1
7159: PUSH
7160: LD_INT 2
7162: PUSH
7163: LD_INT 28
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: PUSH
7172: LD_INT 14
7174: PUSH
7175: LD_INT 1
7177: PUSH
7178: LD_INT 2
7180: PUSH
7181: LD_INT 25
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: PUSH
7190: LD_INT 14
7192: PUSH
7193: LD_INT 1
7195: PUSH
7196: LD_INT 2
7198: PUSH
7199: LD_INT 28
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: LIST
7206: LIST
7207: PUSH
7208: LD_INT 14
7210: PUSH
7211: LD_INT 1
7213: PUSH
7214: LD_INT 2
7216: PUSH
7217: LD_INT 29
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: PUSH
7226: LD_INT 11
7228: PUSH
7229: LD_INT 1
7231: PUSH
7232: LD_INT 2
7234: PUSH
7235: LD_INT 24
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: LIST
7250: ST_TO_ADDR
// if w mod 3 = 0 then
7251: LD_VAR 0 7
7255: PUSH
7256: LD_INT 3
7258: MOD
7259: PUSH
7260: LD_INT 0
7262: EQUAL
7263: IFFALSE 7339
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7265: LD_ADDR_VAR 0 8
7269: PUSH
7270: LD_VAR 0 8
7274: PPUSH
7275: LD_INT 1
7277: PUSH
7278: LD_VAR 0 8
7282: PUSH
7283: LD_VAR 0 1
7287: ARRAY
7288: PUSH
7289: LD_INT 1
7291: PLUS
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PPUSH
7297: LD_INT 14
7299: PUSH
7300: LD_INT 1
7302: PUSH
7303: LD_INT 2
7305: PUSH
7306: LD_INT 25
7308: PUSH
7309: LD_INT 28
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 1
7318: PPUSH
7319: LD_INT 2
7321: PPUSH
7322: CALL_OW 12
7326: ARRAY
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PPUSH
7334: CALL 53792 0 3
7338: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7339: LD_INT 1
7341: PPUSH
7342: LD_VAR 0 8
7346: PPUSH
7347: CALL 42219 0 2
// if GetSide ( ar_dep_w ) = 2 then
7351: LD_INT 45
7353: PPUSH
7354: CALL_OW 255
7358: PUSH
7359: LD_INT 2
7361: EQUAL
7362: IFFALSE 7447
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7364: LD_ADDR_VAR 0 8
7368: PUSH
7369: LD_INT 14
7371: PUSH
7372: LD_INT 1
7374: PUSH
7375: LD_INT 2
7377: PUSH
7378: LD_INT 28
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: PUSH
7387: LD_INT 14
7389: PUSH
7390: LD_INT 1
7392: PUSH
7393: LD_INT 2
7395: PUSH
7396: LD_INT 27
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 14
7407: PUSH
7408: LD_INT 1
7410: PUSH
7411: LD_INT 2
7413: PUSH
7414: LD_INT 27
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: LIST
7421: LIST
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7428: LD_INT 2
7430: PPUSH
7431: LD_VAR 0 8
7435: PPUSH
7436: CALL 42219 0 2
// wait ( 0 0$50 ) ;
7440: LD_INT 1750
7442: PPUSH
7443: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7447: LD_INT 35
7449: PPUSH
7450: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7454: LD_EXP 69
7458: PUSH
7459: LD_INT 1
7461: ARRAY
7462: PPUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 2
7468: PUSH
7469: LD_INT 34
7471: PUSH
7472: LD_INT 32
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PUSH
7479: LD_INT 34
7481: PUSH
7482: LD_INT 88
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: LIST
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PPUSH
7498: CALL_OW 72
7502: PUSH
7503: LD_INT 4
7505: GREATEREQUAL
7506: IFFALSE 7447
// wait ( 0 0$10 ) ;
7508: LD_INT 350
7510: PPUSH
7511: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7515: LD_ADDR_VAR 0 3
7519: PUSH
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7569: LD_INT 100
7571: PPUSH
7572: CALL_OW 13
7576: PUSH
7577: LD_INT 50
7579: LESS
7580: IFFALSE 7613
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7582: LD_ADDR_VAR 0 5
7586: PUSH
7587: LD_INT 55
7589: PUSH
7590: LD_INT 7
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: PUSH
7597: LD_INT 75
7599: PUSH
7600: LD_INT 90
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: ST_TO_ADDR
7611: GO 7642
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7613: LD_ADDR_VAR 0 5
7617: PUSH
7618: LD_INT 128
7620: PUSH
7621: LD_INT 94
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 180
7630: PUSH
7631: LD_INT 135
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: ST_TO_ADDR
// if w mod 4 = 0 then
7642: LD_VAR 0 7
7646: PUSH
7647: LD_INT 4
7649: MOD
7650: PUSH
7651: LD_INT 0
7653: EQUAL
7654: IFFALSE 7685
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7656: LD_ADDR_VAR 0 5
7660: PUSH
7661: LD_INT 91
7663: PUSH
7664: LD_INT 58
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 117
7673: PUSH
7674: LD_INT 107
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_VAR 0 5
7694: PUSH
7695: LD_INT 1
7697: ARRAY
7698: PPUSH
7699: LD_VAR 0 5
7703: PUSH
7704: LD_INT 2
7706: ARRAY
7707: PPUSH
7708: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7712: LD_INT 35
7714: PPUSH
7715: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7719: LD_VAR 0 3
7723: PPUSH
7724: LD_INT 60
7726: PUSH
7727: EMPTY
7728: LIST
7729: PPUSH
7730: CALL_OW 72
7734: PUSH
7735: LD_INT 0
7737: EQUAL
7738: IFFALSE 7712
// repeat wait ( 0 0$2 ) ;
7740: LD_INT 70
7742: PPUSH
7743: CALL_OW 67
// for i in tmp do
7747: LD_ADDR_VAR 0 1
7751: PUSH
7752: LD_VAR 0 3
7756: PUSH
7757: FOR_IN
7758: IFFALSE 7847
// if GetChassis ( i ) = ar_hovercraft then
7760: LD_VAR 0 1
7764: PPUSH
7765: CALL_OW 265
7769: PUSH
7770: LD_INT 11
7772: EQUAL
7773: IFFALSE 7811
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7775: LD_VAR 0 1
7779: PPUSH
7780: LD_INT 22
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: PPUSH
7795: LD_VAR 0 1
7799: PPUSH
7800: CALL_OW 74
7804: PPUSH
7805: CALL 81738 0 2
7809: GO 7845
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7811: LD_VAR 0 1
7815: PPUSH
7816: LD_INT 22
7818: PUSH
7819: LD_INT 1
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PPUSH
7826: CALL_OW 69
7830: PPUSH
7831: LD_VAR 0 1
7835: PPUSH
7836: CALL_OW 74
7840: PPUSH
7841: CALL_OW 115
7845: GO 7757
7847: POP
7848: POP
// until not tmp ;
7849: LD_VAR 0 3
7853: NOT
7854: IFFALSE 7740
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7856: LD_INT 22050
7858: PPUSH
7859: LD_INT 28350
7861: PPUSH
7862: CALL_OW 12
7866: PPUSH
7867: CALL_OW 67
// w := w + 1 ;
7871: LD_ADDR_VAR 0 7
7875: PUSH
7876: LD_VAR 0 7
7880: PUSH
7881: LD_INT 1
7883: PLUS
7884: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7885: LD_INT 94
7887: PPUSH
7888: CALL_OW 301
7892: PUSH
7893: LD_EXP 50
7897: PUSH
7898: LD_INT 1
7900: ARRAY
7901: PPUSH
7902: LD_INT 30
7904: PUSH
7905: LD_INT 3
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 72
7916: NOT
7917: OR
7918: IFFALSE 7043
// end ;
7920: PPOPN 8
7922: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7923: LD_INT 204
7925: IFFALSE 8391
7927: GO 7929
7929: DISABLE
7930: LD_INT 0
7932: PPUSH
7933: PPUSH
7934: PPUSH
7935: PPUSH
// begin enable ;
7936: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7937: LD_INT 35
7939: PPUSH
7940: LD_INT 1190
7942: PPUSH
7943: CALL_OW 12
7947: PPUSH
7948: CALL_OW 67
// tmp := [ ] ;
7952: LD_ADDR_VAR 0 2
7956: PUSH
7957: EMPTY
7958: ST_TO_ADDR
// uc_side := 8 ;
7959: LD_ADDR_OWVAR 20
7963: PUSH
7964: LD_INT 8
7966: ST_TO_ADDR
// uc_nation := 2 ;
7967: LD_ADDR_OWVAR 21
7971: PUSH
7972: LD_INT 2
7974: ST_TO_ADDR
// InitHc ;
7975: CALL_OW 19
// for i = 1 to 3 do
7979: LD_ADDR_VAR 0 1
7983: PUSH
7984: DOUBLE
7985: LD_INT 1
7987: DEC
7988: ST_TO_ADDR
7989: LD_INT 3
7991: PUSH
7992: FOR_TO
7993: IFFALSE 8120
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7995: LD_INT 13
7997: PUSH
7998: LD_INT 14
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PUSH
8005: LD_INT 1
8007: PPUSH
8008: LD_INT 2
8010: PPUSH
8011: CALL_OW 12
8015: ARRAY
8016: PPUSH
8017: LD_INT 3
8019: PPUSH
8020: LD_INT 5
8022: PPUSH
8023: LD_INT 27
8025: PUSH
8026: LD_INT 28
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 1
8035: PPUSH
8036: LD_INT 2
8038: PPUSH
8039: CALL_OW 12
8043: ARRAY
8044: PPUSH
8045: LD_INT 100
8047: PPUSH
8048: CALL 53670 0 5
// un := CreateVehicle ;
8052: LD_ADDR_VAR 0 3
8056: PUSH
8057: CALL_OW 45
8061: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8062: LD_VAR 0 3
8066: PPUSH
8067: LD_INT 4
8069: PPUSH
8070: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8074: LD_VAR 0 3
8078: PPUSH
8079: LD_INT 15
8081: PPUSH
8082: LD_INT 0
8084: PPUSH
8085: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8089: LD_ADDR_VAR 0 2
8093: PUSH
8094: LD_VAR 0 2
8098: PPUSH
8099: LD_VAR 0 2
8103: PUSH
8104: LD_INT 1
8106: PLUS
8107: PPUSH
8108: LD_VAR 0 3
8112: PPUSH
8113: CALL_OW 1
8117: ST_TO_ADDR
// end ;
8118: GO 7992
8120: POP
8121: POP
// for i = 1 to 4 do
8122: LD_ADDR_VAR 0 1
8126: PUSH
8127: DOUBLE
8128: LD_INT 1
8130: DEC
8131: ST_TO_ADDR
8132: LD_INT 4
8134: PUSH
8135: FOR_TO
8136: IFFALSE 8207
// begin PrepareHuman ( false , 1 , 6 ) ;
8138: LD_INT 0
8140: PPUSH
8141: LD_INT 1
8143: PPUSH
8144: LD_INT 6
8146: PPUSH
8147: CALL_OW 380
// un := CreateHuman ;
8151: LD_ADDR_VAR 0 3
8155: PUSH
8156: CALL_OW 44
8160: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8161: LD_VAR 0 3
8165: PPUSH
8166: LD_INT 15
8168: PPUSH
8169: LD_INT 0
8171: PPUSH
8172: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8176: LD_ADDR_VAR 0 2
8180: PUSH
8181: LD_VAR 0 2
8185: PPUSH
8186: LD_VAR 0 2
8190: PUSH
8191: LD_INT 1
8193: PLUS
8194: PPUSH
8195: LD_VAR 0 3
8199: PPUSH
8200: CALL_OW 1
8204: ST_TO_ADDR
// end ;
8205: GO 8135
8207: POP
8208: POP
// wait ( 0 0$3 ) ;
8209: LD_INT 105
8211: PPUSH
8212: CALL_OW 67
// for i in tmp do
8216: LD_ADDR_VAR 0 1
8220: PUSH
8221: LD_VAR 0 2
8225: PUSH
8226: FOR_IN
8227: IFFALSE 8295
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 257
8238: PUSH
8239: LD_INT 1
8241: EQUAL
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 247
8252: PUSH
8253: LD_INT 2
8255: EQUAL
8256: OR
8257: IFFALSE 8293
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8259: LD_VAR 0 1
8263: PPUSH
8264: LD_INT 81
8266: PUSH
8267: LD_INT 8
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: PPUSH
8274: CALL_OW 69
8278: PPUSH
8279: LD_VAR 0 1
8283: PPUSH
8284: CALL_OW 74
8288: PPUSH
8289: CALL_OW 115
8293: GO 8226
8295: POP
8296: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8297: LD_VAR 0 2
8301: PPUSH
8302: LD_INT 210
8304: PPUSH
8305: LD_INT 178
8307: PPUSH
8308: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 10
8319: PPUSH
8320: LD_INT 22
8322: PUSH
8323: LD_INT 8
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PPUSH
8330: CALL_OW 70
8334: ST_TO_ADDR
// if x then
8335: LD_VAR 0 4
8339: IFFALSE 8367
// for i in x do
8341: LD_ADDR_VAR 0 1
8345: PUSH
8346: LD_VAR 0 4
8350: PUSH
8351: FOR_IN
8352: IFFALSE 8365
// RemoveUnit ( i ) ;
8354: LD_VAR 0 1
8358: PPUSH
8359: CALL_OW 64
8363: GO 8351
8365: POP
8366: POP
// wait ( 0 0$1 ) ;
8367: LD_INT 35
8369: PPUSH
8370: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8374: LD_INT 22
8376: PUSH
8377: LD_INT 8
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 69
8388: NOT
8389: IFFALSE 8297
// end ;
8391: PPOPN 4
8393: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8394: LD_INT 22
8396: PUSH
8397: LD_INT 2
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PUSH
8404: LD_INT 34
8406: PUSH
8407: LD_INT 31
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 3
8416: PUSH
8417: LD_INT 24
8419: PUSH
8420: LD_INT 1000
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: IFFALSE 8543
8442: GO 8444
8444: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8445: LD_INT 45
8447: PPUSH
8448: CALL_OW 302
8452: PUSH
8453: LD_INT 45
8455: PPUSH
8456: CALL_OW 255
8460: AND
8461: IFFALSE 8504
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8463: LD_INT 22
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 34
8475: PUSH
8476: LD_INT 31
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PPUSH
8487: CALL_OW 69
8491: PPUSH
8492: LD_INT 18
8494: PPUSH
8495: LD_INT 8
8497: PPUSH
8498: CALL_OW 111
8502: GO 8543
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8504: LD_INT 22
8506: PUSH
8507: LD_INT 2
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 34
8516: PUSH
8517: LD_INT 31
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PPUSH
8528: CALL_OW 69
8532: PPUSH
8533: LD_INT 106
8535: PPUSH
8536: LD_INT 14
8538: PPUSH
8539: CALL_OW 111
// end ; end_of_file
8543: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8544: LD_INT 0
8546: PPUSH
8547: PPUSH
8548: PPUSH
8549: PPUSH
8550: PPUSH
8551: PPUSH
// InGameOn ;
8552: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8556: LD_EXP 21
8560: PPUSH
8561: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8565: LD_INT 2
8567: PPUSH
8568: LD_INT 1
8570: PPUSH
8571: LD_INT 1
8573: PPUSH
8574: LD_INT 1
8576: PPUSH
8577: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8581: LD_ADDR_VAR 0 2
8585: PUSH
8586: LD_INT 22
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PUSH
8596: LD_INT 25
8598: PUSH
8599: LD_INT 1
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PPUSH
8610: CALL_OW 69
8614: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8615: LD_ADDR_VAR 0 4
8619: PUSH
8620: LD_INT 22
8622: PUSH
8623: LD_INT 1
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 34
8632: PUSH
8633: LD_INT 11
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 69
8648: PUSH
8649: LD_INT 1
8651: ARRAY
8652: ST_TO_ADDR
// for i = 1 to tmp do
8653: LD_ADDR_VAR 0 6
8657: PUSH
8658: DOUBLE
8659: LD_INT 1
8661: DEC
8662: ST_TO_ADDR
8663: LD_VAR 0 2
8667: PUSH
8668: FOR_TO
8669: IFFALSE 8716
// begin if i = 5 then
8671: LD_VAR 0 6
8675: PUSH
8676: LD_INT 5
8678: EQUAL
8679: IFFALSE 8683
// break ;
8681: GO 8716
// sols := Replace ( sols , i , tmp [ i ] ) ;
8683: LD_ADDR_VAR 0 5
8687: PUSH
8688: LD_VAR 0 5
8692: PPUSH
8693: LD_VAR 0 6
8697: PPUSH
8698: LD_VAR 0 2
8702: PUSH
8703: LD_VAR 0 6
8707: ARRAY
8708: PPUSH
8709: CALL_OW 1
8713: ST_TO_ADDR
// end ;
8714: GO 8668
8716: POP
8717: POP
// tmp := ar_force_tmp ;
8718: LD_ADDR_VAR 0 2
8722: PUSH
8723: LD_EXP 40
8727: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8728: LD_VAR 0 2
8732: PUSH
8733: LD_INT 1
8735: ARRAY
8736: PPUSH
8737: LD_INT 108
8739: PPUSH
8740: LD_INT 139
8742: PPUSH
8743: LD_INT 0
8745: PPUSH
8746: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8750: LD_VAR 0 2
8754: PUSH
8755: LD_INT 1
8757: ARRAY
8758: PPUSH
8759: LD_EXP 21
8763: PPUSH
8764: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8768: LD_VAR 0 2
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: PPUSH
8777: LD_INT 114
8779: PPUSH
8780: LD_INT 132
8782: PPUSH
8783: LD_INT 0
8785: PPUSH
8786: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8790: LD_VAR 0 2
8794: PUSH
8795: LD_INT 3
8797: ARRAY
8798: PPUSH
8799: LD_INT 115
8801: PPUSH
8802: LD_INT 132
8804: PPUSH
8805: LD_INT 0
8807: PPUSH
8808: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8812: LD_VAR 0 2
8816: PUSH
8817: LD_INT 2
8819: ARRAY
8820: PUSH
8821: LD_VAR 0 2
8825: PUSH
8826: LD_INT 3
8828: ARRAY
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8838: LD_VAR 0 4
8842: PPUSH
8843: LD_INT 83
8845: PPUSH
8846: LD_INT 123
8848: PPUSH
8849: CALL_OW 111
// Wait ( 0 0$01 ) ;
8853: LD_INT 35
8855: PPUSH
8856: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8860: LD_INT 90
8862: PPUSH
8863: LD_INT 144
8865: PPUSH
8866: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8870: LD_VAR 0 5
8874: PPUSH
8875: LD_INT 88
8877: PPUSH
8878: LD_INT 129
8880: PPUSH
8881: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_INT 92
8892: PUSH
8893: LD_INT 131
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: LD_INT 88
8902: PUSH
8903: LD_INT 127
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: LD_INT 91
8912: PUSH
8913: LD_INT 132
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PUSH
8920: LD_INT 92
8922: PUSH
8923: LD_INT 134
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: ST_TO_ADDR
// for i = 1 to sols do
8936: LD_ADDR_VAR 0 6
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_VAR 0 5
8950: PUSH
8951: FOR_TO
8952: IFFALSE 9025
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8954: LD_VAR 0 5
8958: PUSH
8959: LD_VAR 0 6
8963: ARRAY
8964: PPUSH
8965: LD_VAR 0 3
8969: PUSH
8970: LD_VAR 0 6
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 2
8993: ARRAY
8994: PPUSH
8995: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8999: LD_VAR 0 5
9003: PUSH
9004: LD_VAR 0 6
9008: ARRAY
9009: PPUSH
9010: CALL_OW 197
// AddComHold ( sols ) ;
9014: LD_VAR 0 5
9018: PPUSH
9019: CALL_OW 200
// end ;
9023: GO 8951
9025: POP
9026: POP
// repeat wait ( 0 0$1 ) ;
9027: LD_INT 35
9029: PPUSH
9030: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9034: LD_VAR 0 5
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 92
9045: PPUSH
9046: LD_INT 131
9048: PPUSH
9049: CALL_OW 297
9053: PUSH
9054: LD_INT 4
9056: LESS
9057: IFFALSE 9027
// CenterOnXY ( 96 , 139 ) ;
9059: LD_INT 96
9061: PPUSH
9062: LD_INT 139
9064: PPUSH
9065: CALL_OW 84
// wait ( 0 0$3 ) ;
9069: LD_INT 105
9071: PPUSH
9072: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9076: LD_INT 111
9078: PPUSH
9079: LD_INT 135
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: LD_INT 25
9087: NEG
9088: PPUSH
9089: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9093: LD_VAR 0 2
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_VAR 0 2
9106: PUSH
9107: LD_INT 1
9109: ARRAY
9110: PPUSH
9111: CALL_OW 250
9115: PUSH
9116: LD_INT 3
9118: PLUS
9119: PPUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_INT 1
9127: ARRAY
9128: PPUSH
9129: CALL_OW 251
9133: PPUSH
9134: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9138: LD_VAR 0 2
9142: PUSH
9143: LD_INT 3
9145: ARRAY
9146: PPUSH
9147: LD_INT 7
9149: PPUSH
9150: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9154: LD_VAR 0 2
9158: PUSH
9159: LD_INT 2
9161: ARRAY
9162: PPUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_INT 1
9170: ARRAY
9171: PPUSH
9172: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9176: LD_INT 35
9178: PPUSH
9179: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9183: LD_VAR 0 2
9187: PUSH
9188: LD_INT 1
9190: ARRAY
9191: PPUSH
9192: LD_VAR 0 2
9196: PUSH
9197: LD_INT 2
9199: ARRAY
9200: PPUSH
9201: CALL_OW 296
9205: PUSH
9206: LD_INT 5
9208: LESS
9209: IFFALSE 9176
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9211: LD_VAR 0 2
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 2
9224: PUSH
9225: LD_INT 2
9227: ARRAY
9228: PPUSH
9229: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9233: LD_VAR 0 2
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: LD_STRING D1a-Merc1-1
9244: PPUSH
9245: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9249: LD_VAR 0 2
9253: PUSH
9254: LD_INT 2
9256: ARRAY
9257: PPUSH
9258: LD_STRING D1a-FMerc2-1
9260: PPUSH
9261: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9265: LD_VAR 0 2
9269: PUSH
9270: LD_INT 2
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 2
9278: PUSH
9279: LD_INT 1
9281: ARRAY
9282: PPUSH
9283: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9287: LD_VAR 0 2
9291: PUSH
9292: LD_INT 1
9294: ARRAY
9295: PPUSH
9296: LD_INT 500
9298: PPUSH
9299: CALL_OW 234
// wait ( 0 0$2 ) ;
9303: LD_INT 70
9305: PPUSH
9306: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9310: LD_VAR 0 2
9314: PUSH
9315: LD_INT 1
9317: ARRAY
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9326: LD_INT 10
9328: PPUSH
9329: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9333: LD_VAR 0 2
9337: PUSH
9338: LD_INT 1
9340: ARRAY
9341: PPUSH
9342: LD_STRING D1a-Merc1-2
9344: PPUSH
9345: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9349: LD_INT 7
9351: PPUSH
9352: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9356: LD_VAR 0 2
9360: PUSH
9361: LD_INT 1
9363: ARRAY
9364: PPUSH
9365: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9369: LD_VAR 0 2
9373: PUSH
9374: LD_INT 2
9376: ARRAY
9377: PPUSH
9378: LD_INT 10
9380: PPUSH
9381: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9385: LD_VAR 0 2
9389: PUSH
9390: LD_INT 2
9392: ARRAY
9393: PPUSH
9394: LD_STRING D1a-FMerc2-2
9396: PPUSH
9397: CALL_OW 88
// wait ( 0 0$1 ) ;
9401: LD_INT 35
9403: PPUSH
9404: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9408: LD_INT 7
9410: PPUSH
9411: CALL_OW 85
// wait ( 0 0$2 ) ;
9415: LD_INT 70
9417: PPUSH
9418: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9422: LD_EXP 44
9426: PPUSH
9427: LD_STRING D1a-Saliba-1
9429: PPUSH
9430: CALL_OW 91
// KillUnit ( Saliba ) ;
9434: LD_EXP 44
9438: PPUSH
9439: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9443: LD_VAR 0 2
9447: PUSH
9448: LD_INT 3
9450: ARRAY
9451: PPUSH
9452: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9456: LD_EXP 21
9460: PPUSH
9461: CALL_OW 85
// wait ( 0 0$1 ) ;
9465: LD_INT 35
9467: PPUSH
9468: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9472: LD_VAR 0 5
9476: PPUSH
9477: LD_INT 88
9479: PPUSH
9480: LD_INT 141
9482: PPUSH
9483: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 70
9494: PPUSH
9495: CALL_OW 202
// wait ( 0 0$2 ) ;
9499: LD_INT 70
9501: PPUSH
9502: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9506: LD_INT 2
9508: PPUSH
9509: LD_INT 1
9511: PPUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 1
9517: PPUSH
9518: CALL_OW 80
// InGameOff ;
9522: CALL_OW 9
// ComWalk ( sols ) ;
9526: LD_VAR 0 5
9530: PPUSH
9531: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9535: LD_STRING M1
9537: PPUSH
9538: CALL_OW 337
// game_speed := 4 ;
9542: LD_ADDR_OWVAR 65
9546: PUSH
9547: LD_INT 4
9549: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9550: LD_INT 111
9552: PPUSH
9553: LD_INT 135
9555: PPUSH
9556: LD_INT 1
9558: PPUSH
9559: CALL_OW 331
// SaveForQuickRestart ;
9563: CALL_OW 22
// ar_run := true ;
9567: LD_ADDR_EXP 5
9571: PUSH
9572: LD_INT 1
9574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9575: LD_INT 35
9577: PPUSH
9578: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9582: LD_INT 22
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: LD_INT 91
9594: PUSH
9595: LD_INT 7
9597: PUSH
9598: LD_INT 10
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: LIST
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: PUSH
9615: LD_INT 7
9617: PPUSH
9618: CALL_OW 256
9622: PUSH
9623: LD_INT 999
9625: LESS
9626: OR
9627: IFFALSE 9575
// if GetSide ( ar_dep_s ) = 2 then
9629: LD_INT 7
9631: PPUSH
9632: CALL_OW 255
9636: PUSH
9637: LD_INT 2
9639: EQUAL
9640: IFFALSE 9652
// SetSide ( ar_dep_s , 1 ) ;
9642: LD_INT 7
9644: PPUSH
9645: LD_INT 1
9647: PPUSH
9648: CALL_OW 235
// end ;
9652: LD_VAR 0 1
9656: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9657: LD_EXP 5
9661: IFFALSE 10021
9663: GO 9665
9665: DISABLE
9666: LD_INT 0
9668: PPUSH
9669: PPUSH
9670: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_EXP 40
9680: PUSH
9681: LD_EXP 36
9685: PPUSH
9686: LD_INT 2
9688: PUSH
9689: LD_INT 21
9691: PUSH
9692: LD_INT 2
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: PUSH
9699: LD_INT 21
9701: PUSH
9702: LD_INT 1
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: PPUSH
9714: CALL_OW 72
9718: ADD
9719: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9720: LD_VAR 0 2
9724: PPUSH
9725: LD_INT 5
9727: PPUSH
9728: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9732: LD_INT 5
9734: PPUSH
9735: LD_INT 1
9737: PPUSH
9738: CALL_OW 343
// k := 1 ;
9742: LD_ADDR_VAR 0 3
9746: PUSH
9747: LD_INT 1
9749: ST_TO_ADDR
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 9846
// begin if IsInUnit ( i ) then
9763: LD_VAR 0 1
9767: PPUSH
9768: CALL_OW 310
9772: IFFALSE 9783
// ComExitBuilding ( i ) ;
9774: LD_VAR 0 1
9778: PPUSH
9779: CALL_OW 122
// if GetClass ( i ) = 3 then
9783: LD_VAR 0 1
9787: PPUSH
9788: CALL_OW 257
9792: PUSH
9793: LD_INT 3
9795: EQUAL
9796: IFFALSE 9832
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9798: LD_VAR 0 1
9802: PPUSH
9803: LD_EXP 41
9807: PUSH
9808: LD_VAR 0 3
9812: ARRAY
9813: PPUSH
9814: CALL_OW 180
// k := k + 1 ;
9818: LD_ADDR_VAR 0 3
9822: PUSH
9823: LD_VAR 0 3
9827: PUSH
9828: LD_INT 1
9830: PLUS
9831: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9832: LD_VAR 0 1
9836: PPUSH
9837: LD_INT 10
9839: PPUSH
9840: CALL_OW 173
// end ;
9844: GO 9760
9846: POP
9847: POP
// ar_patrol := true ;
9848: LD_ADDR_EXP 7
9852: PUSH
9853: LD_INT 1
9855: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9856: LD_INT 10
9858: PPUSH
9859: CALL_OW 67
// for i in tmp do
9863: LD_ADDR_VAR 0 1
9867: PUSH
9868: LD_VAR 0 2
9872: PUSH
9873: FOR_IN
9874: IFFALSE 9902
// if not HasTask ( i ) then
9876: LD_VAR 0 1
9880: PPUSH
9881: CALL_OW 314
9885: NOT
9886: IFFALSE 9900
// ComMoveToArea ( i , escape_area ) ;
9888: LD_VAR 0 1
9892: PPUSH
9893: LD_INT 10
9895: PPUSH
9896: CALL_OW 113
9900: GO 9873
9902: POP
9903: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9904: LD_ADDR_VAR 0 3
9908: PUSH
9909: LD_VAR 0 2
9913: PPUSH
9914: LD_INT 95
9916: PUSH
9917: LD_INT 10
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PPUSH
9924: CALL_OW 72
9928: ST_TO_ADDR
// if k then
9929: LD_VAR 0 3
9933: IFFALSE 10002
// for i in k do
9935: LD_ADDR_VAR 0 1
9939: PUSH
9940: LD_VAR 0 3
9944: PUSH
9945: FOR_IN
9946: IFFALSE 10000
// begin if IsInUnit ( i ) then
9948: LD_VAR 0 1
9952: PPUSH
9953: CALL_OW 310
9957: IFFALSE 9973
// RemoveUnit ( IsInUnit ( i ) ) ;
9959: LD_VAR 0 1
9963: PPUSH
9964: CALL_OW 310
9968: PPUSH
9969: CALL_OW 64
// RemoveUnit ( i ) ;
9973: LD_VAR 0 1
9977: PPUSH
9978: CALL_OW 64
// tmp := tmp diff i ;
9982: LD_ADDR_VAR 0 2
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_VAR 0 1
9996: DIFF
9997: ST_TO_ADDR
// end ;
9998: GO 9945
10000: POP
10001: POP
// until tmp = [ ] ;
10002: LD_VAR 0 2
10006: PUSH
10007: EMPTY
10008: EQUAL
10009: IFFALSE 9856
// ChangeSideFog ( 5 , 5 ) ;
10011: LD_INT 5
10013: PPUSH
10014: LD_INT 5
10016: PPUSH
10017: CALL_OW 343
// end ;
10021: PPOPN 3
10023: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10024: LD_EXP 7
10028: IFFALSE 10318
10030: GO 10032
10032: DISABLE
10033: LD_INT 0
10035: PPUSH
10036: PPUSH
10037: PPUSH
// begin uc_side := 2 ;
10038: LD_ADDR_OWVAR 20
10042: PUSH
10043: LD_INT 2
10045: ST_TO_ADDR
// uc_nation := 2 ;
10046: LD_ADDR_OWVAR 21
10050: PUSH
10051: LD_INT 2
10053: ST_TO_ADDR
// InitHc ;
10054: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10058: LD_INT 1
10060: PPUSH
10061: LD_INT 1
10063: PPUSH
10064: LD_INT 6
10066: PPUSH
10067: CALL_OW 380
// un := CreateHuman ;
10071: LD_ADDR_VAR 0 2
10075: PUSH
10076: CALL_OW 44
10080: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10081: LD_INT 14
10083: PPUSH
10084: LD_INT 1
10086: PPUSH
10087: LD_INT 1
10089: PPUSH
10090: LD_INT 27
10092: PPUSH
10093: LD_INT 98
10095: PPUSH
10096: CALL 53670 0 5
// veh := CreateVehicle ;
10100: LD_ADDR_VAR 0 3
10104: PUSH
10105: CALL_OW 45
10109: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10110: LD_VAR 0 3
10114: PPUSH
10115: LD_INT 4
10117: PPUSH
10118: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10122: LD_VAR 0 3
10126: PPUSH
10127: LD_INT 179
10129: PPUSH
10130: LD_INT 135
10132: PPUSH
10133: LD_INT 0
10135: PPUSH
10136: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10140: LD_VAR 0 2
10144: PPUSH
10145: LD_VAR 0 3
10149: PPUSH
10150: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: LD_INT 126
10161: PPUSH
10162: LD_INT 133
10164: PPUSH
10165: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10169: LD_INT 10
10171: PPUSH
10172: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10176: LD_INT 1
10178: PPUSH
10179: LD_VAR 0 3
10183: PPUSH
10184: CALL_OW 292
10188: PUSH
10189: LD_VAR 0 3
10193: PPUSH
10194: LD_INT 7
10196: PPUSH
10197: CALL_OW 296
10201: PUSH
10202: LD_INT 9
10204: LESS
10205: OR
10206: IFFALSE 10169
// ComHold ( veh ) ;
10208: LD_VAR 0 3
10212: PPUSH
10213: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10217: LD_VAR 0 2
10221: PPUSH
10222: LD_STRING D2aa-Ar1-1
10224: PPUSH
10225: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10229: LD_VAR 0 2
10233: PPUSH
10234: LD_INT 177
10236: PPUSH
10237: LD_INT 96
10239: PPUSH
10240: CALL_OW 111
// AddComExitVehicle ( un ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10253: LD_INT 35
10255: PPUSH
10256: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10260: LD_VAR 0 2
10264: PPUSH
10265: LD_INT 204
10267: PPUSH
10268: CALL_OW 296
10272: PUSH
10273: LD_INT 15
10275: LESS
10276: IFFALSE 10253
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10278: LD_ADDR_EXP 50
10282: PUSH
10283: LD_EXP 50
10287: PPUSH
10288: LD_INT 3
10290: PUSH
10291: LD_EXP 50
10295: PUSH
10296: LD_INT 3
10298: ARRAY
10299: PUSH
10300: LD_INT 1
10302: PLUS
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PPUSH
10308: LD_VAR 0 2
10312: PPUSH
10313: CALL 53792 0 3
10317: ST_TO_ADDR
// end ;
10318: PPOPN 3
10320: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10321: LD_INT 7
10323: PPUSH
10324: CALL_OW 255
10328: PUSH
10329: LD_INT 1
10331: EQUAL
10332: PUSH
10333: LD_INT 7
10335: PPUSH
10336: CALL_OW 301
10340: OR
10341: IFFALSE 12749
10343: GO 10345
10345: DISABLE
10346: LD_INT 0
10348: PPUSH
10349: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_EXP 36
10359: PPUSH
10360: LD_INT 21
10362: PUSH
10363: LD_INT 3
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PPUSH
10370: CALL_OW 72
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10392
// SetSide ( i , 1 ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL_OW 235
10390: GO 10375
10392: POP
10393: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10394: LD_ADDR_VAR 0 2
10398: PUSH
10399: LD_INT 46
10401: PUSH
10402: LD_INT 41
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PUSH
10409: LD_INT 50
10411: PUSH
10412: LD_INT 25
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 57
10421: PUSH
10422: LD_INT 75
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: LD_INT 75
10431: PUSH
10432: LD_INT 89
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 51
10441: PUSH
10442: LD_INT 45
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 95
10451: PUSH
10452: LD_INT 95
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 84
10461: PUSH
10462: LD_INT 77
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: LD_INT 101
10471: PUSH
10472: LD_INT 76
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PUSH
10479: LD_INT 118
10481: PUSH
10482: LD_INT 81
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PUSH
10489: LD_INT 139
10491: PUSH
10492: LD_INT 97
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PUSH
10499: LD_INT 129
10501: PUSH
10502: LD_INT 114
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: PUSH
10509: LD_INT 154
10511: PUSH
10512: LD_INT 111
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: ST_TO_ADDR
// base_captured := true ;
10533: LD_ADDR_EXP 6
10537: PUSH
10538: LD_INT 1
10540: ST_TO_ADDR
// DialogueOn ;
10541: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10545: LD_EXP 21
10549: PPUSH
10550: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10554: LD_EXP 21
10558: PPUSH
10559: LD_STRING D2-JMM-1
10561: PPUSH
10562: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10566: LD_EXP 30
10570: PPUSH
10571: LD_STRING D2-Pow-1
10573: PPUSH
10574: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10578: LD_EXP 21
10582: PPUSH
10583: LD_STRING D2-JMM-2
10585: PPUSH
10586: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10590: LD_EXP 30
10594: PPUSH
10595: LD_STRING D2-Pow-2
10597: PPUSH
10598: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10602: LD_EXP 21
10606: PPUSH
10607: LD_STRING D2-JMM-3
10609: PPUSH
10610: CALL_OW 88
// DialogueOff ;
10614: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10618: LD_STRING M2
10620: PPUSH
10621: CALL_OW 337
// Wait ( 0 0$2 ) ;
10625: LD_INT 70
10627: PPUSH
10628: CALL_OW 67
// if IsOk ( Gary ) then
10632: LD_EXP 32
10636: PPUSH
10637: CALL_OW 302
10641: IFFALSE 10655
// Say ( Gary , D2a-Gary-1 ) ;
10643: LD_EXP 32
10647: PPUSH
10648: LD_STRING D2a-Gary-1
10650: PPUSH
10651: CALL_OW 88
// if IsOk ( Bobby ) then
10655: LD_EXP 24
10659: PPUSH
10660: CALL_OW 302
10664: IFFALSE 10678
// Say ( Bobby , D2a-Bobby-1 ) ;
10666: LD_EXP 24
10670: PPUSH
10671: LD_STRING D2a-Bobby-1
10673: PPUSH
10674: CALL_OW 88
// if IsOk ( Cyrus ) then
10678: LD_EXP 25
10682: PPUSH
10683: CALL_OW 302
10687: IFFALSE 10701
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10689: LD_EXP 25
10693: PPUSH
10694: LD_STRING D2a-Cyrus-1
10696: PPUSH
10697: CALL_OW 88
// if IsOk ( Lisa ) then
10701: LD_EXP 22
10705: PPUSH
10706: CALL_OW 302
10710: IFFALSE 10724
// Say ( Lisa , D2a-Lisa-1 ) ;
10712: LD_EXP 22
10716: PPUSH
10717: LD_STRING D2a-Lisa-1
10719: PPUSH
10720: CALL_OW 88
// if IsOk ( Frank ) then
10724: LD_EXP 33
10728: PPUSH
10729: CALL_OW 302
10733: IFFALSE 10747
// Say ( Frank , D2a-Frank-1 ) ;
10735: LD_EXP 33
10739: PPUSH
10740: LD_STRING D2a-Frank-1
10742: PPUSH
10743: CALL_OW 88
// if IsOk ( Cornel ) then
10747: LD_EXP 31
10751: PPUSH
10752: CALL_OW 302
10756: IFFALSE 10770
// Say ( Cornel , D2a-Corn-1 ) ;
10758: LD_EXP 31
10762: PPUSH
10763: LD_STRING D2a-Corn-1
10765: PPUSH
10766: CALL_OW 88
// if IsOk ( Donaldson ) then
10770: LD_EXP 23
10774: PPUSH
10775: CALL_OW 302
10779: IFFALSE 10793
// Say ( Donaldson , D2a-Don-1 ) ;
10781: LD_EXP 23
10785: PPUSH
10786: LD_STRING D2a-Don-1
10788: PPUSH
10789: CALL_OW 88
// if IsOk ( Brown ) then
10793: LD_EXP 27
10797: PPUSH
10798: CALL_OW 302
10802: IFFALSE 10816
// Say ( Brown , D2a-Brown-1 ) ;
10804: LD_EXP 27
10808: PPUSH
10809: LD_STRING D2a-Brown-1
10811: PPUSH
10812: CALL_OW 88
// Wait ( 0 0$30 ) ;
10816: LD_INT 1050
10818: PPUSH
10819: CALL_OW 67
// if IsOk ( Frank ) then
10823: LD_EXP 33
10827: PPUSH
10828: CALL_OW 302
10832: IFFALSE 11098
// begin DialogueOn ;
10834: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10838: LD_EXP 21
10842: PUSH
10843: LD_EXP 33
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PPUSH
10852: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10856: LD_EXP 33
10860: PPUSH
10861: LD_STRING D3F-Frank-1
10863: PPUSH
10864: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10868: LD_EXP 21
10872: PPUSH
10873: LD_STRING D3F-JMM-1
10875: PPUSH
10876: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10880: LD_EXP 33
10884: PPUSH
10885: LD_STRING D3F-Frank-2
10887: PPUSH
10888: CALL_OW 88
// case Query ( QFrank ) of 1 :
10892: LD_STRING QFrank
10894: PPUSH
10895: CALL_OW 97
10899: PUSH
10900: LD_INT 1
10902: DOUBLE
10903: EQUAL
10904: IFTRUE 10908
10906: GO 10931
10908: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10909: LD_EXP 21
10913: PPUSH
10914: LD_STRING D3Fa-JMM-1
10916: PPUSH
10917: CALL_OW 88
// us_scout := 1 ;
10921: LD_ADDR_EXP 8
10925: PUSH
10926: LD_INT 1
10928: ST_TO_ADDR
// end ; 2 :
10929: GO 11094
10931: LD_INT 2
10933: DOUBLE
10934: EQUAL
10935: IFTRUE 10939
10937: GO 11061
10939: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fb-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fb-Frank-1
10959: PPUSH
10960: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10964: LD_STRING QFrank2
10966: PPUSH
10967: CALL_OW 97
10971: PUSH
10972: LD_INT 1
10974: DOUBLE
10975: EQUAL
10976: IFTRUE 10980
10978: GO 11027
10980: POP
// begin us_scout := 2 ;
10981: LD_ADDR_EXP 8
10985: PUSH
10986: LD_INT 2
10988: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10989: LD_EXP 21
10993: PPUSH
10994: LD_STRING D3Fba-JMM-1
10996: PPUSH
10997: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11001: LD_EXP 33
11005: PPUSH
11006: LD_STRING D3Fba-Frank-1
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11013: LD_EXP 21
11017: PPUSH
11018: LD_STRING D3Fba-JMM-2
11020: PPUSH
11021: CALL_OW 88
// end ; 2 :
11025: GO 11059
11027: LD_INT 2
11029: DOUBLE
11030: EQUAL
11031: IFTRUE 11035
11033: GO 11058
11035: POP
// begin us_scout := 0 ;
11036: LD_ADDR_EXP 8
11040: PUSH
11041: LD_INT 0
11043: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11044: LD_EXP 21
11048: PPUSH
11049: LD_STRING D3Fbb-JMM-1
11051: PPUSH
11052: CALL_OW 88
// end ; end ;
11056: GO 11059
11058: POP
// end ; 3 :
11059: GO 11094
11061: LD_INT 3
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11093
11069: POP
// begin us_scout := - 1 ;
11070: LD_ADDR_EXP 8
11074: PUSH
11075: LD_INT 1
11077: NEG
11078: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11079: LD_EXP 21
11083: PPUSH
11084: LD_STRING D3Fc-JMM-1
11086: PPUSH
11087: CALL_OW 88
// end ; end ;
11091: GO 11094
11093: POP
// DialogueOff ;
11094: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11098: LD_EXP 8
11102: PUSH
11103: LD_INT 1
11105: NEG
11106: PUSH
11107: LD_INT 0
11109: PUSH
11110: EMPTY
11111: LIST
11112: LIST
11113: IN
11114: IFFALSE 11118
// exit ;
11116: GO 12749
// if us_scout in [ 1 , 2 ] then
11118: LD_EXP 8
11122: PUSH
11123: LD_INT 1
11125: PUSH
11126: LD_INT 2
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: IN
11133: IFFALSE 11812
// begin if IsInUnit ( Frank ) then
11135: LD_EXP 33
11139: PPUSH
11140: CALL_OW 310
11144: IFFALSE 11155
// ComExit ( Frank ) ;
11146: LD_EXP 33
11150: PPUSH
11151: CALL 86502 0 1
// SetSide ( Frank , 4 ) ;
11155: LD_EXP 33
11159: PPUSH
11160: LD_INT 4
11162: PPUSH
11163: CALL_OW 235
// wait ( 0 0$1 ) ;
11167: LD_INT 35
11169: PPUSH
11170: CALL_OW 67
// if us_scout = 2 then
11174: LD_EXP 8
11178: PUSH
11179: LD_INT 2
11181: EQUAL
11182: IFFALSE 11550
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11184: LD_EXP 33
11188: PPUSH
11189: LD_INT 75
11191: PPUSH
11192: LD_INT 63
11194: PPUSH
11195: CALL_OW 111
// AddComHold ( Frank ) ;
11199: LD_EXP 33
11203: PPUSH
11204: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11208: LD_EXP 33
11212: PPUSH
11213: LD_INT 770
11215: PPUSH
11216: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11220: LD_EXP 33
11224: PPUSH
11225: LD_INT 100
11227: PPUSH
11228: LD_INT 75
11230: PPUSH
11231: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 123
11242: PPUSH
11243: LD_INT 103
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 138
11257: PPUSH
11258: LD_INT 108
11260: PPUSH
11261: CALL_OW 171
// AddComHold ( Frank ) ;
11265: LD_EXP 33
11269: PPUSH
11270: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11274: LD_INT 35
11276: PPUSH
11277: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11281: LD_EXP 33
11285: PPUSH
11286: LD_INT 138
11288: PPUSH
11289: LD_INT 108
11291: PPUSH
11292: CALL_OW 307
11296: IFFALSE 11274
// AddComMoveXY ( Frank , 125 , 132 ) ;
11298: LD_EXP 33
11302: PPUSH
11303: LD_INT 125
11305: PPUSH
11306: LD_INT 132
11308: PPUSH
11309: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11313: LD_INT 35
11315: PPUSH
11316: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11320: LD_INT 1
11322: PPUSH
11323: LD_EXP 33
11327: PPUSH
11328: CALL_OW 292
11332: PUSH
11333: LD_EXP 33
11337: PPUSH
11338: LD_INT 7
11340: PPUSH
11341: CALL_OW 296
11345: PUSH
11346: LD_INT 7
11348: LESS
11349: OR
11350: IFFALSE 11313
// DialogueOn ;
11352: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11356: LD_EXP 33
11360: PPUSH
11361: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11365: LD_INT 10
11367: PPUSH
11368: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11372: LD_EXP 21
11376: PPUSH
11377: LD_STRING D4Fa-JMM-1
11379: PPUSH
11380: CALL_OW 88
// for i in points do
11384: LD_ADDR_VAR 0 1
11388: PUSH
11389: LD_VAR 0 2
11393: PUSH
11394: FOR_IN
11395: IFFALSE 11453
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11397: LD_VAR 0 1
11401: PUSH
11402: LD_INT 1
11404: ARRAY
11405: PPUSH
11406: LD_VAR 0 1
11410: PUSH
11411: LD_INT 2
11413: ARRAY
11414: PPUSH
11415: LD_INT 1
11417: PPUSH
11418: LD_INT 20
11420: NEG
11421: PPUSH
11422: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11426: LD_VAR 0 1
11430: PUSH
11431: LD_INT 1
11433: ARRAY
11434: PPUSH
11435: LD_VAR 0 1
11439: PUSH
11440: LD_INT 2
11442: ARRAY
11443: PPUSH
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 331
// end ;
11451: GO 11394
11453: POP
11454: POP
// dwait ( 0 0$0.5 ) ;
11455: LD_INT 18
11457: PPUSH
11458: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11462: LD_INT 42
11464: PPUSH
11465: LD_INT 27
11467: PPUSH
11468: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11472: LD_EXP 33
11476: PPUSH
11477: LD_STRING D4Fa-Frank-1
11479: PPUSH
11480: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11484: LD_INT 18
11486: PPUSH
11487: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11491: LD_EXP 21
11495: PPUSH
11496: LD_STRING D4Fa-JMM-2
11498: PPUSH
11499: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11503: LD_INT 118
11505: PPUSH
11506: LD_INT 80
11508: PPUSH
11509: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11513: LD_EXP 33
11517: PPUSH
11518: LD_STRING D4Fa-Frank-2
11520: PPUSH
11521: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11525: LD_INT 10
11527: PPUSH
11528: CALL_OW 68
// DialogueOff ;
11532: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11536: LD_EXP 33
11540: PPUSH
11541: LD_INT 1
11543: PPUSH
11544: CALL_OW 235
// end else
11548: GO 11812
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11550: LD_INT 2
11552: PPUSH
11553: LD_INT 4
11555: PPUSH
11556: LD_INT 2
11558: PPUSH
11559: LD_INT 1
11561: PPUSH
11562: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11566: LD_EXP 33
11570: PPUSH
11571: LD_INT 75
11573: PPUSH
11574: LD_INT 63
11576: PPUSH
11577: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 175
11588: PPUSH
11589: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11593: LD_EXP 33
11597: PPUSH
11598: LD_INT 102
11600: PPUSH
11601: LD_INT 76
11603: PPUSH
11604: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 108
11615: PPUSH
11616: LD_INT 70
11618: PPUSH
11619: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11623: LD_INT 35
11625: PPUSH
11626: CALL_OW 67
// until See ( 2 , Frank ) ;
11630: LD_INT 2
11632: PPUSH
11633: LD_EXP 33
11637: PPUSH
11638: CALL_OW 292
11642: IFFALSE 11623
// ComMoveXY ( Frank , 112 , 118 ) ;
11644: LD_EXP 33
11648: PPUSH
11649: LD_INT 112
11651: PPUSH
11652: LD_INT 118
11654: PPUSH
11655: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11659: LD_EXP 33
11663: PPUSH
11664: CALL_OW 256
11668: PUSH
11669: LD_INT 750
11671: GREATEREQUAL
11672: IFFALSE 11686
// SetLives ( Frank , 700 ) ;
11674: LD_EXP 33
11678: PPUSH
11679: LD_INT 700
11681: PPUSH
11682: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11686: LD_INT 35
11688: PPUSH
11689: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11693: LD_INT 1
11695: PPUSH
11696: LD_EXP 33
11700: PPUSH
11701: CALL_OW 292
11705: PUSH
11706: LD_EXP 33
11710: PPUSH
11711: LD_INT 7
11713: PPUSH
11714: CALL_OW 296
11718: PUSH
11719: LD_INT 17
11721: LESS
11722: OR
11723: IFFALSE 11686
// DialogueOn ;
11725: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11729: LD_EXP 33
11733: PPUSH
11734: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11738: LD_EXP 33
11742: PPUSH
11743: LD_STRING D4Fb-Frank-1
11745: PPUSH
11746: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11750: LD_EXP 21
11754: PPUSH
11755: LD_STRING D4Fb-JMM-1
11757: PPUSH
11758: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11762: LD_INT 2
11764: PPUSH
11765: LD_STRING D4Fb-FSci1-1
11767: PPUSH
11768: CALL 16726 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11772: LD_EXP 33
11776: PPUSH
11777: LD_STRING D4Fb-Frank-2
11779: PPUSH
11780: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11784: LD_EXP 21
11788: PPUSH
11789: LD_STRING D4Fb-JMM-2
11791: PPUSH
11792: CALL_OW 88
// DialogueOff ;
11796: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11800: LD_EXP 33
11804: PPUSH
11805: LD_INT 1
11807: PPUSH
11808: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11812: LD_EXP 34
11816: PPUSH
11817: CALL_OW 302
11821: PUSH
11822: LD_EXP 33
11826: NOT
11827: AND
11828: IFFALSE 11976
// begin DialogueOn ;
11830: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11834: LD_EXP 21
11838: PUSH
11839: LD_EXP 34
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PPUSH
11848: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11852: LD_EXP 34
11856: PPUSH
11857: LD_STRING D3Y-Yam-1
11859: PPUSH
11860: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11864: LD_EXP 21
11868: PPUSH
11869: LD_STRING D3Y-JMM-1
11871: PPUSH
11872: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11876: LD_EXP 34
11880: PPUSH
11881: LD_STRING D3Y-Yam-2
11883: PPUSH
11884: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11888: LD_STRING QYamoko
11890: PPUSH
11891: CALL_OW 97
11895: PUSH
11896: LD_INT 1
11898: DOUBLE
11899: EQUAL
11900: IFTRUE 11904
11902: GO 11939
11904: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11905: LD_EXP 21
11909: PPUSH
11910: LD_STRING D3Ya-JMM-1
11912: PPUSH
11913: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11917: LD_EXP 34
11921: PPUSH
11922: LD_STRING D3Ya-Yam-1
11924: PPUSH
11925: CALL_OW 88
// us_scout := 1 ;
11929: LD_ADDR_EXP 8
11933: PUSH
11934: LD_INT 1
11936: ST_TO_ADDR
// end ; 2 :
11937: GO 11972
11939: LD_INT 2
11941: DOUBLE
11942: EQUAL
11943: IFTRUE 11947
11945: GO 11971
11947: POP
// begin us_scout := - 1 ;
11948: LD_ADDR_EXP 8
11952: PUSH
11953: LD_INT 1
11955: NEG
11956: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11957: LD_EXP 21
11961: PPUSH
11962: LD_STRING D3Yb-JMM-1
11964: PPUSH
11965: CALL_OW 88
// end ; end ;
11969: GO 11972
11971: POP
// DialogueOff ;
11972: CALL_OW 7
// end ; if Frank then
11976: LD_EXP 33
11980: IFFALSE 11984
// exit ;
11982: GO 12749
// if us_scout in [ - 1 , 0 ] then
11984: LD_EXP 8
11988: PUSH
11989: LD_INT 1
11991: NEG
11992: PUSH
11993: LD_INT 0
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12749
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12004: LD_ADDR_EXP 8
12008: PUSH
12009: LD_INT 2
12011: PUSH
12012: LD_INT 2
12014: PUSH
12015: LD_INT 1
12017: PUSH
12018: LD_INT 1
12020: PUSH
12021: EMPTY
12022: LIST
12023: LIST
12024: LIST
12025: LIST
12026: PUSH
12027: LD_OWVAR 67
12031: ARRAY
12032: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12033: LD_EXP 8
12037: PUSH
12038: LD_INT 1
12040: PUSH
12041: LD_INT 2
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: IN
12048: IFFALSE 12749
// begin if IsInUnit ( Kikuchi ) then
12050: LD_EXP 34
12054: PPUSH
12055: CALL_OW 310
12059: IFFALSE 12070
// ComExitBuilding ( Kikuchi ) ;
12061: LD_EXP 34
12065: PPUSH
12066: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12070: LD_EXP 34
12074: PPUSH
12075: CALL_OW 311
12079: IFFALSE 12090
// ComExitVehicle ( Kikuchi ) ;
12081: LD_EXP 34
12085: PPUSH
12086: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12090: LD_EXP 34
12094: PPUSH
12095: LD_INT 4
12097: PPUSH
12098: CALL_OW 235
// wait ( 0 0$1 ) ;
12102: LD_INT 35
12104: PPUSH
12105: CALL_OW 67
// if us_scout = 2 then
12109: LD_EXP 8
12113: PUSH
12114: LD_INT 2
12116: EQUAL
12117: IFFALSE 12497
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12119: LD_EXP 34
12123: PPUSH
12124: LD_INT 75
12126: PPUSH
12127: LD_INT 63
12129: PPUSH
12130: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12134: LD_EXP 34
12138: PPUSH
12139: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12143: LD_EXP 34
12147: PPUSH
12148: LD_INT 770
12150: PPUSH
12151: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12155: LD_EXP 34
12159: PPUSH
12160: LD_INT 100
12162: PPUSH
12163: LD_INT 75
12165: PPUSH
12166: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12170: LD_EXP 34
12174: PPUSH
12175: LD_INT 123
12177: PPUSH
12178: LD_INT 103
12180: PPUSH
12181: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12185: LD_EXP 34
12189: PPUSH
12190: LD_INT 138
12192: PPUSH
12193: LD_INT 108
12195: PPUSH
12196: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12200: LD_EXP 34
12204: PPUSH
12205: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12209: LD_INT 35
12211: PPUSH
12212: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12216: LD_EXP 34
12220: PPUSH
12221: LD_INT 138
12223: PPUSH
12224: LD_INT 108
12226: PPUSH
12227: CALL_OW 307
12231: IFFALSE 12209
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12233: LD_EXP 34
12237: PPUSH
12238: LD_INT 125
12240: PPUSH
12241: LD_INT 132
12243: PPUSH
12244: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12248: LD_INT 35
12250: PPUSH
12251: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12255: LD_INT 1
12257: PPUSH
12258: LD_EXP 34
12262: PPUSH
12263: CALL_OW 292
12267: PUSH
12268: LD_EXP 34
12272: PPUSH
12273: LD_INT 7
12275: PPUSH
12276: CALL_OW 296
12280: PUSH
12281: LD_INT 7
12283: LESS
12284: OR
12285: IFFALSE 12248
// DialogueOn ;
12287: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12300: LD_INT 10
12302: PPUSH
12303: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12307: LD_EXP 34
12311: PPUSH
12312: LD_STRING D4Ya-Yam-1
12314: PPUSH
12315: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12319: LD_EXP 21
12323: PPUSH
12324: LD_STRING D4Ya-JMM-1
12326: PPUSH
12327: CALL_OW 88
// for i in points do
12331: LD_ADDR_VAR 0 1
12335: PUSH
12336: LD_VAR 0 2
12340: PUSH
12341: FOR_IN
12342: IFFALSE 12400
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12344: LD_VAR 0 1
12348: PUSH
12349: LD_INT 1
12351: ARRAY
12352: PPUSH
12353: LD_VAR 0 1
12357: PUSH
12358: LD_INT 2
12360: ARRAY
12361: PPUSH
12362: LD_INT 1
12364: PPUSH
12365: LD_INT 20
12367: NEG
12368: PPUSH
12369: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12373: LD_VAR 0 1
12377: PUSH
12378: LD_INT 1
12380: ARRAY
12381: PPUSH
12382: LD_VAR 0 1
12386: PUSH
12387: LD_INT 2
12389: ARRAY
12390: PPUSH
12391: LD_INT 1
12393: PPUSH
12394: CALL_OW 331
// end ;
12398: GO 12341
12400: POP
12401: POP
// dwait ( 0 0$0.5 ) ;
12402: LD_INT 18
12404: PPUSH
12405: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12409: LD_INT 42
12411: PPUSH
12412: LD_INT 27
12414: PPUSH
12415: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12419: LD_EXP 34
12423: PPUSH
12424: LD_STRING D4Ya-Yam-2
12426: PPUSH
12427: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12431: LD_INT 18
12433: PPUSH
12434: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12438: LD_INT 118
12440: PPUSH
12441: LD_INT 80
12443: PPUSH
12444: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12448: LD_EXP 21
12452: PPUSH
12453: LD_STRING D4Ya-JMM-2
12455: PPUSH
12456: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12460: LD_EXP 34
12464: PPUSH
12465: LD_STRING D4Ya-Yam-3
12467: PPUSH
12468: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12472: LD_INT 10
12474: PPUSH
12475: CALL_OW 68
// DialogueOff ;
12479: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12483: LD_EXP 34
12487: PPUSH
12488: LD_INT 1
12490: PPUSH
12491: CALL_OW 235
// end else
12495: GO 12749
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12497: LD_INT 2
12499: PPUSH
12500: LD_INT 4
12502: PPUSH
12503: LD_INT 2
12505: PPUSH
12506: LD_INT 1
12508: PPUSH
12509: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12513: LD_EXP 34
12517: PPUSH
12518: LD_INT 75
12520: PPUSH
12521: LD_INT 63
12523: PPUSH
12524: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_INT 175
12535: PPUSH
12536: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12540: LD_EXP 34
12544: PPUSH
12545: LD_INT 102
12547: PPUSH
12548: LD_INT 76
12550: PPUSH
12551: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12555: LD_EXP 34
12559: PPUSH
12560: LD_INT 108
12562: PPUSH
12563: LD_INT 70
12565: PPUSH
12566: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12570: LD_INT 35
12572: PPUSH
12573: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12577: LD_INT 2
12579: PPUSH
12580: LD_EXP 34
12584: PPUSH
12585: CALL_OW 292
12589: IFFALSE 12570
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12591: LD_EXP 34
12595: PPUSH
12596: LD_INT 112
12598: PPUSH
12599: LD_INT 118
12601: PPUSH
12602: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12606: LD_EXP 34
12610: PPUSH
12611: CALL_OW 256
12615: PUSH
12616: LD_INT 750
12618: GREATEREQUAL
12619: IFFALSE 12633
// SetLives ( Kikuchi , 700 ) ;
12621: LD_EXP 34
12625: PPUSH
12626: LD_INT 700
12628: PPUSH
12629: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12633: LD_INT 35
12635: PPUSH
12636: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12640: LD_INT 1
12642: PPUSH
12643: LD_EXP 34
12647: PPUSH
12648: CALL_OW 292
12652: PUSH
12653: LD_EXP 34
12657: PPUSH
12658: LD_INT 7
12660: PPUSH
12661: CALL_OW 296
12665: PUSH
12666: LD_INT 17
12668: LESS
12669: OR
12670: IFFALSE 12633
// DialogueOn ;
12672: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12676: LD_EXP 34
12680: PPUSH
12681: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12685: LD_EXP 34
12689: PPUSH
12690: LD_STRING D4Yb-Yam-1
12692: PPUSH
12693: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12697: LD_EXP 21
12701: PPUSH
12702: LD_STRING D4Yb-JMM-1
12704: PPUSH
12705: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12709: LD_EXP 34
12713: PPUSH
12714: LD_STRING D4Yb-Yam-2
12716: PPUSH
12717: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12721: LD_EXP 21
12725: PPUSH
12726: LD_STRING D4Yb-JMM-2
12728: PPUSH
12729: CALL_OW 88
// DialogueOff ;
12733: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12737: LD_EXP 34
12741: PPUSH
12742: LD_INT 1
12744: PPUSH
12745: CALL_OW 235
// end ; end ; end ;
12749: PPOPN 2
12751: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12752: LD_EXP 6
12756: IFFALSE 13789
12758: GO 12760
12760: DISABLE
12761: LD_INT 0
12763: PPUSH
12764: PPUSH
12765: PPUSH
12766: PPUSH
// begin enable ;
12767: ENABLE
// if not seen [ 1 ] then
12768: LD_EXP 9
12772: PUSH
12773: LD_INT 1
12775: ARRAY
12776: NOT
12777: IFFALSE 12957
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 2
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 2
12796: PUSH
12797: LD_INT 25
12799: PUSH
12800: LD_INT 11
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: LD_INT 33
12809: PUSH
12810: LD_INT 4
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: LIST
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 69
12830: ST_TO_ADDR
// if tmp then
12831: LD_VAR 0 2
12835: IFFALSE 12957
// for i in tmp do
12837: LD_ADDR_VAR 0 1
12841: PUSH
12842: LD_VAR 0 2
12846: PUSH
12847: FOR_IN
12848: IFFALSE 12955
// if See ( 1 , i ) then
12850: LD_INT 1
12852: PPUSH
12853: LD_VAR 0 1
12857: PPUSH
12858: CALL_OW 292
12862: IFFALSE 12953
// begin seen := Replace ( seen , 1 , true ) ;
12864: LD_ADDR_EXP 9
12868: PUSH
12869: LD_EXP 9
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 1
12879: PPUSH
12880: CALL_OW 1
12884: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12885: LD_INT 1
12887: PPUSH
12888: CALL 16548 0 1
12892: IFFALSE 12953
// begin DialogueOn ;
12894: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12898: LD_VAR 0 1
12902: PPUSH
12903: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12907: LD_INT 10
12909: PPUSH
12910: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: LD_INT 1
12921: PPUSH
12922: LD_STRING D5a-Sol2-1
12924: PPUSH
12925: CALL 16726 0 2
12929: ST_TO_ADDR
// if not un then
12930: LD_VAR 0 3
12934: NOT
12935: IFFALSE 12947
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12937: LD_INT 2
12939: PPUSH
12940: LD_STRING D5a-FSol2-1
12942: PPUSH
12943: CALL 16726 0 2
// DialogueOff ;
12947: CALL_OW 7
// break ;
12951: GO 12955
// end ; end ;
12953: GO 12847
12955: POP
12956: POP
// end ; if not seen [ 2 ] then
12957: LD_EXP 9
12961: PUSH
12962: LD_INT 2
12964: ARRAY
12965: NOT
12966: IFFALSE 13191
// begin can_kamikazed := true ;
12968: LD_ADDR_EXP 10
12972: PUSH
12973: LD_INT 1
12975: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12976: LD_ADDR_VAR 0 2
12980: PUSH
12981: LD_INT 22
12983: PUSH
12984: LD_INT 2
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PUSH
12991: LD_INT 25
12993: PUSH
12994: LD_INT 17
12996: PUSH
12997: EMPTY
12998: LIST
12999: LIST
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PPUSH
13005: CALL_OW 69
13009: ST_TO_ADDR
// if tmp then
13010: LD_VAR 0 2
13014: IFFALSE 13191
// for i in tmp do
13016: LD_ADDR_VAR 0 1
13020: PUSH
13021: LD_VAR 0 2
13025: PUSH
13026: FOR_IN
13027: IFFALSE 13189
// if See ( 1 , i ) then
13029: LD_INT 1
13031: PPUSH
13032: LD_VAR 0 1
13036: PPUSH
13037: CALL_OW 292
13041: IFFALSE 13187
// begin seen := Replace ( seen , 2 , true ) ;
13043: LD_ADDR_EXP 9
13047: PUSH
13048: LD_EXP 9
13052: PPUSH
13053: LD_INT 2
13055: PPUSH
13056: LD_INT 1
13058: PPUSH
13059: CALL_OW 1
13063: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13064: LD_INT 1
13066: PPUSH
13067: CALL 16548 0 1
13071: IFFALSE 13187
// begin DialogueOn ;
13073: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13077: LD_VAR 0 1
13081: PPUSH
13082: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13086: LD_INT 10
13088: PPUSH
13089: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13093: LD_ADDR_VAR 0 3
13097: PUSH
13098: LD_INT 1
13100: PPUSH
13101: LD_STRING D5b-Sol1-1
13103: PPUSH
13104: CALL 16726 0 2
13108: ST_TO_ADDR
// if not un then
13109: LD_VAR 0 3
13113: NOT
13114: IFFALSE 13132
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13116: LD_ADDR_VAR 0 3
13120: PUSH
13121: LD_INT 2
13123: PPUSH
13124: LD_STRING D5b-FSol1-1
13126: PPUSH
13127: CALL 16726 0 2
13131: ST_TO_ADDR
// if un then
13132: LD_VAR 0 3
13136: IFFALSE 13181
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13138: LD_ADDR_VAR 0 4
13142: PUSH
13143: LD_INT 1
13145: PPUSH
13146: LD_STRING D5b-Sol2-1
13148: PPUSH
13149: LD_VAR 0 3
13153: PPUSH
13154: CALL 16952 0 3
13158: ST_TO_ADDR
// if not un2 then
13159: LD_VAR 0 4
13163: NOT
13164: IFFALSE 13181
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13166: LD_INT 2
13168: PPUSH
13169: LD_STRING D5b-FSol2-1
13171: PPUSH
13172: LD_VAR 0 3
13176: PPUSH
13177: CALL 16952 0 3
// end ; DialogueOff ;
13181: CALL_OW 7
// break ;
13185: GO 13189
// end ; end ;
13187: GO 13026
13189: POP
13190: POP
// end ; if not seen [ 3 ] then
13191: LD_EXP 9
13195: PUSH
13196: LD_INT 3
13198: ARRAY
13199: NOT
13200: IFFALSE 13374
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13202: LD_ADDR_VAR 0 2
13206: PUSH
13207: LD_INT 22
13209: PUSH
13210: LD_INT 2
13212: PUSH
13213: EMPTY
13214: LIST
13215: LIST
13216: PUSH
13217: LD_INT 33
13219: PUSH
13220: LD_INT 2
13222: PUSH
13223: EMPTY
13224: LIST
13225: LIST
13226: PUSH
13227: EMPTY
13228: LIST
13229: LIST
13230: PPUSH
13231: CALL_OW 69
13235: ST_TO_ADDR
// if tmp then
13236: LD_VAR 0 2
13240: IFFALSE 13374
// for i in tmp do
13242: LD_ADDR_VAR 0 1
13246: PUSH
13247: LD_VAR 0 2
13251: PUSH
13252: FOR_IN
13253: IFFALSE 13372
// if See ( 1 , i ) then
13255: LD_INT 1
13257: PPUSH
13258: LD_VAR 0 1
13262: PPUSH
13263: CALL_OW 292
13267: IFFALSE 13370
// begin seen := Replace ( seen , 3 , true ) ;
13269: LD_ADDR_EXP 9
13273: PUSH
13274: LD_EXP 9
13278: PPUSH
13279: LD_INT 3
13281: PPUSH
13282: LD_INT 1
13284: PPUSH
13285: CALL_OW 1
13289: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13290: LD_INT 1
13292: PPUSH
13293: CALL 16548 0 1
13297: IFFALSE 13370
// begin DialogueOn ;
13299: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13303: LD_VAR 0 1
13307: PPUSH
13308: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13312: LD_INT 10
13314: PPUSH
13315: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_INT 1
13326: PPUSH
13327: LD_STRING D8-Sol1-1
13329: PPUSH
13330: CALL 16726 0 2
13334: ST_TO_ADDR
// if not un then
13335: LD_VAR 0 3
13339: NOT
13340: IFFALSE 13352
// SayRand ( sex_female , D8-FSol1-1 ) ;
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D8-FSol1-1
13347: PPUSH
13348: CALL 16726 0 2
// Say ( JMM , D8-JMM-1 ) ;
13352: LD_EXP 21
13356: PPUSH
13357: LD_STRING D8-JMM-1
13359: PPUSH
13360: CALL_OW 88
// DialogueOff ;
13364: CALL_OW 7
// break ;
13368: GO 13372
// end ; end ;
13370: GO 13252
13372: POP
13373: POP
// end ; if not seen [ 4 ] then
13374: LD_EXP 9
13378: PUSH
13379: LD_INT 4
13381: ARRAY
13382: NOT
13383: IFFALSE 13545
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13385: LD_ADDR_VAR 0 2
13389: PUSH
13390: LD_INT 22
13392: PUSH
13393: LD_INT 2
13395: PUSH
13396: EMPTY
13397: LIST
13398: LIST
13399: PUSH
13400: LD_INT 33
13402: PUSH
13403: LD_INT 5
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: PPUSH
13414: CALL_OW 69
13418: ST_TO_ADDR
// if tmp then
13419: LD_VAR 0 2
13423: IFFALSE 13545
// for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13543
// if See ( 1 , i ) then
13438: LD_INT 1
13440: PPUSH
13441: LD_VAR 0 1
13445: PPUSH
13446: CALL_OW 292
13450: IFFALSE 13541
// begin seen := Replace ( seen , 4 , true ) ;
13452: LD_ADDR_EXP 9
13456: PUSH
13457: LD_EXP 9
13461: PPUSH
13462: LD_INT 4
13464: PPUSH
13465: LD_INT 1
13467: PPUSH
13468: CALL_OW 1
13472: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13473: LD_INT 1
13475: PPUSH
13476: CALL 16548 0 1
13480: IFFALSE 13541
// begin DialogueOn ;
13482: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13486: LD_VAR 0 1
13490: PPUSH
13491: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13495: LD_INT 10
13497: PPUSH
13498: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13502: LD_ADDR_VAR 0 3
13506: PUSH
13507: LD_INT 1
13509: PPUSH
13510: LD_STRING D5a-Sol1-1
13512: PPUSH
13513: CALL 16726 0 2
13517: ST_TO_ADDR
// if not un then
13518: LD_VAR 0 3
13522: NOT
13523: IFFALSE 13535
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13525: LD_INT 2
13527: PPUSH
13528: LD_STRING D5a-FSol1-1
13530: PPUSH
13531: CALL 16726 0 2
// DialogueOff ;
13535: CALL_OW 7
// break ;
13539: GO 13543
// end ; end ;
13541: GO 13435
13543: POP
13544: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13545: LD_EXP 9
13549: PUSH
13550: LD_INT 5
13552: ARRAY
13553: NOT
13554: PUSH
13555: LD_EXP 9
13559: PUSH
13560: LD_INT 3
13562: ARRAY
13563: AND
13564: IFFALSE 13738
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13566: LD_ADDR_VAR 0 2
13570: PUSH
13571: LD_INT 22
13573: PUSH
13574: LD_INT 2
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: PUSH
13581: LD_INT 34
13583: PUSH
13584: LD_INT 31
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: PPUSH
13595: CALL_OW 69
13599: ST_TO_ADDR
// if tmp then
13600: LD_VAR 0 2
13604: IFFALSE 13738
// for i in tmp do
13606: LD_ADDR_VAR 0 1
13610: PUSH
13611: LD_VAR 0 2
13615: PUSH
13616: FOR_IN
13617: IFFALSE 13736
// if See ( 1 , i ) then
13619: LD_INT 1
13621: PPUSH
13622: LD_VAR 0 1
13626: PPUSH
13627: CALL_OW 292
13631: IFFALSE 13734
// begin seen := Replace ( seen , 5 , true ) ;
13633: LD_ADDR_EXP 9
13637: PUSH
13638: LD_EXP 9
13642: PPUSH
13643: LD_INT 5
13645: PPUSH
13646: LD_INT 1
13648: PPUSH
13649: CALL_OW 1
13653: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13654: LD_INT 1
13656: PPUSH
13657: CALL 16548 0 1
13661: IFFALSE 13734
// begin DialogueOn ;
13663: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13676: LD_INT 10
13678: PPUSH
13679: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13683: LD_ADDR_VAR 0 3
13687: PUSH
13688: LD_INT 1
13690: PPUSH
13691: LD_STRING D8a-Sol2-1
13693: PPUSH
13694: CALL 16726 0 2
13698: ST_TO_ADDR
// if not un then
13699: LD_VAR 0 3
13703: NOT
13704: IFFALSE 13716
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13706: LD_INT 2
13708: PPUSH
13709: LD_STRING D8a-FSol2-1
13711: PPUSH
13712: CALL 16726 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13716: LD_EXP 21
13720: PPUSH
13721: LD_STRING D8a-JMM-1
13723: PPUSH
13724: CALL_OW 88
// DialogueOff ;
13728: CALL_OW 7
// break ;
13732: GO 13736
// end ; end ;
13734: GO 13616
13736: POP
13737: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13738: LD_EXP 9
13742: PUSH
13743: LD_INT 1
13745: ARRAY
13746: PUSH
13747: LD_EXP 9
13751: PUSH
13752: LD_INT 2
13754: ARRAY
13755: AND
13756: PUSH
13757: LD_EXP 9
13761: PUSH
13762: LD_INT 3
13764: ARRAY
13765: AND
13766: PUSH
13767: LD_EXP 9
13771: PUSH
13772: LD_INT 4
13774: ARRAY
13775: AND
13776: PUSH
13777: LD_EXP 9
13781: PUSH
13782: LD_INT 5
13784: ARRAY
13785: AND
13786: IFFALSE 13789
// disable ;
13788: DISABLE
// end ;
13789: PPOPN 4
13791: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13792: LD_EXP 10
13796: PUSH
13797: LD_EXP 11
13801: AND
13802: IFFALSE 14000
13804: GO 13806
13806: DISABLE
13807: LD_INT 0
13809: PPUSH
// begin DialogueOn ;
13810: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13814: LD_EXP 11
13818: PPUSH
13819: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13823: LD_ADDR_VAR 0 1
13827: PUSH
13828: LD_INT 1
13830: PPUSH
13831: LD_STRING D5c-Sol1-1
13833: PPUSH
13834: CALL 16726 0 2
13838: ST_TO_ADDR
// if not un then
13839: LD_VAR 0 1
13843: NOT
13844: IFFALSE 13862
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13846: LD_ADDR_VAR 0 1
13850: PUSH
13851: LD_INT 2
13853: PPUSH
13854: LD_STRING D5c-FSol1-1
13856: PPUSH
13857: CALL 16726 0 2
13861: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13862: LD_EXP 21
13866: PPUSH
13867: LD_STRING D5c-JMM-1
13869: PPUSH
13870: CALL_OW 88
// if IsOk ( Lisa ) then
13874: LD_EXP 22
13878: PPUSH
13879: CALL_OW 302
13883: IFFALSE 13899
// Say ( Lisa , D5d-Lisa-1 ) else
13885: LD_EXP 22
13889: PPUSH
13890: LD_STRING D5d-Lisa-1
13892: PPUSH
13893: CALL_OW 88
13897: GO 13984
// if IsOk ( Cyrus ) then
13899: LD_EXP 25
13903: PPUSH
13904: CALL_OW 302
13908: IFFALSE 13924
// Say ( Cyrus , D5d-Cyrus-1 ) else
13910: LD_EXP 25
13914: PPUSH
13915: LD_STRING D5d-Cyrus-1
13917: PPUSH
13918: CALL_OW 88
13922: GO 13984
// if IsOk ( Gary ) then
13924: LD_EXP 32
13928: PPUSH
13929: CALL_OW 302
13933: IFFALSE 13949
// Say ( Gary , D5d-Gary-1 ) else
13935: LD_EXP 32
13939: PPUSH
13940: LD_STRING D5d-Gary-1
13942: PPUSH
13943: CALL_OW 88
13947: GO 13984
// if GetSex ( un ) = sex_male then
13949: LD_VAR 0 1
13953: PPUSH
13954: CALL_OW 258
13958: PUSH
13959: LD_INT 1
13961: EQUAL
13962: IFFALSE 13978
// Say ( un , D5d-Sol1-1 ) else
13964: LD_VAR 0 1
13968: PPUSH
13969: LD_STRING D5d-Sol1-1
13971: PPUSH
13972: CALL_OW 88
13976: GO 13984
// begin DialogueOff ;
13978: CALL_OW 7
// exit ;
13982: GO 14000
// end ; Say ( JMM , D5d-JMM-1 ) ;
13984: LD_EXP 21
13988: PPUSH
13989: LD_STRING D5d-JMM-1
13991: PPUSH
13992: CALL_OW 88
// DialogueOff ;
13996: CALL_OW 7
// end ;
14000: PPOPN 1
14002: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14003: LD_INT 1
14005: PPUSH
14006: LD_INT 17
14008: PPUSH
14009: CALL_OW 294
14013: PUSH
14014: LD_INT 2
14016: GREATEREQUAL
14017: IFFALSE 14149
14019: GO 14021
14021: DISABLE
14022: LD_INT 0
14024: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14025: LD_INT 10
14027: PPUSH
14028: LD_INT 5
14030: PPUSH
14031: LD_INT 1
14033: PPUSH
14034: LD_INT 10
14036: NEG
14037: PPUSH
14038: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14042: LD_INT 10
14044: PPUSH
14045: LD_INT 5
14047: PPUSH
14048: LD_INT 1
14050: PPUSH
14051: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14055: LD_INT 10
14057: PPUSH
14058: LD_INT 5
14060: PPUSH
14061: CALL_OW 86
// DialogueOn ;
14065: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14069: LD_ADDR_VAR 0 1
14073: PUSH
14074: LD_INT 1
14076: PPUSH
14077: LD_STRING D6-Sci1-1
14079: PPUSH
14080: CALL 16726 0 2
14084: ST_TO_ADDR
// if un then
14085: LD_VAR 0 1
14089: IFFALSE 14127
// begin Say ( JMM , D6-JMM-1 ) ;
14091: LD_EXP 21
14095: PPUSH
14096: LD_STRING D6-JMM-1
14098: PPUSH
14099: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_STRING D6-Sci1-2
14110: PPUSH
14111: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14115: LD_EXP 21
14119: PPUSH
14120: LD_STRING D6-JMM-2
14122: PPUSH
14123: CALL_OW 88
// end ; DialogueOff ;
14127: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14131: LD_STRING M3
14133: PPUSH
14134: CALL_OW 337
// wait ( 0 0$30 ) ;
14138: LD_INT 1050
14140: PPUSH
14141: CALL_OW 67
// AmericanReinforcements ;
14145: CALL 2326 0 0
// end ;
14149: PPOPN 1
14151: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14152: LD_OWVAR 1
14156: PUSH
14157: LD_INT 42000
14159: GREATEREQUAL
14160: PUSH
14161: LD_INT 2
14163: PPUSH
14164: LD_INT 169
14166: PPUSH
14167: LD_INT 90
14169: PPUSH
14170: LD_INT 10
14172: PPUSH
14173: CALL 54688 0 4
14177: PUSH
14178: LD_INT 4
14180: ARRAY
14181: PUSH
14182: LD_INT 0
14184: EQUAL
14185: PUSH
14186: LD_INT 45
14188: PPUSH
14189: CALL_OW 301
14193: OR
14194: PUSH
14195: LD_INT 45
14197: PPUSH
14198: CALL_OW 255
14202: PUSH
14203: LD_INT 1
14205: EQUAL
14206: OR
14207: AND
14208: PUSH
14209: LD_INT 94
14211: PPUSH
14212: CALL_OW 301
14216: NOT
14217: AND
14218: IFFALSE 15423
14220: GO 14222
14222: DISABLE
14223: LD_INT 0
14225: PPUSH
14226: PPUSH
14227: PPUSH
14228: PPUSH
14229: PPUSH
// begin uc_side := 5 ;
14230: LD_ADDR_OWVAR 20
14234: PUSH
14235: LD_INT 5
14237: ST_TO_ADDR
// uc_nation := 2 ;
14238: LD_ADDR_OWVAR 21
14242: PUSH
14243: LD_INT 2
14245: ST_TO_ADDR
// InitHc ;
14246: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14250: LD_INT 1
14252: PPUSH
14253: LD_INT 3
14255: PPUSH
14256: LD_INT 8
14258: PPUSH
14259: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14263: LD_ADDR_OWVAR 29
14267: PUSH
14268: LD_INT 12
14270: PUSH
14271: LD_INT 12
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: ST_TO_ADDR
// hc_name := Hans Fliege ;
14278: LD_ADDR_OWVAR 26
14282: PUSH
14283: LD_STRING Hans Fliege
14285: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14286: LD_ADDR_OWVAR 33
14290: PUSH
14291: LD_STRING SecondCharsGal
14293: ST_TO_ADDR
// hc_face_number := 7 ;
14294: LD_ADDR_OWVAR 34
14298: PUSH
14299: LD_INT 7
14301: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14302: LD_ADDR_EXP 46
14306: PUSH
14307: CALL_OW 44
14311: ST_TO_ADDR
// InitHc ;
14312: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14316: LD_INT 1
14318: PPUSH
14319: LD_INT 16
14321: PPUSH
14322: LD_INT 2
14324: PPUSH
14325: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14329: LD_ADDR_OWVAR 29
14333: PUSH
14334: LD_INT 12
14336: PUSH
14337: LD_INT 12
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: ST_TO_ADDR
// hc_name :=  ;
14344: LD_ADDR_OWVAR 26
14348: PUSH
14349: LD_STRING 
14351: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14352: LD_ADDR_EXP 47
14356: PUSH
14357: CALL_OW 44
14361: ST_TO_ADDR
// InitHc ;
14362: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14366: LD_INT 35
14368: PPUSH
14369: CALL_OW 67
// until not InBattle ( 1 ) ;
14373: LD_INT 1
14375: PPUSH
14376: CALL_OW 463
14380: NOT
14381: IFFALSE 14366
// wait ( 0 0$5 ) ;
14383: LD_INT 175
14385: PPUSH
14386: CALL_OW 67
// DialogueOn ;
14390: CALL_OW 6
// InGameOn ;
14394: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14398: LD_ADDR_VAR 0 1
14402: PUSH
14403: LD_INT 22
14405: PUSH
14406: LD_INT 1
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: LD_INT 2
14415: PUSH
14416: LD_INT 25
14418: PUSH
14419: LD_INT 1
14421: PUSH
14422: EMPTY
14423: LIST
14424: LIST
14425: PUSH
14426: LD_INT 25
14428: PUSH
14429: LD_INT 2
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PUSH
14436: LD_INT 25
14438: PUSH
14439: LD_INT 3
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: PUSH
14446: LD_INT 25
14448: PUSH
14449: LD_INT 4
14451: PUSH
14452: EMPTY
14453: LIST
14454: LIST
14455: PUSH
14456: LD_INT 25
14458: PUSH
14459: LD_INT 5
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: LD_INT 25
14468: PUSH
14469: LD_INT 8
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: LIST
14482: LIST
14483: LIST
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PPUSH
14489: CALL_OW 69
14493: PUSH
14494: LD_EXP 21
14498: PUSH
14499: LD_EXP 22
14503: PUSH
14504: LD_EXP 23
14508: PUSH
14509: LD_EXP 24
14513: PUSH
14514: LD_EXP 25
14518: PUSH
14519: LD_EXP 26
14523: PUSH
14524: LD_EXP 27
14528: PUSH
14529: LD_EXP 28
14533: PUSH
14534: LD_EXP 29
14538: PUSH
14539: LD_EXP 31
14543: PUSH
14544: LD_EXP 32
14548: PUSH
14549: LD_EXP 33
14553: PUSH
14554: LD_EXP 34
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: DIFF
14574: PPUSH
14575: LD_INT 26
14577: PUSH
14578: LD_INT 1
14580: PUSH
14581: EMPTY
14582: LIST
14583: LIST
14584: PPUSH
14585: CALL_OW 72
14589: PUSH
14590: LD_INT 1
14592: ARRAY
14593: ST_TO_ADDR
// if Brown then
14594: LD_EXP 27
14598: IFFALSE 14610
// un := Brown ;
14600: LD_ADDR_VAR 0 1
14604: PUSH
14605: LD_EXP 27
14609: ST_TO_ADDR
// if un then
14610: LD_VAR 0 1
14614: IFFALSE 14640
// begin Say ( un , D7-Sol1-1 ) ;
14616: LD_VAR 0 1
14620: PPUSH
14621: LD_STRING D7-Sol1-1
14623: PPUSH
14624: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14628: LD_EXP 21
14632: PPUSH
14633: LD_STRING D7-JMM-1
14635: PPUSH
14636: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14640: LD_EXP 46
14644: PPUSH
14645: LD_STRING D7-Ar1-1
14647: PPUSH
14648: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14652: LD_EXP 21
14656: PPUSH
14657: LD_STRING D7-JMM-2
14659: PPUSH
14660: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14664: LD_EXP 46
14668: PPUSH
14669: LD_STRING D7-Ar1-2
14671: PPUSH
14672: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14676: LD_EXP 21
14680: PPUSH
14681: LD_STRING D7-JMM-3
14683: PPUSH
14684: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14688: LD_EXP 46
14692: PPUSH
14693: LD_STRING D7-Ar1-3
14695: PPUSH
14696: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14700: LD_EXP 21
14704: PPUSH
14705: LD_STRING D7-JMM-4
14707: PPUSH
14708: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14712: LD_EXP 46
14716: PPUSH
14717: LD_STRING D7-Ar1-4
14719: PPUSH
14720: CALL_OW 94
// InGameOff ;
14724: CALL_OW 9
// DialogueOff ;
14728: CALL_OW 7
// case Query ( QCameras ) of 1 :
14732: LD_STRING QCameras
14734: PPUSH
14735: CALL_OW 97
14739: PUSH
14740: LD_INT 1
14742: DOUBLE
14743: EQUAL
14744: IFTRUE 14748
14746: GO 14751
14748: POP
// ; 2 :
14749: GO 14765
14751: LD_INT 2
14753: DOUBLE
14754: EQUAL
14755: IFTRUE 14759
14757: GO 14764
14759: POP
// exit ; end ;
14760: GO 15423
14762: GO 14765
14764: POP
// ChangeMissionObjectives ( MCar ) ;
14765: LD_STRING MCar
14767: PPUSH
14768: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14772: LD_INT 124
14774: PPUSH
14775: LD_INT 90
14777: PPUSH
14778: LD_INT 1
14780: PPUSH
14781: LD_INT 6
14783: NEG
14784: PPUSH
14785: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14789: LD_INT 124
14791: PPUSH
14792: LD_INT 90
14794: PPUSH
14795: LD_INT 1
14797: PPUSH
14798: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14802: LD_INT 12
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 424
// wait ( 3 ) ;
14812: LD_INT 3
14814: PPUSH
14815: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14819: LD_INT 124
14821: PPUSH
14822: LD_INT 90
14824: PPUSH
14825: CALL_OW 86
// cargo := false ;
14829: LD_ADDR_VAR 0 3
14833: PUSH
14834: LD_INT 0
14836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14837: LD_INT 35
14839: PPUSH
14840: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14844: LD_ADDR_VAR 0 3
14848: PUSH
14849: LD_INT 12
14851: PPUSH
14852: LD_INT 32
14854: PUSH
14855: LD_INT 3
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: LD_INT 34
14864: PUSH
14865: LD_INT 32
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: LD_INT 58
14874: PUSH
14875: EMPTY
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: LIST
14882: PPUSH
14883: CALL_OW 70
14887: ST_TO_ADDR
// until cargo ;
14888: LD_VAR 0 3
14892: IFFALSE 14837
// cargo := cargo [ 1 ] ;
14894: LD_ADDR_VAR 0 3
14898: PUSH
14899: LD_VAR 0 3
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14908: LD_VAR 0 3
14912: PPUSH
14913: LD_INT 5
14915: PPUSH
14916: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14920: LD_INT 12
14922: PPUSH
14923: LD_INT 0
14925: PPUSH
14926: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14930: LD_EXP 46
14934: PPUSH
14935: LD_INT 11
14937: PPUSH
14938: LD_INT 0
14940: PPUSH
14941: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14945: LD_EXP 47
14949: PPUSH
14950: LD_INT 11
14952: PPUSH
14953: LD_INT 0
14955: PPUSH
14956: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14960: LD_EXP 46
14964: PUSH
14965: LD_EXP 47
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PPUSH
14974: LD_INT 12
14976: PPUSH
14977: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14981: LD_EXP 46
14985: PPUSH
14986: LD_VAR 0 3
14990: PPUSH
14991: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14995: LD_EXP 46
14999: PUSH
15000: LD_EXP 47
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: PPUSH
15009: LD_INT 209
15011: PPUSH
15012: LD_INT 178
15014: PPUSH
15015: CALL_OW 171
// escaped := 0 ;
15019: LD_ADDR_VAR 0 5
15023: PUSH
15024: LD_INT 0
15026: ST_TO_ADDR
// while ( true ) do
15027: LD_INT 1
15029: IFFALSE 15245
// begin wait ( 0 0$1 ) ;
15031: LD_INT 35
15033: PPUSH
15034: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15038: LD_EXP 46
15042: PPUSH
15043: CALL_OW 314
15047: NOT
15048: PUSH
15049: LD_EXP 47
15053: PPUSH
15054: CALL_OW 314
15058: NOT
15059: OR
15060: IFFALSE 15086
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15062: LD_EXP 46
15066: PUSH
15067: LD_EXP 47
15071: PUSH
15072: EMPTY
15073: LIST
15074: LIST
15075: PPUSH
15076: LD_INT 209
15078: PPUSH
15079: LD_INT 178
15081: PPUSH
15082: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15086: LD_EXP 46
15090: PPUSH
15091: LD_INT 10
15093: PPUSH
15094: CALL_OW 308
15098: IFFALSE 15123
// begin RemoveUnit ( ar_mechanic ) ;
15100: LD_EXP 46
15104: PPUSH
15105: CALL_OW 64
// escaped := escaped + 1 ;
15109: LD_ADDR_VAR 0 5
15113: PUSH
15114: LD_VAR 0 5
15118: PUSH
15119: LD_INT 1
15121: PLUS
15122: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15123: LD_EXP 47
15127: PPUSH
15128: LD_INT 10
15130: PPUSH
15131: CALL_OW 308
15135: IFFALSE 15160
// begin RemoveUnit ( ar_mechanic_friend ) ;
15137: LD_EXP 47
15141: PPUSH
15142: CALL_OW 64
// escaped := escaped + 1 ;
15146: LD_ADDR_VAR 0 5
15150: PUSH
15151: LD_VAR 0 5
15155: PUSH
15156: LD_INT 1
15158: PLUS
15159: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15160: LD_VAR 0 3
15164: PPUSH
15165: LD_INT 10
15167: PPUSH
15168: CALL_OW 308
15172: IFFALSE 15183
// RemoveUnit ( cargo ) ;
15174: LD_VAR 0 3
15178: PPUSH
15179: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15183: LD_EXP 46
15187: PPUSH
15188: CALL_OW 305
15192: NOT
15193: PUSH
15194: LD_VAR 0 5
15198: PUSH
15199: LD_INT 2
15201: GREATEREQUAL
15202: AND
15203: IFFALSE 15207
// break ;
15205: GO 15245
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15207: LD_EXP 46
15211: PPUSH
15212: CALL_OW 305
15216: NOT
15217: PUSH
15218: LD_EXP 47
15222: PPUSH
15223: CALL_OW 305
15227: NOT
15228: AND
15229: PUSH
15230: LD_VAR 0 5
15234: PUSH
15235: LD_INT 2
15237: LESS
15238: AND
15239: IFFALSE 15243
// exit ;
15241: GO 15423
// end ;
15243: GO 15027
// wait ( 0 0$2 ) ;
15245: LD_INT 70
15247: PPUSH
15248: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15252: LD_EXP 46
15256: PPUSH
15257: LD_STRING D7a-Ar1-1
15259: PPUSH
15260: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15264: LD_ADDR_VAR 0 4
15268: PUSH
15269: LD_INT 129
15271: PUSH
15272: LD_INT 10
15274: PUSH
15275: EMPTY
15276: LIST
15277: LIST
15278: PUSH
15279: LD_INT 103
15281: PUSH
15282: LD_INT 6
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: PUSH
15289: LD_INT 148
15291: PUSH
15292: LD_INT 47
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: PUSH
15299: LD_INT 155
15301: PUSH
15302: LD_INT 16
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: PUSH
15309: EMPTY
15310: LIST
15311: LIST
15312: LIST
15313: LIST
15314: ST_TO_ADDR
// if Difficulty = 1 then
15315: LD_OWVAR 67
15319: PUSH
15320: LD_INT 1
15322: EQUAL
15323: IFFALSE 15360
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15325: LD_ADDR_VAR 0 4
15329: PUSH
15330: LD_VAR 0 4
15334: PUSH
15335: LD_INT 78
15337: PUSH
15338: LD_INT 7
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: PUSH
15345: LD_INT 104
15347: PUSH
15348: LD_INT 43
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: PUSH
15355: EMPTY
15356: LIST
15357: LIST
15358: ADD
15359: ST_TO_ADDR
// for i in tmp do
15360: LD_ADDR_VAR 0 2
15364: PUSH
15365: LD_VAR 0 4
15369: PUSH
15370: FOR_IN
15371: IFFALSE 15404
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15373: LD_VAR 0 2
15377: PUSH
15378: LD_INT 1
15380: ARRAY
15381: PPUSH
15382: LD_VAR 0 2
15386: PUSH
15387: LD_INT 2
15389: ARRAY
15390: PPUSH
15391: LD_INT 1
15393: PPUSH
15394: LD_INT 9
15396: NEG
15397: PPUSH
15398: CALL_OW 330
15402: GO 15370
15404: POP
15405: POP
// SetAchievement ( ACH_FRIEND ) ;
15406: LD_STRING ACH_FRIEND
15408: PPUSH
15409: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15413: LD_INT 129
15415: PPUSH
15416: LD_INT 10
15418: PPUSH
15419: CALL_OW 84
// end ;
15423: PPOPN 5
15425: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15426: LD_EXP 15
15430: PUSH
15431: LD_INT 21000
15433: MINUS
15434: PUSH
15435: LD_OWVAR 1
15439: LESSEQUAL
15440: IFFALSE 15480
15442: GO 15444
15444: DISABLE
// begin powell_warn := true ;
15445: LD_ADDR_EXP 16
15449: PUSH
15450: LD_INT 1
15452: ST_TO_ADDR
// DialogueOn ;
15453: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15457: LD_EXP 30
15461: PPUSH
15462: LD_STRING D9-Pow-1
15464: PPUSH
15465: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15469: LD_INT 10
15471: PPUSH
15472: CALL_OW 68
// DialogueOff ;
15476: CALL_OW 7
// end ;
15480: END
// every 0 0$1 trigger game_time <= tick do
15481: LD_EXP 15
15485: PUSH
15486: LD_OWVAR 1
15490: LESSEQUAL
15491: IFFALSE 15530
15493: GO 15495
15495: DISABLE
// begin DialogueOn ;
15496: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15500: LD_EXP 30
15504: PPUSH
15505: LD_STRING D9a-Pow-1
15507: PPUSH
15508: CALL_OW 94
// dwait ( 0 0$2 ) ;
15512: LD_INT 70
15514: PPUSH
15515: CALL_OW 68
// DialogueOff ;
15519: CALL_OW 7
// YouLost ( Command ) ;
15523: LD_STRING Command
15525: PPUSH
15526: CALL_OW 104
// end ;
15530: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15531: LD_INT 22
15533: PUSH
15534: LD_INT 2
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: LD_INT 30
15543: PUSH
15544: LD_INT 1
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PUSH
15551: EMPTY
15552: LIST
15553: LIST
15554: PPUSH
15555: CALL_OW 69
15559: PUSH
15560: LD_INT 0
15562: EQUAL
15563: PUSH
15564: LD_EXP 21
15568: PPUSH
15569: CALL_OW 302
15573: AND
15574: IFFALSE 15622
15576: GO 15578
15578: DISABLE
// begin case Query ( QEndMission ) of 1 :
15579: LD_STRING QEndMission
15581: PPUSH
15582: CALL_OW 97
15586: PUSH
15587: LD_INT 1
15589: DOUBLE
15590: EQUAL
15591: IFTRUE 15595
15593: GO 15606
15595: POP
// end_the_mission_allowed := true ; 2 :
15596: LD_ADDR_OWVAR 57
15600: PUSH
15601: LD_INT 1
15603: ST_TO_ADDR
15604: GO 15622
15606: LD_INT 2
15608: DOUBLE
15609: EQUAL
15610: IFTRUE 15614
15612: GO 15621
15614: POP
// EndMission ; end ;
15615: CALL 15630 0 0
15619: GO 15622
15621: POP
// end ;
15622: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15623: CALL 15630 0 0
// end ;
15627: PPOPN 1
15629: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15630: LD_INT 0
15632: PPUSH
15633: PPUSH
15634: PPUSH
15635: PPUSH
15636: PPUSH
// m1 := false ;
15637: LD_ADDR_VAR 0 3
15641: PUSH
15642: LD_INT 0
15644: ST_TO_ADDR
// m2 := false ;
15645: LD_ADDR_VAR 0 4
15649: PUSH
15650: LD_INT 0
15652: ST_TO_ADDR
// m3 := false ;
15653: LD_ADDR_VAR 0 5
15657: PUSH
15658: LD_INT 0
15660: ST_TO_ADDR
// if not am_veh_consturcted then
15661: LD_EXP 20
15665: NOT
15666: IFFALSE 15675
// SetAchievement ( ACH_ARABTECH ) ;
15668: LD_STRING ACH_ARABTECH
15670: PPUSH
15671: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15675: LD_OWVAR 1
15679: PUSH
15680: LD_INT 252000
15682: PUSH
15683: LD_INT 210000
15685: PUSH
15686: LD_INT 199500
15688: PUSH
15689: LD_INT 193200
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: PUSH
15698: LD_OWVAR 67
15702: ARRAY
15703: LESS
15704: IFFALSE 15726
// begin m3 := true ;
15706: LD_ADDR_VAR 0 5
15710: PUSH
15711: LD_INT 1
15713: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15714: LD_STRING Time1
15716: PPUSH
15717: LD_INT 1
15719: PPUSH
15720: CALL_OW 101
// end else
15724: GO 15757
// if not powell_warn then
15726: LD_EXP 16
15730: NOT
15731: IFFALSE 15746
// AddMedal ( Time1 , - 1 ) else
15733: LD_STRING Time1
15735: PPUSH
15736: LD_INT 1
15738: NEG
15739: PPUSH
15740: CALL_OW 101
15744: GO 15757
// AddMedal ( Time1 , - 2 ) ;
15746: LD_STRING Time1
15748: PPUSH
15749: LD_INT 2
15751: NEG
15752: PPUSH
15753: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15757: LD_EXP 17
15761: PUSH
15762: LD_INT 5
15764: PUSH
15765: LD_INT 4
15767: PUSH
15768: LD_INT 3
15770: PUSH
15771: LD_INT 3
15773: PUSH
15774: EMPTY
15775: LIST
15776: LIST
15777: LIST
15778: LIST
15779: PUSH
15780: LD_OWVAR 67
15784: ARRAY
15785: GREATEREQUAL
15786: IFFALSE 15801
// AddMedal ( Destroy , - 2 ) else
15788: LD_STRING Destroy
15790: PPUSH
15791: LD_INT 2
15793: NEG
15794: PPUSH
15795: CALL_OW 101
15799: GO 15934
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15801: LD_INT 22
15803: PUSH
15804: LD_INT 2
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 21
15813: PUSH
15814: LD_INT 3
15816: PUSH
15817: EMPTY
15818: LIST
15819: LIST
15820: PUSH
15821: LD_INT 50
15823: PUSH
15824: EMPTY
15825: LIST
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: LIST
15831: PPUSH
15832: CALL_OW 69
15836: PUSH
15837: LD_INT 25
15839: GREATEREQUAL
15840: IFFALSE 15855
// AddMedal ( Destroy , - 1 ) else
15842: LD_STRING Destroy
15844: PPUSH
15845: LD_INT 1
15847: NEG
15848: PPUSH
15849: CALL_OW 101
15853: GO 15934
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15855: LD_INT 22
15857: PUSH
15858: LD_INT 2
15860: PUSH
15861: EMPTY
15862: LIST
15863: LIST
15864: PUSH
15865: LD_INT 21
15867: PUSH
15868: LD_INT 3
15870: PUSH
15871: EMPTY
15872: LIST
15873: LIST
15874: PUSH
15875: LD_INT 50
15877: PUSH
15878: EMPTY
15879: LIST
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: PPUSH
15886: CALL_OW 69
15890: PUSH
15891: LD_INT 15
15893: GREATEREQUAL
15894: IFFALSE 15916
// begin m1 := true ;
15896: LD_ADDR_VAR 0 3
15900: PUSH
15901: LD_INT 1
15903: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15904: LD_STRING Destroy
15906: PPUSH
15907: LD_INT 1
15909: PPUSH
15910: CALL_OW 101
// end else
15914: GO 15934
// begin m1 := true ;
15916: LD_ADDR_VAR 0 3
15920: PUSH
15921: LD_INT 1
15923: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15924: LD_STRING Destroy
15926: PPUSH
15927: LD_INT 2
15929: PPUSH
15930: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15934: LD_EXP 13
15938: PPUSH
15939: LD_STRING 11_artifact_captured
15941: PPUSH
15942: CALL_OW 39
// if artifact_get then
15946: LD_EXP 13
15950: IFFALSE 15972
// begin m2 := true ;
15952: LD_ADDR_VAR 0 4
15956: PUSH
15957: LD_INT 1
15959: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15960: LD_STRING Artefact
15962: PPUSH
15963: LD_INT 1
15965: PPUSH
15966: CALL_OW 101
// end else
15970: GO 15983
// AddMedal ( Artefact , - 1 ) ;
15972: LD_STRING Artefact
15974: PPUSH
15975: LD_INT 1
15977: NEG
15978: PPUSH
15979: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15983: LD_VAR 0 3
15987: PUSH
15988: LD_VAR 0 4
15992: AND
15993: PUSH
15994: LD_VAR 0 5
15998: AND
15999: PUSH
16000: LD_OWVAR 67
16004: PUSH
16005: LD_INT 3
16007: GREATEREQUAL
16008: AND
16009: IFFALSE 16021
// SetAchievementEX ( ACH_AMER , 11 ) ;
16011: LD_STRING ACH_AMER
16013: PPUSH
16014: LD_INT 11
16016: PPUSH
16017: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16021: LD_VAR 0 3
16025: PUSH
16026: LD_VAR 0 4
16030: AND
16031: PUSH
16032: LD_VAR 0 5
16036: AND
16037: PUSH
16038: LD_EXP 17
16042: PUSH
16043: LD_INT 0
16045: EQUAL
16046: AND
16047: IFFALSE 16063
// begin wait ( 3 ) ;
16049: LD_INT 3
16051: PPUSH
16052: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16056: LD_STRING ACH_GENERAL
16058: PPUSH
16059: CALL_OW 543
// end ; if tick <= 100 100$00 then
16063: LD_OWVAR 1
16067: PUSH
16068: LD_INT 210000
16070: LESSEQUAL
16071: IFFALSE 16087
// begin wait ( 3 ) ;
16073: LD_INT 3
16075: PPUSH
16076: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16080: LD_STRING ACH_ASPEED_11
16082: PPUSH
16083: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16087: LD_STRING MAIN
16089: PPUSH
16090: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16094: LD_ADDR_EXP 19
16098: PUSH
16099: LD_EXP 19
16103: PPUSH
16104: LD_INT 51
16106: PUSH
16107: EMPTY
16108: LIST
16109: PPUSH
16110: CALL_OW 72
16114: ST_TO_ADDR
// tmp := JMM ^ selected ;
16115: LD_ADDR_VAR 0 2
16119: PUSH
16120: LD_EXP 21
16124: PUSH
16125: LD_EXP 19
16129: ADD
16130: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16131: LD_VAR 0 2
16135: PPUSH
16136: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16140: LD_VAR 0 2
16144: PUSH
16145: LD_EXP 21
16149: PUSH
16150: LD_EXP 22
16154: PUSH
16155: LD_EXP 23
16159: PUSH
16160: LD_EXP 24
16164: PUSH
16165: LD_EXP 25
16169: PUSH
16170: LD_EXP 26
16174: PUSH
16175: LD_EXP 27
16179: PUSH
16180: LD_EXP 28
16184: PUSH
16185: LD_EXP 29
16189: PUSH
16190: LD_EXP 31
16194: PUSH
16195: LD_EXP 32
16199: PUSH
16200: LD_EXP 33
16204: PUSH
16205: LD_EXP 34
16209: PUSH
16210: EMPTY
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: DIFF
16225: PPUSH
16226: LD_STRING 11c_others
16228: PPUSH
16229: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16233: LD_EXP 21
16237: PPUSH
16238: LD_EXP 3
16242: PUSH
16243: LD_STRING JMM
16245: STR
16246: PPUSH
16247: CALL_OW 38
// if Lisa then
16251: LD_EXP 22
16255: IFFALSE 16275
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16257: LD_EXP 22
16261: PPUSH
16262: LD_EXP 3
16266: PUSH
16267: LD_STRING Lisa
16269: STR
16270: PPUSH
16271: CALL_OW 38
// if Donaldson then
16275: LD_EXP 23
16279: IFFALSE 16299
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16281: LD_EXP 23
16285: PPUSH
16286: LD_EXP 3
16290: PUSH
16291: LD_STRING Donaldson
16293: STR
16294: PPUSH
16295: CALL_OW 38
// if Bobby then
16299: LD_EXP 24
16303: IFFALSE 16323
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16305: LD_EXP 24
16309: PPUSH
16310: LD_EXP 3
16314: PUSH
16315: LD_STRING Bobby
16317: STR
16318: PPUSH
16319: CALL_OW 38
// if Cyrus then
16323: LD_EXP 25
16327: IFFALSE 16347
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16329: LD_EXP 25
16333: PPUSH
16334: LD_EXP 3
16338: PUSH
16339: LD_STRING Cyrus
16341: STR
16342: PPUSH
16343: CALL_OW 38
// if Denis then
16347: LD_EXP 26
16351: IFFALSE 16371
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16353: LD_EXP 26
16357: PPUSH
16358: LD_EXP 3
16362: PUSH
16363: LD_STRING Denis
16365: STR
16366: PPUSH
16367: CALL_OW 38
// if Brown then
16371: LD_EXP 27
16375: IFFALSE 16395
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16377: LD_EXP 27
16381: PPUSH
16382: LD_EXP 3
16386: PUSH
16387: LD_STRING Brown
16389: STR
16390: PPUSH
16391: CALL_OW 38
// if Gladstone then
16395: LD_EXP 28
16399: IFFALSE 16419
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16401: LD_EXP 28
16405: PPUSH
16406: LD_EXP 3
16410: PUSH
16411: LD_STRING Gladstone
16413: STR
16414: PPUSH
16415: CALL_OW 38
// if Houten then
16419: LD_EXP 29
16423: IFFALSE 16443
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16425: LD_EXP 29
16429: PPUSH
16430: LD_EXP 3
16434: PUSH
16435: LD_STRING Houten
16437: STR
16438: PPUSH
16439: CALL_OW 38
// if Cornel then
16443: LD_EXP 31
16447: IFFALSE 16467
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16449: LD_EXP 31
16453: PPUSH
16454: LD_EXP 3
16458: PUSH
16459: LD_STRING Cornell
16461: STR
16462: PPUSH
16463: CALL_OW 38
// if Gary then
16467: LD_EXP 32
16471: IFFALSE 16491
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16473: LD_EXP 32
16477: PPUSH
16478: LD_EXP 3
16482: PUSH
16483: LD_STRING Gary
16485: STR
16486: PPUSH
16487: CALL_OW 38
// if Frank then
16491: LD_EXP 33
16495: IFFALSE 16515
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16497: LD_EXP 33
16501: PPUSH
16502: LD_EXP 3
16506: PUSH
16507: LD_STRING Frank
16509: STR
16510: PPUSH
16511: CALL_OW 38
// if Kikuchi then
16515: LD_EXP 34
16519: IFFALSE 16539
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16521: LD_EXP 34
16525: PPUSH
16526: LD_EXP 3
16530: PUSH
16531: LD_STRING Kikuchi
16533: STR
16534: PPUSH
16535: CALL_OW 38
// YouWin ;
16539: CALL_OW 103
// end ;
16543: LD_VAR 0 1
16547: RET
// export function CanSayRand ( side ) ; begin
16548: LD_INT 0
16550: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16551: LD_ADDR_VAR 0 2
16555: PUSH
16556: LD_INT 52
16558: PUSH
16559: EMPTY
16560: LIST
16561: PUSH
16562: LD_INT 22
16564: PUSH
16565: LD_VAR 0 1
16569: PUSH
16570: EMPTY
16571: LIST
16572: LIST
16573: PUSH
16574: LD_INT 2
16576: PUSH
16577: LD_INT 25
16579: PUSH
16580: LD_INT 1
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: PUSH
16587: LD_INT 25
16589: PUSH
16590: LD_INT 2
16592: PUSH
16593: EMPTY
16594: LIST
16595: LIST
16596: PUSH
16597: LD_INT 25
16599: PUSH
16600: LD_INT 3
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: PUSH
16607: LD_INT 25
16609: PUSH
16610: LD_INT 4
16612: PUSH
16613: EMPTY
16614: LIST
16615: LIST
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: LIST
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL_OW 69
16633: PUSH
16634: LD_EXP 21
16638: PUSH
16639: LD_EXP 33
16643: PUSH
16644: LD_EXP 22
16648: PUSH
16649: LD_EXP 23
16653: PUSH
16654: LD_EXP 24
16658: PUSH
16659: LD_EXP 25
16663: PUSH
16664: LD_EXP 26
16668: PUSH
16669: LD_EXP 27
16673: PUSH
16674: LD_EXP 28
16678: PUSH
16679: LD_EXP 29
16683: PUSH
16684: LD_EXP 30
16688: PUSH
16689: LD_EXP 31
16693: PUSH
16694: LD_EXP 32
16698: PUSH
16699: LD_EXP 34
16703: PUSH
16704: EMPTY
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: DIFF
16720: ST_TO_ADDR
// end ;
16721: LD_VAR 0 2
16725: RET
// export function SayRand ( sex , dial ) ; begin
16726: LD_INT 0
16728: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: LD_INT 52
16736: PUSH
16737: EMPTY
16738: LIST
16739: PUSH
16740: LD_INT 22
16742: PUSH
16743: LD_INT 1
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: PUSH
16750: LD_INT 26
16752: PUSH
16753: LD_VAR 0 1
16757: PUSH
16758: EMPTY
16759: LIST
16760: LIST
16761: PUSH
16762: LD_INT 2
16764: PUSH
16765: LD_INT 25
16767: PUSH
16768: LD_INT 1
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: PUSH
16775: LD_INT 25
16777: PUSH
16778: LD_INT 2
16780: PUSH
16781: EMPTY
16782: LIST
16783: LIST
16784: PUSH
16785: LD_INT 25
16787: PUSH
16788: LD_INT 3
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 25
16797: PUSH
16798: LD_INT 4
16800: PUSH
16801: EMPTY
16802: LIST
16803: LIST
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: LIST
16809: LIST
16810: LIST
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: LIST
16816: LIST
16817: PPUSH
16818: CALL_OW 69
16822: PUSH
16823: LD_EXP 21
16827: PUSH
16828: LD_EXP 33
16832: PUSH
16833: LD_EXP 22
16837: PUSH
16838: LD_EXP 23
16842: PUSH
16843: LD_EXP 24
16847: PUSH
16848: LD_EXP 25
16852: PUSH
16853: LD_EXP 26
16857: PUSH
16858: LD_EXP 27
16862: PUSH
16863: LD_EXP 28
16867: PUSH
16868: LD_EXP 29
16872: PUSH
16873: LD_EXP 30
16877: PUSH
16878: LD_EXP 31
16882: PUSH
16883: LD_EXP 32
16887: PUSH
16888: LD_EXP 34
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: LIST
16903: LIST
16904: LIST
16905: LIST
16906: LIST
16907: LIST
16908: DIFF
16909: ST_TO_ADDR
// if not result then
16910: LD_VAR 0 3
16914: NOT
16915: IFFALSE 16919
// exit ;
16917: GO 16947
// result := result [ 1 ] ;
16919: LD_ADDR_VAR 0 3
16923: PUSH
16924: LD_VAR 0 3
16928: PUSH
16929: LD_INT 1
16931: ARRAY
16932: ST_TO_ADDR
// Say ( result , dial ) ;
16933: LD_VAR 0 3
16937: PPUSH
16938: LD_VAR 0 2
16942: PPUSH
16943: CALL_OW 88
// end ;
16947: LD_VAR 0 3
16951: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16952: LD_INT 0
16954: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16955: LD_ADDR_VAR 0 4
16959: PUSH
16960: LD_INT 22
16962: PUSH
16963: LD_INT 1
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: PUSH
16970: LD_INT 26
16972: PUSH
16973: LD_VAR 0 1
16977: PUSH
16978: EMPTY
16979: LIST
16980: LIST
16981: PUSH
16982: LD_INT 2
16984: PUSH
16985: LD_INT 25
16987: PUSH
16988: LD_INT 1
16990: PUSH
16991: EMPTY
16992: LIST
16993: LIST
16994: PUSH
16995: LD_INT 25
16997: PUSH
16998: LD_INT 2
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: LD_INT 25
17007: PUSH
17008: LD_INT 3
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: PUSH
17015: LD_INT 25
17017: PUSH
17018: LD_INT 4
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PUSH
17025: EMPTY
17026: LIST
17027: LIST
17028: LIST
17029: LIST
17030: LIST
17031: PUSH
17032: EMPTY
17033: LIST
17034: LIST
17035: LIST
17036: PPUSH
17037: CALL_OW 69
17041: PUSH
17042: LD_EXP 21
17046: PUSH
17047: LD_EXP 33
17051: PUSH
17052: LD_EXP 22
17056: PUSH
17057: LD_EXP 23
17061: PUSH
17062: LD_EXP 24
17066: PUSH
17067: LD_EXP 25
17071: PUSH
17072: LD_EXP 26
17076: PUSH
17077: LD_EXP 27
17081: PUSH
17082: LD_EXP 28
17086: PUSH
17087: LD_EXP 29
17091: PUSH
17092: LD_EXP 30
17096: PUSH
17097: LD_EXP 31
17101: PUSH
17102: LD_EXP 32
17106: PUSH
17107: LD_EXP 34
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: PUSH
17128: LD_VAR 0 3
17132: ADD
17133: DIFF
17134: ST_TO_ADDR
// if not result then
17135: LD_VAR 0 4
17139: NOT
17140: IFFALSE 17144
// exit ;
17142: GO 17172
// result := result [ 1 ] ;
17144: LD_ADDR_VAR 0 4
17148: PUSH
17149: LD_VAR 0 4
17153: PUSH
17154: LD_INT 1
17156: ARRAY
17157: ST_TO_ADDR
// Say ( result , dial ) ;
17158: LD_VAR 0 4
17162: PPUSH
17163: LD_VAR 0 2
17167: PPUSH
17168: CALL_OW 88
// end ; end_of_file
17172: LD_VAR 0 4
17176: RET
// export function CustomEvent ( event ) ; begin
17177: LD_INT 0
17179: PPUSH
// end ;
17180: LD_VAR 0 2
17184: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL_OW 255
17194: PUSH
17195: LD_INT 1
17197: EQUAL
17198: IFFALSE 17208
// artifact_get := true ;
17200: LD_ADDR_EXP 13
17204: PUSH
17205: LD_INT 1
17207: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17208: LD_VAR 0 1
17212: PPUSH
17213: CALL_OW 255
17217: PUSH
17218: LD_INT 2
17220: EQUAL
17221: IFFALSE 17239
// begin artifact_get := false ;
17223: LD_ADDR_EXP 13
17227: PUSH
17228: LD_INT 0
17230: ST_TO_ADDR
// artifact_stolen := true ;
17231: LD_ADDR_EXP 12
17235: PUSH
17236: LD_INT 1
17238: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17239: LD_ADDR_EXP 14
17243: PUSH
17244: LD_INT 1
17246: ST_TO_ADDR
// end ;
17247: PPOPN 2
17249: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17250: LD_ADDR_EXP 14
17254: PUSH
17255: LD_INT 0
17257: ST_TO_ADDR
// end ;
17258: PPOPN 2
17260: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17261: LD_VAR 0 1
17265: PPUSH
17266: CALL 105672 0 1
// if un = JMM then
17270: LD_VAR 0 1
17274: PUSH
17275: LD_EXP 21
17279: EQUAL
17280: IFFALSE 17291
// begin YouLost ( JMM ) ;
17282: LD_STRING JMM
17284: PPUSH
17285: CALL_OW 104
// exit ;
17289: GO 17423
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17291: LD_VAR 0 1
17295: PUSH
17296: LD_INT 22
17298: PUSH
17299: LD_INT 1
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PUSH
17306: LD_INT 21
17308: PUSH
17309: LD_INT 1
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PUSH
17316: LD_INT 2
17318: PUSH
17319: LD_INT 25
17321: PUSH
17322: LD_INT 1
17324: PUSH
17325: EMPTY
17326: LIST
17327: LIST
17328: PUSH
17329: LD_INT 25
17331: PUSH
17332: LD_INT 2
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: PUSH
17339: LD_INT 25
17341: PUSH
17342: LD_INT 3
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: PUSH
17349: LD_INT 25
17351: PUSH
17352: LD_INT 4
17354: PUSH
17355: EMPTY
17356: LIST
17357: LIST
17358: PUSH
17359: LD_INT 25
17361: PUSH
17362: LD_INT 5
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: PUSH
17369: LD_INT 25
17371: PUSH
17372: LD_INT 8
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: PUSH
17388: EMPTY
17389: LIST
17390: LIST
17391: LIST
17392: PPUSH
17393: CALL_OW 69
17397: IN
17398: IFFALSE 17414
// loses_counter := loses_counter + 1 ;
17400: LD_ADDR_EXP 17
17404: PUSH
17405: LD_EXP 17
17409: PUSH
17410: LD_INT 1
17412: PLUS
17413: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17414: LD_VAR 0 1
17418: PPUSH
17419: CALL 45671 0 1
// end ;
17423: PPOPN 1
17425: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17426: LD_VAR 0 1
17430: PPUSH
17431: LD_VAR 0 2
17435: PPUSH
17436: CALL 48003 0 2
// end ;
17440: PPOPN 2
17442: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17443: LD_VAR 0 1
17447: PPUSH
17448: CALL 47312 0 1
// end ;
17452: PPOPN 1
17454: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17455: LD_VAR 0 1
17459: PPUSH
17460: LD_VAR 0 2
17464: PPUSH
17465: LD_VAR 0 3
17469: PPUSH
17470: LD_VAR 0 4
17474: PPUSH
17475: LD_VAR 0 5
17479: PPUSH
17480: CALL 44987 0 5
// end ;
17484: PPOPN 5
17486: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17487: LD_VAR 0 1
17491: PPUSH
17492: LD_VAR 0 2
17496: PPUSH
17497: CALL 105792 0 2
// if GetNation ( vehicle ) = nation_american then
17501: LD_VAR 0 1
17505: PPUSH
17506: CALL_OW 248
17510: PUSH
17511: LD_INT 1
17513: EQUAL
17514: IFFALSE 17524
// am_veh_consturcted := true ;
17516: LD_ADDR_EXP 20
17520: PUSH
17521: LD_INT 1
17523: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17524: LD_VAR 0 1
17528: PPUSH
17529: LD_VAR 0 2
17533: PPUSH
17534: CALL 44578 0 2
// end ;
17538: PPOPN 2
17540: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17541: LD_VAR 0 1
17545: PPUSH
17546: CALL_OW 247
17550: PUSH
17551: LD_INT 2
17553: EQUAL
17554: IFFALSE 17558
// exit ;
17556: GO 17575
// if not kamikazed then
17558: LD_EXP 11
17562: NOT
17563: IFFALSE 17575
// kamikazed := unit ;
17565: LD_ADDR_EXP 11
17569: PUSH
17570: LD_VAR 0 1
17574: ST_TO_ADDR
// end ;
17575: PPOPN 1
17577: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17578: LD_INT 0
17580: PPUSH
17581: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17582: LD_VAR 0 1
17586: PPUSH
17587: LD_VAR 0 2
17591: PPUSH
17592: LD_VAR 0 3
17596: PPUSH
17597: LD_VAR 0 4
17601: PPUSH
17602: CALL 44416 0 4
// end ;
17606: PPOPN 6
17608: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17609: LD_VAR 0 1
17613: PPUSH
17614: LD_VAR 0 2
17618: PPUSH
17619: LD_VAR 0 3
17623: PPUSH
17624: CALL 44191 0 3
// end ;
17628: PPOPN 3
17630: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17631: LD_VAR 0 1
17635: PPUSH
17636: LD_VAR 0 2
17640: PPUSH
17641: CALL 45367 0 2
// end ;
17645: PPOPN 2
17647: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17648: LD_VAR 0 1
17652: PPUSH
17653: LD_VAR 0 2
17657: PPUSH
17658: CALL 43885 0 2
// end ;
17662: PPOPN 2
17664: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17665: LD_VAR 0 1
17669: PPUSH
17670: LD_VAR 0 2
17674: PPUSH
17675: CALL 44076 0 2
// end ;
17679: PPOPN 2
17681: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17682: LD_VAR 0 1
17686: PPUSH
17687: CALL 47071 0 1
// end ;
17691: PPOPN 1
17693: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17694: LD_VAR 0 1
17698: PPUSH
17699: LD_VAR 0 2
17703: PPUSH
17704: CALL 48298 0 2
// end ;
17708: PPOPN 2
17710: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17711: LD_VAR 0 1
17715: PPUSH
17716: LD_VAR 0 2
17720: PPUSH
17721: LD_VAR 0 3
17725: PPUSH
17726: LD_VAR 0 4
17730: PPUSH
17731: CALL 48514 0 4
// end ;
17735: PPOPN 4
17737: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17738: LD_VAR 0 1
17742: PPUSH
17743: CALL 105776 0 1
// end ; end_of_file
17747: PPOPN 1
17749: END
// every 0 0$1 trigger game do
17750: LD_EXP 2
17754: IFFALSE 17784
17756: GO 17758
17758: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17759: LD_INT 7
17761: PUSH
17762: LD_INT 6
17764: PUSH
17765: LD_INT 4
17767: PUSH
17768: LD_INT 6
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: PPUSH
17777: LD_INT 1750
17779: PPUSH
17780: CALL 17785 0 2
17784: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17785: LD_INT 0
17787: PPUSH
17788: PPUSH
17789: PPUSH
// if not areas then
17790: LD_VAR 0 1
17794: NOT
17795: IFFALSE 17799
// exit ;
17797: GO 17929
// repeat wait ( time ) ;
17799: LD_VAR 0 2
17803: PPUSH
17804: CALL_OW 67
// for i in areas do
17808: LD_ADDR_VAR 0 4
17812: PUSH
17813: LD_VAR 0 1
17817: PUSH
17818: FOR_IN
17819: IFFALSE 17888
// begin p := rand ( 1 , 90 ) ;
17821: LD_ADDR_VAR 0 5
17825: PUSH
17826: LD_INT 1
17828: PPUSH
17829: LD_INT 90
17831: PPUSH
17832: CALL_OW 12
17836: ST_TO_ADDR
// if Prob ( p ) then
17837: LD_VAR 0 5
17841: PPUSH
17842: CALL_OW 13
17846: IFFALSE 17886
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17848: LD_INT 2
17850: PPUSH
17851: LD_INT 5
17853: PPUSH
17854: CALL_OW 12
17858: PPUSH
17859: LD_VAR 0 4
17863: PPUSH
17864: LD_INT 1
17866: PPUSH
17867: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17871: LD_INT 735
17873: PPUSH
17874: LD_INT 1295
17876: PPUSH
17877: CALL_OW 12
17881: PPUSH
17882: CALL_OW 67
// end ; end ;
17886: GO 17818
17888: POP
17889: POP
// time := time + 0 0$3 ;
17890: LD_ADDR_VAR 0 2
17894: PUSH
17895: LD_VAR 0 2
17899: PUSH
17900: LD_INT 105
17902: PLUS
17903: ST_TO_ADDR
// if time > 6 6$00 then
17904: LD_VAR 0 2
17908: PUSH
17909: LD_INT 12600
17911: GREATER
17912: IFFALSE 17922
// time := 0 0$40 ;
17914: LD_ADDR_VAR 0 2
17918: PUSH
17919: LD_INT 1400
17921: ST_TO_ADDR
// until not game ;
17922: LD_EXP 2
17926: NOT
17927: IFFALSE 17799
// end ;
17929: LD_VAR 0 3
17933: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17934: LD_OWVAR 1
17938: PUSH
17939: LD_INT 84000
17941: PUSH
17942: LD_INT 73500
17944: PUSH
17945: LD_INT 63000
17947: PUSH
17948: LD_INT 52500
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: PUSH
17957: LD_OWVAR 67
17961: ARRAY
17962: LESS
17963: IFFALSE 17990
17965: GO 17967
17967: DISABLE
// begin enable ;
17968: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17969: LD_INT 1
17971: PPUSH
17972: LD_INT 5
17974: PPUSH
17975: CALL_OW 12
17979: PPUSH
17980: LD_INT 7
17982: PPUSH
17983: LD_INT 1
17985: PPUSH
17986: CALL_OW 55
// end ; end_of_file
17990: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// skirmish := false ;
17995: LD_ADDR_EXP 48
17999: PUSH
18000: LD_INT 0
18002: ST_TO_ADDR
// debug_mc := false ;
18003: LD_ADDR_EXP 49
18007: PUSH
18008: LD_INT 0
18010: ST_TO_ADDR
// mc_bases := [ ] ;
18011: LD_ADDR_EXP 50
18015: PUSH
18016: EMPTY
18017: ST_TO_ADDR
// mc_sides := [ ] ;
18018: LD_ADDR_EXP 76
18022: PUSH
18023: EMPTY
18024: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18025: LD_ADDR_EXP 51
18029: PUSH
18030: EMPTY
18031: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18032: LD_ADDR_EXP 52
18036: PUSH
18037: EMPTY
18038: ST_TO_ADDR
// mc_need_heal := [ ] ;
18039: LD_ADDR_EXP 53
18043: PUSH
18044: EMPTY
18045: ST_TO_ADDR
// mc_healers := [ ] ;
18046: LD_ADDR_EXP 54
18050: PUSH
18051: EMPTY
18052: ST_TO_ADDR
// mc_build_list := [ ] ;
18053: LD_ADDR_EXP 55
18057: PUSH
18058: EMPTY
18059: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18060: LD_ADDR_EXP 82
18064: PUSH
18065: EMPTY
18066: ST_TO_ADDR
// mc_builders := [ ] ;
18067: LD_ADDR_EXP 56
18071: PUSH
18072: EMPTY
18073: ST_TO_ADDR
// mc_construct_list := [ ] ;
18074: LD_ADDR_EXP 57
18078: PUSH
18079: EMPTY
18080: ST_TO_ADDR
// mc_turret_list := [ ] ;
18081: LD_ADDR_EXP 58
18085: PUSH
18086: EMPTY
18087: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18088: LD_ADDR_EXP 59
18092: PUSH
18093: EMPTY
18094: ST_TO_ADDR
// mc_miners := [ ] ;
18095: LD_ADDR_EXP 64
18099: PUSH
18100: EMPTY
18101: ST_TO_ADDR
// mc_mines := [ ] ;
18102: LD_ADDR_EXP 63
18106: PUSH
18107: EMPTY
18108: ST_TO_ADDR
// mc_minefields := [ ] ;
18109: LD_ADDR_EXP 65
18113: PUSH
18114: EMPTY
18115: ST_TO_ADDR
// mc_crates := [ ] ;
18116: LD_ADDR_EXP 66
18120: PUSH
18121: EMPTY
18122: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18123: LD_ADDR_EXP 67
18127: PUSH
18128: EMPTY
18129: ST_TO_ADDR
// mc_crates_area := [ ] ;
18130: LD_ADDR_EXP 68
18134: PUSH
18135: EMPTY
18136: ST_TO_ADDR
// mc_vehicles := [ ] ;
18137: LD_ADDR_EXP 69
18141: PUSH
18142: EMPTY
18143: ST_TO_ADDR
// mc_attack := [ ] ;
18144: LD_ADDR_EXP 70
18148: PUSH
18149: EMPTY
18150: ST_TO_ADDR
// mc_produce := [ ] ;
18151: LD_ADDR_EXP 71
18155: PUSH
18156: EMPTY
18157: ST_TO_ADDR
// mc_defender := [ ] ;
18158: LD_ADDR_EXP 72
18162: PUSH
18163: EMPTY
18164: ST_TO_ADDR
// mc_parking := [ ] ;
18165: LD_ADDR_EXP 74
18169: PUSH
18170: EMPTY
18171: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18172: LD_ADDR_EXP 60
18176: PUSH
18177: EMPTY
18178: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18179: LD_ADDR_EXP 62
18183: PUSH
18184: EMPTY
18185: ST_TO_ADDR
// mc_scan := [ ] ;
18186: LD_ADDR_EXP 73
18190: PUSH
18191: EMPTY
18192: ST_TO_ADDR
// mc_scan_area := [ ] ;
18193: LD_ADDR_EXP 75
18197: PUSH
18198: EMPTY
18199: ST_TO_ADDR
// mc_tech := [ ] ;
18200: LD_ADDR_EXP 77
18204: PUSH
18205: EMPTY
18206: ST_TO_ADDR
// mc_class := [ ] ;
18207: LD_ADDR_EXP 91
18211: PUSH
18212: EMPTY
18213: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18214: LD_ADDR_EXP 92
18218: PUSH
18219: EMPTY
18220: ST_TO_ADDR
// mc_is_defending := [ ] ;
18221: LD_ADDR_EXP 93
18225: PUSH
18226: EMPTY
18227: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18228: LD_ADDR_EXP 84
18232: PUSH
18233: EMPTY
18234: ST_TO_ADDR
// end ;
18235: LD_VAR 0 1
18239: RET
// export function MC_Kill ( base ) ; begin
18240: LD_INT 0
18242: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18243: LD_ADDR_EXP 50
18247: PUSH
18248: LD_EXP 50
18252: PPUSH
18253: LD_VAR 0 1
18257: PPUSH
18258: EMPTY
18259: PPUSH
18260: CALL_OW 1
18264: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18265: LD_ADDR_EXP 51
18269: PUSH
18270: LD_EXP 51
18274: PPUSH
18275: LD_VAR 0 1
18279: PPUSH
18280: EMPTY
18281: PPUSH
18282: CALL_OW 1
18286: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18287: LD_ADDR_EXP 52
18291: PUSH
18292: LD_EXP 52
18296: PPUSH
18297: LD_VAR 0 1
18301: PPUSH
18302: EMPTY
18303: PPUSH
18304: CALL_OW 1
18308: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18309: LD_ADDR_EXP 53
18313: PUSH
18314: LD_EXP 53
18318: PPUSH
18319: LD_VAR 0 1
18323: PPUSH
18324: EMPTY
18325: PPUSH
18326: CALL_OW 1
18330: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18331: LD_ADDR_EXP 54
18335: PUSH
18336: LD_EXP 54
18340: PPUSH
18341: LD_VAR 0 1
18345: PPUSH
18346: EMPTY
18347: PPUSH
18348: CALL_OW 1
18352: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18353: LD_ADDR_EXP 55
18357: PUSH
18358: LD_EXP 55
18362: PPUSH
18363: LD_VAR 0 1
18367: PPUSH
18368: EMPTY
18369: PPUSH
18370: CALL_OW 1
18374: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18375: LD_ADDR_EXP 56
18379: PUSH
18380: LD_EXP 56
18384: PPUSH
18385: LD_VAR 0 1
18389: PPUSH
18390: EMPTY
18391: PPUSH
18392: CALL_OW 1
18396: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18397: LD_ADDR_EXP 57
18401: PUSH
18402: LD_EXP 57
18406: PPUSH
18407: LD_VAR 0 1
18411: PPUSH
18412: EMPTY
18413: PPUSH
18414: CALL_OW 1
18418: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18419: LD_ADDR_EXP 58
18423: PUSH
18424: LD_EXP 58
18428: PPUSH
18429: LD_VAR 0 1
18433: PPUSH
18434: EMPTY
18435: PPUSH
18436: CALL_OW 1
18440: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18441: LD_ADDR_EXP 59
18445: PUSH
18446: LD_EXP 59
18450: PPUSH
18451: LD_VAR 0 1
18455: PPUSH
18456: EMPTY
18457: PPUSH
18458: CALL_OW 1
18462: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18463: LD_ADDR_EXP 60
18467: PUSH
18468: LD_EXP 60
18472: PPUSH
18473: LD_VAR 0 1
18477: PPUSH
18478: EMPTY
18479: PPUSH
18480: CALL_OW 1
18484: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18485: LD_ADDR_EXP 61
18489: PUSH
18490: LD_EXP 61
18494: PPUSH
18495: LD_VAR 0 1
18499: PPUSH
18500: LD_INT 0
18502: PPUSH
18503: CALL_OW 1
18507: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18508: LD_ADDR_EXP 62
18512: PUSH
18513: LD_EXP 62
18517: PPUSH
18518: LD_VAR 0 1
18522: PPUSH
18523: EMPTY
18524: PPUSH
18525: CALL_OW 1
18529: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18530: LD_ADDR_EXP 63
18534: PUSH
18535: LD_EXP 63
18539: PPUSH
18540: LD_VAR 0 1
18544: PPUSH
18545: EMPTY
18546: PPUSH
18547: CALL_OW 1
18551: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18552: LD_ADDR_EXP 64
18556: PUSH
18557: LD_EXP 64
18561: PPUSH
18562: LD_VAR 0 1
18566: PPUSH
18567: EMPTY
18568: PPUSH
18569: CALL_OW 1
18573: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18574: LD_ADDR_EXP 65
18578: PUSH
18579: LD_EXP 65
18583: PPUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: EMPTY
18590: PPUSH
18591: CALL_OW 1
18595: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18596: LD_ADDR_EXP 66
18600: PUSH
18601: LD_EXP 66
18605: PPUSH
18606: LD_VAR 0 1
18610: PPUSH
18611: EMPTY
18612: PPUSH
18613: CALL_OW 1
18617: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18618: LD_ADDR_EXP 67
18622: PUSH
18623: LD_EXP 67
18627: PPUSH
18628: LD_VAR 0 1
18632: PPUSH
18633: EMPTY
18634: PPUSH
18635: CALL_OW 1
18639: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18640: LD_ADDR_EXP 68
18644: PUSH
18645: LD_EXP 68
18649: PPUSH
18650: LD_VAR 0 1
18654: PPUSH
18655: EMPTY
18656: PPUSH
18657: CALL_OW 1
18661: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18662: LD_ADDR_EXP 69
18666: PUSH
18667: LD_EXP 69
18671: PPUSH
18672: LD_VAR 0 1
18676: PPUSH
18677: EMPTY
18678: PPUSH
18679: CALL_OW 1
18683: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18684: LD_ADDR_EXP 70
18688: PUSH
18689: LD_EXP 70
18693: PPUSH
18694: LD_VAR 0 1
18698: PPUSH
18699: EMPTY
18700: PPUSH
18701: CALL_OW 1
18705: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18706: LD_ADDR_EXP 71
18710: PUSH
18711: LD_EXP 71
18715: PPUSH
18716: LD_VAR 0 1
18720: PPUSH
18721: EMPTY
18722: PPUSH
18723: CALL_OW 1
18727: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18728: LD_ADDR_EXP 72
18732: PUSH
18733: LD_EXP 72
18737: PPUSH
18738: LD_VAR 0 1
18742: PPUSH
18743: EMPTY
18744: PPUSH
18745: CALL_OW 1
18749: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18750: LD_ADDR_EXP 73
18754: PUSH
18755: LD_EXP 73
18759: PPUSH
18760: LD_VAR 0 1
18764: PPUSH
18765: EMPTY
18766: PPUSH
18767: CALL_OW 1
18771: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18772: LD_ADDR_EXP 74
18776: PUSH
18777: LD_EXP 74
18781: PPUSH
18782: LD_VAR 0 1
18786: PPUSH
18787: EMPTY
18788: PPUSH
18789: CALL_OW 1
18793: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18794: LD_ADDR_EXP 75
18798: PUSH
18799: LD_EXP 75
18803: PPUSH
18804: LD_VAR 0 1
18808: PPUSH
18809: EMPTY
18810: PPUSH
18811: CALL_OW 1
18815: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18816: LD_ADDR_EXP 77
18820: PUSH
18821: LD_EXP 77
18825: PPUSH
18826: LD_VAR 0 1
18830: PPUSH
18831: EMPTY
18832: PPUSH
18833: CALL_OW 1
18837: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18838: LD_ADDR_EXP 79
18842: PUSH
18843: LD_EXP 79
18847: PPUSH
18848: LD_VAR 0 1
18852: PPUSH
18853: EMPTY
18854: PPUSH
18855: CALL_OW 1
18859: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18860: LD_ADDR_EXP 80
18864: PUSH
18865: LD_EXP 80
18869: PPUSH
18870: LD_VAR 0 1
18874: PPUSH
18875: EMPTY
18876: PPUSH
18877: CALL_OW 1
18881: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18882: LD_ADDR_EXP 81
18886: PUSH
18887: LD_EXP 81
18891: PPUSH
18892: LD_VAR 0 1
18896: PPUSH
18897: EMPTY
18898: PPUSH
18899: CALL_OW 1
18903: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18904: LD_ADDR_EXP 82
18908: PUSH
18909: LD_EXP 82
18913: PPUSH
18914: LD_VAR 0 1
18918: PPUSH
18919: EMPTY
18920: PPUSH
18921: CALL_OW 1
18925: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18926: LD_ADDR_EXP 83
18930: PUSH
18931: LD_EXP 83
18935: PPUSH
18936: LD_VAR 0 1
18940: PPUSH
18941: EMPTY
18942: PPUSH
18943: CALL_OW 1
18947: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18948: LD_ADDR_EXP 84
18952: PUSH
18953: LD_EXP 84
18957: PPUSH
18958: LD_VAR 0 1
18962: PPUSH
18963: EMPTY
18964: PPUSH
18965: CALL_OW 1
18969: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18970: LD_ADDR_EXP 85
18974: PUSH
18975: LD_EXP 85
18979: PPUSH
18980: LD_VAR 0 1
18984: PPUSH
18985: EMPTY
18986: PPUSH
18987: CALL_OW 1
18991: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18992: LD_ADDR_EXP 86
18996: PUSH
18997: LD_EXP 86
19001: PPUSH
19002: LD_VAR 0 1
19006: PPUSH
19007: EMPTY
19008: PPUSH
19009: CALL_OW 1
19013: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19014: LD_ADDR_EXP 87
19018: PUSH
19019: LD_EXP 87
19023: PPUSH
19024: LD_VAR 0 1
19028: PPUSH
19029: EMPTY
19030: PPUSH
19031: CALL_OW 1
19035: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19036: LD_ADDR_EXP 88
19040: PUSH
19041: LD_EXP 88
19045: PPUSH
19046: LD_VAR 0 1
19050: PPUSH
19051: EMPTY
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19058: LD_ADDR_EXP 89
19062: PUSH
19063: LD_EXP 89
19067: PPUSH
19068: LD_VAR 0 1
19072: PPUSH
19073: EMPTY
19074: PPUSH
19075: CALL_OW 1
19079: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19080: LD_ADDR_EXP 90
19084: PUSH
19085: LD_EXP 90
19089: PPUSH
19090: LD_VAR 0 1
19094: PPUSH
19095: EMPTY
19096: PPUSH
19097: CALL_OW 1
19101: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19102: LD_ADDR_EXP 91
19106: PUSH
19107: LD_EXP 91
19111: PPUSH
19112: LD_VAR 0 1
19116: PPUSH
19117: EMPTY
19118: PPUSH
19119: CALL_OW 1
19123: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19124: LD_ADDR_EXP 92
19128: PUSH
19129: LD_EXP 92
19133: PPUSH
19134: LD_VAR 0 1
19138: PPUSH
19139: LD_INT 0
19141: PPUSH
19142: CALL_OW 1
19146: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19147: LD_ADDR_EXP 93
19151: PUSH
19152: LD_EXP 93
19156: PPUSH
19157: LD_VAR 0 1
19161: PPUSH
19162: LD_INT 0
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// end ;
19170: LD_VAR 0 2
19174: RET
// export function MC_Add ( side , units ) ; var base ; begin
19175: LD_INT 0
19177: PPUSH
19178: PPUSH
// base := mc_bases + 1 ;
19179: LD_ADDR_VAR 0 4
19183: PUSH
19184: LD_EXP 50
19188: PUSH
19189: LD_INT 1
19191: PLUS
19192: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19193: LD_ADDR_EXP 76
19197: PUSH
19198: LD_EXP 76
19202: PPUSH
19203: LD_VAR 0 4
19207: PPUSH
19208: LD_VAR 0 1
19212: PPUSH
19213: CALL_OW 1
19217: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19218: LD_ADDR_EXP 50
19222: PUSH
19223: LD_EXP 50
19227: PPUSH
19228: LD_VAR 0 4
19232: PPUSH
19233: LD_VAR 0 2
19237: PPUSH
19238: CALL_OW 1
19242: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19243: LD_ADDR_EXP 51
19247: PUSH
19248: LD_EXP 51
19252: PPUSH
19253: LD_VAR 0 4
19257: PPUSH
19258: EMPTY
19259: PPUSH
19260: CALL_OW 1
19264: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19265: LD_ADDR_EXP 52
19269: PUSH
19270: LD_EXP 52
19274: PPUSH
19275: LD_VAR 0 4
19279: PPUSH
19280: EMPTY
19281: PPUSH
19282: CALL_OW 1
19286: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19287: LD_ADDR_EXP 53
19291: PUSH
19292: LD_EXP 53
19296: PPUSH
19297: LD_VAR 0 4
19301: PPUSH
19302: EMPTY
19303: PPUSH
19304: CALL_OW 1
19308: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19309: LD_ADDR_EXP 54
19313: PUSH
19314: LD_EXP 54
19318: PPUSH
19319: LD_VAR 0 4
19323: PPUSH
19324: EMPTY
19325: PPUSH
19326: CALL_OW 1
19330: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19331: LD_ADDR_EXP 55
19335: PUSH
19336: LD_EXP 55
19340: PPUSH
19341: LD_VAR 0 4
19345: PPUSH
19346: EMPTY
19347: PPUSH
19348: CALL_OW 1
19352: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19353: LD_ADDR_EXP 56
19357: PUSH
19358: LD_EXP 56
19362: PPUSH
19363: LD_VAR 0 4
19367: PPUSH
19368: EMPTY
19369: PPUSH
19370: CALL_OW 1
19374: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19375: LD_ADDR_EXP 57
19379: PUSH
19380: LD_EXP 57
19384: PPUSH
19385: LD_VAR 0 4
19389: PPUSH
19390: EMPTY
19391: PPUSH
19392: CALL_OW 1
19396: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19397: LD_ADDR_EXP 58
19401: PUSH
19402: LD_EXP 58
19406: PPUSH
19407: LD_VAR 0 4
19411: PPUSH
19412: EMPTY
19413: PPUSH
19414: CALL_OW 1
19418: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19419: LD_ADDR_EXP 59
19423: PUSH
19424: LD_EXP 59
19428: PPUSH
19429: LD_VAR 0 4
19433: PPUSH
19434: EMPTY
19435: PPUSH
19436: CALL_OW 1
19440: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19441: LD_ADDR_EXP 60
19445: PUSH
19446: LD_EXP 60
19450: PPUSH
19451: LD_VAR 0 4
19455: PPUSH
19456: EMPTY
19457: PPUSH
19458: CALL_OW 1
19462: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19463: LD_ADDR_EXP 61
19467: PUSH
19468: LD_EXP 61
19472: PPUSH
19473: LD_VAR 0 4
19477: PPUSH
19478: LD_INT 0
19480: PPUSH
19481: CALL_OW 1
19485: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19486: LD_ADDR_EXP 62
19490: PUSH
19491: LD_EXP 62
19495: PPUSH
19496: LD_VAR 0 4
19500: PPUSH
19501: EMPTY
19502: PPUSH
19503: CALL_OW 1
19507: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19508: LD_ADDR_EXP 63
19512: PUSH
19513: LD_EXP 63
19517: PPUSH
19518: LD_VAR 0 4
19522: PPUSH
19523: EMPTY
19524: PPUSH
19525: CALL_OW 1
19529: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19530: LD_ADDR_EXP 64
19534: PUSH
19535: LD_EXP 64
19539: PPUSH
19540: LD_VAR 0 4
19544: PPUSH
19545: EMPTY
19546: PPUSH
19547: CALL_OW 1
19551: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19552: LD_ADDR_EXP 65
19556: PUSH
19557: LD_EXP 65
19561: PPUSH
19562: LD_VAR 0 4
19566: PPUSH
19567: EMPTY
19568: PPUSH
19569: CALL_OW 1
19573: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19574: LD_ADDR_EXP 66
19578: PUSH
19579: LD_EXP 66
19583: PPUSH
19584: LD_VAR 0 4
19588: PPUSH
19589: EMPTY
19590: PPUSH
19591: CALL_OW 1
19595: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19596: LD_ADDR_EXP 67
19600: PUSH
19601: LD_EXP 67
19605: PPUSH
19606: LD_VAR 0 4
19610: PPUSH
19611: EMPTY
19612: PPUSH
19613: CALL_OW 1
19617: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19618: LD_ADDR_EXP 68
19622: PUSH
19623: LD_EXP 68
19627: PPUSH
19628: LD_VAR 0 4
19632: PPUSH
19633: EMPTY
19634: PPUSH
19635: CALL_OW 1
19639: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19640: LD_ADDR_EXP 69
19644: PUSH
19645: LD_EXP 69
19649: PPUSH
19650: LD_VAR 0 4
19654: PPUSH
19655: EMPTY
19656: PPUSH
19657: CALL_OW 1
19661: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19662: LD_ADDR_EXP 70
19666: PUSH
19667: LD_EXP 70
19671: PPUSH
19672: LD_VAR 0 4
19676: PPUSH
19677: EMPTY
19678: PPUSH
19679: CALL_OW 1
19683: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19684: LD_ADDR_EXP 71
19688: PUSH
19689: LD_EXP 71
19693: PPUSH
19694: LD_VAR 0 4
19698: PPUSH
19699: EMPTY
19700: PPUSH
19701: CALL_OW 1
19705: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19706: LD_ADDR_EXP 72
19710: PUSH
19711: LD_EXP 72
19715: PPUSH
19716: LD_VAR 0 4
19720: PPUSH
19721: EMPTY
19722: PPUSH
19723: CALL_OW 1
19727: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19728: LD_ADDR_EXP 73
19732: PUSH
19733: LD_EXP 73
19737: PPUSH
19738: LD_VAR 0 4
19742: PPUSH
19743: EMPTY
19744: PPUSH
19745: CALL_OW 1
19749: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19750: LD_ADDR_EXP 74
19754: PUSH
19755: LD_EXP 74
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: EMPTY
19766: PPUSH
19767: CALL_OW 1
19771: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19772: LD_ADDR_EXP 75
19776: PUSH
19777: LD_EXP 75
19781: PPUSH
19782: LD_VAR 0 4
19786: PPUSH
19787: EMPTY
19788: PPUSH
19789: CALL_OW 1
19793: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19794: LD_ADDR_EXP 77
19798: PUSH
19799: LD_EXP 77
19803: PPUSH
19804: LD_VAR 0 4
19808: PPUSH
19809: EMPTY
19810: PPUSH
19811: CALL_OW 1
19815: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19816: LD_ADDR_EXP 79
19820: PUSH
19821: LD_EXP 79
19825: PPUSH
19826: LD_VAR 0 4
19830: PPUSH
19831: EMPTY
19832: PPUSH
19833: CALL_OW 1
19837: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19838: LD_ADDR_EXP 80
19842: PUSH
19843: LD_EXP 80
19847: PPUSH
19848: LD_VAR 0 4
19852: PPUSH
19853: EMPTY
19854: PPUSH
19855: CALL_OW 1
19859: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19860: LD_ADDR_EXP 81
19864: PUSH
19865: LD_EXP 81
19869: PPUSH
19870: LD_VAR 0 4
19874: PPUSH
19875: EMPTY
19876: PPUSH
19877: CALL_OW 1
19881: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19882: LD_ADDR_EXP 82
19886: PUSH
19887: LD_EXP 82
19891: PPUSH
19892: LD_VAR 0 4
19896: PPUSH
19897: EMPTY
19898: PPUSH
19899: CALL_OW 1
19903: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19904: LD_ADDR_EXP 83
19908: PUSH
19909: LD_EXP 83
19913: PPUSH
19914: LD_VAR 0 4
19918: PPUSH
19919: EMPTY
19920: PPUSH
19921: CALL_OW 1
19925: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19926: LD_ADDR_EXP 84
19930: PUSH
19931: LD_EXP 84
19935: PPUSH
19936: LD_VAR 0 4
19940: PPUSH
19941: EMPTY
19942: PPUSH
19943: CALL_OW 1
19947: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19948: LD_ADDR_EXP 85
19952: PUSH
19953: LD_EXP 85
19957: PPUSH
19958: LD_VAR 0 4
19962: PPUSH
19963: EMPTY
19964: PPUSH
19965: CALL_OW 1
19969: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19970: LD_ADDR_EXP 86
19974: PUSH
19975: LD_EXP 86
19979: PPUSH
19980: LD_VAR 0 4
19984: PPUSH
19985: EMPTY
19986: PPUSH
19987: CALL_OW 1
19991: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19992: LD_ADDR_EXP 87
19996: PUSH
19997: LD_EXP 87
20001: PPUSH
20002: LD_VAR 0 4
20006: PPUSH
20007: EMPTY
20008: PPUSH
20009: CALL_OW 1
20013: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20014: LD_ADDR_EXP 88
20018: PUSH
20019: LD_EXP 88
20023: PPUSH
20024: LD_VAR 0 4
20028: PPUSH
20029: EMPTY
20030: PPUSH
20031: CALL_OW 1
20035: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20036: LD_ADDR_EXP 89
20040: PUSH
20041: LD_EXP 89
20045: PPUSH
20046: LD_VAR 0 4
20050: PPUSH
20051: EMPTY
20052: PPUSH
20053: CALL_OW 1
20057: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20058: LD_ADDR_EXP 90
20062: PUSH
20063: LD_EXP 90
20067: PPUSH
20068: LD_VAR 0 4
20072: PPUSH
20073: EMPTY
20074: PPUSH
20075: CALL_OW 1
20079: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20080: LD_ADDR_EXP 91
20084: PUSH
20085: LD_EXP 91
20089: PPUSH
20090: LD_VAR 0 4
20094: PPUSH
20095: EMPTY
20096: PPUSH
20097: CALL_OW 1
20101: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20102: LD_ADDR_EXP 92
20106: PUSH
20107: LD_EXP 92
20111: PPUSH
20112: LD_VAR 0 4
20116: PPUSH
20117: LD_INT 0
20119: PPUSH
20120: CALL_OW 1
20124: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20125: LD_ADDR_EXP 93
20129: PUSH
20130: LD_EXP 93
20134: PPUSH
20135: LD_VAR 0 4
20139: PPUSH
20140: LD_INT 0
20142: PPUSH
20143: CALL_OW 1
20147: ST_TO_ADDR
// result := base ;
20148: LD_ADDR_VAR 0 3
20152: PUSH
20153: LD_VAR 0 4
20157: ST_TO_ADDR
// end ;
20158: LD_VAR 0 3
20162: RET
// export function MC_Start ( ) ; var i ; begin
20163: LD_INT 0
20165: PPUSH
20166: PPUSH
// for i = 1 to mc_bases do
20167: LD_ADDR_VAR 0 2
20171: PUSH
20172: DOUBLE
20173: LD_INT 1
20175: DEC
20176: ST_TO_ADDR
20177: LD_EXP 50
20181: PUSH
20182: FOR_TO
20183: IFFALSE 21283
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20185: LD_ADDR_EXP 50
20189: PUSH
20190: LD_EXP 50
20194: PPUSH
20195: LD_VAR 0 2
20199: PPUSH
20200: LD_EXP 50
20204: PUSH
20205: LD_VAR 0 2
20209: ARRAY
20210: PUSH
20211: LD_INT 0
20213: DIFF
20214: PPUSH
20215: CALL_OW 1
20219: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20220: LD_ADDR_EXP 51
20224: PUSH
20225: LD_EXP 51
20229: PPUSH
20230: LD_VAR 0 2
20234: PPUSH
20235: EMPTY
20236: PPUSH
20237: CALL_OW 1
20241: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20242: LD_ADDR_EXP 52
20246: PUSH
20247: LD_EXP 52
20251: PPUSH
20252: LD_VAR 0 2
20256: PPUSH
20257: EMPTY
20258: PPUSH
20259: CALL_OW 1
20263: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20264: LD_ADDR_EXP 53
20268: PUSH
20269: LD_EXP 53
20273: PPUSH
20274: LD_VAR 0 2
20278: PPUSH
20279: EMPTY
20280: PPUSH
20281: CALL_OW 1
20285: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20286: LD_ADDR_EXP 54
20290: PUSH
20291: LD_EXP 54
20295: PPUSH
20296: LD_VAR 0 2
20300: PPUSH
20301: EMPTY
20302: PUSH
20303: EMPTY
20304: PUSH
20305: EMPTY
20306: LIST
20307: LIST
20308: PPUSH
20309: CALL_OW 1
20313: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20314: LD_ADDR_EXP 55
20318: PUSH
20319: LD_EXP 55
20323: PPUSH
20324: LD_VAR 0 2
20328: PPUSH
20329: EMPTY
20330: PPUSH
20331: CALL_OW 1
20335: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20336: LD_ADDR_EXP 82
20340: PUSH
20341: LD_EXP 82
20345: PPUSH
20346: LD_VAR 0 2
20350: PPUSH
20351: EMPTY
20352: PPUSH
20353: CALL_OW 1
20357: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20358: LD_ADDR_EXP 56
20362: PUSH
20363: LD_EXP 56
20367: PPUSH
20368: LD_VAR 0 2
20372: PPUSH
20373: EMPTY
20374: PPUSH
20375: CALL_OW 1
20379: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20380: LD_ADDR_EXP 57
20384: PUSH
20385: LD_EXP 57
20389: PPUSH
20390: LD_VAR 0 2
20394: PPUSH
20395: EMPTY
20396: PPUSH
20397: CALL_OW 1
20401: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20402: LD_ADDR_EXP 58
20406: PUSH
20407: LD_EXP 58
20411: PPUSH
20412: LD_VAR 0 2
20416: PPUSH
20417: LD_EXP 50
20421: PUSH
20422: LD_VAR 0 2
20426: ARRAY
20427: PPUSH
20428: LD_INT 2
20430: PUSH
20431: LD_INT 30
20433: PUSH
20434: LD_INT 32
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: LD_INT 30
20443: PUSH
20444: LD_INT 33
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: LIST
20455: PPUSH
20456: CALL_OW 72
20460: PPUSH
20461: CALL_OW 1
20465: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20466: LD_ADDR_EXP 59
20470: PUSH
20471: LD_EXP 59
20475: PPUSH
20476: LD_VAR 0 2
20480: PPUSH
20481: LD_EXP 50
20485: PUSH
20486: LD_VAR 0 2
20490: ARRAY
20491: PPUSH
20492: LD_INT 2
20494: PUSH
20495: LD_INT 30
20497: PUSH
20498: LD_INT 32
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 30
20507: PUSH
20508: LD_INT 31
20510: PUSH
20511: EMPTY
20512: LIST
20513: LIST
20514: PUSH
20515: EMPTY
20516: LIST
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 58
20522: PUSH
20523: EMPTY
20524: LIST
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PPUSH
20530: CALL_OW 72
20534: PPUSH
20535: CALL_OW 1
20539: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20540: LD_ADDR_EXP 60
20544: PUSH
20545: LD_EXP 60
20549: PPUSH
20550: LD_VAR 0 2
20554: PPUSH
20555: EMPTY
20556: PPUSH
20557: CALL_OW 1
20561: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20562: LD_ADDR_EXP 64
20566: PUSH
20567: LD_EXP 64
20571: PPUSH
20572: LD_VAR 0 2
20576: PPUSH
20577: EMPTY
20578: PPUSH
20579: CALL_OW 1
20583: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20584: LD_ADDR_EXP 63
20588: PUSH
20589: LD_EXP 63
20593: PPUSH
20594: LD_VAR 0 2
20598: PPUSH
20599: EMPTY
20600: PPUSH
20601: CALL_OW 1
20605: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20606: LD_ADDR_EXP 65
20610: PUSH
20611: LD_EXP 65
20615: PPUSH
20616: LD_VAR 0 2
20620: PPUSH
20621: EMPTY
20622: PPUSH
20623: CALL_OW 1
20627: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20628: LD_ADDR_EXP 66
20632: PUSH
20633: LD_EXP 66
20637: PPUSH
20638: LD_VAR 0 2
20642: PPUSH
20643: EMPTY
20644: PPUSH
20645: CALL_OW 1
20649: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20650: LD_ADDR_EXP 67
20654: PUSH
20655: LD_EXP 67
20659: PPUSH
20660: LD_VAR 0 2
20664: PPUSH
20665: EMPTY
20666: PPUSH
20667: CALL_OW 1
20671: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20672: LD_ADDR_EXP 68
20676: PUSH
20677: LD_EXP 68
20681: PPUSH
20682: LD_VAR 0 2
20686: PPUSH
20687: EMPTY
20688: PPUSH
20689: CALL_OW 1
20693: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20694: LD_ADDR_EXP 69
20698: PUSH
20699: LD_EXP 69
20703: PPUSH
20704: LD_VAR 0 2
20708: PPUSH
20709: EMPTY
20710: PPUSH
20711: CALL_OW 1
20715: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20716: LD_ADDR_EXP 70
20720: PUSH
20721: LD_EXP 70
20725: PPUSH
20726: LD_VAR 0 2
20730: PPUSH
20731: EMPTY
20732: PPUSH
20733: CALL_OW 1
20737: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20738: LD_ADDR_EXP 71
20742: PUSH
20743: LD_EXP 71
20747: PPUSH
20748: LD_VAR 0 2
20752: PPUSH
20753: EMPTY
20754: PPUSH
20755: CALL_OW 1
20759: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20760: LD_ADDR_EXP 72
20764: PUSH
20765: LD_EXP 72
20769: PPUSH
20770: LD_VAR 0 2
20774: PPUSH
20775: EMPTY
20776: PPUSH
20777: CALL_OW 1
20781: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20782: LD_ADDR_EXP 61
20786: PUSH
20787: LD_EXP 61
20791: PPUSH
20792: LD_VAR 0 2
20796: PPUSH
20797: LD_INT 0
20799: PPUSH
20800: CALL_OW 1
20804: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20805: LD_ADDR_EXP 74
20809: PUSH
20810: LD_EXP 74
20814: PPUSH
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_INT 0
20822: PPUSH
20823: CALL_OW 1
20827: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20828: LD_ADDR_EXP 62
20832: PUSH
20833: LD_EXP 62
20837: PPUSH
20838: LD_VAR 0 2
20842: PPUSH
20843: EMPTY
20844: PPUSH
20845: CALL_OW 1
20849: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20850: LD_ADDR_EXP 73
20854: PUSH
20855: LD_EXP 73
20859: PPUSH
20860: LD_VAR 0 2
20864: PPUSH
20865: LD_INT 0
20867: PPUSH
20868: CALL_OW 1
20872: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20873: LD_ADDR_EXP 75
20877: PUSH
20878: LD_EXP 75
20882: PPUSH
20883: LD_VAR 0 2
20887: PPUSH
20888: EMPTY
20889: PPUSH
20890: CALL_OW 1
20894: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20895: LD_ADDR_EXP 78
20899: PUSH
20900: LD_EXP 78
20904: PPUSH
20905: LD_VAR 0 2
20909: PPUSH
20910: LD_INT 0
20912: PPUSH
20913: CALL_OW 1
20917: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20918: LD_ADDR_EXP 79
20922: PUSH
20923: LD_EXP 79
20927: PPUSH
20928: LD_VAR 0 2
20932: PPUSH
20933: EMPTY
20934: PPUSH
20935: CALL_OW 1
20939: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20940: LD_ADDR_EXP 80
20944: PUSH
20945: LD_EXP 80
20949: PPUSH
20950: LD_VAR 0 2
20954: PPUSH
20955: EMPTY
20956: PPUSH
20957: CALL_OW 1
20961: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20962: LD_ADDR_EXP 81
20966: PUSH
20967: LD_EXP 81
20971: PPUSH
20972: LD_VAR 0 2
20976: PPUSH
20977: EMPTY
20978: PPUSH
20979: CALL_OW 1
20983: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20984: LD_ADDR_EXP 83
20988: PUSH
20989: LD_EXP 83
20993: PPUSH
20994: LD_VAR 0 2
20998: PPUSH
20999: LD_EXP 50
21003: PUSH
21004: LD_VAR 0 2
21008: ARRAY
21009: PPUSH
21010: LD_INT 2
21012: PUSH
21013: LD_INT 30
21015: PUSH
21016: LD_INT 6
21018: PUSH
21019: EMPTY
21020: LIST
21021: LIST
21022: PUSH
21023: LD_INT 30
21025: PUSH
21026: LD_INT 7
21028: PUSH
21029: EMPTY
21030: LIST
21031: LIST
21032: PUSH
21033: LD_INT 30
21035: PUSH
21036: LD_INT 8
21038: PUSH
21039: EMPTY
21040: LIST
21041: LIST
21042: PUSH
21043: EMPTY
21044: LIST
21045: LIST
21046: LIST
21047: LIST
21048: PPUSH
21049: CALL_OW 72
21053: PPUSH
21054: CALL_OW 1
21058: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21059: LD_ADDR_EXP 84
21063: PUSH
21064: LD_EXP 84
21068: PPUSH
21069: LD_VAR 0 2
21073: PPUSH
21074: EMPTY
21075: PPUSH
21076: CALL_OW 1
21080: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21081: LD_ADDR_EXP 85
21085: PUSH
21086: LD_EXP 85
21090: PPUSH
21091: LD_VAR 0 2
21095: PPUSH
21096: EMPTY
21097: PPUSH
21098: CALL_OW 1
21102: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21103: LD_ADDR_EXP 86
21107: PUSH
21108: LD_EXP 86
21112: PPUSH
21113: LD_VAR 0 2
21117: PPUSH
21118: EMPTY
21119: PPUSH
21120: CALL_OW 1
21124: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21125: LD_ADDR_EXP 87
21129: PUSH
21130: LD_EXP 87
21134: PPUSH
21135: LD_VAR 0 2
21139: PPUSH
21140: EMPTY
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21147: LD_ADDR_EXP 88
21151: PUSH
21152: LD_EXP 88
21156: PPUSH
21157: LD_VAR 0 2
21161: PPUSH
21162: EMPTY
21163: PPUSH
21164: CALL_OW 1
21168: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21169: LD_ADDR_EXP 89
21173: PUSH
21174: LD_EXP 89
21178: PPUSH
21179: LD_VAR 0 2
21183: PPUSH
21184: EMPTY
21185: PPUSH
21186: CALL_OW 1
21190: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21191: LD_ADDR_EXP 90
21195: PUSH
21196: LD_EXP 90
21200: PPUSH
21201: LD_VAR 0 2
21205: PPUSH
21206: EMPTY
21207: PPUSH
21208: CALL_OW 1
21212: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21213: LD_ADDR_EXP 91
21217: PUSH
21218: LD_EXP 91
21222: PPUSH
21223: LD_VAR 0 2
21227: PPUSH
21228: EMPTY
21229: PPUSH
21230: CALL_OW 1
21234: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21235: LD_ADDR_EXP 92
21239: PUSH
21240: LD_EXP 92
21244: PPUSH
21245: LD_VAR 0 2
21249: PPUSH
21250: LD_INT 0
21252: PPUSH
21253: CALL_OW 1
21257: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21258: LD_ADDR_EXP 93
21262: PUSH
21263: LD_EXP 93
21267: PPUSH
21268: LD_VAR 0 2
21272: PPUSH
21273: LD_INT 0
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// end ;
21281: GO 20182
21283: POP
21284: POP
// MC_InitSides ( ) ;
21285: CALL 21571 0 0
// MC_InitResearch ( ) ;
21289: CALL 21310 0 0
// CustomInitMacro ( ) ;
21293: CALL 304 0 0
// skirmish := true ;
21297: LD_ADDR_EXP 48
21301: PUSH
21302: LD_INT 1
21304: ST_TO_ADDR
// end ;
21305: LD_VAR 0 1
21309: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21310: LD_INT 0
21312: PPUSH
21313: PPUSH
21314: PPUSH
21315: PPUSH
21316: PPUSH
21317: PPUSH
// if not mc_bases then
21318: LD_EXP 50
21322: NOT
21323: IFFALSE 21327
// exit ;
21325: GO 21566
// for i = 1 to 8 do
21327: LD_ADDR_VAR 0 2
21331: PUSH
21332: DOUBLE
21333: LD_INT 1
21335: DEC
21336: ST_TO_ADDR
21337: LD_INT 8
21339: PUSH
21340: FOR_TO
21341: IFFALSE 21367
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21343: LD_ADDR_EXP 77
21347: PUSH
21348: LD_EXP 77
21352: PPUSH
21353: LD_VAR 0 2
21357: PPUSH
21358: EMPTY
21359: PPUSH
21360: CALL_OW 1
21364: ST_TO_ADDR
21365: GO 21340
21367: POP
21368: POP
// tmp := [ ] ;
21369: LD_ADDR_VAR 0 5
21373: PUSH
21374: EMPTY
21375: ST_TO_ADDR
// for i = 1 to mc_sides do
21376: LD_ADDR_VAR 0 2
21380: PUSH
21381: DOUBLE
21382: LD_INT 1
21384: DEC
21385: ST_TO_ADDR
21386: LD_EXP 76
21390: PUSH
21391: FOR_TO
21392: IFFALSE 21450
// if not mc_sides [ i ] in tmp then
21394: LD_EXP 76
21398: PUSH
21399: LD_VAR 0 2
21403: ARRAY
21404: PUSH
21405: LD_VAR 0 5
21409: IN
21410: NOT
21411: IFFALSE 21448
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21413: LD_ADDR_VAR 0 5
21417: PUSH
21418: LD_VAR 0 5
21422: PPUSH
21423: LD_VAR 0 5
21427: PUSH
21428: LD_INT 1
21430: PLUS
21431: PPUSH
21432: LD_EXP 76
21436: PUSH
21437: LD_VAR 0 2
21441: ARRAY
21442: PPUSH
21443: CALL_OW 2
21447: ST_TO_ADDR
21448: GO 21391
21450: POP
21451: POP
// if not tmp then
21452: LD_VAR 0 5
21456: NOT
21457: IFFALSE 21461
// exit ;
21459: GO 21566
// for j in tmp do
21461: LD_ADDR_VAR 0 3
21465: PUSH
21466: LD_VAR 0 5
21470: PUSH
21471: FOR_IN
21472: IFFALSE 21564
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21474: LD_ADDR_VAR 0 6
21478: PUSH
21479: LD_INT 22
21481: PUSH
21482: LD_VAR 0 3
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: PPUSH
21491: CALL_OW 69
21495: ST_TO_ADDR
// if not un then
21496: LD_VAR 0 6
21500: NOT
21501: IFFALSE 21505
// continue ;
21503: GO 21471
// nation := GetNation ( un [ 1 ] ) ;
21505: LD_ADDR_VAR 0 4
21509: PUSH
21510: LD_VAR 0 6
21514: PUSH
21515: LD_INT 1
21517: ARRAY
21518: PPUSH
21519: CALL_OW 248
21523: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21524: LD_ADDR_EXP 77
21528: PUSH
21529: LD_EXP 77
21533: PPUSH
21534: LD_VAR 0 3
21538: PPUSH
21539: LD_VAR 0 3
21543: PPUSH
21544: LD_VAR 0 4
21548: PPUSH
21549: LD_INT 1
21551: PPUSH
21552: CALL 48718 0 3
21556: PPUSH
21557: CALL_OW 1
21561: ST_TO_ADDR
// end ;
21562: GO 21471
21564: POP
21565: POP
// end ;
21566: LD_VAR 0 1
21570: RET
// export function MC_InitSides ( ) ; var i ; begin
21571: LD_INT 0
21573: PPUSH
21574: PPUSH
// if not mc_bases then
21575: LD_EXP 50
21579: NOT
21580: IFFALSE 21584
// exit ;
21582: GO 21658
// for i = 1 to mc_bases do
21584: LD_ADDR_VAR 0 2
21588: PUSH
21589: DOUBLE
21590: LD_INT 1
21592: DEC
21593: ST_TO_ADDR
21594: LD_EXP 50
21598: PUSH
21599: FOR_TO
21600: IFFALSE 21656
// if mc_bases [ i ] then
21602: LD_EXP 50
21606: PUSH
21607: LD_VAR 0 2
21611: ARRAY
21612: IFFALSE 21654
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21614: LD_ADDR_EXP 76
21618: PUSH
21619: LD_EXP 76
21623: PPUSH
21624: LD_VAR 0 2
21628: PPUSH
21629: LD_EXP 50
21633: PUSH
21634: LD_VAR 0 2
21638: ARRAY
21639: PUSH
21640: LD_INT 1
21642: ARRAY
21643: PPUSH
21644: CALL_OW 255
21648: PPUSH
21649: CALL_OW 1
21653: ST_TO_ADDR
21654: GO 21599
21656: POP
21657: POP
// end ;
21658: LD_VAR 0 1
21662: RET
// every 0 0$03 trigger skirmish do
21663: LD_EXP 48
21667: IFFALSE 21821
21669: GO 21671
21671: DISABLE
// begin enable ;
21672: ENABLE
// MC_CheckBuildings ( ) ;
21673: CALL 26319 0 0
// MC_CheckPeopleLife ( ) ;
21677: CALL 26480 0 0
// RaiseSailEvent ( 100 ) ;
21681: LD_INT 100
21683: PPUSH
21684: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21688: LD_INT 103
21690: PPUSH
21691: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21695: LD_INT 104
21697: PPUSH
21698: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21702: LD_INT 105
21704: PPUSH
21705: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21709: LD_INT 106
21711: PPUSH
21712: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21716: LD_INT 107
21718: PPUSH
21719: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21723: LD_INT 108
21725: PPUSH
21726: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21730: LD_INT 109
21732: PPUSH
21733: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21737: LD_INT 110
21739: PPUSH
21740: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21744: LD_INT 111
21746: PPUSH
21747: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21751: LD_INT 112
21753: PPUSH
21754: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21758: LD_INT 113
21760: PPUSH
21761: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21765: LD_INT 120
21767: PPUSH
21768: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21772: LD_INT 121
21774: PPUSH
21775: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21779: LD_INT 122
21781: PPUSH
21782: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21786: LD_INT 123
21788: PPUSH
21789: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21793: LD_INT 124
21795: PPUSH
21796: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21800: LD_INT 125
21802: PPUSH
21803: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21807: LD_INT 126
21809: PPUSH
21810: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21814: LD_INT 200
21816: PPUSH
21817: CALL_OW 427
// end ;
21821: END
// on SailEvent ( event ) do begin if event < 100 then
21822: LD_VAR 0 1
21826: PUSH
21827: LD_INT 100
21829: LESS
21830: IFFALSE 21841
// CustomEvent ( event ) ;
21832: LD_VAR 0 1
21836: PPUSH
21837: CALL 17177 0 1
// if event = 100 then
21841: LD_VAR 0 1
21845: PUSH
21846: LD_INT 100
21848: EQUAL
21849: IFFALSE 21855
// MC_ClassManager ( ) ;
21851: CALL 22247 0 0
// if event = 101 then
21855: LD_VAR 0 1
21859: PUSH
21860: LD_INT 101
21862: EQUAL
21863: IFFALSE 21869
// MC_RepairBuildings ( ) ;
21865: CALL 27065 0 0
// if event = 102 then
21869: LD_VAR 0 1
21873: PUSH
21874: LD_INT 102
21876: EQUAL
21877: IFFALSE 21883
// MC_Heal ( ) ;
21879: CALL 28000 0 0
// if event = 103 then
21883: LD_VAR 0 1
21887: PUSH
21888: LD_INT 103
21890: EQUAL
21891: IFFALSE 21897
// MC_Build ( ) ;
21893: CALL 28422 0 0
// if event = 104 then
21897: LD_VAR 0 1
21901: PUSH
21902: LD_INT 104
21904: EQUAL
21905: IFFALSE 21911
// MC_TurretWeapon ( ) ;
21907: CALL 30056 0 0
// if event = 105 then
21911: LD_VAR 0 1
21915: PUSH
21916: LD_INT 105
21918: EQUAL
21919: IFFALSE 21925
// MC_BuildUpgrade ( ) ;
21921: CALL 29607 0 0
// if event = 106 then
21925: LD_VAR 0 1
21929: PUSH
21930: LD_INT 106
21932: EQUAL
21933: IFFALSE 21939
// MC_PlantMines ( ) ;
21935: CALL 30486 0 0
// if event = 107 then
21939: LD_VAR 0 1
21943: PUSH
21944: LD_INT 107
21946: EQUAL
21947: IFFALSE 21953
// MC_CollectCrates ( ) ;
21949: CALL 31277 0 0
// if event = 108 then
21953: LD_VAR 0 1
21957: PUSH
21958: LD_INT 108
21960: EQUAL
21961: IFFALSE 21967
// MC_LinkRemoteControl ( ) ;
21963: CALL 33127 0 0
// if event = 109 then
21967: LD_VAR 0 1
21971: PUSH
21972: LD_INT 109
21974: EQUAL
21975: IFFALSE 21981
// MC_ProduceVehicle ( ) ;
21977: CALL 33308 0 0
// if event = 110 then
21981: LD_VAR 0 1
21985: PUSH
21986: LD_INT 110
21988: EQUAL
21989: IFFALSE 21995
// MC_SendAttack ( ) ;
21991: CALL 33774 0 0
// if event = 111 then
21995: LD_VAR 0 1
21999: PUSH
22000: LD_INT 111
22002: EQUAL
22003: IFFALSE 22009
// MC_Defend ( ) ;
22005: CALL 33882 0 0
// if event = 112 then
22009: LD_VAR 0 1
22013: PUSH
22014: LD_INT 112
22016: EQUAL
22017: IFFALSE 22023
// MC_Research ( ) ;
22019: CALL 34762 0 0
// if event = 113 then
22023: LD_VAR 0 1
22027: PUSH
22028: LD_INT 113
22030: EQUAL
22031: IFFALSE 22037
// MC_MinesTrigger ( ) ;
22033: CALL 35876 0 0
// if event = 120 then
22037: LD_VAR 0 1
22041: PUSH
22042: LD_INT 120
22044: EQUAL
22045: IFFALSE 22051
// MC_RepairVehicle ( ) ;
22047: CALL 35975 0 0
// if event = 121 then
22051: LD_VAR 0 1
22055: PUSH
22056: LD_INT 121
22058: EQUAL
22059: IFFALSE 22065
// MC_TameApe ( ) ;
22061: CALL 36744 0 0
// if event = 122 then
22065: LD_VAR 0 1
22069: PUSH
22070: LD_INT 122
22072: EQUAL
22073: IFFALSE 22079
// MC_ChangeApeClass ( ) ;
22075: CALL 37573 0 0
// if event = 123 then
22079: LD_VAR 0 1
22083: PUSH
22084: LD_INT 123
22086: EQUAL
22087: IFFALSE 22093
// MC_Bazooka ( ) ;
22089: CALL 38223 0 0
// if event = 124 then
22093: LD_VAR 0 1
22097: PUSH
22098: LD_INT 124
22100: EQUAL
22101: IFFALSE 22107
// MC_TeleportExit ( ) ;
22103: CALL 38421 0 0
// if event = 125 then
22107: LD_VAR 0 1
22111: PUSH
22112: LD_INT 125
22114: EQUAL
22115: IFFALSE 22121
// MC_Deposits ( ) ;
22117: CALL 39068 0 0
// if event = 126 then
22121: LD_VAR 0 1
22125: PUSH
22126: LD_INT 126
22128: EQUAL
22129: IFFALSE 22135
// MC_RemoteDriver ( ) ;
22131: CALL 39693 0 0
// if event = 200 then
22135: LD_VAR 0 1
22139: PUSH
22140: LD_INT 200
22142: EQUAL
22143: IFFALSE 22149
// MC_Idle ( ) ;
22145: CALL 41642 0 0
// end ;
22149: PPOPN 1
22151: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22152: LD_INT 0
22154: PPUSH
22155: PPUSH
// if not mc_bases [ base ] or not tag then
22156: LD_EXP 50
22160: PUSH
22161: LD_VAR 0 1
22165: ARRAY
22166: NOT
22167: PUSH
22168: LD_VAR 0 2
22172: NOT
22173: OR
22174: IFFALSE 22178
// exit ;
22176: GO 22242
// for i in mc_bases [ base ] union mc_ape [ base ] do
22178: LD_ADDR_VAR 0 4
22182: PUSH
22183: LD_EXP 50
22187: PUSH
22188: LD_VAR 0 1
22192: ARRAY
22193: PUSH
22194: LD_EXP 79
22198: PUSH
22199: LD_VAR 0 1
22203: ARRAY
22204: UNION
22205: PUSH
22206: FOR_IN
22207: IFFALSE 22240
// if GetTag ( i ) = tag then
22209: LD_VAR 0 4
22213: PPUSH
22214: CALL_OW 110
22218: PUSH
22219: LD_VAR 0 2
22223: EQUAL
22224: IFFALSE 22238
// SetTag ( i , 0 ) ;
22226: LD_VAR 0 4
22230: PPUSH
22231: LD_INT 0
22233: PPUSH
22234: CALL_OW 109
22238: GO 22206
22240: POP
22241: POP
// end ;
22242: LD_VAR 0 3
22246: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22247: LD_INT 0
22249: PPUSH
22250: PPUSH
22251: PPUSH
22252: PPUSH
22253: PPUSH
22254: PPUSH
22255: PPUSH
22256: PPUSH
// if not mc_bases then
22257: LD_EXP 50
22261: NOT
22262: IFFALSE 22266
// exit ;
22264: GO 22724
// for i = 1 to mc_bases do
22266: LD_ADDR_VAR 0 2
22270: PUSH
22271: DOUBLE
22272: LD_INT 1
22274: DEC
22275: ST_TO_ADDR
22276: LD_EXP 50
22280: PUSH
22281: FOR_TO
22282: IFFALSE 22722
// begin tmp := MC_ClassCheckReq ( i ) ;
22284: LD_ADDR_VAR 0 4
22288: PUSH
22289: LD_VAR 0 2
22293: PPUSH
22294: CALL 22729 0 1
22298: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22299: LD_ADDR_EXP 91
22303: PUSH
22304: LD_EXP 91
22308: PPUSH
22309: LD_VAR 0 2
22313: PPUSH
22314: LD_VAR 0 4
22318: PPUSH
22319: CALL_OW 1
22323: ST_TO_ADDR
// if not tmp then
22324: LD_VAR 0 4
22328: NOT
22329: IFFALSE 22333
// continue ;
22331: GO 22281
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22333: LD_ADDR_VAR 0 6
22337: PUSH
22338: LD_EXP 50
22342: PUSH
22343: LD_VAR 0 2
22347: ARRAY
22348: PPUSH
22349: LD_INT 2
22351: PUSH
22352: LD_INT 30
22354: PUSH
22355: LD_INT 4
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: PUSH
22362: LD_INT 30
22364: PUSH
22365: LD_INT 5
22367: PUSH
22368: EMPTY
22369: LIST
22370: LIST
22371: PUSH
22372: EMPTY
22373: LIST
22374: LIST
22375: LIST
22376: PPUSH
22377: CALL_OW 72
22381: PUSH
22382: LD_EXP 50
22386: PUSH
22387: LD_VAR 0 2
22391: ARRAY
22392: PPUSH
22393: LD_INT 2
22395: PUSH
22396: LD_INT 30
22398: PUSH
22399: LD_INT 0
22401: PUSH
22402: EMPTY
22403: LIST
22404: LIST
22405: PUSH
22406: LD_INT 30
22408: PUSH
22409: LD_INT 1
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: PUSH
22416: EMPTY
22417: LIST
22418: LIST
22419: LIST
22420: PPUSH
22421: CALL_OW 72
22425: PUSH
22426: LD_EXP 50
22430: PUSH
22431: LD_VAR 0 2
22435: ARRAY
22436: PPUSH
22437: LD_INT 30
22439: PUSH
22440: LD_INT 3
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PPUSH
22447: CALL_OW 72
22451: PUSH
22452: LD_EXP 50
22456: PUSH
22457: LD_VAR 0 2
22461: ARRAY
22462: PPUSH
22463: LD_INT 2
22465: PUSH
22466: LD_INT 30
22468: PUSH
22469: LD_INT 6
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: PUSH
22476: LD_INT 30
22478: PUSH
22479: LD_INT 7
22481: PUSH
22482: EMPTY
22483: LIST
22484: LIST
22485: PUSH
22486: LD_INT 30
22488: PUSH
22489: LD_INT 8
22491: PUSH
22492: EMPTY
22493: LIST
22494: LIST
22495: PUSH
22496: EMPTY
22497: LIST
22498: LIST
22499: LIST
22500: LIST
22501: PPUSH
22502: CALL_OW 72
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: ST_TO_ADDR
// for j = 1 to 4 do
22513: LD_ADDR_VAR 0 3
22517: PUSH
22518: DOUBLE
22519: LD_INT 1
22521: DEC
22522: ST_TO_ADDR
22523: LD_INT 4
22525: PUSH
22526: FOR_TO
22527: IFFALSE 22718
// begin if not tmp [ j ] then
22529: LD_VAR 0 4
22533: PUSH
22534: LD_VAR 0 3
22538: ARRAY
22539: NOT
22540: IFFALSE 22544
// continue ;
22542: GO 22526
// for p in tmp [ j ] do
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: LD_VAR 0 4
22553: PUSH
22554: LD_VAR 0 3
22558: ARRAY
22559: PUSH
22560: FOR_IN
22561: IFFALSE 22714
// begin if not b [ j ] then
22563: LD_VAR 0 6
22567: PUSH
22568: LD_VAR 0 3
22572: ARRAY
22573: NOT
22574: IFFALSE 22578
// break ;
22576: GO 22714
// e := 0 ;
22578: LD_ADDR_VAR 0 7
22582: PUSH
22583: LD_INT 0
22585: ST_TO_ADDR
// for k in b [ j ] do
22586: LD_ADDR_VAR 0 8
22590: PUSH
22591: LD_VAR 0 6
22595: PUSH
22596: LD_VAR 0 3
22600: ARRAY
22601: PUSH
22602: FOR_IN
22603: IFFALSE 22630
// if IsNotFull ( k ) then
22605: LD_VAR 0 8
22609: PPUSH
22610: CALL 50871 0 1
22614: IFFALSE 22628
// begin e := k ;
22616: LD_ADDR_VAR 0 7
22620: PUSH
22621: LD_VAR 0 8
22625: ST_TO_ADDR
// break ;
22626: GO 22630
// end ;
22628: GO 22602
22630: POP
22631: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22632: LD_VAR 0 7
22636: PUSH
22637: LD_VAR 0 5
22641: PPUSH
22642: LD_VAR 0 7
22646: PPUSH
22647: CALL 84750 0 2
22651: NOT
22652: AND
22653: IFFALSE 22712
// begin if IsInUnit ( p ) then
22655: LD_VAR 0 5
22659: PPUSH
22660: CALL_OW 310
22664: IFFALSE 22675
// ComExitBuilding ( p ) ;
22666: LD_VAR 0 5
22670: PPUSH
22671: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22675: LD_VAR 0 5
22679: PPUSH
22680: LD_VAR 0 7
22684: PPUSH
22685: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22689: LD_VAR 0 5
22693: PPUSH
22694: LD_VAR 0 3
22698: PPUSH
22699: CALL_OW 183
// AddComExitBuilding ( p ) ;
22703: LD_VAR 0 5
22707: PPUSH
22708: CALL_OW 182
// end ; end ;
22712: GO 22560
22714: POP
22715: POP
// end ;
22716: GO 22526
22718: POP
22719: POP
// end ;
22720: GO 22281
22722: POP
22723: POP
// end ;
22724: LD_VAR 0 1
22728: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22729: LD_INT 0
22731: PPUSH
22732: PPUSH
22733: PPUSH
22734: PPUSH
22735: PPUSH
22736: PPUSH
22737: PPUSH
22738: PPUSH
22739: PPUSH
22740: PPUSH
22741: PPUSH
22742: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22743: LD_VAR 0 1
22747: NOT
22748: PUSH
22749: LD_EXP 50
22753: PUSH
22754: LD_VAR 0 1
22758: ARRAY
22759: NOT
22760: OR
22761: PUSH
22762: LD_EXP 50
22766: PUSH
22767: LD_VAR 0 1
22771: ARRAY
22772: PPUSH
22773: LD_INT 2
22775: PUSH
22776: LD_INT 30
22778: PUSH
22779: LD_INT 0
22781: PUSH
22782: EMPTY
22783: LIST
22784: LIST
22785: PUSH
22786: LD_INT 30
22788: PUSH
22789: LD_INT 1
22791: PUSH
22792: EMPTY
22793: LIST
22794: LIST
22795: PUSH
22796: EMPTY
22797: LIST
22798: LIST
22799: LIST
22800: PPUSH
22801: CALL_OW 72
22805: NOT
22806: OR
22807: IFFALSE 22811
// exit ;
22809: GO 26314
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22811: LD_ADDR_VAR 0 4
22815: PUSH
22816: LD_EXP 50
22820: PUSH
22821: LD_VAR 0 1
22825: ARRAY
22826: PPUSH
22827: LD_INT 2
22829: PUSH
22830: LD_INT 25
22832: PUSH
22833: LD_INT 1
22835: PUSH
22836: EMPTY
22837: LIST
22838: LIST
22839: PUSH
22840: LD_INT 25
22842: PUSH
22843: LD_INT 2
22845: PUSH
22846: EMPTY
22847: LIST
22848: LIST
22849: PUSH
22850: LD_INT 25
22852: PUSH
22853: LD_INT 3
22855: PUSH
22856: EMPTY
22857: LIST
22858: LIST
22859: PUSH
22860: LD_INT 25
22862: PUSH
22863: LD_INT 4
22865: PUSH
22866: EMPTY
22867: LIST
22868: LIST
22869: PUSH
22870: LD_INT 25
22872: PUSH
22873: LD_INT 5
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PUSH
22880: LD_INT 25
22882: PUSH
22883: LD_INT 8
22885: PUSH
22886: EMPTY
22887: LIST
22888: LIST
22889: PUSH
22890: LD_INT 25
22892: PUSH
22893: LD_INT 9
22895: PUSH
22896: EMPTY
22897: LIST
22898: LIST
22899: PUSH
22900: EMPTY
22901: LIST
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: LIST
22907: LIST
22908: LIST
22909: PPUSH
22910: CALL_OW 72
22914: ST_TO_ADDR
// if not tmp then
22915: LD_VAR 0 4
22919: NOT
22920: IFFALSE 22924
// exit ;
22922: GO 26314
// for i in tmp do
22924: LD_ADDR_VAR 0 3
22928: PUSH
22929: LD_VAR 0 4
22933: PUSH
22934: FOR_IN
22935: IFFALSE 22966
// if GetTag ( i ) then
22937: LD_VAR 0 3
22941: PPUSH
22942: CALL_OW 110
22946: IFFALSE 22964
// tmp := tmp diff i ;
22948: LD_ADDR_VAR 0 4
22952: PUSH
22953: LD_VAR 0 4
22957: PUSH
22958: LD_VAR 0 3
22962: DIFF
22963: ST_TO_ADDR
22964: GO 22934
22966: POP
22967: POP
// if not tmp then
22968: LD_VAR 0 4
22972: NOT
22973: IFFALSE 22977
// exit ;
22975: GO 26314
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22977: LD_ADDR_VAR 0 5
22981: PUSH
22982: LD_EXP 50
22986: PUSH
22987: LD_VAR 0 1
22991: ARRAY
22992: PPUSH
22993: LD_INT 2
22995: PUSH
22996: LD_INT 25
22998: PUSH
22999: LD_INT 1
23001: PUSH
23002: EMPTY
23003: LIST
23004: LIST
23005: PUSH
23006: LD_INT 25
23008: PUSH
23009: LD_INT 5
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: PUSH
23016: LD_INT 25
23018: PUSH
23019: LD_INT 8
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: PUSH
23026: LD_INT 25
23028: PUSH
23029: LD_INT 9
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PUSH
23036: EMPTY
23037: LIST
23038: LIST
23039: LIST
23040: LIST
23041: LIST
23042: PPUSH
23043: CALL_OW 72
23047: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23048: LD_ADDR_VAR 0 6
23052: PUSH
23053: LD_EXP 50
23057: PUSH
23058: LD_VAR 0 1
23062: ARRAY
23063: PPUSH
23064: LD_INT 25
23066: PUSH
23067: LD_INT 2
23069: PUSH
23070: EMPTY
23071: LIST
23072: LIST
23073: PPUSH
23074: CALL_OW 72
23078: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23079: LD_ADDR_VAR 0 7
23083: PUSH
23084: LD_EXP 50
23088: PUSH
23089: LD_VAR 0 1
23093: ARRAY
23094: PPUSH
23095: LD_INT 25
23097: PUSH
23098: LD_INT 3
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: PPUSH
23105: CALL_OW 72
23109: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23110: LD_ADDR_VAR 0 8
23114: PUSH
23115: LD_EXP 50
23119: PUSH
23120: LD_VAR 0 1
23124: ARRAY
23125: PPUSH
23126: LD_INT 25
23128: PUSH
23129: LD_INT 4
23131: PUSH
23132: EMPTY
23133: LIST
23134: LIST
23135: PUSH
23136: LD_INT 24
23138: PUSH
23139: LD_INT 251
23141: PUSH
23142: EMPTY
23143: LIST
23144: LIST
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PPUSH
23150: CALL_OW 72
23154: ST_TO_ADDR
// if mc_is_defending [ base ] then
23155: LD_EXP 93
23159: PUSH
23160: LD_VAR 0 1
23164: ARRAY
23165: IFFALSE 23626
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23167: LD_ADDR_EXP 92
23171: PUSH
23172: LD_EXP 92
23176: PPUSH
23177: LD_VAR 0 1
23181: PPUSH
23182: LD_INT 4
23184: PPUSH
23185: CALL_OW 1
23189: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23190: LD_ADDR_VAR 0 12
23194: PUSH
23195: LD_EXP 50
23199: PUSH
23200: LD_VAR 0 1
23204: ARRAY
23205: PPUSH
23206: LD_INT 2
23208: PUSH
23209: LD_INT 30
23211: PUSH
23212: LD_INT 4
23214: PUSH
23215: EMPTY
23216: LIST
23217: LIST
23218: PUSH
23219: LD_INT 30
23221: PUSH
23222: LD_INT 5
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: EMPTY
23230: LIST
23231: LIST
23232: LIST
23233: PPUSH
23234: CALL_OW 72
23238: ST_TO_ADDR
// if not b then
23239: LD_VAR 0 12
23243: NOT
23244: IFFALSE 23248
// exit ;
23246: GO 26314
// p := [ ] ;
23248: LD_ADDR_VAR 0 11
23252: PUSH
23253: EMPTY
23254: ST_TO_ADDR
// if sci >= 2 then
23255: LD_VAR 0 8
23259: PUSH
23260: LD_INT 2
23262: GREATEREQUAL
23263: IFFALSE 23294
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23265: LD_ADDR_VAR 0 8
23269: PUSH
23270: LD_VAR 0 8
23274: PUSH
23275: LD_INT 1
23277: ARRAY
23278: PUSH
23279: LD_VAR 0 8
23283: PUSH
23284: LD_INT 2
23286: ARRAY
23287: PUSH
23288: EMPTY
23289: LIST
23290: LIST
23291: ST_TO_ADDR
23292: GO 23355
// if sci = 1 then
23294: LD_VAR 0 8
23298: PUSH
23299: LD_INT 1
23301: EQUAL
23302: IFFALSE 23323
// sci := [ sci [ 1 ] ] else
23304: LD_ADDR_VAR 0 8
23308: PUSH
23309: LD_VAR 0 8
23313: PUSH
23314: LD_INT 1
23316: ARRAY
23317: PUSH
23318: EMPTY
23319: LIST
23320: ST_TO_ADDR
23321: GO 23355
// if sci = 0 then
23323: LD_VAR 0 8
23327: PUSH
23328: LD_INT 0
23330: EQUAL
23331: IFFALSE 23355
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23333: LD_ADDR_VAR 0 11
23337: PUSH
23338: LD_VAR 0 4
23342: PPUSH
23343: LD_INT 4
23345: PPUSH
23346: CALL 84613 0 2
23350: PUSH
23351: LD_INT 1
23353: ARRAY
23354: ST_TO_ADDR
// if eng > 4 then
23355: LD_VAR 0 6
23359: PUSH
23360: LD_INT 4
23362: GREATER
23363: IFFALSE 23409
// for i = eng downto 4 do
23365: LD_ADDR_VAR 0 3
23369: PUSH
23370: DOUBLE
23371: LD_VAR 0 6
23375: INC
23376: ST_TO_ADDR
23377: LD_INT 4
23379: PUSH
23380: FOR_DOWNTO
23381: IFFALSE 23407
// eng := eng diff eng [ i ] ;
23383: LD_ADDR_VAR 0 6
23387: PUSH
23388: LD_VAR 0 6
23392: PUSH
23393: LD_VAR 0 6
23397: PUSH
23398: LD_VAR 0 3
23402: ARRAY
23403: DIFF
23404: ST_TO_ADDR
23405: GO 23380
23407: POP
23408: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23409: LD_ADDR_VAR 0 4
23413: PUSH
23414: LD_VAR 0 4
23418: PUSH
23419: LD_VAR 0 5
23423: PUSH
23424: LD_VAR 0 6
23428: UNION
23429: PUSH
23430: LD_VAR 0 7
23434: UNION
23435: PUSH
23436: LD_VAR 0 8
23440: UNION
23441: DIFF
23442: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23443: LD_ADDR_VAR 0 13
23447: PUSH
23448: LD_EXP 50
23452: PUSH
23453: LD_VAR 0 1
23457: ARRAY
23458: PPUSH
23459: LD_INT 2
23461: PUSH
23462: LD_INT 30
23464: PUSH
23465: LD_INT 32
23467: PUSH
23468: EMPTY
23469: LIST
23470: LIST
23471: PUSH
23472: LD_INT 30
23474: PUSH
23475: LD_INT 31
23477: PUSH
23478: EMPTY
23479: LIST
23480: LIST
23481: PUSH
23482: EMPTY
23483: LIST
23484: LIST
23485: LIST
23486: PPUSH
23487: CALL_OW 72
23491: PUSH
23492: LD_EXP 50
23496: PUSH
23497: LD_VAR 0 1
23501: ARRAY
23502: PPUSH
23503: LD_INT 2
23505: PUSH
23506: LD_INT 30
23508: PUSH
23509: LD_INT 4
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: PUSH
23516: LD_INT 30
23518: PUSH
23519: LD_INT 5
23521: PUSH
23522: EMPTY
23523: LIST
23524: LIST
23525: PUSH
23526: EMPTY
23527: LIST
23528: LIST
23529: LIST
23530: PPUSH
23531: CALL_OW 72
23535: PUSH
23536: LD_INT 6
23538: MUL
23539: PLUS
23540: ST_TO_ADDR
// if bcount < tmp then
23541: LD_VAR 0 13
23545: PUSH
23546: LD_VAR 0 4
23550: LESS
23551: IFFALSE 23597
// for i = tmp downto bcount do
23553: LD_ADDR_VAR 0 3
23557: PUSH
23558: DOUBLE
23559: LD_VAR 0 4
23563: INC
23564: ST_TO_ADDR
23565: LD_VAR 0 13
23569: PUSH
23570: FOR_DOWNTO
23571: IFFALSE 23595
// tmp := Delete ( tmp , tmp ) ;
23573: LD_ADDR_VAR 0 4
23577: PUSH
23578: LD_VAR 0 4
23582: PPUSH
23583: LD_VAR 0 4
23587: PPUSH
23588: CALL_OW 3
23592: ST_TO_ADDR
23593: GO 23570
23595: POP
23596: POP
// result := [ tmp , 0 , 0 , p ] ;
23597: LD_ADDR_VAR 0 2
23601: PUSH
23602: LD_VAR 0 4
23606: PUSH
23607: LD_INT 0
23609: PUSH
23610: LD_INT 0
23612: PUSH
23613: LD_VAR 0 11
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: LIST
23622: LIST
23623: ST_TO_ADDR
// exit ;
23624: GO 26314
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23626: LD_EXP 50
23630: PUSH
23631: LD_VAR 0 1
23635: ARRAY
23636: PPUSH
23637: LD_INT 2
23639: PUSH
23640: LD_INT 30
23642: PUSH
23643: LD_INT 6
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: PUSH
23650: LD_INT 30
23652: PUSH
23653: LD_INT 7
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 30
23662: PUSH
23663: LD_INT 8
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: PPUSH
23676: CALL_OW 72
23680: NOT
23681: PUSH
23682: LD_EXP 50
23686: PUSH
23687: LD_VAR 0 1
23691: ARRAY
23692: PPUSH
23693: LD_INT 30
23695: PUSH
23696: LD_INT 3
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: PPUSH
23703: CALL_OW 72
23707: NOT
23708: AND
23709: IFFALSE 23781
// begin if eng = tmp then
23711: LD_VAR 0 6
23715: PUSH
23716: LD_VAR 0 4
23720: EQUAL
23721: IFFALSE 23725
// exit ;
23723: GO 26314
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23725: LD_ADDR_EXP 92
23729: PUSH
23730: LD_EXP 92
23734: PPUSH
23735: LD_VAR 0 1
23739: PPUSH
23740: LD_INT 1
23742: PPUSH
23743: CALL_OW 1
23747: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23748: LD_ADDR_VAR 0 2
23752: PUSH
23753: LD_INT 0
23755: PUSH
23756: LD_VAR 0 4
23760: PUSH
23761: LD_VAR 0 6
23765: DIFF
23766: PUSH
23767: LD_INT 0
23769: PUSH
23770: LD_INT 0
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: LIST
23777: LIST
23778: ST_TO_ADDR
// exit ;
23779: GO 26314
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23781: LD_EXP 77
23785: PUSH
23786: LD_EXP 76
23790: PUSH
23791: LD_VAR 0 1
23795: ARRAY
23796: ARRAY
23797: PUSH
23798: LD_EXP 50
23802: PUSH
23803: LD_VAR 0 1
23807: ARRAY
23808: PPUSH
23809: LD_INT 2
23811: PUSH
23812: LD_INT 30
23814: PUSH
23815: LD_INT 6
23817: PUSH
23818: EMPTY
23819: LIST
23820: LIST
23821: PUSH
23822: LD_INT 30
23824: PUSH
23825: LD_INT 7
23827: PUSH
23828: EMPTY
23829: LIST
23830: LIST
23831: PUSH
23832: LD_INT 30
23834: PUSH
23835: LD_INT 8
23837: PUSH
23838: EMPTY
23839: LIST
23840: LIST
23841: PUSH
23842: EMPTY
23843: LIST
23844: LIST
23845: LIST
23846: LIST
23847: PPUSH
23848: CALL_OW 72
23852: AND
23853: PUSH
23854: LD_EXP 50
23858: PUSH
23859: LD_VAR 0 1
23863: ARRAY
23864: PPUSH
23865: LD_INT 30
23867: PUSH
23868: LD_INT 3
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: PPUSH
23875: CALL_OW 72
23879: NOT
23880: AND
23881: IFFALSE 24095
// begin if sci >= 6 then
23883: LD_VAR 0 8
23887: PUSH
23888: LD_INT 6
23890: GREATEREQUAL
23891: IFFALSE 23895
// exit ;
23893: GO 26314
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23895: LD_ADDR_EXP 92
23899: PUSH
23900: LD_EXP 92
23904: PPUSH
23905: LD_VAR 0 1
23909: PPUSH
23910: LD_INT 2
23912: PPUSH
23913: CALL_OW 1
23917: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23918: LD_ADDR_VAR 0 9
23922: PUSH
23923: LD_VAR 0 4
23927: PUSH
23928: LD_VAR 0 8
23932: DIFF
23933: PPUSH
23934: LD_INT 4
23936: PPUSH
23937: CALL 84613 0 2
23941: ST_TO_ADDR
// p := [ ] ;
23942: LD_ADDR_VAR 0 11
23946: PUSH
23947: EMPTY
23948: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23949: LD_VAR 0 8
23953: PUSH
23954: LD_INT 6
23956: LESS
23957: PUSH
23958: LD_VAR 0 9
23962: PUSH
23963: LD_INT 6
23965: GREATER
23966: AND
23967: IFFALSE 24048
// begin for i = 1 to 6 - sci do
23969: LD_ADDR_VAR 0 3
23973: PUSH
23974: DOUBLE
23975: LD_INT 1
23977: DEC
23978: ST_TO_ADDR
23979: LD_INT 6
23981: PUSH
23982: LD_VAR 0 8
23986: MINUS
23987: PUSH
23988: FOR_TO
23989: IFFALSE 24044
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23991: LD_ADDR_VAR 0 11
23995: PUSH
23996: LD_VAR 0 11
24000: PPUSH
24001: LD_VAR 0 11
24005: PUSH
24006: LD_INT 1
24008: PLUS
24009: PPUSH
24010: LD_VAR 0 9
24014: PUSH
24015: LD_INT 1
24017: ARRAY
24018: PPUSH
24019: CALL_OW 2
24023: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24024: LD_ADDR_VAR 0 9
24028: PUSH
24029: LD_VAR 0 9
24033: PPUSH
24034: LD_INT 1
24036: PPUSH
24037: CALL_OW 3
24041: ST_TO_ADDR
// end ;
24042: GO 23988
24044: POP
24045: POP
// end else
24046: GO 24068
// if sort then
24048: LD_VAR 0 9
24052: IFFALSE 24068
// p := sort [ 1 ] ;
24054: LD_ADDR_VAR 0 11
24058: PUSH
24059: LD_VAR 0 9
24063: PUSH
24064: LD_INT 1
24066: ARRAY
24067: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24068: LD_ADDR_VAR 0 2
24072: PUSH
24073: LD_INT 0
24075: PUSH
24076: LD_INT 0
24078: PUSH
24079: LD_INT 0
24081: PUSH
24082: LD_VAR 0 11
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: ST_TO_ADDR
// exit ;
24093: GO 26314
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24095: LD_EXP 77
24099: PUSH
24100: LD_EXP 76
24104: PUSH
24105: LD_VAR 0 1
24109: ARRAY
24110: ARRAY
24111: PUSH
24112: LD_EXP 50
24116: PUSH
24117: LD_VAR 0 1
24121: ARRAY
24122: PPUSH
24123: LD_INT 2
24125: PUSH
24126: LD_INT 30
24128: PUSH
24129: LD_INT 6
24131: PUSH
24132: EMPTY
24133: LIST
24134: LIST
24135: PUSH
24136: LD_INT 30
24138: PUSH
24139: LD_INT 7
24141: PUSH
24142: EMPTY
24143: LIST
24144: LIST
24145: PUSH
24146: LD_INT 30
24148: PUSH
24149: LD_INT 8
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: LIST
24160: LIST
24161: PPUSH
24162: CALL_OW 72
24166: AND
24167: PUSH
24168: LD_EXP 50
24172: PUSH
24173: LD_VAR 0 1
24177: ARRAY
24178: PPUSH
24179: LD_INT 30
24181: PUSH
24182: LD_INT 3
24184: PUSH
24185: EMPTY
24186: LIST
24187: LIST
24188: PPUSH
24189: CALL_OW 72
24193: AND
24194: IFFALSE 24928
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24196: LD_ADDR_EXP 92
24200: PUSH
24201: LD_EXP 92
24205: PPUSH
24206: LD_VAR 0 1
24210: PPUSH
24211: LD_INT 3
24213: PPUSH
24214: CALL_OW 1
24218: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24219: LD_ADDR_VAR 0 2
24223: PUSH
24224: LD_INT 0
24226: PUSH
24227: LD_INT 0
24229: PUSH
24230: LD_INT 0
24232: PUSH
24233: LD_INT 0
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: LIST
24240: LIST
24241: ST_TO_ADDR
// if not eng then
24242: LD_VAR 0 6
24246: NOT
24247: IFFALSE 24310
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24249: LD_ADDR_VAR 0 11
24253: PUSH
24254: LD_VAR 0 4
24258: PPUSH
24259: LD_INT 2
24261: PPUSH
24262: CALL 84613 0 2
24266: PUSH
24267: LD_INT 1
24269: ARRAY
24270: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24271: LD_ADDR_VAR 0 2
24275: PUSH
24276: LD_VAR 0 2
24280: PPUSH
24281: LD_INT 2
24283: PPUSH
24284: LD_VAR 0 11
24288: PPUSH
24289: CALL_OW 1
24293: ST_TO_ADDR
// tmp := tmp diff p ;
24294: LD_ADDR_VAR 0 4
24298: PUSH
24299: LD_VAR 0 4
24303: PUSH
24304: LD_VAR 0 11
24308: DIFF
24309: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24310: LD_VAR 0 4
24314: PUSH
24315: LD_VAR 0 8
24319: PUSH
24320: LD_INT 6
24322: LESS
24323: AND
24324: IFFALSE 24512
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24326: LD_ADDR_VAR 0 9
24330: PUSH
24331: LD_VAR 0 4
24335: PUSH
24336: LD_VAR 0 8
24340: PUSH
24341: LD_VAR 0 7
24345: UNION
24346: DIFF
24347: PPUSH
24348: LD_INT 4
24350: PPUSH
24351: CALL 84613 0 2
24355: ST_TO_ADDR
// p := [ ] ;
24356: LD_ADDR_VAR 0 11
24360: PUSH
24361: EMPTY
24362: ST_TO_ADDR
// if sort then
24363: LD_VAR 0 9
24367: IFFALSE 24483
// for i = 1 to 6 - sci do
24369: LD_ADDR_VAR 0 3
24373: PUSH
24374: DOUBLE
24375: LD_INT 1
24377: DEC
24378: ST_TO_ADDR
24379: LD_INT 6
24381: PUSH
24382: LD_VAR 0 8
24386: MINUS
24387: PUSH
24388: FOR_TO
24389: IFFALSE 24481
// begin if i = sort then
24391: LD_VAR 0 3
24395: PUSH
24396: LD_VAR 0 9
24400: EQUAL
24401: IFFALSE 24405
// break ;
24403: GO 24481
// if GetClass ( i ) = 4 then
24405: LD_VAR 0 3
24409: PPUSH
24410: CALL_OW 257
24414: PUSH
24415: LD_INT 4
24417: EQUAL
24418: IFFALSE 24422
// continue ;
24420: GO 24388
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24422: LD_ADDR_VAR 0 11
24426: PUSH
24427: LD_VAR 0 11
24431: PPUSH
24432: LD_VAR 0 11
24436: PUSH
24437: LD_INT 1
24439: PLUS
24440: PPUSH
24441: LD_VAR 0 9
24445: PUSH
24446: LD_VAR 0 3
24450: ARRAY
24451: PPUSH
24452: CALL_OW 2
24456: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24457: LD_ADDR_VAR 0 4
24461: PUSH
24462: LD_VAR 0 4
24466: PUSH
24467: LD_VAR 0 9
24471: PUSH
24472: LD_VAR 0 3
24476: ARRAY
24477: DIFF
24478: ST_TO_ADDR
// end ;
24479: GO 24388
24481: POP
24482: POP
// if p then
24483: LD_VAR 0 11
24487: IFFALSE 24512
// result := Replace ( result , 4 , p ) ;
24489: LD_ADDR_VAR 0 2
24493: PUSH
24494: LD_VAR 0 2
24498: PPUSH
24499: LD_INT 4
24501: PPUSH
24502: LD_VAR 0 11
24506: PPUSH
24507: CALL_OW 1
24511: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24512: LD_VAR 0 4
24516: PUSH
24517: LD_VAR 0 7
24521: PUSH
24522: LD_INT 6
24524: LESS
24525: AND
24526: IFFALSE 24714
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24528: LD_ADDR_VAR 0 9
24532: PUSH
24533: LD_VAR 0 4
24537: PUSH
24538: LD_VAR 0 8
24542: PUSH
24543: LD_VAR 0 7
24547: UNION
24548: DIFF
24549: PPUSH
24550: LD_INT 3
24552: PPUSH
24553: CALL 84613 0 2
24557: ST_TO_ADDR
// p := [ ] ;
24558: LD_ADDR_VAR 0 11
24562: PUSH
24563: EMPTY
24564: ST_TO_ADDR
// if sort then
24565: LD_VAR 0 9
24569: IFFALSE 24685
// for i = 1 to 6 - mech do
24571: LD_ADDR_VAR 0 3
24575: PUSH
24576: DOUBLE
24577: LD_INT 1
24579: DEC
24580: ST_TO_ADDR
24581: LD_INT 6
24583: PUSH
24584: LD_VAR 0 7
24588: MINUS
24589: PUSH
24590: FOR_TO
24591: IFFALSE 24683
// begin if i = sort then
24593: LD_VAR 0 3
24597: PUSH
24598: LD_VAR 0 9
24602: EQUAL
24603: IFFALSE 24607
// break ;
24605: GO 24683
// if GetClass ( i ) = 3 then
24607: LD_VAR 0 3
24611: PPUSH
24612: CALL_OW 257
24616: PUSH
24617: LD_INT 3
24619: EQUAL
24620: IFFALSE 24624
// continue ;
24622: GO 24590
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24624: LD_ADDR_VAR 0 11
24628: PUSH
24629: LD_VAR 0 11
24633: PPUSH
24634: LD_VAR 0 11
24638: PUSH
24639: LD_INT 1
24641: PLUS
24642: PPUSH
24643: LD_VAR 0 9
24647: PUSH
24648: LD_VAR 0 3
24652: ARRAY
24653: PPUSH
24654: CALL_OW 2
24658: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24659: LD_ADDR_VAR 0 4
24663: PUSH
24664: LD_VAR 0 4
24668: PUSH
24669: LD_VAR 0 9
24673: PUSH
24674: LD_VAR 0 3
24678: ARRAY
24679: DIFF
24680: ST_TO_ADDR
// end ;
24681: GO 24590
24683: POP
24684: POP
// if p then
24685: LD_VAR 0 11
24689: IFFALSE 24714
// result := Replace ( result , 3 , p ) ;
24691: LD_ADDR_VAR 0 2
24695: PUSH
24696: LD_VAR 0 2
24700: PPUSH
24701: LD_INT 3
24703: PPUSH
24704: LD_VAR 0 11
24708: PPUSH
24709: CALL_OW 1
24713: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24714: LD_VAR 0 4
24718: PUSH
24719: LD_INT 6
24721: GREATER
24722: PUSH
24723: LD_VAR 0 6
24727: PUSH
24728: LD_INT 6
24730: LESS
24731: AND
24732: IFFALSE 24926
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24734: LD_ADDR_VAR 0 9
24738: PUSH
24739: LD_VAR 0 4
24743: PUSH
24744: LD_VAR 0 8
24748: PUSH
24749: LD_VAR 0 7
24753: UNION
24754: PUSH
24755: LD_VAR 0 6
24759: UNION
24760: DIFF
24761: PPUSH
24762: LD_INT 2
24764: PPUSH
24765: CALL 84613 0 2
24769: ST_TO_ADDR
// p := [ ] ;
24770: LD_ADDR_VAR 0 11
24774: PUSH
24775: EMPTY
24776: ST_TO_ADDR
// if sort then
24777: LD_VAR 0 9
24781: IFFALSE 24897
// for i = 1 to 6 - eng do
24783: LD_ADDR_VAR 0 3
24787: PUSH
24788: DOUBLE
24789: LD_INT 1
24791: DEC
24792: ST_TO_ADDR
24793: LD_INT 6
24795: PUSH
24796: LD_VAR 0 6
24800: MINUS
24801: PUSH
24802: FOR_TO
24803: IFFALSE 24895
// begin if i = sort then
24805: LD_VAR 0 3
24809: PUSH
24810: LD_VAR 0 9
24814: EQUAL
24815: IFFALSE 24819
// break ;
24817: GO 24895
// if GetClass ( i ) = 2 then
24819: LD_VAR 0 3
24823: PPUSH
24824: CALL_OW 257
24828: PUSH
24829: LD_INT 2
24831: EQUAL
24832: IFFALSE 24836
// continue ;
24834: GO 24802
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24836: LD_ADDR_VAR 0 11
24840: PUSH
24841: LD_VAR 0 11
24845: PPUSH
24846: LD_VAR 0 11
24850: PUSH
24851: LD_INT 1
24853: PLUS
24854: PPUSH
24855: LD_VAR 0 9
24859: PUSH
24860: LD_VAR 0 3
24864: ARRAY
24865: PPUSH
24866: CALL_OW 2
24870: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24871: LD_ADDR_VAR 0 4
24875: PUSH
24876: LD_VAR 0 4
24880: PUSH
24881: LD_VAR 0 9
24885: PUSH
24886: LD_VAR 0 3
24890: ARRAY
24891: DIFF
24892: ST_TO_ADDR
// end ;
24893: GO 24802
24895: POP
24896: POP
// if p then
24897: LD_VAR 0 11
24901: IFFALSE 24926
// result := Replace ( result , 2 , p ) ;
24903: LD_ADDR_VAR 0 2
24907: PUSH
24908: LD_VAR 0 2
24912: PPUSH
24913: LD_INT 2
24915: PPUSH
24916: LD_VAR 0 11
24920: PPUSH
24921: CALL_OW 1
24925: ST_TO_ADDR
// end ; exit ;
24926: GO 26314
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24928: LD_EXP 77
24932: PUSH
24933: LD_EXP 76
24937: PUSH
24938: LD_VAR 0 1
24942: ARRAY
24943: ARRAY
24944: NOT
24945: PUSH
24946: LD_EXP 50
24950: PUSH
24951: LD_VAR 0 1
24955: ARRAY
24956: PPUSH
24957: LD_INT 30
24959: PUSH
24960: LD_INT 3
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PPUSH
24967: CALL_OW 72
24971: AND
24972: PUSH
24973: LD_EXP 55
24977: PUSH
24978: LD_VAR 0 1
24982: ARRAY
24983: AND
24984: IFFALSE 25592
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24986: LD_ADDR_EXP 92
24990: PUSH
24991: LD_EXP 92
24995: PPUSH
24996: LD_VAR 0 1
25000: PPUSH
25001: LD_INT 5
25003: PPUSH
25004: CALL_OW 1
25008: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25009: LD_ADDR_VAR 0 2
25013: PUSH
25014: LD_INT 0
25016: PUSH
25017: LD_INT 0
25019: PUSH
25020: LD_INT 0
25022: PUSH
25023: LD_INT 0
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: LIST
25030: LIST
25031: ST_TO_ADDR
// if sci > 1 then
25032: LD_VAR 0 8
25036: PUSH
25037: LD_INT 1
25039: GREATER
25040: IFFALSE 25068
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25042: LD_ADDR_VAR 0 4
25046: PUSH
25047: LD_VAR 0 4
25051: PUSH
25052: LD_VAR 0 8
25056: PUSH
25057: LD_VAR 0 8
25061: PUSH
25062: LD_INT 1
25064: ARRAY
25065: DIFF
25066: DIFF
25067: ST_TO_ADDR
// if tmp and not sci then
25068: LD_VAR 0 4
25072: PUSH
25073: LD_VAR 0 8
25077: NOT
25078: AND
25079: IFFALSE 25148
// begin sort := SortBySkill ( tmp , 4 ) ;
25081: LD_ADDR_VAR 0 9
25085: PUSH
25086: LD_VAR 0 4
25090: PPUSH
25091: LD_INT 4
25093: PPUSH
25094: CALL 84613 0 2
25098: ST_TO_ADDR
// if sort then
25099: LD_VAR 0 9
25103: IFFALSE 25119
// p := sort [ 1 ] ;
25105: LD_ADDR_VAR 0 11
25109: PUSH
25110: LD_VAR 0 9
25114: PUSH
25115: LD_INT 1
25117: ARRAY
25118: ST_TO_ADDR
// if p then
25119: LD_VAR 0 11
25123: IFFALSE 25148
// result := Replace ( result , 4 , p ) ;
25125: LD_ADDR_VAR 0 2
25129: PUSH
25130: LD_VAR 0 2
25134: PPUSH
25135: LD_INT 4
25137: PPUSH
25138: LD_VAR 0 11
25142: PPUSH
25143: CALL_OW 1
25147: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25148: LD_ADDR_VAR 0 4
25152: PUSH
25153: LD_VAR 0 4
25157: PUSH
25158: LD_VAR 0 7
25162: DIFF
25163: ST_TO_ADDR
// if tmp and mech < 6 then
25164: LD_VAR 0 4
25168: PUSH
25169: LD_VAR 0 7
25173: PUSH
25174: LD_INT 6
25176: LESS
25177: AND
25178: IFFALSE 25366
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25180: LD_ADDR_VAR 0 9
25184: PUSH
25185: LD_VAR 0 4
25189: PUSH
25190: LD_VAR 0 8
25194: PUSH
25195: LD_VAR 0 7
25199: UNION
25200: DIFF
25201: PPUSH
25202: LD_INT 3
25204: PPUSH
25205: CALL 84613 0 2
25209: ST_TO_ADDR
// p := [ ] ;
25210: LD_ADDR_VAR 0 11
25214: PUSH
25215: EMPTY
25216: ST_TO_ADDR
// if sort then
25217: LD_VAR 0 9
25221: IFFALSE 25337
// for i = 1 to 6 - mech do
25223: LD_ADDR_VAR 0 3
25227: PUSH
25228: DOUBLE
25229: LD_INT 1
25231: DEC
25232: ST_TO_ADDR
25233: LD_INT 6
25235: PUSH
25236: LD_VAR 0 7
25240: MINUS
25241: PUSH
25242: FOR_TO
25243: IFFALSE 25335
// begin if i = sort then
25245: LD_VAR 0 3
25249: PUSH
25250: LD_VAR 0 9
25254: EQUAL
25255: IFFALSE 25259
// break ;
25257: GO 25335
// if GetClass ( i ) = 3 then
25259: LD_VAR 0 3
25263: PPUSH
25264: CALL_OW 257
25268: PUSH
25269: LD_INT 3
25271: EQUAL
25272: IFFALSE 25276
// continue ;
25274: GO 25242
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25276: LD_ADDR_VAR 0 11
25280: PUSH
25281: LD_VAR 0 11
25285: PPUSH
25286: LD_VAR 0 11
25290: PUSH
25291: LD_INT 1
25293: PLUS
25294: PPUSH
25295: LD_VAR 0 9
25299: PUSH
25300: LD_VAR 0 3
25304: ARRAY
25305: PPUSH
25306: CALL_OW 2
25310: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25311: LD_ADDR_VAR 0 4
25315: PUSH
25316: LD_VAR 0 4
25320: PUSH
25321: LD_VAR 0 9
25325: PUSH
25326: LD_VAR 0 3
25330: ARRAY
25331: DIFF
25332: ST_TO_ADDR
// end ;
25333: GO 25242
25335: POP
25336: POP
// if p then
25337: LD_VAR 0 11
25341: IFFALSE 25366
// result := Replace ( result , 3 , p ) ;
25343: LD_ADDR_VAR 0 2
25347: PUSH
25348: LD_VAR 0 2
25352: PPUSH
25353: LD_INT 3
25355: PPUSH
25356: LD_VAR 0 11
25360: PPUSH
25361: CALL_OW 1
25365: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25366: LD_ADDR_VAR 0 4
25370: PUSH
25371: LD_VAR 0 4
25375: PUSH
25376: LD_VAR 0 6
25380: DIFF
25381: ST_TO_ADDR
// if tmp and eng < 6 then
25382: LD_VAR 0 4
25386: PUSH
25387: LD_VAR 0 6
25391: PUSH
25392: LD_INT 6
25394: LESS
25395: AND
25396: IFFALSE 25590
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25398: LD_ADDR_VAR 0 9
25402: PUSH
25403: LD_VAR 0 4
25407: PUSH
25408: LD_VAR 0 8
25412: PUSH
25413: LD_VAR 0 7
25417: UNION
25418: PUSH
25419: LD_VAR 0 6
25423: UNION
25424: DIFF
25425: PPUSH
25426: LD_INT 2
25428: PPUSH
25429: CALL 84613 0 2
25433: ST_TO_ADDR
// p := [ ] ;
25434: LD_ADDR_VAR 0 11
25438: PUSH
25439: EMPTY
25440: ST_TO_ADDR
// if sort then
25441: LD_VAR 0 9
25445: IFFALSE 25561
// for i = 1 to 6 - eng do
25447: LD_ADDR_VAR 0 3
25451: PUSH
25452: DOUBLE
25453: LD_INT 1
25455: DEC
25456: ST_TO_ADDR
25457: LD_INT 6
25459: PUSH
25460: LD_VAR 0 6
25464: MINUS
25465: PUSH
25466: FOR_TO
25467: IFFALSE 25559
// begin if i = sort then
25469: LD_VAR 0 3
25473: PUSH
25474: LD_VAR 0 9
25478: EQUAL
25479: IFFALSE 25483
// break ;
25481: GO 25559
// if GetClass ( i ) = 2 then
25483: LD_VAR 0 3
25487: PPUSH
25488: CALL_OW 257
25492: PUSH
25493: LD_INT 2
25495: EQUAL
25496: IFFALSE 25500
// continue ;
25498: GO 25466
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25500: LD_ADDR_VAR 0 11
25504: PUSH
25505: LD_VAR 0 11
25509: PPUSH
25510: LD_VAR 0 11
25514: PUSH
25515: LD_INT 1
25517: PLUS
25518: PPUSH
25519: LD_VAR 0 9
25523: PUSH
25524: LD_VAR 0 3
25528: ARRAY
25529: PPUSH
25530: CALL_OW 2
25534: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25535: LD_ADDR_VAR 0 4
25539: PUSH
25540: LD_VAR 0 4
25544: PUSH
25545: LD_VAR 0 9
25549: PUSH
25550: LD_VAR 0 3
25554: ARRAY
25555: DIFF
25556: ST_TO_ADDR
// end ;
25557: GO 25466
25559: POP
25560: POP
// if p then
25561: LD_VAR 0 11
25565: IFFALSE 25590
// result := Replace ( result , 2 , p ) ;
25567: LD_ADDR_VAR 0 2
25571: PUSH
25572: LD_VAR 0 2
25576: PPUSH
25577: LD_INT 2
25579: PPUSH
25580: LD_VAR 0 11
25584: PPUSH
25585: CALL_OW 1
25589: ST_TO_ADDR
// end ; exit ;
25590: GO 26314
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25592: LD_EXP 77
25596: PUSH
25597: LD_EXP 76
25601: PUSH
25602: LD_VAR 0 1
25606: ARRAY
25607: ARRAY
25608: NOT
25609: PUSH
25610: LD_EXP 50
25614: PUSH
25615: LD_VAR 0 1
25619: ARRAY
25620: PPUSH
25621: LD_INT 30
25623: PUSH
25624: LD_INT 3
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PPUSH
25631: CALL_OW 72
25635: AND
25636: PUSH
25637: LD_EXP 55
25641: PUSH
25642: LD_VAR 0 1
25646: ARRAY
25647: NOT
25648: AND
25649: IFFALSE 26314
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25651: LD_ADDR_EXP 92
25655: PUSH
25656: LD_EXP 92
25660: PPUSH
25661: LD_VAR 0 1
25665: PPUSH
25666: LD_INT 6
25668: PPUSH
25669: CALL_OW 1
25673: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25674: LD_ADDR_VAR 0 2
25678: PUSH
25679: LD_INT 0
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: LD_INT 0
25687: PUSH
25688: LD_INT 0
25690: PUSH
25691: EMPTY
25692: LIST
25693: LIST
25694: LIST
25695: LIST
25696: ST_TO_ADDR
// if sci >= 1 then
25697: LD_VAR 0 8
25701: PUSH
25702: LD_INT 1
25704: GREATEREQUAL
25705: IFFALSE 25727
// tmp := tmp diff sci [ 1 ] ;
25707: LD_ADDR_VAR 0 4
25711: PUSH
25712: LD_VAR 0 4
25716: PUSH
25717: LD_VAR 0 8
25721: PUSH
25722: LD_INT 1
25724: ARRAY
25725: DIFF
25726: ST_TO_ADDR
// if tmp and not sci then
25727: LD_VAR 0 4
25731: PUSH
25732: LD_VAR 0 8
25736: NOT
25737: AND
25738: IFFALSE 25807
// begin sort := SortBySkill ( tmp , 4 ) ;
25740: LD_ADDR_VAR 0 9
25744: PUSH
25745: LD_VAR 0 4
25749: PPUSH
25750: LD_INT 4
25752: PPUSH
25753: CALL 84613 0 2
25757: ST_TO_ADDR
// if sort then
25758: LD_VAR 0 9
25762: IFFALSE 25778
// p := sort [ 1 ] ;
25764: LD_ADDR_VAR 0 11
25768: PUSH
25769: LD_VAR 0 9
25773: PUSH
25774: LD_INT 1
25776: ARRAY
25777: ST_TO_ADDR
// if p then
25778: LD_VAR 0 11
25782: IFFALSE 25807
// result := Replace ( result , 4 , p ) ;
25784: LD_ADDR_VAR 0 2
25788: PUSH
25789: LD_VAR 0 2
25793: PPUSH
25794: LD_INT 4
25796: PPUSH
25797: LD_VAR 0 11
25801: PPUSH
25802: CALL_OW 1
25806: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25807: LD_ADDR_VAR 0 4
25811: PUSH
25812: LD_VAR 0 4
25816: PUSH
25817: LD_VAR 0 7
25821: DIFF
25822: ST_TO_ADDR
// if tmp and mech < 6 then
25823: LD_VAR 0 4
25827: PUSH
25828: LD_VAR 0 7
25832: PUSH
25833: LD_INT 6
25835: LESS
25836: AND
25837: IFFALSE 26019
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25839: LD_ADDR_VAR 0 9
25843: PUSH
25844: LD_VAR 0 4
25848: PUSH
25849: LD_VAR 0 7
25853: DIFF
25854: PPUSH
25855: LD_INT 3
25857: PPUSH
25858: CALL 84613 0 2
25862: ST_TO_ADDR
// p := [ ] ;
25863: LD_ADDR_VAR 0 11
25867: PUSH
25868: EMPTY
25869: ST_TO_ADDR
// if sort then
25870: LD_VAR 0 9
25874: IFFALSE 25990
// for i = 1 to 6 - mech do
25876: LD_ADDR_VAR 0 3
25880: PUSH
25881: DOUBLE
25882: LD_INT 1
25884: DEC
25885: ST_TO_ADDR
25886: LD_INT 6
25888: PUSH
25889: LD_VAR 0 7
25893: MINUS
25894: PUSH
25895: FOR_TO
25896: IFFALSE 25988
// begin if i = sort then
25898: LD_VAR 0 3
25902: PUSH
25903: LD_VAR 0 9
25907: EQUAL
25908: IFFALSE 25912
// break ;
25910: GO 25988
// if GetClass ( i ) = 3 then
25912: LD_VAR 0 3
25916: PPUSH
25917: CALL_OW 257
25921: PUSH
25922: LD_INT 3
25924: EQUAL
25925: IFFALSE 25929
// continue ;
25927: GO 25895
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25929: LD_ADDR_VAR 0 11
25933: PUSH
25934: LD_VAR 0 11
25938: PPUSH
25939: LD_VAR 0 11
25943: PUSH
25944: LD_INT 1
25946: PLUS
25947: PPUSH
25948: LD_VAR 0 9
25952: PUSH
25953: LD_VAR 0 3
25957: ARRAY
25958: PPUSH
25959: CALL_OW 2
25963: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25964: LD_ADDR_VAR 0 4
25968: PUSH
25969: LD_VAR 0 4
25973: PUSH
25974: LD_VAR 0 9
25978: PUSH
25979: LD_VAR 0 3
25983: ARRAY
25984: DIFF
25985: ST_TO_ADDR
// end ;
25986: GO 25895
25988: POP
25989: POP
// if p then
25990: LD_VAR 0 11
25994: IFFALSE 26019
// result := Replace ( result , 3 , p ) ;
25996: LD_ADDR_VAR 0 2
26000: PUSH
26001: LD_VAR 0 2
26005: PPUSH
26006: LD_INT 3
26008: PPUSH
26009: LD_VAR 0 11
26013: PPUSH
26014: CALL_OW 1
26018: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26019: LD_ADDR_VAR 0 4
26023: PUSH
26024: LD_VAR 0 4
26028: PUSH
26029: LD_VAR 0 6
26033: DIFF
26034: ST_TO_ADDR
// if tmp and eng < 4 then
26035: LD_VAR 0 4
26039: PUSH
26040: LD_VAR 0 6
26044: PUSH
26045: LD_INT 4
26047: LESS
26048: AND
26049: IFFALSE 26239
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26051: LD_ADDR_VAR 0 9
26055: PUSH
26056: LD_VAR 0 4
26060: PUSH
26061: LD_VAR 0 7
26065: PUSH
26066: LD_VAR 0 6
26070: UNION
26071: DIFF
26072: PPUSH
26073: LD_INT 2
26075: PPUSH
26076: CALL 84613 0 2
26080: ST_TO_ADDR
// p := [ ] ;
26081: LD_ADDR_VAR 0 11
26085: PUSH
26086: EMPTY
26087: ST_TO_ADDR
// if sort then
26088: LD_VAR 0 9
26092: IFFALSE 26208
// for i = 1 to 4 - eng do
26094: LD_ADDR_VAR 0 3
26098: PUSH
26099: DOUBLE
26100: LD_INT 1
26102: DEC
26103: ST_TO_ADDR
26104: LD_INT 4
26106: PUSH
26107: LD_VAR 0 6
26111: MINUS
26112: PUSH
26113: FOR_TO
26114: IFFALSE 26206
// begin if i = sort then
26116: LD_VAR 0 3
26120: PUSH
26121: LD_VAR 0 9
26125: EQUAL
26126: IFFALSE 26130
// break ;
26128: GO 26206
// if GetClass ( i ) = 2 then
26130: LD_VAR 0 3
26134: PPUSH
26135: CALL_OW 257
26139: PUSH
26140: LD_INT 2
26142: EQUAL
26143: IFFALSE 26147
// continue ;
26145: GO 26113
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26147: LD_ADDR_VAR 0 11
26151: PUSH
26152: LD_VAR 0 11
26156: PPUSH
26157: LD_VAR 0 11
26161: PUSH
26162: LD_INT 1
26164: PLUS
26165: PPUSH
26166: LD_VAR 0 9
26170: PUSH
26171: LD_VAR 0 3
26175: ARRAY
26176: PPUSH
26177: CALL_OW 2
26181: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26182: LD_ADDR_VAR 0 4
26186: PUSH
26187: LD_VAR 0 4
26191: PUSH
26192: LD_VAR 0 9
26196: PUSH
26197: LD_VAR 0 3
26201: ARRAY
26202: DIFF
26203: ST_TO_ADDR
// end ;
26204: GO 26113
26206: POP
26207: POP
// if p then
26208: LD_VAR 0 11
26212: IFFALSE 26237
// result := Replace ( result , 2 , p ) ;
26214: LD_ADDR_VAR 0 2
26218: PUSH
26219: LD_VAR 0 2
26223: PPUSH
26224: LD_INT 2
26226: PPUSH
26227: LD_VAR 0 11
26231: PPUSH
26232: CALL_OW 1
26236: ST_TO_ADDR
// end else
26237: GO 26283
// for i = eng downto 5 do
26239: LD_ADDR_VAR 0 3
26243: PUSH
26244: DOUBLE
26245: LD_VAR 0 6
26249: INC
26250: ST_TO_ADDR
26251: LD_INT 5
26253: PUSH
26254: FOR_DOWNTO
26255: IFFALSE 26281
// tmp := tmp union eng [ i ] ;
26257: LD_ADDR_VAR 0 4
26261: PUSH
26262: LD_VAR 0 4
26266: PUSH
26267: LD_VAR 0 6
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: UNION
26278: ST_TO_ADDR
26279: GO 26254
26281: POP
26282: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26283: LD_ADDR_VAR 0 2
26287: PUSH
26288: LD_VAR 0 2
26292: PPUSH
26293: LD_INT 1
26295: PPUSH
26296: LD_VAR 0 4
26300: PUSH
26301: LD_VAR 0 5
26305: DIFF
26306: PPUSH
26307: CALL_OW 1
26311: ST_TO_ADDR
// exit ;
26312: GO 26314
// end ; end ;
26314: LD_VAR 0 2
26318: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26319: LD_INT 0
26321: PPUSH
26322: PPUSH
26323: PPUSH
// if not mc_bases then
26324: LD_EXP 50
26328: NOT
26329: IFFALSE 26333
// exit ;
26331: GO 26475
// for i = 1 to mc_bases do
26333: LD_ADDR_VAR 0 2
26337: PUSH
26338: DOUBLE
26339: LD_INT 1
26341: DEC
26342: ST_TO_ADDR
26343: LD_EXP 50
26347: PUSH
26348: FOR_TO
26349: IFFALSE 26466
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26351: LD_ADDR_VAR 0 3
26355: PUSH
26356: LD_EXP 50
26360: PUSH
26361: LD_VAR 0 2
26365: ARRAY
26366: PPUSH
26367: LD_INT 21
26369: PUSH
26370: LD_INT 3
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PUSH
26377: LD_INT 3
26379: PUSH
26380: LD_INT 2
26382: PUSH
26383: LD_INT 30
26385: PUSH
26386: LD_INT 29
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 30
26395: PUSH
26396: LD_INT 30
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: LIST
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PUSH
26412: LD_INT 3
26414: PUSH
26415: LD_INT 24
26417: PUSH
26418: LD_INT 1000
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: LIST
26433: PPUSH
26434: CALL_OW 72
26438: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26439: LD_ADDR_EXP 51
26443: PUSH
26444: LD_EXP 51
26448: PPUSH
26449: LD_VAR 0 2
26453: PPUSH
26454: LD_VAR 0 3
26458: PPUSH
26459: CALL_OW 1
26463: ST_TO_ADDR
// end ;
26464: GO 26348
26466: POP
26467: POP
// RaiseSailEvent ( 101 ) ;
26468: LD_INT 101
26470: PPUSH
26471: CALL_OW 427
// end ;
26475: LD_VAR 0 1
26479: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26480: LD_INT 0
26482: PPUSH
26483: PPUSH
26484: PPUSH
26485: PPUSH
26486: PPUSH
26487: PPUSH
26488: PPUSH
// if not mc_bases then
26489: LD_EXP 50
26493: NOT
26494: IFFALSE 26498
// exit ;
26496: GO 27060
// for i = 1 to mc_bases do
26498: LD_ADDR_VAR 0 2
26502: PUSH
26503: DOUBLE
26504: LD_INT 1
26506: DEC
26507: ST_TO_ADDR
26508: LD_EXP 50
26512: PUSH
26513: FOR_TO
26514: IFFALSE 27051
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26516: LD_ADDR_VAR 0 5
26520: PUSH
26521: LD_EXP 50
26525: PUSH
26526: LD_VAR 0 2
26530: ARRAY
26531: PUSH
26532: LD_EXP 79
26536: PUSH
26537: LD_VAR 0 2
26541: ARRAY
26542: UNION
26543: PPUSH
26544: LD_INT 21
26546: PUSH
26547: LD_INT 1
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: PUSH
26554: LD_INT 1
26556: PUSH
26557: LD_INT 3
26559: PUSH
26560: LD_INT 54
26562: PUSH
26563: EMPTY
26564: LIST
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: LD_INT 3
26572: PUSH
26573: LD_INT 24
26575: PUSH
26576: LD_INT 1000
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: LIST
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: PPUSH
26596: CALL_OW 72
26600: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26601: LD_ADDR_VAR 0 6
26605: PUSH
26606: LD_EXP 50
26610: PUSH
26611: LD_VAR 0 2
26615: ARRAY
26616: PPUSH
26617: LD_INT 21
26619: PUSH
26620: LD_INT 1
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 1
26629: PUSH
26630: LD_INT 3
26632: PUSH
26633: LD_INT 54
26635: PUSH
26636: EMPTY
26637: LIST
26638: PUSH
26639: EMPTY
26640: LIST
26641: LIST
26642: PUSH
26643: LD_INT 3
26645: PUSH
26646: LD_INT 24
26648: PUSH
26649: LD_INT 250
26651: PUSH
26652: EMPTY
26653: LIST
26654: LIST
26655: PUSH
26656: EMPTY
26657: LIST
26658: LIST
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: LIST
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PPUSH
26669: CALL_OW 72
26673: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26674: LD_ADDR_VAR 0 7
26678: PUSH
26679: LD_VAR 0 5
26683: PUSH
26684: LD_VAR 0 6
26688: DIFF
26689: ST_TO_ADDR
// if not need_heal_1 then
26690: LD_VAR 0 6
26694: NOT
26695: IFFALSE 26728
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26697: LD_ADDR_EXP 53
26701: PUSH
26702: LD_EXP 53
26706: PPUSH
26707: LD_VAR 0 2
26711: PUSH
26712: LD_INT 1
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PPUSH
26719: EMPTY
26720: PPUSH
26721: CALL 53792 0 3
26725: ST_TO_ADDR
26726: GO 26798
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26728: LD_ADDR_EXP 53
26732: PUSH
26733: LD_EXP 53
26737: PPUSH
26738: LD_VAR 0 2
26742: PUSH
26743: LD_INT 1
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PPUSH
26750: LD_EXP 53
26754: PUSH
26755: LD_VAR 0 2
26759: ARRAY
26760: PUSH
26761: LD_INT 1
26763: ARRAY
26764: PPUSH
26765: LD_INT 3
26767: PUSH
26768: LD_INT 24
26770: PUSH
26771: LD_INT 1000
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PPUSH
26782: CALL_OW 72
26786: PUSH
26787: LD_VAR 0 6
26791: UNION
26792: PPUSH
26793: CALL 53792 0 3
26797: ST_TO_ADDR
// if not need_heal_2 then
26798: LD_VAR 0 7
26802: NOT
26803: IFFALSE 26836
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26805: LD_ADDR_EXP 53
26809: PUSH
26810: LD_EXP 53
26814: PPUSH
26815: LD_VAR 0 2
26819: PUSH
26820: LD_INT 2
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: PPUSH
26827: EMPTY
26828: PPUSH
26829: CALL 53792 0 3
26833: ST_TO_ADDR
26834: GO 26868
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26836: LD_ADDR_EXP 53
26840: PUSH
26841: LD_EXP 53
26845: PPUSH
26846: LD_VAR 0 2
26850: PUSH
26851: LD_INT 2
26853: PUSH
26854: EMPTY
26855: LIST
26856: LIST
26857: PPUSH
26858: LD_VAR 0 7
26862: PPUSH
26863: CALL 53792 0 3
26867: ST_TO_ADDR
// if need_heal_2 then
26868: LD_VAR 0 7
26872: IFFALSE 27033
// for j in need_heal_2 do
26874: LD_ADDR_VAR 0 3
26878: PUSH
26879: LD_VAR 0 7
26883: PUSH
26884: FOR_IN
26885: IFFALSE 27031
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26887: LD_ADDR_VAR 0 5
26891: PUSH
26892: LD_EXP 50
26896: PUSH
26897: LD_VAR 0 2
26901: ARRAY
26902: PPUSH
26903: LD_INT 2
26905: PUSH
26906: LD_INT 30
26908: PUSH
26909: LD_INT 6
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: PUSH
26916: LD_INT 30
26918: PUSH
26919: LD_INT 7
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: PUSH
26926: LD_INT 30
26928: PUSH
26929: LD_INT 8
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: PUSH
26936: LD_INT 30
26938: PUSH
26939: LD_INT 0
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 30
26948: PUSH
26949: LD_INT 1
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: LIST
26960: LIST
26961: LIST
26962: LIST
26963: PPUSH
26964: CALL_OW 72
26968: ST_TO_ADDR
// if tmp then
26969: LD_VAR 0 5
26973: IFFALSE 27029
// begin k := NearestUnitToUnit ( tmp , j ) ;
26975: LD_ADDR_VAR 0 4
26979: PUSH
26980: LD_VAR 0 5
26984: PPUSH
26985: LD_VAR 0 3
26989: PPUSH
26990: CALL_OW 74
26994: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26995: LD_VAR 0 3
26999: PPUSH
27000: LD_VAR 0 4
27004: PPUSH
27005: CALL_OW 296
27009: PUSH
27010: LD_INT 5
27012: GREATER
27013: IFFALSE 27029
// ComMoveToNearbyEntrance ( j , k ) ;
27015: LD_VAR 0 3
27019: PPUSH
27020: LD_VAR 0 4
27024: PPUSH
27025: CALL 86981 0 2
// end ; end ;
27029: GO 26884
27031: POP
27032: POP
// if not need_heal_1 and not need_heal_2 then
27033: LD_VAR 0 6
27037: NOT
27038: PUSH
27039: LD_VAR 0 7
27043: NOT
27044: AND
27045: IFFALSE 27049
// continue ;
27047: GO 26513
// end ;
27049: GO 26513
27051: POP
27052: POP
// RaiseSailEvent ( 102 ) ;
27053: LD_INT 102
27055: PPUSH
27056: CALL_OW 427
// end ;
27060: LD_VAR 0 1
27064: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27065: LD_INT 0
27067: PPUSH
27068: PPUSH
27069: PPUSH
27070: PPUSH
27071: PPUSH
27072: PPUSH
27073: PPUSH
27074: PPUSH
// if not mc_bases then
27075: LD_EXP 50
27079: NOT
27080: IFFALSE 27084
// exit ;
27082: GO 27995
// for i = 1 to mc_bases do
27084: LD_ADDR_VAR 0 2
27088: PUSH
27089: DOUBLE
27090: LD_INT 1
27092: DEC
27093: ST_TO_ADDR
27094: LD_EXP 50
27098: PUSH
27099: FOR_TO
27100: IFFALSE 27993
// begin if not mc_building_need_repair [ i ] then
27102: LD_EXP 51
27106: PUSH
27107: LD_VAR 0 2
27111: ARRAY
27112: NOT
27113: IFFALSE 27298
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27115: LD_ADDR_VAR 0 6
27119: PUSH
27120: LD_EXP 69
27124: PUSH
27125: LD_VAR 0 2
27129: ARRAY
27130: PPUSH
27131: LD_INT 3
27133: PUSH
27134: LD_INT 24
27136: PUSH
27137: LD_INT 1000
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 2
27150: PUSH
27151: LD_INT 34
27153: PUSH
27154: LD_INT 13
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 34
27163: PUSH
27164: LD_INT 52
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 34
27173: PUSH
27174: LD_INT 88
27176: PUSH
27177: EMPTY
27178: LIST
27179: LIST
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: LIST
27185: LIST
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PPUSH
27191: CALL_OW 72
27195: ST_TO_ADDR
// if cranes then
27196: LD_VAR 0 6
27200: IFFALSE 27262
// for j in cranes do
27202: LD_ADDR_VAR 0 3
27206: PUSH
27207: LD_VAR 0 6
27211: PUSH
27212: FOR_IN
27213: IFFALSE 27260
// if not IsInArea ( j , mc_parking [ i ] ) then
27215: LD_VAR 0 3
27219: PPUSH
27220: LD_EXP 74
27224: PUSH
27225: LD_VAR 0 2
27229: ARRAY
27230: PPUSH
27231: CALL_OW 308
27235: NOT
27236: IFFALSE 27258
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27238: LD_VAR 0 3
27242: PPUSH
27243: LD_EXP 74
27247: PUSH
27248: LD_VAR 0 2
27252: ARRAY
27253: PPUSH
27254: CALL_OW 113
27258: GO 27212
27260: POP
27261: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27262: LD_ADDR_EXP 52
27266: PUSH
27267: LD_EXP 52
27271: PPUSH
27272: LD_VAR 0 2
27276: PPUSH
27277: EMPTY
27278: PPUSH
27279: CALL_OW 1
27283: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27284: LD_VAR 0 2
27288: PPUSH
27289: LD_INT 101
27291: PPUSH
27292: CALL 22152 0 2
// continue ;
27296: GO 27099
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27298: LD_ADDR_EXP 56
27302: PUSH
27303: LD_EXP 56
27307: PPUSH
27308: LD_VAR 0 2
27312: PPUSH
27313: EMPTY
27314: PPUSH
27315: CALL_OW 1
27319: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27320: LD_VAR 0 2
27324: PPUSH
27325: LD_INT 103
27327: PPUSH
27328: CALL 22152 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27332: LD_ADDR_VAR 0 5
27336: PUSH
27337: LD_EXP 50
27341: PUSH
27342: LD_VAR 0 2
27346: ARRAY
27347: PUSH
27348: LD_EXP 79
27352: PUSH
27353: LD_VAR 0 2
27357: ARRAY
27358: UNION
27359: PPUSH
27360: LD_INT 2
27362: PUSH
27363: LD_INT 25
27365: PUSH
27366: LD_INT 2
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: LD_INT 25
27375: PUSH
27376: LD_INT 16
27378: PUSH
27379: EMPTY
27380: LIST
27381: LIST
27382: PUSH
27383: EMPTY
27384: LIST
27385: LIST
27386: LIST
27387: PUSH
27388: EMPTY
27389: LIST
27390: PPUSH
27391: CALL_OW 72
27395: ST_TO_ADDR
// if mc_need_heal [ i ] then
27396: LD_EXP 53
27400: PUSH
27401: LD_VAR 0 2
27405: ARRAY
27406: IFFALSE 27450
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27408: LD_ADDR_VAR 0 5
27412: PUSH
27413: LD_VAR 0 5
27417: PUSH
27418: LD_EXP 53
27422: PUSH
27423: LD_VAR 0 2
27427: ARRAY
27428: PUSH
27429: LD_INT 1
27431: ARRAY
27432: PUSH
27433: LD_EXP 53
27437: PUSH
27438: LD_VAR 0 2
27442: ARRAY
27443: PUSH
27444: LD_INT 2
27446: ARRAY
27447: UNION
27448: DIFF
27449: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27450: LD_ADDR_VAR 0 6
27454: PUSH
27455: LD_EXP 69
27459: PUSH
27460: LD_VAR 0 2
27464: ARRAY
27465: PPUSH
27466: LD_INT 2
27468: PUSH
27469: LD_INT 34
27471: PUSH
27472: LD_INT 13
27474: PUSH
27475: EMPTY
27476: LIST
27477: LIST
27478: PUSH
27479: LD_INT 34
27481: PUSH
27482: LD_INT 52
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: LD_INT 34
27491: PUSH
27492: LD_INT 88
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PUSH
27499: EMPTY
27500: LIST
27501: LIST
27502: LIST
27503: LIST
27504: PPUSH
27505: CALL_OW 72
27509: ST_TO_ADDR
// if cranes then
27510: LD_VAR 0 6
27514: IFFALSE 27682
// begin for j in cranes do
27516: LD_ADDR_VAR 0 3
27520: PUSH
27521: LD_VAR 0 6
27525: PUSH
27526: FOR_IN
27527: IFFALSE 27680
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27529: LD_VAR 0 3
27533: PPUSH
27534: CALL_OW 256
27538: PUSH
27539: LD_INT 1000
27541: EQUAL
27542: PUSH
27543: LD_VAR 0 3
27547: PPUSH
27548: CALL_OW 314
27552: NOT
27553: AND
27554: IFFALSE 27620
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27556: LD_ADDR_VAR 0 8
27560: PUSH
27561: LD_EXP 51
27565: PUSH
27566: LD_VAR 0 2
27570: ARRAY
27571: PPUSH
27572: LD_VAR 0 3
27576: PPUSH
27577: CALL_OW 74
27581: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27582: LD_VAR 0 8
27586: PPUSH
27587: LD_INT 16
27589: PPUSH
27590: CALL 56389 0 2
27594: PUSH
27595: LD_INT 4
27597: ARRAY
27598: PUSH
27599: LD_INT 10
27601: LESS
27602: IFFALSE 27618
// ComRepairBuilding ( j , to_repair ) ;
27604: LD_VAR 0 3
27608: PPUSH
27609: LD_VAR 0 8
27613: PPUSH
27614: CALL_OW 130
// end else
27618: GO 27678
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27620: LD_VAR 0 3
27624: PPUSH
27625: CALL_OW 256
27629: PUSH
27630: LD_INT 500
27632: LESS
27633: PUSH
27634: LD_VAR 0 3
27638: PPUSH
27639: LD_EXP 74
27643: PUSH
27644: LD_VAR 0 2
27648: ARRAY
27649: PPUSH
27650: CALL_OW 308
27654: NOT
27655: AND
27656: IFFALSE 27678
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27658: LD_VAR 0 3
27662: PPUSH
27663: LD_EXP 74
27667: PUSH
27668: LD_VAR 0 2
27672: ARRAY
27673: PPUSH
27674: CALL_OW 113
// end ;
27678: GO 27526
27680: POP
27681: POP
// end ; if tmp > 3 then
27682: LD_VAR 0 5
27686: PUSH
27687: LD_INT 3
27689: GREATER
27690: IFFALSE 27710
// tmp := ShrinkArray ( tmp , 4 ) ;
27692: LD_ADDR_VAR 0 5
27696: PUSH
27697: LD_VAR 0 5
27701: PPUSH
27702: LD_INT 4
27704: PPUSH
27705: CALL 86419 0 2
27709: ST_TO_ADDR
// if not tmp then
27710: LD_VAR 0 5
27714: NOT
27715: IFFALSE 27719
// continue ;
27717: GO 27099
// for j in tmp do
27719: LD_ADDR_VAR 0 3
27723: PUSH
27724: LD_VAR 0 5
27728: PUSH
27729: FOR_IN
27730: IFFALSE 27989
// begin if IsInUnit ( j ) then
27732: LD_VAR 0 3
27736: PPUSH
27737: CALL_OW 310
27741: IFFALSE 27752
// ComExitBuilding ( j ) ;
27743: LD_VAR 0 3
27747: PPUSH
27748: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27752: LD_VAR 0 3
27756: PUSH
27757: LD_EXP 52
27761: PUSH
27762: LD_VAR 0 2
27766: ARRAY
27767: IN
27768: NOT
27769: IFFALSE 27827
// begin SetTag ( j , 101 ) ;
27771: LD_VAR 0 3
27775: PPUSH
27776: LD_INT 101
27778: PPUSH
27779: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27783: LD_ADDR_EXP 52
27787: PUSH
27788: LD_EXP 52
27792: PPUSH
27793: LD_VAR 0 2
27797: PUSH
27798: LD_EXP 52
27802: PUSH
27803: LD_VAR 0 2
27807: ARRAY
27808: PUSH
27809: LD_INT 1
27811: PLUS
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: PPUSH
27817: LD_VAR 0 3
27821: PPUSH
27822: CALL 53792 0 3
27826: ST_TO_ADDR
// end ; wait ( 1 ) ;
27827: LD_INT 1
27829: PPUSH
27830: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27834: LD_ADDR_VAR 0 7
27838: PUSH
27839: LD_EXP 51
27843: PUSH
27844: LD_VAR 0 2
27848: ARRAY
27849: ST_TO_ADDR
// if mc_scan [ i ] then
27850: LD_EXP 73
27854: PUSH
27855: LD_VAR 0 2
27859: ARRAY
27860: IFFALSE 27922
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27862: LD_ADDR_VAR 0 7
27866: PUSH
27867: LD_EXP 51
27871: PUSH
27872: LD_VAR 0 2
27876: ARRAY
27877: PPUSH
27878: LD_INT 3
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 32
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 30
27893: PUSH
27894: LD_INT 33
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: LD_INT 30
27903: PUSH
27904: LD_INT 31
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: PPUSH
27917: CALL_OW 72
27921: ST_TO_ADDR
// if not to_repair_tmp then
27922: LD_VAR 0 7
27926: NOT
27927: IFFALSE 27931
// continue ;
27929: GO 27729
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27931: LD_ADDR_VAR 0 8
27935: PUSH
27936: LD_VAR 0 7
27940: PPUSH
27941: LD_VAR 0 3
27945: PPUSH
27946: CALL_OW 74
27950: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
27951: LD_VAR 0 8
27955: PPUSH
27956: LD_INT 16
27958: PPUSH
27959: CALL 56389 0 2
27963: PUSH
27964: LD_INT 4
27966: ARRAY
27967: PUSH
27968: LD_INT 14
27970: LESS
27971: IFFALSE 27987
// ComRepairBuilding ( j , to_repair ) ;
27973: LD_VAR 0 3
27977: PPUSH
27978: LD_VAR 0 8
27982: PPUSH
27983: CALL_OW 130
// end ;
27987: GO 27729
27989: POP
27990: POP
// end ;
27991: GO 27099
27993: POP
27994: POP
// end ;
27995: LD_VAR 0 1
27999: RET
// export function MC_Heal ; var i , j , tmp ; begin
28000: LD_INT 0
28002: PPUSH
28003: PPUSH
28004: PPUSH
28005: PPUSH
// if not mc_bases then
28006: LD_EXP 50
28010: NOT
28011: IFFALSE 28015
// exit ;
28013: GO 28417
// for i = 1 to mc_bases do
28015: LD_ADDR_VAR 0 2
28019: PUSH
28020: DOUBLE
28021: LD_INT 1
28023: DEC
28024: ST_TO_ADDR
28025: LD_EXP 50
28029: PUSH
28030: FOR_TO
28031: IFFALSE 28415
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28033: LD_EXP 53
28037: PUSH
28038: LD_VAR 0 2
28042: ARRAY
28043: PUSH
28044: LD_INT 1
28046: ARRAY
28047: NOT
28048: PUSH
28049: LD_EXP 53
28053: PUSH
28054: LD_VAR 0 2
28058: ARRAY
28059: PUSH
28060: LD_INT 2
28062: ARRAY
28063: NOT
28064: AND
28065: IFFALSE 28103
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28067: LD_ADDR_EXP 54
28071: PUSH
28072: LD_EXP 54
28076: PPUSH
28077: LD_VAR 0 2
28081: PPUSH
28082: EMPTY
28083: PPUSH
28084: CALL_OW 1
28088: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28089: LD_VAR 0 2
28093: PPUSH
28094: LD_INT 102
28096: PPUSH
28097: CALL 22152 0 2
// continue ;
28101: GO 28030
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28103: LD_ADDR_VAR 0 4
28107: PUSH
28108: LD_EXP 50
28112: PUSH
28113: LD_VAR 0 2
28117: ARRAY
28118: PPUSH
28119: LD_INT 25
28121: PUSH
28122: LD_INT 4
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PPUSH
28129: CALL_OW 72
28133: ST_TO_ADDR
// if not tmp then
28134: LD_VAR 0 4
28138: NOT
28139: IFFALSE 28143
// continue ;
28141: GO 28030
// if mc_taming [ i ] then
28143: LD_EXP 81
28147: PUSH
28148: LD_VAR 0 2
28152: ARRAY
28153: IFFALSE 28177
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28155: LD_ADDR_EXP 81
28159: PUSH
28160: LD_EXP 81
28164: PPUSH
28165: LD_VAR 0 2
28169: PPUSH
28170: EMPTY
28171: PPUSH
28172: CALL_OW 1
28176: ST_TO_ADDR
// for j in tmp do
28177: LD_ADDR_VAR 0 3
28181: PUSH
28182: LD_VAR 0 4
28186: PUSH
28187: FOR_IN
28188: IFFALSE 28411
// begin if IsInUnit ( j ) then
28190: LD_VAR 0 3
28194: PPUSH
28195: CALL_OW 310
28199: IFFALSE 28210
// ComExitBuilding ( j ) ;
28201: LD_VAR 0 3
28205: PPUSH
28206: CALL_OW 122
// if not j in mc_healers [ i ] then
28210: LD_VAR 0 3
28214: PUSH
28215: LD_EXP 54
28219: PUSH
28220: LD_VAR 0 2
28224: ARRAY
28225: IN
28226: NOT
28227: IFFALSE 28273
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28229: LD_ADDR_EXP 54
28233: PUSH
28234: LD_EXP 54
28238: PPUSH
28239: LD_VAR 0 2
28243: PUSH
28244: LD_EXP 54
28248: PUSH
28249: LD_VAR 0 2
28253: ARRAY
28254: PUSH
28255: LD_INT 1
28257: PLUS
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PPUSH
28263: LD_VAR 0 3
28267: PPUSH
28268: CALL 53792 0 3
28272: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28273: LD_VAR 0 3
28277: PPUSH
28278: CALL_OW 110
28282: PUSH
28283: LD_INT 102
28285: NONEQUAL
28286: IFFALSE 28300
// SetTag ( j , 102 ) ;
28288: LD_VAR 0 3
28292: PPUSH
28293: LD_INT 102
28295: PPUSH
28296: CALL_OW 109
// Wait ( 3 ) ;
28300: LD_INT 3
28302: PPUSH
28303: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28307: LD_EXP 53
28311: PUSH
28312: LD_VAR 0 2
28316: ARRAY
28317: PUSH
28318: LD_INT 1
28320: ARRAY
28321: IFFALSE 28353
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28323: LD_VAR 0 3
28327: PPUSH
28328: LD_EXP 53
28332: PUSH
28333: LD_VAR 0 2
28337: ARRAY
28338: PUSH
28339: LD_INT 1
28341: ARRAY
28342: PUSH
28343: LD_INT 1
28345: ARRAY
28346: PPUSH
28347: CALL_OW 128
28351: GO 28409
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28353: LD_VAR 0 3
28357: PPUSH
28358: CALL_OW 314
28362: NOT
28363: PUSH
28364: LD_EXP 53
28368: PUSH
28369: LD_VAR 0 2
28373: ARRAY
28374: PUSH
28375: LD_INT 2
28377: ARRAY
28378: AND
28379: IFFALSE 28409
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28381: LD_VAR 0 3
28385: PPUSH
28386: LD_EXP 53
28390: PUSH
28391: LD_VAR 0 2
28395: ARRAY
28396: PUSH
28397: LD_INT 2
28399: ARRAY
28400: PUSH
28401: LD_INT 1
28403: ARRAY
28404: PPUSH
28405: CALL_OW 128
// end ;
28409: GO 28187
28411: POP
28412: POP
// end ;
28413: GO 28030
28415: POP
28416: POP
// end ;
28417: LD_VAR 0 1
28421: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28422: LD_INT 0
28424: PPUSH
28425: PPUSH
28426: PPUSH
28427: PPUSH
28428: PPUSH
28429: PPUSH
// if not mc_bases then
28430: LD_EXP 50
28434: NOT
28435: IFFALSE 28439
// exit ;
28437: GO 29602
// for i = 1 to mc_bases do
28439: LD_ADDR_VAR 0 2
28443: PUSH
28444: DOUBLE
28445: LD_INT 1
28447: DEC
28448: ST_TO_ADDR
28449: LD_EXP 50
28453: PUSH
28454: FOR_TO
28455: IFFALSE 29600
// begin if mc_scan [ i ] then
28457: LD_EXP 73
28461: PUSH
28462: LD_VAR 0 2
28466: ARRAY
28467: IFFALSE 28471
// continue ;
28469: GO 28454
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28471: LD_EXP 55
28475: PUSH
28476: LD_VAR 0 2
28480: ARRAY
28481: NOT
28482: PUSH
28483: LD_EXP 57
28487: PUSH
28488: LD_VAR 0 2
28492: ARRAY
28493: NOT
28494: AND
28495: PUSH
28496: LD_EXP 56
28500: PUSH
28501: LD_VAR 0 2
28505: ARRAY
28506: AND
28507: IFFALSE 28545
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28509: LD_ADDR_EXP 56
28513: PUSH
28514: LD_EXP 56
28518: PPUSH
28519: LD_VAR 0 2
28523: PPUSH
28524: EMPTY
28525: PPUSH
28526: CALL_OW 1
28530: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28531: LD_VAR 0 2
28535: PPUSH
28536: LD_INT 103
28538: PPUSH
28539: CALL 22152 0 2
// continue ;
28543: GO 28454
// end ; if mc_construct_list [ i ] then
28545: LD_EXP 57
28549: PUSH
28550: LD_VAR 0 2
28554: ARRAY
28555: IFFALSE 28775
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28557: LD_ADDR_VAR 0 5
28561: PUSH
28562: LD_EXP 50
28566: PUSH
28567: LD_VAR 0 2
28571: ARRAY
28572: PPUSH
28573: LD_INT 25
28575: PUSH
28576: LD_INT 2
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PPUSH
28583: CALL_OW 72
28587: PUSH
28588: LD_EXP 52
28592: PUSH
28593: LD_VAR 0 2
28597: ARRAY
28598: DIFF
28599: ST_TO_ADDR
// if not tmp then
28600: LD_VAR 0 5
28604: NOT
28605: IFFALSE 28609
// continue ;
28607: GO 28454
// for j in tmp do
28609: LD_ADDR_VAR 0 3
28613: PUSH
28614: LD_VAR 0 5
28618: PUSH
28619: FOR_IN
28620: IFFALSE 28771
// begin if not mc_builders [ i ] then
28622: LD_EXP 56
28626: PUSH
28627: LD_VAR 0 2
28631: ARRAY
28632: NOT
28633: IFFALSE 28691
// begin SetTag ( j , 103 ) ;
28635: LD_VAR 0 3
28639: PPUSH
28640: LD_INT 103
28642: PPUSH
28643: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28647: LD_ADDR_EXP 56
28651: PUSH
28652: LD_EXP 56
28656: PPUSH
28657: LD_VAR 0 2
28661: PUSH
28662: LD_EXP 56
28666: PUSH
28667: LD_VAR 0 2
28671: ARRAY
28672: PUSH
28673: LD_INT 1
28675: PLUS
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PPUSH
28681: LD_VAR 0 3
28685: PPUSH
28686: CALL 53792 0 3
28690: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28691: LD_VAR 0 3
28695: PPUSH
28696: CALL_OW 310
28700: IFFALSE 28711
// ComExitBuilding ( j ) ;
28702: LD_VAR 0 3
28706: PPUSH
28707: CALL_OW 122
// wait ( 3 ) ;
28711: LD_INT 3
28713: PPUSH
28714: CALL_OW 67
// if not mc_construct_list [ i ] then
28718: LD_EXP 57
28722: PUSH
28723: LD_VAR 0 2
28727: ARRAY
28728: NOT
28729: IFFALSE 28733
// break ;
28731: GO 28771
// if not HasTask ( j ) then
28733: LD_VAR 0 3
28737: PPUSH
28738: CALL_OW 314
28742: NOT
28743: IFFALSE 28769
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28745: LD_VAR 0 3
28749: PPUSH
28750: LD_EXP 57
28754: PUSH
28755: LD_VAR 0 2
28759: ARRAY
28760: PUSH
28761: LD_INT 1
28763: ARRAY
28764: PPUSH
28765: CALL 56653 0 2
// end ;
28769: GO 28619
28771: POP
28772: POP
// end else
28773: GO 29598
// if mc_build_list [ i ] then
28775: LD_EXP 55
28779: PUSH
28780: LD_VAR 0 2
28784: ARRAY
28785: IFFALSE 29598
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28787: LD_EXP 55
28791: PUSH
28792: LD_VAR 0 2
28796: ARRAY
28797: PUSH
28798: LD_INT 1
28800: ARRAY
28801: PUSH
28802: LD_INT 1
28804: ARRAY
28805: PPUSH
28806: CALL 56477 0 1
28810: PUSH
28811: LD_EXP 50
28815: PUSH
28816: LD_VAR 0 2
28820: ARRAY
28821: PPUSH
28822: LD_INT 2
28824: PUSH
28825: LD_INT 30
28827: PUSH
28828: LD_INT 2
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PUSH
28835: LD_INT 30
28837: PUSH
28838: LD_INT 3
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: LIST
28849: PPUSH
28850: CALL_OW 72
28854: NOT
28855: AND
28856: IFFALSE 28961
// begin for j = 1 to mc_build_list [ i ] do
28858: LD_ADDR_VAR 0 3
28862: PUSH
28863: DOUBLE
28864: LD_INT 1
28866: DEC
28867: ST_TO_ADDR
28868: LD_EXP 55
28872: PUSH
28873: LD_VAR 0 2
28877: ARRAY
28878: PUSH
28879: FOR_TO
28880: IFFALSE 28959
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28882: LD_EXP 55
28886: PUSH
28887: LD_VAR 0 2
28891: ARRAY
28892: PUSH
28893: LD_VAR 0 3
28897: ARRAY
28898: PUSH
28899: LD_INT 1
28901: ARRAY
28902: PUSH
28903: LD_INT 2
28905: EQUAL
28906: IFFALSE 28957
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28908: LD_ADDR_EXP 55
28912: PUSH
28913: LD_EXP 55
28917: PPUSH
28918: LD_VAR 0 2
28922: PPUSH
28923: LD_EXP 55
28927: PUSH
28928: LD_VAR 0 2
28932: ARRAY
28933: PPUSH
28934: LD_VAR 0 3
28938: PPUSH
28939: LD_INT 1
28941: PPUSH
28942: LD_INT 0
28944: PPUSH
28945: CALL 53210 0 4
28949: PPUSH
28950: CALL_OW 1
28954: ST_TO_ADDR
// break ;
28955: GO 28959
// end ;
28957: GO 28879
28959: POP
28960: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28961: LD_ADDR_VAR 0 6
28965: PUSH
28966: LD_EXP 50
28970: PUSH
28971: LD_VAR 0 2
28975: ARRAY
28976: PPUSH
28977: LD_INT 2
28979: PUSH
28980: LD_INT 30
28982: PUSH
28983: LD_INT 0
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 30
28992: PUSH
28993: LD_INT 1
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: LIST
29004: PPUSH
29005: CALL_OW 72
29009: ST_TO_ADDR
// for k := 1 to depot do
29010: LD_ADDR_VAR 0 4
29014: PUSH
29015: DOUBLE
29016: LD_INT 1
29018: DEC
29019: ST_TO_ADDR
29020: LD_VAR 0 6
29024: PUSH
29025: FOR_TO
29026: IFFALSE 29596
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29028: LD_EXP 55
29032: PUSH
29033: LD_VAR 0 2
29037: ARRAY
29038: PUSH
29039: LD_INT 1
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: PUSH
29047: LD_INT 0
29049: EQUAL
29050: PUSH
29051: LD_VAR 0 6
29055: PUSH
29056: LD_VAR 0 4
29060: ARRAY
29061: PPUSH
29062: LD_EXP 55
29066: PUSH
29067: LD_VAR 0 2
29071: ARRAY
29072: PUSH
29073: LD_INT 1
29075: ARRAY
29076: PUSH
29077: LD_INT 1
29079: ARRAY
29080: PPUSH
29081: LD_EXP 55
29085: PUSH
29086: LD_VAR 0 2
29090: ARRAY
29091: PUSH
29092: LD_INT 1
29094: ARRAY
29095: PUSH
29096: LD_INT 2
29098: ARRAY
29099: PPUSH
29100: LD_EXP 55
29104: PUSH
29105: LD_VAR 0 2
29109: ARRAY
29110: PUSH
29111: LD_INT 1
29113: ARRAY
29114: PUSH
29115: LD_INT 3
29117: ARRAY
29118: PPUSH
29119: LD_EXP 55
29123: PUSH
29124: LD_VAR 0 2
29128: ARRAY
29129: PUSH
29130: LD_INT 1
29132: ARRAY
29133: PUSH
29134: LD_INT 4
29136: ARRAY
29137: PPUSH
29138: CALL 61889 0 5
29142: OR
29143: IFFALSE 29424
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29145: LD_ADDR_VAR 0 5
29149: PUSH
29150: LD_EXP 50
29154: PUSH
29155: LD_VAR 0 2
29159: ARRAY
29160: PPUSH
29161: LD_INT 25
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PPUSH
29171: CALL_OW 72
29175: PUSH
29176: LD_EXP 52
29180: PUSH
29181: LD_VAR 0 2
29185: ARRAY
29186: DIFF
29187: ST_TO_ADDR
// if not tmp then
29188: LD_VAR 0 5
29192: NOT
29193: IFFALSE 29197
// continue ;
29195: GO 29025
// for j in tmp do
29197: LD_ADDR_VAR 0 3
29201: PUSH
29202: LD_VAR 0 5
29206: PUSH
29207: FOR_IN
29208: IFFALSE 29420
// begin if not mc_builders [ i ] then
29210: LD_EXP 56
29214: PUSH
29215: LD_VAR 0 2
29219: ARRAY
29220: NOT
29221: IFFALSE 29279
// begin SetTag ( j , 103 ) ;
29223: LD_VAR 0 3
29227: PPUSH
29228: LD_INT 103
29230: PPUSH
29231: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29235: LD_ADDR_EXP 56
29239: PUSH
29240: LD_EXP 56
29244: PPUSH
29245: LD_VAR 0 2
29249: PUSH
29250: LD_EXP 56
29254: PUSH
29255: LD_VAR 0 2
29259: ARRAY
29260: PUSH
29261: LD_INT 1
29263: PLUS
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PPUSH
29269: LD_VAR 0 3
29273: PPUSH
29274: CALL 53792 0 3
29278: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29279: LD_VAR 0 3
29283: PPUSH
29284: CALL_OW 310
29288: IFFALSE 29299
// ComExitBuilding ( j ) ;
29290: LD_VAR 0 3
29294: PPUSH
29295: CALL_OW 122
// wait ( 3 ) ;
29299: LD_INT 3
29301: PPUSH
29302: CALL_OW 67
// if not mc_build_list [ i ] then
29306: LD_EXP 55
29310: PUSH
29311: LD_VAR 0 2
29315: ARRAY
29316: NOT
29317: IFFALSE 29321
// break ;
29319: GO 29420
// if not HasTask ( j ) then
29321: LD_VAR 0 3
29325: PPUSH
29326: CALL_OW 314
29330: NOT
29331: IFFALSE 29418
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29333: LD_VAR 0 3
29337: PPUSH
29338: LD_EXP 55
29342: PUSH
29343: LD_VAR 0 2
29347: ARRAY
29348: PUSH
29349: LD_INT 1
29351: ARRAY
29352: PUSH
29353: LD_INT 1
29355: ARRAY
29356: PPUSH
29357: LD_EXP 55
29361: PUSH
29362: LD_VAR 0 2
29366: ARRAY
29367: PUSH
29368: LD_INT 1
29370: ARRAY
29371: PUSH
29372: LD_INT 2
29374: ARRAY
29375: PPUSH
29376: LD_EXP 55
29380: PUSH
29381: LD_VAR 0 2
29385: ARRAY
29386: PUSH
29387: LD_INT 1
29389: ARRAY
29390: PUSH
29391: LD_INT 3
29393: ARRAY
29394: PPUSH
29395: LD_EXP 55
29399: PUSH
29400: LD_VAR 0 2
29404: ARRAY
29405: PUSH
29406: LD_INT 1
29408: ARRAY
29409: PUSH
29410: LD_INT 4
29412: ARRAY
29413: PPUSH
29414: CALL_OW 145
// end ;
29418: GO 29207
29420: POP
29421: POP
// end else
29422: GO 29594
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29424: LD_EXP 50
29428: PUSH
29429: LD_VAR 0 2
29433: ARRAY
29434: PPUSH
29435: LD_EXP 55
29439: PUSH
29440: LD_VAR 0 2
29444: ARRAY
29445: PUSH
29446: LD_INT 1
29448: ARRAY
29449: PUSH
29450: LD_INT 1
29452: ARRAY
29453: PPUSH
29454: LD_EXP 55
29458: PUSH
29459: LD_VAR 0 2
29463: ARRAY
29464: PUSH
29465: LD_INT 1
29467: ARRAY
29468: PUSH
29469: LD_INT 2
29471: ARRAY
29472: PPUSH
29473: LD_EXP 55
29477: PUSH
29478: LD_VAR 0 2
29482: ARRAY
29483: PUSH
29484: LD_INT 1
29486: ARRAY
29487: PUSH
29488: LD_INT 3
29490: ARRAY
29491: PPUSH
29492: LD_EXP 55
29496: PUSH
29497: LD_VAR 0 2
29501: ARRAY
29502: PUSH
29503: LD_INT 1
29505: ARRAY
29506: PUSH
29507: LD_INT 4
29509: ARRAY
29510: PPUSH
29511: LD_EXP 50
29515: PUSH
29516: LD_VAR 0 2
29520: ARRAY
29521: PPUSH
29522: LD_INT 21
29524: PUSH
29525: LD_INT 3
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PPUSH
29532: CALL_OW 72
29536: PPUSH
29537: EMPTY
29538: PPUSH
29539: CALL 60643 0 7
29543: NOT
29544: IFFALSE 29594
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29546: LD_ADDR_EXP 55
29550: PUSH
29551: LD_EXP 55
29555: PPUSH
29556: LD_VAR 0 2
29560: PPUSH
29561: LD_EXP 55
29565: PUSH
29566: LD_VAR 0 2
29570: ARRAY
29571: PPUSH
29572: LD_INT 1
29574: PPUSH
29575: LD_INT 1
29577: NEG
29578: PPUSH
29579: LD_INT 0
29581: PPUSH
29582: CALL 53210 0 4
29586: PPUSH
29587: CALL_OW 1
29591: ST_TO_ADDR
// continue ;
29592: GO 29025
// end ; end ;
29594: GO 29025
29596: POP
29597: POP
// end ; end ;
29598: GO 28454
29600: POP
29601: POP
// end ;
29602: LD_VAR 0 1
29606: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29607: LD_INT 0
29609: PPUSH
29610: PPUSH
29611: PPUSH
29612: PPUSH
29613: PPUSH
29614: PPUSH
// if not mc_bases then
29615: LD_EXP 50
29619: NOT
29620: IFFALSE 29624
// exit ;
29622: GO 30051
// for i = 1 to mc_bases do
29624: LD_ADDR_VAR 0 2
29628: PUSH
29629: DOUBLE
29630: LD_INT 1
29632: DEC
29633: ST_TO_ADDR
29634: LD_EXP 50
29638: PUSH
29639: FOR_TO
29640: IFFALSE 30049
// begin tmp := mc_build_upgrade [ i ] ;
29642: LD_ADDR_VAR 0 4
29646: PUSH
29647: LD_EXP 82
29651: PUSH
29652: LD_VAR 0 2
29656: ARRAY
29657: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29658: LD_ADDR_VAR 0 6
29662: PUSH
29663: LD_EXP 83
29667: PUSH
29668: LD_VAR 0 2
29672: ARRAY
29673: PPUSH
29674: LD_INT 2
29676: PUSH
29677: LD_INT 30
29679: PUSH
29680: LD_INT 6
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 30
29689: PUSH
29690: LD_INT 7
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: LIST
29701: PPUSH
29702: CALL_OW 72
29706: ST_TO_ADDR
// if not tmp and not lab then
29707: LD_VAR 0 4
29711: NOT
29712: PUSH
29713: LD_VAR 0 6
29717: NOT
29718: AND
29719: IFFALSE 29723
// continue ;
29721: GO 29639
// if tmp then
29723: LD_VAR 0 4
29727: IFFALSE 29847
// for j in tmp do
29729: LD_ADDR_VAR 0 3
29733: PUSH
29734: LD_VAR 0 4
29738: PUSH
29739: FOR_IN
29740: IFFALSE 29845
// begin if UpgradeCost ( j ) then
29742: LD_VAR 0 3
29746: PPUSH
29747: CALL 60303 0 1
29751: IFFALSE 29843
// begin ComUpgrade ( j ) ;
29753: LD_VAR 0 3
29757: PPUSH
29758: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29762: LD_ADDR_EXP 82
29766: PUSH
29767: LD_EXP 82
29771: PPUSH
29772: LD_VAR 0 2
29776: PPUSH
29777: LD_EXP 82
29781: PUSH
29782: LD_VAR 0 2
29786: ARRAY
29787: PUSH
29788: LD_VAR 0 3
29792: DIFF
29793: PPUSH
29794: CALL_OW 1
29798: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29799: LD_ADDR_EXP 57
29803: PUSH
29804: LD_EXP 57
29808: PPUSH
29809: LD_VAR 0 2
29813: PUSH
29814: LD_EXP 57
29818: PUSH
29819: LD_VAR 0 2
29823: ARRAY
29824: PUSH
29825: LD_INT 1
29827: PLUS
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PPUSH
29833: LD_VAR 0 3
29837: PPUSH
29838: CALL 53792 0 3
29842: ST_TO_ADDR
// end ; end ;
29843: GO 29739
29845: POP
29846: POP
// if not lab or not mc_lab_upgrade [ i ] then
29847: LD_VAR 0 6
29851: NOT
29852: PUSH
29853: LD_EXP 84
29857: PUSH
29858: LD_VAR 0 2
29862: ARRAY
29863: NOT
29864: OR
29865: IFFALSE 29869
// continue ;
29867: GO 29639
// for j in lab do
29869: LD_ADDR_VAR 0 3
29873: PUSH
29874: LD_VAR 0 6
29878: PUSH
29879: FOR_IN
29880: IFFALSE 30045
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29882: LD_VAR 0 3
29886: PPUSH
29887: CALL_OW 266
29891: PUSH
29892: LD_INT 6
29894: PUSH
29895: LD_INT 7
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: IN
29902: PUSH
29903: LD_VAR 0 3
29907: PPUSH
29908: CALL_OW 461
29912: PUSH
29913: LD_INT 1
29915: NONEQUAL
29916: AND
29917: IFFALSE 30043
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29919: LD_VAR 0 3
29923: PPUSH
29924: LD_EXP 84
29928: PUSH
29929: LD_VAR 0 2
29933: ARRAY
29934: PUSH
29935: LD_INT 1
29937: ARRAY
29938: PPUSH
29939: CALL 60508 0 2
29943: IFFALSE 30043
// begin ComCancel ( j ) ;
29945: LD_VAR 0 3
29949: PPUSH
29950: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29954: LD_VAR 0 3
29958: PPUSH
29959: LD_EXP 84
29963: PUSH
29964: LD_VAR 0 2
29968: ARRAY
29969: PUSH
29970: LD_INT 1
29972: ARRAY
29973: PPUSH
29974: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29978: LD_VAR 0 3
29982: PUSH
29983: LD_EXP 57
29987: PUSH
29988: LD_VAR 0 2
29992: ARRAY
29993: IN
29994: NOT
29995: IFFALSE 30041
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29997: LD_ADDR_EXP 57
30001: PUSH
30002: LD_EXP 57
30006: PPUSH
30007: LD_VAR 0 2
30011: PUSH
30012: LD_EXP 57
30016: PUSH
30017: LD_VAR 0 2
30021: ARRAY
30022: PUSH
30023: LD_INT 1
30025: PLUS
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PPUSH
30031: LD_VAR 0 3
30035: PPUSH
30036: CALL 53792 0 3
30040: ST_TO_ADDR
// break ;
30041: GO 30045
// end ; end ; end ;
30043: GO 29879
30045: POP
30046: POP
// end ;
30047: GO 29639
30049: POP
30050: POP
// end ;
30051: LD_VAR 0 1
30055: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30056: LD_INT 0
30058: PPUSH
30059: PPUSH
30060: PPUSH
30061: PPUSH
30062: PPUSH
30063: PPUSH
30064: PPUSH
30065: PPUSH
30066: PPUSH
// if not mc_bases then
30067: LD_EXP 50
30071: NOT
30072: IFFALSE 30076
// exit ;
30074: GO 30481
// for i = 1 to mc_bases do
30076: LD_ADDR_VAR 0 2
30080: PUSH
30081: DOUBLE
30082: LD_INT 1
30084: DEC
30085: ST_TO_ADDR
30086: LD_EXP 50
30090: PUSH
30091: FOR_TO
30092: IFFALSE 30479
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30094: LD_EXP 58
30098: PUSH
30099: LD_VAR 0 2
30103: ARRAY
30104: NOT
30105: PUSH
30106: LD_EXP 50
30110: PUSH
30111: LD_VAR 0 2
30115: ARRAY
30116: PPUSH
30117: LD_INT 30
30119: PUSH
30120: LD_INT 3
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PPUSH
30127: CALL_OW 72
30131: NOT
30132: OR
30133: IFFALSE 30137
// continue ;
30135: GO 30091
// busy := false ;
30137: LD_ADDR_VAR 0 8
30141: PUSH
30142: LD_INT 0
30144: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30145: LD_ADDR_VAR 0 4
30149: PUSH
30150: LD_EXP 50
30154: PUSH
30155: LD_VAR 0 2
30159: ARRAY
30160: PPUSH
30161: LD_INT 30
30163: PUSH
30164: LD_INT 3
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PPUSH
30171: CALL_OW 72
30175: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30176: LD_ADDR_VAR 0 6
30180: PUSH
30181: LD_EXP 58
30185: PUSH
30186: LD_VAR 0 2
30190: ARRAY
30191: PPUSH
30192: LD_INT 2
30194: PUSH
30195: LD_INT 30
30197: PUSH
30198: LD_INT 32
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 30
30207: PUSH
30208: LD_INT 33
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: LIST
30219: PPUSH
30220: CALL_OW 72
30224: ST_TO_ADDR
// if not t then
30225: LD_VAR 0 6
30229: NOT
30230: IFFALSE 30234
// continue ;
30232: GO 30091
// for j in tmp do
30234: LD_ADDR_VAR 0 3
30238: PUSH
30239: LD_VAR 0 4
30243: PUSH
30244: FOR_IN
30245: IFFALSE 30275
// if not BuildingStatus ( j ) = bs_idle then
30247: LD_VAR 0 3
30251: PPUSH
30252: CALL_OW 461
30256: PUSH
30257: LD_INT 2
30259: EQUAL
30260: NOT
30261: IFFALSE 30273
// begin busy := true ;
30263: LD_ADDR_VAR 0 8
30267: PUSH
30268: LD_INT 1
30270: ST_TO_ADDR
// break ;
30271: GO 30275
// end ;
30273: GO 30244
30275: POP
30276: POP
// if busy then
30277: LD_VAR 0 8
30281: IFFALSE 30285
// continue ;
30283: GO 30091
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30285: LD_ADDR_VAR 0 7
30289: PUSH
30290: LD_VAR 0 6
30294: PPUSH
30295: LD_INT 35
30297: PUSH
30298: LD_INT 0
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PPUSH
30305: CALL_OW 72
30309: ST_TO_ADDR
// if tw then
30310: LD_VAR 0 7
30314: IFFALSE 30391
// begin tw := tw [ 1 ] ;
30316: LD_ADDR_VAR 0 7
30320: PUSH
30321: LD_VAR 0 7
30325: PUSH
30326: LD_INT 1
30328: ARRAY
30329: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30330: LD_ADDR_VAR 0 9
30334: PUSH
30335: LD_VAR 0 7
30339: PPUSH
30340: LD_EXP 75
30344: PUSH
30345: LD_VAR 0 2
30349: ARRAY
30350: PPUSH
30351: CALL 58800 0 2
30355: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30356: LD_EXP 89
30360: PUSH
30361: LD_VAR 0 2
30365: ARRAY
30366: IFFALSE 30389
// if not weapon in mc_allowed_tower_weapons [ i ] then
30368: LD_VAR 0 9
30372: PUSH
30373: LD_EXP 89
30377: PUSH
30378: LD_VAR 0 2
30382: ARRAY
30383: IN
30384: NOT
30385: IFFALSE 30389
// continue ;
30387: GO 30091
// end else
30389: GO 30454
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30391: LD_ADDR_VAR 0 5
30395: PUSH
30396: LD_EXP 58
30400: PUSH
30401: LD_VAR 0 2
30405: ARRAY
30406: PPUSH
30407: LD_VAR 0 4
30411: PPUSH
30412: CALL 85652 0 2
30416: ST_TO_ADDR
// if not tmp2 then
30417: LD_VAR 0 5
30421: NOT
30422: IFFALSE 30426
// continue ;
30424: GO 30091
// tw := tmp2 [ 1 ] ;
30426: LD_ADDR_VAR 0 7
30430: PUSH
30431: LD_VAR 0 5
30435: PUSH
30436: LD_INT 1
30438: ARRAY
30439: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30440: LD_ADDR_VAR 0 9
30444: PUSH
30445: LD_VAR 0 5
30449: PUSH
30450: LD_INT 2
30452: ARRAY
30453: ST_TO_ADDR
// end ; if not weapon then
30454: LD_VAR 0 9
30458: NOT
30459: IFFALSE 30463
// continue ;
30461: GO 30091
// ComPlaceWeapon ( tw , weapon ) ;
30463: LD_VAR 0 7
30467: PPUSH
30468: LD_VAR 0 9
30472: PPUSH
30473: CALL_OW 148
// end ;
30477: GO 30091
30479: POP
30480: POP
// end ;
30481: LD_VAR 0 1
30485: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30486: LD_INT 0
30488: PPUSH
30489: PPUSH
30490: PPUSH
30491: PPUSH
30492: PPUSH
30493: PPUSH
30494: PPUSH
// if not mc_bases then
30495: LD_EXP 50
30499: NOT
30500: IFFALSE 30504
// exit ;
30502: GO 31272
// for i = 1 to mc_bases do
30504: LD_ADDR_VAR 0 2
30508: PUSH
30509: DOUBLE
30510: LD_INT 1
30512: DEC
30513: ST_TO_ADDR
30514: LD_EXP 50
30518: PUSH
30519: FOR_TO
30520: IFFALSE 31270
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30522: LD_EXP 63
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: NOT
30533: PUSH
30534: LD_EXP 63
30538: PUSH
30539: LD_VAR 0 2
30543: ARRAY
30544: PUSH
30545: LD_EXP 64
30549: PUSH
30550: LD_VAR 0 2
30554: ARRAY
30555: EQUAL
30556: OR
30557: PUSH
30558: LD_EXP 73
30562: PUSH
30563: LD_VAR 0 2
30567: ARRAY
30568: OR
30569: IFFALSE 30573
// continue ;
30571: GO 30519
// if mc_miners [ i ] then
30573: LD_EXP 64
30577: PUSH
30578: LD_VAR 0 2
30582: ARRAY
30583: IFFALSE 30957
// begin for j = mc_miners [ i ] downto 1 do
30585: LD_ADDR_VAR 0 3
30589: PUSH
30590: DOUBLE
30591: LD_EXP 64
30595: PUSH
30596: LD_VAR 0 2
30600: ARRAY
30601: INC
30602: ST_TO_ADDR
30603: LD_INT 1
30605: PUSH
30606: FOR_DOWNTO
30607: IFFALSE 30955
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30609: LD_EXP 64
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PUSH
30620: LD_VAR 0 3
30624: ARRAY
30625: PPUSH
30626: CALL_OW 301
30630: PUSH
30631: LD_EXP 64
30635: PUSH
30636: LD_VAR 0 2
30640: ARRAY
30641: PUSH
30642: LD_VAR 0 3
30646: ARRAY
30647: PPUSH
30648: CALL_OW 257
30652: PUSH
30653: LD_INT 1
30655: NONEQUAL
30656: OR
30657: IFFALSE 30720
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30659: LD_ADDR_VAR 0 5
30663: PUSH
30664: LD_EXP 64
30668: PUSH
30669: LD_VAR 0 2
30673: ARRAY
30674: PUSH
30675: LD_EXP 64
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: PUSH
30686: LD_VAR 0 3
30690: ARRAY
30691: DIFF
30692: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30693: LD_ADDR_EXP 64
30697: PUSH
30698: LD_EXP 64
30702: PPUSH
30703: LD_VAR 0 2
30707: PPUSH
30708: LD_VAR 0 5
30712: PPUSH
30713: CALL_OW 1
30717: ST_TO_ADDR
// continue ;
30718: GO 30606
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30720: LD_EXP 64
30724: PUSH
30725: LD_VAR 0 2
30729: ARRAY
30730: PUSH
30731: LD_VAR 0 3
30735: ARRAY
30736: PPUSH
30737: CALL_OW 257
30741: PUSH
30742: LD_INT 1
30744: EQUAL
30745: PUSH
30746: LD_EXP 64
30750: PUSH
30751: LD_VAR 0 2
30755: ARRAY
30756: PUSH
30757: LD_VAR 0 3
30761: ARRAY
30762: PPUSH
30763: CALL_OW 459
30767: NOT
30768: AND
30769: PUSH
30770: LD_EXP 64
30774: PUSH
30775: LD_VAR 0 2
30779: ARRAY
30780: PUSH
30781: LD_VAR 0 3
30785: ARRAY
30786: PPUSH
30787: CALL_OW 314
30791: NOT
30792: AND
30793: IFFALSE 30953
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30795: LD_EXP 64
30799: PUSH
30800: LD_VAR 0 2
30804: ARRAY
30805: PUSH
30806: LD_VAR 0 3
30810: ARRAY
30811: PPUSH
30812: CALL_OW 310
30816: IFFALSE 30839
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30818: LD_EXP 64
30822: PUSH
30823: LD_VAR 0 2
30827: ARRAY
30828: PUSH
30829: LD_VAR 0 3
30833: ARRAY
30834: PPUSH
30835: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30839: LD_EXP 64
30843: PUSH
30844: LD_VAR 0 2
30848: ARRAY
30849: PUSH
30850: LD_VAR 0 3
30854: ARRAY
30855: PPUSH
30856: CALL_OW 314
30860: NOT
30861: IFFALSE 30953
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30863: LD_ADDR_VAR 0 7
30867: PUSH
30868: LD_INT 1
30870: PPUSH
30871: LD_EXP 63
30875: PUSH
30876: LD_VAR 0 2
30880: ARRAY
30881: PPUSH
30882: CALL_OW 12
30886: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30887: LD_EXP 64
30891: PUSH
30892: LD_VAR 0 2
30896: ARRAY
30897: PUSH
30898: LD_VAR 0 3
30902: ARRAY
30903: PPUSH
30904: LD_EXP 63
30908: PUSH
30909: LD_VAR 0 2
30913: ARRAY
30914: PUSH
30915: LD_VAR 0 7
30919: ARRAY
30920: PUSH
30921: LD_INT 1
30923: ARRAY
30924: PPUSH
30925: LD_EXP 63
30929: PUSH
30930: LD_VAR 0 2
30934: ARRAY
30935: PUSH
30936: LD_VAR 0 7
30940: ARRAY
30941: PUSH
30942: LD_INT 2
30944: ARRAY
30945: PPUSH
30946: LD_INT 0
30948: PPUSH
30949: CALL_OW 193
// end ; end ; end ;
30953: GO 30606
30955: POP
30956: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30957: LD_ADDR_VAR 0 5
30961: PUSH
30962: LD_EXP 50
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PPUSH
30973: LD_INT 2
30975: PUSH
30976: LD_INT 30
30978: PUSH
30979: LD_INT 4
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 30
30988: PUSH
30989: LD_INT 5
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 30
30998: PUSH
30999: LD_INT 32
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: PPUSH
31012: CALL_OW 72
31016: ST_TO_ADDR
// if not tmp then
31017: LD_VAR 0 5
31021: NOT
31022: IFFALSE 31026
// continue ;
31024: GO 30519
// list := [ ] ;
31026: LD_ADDR_VAR 0 6
31030: PUSH
31031: EMPTY
31032: ST_TO_ADDR
// for j in tmp do
31033: LD_ADDR_VAR 0 3
31037: PUSH
31038: LD_VAR 0 5
31042: PUSH
31043: FOR_IN
31044: IFFALSE 31113
// begin for k in UnitsInside ( j ) do
31046: LD_ADDR_VAR 0 4
31050: PUSH
31051: LD_VAR 0 3
31055: PPUSH
31056: CALL_OW 313
31060: PUSH
31061: FOR_IN
31062: IFFALSE 31109
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31064: LD_VAR 0 4
31068: PPUSH
31069: CALL_OW 257
31073: PUSH
31074: LD_INT 1
31076: EQUAL
31077: PUSH
31078: LD_VAR 0 4
31082: PPUSH
31083: CALL_OW 459
31087: NOT
31088: AND
31089: IFFALSE 31107
// list := list ^ k ;
31091: LD_ADDR_VAR 0 6
31095: PUSH
31096: LD_VAR 0 6
31100: PUSH
31101: LD_VAR 0 4
31105: ADD
31106: ST_TO_ADDR
31107: GO 31061
31109: POP
31110: POP
// end ;
31111: GO 31043
31113: POP
31114: POP
// list := list diff mc_miners [ i ] ;
31115: LD_ADDR_VAR 0 6
31119: PUSH
31120: LD_VAR 0 6
31124: PUSH
31125: LD_EXP 64
31129: PUSH
31130: LD_VAR 0 2
31134: ARRAY
31135: DIFF
31136: ST_TO_ADDR
// if not list then
31137: LD_VAR 0 6
31141: NOT
31142: IFFALSE 31146
// continue ;
31144: GO 30519
// k := mc_mines [ i ] - mc_miners [ i ] ;
31146: LD_ADDR_VAR 0 4
31150: PUSH
31151: LD_EXP 63
31155: PUSH
31156: LD_VAR 0 2
31160: ARRAY
31161: PUSH
31162: LD_EXP 64
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: MINUS
31173: ST_TO_ADDR
// if k > list then
31174: LD_VAR 0 4
31178: PUSH
31179: LD_VAR 0 6
31183: GREATER
31184: IFFALSE 31196
// k := list ;
31186: LD_ADDR_VAR 0 4
31190: PUSH
31191: LD_VAR 0 6
31195: ST_TO_ADDR
// for j = 1 to k do
31196: LD_ADDR_VAR 0 3
31200: PUSH
31201: DOUBLE
31202: LD_INT 1
31204: DEC
31205: ST_TO_ADDR
31206: LD_VAR 0 4
31210: PUSH
31211: FOR_TO
31212: IFFALSE 31266
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31214: LD_ADDR_EXP 64
31218: PUSH
31219: LD_EXP 64
31223: PPUSH
31224: LD_VAR 0 2
31228: PUSH
31229: LD_EXP 64
31233: PUSH
31234: LD_VAR 0 2
31238: ARRAY
31239: PUSH
31240: LD_INT 1
31242: PLUS
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PPUSH
31248: LD_VAR 0 6
31252: PUSH
31253: LD_VAR 0 3
31257: ARRAY
31258: PPUSH
31259: CALL 53792 0 3
31263: ST_TO_ADDR
31264: GO 31211
31266: POP
31267: POP
// end ;
31268: GO 30519
31270: POP
31271: POP
// end ;
31272: LD_VAR 0 1
31276: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31277: LD_INT 0
31279: PPUSH
31280: PPUSH
31281: PPUSH
31282: PPUSH
31283: PPUSH
31284: PPUSH
31285: PPUSH
31286: PPUSH
31287: PPUSH
31288: PPUSH
31289: PPUSH
// if not mc_bases then
31290: LD_EXP 50
31294: NOT
31295: IFFALSE 31299
// exit ;
31297: GO 33122
// for i = 1 to mc_bases do
31299: LD_ADDR_VAR 0 2
31303: PUSH
31304: DOUBLE
31305: LD_INT 1
31307: DEC
31308: ST_TO_ADDR
31309: LD_EXP 50
31313: PUSH
31314: FOR_TO
31315: IFFALSE 33120
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31317: LD_EXP 50
31321: PUSH
31322: LD_VAR 0 2
31326: ARRAY
31327: NOT
31328: PUSH
31329: LD_EXP 57
31333: PUSH
31334: LD_VAR 0 2
31338: ARRAY
31339: OR
31340: IFFALSE 31344
// continue ;
31342: GO 31314
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31344: LD_EXP 66
31348: PUSH
31349: LD_VAR 0 2
31353: ARRAY
31354: NOT
31355: PUSH
31356: LD_EXP 67
31360: PUSH
31361: LD_VAR 0 2
31365: ARRAY
31366: AND
31367: IFFALSE 31405
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31369: LD_ADDR_EXP 67
31373: PUSH
31374: LD_EXP 67
31378: PPUSH
31379: LD_VAR 0 2
31383: PPUSH
31384: EMPTY
31385: PPUSH
31386: CALL_OW 1
31390: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31391: LD_VAR 0 2
31395: PPUSH
31396: LD_INT 107
31398: PPUSH
31399: CALL 22152 0 2
// continue ;
31403: GO 31314
// end ; target := [ ] ;
31405: LD_ADDR_VAR 0 7
31409: PUSH
31410: EMPTY
31411: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31412: LD_ADDR_VAR 0 6
31416: PUSH
31417: LD_EXP 50
31421: PUSH
31422: LD_VAR 0 2
31426: ARRAY
31427: PUSH
31428: LD_INT 1
31430: ARRAY
31431: PPUSH
31432: CALL_OW 255
31436: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31437: LD_ADDR_VAR 0 9
31441: PUSH
31442: LD_EXP 50
31446: PUSH
31447: LD_VAR 0 2
31451: ARRAY
31452: PPUSH
31453: LD_INT 2
31455: PUSH
31456: LD_INT 30
31458: PUSH
31459: LD_INT 0
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 30
31468: PUSH
31469: LD_INT 1
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: LIST
31480: PPUSH
31481: CALL_OW 72
31485: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31486: LD_ADDR_VAR 0 3
31490: PUSH
31491: DOUBLE
31492: LD_EXP 66
31496: PUSH
31497: LD_VAR 0 2
31501: ARRAY
31502: INC
31503: ST_TO_ADDR
31504: LD_INT 1
31506: PUSH
31507: FOR_DOWNTO
31508: IFFALSE 31753
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31510: LD_EXP 66
31514: PUSH
31515: LD_VAR 0 2
31519: ARRAY
31520: PUSH
31521: LD_VAR 0 3
31525: ARRAY
31526: PUSH
31527: LD_INT 2
31529: ARRAY
31530: PPUSH
31531: LD_EXP 66
31535: PUSH
31536: LD_VAR 0 2
31540: ARRAY
31541: PUSH
31542: LD_VAR 0 3
31546: ARRAY
31547: PUSH
31548: LD_INT 3
31550: ARRAY
31551: PPUSH
31552: CALL_OW 488
31556: PUSH
31557: LD_EXP 66
31561: PUSH
31562: LD_VAR 0 2
31566: ARRAY
31567: PUSH
31568: LD_VAR 0 3
31572: ARRAY
31573: PUSH
31574: LD_INT 2
31576: ARRAY
31577: PPUSH
31578: LD_EXP 66
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_VAR 0 3
31593: ARRAY
31594: PUSH
31595: LD_INT 3
31597: ARRAY
31598: PPUSH
31599: CALL_OW 284
31603: PUSH
31604: LD_INT 0
31606: EQUAL
31607: AND
31608: IFFALSE 31663
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31610: LD_ADDR_VAR 0 5
31614: PUSH
31615: LD_EXP 66
31619: PUSH
31620: LD_VAR 0 2
31624: ARRAY
31625: PPUSH
31626: LD_VAR 0 3
31630: PPUSH
31631: CALL_OW 3
31635: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31636: LD_ADDR_EXP 66
31640: PUSH
31641: LD_EXP 66
31645: PPUSH
31646: LD_VAR 0 2
31650: PPUSH
31651: LD_VAR 0 5
31655: PPUSH
31656: CALL_OW 1
31660: ST_TO_ADDR
// continue ;
31661: GO 31507
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31663: LD_VAR 0 6
31667: PPUSH
31668: LD_EXP 66
31672: PUSH
31673: LD_VAR 0 2
31677: ARRAY
31678: PUSH
31679: LD_VAR 0 3
31683: ARRAY
31684: PUSH
31685: LD_INT 2
31687: ARRAY
31688: PPUSH
31689: LD_EXP 66
31693: PUSH
31694: LD_VAR 0 2
31698: ARRAY
31699: PUSH
31700: LD_VAR 0 3
31704: ARRAY
31705: PUSH
31706: LD_INT 3
31708: ARRAY
31709: PPUSH
31710: LD_INT 30
31712: PPUSH
31713: CALL 54688 0 4
31717: PUSH
31718: LD_INT 4
31720: ARRAY
31721: PUSH
31722: LD_INT 0
31724: EQUAL
31725: IFFALSE 31751
// begin target := mc_crates [ i ] [ j ] ;
31727: LD_ADDR_VAR 0 7
31731: PUSH
31732: LD_EXP 66
31736: PUSH
31737: LD_VAR 0 2
31741: ARRAY
31742: PUSH
31743: LD_VAR 0 3
31747: ARRAY
31748: ST_TO_ADDR
// break ;
31749: GO 31753
// end ; end ;
31751: GO 31507
31753: POP
31754: POP
// if not target then
31755: LD_VAR 0 7
31759: NOT
31760: IFFALSE 31764
// continue ;
31762: GO 31314
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31764: LD_ADDR_VAR 0 8
31768: PUSH
31769: LD_EXP 69
31773: PUSH
31774: LD_VAR 0 2
31778: ARRAY
31779: PPUSH
31780: LD_INT 2
31782: PUSH
31783: LD_INT 3
31785: PUSH
31786: LD_INT 58
31788: PUSH
31789: EMPTY
31790: LIST
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 61
31798: PUSH
31799: EMPTY
31800: LIST
31801: PUSH
31802: LD_INT 33
31804: PUSH
31805: LD_INT 5
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 33
31814: PUSH
31815: LD_INT 3
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: LIST
31826: LIST
31827: LIST
31828: PUSH
31829: LD_INT 2
31831: PUSH
31832: LD_INT 34
31834: PUSH
31835: LD_INT 32
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 34
31844: PUSH
31845: LD_INT 51
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 34
31854: PUSH
31855: LD_INT 12
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PPUSH
31872: CALL_OW 72
31876: ST_TO_ADDR
// if not cargo then
31877: LD_VAR 0 8
31881: NOT
31882: IFFALSE 32588
// begin if mc_crates_collector [ i ] < 5 then
31884: LD_EXP 67
31888: PUSH
31889: LD_VAR 0 2
31893: ARRAY
31894: PUSH
31895: LD_INT 5
31897: LESS
31898: IFFALSE 32264
// begin if mc_ape [ i ] then
31900: LD_EXP 79
31904: PUSH
31905: LD_VAR 0 2
31909: ARRAY
31910: IFFALSE 31957
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31912: LD_ADDR_VAR 0 5
31916: PUSH
31917: LD_EXP 79
31921: PUSH
31922: LD_VAR 0 2
31926: ARRAY
31927: PPUSH
31928: LD_INT 25
31930: PUSH
31931: LD_INT 16
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PUSH
31938: LD_INT 24
31940: PUSH
31941: LD_INT 750
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PPUSH
31952: CALL_OW 72
31956: ST_TO_ADDR
// if not tmp then
31957: LD_VAR 0 5
31961: NOT
31962: IFFALSE 32009
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31964: LD_ADDR_VAR 0 5
31968: PUSH
31969: LD_EXP 50
31973: PUSH
31974: LD_VAR 0 2
31978: ARRAY
31979: PPUSH
31980: LD_INT 25
31982: PUSH
31983: LD_INT 2
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 24
31992: PUSH
31993: LD_INT 750
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PPUSH
32004: CALL_OW 72
32008: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32009: LD_EXP 79
32013: PUSH
32014: LD_VAR 0 2
32018: ARRAY
32019: PUSH
32020: LD_EXP 50
32024: PUSH
32025: LD_VAR 0 2
32029: ARRAY
32030: PPUSH
32031: LD_INT 25
32033: PUSH
32034: LD_INT 2
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 24
32043: PUSH
32044: LD_INT 750
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PPUSH
32055: CALL_OW 72
32059: AND
32060: PUSH
32061: LD_VAR 0 5
32065: PUSH
32066: LD_INT 5
32068: LESS
32069: AND
32070: IFFALSE 32152
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32072: LD_ADDR_VAR 0 3
32076: PUSH
32077: LD_EXP 50
32081: PUSH
32082: LD_VAR 0 2
32086: ARRAY
32087: PPUSH
32088: LD_INT 25
32090: PUSH
32091: LD_INT 2
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 24
32100: PUSH
32101: LD_INT 750
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PPUSH
32112: CALL_OW 72
32116: PUSH
32117: FOR_IN
32118: IFFALSE 32150
// begin tmp := tmp union j ;
32120: LD_ADDR_VAR 0 5
32124: PUSH
32125: LD_VAR 0 5
32129: PUSH
32130: LD_VAR 0 3
32134: UNION
32135: ST_TO_ADDR
// if tmp >= 5 then
32136: LD_VAR 0 5
32140: PUSH
32141: LD_INT 5
32143: GREATEREQUAL
32144: IFFALSE 32148
// break ;
32146: GO 32150
// end ;
32148: GO 32117
32150: POP
32151: POP
// end ; if not tmp then
32152: LD_VAR 0 5
32156: NOT
32157: IFFALSE 32161
// continue ;
32159: GO 31314
// for j in tmp do
32161: LD_ADDR_VAR 0 3
32165: PUSH
32166: LD_VAR 0 5
32170: PUSH
32171: FOR_IN
32172: IFFALSE 32262
// if not GetTag ( j ) then
32174: LD_VAR 0 3
32178: PPUSH
32179: CALL_OW 110
32183: NOT
32184: IFFALSE 32260
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32186: LD_ADDR_EXP 67
32190: PUSH
32191: LD_EXP 67
32195: PPUSH
32196: LD_VAR 0 2
32200: PUSH
32201: LD_EXP 67
32205: PUSH
32206: LD_VAR 0 2
32210: ARRAY
32211: PUSH
32212: LD_INT 1
32214: PLUS
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PPUSH
32220: LD_VAR 0 3
32224: PPUSH
32225: CALL 53792 0 3
32229: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32230: LD_VAR 0 3
32234: PPUSH
32235: LD_INT 107
32237: PPUSH
32238: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32242: LD_EXP 67
32246: PUSH
32247: LD_VAR 0 2
32251: ARRAY
32252: PUSH
32253: LD_INT 5
32255: GREATEREQUAL
32256: IFFALSE 32260
// break ;
32258: GO 32262
// end ;
32260: GO 32171
32262: POP
32263: POP
// end ; if mc_crates_collector [ i ] and target then
32264: LD_EXP 67
32268: PUSH
32269: LD_VAR 0 2
32273: ARRAY
32274: PUSH
32275: LD_VAR 0 7
32279: AND
32280: IFFALSE 32586
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32282: LD_EXP 67
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PUSH
32293: LD_VAR 0 7
32297: PUSH
32298: LD_INT 1
32300: ARRAY
32301: LESS
32302: IFFALSE 32322
// tmp := mc_crates_collector [ i ] else
32304: LD_ADDR_VAR 0 5
32308: PUSH
32309: LD_EXP 67
32313: PUSH
32314: LD_VAR 0 2
32318: ARRAY
32319: ST_TO_ADDR
32320: GO 32336
// tmp := target [ 1 ] ;
32322: LD_ADDR_VAR 0 5
32326: PUSH
32327: LD_VAR 0 7
32331: PUSH
32332: LD_INT 1
32334: ARRAY
32335: ST_TO_ADDR
// k := 0 ;
32336: LD_ADDR_VAR 0 4
32340: PUSH
32341: LD_INT 0
32343: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32344: LD_ADDR_VAR 0 3
32348: PUSH
32349: LD_EXP 67
32353: PUSH
32354: LD_VAR 0 2
32358: ARRAY
32359: PUSH
32360: FOR_IN
32361: IFFALSE 32584
// begin k := k + 1 ;
32363: LD_ADDR_VAR 0 4
32367: PUSH
32368: LD_VAR 0 4
32372: PUSH
32373: LD_INT 1
32375: PLUS
32376: ST_TO_ADDR
// if k > tmp then
32377: LD_VAR 0 4
32381: PUSH
32382: LD_VAR 0 5
32386: GREATER
32387: IFFALSE 32391
// break ;
32389: GO 32584
// if not GetClass ( j ) in [ 2 , 16 ] then
32391: LD_VAR 0 3
32395: PPUSH
32396: CALL_OW 257
32400: PUSH
32401: LD_INT 2
32403: PUSH
32404: LD_INT 16
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: IN
32411: NOT
32412: IFFALSE 32465
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32414: LD_ADDR_EXP 67
32418: PUSH
32419: LD_EXP 67
32423: PPUSH
32424: LD_VAR 0 2
32428: PPUSH
32429: LD_EXP 67
32433: PUSH
32434: LD_VAR 0 2
32438: ARRAY
32439: PUSH
32440: LD_VAR 0 3
32444: DIFF
32445: PPUSH
32446: CALL_OW 1
32450: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32451: LD_VAR 0 3
32455: PPUSH
32456: LD_INT 0
32458: PPUSH
32459: CALL_OW 109
// continue ;
32463: GO 32360
// end ; if IsInUnit ( j ) then
32465: LD_VAR 0 3
32469: PPUSH
32470: CALL_OW 310
32474: IFFALSE 32485
// ComExitBuilding ( j ) ;
32476: LD_VAR 0 3
32480: PPUSH
32481: CALL_OW 122
// wait ( 3 ) ;
32485: LD_INT 3
32487: PPUSH
32488: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32492: LD_VAR 0 3
32496: PPUSH
32497: CALL_OW 314
32501: PUSH
32502: LD_VAR 0 6
32506: PPUSH
32507: LD_VAR 0 7
32511: PUSH
32512: LD_INT 2
32514: ARRAY
32515: PPUSH
32516: LD_VAR 0 7
32520: PUSH
32521: LD_INT 3
32523: ARRAY
32524: PPUSH
32525: LD_INT 30
32527: PPUSH
32528: CALL 54688 0 4
32532: PUSH
32533: LD_INT 4
32535: ARRAY
32536: AND
32537: IFFALSE 32555
// ComStandNearbyBuilding ( j , depot ) else
32539: LD_VAR 0 3
32543: PPUSH
32544: LD_VAR 0 9
32548: PPUSH
32549: CALL 50219 0 2
32553: GO 32582
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32555: LD_VAR 0 3
32559: PPUSH
32560: LD_VAR 0 7
32564: PUSH
32565: LD_INT 2
32567: ARRAY
32568: PPUSH
32569: LD_VAR 0 7
32573: PUSH
32574: LD_INT 3
32576: ARRAY
32577: PPUSH
32578: CALL_OW 117
// end ;
32582: GO 32360
32584: POP
32585: POP
// end ; end else
32586: GO 33118
// begin for j in cargo do
32588: LD_ADDR_VAR 0 3
32592: PUSH
32593: LD_VAR 0 8
32597: PUSH
32598: FOR_IN
32599: IFFALSE 33116
// begin if GetTag ( j ) <> 0 then
32601: LD_VAR 0 3
32605: PPUSH
32606: CALL_OW 110
32610: PUSH
32611: LD_INT 0
32613: NONEQUAL
32614: IFFALSE 32618
// continue ;
32616: GO 32598
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32618: LD_VAR 0 3
32622: PPUSH
32623: CALL_OW 256
32627: PUSH
32628: LD_INT 1000
32630: LESS
32631: PUSH
32632: LD_VAR 0 3
32636: PPUSH
32637: LD_EXP 74
32641: PUSH
32642: LD_VAR 0 2
32646: ARRAY
32647: PPUSH
32648: CALL_OW 308
32652: NOT
32653: AND
32654: IFFALSE 32676
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32656: LD_VAR 0 3
32660: PPUSH
32661: LD_EXP 74
32665: PUSH
32666: LD_VAR 0 2
32670: ARRAY
32671: PPUSH
32672: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32676: LD_VAR 0 3
32680: PPUSH
32681: CALL_OW 256
32685: PUSH
32686: LD_INT 1000
32688: LESS
32689: PUSH
32690: LD_VAR 0 3
32694: PPUSH
32695: LD_EXP 74
32699: PUSH
32700: LD_VAR 0 2
32704: ARRAY
32705: PPUSH
32706: CALL_OW 308
32710: AND
32711: IFFALSE 32715
// continue ;
32713: GO 32598
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32715: LD_VAR 0 3
32719: PPUSH
32720: CALL_OW 262
32724: PUSH
32725: LD_INT 2
32727: EQUAL
32728: PUSH
32729: LD_VAR 0 3
32733: PPUSH
32734: CALL_OW 261
32738: PUSH
32739: LD_INT 15
32741: LESS
32742: AND
32743: IFFALSE 32747
// continue ;
32745: GO 32598
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32747: LD_VAR 0 3
32751: PPUSH
32752: CALL_OW 262
32756: PUSH
32757: LD_INT 1
32759: EQUAL
32760: PUSH
32761: LD_VAR 0 3
32765: PPUSH
32766: CALL_OW 261
32770: PUSH
32771: LD_INT 10
32773: LESS
32774: AND
32775: IFFALSE 33055
// begin if not depot then
32777: LD_VAR 0 9
32781: NOT
32782: IFFALSE 32786
// continue ;
32784: GO 32598
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32786: LD_VAR 0 3
32790: PPUSH
32791: LD_VAR 0 9
32795: PPUSH
32796: LD_VAR 0 3
32800: PPUSH
32801: CALL_OW 74
32805: PPUSH
32806: CALL_OW 296
32810: PUSH
32811: LD_INT 6
32813: LESS
32814: IFFALSE 32830
// SetFuel ( j , 100 ) else
32816: LD_VAR 0 3
32820: PPUSH
32821: LD_INT 100
32823: PPUSH
32824: CALL_OW 240
32828: GO 33055
// if GetFuel ( j ) = 0 then
32830: LD_VAR 0 3
32834: PPUSH
32835: CALL_OW 261
32839: PUSH
32840: LD_INT 0
32842: EQUAL
32843: IFFALSE 33055
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32845: LD_ADDR_EXP 69
32849: PUSH
32850: LD_EXP 69
32854: PPUSH
32855: LD_VAR 0 2
32859: PPUSH
32860: LD_EXP 69
32864: PUSH
32865: LD_VAR 0 2
32869: ARRAY
32870: PUSH
32871: LD_VAR 0 3
32875: DIFF
32876: PPUSH
32877: CALL_OW 1
32881: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32882: LD_VAR 0 3
32886: PPUSH
32887: CALL_OW 263
32891: PUSH
32892: LD_INT 1
32894: EQUAL
32895: IFFALSE 32911
// ComExitVehicle ( IsInUnit ( j ) ) ;
32897: LD_VAR 0 3
32901: PPUSH
32902: CALL_OW 310
32906: PPUSH
32907: CALL_OW 121
// if GetControl ( j ) = control_remote then
32911: LD_VAR 0 3
32915: PPUSH
32916: CALL_OW 263
32920: PUSH
32921: LD_INT 2
32923: EQUAL
32924: IFFALSE 32935
// ComUnlink ( j ) ;
32926: LD_VAR 0 3
32930: PPUSH
32931: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32935: LD_ADDR_VAR 0 10
32939: PUSH
32940: LD_VAR 0 2
32944: PPUSH
32945: LD_INT 3
32947: PPUSH
32948: CALL 42722 0 2
32952: ST_TO_ADDR
// if fac then
32953: LD_VAR 0 10
32957: IFFALSE 33053
// begin for k in fac do
32959: LD_ADDR_VAR 0 4
32963: PUSH
32964: LD_VAR 0 10
32968: PUSH
32969: FOR_IN
32970: IFFALSE 33051
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32972: LD_ADDR_VAR 0 11
32976: PUSH
32977: LD_VAR 0 10
32981: PPUSH
32982: LD_VAR 0 3
32986: PPUSH
32987: CALL_OW 265
32991: PPUSH
32992: LD_VAR 0 3
32996: PPUSH
32997: CALL_OW 262
33001: PPUSH
33002: LD_VAR 0 3
33006: PPUSH
33007: CALL_OW 263
33011: PPUSH
33012: LD_VAR 0 3
33016: PPUSH
33017: CALL_OW 264
33021: PPUSH
33022: CALL 51290 0 5
33026: ST_TO_ADDR
// if components then
33027: LD_VAR 0 11
33031: IFFALSE 33049
// begin MC_InsertProduceList ( i , components ) ;
33033: LD_VAR 0 2
33037: PPUSH
33038: LD_VAR 0 11
33042: PPUSH
33043: CALL 42267 0 2
// break ;
33047: GO 33051
// end ; end ;
33049: GO 32969
33051: POP
33052: POP
// end ; continue ;
33053: GO 32598
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33055: LD_VAR 0 3
33059: PPUSH
33060: LD_INT 1
33062: PPUSH
33063: CALL_OW 289
33067: PUSH
33068: LD_INT 100
33070: LESS
33071: PUSH
33072: LD_VAR 0 3
33076: PPUSH
33077: CALL_OW 314
33081: NOT
33082: AND
33083: IFFALSE 33112
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33085: LD_VAR 0 3
33089: PPUSH
33090: LD_VAR 0 7
33094: PUSH
33095: LD_INT 2
33097: ARRAY
33098: PPUSH
33099: LD_VAR 0 7
33103: PUSH
33104: LD_INT 3
33106: ARRAY
33107: PPUSH
33108: CALL_OW 117
// break ;
33112: GO 33116
// end ;
33114: GO 32598
33116: POP
33117: POP
// end ; end ;
33118: GO 31314
33120: POP
33121: POP
// end ;
33122: LD_VAR 0 1
33126: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33127: LD_INT 0
33129: PPUSH
33130: PPUSH
33131: PPUSH
33132: PPUSH
// if not mc_bases then
33133: LD_EXP 50
33137: NOT
33138: IFFALSE 33142
// exit ;
33140: GO 33303
// for i = 1 to mc_bases do
33142: LD_ADDR_VAR 0 2
33146: PUSH
33147: DOUBLE
33148: LD_INT 1
33150: DEC
33151: ST_TO_ADDR
33152: LD_EXP 50
33156: PUSH
33157: FOR_TO
33158: IFFALSE 33301
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33160: LD_ADDR_VAR 0 4
33164: PUSH
33165: LD_EXP 69
33169: PUSH
33170: LD_VAR 0 2
33174: ARRAY
33175: PUSH
33176: LD_EXP 72
33180: PUSH
33181: LD_VAR 0 2
33185: ARRAY
33186: UNION
33187: PPUSH
33188: LD_INT 33
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PPUSH
33198: CALL_OW 72
33202: ST_TO_ADDR
// if tmp then
33203: LD_VAR 0 4
33207: IFFALSE 33299
// for j in tmp do
33209: LD_ADDR_VAR 0 3
33213: PUSH
33214: LD_VAR 0 4
33218: PUSH
33219: FOR_IN
33220: IFFALSE 33297
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33222: LD_VAR 0 3
33226: PPUSH
33227: CALL_OW 312
33231: NOT
33232: PUSH
33233: LD_VAR 0 3
33237: PPUSH
33238: CALL_OW 256
33242: PUSH
33243: LD_INT 250
33245: GREATEREQUAL
33246: AND
33247: IFFALSE 33260
// Connect ( j ) else
33249: LD_VAR 0 3
33253: PPUSH
33254: CALL 56761 0 1
33258: GO 33295
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33260: LD_VAR 0 3
33264: PPUSH
33265: CALL_OW 256
33269: PUSH
33270: LD_INT 250
33272: LESS
33273: PUSH
33274: LD_VAR 0 3
33278: PPUSH
33279: CALL_OW 312
33283: AND
33284: IFFALSE 33295
// ComUnlink ( j ) ;
33286: LD_VAR 0 3
33290: PPUSH
33291: CALL_OW 136
33295: GO 33219
33297: POP
33298: POP
// end ;
33299: GO 33157
33301: POP
33302: POP
// end ;
33303: LD_VAR 0 1
33307: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33308: LD_INT 0
33310: PPUSH
33311: PPUSH
33312: PPUSH
33313: PPUSH
33314: PPUSH
// if not mc_bases then
33315: LD_EXP 50
33319: NOT
33320: IFFALSE 33324
// exit ;
33322: GO 33769
// for i = 1 to mc_bases do
33324: LD_ADDR_VAR 0 2
33328: PUSH
33329: DOUBLE
33330: LD_INT 1
33332: DEC
33333: ST_TO_ADDR
33334: LD_EXP 50
33338: PUSH
33339: FOR_TO
33340: IFFALSE 33767
// begin if not mc_produce [ i ] then
33342: LD_EXP 71
33346: PUSH
33347: LD_VAR 0 2
33351: ARRAY
33352: NOT
33353: IFFALSE 33357
// continue ;
33355: GO 33339
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33357: LD_ADDR_VAR 0 5
33361: PUSH
33362: LD_EXP 50
33366: PUSH
33367: LD_VAR 0 2
33371: ARRAY
33372: PPUSH
33373: LD_INT 30
33375: PUSH
33376: LD_INT 3
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PPUSH
33383: CALL_OW 72
33387: ST_TO_ADDR
// if not fac then
33388: LD_VAR 0 5
33392: NOT
33393: IFFALSE 33397
// continue ;
33395: GO 33339
// for j in fac do
33397: LD_ADDR_VAR 0 3
33401: PUSH
33402: LD_VAR 0 5
33406: PUSH
33407: FOR_IN
33408: IFFALSE 33763
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33410: LD_VAR 0 3
33414: PPUSH
33415: CALL_OW 461
33419: PUSH
33420: LD_INT 2
33422: NONEQUAL
33423: PUSH
33424: LD_VAR 0 3
33428: PPUSH
33429: LD_INT 15
33431: PPUSH
33432: CALL 56389 0 2
33436: PUSH
33437: LD_INT 4
33439: ARRAY
33440: OR
33441: IFFALSE 33445
// continue ;
33443: GO 33407
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33445: LD_VAR 0 3
33449: PPUSH
33450: LD_EXP 71
33454: PUSH
33455: LD_VAR 0 2
33459: ARRAY
33460: PUSH
33461: LD_INT 1
33463: ARRAY
33464: PUSH
33465: LD_INT 1
33467: ARRAY
33468: PPUSH
33469: LD_EXP 71
33473: PUSH
33474: LD_VAR 0 2
33478: ARRAY
33479: PUSH
33480: LD_INT 1
33482: ARRAY
33483: PUSH
33484: LD_INT 2
33486: ARRAY
33487: PPUSH
33488: LD_EXP 71
33492: PUSH
33493: LD_VAR 0 2
33497: ARRAY
33498: PUSH
33499: LD_INT 1
33501: ARRAY
33502: PUSH
33503: LD_INT 3
33505: ARRAY
33506: PPUSH
33507: LD_EXP 71
33511: PUSH
33512: LD_VAR 0 2
33516: ARRAY
33517: PUSH
33518: LD_INT 1
33520: ARRAY
33521: PUSH
33522: LD_INT 4
33524: ARRAY
33525: PPUSH
33526: CALL_OW 448
33530: PUSH
33531: LD_VAR 0 3
33535: PPUSH
33536: LD_EXP 71
33540: PUSH
33541: LD_VAR 0 2
33545: ARRAY
33546: PUSH
33547: LD_INT 1
33549: ARRAY
33550: PUSH
33551: LD_INT 1
33553: ARRAY
33554: PUSH
33555: LD_EXP 71
33559: PUSH
33560: LD_VAR 0 2
33564: ARRAY
33565: PUSH
33566: LD_INT 1
33568: ARRAY
33569: PUSH
33570: LD_INT 2
33572: ARRAY
33573: PUSH
33574: LD_EXP 71
33578: PUSH
33579: LD_VAR 0 2
33583: ARRAY
33584: PUSH
33585: LD_INT 1
33587: ARRAY
33588: PUSH
33589: LD_INT 3
33591: ARRAY
33592: PUSH
33593: LD_EXP 71
33597: PUSH
33598: LD_VAR 0 2
33602: ARRAY
33603: PUSH
33604: LD_INT 1
33606: ARRAY
33607: PUSH
33608: LD_INT 4
33610: ARRAY
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: PPUSH
33618: CALL 60156 0 2
33622: AND
33623: IFFALSE 33761
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33625: LD_VAR 0 3
33629: PPUSH
33630: LD_EXP 71
33634: PUSH
33635: LD_VAR 0 2
33639: ARRAY
33640: PUSH
33641: LD_INT 1
33643: ARRAY
33644: PUSH
33645: LD_INT 1
33647: ARRAY
33648: PPUSH
33649: LD_EXP 71
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: PUSH
33660: LD_INT 1
33662: ARRAY
33663: PUSH
33664: LD_INT 2
33666: ARRAY
33667: PPUSH
33668: LD_EXP 71
33672: PUSH
33673: LD_VAR 0 2
33677: ARRAY
33678: PUSH
33679: LD_INT 1
33681: ARRAY
33682: PUSH
33683: LD_INT 3
33685: ARRAY
33686: PPUSH
33687: LD_EXP 71
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PUSH
33698: LD_INT 1
33700: ARRAY
33701: PUSH
33702: LD_INT 4
33704: ARRAY
33705: PPUSH
33706: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33710: LD_ADDR_VAR 0 4
33714: PUSH
33715: LD_EXP 71
33719: PUSH
33720: LD_VAR 0 2
33724: ARRAY
33725: PPUSH
33726: LD_INT 1
33728: PPUSH
33729: CALL_OW 3
33733: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33734: LD_ADDR_EXP 71
33738: PUSH
33739: LD_EXP 71
33743: PPUSH
33744: LD_VAR 0 2
33748: PPUSH
33749: LD_VAR 0 4
33753: PPUSH
33754: CALL_OW 1
33758: ST_TO_ADDR
// break ;
33759: GO 33763
// end ; end ;
33761: GO 33407
33763: POP
33764: POP
// end ;
33765: GO 33339
33767: POP
33768: POP
// end ;
33769: LD_VAR 0 1
33773: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33774: LD_INT 0
33776: PPUSH
33777: PPUSH
33778: PPUSH
// if not mc_bases then
33779: LD_EXP 50
33783: NOT
33784: IFFALSE 33788
// exit ;
33786: GO 33877
// for i = 1 to mc_bases do
33788: LD_ADDR_VAR 0 2
33792: PUSH
33793: DOUBLE
33794: LD_INT 1
33796: DEC
33797: ST_TO_ADDR
33798: LD_EXP 50
33802: PUSH
33803: FOR_TO
33804: IFFALSE 33875
// begin if mc_attack [ i ] then
33806: LD_EXP 70
33810: PUSH
33811: LD_VAR 0 2
33815: ARRAY
33816: IFFALSE 33873
// begin tmp := mc_attack [ i ] [ 1 ] ;
33818: LD_ADDR_VAR 0 3
33822: PUSH
33823: LD_EXP 70
33827: PUSH
33828: LD_VAR 0 2
33832: ARRAY
33833: PUSH
33834: LD_INT 1
33836: ARRAY
33837: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33838: LD_ADDR_EXP 70
33842: PUSH
33843: LD_EXP 70
33847: PPUSH
33848: LD_VAR 0 2
33852: PPUSH
33853: EMPTY
33854: PPUSH
33855: CALL_OW 1
33859: ST_TO_ADDR
// Attack ( tmp ) ;
33860: LD_VAR 0 3
33864: PPUSH
33865: CALL 109961 0 1
// exit ;
33869: POP
33870: POP
33871: GO 33877
// end ; end ;
33873: GO 33803
33875: POP
33876: POP
// end ;
33877: LD_VAR 0 1
33881: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33882: LD_INT 0
33884: PPUSH
33885: PPUSH
33886: PPUSH
33887: PPUSH
33888: PPUSH
33889: PPUSH
33890: PPUSH
// if not mc_bases then
33891: LD_EXP 50
33895: NOT
33896: IFFALSE 33900
// exit ;
33898: GO 34757
// for i = 1 to mc_bases do
33900: LD_ADDR_VAR 0 2
33904: PUSH
33905: DOUBLE
33906: LD_INT 1
33908: DEC
33909: ST_TO_ADDR
33910: LD_EXP 50
33914: PUSH
33915: FOR_TO
33916: IFFALSE 34755
// begin if not mc_bases [ i ] then
33918: LD_EXP 50
33922: PUSH
33923: LD_VAR 0 2
33927: ARRAY
33928: NOT
33929: IFFALSE 33933
// continue ;
33931: GO 33915
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33933: LD_ADDR_VAR 0 7
33937: PUSH
33938: LD_EXP 50
33942: PUSH
33943: LD_VAR 0 2
33947: ARRAY
33948: PUSH
33949: LD_INT 1
33951: ARRAY
33952: PPUSH
33953: CALL 50441 0 1
33957: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33958: LD_ADDR_EXP 73
33962: PUSH
33963: LD_EXP 73
33967: PPUSH
33968: LD_VAR 0 2
33972: PPUSH
33973: LD_EXP 50
33977: PUSH
33978: LD_VAR 0 2
33982: ARRAY
33983: PUSH
33984: LD_INT 1
33986: ARRAY
33987: PPUSH
33988: CALL_OW 255
33992: PPUSH
33993: LD_EXP 75
33997: PUSH
33998: LD_VAR 0 2
34002: ARRAY
34003: PPUSH
34004: CALL 50406 0 2
34008: PPUSH
34009: CALL_OW 1
34013: ST_TO_ADDR
// if not mc_scan [ i ] then
34014: LD_EXP 73
34018: PUSH
34019: LD_VAR 0 2
34023: ARRAY
34024: NOT
34025: IFFALSE 34203
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34027: LD_ADDR_EXP 93
34031: PUSH
34032: LD_EXP 93
34036: PPUSH
34037: LD_VAR 0 2
34041: PPUSH
34042: LD_INT 0
34044: PPUSH
34045: CALL_OW 1
34049: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34050: LD_ADDR_VAR 0 4
34054: PUSH
34055: LD_EXP 50
34059: PUSH
34060: LD_VAR 0 2
34064: ARRAY
34065: PPUSH
34066: LD_INT 2
34068: PUSH
34069: LD_INT 25
34071: PUSH
34072: LD_INT 5
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 25
34081: PUSH
34082: LD_INT 8
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 25
34091: PUSH
34092: LD_INT 9
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: PPUSH
34105: CALL_OW 72
34109: ST_TO_ADDR
// if not tmp then
34110: LD_VAR 0 4
34114: NOT
34115: IFFALSE 34119
// continue ;
34117: GO 33915
// for j in tmp do
34119: LD_ADDR_VAR 0 3
34123: PUSH
34124: LD_VAR 0 4
34128: PUSH
34129: FOR_IN
34130: IFFALSE 34201
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34132: LD_VAR 0 3
34136: PPUSH
34137: CALL_OW 310
34141: PPUSH
34142: CALL_OW 266
34146: PUSH
34147: LD_INT 5
34149: EQUAL
34150: PUSH
34151: LD_VAR 0 3
34155: PPUSH
34156: CALL_OW 257
34160: PUSH
34161: LD_INT 1
34163: EQUAL
34164: AND
34165: PUSH
34166: LD_VAR 0 3
34170: PPUSH
34171: CALL_OW 459
34175: NOT
34176: AND
34177: PUSH
34178: LD_VAR 0 7
34182: AND
34183: IFFALSE 34199
// ComChangeProfession ( j , class ) ;
34185: LD_VAR 0 3
34189: PPUSH
34190: LD_VAR 0 7
34194: PPUSH
34195: CALL_OW 123
34199: GO 34129
34201: POP
34202: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34203: LD_EXP 73
34207: PUSH
34208: LD_VAR 0 2
34212: ARRAY
34213: PUSH
34214: LD_EXP 93
34218: PUSH
34219: LD_VAR 0 2
34223: ARRAY
34224: NOT
34225: AND
34226: PUSH
34227: LD_EXP 72
34231: PUSH
34232: LD_VAR 0 2
34236: ARRAY
34237: NOT
34238: AND
34239: PUSH
34240: LD_EXP 50
34244: PUSH
34245: LD_VAR 0 2
34249: ARRAY
34250: PPUSH
34251: LD_INT 50
34253: PUSH
34254: EMPTY
34255: LIST
34256: PUSH
34257: LD_INT 2
34259: PUSH
34260: LD_INT 30
34262: PUSH
34263: LD_INT 32
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 30
34272: PUSH
34273: LD_INT 33
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 30
34282: PUSH
34283: LD_INT 4
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 30
34292: PUSH
34293: LD_INT 5
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PPUSH
34311: CALL_OW 72
34315: PUSH
34316: LD_INT 4
34318: LESS
34319: PUSH
34320: LD_EXP 50
34324: PUSH
34325: LD_VAR 0 2
34329: ARRAY
34330: PPUSH
34331: LD_INT 3
34333: PUSH
34334: LD_INT 24
34336: PUSH
34337: LD_INT 1000
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 2
34350: PUSH
34351: LD_INT 30
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 30
34363: PUSH
34364: LD_INT 1
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: LIST
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PPUSH
34380: CALL_OW 72
34384: OR
34385: AND
34386: IFFALSE 34637
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34388: LD_ADDR_EXP 93
34392: PUSH
34393: LD_EXP 93
34397: PPUSH
34398: LD_VAR 0 2
34402: PPUSH
34403: LD_INT 1
34405: PPUSH
34406: CALL_OW 1
34410: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34411: LD_ADDR_VAR 0 4
34415: PUSH
34416: LD_EXP 50
34420: PUSH
34421: LD_VAR 0 2
34425: ARRAY
34426: PPUSH
34427: LD_INT 2
34429: PUSH
34430: LD_INT 25
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 25
34442: PUSH
34443: LD_INT 5
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 25
34452: PUSH
34453: LD_INT 8
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 25
34462: PUSH
34463: LD_INT 9
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: PPUSH
34477: CALL_OW 72
34481: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34482: LD_ADDR_VAR 0 4
34486: PUSH
34487: LD_VAR 0 4
34491: PUSH
34492: LD_VAR 0 4
34496: PPUSH
34497: LD_INT 18
34499: PPUSH
34500: CALL 83678 0 2
34504: DIFF
34505: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34506: LD_VAR 0 4
34510: NOT
34511: PUSH
34512: LD_EXP 50
34516: PUSH
34517: LD_VAR 0 2
34521: ARRAY
34522: PPUSH
34523: LD_INT 2
34525: PUSH
34526: LD_INT 30
34528: PUSH
34529: LD_INT 4
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 30
34538: PUSH
34539: LD_INT 5
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: LIST
34550: PPUSH
34551: CALL_OW 72
34555: NOT
34556: AND
34557: IFFALSE 34619
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34559: LD_ADDR_VAR 0 4
34563: PUSH
34564: LD_EXP 50
34568: PUSH
34569: LD_VAR 0 2
34573: ARRAY
34574: PPUSH
34575: LD_INT 2
34577: PUSH
34578: LD_INT 25
34580: PUSH
34581: LD_INT 2
34583: PUSH
34584: EMPTY
34585: LIST
34586: LIST
34587: PUSH
34588: LD_INT 25
34590: PUSH
34591: LD_INT 3
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 25
34600: PUSH
34601: LD_INT 4
34603: PUSH
34604: EMPTY
34605: LIST
34606: LIST
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: PPUSH
34614: CALL_OW 72
34618: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34619: LD_VAR 0 2
34623: PPUSH
34624: LD_VAR 0 4
34628: PPUSH
34629: CALL 114670 0 2
// exit ;
34633: POP
34634: POP
34635: GO 34757
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34637: LD_EXP 73
34641: PUSH
34642: LD_VAR 0 2
34646: ARRAY
34647: PUSH
34648: LD_EXP 93
34652: PUSH
34653: LD_VAR 0 2
34657: ARRAY
34658: NOT
34659: AND
34660: PUSH
34661: LD_EXP 72
34665: PUSH
34666: LD_VAR 0 2
34670: ARRAY
34671: AND
34672: IFFALSE 34753
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34674: LD_ADDR_EXP 93
34678: PUSH
34679: LD_EXP 93
34683: PPUSH
34684: LD_VAR 0 2
34688: PPUSH
34689: LD_INT 1
34691: PPUSH
34692: CALL_OW 1
34696: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34697: LD_ADDR_VAR 0 4
34701: PUSH
34702: LD_EXP 72
34706: PUSH
34707: LD_VAR 0 2
34711: ARRAY
34712: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34713: LD_ADDR_EXP 72
34717: PUSH
34718: LD_EXP 72
34722: PPUSH
34723: LD_VAR 0 2
34727: PPUSH
34728: EMPTY
34729: PPUSH
34730: CALL_OW 1
34734: ST_TO_ADDR
// Defend ( i , tmp ) ;
34735: LD_VAR 0 2
34739: PPUSH
34740: LD_VAR 0 4
34744: PPUSH
34745: CALL 115266 0 2
// exit ;
34749: POP
34750: POP
34751: GO 34757
// end ; end ;
34753: GO 33915
34755: POP
34756: POP
// end ;
34757: LD_VAR 0 1
34761: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34762: LD_INT 0
34764: PPUSH
34765: PPUSH
34766: PPUSH
34767: PPUSH
34768: PPUSH
34769: PPUSH
34770: PPUSH
34771: PPUSH
34772: PPUSH
34773: PPUSH
34774: PPUSH
// if not mc_bases then
34775: LD_EXP 50
34779: NOT
34780: IFFALSE 34784
// exit ;
34782: GO 35871
// for i = 1 to mc_bases do
34784: LD_ADDR_VAR 0 2
34788: PUSH
34789: DOUBLE
34790: LD_INT 1
34792: DEC
34793: ST_TO_ADDR
34794: LD_EXP 50
34798: PUSH
34799: FOR_TO
34800: IFFALSE 35869
// begin tmp := mc_lab [ i ] ;
34802: LD_ADDR_VAR 0 6
34806: PUSH
34807: LD_EXP 83
34811: PUSH
34812: LD_VAR 0 2
34816: ARRAY
34817: ST_TO_ADDR
// if not tmp then
34818: LD_VAR 0 6
34822: NOT
34823: IFFALSE 34827
// continue ;
34825: GO 34799
// idle_lab := 0 ;
34827: LD_ADDR_VAR 0 11
34831: PUSH
34832: LD_INT 0
34834: ST_TO_ADDR
// for j in tmp do
34835: LD_ADDR_VAR 0 3
34839: PUSH
34840: LD_VAR 0 6
34844: PUSH
34845: FOR_IN
34846: IFFALSE 35865
// begin researching := false ;
34848: LD_ADDR_VAR 0 10
34852: PUSH
34853: LD_INT 0
34855: ST_TO_ADDR
// side := GetSide ( j ) ;
34856: LD_ADDR_VAR 0 4
34860: PUSH
34861: LD_VAR 0 3
34865: PPUSH
34866: CALL_OW 255
34870: ST_TO_ADDR
// if not mc_tech [ side ] then
34871: LD_EXP 77
34875: PUSH
34876: LD_VAR 0 4
34880: ARRAY
34881: NOT
34882: IFFALSE 34886
// continue ;
34884: GO 34845
// if BuildingStatus ( j ) = bs_idle then
34886: LD_VAR 0 3
34890: PPUSH
34891: CALL_OW 461
34895: PUSH
34896: LD_INT 2
34898: EQUAL
34899: IFFALSE 35087
// begin if idle_lab and UnitsInside ( j ) < 6 then
34901: LD_VAR 0 11
34905: PUSH
34906: LD_VAR 0 3
34910: PPUSH
34911: CALL_OW 313
34915: PUSH
34916: LD_INT 6
34918: LESS
34919: AND
34920: IFFALSE 34991
// begin tmp2 := UnitsInside ( idle_lab ) ;
34922: LD_ADDR_VAR 0 9
34926: PUSH
34927: LD_VAR 0 11
34931: PPUSH
34932: CALL_OW 313
34936: ST_TO_ADDR
// if tmp2 then
34937: LD_VAR 0 9
34941: IFFALSE 34983
// for x in tmp2 do
34943: LD_ADDR_VAR 0 7
34947: PUSH
34948: LD_VAR 0 9
34952: PUSH
34953: FOR_IN
34954: IFFALSE 34981
// begin ComExitBuilding ( x ) ;
34956: LD_VAR 0 7
34960: PPUSH
34961: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34965: LD_VAR 0 7
34969: PPUSH
34970: LD_VAR 0 3
34974: PPUSH
34975: CALL_OW 180
// end ;
34979: GO 34953
34981: POP
34982: POP
// idle_lab := 0 ;
34983: LD_ADDR_VAR 0 11
34987: PUSH
34988: LD_INT 0
34990: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34991: LD_ADDR_VAR 0 5
34995: PUSH
34996: LD_EXP 77
35000: PUSH
35001: LD_VAR 0 4
35005: ARRAY
35006: PUSH
35007: FOR_IN
35008: IFFALSE 35068
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35010: LD_VAR 0 3
35014: PPUSH
35015: LD_VAR 0 5
35019: PPUSH
35020: CALL_OW 430
35024: PUSH
35025: LD_VAR 0 4
35029: PPUSH
35030: LD_VAR 0 5
35034: PPUSH
35035: CALL 49511 0 2
35039: AND
35040: IFFALSE 35066
// begin researching := true ;
35042: LD_ADDR_VAR 0 10
35046: PUSH
35047: LD_INT 1
35049: ST_TO_ADDR
// ComResearch ( j , t ) ;
35050: LD_VAR 0 3
35054: PPUSH
35055: LD_VAR 0 5
35059: PPUSH
35060: CALL_OW 124
// break ;
35064: GO 35068
// end ;
35066: GO 35007
35068: POP
35069: POP
// if not researching then
35070: LD_VAR 0 10
35074: NOT
35075: IFFALSE 35087
// idle_lab := j ;
35077: LD_ADDR_VAR 0 11
35081: PUSH
35082: LD_VAR 0 3
35086: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35087: LD_VAR 0 3
35091: PPUSH
35092: CALL_OW 461
35096: PUSH
35097: LD_INT 10
35099: EQUAL
35100: IFFALSE 35688
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35102: LD_EXP 79
35106: PUSH
35107: LD_VAR 0 2
35111: ARRAY
35112: NOT
35113: PUSH
35114: LD_EXP 80
35118: PUSH
35119: LD_VAR 0 2
35123: ARRAY
35124: NOT
35125: AND
35126: PUSH
35127: LD_EXP 77
35131: PUSH
35132: LD_VAR 0 4
35136: ARRAY
35137: PUSH
35138: LD_INT 1
35140: GREATER
35141: AND
35142: IFFALSE 35273
// begin ComCancel ( j ) ;
35144: LD_VAR 0 3
35148: PPUSH
35149: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35153: LD_ADDR_EXP 77
35157: PUSH
35158: LD_EXP 77
35162: PPUSH
35163: LD_VAR 0 4
35167: PPUSH
35168: LD_EXP 77
35172: PUSH
35173: LD_VAR 0 4
35177: ARRAY
35178: PPUSH
35179: LD_EXP 77
35183: PUSH
35184: LD_VAR 0 4
35188: ARRAY
35189: PUSH
35190: LD_INT 1
35192: MINUS
35193: PPUSH
35194: LD_EXP 77
35198: PUSH
35199: LD_VAR 0 4
35203: ARRAY
35204: PPUSH
35205: LD_INT 0
35207: PPUSH
35208: CALL 53210 0 4
35212: PPUSH
35213: CALL_OW 1
35217: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35218: LD_ADDR_EXP 77
35222: PUSH
35223: LD_EXP 77
35227: PPUSH
35228: LD_VAR 0 4
35232: PPUSH
35233: LD_EXP 77
35237: PUSH
35238: LD_VAR 0 4
35242: ARRAY
35243: PPUSH
35244: LD_EXP 77
35248: PUSH
35249: LD_VAR 0 4
35253: ARRAY
35254: PPUSH
35255: LD_INT 1
35257: PPUSH
35258: LD_INT 0
35260: PPUSH
35261: CALL 53210 0 4
35265: PPUSH
35266: CALL_OW 1
35270: ST_TO_ADDR
// continue ;
35271: GO 34845
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35273: LD_EXP 79
35277: PUSH
35278: LD_VAR 0 2
35282: ARRAY
35283: PUSH
35284: LD_EXP 80
35288: PUSH
35289: LD_VAR 0 2
35293: ARRAY
35294: NOT
35295: AND
35296: IFFALSE 35423
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35298: LD_ADDR_EXP 80
35302: PUSH
35303: LD_EXP 80
35307: PPUSH
35308: LD_VAR 0 2
35312: PUSH
35313: LD_EXP 80
35317: PUSH
35318: LD_VAR 0 2
35322: ARRAY
35323: PUSH
35324: LD_INT 1
35326: PLUS
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PPUSH
35332: LD_EXP 79
35336: PUSH
35337: LD_VAR 0 2
35341: ARRAY
35342: PUSH
35343: LD_INT 1
35345: ARRAY
35346: PPUSH
35347: CALL 53792 0 3
35351: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35352: LD_EXP 79
35356: PUSH
35357: LD_VAR 0 2
35361: ARRAY
35362: PUSH
35363: LD_INT 1
35365: ARRAY
35366: PPUSH
35367: LD_INT 112
35369: PPUSH
35370: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35374: LD_ADDR_VAR 0 9
35378: PUSH
35379: LD_EXP 79
35383: PUSH
35384: LD_VAR 0 2
35388: ARRAY
35389: PPUSH
35390: LD_INT 1
35392: PPUSH
35393: CALL_OW 3
35397: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35398: LD_ADDR_EXP 79
35402: PUSH
35403: LD_EXP 79
35407: PPUSH
35408: LD_VAR 0 2
35412: PPUSH
35413: LD_VAR 0 9
35417: PPUSH
35418: CALL_OW 1
35422: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35423: LD_EXP 79
35427: PUSH
35428: LD_VAR 0 2
35432: ARRAY
35433: PUSH
35434: LD_EXP 80
35438: PUSH
35439: LD_VAR 0 2
35443: ARRAY
35444: AND
35445: PUSH
35446: LD_EXP 80
35450: PUSH
35451: LD_VAR 0 2
35455: ARRAY
35456: PUSH
35457: LD_INT 1
35459: ARRAY
35460: PPUSH
35461: CALL_OW 310
35465: NOT
35466: AND
35467: PUSH
35468: LD_VAR 0 3
35472: PPUSH
35473: CALL_OW 313
35477: PUSH
35478: LD_INT 6
35480: EQUAL
35481: AND
35482: IFFALSE 35538
// begin tmp2 := UnitsInside ( j ) ;
35484: LD_ADDR_VAR 0 9
35488: PUSH
35489: LD_VAR 0 3
35493: PPUSH
35494: CALL_OW 313
35498: ST_TO_ADDR
// if tmp2 = 6 then
35499: LD_VAR 0 9
35503: PUSH
35504: LD_INT 6
35506: EQUAL
35507: IFFALSE 35538
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35509: LD_VAR 0 9
35513: PUSH
35514: LD_INT 1
35516: ARRAY
35517: PPUSH
35518: LD_INT 112
35520: PPUSH
35521: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35525: LD_VAR 0 9
35529: PUSH
35530: LD_INT 1
35532: ARRAY
35533: PPUSH
35534: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35538: LD_EXP 80
35542: PUSH
35543: LD_VAR 0 2
35547: ARRAY
35548: PUSH
35549: LD_EXP 80
35553: PUSH
35554: LD_VAR 0 2
35558: ARRAY
35559: PUSH
35560: LD_INT 1
35562: ARRAY
35563: PPUSH
35564: CALL_OW 314
35568: NOT
35569: AND
35570: PUSH
35571: LD_EXP 80
35575: PUSH
35576: LD_VAR 0 2
35580: ARRAY
35581: PUSH
35582: LD_INT 1
35584: ARRAY
35585: PPUSH
35586: CALL_OW 310
35590: NOT
35591: AND
35592: IFFALSE 35618
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35594: LD_EXP 80
35598: PUSH
35599: LD_VAR 0 2
35603: ARRAY
35604: PUSH
35605: LD_INT 1
35607: ARRAY
35608: PPUSH
35609: LD_VAR 0 3
35613: PPUSH
35614: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35618: LD_EXP 80
35622: PUSH
35623: LD_VAR 0 2
35627: ARRAY
35628: PUSH
35629: LD_INT 1
35631: ARRAY
35632: PPUSH
35633: CALL_OW 310
35637: PUSH
35638: LD_EXP 80
35642: PUSH
35643: LD_VAR 0 2
35647: ARRAY
35648: PUSH
35649: LD_INT 1
35651: ARRAY
35652: PPUSH
35653: CALL_OW 310
35657: PPUSH
35658: CALL_OW 461
35662: PUSH
35663: LD_INT 3
35665: NONEQUAL
35666: AND
35667: IFFALSE 35688
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35669: LD_EXP 80
35673: PUSH
35674: LD_VAR 0 2
35678: ARRAY
35679: PUSH
35680: LD_INT 1
35682: ARRAY
35683: PPUSH
35684: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35688: LD_VAR 0 3
35692: PPUSH
35693: CALL_OW 461
35697: PUSH
35698: LD_INT 6
35700: EQUAL
35701: PUSH
35702: LD_VAR 0 6
35706: PUSH
35707: LD_INT 1
35709: GREATER
35710: AND
35711: IFFALSE 35863
// begin sci := [ ] ;
35713: LD_ADDR_VAR 0 8
35717: PUSH
35718: EMPTY
35719: ST_TO_ADDR
// for x in ( tmp diff j ) do
35720: LD_ADDR_VAR 0 7
35724: PUSH
35725: LD_VAR 0 6
35729: PUSH
35730: LD_VAR 0 3
35734: DIFF
35735: PUSH
35736: FOR_IN
35737: IFFALSE 35789
// begin if sci = 6 then
35739: LD_VAR 0 8
35743: PUSH
35744: LD_INT 6
35746: EQUAL
35747: IFFALSE 35751
// break ;
35749: GO 35789
// if BuildingStatus ( x ) = bs_idle then
35751: LD_VAR 0 7
35755: PPUSH
35756: CALL_OW 461
35760: PUSH
35761: LD_INT 2
35763: EQUAL
35764: IFFALSE 35787
// sci := sci ^ UnitsInside ( x ) ;
35766: LD_ADDR_VAR 0 8
35770: PUSH
35771: LD_VAR 0 8
35775: PUSH
35776: LD_VAR 0 7
35780: PPUSH
35781: CALL_OW 313
35785: ADD
35786: ST_TO_ADDR
// end ;
35787: GO 35736
35789: POP
35790: POP
// if not sci then
35791: LD_VAR 0 8
35795: NOT
35796: IFFALSE 35800
// continue ;
35798: GO 34845
// for x in sci do
35800: LD_ADDR_VAR 0 7
35804: PUSH
35805: LD_VAR 0 8
35809: PUSH
35810: FOR_IN
35811: IFFALSE 35861
// if IsInUnit ( x ) and not HasTask ( x ) then
35813: LD_VAR 0 7
35817: PPUSH
35818: CALL_OW 310
35822: PUSH
35823: LD_VAR 0 7
35827: PPUSH
35828: CALL_OW 314
35832: NOT
35833: AND
35834: IFFALSE 35859
// begin ComExitBuilding ( x ) ;
35836: LD_VAR 0 7
35840: PPUSH
35841: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35845: LD_VAR 0 7
35849: PPUSH
35850: LD_VAR 0 3
35854: PPUSH
35855: CALL_OW 180
// end ;
35859: GO 35810
35861: POP
35862: POP
// end ; end ;
35863: GO 34845
35865: POP
35866: POP
// end ;
35867: GO 34799
35869: POP
35870: POP
// end ;
35871: LD_VAR 0 1
35875: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35876: LD_INT 0
35878: PPUSH
35879: PPUSH
// if not mc_bases then
35880: LD_EXP 50
35884: NOT
35885: IFFALSE 35889
// exit ;
35887: GO 35970
// for i = 1 to mc_bases do
35889: LD_ADDR_VAR 0 2
35893: PUSH
35894: DOUBLE
35895: LD_INT 1
35897: DEC
35898: ST_TO_ADDR
35899: LD_EXP 50
35903: PUSH
35904: FOR_TO
35905: IFFALSE 35968
// if mc_mines [ i ] and mc_miners [ i ] then
35907: LD_EXP 63
35911: PUSH
35912: LD_VAR 0 2
35916: ARRAY
35917: PUSH
35918: LD_EXP 64
35922: PUSH
35923: LD_VAR 0 2
35927: ARRAY
35928: AND
35929: IFFALSE 35966
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35931: LD_EXP 64
35935: PUSH
35936: LD_VAR 0 2
35940: ARRAY
35941: PUSH
35942: LD_INT 1
35944: ARRAY
35945: PPUSH
35946: CALL_OW 255
35950: PPUSH
35951: LD_EXP 63
35955: PUSH
35956: LD_VAR 0 2
35960: ARRAY
35961: PPUSH
35962: CALL 50594 0 2
35966: GO 35904
35968: POP
35969: POP
// end ;
35970: LD_VAR 0 1
35974: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35975: LD_INT 0
35977: PPUSH
35978: PPUSH
35979: PPUSH
35980: PPUSH
35981: PPUSH
35982: PPUSH
35983: PPUSH
35984: PPUSH
// if not mc_bases or not mc_parking then
35985: LD_EXP 50
35989: NOT
35990: PUSH
35991: LD_EXP 74
35995: NOT
35996: OR
35997: IFFALSE 36001
// exit ;
35999: GO 36739
// for i = 1 to mc_bases do
36001: LD_ADDR_VAR 0 2
36005: PUSH
36006: DOUBLE
36007: LD_INT 1
36009: DEC
36010: ST_TO_ADDR
36011: LD_EXP 50
36015: PUSH
36016: FOR_TO
36017: IFFALSE 36737
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36019: LD_EXP 50
36023: PUSH
36024: LD_VAR 0 2
36028: ARRAY
36029: NOT
36030: PUSH
36031: LD_EXP 74
36035: PUSH
36036: LD_VAR 0 2
36040: ARRAY
36041: NOT
36042: OR
36043: IFFALSE 36047
// continue ;
36045: GO 36016
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36047: LD_ADDR_VAR 0 5
36051: PUSH
36052: LD_EXP 50
36056: PUSH
36057: LD_VAR 0 2
36061: ARRAY
36062: PUSH
36063: LD_INT 1
36065: ARRAY
36066: PPUSH
36067: CALL_OW 255
36071: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36072: LD_ADDR_VAR 0 6
36076: PUSH
36077: LD_EXP 50
36081: PUSH
36082: LD_VAR 0 2
36086: ARRAY
36087: PPUSH
36088: LD_INT 30
36090: PUSH
36091: LD_INT 3
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PPUSH
36098: CALL_OW 72
36102: ST_TO_ADDR
// if not fac then
36103: LD_VAR 0 6
36107: NOT
36108: IFFALSE 36159
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36110: LD_ADDR_VAR 0 6
36114: PUSH
36115: LD_EXP 50
36119: PUSH
36120: LD_VAR 0 2
36124: ARRAY
36125: PPUSH
36126: LD_INT 2
36128: PUSH
36129: LD_INT 30
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 30
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: LIST
36153: PPUSH
36154: CALL_OW 72
36158: ST_TO_ADDR
// if not fac then
36159: LD_VAR 0 6
36163: NOT
36164: IFFALSE 36168
// continue ;
36166: GO 36016
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36168: LD_ADDR_VAR 0 7
36172: PUSH
36173: LD_EXP 74
36177: PUSH
36178: LD_VAR 0 2
36182: ARRAY
36183: PPUSH
36184: LD_INT 22
36186: PUSH
36187: LD_VAR 0 5
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 21
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 3
36208: PUSH
36209: LD_INT 60
36211: PUSH
36212: EMPTY
36213: LIST
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 3
36221: PUSH
36222: LD_INT 24
36224: PUSH
36225: LD_INT 1000
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: PPUSH
36242: CALL_OW 70
36246: ST_TO_ADDR
// for j in fac do
36247: LD_ADDR_VAR 0 3
36251: PUSH
36252: LD_VAR 0 6
36256: PUSH
36257: FOR_IN
36258: IFFALSE 36353
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36260: LD_ADDR_VAR 0 7
36264: PUSH
36265: LD_VAR 0 7
36269: PUSH
36270: LD_INT 22
36272: PUSH
36273: LD_VAR 0 5
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 91
36284: PUSH
36285: LD_VAR 0 3
36289: PUSH
36290: LD_INT 15
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 21
36300: PUSH
36301: LD_INT 2
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 3
36310: PUSH
36311: LD_INT 60
36313: PUSH
36314: EMPTY
36315: LIST
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 3
36323: PUSH
36324: LD_INT 24
36326: PUSH
36327: LD_INT 1000
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: EMPTY
36335: LIST
36336: LIST
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: PPUSH
36345: CALL_OW 69
36349: UNION
36350: ST_TO_ADDR
36351: GO 36257
36353: POP
36354: POP
// if not vehs then
36355: LD_VAR 0 7
36359: NOT
36360: IFFALSE 36386
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36362: LD_ADDR_EXP 62
36366: PUSH
36367: LD_EXP 62
36371: PPUSH
36372: LD_VAR 0 2
36376: PPUSH
36377: EMPTY
36378: PPUSH
36379: CALL_OW 1
36383: ST_TO_ADDR
// continue ;
36384: GO 36016
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36386: LD_ADDR_VAR 0 8
36390: PUSH
36391: LD_EXP 50
36395: PUSH
36396: LD_VAR 0 2
36400: ARRAY
36401: PPUSH
36402: LD_INT 30
36404: PUSH
36405: LD_INT 3
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PPUSH
36412: CALL_OW 72
36416: ST_TO_ADDR
// if tmp then
36417: LD_VAR 0 8
36421: IFFALSE 36524
// begin for j in tmp do
36423: LD_ADDR_VAR 0 3
36427: PUSH
36428: LD_VAR 0 8
36432: PUSH
36433: FOR_IN
36434: IFFALSE 36522
// for k in UnitsInside ( j ) do
36436: LD_ADDR_VAR 0 4
36440: PUSH
36441: LD_VAR 0 3
36445: PPUSH
36446: CALL_OW 313
36450: PUSH
36451: FOR_IN
36452: IFFALSE 36518
// if k then
36454: LD_VAR 0 4
36458: IFFALSE 36516
// if not k in mc_repair_vehicle [ i ] then
36460: LD_VAR 0 4
36464: PUSH
36465: LD_EXP 62
36469: PUSH
36470: LD_VAR 0 2
36474: ARRAY
36475: IN
36476: NOT
36477: IFFALSE 36516
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36479: LD_ADDR_EXP 62
36483: PUSH
36484: LD_EXP 62
36488: PPUSH
36489: LD_VAR 0 2
36493: PPUSH
36494: LD_EXP 62
36498: PUSH
36499: LD_VAR 0 2
36503: ARRAY
36504: PUSH
36505: LD_VAR 0 4
36509: UNION
36510: PPUSH
36511: CALL_OW 1
36515: ST_TO_ADDR
36516: GO 36451
36518: POP
36519: POP
36520: GO 36433
36522: POP
36523: POP
// end ; if not mc_repair_vehicle [ i ] then
36524: LD_EXP 62
36528: PUSH
36529: LD_VAR 0 2
36533: ARRAY
36534: NOT
36535: IFFALSE 36539
// continue ;
36537: GO 36016
// for j in mc_repair_vehicle [ i ] do
36539: LD_ADDR_VAR 0 3
36543: PUSH
36544: LD_EXP 62
36548: PUSH
36549: LD_VAR 0 2
36553: ARRAY
36554: PUSH
36555: FOR_IN
36556: IFFALSE 36733
// begin if GetClass ( j ) <> 3 then
36558: LD_VAR 0 3
36562: PPUSH
36563: CALL_OW 257
36567: PUSH
36568: LD_INT 3
36570: NONEQUAL
36571: IFFALSE 36612
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36573: LD_ADDR_EXP 62
36577: PUSH
36578: LD_EXP 62
36582: PPUSH
36583: LD_VAR 0 2
36587: PPUSH
36588: LD_EXP 62
36592: PUSH
36593: LD_VAR 0 2
36597: ARRAY
36598: PUSH
36599: LD_VAR 0 3
36603: DIFF
36604: PPUSH
36605: CALL_OW 1
36609: ST_TO_ADDR
// continue ;
36610: GO 36555
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36612: LD_VAR 0 3
36616: PPUSH
36617: CALL_OW 311
36621: NOT
36622: PUSH
36623: LD_VAR 0 3
36627: PUSH
36628: LD_EXP 53
36632: PUSH
36633: LD_VAR 0 2
36637: ARRAY
36638: PUSH
36639: LD_INT 1
36641: ARRAY
36642: IN
36643: NOT
36644: AND
36645: PUSH
36646: LD_VAR 0 3
36650: PUSH
36651: LD_EXP 53
36655: PUSH
36656: LD_VAR 0 2
36660: ARRAY
36661: PUSH
36662: LD_INT 2
36664: ARRAY
36665: IN
36666: NOT
36667: AND
36668: IFFALSE 36731
// begin if IsInUnit ( j ) then
36670: LD_VAR 0 3
36674: PPUSH
36675: CALL_OW 310
36679: IFFALSE 36692
// ComExitBuilding ( j ) else
36681: LD_VAR 0 3
36685: PPUSH
36686: CALL_OW 122
36690: GO 36731
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36692: LD_VAR 0 3
36696: PPUSH
36697: LD_VAR 0 7
36701: PUSH
36702: LD_INT 1
36704: ARRAY
36705: PPUSH
36706: CALL 88169 0 2
36710: NOT
36711: IFFALSE 36731
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36713: LD_VAR 0 3
36717: PPUSH
36718: LD_VAR 0 7
36722: PUSH
36723: LD_INT 1
36725: ARRAY
36726: PPUSH
36727: CALL_OW 129
// end ; end ;
36731: GO 36555
36733: POP
36734: POP
// end ;
36735: GO 36016
36737: POP
36738: POP
// end ;
36739: LD_VAR 0 1
36743: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36744: LD_INT 0
36746: PPUSH
36747: PPUSH
36748: PPUSH
36749: PPUSH
36750: PPUSH
36751: PPUSH
36752: PPUSH
36753: PPUSH
36754: PPUSH
36755: PPUSH
36756: PPUSH
// if not mc_bases then
36757: LD_EXP 50
36761: NOT
36762: IFFALSE 36766
// exit ;
36764: GO 37568
// for i = 1 to mc_bases do
36766: LD_ADDR_VAR 0 2
36770: PUSH
36771: DOUBLE
36772: LD_INT 1
36774: DEC
36775: ST_TO_ADDR
36776: LD_EXP 50
36780: PUSH
36781: FOR_TO
36782: IFFALSE 37566
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36784: LD_EXP 78
36788: PUSH
36789: LD_VAR 0 2
36793: ARRAY
36794: NOT
36795: PUSH
36796: LD_EXP 53
36800: PUSH
36801: LD_VAR 0 2
36805: ARRAY
36806: PUSH
36807: LD_INT 1
36809: ARRAY
36810: OR
36811: PUSH
36812: LD_EXP 53
36816: PUSH
36817: LD_VAR 0 2
36821: ARRAY
36822: PUSH
36823: LD_INT 2
36825: ARRAY
36826: OR
36827: PUSH
36828: LD_EXP 76
36832: PUSH
36833: LD_VAR 0 2
36837: ARRAY
36838: PPUSH
36839: LD_INT 1
36841: PPUSH
36842: CALL_OW 325
36846: NOT
36847: OR
36848: PUSH
36849: LD_EXP 73
36853: PUSH
36854: LD_VAR 0 2
36858: ARRAY
36859: OR
36860: IFFALSE 36864
// continue ;
36862: GO 36781
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36864: LD_ADDR_VAR 0 8
36868: PUSH
36869: LD_EXP 50
36873: PUSH
36874: LD_VAR 0 2
36878: ARRAY
36879: PPUSH
36880: LD_INT 25
36882: PUSH
36883: LD_INT 4
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 50
36892: PUSH
36893: EMPTY
36894: LIST
36895: PUSH
36896: LD_INT 3
36898: PUSH
36899: LD_INT 60
36901: PUSH
36902: EMPTY
36903: LIST
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: LIST
36913: PPUSH
36914: CALL_OW 72
36918: PUSH
36919: LD_EXP 54
36923: PUSH
36924: LD_VAR 0 2
36928: ARRAY
36929: DIFF
36930: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36931: LD_ADDR_VAR 0 9
36935: PUSH
36936: LD_EXP 50
36940: PUSH
36941: LD_VAR 0 2
36945: ARRAY
36946: PPUSH
36947: LD_INT 2
36949: PUSH
36950: LD_INT 30
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 30
36962: PUSH
36963: LD_INT 1
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: LIST
36974: PPUSH
36975: CALL_OW 72
36979: ST_TO_ADDR
// if not tmp or not dep then
36980: LD_VAR 0 8
36984: NOT
36985: PUSH
36986: LD_VAR 0 9
36990: NOT
36991: OR
36992: IFFALSE 36996
// continue ;
36994: GO 36781
// side := GetSide ( tmp [ 1 ] ) ;
36996: LD_ADDR_VAR 0 11
37000: PUSH
37001: LD_VAR 0 8
37005: PUSH
37006: LD_INT 1
37008: ARRAY
37009: PPUSH
37010: CALL_OW 255
37014: ST_TO_ADDR
// dep := dep [ 1 ] ;
37015: LD_ADDR_VAR 0 9
37019: PUSH
37020: LD_VAR 0 9
37024: PUSH
37025: LD_INT 1
37027: ARRAY
37028: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37029: LD_ADDR_VAR 0 7
37033: PUSH
37034: LD_EXP 78
37038: PUSH
37039: LD_VAR 0 2
37043: ARRAY
37044: PPUSH
37045: LD_INT 22
37047: PUSH
37048: LD_INT 0
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 25
37057: PUSH
37058: LD_INT 12
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PPUSH
37069: CALL_OW 70
37073: PUSH
37074: LD_INT 22
37076: PUSH
37077: LD_INT 0
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 25
37086: PUSH
37087: LD_INT 12
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 91
37096: PUSH
37097: LD_VAR 0 9
37101: PUSH
37102: LD_INT 20
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: LIST
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: LIST
37114: PPUSH
37115: CALL_OW 69
37119: UNION
37120: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37121: LD_ADDR_VAR 0 10
37125: PUSH
37126: LD_EXP 78
37130: PUSH
37131: LD_VAR 0 2
37135: ARRAY
37136: PPUSH
37137: LD_INT 81
37139: PUSH
37140: LD_VAR 0 11
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PPUSH
37149: CALL_OW 70
37153: ST_TO_ADDR
// if not apes or danger_at_area then
37154: LD_VAR 0 7
37158: NOT
37159: PUSH
37160: LD_VAR 0 10
37164: OR
37165: IFFALSE 37215
// begin if mc_taming [ i ] then
37167: LD_EXP 81
37171: PUSH
37172: LD_VAR 0 2
37176: ARRAY
37177: IFFALSE 37213
// begin MC_Reset ( i , 121 ) ;
37179: LD_VAR 0 2
37183: PPUSH
37184: LD_INT 121
37186: PPUSH
37187: CALL 22152 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37191: LD_ADDR_EXP 81
37195: PUSH
37196: LD_EXP 81
37200: PPUSH
37201: LD_VAR 0 2
37205: PPUSH
37206: EMPTY
37207: PPUSH
37208: CALL_OW 1
37212: ST_TO_ADDR
// end ; continue ;
37213: GO 36781
// end ; for j in tmp do
37215: LD_ADDR_VAR 0 3
37219: PUSH
37220: LD_VAR 0 8
37224: PUSH
37225: FOR_IN
37226: IFFALSE 37562
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37228: LD_VAR 0 3
37232: PUSH
37233: LD_EXP 81
37237: PUSH
37238: LD_VAR 0 2
37242: ARRAY
37243: IN
37244: NOT
37245: PUSH
37246: LD_EXP 81
37250: PUSH
37251: LD_VAR 0 2
37255: ARRAY
37256: PUSH
37257: LD_INT 3
37259: LESS
37260: AND
37261: IFFALSE 37319
// begin SetTag ( j , 121 ) ;
37263: LD_VAR 0 3
37267: PPUSH
37268: LD_INT 121
37270: PPUSH
37271: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37275: LD_ADDR_EXP 81
37279: PUSH
37280: LD_EXP 81
37284: PPUSH
37285: LD_VAR 0 2
37289: PUSH
37290: LD_EXP 81
37294: PUSH
37295: LD_VAR 0 2
37299: ARRAY
37300: PUSH
37301: LD_INT 1
37303: PLUS
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PPUSH
37309: LD_VAR 0 3
37313: PPUSH
37314: CALL 53792 0 3
37318: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37319: LD_VAR 0 3
37323: PUSH
37324: LD_EXP 81
37328: PUSH
37329: LD_VAR 0 2
37333: ARRAY
37334: IN
37335: IFFALSE 37560
// begin if GetClass ( j ) <> 4 then
37337: LD_VAR 0 3
37341: PPUSH
37342: CALL_OW 257
37346: PUSH
37347: LD_INT 4
37349: NONEQUAL
37350: IFFALSE 37403
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37352: LD_ADDR_EXP 81
37356: PUSH
37357: LD_EXP 81
37361: PPUSH
37362: LD_VAR 0 2
37366: PPUSH
37367: LD_EXP 81
37371: PUSH
37372: LD_VAR 0 2
37376: ARRAY
37377: PUSH
37378: LD_VAR 0 3
37382: DIFF
37383: PPUSH
37384: CALL_OW 1
37388: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37389: LD_VAR 0 3
37393: PPUSH
37394: LD_INT 0
37396: PPUSH
37397: CALL_OW 109
// continue ;
37401: GO 37225
// end ; if IsInUnit ( j ) then
37403: LD_VAR 0 3
37407: PPUSH
37408: CALL_OW 310
37412: IFFALSE 37423
// ComExitBuilding ( j ) ;
37414: LD_VAR 0 3
37418: PPUSH
37419: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37423: LD_ADDR_VAR 0 6
37427: PUSH
37428: LD_VAR 0 7
37432: PPUSH
37433: LD_VAR 0 3
37437: PPUSH
37438: CALL_OW 74
37442: ST_TO_ADDR
// if not ape then
37443: LD_VAR 0 6
37447: NOT
37448: IFFALSE 37452
// break ;
37450: GO 37562
// x := GetX ( ape ) ;
37452: LD_ADDR_VAR 0 4
37456: PUSH
37457: LD_VAR 0 6
37461: PPUSH
37462: CALL_OW 250
37466: ST_TO_ADDR
// y := GetY ( ape ) ;
37467: LD_ADDR_VAR 0 5
37471: PUSH
37472: LD_VAR 0 6
37476: PPUSH
37477: CALL_OW 251
37481: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37482: LD_VAR 0 4
37486: PPUSH
37487: LD_VAR 0 5
37491: PPUSH
37492: CALL_OW 488
37496: NOT
37497: PUSH
37498: LD_VAR 0 11
37502: PPUSH
37503: LD_VAR 0 4
37507: PPUSH
37508: LD_VAR 0 5
37512: PPUSH
37513: LD_INT 20
37515: PPUSH
37516: CALL 54688 0 4
37520: PUSH
37521: LD_INT 4
37523: ARRAY
37524: OR
37525: IFFALSE 37529
// break ;
37527: GO 37562
// if not HasTask ( j ) then
37529: LD_VAR 0 3
37533: PPUSH
37534: CALL_OW 314
37538: NOT
37539: IFFALSE 37560
// ComTameXY ( j , x , y ) ;
37541: LD_VAR 0 3
37545: PPUSH
37546: LD_VAR 0 4
37550: PPUSH
37551: LD_VAR 0 5
37555: PPUSH
37556: CALL_OW 131
// end ; end ;
37560: GO 37225
37562: POP
37563: POP
// end ;
37564: GO 36781
37566: POP
37567: POP
// end ;
37568: LD_VAR 0 1
37572: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37573: LD_INT 0
37575: PPUSH
37576: PPUSH
37577: PPUSH
37578: PPUSH
37579: PPUSH
37580: PPUSH
37581: PPUSH
37582: PPUSH
// if not mc_bases then
37583: LD_EXP 50
37587: NOT
37588: IFFALSE 37592
// exit ;
37590: GO 38218
// for i = 1 to mc_bases do
37592: LD_ADDR_VAR 0 2
37596: PUSH
37597: DOUBLE
37598: LD_INT 1
37600: DEC
37601: ST_TO_ADDR
37602: LD_EXP 50
37606: PUSH
37607: FOR_TO
37608: IFFALSE 38216
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37610: LD_EXP 79
37614: PUSH
37615: LD_VAR 0 2
37619: ARRAY
37620: NOT
37621: PUSH
37622: LD_EXP 79
37626: PUSH
37627: LD_VAR 0 2
37631: ARRAY
37632: PPUSH
37633: LD_INT 25
37635: PUSH
37636: LD_INT 12
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PPUSH
37643: CALL_OW 72
37647: NOT
37648: OR
37649: IFFALSE 37653
// continue ;
37651: GO 37607
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37653: LD_ADDR_VAR 0 5
37657: PUSH
37658: LD_EXP 79
37662: PUSH
37663: LD_VAR 0 2
37667: ARRAY
37668: PUSH
37669: LD_INT 1
37671: ARRAY
37672: PPUSH
37673: CALL_OW 255
37677: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37678: LD_VAR 0 5
37682: PPUSH
37683: LD_INT 2
37685: PPUSH
37686: CALL_OW 325
37690: IFFALSE 37943
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37692: LD_ADDR_VAR 0 4
37696: PUSH
37697: LD_EXP 79
37701: PUSH
37702: LD_VAR 0 2
37706: ARRAY
37707: PPUSH
37708: LD_INT 25
37710: PUSH
37711: LD_INT 16
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PPUSH
37718: CALL_OW 72
37722: ST_TO_ADDR
// if tmp < 6 then
37723: LD_VAR 0 4
37727: PUSH
37728: LD_INT 6
37730: LESS
37731: IFFALSE 37943
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37733: LD_ADDR_VAR 0 6
37737: PUSH
37738: LD_EXP 50
37742: PUSH
37743: LD_VAR 0 2
37747: ARRAY
37748: PPUSH
37749: LD_INT 2
37751: PUSH
37752: LD_INT 30
37754: PUSH
37755: LD_INT 0
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 30
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: LIST
37776: PPUSH
37777: CALL_OW 72
37781: ST_TO_ADDR
// if depot then
37782: LD_VAR 0 6
37786: IFFALSE 37943
// begin selected := 0 ;
37788: LD_ADDR_VAR 0 7
37792: PUSH
37793: LD_INT 0
37795: ST_TO_ADDR
// for j in depot do
37796: LD_ADDR_VAR 0 3
37800: PUSH
37801: LD_VAR 0 6
37805: PUSH
37806: FOR_IN
37807: IFFALSE 37838
// begin if UnitsInside ( j ) < 6 then
37809: LD_VAR 0 3
37813: PPUSH
37814: CALL_OW 313
37818: PUSH
37819: LD_INT 6
37821: LESS
37822: IFFALSE 37836
// begin selected := j ;
37824: LD_ADDR_VAR 0 7
37828: PUSH
37829: LD_VAR 0 3
37833: ST_TO_ADDR
// break ;
37834: GO 37838
// end ; end ;
37836: GO 37806
37838: POP
37839: POP
// if selected then
37840: LD_VAR 0 7
37844: IFFALSE 37943
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37846: LD_ADDR_VAR 0 3
37850: PUSH
37851: LD_EXP 79
37855: PUSH
37856: LD_VAR 0 2
37860: ARRAY
37861: PPUSH
37862: LD_INT 25
37864: PUSH
37865: LD_INT 12
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PPUSH
37872: CALL_OW 72
37876: PUSH
37877: FOR_IN
37878: IFFALSE 37941
// if not HasTask ( j ) then
37880: LD_VAR 0 3
37884: PPUSH
37885: CALL_OW 314
37889: NOT
37890: IFFALSE 37939
// begin if not IsInUnit ( j ) then
37892: LD_VAR 0 3
37896: PPUSH
37897: CALL_OW 310
37901: NOT
37902: IFFALSE 37918
// ComEnterUnit ( j , selected ) ;
37904: LD_VAR 0 3
37908: PPUSH
37909: LD_VAR 0 7
37913: PPUSH
37914: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37918: LD_VAR 0 3
37922: PPUSH
37923: LD_INT 16
37925: PPUSH
37926: CALL_OW 183
// AddComExitBuilding ( j ) ;
37930: LD_VAR 0 3
37934: PPUSH
37935: CALL_OW 182
// end ;
37939: GO 37877
37941: POP
37942: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37943: LD_VAR 0 5
37947: PPUSH
37948: LD_INT 11
37950: PPUSH
37951: CALL_OW 325
37955: IFFALSE 38214
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37957: LD_ADDR_VAR 0 4
37961: PUSH
37962: LD_EXP 79
37966: PUSH
37967: LD_VAR 0 2
37971: ARRAY
37972: PPUSH
37973: LD_INT 25
37975: PUSH
37976: LD_INT 16
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PPUSH
37983: CALL_OW 72
37987: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37988: LD_VAR 0 4
37992: PUSH
37993: LD_INT 6
37995: GREATEREQUAL
37996: PUSH
37997: LD_VAR 0 5
38001: PPUSH
38002: LD_INT 2
38004: PPUSH
38005: CALL_OW 325
38009: NOT
38010: OR
38011: IFFALSE 38214
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38013: LD_ADDR_VAR 0 8
38017: PUSH
38018: LD_EXP 50
38022: PUSH
38023: LD_VAR 0 2
38027: ARRAY
38028: PPUSH
38029: LD_INT 2
38031: PUSH
38032: LD_INT 30
38034: PUSH
38035: LD_INT 4
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: LD_INT 30
38044: PUSH
38045: LD_INT 5
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: LIST
38056: PPUSH
38057: CALL_OW 72
38061: ST_TO_ADDR
// if barracks then
38062: LD_VAR 0 8
38066: IFFALSE 38214
// begin selected := 0 ;
38068: LD_ADDR_VAR 0 7
38072: PUSH
38073: LD_INT 0
38075: ST_TO_ADDR
// for j in barracks do
38076: LD_ADDR_VAR 0 3
38080: PUSH
38081: LD_VAR 0 8
38085: PUSH
38086: FOR_IN
38087: IFFALSE 38118
// begin if UnitsInside ( j ) < 6 then
38089: LD_VAR 0 3
38093: PPUSH
38094: CALL_OW 313
38098: PUSH
38099: LD_INT 6
38101: LESS
38102: IFFALSE 38116
// begin selected := j ;
38104: LD_ADDR_VAR 0 7
38108: PUSH
38109: LD_VAR 0 3
38113: ST_TO_ADDR
// break ;
38114: GO 38118
// end ; end ;
38116: GO 38086
38118: POP
38119: POP
// if selected then
38120: LD_VAR 0 7
38124: IFFALSE 38214
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38126: LD_ADDR_VAR 0 3
38130: PUSH
38131: LD_EXP 79
38135: PUSH
38136: LD_VAR 0 2
38140: ARRAY
38141: PPUSH
38142: LD_INT 25
38144: PUSH
38145: LD_INT 12
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PPUSH
38152: CALL_OW 72
38156: PUSH
38157: FOR_IN
38158: IFFALSE 38212
// if not IsInUnit ( j ) and not HasTask ( j ) then
38160: LD_VAR 0 3
38164: PPUSH
38165: CALL_OW 310
38169: NOT
38170: PUSH
38171: LD_VAR 0 3
38175: PPUSH
38176: CALL_OW 314
38180: NOT
38181: AND
38182: IFFALSE 38210
// begin ComEnterUnit ( j , selected ) ;
38184: LD_VAR 0 3
38188: PPUSH
38189: LD_VAR 0 7
38193: PPUSH
38194: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38198: LD_VAR 0 3
38202: PPUSH
38203: LD_INT 15
38205: PPUSH
38206: CALL_OW 183
// end ;
38210: GO 38157
38212: POP
38213: POP
// end ; end ; end ; end ; end ;
38214: GO 37607
38216: POP
38217: POP
// end ;
38218: LD_VAR 0 1
38222: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38223: LD_INT 0
38225: PPUSH
38226: PPUSH
38227: PPUSH
38228: PPUSH
// if not mc_bases then
38229: LD_EXP 50
38233: NOT
38234: IFFALSE 38238
// exit ;
38236: GO 38416
// for i = 1 to mc_bases do
38238: LD_ADDR_VAR 0 2
38242: PUSH
38243: DOUBLE
38244: LD_INT 1
38246: DEC
38247: ST_TO_ADDR
38248: LD_EXP 50
38252: PUSH
38253: FOR_TO
38254: IFFALSE 38414
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38256: LD_ADDR_VAR 0 4
38260: PUSH
38261: LD_EXP 50
38265: PUSH
38266: LD_VAR 0 2
38270: ARRAY
38271: PPUSH
38272: LD_INT 25
38274: PUSH
38275: LD_INT 9
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PPUSH
38282: CALL_OW 72
38286: ST_TO_ADDR
// if not tmp then
38287: LD_VAR 0 4
38291: NOT
38292: IFFALSE 38296
// continue ;
38294: GO 38253
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38296: LD_EXP 76
38300: PUSH
38301: LD_VAR 0 2
38305: ARRAY
38306: PPUSH
38307: LD_INT 29
38309: PPUSH
38310: CALL_OW 325
38314: NOT
38315: PUSH
38316: LD_EXP 76
38320: PUSH
38321: LD_VAR 0 2
38325: ARRAY
38326: PPUSH
38327: LD_INT 28
38329: PPUSH
38330: CALL_OW 325
38334: NOT
38335: AND
38336: IFFALSE 38340
// continue ;
38338: GO 38253
// for j in tmp do
38340: LD_ADDR_VAR 0 3
38344: PUSH
38345: LD_VAR 0 4
38349: PUSH
38350: FOR_IN
38351: IFFALSE 38410
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38353: LD_VAR 0 3
38357: PUSH
38358: LD_EXP 53
38362: PUSH
38363: LD_VAR 0 2
38367: ARRAY
38368: PUSH
38369: LD_INT 1
38371: ARRAY
38372: IN
38373: NOT
38374: PUSH
38375: LD_VAR 0 3
38379: PUSH
38380: LD_EXP 53
38384: PUSH
38385: LD_VAR 0 2
38389: ARRAY
38390: PUSH
38391: LD_INT 2
38393: ARRAY
38394: IN
38395: NOT
38396: AND
38397: IFFALSE 38408
// ComSpaceTimeShoot ( j ) ;
38399: LD_VAR 0 3
38403: PPUSH
38404: CALL 49602 0 1
38408: GO 38350
38410: POP
38411: POP
// end ;
38412: GO 38253
38414: POP
38415: POP
// end ;
38416: LD_VAR 0 1
38420: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38421: LD_INT 0
38423: PPUSH
38424: PPUSH
38425: PPUSH
38426: PPUSH
38427: PPUSH
38428: PPUSH
38429: PPUSH
38430: PPUSH
38431: PPUSH
// if not mc_bases then
38432: LD_EXP 50
38436: NOT
38437: IFFALSE 38441
// exit ;
38439: GO 39063
// for i = 1 to mc_bases do
38441: LD_ADDR_VAR 0 2
38445: PUSH
38446: DOUBLE
38447: LD_INT 1
38449: DEC
38450: ST_TO_ADDR
38451: LD_EXP 50
38455: PUSH
38456: FOR_TO
38457: IFFALSE 39061
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38459: LD_EXP 85
38463: PUSH
38464: LD_VAR 0 2
38468: ARRAY
38469: NOT
38470: PUSH
38471: LD_INT 38
38473: PPUSH
38474: LD_EXP 76
38478: PUSH
38479: LD_VAR 0 2
38483: ARRAY
38484: PPUSH
38485: CALL_OW 321
38489: PUSH
38490: LD_INT 2
38492: NONEQUAL
38493: OR
38494: IFFALSE 38498
// continue ;
38496: GO 38456
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38498: LD_ADDR_VAR 0 8
38502: PUSH
38503: LD_EXP 50
38507: PUSH
38508: LD_VAR 0 2
38512: ARRAY
38513: PPUSH
38514: LD_INT 30
38516: PUSH
38517: LD_INT 34
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PPUSH
38524: CALL_OW 72
38528: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38529: LD_ADDR_VAR 0 9
38533: PUSH
38534: LD_EXP 50
38538: PUSH
38539: LD_VAR 0 2
38543: ARRAY
38544: PPUSH
38545: LD_INT 25
38547: PUSH
38548: LD_INT 4
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PPUSH
38555: CALL_OW 72
38559: PPUSH
38560: LD_INT 0
38562: PPUSH
38563: CALL 83678 0 2
38567: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38568: LD_VAR 0 9
38572: NOT
38573: PUSH
38574: LD_VAR 0 8
38578: NOT
38579: OR
38580: PUSH
38581: LD_EXP 50
38585: PUSH
38586: LD_VAR 0 2
38590: ARRAY
38591: PPUSH
38592: LD_INT 124
38594: PPUSH
38595: CALL 83678 0 2
38599: OR
38600: IFFALSE 38604
// continue ;
38602: GO 38456
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38604: LD_EXP 86
38608: PUSH
38609: LD_VAR 0 2
38613: ARRAY
38614: PUSH
38615: LD_EXP 85
38619: PUSH
38620: LD_VAR 0 2
38624: ARRAY
38625: LESS
38626: PUSH
38627: LD_EXP 86
38631: PUSH
38632: LD_VAR 0 2
38636: ARRAY
38637: PUSH
38638: LD_VAR 0 8
38642: LESS
38643: AND
38644: IFFALSE 39059
// begin tmp := sci [ 1 ] ;
38646: LD_ADDR_VAR 0 7
38650: PUSH
38651: LD_VAR 0 9
38655: PUSH
38656: LD_INT 1
38658: ARRAY
38659: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38660: LD_VAR 0 7
38664: PPUSH
38665: LD_INT 124
38667: PPUSH
38668: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38672: LD_ADDR_VAR 0 3
38676: PUSH
38677: DOUBLE
38678: LD_EXP 85
38682: PUSH
38683: LD_VAR 0 2
38687: ARRAY
38688: INC
38689: ST_TO_ADDR
38690: LD_EXP 85
38694: PUSH
38695: LD_VAR 0 2
38699: ARRAY
38700: PUSH
38701: FOR_DOWNTO
38702: IFFALSE 39045
// begin if IsInUnit ( tmp ) then
38704: LD_VAR 0 7
38708: PPUSH
38709: CALL_OW 310
38713: IFFALSE 38724
// ComExitBuilding ( tmp ) ;
38715: LD_VAR 0 7
38719: PPUSH
38720: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38724: LD_INT 35
38726: PPUSH
38727: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38731: LD_VAR 0 7
38735: PPUSH
38736: CALL_OW 310
38740: NOT
38741: PUSH
38742: LD_VAR 0 7
38746: PPUSH
38747: CALL_OW 314
38751: NOT
38752: AND
38753: IFFALSE 38724
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38755: LD_ADDR_VAR 0 6
38759: PUSH
38760: LD_VAR 0 7
38764: PPUSH
38765: CALL_OW 250
38769: PUSH
38770: LD_VAR 0 7
38774: PPUSH
38775: CALL_OW 251
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38784: LD_INT 35
38786: PPUSH
38787: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38791: LD_ADDR_VAR 0 4
38795: PUSH
38796: LD_EXP 85
38800: PUSH
38801: LD_VAR 0 2
38805: ARRAY
38806: PUSH
38807: LD_VAR 0 3
38811: ARRAY
38812: PUSH
38813: LD_INT 1
38815: ARRAY
38816: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38817: LD_ADDR_VAR 0 5
38821: PUSH
38822: LD_EXP 85
38826: PUSH
38827: LD_VAR 0 2
38831: ARRAY
38832: PUSH
38833: LD_VAR 0 3
38837: ARRAY
38838: PUSH
38839: LD_INT 2
38841: ARRAY
38842: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38843: LD_VAR 0 7
38847: PPUSH
38848: LD_INT 10
38850: PPUSH
38851: CALL 56389 0 2
38855: PUSH
38856: LD_INT 4
38858: ARRAY
38859: IFFALSE 38897
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38861: LD_VAR 0 7
38865: PPUSH
38866: LD_VAR 0 6
38870: PUSH
38871: LD_INT 1
38873: ARRAY
38874: PPUSH
38875: LD_VAR 0 6
38879: PUSH
38880: LD_INT 2
38882: ARRAY
38883: PPUSH
38884: CALL_OW 111
// wait ( 0 0$10 ) ;
38888: LD_INT 350
38890: PPUSH
38891: CALL_OW 67
// end else
38895: GO 38923
// begin ComMoveXY ( tmp , x , y ) ;
38897: LD_VAR 0 7
38901: PPUSH
38902: LD_VAR 0 4
38906: PPUSH
38907: LD_VAR 0 5
38911: PPUSH
38912: CALL_OW 111
// wait ( 0 0$3 ) ;
38916: LD_INT 105
38918: PPUSH
38919: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38923: LD_VAR 0 7
38927: PPUSH
38928: LD_VAR 0 4
38932: PPUSH
38933: LD_VAR 0 5
38937: PPUSH
38938: CALL_OW 307
38942: IFFALSE 38784
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38944: LD_VAR 0 7
38948: PPUSH
38949: LD_VAR 0 4
38953: PPUSH
38954: LD_VAR 0 5
38958: PPUSH
38959: LD_VAR 0 8
38963: PUSH
38964: LD_VAR 0 3
38968: ARRAY
38969: PPUSH
38970: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38974: LD_INT 35
38976: PPUSH
38977: CALL_OW 67
// until not HasTask ( tmp ) ;
38981: LD_VAR 0 7
38985: PPUSH
38986: CALL_OW 314
38990: NOT
38991: IFFALSE 38974
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38993: LD_ADDR_EXP 86
38997: PUSH
38998: LD_EXP 86
39002: PPUSH
39003: LD_VAR 0 2
39007: PUSH
39008: LD_EXP 86
39012: PUSH
39013: LD_VAR 0 2
39017: ARRAY
39018: PUSH
39019: LD_INT 1
39021: PLUS
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PPUSH
39027: LD_VAR 0 8
39031: PUSH
39032: LD_VAR 0 3
39036: ARRAY
39037: PPUSH
39038: CALL 53792 0 3
39042: ST_TO_ADDR
// end ;
39043: GO 38701
39045: POP
39046: POP
// MC_Reset ( i , 124 ) ;
39047: LD_VAR 0 2
39051: PPUSH
39052: LD_INT 124
39054: PPUSH
39055: CALL 22152 0 2
// end ; end ;
39059: GO 38456
39061: POP
39062: POP
// end ;
39063: LD_VAR 0 1
39067: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39068: LD_INT 0
39070: PPUSH
39071: PPUSH
39072: PPUSH
// if not mc_bases then
39073: LD_EXP 50
39077: NOT
39078: IFFALSE 39082
// exit ;
39080: GO 39688
// for i = 1 to mc_bases do
39082: LD_ADDR_VAR 0 2
39086: PUSH
39087: DOUBLE
39088: LD_INT 1
39090: DEC
39091: ST_TO_ADDR
39092: LD_EXP 50
39096: PUSH
39097: FOR_TO
39098: IFFALSE 39686
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39100: LD_ADDR_VAR 0 3
39104: PUSH
39105: LD_EXP 50
39109: PUSH
39110: LD_VAR 0 2
39114: ARRAY
39115: PPUSH
39116: LD_INT 25
39118: PUSH
39119: LD_INT 4
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: PPUSH
39126: CALL_OW 72
39130: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39131: LD_VAR 0 3
39135: NOT
39136: PUSH
39137: LD_EXP 87
39141: PUSH
39142: LD_VAR 0 2
39146: ARRAY
39147: NOT
39148: OR
39149: PUSH
39150: LD_EXP 50
39154: PUSH
39155: LD_VAR 0 2
39159: ARRAY
39160: PPUSH
39161: LD_INT 2
39163: PUSH
39164: LD_INT 30
39166: PUSH
39167: LD_INT 0
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 30
39176: PUSH
39177: LD_INT 1
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: LIST
39188: PPUSH
39189: CALL_OW 72
39193: NOT
39194: OR
39195: IFFALSE 39245
// begin if mc_deposits_finder [ i ] then
39197: LD_EXP 88
39201: PUSH
39202: LD_VAR 0 2
39206: ARRAY
39207: IFFALSE 39243
// begin MC_Reset ( i , 125 ) ;
39209: LD_VAR 0 2
39213: PPUSH
39214: LD_INT 125
39216: PPUSH
39217: CALL 22152 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39221: LD_ADDR_EXP 88
39225: PUSH
39226: LD_EXP 88
39230: PPUSH
39231: LD_VAR 0 2
39235: PPUSH
39236: EMPTY
39237: PPUSH
39238: CALL_OW 1
39242: ST_TO_ADDR
// end ; continue ;
39243: GO 39097
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39245: LD_EXP 87
39249: PUSH
39250: LD_VAR 0 2
39254: ARRAY
39255: PUSH
39256: LD_INT 1
39258: ARRAY
39259: PUSH
39260: LD_INT 3
39262: ARRAY
39263: PUSH
39264: LD_INT 1
39266: EQUAL
39267: PUSH
39268: LD_INT 20
39270: PPUSH
39271: LD_EXP 76
39275: PUSH
39276: LD_VAR 0 2
39280: ARRAY
39281: PPUSH
39282: CALL_OW 321
39286: PUSH
39287: LD_INT 2
39289: NONEQUAL
39290: AND
39291: IFFALSE 39341
// begin if mc_deposits_finder [ i ] then
39293: LD_EXP 88
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: IFFALSE 39339
// begin MC_Reset ( i , 125 ) ;
39305: LD_VAR 0 2
39309: PPUSH
39310: LD_INT 125
39312: PPUSH
39313: CALL 22152 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39317: LD_ADDR_EXP 88
39321: PUSH
39322: LD_EXP 88
39326: PPUSH
39327: LD_VAR 0 2
39331: PPUSH
39332: EMPTY
39333: PPUSH
39334: CALL_OW 1
39338: ST_TO_ADDR
// end ; continue ;
39339: GO 39097
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39341: LD_EXP 87
39345: PUSH
39346: LD_VAR 0 2
39350: ARRAY
39351: PUSH
39352: LD_INT 1
39354: ARRAY
39355: PUSH
39356: LD_INT 1
39358: ARRAY
39359: PPUSH
39360: LD_EXP 87
39364: PUSH
39365: LD_VAR 0 2
39369: ARRAY
39370: PUSH
39371: LD_INT 1
39373: ARRAY
39374: PUSH
39375: LD_INT 2
39377: ARRAY
39378: PPUSH
39379: LD_EXP 76
39383: PUSH
39384: LD_VAR 0 2
39388: ARRAY
39389: PPUSH
39390: CALL_OW 440
39394: IFFALSE 39437
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39396: LD_ADDR_EXP 87
39400: PUSH
39401: LD_EXP 87
39405: PPUSH
39406: LD_VAR 0 2
39410: PPUSH
39411: LD_EXP 87
39415: PUSH
39416: LD_VAR 0 2
39420: ARRAY
39421: PPUSH
39422: LD_INT 1
39424: PPUSH
39425: CALL_OW 3
39429: PPUSH
39430: CALL_OW 1
39434: ST_TO_ADDR
39435: GO 39684
// begin if not mc_deposits_finder [ i ] then
39437: LD_EXP 88
39441: PUSH
39442: LD_VAR 0 2
39446: ARRAY
39447: NOT
39448: IFFALSE 39500
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39450: LD_ADDR_EXP 88
39454: PUSH
39455: LD_EXP 88
39459: PPUSH
39460: LD_VAR 0 2
39464: PPUSH
39465: LD_VAR 0 3
39469: PUSH
39470: LD_INT 1
39472: ARRAY
39473: PUSH
39474: EMPTY
39475: LIST
39476: PPUSH
39477: CALL_OW 1
39481: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39482: LD_VAR 0 3
39486: PUSH
39487: LD_INT 1
39489: ARRAY
39490: PPUSH
39491: LD_INT 125
39493: PPUSH
39494: CALL_OW 109
// end else
39498: GO 39684
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39500: LD_EXP 88
39504: PUSH
39505: LD_VAR 0 2
39509: ARRAY
39510: PUSH
39511: LD_INT 1
39513: ARRAY
39514: PPUSH
39515: CALL_OW 310
39519: IFFALSE 39542
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39521: LD_EXP 88
39525: PUSH
39526: LD_VAR 0 2
39530: ARRAY
39531: PUSH
39532: LD_INT 1
39534: ARRAY
39535: PPUSH
39536: CALL_OW 122
39540: GO 39684
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39542: LD_EXP 88
39546: PUSH
39547: LD_VAR 0 2
39551: ARRAY
39552: PUSH
39553: LD_INT 1
39555: ARRAY
39556: PPUSH
39557: CALL_OW 314
39561: NOT
39562: PUSH
39563: LD_EXP 88
39567: PUSH
39568: LD_VAR 0 2
39572: ARRAY
39573: PUSH
39574: LD_INT 1
39576: ARRAY
39577: PPUSH
39578: LD_EXP 87
39582: PUSH
39583: LD_VAR 0 2
39587: ARRAY
39588: PUSH
39589: LD_INT 1
39591: ARRAY
39592: PUSH
39593: LD_INT 1
39595: ARRAY
39596: PPUSH
39597: LD_EXP 87
39601: PUSH
39602: LD_VAR 0 2
39606: ARRAY
39607: PUSH
39608: LD_INT 1
39610: ARRAY
39611: PUSH
39612: LD_INT 2
39614: ARRAY
39615: PPUSH
39616: CALL_OW 297
39620: PUSH
39621: LD_INT 6
39623: GREATER
39624: AND
39625: IFFALSE 39684
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39627: LD_EXP 88
39631: PUSH
39632: LD_VAR 0 2
39636: ARRAY
39637: PUSH
39638: LD_INT 1
39640: ARRAY
39641: PPUSH
39642: LD_EXP 87
39646: PUSH
39647: LD_VAR 0 2
39651: ARRAY
39652: PUSH
39653: LD_INT 1
39655: ARRAY
39656: PUSH
39657: LD_INT 1
39659: ARRAY
39660: PPUSH
39661: LD_EXP 87
39665: PUSH
39666: LD_VAR 0 2
39670: ARRAY
39671: PUSH
39672: LD_INT 1
39674: ARRAY
39675: PUSH
39676: LD_INT 2
39678: ARRAY
39679: PPUSH
39680: CALL_OW 111
// end ; end ; end ;
39684: GO 39097
39686: POP
39687: POP
// end ;
39688: LD_VAR 0 1
39692: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39693: LD_INT 0
39695: PPUSH
39696: PPUSH
39697: PPUSH
39698: PPUSH
39699: PPUSH
39700: PPUSH
39701: PPUSH
39702: PPUSH
39703: PPUSH
39704: PPUSH
39705: PPUSH
// if not mc_bases then
39706: LD_EXP 50
39710: NOT
39711: IFFALSE 39715
// exit ;
39713: GO 40655
// for i = 1 to mc_bases do
39715: LD_ADDR_VAR 0 2
39719: PUSH
39720: DOUBLE
39721: LD_INT 1
39723: DEC
39724: ST_TO_ADDR
39725: LD_EXP 50
39729: PUSH
39730: FOR_TO
39731: IFFALSE 40653
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39733: LD_EXP 50
39737: PUSH
39738: LD_VAR 0 2
39742: ARRAY
39743: NOT
39744: PUSH
39745: LD_EXP 73
39749: PUSH
39750: LD_VAR 0 2
39754: ARRAY
39755: OR
39756: IFFALSE 39760
// continue ;
39758: GO 39730
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39760: LD_ADDR_VAR 0 7
39764: PUSH
39765: LD_EXP 50
39769: PUSH
39770: LD_VAR 0 2
39774: ARRAY
39775: PUSH
39776: LD_INT 1
39778: ARRAY
39779: PPUSH
39780: CALL_OW 248
39784: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39785: LD_VAR 0 7
39789: PUSH
39790: LD_INT 3
39792: EQUAL
39793: PUSH
39794: LD_EXP 69
39798: PUSH
39799: LD_VAR 0 2
39803: ARRAY
39804: PUSH
39805: LD_EXP 72
39809: PUSH
39810: LD_VAR 0 2
39814: ARRAY
39815: UNION
39816: PPUSH
39817: LD_INT 33
39819: PUSH
39820: LD_INT 2
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PPUSH
39827: CALL_OW 72
39831: NOT
39832: OR
39833: IFFALSE 39837
// continue ;
39835: GO 39730
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39837: LD_ADDR_VAR 0 9
39841: PUSH
39842: LD_EXP 50
39846: PUSH
39847: LD_VAR 0 2
39851: ARRAY
39852: PPUSH
39853: LD_INT 30
39855: PUSH
39856: LD_INT 36
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PPUSH
39863: CALL_OW 72
39867: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39868: LD_ADDR_VAR 0 10
39872: PUSH
39873: LD_EXP 69
39877: PUSH
39878: LD_VAR 0 2
39882: ARRAY
39883: PPUSH
39884: LD_INT 34
39886: PUSH
39887: LD_INT 31
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PPUSH
39894: CALL_OW 72
39898: ST_TO_ADDR
// if not cts and not mcts then
39899: LD_VAR 0 9
39903: NOT
39904: PUSH
39905: LD_VAR 0 10
39909: NOT
39910: AND
39911: IFFALSE 39915
// continue ;
39913: GO 39730
// x := cts ;
39915: LD_ADDR_VAR 0 11
39919: PUSH
39920: LD_VAR 0 9
39924: ST_TO_ADDR
// if not x then
39925: LD_VAR 0 11
39929: NOT
39930: IFFALSE 39942
// x := mcts ;
39932: LD_ADDR_VAR 0 11
39936: PUSH
39937: LD_VAR 0 10
39941: ST_TO_ADDR
// if not x then
39942: LD_VAR 0 11
39946: NOT
39947: IFFALSE 39951
// continue ;
39949: GO 39730
// if mc_remote_driver [ i ] then
39951: LD_EXP 90
39955: PUSH
39956: LD_VAR 0 2
39960: ARRAY
39961: IFFALSE 40348
// for j in mc_remote_driver [ i ] do
39963: LD_ADDR_VAR 0 3
39967: PUSH
39968: LD_EXP 90
39972: PUSH
39973: LD_VAR 0 2
39977: ARRAY
39978: PUSH
39979: FOR_IN
39980: IFFALSE 40346
// begin if GetClass ( j ) <> 3 then
39982: LD_VAR 0 3
39986: PPUSH
39987: CALL_OW 257
39991: PUSH
39992: LD_INT 3
39994: NONEQUAL
39995: IFFALSE 40048
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39997: LD_ADDR_EXP 90
40001: PUSH
40002: LD_EXP 90
40006: PPUSH
40007: LD_VAR 0 2
40011: PPUSH
40012: LD_EXP 90
40016: PUSH
40017: LD_VAR 0 2
40021: ARRAY
40022: PUSH
40023: LD_VAR 0 3
40027: DIFF
40028: PPUSH
40029: CALL_OW 1
40033: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40034: LD_VAR 0 3
40038: PPUSH
40039: LD_INT 0
40041: PPUSH
40042: CALL_OW 109
// continue ;
40046: GO 39979
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40048: LD_EXP 69
40052: PUSH
40053: LD_VAR 0 2
40057: ARRAY
40058: PPUSH
40059: LD_INT 34
40061: PUSH
40062: LD_INT 31
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 58
40071: PUSH
40072: EMPTY
40073: LIST
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PPUSH
40079: CALL_OW 72
40083: PUSH
40084: LD_VAR 0 3
40088: PPUSH
40089: CALL 83713 0 1
40093: NOT
40094: AND
40095: IFFALSE 40166
// begin if IsInUnit ( j ) then
40097: LD_VAR 0 3
40101: PPUSH
40102: CALL_OW 310
40106: IFFALSE 40117
// ComExitBuilding ( j ) ;
40108: LD_VAR 0 3
40112: PPUSH
40113: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40117: LD_VAR 0 3
40121: PPUSH
40122: LD_EXP 69
40126: PUSH
40127: LD_VAR 0 2
40131: ARRAY
40132: PPUSH
40133: LD_INT 34
40135: PUSH
40136: LD_INT 31
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 58
40145: PUSH
40146: EMPTY
40147: LIST
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PPUSH
40153: CALL_OW 72
40157: PUSH
40158: LD_INT 1
40160: ARRAY
40161: PPUSH
40162: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40166: LD_VAR 0 3
40170: PPUSH
40171: CALL_OW 310
40175: NOT
40176: PUSH
40177: LD_VAR 0 3
40181: PPUSH
40182: CALL_OW 310
40186: PPUSH
40187: CALL_OW 266
40191: PUSH
40192: LD_INT 36
40194: NONEQUAL
40195: PUSH
40196: LD_VAR 0 3
40200: PPUSH
40201: CALL 83713 0 1
40205: NOT
40206: AND
40207: OR
40208: IFFALSE 40344
// begin if IsInUnit ( j ) then
40210: LD_VAR 0 3
40214: PPUSH
40215: CALL_OW 310
40219: IFFALSE 40230
// ComExitBuilding ( j ) ;
40221: LD_VAR 0 3
40225: PPUSH
40226: CALL_OW 122
// ct := 0 ;
40230: LD_ADDR_VAR 0 8
40234: PUSH
40235: LD_INT 0
40237: ST_TO_ADDR
// for k in x do
40238: LD_ADDR_VAR 0 4
40242: PUSH
40243: LD_VAR 0 11
40247: PUSH
40248: FOR_IN
40249: IFFALSE 40322
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40251: LD_VAR 0 4
40255: PPUSH
40256: CALL_OW 264
40260: PUSH
40261: LD_INT 31
40263: EQUAL
40264: PUSH
40265: LD_VAR 0 4
40269: PPUSH
40270: CALL_OW 311
40274: NOT
40275: AND
40276: PUSH
40277: LD_VAR 0 4
40281: PPUSH
40282: CALL_OW 266
40286: PUSH
40287: LD_INT 36
40289: EQUAL
40290: PUSH
40291: LD_VAR 0 4
40295: PPUSH
40296: CALL_OW 313
40300: PUSH
40301: LD_INT 3
40303: LESS
40304: AND
40305: OR
40306: IFFALSE 40320
// begin ct := k ;
40308: LD_ADDR_VAR 0 8
40312: PUSH
40313: LD_VAR 0 4
40317: ST_TO_ADDR
// break ;
40318: GO 40322
// end ;
40320: GO 40248
40322: POP
40323: POP
// if ct then
40324: LD_VAR 0 8
40328: IFFALSE 40344
// ComEnterUnit ( j , ct ) ;
40330: LD_VAR 0 3
40334: PPUSH
40335: LD_VAR 0 8
40339: PPUSH
40340: CALL_OW 120
// end ; end ;
40344: GO 39979
40346: POP
40347: POP
// places := 0 ;
40348: LD_ADDR_VAR 0 5
40352: PUSH
40353: LD_INT 0
40355: ST_TO_ADDR
// for j = 1 to x do
40356: LD_ADDR_VAR 0 3
40360: PUSH
40361: DOUBLE
40362: LD_INT 1
40364: DEC
40365: ST_TO_ADDR
40366: LD_VAR 0 11
40370: PUSH
40371: FOR_TO
40372: IFFALSE 40448
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40374: LD_VAR 0 11
40378: PUSH
40379: LD_VAR 0 3
40383: ARRAY
40384: PPUSH
40385: CALL_OW 264
40389: PUSH
40390: LD_INT 31
40392: EQUAL
40393: IFFALSE 40411
// places := places + 1 else
40395: LD_ADDR_VAR 0 5
40399: PUSH
40400: LD_VAR 0 5
40404: PUSH
40405: LD_INT 1
40407: PLUS
40408: ST_TO_ADDR
40409: GO 40446
// if GetBType ( x [ j ] ) = b_control_tower then
40411: LD_VAR 0 11
40415: PUSH
40416: LD_VAR 0 3
40420: ARRAY
40421: PPUSH
40422: CALL_OW 266
40426: PUSH
40427: LD_INT 36
40429: EQUAL
40430: IFFALSE 40446
// places := places + 3 ;
40432: LD_ADDR_VAR 0 5
40436: PUSH
40437: LD_VAR 0 5
40441: PUSH
40442: LD_INT 3
40444: PLUS
40445: ST_TO_ADDR
40446: GO 40371
40448: POP
40449: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40450: LD_VAR 0 5
40454: PUSH
40455: LD_INT 0
40457: EQUAL
40458: PUSH
40459: LD_VAR 0 5
40463: PUSH
40464: LD_EXP 90
40468: PUSH
40469: LD_VAR 0 2
40473: ARRAY
40474: LESSEQUAL
40475: OR
40476: IFFALSE 40480
// continue ;
40478: GO 39730
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40480: LD_ADDR_VAR 0 6
40484: PUSH
40485: LD_EXP 50
40489: PUSH
40490: LD_VAR 0 2
40494: ARRAY
40495: PPUSH
40496: LD_INT 25
40498: PUSH
40499: LD_INT 3
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PPUSH
40506: CALL_OW 72
40510: PUSH
40511: LD_EXP 90
40515: PUSH
40516: LD_VAR 0 2
40520: ARRAY
40521: DIFF
40522: PPUSH
40523: LD_INT 3
40525: PPUSH
40526: CALL 84613 0 2
40530: ST_TO_ADDR
// for j in tmp do
40531: LD_ADDR_VAR 0 3
40535: PUSH
40536: LD_VAR 0 6
40540: PUSH
40541: FOR_IN
40542: IFFALSE 40577
// if GetTag ( j ) > 0 then
40544: LD_VAR 0 3
40548: PPUSH
40549: CALL_OW 110
40553: PUSH
40554: LD_INT 0
40556: GREATER
40557: IFFALSE 40575
// tmp := tmp diff j ;
40559: LD_ADDR_VAR 0 6
40563: PUSH
40564: LD_VAR 0 6
40568: PUSH
40569: LD_VAR 0 3
40573: DIFF
40574: ST_TO_ADDR
40575: GO 40541
40577: POP
40578: POP
// if not tmp then
40579: LD_VAR 0 6
40583: NOT
40584: IFFALSE 40588
// continue ;
40586: GO 39730
// if places then
40588: LD_VAR 0 5
40592: IFFALSE 40651
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40594: LD_ADDR_EXP 90
40598: PUSH
40599: LD_EXP 90
40603: PPUSH
40604: LD_VAR 0 2
40608: PPUSH
40609: LD_EXP 90
40613: PUSH
40614: LD_VAR 0 2
40618: ARRAY
40619: PUSH
40620: LD_VAR 0 6
40624: PUSH
40625: LD_INT 1
40627: ARRAY
40628: UNION
40629: PPUSH
40630: CALL_OW 1
40634: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40635: LD_VAR 0 6
40639: PUSH
40640: LD_INT 1
40642: ARRAY
40643: PPUSH
40644: LD_INT 126
40646: PPUSH
40647: CALL_OW 109
// end ; end ;
40651: GO 39730
40653: POP
40654: POP
// end ;
40655: LD_VAR 0 1
40659: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40660: LD_INT 0
40662: PPUSH
40663: PPUSH
40664: PPUSH
40665: PPUSH
40666: PPUSH
40667: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40668: LD_VAR 0 1
40672: NOT
40673: PUSH
40674: LD_VAR 0 2
40678: NOT
40679: OR
40680: PUSH
40681: LD_VAR 0 3
40685: NOT
40686: OR
40687: PUSH
40688: LD_VAR 0 4
40692: PUSH
40693: LD_INT 1
40695: PUSH
40696: LD_INT 2
40698: PUSH
40699: LD_INT 3
40701: PUSH
40702: LD_INT 4
40704: PUSH
40705: LD_INT 5
40707: PUSH
40708: LD_INT 8
40710: PUSH
40711: LD_INT 9
40713: PUSH
40714: LD_INT 15
40716: PUSH
40717: LD_INT 16
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: LIST
40728: LIST
40729: LIST
40730: IN
40731: NOT
40732: OR
40733: IFFALSE 40737
// exit ;
40735: GO 41637
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40737: LD_ADDR_VAR 0 2
40741: PUSH
40742: LD_VAR 0 2
40746: PPUSH
40747: LD_INT 21
40749: PUSH
40750: LD_INT 3
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 24
40759: PUSH
40760: LD_INT 250
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PPUSH
40771: CALL_OW 72
40775: ST_TO_ADDR
// case class of 1 , 15 :
40776: LD_VAR 0 4
40780: PUSH
40781: LD_INT 1
40783: DOUBLE
40784: EQUAL
40785: IFTRUE 40795
40787: LD_INT 15
40789: DOUBLE
40790: EQUAL
40791: IFTRUE 40795
40793: GO 40880
40795: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40796: LD_ADDR_VAR 0 8
40800: PUSH
40801: LD_VAR 0 2
40805: PPUSH
40806: LD_INT 2
40808: PUSH
40809: LD_INT 30
40811: PUSH
40812: LD_INT 32
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 30
40821: PUSH
40822: LD_INT 31
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: LIST
40833: PPUSH
40834: CALL_OW 72
40838: PUSH
40839: LD_VAR 0 2
40843: PPUSH
40844: LD_INT 2
40846: PUSH
40847: LD_INT 30
40849: PUSH
40850: LD_INT 4
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 30
40859: PUSH
40860: LD_INT 5
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: LIST
40871: PPUSH
40872: CALL_OW 72
40876: ADD
40877: ST_TO_ADDR
40878: GO 41126
40880: LD_INT 2
40882: DOUBLE
40883: EQUAL
40884: IFTRUE 40894
40886: LD_INT 16
40888: DOUBLE
40889: EQUAL
40890: IFTRUE 40894
40892: GO 40940
40894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40895: LD_ADDR_VAR 0 8
40899: PUSH
40900: LD_VAR 0 2
40904: PPUSH
40905: LD_INT 2
40907: PUSH
40908: LD_INT 30
40910: PUSH
40911: LD_INT 0
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 30
40920: PUSH
40921: LD_INT 1
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: LIST
40932: PPUSH
40933: CALL_OW 72
40937: ST_TO_ADDR
40938: GO 41126
40940: LD_INT 3
40942: DOUBLE
40943: EQUAL
40944: IFTRUE 40948
40946: GO 40994
40948: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40949: LD_ADDR_VAR 0 8
40953: PUSH
40954: LD_VAR 0 2
40958: PPUSH
40959: LD_INT 2
40961: PUSH
40962: LD_INT 30
40964: PUSH
40965: LD_INT 2
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 30
40974: PUSH
40975: LD_INT 3
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: LIST
40986: PPUSH
40987: CALL_OW 72
40991: ST_TO_ADDR
40992: GO 41126
40994: LD_INT 4
40996: DOUBLE
40997: EQUAL
40998: IFTRUE 41002
41000: GO 41059
41002: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41003: LD_ADDR_VAR 0 8
41007: PUSH
41008: LD_VAR 0 2
41012: PPUSH
41013: LD_INT 2
41015: PUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 6
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 30
41028: PUSH
41029: LD_INT 7
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 30
41038: PUSH
41039: LD_INT 8
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: PPUSH
41052: CALL_OW 72
41056: ST_TO_ADDR
41057: GO 41126
41059: LD_INT 5
41061: DOUBLE
41062: EQUAL
41063: IFTRUE 41079
41065: LD_INT 8
41067: DOUBLE
41068: EQUAL
41069: IFTRUE 41079
41071: LD_INT 9
41073: DOUBLE
41074: EQUAL
41075: IFTRUE 41079
41077: GO 41125
41079: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41080: LD_ADDR_VAR 0 8
41084: PUSH
41085: LD_VAR 0 2
41089: PPUSH
41090: LD_INT 2
41092: PUSH
41093: LD_INT 30
41095: PUSH
41096: LD_INT 4
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 30
41105: PUSH
41106: LD_INT 5
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: LIST
41117: PPUSH
41118: CALL_OW 72
41122: ST_TO_ADDR
41123: GO 41126
41125: POP
// if not tmp then
41126: LD_VAR 0 8
41130: NOT
41131: IFFALSE 41135
// exit ;
41133: GO 41637
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41135: LD_VAR 0 4
41139: PUSH
41140: LD_INT 1
41142: PUSH
41143: LD_INT 15
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: IN
41150: PUSH
41151: LD_EXP 59
41155: PUSH
41156: LD_VAR 0 1
41160: ARRAY
41161: AND
41162: IFFALSE 41318
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41164: LD_ADDR_VAR 0 9
41168: PUSH
41169: LD_EXP 59
41173: PUSH
41174: LD_VAR 0 1
41178: ARRAY
41179: PUSH
41180: LD_INT 1
41182: ARRAY
41183: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41184: LD_VAR 0 9
41188: PUSH
41189: LD_EXP 60
41193: PUSH
41194: LD_VAR 0 1
41198: ARRAY
41199: IN
41200: NOT
41201: IFFALSE 41316
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41203: LD_ADDR_EXP 60
41207: PUSH
41208: LD_EXP 60
41212: PPUSH
41213: LD_VAR 0 1
41217: PUSH
41218: LD_EXP 60
41222: PUSH
41223: LD_VAR 0 1
41227: ARRAY
41228: PUSH
41229: LD_INT 1
41231: PLUS
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PPUSH
41237: LD_VAR 0 9
41241: PPUSH
41242: CALL 53792 0 3
41246: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41247: LD_ADDR_EXP 59
41251: PUSH
41252: LD_EXP 59
41256: PPUSH
41257: LD_VAR 0 1
41261: PPUSH
41262: LD_EXP 59
41266: PUSH
41267: LD_VAR 0 1
41271: ARRAY
41272: PUSH
41273: LD_VAR 0 9
41277: DIFF
41278: PPUSH
41279: CALL_OW 1
41283: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41284: LD_VAR 0 3
41288: PPUSH
41289: LD_EXP 60
41293: PUSH
41294: LD_VAR 0 1
41298: ARRAY
41299: PUSH
41300: LD_EXP 60
41304: PUSH
41305: LD_VAR 0 1
41309: ARRAY
41310: ARRAY
41311: PPUSH
41312: CALL_OW 120
// end ; exit ;
41316: GO 41637
// end ; if tmp > 1 then
41318: LD_VAR 0 8
41322: PUSH
41323: LD_INT 1
41325: GREATER
41326: IFFALSE 41430
// for i = 2 to tmp do
41328: LD_ADDR_VAR 0 6
41332: PUSH
41333: DOUBLE
41334: LD_INT 2
41336: DEC
41337: ST_TO_ADDR
41338: LD_VAR 0 8
41342: PUSH
41343: FOR_TO
41344: IFFALSE 41428
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41346: LD_VAR 0 8
41350: PUSH
41351: LD_VAR 0 6
41355: ARRAY
41356: PPUSH
41357: CALL_OW 461
41361: PUSH
41362: LD_INT 6
41364: EQUAL
41365: IFFALSE 41426
// begin x := tmp [ i ] ;
41367: LD_ADDR_VAR 0 9
41371: PUSH
41372: LD_VAR 0 8
41376: PUSH
41377: LD_VAR 0 6
41381: ARRAY
41382: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41383: LD_ADDR_VAR 0 8
41387: PUSH
41388: LD_VAR 0 8
41392: PPUSH
41393: LD_VAR 0 6
41397: PPUSH
41398: CALL_OW 3
41402: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41403: LD_ADDR_VAR 0 8
41407: PUSH
41408: LD_VAR 0 8
41412: PPUSH
41413: LD_INT 1
41415: PPUSH
41416: LD_VAR 0 9
41420: PPUSH
41421: CALL_OW 2
41425: ST_TO_ADDR
// end ;
41426: GO 41343
41428: POP
41429: POP
// for i in tmp do
41430: LD_ADDR_VAR 0 6
41434: PUSH
41435: LD_VAR 0 8
41439: PUSH
41440: FOR_IN
41441: IFFALSE 41510
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41443: LD_VAR 0 6
41447: PPUSH
41448: CALL_OW 313
41452: PUSH
41453: LD_INT 6
41455: LESS
41456: PUSH
41457: LD_VAR 0 6
41461: PPUSH
41462: CALL_OW 266
41466: PUSH
41467: LD_INT 31
41469: PUSH
41470: LD_INT 32
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: IN
41477: NOT
41478: AND
41479: PUSH
41480: LD_VAR 0 6
41484: PPUSH
41485: CALL_OW 313
41489: PUSH
41490: LD_INT 0
41492: EQUAL
41493: OR
41494: IFFALSE 41508
// begin j := i ;
41496: LD_ADDR_VAR 0 7
41500: PUSH
41501: LD_VAR 0 6
41505: ST_TO_ADDR
// break ;
41506: GO 41510
// end ; end ;
41508: GO 41440
41510: POP
41511: POP
// if j then
41512: LD_VAR 0 7
41516: IFFALSE 41534
// ComEnterUnit ( unit , j ) else
41518: LD_VAR 0 3
41522: PPUSH
41523: LD_VAR 0 7
41527: PPUSH
41528: CALL_OW 120
41532: GO 41637
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41534: LD_ADDR_VAR 0 10
41538: PUSH
41539: LD_VAR 0 2
41543: PPUSH
41544: LD_INT 2
41546: PUSH
41547: LD_INT 30
41549: PUSH
41550: LD_INT 0
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 30
41559: PUSH
41560: LD_INT 1
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: LIST
41571: PPUSH
41572: CALL_OW 72
41576: ST_TO_ADDR
// if depot then
41577: LD_VAR 0 10
41581: IFFALSE 41637
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41583: LD_ADDR_VAR 0 10
41587: PUSH
41588: LD_VAR 0 10
41592: PPUSH
41593: LD_VAR 0 3
41597: PPUSH
41598: CALL_OW 74
41602: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41603: LD_VAR 0 3
41607: PPUSH
41608: LD_VAR 0 10
41612: PPUSH
41613: CALL_OW 296
41617: PUSH
41618: LD_INT 10
41620: GREATER
41621: IFFALSE 41637
// ComStandNearbyBuilding ( unit , depot ) ;
41623: LD_VAR 0 3
41627: PPUSH
41628: LD_VAR 0 10
41632: PPUSH
41633: CALL 50219 0 2
// end ; end ; end ;
41637: LD_VAR 0 5
41641: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41642: LD_INT 0
41644: PPUSH
41645: PPUSH
41646: PPUSH
41647: PPUSH
// if not mc_bases then
41648: LD_EXP 50
41652: NOT
41653: IFFALSE 41657
// exit ;
41655: GO 41896
// for i = 1 to mc_bases do
41657: LD_ADDR_VAR 0 2
41661: PUSH
41662: DOUBLE
41663: LD_INT 1
41665: DEC
41666: ST_TO_ADDR
41667: LD_EXP 50
41671: PUSH
41672: FOR_TO
41673: IFFALSE 41894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41675: LD_ADDR_VAR 0 4
41679: PUSH
41680: LD_EXP 50
41684: PUSH
41685: LD_VAR 0 2
41689: ARRAY
41690: PPUSH
41691: LD_INT 21
41693: PUSH
41694: LD_INT 1
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PPUSH
41701: CALL_OW 72
41705: PUSH
41706: LD_EXP 79
41710: PUSH
41711: LD_VAR 0 2
41715: ARRAY
41716: UNION
41717: ST_TO_ADDR
// if not tmp then
41718: LD_VAR 0 4
41722: NOT
41723: IFFALSE 41727
// continue ;
41725: GO 41672
// for j in tmp do
41727: LD_ADDR_VAR 0 3
41731: PUSH
41732: LD_VAR 0 4
41736: PUSH
41737: FOR_IN
41738: IFFALSE 41890
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41740: LD_VAR 0 3
41744: PPUSH
41745: CALL_OW 110
41749: NOT
41750: PUSH
41751: LD_VAR 0 3
41755: PPUSH
41756: CALL_OW 314
41760: NOT
41761: AND
41762: PUSH
41763: LD_VAR 0 3
41767: PPUSH
41768: CALL_OW 311
41772: NOT
41773: AND
41774: PUSH
41775: LD_VAR 0 3
41779: PPUSH
41780: CALL_OW 310
41784: NOT
41785: AND
41786: PUSH
41787: LD_VAR 0 3
41791: PUSH
41792: LD_EXP 53
41796: PUSH
41797: LD_VAR 0 2
41801: ARRAY
41802: PUSH
41803: LD_INT 1
41805: ARRAY
41806: IN
41807: NOT
41808: AND
41809: PUSH
41810: LD_VAR 0 3
41814: PUSH
41815: LD_EXP 53
41819: PUSH
41820: LD_VAR 0 2
41824: ARRAY
41825: PUSH
41826: LD_INT 2
41828: ARRAY
41829: IN
41830: NOT
41831: AND
41832: PUSH
41833: LD_VAR 0 3
41837: PUSH
41838: LD_EXP 62
41842: PUSH
41843: LD_VAR 0 2
41847: ARRAY
41848: IN
41849: NOT
41850: AND
41851: IFFALSE 41888
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41853: LD_VAR 0 2
41857: PPUSH
41858: LD_EXP 50
41862: PUSH
41863: LD_VAR 0 2
41867: ARRAY
41868: PPUSH
41869: LD_VAR 0 3
41873: PPUSH
41874: LD_VAR 0 3
41878: PPUSH
41879: CALL_OW 257
41883: PPUSH
41884: CALL 40660 0 4
// end ;
41888: GO 41737
41890: POP
41891: POP
// end ;
41892: GO 41672
41894: POP
41895: POP
// end ;
41896: LD_VAR 0 1
41900: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41901: LD_INT 0
41903: PPUSH
41904: PPUSH
41905: PPUSH
41906: PPUSH
41907: PPUSH
41908: PPUSH
// if not mc_bases [ base ] then
41909: LD_EXP 50
41913: PUSH
41914: LD_VAR 0 1
41918: ARRAY
41919: NOT
41920: IFFALSE 41924
// exit ;
41922: GO 42106
// tmp := [ ] ;
41924: LD_ADDR_VAR 0 6
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41931: LD_ADDR_VAR 0 7
41935: PUSH
41936: LD_VAR 0 3
41940: PPUSH
41941: LD_INT 0
41943: PPUSH
41944: CALL_OW 517
41948: ST_TO_ADDR
// if not list then
41949: LD_VAR 0 7
41953: NOT
41954: IFFALSE 41958
// exit ;
41956: GO 42106
// for i = 1 to amount do
41958: LD_ADDR_VAR 0 5
41962: PUSH
41963: DOUBLE
41964: LD_INT 1
41966: DEC
41967: ST_TO_ADDR
41968: LD_VAR 0 2
41972: PUSH
41973: FOR_TO
41974: IFFALSE 42054
// begin x := rand ( 1 , list [ 1 ] ) ;
41976: LD_ADDR_VAR 0 8
41980: PUSH
41981: LD_INT 1
41983: PPUSH
41984: LD_VAR 0 7
41988: PUSH
41989: LD_INT 1
41991: ARRAY
41992: PPUSH
41993: CALL_OW 12
41997: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41998: LD_ADDR_VAR 0 6
42002: PUSH
42003: LD_VAR 0 6
42007: PPUSH
42008: LD_VAR 0 5
42012: PPUSH
42013: LD_VAR 0 7
42017: PUSH
42018: LD_INT 1
42020: ARRAY
42021: PUSH
42022: LD_VAR 0 8
42026: ARRAY
42027: PUSH
42028: LD_VAR 0 7
42032: PUSH
42033: LD_INT 2
42035: ARRAY
42036: PUSH
42037: LD_VAR 0 8
42041: ARRAY
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PPUSH
42047: CALL_OW 1
42051: ST_TO_ADDR
// end ;
42052: GO 41973
42054: POP
42055: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42056: LD_ADDR_EXP 63
42060: PUSH
42061: LD_EXP 63
42065: PPUSH
42066: LD_VAR 0 1
42070: PPUSH
42071: LD_VAR 0 6
42075: PPUSH
42076: CALL_OW 1
42080: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42081: LD_ADDR_EXP 65
42085: PUSH
42086: LD_EXP 65
42090: PPUSH
42091: LD_VAR 0 1
42095: PPUSH
42096: LD_VAR 0 3
42100: PPUSH
42101: CALL_OW 1
42105: ST_TO_ADDR
// end ;
42106: LD_VAR 0 4
42110: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42111: LD_INT 0
42113: PPUSH
// if not mc_bases [ base ] then
42114: LD_EXP 50
42118: PUSH
42119: LD_VAR 0 1
42123: ARRAY
42124: NOT
42125: IFFALSE 42129
// exit ;
42127: GO 42154
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42129: LD_ADDR_EXP 55
42133: PUSH
42134: LD_EXP 55
42138: PPUSH
42139: LD_VAR 0 1
42143: PPUSH
42144: LD_VAR 0 2
42148: PPUSH
42149: CALL_OW 1
42153: ST_TO_ADDR
// end ;
42154: LD_VAR 0 3
42158: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42159: LD_INT 0
42161: PPUSH
// if not mc_bases [ base ] then
42162: LD_EXP 50
42166: PUSH
42167: LD_VAR 0 1
42171: ARRAY
42172: NOT
42173: IFFALSE 42177
// exit ;
42175: GO 42214
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42177: LD_ADDR_EXP 55
42181: PUSH
42182: LD_EXP 55
42186: PPUSH
42187: LD_VAR 0 1
42191: PPUSH
42192: LD_EXP 55
42196: PUSH
42197: LD_VAR 0 1
42201: ARRAY
42202: PUSH
42203: LD_VAR 0 2
42207: UNION
42208: PPUSH
42209: CALL_OW 1
42213: ST_TO_ADDR
// end ;
42214: LD_VAR 0 3
42218: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42219: LD_INT 0
42221: PPUSH
// if not mc_bases [ base ] then
42222: LD_EXP 50
42226: PUSH
42227: LD_VAR 0 1
42231: ARRAY
42232: NOT
42233: IFFALSE 42237
// exit ;
42235: GO 42262
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42237: LD_ADDR_EXP 71
42241: PUSH
42242: LD_EXP 71
42246: PPUSH
42247: LD_VAR 0 1
42251: PPUSH
42252: LD_VAR 0 2
42256: PPUSH
42257: CALL_OW 1
42261: ST_TO_ADDR
// end ;
42262: LD_VAR 0 3
42266: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42267: LD_INT 0
42269: PPUSH
// if not mc_bases [ base ] then
42270: LD_EXP 50
42274: PUSH
42275: LD_VAR 0 1
42279: ARRAY
42280: NOT
42281: IFFALSE 42285
// exit ;
42283: GO 42322
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42285: LD_ADDR_EXP 71
42289: PUSH
42290: LD_EXP 71
42294: PPUSH
42295: LD_VAR 0 1
42299: PPUSH
42300: LD_EXP 71
42304: PUSH
42305: LD_VAR 0 1
42309: ARRAY
42310: PUSH
42311: LD_VAR 0 2
42315: ADD
42316: PPUSH
42317: CALL_OW 1
42321: ST_TO_ADDR
// end ;
42322: LD_VAR 0 3
42326: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42327: LD_INT 0
42329: PPUSH
// if not mc_bases [ base ] then
42330: LD_EXP 50
42334: PUSH
42335: LD_VAR 0 1
42339: ARRAY
42340: NOT
42341: IFFALSE 42345
// exit ;
42343: GO 42399
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42345: LD_ADDR_EXP 72
42349: PUSH
42350: LD_EXP 72
42354: PPUSH
42355: LD_VAR 0 1
42359: PPUSH
42360: LD_VAR 0 2
42364: PPUSH
42365: CALL_OW 1
42369: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42370: LD_ADDR_EXP 61
42374: PUSH
42375: LD_EXP 61
42379: PPUSH
42380: LD_VAR 0 1
42384: PPUSH
42385: LD_VAR 0 2
42389: PUSH
42390: LD_INT 0
42392: PLUS
42393: PPUSH
42394: CALL_OW 1
42398: ST_TO_ADDR
// end ;
42399: LD_VAR 0 3
42403: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42404: LD_INT 0
42406: PPUSH
// if not mc_bases [ base ] then
42407: LD_EXP 50
42411: PUSH
42412: LD_VAR 0 1
42416: ARRAY
42417: NOT
42418: IFFALSE 42422
// exit ;
42420: GO 42447
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42422: LD_ADDR_EXP 61
42426: PUSH
42427: LD_EXP 61
42431: PPUSH
42432: LD_VAR 0 1
42436: PPUSH
42437: LD_VAR 0 2
42441: PPUSH
42442: CALL_OW 1
42446: ST_TO_ADDR
// end ;
42447: LD_VAR 0 3
42451: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42452: LD_INT 0
42454: PPUSH
42455: PPUSH
42456: PPUSH
42457: PPUSH
// if not mc_bases [ base ] then
42458: LD_EXP 50
42462: PUSH
42463: LD_VAR 0 1
42467: ARRAY
42468: NOT
42469: IFFALSE 42473
// exit ;
42471: GO 42538
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42473: LD_ADDR_EXP 70
42477: PUSH
42478: LD_EXP 70
42482: PPUSH
42483: LD_VAR 0 1
42487: PUSH
42488: LD_EXP 70
42492: PUSH
42493: LD_VAR 0 1
42497: ARRAY
42498: PUSH
42499: LD_INT 1
42501: PLUS
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PPUSH
42507: LD_VAR 0 1
42511: PUSH
42512: LD_VAR 0 2
42516: PUSH
42517: LD_VAR 0 3
42521: PUSH
42522: LD_VAR 0 4
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: LIST
42531: LIST
42532: PPUSH
42533: CALL 53792 0 3
42537: ST_TO_ADDR
// end ;
42538: LD_VAR 0 5
42542: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42543: LD_INT 0
42545: PPUSH
// if not mc_bases [ base ] then
42546: LD_EXP 50
42550: PUSH
42551: LD_VAR 0 1
42555: ARRAY
42556: NOT
42557: IFFALSE 42561
// exit ;
42559: GO 42586
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42561: LD_ADDR_EXP 87
42565: PUSH
42566: LD_EXP 87
42570: PPUSH
42571: LD_VAR 0 1
42575: PPUSH
42576: LD_VAR 0 2
42580: PPUSH
42581: CALL_OW 1
42585: ST_TO_ADDR
// end ;
42586: LD_VAR 0 3
42590: RET
// export function MC_GetMinesField ( base ) ; begin
42591: LD_INT 0
42593: PPUSH
// result := mc_mines [ base ] ;
42594: LD_ADDR_VAR 0 2
42598: PUSH
42599: LD_EXP 63
42603: PUSH
42604: LD_VAR 0 1
42608: ARRAY
42609: ST_TO_ADDR
// end ;
42610: LD_VAR 0 2
42614: RET
// export function MC_GetProduceList ( base ) ; begin
42615: LD_INT 0
42617: PPUSH
// result := mc_produce [ base ] ;
42618: LD_ADDR_VAR 0 2
42622: PUSH
42623: LD_EXP 71
42627: PUSH
42628: LD_VAR 0 1
42632: ARRAY
42633: ST_TO_ADDR
// end ;
42634: LD_VAR 0 2
42638: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42639: LD_INT 0
42641: PPUSH
42642: PPUSH
// if not mc_bases then
42643: LD_EXP 50
42647: NOT
42648: IFFALSE 42652
// exit ;
42650: GO 42717
// if mc_bases [ base ] then
42652: LD_EXP 50
42656: PUSH
42657: LD_VAR 0 1
42661: ARRAY
42662: IFFALSE 42717
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42664: LD_ADDR_VAR 0 3
42668: PUSH
42669: LD_EXP 50
42673: PUSH
42674: LD_VAR 0 1
42678: ARRAY
42679: PPUSH
42680: LD_INT 30
42682: PUSH
42683: LD_VAR 0 2
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PPUSH
42692: CALL_OW 72
42696: ST_TO_ADDR
// if result then
42697: LD_VAR 0 3
42701: IFFALSE 42717
// result := result [ 1 ] ;
42703: LD_ADDR_VAR 0 3
42707: PUSH
42708: LD_VAR 0 3
42712: PUSH
42713: LD_INT 1
42715: ARRAY
42716: ST_TO_ADDR
// end ; end ;
42717: LD_VAR 0 3
42721: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42722: LD_INT 0
42724: PPUSH
42725: PPUSH
// if not mc_bases then
42726: LD_EXP 50
42730: NOT
42731: IFFALSE 42735
// exit ;
42733: GO 42780
// if mc_bases [ base ] then
42735: LD_EXP 50
42739: PUSH
42740: LD_VAR 0 1
42744: ARRAY
42745: IFFALSE 42780
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42747: LD_ADDR_VAR 0 3
42751: PUSH
42752: LD_EXP 50
42756: PUSH
42757: LD_VAR 0 1
42761: ARRAY
42762: PPUSH
42763: LD_INT 30
42765: PUSH
42766: LD_VAR 0 2
42770: PUSH
42771: EMPTY
42772: LIST
42773: LIST
42774: PPUSH
42775: CALL_OW 72
42779: ST_TO_ADDR
// end ;
42780: LD_VAR 0 3
42784: RET
// export function MC_SetTame ( base , area ) ; begin
42785: LD_INT 0
42787: PPUSH
// if not mc_bases or not base then
42788: LD_EXP 50
42792: NOT
42793: PUSH
42794: LD_VAR 0 1
42798: NOT
42799: OR
42800: IFFALSE 42804
// exit ;
42802: GO 42829
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42804: LD_ADDR_EXP 78
42808: PUSH
42809: LD_EXP 78
42813: PPUSH
42814: LD_VAR 0 1
42818: PPUSH
42819: LD_VAR 0 2
42823: PPUSH
42824: CALL_OW 1
42828: ST_TO_ADDR
// end ;
42829: LD_VAR 0 3
42833: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42834: LD_INT 0
42836: PPUSH
42837: PPUSH
// if not mc_bases or not base then
42838: LD_EXP 50
42842: NOT
42843: PUSH
42844: LD_VAR 0 1
42848: NOT
42849: OR
42850: IFFALSE 42854
// exit ;
42852: GO 42956
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42854: LD_ADDR_VAR 0 4
42858: PUSH
42859: LD_EXP 50
42863: PUSH
42864: LD_VAR 0 1
42868: ARRAY
42869: PPUSH
42870: LD_INT 30
42872: PUSH
42873: LD_VAR 0 2
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: PPUSH
42882: CALL_OW 72
42886: ST_TO_ADDR
// if not tmp then
42887: LD_VAR 0 4
42891: NOT
42892: IFFALSE 42896
// exit ;
42894: GO 42956
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42896: LD_ADDR_EXP 82
42900: PUSH
42901: LD_EXP 82
42905: PPUSH
42906: LD_VAR 0 1
42910: PPUSH
42911: LD_EXP 82
42915: PUSH
42916: LD_VAR 0 1
42920: ARRAY
42921: PPUSH
42922: LD_EXP 82
42926: PUSH
42927: LD_VAR 0 1
42931: ARRAY
42932: PUSH
42933: LD_INT 1
42935: PLUS
42936: PPUSH
42937: LD_VAR 0 4
42941: PUSH
42942: LD_INT 1
42944: ARRAY
42945: PPUSH
42946: CALL_OW 2
42950: PPUSH
42951: CALL_OW 1
42955: ST_TO_ADDR
// end ;
42956: LD_VAR 0 3
42960: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42961: LD_INT 0
42963: PPUSH
42964: PPUSH
// if not mc_bases or not base or not kinds then
42965: LD_EXP 50
42969: NOT
42970: PUSH
42971: LD_VAR 0 1
42975: NOT
42976: OR
42977: PUSH
42978: LD_VAR 0 2
42982: NOT
42983: OR
42984: IFFALSE 42988
// exit ;
42986: GO 43049
// for i in kinds do
42988: LD_ADDR_VAR 0 4
42992: PUSH
42993: LD_VAR 0 2
42997: PUSH
42998: FOR_IN
42999: IFFALSE 43047
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43001: LD_ADDR_EXP 84
43005: PUSH
43006: LD_EXP 84
43010: PPUSH
43011: LD_VAR 0 1
43015: PUSH
43016: LD_EXP 84
43020: PUSH
43021: LD_VAR 0 1
43025: ARRAY
43026: PUSH
43027: LD_INT 1
43029: PLUS
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PPUSH
43035: LD_VAR 0 4
43039: PPUSH
43040: CALL 53792 0 3
43044: ST_TO_ADDR
43045: GO 42998
43047: POP
43048: POP
// end ;
43049: LD_VAR 0 3
43053: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43054: LD_INT 0
43056: PPUSH
// if not mc_bases or not base or not areas then
43057: LD_EXP 50
43061: NOT
43062: PUSH
43063: LD_VAR 0 1
43067: NOT
43068: OR
43069: PUSH
43070: LD_VAR 0 2
43074: NOT
43075: OR
43076: IFFALSE 43080
// exit ;
43078: GO 43105
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43080: LD_ADDR_EXP 68
43084: PUSH
43085: LD_EXP 68
43089: PPUSH
43090: LD_VAR 0 1
43094: PPUSH
43095: LD_VAR 0 2
43099: PPUSH
43100: CALL_OW 1
43104: ST_TO_ADDR
// end ;
43105: LD_VAR 0 3
43109: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43110: LD_INT 0
43112: PPUSH
// if not mc_bases or not base or not teleports_exit then
43113: LD_EXP 50
43117: NOT
43118: PUSH
43119: LD_VAR 0 1
43123: NOT
43124: OR
43125: PUSH
43126: LD_VAR 0 2
43130: NOT
43131: OR
43132: IFFALSE 43136
// exit ;
43134: GO 43161
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43136: LD_ADDR_EXP 85
43140: PUSH
43141: LD_EXP 85
43145: PPUSH
43146: LD_VAR 0 1
43150: PPUSH
43151: LD_VAR 0 2
43155: PPUSH
43156: CALL_OW 1
43160: ST_TO_ADDR
// end ;
43161: LD_VAR 0 3
43165: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43166: LD_INT 0
43168: PPUSH
43169: PPUSH
43170: PPUSH
// if not mc_bases or not base or not ext_list then
43171: LD_EXP 50
43175: NOT
43176: PUSH
43177: LD_VAR 0 1
43181: NOT
43182: OR
43183: PUSH
43184: LD_VAR 0 5
43188: NOT
43189: OR
43190: IFFALSE 43194
// exit ;
43192: GO 43367
// tmp := GetFacExtXYD ( x , y , d ) ;
43194: LD_ADDR_VAR 0 8
43198: PUSH
43199: LD_VAR 0 2
43203: PPUSH
43204: LD_VAR 0 3
43208: PPUSH
43209: LD_VAR 0 4
43213: PPUSH
43214: CALL 83743 0 3
43218: ST_TO_ADDR
// if not tmp then
43219: LD_VAR 0 8
43223: NOT
43224: IFFALSE 43228
// exit ;
43226: GO 43367
// for i in tmp do
43228: LD_ADDR_VAR 0 7
43232: PUSH
43233: LD_VAR 0 8
43237: PUSH
43238: FOR_IN
43239: IFFALSE 43365
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43241: LD_ADDR_EXP 55
43245: PUSH
43246: LD_EXP 55
43250: PPUSH
43251: LD_VAR 0 1
43255: PPUSH
43256: LD_EXP 55
43260: PUSH
43261: LD_VAR 0 1
43265: ARRAY
43266: PPUSH
43267: LD_EXP 55
43271: PUSH
43272: LD_VAR 0 1
43276: ARRAY
43277: PUSH
43278: LD_INT 1
43280: PLUS
43281: PPUSH
43282: LD_VAR 0 5
43286: PUSH
43287: LD_INT 1
43289: ARRAY
43290: PUSH
43291: LD_VAR 0 7
43295: PUSH
43296: LD_INT 1
43298: ARRAY
43299: PUSH
43300: LD_VAR 0 7
43304: PUSH
43305: LD_INT 2
43307: ARRAY
43308: PUSH
43309: LD_VAR 0 7
43313: PUSH
43314: LD_INT 3
43316: ARRAY
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: LIST
43322: LIST
43323: PPUSH
43324: CALL_OW 2
43328: PPUSH
43329: CALL_OW 1
43333: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43334: LD_ADDR_VAR 0 5
43338: PUSH
43339: LD_VAR 0 5
43343: PPUSH
43344: LD_INT 1
43346: PPUSH
43347: CALL_OW 3
43351: ST_TO_ADDR
// if not ext_list then
43352: LD_VAR 0 5
43356: NOT
43357: IFFALSE 43363
// exit ;
43359: POP
43360: POP
43361: GO 43367
// end ;
43363: GO 43238
43365: POP
43366: POP
// end ;
43367: LD_VAR 0 6
43371: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43372: LD_INT 0
43374: PPUSH
// if not mc_bases or not base or not weapon_list then
43375: LD_EXP 50
43379: NOT
43380: PUSH
43381: LD_VAR 0 1
43385: NOT
43386: OR
43387: PUSH
43388: LD_VAR 0 2
43392: NOT
43393: OR
43394: IFFALSE 43398
// exit ;
43396: GO 43423
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43398: LD_ADDR_EXP 89
43402: PUSH
43403: LD_EXP 89
43407: PPUSH
43408: LD_VAR 0 1
43412: PPUSH
43413: LD_VAR 0 2
43417: PPUSH
43418: CALL_OW 1
43422: ST_TO_ADDR
// end ;
43423: LD_VAR 0 3
43427: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43428: LD_INT 0
43430: PPUSH
// if not mc_bases or not base or not tech_list then
43431: LD_EXP 50
43435: NOT
43436: PUSH
43437: LD_VAR 0 1
43441: NOT
43442: OR
43443: PUSH
43444: LD_VAR 0 2
43448: NOT
43449: OR
43450: IFFALSE 43454
// exit ;
43452: GO 43479
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43454: LD_ADDR_EXP 77
43458: PUSH
43459: LD_EXP 77
43463: PPUSH
43464: LD_VAR 0 1
43468: PPUSH
43469: LD_VAR 0 2
43473: PPUSH
43474: CALL_OW 1
43478: ST_TO_ADDR
// end ;
43479: LD_VAR 0 3
43483: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43484: LD_INT 0
43486: PPUSH
// if not mc_bases or not parking_area or not base then
43487: LD_EXP 50
43491: NOT
43492: PUSH
43493: LD_VAR 0 2
43497: NOT
43498: OR
43499: PUSH
43500: LD_VAR 0 1
43504: NOT
43505: OR
43506: IFFALSE 43510
// exit ;
43508: GO 43535
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43510: LD_ADDR_EXP 74
43514: PUSH
43515: LD_EXP 74
43519: PPUSH
43520: LD_VAR 0 1
43524: PPUSH
43525: LD_VAR 0 2
43529: PPUSH
43530: CALL_OW 1
43534: ST_TO_ADDR
// end ;
43535: LD_VAR 0 3
43539: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43540: LD_INT 0
43542: PPUSH
// if not mc_bases or not base or not scan_area then
43543: LD_EXP 50
43547: NOT
43548: PUSH
43549: LD_VAR 0 1
43553: NOT
43554: OR
43555: PUSH
43556: LD_VAR 0 2
43560: NOT
43561: OR
43562: IFFALSE 43566
// exit ;
43564: GO 43591
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43566: LD_ADDR_EXP 75
43570: PUSH
43571: LD_EXP 75
43575: PPUSH
43576: LD_VAR 0 1
43580: PPUSH
43581: LD_VAR 0 2
43585: PPUSH
43586: CALL_OW 1
43590: ST_TO_ADDR
// end ;
43591: LD_VAR 0 3
43595: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43596: LD_INT 0
43598: PPUSH
43599: PPUSH
// if not mc_bases or not base then
43600: LD_EXP 50
43604: NOT
43605: PUSH
43606: LD_VAR 0 1
43610: NOT
43611: OR
43612: IFFALSE 43616
// exit ;
43614: GO 43680
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43616: LD_ADDR_VAR 0 3
43620: PUSH
43621: LD_INT 1
43623: PUSH
43624: LD_INT 2
43626: PUSH
43627: LD_INT 3
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: LD_INT 11
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43643: LD_ADDR_EXP 77
43647: PUSH
43648: LD_EXP 77
43652: PPUSH
43653: LD_VAR 0 1
43657: PPUSH
43658: LD_EXP 77
43662: PUSH
43663: LD_VAR 0 1
43667: ARRAY
43668: PUSH
43669: LD_VAR 0 3
43673: DIFF
43674: PPUSH
43675: CALL_OW 1
43679: ST_TO_ADDR
// end ;
43680: LD_VAR 0 2
43684: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43685: LD_INT 0
43687: PPUSH
// result := mc_vehicles [ base ] ;
43688: LD_ADDR_VAR 0 3
43692: PUSH
43693: LD_EXP 69
43697: PUSH
43698: LD_VAR 0 1
43702: ARRAY
43703: ST_TO_ADDR
// if onlyCombat then
43704: LD_VAR 0 2
43708: IFFALSE 43880
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43710: LD_ADDR_VAR 0 3
43714: PUSH
43715: LD_VAR 0 3
43719: PUSH
43720: LD_VAR 0 3
43724: PPUSH
43725: LD_INT 2
43727: PUSH
43728: LD_INT 34
43730: PUSH
43731: LD_INT 12
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 34
43740: PUSH
43741: LD_INT 51
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 34
43750: PUSH
43751: LD_INT 89
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 34
43760: PUSH
43761: LD_INT 32
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: LD_INT 34
43770: PUSH
43771: LD_INT 13
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 34
43780: PUSH
43781: LD_INT 52
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 34
43790: PUSH
43791: LD_INT 88
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 34
43800: PUSH
43801: LD_INT 14
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 34
43810: PUSH
43811: LD_INT 53
43813: PUSH
43814: EMPTY
43815: LIST
43816: LIST
43817: PUSH
43818: LD_INT 34
43820: PUSH
43821: LD_INT 98
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: PUSH
43828: LD_INT 34
43830: PUSH
43831: LD_INT 31
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 34
43840: PUSH
43841: LD_INT 48
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 34
43850: PUSH
43851: LD_INT 8
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: PPUSH
43874: CALL_OW 72
43878: DIFF
43879: ST_TO_ADDR
// end ; end_of_file
43880: LD_VAR 0 3
43884: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43885: LD_INT 0
43887: PPUSH
43888: PPUSH
43889: PPUSH
// if not mc_bases or not skirmish then
43890: LD_EXP 50
43894: NOT
43895: PUSH
43896: LD_EXP 48
43900: NOT
43901: OR
43902: IFFALSE 43906
// exit ;
43904: GO 44071
// for i = 1 to mc_bases do
43906: LD_ADDR_VAR 0 4
43910: PUSH
43911: DOUBLE
43912: LD_INT 1
43914: DEC
43915: ST_TO_ADDR
43916: LD_EXP 50
43920: PUSH
43921: FOR_TO
43922: IFFALSE 44069
// begin if sci in mc_bases [ i ] then
43924: LD_VAR 0 2
43928: PUSH
43929: LD_EXP 50
43933: PUSH
43934: LD_VAR 0 4
43938: ARRAY
43939: IN
43940: IFFALSE 44067
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43942: LD_ADDR_EXP 79
43946: PUSH
43947: LD_EXP 79
43951: PPUSH
43952: LD_VAR 0 4
43956: PUSH
43957: LD_EXP 79
43961: PUSH
43962: LD_VAR 0 4
43966: ARRAY
43967: PUSH
43968: LD_INT 1
43970: PLUS
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PPUSH
43976: LD_VAR 0 1
43980: PPUSH
43981: CALL 53792 0 3
43985: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43986: LD_ADDR_VAR 0 5
43990: PUSH
43991: LD_EXP 50
43995: PUSH
43996: LD_VAR 0 4
44000: ARRAY
44001: PPUSH
44002: LD_INT 2
44004: PUSH
44005: LD_INT 30
44007: PUSH
44008: LD_INT 0
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: LD_INT 30
44017: PUSH
44018: LD_INT 1
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: LIST
44029: PPUSH
44030: CALL_OW 72
44034: PPUSH
44035: LD_VAR 0 1
44039: PPUSH
44040: CALL_OW 74
44044: ST_TO_ADDR
// if tmp then
44045: LD_VAR 0 5
44049: IFFALSE 44065
// ComStandNearbyBuilding ( ape , tmp ) ;
44051: LD_VAR 0 1
44055: PPUSH
44056: LD_VAR 0 5
44060: PPUSH
44061: CALL 50219 0 2
// break ;
44065: GO 44069
// end ; end ;
44067: GO 43921
44069: POP
44070: POP
// end ;
44071: LD_VAR 0 3
44075: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44076: LD_INT 0
44078: PPUSH
44079: PPUSH
44080: PPUSH
// if not mc_bases or not skirmish then
44081: LD_EXP 50
44085: NOT
44086: PUSH
44087: LD_EXP 48
44091: NOT
44092: OR
44093: IFFALSE 44097
// exit ;
44095: GO 44186
// for i = 1 to mc_bases do
44097: LD_ADDR_VAR 0 4
44101: PUSH
44102: DOUBLE
44103: LD_INT 1
44105: DEC
44106: ST_TO_ADDR
44107: LD_EXP 50
44111: PUSH
44112: FOR_TO
44113: IFFALSE 44184
// begin if building in mc_busy_turret_list [ i ] then
44115: LD_VAR 0 1
44119: PUSH
44120: LD_EXP 60
44124: PUSH
44125: LD_VAR 0 4
44129: ARRAY
44130: IN
44131: IFFALSE 44182
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44133: LD_ADDR_VAR 0 5
44137: PUSH
44138: LD_EXP 60
44142: PUSH
44143: LD_VAR 0 4
44147: ARRAY
44148: PUSH
44149: LD_VAR 0 1
44153: DIFF
44154: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44155: LD_ADDR_EXP 60
44159: PUSH
44160: LD_EXP 60
44164: PPUSH
44165: LD_VAR 0 4
44169: PPUSH
44170: LD_VAR 0 5
44174: PPUSH
44175: CALL_OW 1
44179: ST_TO_ADDR
// break ;
44180: GO 44184
// end ; end ;
44182: GO 44112
44184: POP
44185: POP
// end ;
44186: LD_VAR 0 3
44190: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44191: LD_INT 0
44193: PPUSH
44194: PPUSH
44195: PPUSH
// if not mc_bases or not skirmish then
44196: LD_EXP 50
44200: NOT
44201: PUSH
44202: LD_EXP 48
44206: NOT
44207: OR
44208: IFFALSE 44212
// exit ;
44210: GO 44411
// for i = 1 to mc_bases do
44212: LD_ADDR_VAR 0 5
44216: PUSH
44217: DOUBLE
44218: LD_INT 1
44220: DEC
44221: ST_TO_ADDR
44222: LD_EXP 50
44226: PUSH
44227: FOR_TO
44228: IFFALSE 44409
// if building in mc_bases [ i ] then
44230: LD_VAR 0 1
44234: PUSH
44235: LD_EXP 50
44239: PUSH
44240: LD_VAR 0 5
44244: ARRAY
44245: IN
44246: IFFALSE 44407
// begin tmp := mc_bases [ i ] diff building ;
44248: LD_ADDR_VAR 0 6
44252: PUSH
44253: LD_EXP 50
44257: PUSH
44258: LD_VAR 0 5
44262: ARRAY
44263: PUSH
44264: LD_VAR 0 1
44268: DIFF
44269: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44270: LD_ADDR_EXP 50
44274: PUSH
44275: LD_EXP 50
44279: PPUSH
44280: LD_VAR 0 5
44284: PPUSH
44285: LD_VAR 0 6
44289: PPUSH
44290: CALL_OW 1
44294: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44295: LD_VAR 0 1
44299: PUSH
44300: LD_EXP 58
44304: PUSH
44305: LD_VAR 0 5
44309: ARRAY
44310: IN
44311: IFFALSE 44350
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44313: LD_ADDR_EXP 58
44317: PUSH
44318: LD_EXP 58
44322: PPUSH
44323: LD_VAR 0 5
44327: PPUSH
44328: LD_EXP 58
44332: PUSH
44333: LD_VAR 0 5
44337: ARRAY
44338: PUSH
44339: LD_VAR 0 1
44343: DIFF
44344: PPUSH
44345: CALL_OW 1
44349: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44350: LD_VAR 0 1
44354: PUSH
44355: LD_EXP 59
44359: PUSH
44360: LD_VAR 0 5
44364: ARRAY
44365: IN
44366: IFFALSE 44405
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44368: LD_ADDR_EXP 59
44372: PUSH
44373: LD_EXP 59
44377: PPUSH
44378: LD_VAR 0 5
44382: PPUSH
44383: LD_EXP 59
44387: PUSH
44388: LD_VAR 0 5
44392: ARRAY
44393: PUSH
44394: LD_VAR 0 1
44398: DIFF
44399: PPUSH
44400: CALL_OW 1
44404: ST_TO_ADDR
// break ;
44405: GO 44409
// end ;
44407: GO 44227
44409: POP
44410: POP
// end ;
44411: LD_VAR 0 4
44415: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44416: LD_INT 0
44418: PPUSH
44419: PPUSH
44420: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44421: LD_EXP 50
44425: NOT
44426: PUSH
44427: LD_EXP 48
44431: NOT
44432: OR
44433: PUSH
44434: LD_VAR 0 3
44438: PUSH
44439: LD_EXP 76
44443: IN
44444: NOT
44445: OR
44446: IFFALSE 44450
// exit ;
44448: GO 44573
// for i = 1 to mc_vehicles do
44450: LD_ADDR_VAR 0 6
44454: PUSH
44455: DOUBLE
44456: LD_INT 1
44458: DEC
44459: ST_TO_ADDR
44460: LD_EXP 69
44464: PUSH
44465: FOR_TO
44466: IFFALSE 44571
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44468: LD_VAR 0 2
44472: PUSH
44473: LD_EXP 69
44477: PUSH
44478: LD_VAR 0 6
44482: ARRAY
44483: IN
44484: PUSH
44485: LD_VAR 0 1
44489: PUSH
44490: LD_EXP 69
44494: PUSH
44495: LD_VAR 0 6
44499: ARRAY
44500: IN
44501: OR
44502: IFFALSE 44569
// begin tmp := mc_vehicles [ i ] diff old ;
44504: LD_ADDR_VAR 0 7
44508: PUSH
44509: LD_EXP 69
44513: PUSH
44514: LD_VAR 0 6
44518: ARRAY
44519: PUSH
44520: LD_VAR 0 2
44524: DIFF
44525: ST_TO_ADDR
// tmp := tmp diff new ;
44526: LD_ADDR_VAR 0 7
44530: PUSH
44531: LD_VAR 0 7
44535: PUSH
44536: LD_VAR 0 1
44540: DIFF
44541: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44542: LD_ADDR_EXP 69
44546: PUSH
44547: LD_EXP 69
44551: PPUSH
44552: LD_VAR 0 6
44556: PPUSH
44557: LD_VAR 0 7
44561: PPUSH
44562: CALL_OW 1
44566: ST_TO_ADDR
// break ;
44567: GO 44571
// end ;
44569: GO 44465
44571: POP
44572: POP
// end ;
44573: LD_VAR 0 5
44577: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44578: LD_INT 0
44580: PPUSH
44581: PPUSH
44582: PPUSH
44583: PPUSH
// if not mc_bases or not skirmish then
44584: LD_EXP 50
44588: NOT
44589: PUSH
44590: LD_EXP 48
44594: NOT
44595: OR
44596: IFFALSE 44600
// exit ;
44598: GO 44982
// side := GetSide ( vehicle ) ;
44600: LD_ADDR_VAR 0 5
44604: PUSH
44605: LD_VAR 0 1
44609: PPUSH
44610: CALL_OW 255
44614: ST_TO_ADDR
// for i = 1 to mc_bases do
44615: LD_ADDR_VAR 0 4
44619: PUSH
44620: DOUBLE
44621: LD_INT 1
44623: DEC
44624: ST_TO_ADDR
44625: LD_EXP 50
44629: PUSH
44630: FOR_TO
44631: IFFALSE 44980
// begin if factory in mc_bases [ i ] then
44633: LD_VAR 0 2
44637: PUSH
44638: LD_EXP 50
44642: PUSH
44643: LD_VAR 0 4
44647: ARRAY
44648: IN
44649: IFFALSE 44978
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44651: LD_EXP 72
44655: PUSH
44656: LD_VAR 0 4
44660: ARRAY
44661: PUSH
44662: LD_EXP 61
44666: PUSH
44667: LD_VAR 0 4
44671: ARRAY
44672: LESS
44673: PUSH
44674: LD_VAR 0 1
44678: PPUSH
44679: CALL_OW 264
44683: PUSH
44684: LD_INT 31
44686: PUSH
44687: LD_INT 32
44689: PUSH
44690: LD_INT 51
44692: PUSH
44693: LD_INT 89
44695: PUSH
44696: LD_INT 12
44698: PUSH
44699: LD_INT 30
44701: PUSH
44702: LD_INT 98
44704: PUSH
44705: LD_INT 11
44707: PUSH
44708: LD_INT 53
44710: PUSH
44711: LD_INT 14
44713: PUSH
44714: LD_INT 91
44716: PUSH
44717: LD_INT 29
44719: PUSH
44720: LD_INT 99
44722: PUSH
44723: LD_INT 13
44725: PUSH
44726: LD_INT 52
44728: PUSH
44729: LD_INT 88
44731: PUSH
44732: LD_INT 48
44734: PUSH
44735: LD_INT 8
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: IN
44758: NOT
44759: AND
44760: IFFALSE 44808
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44762: LD_ADDR_EXP 72
44766: PUSH
44767: LD_EXP 72
44771: PPUSH
44772: LD_VAR 0 4
44776: PUSH
44777: LD_EXP 72
44781: PUSH
44782: LD_VAR 0 4
44786: ARRAY
44787: PUSH
44788: LD_INT 1
44790: PLUS
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PPUSH
44796: LD_VAR 0 1
44800: PPUSH
44801: CALL 53792 0 3
44805: ST_TO_ADDR
44806: GO 44852
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44808: LD_ADDR_EXP 69
44812: PUSH
44813: LD_EXP 69
44817: PPUSH
44818: LD_VAR 0 4
44822: PUSH
44823: LD_EXP 69
44827: PUSH
44828: LD_VAR 0 4
44832: ARRAY
44833: PUSH
44834: LD_INT 1
44836: PLUS
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PPUSH
44842: LD_VAR 0 1
44846: PPUSH
44847: CALL 53792 0 3
44851: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44852: LD_VAR 0 1
44856: PPUSH
44857: CALL_OW 263
44861: PUSH
44862: LD_INT 2
44864: EQUAL
44865: IFFALSE 44894
// begin repeat wait ( 0 0$3 ) ;
44867: LD_INT 105
44869: PPUSH
44870: CALL_OW 67
// Connect ( vehicle ) ;
44874: LD_VAR 0 1
44878: PPUSH
44879: CALL 56761 0 1
// until IsControledBy ( vehicle ) ;
44883: LD_VAR 0 1
44887: PPUSH
44888: CALL_OW 312
44892: IFFALSE 44867
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44894: LD_VAR 0 1
44898: PPUSH
44899: LD_EXP 74
44903: PUSH
44904: LD_VAR 0 4
44908: ARRAY
44909: PPUSH
44910: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44914: LD_VAR 0 1
44918: PPUSH
44919: CALL_OW 263
44923: PUSH
44924: LD_INT 1
44926: NONEQUAL
44927: IFFALSE 44931
// break ;
44929: GO 44980
// repeat wait ( 0 0$1 ) ;
44931: LD_INT 35
44933: PPUSH
44934: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44938: LD_VAR 0 1
44942: PPUSH
44943: LD_EXP 74
44947: PUSH
44948: LD_VAR 0 4
44952: ARRAY
44953: PPUSH
44954: CALL_OW 308
44958: IFFALSE 44931
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44960: LD_VAR 0 1
44964: PPUSH
44965: CALL_OW 311
44969: PPUSH
44970: CALL_OW 121
// exit ;
44974: POP
44975: POP
44976: GO 44982
// end ; end ;
44978: GO 44630
44980: POP
44981: POP
// end ;
44982: LD_VAR 0 3
44986: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44987: LD_INT 0
44989: PPUSH
44990: PPUSH
44991: PPUSH
44992: PPUSH
// if not mc_bases or not skirmish then
44993: LD_EXP 50
44997: NOT
44998: PUSH
44999: LD_EXP 48
45003: NOT
45004: OR
45005: IFFALSE 45009
// exit ;
45007: GO 45362
// repeat wait ( 0 0$1 ) ;
45009: LD_INT 35
45011: PPUSH
45012: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45016: LD_VAR 0 2
45020: PPUSH
45021: LD_VAR 0 3
45025: PPUSH
45026: CALL_OW 284
45030: IFFALSE 45009
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45032: LD_VAR 0 2
45036: PPUSH
45037: LD_VAR 0 3
45041: PPUSH
45042: CALL_OW 283
45046: PUSH
45047: LD_INT 4
45049: EQUAL
45050: IFFALSE 45054
// exit ;
45052: GO 45362
// for i = 1 to mc_bases do
45054: LD_ADDR_VAR 0 7
45058: PUSH
45059: DOUBLE
45060: LD_INT 1
45062: DEC
45063: ST_TO_ADDR
45064: LD_EXP 50
45068: PUSH
45069: FOR_TO
45070: IFFALSE 45360
// begin if mc_crates_area [ i ] then
45072: LD_EXP 68
45076: PUSH
45077: LD_VAR 0 7
45081: ARRAY
45082: IFFALSE 45193
// for j in mc_crates_area [ i ] do
45084: LD_ADDR_VAR 0 8
45088: PUSH
45089: LD_EXP 68
45093: PUSH
45094: LD_VAR 0 7
45098: ARRAY
45099: PUSH
45100: FOR_IN
45101: IFFALSE 45191
// if InArea ( x , y , j ) then
45103: LD_VAR 0 2
45107: PPUSH
45108: LD_VAR 0 3
45112: PPUSH
45113: LD_VAR 0 8
45117: PPUSH
45118: CALL_OW 309
45122: IFFALSE 45189
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45124: LD_ADDR_EXP 66
45128: PUSH
45129: LD_EXP 66
45133: PPUSH
45134: LD_VAR 0 7
45138: PUSH
45139: LD_EXP 66
45143: PUSH
45144: LD_VAR 0 7
45148: ARRAY
45149: PUSH
45150: LD_INT 1
45152: PLUS
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PPUSH
45158: LD_VAR 0 4
45162: PUSH
45163: LD_VAR 0 2
45167: PUSH
45168: LD_VAR 0 3
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: LIST
45177: PPUSH
45178: CALL 53792 0 3
45182: ST_TO_ADDR
// exit ;
45183: POP
45184: POP
45185: POP
45186: POP
45187: GO 45362
// end ;
45189: GO 45100
45191: POP
45192: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45193: LD_ADDR_VAR 0 9
45197: PUSH
45198: LD_EXP 50
45202: PUSH
45203: LD_VAR 0 7
45207: ARRAY
45208: PPUSH
45209: LD_INT 2
45211: PUSH
45212: LD_INT 30
45214: PUSH
45215: LD_INT 0
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: LD_INT 30
45224: PUSH
45225: LD_INT 1
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: LIST
45236: PPUSH
45237: CALL_OW 72
45241: ST_TO_ADDR
// if not depot then
45242: LD_VAR 0 9
45246: NOT
45247: IFFALSE 45251
// continue ;
45249: GO 45069
// for j in depot do
45251: LD_ADDR_VAR 0 8
45255: PUSH
45256: LD_VAR 0 9
45260: PUSH
45261: FOR_IN
45262: IFFALSE 45356
// if GetDistUnitXY ( j , x , y ) < 30 then
45264: LD_VAR 0 8
45268: PPUSH
45269: LD_VAR 0 2
45273: PPUSH
45274: LD_VAR 0 3
45278: PPUSH
45279: CALL_OW 297
45283: PUSH
45284: LD_INT 30
45286: LESS
45287: IFFALSE 45354
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45289: LD_ADDR_EXP 66
45293: PUSH
45294: LD_EXP 66
45298: PPUSH
45299: LD_VAR 0 7
45303: PUSH
45304: LD_EXP 66
45308: PUSH
45309: LD_VAR 0 7
45313: ARRAY
45314: PUSH
45315: LD_INT 1
45317: PLUS
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PPUSH
45323: LD_VAR 0 4
45327: PUSH
45328: LD_VAR 0 2
45332: PUSH
45333: LD_VAR 0 3
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: LIST
45342: PPUSH
45343: CALL 53792 0 3
45347: ST_TO_ADDR
// exit ;
45348: POP
45349: POP
45350: POP
45351: POP
45352: GO 45362
// end ;
45354: GO 45261
45356: POP
45357: POP
// end ;
45358: GO 45069
45360: POP
45361: POP
// end ;
45362: LD_VAR 0 6
45366: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45367: LD_INT 0
45369: PPUSH
45370: PPUSH
45371: PPUSH
45372: PPUSH
// if not mc_bases or not skirmish then
45373: LD_EXP 50
45377: NOT
45378: PUSH
45379: LD_EXP 48
45383: NOT
45384: OR
45385: IFFALSE 45389
// exit ;
45387: GO 45666
// side := GetSide ( lab ) ;
45389: LD_ADDR_VAR 0 4
45393: PUSH
45394: LD_VAR 0 2
45398: PPUSH
45399: CALL_OW 255
45403: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45404: LD_VAR 0 4
45408: PUSH
45409: LD_EXP 76
45413: IN
45414: NOT
45415: PUSH
45416: LD_EXP 77
45420: NOT
45421: OR
45422: PUSH
45423: LD_EXP 50
45427: NOT
45428: OR
45429: IFFALSE 45433
// exit ;
45431: GO 45666
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45433: LD_ADDR_EXP 77
45437: PUSH
45438: LD_EXP 77
45442: PPUSH
45443: LD_VAR 0 4
45447: PPUSH
45448: LD_EXP 77
45452: PUSH
45453: LD_VAR 0 4
45457: ARRAY
45458: PUSH
45459: LD_VAR 0 1
45463: DIFF
45464: PPUSH
45465: CALL_OW 1
45469: ST_TO_ADDR
// for i = 1 to mc_bases do
45470: LD_ADDR_VAR 0 5
45474: PUSH
45475: DOUBLE
45476: LD_INT 1
45478: DEC
45479: ST_TO_ADDR
45480: LD_EXP 50
45484: PUSH
45485: FOR_TO
45486: IFFALSE 45664
// begin if lab in mc_bases [ i ] then
45488: LD_VAR 0 2
45492: PUSH
45493: LD_EXP 50
45497: PUSH
45498: LD_VAR 0 5
45502: ARRAY
45503: IN
45504: IFFALSE 45662
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45506: LD_VAR 0 1
45510: PUSH
45511: LD_INT 11
45513: PUSH
45514: LD_INT 4
45516: PUSH
45517: LD_INT 3
45519: PUSH
45520: LD_INT 2
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: IN
45529: PUSH
45530: LD_EXP 80
45534: PUSH
45535: LD_VAR 0 5
45539: ARRAY
45540: AND
45541: IFFALSE 45662
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45543: LD_ADDR_VAR 0 6
45547: PUSH
45548: LD_EXP 80
45552: PUSH
45553: LD_VAR 0 5
45557: ARRAY
45558: PUSH
45559: LD_INT 1
45561: ARRAY
45562: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45563: LD_ADDR_EXP 80
45567: PUSH
45568: LD_EXP 80
45572: PPUSH
45573: LD_VAR 0 5
45577: PPUSH
45578: EMPTY
45579: PPUSH
45580: CALL_OW 1
45584: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45585: LD_VAR 0 6
45589: PPUSH
45590: LD_INT 0
45592: PPUSH
45593: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45597: LD_VAR 0 6
45601: PPUSH
45602: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45606: LD_ADDR_EXP 79
45610: PUSH
45611: LD_EXP 79
45615: PPUSH
45616: LD_VAR 0 5
45620: PPUSH
45621: LD_EXP 79
45625: PUSH
45626: LD_VAR 0 5
45630: ARRAY
45631: PPUSH
45632: LD_INT 1
45634: PPUSH
45635: LD_VAR 0 6
45639: PPUSH
45640: CALL_OW 2
45644: PPUSH
45645: CALL_OW 1
45649: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45650: LD_VAR 0 5
45654: PPUSH
45655: LD_INT 112
45657: PPUSH
45658: CALL 22152 0 2
// end ; end ; end ;
45662: GO 45485
45664: POP
45665: POP
// end ;
45666: LD_VAR 0 3
45670: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45671: LD_INT 0
45673: PPUSH
45674: PPUSH
45675: PPUSH
45676: PPUSH
45677: PPUSH
45678: PPUSH
45679: PPUSH
45680: PPUSH
// if not mc_bases or not skirmish then
45681: LD_EXP 50
45685: NOT
45686: PUSH
45687: LD_EXP 48
45691: NOT
45692: OR
45693: IFFALSE 45697
// exit ;
45695: GO 47066
// for i = 1 to mc_bases do
45697: LD_ADDR_VAR 0 3
45701: PUSH
45702: DOUBLE
45703: LD_INT 1
45705: DEC
45706: ST_TO_ADDR
45707: LD_EXP 50
45711: PUSH
45712: FOR_TO
45713: IFFALSE 47064
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45715: LD_VAR 0 1
45719: PUSH
45720: LD_EXP 50
45724: PUSH
45725: LD_VAR 0 3
45729: ARRAY
45730: IN
45731: PUSH
45732: LD_VAR 0 1
45736: PUSH
45737: LD_EXP 57
45741: PUSH
45742: LD_VAR 0 3
45746: ARRAY
45747: IN
45748: OR
45749: PUSH
45750: LD_VAR 0 1
45754: PUSH
45755: LD_EXP 72
45759: PUSH
45760: LD_VAR 0 3
45764: ARRAY
45765: IN
45766: OR
45767: PUSH
45768: LD_VAR 0 1
45772: PUSH
45773: LD_EXP 69
45777: PUSH
45778: LD_VAR 0 3
45782: ARRAY
45783: IN
45784: OR
45785: PUSH
45786: LD_VAR 0 1
45790: PUSH
45791: LD_EXP 79
45795: PUSH
45796: LD_VAR 0 3
45800: ARRAY
45801: IN
45802: OR
45803: PUSH
45804: LD_VAR 0 1
45808: PUSH
45809: LD_EXP 80
45813: PUSH
45814: LD_VAR 0 3
45818: ARRAY
45819: IN
45820: OR
45821: IFFALSE 47062
// begin if un in mc_ape [ i ] then
45823: LD_VAR 0 1
45827: PUSH
45828: LD_EXP 79
45832: PUSH
45833: LD_VAR 0 3
45837: ARRAY
45838: IN
45839: IFFALSE 45878
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45841: LD_ADDR_EXP 79
45845: PUSH
45846: LD_EXP 79
45850: PPUSH
45851: LD_VAR 0 3
45855: PPUSH
45856: LD_EXP 79
45860: PUSH
45861: LD_VAR 0 3
45865: ARRAY
45866: PUSH
45867: LD_VAR 0 1
45871: DIFF
45872: PPUSH
45873: CALL_OW 1
45877: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45878: LD_VAR 0 1
45882: PUSH
45883: LD_EXP 80
45887: PUSH
45888: LD_VAR 0 3
45892: ARRAY
45893: IN
45894: IFFALSE 45918
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45896: LD_ADDR_EXP 80
45900: PUSH
45901: LD_EXP 80
45905: PPUSH
45906: LD_VAR 0 3
45910: PPUSH
45911: EMPTY
45912: PPUSH
45913: CALL_OW 1
45917: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45918: LD_VAR 0 1
45922: PPUSH
45923: CALL_OW 247
45927: PUSH
45928: LD_INT 2
45930: EQUAL
45931: PUSH
45932: LD_VAR 0 1
45936: PPUSH
45937: CALL_OW 110
45941: PUSH
45942: LD_INT 20
45944: EQUAL
45945: PUSH
45946: LD_VAR 0 1
45950: PUSH
45951: LD_EXP 72
45955: PUSH
45956: LD_VAR 0 3
45960: ARRAY
45961: IN
45962: OR
45963: PUSH
45964: LD_VAR 0 1
45968: PPUSH
45969: CALL_OW 264
45973: PUSH
45974: LD_INT 12
45976: PUSH
45977: LD_INT 51
45979: PUSH
45980: LD_INT 89
45982: PUSH
45983: LD_INT 32
45985: PUSH
45986: LD_INT 13
45988: PUSH
45989: LD_INT 52
45991: PUSH
45992: LD_INT 31
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: IN
46004: OR
46005: AND
46006: IFFALSE 46314
// begin if un in mc_defender [ i ] then
46008: LD_VAR 0 1
46012: PUSH
46013: LD_EXP 72
46017: PUSH
46018: LD_VAR 0 3
46022: ARRAY
46023: IN
46024: IFFALSE 46063
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46026: LD_ADDR_EXP 72
46030: PUSH
46031: LD_EXP 72
46035: PPUSH
46036: LD_VAR 0 3
46040: PPUSH
46041: LD_EXP 72
46045: PUSH
46046: LD_VAR 0 3
46050: ARRAY
46051: PUSH
46052: LD_VAR 0 1
46056: DIFF
46057: PPUSH
46058: CALL_OW 1
46062: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46063: LD_ADDR_VAR 0 8
46067: PUSH
46068: LD_VAR 0 3
46072: PPUSH
46073: LD_INT 3
46075: PPUSH
46076: CALL 42722 0 2
46080: ST_TO_ADDR
// if fac then
46081: LD_VAR 0 8
46085: IFFALSE 46314
// begin for j in fac do
46087: LD_ADDR_VAR 0 4
46091: PUSH
46092: LD_VAR 0 8
46096: PUSH
46097: FOR_IN
46098: IFFALSE 46312
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46100: LD_ADDR_VAR 0 9
46104: PUSH
46105: LD_VAR 0 8
46109: PPUSH
46110: LD_VAR 0 1
46114: PPUSH
46115: CALL_OW 265
46119: PPUSH
46120: LD_VAR 0 1
46124: PPUSH
46125: CALL_OW 262
46129: PPUSH
46130: LD_VAR 0 1
46134: PPUSH
46135: CALL_OW 263
46139: PPUSH
46140: LD_VAR 0 1
46144: PPUSH
46145: CALL_OW 264
46149: PPUSH
46150: CALL 51290 0 5
46154: ST_TO_ADDR
// if components then
46155: LD_VAR 0 9
46159: IFFALSE 46310
// begin if GetWeapon ( un ) = ar_control_tower then
46161: LD_VAR 0 1
46165: PPUSH
46166: CALL_OW 264
46170: PUSH
46171: LD_INT 31
46173: EQUAL
46174: IFFALSE 46291
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46176: LD_VAR 0 1
46180: PPUSH
46181: CALL_OW 311
46185: PPUSH
46186: LD_INT 0
46188: PPUSH
46189: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46193: LD_ADDR_EXP 90
46197: PUSH
46198: LD_EXP 90
46202: PPUSH
46203: LD_VAR 0 3
46207: PPUSH
46208: LD_EXP 90
46212: PUSH
46213: LD_VAR 0 3
46217: ARRAY
46218: PUSH
46219: LD_VAR 0 1
46223: PPUSH
46224: CALL_OW 311
46228: DIFF
46229: PPUSH
46230: CALL_OW 1
46234: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46235: LD_ADDR_VAR 0 7
46239: PUSH
46240: LD_EXP 71
46244: PUSH
46245: LD_VAR 0 3
46249: ARRAY
46250: PPUSH
46251: LD_INT 1
46253: PPUSH
46254: LD_VAR 0 9
46258: PPUSH
46259: CALL_OW 2
46263: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46264: LD_ADDR_EXP 71
46268: PUSH
46269: LD_EXP 71
46273: PPUSH
46274: LD_VAR 0 3
46278: PPUSH
46279: LD_VAR 0 7
46283: PPUSH
46284: CALL_OW 1
46288: ST_TO_ADDR
// end else
46289: GO 46308
// MC_InsertProduceList ( i , [ components ] ) ;
46291: LD_VAR 0 3
46295: PPUSH
46296: LD_VAR 0 9
46300: PUSH
46301: EMPTY
46302: LIST
46303: PPUSH
46304: CALL 42267 0 2
// break ;
46308: GO 46312
// end ; end ;
46310: GO 46097
46312: POP
46313: POP
// end ; end ; if GetType ( un ) = unit_building then
46314: LD_VAR 0 1
46318: PPUSH
46319: CALL_OW 247
46323: PUSH
46324: LD_INT 3
46326: EQUAL
46327: IFFALSE 46730
// begin btype := GetBType ( un ) ;
46329: LD_ADDR_VAR 0 5
46333: PUSH
46334: LD_VAR 0 1
46338: PPUSH
46339: CALL_OW 266
46343: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46344: LD_VAR 0 5
46348: PUSH
46349: LD_INT 29
46351: PUSH
46352: LD_INT 30
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: IN
46359: IFFALSE 46432
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46361: LD_VAR 0 1
46365: PPUSH
46366: CALL_OW 250
46370: PPUSH
46371: LD_VAR 0 1
46375: PPUSH
46376: CALL_OW 251
46380: PPUSH
46381: LD_VAR 0 1
46385: PPUSH
46386: CALL_OW 255
46390: PPUSH
46391: CALL_OW 440
46395: NOT
46396: IFFALSE 46432
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46398: LD_VAR 0 1
46402: PPUSH
46403: CALL_OW 250
46407: PPUSH
46408: LD_VAR 0 1
46412: PPUSH
46413: CALL_OW 251
46417: PPUSH
46418: LD_VAR 0 1
46422: PPUSH
46423: CALL_OW 255
46427: PPUSH
46428: CALL_OW 441
// end ; if btype = b_warehouse then
46432: LD_VAR 0 5
46436: PUSH
46437: LD_INT 1
46439: EQUAL
46440: IFFALSE 46458
// begin btype := b_depot ;
46442: LD_ADDR_VAR 0 5
46446: PUSH
46447: LD_INT 0
46449: ST_TO_ADDR
// pos := 1 ;
46450: LD_ADDR_VAR 0 6
46454: PUSH
46455: LD_INT 1
46457: ST_TO_ADDR
// end ; if btype = b_factory then
46458: LD_VAR 0 5
46462: PUSH
46463: LD_INT 3
46465: EQUAL
46466: IFFALSE 46484
// begin btype := b_workshop ;
46468: LD_ADDR_VAR 0 5
46472: PUSH
46473: LD_INT 2
46475: ST_TO_ADDR
// pos := 1 ;
46476: LD_ADDR_VAR 0 6
46480: PUSH
46481: LD_INT 1
46483: ST_TO_ADDR
// end ; if btype = b_barracks then
46484: LD_VAR 0 5
46488: PUSH
46489: LD_INT 5
46491: EQUAL
46492: IFFALSE 46502
// btype := b_armoury ;
46494: LD_ADDR_VAR 0 5
46498: PUSH
46499: LD_INT 4
46501: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46502: LD_VAR 0 5
46506: PUSH
46507: LD_INT 7
46509: PUSH
46510: LD_INT 8
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: IN
46517: IFFALSE 46527
// btype := b_lab ;
46519: LD_ADDR_VAR 0 5
46523: PUSH
46524: LD_INT 6
46526: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46527: LD_ADDR_EXP 55
46531: PUSH
46532: LD_EXP 55
46536: PPUSH
46537: LD_VAR 0 3
46541: PUSH
46542: LD_EXP 55
46546: PUSH
46547: LD_VAR 0 3
46551: ARRAY
46552: PUSH
46553: LD_INT 1
46555: PLUS
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PPUSH
46561: LD_VAR 0 5
46565: PUSH
46566: LD_VAR 0 1
46570: PPUSH
46571: CALL_OW 250
46575: PUSH
46576: LD_VAR 0 1
46580: PPUSH
46581: CALL_OW 251
46585: PUSH
46586: LD_VAR 0 1
46590: PPUSH
46591: CALL_OW 254
46595: PUSH
46596: EMPTY
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: PPUSH
46602: CALL 53792 0 3
46606: ST_TO_ADDR
// if pos = 1 then
46607: LD_VAR 0 6
46611: PUSH
46612: LD_INT 1
46614: EQUAL
46615: IFFALSE 46730
// begin tmp := mc_build_list [ i ] ;
46617: LD_ADDR_VAR 0 7
46621: PUSH
46622: LD_EXP 55
46626: PUSH
46627: LD_VAR 0 3
46631: ARRAY
46632: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46633: LD_VAR 0 7
46637: PPUSH
46638: LD_INT 2
46640: PUSH
46641: LD_INT 30
46643: PUSH
46644: LD_INT 0
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 30
46653: PUSH
46654: LD_INT 1
46656: PUSH
46657: EMPTY
46658: LIST
46659: LIST
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: LIST
46665: PPUSH
46666: CALL_OW 72
46670: IFFALSE 46680
// pos := 2 ;
46672: LD_ADDR_VAR 0 6
46676: PUSH
46677: LD_INT 2
46679: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46680: LD_ADDR_VAR 0 7
46684: PUSH
46685: LD_VAR 0 7
46689: PPUSH
46690: LD_VAR 0 6
46694: PPUSH
46695: LD_VAR 0 7
46699: PPUSH
46700: CALL 54118 0 3
46704: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46705: LD_ADDR_EXP 55
46709: PUSH
46710: LD_EXP 55
46714: PPUSH
46715: LD_VAR 0 3
46719: PPUSH
46720: LD_VAR 0 7
46724: PPUSH
46725: CALL_OW 1
46729: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46730: LD_VAR 0 1
46734: PUSH
46735: LD_EXP 50
46739: PUSH
46740: LD_VAR 0 3
46744: ARRAY
46745: IN
46746: IFFALSE 46785
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46748: LD_ADDR_EXP 50
46752: PUSH
46753: LD_EXP 50
46757: PPUSH
46758: LD_VAR 0 3
46762: PPUSH
46763: LD_EXP 50
46767: PUSH
46768: LD_VAR 0 3
46772: ARRAY
46773: PUSH
46774: LD_VAR 0 1
46778: DIFF
46779: PPUSH
46780: CALL_OW 1
46784: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46785: LD_VAR 0 1
46789: PUSH
46790: LD_EXP 57
46794: PUSH
46795: LD_VAR 0 3
46799: ARRAY
46800: IN
46801: IFFALSE 46840
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46803: LD_ADDR_EXP 57
46807: PUSH
46808: LD_EXP 57
46812: PPUSH
46813: LD_VAR 0 3
46817: PPUSH
46818: LD_EXP 57
46822: PUSH
46823: LD_VAR 0 3
46827: ARRAY
46828: PUSH
46829: LD_VAR 0 1
46833: DIFF
46834: PPUSH
46835: CALL_OW 1
46839: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46840: LD_VAR 0 1
46844: PUSH
46845: LD_EXP 69
46849: PUSH
46850: LD_VAR 0 3
46854: ARRAY
46855: IN
46856: IFFALSE 46895
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46858: LD_ADDR_EXP 69
46862: PUSH
46863: LD_EXP 69
46867: PPUSH
46868: LD_VAR 0 3
46872: PPUSH
46873: LD_EXP 69
46877: PUSH
46878: LD_VAR 0 3
46882: ARRAY
46883: PUSH
46884: LD_VAR 0 1
46888: DIFF
46889: PPUSH
46890: CALL_OW 1
46894: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46895: LD_VAR 0 1
46899: PUSH
46900: LD_EXP 72
46904: PUSH
46905: LD_VAR 0 3
46909: ARRAY
46910: IN
46911: IFFALSE 46950
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46913: LD_ADDR_EXP 72
46917: PUSH
46918: LD_EXP 72
46922: PPUSH
46923: LD_VAR 0 3
46927: PPUSH
46928: LD_EXP 72
46932: PUSH
46933: LD_VAR 0 3
46937: ARRAY
46938: PUSH
46939: LD_VAR 0 1
46943: DIFF
46944: PPUSH
46945: CALL_OW 1
46949: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46950: LD_VAR 0 1
46954: PUSH
46955: LD_EXP 59
46959: PUSH
46960: LD_VAR 0 3
46964: ARRAY
46965: IN
46966: IFFALSE 47005
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46968: LD_ADDR_EXP 59
46972: PUSH
46973: LD_EXP 59
46977: PPUSH
46978: LD_VAR 0 3
46982: PPUSH
46983: LD_EXP 59
46987: PUSH
46988: LD_VAR 0 3
46992: ARRAY
46993: PUSH
46994: LD_VAR 0 1
46998: DIFF
46999: PPUSH
47000: CALL_OW 1
47004: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47005: LD_VAR 0 1
47009: PUSH
47010: LD_EXP 58
47014: PUSH
47015: LD_VAR 0 3
47019: ARRAY
47020: IN
47021: IFFALSE 47060
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47023: LD_ADDR_EXP 58
47027: PUSH
47028: LD_EXP 58
47032: PPUSH
47033: LD_VAR 0 3
47037: PPUSH
47038: LD_EXP 58
47042: PUSH
47043: LD_VAR 0 3
47047: ARRAY
47048: PUSH
47049: LD_VAR 0 1
47053: DIFF
47054: PPUSH
47055: CALL_OW 1
47059: ST_TO_ADDR
// end ; break ;
47060: GO 47064
// end ;
47062: GO 45712
47064: POP
47065: POP
// end ;
47066: LD_VAR 0 2
47070: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47071: LD_INT 0
47073: PPUSH
47074: PPUSH
47075: PPUSH
// if not mc_bases or not skirmish then
47076: LD_EXP 50
47080: NOT
47081: PUSH
47082: LD_EXP 48
47086: NOT
47087: OR
47088: IFFALSE 47092
// exit ;
47090: GO 47307
// for i = 1 to mc_bases do
47092: LD_ADDR_VAR 0 3
47096: PUSH
47097: DOUBLE
47098: LD_INT 1
47100: DEC
47101: ST_TO_ADDR
47102: LD_EXP 50
47106: PUSH
47107: FOR_TO
47108: IFFALSE 47305
// begin if building in mc_construct_list [ i ] then
47110: LD_VAR 0 1
47114: PUSH
47115: LD_EXP 57
47119: PUSH
47120: LD_VAR 0 3
47124: ARRAY
47125: IN
47126: IFFALSE 47303
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47128: LD_ADDR_EXP 57
47132: PUSH
47133: LD_EXP 57
47137: PPUSH
47138: LD_VAR 0 3
47142: PPUSH
47143: LD_EXP 57
47147: PUSH
47148: LD_VAR 0 3
47152: ARRAY
47153: PUSH
47154: LD_VAR 0 1
47158: DIFF
47159: PPUSH
47160: CALL_OW 1
47164: ST_TO_ADDR
// if building in mc_lab [ i ] then
47165: LD_VAR 0 1
47169: PUSH
47170: LD_EXP 83
47174: PUSH
47175: LD_VAR 0 3
47179: ARRAY
47180: IN
47181: IFFALSE 47236
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47183: LD_ADDR_EXP 84
47187: PUSH
47188: LD_EXP 84
47192: PPUSH
47193: LD_VAR 0 3
47197: PPUSH
47198: LD_EXP 84
47202: PUSH
47203: LD_VAR 0 3
47207: ARRAY
47208: PPUSH
47209: LD_INT 1
47211: PPUSH
47212: LD_EXP 84
47216: PUSH
47217: LD_VAR 0 3
47221: ARRAY
47222: PPUSH
47223: LD_INT 0
47225: PPUSH
47226: CALL 53210 0 4
47230: PPUSH
47231: CALL_OW 1
47235: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47236: LD_VAR 0 1
47240: PUSH
47241: LD_EXP 50
47245: PUSH
47246: LD_VAR 0 3
47250: ARRAY
47251: IN
47252: NOT
47253: IFFALSE 47299
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47255: LD_ADDR_EXP 50
47259: PUSH
47260: LD_EXP 50
47264: PPUSH
47265: LD_VAR 0 3
47269: PUSH
47270: LD_EXP 50
47274: PUSH
47275: LD_VAR 0 3
47279: ARRAY
47280: PUSH
47281: LD_INT 1
47283: PLUS
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PPUSH
47289: LD_VAR 0 1
47293: PPUSH
47294: CALL 53792 0 3
47298: ST_TO_ADDR
// exit ;
47299: POP
47300: POP
47301: GO 47307
// end ; end ;
47303: GO 47107
47305: POP
47306: POP
// end ;
47307: LD_VAR 0 2
47311: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47312: LD_INT 0
47314: PPUSH
47315: PPUSH
47316: PPUSH
47317: PPUSH
47318: PPUSH
47319: PPUSH
47320: PPUSH
// if not mc_bases or not skirmish then
47321: LD_EXP 50
47325: NOT
47326: PUSH
47327: LD_EXP 48
47331: NOT
47332: OR
47333: IFFALSE 47337
// exit ;
47335: GO 47998
// for i = 1 to mc_bases do
47337: LD_ADDR_VAR 0 3
47341: PUSH
47342: DOUBLE
47343: LD_INT 1
47345: DEC
47346: ST_TO_ADDR
47347: LD_EXP 50
47351: PUSH
47352: FOR_TO
47353: IFFALSE 47996
// begin if building in mc_construct_list [ i ] then
47355: LD_VAR 0 1
47359: PUSH
47360: LD_EXP 57
47364: PUSH
47365: LD_VAR 0 3
47369: ARRAY
47370: IN
47371: IFFALSE 47994
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47373: LD_ADDR_EXP 57
47377: PUSH
47378: LD_EXP 57
47382: PPUSH
47383: LD_VAR 0 3
47387: PPUSH
47388: LD_EXP 57
47392: PUSH
47393: LD_VAR 0 3
47397: ARRAY
47398: PUSH
47399: LD_VAR 0 1
47403: DIFF
47404: PPUSH
47405: CALL_OW 1
47409: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47410: LD_ADDR_EXP 50
47414: PUSH
47415: LD_EXP 50
47419: PPUSH
47420: LD_VAR 0 3
47424: PUSH
47425: LD_EXP 50
47429: PUSH
47430: LD_VAR 0 3
47434: ARRAY
47435: PUSH
47436: LD_INT 1
47438: PLUS
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PPUSH
47444: LD_VAR 0 1
47448: PPUSH
47449: CALL 53792 0 3
47453: ST_TO_ADDR
// btype := GetBType ( building ) ;
47454: LD_ADDR_VAR 0 5
47458: PUSH
47459: LD_VAR 0 1
47463: PPUSH
47464: CALL_OW 266
47468: ST_TO_ADDR
// side := GetSide ( building ) ;
47469: LD_ADDR_VAR 0 8
47473: PUSH
47474: LD_VAR 0 1
47478: PPUSH
47479: CALL_OW 255
47483: ST_TO_ADDR
// if btype = b_lab then
47484: LD_VAR 0 5
47488: PUSH
47489: LD_INT 6
47491: EQUAL
47492: IFFALSE 47542
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47494: LD_ADDR_EXP 83
47498: PUSH
47499: LD_EXP 83
47503: PPUSH
47504: LD_VAR 0 3
47508: PUSH
47509: LD_EXP 83
47513: PUSH
47514: LD_VAR 0 3
47518: ARRAY
47519: PUSH
47520: LD_INT 1
47522: PLUS
47523: PUSH
47524: EMPTY
47525: LIST
47526: LIST
47527: PPUSH
47528: LD_VAR 0 1
47532: PPUSH
47533: CALL 53792 0 3
47537: ST_TO_ADDR
// exit ;
47538: POP
47539: POP
47540: GO 47998
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47542: LD_VAR 0 5
47546: PUSH
47547: LD_INT 0
47549: PUSH
47550: LD_INT 2
47552: PUSH
47553: LD_INT 4
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: LIST
47560: IN
47561: IFFALSE 47685
// begin if btype = b_armoury then
47563: LD_VAR 0 5
47567: PUSH
47568: LD_INT 4
47570: EQUAL
47571: IFFALSE 47581
// btype := b_barracks ;
47573: LD_ADDR_VAR 0 5
47577: PUSH
47578: LD_INT 5
47580: ST_TO_ADDR
// if btype = b_depot then
47581: LD_VAR 0 5
47585: PUSH
47586: LD_INT 0
47588: EQUAL
47589: IFFALSE 47599
// btype := b_warehouse ;
47591: LD_ADDR_VAR 0 5
47595: PUSH
47596: LD_INT 1
47598: ST_TO_ADDR
// if btype = b_workshop then
47599: LD_VAR 0 5
47603: PUSH
47604: LD_INT 2
47606: EQUAL
47607: IFFALSE 47617
// btype := b_factory ;
47609: LD_ADDR_VAR 0 5
47613: PUSH
47614: LD_INT 3
47616: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47617: LD_VAR 0 5
47621: PPUSH
47622: LD_VAR 0 8
47626: PPUSH
47627: CALL_OW 323
47631: PUSH
47632: LD_INT 1
47634: EQUAL
47635: IFFALSE 47681
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47637: LD_ADDR_EXP 82
47641: PUSH
47642: LD_EXP 82
47646: PPUSH
47647: LD_VAR 0 3
47651: PUSH
47652: LD_EXP 82
47656: PUSH
47657: LD_VAR 0 3
47661: ARRAY
47662: PUSH
47663: LD_INT 1
47665: PLUS
47666: PUSH
47667: EMPTY
47668: LIST
47669: LIST
47670: PPUSH
47671: LD_VAR 0 1
47675: PPUSH
47676: CALL 53792 0 3
47680: ST_TO_ADDR
// exit ;
47681: POP
47682: POP
47683: GO 47998
// end ; if btype in [ b_bunker , b_turret ] then
47685: LD_VAR 0 5
47689: PUSH
47690: LD_INT 32
47692: PUSH
47693: LD_INT 33
47695: PUSH
47696: EMPTY
47697: LIST
47698: LIST
47699: IN
47700: IFFALSE 47990
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47702: LD_ADDR_EXP 58
47706: PUSH
47707: LD_EXP 58
47711: PPUSH
47712: LD_VAR 0 3
47716: PUSH
47717: LD_EXP 58
47721: PUSH
47722: LD_VAR 0 3
47726: ARRAY
47727: PUSH
47728: LD_INT 1
47730: PLUS
47731: PUSH
47732: EMPTY
47733: LIST
47734: LIST
47735: PPUSH
47736: LD_VAR 0 1
47740: PPUSH
47741: CALL 53792 0 3
47745: ST_TO_ADDR
// if btype = b_bunker then
47746: LD_VAR 0 5
47750: PUSH
47751: LD_INT 32
47753: EQUAL
47754: IFFALSE 47990
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47756: LD_ADDR_EXP 59
47760: PUSH
47761: LD_EXP 59
47765: PPUSH
47766: LD_VAR 0 3
47770: PUSH
47771: LD_EXP 59
47775: PUSH
47776: LD_VAR 0 3
47780: ARRAY
47781: PUSH
47782: LD_INT 1
47784: PLUS
47785: PUSH
47786: EMPTY
47787: LIST
47788: LIST
47789: PPUSH
47790: LD_VAR 0 1
47794: PPUSH
47795: CALL 53792 0 3
47799: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47800: LD_ADDR_VAR 0 6
47804: PUSH
47805: LD_EXP 50
47809: PUSH
47810: LD_VAR 0 3
47814: ARRAY
47815: PPUSH
47816: LD_INT 25
47818: PUSH
47819: LD_INT 1
47821: PUSH
47822: EMPTY
47823: LIST
47824: LIST
47825: PUSH
47826: LD_INT 3
47828: PUSH
47829: LD_INT 54
47831: PUSH
47832: EMPTY
47833: LIST
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: PUSH
47839: EMPTY
47840: LIST
47841: LIST
47842: PPUSH
47843: CALL_OW 72
47847: ST_TO_ADDR
// if tmp then
47848: LD_VAR 0 6
47852: IFFALSE 47858
// exit ;
47854: POP
47855: POP
47856: GO 47998
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47858: LD_ADDR_VAR 0 6
47862: PUSH
47863: LD_EXP 50
47867: PUSH
47868: LD_VAR 0 3
47872: ARRAY
47873: PPUSH
47874: LD_INT 2
47876: PUSH
47877: LD_INT 30
47879: PUSH
47880: LD_INT 4
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: LD_INT 30
47889: PUSH
47890: LD_INT 5
47892: PUSH
47893: EMPTY
47894: LIST
47895: LIST
47896: PUSH
47897: EMPTY
47898: LIST
47899: LIST
47900: LIST
47901: PPUSH
47902: CALL_OW 72
47906: ST_TO_ADDR
// if not tmp then
47907: LD_VAR 0 6
47911: NOT
47912: IFFALSE 47918
// exit ;
47914: POP
47915: POP
47916: GO 47998
// for j in tmp do
47918: LD_ADDR_VAR 0 4
47922: PUSH
47923: LD_VAR 0 6
47927: PUSH
47928: FOR_IN
47929: IFFALSE 47988
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47931: LD_ADDR_VAR 0 7
47935: PUSH
47936: LD_VAR 0 4
47940: PPUSH
47941: CALL_OW 313
47945: PPUSH
47946: LD_INT 25
47948: PUSH
47949: LD_INT 1
47951: PUSH
47952: EMPTY
47953: LIST
47954: LIST
47955: PPUSH
47956: CALL_OW 72
47960: ST_TO_ADDR
// if units then
47961: LD_VAR 0 7
47965: IFFALSE 47986
// begin ComExitBuilding ( units [ 1 ] ) ;
47967: LD_VAR 0 7
47971: PUSH
47972: LD_INT 1
47974: ARRAY
47975: PPUSH
47976: CALL_OW 122
// exit ;
47980: POP
47981: POP
47982: POP
47983: POP
47984: GO 47998
// end ; end ;
47986: GO 47928
47988: POP
47989: POP
// end ; end ; exit ;
47990: POP
47991: POP
47992: GO 47998
// end ; end ;
47994: GO 47352
47996: POP
47997: POP
// end ;
47998: LD_VAR 0 2
48002: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48003: LD_INT 0
48005: PPUSH
48006: PPUSH
48007: PPUSH
48008: PPUSH
48009: PPUSH
48010: PPUSH
48011: PPUSH
// if not mc_bases or not skirmish then
48012: LD_EXP 50
48016: NOT
48017: PUSH
48018: LD_EXP 48
48022: NOT
48023: OR
48024: IFFALSE 48028
// exit ;
48026: GO 48293
// btype := GetBType ( building ) ;
48028: LD_ADDR_VAR 0 6
48032: PUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: CALL_OW 266
48042: ST_TO_ADDR
// x := GetX ( building ) ;
48043: LD_ADDR_VAR 0 7
48047: PUSH
48048: LD_VAR 0 1
48052: PPUSH
48053: CALL_OW 250
48057: ST_TO_ADDR
// y := GetY ( building ) ;
48058: LD_ADDR_VAR 0 8
48062: PUSH
48063: LD_VAR 0 1
48067: PPUSH
48068: CALL_OW 251
48072: ST_TO_ADDR
// d := GetDir ( building ) ;
48073: LD_ADDR_VAR 0 9
48077: PUSH
48078: LD_VAR 0 1
48082: PPUSH
48083: CALL_OW 254
48087: ST_TO_ADDR
// for i = 1 to mc_bases do
48088: LD_ADDR_VAR 0 4
48092: PUSH
48093: DOUBLE
48094: LD_INT 1
48096: DEC
48097: ST_TO_ADDR
48098: LD_EXP 50
48102: PUSH
48103: FOR_TO
48104: IFFALSE 48291
// begin if not mc_build_list [ i ] then
48106: LD_EXP 55
48110: PUSH
48111: LD_VAR 0 4
48115: ARRAY
48116: NOT
48117: IFFALSE 48121
// continue ;
48119: GO 48103
// for j := 1 to mc_build_list [ i ] do
48121: LD_ADDR_VAR 0 5
48125: PUSH
48126: DOUBLE
48127: LD_INT 1
48129: DEC
48130: ST_TO_ADDR
48131: LD_EXP 55
48135: PUSH
48136: LD_VAR 0 4
48140: ARRAY
48141: PUSH
48142: FOR_TO
48143: IFFALSE 48287
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48145: LD_VAR 0 6
48149: PUSH
48150: LD_VAR 0 7
48154: PUSH
48155: LD_VAR 0 8
48159: PUSH
48160: LD_VAR 0 9
48164: PUSH
48165: EMPTY
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: PPUSH
48171: LD_EXP 55
48175: PUSH
48176: LD_VAR 0 4
48180: ARRAY
48181: PUSH
48182: LD_VAR 0 5
48186: ARRAY
48187: PPUSH
48188: CALL 59972 0 2
48192: IFFALSE 48285
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48194: LD_ADDR_EXP 55
48198: PUSH
48199: LD_EXP 55
48203: PPUSH
48204: LD_VAR 0 4
48208: PPUSH
48209: LD_EXP 55
48213: PUSH
48214: LD_VAR 0 4
48218: ARRAY
48219: PPUSH
48220: LD_VAR 0 5
48224: PPUSH
48225: CALL_OW 3
48229: PPUSH
48230: CALL_OW 1
48234: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48235: LD_ADDR_EXP 57
48239: PUSH
48240: LD_EXP 57
48244: PPUSH
48245: LD_VAR 0 4
48249: PUSH
48250: LD_EXP 57
48254: PUSH
48255: LD_VAR 0 4
48259: ARRAY
48260: PUSH
48261: LD_INT 1
48263: PLUS
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: PPUSH
48269: LD_VAR 0 1
48273: PPUSH
48274: CALL 53792 0 3
48278: ST_TO_ADDR
// exit ;
48279: POP
48280: POP
48281: POP
48282: POP
48283: GO 48293
// end ;
48285: GO 48142
48287: POP
48288: POP
// end ;
48289: GO 48103
48291: POP
48292: POP
// end ;
48293: LD_VAR 0 3
48297: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48298: LD_INT 0
48300: PPUSH
48301: PPUSH
48302: PPUSH
// if not mc_bases or not skirmish then
48303: LD_EXP 50
48307: NOT
48308: PUSH
48309: LD_EXP 48
48313: NOT
48314: OR
48315: IFFALSE 48319
// exit ;
48317: GO 48509
// for i = 1 to mc_bases do
48319: LD_ADDR_VAR 0 4
48323: PUSH
48324: DOUBLE
48325: LD_INT 1
48327: DEC
48328: ST_TO_ADDR
48329: LD_EXP 50
48333: PUSH
48334: FOR_TO
48335: IFFALSE 48422
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48337: LD_VAR 0 1
48341: PUSH
48342: LD_EXP 58
48346: PUSH
48347: LD_VAR 0 4
48351: ARRAY
48352: IN
48353: PUSH
48354: LD_VAR 0 1
48358: PUSH
48359: LD_EXP 59
48363: PUSH
48364: LD_VAR 0 4
48368: ARRAY
48369: IN
48370: NOT
48371: AND
48372: IFFALSE 48420
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48374: LD_ADDR_EXP 59
48378: PUSH
48379: LD_EXP 59
48383: PPUSH
48384: LD_VAR 0 4
48388: PUSH
48389: LD_EXP 59
48393: PUSH
48394: LD_VAR 0 4
48398: ARRAY
48399: PUSH
48400: LD_INT 1
48402: PLUS
48403: PUSH
48404: EMPTY
48405: LIST
48406: LIST
48407: PPUSH
48408: LD_VAR 0 1
48412: PPUSH
48413: CALL 53792 0 3
48417: ST_TO_ADDR
// break ;
48418: GO 48422
// end ; end ;
48420: GO 48334
48422: POP
48423: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48424: LD_VAR 0 1
48428: PPUSH
48429: CALL_OW 257
48433: PUSH
48434: LD_EXP 76
48438: IN
48439: PUSH
48440: LD_VAR 0 1
48444: PPUSH
48445: CALL_OW 266
48449: PUSH
48450: LD_INT 5
48452: EQUAL
48453: AND
48454: PUSH
48455: LD_VAR 0 2
48459: PPUSH
48460: CALL_OW 110
48464: PUSH
48465: LD_INT 18
48467: NONEQUAL
48468: AND
48469: IFFALSE 48509
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48471: LD_VAR 0 2
48475: PPUSH
48476: CALL_OW 257
48480: PUSH
48481: LD_INT 5
48483: PUSH
48484: LD_INT 8
48486: PUSH
48487: LD_INT 9
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: LIST
48494: IN
48495: IFFALSE 48509
// SetClass ( unit , 1 ) ;
48497: LD_VAR 0 2
48501: PPUSH
48502: LD_INT 1
48504: PPUSH
48505: CALL_OW 336
// end ;
48509: LD_VAR 0 3
48513: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48514: LD_INT 0
48516: PPUSH
48517: PPUSH
// if not mc_bases or not skirmish then
48518: LD_EXP 50
48522: NOT
48523: PUSH
48524: LD_EXP 48
48528: NOT
48529: OR
48530: IFFALSE 48534
// exit ;
48532: GO 48650
// if GetLives ( abandoned_vehicle ) > 250 then
48534: LD_VAR 0 2
48538: PPUSH
48539: CALL_OW 256
48543: PUSH
48544: LD_INT 250
48546: GREATER
48547: IFFALSE 48551
// exit ;
48549: GO 48650
// for i = 1 to mc_bases do
48551: LD_ADDR_VAR 0 6
48555: PUSH
48556: DOUBLE
48557: LD_INT 1
48559: DEC
48560: ST_TO_ADDR
48561: LD_EXP 50
48565: PUSH
48566: FOR_TO
48567: IFFALSE 48648
// begin if driver in mc_bases [ i ] then
48569: LD_VAR 0 1
48573: PUSH
48574: LD_EXP 50
48578: PUSH
48579: LD_VAR 0 6
48583: ARRAY
48584: IN
48585: IFFALSE 48646
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48587: LD_VAR 0 1
48591: PPUSH
48592: LD_EXP 50
48596: PUSH
48597: LD_VAR 0 6
48601: ARRAY
48602: PPUSH
48603: LD_INT 2
48605: PUSH
48606: LD_INT 30
48608: PUSH
48609: LD_INT 0
48611: PUSH
48612: EMPTY
48613: LIST
48614: LIST
48615: PUSH
48616: LD_INT 30
48618: PUSH
48619: LD_INT 1
48621: PUSH
48622: EMPTY
48623: LIST
48624: LIST
48625: PUSH
48626: EMPTY
48627: LIST
48628: LIST
48629: LIST
48630: PPUSH
48631: CALL_OW 72
48635: PUSH
48636: LD_INT 1
48638: ARRAY
48639: PPUSH
48640: CALL 86981 0 2
// break ;
48644: GO 48648
// end ; end ;
48646: GO 48566
48648: POP
48649: POP
// end ; end_of_file
48650: LD_VAR 0 5
48654: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48655: LD_INT 0
48657: PPUSH
48658: PPUSH
// if exist_mode then
48659: LD_VAR 0 2
48663: IFFALSE 48688
// unit := CreateCharacter ( prefix & ident ) else
48665: LD_ADDR_VAR 0 5
48669: PUSH
48670: LD_VAR 0 3
48674: PUSH
48675: LD_VAR 0 1
48679: STR
48680: PPUSH
48681: CALL_OW 34
48685: ST_TO_ADDR
48686: GO 48703
// unit := NewCharacter ( ident ) ;
48688: LD_ADDR_VAR 0 5
48692: PUSH
48693: LD_VAR 0 1
48697: PPUSH
48698: CALL_OW 25
48702: ST_TO_ADDR
// result := unit ;
48703: LD_ADDR_VAR 0 4
48707: PUSH
48708: LD_VAR 0 5
48712: ST_TO_ADDR
// end ;
48713: LD_VAR 0 4
48717: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48718: LD_INT 0
48720: PPUSH
48721: PPUSH
// if not side or not nation then
48722: LD_VAR 0 1
48726: NOT
48727: PUSH
48728: LD_VAR 0 2
48732: NOT
48733: OR
48734: IFFALSE 48738
// exit ;
48736: GO 49506
// case nation of nation_american :
48738: LD_VAR 0 2
48742: PUSH
48743: LD_INT 1
48745: DOUBLE
48746: EQUAL
48747: IFTRUE 48751
48749: GO 48965
48751: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48752: LD_ADDR_VAR 0 4
48756: PUSH
48757: LD_INT 35
48759: PUSH
48760: LD_INT 45
48762: PUSH
48763: LD_INT 46
48765: PUSH
48766: LD_INT 47
48768: PUSH
48769: LD_INT 82
48771: PUSH
48772: LD_INT 83
48774: PUSH
48775: LD_INT 84
48777: PUSH
48778: LD_INT 85
48780: PUSH
48781: LD_INT 86
48783: PUSH
48784: LD_INT 1
48786: PUSH
48787: LD_INT 2
48789: PUSH
48790: LD_INT 6
48792: PUSH
48793: LD_INT 15
48795: PUSH
48796: LD_INT 16
48798: PUSH
48799: LD_INT 7
48801: PUSH
48802: LD_INT 12
48804: PUSH
48805: LD_INT 13
48807: PUSH
48808: LD_INT 10
48810: PUSH
48811: LD_INT 14
48813: PUSH
48814: LD_INT 20
48816: PUSH
48817: LD_INT 21
48819: PUSH
48820: LD_INT 22
48822: PUSH
48823: LD_INT 25
48825: PUSH
48826: LD_INT 32
48828: PUSH
48829: LD_INT 27
48831: PUSH
48832: LD_INT 36
48834: PUSH
48835: LD_INT 69
48837: PUSH
48838: LD_INT 39
48840: PUSH
48841: LD_INT 34
48843: PUSH
48844: LD_INT 40
48846: PUSH
48847: LD_INT 48
48849: PUSH
48850: LD_INT 49
48852: PUSH
48853: LD_INT 50
48855: PUSH
48856: LD_INT 51
48858: PUSH
48859: LD_INT 52
48861: PUSH
48862: LD_INT 53
48864: PUSH
48865: LD_INT 54
48867: PUSH
48868: LD_INT 55
48870: PUSH
48871: LD_INT 56
48873: PUSH
48874: LD_INT 57
48876: PUSH
48877: LD_INT 58
48879: PUSH
48880: LD_INT 59
48882: PUSH
48883: LD_INT 60
48885: PUSH
48886: LD_INT 61
48888: PUSH
48889: LD_INT 62
48891: PUSH
48892: LD_INT 80
48894: PUSH
48895: LD_INT 82
48897: PUSH
48898: LD_INT 83
48900: PUSH
48901: LD_INT 84
48903: PUSH
48904: LD_INT 85
48906: PUSH
48907: LD_INT 86
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: LIST
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: LIST
48960: LIST
48961: LIST
48962: ST_TO_ADDR
48963: GO 49430
48965: LD_INT 2
48967: DOUBLE
48968: EQUAL
48969: IFTRUE 48973
48971: GO 49199
48973: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48974: LD_ADDR_VAR 0 4
48978: PUSH
48979: LD_INT 35
48981: PUSH
48982: LD_INT 45
48984: PUSH
48985: LD_INT 46
48987: PUSH
48988: LD_INT 47
48990: PUSH
48991: LD_INT 82
48993: PUSH
48994: LD_INT 83
48996: PUSH
48997: LD_INT 84
48999: PUSH
49000: LD_INT 85
49002: PUSH
49003: LD_INT 87
49005: PUSH
49006: LD_INT 70
49008: PUSH
49009: LD_INT 1
49011: PUSH
49012: LD_INT 11
49014: PUSH
49015: LD_INT 3
49017: PUSH
49018: LD_INT 4
49020: PUSH
49021: LD_INT 5
49023: PUSH
49024: LD_INT 6
49026: PUSH
49027: LD_INT 15
49029: PUSH
49030: LD_INT 18
49032: PUSH
49033: LD_INT 7
49035: PUSH
49036: LD_INT 17
49038: PUSH
49039: LD_INT 8
49041: PUSH
49042: LD_INT 20
49044: PUSH
49045: LD_INT 21
49047: PUSH
49048: LD_INT 22
49050: PUSH
49051: LD_INT 72
49053: PUSH
49054: LD_INT 26
49056: PUSH
49057: LD_INT 69
49059: PUSH
49060: LD_INT 39
49062: PUSH
49063: LD_INT 40
49065: PUSH
49066: LD_INT 41
49068: PUSH
49069: LD_INT 42
49071: PUSH
49072: LD_INT 43
49074: PUSH
49075: LD_INT 48
49077: PUSH
49078: LD_INT 49
49080: PUSH
49081: LD_INT 50
49083: PUSH
49084: LD_INT 51
49086: PUSH
49087: LD_INT 52
49089: PUSH
49090: LD_INT 53
49092: PUSH
49093: LD_INT 54
49095: PUSH
49096: LD_INT 55
49098: PUSH
49099: LD_INT 56
49101: PUSH
49102: LD_INT 60
49104: PUSH
49105: LD_INT 61
49107: PUSH
49108: LD_INT 62
49110: PUSH
49111: LD_INT 66
49113: PUSH
49114: LD_INT 67
49116: PUSH
49117: LD_INT 68
49119: PUSH
49120: LD_INT 81
49122: PUSH
49123: LD_INT 82
49125: PUSH
49126: LD_INT 83
49128: PUSH
49129: LD_INT 84
49131: PUSH
49132: LD_INT 85
49134: PUSH
49135: LD_INT 87
49137: PUSH
49138: LD_INT 88
49140: PUSH
49141: EMPTY
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: LIST
49173: LIST
49174: LIST
49175: LIST
49176: LIST
49177: LIST
49178: LIST
49179: LIST
49180: LIST
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: ST_TO_ADDR
49197: GO 49430
49199: LD_INT 3
49201: DOUBLE
49202: EQUAL
49203: IFTRUE 49207
49205: GO 49429
49207: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49208: LD_ADDR_VAR 0 4
49212: PUSH
49213: LD_INT 46
49215: PUSH
49216: LD_INT 47
49218: PUSH
49219: LD_INT 1
49221: PUSH
49222: LD_INT 2
49224: PUSH
49225: LD_INT 82
49227: PUSH
49228: LD_INT 83
49230: PUSH
49231: LD_INT 84
49233: PUSH
49234: LD_INT 85
49236: PUSH
49237: LD_INT 86
49239: PUSH
49240: LD_INT 11
49242: PUSH
49243: LD_INT 9
49245: PUSH
49246: LD_INT 20
49248: PUSH
49249: LD_INT 19
49251: PUSH
49252: LD_INT 21
49254: PUSH
49255: LD_INT 24
49257: PUSH
49258: LD_INT 22
49260: PUSH
49261: LD_INT 25
49263: PUSH
49264: LD_INT 28
49266: PUSH
49267: LD_INT 29
49269: PUSH
49270: LD_INT 30
49272: PUSH
49273: LD_INT 31
49275: PUSH
49276: LD_INT 37
49278: PUSH
49279: LD_INT 38
49281: PUSH
49282: LD_INT 32
49284: PUSH
49285: LD_INT 27
49287: PUSH
49288: LD_INT 33
49290: PUSH
49291: LD_INT 69
49293: PUSH
49294: LD_INT 39
49296: PUSH
49297: LD_INT 34
49299: PUSH
49300: LD_INT 40
49302: PUSH
49303: LD_INT 71
49305: PUSH
49306: LD_INT 23
49308: PUSH
49309: LD_INT 44
49311: PUSH
49312: LD_INT 48
49314: PUSH
49315: LD_INT 49
49317: PUSH
49318: LD_INT 50
49320: PUSH
49321: LD_INT 51
49323: PUSH
49324: LD_INT 52
49326: PUSH
49327: LD_INT 53
49329: PUSH
49330: LD_INT 54
49332: PUSH
49333: LD_INT 55
49335: PUSH
49336: LD_INT 56
49338: PUSH
49339: LD_INT 57
49341: PUSH
49342: LD_INT 58
49344: PUSH
49345: LD_INT 59
49347: PUSH
49348: LD_INT 63
49350: PUSH
49351: LD_INT 64
49353: PUSH
49354: LD_INT 65
49356: PUSH
49357: LD_INT 82
49359: PUSH
49360: LD_INT 83
49362: PUSH
49363: LD_INT 84
49365: PUSH
49366: LD_INT 85
49368: PUSH
49369: LD_INT 86
49371: PUSH
49372: EMPTY
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: LIST
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: LIST
49418: LIST
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: LIST
49424: LIST
49425: LIST
49426: ST_TO_ADDR
49427: GO 49430
49429: POP
// if state > - 1 and state < 3 then
49430: LD_VAR 0 3
49434: PUSH
49435: LD_INT 1
49437: NEG
49438: GREATER
49439: PUSH
49440: LD_VAR 0 3
49444: PUSH
49445: LD_INT 3
49447: LESS
49448: AND
49449: IFFALSE 49506
// for i in result do
49451: LD_ADDR_VAR 0 5
49455: PUSH
49456: LD_VAR 0 4
49460: PUSH
49461: FOR_IN
49462: IFFALSE 49504
// if GetTech ( i , side ) <> state then
49464: LD_VAR 0 5
49468: PPUSH
49469: LD_VAR 0 1
49473: PPUSH
49474: CALL_OW 321
49478: PUSH
49479: LD_VAR 0 3
49483: NONEQUAL
49484: IFFALSE 49502
// result := result diff i ;
49486: LD_ADDR_VAR 0 4
49490: PUSH
49491: LD_VAR 0 4
49495: PUSH
49496: LD_VAR 0 5
49500: DIFF
49501: ST_TO_ADDR
49502: GO 49461
49504: POP
49505: POP
// end ;
49506: LD_VAR 0 4
49510: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49511: LD_INT 0
49513: PPUSH
49514: PPUSH
49515: PPUSH
// result := true ;
49516: LD_ADDR_VAR 0 3
49520: PUSH
49521: LD_INT 1
49523: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49524: LD_ADDR_VAR 0 5
49528: PUSH
49529: LD_VAR 0 2
49533: PPUSH
49534: CALL_OW 480
49538: ST_TO_ADDR
// if not tmp then
49539: LD_VAR 0 5
49543: NOT
49544: IFFALSE 49548
// exit ;
49546: GO 49597
// for i in tmp do
49548: LD_ADDR_VAR 0 4
49552: PUSH
49553: LD_VAR 0 5
49557: PUSH
49558: FOR_IN
49559: IFFALSE 49595
// if GetTech ( i , side ) <> state_researched then
49561: LD_VAR 0 4
49565: PPUSH
49566: LD_VAR 0 1
49570: PPUSH
49571: CALL_OW 321
49575: PUSH
49576: LD_INT 2
49578: NONEQUAL
49579: IFFALSE 49593
// begin result := false ;
49581: LD_ADDR_VAR 0 3
49585: PUSH
49586: LD_INT 0
49588: ST_TO_ADDR
// exit ;
49589: POP
49590: POP
49591: GO 49597
// end ;
49593: GO 49558
49595: POP
49596: POP
// end ;
49597: LD_VAR 0 3
49601: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49602: LD_INT 0
49604: PPUSH
49605: PPUSH
49606: PPUSH
49607: PPUSH
49608: PPUSH
49609: PPUSH
49610: PPUSH
49611: PPUSH
49612: PPUSH
49613: PPUSH
49614: PPUSH
49615: PPUSH
49616: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49617: LD_VAR 0 1
49621: NOT
49622: PUSH
49623: LD_VAR 0 1
49627: PPUSH
49628: CALL_OW 257
49632: PUSH
49633: LD_INT 9
49635: NONEQUAL
49636: OR
49637: IFFALSE 49641
// exit ;
49639: GO 50214
// side := GetSide ( unit ) ;
49641: LD_ADDR_VAR 0 9
49645: PUSH
49646: LD_VAR 0 1
49650: PPUSH
49651: CALL_OW 255
49655: ST_TO_ADDR
// tech_space := tech_spacanom ;
49656: LD_ADDR_VAR 0 12
49660: PUSH
49661: LD_INT 29
49663: ST_TO_ADDR
// tech_time := tech_taurad ;
49664: LD_ADDR_VAR 0 13
49668: PUSH
49669: LD_INT 28
49671: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49672: LD_ADDR_VAR 0 11
49676: PUSH
49677: LD_VAR 0 1
49681: PPUSH
49682: CALL_OW 310
49686: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49687: LD_VAR 0 11
49691: PPUSH
49692: CALL_OW 247
49696: PUSH
49697: LD_INT 2
49699: EQUAL
49700: IFFALSE 49704
// exit ;
49702: GO 50214
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49704: LD_ADDR_VAR 0 8
49708: PUSH
49709: LD_INT 81
49711: PUSH
49712: LD_VAR 0 9
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 3
49723: PUSH
49724: LD_INT 21
49726: PUSH
49727: LD_INT 3
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: PUSH
49734: EMPTY
49735: LIST
49736: LIST
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: PPUSH
49742: CALL_OW 69
49746: ST_TO_ADDR
// if not tmp then
49747: LD_VAR 0 8
49751: NOT
49752: IFFALSE 49756
// exit ;
49754: GO 50214
// if in_unit then
49756: LD_VAR 0 11
49760: IFFALSE 49784
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49762: LD_ADDR_VAR 0 10
49766: PUSH
49767: LD_VAR 0 8
49771: PPUSH
49772: LD_VAR 0 11
49776: PPUSH
49777: CALL_OW 74
49781: ST_TO_ADDR
49782: GO 49804
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49784: LD_ADDR_VAR 0 10
49788: PUSH
49789: LD_VAR 0 8
49793: PPUSH
49794: LD_VAR 0 1
49798: PPUSH
49799: CALL_OW 74
49803: ST_TO_ADDR
// if not enemy then
49804: LD_VAR 0 10
49808: NOT
49809: IFFALSE 49813
// exit ;
49811: GO 50214
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49813: LD_VAR 0 11
49817: PUSH
49818: LD_VAR 0 11
49822: PPUSH
49823: LD_VAR 0 10
49827: PPUSH
49828: CALL_OW 296
49832: PUSH
49833: LD_INT 13
49835: GREATER
49836: AND
49837: PUSH
49838: LD_VAR 0 1
49842: PPUSH
49843: LD_VAR 0 10
49847: PPUSH
49848: CALL_OW 296
49852: PUSH
49853: LD_INT 12
49855: GREATER
49856: OR
49857: IFFALSE 49861
// exit ;
49859: GO 50214
// missile := [ 1 ] ;
49861: LD_ADDR_VAR 0 14
49865: PUSH
49866: LD_INT 1
49868: PUSH
49869: EMPTY
49870: LIST
49871: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49872: LD_VAR 0 9
49876: PPUSH
49877: LD_VAR 0 12
49881: PPUSH
49882: CALL_OW 325
49886: IFFALSE 49915
// missile := Replace ( missile , missile + 1 , 2 ) ;
49888: LD_ADDR_VAR 0 14
49892: PUSH
49893: LD_VAR 0 14
49897: PPUSH
49898: LD_VAR 0 14
49902: PUSH
49903: LD_INT 1
49905: PLUS
49906: PPUSH
49907: LD_INT 2
49909: PPUSH
49910: CALL_OW 1
49914: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49915: LD_VAR 0 9
49919: PPUSH
49920: LD_VAR 0 13
49924: PPUSH
49925: CALL_OW 325
49929: PUSH
49930: LD_VAR 0 10
49934: PPUSH
49935: CALL_OW 255
49939: PPUSH
49940: LD_VAR 0 13
49944: PPUSH
49945: CALL_OW 325
49949: NOT
49950: AND
49951: IFFALSE 49980
// missile := Replace ( missile , missile + 1 , 3 ) ;
49953: LD_ADDR_VAR 0 14
49957: PUSH
49958: LD_VAR 0 14
49962: PPUSH
49963: LD_VAR 0 14
49967: PUSH
49968: LD_INT 1
49970: PLUS
49971: PPUSH
49972: LD_INT 3
49974: PPUSH
49975: CALL_OW 1
49979: ST_TO_ADDR
// if missile < 2 then
49980: LD_VAR 0 14
49984: PUSH
49985: LD_INT 2
49987: LESS
49988: IFFALSE 49992
// exit ;
49990: GO 50214
// x := GetX ( enemy ) ;
49992: LD_ADDR_VAR 0 4
49996: PUSH
49997: LD_VAR 0 10
50001: PPUSH
50002: CALL_OW 250
50006: ST_TO_ADDR
// y := GetY ( enemy ) ;
50007: LD_ADDR_VAR 0 5
50011: PUSH
50012: LD_VAR 0 10
50016: PPUSH
50017: CALL_OW 251
50021: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50022: LD_ADDR_VAR 0 6
50026: PUSH
50027: LD_VAR 0 4
50031: PUSH
50032: LD_INT 1
50034: NEG
50035: PPUSH
50036: LD_INT 1
50038: PPUSH
50039: CALL_OW 12
50043: PLUS
50044: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50045: LD_ADDR_VAR 0 7
50049: PUSH
50050: LD_VAR 0 5
50054: PUSH
50055: LD_INT 1
50057: NEG
50058: PPUSH
50059: LD_INT 1
50061: PPUSH
50062: CALL_OW 12
50066: PLUS
50067: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50068: LD_VAR 0 6
50072: PPUSH
50073: LD_VAR 0 7
50077: PPUSH
50078: CALL_OW 488
50082: NOT
50083: IFFALSE 50105
// begin _x := x ;
50085: LD_ADDR_VAR 0 6
50089: PUSH
50090: LD_VAR 0 4
50094: ST_TO_ADDR
// _y := y ;
50095: LD_ADDR_VAR 0 7
50099: PUSH
50100: LD_VAR 0 5
50104: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50105: LD_ADDR_VAR 0 3
50109: PUSH
50110: LD_INT 1
50112: PPUSH
50113: LD_VAR 0 14
50117: PPUSH
50118: CALL_OW 12
50122: ST_TO_ADDR
// case i of 1 :
50123: LD_VAR 0 3
50127: PUSH
50128: LD_INT 1
50130: DOUBLE
50131: EQUAL
50132: IFTRUE 50136
50134: GO 50153
50136: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50137: LD_VAR 0 1
50141: PPUSH
50142: LD_VAR 0 10
50146: PPUSH
50147: CALL_OW 115
50151: GO 50214
50153: LD_INT 2
50155: DOUBLE
50156: EQUAL
50157: IFTRUE 50161
50159: GO 50183
50161: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50162: LD_VAR 0 1
50166: PPUSH
50167: LD_VAR 0 6
50171: PPUSH
50172: LD_VAR 0 7
50176: PPUSH
50177: CALL_OW 153
50181: GO 50214
50183: LD_INT 3
50185: DOUBLE
50186: EQUAL
50187: IFTRUE 50191
50189: GO 50213
50191: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50192: LD_VAR 0 1
50196: PPUSH
50197: LD_VAR 0 6
50201: PPUSH
50202: LD_VAR 0 7
50206: PPUSH
50207: CALL_OW 154
50211: GO 50214
50213: POP
// end ;
50214: LD_VAR 0 2
50218: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50219: LD_INT 0
50221: PPUSH
50222: PPUSH
50223: PPUSH
50224: PPUSH
50225: PPUSH
50226: PPUSH
// if not unit or not building then
50227: LD_VAR 0 1
50231: NOT
50232: PUSH
50233: LD_VAR 0 2
50237: NOT
50238: OR
50239: IFFALSE 50243
// exit ;
50241: GO 50401
// x := GetX ( building ) ;
50243: LD_ADDR_VAR 0 5
50247: PUSH
50248: LD_VAR 0 2
50252: PPUSH
50253: CALL_OW 250
50257: ST_TO_ADDR
// y := GetY ( building ) ;
50258: LD_ADDR_VAR 0 6
50262: PUSH
50263: LD_VAR 0 2
50267: PPUSH
50268: CALL_OW 251
50272: ST_TO_ADDR
// for i = 0 to 5 do
50273: LD_ADDR_VAR 0 4
50277: PUSH
50278: DOUBLE
50279: LD_INT 0
50281: DEC
50282: ST_TO_ADDR
50283: LD_INT 5
50285: PUSH
50286: FOR_TO
50287: IFFALSE 50399
// begin _x := ShiftX ( x , i , 3 ) ;
50289: LD_ADDR_VAR 0 7
50293: PUSH
50294: LD_VAR 0 5
50298: PPUSH
50299: LD_VAR 0 4
50303: PPUSH
50304: LD_INT 3
50306: PPUSH
50307: CALL_OW 272
50311: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50312: LD_ADDR_VAR 0 8
50316: PUSH
50317: LD_VAR 0 6
50321: PPUSH
50322: LD_VAR 0 4
50326: PPUSH
50327: LD_INT 3
50329: PPUSH
50330: CALL_OW 273
50334: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50335: LD_VAR 0 7
50339: PPUSH
50340: LD_VAR 0 8
50344: PPUSH
50345: CALL_OW 488
50349: NOT
50350: IFFALSE 50354
// continue ;
50352: GO 50286
// if HexInfo ( _x , _y ) = 0 then
50354: LD_VAR 0 7
50358: PPUSH
50359: LD_VAR 0 8
50363: PPUSH
50364: CALL_OW 428
50368: PUSH
50369: LD_INT 0
50371: EQUAL
50372: IFFALSE 50397
// begin ComMoveXY ( unit , _x , _y ) ;
50374: LD_VAR 0 1
50378: PPUSH
50379: LD_VAR 0 7
50383: PPUSH
50384: LD_VAR 0 8
50388: PPUSH
50389: CALL_OW 111
// exit ;
50393: POP
50394: POP
50395: GO 50401
// end ; end ;
50397: GO 50286
50399: POP
50400: POP
// end ;
50401: LD_VAR 0 3
50405: RET
// export function ScanBase ( side , base_area ) ; begin
50406: LD_INT 0
50408: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50409: LD_ADDR_VAR 0 3
50413: PUSH
50414: LD_VAR 0 2
50418: PPUSH
50419: LD_INT 81
50421: PUSH
50422: LD_VAR 0 1
50426: PUSH
50427: EMPTY
50428: LIST
50429: LIST
50430: PPUSH
50431: CALL_OW 70
50435: ST_TO_ADDR
// end ;
50436: LD_VAR 0 3
50440: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50441: LD_INT 0
50443: PPUSH
50444: PPUSH
50445: PPUSH
50446: PPUSH
// result := false ;
50447: LD_ADDR_VAR 0 2
50451: PUSH
50452: LD_INT 0
50454: ST_TO_ADDR
// side := GetSide ( unit ) ;
50455: LD_ADDR_VAR 0 3
50459: PUSH
50460: LD_VAR 0 1
50464: PPUSH
50465: CALL_OW 255
50469: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50470: LD_ADDR_VAR 0 4
50474: PUSH
50475: LD_VAR 0 1
50479: PPUSH
50480: CALL_OW 248
50484: ST_TO_ADDR
// case nat of 1 :
50485: LD_VAR 0 4
50489: PUSH
50490: LD_INT 1
50492: DOUBLE
50493: EQUAL
50494: IFTRUE 50498
50496: GO 50509
50498: POP
// tech := tech_lassight ; 2 :
50499: LD_ADDR_VAR 0 5
50503: PUSH
50504: LD_INT 12
50506: ST_TO_ADDR
50507: GO 50548
50509: LD_INT 2
50511: DOUBLE
50512: EQUAL
50513: IFTRUE 50517
50515: GO 50528
50517: POP
// tech := tech_mortar ; 3 :
50518: LD_ADDR_VAR 0 5
50522: PUSH
50523: LD_INT 41
50525: ST_TO_ADDR
50526: GO 50548
50528: LD_INT 3
50530: DOUBLE
50531: EQUAL
50532: IFTRUE 50536
50534: GO 50547
50536: POP
// tech := tech_bazooka ; end ;
50537: LD_ADDR_VAR 0 5
50541: PUSH
50542: LD_INT 44
50544: ST_TO_ADDR
50545: GO 50548
50547: POP
// if Researched ( side , tech ) then
50548: LD_VAR 0 3
50552: PPUSH
50553: LD_VAR 0 5
50557: PPUSH
50558: CALL_OW 325
50562: IFFALSE 50589
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50564: LD_ADDR_VAR 0 2
50568: PUSH
50569: LD_INT 5
50571: PUSH
50572: LD_INT 8
50574: PUSH
50575: LD_INT 9
50577: PUSH
50578: EMPTY
50579: LIST
50580: LIST
50581: LIST
50582: PUSH
50583: LD_VAR 0 4
50587: ARRAY
50588: ST_TO_ADDR
// end ;
50589: LD_VAR 0 2
50593: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50594: LD_INT 0
50596: PPUSH
50597: PPUSH
50598: PPUSH
// if not mines then
50599: LD_VAR 0 2
50603: NOT
50604: IFFALSE 50608
// exit ;
50606: GO 50752
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50608: LD_ADDR_VAR 0 5
50612: PUSH
50613: LD_INT 81
50615: PUSH
50616: LD_VAR 0 1
50620: PUSH
50621: EMPTY
50622: LIST
50623: LIST
50624: PUSH
50625: LD_INT 3
50627: PUSH
50628: LD_INT 21
50630: PUSH
50631: LD_INT 3
50633: PUSH
50634: EMPTY
50635: LIST
50636: LIST
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PPUSH
50646: CALL_OW 69
50650: ST_TO_ADDR
// for i in mines do
50651: LD_ADDR_VAR 0 4
50655: PUSH
50656: LD_VAR 0 2
50660: PUSH
50661: FOR_IN
50662: IFFALSE 50750
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50664: LD_VAR 0 4
50668: PUSH
50669: LD_INT 1
50671: ARRAY
50672: PPUSH
50673: LD_VAR 0 4
50677: PUSH
50678: LD_INT 2
50680: ARRAY
50681: PPUSH
50682: CALL_OW 458
50686: NOT
50687: IFFALSE 50691
// continue ;
50689: GO 50661
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50691: LD_VAR 0 4
50695: PUSH
50696: LD_INT 1
50698: ARRAY
50699: PPUSH
50700: LD_VAR 0 4
50704: PUSH
50705: LD_INT 2
50707: ARRAY
50708: PPUSH
50709: CALL_OW 428
50713: PUSH
50714: LD_VAR 0 5
50718: IN
50719: IFFALSE 50748
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50721: LD_VAR 0 4
50725: PUSH
50726: LD_INT 1
50728: ARRAY
50729: PPUSH
50730: LD_VAR 0 4
50734: PUSH
50735: LD_INT 2
50737: ARRAY
50738: PPUSH
50739: LD_VAR 0 1
50743: PPUSH
50744: CALL_OW 456
// end ;
50748: GO 50661
50750: POP
50751: POP
// end ;
50752: LD_VAR 0 3
50756: RET
// export function Count ( array ) ; var i ; begin
50757: LD_INT 0
50759: PPUSH
50760: PPUSH
// result := 0 ;
50761: LD_ADDR_VAR 0 2
50765: PUSH
50766: LD_INT 0
50768: ST_TO_ADDR
// for i in array do
50769: LD_ADDR_VAR 0 3
50773: PUSH
50774: LD_VAR 0 1
50778: PUSH
50779: FOR_IN
50780: IFFALSE 50804
// if i then
50782: LD_VAR 0 3
50786: IFFALSE 50802
// result := result + 1 ;
50788: LD_ADDR_VAR 0 2
50792: PUSH
50793: LD_VAR 0 2
50797: PUSH
50798: LD_INT 1
50800: PLUS
50801: ST_TO_ADDR
50802: GO 50779
50804: POP
50805: POP
// end ;
50806: LD_VAR 0 2
50810: RET
// export function IsEmpty ( building ) ; begin
50811: LD_INT 0
50813: PPUSH
// if not building then
50814: LD_VAR 0 1
50818: NOT
50819: IFFALSE 50823
// exit ;
50821: GO 50866
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50823: LD_ADDR_VAR 0 2
50827: PUSH
50828: LD_VAR 0 1
50832: PUSH
50833: LD_INT 22
50835: PUSH
50836: LD_VAR 0 1
50840: PPUSH
50841: CALL_OW 255
50845: PUSH
50846: EMPTY
50847: LIST
50848: LIST
50849: PUSH
50850: LD_INT 58
50852: PUSH
50853: EMPTY
50854: LIST
50855: PUSH
50856: EMPTY
50857: LIST
50858: LIST
50859: PPUSH
50860: CALL_OW 69
50864: IN
50865: ST_TO_ADDR
// end ;
50866: LD_VAR 0 2
50870: RET
// export function IsNotFull ( building ) ; var places ; begin
50871: LD_INT 0
50873: PPUSH
50874: PPUSH
// if not building then
50875: LD_VAR 0 1
50879: NOT
50880: IFFALSE 50884
// exit ;
50882: GO 51055
// result := false ;
50884: LD_ADDR_VAR 0 2
50888: PUSH
50889: LD_INT 0
50891: ST_TO_ADDR
// places := 0 ;
50892: LD_ADDR_VAR 0 3
50896: PUSH
50897: LD_INT 0
50899: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
50900: LD_VAR 0 1
50904: PPUSH
50905: CALL_OW 266
50909: PUSH
50910: LD_INT 0
50912: DOUBLE
50913: EQUAL
50914: IFTRUE 50972
50916: LD_INT 1
50918: DOUBLE
50919: EQUAL
50920: IFTRUE 50972
50922: LD_INT 6
50924: DOUBLE
50925: EQUAL
50926: IFTRUE 50972
50928: LD_INT 7
50930: DOUBLE
50931: EQUAL
50932: IFTRUE 50972
50934: LD_INT 8
50936: DOUBLE
50937: EQUAL
50938: IFTRUE 50972
50940: LD_INT 4
50942: DOUBLE
50943: EQUAL
50944: IFTRUE 50972
50946: LD_INT 5
50948: DOUBLE
50949: EQUAL
50950: IFTRUE 50972
50952: LD_INT 2
50954: DOUBLE
50955: EQUAL
50956: IFTRUE 50972
50958: LD_INT 3
50960: DOUBLE
50961: EQUAL
50962: IFTRUE 50972
50964: LD_INT 35
50966: DOUBLE
50967: EQUAL
50968: IFTRUE 50972
50970: GO 50983
50972: POP
// places := 6 ; b_bunker , b_breastwork :
50973: LD_ADDR_VAR 0 3
50977: PUSH
50978: LD_INT 6
50980: ST_TO_ADDR
50981: GO 51028
50983: LD_INT 32
50985: DOUBLE
50986: EQUAL
50987: IFTRUE 50997
50989: LD_INT 31
50991: DOUBLE
50992: EQUAL
50993: IFTRUE 50997
50995: GO 51008
50997: POP
// places := 1 ; b_control_tower :
50998: LD_ADDR_VAR 0 3
51002: PUSH
51003: LD_INT 1
51005: ST_TO_ADDR
51006: GO 51028
51008: LD_INT 36
51010: DOUBLE
51011: EQUAL
51012: IFTRUE 51016
51014: GO 51027
51016: POP
// places := 3 ; end ;
51017: LD_ADDR_VAR 0 3
51021: PUSH
51022: LD_INT 3
51024: ST_TO_ADDR
51025: GO 51028
51027: POP
// if places then
51028: LD_VAR 0 3
51032: IFFALSE 51055
// result := UnitsInside ( building ) < places ;
51034: LD_ADDR_VAR 0 2
51038: PUSH
51039: LD_VAR 0 1
51043: PPUSH
51044: CALL_OW 313
51048: PUSH
51049: LD_VAR 0 3
51053: LESS
51054: ST_TO_ADDR
// end ;
51055: LD_VAR 0 2
51059: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51060: LD_INT 0
51062: PPUSH
51063: PPUSH
51064: PPUSH
51065: PPUSH
// tmp := [ ] ;
51066: LD_ADDR_VAR 0 3
51070: PUSH
51071: EMPTY
51072: ST_TO_ADDR
// list := [ ] ;
51073: LD_ADDR_VAR 0 5
51077: PUSH
51078: EMPTY
51079: ST_TO_ADDR
// for i = 16 to 25 do
51080: LD_ADDR_VAR 0 4
51084: PUSH
51085: DOUBLE
51086: LD_INT 16
51088: DEC
51089: ST_TO_ADDR
51090: LD_INT 25
51092: PUSH
51093: FOR_TO
51094: IFFALSE 51167
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51096: LD_ADDR_VAR 0 3
51100: PUSH
51101: LD_VAR 0 3
51105: PUSH
51106: LD_INT 22
51108: PUSH
51109: LD_VAR 0 1
51113: PPUSH
51114: CALL_OW 255
51118: PUSH
51119: EMPTY
51120: LIST
51121: LIST
51122: PUSH
51123: LD_INT 91
51125: PUSH
51126: LD_VAR 0 1
51130: PUSH
51131: LD_INT 6
51133: PUSH
51134: EMPTY
51135: LIST
51136: LIST
51137: LIST
51138: PUSH
51139: LD_INT 30
51141: PUSH
51142: LD_VAR 0 4
51146: PUSH
51147: EMPTY
51148: LIST
51149: LIST
51150: PUSH
51151: EMPTY
51152: LIST
51153: LIST
51154: LIST
51155: PUSH
51156: EMPTY
51157: LIST
51158: PPUSH
51159: CALL_OW 69
51163: ADD
51164: ST_TO_ADDR
51165: GO 51093
51167: POP
51168: POP
// for i = 1 to tmp do
51169: LD_ADDR_VAR 0 4
51173: PUSH
51174: DOUBLE
51175: LD_INT 1
51177: DEC
51178: ST_TO_ADDR
51179: LD_VAR 0 3
51183: PUSH
51184: FOR_TO
51185: IFFALSE 51273
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51187: LD_ADDR_VAR 0 5
51191: PUSH
51192: LD_VAR 0 5
51196: PUSH
51197: LD_VAR 0 3
51201: PUSH
51202: LD_VAR 0 4
51206: ARRAY
51207: PPUSH
51208: CALL_OW 266
51212: PUSH
51213: LD_VAR 0 3
51217: PUSH
51218: LD_VAR 0 4
51222: ARRAY
51223: PPUSH
51224: CALL_OW 250
51228: PUSH
51229: LD_VAR 0 3
51233: PUSH
51234: LD_VAR 0 4
51238: ARRAY
51239: PPUSH
51240: CALL_OW 251
51244: PUSH
51245: LD_VAR 0 3
51249: PUSH
51250: LD_VAR 0 4
51254: ARRAY
51255: PPUSH
51256: CALL_OW 254
51260: PUSH
51261: EMPTY
51262: LIST
51263: LIST
51264: LIST
51265: LIST
51266: PUSH
51267: EMPTY
51268: LIST
51269: ADD
51270: ST_TO_ADDR
51271: GO 51184
51273: POP
51274: POP
// result := list ;
51275: LD_ADDR_VAR 0 2
51279: PUSH
51280: LD_VAR 0 5
51284: ST_TO_ADDR
// end ;
51285: LD_VAR 0 2
51289: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51290: LD_INT 0
51292: PPUSH
51293: PPUSH
51294: PPUSH
51295: PPUSH
51296: PPUSH
51297: PPUSH
51298: PPUSH
// if not factory then
51299: LD_VAR 0 1
51303: NOT
51304: IFFALSE 51308
// exit ;
51306: GO 51901
// if control = control_apeman then
51308: LD_VAR 0 4
51312: PUSH
51313: LD_INT 5
51315: EQUAL
51316: IFFALSE 51425
// begin tmp := UnitsInside ( factory ) ;
51318: LD_ADDR_VAR 0 8
51322: PUSH
51323: LD_VAR 0 1
51327: PPUSH
51328: CALL_OW 313
51332: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51333: LD_VAR 0 8
51337: PPUSH
51338: LD_INT 25
51340: PUSH
51341: LD_INT 12
51343: PUSH
51344: EMPTY
51345: LIST
51346: LIST
51347: PPUSH
51348: CALL_OW 72
51352: NOT
51353: IFFALSE 51363
// control := control_manual ;
51355: LD_ADDR_VAR 0 4
51359: PUSH
51360: LD_INT 1
51362: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51363: LD_ADDR_VAR 0 8
51367: PUSH
51368: LD_VAR 0 1
51372: PPUSH
51373: CALL 51060 0 1
51377: ST_TO_ADDR
// if tmp then
51378: LD_VAR 0 8
51382: IFFALSE 51425
// begin for i in tmp do
51384: LD_ADDR_VAR 0 7
51388: PUSH
51389: LD_VAR 0 8
51393: PUSH
51394: FOR_IN
51395: IFFALSE 51423
// if i [ 1 ] = b_ext_radio then
51397: LD_VAR 0 7
51401: PUSH
51402: LD_INT 1
51404: ARRAY
51405: PUSH
51406: LD_INT 22
51408: EQUAL
51409: IFFALSE 51421
// begin control := control_remote ;
51411: LD_ADDR_VAR 0 4
51415: PUSH
51416: LD_INT 2
51418: ST_TO_ADDR
// break ;
51419: GO 51423
// end ;
51421: GO 51394
51423: POP
51424: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51425: LD_VAR 0 1
51429: PPUSH
51430: LD_VAR 0 2
51434: PPUSH
51435: LD_VAR 0 3
51439: PPUSH
51440: LD_VAR 0 4
51444: PPUSH
51445: LD_VAR 0 5
51449: PPUSH
51450: CALL_OW 448
51454: IFFALSE 51489
// begin result := [ chassis , engine , control , weapon ] ;
51456: LD_ADDR_VAR 0 6
51460: PUSH
51461: LD_VAR 0 2
51465: PUSH
51466: LD_VAR 0 3
51470: PUSH
51471: LD_VAR 0 4
51475: PUSH
51476: LD_VAR 0 5
51480: PUSH
51481: EMPTY
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: ST_TO_ADDR
// exit ;
51487: GO 51901
// end ; _chassis := AvailableChassisList ( factory ) ;
51489: LD_ADDR_VAR 0 9
51493: PUSH
51494: LD_VAR 0 1
51498: PPUSH
51499: CALL_OW 475
51503: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51504: LD_ADDR_VAR 0 11
51508: PUSH
51509: LD_VAR 0 1
51513: PPUSH
51514: CALL_OW 476
51518: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51519: LD_ADDR_VAR 0 12
51523: PUSH
51524: LD_VAR 0 1
51528: PPUSH
51529: CALL_OW 477
51533: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51534: LD_ADDR_VAR 0 10
51538: PUSH
51539: LD_VAR 0 1
51543: PPUSH
51544: CALL_OW 478
51548: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51549: LD_VAR 0 9
51553: NOT
51554: PUSH
51555: LD_VAR 0 11
51559: NOT
51560: OR
51561: PUSH
51562: LD_VAR 0 12
51566: NOT
51567: OR
51568: PUSH
51569: LD_VAR 0 10
51573: NOT
51574: OR
51575: IFFALSE 51610
// begin result := [ chassis , engine , control , weapon ] ;
51577: LD_ADDR_VAR 0 6
51581: PUSH
51582: LD_VAR 0 2
51586: PUSH
51587: LD_VAR 0 3
51591: PUSH
51592: LD_VAR 0 4
51596: PUSH
51597: LD_VAR 0 5
51601: PUSH
51602: EMPTY
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: ST_TO_ADDR
// exit ;
51608: GO 51901
// end ; if not chassis in _chassis then
51610: LD_VAR 0 2
51614: PUSH
51615: LD_VAR 0 9
51619: IN
51620: NOT
51621: IFFALSE 51647
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51623: LD_ADDR_VAR 0 2
51627: PUSH
51628: LD_VAR 0 9
51632: PUSH
51633: LD_INT 1
51635: PPUSH
51636: LD_VAR 0 9
51640: PPUSH
51641: CALL_OW 12
51645: ARRAY
51646: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51647: LD_VAR 0 2
51651: PPUSH
51652: LD_VAR 0 3
51656: PPUSH
51657: CALL 51906 0 2
51661: NOT
51662: IFFALSE 51721
// repeat engine := _engine [ 1 ] ;
51664: LD_ADDR_VAR 0 3
51668: PUSH
51669: LD_VAR 0 11
51673: PUSH
51674: LD_INT 1
51676: ARRAY
51677: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51678: LD_ADDR_VAR 0 11
51682: PUSH
51683: LD_VAR 0 11
51687: PPUSH
51688: LD_INT 1
51690: PPUSH
51691: CALL_OW 3
51695: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51696: LD_VAR 0 2
51700: PPUSH
51701: LD_VAR 0 3
51705: PPUSH
51706: CALL 51906 0 2
51710: PUSH
51711: LD_VAR 0 11
51715: PUSH
51716: EMPTY
51717: EQUAL
51718: OR
51719: IFFALSE 51664
// if not control in _control then
51721: LD_VAR 0 4
51725: PUSH
51726: LD_VAR 0 12
51730: IN
51731: NOT
51732: IFFALSE 51758
// control := _control [ rand ( 1 , _control ) ] ;
51734: LD_ADDR_VAR 0 4
51738: PUSH
51739: LD_VAR 0 12
51743: PUSH
51744: LD_INT 1
51746: PPUSH
51747: LD_VAR 0 12
51751: PPUSH
51752: CALL_OW 12
51756: ARRAY
51757: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51758: LD_VAR 0 2
51762: PPUSH
51763: LD_VAR 0 5
51767: PPUSH
51768: CALL 52126 0 2
51772: NOT
51773: IFFALSE 51832
// repeat weapon := _weapon [ 1 ] ;
51775: LD_ADDR_VAR 0 5
51779: PUSH
51780: LD_VAR 0 10
51784: PUSH
51785: LD_INT 1
51787: ARRAY
51788: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51789: LD_ADDR_VAR 0 10
51793: PUSH
51794: LD_VAR 0 10
51798: PPUSH
51799: LD_INT 1
51801: PPUSH
51802: CALL_OW 3
51806: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51807: LD_VAR 0 2
51811: PPUSH
51812: LD_VAR 0 5
51816: PPUSH
51817: CALL 52126 0 2
51821: PUSH
51822: LD_VAR 0 10
51826: PUSH
51827: EMPTY
51828: EQUAL
51829: OR
51830: IFFALSE 51775
// result := [ ] ;
51832: LD_ADDR_VAR 0 6
51836: PUSH
51837: EMPTY
51838: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51839: LD_VAR 0 1
51843: PPUSH
51844: LD_VAR 0 2
51848: PPUSH
51849: LD_VAR 0 3
51853: PPUSH
51854: LD_VAR 0 4
51858: PPUSH
51859: LD_VAR 0 5
51863: PPUSH
51864: CALL_OW 448
51868: IFFALSE 51901
// result := [ chassis , engine , control , weapon ] ;
51870: LD_ADDR_VAR 0 6
51874: PUSH
51875: LD_VAR 0 2
51879: PUSH
51880: LD_VAR 0 3
51884: PUSH
51885: LD_VAR 0 4
51889: PUSH
51890: LD_VAR 0 5
51894: PUSH
51895: EMPTY
51896: LIST
51897: LIST
51898: LIST
51899: LIST
51900: ST_TO_ADDR
// end ;
51901: LD_VAR 0 6
51905: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51906: LD_INT 0
51908: PPUSH
// if not chassis or not engine then
51909: LD_VAR 0 1
51913: NOT
51914: PUSH
51915: LD_VAR 0 2
51919: NOT
51920: OR
51921: IFFALSE 51925
// exit ;
51923: GO 52121
// case engine of engine_solar :
51925: LD_VAR 0 2
51929: PUSH
51930: LD_INT 2
51932: DOUBLE
51933: EQUAL
51934: IFTRUE 51938
51936: GO 51976
51938: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51939: LD_ADDR_VAR 0 3
51943: PUSH
51944: LD_INT 11
51946: PUSH
51947: LD_INT 12
51949: PUSH
51950: LD_INT 13
51952: PUSH
51953: LD_INT 14
51955: PUSH
51956: LD_INT 1
51958: PUSH
51959: LD_INT 2
51961: PUSH
51962: LD_INT 3
51964: PUSH
51965: EMPTY
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: LIST
51971: LIST
51972: LIST
51973: ST_TO_ADDR
51974: GO 52105
51976: LD_INT 1
51978: DOUBLE
51979: EQUAL
51980: IFTRUE 51984
51982: GO 52046
51984: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51985: LD_ADDR_VAR 0 3
51989: PUSH
51990: LD_INT 11
51992: PUSH
51993: LD_INT 12
51995: PUSH
51996: LD_INT 13
51998: PUSH
51999: LD_INT 14
52001: PUSH
52002: LD_INT 1
52004: PUSH
52005: LD_INT 2
52007: PUSH
52008: LD_INT 3
52010: PUSH
52011: LD_INT 4
52013: PUSH
52014: LD_INT 5
52016: PUSH
52017: LD_INT 21
52019: PUSH
52020: LD_INT 23
52022: PUSH
52023: LD_INT 22
52025: PUSH
52026: LD_INT 24
52028: PUSH
52029: EMPTY
52030: LIST
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: LIST
52040: LIST
52041: LIST
52042: LIST
52043: ST_TO_ADDR
52044: GO 52105
52046: LD_INT 3
52048: DOUBLE
52049: EQUAL
52050: IFTRUE 52054
52052: GO 52104
52054: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52055: LD_ADDR_VAR 0 3
52059: PUSH
52060: LD_INT 13
52062: PUSH
52063: LD_INT 14
52065: PUSH
52066: LD_INT 2
52068: PUSH
52069: LD_INT 3
52071: PUSH
52072: LD_INT 4
52074: PUSH
52075: LD_INT 5
52077: PUSH
52078: LD_INT 21
52080: PUSH
52081: LD_INT 22
52083: PUSH
52084: LD_INT 23
52086: PUSH
52087: LD_INT 24
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: LIST
52098: LIST
52099: LIST
52100: LIST
52101: ST_TO_ADDR
52102: GO 52105
52104: POP
// result := ( chassis in result ) ;
52105: LD_ADDR_VAR 0 3
52109: PUSH
52110: LD_VAR 0 1
52114: PUSH
52115: LD_VAR 0 3
52119: IN
52120: ST_TO_ADDR
// end ;
52121: LD_VAR 0 3
52125: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52126: LD_INT 0
52128: PPUSH
// if not chassis or not weapon then
52129: LD_VAR 0 1
52133: NOT
52134: PUSH
52135: LD_VAR 0 2
52139: NOT
52140: OR
52141: IFFALSE 52145
// exit ;
52143: GO 53205
// case weapon of us_machine_gun :
52145: LD_VAR 0 2
52149: PUSH
52150: LD_INT 2
52152: DOUBLE
52153: EQUAL
52154: IFTRUE 52158
52156: GO 52188
52158: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52159: LD_ADDR_VAR 0 3
52163: PUSH
52164: LD_INT 1
52166: PUSH
52167: LD_INT 2
52169: PUSH
52170: LD_INT 3
52172: PUSH
52173: LD_INT 4
52175: PUSH
52176: LD_INT 5
52178: PUSH
52179: EMPTY
52180: LIST
52181: LIST
52182: LIST
52183: LIST
52184: LIST
52185: ST_TO_ADDR
52186: GO 53189
52188: LD_INT 3
52190: DOUBLE
52191: EQUAL
52192: IFTRUE 52196
52194: GO 52226
52196: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52197: LD_ADDR_VAR 0 3
52201: PUSH
52202: LD_INT 1
52204: PUSH
52205: LD_INT 2
52207: PUSH
52208: LD_INT 3
52210: PUSH
52211: LD_INT 4
52213: PUSH
52214: LD_INT 5
52216: PUSH
52217: EMPTY
52218: LIST
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: ST_TO_ADDR
52224: GO 53189
52226: LD_INT 11
52228: DOUBLE
52229: EQUAL
52230: IFTRUE 52234
52232: GO 52264
52234: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52235: LD_ADDR_VAR 0 3
52239: PUSH
52240: LD_INT 1
52242: PUSH
52243: LD_INT 2
52245: PUSH
52246: LD_INT 3
52248: PUSH
52249: LD_INT 4
52251: PUSH
52252: LD_INT 5
52254: PUSH
52255: EMPTY
52256: LIST
52257: LIST
52258: LIST
52259: LIST
52260: LIST
52261: ST_TO_ADDR
52262: GO 53189
52264: LD_INT 4
52266: DOUBLE
52267: EQUAL
52268: IFTRUE 52272
52270: GO 52298
52272: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52273: LD_ADDR_VAR 0 3
52277: PUSH
52278: LD_INT 2
52280: PUSH
52281: LD_INT 3
52283: PUSH
52284: LD_INT 4
52286: PUSH
52287: LD_INT 5
52289: PUSH
52290: EMPTY
52291: LIST
52292: LIST
52293: LIST
52294: LIST
52295: ST_TO_ADDR
52296: GO 53189
52298: LD_INT 5
52300: DOUBLE
52301: EQUAL
52302: IFTRUE 52306
52304: GO 52332
52306: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52307: LD_ADDR_VAR 0 3
52311: PUSH
52312: LD_INT 2
52314: PUSH
52315: LD_INT 3
52317: PUSH
52318: LD_INT 4
52320: PUSH
52321: LD_INT 5
52323: PUSH
52324: EMPTY
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: ST_TO_ADDR
52330: GO 53189
52332: LD_INT 9
52334: DOUBLE
52335: EQUAL
52336: IFTRUE 52340
52338: GO 52366
52340: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52341: LD_ADDR_VAR 0 3
52345: PUSH
52346: LD_INT 2
52348: PUSH
52349: LD_INT 3
52351: PUSH
52352: LD_INT 4
52354: PUSH
52355: LD_INT 5
52357: PUSH
52358: EMPTY
52359: LIST
52360: LIST
52361: LIST
52362: LIST
52363: ST_TO_ADDR
52364: GO 53189
52366: LD_INT 7
52368: DOUBLE
52369: EQUAL
52370: IFTRUE 52374
52372: GO 52400
52374: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52375: LD_ADDR_VAR 0 3
52379: PUSH
52380: LD_INT 2
52382: PUSH
52383: LD_INT 3
52385: PUSH
52386: LD_INT 4
52388: PUSH
52389: LD_INT 5
52391: PUSH
52392: EMPTY
52393: LIST
52394: LIST
52395: LIST
52396: LIST
52397: ST_TO_ADDR
52398: GO 53189
52400: LD_INT 12
52402: DOUBLE
52403: EQUAL
52404: IFTRUE 52408
52406: GO 52434
52408: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52409: LD_ADDR_VAR 0 3
52413: PUSH
52414: LD_INT 2
52416: PUSH
52417: LD_INT 3
52419: PUSH
52420: LD_INT 4
52422: PUSH
52423: LD_INT 5
52425: PUSH
52426: EMPTY
52427: LIST
52428: LIST
52429: LIST
52430: LIST
52431: ST_TO_ADDR
52432: GO 53189
52434: LD_INT 13
52436: DOUBLE
52437: EQUAL
52438: IFTRUE 52442
52440: GO 52468
52442: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52443: LD_ADDR_VAR 0 3
52447: PUSH
52448: LD_INT 2
52450: PUSH
52451: LD_INT 3
52453: PUSH
52454: LD_INT 4
52456: PUSH
52457: LD_INT 5
52459: PUSH
52460: EMPTY
52461: LIST
52462: LIST
52463: LIST
52464: LIST
52465: ST_TO_ADDR
52466: GO 53189
52468: LD_INT 14
52470: DOUBLE
52471: EQUAL
52472: IFTRUE 52476
52474: GO 52494
52476: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52477: LD_ADDR_VAR 0 3
52481: PUSH
52482: LD_INT 4
52484: PUSH
52485: LD_INT 5
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: ST_TO_ADDR
52492: GO 53189
52494: LD_INT 6
52496: DOUBLE
52497: EQUAL
52498: IFTRUE 52502
52500: GO 52520
52502: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52503: LD_ADDR_VAR 0 3
52507: PUSH
52508: LD_INT 4
52510: PUSH
52511: LD_INT 5
52513: PUSH
52514: EMPTY
52515: LIST
52516: LIST
52517: ST_TO_ADDR
52518: GO 53189
52520: LD_INT 10
52522: DOUBLE
52523: EQUAL
52524: IFTRUE 52528
52526: GO 52546
52528: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52529: LD_ADDR_VAR 0 3
52533: PUSH
52534: LD_INT 4
52536: PUSH
52537: LD_INT 5
52539: PUSH
52540: EMPTY
52541: LIST
52542: LIST
52543: ST_TO_ADDR
52544: GO 53189
52546: LD_INT 22
52548: DOUBLE
52549: EQUAL
52550: IFTRUE 52554
52552: GO 52580
52554: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52555: LD_ADDR_VAR 0 3
52559: PUSH
52560: LD_INT 11
52562: PUSH
52563: LD_INT 12
52565: PUSH
52566: LD_INT 13
52568: PUSH
52569: LD_INT 14
52571: PUSH
52572: EMPTY
52573: LIST
52574: LIST
52575: LIST
52576: LIST
52577: ST_TO_ADDR
52578: GO 53189
52580: LD_INT 23
52582: DOUBLE
52583: EQUAL
52584: IFTRUE 52588
52586: GO 52614
52588: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52589: LD_ADDR_VAR 0 3
52593: PUSH
52594: LD_INT 11
52596: PUSH
52597: LD_INT 12
52599: PUSH
52600: LD_INT 13
52602: PUSH
52603: LD_INT 14
52605: PUSH
52606: EMPTY
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: ST_TO_ADDR
52612: GO 53189
52614: LD_INT 24
52616: DOUBLE
52617: EQUAL
52618: IFTRUE 52622
52620: GO 52648
52622: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52623: LD_ADDR_VAR 0 3
52627: PUSH
52628: LD_INT 11
52630: PUSH
52631: LD_INT 12
52633: PUSH
52634: LD_INT 13
52636: PUSH
52637: LD_INT 14
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: LIST
52644: LIST
52645: ST_TO_ADDR
52646: GO 53189
52648: LD_INT 30
52650: DOUBLE
52651: EQUAL
52652: IFTRUE 52656
52654: GO 52682
52656: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52657: LD_ADDR_VAR 0 3
52661: PUSH
52662: LD_INT 11
52664: PUSH
52665: LD_INT 12
52667: PUSH
52668: LD_INT 13
52670: PUSH
52671: LD_INT 14
52673: PUSH
52674: EMPTY
52675: LIST
52676: LIST
52677: LIST
52678: LIST
52679: ST_TO_ADDR
52680: GO 53189
52682: LD_INT 25
52684: DOUBLE
52685: EQUAL
52686: IFTRUE 52690
52688: GO 52708
52690: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52691: LD_ADDR_VAR 0 3
52695: PUSH
52696: LD_INT 13
52698: PUSH
52699: LD_INT 14
52701: PUSH
52702: EMPTY
52703: LIST
52704: LIST
52705: ST_TO_ADDR
52706: GO 53189
52708: LD_INT 27
52710: DOUBLE
52711: EQUAL
52712: IFTRUE 52716
52714: GO 52734
52716: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52717: LD_ADDR_VAR 0 3
52721: PUSH
52722: LD_INT 13
52724: PUSH
52725: LD_INT 14
52727: PUSH
52728: EMPTY
52729: LIST
52730: LIST
52731: ST_TO_ADDR
52732: GO 53189
52734: LD_INT 92
52736: DOUBLE
52737: EQUAL
52738: IFTRUE 52742
52740: GO 52768
52742: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52743: LD_ADDR_VAR 0 3
52747: PUSH
52748: LD_INT 11
52750: PUSH
52751: LD_INT 12
52753: PUSH
52754: LD_INT 13
52756: PUSH
52757: LD_INT 14
52759: PUSH
52760: EMPTY
52761: LIST
52762: LIST
52763: LIST
52764: LIST
52765: ST_TO_ADDR
52766: GO 53189
52768: LD_INT 28
52770: DOUBLE
52771: EQUAL
52772: IFTRUE 52776
52774: GO 52794
52776: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52777: LD_ADDR_VAR 0 3
52781: PUSH
52782: LD_INT 13
52784: PUSH
52785: LD_INT 14
52787: PUSH
52788: EMPTY
52789: LIST
52790: LIST
52791: ST_TO_ADDR
52792: GO 53189
52794: LD_INT 29
52796: DOUBLE
52797: EQUAL
52798: IFTRUE 52802
52800: GO 52820
52802: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52803: LD_ADDR_VAR 0 3
52807: PUSH
52808: LD_INT 13
52810: PUSH
52811: LD_INT 14
52813: PUSH
52814: EMPTY
52815: LIST
52816: LIST
52817: ST_TO_ADDR
52818: GO 53189
52820: LD_INT 31
52822: DOUBLE
52823: EQUAL
52824: IFTRUE 52828
52826: GO 52846
52828: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52829: LD_ADDR_VAR 0 3
52833: PUSH
52834: LD_INT 13
52836: PUSH
52837: LD_INT 14
52839: PUSH
52840: EMPTY
52841: LIST
52842: LIST
52843: ST_TO_ADDR
52844: GO 53189
52846: LD_INT 26
52848: DOUBLE
52849: EQUAL
52850: IFTRUE 52854
52852: GO 52872
52854: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52855: LD_ADDR_VAR 0 3
52859: PUSH
52860: LD_INT 13
52862: PUSH
52863: LD_INT 14
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: ST_TO_ADDR
52870: GO 53189
52872: LD_INT 42
52874: DOUBLE
52875: EQUAL
52876: IFTRUE 52880
52878: GO 52906
52880: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52881: LD_ADDR_VAR 0 3
52885: PUSH
52886: LD_INT 21
52888: PUSH
52889: LD_INT 22
52891: PUSH
52892: LD_INT 23
52894: PUSH
52895: LD_INT 24
52897: PUSH
52898: EMPTY
52899: LIST
52900: LIST
52901: LIST
52902: LIST
52903: ST_TO_ADDR
52904: GO 53189
52906: LD_INT 43
52908: DOUBLE
52909: EQUAL
52910: IFTRUE 52914
52912: GO 52940
52914: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52915: LD_ADDR_VAR 0 3
52919: PUSH
52920: LD_INT 21
52922: PUSH
52923: LD_INT 22
52925: PUSH
52926: LD_INT 23
52928: PUSH
52929: LD_INT 24
52931: PUSH
52932: EMPTY
52933: LIST
52934: LIST
52935: LIST
52936: LIST
52937: ST_TO_ADDR
52938: GO 53189
52940: LD_INT 44
52942: DOUBLE
52943: EQUAL
52944: IFTRUE 52948
52946: GO 52974
52948: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52949: LD_ADDR_VAR 0 3
52953: PUSH
52954: LD_INT 21
52956: PUSH
52957: LD_INT 22
52959: PUSH
52960: LD_INT 23
52962: PUSH
52963: LD_INT 24
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: LIST
52970: LIST
52971: ST_TO_ADDR
52972: GO 53189
52974: LD_INT 45
52976: DOUBLE
52977: EQUAL
52978: IFTRUE 52982
52980: GO 53008
52982: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52983: LD_ADDR_VAR 0 3
52987: PUSH
52988: LD_INT 21
52990: PUSH
52991: LD_INT 22
52993: PUSH
52994: LD_INT 23
52996: PUSH
52997: LD_INT 24
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: LIST
53004: LIST
53005: ST_TO_ADDR
53006: GO 53189
53008: LD_INT 49
53010: DOUBLE
53011: EQUAL
53012: IFTRUE 53016
53014: GO 53042
53016: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53017: LD_ADDR_VAR 0 3
53021: PUSH
53022: LD_INT 21
53024: PUSH
53025: LD_INT 22
53027: PUSH
53028: LD_INT 23
53030: PUSH
53031: LD_INT 24
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: LIST
53038: LIST
53039: ST_TO_ADDR
53040: GO 53189
53042: LD_INT 51
53044: DOUBLE
53045: EQUAL
53046: IFTRUE 53050
53048: GO 53076
53050: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53051: LD_ADDR_VAR 0 3
53055: PUSH
53056: LD_INT 21
53058: PUSH
53059: LD_INT 22
53061: PUSH
53062: LD_INT 23
53064: PUSH
53065: LD_INT 24
53067: PUSH
53068: EMPTY
53069: LIST
53070: LIST
53071: LIST
53072: LIST
53073: ST_TO_ADDR
53074: GO 53189
53076: LD_INT 52
53078: DOUBLE
53079: EQUAL
53080: IFTRUE 53084
53082: GO 53110
53084: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53085: LD_ADDR_VAR 0 3
53089: PUSH
53090: LD_INT 21
53092: PUSH
53093: LD_INT 22
53095: PUSH
53096: LD_INT 23
53098: PUSH
53099: LD_INT 24
53101: PUSH
53102: EMPTY
53103: LIST
53104: LIST
53105: LIST
53106: LIST
53107: ST_TO_ADDR
53108: GO 53189
53110: LD_INT 53
53112: DOUBLE
53113: EQUAL
53114: IFTRUE 53118
53116: GO 53136
53118: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53119: LD_ADDR_VAR 0 3
53123: PUSH
53124: LD_INT 23
53126: PUSH
53127: LD_INT 24
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: ST_TO_ADDR
53134: GO 53189
53136: LD_INT 46
53138: DOUBLE
53139: EQUAL
53140: IFTRUE 53144
53142: GO 53162
53144: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53145: LD_ADDR_VAR 0 3
53149: PUSH
53150: LD_INT 23
53152: PUSH
53153: LD_INT 24
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: ST_TO_ADDR
53160: GO 53189
53162: LD_INT 47
53164: DOUBLE
53165: EQUAL
53166: IFTRUE 53170
53168: GO 53188
53170: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53171: LD_ADDR_VAR 0 3
53175: PUSH
53176: LD_INT 23
53178: PUSH
53179: LD_INT 24
53181: PUSH
53182: EMPTY
53183: LIST
53184: LIST
53185: ST_TO_ADDR
53186: GO 53189
53188: POP
// result := ( chassis in result ) ;
53189: LD_ADDR_VAR 0 3
53193: PUSH
53194: LD_VAR 0 1
53198: PUSH
53199: LD_VAR 0 3
53203: IN
53204: ST_TO_ADDR
// end ;
53205: LD_VAR 0 3
53209: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53210: LD_INT 0
53212: PPUSH
53213: PPUSH
53214: PPUSH
53215: PPUSH
53216: PPUSH
53217: PPUSH
53218: PPUSH
// result := array ;
53219: LD_ADDR_VAR 0 5
53223: PUSH
53224: LD_VAR 0 1
53228: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53229: LD_VAR 0 1
53233: NOT
53234: PUSH
53235: LD_VAR 0 2
53239: NOT
53240: OR
53241: PUSH
53242: LD_VAR 0 3
53246: NOT
53247: OR
53248: PUSH
53249: LD_VAR 0 2
53253: PUSH
53254: LD_VAR 0 1
53258: GREATER
53259: OR
53260: PUSH
53261: LD_VAR 0 3
53265: PUSH
53266: LD_VAR 0 1
53270: GREATER
53271: OR
53272: IFFALSE 53276
// exit ;
53274: GO 53572
// if direction then
53276: LD_VAR 0 4
53280: IFFALSE 53344
// begin d := 1 ;
53282: LD_ADDR_VAR 0 9
53286: PUSH
53287: LD_INT 1
53289: ST_TO_ADDR
// if i_from > i_to then
53290: LD_VAR 0 2
53294: PUSH
53295: LD_VAR 0 3
53299: GREATER
53300: IFFALSE 53326
// length := ( array - i_from ) + i_to else
53302: LD_ADDR_VAR 0 11
53306: PUSH
53307: LD_VAR 0 1
53311: PUSH
53312: LD_VAR 0 2
53316: MINUS
53317: PUSH
53318: LD_VAR 0 3
53322: PLUS
53323: ST_TO_ADDR
53324: GO 53342
// length := i_to - i_from ;
53326: LD_ADDR_VAR 0 11
53330: PUSH
53331: LD_VAR 0 3
53335: PUSH
53336: LD_VAR 0 2
53340: MINUS
53341: ST_TO_ADDR
// end else
53342: GO 53405
// begin d := - 1 ;
53344: LD_ADDR_VAR 0 9
53348: PUSH
53349: LD_INT 1
53351: NEG
53352: ST_TO_ADDR
// if i_from > i_to then
53353: LD_VAR 0 2
53357: PUSH
53358: LD_VAR 0 3
53362: GREATER
53363: IFFALSE 53383
// length := i_from - i_to else
53365: LD_ADDR_VAR 0 11
53369: PUSH
53370: LD_VAR 0 2
53374: PUSH
53375: LD_VAR 0 3
53379: MINUS
53380: ST_TO_ADDR
53381: GO 53405
// length := ( array - i_to ) + i_from ;
53383: LD_ADDR_VAR 0 11
53387: PUSH
53388: LD_VAR 0 1
53392: PUSH
53393: LD_VAR 0 3
53397: MINUS
53398: PUSH
53399: LD_VAR 0 2
53403: PLUS
53404: ST_TO_ADDR
// end ; if not length then
53405: LD_VAR 0 11
53409: NOT
53410: IFFALSE 53414
// exit ;
53412: GO 53572
// tmp := array ;
53414: LD_ADDR_VAR 0 10
53418: PUSH
53419: LD_VAR 0 1
53423: ST_TO_ADDR
// for i = 1 to length do
53424: LD_ADDR_VAR 0 6
53428: PUSH
53429: DOUBLE
53430: LD_INT 1
53432: DEC
53433: ST_TO_ADDR
53434: LD_VAR 0 11
53438: PUSH
53439: FOR_TO
53440: IFFALSE 53560
// begin for j = 1 to array do
53442: LD_ADDR_VAR 0 7
53446: PUSH
53447: DOUBLE
53448: LD_INT 1
53450: DEC
53451: ST_TO_ADDR
53452: LD_VAR 0 1
53456: PUSH
53457: FOR_TO
53458: IFFALSE 53546
// begin k := j + d ;
53460: LD_ADDR_VAR 0 8
53464: PUSH
53465: LD_VAR 0 7
53469: PUSH
53470: LD_VAR 0 9
53474: PLUS
53475: ST_TO_ADDR
// if k > array then
53476: LD_VAR 0 8
53480: PUSH
53481: LD_VAR 0 1
53485: GREATER
53486: IFFALSE 53496
// k := 1 ;
53488: LD_ADDR_VAR 0 8
53492: PUSH
53493: LD_INT 1
53495: ST_TO_ADDR
// if not k then
53496: LD_VAR 0 8
53500: NOT
53501: IFFALSE 53513
// k := array ;
53503: LD_ADDR_VAR 0 8
53507: PUSH
53508: LD_VAR 0 1
53512: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53513: LD_ADDR_VAR 0 10
53517: PUSH
53518: LD_VAR 0 10
53522: PPUSH
53523: LD_VAR 0 8
53527: PPUSH
53528: LD_VAR 0 1
53532: PUSH
53533: LD_VAR 0 7
53537: ARRAY
53538: PPUSH
53539: CALL_OW 1
53543: ST_TO_ADDR
// end ;
53544: GO 53457
53546: POP
53547: POP
// array := tmp ;
53548: LD_ADDR_VAR 0 1
53552: PUSH
53553: LD_VAR 0 10
53557: ST_TO_ADDR
// end ;
53558: GO 53439
53560: POP
53561: POP
// result := array ;
53562: LD_ADDR_VAR 0 5
53566: PUSH
53567: LD_VAR 0 1
53571: ST_TO_ADDR
// end ;
53572: LD_VAR 0 5
53576: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53577: LD_INT 0
53579: PPUSH
53580: PPUSH
// result := 0 ;
53581: LD_ADDR_VAR 0 3
53585: PUSH
53586: LD_INT 0
53588: ST_TO_ADDR
// if not array or not value in array then
53589: LD_VAR 0 1
53593: NOT
53594: PUSH
53595: LD_VAR 0 2
53599: PUSH
53600: LD_VAR 0 1
53604: IN
53605: NOT
53606: OR
53607: IFFALSE 53611
// exit ;
53609: GO 53665
// for i = 1 to array do
53611: LD_ADDR_VAR 0 4
53615: PUSH
53616: DOUBLE
53617: LD_INT 1
53619: DEC
53620: ST_TO_ADDR
53621: LD_VAR 0 1
53625: PUSH
53626: FOR_TO
53627: IFFALSE 53663
// if value = array [ i ] then
53629: LD_VAR 0 2
53633: PUSH
53634: LD_VAR 0 1
53638: PUSH
53639: LD_VAR 0 4
53643: ARRAY
53644: EQUAL
53645: IFFALSE 53661
// begin result := i ;
53647: LD_ADDR_VAR 0 3
53651: PUSH
53652: LD_VAR 0 4
53656: ST_TO_ADDR
// exit ;
53657: POP
53658: POP
53659: GO 53665
// end ;
53661: GO 53626
53663: POP
53664: POP
// end ;
53665: LD_VAR 0 3
53669: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53670: LD_INT 0
53672: PPUSH
// vc_chassis := chassis ;
53673: LD_ADDR_OWVAR 37
53677: PUSH
53678: LD_VAR 0 1
53682: ST_TO_ADDR
// vc_engine := engine ;
53683: LD_ADDR_OWVAR 39
53687: PUSH
53688: LD_VAR 0 2
53692: ST_TO_ADDR
// vc_control := control ;
53693: LD_ADDR_OWVAR 38
53697: PUSH
53698: LD_VAR 0 3
53702: ST_TO_ADDR
// vc_weapon := weapon ;
53703: LD_ADDR_OWVAR 40
53707: PUSH
53708: LD_VAR 0 4
53712: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53713: LD_ADDR_OWVAR 41
53717: PUSH
53718: LD_VAR 0 5
53722: ST_TO_ADDR
// end ;
53723: LD_VAR 0 6
53727: RET
// export function WantPlant ( unit ) ; var task ; begin
53728: LD_INT 0
53730: PPUSH
53731: PPUSH
// result := false ;
53732: LD_ADDR_VAR 0 2
53736: PUSH
53737: LD_INT 0
53739: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53740: LD_ADDR_VAR 0 3
53744: PUSH
53745: LD_VAR 0 1
53749: PPUSH
53750: CALL_OW 437
53754: ST_TO_ADDR
// if task then
53755: LD_VAR 0 3
53759: IFFALSE 53787
// if task [ 1 ] [ 1 ] = p then
53761: LD_VAR 0 3
53765: PUSH
53766: LD_INT 1
53768: ARRAY
53769: PUSH
53770: LD_INT 1
53772: ARRAY
53773: PUSH
53774: LD_STRING p
53776: EQUAL
53777: IFFALSE 53787
// result := true ;
53779: LD_ADDR_VAR 0 2
53783: PUSH
53784: LD_INT 1
53786: ST_TO_ADDR
// end ;
53787: LD_VAR 0 2
53791: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53792: LD_INT 0
53794: PPUSH
53795: PPUSH
53796: PPUSH
53797: PPUSH
// if pos < 1 then
53798: LD_VAR 0 2
53802: PUSH
53803: LD_INT 1
53805: LESS
53806: IFFALSE 53810
// exit ;
53808: GO 54113
// if pos = 1 then
53810: LD_VAR 0 2
53814: PUSH
53815: LD_INT 1
53817: EQUAL
53818: IFFALSE 53851
// result := Replace ( arr , pos [ 1 ] , value ) else
53820: LD_ADDR_VAR 0 4
53824: PUSH
53825: LD_VAR 0 1
53829: PPUSH
53830: LD_VAR 0 2
53834: PUSH
53835: LD_INT 1
53837: ARRAY
53838: PPUSH
53839: LD_VAR 0 3
53843: PPUSH
53844: CALL_OW 1
53848: ST_TO_ADDR
53849: GO 54113
// begin tmp := arr ;
53851: LD_ADDR_VAR 0 6
53855: PUSH
53856: LD_VAR 0 1
53860: ST_TO_ADDR
// s_arr := [ tmp ] ;
53861: LD_ADDR_VAR 0 7
53865: PUSH
53866: LD_VAR 0 6
53870: PUSH
53871: EMPTY
53872: LIST
53873: ST_TO_ADDR
// for i = 1 to pos - 1 do
53874: LD_ADDR_VAR 0 5
53878: PUSH
53879: DOUBLE
53880: LD_INT 1
53882: DEC
53883: ST_TO_ADDR
53884: LD_VAR 0 2
53888: PUSH
53889: LD_INT 1
53891: MINUS
53892: PUSH
53893: FOR_TO
53894: IFFALSE 53939
// begin tmp := tmp [ pos [ i ] ] ;
53896: LD_ADDR_VAR 0 6
53900: PUSH
53901: LD_VAR 0 6
53905: PUSH
53906: LD_VAR 0 2
53910: PUSH
53911: LD_VAR 0 5
53915: ARRAY
53916: ARRAY
53917: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53918: LD_ADDR_VAR 0 7
53922: PUSH
53923: LD_VAR 0 7
53927: PUSH
53928: LD_VAR 0 6
53932: PUSH
53933: EMPTY
53934: LIST
53935: ADD
53936: ST_TO_ADDR
// end ;
53937: GO 53893
53939: POP
53940: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53941: LD_ADDR_VAR 0 6
53945: PUSH
53946: LD_VAR 0 6
53950: PPUSH
53951: LD_VAR 0 2
53955: PUSH
53956: LD_VAR 0 2
53960: ARRAY
53961: PPUSH
53962: LD_VAR 0 3
53966: PPUSH
53967: CALL_OW 1
53971: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53972: LD_ADDR_VAR 0 7
53976: PUSH
53977: LD_VAR 0 7
53981: PPUSH
53982: LD_VAR 0 7
53986: PPUSH
53987: LD_VAR 0 6
53991: PPUSH
53992: CALL_OW 1
53996: ST_TO_ADDR
// for i = s_arr downto 2 do
53997: LD_ADDR_VAR 0 5
54001: PUSH
54002: DOUBLE
54003: LD_VAR 0 7
54007: INC
54008: ST_TO_ADDR
54009: LD_INT 2
54011: PUSH
54012: FOR_DOWNTO
54013: IFFALSE 54097
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54015: LD_ADDR_VAR 0 6
54019: PUSH
54020: LD_VAR 0 7
54024: PUSH
54025: LD_VAR 0 5
54029: PUSH
54030: LD_INT 1
54032: MINUS
54033: ARRAY
54034: PPUSH
54035: LD_VAR 0 2
54039: PUSH
54040: LD_VAR 0 5
54044: PUSH
54045: LD_INT 1
54047: MINUS
54048: ARRAY
54049: PPUSH
54050: LD_VAR 0 7
54054: PUSH
54055: LD_VAR 0 5
54059: ARRAY
54060: PPUSH
54061: CALL_OW 1
54065: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54066: LD_ADDR_VAR 0 7
54070: PUSH
54071: LD_VAR 0 7
54075: PPUSH
54076: LD_VAR 0 5
54080: PUSH
54081: LD_INT 1
54083: MINUS
54084: PPUSH
54085: LD_VAR 0 6
54089: PPUSH
54090: CALL_OW 1
54094: ST_TO_ADDR
// end ;
54095: GO 54012
54097: POP
54098: POP
// result := s_arr [ 1 ] ;
54099: LD_ADDR_VAR 0 4
54103: PUSH
54104: LD_VAR 0 7
54108: PUSH
54109: LD_INT 1
54111: ARRAY
54112: ST_TO_ADDR
// end ; end ;
54113: LD_VAR 0 4
54117: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54118: LD_INT 0
54120: PPUSH
54121: PPUSH
// if not list then
54122: LD_VAR 0 1
54126: NOT
54127: IFFALSE 54131
// exit ;
54129: GO 54222
// i := list [ pos1 ] ;
54131: LD_ADDR_VAR 0 5
54135: PUSH
54136: LD_VAR 0 1
54140: PUSH
54141: LD_VAR 0 2
54145: ARRAY
54146: ST_TO_ADDR
// if not i then
54147: LD_VAR 0 5
54151: NOT
54152: IFFALSE 54156
// exit ;
54154: GO 54222
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54156: LD_ADDR_VAR 0 1
54160: PUSH
54161: LD_VAR 0 1
54165: PPUSH
54166: LD_VAR 0 2
54170: PPUSH
54171: LD_VAR 0 1
54175: PUSH
54176: LD_VAR 0 3
54180: ARRAY
54181: PPUSH
54182: CALL_OW 1
54186: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54187: LD_ADDR_VAR 0 1
54191: PUSH
54192: LD_VAR 0 1
54196: PPUSH
54197: LD_VAR 0 3
54201: PPUSH
54202: LD_VAR 0 5
54206: PPUSH
54207: CALL_OW 1
54211: ST_TO_ADDR
// result := list ;
54212: LD_ADDR_VAR 0 4
54216: PUSH
54217: LD_VAR 0 1
54221: ST_TO_ADDR
// end ;
54222: LD_VAR 0 4
54226: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54227: LD_INT 0
54229: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54230: LD_ADDR_VAR 0 5
54234: PUSH
54235: LD_VAR 0 1
54239: PPUSH
54240: CALL_OW 250
54244: PPUSH
54245: LD_VAR 0 1
54249: PPUSH
54250: CALL_OW 251
54254: PPUSH
54255: LD_VAR 0 2
54259: PPUSH
54260: LD_VAR 0 3
54264: PPUSH
54265: LD_VAR 0 4
54269: PPUSH
54270: CALL 54280 0 5
54274: ST_TO_ADDR
// end ;
54275: LD_VAR 0 5
54279: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54280: LD_INT 0
54282: PPUSH
54283: PPUSH
54284: PPUSH
54285: PPUSH
// if not list then
54286: LD_VAR 0 3
54290: NOT
54291: IFFALSE 54295
// exit ;
54293: GO 54683
// result := [ ] ;
54295: LD_ADDR_VAR 0 6
54299: PUSH
54300: EMPTY
54301: ST_TO_ADDR
// for i in list do
54302: LD_ADDR_VAR 0 7
54306: PUSH
54307: LD_VAR 0 3
54311: PUSH
54312: FOR_IN
54313: IFFALSE 54515
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54315: LD_ADDR_VAR 0 9
54319: PUSH
54320: LD_VAR 0 7
54324: PPUSH
54325: LD_VAR 0 1
54329: PPUSH
54330: LD_VAR 0 2
54334: PPUSH
54335: CALL_OW 297
54339: ST_TO_ADDR
// if not result then
54340: LD_VAR 0 6
54344: NOT
54345: IFFALSE 54371
// result := [ [ i , tmp ] ] else
54347: LD_ADDR_VAR 0 6
54351: PUSH
54352: LD_VAR 0 7
54356: PUSH
54357: LD_VAR 0 9
54361: PUSH
54362: EMPTY
54363: LIST
54364: LIST
54365: PUSH
54366: EMPTY
54367: LIST
54368: ST_TO_ADDR
54369: GO 54513
// begin if result [ result ] [ 2 ] < tmp then
54371: LD_VAR 0 6
54375: PUSH
54376: LD_VAR 0 6
54380: ARRAY
54381: PUSH
54382: LD_INT 2
54384: ARRAY
54385: PUSH
54386: LD_VAR 0 9
54390: LESS
54391: IFFALSE 54433
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54393: LD_ADDR_VAR 0 6
54397: PUSH
54398: LD_VAR 0 6
54402: PPUSH
54403: LD_VAR 0 6
54407: PUSH
54408: LD_INT 1
54410: PLUS
54411: PPUSH
54412: LD_VAR 0 7
54416: PUSH
54417: LD_VAR 0 9
54421: PUSH
54422: EMPTY
54423: LIST
54424: LIST
54425: PPUSH
54426: CALL_OW 2
54430: ST_TO_ADDR
54431: GO 54513
// for j = 1 to result do
54433: LD_ADDR_VAR 0 8
54437: PUSH
54438: DOUBLE
54439: LD_INT 1
54441: DEC
54442: ST_TO_ADDR
54443: LD_VAR 0 6
54447: PUSH
54448: FOR_TO
54449: IFFALSE 54511
// begin if tmp < result [ j ] [ 2 ] then
54451: LD_VAR 0 9
54455: PUSH
54456: LD_VAR 0 6
54460: PUSH
54461: LD_VAR 0 8
54465: ARRAY
54466: PUSH
54467: LD_INT 2
54469: ARRAY
54470: LESS
54471: IFFALSE 54509
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54473: LD_ADDR_VAR 0 6
54477: PUSH
54478: LD_VAR 0 6
54482: PPUSH
54483: LD_VAR 0 8
54487: PPUSH
54488: LD_VAR 0 7
54492: PUSH
54493: LD_VAR 0 9
54497: PUSH
54498: EMPTY
54499: LIST
54500: LIST
54501: PPUSH
54502: CALL_OW 2
54506: ST_TO_ADDR
// break ;
54507: GO 54511
// end ; end ;
54509: GO 54448
54511: POP
54512: POP
// end ; end ;
54513: GO 54312
54515: POP
54516: POP
// if result and not asc then
54517: LD_VAR 0 6
54521: PUSH
54522: LD_VAR 0 4
54526: NOT
54527: AND
54528: IFFALSE 54603
// begin tmp := result ;
54530: LD_ADDR_VAR 0 9
54534: PUSH
54535: LD_VAR 0 6
54539: ST_TO_ADDR
// for i = tmp downto 1 do
54540: LD_ADDR_VAR 0 7
54544: PUSH
54545: DOUBLE
54546: LD_VAR 0 9
54550: INC
54551: ST_TO_ADDR
54552: LD_INT 1
54554: PUSH
54555: FOR_DOWNTO
54556: IFFALSE 54601
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54558: LD_ADDR_VAR 0 6
54562: PUSH
54563: LD_VAR 0 6
54567: PPUSH
54568: LD_VAR 0 9
54572: PUSH
54573: LD_VAR 0 7
54577: MINUS
54578: PUSH
54579: LD_INT 1
54581: PLUS
54582: PPUSH
54583: LD_VAR 0 9
54587: PUSH
54588: LD_VAR 0 7
54592: ARRAY
54593: PPUSH
54594: CALL_OW 1
54598: ST_TO_ADDR
54599: GO 54555
54601: POP
54602: POP
// end ; tmp := [ ] ;
54603: LD_ADDR_VAR 0 9
54607: PUSH
54608: EMPTY
54609: ST_TO_ADDR
// if mode then
54610: LD_VAR 0 5
54614: IFFALSE 54683
// begin for i = 1 to result do
54616: LD_ADDR_VAR 0 7
54620: PUSH
54621: DOUBLE
54622: LD_INT 1
54624: DEC
54625: ST_TO_ADDR
54626: LD_VAR 0 6
54630: PUSH
54631: FOR_TO
54632: IFFALSE 54671
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54634: LD_ADDR_VAR 0 9
54638: PUSH
54639: LD_VAR 0 9
54643: PPUSH
54644: LD_VAR 0 7
54648: PPUSH
54649: LD_VAR 0 6
54653: PUSH
54654: LD_VAR 0 7
54658: ARRAY
54659: PUSH
54660: LD_INT 1
54662: ARRAY
54663: PPUSH
54664: CALL_OW 1
54668: ST_TO_ADDR
54669: GO 54631
54671: POP
54672: POP
// result := tmp ;
54673: LD_ADDR_VAR 0 6
54677: PUSH
54678: LD_VAR 0 9
54682: ST_TO_ADDR
// end ; end ;
54683: LD_VAR 0 6
54687: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54688: LD_INT 0
54690: PPUSH
54691: PPUSH
54692: PPUSH
54693: PPUSH
54694: PPUSH
54695: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54696: LD_ADDR_VAR 0 5
54700: PUSH
54701: LD_INT 0
54703: PUSH
54704: LD_INT 0
54706: PUSH
54707: LD_INT 0
54709: PUSH
54710: EMPTY
54711: PUSH
54712: EMPTY
54713: LIST
54714: LIST
54715: LIST
54716: LIST
54717: ST_TO_ADDR
// if not x or not y then
54718: LD_VAR 0 2
54722: NOT
54723: PUSH
54724: LD_VAR 0 3
54728: NOT
54729: OR
54730: IFFALSE 54734
// exit ;
54732: GO 56384
// if not range then
54734: LD_VAR 0 4
54738: NOT
54739: IFFALSE 54749
// range := 10 ;
54741: LD_ADDR_VAR 0 4
54745: PUSH
54746: LD_INT 10
54748: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54749: LD_ADDR_VAR 0 8
54753: PUSH
54754: LD_INT 81
54756: PUSH
54757: LD_VAR 0 1
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: PUSH
54766: LD_INT 92
54768: PUSH
54769: LD_VAR 0 2
54773: PUSH
54774: LD_VAR 0 3
54778: PUSH
54779: LD_VAR 0 4
54783: PUSH
54784: EMPTY
54785: LIST
54786: LIST
54787: LIST
54788: LIST
54789: PUSH
54790: LD_INT 3
54792: PUSH
54793: LD_INT 21
54795: PUSH
54796: LD_INT 3
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: PUSH
54807: EMPTY
54808: LIST
54809: LIST
54810: LIST
54811: PPUSH
54812: CALL_OW 69
54816: ST_TO_ADDR
// if not tmp then
54817: LD_VAR 0 8
54821: NOT
54822: IFFALSE 54826
// exit ;
54824: GO 56384
// for i in tmp do
54826: LD_ADDR_VAR 0 6
54830: PUSH
54831: LD_VAR 0 8
54835: PUSH
54836: FOR_IN
54837: IFFALSE 56359
// begin points := [ 0 , 0 , 0 ] ;
54839: LD_ADDR_VAR 0 9
54843: PUSH
54844: LD_INT 0
54846: PUSH
54847: LD_INT 0
54849: PUSH
54850: LD_INT 0
54852: PUSH
54853: EMPTY
54854: LIST
54855: LIST
54856: LIST
54857: ST_TO_ADDR
// bpoints := 1 ;
54858: LD_ADDR_VAR 0 10
54862: PUSH
54863: LD_INT 1
54865: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54866: LD_VAR 0 6
54870: PPUSH
54871: CALL_OW 247
54875: PUSH
54876: LD_INT 1
54878: DOUBLE
54879: EQUAL
54880: IFTRUE 54884
54882: GO 55462
54884: POP
// begin if GetClass ( i ) = 1 then
54885: LD_VAR 0 6
54889: PPUSH
54890: CALL_OW 257
54894: PUSH
54895: LD_INT 1
54897: EQUAL
54898: IFFALSE 54919
// points := [ 10 , 5 , 3 ] ;
54900: LD_ADDR_VAR 0 9
54904: PUSH
54905: LD_INT 10
54907: PUSH
54908: LD_INT 5
54910: PUSH
54911: LD_INT 3
54913: PUSH
54914: EMPTY
54915: LIST
54916: LIST
54917: LIST
54918: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54919: LD_VAR 0 6
54923: PPUSH
54924: CALL_OW 257
54928: PUSH
54929: LD_INT 2
54931: PUSH
54932: LD_INT 3
54934: PUSH
54935: LD_INT 4
54937: PUSH
54938: EMPTY
54939: LIST
54940: LIST
54941: LIST
54942: IN
54943: IFFALSE 54964
// points := [ 3 , 2 , 1 ] ;
54945: LD_ADDR_VAR 0 9
54949: PUSH
54950: LD_INT 3
54952: PUSH
54953: LD_INT 2
54955: PUSH
54956: LD_INT 1
54958: PUSH
54959: EMPTY
54960: LIST
54961: LIST
54962: LIST
54963: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54964: LD_VAR 0 6
54968: PPUSH
54969: CALL_OW 257
54973: PUSH
54974: LD_INT 5
54976: EQUAL
54977: IFFALSE 54998
// points := [ 130 , 5 , 2 ] ;
54979: LD_ADDR_VAR 0 9
54983: PUSH
54984: LD_INT 130
54986: PUSH
54987: LD_INT 5
54989: PUSH
54990: LD_INT 2
54992: PUSH
54993: EMPTY
54994: LIST
54995: LIST
54996: LIST
54997: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54998: LD_VAR 0 6
55002: PPUSH
55003: CALL_OW 257
55007: PUSH
55008: LD_INT 8
55010: EQUAL
55011: IFFALSE 55032
// points := [ 35 , 35 , 30 ] ;
55013: LD_ADDR_VAR 0 9
55017: PUSH
55018: LD_INT 35
55020: PUSH
55021: LD_INT 35
55023: PUSH
55024: LD_INT 30
55026: PUSH
55027: EMPTY
55028: LIST
55029: LIST
55030: LIST
55031: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55032: LD_VAR 0 6
55036: PPUSH
55037: CALL_OW 257
55041: PUSH
55042: LD_INT 9
55044: EQUAL
55045: IFFALSE 55066
// points := [ 20 , 55 , 40 ] ;
55047: LD_ADDR_VAR 0 9
55051: PUSH
55052: LD_INT 20
55054: PUSH
55055: LD_INT 55
55057: PUSH
55058: LD_INT 40
55060: PUSH
55061: EMPTY
55062: LIST
55063: LIST
55064: LIST
55065: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55066: LD_VAR 0 6
55070: PPUSH
55071: CALL_OW 257
55075: PUSH
55076: LD_INT 12
55078: PUSH
55079: LD_INT 16
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: IN
55086: IFFALSE 55107
// points := [ 5 , 3 , 2 ] ;
55088: LD_ADDR_VAR 0 9
55092: PUSH
55093: LD_INT 5
55095: PUSH
55096: LD_INT 3
55098: PUSH
55099: LD_INT 2
55101: PUSH
55102: EMPTY
55103: LIST
55104: LIST
55105: LIST
55106: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55107: LD_VAR 0 6
55111: PPUSH
55112: CALL_OW 257
55116: PUSH
55117: LD_INT 17
55119: EQUAL
55120: IFFALSE 55141
// points := [ 100 , 50 , 75 ] ;
55122: LD_ADDR_VAR 0 9
55126: PUSH
55127: LD_INT 100
55129: PUSH
55130: LD_INT 50
55132: PUSH
55133: LD_INT 75
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: LIST
55140: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55141: LD_VAR 0 6
55145: PPUSH
55146: CALL_OW 257
55150: PUSH
55151: LD_INT 15
55153: EQUAL
55154: IFFALSE 55175
// points := [ 10 , 5 , 3 ] ;
55156: LD_ADDR_VAR 0 9
55160: PUSH
55161: LD_INT 10
55163: PUSH
55164: LD_INT 5
55166: PUSH
55167: LD_INT 3
55169: PUSH
55170: EMPTY
55171: LIST
55172: LIST
55173: LIST
55174: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55175: LD_VAR 0 6
55179: PPUSH
55180: CALL_OW 257
55184: PUSH
55185: LD_INT 14
55187: EQUAL
55188: IFFALSE 55209
// points := [ 10 , 0 , 0 ] ;
55190: LD_ADDR_VAR 0 9
55194: PUSH
55195: LD_INT 10
55197: PUSH
55198: LD_INT 0
55200: PUSH
55201: LD_INT 0
55203: PUSH
55204: EMPTY
55205: LIST
55206: LIST
55207: LIST
55208: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55209: LD_VAR 0 6
55213: PPUSH
55214: CALL_OW 257
55218: PUSH
55219: LD_INT 11
55221: EQUAL
55222: IFFALSE 55243
// points := [ 30 , 10 , 5 ] ;
55224: LD_ADDR_VAR 0 9
55228: PUSH
55229: LD_INT 30
55231: PUSH
55232: LD_INT 10
55234: PUSH
55235: LD_INT 5
55237: PUSH
55238: EMPTY
55239: LIST
55240: LIST
55241: LIST
55242: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55243: LD_VAR 0 1
55247: PPUSH
55248: LD_INT 5
55250: PPUSH
55251: CALL_OW 321
55255: PUSH
55256: LD_INT 2
55258: EQUAL
55259: IFFALSE 55276
// bpoints := bpoints * 1.8 ;
55261: LD_ADDR_VAR 0 10
55265: PUSH
55266: LD_VAR 0 10
55270: PUSH
55271: LD_REAL  1.80000000000000E+0000
55274: MUL
55275: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55276: LD_VAR 0 6
55280: PPUSH
55281: CALL_OW 257
55285: PUSH
55286: LD_INT 1
55288: PUSH
55289: LD_INT 2
55291: PUSH
55292: LD_INT 3
55294: PUSH
55295: LD_INT 4
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: IN
55304: PUSH
55305: LD_VAR 0 1
55309: PPUSH
55310: LD_INT 51
55312: PPUSH
55313: CALL_OW 321
55317: PUSH
55318: LD_INT 2
55320: EQUAL
55321: AND
55322: IFFALSE 55339
// bpoints := bpoints * 1.2 ;
55324: LD_ADDR_VAR 0 10
55328: PUSH
55329: LD_VAR 0 10
55333: PUSH
55334: LD_REAL  1.20000000000000E+0000
55337: MUL
55338: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55339: LD_VAR 0 6
55343: PPUSH
55344: CALL_OW 257
55348: PUSH
55349: LD_INT 5
55351: PUSH
55352: LD_INT 7
55354: PUSH
55355: LD_INT 9
55357: PUSH
55358: EMPTY
55359: LIST
55360: LIST
55361: LIST
55362: IN
55363: PUSH
55364: LD_VAR 0 1
55368: PPUSH
55369: LD_INT 52
55371: PPUSH
55372: CALL_OW 321
55376: PUSH
55377: LD_INT 2
55379: EQUAL
55380: AND
55381: IFFALSE 55398
// bpoints := bpoints * 1.5 ;
55383: LD_ADDR_VAR 0 10
55387: PUSH
55388: LD_VAR 0 10
55392: PUSH
55393: LD_REAL  1.50000000000000E+0000
55396: MUL
55397: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55398: LD_VAR 0 1
55402: PPUSH
55403: LD_INT 66
55405: PPUSH
55406: CALL_OW 321
55410: PUSH
55411: LD_INT 2
55413: EQUAL
55414: IFFALSE 55431
// bpoints := bpoints * 1.1 ;
55416: LD_ADDR_VAR 0 10
55420: PUSH
55421: LD_VAR 0 10
55425: PUSH
55426: LD_REAL  1.10000000000000E+0000
55429: MUL
55430: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55431: LD_ADDR_VAR 0 10
55435: PUSH
55436: LD_VAR 0 10
55440: PUSH
55441: LD_VAR 0 6
55445: PPUSH
55446: LD_INT 1
55448: PPUSH
55449: CALL_OW 259
55453: PUSH
55454: LD_REAL  1.15000000000000E+0000
55457: MUL
55458: MUL
55459: ST_TO_ADDR
// end ; unit_vehicle :
55460: GO 56288
55462: LD_INT 2
55464: DOUBLE
55465: EQUAL
55466: IFTRUE 55470
55468: GO 56276
55470: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55471: LD_VAR 0 6
55475: PPUSH
55476: CALL_OW 264
55480: PUSH
55481: LD_INT 2
55483: PUSH
55484: LD_INT 42
55486: PUSH
55487: LD_INT 24
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: LIST
55494: IN
55495: IFFALSE 55516
// points := [ 25 , 5 , 3 ] ;
55497: LD_ADDR_VAR 0 9
55501: PUSH
55502: LD_INT 25
55504: PUSH
55505: LD_INT 5
55507: PUSH
55508: LD_INT 3
55510: PUSH
55511: EMPTY
55512: LIST
55513: LIST
55514: LIST
55515: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55516: LD_VAR 0 6
55520: PPUSH
55521: CALL_OW 264
55525: PUSH
55526: LD_INT 4
55528: PUSH
55529: LD_INT 43
55531: PUSH
55532: LD_INT 25
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: LIST
55539: IN
55540: IFFALSE 55561
// points := [ 40 , 15 , 5 ] ;
55542: LD_ADDR_VAR 0 9
55546: PUSH
55547: LD_INT 40
55549: PUSH
55550: LD_INT 15
55552: PUSH
55553: LD_INT 5
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: LIST
55560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55561: LD_VAR 0 6
55565: PPUSH
55566: CALL_OW 264
55570: PUSH
55571: LD_INT 3
55573: PUSH
55574: LD_INT 23
55576: PUSH
55577: EMPTY
55578: LIST
55579: LIST
55580: IN
55581: IFFALSE 55602
// points := [ 7 , 25 , 8 ] ;
55583: LD_ADDR_VAR 0 9
55587: PUSH
55588: LD_INT 7
55590: PUSH
55591: LD_INT 25
55593: PUSH
55594: LD_INT 8
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: LIST
55601: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55602: LD_VAR 0 6
55606: PPUSH
55607: CALL_OW 264
55611: PUSH
55612: LD_INT 5
55614: PUSH
55615: LD_INT 27
55617: PUSH
55618: LD_INT 44
55620: PUSH
55621: EMPTY
55622: LIST
55623: LIST
55624: LIST
55625: IN
55626: IFFALSE 55647
// points := [ 14 , 50 , 16 ] ;
55628: LD_ADDR_VAR 0 9
55632: PUSH
55633: LD_INT 14
55635: PUSH
55636: LD_INT 50
55638: PUSH
55639: LD_INT 16
55641: PUSH
55642: EMPTY
55643: LIST
55644: LIST
55645: LIST
55646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55647: LD_VAR 0 6
55651: PPUSH
55652: CALL_OW 264
55656: PUSH
55657: LD_INT 6
55659: PUSH
55660: LD_INT 46
55662: PUSH
55663: EMPTY
55664: LIST
55665: LIST
55666: IN
55667: IFFALSE 55688
// points := [ 32 , 120 , 70 ] ;
55669: LD_ADDR_VAR 0 9
55673: PUSH
55674: LD_INT 32
55676: PUSH
55677: LD_INT 120
55679: PUSH
55680: LD_INT 70
55682: PUSH
55683: EMPTY
55684: LIST
55685: LIST
55686: LIST
55687: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55688: LD_VAR 0 6
55692: PPUSH
55693: CALL_OW 264
55697: PUSH
55698: LD_INT 7
55700: PUSH
55701: LD_INT 28
55703: PUSH
55704: LD_INT 45
55706: PUSH
55707: LD_INT 92
55709: PUSH
55710: EMPTY
55711: LIST
55712: LIST
55713: LIST
55714: LIST
55715: IN
55716: IFFALSE 55737
// points := [ 35 , 20 , 45 ] ;
55718: LD_ADDR_VAR 0 9
55722: PUSH
55723: LD_INT 35
55725: PUSH
55726: LD_INT 20
55728: PUSH
55729: LD_INT 45
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: LIST
55736: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55737: LD_VAR 0 6
55741: PPUSH
55742: CALL_OW 264
55746: PUSH
55747: LD_INT 47
55749: PUSH
55750: EMPTY
55751: LIST
55752: IN
55753: IFFALSE 55774
// points := [ 67 , 45 , 75 ] ;
55755: LD_ADDR_VAR 0 9
55759: PUSH
55760: LD_INT 67
55762: PUSH
55763: LD_INT 45
55765: PUSH
55766: LD_INT 75
55768: PUSH
55769: EMPTY
55770: LIST
55771: LIST
55772: LIST
55773: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55774: LD_VAR 0 6
55778: PPUSH
55779: CALL_OW 264
55783: PUSH
55784: LD_INT 26
55786: PUSH
55787: EMPTY
55788: LIST
55789: IN
55790: IFFALSE 55811
// points := [ 120 , 30 , 80 ] ;
55792: LD_ADDR_VAR 0 9
55796: PUSH
55797: LD_INT 120
55799: PUSH
55800: LD_INT 30
55802: PUSH
55803: LD_INT 80
55805: PUSH
55806: EMPTY
55807: LIST
55808: LIST
55809: LIST
55810: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55811: LD_VAR 0 6
55815: PPUSH
55816: CALL_OW 264
55820: PUSH
55821: LD_INT 22
55823: PUSH
55824: EMPTY
55825: LIST
55826: IN
55827: IFFALSE 55848
// points := [ 40 , 1 , 1 ] ;
55829: LD_ADDR_VAR 0 9
55833: PUSH
55834: LD_INT 40
55836: PUSH
55837: LD_INT 1
55839: PUSH
55840: LD_INT 1
55842: PUSH
55843: EMPTY
55844: LIST
55845: LIST
55846: LIST
55847: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55848: LD_VAR 0 6
55852: PPUSH
55853: CALL_OW 264
55857: PUSH
55858: LD_INT 29
55860: PUSH
55861: EMPTY
55862: LIST
55863: IN
55864: IFFALSE 55885
// points := [ 70 , 200 , 400 ] ;
55866: LD_ADDR_VAR 0 9
55870: PUSH
55871: LD_INT 70
55873: PUSH
55874: LD_INT 200
55876: PUSH
55877: LD_INT 400
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: LIST
55884: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55885: LD_VAR 0 6
55889: PPUSH
55890: CALL_OW 264
55894: PUSH
55895: LD_INT 14
55897: PUSH
55898: LD_INT 53
55900: PUSH
55901: EMPTY
55902: LIST
55903: LIST
55904: IN
55905: IFFALSE 55926
// points := [ 40 , 10 , 20 ] ;
55907: LD_ADDR_VAR 0 9
55911: PUSH
55912: LD_INT 40
55914: PUSH
55915: LD_INT 10
55917: PUSH
55918: LD_INT 20
55920: PUSH
55921: EMPTY
55922: LIST
55923: LIST
55924: LIST
55925: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55926: LD_VAR 0 6
55930: PPUSH
55931: CALL_OW 264
55935: PUSH
55936: LD_INT 9
55938: PUSH
55939: EMPTY
55940: LIST
55941: IN
55942: IFFALSE 55963
// points := [ 5 , 70 , 20 ] ;
55944: LD_ADDR_VAR 0 9
55948: PUSH
55949: LD_INT 5
55951: PUSH
55952: LD_INT 70
55954: PUSH
55955: LD_INT 20
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: LIST
55962: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55963: LD_VAR 0 6
55967: PPUSH
55968: CALL_OW 264
55972: PUSH
55973: LD_INT 10
55975: PUSH
55976: EMPTY
55977: LIST
55978: IN
55979: IFFALSE 56000
// points := [ 35 , 110 , 70 ] ;
55981: LD_ADDR_VAR 0 9
55985: PUSH
55986: LD_INT 35
55988: PUSH
55989: LD_INT 110
55991: PUSH
55992: LD_INT 70
55994: PUSH
55995: EMPTY
55996: LIST
55997: LIST
55998: LIST
55999: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56000: LD_VAR 0 6
56004: PPUSH
56005: CALL_OW 265
56009: PUSH
56010: LD_INT 25
56012: EQUAL
56013: IFFALSE 56034
// points := [ 80 , 65 , 100 ] ;
56015: LD_ADDR_VAR 0 9
56019: PUSH
56020: LD_INT 80
56022: PUSH
56023: LD_INT 65
56025: PUSH
56026: LD_INT 100
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: LIST
56033: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56034: LD_VAR 0 6
56038: PPUSH
56039: CALL_OW 263
56043: PUSH
56044: LD_INT 1
56046: EQUAL
56047: IFFALSE 56082
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56049: LD_ADDR_VAR 0 10
56053: PUSH
56054: LD_VAR 0 10
56058: PUSH
56059: LD_VAR 0 6
56063: PPUSH
56064: CALL_OW 311
56068: PPUSH
56069: LD_INT 3
56071: PPUSH
56072: CALL_OW 259
56076: PUSH
56077: LD_INT 4
56079: MUL
56080: MUL
56081: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56082: LD_VAR 0 6
56086: PPUSH
56087: CALL_OW 263
56091: PUSH
56092: LD_INT 2
56094: EQUAL
56095: IFFALSE 56146
// begin j := IsControledBy ( i ) ;
56097: LD_ADDR_VAR 0 7
56101: PUSH
56102: LD_VAR 0 6
56106: PPUSH
56107: CALL_OW 312
56111: ST_TO_ADDR
// if j then
56112: LD_VAR 0 7
56116: IFFALSE 56146
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56118: LD_ADDR_VAR 0 10
56122: PUSH
56123: LD_VAR 0 10
56127: PUSH
56128: LD_VAR 0 7
56132: PPUSH
56133: LD_INT 3
56135: PPUSH
56136: CALL_OW 259
56140: PUSH
56141: LD_INT 3
56143: MUL
56144: MUL
56145: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56146: LD_VAR 0 6
56150: PPUSH
56151: CALL_OW 264
56155: PUSH
56156: LD_INT 5
56158: PUSH
56159: LD_INT 6
56161: PUSH
56162: LD_INT 46
56164: PUSH
56165: LD_INT 44
56167: PUSH
56168: LD_INT 47
56170: PUSH
56171: LD_INT 45
56173: PUSH
56174: LD_INT 28
56176: PUSH
56177: LD_INT 7
56179: PUSH
56180: LD_INT 27
56182: PUSH
56183: LD_INT 29
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: LIST
56190: LIST
56191: LIST
56192: LIST
56193: LIST
56194: LIST
56195: LIST
56196: LIST
56197: IN
56198: PUSH
56199: LD_VAR 0 1
56203: PPUSH
56204: LD_INT 52
56206: PPUSH
56207: CALL_OW 321
56211: PUSH
56212: LD_INT 2
56214: EQUAL
56215: AND
56216: IFFALSE 56233
// bpoints := bpoints * 1.2 ;
56218: LD_ADDR_VAR 0 10
56222: PUSH
56223: LD_VAR 0 10
56227: PUSH
56228: LD_REAL  1.20000000000000E+0000
56231: MUL
56232: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56233: LD_VAR 0 6
56237: PPUSH
56238: CALL_OW 264
56242: PUSH
56243: LD_INT 6
56245: PUSH
56246: LD_INT 46
56248: PUSH
56249: LD_INT 47
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: LIST
56256: IN
56257: IFFALSE 56274
// bpoints := bpoints * 1.2 ;
56259: LD_ADDR_VAR 0 10
56263: PUSH
56264: LD_VAR 0 10
56268: PUSH
56269: LD_REAL  1.20000000000000E+0000
56272: MUL
56273: ST_TO_ADDR
// end ; unit_building :
56274: GO 56288
56276: LD_INT 3
56278: DOUBLE
56279: EQUAL
56280: IFTRUE 56284
56282: GO 56287
56284: POP
// ; end ;
56285: GO 56288
56287: POP
// for j = 1 to 3 do
56288: LD_ADDR_VAR 0 7
56292: PUSH
56293: DOUBLE
56294: LD_INT 1
56296: DEC
56297: ST_TO_ADDR
56298: LD_INT 3
56300: PUSH
56301: FOR_TO
56302: IFFALSE 56355
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56304: LD_ADDR_VAR 0 5
56308: PUSH
56309: LD_VAR 0 5
56313: PPUSH
56314: LD_VAR 0 7
56318: PPUSH
56319: LD_VAR 0 5
56323: PUSH
56324: LD_VAR 0 7
56328: ARRAY
56329: PUSH
56330: LD_VAR 0 9
56334: PUSH
56335: LD_VAR 0 7
56339: ARRAY
56340: PUSH
56341: LD_VAR 0 10
56345: MUL
56346: PLUS
56347: PPUSH
56348: CALL_OW 1
56352: ST_TO_ADDR
56353: GO 56301
56355: POP
56356: POP
// end ;
56357: GO 54836
56359: POP
56360: POP
// result := Replace ( result , 4 , tmp ) ;
56361: LD_ADDR_VAR 0 5
56365: PUSH
56366: LD_VAR 0 5
56370: PPUSH
56371: LD_INT 4
56373: PPUSH
56374: LD_VAR 0 8
56378: PPUSH
56379: CALL_OW 1
56383: ST_TO_ADDR
// end ;
56384: LD_VAR 0 5
56388: RET
// export function DangerAtRange ( unit , range ) ; begin
56389: LD_INT 0
56391: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56392: LD_ADDR_VAR 0 3
56396: PUSH
56397: LD_VAR 0 1
56401: PPUSH
56402: CALL_OW 255
56406: PPUSH
56407: LD_VAR 0 1
56411: PPUSH
56412: CALL_OW 250
56416: PPUSH
56417: LD_VAR 0 1
56421: PPUSH
56422: CALL_OW 251
56426: PPUSH
56427: LD_VAR 0 2
56431: PPUSH
56432: CALL 54688 0 4
56436: ST_TO_ADDR
// end ;
56437: LD_VAR 0 3
56441: RET
// export function DangerInArea ( side , area ) ; begin
56442: LD_INT 0
56444: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56445: LD_ADDR_VAR 0 3
56449: PUSH
56450: LD_VAR 0 2
56454: PPUSH
56455: LD_INT 81
56457: PUSH
56458: LD_VAR 0 1
56462: PUSH
56463: EMPTY
56464: LIST
56465: LIST
56466: PPUSH
56467: CALL_OW 70
56471: ST_TO_ADDR
// end ;
56472: LD_VAR 0 3
56476: RET
// export function IsExtension ( b ) ; begin
56477: LD_INT 0
56479: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56480: LD_ADDR_VAR 0 2
56484: PUSH
56485: LD_VAR 0 1
56489: PUSH
56490: LD_INT 23
56492: PUSH
56493: LD_INT 20
56495: PUSH
56496: LD_INT 22
56498: PUSH
56499: LD_INT 17
56501: PUSH
56502: LD_INT 24
56504: PUSH
56505: LD_INT 21
56507: PUSH
56508: LD_INT 19
56510: PUSH
56511: LD_INT 16
56513: PUSH
56514: LD_INT 25
56516: PUSH
56517: LD_INT 18
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: LIST
56524: LIST
56525: LIST
56526: LIST
56527: LIST
56528: LIST
56529: LIST
56530: LIST
56531: IN
56532: ST_TO_ADDR
// end ;
56533: LD_VAR 0 2
56537: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56538: LD_INT 0
56540: PPUSH
56541: PPUSH
56542: PPUSH
// result := [ ] ;
56543: LD_ADDR_VAR 0 4
56547: PUSH
56548: EMPTY
56549: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56550: LD_ADDR_VAR 0 5
56554: PUSH
56555: LD_VAR 0 2
56559: PPUSH
56560: LD_INT 21
56562: PUSH
56563: LD_INT 3
56565: PUSH
56566: EMPTY
56567: LIST
56568: LIST
56569: PPUSH
56570: CALL_OW 70
56574: ST_TO_ADDR
// if not tmp then
56575: LD_VAR 0 5
56579: NOT
56580: IFFALSE 56584
// exit ;
56582: GO 56648
// if checkLink then
56584: LD_VAR 0 3
56588: IFFALSE 56638
// begin for i in tmp do
56590: LD_ADDR_VAR 0 6
56594: PUSH
56595: LD_VAR 0 5
56599: PUSH
56600: FOR_IN
56601: IFFALSE 56636
// if GetBase ( i ) <> base then
56603: LD_VAR 0 6
56607: PPUSH
56608: CALL_OW 274
56612: PUSH
56613: LD_VAR 0 1
56617: NONEQUAL
56618: IFFALSE 56634
// ComLinkToBase ( base , i ) ;
56620: LD_VAR 0 1
56624: PPUSH
56625: LD_VAR 0 6
56629: PPUSH
56630: CALL_OW 169
56634: GO 56600
56636: POP
56637: POP
// end ; result := tmp ;
56638: LD_ADDR_VAR 0 4
56642: PUSH
56643: LD_VAR 0 5
56647: ST_TO_ADDR
// end ;
56648: LD_VAR 0 4
56652: RET
// export function ComComplete ( units , b ) ; var i ; begin
56653: LD_INT 0
56655: PPUSH
56656: PPUSH
// if not units then
56657: LD_VAR 0 1
56661: NOT
56662: IFFALSE 56666
// exit ;
56664: GO 56756
// for i in units do
56666: LD_ADDR_VAR 0 4
56670: PUSH
56671: LD_VAR 0 1
56675: PUSH
56676: FOR_IN
56677: IFFALSE 56754
// if BuildingStatus ( b ) = bs_build then
56679: LD_VAR 0 2
56683: PPUSH
56684: CALL_OW 461
56688: PUSH
56689: LD_INT 1
56691: EQUAL
56692: IFFALSE 56752
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56694: LD_VAR 0 4
56698: PPUSH
56699: LD_STRING h
56701: PUSH
56702: LD_VAR 0 2
56706: PPUSH
56707: CALL_OW 250
56711: PUSH
56712: LD_VAR 0 2
56716: PPUSH
56717: CALL_OW 251
56721: PUSH
56722: LD_VAR 0 2
56726: PUSH
56727: LD_INT 0
56729: PUSH
56730: LD_INT 0
56732: PUSH
56733: LD_INT 0
56735: PUSH
56736: EMPTY
56737: LIST
56738: LIST
56739: LIST
56740: LIST
56741: LIST
56742: LIST
56743: LIST
56744: PUSH
56745: EMPTY
56746: LIST
56747: PPUSH
56748: CALL_OW 446
56752: GO 56676
56754: POP
56755: POP
// end ;
56756: LD_VAR 0 3
56760: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56761: LD_INT 0
56763: PPUSH
56764: PPUSH
56765: PPUSH
56766: PPUSH
56767: PPUSH
56768: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56769: LD_VAR 0 1
56773: NOT
56774: PUSH
56775: LD_VAR 0 1
56779: PPUSH
56780: CALL_OW 263
56784: PUSH
56785: LD_INT 2
56787: NONEQUAL
56788: OR
56789: IFFALSE 56793
// exit ;
56791: GO 57109
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56793: LD_ADDR_VAR 0 6
56797: PUSH
56798: LD_INT 22
56800: PUSH
56801: LD_VAR 0 1
56805: PPUSH
56806: CALL_OW 255
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PUSH
56815: LD_INT 2
56817: PUSH
56818: LD_INT 30
56820: PUSH
56821: LD_INT 36
56823: PUSH
56824: EMPTY
56825: LIST
56826: LIST
56827: PUSH
56828: LD_INT 34
56830: PUSH
56831: LD_INT 31
56833: PUSH
56834: EMPTY
56835: LIST
56836: LIST
56837: PUSH
56838: EMPTY
56839: LIST
56840: LIST
56841: LIST
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: PPUSH
56847: CALL_OW 69
56851: ST_TO_ADDR
// if not tmp then
56852: LD_VAR 0 6
56856: NOT
56857: IFFALSE 56861
// exit ;
56859: GO 57109
// result := [ ] ;
56861: LD_ADDR_VAR 0 2
56865: PUSH
56866: EMPTY
56867: ST_TO_ADDR
// for i in tmp do
56868: LD_ADDR_VAR 0 3
56872: PUSH
56873: LD_VAR 0 6
56877: PUSH
56878: FOR_IN
56879: IFFALSE 56950
// begin t := UnitsInside ( i ) ;
56881: LD_ADDR_VAR 0 4
56885: PUSH
56886: LD_VAR 0 3
56890: PPUSH
56891: CALL_OW 313
56895: ST_TO_ADDR
// if t then
56896: LD_VAR 0 4
56900: IFFALSE 56948
// for j in t do
56902: LD_ADDR_VAR 0 7
56906: PUSH
56907: LD_VAR 0 4
56911: PUSH
56912: FOR_IN
56913: IFFALSE 56946
// result := Replace ( result , result + 1 , j ) ;
56915: LD_ADDR_VAR 0 2
56919: PUSH
56920: LD_VAR 0 2
56924: PPUSH
56925: LD_VAR 0 2
56929: PUSH
56930: LD_INT 1
56932: PLUS
56933: PPUSH
56934: LD_VAR 0 7
56938: PPUSH
56939: CALL_OW 1
56943: ST_TO_ADDR
56944: GO 56912
56946: POP
56947: POP
// end ;
56948: GO 56878
56950: POP
56951: POP
// if not result then
56952: LD_VAR 0 2
56956: NOT
56957: IFFALSE 56961
// exit ;
56959: GO 57109
// mech := result [ 1 ] ;
56961: LD_ADDR_VAR 0 5
56965: PUSH
56966: LD_VAR 0 2
56970: PUSH
56971: LD_INT 1
56973: ARRAY
56974: ST_TO_ADDR
// if result > 1 then
56975: LD_VAR 0 2
56979: PUSH
56980: LD_INT 1
56982: GREATER
56983: IFFALSE 57095
// begin for i = 2 to result do
56985: LD_ADDR_VAR 0 3
56989: PUSH
56990: DOUBLE
56991: LD_INT 2
56993: DEC
56994: ST_TO_ADDR
56995: LD_VAR 0 2
56999: PUSH
57000: FOR_TO
57001: IFFALSE 57093
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57003: LD_ADDR_VAR 0 4
57007: PUSH
57008: LD_VAR 0 2
57012: PUSH
57013: LD_VAR 0 3
57017: ARRAY
57018: PPUSH
57019: LD_INT 3
57021: PPUSH
57022: CALL_OW 259
57026: PUSH
57027: LD_VAR 0 2
57031: PUSH
57032: LD_VAR 0 3
57036: ARRAY
57037: PPUSH
57038: CALL_OW 432
57042: MINUS
57043: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57044: LD_VAR 0 4
57048: PUSH
57049: LD_VAR 0 5
57053: PPUSH
57054: LD_INT 3
57056: PPUSH
57057: CALL_OW 259
57061: PUSH
57062: LD_VAR 0 5
57066: PPUSH
57067: CALL_OW 432
57071: MINUS
57072: GREATEREQUAL
57073: IFFALSE 57091
// mech := result [ i ] ;
57075: LD_ADDR_VAR 0 5
57079: PUSH
57080: LD_VAR 0 2
57084: PUSH
57085: LD_VAR 0 3
57089: ARRAY
57090: ST_TO_ADDR
// end ;
57091: GO 57000
57093: POP
57094: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57095: LD_VAR 0 1
57099: PPUSH
57100: LD_VAR 0 5
57104: PPUSH
57105: CALL_OW 135
// end ;
57109: LD_VAR 0 2
57113: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57114: LD_INT 0
57116: PPUSH
57117: PPUSH
57118: PPUSH
57119: PPUSH
57120: PPUSH
57121: PPUSH
57122: PPUSH
57123: PPUSH
57124: PPUSH
57125: PPUSH
57126: PPUSH
57127: PPUSH
57128: PPUSH
// result := [ ] ;
57129: LD_ADDR_VAR 0 7
57133: PUSH
57134: EMPTY
57135: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57136: LD_VAR 0 1
57140: PPUSH
57141: CALL_OW 266
57145: PUSH
57146: LD_INT 0
57148: PUSH
57149: LD_INT 1
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: IN
57156: NOT
57157: IFFALSE 57161
// exit ;
57159: GO 58795
// if name then
57161: LD_VAR 0 3
57165: IFFALSE 57181
// SetBName ( base_dep , name ) ;
57167: LD_VAR 0 1
57171: PPUSH
57172: LD_VAR 0 3
57176: PPUSH
57177: CALL_OW 500
// base := GetBase ( base_dep ) ;
57181: LD_ADDR_VAR 0 15
57185: PUSH
57186: LD_VAR 0 1
57190: PPUSH
57191: CALL_OW 274
57195: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57196: LD_ADDR_VAR 0 16
57200: PUSH
57201: LD_VAR 0 1
57205: PPUSH
57206: CALL_OW 255
57210: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57211: LD_ADDR_VAR 0 17
57215: PUSH
57216: LD_VAR 0 1
57220: PPUSH
57221: CALL_OW 248
57225: ST_TO_ADDR
// if sources then
57226: LD_VAR 0 5
57230: IFFALSE 57277
// for i = 1 to 3 do
57232: LD_ADDR_VAR 0 8
57236: PUSH
57237: DOUBLE
57238: LD_INT 1
57240: DEC
57241: ST_TO_ADDR
57242: LD_INT 3
57244: PUSH
57245: FOR_TO
57246: IFFALSE 57275
// AddResourceType ( base , i , sources [ i ] ) ;
57248: LD_VAR 0 15
57252: PPUSH
57253: LD_VAR 0 8
57257: PPUSH
57258: LD_VAR 0 5
57262: PUSH
57263: LD_VAR 0 8
57267: ARRAY
57268: PPUSH
57269: CALL_OW 276
57273: GO 57245
57275: POP
57276: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57277: LD_ADDR_VAR 0 18
57281: PUSH
57282: LD_VAR 0 15
57286: PPUSH
57287: LD_VAR 0 2
57291: PPUSH
57292: LD_INT 1
57294: PPUSH
57295: CALL 56538 0 3
57299: ST_TO_ADDR
// InitHc ;
57300: CALL_OW 19
// InitUc ;
57304: CALL_OW 18
// uc_side := side ;
57308: LD_ADDR_OWVAR 20
57312: PUSH
57313: LD_VAR 0 16
57317: ST_TO_ADDR
// uc_nation := nation ;
57318: LD_ADDR_OWVAR 21
57322: PUSH
57323: LD_VAR 0 17
57327: ST_TO_ADDR
// if buildings then
57328: LD_VAR 0 18
57332: IFFALSE 58654
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57334: LD_ADDR_VAR 0 19
57338: PUSH
57339: LD_VAR 0 18
57343: PPUSH
57344: LD_INT 2
57346: PUSH
57347: LD_INT 30
57349: PUSH
57350: LD_INT 29
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: PUSH
57357: LD_INT 30
57359: PUSH
57360: LD_INT 30
57362: PUSH
57363: EMPTY
57364: LIST
57365: LIST
57366: PUSH
57367: EMPTY
57368: LIST
57369: LIST
57370: LIST
57371: PPUSH
57372: CALL_OW 72
57376: ST_TO_ADDR
// if tmp then
57377: LD_VAR 0 19
57381: IFFALSE 57429
// for i in tmp do
57383: LD_ADDR_VAR 0 8
57387: PUSH
57388: LD_VAR 0 19
57392: PUSH
57393: FOR_IN
57394: IFFALSE 57427
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57396: LD_VAR 0 8
57400: PPUSH
57401: CALL_OW 250
57405: PPUSH
57406: LD_VAR 0 8
57410: PPUSH
57411: CALL_OW 251
57415: PPUSH
57416: LD_VAR 0 16
57420: PPUSH
57421: CALL_OW 441
57425: GO 57393
57427: POP
57428: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57429: LD_VAR 0 18
57433: PPUSH
57434: LD_INT 2
57436: PUSH
57437: LD_INT 30
57439: PUSH
57440: LD_INT 32
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: PUSH
57447: LD_INT 30
57449: PUSH
57450: LD_INT 33
57452: PUSH
57453: EMPTY
57454: LIST
57455: LIST
57456: PUSH
57457: EMPTY
57458: LIST
57459: LIST
57460: LIST
57461: PPUSH
57462: CALL_OW 72
57466: IFFALSE 57554
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57468: LD_ADDR_VAR 0 8
57472: PUSH
57473: LD_VAR 0 18
57477: PPUSH
57478: LD_INT 2
57480: PUSH
57481: LD_INT 30
57483: PUSH
57484: LD_INT 32
57486: PUSH
57487: EMPTY
57488: LIST
57489: LIST
57490: PUSH
57491: LD_INT 30
57493: PUSH
57494: LD_INT 33
57496: PUSH
57497: EMPTY
57498: LIST
57499: LIST
57500: PUSH
57501: EMPTY
57502: LIST
57503: LIST
57504: LIST
57505: PPUSH
57506: CALL_OW 72
57510: PUSH
57511: FOR_IN
57512: IFFALSE 57552
// begin if not GetBWeapon ( i ) then
57514: LD_VAR 0 8
57518: PPUSH
57519: CALL_OW 269
57523: NOT
57524: IFFALSE 57550
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57526: LD_VAR 0 8
57530: PPUSH
57531: LD_VAR 0 8
57535: PPUSH
57536: LD_VAR 0 2
57540: PPUSH
57541: CALL 58800 0 2
57545: PPUSH
57546: CALL_OW 431
// end ;
57550: GO 57511
57552: POP
57553: POP
// end ; for i = 1 to personel do
57554: LD_ADDR_VAR 0 8
57558: PUSH
57559: DOUBLE
57560: LD_INT 1
57562: DEC
57563: ST_TO_ADDR
57564: LD_VAR 0 6
57568: PUSH
57569: FOR_TO
57570: IFFALSE 58634
// begin if i > 4 then
57572: LD_VAR 0 8
57576: PUSH
57577: LD_INT 4
57579: GREATER
57580: IFFALSE 57584
// break ;
57582: GO 58634
// case i of 1 :
57584: LD_VAR 0 8
57588: PUSH
57589: LD_INT 1
57591: DOUBLE
57592: EQUAL
57593: IFTRUE 57597
57595: GO 57677
57597: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57598: LD_ADDR_VAR 0 12
57602: PUSH
57603: LD_VAR 0 18
57607: PPUSH
57608: LD_INT 22
57610: PUSH
57611: LD_VAR 0 16
57615: PUSH
57616: EMPTY
57617: LIST
57618: LIST
57619: PUSH
57620: LD_INT 58
57622: PUSH
57623: EMPTY
57624: LIST
57625: PUSH
57626: LD_INT 2
57628: PUSH
57629: LD_INT 30
57631: PUSH
57632: LD_INT 32
57634: PUSH
57635: EMPTY
57636: LIST
57637: LIST
57638: PUSH
57639: LD_INT 30
57641: PUSH
57642: LD_INT 4
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: PUSH
57649: LD_INT 30
57651: PUSH
57652: LD_INT 5
57654: PUSH
57655: EMPTY
57656: LIST
57657: LIST
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: LIST
57663: LIST
57664: PUSH
57665: EMPTY
57666: LIST
57667: LIST
57668: LIST
57669: PPUSH
57670: CALL_OW 72
57674: ST_TO_ADDR
57675: GO 57899
57677: LD_INT 2
57679: DOUBLE
57680: EQUAL
57681: IFTRUE 57685
57683: GO 57747
57685: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57686: LD_ADDR_VAR 0 12
57690: PUSH
57691: LD_VAR 0 18
57695: PPUSH
57696: LD_INT 22
57698: PUSH
57699: LD_VAR 0 16
57703: PUSH
57704: EMPTY
57705: LIST
57706: LIST
57707: PUSH
57708: LD_INT 2
57710: PUSH
57711: LD_INT 30
57713: PUSH
57714: LD_INT 0
57716: PUSH
57717: EMPTY
57718: LIST
57719: LIST
57720: PUSH
57721: LD_INT 30
57723: PUSH
57724: LD_INT 1
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: PUSH
57731: EMPTY
57732: LIST
57733: LIST
57734: LIST
57735: PUSH
57736: EMPTY
57737: LIST
57738: LIST
57739: PPUSH
57740: CALL_OW 72
57744: ST_TO_ADDR
57745: GO 57899
57747: LD_INT 3
57749: DOUBLE
57750: EQUAL
57751: IFTRUE 57755
57753: GO 57817
57755: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57756: LD_ADDR_VAR 0 12
57760: PUSH
57761: LD_VAR 0 18
57765: PPUSH
57766: LD_INT 22
57768: PUSH
57769: LD_VAR 0 16
57773: PUSH
57774: EMPTY
57775: LIST
57776: LIST
57777: PUSH
57778: LD_INT 2
57780: PUSH
57781: LD_INT 30
57783: PUSH
57784: LD_INT 2
57786: PUSH
57787: EMPTY
57788: LIST
57789: LIST
57790: PUSH
57791: LD_INT 30
57793: PUSH
57794: LD_INT 3
57796: PUSH
57797: EMPTY
57798: LIST
57799: LIST
57800: PUSH
57801: EMPTY
57802: LIST
57803: LIST
57804: LIST
57805: PUSH
57806: EMPTY
57807: LIST
57808: LIST
57809: PPUSH
57810: CALL_OW 72
57814: ST_TO_ADDR
57815: GO 57899
57817: LD_INT 4
57819: DOUBLE
57820: EQUAL
57821: IFTRUE 57825
57823: GO 57898
57825: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57826: LD_ADDR_VAR 0 12
57830: PUSH
57831: LD_VAR 0 18
57835: PPUSH
57836: LD_INT 22
57838: PUSH
57839: LD_VAR 0 16
57843: PUSH
57844: EMPTY
57845: LIST
57846: LIST
57847: PUSH
57848: LD_INT 2
57850: PUSH
57851: LD_INT 30
57853: PUSH
57854: LD_INT 6
57856: PUSH
57857: EMPTY
57858: LIST
57859: LIST
57860: PUSH
57861: LD_INT 30
57863: PUSH
57864: LD_INT 7
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: PUSH
57871: LD_INT 30
57873: PUSH
57874: LD_INT 8
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: PUSH
57881: EMPTY
57882: LIST
57883: LIST
57884: LIST
57885: LIST
57886: PUSH
57887: EMPTY
57888: LIST
57889: LIST
57890: PPUSH
57891: CALL_OW 72
57895: ST_TO_ADDR
57896: GO 57899
57898: POP
// if i = 1 then
57899: LD_VAR 0 8
57903: PUSH
57904: LD_INT 1
57906: EQUAL
57907: IFFALSE 58018
// begin tmp := [ ] ;
57909: LD_ADDR_VAR 0 19
57913: PUSH
57914: EMPTY
57915: ST_TO_ADDR
// for j in f do
57916: LD_ADDR_VAR 0 9
57920: PUSH
57921: LD_VAR 0 12
57925: PUSH
57926: FOR_IN
57927: IFFALSE 58000
// if GetBType ( j ) = b_bunker then
57929: LD_VAR 0 9
57933: PPUSH
57934: CALL_OW 266
57938: PUSH
57939: LD_INT 32
57941: EQUAL
57942: IFFALSE 57969
// tmp := Insert ( tmp , 1 , j ) else
57944: LD_ADDR_VAR 0 19
57948: PUSH
57949: LD_VAR 0 19
57953: PPUSH
57954: LD_INT 1
57956: PPUSH
57957: LD_VAR 0 9
57961: PPUSH
57962: CALL_OW 2
57966: ST_TO_ADDR
57967: GO 57998
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57969: LD_ADDR_VAR 0 19
57973: PUSH
57974: LD_VAR 0 19
57978: PPUSH
57979: LD_VAR 0 19
57983: PUSH
57984: LD_INT 1
57986: PLUS
57987: PPUSH
57988: LD_VAR 0 9
57992: PPUSH
57993: CALL_OW 2
57997: ST_TO_ADDR
57998: GO 57926
58000: POP
58001: POP
// if tmp then
58002: LD_VAR 0 19
58006: IFFALSE 58018
// f := tmp ;
58008: LD_ADDR_VAR 0 12
58012: PUSH
58013: LD_VAR 0 19
58017: ST_TO_ADDR
// end ; x := personel [ i ] ;
58018: LD_ADDR_VAR 0 13
58022: PUSH
58023: LD_VAR 0 6
58027: PUSH
58028: LD_VAR 0 8
58032: ARRAY
58033: ST_TO_ADDR
// if x = - 1 then
58034: LD_VAR 0 13
58038: PUSH
58039: LD_INT 1
58041: NEG
58042: EQUAL
58043: IFFALSE 58252
// begin for j in f do
58045: LD_ADDR_VAR 0 9
58049: PUSH
58050: LD_VAR 0 12
58054: PUSH
58055: FOR_IN
58056: IFFALSE 58248
// repeat InitHc ;
58058: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58062: LD_VAR 0 9
58066: PPUSH
58067: CALL_OW 266
58071: PUSH
58072: LD_INT 5
58074: EQUAL
58075: IFFALSE 58145
// begin if UnitsInside ( j ) < 3 then
58077: LD_VAR 0 9
58081: PPUSH
58082: CALL_OW 313
58086: PUSH
58087: LD_INT 3
58089: LESS
58090: IFFALSE 58126
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58092: LD_INT 0
58094: PPUSH
58095: LD_INT 5
58097: PUSH
58098: LD_INT 8
58100: PUSH
58101: LD_INT 9
58103: PUSH
58104: EMPTY
58105: LIST
58106: LIST
58107: LIST
58108: PUSH
58109: LD_VAR 0 17
58113: ARRAY
58114: PPUSH
58115: LD_VAR 0 4
58119: PPUSH
58120: CALL_OW 380
58124: GO 58143
// PrepareHuman ( false , i , skill ) ;
58126: LD_INT 0
58128: PPUSH
58129: LD_VAR 0 8
58133: PPUSH
58134: LD_VAR 0 4
58138: PPUSH
58139: CALL_OW 380
// end else
58143: GO 58162
// PrepareHuman ( false , i , skill ) ;
58145: LD_INT 0
58147: PPUSH
58148: LD_VAR 0 8
58152: PPUSH
58153: LD_VAR 0 4
58157: PPUSH
58158: CALL_OW 380
// un := CreateHuman ;
58162: LD_ADDR_VAR 0 14
58166: PUSH
58167: CALL_OW 44
58171: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58172: LD_ADDR_VAR 0 7
58176: PUSH
58177: LD_VAR 0 7
58181: PPUSH
58182: LD_INT 1
58184: PPUSH
58185: LD_VAR 0 14
58189: PPUSH
58190: CALL_OW 2
58194: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58195: LD_VAR 0 14
58199: PPUSH
58200: LD_VAR 0 9
58204: PPUSH
58205: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58209: LD_VAR 0 9
58213: PPUSH
58214: CALL_OW 313
58218: PUSH
58219: LD_INT 6
58221: EQUAL
58222: PUSH
58223: LD_VAR 0 9
58227: PPUSH
58228: CALL_OW 266
58232: PUSH
58233: LD_INT 32
58235: PUSH
58236: LD_INT 31
58238: PUSH
58239: EMPTY
58240: LIST
58241: LIST
58242: IN
58243: OR
58244: IFFALSE 58058
58246: GO 58055
58248: POP
58249: POP
// end else
58250: GO 58632
// for j = 1 to x do
58252: LD_ADDR_VAR 0 9
58256: PUSH
58257: DOUBLE
58258: LD_INT 1
58260: DEC
58261: ST_TO_ADDR
58262: LD_VAR 0 13
58266: PUSH
58267: FOR_TO
58268: IFFALSE 58630
// begin InitHc ;
58270: CALL_OW 19
// if not f then
58274: LD_VAR 0 12
58278: NOT
58279: IFFALSE 58368
// begin PrepareHuman ( false , i , skill ) ;
58281: LD_INT 0
58283: PPUSH
58284: LD_VAR 0 8
58288: PPUSH
58289: LD_VAR 0 4
58293: PPUSH
58294: CALL_OW 380
// un := CreateHuman ;
58298: LD_ADDR_VAR 0 14
58302: PUSH
58303: CALL_OW 44
58307: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58308: LD_ADDR_VAR 0 7
58312: PUSH
58313: LD_VAR 0 7
58317: PPUSH
58318: LD_INT 1
58320: PPUSH
58321: LD_VAR 0 14
58325: PPUSH
58326: CALL_OW 2
58330: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58331: LD_VAR 0 14
58335: PPUSH
58336: LD_VAR 0 1
58340: PPUSH
58341: CALL_OW 250
58345: PPUSH
58346: LD_VAR 0 1
58350: PPUSH
58351: CALL_OW 251
58355: PPUSH
58356: LD_INT 10
58358: PPUSH
58359: LD_INT 0
58361: PPUSH
58362: CALL_OW 50
// continue ;
58366: GO 58267
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58368: LD_VAR 0 12
58372: PUSH
58373: LD_INT 1
58375: ARRAY
58376: PPUSH
58377: CALL_OW 313
58381: PUSH
58382: LD_VAR 0 12
58386: PUSH
58387: LD_INT 1
58389: ARRAY
58390: PPUSH
58391: CALL_OW 266
58395: PUSH
58396: LD_INT 32
58398: PUSH
58399: LD_INT 31
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: IN
58406: AND
58407: PUSH
58408: LD_VAR 0 12
58412: PUSH
58413: LD_INT 1
58415: ARRAY
58416: PPUSH
58417: CALL_OW 313
58421: PUSH
58422: LD_INT 6
58424: EQUAL
58425: OR
58426: IFFALSE 58446
// f := Delete ( f , 1 ) ;
58428: LD_ADDR_VAR 0 12
58432: PUSH
58433: LD_VAR 0 12
58437: PPUSH
58438: LD_INT 1
58440: PPUSH
58441: CALL_OW 3
58445: ST_TO_ADDR
// if not f then
58446: LD_VAR 0 12
58450: NOT
58451: IFFALSE 58469
// begin x := x + 2 ;
58453: LD_ADDR_VAR 0 13
58457: PUSH
58458: LD_VAR 0 13
58462: PUSH
58463: LD_INT 2
58465: PLUS
58466: ST_TO_ADDR
// continue ;
58467: GO 58267
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58469: LD_VAR 0 12
58473: PUSH
58474: LD_INT 1
58476: ARRAY
58477: PPUSH
58478: CALL_OW 266
58482: PUSH
58483: LD_INT 5
58485: EQUAL
58486: IFFALSE 58560
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58488: LD_VAR 0 12
58492: PUSH
58493: LD_INT 1
58495: ARRAY
58496: PPUSH
58497: CALL_OW 313
58501: PUSH
58502: LD_INT 3
58504: LESS
58505: IFFALSE 58541
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58507: LD_INT 0
58509: PPUSH
58510: LD_INT 5
58512: PUSH
58513: LD_INT 8
58515: PUSH
58516: LD_INT 9
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: LIST
58523: PUSH
58524: LD_VAR 0 17
58528: ARRAY
58529: PPUSH
58530: LD_VAR 0 4
58534: PPUSH
58535: CALL_OW 380
58539: GO 58558
// PrepareHuman ( false , i , skill ) ;
58541: LD_INT 0
58543: PPUSH
58544: LD_VAR 0 8
58548: PPUSH
58549: LD_VAR 0 4
58553: PPUSH
58554: CALL_OW 380
// end else
58558: GO 58577
// PrepareHuman ( false , i , skill ) ;
58560: LD_INT 0
58562: PPUSH
58563: LD_VAR 0 8
58567: PPUSH
58568: LD_VAR 0 4
58572: PPUSH
58573: CALL_OW 380
// un := CreateHuman ;
58577: LD_ADDR_VAR 0 14
58581: PUSH
58582: CALL_OW 44
58586: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58587: LD_ADDR_VAR 0 7
58591: PUSH
58592: LD_VAR 0 7
58596: PPUSH
58597: LD_INT 1
58599: PPUSH
58600: LD_VAR 0 14
58604: PPUSH
58605: CALL_OW 2
58609: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58610: LD_VAR 0 14
58614: PPUSH
58615: LD_VAR 0 12
58619: PUSH
58620: LD_INT 1
58622: ARRAY
58623: PPUSH
58624: CALL_OW 52
// end ;
58628: GO 58267
58630: POP
58631: POP
// end ;
58632: GO 57569
58634: POP
58635: POP
// result := result ^ buildings ;
58636: LD_ADDR_VAR 0 7
58640: PUSH
58641: LD_VAR 0 7
58645: PUSH
58646: LD_VAR 0 18
58650: ADD
58651: ST_TO_ADDR
// end else
58652: GO 58795
// begin for i = 1 to personel do
58654: LD_ADDR_VAR 0 8
58658: PUSH
58659: DOUBLE
58660: LD_INT 1
58662: DEC
58663: ST_TO_ADDR
58664: LD_VAR 0 6
58668: PUSH
58669: FOR_TO
58670: IFFALSE 58793
// begin if i > 4 then
58672: LD_VAR 0 8
58676: PUSH
58677: LD_INT 4
58679: GREATER
58680: IFFALSE 58684
// break ;
58682: GO 58793
// x := personel [ i ] ;
58684: LD_ADDR_VAR 0 13
58688: PUSH
58689: LD_VAR 0 6
58693: PUSH
58694: LD_VAR 0 8
58698: ARRAY
58699: ST_TO_ADDR
// if x = - 1 then
58700: LD_VAR 0 13
58704: PUSH
58705: LD_INT 1
58707: NEG
58708: EQUAL
58709: IFFALSE 58713
// continue ;
58711: GO 58669
// PrepareHuman ( false , i , skill ) ;
58713: LD_INT 0
58715: PPUSH
58716: LD_VAR 0 8
58720: PPUSH
58721: LD_VAR 0 4
58725: PPUSH
58726: CALL_OW 380
// un := CreateHuman ;
58730: LD_ADDR_VAR 0 14
58734: PUSH
58735: CALL_OW 44
58739: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58740: LD_VAR 0 14
58744: PPUSH
58745: LD_VAR 0 1
58749: PPUSH
58750: CALL_OW 250
58754: PPUSH
58755: LD_VAR 0 1
58759: PPUSH
58760: CALL_OW 251
58764: PPUSH
58765: LD_INT 10
58767: PPUSH
58768: LD_INT 0
58770: PPUSH
58771: CALL_OW 50
// result := result ^ un ;
58775: LD_ADDR_VAR 0 7
58779: PUSH
58780: LD_VAR 0 7
58784: PUSH
58785: LD_VAR 0 14
58789: ADD
58790: ST_TO_ADDR
// end ;
58791: GO 58669
58793: POP
58794: POP
// end ; end ;
58795: LD_VAR 0 7
58799: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58800: LD_INT 0
58802: PPUSH
58803: PPUSH
58804: PPUSH
58805: PPUSH
58806: PPUSH
58807: PPUSH
58808: PPUSH
58809: PPUSH
58810: PPUSH
58811: PPUSH
58812: PPUSH
58813: PPUSH
58814: PPUSH
58815: PPUSH
58816: PPUSH
58817: PPUSH
// result := false ;
58818: LD_ADDR_VAR 0 3
58822: PUSH
58823: LD_INT 0
58825: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58826: LD_VAR 0 1
58830: NOT
58831: PUSH
58832: LD_VAR 0 1
58836: PPUSH
58837: CALL_OW 266
58841: PUSH
58842: LD_INT 32
58844: PUSH
58845: LD_INT 33
58847: PUSH
58848: EMPTY
58849: LIST
58850: LIST
58851: IN
58852: NOT
58853: OR
58854: IFFALSE 58858
// exit ;
58856: GO 59967
// nat := GetNation ( tower ) ;
58858: LD_ADDR_VAR 0 12
58862: PUSH
58863: LD_VAR 0 1
58867: PPUSH
58868: CALL_OW 248
58872: ST_TO_ADDR
// side := GetSide ( tower ) ;
58873: LD_ADDR_VAR 0 16
58877: PUSH
58878: LD_VAR 0 1
58882: PPUSH
58883: CALL_OW 255
58887: ST_TO_ADDR
// x := GetX ( tower ) ;
58888: LD_ADDR_VAR 0 10
58892: PUSH
58893: LD_VAR 0 1
58897: PPUSH
58898: CALL_OW 250
58902: ST_TO_ADDR
// y := GetY ( tower ) ;
58903: LD_ADDR_VAR 0 11
58907: PUSH
58908: LD_VAR 0 1
58912: PPUSH
58913: CALL_OW 251
58917: ST_TO_ADDR
// if not x or not y then
58918: LD_VAR 0 10
58922: NOT
58923: PUSH
58924: LD_VAR 0 11
58928: NOT
58929: OR
58930: IFFALSE 58934
// exit ;
58932: GO 59967
// weapon := 0 ;
58934: LD_ADDR_VAR 0 18
58938: PUSH
58939: LD_INT 0
58941: ST_TO_ADDR
// fac_list := [ ] ;
58942: LD_ADDR_VAR 0 17
58946: PUSH
58947: EMPTY
58948: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58949: LD_ADDR_VAR 0 6
58953: PUSH
58954: LD_VAR 0 1
58958: PPUSH
58959: CALL_OW 274
58963: PPUSH
58964: LD_VAR 0 2
58968: PPUSH
58969: LD_INT 0
58971: PPUSH
58972: CALL 56538 0 3
58976: PPUSH
58977: LD_INT 30
58979: PUSH
58980: LD_INT 3
58982: PUSH
58983: EMPTY
58984: LIST
58985: LIST
58986: PPUSH
58987: CALL_OW 72
58991: ST_TO_ADDR
// if not factories then
58992: LD_VAR 0 6
58996: NOT
58997: IFFALSE 59001
// exit ;
58999: GO 59967
// for i in factories do
59001: LD_ADDR_VAR 0 8
59005: PUSH
59006: LD_VAR 0 6
59010: PUSH
59011: FOR_IN
59012: IFFALSE 59037
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59014: LD_ADDR_VAR 0 17
59018: PUSH
59019: LD_VAR 0 17
59023: PUSH
59024: LD_VAR 0 8
59028: PPUSH
59029: CALL_OW 478
59033: UNION
59034: ST_TO_ADDR
59035: GO 59011
59037: POP
59038: POP
// if not fac_list then
59039: LD_VAR 0 17
59043: NOT
59044: IFFALSE 59048
// exit ;
59046: GO 59967
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59048: LD_ADDR_VAR 0 5
59052: PUSH
59053: LD_INT 4
59055: PUSH
59056: LD_INT 5
59058: PUSH
59059: LD_INT 9
59061: PUSH
59062: LD_INT 10
59064: PUSH
59065: LD_INT 6
59067: PUSH
59068: LD_INT 7
59070: PUSH
59071: LD_INT 11
59073: PUSH
59074: EMPTY
59075: LIST
59076: LIST
59077: LIST
59078: LIST
59079: LIST
59080: LIST
59081: LIST
59082: PUSH
59083: LD_INT 27
59085: PUSH
59086: LD_INT 28
59088: PUSH
59089: LD_INT 26
59091: PUSH
59092: LD_INT 30
59094: PUSH
59095: EMPTY
59096: LIST
59097: LIST
59098: LIST
59099: LIST
59100: PUSH
59101: LD_INT 43
59103: PUSH
59104: LD_INT 44
59106: PUSH
59107: LD_INT 46
59109: PUSH
59110: LD_INT 45
59112: PUSH
59113: LD_INT 47
59115: PUSH
59116: LD_INT 49
59118: PUSH
59119: EMPTY
59120: LIST
59121: LIST
59122: LIST
59123: LIST
59124: LIST
59125: LIST
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: LIST
59131: PUSH
59132: LD_VAR 0 12
59136: ARRAY
59137: ST_TO_ADDR
// list := list isect fac_list ;
59138: LD_ADDR_VAR 0 5
59142: PUSH
59143: LD_VAR 0 5
59147: PUSH
59148: LD_VAR 0 17
59152: ISECT
59153: ST_TO_ADDR
// if not list then
59154: LD_VAR 0 5
59158: NOT
59159: IFFALSE 59163
// exit ;
59161: GO 59967
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59163: LD_VAR 0 12
59167: PUSH
59168: LD_INT 3
59170: EQUAL
59171: PUSH
59172: LD_INT 49
59174: PUSH
59175: LD_VAR 0 5
59179: IN
59180: AND
59181: PUSH
59182: LD_INT 31
59184: PPUSH
59185: LD_VAR 0 16
59189: PPUSH
59190: CALL_OW 321
59194: PUSH
59195: LD_INT 2
59197: EQUAL
59198: AND
59199: IFFALSE 59259
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59201: LD_INT 22
59203: PUSH
59204: LD_VAR 0 16
59208: PUSH
59209: EMPTY
59210: LIST
59211: LIST
59212: PUSH
59213: LD_INT 35
59215: PUSH
59216: LD_INT 49
59218: PUSH
59219: EMPTY
59220: LIST
59221: LIST
59222: PUSH
59223: LD_INT 91
59225: PUSH
59226: LD_VAR 0 1
59230: PUSH
59231: LD_INT 10
59233: PUSH
59234: EMPTY
59235: LIST
59236: LIST
59237: LIST
59238: PUSH
59239: EMPTY
59240: LIST
59241: LIST
59242: LIST
59243: PPUSH
59244: CALL_OW 69
59248: NOT
59249: IFFALSE 59259
// weapon := ru_time_lapser ;
59251: LD_ADDR_VAR 0 18
59255: PUSH
59256: LD_INT 49
59258: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59259: LD_VAR 0 12
59263: PUSH
59264: LD_INT 1
59266: PUSH
59267: LD_INT 2
59269: PUSH
59270: EMPTY
59271: LIST
59272: LIST
59273: IN
59274: PUSH
59275: LD_INT 11
59277: PUSH
59278: LD_VAR 0 5
59282: IN
59283: PUSH
59284: LD_INT 30
59286: PUSH
59287: LD_VAR 0 5
59291: IN
59292: OR
59293: AND
59294: PUSH
59295: LD_INT 6
59297: PPUSH
59298: LD_VAR 0 16
59302: PPUSH
59303: CALL_OW 321
59307: PUSH
59308: LD_INT 2
59310: EQUAL
59311: AND
59312: IFFALSE 59477
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59314: LD_INT 22
59316: PUSH
59317: LD_VAR 0 16
59321: PUSH
59322: EMPTY
59323: LIST
59324: LIST
59325: PUSH
59326: LD_INT 2
59328: PUSH
59329: LD_INT 35
59331: PUSH
59332: LD_INT 11
59334: PUSH
59335: EMPTY
59336: LIST
59337: LIST
59338: PUSH
59339: LD_INT 35
59341: PUSH
59342: LD_INT 30
59344: PUSH
59345: EMPTY
59346: LIST
59347: LIST
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: LIST
59353: PUSH
59354: LD_INT 91
59356: PUSH
59357: LD_VAR 0 1
59361: PUSH
59362: LD_INT 18
59364: PUSH
59365: EMPTY
59366: LIST
59367: LIST
59368: LIST
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: LIST
59374: PPUSH
59375: CALL_OW 69
59379: NOT
59380: PUSH
59381: LD_INT 22
59383: PUSH
59384: LD_VAR 0 16
59388: PUSH
59389: EMPTY
59390: LIST
59391: LIST
59392: PUSH
59393: LD_INT 2
59395: PUSH
59396: LD_INT 30
59398: PUSH
59399: LD_INT 32
59401: PUSH
59402: EMPTY
59403: LIST
59404: LIST
59405: PUSH
59406: LD_INT 30
59408: PUSH
59409: LD_INT 33
59411: PUSH
59412: EMPTY
59413: LIST
59414: LIST
59415: PUSH
59416: EMPTY
59417: LIST
59418: LIST
59419: LIST
59420: PUSH
59421: LD_INT 91
59423: PUSH
59424: LD_VAR 0 1
59428: PUSH
59429: LD_INT 12
59431: PUSH
59432: EMPTY
59433: LIST
59434: LIST
59435: LIST
59436: PUSH
59437: EMPTY
59438: LIST
59439: LIST
59440: LIST
59441: PUSH
59442: EMPTY
59443: LIST
59444: PPUSH
59445: CALL_OW 69
59449: PUSH
59450: LD_INT 2
59452: GREATER
59453: AND
59454: IFFALSE 59477
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59456: LD_ADDR_VAR 0 18
59460: PUSH
59461: LD_INT 11
59463: PUSH
59464: LD_INT 30
59466: PUSH
59467: EMPTY
59468: LIST
59469: LIST
59470: PUSH
59471: LD_VAR 0 12
59475: ARRAY
59476: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59477: LD_VAR 0 18
59481: NOT
59482: PUSH
59483: LD_INT 40
59485: PPUSH
59486: LD_VAR 0 16
59490: PPUSH
59491: CALL_OW 321
59495: PUSH
59496: LD_INT 2
59498: EQUAL
59499: AND
59500: PUSH
59501: LD_INT 7
59503: PUSH
59504: LD_VAR 0 5
59508: IN
59509: PUSH
59510: LD_INT 28
59512: PUSH
59513: LD_VAR 0 5
59517: IN
59518: OR
59519: PUSH
59520: LD_INT 45
59522: PUSH
59523: LD_VAR 0 5
59527: IN
59528: OR
59529: AND
59530: IFFALSE 59784
// begin hex := GetHexInfo ( x , y ) ;
59532: LD_ADDR_VAR 0 4
59536: PUSH
59537: LD_VAR 0 10
59541: PPUSH
59542: LD_VAR 0 11
59546: PPUSH
59547: CALL_OW 546
59551: ST_TO_ADDR
// if hex [ 1 ] then
59552: LD_VAR 0 4
59556: PUSH
59557: LD_INT 1
59559: ARRAY
59560: IFFALSE 59564
// exit ;
59562: GO 59967
// height := hex [ 2 ] ;
59564: LD_ADDR_VAR 0 15
59568: PUSH
59569: LD_VAR 0 4
59573: PUSH
59574: LD_INT 2
59576: ARRAY
59577: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59578: LD_ADDR_VAR 0 14
59582: PUSH
59583: LD_INT 0
59585: PUSH
59586: LD_INT 2
59588: PUSH
59589: LD_INT 3
59591: PUSH
59592: LD_INT 5
59594: PUSH
59595: EMPTY
59596: LIST
59597: LIST
59598: LIST
59599: LIST
59600: ST_TO_ADDR
// for i in tmp do
59601: LD_ADDR_VAR 0 8
59605: PUSH
59606: LD_VAR 0 14
59610: PUSH
59611: FOR_IN
59612: IFFALSE 59782
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59614: LD_ADDR_VAR 0 9
59618: PUSH
59619: LD_VAR 0 10
59623: PPUSH
59624: LD_VAR 0 8
59628: PPUSH
59629: LD_INT 5
59631: PPUSH
59632: CALL_OW 272
59636: PUSH
59637: LD_VAR 0 11
59641: PPUSH
59642: LD_VAR 0 8
59646: PPUSH
59647: LD_INT 5
59649: PPUSH
59650: CALL_OW 273
59654: PUSH
59655: EMPTY
59656: LIST
59657: LIST
59658: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59659: LD_VAR 0 9
59663: PUSH
59664: LD_INT 1
59666: ARRAY
59667: PPUSH
59668: LD_VAR 0 9
59672: PUSH
59673: LD_INT 2
59675: ARRAY
59676: PPUSH
59677: CALL_OW 488
59681: IFFALSE 59780
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59683: LD_ADDR_VAR 0 4
59687: PUSH
59688: LD_VAR 0 9
59692: PUSH
59693: LD_INT 1
59695: ARRAY
59696: PPUSH
59697: LD_VAR 0 9
59701: PUSH
59702: LD_INT 2
59704: ARRAY
59705: PPUSH
59706: CALL_OW 546
59710: ST_TO_ADDR
// if hex [ 1 ] then
59711: LD_VAR 0 4
59715: PUSH
59716: LD_INT 1
59718: ARRAY
59719: IFFALSE 59723
// continue ;
59721: GO 59611
// h := hex [ 2 ] ;
59723: LD_ADDR_VAR 0 13
59727: PUSH
59728: LD_VAR 0 4
59732: PUSH
59733: LD_INT 2
59735: ARRAY
59736: ST_TO_ADDR
// if h + 7 < height then
59737: LD_VAR 0 13
59741: PUSH
59742: LD_INT 7
59744: PLUS
59745: PUSH
59746: LD_VAR 0 15
59750: LESS
59751: IFFALSE 59780
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59753: LD_ADDR_VAR 0 18
59757: PUSH
59758: LD_INT 7
59760: PUSH
59761: LD_INT 28
59763: PUSH
59764: LD_INT 45
59766: PUSH
59767: EMPTY
59768: LIST
59769: LIST
59770: LIST
59771: PUSH
59772: LD_VAR 0 12
59776: ARRAY
59777: ST_TO_ADDR
// break ;
59778: GO 59782
// end ; end ; end ;
59780: GO 59611
59782: POP
59783: POP
// end ; if not weapon then
59784: LD_VAR 0 18
59788: NOT
59789: IFFALSE 59849
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59791: LD_ADDR_VAR 0 5
59795: PUSH
59796: LD_VAR 0 5
59800: PUSH
59801: LD_INT 11
59803: PUSH
59804: LD_INT 30
59806: PUSH
59807: LD_INT 49
59809: PUSH
59810: EMPTY
59811: LIST
59812: LIST
59813: LIST
59814: DIFF
59815: ST_TO_ADDR
// if not list then
59816: LD_VAR 0 5
59820: NOT
59821: IFFALSE 59825
// exit ;
59823: GO 59967
// weapon := list [ rand ( 1 , list ) ] ;
59825: LD_ADDR_VAR 0 18
59829: PUSH
59830: LD_VAR 0 5
59834: PUSH
59835: LD_INT 1
59837: PPUSH
59838: LD_VAR 0 5
59842: PPUSH
59843: CALL_OW 12
59847: ARRAY
59848: ST_TO_ADDR
// end ; if weapon then
59849: LD_VAR 0 18
59853: IFFALSE 59967
// begin tmp := CostOfWeapon ( weapon ) ;
59855: LD_ADDR_VAR 0 14
59859: PUSH
59860: LD_VAR 0 18
59864: PPUSH
59865: CALL_OW 451
59869: ST_TO_ADDR
// j := GetBase ( tower ) ;
59870: LD_ADDR_VAR 0 9
59874: PUSH
59875: LD_VAR 0 1
59879: PPUSH
59880: CALL_OW 274
59884: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59885: LD_VAR 0 9
59889: PPUSH
59890: LD_INT 1
59892: PPUSH
59893: CALL_OW 275
59897: PUSH
59898: LD_VAR 0 14
59902: PUSH
59903: LD_INT 1
59905: ARRAY
59906: GREATEREQUAL
59907: PUSH
59908: LD_VAR 0 9
59912: PPUSH
59913: LD_INT 2
59915: PPUSH
59916: CALL_OW 275
59920: PUSH
59921: LD_VAR 0 14
59925: PUSH
59926: LD_INT 2
59928: ARRAY
59929: GREATEREQUAL
59930: AND
59931: PUSH
59932: LD_VAR 0 9
59936: PPUSH
59937: LD_INT 3
59939: PPUSH
59940: CALL_OW 275
59944: PUSH
59945: LD_VAR 0 14
59949: PUSH
59950: LD_INT 3
59952: ARRAY
59953: GREATEREQUAL
59954: AND
59955: IFFALSE 59967
// result := weapon ;
59957: LD_ADDR_VAR 0 3
59961: PUSH
59962: LD_VAR 0 18
59966: ST_TO_ADDR
// end ; end ;
59967: LD_VAR 0 3
59971: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59972: LD_INT 0
59974: PPUSH
59975: PPUSH
// result := true ;
59976: LD_ADDR_VAR 0 3
59980: PUSH
59981: LD_INT 1
59983: ST_TO_ADDR
// if array1 = array2 then
59984: LD_VAR 0 1
59988: PUSH
59989: LD_VAR 0 2
59993: EQUAL
59994: IFFALSE 60054
// begin for i = 1 to array1 do
59996: LD_ADDR_VAR 0 4
60000: PUSH
60001: DOUBLE
60002: LD_INT 1
60004: DEC
60005: ST_TO_ADDR
60006: LD_VAR 0 1
60010: PUSH
60011: FOR_TO
60012: IFFALSE 60050
// if array1 [ i ] <> array2 [ i ] then
60014: LD_VAR 0 1
60018: PUSH
60019: LD_VAR 0 4
60023: ARRAY
60024: PUSH
60025: LD_VAR 0 2
60029: PUSH
60030: LD_VAR 0 4
60034: ARRAY
60035: NONEQUAL
60036: IFFALSE 60048
// begin result := false ;
60038: LD_ADDR_VAR 0 3
60042: PUSH
60043: LD_INT 0
60045: ST_TO_ADDR
// break ;
60046: GO 60050
// end ;
60048: GO 60011
60050: POP
60051: POP
// end else
60052: GO 60062
// result := false ;
60054: LD_ADDR_VAR 0 3
60058: PUSH
60059: LD_INT 0
60061: ST_TO_ADDR
// end ;
60062: LD_VAR 0 3
60066: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60067: LD_INT 0
60069: PPUSH
60070: PPUSH
// if not array1 or not array2 then
60071: LD_VAR 0 1
60075: NOT
60076: PUSH
60077: LD_VAR 0 2
60081: NOT
60082: OR
60083: IFFALSE 60087
// exit ;
60085: GO 60151
// result := true ;
60087: LD_ADDR_VAR 0 3
60091: PUSH
60092: LD_INT 1
60094: ST_TO_ADDR
// for i = 1 to array1 do
60095: LD_ADDR_VAR 0 4
60099: PUSH
60100: DOUBLE
60101: LD_INT 1
60103: DEC
60104: ST_TO_ADDR
60105: LD_VAR 0 1
60109: PUSH
60110: FOR_TO
60111: IFFALSE 60149
// if array1 [ i ] <> array2 [ i ] then
60113: LD_VAR 0 1
60117: PUSH
60118: LD_VAR 0 4
60122: ARRAY
60123: PUSH
60124: LD_VAR 0 2
60128: PUSH
60129: LD_VAR 0 4
60133: ARRAY
60134: NONEQUAL
60135: IFFALSE 60147
// begin result := false ;
60137: LD_ADDR_VAR 0 3
60141: PUSH
60142: LD_INT 0
60144: ST_TO_ADDR
// break ;
60145: GO 60149
// end ;
60147: GO 60110
60149: POP
60150: POP
// end ;
60151: LD_VAR 0 3
60155: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60156: LD_INT 0
60158: PPUSH
60159: PPUSH
60160: PPUSH
// pom := GetBase ( fac ) ;
60161: LD_ADDR_VAR 0 5
60165: PUSH
60166: LD_VAR 0 1
60170: PPUSH
60171: CALL_OW 274
60175: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60176: LD_ADDR_VAR 0 4
60180: PUSH
60181: LD_VAR 0 2
60185: PUSH
60186: LD_INT 1
60188: ARRAY
60189: PPUSH
60190: LD_VAR 0 2
60194: PUSH
60195: LD_INT 2
60197: ARRAY
60198: PPUSH
60199: LD_VAR 0 2
60203: PUSH
60204: LD_INT 3
60206: ARRAY
60207: PPUSH
60208: LD_VAR 0 2
60212: PUSH
60213: LD_INT 4
60215: ARRAY
60216: PPUSH
60217: CALL_OW 449
60221: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60222: LD_ADDR_VAR 0 3
60226: PUSH
60227: LD_VAR 0 5
60231: PPUSH
60232: LD_INT 1
60234: PPUSH
60235: CALL_OW 275
60239: PUSH
60240: LD_VAR 0 4
60244: PUSH
60245: LD_INT 1
60247: ARRAY
60248: GREATEREQUAL
60249: PUSH
60250: LD_VAR 0 5
60254: PPUSH
60255: LD_INT 2
60257: PPUSH
60258: CALL_OW 275
60262: PUSH
60263: LD_VAR 0 4
60267: PUSH
60268: LD_INT 2
60270: ARRAY
60271: GREATEREQUAL
60272: AND
60273: PUSH
60274: LD_VAR 0 5
60278: PPUSH
60279: LD_INT 3
60281: PPUSH
60282: CALL_OW 275
60286: PUSH
60287: LD_VAR 0 4
60291: PUSH
60292: LD_INT 3
60294: ARRAY
60295: GREATEREQUAL
60296: AND
60297: ST_TO_ADDR
// end ;
60298: LD_VAR 0 3
60302: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60303: LD_INT 0
60305: PPUSH
60306: PPUSH
60307: PPUSH
60308: PPUSH
// pom := GetBase ( building ) ;
60309: LD_ADDR_VAR 0 3
60313: PUSH
60314: LD_VAR 0 1
60318: PPUSH
60319: CALL_OW 274
60323: ST_TO_ADDR
// if not pom then
60324: LD_VAR 0 3
60328: NOT
60329: IFFALSE 60333
// exit ;
60331: GO 60503
// btype := GetBType ( building ) ;
60333: LD_ADDR_VAR 0 5
60337: PUSH
60338: LD_VAR 0 1
60342: PPUSH
60343: CALL_OW 266
60347: ST_TO_ADDR
// if btype = b_armoury then
60348: LD_VAR 0 5
60352: PUSH
60353: LD_INT 4
60355: EQUAL
60356: IFFALSE 60366
// btype := b_barracks ;
60358: LD_ADDR_VAR 0 5
60362: PUSH
60363: LD_INT 5
60365: ST_TO_ADDR
// if btype = b_depot then
60366: LD_VAR 0 5
60370: PUSH
60371: LD_INT 0
60373: EQUAL
60374: IFFALSE 60384
// btype := b_warehouse ;
60376: LD_ADDR_VAR 0 5
60380: PUSH
60381: LD_INT 1
60383: ST_TO_ADDR
// if btype = b_workshop then
60384: LD_VAR 0 5
60388: PUSH
60389: LD_INT 2
60391: EQUAL
60392: IFFALSE 60402
// btype := b_factory ;
60394: LD_ADDR_VAR 0 5
60398: PUSH
60399: LD_INT 3
60401: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60402: LD_ADDR_VAR 0 4
60406: PUSH
60407: LD_VAR 0 5
60411: PPUSH
60412: LD_VAR 0 1
60416: PPUSH
60417: CALL_OW 248
60421: PPUSH
60422: CALL_OW 450
60426: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60427: LD_ADDR_VAR 0 2
60431: PUSH
60432: LD_VAR 0 3
60436: PPUSH
60437: LD_INT 1
60439: PPUSH
60440: CALL_OW 275
60444: PUSH
60445: LD_VAR 0 4
60449: PUSH
60450: LD_INT 1
60452: ARRAY
60453: GREATEREQUAL
60454: PUSH
60455: LD_VAR 0 3
60459: PPUSH
60460: LD_INT 2
60462: PPUSH
60463: CALL_OW 275
60467: PUSH
60468: LD_VAR 0 4
60472: PUSH
60473: LD_INT 2
60475: ARRAY
60476: GREATEREQUAL
60477: AND
60478: PUSH
60479: LD_VAR 0 3
60483: PPUSH
60484: LD_INT 3
60486: PPUSH
60487: CALL_OW 275
60491: PUSH
60492: LD_VAR 0 4
60496: PUSH
60497: LD_INT 3
60499: ARRAY
60500: GREATEREQUAL
60501: AND
60502: ST_TO_ADDR
// end ;
60503: LD_VAR 0 2
60507: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60508: LD_INT 0
60510: PPUSH
60511: PPUSH
60512: PPUSH
// pom := GetBase ( building ) ;
60513: LD_ADDR_VAR 0 4
60517: PUSH
60518: LD_VAR 0 1
60522: PPUSH
60523: CALL_OW 274
60527: ST_TO_ADDR
// if not pom then
60528: LD_VAR 0 4
60532: NOT
60533: IFFALSE 60537
// exit ;
60535: GO 60638
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60537: LD_ADDR_VAR 0 5
60541: PUSH
60542: LD_VAR 0 2
60546: PPUSH
60547: LD_VAR 0 1
60551: PPUSH
60552: CALL_OW 248
60556: PPUSH
60557: CALL_OW 450
60561: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60562: LD_ADDR_VAR 0 3
60566: PUSH
60567: LD_VAR 0 4
60571: PPUSH
60572: LD_INT 1
60574: PPUSH
60575: CALL_OW 275
60579: PUSH
60580: LD_VAR 0 5
60584: PUSH
60585: LD_INT 1
60587: ARRAY
60588: GREATEREQUAL
60589: PUSH
60590: LD_VAR 0 4
60594: PPUSH
60595: LD_INT 2
60597: PPUSH
60598: CALL_OW 275
60602: PUSH
60603: LD_VAR 0 5
60607: PUSH
60608: LD_INT 2
60610: ARRAY
60611: GREATEREQUAL
60612: AND
60613: PUSH
60614: LD_VAR 0 4
60618: PPUSH
60619: LD_INT 3
60621: PPUSH
60622: CALL_OW 275
60626: PUSH
60627: LD_VAR 0 5
60631: PUSH
60632: LD_INT 3
60634: ARRAY
60635: GREATEREQUAL
60636: AND
60637: ST_TO_ADDR
// end ;
60638: LD_VAR 0 3
60642: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60643: LD_INT 0
60645: PPUSH
60646: PPUSH
60647: PPUSH
60648: PPUSH
60649: PPUSH
60650: PPUSH
60651: PPUSH
60652: PPUSH
60653: PPUSH
60654: PPUSH
60655: PPUSH
// result := false ;
60656: LD_ADDR_VAR 0 8
60660: PUSH
60661: LD_INT 0
60663: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60664: LD_VAR 0 5
60668: NOT
60669: PUSH
60670: LD_VAR 0 1
60674: NOT
60675: OR
60676: PUSH
60677: LD_VAR 0 2
60681: NOT
60682: OR
60683: PUSH
60684: LD_VAR 0 3
60688: NOT
60689: OR
60690: IFFALSE 60694
// exit ;
60692: GO 61508
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60694: LD_ADDR_VAR 0 14
60698: PUSH
60699: LD_VAR 0 1
60703: PPUSH
60704: LD_VAR 0 2
60708: PPUSH
60709: LD_VAR 0 3
60713: PPUSH
60714: LD_VAR 0 4
60718: PPUSH
60719: LD_VAR 0 5
60723: PUSH
60724: LD_INT 1
60726: ARRAY
60727: PPUSH
60728: CALL_OW 248
60732: PPUSH
60733: LD_INT 0
60735: PPUSH
60736: CALL 62741 0 6
60740: ST_TO_ADDR
// if not hexes then
60741: LD_VAR 0 14
60745: NOT
60746: IFFALSE 60750
// exit ;
60748: GO 61508
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60750: LD_ADDR_VAR 0 17
60754: PUSH
60755: LD_VAR 0 5
60759: PPUSH
60760: LD_INT 22
60762: PUSH
60763: LD_VAR 0 13
60767: PPUSH
60768: CALL_OW 255
60772: PUSH
60773: EMPTY
60774: LIST
60775: LIST
60776: PUSH
60777: LD_INT 2
60779: PUSH
60780: LD_INT 30
60782: PUSH
60783: LD_INT 0
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: PUSH
60790: LD_INT 30
60792: PUSH
60793: LD_INT 1
60795: PUSH
60796: EMPTY
60797: LIST
60798: LIST
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: LIST
60804: PUSH
60805: EMPTY
60806: LIST
60807: LIST
60808: PPUSH
60809: CALL_OW 72
60813: ST_TO_ADDR
// for i = 1 to hexes do
60814: LD_ADDR_VAR 0 9
60818: PUSH
60819: DOUBLE
60820: LD_INT 1
60822: DEC
60823: ST_TO_ADDR
60824: LD_VAR 0 14
60828: PUSH
60829: FOR_TO
60830: IFFALSE 61506
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60832: LD_ADDR_VAR 0 13
60836: PUSH
60837: LD_VAR 0 14
60841: PUSH
60842: LD_VAR 0 9
60846: ARRAY
60847: PUSH
60848: LD_INT 1
60850: ARRAY
60851: PPUSH
60852: LD_VAR 0 14
60856: PUSH
60857: LD_VAR 0 9
60861: ARRAY
60862: PUSH
60863: LD_INT 2
60865: ARRAY
60866: PPUSH
60867: CALL_OW 428
60871: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60872: LD_VAR 0 14
60876: PUSH
60877: LD_VAR 0 9
60881: ARRAY
60882: PUSH
60883: LD_INT 1
60885: ARRAY
60886: PPUSH
60887: LD_VAR 0 14
60891: PUSH
60892: LD_VAR 0 9
60896: ARRAY
60897: PUSH
60898: LD_INT 2
60900: ARRAY
60901: PPUSH
60902: CALL_OW 351
60906: PUSH
60907: LD_VAR 0 14
60911: PUSH
60912: LD_VAR 0 9
60916: ARRAY
60917: PUSH
60918: LD_INT 1
60920: ARRAY
60921: PPUSH
60922: LD_VAR 0 14
60926: PUSH
60927: LD_VAR 0 9
60931: ARRAY
60932: PUSH
60933: LD_INT 2
60935: ARRAY
60936: PPUSH
60937: CALL_OW 488
60941: NOT
60942: OR
60943: PUSH
60944: LD_VAR 0 13
60948: PPUSH
60949: CALL_OW 247
60953: PUSH
60954: LD_INT 3
60956: EQUAL
60957: OR
60958: IFFALSE 60964
// exit ;
60960: POP
60961: POP
60962: GO 61508
// if not tmp then
60964: LD_VAR 0 13
60968: NOT
60969: IFFALSE 60973
// continue ;
60971: GO 60829
// result := true ;
60973: LD_ADDR_VAR 0 8
60977: PUSH
60978: LD_INT 1
60980: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60981: LD_VAR 0 6
60985: PUSH
60986: LD_VAR 0 13
60990: PPUSH
60991: CALL_OW 247
60995: PUSH
60996: LD_INT 2
60998: EQUAL
60999: AND
61000: PUSH
61001: LD_VAR 0 13
61005: PPUSH
61006: CALL_OW 263
61010: PUSH
61011: LD_INT 1
61013: EQUAL
61014: AND
61015: IFFALSE 61179
// begin if IsDrivenBy ( tmp ) then
61017: LD_VAR 0 13
61021: PPUSH
61022: CALL_OW 311
61026: IFFALSE 61030
// continue ;
61028: GO 60829
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61030: LD_VAR 0 6
61034: PPUSH
61035: LD_INT 3
61037: PUSH
61038: LD_INT 60
61040: PUSH
61041: EMPTY
61042: LIST
61043: PUSH
61044: EMPTY
61045: LIST
61046: LIST
61047: PUSH
61048: LD_INT 3
61050: PUSH
61051: LD_INT 55
61053: PUSH
61054: EMPTY
61055: LIST
61056: PUSH
61057: EMPTY
61058: LIST
61059: LIST
61060: PUSH
61061: EMPTY
61062: LIST
61063: LIST
61064: PPUSH
61065: CALL_OW 72
61069: IFFALSE 61177
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61071: LD_ADDR_VAR 0 18
61075: PUSH
61076: LD_VAR 0 6
61080: PPUSH
61081: LD_INT 3
61083: PUSH
61084: LD_INT 60
61086: PUSH
61087: EMPTY
61088: LIST
61089: PUSH
61090: EMPTY
61091: LIST
61092: LIST
61093: PUSH
61094: LD_INT 3
61096: PUSH
61097: LD_INT 55
61099: PUSH
61100: EMPTY
61101: LIST
61102: PUSH
61103: EMPTY
61104: LIST
61105: LIST
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PPUSH
61111: CALL_OW 72
61115: PUSH
61116: LD_INT 1
61118: ARRAY
61119: ST_TO_ADDR
// if IsInUnit ( driver ) then
61120: LD_VAR 0 18
61124: PPUSH
61125: CALL_OW 310
61129: IFFALSE 61140
// ComExit ( driver ) ;
61131: LD_VAR 0 18
61135: PPUSH
61136: CALL 86502 0 1
// AddComEnterUnit ( driver , tmp ) ;
61140: LD_VAR 0 18
61144: PPUSH
61145: LD_VAR 0 13
61149: PPUSH
61150: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61154: LD_VAR 0 18
61158: PPUSH
61159: LD_VAR 0 7
61163: PPUSH
61164: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61168: LD_VAR 0 18
61172: PPUSH
61173: CALL_OW 181
// end ; continue ;
61177: GO 60829
// end ; if not cleaners or not tmp in cleaners then
61179: LD_VAR 0 6
61183: NOT
61184: PUSH
61185: LD_VAR 0 13
61189: PUSH
61190: LD_VAR 0 6
61194: IN
61195: NOT
61196: OR
61197: IFFALSE 61504
// begin if dep then
61199: LD_VAR 0 17
61203: IFFALSE 61339
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61205: LD_ADDR_VAR 0 16
61209: PUSH
61210: LD_VAR 0 17
61214: PUSH
61215: LD_INT 1
61217: ARRAY
61218: PPUSH
61219: CALL_OW 250
61223: PPUSH
61224: LD_VAR 0 17
61228: PUSH
61229: LD_INT 1
61231: ARRAY
61232: PPUSH
61233: CALL_OW 254
61237: PPUSH
61238: LD_INT 5
61240: PPUSH
61241: CALL_OW 272
61245: PUSH
61246: LD_VAR 0 17
61250: PUSH
61251: LD_INT 1
61253: ARRAY
61254: PPUSH
61255: CALL_OW 251
61259: PPUSH
61260: LD_VAR 0 17
61264: PUSH
61265: LD_INT 1
61267: ARRAY
61268: PPUSH
61269: CALL_OW 254
61273: PPUSH
61274: LD_INT 5
61276: PPUSH
61277: CALL_OW 273
61281: PUSH
61282: EMPTY
61283: LIST
61284: LIST
61285: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61286: LD_VAR 0 16
61290: PUSH
61291: LD_INT 1
61293: ARRAY
61294: PPUSH
61295: LD_VAR 0 16
61299: PUSH
61300: LD_INT 2
61302: ARRAY
61303: PPUSH
61304: CALL_OW 488
61308: IFFALSE 61339
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61310: LD_VAR 0 13
61314: PPUSH
61315: LD_VAR 0 16
61319: PUSH
61320: LD_INT 1
61322: ARRAY
61323: PPUSH
61324: LD_VAR 0 16
61328: PUSH
61329: LD_INT 2
61331: ARRAY
61332: PPUSH
61333: CALL_OW 111
// continue ;
61337: GO 60829
// end ; end ; r := GetDir ( tmp ) ;
61339: LD_ADDR_VAR 0 15
61343: PUSH
61344: LD_VAR 0 13
61348: PPUSH
61349: CALL_OW 254
61353: ST_TO_ADDR
// if r = 5 then
61354: LD_VAR 0 15
61358: PUSH
61359: LD_INT 5
61361: EQUAL
61362: IFFALSE 61372
// r := 0 ;
61364: LD_ADDR_VAR 0 15
61368: PUSH
61369: LD_INT 0
61371: ST_TO_ADDR
// for j = r to 5 do
61372: LD_ADDR_VAR 0 10
61376: PUSH
61377: DOUBLE
61378: LD_VAR 0 15
61382: DEC
61383: ST_TO_ADDR
61384: LD_INT 5
61386: PUSH
61387: FOR_TO
61388: IFFALSE 61502
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61390: LD_ADDR_VAR 0 11
61394: PUSH
61395: LD_VAR 0 13
61399: PPUSH
61400: CALL_OW 250
61404: PPUSH
61405: LD_VAR 0 10
61409: PPUSH
61410: LD_INT 2
61412: PPUSH
61413: CALL_OW 272
61417: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61418: LD_ADDR_VAR 0 12
61422: PUSH
61423: LD_VAR 0 13
61427: PPUSH
61428: CALL_OW 251
61432: PPUSH
61433: LD_VAR 0 10
61437: PPUSH
61438: LD_INT 2
61440: PPUSH
61441: CALL_OW 273
61445: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61446: LD_VAR 0 11
61450: PPUSH
61451: LD_VAR 0 12
61455: PPUSH
61456: CALL_OW 488
61460: PUSH
61461: LD_VAR 0 11
61465: PPUSH
61466: LD_VAR 0 12
61470: PPUSH
61471: CALL_OW 428
61475: NOT
61476: AND
61477: IFFALSE 61500
// begin ComMoveXY ( tmp , _x , _y ) ;
61479: LD_VAR 0 13
61483: PPUSH
61484: LD_VAR 0 11
61488: PPUSH
61489: LD_VAR 0 12
61493: PPUSH
61494: CALL_OW 111
// break ;
61498: GO 61502
// end ; end ;
61500: GO 61387
61502: POP
61503: POP
// end ; end ;
61504: GO 60829
61506: POP
61507: POP
// end ;
61508: LD_VAR 0 8
61512: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61513: LD_INT 0
61515: PPUSH
// result := true ;
61516: LD_ADDR_VAR 0 3
61520: PUSH
61521: LD_INT 1
61523: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61524: LD_VAR 0 2
61528: PUSH
61529: LD_INT 24
61531: DOUBLE
61532: EQUAL
61533: IFTRUE 61543
61535: LD_INT 33
61537: DOUBLE
61538: EQUAL
61539: IFTRUE 61543
61541: GO 61568
61543: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61544: LD_ADDR_VAR 0 3
61548: PUSH
61549: LD_INT 32
61551: PPUSH
61552: LD_VAR 0 1
61556: PPUSH
61557: CALL_OW 321
61561: PUSH
61562: LD_INT 2
61564: EQUAL
61565: ST_TO_ADDR
61566: GO 61884
61568: LD_INT 20
61570: DOUBLE
61571: EQUAL
61572: IFTRUE 61576
61574: GO 61601
61576: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61577: LD_ADDR_VAR 0 3
61581: PUSH
61582: LD_INT 6
61584: PPUSH
61585: LD_VAR 0 1
61589: PPUSH
61590: CALL_OW 321
61594: PUSH
61595: LD_INT 2
61597: EQUAL
61598: ST_TO_ADDR
61599: GO 61884
61601: LD_INT 22
61603: DOUBLE
61604: EQUAL
61605: IFTRUE 61615
61607: LD_INT 36
61609: DOUBLE
61610: EQUAL
61611: IFTRUE 61615
61613: GO 61640
61615: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61616: LD_ADDR_VAR 0 3
61620: PUSH
61621: LD_INT 15
61623: PPUSH
61624: LD_VAR 0 1
61628: PPUSH
61629: CALL_OW 321
61633: PUSH
61634: LD_INT 2
61636: EQUAL
61637: ST_TO_ADDR
61638: GO 61884
61640: LD_INT 30
61642: DOUBLE
61643: EQUAL
61644: IFTRUE 61648
61646: GO 61673
61648: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61649: LD_ADDR_VAR 0 3
61653: PUSH
61654: LD_INT 20
61656: PPUSH
61657: LD_VAR 0 1
61661: PPUSH
61662: CALL_OW 321
61666: PUSH
61667: LD_INT 2
61669: EQUAL
61670: ST_TO_ADDR
61671: GO 61884
61673: LD_INT 28
61675: DOUBLE
61676: EQUAL
61677: IFTRUE 61687
61679: LD_INT 21
61681: DOUBLE
61682: EQUAL
61683: IFTRUE 61687
61685: GO 61712
61687: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61688: LD_ADDR_VAR 0 3
61692: PUSH
61693: LD_INT 21
61695: PPUSH
61696: LD_VAR 0 1
61700: PPUSH
61701: CALL_OW 321
61705: PUSH
61706: LD_INT 2
61708: EQUAL
61709: ST_TO_ADDR
61710: GO 61884
61712: LD_INT 16
61714: DOUBLE
61715: EQUAL
61716: IFTRUE 61720
61718: GO 61745
61720: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61721: LD_ADDR_VAR 0 3
61725: PUSH
61726: LD_INT 84
61728: PPUSH
61729: LD_VAR 0 1
61733: PPUSH
61734: CALL_OW 321
61738: PUSH
61739: LD_INT 2
61741: EQUAL
61742: ST_TO_ADDR
61743: GO 61884
61745: LD_INT 19
61747: DOUBLE
61748: EQUAL
61749: IFTRUE 61759
61751: LD_INT 23
61753: DOUBLE
61754: EQUAL
61755: IFTRUE 61759
61757: GO 61784
61759: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61760: LD_ADDR_VAR 0 3
61764: PUSH
61765: LD_INT 83
61767: PPUSH
61768: LD_VAR 0 1
61772: PPUSH
61773: CALL_OW 321
61777: PUSH
61778: LD_INT 2
61780: EQUAL
61781: ST_TO_ADDR
61782: GO 61884
61784: LD_INT 17
61786: DOUBLE
61787: EQUAL
61788: IFTRUE 61792
61790: GO 61817
61792: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61793: LD_ADDR_VAR 0 3
61797: PUSH
61798: LD_INT 39
61800: PPUSH
61801: LD_VAR 0 1
61805: PPUSH
61806: CALL_OW 321
61810: PUSH
61811: LD_INT 2
61813: EQUAL
61814: ST_TO_ADDR
61815: GO 61884
61817: LD_INT 18
61819: DOUBLE
61820: EQUAL
61821: IFTRUE 61825
61823: GO 61850
61825: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61826: LD_ADDR_VAR 0 3
61830: PUSH
61831: LD_INT 40
61833: PPUSH
61834: LD_VAR 0 1
61838: PPUSH
61839: CALL_OW 321
61843: PUSH
61844: LD_INT 2
61846: EQUAL
61847: ST_TO_ADDR
61848: GO 61884
61850: LD_INT 27
61852: DOUBLE
61853: EQUAL
61854: IFTRUE 61858
61856: GO 61883
61858: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61859: LD_ADDR_VAR 0 3
61863: PUSH
61864: LD_INT 35
61866: PPUSH
61867: LD_VAR 0 1
61871: PPUSH
61872: CALL_OW 321
61876: PUSH
61877: LD_INT 2
61879: EQUAL
61880: ST_TO_ADDR
61881: GO 61884
61883: POP
// end ;
61884: LD_VAR 0 3
61888: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61889: LD_INT 0
61891: PPUSH
61892: PPUSH
61893: PPUSH
61894: PPUSH
61895: PPUSH
61896: PPUSH
61897: PPUSH
61898: PPUSH
61899: PPUSH
61900: PPUSH
61901: PPUSH
// result := false ;
61902: LD_ADDR_VAR 0 6
61906: PUSH
61907: LD_INT 0
61909: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61910: LD_VAR 0 1
61914: NOT
61915: PUSH
61916: LD_VAR 0 1
61920: PPUSH
61921: CALL_OW 266
61925: PUSH
61926: LD_INT 0
61928: PUSH
61929: LD_INT 1
61931: PUSH
61932: EMPTY
61933: LIST
61934: LIST
61935: IN
61936: NOT
61937: OR
61938: PUSH
61939: LD_VAR 0 2
61943: NOT
61944: OR
61945: PUSH
61946: LD_VAR 0 5
61950: PUSH
61951: LD_INT 0
61953: PUSH
61954: LD_INT 1
61956: PUSH
61957: LD_INT 2
61959: PUSH
61960: LD_INT 3
61962: PUSH
61963: LD_INT 4
61965: PUSH
61966: LD_INT 5
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: IN
61977: NOT
61978: OR
61979: PUSH
61980: LD_VAR 0 3
61984: PPUSH
61985: LD_VAR 0 4
61989: PPUSH
61990: CALL_OW 488
61994: NOT
61995: OR
61996: IFFALSE 62000
// exit ;
61998: GO 62736
// side := GetSide ( depot ) ;
62000: LD_ADDR_VAR 0 9
62004: PUSH
62005: LD_VAR 0 1
62009: PPUSH
62010: CALL_OW 255
62014: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62015: LD_VAR 0 9
62019: PPUSH
62020: LD_VAR 0 2
62024: PPUSH
62025: CALL 61513 0 2
62029: NOT
62030: IFFALSE 62034
// exit ;
62032: GO 62736
// pom := GetBase ( depot ) ;
62034: LD_ADDR_VAR 0 10
62038: PUSH
62039: LD_VAR 0 1
62043: PPUSH
62044: CALL_OW 274
62048: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62049: LD_ADDR_VAR 0 11
62053: PUSH
62054: LD_VAR 0 2
62058: PPUSH
62059: LD_VAR 0 1
62063: PPUSH
62064: CALL_OW 248
62068: PPUSH
62069: CALL_OW 450
62073: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62074: LD_VAR 0 10
62078: PPUSH
62079: LD_INT 1
62081: PPUSH
62082: CALL_OW 275
62086: PUSH
62087: LD_VAR 0 11
62091: PUSH
62092: LD_INT 1
62094: ARRAY
62095: GREATEREQUAL
62096: PUSH
62097: LD_VAR 0 10
62101: PPUSH
62102: LD_INT 2
62104: PPUSH
62105: CALL_OW 275
62109: PUSH
62110: LD_VAR 0 11
62114: PUSH
62115: LD_INT 2
62117: ARRAY
62118: GREATEREQUAL
62119: AND
62120: PUSH
62121: LD_VAR 0 10
62125: PPUSH
62126: LD_INT 3
62128: PPUSH
62129: CALL_OW 275
62133: PUSH
62134: LD_VAR 0 11
62138: PUSH
62139: LD_INT 3
62141: ARRAY
62142: GREATEREQUAL
62143: AND
62144: NOT
62145: IFFALSE 62149
// exit ;
62147: GO 62736
// if GetBType ( depot ) = b_depot then
62149: LD_VAR 0 1
62153: PPUSH
62154: CALL_OW 266
62158: PUSH
62159: LD_INT 0
62161: EQUAL
62162: IFFALSE 62174
// dist := 28 else
62164: LD_ADDR_VAR 0 14
62168: PUSH
62169: LD_INT 28
62171: ST_TO_ADDR
62172: GO 62182
// dist := 36 ;
62174: LD_ADDR_VAR 0 14
62178: PUSH
62179: LD_INT 36
62181: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62182: LD_VAR 0 1
62186: PPUSH
62187: LD_VAR 0 3
62191: PPUSH
62192: LD_VAR 0 4
62196: PPUSH
62197: CALL_OW 297
62201: PUSH
62202: LD_VAR 0 14
62206: GREATER
62207: IFFALSE 62211
// exit ;
62209: GO 62736
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62211: LD_ADDR_VAR 0 12
62215: PUSH
62216: LD_VAR 0 2
62220: PPUSH
62221: LD_VAR 0 3
62225: PPUSH
62226: LD_VAR 0 4
62230: PPUSH
62231: LD_VAR 0 5
62235: PPUSH
62236: LD_VAR 0 1
62240: PPUSH
62241: CALL_OW 248
62245: PPUSH
62246: LD_INT 0
62248: PPUSH
62249: CALL 62741 0 6
62253: ST_TO_ADDR
// if not hexes then
62254: LD_VAR 0 12
62258: NOT
62259: IFFALSE 62263
// exit ;
62261: GO 62736
// hex := GetHexInfo ( x , y ) ;
62263: LD_ADDR_VAR 0 15
62267: PUSH
62268: LD_VAR 0 3
62272: PPUSH
62273: LD_VAR 0 4
62277: PPUSH
62278: CALL_OW 546
62282: ST_TO_ADDR
// if hex [ 1 ] then
62283: LD_VAR 0 15
62287: PUSH
62288: LD_INT 1
62290: ARRAY
62291: IFFALSE 62295
// exit ;
62293: GO 62736
// height := hex [ 2 ] ;
62295: LD_ADDR_VAR 0 13
62299: PUSH
62300: LD_VAR 0 15
62304: PUSH
62305: LD_INT 2
62307: ARRAY
62308: ST_TO_ADDR
// for i = 1 to hexes do
62309: LD_ADDR_VAR 0 7
62313: PUSH
62314: DOUBLE
62315: LD_INT 1
62317: DEC
62318: ST_TO_ADDR
62319: LD_VAR 0 12
62323: PUSH
62324: FOR_TO
62325: IFFALSE 62655
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62327: LD_VAR 0 12
62331: PUSH
62332: LD_VAR 0 7
62336: ARRAY
62337: PUSH
62338: LD_INT 1
62340: ARRAY
62341: PPUSH
62342: LD_VAR 0 12
62346: PUSH
62347: LD_VAR 0 7
62351: ARRAY
62352: PUSH
62353: LD_INT 2
62355: ARRAY
62356: PPUSH
62357: CALL_OW 488
62361: NOT
62362: PUSH
62363: LD_VAR 0 12
62367: PUSH
62368: LD_VAR 0 7
62372: ARRAY
62373: PUSH
62374: LD_INT 1
62376: ARRAY
62377: PPUSH
62378: LD_VAR 0 12
62382: PUSH
62383: LD_VAR 0 7
62387: ARRAY
62388: PUSH
62389: LD_INT 2
62391: ARRAY
62392: PPUSH
62393: CALL_OW 428
62397: PUSH
62398: LD_INT 0
62400: GREATER
62401: OR
62402: PUSH
62403: LD_VAR 0 12
62407: PUSH
62408: LD_VAR 0 7
62412: ARRAY
62413: PUSH
62414: LD_INT 1
62416: ARRAY
62417: PPUSH
62418: LD_VAR 0 12
62422: PUSH
62423: LD_VAR 0 7
62427: ARRAY
62428: PUSH
62429: LD_INT 2
62431: ARRAY
62432: PPUSH
62433: CALL_OW 351
62437: OR
62438: IFFALSE 62444
// exit ;
62440: POP
62441: POP
62442: GO 62736
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62444: LD_ADDR_VAR 0 8
62448: PUSH
62449: LD_VAR 0 12
62453: PUSH
62454: LD_VAR 0 7
62458: ARRAY
62459: PUSH
62460: LD_INT 1
62462: ARRAY
62463: PPUSH
62464: LD_VAR 0 12
62468: PUSH
62469: LD_VAR 0 7
62473: ARRAY
62474: PUSH
62475: LD_INT 2
62477: ARRAY
62478: PPUSH
62479: CALL_OW 546
62483: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62484: LD_VAR 0 8
62488: PUSH
62489: LD_INT 1
62491: ARRAY
62492: PUSH
62493: LD_VAR 0 8
62497: PUSH
62498: LD_INT 2
62500: ARRAY
62501: PUSH
62502: LD_VAR 0 13
62506: PUSH
62507: LD_INT 2
62509: PLUS
62510: GREATER
62511: OR
62512: PUSH
62513: LD_VAR 0 8
62517: PUSH
62518: LD_INT 2
62520: ARRAY
62521: PUSH
62522: LD_VAR 0 13
62526: PUSH
62527: LD_INT 2
62529: MINUS
62530: LESS
62531: OR
62532: PUSH
62533: LD_VAR 0 8
62537: PUSH
62538: LD_INT 3
62540: ARRAY
62541: PUSH
62542: LD_INT 0
62544: PUSH
62545: LD_INT 8
62547: PUSH
62548: LD_INT 9
62550: PUSH
62551: LD_INT 10
62553: PUSH
62554: LD_INT 11
62556: PUSH
62557: LD_INT 12
62559: PUSH
62560: LD_INT 13
62562: PUSH
62563: LD_INT 16
62565: PUSH
62566: LD_INT 17
62568: PUSH
62569: LD_INT 18
62571: PUSH
62572: LD_INT 19
62574: PUSH
62575: LD_INT 20
62577: PUSH
62578: LD_INT 21
62580: PUSH
62581: EMPTY
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: LIST
62587: LIST
62588: LIST
62589: LIST
62590: LIST
62591: LIST
62592: LIST
62593: LIST
62594: LIST
62595: IN
62596: NOT
62597: OR
62598: PUSH
62599: LD_VAR 0 8
62603: PUSH
62604: LD_INT 5
62606: ARRAY
62607: NOT
62608: OR
62609: PUSH
62610: LD_VAR 0 8
62614: PUSH
62615: LD_INT 6
62617: ARRAY
62618: PUSH
62619: LD_INT 1
62621: PUSH
62622: LD_INT 2
62624: PUSH
62625: LD_INT 7
62627: PUSH
62628: LD_INT 9
62630: PUSH
62631: LD_INT 10
62633: PUSH
62634: LD_INT 11
62636: PUSH
62637: EMPTY
62638: LIST
62639: LIST
62640: LIST
62641: LIST
62642: LIST
62643: LIST
62644: IN
62645: NOT
62646: OR
62647: IFFALSE 62653
// exit ;
62649: POP
62650: POP
62651: GO 62736
// end ;
62653: GO 62324
62655: POP
62656: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62657: LD_VAR 0 9
62661: PPUSH
62662: LD_VAR 0 3
62666: PPUSH
62667: LD_VAR 0 4
62671: PPUSH
62672: LD_INT 20
62674: PPUSH
62675: CALL 54688 0 4
62679: PUSH
62680: LD_INT 4
62682: ARRAY
62683: IFFALSE 62687
// exit ;
62685: GO 62736
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62687: LD_VAR 0 2
62691: PUSH
62692: LD_INT 29
62694: PUSH
62695: LD_INT 30
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: IN
62702: PUSH
62703: LD_VAR 0 3
62707: PPUSH
62708: LD_VAR 0 4
62712: PPUSH
62713: LD_VAR 0 9
62717: PPUSH
62718: CALL_OW 440
62722: NOT
62723: AND
62724: IFFALSE 62728
// exit ;
62726: GO 62736
// result := true ;
62728: LD_ADDR_VAR 0 6
62732: PUSH
62733: LD_INT 1
62735: ST_TO_ADDR
// end ;
62736: LD_VAR 0 6
62740: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62741: LD_INT 0
62743: PPUSH
62744: PPUSH
62745: PPUSH
62746: PPUSH
62747: PPUSH
62748: PPUSH
62749: PPUSH
62750: PPUSH
62751: PPUSH
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
62778: PPUSH
62779: PPUSH
62780: PPUSH
62781: PPUSH
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
62796: PPUSH
62797: PPUSH
62798: PPUSH
62799: PPUSH
62800: PPUSH
// result = [ ] ;
62801: LD_ADDR_VAR 0 7
62805: PUSH
62806: EMPTY
62807: ST_TO_ADDR
// temp_list = [ ] ;
62808: LD_ADDR_VAR 0 9
62812: PUSH
62813: EMPTY
62814: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62815: LD_VAR 0 4
62819: PUSH
62820: LD_INT 0
62822: PUSH
62823: LD_INT 1
62825: PUSH
62826: LD_INT 2
62828: PUSH
62829: LD_INT 3
62831: PUSH
62832: LD_INT 4
62834: PUSH
62835: LD_INT 5
62837: PUSH
62838: EMPTY
62839: LIST
62840: LIST
62841: LIST
62842: LIST
62843: LIST
62844: LIST
62845: IN
62846: NOT
62847: PUSH
62848: LD_VAR 0 1
62852: PUSH
62853: LD_INT 0
62855: PUSH
62856: LD_INT 1
62858: PUSH
62859: EMPTY
62860: LIST
62861: LIST
62862: IN
62863: PUSH
62864: LD_VAR 0 5
62868: PUSH
62869: LD_INT 1
62871: PUSH
62872: LD_INT 2
62874: PUSH
62875: LD_INT 3
62877: PUSH
62878: EMPTY
62879: LIST
62880: LIST
62881: LIST
62882: IN
62883: NOT
62884: AND
62885: OR
62886: IFFALSE 62890
// exit ;
62888: GO 81281
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62890: LD_VAR 0 1
62894: PUSH
62895: LD_INT 6
62897: PUSH
62898: LD_INT 7
62900: PUSH
62901: LD_INT 8
62903: PUSH
62904: LD_INT 13
62906: PUSH
62907: LD_INT 12
62909: PUSH
62910: LD_INT 15
62912: PUSH
62913: LD_INT 11
62915: PUSH
62916: LD_INT 14
62918: PUSH
62919: LD_INT 10
62921: PUSH
62922: EMPTY
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: LIST
62930: LIST
62931: LIST
62932: IN
62933: IFFALSE 62943
// btype = b_lab ;
62935: LD_ADDR_VAR 0 1
62939: PUSH
62940: LD_INT 6
62942: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62943: LD_VAR 0 6
62947: PUSH
62948: LD_INT 0
62950: PUSH
62951: LD_INT 1
62953: PUSH
62954: LD_INT 2
62956: PUSH
62957: EMPTY
62958: LIST
62959: LIST
62960: LIST
62961: IN
62962: NOT
62963: PUSH
62964: LD_VAR 0 1
62968: PUSH
62969: LD_INT 0
62971: PUSH
62972: LD_INT 1
62974: PUSH
62975: LD_INT 2
62977: PUSH
62978: LD_INT 3
62980: PUSH
62981: LD_INT 6
62983: PUSH
62984: LD_INT 36
62986: PUSH
62987: LD_INT 4
62989: PUSH
62990: LD_INT 5
62992: PUSH
62993: LD_INT 31
62995: PUSH
62996: LD_INT 32
62998: PUSH
62999: LD_INT 33
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: IN
63015: NOT
63016: PUSH
63017: LD_VAR 0 6
63021: PUSH
63022: LD_INT 1
63024: EQUAL
63025: AND
63026: OR
63027: PUSH
63028: LD_VAR 0 1
63032: PUSH
63033: LD_INT 2
63035: PUSH
63036: LD_INT 3
63038: PUSH
63039: EMPTY
63040: LIST
63041: LIST
63042: IN
63043: NOT
63044: PUSH
63045: LD_VAR 0 6
63049: PUSH
63050: LD_INT 2
63052: EQUAL
63053: AND
63054: OR
63055: IFFALSE 63065
// mode = 0 ;
63057: LD_ADDR_VAR 0 6
63061: PUSH
63062: LD_INT 0
63064: ST_TO_ADDR
// case mode of 0 :
63065: LD_VAR 0 6
63069: PUSH
63070: LD_INT 0
63072: DOUBLE
63073: EQUAL
63074: IFTRUE 63078
63076: GO 74531
63078: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63079: LD_ADDR_VAR 0 11
63083: PUSH
63084: LD_INT 0
63086: PUSH
63087: LD_INT 0
63089: PUSH
63090: EMPTY
63091: LIST
63092: LIST
63093: PUSH
63094: LD_INT 0
63096: PUSH
63097: LD_INT 1
63099: NEG
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: PUSH
63105: LD_INT 1
63107: PUSH
63108: LD_INT 0
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: PUSH
63115: LD_INT 1
63117: PUSH
63118: LD_INT 1
63120: PUSH
63121: EMPTY
63122: LIST
63123: LIST
63124: PUSH
63125: LD_INT 0
63127: PUSH
63128: LD_INT 1
63130: PUSH
63131: EMPTY
63132: LIST
63133: LIST
63134: PUSH
63135: LD_INT 1
63137: NEG
63138: PUSH
63139: LD_INT 0
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: PUSH
63146: LD_INT 1
63148: NEG
63149: PUSH
63150: LD_INT 1
63152: NEG
63153: PUSH
63154: EMPTY
63155: LIST
63156: LIST
63157: PUSH
63158: LD_INT 1
63160: NEG
63161: PUSH
63162: LD_INT 2
63164: NEG
63165: PUSH
63166: EMPTY
63167: LIST
63168: LIST
63169: PUSH
63170: LD_INT 0
63172: PUSH
63173: LD_INT 2
63175: NEG
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: PUSH
63181: LD_INT 1
63183: PUSH
63184: LD_INT 1
63186: NEG
63187: PUSH
63188: EMPTY
63189: LIST
63190: LIST
63191: PUSH
63192: LD_INT 1
63194: PUSH
63195: LD_INT 2
63197: PUSH
63198: EMPTY
63199: LIST
63200: LIST
63201: PUSH
63202: LD_INT 0
63204: PUSH
63205: LD_INT 2
63207: PUSH
63208: EMPTY
63209: LIST
63210: LIST
63211: PUSH
63212: LD_INT 1
63214: NEG
63215: PUSH
63216: LD_INT 1
63218: PUSH
63219: EMPTY
63220: LIST
63221: LIST
63222: PUSH
63223: LD_INT 1
63225: PUSH
63226: LD_INT 3
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: PUSH
63233: LD_INT 0
63235: PUSH
63236: LD_INT 3
63238: PUSH
63239: EMPTY
63240: LIST
63241: LIST
63242: PUSH
63243: LD_INT 1
63245: NEG
63246: PUSH
63247: LD_INT 2
63249: PUSH
63250: EMPTY
63251: LIST
63252: LIST
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: LIST
63270: LIST
63271: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63272: LD_ADDR_VAR 0 12
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: LD_INT 0
63282: PUSH
63283: EMPTY
63284: LIST
63285: LIST
63286: PUSH
63287: LD_INT 0
63289: PUSH
63290: LD_INT 1
63292: NEG
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PUSH
63298: LD_INT 1
63300: PUSH
63301: LD_INT 0
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: PUSH
63308: LD_INT 1
63310: PUSH
63311: LD_INT 1
63313: PUSH
63314: EMPTY
63315: LIST
63316: LIST
63317: PUSH
63318: LD_INT 0
63320: PUSH
63321: LD_INT 1
63323: PUSH
63324: EMPTY
63325: LIST
63326: LIST
63327: PUSH
63328: LD_INT 1
63330: NEG
63331: PUSH
63332: LD_INT 0
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 1
63341: NEG
63342: PUSH
63343: LD_INT 1
63345: NEG
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: PUSH
63351: LD_INT 1
63353: PUSH
63354: LD_INT 1
63356: NEG
63357: PUSH
63358: EMPTY
63359: LIST
63360: LIST
63361: PUSH
63362: LD_INT 2
63364: PUSH
63365: LD_INT 0
63367: PUSH
63368: EMPTY
63369: LIST
63370: LIST
63371: PUSH
63372: LD_INT 2
63374: PUSH
63375: LD_INT 1
63377: PUSH
63378: EMPTY
63379: LIST
63380: LIST
63381: PUSH
63382: LD_INT 1
63384: NEG
63385: PUSH
63386: LD_INT 1
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: PUSH
63393: LD_INT 2
63395: NEG
63396: PUSH
63397: LD_INT 0
63399: PUSH
63400: EMPTY
63401: LIST
63402: LIST
63403: PUSH
63404: LD_INT 2
63406: NEG
63407: PUSH
63408: LD_INT 1
63410: NEG
63411: PUSH
63412: EMPTY
63413: LIST
63414: LIST
63415: PUSH
63416: LD_INT 2
63418: NEG
63419: PUSH
63420: LD_INT 1
63422: PUSH
63423: EMPTY
63424: LIST
63425: LIST
63426: PUSH
63427: LD_INT 3
63429: NEG
63430: PUSH
63431: LD_INT 0
63433: PUSH
63434: EMPTY
63435: LIST
63436: LIST
63437: PUSH
63438: LD_INT 3
63440: NEG
63441: PUSH
63442: LD_INT 1
63444: NEG
63445: PUSH
63446: EMPTY
63447: LIST
63448: LIST
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: LIST
63454: LIST
63455: LIST
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63468: LD_ADDR_VAR 0 13
63472: PUSH
63473: LD_INT 0
63475: PUSH
63476: LD_INT 0
63478: PUSH
63479: EMPTY
63480: LIST
63481: LIST
63482: PUSH
63483: LD_INT 0
63485: PUSH
63486: LD_INT 1
63488: NEG
63489: PUSH
63490: EMPTY
63491: LIST
63492: LIST
63493: PUSH
63494: LD_INT 1
63496: PUSH
63497: LD_INT 0
63499: PUSH
63500: EMPTY
63501: LIST
63502: LIST
63503: PUSH
63504: LD_INT 1
63506: PUSH
63507: LD_INT 1
63509: PUSH
63510: EMPTY
63511: LIST
63512: LIST
63513: PUSH
63514: LD_INT 0
63516: PUSH
63517: LD_INT 1
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 1
63526: NEG
63527: PUSH
63528: LD_INT 0
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: LD_INT 1
63537: NEG
63538: PUSH
63539: LD_INT 1
63541: NEG
63542: PUSH
63543: EMPTY
63544: LIST
63545: LIST
63546: PUSH
63547: LD_INT 1
63549: NEG
63550: PUSH
63551: LD_INT 2
63553: NEG
63554: PUSH
63555: EMPTY
63556: LIST
63557: LIST
63558: PUSH
63559: LD_INT 2
63561: PUSH
63562: LD_INT 1
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PUSH
63569: LD_INT 2
63571: PUSH
63572: LD_INT 2
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PUSH
63579: LD_INT 1
63581: PUSH
63582: LD_INT 2
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: PUSH
63589: LD_INT 2
63591: NEG
63592: PUSH
63593: LD_INT 1
63595: NEG
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PUSH
63601: LD_INT 2
63603: NEG
63604: PUSH
63605: LD_INT 2
63607: NEG
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: PUSH
63613: LD_INT 2
63615: NEG
63616: PUSH
63617: LD_INT 3
63619: NEG
63620: PUSH
63621: EMPTY
63622: LIST
63623: LIST
63624: PUSH
63625: LD_INT 3
63627: NEG
63628: PUSH
63629: LD_INT 2
63631: NEG
63632: PUSH
63633: EMPTY
63634: LIST
63635: LIST
63636: PUSH
63637: LD_INT 3
63639: NEG
63640: PUSH
63641: LD_INT 3
63643: NEG
63644: PUSH
63645: EMPTY
63646: LIST
63647: LIST
63648: PUSH
63649: EMPTY
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: LIST
63666: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63667: LD_ADDR_VAR 0 14
63671: PUSH
63672: LD_INT 0
63674: PUSH
63675: LD_INT 0
63677: PUSH
63678: EMPTY
63679: LIST
63680: LIST
63681: PUSH
63682: LD_INT 0
63684: PUSH
63685: LD_INT 1
63687: NEG
63688: PUSH
63689: EMPTY
63690: LIST
63691: LIST
63692: PUSH
63693: LD_INT 1
63695: PUSH
63696: LD_INT 0
63698: PUSH
63699: EMPTY
63700: LIST
63701: LIST
63702: PUSH
63703: LD_INT 1
63705: PUSH
63706: LD_INT 1
63708: PUSH
63709: EMPTY
63710: LIST
63711: LIST
63712: PUSH
63713: LD_INT 0
63715: PUSH
63716: LD_INT 1
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PUSH
63723: LD_INT 1
63725: NEG
63726: PUSH
63727: LD_INT 0
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PUSH
63734: LD_INT 1
63736: NEG
63737: PUSH
63738: LD_INT 1
63740: NEG
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: LD_INT 1
63748: NEG
63749: PUSH
63750: LD_INT 2
63752: NEG
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: PUSH
63758: LD_INT 0
63760: PUSH
63761: LD_INT 2
63763: NEG
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: PUSH
63769: LD_INT 1
63771: PUSH
63772: LD_INT 1
63774: NEG
63775: PUSH
63776: EMPTY
63777: LIST
63778: LIST
63779: PUSH
63780: LD_INT 1
63782: PUSH
63783: LD_INT 2
63785: PUSH
63786: EMPTY
63787: LIST
63788: LIST
63789: PUSH
63790: LD_INT 0
63792: PUSH
63793: LD_INT 2
63795: PUSH
63796: EMPTY
63797: LIST
63798: LIST
63799: PUSH
63800: LD_INT 1
63802: NEG
63803: PUSH
63804: LD_INT 1
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PUSH
63811: LD_INT 1
63813: NEG
63814: PUSH
63815: LD_INT 3
63817: NEG
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PUSH
63823: LD_INT 0
63825: PUSH
63826: LD_INT 3
63828: NEG
63829: PUSH
63830: EMPTY
63831: LIST
63832: LIST
63833: PUSH
63834: LD_INT 1
63836: PUSH
63837: LD_INT 2
63839: NEG
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63863: LD_ADDR_VAR 0 15
63867: PUSH
63868: LD_INT 0
63870: PUSH
63871: LD_INT 0
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 0
63880: PUSH
63881: LD_INT 1
63883: NEG
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: PUSH
63889: LD_INT 1
63891: PUSH
63892: LD_INT 0
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PUSH
63899: LD_INT 1
63901: PUSH
63902: LD_INT 1
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 0
63911: PUSH
63912: LD_INT 1
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PUSH
63919: LD_INT 1
63921: NEG
63922: PUSH
63923: LD_INT 0
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: PUSH
63930: LD_INT 1
63932: NEG
63933: PUSH
63934: LD_INT 1
63936: NEG
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: PUSH
63942: LD_INT 1
63944: PUSH
63945: LD_INT 1
63947: NEG
63948: PUSH
63949: EMPTY
63950: LIST
63951: LIST
63952: PUSH
63953: LD_INT 2
63955: PUSH
63956: LD_INT 0
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: PUSH
63963: LD_INT 2
63965: PUSH
63966: LD_INT 1
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: PUSH
63973: LD_INT 1
63975: NEG
63976: PUSH
63977: LD_INT 1
63979: PUSH
63980: EMPTY
63981: LIST
63982: LIST
63983: PUSH
63984: LD_INT 2
63986: NEG
63987: PUSH
63988: LD_INT 0
63990: PUSH
63991: EMPTY
63992: LIST
63993: LIST
63994: PUSH
63995: LD_INT 2
63997: NEG
63998: PUSH
63999: LD_INT 1
64001: NEG
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PUSH
64007: LD_INT 2
64009: PUSH
64010: LD_INT 1
64012: NEG
64013: PUSH
64014: EMPTY
64015: LIST
64016: LIST
64017: PUSH
64018: LD_INT 3
64020: PUSH
64021: LD_INT 0
64023: PUSH
64024: EMPTY
64025: LIST
64026: LIST
64027: PUSH
64028: LD_INT 3
64030: PUSH
64031: LD_INT 1
64033: PUSH
64034: EMPTY
64035: LIST
64036: LIST
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64056: LD_ADDR_VAR 0 16
64060: PUSH
64061: LD_INT 0
64063: PUSH
64064: LD_INT 0
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 0
64073: PUSH
64074: LD_INT 1
64076: NEG
64077: PUSH
64078: EMPTY
64079: LIST
64080: LIST
64081: PUSH
64082: LD_INT 1
64084: PUSH
64085: LD_INT 0
64087: PUSH
64088: EMPTY
64089: LIST
64090: LIST
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: LD_INT 1
64097: PUSH
64098: EMPTY
64099: LIST
64100: LIST
64101: PUSH
64102: LD_INT 0
64104: PUSH
64105: LD_INT 1
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: PUSH
64112: LD_INT 1
64114: NEG
64115: PUSH
64116: LD_INT 0
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PUSH
64123: LD_INT 1
64125: NEG
64126: PUSH
64127: LD_INT 1
64129: NEG
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: LD_INT 1
64137: NEG
64138: PUSH
64139: LD_INT 2
64141: NEG
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: PUSH
64147: LD_INT 2
64149: PUSH
64150: LD_INT 1
64152: PUSH
64153: EMPTY
64154: LIST
64155: LIST
64156: PUSH
64157: LD_INT 2
64159: PUSH
64160: LD_INT 2
64162: PUSH
64163: EMPTY
64164: LIST
64165: LIST
64166: PUSH
64167: LD_INT 1
64169: PUSH
64170: LD_INT 2
64172: PUSH
64173: EMPTY
64174: LIST
64175: LIST
64176: PUSH
64177: LD_INT 2
64179: NEG
64180: PUSH
64181: LD_INT 1
64183: NEG
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 2
64191: NEG
64192: PUSH
64193: LD_INT 2
64195: NEG
64196: PUSH
64197: EMPTY
64198: LIST
64199: LIST
64200: PUSH
64201: LD_INT 3
64203: PUSH
64204: LD_INT 2
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: PUSH
64211: LD_INT 3
64213: PUSH
64214: LD_INT 3
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: PUSH
64221: LD_INT 2
64223: PUSH
64224: LD_INT 3
64226: PUSH
64227: EMPTY
64228: LIST
64229: LIST
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64249: LD_ADDR_VAR 0 17
64253: PUSH
64254: LD_INT 0
64256: PUSH
64257: LD_INT 0
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: PUSH
64264: LD_INT 0
64266: PUSH
64267: LD_INT 1
64269: NEG
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PUSH
64275: LD_INT 1
64277: PUSH
64278: LD_INT 0
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 1
64287: PUSH
64288: LD_INT 1
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: PUSH
64295: LD_INT 0
64297: PUSH
64298: LD_INT 1
64300: PUSH
64301: EMPTY
64302: LIST
64303: LIST
64304: PUSH
64305: LD_INT 1
64307: NEG
64308: PUSH
64309: LD_INT 0
64311: PUSH
64312: EMPTY
64313: LIST
64314: LIST
64315: PUSH
64316: LD_INT 1
64318: NEG
64319: PUSH
64320: LD_INT 1
64322: NEG
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: PUSH
64328: LD_INT 1
64330: NEG
64331: PUSH
64332: LD_INT 2
64334: NEG
64335: PUSH
64336: EMPTY
64337: LIST
64338: LIST
64339: PUSH
64340: LD_INT 0
64342: PUSH
64343: LD_INT 2
64345: NEG
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 1
64353: PUSH
64354: LD_INT 1
64356: NEG
64357: PUSH
64358: EMPTY
64359: LIST
64360: LIST
64361: PUSH
64362: LD_INT 2
64364: PUSH
64365: LD_INT 0
64367: PUSH
64368: EMPTY
64369: LIST
64370: LIST
64371: PUSH
64372: LD_INT 2
64374: PUSH
64375: LD_INT 1
64377: PUSH
64378: EMPTY
64379: LIST
64380: LIST
64381: PUSH
64382: LD_INT 2
64384: PUSH
64385: LD_INT 2
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PUSH
64392: LD_INT 1
64394: PUSH
64395: LD_INT 2
64397: PUSH
64398: EMPTY
64399: LIST
64400: LIST
64401: PUSH
64402: LD_INT 0
64404: PUSH
64405: LD_INT 2
64407: PUSH
64408: EMPTY
64409: LIST
64410: LIST
64411: PUSH
64412: LD_INT 1
64414: NEG
64415: PUSH
64416: LD_INT 1
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PUSH
64423: LD_INT 2
64425: NEG
64426: PUSH
64427: LD_INT 0
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PUSH
64434: LD_INT 2
64436: NEG
64437: PUSH
64438: LD_INT 1
64440: NEG
64441: PUSH
64442: EMPTY
64443: LIST
64444: LIST
64445: PUSH
64446: LD_INT 2
64448: NEG
64449: PUSH
64450: LD_INT 2
64452: NEG
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64479: LD_ADDR_VAR 0 18
64483: PUSH
64484: LD_INT 0
64486: PUSH
64487: LD_INT 0
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PUSH
64494: LD_INT 0
64496: PUSH
64497: LD_INT 1
64499: NEG
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 1
64507: PUSH
64508: LD_INT 0
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: LD_INT 1
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 0
64527: PUSH
64528: LD_INT 1
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: LD_INT 1
64537: NEG
64538: PUSH
64539: LD_INT 0
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: LD_INT 1
64548: NEG
64549: PUSH
64550: LD_INT 1
64552: NEG
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 1
64560: NEG
64561: PUSH
64562: LD_INT 2
64564: NEG
64565: PUSH
64566: EMPTY
64567: LIST
64568: LIST
64569: PUSH
64570: LD_INT 0
64572: PUSH
64573: LD_INT 2
64575: NEG
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 1
64583: PUSH
64584: LD_INT 1
64586: NEG
64587: PUSH
64588: EMPTY
64589: LIST
64590: LIST
64591: PUSH
64592: LD_INT 2
64594: PUSH
64595: LD_INT 0
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: PUSH
64602: LD_INT 2
64604: PUSH
64605: LD_INT 1
64607: PUSH
64608: EMPTY
64609: LIST
64610: LIST
64611: PUSH
64612: LD_INT 2
64614: PUSH
64615: LD_INT 2
64617: PUSH
64618: EMPTY
64619: LIST
64620: LIST
64621: PUSH
64622: LD_INT 1
64624: PUSH
64625: LD_INT 2
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: PUSH
64632: LD_INT 0
64634: PUSH
64635: LD_INT 2
64637: PUSH
64638: EMPTY
64639: LIST
64640: LIST
64641: PUSH
64642: LD_INT 1
64644: NEG
64645: PUSH
64646: LD_INT 1
64648: PUSH
64649: EMPTY
64650: LIST
64651: LIST
64652: PUSH
64653: LD_INT 2
64655: NEG
64656: PUSH
64657: LD_INT 0
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: PUSH
64664: LD_INT 2
64666: NEG
64667: PUSH
64668: LD_INT 1
64670: NEG
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: LD_INT 2
64678: NEG
64679: PUSH
64680: LD_INT 2
64682: NEG
64683: PUSH
64684: EMPTY
64685: LIST
64686: LIST
64687: PUSH
64688: EMPTY
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64709: LD_ADDR_VAR 0 19
64713: PUSH
64714: LD_INT 0
64716: PUSH
64717: LD_INT 0
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PUSH
64724: LD_INT 0
64726: PUSH
64727: LD_INT 1
64729: NEG
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: PUSH
64735: LD_INT 1
64737: PUSH
64738: LD_INT 0
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 1
64747: PUSH
64748: LD_INT 1
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: LD_INT 0
64757: PUSH
64758: LD_INT 1
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: LD_INT 1
64767: NEG
64768: PUSH
64769: LD_INT 0
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 1
64778: NEG
64779: PUSH
64780: LD_INT 1
64782: NEG
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 1
64790: NEG
64791: PUSH
64792: LD_INT 2
64794: NEG
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: PUSH
64800: LD_INT 0
64802: PUSH
64803: LD_INT 2
64805: NEG
64806: PUSH
64807: EMPTY
64808: LIST
64809: LIST
64810: PUSH
64811: LD_INT 1
64813: PUSH
64814: LD_INT 1
64816: NEG
64817: PUSH
64818: EMPTY
64819: LIST
64820: LIST
64821: PUSH
64822: LD_INT 2
64824: PUSH
64825: LD_INT 0
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: PUSH
64832: LD_INT 2
64834: PUSH
64835: LD_INT 1
64837: PUSH
64838: EMPTY
64839: LIST
64840: LIST
64841: PUSH
64842: LD_INT 2
64844: PUSH
64845: LD_INT 2
64847: PUSH
64848: EMPTY
64849: LIST
64850: LIST
64851: PUSH
64852: LD_INT 1
64854: PUSH
64855: LD_INT 2
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: LD_INT 0
64864: PUSH
64865: LD_INT 2
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 1
64874: NEG
64875: PUSH
64876: LD_INT 1
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: LD_INT 2
64885: NEG
64886: PUSH
64887: LD_INT 0
64889: PUSH
64890: EMPTY
64891: LIST
64892: LIST
64893: PUSH
64894: LD_INT 2
64896: NEG
64897: PUSH
64898: LD_INT 1
64900: NEG
64901: PUSH
64902: EMPTY
64903: LIST
64904: LIST
64905: PUSH
64906: LD_INT 2
64908: NEG
64909: PUSH
64910: LD_INT 2
64912: NEG
64913: PUSH
64914: EMPTY
64915: LIST
64916: LIST
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64939: LD_ADDR_VAR 0 20
64943: PUSH
64944: LD_INT 0
64946: PUSH
64947: LD_INT 0
64949: PUSH
64950: EMPTY
64951: LIST
64952: LIST
64953: PUSH
64954: LD_INT 0
64956: PUSH
64957: LD_INT 1
64959: NEG
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: PUSH
64965: LD_INT 1
64967: PUSH
64968: LD_INT 0
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: LD_INT 1
64977: PUSH
64978: LD_INT 1
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: PUSH
64985: LD_INT 0
64987: PUSH
64988: LD_INT 1
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: PUSH
64995: LD_INT 1
64997: NEG
64998: PUSH
64999: LD_INT 0
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: LD_INT 1
65008: NEG
65009: PUSH
65010: LD_INT 1
65012: NEG
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 1
65020: NEG
65021: PUSH
65022: LD_INT 2
65024: NEG
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 0
65032: PUSH
65033: LD_INT 2
65035: NEG
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: LD_INT 1
65043: PUSH
65044: LD_INT 1
65046: NEG
65047: PUSH
65048: EMPTY
65049: LIST
65050: LIST
65051: PUSH
65052: LD_INT 2
65054: PUSH
65055: LD_INT 0
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 2
65064: PUSH
65065: LD_INT 1
65067: PUSH
65068: EMPTY
65069: LIST
65070: LIST
65071: PUSH
65072: LD_INT 2
65074: PUSH
65075: LD_INT 2
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: PUSH
65082: LD_INT 1
65084: PUSH
65085: LD_INT 2
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 0
65094: PUSH
65095: LD_INT 2
65097: PUSH
65098: EMPTY
65099: LIST
65100: LIST
65101: PUSH
65102: LD_INT 1
65104: NEG
65105: PUSH
65106: LD_INT 1
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: PUSH
65113: LD_INT 2
65115: NEG
65116: PUSH
65117: LD_INT 0
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 2
65126: NEG
65127: PUSH
65128: LD_INT 1
65130: NEG
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: LD_INT 2
65138: NEG
65139: PUSH
65140: LD_INT 2
65142: NEG
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65169: LD_ADDR_VAR 0 21
65173: PUSH
65174: LD_INT 0
65176: PUSH
65177: LD_INT 0
65179: PUSH
65180: EMPTY
65181: LIST
65182: LIST
65183: PUSH
65184: LD_INT 0
65186: PUSH
65187: LD_INT 1
65189: NEG
65190: PUSH
65191: EMPTY
65192: LIST
65193: LIST
65194: PUSH
65195: LD_INT 1
65197: PUSH
65198: LD_INT 0
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: PUSH
65205: LD_INT 1
65207: PUSH
65208: LD_INT 1
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: PUSH
65215: LD_INT 0
65217: PUSH
65218: LD_INT 1
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PUSH
65225: LD_INT 1
65227: NEG
65228: PUSH
65229: LD_INT 0
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PUSH
65236: LD_INT 1
65238: NEG
65239: PUSH
65240: LD_INT 1
65242: NEG
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: LD_INT 1
65250: NEG
65251: PUSH
65252: LD_INT 2
65254: NEG
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: PUSH
65260: LD_INT 0
65262: PUSH
65263: LD_INT 2
65265: NEG
65266: PUSH
65267: EMPTY
65268: LIST
65269: LIST
65270: PUSH
65271: LD_INT 1
65273: PUSH
65274: LD_INT 1
65276: NEG
65277: PUSH
65278: EMPTY
65279: LIST
65280: LIST
65281: PUSH
65282: LD_INT 2
65284: PUSH
65285: LD_INT 0
65287: PUSH
65288: EMPTY
65289: LIST
65290: LIST
65291: PUSH
65292: LD_INT 2
65294: PUSH
65295: LD_INT 1
65297: PUSH
65298: EMPTY
65299: LIST
65300: LIST
65301: PUSH
65302: LD_INT 2
65304: PUSH
65305: LD_INT 2
65307: PUSH
65308: EMPTY
65309: LIST
65310: LIST
65311: PUSH
65312: LD_INT 1
65314: PUSH
65315: LD_INT 2
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 0
65324: PUSH
65325: LD_INT 2
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: PUSH
65332: LD_INT 1
65334: NEG
65335: PUSH
65336: LD_INT 1
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: PUSH
65343: LD_INT 2
65345: NEG
65346: PUSH
65347: LD_INT 0
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 2
65356: NEG
65357: PUSH
65358: LD_INT 1
65360: NEG
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 2
65368: NEG
65369: PUSH
65370: LD_INT 2
65372: NEG
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PUSH
65378: EMPTY
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65399: LD_ADDR_VAR 0 22
65403: PUSH
65404: LD_INT 0
65406: PUSH
65407: LD_INT 0
65409: PUSH
65410: EMPTY
65411: LIST
65412: LIST
65413: PUSH
65414: LD_INT 0
65416: PUSH
65417: LD_INT 1
65419: NEG
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: PUSH
65425: LD_INT 1
65427: PUSH
65428: LD_INT 0
65430: PUSH
65431: EMPTY
65432: LIST
65433: LIST
65434: PUSH
65435: LD_INT 1
65437: PUSH
65438: LD_INT 1
65440: PUSH
65441: EMPTY
65442: LIST
65443: LIST
65444: PUSH
65445: LD_INT 0
65447: PUSH
65448: LD_INT 1
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 1
65457: NEG
65458: PUSH
65459: LD_INT 0
65461: PUSH
65462: EMPTY
65463: LIST
65464: LIST
65465: PUSH
65466: LD_INT 1
65468: NEG
65469: PUSH
65470: LD_INT 1
65472: NEG
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PUSH
65478: LD_INT 1
65480: NEG
65481: PUSH
65482: LD_INT 2
65484: NEG
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: PUSH
65490: LD_INT 0
65492: PUSH
65493: LD_INT 2
65495: NEG
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: PUSH
65501: LD_INT 1
65503: PUSH
65504: LD_INT 1
65506: NEG
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PUSH
65512: LD_INT 2
65514: PUSH
65515: LD_INT 0
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: PUSH
65522: LD_INT 2
65524: PUSH
65525: LD_INT 1
65527: PUSH
65528: EMPTY
65529: LIST
65530: LIST
65531: PUSH
65532: LD_INT 2
65534: PUSH
65535: LD_INT 2
65537: PUSH
65538: EMPTY
65539: LIST
65540: LIST
65541: PUSH
65542: LD_INT 1
65544: PUSH
65545: LD_INT 2
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 0
65554: PUSH
65555: LD_INT 2
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 1
65564: NEG
65565: PUSH
65566: LD_INT 1
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 2
65575: NEG
65576: PUSH
65577: LD_INT 0
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 2
65586: NEG
65587: PUSH
65588: LD_INT 1
65590: NEG
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 2
65598: NEG
65599: PUSH
65600: LD_INT 2
65602: NEG
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65629: LD_ADDR_VAR 0 23
65633: PUSH
65634: LD_INT 0
65636: PUSH
65637: LD_INT 0
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PUSH
65644: LD_INT 0
65646: PUSH
65647: LD_INT 1
65649: NEG
65650: PUSH
65651: EMPTY
65652: LIST
65653: LIST
65654: PUSH
65655: LD_INT 1
65657: PUSH
65658: LD_INT 0
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: LD_INT 1
65667: PUSH
65668: LD_INT 1
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: LD_INT 0
65677: PUSH
65678: LD_INT 1
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 1
65687: NEG
65688: PUSH
65689: LD_INT 0
65691: PUSH
65692: EMPTY
65693: LIST
65694: LIST
65695: PUSH
65696: LD_INT 1
65698: NEG
65699: PUSH
65700: LD_INT 1
65702: NEG
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 1
65710: NEG
65711: PUSH
65712: LD_INT 2
65714: NEG
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: PUSH
65720: LD_INT 0
65722: PUSH
65723: LD_INT 2
65725: NEG
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: LD_INT 1
65733: PUSH
65734: LD_INT 1
65736: NEG
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 2
65744: PUSH
65745: LD_INT 0
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: LD_INT 2
65754: PUSH
65755: LD_INT 1
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: PUSH
65762: LD_INT 2
65764: PUSH
65765: LD_INT 2
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: PUSH
65772: LD_INT 1
65774: PUSH
65775: LD_INT 2
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 0
65784: PUSH
65785: LD_INT 2
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 1
65794: NEG
65795: PUSH
65796: LD_INT 1
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 2
65805: NEG
65806: PUSH
65807: LD_INT 0
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: PUSH
65814: LD_INT 2
65816: NEG
65817: PUSH
65818: LD_INT 1
65820: NEG
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 2
65828: NEG
65829: PUSH
65830: LD_INT 2
65832: NEG
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: PUSH
65838: LD_INT 2
65840: NEG
65841: PUSH
65842: LD_INT 3
65844: NEG
65845: PUSH
65846: EMPTY
65847: LIST
65848: LIST
65849: PUSH
65850: LD_INT 1
65852: NEG
65853: PUSH
65854: LD_INT 3
65856: NEG
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: LD_INT 1
65864: PUSH
65865: LD_INT 2
65867: NEG
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PUSH
65873: LD_INT 2
65875: PUSH
65876: LD_INT 1
65878: NEG
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65909: LD_ADDR_VAR 0 24
65913: PUSH
65914: LD_INT 0
65916: PUSH
65917: LD_INT 0
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: LD_INT 0
65926: PUSH
65927: LD_INT 1
65929: NEG
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: PUSH
65935: LD_INT 1
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 1
65947: PUSH
65948: LD_INT 1
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 0
65957: PUSH
65958: LD_INT 1
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 1
65967: NEG
65968: PUSH
65969: LD_INT 0
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: PUSH
65976: LD_INT 1
65978: NEG
65979: PUSH
65980: LD_INT 1
65982: NEG
65983: PUSH
65984: EMPTY
65985: LIST
65986: LIST
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: LD_INT 2
65994: NEG
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PUSH
66000: LD_INT 0
66002: PUSH
66003: LD_INT 2
66005: NEG
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: PUSH
66011: LD_INT 1
66013: PUSH
66014: LD_INT 1
66016: NEG
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: LD_INT 2
66024: PUSH
66025: LD_INT 0
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: PUSH
66032: LD_INT 2
66034: PUSH
66035: LD_INT 1
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 2
66044: PUSH
66045: LD_INT 2
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: PUSH
66052: LD_INT 1
66054: PUSH
66055: LD_INT 2
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PUSH
66062: LD_INT 0
66064: PUSH
66065: LD_INT 2
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 1
66074: NEG
66075: PUSH
66076: LD_INT 1
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 2
66085: NEG
66086: PUSH
66087: LD_INT 0
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PUSH
66094: LD_INT 2
66096: NEG
66097: PUSH
66098: LD_INT 1
66100: NEG
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 2
66108: NEG
66109: PUSH
66110: LD_INT 2
66112: NEG
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 1
66120: PUSH
66121: LD_INT 2
66123: NEG
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: PUSH
66129: LD_INT 2
66131: PUSH
66132: LD_INT 1
66134: NEG
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: PUSH
66140: LD_INT 3
66142: PUSH
66143: LD_INT 1
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: PUSH
66150: LD_INT 3
66152: PUSH
66153: LD_INT 2
66155: PUSH
66156: EMPTY
66157: LIST
66158: LIST
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66185: LD_ADDR_VAR 0 25
66189: PUSH
66190: LD_INT 0
66192: PUSH
66193: LD_INT 0
66195: PUSH
66196: EMPTY
66197: LIST
66198: LIST
66199: PUSH
66200: LD_INT 0
66202: PUSH
66203: LD_INT 1
66205: NEG
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 1
66213: PUSH
66214: LD_INT 0
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: LD_INT 1
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: PUSH
66231: LD_INT 0
66233: PUSH
66234: LD_INT 1
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 1
66243: NEG
66244: PUSH
66245: LD_INT 0
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: LD_INT 1
66254: NEG
66255: PUSH
66256: LD_INT 1
66258: NEG
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 1
66266: NEG
66267: PUSH
66268: LD_INT 2
66270: NEG
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: PUSH
66276: LD_INT 0
66278: PUSH
66279: LD_INT 2
66281: NEG
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 1
66289: PUSH
66290: LD_INT 1
66292: NEG
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: LD_INT 2
66300: PUSH
66301: LD_INT 0
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: PUSH
66308: LD_INT 2
66310: PUSH
66311: LD_INT 1
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PUSH
66318: LD_INT 2
66320: PUSH
66321: LD_INT 2
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 1
66330: PUSH
66331: LD_INT 2
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 0
66340: PUSH
66341: LD_INT 2
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 1
66350: NEG
66351: PUSH
66352: LD_INT 1
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: LD_INT 2
66361: NEG
66362: PUSH
66363: LD_INT 0
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 2
66372: NEG
66373: PUSH
66374: LD_INT 1
66376: NEG
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 2
66384: NEG
66385: PUSH
66386: LD_INT 2
66388: NEG
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PUSH
66394: LD_INT 3
66396: PUSH
66397: LD_INT 1
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: LD_INT 3
66406: PUSH
66407: LD_INT 2
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PUSH
66414: LD_INT 2
66416: PUSH
66417: LD_INT 3
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 1
66426: PUSH
66427: LD_INT 3
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66459: LD_ADDR_VAR 0 26
66463: PUSH
66464: LD_INT 0
66466: PUSH
66467: LD_INT 0
66469: PUSH
66470: EMPTY
66471: LIST
66472: LIST
66473: PUSH
66474: LD_INT 0
66476: PUSH
66477: LD_INT 1
66479: NEG
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 1
66487: PUSH
66488: LD_INT 0
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: LD_INT 1
66497: PUSH
66498: LD_INT 1
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 0
66507: PUSH
66508: LD_INT 1
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 1
66517: NEG
66518: PUSH
66519: LD_INT 0
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 1
66528: NEG
66529: PUSH
66530: LD_INT 1
66532: NEG
66533: PUSH
66534: EMPTY
66535: LIST
66536: LIST
66537: PUSH
66538: LD_INT 1
66540: NEG
66541: PUSH
66542: LD_INT 2
66544: NEG
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 0
66552: PUSH
66553: LD_INT 2
66555: NEG
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 1
66563: PUSH
66564: LD_INT 1
66566: NEG
66567: PUSH
66568: EMPTY
66569: LIST
66570: LIST
66571: PUSH
66572: LD_INT 2
66574: PUSH
66575: LD_INT 0
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 2
66584: PUSH
66585: LD_INT 1
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 2
66594: PUSH
66595: LD_INT 2
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 1
66604: PUSH
66605: LD_INT 2
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 0
66614: PUSH
66615: LD_INT 2
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 1
66624: NEG
66625: PUSH
66626: LD_INT 1
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 2
66635: NEG
66636: PUSH
66637: LD_INT 0
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: LD_INT 2
66646: NEG
66647: PUSH
66648: LD_INT 1
66650: NEG
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: LD_INT 2
66658: NEG
66659: PUSH
66660: LD_INT 2
66662: NEG
66663: PUSH
66664: EMPTY
66665: LIST
66666: LIST
66667: PUSH
66668: LD_INT 2
66670: PUSH
66671: LD_INT 3
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 1
66680: PUSH
66681: LD_INT 3
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 1
66690: NEG
66691: PUSH
66692: LD_INT 2
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 2
66701: NEG
66702: PUSH
66703: LD_INT 1
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: EMPTY
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66735: LD_ADDR_VAR 0 27
66739: PUSH
66740: LD_INT 0
66742: PUSH
66743: LD_INT 0
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: PUSH
66750: LD_INT 0
66752: PUSH
66753: LD_INT 1
66755: NEG
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: PUSH
66764: LD_INT 0
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PUSH
66771: LD_INT 1
66773: PUSH
66774: LD_INT 1
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: LD_INT 0
66783: PUSH
66784: LD_INT 1
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: LD_INT 1
66793: NEG
66794: PUSH
66795: LD_INT 0
66797: PUSH
66798: EMPTY
66799: LIST
66800: LIST
66801: PUSH
66802: LD_INT 1
66804: NEG
66805: PUSH
66806: LD_INT 1
66808: NEG
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: PUSH
66814: LD_INT 1
66816: NEG
66817: PUSH
66818: LD_INT 2
66820: NEG
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 0
66828: PUSH
66829: LD_INT 2
66831: NEG
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: LD_INT 1
66839: PUSH
66840: LD_INT 1
66842: NEG
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PUSH
66848: LD_INT 2
66850: PUSH
66851: LD_INT 0
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 2
66860: PUSH
66861: LD_INT 1
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 2
66870: PUSH
66871: LD_INT 2
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PUSH
66878: LD_INT 1
66880: PUSH
66881: LD_INT 2
66883: PUSH
66884: EMPTY
66885: LIST
66886: LIST
66887: PUSH
66888: LD_INT 0
66890: PUSH
66891: LD_INT 2
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 1
66900: NEG
66901: PUSH
66902: LD_INT 1
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 2
66911: NEG
66912: PUSH
66913: LD_INT 0
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 2
66922: NEG
66923: PUSH
66924: LD_INT 1
66926: NEG
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: PUSH
66932: LD_INT 2
66934: NEG
66935: PUSH
66936: LD_INT 2
66938: NEG
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 1
66946: NEG
66947: PUSH
66948: LD_INT 2
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: PUSH
66955: LD_INT 2
66957: NEG
66958: PUSH
66959: LD_INT 1
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: PUSH
66966: LD_INT 3
66968: NEG
66969: PUSH
66970: LD_INT 1
66972: NEG
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 3
66980: NEG
66981: PUSH
66982: LD_INT 2
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67015: LD_ADDR_VAR 0 28
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: LD_INT 0
67025: PUSH
67026: EMPTY
67027: LIST
67028: LIST
67029: PUSH
67030: LD_INT 0
67032: PUSH
67033: LD_INT 1
67035: NEG
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: LD_INT 1
67043: PUSH
67044: LD_INT 0
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: LD_INT 1
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 0
67063: PUSH
67064: LD_INT 1
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 1
67073: NEG
67074: PUSH
67075: LD_INT 0
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PUSH
67082: LD_INT 1
67084: NEG
67085: PUSH
67086: LD_INT 1
67088: NEG
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: PUSH
67094: LD_INT 1
67096: NEG
67097: PUSH
67098: LD_INT 2
67100: NEG
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: LD_INT 0
67108: PUSH
67109: LD_INT 2
67111: NEG
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: PUSH
67117: LD_INT 1
67119: PUSH
67120: LD_INT 1
67122: NEG
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: LD_INT 2
67130: PUSH
67131: LD_INT 0
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: PUSH
67138: LD_INT 2
67140: PUSH
67141: LD_INT 1
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 2
67150: PUSH
67151: LD_INT 2
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 1
67160: PUSH
67161: LD_INT 2
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: LD_INT 2
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: NEG
67181: PUSH
67182: LD_INT 1
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 2
67191: NEG
67192: PUSH
67193: LD_INT 0
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: PUSH
67200: LD_INT 2
67202: NEG
67203: PUSH
67204: LD_INT 1
67206: NEG
67207: PUSH
67208: EMPTY
67209: LIST
67210: LIST
67211: PUSH
67212: LD_INT 2
67214: NEG
67215: PUSH
67216: LD_INT 2
67218: NEG
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 2
67226: NEG
67227: PUSH
67228: LD_INT 3
67230: NEG
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 1
67238: NEG
67239: PUSH
67240: LD_INT 3
67242: NEG
67243: PUSH
67244: EMPTY
67245: LIST
67246: LIST
67247: PUSH
67248: LD_INT 3
67250: NEG
67251: PUSH
67252: LD_INT 1
67254: NEG
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PUSH
67260: LD_INT 3
67262: NEG
67263: PUSH
67264: LD_INT 2
67266: NEG
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67297: LD_ADDR_VAR 0 29
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: PUSH
67312: LD_INT 0
67314: PUSH
67315: LD_INT 1
67317: NEG
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 1
67325: PUSH
67326: LD_INT 0
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: LD_INT 1
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 0
67345: PUSH
67346: LD_INT 1
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: PUSH
67353: LD_INT 1
67355: NEG
67356: PUSH
67357: LD_INT 0
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 1
67366: NEG
67367: PUSH
67368: LD_INT 1
67370: NEG
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 1
67378: NEG
67379: PUSH
67380: LD_INT 2
67382: NEG
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 0
67390: PUSH
67391: LD_INT 2
67393: NEG
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: PUSH
67399: LD_INT 1
67401: PUSH
67402: LD_INT 1
67404: NEG
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 2
67412: PUSH
67413: LD_INT 0
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 2
67422: PUSH
67423: LD_INT 1
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 1
67432: PUSH
67433: LD_INT 2
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 0
67442: PUSH
67443: LD_INT 2
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 1
67452: NEG
67453: PUSH
67454: LD_INT 1
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 2
67463: NEG
67464: PUSH
67465: LD_INT 1
67467: NEG
67468: PUSH
67469: EMPTY
67470: LIST
67471: LIST
67472: PUSH
67473: LD_INT 2
67475: NEG
67476: PUSH
67477: LD_INT 2
67479: NEG
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: PUSH
67485: LD_INT 2
67487: NEG
67488: PUSH
67489: LD_INT 3
67491: NEG
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 2
67499: PUSH
67500: LD_INT 1
67502: NEG
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: LD_INT 3
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 1
67520: PUSH
67521: LD_INT 3
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 1
67530: NEG
67531: PUSH
67532: LD_INT 2
67534: PUSH
67535: EMPTY
67536: LIST
67537: LIST
67538: PUSH
67539: LD_INT 3
67541: NEG
67542: PUSH
67543: LD_INT 2
67545: NEG
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: LIST
67557: LIST
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67576: LD_ADDR_VAR 0 30
67580: PUSH
67581: LD_INT 0
67583: PUSH
67584: LD_INT 0
67586: PUSH
67587: EMPTY
67588: LIST
67589: LIST
67590: PUSH
67591: LD_INT 0
67593: PUSH
67594: LD_INT 1
67596: NEG
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: PUSH
67602: LD_INT 1
67604: PUSH
67605: LD_INT 0
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 1
67614: PUSH
67615: LD_INT 1
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: LD_INT 0
67624: PUSH
67625: LD_INT 1
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: PUSH
67632: LD_INT 1
67634: NEG
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: PUSH
67643: LD_INT 1
67645: NEG
67646: PUSH
67647: LD_INT 1
67649: NEG
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 1
67657: NEG
67658: PUSH
67659: LD_INT 2
67661: NEG
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 0
67669: PUSH
67670: LD_INT 2
67672: NEG
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: PUSH
67678: LD_INT 1
67680: PUSH
67681: LD_INT 1
67683: NEG
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: LD_INT 2
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: EMPTY
67696: LIST
67697: LIST
67698: PUSH
67699: LD_INT 2
67701: PUSH
67702: LD_INT 1
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 2
67711: PUSH
67712: LD_INT 2
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 1
67721: PUSH
67722: LD_INT 2
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 1
67731: NEG
67732: PUSH
67733: LD_INT 1
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PUSH
67740: LD_INT 2
67742: NEG
67743: PUSH
67744: LD_INT 0
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 2
67753: NEG
67754: PUSH
67755: LD_INT 1
67757: NEG
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: LD_INT 1
67765: NEG
67766: PUSH
67767: LD_INT 3
67769: NEG
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: PUSH
67775: LD_INT 1
67777: PUSH
67778: LD_INT 2
67780: NEG
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: LD_INT 3
67788: PUSH
67789: LD_INT 2
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 2
67798: PUSH
67799: LD_INT 3
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: PUSH
67806: LD_INT 2
67808: NEG
67809: PUSH
67810: LD_INT 1
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 3
67819: NEG
67820: PUSH
67821: LD_INT 1
67823: NEG
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67854: LD_ADDR_VAR 0 31
67858: PUSH
67859: LD_INT 0
67861: PUSH
67862: LD_INT 0
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 0
67871: PUSH
67872: LD_INT 1
67874: NEG
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 1
67882: PUSH
67883: LD_INT 0
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 1
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: LD_INT 0
67902: PUSH
67903: LD_INT 1
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 1
67912: NEG
67913: PUSH
67914: LD_INT 0
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 1
67923: NEG
67924: PUSH
67925: LD_INT 1
67927: NEG
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 1
67935: NEG
67936: PUSH
67937: LD_INT 2
67939: NEG
67940: PUSH
67941: EMPTY
67942: LIST
67943: LIST
67944: PUSH
67945: LD_INT 1
67947: PUSH
67948: LD_INT 1
67950: NEG
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: LD_INT 2
67958: PUSH
67959: LD_INT 0
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 2
67968: PUSH
67969: LD_INT 1
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 2
67978: PUSH
67979: LD_INT 2
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 1
67988: PUSH
67989: LD_INT 2
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 0
67998: PUSH
67999: LD_INT 2
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: NEG
68009: PUSH
68010: LD_INT 1
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 2
68019: NEG
68020: PUSH
68021: LD_INT 1
68023: NEG
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 2
68031: NEG
68032: PUSH
68033: LD_INT 2
68035: NEG
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 2
68043: NEG
68044: PUSH
68045: LD_INT 3
68047: NEG
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 2
68055: PUSH
68056: LD_INT 1
68058: NEG
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 3
68066: PUSH
68067: LD_INT 1
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 1
68076: PUSH
68077: LD_INT 3
68079: PUSH
68080: EMPTY
68081: LIST
68082: LIST
68083: PUSH
68084: LD_INT 1
68086: NEG
68087: PUSH
68088: LD_INT 2
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 3
68097: NEG
68098: PUSH
68099: LD_INT 2
68101: NEG
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68132: LD_ADDR_VAR 0 32
68136: PUSH
68137: LD_INT 0
68139: PUSH
68140: LD_INT 0
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: LD_INT 0
68149: PUSH
68150: LD_INT 1
68152: NEG
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PUSH
68158: LD_INT 1
68160: PUSH
68161: LD_INT 0
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 1
68170: PUSH
68171: LD_INT 1
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: LD_INT 1
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 1
68190: NEG
68191: PUSH
68192: LD_INT 0
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PUSH
68199: LD_INT 1
68201: NEG
68202: PUSH
68203: LD_INT 1
68205: NEG
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 1
68213: NEG
68214: PUSH
68215: LD_INT 2
68217: NEG
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 0
68225: PUSH
68226: LD_INT 2
68228: NEG
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 1
68236: PUSH
68237: LD_INT 1
68239: NEG
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: LD_INT 1
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 2
68257: PUSH
68258: LD_INT 2
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 1
68267: PUSH
68268: LD_INT 2
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: LD_INT 0
68277: PUSH
68278: LD_INT 2
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: LD_INT 1
68287: NEG
68288: PUSH
68289: LD_INT 1
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: PUSH
68296: LD_INT 2
68298: NEG
68299: PUSH
68300: LD_INT 0
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 2
68309: NEG
68310: PUSH
68311: LD_INT 1
68313: NEG
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 1
68321: NEG
68322: PUSH
68323: LD_INT 3
68325: NEG
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PUSH
68331: LD_INT 1
68333: PUSH
68334: LD_INT 2
68336: NEG
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: PUSH
68342: LD_INT 3
68344: PUSH
68345: LD_INT 2
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: LD_INT 2
68354: PUSH
68355: LD_INT 3
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 2
68364: NEG
68365: PUSH
68366: LD_INT 1
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PUSH
68373: LD_INT 3
68375: NEG
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68410: LD_ADDR_VAR 0 33
68414: PUSH
68415: LD_INT 0
68417: PUSH
68418: LD_INT 0
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: LD_INT 0
68427: PUSH
68428: LD_INT 1
68430: NEG
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 1
68438: PUSH
68439: LD_INT 0
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 1
68448: PUSH
68449: LD_INT 1
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 0
68458: PUSH
68459: LD_INT 1
68461: PUSH
68462: EMPTY
68463: LIST
68464: LIST
68465: PUSH
68466: LD_INT 1
68468: NEG
68469: PUSH
68470: LD_INT 0
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: LD_INT 1
68479: NEG
68480: PUSH
68481: LD_INT 1
68483: NEG
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 1
68491: NEG
68492: PUSH
68493: LD_INT 2
68495: NEG
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: LD_INT 1
68503: PUSH
68504: LD_INT 1
68506: NEG
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 2
68514: PUSH
68515: LD_INT 0
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 2
68524: PUSH
68525: LD_INT 1
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: PUSH
68532: LD_INT 1
68534: PUSH
68535: LD_INT 2
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 0
68544: PUSH
68545: LD_INT 2
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: NEG
68555: PUSH
68556: LD_INT 1
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 2
68565: NEG
68566: PUSH
68567: LD_INT 0
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 2
68576: NEG
68577: PUSH
68578: LD_INT 1
68580: NEG
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 2
68588: NEG
68589: PUSH
68590: LD_INT 2
68592: NEG
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 2
68600: NEG
68601: PUSH
68602: LD_INT 3
68604: NEG
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: PUSH
68610: LD_INT 2
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 3
68623: PUSH
68624: LD_INT 1
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 1
68633: PUSH
68634: LD_INT 3
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 1
68643: NEG
68644: PUSH
68645: LD_INT 2
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PUSH
68652: LD_INT 3
68654: NEG
68655: PUSH
68656: LD_INT 2
68658: NEG
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68689: LD_ADDR_VAR 0 34
68693: PUSH
68694: LD_INT 0
68696: PUSH
68697: LD_INT 0
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 0
68706: PUSH
68707: LD_INT 1
68709: NEG
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 1
68717: PUSH
68718: LD_INT 0
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: LD_INT 1
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 0
68737: PUSH
68738: LD_INT 1
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 1
68747: NEG
68748: PUSH
68749: LD_INT 0
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 1
68758: NEG
68759: PUSH
68760: LD_INT 1
68762: NEG
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: LD_INT 2
68774: NEG
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 0
68782: PUSH
68783: LD_INT 2
68785: NEG
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 1
68793: PUSH
68794: LD_INT 1
68796: NEG
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PUSH
68802: LD_INT 2
68804: PUSH
68805: LD_INT 1
68807: PUSH
68808: EMPTY
68809: LIST
68810: LIST
68811: PUSH
68812: LD_INT 2
68814: PUSH
68815: LD_INT 2
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 1
68824: PUSH
68825: LD_INT 2
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 1
68834: NEG
68835: PUSH
68836: LD_INT 1
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 2
68845: NEG
68846: PUSH
68847: LD_INT 0
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 2
68856: NEG
68857: PUSH
68858: LD_INT 1
68860: NEG
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: PUSH
68866: LD_INT 2
68868: NEG
68869: PUSH
68870: LD_INT 2
68872: NEG
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: LD_INT 3
68884: NEG
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: LD_INT 1
68892: PUSH
68893: LD_INT 2
68895: NEG
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 3
68903: PUSH
68904: LD_INT 2
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 2
68913: PUSH
68914: LD_INT 3
68916: PUSH
68917: EMPTY
68918: LIST
68919: LIST
68920: PUSH
68921: LD_INT 2
68923: NEG
68924: PUSH
68925: LD_INT 1
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 3
68934: NEG
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68969: LD_ADDR_VAR 0 35
68973: PUSH
68974: LD_INT 0
68976: PUSH
68977: LD_INT 0
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 0
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 1
68997: PUSH
68998: LD_INT 0
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 1
69007: PUSH
69008: LD_INT 1
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 0
69017: PUSH
69018: LD_INT 1
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 1
69027: NEG
69028: PUSH
69029: LD_INT 0
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: NEG
69039: PUSH
69040: LD_INT 1
69042: NEG
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 2
69050: PUSH
69051: LD_INT 1
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 2
69060: NEG
69061: PUSH
69062: LD_INT 1
69064: NEG
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69081: LD_ADDR_VAR 0 36
69085: PUSH
69086: LD_INT 0
69088: PUSH
69089: LD_INT 0
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: LD_INT 1
69101: NEG
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 1
69109: PUSH
69110: LD_INT 0
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 1
69119: PUSH
69120: LD_INT 1
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 0
69129: PUSH
69130: LD_INT 1
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 1
69139: NEG
69140: PUSH
69141: LD_INT 0
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 1
69150: NEG
69151: PUSH
69152: LD_INT 1
69154: NEG
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: LD_INT 1
69162: NEG
69163: PUSH
69164: LD_INT 2
69166: NEG
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 1
69174: PUSH
69175: LD_INT 2
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69193: LD_ADDR_VAR 0 37
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: LD_INT 1
69213: NEG
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 1
69221: PUSH
69222: LD_INT 0
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 1
69231: PUSH
69232: LD_INT 1
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 0
69241: PUSH
69242: LD_INT 1
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 1
69251: NEG
69252: PUSH
69253: LD_INT 0
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: NEG
69263: PUSH
69264: LD_INT 1
69266: NEG
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 1
69274: PUSH
69275: LD_INT 1
69277: NEG
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 1
69285: NEG
69286: PUSH
69287: LD_INT 1
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69305: LD_ADDR_VAR 0 38
69309: PUSH
69310: LD_INT 0
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 0
69322: PUSH
69323: LD_INT 1
69325: NEG
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: PUSH
69331: LD_INT 1
69333: PUSH
69334: LD_INT 0
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 1
69343: PUSH
69344: LD_INT 1
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 0
69353: PUSH
69354: LD_INT 1
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 1
69363: NEG
69364: PUSH
69365: LD_INT 0
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 1
69374: NEG
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 2
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 2
69396: NEG
69397: PUSH
69398: LD_INT 1
69400: NEG
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: EMPTY
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69417: LD_ADDR_VAR 0 39
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PUSH
69432: LD_INT 0
69434: PUSH
69435: LD_INT 1
69437: NEG
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 1
69445: PUSH
69446: LD_INT 0
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: LD_INT 1
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 0
69465: PUSH
69466: LD_INT 1
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 1
69475: NEG
69476: PUSH
69477: LD_INT 0
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 1
69486: NEG
69487: PUSH
69488: LD_INT 1
69490: NEG
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 1
69498: NEG
69499: PUSH
69500: LD_INT 2
69502: NEG
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 1
69510: PUSH
69511: LD_INT 2
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69529: LD_ADDR_VAR 0 40
69533: PUSH
69534: LD_INT 0
69536: PUSH
69537: LD_INT 0
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 0
69546: PUSH
69547: LD_INT 1
69549: NEG
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 1
69557: PUSH
69558: LD_INT 0
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 1
69567: PUSH
69568: LD_INT 1
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 0
69577: PUSH
69578: LD_INT 1
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 1
69587: NEG
69588: PUSH
69589: LD_INT 0
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 1
69598: NEG
69599: PUSH
69600: LD_INT 1
69602: NEG
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 1
69610: PUSH
69611: LD_INT 1
69613: NEG
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 1
69621: NEG
69622: PUSH
69623: LD_INT 1
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69641: LD_ADDR_VAR 0 41
69645: PUSH
69646: LD_INT 0
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 0
69658: PUSH
69659: LD_INT 1
69661: NEG
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 1
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 0
69689: PUSH
69690: LD_INT 1
69692: PUSH
69693: EMPTY
69694: LIST
69695: LIST
69696: PUSH
69697: LD_INT 1
69699: NEG
69700: PUSH
69701: LD_INT 0
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 1
69710: NEG
69711: PUSH
69712: LD_INT 1
69714: NEG
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: PUSH
69720: LD_INT 1
69722: NEG
69723: PUSH
69724: LD_INT 2
69726: NEG
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: PUSH
69732: LD_INT 1
69734: PUSH
69735: LD_INT 1
69737: NEG
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: LD_INT 2
69745: PUSH
69746: LD_INT 0
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: LD_INT 2
69755: PUSH
69756: LD_INT 1
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 2
69765: PUSH
69766: LD_INT 2
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 1
69775: PUSH
69776: LD_INT 2
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: LD_INT 1
69785: NEG
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 2
69796: NEG
69797: PUSH
69798: LD_INT 0
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 2
69807: NEG
69808: PUSH
69809: LD_INT 1
69811: NEG
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: LD_INT 2
69819: NEG
69820: PUSH
69821: LD_INT 2
69823: NEG
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: LD_INT 2
69831: NEG
69832: PUSH
69833: LD_INT 3
69835: NEG
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 2
69843: PUSH
69844: LD_INT 1
69846: NEG
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: LD_INT 3
69854: PUSH
69855: LD_INT 0
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: PUSH
69862: LD_INT 3
69864: PUSH
69865: LD_INT 1
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: PUSH
69872: LD_INT 3
69874: PUSH
69875: LD_INT 2
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 3
69884: PUSH
69885: LD_INT 3
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 2
69894: PUSH
69895: LD_INT 3
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 2
69904: NEG
69905: PUSH
69906: LD_INT 1
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 3
69915: NEG
69916: PUSH
69917: LD_INT 0
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: LD_INT 3
69926: NEG
69927: PUSH
69928: LD_INT 1
69930: NEG
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 3
69938: NEG
69939: PUSH
69940: LD_INT 2
69942: NEG
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 3
69950: NEG
69951: PUSH
69952: LD_INT 3
69954: NEG
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69991: LD_ADDR_VAR 0 42
69995: PUSH
69996: LD_INT 0
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: LD_INT 1
70011: NEG
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: LD_INT 0
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 1
70029: PUSH
70030: LD_INT 1
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: LD_INT 1
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 1
70049: NEG
70050: PUSH
70051: LD_INT 0
70053: PUSH
70054: EMPTY
70055: LIST
70056: LIST
70057: PUSH
70058: LD_INT 1
70060: NEG
70061: PUSH
70062: LD_INT 1
70064: NEG
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 1
70072: NEG
70073: PUSH
70074: LD_INT 2
70076: NEG
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 0
70084: PUSH
70085: LD_INT 2
70087: NEG
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 1
70095: PUSH
70096: LD_INT 1
70098: NEG
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 2
70106: PUSH
70107: LD_INT 1
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 2
70116: PUSH
70117: LD_INT 2
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: PUSH
70127: LD_INT 2
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 0
70136: PUSH
70137: LD_INT 2
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 1
70146: NEG
70147: PUSH
70148: LD_INT 1
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 2
70157: NEG
70158: PUSH
70159: LD_INT 1
70161: NEG
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 2
70169: NEG
70170: PUSH
70171: LD_INT 2
70173: NEG
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 2
70181: NEG
70182: PUSH
70183: LD_INT 3
70185: NEG
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 1
70193: NEG
70194: PUSH
70195: LD_INT 3
70197: NEG
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: LD_INT 0
70205: PUSH
70206: LD_INT 3
70208: NEG
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: PUSH
70214: LD_INT 1
70216: PUSH
70217: LD_INT 2
70219: NEG
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PUSH
70225: LD_INT 3
70227: PUSH
70228: LD_INT 2
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: PUSH
70235: LD_INT 3
70237: PUSH
70238: LD_INT 3
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: PUSH
70245: LD_INT 2
70247: PUSH
70248: LD_INT 3
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 1
70257: PUSH
70258: LD_INT 3
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 0
70267: PUSH
70268: LD_INT 3
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: LD_INT 2
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: LD_INT 3
70288: NEG
70289: PUSH
70290: LD_INT 2
70292: NEG
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 3
70300: NEG
70301: PUSH
70302: LD_INT 3
70304: NEG
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70341: LD_ADDR_VAR 0 43
70345: PUSH
70346: LD_INT 0
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 0
70358: PUSH
70359: LD_INT 1
70361: NEG
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 1
70369: PUSH
70370: LD_INT 0
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 1
70379: PUSH
70380: LD_INT 1
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 0
70389: PUSH
70390: LD_INT 1
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 1
70399: NEG
70400: PUSH
70401: LD_INT 0
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: LD_INT 1
70410: NEG
70411: PUSH
70412: LD_INT 1
70414: NEG
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 1
70422: NEG
70423: PUSH
70424: LD_INT 2
70426: NEG
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: LD_INT 0
70434: PUSH
70435: LD_INT 2
70437: NEG
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 1
70445: PUSH
70446: LD_INT 1
70448: NEG
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 2
70456: PUSH
70457: LD_INT 0
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: PUSH
70464: LD_INT 2
70466: PUSH
70467: LD_INT 1
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 1
70476: PUSH
70477: LD_INT 2
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 0
70486: PUSH
70487: LD_INT 2
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PUSH
70494: LD_INT 1
70496: NEG
70497: PUSH
70498: LD_INT 1
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 2
70507: NEG
70508: PUSH
70509: LD_INT 0
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: PUSH
70516: LD_INT 2
70518: NEG
70519: PUSH
70520: LD_INT 1
70522: NEG
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 1
70530: NEG
70531: PUSH
70532: LD_INT 3
70534: NEG
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 0
70542: PUSH
70543: LD_INT 3
70545: NEG
70546: PUSH
70547: EMPTY
70548: LIST
70549: LIST
70550: PUSH
70551: LD_INT 1
70553: PUSH
70554: LD_INT 2
70556: NEG
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: PUSH
70562: LD_INT 2
70564: PUSH
70565: LD_INT 1
70567: NEG
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: LD_INT 3
70575: PUSH
70576: LD_INT 0
70578: PUSH
70579: EMPTY
70580: LIST
70581: LIST
70582: PUSH
70583: LD_INT 3
70585: PUSH
70586: LD_INT 1
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: PUSH
70593: LD_INT 1
70595: PUSH
70596: LD_INT 3
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 0
70605: PUSH
70606: LD_INT 3
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: LD_INT 1
70615: NEG
70616: PUSH
70617: LD_INT 2
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: LD_INT 2
70626: NEG
70627: PUSH
70628: LD_INT 1
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: PUSH
70635: LD_INT 3
70637: NEG
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: LD_INT 3
70648: NEG
70649: PUSH
70650: LD_INT 1
70652: NEG
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70689: LD_ADDR_VAR 0 44
70693: PUSH
70694: LD_INT 0
70696: PUSH
70697: LD_INT 0
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 0
70706: PUSH
70707: LD_INT 1
70709: NEG
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: PUSH
70715: LD_INT 1
70717: PUSH
70718: LD_INT 0
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: PUSH
70725: LD_INT 1
70727: PUSH
70728: LD_INT 1
70730: PUSH
70731: EMPTY
70732: LIST
70733: LIST
70734: PUSH
70735: LD_INT 0
70737: PUSH
70738: LD_INT 1
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: PUSH
70745: LD_INT 1
70747: NEG
70748: PUSH
70749: LD_INT 0
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 1
70758: NEG
70759: PUSH
70760: LD_INT 1
70762: NEG
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 1
70770: NEG
70771: PUSH
70772: LD_INT 2
70774: NEG
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 1
70782: PUSH
70783: LD_INT 1
70785: NEG
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PUSH
70791: LD_INT 2
70793: PUSH
70794: LD_INT 0
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 2
70803: PUSH
70804: LD_INT 1
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 2
70813: PUSH
70814: LD_INT 2
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 1
70823: PUSH
70824: LD_INT 2
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 1
70833: NEG
70834: PUSH
70835: LD_INT 1
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 2
70844: NEG
70845: PUSH
70846: LD_INT 0
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 2
70855: NEG
70856: PUSH
70857: LD_INT 1
70859: NEG
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 2
70867: NEG
70868: PUSH
70869: LD_INT 2
70871: NEG
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 2
70879: NEG
70880: PUSH
70881: LD_INT 3
70883: NEG
70884: PUSH
70885: EMPTY
70886: LIST
70887: LIST
70888: PUSH
70889: LD_INT 2
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 3
70902: PUSH
70903: LD_INT 0
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: LD_INT 3
70912: PUSH
70913: LD_INT 1
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 3
70922: PUSH
70923: LD_INT 2
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 3
70932: PUSH
70933: LD_INT 3
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 2
70942: PUSH
70943: LD_INT 3
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: NEG
70953: PUSH
70954: LD_INT 1
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: PUSH
70961: LD_INT 3
70963: NEG
70964: PUSH
70965: LD_INT 0
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: LD_INT 3
70974: NEG
70975: PUSH
70976: LD_INT 1
70978: NEG
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 3
70986: NEG
70987: PUSH
70988: LD_INT 2
70990: NEG
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: LD_INT 3
70998: NEG
70999: PUSH
71000: LD_INT 3
71002: NEG
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71039: LD_ADDR_VAR 0 45
71043: PUSH
71044: LD_INT 0
71046: PUSH
71047: LD_INT 0
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: LD_INT 1
71059: NEG
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: LD_INT 1
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 1
71077: PUSH
71078: LD_INT 1
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 0
71087: PUSH
71088: LD_INT 1
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 1
71097: NEG
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 1
71108: NEG
71109: PUSH
71110: LD_INT 1
71112: NEG
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: LD_INT 2
71124: NEG
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 0
71132: PUSH
71133: LD_INT 2
71135: NEG
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: LD_INT 1
71143: PUSH
71144: LD_INT 1
71146: NEG
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 2
71154: PUSH
71155: LD_INT 1
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 2
71164: PUSH
71165: LD_INT 2
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 1
71174: PUSH
71175: LD_INT 2
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 0
71184: PUSH
71185: LD_INT 2
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 1
71194: NEG
71195: PUSH
71196: LD_INT 1
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 2
71205: NEG
71206: PUSH
71207: LD_INT 1
71209: NEG
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 2
71217: NEG
71218: PUSH
71219: LD_INT 2
71221: NEG
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 2
71229: NEG
71230: PUSH
71231: LD_INT 3
71233: NEG
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 1
71241: NEG
71242: PUSH
71243: LD_INT 3
71245: NEG
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 0
71253: PUSH
71254: LD_INT 3
71256: NEG
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 1
71264: PUSH
71265: LD_INT 2
71267: NEG
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 3
71275: PUSH
71276: LD_INT 2
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 3
71285: PUSH
71286: LD_INT 3
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: LD_INT 2
71295: PUSH
71296: LD_INT 3
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: LD_INT 3
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 0
71315: PUSH
71316: LD_INT 3
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 1
71325: NEG
71326: PUSH
71327: LD_INT 2
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 3
71336: NEG
71337: PUSH
71338: LD_INT 2
71340: NEG
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PUSH
71346: LD_INT 3
71348: NEG
71349: PUSH
71350: LD_INT 3
71352: NEG
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71389: LD_ADDR_VAR 0 46
71393: PUSH
71394: LD_INT 0
71396: PUSH
71397: LD_INT 0
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 0
71406: PUSH
71407: LD_INT 1
71409: NEG
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 1
71417: PUSH
71418: LD_INT 0
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 1
71427: PUSH
71428: LD_INT 1
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: LD_INT 0
71437: PUSH
71438: LD_INT 1
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 1
71447: NEG
71448: PUSH
71449: LD_INT 0
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: LD_INT 1
71462: NEG
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: LD_INT 2
71474: NEG
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: PUSH
71480: LD_INT 0
71482: PUSH
71483: LD_INT 2
71485: NEG
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: PUSH
71494: LD_INT 1
71496: NEG
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 2
71504: PUSH
71505: LD_INT 0
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 2
71514: PUSH
71515: LD_INT 1
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 1
71524: PUSH
71525: LD_INT 2
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PUSH
71532: LD_INT 0
71534: PUSH
71535: LD_INT 2
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 1
71544: NEG
71545: PUSH
71546: LD_INT 1
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 2
71555: NEG
71556: PUSH
71557: LD_INT 0
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 2
71566: NEG
71567: PUSH
71568: LD_INT 1
71570: NEG
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 1
71578: NEG
71579: PUSH
71580: LD_INT 3
71582: NEG
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 0
71590: PUSH
71591: LD_INT 3
71593: NEG
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 1
71601: PUSH
71602: LD_INT 2
71604: NEG
71605: PUSH
71606: EMPTY
71607: LIST
71608: LIST
71609: PUSH
71610: LD_INT 2
71612: PUSH
71613: LD_INT 1
71615: NEG
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PUSH
71621: LD_INT 3
71623: PUSH
71624: LD_INT 0
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 3
71633: PUSH
71634: LD_INT 1
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 1
71643: PUSH
71644: LD_INT 3
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: LD_INT 3
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: PUSH
71661: LD_INT 1
71663: NEG
71664: PUSH
71665: LD_INT 2
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 2
71674: NEG
71675: PUSH
71676: LD_INT 1
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 3
71685: NEG
71686: PUSH
71687: LD_INT 0
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 3
71696: NEG
71697: PUSH
71698: LD_INT 1
71700: NEG
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71737: LD_ADDR_VAR 0 47
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: LD_INT 0
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: LD_INT 1
71757: NEG
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: LD_INT 0
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: LD_INT 1
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 0
71785: PUSH
71786: LD_INT 1
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 1
71795: NEG
71796: PUSH
71797: LD_INT 0
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: LD_INT 1
71806: NEG
71807: PUSH
71808: LD_INT 1
71810: NEG
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: LD_INT 2
71822: NEG
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 0
71830: PUSH
71831: LD_INT 2
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 1
71841: PUSH
71842: LD_INT 1
71844: NEG
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PUSH
71850: LD_INT 2
71852: NEG
71853: PUSH
71854: LD_INT 1
71856: NEG
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 2
71864: NEG
71865: PUSH
71866: LD_INT 2
71868: NEG
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: LIST
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: LIST
71887: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71888: LD_ADDR_VAR 0 48
71892: PUSH
71893: LD_INT 0
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 0
71905: PUSH
71906: LD_INT 1
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 1
71916: PUSH
71917: LD_INT 0
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 1
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 0
71936: PUSH
71937: LD_INT 1
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: PUSH
71948: LD_INT 0
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 1
71957: NEG
71958: PUSH
71959: LD_INT 1
71961: NEG
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 1
71969: NEG
71970: PUSH
71971: LD_INT 2
71973: NEG
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 0
71981: PUSH
71982: LD_INT 2
71984: NEG
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: LD_INT 1
71992: PUSH
71993: LD_INT 1
71995: NEG
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 2
72003: PUSH
72004: LD_INT 0
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 2
72013: PUSH
72014: LD_INT 1
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: LIST
72032: LIST
72033: LIST
72034: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72035: LD_ADDR_VAR 0 49
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: LD_INT 0
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: PUSH
72050: LD_INT 0
72052: PUSH
72053: LD_INT 1
72055: NEG
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 1
72063: PUSH
72064: LD_INT 0
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 1
72073: PUSH
72074: LD_INT 1
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 0
72083: PUSH
72084: LD_INT 1
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 1
72093: NEG
72094: PUSH
72095: LD_INT 0
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PUSH
72102: LD_INT 1
72104: NEG
72105: PUSH
72106: LD_INT 1
72108: NEG
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: LD_INT 1
72119: NEG
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: LD_INT 2
72127: PUSH
72128: LD_INT 0
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: PUSH
72135: LD_INT 2
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 2
72147: PUSH
72148: LD_INT 2
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 1
72157: PUSH
72158: LD_INT 2
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72179: LD_ADDR_VAR 0 50
72183: PUSH
72184: LD_INT 0
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 0
72196: PUSH
72197: LD_INT 1
72199: NEG
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 1
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 1
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 0
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 1
72237: NEG
72238: PUSH
72239: LD_INT 0
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 1
72248: NEG
72249: PUSH
72250: LD_INT 1
72252: NEG
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: LD_INT 2
72260: PUSH
72261: LD_INT 1
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: PUSH
72268: LD_INT 2
72270: PUSH
72271: LD_INT 2
72273: PUSH
72274: EMPTY
72275: LIST
72276: LIST
72277: PUSH
72278: LD_INT 1
72280: PUSH
72281: LD_INT 2
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: PUSH
72288: LD_INT 0
72290: PUSH
72291: LD_INT 2
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 1
72300: NEG
72301: PUSH
72302: LD_INT 1
72304: PUSH
72305: EMPTY
72306: LIST
72307: LIST
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72323: LD_ADDR_VAR 0 51
72327: PUSH
72328: LD_INT 0
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 0
72340: PUSH
72341: LD_INT 1
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 1
72351: PUSH
72352: LD_INT 0
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 1
72361: PUSH
72362: LD_INT 1
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: LD_INT 0
72371: PUSH
72372: LD_INT 1
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PUSH
72379: LD_INT 1
72381: NEG
72382: PUSH
72383: LD_INT 0
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: PUSH
72390: LD_INT 1
72392: NEG
72393: PUSH
72394: LD_INT 1
72396: NEG
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: LD_INT 2
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 0
72414: PUSH
72415: LD_INT 2
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 1
72424: NEG
72425: PUSH
72426: LD_INT 1
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 2
72435: NEG
72436: PUSH
72437: LD_INT 0
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: LD_INT 2
72446: NEG
72447: PUSH
72448: LD_INT 1
72450: NEG
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72470: LD_ADDR_VAR 0 52
72474: PUSH
72475: LD_INT 0
72477: PUSH
72478: LD_INT 0
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: PUSH
72485: LD_INT 0
72487: PUSH
72488: LD_INT 1
72490: NEG
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: LD_INT 1
72498: PUSH
72499: LD_INT 0
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: PUSH
72506: LD_INT 1
72508: PUSH
72509: LD_INT 1
72511: PUSH
72512: EMPTY
72513: LIST
72514: LIST
72515: PUSH
72516: LD_INT 0
72518: PUSH
72519: LD_INT 1
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: LD_INT 0
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 1
72539: NEG
72540: PUSH
72541: LD_INT 1
72543: NEG
72544: PUSH
72545: EMPTY
72546: LIST
72547: LIST
72548: PUSH
72549: LD_INT 1
72551: NEG
72552: PUSH
72553: LD_INT 2
72555: NEG
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 1
72563: NEG
72564: PUSH
72565: LD_INT 1
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 2
72574: NEG
72575: PUSH
72576: LD_INT 0
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 2
72585: NEG
72586: PUSH
72587: LD_INT 1
72589: NEG
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 2
72597: NEG
72598: PUSH
72599: LD_INT 2
72601: NEG
72602: PUSH
72603: EMPTY
72604: LIST
72605: LIST
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: LIST
72611: LIST
72612: LIST
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72621: LD_ADDR_VAR 0 53
72625: PUSH
72626: LD_INT 0
72628: PUSH
72629: LD_INT 0
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 0
72638: PUSH
72639: LD_INT 1
72641: NEG
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 1
72649: PUSH
72650: LD_INT 0
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PUSH
72657: LD_INT 1
72659: PUSH
72660: LD_INT 1
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: LD_INT 0
72669: PUSH
72670: LD_INT 1
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 1
72679: NEG
72680: PUSH
72681: LD_INT 0
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 1
72690: NEG
72691: PUSH
72692: LD_INT 1
72694: NEG
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PUSH
72700: LD_INT 1
72702: NEG
72703: PUSH
72704: LD_INT 2
72706: NEG
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: LD_INT 2
72717: NEG
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: LD_INT 1
72725: PUSH
72726: LD_INT 1
72728: NEG
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: LD_INT 2
72736: PUSH
72737: LD_INT 0
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: LD_INT 2
72746: PUSH
72747: LD_INT 1
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 2
72756: PUSH
72757: LD_INT 2
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: PUSH
72764: LD_INT 1
72766: PUSH
72767: LD_INT 2
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 0
72776: PUSH
72777: LD_INT 2
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 1
72786: NEG
72787: PUSH
72788: LD_INT 1
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 2
72797: NEG
72798: PUSH
72799: LD_INT 0
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 2
72808: NEG
72809: PUSH
72810: LD_INT 1
72812: NEG
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: LD_INT 2
72820: NEG
72821: PUSH
72822: LD_INT 2
72824: NEG
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72851: LD_ADDR_VAR 0 54
72855: PUSH
72856: LD_INT 0
72858: PUSH
72859: LD_INT 0
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 0
72868: PUSH
72869: LD_INT 1
72871: NEG
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 0
72899: PUSH
72900: LD_INT 1
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 0
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: LD_INT 1
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 1
72932: NEG
72933: PUSH
72934: LD_INT 2
72936: NEG
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PUSH
72942: LD_INT 0
72944: PUSH
72945: LD_INT 2
72947: NEG
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 1
72955: PUSH
72956: LD_INT 1
72958: NEG
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 2
72966: PUSH
72967: LD_INT 0
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 2
72976: PUSH
72977: LD_INT 1
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: PUSH
72984: LD_INT 2
72986: PUSH
72987: LD_INT 2
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: PUSH
72994: LD_INT 1
72996: PUSH
72997: LD_INT 2
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 0
73006: PUSH
73007: LD_INT 2
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: PUSH
73014: LD_INT 1
73016: NEG
73017: PUSH
73018: LD_INT 1
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 2
73027: NEG
73028: PUSH
73029: LD_INT 0
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: LD_INT 2
73038: NEG
73039: PUSH
73040: LD_INT 1
73042: NEG
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 2
73050: NEG
73051: PUSH
73052: LD_INT 2
73054: NEG
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73081: LD_ADDR_VAR 0 55
73085: PUSH
73086: LD_INT 0
73088: PUSH
73089: LD_INT 0
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 0
73098: PUSH
73099: LD_INT 1
73101: NEG
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: PUSH
73107: LD_INT 1
73109: PUSH
73110: LD_INT 0
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: LD_INT 1
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 0
73129: PUSH
73130: LD_INT 1
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 1
73139: NEG
73140: PUSH
73141: LD_INT 0
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 1
73150: NEG
73151: PUSH
73152: LD_INT 1
73154: NEG
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: LD_INT 2
73166: NEG
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 0
73174: PUSH
73175: LD_INT 2
73177: NEG
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: PUSH
73183: LD_INT 1
73185: PUSH
73186: LD_INT 1
73188: NEG
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 2
73196: PUSH
73197: LD_INT 0
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 2
73206: PUSH
73207: LD_INT 1
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 2
73216: PUSH
73217: LD_INT 2
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 1
73226: PUSH
73227: LD_INT 2
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 0
73236: PUSH
73237: LD_INT 2
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: NEG
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 2
73257: NEG
73258: PUSH
73259: LD_INT 0
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 2
73268: NEG
73269: PUSH
73270: LD_INT 1
73272: NEG
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 2
73280: NEG
73281: PUSH
73282: LD_INT 2
73284: NEG
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: LIST
73310: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73311: LD_ADDR_VAR 0 56
73315: PUSH
73316: LD_INT 0
73318: PUSH
73319: LD_INT 0
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PUSH
73326: LD_INT 0
73328: PUSH
73329: LD_INT 1
73331: NEG
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: LD_INT 1
73339: PUSH
73340: LD_INT 0
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 1
73349: PUSH
73350: LD_INT 1
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 0
73359: PUSH
73360: LD_INT 1
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 1
73369: NEG
73370: PUSH
73371: LD_INT 0
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 1
73380: NEG
73381: PUSH
73382: LD_INT 1
73384: NEG
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: LD_INT 2
73396: NEG
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 0
73404: PUSH
73405: LD_INT 2
73407: NEG
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 1
73415: PUSH
73416: LD_INT 1
73418: NEG
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 2
73426: PUSH
73427: LD_INT 0
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 2
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 2
73446: PUSH
73447: LD_INT 2
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 1
73456: PUSH
73457: LD_INT 2
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 0
73466: PUSH
73467: LD_INT 2
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 1
73476: NEG
73477: PUSH
73478: LD_INT 1
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 2
73487: NEG
73488: PUSH
73489: LD_INT 0
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 2
73498: NEG
73499: PUSH
73500: LD_INT 1
73502: NEG
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 2
73510: NEG
73511: PUSH
73512: LD_INT 2
73514: NEG
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73541: LD_ADDR_VAR 0 57
73545: PUSH
73546: LD_INT 0
73548: PUSH
73549: LD_INT 0
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 0
73558: PUSH
73559: LD_INT 1
73561: NEG
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 1
73569: PUSH
73570: LD_INT 0
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: LD_INT 1
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 0
73589: PUSH
73590: LD_INT 1
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 1
73599: NEG
73600: PUSH
73601: LD_INT 0
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 1
73610: NEG
73611: PUSH
73612: LD_INT 1
73614: NEG
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PUSH
73620: LD_INT 1
73622: NEG
73623: PUSH
73624: LD_INT 2
73626: NEG
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 0
73634: PUSH
73635: LD_INT 2
73637: NEG
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 1
73645: PUSH
73646: LD_INT 1
73648: NEG
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 2
73656: PUSH
73657: LD_INT 0
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 2
73666: PUSH
73667: LD_INT 1
73669: PUSH
73670: EMPTY
73671: LIST
73672: LIST
73673: PUSH
73674: LD_INT 2
73676: PUSH
73677: LD_INT 2
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 1
73686: PUSH
73687: LD_INT 2
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: PUSH
73694: LD_INT 0
73696: PUSH
73697: LD_INT 2
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 1
73706: NEG
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 2
73717: NEG
73718: PUSH
73719: LD_INT 0
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 2
73728: NEG
73729: PUSH
73730: LD_INT 1
73732: NEG
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 2
73740: NEG
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73771: LD_ADDR_VAR 0 58
73775: PUSH
73776: LD_INT 0
73778: PUSH
73779: LD_INT 0
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 0
73788: PUSH
73789: LD_INT 1
73791: NEG
73792: PUSH
73793: EMPTY
73794: LIST
73795: LIST
73796: PUSH
73797: LD_INT 1
73799: PUSH
73800: LD_INT 0
73802: PUSH
73803: EMPTY
73804: LIST
73805: LIST
73806: PUSH
73807: LD_INT 1
73809: PUSH
73810: LD_INT 1
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 0
73819: PUSH
73820: LD_INT 1
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: LD_INT 0
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PUSH
73838: LD_INT 1
73840: NEG
73841: PUSH
73842: LD_INT 1
73844: NEG
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: LD_INT 2
73856: NEG
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: PUSH
73862: LD_INT 0
73864: PUSH
73865: LD_INT 2
73867: NEG
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: PUSH
73873: LD_INT 1
73875: PUSH
73876: LD_INT 1
73878: NEG
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: LD_INT 2
73886: PUSH
73887: LD_INT 0
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: PUSH
73894: LD_INT 2
73896: PUSH
73897: LD_INT 1
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: PUSH
73904: LD_INT 2
73906: PUSH
73907: LD_INT 2
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: PUSH
73914: LD_INT 1
73916: PUSH
73917: LD_INT 2
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 0
73926: PUSH
73927: LD_INT 2
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 1
73936: NEG
73937: PUSH
73938: LD_INT 1
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 2
73947: NEG
73948: PUSH
73949: LD_INT 0
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 2
73958: NEG
73959: PUSH
73960: LD_INT 1
73962: NEG
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 2
73970: NEG
73971: PUSH
73972: LD_INT 2
73974: NEG
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: LIST
73984: LIST
73985: LIST
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74001: LD_ADDR_VAR 0 59
74005: PUSH
74006: LD_INT 0
74008: PUSH
74009: LD_INT 0
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: PUSH
74016: LD_INT 0
74018: PUSH
74019: LD_INT 1
74021: NEG
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: PUSH
74027: LD_INT 1
74029: PUSH
74030: LD_INT 0
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: LD_INT 1
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 0
74049: PUSH
74050: LD_INT 1
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 1
74059: NEG
74060: PUSH
74061: LD_INT 0
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 1
74070: NEG
74071: PUSH
74072: LD_INT 1
74074: NEG
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: LIST
74084: LIST
74085: LIST
74086: LIST
74087: LIST
74088: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74089: LD_ADDR_VAR 0 60
74093: PUSH
74094: LD_INT 0
74096: PUSH
74097: LD_INT 0
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: LD_INT 1
74109: NEG
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 1
74117: PUSH
74118: LD_INT 0
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: PUSH
74125: LD_INT 1
74127: PUSH
74128: LD_INT 1
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: PUSH
74135: LD_INT 0
74137: PUSH
74138: LD_INT 1
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: PUSH
74145: LD_INT 1
74147: NEG
74148: PUSH
74149: LD_INT 0
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 1
74158: NEG
74159: PUSH
74160: LD_INT 1
74162: NEG
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: LIST
74174: LIST
74175: LIST
74176: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74177: LD_ADDR_VAR 0 61
74181: PUSH
74182: LD_INT 0
74184: PUSH
74185: LD_INT 0
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: LD_INT 0
74194: PUSH
74195: LD_INT 1
74197: NEG
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 1
74205: PUSH
74206: LD_INT 0
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: PUSH
74216: LD_INT 1
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: PUSH
74223: LD_INT 0
74225: PUSH
74226: LD_INT 1
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 1
74235: NEG
74236: PUSH
74237: LD_INT 0
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: PUSH
74244: LD_INT 1
74246: NEG
74247: PUSH
74248: LD_INT 1
74250: NEG
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: LIST
74262: LIST
74263: LIST
74264: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74265: LD_ADDR_VAR 0 62
74269: PUSH
74270: LD_INT 0
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 0
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 1
74293: PUSH
74294: LD_INT 0
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 1
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 0
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 1
74323: NEG
74324: PUSH
74325: LD_INT 0
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: LD_INT 1
74334: NEG
74335: PUSH
74336: LD_INT 1
74338: NEG
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74353: LD_ADDR_VAR 0 63
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: LD_INT 0
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 0
74370: PUSH
74371: LD_INT 1
74373: NEG
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 1
74381: PUSH
74382: LD_INT 0
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 1
74391: PUSH
74392: LD_INT 1
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: LD_INT 0
74401: PUSH
74402: LD_INT 1
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: PUSH
74409: LD_INT 1
74411: NEG
74412: PUSH
74413: LD_INT 0
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: PUSH
74420: LD_INT 1
74422: NEG
74423: PUSH
74424: LD_INT 1
74426: NEG
74427: PUSH
74428: EMPTY
74429: LIST
74430: LIST
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74441: LD_ADDR_VAR 0 64
74445: PUSH
74446: LD_INT 0
74448: PUSH
74449: LD_INT 0
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 0
74458: PUSH
74459: LD_INT 1
74461: NEG
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 1
74469: PUSH
74470: LD_INT 0
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 1
74479: PUSH
74480: LD_INT 1
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: LD_INT 0
74489: PUSH
74490: LD_INT 1
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: PUSH
74497: LD_INT 1
74499: NEG
74500: PUSH
74501: LD_INT 0
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PUSH
74508: LD_INT 1
74510: NEG
74511: PUSH
74512: LD_INT 1
74514: NEG
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: ST_TO_ADDR
// end ; 1 :
74529: GO 80426
74531: LD_INT 1
74533: DOUBLE
74534: EQUAL
74535: IFTRUE 74539
74537: GO 77162
74539: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74540: LD_ADDR_VAR 0 11
74544: PUSH
74545: LD_INT 1
74547: NEG
74548: PUSH
74549: LD_INT 3
74551: NEG
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 0
74559: PUSH
74560: LD_INT 3
74562: NEG
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 1
74570: PUSH
74571: LD_INT 2
74573: NEG
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: LIST
74583: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74584: LD_ADDR_VAR 0 12
74588: PUSH
74589: LD_INT 2
74591: PUSH
74592: LD_INT 1
74594: NEG
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 3
74602: PUSH
74603: LD_INT 0
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 3
74612: PUSH
74613: LD_INT 1
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: LIST
74624: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74625: LD_ADDR_VAR 0 13
74629: PUSH
74630: LD_INT 3
74632: PUSH
74633: LD_INT 2
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: LD_INT 3
74642: PUSH
74643: LD_INT 3
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: PUSH
74650: LD_INT 2
74652: PUSH
74653: LD_INT 3
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: LIST
74664: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74665: LD_ADDR_VAR 0 14
74669: PUSH
74670: LD_INT 1
74672: PUSH
74673: LD_INT 3
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: PUSH
74680: LD_INT 0
74682: PUSH
74683: LD_INT 3
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 1
74692: NEG
74693: PUSH
74694: LD_INT 2
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: LIST
74705: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74706: LD_ADDR_VAR 0 15
74710: PUSH
74711: LD_INT 2
74713: NEG
74714: PUSH
74715: LD_INT 1
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 3
74724: NEG
74725: PUSH
74726: LD_INT 0
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 3
74735: NEG
74736: PUSH
74737: LD_INT 1
74739: NEG
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: LIST
74749: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74750: LD_ADDR_VAR 0 16
74754: PUSH
74755: LD_INT 2
74757: NEG
74758: PUSH
74759: LD_INT 3
74761: NEG
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: PUSH
74767: LD_INT 3
74769: NEG
74770: PUSH
74771: LD_INT 2
74773: NEG
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 3
74781: NEG
74782: PUSH
74783: LD_INT 3
74785: NEG
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: LIST
74795: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74796: LD_ADDR_VAR 0 17
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: PUSH
74805: LD_INT 3
74807: NEG
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: LD_INT 0
74815: PUSH
74816: LD_INT 3
74818: NEG
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: LD_INT 1
74826: PUSH
74827: LD_INT 2
74829: NEG
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: LIST
74839: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74840: LD_ADDR_VAR 0 18
74844: PUSH
74845: LD_INT 2
74847: PUSH
74848: LD_INT 1
74850: NEG
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: LD_INT 3
74858: PUSH
74859: LD_INT 0
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: LD_INT 3
74868: PUSH
74869: LD_INT 1
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: LIST
74880: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74881: LD_ADDR_VAR 0 19
74885: PUSH
74886: LD_INT 3
74888: PUSH
74889: LD_INT 2
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: LD_INT 3
74898: PUSH
74899: LD_INT 3
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PUSH
74906: LD_INT 2
74908: PUSH
74909: LD_INT 3
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: LIST
74920: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74921: LD_ADDR_VAR 0 20
74925: PUSH
74926: LD_INT 1
74928: PUSH
74929: LD_INT 3
74931: PUSH
74932: EMPTY
74933: LIST
74934: LIST
74935: PUSH
74936: LD_INT 0
74938: PUSH
74939: LD_INT 3
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: LD_INT 1
74948: NEG
74949: PUSH
74950: LD_INT 2
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: LIST
74961: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74962: LD_ADDR_VAR 0 21
74966: PUSH
74967: LD_INT 2
74969: NEG
74970: PUSH
74971: LD_INT 1
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PUSH
74978: LD_INT 3
74980: NEG
74981: PUSH
74982: LD_INT 0
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 3
74991: NEG
74992: PUSH
74993: LD_INT 1
74995: NEG
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: LIST
75005: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75006: LD_ADDR_VAR 0 22
75010: PUSH
75011: LD_INT 2
75013: NEG
75014: PUSH
75015: LD_INT 3
75017: NEG
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: LD_INT 3
75025: NEG
75026: PUSH
75027: LD_INT 2
75029: NEG
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: LD_INT 3
75037: NEG
75038: PUSH
75039: LD_INT 3
75041: NEG
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: LIST
75051: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75052: LD_ADDR_VAR 0 23
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: LD_INT 3
75062: NEG
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: LD_INT 4
75074: NEG
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 1
75082: PUSH
75083: LD_INT 3
75085: NEG
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: LIST
75095: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75096: LD_ADDR_VAR 0 24
75100: PUSH
75101: LD_INT 3
75103: PUSH
75104: LD_INT 0
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 3
75113: PUSH
75114: LD_INT 1
75116: NEG
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 4
75124: PUSH
75125: LD_INT 1
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: LIST
75136: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75137: LD_ADDR_VAR 0 25
75141: PUSH
75142: LD_INT 3
75144: PUSH
75145: LD_INT 3
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 4
75154: PUSH
75155: LD_INT 3
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: LD_INT 3
75164: PUSH
75165: LD_INT 4
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: LIST
75176: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75177: LD_ADDR_VAR 0 26
75181: PUSH
75182: LD_INT 0
75184: PUSH
75185: LD_INT 3
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 1
75194: PUSH
75195: LD_INT 4
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 1
75204: NEG
75205: PUSH
75206: LD_INT 3
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: LIST
75217: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75218: LD_ADDR_VAR 0 27
75222: PUSH
75223: LD_INT 3
75225: NEG
75226: PUSH
75227: LD_INT 0
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 3
75236: NEG
75237: PUSH
75238: LD_INT 1
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 4
75247: NEG
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: LIST
75261: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75262: LD_ADDR_VAR 0 28
75266: PUSH
75267: LD_INT 3
75269: NEG
75270: PUSH
75271: LD_INT 3
75273: NEG
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 3
75281: NEG
75282: PUSH
75283: LD_INT 4
75285: NEG
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 4
75293: NEG
75294: PUSH
75295: LD_INT 3
75297: NEG
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: LIST
75307: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75308: LD_ADDR_VAR 0 29
75312: PUSH
75313: LD_INT 1
75315: NEG
75316: PUSH
75317: LD_INT 3
75319: NEG
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: LD_INT 3
75330: NEG
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 1
75338: PUSH
75339: LD_INT 2
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 1
75349: NEG
75350: PUSH
75351: LD_INT 4
75353: NEG
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 0
75361: PUSH
75362: LD_INT 4
75364: NEG
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 1
75372: PUSH
75373: LD_INT 3
75375: NEG
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 1
75383: NEG
75384: PUSH
75385: LD_INT 5
75387: NEG
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: PUSH
75393: LD_INT 0
75395: PUSH
75396: LD_INT 5
75398: NEG
75399: PUSH
75400: EMPTY
75401: LIST
75402: LIST
75403: PUSH
75404: LD_INT 1
75406: PUSH
75407: LD_INT 4
75409: NEG
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 1
75417: NEG
75418: PUSH
75419: LD_INT 6
75421: NEG
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PUSH
75427: LD_INT 0
75429: PUSH
75430: LD_INT 6
75432: NEG
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 1
75440: PUSH
75441: LD_INT 5
75443: NEG
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75463: LD_ADDR_VAR 0 30
75467: PUSH
75468: LD_INT 2
75470: PUSH
75471: LD_INT 1
75473: NEG
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PUSH
75479: LD_INT 3
75481: PUSH
75482: LD_INT 0
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 3
75491: PUSH
75492: LD_INT 1
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 3
75501: PUSH
75502: LD_INT 1
75504: NEG
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: LD_INT 4
75512: PUSH
75513: LD_INT 0
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 4
75522: PUSH
75523: LD_INT 1
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 4
75532: PUSH
75533: LD_INT 1
75535: NEG
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 5
75543: PUSH
75544: LD_INT 0
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 5
75553: PUSH
75554: LD_INT 1
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 5
75563: PUSH
75564: LD_INT 1
75566: NEG
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: LD_INT 6
75574: PUSH
75575: LD_INT 0
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 6
75584: PUSH
75585: LD_INT 1
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: LIST
75599: LIST
75600: LIST
75601: LIST
75602: LIST
75603: LIST
75604: LIST
75605: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75606: LD_ADDR_VAR 0 31
75610: PUSH
75611: LD_INT 3
75613: PUSH
75614: LD_INT 2
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 3
75623: PUSH
75624: LD_INT 3
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 2
75633: PUSH
75634: LD_INT 3
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 4
75643: PUSH
75644: LD_INT 3
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 4
75653: PUSH
75654: LD_INT 4
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 3
75663: PUSH
75664: LD_INT 4
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 5
75673: PUSH
75674: LD_INT 4
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 5
75683: PUSH
75684: LD_INT 5
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 4
75693: PUSH
75694: LD_INT 5
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 6
75703: PUSH
75704: LD_INT 5
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 6
75713: PUSH
75714: LD_INT 6
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 5
75723: PUSH
75724: LD_INT 6
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: EMPTY
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75745: LD_ADDR_VAR 0 32
75749: PUSH
75750: LD_INT 1
75752: PUSH
75753: LD_INT 3
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 0
75762: PUSH
75763: LD_INT 3
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 1
75772: NEG
75773: PUSH
75774: LD_INT 2
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 1
75783: PUSH
75784: LD_INT 4
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 0
75793: PUSH
75794: LD_INT 4
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 1
75803: NEG
75804: PUSH
75805: LD_INT 3
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 1
75814: PUSH
75815: LD_INT 5
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 0
75824: PUSH
75825: LD_INT 5
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 1
75834: NEG
75835: PUSH
75836: LD_INT 4
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: PUSH
75843: LD_INT 1
75845: PUSH
75846: LD_INT 6
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: PUSH
75853: LD_INT 0
75855: PUSH
75856: LD_INT 6
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 1
75865: NEG
75866: PUSH
75867: LD_INT 5
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: LIST
75878: LIST
75879: LIST
75880: LIST
75881: LIST
75882: LIST
75883: LIST
75884: LIST
75885: LIST
75886: LIST
75887: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75888: LD_ADDR_VAR 0 33
75892: PUSH
75893: LD_INT 2
75895: NEG
75896: PUSH
75897: LD_INT 1
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 3
75906: NEG
75907: PUSH
75908: LD_INT 0
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: LD_INT 3
75917: NEG
75918: PUSH
75919: LD_INT 1
75921: NEG
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 3
75929: NEG
75930: PUSH
75931: LD_INT 1
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 4
75940: NEG
75941: PUSH
75942: LD_INT 0
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 4
75951: NEG
75952: PUSH
75953: LD_INT 1
75955: NEG
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 4
75963: NEG
75964: PUSH
75965: LD_INT 1
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 5
75974: NEG
75975: PUSH
75976: LD_INT 0
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 5
75985: NEG
75986: PUSH
75987: LD_INT 1
75989: NEG
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 5
75997: NEG
75998: PUSH
75999: LD_INT 1
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: LD_INT 6
76008: NEG
76009: PUSH
76010: LD_INT 0
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: PUSH
76017: LD_INT 6
76019: NEG
76020: PUSH
76021: LD_INT 1
76023: NEG
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: LIST
76040: LIST
76041: LIST
76042: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76043: LD_ADDR_VAR 0 34
76047: PUSH
76048: LD_INT 2
76050: NEG
76051: PUSH
76052: LD_INT 3
76054: NEG
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PUSH
76060: LD_INT 3
76062: NEG
76063: PUSH
76064: LD_INT 2
76066: NEG
76067: PUSH
76068: EMPTY
76069: LIST
76070: LIST
76071: PUSH
76072: LD_INT 3
76074: NEG
76075: PUSH
76076: LD_INT 3
76078: NEG
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 3
76086: NEG
76087: PUSH
76088: LD_INT 4
76090: NEG
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: PUSH
76096: LD_INT 4
76098: NEG
76099: PUSH
76100: LD_INT 3
76102: NEG
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 4
76110: NEG
76111: PUSH
76112: LD_INT 4
76114: NEG
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 4
76122: NEG
76123: PUSH
76124: LD_INT 5
76126: NEG
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 5
76134: NEG
76135: PUSH
76136: LD_INT 4
76138: NEG
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 5
76146: NEG
76147: PUSH
76148: LD_INT 5
76150: NEG
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 5
76158: NEG
76159: PUSH
76160: LD_INT 6
76162: NEG
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PUSH
76168: LD_INT 6
76170: NEG
76171: PUSH
76172: LD_INT 5
76174: NEG
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 6
76182: NEG
76183: PUSH
76184: LD_INT 6
76186: NEG
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76206: LD_ADDR_VAR 0 41
76210: PUSH
76211: LD_INT 0
76213: PUSH
76214: LD_INT 2
76216: NEG
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 1
76224: NEG
76225: PUSH
76226: LD_INT 3
76228: NEG
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 1
76236: PUSH
76237: LD_INT 2
76239: NEG
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: LIST
76249: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76250: LD_ADDR_VAR 0 42
76254: PUSH
76255: LD_INT 2
76257: PUSH
76258: LD_INT 0
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: LD_INT 2
76267: PUSH
76268: LD_INT 1
76270: NEG
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 3
76278: PUSH
76279: LD_INT 1
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: LIST
76290: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76291: LD_ADDR_VAR 0 43
76295: PUSH
76296: LD_INT 2
76298: PUSH
76299: LD_INT 2
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 3
76308: PUSH
76309: LD_INT 2
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 2
76318: PUSH
76319: LD_INT 3
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: LIST
76330: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76331: LD_ADDR_VAR 0 44
76335: PUSH
76336: LD_INT 0
76338: PUSH
76339: LD_INT 2
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 1
76348: PUSH
76349: LD_INT 3
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 1
76358: NEG
76359: PUSH
76360: LD_INT 2
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: LIST
76371: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76372: LD_ADDR_VAR 0 45
76376: PUSH
76377: LD_INT 2
76379: NEG
76380: PUSH
76381: LD_INT 0
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 2
76390: NEG
76391: PUSH
76392: LD_INT 1
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 3
76401: NEG
76402: PUSH
76403: LD_INT 1
76405: NEG
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: LIST
76415: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76416: LD_ADDR_VAR 0 46
76420: PUSH
76421: LD_INT 2
76423: NEG
76424: PUSH
76425: LD_INT 2
76427: NEG
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 2
76435: NEG
76436: PUSH
76437: LD_INT 3
76439: NEG
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: LD_INT 3
76447: NEG
76448: PUSH
76449: LD_INT 2
76451: NEG
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: EMPTY
76458: LIST
76459: LIST
76460: LIST
76461: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76462: LD_ADDR_VAR 0 47
76466: PUSH
76467: LD_INT 2
76469: NEG
76470: PUSH
76471: LD_INT 3
76473: NEG
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 1
76481: NEG
76482: PUSH
76483: LD_INT 3
76485: NEG
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76495: LD_ADDR_VAR 0 48
76499: PUSH
76500: LD_INT 1
76502: PUSH
76503: LD_INT 2
76505: NEG
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: LD_INT 2
76513: PUSH
76514: LD_INT 1
76516: NEG
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76526: LD_ADDR_VAR 0 49
76530: PUSH
76531: LD_INT 3
76533: PUSH
76534: LD_INT 1
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PUSH
76541: LD_INT 3
76543: PUSH
76544: LD_INT 2
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76555: LD_ADDR_VAR 0 50
76559: PUSH
76560: LD_INT 2
76562: PUSH
76563: LD_INT 3
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: LD_INT 1
76572: PUSH
76573: LD_INT 3
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76584: LD_ADDR_VAR 0 51
76588: PUSH
76589: LD_INT 1
76591: NEG
76592: PUSH
76593: LD_INT 2
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 2
76602: NEG
76603: PUSH
76604: LD_INT 1
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76615: LD_ADDR_VAR 0 52
76619: PUSH
76620: LD_INT 3
76622: NEG
76623: PUSH
76624: LD_INT 1
76626: NEG
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: PUSH
76632: LD_INT 3
76634: NEG
76635: PUSH
76636: LD_INT 2
76638: NEG
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76648: LD_ADDR_VAR 0 53
76652: PUSH
76653: LD_INT 1
76655: NEG
76656: PUSH
76657: LD_INT 3
76659: NEG
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: LD_INT 0
76667: PUSH
76668: LD_INT 3
76670: NEG
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 1
76678: PUSH
76679: LD_INT 2
76681: NEG
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: LIST
76691: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76692: LD_ADDR_VAR 0 54
76696: PUSH
76697: LD_INT 2
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 3
76710: PUSH
76711: LD_INT 0
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 3
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: LIST
76732: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76733: LD_ADDR_VAR 0 55
76737: PUSH
76738: LD_INT 3
76740: PUSH
76741: LD_INT 2
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PUSH
76748: LD_INT 3
76750: PUSH
76751: LD_INT 3
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 2
76760: PUSH
76761: LD_INT 3
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: LIST
76772: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76773: LD_ADDR_VAR 0 56
76777: PUSH
76778: LD_INT 1
76780: PUSH
76781: LD_INT 3
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 0
76790: PUSH
76791: LD_INT 3
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 1
76800: NEG
76801: PUSH
76802: LD_INT 2
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: LIST
76813: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76814: LD_ADDR_VAR 0 57
76818: PUSH
76819: LD_INT 2
76821: NEG
76822: PUSH
76823: LD_INT 1
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 3
76832: NEG
76833: PUSH
76834: LD_INT 0
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 3
76843: NEG
76844: PUSH
76845: LD_INT 1
76847: NEG
76848: PUSH
76849: EMPTY
76850: LIST
76851: LIST
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: LIST
76857: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76858: LD_ADDR_VAR 0 58
76862: PUSH
76863: LD_INT 2
76865: NEG
76866: PUSH
76867: LD_INT 3
76869: NEG
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: LD_INT 3
76877: NEG
76878: PUSH
76879: LD_INT 2
76881: NEG
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 3
76889: NEG
76890: PUSH
76891: LD_INT 3
76893: NEG
76894: PUSH
76895: EMPTY
76896: LIST
76897: LIST
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: LIST
76903: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76904: LD_ADDR_VAR 0 59
76908: PUSH
76909: LD_INT 1
76911: NEG
76912: PUSH
76913: LD_INT 2
76915: NEG
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 0
76923: PUSH
76924: LD_INT 2
76926: NEG
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 1
76934: PUSH
76935: LD_INT 1
76937: NEG
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: LIST
76947: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76948: LD_ADDR_VAR 0 60
76952: PUSH
76953: LD_INT 1
76955: PUSH
76956: LD_INT 1
76958: NEG
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 2
76966: PUSH
76967: LD_INT 0
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PUSH
76974: LD_INT 2
76976: PUSH
76977: LD_INT 1
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: LIST
76988: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76989: LD_ADDR_VAR 0 61
76993: PUSH
76994: LD_INT 2
76996: PUSH
76997: LD_INT 1
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 2
77006: PUSH
77007: LD_INT 2
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 1
77016: PUSH
77017: LD_INT 2
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: LIST
77028: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77029: LD_ADDR_VAR 0 62
77033: PUSH
77034: LD_INT 1
77036: PUSH
77037: LD_INT 2
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 0
77046: PUSH
77047: LD_INT 2
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 1
77056: NEG
77057: PUSH
77058: LD_INT 1
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: LIST
77069: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77070: LD_ADDR_VAR 0 63
77074: PUSH
77075: LD_INT 1
77077: NEG
77078: PUSH
77079: LD_INT 1
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 2
77088: NEG
77089: PUSH
77090: LD_INT 0
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 2
77099: NEG
77100: PUSH
77101: LD_INT 1
77103: NEG
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: LIST
77113: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77114: LD_ADDR_VAR 0 64
77118: PUSH
77119: LD_INT 1
77121: NEG
77122: PUSH
77123: LD_INT 2
77125: NEG
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: PUSH
77131: LD_INT 2
77133: NEG
77134: PUSH
77135: LD_INT 1
77137: NEG
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: LD_INT 2
77145: NEG
77146: PUSH
77147: LD_INT 2
77149: NEG
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: LIST
77159: ST_TO_ADDR
// end ; 2 :
77160: GO 80426
77162: LD_INT 2
77164: DOUBLE
77165: EQUAL
77166: IFTRUE 77170
77168: GO 80425
77170: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77171: LD_ADDR_VAR 0 29
77175: PUSH
77176: LD_INT 4
77178: PUSH
77179: LD_INT 0
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: LD_INT 4
77188: PUSH
77189: LD_INT 1
77191: NEG
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 5
77199: PUSH
77200: LD_INT 0
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 5
77209: PUSH
77210: LD_INT 1
77212: PUSH
77213: EMPTY
77214: LIST
77215: LIST
77216: PUSH
77217: LD_INT 4
77219: PUSH
77220: LD_INT 1
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 3
77229: PUSH
77230: LD_INT 0
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: LD_INT 3
77239: PUSH
77240: LD_INT 1
77242: NEG
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: LD_INT 3
77250: PUSH
77251: LD_INT 2
77253: NEG
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 5
77261: PUSH
77262: LD_INT 2
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 3
77271: PUSH
77272: LD_INT 3
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 3
77281: PUSH
77282: LD_INT 2
77284: PUSH
77285: EMPTY
77286: LIST
77287: LIST
77288: PUSH
77289: LD_INT 4
77291: PUSH
77292: LD_INT 3
77294: PUSH
77295: EMPTY
77296: LIST
77297: LIST
77298: PUSH
77299: LD_INT 4
77301: PUSH
77302: LD_INT 4
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 3
77311: PUSH
77312: LD_INT 4
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: LD_INT 2
77321: PUSH
77322: LD_INT 3
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 2
77331: PUSH
77332: LD_INT 2
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 4
77341: PUSH
77342: LD_INT 2
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 2
77351: PUSH
77352: LD_INT 4
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 0
77361: PUSH
77362: LD_INT 4
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 0
77371: PUSH
77372: LD_INT 3
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: LD_INT 1
77381: PUSH
77382: LD_INT 4
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: LD_INT 1
77391: PUSH
77392: LD_INT 5
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 0
77401: PUSH
77402: LD_INT 5
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: LD_INT 4
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 1
77422: NEG
77423: PUSH
77424: LD_INT 3
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 2
77433: PUSH
77434: LD_INT 5
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 2
77443: NEG
77444: PUSH
77445: LD_INT 3
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 3
77454: NEG
77455: PUSH
77456: LD_INT 0
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 3
77465: NEG
77466: PUSH
77467: LD_INT 1
77469: NEG
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 2
77477: NEG
77478: PUSH
77479: LD_INT 0
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 2
77488: NEG
77489: PUSH
77490: LD_INT 1
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PUSH
77497: LD_INT 3
77499: NEG
77500: PUSH
77501: LD_INT 1
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: PUSH
77508: LD_INT 4
77510: NEG
77511: PUSH
77512: LD_INT 0
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 4
77521: NEG
77522: PUSH
77523: LD_INT 1
77525: NEG
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 4
77533: NEG
77534: PUSH
77535: LD_INT 2
77537: NEG
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: PUSH
77543: LD_INT 2
77545: NEG
77546: PUSH
77547: LD_INT 2
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 4
77556: NEG
77557: PUSH
77558: LD_INT 4
77560: NEG
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 4
77568: NEG
77569: PUSH
77570: LD_INT 5
77572: NEG
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: LD_INT 3
77580: NEG
77581: PUSH
77582: LD_INT 4
77584: NEG
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 3
77592: NEG
77593: PUSH
77594: LD_INT 3
77596: NEG
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 4
77604: NEG
77605: PUSH
77606: LD_INT 3
77608: NEG
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 5
77616: NEG
77617: PUSH
77618: LD_INT 4
77620: NEG
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 5
77628: NEG
77629: PUSH
77630: LD_INT 5
77632: NEG
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: LD_INT 3
77640: NEG
77641: PUSH
77642: LD_INT 5
77644: NEG
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 5
77652: NEG
77653: PUSH
77654: LD_INT 3
77656: NEG
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77709: LD_ADDR_VAR 0 30
77713: PUSH
77714: LD_INT 4
77716: PUSH
77717: LD_INT 4
77719: PUSH
77720: EMPTY
77721: LIST
77722: LIST
77723: PUSH
77724: LD_INT 4
77726: PUSH
77727: LD_INT 3
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 5
77736: PUSH
77737: LD_INT 4
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 5
77746: PUSH
77747: LD_INT 5
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 4
77756: PUSH
77757: LD_INT 5
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 3
77766: PUSH
77767: LD_INT 4
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: PUSH
77774: LD_INT 3
77776: PUSH
77777: LD_INT 3
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: LD_INT 5
77786: PUSH
77787: LD_INT 3
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 3
77796: PUSH
77797: LD_INT 5
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 0
77806: PUSH
77807: LD_INT 3
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: PUSH
77814: LD_INT 0
77816: PUSH
77817: LD_INT 2
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: PUSH
77824: LD_INT 1
77826: PUSH
77827: LD_INT 3
77829: PUSH
77830: EMPTY
77831: LIST
77832: LIST
77833: PUSH
77834: LD_INT 1
77836: PUSH
77837: LD_INT 4
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 0
77846: PUSH
77847: LD_INT 4
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 1
77856: NEG
77857: PUSH
77858: LD_INT 3
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 1
77867: NEG
77868: PUSH
77869: LD_INT 2
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 2
77878: PUSH
77879: LD_INT 4
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 2
77888: NEG
77889: PUSH
77890: LD_INT 2
77892: PUSH
77893: EMPTY
77894: LIST
77895: LIST
77896: PUSH
77897: LD_INT 4
77899: NEG
77900: PUSH
77901: LD_INT 0
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 4
77910: NEG
77911: PUSH
77912: LD_INT 1
77914: NEG
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 3
77922: NEG
77923: PUSH
77924: LD_INT 0
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 3
77933: NEG
77934: PUSH
77935: LD_INT 1
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 4
77944: NEG
77945: PUSH
77946: LD_INT 1
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 5
77955: NEG
77956: PUSH
77957: LD_INT 0
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 5
77966: NEG
77967: PUSH
77968: LD_INT 1
77970: NEG
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 5
77978: NEG
77979: PUSH
77980: LD_INT 2
77982: NEG
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 3
77990: NEG
77991: PUSH
77992: LD_INT 2
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: PUSH
77999: LD_INT 3
78001: NEG
78002: PUSH
78003: LD_INT 3
78005: NEG
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 3
78013: NEG
78014: PUSH
78015: LD_INT 4
78017: NEG
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PUSH
78023: LD_INT 2
78025: NEG
78026: PUSH
78027: LD_INT 3
78029: NEG
78030: PUSH
78031: EMPTY
78032: LIST
78033: LIST
78034: PUSH
78035: LD_INT 2
78037: NEG
78038: PUSH
78039: LD_INT 2
78041: NEG
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 3
78049: NEG
78050: PUSH
78051: LD_INT 2
78053: NEG
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 4
78061: NEG
78062: PUSH
78063: LD_INT 3
78065: NEG
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 4
78073: NEG
78074: PUSH
78075: LD_INT 4
78077: NEG
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 2
78085: NEG
78086: PUSH
78087: LD_INT 4
78089: NEG
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: PUSH
78095: LD_INT 4
78097: NEG
78098: PUSH
78099: LD_INT 2
78101: NEG
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: LD_INT 0
78109: PUSH
78110: LD_INT 4
78112: NEG
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 0
78120: PUSH
78121: LD_INT 5
78123: NEG
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 1
78131: PUSH
78132: LD_INT 4
78134: NEG
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 1
78142: PUSH
78143: LD_INT 3
78145: NEG
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: LD_INT 0
78153: PUSH
78154: LD_INT 3
78156: NEG
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 1
78164: NEG
78165: PUSH
78166: LD_INT 4
78168: NEG
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 1
78176: NEG
78177: PUSH
78178: LD_INT 5
78180: NEG
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 2
78188: PUSH
78189: LD_INT 3
78191: NEG
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: PUSH
78197: LD_INT 2
78199: NEG
78200: PUSH
78201: LD_INT 5
78203: NEG
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78256: LD_ADDR_VAR 0 31
78260: PUSH
78261: LD_INT 0
78263: PUSH
78264: LD_INT 4
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 0
78273: PUSH
78274: LD_INT 3
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 1
78283: PUSH
78284: LD_INT 4
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 1
78293: PUSH
78294: LD_INT 5
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 0
78303: PUSH
78304: LD_INT 5
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 1
78313: NEG
78314: PUSH
78315: LD_INT 4
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 1
78324: NEG
78325: PUSH
78326: LD_INT 3
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: LD_INT 2
78335: PUSH
78336: LD_INT 5
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 2
78345: NEG
78346: PUSH
78347: LD_INT 3
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 3
78356: NEG
78357: PUSH
78358: LD_INT 0
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: LD_INT 3
78367: NEG
78368: PUSH
78369: LD_INT 1
78371: NEG
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PUSH
78377: LD_INT 2
78379: NEG
78380: PUSH
78381: LD_INT 0
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 2
78390: NEG
78391: PUSH
78392: LD_INT 1
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 3
78401: NEG
78402: PUSH
78403: LD_INT 1
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 4
78412: NEG
78413: PUSH
78414: LD_INT 0
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 4
78423: NEG
78424: PUSH
78425: LD_INT 1
78427: NEG
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 4
78435: NEG
78436: PUSH
78437: LD_INT 2
78439: NEG
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 2
78447: NEG
78448: PUSH
78449: LD_INT 2
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 4
78458: NEG
78459: PUSH
78460: LD_INT 4
78462: NEG
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 4
78470: NEG
78471: PUSH
78472: LD_INT 5
78474: NEG
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: PUSH
78480: LD_INT 3
78482: NEG
78483: PUSH
78484: LD_INT 4
78486: NEG
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 3
78494: NEG
78495: PUSH
78496: LD_INT 3
78498: NEG
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 4
78506: NEG
78507: PUSH
78508: LD_INT 3
78510: NEG
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 5
78518: NEG
78519: PUSH
78520: LD_INT 4
78522: NEG
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 5
78530: NEG
78531: PUSH
78532: LD_INT 5
78534: NEG
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 3
78542: NEG
78543: PUSH
78544: LD_INT 5
78546: NEG
78547: PUSH
78548: EMPTY
78549: LIST
78550: LIST
78551: PUSH
78552: LD_INT 5
78554: NEG
78555: PUSH
78556: LD_INT 3
78558: NEG
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 0
78566: PUSH
78567: LD_INT 3
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 0
78577: PUSH
78578: LD_INT 4
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 1
78588: PUSH
78589: LD_INT 3
78591: NEG
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: LD_INT 1
78599: PUSH
78600: LD_INT 2
78602: NEG
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: LD_INT 0
78610: PUSH
78611: LD_INT 2
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 1
78621: NEG
78622: PUSH
78623: LD_INT 3
78625: NEG
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 1
78633: NEG
78634: PUSH
78635: LD_INT 4
78637: NEG
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: PUSH
78643: LD_INT 2
78645: PUSH
78646: LD_INT 2
78648: NEG
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: PUSH
78654: LD_INT 2
78656: NEG
78657: PUSH
78658: LD_INT 4
78660: NEG
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: PUSH
78666: LD_INT 4
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PUSH
78676: LD_INT 4
78678: PUSH
78679: LD_INT 1
78681: NEG
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 5
78689: PUSH
78690: LD_INT 0
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: PUSH
78697: LD_INT 5
78699: PUSH
78700: LD_INT 1
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 4
78709: PUSH
78710: LD_INT 1
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: LD_INT 3
78719: PUSH
78720: LD_INT 0
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 3
78729: PUSH
78730: LD_INT 1
78732: NEG
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 3
78740: PUSH
78741: LD_INT 2
78743: NEG
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 5
78751: PUSH
78752: LD_INT 2
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78806: LD_ADDR_VAR 0 32
78810: PUSH
78811: LD_INT 4
78813: NEG
78814: PUSH
78815: LD_INT 0
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 4
78824: NEG
78825: PUSH
78826: LD_INT 1
78828: NEG
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 3
78836: NEG
78837: PUSH
78838: LD_INT 0
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 3
78847: NEG
78848: PUSH
78849: LD_INT 1
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 4
78858: NEG
78859: PUSH
78860: LD_INT 1
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 5
78869: NEG
78870: PUSH
78871: LD_INT 0
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 5
78880: NEG
78881: PUSH
78882: LD_INT 1
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 5
78892: NEG
78893: PUSH
78894: LD_INT 2
78896: NEG
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 3
78904: NEG
78905: PUSH
78906: LD_INT 2
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: PUSH
78913: LD_INT 3
78915: NEG
78916: PUSH
78917: LD_INT 3
78919: NEG
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 3
78927: NEG
78928: PUSH
78929: LD_INT 4
78931: NEG
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 2
78939: NEG
78940: PUSH
78941: LD_INT 3
78943: NEG
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 2
78951: NEG
78952: PUSH
78953: LD_INT 2
78955: NEG
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 3
78963: NEG
78964: PUSH
78965: LD_INT 2
78967: NEG
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 4
78975: NEG
78976: PUSH
78977: LD_INT 3
78979: NEG
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 4
78987: NEG
78988: PUSH
78989: LD_INT 4
78991: NEG
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 2
78999: NEG
79000: PUSH
79001: LD_INT 4
79003: NEG
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 4
79011: NEG
79012: PUSH
79013: LD_INT 2
79015: NEG
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: LD_INT 4
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 0
79034: PUSH
79035: LD_INT 5
79037: NEG
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 1
79045: PUSH
79046: LD_INT 4
79048: NEG
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 1
79056: PUSH
79057: LD_INT 3
79059: NEG
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 0
79067: PUSH
79068: LD_INT 3
79070: NEG
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 1
79078: NEG
79079: PUSH
79080: LD_INT 4
79082: NEG
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: LD_INT 5
79094: NEG
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 2
79102: PUSH
79103: LD_INT 3
79105: NEG
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 2
79113: NEG
79114: PUSH
79115: LD_INT 5
79117: NEG
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 3
79125: PUSH
79126: LD_INT 0
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 3
79135: PUSH
79136: LD_INT 1
79138: NEG
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 4
79146: PUSH
79147: LD_INT 0
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 4
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 3
79166: PUSH
79167: LD_INT 1
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 2
79176: PUSH
79177: LD_INT 0
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 2
79186: PUSH
79187: LD_INT 1
79189: NEG
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 2
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 4
79208: PUSH
79209: LD_INT 2
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PUSH
79216: LD_INT 4
79218: PUSH
79219: LD_INT 4
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 4
79228: PUSH
79229: LD_INT 3
79231: PUSH
79232: EMPTY
79233: LIST
79234: LIST
79235: PUSH
79236: LD_INT 5
79238: PUSH
79239: LD_INT 4
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 5
79248: PUSH
79249: LD_INT 5
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 4
79258: PUSH
79259: LD_INT 5
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 3
79268: PUSH
79269: LD_INT 4
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: LD_INT 3
79278: PUSH
79279: LD_INT 3
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 5
79288: PUSH
79289: LD_INT 3
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 3
79298: PUSH
79299: LD_INT 5
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79353: LD_ADDR_VAR 0 33
79357: PUSH
79358: LD_INT 4
79360: NEG
79361: PUSH
79362: LD_INT 4
79364: NEG
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 4
79372: NEG
79373: PUSH
79374: LD_INT 5
79376: NEG
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 3
79384: NEG
79385: PUSH
79386: LD_INT 4
79388: NEG
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 3
79396: NEG
79397: PUSH
79398: LD_INT 3
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 4
79408: NEG
79409: PUSH
79410: LD_INT 3
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 5
79420: NEG
79421: PUSH
79422: LD_INT 4
79424: NEG
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 5
79432: NEG
79433: PUSH
79434: LD_INT 5
79436: NEG
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 3
79444: NEG
79445: PUSH
79446: LD_INT 5
79448: NEG
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 5
79456: NEG
79457: PUSH
79458: LD_INT 3
79460: NEG
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 0
79468: PUSH
79469: LD_INT 3
79471: NEG
79472: PUSH
79473: EMPTY
79474: LIST
79475: LIST
79476: PUSH
79477: LD_INT 0
79479: PUSH
79480: LD_INT 4
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 1
79490: PUSH
79491: LD_INT 3
79493: NEG
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 1
79501: PUSH
79502: LD_INT 2
79504: NEG
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: LD_INT 2
79515: NEG
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 1
79523: NEG
79524: PUSH
79525: LD_INT 3
79527: NEG
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 1
79535: NEG
79536: PUSH
79537: LD_INT 4
79539: NEG
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 2
79547: PUSH
79548: LD_INT 2
79550: NEG
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 2
79558: NEG
79559: PUSH
79560: LD_INT 4
79562: NEG
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: PUSH
79568: LD_INT 4
79570: PUSH
79571: LD_INT 0
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: PUSH
79578: LD_INT 4
79580: PUSH
79581: LD_INT 1
79583: NEG
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 5
79591: PUSH
79592: LD_INT 0
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 5
79601: PUSH
79602: LD_INT 1
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 4
79611: PUSH
79612: LD_INT 1
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 3
79621: PUSH
79622: LD_INT 0
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 3
79631: PUSH
79632: LD_INT 1
79634: NEG
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 3
79642: PUSH
79643: LD_INT 2
79645: NEG
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 5
79653: PUSH
79654: LD_INT 2
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 3
79663: PUSH
79664: LD_INT 3
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 3
79673: PUSH
79674: LD_INT 2
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 4
79683: PUSH
79684: LD_INT 3
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 4
79693: PUSH
79694: LD_INT 4
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 3
79703: PUSH
79704: LD_INT 4
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 2
79713: PUSH
79714: LD_INT 3
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: LD_INT 2
79723: PUSH
79724: LD_INT 2
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 4
79733: PUSH
79734: LD_INT 2
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 2
79743: PUSH
79744: LD_INT 4
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PUSH
79751: LD_INT 0
79753: PUSH
79754: LD_INT 4
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: LD_INT 0
79763: PUSH
79764: LD_INT 3
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 1
79773: PUSH
79774: LD_INT 4
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 1
79783: PUSH
79784: LD_INT 5
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 0
79793: PUSH
79794: LD_INT 5
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: PUSH
79801: LD_INT 1
79803: NEG
79804: PUSH
79805: LD_INT 4
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 1
79814: NEG
79815: PUSH
79816: LD_INT 3
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 2
79825: PUSH
79826: LD_INT 5
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 2
79835: NEG
79836: PUSH
79837: LD_INT 3
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79891: LD_ADDR_VAR 0 34
79895: PUSH
79896: LD_INT 0
79898: PUSH
79899: LD_INT 4
79901: NEG
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 0
79909: PUSH
79910: LD_INT 5
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 1
79920: PUSH
79921: LD_INT 4
79923: NEG
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 1
79931: PUSH
79932: LD_INT 3
79934: NEG
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 0
79942: PUSH
79943: LD_INT 3
79945: NEG
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 1
79953: NEG
79954: PUSH
79955: LD_INT 4
79957: NEG
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 1
79965: NEG
79966: PUSH
79967: LD_INT 5
79969: NEG
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 2
79977: PUSH
79978: LD_INT 3
79980: NEG
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 2
79988: NEG
79989: PUSH
79990: LD_INT 5
79992: NEG
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: LD_INT 3
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 3
80010: PUSH
80011: LD_INT 1
80013: NEG
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 4
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 4
80031: PUSH
80032: LD_INT 1
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 3
80041: PUSH
80042: LD_INT 1
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 2
80051: PUSH
80052: LD_INT 0
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 2
80061: PUSH
80062: LD_INT 1
80064: NEG
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: PUSH
80070: LD_INT 2
80072: PUSH
80073: LD_INT 2
80075: NEG
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: LD_INT 4
80083: PUSH
80084: LD_INT 2
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 4
80093: PUSH
80094: LD_INT 4
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 4
80103: PUSH
80104: LD_INT 3
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 5
80113: PUSH
80114: LD_INT 4
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 5
80123: PUSH
80124: LD_INT 5
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 4
80133: PUSH
80134: LD_INT 5
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 3
80143: PUSH
80144: LD_INT 4
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 3
80153: PUSH
80154: LD_INT 3
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 5
80163: PUSH
80164: LD_INT 3
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 3
80173: PUSH
80174: LD_INT 5
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 0
80183: PUSH
80184: LD_INT 3
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 0
80193: PUSH
80194: LD_INT 2
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PUSH
80201: LD_INT 1
80203: PUSH
80204: LD_INT 3
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 1
80213: PUSH
80214: LD_INT 4
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 0
80223: PUSH
80224: LD_INT 4
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: NEG
80234: PUSH
80235: LD_INT 3
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 1
80244: NEG
80245: PUSH
80246: LD_INT 2
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 2
80255: PUSH
80256: LD_INT 4
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 2
80265: NEG
80266: PUSH
80267: LD_INT 2
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 4
80276: NEG
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 4
80287: NEG
80288: PUSH
80289: LD_INT 1
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 3
80299: NEG
80300: PUSH
80301: LD_INT 0
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 3
80310: NEG
80311: PUSH
80312: LD_INT 1
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 4
80321: NEG
80322: PUSH
80323: LD_INT 1
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 5
80332: NEG
80333: PUSH
80334: LD_INT 0
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 5
80343: NEG
80344: PUSH
80345: LD_INT 1
80347: NEG
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 5
80355: NEG
80356: PUSH
80357: LD_INT 2
80359: NEG
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: PUSH
80365: LD_INT 3
80367: NEG
80368: PUSH
80369: LD_INT 2
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: LIST
80421: LIST
80422: ST_TO_ADDR
// end ; end ;
80423: GO 80426
80425: POP
// case btype of b_depot , b_warehouse :
80426: LD_VAR 0 1
80430: PUSH
80431: LD_INT 0
80433: DOUBLE
80434: EQUAL
80435: IFTRUE 80445
80437: LD_INT 1
80439: DOUBLE
80440: EQUAL
80441: IFTRUE 80445
80443: GO 80646
80445: POP
// case nation of nation_american :
80446: LD_VAR 0 5
80450: PUSH
80451: LD_INT 1
80453: DOUBLE
80454: EQUAL
80455: IFTRUE 80459
80457: GO 80515
80459: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80460: LD_ADDR_VAR 0 9
80464: PUSH
80465: LD_VAR 0 11
80469: PUSH
80470: LD_VAR 0 12
80474: PUSH
80475: LD_VAR 0 13
80479: PUSH
80480: LD_VAR 0 14
80484: PUSH
80485: LD_VAR 0 15
80489: PUSH
80490: LD_VAR 0 16
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: PUSH
80503: LD_VAR 0 4
80507: PUSH
80508: LD_INT 1
80510: PLUS
80511: ARRAY
80512: ST_TO_ADDR
80513: GO 80644
80515: LD_INT 2
80517: DOUBLE
80518: EQUAL
80519: IFTRUE 80523
80521: GO 80579
80523: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80524: LD_ADDR_VAR 0 9
80528: PUSH
80529: LD_VAR 0 17
80533: PUSH
80534: LD_VAR 0 18
80538: PUSH
80539: LD_VAR 0 19
80543: PUSH
80544: LD_VAR 0 20
80548: PUSH
80549: LD_VAR 0 21
80553: PUSH
80554: LD_VAR 0 22
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: PUSH
80567: LD_VAR 0 4
80571: PUSH
80572: LD_INT 1
80574: PLUS
80575: ARRAY
80576: ST_TO_ADDR
80577: GO 80644
80579: LD_INT 3
80581: DOUBLE
80582: EQUAL
80583: IFTRUE 80587
80585: GO 80643
80587: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80588: LD_ADDR_VAR 0 9
80592: PUSH
80593: LD_VAR 0 23
80597: PUSH
80598: LD_VAR 0 24
80602: PUSH
80603: LD_VAR 0 25
80607: PUSH
80608: LD_VAR 0 26
80612: PUSH
80613: LD_VAR 0 27
80617: PUSH
80618: LD_VAR 0 28
80622: PUSH
80623: EMPTY
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: PUSH
80631: LD_VAR 0 4
80635: PUSH
80636: LD_INT 1
80638: PLUS
80639: ARRAY
80640: ST_TO_ADDR
80641: GO 80644
80643: POP
80644: GO 81199
80646: LD_INT 2
80648: DOUBLE
80649: EQUAL
80650: IFTRUE 80660
80652: LD_INT 3
80654: DOUBLE
80655: EQUAL
80656: IFTRUE 80660
80658: GO 80716
80660: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80661: LD_ADDR_VAR 0 9
80665: PUSH
80666: LD_VAR 0 29
80670: PUSH
80671: LD_VAR 0 30
80675: PUSH
80676: LD_VAR 0 31
80680: PUSH
80681: LD_VAR 0 32
80685: PUSH
80686: LD_VAR 0 33
80690: PUSH
80691: LD_VAR 0 34
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: PUSH
80704: LD_VAR 0 4
80708: PUSH
80709: LD_INT 1
80711: PLUS
80712: ARRAY
80713: ST_TO_ADDR
80714: GO 81199
80716: LD_INT 16
80718: DOUBLE
80719: EQUAL
80720: IFTRUE 80778
80722: LD_INT 17
80724: DOUBLE
80725: EQUAL
80726: IFTRUE 80778
80728: LD_INT 18
80730: DOUBLE
80731: EQUAL
80732: IFTRUE 80778
80734: LD_INT 19
80736: DOUBLE
80737: EQUAL
80738: IFTRUE 80778
80740: LD_INT 22
80742: DOUBLE
80743: EQUAL
80744: IFTRUE 80778
80746: LD_INT 20
80748: DOUBLE
80749: EQUAL
80750: IFTRUE 80778
80752: LD_INT 21
80754: DOUBLE
80755: EQUAL
80756: IFTRUE 80778
80758: LD_INT 23
80760: DOUBLE
80761: EQUAL
80762: IFTRUE 80778
80764: LD_INT 24
80766: DOUBLE
80767: EQUAL
80768: IFTRUE 80778
80770: LD_INT 25
80772: DOUBLE
80773: EQUAL
80774: IFTRUE 80778
80776: GO 80834
80778: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80779: LD_ADDR_VAR 0 9
80783: PUSH
80784: LD_VAR 0 35
80788: PUSH
80789: LD_VAR 0 36
80793: PUSH
80794: LD_VAR 0 37
80798: PUSH
80799: LD_VAR 0 38
80803: PUSH
80804: LD_VAR 0 39
80808: PUSH
80809: LD_VAR 0 40
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: PUSH
80822: LD_VAR 0 4
80826: PUSH
80827: LD_INT 1
80829: PLUS
80830: ARRAY
80831: ST_TO_ADDR
80832: GO 81199
80834: LD_INT 6
80836: DOUBLE
80837: EQUAL
80838: IFTRUE 80890
80840: LD_INT 7
80842: DOUBLE
80843: EQUAL
80844: IFTRUE 80890
80846: LD_INT 8
80848: DOUBLE
80849: EQUAL
80850: IFTRUE 80890
80852: LD_INT 13
80854: DOUBLE
80855: EQUAL
80856: IFTRUE 80890
80858: LD_INT 12
80860: DOUBLE
80861: EQUAL
80862: IFTRUE 80890
80864: LD_INT 15
80866: DOUBLE
80867: EQUAL
80868: IFTRUE 80890
80870: LD_INT 11
80872: DOUBLE
80873: EQUAL
80874: IFTRUE 80890
80876: LD_INT 14
80878: DOUBLE
80879: EQUAL
80880: IFTRUE 80890
80882: LD_INT 10
80884: DOUBLE
80885: EQUAL
80886: IFTRUE 80890
80888: GO 80946
80890: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80891: LD_ADDR_VAR 0 9
80895: PUSH
80896: LD_VAR 0 41
80900: PUSH
80901: LD_VAR 0 42
80905: PUSH
80906: LD_VAR 0 43
80910: PUSH
80911: LD_VAR 0 44
80915: PUSH
80916: LD_VAR 0 45
80920: PUSH
80921: LD_VAR 0 46
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: PUSH
80934: LD_VAR 0 4
80938: PUSH
80939: LD_INT 1
80941: PLUS
80942: ARRAY
80943: ST_TO_ADDR
80944: GO 81199
80946: LD_INT 36
80948: DOUBLE
80949: EQUAL
80950: IFTRUE 80954
80952: GO 81010
80954: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80955: LD_ADDR_VAR 0 9
80959: PUSH
80960: LD_VAR 0 47
80964: PUSH
80965: LD_VAR 0 48
80969: PUSH
80970: LD_VAR 0 49
80974: PUSH
80975: LD_VAR 0 50
80979: PUSH
80980: LD_VAR 0 51
80984: PUSH
80985: LD_VAR 0 52
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: PUSH
80998: LD_VAR 0 4
81002: PUSH
81003: LD_INT 1
81005: PLUS
81006: ARRAY
81007: ST_TO_ADDR
81008: GO 81199
81010: LD_INT 4
81012: DOUBLE
81013: EQUAL
81014: IFTRUE 81036
81016: LD_INT 5
81018: DOUBLE
81019: EQUAL
81020: IFTRUE 81036
81022: LD_INT 34
81024: DOUBLE
81025: EQUAL
81026: IFTRUE 81036
81028: LD_INT 37
81030: DOUBLE
81031: EQUAL
81032: IFTRUE 81036
81034: GO 81092
81036: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81037: LD_ADDR_VAR 0 9
81041: PUSH
81042: LD_VAR 0 53
81046: PUSH
81047: LD_VAR 0 54
81051: PUSH
81052: LD_VAR 0 55
81056: PUSH
81057: LD_VAR 0 56
81061: PUSH
81062: LD_VAR 0 57
81066: PUSH
81067: LD_VAR 0 58
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: PUSH
81080: LD_VAR 0 4
81084: PUSH
81085: LD_INT 1
81087: PLUS
81088: ARRAY
81089: ST_TO_ADDR
81090: GO 81199
81092: LD_INT 31
81094: DOUBLE
81095: EQUAL
81096: IFTRUE 81142
81098: LD_INT 32
81100: DOUBLE
81101: EQUAL
81102: IFTRUE 81142
81104: LD_INT 33
81106: DOUBLE
81107: EQUAL
81108: IFTRUE 81142
81110: LD_INT 27
81112: DOUBLE
81113: EQUAL
81114: IFTRUE 81142
81116: LD_INT 26
81118: DOUBLE
81119: EQUAL
81120: IFTRUE 81142
81122: LD_INT 28
81124: DOUBLE
81125: EQUAL
81126: IFTRUE 81142
81128: LD_INT 29
81130: DOUBLE
81131: EQUAL
81132: IFTRUE 81142
81134: LD_INT 30
81136: DOUBLE
81137: EQUAL
81138: IFTRUE 81142
81140: GO 81198
81142: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81143: LD_ADDR_VAR 0 9
81147: PUSH
81148: LD_VAR 0 59
81152: PUSH
81153: LD_VAR 0 60
81157: PUSH
81158: LD_VAR 0 61
81162: PUSH
81163: LD_VAR 0 62
81167: PUSH
81168: LD_VAR 0 63
81172: PUSH
81173: LD_VAR 0 64
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: PUSH
81186: LD_VAR 0 4
81190: PUSH
81191: LD_INT 1
81193: PLUS
81194: ARRAY
81195: ST_TO_ADDR
81196: GO 81199
81198: POP
// temp_list2 = [ ] ;
81199: LD_ADDR_VAR 0 10
81203: PUSH
81204: EMPTY
81205: ST_TO_ADDR
// for i in temp_list do
81206: LD_ADDR_VAR 0 8
81210: PUSH
81211: LD_VAR 0 9
81215: PUSH
81216: FOR_IN
81217: IFFALSE 81269
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81219: LD_ADDR_VAR 0 10
81223: PUSH
81224: LD_VAR 0 10
81228: PUSH
81229: LD_VAR 0 8
81233: PUSH
81234: LD_INT 1
81236: ARRAY
81237: PUSH
81238: LD_VAR 0 2
81242: PLUS
81243: PUSH
81244: LD_VAR 0 8
81248: PUSH
81249: LD_INT 2
81251: ARRAY
81252: PUSH
81253: LD_VAR 0 3
81257: PLUS
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: EMPTY
81264: LIST
81265: ADD
81266: ST_TO_ADDR
81267: GO 81216
81269: POP
81270: POP
// result = temp_list2 ;
81271: LD_ADDR_VAR 0 7
81275: PUSH
81276: LD_VAR 0 10
81280: ST_TO_ADDR
// end ;
81281: LD_VAR 0 7
81285: RET
// export function EnemyInRange ( unit , dist ) ; begin
81286: LD_INT 0
81288: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81289: LD_ADDR_VAR 0 3
81293: PUSH
81294: LD_VAR 0 1
81298: PPUSH
81299: CALL_OW 255
81303: PPUSH
81304: LD_VAR 0 1
81308: PPUSH
81309: CALL_OW 250
81313: PPUSH
81314: LD_VAR 0 1
81318: PPUSH
81319: CALL_OW 251
81323: PPUSH
81324: LD_VAR 0 2
81328: PPUSH
81329: CALL 54688 0 4
81333: PUSH
81334: LD_INT 4
81336: ARRAY
81337: ST_TO_ADDR
// end ;
81338: LD_VAR 0 3
81342: RET
// export function PlayerSeeMe ( unit ) ; begin
81343: LD_INT 0
81345: PPUSH
// result := See ( your_side , unit ) ;
81346: LD_ADDR_VAR 0 2
81350: PUSH
81351: LD_OWVAR 2
81355: PPUSH
81356: LD_VAR 0 1
81360: PPUSH
81361: CALL_OW 292
81365: ST_TO_ADDR
// end ;
81366: LD_VAR 0 2
81370: RET
// export function ReverseDir ( unit ) ; begin
81371: LD_INT 0
81373: PPUSH
// if not unit then
81374: LD_VAR 0 1
81378: NOT
81379: IFFALSE 81383
// exit ;
81381: GO 81406
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81383: LD_ADDR_VAR 0 2
81387: PUSH
81388: LD_VAR 0 1
81392: PPUSH
81393: CALL_OW 254
81397: PUSH
81398: LD_INT 3
81400: PLUS
81401: PUSH
81402: LD_INT 6
81404: MOD
81405: ST_TO_ADDR
// end ;
81406: LD_VAR 0 2
81410: RET
// export function ReverseArray ( array ) ; var i ; begin
81411: LD_INT 0
81413: PPUSH
81414: PPUSH
// if not array then
81415: LD_VAR 0 1
81419: NOT
81420: IFFALSE 81424
// exit ;
81422: GO 81479
// result := [ ] ;
81424: LD_ADDR_VAR 0 2
81428: PUSH
81429: EMPTY
81430: ST_TO_ADDR
// for i := array downto 1 do
81431: LD_ADDR_VAR 0 3
81435: PUSH
81436: DOUBLE
81437: LD_VAR 0 1
81441: INC
81442: ST_TO_ADDR
81443: LD_INT 1
81445: PUSH
81446: FOR_DOWNTO
81447: IFFALSE 81477
// result := Join ( result , array [ i ] ) ;
81449: LD_ADDR_VAR 0 2
81453: PUSH
81454: LD_VAR 0 2
81458: PPUSH
81459: LD_VAR 0 1
81463: PUSH
81464: LD_VAR 0 3
81468: ARRAY
81469: PPUSH
81470: CALL 86104 0 2
81474: ST_TO_ADDR
81475: GO 81446
81477: POP
81478: POP
// end ;
81479: LD_VAR 0 2
81483: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81484: LD_INT 0
81486: PPUSH
81487: PPUSH
81488: PPUSH
81489: PPUSH
81490: PPUSH
81491: PPUSH
// if not unit or not hexes then
81492: LD_VAR 0 1
81496: NOT
81497: PUSH
81498: LD_VAR 0 2
81502: NOT
81503: OR
81504: IFFALSE 81508
// exit ;
81506: GO 81631
// dist := 9999 ;
81508: LD_ADDR_VAR 0 5
81512: PUSH
81513: LD_INT 9999
81515: ST_TO_ADDR
// for i = 1 to hexes do
81516: LD_ADDR_VAR 0 4
81520: PUSH
81521: DOUBLE
81522: LD_INT 1
81524: DEC
81525: ST_TO_ADDR
81526: LD_VAR 0 2
81530: PUSH
81531: FOR_TO
81532: IFFALSE 81619
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81534: LD_ADDR_VAR 0 6
81538: PUSH
81539: LD_VAR 0 1
81543: PPUSH
81544: LD_VAR 0 2
81548: PUSH
81549: LD_VAR 0 4
81553: ARRAY
81554: PUSH
81555: LD_INT 1
81557: ARRAY
81558: PPUSH
81559: LD_VAR 0 2
81563: PUSH
81564: LD_VAR 0 4
81568: ARRAY
81569: PUSH
81570: LD_INT 2
81572: ARRAY
81573: PPUSH
81574: CALL_OW 297
81578: ST_TO_ADDR
// if tdist < dist then
81579: LD_VAR 0 6
81583: PUSH
81584: LD_VAR 0 5
81588: LESS
81589: IFFALSE 81617
// begin hex := hexes [ i ] ;
81591: LD_ADDR_VAR 0 8
81595: PUSH
81596: LD_VAR 0 2
81600: PUSH
81601: LD_VAR 0 4
81605: ARRAY
81606: ST_TO_ADDR
// dist := tdist ;
81607: LD_ADDR_VAR 0 5
81611: PUSH
81612: LD_VAR 0 6
81616: ST_TO_ADDR
// end ; end ;
81617: GO 81531
81619: POP
81620: POP
// result := hex ;
81621: LD_ADDR_VAR 0 3
81625: PUSH
81626: LD_VAR 0 8
81630: ST_TO_ADDR
// end ;
81631: LD_VAR 0 3
81635: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81636: LD_INT 0
81638: PPUSH
81639: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81640: LD_VAR 0 1
81644: NOT
81645: PUSH
81646: LD_VAR 0 1
81650: PUSH
81651: LD_INT 21
81653: PUSH
81654: LD_INT 2
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 23
81663: PUSH
81664: LD_INT 2
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PPUSH
81675: CALL_OW 69
81679: IN
81680: NOT
81681: OR
81682: IFFALSE 81686
// exit ;
81684: GO 81733
// for i = 1 to 3 do
81686: LD_ADDR_VAR 0 3
81690: PUSH
81691: DOUBLE
81692: LD_INT 1
81694: DEC
81695: ST_TO_ADDR
81696: LD_INT 3
81698: PUSH
81699: FOR_TO
81700: IFFALSE 81731
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81702: LD_VAR 0 1
81706: PPUSH
81707: CALL_OW 250
81711: PPUSH
81712: LD_VAR 0 1
81716: PPUSH
81717: CALL_OW 251
81721: PPUSH
81722: LD_INT 1
81724: PPUSH
81725: CALL_OW 453
81729: GO 81699
81731: POP
81732: POP
// end ;
81733: LD_VAR 0 2
81737: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81738: LD_INT 0
81740: PPUSH
81741: PPUSH
81742: PPUSH
81743: PPUSH
81744: PPUSH
81745: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81746: LD_VAR 0 1
81750: NOT
81751: PUSH
81752: LD_VAR 0 2
81756: NOT
81757: OR
81758: PUSH
81759: LD_VAR 0 1
81763: PPUSH
81764: CALL_OW 314
81768: OR
81769: IFFALSE 81773
// exit ;
81771: GO 82214
// x := GetX ( enemy_unit ) ;
81773: LD_ADDR_VAR 0 7
81777: PUSH
81778: LD_VAR 0 2
81782: PPUSH
81783: CALL_OW 250
81787: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81788: LD_ADDR_VAR 0 8
81792: PUSH
81793: LD_VAR 0 2
81797: PPUSH
81798: CALL_OW 251
81802: ST_TO_ADDR
// if not x or not y then
81803: LD_VAR 0 7
81807: NOT
81808: PUSH
81809: LD_VAR 0 8
81813: NOT
81814: OR
81815: IFFALSE 81819
// exit ;
81817: GO 82214
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81819: LD_ADDR_VAR 0 6
81823: PUSH
81824: LD_VAR 0 7
81828: PPUSH
81829: LD_INT 0
81831: PPUSH
81832: LD_INT 4
81834: PPUSH
81835: CALL_OW 272
81839: PUSH
81840: LD_VAR 0 8
81844: PPUSH
81845: LD_INT 0
81847: PPUSH
81848: LD_INT 4
81850: PPUSH
81851: CALL_OW 273
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_VAR 0 7
81864: PPUSH
81865: LD_INT 1
81867: PPUSH
81868: LD_INT 4
81870: PPUSH
81871: CALL_OW 272
81875: PUSH
81876: LD_VAR 0 8
81880: PPUSH
81881: LD_INT 1
81883: PPUSH
81884: LD_INT 4
81886: PPUSH
81887: CALL_OW 273
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_VAR 0 7
81900: PPUSH
81901: LD_INT 2
81903: PPUSH
81904: LD_INT 4
81906: PPUSH
81907: CALL_OW 272
81911: PUSH
81912: LD_VAR 0 8
81916: PPUSH
81917: LD_INT 2
81919: PPUSH
81920: LD_INT 4
81922: PPUSH
81923: CALL_OW 273
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_VAR 0 7
81936: PPUSH
81937: LD_INT 3
81939: PPUSH
81940: LD_INT 4
81942: PPUSH
81943: CALL_OW 272
81947: PUSH
81948: LD_VAR 0 8
81952: PPUSH
81953: LD_INT 3
81955: PPUSH
81956: LD_INT 4
81958: PPUSH
81959: CALL_OW 273
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_VAR 0 7
81972: PPUSH
81973: LD_INT 4
81975: PPUSH
81976: LD_INT 4
81978: PPUSH
81979: CALL_OW 272
81983: PUSH
81984: LD_VAR 0 8
81988: PPUSH
81989: LD_INT 4
81991: PPUSH
81992: LD_INT 4
81994: PPUSH
81995: CALL_OW 273
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_VAR 0 7
82008: PPUSH
82009: LD_INT 5
82011: PPUSH
82012: LD_INT 4
82014: PPUSH
82015: CALL_OW 272
82019: PUSH
82020: LD_VAR 0 8
82024: PPUSH
82025: LD_INT 5
82027: PPUSH
82028: LD_INT 4
82030: PPUSH
82031: CALL_OW 273
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: ST_TO_ADDR
// for i = tmp downto 1 do
82048: LD_ADDR_VAR 0 4
82052: PUSH
82053: DOUBLE
82054: LD_VAR 0 6
82058: INC
82059: ST_TO_ADDR
82060: LD_INT 1
82062: PUSH
82063: FOR_DOWNTO
82064: IFFALSE 82165
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82066: LD_VAR 0 6
82070: PUSH
82071: LD_VAR 0 4
82075: ARRAY
82076: PUSH
82077: LD_INT 1
82079: ARRAY
82080: PPUSH
82081: LD_VAR 0 6
82085: PUSH
82086: LD_VAR 0 4
82090: ARRAY
82091: PUSH
82092: LD_INT 2
82094: ARRAY
82095: PPUSH
82096: CALL_OW 488
82100: NOT
82101: PUSH
82102: LD_VAR 0 6
82106: PUSH
82107: LD_VAR 0 4
82111: ARRAY
82112: PUSH
82113: LD_INT 1
82115: ARRAY
82116: PPUSH
82117: LD_VAR 0 6
82121: PUSH
82122: LD_VAR 0 4
82126: ARRAY
82127: PUSH
82128: LD_INT 2
82130: ARRAY
82131: PPUSH
82132: CALL_OW 428
82136: PUSH
82137: LD_INT 0
82139: NONEQUAL
82140: OR
82141: IFFALSE 82163
// tmp := Delete ( tmp , i ) ;
82143: LD_ADDR_VAR 0 6
82147: PUSH
82148: LD_VAR 0 6
82152: PPUSH
82153: LD_VAR 0 4
82157: PPUSH
82158: CALL_OW 3
82162: ST_TO_ADDR
82163: GO 82063
82165: POP
82166: POP
// j := GetClosestHex ( unit , tmp ) ;
82167: LD_ADDR_VAR 0 5
82171: PUSH
82172: LD_VAR 0 1
82176: PPUSH
82177: LD_VAR 0 6
82181: PPUSH
82182: CALL 81484 0 2
82186: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82187: LD_VAR 0 1
82191: PPUSH
82192: LD_VAR 0 5
82196: PUSH
82197: LD_INT 1
82199: ARRAY
82200: PPUSH
82201: LD_VAR 0 5
82205: PUSH
82206: LD_INT 2
82208: ARRAY
82209: PPUSH
82210: CALL_OW 111
// end ;
82214: LD_VAR 0 3
82218: RET
// export function PrepareApemanSoldier ( ) ; begin
82219: LD_INT 0
82221: PPUSH
// uc_nation := 0 ;
82222: LD_ADDR_OWVAR 21
82226: PUSH
82227: LD_INT 0
82229: ST_TO_ADDR
// hc_sex := sex_male ;
82230: LD_ADDR_OWVAR 27
82234: PUSH
82235: LD_INT 1
82237: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82238: LD_ADDR_OWVAR 28
82242: PUSH
82243: LD_INT 15
82245: ST_TO_ADDR
// hc_gallery :=  ;
82246: LD_ADDR_OWVAR 33
82250: PUSH
82251: LD_STRING 
82253: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82254: LD_ADDR_OWVAR 31
82258: PUSH
82259: LD_INT 0
82261: PPUSH
82262: LD_INT 3
82264: PPUSH
82265: CALL_OW 12
82269: PUSH
82270: LD_INT 0
82272: PPUSH
82273: LD_INT 3
82275: PPUSH
82276: CALL_OW 12
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: LD_INT 0
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: ST_TO_ADDR
// end ;
82293: LD_VAR 0 1
82297: RET
// export function PrepareApemanEngineer ( ) ; begin
82298: LD_INT 0
82300: PPUSH
// uc_nation := 0 ;
82301: LD_ADDR_OWVAR 21
82305: PUSH
82306: LD_INT 0
82308: ST_TO_ADDR
// hc_sex := sex_male ;
82309: LD_ADDR_OWVAR 27
82313: PUSH
82314: LD_INT 1
82316: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82317: LD_ADDR_OWVAR 28
82321: PUSH
82322: LD_INT 16
82324: ST_TO_ADDR
// hc_gallery :=  ;
82325: LD_ADDR_OWVAR 33
82329: PUSH
82330: LD_STRING 
82332: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82333: LD_ADDR_OWVAR 31
82337: PUSH
82338: LD_INT 0
82340: PPUSH
82341: LD_INT 3
82343: PPUSH
82344: CALL_OW 12
82348: PUSH
82349: LD_INT 0
82351: PPUSH
82352: LD_INT 3
82354: PPUSH
82355: CALL_OW 12
82359: PUSH
82360: LD_INT 0
82362: PUSH
82363: LD_INT 0
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: ST_TO_ADDR
// end ;
82372: LD_VAR 0 1
82376: RET
// export function PrepareApeman ( agressivity ) ; begin
82377: LD_INT 0
82379: PPUSH
// uc_side := 0 ;
82380: LD_ADDR_OWVAR 20
82384: PUSH
82385: LD_INT 0
82387: ST_TO_ADDR
// uc_nation := 0 ;
82388: LD_ADDR_OWVAR 21
82392: PUSH
82393: LD_INT 0
82395: ST_TO_ADDR
// hc_sex := sex_male ;
82396: LD_ADDR_OWVAR 27
82400: PUSH
82401: LD_INT 1
82403: ST_TO_ADDR
// hc_class := class_apeman ;
82404: LD_ADDR_OWVAR 28
82408: PUSH
82409: LD_INT 12
82411: ST_TO_ADDR
// hc_gallery :=  ;
82412: LD_ADDR_OWVAR 33
82416: PUSH
82417: LD_STRING 
82419: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82420: LD_ADDR_OWVAR 35
82424: PUSH
82425: LD_VAR 0 1
82429: NEG
82430: PPUSH
82431: LD_VAR 0 1
82435: PPUSH
82436: CALL_OW 12
82440: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82441: LD_ADDR_OWVAR 31
82445: PUSH
82446: LD_INT 0
82448: PPUSH
82449: LD_INT 3
82451: PPUSH
82452: CALL_OW 12
82456: PUSH
82457: LD_INT 0
82459: PPUSH
82460: LD_INT 3
82462: PPUSH
82463: CALL_OW 12
82467: PUSH
82468: LD_INT 0
82470: PUSH
82471: LD_INT 0
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: ST_TO_ADDR
// end ;
82480: LD_VAR 0 2
82484: RET
// export function PrepareTiger ( agressivity ) ; begin
82485: LD_INT 0
82487: PPUSH
// uc_side := 0 ;
82488: LD_ADDR_OWVAR 20
82492: PUSH
82493: LD_INT 0
82495: ST_TO_ADDR
// uc_nation := 0 ;
82496: LD_ADDR_OWVAR 21
82500: PUSH
82501: LD_INT 0
82503: ST_TO_ADDR
// hc_class := class_tiger ;
82504: LD_ADDR_OWVAR 28
82508: PUSH
82509: LD_INT 14
82511: ST_TO_ADDR
// hc_gallery :=  ;
82512: LD_ADDR_OWVAR 33
82516: PUSH
82517: LD_STRING 
82519: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82520: LD_ADDR_OWVAR 35
82524: PUSH
82525: LD_VAR 0 1
82529: NEG
82530: PPUSH
82531: LD_VAR 0 1
82535: PPUSH
82536: CALL_OW 12
82540: ST_TO_ADDR
// end ;
82541: LD_VAR 0 2
82545: RET
// export function PrepareEnchidna ( ) ; begin
82546: LD_INT 0
82548: PPUSH
// uc_side := 0 ;
82549: LD_ADDR_OWVAR 20
82553: PUSH
82554: LD_INT 0
82556: ST_TO_ADDR
// uc_nation := 0 ;
82557: LD_ADDR_OWVAR 21
82561: PUSH
82562: LD_INT 0
82564: ST_TO_ADDR
// hc_class := class_baggie ;
82565: LD_ADDR_OWVAR 28
82569: PUSH
82570: LD_INT 13
82572: ST_TO_ADDR
// hc_gallery :=  ;
82573: LD_ADDR_OWVAR 33
82577: PUSH
82578: LD_STRING 
82580: ST_TO_ADDR
// end ;
82581: LD_VAR 0 1
82585: RET
// export function PrepareFrog ( ) ; begin
82586: LD_INT 0
82588: PPUSH
// uc_side := 0 ;
82589: LD_ADDR_OWVAR 20
82593: PUSH
82594: LD_INT 0
82596: ST_TO_ADDR
// uc_nation := 0 ;
82597: LD_ADDR_OWVAR 21
82601: PUSH
82602: LD_INT 0
82604: ST_TO_ADDR
// hc_class := class_frog ;
82605: LD_ADDR_OWVAR 28
82609: PUSH
82610: LD_INT 19
82612: ST_TO_ADDR
// hc_gallery :=  ;
82613: LD_ADDR_OWVAR 33
82617: PUSH
82618: LD_STRING 
82620: ST_TO_ADDR
// end ;
82621: LD_VAR 0 1
82625: RET
// export function PrepareFish ( ) ; begin
82626: LD_INT 0
82628: PPUSH
// uc_side := 0 ;
82629: LD_ADDR_OWVAR 20
82633: PUSH
82634: LD_INT 0
82636: ST_TO_ADDR
// uc_nation := 0 ;
82637: LD_ADDR_OWVAR 21
82641: PUSH
82642: LD_INT 0
82644: ST_TO_ADDR
// hc_class := class_fish ;
82645: LD_ADDR_OWVAR 28
82649: PUSH
82650: LD_INT 20
82652: ST_TO_ADDR
// hc_gallery :=  ;
82653: LD_ADDR_OWVAR 33
82657: PUSH
82658: LD_STRING 
82660: ST_TO_ADDR
// end ;
82661: LD_VAR 0 1
82665: RET
// export function PrepareBird ( ) ; begin
82666: LD_INT 0
82668: PPUSH
// uc_side := 0 ;
82669: LD_ADDR_OWVAR 20
82673: PUSH
82674: LD_INT 0
82676: ST_TO_ADDR
// uc_nation := 0 ;
82677: LD_ADDR_OWVAR 21
82681: PUSH
82682: LD_INT 0
82684: ST_TO_ADDR
// hc_class := class_phororhacos ;
82685: LD_ADDR_OWVAR 28
82689: PUSH
82690: LD_INT 18
82692: ST_TO_ADDR
// hc_gallery :=  ;
82693: LD_ADDR_OWVAR 33
82697: PUSH
82698: LD_STRING 
82700: ST_TO_ADDR
// end ;
82701: LD_VAR 0 1
82705: RET
// export function PrepareHorse ( ) ; begin
82706: LD_INT 0
82708: PPUSH
// uc_side := 0 ;
82709: LD_ADDR_OWVAR 20
82713: PUSH
82714: LD_INT 0
82716: ST_TO_ADDR
// uc_nation := 0 ;
82717: LD_ADDR_OWVAR 21
82721: PUSH
82722: LD_INT 0
82724: ST_TO_ADDR
// hc_class := class_horse ;
82725: LD_ADDR_OWVAR 28
82729: PUSH
82730: LD_INT 21
82732: ST_TO_ADDR
// hc_gallery :=  ;
82733: LD_ADDR_OWVAR 33
82737: PUSH
82738: LD_STRING 
82740: ST_TO_ADDR
// end ;
82741: LD_VAR 0 1
82745: RET
// export function PrepareMastodont ( ) ; begin
82746: LD_INT 0
82748: PPUSH
// uc_side := 0 ;
82749: LD_ADDR_OWVAR 20
82753: PUSH
82754: LD_INT 0
82756: ST_TO_ADDR
// uc_nation := 0 ;
82757: LD_ADDR_OWVAR 21
82761: PUSH
82762: LD_INT 0
82764: ST_TO_ADDR
// vc_chassis := class_mastodont ;
82765: LD_ADDR_OWVAR 37
82769: PUSH
82770: LD_INT 31
82772: ST_TO_ADDR
// vc_control := control_rider ;
82773: LD_ADDR_OWVAR 38
82777: PUSH
82778: LD_INT 4
82780: ST_TO_ADDR
// end ;
82781: LD_VAR 0 1
82785: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82786: LD_INT 0
82788: PPUSH
82789: PPUSH
82790: PPUSH
// uc_side = 0 ;
82791: LD_ADDR_OWVAR 20
82795: PUSH
82796: LD_INT 0
82798: ST_TO_ADDR
// uc_nation = 0 ;
82799: LD_ADDR_OWVAR 21
82803: PUSH
82804: LD_INT 0
82806: ST_TO_ADDR
// InitHc_All ( ) ;
82807: CALL_OW 584
// InitVc ;
82811: CALL_OW 20
// if mastodonts then
82815: LD_VAR 0 6
82819: IFFALSE 82886
// for i = 1 to mastodonts do
82821: LD_ADDR_VAR 0 11
82825: PUSH
82826: DOUBLE
82827: LD_INT 1
82829: DEC
82830: ST_TO_ADDR
82831: LD_VAR 0 6
82835: PUSH
82836: FOR_TO
82837: IFFALSE 82884
// begin vc_chassis := 31 ;
82839: LD_ADDR_OWVAR 37
82843: PUSH
82844: LD_INT 31
82846: ST_TO_ADDR
// vc_control := control_rider ;
82847: LD_ADDR_OWVAR 38
82851: PUSH
82852: LD_INT 4
82854: ST_TO_ADDR
// animal := CreateVehicle ;
82855: LD_ADDR_VAR 0 12
82859: PUSH
82860: CALL_OW 45
82864: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82865: LD_VAR 0 12
82869: PPUSH
82870: LD_VAR 0 8
82874: PPUSH
82875: LD_INT 0
82877: PPUSH
82878: CALL 85021 0 3
// end ;
82882: GO 82836
82884: POP
82885: POP
// if horses then
82886: LD_VAR 0 5
82890: IFFALSE 82957
// for i = 1 to horses do
82892: LD_ADDR_VAR 0 11
82896: PUSH
82897: DOUBLE
82898: LD_INT 1
82900: DEC
82901: ST_TO_ADDR
82902: LD_VAR 0 5
82906: PUSH
82907: FOR_TO
82908: IFFALSE 82955
// begin hc_class := 21 ;
82910: LD_ADDR_OWVAR 28
82914: PUSH
82915: LD_INT 21
82917: ST_TO_ADDR
// hc_gallery :=  ;
82918: LD_ADDR_OWVAR 33
82922: PUSH
82923: LD_STRING 
82925: ST_TO_ADDR
// animal := CreateHuman ;
82926: LD_ADDR_VAR 0 12
82930: PUSH
82931: CALL_OW 44
82935: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82936: LD_VAR 0 12
82940: PPUSH
82941: LD_VAR 0 8
82945: PPUSH
82946: LD_INT 0
82948: PPUSH
82949: CALL 85021 0 3
// end ;
82953: GO 82907
82955: POP
82956: POP
// if birds then
82957: LD_VAR 0 1
82961: IFFALSE 83028
// for i = 1 to birds do
82963: LD_ADDR_VAR 0 11
82967: PUSH
82968: DOUBLE
82969: LD_INT 1
82971: DEC
82972: ST_TO_ADDR
82973: LD_VAR 0 1
82977: PUSH
82978: FOR_TO
82979: IFFALSE 83026
// begin hc_class = 18 ;
82981: LD_ADDR_OWVAR 28
82985: PUSH
82986: LD_INT 18
82988: ST_TO_ADDR
// hc_gallery =  ;
82989: LD_ADDR_OWVAR 33
82993: PUSH
82994: LD_STRING 
82996: ST_TO_ADDR
// animal := CreateHuman ;
82997: LD_ADDR_VAR 0 12
83001: PUSH
83002: CALL_OW 44
83006: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83007: LD_VAR 0 12
83011: PPUSH
83012: LD_VAR 0 8
83016: PPUSH
83017: LD_INT 0
83019: PPUSH
83020: CALL 85021 0 3
// end ;
83024: GO 82978
83026: POP
83027: POP
// if tigers then
83028: LD_VAR 0 2
83032: IFFALSE 83116
// for i = 1 to tigers do
83034: LD_ADDR_VAR 0 11
83038: PUSH
83039: DOUBLE
83040: LD_INT 1
83042: DEC
83043: ST_TO_ADDR
83044: LD_VAR 0 2
83048: PUSH
83049: FOR_TO
83050: IFFALSE 83114
// begin hc_class = class_tiger ;
83052: LD_ADDR_OWVAR 28
83056: PUSH
83057: LD_INT 14
83059: ST_TO_ADDR
// hc_gallery =  ;
83060: LD_ADDR_OWVAR 33
83064: PUSH
83065: LD_STRING 
83067: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83068: LD_ADDR_OWVAR 35
83072: PUSH
83073: LD_INT 7
83075: NEG
83076: PPUSH
83077: LD_INT 7
83079: PPUSH
83080: CALL_OW 12
83084: ST_TO_ADDR
// animal := CreateHuman ;
83085: LD_ADDR_VAR 0 12
83089: PUSH
83090: CALL_OW 44
83094: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83095: LD_VAR 0 12
83099: PPUSH
83100: LD_VAR 0 8
83104: PPUSH
83105: LD_INT 0
83107: PPUSH
83108: CALL 85021 0 3
// end ;
83112: GO 83049
83114: POP
83115: POP
// if apemans then
83116: LD_VAR 0 3
83120: IFFALSE 83243
// for i = 1 to apemans do
83122: LD_ADDR_VAR 0 11
83126: PUSH
83127: DOUBLE
83128: LD_INT 1
83130: DEC
83131: ST_TO_ADDR
83132: LD_VAR 0 3
83136: PUSH
83137: FOR_TO
83138: IFFALSE 83241
// begin hc_class = class_apeman ;
83140: LD_ADDR_OWVAR 28
83144: PUSH
83145: LD_INT 12
83147: ST_TO_ADDR
// hc_gallery =  ;
83148: LD_ADDR_OWVAR 33
83152: PUSH
83153: LD_STRING 
83155: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83156: LD_ADDR_OWVAR 35
83160: PUSH
83161: LD_INT 2
83163: NEG
83164: PPUSH
83165: LD_INT 2
83167: PPUSH
83168: CALL_OW 12
83172: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83173: LD_ADDR_OWVAR 31
83177: PUSH
83178: LD_INT 1
83180: PPUSH
83181: LD_INT 3
83183: PPUSH
83184: CALL_OW 12
83188: PUSH
83189: LD_INT 1
83191: PPUSH
83192: LD_INT 3
83194: PPUSH
83195: CALL_OW 12
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: ST_TO_ADDR
// animal := CreateHuman ;
83212: LD_ADDR_VAR 0 12
83216: PUSH
83217: CALL_OW 44
83221: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83222: LD_VAR 0 12
83226: PPUSH
83227: LD_VAR 0 8
83231: PPUSH
83232: LD_INT 0
83234: PPUSH
83235: CALL 85021 0 3
// end ;
83239: GO 83137
83241: POP
83242: POP
// if enchidnas then
83243: LD_VAR 0 4
83247: IFFALSE 83314
// for i = 1 to enchidnas do
83249: LD_ADDR_VAR 0 11
83253: PUSH
83254: DOUBLE
83255: LD_INT 1
83257: DEC
83258: ST_TO_ADDR
83259: LD_VAR 0 4
83263: PUSH
83264: FOR_TO
83265: IFFALSE 83312
// begin hc_class = 13 ;
83267: LD_ADDR_OWVAR 28
83271: PUSH
83272: LD_INT 13
83274: ST_TO_ADDR
// hc_gallery =  ;
83275: LD_ADDR_OWVAR 33
83279: PUSH
83280: LD_STRING 
83282: ST_TO_ADDR
// animal := CreateHuman ;
83283: LD_ADDR_VAR 0 12
83287: PUSH
83288: CALL_OW 44
83292: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83293: LD_VAR 0 12
83297: PPUSH
83298: LD_VAR 0 8
83302: PPUSH
83303: LD_INT 0
83305: PPUSH
83306: CALL 85021 0 3
// end ;
83310: GO 83264
83312: POP
83313: POP
// if fishes then
83314: LD_VAR 0 7
83318: IFFALSE 83385
// for i = 1 to fishes do
83320: LD_ADDR_VAR 0 11
83324: PUSH
83325: DOUBLE
83326: LD_INT 1
83328: DEC
83329: ST_TO_ADDR
83330: LD_VAR 0 7
83334: PUSH
83335: FOR_TO
83336: IFFALSE 83383
// begin hc_class = 20 ;
83338: LD_ADDR_OWVAR 28
83342: PUSH
83343: LD_INT 20
83345: ST_TO_ADDR
// hc_gallery =  ;
83346: LD_ADDR_OWVAR 33
83350: PUSH
83351: LD_STRING 
83353: ST_TO_ADDR
// animal := CreateHuman ;
83354: LD_ADDR_VAR 0 12
83358: PUSH
83359: CALL_OW 44
83363: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83364: LD_VAR 0 12
83368: PPUSH
83369: LD_VAR 0 9
83373: PPUSH
83374: LD_INT 0
83376: PPUSH
83377: CALL 85021 0 3
// end ;
83381: GO 83335
83383: POP
83384: POP
// end ;
83385: LD_VAR 0 10
83389: RET
// export function WantHeal ( sci , unit ) ; begin
83390: LD_INT 0
83392: PPUSH
// if GetTaskList ( sci ) > 0 then
83393: LD_VAR 0 1
83397: PPUSH
83398: CALL_OW 437
83402: PUSH
83403: LD_INT 0
83405: GREATER
83406: IFFALSE 83476
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83408: LD_VAR 0 1
83412: PPUSH
83413: CALL_OW 437
83417: PUSH
83418: LD_INT 1
83420: ARRAY
83421: PUSH
83422: LD_INT 1
83424: ARRAY
83425: PUSH
83426: LD_STRING l
83428: EQUAL
83429: PUSH
83430: LD_VAR 0 1
83434: PPUSH
83435: CALL_OW 437
83439: PUSH
83440: LD_INT 1
83442: ARRAY
83443: PUSH
83444: LD_INT 4
83446: ARRAY
83447: PUSH
83448: LD_VAR 0 2
83452: EQUAL
83453: AND
83454: IFFALSE 83466
// result := true else
83456: LD_ADDR_VAR 0 3
83460: PUSH
83461: LD_INT 1
83463: ST_TO_ADDR
83464: GO 83474
// result := false ;
83466: LD_ADDR_VAR 0 3
83470: PUSH
83471: LD_INT 0
83473: ST_TO_ADDR
// end else
83474: GO 83484
// result := false ;
83476: LD_ADDR_VAR 0 3
83480: PUSH
83481: LD_INT 0
83483: ST_TO_ADDR
// end ;
83484: LD_VAR 0 3
83488: RET
// export function HealTarget ( sci ) ; begin
83489: LD_INT 0
83491: PPUSH
// if not sci then
83492: LD_VAR 0 1
83496: NOT
83497: IFFALSE 83501
// exit ;
83499: GO 83566
// result := 0 ;
83501: LD_ADDR_VAR 0 2
83505: PUSH
83506: LD_INT 0
83508: ST_TO_ADDR
// if GetTaskList ( sci ) then
83509: LD_VAR 0 1
83513: PPUSH
83514: CALL_OW 437
83518: IFFALSE 83566
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83520: LD_VAR 0 1
83524: PPUSH
83525: CALL_OW 437
83529: PUSH
83530: LD_INT 1
83532: ARRAY
83533: PUSH
83534: LD_INT 1
83536: ARRAY
83537: PUSH
83538: LD_STRING l
83540: EQUAL
83541: IFFALSE 83566
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83543: LD_ADDR_VAR 0 2
83547: PUSH
83548: LD_VAR 0 1
83552: PPUSH
83553: CALL_OW 437
83557: PUSH
83558: LD_INT 1
83560: ARRAY
83561: PUSH
83562: LD_INT 4
83564: ARRAY
83565: ST_TO_ADDR
// end ;
83566: LD_VAR 0 2
83570: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83571: LD_INT 0
83573: PPUSH
83574: PPUSH
83575: PPUSH
83576: PPUSH
// if not base_units then
83577: LD_VAR 0 1
83581: NOT
83582: IFFALSE 83586
// exit ;
83584: GO 83673
// result := false ;
83586: LD_ADDR_VAR 0 2
83590: PUSH
83591: LD_INT 0
83593: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83594: LD_ADDR_VAR 0 5
83598: PUSH
83599: LD_VAR 0 1
83603: PPUSH
83604: LD_INT 21
83606: PUSH
83607: LD_INT 3
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PPUSH
83614: CALL_OW 72
83618: ST_TO_ADDR
// if not tmp then
83619: LD_VAR 0 5
83623: NOT
83624: IFFALSE 83628
// exit ;
83626: GO 83673
// for i in tmp do
83628: LD_ADDR_VAR 0 3
83632: PUSH
83633: LD_VAR 0 5
83637: PUSH
83638: FOR_IN
83639: IFFALSE 83671
// begin result := EnemyInRange ( i , 22 ) ;
83641: LD_ADDR_VAR 0 2
83645: PUSH
83646: LD_VAR 0 3
83650: PPUSH
83651: LD_INT 22
83653: PPUSH
83654: CALL 81286 0 2
83658: ST_TO_ADDR
// if result then
83659: LD_VAR 0 2
83663: IFFALSE 83669
// exit ;
83665: POP
83666: POP
83667: GO 83673
// end ;
83669: GO 83638
83671: POP
83672: POP
// end ;
83673: LD_VAR 0 2
83677: RET
// export function FilterByTag ( units , tag ) ; begin
83678: LD_INT 0
83680: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83681: LD_ADDR_VAR 0 3
83685: PUSH
83686: LD_VAR 0 1
83690: PPUSH
83691: LD_INT 120
83693: PUSH
83694: LD_VAR 0 2
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PPUSH
83703: CALL_OW 72
83707: ST_TO_ADDR
// end ;
83708: LD_VAR 0 3
83712: RET
// export function IsDriver ( un ) ; begin
83713: LD_INT 0
83715: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83716: LD_ADDR_VAR 0 2
83720: PUSH
83721: LD_VAR 0 1
83725: PUSH
83726: LD_INT 55
83728: PUSH
83729: EMPTY
83730: LIST
83731: PPUSH
83732: CALL_OW 69
83736: IN
83737: ST_TO_ADDR
// end ;
83738: LD_VAR 0 2
83742: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83743: LD_INT 0
83745: PPUSH
83746: PPUSH
// list := [ ] ;
83747: LD_ADDR_VAR 0 5
83751: PUSH
83752: EMPTY
83753: ST_TO_ADDR
// case d of 0 :
83754: LD_VAR 0 3
83758: PUSH
83759: LD_INT 0
83761: DOUBLE
83762: EQUAL
83763: IFTRUE 83767
83765: GO 83900
83767: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83768: LD_ADDR_VAR 0 5
83772: PUSH
83773: LD_VAR 0 1
83777: PUSH
83778: LD_INT 4
83780: MINUS
83781: PUSH
83782: LD_VAR 0 2
83786: PUSH
83787: LD_INT 4
83789: MINUS
83790: PUSH
83791: LD_INT 2
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: LIST
83798: PUSH
83799: LD_VAR 0 1
83803: PUSH
83804: LD_INT 3
83806: MINUS
83807: PUSH
83808: LD_VAR 0 2
83812: PUSH
83813: LD_INT 1
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: LIST
83820: PUSH
83821: LD_VAR 0 1
83825: PUSH
83826: LD_INT 4
83828: PLUS
83829: PUSH
83830: LD_VAR 0 2
83834: PUSH
83835: LD_INT 4
83837: PUSH
83838: EMPTY
83839: LIST
83840: LIST
83841: LIST
83842: PUSH
83843: LD_VAR 0 1
83847: PUSH
83848: LD_INT 3
83850: PLUS
83851: PUSH
83852: LD_VAR 0 2
83856: PUSH
83857: LD_INT 3
83859: PLUS
83860: PUSH
83861: LD_INT 5
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: LIST
83868: PUSH
83869: LD_VAR 0 1
83873: PUSH
83874: LD_VAR 0 2
83878: PUSH
83879: LD_INT 4
83881: PLUS
83882: PUSH
83883: LD_INT 0
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: LIST
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: ST_TO_ADDR
// end ; 1 :
83898: GO 84598
83900: LD_INT 1
83902: DOUBLE
83903: EQUAL
83904: IFTRUE 83908
83906: GO 84041
83908: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83909: LD_ADDR_VAR 0 5
83913: PUSH
83914: LD_VAR 0 1
83918: PUSH
83919: LD_VAR 0 2
83923: PUSH
83924: LD_INT 4
83926: MINUS
83927: PUSH
83928: LD_INT 3
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: LIST
83935: PUSH
83936: LD_VAR 0 1
83940: PUSH
83941: LD_INT 3
83943: MINUS
83944: PUSH
83945: LD_VAR 0 2
83949: PUSH
83950: LD_INT 3
83952: MINUS
83953: PUSH
83954: LD_INT 2
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: LIST
83961: PUSH
83962: LD_VAR 0 1
83966: PUSH
83967: LD_INT 4
83969: MINUS
83970: PUSH
83971: LD_VAR 0 2
83975: PUSH
83976: LD_INT 1
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: LIST
83983: PUSH
83984: LD_VAR 0 1
83988: PUSH
83989: LD_VAR 0 2
83993: PUSH
83994: LD_INT 3
83996: PLUS
83997: PUSH
83998: LD_INT 0
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: LIST
84005: PUSH
84006: LD_VAR 0 1
84010: PUSH
84011: LD_INT 4
84013: PLUS
84014: PUSH
84015: LD_VAR 0 2
84019: PUSH
84020: LD_INT 4
84022: PLUS
84023: PUSH
84024: LD_INT 5
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: LIST
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: ST_TO_ADDR
// end ; 2 :
84039: GO 84598
84041: LD_INT 2
84043: DOUBLE
84044: EQUAL
84045: IFTRUE 84049
84047: GO 84178
84049: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84050: LD_ADDR_VAR 0 5
84054: PUSH
84055: LD_VAR 0 1
84059: PUSH
84060: LD_VAR 0 2
84064: PUSH
84065: LD_INT 3
84067: MINUS
84068: PUSH
84069: LD_INT 3
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: LIST
84076: PUSH
84077: LD_VAR 0 1
84081: PUSH
84082: LD_INT 4
84084: PLUS
84085: PUSH
84086: LD_VAR 0 2
84090: PUSH
84091: LD_INT 4
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: LIST
84098: PUSH
84099: LD_VAR 0 1
84103: PUSH
84104: LD_VAR 0 2
84108: PUSH
84109: LD_INT 4
84111: PLUS
84112: PUSH
84113: LD_INT 0
84115: PUSH
84116: EMPTY
84117: LIST
84118: LIST
84119: LIST
84120: PUSH
84121: LD_VAR 0 1
84125: PUSH
84126: LD_INT 3
84128: MINUS
84129: PUSH
84130: LD_VAR 0 2
84134: PUSH
84135: LD_INT 1
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: LIST
84142: PUSH
84143: LD_VAR 0 1
84147: PUSH
84148: LD_INT 4
84150: MINUS
84151: PUSH
84152: LD_VAR 0 2
84156: PUSH
84157: LD_INT 4
84159: MINUS
84160: PUSH
84161: LD_INT 2
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: LIST
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: ST_TO_ADDR
// end ; 3 :
84176: GO 84598
84178: LD_INT 3
84180: DOUBLE
84181: EQUAL
84182: IFTRUE 84186
84184: GO 84319
84186: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84187: LD_ADDR_VAR 0 5
84191: PUSH
84192: LD_VAR 0 1
84196: PUSH
84197: LD_INT 3
84199: PLUS
84200: PUSH
84201: LD_VAR 0 2
84205: PUSH
84206: LD_INT 4
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: LIST
84213: PUSH
84214: LD_VAR 0 1
84218: PUSH
84219: LD_INT 4
84221: PLUS
84222: PUSH
84223: LD_VAR 0 2
84227: PUSH
84228: LD_INT 4
84230: PLUS
84231: PUSH
84232: LD_INT 5
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: LIST
84239: PUSH
84240: LD_VAR 0 1
84244: PUSH
84245: LD_INT 4
84247: MINUS
84248: PUSH
84249: LD_VAR 0 2
84253: PUSH
84254: LD_INT 1
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: LIST
84261: PUSH
84262: LD_VAR 0 1
84266: PUSH
84267: LD_VAR 0 2
84271: PUSH
84272: LD_INT 4
84274: MINUS
84275: PUSH
84276: LD_INT 3
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: LIST
84283: PUSH
84284: LD_VAR 0 1
84288: PUSH
84289: LD_INT 3
84291: MINUS
84292: PUSH
84293: LD_VAR 0 2
84297: PUSH
84298: LD_INT 3
84300: MINUS
84301: PUSH
84302: LD_INT 2
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: LIST
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: ST_TO_ADDR
// end ; 4 :
84317: GO 84598
84319: LD_INT 4
84321: DOUBLE
84322: EQUAL
84323: IFTRUE 84327
84325: GO 84460
84327: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84328: LD_ADDR_VAR 0 5
84332: PUSH
84333: LD_VAR 0 1
84337: PUSH
84338: LD_VAR 0 2
84342: PUSH
84343: LD_INT 4
84345: PLUS
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: LIST
84354: PUSH
84355: LD_VAR 0 1
84359: PUSH
84360: LD_INT 3
84362: PLUS
84363: PUSH
84364: LD_VAR 0 2
84368: PUSH
84369: LD_INT 3
84371: PLUS
84372: PUSH
84373: LD_INT 5
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: LIST
84380: PUSH
84381: LD_VAR 0 1
84385: PUSH
84386: LD_INT 4
84388: PLUS
84389: PUSH
84390: LD_VAR 0 2
84394: PUSH
84395: LD_INT 4
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: LIST
84402: PUSH
84403: LD_VAR 0 1
84407: PUSH
84408: LD_VAR 0 2
84412: PUSH
84413: LD_INT 3
84415: MINUS
84416: PUSH
84417: LD_INT 3
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: LIST
84424: PUSH
84425: LD_VAR 0 1
84429: PUSH
84430: LD_INT 4
84432: MINUS
84433: PUSH
84434: LD_VAR 0 2
84438: PUSH
84439: LD_INT 4
84441: MINUS
84442: PUSH
84443: LD_INT 2
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: LIST
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: ST_TO_ADDR
// end ; 5 :
84458: GO 84598
84460: LD_INT 5
84462: DOUBLE
84463: EQUAL
84464: IFTRUE 84468
84466: GO 84597
84468: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84469: LD_ADDR_VAR 0 5
84473: PUSH
84474: LD_VAR 0 1
84478: PUSH
84479: LD_INT 4
84481: MINUS
84482: PUSH
84483: LD_VAR 0 2
84487: PUSH
84488: LD_INT 1
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: LIST
84495: PUSH
84496: LD_VAR 0 1
84500: PUSH
84501: LD_VAR 0 2
84505: PUSH
84506: LD_INT 4
84508: MINUS
84509: PUSH
84510: LD_INT 3
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: LIST
84517: PUSH
84518: LD_VAR 0 1
84522: PUSH
84523: LD_INT 4
84525: PLUS
84526: PUSH
84527: LD_VAR 0 2
84531: PUSH
84532: LD_INT 4
84534: PLUS
84535: PUSH
84536: LD_INT 5
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: LIST
84543: PUSH
84544: LD_VAR 0 1
84548: PUSH
84549: LD_INT 3
84551: PLUS
84552: PUSH
84553: LD_VAR 0 2
84557: PUSH
84558: LD_INT 4
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: LIST
84565: PUSH
84566: LD_VAR 0 1
84570: PUSH
84571: LD_VAR 0 2
84575: PUSH
84576: LD_INT 3
84578: PLUS
84579: PUSH
84580: LD_INT 0
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: LIST
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: ST_TO_ADDR
// end ; end ;
84595: GO 84598
84597: POP
// result := list ;
84598: LD_ADDR_VAR 0 4
84602: PUSH
84603: LD_VAR 0 5
84607: ST_TO_ADDR
// end ;
84608: LD_VAR 0 4
84612: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84613: LD_INT 0
84615: PPUSH
84616: PPUSH
84617: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84618: LD_VAR 0 1
84622: NOT
84623: PUSH
84624: LD_VAR 0 2
84628: PUSH
84629: LD_INT 1
84631: PUSH
84632: LD_INT 2
84634: PUSH
84635: LD_INT 3
84637: PUSH
84638: LD_INT 4
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: IN
84647: NOT
84648: OR
84649: IFFALSE 84653
// exit ;
84651: GO 84745
// tmp := [ ] ;
84653: LD_ADDR_VAR 0 5
84657: PUSH
84658: EMPTY
84659: ST_TO_ADDR
// for i in units do
84660: LD_ADDR_VAR 0 4
84664: PUSH
84665: LD_VAR 0 1
84669: PUSH
84670: FOR_IN
84671: IFFALSE 84714
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
84673: LD_ADDR_VAR 0 5
84677: PUSH
84678: LD_VAR 0 5
84682: PPUSH
84683: LD_VAR 0 5
84687: PUSH
84688: LD_INT 1
84690: PLUS
84691: PPUSH
84692: LD_VAR 0 4
84696: PPUSH
84697: LD_VAR 0 2
84701: PPUSH
84702: CALL_OW 259
84706: PPUSH
84707: CALL_OW 2
84711: ST_TO_ADDR
84712: GO 84670
84714: POP
84715: POP
// if not tmp then
84716: LD_VAR 0 5
84720: NOT
84721: IFFALSE 84725
// exit ;
84723: GO 84745
// result := SortListByListDesc ( units , tmp ) ;
84725: LD_ADDR_VAR 0 3
84729: PUSH
84730: LD_VAR 0 1
84734: PPUSH
84735: LD_VAR 0 5
84739: PPUSH
84740: CALL_OW 77
84744: ST_TO_ADDR
// end ;
84745: LD_VAR 0 3
84749: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84750: LD_INT 0
84752: PPUSH
84753: PPUSH
84754: PPUSH
// result := false ;
84755: LD_ADDR_VAR 0 3
84759: PUSH
84760: LD_INT 0
84762: ST_TO_ADDR
// x := GetX ( building ) ;
84763: LD_ADDR_VAR 0 4
84767: PUSH
84768: LD_VAR 0 2
84772: PPUSH
84773: CALL_OW 250
84777: ST_TO_ADDR
// y := GetY ( building ) ;
84778: LD_ADDR_VAR 0 5
84782: PUSH
84783: LD_VAR 0 2
84787: PPUSH
84788: CALL_OW 251
84792: ST_TO_ADDR
// if not building or not x or not y then
84793: LD_VAR 0 2
84797: NOT
84798: PUSH
84799: LD_VAR 0 4
84803: NOT
84804: OR
84805: PUSH
84806: LD_VAR 0 5
84810: NOT
84811: OR
84812: IFFALSE 84816
// exit ;
84814: GO 84908
// if GetTaskList ( unit ) then
84816: LD_VAR 0 1
84820: PPUSH
84821: CALL_OW 437
84825: IFFALSE 84908
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84827: LD_STRING e
84829: PUSH
84830: LD_VAR 0 1
84834: PPUSH
84835: CALL_OW 437
84839: PUSH
84840: LD_INT 1
84842: ARRAY
84843: PUSH
84844: LD_INT 1
84846: ARRAY
84847: EQUAL
84848: PUSH
84849: LD_VAR 0 4
84853: PUSH
84854: LD_VAR 0 1
84858: PPUSH
84859: CALL_OW 437
84863: PUSH
84864: LD_INT 1
84866: ARRAY
84867: PUSH
84868: LD_INT 2
84870: ARRAY
84871: EQUAL
84872: AND
84873: PUSH
84874: LD_VAR 0 5
84878: PUSH
84879: LD_VAR 0 1
84883: PPUSH
84884: CALL_OW 437
84888: PUSH
84889: LD_INT 1
84891: ARRAY
84892: PUSH
84893: LD_INT 3
84895: ARRAY
84896: EQUAL
84897: AND
84898: IFFALSE 84908
// result := true end ;
84900: LD_ADDR_VAR 0 3
84904: PUSH
84905: LD_INT 1
84907: ST_TO_ADDR
// end ;
84908: LD_VAR 0 3
84912: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84913: LD_INT 0
84915: PPUSH
// result := false ;
84916: LD_ADDR_VAR 0 4
84920: PUSH
84921: LD_INT 0
84923: ST_TO_ADDR
// if GetTaskList ( unit ) then
84924: LD_VAR 0 1
84928: PPUSH
84929: CALL_OW 437
84933: IFFALSE 85016
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84935: LD_STRING M
84937: PUSH
84938: LD_VAR 0 1
84942: PPUSH
84943: CALL_OW 437
84947: PUSH
84948: LD_INT 1
84950: ARRAY
84951: PUSH
84952: LD_INT 1
84954: ARRAY
84955: EQUAL
84956: PUSH
84957: LD_VAR 0 2
84961: PUSH
84962: LD_VAR 0 1
84966: PPUSH
84967: CALL_OW 437
84971: PUSH
84972: LD_INT 1
84974: ARRAY
84975: PUSH
84976: LD_INT 2
84978: ARRAY
84979: EQUAL
84980: AND
84981: PUSH
84982: LD_VAR 0 3
84986: PUSH
84987: LD_VAR 0 1
84991: PPUSH
84992: CALL_OW 437
84996: PUSH
84997: LD_INT 1
84999: ARRAY
85000: PUSH
85001: LD_INT 3
85003: ARRAY
85004: EQUAL
85005: AND
85006: IFFALSE 85016
// result := true ;
85008: LD_ADDR_VAR 0 4
85012: PUSH
85013: LD_INT 1
85015: ST_TO_ADDR
// end ; end ;
85016: LD_VAR 0 4
85020: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85021: LD_INT 0
85023: PPUSH
85024: PPUSH
85025: PPUSH
85026: PPUSH
// if not unit or not area then
85027: LD_VAR 0 1
85031: NOT
85032: PUSH
85033: LD_VAR 0 2
85037: NOT
85038: OR
85039: IFFALSE 85043
// exit ;
85041: GO 85207
// tmp := AreaToList ( area , i ) ;
85043: LD_ADDR_VAR 0 6
85047: PUSH
85048: LD_VAR 0 2
85052: PPUSH
85053: LD_VAR 0 5
85057: PPUSH
85058: CALL_OW 517
85062: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85063: LD_ADDR_VAR 0 5
85067: PUSH
85068: DOUBLE
85069: LD_INT 1
85071: DEC
85072: ST_TO_ADDR
85073: LD_VAR 0 6
85077: PUSH
85078: LD_INT 1
85080: ARRAY
85081: PUSH
85082: FOR_TO
85083: IFFALSE 85205
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85085: LD_ADDR_VAR 0 7
85089: PUSH
85090: LD_VAR 0 6
85094: PUSH
85095: LD_INT 1
85097: ARRAY
85098: PUSH
85099: LD_VAR 0 5
85103: ARRAY
85104: PUSH
85105: LD_VAR 0 6
85109: PUSH
85110: LD_INT 2
85112: ARRAY
85113: PUSH
85114: LD_VAR 0 5
85118: ARRAY
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85124: LD_VAR 0 7
85128: PUSH
85129: LD_INT 1
85131: ARRAY
85132: PPUSH
85133: LD_VAR 0 7
85137: PUSH
85138: LD_INT 2
85140: ARRAY
85141: PPUSH
85142: CALL_OW 428
85146: PUSH
85147: LD_INT 0
85149: EQUAL
85150: IFFALSE 85203
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85152: LD_VAR 0 1
85156: PPUSH
85157: LD_VAR 0 7
85161: PUSH
85162: LD_INT 1
85164: ARRAY
85165: PPUSH
85166: LD_VAR 0 7
85170: PUSH
85171: LD_INT 2
85173: ARRAY
85174: PPUSH
85175: LD_VAR 0 3
85179: PPUSH
85180: CALL_OW 48
// result := IsPlaced ( unit ) ;
85184: LD_ADDR_VAR 0 4
85188: PUSH
85189: LD_VAR 0 1
85193: PPUSH
85194: CALL_OW 305
85198: ST_TO_ADDR
// exit ;
85199: POP
85200: POP
85201: GO 85207
// end ; end ;
85203: GO 85082
85205: POP
85206: POP
// end ;
85207: LD_VAR 0 4
85211: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85212: LD_INT 0
85214: PPUSH
85215: PPUSH
85216: PPUSH
// if not side or side > 8 then
85217: LD_VAR 0 1
85221: NOT
85222: PUSH
85223: LD_VAR 0 1
85227: PUSH
85228: LD_INT 8
85230: GREATER
85231: OR
85232: IFFALSE 85236
// exit ;
85234: GO 85423
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85236: LD_ADDR_VAR 0 4
85240: PUSH
85241: LD_INT 22
85243: PUSH
85244: LD_VAR 0 1
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 21
85255: PUSH
85256: LD_INT 3
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PPUSH
85267: CALL_OW 69
85271: ST_TO_ADDR
// if not tmp then
85272: LD_VAR 0 4
85276: NOT
85277: IFFALSE 85281
// exit ;
85279: GO 85423
// enable_addtolog := true ;
85281: LD_ADDR_OWVAR 81
85285: PUSH
85286: LD_INT 1
85288: ST_TO_ADDR
// AddToLog ( [ ) ;
85289: LD_STRING [
85291: PPUSH
85292: CALL_OW 561
// for i in tmp do
85296: LD_ADDR_VAR 0 3
85300: PUSH
85301: LD_VAR 0 4
85305: PUSH
85306: FOR_IN
85307: IFFALSE 85414
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85309: LD_STRING [
85311: PUSH
85312: LD_VAR 0 3
85316: PPUSH
85317: CALL_OW 266
85321: STR
85322: PUSH
85323: LD_STRING , 
85325: STR
85326: PUSH
85327: LD_VAR 0 3
85331: PPUSH
85332: CALL_OW 250
85336: STR
85337: PUSH
85338: LD_STRING , 
85340: STR
85341: PUSH
85342: LD_VAR 0 3
85346: PPUSH
85347: CALL_OW 251
85351: STR
85352: PUSH
85353: LD_STRING , 
85355: STR
85356: PUSH
85357: LD_VAR 0 3
85361: PPUSH
85362: CALL_OW 254
85366: STR
85367: PUSH
85368: LD_STRING , 
85370: STR
85371: PUSH
85372: LD_VAR 0 3
85376: PPUSH
85377: LD_INT 1
85379: PPUSH
85380: CALL_OW 268
85384: STR
85385: PUSH
85386: LD_STRING , 
85388: STR
85389: PUSH
85390: LD_VAR 0 3
85394: PPUSH
85395: LD_INT 2
85397: PPUSH
85398: CALL_OW 268
85402: STR
85403: PUSH
85404: LD_STRING ],
85406: STR
85407: PPUSH
85408: CALL_OW 561
// end ;
85412: GO 85306
85414: POP
85415: POP
// AddToLog ( ]; ) ;
85416: LD_STRING ];
85418: PPUSH
85419: CALL_OW 561
// end ;
85423: LD_VAR 0 2
85427: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85428: LD_INT 0
85430: PPUSH
85431: PPUSH
85432: PPUSH
85433: PPUSH
85434: PPUSH
// if not area or not rate or not max then
85435: LD_VAR 0 1
85439: NOT
85440: PUSH
85441: LD_VAR 0 2
85445: NOT
85446: OR
85447: PUSH
85448: LD_VAR 0 4
85452: NOT
85453: OR
85454: IFFALSE 85458
// exit ;
85456: GO 85647
// while 1 do
85458: LD_INT 1
85460: IFFALSE 85647
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85462: LD_ADDR_VAR 0 9
85466: PUSH
85467: LD_VAR 0 1
85471: PPUSH
85472: LD_INT 1
85474: PPUSH
85475: CALL_OW 287
85479: PUSH
85480: LD_INT 10
85482: MUL
85483: ST_TO_ADDR
// r := rate / 10 ;
85484: LD_ADDR_VAR 0 7
85488: PUSH
85489: LD_VAR 0 2
85493: PUSH
85494: LD_INT 10
85496: DIVREAL
85497: ST_TO_ADDR
// time := 1 1$00 ;
85498: LD_ADDR_VAR 0 8
85502: PUSH
85503: LD_INT 2100
85505: ST_TO_ADDR
// if amount < min then
85506: LD_VAR 0 9
85510: PUSH
85511: LD_VAR 0 3
85515: LESS
85516: IFFALSE 85534
// r := r * 2 else
85518: LD_ADDR_VAR 0 7
85522: PUSH
85523: LD_VAR 0 7
85527: PUSH
85528: LD_INT 2
85530: MUL
85531: ST_TO_ADDR
85532: GO 85560
// if amount > max then
85534: LD_VAR 0 9
85538: PUSH
85539: LD_VAR 0 4
85543: GREATER
85544: IFFALSE 85560
// r := r / 2 ;
85546: LD_ADDR_VAR 0 7
85550: PUSH
85551: LD_VAR 0 7
85555: PUSH
85556: LD_INT 2
85558: DIVREAL
85559: ST_TO_ADDR
// time := time / r ;
85560: LD_ADDR_VAR 0 8
85564: PUSH
85565: LD_VAR 0 8
85569: PUSH
85570: LD_VAR 0 7
85574: DIVREAL
85575: ST_TO_ADDR
// if time < 0 then
85576: LD_VAR 0 8
85580: PUSH
85581: LD_INT 0
85583: LESS
85584: IFFALSE 85601
// time := time * - 1 ;
85586: LD_ADDR_VAR 0 8
85590: PUSH
85591: LD_VAR 0 8
85595: PUSH
85596: LD_INT 1
85598: NEG
85599: MUL
85600: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85601: LD_VAR 0 8
85605: PUSH
85606: LD_INT 35
85608: PPUSH
85609: LD_INT 875
85611: PPUSH
85612: CALL_OW 12
85616: PLUS
85617: PPUSH
85618: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85622: LD_INT 1
85624: PPUSH
85625: LD_INT 5
85627: PPUSH
85628: CALL_OW 12
85632: PPUSH
85633: LD_VAR 0 1
85637: PPUSH
85638: LD_INT 1
85640: PPUSH
85641: CALL_OW 55
// end ;
85645: GO 85458
// end ;
85647: LD_VAR 0 5
85651: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85652: LD_INT 0
85654: PPUSH
85655: PPUSH
85656: PPUSH
85657: PPUSH
85658: PPUSH
85659: PPUSH
85660: PPUSH
85661: PPUSH
// if not turrets or not factories then
85662: LD_VAR 0 1
85666: NOT
85667: PUSH
85668: LD_VAR 0 2
85672: NOT
85673: OR
85674: IFFALSE 85678
// exit ;
85676: GO 85985
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85678: LD_ADDR_VAR 0 10
85682: PUSH
85683: LD_INT 5
85685: PUSH
85686: LD_INT 6
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 2
85695: PUSH
85696: LD_INT 4
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 3
85705: PUSH
85706: LD_INT 5
85708: PUSH
85709: EMPTY
85710: LIST
85711: LIST
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 24
85720: PUSH
85721: LD_INT 25
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: PUSH
85728: LD_INT 23
85730: PUSH
85731: LD_INT 27
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 42
85744: PUSH
85745: LD_INT 43
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 44
85754: PUSH
85755: LD_INT 46
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 45
85764: PUSH
85765: LD_INT 47
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: LIST
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: LIST
85781: ST_TO_ADDR
// result := [ ] ;
85782: LD_ADDR_VAR 0 3
85786: PUSH
85787: EMPTY
85788: ST_TO_ADDR
// for i in turrets do
85789: LD_ADDR_VAR 0 4
85793: PUSH
85794: LD_VAR 0 1
85798: PUSH
85799: FOR_IN
85800: IFFALSE 85983
// begin nat := GetNation ( i ) ;
85802: LD_ADDR_VAR 0 7
85806: PUSH
85807: LD_VAR 0 4
85811: PPUSH
85812: CALL_OW 248
85816: ST_TO_ADDR
// weapon := 0 ;
85817: LD_ADDR_VAR 0 8
85821: PUSH
85822: LD_INT 0
85824: ST_TO_ADDR
// if not nat then
85825: LD_VAR 0 7
85829: NOT
85830: IFFALSE 85834
// continue ;
85832: GO 85799
// for j in list [ nat ] do
85834: LD_ADDR_VAR 0 5
85838: PUSH
85839: LD_VAR 0 10
85843: PUSH
85844: LD_VAR 0 7
85848: ARRAY
85849: PUSH
85850: FOR_IN
85851: IFFALSE 85892
// if GetBWeapon ( i ) = j [ 1 ] then
85853: LD_VAR 0 4
85857: PPUSH
85858: CALL_OW 269
85862: PUSH
85863: LD_VAR 0 5
85867: PUSH
85868: LD_INT 1
85870: ARRAY
85871: EQUAL
85872: IFFALSE 85890
// begin weapon := j [ 2 ] ;
85874: LD_ADDR_VAR 0 8
85878: PUSH
85879: LD_VAR 0 5
85883: PUSH
85884: LD_INT 2
85886: ARRAY
85887: ST_TO_ADDR
// break ;
85888: GO 85892
// end ;
85890: GO 85850
85892: POP
85893: POP
// if not weapon then
85894: LD_VAR 0 8
85898: NOT
85899: IFFALSE 85903
// continue ;
85901: GO 85799
// for k in factories do
85903: LD_ADDR_VAR 0 6
85907: PUSH
85908: LD_VAR 0 2
85912: PUSH
85913: FOR_IN
85914: IFFALSE 85979
// begin weapons := AvailableWeaponList ( k ) ;
85916: LD_ADDR_VAR 0 9
85920: PUSH
85921: LD_VAR 0 6
85925: PPUSH
85926: CALL_OW 478
85930: ST_TO_ADDR
// if not weapons then
85931: LD_VAR 0 9
85935: NOT
85936: IFFALSE 85940
// continue ;
85938: GO 85913
// if weapon in weapons then
85940: LD_VAR 0 8
85944: PUSH
85945: LD_VAR 0 9
85949: IN
85950: IFFALSE 85977
// begin result := [ i , weapon ] ;
85952: LD_ADDR_VAR 0 3
85956: PUSH
85957: LD_VAR 0 4
85961: PUSH
85962: LD_VAR 0 8
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: ST_TO_ADDR
// exit ;
85971: POP
85972: POP
85973: POP
85974: POP
85975: GO 85985
// end ; end ;
85977: GO 85913
85979: POP
85980: POP
// end ;
85981: GO 85799
85983: POP
85984: POP
// end ;
85985: LD_VAR 0 3
85989: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85990: LD_INT 0
85992: PPUSH
// if not side or side > 8 then
85993: LD_VAR 0 3
85997: NOT
85998: PUSH
85999: LD_VAR 0 3
86003: PUSH
86004: LD_INT 8
86006: GREATER
86007: OR
86008: IFFALSE 86012
// exit ;
86010: GO 86071
// if not range then
86012: LD_VAR 0 4
86016: NOT
86017: IFFALSE 86028
// range := - 12 ;
86019: LD_ADDR_VAR 0 4
86023: PUSH
86024: LD_INT 12
86026: NEG
86027: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86028: LD_VAR 0 1
86032: PPUSH
86033: LD_VAR 0 2
86037: PPUSH
86038: LD_VAR 0 3
86042: PPUSH
86043: LD_VAR 0 4
86047: PPUSH
86048: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86052: LD_VAR 0 1
86056: PPUSH
86057: LD_VAR 0 2
86061: PPUSH
86062: LD_VAR 0 3
86066: PPUSH
86067: CALL_OW 331
// end ;
86071: LD_VAR 0 5
86075: RET
// export function Video ( mode ) ; begin
86076: LD_INT 0
86078: PPUSH
// ingame_video = mode ;
86079: LD_ADDR_OWVAR 52
86083: PUSH
86084: LD_VAR 0 1
86088: ST_TO_ADDR
// interface_hidden = mode ;
86089: LD_ADDR_OWVAR 54
86093: PUSH
86094: LD_VAR 0 1
86098: ST_TO_ADDR
// end ;
86099: LD_VAR 0 2
86103: RET
// export function Join ( array , element ) ; begin
86104: LD_INT 0
86106: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86107: LD_ADDR_VAR 0 3
86111: PUSH
86112: LD_VAR 0 1
86116: PPUSH
86117: LD_VAR 0 1
86121: PUSH
86122: LD_INT 1
86124: PLUS
86125: PPUSH
86126: LD_VAR 0 2
86130: PPUSH
86131: CALL_OW 1
86135: ST_TO_ADDR
// end ;
86136: LD_VAR 0 3
86140: RET
// export function JoinUnion ( array , element ) ; begin
86141: LD_INT 0
86143: PPUSH
// result := array union element ;
86144: LD_ADDR_VAR 0 3
86148: PUSH
86149: LD_VAR 0 1
86153: PUSH
86154: LD_VAR 0 2
86158: UNION
86159: ST_TO_ADDR
// end ;
86160: LD_VAR 0 3
86164: RET
// export function GetBehemoths ( side ) ; begin
86165: LD_INT 0
86167: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86168: LD_ADDR_VAR 0 2
86172: PUSH
86173: LD_INT 22
86175: PUSH
86176: LD_VAR 0 1
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: LD_INT 31
86187: PUSH
86188: LD_INT 25
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PPUSH
86199: CALL_OW 69
86203: ST_TO_ADDR
// end ;
86204: LD_VAR 0 2
86208: RET
// export function Shuffle ( array ) ; var i , index ; begin
86209: LD_INT 0
86211: PPUSH
86212: PPUSH
86213: PPUSH
// result := [ ] ;
86214: LD_ADDR_VAR 0 2
86218: PUSH
86219: EMPTY
86220: ST_TO_ADDR
// if not array then
86221: LD_VAR 0 1
86225: NOT
86226: IFFALSE 86230
// exit ;
86228: GO 86329
// Randomize ;
86230: CALL_OW 10
// for i = array downto 1 do
86234: LD_ADDR_VAR 0 3
86238: PUSH
86239: DOUBLE
86240: LD_VAR 0 1
86244: INC
86245: ST_TO_ADDR
86246: LD_INT 1
86248: PUSH
86249: FOR_DOWNTO
86250: IFFALSE 86327
// begin index := rand ( 1 , array ) ;
86252: LD_ADDR_VAR 0 4
86256: PUSH
86257: LD_INT 1
86259: PPUSH
86260: LD_VAR 0 1
86264: PPUSH
86265: CALL_OW 12
86269: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86270: LD_ADDR_VAR 0 2
86274: PUSH
86275: LD_VAR 0 2
86279: PPUSH
86280: LD_VAR 0 2
86284: PUSH
86285: LD_INT 1
86287: PLUS
86288: PPUSH
86289: LD_VAR 0 1
86293: PUSH
86294: LD_VAR 0 4
86298: ARRAY
86299: PPUSH
86300: CALL_OW 2
86304: ST_TO_ADDR
// array := Delete ( array , index ) ;
86305: LD_ADDR_VAR 0 1
86309: PUSH
86310: LD_VAR 0 1
86314: PPUSH
86315: LD_VAR 0 4
86319: PPUSH
86320: CALL_OW 3
86324: ST_TO_ADDR
// end ;
86325: GO 86249
86327: POP
86328: POP
// end ;
86329: LD_VAR 0 2
86333: RET
// export function GetBaseMaterials ( base ) ; begin
86334: LD_INT 0
86336: PPUSH
// result := [ 0 , 0 , 0 ] ;
86337: LD_ADDR_VAR 0 2
86341: PUSH
86342: LD_INT 0
86344: PUSH
86345: LD_INT 0
86347: PUSH
86348: LD_INT 0
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: LIST
86355: ST_TO_ADDR
// if not base then
86356: LD_VAR 0 1
86360: NOT
86361: IFFALSE 86365
// exit ;
86363: GO 86414
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86365: LD_ADDR_VAR 0 2
86369: PUSH
86370: LD_VAR 0 1
86374: PPUSH
86375: LD_INT 1
86377: PPUSH
86378: CALL_OW 275
86382: PUSH
86383: LD_VAR 0 1
86387: PPUSH
86388: LD_INT 2
86390: PPUSH
86391: CALL_OW 275
86395: PUSH
86396: LD_VAR 0 1
86400: PPUSH
86401: LD_INT 3
86403: PPUSH
86404: CALL_OW 275
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: LIST
86413: ST_TO_ADDR
// end ;
86414: LD_VAR 0 2
86418: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86419: LD_INT 0
86421: PPUSH
86422: PPUSH
// result := array ;
86423: LD_ADDR_VAR 0 3
86427: PUSH
86428: LD_VAR 0 1
86432: ST_TO_ADDR
// if size >= result then
86433: LD_VAR 0 2
86437: PUSH
86438: LD_VAR 0 3
86442: GREATEREQUAL
86443: IFFALSE 86447
// exit ;
86445: GO 86497
// if size then
86447: LD_VAR 0 2
86451: IFFALSE 86497
// for i := array downto size do
86453: LD_ADDR_VAR 0 4
86457: PUSH
86458: DOUBLE
86459: LD_VAR 0 1
86463: INC
86464: ST_TO_ADDR
86465: LD_VAR 0 2
86469: PUSH
86470: FOR_DOWNTO
86471: IFFALSE 86495
// result := Delete ( result , result ) ;
86473: LD_ADDR_VAR 0 3
86477: PUSH
86478: LD_VAR 0 3
86482: PPUSH
86483: LD_VAR 0 3
86487: PPUSH
86488: CALL_OW 3
86492: ST_TO_ADDR
86493: GO 86470
86495: POP
86496: POP
// end ;
86497: LD_VAR 0 3
86501: RET
// export function ComExit ( unit ) ; var tmp ; begin
86502: LD_INT 0
86504: PPUSH
86505: PPUSH
// if not IsInUnit ( unit ) then
86506: LD_VAR 0 1
86510: PPUSH
86511: CALL_OW 310
86515: NOT
86516: IFFALSE 86520
// exit ;
86518: GO 86580
// tmp := IsInUnit ( unit ) ;
86520: LD_ADDR_VAR 0 3
86524: PUSH
86525: LD_VAR 0 1
86529: PPUSH
86530: CALL_OW 310
86534: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86535: LD_VAR 0 3
86539: PPUSH
86540: CALL_OW 247
86544: PUSH
86545: LD_INT 2
86547: EQUAL
86548: IFFALSE 86561
// ComExitVehicle ( unit ) else
86550: LD_VAR 0 1
86554: PPUSH
86555: CALL_OW 121
86559: GO 86570
// ComExitBuilding ( unit ) ;
86561: LD_VAR 0 1
86565: PPUSH
86566: CALL_OW 122
// result := tmp ;
86570: LD_ADDR_VAR 0 2
86574: PUSH
86575: LD_VAR 0 3
86579: ST_TO_ADDR
// end ;
86580: LD_VAR 0 2
86584: RET
// export function ComExitAll ( units ) ; var i ; begin
86585: LD_INT 0
86587: PPUSH
86588: PPUSH
// if not units then
86589: LD_VAR 0 1
86593: NOT
86594: IFFALSE 86598
// exit ;
86596: GO 86624
// for i in units do
86598: LD_ADDR_VAR 0 3
86602: PUSH
86603: LD_VAR 0 1
86607: PUSH
86608: FOR_IN
86609: IFFALSE 86622
// ComExit ( i ) ;
86611: LD_VAR 0 3
86615: PPUSH
86616: CALL 86502 0 1
86620: GO 86608
86622: POP
86623: POP
// end ;
86624: LD_VAR 0 2
86628: RET
// export function ResetHc ; begin
86629: LD_INT 0
86631: PPUSH
// InitHc ;
86632: CALL_OW 19
// hc_importance := 0 ;
86636: LD_ADDR_OWVAR 32
86640: PUSH
86641: LD_INT 0
86643: ST_TO_ADDR
// end ;
86644: LD_VAR 0 1
86648: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86649: LD_INT 0
86651: PPUSH
86652: PPUSH
86653: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86654: LD_ADDR_VAR 0 6
86658: PUSH
86659: LD_VAR 0 1
86663: PUSH
86664: LD_VAR 0 3
86668: PLUS
86669: PUSH
86670: LD_INT 2
86672: DIV
86673: ST_TO_ADDR
// if _x < 0 then
86674: LD_VAR 0 6
86678: PUSH
86679: LD_INT 0
86681: LESS
86682: IFFALSE 86699
// _x := _x * - 1 ;
86684: LD_ADDR_VAR 0 6
86688: PUSH
86689: LD_VAR 0 6
86693: PUSH
86694: LD_INT 1
86696: NEG
86697: MUL
86698: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86699: LD_ADDR_VAR 0 7
86703: PUSH
86704: LD_VAR 0 2
86708: PUSH
86709: LD_VAR 0 4
86713: PLUS
86714: PUSH
86715: LD_INT 2
86717: DIV
86718: ST_TO_ADDR
// if _y < 0 then
86719: LD_VAR 0 7
86723: PUSH
86724: LD_INT 0
86726: LESS
86727: IFFALSE 86744
// _y := _y * - 1 ;
86729: LD_ADDR_VAR 0 7
86733: PUSH
86734: LD_VAR 0 7
86738: PUSH
86739: LD_INT 1
86741: NEG
86742: MUL
86743: ST_TO_ADDR
// result := [ _x , _y ] ;
86744: LD_ADDR_VAR 0 5
86748: PUSH
86749: LD_VAR 0 6
86753: PUSH
86754: LD_VAR 0 7
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: ST_TO_ADDR
// end ;
86763: LD_VAR 0 5
86767: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
86768: LD_INT 0
86770: PPUSH
86771: PPUSH
86772: PPUSH
86773: PPUSH
// task := GetTaskList ( unit ) ;
86774: LD_ADDR_VAR 0 7
86778: PUSH
86779: LD_VAR 0 1
86783: PPUSH
86784: CALL_OW 437
86788: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
86789: LD_VAR 0 7
86793: NOT
86794: PUSH
86795: LD_VAR 0 1
86799: PPUSH
86800: LD_VAR 0 2
86804: PPUSH
86805: CALL_OW 308
86809: NOT
86810: AND
86811: IFFALSE 86815
// exit ;
86813: GO 86933
// if IsInArea ( unit , area ) then
86815: LD_VAR 0 1
86819: PPUSH
86820: LD_VAR 0 2
86824: PPUSH
86825: CALL_OW 308
86829: IFFALSE 86847
// begin ComMoveToArea ( unit , goAway ) ;
86831: LD_VAR 0 1
86835: PPUSH
86836: LD_VAR 0 3
86840: PPUSH
86841: CALL_OW 113
// exit ;
86845: GO 86933
// end ; if task [ 1 ] [ 1 ] <> M then
86847: LD_VAR 0 7
86851: PUSH
86852: LD_INT 1
86854: ARRAY
86855: PUSH
86856: LD_INT 1
86858: ARRAY
86859: PUSH
86860: LD_STRING M
86862: NONEQUAL
86863: IFFALSE 86867
// exit ;
86865: GO 86933
// x := task [ 1 ] [ 2 ] ;
86867: LD_ADDR_VAR 0 5
86871: PUSH
86872: LD_VAR 0 7
86876: PUSH
86877: LD_INT 1
86879: ARRAY
86880: PUSH
86881: LD_INT 2
86883: ARRAY
86884: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86885: LD_ADDR_VAR 0 6
86889: PUSH
86890: LD_VAR 0 7
86894: PUSH
86895: LD_INT 1
86897: ARRAY
86898: PUSH
86899: LD_INT 3
86901: ARRAY
86902: ST_TO_ADDR
// if InArea ( x , y , area ) then
86903: LD_VAR 0 5
86907: PPUSH
86908: LD_VAR 0 6
86912: PPUSH
86913: LD_VAR 0 2
86917: PPUSH
86918: CALL_OW 309
86922: IFFALSE 86933
// ComStop ( unit ) ;
86924: LD_VAR 0 1
86928: PPUSH
86929: CALL_OW 141
// end ;
86933: LD_VAR 0 4
86937: RET
// export function Abs ( value ) ; begin
86938: LD_INT 0
86940: PPUSH
// result := value ;
86941: LD_ADDR_VAR 0 2
86945: PUSH
86946: LD_VAR 0 1
86950: ST_TO_ADDR
// if value < 0 then
86951: LD_VAR 0 1
86955: PUSH
86956: LD_INT 0
86958: LESS
86959: IFFALSE 86976
// result := value * - 1 ;
86961: LD_ADDR_VAR 0 2
86965: PUSH
86966: LD_VAR 0 1
86970: PUSH
86971: LD_INT 1
86973: NEG
86974: MUL
86975: ST_TO_ADDR
// end ;
86976: LD_VAR 0 2
86980: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86981: LD_INT 0
86983: PPUSH
86984: PPUSH
86985: PPUSH
86986: PPUSH
86987: PPUSH
86988: PPUSH
86989: PPUSH
86990: PPUSH
// if not unit or not building then
86991: LD_VAR 0 1
86995: NOT
86996: PUSH
86997: LD_VAR 0 2
87001: NOT
87002: OR
87003: IFFALSE 87007
// exit ;
87005: GO 87233
// x := GetX ( building ) ;
87007: LD_ADDR_VAR 0 4
87011: PUSH
87012: LD_VAR 0 2
87016: PPUSH
87017: CALL_OW 250
87021: ST_TO_ADDR
// y := GetY ( building ) ;
87022: LD_ADDR_VAR 0 6
87026: PUSH
87027: LD_VAR 0 2
87031: PPUSH
87032: CALL_OW 251
87036: ST_TO_ADDR
// d := GetDir ( building ) ;
87037: LD_ADDR_VAR 0 8
87041: PUSH
87042: LD_VAR 0 2
87046: PPUSH
87047: CALL_OW 254
87051: ST_TO_ADDR
// r := 4 ;
87052: LD_ADDR_VAR 0 9
87056: PUSH
87057: LD_INT 4
87059: ST_TO_ADDR
// for i := 1 to 5 do
87060: LD_ADDR_VAR 0 10
87064: PUSH
87065: DOUBLE
87066: LD_INT 1
87068: DEC
87069: ST_TO_ADDR
87070: LD_INT 5
87072: PUSH
87073: FOR_TO
87074: IFFALSE 87231
// begin _x := ShiftX ( x , d , r + i ) ;
87076: LD_ADDR_VAR 0 5
87080: PUSH
87081: LD_VAR 0 4
87085: PPUSH
87086: LD_VAR 0 8
87090: PPUSH
87091: LD_VAR 0 9
87095: PUSH
87096: LD_VAR 0 10
87100: PLUS
87101: PPUSH
87102: CALL_OW 272
87106: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87107: LD_ADDR_VAR 0 7
87111: PUSH
87112: LD_VAR 0 6
87116: PPUSH
87117: LD_VAR 0 8
87121: PPUSH
87122: LD_VAR 0 9
87126: PUSH
87127: LD_VAR 0 10
87131: PLUS
87132: PPUSH
87133: CALL_OW 273
87137: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87138: LD_VAR 0 5
87142: PPUSH
87143: LD_VAR 0 7
87147: PPUSH
87148: CALL_OW 488
87152: PUSH
87153: LD_VAR 0 5
87157: PPUSH
87158: LD_VAR 0 7
87162: PPUSH
87163: CALL_OW 428
87167: PPUSH
87168: CALL_OW 247
87172: PUSH
87173: LD_INT 3
87175: PUSH
87176: LD_INT 2
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: IN
87183: NOT
87184: AND
87185: IFFALSE 87229
// begin ComMoveXY ( unit , _x , _y ) ;
87187: LD_VAR 0 1
87191: PPUSH
87192: LD_VAR 0 5
87196: PPUSH
87197: LD_VAR 0 7
87201: PPUSH
87202: CALL_OW 111
// result := [ _x , _y ] ;
87206: LD_ADDR_VAR 0 3
87210: PUSH
87211: LD_VAR 0 5
87215: PUSH
87216: LD_VAR 0 7
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: ST_TO_ADDR
// exit ;
87225: POP
87226: POP
87227: GO 87233
// end ; end ;
87229: GO 87073
87231: POP
87232: POP
// end ;
87233: LD_VAR 0 3
87237: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87238: LD_INT 0
87240: PPUSH
87241: PPUSH
87242: PPUSH
// result := 0 ;
87243: LD_ADDR_VAR 0 3
87247: PUSH
87248: LD_INT 0
87250: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87251: LD_VAR 0 1
87255: PUSH
87256: LD_INT 0
87258: LESS
87259: PUSH
87260: LD_VAR 0 1
87264: PUSH
87265: LD_INT 8
87267: GREATER
87268: OR
87269: PUSH
87270: LD_VAR 0 2
87274: PUSH
87275: LD_INT 0
87277: LESS
87278: OR
87279: PUSH
87280: LD_VAR 0 2
87284: PUSH
87285: LD_INT 8
87287: GREATER
87288: OR
87289: IFFALSE 87293
// exit ;
87291: GO 87368
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87293: LD_ADDR_VAR 0 4
87297: PUSH
87298: LD_INT 22
87300: PUSH
87301: LD_VAR 0 2
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PPUSH
87310: CALL_OW 69
87314: PUSH
87315: FOR_IN
87316: IFFALSE 87366
// begin un := UnitShoot ( i ) ;
87318: LD_ADDR_VAR 0 5
87322: PUSH
87323: LD_VAR 0 4
87327: PPUSH
87328: CALL_OW 504
87332: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87333: LD_VAR 0 5
87337: PPUSH
87338: CALL_OW 255
87342: PUSH
87343: LD_VAR 0 1
87347: EQUAL
87348: IFFALSE 87364
// begin result := un ;
87350: LD_ADDR_VAR 0 3
87354: PUSH
87355: LD_VAR 0 5
87359: ST_TO_ADDR
// exit ;
87360: POP
87361: POP
87362: GO 87368
// end ; end ;
87364: GO 87315
87366: POP
87367: POP
// end ;
87368: LD_VAR 0 3
87372: RET
// export function GetCargoBay ( units ) ; begin
87373: LD_INT 0
87375: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87376: LD_ADDR_VAR 0 2
87380: PUSH
87381: LD_VAR 0 1
87385: PPUSH
87386: LD_INT 2
87388: PUSH
87389: LD_INT 34
87391: PUSH
87392: LD_INT 12
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PUSH
87399: LD_INT 34
87401: PUSH
87402: LD_INT 51
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: PUSH
87409: LD_INT 34
87411: PUSH
87412: LD_INT 32
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 34
87421: PUSH
87422: LD_INT 89
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: PPUSH
87436: CALL_OW 72
87440: ST_TO_ADDR
// end ;
87441: LD_VAR 0 2
87445: RET
// export function Negate ( value ) ; begin
87446: LD_INT 0
87448: PPUSH
// result := not value ;
87449: LD_ADDR_VAR 0 2
87453: PUSH
87454: LD_VAR 0 1
87458: NOT
87459: ST_TO_ADDR
// end ;
87460: LD_VAR 0 2
87464: RET
// export function Inc ( value ) ; begin
87465: LD_INT 0
87467: PPUSH
// result := value + 1 ;
87468: LD_ADDR_VAR 0 2
87472: PUSH
87473: LD_VAR 0 1
87477: PUSH
87478: LD_INT 1
87480: PLUS
87481: ST_TO_ADDR
// end ;
87482: LD_VAR 0 2
87486: RET
// export function Dec ( value ) ; begin
87487: LD_INT 0
87489: PPUSH
// result := value - 1 ;
87490: LD_ADDR_VAR 0 2
87494: PUSH
87495: LD_VAR 0 1
87499: PUSH
87500: LD_INT 1
87502: MINUS
87503: ST_TO_ADDR
// end ;
87504: LD_VAR 0 2
87508: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87509: LD_INT 0
87511: PPUSH
87512: PPUSH
87513: PPUSH
87514: PPUSH
87515: PPUSH
87516: PPUSH
87517: PPUSH
87518: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87519: LD_VAR 0 1
87523: PPUSH
87524: LD_VAR 0 2
87528: PPUSH
87529: CALL_OW 488
87533: NOT
87534: PUSH
87535: LD_VAR 0 3
87539: PPUSH
87540: LD_VAR 0 4
87544: PPUSH
87545: CALL_OW 488
87549: NOT
87550: OR
87551: IFFALSE 87564
// begin result := - 1 ;
87553: LD_ADDR_VAR 0 5
87557: PUSH
87558: LD_INT 1
87560: NEG
87561: ST_TO_ADDR
// exit ;
87562: GO 87799
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87564: LD_ADDR_VAR 0 12
87568: PUSH
87569: LD_VAR 0 1
87573: PPUSH
87574: LD_VAR 0 2
87578: PPUSH
87579: LD_VAR 0 3
87583: PPUSH
87584: LD_VAR 0 4
87588: PPUSH
87589: CALL 86649 0 4
87593: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87594: LD_ADDR_VAR 0 11
87598: PUSH
87599: LD_VAR 0 1
87603: PPUSH
87604: LD_VAR 0 2
87608: PPUSH
87609: LD_VAR 0 12
87613: PUSH
87614: LD_INT 1
87616: ARRAY
87617: PPUSH
87618: LD_VAR 0 12
87622: PUSH
87623: LD_INT 2
87625: ARRAY
87626: PPUSH
87627: CALL_OW 298
87631: ST_TO_ADDR
// distance := 9999 ;
87632: LD_ADDR_VAR 0 10
87636: PUSH
87637: LD_INT 9999
87639: ST_TO_ADDR
// for i := 0 to 5 do
87640: LD_ADDR_VAR 0 6
87644: PUSH
87645: DOUBLE
87646: LD_INT 0
87648: DEC
87649: ST_TO_ADDR
87650: LD_INT 5
87652: PUSH
87653: FOR_TO
87654: IFFALSE 87797
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87656: LD_ADDR_VAR 0 7
87660: PUSH
87661: LD_VAR 0 1
87665: PPUSH
87666: LD_VAR 0 6
87670: PPUSH
87671: LD_VAR 0 11
87675: PPUSH
87676: CALL_OW 272
87680: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87681: LD_ADDR_VAR 0 8
87685: PUSH
87686: LD_VAR 0 2
87690: PPUSH
87691: LD_VAR 0 6
87695: PPUSH
87696: LD_VAR 0 11
87700: PPUSH
87701: CALL_OW 273
87705: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87706: LD_VAR 0 7
87710: PPUSH
87711: LD_VAR 0 8
87715: PPUSH
87716: CALL_OW 488
87720: NOT
87721: IFFALSE 87725
// continue ;
87723: GO 87653
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87725: LD_ADDR_VAR 0 9
87729: PUSH
87730: LD_VAR 0 12
87734: PUSH
87735: LD_INT 1
87737: ARRAY
87738: PPUSH
87739: LD_VAR 0 12
87743: PUSH
87744: LD_INT 2
87746: ARRAY
87747: PPUSH
87748: LD_VAR 0 7
87752: PPUSH
87753: LD_VAR 0 8
87757: PPUSH
87758: CALL_OW 298
87762: ST_TO_ADDR
// if tmp < distance then
87763: LD_VAR 0 9
87767: PUSH
87768: LD_VAR 0 10
87772: LESS
87773: IFFALSE 87795
// begin result := i ;
87775: LD_ADDR_VAR 0 5
87779: PUSH
87780: LD_VAR 0 6
87784: ST_TO_ADDR
// distance := tmp ;
87785: LD_ADDR_VAR 0 10
87789: PUSH
87790: LD_VAR 0 9
87794: ST_TO_ADDR
// end ; end ;
87795: GO 87653
87797: POP
87798: POP
// end ;
87799: LD_VAR 0 5
87803: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87804: LD_INT 0
87806: PPUSH
87807: PPUSH
// if not driver or not IsInUnit ( driver ) then
87808: LD_VAR 0 1
87812: NOT
87813: PUSH
87814: LD_VAR 0 1
87818: PPUSH
87819: CALL_OW 310
87823: NOT
87824: OR
87825: IFFALSE 87829
// exit ;
87827: GO 87919
// vehicle := IsInUnit ( driver ) ;
87829: LD_ADDR_VAR 0 3
87833: PUSH
87834: LD_VAR 0 1
87838: PPUSH
87839: CALL_OW 310
87843: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87844: LD_VAR 0 1
87848: PPUSH
87849: LD_STRING \
87851: PUSH
87852: LD_INT 0
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 0
87860: PUSH
87861: LD_INT 0
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: LD_INT 0
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: PUSH
87879: LD_STRING E
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: LD_INT 0
87887: PUSH
87888: LD_VAR 0 3
87892: PUSH
87893: LD_INT 0
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: LD_INT 0
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PPUSH
87915: CALL_OW 446
// end ;
87919: LD_VAR 0 2
87923: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87924: LD_INT 0
87926: PPUSH
87927: PPUSH
// if not driver or not IsInUnit ( driver ) then
87928: LD_VAR 0 1
87932: NOT
87933: PUSH
87934: LD_VAR 0 1
87938: PPUSH
87939: CALL_OW 310
87943: NOT
87944: OR
87945: IFFALSE 87949
// exit ;
87947: GO 88039
// vehicle := IsInUnit ( driver ) ;
87949: LD_ADDR_VAR 0 3
87953: PUSH
87954: LD_VAR 0 1
87958: PPUSH
87959: CALL_OW 310
87963: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87964: LD_VAR 0 1
87968: PPUSH
87969: LD_STRING \
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: LD_INT 0
87977: PUSH
87978: LD_INT 0
87980: PUSH
87981: LD_INT 0
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: LD_INT 0
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: PUSH
87999: LD_STRING E
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: LD_INT 0
88007: PUSH
88008: LD_VAR 0 3
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: LD_INT 0
88018: PUSH
88019: LD_INT 0
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PPUSH
88035: CALL_OW 447
// end ;
88039: LD_VAR 0 2
88043: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88044: LD_INT 0
88046: PPUSH
88047: PPUSH
88048: PPUSH
// tmp := [ ] ;
88049: LD_ADDR_VAR 0 5
88053: PUSH
88054: EMPTY
88055: ST_TO_ADDR
// for i in units do
88056: LD_ADDR_VAR 0 4
88060: PUSH
88061: LD_VAR 0 1
88065: PUSH
88066: FOR_IN
88067: IFFALSE 88105
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88069: LD_ADDR_VAR 0 5
88073: PUSH
88074: LD_VAR 0 5
88078: PPUSH
88079: LD_VAR 0 5
88083: PUSH
88084: LD_INT 1
88086: PLUS
88087: PPUSH
88088: LD_VAR 0 4
88092: PPUSH
88093: CALL_OW 256
88097: PPUSH
88098: CALL_OW 2
88102: ST_TO_ADDR
88103: GO 88066
88105: POP
88106: POP
// if not tmp then
88107: LD_VAR 0 5
88111: NOT
88112: IFFALSE 88116
// exit ;
88114: GO 88164
// if asc then
88116: LD_VAR 0 2
88120: IFFALSE 88144
// result := SortListByListAsc ( units , tmp ) else
88122: LD_ADDR_VAR 0 3
88126: PUSH
88127: LD_VAR 0 1
88131: PPUSH
88132: LD_VAR 0 5
88136: PPUSH
88137: CALL_OW 76
88141: ST_TO_ADDR
88142: GO 88164
// result := SortListByListDesc ( units , tmp ) ;
88144: LD_ADDR_VAR 0 3
88148: PUSH
88149: LD_VAR 0 1
88153: PPUSH
88154: LD_VAR 0 5
88158: PPUSH
88159: CALL_OW 77
88163: ST_TO_ADDR
// end ;
88164: LD_VAR 0 3
88168: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88169: LD_INT 0
88171: PPUSH
88172: PPUSH
// task := GetTaskList ( mech ) ;
88173: LD_ADDR_VAR 0 4
88177: PUSH
88178: LD_VAR 0 1
88182: PPUSH
88183: CALL_OW 437
88187: ST_TO_ADDR
// if not task then
88188: LD_VAR 0 4
88192: NOT
88193: IFFALSE 88197
// exit ;
88195: GO 88239
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88197: LD_ADDR_VAR 0 3
88201: PUSH
88202: LD_VAR 0 4
88206: PUSH
88207: LD_INT 1
88209: ARRAY
88210: PUSH
88211: LD_INT 1
88213: ARRAY
88214: PUSH
88215: LD_STRING r
88217: EQUAL
88218: PUSH
88219: LD_VAR 0 4
88223: PUSH
88224: LD_INT 1
88226: ARRAY
88227: PUSH
88228: LD_INT 4
88230: ARRAY
88231: PUSH
88232: LD_VAR 0 2
88236: EQUAL
88237: AND
88238: ST_TO_ADDR
// end ;
88239: LD_VAR 0 3
88243: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88244: LD_INT 0
88246: PPUSH
// SetDir ( unit , d ) ;
88247: LD_VAR 0 1
88251: PPUSH
88252: LD_VAR 0 4
88256: PPUSH
88257: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88261: LD_VAR 0 1
88265: PPUSH
88266: LD_VAR 0 2
88270: PPUSH
88271: LD_VAR 0 3
88275: PPUSH
88276: LD_VAR 0 5
88280: PPUSH
88281: CALL_OW 48
// end ;
88285: LD_VAR 0 6
88289: RET
// export function ToNaturalNumber ( number ) ; begin
88290: LD_INT 0
88292: PPUSH
// result := number div 1 ;
88293: LD_ADDR_VAR 0 2
88297: PUSH
88298: LD_VAR 0 1
88302: PUSH
88303: LD_INT 1
88305: DIV
88306: ST_TO_ADDR
// if number < 0 then
88307: LD_VAR 0 1
88311: PUSH
88312: LD_INT 0
88314: LESS
88315: IFFALSE 88325
// result := 0 ;
88317: LD_ADDR_VAR 0 2
88321: PUSH
88322: LD_INT 0
88324: ST_TO_ADDR
// end ;
88325: LD_VAR 0 2
88329: RET
// export function SortByClass ( units , class ) ; var un ; begin
88330: LD_INT 0
88332: PPUSH
88333: PPUSH
// if not units or not class then
88334: LD_VAR 0 1
88338: NOT
88339: PUSH
88340: LD_VAR 0 2
88344: NOT
88345: OR
88346: IFFALSE 88350
// exit ;
88348: GO 88445
// result := [ ] ;
88350: LD_ADDR_VAR 0 3
88354: PUSH
88355: EMPTY
88356: ST_TO_ADDR
// for un in units do
88357: LD_ADDR_VAR 0 4
88361: PUSH
88362: LD_VAR 0 1
88366: PUSH
88367: FOR_IN
88368: IFFALSE 88443
// if GetClass ( un ) = class then
88370: LD_VAR 0 4
88374: PPUSH
88375: CALL_OW 257
88379: PUSH
88380: LD_VAR 0 2
88384: EQUAL
88385: IFFALSE 88412
// result := Insert ( result , 1 , un ) else
88387: LD_ADDR_VAR 0 3
88391: PUSH
88392: LD_VAR 0 3
88396: PPUSH
88397: LD_INT 1
88399: PPUSH
88400: LD_VAR 0 4
88404: PPUSH
88405: CALL_OW 2
88409: ST_TO_ADDR
88410: GO 88441
// result := Replace ( result , result + 1 , un ) ;
88412: LD_ADDR_VAR 0 3
88416: PUSH
88417: LD_VAR 0 3
88421: PPUSH
88422: LD_VAR 0 3
88426: PUSH
88427: LD_INT 1
88429: PLUS
88430: PPUSH
88431: LD_VAR 0 4
88435: PPUSH
88436: CALL_OW 1
88440: ST_TO_ADDR
88441: GO 88367
88443: POP
88444: POP
// end ;
88445: LD_VAR 0 3
88449: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88450: LD_INT 0
88452: PPUSH
88453: PPUSH
88454: PPUSH
88455: PPUSH
88456: PPUSH
88457: PPUSH
88458: PPUSH
// result := [ ] ;
88459: LD_ADDR_VAR 0 4
88463: PUSH
88464: EMPTY
88465: ST_TO_ADDR
// if x - r < 0 then
88466: LD_VAR 0 1
88470: PUSH
88471: LD_VAR 0 3
88475: MINUS
88476: PUSH
88477: LD_INT 0
88479: LESS
88480: IFFALSE 88492
// min_x := 0 else
88482: LD_ADDR_VAR 0 8
88486: PUSH
88487: LD_INT 0
88489: ST_TO_ADDR
88490: GO 88508
// min_x := x - r ;
88492: LD_ADDR_VAR 0 8
88496: PUSH
88497: LD_VAR 0 1
88501: PUSH
88502: LD_VAR 0 3
88506: MINUS
88507: ST_TO_ADDR
// if y - r < 0 then
88508: LD_VAR 0 2
88512: PUSH
88513: LD_VAR 0 3
88517: MINUS
88518: PUSH
88519: LD_INT 0
88521: LESS
88522: IFFALSE 88534
// min_y := 0 else
88524: LD_ADDR_VAR 0 7
88528: PUSH
88529: LD_INT 0
88531: ST_TO_ADDR
88532: GO 88550
// min_y := y - r ;
88534: LD_ADDR_VAR 0 7
88538: PUSH
88539: LD_VAR 0 2
88543: PUSH
88544: LD_VAR 0 3
88548: MINUS
88549: ST_TO_ADDR
// max_x := x + r ;
88550: LD_ADDR_VAR 0 9
88554: PUSH
88555: LD_VAR 0 1
88559: PUSH
88560: LD_VAR 0 3
88564: PLUS
88565: ST_TO_ADDR
// max_y := y + r ;
88566: LD_ADDR_VAR 0 10
88570: PUSH
88571: LD_VAR 0 2
88575: PUSH
88576: LD_VAR 0 3
88580: PLUS
88581: ST_TO_ADDR
// for _x = min_x to max_x do
88582: LD_ADDR_VAR 0 5
88586: PUSH
88587: DOUBLE
88588: LD_VAR 0 8
88592: DEC
88593: ST_TO_ADDR
88594: LD_VAR 0 9
88598: PUSH
88599: FOR_TO
88600: IFFALSE 88701
// for _y = min_y to max_y do
88602: LD_ADDR_VAR 0 6
88606: PUSH
88607: DOUBLE
88608: LD_VAR 0 7
88612: DEC
88613: ST_TO_ADDR
88614: LD_VAR 0 10
88618: PUSH
88619: FOR_TO
88620: IFFALSE 88697
// begin if not ValidHex ( _x , _y ) then
88622: LD_VAR 0 5
88626: PPUSH
88627: LD_VAR 0 6
88631: PPUSH
88632: CALL_OW 488
88636: NOT
88637: IFFALSE 88641
// continue ;
88639: GO 88619
// if GetResourceTypeXY ( _x , _y ) then
88641: LD_VAR 0 5
88645: PPUSH
88646: LD_VAR 0 6
88650: PPUSH
88651: CALL_OW 283
88655: IFFALSE 88695
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88657: LD_ADDR_VAR 0 4
88661: PUSH
88662: LD_VAR 0 4
88666: PPUSH
88667: LD_VAR 0 4
88671: PUSH
88672: LD_INT 1
88674: PLUS
88675: PPUSH
88676: LD_VAR 0 5
88680: PUSH
88681: LD_VAR 0 6
88685: PUSH
88686: EMPTY
88687: LIST
88688: LIST
88689: PPUSH
88690: CALL_OW 1
88694: ST_TO_ADDR
// end ;
88695: GO 88619
88697: POP
88698: POP
88699: GO 88599
88701: POP
88702: POP
// end ;
88703: LD_VAR 0 4
88707: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88708: LD_INT 0
88710: PPUSH
88711: PPUSH
88712: PPUSH
88713: PPUSH
88714: PPUSH
88715: PPUSH
88716: PPUSH
88717: PPUSH
// if not units then
88718: LD_VAR 0 1
88722: NOT
88723: IFFALSE 88727
// exit ;
88725: GO 89251
// result := UnitFilter ( units , [ f_ok ] ) ;
88727: LD_ADDR_VAR 0 3
88731: PUSH
88732: LD_VAR 0 1
88736: PPUSH
88737: LD_INT 50
88739: PUSH
88740: EMPTY
88741: LIST
88742: PPUSH
88743: CALL_OW 72
88747: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
88748: LD_ADDR_VAR 0 8
88752: PUSH
88753: LD_VAR 0 1
88757: PUSH
88758: LD_INT 1
88760: ARRAY
88761: PPUSH
88762: CALL_OW 255
88766: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
88767: LD_ADDR_VAR 0 10
88771: PUSH
88772: LD_INT 29
88774: PUSH
88775: LD_INT 91
88777: PUSH
88778: LD_INT 49
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: LIST
88785: ST_TO_ADDR
// if not result then
88786: LD_VAR 0 3
88790: NOT
88791: IFFALSE 88795
// exit ;
88793: GO 89251
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88795: LD_ADDR_VAR 0 5
88799: PUSH
88800: LD_INT 81
88802: PUSH
88803: LD_VAR 0 8
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PPUSH
88812: CALL_OW 69
88816: ST_TO_ADDR
// for i in result do
88817: LD_ADDR_VAR 0 4
88821: PUSH
88822: LD_VAR 0 3
88826: PUSH
88827: FOR_IN
88828: IFFALSE 89249
// begin tag := GetTag ( i ) + 1 ;
88830: LD_ADDR_VAR 0 9
88834: PUSH
88835: LD_VAR 0 4
88839: PPUSH
88840: CALL_OW 110
88844: PUSH
88845: LD_INT 1
88847: PLUS
88848: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88849: LD_ADDR_VAR 0 7
88853: PUSH
88854: LD_VAR 0 4
88858: PPUSH
88859: CALL_OW 250
88863: PPUSH
88864: LD_VAR 0 4
88868: PPUSH
88869: CALL_OW 251
88873: PPUSH
88874: LD_INT 6
88876: PPUSH
88877: CALL 88450 0 3
88881: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88882: LD_VAR 0 4
88886: PPUSH
88887: CALL_OW 247
88891: PUSH
88892: LD_INT 2
88894: EQUAL
88895: PUSH
88896: LD_VAR 0 7
88900: AND
88901: PUSH
88902: LD_VAR 0 4
88906: PPUSH
88907: CALL_OW 264
88911: PUSH
88912: LD_VAR 0 10
88916: IN
88917: NOT
88918: AND
88919: IFFALSE 88958
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88921: LD_VAR 0 4
88925: PPUSH
88926: LD_VAR 0 7
88930: PUSH
88931: LD_INT 1
88933: ARRAY
88934: PUSH
88935: LD_INT 1
88937: ARRAY
88938: PPUSH
88939: LD_VAR 0 7
88943: PUSH
88944: LD_INT 1
88946: ARRAY
88947: PUSH
88948: LD_INT 2
88950: ARRAY
88951: PPUSH
88952: CALL_OW 116
88956: GO 89247
// if path > tag then
88958: LD_VAR 0 2
88962: PUSH
88963: LD_VAR 0 9
88967: GREATER
88968: IFFALSE 89176
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
88970: LD_ADDR_VAR 0 6
88974: PUSH
88975: LD_VAR 0 5
88979: PPUSH
88980: LD_INT 91
88982: PUSH
88983: LD_VAR 0 4
88987: PUSH
88988: LD_INT 8
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: LIST
88995: PPUSH
88996: CALL_OW 72
89000: ST_TO_ADDR
// if nearEnemy then
89001: LD_VAR 0 6
89005: IFFALSE 89074
// begin if GetWeapon ( i ) = ru_time_lapser then
89007: LD_VAR 0 4
89011: PPUSH
89012: CALL_OW 264
89016: PUSH
89017: LD_INT 49
89019: EQUAL
89020: IFFALSE 89048
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89022: LD_VAR 0 4
89026: PPUSH
89027: LD_VAR 0 6
89031: PPUSH
89032: LD_VAR 0 4
89036: PPUSH
89037: CALL_OW 74
89041: PPUSH
89042: CALL_OW 112
89046: GO 89072
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89048: LD_VAR 0 4
89052: PPUSH
89053: LD_VAR 0 6
89057: PPUSH
89058: LD_VAR 0 4
89062: PPUSH
89063: CALL_OW 74
89067: PPUSH
89068: CALL_OW 115
// end else
89072: GO 89174
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89074: LD_VAR 0 4
89078: PPUSH
89079: LD_VAR 0 2
89083: PUSH
89084: LD_VAR 0 9
89088: ARRAY
89089: PUSH
89090: LD_INT 1
89092: ARRAY
89093: PPUSH
89094: LD_VAR 0 2
89098: PUSH
89099: LD_VAR 0 9
89103: ARRAY
89104: PUSH
89105: LD_INT 2
89107: ARRAY
89108: PPUSH
89109: CALL_OW 297
89113: PUSH
89114: LD_INT 6
89116: GREATER
89117: IFFALSE 89160
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89119: LD_VAR 0 4
89123: PPUSH
89124: LD_VAR 0 2
89128: PUSH
89129: LD_VAR 0 9
89133: ARRAY
89134: PUSH
89135: LD_INT 1
89137: ARRAY
89138: PPUSH
89139: LD_VAR 0 2
89143: PUSH
89144: LD_VAR 0 9
89148: ARRAY
89149: PUSH
89150: LD_INT 2
89152: ARRAY
89153: PPUSH
89154: CALL_OW 114
89158: GO 89174
// SetTag ( i , tag ) ;
89160: LD_VAR 0 4
89164: PPUSH
89165: LD_VAR 0 9
89169: PPUSH
89170: CALL_OW 109
// end else
89174: GO 89247
// if enemy then
89176: LD_VAR 0 5
89180: IFFALSE 89247
// begin if GetWeapon ( i ) = ru_time_lapser then
89182: LD_VAR 0 4
89186: PPUSH
89187: CALL_OW 264
89191: PUSH
89192: LD_INT 49
89194: EQUAL
89195: IFFALSE 89223
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89197: LD_VAR 0 4
89201: PPUSH
89202: LD_VAR 0 5
89206: PPUSH
89207: LD_VAR 0 4
89211: PPUSH
89212: CALL_OW 74
89216: PPUSH
89217: CALL_OW 112
89221: GO 89247
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89223: LD_VAR 0 4
89227: PPUSH
89228: LD_VAR 0 5
89232: PPUSH
89233: LD_VAR 0 4
89237: PPUSH
89238: CALL_OW 74
89242: PPUSH
89243: CALL_OW 115
// end ; end ;
89247: GO 88827
89249: POP
89250: POP
// end ;
89251: LD_VAR 0 3
89255: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89256: LD_INT 0
89258: PPUSH
89259: PPUSH
89260: PPUSH
// if not unit or IsInUnit ( unit ) then
89261: LD_VAR 0 1
89265: NOT
89266: PUSH
89267: LD_VAR 0 1
89271: PPUSH
89272: CALL_OW 310
89276: OR
89277: IFFALSE 89281
// exit ;
89279: GO 89372
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89281: LD_ADDR_VAR 0 4
89285: PUSH
89286: LD_VAR 0 1
89290: PPUSH
89291: CALL_OW 250
89295: PPUSH
89296: LD_VAR 0 2
89300: PPUSH
89301: LD_INT 1
89303: PPUSH
89304: CALL_OW 272
89308: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89309: LD_ADDR_VAR 0 5
89313: PUSH
89314: LD_VAR 0 1
89318: PPUSH
89319: CALL_OW 251
89323: PPUSH
89324: LD_VAR 0 2
89328: PPUSH
89329: LD_INT 1
89331: PPUSH
89332: CALL_OW 273
89336: ST_TO_ADDR
// if ValidHex ( x , y ) then
89337: LD_VAR 0 4
89341: PPUSH
89342: LD_VAR 0 5
89346: PPUSH
89347: CALL_OW 488
89351: IFFALSE 89372
// ComTurnXY ( unit , x , y ) ;
89353: LD_VAR 0 1
89357: PPUSH
89358: LD_VAR 0 4
89362: PPUSH
89363: LD_VAR 0 5
89367: PPUSH
89368: CALL_OW 118
// end ;
89372: LD_VAR 0 3
89376: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89377: LD_INT 0
89379: PPUSH
89380: PPUSH
// result := false ;
89381: LD_ADDR_VAR 0 3
89385: PUSH
89386: LD_INT 0
89388: ST_TO_ADDR
// if not units then
89389: LD_VAR 0 2
89393: NOT
89394: IFFALSE 89398
// exit ;
89396: GO 89443
// for i in units do
89398: LD_ADDR_VAR 0 4
89402: PUSH
89403: LD_VAR 0 2
89407: PUSH
89408: FOR_IN
89409: IFFALSE 89441
// if See ( side , i ) then
89411: LD_VAR 0 1
89415: PPUSH
89416: LD_VAR 0 4
89420: PPUSH
89421: CALL_OW 292
89425: IFFALSE 89439
// begin result := true ;
89427: LD_ADDR_VAR 0 3
89431: PUSH
89432: LD_INT 1
89434: ST_TO_ADDR
// exit ;
89435: POP
89436: POP
89437: GO 89443
// end ;
89439: GO 89408
89441: POP
89442: POP
// end ;
89443: LD_VAR 0 3
89447: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89448: LD_INT 0
89450: PPUSH
89451: PPUSH
89452: PPUSH
89453: PPUSH
// if not unit or not points then
89454: LD_VAR 0 1
89458: NOT
89459: PUSH
89460: LD_VAR 0 2
89464: NOT
89465: OR
89466: IFFALSE 89470
// exit ;
89468: GO 89560
// dist := 99999 ;
89470: LD_ADDR_VAR 0 5
89474: PUSH
89475: LD_INT 99999
89477: ST_TO_ADDR
// for i in points do
89478: LD_ADDR_VAR 0 4
89482: PUSH
89483: LD_VAR 0 2
89487: PUSH
89488: FOR_IN
89489: IFFALSE 89558
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89491: LD_ADDR_VAR 0 6
89495: PUSH
89496: LD_VAR 0 1
89500: PPUSH
89501: LD_VAR 0 4
89505: PUSH
89506: LD_INT 1
89508: ARRAY
89509: PPUSH
89510: LD_VAR 0 4
89514: PUSH
89515: LD_INT 2
89517: ARRAY
89518: PPUSH
89519: CALL_OW 297
89523: ST_TO_ADDR
// if tmpDist < dist then
89524: LD_VAR 0 6
89528: PUSH
89529: LD_VAR 0 5
89533: LESS
89534: IFFALSE 89556
// begin result := i ;
89536: LD_ADDR_VAR 0 3
89540: PUSH
89541: LD_VAR 0 4
89545: ST_TO_ADDR
// dist := tmpDist ;
89546: LD_ADDR_VAR 0 5
89550: PUSH
89551: LD_VAR 0 6
89555: ST_TO_ADDR
// end ; end ;
89556: GO 89488
89558: POP
89559: POP
// end ;
89560: LD_VAR 0 3
89564: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89565: LD_INT 0
89567: PPUSH
// uc_side := side ;
89568: LD_ADDR_OWVAR 20
89572: PUSH
89573: LD_VAR 0 1
89577: ST_TO_ADDR
// uc_nation := 3 ;
89578: LD_ADDR_OWVAR 21
89582: PUSH
89583: LD_INT 3
89585: ST_TO_ADDR
// vc_chassis := 25 ;
89586: LD_ADDR_OWVAR 37
89590: PUSH
89591: LD_INT 25
89593: ST_TO_ADDR
// vc_engine := engine_siberite ;
89594: LD_ADDR_OWVAR 39
89598: PUSH
89599: LD_INT 3
89601: ST_TO_ADDR
// vc_control := control_computer ;
89602: LD_ADDR_OWVAR 38
89606: PUSH
89607: LD_INT 3
89609: ST_TO_ADDR
// vc_weapon := 59 ;
89610: LD_ADDR_OWVAR 40
89614: PUSH
89615: LD_INT 59
89617: ST_TO_ADDR
// result := CreateVehicle ;
89618: LD_ADDR_VAR 0 5
89622: PUSH
89623: CALL_OW 45
89627: ST_TO_ADDR
// SetDir ( result , d ) ;
89628: LD_VAR 0 5
89632: PPUSH
89633: LD_VAR 0 4
89637: PPUSH
89638: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89642: LD_VAR 0 5
89646: PPUSH
89647: LD_VAR 0 2
89651: PPUSH
89652: LD_VAR 0 3
89656: PPUSH
89657: LD_INT 0
89659: PPUSH
89660: CALL_OW 48
// end ;
89664: LD_VAR 0 5
89668: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89669: LD_INT 0
89671: PPUSH
89672: PPUSH
89673: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89674: LD_ADDR_VAR 0 2
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: LD_INT 0
89684: PUSH
89685: LD_INT 0
89687: PUSH
89688: LD_INT 0
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89697: LD_VAR 0 1
89701: NOT
89702: PUSH
89703: LD_VAR 0 1
89707: PPUSH
89708: CALL_OW 264
89712: PUSH
89713: LD_INT 12
89715: PUSH
89716: LD_INT 51
89718: PUSH
89719: LD_INT 32
89721: PUSH
89722: LD_INT 89
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: IN
89731: NOT
89732: OR
89733: IFFALSE 89737
// exit ;
89735: GO 89835
// for i := 1 to 3 do
89737: LD_ADDR_VAR 0 3
89741: PUSH
89742: DOUBLE
89743: LD_INT 1
89745: DEC
89746: ST_TO_ADDR
89747: LD_INT 3
89749: PUSH
89750: FOR_TO
89751: IFFALSE 89833
// begin tmp := GetCargo ( cargo , i ) ;
89753: LD_ADDR_VAR 0 4
89757: PUSH
89758: LD_VAR 0 1
89762: PPUSH
89763: LD_VAR 0 3
89767: PPUSH
89768: CALL_OW 289
89772: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
89773: LD_ADDR_VAR 0 2
89777: PUSH
89778: LD_VAR 0 2
89782: PPUSH
89783: LD_VAR 0 3
89787: PPUSH
89788: LD_VAR 0 4
89792: PPUSH
89793: CALL_OW 1
89797: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
89798: LD_ADDR_VAR 0 2
89802: PUSH
89803: LD_VAR 0 2
89807: PPUSH
89808: LD_INT 4
89810: PPUSH
89811: LD_VAR 0 2
89815: PUSH
89816: LD_INT 4
89818: ARRAY
89819: PUSH
89820: LD_VAR 0 4
89824: PLUS
89825: PPUSH
89826: CALL_OW 1
89830: ST_TO_ADDR
// end ;
89831: GO 89750
89833: POP
89834: POP
// end ;
89835: LD_VAR 0 2
89839: RET
// export function Length ( array ) ; begin
89840: LD_INT 0
89842: PPUSH
// result := array + 0 ;
89843: LD_ADDR_VAR 0 2
89847: PUSH
89848: LD_VAR 0 1
89852: PUSH
89853: LD_INT 0
89855: PLUS
89856: ST_TO_ADDR
// end ;
89857: LD_VAR 0 2
89861: RET
// export function PrepareArray ( array ) ; begin
89862: LD_INT 0
89864: PPUSH
// result := array diff 0 ;
89865: LD_ADDR_VAR 0 2
89869: PUSH
89870: LD_VAR 0 1
89874: PUSH
89875: LD_INT 0
89877: DIFF
89878: ST_TO_ADDR
// if not result [ 1 ] then
89879: LD_VAR 0 2
89883: PUSH
89884: LD_INT 1
89886: ARRAY
89887: NOT
89888: IFFALSE 89908
// result := Delete ( result , 1 ) ;
89890: LD_ADDR_VAR 0 2
89894: PUSH
89895: LD_VAR 0 2
89899: PPUSH
89900: LD_INT 1
89902: PPUSH
89903: CALL_OW 3
89907: ST_TO_ADDR
// end ;
89908: LD_VAR 0 2
89912: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
89913: LD_INT 0
89915: PPUSH
89916: PPUSH
89917: PPUSH
89918: PPUSH
// sibRocketRange := 25 ;
89919: LD_ADDR_VAR 0 6
89923: PUSH
89924: LD_INT 25
89926: ST_TO_ADDR
// result := false ;
89927: LD_ADDR_VAR 0 4
89931: PUSH
89932: LD_INT 0
89934: ST_TO_ADDR
// for i := 0 to 5 do
89935: LD_ADDR_VAR 0 5
89939: PUSH
89940: DOUBLE
89941: LD_INT 0
89943: DEC
89944: ST_TO_ADDR
89945: LD_INT 5
89947: PUSH
89948: FOR_TO
89949: IFFALSE 90016
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
89951: LD_VAR 0 1
89955: PPUSH
89956: LD_VAR 0 5
89960: PPUSH
89961: LD_VAR 0 6
89965: PPUSH
89966: CALL_OW 272
89970: PPUSH
89971: LD_VAR 0 2
89975: PPUSH
89976: LD_VAR 0 5
89980: PPUSH
89981: LD_VAR 0 6
89985: PPUSH
89986: CALL_OW 273
89990: PPUSH
89991: LD_VAR 0 3
89995: PPUSH
89996: CALL_OW 309
90000: IFFALSE 90014
// begin result := true ;
90002: LD_ADDR_VAR 0 4
90006: PUSH
90007: LD_INT 1
90009: ST_TO_ADDR
// exit ;
90010: POP
90011: POP
90012: GO 90018
// end ;
90014: GO 89948
90016: POP
90017: POP
// end ; end_of_file end_of_file
90018: LD_VAR 0 4
90022: RET
// every 0 0$1 do
90023: GO 90025
90025: DISABLE
// begin enable ;
90026: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90027: LD_STRING updateTimer(
90029: PUSH
90030: LD_OWVAR 1
90034: STR
90035: PUSH
90036: LD_STRING );
90038: STR
90039: PPUSH
90040: CALL_OW 559
// end ;
90044: END
// export function SOS_MapStart ( ) ; begin
90045: LD_INT 0
90047: PPUSH
// if streamModeActive then
90048: LD_EXP 94
90052: IFFALSE 90061
// DefineStreamItems ( true ) ;
90054: LD_INT 1
90056: PPUSH
90057: CALL 91715 0 1
// UpdateFactoryWaypoints ( ) ;
90061: CALL 104576 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90065: CALL 104833 0 0
// end ;
90069: LD_VAR 0 1
90073: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90074: LD_INT 0
90076: PPUSH
// if p2 = hack_mode then
90077: LD_VAR 0 2
90081: PUSH
90082: LD_INT 100
90084: EQUAL
90085: IFFALSE 91088
// begin if not StreamModeActive then
90087: LD_EXP 94
90091: NOT
90092: IFFALSE 90102
// StreamModeActive := true ;
90094: LD_ADDR_EXP 94
90098: PUSH
90099: LD_INT 1
90101: ST_TO_ADDR
// if p3 = 0 then
90102: LD_VAR 0 3
90106: PUSH
90107: LD_INT 0
90109: EQUAL
90110: IFFALSE 90116
// InitStreamMode ;
90112: CALL 91251 0 0
// if p3 = 1 then
90116: LD_VAR 0 3
90120: PUSH
90121: LD_INT 1
90123: EQUAL
90124: IFFALSE 90134
// sRocket := true ;
90126: LD_ADDR_EXP 99
90130: PUSH
90131: LD_INT 1
90133: ST_TO_ADDR
// if p3 = 2 then
90134: LD_VAR 0 3
90138: PUSH
90139: LD_INT 2
90141: EQUAL
90142: IFFALSE 90152
// sSpeed := true ;
90144: LD_ADDR_EXP 98
90148: PUSH
90149: LD_INT 1
90151: ST_TO_ADDR
// if p3 = 3 then
90152: LD_VAR 0 3
90156: PUSH
90157: LD_INT 3
90159: EQUAL
90160: IFFALSE 90170
// sEngine := true ;
90162: LD_ADDR_EXP 100
90166: PUSH
90167: LD_INT 1
90169: ST_TO_ADDR
// if p3 = 4 then
90170: LD_VAR 0 3
90174: PUSH
90175: LD_INT 4
90177: EQUAL
90178: IFFALSE 90188
// sSpec := true ;
90180: LD_ADDR_EXP 97
90184: PUSH
90185: LD_INT 1
90187: ST_TO_ADDR
// if p3 = 5 then
90188: LD_VAR 0 3
90192: PUSH
90193: LD_INT 5
90195: EQUAL
90196: IFFALSE 90206
// sLevel := true ;
90198: LD_ADDR_EXP 101
90202: PUSH
90203: LD_INT 1
90205: ST_TO_ADDR
// if p3 = 6 then
90206: LD_VAR 0 3
90210: PUSH
90211: LD_INT 6
90213: EQUAL
90214: IFFALSE 90224
// sArmoury := true ;
90216: LD_ADDR_EXP 102
90220: PUSH
90221: LD_INT 1
90223: ST_TO_ADDR
// if p3 = 7 then
90224: LD_VAR 0 3
90228: PUSH
90229: LD_INT 7
90231: EQUAL
90232: IFFALSE 90242
// sRadar := true ;
90234: LD_ADDR_EXP 103
90238: PUSH
90239: LD_INT 1
90241: ST_TO_ADDR
// if p3 = 8 then
90242: LD_VAR 0 3
90246: PUSH
90247: LD_INT 8
90249: EQUAL
90250: IFFALSE 90260
// sBunker := true ;
90252: LD_ADDR_EXP 104
90256: PUSH
90257: LD_INT 1
90259: ST_TO_ADDR
// if p3 = 9 then
90260: LD_VAR 0 3
90264: PUSH
90265: LD_INT 9
90267: EQUAL
90268: IFFALSE 90278
// sHack := true ;
90270: LD_ADDR_EXP 105
90274: PUSH
90275: LD_INT 1
90277: ST_TO_ADDR
// if p3 = 10 then
90278: LD_VAR 0 3
90282: PUSH
90283: LD_INT 10
90285: EQUAL
90286: IFFALSE 90296
// sFire := true ;
90288: LD_ADDR_EXP 106
90292: PUSH
90293: LD_INT 1
90295: ST_TO_ADDR
// if p3 = 11 then
90296: LD_VAR 0 3
90300: PUSH
90301: LD_INT 11
90303: EQUAL
90304: IFFALSE 90314
// sRefresh := true ;
90306: LD_ADDR_EXP 107
90310: PUSH
90311: LD_INT 1
90313: ST_TO_ADDR
// if p3 = 12 then
90314: LD_VAR 0 3
90318: PUSH
90319: LD_INT 12
90321: EQUAL
90322: IFFALSE 90332
// sExp := true ;
90324: LD_ADDR_EXP 108
90328: PUSH
90329: LD_INT 1
90331: ST_TO_ADDR
// if p3 = 13 then
90332: LD_VAR 0 3
90336: PUSH
90337: LD_INT 13
90339: EQUAL
90340: IFFALSE 90350
// sDepot := true ;
90342: LD_ADDR_EXP 109
90346: PUSH
90347: LD_INT 1
90349: ST_TO_ADDR
// if p3 = 14 then
90350: LD_VAR 0 3
90354: PUSH
90355: LD_INT 14
90357: EQUAL
90358: IFFALSE 90368
// sFlag := true ;
90360: LD_ADDR_EXP 110
90364: PUSH
90365: LD_INT 1
90367: ST_TO_ADDR
// if p3 = 15 then
90368: LD_VAR 0 3
90372: PUSH
90373: LD_INT 15
90375: EQUAL
90376: IFFALSE 90386
// sKamikadze := true ;
90378: LD_ADDR_EXP 118
90382: PUSH
90383: LD_INT 1
90385: ST_TO_ADDR
// if p3 = 16 then
90386: LD_VAR 0 3
90390: PUSH
90391: LD_INT 16
90393: EQUAL
90394: IFFALSE 90404
// sTroll := true ;
90396: LD_ADDR_EXP 119
90400: PUSH
90401: LD_INT 1
90403: ST_TO_ADDR
// if p3 = 17 then
90404: LD_VAR 0 3
90408: PUSH
90409: LD_INT 17
90411: EQUAL
90412: IFFALSE 90422
// sSlow := true ;
90414: LD_ADDR_EXP 120
90418: PUSH
90419: LD_INT 1
90421: ST_TO_ADDR
// if p3 = 18 then
90422: LD_VAR 0 3
90426: PUSH
90427: LD_INT 18
90429: EQUAL
90430: IFFALSE 90440
// sLack := true ;
90432: LD_ADDR_EXP 121
90436: PUSH
90437: LD_INT 1
90439: ST_TO_ADDR
// if p3 = 19 then
90440: LD_VAR 0 3
90444: PUSH
90445: LD_INT 19
90447: EQUAL
90448: IFFALSE 90458
// sTank := true ;
90450: LD_ADDR_EXP 123
90454: PUSH
90455: LD_INT 1
90457: ST_TO_ADDR
// if p3 = 20 then
90458: LD_VAR 0 3
90462: PUSH
90463: LD_INT 20
90465: EQUAL
90466: IFFALSE 90476
// sRemote := true ;
90468: LD_ADDR_EXP 124
90472: PUSH
90473: LD_INT 1
90475: ST_TO_ADDR
// if p3 = 21 then
90476: LD_VAR 0 3
90480: PUSH
90481: LD_INT 21
90483: EQUAL
90484: IFFALSE 90494
// sPowell := true ;
90486: LD_ADDR_EXP 125
90490: PUSH
90491: LD_INT 1
90493: ST_TO_ADDR
// if p3 = 22 then
90494: LD_VAR 0 3
90498: PUSH
90499: LD_INT 22
90501: EQUAL
90502: IFFALSE 90512
// sTeleport := true ;
90504: LD_ADDR_EXP 128
90508: PUSH
90509: LD_INT 1
90511: ST_TO_ADDR
// if p3 = 23 then
90512: LD_VAR 0 3
90516: PUSH
90517: LD_INT 23
90519: EQUAL
90520: IFFALSE 90530
// sOilTower := true ;
90522: LD_ADDR_EXP 130
90526: PUSH
90527: LD_INT 1
90529: ST_TO_ADDR
// if p3 = 24 then
90530: LD_VAR 0 3
90534: PUSH
90535: LD_INT 24
90537: EQUAL
90538: IFFALSE 90548
// sShovel := true ;
90540: LD_ADDR_EXP 131
90544: PUSH
90545: LD_INT 1
90547: ST_TO_ADDR
// if p3 = 25 then
90548: LD_VAR 0 3
90552: PUSH
90553: LD_INT 25
90555: EQUAL
90556: IFFALSE 90566
// sSheik := true ;
90558: LD_ADDR_EXP 132
90562: PUSH
90563: LD_INT 1
90565: ST_TO_ADDR
// if p3 = 26 then
90566: LD_VAR 0 3
90570: PUSH
90571: LD_INT 26
90573: EQUAL
90574: IFFALSE 90584
// sEarthquake := true ;
90576: LD_ADDR_EXP 134
90580: PUSH
90581: LD_INT 1
90583: ST_TO_ADDR
// if p3 = 27 then
90584: LD_VAR 0 3
90588: PUSH
90589: LD_INT 27
90591: EQUAL
90592: IFFALSE 90602
// sAI := true ;
90594: LD_ADDR_EXP 135
90598: PUSH
90599: LD_INT 1
90601: ST_TO_ADDR
// if p3 = 28 then
90602: LD_VAR 0 3
90606: PUSH
90607: LD_INT 28
90609: EQUAL
90610: IFFALSE 90620
// sCargo := true ;
90612: LD_ADDR_EXP 138
90616: PUSH
90617: LD_INT 1
90619: ST_TO_ADDR
// if p3 = 29 then
90620: LD_VAR 0 3
90624: PUSH
90625: LD_INT 29
90627: EQUAL
90628: IFFALSE 90638
// sDLaser := true ;
90630: LD_ADDR_EXP 139
90634: PUSH
90635: LD_INT 1
90637: ST_TO_ADDR
// if p3 = 30 then
90638: LD_VAR 0 3
90642: PUSH
90643: LD_INT 30
90645: EQUAL
90646: IFFALSE 90656
// sExchange := true ;
90648: LD_ADDR_EXP 140
90652: PUSH
90653: LD_INT 1
90655: ST_TO_ADDR
// if p3 = 31 then
90656: LD_VAR 0 3
90660: PUSH
90661: LD_INT 31
90663: EQUAL
90664: IFFALSE 90674
// sFac := true ;
90666: LD_ADDR_EXP 141
90670: PUSH
90671: LD_INT 1
90673: ST_TO_ADDR
// if p3 = 32 then
90674: LD_VAR 0 3
90678: PUSH
90679: LD_INT 32
90681: EQUAL
90682: IFFALSE 90692
// sPower := true ;
90684: LD_ADDR_EXP 142
90688: PUSH
90689: LD_INT 1
90691: ST_TO_ADDR
// if p3 = 33 then
90692: LD_VAR 0 3
90696: PUSH
90697: LD_INT 33
90699: EQUAL
90700: IFFALSE 90710
// sRandom := true ;
90702: LD_ADDR_EXP 143
90706: PUSH
90707: LD_INT 1
90709: ST_TO_ADDR
// if p3 = 34 then
90710: LD_VAR 0 3
90714: PUSH
90715: LD_INT 34
90717: EQUAL
90718: IFFALSE 90728
// sShield := true ;
90720: LD_ADDR_EXP 144
90724: PUSH
90725: LD_INT 1
90727: ST_TO_ADDR
// if p3 = 35 then
90728: LD_VAR 0 3
90732: PUSH
90733: LD_INT 35
90735: EQUAL
90736: IFFALSE 90746
// sTime := true ;
90738: LD_ADDR_EXP 145
90742: PUSH
90743: LD_INT 1
90745: ST_TO_ADDR
// if p3 = 36 then
90746: LD_VAR 0 3
90750: PUSH
90751: LD_INT 36
90753: EQUAL
90754: IFFALSE 90764
// sTools := true ;
90756: LD_ADDR_EXP 146
90760: PUSH
90761: LD_INT 1
90763: ST_TO_ADDR
// if p3 = 101 then
90764: LD_VAR 0 3
90768: PUSH
90769: LD_INT 101
90771: EQUAL
90772: IFFALSE 90782
// sSold := true ;
90774: LD_ADDR_EXP 111
90778: PUSH
90779: LD_INT 1
90781: ST_TO_ADDR
// if p3 = 102 then
90782: LD_VAR 0 3
90786: PUSH
90787: LD_INT 102
90789: EQUAL
90790: IFFALSE 90800
// sDiff := true ;
90792: LD_ADDR_EXP 112
90796: PUSH
90797: LD_INT 1
90799: ST_TO_ADDR
// if p3 = 103 then
90800: LD_VAR 0 3
90804: PUSH
90805: LD_INT 103
90807: EQUAL
90808: IFFALSE 90818
// sFog := true ;
90810: LD_ADDR_EXP 115
90814: PUSH
90815: LD_INT 1
90817: ST_TO_ADDR
// if p3 = 104 then
90818: LD_VAR 0 3
90822: PUSH
90823: LD_INT 104
90825: EQUAL
90826: IFFALSE 90836
// sReset := true ;
90828: LD_ADDR_EXP 116
90832: PUSH
90833: LD_INT 1
90835: ST_TO_ADDR
// if p3 = 105 then
90836: LD_VAR 0 3
90840: PUSH
90841: LD_INT 105
90843: EQUAL
90844: IFFALSE 90854
// sSun := true ;
90846: LD_ADDR_EXP 117
90850: PUSH
90851: LD_INT 1
90853: ST_TO_ADDR
// if p3 = 106 then
90854: LD_VAR 0 3
90858: PUSH
90859: LD_INT 106
90861: EQUAL
90862: IFFALSE 90872
// sTiger := true ;
90864: LD_ADDR_EXP 113
90868: PUSH
90869: LD_INT 1
90871: ST_TO_ADDR
// if p3 = 107 then
90872: LD_VAR 0 3
90876: PUSH
90877: LD_INT 107
90879: EQUAL
90880: IFFALSE 90890
// sBomb := true ;
90882: LD_ADDR_EXP 114
90886: PUSH
90887: LD_INT 1
90889: ST_TO_ADDR
// if p3 = 108 then
90890: LD_VAR 0 3
90894: PUSH
90895: LD_INT 108
90897: EQUAL
90898: IFFALSE 90908
// sWound := true ;
90900: LD_ADDR_EXP 122
90904: PUSH
90905: LD_INT 1
90907: ST_TO_ADDR
// if p3 = 109 then
90908: LD_VAR 0 3
90912: PUSH
90913: LD_INT 109
90915: EQUAL
90916: IFFALSE 90926
// sBetray := true ;
90918: LD_ADDR_EXP 126
90922: PUSH
90923: LD_INT 1
90925: ST_TO_ADDR
// if p3 = 110 then
90926: LD_VAR 0 3
90930: PUSH
90931: LD_INT 110
90933: EQUAL
90934: IFFALSE 90944
// sContamin := true ;
90936: LD_ADDR_EXP 127
90940: PUSH
90941: LD_INT 1
90943: ST_TO_ADDR
// if p3 = 111 then
90944: LD_VAR 0 3
90948: PUSH
90949: LD_INT 111
90951: EQUAL
90952: IFFALSE 90962
// sOil := true ;
90954: LD_ADDR_EXP 129
90958: PUSH
90959: LD_INT 1
90961: ST_TO_ADDR
// if p3 = 112 then
90962: LD_VAR 0 3
90966: PUSH
90967: LD_INT 112
90969: EQUAL
90970: IFFALSE 90980
// sStu := true ;
90972: LD_ADDR_EXP 133
90976: PUSH
90977: LD_INT 1
90979: ST_TO_ADDR
// if p3 = 113 then
90980: LD_VAR 0 3
90984: PUSH
90985: LD_INT 113
90987: EQUAL
90988: IFFALSE 90998
// sBazooka := true ;
90990: LD_ADDR_EXP 136
90994: PUSH
90995: LD_INT 1
90997: ST_TO_ADDR
// if p3 = 114 then
90998: LD_VAR 0 3
91002: PUSH
91003: LD_INT 114
91005: EQUAL
91006: IFFALSE 91016
// sMortar := true ;
91008: LD_ADDR_EXP 137
91012: PUSH
91013: LD_INT 1
91015: ST_TO_ADDR
// if p3 = 115 then
91016: LD_VAR 0 3
91020: PUSH
91021: LD_INT 115
91023: EQUAL
91024: IFFALSE 91034
// sRanger := true ;
91026: LD_ADDR_EXP 147
91030: PUSH
91031: LD_INT 1
91033: ST_TO_ADDR
// if p3 = 116 then
91034: LD_VAR 0 3
91038: PUSH
91039: LD_INT 116
91041: EQUAL
91042: IFFALSE 91052
// sComputer := true ;
91044: LD_ADDR_EXP 148
91048: PUSH
91049: LD_INT 1
91051: ST_TO_ADDR
// if p3 = 117 then
91052: LD_VAR 0 3
91056: PUSH
91057: LD_INT 117
91059: EQUAL
91060: IFFALSE 91070
// s30 := true ;
91062: LD_ADDR_EXP 149
91066: PUSH
91067: LD_INT 1
91069: ST_TO_ADDR
// if p3 = 118 then
91070: LD_VAR 0 3
91074: PUSH
91075: LD_INT 118
91077: EQUAL
91078: IFFALSE 91088
// s60 := true ;
91080: LD_ADDR_EXP 150
91084: PUSH
91085: LD_INT 1
91087: ST_TO_ADDR
// end ; if p2 = stream_mode then
91088: LD_VAR 0 2
91092: PUSH
91093: LD_INT 101
91095: EQUAL
91096: IFFALSE 91224
// begin case p3 of 1 :
91098: LD_VAR 0 3
91102: PUSH
91103: LD_INT 1
91105: DOUBLE
91106: EQUAL
91107: IFTRUE 91111
91109: GO 91118
91111: POP
// hHackUnlimitedResources ; 2 :
91112: CALL 103322 0 0
91116: GO 91224
91118: LD_INT 2
91120: DOUBLE
91121: EQUAL
91122: IFTRUE 91126
91124: GO 91133
91126: POP
// hHackSetLevel10 ; 3 :
91127: CALL 103455 0 0
91131: GO 91224
91133: LD_INT 3
91135: DOUBLE
91136: EQUAL
91137: IFTRUE 91141
91139: GO 91148
91141: POP
// hHackSetLevel10YourUnits ; 4 :
91142: CALL 103540 0 0
91146: GO 91224
91148: LD_INT 4
91150: DOUBLE
91151: EQUAL
91152: IFTRUE 91156
91154: GO 91163
91156: POP
// hHackInvincible ; 5 :
91157: CALL 103988 0 0
91161: GO 91224
91163: LD_INT 5
91165: DOUBLE
91166: EQUAL
91167: IFTRUE 91171
91169: GO 91178
91171: POP
// hHackInvisible ; 6 :
91172: CALL 104099 0 0
91176: GO 91224
91178: LD_INT 6
91180: DOUBLE
91181: EQUAL
91182: IFTRUE 91186
91184: GO 91193
91186: POP
// hHackChangeYourSide ; 7 :
91187: CALL 104156 0 0
91191: GO 91224
91193: LD_INT 7
91195: DOUBLE
91196: EQUAL
91197: IFTRUE 91201
91199: GO 91208
91201: POP
// hHackChangeUnitSide ; 8 :
91202: CALL 104198 0 0
91206: GO 91224
91208: LD_INT 8
91210: DOUBLE
91211: EQUAL
91212: IFTRUE 91216
91214: GO 91223
91216: POP
// hHackFog ; end ;
91217: CALL 104299 0 0
91221: GO 91224
91223: POP
// end ; end ;
91224: LD_VAR 0 7
91228: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
91229: GO 91231
91231: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91232: LD_STRING initStreamRollete();
91234: PPUSH
91235: CALL_OW 559
// InitStreamMode ;
91239: CALL 91251 0 0
// DefineStreamItems ( false ) ;
91243: LD_INT 0
91245: PPUSH
91246: CALL 91715 0 1
// end ;
91250: END
// function InitStreamMode ; begin
91251: LD_INT 0
91253: PPUSH
// streamModeActive := false ;
91254: LD_ADDR_EXP 94
91258: PUSH
91259: LD_INT 0
91261: ST_TO_ADDR
// normalCounter := 36 ;
91262: LD_ADDR_EXP 95
91266: PUSH
91267: LD_INT 36
91269: ST_TO_ADDR
// hardcoreCounter := 18 ;
91270: LD_ADDR_EXP 96
91274: PUSH
91275: LD_INT 18
91277: ST_TO_ADDR
// sRocket := false ;
91278: LD_ADDR_EXP 99
91282: PUSH
91283: LD_INT 0
91285: ST_TO_ADDR
// sSpeed := false ;
91286: LD_ADDR_EXP 98
91290: PUSH
91291: LD_INT 0
91293: ST_TO_ADDR
// sEngine := false ;
91294: LD_ADDR_EXP 100
91298: PUSH
91299: LD_INT 0
91301: ST_TO_ADDR
// sSpec := false ;
91302: LD_ADDR_EXP 97
91306: PUSH
91307: LD_INT 0
91309: ST_TO_ADDR
// sLevel := false ;
91310: LD_ADDR_EXP 101
91314: PUSH
91315: LD_INT 0
91317: ST_TO_ADDR
// sArmoury := false ;
91318: LD_ADDR_EXP 102
91322: PUSH
91323: LD_INT 0
91325: ST_TO_ADDR
// sRadar := false ;
91326: LD_ADDR_EXP 103
91330: PUSH
91331: LD_INT 0
91333: ST_TO_ADDR
// sBunker := false ;
91334: LD_ADDR_EXP 104
91338: PUSH
91339: LD_INT 0
91341: ST_TO_ADDR
// sHack := false ;
91342: LD_ADDR_EXP 105
91346: PUSH
91347: LD_INT 0
91349: ST_TO_ADDR
// sFire := false ;
91350: LD_ADDR_EXP 106
91354: PUSH
91355: LD_INT 0
91357: ST_TO_ADDR
// sRefresh := false ;
91358: LD_ADDR_EXP 107
91362: PUSH
91363: LD_INT 0
91365: ST_TO_ADDR
// sExp := false ;
91366: LD_ADDR_EXP 108
91370: PUSH
91371: LD_INT 0
91373: ST_TO_ADDR
// sDepot := false ;
91374: LD_ADDR_EXP 109
91378: PUSH
91379: LD_INT 0
91381: ST_TO_ADDR
// sFlag := false ;
91382: LD_ADDR_EXP 110
91386: PUSH
91387: LD_INT 0
91389: ST_TO_ADDR
// sKamikadze := false ;
91390: LD_ADDR_EXP 118
91394: PUSH
91395: LD_INT 0
91397: ST_TO_ADDR
// sTroll := false ;
91398: LD_ADDR_EXP 119
91402: PUSH
91403: LD_INT 0
91405: ST_TO_ADDR
// sSlow := false ;
91406: LD_ADDR_EXP 120
91410: PUSH
91411: LD_INT 0
91413: ST_TO_ADDR
// sLack := false ;
91414: LD_ADDR_EXP 121
91418: PUSH
91419: LD_INT 0
91421: ST_TO_ADDR
// sTank := false ;
91422: LD_ADDR_EXP 123
91426: PUSH
91427: LD_INT 0
91429: ST_TO_ADDR
// sRemote := false ;
91430: LD_ADDR_EXP 124
91434: PUSH
91435: LD_INT 0
91437: ST_TO_ADDR
// sPowell := false ;
91438: LD_ADDR_EXP 125
91442: PUSH
91443: LD_INT 0
91445: ST_TO_ADDR
// sTeleport := false ;
91446: LD_ADDR_EXP 128
91450: PUSH
91451: LD_INT 0
91453: ST_TO_ADDR
// sOilTower := false ;
91454: LD_ADDR_EXP 130
91458: PUSH
91459: LD_INT 0
91461: ST_TO_ADDR
// sShovel := false ;
91462: LD_ADDR_EXP 131
91466: PUSH
91467: LD_INT 0
91469: ST_TO_ADDR
// sSheik := false ;
91470: LD_ADDR_EXP 132
91474: PUSH
91475: LD_INT 0
91477: ST_TO_ADDR
// sEarthquake := false ;
91478: LD_ADDR_EXP 134
91482: PUSH
91483: LD_INT 0
91485: ST_TO_ADDR
// sAI := false ;
91486: LD_ADDR_EXP 135
91490: PUSH
91491: LD_INT 0
91493: ST_TO_ADDR
// sCargo := false ;
91494: LD_ADDR_EXP 138
91498: PUSH
91499: LD_INT 0
91501: ST_TO_ADDR
// sDLaser := false ;
91502: LD_ADDR_EXP 139
91506: PUSH
91507: LD_INT 0
91509: ST_TO_ADDR
// sExchange := false ;
91510: LD_ADDR_EXP 140
91514: PUSH
91515: LD_INT 0
91517: ST_TO_ADDR
// sFac := false ;
91518: LD_ADDR_EXP 141
91522: PUSH
91523: LD_INT 0
91525: ST_TO_ADDR
// sPower := false ;
91526: LD_ADDR_EXP 142
91530: PUSH
91531: LD_INT 0
91533: ST_TO_ADDR
// sRandom := false ;
91534: LD_ADDR_EXP 143
91538: PUSH
91539: LD_INT 0
91541: ST_TO_ADDR
// sShield := false ;
91542: LD_ADDR_EXP 144
91546: PUSH
91547: LD_INT 0
91549: ST_TO_ADDR
// sTime := false ;
91550: LD_ADDR_EXP 145
91554: PUSH
91555: LD_INT 0
91557: ST_TO_ADDR
// sTools := false ;
91558: LD_ADDR_EXP 146
91562: PUSH
91563: LD_INT 0
91565: ST_TO_ADDR
// sSold := false ;
91566: LD_ADDR_EXP 111
91570: PUSH
91571: LD_INT 0
91573: ST_TO_ADDR
// sDiff := false ;
91574: LD_ADDR_EXP 112
91578: PUSH
91579: LD_INT 0
91581: ST_TO_ADDR
// sFog := false ;
91582: LD_ADDR_EXP 115
91586: PUSH
91587: LD_INT 0
91589: ST_TO_ADDR
// sReset := false ;
91590: LD_ADDR_EXP 116
91594: PUSH
91595: LD_INT 0
91597: ST_TO_ADDR
// sSun := false ;
91598: LD_ADDR_EXP 117
91602: PUSH
91603: LD_INT 0
91605: ST_TO_ADDR
// sTiger := false ;
91606: LD_ADDR_EXP 113
91610: PUSH
91611: LD_INT 0
91613: ST_TO_ADDR
// sBomb := false ;
91614: LD_ADDR_EXP 114
91618: PUSH
91619: LD_INT 0
91621: ST_TO_ADDR
// sWound := false ;
91622: LD_ADDR_EXP 122
91626: PUSH
91627: LD_INT 0
91629: ST_TO_ADDR
// sBetray := false ;
91630: LD_ADDR_EXP 126
91634: PUSH
91635: LD_INT 0
91637: ST_TO_ADDR
// sContamin := false ;
91638: LD_ADDR_EXP 127
91642: PUSH
91643: LD_INT 0
91645: ST_TO_ADDR
// sOil := false ;
91646: LD_ADDR_EXP 129
91650: PUSH
91651: LD_INT 0
91653: ST_TO_ADDR
// sStu := false ;
91654: LD_ADDR_EXP 133
91658: PUSH
91659: LD_INT 0
91661: ST_TO_ADDR
// sBazooka := false ;
91662: LD_ADDR_EXP 136
91666: PUSH
91667: LD_INT 0
91669: ST_TO_ADDR
// sMortar := false ;
91670: LD_ADDR_EXP 137
91674: PUSH
91675: LD_INT 0
91677: ST_TO_ADDR
// sRanger := false ;
91678: LD_ADDR_EXP 147
91682: PUSH
91683: LD_INT 0
91685: ST_TO_ADDR
// sComputer := false ;
91686: LD_ADDR_EXP 148
91690: PUSH
91691: LD_INT 0
91693: ST_TO_ADDR
// s30 := false ;
91694: LD_ADDR_EXP 149
91698: PUSH
91699: LD_INT 0
91701: ST_TO_ADDR
// s60 := false ;
91702: LD_ADDR_EXP 150
91706: PUSH
91707: LD_INT 0
91709: ST_TO_ADDR
// end ;
91710: LD_VAR 0 1
91714: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91715: LD_INT 0
91717: PPUSH
91718: PPUSH
91719: PPUSH
91720: PPUSH
91721: PPUSH
91722: PPUSH
91723: PPUSH
// result := [ ] ;
91724: LD_ADDR_VAR 0 2
91728: PUSH
91729: EMPTY
91730: ST_TO_ADDR
// if campaign_id = 1 then
91731: LD_OWVAR 69
91735: PUSH
91736: LD_INT 1
91738: EQUAL
91739: IFFALSE 94905
// begin case mission_number of 1 :
91741: LD_OWVAR 70
91745: PUSH
91746: LD_INT 1
91748: DOUBLE
91749: EQUAL
91750: IFTRUE 91754
91752: GO 91830
91754: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91755: LD_ADDR_VAR 0 2
91759: PUSH
91760: LD_INT 2
91762: PUSH
91763: LD_INT 4
91765: PUSH
91766: LD_INT 11
91768: PUSH
91769: LD_INT 12
91771: PUSH
91772: LD_INT 15
91774: PUSH
91775: LD_INT 16
91777: PUSH
91778: LD_INT 22
91780: PUSH
91781: LD_INT 23
91783: PUSH
91784: LD_INT 26
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: PUSH
91798: LD_INT 101
91800: PUSH
91801: LD_INT 102
91803: PUSH
91804: LD_INT 106
91806: PUSH
91807: LD_INT 116
91809: PUSH
91810: LD_INT 117
91812: PUSH
91813: LD_INT 118
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: ST_TO_ADDR
91828: GO 94903
91830: LD_INT 2
91832: DOUBLE
91833: EQUAL
91834: IFTRUE 91838
91836: GO 91922
91838: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91839: LD_ADDR_VAR 0 2
91843: PUSH
91844: LD_INT 2
91846: PUSH
91847: LD_INT 4
91849: PUSH
91850: LD_INT 11
91852: PUSH
91853: LD_INT 12
91855: PUSH
91856: LD_INT 15
91858: PUSH
91859: LD_INT 16
91861: PUSH
91862: LD_INT 22
91864: PUSH
91865: LD_INT 23
91867: PUSH
91868: LD_INT 26
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 101
91884: PUSH
91885: LD_INT 102
91887: PUSH
91888: LD_INT 105
91890: PUSH
91891: LD_INT 106
91893: PUSH
91894: LD_INT 108
91896: PUSH
91897: LD_INT 116
91899: PUSH
91900: LD_INT 117
91902: PUSH
91903: LD_INT 118
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: ST_TO_ADDR
91920: GO 94903
91922: LD_INT 3
91924: DOUBLE
91925: EQUAL
91926: IFTRUE 91930
91928: GO 92018
91930: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91931: LD_ADDR_VAR 0 2
91935: PUSH
91936: LD_INT 2
91938: PUSH
91939: LD_INT 4
91941: PUSH
91942: LD_INT 5
91944: PUSH
91945: LD_INT 11
91947: PUSH
91948: LD_INT 12
91950: PUSH
91951: LD_INT 15
91953: PUSH
91954: LD_INT 16
91956: PUSH
91957: LD_INT 22
91959: PUSH
91960: LD_INT 26
91962: PUSH
91963: LD_INT 36
91965: PUSH
91966: EMPTY
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: PUSH
91978: LD_INT 101
91980: PUSH
91981: LD_INT 102
91983: PUSH
91984: LD_INT 105
91986: PUSH
91987: LD_INT 106
91989: PUSH
91990: LD_INT 108
91992: PUSH
91993: LD_INT 116
91995: PUSH
91996: LD_INT 117
91998: PUSH
91999: LD_INT 118
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: ST_TO_ADDR
92016: GO 94903
92018: LD_INT 4
92020: DOUBLE
92021: EQUAL
92022: IFTRUE 92026
92024: GO 92122
92026: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92027: LD_ADDR_VAR 0 2
92031: PUSH
92032: LD_INT 2
92034: PUSH
92035: LD_INT 4
92037: PUSH
92038: LD_INT 5
92040: PUSH
92041: LD_INT 8
92043: PUSH
92044: LD_INT 11
92046: PUSH
92047: LD_INT 12
92049: PUSH
92050: LD_INT 15
92052: PUSH
92053: LD_INT 16
92055: PUSH
92056: LD_INT 22
92058: PUSH
92059: LD_INT 23
92061: PUSH
92062: LD_INT 26
92064: PUSH
92065: LD_INT 36
92067: PUSH
92068: EMPTY
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: PUSH
92082: LD_INT 101
92084: PUSH
92085: LD_INT 102
92087: PUSH
92088: LD_INT 105
92090: PUSH
92091: LD_INT 106
92093: PUSH
92094: LD_INT 108
92096: PUSH
92097: LD_INT 116
92099: PUSH
92100: LD_INT 117
92102: PUSH
92103: LD_INT 118
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: LIST
92113: LIST
92114: LIST
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: ST_TO_ADDR
92120: GO 94903
92122: LD_INT 5
92124: DOUBLE
92125: EQUAL
92126: IFTRUE 92130
92128: GO 92242
92130: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92131: LD_ADDR_VAR 0 2
92135: PUSH
92136: LD_INT 2
92138: PUSH
92139: LD_INT 4
92141: PUSH
92142: LD_INT 5
92144: PUSH
92145: LD_INT 6
92147: PUSH
92148: LD_INT 8
92150: PUSH
92151: LD_INT 11
92153: PUSH
92154: LD_INT 12
92156: PUSH
92157: LD_INT 15
92159: PUSH
92160: LD_INT 16
92162: PUSH
92163: LD_INT 22
92165: PUSH
92166: LD_INT 23
92168: PUSH
92169: LD_INT 25
92171: PUSH
92172: LD_INT 26
92174: PUSH
92175: LD_INT 36
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 101
92196: PUSH
92197: LD_INT 102
92199: PUSH
92200: LD_INT 105
92202: PUSH
92203: LD_INT 106
92205: PUSH
92206: LD_INT 108
92208: PUSH
92209: LD_INT 109
92211: PUSH
92212: LD_INT 112
92214: PUSH
92215: LD_INT 116
92217: PUSH
92218: LD_INT 117
92220: PUSH
92221: LD_INT 118
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: ST_TO_ADDR
92240: GO 94903
92242: LD_INT 6
92244: DOUBLE
92245: EQUAL
92246: IFTRUE 92250
92248: GO 92382
92250: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92251: LD_ADDR_VAR 0 2
92255: PUSH
92256: LD_INT 2
92258: PUSH
92259: LD_INT 4
92261: PUSH
92262: LD_INT 5
92264: PUSH
92265: LD_INT 6
92267: PUSH
92268: LD_INT 8
92270: PUSH
92271: LD_INT 11
92273: PUSH
92274: LD_INT 12
92276: PUSH
92277: LD_INT 15
92279: PUSH
92280: LD_INT 16
92282: PUSH
92283: LD_INT 20
92285: PUSH
92286: LD_INT 21
92288: PUSH
92289: LD_INT 22
92291: PUSH
92292: LD_INT 23
92294: PUSH
92295: LD_INT 25
92297: PUSH
92298: LD_INT 26
92300: PUSH
92301: LD_INT 30
92303: PUSH
92304: LD_INT 31
92306: PUSH
92307: LD_INT 32
92309: PUSH
92310: LD_INT 36
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 101
92336: PUSH
92337: LD_INT 102
92339: PUSH
92340: LD_INT 105
92342: PUSH
92343: LD_INT 106
92345: PUSH
92346: LD_INT 108
92348: PUSH
92349: LD_INT 109
92351: PUSH
92352: LD_INT 112
92354: PUSH
92355: LD_INT 116
92357: PUSH
92358: LD_INT 117
92360: PUSH
92361: LD_INT 118
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: ST_TO_ADDR
92380: GO 94903
92382: LD_INT 7
92384: DOUBLE
92385: EQUAL
92386: IFTRUE 92390
92388: GO 92502
92390: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92391: LD_ADDR_VAR 0 2
92395: PUSH
92396: LD_INT 2
92398: PUSH
92399: LD_INT 4
92401: PUSH
92402: LD_INT 5
92404: PUSH
92405: LD_INT 7
92407: PUSH
92408: LD_INT 11
92410: PUSH
92411: LD_INT 12
92413: PUSH
92414: LD_INT 15
92416: PUSH
92417: LD_INT 16
92419: PUSH
92420: LD_INT 20
92422: PUSH
92423: LD_INT 21
92425: PUSH
92426: LD_INT 22
92428: PUSH
92429: LD_INT 23
92431: PUSH
92432: LD_INT 25
92434: PUSH
92435: LD_INT 26
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 101
92456: PUSH
92457: LD_INT 102
92459: PUSH
92460: LD_INT 103
92462: PUSH
92463: LD_INT 105
92465: PUSH
92466: LD_INT 106
92468: PUSH
92469: LD_INT 108
92471: PUSH
92472: LD_INT 112
92474: PUSH
92475: LD_INT 116
92477: PUSH
92478: LD_INT 117
92480: PUSH
92481: LD_INT 118
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: ST_TO_ADDR
92500: GO 94903
92502: LD_INT 8
92504: DOUBLE
92505: EQUAL
92506: IFTRUE 92510
92508: GO 92650
92510: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92511: LD_ADDR_VAR 0 2
92515: PUSH
92516: LD_INT 2
92518: PUSH
92519: LD_INT 4
92521: PUSH
92522: LD_INT 5
92524: PUSH
92525: LD_INT 6
92527: PUSH
92528: LD_INT 7
92530: PUSH
92531: LD_INT 8
92533: PUSH
92534: LD_INT 11
92536: PUSH
92537: LD_INT 12
92539: PUSH
92540: LD_INT 15
92542: PUSH
92543: LD_INT 16
92545: PUSH
92546: LD_INT 20
92548: PUSH
92549: LD_INT 21
92551: PUSH
92552: LD_INT 22
92554: PUSH
92555: LD_INT 23
92557: PUSH
92558: LD_INT 25
92560: PUSH
92561: LD_INT 26
92563: PUSH
92564: LD_INT 30
92566: PUSH
92567: LD_INT 31
92569: PUSH
92570: LD_INT 32
92572: PUSH
92573: LD_INT 36
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 101
92600: PUSH
92601: LD_INT 102
92603: PUSH
92604: LD_INT 103
92606: PUSH
92607: LD_INT 105
92609: PUSH
92610: LD_INT 106
92612: PUSH
92613: LD_INT 108
92615: PUSH
92616: LD_INT 109
92618: PUSH
92619: LD_INT 112
92621: PUSH
92622: LD_INT 116
92624: PUSH
92625: LD_INT 117
92627: PUSH
92628: LD_INT 118
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: PUSH
92644: EMPTY
92645: LIST
92646: LIST
92647: ST_TO_ADDR
92648: GO 94903
92650: LD_INT 9
92652: DOUBLE
92653: EQUAL
92654: IFTRUE 92658
92656: GO 92806
92658: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92659: LD_ADDR_VAR 0 2
92663: PUSH
92664: LD_INT 2
92666: PUSH
92667: LD_INT 4
92669: PUSH
92670: LD_INT 5
92672: PUSH
92673: LD_INT 6
92675: PUSH
92676: LD_INT 7
92678: PUSH
92679: LD_INT 8
92681: PUSH
92682: LD_INT 11
92684: PUSH
92685: LD_INT 12
92687: PUSH
92688: LD_INT 15
92690: PUSH
92691: LD_INT 16
92693: PUSH
92694: LD_INT 20
92696: PUSH
92697: LD_INT 21
92699: PUSH
92700: LD_INT 22
92702: PUSH
92703: LD_INT 23
92705: PUSH
92706: LD_INT 25
92708: PUSH
92709: LD_INT 26
92711: PUSH
92712: LD_INT 28
92714: PUSH
92715: LD_INT 30
92717: PUSH
92718: LD_INT 31
92720: PUSH
92721: LD_INT 32
92723: PUSH
92724: LD_INT 36
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: LIST
92748: LIST
92749: PUSH
92750: LD_INT 101
92752: PUSH
92753: LD_INT 102
92755: PUSH
92756: LD_INT 103
92758: PUSH
92759: LD_INT 105
92761: PUSH
92762: LD_INT 106
92764: PUSH
92765: LD_INT 108
92767: PUSH
92768: LD_INT 109
92770: PUSH
92771: LD_INT 112
92773: PUSH
92774: LD_INT 114
92776: PUSH
92777: LD_INT 116
92779: PUSH
92780: LD_INT 117
92782: PUSH
92783: LD_INT 118
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: ST_TO_ADDR
92804: GO 94903
92806: LD_INT 10
92808: DOUBLE
92809: EQUAL
92810: IFTRUE 92814
92812: GO 93010
92814: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92815: LD_ADDR_VAR 0 2
92819: PUSH
92820: LD_INT 2
92822: PUSH
92823: LD_INT 4
92825: PUSH
92826: LD_INT 5
92828: PUSH
92829: LD_INT 6
92831: PUSH
92832: LD_INT 7
92834: PUSH
92835: LD_INT 8
92837: PUSH
92838: LD_INT 9
92840: PUSH
92841: LD_INT 10
92843: PUSH
92844: LD_INT 11
92846: PUSH
92847: LD_INT 12
92849: PUSH
92850: LD_INT 13
92852: PUSH
92853: LD_INT 14
92855: PUSH
92856: LD_INT 15
92858: PUSH
92859: LD_INT 16
92861: PUSH
92862: LD_INT 17
92864: PUSH
92865: LD_INT 18
92867: PUSH
92868: LD_INT 19
92870: PUSH
92871: LD_INT 20
92873: PUSH
92874: LD_INT 21
92876: PUSH
92877: LD_INT 22
92879: PUSH
92880: LD_INT 23
92882: PUSH
92883: LD_INT 24
92885: PUSH
92886: LD_INT 25
92888: PUSH
92889: LD_INT 26
92891: PUSH
92892: LD_INT 28
92894: PUSH
92895: LD_INT 30
92897: PUSH
92898: LD_INT 31
92900: PUSH
92901: LD_INT 32
92903: PUSH
92904: LD_INT 36
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 101
92940: PUSH
92941: LD_INT 102
92943: PUSH
92944: LD_INT 103
92946: PUSH
92947: LD_INT 104
92949: PUSH
92950: LD_INT 105
92952: PUSH
92953: LD_INT 106
92955: PUSH
92956: LD_INT 107
92958: PUSH
92959: LD_INT 108
92961: PUSH
92962: LD_INT 109
92964: PUSH
92965: LD_INT 110
92967: PUSH
92968: LD_INT 111
92970: PUSH
92971: LD_INT 112
92973: PUSH
92974: LD_INT 114
92976: PUSH
92977: LD_INT 116
92979: PUSH
92980: LD_INT 117
92982: PUSH
92983: LD_INT 118
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: ST_TO_ADDR
93008: GO 94903
93010: LD_INT 11
93012: DOUBLE
93013: EQUAL
93014: IFTRUE 93018
93016: GO 93222
93018: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93019: LD_ADDR_VAR 0 2
93023: PUSH
93024: LD_INT 2
93026: PUSH
93027: LD_INT 3
93029: PUSH
93030: LD_INT 4
93032: PUSH
93033: LD_INT 5
93035: PUSH
93036: LD_INT 6
93038: PUSH
93039: LD_INT 7
93041: PUSH
93042: LD_INT 8
93044: PUSH
93045: LD_INT 9
93047: PUSH
93048: LD_INT 10
93050: PUSH
93051: LD_INT 11
93053: PUSH
93054: LD_INT 12
93056: PUSH
93057: LD_INT 13
93059: PUSH
93060: LD_INT 14
93062: PUSH
93063: LD_INT 15
93065: PUSH
93066: LD_INT 16
93068: PUSH
93069: LD_INT 17
93071: PUSH
93072: LD_INT 18
93074: PUSH
93075: LD_INT 19
93077: PUSH
93078: LD_INT 20
93080: PUSH
93081: LD_INT 21
93083: PUSH
93084: LD_INT 22
93086: PUSH
93087: LD_INT 23
93089: PUSH
93090: LD_INT 24
93092: PUSH
93093: LD_INT 25
93095: PUSH
93096: LD_INT 26
93098: PUSH
93099: LD_INT 28
93101: PUSH
93102: LD_INT 30
93104: PUSH
93105: LD_INT 31
93107: PUSH
93108: LD_INT 32
93110: PUSH
93111: LD_INT 34
93113: PUSH
93114: LD_INT 36
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: PUSH
93150: LD_INT 101
93152: PUSH
93153: LD_INT 102
93155: PUSH
93156: LD_INT 103
93158: PUSH
93159: LD_INT 104
93161: PUSH
93162: LD_INT 105
93164: PUSH
93165: LD_INT 106
93167: PUSH
93168: LD_INT 107
93170: PUSH
93171: LD_INT 108
93173: PUSH
93174: LD_INT 109
93176: PUSH
93177: LD_INT 110
93179: PUSH
93180: LD_INT 111
93182: PUSH
93183: LD_INT 112
93185: PUSH
93186: LD_INT 114
93188: PUSH
93189: LD_INT 116
93191: PUSH
93192: LD_INT 117
93194: PUSH
93195: LD_INT 118
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: ST_TO_ADDR
93220: GO 94903
93222: LD_INT 12
93224: DOUBLE
93225: EQUAL
93226: IFTRUE 93230
93228: GO 93450
93230: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93231: LD_ADDR_VAR 0 2
93235: PUSH
93236: LD_INT 1
93238: PUSH
93239: LD_INT 2
93241: PUSH
93242: LD_INT 3
93244: PUSH
93245: LD_INT 4
93247: PUSH
93248: LD_INT 5
93250: PUSH
93251: LD_INT 6
93253: PUSH
93254: LD_INT 7
93256: PUSH
93257: LD_INT 8
93259: PUSH
93260: LD_INT 9
93262: PUSH
93263: LD_INT 10
93265: PUSH
93266: LD_INT 11
93268: PUSH
93269: LD_INT 12
93271: PUSH
93272: LD_INT 13
93274: PUSH
93275: LD_INT 14
93277: PUSH
93278: LD_INT 15
93280: PUSH
93281: LD_INT 16
93283: PUSH
93284: LD_INT 17
93286: PUSH
93287: LD_INT 18
93289: PUSH
93290: LD_INT 19
93292: PUSH
93293: LD_INT 20
93295: PUSH
93296: LD_INT 21
93298: PUSH
93299: LD_INT 22
93301: PUSH
93302: LD_INT 23
93304: PUSH
93305: LD_INT 24
93307: PUSH
93308: LD_INT 25
93310: PUSH
93311: LD_INT 26
93313: PUSH
93314: LD_INT 27
93316: PUSH
93317: LD_INT 28
93319: PUSH
93320: LD_INT 30
93322: PUSH
93323: LD_INT 31
93325: PUSH
93326: LD_INT 32
93328: PUSH
93329: LD_INT 33
93331: PUSH
93332: LD_INT 34
93334: PUSH
93335: LD_INT 36
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 101
93376: PUSH
93377: LD_INT 102
93379: PUSH
93380: LD_INT 103
93382: PUSH
93383: LD_INT 104
93385: PUSH
93386: LD_INT 105
93388: PUSH
93389: LD_INT 106
93391: PUSH
93392: LD_INT 107
93394: PUSH
93395: LD_INT 108
93397: PUSH
93398: LD_INT 109
93400: PUSH
93401: LD_INT 110
93403: PUSH
93404: LD_INT 111
93406: PUSH
93407: LD_INT 112
93409: PUSH
93410: LD_INT 113
93412: PUSH
93413: LD_INT 114
93415: PUSH
93416: LD_INT 116
93418: PUSH
93419: LD_INT 117
93421: PUSH
93422: LD_INT 118
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: ST_TO_ADDR
93448: GO 94903
93450: LD_INT 13
93452: DOUBLE
93453: EQUAL
93454: IFTRUE 93458
93456: GO 93666
93458: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93459: LD_ADDR_VAR 0 2
93463: PUSH
93464: LD_INT 1
93466: PUSH
93467: LD_INT 2
93469: PUSH
93470: LD_INT 3
93472: PUSH
93473: LD_INT 4
93475: PUSH
93476: LD_INT 5
93478: PUSH
93479: LD_INT 8
93481: PUSH
93482: LD_INT 9
93484: PUSH
93485: LD_INT 10
93487: PUSH
93488: LD_INT 11
93490: PUSH
93491: LD_INT 12
93493: PUSH
93494: LD_INT 14
93496: PUSH
93497: LD_INT 15
93499: PUSH
93500: LD_INT 16
93502: PUSH
93503: LD_INT 17
93505: PUSH
93506: LD_INT 18
93508: PUSH
93509: LD_INT 19
93511: PUSH
93512: LD_INT 20
93514: PUSH
93515: LD_INT 21
93517: PUSH
93518: LD_INT 22
93520: PUSH
93521: LD_INT 23
93523: PUSH
93524: LD_INT 24
93526: PUSH
93527: LD_INT 25
93529: PUSH
93530: LD_INT 26
93532: PUSH
93533: LD_INT 27
93535: PUSH
93536: LD_INT 28
93538: PUSH
93539: LD_INT 30
93541: PUSH
93542: LD_INT 31
93544: PUSH
93545: LD_INT 32
93547: PUSH
93548: LD_INT 33
93550: PUSH
93551: LD_INT 34
93553: PUSH
93554: LD_INT 36
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: PUSH
93590: LD_INT 101
93592: PUSH
93593: LD_INT 102
93595: PUSH
93596: LD_INT 103
93598: PUSH
93599: LD_INT 104
93601: PUSH
93602: LD_INT 105
93604: PUSH
93605: LD_INT 106
93607: PUSH
93608: LD_INT 107
93610: PUSH
93611: LD_INT 108
93613: PUSH
93614: LD_INT 109
93616: PUSH
93617: LD_INT 110
93619: PUSH
93620: LD_INT 111
93622: PUSH
93623: LD_INT 112
93625: PUSH
93626: LD_INT 113
93628: PUSH
93629: LD_INT 114
93631: PUSH
93632: LD_INT 116
93634: PUSH
93635: LD_INT 117
93637: PUSH
93638: LD_INT 118
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: ST_TO_ADDR
93664: GO 94903
93666: LD_INT 14
93668: DOUBLE
93669: EQUAL
93670: IFTRUE 93674
93672: GO 93898
93674: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93675: LD_ADDR_VAR 0 2
93679: PUSH
93680: LD_INT 1
93682: PUSH
93683: LD_INT 2
93685: PUSH
93686: LD_INT 3
93688: PUSH
93689: LD_INT 4
93691: PUSH
93692: LD_INT 5
93694: PUSH
93695: LD_INT 6
93697: PUSH
93698: LD_INT 7
93700: PUSH
93701: LD_INT 8
93703: PUSH
93704: LD_INT 9
93706: PUSH
93707: LD_INT 10
93709: PUSH
93710: LD_INT 11
93712: PUSH
93713: LD_INT 12
93715: PUSH
93716: LD_INT 13
93718: PUSH
93719: LD_INT 14
93721: PUSH
93722: LD_INT 15
93724: PUSH
93725: LD_INT 16
93727: PUSH
93728: LD_INT 17
93730: PUSH
93731: LD_INT 18
93733: PUSH
93734: LD_INT 19
93736: PUSH
93737: LD_INT 20
93739: PUSH
93740: LD_INT 21
93742: PUSH
93743: LD_INT 22
93745: PUSH
93746: LD_INT 23
93748: PUSH
93749: LD_INT 24
93751: PUSH
93752: LD_INT 25
93754: PUSH
93755: LD_INT 26
93757: PUSH
93758: LD_INT 27
93760: PUSH
93761: LD_INT 28
93763: PUSH
93764: LD_INT 29
93766: PUSH
93767: LD_INT 30
93769: PUSH
93770: LD_INT 31
93772: PUSH
93773: LD_INT 32
93775: PUSH
93776: LD_INT 33
93778: PUSH
93779: LD_INT 34
93781: PUSH
93782: LD_INT 36
93784: PUSH
93785: EMPTY
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: PUSH
93822: LD_INT 101
93824: PUSH
93825: LD_INT 102
93827: PUSH
93828: LD_INT 103
93830: PUSH
93831: LD_INT 104
93833: PUSH
93834: LD_INT 105
93836: PUSH
93837: LD_INT 106
93839: PUSH
93840: LD_INT 107
93842: PUSH
93843: LD_INT 108
93845: PUSH
93846: LD_INT 109
93848: PUSH
93849: LD_INT 110
93851: PUSH
93852: LD_INT 111
93854: PUSH
93855: LD_INT 112
93857: PUSH
93858: LD_INT 113
93860: PUSH
93861: LD_INT 114
93863: PUSH
93864: LD_INT 116
93866: PUSH
93867: LD_INT 117
93869: PUSH
93870: LD_INT 118
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: ST_TO_ADDR
93896: GO 94903
93898: LD_INT 15
93900: DOUBLE
93901: EQUAL
93902: IFTRUE 93906
93904: GO 94130
93906: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93907: LD_ADDR_VAR 0 2
93911: PUSH
93912: LD_INT 1
93914: PUSH
93915: LD_INT 2
93917: PUSH
93918: LD_INT 3
93920: PUSH
93921: LD_INT 4
93923: PUSH
93924: LD_INT 5
93926: PUSH
93927: LD_INT 6
93929: PUSH
93930: LD_INT 7
93932: PUSH
93933: LD_INT 8
93935: PUSH
93936: LD_INT 9
93938: PUSH
93939: LD_INT 10
93941: PUSH
93942: LD_INT 11
93944: PUSH
93945: LD_INT 12
93947: PUSH
93948: LD_INT 13
93950: PUSH
93951: LD_INT 14
93953: PUSH
93954: LD_INT 15
93956: PUSH
93957: LD_INT 16
93959: PUSH
93960: LD_INT 17
93962: PUSH
93963: LD_INT 18
93965: PUSH
93966: LD_INT 19
93968: PUSH
93969: LD_INT 20
93971: PUSH
93972: LD_INT 21
93974: PUSH
93975: LD_INT 22
93977: PUSH
93978: LD_INT 23
93980: PUSH
93981: LD_INT 24
93983: PUSH
93984: LD_INT 25
93986: PUSH
93987: LD_INT 26
93989: PUSH
93990: LD_INT 27
93992: PUSH
93993: LD_INT 28
93995: PUSH
93996: LD_INT 29
93998: PUSH
93999: LD_INT 30
94001: PUSH
94002: LD_INT 31
94004: PUSH
94005: LD_INT 32
94007: PUSH
94008: LD_INT 33
94010: PUSH
94011: LD_INT 34
94013: PUSH
94014: LD_INT 36
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 101
94056: PUSH
94057: LD_INT 102
94059: PUSH
94060: LD_INT 103
94062: PUSH
94063: LD_INT 104
94065: PUSH
94066: LD_INT 105
94068: PUSH
94069: LD_INT 106
94071: PUSH
94072: LD_INT 107
94074: PUSH
94075: LD_INT 108
94077: PUSH
94078: LD_INT 109
94080: PUSH
94081: LD_INT 110
94083: PUSH
94084: LD_INT 111
94086: PUSH
94087: LD_INT 112
94089: PUSH
94090: LD_INT 113
94092: PUSH
94093: LD_INT 114
94095: PUSH
94096: LD_INT 116
94098: PUSH
94099: LD_INT 117
94101: PUSH
94102: LD_INT 118
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: ST_TO_ADDR
94128: GO 94903
94130: LD_INT 16
94132: DOUBLE
94133: EQUAL
94134: IFTRUE 94138
94136: GO 94274
94138: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94139: LD_ADDR_VAR 0 2
94143: PUSH
94144: LD_INT 2
94146: PUSH
94147: LD_INT 4
94149: PUSH
94150: LD_INT 5
94152: PUSH
94153: LD_INT 7
94155: PUSH
94156: LD_INT 11
94158: PUSH
94159: LD_INT 12
94161: PUSH
94162: LD_INT 15
94164: PUSH
94165: LD_INT 16
94167: PUSH
94168: LD_INT 20
94170: PUSH
94171: LD_INT 21
94173: PUSH
94174: LD_INT 22
94176: PUSH
94177: LD_INT 23
94179: PUSH
94180: LD_INT 25
94182: PUSH
94183: LD_INT 26
94185: PUSH
94186: LD_INT 30
94188: PUSH
94189: LD_INT 31
94191: PUSH
94192: LD_INT 32
94194: PUSH
94195: LD_INT 33
94197: PUSH
94198: LD_INT 34
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: PUSH
94222: LD_INT 101
94224: PUSH
94225: LD_INT 102
94227: PUSH
94228: LD_INT 103
94230: PUSH
94231: LD_INT 106
94233: PUSH
94234: LD_INT 108
94236: PUSH
94237: LD_INT 112
94239: PUSH
94240: LD_INT 113
94242: PUSH
94243: LD_INT 114
94245: PUSH
94246: LD_INT 116
94248: PUSH
94249: LD_INT 117
94251: PUSH
94252: LD_INT 118
94254: PUSH
94255: EMPTY
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: ST_TO_ADDR
94272: GO 94903
94274: LD_INT 17
94276: DOUBLE
94277: EQUAL
94278: IFTRUE 94282
94280: GO 94506
94282: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94283: LD_ADDR_VAR 0 2
94287: PUSH
94288: LD_INT 1
94290: PUSH
94291: LD_INT 2
94293: PUSH
94294: LD_INT 3
94296: PUSH
94297: LD_INT 4
94299: PUSH
94300: LD_INT 5
94302: PUSH
94303: LD_INT 6
94305: PUSH
94306: LD_INT 7
94308: PUSH
94309: LD_INT 8
94311: PUSH
94312: LD_INT 9
94314: PUSH
94315: LD_INT 10
94317: PUSH
94318: LD_INT 11
94320: PUSH
94321: LD_INT 12
94323: PUSH
94324: LD_INT 13
94326: PUSH
94327: LD_INT 14
94329: PUSH
94330: LD_INT 15
94332: PUSH
94333: LD_INT 16
94335: PUSH
94336: LD_INT 17
94338: PUSH
94339: LD_INT 18
94341: PUSH
94342: LD_INT 19
94344: PUSH
94345: LD_INT 20
94347: PUSH
94348: LD_INT 21
94350: PUSH
94351: LD_INT 22
94353: PUSH
94354: LD_INT 23
94356: PUSH
94357: LD_INT 24
94359: PUSH
94360: LD_INT 25
94362: PUSH
94363: LD_INT 26
94365: PUSH
94366: LD_INT 27
94368: PUSH
94369: LD_INT 28
94371: PUSH
94372: LD_INT 29
94374: PUSH
94375: LD_INT 30
94377: PUSH
94378: LD_INT 31
94380: PUSH
94381: LD_INT 32
94383: PUSH
94384: LD_INT 33
94386: PUSH
94387: LD_INT 34
94389: PUSH
94390: LD_INT 36
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 101
94432: PUSH
94433: LD_INT 102
94435: PUSH
94436: LD_INT 103
94438: PUSH
94439: LD_INT 104
94441: PUSH
94442: LD_INT 105
94444: PUSH
94445: LD_INT 106
94447: PUSH
94448: LD_INT 107
94450: PUSH
94451: LD_INT 108
94453: PUSH
94454: LD_INT 109
94456: PUSH
94457: LD_INT 110
94459: PUSH
94460: LD_INT 111
94462: PUSH
94463: LD_INT 112
94465: PUSH
94466: LD_INT 113
94468: PUSH
94469: LD_INT 114
94471: PUSH
94472: LD_INT 116
94474: PUSH
94475: LD_INT 117
94477: PUSH
94478: LD_INT 118
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: ST_TO_ADDR
94504: GO 94903
94506: LD_INT 18
94508: DOUBLE
94509: EQUAL
94510: IFTRUE 94514
94512: GO 94662
94514: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94515: LD_ADDR_VAR 0 2
94519: PUSH
94520: LD_INT 2
94522: PUSH
94523: LD_INT 4
94525: PUSH
94526: LD_INT 5
94528: PUSH
94529: LD_INT 7
94531: PUSH
94532: LD_INT 11
94534: PUSH
94535: LD_INT 12
94537: PUSH
94538: LD_INT 15
94540: PUSH
94541: LD_INT 16
94543: PUSH
94544: LD_INT 20
94546: PUSH
94547: LD_INT 21
94549: PUSH
94550: LD_INT 22
94552: PUSH
94553: LD_INT 23
94555: PUSH
94556: LD_INT 25
94558: PUSH
94559: LD_INT 26
94561: PUSH
94562: LD_INT 30
94564: PUSH
94565: LD_INT 31
94567: PUSH
94568: LD_INT 32
94570: PUSH
94571: LD_INT 33
94573: PUSH
94574: LD_INT 34
94576: PUSH
94577: LD_INT 35
94579: PUSH
94580: LD_INT 36
94582: PUSH
94583: EMPTY
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 101
94608: PUSH
94609: LD_INT 102
94611: PUSH
94612: LD_INT 103
94614: PUSH
94615: LD_INT 106
94617: PUSH
94618: LD_INT 108
94620: PUSH
94621: LD_INT 112
94623: PUSH
94624: LD_INT 113
94626: PUSH
94627: LD_INT 114
94629: PUSH
94630: LD_INT 115
94632: PUSH
94633: LD_INT 116
94635: PUSH
94636: LD_INT 117
94638: PUSH
94639: LD_INT 118
94641: PUSH
94642: EMPTY
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: PUSH
94656: EMPTY
94657: LIST
94658: LIST
94659: ST_TO_ADDR
94660: GO 94903
94662: LD_INT 19
94664: DOUBLE
94665: EQUAL
94666: IFTRUE 94670
94668: GO 94902
94670: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94671: LD_ADDR_VAR 0 2
94675: PUSH
94676: LD_INT 1
94678: PUSH
94679: LD_INT 2
94681: PUSH
94682: LD_INT 3
94684: PUSH
94685: LD_INT 4
94687: PUSH
94688: LD_INT 5
94690: PUSH
94691: LD_INT 6
94693: PUSH
94694: LD_INT 7
94696: PUSH
94697: LD_INT 8
94699: PUSH
94700: LD_INT 9
94702: PUSH
94703: LD_INT 10
94705: PUSH
94706: LD_INT 11
94708: PUSH
94709: LD_INT 12
94711: PUSH
94712: LD_INT 13
94714: PUSH
94715: LD_INT 14
94717: PUSH
94718: LD_INT 15
94720: PUSH
94721: LD_INT 16
94723: PUSH
94724: LD_INT 17
94726: PUSH
94727: LD_INT 18
94729: PUSH
94730: LD_INT 19
94732: PUSH
94733: LD_INT 20
94735: PUSH
94736: LD_INT 21
94738: PUSH
94739: LD_INT 22
94741: PUSH
94742: LD_INT 23
94744: PUSH
94745: LD_INT 24
94747: PUSH
94748: LD_INT 25
94750: PUSH
94751: LD_INT 26
94753: PUSH
94754: LD_INT 27
94756: PUSH
94757: LD_INT 28
94759: PUSH
94760: LD_INT 29
94762: PUSH
94763: LD_INT 30
94765: PUSH
94766: LD_INT 31
94768: PUSH
94769: LD_INT 32
94771: PUSH
94772: LD_INT 33
94774: PUSH
94775: LD_INT 34
94777: PUSH
94778: LD_INT 35
94780: PUSH
94781: LD_INT 36
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 101
94824: PUSH
94825: LD_INT 102
94827: PUSH
94828: LD_INT 103
94830: PUSH
94831: LD_INT 104
94833: PUSH
94834: LD_INT 105
94836: PUSH
94837: LD_INT 106
94839: PUSH
94840: LD_INT 107
94842: PUSH
94843: LD_INT 108
94845: PUSH
94846: LD_INT 109
94848: PUSH
94849: LD_INT 110
94851: PUSH
94852: LD_INT 111
94854: PUSH
94855: LD_INT 112
94857: PUSH
94858: LD_INT 113
94860: PUSH
94861: LD_INT 114
94863: PUSH
94864: LD_INT 115
94866: PUSH
94867: LD_INT 116
94869: PUSH
94870: LD_INT 117
94872: PUSH
94873: LD_INT 118
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: ST_TO_ADDR
94900: GO 94903
94902: POP
// end else
94903: GO 95134
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94905: LD_ADDR_VAR 0 2
94909: PUSH
94910: LD_INT 1
94912: PUSH
94913: LD_INT 2
94915: PUSH
94916: LD_INT 3
94918: PUSH
94919: LD_INT 4
94921: PUSH
94922: LD_INT 5
94924: PUSH
94925: LD_INT 6
94927: PUSH
94928: LD_INT 7
94930: PUSH
94931: LD_INT 8
94933: PUSH
94934: LD_INT 9
94936: PUSH
94937: LD_INT 10
94939: PUSH
94940: LD_INT 11
94942: PUSH
94943: LD_INT 12
94945: PUSH
94946: LD_INT 13
94948: PUSH
94949: LD_INT 14
94951: PUSH
94952: LD_INT 15
94954: PUSH
94955: LD_INT 16
94957: PUSH
94958: LD_INT 17
94960: PUSH
94961: LD_INT 18
94963: PUSH
94964: LD_INT 19
94966: PUSH
94967: LD_INT 20
94969: PUSH
94970: LD_INT 21
94972: PUSH
94973: LD_INT 22
94975: PUSH
94976: LD_INT 23
94978: PUSH
94979: LD_INT 24
94981: PUSH
94982: LD_INT 25
94984: PUSH
94985: LD_INT 26
94987: PUSH
94988: LD_INT 27
94990: PUSH
94991: LD_INT 28
94993: PUSH
94994: LD_INT 29
94996: PUSH
94997: LD_INT 30
94999: PUSH
95000: LD_INT 31
95002: PUSH
95003: LD_INT 32
95005: PUSH
95006: LD_INT 33
95008: PUSH
95009: LD_INT 34
95011: PUSH
95012: LD_INT 35
95014: PUSH
95015: LD_INT 36
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: PUSH
95056: LD_INT 101
95058: PUSH
95059: LD_INT 102
95061: PUSH
95062: LD_INT 103
95064: PUSH
95065: LD_INT 104
95067: PUSH
95068: LD_INT 105
95070: PUSH
95071: LD_INT 106
95073: PUSH
95074: LD_INT 107
95076: PUSH
95077: LD_INT 108
95079: PUSH
95080: LD_INT 109
95082: PUSH
95083: LD_INT 110
95085: PUSH
95086: LD_INT 111
95088: PUSH
95089: LD_INT 112
95091: PUSH
95092: LD_INT 113
95094: PUSH
95095: LD_INT 114
95097: PUSH
95098: LD_INT 115
95100: PUSH
95101: LD_INT 116
95103: PUSH
95104: LD_INT 117
95106: PUSH
95107: LD_INT 118
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: ST_TO_ADDR
// if result then
95134: LD_VAR 0 2
95138: IFFALSE 95924
// begin normal :=  ;
95140: LD_ADDR_VAR 0 5
95144: PUSH
95145: LD_STRING 
95147: ST_TO_ADDR
// hardcore :=  ;
95148: LD_ADDR_VAR 0 6
95152: PUSH
95153: LD_STRING 
95155: ST_TO_ADDR
// active :=  ;
95156: LD_ADDR_VAR 0 7
95160: PUSH
95161: LD_STRING 
95163: ST_TO_ADDR
// for i = 1 to normalCounter do
95164: LD_ADDR_VAR 0 8
95168: PUSH
95169: DOUBLE
95170: LD_INT 1
95172: DEC
95173: ST_TO_ADDR
95174: LD_EXP 95
95178: PUSH
95179: FOR_TO
95180: IFFALSE 95281
// begin tmp := 0 ;
95182: LD_ADDR_VAR 0 3
95186: PUSH
95187: LD_STRING 0
95189: ST_TO_ADDR
// if result [ 1 ] then
95190: LD_VAR 0 2
95194: PUSH
95195: LD_INT 1
95197: ARRAY
95198: IFFALSE 95263
// if result [ 1 ] [ 1 ] = i then
95200: LD_VAR 0 2
95204: PUSH
95205: LD_INT 1
95207: ARRAY
95208: PUSH
95209: LD_INT 1
95211: ARRAY
95212: PUSH
95213: LD_VAR 0 8
95217: EQUAL
95218: IFFALSE 95263
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95220: LD_ADDR_VAR 0 2
95224: PUSH
95225: LD_VAR 0 2
95229: PPUSH
95230: LD_INT 1
95232: PPUSH
95233: LD_VAR 0 2
95237: PUSH
95238: LD_INT 1
95240: ARRAY
95241: PPUSH
95242: LD_INT 1
95244: PPUSH
95245: CALL_OW 3
95249: PPUSH
95250: CALL_OW 1
95254: ST_TO_ADDR
// tmp := 1 ;
95255: LD_ADDR_VAR 0 3
95259: PUSH
95260: LD_STRING 1
95262: ST_TO_ADDR
// end ; normal := normal & tmp ;
95263: LD_ADDR_VAR 0 5
95267: PUSH
95268: LD_VAR 0 5
95272: PUSH
95273: LD_VAR 0 3
95277: STR
95278: ST_TO_ADDR
// end ;
95279: GO 95179
95281: POP
95282: POP
// for i = 1 to hardcoreCounter do
95283: LD_ADDR_VAR 0 8
95287: PUSH
95288: DOUBLE
95289: LD_INT 1
95291: DEC
95292: ST_TO_ADDR
95293: LD_EXP 96
95297: PUSH
95298: FOR_TO
95299: IFFALSE 95404
// begin tmp := 0 ;
95301: LD_ADDR_VAR 0 3
95305: PUSH
95306: LD_STRING 0
95308: ST_TO_ADDR
// if result [ 2 ] then
95309: LD_VAR 0 2
95313: PUSH
95314: LD_INT 2
95316: ARRAY
95317: IFFALSE 95386
// if result [ 2 ] [ 1 ] = 100 + i then
95319: LD_VAR 0 2
95323: PUSH
95324: LD_INT 2
95326: ARRAY
95327: PUSH
95328: LD_INT 1
95330: ARRAY
95331: PUSH
95332: LD_INT 100
95334: PUSH
95335: LD_VAR 0 8
95339: PLUS
95340: EQUAL
95341: IFFALSE 95386
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95343: LD_ADDR_VAR 0 2
95347: PUSH
95348: LD_VAR 0 2
95352: PPUSH
95353: LD_INT 2
95355: PPUSH
95356: LD_VAR 0 2
95360: PUSH
95361: LD_INT 2
95363: ARRAY
95364: PPUSH
95365: LD_INT 1
95367: PPUSH
95368: CALL_OW 3
95372: PPUSH
95373: CALL_OW 1
95377: ST_TO_ADDR
// tmp := 1 ;
95378: LD_ADDR_VAR 0 3
95382: PUSH
95383: LD_STRING 1
95385: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95386: LD_ADDR_VAR 0 6
95390: PUSH
95391: LD_VAR 0 6
95395: PUSH
95396: LD_VAR 0 3
95400: STR
95401: ST_TO_ADDR
// end ;
95402: GO 95298
95404: POP
95405: POP
// if isGameLoad then
95406: LD_VAR 0 1
95410: IFFALSE 95885
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95412: LD_ADDR_VAR 0 4
95416: PUSH
95417: LD_EXP 99
95421: PUSH
95422: LD_EXP 98
95426: PUSH
95427: LD_EXP 100
95431: PUSH
95432: LD_EXP 97
95436: PUSH
95437: LD_EXP 101
95441: PUSH
95442: LD_EXP 102
95446: PUSH
95447: LD_EXP 103
95451: PUSH
95452: LD_EXP 104
95456: PUSH
95457: LD_EXP 105
95461: PUSH
95462: LD_EXP 106
95466: PUSH
95467: LD_EXP 107
95471: PUSH
95472: LD_EXP 108
95476: PUSH
95477: LD_EXP 109
95481: PUSH
95482: LD_EXP 110
95486: PUSH
95487: LD_EXP 118
95491: PUSH
95492: LD_EXP 119
95496: PUSH
95497: LD_EXP 120
95501: PUSH
95502: LD_EXP 121
95506: PUSH
95507: LD_EXP 123
95511: PUSH
95512: LD_EXP 124
95516: PUSH
95517: LD_EXP 125
95521: PUSH
95522: LD_EXP 128
95526: PUSH
95527: LD_EXP 130
95531: PUSH
95532: LD_EXP 131
95536: PUSH
95537: LD_EXP 132
95541: PUSH
95542: LD_EXP 134
95546: PUSH
95547: LD_EXP 135
95551: PUSH
95552: LD_EXP 138
95556: PUSH
95557: LD_EXP 139
95561: PUSH
95562: LD_EXP 140
95566: PUSH
95567: LD_EXP 141
95571: PUSH
95572: LD_EXP 142
95576: PUSH
95577: LD_EXP 143
95581: PUSH
95582: LD_EXP 144
95586: PUSH
95587: LD_EXP 145
95591: PUSH
95592: LD_EXP 146
95596: PUSH
95597: LD_EXP 111
95601: PUSH
95602: LD_EXP 112
95606: PUSH
95607: LD_EXP 115
95611: PUSH
95612: LD_EXP 116
95616: PUSH
95617: LD_EXP 117
95621: PUSH
95622: LD_EXP 113
95626: PUSH
95627: LD_EXP 114
95631: PUSH
95632: LD_EXP 122
95636: PUSH
95637: LD_EXP 126
95641: PUSH
95642: LD_EXP 127
95646: PUSH
95647: LD_EXP 129
95651: PUSH
95652: LD_EXP 133
95656: PUSH
95657: LD_EXP 136
95661: PUSH
95662: LD_EXP 137
95666: PUSH
95667: LD_EXP 147
95671: PUSH
95672: LD_EXP 148
95676: PUSH
95677: LD_EXP 149
95681: PUSH
95682: LD_EXP 150
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: ST_TO_ADDR
// tmp :=  ;
95743: LD_ADDR_VAR 0 3
95747: PUSH
95748: LD_STRING 
95750: ST_TO_ADDR
// for i = 1 to normalCounter do
95751: LD_ADDR_VAR 0 8
95755: PUSH
95756: DOUBLE
95757: LD_INT 1
95759: DEC
95760: ST_TO_ADDR
95761: LD_EXP 95
95765: PUSH
95766: FOR_TO
95767: IFFALSE 95803
// begin if flags [ i ] then
95769: LD_VAR 0 4
95773: PUSH
95774: LD_VAR 0 8
95778: ARRAY
95779: IFFALSE 95801
// tmp := tmp & i & ; ;
95781: LD_ADDR_VAR 0 3
95785: PUSH
95786: LD_VAR 0 3
95790: PUSH
95791: LD_VAR 0 8
95795: STR
95796: PUSH
95797: LD_STRING ;
95799: STR
95800: ST_TO_ADDR
// end ;
95801: GO 95766
95803: POP
95804: POP
// for i = 1 to hardcoreCounter do
95805: LD_ADDR_VAR 0 8
95809: PUSH
95810: DOUBLE
95811: LD_INT 1
95813: DEC
95814: ST_TO_ADDR
95815: LD_EXP 96
95819: PUSH
95820: FOR_TO
95821: IFFALSE 95867
// begin if flags [ normalCounter + i ] then
95823: LD_VAR 0 4
95827: PUSH
95828: LD_EXP 95
95832: PUSH
95833: LD_VAR 0 8
95837: PLUS
95838: ARRAY
95839: IFFALSE 95865
// tmp := tmp & ( 100 + i ) & ; ;
95841: LD_ADDR_VAR 0 3
95845: PUSH
95846: LD_VAR 0 3
95850: PUSH
95851: LD_INT 100
95853: PUSH
95854: LD_VAR 0 8
95858: PLUS
95859: STR
95860: PUSH
95861: LD_STRING ;
95863: STR
95864: ST_TO_ADDR
// end ;
95865: GO 95820
95867: POP
95868: POP
// if tmp then
95869: LD_VAR 0 3
95873: IFFALSE 95885
// active := tmp ;
95875: LD_ADDR_VAR 0 7
95879: PUSH
95880: LD_VAR 0 3
95884: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95885: LD_STRING getStreamItemsFromMission("
95887: PUSH
95888: LD_VAR 0 5
95892: STR
95893: PUSH
95894: LD_STRING ","
95896: STR
95897: PUSH
95898: LD_VAR 0 6
95902: STR
95903: PUSH
95904: LD_STRING ","
95906: STR
95907: PUSH
95908: LD_VAR 0 7
95912: STR
95913: PUSH
95914: LD_STRING ")
95916: STR
95917: PPUSH
95918: CALL_OW 559
// end else
95922: GO 95931
// ToLua ( getStreamItemsFromMission("","","") ) ;
95924: LD_STRING getStreamItemsFromMission("","","")
95926: PPUSH
95927: CALL_OW 559
// end ;
95931: LD_VAR 0 2
95935: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95936: LD_EXP 94
95940: PUSH
95941: LD_EXP 99
95945: AND
95946: IFFALSE 96070
95948: GO 95950
95950: DISABLE
95951: LD_INT 0
95953: PPUSH
95954: PPUSH
// begin enable ;
95955: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95956: LD_ADDR_VAR 0 2
95960: PUSH
95961: LD_INT 22
95963: PUSH
95964: LD_OWVAR 2
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: PUSH
95973: LD_INT 2
95975: PUSH
95976: LD_INT 34
95978: PUSH
95979: LD_INT 7
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: LD_INT 34
95988: PUSH
95989: LD_INT 45
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: PUSH
95996: LD_INT 34
95998: PUSH
95999: LD_INT 28
96001: PUSH
96002: EMPTY
96003: LIST
96004: LIST
96005: PUSH
96006: LD_INT 34
96008: PUSH
96009: LD_INT 47
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: PUSH
96016: EMPTY
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: PUSH
96023: EMPTY
96024: LIST
96025: LIST
96026: PPUSH
96027: CALL_OW 69
96031: ST_TO_ADDR
// if not tmp then
96032: LD_VAR 0 2
96036: NOT
96037: IFFALSE 96041
// exit ;
96039: GO 96070
// for i in tmp do
96041: LD_ADDR_VAR 0 1
96045: PUSH
96046: LD_VAR 0 2
96050: PUSH
96051: FOR_IN
96052: IFFALSE 96068
// begin SetLives ( i , 0 ) ;
96054: LD_VAR 0 1
96058: PPUSH
96059: LD_INT 0
96061: PPUSH
96062: CALL_OW 234
// end ;
96066: GO 96051
96068: POP
96069: POP
// end ;
96070: PPOPN 2
96072: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96073: LD_EXP 94
96077: PUSH
96078: LD_EXP 100
96082: AND
96083: IFFALSE 96167
96085: GO 96087
96087: DISABLE
96088: LD_INT 0
96090: PPUSH
96091: PPUSH
// begin enable ;
96092: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96093: LD_ADDR_VAR 0 2
96097: PUSH
96098: LD_INT 22
96100: PUSH
96101: LD_OWVAR 2
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: PUSH
96110: LD_INT 32
96112: PUSH
96113: LD_INT 3
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PPUSH
96124: CALL_OW 69
96128: ST_TO_ADDR
// if not tmp then
96129: LD_VAR 0 2
96133: NOT
96134: IFFALSE 96138
// exit ;
96136: GO 96167
// for i in tmp do
96138: LD_ADDR_VAR 0 1
96142: PUSH
96143: LD_VAR 0 2
96147: PUSH
96148: FOR_IN
96149: IFFALSE 96165
// begin SetLives ( i , 0 ) ;
96151: LD_VAR 0 1
96155: PPUSH
96156: LD_INT 0
96158: PPUSH
96159: CALL_OW 234
// end ;
96163: GO 96148
96165: POP
96166: POP
// end ;
96167: PPOPN 2
96169: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96170: LD_EXP 94
96174: PUSH
96175: LD_EXP 97
96179: AND
96180: IFFALSE 96273
96182: GO 96184
96184: DISABLE
96185: LD_INT 0
96187: PPUSH
// begin enable ;
96188: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96189: LD_ADDR_VAR 0 1
96193: PUSH
96194: LD_INT 22
96196: PUSH
96197: LD_OWVAR 2
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PUSH
96206: LD_INT 2
96208: PUSH
96209: LD_INT 25
96211: PUSH
96212: LD_INT 5
96214: PUSH
96215: EMPTY
96216: LIST
96217: LIST
96218: PUSH
96219: LD_INT 25
96221: PUSH
96222: LD_INT 9
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PUSH
96229: LD_INT 25
96231: PUSH
96232: LD_INT 8
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: PUSH
96239: EMPTY
96240: LIST
96241: LIST
96242: LIST
96243: LIST
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PPUSH
96249: CALL_OW 69
96253: PUSH
96254: FOR_IN
96255: IFFALSE 96271
// begin SetClass ( i , 1 ) ;
96257: LD_VAR 0 1
96261: PPUSH
96262: LD_INT 1
96264: PPUSH
96265: CALL_OW 336
// end ;
96269: GO 96254
96271: POP
96272: POP
// end ;
96273: PPOPN 1
96275: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96276: LD_EXP 94
96280: PUSH
96281: LD_EXP 98
96285: AND
96286: PUSH
96287: LD_OWVAR 65
96291: PUSH
96292: LD_INT 7
96294: LESS
96295: AND
96296: IFFALSE 96310
96298: GO 96300
96300: DISABLE
// begin enable ;
96301: ENABLE
// game_speed := 7 ;
96302: LD_ADDR_OWVAR 65
96306: PUSH
96307: LD_INT 7
96309: ST_TO_ADDR
// end ;
96310: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96311: LD_EXP 94
96315: PUSH
96316: LD_EXP 101
96320: AND
96321: IFFALSE 96523
96323: GO 96325
96325: DISABLE
96326: LD_INT 0
96328: PPUSH
96329: PPUSH
96330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96331: LD_ADDR_VAR 0 3
96335: PUSH
96336: LD_INT 81
96338: PUSH
96339: LD_OWVAR 2
96343: PUSH
96344: EMPTY
96345: LIST
96346: LIST
96347: PUSH
96348: LD_INT 21
96350: PUSH
96351: LD_INT 1
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PUSH
96358: EMPTY
96359: LIST
96360: LIST
96361: PPUSH
96362: CALL_OW 69
96366: ST_TO_ADDR
// if not tmp then
96367: LD_VAR 0 3
96371: NOT
96372: IFFALSE 96376
// exit ;
96374: GO 96523
// if tmp > 5 then
96376: LD_VAR 0 3
96380: PUSH
96381: LD_INT 5
96383: GREATER
96384: IFFALSE 96396
// k := 5 else
96386: LD_ADDR_VAR 0 2
96390: PUSH
96391: LD_INT 5
96393: ST_TO_ADDR
96394: GO 96406
// k := tmp ;
96396: LD_ADDR_VAR 0 2
96400: PUSH
96401: LD_VAR 0 3
96405: ST_TO_ADDR
// for i := 1 to k do
96406: LD_ADDR_VAR 0 1
96410: PUSH
96411: DOUBLE
96412: LD_INT 1
96414: DEC
96415: ST_TO_ADDR
96416: LD_VAR 0 2
96420: PUSH
96421: FOR_TO
96422: IFFALSE 96521
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96424: LD_VAR 0 3
96428: PUSH
96429: LD_VAR 0 1
96433: ARRAY
96434: PPUSH
96435: LD_VAR 0 1
96439: PUSH
96440: LD_INT 4
96442: MOD
96443: PUSH
96444: LD_INT 1
96446: PLUS
96447: PPUSH
96448: CALL_OW 259
96452: PUSH
96453: LD_INT 10
96455: LESS
96456: IFFALSE 96519
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96458: LD_VAR 0 3
96462: PUSH
96463: LD_VAR 0 1
96467: ARRAY
96468: PPUSH
96469: LD_VAR 0 1
96473: PUSH
96474: LD_INT 4
96476: MOD
96477: PUSH
96478: LD_INT 1
96480: PLUS
96481: PPUSH
96482: LD_VAR 0 3
96486: PUSH
96487: LD_VAR 0 1
96491: ARRAY
96492: PPUSH
96493: LD_VAR 0 1
96497: PUSH
96498: LD_INT 4
96500: MOD
96501: PUSH
96502: LD_INT 1
96504: PLUS
96505: PPUSH
96506: CALL_OW 259
96510: PUSH
96511: LD_INT 1
96513: PLUS
96514: PPUSH
96515: CALL_OW 237
96519: GO 96421
96521: POP
96522: POP
// end ;
96523: PPOPN 3
96525: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96526: LD_EXP 94
96530: PUSH
96531: LD_EXP 102
96535: AND
96536: IFFALSE 96556
96538: GO 96540
96540: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96541: LD_INT 4
96543: PPUSH
96544: LD_OWVAR 2
96548: PPUSH
96549: LD_INT 0
96551: PPUSH
96552: CALL_OW 324
96556: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96557: LD_EXP 94
96561: PUSH
96562: LD_EXP 131
96566: AND
96567: IFFALSE 96587
96569: GO 96571
96571: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96572: LD_INT 19
96574: PPUSH
96575: LD_OWVAR 2
96579: PPUSH
96580: LD_INT 0
96582: PPUSH
96583: CALL_OW 324
96587: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96588: LD_EXP 94
96592: PUSH
96593: LD_EXP 103
96597: AND
96598: IFFALSE 96700
96600: GO 96602
96602: DISABLE
96603: LD_INT 0
96605: PPUSH
96606: PPUSH
// begin enable ;
96607: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96608: LD_ADDR_VAR 0 2
96612: PUSH
96613: LD_INT 22
96615: PUSH
96616: LD_OWVAR 2
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 2
96627: PUSH
96628: LD_INT 34
96630: PUSH
96631: LD_INT 11
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: LD_INT 34
96640: PUSH
96641: LD_INT 30
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: LIST
96652: PUSH
96653: EMPTY
96654: LIST
96655: LIST
96656: PPUSH
96657: CALL_OW 69
96661: ST_TO_ADDR
// if not tmp then
96662: LD_VAR 0 2
96666: NOT
96667: IFFALSE 96671
// exit ;
96669: GO 96700
// for i in tmp do
96671: LD_ADDR_VAR 0 1
96675: PUSH
96676: LD_VAR 0 2
96680: PUSH
96681: FOR_IN
96682: IFFALSE 96698
// begin SetLives ( i , 0 ) ;
96684: LD_VAR 0 1
96688: PPUSH
96689: LD_INT 0
96691: PPUSH
96692: CALL_OW 234
// end ;
96696: GO 96681
96698: POP
96699: POP
// end ;
96700: PPOPN 2
96702: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96703: LD_EXP 94
96707: PUSH
96708: LD_EXP 104
96712: AND
96713: IFFALSE 96733
96715: GO 96717
96717: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96718: LD_INT 32
96720: PPUSH
96721: LD_OWVAR 2
96725: PPUSH
96726: LD_INT 0
96728: PPUSH
96729: CALL_OW 324
96733: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96734: LD_EXP 94
96738: PUSH
96739: LD_EXP 105
96743: AND
96744: IFFALSE 96925
96746: GO 96748
96748: DISABLE
96749: LD_INT 0
96751: PPUSH
96752: PPUSH
96753: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96754: LD_ADDR_VAR 0 2
96758: PUSH
96759: LD_INT 22
96761: PUSH
96762: LD_OWVAR 2
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 33
96773: PUSH
96774: LD_INT 3
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PPUSH
96785: CALL_OW 69
96789: ST_TO_ADDR
// if not tmp then
96790: LD_VAR 0 2
96794: NOT
96795: IFFALSE 96799
// exit ;
96797: GO 96925
// side := 0 ;
96799: LD_ADDR_VAR 0 3
96803: PUSH
96804: LD_INT 0
96806: ST_TO_ADDR
// for i := 1 to 8 do
96807: LD_ADDR_VAR 0 1
96811: PUSH
96812: DOUBLE
96813: LD_INT 1
96815: DEC
96816: ST_TO_ADDR
96817: LD_INT 8
96819: PUSH
96820: FOR_TO
96821: IFFALSE 96869
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96823: LD_OWVAR 2
96827: PUSH
96828: LD_VAR 0 1
96832: NONEQUAL
96833: PUSH
96834: LD_OWVAR 2
96838: PPUSH
96839: LD_VAR 0 1
96843: PPUSH
96844: CALL_OW 81
96848: PUSH
96849: LD_INT 2
96851: EQUAL
96852: AND
96853: IFFALSE 96867
// begin side := i ;
96855: LD_ADDR_VAR 0 3
96859: PUSH
96860: LD_VAR 0 1
96864: ST_TO_ADDR
// break ;
96865: GO 96869
// end ;
96867: GO 96820
96869: POP
96870: POP
// if not side then
96871: LD_VAR 0 3
96875: NOT
96876: IFFALSE 96880
// exit ;
96878: GO 96925
// for i := 1 to tmp do
96880: LD_ADDR_VAR 0 1
96884: PUSH
96885: DOUBLE
96886: LD_INT 1
96888: DEC
96889: ST_TO_ADDR
96890: LD_VAR 0 2
96894: PUSH
96895: FOR_TO
96896: IFFALSE 96923
// if Prob ( 60 ) then
96898: LD_INT 60
96900: PPUSH
96901: CALL_OW 13
96905: IFFALSE 96921
// SetSide ( i , side ) ;
96907: LD_VAR 0 1
96911: PPUSH
96912: LD_VAR 0 3
96916: PPUSH
96917: CALL_OW 235
96921: GO 96895
96923: POP
96924: POP
// end ;
96925: PPOPN 3
96927: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96928: LD_EXP 94
96932: PUSH
96933: LD_EXP 107
96937: AND
96938: IFFALSE 97057
96940: GO 96942
96942: DISABLE
96943: LD_INT 0
96945: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96946: LD_ADDR_VAR 0 1
96950: PUSH
96951: LD_INT 22
96953: PUSH
96954: LD_OWVAR 2
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 21
96965: PUSH
96966: LD_INT 1
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 3
96975: PUSH
96976: LD_INT 23
96978: PUSH
96979: LD_INT 0
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: PUSH
96986: EMPTY
96987: LIST
96988: LIST
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: LIST
96994: PPUSH
96995: CALL_OW 69
96999: PUSH
97000: FOR_IN
97001: IFFALSE 97055
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97003: LD_VAR 0 1
97007: PPUSH
97008: CALL_OW 257
97012: PUSH
97013: LD_INT 1
97015: PUSH
97016: LD_INT 2
97018: PUSH
97019: LD_INT 3
97021: PUSH
97022: LD_INT 4
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: IN
97031: IFFALSE 97053
// SetClass ( un , rand ( 1 , 4 ) ) ;
97033: LD_VAR 0 1
97037: PPUSH
97038: LD_INT 1
97040: PPUSH
97041: LD_INT 4
97043: PPUSH
97044: CALL_OW 12
97048: PPUSH
97049: CALL_OW 336
97053: GO 97000
97055: POP
97056: POP
// end ;
97057: PPOPN 1
97059: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97060: LD_EXP 94
97064: PUSH
97065: LD_EXP 106
97069: AND
97070: IFFALSE 97149
97072: GO 97074
97074: DISABLE
97075: LD_INT 0
97077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97078: LD_ADDR_VAR 0 1
97082: PUSH
97083: LD_INT 22
97085: PUSH
97086: LD_OWVAR 2
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 21
97097: PUSH
97098: LD_INT 3
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: PPUSH
97109: CALL_OW 69
97113: ST_TO_ADDR
// if not tmp then
97114: LD_VAR 0 1
97118: NOT
97119: IFFALSE 97123
// exit ;
97121: GO 97149
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97123: LD_VAR 0 1
97127: PUSH
97128: LD_INT 1
97130: PPUSH
97131: LD_VAR 0 1
97135: PPUSH
97136: CALL_OW 12
97140: ARRAY
97141: PPUSH
97142: LD_INT 100
97144: PPUSH
97145: CALL_OW 234
// end ;
97149: PPOPN 1
97151: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97152: LD_EXP 94
97156: PUSH
97157: LD_EXP 108
97161: AND
97162: IFFALSE 97260
97164: GO 97166
97166: DISABLE
97167: LD_INT 0
97169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97170: LD_ADDR_VAR 0 1
97174: PUSH
97175: LD_INT 22
97177: PUSH
97178: LD_OWVAR 2
97182: PUSH
97183: EMPTY
97184: LIST
97185: LIST
97186: PUSH
97187: LD_INT 21
97189: PUSH
97190: LD_INT 1
97192: PUSH
97193: EMPTY
97194: LIST
97195: LIST
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: PPUSH
97201: CALL_OW 69
97205: ST_TO_ADDR
// if not tmp then
97206: LD_VAR 0 1
97210: NOT
97211: IFFALSE 97215
// exit ;
97213: GO 97260
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97215: LD_VAR 0 1
97219: PUSH
97220: LD_INT 1
97222: PPUSH
97223: LD_VAR 0 1
97227: PPUSH
97228: CALL_OW 12
97232: ARRAY
97233: PPUSH
97234: LD_INT 1
97236: PPUSH
97237: LD_INT 4
97239: PPUSH
97240: CALL_OW 12
97244: PPUSH
97245: LD_INT 3000
97247: PPUSH
97248: LD_INT 9000
97250: PPUSH
97251: CALL_OW 12
97255: PPUSH
97256: CALL_OW 492
// end ;
97260: PPOPN 1
97262: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97263: LD_EXP 94
97267: PUSH
97268: LD_EXP 109
97272: AND
97273: IFFALSE 97293
97275: GO 97277
97277: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97278: LD_INT 1
97280: PPUSH
97281: LD_OWVAR 2
97285: PPUSH
97286: LD_INT 0
97288: PPUSH
97289: CALL_OW 324
97293: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97294: LD_EXP 94
97298: PUSH
97299: LD_EXP 110
97303: AND
97304: IFFALSE 97387
97306: GO 97308
97308: DISABLE
97309: LD_INT 0
97311: PPUSH
97312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97313: LD_ADDR_VAR 0 2
97317: PUSH
97318: LD_INT 22
97320: PUSH
97321: LD_OWVAR 2
97325: PUSH
97326: EMPTY
97327: LIST
97328: LIST
97329: PUSH
97330: LD_INT 21
97332: PUSH
97333: LD_INT 3
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: PUSH
97340: EMPTY
97341: LIST
97342: LIST
97343: PPUSH
97344: CALL_OW 69
97348: ST_TO_ADDR
// if not tmp then
97349: LD_VAR 0 2
97353: NOT
97354: IFFALSE 97358
// exit ;
97356: GO 97387
// for i in tmp do
97358: LD_ADDR_VAR 0 1
97362: PUSH
97363: LD_VAR 0 2
97367: PUSH
97368: FOR_IN
97369: IFFALSE 97385
// SetBLevel ( i , 10 ) ;
97371: LD_VAR 0 1
97375: PPUSH
97376: LD_INT 10
97378: PPUSH
97379: CALL_OW 241
97383: GO 97368
97385: POP
97386: POP
// end ;
97387: PPOPN 2
97389: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97390: LD_EXP 94
97394: PUSH
97395: LD_EXP 111
97399: AND
97400: IFFALSE 97511
97402: GO 97404
97404: DISABLE
97405: LD_INT 0
97407: PPUSH
97408: PPUSH
97409: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97410: LD_ADDR_VAR 0 3
97414: PUSH
97415: LD_INT 22
97417: PUSH
97418: LD_OWVAR 2
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: LD_INT 25
97429: PUSH
97430: LD_INT 1
97432: PUSH
97433: EMPTY
97434: LIST
97435: LIST
97436: PUSH
97437: EMPTY
97438: LIST
97439: LIST
97440: PPUSH
97441: CALL_OW 69
97445: ST_TO_ADDR
// if not tmp then
97446: LD_VAR 0 3
97450: NOT
97451: IFFALSE 97455
// exit ;
97453: GO 97511
// un := tmp [ rand ( 1 , tmp ) ] ;
97455: LD_ADDR_VAR 0 2
97459: PUSH
97460: LD_VAR 0 3
97464: PUSH
97465: LD_INT 1
97467: PPUSH
97468: LD_VAR 0 3
97472: PPUSH
97473: CALL_OW 12
97477: ARRAY
97478: ST_TO_ADDR
// if Crawls ( un ) then
97479: LD_VAR 0 2
97483: PPUSH
97484: CALL_OW 318
97488: IFFALSE 97499
// ComWalk ( un ) ;
97490: LD_VAR 0 2
97494: PPUSH
97495: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97499: LD_VAR 0 2
97503: PPUSH
97504: LD_INT 5
97506: PPUSH
97507: CALL_OW 336
// end ;
97511: PPOPN 3
97513: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97514: LD_EXP 94
97518: PUSH
97519: LD_EXP 112
97523: AND
97524: PUSH
97525: LD_OWVAR 67
97529: PUSH
97530: LD_INT 4
97532: LESS
97533: AND
97534: IFFALSE 97553
97536: GO 97538
97538: DISABLE
// begin Difficulty := Difficulty + 1 ;
97539: LD_ADDR_OWVAR 67
97543: PUSH
97544: LD_OWVAR 67
97548: PUSH
97549: LD_INT 1
97551: PLUS
97552: ST_TO_ADDR
// end ;
97553: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97554: LD_EXP 94
97558: PUSH
97559: LD_EXP 113
97563: AND
97564: IFFALSE 97667
97566: GO 97568
97568: DISABLE
97569: LD_INT 0
97571: PPUSH
// begin for i := 1 to 5 do
97572: LD_ADDR_VAR 0 1
97576: PUSH
97577: DOUBLE
97578: LD_INT 1
97580: DEC
97581: ST_TO_ADDR
97582: LD_INT 5
97584: PUSH
97585: FOR_TO
97586: IFFALSE 97665
// begin uc_nation := nation_nature ;
97588: LD_ADDR_OWVAR 21
97592: PUSH
97593: LD_INT 0
97595: ST_TO_ADDR
// uc_side := 0 ;
97596: LD_ADDR_OWVAR 20
97600: PUSH
97601: LD_INT 0
97603: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97604: LD_ADDR_OWVAR 29
97608: PUSH
97609: LD_INT 12
97611: PUSH
97612: LD_INT 12
97614: PUSH
97615: EMPTY
97616: LIST
97617: LIST
97618: ST_TO_ADDR
// hc_agressivity := 20 ;
97619: LD_ADDR_OWVAR 35
97623: PUSH
97624: LD_INT 20
97626: ST_TO_ADDR
// hc_class := class_tiger ;
97627: LD_ADDR_OWVAR 28
97631: PUSH
97632: LD_INT 14
97634: ST_TO_ADDR
// hc_gallery :=  ;
97635: LD_ADDR_OWVAR 33
97639: PUSH
97640: LD_STRING 
97642: ST_TO_ADDR
// hc_name :=  ;
97643: LD_ADDR_OWVAR 26
97647: PUSH
97648: LD_STRING 
97650: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97651: CALL_OW 44
97655: PPUSH
97656: LD_INT 0
97658: PPUSH
97659: CALL_OW 51
// end ;
97663: GO 97585
97665: POP
97666: POP
// end ;
97667: PPOPN 1
97669: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97670: LD_EXP 94
97674: PUSH
97675: LD_EXP 114
97679: AND
97680: IFFALSE 97689
97682: GO 97684
97684: DISABLE
// StreamSibBomb ;
97685: CALL 97690 0 0
97689: END
// export function StreamSibBomb ; var i , x , y ; begin
97690: LD_INT 0
97692: PPUSH
97693: PPUSH
97694: PPUSH
97695: PPUSH
// result := false ;
97696: LD_ADDR_VAR 0 1
97700: PUSH
97701: LD_INT 0
97703: ST_TO_ADDR
// for i := 1 to 16 do
97704: LD_ADDR_VAR 0 2
97708: PUSH
97709: DOUBLE
97710: LD_INT 1
97712: DEC
97713: ST_TO_ADDR
97714: LD_INT 16
97716: PUSH
97717: FOR_TO
97718: IFFALSE 97917
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97720: LD_ADDR_VAR 0 3
97724: PUSH
97725: LD_INT 10
97727: PUSH
97728: LD_INT 20
97730: PUSH
97731: LD_INT 30
97733: PUSH
97734: LD_INT 40
97736: PUSH
97737: LD_INT 50
97739: PUSH
97740: LD_INT 60
97742: PUSH
97743: LD_INT 70
97745: PUSH
97746: LD_INT 80
97748: PUSH
97749: LD_INT 90
97751: PUSH
97752: LD_INT 100
97754: PUSH
97755: LD_INT 110
97757: PUSH
97758: LD_INT 120
97760: PUSH
97761: LD_INT 130
97763: PUSH
97764: LD_INT 140
97766: PUSH
97767: LD_INT 150
97769: PUSH
97770: EMPTY
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: PUSH
97787: LD_INT 1
97789: PPUSH
97790: LD_INT 15
97792: PPUSH
97793: CALL_OW 12
97797: ARRAY
97798: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97799: LD_ADDR_VAR 0 4
97803: PUSH
97804: LD_INT 10
97806: PUSH
97807: LD_INT 20
97809: PUSH
97810: LD_INT 30
97812: PUSH
97813: LD_INT 40
97815: PUSH
97816: LD_INT 50
97818: PUSH
97819: LD_INT 60
97821: PUSH
97822: LD_INT 70
97824: PUSH
97825: LD_INT 80
97827: PUSH
97828: LD_INT 90
97830: PUSH
97831: LD_INT 100
97833: PUSH
97834: LD_INT 110
97836: PUSH
97837: LD_INT 120
97839: PUSH
97840: LD_INT 130
97842: PUSH
97843: LD_INT 140
97845: PUSH
97846: LD_INT 150
97848: PUSH
97849: EMPTY
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 1
97868: PPUSH
97869: LD_INT 15
97871: PPUSH
97872: CALL_OW 12
97876: ARRAY
97877: ST_TO_ADDR
// if ValidHex ( x , y ) then
97878: LD_VAR 0 3
97882: PPUSH
97883: LD_VAR 0 4
97887: PPUSH
97888: CALL_OW 488
97892: IFFALSE 97915
// begin result := [ x , y ] ;
97894: LD_ADDR_VAR 0 1
97898: PUSH
97899: LD_VAR 0 3
97903: PUSH
97904: LD_VAR 0 4
97908: PUSH
97909: EMPTY
97910: LIST
97911: LIST
97912: ST_TO_ADDR
// break ;
97913: GO 97917
// end ; end ;
97915: GO 97717
97917: POP
97918: POP
// if result then
97919: LD_VAR 0 1
97923: IFFALSE 97983
// begin ToLua ( playSibBomb() ) ;
97925: LD_STRING playSibBomb()
97927: PPUSH
97928: CALL_OW 559
// wait ( 0 0$14 ) ;
97932: LD_INT 490
97934: PPUSH
97935: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97939: LD_VAR 0 1
97943: PUSH
97944: LD_INT 1
97946: ARRAY
97947: PPUSH
97948: LD_VAR 0 1
97952: PUSH
97953: LD_INT 2
97955: ARRAY
97956: PPUSH
97957: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97961: LD_VAR 0 1
97965: PUSH
97966: LD_INT 1
97968: ARRAY
97969: PPUSH
97970: LD_VAR 0 1
97974: PUSH
97975: LD_INT 2
97977: ARRAY
97978: PPUSH
97979: CALL_OW 429
// end ; end ;
97983: LD_VAR 0 1
97987: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97988: LD_EXP 94
97992: PUSH
97993: LD_EXP 116
97997: AND
97998: IFFALSE 98010
98000: GO 98002
98002: DISABLE
// YouLost (  ) ;
98003: LD_STRING 
98005: PPUSH
98006: CALL_OW 104
98010: END
// every 0 0$1 trigger StreamModeActive and sFog do
98011: LD_EXP 94
98015: PUSH
98016: LD_EXP 115
98020: AND
98021: IFFALSE 98035
98023: GO 98025
98025: DISABLE
// FogOff ( your_side ) ;
98026: LD_OWVAR 2
98030: PPUSH
98031: CALL_OW 344
98035: END
// every 0 0$1 trigger StreamModeActive and sSun do
98036: LD_EXP 94
98040: PUSH
98041: LD_EXP 117
98045: AND
98046: IFFALSE 98074
98048: GO 98050
98050: DISABLE
// begin solar_recharge_percent := 0 ;
98051: LD_ADDR_OWVAR 79
98055: PUSH
98056: LD_INT 0
98058: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98059: LD_INT 10500
98061: PPUSH
98062: CALL_OW 67
// solar_recharge_percent := 100 ;
98066: LD_ADDR_OWVAR 79
98070: PUSH
98071: LD_INT 100
98073: ST_TO_ADDR
// end ;
98074: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98075: LD_EXP 94
98079: PUSH
98080: LD_EXP 118
98084: AND
98085: IFFALSE 98324
98087: GO 98089
98089: DISABLE
98090: LD_INT 0
98092: PPUSH
98093: PPUSH
98094: PPUSH
// begin tmp := [ ] ;
98095: LD_ADDR_VAR 0 3
98099: PUSH
98100: EMPTY
98101: ST_TO_ADDR
// for i := 1 to 6 do
98102: LD_ADDR_VAR 0 1
98106: PUSH
98107: DOUBLE
98108: LD_INT 1
98110: DEC
98111: ST_TO_ADDR
98112: LD_INT 6
98114: PUSH
98115: FOR_TO
98116: IFFALSE 98221
// begin uc_nation := nation_nature ;
98118: LD_ADDR_OWVAR 21
98122: PUSH
98123: LD_INT 0
98125: ST_TO_ADDR
// uc_side := 0 ;
98126: LD_ADDR_OWVAR 20
98130: PUSH
98131: LD_INT 0
98133: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98134: LD_ADDR_OWVAR 29
98138: PUSH
98139: LD_INT 12
98141: PUSH
98142: LD_INT 12
98144: PUSH
98145: EMPTY
98146: LIST
98147: LIST
98148: ST_TO_ADDR
// hc_agressivity := 20 ;
98149: LD_ADDR_OWVAR 35
98153: PUSH
98154: LD_INT 20
98156: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98157: LD_ADDR_OWVAR 28
98161: PUSH
98162: LD_INT 17
98164: ST_TO_ADDR
// hc_gallery :=  ;
98165: LD_ADDR_OWVAR 33
98169: PUSH
98170: LD_STRING 
98172: ST_TO_ADDR
// hc_name :=  ;
98173: LD_ADDR_OWVAR 26
98177: PUSH
98178: LD_STRING 
98180: ST_TO_ADDR
// un := CreateHuman ;
98181: LD_ADDR_VAR 0 2
98185: PUSH
98186: CALL_OW 44
98190: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98191: LD_VAR 0 2
98195: PPUSH
98196: LD_INT 1
98198: PPUSH
98199: CALL_OW 51
// tmp := tmp ^ un ;
98203: LD_ADDR_VAR 0 3
98207: PUSH
98208: LD_VAR 0 3
98212: PUSH
98213: LD_VAR 0 2
98217: ADD
98218: ST_TO_ADDR
// end ;
98219: GO 98115
98221: POP
98222: POP
// repeat wait ( 0 0$1 ) ;
98223: LD_INT 35
98225: PPUSH
98226: CALL_OW 67
// for un in tmp do
98230: LD_ADDR_VAR 0 2
98234: PUSH
98235: LD_VAR 0 3
98239: PUSH
98240: FOR_IN
98241: IFFALSE 98315
// begin if IsDead ( un ) then
98243: LD_VAR 0 2
98247: PPUSH
98248: CALL_OW 301
98252: IFFALSE 98272
// begin tmp := tmp diff un ;
98254: LD_ADDR_VAR 0 3
98258: PUSH
98259: LD_VAR 0 3
98263: PUSH
98264: LD_VAR 0 2
98268: DIFF
98269: ST_TO_ADDR
// continue ;
98270: GO 98240
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98272: LD_VAR 0 2
98276: PPUSH
98277: LD_INT 3
98279: PUSH
98280: LD_INT 22
98282: PUSH
98283: LD_INT 0
98285: PUSH
98286: EMPTY
98287: LIST
98288: LIST
98289: PUSH
98290: EMPTY
98291: LIST
98292: LIST
98293: PPUSH
98294: CALL_OW 69
98298: PPUSH
98299: LD_VAR 0 2
98303: PPUSH
98304: CALL_OW 74
98308: PPUSH
98309: CALL_OW 115
// end ;
98313: GO 98240
98315: POP
98316: POP
// until not tmp ;
98317: LD_VAR 0 3
98321: NOT
98322: IFFALSE 98223
// end ;
98324: PPOPN 3
98326: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98327: LD_EXP 94
98331: PUSH
98332: LD_EXP 119
98336: AND
98337: IFFALSE 98391
98339: GO 98341
98341: DISABLE
// begin ToLua ( displayTroll(); ) ;
98342: LD_STRING displayTroll();
98344: PPUSH
98345: CALL_OW 559
// wait ( 3 3$00 ) ;
98349: LD_INT 6300
98351: PPUSH
98352: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98356: LD_STRING hideTroll();
98358: PPUSH
98359: CALL_OW 559
// wait ( 1 1$00 ) ;
98363: LD_INT 2100
98365: PPUSH
98366: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98370: LD_STRING displayTroll();
98372: PPUSH
98373: CALL_OW 559
// wait ( 1 1$00 ) ;
98377: LD_INT 2100
98379: PPUSH
98380: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98384: LD_STRING hideTroll();
98386: PPUSH
98387: CALL_OW 559
// end ;
98391: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98392: LD_EXP 94
98396: PUSH
98397: LD_EXP 120
98401: AND
98402: IFFALSE 98465
98404: GO 98406
98406: DISABLE
98407: LD_INT 0
98409: PPUSH
// begin p := 0 ;
98410: LD_ADDR_VAR 0 1
98414: PUSH
98415: LD_INT 0
98417: ST_TO_ADDR
// repeat game_speed := 1 ;
98418: LD_ADDR_OWVAR 65
98422: PUSH
98423: LD_INT 1
98425: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98426: LD_INT 35
98428: PPUSH
98429: CALL_OW 67
// p := p + 1 ;
98433: LD_ADDR_VAR 0 1
98437: PUSH
98438: LD_VAR 0 1
98442: PUSH
98443: LD_INT 1
98445: PLUS
98446: ST_TO_ADDR
// until p >= 60 ;
98447: LD_VAR 0 1
98451: PUSH
98452: LD_INT 60
98454: GREATEREQUAL
98455: IFFALSE 98418
// game_speed := 4 ;
98457: LD_ADDR_OWVAR 65
98461: PUSH
98462: LD_INT 4
98464: ST_TO_ADDR
// end ;
98465: PPOPN 1
98467: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98468: LD_EXP 94
98472: PUSH
98473: LD_EXP 121
98477: AND
98478: IFFALSE 98624
98480: GO 98482
98482: DISABLE
98483: LD_INT 0
98485: PPUSH
98486: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98487: LD_ADDR_VAR 0 1
98491: PUSH
98492: LD_INT 22
98494: PUSH
98495: LD_OWVAR 2
98499: PUSH
98500: EMPTY
98501: LIST
98502: LIST
98503: PUSH
98504: LD_INT 2
98506: PUSH
98507: LD_INT 30
98509: PUSH
98510: LD_INT 0
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: PUSH
98517: LD_INT 30
98519: PUSH
98520: LD_INT 1
98522: PUSH
98523: EMPTY
98524: LIST
98525: LIST
98526: PUSH
98527: EMPTY
98528: LIST
98529: LIST
98530: LIST
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PPUSH
98536: CALL_OW 69
98540: ST_TO_ADDR
// if not depot then
98541: LD_VAR 0 1
98545: NOT
98546: IFFALSE 98550
// exit ;
98548: GO 98624
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98550: LD_ADDR_VAR 0 2
98554: PUSH
98555: LD_VAR 0 1
98559: PUSH
98560: LD_INT 1
98562: PPUSH
98563: LD_VAR 0 1
98567: PPUSH
98568: CALL_OW 12
98572: ARRAY
98573: PPUSH
98574: CALL_OW 274
98578: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98579: LD_VAR 0 2
98583: PPUSH
98584: LD_INT 1
98586: PPUSH
98587: LD_INT 0
98589: PPUSH
98590: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98594: LD_VAR 0 2
98598: PPUSH
98599: LD_INT 2
98601: PPUSH
98602: LD_INT 0
98604: PPUSH
98605: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98609: LD_VAR 0 2
98613: PPUSH
98614: LD_INT 3
98616: PPUSH
98617: LD_INT 0
98619: PPUSH
98620: CALL_OW 277
// end ;
98624: PPOPN 2
98626: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98627: LD_EXP 94
98631: PUSH
98632: LD_EXP 122
98636: AND
98637: IFFALSE 98734
98639: GO 98641
98641: DISABLE
98642: LD_INT 0
98644: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98645: LD_ADDR_VAR 0 1
98649: PUSH
98650: LD_INT 22
98652: PUSH
98653: LD_OWVAR 2
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: PUSH
98662: LD_INT 21
98664: PUSH
98665: LD_INT 1
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: PUSH
98672: LD_INT 3
98674: PUSH
98675: LD_INT 23
98677: PUSH
98678: LD_INT 0
98680: PUSH
98681: EMPTY
98682: LIST
98683: LIST
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: PUSH
98689: EMPTY
98690: LIST
98691: LIST
98692: LIST
98693: PPUSH
98694: CALL_OW 69
98698: ST_TO_ADDR
// if not tmp then
98699: LD_VAR 0 1
98703: NOT
98704: IFFALSE 98708
// exit ;
98706: GO 98734
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98708: LD_VAR 0 1
98712: PUSH
98713: LD_INT 1
98715: PPUSH
98716: LD_VAR 0 1
98720: PPUSH
98721: CALL_OW 12
98725: ARRAY
98726: PPUSH
98727: LD_INT 200
98729: PPUSH
98730: CALL_OW 234
// end ;
98734: PPOPN 1
98736: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98737: LD_EXP 94
98741: PUSH
98742: LD_EXP 123
98746: AND
98747: IFFALSE 98826
98749: GO 98751
98751: DISABLE
98752: LD_INT 0
98754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98755: LD_ADDR_VAR 0 1
98759: PUSH
98760: LD_INT 22
98762: PUSH
98763: LD_OWVAR 2
98767: PUSH
98768: EMPTY
98769: LIST
98770: LIST
98771: PUSH
98772: LD_INT 21
98774: PUSH
98775: LD_INT 2
98777: PUSH
98778: EMPTY
98779: LIST
98780: LIST
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: PPUSH
98786: CALL_OW 69
98790: ST_TO_ADDR
// if not tmp then
98791: LD_VAR 0 1
98795: NOT
98796: IFFALSE 98800
// exit ;
98798: GO 98826
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98800: LD_VAR 0 1
98804: PUSH
98805: LD_INT 1
98807: PPUSH
98808: LD_VAR 0 1
98812: PPUSH
98813: CALL_OW 12
98817: ARRAY
98818: PPUSH
98819: LD_INT 60
98821: PPUSH
98822: CALL_OW 234
// end ;
98826: PPOPN 1
98828: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98829: LD_EXP 94
98833: PUSH
98834: LD_EXP 124
98838: AND
98839: IFFALSE 98938
98841: GO 98843
98843: DISABLE
98844: LD_INT 0
98846: PPUSH
98847: PPUSH
// begin enable ;
98848: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98849: LD_ADDR_VAR 0 1
98853: PUSH
98854: LD_INT 22
98856: PUSH
98857: LD_OWVAR 2
98861: PUSH
98862: EMPTY
98863: LIST
98864: LIST
98865: PUSH
98866: LD_INT 61
98868: PUSH
98869: EMPTY
98870: LIST
98871: PUSH
98872: LD_INT 33
98874: PUSH
98875: LD_INT 2
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: LIST
98886: PPUSH
98887: CALL_OW 69
98891: ST_TO_ADDR
// if not tmp then
98892: LD_VAR 0 1
98896: NOT
98897: IFFALSE 98901
// exit ;
98899: GO 98938
// for i in tmp do
98901: LD_ADDR_VAR 0 2
98905: PUSH
98906: LD_VAR 0 1
98910: PUSH
98911: FOR_IN
98912: IFFALSE 98936
// if IsControledBy ( i ) then
98914: LD_VAR 0 2
98918: PPUSH
98919: CALL_OW 312
98923: IFFALSE 98934
// ComUnlink ( i ) ;
98925: LD_VAR 0 2
98929: PPUSH
98930: CALL_OW 136
98934: GO 98911
98936: POP
98937: POP
// end ;
98938: PPOPN 2
98940: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98941: LD_EXP 94
98945: PUSH
98946: LD_EXP 125
98950: AND
98951: IFFALSE 99091
98953: GO 98955
98955: DISABLE
98956: LD_INT 0
98958: PPUSH
98959: PPUSH
// begin ToLua ( displayPowell(); ) ;
98960: LD_STRING displayPowell();
98962: PPUSH
98963: CALL_OW 559
// uc_side := 0 ;
98967: LD_ADDR_OWVAR 20
98971: PUSH
98972: LD_INT 0
98974: ST_TO_ADDR
// uc_nation := 2 ;
98975: LD_ADDR_OWVAR 21
98979: PUSH
98980: LD_INT 2
98982: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98983: LD_ADDR_OWVAR 37
98987: PUSH
98988: LD_INT 14
98990: ST_TO_ADDR
// vc_engine := engine_siberite ;
98991: LD_ADDR_OWVAR 39
98995: PUSH
98996: LD_INT 3
98998: ST_TO_ADDR
// vc_control := control_apeman ;
98999: LD_ADDR_OWVAR 38
99003: PUSH
99004: LD_INT 5
99006: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99007: LD_ADDR_OWVAR 40
99011: PUSH
99012: LD_INT 29
99014: ST_TO_ADDR
// un := CreateVehicle ;
99015: LD_ADDR_VAR 0 2
99019: PUSH
99020: CALL_OW 45
99024: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99025: LD_VAR 0 2
99029: PPUSH
99030: LD_INT 1
99032: PPUSH
99033: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99037: LD_INT 35
99039: PPUSH
99040: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99044: LD_VAR 0 2
99048: PPUSH
99049: LD_INT 22
99051: PUSH
99052: LD_OWVAR 2
99056: PUSH
99057: EMPTY
99058: LIST
99059: LIST
99060: PPUSH
99061: CALL_OW 69
99065: PPUSH
99066: LD_VAR 0 2
99070: PPUSH
99071: CALL_OW 74
99075: PPUSH
99076: CALL_OW 115
// until IsDead ( un ) ;
99080: LD_VAR 0 2
99084: PPUSH
99085: CALL_OW 301
99089: IFFALSE 99037
// end ;
99091: PPOPN 2
99093: END
// every 0 0$1 trigger StreamModeActive and sStu do
99094: LD_EXP 94
99098: PUSH
99099: LD_EXP 133
99103: AND
99104: IFFALSE 99120
99106: GO 99108
99108: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99109: LD_STRING displayStucuk();
99111: PPUSH
99112: CALL_OW 559
// ResetFog ;
99116: CALL_OW 335
// end ;
99120: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99121: LD_EXP 94
99125: PUSH
99126: LD_EXP 126
99130: AND
99131: IFFALSE 99272
99133: GO 99135
99135: DISABLE
99136: LD_INT 0
99138: PPUSH
99139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99140: LD_ADDR_VAR 0 2
99144: PUSH
99145: LD_INT 22
99147: PUSH
99148: LD_OWVAR 2
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: PUSH
99157: LD_INT 21
99159: PUSH
99160: LD_INT 1
99162: PUSH
99163: EMPTY
99164: LIST
99165: LIST
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: PPUSH
99171: CALL_OW 69
99175: ST_TO_ADDR
// if not tmp then
99176: LD_VAR 0 2
99180: NOT
99181: IFFALSE 99185
// exit ;
99183: GO 99272
// un := tmp [ rand ( 1 , tmp ) ] ;
99185: LD_ADDR_VAR 0 1
99189: PUSH
99190: LD_VAR 0 2
99194: PUSH
99195: LD_INT 1
99197: PPUSH
99198: LD_VAR 0 2
99202: PPUSH
99203: CALL_OW 12
99207: ARRAY
99208: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99209: LD_VAR 0 1
99213: PPUSH
99214: LD_INT 0
99216: PPUSH
99217: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99221: LD_VAR 0 1
99225: PPUSH
99226: LD_OWVAR 3
99230: PUSH
99231: LD_VAR 0 1
99235: DIFF
99236: PPUSH
99237: LD_VAR 0 1
99241: PPUSH
99242: CALL_OW 74
99246: PPUSH
99247: CALL_OW 115
// wait ( 0 0$20 ) ;
99251: LD_INT 700
99253: PPUSH
99254: CALL_OW 67
// SetSide ( un , your_side ) ;
99258: LD_VAR 0 1
99262: PPUSH
99263: LD_OWVAR 2
99267: PPUSH
99268: CALL_OW 235
// end ;
99272: PPOPN 2
99274: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99275: LD_EXP 94
99279: PUSH
99280: LD_EXP 127
99284: AND
99285: IFFALSE 99391
99287: GO 99289
99289: DISABLE
99290: LD_INT 0
99292: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99293: LD_ADDR_VAR 0 1
99297: PUSH
99298: LD_INT 22
99300: PUSH
99301: LD_OWVAR 2
99305: PUSH
99306: EMPTY
99307: LIST
99308: LIST
99309: PUSH
99310: LD_INT 2
99312: PUSH
99313: LD_INT 30
99315: PUSH
99316: LD_INT 0
99318: PUSH
99319: EMPTY
99320: LIST
99321: LIST
99322: PUSH
99323: LD_INT 30
99325: PUSH
99326: LD_INT 1
99328: PUSH
99329: EMPTY
99330: LIST
99331: LIST
99332: PUSH
99333: EMPTY
99334: LIST
99335: LIST
99336: LIST
99337: PUSH
99338: EMPTY
99339: LIST
99340: LIST
99341: PPUSH
99342: CALL_OW 69
99346: ST_TO_ADDR
// if not depot then
99347: LD_VAR 0 1
99351: NOT
99352: IFFALSE 99356
// exit ;
99354: GO 99391
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99356: LD_VAR 0 1
99360: PUSH
99361: LD_INT 1
99363: ARRAY
99364: PPUSH
99365: CALL_OW 250
99369: PPUSH
99370: LD_VAR 0 1
99374: PUSH
99375: LD_INT 1
99377: ARRAY
99378: PPUSH
99379: CALL_OW 251
99383: PPUSH
99384: LD_INT 70
99386: PPUSH
99387: CALL_OW 495
// end ;
99391: PPOPN 1
99393: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99394: LD_EXP 94
99398: PUSH
99399: LD_EXP 128
99403: AND
99404: IFFALSE 99615
99406: GO 99408
99408: DISABLE
99409: LD_INT 0
99411: PPUSH
99412: PPUSH
99413: PPUSH
99414: PPUSH
99415: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99416: LD_ADDR_VAR 0 5
99420: PUSH
99421: LD_INT 22
99423: PUSH
99424: LD_OWVAR 2
99428: PUSH
99429: EMPTY
99430: LIST
99431: LIST
99432: PUSH
99433: LD_INT 21
99435: PUSH
99436: LD_INT 1
99438: PUSH
99439: EMPTY
99440: LIST
99441: LIST
99442: PUSH
99443: EMPTY
99444: LIST
99445: LIST
99446: PPUSH
99447: CALL_OW 69
99451: ST_TO_ADDR
// if not tmp then
99452: LD_VAR 0 5
99456: NOT
99457: IFFALSE 99461
// exit ;
99459: GO 99615
// for i in tmp do
99461: LD_ADDR_VAR 0 1
99465: PUSH
99466: LD_VAR 0 5
99470: PUSH
99471: FOR_IN
99472: IFFALSE 99613
// begin d := rand ( 0 , 5 ) ;
99474: LD_ADDR_VAR 0 4
99478: PUSH
99479: LD_INT 0
99481: PPUSH
99482: LD_INT 5
99484: PPUSH
99485: CALL_OW 12
99489: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99490: LD_ADDR_VAR 0 2
99494: PUSH
99495: LD_VAR 0 1
99499: PPUSH
99500: CALL_OW 250
99504: PPUSH
99505: LD_VAR 0 4
99509: PPUSH
99510: LD_INT 3
99512: PPUSH
99513: LD_INT 12
99515: PPUSH
99516: CALL_OW 12
99520: PPUSH
99521: CALL_OW 272
99525: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99526: LD_ADDR_VAR 0 3
99530: PUSH
99531: LD_VAR 0 1
99535: PPUSH
99536: CALL_OW 251
99540: PPUSH
99541: LD_VAR 0 4
99545: PPUSH
99546: LD_INT 3
99548: PPUSH
99549: LD_INT 12
99551: PPUSH
99552: CALL_OW 12
99556: PPUSH
99557: CALL_OW 273
99561: ST_TO_ADDR
// if ValidHex ( x , y ) then
99562: LD_VAR 0 2
99566: PPUSH
99567: LD_VAR 0 3
99571: PPUSH
99572: CALL_OW 488
99576: IFFALSE 99611
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99578: LD_VAR 0 1
99582: PPUSH
99583: LD_VAR 0 2
99587: PPUSH
99588: LD_VAR 0 3
99592: PPUSH
99593: LD_INT 3
99595: PPUSH
99596: LD_INT 6
99598: PPUSH
99599: CALL_OW 12
99603: PPUSH
99604: LD_INT 1
99606: PPUSH
99607: CALL_OW 483
// end ;
99611: GO 99471
99613: POP
99614: POP
// end ;
99615: PPOPN 5
99617: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99618: LD_EXP 94
99622: PUSH
99623: LD_EXP 129
99627: AND
99628: IFFALSE 99722
99630: GO 99632
99632: DISABLE
99633: LD_INT 0
99635: PPUSH
99636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99637: LD_ADDR_VAR 0 2
99641: PUSH
99642: LD_INT 22
99644: PUSH
99645: LD_OWVAR 2
99649: PUSH
99650: EMPTY
99651: LIST
99652: LIST
99653: PUSH
99654: LD_INT 32
99656: PUSH
99657: LD_INT 1
99659: PUSH
99660: EMPTY
99661: LIST
99662: LIST
99663: PUSH
99664: LD_INT 21
99666: PUSH
99667: LD_INT 2
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: PUSH
99674: EMPTY
99675: LIST
99676: LIST
99677: LIST
99678: PPUSH
99679: CALL_OW 69
99683: ST_TO_ADDR
// if not tmp then
99684: LD_VAR 0 2
99688: NOT
99689: IFFALSE 99693
// exit ;
99691: GO 99722
// for i in tmp do
99693: LD_ADDR_VAR 0 1
99697: PUSH
99698: LD_VAR 0 2
99702: PUSH
99703: FOR_IN
99704: IFFALSE 99720
// SetFuel ( i , 0 ) ;
99706: LD_VAR 0 1
99710: PPUSH
99711: LD_INT 0
99713: PPUSH
99714: CALL_OW 240
99718: GO 99703
99720: POP
99721: POP
// end ;
99722: PPOPN 2
99724: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99725: LD_EXP 94
99729: PUSH
99730: LD_EXP 130
99734: AND
99735: IFFALSE 99801
99737: GO 99739
99739: DISABLE
99740: LD_INT 0
99742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99743: LD_ADDR_VAR 0 1
99747: PUSH
99748: LD_INT 22
99750: PUSH
99751: LD_OWVAR 2
99755: PUSH
99756: EMPTY
99757: LIST
99758: LIST
99759: PUSH
99760: LD_INT 30
99762: PUSH
99763: LD_INT 29
99765: PUSH
99766: EMPTY
99767: LIST
99768: LIST
99769: PUSH
99770: EMPTY
99771: LIST
99772: LIST
99773: PPUSH
99774: CALL_OW 69
99778: ST_TO_ADDR
// if not tmp then
99779: LD_VAR 0 1
99783: NOT
99784: IFFALSE 99788
// exit ;
99786: GO 99801
// DestroyUnit ( tmp [ 1 ] ) ;
99788: LD_VAR 0 1
99792: PUSH
99793: LD_INT 1
99795: ARRAY
99796: PPUSH
99797: CALL_OW 65
// end ;
99801: PPOPN 1
99803: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99804: LD_EXP 94
99808: PUSH
99809: LD_EXP 132
99813: AND
99814: IFFALSE 99943
99816: GO 99818
99818: DISABLE
99819: LD_INT 0
99821: PPUSH
// begin uc_side := 0 ;
99822: LD_ADDR_OWVAR 20
99826: PUSH
99827: LD_INT 0
99829: ST_TO_ADDR
// uc_nation := nation_arabian ;
99830: LD_ADDR_OWVAR 21
99834: PUSH
99835: LD_INT 2
99837: ST_TO_ADDR
// hc_gallery :=  ;
99838: LD_ADDR_OWVAR 33
99842: PUSH
99843: LD_STRING 
99845: ST_TO_ADDR
// hc_name :=  ;
99846: LD_ADDR_OWVAR 26
99850: PUSH
99851: LD_STRING 
99853: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99854: LD_INT 1
99856: PPUSH
99857: LD_INT 11
99859: PPUSH
99860: LD_INT 10
99862: PPUSH
99863: CALL_OW 380
// un := CreateHuman ;
99867: LD_ADDR_VAR 0 1
99871: PUSH
99872: CALL_OW 44
99876: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99877: LD_VAR 0 1
99881: PPUSH
99882: LD_INT 1
99884: PPUSH
99885: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99889: LD_INT 35
99891: PPUSH
99892: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99896: LD_VAR 0 1
99900: PPUSH
99901: LD_INT 22
99903: PUSH
99904: LD_OWVAR 2
99908: PUSH
99909: EMPTY
99910: LIST
99911: LIST
99912: PPUSH
99913: CALL_OW 69
99917: PPUSH
99918: LD_VAR 0 1
99922: PPUSH
99923: CALL_OW 74
99927: PPUSH
99928: CALL_OW 115
// until IsDead ( un ) ;
99932: LD_VAR 0 1
99936: PPUSH
99937: CALL_OW 301
99941: IFFALSE 99889
// end ;
99943: PPOPN 1
99945: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99946: LD_EXP 94
99950: PUSH
99951: LD_EXP 134
99955: AND
99956: IFFALSE 99968
99958: GO 99960
99960: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99961: LD_STRING earthquake(getX(game), 0, 32)
99963: PPUSH
99964: CALL_OW 559
99968: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99969: LD_EXP 94
99973: PUSH
99974: LD_EXP 135
99978: AND
99979: IFFALSE 100070
99981: GO 99983
99983: DISABLE
99984: LD_INT 0
99986: PPUSH
// begin enable ;
99987: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99988: LD_ADDR_VAR 0 1
99992: PUSH
99993: LD_INT 22
99995: PUSH
99996: LD_OWVAR 2
100000: PUSH
100001: EMPTY
100002: LIST
100003: LIST
100004: PUSH
100005: LD_INT 21
100007: PUSH
100008: LD_INT 2
100010: PUSH
100011: EMPTY
100012: LIST
100013: LIST
100014: PUSH
100015: LD_INT 33
100017: PUSH
100018: LD_INT 3
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: PUSH
100025: EMPTY
100026: LIST
100027: LIST
100028: LIST
100029: PPUSH
100030: CALL_OW 69
100034: ST_TO_ADDR
// if not tmp then
100035: LD_VAR 0 1
100039: NOT
100040: IFFALSE 100044
// exit ;
100042: GO 100070
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100044: LD_VAR 0 1
100048: PUSH
100049: LD_INT 1
100051: PPUSH
100052: LD_VAR 0 1
100056: PPUSH
100057: CALL_OW 12
100061: ARRAY
100062: PPUSH
100063: LD_INT 1
100065: PPUSH
100066: CALL_OW 234
// end ;
100070: PPOPN 1
100072: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100073: LD_EXP 94
100077: PUSH
100078: LD_EXP 136
100082: AND
100083: IFFALSE 100224
100085: GO 100087
100087: DISABLE
100088: LD_INT 0
100090: PPUSH
100091: PPUSH
100092: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100093: LD_ADDR_VAR 0 3
100097: PUSH
100098: LD_INT 22
100100: PUSH
100101: LD_OWVAR 2
100105: PUSH
100106: EMPTY
100107: LIST
100108: LIST
100109: PUSH
100110: LD_INT 25
100112: PUSH
100113: LD_INT 1
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: PUSH
100120: EMPTY
100121: LIST
100122: LIST
100123: PPUSH
100124: CALL_OW 69
100128: ST_TO_ADDR
// if not tmp then
100129: LD_VAR 0 3
100133: NOT
100134: IFFALSE 100138
// exit ;
100136: GO 100224
// un := tmp [ rand ( 1 , tmp ) ] ;
100138: LD_ADDR_VAR 0 2
100142: PUSH
100143: LD_VAR 0 3
100147: PUSH
100148: LD_INT 1
100150: PPUSH
100151: LD_VAR 0 3
100155: PPUSH
100156: CALL_OW 12
100160: ARRAY
100161: ST_TO_ADDR
// if Crawls ( un ) then
100162: LD_VAR 0 2
100166: PPUSH
100167: CALL_OW 318
100171: IFFALSE 100182
// ComWalk ( un ) ;
100173: LD_VAR 0 2
100177: PPUSH
100178: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100182: LD_VAR 0 2
100186: PPUSH
100187: LD_INT 9
100189: PPUSH
100190: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100194: LD_INT 28
100196: PPUSH
100197: LD_OWVAR 2
100201: PPUSH
100202: LD_INT 2
100204: PPUSH
100205: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100209: LD_INT 29
100211: PPUSH
100212: LD_OWVAR 2
100216: PPUSH
100217: LD_INT 2
100219: PPUSH
100220: CALL_OW 322
// end ;
100224: PPOPN 3
100226: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100227: LD_EXP 94
100231: PUSH
100232: LD_EXP 137
100236: AND
100237: IFFALSE 100348
100239: GO 100241
100241: DISABLE
100242: LD_INT 0
100244: PPUSH
100245: PPUSH
100246: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100247: LD_ADDR_VAR 0 3
100251: PUSH
100252: LD_INT 22
100254: PUSH
100255: LD_OWVAR 2
100259: PUSH
100260: EMPTY
100261: LIST
100262: LIST
100263: PUSH
100264: LD_INT 25
100266: PUSH
100267: LD_INT 1
100269: PUSH
100270: EMPTY
100271: LIST
100272: LIST
100273: PUSH
100274: EMPTY
100275: LIST
100276: LIST
100277: PPUSH
100278: CALL_OW 69
100282: ST_TO_ADDR
// if not tmp then
100283: LD_VAR 0 3
100287: NOT
100288: IFFALSE 100292
// exit ;
100290: GO 100348
// un := tmp [ rand ( 1 , tmp ) ] ;
100292: LD_ADDR_VAR 0 2
100296: PUSH
100297: LD_VAR 0 3
100301: PUSH
100302: LD_INT 1
100304: PPUSH
100305: LD_VAR 0 3
100309: PPUSH
100310: CALL_OW 12
100314: ARRAY
100315: ST_TO_ADDR
// if Crawls ( un ) then
100316: LD_VAR 0 2
100320: PPUSH
100321: CALL_OW 318
100325: IFFALSE 100336
// ComWalk ( un ) ;
100327: LD_VAR 0 2
100331: PPUSH
100332: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100336: LD_VAR 0 2
100340: PPUSH
100341: LD_INT 8
100343: PPUSH
100344: CALL_OW 336
// end ;
100348: PPOPN 3
100350: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100351: LD_EXP 94
100355: PUSH
100356: LD_EXP 138
100360: AND
100361: IFFALSE 100505
100363: GO 100365
100365: DISABLE
100366: LD_INT 0
100368: PPUSH
100369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100370: LD_ADDR_VAR 0 2
100374: PUSH
100375: LD_INT 22
100377: PUSH
100378: LD_OWVAR 2
100382: PUSH
100383: EMPTY
100384: LIST
100385: LIST
100386: PUSH
100387: LD_INT 21
100389: PUSH
100390: LD_INT 2
100392: PUSH
100393: EMPTY
100394: LIST
100395: LIST
100396: PUSH
100397: LD_INT 2
100399: PUSH
100400: LD_INT 34
100402: PUSH
100403: LD_INT 12
100405: PUSH
100406: EMPTY
100407: LIST
100408: LIST
100409: PUSH
100410: LD_INT 34
100412: PUSH
100413: LD_INT 51
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: PUSH
100420: LD_INT 34
100422: PUSH
100423: LD_INT 32
100425: PUSH
100426: EMPTY
100427: LIST
100428: LIST
100429: PUSH
100430: EMPTY
100431: LIST
100432: LIST
100433: LIST
100434: LIST
100435: PUSH
100436: EMPTY
100437: LIST
100438: LIST
100439: LIST
100440: PPUSH
100441: CALL_OW 69
100445: ST_TO_ADDR
// if not tmp then
100446: LD_VAR 0 2
100450: NOT
100451: IFFALSE 100455
// exit ;
100453: GO 100505
// for i in tmp do
100455: LD_ADDR_VAR 0 1
100459: PUSH
100460: LD_VAR 0 2
100464: PUSH
100465: FOR_IN
100466: IFFALSE 100503
// if GetCargo ( i , mat_artifact ) = 0 then
100468: LD_VAR 0 1
100472: PPUSH
100473: LD_INT 4
100475: PPUSH
100476: CALL_OW 289
100480: PUSH
100481: LD_INT 0
100483: EQUAL
100484: IFFALSE 100501
// SetCargo ( i , mat_siberit , 100 ) ;
100486: LD_VAR 0 1
100490: PPUSH
100491: LD_INT 3
100493: PPUSH
100494: LD_INT 100
100496: PPUSH
100497: CALL_OW 290
100501: GO 100465
100503: POP
100504: POP
// end ;
100505: PPOPN 2
100507: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100508: LD_EXP 94
100512: PUSH
100513: LD_EXP 139
100517: AND
100518: IFFALSE 100701
100520: GO 100522
100522: DISABLE
100523: LD_INT 0
100525: PPUSH
100526: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100527: LD_ADDR_VAR 0 2
100531: PUSH
100532: LD_INT 22
100534: PUSH
100535: LD_OWVAR 2
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PPUSH
100544: CALL_OW 69
100548: ST_TO_ADDR
// if not tmp then
100549: LD_VAR 0 2
100553: NOT
100554: IFFALSE 100558
// exit ;
100556: GO 100701
// for i := 1 to 2 do
100558: LD_ADDR_VAR 0 1
100562: PUSH
100563: DOUBLE
100564: LD_INT 1
100566: DEC
100567: ST_TO_ADDR
100568: LD_INT 2
100570: PUSH
100571: FOR_TO
100572: IFFALSE 100699
// begin uc_side := your_side ;
100574: LD_ADDR_OWVAR 20
100578: PUSH
100579: LD_OWVAR 2
100583: ST_TO_ADDR
// uc_nation := nation_american ;
100584: LD_ADDR_OWVAR 21
100588: PUSH
100589: LD_INT 1
100591: ST_TO_ADDR
// vc_chassis := us_morphling ;
100592: LD_ADDR_OWVAR 37
100596: PUSH
100597: LD_INT 5
100599: ST_TO_ADDR
// vc_engine := engine_siberite ;
100600: LD_ADDR_OWVAR 39
100604: PUSH
100605: LD_INT 3
100607: ST_TO_ADDR
// vc_control := control_computer ;
100608: LD_ADDR_OWVAR 38
100612: PUSH
100613: LD_INT 3
100615: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100616: LD_ADDR_OWVAR 40
100620: PUSH
100621: LD_INT 10
100623: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100624: LD_VAR 0 2
100628: PUSH
100629: LD_INT 1
100631: ARRAY
100632: PPUSH
100633: CALL_OW 310
100637: NOT
100638: IFFALSE 100685
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100640: CALL_OW 45
100644: PPUSH
100645: LD_VAR 0 2
100649: PUSH
100650: LD_INT 1
100652: ARRAY
100653: PPUSH
100654: CALL_OW 250
100658: PPUSH
100659: LD_VAR 0 2
100663: PUSH
100664: LD_INT 1
100666: ARRAY
100667: PPUSH
100668: CALL_OW 251
100672: PPUSH
100673: LD_INT 12
100675: PPUSH
100676: LD_INT 1
100678: PPUSH
100679: CALL_OW 50
100683: GO 100697
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100685: CALL_OW 45
100689: PPUSH
100690: LD_INT 1
100692: PPUSH
100693: CALL_OW 51
// end ;
100697: GO 100571
100699: POP
100700: POP
// end ;
100701: PPOPN 2
100703: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100704: LD_EXP 94
100708: PUSH
100709: LD_EXP 140
100713: AND
100714: IFFALSE 100936
100716: GO 100718
100718: DISABLE
100719: LD_INT 0
100721: PPUSH
100722: PPUSH
100723: PPUSH
100724: PPUSH
100725: PPUSH
100726: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100727: LD_ADDR_VAR 0 6
100731: PUSH
100732: LD_INT 22
100734: PUSH
100735: LD_OWVAR 2
100739: PUSH
100740: EMPTY
100741: LIST
100742: LIST
100743: PUSH
100744: LD_INT 21
100746: PUSH
100747: LD_INT 1
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: PUSH
100754: LD_INT 3
100756: PUSH
100757: LD_INT 23
100759: PUSH
100760: LD_INT 0
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: EMPTY
100768: LIST
100769: LIST
100770: PUSH
100771: EMPTY
100772: LIST
100773: LIST
100774: LIST
100775: PPUSH
100776: CALL_OW 69
100780: ST_TO_ADDR
// if not tmp then
100781: LD_VAR 0 6
100785: NOT
100786: IFFALSE 100790
// exit ;
100788: GO 100936
// s1 := rand ( 1 , 4 ) ;
100790: LD_ADDR_VAR 0 2
100794: PUSH
100795: LD_INT 1
100797: PPUSH
100798: LD_INT 4
100800: PPUSH
100801: CALL_OW 12
100805: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100806: LD_ADDR_VAR 0 4
100810: PUSH
100811: LD_VAR 0 6
100815: PUSH
100816: LD_INT 1
100818: ARRAY
100819: PPUSH
100820: LD_VAR 0 2
100824: PPUSH
100825: CALL_OW 259
100829: ST_TO_ADDR
// if s1 = 1 then
100830: LD_VAR 0 2
100834: PUSH
100835: LD_INT 1
100837: EQUAL
100838: IFFALSE 100858
// s2 := rand ( 2 , 4 ) else
100840: LD_ADDR_VAR 0 3
100844: PUSH
100845: LD_INT 2
100847: PPUSH
100848: LD_INT 4
100850: PPUSH
100851: CALL_OW 12
100855: ST_TO_ADDR
100856: GO 100866
// s2 := 1 ;
100858: LD_ADDR_VAR 0 3
100862: PUSH
100863: LD_INT 1
100865: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100866: LD_ADDR_VAR 0 5
100870: PUSH
100871: LD_VAR 0 6
100875: PUSH
100876: LD_INT 1
100878: ARRAY
100879: PPUSH
100880: LD_VAR 0 3
100884: PPUSH
100885: CALL_OW 259
100889: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100890: LD_VAR 0 6
100894: PUSH
100895: LD_INT 1
100897: ARRAY
100898: PPUSH
100899: LD_VAR 0 2
100903: PPUSH
100904: LD_VAR 0 5
100908: PPUSH
100909: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100913: LD_VAR 0 6
100917: PUSH
100918: LD_INT 1
100920: ARRAY
100921: PPUSH
100922: LD_VAR 0 3
100926: PPUSH
100927: LD_VAR 0 4
100931: PPUSH
100932: CALL_OW 237
// end ;
100936: PPOPN 6
100938: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100939: LD_EXP 94
100943: PUSH
100944: LD_EXP 141
100948: AND
100949: IFFALSE 101028
100951: GO 100953
100953: DISABLE
100954: LD_INT 0
100956: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100957: LD_ADDR_VAR 0 1
100961: PUSH
100962: LD_INT 22
100964: PUSH
100965: LD_OWVAR 2
100969: PUSH
100970: EMPTY
100971: LIST
100972: LIST
100973: PUSH
100974: LD_INT 30
100976: PUSH
100977: LD_INT 3
100979: PUSH
100980: EMPTY
100981: LIST
100982: LIST
100983: PUSH
100984: EMPTY
100985: LIST
100986: LIST
100987: PPUSH
100988: CALL_OW 69
100992: ST_TO_ADDR
// if not tmp then
100993: LD_VAR 0 1
100997: NOT
100998: IFFALSE 101002
// exit ;
101000: GO 101028
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101002: LD_VAR 0 1
101006: PUSH
101007: LD_INT 1
101009: PPUSH
101010: LD_VAR 0 1
101014: PPUSH
101015: CALL_OW 12
101019: ARRAY
101020: PPUSH
101021: LD_INT 1
101023: PPUSH
101024: CALL_OW 234
// end ;
101028: PPOPN 1
101030: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101031: LD_EXP 94
101035: PUSH
101036: LD_EXP 142
101040: AND
101041: IFFALSE 101153
101043: GO 101045
101045: DISABLE
101046: LD_INT 0
101048: PPUSH
101049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101050: LD_ADDR_VAR 0 2
101054: PUSH
101055: LD_INT 22
101057: PUSH
101058: LD_OWVAR 2
101062: PUSH
101063: EMPTY
101064: LIST
101065: LIST
101066: PUSH
101067: LD_INT 2
101069: PUSH
101070: LD_INT 30
101072: PUSH
101073: LD_INT 27
101075: PUSH
101076: EMPTY
101077: LIST
101078: LIST
101079: PUSH
101080: LD_INT 30
101082: PUSH
101083: LD_INT 26
101085: PUSH
101086: EMPTY
101087: LIST
101088: LIST
101089: PUSH
101090: LD_INT 30
101092: PUSH
101093: LD_INT 28
101095: PUSH
101096: EMPTY
101097: LIST
101098: LIST
101099: PUSH
101100: EMPTY
101101: LIST
101102: LIST
101103: LIST
101104: LIST
101105: PUSH
101106: EMPTY
101107: LIST
101108: LIST
101109: PPUSH
101110: CALL_OW 69
101114: ST_TO_ADDR
// if not tmp then
101115: LD_VAR 0 2
101119: NOT
101120: IFFALSE 101124
// exit ;
101122: GO 101153
// for i in tmp do
101124: LD_ADDR_VAR 0 1
101128: PUSH
101129: LD_VAR 0 2
101133: PUSH
101134: FOR_IN
101135: IFFALSE 101151
// SetLives ( i , 1 ) ;
101137: LD_VAR 0 1
101141: PPUSH
101142: LD_INT 1
101144: PPUSH
101145: CALL_OW 234
101149: GO 101134
101151: POP
101152: POP
// end ;
101153: PPOPN 2
101155: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101156: LD_EXP 94
101160: PUSH
101161: LD_EXP 143
101165: AND
101166: IFFALSE 101453
101168: GO 101170
101170: DISABLE
101171: LD_INT 0
101173: PPUSH
101174: PPUSH
101175: PPUSH
// begin i := rand ( 1 , 7 ) ;
101176: LD_ADDR_VAR 0 1
101180: PUSH
101181: LD_INT 1
101183: PPUSH
101184: LD_INT 7
101186: PPUSH
101187: CALL_OW 12
101191: ST_TO_ADDR
// case i of 1 :
101192: LD_VAR 0 1
101196: PUSH
101197: LD_INT 1
101199: DOUBLE
101200: EQUAL
101201: IFTRUE 101205
101203: GO 101215
101205: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101206: LD_STRING earthquake(getX(game), 0, 32)
101208: PPUSH
101209: CALL_OW 559
101213: GO 101453
101215: LD_INT 2
101217: DOUBLE
101218: EQUAL
101219: IFTRUE 101223
101221: GO 101237
101223: POP
// begin ToLua ( displayStucuk(); ) ;
101224: LD_STRING displayStucuk();
101226: PPUSH
101227: CALL_OW 559
// ResetFog ;
101231: CALL_OW 335
// end ; 3 :
101235: GO 101453
101237: LD_INT 3
101239: DOUBLE
101240: EQUAL
101241: IFTRUE 101245
101243: GO 101349
101245: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101246: LD_ADDR_VAR 0 2
101250: PUSH
101251: LD_INT 22
101253: PUSH
101254: LD_OWVAR 2
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: PUSH
101263: LD_INT 25
101265: PUSH
101266: LD_INT 1
101268: PUSH
101269: EMPTY
101270: LIST
101271: LIST
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: PPUSH
101277: CALL_OW 69
101281: ST_TO_ADDR
// if not tmp then
101282: LD_VAR 0 2
101286: NOT
101287: IFFALSE 101291
// exit ;
101289: GO 101453
// un := tmp [ rand ( 1 , tmp ) ] ;
101291: LD_ADDR_VAR 0 3
101295: PUSH
101296: LD_VAR 0 2
101300: PUSH
101301: LD_INT 1
101303: PPUSH
101304: LD_VAR 0 2
101308: PPUSH
101309: CALL_OW 12
101313: ARRAY
101314: ST_TO_ADDR
// if Crawls ( un ) then
101315: LD_VAR 0 3
101319: PPUSH
101320: CALL_OW 318
101324: IFFALSE 101335
// ComWalk ( un ) ;
101326: LD_VAR 0 3
101330: PPUSH
101331: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101335: LD_VAR 0 3
101339: PPUSH
101340: LD_INT 8
101342: PPUSH
101343: CALL_OW 336
// end ; 4 :
101347: GO 101453
101349: LD_INT 4
101351: DOUBLE
101352: EQUAL
101353: IFTRUE 101357
101355: GO 101431
101357: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101358: LD_ADDR_VAR 0 2
101362: PUSH
101363: LD_INT 22
101365: PUSH
101366: LD_OWVAR 2
101370: PUSH
101371: EMPTY
101372: LIST
101373: LIST
101374: PUSH
101375: LD_INT 30
101377: PUSH
101378: LD_INT 29
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: PUSH
101385: EMPTY
101386: LIST
101387: LIST
101388: PPUSH
101389: CALL_OW 69
101393: ST_TO_ADDR
// if not tmp then
101394: LD_VAR 0 2
101398: NOT
101399: IFFALSE 101403
// exit ;
101401: GO 101453
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101403: LD_VAR 0 2
101407: PUSH
101408: LD_INT 1
101410: ARRAY
101411: PPUSH
101412: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101416: LD_VAR 0 2
101420: PUSH
101421: LD_INT 1
101423: ARRAY
101424: PPUSH
101425: CALL_OW 65
// end ; 5 .. 7 :
101429: GO 101453
101431: LD_INT 5
101433: DOUBLE
101434: GREATEREQUAL
101435: IFFALSE 101443
101437: LD_INT 7
101439: DOUBLE
101440: LESSEQUAL
101441: IFTRUE 101445
101443: GO 101452
101445: POP
// StreamSibBomb ; end ;
101446: CALL 97690 0 0
101450: GO 101453
101452: POP
// end ;
101453: PPOPN 3
101455: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101456: LD_EXP 94
101460: PUSH
101461: LD_EXP 144
101465: AND
101466: IFFALSE 101622
101468: GO 101470
101470: DISABLE
101471: LD_INT 0
101473: PPUSH
101474: PPUSH
101475: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101476: LD_ADDR_VAR 0 2
101480: PUSH
101481: LD_INT 81
101483: PUSH
101484: LD_OWVAR 2
101488: PUSH
101489: EMPTY
101490: LIST
101491: LIST
101492: PUSH
101493: LD_INT 2
101495: PUSH
101496: LD_INT 21
101498: PUSH
101499: LD_INT 1
101501: PUSH
101502: EMPTY
101503: LIST
101504: LIST
101505: PUSH
101506: LD_INT 21
101508: PUSH
101509: LD_INT 2
101511: PUSH
101512: EMPTY
101513: LIST
101514: LIST
101515: PUSH
101516: EMPTY
101517: LIST
101518: LIST
101519: LIST
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: PPUSH
101525: CALL_OW 69
101529: ST_TO_ADDR
// if not tmp then
101530: LD_VAR 0 2
101534: NOT
101535: IFFALSE 101539
// exit ;
101537: GO 101622
// p := 0 ;
101539: LD_ADDR_VAR 0 3
101543: PUSH
101544: LD_INT 0
101546: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101547: LD_INT 35
101549: PPUSH
101550: CALL_OW 67
// p := p + 1 ;
101554: LD_ADDR_VAR 0 3
101558: PUSH
101559: LD_VAR 0 3
101563: PUSH
101564: LD_INT 1
101566: PLUS
101567: ST_TO_ADDR
// for i in tmp do
101568: LD_ADDR_VAR 0 1
101572: PUSH
101573: LD_VAR 0 2
101577: PUSH
101578: FOR_IN
101579: IFFALSE 101610
// if GetLives ( i ) < 1000 then
101581: LD_VAR 0 1
101585: PPUSH
101586: CALL_OW 256
101590: PUSH
101591: LD_INT 1000
101593: LESS
101594: IFFALSE 101608
// SetLives ( i , 1000 ) ;
101596: LD_VAR 0 1
101600: PPUSH
101601: LD_INT 1000
101603: PPUSH
101604: CALL_OW 234
101608: GO 101578
101610: POP
101611: POP
// until p > 20 ;
101612: LD_VAR 0 3
101616: PUSH
101617: LD_INT 20
101619: GREATER
101620: IFFALSE 101547
// end ;
101622: PPOPN 3
101624: END
// every 0 0$1 trigger StreamModeActive and sTime do
101625: LD_EXP 94
101629: PUSH
101630: LD_EXP 145
101634: AND
101635: IFFALSE 101670
101637: GO 101639
101639: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101640: LD_INT 28
101642: PPUSH
101643: LD_OWVAR 2
101647: PPUSH
101648: LD_INT 2
101650: PPUSH
101651: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101655: LD_INT 30
101657: PPUSH
101658: LD_OWVAR 2
101662: PPUSH
101663: LD_INT 2
101665: PPUSH
101666: CALL_OW 322
// end ;
101670: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101671: LD_EXP 94
101675: PUSH
101676: LD_EXP 146
101680: AND
101681: IFFALSE 101802
101683: GO 101685
101685: DISABLE
101686: LD_INT 0
101688: PPUSH
101689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101690: LD_ADDR_VAR 0 2
101694: PUSH
101695: LD_INT 22
101697: PUSH
101698: LD_OWVAR 2
101702: PUSH
101703: EMPTY
101704: LIST
101705: LIST
101706: PUSH
101707: LD_INT 21
101709: PUSH
101710: LD_INT 1
101712: PUSH
101713: EMPTY
101714: LIST
101715: LIST
101716: PUSH
101717: LD_INT 3
101719: PUSH
101720: LD_INT 23
101722: PUSH
101723: LD_INT 0
101725: PUSH
101726: EMPTY
101727: LIST
101728: LIST
101729: PUSH
101730: EMPTY
101731: LIST
101732: LIST
101733: PUSH
101734: EMPTY
101735: LIST
101736: LIST
101737: LIST
101738: PPUSH
101739: CALL_OW 69
101743: ST_TO_ADDR
// if not tmp then
101744: LD_VAR 0 2
101748: NOT
101749: IFFALSE 101753
// exit ;
101751: GO 101802
// for i in tmp do
101753: LD_ADDR_VAR 0 1
101757: PUSH
101758: LD_VAR 0 2
101762: PUSH
101763: FOR_IN
101764: IFFALSE 101800
// begin if Crawls ( i ) then
101766: LD_VAR 0 1
101770: PPUSH
101771: CALL_OW 318
101775: IFFALSE 101786
// ComWalk ( i ) ;
101777: LD_VAR 0 1
101781: PPUSH
101782: CALL_OW 138
// SetClass ( i , 2 ) ;
101786: LD_VAR 0 1
101790: PPUSH
101791: LD_INT 2
101793: PPUSH
101794: CALL_OW 336
// end ;
101798: GO 101763
101800: POP
101801: POP
// end ;
101802: PPOPN 2
101804: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101805: LD_EXP 94
101809: PUSH
101810: LD_EXP 147
101814: AND
101815: IFFALSE 102103
101817: GO 101819
101819: DISABLE
101820: LD_INT 0
101822: PPUSH
101823: PPUSH
101824: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101825: LD_OWVAR 2
101829: PPUSH
101830: LD_INT 9
101832: PPUSH
101833: LD_INT 1
101835: PPUSH
101836: LD_INT 1
101838: PPUSH
101839: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101843: LD_INT 9
101845: PPUSH
101846: LD_OWVAR 2
101850: PPUSH
101851: CALL_OW 343
// uc_side := 9 ;
101855: LD_ADDR_OWVAR 20
101859: PUSH
101860: LD_INT 9
101862: ST_TO_ADDR
// uc_nation := 2 ;
101863: LD_ADDR_OWVAR 21
101867: PUSH
101868: LD_INT 2
101870: ST_TO_ADDR
// hc_name := Dark Warrior ;
101871: LD_ADDR_OWVAR 26
101875: PUSH
101876: LD_STRING Dark Warrior
101878: ST_TO_ADDR
// hc_gallery :=  ;
101879: LD_ADDR_OWVAR 33
101883: PUSH
101884: LD_STRING 
101886: ST_TO_ADDR
// hc_noskilllimit := true ;
101887: LD_ADDR_OWVAR 76
101891: PUSH
101892: LD_INT 1
101894: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101895: LD_ADDR_OWVAR 31
101899: PUSH
101900: LD_INT 30
101902: PUSH
101903: LD_INT 30
101905: PUSH
101906: LD_INT 30
101908: PUSH
101909: LD_INT 30
101911: PUSH
101912: EMPTY
101913: LIST
101914: LIST
101915: LIST
101916: LIST
101917: ST_TO_ADDR
// un := CreateHuman ;
101918: LD_ADDR_VAR 0 3
101922: PUSH
101923: CALL_OW 44
101927: ST_TO_ADDR
// hc_noskilllimit := false ;
101928: LD_ADDR_OWVAR 76
101932: PUSH
101933: LD_INT 0
101935: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101936: LD_VAR 0 3
101940: PPUSH
101941: LD_INT 1
101943: PPUSH
101944: CALL_OW 51
// ToLua ( playRanger() ) ;
101948: LD_STRING playRanger()
101950: PPUSH
101951: CALL_OW 559
// p := 0 ;
101955: LD_ADDR_VAR 0 2
101959: PUSH
101960: LD_INT 0
101962: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101963: LD_INT 35
101965: PPUSH
101966: CALL_OW 67
// p := p + 1 ;
101970: LD_ADDR_VAR 0 2
101974: PUSH
101975: LD_VAR 0 2
101979: PUSH
101980: LD_INT 1
101982: PLUS
101983: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101984: LD_VAR 0 3
101988: PPUSH
101989: CALL_OW 256
101993: PUSH
101994: LD_INT 1000
101996: LESS
101997: IFFALSE 102011
// SetLives ( un , 1000 ) ;
101999: LD_VAR 0 3
102003: PPUSH
102004: LD_INT 1000
102006: PPUSH
102007: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102011: LD_VAR 0 3
102015: PPUSH
102016: LD_INT 81
102018: PUSH
102019: LD_OWVAR 2
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: PUSH
102028: LD_INT 91
102030: PUSH
102031: LD_VAR 0 3
102035: PUSH
102036: LD_INT 30
102038: PUSH
102039: EMPTY
102040: LIST
102041: LIST
102042: LIST
102043: PUSH
102044: EMPTY
102045: LIST
102046: LIST
102047: PPUSH
102048: CALL_OW 69
102052: PPUSH
102053: LD_VAR 0 3
102057: PPUSH
102058: CALL_OW 74
102062: PPUSH
102063: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102067: LD_VAR 0 2
102071: PUSH
102072: LD_INT 80
102074: GREATER
102075: PUSH
102076: LD_VAR 0 3
102080: PPUSH
102081: CALL_OW 301
102085: OR
102086: IFFALSE 101963
// if un then
102088: LD_VAR 0 3
102092: IFFALSE 102103
// RemoveUnit ( un ) ;
102094: LD_VAR 0 3
102098: PPUSH
102099: CALL_OW 64
// end ;
102103: PPOPN 3
102105: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102106: LD_EXP 148
102110: IFFALSE 102226
102112: GO 102114
102114: DISABLE
102115: LD_INT 0
102117: PPUSH
102118: PPUSH
102119: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102120: LD_ADDR_VAR 0 2
102124: PUSH
102125: LD_INT 81
102127: PUSH
102128: LD_OWVAR 2
102132: PUSH
102133: EMPTY
102134: LIST
102135: LIST
102136: PUSH
102137: LD_INT 21
102139: PUSH
102140: LD_INT 1
102142: PUSH
102143: EMPTY
102144: LIST
102145: LIST
102146: PUSH
102147: EMPTY
102148: LIST
102149: LIST
102150: PPUSH
102151: CALL_OW 69
102155: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102156: LD_STRING playComputer()
102158: PPUSH
102159: CALL_OW 559
// if not tmp then
102163: LD_VAR 0 2
102167: NOT
102168: IFFALSE 102172
// exit ;
102170: GO 102226
// for i in tmp do
102172: LD_ADDR_VAR 0 1
102176: PUSH
102177: LD_VAR 0 2
102181: PUSH
102182: FOR_IN
102183: IFFALSE 102224
// for j := 1 to 4 do
102185: LD_ADDR_VAR 0 3
102189: PUSH
102190: DOUBLE
102191: LD_INT 1
102193: DEC
102194: ST_TO_ADDR
102195: LD_INT 4
102197: PUSH
102198: FOR_TO
102199: IFFALSE 102220
// SetSkill ( i , j , 10 ) ;
102201: LD_VAR 0 1
102205: PPUSH
102206: LD_VAR 0 3
102210: PPUSH
102211: LD_INT 10
102213: PPUSH
102214: CALL_OW 237
102218: GO 102198
102220: POP
102221: POP
102222: GO 102182
102224: POP
102225: POP
// end ;
102226: PPOPN 3
102228: END
// every 0 0$1 trigger s30 do var i , tmp ;
102229: LD_EXP 149
102233: IFFALSE 102302
102235: GO 102237
102237: DISABLE
102238: LD_INT 0
102240: PPUSH
102241: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102242: LD_ADDR_VAR 0 2
102246: PUSH
102247: LD_INT 22
102249: PUSH
102250: LD_OWVAR 2
102254: PUSH
102255: EMPTY
102256: LIST
102257: LIST
102258: PPUSH
102259: CALL_OW 69
102263: ST_TO_ADDR
// if not tmp then
102264: LD_VAR 0 2
102268: NOT
102269: IFFALSE 102273
// exit ;
102271: GO 102302
// for i in tmp do
102273: LD_ADDR_VAR 0 1
102277: PUSH
102278: LD_VAR 0 2
102282: PUSH
102283: FOR_IN
102284: IFFALSE 102300
// SetLives ( i , 300 ) ;
102286: LD_VAR 0 1
102290: PPUSH
102291: LD_INT 300
102293: PPUSH
102294: CALL_OW 234
102298: GO 102283
102300: POP
102301: POP
// end ;
102302: PPOPN 2
102304: END
// every 0 0$1 trigger s60 do var i , tmp ;
102305: LD_EXP 150
102309: IFFALSE 102378
102311: GO 102313
102313: DISABLE
102314: LD_INT 0
102316: PPUSH
102317: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102318: LD_ADDR_VAR 0 2
102322: PUSH
102323: LD_INT 22
102325: PUSH
102326: LD_OWVAR 2
102330: PUSH
102331: EMPTY
102332: LIST
102333: LIST
102334: PPUSH
102335: CALL_OW 69
102339: ST_TO_ADDR
// if not tmp then
102340: LD_VAR 0 2
102344: NOT
102345: IFFALSE 102349
// exit ;
102347: GO 102378
// for i in tmp do
102349: LD_ADDR_VAR 0 1
102353: PUSH
102354: LD_VAR 0 2
102358: PUSH
102359: FOR_IN
102360: IFFALSE 102376
// SetLives ( i , 600 ) ;
102362: LD_VAR 0 1
102366: PPUSH
102367: LD_INT 600
102369: PPUSH
102370: CALL_OW 234
102374: GO 102359
102376: POP
102377: POP
// end ;
102378: PPOPN 2
102380: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102381: LD_INT 0
102383: PPUSH
// case cmd of 301 :
102384: LD_VAR 0 1
102388: PUSH
102389: LD_INT 301
102391: DOUBLE
102392: EQUAL
102393: IFTRUE 102397
102395: GO 102429
102397: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102398: LD_VAR 0 6
102402: PPUSH
102403: LD_VAR 0 7
102407: PPUSH
102408: LD_VAR 0 8
102412: PPUSH
102413: LD_VAR 0 4
102417: PPUSH
102418: LD_VAR 0 5
102422: PPUSH
102423: CALL 103630 0 5
102427: GO 102550
102429: LD_INT 302
102431: DOUBLE
102432: EQUAL
102433: IFTRUE 102437
102435: GO 102474
102437: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102438: LD_VAR 0 6
102442: PPUSH
102443: LD_VAR 0 7
102447: PPUSH
102448: LD_VAR 0 8
102452: PPUSH
102453: LD_VAR 0 9
102457: PPUSH
102458: LD_VAR 0 4
102462: PPUSH
102463: LD_VAR 0 5
102467: PPUSH
102468: CALL 103721 0 6
102472: GO 102550
102474: LD_INT 303
102476: DOUBLE
102477: EQUAL
102478: IFTRUE 102482
102480: GO 102519
102482: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102483: LD_VAR 0 6
102487: PPUSH
102488: LD_VAR 0 7
102492: PPUSH
102493: LD_VAR 0 8
102497: PPUSH
102498: LD_VAR 0 9
102502: PPUSH
102503: LD_VAR 0 4
102507: PPUSH
102508: LD_VAR 0 5
102512: PPUSH
102513: CALL 102555 0 6
102517: GO 102550
102519: LD_INT 304
102521: DOUBLE
102522: EQUAL
102523: IFTRUE 102527
102525: GO 102549
102527: POP
// hHackTeleport ( unit , x , y ) ; end ;
102528: LD_VAR 0 2
102532: PPUSH
102533: LD_VAR 0 4
102537: PPUSH
102538: LD_VAR 0 5
102542: PPUSH
102543: CALL 104314 0 3
102547: GO 102550
102549: POP
// end ;
102550: LD_VAR 0 12
102554: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102555: LD_INT 0
102557: PPUSH
102558: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102559: LD_VAR 0 1
102563: PUSH
102564: LD_INT 1
102566: LESS
102567: PUSH
102568: LD_VAR 0 1
102572: PUSH
102573: LD_INT 3
102575: GREATER
102576: OR
102577: PUSH
102578: LD_VAR 0 5
102582: PPUSH
102583: LD_VAR 0 6
102587: PPUSH
102588: CALL_OW 428
102592: OR
102593: IFFALSE 102597
// exit ;
102595: GO 103317
// uc_side := your_side ;
102597: LD_ADDR_OWVAR 20
102601: PUSH
102602: LD_OWVAR 2
102606: ST_TO_ADDR
// uc_nation := nation ;
102607: LD_ADDR_OWVAR 21
102611: PUSH
102612: LD_VAR 0 1
102616: ST_TO_ADDR
// bc_level = 1 ;
102617: LD_ADDR_OWVAR 43
102621: PUSH
102622: LD_INT 1
102624: ST_TO_ADDR
// case btype of 1 :
102625: LD_VAR 0 2
102629: PUSH
102630: LD_INT 1
102632: DOUBLE
102633: EQUAL
102634: IFTRUE 102638
102636: GO 102649
102638: POP
// bc_type := b_depot ; 2 :
102639: LD_ADDR_OWVAR 42
102643: PUSH
102644: LD_INT 0
102646: ST_TO_ADDR
102647: GO 103261
102649: LD_INT 2
102651: DOUBLE
102652: EQUAL
102653: IFTRUE 102657
102655: GO 102668
102657: POP
// bc_type := b_warehouse ; 3 :
102658: LD_ADDR_OWVAR 42
102662: PUSH
102663: LD_INT 1
102665: ST_TO_ADDR
102666: GO 103261
102668: LD_INT 3
102670: DOUBLE
102671: EQUAL
102672: IFTRUE 102676
102674: GO 102687
102676: POP
// bc_type := b_lab ; 4 .. 9 :
102677: LD_ADDR_OWVAR 42
102681: PUSH
102682: LD_INT 6
102684: ST_TO_ADDR
102685: GO 103261
102687: LD_INT 4
102689: DOUBLE
102690: GREATEREQUAL
102691: IFFALSE 102699
102693: LD_INT 9
102695: DOUBLE
102696: LESSEQUAL
102697: IFTRUE 102701
102699: GO 102753
102701: POP
// begin bc_type := b_lab_half ;
102702: LD_ADDR_OWVAR 42
102706: PUSH
102707: LD_INT 7
102709: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102710: LD_ADDR_OWVAR 44
102714: PUSH
102715: LD_INT 10
102717: PUSH
102718: LD_INT 11
102720: PUSH
102721: LD_INT 12
102723: PUSH
102724: LD_INT 15
102726: PUSH
102727: LD_INT 14
102729: PUSH
102730: LD_INT 13
102732: PUSH
102733: EMPTY
102734: LIST
102735: LIST
102736: LIST
102737: LIST
102738: LIST
102739: LIST
102740: PUSH
102741: LD_VAR 0 2
102745: PUSH
102746: LD_INT 3
102748: MINUS
102749: ARRAY
102750: ST_TO_ADDR
// end ; 10 .. 13 :
102751: GO 103261
102753: LD_INT 10
102755: DOUBLE
102756: GREATEREQUAL
102757: IFFALSE 102765
102759: LD_INT 13
102761: DOUBLE
102762: LESSEQUAL
102763: IFTRUE 102767
102765: GO 102844
102767: POP
// begin bc_type := b_lab_full ;
102768: LD_ADDR_OWVAR 42
102772: PUSH
102773: LD_INT 8
102775: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102776: LD_ADDR_OWVAR 44
102780: PUSH
102781: LD_INT 10
102783: PUSH
102784: LD_INT 12
102786: PUSH
102787: LD_INT 14
102789: PUSH
102790: LD_INT 13
102792: PUSH
102793: EMPTY
102794: LIST
102795: LIST
102796: LIST
102797: LIST
102798: PUSH
102799: LD_VAR 0 2
102803: PUSH
102804: LD_INT 9
102806: MINUS
102807: ARRAY
102808: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102809: LD_ADDR_OWVAR 45
102813: PUSH
102814: LD_INT 11
102816: PUSH
102817: LD_INT 15
102819: PUSH
102820: LD_INT 12
102822: PUSH
102823: LD_INT 15
102825: PUSH
102826: EMPTY
102827: LIST
102828: LIST
102829: LIST
102830: LIST
102831: PUSH
102832: LD_VAR 0 2
102836: PUSH
102837: LD_INT 9
102839: MINUS
102840: ARRAY
102841: ST_TO_ADDR
// end ; 14 :
102842: GO 103261
102844: LD_INT 14
102846: DOUBLE
102847: EQUAL
102848: IFTRUE 102852
102850: GO 102863
102852: POP
// bc_type := b_workshop ; 15 :
102853: LD_ADDR_OWVAR 42
102857: PUSH
102858: LD_INT 2
102860: ST_TO_ADDR
102861: GO 103261
102863: LD_INT 15
102865: DOUBLE
102866: EQUAL
102867: IFTRUE 102871
102869: GO 102882
102871: POP
// bc_type := b_factory ; 16 :
102872: LD_ADDR_OWVAR 42
102876: PUSH
102877: LD_INT 3
102879: ST_TO_ADDR
102880: GO 103261
102882: LD_INT 16
102884: DOUBLE
102885: EQUAL
102886: IFTRUE 102890
102888: GO 102901
102890: POP
// bc_type := b_ext_gun ; 17 :
102891: LD_ADDR_OWVAR 42
102895: PUSH
102896: LD_INT 17
102898: ST_TO_ADDR
102899: GO 103261
102901: LD_INT 17
102903: DOUBLE
102904: EQUAL
102905: IFTRUE 102909
102907: GO 102937
102909: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102910: LD_ADDR_OWVAR 42
102914: PUSH
102915: LD_INT 19
102917: PUSH
102918: LD_INT 23
102920: PUSH
102921: LD_INT 19
102923: PUSH
102924: EMPTY
102925: LIST
102926: LIST
102927: LIST
102928: PUSH
102929: LD_VAR 0 1
102933: ARRAY
102934: ST_TO_ADDR
102935: GO 103261
102937: LD_INT 18
102939: DOUBLE
102940: EQUAL
102941: IFTRUE 102945
102943: GO 102956
102945: POP
// bc_type := b_ext_radar ; 19 :
102946: LD_ADDR_OWVAR 42
102950: PUSH
102951: LD_INT 20
102953: ST_TO_ADDR
102954: GO 103261
102956: LD_INT 19
102958: DOUBLE
102959: EQUAL
102960: IFTRUE 102964
102962: GO 102975
102964: POP
// bc_type := b_ext_radio ; 20 :
102965: LD_ADDR_OWVAR 42
102969: PUSH
102970: LD_INT 22
102972: ST_TO_ADDR
102973: GO 103261
102975: LD_INT 20
102977: DOUBLE
102978: EQUAL
102979: IFTRUE 102983
102981: GO 102994
102983: POP
// bc_type := b_ext_siberium ; 21 :
102984: LD_ADDR_OWVAR 42
102988: PUSH
102989: LD_INT 21
102991: ST_TO_ADDR
102992: GO 103261
102994: LD_INT 21
102996: DOUBLE
102997: EQUAL
102998: IFTRUE 103002
103000: GO 103013
103002: POP
// bc_type := b_ext_computer ; 22 :
103003: LD_ADDR_OWVAR 42
103007: PUSH
103008: LD_INT 24
103010: ST_TO_ADDR
103011: GO 103261
103013: LD_INT 22
103015: DOUBLE
103016: EQUAL
103017: IFTRUE 103021
103019: GO 103032
103021: POP
// bc_type := b_ext_track ; 23 :
103022: LD_ADDR_OWVAR 42
103026: PUSH
103027: LD_INT 16
103029: ST_TO_ADDR
103030: GO 103261
103032: LD_INT 23
103034: DOUBLE
103035: EQUAL
103036: IFTRUE 103040
103038: GO 103051
103040: POP
// bc_type := b_ext_laser ; 24 :
103041: LD_ADDR_OWVAR 42
103045: PUSH
103046: LD_INT 25
103048: ST_TO_ADDR
103049: GO 103261
103051: LD_INT 24
103053: DOUBLE
103054: EQUAL
103055: IFTRUE 103059
103057: GO 103070
103059: POP
// bc_type := b_control_tower ; 25 :
103060: LD_ADDR_OWVAR 42
103064: PUSH
103065: LD_INT 36
103067: ST_TO_ADDR
103068: GO 103261
103070: LD_INT 25
103072: DOUBLE
103073: EQUAL
103074: IFTRUE 103078
103076: GO 103089
103078: POP
// bc_type := b_breastwork ; 26 :
103079: LD_ADDR_OWVAR 42
103083: PUSH
103084: LD_INT 31
103086: ST_TO_ADDR
103087: GO 103261
103089: LD_INT 26
103091: DOUBLE
103092: EQUAL
103093: IFTRUE 103097
103095: GO 103108
103097: POP
// bc_type := b_bunker ; 27 :
103098: LD_ADDR_OWVAR 42
103102: PUSH
103103: LD_INT 32
103105: ST_TO_ADDR
103106: GO 103261
103108: LD_INT 27
103110: DOUBLE
103111: EQUAL
103112: IFTRUE 103116
103114: GO 103127
103116: POP
// bc_type := b_turret ; 28 :
103117: LD_ADDR_OWVAR 42
103121: PUSH
103122: LD_INT 33
103124: ST_TO_ADDR
103125: GO 103261
103127: LD_INT 28
103129: DOUBLE
103130: EQUAL
103131: IFTRUE 103135
103133: GO 103146
103135: POP
// bc_type := b_armoury ; 29 :
103136: LD_ADDR_OWVAR 42
103140: PUSH
103141: LD_INT 4
103143: ST_TO_ADDR
103144: GO 103261
103146: LD_INT 29
103148: DOUBLE
103149: EQUAL
103150: IFTRUE 103154
103152: GO 103165
103154: POP
// bc_type := b_barracks ; 30 :
103155: LD_ADDR_OWVAR 42
103159: PUSH
103160: LD_INT 5
103162: ST_TO_ADDR
103163: GO 103261
103165: LD_INT 30
103167: DOUBLE
103168: EQUAL
103169: IFTRUE 103173
103171: GO 103184
103173: POP
// bc_type := b_solar_power ; 31 :
103174: LD_ADDR_OWVAR 42
103178: PUSH
103179: LD_INT 27
103181: ST_TO_ADDR
103182: GO 103261
103184: LD_INT 31
103186: DOUBLE
103187: EQUAL
103188: IFTRUE 103192
103190: GO 103203
103192: POP
// bc_type := b_oil_power ; 32 :
103193: LD_ADDR_OWVAR 42
103197: PUSH
103198: LD_INT 26
103200: ST_TO_ADDR
103201: GO 103261
103203: LD_INT 32
103205: DOUBLE
103206: EQUAL
103207: IFTRUE 103211
103209: GO 103222
103211: POP
// bc_type := b_siberite_power ; 33 :
103212: LD_ADDR_OWVAR 42
103216: PUSH
103217: LD_INT 28
103219: ST_TO_ADDR
103220: GO 103261
103222: LD_INT 33
103224: DOUBLE
103225: EQUAL
103226: IFTRUE 103230
103228: GO 103241
103230: POP
// bc_type := b_oil_mine ; 34 :
103231: LD_ADDR_OWVAR 42
103235: PUSH
103236: LD_INT 29
103238: ST_TO_ADDR
103239: GO 103261
103241: LD_INT 34
103243: DOUBLE
103244: EQUAL
103245: IFTRUE 103249
103247: GO 103260
103249: POP
// bc_type := b_siberite_mine ; end ;
103250: LD_ADDR_OWVAR 42
103254: PUSH
103255: LD_INT 30
103257: ST_TO_ADDR
103258: GO 103261
103260: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103261: LD_ADDR_VAR 0 8
103265: PUSH
103266: LD_VAR 0 5
103270: PPUSH
103271: LD_VAR 0 6
103275: PPUSH
103276: LD_VAR 0 3
103280: PPUSH
103281: CALL_OW 47
103285: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103286: LD_OWVAR 42
103290: PUSH
103291: LD_INT 32
103293: PUSH
103294: LD_INT 33
103296: PUSH
103297: EMPTY
103298: LIST
103299: LIST
103300: IN
103301: IFFALSE 103317
// PlaceWeaponTurret ( b , weapon ) ;
103303: LD_VAR 0 8
103307: PPUSH
103308: LD_VAR 0 4
103312: PPUSH
103313: CALL_OW 431
// end ;
103317: LD_VAR 0 7
103321: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103322: LD_INT 0
103324: PPUSH
103325: PPUSH
103326: PPUSH
103327: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103328: LD_ADDR_VAR 0 4
103332: PUSH
103333: LD_INT 22
103335: PUSH
103336: LD_OWVAR 2
103340: PUSH
103341: EMPTY
103342: LIST
103343: LIST
103344: PUSH
103345: LD_INT 2
103347: PUSH
103348: LD_INT 30
103350: PUSH
103351: LD_INT 0
103353: PUSH
103354: EMPTY
103355: LIST
103356: LIST
103357: PUSH
103358: LD_INT 30
103360: PUSH
103361: LD_INT 1
103363: PUSH
103364: EMPTY
103365: LIST
103366: LIST
103367: PUSH
103368: EMPTY
103369: LIST
103370: LIST
103371: LIST
103372: PUSH
103373: EMPTY
103374: LIST
103375: LIST
103376: PPUSH
103377: CALL_OW 69
103381: ST_TO_ADDR
// if not tmp then
103382: LD_VAR 0 4
103386: NOT
103387: IFFALSE 103391
// exit ;
103389: GO 103450
// for i in tmp do
103391: LD_ADDR_VAR 0 2
103395: PUSH
103396: LD_VAR 0 4
103400: PUSH
103401: FOR_IN
103402: IFFALSE 103448
// for j = 1 to 3 do
103404: LD_ADDR_VAR 0 3
103408: PUSH
103409: DOUBLE
103410: LD_INT 1
103412: DEC
103413: ST_TO_ADDR
103414: LD_INT 3
103416: PUSH
103417: FOR_TO
103418: IFFALSE 103444
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103420: LD_VAR 0 2
103424: PPUSH
103425: CALL_OW 274
103429: PPUSH
103430: LD_VAR 0 3
103434: PPUSH
103435: LD_INT 99999
103437: PPUSH
103438: CALL_OW 277
103442: GO 103417
103444: POP
103445: POP
103446: GO 103401
103448: POP
103449: POP
// end ;
103450: LD_VAR 0 1
103454: RET
// export function hHackSetLevel10 ; var i , j ; begin
103455: LD_INT 0
103457: PPUSH
103458: PPUSH
103459: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103460: LD_ADDR_VAR 0 2
103464: PUSH
103465: LD_INT 21
103467: PUSH
103468: LD_INT 1
103470: PUSH
103471: EMPTY
103472: LIST
103473: LIST
103474: PPUSH
103475: CALL_OW 69
103479: PUSH
103480: FOR_IN
103481: IFFALSE 103533
// if IsSelected ( i ) then
103483: LD_VAR 0 2
103487: PPUSH
103488: CALL_OW 306
103492: IFFALSE 103531
// begin for j := 1 to 4 do
103494: LD_ADDR_VAR 0 3
103498: PUSH
103499: DOUBLE
103500: LD_INT 1
103502: DEC
103503: ST_TO_ADDR
103504: LD_INT 4
103506: PUSH
103507: FOR_TO
103508: IFFALSE 103529
// SetSkill ( i , j , 10 ) ;
103510: LD_VAR 0 2
103514: PPUSH
103515: LD_VAR 0 3
103519: PPUSH
103520: LD_INT 10
103522: PPUSH
103523: CALL_OW 237
103527: GO 103507
103529: POP
103530: POP
// end ;
103531: GO 103480
103533: POP
103534: POP
// end ;
103535: LD_VAR 0 1
103539: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103540: LD_INT 0
103542: PPUSH
103543: PPUSH
103544: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103545: LD_ADDR_VAR 0 2
103549: PUSH
103550: LD_INT 22
103552: PUSH
103553: LD_OWVAR 2
103557: PUSH
103558: EMPTY
103559: LIST
103560: LIST
103561: PUSH
103562: LD_INT 21
103564: PUSH
103565: LD_INT 1
103567: PUSH
103568: EMPTY
103569: LIST
103570: LIST
103571: PUSH
103572: EMPTY
103573: LIST
103574: LIST
103575: PPUSH
103576: CALL_OW 69
103580: PUSH
103581: FOR_IN
103582: IFFALSE 103623
// begin for j := 1 to 4 do
103584: LD_ADDR_VAR 0 3
103588: PUSH
103589: DOUBLE
103590: LD_INT 1
103592: DEC
103593: ST_TO_ADDR
103594: LD_INT 4
103596: PUSH
103597: FOR_TO
103598: IFFALSE 103619
// SetSkill ( i , j , 10 ) ;
103600: LD_VAR 0 2
103604: PPUSH
103605: LD_VAR 0 3
103609: PPUSH
103610: LD_INT 10
103612: PPUSH
103613: CALL_OW 237
103617: GO 103597
103619: POP
103620: POP
// end ;
103621: GO 103581
103623: POP
103624: POP
// end ;
103625: LD_VAR 0 1
103629: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103630: LD_INT 0
103632: PPUSH
// uc_side := your_side ;
103633: LD_ADDR_OWVAR 20
103637: PUSH
103638: LD_OWVAR 2
103642: ST_TO_ADDR
// uc_nation := nation ;
103643: LD_ADDR_OWVAR 21
103647: PUSH
103648: LD_VAR 0 1
103652: ST_TO_ADDR
// InitHc ;
103653: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103657: LD_INT 0
103659: PPUSH
103660: LD_VAR 0 2
103664: PPUSH
103665: LD_VAR 0 3
103669: PPUSH
103670: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103674: LD_VAR 0 4
103678: PPUSH
103679: LD_VAR 0 5
103683: PPUSH
103684: CALL_OW 428
103688: PUSH
103689: LD_INT 0
103691: EQUAL
103692: IFFALSE 103716
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103694: CALL_OW 44
103698: PPUSH
103699: LD_VAR 0 4
103703: PPUSH
103704: LD_VAR 0 5
103708: PPUSH
103709: LD_INT 1
103711: PPUSH
103712: CALL_OW 48
// end ;
103716: LD_VAR 0 6
103720: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103721: LD_INT 0
103723: PPUSH
103724: PPUSH
// uc_side := your_side ;
103725: LD_ADDR_OWVAR 20
103729: PUSH
103730: LD_OWVAR 2
103734: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103735: LD_VAR 0 1
103739: PUSH
103740: LD_INT 1
103742: PUSH
103743: LD_INT 2
103745: PUSH
103746: LD_INT 3
103748: PUSH
103749: LD_INT 4
103751: PUSH
103752: LD_INT 5
103754: PUSH
103755: EMPTY
103756: LIST
103757: LIST
103758: LIST
103759: LIST
103760: LIST
103761: IN
103762: IFFALSE 103774
// uc_nation := nation_american else
103764: LD_ADDR_OWVAR 21
103768: PUSH
103769: LD_INT 1
103771: ST_TO_ADDR
103772: GO 103817
// if chassis in [ 11 , 12 , 13 , 14 ] then
103774: LD_VAR 0 1
103778: PUSH
103779: LD_INT 11
103781: PUSH
103782: LD_INT 12
103784: PUSH
103785: LD_INT 13
103787: PUSH
103788: LD_INT 14
103790: PUSH
103791: EMPTY
103792: LIST
103793: LIST
103794: LIST
103795: LIST
103796: IN
103797: IFFALSE 103809
// uc_nation := nation_arabian else
103799: LD_ADDR_OWVAR 21
103803: PUSH
103804: LD_INT 2
103806: ST_TO_ADDR
103807: GO 103817
// uc_nation := nation_russian ;
103809: LD_ADDR_OWVAR 21
103813: PUSH
103814: LD_INT 3
103816: ST_TO_ADDR
// vc_chassis := chassis ;
103817: LD_ADDR_OWVAR 37
103821: PUSH
103822: LD_VAR 0 1
103826: ST_TO_ADDR
// vc_engine := engine ;
103827: LD_ADDR_OWVAR 39
103831: PUSH
103832: LD_VAR 0 2
103836: ST_TO_ADDR
// vc_control := control ;
103837: LD_ADDR_OWVAR 38
103841: PUSH
103842: LD_VAR 0 3
103846: ST_TO_ADDR
// vc_weapon := weapon ;
103847: LD_ADDR_OWVAR 40
103851: PUSH
103852: LD_VAR 0 4
103856: ST_TO_ADDR
// un := CreateVehicle ;
103857: LD_ADDR_VAR 0 8
103861: PUSH
103862: CALL_OW 45
103866: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103867: LD_VAR 0 8
103871: PPUSH
103872: LD_INT 0
103874: PPUSH
103875: LD_INT 5
103877: PPUSH
103878: CALL_OW 12
103882: PPUSH
103883: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103887: LD_VAR 0 8
103891: PPUSH
103892: LD_VAR 0 5
103896: PPUSH
103897: LD_VAR 0 6
103901: PPUSH
103902: LD_INT 1
103904: PPUSH
103905: CALL_OW 48
// end ;
103909: LD_VAR 0 7
103913: RET
// export hInvincible ; every 1 do
103914: GO 103916
103916: DISABLE
// hInvincible := [ ] ;
103917: LD_ADDR_EXP 151
103921: PUSH
103922: EMPTY
103923: ST_TO_ADDR
103924: END
// every 10 do var i ;
103925: GO 103927
103927: DISABLE
103928: LD_INT 0
103930: PPUSH
// begin enable ;
103931: ENABLE
// if not hInvincible then
103932: LD_EXP 151
103936: NOT
103937: IFFALSE 103941
// exit ;
103939: GO 103985
// for i in hInvincible do
103941: LD_ADDR_VAR 0 1
103945: PUSH
103946: LD_EXP 151
103950: PUSH
103951: FOR_IN
103952: IFFALSE 103983
// if GetLives ( i ) < 1000 then
103954: LD_VAR 0 1
103958: PPUSH
103959: CALL_OW 256
103963: PUSH
103964: LD_INT 1000
103966: LESS
103967: IFFALSE 103981
// SetLives ( i , 1000 ) ;
103969: LD_VAR 0 1
103973: PPUSH
103974: LD_INT 1000
103976: PPUSH
103977: CALL_OW 234
103981: GO 103951
103983: POP
103984: POP
// end ;
103985: PPOPN 1
103987: END
// export function hHackInvincible ; var i ; begin
103988: LD_INT 0
103990: PPUSH
103991: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103992: LD_ADDR_VAR 0 2
103996: PUSH
103997: LD_INT 2
103999: PUSH
104000: LD_INT 21
104002: PUSH
104003: LD_INT 1
104005: PUSH
104006: EMPTY
104007: LIST
104008: LIST
104009: PUSH
104010: LD_INT 21
104012: PUSH
104013: LD_INT 2
104015: PUSH
104016: EMPTY
104017: LIST
104018: LIST
104019: PUSH
104020: EMPTY
104021: LIST
104022: LIST
104023: LIST
104024: PPUSH
104025: CALL_OW 69
104029: PUSH
104030: FOR_IN
104031: IFFALSE 104092
// if IsSelected ( i ) then
104033: LD_VAR 0 2
104037: PPUSH
104038: CALL_OW 306
104042: IFFALSE 104090
// begin if i in hInvincible then
104044: LD_VAR 0 2
104048: PUSH
104049: LD_EXP 151
104053: IN
104054: IFFALSE 104074
// hInvincible := hInvincible diff i else
104056: LD_ADDR_EXP 151
104060: PUSH
104061: LD_EXP 151
104065: PUSH
104066: LD_VAR 0 2
104070: DIFF
104071: ST_TO_ADDR
104072: GO 104090
// hInvincible := hInvincible union i ;
104074: LD_ADDR_EXP 151
104078: PUSH
104079: LD_EXP 151
104083: PUSH
104084: LD_VAR 0 2
104088: UNION
104089: ST_TO_ADDR
// end ;
104090: GO 104030
104092: POP
104093: POP
// end ;
104094: LD_VAR 0 1
104098: RET
// export function hHackInvisible ; var i , j ; begin
104099: LD_INT 0
104101: PPUSH
104102: PPUSH
104103: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104104: LD_ADDR_VAR 0 2
104108: PUSH
104109: LD_INT 21
104111: PUSH
104112: LD_INT 1
104114: PUSH
104115: EMPTY
104116: LIST
104117: LIST
104118: PPUSH
104119: CALL_OW 69
104123: PUSH
104124: FOR_IN
104125: IFFALSE 104149
// if IsSelected ( i ) then
104127: LD_VAR 0 2
104131: PPUSH
104132: CALL_OW 306
104136: IFFALSE 104147
// ComForceInvisible ( i ) ;
104138: LD_VAR 0 2
104142: PPUSH
104143: CALL_OW 496
104147: GO 104124
104149: POP
104150: POP
// end ;
104151: LD_VAR 0 1
104155: RET
// export function hHackChangeYourSide ; begin
104156: LD_INT 0
104158: PPUSH
// if your_side = 8 then
104159: LD_OWVAR 2
104163: PUSH
104164: LD_INT 8
104166: EQUAL
104167: IFFALSE 104179
// your_side := 0 else
104169: LD_ADDR_OWVAR 2
104173: PUSH
104174: LD_INT 0
104176: ST_TO_ADDR
104177: GO 104193
// your_side := your_side + 1 ;
104179: LD_ADDR_OWVAR 2
104183: PUSH
104184: LD_OWVAR 2
104188: PUSH
104189: LD_INT 1
104191: PLUS
104192: ST_TO_ADDR
// end ;
104193: LD_VAR 0 1
104197: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104198: LD_INT 0
104200: PPUSH
104201: PPUSH
104202: PPUSH
// for i in all_units do
104203: LD_ADDR_VAR 0 2
104207: PUSH
104208: LD_OWVAR 3
104212: PUSH
104213: FOR_IN
104214: IFFALSE 104292
// if IsSelected ( i ) then
104216: LD_VAR 0 2
104220: PPUSH
104221: CALL_OW 306
104225: IFFALSE 104290
// begin j := GetSide ( i ) ;
104227: LD_ADDR_VAR 0 3
104231: PUSH
104232: LD_VAR 0 2
104236: PPUSH
104237: CALL_OW 255
104241: ST_TO_ADDR
// if j = 8 then
104242: LD_VAR 0 3
104246: PUSH
104247: LD_INT 8
104249: EQUAL
104250: IFFALSE 104262
// j := 0 else
104252: LD_ADDR_VAR 0 3
104256: PUSH
104257: LD_INT 0
104259: ST_TO_ADDR
104260: GO 104276
// j := j + 1 ;
104262: LD_ADDR_VAR 0 3
104266: PUSH
104267: LD_VAR 0 3
104271: PUSH
104272: LD_INT 1
104274: PLUS
104275: ST_TO_ADDR
// SetSide ( i , j ) ;
104276: LD_VAR 0 2
104280: PPUSH
104281: LD_VAR 0 3
104285: PPUSH
104286: CALL_OW 235
// end ;
104290: GO 104213
104292: POP
104293: POP
// end ;
104294: LD_VAR 0 1
104298: RET
// export function hHackFog ; begin
104299: LD_INT 0
104301: PPUSH
// FogOff ( true ) ;
104302: LD_INT 1
104304: PPUSH
104305: CALL_OW 344
// end ;
104309: LD_VAR 0 1
104313: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104314: LD_INT 0
104316: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104317: LD_VAR 0 1
104321: PPUSH
104322: LD_VAR 0 2
104326: PPUSH
104327: LD_VAR 0 3
104331: PPUSH
104332: LD_INT 1
104334: PPUSH
104335: LD_INT 1
104337: PPUSH
104338: CALL_OW 483
// CenterOnXY ( x , y ) ;
104342: LD_VAR 0 2
104346: PPUSH
104347: LD_VAR 0 3
104351: PPUSH
104352: CALL_OW 84
// end ;
104356: LD_VAR 0 4
104360: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104361: LD_INT 0
104363: PPUSH
104364: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104365: LD_VAR 0 1
104369: NOT
104370: PUSH
104371: LD_VAR 0 2
104375: PPUSH
104376: LD_VAR 0 3
104380: PPUSH
104381: CALL_OW 488
104385: NOT
104386: OR
104387: PUSH
104388: LD_VAR 0 1
104392: PPUSH
104393: CALL_OW 266
104397: PUSH
104398: LD_INT 3
104400: NONEQUAL
104401: PUSH
104402: LD_VAR 0 1
104406: PPUSH
104407: CALL_OW 247
104411: PUSH
104412: LD_INT 1
104414: EQUAL
104415: NOT
104416: AND
104417: OR
104418: IFFALSE 104422
// exit ;
104420: GO 104571
// if GetType ( factory ) = unit_human then
104422: LD_VAR 0 1
104426: PPUSH
104427: CALL_OW 247
104431: PUSH
104432: LD_INT 1
104434: EQUAL
104435: IFFALSE 104452
// factory := IsInUnit ( factory ) ;
104437: LD_ADDR_VAR 0 1
104441: PUSH
104442: LD_VAR 0 1
104446: PPUSH
104447: CALL_OW 310
104451: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104452: LD_VAR 0 1
104456: PPUSH
104457: CALL_OW 266
104461: PUSH
104462: LD_INT 3
104464: NONEQUAL
104465: IFFALSE 104469
// exit ;
104467: GO 104571
// if HexInfo ( x , y ) = factory then
104469: LD_VAR 0 2
104473: PPUSH
104474: LD_VAR 0 3
104478: PPUSH
104479: CALL_OW 428
104483: PUSH
104484: LD_VAR 0 1
104488: EQUAL
104489: IFFALSE 104516
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104491: LD_ADDR_EXP 152
104495: PUSH
104496: LD_EXP 152
104500: PPUSH
104501: LD_VAR 0 1
104505: PPUSH
104506: LD_INT 0
104508: PPUSH
104509: CALL_OW 1
104513: ST_TO_ADDR
104514: GO 104567
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104516: LD_ADDR_EXP 152
104520: PUSH
104521: LD_EXP 152
104525: PPUSH
104526: LD_VAR 0 1
104530: PPUSH
104531: LD_VAR 0 1
104535: PPUSH
104536: CALL_OW 255
104540: PUSH
104541: LD_VAR 0 1
104545: PUSH
104546: LD_VAR 0 2
104550: PUSH
104551: LD_VAR 0 3
104555: PUSH
104556: EMPTY
104557: LIST
104558: LIST
104559: LIST
104560: LIST
104561: PPUSH
104562: CALL_OW 1
104566: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104567: CALL 104576 0 0
// end ;
104571: LD_VAR 0 4
104575: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104576: LD_INT 0
104578: PPUSH
104579: PPUSH
104580: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104581: LD_STRING resetFactoryWaypoint();
104583: PPUSH
104584: CALL_OW 559
// if factoryWaypoints then
104588: LD_EXP 152
104592: IFFALSE 104718
// begin list := PrepareArray ( factoryWaypoints ) ;
104594: LD_ADDR_VAR 0 3
104598: PUSH
104599: LD_EXP 152
104603: PPUSH
104604: CALL 89862 0 1
104608: ST_TO_ADDR
// for i := 1 to list do
104609: LD_ADDR_VAR 0 2
104613: PUSH
104614: DOUBLE
104615: LD_INT 1
104617: DEC
104618: ST_TO_ADDR
104619: LD_VAR 0 3
104623: PUSH
104624: FOR_TO
104625: IFFALSE 104716
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104627: LD_STRING setFactoryWaypointXY(
104629: PUSH
104630: LD_VAR 0 3
104634: PUSH
104635: LD_VAR 0 2
104639: ARRAY
104640: PUSH
104641: LD_INT 1
104643: ARRAY
104644: STR
104645: PUSH
104646: LD_STRING ,
104648: STR
104649: PUSH
104650: LD_VAR 0 3
104654: PUSH
104655: LD_VAR 0 2
104659: ARRAY
104660: PUSH
104661: LD_INT 2
104663: ARRAY
104664: STR
104665: PUSH
104666: LD_STRING ,
104668: STR
104669: PUSH
104670: LD_VAR 0 3
104674: PUSH
104675: LD_VAR 0 2
104679: ARRAY
104680: PUSH
104681: LD_INT 3
104683: ARRAY
104684: STR
104685: PUSH
104686: LD_STRING ,
104688: STR
104689: PUSH
104690: LD_VAR 0 3
104694: PUSH
104695: LD_VAR 0 2
104699: ARRAY
104700: PUSH
104701: LD_INT 4
104703: ARRAY
104704: STR
104705: PUSH
104706: LD_STRING )
104708: STR
104709: PPUSH
104710: CALL_OW 559
104714: GO 104624
104716: POP
104717: POP
// end ; end ;
104718: LD_VAR 0 1
104722: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104723: LD_INT 0
104725: PPUSH
// if HexInfo ( x , y ) = warehouse then
104726: LD_VAR 0 2
104730: PPUSH
104731: LD_VAR 0 3
104735: PPUSH
104736: CALL_OW 428
104740: PUSH
104741: LD_VAR 0 1
104745: EQUAL
104746: IFFALSE 104773
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104748: LD_ADDR_EXP 153
104752: PUSH
104753: LD_EXP 153
104757: PPUSH
104758: LD_VAR 0 1
104762: PPUSH
104763: LD_INT 0
104765: PPUSH
104766: CALL_OW 1
104770: ST_TO_ADDR
104771: GO 104824
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104773: LD_ADDR_EXP 153
104777: PUSH
104778: LD_EXP 153
104782: PPUSH
104783: LD_VAR 0 1
104787: PPUSH
104788: LD_VAR 0 1
104792: PPUSH
104793: CALL_OW 255
104797: PUSH
104798: LD_VAR 0 1
104802: PUSH
104803: LD_VAR 0 2
104807: PUSH
104808: LD_VAR 0 3
104812: PUSH
104813: EMPTY
104814: LIST
104815: LIST
104816: LIST
104817: LIST
104818: PPUSH
104819: CALL_OW 1
104823: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104824: CALL 104833 0 0
// end ;
104828: LD_VAR 0 4
104832: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104833: LD_INT 0
104835: PPUSH
104836: PPUSH
104837: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104838: LD_STRING resetWarehouseGatheringPoints();
104840: PPUSH
104841: CALL_OW 559
// if warehouseGatheringPoints then
104845: LD_EXP 153
104849: IFFALSE 104975
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104851: LD_ADDR_VAR 0 3
104855: PUSH
104856: LD_EXP 153
104860: PPUSH
104861: CALL 89862 0 1
104865: ST_TO_ADDR
// for i := 1 to list do
104866: LD_ADDR_VAR 0 2
104870: PUSH
104871: DOUBLE
104872: LD_INT 1
104874: DEC
104875: ST_TO_ADDR
104876: LD_VAR 0 3
104880: PUSH
104881: FOR_TO
104882: IFFALSE 104973
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104884: LD_STRING setWarehouseGatheringPointXY(
104886: PUSH
104887: LD_VAR 0 3
104891: PUSH
104892: LD_VAR 0 2
104896: ARRAY
104897: PUSH
104898: LD_INT 1
104900: ARRAY
104901: STR
104902: PUSH
104903: LD_STRING ,
104905: STR
104906: PUSH
104907: LD_VAR 0 3
104911: PUSH
104912: LD_VAR 0 2
104916: ARRAY
104917: PUSH
104918: LD_INT 2
104920: ARRAY
104921: STR
104922: PUSH
104923: LD_STRING ,
104925: STR
104926: PUSH
104927: LD_VAR 0 3
104931: PUSH
104932: LD_VAR 0 2
104936: ARRAY
104937: PUSH
104938: LD_INT 3
104940: ARRAY
104941: STR
104942: PUSH
104943: LD_STRING ,
104945: STR
104946: PUSH
104947: LD_VAR 0 3
104951: PUSH
104952: LD_VAR 0 2
104956: ARRAY
104957: PUSH
104958: LD_INT 4
104960: ARRAY
104961: STR
104962: PUSH
104963: LD_STRING )
104965: STR
104966: PPUSH
104967: CALL_OW 559
104971: GO 104881
104973: POP
104974: POP
// end ; end ;
104975: LD_VAR 0 1
104979: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
104980: LD_EXP 153
104984: IFFALSE 105669
104986: GO 104988
104988: DISABLE
104989: LD_INT 0
104991: PPUSH
104992: PPUSH
104993: PPUSH
104994: PPUSH
104995: PPUSH
104996: PPUSH
104997: PPUSH
104998: PPUSH
104999: PPUSH
// begin enable ;
105000: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105001: LD_ADDR_VAR 0 3
105005: PUSH
105006: LD_EXP 153
105010: PPUSH
105011: CALL 89862 0 1
105015: ST_TO_ADDR
// if not list then
105016: LD_VAR 0 3
105020: NOT
105021: IFFALSE 105025
// exit ;
105023: GO 105669
// for i := 1 to list do
105025: LD_ADDR_VAR 0 1
105029: PUSH
105030: DOUBLE
105031: LD_INT 1
105033: DEC
105034: ST_TO_ADDR
105035: LD_VAR 0 3
105039: PUSH
105040: FOR_TO
105041: IFFALSE 105667
// begin depot := list [ i ] [ 2 ] ;
105043: LD_ADDR_VAR 0 8
105047: PUSH
105048: LD_VAR 0 3
105052: PUSH
105053: LD_VAR 0 1
105057: ARRAY
105058: PUSH
105059: LD_INT 2
105061: ARRAY
105062: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105063: LD_ADDR_VAR 0 5
105067: PUSH
105068: LD_VAR 0 3
105072: PUSH
105073: LD_VAR 0 1
105077: ARRAY
105078: PUSH
105079: LD_INT 1
105081: ARRAY
105082: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105083: LD_VAR 0 8
105087: PPUSH
105088: CALL_OW 301
105092: PUSH
105093: LD_VAR 0 5
105097: PUSH
105098: LD_VAR 0 8
105102: PPUSH
105103: CALL_OW 255
105107: NONEQUAL
105108: OR
105109: IFFALSE 105138
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105111: LD_ADDR_EXP 153
105115: PUSH
105116: LD_EXP 153
105120: PPUSH
105121: LD_VAR 0 8
105125: PPUSH
105126: LD_INT 0
105128: PPUSH
105129: CALL_OW 1
105133: ST_TO_ADDR
// exit ;
105134: POP
105135: POP
105136: GO 105669
// end ; x := list [ i ] [ 3 ] ;
105138: LD_ADDR_VAR 0 6
105142: PUSH
105143: LD_VAR 0 3
105147: PUSH
105148: LD_VAR 0 1
105152: ARRAY
105153: PUSH
105154: LD_INT 3
105156: ARRAY
105157: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105158: LD_ADDR_VAR 0 7
105162: PUSH
105163: LD_VAR 0 3
105167: PUSH
105168: LD_VAR 0 1
105172: ARRAY
105173: PUSH
105174: LD_INT 4
105176: ARRAY
105177: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105178: LD_ADDR_VAR 0 9
105182: PUSH
105183: LD_VAR 0 6
105187: PPUSH
105188: LD_VAR 0 7
105192: PPUSH
105193: LD_INT 16
105195: PPUSH
105196: CALL 88450 0 3
105200: ST_TO_ADDR
// if not cratesNearbyPoint then
105201: LD_VAR 0 9
105205: NOT
105206: IFFALSE 105212
// exit ;
105208: POP
105209: POP
105210: GO 105669
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105212: LD_ADDR_VAR 0 4
105216: PUSH
105217: LD_INT 22
105219: PUSH
105220: LD_VAR 0 5
105224: PUSH
105225: EMPTY
105226: LIST
105227: LIST
105228: PUSH
105229: LD_INT 3
105231: PUSH
105232: LD_INT 60
105234: PUSH
105235: EMPTY
105236: LIST
105237: PUSH
105238: EMPTY
105239: LIST
105240: LIST
105241: PUSH
105242: LD_INT 91
105244: PUSH
105245: LD_VAR 0 8
105249: PUSH
105250: LD_INT 6
105252: PUSH
105253: EMPTY
105254: LIST
105255: LIST
105256: LIST
105257: PUSH
105258: LD_INT 2
105260: PUSH
105261: LD_INT 25
105263: PUSH
105264: LD_INT 2
105266: PUSH
105267: EMPTY
105268: LIST
105269: LIST
105270: PUSH
105271: LD_INT 25
105273: PUSH
105274: LD_INT 16
105276: PUSH
105277: EMPTY
105278: LIST
105279: LIST
105280: PUSH
105281: EMPTY
105282: LIST
105283: LIST
105284: LIST
105285: PUSH
105286: EMPTY
105287: LIST
105288: LIST
105289: LIST
105290: LIST
105291: PPUSH
105292: CALL_OW 69
105296: PUSH
105297: LD_VAR 0 8
105301: PPUSH
105302: CALL_OW 313
105306: PPUSH
105307: LD_INT 3
105309: PUSH
105310: LD_INT 60
105312: PUSH
105313: EMPTY
105314: LIST
105315: PUSH
105316: EMPTY
105317: LIST
105318: LIST
105319: PUSH
105320: LD_INT 2
105322: PUSH
105323: LD_INT 25
105325: PUSH
105326: LD_INT 2
105328: PUSH
105329: EMPTY
105330: LIST
105331: LIST
105332: PUSH
105333: LD_INT 25
105335: PUSH
105336: LD_INT 16
105338: PUSH
105339: EMPTY
105340: LIST
105341: LIST
105342: PUSH
105343: EMPTY
105344: LIST
105345: LIST
105346: LIST
105347: PUSH
105348: EMPTY
105349: LIST
105350: LIST
105351: PPUSH
105352: CALL_OW 72
105356: UNION
105357: ST_TO_ADDR
// if tmp then
105358: LD_VAR 0 4
105362: IFFALSE 105442
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105364: LD_ADDR_VAR 0 4
105368: PUSH
105369: LD_VAR 0 4
105373: PPUSH
105374: LD_INT 3
105376: PPUSH
105377: CALL 86419 0 2
105381: ST_TO_ADDR
// for j in tmp do
105382: LD_ADDR_VAR 0 2
105386: PUSH
105387: LD_VAR 0 4
105391: PUSH
105392: FOR_IN
105393: IFFALSE 105436
// begin if IsInUnit ( j ) then
105395: LD_VAR 0 2
105399: PPUSH
105400: CALL_OW 310
105404: IFFALSE 105415
// ComExit ( j ) ;
105406: LD_VAR 0 2
105410: PPUSH
105411: CALL 86502 0 1
// AddComCollect ( j , x , y ) ;
105415: LD_VAR 0 2
105419: PPUSH
105420: LD_VAR 0 6
105424: PPUSH
105425: LD_VAR 0 7
105429: PPUSH
105430: CALL_OW 177
// end ;
105434: GO 105392
105436: POP
105437: POP
// exit ;
105438: POP
105439: POP
105440: GO 105669
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105442: LD_ADDR_VAR 0 4
105446: PUSH
105447: LD_INT 22
105449: PUSH
105450: LD_VAR 0 5
105454: PUSH
105455: EMPTY
105456: LIST
105457: LIST
105458: PUSH
105459: LD_INT 91
105461: PUSH
105462: LD_VAR 0 8
105466: PUSH
105467: LD_INT 8
105469: PUSH
105470: EMPTY
105471: LIST
105472: LIST
105473: LIST
105474: PUSH
105475: LD_INT 2
105477: PUSH
105478: LD_INT 34
105480: PUSH
105481: LD_INT 12
105483: PUSH
105484: EMPTY
105485: LIST
105486: LIST
105487: PUSH
105488: LD_INT 34
105490: PUSH
105491: LD_INT 51
105493: PUSH
105494: EMPTY
105495: LIST
105496: LIST
105497: PUSH
105498: LD_INT 34
105500: PUSH
105501: LD_INT 32
105503: PUSH
105504: EMPTY
105505: LIST
105506: LIST
105507: PUSH
105508: LD_INT 34
105510: PUSH
105511: LD_INT 89
105513: PUSH
105514: EMPTY
105515: LIST
105516: LIST
105517: PUSH
105518: EMPTY
105519: LIST
105520: LIST
105521: LIST
105522: LIST
105523: LIST
105524: PUSH
105525: EMPTY
105526: LIST
105527: LIST
105528: LIST
105529: PPUSH
105530: CALL_OW 69
105534: ST_TO_ADDR
// if tmp then
105535: LD_VAR 0 4
105539: IFFALSE 105665
// begin for j in tmp do
105541: LD_ADDR_VAR 0 2
105545: PUSH
105546: LD_VAR 0 4
105550: PUSH
105551: FOR_IN
105552: IFFALSE 105663
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105554: LD_VAR 0 2
105558: PPUSH
105559: CALL_OW 262
105563: PUSH
105564: LD_INT 3
105566: EQUAL
105567: PUSH
105568: LD_VAR 0 2
105572: PPUSH
105573: CALL_OW 261
105577: PUSH
105578: LD_INT 20
105580: GREATER
105581: OR
105582: PUSH
105583: LD_VAR 0 2
105587: PPUSH
105588: CALL_OW 314
105592: NOT
105593: AND
105594: PUSH
105595: LD_VAR 0 2
105599: PPUSH
105600: CALL_OW 263
105604: PUSH
105605: LD_INT 1
105607: NONEQUAL
105608: PUSH
105609: LD_VAR 0 2
105613: PPUSH
105614: CALL_OW 311
105618: OR
105619: AND
105620: IFFALSE 105661
// begin ComCollect ( j , x , y ) ;
105622: LD_VAR 0 2
105626: PPUSH
105627: LD_VAR 0 6
105631: PPUSH
105632: LD_VAR 0 7
105636: PPUSH
105637: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105641: LD_VAR 0 2
105645: PPUSH
105646: LD_VAR 0 8
105650: PPUSH
105651: CALL_OW 172
// exit ;
105655: POP
105656: POP
105657: POP
105658: POP
105659: GO 105669
// end ;
105661: GO 105551
105663: POP
105664: POP
// end ; end ;
105665: GO 105040
105667: POP
105668: POP
// end ; end_of_file
105669: PPOPN 9
105671: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105672: LD_INT 0
105674: PPUSH
105675: PPUSH
105676: PPUSH
105677: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105678: LD_VAR 0 1
105682: PPUSH
105683: CALL_OW 264
105687: PUSH
105688: LD_INT 91
105690: EQUAL
105691: IFFALSE 105763
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105693: LD_INT 68
105695: PPUSH
105696: LD_VAR 0 1
105700: PPUSH
105701: CALL_OW 255
105705: PPUSH
105706: CALL_OW 321
105710: PUSH
105711: LD_INT 2
105713: EQUAL
105714: IFFALSE 105726
// eff := 70 else
105716: LD_ADDR_VAR 0 4
105720: PUSH
105721: LD_INT 70
105723: ST_TO_ADDR
105724: GO 105734
// eff := 30 ;
105726: LD_ADDR_VAR 0 4
105730: PUSH
105731: LD_INT 30
105733: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105734: LD_VAR 0 1
105738: PPUSH
105739: CALL_OW 250
105743: PPUSH
105744: LD_VAR 0 1
105748: PPUSH
105749: CALL_OW 251
105753: PPUSH
105754: LD_VAR 0 4
105758: PPUSH
105759: CALL_OW 495
// end ; end ;
105763: LD_VAR 0 2
105767: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105768: LD_INT 0
105770: PPUSH
// end ;
105771: LD_VAR 0 4
105775: RET
// export function SOS_Command ( cmd ) ; begin
105776: LD_INT 0
105778: PPUSH
// end ;
105779: LD_VAR 0 2
105783: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105784: LD_INT 0
105786: PPUSH
// end ;
105787: LD_VAR 0 6
105791: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105792: LD_INT 0
105794: PPUSH
105795: PPUSH
// if not vehicle or not factory then
105796: LD_VAR 0 1
105800: NOT
105801: PUSH
105802: LD_VAR 0 2
105806: NOT
105807: OR
105808: IFFALSE 105812
// exit ;
105810: GO 106043
// if factoryWaypoints >= factory then
105812: LD_EXP 152
105816: PUSH
105817: LD_VAR 0 2
105821: GREATEREQUAL
105822: IFFALSE 106043
// if factoryWaypoints [ factory ] then
105824: LD_EXP 152
105828: PUSH
105829: LD_VAR 0 2
105833: ARRAY
105834: IFFALSE 106043
// begin if GetControl ( vehicle ) = control_manual then
105836: LD_VAR 0 1
105840: PPUSH
105841: CALL_OW 263
105845: PUSH
105846: LD_INT 1
105848: EQUAL
105849: IFFALSE 105930
// begin driver := IsDrivenBy ( vehicle ) ;
105851: LD_ADDR_VAR 0 4
105855: PUSH
105856: LD_VAR 0 1
105860: PPUSH
105861: CALL_OW 311
105865: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105866: LD_VAR 0 4
105870: PPUSH
105871: LD_EXP 152
105875: PUSH
105876: LD_VAR 0 2
105880: ARRAY
105881: PUSH
105882: LD_INT 3
105884: ARRAY
105885: PPUSH
105886: LD_EXP 152
105890: PUSH
105891: LD_VAR 0 2
105895: ARRAY
105896: PUSH
105897: LD_INT 4
105899: ARRAY
105900: PPUSH
105901: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105905: LD_VAR 0 4
105909: PPUSH
105910: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105914: LD_VAR 0 4
105918: PPUSH
105919: LD_VAR 0 2
105923: PPUSH
105924: CALL_OW 180
// end else
105928: GO 106043
// if GetControl ( vehicle ) = control_remote then
105930: LD_VAR 0 1
105934: PPUSH
105935: CALL_OW 263
105939: PUSH
105940: LD_INT 2
105942: EQUAL
105943: IFFALSE 106004
// begin wait ( 0 0$2 ) ;
105945: LD_INT 70
105947: PPUSH
105948: CALL_OW 67
// if Connect ( vehicle ) then
105952: LD_VAR 0 1
105956: PPUSH
105957: CALL 56761 0 1
105961: IFFALSE 106002
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105963: LD_VAR 0 1
105967: PPUSH
105968: LD_EXP 152
105972: PUSH
105973: LD_VAR 0 2
105977: ARRAY
105978: PUSH
105979: LD_INT 3
105981: ARRAY
105982: PPUSH
105983: LD_EXP 152
105987: PUSH
105988: LD_VAR 0 2
105992: ARRAY
105993: PUSH
105994: LD_INT 4
105996: ARRAY
105997: PPUSH
105998: CALL_OW 171
// end else
106002: GO 106043
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106004: LD_VAR 0 1
106008: PPUSH
106009: LD_EXP 152
106013: PUSH
106014: LD_VAR 0 2
106018: ARRAY
106019: PUSH
106020: LD_INT 3
106022: ARRAY
106023: PPUSH
106024: LD_EXP 152
106028: PUSH
106029: LD_VAR 0 2
106033: ARRAY
106034: PUSH
106035: LD_INT 4
106037: ARRAY
106038: PPUSH
106039: CALL_OW 171
// end ; end ;
106043: LD_VAR 0 3
106047: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106048: LD_INT 0
106050: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106051: LD_VAR 0 1
106055: PUSH
106056: LD_INT 250
106058: EQUAL
106059: PUSH
106060: LD_VAR 0 2
106064: PPUSH
106065: CALL_OW 264
106069: PUSH
106070: LD_INT 81
106072: EQUAL
106073: AND
106074: IFFALSE 106095
// MinerPlaceMine ( unit , x , y ) ;
106076: LD_VAR 0 2
106080: PPUSH
106081: LD_VAR 0 4
106085: PPUSH
106086: LD_VAR 0 5
106090: PPUSH
106091: CALL 108480 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106095: LD_VAR 0 1
106099: PUSH
106100: LD_INT 251
106102: EQUAL
106103: PUSH
106104: LD_VAR 0 2
106108: PPUSH
106109: CALL_OW 264
106113: PUSH
106114: LD_INT 81
106116: EQUAL
106117: AND
106118: IFFALSE 106139
// MinerDetonateMine ( unit , x , y ) ;
106120: LD_VAR 0 2
106124: PPUSH
106125: LD_VAR 0 4
106129: PPUSH
106130: LD_VAR 0 5
106134: PPUSH
106135: CALL 108755 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106139: LD_VAR 0 1
106143: PUSH
106144: LD_INT 252
106146: EQUAL
106147: PUSH
106148: LD_VAR 0 2
106152: PPUSH
106153: CALL_OW 264
106157: PUSH
106158: LD_INT 81
106160: EQUAL
106161: AND
106162: IFFALSE 106183
// MinerCreateMinefield ( unit , x , y ) ;
106164: LD_VAR 0 2
106168: PPUSH
106169: LD_VAR 0 4
106173: PPUSH
106174: LD_VAR 0 5
106178: PPUSH
106179: CALL 109172 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106183: LD_VAR 0 1
106187: PUSH
106188: LD_INT 253
106190: EQUAL
106191: PUSH
106192: LD_VAR 0 2
106196: PPUSH
106197: CALL_OW 257
106201: PUSH
106202: LD_INT 5
106204: EQUAL
106205: AND
106206: IFFALSE 106227
// ComBinocular ( unit , x , y ) ;
106208: LD_VAR 0 2
106212: PPUSH
106213: LD_VAR 0 4
106217: PPUSH
106218: LD_VAR 0 5
106222: PPUSH
106223: CALL 109541 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106227: LD_VAR 0 1
106231: PUSH
106232: LD_INT 254
106234: EQUAL
106235: PUSH
106236: LD_VAR 0 2
106240: PPUSH
106241: CALL_OW 264
106245: PUSH
106246: LD_INT 99
106248: EQUAL
106249: AND
106250: PUSH
106251: LD_VAR 0 3
106255: PPUSH
106256: CALL_OW 263
106260: PUSH
106261: LD_INT 3
106263: EQUAL
106264: AND
106265: IFFALSE 106281
// HackDestroyVehicle ( unit , selectedUnit ) ;
106267: LD_VAR 0 2
106271: PPUSH
106272: LD_VAR 0 3
106276: PPUSH
106277: CALL 107844 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106281: LD_VAR 0 1
106285: PUSH
106286: LD_INT 255
106288: EQUAL
106289: PUSH
106290: LD_VAR 0 2
106294: PPUSH
106295: CALL_OW 264
106299: PUSH
106300: LD_INT 14
106302: PUSH
106303: LD_INT 53
106305: PUSH
106306: EMPTY
106307: LIST
106308: LIST
106309: IN
106310: AND
106311: PUSH
106312: LD_VAR 0 4
106316: PPUSH
106317: LD_VAR 0 5
106321: PPUSH
106322: CALL_OW 488
106326: AND
106327: IFFALSE 106351
// CutTreeXYR ( unit , x , y , 12 ) ;
106329: LD_VAR 0 2
106333: PPUSH
106334: LD_VAR 0 4
106338: PPUSH
106339: LD_VAR 0 5
106343: PPUSH
106344: LD_INT 12
106346: PPUSH
106347: CALL 106414 0 4
// if cmd = 256 then
106351: LD_VAR 0 1
106355: PUSH
106356: LD_INT 256
106358: EQUAL
106359: IFFALSE 106380
// SetFactoryWaypoint ( unit , x , y ) ;
106361: LD_VAR 0 2
106365: PPUSH
106366: LD_VAR 0 4
106370: PPUSH
106371: LD_VAR 0 5
106375: PPUSH
106376: CALL 104361 0 3
// if cmd = 257 then
106380: LD_VAR 0 1
106384: PUSH
106385: LD_INT 257
106387: EQUAL
106388: IFFALSE 106409
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106390: LD_VAR 0 2
106394: PPUSH
106395: LD_VAR 0 4
106399: PPUSH
106400: LD_VAR 0 5
106404: PPUSH
106405: CALL 104723 0 3
// end ;
106409: LD_VAR 0 6
106413: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106414: LD_INT 0
106416: PPUSH
106417: PPUSH
106418: PPUSH
106419: PPUSH
106420: PPUSH
106421: PPUSH
106422: PPUSH
106423: PPUSH
106424: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106425: LD_VAR 0 1
106429: NOT
106430: PUSH
106431: LD_VAR 0 2
106435: PPUSH
106436: LD_VAR 0 3
106440: PPUSH
106441: CALL_OW 488
106445: NOT
106446: OR
106447: PUSH
106448: LD_VAR 0 4
106452: NOT
106453: OR
106454: IFFALSE 106458
// exit ;
106456: GO 106798
// list := [ ] ;
106458: LD_ADDR_VAR 0 13
106462: PUSH
106463: EMPTY
106464: ST_TO_ADDR
// if x - r < 0 then
106465: LD_VAR 0 2
106469: PUSH
106470: LD_VAR 0 4
106474: MINUS
106475: PUSH
106476: LD_INT 0
106478: LESS
106479: IFFALSE 106491
// min_x := 0 else
106481: LD_ADDR_VAR 0 7
106485: PUSH
106486: LD_INT 0
106488: ST_TO_ADDR
106489: GO 106507
// min_x := x - r ;
106491: LD_ADDR_VAR 0 7
106495: PUSH
106496: LD_VAR 0 2
106500: PUSH
106501: LD_VAR 0 4
106505: MINUS
106506: ST_TO_ADDR
// if y - r < 0 then
106507: LD_VAR 0 3
106511: PUSH
106512: LD_VAR 0 4
106516: MINUS
106517: PUSH
106518: LD_INT 0
106520: LESS
106521: IFFALSE 106533
// min_y := 0 else
106523: LD_ADDR_VAR 0 8
106527: PUSH
106528: LD_INT 0
106530: ST_TO_ADDR
106531: GO 106549
// min_y := y - r ;
106533: LD_ADDR_VAR 0 8
106537: PUSH
106538: LD_VAR 0 3
106542: PUSH
106543: LD_VAR 0 4
106547: MINUS
106548: ST_TO_ADDR
// max_x := x + r ;
106549: LD_ADDR_VAR 0 9
106553: PUSH
106554: LD_VAR 0 2
106558: PUSH
106559: LD_VAR 0 4
106563: PLUS
106564: ST_TO_ADDR
// max_y := y + r ;
106565: LD_ADDR_VAR 0 10
106569: PUSH
106570: LD_VAR 0 3
106574: PUSH
106575: LD_VAR 0 4
106579: PLUS
106580: ST_TO_ADDR
// for _x = min_x to max_x do
106581: LD_ADDR_VAR 0 11
106585: PUSH
106586: DOUBLE
106587: LD_VAR 0 7
106591: DEC
106592: ST_TO_ADDR
106593: LD_VAR 0 9
106597: PUSH
106598: FOR_TO
106599: IFFALSE 106716
// for _y = min_y to max_y do
106601: LD_ADDR_VAR 0 12
106605: PUSH
106606: DOUBLE
106607: LD_VAR 0 8
106611: DEC
106612: ST_TO_ADDR
106613: LD_VAR 0 10
106617: PUSH
106618: FOR_TO
106619: IFFALSE 106712
// begin if not ValidHex ( _x , _y ) then
106621: LD_VAR 0 11
106625: PPUSH
106626: LD_VAR 0 12
106630: PPUSH
106631: CALL_OW 488
106635: NOT
106636: IFFALSE 106640
// continue ;
106638: GO 106618
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106640: LD_VAR 0 11
106644: PPUSH
106645: LD_VAR 0 12
106649: PPUSH
106650: CALL_OW 351
106654: PUSH
106655: LD_VAR 0 11
106659: PPUSH
106660: LD_VAR 0 12
106664: PPUSH
106665: CALL_OW 554
106669: AND
106670: IFFALSE 106710
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106672: LD_ADDR_VAR 0 13
106676: PUSH
106677: LD_VAR 0 13
106681: PPUSH
106682: LD_VAR 0 13
106686: PUSH
106687: LD_INT 1
106689: PLUS
106690: PPUSH
106691: LD_VAR 0 11
106695: PUSH
106696: LD_VAR 0 12
106700: PUSH
106701: EMPTY
106702: LIST
106703: LIST
106704: PPUSH
106705: CALL_OW 2
106709: ST_TO_ADDR
// end ;
106710: GO 106618
106712: POP
106713: POP
106714: GO 106598
106716: POP
106717: POP
// if not list then
106718: LD_VAR 0 13
106722: NOT
106723: IFFALSE 106727
// exit ;
106725: GO 106798
// for i in list do
106727: LD_ADDR_VAR 0 6
106731: PUSH
106732: LD_VAR 0 13
106736: PUSH
106737: FOR_IN
106738: IFFALSE 106796
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106740: LD_VAR 0 1
106744: PPUSH
106745: LD_STRING M
106747: PUSH
106748: LD_VAR 0 6
106752: PUSH
106753: LD_INT 1
106755: ARRAY
106756: PUSH
106757: LD_VAR 0 6
106761: PUSH
106762: LD_INT 2
106764: ARRAY
106765: PUSH
106766: LD_INT 0
106768: PUSH
106769: LD_INT 0
106771: PUSH
106772: LD_INT 0
106774: PUSH
106775: LD_INT 0
106777: PUSH
106778: EMPTY
106779: LIST
106780: LIST
106781: LIST
106782: LIST
106783: LIST
106784: LIST
106785: LIST
106786: PUSH
106787: EMPTY
106788: LIST
106789: PPUSH
106790: CALL_OW 447
106794: GO 106737
106796: POP
106797: POP
// end ;
106798: LD_VAR 0 5
106802: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106803: LD_EXP 155
106807: NOT
106808: IFFALSE 106858
106810: GO 106812
106812: DISABLE
// begin initHack := true ;
106813: LD_ADDR_EXP 155
106817: PUSH
106818: LD_INT 1
106820: ST_TO_ADDR
// hackTanks := [ ] ;
106821: LD_ADDR_EXP 156
106825: PUSH
106826: EMPTY
106827: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106828: LD_ADDR_EXP 157
106832: PUSH
106833: EMPTY
106834: ST_TO_ADDR
// hackLimit := 3 ;
106835: LD_ADDR_EXP 158
106839: PUSH
106840: LD_INT 3
106842: ST_TO_ADDR
// hackDist := 12 ;
106843: LD_ADDR_EXP 159
106847: PUSH
106848: LD_INT 12
106850: ST_TO_ADDR
// hackCounter := [ ] ;
106851: LD_ADDR_EXP 160
106855: PUSH
106856: EMPTY
106857: ST_TO_ADDR
// end ;
106858: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106859: LD_EXP 155
106863: PUSH
106864: LD_INT 34
106866: PUSH
106867: LD_INT 99
106869: PUSH
106870: EMPTY
106871: LIST
106872: LIST
106873: PPUSH
106874: CALL_OW 69
106878: AND
106879: IFFALSE 107132
106881: GO 106883
106883: DISABLE
106884: LD_INT 0
106886: PPUSH
106887: PPUSH
// begin enable ;
106888: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106889: LD_ADDR_VAR 0 1
106893: PUSH
106894: LD_INT 34
106896: PUSH
106897: LD_INT 99
106899: PUSH
106900: EMPTY
106901: LIST
106902: LIST
106903: PPUSH
106904: CALL_OW 69
106908: PUSH
106909: FOR_IN
106910: IFFALSE 107130
// begin if not i in hackTanks then
106912: LD_VAR 0 1
106916: PUSH
106917: LD_EXP 156
106921: IN
106922: NOT
106923: IFFALSE 107006
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106925: LD_ADDR_EXP 156
106929: PUSH
106930: LD_EXP 156
106934: PPUSH
106935: LD_EXP 156
106939: PUSH
106940: LD_INT 1
106942: PLUS
106943: PPUSH
106944: LD_VAR 0 1
106948: PPUSH
106949: CALL_OW 1
106953: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106954: LD_ADDR_EXP 157
106958: PUSH
106959: LD_EXP 157
106963: PPUSH
106964: LD_EXP 157
106968: PUSH
106969: LD_INT 1
106971: PLUS
106972: PPUSH
106973: EMPTY
106974: PPUSH
106975: CALL_OW 1
106979: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106980: LD_ADDR_EXP 160
106984: PUSH
106985: LD_EXP 160
106989: PPUSH
106990: LD_EXP 160
106994: PUSH
106995: LD_INT 1
106997: PLUS
106998: PPUSH
106999: EMPTY
107000: PPUSH
107001: CALL_OW 1
107005: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107006: LD_VAR 0 1
107010: PPUSH
107011: CALL_OW 302
107015: NOT
107016: IFFALSE 107029
// begin HackUnlinkAll ( i ) ;
107018: LD_VAR 0 1
107022: PPUSH
107023: CALL 107135 0 1
// continue ;
107027: GO 106909
// end ; HackCheckCapturedStatus ( i ) ;
107029: LD_VAR 0 1
107033: PPUSH
107034: CALL 107578 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107038: LD_ADDR_VAR 0 2
107042: PUSH
107043: LD_INT 81
107045: PUSH
107046: LD_VAR 0 1
107050: PPUSH
107051: CALL_OW 255
107055: PUSH
107056: EMPTY
107057: LIST
107058: LIST
107059: PUSH
107060: LD_INT 33
107062: PUSH
107063: LD_INT 3
107065: PUSH
107066: EMPTY
107067: LIST
107068: LIST
107069: PUSH
107070: LD_INT 91
107072: PUSH
107073: LD_VAR 0 1
107077: PUSH
107078: LD_EXP 159
107082: PUSH
107083: EMPTY
107084: LIST
107085: LIST
107086: LIST
107087: PUSH
107088: LD_INT 50
107090: PUSH
107091: EMPTY
107092: LIST
107093: PUSH
107094: EMPTY
107095: LIST
107096: LIST
107097: LIST
107098: LIST
107099: PPUSH
107100: CALL_OW 69
107104: ST_TO_ADDR
// if not tmp then
107105: LD_VAR 0 2
107109: NOT
107110: IFFALSE 107114
// continue ;
107112: GO 106909
// HackLink ( i , tmp ) ;
107114: LD_VAR 0 1
107118: PPUSH
107119: LD_VAR 0 2
107123: PPUSH
107124: CALL 107271 0 2
// end ;
107128: GO 106909
107130: POP
107131: POP
// end ;
107132: PPOPN 2
107134: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107135: LD_INT 0
107137: PPUSH
107138: PPUSH
107139: PPUSH
// if not hack in hackTanks then
107140: LD_VAR 0 1
107144: PUSH
107145: LD_EXP 156
107149: IN
107150: NOT
107151: IFFALSE 107155
// exit ;
107153: GO 107266
// index := GetElementIndex ( hackTanks , hack ) ;
107155: LD_ADDR_VAR 0 4
107159: PUSH
107160: LD_EXP 156
107164: PPUSH
107165: LD_VAR 0 1
107169: PPUSH
107170: CALL 53577 0 2
107174: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107175: LD_EXP 157
107179: PUSH
107180: LD_VAR 0 4
107184: ARRAY
107185: IFFALSE 107266
// begin for i in hackTanksCaptured [ index ] do
107187: LD_ADDR_VAR 0 3
107191: PUSH
107192: LD_EXP 157
107196: PUSH
107197: LD_VAR 0 4
107201: ARRAY
107202: PUSH
107203: FOR_IN
107204: IFFALSE 107230
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107206: LD_VAR 0 3
107210: PUSH
107211: LD_INT 1
107213: ARRAY
107214: PPUSH
107215: LD_VAR 0 3
107219: PUSH
107220: LD_INT 2
107222: ARRAY
107223: PPUSH
107224: CALL_OW 235
107228: GO 107203
107230: POP
107231: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107232: LD_ADDR_EXP 157
107236: PUSH
107237: LD_EXP 157
107241: PPUSH
107242: LD_VAR 0 4
107246: PPUSH
107247: EMPTY
107248: PPUSH
107249: CALL_OW 1
107253: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107254: LD_VAR 0 1
107258: PPUSH
107259: LD_INT 0
107261: PPUSH
107262: CALL_OW 505
// end ; end ;
107266: LD_VAR 0 2
107270: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107271: LD_INT 0
107273: PPUSH
107274: PPUSH
107275: PPUSH
// if not hack in hackTanks or not vehicles then
107276: LD_VAR 0 1
107280: PUSH
107281: LD_EXP 156
107285: IN
107286: NOT
107287: PUSH
107288: LD_VAR 0 2
107292: NOT
107293: OR
107294: IFFALSE 107298
// exit ;
107296: GO 107573
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107298: LD_ADDR_VAR 0 2
107302: PUSH
107303: LD_VAR 0 1
107307: PPUSH
107308: LD_VAR 0 2
107312: PPUSH
107313: LD_INT 1
107315: PPUSH
107316: LD_INT 1
107318: PPUSH
107319: CALL 54227 0 4
107323: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107324: LD_ADDR_VAR 0 5
107328: PUSH
107329: LD_EXP 156
107333: PPUSH
107334: LD_VAR 0 1
107338: PPUSH
107339: CALL 53577 0 2
107343: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107344: LD_EXP 157
107348: PUSH
107349: LD_VAR 0 5
107353: ARRAY
107354: PUSH
107355: LD_EXP 158
107359: LESS
107360: IFFALSE 107549
// begin for i := 1 to vehicles do
107362: LD_ADDR_VAR 0 4
107366: PUSH
107367: DOUBLE
107368: LD_INT 1
107370: DEC
107371: ST_TO_ADDR
107372: LD_VAR 0 2
107376: PUSH
107377: FOR_TO
107378: IFFALSE 107547
// begin if hackTanksCaptured [ index ] = hackLimit then
107380: LD_EXP 157
107384: PUSH
107385: LD_VAR 0 5
107389: ARRAY
107390: PUSH
107391: LD_EXP 158
107395: EQUAL
107396: IFFALSE 107400
// break ;
107398: GO 107547
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107400: LD_ADDR_EXP 160
107404: PUSH
107405: LD_EXP 160
107409: PPUSH
107410: LD_VAR 0 5
107414: PPUSH
107415: LD_EXP 160
107419: PUSH
107420: LD_VAR 0 5
107424: ARRAY
107425: PUSH
107426: LD_INT 1
107428: PLUS
107429: PPUSH
107430: CALL_OW 1
107434: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107435: LD_ADDR_EXP 157
107439: PUSH
107440: LD_EXP 157
107444: PPUSH
107445: LD_VAR 0 5
107449: PUSH
107450: LD_EXP 157
107454: PUSH
107455: LD_VAR 0 5
107459: ARRAY
107460: PUSH
107461: LD_INT 1
107463: PLUS
107464: PUSH
107465: EMPTY
107466: LIST
107467: LIST
107468: PPUSH
107469: LD_VAR 0 2
107473: PUSH
107474: LD_VAR 0 4
107478: ARRAY
107479: PUSH
107480: LD_VAR 0 2
107484: PUSH
107485: LD_VAR 0 4
107489: ARRAY
107490: PPUSH
107491: CALL_OW 255
107495: PUSH
107496: EMPTY
107497: LIST
107498: LIST
107499: PPUSH
107500: CALL 53792 0 3
107504: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107505: LD_VAR 0 2
107509: PUSH
107510: LD_VAR 0 4
107514: ARRAY
107515: PPUSH
107516: LD_VAR 0 1
107520: PPUSH
107521: CALL_OW 255
107525: PPUSH
107526: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107530: LD_VAR 0 2
107534: PUSH
107535: LD_VAR 0 4
107539: ARRAY
107540: PPUSH
107541: CALL_OW 141
// end ;
107545: GO 107377
107547: POP
107548: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107549: LD_VAR 0 1
107553: PPUSH
107554: LD_EXP 157
107558: PUSH
107559: LD_VAR 0 5
107563: ARRAY
107564: PUSH
107565: LD_INT 0
107567: PLUS
107568: PPUSH
107569: CALL_OW 505
// end ;
107573: LD_VAR 0 3
107577: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107578: LD_INT 0
107580: PPUSH
107581: PPUSH
107582: PPUSH
107583: PPUSH
// if not hack in hackTanks then
107584: LD_VAR 0 1
107588: PUSH
107589: LD_EXP 156
107593: IN
107594: NOT
107595: IFFALSE 107599
// exit ;
107597: GO 107839
// index := GetElementIndex ( hackTanks , hack ) ;
107599: LD_ADDR_VAR 0 4
107603: PUSH
107604: LD_EXP 156
107608: PPUSH
107609: LD_VAR 0 1
107613: PPUSH
107614: CALL 53577 0 2
107618: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107619: LD_ADDR_VAR 0 3
107623: PUSH
107624: DOUBLE
107625: LD_EXP 157
107629: PUSH
107630: LD_VAR 0 4
107634: ARRAY
107635: INC
107636: ST_TO_ADDR
107637: LD_INT 1
107639: PUSH
107640: FOR_DOWNTO
107641: IFFALSE 107813
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107643: LD_ADDR_VAR 0 5
107647: PUSH
107648: LD_EXP 157
107652: PUSH
107653: LD_VAR 0 4
107657: ARRAY
107658: PUSH
107659: LD_VAR 0 3
107663: ARRAY
107664: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107665: LD_VAR 0 5
107669: PUSH
107670: LD_INT 1
107672: ARRAY
107673: PPUSH
107674: CALL_OW 302
107678: NOT
107679: PUSH
107680: LD_VAR 0 5
107684: PUSH
107685: LD_INT 1
107687: ARRAY
107688: PPUSH
107689: CALL_OW 255
107693: PUSH
107694: LD_VAR 0 1
107698: PPUSH
107699: CALL_OW 255
107703: NONEQUAL
107704: OR
107705: IFFALSE 107811
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107707: LD_VAR 0 5
107711: PUSH
107712: LD_INT 1
107714: ARRAY
107715: PPUSH
107716: CALL_OW 305
107720: PUSH
107721: LD_VAR 0 5
107725: PUSH
107726: LD_INT 1
107728: ARRAY
107729: PPUSH
107730: CALL_OW 255
107734: PUSH
107735: LD_VAR 0 1
107739: PPUSH
107740: CALL_OW 255
107744: EQUAL
107745: AND
107746: IFFALSE 107770
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107748: LD_VAR 0 5
107752: PUSH
107753: LD_INT 1
107755: ARRAY
107756: PPUSH
107757: LD_VAR 0 5
107761: PUSH
107762: LD_INT 2
107764: ARRAY
107765: PPUSH
107766: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107770: LD_ADDR_EXP 157
107774: PUSH
107775: LD_EXP 157
107779: PPUSH
107780: LD_VAR 0 4
107784: PPUSH
107785: LD_EXP 157
107789: PUSH
107790: LD_VAR 0 4
107794: ARRAY
107795: PPUSH
107796: LD_VAR 0 3
107800: PPUSH
107801: CALL_OW 3
107805: PPUSH
107806: CALL_OW 1
107810: ST_TO_ADDR
// end ; end ;
107811: GO 107640
107813: POP
107814: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107815: LD_VAR 0 1
107819: PPUSH
107820: LD_EXP 157
107824: PUSH
107825: LD_VAR 0 4
107829: ARRAY
107830: PUSH
107831: LD_INT 0
107833: PLUS
107834: PPUSH
107835: CALL_OW 505
// end ;
107839: LD_VAR 0 2
107843: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107844: LD_INT 0
107846: PPUSH
107847: PPUSH
107848: PPUSH
107849: PPUSH
// if not hack in hackTanks then
107850: LD_VAR 0 1
107854: PUSH
107855: LD_EXP 156
107859: IN
107860: NOT
107861: IFFALSE 107865
// exit ;
107863: GO 107950
// index := GetElementIndex ( hackTanks , hack ) ;
107865: LD_ADDR_VAR 0 5
107869: PUSH
107870: LD_EXP 156
107874: PPUSH
107875: LD_VAR 0 1
107879: PPUSH
107880: CALL 53577 0 2
107884: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107885: LD_ADDR_VAR 0 4
107889: PUSH
107890: DOUBLE
107891: LD_INT 1
107893: DEC
107894: ST_TO_ADDR
107895: LD_EXP 157
107899: PUSH
107900: LD_VAR 0 5
107904: ARRAY
107905: PUSH
107906: FOR_TO
107907: IFFALSE 107948
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107909: LD_EXP 157
107913: PUSH
107914: LD_VAR 0 5
107918: ARRAY
107919: PUSH
107920: LD_VAR 0 4
107924: ARRAY
107925: PUSH
107926: LD_INT 1
107928: ARRAY
107929: PUSH
107930: LD_VAR 0 2
107934: EQUAL
107935: IFFALSE 107946
// KillUnit ( vehicle ) ;
107937: LD_VAR 0 2
107941: PPUSH
107942: CALL_OW 66
107946: GO 107906
107948: POP
107949: POP
// end ;
107950: LD_VAR 0 3
107954: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107955: LD_EXP 161
107959: NOT
107960: IFFALSE 107995
107962: GO 107964
107964: DISABLE
// begin initMiner := true ;
107965: LD_ADDR_EXP 161
107969: PUSH
107970: LD_INT 1
107972: ST_TO_ADDR
// minersList := [ ] ;
107973: LD_ADDR_EXP 162
107977: PUSH
107978: EMPTY
107979: ST_TO_ADDR
// minerMinesList := [ ] ;
107980: LD_ADDR_EXP 163
107984: PUSH
107985: EMPTY
107986: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107987: LD_ADDR_EXP 164
107991: PUSH
107992: LD_INT 5
107994: ST_TO_ADDR
// end ;
107995: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107996: LD_EXP 161
108000: PUSH
108001: LD_INT 34
108003: PUSH
108004: LD_INT 81
108006: PUSH
108007: EMPTY
108008: LIST
108009: LIST
108010: PPUSH
108011: CALL_OW 69
108015: AND
108016: IFFALSE 108477
108018: GO 108020
108020: DISABLE
108021: LD_INT 0
108023: PPUSH
108024: PPUSH
108025: PPUSH
108026: PPUSH
// begin enable ;
108027: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108028: LD_ADDR_VAR 0 1
108032: PUSH
108033: LD_INT 34
108035: PUSH
108036: LD_INT 81
108038: PUSH
108039: EMPTY
108040: LIST
108041: LIST
108042: PPUSH
108043: CALL_OW 69
108047: PUSH
108048: FOR_IN
108049: IFFALSE 108121
// begin if not i in minersList then
108051: LD_VAR 0 1
108055: PUSH
108056: LD_EXP 162
108060: IN
108061: NOT
108062: IFFALSE 108119
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108064: LD_ADDR_EXP 162
108068: PUSH
108069: LD_EXP 162
108073: PPUSH
108074: LD_EXP 162
108078: PUSH
108079: LD_INT 1
108081: PLUS
108082: PPUSH
108083: LD_VAR 0 1
108087: PPUSH
108088: CALL_OW 1
108092: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108093: LD_ADDR_EXP 163
108097: PUSH
108098: LD_EXP 163
108102: PPUSH
108103: LD_EXP 163
108107: PUSH
108108: LD_INT 1
108110: PLUS
108111: PPUSH
108112: EMPTY
108113: PPUSH
108114: CALL_OW 1
108118: ST_TO_ADDR
// end end ;
108119: GO 108048
108121: POP
108122: POP
// for i := minerMinesList downto 1 do
108123: LD_ADDR_VAR 0 1
108127: PUSH
108128: DOUBLE
108129: LD_EXP 163
108133: INC
108134: ST_TO_ADDR
108135: LD_INT 1
108137: PUSH
108138: FOR_DOWNTO
108139: IFFALSE 108475
// begin if IsLive ( minersList [ i ] ) then
108141: LD_EXP 162
108145: PUSH
108146: LD_VAR 0 1
108150: ARRAY
108151: PPUSH
108152: CALL_OW 300
108156: IFFALSE 108184
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108158: LD_EXP 162
108162: PUSH
108163: LD_VAR 0 1
108167: ARRAY
108168: PPUSH
108169: LD_EXP 163
108173: PUSH
108174: LD_VAR 0 1
108178: ARRAY
108179: PPUSH
108180: CALL_OW 505
// if not minerMinesList [ i ] then
108184: LD_EXP 163
108188: PUSH
108189: LD_VAR 0 1
108193: ARRAY
108194: NOT
108195: IFFALSE 108199
// continue ;
108197: GO 108138
// for j := minerMinesList [ i ] downto 1 do
108199: LD_ADDR_VAR 0 2
108203: PUSH
108204: DOUBLE
108205: LD_EXP 163
108209: PUSH
108210: LD_VAR 0 1
108214: ARRAY
108215: INC
108216: ST_TO_ADDR
108217: LD_INT 1
108219: PUSH
108220: FOR_DOWNTO
108221: IFFALSE 108471
// begin side := GetSide ( minersList [ i ] ) ;
108223: LD_ADDR_VAR 0 3
108227: PUSH
108228: LD_EXP 162
108232: PUSH
108233: LD_VAR 0 1
108237: ARRAY
108238: PPUSH
108239: CALL_OW 255
108243: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108244: LD_ADDR_VAR 0 4
108248: PUSH
108249: LD_EXP 163
108253: PUSH
108254: LD_VAR 0 1
108258: ARRAY
108259: PUSH
108260: LD_VAR 0 2
108264: ARRAY
108265: PUSH
108266: LD_INT 1
108268: ARRAY
108269: PPUSH
108270: LD_EXP 163
108274: PUSH
108275: LD_VAR 0 1
108279: ARRAY
108280: PUSH
108281: LD_VAR 0 2
108285: ARRAY
108286: PUSH
108287: LD_INT 2
108289: ARRAY
108290: PPUSH
108291: CALL_OW 428
108295: ST_TO_ADDR
// if not tmp then
108296: LD_VAR 0 4
108300: NOT
108301: IFFALSE 108305
// continue ;
108303: GO 108220
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108305: LD_VAR 0 4
108309: PUSH
108310: LD_INT 81
108312: PUSH
108313: LD_VAR 0 3
108317: PUSH
108318: EMPTY
108319: LIST
108320: LIST
108321: PPUSH
108322: CALL_OW 69
108326: IN
108327: PUSH
108328: LD_EXP 163
108332: PUSH
108333: LD_VAR 0 1
108337: ARRAY
108338: PUSH
108339: LD_VAR 0 2
108343: ARRAY
108344: PUSH
108345: LD_INT 1
108347: ARRAY
108348: PPUSH
108349: LD_EXP 163
108353: PUSH
108354: LD_VAR 0 1
108358: ARRAY
108359: PUSH
108360: LD_VAR 0 2
108364: ARRAY
108365: PUSH
108366: LD_INT 2
108368: ARRAY
108369: PPUSH
108370: CALL_OW 458
108374: AND
108375: IFFALSE 108469
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108377: LD_EXP 163
108381: PUSH
108382: LD_VAR 0 1
108386: ARRAY
108387: PUSH
108388: LD_VAR 0 2
108392: ARRAY
108393: PUSH
108394: LD_INT 1
108396: ARRAY
108397: PPUSH
108398: LD_EXP 163
108402: PUSH
108403: LD_VAR 0 1
108407: ARRAY
108408: PUSH
108409: LD_VAR 0 2
108413: ARRAY
108414: PUSH
108415: LD_INT 2
108417: ARRAY
108418: PPUSH
108419: LD_VAR 0 3
108423: PPUSH
108424: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108428: LD_ADDR_EXP 163
108432: PUSH
108433: LD_EXP 163
108437: PPUSH
108438: LD_VAR 0 1
108442: PPUSH
108443: LD_EXP 163
108447: PUSH
108448: LD_VAR 0 1
108452: ARRAY
108453: PPUSH
108454: LD_VAR 0 2
108458: PPUSH
108459: CALL_OW 3
108463: PPUSH
108464: CALL_OW 1
108468: ST_TO_ADDR
// end ; end ;
108469: GO 108220
108471: POP
108472: POP
// end ;
108473: GO 108138
108475: POP
108476: POP
// end ;
108477: PPOPN 4
108479: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108480: LD_INT 0
108482: PPUSH
108483: PPUSH
// result := false ;
108484: LD_ADDR_VAR 0 4
108488: PUSH
108489: LD_INT 0
108491: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108492: LD_VAR 0 1
108496: PPUSH
108497: CALL_OW 264
108501: PUSH
108502: LD_INT 81
108504: EQUAL
108505: NOT
108506: IFFALSE 108510
// exit ;
108508: GO 108750
// index := GetElementIndex ( minersList , unit ) ;
108510: LD_ADDR_VAR 0 5
108514: PUSH
108515: LD_EXP 162
108519: PPUSH
108520: LD_VAR 0 1
108524: PPUSH
108525: CALL 53577 0 2
108529: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108530: LD_EXP 163
108534: PUSH
108535: LD_VAR 0 5
108539: ARRAY
108540: PUSH
108541: LD_EXP 164
108545: GREATEREQUAL
108546: IFFALSE 108550
// exit ;
108548: GO 108750
// ComMoveXY ( unit , x , y ) ;
108550: LD_VAR 0 1
108554: PPUSH
108555: LD_VAR 0 2
108559: PPUSH
108560: LD_VAR 0 3
108564: PPUSH
108565: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108569: LD_INT 35
108571: PPUSH
108572: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108576: LD_VAR 0 1
108580: PPUSH
108581: LD_VAR 0 2
108585: PPUSH
108586: LD_VAR 0 3
108590: PPUSH
108591: CALL 84913 0 3
108595: NOT
108596: PUSH
108597: LD_VAR 0 1
108601: PPUSH
108602: CALL_OW 314
108606: AND
108607: IFFALSE 108611
// exit ;
108609: GO 108750
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108611: LD_VAR 0 2
108615: PPUSH
108616: LD_VAR 0 3
108620: PPUSH
108621: CALL_OW 428
108625: PUSH
108626: LD_VAR 0 1
108630: EQUAL
108631: PUSH
108632: LD_VAR 0 1
108636: PPUSH
108637: CALL_OW 314
108641: NOT
108642: AND
108643: IFFALSE 108569
// PlaySoundXY ( x , y , PlantMine ) ;
108645: LD_VAR 0 2
108649: PPUSH
108650: LD_VAR 0 3
108654: PPUSH
108655: LD_STRING PlantMine
108657: PPUSH
108658: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108662: LD_VAR 0 2
108666: PPUSH
108667: LD_VAR 0 3
108671: PPUSH
108672: LD_VAR 0 1
108676: PPUSH
108677: CALL_OW 255
108681: PPUSH
108682: LD_INT 0
108684: PPUSH
108685: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108689: LD_ADDR_EXP 163
108693: PUSH
108694: LD_EXP 163
108698: PPUSH
108699: LD_VAR 0 5
108703: PUSH
108704: LD_EXP 163
108708: PUSH
108709: LD_VAR 0 5
108713: ARRAY
108714: PUSH
108715: LD_INT 1
108717: PLUS
108718: PUSH
108719: EMPTY
108720: LIST
108721: LIST
108722: PPUSH
108723: LD_VAR 0 2
108727: PUSH
108728: LD_VAR 0 3
108732: PUSH
108733: EMPTY
108734: LIST
108735: LIST
108736: PPUSH
108737: CALL 53792 0 3
108741: ST_TO_ADDR
// result := true ;
108742: LD_ADDR_VAR 0 4
108746: PUSH
108747: LD_INT 1
108749: ST_TO_ADDR
// end ;
108750: LD_VAR 0 4
108754: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108755: LD_INT 0
108757: PPUSH
108758: PPUSH
108759: PPUSH
// if not unit in minersList then
108760: LD_VAR 0 1
108764: PUSH
108765: LD_EXP 162
108769: IN
108770: NOT
108771: IFFALSE 108775
// exit ;
108773: GO 109167
// index := GetElementIndex ( minersList , unit ) ;
108775: LD_ADDR_VAR 0 6
108779: PUSH
108780: LD_EXP 162
108784: PPUSH
108785: LD_VAR 0 1
108789: PPUSH
108790: CALL 53577 0 2
108794: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108795: LD_ADDR_VAR 0 5
108799: PUSH
108800: DOUBLE
108801: LD_EXP 163
108805: PUSH
108806: LD_VAR 0 6
108810: ARRAY
108811: INC
108812: ST_TO_ADDR
108813: LD_INT 1
108815: PUSH
108816: FOR_DOWNTO
108817: IFFALSE 108978
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108819: LD_EXP 163
108823: PUSH
108824: LD_VAR 0 6
108828: ARRAY
108829: PUSH
108830: LD_VAR 0 5
108834: ARRAY
108835: PUSH
108836: LD_INT 1
108838: ARRAY
108839: PUSH
108840: LD_VAR 0 2
108844: EQUAL
108845: PUSH
108846: LD_EXP 163
108850: PUSH
108851: LD_VAR 0 6
108855: ARRAY
108856: PUSH
108857: LD_VAR 0 5
108861: ARRAY
108862: PUSH
108863: LD_INT 2
108865: ARRAY
108866: PUSH
108867: LD_VAR 0 3
108871: EQUAL
108872: AND
108873: IFFALSE 108976
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108875: LD_EXP 163
108879: PUSH
108880: LD_VAR 0 6
108884: ARRAY
108885: PUSH
108886: LD_VAR 0 5
108890: ARRAY
108891: PUSH
108892: LD_INT 1
108894: ARRAY
108895: PPUSH
108896: LD_EXP 163
108900: PUSH
108901: LD_VAR 0 6
108905: ARRAY
108906: PUSH
108907: LD_VAR 0 5
108911: ARRAY
108912: PUSH
108913: LD_INT 2
108915: ARRAY
108916: PPUSH
108917: LD_VAR 0 1
108921: PPUSH
108922: CALL_OW 255
108926: PPUSH
108927: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108931: LD_ADDR_EXP 163
108935: PUSH
108936: LD_EXP 163
108940: PPUSH
108941: LD_VAR 0 6
108945: PPUSH
108946: LD_EXP 163
108950: PUSH
108951: LD_VAR 0 6
108955: ARRAY
108956: PPUSH
108957: LD_VAR 0 5
108961: PPUSH
108962: CALL_OW 3
108966: PPUSH
108967: CALL_OW 1
108971: ST_TO_ADDR
// exit ;
108972: POP
108973: POP
108974: GO 109167
// end ; end ;
108976: GO 108816
108978: POP
108979: POP
// for i := minerMinesList [ index ] downto 1 do
108980: LD_ADDR_VAR 0 5
108984: PUSH
108985: DOUBLE
108986: LD_EXP 163
108990: PUSH
108991: LD_VAR 0 6
108995: ARRAY
108996: INC
108997: ST_TO_ADDR
108998: LD_INT 1
109000: PUSH
109001: FOR_DOWNTO
109002: IFFALSE 109165
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109004: LD_EXP 163
109008: PUSH
109009: LD_VAR 0 6
109013: ARRAY
109014: PUSH
109015: LD_VAR 0 5
109019: ARRAY
109020: PUSH
109021: LD_INT 1
109023: ARRAY
109024: PPUSH
109025: LD_EXP 163
109029: PUSH
109030: LD_VAR 0 6
109034: ARRAY
109035: PUSH
109036: LD_VAR 0 5
109040: ARRAY
109041: PUSH
109042: LD_INT 2
109044: ARRAY
109045: PPUSH
109046: LD_VAR 0 2
109050: PPUSH
109051: LD_VAR 0 3
109055: PPUSH
109056: CALL_OW 298
109060: PUSH
109061: LD_INT 6
109063: LESS
109064: IFFALSE 109163
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109066: LD_EXP 163
109070: PUSH
109071: LD_VAR 0 6
109075: ARRAY
109076: PUSH
109077: LD_VAR 0 5
109081: ARRAY
109082: PUSH
109083: LD_INT 1
109085: ARRAY
109086: PPUSH
109087: LD_EXP 163
109091: PUSH
109092: LD_VAR 0 6
109096: ARRAY
109097: PUSH
109098: LD_VAR 0 5
109102: ARRAY
109103: PUSH
109104: LD_INT 2
109106: ARRAY
109107: PPUSH
109108: LD_VAR 0 1
109112: PPUSH
109113: CALL_OW 255
109117: PPUSH
109118: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109122: LD_ADDR_EXP 163
109126: PUSH
109127: LD_EXP 163
109131: PPUSH
109132: LD_VAR 0 6
109136: PPUSH
109137: LD_EXP 163
109141: PUSH
109142: LD_VAR 0 6
109146: ARRAY
109147: PPUSH
109148: LD_VAR 0 5
109152: PPUSH
109153: CALL_OW 3
109157: PPUSH
109158: CALL_OW 1
109162: ST_TO_ADDR
// end ; end ;
109163: GO 109001
109165: POP
109166: POP
// end ;
109167: LD_VAR 0 4
109171: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109172: LD_INT 0
109174: PPUSH
109175: PPUSH
109176: PPUSH
109177: PPUSH
109178: PPUSH
109179: PPUSH
109180: PPUSH
109181: PPUSH
109182: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109183: LD_VAR 0 1
109187: PPUSH
109188: CALL_OW 264
109192: PUSH
109193: LD_INT 81
109195: EQUAL
109196: NOT
109197: PUSH
109198: LD_VAR 0 1
109202: PUSH
109203: LD_EXP 162
109207: IN
109208: NOT
109209: OR
109210: IFFALSE 109214
// exit ;
109212: GO 109536
// index := GetElementIndex ( minersList , unit ) ;
109214: LD_ADDR_VAR 0 6
109218: PUSH
109219: LD_EXP 162
109223: PPUSH
109224: LD_VAR 0 1
109228: PPUSH
109229: CALL 53577 0 2
109233: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109234: LD_ADDR_VAR 0 8
109238: PUSH
109239: LD_EXP 164
109243: PUSH
109244: LD_EXP 163
109248: PUSH
109249: LD_VAR 0 6
109253: ARRAY
109254: MINUS
109255: ST_TO_ADDR
// if not minesFreeAmount then
109256: LD_VAR 0 8
109260: NOT
109261: IFFALSE 109265
// exit ;
109263: GO 109536
// tmp := [ ] ;
109265: LD_ADDR_VAR 0 7
109269: PUSH
109270: EMPTY
109271: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109272: LD_ADDR_VAR 0 5
109276: PUSH
109277: DOUBLE
109278: LD_INT 1
109280: DEC
109281: ST_TO_ADDR
109282: LD_VAR 0 8
109286: PUSH
109287: FOR_TO
109288: IFFALSE 109483
// begin _d := rand ( 0 , 5 ) ;
109290: LD_ADDR_VAR 0 11
109294: PUSH
109295: LD_INT 0
109297: PPUSH
109298: LD_INT 5
109300: PPUSH
109301: CALL_OW 12
109305: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109306: LD_ADDR_VAR 0 12
109310: PUSH
109311: LD_INT 2
109313: PPUSH
109314: LD_INT 6
109316: PPUSH
109317: CALL_OW 12
109321: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109322: LD_ADDR_VAR 0 9
109326: PUSH
109327: LD_VAR 0 2
109331: PPUSH
109332: LD_VAR 0 11
109336: PPUSH
109337: LD_VAR 0 12
109341: PPUSH
109342: CALL_OW 272
109346: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109347: LD_ADDR_VAR 0 10
109351: PUSH
109352: LD_VAR 0 3
109356: PPUSH
109357: LD_VAR 0 11
109361: PPUSH
109362: LD_VAR 0 12
109366: PPUSH
109367: CALL_OW 273
109371: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109372: LD_VAR 0 9
109376: PPUSH
109377: LD_VAR 0 10
109381: PPUSH
109382: CALL_OW 488
109386: PUSH
109387: LD_VAR 0 9
109391: PUSH
109392: LD_VAR 0 10
109396: PUSH
109397: EMPTY
109398: LIST
109399: LIST
109400: PUSH
109401: LD_VAR 0 7
109405: IN
109406: NOT
109407: AND
109408: PUSH
109409: LD_VAR 0 9
109413: PPUSH
109414: LD_VAR 0 10
109418: PPUSH
109419: CALL_OW 458
109423: NOT
109424: AND
109425: IFFALSE 109467
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109427: LD_ADDR_VAR 0 7
109431: PUSH
109432: LD_VAR 0 7
109436: PPUSH
109437: LD_VAR 0 7
109441: PUSH
109442: LD_INT 1
109444: PLUS
109445: PPUSH
109446: LD_VAR 0 9
109450: PUSH
109451: LD_VAR 0 10
109455: PUSH
109456: EMPTY
109457: LIST
109458: LIST
109459: PPUSH
109460: CALL_OW 1
109464: ST_TO_ADDR
109465: GO 109481
// i := i - 1 ;
109467: LD_ADDR_VAR 0 5
109471: PUSH
109472: LD_VAR 0 5
109476: PUSH
109477: LD_INT 1
109479: MINUS
109480: ST_TO_ADDR
// end ;
109481: GO 109287
109483: POP
109484: POP
// for i in tmp do
109485: LD_ADDR_VAR 0 5
109489: PUSH
109490: LD_VAR 0 7
109494: PUSH
109495: FOR_IN
109496: IFFALSE 109534
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109498: LD_VAR 0 1
109502: PPUSH
109503: LD_VAR 0 5
109507: PUSH
109508: LD_INT 1
109510: ARRAY
109511: PPUSH
109512: LD_VAR 0 5
109516: PUSH
109517: LD_INT 2
109519: ARRAY
109520: PPUSH
109521: CALL 108480 0 3
109525: NOT
109526: IFFALSE 109532
// exit ;
109528: POP
109529: POP
109530: GO 109536
109532: GO 109495
109534: POP
109535: POP
// end ;
109536: LD_VAR 0 4
109540: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109541: LD_INT 0
109543: PPUSH
109544: PPUSH
109545: PPUSH
109546: PPUSH
109547: PPUSH
109548: PPUSH
109549: PPUSH
// if not GetClass ( unit ) = class_sniper then
109550: LD_VAR 0 1
109554: PPUSH
109555: CALL_OW 257
109559: PUSH
109560: LD_INT 5
109562: EQUAL
109563: NOT
109564: IFFALSE 109568
// exit ;
109566: GO 109956
// dist := 8 ;
109568: LD_ADDR_VAR 0 5
109572: PUSH
109573: LD_INT 8
109575: ST_TO_ADDR
// viewRange := 12 ;
109576: LD_ADDR_VAR 0 7
109580: PUSH
109581: LD_INT 12
109583: ST_TO_ADDR
// side := GetSide ( unit ) ;
109584: LD_ADDR_VAR 0 6
109588: PUSH
109589: LD_VAR 0 1
109593: PPUSH
109594: CALL_OW 255
109598: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109599: LD_INT 61
109601: PPUSH
109602: LD_VAR 0 6
109606: PPUSH
109607: CALL_OW 321
109611: PUSH
109612: LD_INT 2
109614: EQUAL
109615: IFFALSE 109625
// viewRange := 16 ;
109617: LD_ADDR_VAR 0 7
109621: PUSH
109622: LD_INT 16
109624: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109625: LD_VAR 0 1
109629: PPUSH
109630: LD_VAR 0 2
109634: PPUSH
109635: LD_VAR 0 3
109639: PPUSH
109640: CALL_OW 297
109644: PUSH
109645: LD_VAR 0 5
109649: GREATER
109650: IFFALSE 109729
// begin ComMoveXY ( unit , x , y ) ;
109652: LD_VAR 0 1
109656: PPUSH
109657: LD_VAR 0 2
109661: PPUSH
109662: LD_VAR 0 3
109666: PPUSH
109667: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109671: LD_INT 35
109673: PPUSH
109674: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109678: LD_VAR 0 1
109682: PPUSH
109683: LD_VAR 0 2
109687: PPUSH
109688: LD_VAR 0 3
109692: PPUSH
109693: CALL 84913 0 3
109697: NOT
109698: IFFALSE 109702
// exit ;
109700: GO 109956
// until GetDistUnitXY ( unit , x , y ) < dist ;
109702: LD_VAR 0 1
109706: PPUSH
109707: LD_VAR 0 2
109711: PPUSH
109712: LD_VAR 0 3
109716: PPUSH
109717: CALL_OW 297
109721: PUSH
109722: LD_VAR 0 5
109726: LESS
109727: IFFALSE 109671
// end ; ComTurnXY ( unit , x , y ) ;
109729: LD_VAR 0 1
109733: PPUSH
109734: LD_VAR 0 2
109738: PPUSH
109739: LD_VAR 0 3
109743: PPUSH
109744: CALL_OW 118
// wait ( 5 ) ;
109748: LD_INT 5
109750: PPUSH
109751: CALL_OW 67
// _d := GetDir ( unit ) ;
109755: LD_ADDR_VAR 0 10
109759: PUSH
109760: LD_VAR 0 1
109764: PPUSH
109765: CALL_OW 254
109769: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109770: LD_ADDR_VAR 0 8
109774: PUSH
109775: LD_VAR 0 1
109779: PPUSH
109780: CALL_OW 250
109784: PPUSH
109785: LD_VAR 0 10
109789: PPUSH
109790: LD_VAR 0 5
109794: PPUSH
109795: CALL_OW 272
109799: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109800: LD_ADDR_VAR 0 9
109804: PUSH
109805: LD_VAR 0 1
109809: PPUSH
109810: CALL_OW 251
109814: PPUSH
109815: LD_VAR 0 10
109819: PPUSH
109820: LD_VAR 0 5
109824: PPUSH
109825: CALL_OW 273
109829: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109830: LD_VAR 0 8
109834: PPUSH
109835: LD_VAR 0 9
109839: PPUSH
109840: CALL_OW 488
109844: NOT
109845: IFFALSE 109849
// exit ;
109847: GO 109956
// ComAnimCustom ( unit , 1 ) ;
109849: LD_VAR 0 1
109853: PPUSH
109854: LD_INT 1
109856: PPUSH
109857: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109861: LD_VAR 0 8
109865: PPUSH
109866: LD_VAR 0 9
109870: PPUSH
109871: LD_VAR 0 6
109875: PPUSH
109876: LD_VAR 0 7
109880: PPUSH
109881: CALL_OW 330
// repeat wait ( 1 ) ;
109885: LD_INT 1
109887: PPUSH
109888: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109892: LD_VAR 0 1
109896: PPUSH
109897: CALL_OW 316
109901: PUSH
109902: LD_VAR 0 1
109906: PPUSH
109907: CALL_OW 314
109911: OR
109912: PUSH
109913: LD_VAR 0 1
109917: PPUSH
109918: CALL_OW 302
109922: NOT
109923: OR
109924: PUSH
109925: LD_VAR 0 1
109929: PPUSH
109930: CALL_OW 301
109934: OR
109935: IFFALSE 109885
// RemoveSeeing ( _x , _y , side ) ;
109937: LD_VAR 0 8
109941: PPUSH
109942: LD_VAR 0 9
109946: PPUSH
109947: LD_VAR 0 6
109951: PPUSH
109952: CALL_OW 331
// end ; end_of_file
109956: LD_VAR 0 4
109960: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109961: LD_INT 0
109963: PPUSH
109964: PPUSH
109965: PPUSH
109966: PPUSH
109967: PPUSH
109968: PPUSH
109969: PPUSH
109970: PPUSH
109971: PPUSH
109972: PPUSH
109973: PPUSH
109974: PPUSH
109975: PPUSH
109976: PPUSH
109977: PPUSH
109978: PPUSH
109979: PPUSH
109980: PPUSH
109981: PPUSH
109982: PPUSH
109983: PPUSH
109984: PPUSH
109985: PPUSH
109986: PPUSH
109987: PPUSH
109988: PPUSH
109989: PPUSH
109990: PPUSH
109991: PPUSH
109992: PPUSH
109993: PPUSH
109994: PPUSH
109995: PPUSH
109996: PPUSH
// if not list then
109997: LD_VAR 0 1
110001: NOT
110002: IFFALSE 110006
// exit ;
110004: GO 114665
// base := list [ 1 ] ;
110006: LD_ADDR_VAR 0 3
110010: PUSH
110011: LD_VAR 0 1
110015: PUSH
110016: LD_INT 1
110018: ARRAY
110019: ST_TO_ADDR
// group := list [ 2 ] ;
110020: LD_ADDR_VAR 0 4
110024: PUSH
110025: LD_VAR 0 1
110029: PUSH
110030: LD_INT 2
110032: ARRAY
110033: ST_TO_ADDR
// path := list [ 3 ] ;
110034: LD_ADDR_VAR 0 5
110038: PUSH
110039: LD_VAR 0 1
110043: PUSH
110044: LD_INT 3
110046: ARRAY
110047: ST_TO_ADDR
// flags := list [ 4 ] ;
110048: LD_ADDR_VAR 0 6
110052: PUSH
110053: LD_VAR 0 1
110057: PUSH
110058: LD_INT 4
110060: ARRAY
110061: ST_TO_ADDR
// mined := [ ] ;
110062: LD_ADDR_VAR 0 27
110066: PUSH
110067: EMPTY
110068: ST_TO_ADDR
// bombed := [ ] ;
110069: LD_ADDR_VAR 0 28
110073: PUSH
110074: EMPTY
110075: ST_TO_ADDR
// healers := [ ] ;
110076: LD_ADDR_VAR 0 31
110080: PUSH
110081: EMPTY
110082: ST_TO_ADDR
// to_heal := [ ] ;
110083: LD_ADDR_VAR 0 30
110087: PUSH
110088: EMPTY
110089: ST_TO_ADDR
// repairs := [ ] ;
110090: LD_ADDR_VAR 0 33
110094: PUSH
110095: EMPTY
110096: ST_TO_ADDR
// to_repair := [ ] ;
110097: LD_ADDR_VAR 0 32
110101: PUSH
110102: EMPTY
110103: ST_TO_ADDR
// if not group or not path then
110104: LD_VAR 0 4
110108: NOT
110109: PUSH
110110: LD_VAR 0 5
110114: NOT
110115: OR
110116: IFFALSE 110120
// exit ;
110118: GO 114665
// side := GetSide ( group [ 1 ] ) ;
110120: LD_ADDR_VAR 0 35
110124: PUSH
110125: LD_VAR 0 4
110129: PUSH
110130: LD_INT 1
110132: ARRAY
110133: PPUSH
110134: CALL_OW 255
110138: ST_TO_ADDR
// if flags then
110139: LD_VAR 0 6
110143: IFFALSE 110287
// begin f_ignore_area := flags [ 1 ] ;
110145: LD_ADDR_VAR 0 17
110149: PUSH
110150: LD_VAR 0 6
110154: PUSH
110155: LD_INT 1
110157: ARRAY
110158: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110159: LD_ADDR_VAR 0 18
110163: PUSH
110164: LD_VAR 0 6
110168: PUSH
110169: LD_INT 2
110171: ARRAY
110172: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110173: LD_ADDR_VAR 0 19
110177: PUSH
110178: LD_VAR 0 6
110182: PUSH
110183: LD_INT 3
110185: ARRAY
110186: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110187: LD_ADDR_VAR 0 20
110191: PUSH
110192: LD_VAR 0 6
110196: PUSH
110197: LD_INT 4
110199: ARRAY
110200: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110201: LD_ADDR_VAR 0 21
110205: PUSH
110206: LD_VAR 0 6
110210: PUSH
110211: LD_INT 5
110213: ARRAY
110214: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110215: LD_ADDR_VAR 0 22
110219: PUSH
110220: LD_VAR 0 6
110224: PUSH
110225: LD_INT 6
110227: ARRAY
110228: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110229: LD_ADDR_VAR 0 23
110233: PUSH
110234: LD_VAR 0 6
110238: PUSH
110239: LD_INT 7
110241: ARRAY
110242: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110243: LD_ADDR_VAR 0 24
110247: PUSH
110248: LD_VAR 0 6
110252: PUSH
110253: LD_INT 8
110255: ARRAY
110256: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110257: LD_ADDR_VAR 0 25
110261: PUSH
110262: LD_VAR 0 6
110266: PUSH
110267: LD_INT 9
110269: ARRAY
110270: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110271: LD_ADDR_VAR 0 26
110275: PUSH
110276: LD_VAR 0 6
110280: PUSH
110281: LD_INT 10
110283: ARRAY
110284: ST_TO_ADDR
// end else
110285: GO 110367
// begin f_ignore_area := false ;
110287: LD_ADDR_VAR 0 17
110291: PUSH
110292: LD_INT 0
110294: ST_TO_ADDR
// f_capture := false ;
110295: LD_ADDR_VAR 0 18
110299: PUSH
110300: LD_INT 0
110302: ST_TO_ADDR
// f_ignore_civ := false ;
110303: LD_ADDR_VAR 0 19
110307: PUSH
110308: LD_INT 0
110310: ST_TO_ADDR
// f_murder := false ;
110311: LD_ADDR_VAR 0 20
110315: PUSH
110316: LD_INT 0
110318: ST_TO_ADDR
// f_mines := false ;
110319: LD_ADDR_VAR 0 21
110323: PUSH
110324: LD_INT 0
110326: ST_TO_ADDR
// f_repair := false ;
110327: LD_ADDR_VAR 0 22
110331: PUSH
110332: LD_INT 0
110334: ST_TO_ADDR
// f_heal := false ;
110335: LD_ADDR_VAR 0 23
110339: PUSH
110340: LD_INT 0
110342: ST_TO_ADDR
// f_spacetime := false ;
110343: LD_ADDR_VAR 0 24
110347: PUSH
110348: LD_INT 0
110350: ST_TO_ADDR
// f_attack_depot := false ;
110351: LD_ADDR_VAR 0 25
110355: PUSH
110356: LD_INT 0
110358: ST_TO_ADDR
// f_crawl := false ;
110359: LD_ADDR_VAR 0 26
110363: PUSH
110364: LD_INT 0
110366: ST_TO_ADDR
// end ; if f_heal then
110367: LD_VAR 0 23
110371: IFFALSE 110398
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110373: LD_ADDR_VAR 0 31
110377: PUSH
110378: LD_VAR 0 4
110382: PPUSH
110383: LD_INT 25
110385: PUSH
110386: LD_INT 4
110388: PUSH
110389: EMPTY
110390: LIST
110391: LIST
110392: PPUSH
110393: CALL_OW 72
110397: ST_TO_ADDR
// if f_repair then
110398: LD_VAR 0 22
110402: IFFALSE 110429
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110404: LD_ADDR_VAR 0 33
110408: PUSH
110409: LD_VAR 0 4
110413: PPUSH
110414: LD_INT 25
110416: PUSH
110417: LD_INT 3
110419: PUSH
110420: EMPTY
110421: LIST
110422: LIST
110423: PPUSH
110424: CALL_OW 72
110428: ST_TO_ADDR
// units_path := [ ] ;
110429: LD_ADDR_VAR 0 16
110433: PUSH
110434: EMPTY
110435: ST_TO_ADDR
// for i = 1 to group do
110436: LD_ADDR_VAR 0 7
110440: PUSH
110441: DOUBLE
110442: LD_INT 1
110444: DEC
110445: ST_TO_ADDR
110446: LD_VAR 0 4
110450: PUSH
110451: FOR_TO
110452: IFFALSE 110481
// units_path := Replace ( units_path , i , path ) ;
110454: LD_ADDR_VAR 0 16
110458: PUSH
110459: LD_VAR 0 16
110463: PPUSH
110464: LD_VAR 0 7
110468: PPUSH
110469: LD_VAR 0 5
110473: PPUSH
110474: CALL_OW 1
110478: ST_TO_ADDR
110479: GO 110451
110481: POP
110482: POP
// repeat for i = group downto 1 do
110483: LD_ADDR_VAR 0 7
110487: PUSH
110488: DOUBLE
110489: LD_VAR 0 4
110493: INC
110494: ST_TO_ADDR
110495: LD_INT 1
110497: PUSH
110498: FOR_DOWNTO
110499: IFFALSE 114621
// begin wait ( 5 ) ;
110501: LD_INT 5
110503: PPUSH
110504: CALL_OW 67
// tmp := [ ] ;
110508: LD_ADDR_VAR 0 14
110512: PUSH
110513: EMPTY
110514: ST_TO_ADDR
// attacking := false ;
110515: LD_ADDR_VAR 0 29
110519: PUSH
110520: LD_INT 0
110522: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110523: LD_VAR 0 4
110527: PUSH
110528: LD_VAR 0 7
110532: ARRAY
110533: PPUSH
110534: CALL_OW 301
110538: PUSH
110539: LD_VAR 0 4
110543: PUSH
110544: LD_VAR 0 7
110548: ARRAY
110549: NOT
110550: OR
110551: IFFALSE 110660
// begin if GetType ( group [ i ] ) = unit_human then
110553: LD_VAR 0 4
110557: PUSH
110558: LD_VAR 0 7
110562: ARRAY
110563: PPUSH
110564: CALL_OW 247
110568: PUSH
110569: LD_INT 1
110571: EQUAL
110572: IFFALSE 110618
// begin to_heal := to_heal diff group [ i ] ;
110574: LD_ADDR_VAR 0 30
110578: PUSH
110579: LD_VAR 0 30
110583: PUSH
110584: LD_VAR 0 4
110588: PUSH
110589: LD_VAR 0 7
110593: ARRAY
110594: DIFF
110595: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110596: LD_ADDR_VAR 0 31
110600: PUSH
110601: LD_VAR 0 31
110605: PUSH
110606: LD_VAR 0 4
110610: PUSH
110611: LD_VAR 0 7
110615: ARRAY
110616: DIFF
110617: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110618: LD_ADDR_VAR 0 4
110622: PUSH
110623: LD_VAR 0 4
110627: PPUSH
110628: LD_VAR 0 7
110632: PPUSH
110633: CALL_OW 3
110637: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110638: LD_ADDR_VAR 0 16
110642: PUSH
110643: LD_VAR 0 16
110647: PPUSH
110648: LD_VAR 0 7
110652: PPUSH
110653: CALL_OW 3
110657: ST_TO_ADDR
// continue ;
110658: GO 110498
// end ; if f_repair then
110660: LD_VAR 0 22
110664: IFFALSE 111153
// begin if GetType ( group [ i ] ) = unit_vehicle then
110666: LD_VAR 0 4
110670: PUSH
110671: LD_VAR 0 7
110675: ARRAY
110676: PPUSH
110677: CALL_OW 247
110681: PUSH
110682: LD_INT 2
110684: EQUAL
110685: IFFALSE 110875
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110687: LD_VAR 0 4
110691: PUSH
110692: LD_VAR 0 7
110696: ARRAY
110697: PPUSH
110698: CALL_OW 256
110702: PUSH
110703: LD_INT 700
110705: LESS
110706: PUSH
110707: LD_VAR 0 4
110711: PUSH
110712: LD_VAR 0 7
110716: ARRAY
110717: PUSH
110718: LD_VAR 0 32
110722: IN
110723: NOT
110724: AND
110725: IFFALSE 110749
// to_repair := to_repair union group [ i ] ;
110727: LD_ADDR_VAR 0 32
110731: PUSH
110732: LD_VAR 0 32
110736: PUSH
110737: LD_VAR 0 4
110741: PUSH
110742: LD_VAR 0 7
110746: ARRAY
110747: UNION
110748: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110749: LD_VAR 0 4
110753: PUSH
110754: LD_VAR 0 7
110758: ARRAY
110759: PPUSH
110760: CALL_OW 256
110764: PUSH
110765: LD_INT 1000
110767: EQUAL
110768: PUSH
110769: LD_VAR 0 4
110773: PUSH
110774: LD_VAR 0 7
110778: ARRAY
110779: PUSH
110780: LD_VAR 0 32
110784: IN
110785: AND
110786: IFFALSE 110810
// to_repair := to_repair diff group [ i ] ;
110788: LD_ADDR_VAR 0 32
110792: PUSH
110793: LD_VAR 0 32
110797: PUSH
110798: LD_VAR 0 4
110802: PUSH
110803: LD_VAR 0 7
110807: ARRAY
110808: DIFF
110809: ST_TO_ADDR
// if group [ i ] in to_repair then
110810: LD_VAR 0 4
110814: PUSH
110815: LD_VAR 0 7
110819: ARRAY
110820: PUSH
110821: LD_VAR 0 32
110825: IN
110826: IFFALSE 110873
// begin if not IsInArea ( group [ i ] , f_repair ) then
110828: LD_VAR 0 4
110832: PUSH
110833: LD_VAR 0 7
110837: ARRAY
110838: PPUSH
110839: LD_VAR 0 22
110843: PPUSH
110844: CALL_OW 308
110848: NOT
110849: IFFALSE 110871
// ComMoveToArea ( group [ i ] , f_repair ) ;
110851: LD_VAR 0 4
110855: PUSH
110856: LD_VAR 0 7
110860: ARRAY
110861: PPUSH
110862: LD_VAR 0 22
110866: PPUSH
110867: CALL_OW 113
// continue ;
110871: GO 110498
// end ; end else
110873: GO 111153
// if group [ i ] in repairs then
110875: LD_VAR 0 4
110879: PUSH
110880: LD_VAR 0 7
110884: ARRAY
110885: PUSH
110886: LD_VAR 0 33
110890: IN
110891: IFFALSE 111153
// begin if IsInUnit ( group [ i ] ) then
110893: LD_VAR 0 4
110897: PUSH
110898: LD_VAR 0 7
110902: ARRAY
110903: PPUSH
110904: CALL_OW 310
110908: IFFALSE 110976
// begin z := IsInUnit ( group [ i ] ) ;
110910: LD_ADDR_VAR 0 13
110914: PUSH
110915: LD_VAR 0 4
110919: PUSH
110920: LD_VAR 0 7
110924: ARRAY
110925: PPUSH
110926: CALL_OW 310
110930: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110931: LD_VAR 0 13
110935: PUSH
110936: LD_VAR 0 32
110940: IN
110941: PUSH
110942: LD_VAR 0 13
110946: PPUSH
110947: LD_VAR 0 22
110951: PPUSH
110952: CALL_OW 308
110956: AND
110957: IFFALSE 110974
// ComExitVehicle ( group [ i ] ) ;
110959: LD_VAR 0 4
110963: PUSH
110964: LD_VAR 0 7
110968: ARRAY
110969: PPUSH
110970: CALL_OW 121
// end else
110974: GO 111153
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110976: LD_ADDR_VAR 0 13
110980: PUSH
110981: LD_VAR 0 4
110985: PPUSH
110986: LD_INT 95
110988: PUSH
110989: LD_VAR 0 22
110993: PUSH
110994: EMPTY
110995: LIST
110996: LIST
110997: PUSH
110998: LD_INT 58
111000: PUSH
111001: EMPTY
111002: LIST
111003: PUSH
111004: EMPTY
111005: LIST
111006: LIST
111007: PPUSH
111008: CALL_OW 72
111012: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111013: LD_VAR 0 4
111017: PUSH
111018: LD_VAR 0 7
111022: ARRAY
111023: PPUSH
111024: CALL_OW 314
111028: NOT
111029: IFFALSE 111151
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111031: LD_ADDR_VAR 0 10
111035: PUSH
111036: LD_VAR 0 13
111040: PPUSH
111041: LD_VAR 0 4
111045: PUSH
111046: LD_VAR 0 7
111050: ARRAY
111051: PPUSH
111052: CALL_OW 74
111056: ST_TO_ADDR
// if not x then
111057: LD_VAR 0 10
111061: NOT
111062: IFFALSE 111066
// continue ;
111064: GO 110498
// if GetLives ( x ) < 1000 then
111066: LD_VAR 0 10
111070: PPUSH
111071: CALL_OW 256
111075: PUSH
111076: LD_INT 1000
111078: LESS
111079: IFFALSE 111103
// ComRepairVehicle ( group [ i ] , x ) else
111081: LD_VAR 0 4
111085: PUSH
111086: LD_VAR 0 7
111090: ARRAY
111091: PPUSH
111092: LD_VAR 0 10
111096: PPUSH
111097: CALL_OW 129
111101: GO 111151
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111103: LD_VAR 0 23
111107: PUSH
111108: LD_VAR 0 4
111112: PUSH
111113: LD_VAR 0 7
111117: ARRAY
111118: PPUSH
111119: CALL_OW 256
111123: PUSH
111124: LD_INT 1000
111126: LESS
111127: AND
111128: NOT
111129: IFFALSE 111151
// ComEnterUnit ( group [ i ] , x ) ;
111131: LD_VAR 0 4
111135: PUSH
111136: LD_VAR 0 7
111140: ARRAY
111141: PPUSH
111142: LD_VAR 0 10
111146: PPUSH
111147: CALL_OW 120
// end ; continue ;
111151: GO 110498
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111153: LD_VAR 0 23
111157: PUSH
111158: LD_VAR 0 4
111162: PUSH
111163: LD_VAR 0 7
111167: ARRAY
111168: PPUSH
111169: CALL_OW 247
111173: PUSH
111174: LD_INT 1
111176: EQUAL
111177: AND
111178: IFFALSE 111656
// begin if group [ i ] in healers then
111180: LD_VAR 0 4
111184: PUSH
111185: LD_VAR 0 7
111189: ARRAY
111190: PUSH
111191: LD_VAR 0 31
111195: IN
111196: IFFALSE 111469
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111198: LD_VAR 0 4
111202: PUSH
111203: LD_VAR 0 7
111207: ARRAY
111208: PPUSH
111209: LD_VAR 0 23
111213: PPUSH
111214: CALL_OW 308
111218: NOT
111219: PUSH
111220: LD_VAR 0 4
111224: PUSH
111225: LD_VAR 0 7
111229: ARRAY
111230: PPUSH
111231: CALL_OW 314
111235: NOT
111236: AND
111237: IFFALSE 111261
// ComMoveToArea ( group [ i ] , f_heal ) else
111239: LD_VAR 0 4
111243: PUSH
111244: LD_VAR 0 7
111248: ARRAY
111249: PPUSH
111250: LD_VAR 0 23
111254: PPUSH
111255: CALL_OW 113
111259: GO 111467
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111261: LD_VAR 0 4
111265: PUSH
111266: LD_VAR 0 7
111270: ARRAY
111271: PPUSH
111272: CALL 83489 0 1
111276: PPUSH
111277: CALL_OW 256
111281: PUSH
111282: LD_INT 1000
111284: EQUAL
111285: IFFALSE 111304
// ComStop ( group [ i ] ) else
111287: LD_VAR 0 4
111291: PUSH
111292: LD_VAR 0 7
111296: ARRAY
111297: PPUSH
111298: CALL_OW 141
111302: GO 111467
// if not HasTask ( group [ i ] ) and to_heal then
111304: LD_VAR 0 4
111308: PUSH
111309: LD_VAR 0 7
111313: ARRAY
111314: PPUSH
111315: CALL_OW 314
111319: NOT
111320: PUSH
111321: LD_VAR 0 30
111325: AND
111326: IFFALSE 111467
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111328: LD_ADDR_VAR 0 13
111332: PUSH
111333: LD_VAR 0 30
111337: PPUSH
111338: LD_INT 3
111340: PUSH
111341: LD_INT 54
111343: PUSH
111344: EMPTY
111345: LIST
111346: PUSH
111347: EMPTY
111348: LIST
111349: LIST
111350: PPUSH
111351: CALL_OW 72
111355: PPUSH
111356: LD_VAR 0 4
111360: PUSH
111361: LD_VAR 0 7
111365: ARRAY
111366: PPUSH
111367: CALL_OW 74
111371: ST_TO_ADDR
// if z then
111372: LD_VAR 0 13
111376: IFFALSE 111467
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111378: LD_INT 91
111380: PUSH
111381: LD_VAR 0 13
111385: PUSH
111386: LD_INT 10
111388: PUSH
111389: EMPTY
111390: LIST
111391: LIST
111392: LIST
111393: PUSH
111394: LD_INT 81
111396: PUSH
111397: LD_VAR 0 13
111401: PPUSH
111402: CALL_OW 255
111406: PUSH
111407: EMPTY
111408: LIST
111409: LIST
111410: PUSH
111411: EMPTY
111412: LIST
111413: LIST
111414: PPUSH
111415: CALL_OW 69
111419: PUSH
111420: LD_INT 0
111422: EQUAL
111423: IFFALSE 111447
// ComHeal ( group [ i ] , z ) else
111425: LD_VAR 0 4
111429: PUSH
111430: LD_VAR 0 7
111434: ARRAY
111435: PPUSH
111436: LD_VAR 0 13
111440: PPUSH
111441: CALL_OW 128
111445: GO 111467
// ComMoveToArea ( group [ i ] , f_heal ) ;
111447: LD_VAR 0 4
111451: PUSH
111452: LD_VAR 0 7
111456: ARRAY
111457: PPUSH
111458: LD_VAR 0 23
111462: PPUSH
111463: CALL_OW 113
// end ; continue ;
111467: GO 110498
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111469: LD_VAR 0 4
111473: PUSH
111474: LD_VAR 0 7
111478: ARRAY
111479: PPUSH
111480: CALL_OW 256
111484: PUSH
111485: LD_INT 700
111487: LESS
111488: PUSH
111489: LD_VAR 0 4
111493: PUSH
111494: LD_VAR 0 7
111498: ARRAY
111499: PUSH
111500: LD_VAR 0 30
111504: IN
111505: NOT
111506: AND
111507: IFFALSE 111531
// to_heal := to_heal union group [ i ] ;
111509: LD_ADDR_VAR 0 30
111513: PUSH
111514: LD_VAR 0 30
111518: PUSH
111519: LD_VAR 0 4
111523: PUSH
111524: LD_VAR 0 7
111528: ARRAY
111529: UNION
111530: ST_TO_ADDR
// if group [ i ] in to_heal then
111531: LD_VAR 0 4
111535: PUSH
111536: LD_VAR 0 7
111540: ARRAY
111541: PUSH
111542: LD_VAR 0 30
111546: IN
111547: IFFALSE 111656
// begin if GetLives ( group [ i ] ) = 1000 then
111549: LD_VAR 0 4
111553: PUSH
111554: LD_VAR 0 7
111558: ARRAY
111559: PPUSH
111560: CALL_OW 256
111564: PUSH
111565: LD_INT 1000
111567: EQUAL
111568: IFFALSE 111594
// to_heal := to_heal diff group [ i ] else
111570: LD_ADDR_VAR 0 30
111574: PUSH
111575: LD_VAR 0 30
111579: PUSH
111580: LD_VAR 0 4
111584: PUSH
111585: LD_VAR 0 7
111589: ARRAY
111590: DIFF
111591: ST_TO_ADDR
111592: GO 111656
// begin if not IsInArea ( group [ i ] , to_heal ) then
111594: LD_VAR 0 4
111598: PUSH
111599: LD_VAR 0 7
111603: ARRAY
111604: PPUSH
111605: LD_VAR 0 30
111609: PPUSH
111610: CALL_OW 308
111614: NOT
111615: IFFALSE 111639
// ComMoveToArea ( group [ i ] , f_heal ) else
111617: LD_VAR 0 4
111621: PUSH
111622: LD_VAR 0 7
111626: ARRAY
111627: PPUSH
111628: LD_VAR 0 23
111632: PPUSH
111633: CALL_OW 113
111637: GO 111654
// ComHold ( group [ i ] ) ;
111639: LD_VAR 0 4
111643: PUSH
111644: LD_VAR 0 7
111648: ARRAY
111649: PPUSH
111650: CALL_OW 140
// continue ;
111654: GO 110498
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111656: LD_VAR 0 4
111660: PUSH
111661: LD_VAR 0 7
111665: ARRAY
111666: PPUSH
111667: LD_INT 10
111669: PPUSH
111670: CALL 81286 0 2
111674: NOT
111675: PUSH
111676: LD_VAR 0 16
111680: PUSH
111681: LD_VAR 0 7
111685: ARRAY
111686: PUSH
111687: EMPTY
111688: EQUAL
111689: NOT
111690: AND
111691: IFFALSE 111957
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111693: LD_VAR 0 4
111697: PUSH
111698: LD_VAR 0 7
111702: ARRAY
111703: PPUSH
111704: CALL_OW 262
111708: PUSH
111709: LD_INT 1
111711: PUSH
111712: LD_INT 2
111714: PUSH
111715: EMPTY
111716: LIST
111717: LIST
111718: IN
111719: IFFALSE 111760
// if GetFuel ( group [ i ] ) < 10 then
111721: LD_VAR 0 4
111725: PUSH
111726: LD_VAR 0 7
111730: ARRAY
111731: PPUSH
111732: CALL_OW 261
111736: PUSH
111737: LD_INT 10
111739: LESS
111740: IFFALSE 111760
// SetFuel ( group [ i ] , 12 ) ;
111742: LD_VAR 0 4
111746: PUSH
111747: LD_VAR 0 7
111751: ARRAY
111752: PPUSH
111753: LD_INT 12
111755: PPUSH
111756: CALL_OW 240
// if units_path [ i ] then
111760: LD_VAR 0 16
111764: PUSH
111765: LD_VAR 0 7
111769: ARRAY
111770: IFFALSE 111955
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111772: LD_VAR 0 4
111776: PUSH
111777: LD_VAR 0 7
111781: ARRAY
111782: PPUSH
111783: LD_VAR 0 16
111787: PUSH
111788: LD_VAR 0 7
111792: ARRAY
111793: PUSH
111794: LD_INT 1
111796: ARRAY
111797: PUSH
111798: LD_INT 1
111800: ARRAY
111801: PPUSH
111802: LD_VAR 0 16
111806: PUSH
111807: LD_VAR 0 7
111811: ARRAY
111812: PUSH
111813: LD_INT 1
111815: ARRAY
111816: PUSH
111817: LD_INT 2
111819: ARRAY
111820: PPUSH
111821: CALL_OW 297
111825: PUSH
111826: LD_INT 6
111828: GREATER
111829: IFFALSE 111904
// begin if not HasTask ( group [ i ] ) then
111831: LD_VAR 0 4
111835: PUSH
111836: LD_VAR 0 7
111840: ARRAY
111841: PPUSH
111842: CALL_OW 314
111846: NOT
111847: IFFALSE 111902
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111849: LD_VAR 0 4
111853: PUSH
111854: LD_VAR 0 7
111858: ARRAY
111859: PPUSH
111860: LD_VAR 0 16
111864: PUSH
111865: LD_VAR 0 7
111869: ARRAY
111870: PUSH
111871: LD_INT 1
111873: ARRAY
111874: PUSH
111875: LD_INT 1
111877: ARRAY
111878: PPUSH
111879: LD_VAR 0 16
111883: PUSH
111884: LD_VAR 0 7
111888: ARRAY
111889: PUSH
111890: LD_INT 1
111892: ARRAY
111893: PUSH
111894: LD_INT 2
111896: ARRAY
111897: PPUSH
111898: CALL_OW 114
// end else
111902: GO 111955
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111904: LD_ADDR_VAR 0 15
111908: PUSH
111909: LD_VAR 0 16
111913: PUSH
111914: LD_VAR 0 7
111918: ARRAY
111919: PPUSH
111920: LD_INT 1
111922: PPUSH
111923: CALL_OW 3
111927: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111928: LD_ADDR_VAR 0 16
111932: PUSH
111933: LD_VAR 0 16
111937: PPUSH
111938: LD_VAR 0 7
111942: PPUSH
111943: LD_VAR 0 15
111947: PPUSH
111948: CALL_OW 1
111952: ST_TO_ADDR
// continue ;
111953: GO 110498
// end ; end ; end else
111955: GO 114619
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111957: LD_ADDR_VAR 0 14
111961: PUSH
111962: LD_INT 81
111964: PUSH
111965: LD_VAR 0 4
111969: PUSH
111970: LD_VAR 0 7
111974: ARRAY
111975: PPUSH
111976: CALL_OW 255
111980: PUSH
111981: EMPTY
111982: LIST
111983: LIST
111984: PPUSH
111985: CALL_OW 69
111989: ST_TO_ADDR
// if not tmp then
111990: LD_VAR 0 14
111994: NOT
111995: IFFALSE 111999
// continue ;
111997: GO 110498
// if f_ignore_area then
111999: LD_VAR 0 17
112003: IFFALSE 112091
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112005: LD_ADDR_VAR 0 15
112009: PUSH
112010: LD_VAR 0 14
112014: PPUSH
112015: LD_INT 3
112017: PUSH
112018: LD_INT 92
112020: PUSH
112021: LD_VAR 0 17
112025: PUSH
112026: LD_INT 1
112028: ARRAY
112029: PUSH
112030: LD_VAR 0 17
112034: PUSH
112035: LD_INT 2
112037: ARRAY
112038: PUSH
112039: LD_VAR 0 17
112043: PUSH
112044: LD_INT 3
112046: ARRAY
112047: PUSH
112048: EMPTY
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: PUSH
112054: EMPTY
112055: LIST
112056: LIST
112057: PPUSH
112058: CALL_OW 72
112062: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112063: LD_VAR 0 14
112067: PUSH
112068: LD_VAR 0 15
112072: DIFF
112073: IFFALSE 112091
// tmp := tmp diff tmp2 ;
112075: LD_ADDR_VAR 0 14
112079: PUSH
112080: LD_VAR 0 14
112084: PUSH
112085: LD_VAR 0 15
112089: DIFF
112090: ST_TO_ADDR
// end ; if not f_murder then
112091: LD_VAR 0 20
112095: NOT
112096: IFFALSE 112154
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112098: LD_ADDR_VAR 0 15
112102: PUSH
112103: LD_VAR 0 14
112107: PPUSH
112108: LD_INT 3
112110: PUSH
112111: LD_INT 50
112113: PUSH
112114: EMPTY
112115: LIST
112116: PUSH
112117: EMPTY
112118: LIST
112119: LIST
112120: PPUSH
112121: CALL_OW 72
112125: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112126: LD_VAR 0 14
112130: PUSH
112131: LD_VAR 0 15
112135: DIFF
112136: IFFALSE 112154
// tmp := tmp diff tmp2 ;
112138: LD_ADDR_VAR 0 14
112142: PUSH
112143: LD_VAR 0 14
112147: PUSH
112148: LD_VAR 0 15
112152: DIFF
112153: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112154: LD_ADDR_VAR 0 14
112158: PUSH
112159: LD_VAR 0 4
112163: PUSH
112164: LD_VAR 0 7
112168: ARRAY
112169: PPUSH
112170: LD_VAR 0 14
112174: PPUSH
112175: LD_INT 1
112177: PPUSH
112178: LD_INT 1
112180: PPUSH
112181: CALL 54227 0 4
112185: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112186: LD_VAR 0 4
112190: PUSH
112191: LD_VAR 0 7
112195: ARRAY
112196: PPUSH
112197: CALL_OW 257
112201: PUSH
112202: LD_INT 1
112204: EQUAL
112205: IFFALSE 112653
// begin if WantPlant ( group [ i ] ) then
112207: LD_VAR 0 4
112211: PUSH
112212: LD_VAR 0 7
112216: ARRAY
112217: PPUSH
112218: CALL 53728 0 1
112222: IFFALSE 112226
// continue ;
112224: GO 110498
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112226: LD_VAR 0 18
112230: PUSH
112231: LD_VAR 0 4
112235: PUSH
112236: LD_VAR 0 7
112240: ARRAY
112241: PPUSH
112242: CALL_OW 310
112246: NOT
112247: AND
112248: PUSH
112249: LD_VAR 0 14
112253: PUSH
112254: LD_INT 1
112256: ARRAY
112257: PUSH
112258: LD_VAR 0 14
112262: PPUSH
112263: LD_INT 21
112265: PUSH
112266: LD_INT 2
112268: PUSH
112269: EMPTY
112270: LIST
112271: LIST
112272: PUSH
112273: LD_INT 58
112275: PUSH
112276: EMPTY
112277: LIST
112278: PUSH
112279: EMPTY
112280: LIST
112281: LIST
112282: PPUSH
112283: CALL_OW 72
112287: IN
112288: AND
112289: IFFALSE 112325
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112291: LD_VAR 0 4
112295: PUSH
112296: LD_VAR 0 7
112300: ARRAY
112301: PPUSH
112302: LD_VAR 0 14
112306: PUSH
112307: LD_INT 1
112309: ARRAY
112310: PPUSH
112311: CALL_OW 120
// attacking := true ;
112315: LD_ADDR_VAR 0 29
112319: PUSH
112320: LD_INT 1
112322: ST_TO_ADDR
// continue ;
112323: GO 110498
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112325: LD_VAR 0 26
112329: PUSH
112330: LD_VAR 0 4
112334: PUSH
112335: LD_VAR 0 7
112339: ARRAY
112340: PPUSH
112341: CALL_OW 257
112345: PUSH
112346: LD_INT 1
112348: EQUAL
112349: AND
112350: PUSH
112351: LD_VAR 0 4
112355: PUSH
112356: LD_VAR 0 7
112360: ARRAY
112361: PPUSH
112362: CALL_OW 256
112366: PUSH
112367: LD_INT 800
112369: LESS
112370: AND
112371: PUSH
112372: LD_VAR 0 4
112376: PUSH
112377: LD_VAR 0 7
112381: ARRAY
112382: PPUSH
112383: CALL_OW 318
112387: NOT
112388: AND
112389: IFFALSE 112406
// ComCrawl ( group [ i ] ) ;
112391: LD_VAR 0 4
112395: PUSH
112396: LD_VAR 0 7
112400: ARRAY
112401: PPUSH
112402: CALL_OW 137
// if f_mines then
112406: LD_VAR 0 21
112410: IFFALSE 112653
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112412: LD_VAR 0 14
112416: PUSH
112417: LD_INT 1
112419: ARRAY
112420: PPUSH
112421: CALL_OW 247
112425: PUSH
112426: LD_INT 3
112428: EQUAL
112429: PUSH
112430: LD_VAR 0 14
112434: PUSH
112435: LD_INT 1
112437: ARRAY
112438: PUSH
112439: LD_VAR 0 27
112443: IN
112444: NOT
112445: AND
112446: IFFALSE 112653
// begin x := GetX ( tmp [ 1 ] ) ;
112448: LD_ADDR_VAR 0 10
112452: PUSH
112453: LD_VAR 0 14
112457: PUSH
112458: LD_INT 1
112460: ARRAY
112461: PPUSH
112462: CALL_OW 250
112466: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112467: LD_ADDR_VAR 0 11
112471: PUSH
112472: LD_VAR 0 14
112476: PUSH
112477: LD_INT 1
112479: ARRAY
112480: PPUSH
112481: CALL_OW 251
112485: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112486: LD_ADDR_VAR 0 12
112490: PUSH
112491: LD_VAR 0 4
112495: PUSH
112496: LD_VAR 0 7
112500: ARRAY
112501: PPUSH
112502: CALL 81371 0 1
112506: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112507: LD_VAR 0 4
112511: PUSH
112512: LD_VAR 0 7
112516: ARRAY
112517: PPUSH
112518: LD_VAR 0 10
112522: PPUSH
112523: LD_VAR 0 11
112527: PPUSH
112528: LD_VAR 0 14
112532: PUSH
112533: LD_INT 1
112535: ARRAY
112536: PPUSH
112537: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112541: LD_VAR 0 4
112545: PUSH
112546: LD_VAR 0 7
112550: ARRAY
112551: PPUSH
112552: LD_VAR 0 10
112556: PPUSH
112557: LD_VAR 0 12
112561: PPUSH
112562: LD_INT 7
112564: PPUSH
112565: CALL_OW 272
112569: PPUSH
112570: LD_VAR 0 11
112574: PPUSH
112575: LD_VAR 0 12
112579: PPUSH
112580: LD_INT 7
112582: PPUSH
112583: CALL_OW 273
112587: PPUSH
112588: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112592: LD_VAR 0 4
112596: PUSH
112597: LD_VAR 0 7
112601: ARRAY
112602: PPUSH
112603: LD_INT 71
112605: PPUSH
112606: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112610: LD_ADDR_VAR 0 27
112614: PUSH
112615: LD_VAR 0 27
112619: PPUSH
112620: LD_VAR 0 27
112624: PUSH
112625: LD_INT 1
112627: PLUS
112628: PPUSH
112629: LD_VAR 0 14
112633: PUSH
112634: LD_INT 1
112636: ARRAY
112637: PPUSH
112638: CALL_OW 1
112642: ST_TO_ADDR
// attacking := true ;
112643: LD_ADDR_VAR 0 29
112647: PUSH
112648: LD_INT 1
112650: ST_TO_ADDR
// continue ;
112651: GO 110498
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112653: LD_VAR 0 4
112657: PUSH
112658: LD_VAR 0 7
112662: ARRAY
112663: PPUSH
112664: CALL_OW 257
112668: PUSH
112669: LD_INT 17
112671: EQUAL
112672: PUSH
112673: LD_VAR 0 4
112677: PUSH
112678: LD_VAR 0 7
112682: ARRAY
112683: PPUSH
112684: CALL_OW 110
112688: PUSH
112689: LD_INT 71
112691: EQUAL
112692: NOT
112693: AND
112694: IFFALSE 112840
// begin attacking := false ;
112696: LD_ADDR_VAR 0 29
112700: PUSH
112701: LD_INT 0
112703: ST_TO_ADDR
// k := 5 ;
112704: LD_ADDR_VAR 0 9
112708: PUSH
112709: LD_INT 5
112711: ST_TO_ADDR
// if tmp < k then
112712: LD_VAR 0 14
112716: PUSH
112717: LD_VAR 0 9
112721: LESS
112722: IFFALSE 112734
// k := tmp ;
112724: LD_ADDR_VAR 0 9
112728: PUSH
112729: LD_VAR 0 14
112733: ST_TO_ADDR
// for j = 1 to k do
112734: LD_ADDR_VAR 0 8
112738: PUSH
112739: DOUBLE
112740: LD_INT 1
112742: DEC
112743: ST_TO_ADDR
112744: LD_VAR 0 9
112748: PUSH
112749: FOR_TO
112750: IFFALSE 112838
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112752: LD_VAR 0 14
112756: PUSH
112757: LD_VAR 0 8
112761: ARRAY
112762: PUSH
112763: LD_VAR 0 14
112767: PPUSH
112768: LD_INT 58
112770: PUSH
112771: EMPTY
112772: LIST
112773: PPUSH
112774: CALL_OW 72
112778: IN
112779: NOT
112780: IFFALSE 112836
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112782: LD_VAR 0 4
112786: PUSH
112787: LD_VAR 0 7
112791: ARRAY
112792: PPUSH
112793: LD_VAR 0 14
112797: PUSH
112798: LD_VAR 0 8
112802: ARRAY
112803: PPUSH
112804: CALL_OW 115
// attacking := true ;
112808: LD_ADDR_VAR 0 29
112812: PUSH
112813: LD_INT 1
112815: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112816: LD_VAR 0 4
112820: PUSH
112821: LD_VAR 0 7
112825: ARRAY
112826: PPUSH
112827: LD_INT 71
112829: PPUSH
112830: CALL_OW 109
// continue ;
112834: GO 112749
// end ; end ;
112836: GO 112749
112838: POP
112839: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112840: LD_VAR 0 4
112844: PUSH
112845: LD_VAR 0 7
112849: ARRAY
112850: PPUSH
112851: CALL_OW 257
112855: PUSH
112856: LD_INT 8
112858: EQUAL
112859: PUSH
112860: LD_VAR 0 4
112864: PUSH
112865: LD_VAR 0 7
112869: ARRAY
112870: PPUSH
112871: CALL_OW 264
112875: PUSH
112876: LD_INT 28
112878: PUSH
112879: LD_INT 45
112881: PUSH
112882: LD_INT 7
112884: PUSH
112885: LD_INT 47
112887: PUSH
112888: EMPTY
112889: LIST
112890: LIST
112891: LIST
112892: LIST
112893: IN
112894: OR
112895: IFFALSE 113151
// begin attacking := false ;
112897: LD_ADDR_VAR 0 29
112901: PUSH
112902: LD_INT 0
112904: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112905: LD_VAR 0 14
112909: PUSH
112910: LD_INT 1
112912: ARRAY
112913: PPUSH
112914: CALL_OW 266
112918: PUSH
112919: LD_INT 32
112921: PUSH
112922: LD_INT 31
112924: PUSH
112925: LD_INT 33
112927: PUSH
112928: LD_INT 4
112930: PUSH
112931: LD_INT 5
112933: PUSH
112934: EMPTY
112935: LIST
112936: LIST
112937: LIST
112938: LIST
112939: LIST
112940: IN
112941: IFFALSE 113127
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112943: LD_ADDR_VAR 0 9
112947: PUSH
112948: LD_VAR 0 14
112952: PUSH
112953: LD_INT 1
112955: ARRAY
112956: PPUSH
112957: CALL_OW 266
112961: PPUSH
112962: LD_VAR 0 14
112966: PUSH
112967: LD_INT 1
112969: ARRAY
112970: PPUSH
112971: CALL_OW 250
112975: PPUSH
112976: LD_VAR 0 14
112980: PUSH
112981: LD_INT 1
112983: ARRAY
112984: PPUSH
112985: CALL_OW 251
112989: PPUSH
112990: LD_VAR 0 14
112994: PUSH
112995: LD_INT 1
112997: ARRAY
112998: PPUSH
112999: CALL_OW 254
113003: PPUSH
113004: LD_VAR 0 14
113008: PUSH
113009: LD_INT 1
113011: ARRAY
113012: PPUSH
113013: CALL_OW 248
113017: PPUSH
113018: LD_INT 0
113020: PPUSH
113021: CALL 62741 0 6
113025: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113026: LD_ADDR_VAR 0 8
113030: PUSH
113031: LD_VAR 0 4
113035: PUSH
113036: LD_VAR 0 7
113040: ARRAY
113041: PPUSH
113042: LD_VAR 0 9
113046: PPUSH
113047: CALL 81484 0 2
113051: ST_TO_ADDR
// if j then
113052: LD_VAR 0 8
113056: IFFALSE 113125
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113058: LD_VAR 0 8
113062: PUSH
113063: LD_INT 1
113065: ARRAY
113066: PPUSH
113067: LD_VAR 0 8
113071: PUSH
113072: LD_INT 2
113074: ARRAY
113075: PPUSH
113076: CALL_OW 488
113080: IFFALSE 113125
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113082: LD_VAR 0 4
113086: PUSH
113087: LD_VAR 0 7
113091: ARRAY
113092: PPUSH
113093: LD_VAR 0 8
113097: PUSH
113098: LD_INT 1
113100: ARRAY
113101: PPUSH
113102: LD_VAR 0 8
113106: PUSH
113107: LD_INT 2
113109: ARRAY
113110: PPUSH
113111: CALL_OW 116
// attacking := true ;
113115: LD_ADDR_VAR 0 29
113119: PUSH
113120: LD_INT 1
113122: ST_TO_ADDR
// continue ;
113123: GO 110498
// end ; end else
113125: GO 113151
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113127: LD_VAR 0 4
113131: PUSH
113132: LD_VAR 0 7
113136: ARRAY
113137: PPUSH
113138: LD_VAR 0 14
113142: PUSH
113143: LD_INT 1
113145: ARRAY
113146: PPUSH
113147: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113151: LD_VAR 0 4
113155: PUSH
113156: LD_VAR 0 7
113160: ARRAY
113161: PPUSH
113162: CALL_OW 265
113166: PUSH
113167: LD_INT 11
113169: EQUAL
113170: IFFALSE 113448
// begin k := 10 ;
113172: LD_ADDR_VAR 0 9
113176: PUSH
113177: LD_INT 10
113179: ST_TO_ADDR
// x := 0 ;
113180: LD_ADDR_VAR 0 10
113184: PUSH
113185: LD_INT 0
113187: ST_TO_ADDR
// if tmp < k then
113188: LD_VAR 0 14
113192: PUSH
113193: LD_VAR 0 9
113197: LESS
113198: IFFALSE 113210
// k := tmp ;
113200: LD_ADDR_VAR 0 9
113204: PUSH
113205: LD_VAR 0 14
113209: ST_TO_ADDR
// for j = k downto 1 do
113210: LD_ADDR_VAR 0 8
113214: PUSH
113215: DOUBLE
113216: LD_VAR 0 9
113220: INC
113221: ST_TO_ADDR
113222: LD_INT 1
113224: PUSH
113225: FOR_DOWNTO
113226: IFFALSE 113301
// begin if GetType ( tmp [ j ] ) = unit_human then
113228: LD_VAR 0 14
113232: PUSH
113233: LD_VAR 0 8
113237: ARRAY
113238: PPUSH
113239: CALL_OW 247
113243: PUSH
113244: LD_INT 1
113246: EQUAL
113247: IFFALSE 113299
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113249: LD_VAR 0 4
113253: PUSH
113254: LD_VAR 0 7
113258: ARRAY
113259: PPUSH
113260: LD_VAR 0 14
113264: PUSH
113265: LD_VAR 0 8
113269: ARRAY
113270: PPUSH
113271: CALL 81738 0 2
// x := tmp [ j ] ;
113275: LD_ADDR_VAR 0 10
113279: PUSH
113280: LD_VAR 0 14
113284: PUSH
113285: LD_VAR 0 8
113289: ARRAY
113290: ST_TO_ADDR
// attacking := true ;
113291: LD_ADDR_VAR 0 29
113295: PUSH
113296: LD_INT 1
113298: ST_TO_ADDR
// end ; end ;
113299: GO 113225
113301: POP
113302: POP
// if not x then
113303: LD_VAR 0 10
113307: NOT
113308: IFFALSE 113448
// begin attacking := true ;
113310: LD_ADDR_VAR 0 29
113314: PUSH
113315: LD_INT 1
113317: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113318: LD_VAR 0 4
113322: PUSH
113323: LD_VAR 0 7
113327: ARRAY
113328: PPUSH
113329: CALL_OW 250
113333: PPUSH
113334: LD_VAR 0 4
113338: PUSH
113339: LD_VAR 0 7
113343: ARRAY
113344: PPUSH
113345: CALL_OW 251
113349: PPUSH
113350: CALL_OW 546
113354: PUSH
113355: LD_INT 2
113357: ARRAY
113358: PUSH
113359: LD_VAR 0 14
113363: PUSH
113364: LD_INT 1
113366: ARRAY
113367: PPUSH
113368: CALL_OW 250
113372: PPUSH
113373: LD_VAR 0 14
113377: PUSH
113378: LD_INT 1
113380: ARRAY
113381: PPUSH
113382: CALL_OW 251
113386: PPUSH
113387: CALL_OW 546
113391: PUSH
113392: LD_INT 2
113394: ARRAY
113395: EQUAL
113396: IFFALSE 113424
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113398: LD_VAR 0 4
113402: PUSH
113403: LD_VAR 0 7
113407: ARRAY
113408: PPUSH
113409: LD_VAR 0 14
113413: PUSH
113414: LD_INT 1
113416: ARRAY
113417: PPUSH
113418: CALL 81738 0 2
113422: GO 113448
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113424: LD_VAR 0 4
113428: PUSH
113429: LD_VAR 0 7
113433: ARRAY
113434: PPUSH
113435: LD_VAR 0 14
113439: PUSH
113440: LD_INT 1
113442: ARRAY
113443: PPUSH
113444: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113448: LD_VAR 0 4
113452: PUSH
113453: LD_VAR 0 7
113457: ARRAY
113458: PPUSH
113459: CALL_OW 264
113463: PUSH
113464: LD_INT 29
113466: EQUAL
113467: IFFALSE 113833
// begin if WantsToAttack ( group [ i ] ) in bombed then
113469: LD_VAR 0 4
113473: PUSH
113474: LD_VAR 0 7
113478: ARRAY
113479: PPUSH
113480: CALL_OW 319
113484: PUSH
113485: LD_VAR 0 28
113489: IN
113490: IFFALSE 113494
// continue ;
113492: GO 110498
// k := 8 ;
113494: LD_ADDR_VAR 0 9
113498: PUSH
113499: LD_INT 8
113501: ST_TO_ADDR
// x := 0 ;
113502: LD_ADDR_VAR 0 10
113506: PUSH
113507: LD_INT 0
113509: ST_TO_ADDR
// if tmp < k then
113510: LD_VAR 0 14
113514: PUSH
113515: LD_VAR 0 9
113519: LESS
113520: IFFALSE 113532
// k := tmp ;
113522: LD_ADDR_VAR 0 9
113526: PUSH
113527: LD_VAR 0 14
113531: ST_TO_ADDR
// for j = 1 to k do
113532: LD_ADDR_VAR 0 8
113536: PUSH
113537: DOUBLE
113538: LD_INT 1
113540: DEC
113541: ST_TO_ADDR
113542: LD_VAR 0 9
113546: PUSH
113547: FOR_TO
113548: IFFALSE 113680
// begin if GetType ( tmp [ j ] ) = unit_building then
113550: LD_VAR 0 14
113554: PUSH
113555: LD_VAR 0 8
113559: ARRAY
113560: PPUSH
113561: CALL_OW 247
113565: PUSH
113566: LD_INT 3
113568: EQUAL
113569: IFFALSE 113678
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113571: LD_VAR 0 14
113575: PUSH
113576: LD_VAR 0 8
113580: ARRAY
113581: PUSH
113582: LD_VAR 0 28
113586: IN
113587: NOT
113588: PUSH
113589: LD_VAR 0 14
113593: PUSH
113594: LD_VAR 0 8
113598: ARRAY
113599: PPUSH
113600: CALL_OW 313
113604: AND
113605: IFFALSE 113678
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113607: LD_VAR 0 4
113611: PUSH
113612: LD_VAR 0 7
113616: ARRAY
113617: PPUSH
113618: LD_VAR 0 14
113622: PUSH
113623: LD_VAR 0 8
113627: ARRAY
113628: PPUSH
113629: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113633: LD_ADDR_VAR 0 28
113637: PUSH
113638: LD_VAR 0 28
113642: PPUSH
113643: LD_VAR 0 28
113647: PUSH
113648: LD_INT 1
113650: PLUS
113651: PPUSH
113652: LD_VAR 0 14
113656: PUSH
113657: LD_VAR 0 8
113661: ARRAY
113662: PPUSH
113663: CALL_OW 1
113667: ST_TO_ADDR
// attacking := true ;
113668: LD_ADDR_VAR 0 29
113672: PUSH
113673: LD_INT 1
113675: ST_TO_ADDR
// break ;
113676: GO 113680
// end ; end ;
113678: GO 113547
113680: POP
113681: POP
// if not attacking and f_attack_depot then
113682: LD_VAR 0 29
113686: NOT
113687: PUSH
113688: LD_VAR 0 25
113692: AND
113693: IFFALSE 113788
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113695: LD_ADDR_VAR 0 13
113699: PUSH
113700: LD_VAR 0 14
113704: PPUSH
113705: LD_INT 2
113707: PUSH
113708: LD_INT 30
113710: PUSH
113711: LD_INT 0
113713: PUSH
113714: EMPTY
113715: LIST
113716: LIST
113717: PUSH
113718: LD_INT 30
113720: PUSH
113721: LD_INT 1
113723: PUSH
113724: EMPTY
113725: LIST
113726: LIST
113727: PUSH
113728: EMPTY
113729: LIST
113730: LIST
113731: LIST
113732: PPUSH
113733: CALL_OW 72
113737: ST_TO_ADDR
// if z then
113738: LD_VAR 0 13
113742: IFFALSE 113788
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113744: LD_VAR 0 4
113748: PUSH
113749: LD_VAR 0 7
113753: ARRAY
113754: PPUSH
113755: LD_VAR 0 13
113759: PPUSH
113760: LD_VAR 0 4
113764: PUSH
113765: LD_VAR 0 7
113769: ARRAY
113770: PPUSH
113771: CALL_OW 74
113775: PPUSH
113776: CALL_OW 115
// attacking := true ;
113780: LD_ADDR_VAR 0 29
113784: PUSH
113785: LD_INT 1
113787: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113788: LD_VAR 0 4
113792: PUSH
113793: LD_VAR 0 7
113797: ARRAY
113798: PPUSH
113799: CALL_OW 256
113803: PUSH
113804: LD_INT 500
113806: LESS
113807: IFFALSE 113833
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113809: LD_VAR 0 4
113813: PUSH
113814: LD_VAR 0 7
113818: ARRAY
113819: PPUSH
113820: LD_VAR 0 14
113824: PUSH
113825: LD_INT 1
113827: ARRAY
113828: PPUSH
113829: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113833: LD_VAR 0 4
113837: PUSH
113838: LD_VAR 0 7
113842: ARRAY
113843: PPUSH
113844: CALL_OW 264
113848: PUSH
113849: LD_INT 49
113851: EQUAL
113852: IFFALSE 113973
// begin if not HasTask ( group [ i ] ) then
113854: LD_VAR 0 4
113858: PUSH
113859: LD_VAR 0 7
113863: ARRAY
113864: PPUSH
113865: CALL_OW 314
113869: NOT
113870: IFFALSE 113973
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113872: LD_ADDR_VAR 0 9
113876: PUSH
113877: LD_INT 81
113879: PUSH
113880: LD_VAR 0 4
113884: PUSH
113885: LD_VAR 0 7
113889: ARRAY
113890: PPUSH
113891: CALL_OW 255
113895: PUSH
113896: EMPTY
113897: LIST
113898: LIST
113899: PPUSH
113900: CALL_OW 69
113904: PPUSH
113905: LD_VAR 0 4
113909: PUSH
113910: LD_VAR 0 7
113914: ARRAY
113915: PPUSH
113916: CALL_OW 74
113920: ST_TO_ADDR
// if k then
113921: LD_VAR 0 9
113925: IFFALSE 113973
// if GetDistUnits ( group [ i ] , k ) > 10 then
113927: LD_VAR 0 4
113931: PUSH
113932: LD_VAR 0 7
113936: ARRAY
113937: PPUSH
113938: LD_VAR 0 9
113942: PPUSH
113943: CALL_OW 296
113947: PUSH
113948: LD_INT 10
113950: GREATER
113951: IFFALSE 113973
// ComMoveUnit ( group [ i ] , k ) ;
113953: LD_VAR 0 4
113957: PUSH
113958: LD_VAR 0 7
113962: ARRAY
113963: PPUSH
113964: LD_VAR 0 9
113968: PPUSH
113969: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113973: LD_VAR 0 4
113977: PUSH
113978: LD_VAR 0 7
113982: ARRAY
113983: PPUSH
113984: CALL_OW 256
113988: PUSH
113989: LD_INT 250
113991: LESS
113992: PUSH
113993: LD_VAR 0 4
113997: PUSH
113998: LD_VAR 0 7
114002: ARRAY
114003: PUSH
114004: LD_INT 21
114006: PUSH
114007: LD_INT 2
114009: PUSH
114010: EMPTY
114011: LIST
114012: LIST
114013: PUSH
114014: LD_INT 23
114016: PUSH
114017: LD_INT 2
114019: PUSH
114020: EMPTY
114021: LIST
114022: LIST
114023: PUSH
114024: EMPTY
114025: LIST
114026: LIST
114027: PPUSH
114028: CALL_OW 69
114032: IN
114033: AND
114034: IFFALSE 114159
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114036: LD_ADDR_VAR 0 9
114040: PUSH
114041: LD_OWVAR 3
114045: PUSH
114046: LD_VAR 0 4
114050: PUSH
114051: LD_VAR 0 7
114055: ARRAY
114056: DIFF
114057: PPUSH
114058: LD_VAR 0 4
114062: PUSH
114063: LD_VAR 0 7
114067: ARRAY
114068: PPUSH
114069: CALL_OW 74
114073: ST_TO_ADDR
// if not k then
114074: LD_VAR 0 9
114078: NOT
114079: IFFALSE 114083
// continue ;
114081: GO 110498
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114083: LD_VAR 0 9
114087: PUSH
114088: LD_INT 81
114090: PUSH
114091: LD_VAR 0 4
114095: PUSH
114096: LD_VAR 0 7
114100: ARRAY
114101: PPUSH
114102: CALL_OW 255
114106: PUSH
114107: EMPTY
114108: LIST
114109: LIST
114110: PPUSH
114111: CALL_OW 69
114115: IN
114116: PUSH
114117: LD_VAR 0 9
114121: PPUSH
114122: LD_VAR 0 4
114126: PUSH
114127: LD_VAR 0 7
114131: ARRAY
114132: PPUSH
114133: CALL_OW 296
114137: PUSH
114138: LD_INT 5
114140: LESS
114141: AND
114142: IFFALSE 114159
// ComAutodestruct ( group [ i ] ) ;
114144: LD_VAR 0 4
114148: PUSH
114149: LD_VAR 0 7
114153: ARRAY
114154: PPUSH
114155: CALL 81636 0 1
// end ; if f_attack_depot then
114159: LD_VAR 0 25
114163: IFFALSE 114275
// begin k := 6 ;
114165: LD_ADDR_VAR 0 9
114169: PUSH
114170: LD_INT 6
114172: ST_TO_ADDR
// if tmp < k then
114173: LD_VAR 0 14
114177: PUSH
114178: LD_VAR 0 9
114182: LESS
114183: IFFALSE 114195
// k := tmp ;
114185: LD_ADDR_VAR 0 9
114189: PUSH
114190: LD_VAR 0 14
114194: ST_TO_ADDR
// for j = 1 to k do
114195: LD_ADDR_VAR 0 8
114199: PUSH
114200: DOUBLE
114201: LD_INT 1
114203: DEC
114204: ST_TO_ADDR
114205: LD_VAR 0 9
114209: PUSH
114210: FOR_TO
114211: IFFALSE 114273
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114213: LD_VAR 0 8
114217: PPUSH
114218: CALL_OW 266
114222: PUSH
114223: LD_INT 0
114225: PUSH
114226: LD_INT 1
114228: PUSH
114229: EMPTY
114230: LIST
114231: LIST
114232: IN
114233: IFFALSE 114271
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114235: LD_VAR 0 4
114239: PUSH
114240: LD_VAR 0 7
114244: ARRAY
114245: PPUSH
114246: LD_VAR 0 14
114250: PUSH
114251: LD_VAR 0 8
114255: ARRAY
114256: PPUSH
114257: CALL_OW 115
// attacking := true ;
114261: LD_ADDR_VAR 0 29
114265: PUSH
114266: LD_INT 1
114268: ST_TO_ADDR
// break ;
114269: GO 114273
// end ;
114271: GO 114210
114273: POP
114274: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114275: LD_VAR 0 4
114279: PUSH
114280: LD_VAR 0 7
114284: ARRAY
114285: PPUSH
114286: CALL_OW 302
114290: PUSH
114291: LD_VAR 0 29
114295: NOT
114296: AND
114297: IFFALSE 114619
// begin if GetTag ( group [ i ] ) = 71 then
114299: LD_VAR 0 4
114303: PUSH
114304: LD_VAR 0 7
114308: ARRAY
114309: PPUSH
114310: CALL_OW 110
114314: PUSH
114315: LD_INT 71
114317: EQUAL
114318: IFFALSE 114359
// begin if HasTask ( group [ i ] ) then
114320: LD_VAR 0 4
114324: PUSH
114325: LD_VAR 0 7
114329: ARRAY
114330: PPUSH
114331: CALL_OW 314
114335: IFFALSE 114341
// continue else
114337: GO 110498
114339: GO 114359
// SetTag ( group [ i ] , 0 ) ;
114341: LD_VAR 0 4
114345: PUSH
114346: LD_VAR 0 7
114350: ARRAY
114351: PPUSH
114352: LD_INT 0
114354: PPUSH
114355: CALL_OW 109
// end ; k := 8 ;
114359: LD_ADDR_VAR 0 9
114363: PUSH
114364: LD_INT 8
114366: ST_TO_ADDR
// x := 0 ;
114367: LD_ADDR_VAR 0 10
114371: PUSH
114372: LD_INT 0
114374: ST_TO_ADDR
// if tmp < k then
114375: LD_VAR 0 14
114379: PUSH
114380: LD_VAR 0 9
114384: LESS
114385: IFFALSE 114397
// k := tmp ;
114387: LD_ADDR_VAR 0 9
114391: PUSH
114392: LD_VAR 0 14
114396: ST_TO_ADDR
// for j = 1 to k do
114397: LD_ADDR_VAR 0 8
114401: PUSH
114402: DOUBLE
114403: LD_INT 1
114405: DEC
114406: ST_TO_ADDR
114407: LD_VAR 0 9
114411: PUSH
114412: FOR_TO
114413: IFFALSE 114511
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114415: LD_VAR 0 14
114419: PUSH
114420: LD_VAR 0 8
114424: ARRAY
114425: PPUSH
114426: CALL_OW 247
114430: PUSH
114431: LD_INT 1
114433: EQUAL
114434: PUSH
114435: LD_VAR 0 14
114439: PUSH
114440: LD_VAR 0 8
114444: ARRAY
114445: PPUSH
114446: CALL_OW 256
114450: PUSH
114451: LD_INT 250
114453: LESS
114454: PUSH
114455: LD_VAR 0 20
114459: AND
114460: PUSH
114461: LD_VAR 0 20
114465: NOT
114466: PUSH
114467: LD_VAR 0 14
114471: PUSH
114472: LD_VAR 0 8
114476: ARRAY
114477: PPUSH
114478: CALL_OW 256
114482: PUSH
114483: LD_INT 250
114485: GREATEREQUAL
114486: AND
114487: OR
114488: AND
114489: IFFALSE 114509
// begin x := tmp [ j ] ;
114491: LD_ADDR_VAR 0 10
114495: PUSH
114496: LD_VAR 0 14
114500: PUSH
114501: LD_VAR 0 8
114505: ARRAY
114506: ST_TO_ADDR
// break ;
114507: GO 114511
// end ;
114509: GO 114412
114511: POP
114512: POP
// if x then
114513: LD_VAR 0 10
114517: IFFALSE 114541
// ComAttackUnit ( group [ i ] , x ) else
114519: LD_VAR 0 4
114523: PUSH
114524: LD_VAR 0 7
114528: ARRAY
114529: PPUSH
114530: LD_VAR 0 10
114534: PPUSH
114535: CALL_OW 115
114539: GO 114565
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114541: LD_VAR 0 4
114545: PUSH
114546: LD_VAR 0 7
114550: ARRAY
114551: PPUSH
114552: LD_VAR 0 14
114556: PUSH
114557: LD_INT 1
114559: ARRAY
114560: PPUSH
114561: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114565: LD_VAR 0 4
114569: PUSH
114570: LD_VAR 0 7
114574: ARRAY
114575: PPUSH
114576: CALL_OW 314
114580: NOT
114581: IFFALSE 114619
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114583: LD_VAR 0 4
114587: PUSH
114588: LD_VAR 0 7
114592: ARRAY
114593: PPUSH
114594: LD_VAR 0 14
114598: PPUSH
114599: LD_VAR 0 4
114603: PUSH
114604: LD_VAR 0 7
114608: ARRAY
114609: PPUSH
114610: CALL_OW 74
114614: PPUSH
114615: CALL_OW 115
// end ; end ; end ;
114619: GO 110498
114621: POP
114622: POP
// wait ( 0 0$2 ) ;
114623: LD_INT 70
114625: PPUSH
114626: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114630: LD_VAR 0 4
114634: NOT
114635: PUSH
114636: LD_VAR 0 4
114640: PUSH
114641: EMPTY
114642: EQUAL
114643: OR
114644: PUSH
114645: LD_INT 81
114647: PUSH
114648: LD_VAR 0 35
114652: PUSH
114653: EMPTY
114654: LIST
114655: LIST
114656: PPUSH
114657: CALL_OW 69
114661: NOT
114662: OR
114663: IFFALSE 110483
// end ;
114665: LD_VAR 0 2
114669: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114670: LD_INT 0
114672: PPUSH
114673: PPUSH
114674: PPUSH
114675: PPUSH
114676: PPUSH
114677: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114678: LD_VAR 0 1
114682: NOT
114683: PUSH
114684: LD_EXP 50
114688: PUSH
114689: LD_VAR 0 1
114693: ARRAY
114694: NOT
114695: OR
114696: PUSH
114697: LD_VAR 0 2
114701: NOT
114702: OR
114703: IFFALSE 114707
// exit ;
114705: GO 115261
// side := mc_sides [ base ] ;
114707: LD_ADDR_VAR 0 6
114711: PUSH
114712: LD_EXP 76
114716: PUSH
114717: LD_VAR 0 1
114721: ARRAY
114722: ST_TO_ADDR
// if not side then
114723: LD_VAR 0 6
114727: NOT
114728: IFFALSE 114732
// exit ;
114730: GO 115261
// for i in solds do
114732: LD_ADDR_VAR 0 7
114736: PUSH
114737: LD_VAR 0 2
114741: PUSH
114742: FOR_IN
114743: IFFALSE 114804
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114745: LD_VAR 0 7
114749: PPUSH
114750: CALL_OW 310
114754: PPUSH
114755: CALL_OW 266
114759: PUSH
114760: LD_INT 32
114762: PUSH
114763: LD_INT 31
114765: PUSH
114766: EMPTY
114767: LIST
114768: LIST
114769: IN
114770: IFFALSE 114790
// solds := solds diff i else
114772: LD_ADDR_VAR 0 2
114776: PUSH
114777: LD_VAR 0 2
114781: PUSH
114782: LD_VAR 0 7
114786: DIFF
114787: ST_TO_ADDR
114788: GO 114802
// SetTag ( i , 18 ) ;
114790: LD_VAR 0 7
114794: PPUSH
114795: LD_INT 18
114797: PPUSH
114798: CALL_OW 109
114802: GO 114742
114804: POP
114805: POP
// if not solds then
114806: LD_VAR 0 2
114810: NOT
114811: IFFALSE 114815
// exit ;
114813: GO 115261
// repeat wait ( 0 0$2 ) ;
114815: LD_INT 70
114817: PPUSH
114818: CALL_OW 67
// enemy := mc_scan [ base ] ;
114822: LD_ADDR_VAR 0 4
114826: PUSH
114827: LD_EXP 73
114831: PUSH
114832: LD_VAR 0 1
114836: ARRAY
114837: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114838: LD_EXP 50
114842: PUSH
114843: LD_VAR 0 1
114847: ARRAY
114848: NOT
114849: PUSH
114850: LD_EXP 50
114854: PUSH
114855: LD_VAR 0 1
114859: ARRAY
114860: PUSH
114861: EMPTY
114862: EQUAL
114863: OR
114864: IFFALSE 114901
// begin for i in solds do
114866: LD_ADDR_VAR 0 7
114870: PUSH
114871: LD_VAR 0 2
114875: PUSH
114876: FOR_IN
114877: IFFALSE 114890
// ComStop ( i ) ;
114879: LD_VAR 0 7
114883: PPUSH
114884: CALL_OW 141
114888: GO 114876
114890: POP
114891: POP
// solds := [ ] ;
114892: LD_ADDR_VAR 0 2
114896: PUSH
114897: EMPTY
114898: ST_TO_ADDR
// exit ;
114899: GO 115261
// end ; for i in solds do
114901: LD_ADDR_VAR 0 7
114905: PUSH
114906: LD_VAR 0 2
114910: PUSH
114911: FOR_IN
114912: IFFALSE 115233
// begin if IsInUnit ( i ) then
114914: LD_VAR 0 7
114918: PPUSH
114919: CALL_OW 310
114923: IFFALSE 114934
// ComExitBuilding ( i ) ;
114925: LD_VAR 0 7
114929: PPUSH
114930: CALL_OW 122
// if GetLives ( i ) > 500 then
114934: LD_VAR 0 7
114938: PPUSH
114939: CALL_OW 256
114943: PUSH
114944: LD_INT 500
114946: GREATER
114947: IFFALSE 115000
// begin e := NearestUnitToUnit ( enemy , i ) ;
114949: LD_ADDR_VAR 0 5
114953: PUSH
114954: LD_VAR 0 4
114958: PPUSH
114959: LD_VAR 0 7
114963: PPUSH
114964: CALL_OW 74
114968: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114969: LD_VAR 0 7
114973: PPUSH
114974: LD_VAR 0 5
114978: PPUSH
114979: CALL_OW 250
114983: PPUSH
114984: LD_VAR 0 5
114988: PPUSH
114989: CALL_OW 251
114993: PPUSH
114994: CALL_OW 114
// end else
114998: GO 115231
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115000: LD_VAR 0 7
115004: PPUSH
115005: LD_EXP 50
115009: PUSH
115010: LD_VAR 0 1
115014: ARRAY
115015: PPUSH
115016: LD_INT 2
115018: PUSH
115019: LD_INT 30
115021: PUSH
115022: LD_INT 0
115024: PUSH
115025: EMPTY
115026: LIST
115027: LIST
115028: PUSH
115029: LD_INT 30
115031: PUSH
115032: LD_INT 1
115034: PUSH
115035: EMPTY
115036: LIST
115037: LIST
115038: PUSH
115039: LD_INT 30
115041: PUSH
115042: LD_INT 6
115044: PUSH
115045: EMPTY
115046: LIST
115047: LIST
115048: PUSH
115049: EMPTY
115050: LIST
115051: LIST
115052: LIST
115053: LIST
115054: PPUSH
115055: CALL_OW 72
115059: PPUSH
115060: LD_VAR 0 7
115064: PPUSH
115065: CALL_OW 74
115069: PPUSH
115070: CALL_OW 296
115074: PUSH
115075: LD_INT 10
115077: GREATER
115078: IFFALSE 115231
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115080: LD_ADDR_VAR 0 8
115084: PUSH
115085: LD_EXP 50
115089: PUSH
115090: LD_VAR 0 1
115094: ARRAY
115095: PPUSH
115096: LD_INT 2
115098: PUSH
115099: LD_INT 30
115101: PUSH
115102: LD_INT 0
115104: PUSH
115105: EMPTY
115106: LIST
115107: LIST
115108: PUSH
115109: LD_INT 30
115111: PUSH
115112: LD_INT 1
115114: PUSH
115115: EMPTY
115116: LIST
115117: LIST
115118: PUSH
115119: LD_INT 30
115121: PUSH
115122: LD_INT 6
115124: PUSH
115125: EMPTY
115126: LIST
115127: LIST
115128: PUSH
115129: EMPTY
115130: LIST
115131: LIST
115132: LIST
115133: LIST
115134: PPUSH
115135: CALL_OW 72
115139: PPUSH
115140: LD_VAR 0 7
115144: PPUSH
115145: CALL_OW 74
115149: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115150: LD_VAR 0 7
115154: PPUSH
115155: LD_VAR 0 8
115159: PPUSH
115160: CALL_OW 250
115164: PPUSH
115165: LD_INT 3
115167: PPUSH
115168: LD_INT 5
115170: PPUSH
115171: CALL_OW 272
115175: PPUSH
115176: LD_VAR 0 8
115180: PPUSH
115181: CALL_OW 251
115185: PPUSH
115186: LD_INT 3
115188: PPUSH
115189: LD_INT 5
115191: PPUSH
115192: CALL_OW 273
115196: PPUSH
115197: CALL_OW 111
// SetTag ( i , 0 ) ;
115201: LD_VAR 0 7
115205: PPUSH
115206: LD_INT 0
115208: PPUSH
115209: CALL_OW 109
// solds := solds diff i ;
115213: LD_ADDR_VAR 0 2
115217: PUSH
115218: LD_VAR 0 2
115222: PUSH
115223: LD_VAR 0 7
115227: DIFF
115228: ST_TO_ADDR
// continue ;
115229: GO 114911
// end ; end ;
115231: GO 114911
115233: POP
115234: POP
// until not solds or not enemy ;
115235: LD_VAR 0 2
115239: NOT
115240: PUSH
115241: LD_VAR 0 4
115245: NOT
115246: OR
115247: IFFALSE 114815
// MC_Reset ( base , 18 ) ;
115249: LD_VAR 0 1
115253: PPUSH
115254: LD_INT 18
115256: PPUSH
115257: CALL 22152 0 2
// end ;
115261: LD_VAR 0 3
115265: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115266: LD_INT 0
115268: PPUSH
115269: PPUSH
115270: PPUSH
115271: PPUSH
115272: PPUSH
115273: PPUSH
115274: PPUSH
115275: PPUSH
115276: PPUSH
115277: PPUSH
115278: PPUSH
115279: PPUSH
115280: PPUSH
115281: PPUSH
115282: PPUSH
115283: PPUSH
115284: PPUSH
115285: PPUSH
115286: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115287: LD_ADDR_VAR 0 12
115291: PUSH
115292: LD_EXP 50
115296: PUSH
115297: LD_VAR 0 1
115301: ARRAY
115302: PPUSH
115303: LD_INT 25
115305: PUSH
115306: LD_INT 3
115308: PUSH
115309: EMPTY
115310: LIST
115311: LIST
115312: PPUSH
115313: CALL_OW 72
115317: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115318: LD_EXP 90
115322: PUSH
115323: LD_VAR 0 1
115327: ARRAY
115328: IFFALSE 115352
// mechs := mechs diff mc_remote_driver [ base ] ;
115330: LD_ADDR_VAR 0 12
115334: PUSH
115335: LD_VAR 0 12
115339: PUSH
115340: LD_EXP 90
115344: PUSH
115345: LD_VAR 0 1
115349: ARRAY
115350: DIFF
115351: ST_TO_ADDR
// for i in mechs do
115352: LD_ADDR_VAR 0 4
115356: PUSH
115357: LD_VAR 0 12
115361: PUSH
115362: FOR_IN
115363: IFFALSE 115398
// if GetTag ( i ) > 0 then
115365: LD_VAR 0 4
115369: PPUSH
115370: CALL_OW 110
115374: PUSH
115375: LD_INT 0
115377: GREATER
115378: IFFALSE 115396
// mechs := mechs diff i ;
115380: LD_ADDR_VAR 0 12
115384: PUSH
115385: LD_VAR 0 12
115389: PUSH
115390: LD_VAR 0 4
115394: DIFF
115395: ST_TO_ADDR
115396: GO 115362
115398: POP
115399: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115400: LD_ADDR_VAR 0 8
115404: PUSH
115405: LD_EXP 50
115409: PUSH
115410: LD_VAR 0 1
115414: ARRAY
115415: PPUSH
115416: LD_INT 2
115418: PUSH
115419: LD_INT 25
115421: PUSH
115422: LD_INT 1
115424: PUSH
115425: EMPTY
115426: LIST
115427: LIST
115428: PUSH
115429: LD_INT 25
115431: PUSH
115432: LD_INT 5
115434: PUSH
115435: EMPTY
115436: LIST
115437: LIST
115438: PUSH
115439: LD_INT 25
115441: PUSH
115442: LD_INT 8
115444: PUSH
115445: EMPTY
115446: LIST
115447: LIST
115448: PUSH
115449: LD_INT 25
115451: PUSH
115452: LD_INT 9
115454: PUSH
115455: EMPTY
115456: LIST
115457: LIST
115458: PUSH
115459: EMPTY
115460: LIST
115461: LIST
115462: LIST
115463: LIST
115464: LIST
115465: PPUSH
115466: CALL_OW 72
115470: ST_TO_ADDR
// if not defenders and not solds then
115471: LD_VAR 0 2
115475: NOT
115476: PUSH
115477: LD_VAR 0 8
115481: NOT
115482: AND
115483: IFFALSE 115487
// exit ;
115485: GO 117257
// depot_under_attack := false ;
115487: LD_ADDR_VAR 0 16
115491: PUSH
115492: LD_INT 0
115494: ST_TO_ADDR
// sold_defenders := [ ] ;
115495: LD_ADDR_VAR 0 17
115499: PUSH
115500: EMPTY
115501: ST_TO_ADDR
// if mechs then
115502: LD_VAR 0 12
115506: IFFALSE 115659
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115508: LD_ADDR_VAR 0 4
115512: PUSH
115513: LD_VAR 0 2
115517: PPUSH
115518: LD_INT 21
115520: PUSH
115521: LD_INT 2
115523: PUSH
115524: EMPTY
115525: LIST
115526: LIST
115527: PPUSH
115528: CALL_OW 72
115532: PUSH
115533: FOR_IN
115534: IFFALSE 115657
// begin if GetTag ( i ) <> 20 then
115536: LD_VAR 0 4
115540: PPUSH
115541: CALL_OW 110
115545: PUSH
115546: LD_INT 20
115548: NONEQUAL
115549: IFFALSE 115563
// SetTag ( i , 20 ) ;
115551: LD_VAR 0 4
115555: PPUSH
115556: LD_INT 20
115558: PPUSH
115559: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115563: LD_VAR 0 4
115567: PPUSH
115568: CALL_OW 263
115572: PUSH
115573: LD_INT 1
115575: EQUAL
115576: PUSH
115577: LD_VAR 0 4
115581: PPUSH
115582: CALL_OW 311
115586: NOT
115587: AND
115588: IFFALSE 115655
// begin un := mechs [ 1 ] ;
115590: LD_ADDR_VAR 0 10
115594: PUSH
115595: LD_VAR 0 12
115599: PUSH
115600: LD_INT 1
115602: ARRAY
115603: ST_TO_ADDR
// ComExit ( un ) ;
115604: LD_VAR 0 10
115608: PPUSH
115609: CALL 86502 0 1
// AddComEnterUnit ( un , i ) ;
115613: LD_VAR 0 10
115617: PPUSH
115618: LD_VAR 0 4
115622: PPUSH
115623: CALL_OW 180
// SetTag ( un , 19 ) ;
115627: LD_VAR 0 10
115631: PPUSH
115632: LD_INT 19
115634: PPUSH
115635: CALL_OW 109
// mechs := mechs diff un ;
115639: LD_ADDR_VAR 0 12
115643: PUSH
115644: LD_VAR 0 12
115648: PUSH
115649: LD_VAR 0 10
115653: DIFF
115654: ST_TO_ADDR
// end ; end ;
115655: GO 115533
115657: POP
115658: POP
// if solds then
115659: LD_VAR 0 8
115663: IFFALSE 115722
// for i in solds do
115665: LD_ADDR_VAR 0 4
115669: PUSH
115670: LD_VAR 0 8
115674: PUSH
115675: FOR_IN
115676: IFFALSE 115720
// if not GetTag ( i ) then
115678: LD_VAR 0 4
115682: PPUSH
115683: CALL_OW 110
115687: NOT
115688: IFFALSE 115718
// begin defenders := defenders union i ;
115690: LD_ADDR_VAR 0 2
115694: PUSH
115695: LD_VAR 0 2
115699: PUSH
115700: LD_VAR 0 4
115704: UNION
115705: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115706: LD_VAR 0 4
115710: PPUSH
115711: LD_INT 18
115713: PPUSH
115714: CALL_OW 109
// end ;
115718: GO 115675
115720: POP
115721: POP
// repeat wait ( 0 0$2 ) ;
115722: LD_INT 70
115724: PPUSH
115725: CALL_OW 67
// enemy := mc_scan [ base ] ;
115729: LD_ADDR_VAR 0 21
115733: PUSH
115734: LD_EXP 73
115738: PUSH
115739: LD_VAR 0 1
115743: ARRAY
115744: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115745: LD_EXP 50
115749: PUSH
115750: LD_VAR 0 1
115754: ARRAY
115755: NOT
115756: PUSH
115757: LD_EXP 50
115761: PUSH
115762: LD_VAR 0 1
115766: ARRAY
115767: PUSH
115768: EMPTY
115769: EQUAL
115770: OR
115771: IFFALSE 115808
// begin for i in defenders do
115773: LD_ADDR_VAR 0 4
115777: PUSH
115778: LD_VAR 0 2
115782: PUSH
115783: FOR_IN
115784: IFFALSE 115797
// ComStop ( i ) ;
115786: LD_VAR 0 4
115790: PPUSH
115791: CALL_OW 141
115795: GO 115783
115797: POP
115798: POP
// defenders := [ ] ;
115799: LD_ADDR_VAR 0 2
115803: PUSH
115804: EMPTY
115805: ST_TO_ADDR
// exit ;
115806: GO 117257
// end ; for i in defenders do
115808: LD_ADDR_VAR 0 4
115812: PUSH
115813: LD_VAR 0 2
115817: PUSH
115818: FOR_IN
115819: IFFALSE 116717
// begin e := NearestUnitToUnit ( enemy , i ) ;
115821: LD_ADDR_VAR 0 13
115825: PUSH
115826: LD_VAR 0 21
115830: PPUSH
115831: LD_VAR 0 4
115835: PPUSH
115836: CALL_OW 74
115840: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115841: LD_ADDR_VAR 0 7
115845: PUSH
115846: LD_EXP 50
115850: PUSH
115851: LD_VAR 0 1
115855: ARRAY
115856: PPUSH
115857: LD_INT 2
115859: PUSH
115860: LD_INT 30
115862: PUSH
115863: LD_INT 0
115865: PUSH
115866: EMPTY
115867: LIST
115868: LIST
115869: PUSH
115870: LD_INT 30
115872: PUSH
115873: LD_INT 1
115875: PUSH
115876: EMPTY
115877: LIST
115878: LIST
115879: PUSH
115880: EMPTY
115881: LIST
115882: LIST
115883: LIST
115884: PPUSH
115885: CALL_OW 72
115889: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115890: LD_ADDR_VAR 0 16
115894: PUSH
115895: LD_VAR 0 7
115899: NOT
115900: PUSH
115901: LD_VAR 0 7
115905: PPUSH
115906: LD_INT 3
115908: PUSH
115909: LD_INT 24
115911: PUSH
115912: LD_INT 600
115914: PUSH
115915: EMPTY
115916: LIST
115917: LIST
115918: PUSH
115919: EMPTY
115920: LIST
115921: LIST
115922: PPUSH
115923: CALL_OW 72
115927: OR
115928: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115929: LD_VAR 0 4
115933: PPUSH
115934: CALL_OW 247
115938: PUSH
115939: LD_INT 2
115941: DOUBLE
115942: EQUAL
115943: IFTRUE 115947
115945: GO 116343
115947: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115948: LD_VAR 0 4
115952: PPUSH
115953: CALL_OW 256
115957: PUSH
115958: LD_INT 1000
115960: EQUAL
115961: PUSH
115962: LD_VAR 0 4
115966: PPUSH
115967: LD_VAR 0 13
115971: PPUSH
115972: CALL_OW 296
115976: PUSH
115977: LD_INT 40
115979: LESS
115980: PUSH
115981: LD_VAR 0 13
115985: PPUSH
115986: LD_EXP 75
115990: PUSH
115991: LD_VAR 0 1
115995: ARRAY
115996: PPUSH
115997: CALL_OW 308
116001: OR
116002: AND
116003: IFFALSE 116125
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116005: LD_VAR 0 4
116009: PPUSH
116010: CALL_OW 262
116014: PUSH
116015: LD_INT 1
116017: EQUAL
116018: PUSH
116019: LD_VAR 0 4
116023: PPUSH
116024: CALL_OW 261
116028: PUSH
116029: LD_INT 30
116031: LESS
116032: AND
116033: PUSH
116034: LD_VAR 0 7
116038: AND
116039: IFFALSE 116109
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116041: LD_VAR 0 4
116045: PPUSH
116046: LD_VAR 0 7
116050: PPUSH
116051: LD_VAR 0 4
116055: PPUSH
116056: CALL_OW 74
116060: PPUSH
116061: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116065: LD_VAR 0 4
116069: PPUSH
116070: LD_VAR 0 7
116074: PPUSH
116075: LD_VAR 0 4
116079: PPUSH
116080: CALL_OW 74
116084: PPUSH
116085: CALL_OW 296
116089: PUSH
116090: LD_INT 6
116092: LESS
116093: IFFALSE 116107
// SetFuel ( i , 100 ) ;
116095: LD_VAR 0 4
116099: PPUSH
116100: LD_INT 100
116102: PPUSH
116103: CALL_OW 240
// end else
116107: GO 116123
// ComAttackUnit ( i , e ) ;
116109: LD_VAR 0 4
116113: PPUSH
116114: LD_VAR 0 13
116118: PPUSH
116119: CALL_OW 115
// end else
116123: GO 116226
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116125: LD_VAR 0 13
116129: PPUSH
116130: LD_EXP 75
116134: PUSH
116135: LD_VAR 0 1
116139: ARRAY
116140: PPUSH
116141: CALL_OW 308
116145: NOT
116146: PUSH
116147: LD_VAR 0 4
116151: PPUSH
116152: LD_VAR 0 13
116156: PPUSH
116157: CALL_OW 296
116161: PUSH
116162: LD_INT 40
116164: GREATEREQUAL
116165: AND
116166: PUSH
116167: LD_VAR 0 4
116171: PPUSH
116172: CALL_OW 256
116176: PUSH
116177: LD_INT 650
116179: LESSEQUAL
116180: OR
116181: PUSH
116182: LD_VAR 0 4
116186: PPUSH
116187: LD_EXP 74
116191: PUSH
116192: LD_VAR 0 1
116196: ARRAY
116197: PPUSH
116198: CALL_OW 308
116202: NOT
116203: AND
116204: IFFALSE 116226
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116206: LD_VAR 0 4
116210: PPUSH
116211: LD_EXP 74
116215: PUSH
116216: LD_VAR 0 1
116220: ARRAY
116221: PPUSH
116222: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116226: LD_VAR 0 4
116230: PPUSH
116231: CALL_OW 256
116235: PUSH
116236: LD_INT 1000
116238: LESS
116239: PUSH
116240: LD_VAR 0 4
116244: PPUSH
116245: CALL_OW 263
116249: PUSH
116250: LD_INT 1
116252: EQUAL
116253: AND
116254: PUSH
116255: LD_VAR 0 4
116259: PPUSH
116260: CALL_OW 311
116264: AND
116265: PUSH
116266: LD_VAR 0 4
116270: PPUSH
116271: LD_EXP 74
116275: PUSH
116276: LD_VAR 0 1
116280: ARRAY
116281: PPUSH
116282: CALL_OW 308
116286: AND
116287: IFFALSE 116341
// begin mech := IsDrivenBy ( i ) ;
116289: LD_ADDR_VAR 0 9
116293: PUSH
116294: LD_VAR 0 4
116298: PPUSH
116299: CALL_OW 311
116303: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116304: LD_VAR 0 9
116308: PPUSH
116309: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116313: LD_VAR 0 9
116317: PPUSH
116318: LD_VAR 0 4
116322: PPUSH
116323: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116327: LD_VAR 0 9
116331: PPUSH
116332: LD_VAR 0 4
116336: PPUSH
116337: CALL_OW 180
// end ; end ; unit_human :
116341: GO 116688
116343: LD_INT 1
116345: DOUBLE
116346: EQUAL
116347: IFTRUE 116351
116349: GO 116687
116351: POP
// begin b := IsInUnit ( i ) ;
116352: LD_ADDR_VAR 0 18
116356: PUSH
116357: LD_VAR 0 4
116361: PPUSH
116362: CALL_OW 310
116366: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116367: LD_ADDR_VAR 0 19
116371: PUSH
116372: LD_VAR 0 18
116376: NOT
116377: PUSH
116378: LD_VAR 0 18
116382: PPUSH
116383: CALL_OW 266
116387: PUSH
116388: LD_INT 32
116390: PUSH
116391: LD_INT 31
116393: PUSH
116394: EMPTY
116395: LIST
116396: LIST
116397: IN
116398: OR
116399: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116400: LD_VAR 0 18
116404: PPUSH
116405: CALL_OW 266
116409: PUSH
116410: LD_INT 5
116412: EQUAL
116413: PUSH
116414: LD_VAR 0 4
116418: PPUSH
116419: CALL_OW 257
116423: PUSH
116424: LD_INT 1
116426: PUSH
116427: LD_INT 2
116429: PUSH
116430: LD_INT 3
116432: PUSH
116433: LD_INT 4
116435: PUSH
116436: EMPTY
116437: LIST
116438: LIST
116439: LIST
116440: LIST
116441: IN
116442: AND
116443: IFFALSE 116480
// begin class := AllowSpecClass ( i ) ;
116445: LD_ADDR_VAR 0 20
116449: PUSH
116450: LD_VAR 0 4
116454: PPUSH
116455: CALL 50441 0 1
116459: ST_TO_ADDR
// if class then
116460: LD_VAR 0 20
116464: IFFALSE 116480
// ComChangeProfession ( i , class ) ;
116466: LD_VAR 0 4
116470: PPUSH
116471: LD_VAR 0 20
116475: PPUSH
116476: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116480: LD_VAR 0 16
116484: PUSH
116485: LD_VAR 0 2
116489: PPUSH
116490: LD_INT 21
116492: PUSH
116493: LD_INT 2
116495: PUSH
116496: EMPTY
116497: LIST
116498: LIST
116499: PPUSH
116500: CALL_OW 72
116504: PUSH
116505: LD_INT 1
116507: LESSEQUAL
116508: OR
116509: PUSH
116510: LD_VAR 0 19
116514: AND
116515: PUSH
116516: LD_VAR 0 4
116520: PUSH
116521: LD_VAR 0 17
116525: IN
116526: NOT
116527: AND
116528: IFFALSE 116621
// begin if b then
116530: LD_VAR 0 18
116534: IFFALSE 116583
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116536: LD_VAR 0 18
116540: PPUSH
116541: LD_VAR 0 21
116545: PPUSH
116546: LD_VAR 0 18
116550: PPUSH
116551: CALL_OW 74
116555: PPUSH
116556: CALL_OW 296
116560: PUSH
116561: LD_INT 10
116563: LESS
116564: PUSH
116565: LD_VAR 0 18
116569: PPUSH
116570: CALL_OW 461
116574: PUSH
116575: LD_INT 7
116577: NONEQUAL
116578: AND
116579: IFFALSE 116583
// continue ;
116581: GO 115818
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116583: LD_ADDR_VAR 0 17
116587: PUSH
116588: LD_VAR 0 17
116592: PPUSH
116593: LD_VAR 0 17
116597: PUSH
116598: LD_INT 1
116600: PLUS
116601: PPUSH
116602: LD_VAR 0 4
116606: PPUSH
116607: CALL_OW 1
116611: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116612: LD_VAR 0 4
116616: PPUSH
116617: CALL_OW 122
// end ; if sold_defenders then
116621: LD_VAR 0 17
116625: IFFALSE 116685
// if i in sold_defenders then
116627: LD_VAR 0 4
116631: PUSH
116632: LD_VAR 0 17
116636: IN
116637: IFFALSE 116685
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116639: LD_VAR 0 4
116643: PPUSH
116644: CALL_OW 314
116648: NOT
116649: PUSH
116650: LD_VAR 0 4
116654: PPUSH
116655: LD_VAR 0 13
116659: PPUSH
116660: CALL_OW 296
116664: PUSH
116665: LD_INT 30
116667: LESS
116668: AND
116669: IFFALSE 116685
// ComAttackUnit ( i , e ) ;
116671: LD_VAR 0 4
116675: PPUSH
116676: LD_VAR 0 13
116680: PPUSH
116681: CALL_OW 115
// end ; end ; end ;
116685: GO 116688
116687: POP
// if IsDead ( i ) then
116688: LD_VAR 0 4
116692: PPUSH
116693: CALL_OW 301
116697: IFFALSE 116715
// defenders := defenders diff i ;
116699: LD_ADDR_VAR 0 2
116703: PUSH
116704: LD_VAR 0 2
116708: PUSH
116709: LD_VAR 0 4
116713: DIFF
116714: ST_TO_ADDR
// end ;
116715: GO 115818
116717: POP
116718: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116719: LD_VAR 0 21
116723: NOT
116724: PUSH
116725: LD_VAR 0 2
116729: NOT
116730: OR
116731: PUSH
116732: LD_EXP 50
116736: PUSH
116737: LD_VAR 0 1
116741: ARRAY
116742: NOT
116743: OR
116744: IFFALSE 115722
// MC_Reset ( base , 18 ) ;
116746: LD_VAR 0 1
116750: PPUSH
116751: LD_INT 18
116753: PPUSH
116754: CALL 22152 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116758: LD_ADDR_VAR 0 2
116762: PUSH
116763: LD_VAR 0 2
116767: PUSH
116768: LD_VAR 0 2
116772: PPUSH
116773: LD_INT 2
116775: PUSH
116776: LD_INT 25
116778: PUSH
116779: LD_INT 1
116781: PUSH
116782: EMPTY
116783: LIST
116784: LIST
116785: PUSH
116786: LD_INT 25
116788: PUSH
116789: LD_INT 5
116791: PUSH
116792: EMPTY
116793: LIST
116794: LIST
116795: PUSH
116796: LD_INT 25
116798: PUSH
116799: LD_INT 8
116801: PUSH
116802: EMPTY
116803: LIST
116804: LIST
116805: PUSH
116806: LD_INT 25
116808: PUSH
116809: LD_INT 9
116811: PUSH
116812: EMPTY
116813: LIST
116814: LIST
116815: PUSH
116816: EMPTY
116817: LIST
116818: LIST
116819: LIST
116820: LIST
116821: LIST
116822: PPUSH
116823: CALL_OW 72
116827: DIFF
116828: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116829: LD_VAR 0 21
116833: NOT
116834: PUSH
116835: LD_VAR 0 2
116839: PPUSH
116840: LD_INT 21
116842: PUSH
116843: LD_INT 2
116845: PUSH
116846: EMPTY
116847: LIST
116848: LIST
116849: PPUSH
116850: CALL_OW 72
116854: AND
116855: IFFALSE 117193
// begin tmp := FilterByTag ( defenders , 19 ) ;
116857: LD_ADDR_VAR 0 11
116861: PUSH
116862: LD_VAR 0 2
116866: PPUSH
116867: LD_INT 19
116869: PPUSH
116870: CALL 83678 0 2
116874: ST_TO_ADDR
// if tmp then
116875: LD_VAR 0 11
116879: IFFALSE 116949
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116881: LD_ADDR_VAR 0 11
116885: PUSH
116886: LD_VAR 0 11
116890: PPUSH
116891: LD_INT 25
116893: PUSH
116894: LD_INT 3
116896: PUSH
116897: EMPTY
116898: LIST
116899: LIST
116900: PPUSH
116901: CALL_OW 72
116905: ST_TO_ADDR
// if tmp then
116906: LD_VAR 0 11
116910: IFFALSE 116949
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116912: LD_ADDR_EXP 62
116916: PUSH
116917: LD_EXP 62
116921: PPUSH
116922: LD_VAR 0 1
116926: PPUSH
116927: LD_EXP 62
116931: PUSH
116932: LD_VAR 0 1
116936: ARRAY
116937: PUSH
116938: LD_VAR 0 11
116942: UNION
116943: PPUSH
116944: CALL_OW 1
116948: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116949: LD_VAR 0 1
116953: PPUSH
116954: LD_INT 19
116956: PPUSH
116957: CALL 22152 0 2
// repeat wait ( 0 0$1 ) ;
116961: LD_INT 35
116963: PPUSH
116964: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116968: LD_EXP 50
116972: PUSH
116973: LD_VAR 0 1
116977: ARRAY
116978: NOT
116979: PUSH
116980: LD_EXP 50
116984: PUSH
116985: LD_VAR 0 1
116989: ARRAY
116990: PUSH
116991: EMPTY
116992: EQUAL
116993: OR
116994: IFFALSE 117031
// begin for i in defenders do
116996: LD_ADDR_VAR 0 4
117000: PUSH
117001: LD_VAR 0 2
117005: PUSH
117006: FOR_IN
117007: IFFALSE 117020
// ComStop ( i ) ;
117009: LD_VAR 0 4
117013: PPUSH
117014: CALL_OW 141
117018: GO 117006
117020: POP
117021: POP
// defenders := [ ] ;
117022: LD_ADDR_VAR 0 2
117026: PUSH
117027: EMPTY
117028: ST_TO_ADDR
// exit ;
117029: GO 117257
// end ; for i in defenders do
117031: LD_ADDR_VAR 0 4
117035: PUSH
117036: LD_VAR 0 2
117040: PUSH
117041: FOR_IN
117042: IFFALSE 117131
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117044: LD_VAR 0 4
117048: PPUSH
117049: LD_EXP 74
117053: PUSH
117054: LD_VAR 0 1
117058: ARRAY
117059: PPUSH
117060: CALL_OW 308
117064: NOT
117065: IFFALSE 117089
// ComMoveToArea ( i , mc_parking [ base ] ) else
117067: LD_VAR 0 4
117071: PPUSH
117072: LD_EXP 74
117076: PUSH
117077: LD_VAR 0 1
117081: ARRAY
117082: PPUSH
117083: CALL_OW 113
117087: GO 117129
// if GetControl ( i ) = control_manual then
117089: LD_VAR 0 4
117093: PPUSH
117094: CALL_OW 263
117098: PUSH
117099: LD_INT 1
117101: EQUAL
117102: IFFALSE 117129
// if IsDrivenBy ( i ) then
117104: LD_VAR 0 4
117108: PPUSH
117109: CALL_OW 311
117113: IFFALSE 117129
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117115: LD_VAR 0 4
117119: PPUSH
117120: CALL_OW 311
117124: PPUSH
117125: CALL_OW 121
// end ;
117129: GO 117041
117131: POP
117132: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117133: LD_VAR 0 2
117137: PPUSH
117138: LD_INT 95
117140: PUSH
117141: LD_EXP 74
117145: PUSH
117146: LD_VAR 0 1
117150: ARRAY
117151: PUSH
117152: EMPTY
117153: LIST
117154: LIST
117155: PPUSH
117156: CALL_OW 72
117160: PUSH
117161: LD_VAR 0 2
117165: EQUAL
117166: PUSH
117167: LD_EXP 73
117171: PUSH
117172: LD_VAR 0 1
117176: ARRAY
117177: OR
117178: PUSH
117179: LD_EXP 50
117183: PUSH
117184: LD_VAR 0 1
117188: ARRAY
117189: NOT
117190: OR
117191: IFFALSE 116961
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117193: LD_ADDR_EXP 72
117197: PUSH
117198: LD_EXP 72
117202: PPUSH
117203: LD_VAR 0 1
117207: PPUSH
117208: LD_VAR 0 2
117212: PPUSH
117213: LD_INT 21
117215: PUSH
117216: LD_INT 2
117218: PUSH
117219: EMPTY
117220: LIST
117221: LIST
117222: PPUSH
117223: CALL_OW 72
117227: PPUSH
117228: CALL_OW 1
117232: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117233: LD_VAR 0 1
117237: PPUSH
117238: LD_INT 19
117240: PPUSH
117241: CALL 22152 0 2
// MC_Reset ( base , 20 ) ;
117245: LD_VAR 0 1
117249: PPUSH
117250: LD_INT 20
117252: PPUSH
117253: CALL 22152 0 2
// end ; end_of_file
117257: LD_VAR 0 3
117261: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117262: LD_VAR 0 1
117266: PUSH
117267: LD_INT 200
117269: DOUBLE
117270: GREATEREQUAL
117271: IFFALSE 117279
117273: LD_INT 299
117275: DOUBLE
117276: LESSEQUAL
117277: IFTRUE 117281
117279: GO 117313
117281: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117282: LD_VAR 0 1
117286: PPUSH
117287: LD_VAR 0 2
117291: PPUSH
117292: LD_VAR 0 3
117296: PPUSH
117297: LD_VAR 0 4
117301: PPUSH
117302: LD_VAR 0 5
117306: PPUSH
117307: CALL 106048 0 5
117311: GO 117390
117313: LD_INT 300
117315: DOUBLE
117316: GREATEREQUAL
117317: IFFALSE 117325
117319: LD_INT 399
117321: DOUBLE
117322: LESSEQUAL
117323: IFTRUE 117327
117325: GO 117389
117327: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117328: LD_VAR 0 1
117332: PPUSH
117333: LD_VAR 0 2
117337: PPUSH
117338: LD_VAR 0 3
117342: PPUSH
117343: LD_VAR 0 4
117347: PPUSH
117348: LD_VAR 0 5
117352: PPUSH
117353: LD_VAR 0 6
117357: PPUSH
117358: LD_VAR 0 7
117362: PPUSH
117363: LD_VAR 0 8
117367: PPUSH
117368: LD_VAR 0 9
117372: PPUSH
117373: LD_VAR 0 10
117377: PPUSH
117378: LD_VAR 0 11
117382: PPUSH
117383: CALL 102381 0 11
117387: GO 117390
117389: POP
// end ;
117390: PPOPN 11
117392: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117393: LD_VAR 0 1
117397: PPUSH
117398: LD_VAR 0 2
117402: PPUSH
117403: LD_VAR 0 3
117407: PPUSH
117408: LD_VAR 0 4
117412: PPUSH
117413: LD_VAR 0 5
117417: PPUSH
117418: CALL 105784 0 5
// end ; end_of_file
117422: PPOPN 5
117424: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117425: LD_VAR 0 1
117429: PPUSH
117430: LD_VAR 0 2
117434: PPUSH
117435: LD_VAR 0 3
117439: PPUSH
117440: LD_VAR 0 4
117444: PPUSH
117445: LD_VAR 0 5
117449: PPUSH
117450: LD_VAR 0 6
117454: PPUSH
117455: CALL 90074 0 6
// end ;
117459: PPOPN 6
117461: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117462: LD_INT 0
117464: PPUSH
// begin if not units then
117465: LD_VAR 0 1
117469: NOT
117470: IFFALSE 117474
// exit ;
117472: GO 117474
// end ;
117474: PPOPN 7
117476: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117477: CALL 90045 0 0
// end ;
117481: PPOPN 1
117483: END
