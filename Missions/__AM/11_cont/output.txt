// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 84948 0 0
// InitMacro ;
  23: CALL 17789 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 80494 0 9
// PrepareAmerican ;
  81: CALL 647 0 0
// PrepareArabian ;
  85: CALL 2598 0 0
// MC_Start ( ) ;
  89: CALL 19901 0 0
// Action ;
  93: CALL 8435 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 9
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: PUSH
 363: LD_OWVAR 67
 367: ARRAY
 368: PPUSH
 369: LD_INT 3
 371: PPUSH
 372: CALL 41150 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 376: LD_INT 2
 378: PPUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 9
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_OWVAR 67
 397: ARRAY
 398: PPUSH
 399: LD_INT 2
 401: PPUSH
 402: CALL 41150 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 4
 411: PUSH
 412: LD_INT 6
 414: PUSH
 415: LD_INT 9
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: PUSH
 423: LD_OWVAR 67
 427: ARRAY
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: CALL 41150 0 3
// for i = 1 to mc_bases do
 436: LD_ADDR_VAR 0 2
 440: PUSH
 441: DOUBLE
 442: LD_INT 1
 444: DEC
 445: ST_TO_ADDR
 446: LD_EXP 50
 450: PUSH
 451: FOR_TO
 452: IFFALSE 476
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: LD_EXP 43
 463: PUSH
 464: LD_VAR 0 2
 468: ARRAY
 469: PPUSH
 470: CALL 41576 0 2
 474: GO 451
 476: POP
 477: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 478: LD_INT 1
 480: PPUSH
 481: LD_INT 14
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 2
 489: PUSH
 490: LD_EXP 99
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 14
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: LD_INT 2
 509: PUSH
 510: LD_EXP 99
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 41468 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 529: LD_INT 2
 531: PPUSH
 532: LD_INT 14
 534: PUSH
 535: LD_INT 1
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: LD_EXP 99
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: PPUSH
 555: CALL 41468 0 2
// end ;
 559: LD_VAR 0 1
 563: RET
// function Debuger ; var i ; begin
 564: LD_INT 0
 566: PPUSH
 567: PPUSH
// if not debug then
 568: LD_EXP 1
 572: NOT
 573: IFFALSE 577
// exit ;
 575: GO 613
// game_speed := 5 ;
 577: LD_ADDR_OWVAR 65
 581: PUSH
 582: LD_INT 5
 584: ST_TO_ADDR
// uc_side := 1 ;
 585: LD_ADDR_OWVAR 20
 589: PUSH
 590: LD_INT 1
 592: ST_TO_ADDR
// uc_nation := 1 ;
 593: LD_ADDR_OWVAR 21
 597: PUSH
 598: LD_INT 1
 600: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 601: LD_EXP 36
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 235
// end ;
 613: LD_VAR 0 1
 617: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 618: LD_INT 94
 620: PPUSH
 621: CALL_OW 301
 625: PUSH
 626: LD_INT 45
 628: PPUSH
 629: CALL_OW 302
 633: AND
 634: IFFALSE 646
 636: GO 638
 638: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 639: LD_STRING ACH_EAST
 641: PPUSH
 642: CALL_OW 543
 646: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 647: LD_INT 0
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// uc_side := 4 ;
 657: LD_ADDR_OWVAR 20
 661: PUSH
 662: LD_INT 4
 664: ST_TO_ADDR
// uc_nation := 1 ;
 665: LD_ADDR_OWVAR 21
 669: PUSH
 670: LD_INT 1
 672: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 673: LD_ADDR_EXP 30
 677: PUSH
 678: LD_STRING Powell
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_STRING 
 686: PPUSH
 687: CALL 47879 0 3
 691: ST_TO_ADDR
// uc_side := 1 ;
 692: LD_ADDR_OWVAR 20
 696: PUSH
 697: LD_INT 1
 699: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 700: LD_ADDR_EXP 21
 704: PUSH
 705: LD_STRING JMM
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_EXP 4
 718: PPUSH
 719: CALL 47879 0 3
 723: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 724: LD_EXP 21
 728: PPUSH
 729: CALL_OW 257
 733: PUSH
 734: LD_INT 4
 736: GREATER
 737: IFFALSE 751
// SetClass ( JMM , 1 ) ;
 739: LD_EXP 21
 743: PPUSH
 744: LD_INT 1
 746: PPUSH
 747: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 751: LD_ADDR_EXP 22
 755: PUSH
 756: LD_STRING Lisa
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_EXP 4
 769: PPUSH
 770: CALL 47879 0 3
 774: ST_TO_ADDR
// if not Lisa then
 775: LD_EXP 22
 779: NOT
 780: IFFALSE 795
// Lisa := CreateCharacter ( 10_Lisa ) ;
 782: LD_ADDR_EXP 22
 786: PUSH
 787: LD_STRING 10_Lisa
 789: PPUSH
 790: CALL_OW 34
 794: ST_TO_ADDR
// if not Lisa then
 795: LD_EXP 22
 799: NOT
 800: IFFALSE 815
// Lisa := CreateCharacter ( 09_Lisa ) ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_STRING 09_Lisa
 809: PPUSH
 810: CALL_OW 34
 814: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 815: LD_ADDR_EXP 31
 819: PUSH
 820: LD_STRING Cornel
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_EXP 4
 833: PPUSH
 834: CALL 47879 0 3
 838: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 839: LD_ADDR_EXP 23
 843: PUSH
 844: LD_STRING Donaldson
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_EXP 4
 857: PPUSH
 858: CALL 47879 0 3
 862: ST_TO_ADDR
// if not Donaldson then
 863: LD_EXP 23
 867: NOT
 868: IFFALSE 883
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 870: LD_ADDR_EXP 23
 874: PUSH
 875: LD_STRING 10_Donaldson
 877: PPUSH
 878: CALL_OW 34
 882: ST_TO_ADDR
// if not Donaldson then
 883: LD_EXP 23
 887: NOT
 888: IFFALSE 903
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 890: LD_ADDR_EXP 23
 894: PUSH
 895: LD_STRING 09_Donaldson
 897: PPUSH
 898: CALL_OW 34
 902: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 903: LD_ADDR_EXP 24
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_EXP 4
 921: PPUSH
 922: CALL 47879 0 3
 926: ST_TO_ADDR
// if not Bobby then
 927: LD_EXP 24
 931: NOT
 932: IFFALSE 947
// Bobby := CreateCharacter ( 10_Bobby ) ;
 934: LD_ADDR_EXP 24
 938: PUSH
 939: LD_STRING 10_Bobby
 941: PPUSH
 942: CALL_OW 34
 946: ST_TO_ADDR
// if not Bobby then
 947: LD_EXP 24
 951: NOT
 952: IFFALSE 967
// Bobby := CreateCharacter ( 09_Bobby ) ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_STRING 09_Bobby
 961: PPUSH
 962: CALL_OW 34
 966: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 967: LD_ADDR_EXP 25
 971: PUSH
 972: LD_STRING Cyrus
 974: PPUSH
 975: LD_EXP 1
 979: NOT
 980: PPUSH
 981: LD_EXP 4
 985: PPUSH
 986: CALL 47879 0 3
 990: ST_TO_ADDR
// if not Cyrus then
 991: LD_EXP 25
 995: NOT
 996: IFFALSE 1011
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 998: LD_ADDR_EXP 25
1002: PUSH
1003: LD_STRING 10_Cyrus
1005: PPUSH
1006: CALL_OW 34
1010: ST_TO_ADDR
// if not Cyrus then
1011: LD_EXP 25
1015: NOT
1016: IFFALSE 1031
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_STRING 09_Cyrus
1025: PPUSH
1026: CALL_OW 34
1030: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1031: LD_ADDR_EXP 26
1035: PUSH
1036: LD_STRING Denis
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_EXP 4
1049: PPUSH
1050: CALL 47879 0 3
1054: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1055: LD_ADDR_EXP 27
1059: PUSH
1060: LD_STRING Brown
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_EXP 4
1073: PPUSH
1074: CALL 47879 0 3
1078: ST_TO_ADDR
// if not Brown then
1079: LD_EXP 27
1083: NOT
1084: IFFALSE 1099
// Brown := CreateCharacter ( 10_Brown ) ;
1086: LD_ADDR_EXP 27
1090: PUSH
1091: LD_STRING 10_Brown
1093: PPUSH
1094: CALL_OW 34
1098: ST_TO_ADDR
// if not Brown then
1099: LD_EXP 27
1103: NOT
1104: IFFALSE 1119
// Brown := CreateCharacter ( 08_Brown ) ;
1106: LD_ADDR_EXP 27
1110: PUSH
1111: LD_STRING 08_Brown
1113: PPUSH
1114: CALL_OW 34
1118: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 28
1123: PUSH
1124: LD_STRING Gladstone
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 47879 0 3
1142: ST_TO_ADDR
// if not Gladstone then
1143: LD_EXP 28
1147: NOT
1148: IFFALSE 1163
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1150: LD_ADDR_EXP 28
1154: PUSH
1155: LD_STRING 10_Gladstone
1157: PPUSH
1158: CALL_OW 34
1162: ST_TO_ADDR
// if not Gladstone then
1163: LD_EXP 28
1167: NOT
1168: IFFALSE 1183
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1170: LD_ADDR_EXP 28
1174: PUSH
1175: LD_STRING 08_Gladstone
1177: PPUSH
1178: CALL_OW 34
1182: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1183: LD_ADDR_EXP 29
1187: PUSH
1188: LD_STRING Houten
1190: PPUSH
1191: LD_EXP 1
1195: NOT
1196: PPUSH
1197: LD_EXP 4
1201: PPUSH
1202: CALL 47879 0 3
1206: ST_TO_ADDR
// if not Houten then
1207: LD_EXP 29
1211: NOT
1212: IFFALSE 1227
// Houten := CreateCharacter ( 10_Houten ) ;
1214: LD_ADDR_EXP 29
1218: PUSH
1219: LD_STRING 10_Houten
1221: PPUSH
1222: CALL_OW 34
1226: ST_TO_ADDR
// if not Houten then
1227: LD_EXP 29
1231: NOT
1232: IFFALSE 1247
// Houten := CreateCharacter ( 09_Houten ) ;
1234: LD_ADDR_EXP 29
1238: PUSH
1239: LD_STRING 09_Houten
1241: PPUSH
1242: CALL_OW 34
1246: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1247: LD_ADDR_EXP 31
1251: PUSH
1252: LD_STRING Cornell
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_EXP 4
1265: PPUSH
1266: CALL 47879 0 3
1270: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1271: LD_ADDR_EXP 32
1275: PUSH
1276: LD_STRING Gary
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: LD_EXP 4
1289: PPUSH
1290: CALL 47879 0 3
1294: ST_TO_ADDR
// if not Gary then
1295: LD_EXP 32
1299: NOT
1300: IFFALSE 1315
// Gary := CreateCharacter ( 10_Gary ) ;
1302: LD_ADDR_EXP 32
1306: PUSH
1307: LD_STRING 10_Gary
1309: PPUSH
1310: CALL_OW 34
1314: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1315: LD_ADDR_EXP 33
1319: PUSH
1320: LD_STRING Frank
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 47879 0 3
1338: ST_TO_ADDR
// if not Frank then
1339: LD_EXP 33
1343: NOT
1344: IFFALSE 1359
// Frank := CreateCharacter ( 08_Frank ) ;
1346: LD_ADDR_EXP 33
1350: PUSH
1351: LD_STRING 08_Frank
1353: PPUSH
1354: CALL_OW 34
1358: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1359: LD_ADDR_EXP 34
1363: PUSH
1364: LD_STRING Kikuchi
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: LD_EXP 4
1377: PPUSH
1378: CALL 47879 0 3
1382: ST_TO_ADDR
// if not Kikuchi then
1383: LD_EXP 34
1387: NOT
1388: IFFALSE 1403
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1390: LD_ADDR_EXP 34
1394: PUSH
1395: LD_STRING 08_Kikuchi
1397: PPUSH
1398: CALL_OW 34
1402: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_EXP 22
1412: PUSH
1413: LD_EXP 23
1417: PUSH
1418: LD_EXP 24
1422: PUSH
1423: LD_EXP 25
1427: PUSH
1428: LD_EXP 26
1432: PUSH
1433: LD_EXP 27
1437: PUSH
1438: LD_EXP 28
1442: PUSH
1443: LD_EXP 29
1447: PUSH
1448: LD_EXP 31
1452: PUSH
1453: LD_EXP 32
1457: PUSH
1458: LD_EXP 33
1462: PUSH
1463: LD_EXP 34
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// tmp := tmp diff 0 ;
1482: LD_ADDR_VAR 0 5
1486: PUSH
1487: LD_VAR 0 5
1491: PUSH
1492: LD_INT 0
1494: DIFF
1495: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1496: LD_ADDR_VAR 0 5
1500: PUSH
1501: LD_VAR 0 5
1505: PUSH
1506: LD_STRING 10_lock
1508: PPUSH
1509: CALL_OW 31
1513: UNION
1514: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 5
1524: PUSH
1525: LD_STRING 10c_lock
1527: PPUSH
1528: CALL_OW 31
1532: UNION
1533: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1534: LD_STRING 10_lock
1536: PPUSH
1537: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 40
// for i in tmp do
1548: LD_ADDR_VAR 0 2
1552: PUSH
1553: LD_VAR 0 5
1557: PUSH
1558: FOR_IN
1559: IFFALSE 1597
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 257
1570: PUSH
1571: LD_INT 8
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: IN
1581: IFFALSE 1595
// SetClass ( i , class_soldier ) ;
1583: LD_VAR 0 2
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 336
1595: GO 1558
1597: POP
1598: POP
// if tmp < 12 then
1599: LD_VAR 0 5
1603: PUSH
1604: LD_INT 12
1606: LESS
1607: IFFALSE 1701
// begin k := 16 - tmp ;
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_INT 16
1616: PUSH
1617: LD_VAR 0 5
1621: MINUS
1622: ST_TO_ADDR
// for i = 1 to k do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 3
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1699
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1641: LD_INT 0
1643: PPUSH
1644: LD_INT 1
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 4
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: PUSH
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 12
1672: ARRAY
1673: PPUSH
1674: LD_INT 6
1676: PPUSH
1677: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1681: LD_ADDR_VAR 0 5
1685: PUSH
1686: LD_VAR 0 5
1690: PUSH
1691: CALL_OW 44
1695: ADD
1696: ST_TO_ADDR
// end ;
1697: GO 1638
1699: POP
1700: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1701: LD_ADDR_EXP 19
1705: PUSH
1706: LD_STRING 1
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 12
1714: PPUSH
1715: LD_INT -5
1717: PUSH
1718: LD_EXP 21
1722: PUSH
1723: LD_INT -2
1725: PUSH
1726: LD_INT -3
1728: PUSH
1729: LD_INT -5
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_VAR 0 5
1743: ADD
1744: PUSH
1745: LD_INT -6
1747: PUSH
1748: LD_INT -4
1750: PUSH
1751: LD_EXP 30
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: ADD
1761: PPUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 5
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: LD_INT 0
1791: PUSH
1792: LD_INT 3
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 5
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: LD_INT 2
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 42
1824: ST_TO_ADDR
// others := tmp diff selected ;
1825: LD_ADDR_VAR 0 8
1829: PUSH
1830: LD_VAR 0 5
1834: PUSH
1835: LD_EXP 19
1839: DIFF
1840: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 8
1850: PUSH
1851: LD_EXP 22
1855: PUSH
1856: LD_EXP 23
1860: PUSH
1861: LD_EXP 24
1865: PUSH
1866: LD_EXP 25
1870: PUSH
1871: LD_EXP 26
1875: PUSH
1876: LD_EXP 27
1880: PUSH
1881: LD_EXP 28
1885: PUSH
1886: LD_EXP 29
1890: PUSH
1891: LD_EXP 31
1895: PUSH
1896: LD_EXP 32
1900: PUSH
1901: LD_EXP 33
1905: PUSH
1906: LD_EXP 34
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: DIFF
1925: ST_TO_ADDR
// if others then
1926: LD_VAR 0 8
1930: IFFALSE 1944
// SaveCharacters ( others , 11_others ) ;
1932: LD_VAR 0 8
1936: PPUSH
1937: LD_STRING 11_others
1939: PPUSH
1940: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 1
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 5
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_INT 4
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 1
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 1
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: LD_INT 7
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: PUSH
2021: LD_INT 3
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: ST_TO_ADDR
// for i in JMM ^ selected do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_EXP 21
2055: PUSH
2056: LD_EXP 19
2060: ADD
2061: PUSH
2062: FOR_IN
2063: IFFALSE 2252
// begin if GetClass ( i ) = 3 then
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 257
2074: PUSH
2075: LD_INT 3
2077: EQUAL
2078: IFFALSE 2235
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2080: LD_ADDR_OWVAR 37
2084: PUSH
2085: LD_VAR 0 6
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: PUSH
2094: LD_INT 1
2096: ARRAY
2097: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 6
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2116: LD_ADDR_OWVAR 38
2120: PUSH
2121: LD_VAR 0 6
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PUSH
2130: LD_INT 3
2132: ARRAY
2133: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2134: LD_ADDR_OWVAR 40
2138: PUSH
2139: LD_VAR 0 6
2143: PUSH
2144: LD_INT 1
2146: ARRAY
2147: PUSH
2148: LD_INT 4
2150: ARRAY
2151: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2152: LD_ADDR_VAR 0 6
2156: PUSH
2157: LD_VAR 0 6
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: CALL_OW 3
2169: ST_TO_ADDR
// veh := CreateVehicle ;
2170: LD_ADDR_VAR 0 7
2174: PUSH
2175: CALL_OW 45
2179: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2180: LD_VAR 0 7
2184: PPUSH
2185: LD_INT 8
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2195: LD_VAR 0 2
2199: PPUSH
2200: LD_VAR 0 7
2204: PPUSH
2205: CALL_OW 52
// if i = JMM then
2209: LD_VAR 0 2
2213: PUSH
2214: LD_EXP 21
2218: EQUAL
2219: IFFALSE 2233
// SetMark ( veh , 1 ) ;
2221: LD_VAR 0 7
2225: PPUSH
2226: LD_INT 1
2228: PPUSH
2229: CALL_OW 242
// end else
2233: GO 2250
// PlaceUnitArea ( i , am_hum_start , false ) ;
2235: LD_VAR 0 2
2239: PPUSH
2240: LD_INT 9
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
// end ;
2250: GO 2062
2252: POP
2253: POP
// vc_chassis := us_medium_tracked ;
2254: LD_ADDR_OWVAR 37
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_engine := engine_solar ;
2262: LD_ADDR_OWVAR 39
2266: PUSH
2267: LD_INT 2
2269: ST_TO_ADDR
// vc_control := control_computer ;
2270: LD_ADDR_OWVAR 38
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_weapon := us_radar ;
2278: LD_ADDR_OWVAR 40
2282: PUSH
2283: LD_INT 11
2285: ST_TO_ADDR
// veh := CreateVehicle ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: CALL_OW 45
2295: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2296: LD_VAR 0 7
2300: PPUSH
2301: LD_INT 87
2303: PPUSH
2304: LD_INT 142
2306: PPUSH
2307: LD_INT 0
2309: PPUSH
2310: CALL_OW 48
// end ;
2314: LD_VAR 0 1
2318: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side := 1 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// uc_nation := 1 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 1
2340: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2341: LD_ADDR_VAR 0 3
2345: PUSH
2346: LD_INT 3
2348: PUSH
2349: LD_INT 1
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: LD_INT 5
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_INT 3
2366: PUSH
2367: LD_INT 1
2369: PUSH
2370: LD_INT 3
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: PUSH
2382: LD_INT 3
2384: PUSH
2385: LD_INT 1
2387: PUSH
2388: LD_INT 3
2390: PUSH
2391: LD_INT 7
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 1
2405: PUSH
2406: LD_INT 3
2408: PUSH
2409: LD_INT 11
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: PUSH
2418: LD_INT 4
2420: PUSH
2421: LD_INT 1
2423: PUSH
2424: LD_INT 3
2426: PUSH
2427: LD_INT 6
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 4
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: LD_INT 3
2444: PUSH
2445: LD_INT 5
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2462: LD_ADDR_VAR 0 2
2466: PUSH
2467: DOUBLE
2468: LD_INT 1
2470: DEC
2471: ST_TO_ADDR
2472: LD_INT 7
2474: PUSH
2475: LD_OWVAR 67
2479: MINUS
2480: PUSH
2481: FOR_TO
2482: IFFALSE 2591
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2484: LD_ADDR_OWVAR 37
2488: PUSH
2489: LD_VAR 0 3
2493: PUSH
2494: LD_VAR 0 2
2498: ARRAY
2499: PUSH
2500: LD_INT 1
2502: ARRAY
2503: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_VAR 0 3
2513: PUSH
2514: LD_VAR 0 2
2518: ARRAY
2519: PUSH
2520: LD_INT 2
2522: ARRAY
2523: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2524: LD_ADDR_OWVAR 38
2528: PUSH
2529: LD_VAR 0 3
2533: PUSH
2534: LD_VAR 0 2
2538: ARRAY
2539: PUSH
2540: LD_INT 3
2542: ARRAY
2543: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2544: LD_ADDR_OWVAR 40
2548: PUSH
2549: LD_VAR 0 3
2553: PUSH
2554: LD_VAR 0 2
2558: ARRAY
2559: PUSH
2560: LD_INT 4
2562: ARRAY
2563: ST_TO_ADDR
// veh := CreateVehicle ;
2564: LD_ADDR_VAR 0 4
2568: PUSH
2569: CALL_OW 45
2573: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2574: LD_VAR 0 4
2578: PPUSH
2579: LD_INT 8
2581: PPUSH
2582: LD_INT 0
2584: PPUSH
2585: CALL_OW 49
// end ;
2589: GO 2481
2591: POP
2592: POP
// end ; end_of_file
2593: LD_VAR 0 1
2597: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2598: LD_INT 0
2600: PPUSH
2601: PPUSH
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// if Difficulty = 1 then
2606: LD_OWVAR 67
2610: PUSH
2611: LD_INT 1
2613: EQUAL
2614: IFFALSE 2711
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2616: LD_ADDR_VAR 0 6
2620: PUSH
2621: LD_INT 129
2623: PUSH
2624: LD_INT 45
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 143
2633: PUSH
2634: LD_INT 58
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 184
2643: PUSH
2644: LD_INT 113
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 163
2653: PUSH
2654: LD_INT 107
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: ST_TO_ADDR
// for i in tmp do
2667: LD_ADDR_VAR 0 2
2671: PUSH
2672: LD_VAR 0 6
2676: PUSH
2677: FOR_IN
2678: IFFALSE 2709
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2680: LD_VAR 0 2
2684: PUSH
2685: LD_INT 1
2687: ARRAY
2688: PPUSH
2689: LD_VAR 0 2
2693: PUSH
2694: LD_INT 2
2696: ARRAY
2697: PPUSH
2698: CALL_OW 428
2702: PPUSH
2703: CALL_OW 64
2707: GO 2677
2709: POP
2710: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_INT 21
2718: PUSH
2719: LD_INT 3
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL_OW 69
2730: PUSH
2731: FOR_IN
2732: IFFALSE 2765
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 6
2744: PUSH
2745: LD_INT 7
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: PUSH
2753: LD_OWVAR 67
2757: ARRAY
2758: PPUSH
2759: CALL_OW 241
2763: GO 2731
2765: POP
2766: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2767: LD_ADDR_VAR 0 5
2771: PUSH
2772: LD_INT 5
2774: PUSH
2775: LD_INT 6
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: LIST
2785: PUSH
2786: LD_OWVAR 67
2790: ARRAY
2791: ST_TO_ADDR
// uc_side := 2 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 2
2799: ST_TO_ADDR
// uc_nation := 2 ;
2800: LD_ADDR_OWVAR 21
2804: PUSH
2805: LD_INT 2
2807: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2808: LD_ADDR_OWVAR 37
2812: PUSH
2813: LD_INT 14
2815: ST_TO_ADDR
// vc_engine := engine_siberite ;
2816: LD_ADDR_OWVAR 39
2820: PUSH
2821: LD_INT 3
2823: ST_TO_ADDR
// vc_control := control_manual ;
2824: LD_ADDR_OWVAR 38
2828: PUSH
2829: LD_INT 1
2831: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2832: LD_ADDR_OWVAR 40
2836: PUSH
2837: LD_INT 31
2839: ST_TO_ADDR
// for i = 1 to 3 do
2840: LD_ADDR_VAR 0 2
2844: PUSH
2845: DOUBLE
2846: LD_INT 1
2848: DEC
2849: ST_TO_ADDR
2850: LD_INT 3
2852: PUSH
2853: FOR_TO
2854: IFFALSE 2938
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2856: LD_INT 0
2858: PPUSH
2859: LD_INT 3
2861: PPUSH
2862: LD_VAR 0 5
2866: PPUSH
2867: CALL_OW 380
// un := CreateVehicle ;
2871: LD_ADDR_VAR 0 4
2875: PUSH
2876: CALL_OW 45
2880: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 5
2891: PPUSH
2892: CALL_OW 12
2896: PPUSH
2897: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2901: LD_VAR 0 4
2905: PPUSH
2906: LD_INT 156
2908: PPUSH
2909: LD_INT 15
2911: PPUSH
2912: LD_INT 6
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2922: CALL_OW 44
2926: PPUSH
2927: LD_VAR 0 4
2931: PPUSH
2932: CALL_OW 52
// end ;
2936: GO 2853
2938: POP
2939: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2940: LD_ADDR_EXP 37
2944: PUSH
2945: LD_INT 94
2947: PPUSH
2948: LD_INT 28
2950: PPUSH
2951: LD_STRING dammam
2953: PPUSH
2954: LD_VAR 0 5
2958: PPUSH
2959: LD_INT 10000
2961: PUSH
2962: LD_INT 1000
2964: PUSH
2965: LD_INT 300
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: LIST
2972: PPUSH
2973: LD_INT 12
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: LD_INT 4
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PUSH
2996: LD_INT 1
2998: NEG
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PPUSH
3009: CALL 56112 0 6
3013: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
3014: LD_ADDR_EXP 37
3018: PUSH
3019: LD_EXP 37
3023: PUSH
3024: LD_INT 122
3026: PPUSH
3027: LD_INT 25
3029: PPUSH
3030: LD_STRING 
3032: PPUSH
3033: LD_VAR 0 5
3037: PPUSH
3038: LD_INT 500
3040: PUSH
3041: LD_INT 60
3043: PUSH
3044: LD_INT 0
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PPUSH
3052: LD_INT 8
3054: PUSH
3055: LD_INT 2
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 4
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PUSH
3069: LD_OWVAR 67
3073: ARRAY
3074: PUSH
3075: LD_INT 2
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: PPUSH
3087: CALL 56112 0 6
3091: UNION
3092: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
3093: LD_ADDR_EXP 35
3097: PUSH
3098: LD_INT 45
3100: PPUSH
3101: LD_INT 24
3103: PPUSH
3104: LD_STRING jeddah
3106: PPUSH
3107: LD_VAR 0 5
3111: PPUSH
3112: LD_INT 700
3114: PUSH
3115: LD_INT 300
3117: PUSH
3118: LD_INT 10
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: LD_INT 10
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: LD_INT 3
3134: PUSH
3135: LD_INT 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PPUSH
3144: CALL 56112 0 6
3148: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3149: LD_ADDR_EXP 36
3153: PUSH
3154: LD_INT 7
3156: PPUSH
3157: LD_INT 27
3159: PPUSH
3160: LD_STRING riyadh
3162: PPUSH
3163: LD_VAR 0 5
3167: PPUSH
3168: LD_INT 500
3170: PUSH
3171: LD_INT 60
3173: PUSH
3174: LD_INT 0
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: PPUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 3
3190: PUSH
3191: LD_INT 1
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL 56112 0 6
3204: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
3205: LD_ADDR_EXP 39
3209: PUSH
3210: LD_INT 204
3212: PPUSH
3213: LD_INT 26
3215: PPUSH
3216: LD_STRING 
3218: PPUSH
3219: LD_VAR 0 5
3223: PPUSH
3224: LD_INT 500
3226: PUSH
3227: LD_INT 50
3229: PUSH
3230: LD_INT 0
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PPUSH
3238: LD_INT 10
3240: PUSH
3241: LD_INT 2
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL 56112 0 6
3260: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3261: LD_ADDR_EXP 50
3265: PUSH
3266: LD_EXP 37
3270: PUSH
3271: LD_EXP 35
3275: PUSH
3276: LD_EXP 39
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3286: LD_ADDR_VAR 0 2
3290: PUSH
3291: LD_INT 22
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 30
3303: PUSH
3304: LD_INT 31
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 58
3313: PUSH
3314: EMPTY
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: PUSH
3327: FOR_IN
3328: IFFALSE 3453
// begin if GetBase ( i ) then
3330: LD_VAR 0 2
3334: PPUSH
3335: CALL_OW 274
3339: IFFALSE 3343
// continue ;
3341: GO 3327
// d := GetDir ( i ) ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 254
3357: ST_TO_ADDR
// if d < 3 then
3358: LD_VAR 0 3
3362: PUSH
3363: LD_INT 3
3365: LESS
3366: IFFALSE 3384
// d := d + 3 else
3368: LD_ADDR_VAR 0 3
3372: PUSH
3373: LD_VAR 0 3
3377: PUSH
3378: LD_INT 3
3380: PLUS
3381: ST_TO_ADDR
3382: GO 3398
// d := d - 3 ;
3384: LD_ADDR_VAR 0 3
3388: PUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MINUS
3397: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 8
3403: PPUSH
3404: LD_VAR 0 5
3408: PPUSH
3409: CALL_OW 380
// un := CreateHuman ;
3413: LD_ADDR_VAR 0 4
3417: PUSH
3418: CALL_OW 44
3422: ST_TO_ADDR
// SetDir ( un , d ) ;
3423: LD_VAR 0 4
3427: PPUSH
3428: LD_VAR 0 3
3432: PPUSH
3433: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3437: LD_VAR 0 4
3441: PPUSH
3442: LD_VAR 0 2
3446: PPUSH
3447: CALL_OW 52
// end ;
3451: GO 3327
3453: POP
3454: POP
// if Difficulty > 1 then
3455: LD_OWVAR 67
3459: PUSH
3460: LD_INT 1
3462: GREATER
3463: IFFALSE 3834
// begin ar_kamikadze := [ ] ;
3465: LD_ADDR_EXP 42
3469: PUSH
3470: EMPTY
3471: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: CALL_OW 380
// un := CreateHuman ;
3487: LD_ADDR_VAR 0 4
3491: PUSH
3492: CALL_OW 44
3496: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3497: LD_VAR 0 4
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3509: LD_VAR 0 4
3513: PPUSH
3514: LD_INT 23
3516: PPUSH
3517: LD_INT 44
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 48
// ComCrawl ( un ) ;
3527: LD_VAR 0 4
3531: PPUSH
3532: CALL_OW 137
// un := CreateHuman ;
3536: LD_ADDR_VAR 0 4
3540: PUSH
3541: CALL_OW 44
3545: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3546: LD_VAR 0 4
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_INT 30
3565: PPUSH
3566: LD_INT 39
3568: PPUSH
3569: LD_INT 0
3571: PPUSH
3572: CALL_OW 48
// ComCrawl ( un ) ;
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3585: LD_INT 0
3587: PPUSH
3588: LD_INT 17
3590: PPUSH
3591: LD_VAR 0 5
3595: PPUSH
3596: CALL_OW 380
// un := CreateHuman ;
3600: LD_ADDR_VAR 0 4
3604: PUSH
3605: CALL_OW 44
3609: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3610: LD_VAR 0 4
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3622: LD_VAR 0 4
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 86
3632: PPUSH
3633: LD_INT 0
3635: PPUSH
3636: CALL_OW 48
// ComHold ( un ) ;
3640: LD_VAR 0 4
3644: PPUSH
3645: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3649: LD_ADDR_EXP 42
3653: PUSH
3654: LD_EXP 42
3658: PPUSH
3659: LD_EXP 42
3663: PUSH
3664: LD_INT 1
3666: PLUS
3667: PPUSH
3668: LD_VAR 0 4
3672: PPUSH
3673: CALL_OW 1
3677: ST_TO_ADDR
// un := CreateHuman ;
3678: LD_ADDR_VAR 0 4
3682: PUSH
3683: CALL_OW 44
3687: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3688: LD_VAR 0 4
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 60
3707: PPUSH
3708: LD_INT 85
3710: PPUSH
3711: LD_INT 0
3713: PPUSH
3714: CALL_OW 48
// ComHold ( un ) ;
3718: LD_VAR 0 4
3722: PPUSH
3723: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3727: LD_ADDR_EXP 42
3731: PUSH
3732: LD_EXP 42
3736: PPUSH
3737: LD_EXP 42
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_VAR 0 4
3750: PPUSH
3751: CALL_OW 1
3755: ST_TO_ADDR
// un := CreateHuman ;
3756: LD_ADDR_VAR 0 4
3760: PUSH
3761: CALL_OW 44
3765: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3766: LD_VAR 0 4
3770: PPUSH
3771: LD_INT 3
3773: PPUSH
3774: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3778: LD_VAR 0 4
3782: PPUSH
3783: LD_INT 222
3785: PPUSH
3786: LD_INT 166
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// ComHold ( un ) ;
3796: LD_VAR 0 4
3800: PPUSH
3801: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3805: LD_ADDR_EXP 42
3809: PUSH
3810: LD_EXP 42
3814: PPUSH
3815: LD_EXP 42
3819: PUSH
3820: LD_INT 1
3822: PLUS
3823: PPUSH
3824: LD_VAR 0 4
3828: PPUSH
3829: CALL_OW 1
3833: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3834: LD_ADDR_EXP 40
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3841: LD_INT 1
3843: PPUSH
3844: LD_INT 1
3846: PPUSH
3847: LD_VAR 0 5
3851: PPUSH
3852: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3856: LD_ADDR_OWVAR 26
3860: PUSH
3861: LD_STRING Pavel Grigorovic
3863: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3864: LD_ADDR_OWVAR 33
3868: PUSH
3869: LD_STRING SecondCharsGal
3871: ST_TO_ADDR
// hc_face_number := 4 ;
3872: LD_ADDR_OWVAR 34
3876: PUSH
3877: LD_INT 4
3879: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3880: LD_ADDR_EXP 40
3884: PUSH
3885: LD_EXP 40
3889: PPUSH
3890: LD_INT 1
3892: PPUSH
3893: CALL_OW 44
3897: PPUSH
3898: CALL_OW 1
3902: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3903: LD_INT 2
3905: PPUSH
3906: LD_INT 4
3908: PPUSH
3909: LD_INT 2
3911: PPUSH
3912: CALL_OW 380
// hc_name := Lucy Sebel ;
3916: LD_ADDR_OWVAR 26
3920: PUSH
3921: LD_STRING Lucy Sebel
3923: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3924: LD_ADDR_OWVAR 33
3928: PUSH
3929: LD_STRING SecondCharsGal
3931: ST_TO_ADDR
// hc_face_number := 15 ;
3932: LD_ADDR_OWVAR 34
3936: PUSH
3937: LD_INT 15
3939: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3940: LD_ADDR_EXP 40
3944: PUSH
3945: LD_EXP 40
3949: PPUSH
3950: LD_INT 2
3952: PPUSH
3953: CALL_OW 44
3957: PPUSH
3958: CALL_OW 1
3962: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3963: LD_INT 2
3965: PPUSH
3966: LD_INT 4
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: CALL_OW 380
// hc_gallery :=  ;
3976: LD_ADDR_OWVAR 33
3980: PUSH
3981: LD_STRING 
3983: ST_TO_ADDR
// hc_name :=  ;
3984: LD_ADDR_OWVAR 26
3988: PUSH
3989: LD_STRING 
3991: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3992: LD_ADDR_EXP 40
3996: PUSH
3997: LD_EXP 40
4001: PPUSH
4002: LD_INT 3
4004: PPUSH
4005: CALL_OW 44
4009: PPUSH
4010: CALL_OW 1
4014: ST_TO_ADDR
// hc_sex := sex_male ;
4015: LD_ADDR_OWVAR 27
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// hc_class = 11 ;
4023: LD_ADDR_OWVAR 28
4027: PUSH
4028: LD_INT 11
4030: ST_TO_ADDR
// hc_gallery = sandar ;
4031: LD_ADDR_OWVAR 33
4035: PUSH
4036: LD_STRING sandar
4038: ST_TO_ADDR
// hc_face_number = 33 ;
4039: LD_ADDR_OWVAR 34
4043: PUSH
4044: LD_INT 33
4046: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4047: LD_ADDR_OWVAR 26
4051: PUSH
4052: LD_STRING Thabit Muhair Saliba
4054: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4055: LD_ADDR_OWVAR 31
4059: PUSH
4060: LD_INT 0
4062: PUSH
4063: LD_INT 0
4065: PUSH
4066: LD_INT 0
4068: PUSH
4069: LD_INT 0
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: ST_TO_ADDR
// Saliba = CreateHuman ;
4078: LD_ADDR_EXP 44
4082: PUSH
4083: CALL_OW 44
4087: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4088: LD_EXP 44
4092: PPUSH
4093: LD_INT 7
4095: PPUSH
4096: CALL_OW 52
// if gensher_active then
4100: LD_EXP 18
4104: IFFALSE 4131
// begin Gensher = NewCharacter ( Dietrich ) ;
4106: LD_ADDR_EXP 45
4110: PUSH
4111: LD_STRING Dietrich
4113: PPUSH
4114: CALL_OW 25
4118: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4119: LD_EXP 45
4123: PPUSH
4124: LD_INT 94
4126: PPUSH
4127: CALL_OW 52
// end ; InitHc ;
4131: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4135: LD_ADDR_EXP 41
4139: PUSH
4140: EMPTY
4141: ST_TO_ADDR
// for i = 1 to 5 do
4142: LD_ADDR_VAR 0 2
4146: PUSH
4147: DOUBLE
4148: LD_INT 1
4150: DEC
4151: ST_TO_ADDR
4152: LD_INT 5
4154: PUSH
4155: FOR_TO
4156: IFFALSE 4328
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4158: LD_INT 13
4160: PUSH
4161: LD_INT 14
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 2
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 1
4182: PUSH
4183: LD_INT 2
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: PUSH
4190: LD_INT 1
4192: PPUSH
4193: LD_INT 2
4195: PPUSH
4196: CALL_OW 12
4200: ARRAY
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 25
4207: PUSH
4208: LD_INT 27
4210: PUSH
4211: LD_INT 26
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 60
4233: PPUSH
4234: LD_INT 100
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 52703 0 5
// un := CreateVehicle ;
4246: LD_ADDR_VAR 0 4
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4256: LD_ADDR_EXP 41
4260: PUSH
4261: LD_EXP 41
4265: PPUSH
4266: LD_EXP 41
4270: PUSH
4271: LD_INT 1
4273: PLUS
4274: PPUSH
4275: LD_VAR 0 4
4279: PPUSH
4280: CALL_OW 1
4284: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4285: LD_VAR 0 4
4289: PPUSH
4290: LD_INT 0
4292: PPUSH
4293: LD_INT 5
4295: PPUSH
4296: CALL_OW 12
4300: PPUSH
4301: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4305: LD_VAR 0 4
4309: PPUSH
4310: LD_INT 124
4312: PPUSH
4313: LD_INT 141
4315: PPUSH
4316: LD_INT 8
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL_OW 50
// end ;
4326: GO 4155
4328: POP
4329: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4330: LD_ADDR_EXP 43
4334: PUSH
4335: EMPTY
4336: PUSH
4337: EMPTY
4338: PUSH
4339: EMPTY
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: LIST
4345: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
4346: LD_ADDR_VAR 0 3
4350: PUSH
4351: DOUBLE
4352: LD_INT 1
4354: DEC
4355: ST_TO_ADDR
4356: LD_INT 3
4358: PUSH
4359: LD_INT 3
4361: PUSH
4362: LD_INT 4
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: PUSH
4370: LD_OWVAR 67
4374: ARRAY
4375: PUSH
4376: FOR_TO
4377: IFFALSE 4591
// for i = 1 to 3 do
4379: LD_ADDR_VAR 0 2
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4587
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4395: LD_INT 14
4397: PPUSH
4398: LD_INT 3
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 2
4413: PPUSH
4414: CALL_OW 12
4418: ARRAY
4419: PPUSH
4420: LD_INT 1
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 2
4435: PPUSH
4436: CALL_OW 12
4440: ARRAY
4441: PPUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 27
4447: PUSH
4448: LD_INT 26
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 1
4462: PPUSH
4463: LD_INT 4
4465: PPUSH
4466: CALL_OW 12
4470: ARRAY
4471: PPUSH
4472: LD_INT 100
4474: PPUSH
4475: CALL 52703 0 5
// un := CreateVehicle ;
4479: LD_ADDR_VAR 0 4
4483: PUSH
4484: CALL_OW 45
4488: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4489: LD_ADDR_EXP 43
4493: PUSH
4494: LD_EXP 43
4498: PPUSH
4499: LD_VAR 0 2
4503: PUSH
4504: LD_EXP 43
4508: PUSH
4509: LD_VAR 0 2
4513: ARRAY
4514: PUSH
4515: LD_INT 1
4517: PLUS
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PPUSH
4523: LD_VAR 0 4
4527: PPUSH
4528: CALL 52825 0 3
4532: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4533: LD_VAR 0 4
4537: PPUSH
4538: LD_INT 0
4540: PPUSH
4541: LD_INT 5
4543: PPUSH
4544: CALL_OW 12
4548: PPUSH
4549: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4553: LD_VAR 0 4
4557: PPUSH
4558: LD_INT 20
4560: PUSH
4561: LD_INT 21
4563: PUSH
4564: LD_INT 22
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: ARRAY
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 49
// end ;
4585: GO 4392
4587: POP
4588: POP
4589: GO 4376
4591: POP
4592: POP
// InitHc ;
4593: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4597: LD_INT 4
4599: PPUSH
4600: LD_INT 5
4602: PPUSH
4603: LD_INT 10
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: CALL_OW 58
// end ;
4616: LD_VAR 0 1
4620: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4621: LD_EXP 42
4625: IFFALSE 4699
4627: GO 4629
4629: DISABLE
4630: LD_INT 0
4632: PPUSH
// begin enable ;
4633: ENABLE
// for i in ar_kamikadze do
4634: LD_ADDR_VAR 0 1
4638: PUSH
4639: LD_EXP 42
4643: PUSH
4644: FOR_IN
4645: IFFALSE 4697
// if See ( 1 , i ) then
4647: LD_INT 1
4649: PPUSH
4650: LD_VAR 0 1
4654: PPUSH
4655: CALL_OW 292
4659: IFFALSE 4695
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4661: LD_VAR 0 1
4665: PPUSH
4666: LD_INT 81
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: PPUSH
4681: LD_VAR 0 1
4685: PPUSH
4686: CALL_OW 74
4690: PPUSH
4691: CALL_OW 115
4695: GO 4644
4697: POP
4698: POP
// end ;
4699: PPOPN 1
4701: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4702: LD_EXP 13
4706: IFFALSE 5023
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
4716: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4717: LD_INT 35
4719: PPUSH
4720: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4724: LD_INT 1
4726: PPUSH
4727: CALL 41864 0 1
4731: PUSH
4732: LD_INT 0
4734: EQUAL
4735: IFFALSE 4717
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4737: LD_INT 1
4739: PPUSH
4740: LD_INT 14
4742: PUSH
4743: LD_INT 3
4745: PUSH
4746: LD_INT 2
4748: PUSH
4749: LD_INT 32
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: PPUSH
4761: CALL 41468 0 2
// repeat wait ( 0 0$1 ) ;
4765: LD_INT 35
4767: PPUSH
4768: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4772: LD_EXP 69
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PPUSH
4781: LD_INT 33
4783: PUSH
4784: LD_INT 2
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PUSH
4791: LD_INT 34
4793: PUSH
4794: LD_INT 32
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PPUSH
4805: CALL_OW 72
4809: IFFALSE 4765
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4811: LD_ADDR_VAR 0 2
4815: PUSH
4816: LD_EXP 69
4820: PUSH
4821: LD_INT 1
4823: ARRAY
4824: PPUSH
4825: LD_INT 33
4827: PUSH
4828: LD_INT 2
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PUSH
4835: LD_INT 34
4837: PUSH
4838: LD_INT 32
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PPUSH
4849: CALL_OW 72
4853: PUSH
4854: LD_INT 1
4856: ARRAY
4857: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4858: LD_ADDR_VAR 0 4
4862: PUSH
4863: LD_INT 5
4865: PPUSH
4866: CALL_OW 469
4870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4871: LD_INT 35
4873: PPUSH
4874: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_INT 5
4885: PPUSH
4886: CALL_OW 469
4890: ST_TO_ADDR
// tmp := 100 ;
4891: LD_ADDR_VAR 0 3
4895: PUSH
4896: LD_INT 100
4898: ST_TO_ADDR
// if pos then
4899: LD_VAR 0 4
4903: IFFALSE 4943
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4905: LD_ADDR_VAR 0 3
4909: PUSH
4910: LD_INT 2
4912: PPUSH
4913: LD_VAR 0 4
4917: PUSH
4918: LD_INT 1
4920: ARRAY
4921: PPUSH
4922: LD_VAR 0 4
4926: PUSH
4927: LD_INT 2
4929: ARRAY
4930: PPUSH
4931: LD_INT 20
4933: PPUSH
4934: CALL 53721 0 4
4938: PUSH
4939: LD_INT 4
4941: ARRAY
4942: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4943: LD_VAR 0 4
4947: PUSH
4948: LD_EXP 14
4952: NOT
4953: AND
4954: PUSH
4955: LD_VAR 0 3
4959: PUSH
4960: LD_INT 10
4962: LESS
4963: AND
4964: IFFALSE 4871
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4966: LD_VAR 0 2
4970: PPUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_INT 1
4978: ARRAY
4979: PPUSH
4980: LD_VAR 0 4
4984: PUSH
4985: LD_INT 2
4987: ARRAY
4988: PPUSH
4989: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_INT 198
5000: PPUSH
5001: LD_INT 113
5003: PPUSH
5004: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 124
5015: PPUSH
5016: LD_INT 7
5018: PPUSH
5019: CALL_OW 171
// end ;
5023: PPOPN 4
5025: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5026: LD_EXP 6
5030: IFFALSE 7811
5032: GO 5034
5034: DISABLE
5035: LD_INT 0
5037: PPUSH
5038: PPUSH
5039: PPUSH
5040: PPUSH
5041: PPUSH
5042: PPUSH
5043: PPUSH
5044: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
5045: LD_ADDR_VAR 0 4
5049: PUSH
5050: LD_INT 5
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: LD_INT 7
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: LIST
5063: PUSH
5064: LD_OWVAR 67
5068: ARRAY
5069: ST_TO_ADDR
// coords := [ ] ;
5070: LD_ADDR_VAR 0 5
5074: PUSH
5075: EMPTY
5076: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5077: LD_ADDR_VAR 0 6
5081: PUSH
5082: LD_INT 0
5084: PUSH
5085: LD_INT 0
5087: PUSH
5088: LD_INT 0
5090: PUSH
5091: LD_INT 0
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: LD_INT 0
5099: PUSH
5100: LD_INT 0
5102: PUSH
5103: LD_INT 0
5105: PUSH
5106: LD_INT 1
5108: PUSH
5109: LD_INT 0
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: LIST
5123: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5124: LD_INT 1
5126: PPUSH
5127: LD_INT 14
5129: PUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 2
5135: PUSH
5136: LD_INT 28
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 14
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: LD_INT 2
5153: PUSH
5154: LD_INT 25
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 14
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: LD_INT 2
5171: PUSH
5172: LD_INT 28
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: LIST
5180: PUSH
5181: LD_INT 14
5183: PUSH
5184: LD_INT 1
5186: PUSH
5187: LD_INT 2
5189: PUSH
5190: LD_INT 29
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: PPUSH
5205: CALL 41468 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
5209: LD_INT 21000
5211: PUSH
5212: LD_INT 19950
5214: PUSH
5215: LD_INT 18900
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_OWVAR 67
5227: ARRAY
5228: PPUSH
5229: CALL_OW 67
// InitHc ;
5233: CALL_OW 19
// InitUc ;
5237: CALL_OW 18
// uc_side := 2 ;
5241: LD_ADDR_OWVAR 20
5245: PUSH
5246: LD_INT 2
5248: ST_TO_ADDR
// uc_nation := 2 ;
5249: LD_ADDR_OWVAR 21
5253: PUSH
5254: LD_INT 2
5256: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: EMPTY
5263: PUSH
5264: EMPTY
5265: PUSH
5266: EMPTY
5267: PUSH
5268: EMPTY
5269: PUSH
5270: EMPTY
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
5279: LD_ADDR_VAR 0 3
5283: PUSH
5284: LD_VAR 0 3
5288: PPUSH
5289: LD_INT 1
5291: PPUSH
5292: LD_EXP 69
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PUSH
5301: LD_INT 34
5303: PUSH
5304: LD_INT 32
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: PPUSH
5311: CALL_OW 69
5315: DIFF
5316: PPUSH
5317: CALL_OW 1
5321: ST_TO_ADDR
// for i = 1 to Difficulty do
5322: LD_ADDR_VAR 0 1
5326: PUSH
5327: DOUBLE
5328: LD_INT 1
5330: DEC
5331: ST_TO_ADDR
5332: LD_OWVAR 67
5336: PUSH
5337: FOR_TO
5338: IFFALSE 5476
// begin uc_side := 2 ;
5340: LD_ADDR_OWVAR 20
5344: PUSH
5345: LD_INT 2
5347: ST_TO_ADDR
// uc_nation := 2 ;
5348: LD_ADDR_OWVAR 21
5352: PUSH
5353: LD_INT 2
5355: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5356: LD_INT 13
5358: PPUSH
5359: LD_INT 3
5361: PPUSH
5362: LD_INT 5
5364: PPUSH
5365: LD_INT 29
5367: PPUSH
5368: LD_INT 100
5370: PPUSH
5371: CALL 52703 0 5
// un := CreateVehicle ;
5375: LD_ADDR_VAR 0 2
5379: PUSH
5380: CALL_OW 45
5384: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5385: LD_ADDR_VAR 0 3
5389: PUSH
5390: LD_VAR 0 3
5394: PPUSH
5395: LD_INT 1
5397: PUSH
5398: LD_VAR 0 3
5402: PUSH
5403: LD_INT 1
5405: ARRAY
5406: PUSH
5407: LD_INT 1
5409: PLUS
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PPUSH
5415: LD_VAR 0 2
5419: PPUSH
5420: CALL 52825 0 3
5424: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5425: LD_VAR 0 2
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5437: LD_VAR 0 2
5441: PPUSH
5442: LD_INT 16
5444: PPUSH
5445: LD_INT 0
5447: PPUSH
5448: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5452: LD_VAR 0 2
5456: PPUSH
5457: LD_INT 51
5459: PPUSH
5460: LD_INT 10
5462: PPUSH
5463: CALL_OW 111
// wait ( 0 0$2 ) ;
5467: LD_INT 70
5469: PPUSH
5470: CALL_OW 67
// end ;
5474: GO 5337
5476: POP
5477: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5478: LD_ADDR_VAR 0 5
5482: PUSH
5483: LD_INT 51
5485: PUSH
5486: LD_INT 24
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 75
5495: PUSH
5496: LD_INT 90
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5507: LD_INT 1
5509: PPUSH
5510: LD_VAR 0 3
5514: PUSH
5515: LD_INT 1
5517: ARRAY
5518: PPUSH
5519: LD_VAR 0 5
5523: PPUSH
5524: LD_VAR 0 6
5528: PPUSH
5529: CALL 41701 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5533: LD_ADDR_VAR 0 1
5537: PUSH
5538: DOUBLE
5539: LD_INT 1
5541: DEC
5542: ST_TO_ADDR
5543: LD_INT 1
5545: PUSH
5546: LD_INT 3
5548: PUSH
5549: LD_INT 3
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: LIST
5556: PUSH
5557: LD_OWVAR 67
5561: ARRAY
5562: PUSH
5563: FOR_TO
5564: IFFALSE 5664
// begin uc_side := 2 ;
5566: LD_ADDR_OWVAR 20
5570: PUSH
5571: LD_INT 2
5573: ST_TO_ADDR
// uc_nation := 2 ;
5574: LD_ADDR_OWVAR 21
5578: PUSH
5579: LD_INT 2
5581: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5582: LD_INT 0
5584: PPUSH
5585: LD_INT 17
5587: PPUSH
5588: LD_VAR 0 4
5592: PPUSH
5593: CALL_OW 380
// un := CreateHuman ;
5597: LD_ADDR_VAR 0 2
5601: PUSH
5602: CALL_OW 44
5606: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5607: LD_ADDR_VAR 0 3
5611: PUSH
5612: LD_VAR 0 3
5616: PPUSH
5617: LD_INT 2
5619: PUSH
5620: LD_VAR 0 3
5624: PUSH
5625: LD_INT 2
5627: ARRAY
5628: PUSH
5629: LD_INT 1
5631: PLUS
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PPUSH
5637: LD_VAR 0 2
5641: PPUSH
5642: CALL 52825 0 3
5646: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5647: LD_VAR 0 2
5651: PPUSH
5652: LD_INT 13
5654: PPUSH
5655: LD_INT 0
5657: PPUSH
5658: CALL_OW 49
// end ;
5662: GO 5563
5664: POP
5665: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5666: LD_ADDR_VAR 0 1
5670: PUSH
5671: DOUBLE
5672: LD_INT 1
5674: DEC
5675: ST_TO_ADDR
5676: LD_INT 3
5678: PUSH
5679: LD_INT 4
5681: PUSH
5682: LD_INT 4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_OWVAR 67
5694: ARRAY
5695: PUSH
5696: FOR_TO
5697: IFFALSE 5818
// begin uc_side := 2 ;
5699: LD_ADDR_OWVAR 20
5703: PUSH
5704: LD_INT 2
5706: ST_TO_ADDR
// uc_nation := 2 ;
5707: LD_ADDR_OWVAR 21
5711: PUSH
5712: LD_INT 2
5714: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5715: LD_INT 0
5717: PPUSH
5718: LD_INT 1
5720: PUSH
5721: LD_INT 8
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_VAR 0 1
5732: PUSH
5733: LD_INT 2
5735: MOD
5736: PUSH
5737: LD_INT 1
5739: PLUS
5740: ARRAY
5741: PPUSH
5742: LD_VAR 0 4
5746: PPUSH
5747: CALL_OW 380
// un := CreateHuman ;
5751: LD_ADDR_VAR 0 2
5755: PUSH
5756: CALL_OW 44
5760: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5761: LD_ADDR_VAR 0 3
5765: PUSH
5766: LD_VAR 0 3
5770: PPUSH
5771: LD_INT 2
5773: PUSH
5774: LD_VAR 0 3
5778: PUSH
5779: LD_INT 2
5781: ARRAY
5782: PUSH
5783: LD_INT 1
5785: PLUS
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: PPUSH
5791: LD_VAR 0 2
5795: PPUSH
5796: CALL 52825 0 3
5800: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5801: LD_VAR 0 2
5805: PPUSH
5806: LD_INT 13
5808: PPUSH
5809: LD_INT 0
5811: PPUSH
5812: CALL_OW 49
// end ;
5816: GO 5696
5818: POP
5819: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5820: LD_ADDR_VAR 0 5
5824: PUSH
5825: LD_INT 67
5827: PUSH
5828: LD_INT 112
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: PUSH
5835: LD_INT 85
5837: PUSH
5838: LD_INT 130
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5849: LD_INT 2
5851: PPUSH
5852: LD_VAR 0 3
5856: PUSH
5857: LD_INT 2
5859: ARRAY
5860: PPUSH
5861: LD_VAR 0 5
5865: PPUSH
5866: LD_VAR 0 6
5870: PPUSH
5871: CALL 41701 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5875: LD_ADDR_VAR 0 1
5879: PUSH
5880: DOUBLE
5881: LD_INT 1
5883: DEC
5884: ST_TO_ADDR
5885: LD_INT 1
5887: PUSH
5888: LD_INT 2
5890: PUSH
5891: LD_INT 3
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_OWVAR 67
5903: ARRAY
5904: PUSH
5905: FOR_TO
5906: IFFALSE 6006
// begin uc_side := 2 ;
5908: LD_ADDR_OWVAR 20
5912: PUSH
5913: LD_INT 2
5915: ST_TO_ADDR
// uc_nation := 2 ;
5916: LD_ADDR_OWVAR 21
5920: PUSH
5921: LD_INT 2
5923: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5924: LD_INT 0
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_VAR 0 4
5934: PPUSH
5935: CALL_OW 380
// un := CreateHuman ;
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: CALL_OW 44
5948: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5949: LD_ADDR_VAR 0 3
5953: PUSH
5954: LD_VAR 0 3
5958: PPUSH
5959: LD_INT 3
5961: PUSH
5962: LD_VAR 0 3
5966: PUSH
5967: LD_INT 3
5969: ARRAY
5970: PUSH
5971: LD_INT 1
5973: PLUS
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PPUSH
5979: LD_VAR 0 2
5983: PPUSH
5984: CALL 52825 0 3
5988: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5989: LD_VAR 0 2
5993: PPUSH
5994: LD_INT 14
5996: PPUSH
5997: LD_INT 0
5999: PPUSH
6000: CALL_OW 49
// end ;
6004: GO 5905
6006: POP
6007: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6008: LD_ADDR_VAR 0 5
6012: PUSH
6013: LD_INT 148
6015: PUSH
6016: LD_INT 158
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 148
6025: PUSH
6026: LD_INT 158
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6037: LD_INT 3
6039: PPUSH
6040: LD_VAR 0 3
6044: PUSH
6045: LD_INT 3
6047: ARRAY
6048: PPUSH
6049: LD_VAR 0 5
6053: PPUSH
6054: LD_VAR 0 6
6058: PPUSH
6059: CALL 41701 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
6063: LD_ADDR_VAR 0 1
6067: PUSH
6068: DOUBLE
6069: LD_INT 1
6071: DEC
6072: ST_TO_ADDR
6073: LD_INT 2
6075: PUSH
6076: LD_INT 4
6078: PUSH
6079: LD_INT 4
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: LIST
6086: PUSH
6087: LD_OWVAR 67
6091: ARRAY
6092: PUSH
6093: FOR_TO
6094: IFFALSE 6318
// begin uc_side := 2 ;
6096: LD_ADDR_OWVAR 20
6100: PUSH
6101: LD_INT 2
6103: ST_TO_ADDR
// uc_nation := 2 ;
6104: LD_ADDR_OWVAR 21
6108: PUSH
6109: LD_INT 2
6111: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6112: LD_INT 14
6114: PPUSH
6115: LD_INT 3
6117: PPUSH
6118: LD_INT 1
6120: PUSH
6121: LD_INT 5
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 1
6130: PPUSH
6131: LD_INT 2
6133: PPUSH
6134: CALL_OW 12
6138: ARRAY
6139: PPUSH
6140: LD_INT 27
6142: PUSH
6143: LD_INT 26
6145: PUSH
6146: LD_INT 28
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 1
6156: PPUSH
6157: LD_INT 3
6159: PPUSH
6160: CALL_OW 12
6164: ARRAY
6165: PPUSH
6166: LD_INT 100
6168: PPUSH
6169: CALL 52703 0 5
// un := CreateVehicle ;
6173: LD_ADDR_VAR 0 2
6177: PUSH
6178: CALL_OW 45
6182: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6183: LD_ADDR_VAR 0 3
6187: PUSH
6188: LD_VAR 0 3
6192: PPUSH
6193: LD_INT 4
6195: PUSH
6196: LD_VAR 0 3
6200: PUSH
6201: LD_INT 4
6203: ARRAY
6204: PUSH
6205: LD_INT 1
6207: PLUS
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PPUSH
6213: LD_VAR 0 2
6217: PPUSH
6218: CALL 52825 0 3
6222: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6223: LD_VAR 0 2
6227: PPUSH
6228: LD_INT 5
6230: PPUSH
6231: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6235: LD_VAR 0 2
6239: PPUSH
6240: LD_INT 15
6242: PPUSH
6243: LD_INT 0
6245: PPUSH
6246: CALL_OW 49
// if GetControl ( un ) = control_manual then
6250: LD_VAR 0 2
6254: PPUSH
6255: CALL_OW 263
6259: PUSH
6260: LD_INT 1
6262: EQUAL
6263: IFFALSE 6294
// begin PrepareHuman ( false , 3 , skill ) ;
6265: LD_INT 0
6267: PPUSH
6268: LD_INT 3
6270: PPUSH
6271: LD_VAR 0 4
6275: PPUSH
6276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6280: CALL_OW 44
6284: PPUSH
6285: LD_VAR 0 2
6289: PPUSH
6290: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6294: LD_VAR 0 2
6298: PPUSH
6299: LD_INT 179
6301: PPUSH
6302: LD_INT 135
6304: PPUSH
6305: CALL_OW 111
// wait ( 0 0$2 ) ;
6309: LD_INT 70
6311: PPUSH
6312: CALL_OW 67
// end ;
6316: GO 6093
6318: POP
6319: POP
// vc_chassis := 15 ;
6320: LD_ADDR_OWVAR 37
6324: PUSH
6325: LD_INT 15
6327: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6328: LD_ADDR_VAR 0 3
6332: PUSH
6333: LD_VAR 0 3
6337: PPUSH
6338: LD_INT 4
6340: PUSH
6341: LD_VAR 0 3
6345: PUSH
6346: LD_INT 4
6348: ARRAY
6349: PUSH
6350: LD_INT 1
6352: PLUS
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PPUSH
6358: CALL_OW 45
6362: PPUSH
6363: CALL 52825 0 3
6367: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6368: LD_VAR 0 3
6372: PUSH
6373: LD_INT 4
6375: ARRAY
6376: PUSH
6377: LD_VAR 0 3
6381: PUSH
6382: LD_INT 4
6384: ARRAY
6385: ARRAY
6386: PPUSH
6387: LD_INT 15
6389: PPUSH
6390: LD_INT 0
6392: PPUSH
6393: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6397: LD_INT 0
6399: PPUSH
6400: LD_INT 11
6402: PPUSH
6403: LD_VAR 0 4
6407: PPUSH
6408: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6412: LD_ADDR_VAR 0 3
6416: PUSH
6417: LD_VAR 0 3
6421: PPUSH
6422: LD_INT 4
6424: PUSH
6425: LD_VAR 0 3
6429: PUSH
6430: LD_INT 4
6432: ARRAY
6433: PUSH
6434: LD_INT 1
6436: PLUS
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PPUSH
6442: CALL_OW 44
6446: PPUSH
6447: CALL 52825 0 3
6451: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6452: LD_VAR 0 3
6456: PUSH
6457: LD_INT 4
6459: ARRAY
6460: PUSH
6461: LD_VAR 0 3
6465: PUSH
6466: LD_INT 4
6468: ARRAY
6469: ARRAY
6470: PPUSH
6471: LD_VAR 0 3
6475: PUSH
6476: LD_INT 4
6478: ARRAY
6479: PUSH
6480: LD_VAR 0 3
6484: PUSH
6485: LD_INT 4
6487: ARRAY
6488: PUSH
6489: LD_INT 1
6491: MINUS
6492: ARRAY
6493: PPUSH
6494: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6498: LD_ADDR_VAR 0 5
6502: PUSH
6503: LD_INT 148
6505: PUSH
6506: LD_INT 140
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: EMPTY
6514: LIST
6515: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6516: LD_INT 1
6518: PPUSH
6519: LD_VAR 0 3
6523: PUSH
6524: LD_INT 4
6526: ARRAY
6527: PPUSH
6528: LD_VAR 0 5
6532: PPUSH
6533: LD_VAR 0 6
6537: PPUSH
6538: CALL 41701 0 4
// if gensher_active then
6542: LD_EXP 18
6546: IFFALSE 6948
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6548: LD_EXP 45
6552: PPUSH
6553: LD_STRING D10-Diet-1
6555: PPUSH
6556: CALL_OW 94
// for i = 1 to 2 do
6560: LD_ADDR_VAR 0 1
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 2
6572: PUSH
6573: FOR_TO
6574: IFFALSE 6712
// begin uc_side := 2 ;
6576: LD_ADDR_OWVAR 20
6580: PUSH
6581: LD_INT 2
6583: ST_TO_ADDR
// uc_nation := 2 ;
6584: LD_ADDR_OWVAR 21
6588: PUSH
6589: LD_INT 2
6591: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6592: LD_INT 13
6594: PPUSH
6595: LD_INT 3
6597: PPUSH
6598: LD_INT 5
6600: PPUSH
6601: LD_INT 29
6603: PPUSH
6604: LD_INT 100
6606: PPUSH
6607: CALL 52703 0 5
// un := CreateVehicle ;
6611: LD_ADDR_VAR 0 2
6615: PUSH
6616: CALL_OW 45
6620: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6621: LD_ADDR_VAR 0 3
6625: PUSH
6626: LD_VAR 0 3
6630: PPUSH
6631: LD_INT 5
6633: PUSH
6634: LD_VAR 0 3
6638: PUSH
6639: LD_INT 5
6641: ARRAY
6642: PUSH
6643: LD_INT 1
6645: PLUS
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: PPUSH
6651: LD_VAR 0 2
6655: PPUSH
6656: CALL 52825 0 3
6660: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6661: LD_VAR 0 2
6665: PPUSH
6666: LD_INT 0
6668: PPUSH
6669: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6673: LD_VAR 0 2
6677: PPUSH
6678: LD_INT 23
6680: PPUSH
6681: LD_INT 0
6683: PPUSH
6684: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6688: LD_VAR 0 2
6692: PPUSH
6693: LD_INT 85
6695: PPUSH
6696: LD_INT 152
6698: PPUSH
6699: CALL_OW 111
// wait ( 0 0$2 ) ;
6703: LD_INT 70
6705: PPUSH
6706: CALL_OW 67
// end ;
6710: GO 6573
6712: POP
6713: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6714: LD_ADDR_VAR 0 1
6718: PUSH
6719: DOUBLE
6720: LD_INT 1
6722: DEC
6723: ST_TO_ADDR
6724: LD_INT 2
6726: PUSH
6727: LD_INT 3
6729: PUSH
6730: LD_INT 3
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: LIST
6737: PUSH
6738: LD_OWVAR 67
6742: ARRAY
6743: PUSH
6744: FOR_TO
6745: IFFALSE 6902
// begin uc_side := 2 ;
6747: LD_ADDR_OWVAR 20
6751: PUSH
6752: LD_INT 2
6754: ST_TO_ADDR
// uc_nation := 2 ;
6755: LD_ADDR_OWVAR 21
6759: PUSH
6760: LD_INT 2
6762: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6763: LD_INT 14
6765: PPUSH
6766: LD_INT 3
6768: PPUSH
6769: LD_INT 5
6771: PPUSH
6772: LD_INT 27
6774: PUSH
6775: LD_INT 28
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: PUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 2
6787: PPUSH
6788: CALL_OW 12
6792: ARRAY
6793: PPUSH
6794: LD_INT 100
6796: PPUSH
6797: CALL 52703 0 5
// un := CreateVehicle ;
6801: LD_ADDR_VAR 0 2
6805: PUSH
6806: CALL_OW 45
6810: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6811: LD_ADDR_VAR 0 3
6815: PUSH
6816: LD_VAR 0 3
6820: PPUSH
6821: LD_INT 5
6823: PUSH
6824: LD_VAR 0 3
6828: PUSH
6829: LD_INT 5
6831: ARRAY
6832: PUSH
6833: LD_INT 1
6835: PLUS
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: PPUSH
6841: LD_VAR 0 2
6845: PPUSH
6846: CALL 52825 0 3
6850: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 0
6858: PPUSH
6859: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6863: LD_VAR 0 2
6867: PPUSH
6868: LD_INT 23
6870: PPUSH
6871: LD_INT 0
6873: PPUSH
6874: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6878: LD_VAR 0 2
6882: PPUSH
6883: LD_INT 85
6885: PPUSH
6886: LD_INT 152
6888: PPUSH
6889: CALL_OW 111
// wait ( 0 0$2 ) ;
6893: LD_INT 70
6895: PPUSH
6896: CALL_OW 67
// end ;
6900: GO 6744
6902: POP
6903: POP
// coords := [ [ 97 , 143 ] ] ;
6904: LD_ADDR_VAR 0 5
6908: PUSH
6909: LD_INT 97
6911: PUSH
6912: LD_INT 143
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PUSH
6919: EMPTY
6920: LIST
6921: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6922: LD_INT 1
6924: PPUSH
6925: LD_VAR 0 3
6929: PUSH
6930: LD_INT 5
6932: ARRAY
6933: PPUSH
6934: LD_VAR 0 5
6938: PPUSH
6939: LD_VAR 0 6
6943: PPUSH
6944: CALL 41701 0 4
// end ; Wait ( 13 13$00 ) ;
6948: LD_INT 27300
6950: PPUSH
6951: CALL_OW 67
// tmp := [ ] ;
6955: LD_ADDR_VAR 0 3
6959: PUSH
6960: EMPTY
6961: ST_TO_ADDR
// w := 1 ;
6962: LD_ADDR_VAR 0 7
6966: PUSH
6967: LD_INT 1
6969: ST_TO_ADDR
// repeat tmp := [ ] ;
6970: LD_ADDR_VAR 0 3
6974: PUSH
6975: EMPTY
6976: ST_TO_ADDR
// if w mod 4 = 0 then
6977: LD_VAR 0 7
6981: PUSH
6982: LD_INT 4
6984: MOD
6985: PUSH
6986: LD_INT 0
6988: EQUAL
6989: IFFALSE 7076
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6991: LD_ADDR_VAR 0 8
6995: PUSH
6996: LD_INT 11
6998: PUSH
6999: LD_INT 1
7001: PUSH
7002: LD_INT 2
7004: PUSH
7005: LD_INT 24
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: LIST
7012: LIST
7013: PUSH
7014: LD_INT 11
7016: PUSH
7017: LD_INT 1
7019: PUSH
7020: LD_INT 2
7022: PUSH
7023: LD_INT 24
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: PUSH
7032: LD_INT 11
7034: PUSH
7035: LD_INT 1
7037: PUSH
7038: LD_INT 2
7040: PUSH
7041: LD_INT 24
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 11
7052: PUSH
7053: LD_INT 1
7055: PUSH
7056: LD_INT 2
7058: PUSH
7059: LD_INT 24
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: LIST
7066: LIST
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: ST_TO_ADDR
7074: GO 7178
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7076: LD_ADDR_VAR 0 8
7080: PUSH
7081: LD_INT 14
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: LD_INT 2
7089: PUSH
7090: LD_INT 28
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: PUSH
7099: LD_INT 14
7101: PUSH
7102: LD_INT 1
7104: PUSH
7105: LD_INT 2
7107: PUSH
7108: LD_INT 25
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 14
7119: PUSH
7120: LD_INT 1
7122: PUSH
7123: LD_INT 2
7125: PUSH
7126: LD_INT 28
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: LIST
7133: LIST
7134: PUSH
7135: LD_INT 14
7137: PUSH
7138: LD_INT 1
7140: PUSH
7141: LD_INT 2
7143: PUSH
7144: LD_INT 29
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: LIST
7151: LIST
7152: PUSH
7153: LD_INT 11
7155: PUSH
7156: LD_INT 1
7158: PUSH
7159: LD_INT 2
7161: PUSH
7162: LD_INT 24
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: ST_TO_ADDR
// if w mod 3 = 0 then
7178: LD_VAR 0 7
7182: PUSH
7183: LD_INT 3
7185: MOD
7186: PUSH
7187: LD_INT 0
7189: EQUAL
7190: IFFALSE 7266
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7192: LD_ADDR_VAR 0 8
7196: PUSH
7197: LD_VAR 0 8
7201: PPUSH
7202: LD_INT 1
7204: PUSH
7205: LD_VAR 0 8
7209: PUSH
7210: LD_VAR 0 1
7214: ARRAY
7215: PUSH
7216: LD_INT 1
7218: PLUS
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PPUSH
7224: LD_INT 14
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: LD_INT 2
7232: PUSH
7233: LD_INT 25
7235: PUSH
7236: LD_INT 28
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: LD_INT 1
7245: PPUSH
7246: LD_INT 2
7248: PPUSH
7249: CALL_OW 12
7253: ARRAY
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: PPUSH
7261: CALL 52825 0 3
7265: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7266: LD_INT 1
7268: PPUSH
7269: LD_VAR 0 8
7273: PPUSH
7274: CALL 41468 0 2
// if GetSide ( ar_dep_w ) = 2 then
7278: LD_INT 45
7280: PPUSH
7281: CALL_OW 255
7285: PUSH
7286: LD_INT 2
7288: EQUAL
7289: IFFALSE 7374
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7291: LD_ADDR_VAR 0 8
7295: PUSH
7296: LD_INT 14
7298: PUSH
7299: LD_INT 1
7301: PUSH
7302: LD_INT 2
7304: PUSH
7305: LD_INT 28
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: LD_INT 14
7316: PUSH
7317: LD_INT 1
7319: PUSH
7320: LD_INT 2
7322: PUSH
7323: LD_INT 27
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: LIST
7330: LIST
7331: PUSH
7332: LD_INT 14
7334: PUSH
7335: LD_INT 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 27
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: LIST
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7355: LD_INT 2
7357: PPUSH
7358: LD_VAR 0 8
7362: PPUSH
7363: CALL 41468 0 2
// wait ( 0 0$50 ) ;
7367: LD_INT 1750
7369: PPUSH
7370: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7374: LD_INT 35
7376: PPUSH
7377: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
7381: LD_EXP 69
7385: PUSH
7386: LD_INT 1
7388: ARRAY
7389: PPUSH
7390: LD_INT 3
7392: PUSH
7393: LD_INT 34
7395: PUSH
7396: LD_INT 32
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PPUSH
7407: CALL_OW 72
7411: PUSH
7412: LD_INT 4
7414: GREATEREQUAL
7415: IFFALSE 7374
// wait ( 0 0$10 ) ;
7417: LD_INT 350
7419: PPUSH
7420: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7424: LD_ADDR_VAR 0 3
7428: PUSH
7429: LD_EXP 69
7433: PUSH
7434: LD_INT 1
7436: ARRAY
7437: PPUSH
7438: LD_INT 3
7440: PUSH
7441: LD_INT 34
7443: PUSH
7444: LD_INT 32
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: PUSH
7451: EMPTY
7452: LIST
7453: LIST
7454: PPUSH
7455: CALL_OW 72
7459: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7460: LD_INT 100
7462: PPUSH
7463: CALL_OW 13
7467: PUSH
7468: LD_INT 50
7470: LESS
7471: IFFALSE 7504
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7473: LD_ADDR_VAR 0 5
7477: PUSH
7478: LD_INT 55
7480: PUSH
7481: LD_INT 7
7483: PUSH
7484: EMPTY
7485: LIST
7486: LIST
7487: PUSH
7488: LD_INT 75
7490: PUSH
7491: LD_INT 90
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: ST_TO_ADDR
7502: GO 7533
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7504: LD_ADDR_VAR 0 5
7508: PUSH
7509: LD_INT 128
7511: PUSH
7512: LD_INT 94
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: PUSH
7519: LD_INT 180
7521: PUSH
7522: LD_INT 135
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: ST_TO_ADDR
// if w mod 4 = 0 then
7533: LD_VAR 0 7
7537: PUSH
7538: LD_INT 4
7540: MOD
7541: PUSH
7542: LD_INT 0
7544: EQUAL
7545: IFFALSE 7576
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7547: LD_ADDR_VAR 0 5
7551: PUSH
7552: LD_INT 91
7554: PUSH
7555: LD_INT 58
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: PUSH
7562: LD_INT 117
7564: PUSH
7565: LD_INT 107
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7576: LD_VAR 0 3
7580: PPUSH
7581: LD_VAR 0 5
7585: PUSH
7586: LD_INT 1
7588: ARRAY
7589: PPUSH
7590: LD_VAR 0 5
7594: PUSH
7595: LD_INT 2
7597: ARRAY
7598: PPUSH
7599: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7603: LD_INT 35
7605: PPUSH
7606: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7610: LD_VAR 0 3
7614: PPUSH
7615: LD_INT 60
7617: PUSH
7618: EMPTY
7619: LIST
7620: PPUSH
7621: CALL_OW 72
7625: PUSH
7626: LD_INT 0
7628: EQUAL
7629: IFFALSE 7603
// repeat wait ( 0 0$2 ) ;
7631: LD_INT 70
7633: PPUSH
7634: CALL_OW 67
// for i in tmp do
7638: LD_ADDR_VAR 0 1
7642: PUSH
7643: LD_VAR 0 3
7647: PUSH
7648: FOR_IN
7649: IFFALSE 7738
// if GetChassis ( i ) = ar_hovercraft then
7651: LD_VAR 0 1
7655: PPUSH
7656: CALL_OW 265
7660: PUSH
7661: LD_INT 11
7663: EQUAL
7664: IFFALSE 7702
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7666: LD_VAR 0 1
7670: PPUSH
7671: LD_INT 22
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PPUSH
7681: CALL_OW 69
7685: PPUSH
7686: LD_VAR 0 1
7690: PPUSH
7691: CALL_OW 74
7695: PPUSH
7696: CALL 80013 0 2
7700: GO 7736
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7702: LD_VAR 0 1
7706: PPUSH
7707: LD_INT 22
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PPUSH
7717: CALL_OW 69
7721: PPUSH
7722: LD_VAR 0 1
7726: PPUSH
7727: CALL_OW 74
7731: PPUSH
7732: CALL_OW 115
7736: GO 7648
7738: POP
7739: POP
// until not tmp ;
7740: LD_VAR 0 3
7744: NOT
7745: IFFALSE 7631
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7747: LD_INT 22050
7749: PPUSH
7750: LD_INT 28350
7752: PPUSH
7753: CALL_OW 12
7757: PPUSH
7758: CALL_OW 67
// w := w + 1 ;
7762: LD_ADDR_VAR 0 7
7766: PUSH
7767: LD_VAR 0 7
7771: PUSH
7772: LD_INT 1
7774: PLUS
7775: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7776: LD_INT 94
7778: PPUSH
7779: CALL_OW 301
7783: PUSH
7784: LD_EXP 50
7788: PUSH
7789: LD_INT 1
7791: ARRAY
7792: PPUSH
7793: LD_INT 30
7795: PUSH
7796: LD_INT 3
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PPUSH
7803: CALL_OW 72
7807: NOT
7808: OR
7809: IFFALSE 6970
// end ;
7811: PPOPN 8
7813: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7814: LD_INT 204
7816: IFFALSE 8282
7818: GO 7820
7820: DISABLE
7821: LD_INT 0
7823: PPUSH
7824: PPUSH
7825: PPUSH
7826: PPUSH
// begin enable ;
7827: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7828: LD_INT 35
7830: PPUSH
7831: LD_INT 1190
7833: PPUSH
7834: CALL_OW 12
7838: PPUSH
7839: CALL_OW 67
// tmp := [ ] ;
7843: LD_ADDR_VAR 0 2
7847: PUSH
7848: EMPTY
7849: ST_TO_ADDR
// uc_side := 8 ;
7850: LD_ADDR_OWVAR 20
7854: PUSH
7855: LD_INT 8
7857: ST_TO_ADDR
// uc_nation := 2 ;
7858: LD_ADDR_OWVAR 21
7862: PUSH
7863: LD_INT 2
7865: ST_TO_ADDR
// InitHc ;
7866: CALL_OW 19
// for i = 1 to 3 do
7870: LD_ADDR_VAR 0 1
7874: PUSH
7875: DOUBLE
7876: LD_INT 1
7878: DEC
7879: ST_TO_ADDR
7880: LD_INT 3
7882: PUSH
7883: FOR_TO
7884: IFFALSE 8011
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7886: LD_INT 13
7888: PUSH
7889: LD_INT 14
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PUSH
7896: LD_INT 1
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ARRAY
7907: PPUSH
7908: LD_INT 3
7910: PPUSH
7911: LD_INT 5
7913: PPUSH
7914: LD_INT 27
7916: PUSH
7917: LD_INT 28
7919: PUSH
7920: EMPTY
7921: LIST
7922: LIST
7923: PUSH
7924: LD_INT 1
7926: PPUSH
7927: LD_INT 2
7929: PPUSH
7930: CALL_OW 12
7934: ARRAY
7935: PPUSH
7936: LD_INT 100
7938: PPUSH
7939: CALL 52703 0 5
// un := CreateVehicle ;
7943: LD_ADDR_VAR 0 3
7947: PUSH
7948: CALL_OW 45
7952: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7953: LD_VAR 0 3
7957: PPUSH
7958: LD_INT 4
7960: PPUSH
7961: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7965: LD_VAR 0 3
7969: PPUSH
7970: LD_INT 15
7972: PPUSH
7973: LD_INT 0
7975: PPUSH
7976: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7980: LD_ADDR_VAR 0 2
7984: PUSH
7985: LD_VAR 0 2
7989: PPUSH
7990: LD_VAR 0 2
7994: PUSH
7995: LD_INT 1
7997: PLUS
7998: PPUSH
7999: LD_VAR 0 3
8003: PPUSH
8004: CALL_OW 1
8008: ST_TO_ADDR
// end ;
8009: GO 7883
8011: POP
8012: POP
// for i = 1 to 4 do
8013: LD_ADDR_VAR 0 1
8017: PUSH
8018: DOUBLE
8019: LD_INT 1
8021: DEC
8022: ST_TO_ADDR
8023: LD_INT 4
8025: PUSH
8026: FOR_TO
8027: IFFALSE 8098
// begin PrepareHuman ( false , 1 , 6 ) ;
8029: LD_INT 0
8031: PPUSH
8032: LD_INT 1
8034: PPUSH
8035: LD_INT 6
8037: PPUSH
8038: CALL_OW 380
// un := CreateHuman ;
8042: LD_ADDR_VAR 0 3
8046: PUSH
8047: CALL_OW 44
8051: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8052: LD_VAR 0 3
8056: PPUSH
8057: LD_INT 15
8059: PPUSH
8060: LD_INT 0
8062: PPUSH
8063: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8067: LD_ADDR_VAR 0 2
8071: PUSH
8072: LD_VAR 0 2
8076: PPUSH
8077: LD_VAR 0 2
8081: PUSH
8082: LD_INT 1
8084: PLUS
8085: PPUSH
8086: LD_VAR 0 3
8090: PPUSH
8091: CALL_OW 1
8095: ST_TO_ADDR
// end ;
8096: GO 8026
8098: POP
8099: POP
// wait ( 0 0$3 ) ;
8100: LD_INT 105
8102: PPUSH
8103: CALL_OW 67
// for i in tmp do
8107: LD_ADDR_VAR 0 1
8111: PUSH
8112: LD_VAR 0 2
8116: PUSH
8117: FOR_IN
8118: IFFALSE 8186
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8120: LD_VAR 0 1
8124: PPUSH
8125: CALL_OW 257
8129: PUSH
8130: LD_INT 1
8132: EQUAL
8133: PUSH
8134: LD_VAR 0 1
8138: PPUSH
8139: CALL_OW 247
8143: PUSH
8144: LD_INT 2
8146: EQUAL
8147: OR
8148: IFFALSE 8184
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8150: LD_VAR 0 1
8154: PPUSH
8155: LD_INT 81
8157: PUSH
8158: LD_INT 8
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PPUSH
8165: CALL_OW 69
8169: PPUSH
8170: LD_VAR 0 1
8174: PPUSH
8175: CALL_OW 74
8179: PPUSH
8180: CALL_OW 115
8184: GO 8117
8186: POP
8187: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: LD_INT 210
8195: PPUSH
8196: LD_INT 178
8198: PPUSH
8199: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8203: LD_ADDR_VAR 0 4
8207: PUSH
8208: LD_INT 10
8210: PPUSH
8211: LD_INT 22
8213: PUSH
8214: LD_INT 8
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PPUSH
8221: CALL_OW 70
8225: ST_TO_ADDR
// if x then
8226: LD_VAR 0 4
8230: IFFALSE 8258
// for i in x do
8232: LD_ADDR_VAR 0 1
8236: PUSH
8237: LD_VAR 0 4
8241: PUSH
8242: FOR_IN
8243: IFFALSE 8256
// RemoveUnit ( i ) ;
8245: LD_VAR 0 1
8249: PPUSH
8250: CALL_OW 64
8254: GO 8242
8256: POP
8257: POP
// wait ( 0 0$1 ) ;
8258: LD_INT 35
8260: PPUSH
8261: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8265: LD_INT 22
8267: PUSH
8268: LD_INT 8
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PPUSH
8275: CALL_OW 69
8279: NOT
8280: IFFALSE 8188
// end ;
8282: PPOPN 4
8284: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8285: LD_INT 22
8287: PUSH
8288: LD_INT 2
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: PUSH
8295: LD_INT 34
8297: PUSH
8298: LD_INT 31
8300: PUSH
8301: EMPTY
8302: LIST
8303: LIST
8304: PUSH
8305: LD_INT 3
8307: PUSH
8308: LD_INT 24
8310: PUSH
8311: LD_INT 1000
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: LIST
8326: PPUSH
8327: CALL_OW 69
8331: IFFALSE 8434
8333: GO 8335
8335: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8336: LD_INT 45
8338: PPUSH
8339: CALL_OW 302
8343: PUSH
8344: LD_INT 45
8346: PPUSH
8347: CALL_OW 255
8351: AND
8352: IFFALSE 8395
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8354: LD_INT 22
8356: PUSH
8357: LD_INT 2
8359: PUSH
8360: EMPTY
8361: LIST
8362: LIST
8363: PUSH
8364: LD_INT 34
8366: PUSH
8367: LD_INT 31
8369: PUSH
8370: EMPTY
8371: LIST
8372: LIST
8373: PUSH
8374: EMPTY
8375: LIST
8376: LIST
8377: PPUSH
8378: CALL_OW 69
8382: PPUSH
8383: LD_INT 18
8385: PPUSH
8386: LD_INT 8
8388: PPUSH
8389: CALL_OW 111
8393: GO 8434
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8395: LD_INT 22
8397: PUSH
8398: LD_INT 2
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 34
8407: PUSH
8408: LD_INT 31
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PPUSH
8419: CALL_OW 69
8423: PPUSH
8424: LD_INT 106
8426: PPUSH
8427: LD_INT 14
8429: PPUSH
8430: CALL_OW 111
// end ; end_of_file
8434: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8435: LD_INT 0
8437: PPUSH
8438: PPUSH
8439: PPUSH
8440: PPUSH
8441: PPUSH
8442: PPUSH
// InGameOn ;
8443: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8447: LD_EXP 21
8451: PPUSH
8452: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8456: LD_INT 2
8458: PPUSH
8459: LD_INT 1
8461: PPUSH
8462: LD_INT 1
8464: PPUSH
8465: LD_INT 1
8467: PPUSH
8468: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8472: LD_ADDR_VAR 0 2
8476: PUSH
8477: LD_INT 22
8479: PUSH
8480: LD_INT 1
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PUSH
8487: LD_INT 25
8489: PUSH
8490: LD_INT 1
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PPUSH
8501: CALL_OW 69
8505: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8506: LD_ADDR_VAR 0 4
8510: PUSH
8511: LD_INT 22
8513: PUSH
8514: LD_INT 1
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PUSH
8521: LD_INT 34
8523: PUSH
8524: LD_INT 11
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PPUSH
8535: CALL_OW 69
8539: PUSH
8540: LD_INT 1
8542: ARRAY
8543: ST_TO_ADDR
// for i = 1 to tmp do
8544: LD_ADDR_VAR 0 6
8548: PUSH
8549: DOUBLE
8550: LD_INT 1
8552: DEC
8553: ST_TO_ADDR
8554: LD_VAR 0 2
8558: PUSH
8559: FOR_TO
8560: IFFALSE 8607
// begin if i = 5 then
8562: LD_VAR 0 6
8566: PUSH
8567: LD_INT 5
8569: EQUAL
8570: IFFALSE 8574
// break ;
8572: GO 8607
// sols := Replace ( sols , i , tmp [ i ] ) ;
8574: LD_ADDR_VAR 0 5
8578: PUSH
8579: LD_VAR 0 5
8583: PPUSH
8584: LD_VAR 0 6
8588: PPUSH
8589: LD_VAR 0 2
8593: PUSH
8594: LD_VAR 0 6
8598: ARRAY
8599: PPUSH
8600: CALL_OW 1
8604: ST_TO_ADDR
// end ;
8605: GO 8559
8607: POP
8608: POP
// tmp := ar_force_tmp ;
8609: LD_ADDR_VAR 0 2
8613: PUSH
8614: LD_EXP 40
8618: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8619: LD_VAR 0 2
8623: PUSH
8624: LD_INT 1
8626: ARRAY
8627: PPUSH
8628: LD_INT 108
8630: PPUSH
8631: LD_INT 139
8633: PPUSH
8634: LD_INT 0
8636: PPUSH
8637: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8641: LD_VAR 0 2
8645: PUSH
8646: LD_INT 1
8648: ARRAY
8649: PPUSH
8650: LD_EXP 21
8654: PPUSH
8655: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8659: LD_VAR 0 2
8663: PUSH
8664: LD_INT 2
8666: ARRAY
8667: PPUSH
8668: LD_INT 114
8670: PPUSH
8671: LD_INT 132
8673: PPUSH
8674: LD_INT 0
8676: PPUSH
8677: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8681: LD_VAR 0 2
8685: PUSH
8686: LD_INT 3
8688: ARRAY
8689: PPUSH
8690: LD_INT 115
8692: PPUSH
8693: LD_INT 132
8695: PPUSH
8696: LD_INT 0
8698: PPUSH
8699: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8703: LD_VAR 0 2
8707: PUSH
8708: LD_INT 2
8710: ARRAY
8711: PUSH
8712: LD_VAR 0 2
8716: PUSH
8717: LD_INT 3
8719: ARRAY
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: PPUSH
8725: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 83
8736: PPUSH
8737: LD_INT 123
8739: PPUSH
8740: CALL_OW 111
// Wait ( 0 0$01 ) ;
8744: LD_INT 35
8746: PPUSH
8747: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8751: LD_INT 90
8753: PPUSH
8754: LD_INT 144
8756: PPUSH
8757: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8761: LD_VAR 0 5
8765: PPUSH
8766: LD_INT 88
8768: PPUSH
8769: LD_INT 129
8771: PPUSH
8772: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8776: LD_ADDR_VAR 0 3
8780: PUSH
8781: LD_INT 92
8783: PUSH
8784: LD_INT 131
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: LD_INT 88
8793: PUSH
8794: LD_INT 127
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 91
8803: PUSH
8804: LD_INT 132
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: LD_INT 92
8813: PUSH
8814: LD_INT 134
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: ST_TO_ADDR
// for i = 1 to sols do
8827: LD_ADDR_VAR 0 6
8831: PUSH
8832: DOUBLE
8833: LD_INT 1
8835: DEC
8836: ST_TO_ADDR
8837: LD_VAR 0 5
8841: PUSH
8842: FOR_TO
8843: IFFALSE 8916
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8845: LD_VAR 0 5
8849: PUSH
8850: LD_VAR 0 6
8854: ARRAY
8855: PPUSH
8856: LD_VAR 0 3
8860: PUSH
8861: LD_VAR 0 6
8865: ARRAY
8866: PUSH
8867: LD_INT 1
8869: ARRAY
8870: PPUSH
8871: LD_VAR 0 3
8875: PUSH
8876: LD_VAR 0 6
8880: ARRAY
8881: PUSH
8882: LD_INT 2
8884: ARRAY
8885: PPUSH
8886: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8890: LD_VAR 0 5
8894: PUSH
8895: LD_VAR 0 6
8899: ARRAY
8900: PPUSH
8901: CALL_OW 197
// AddComHold ( sols ) ;
8905: LD_VAR 0 5
8909: PPUSH
8910: CALL_OW 200
// end ;
8914: GO 8842
8916: POP
8917: POP
// repeat wait ( 0 0$1 ) ;
8918: LD_INT 35
8920: PPUSH
8921: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8925: LD_VAR 0 5
8929: PUSH
8930: LD_INT 1
8932: ARRAY
8933: PPUSH
8934: LD_INT 92
8936: PPUSH
8937: LD_INT 131
8939: PPUSH
8940: CALL_OW 297
8944: PUSH
8945: LD_INT 4
8947: LESS
8948: IFFALSE 8918
// CenterOnXY ( 96 , 139 ) ;
8950: LD_INT 96
8952: PPUSH
8953: LD_INT 139
8955: PPUSH
8956: CALL_OW 84
// wait ( 0 0$3 ) ;
8960: LD_INT 105
8962: PPUSH
8963: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8967: LD_INT 111
8969: PPUSH
8970: LD_INT 135
8972: PPUSH
8973: LD_INT 1
8975: PPUSH
8976: LD_INT 25
8978: NEG
8979: PPUSH
8980: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8984: LD_VAR 0 2
8988: PUSH
8989: LD_INT 2
8991: ARRAY
8992: PPUSH
8993: LD_VAR 0 2
8997: PUSH
8998: LD_INT 1
9000: ARRAY
9001: PPUSH
9002: CALL_OW 250
9006: PUSH
9007: LD_INT 3
9009: PLUS
9010: PPUSH
9011: LD_VAR 0 2
9015: PUSH
9016: LD_INT 1
9018: ARRAY
9019: PPUSH
9020: CALL_OW 251
9024: PPUSH
9025: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9029: LD_VAR 0 2
9033: PUSH
9034: LD_INT 3
9036: ARRAY
9037: PPUSH
9038: LD_INT 7
9040: PPUSH
9041: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 2
9052: ARRAY
9053: PPUSH
9054: LD_VAR 0 2
9058: PUSH
9059: LD_INT 1
9061: ARRAY
9062: PPUSH
9063: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9067: LD_INT 35
9069: PPUSH
9070: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9074: LD_VAR 0 2
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: LD_VAR 0 2
9087: PUSH
9088: LD_INT 2
9090: ARRAY
9091: PPUSH
9092: CALL_OW 296
9096: PUSH
9097: LD_INT 5
9099: LESS
9100: IFFALSE 9067
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9102: LD_VAR 0 2
9106: PUSH
9107: LD_INT 1
9109: ARRAY
9110: PPUSH
9111: LD_VAR 0 2
9115: PUSH
9116: LD_INT 2
9118: ARRAY
9119: PPUSH
9120: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9124: LD_VAR 0 2
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_STRING D1a-Merc1-1
9135: PPUSH
9136: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9140: LD_VAR 0 2
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: LD_STRING D1a-FMerc2-1
9151: PPUSH
9152: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9156: LD_VAR 0 2
9160: PUSH
9161: LD_INT 2
9163: ARRAY
9164: PPUSH
9165: LD_VAR 0 2
9169: PUSH
9170: LD_INT 1
9172: ARRAY
9173: PPUSH
9174: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9178: LD_VAR 0 2
9182: PUSH
9183: LD_INT 1
9185: ARRAY
9186: PPUSH
9187: LD_INT 500
9189: PPUSH
9190: CALL_OW 234
// wait ( 0 0$2 ) ;
9194: LD_INT 70
9196: PPUSH
9197: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9201: LD_VAR 0 2
9205: PUSH
9206: LD_INT 1
9208: ARRAY
9209: PPUSH
9210: LD_INT 2
9212: PPUSH
9213: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9217: LD_INT 10
9219: PPUSH
9220: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9224: LD_VAR 0 2
9228: PUSH
9229: LD_INT 1
9231: ARRAY
9232: PPUSH
9233: LD_STRING D1a-Merc1-2
9235: PPUSH
9236: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9240: LD_INT 7
9242: PPUSH
9243: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9247: LD_VAR 0 2
9251: PUSH
9252: LD_INT 1
9254: ARRAY
9255: PPUSH
9256: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9260: LD_VAR 0 2
9264: PUSH
9265: LD_INT 2
9267: ARRAY
9268: PPUSH
9269: LD_INT 10
9271: PPUSH
9272: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9276: LD_VAR 0 2
9280: PUSH
9281: LD_INT 2
9283: ARRAY
9284: PPUSH
9285: LD_STRING D1a-FMerc2-2
9287: PPUSH
9288: CALL_OW 88
// wait ( 0 0$1 ) ;
9292: LD_INT 35
9294: PPUSH
9295: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9299: LD_INT 7
9301: PPUSH
9302: CALL_OW 85
// wait ( 0 0$2 ) ;
9306: LD_INT 70
9308: PPUSH
9309: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9313: LD_EXP 44
9317: PPUSH
9318: LD_STRING D1a-Saliba-1
9320: PPUSH
9321: CALL_OW 91
// KillUnit ( Saliba ) ;
9325: LD_EXP 44
9329: PPUSH
9330: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9334: LD_VAR 0 2
9338: PUSH
9339: LD_INT 3
9341: ARRAY
9342: PPUSH
9343: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9347: LD_EXP 21
9351: PPUSH
9352: CALL_OW 85
// wait ( 0 0$1 ) ;
9356: LD_INT 35
9358: PPUSH
9359: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9363: LD_VAR 0 5
9367: PPUSH
9368: LD_INT 88
9370: PPUSH
9371: LD_INT 141
9373: PPUSH
9374: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9378: LD_VAR 0 5
9382: PPUSH
9383: LD_INT 70
9385: PPUSH
9386: CALL_OW 202
// wait ( 0 0$2 ) ;
9390: LD_INT 70
9392: PPUSH
9393: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9397: LD_INT 2
9399: PPUSH
9400: LD_INT 1
9402: PPUSH
9403: LD_INT 2
9405: PPUSH
9406: LD_INT 1
9408: PPUSH
9409: CALL_OW 80
// InGameOff ;
9413: CALL_OW 9
// ComWalk ( sols ) ;
9417: LD_VAR 0 5
9421: PPUSH
9422: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9426: LD_STRING M1
9428: PPUSH
9429: CALL_OW 337
// game_speed := 4 ;
9433: LD_ADDR_OWVAR 65
9437: PUSH
9438: LD_INT 4
9440: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9441: LD_INT 111
9443: PPUSH
9444: LD_INT 135
9446: PPUSH
9447: LD_INT 1
9449: PPUSH
9450: CALL_OW 331
// SaveForQuickRestart ;
9454: CALL_OW 22
// ar_run := true ;
9458: LD_ADDR_EXP 5
9462: PUSH
9463: LD_INT 1
9465: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9466: LD_INT 35
9468: PPUSH
9469: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9473: LD_INT 22
9475: PUSH
9476: LD_INT 1
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 91
9485: PUSH
9486: LD_INT 7
9488: PUSH
9489: LD_INT 10
9491: PUSH
9492: EMPTY
9493: LIST
9494: LIST
9495: LIST
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PPUSH
9501: CALL_OW 69
9505: PUSH
9506: LD_INT 7
9508: PPUSH
9509: CALL_OW 256
9513: PUSH
9514: LD_INT 999
9516: LESS
9517: OR
9518: IFFALSE 9466
// if GetSide ( ar_dep_s ) = 2 then
9520: LD_INT 7
9522: PPUSH
9523: CALL_OW 255
9527: PUSH
9528: LD_INT 2
9530: EQUAL
9531: IFFALSE 9543
// SetSide ( ar_dep_s , 1 ) ;
9533: LD_INT 7
9535: PPUSH
9536: LD_INT 1
9538: PPUSH
9539: CALL_OW 235
// end ;
9543: LD_VAR 0 1
9547: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9548: LD_EXP 5
9552: IFFALSE 9912
9554: GO 9556
9556: DISABLE
9557: LD_INT 0
9559: PPUSH
9560: PPUSH
9561: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9562: LD_ADDR_VAR 0 2
9566: PUSH
9567: LD_EXP 40
9571: PUSH
9572: LD_EXP 36
9576: PPUSH
9577: LD_INT 2
9579: PUSH
9580: LD_INT 21
9582: PUSH
9583: LD_INT 2
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: PUSH
9590: LD_INT 21
9592: PUSH
9593: LD_INT 1
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 72
9609: ADD
9610: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9611: LD_VAR 0 2
9615: PPUSH
9616: LD_INT 5
9618: PPUSH
9619: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9623: LD_INT 5
9625: PPUSH
9626: LD_INT 1
9628: PPUSH
9629: CALL_OW 343
// k := 1 ;
9633: LD_ADDR_VAR 0 3
9637: PUSH
9638: LD_INT 1
9640: ST_TO_ADDR
// for i in tmp do
9641: LD_ADDR_VAR 0 1
9645: PUSH
9646: LD_VAR 0 2
9650: PUSH
9651: FOR_IN
9652: IFFALSE 9737
// begin if IsInUnit ( i ) then
9654: LD_VAR 0 1
9658: PPUSH
9659: CALL_OW 310
9663: IFFALSE 9674
// ComExitBuilding ( i ) ;
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 122
// if GetClass ( i ) = 3 then
9674: LD_VAR 0 1
9678: PPUSH
9679: CALL_OW 257
9683: PUSH
9684: LD_INT 3
9686: EQUAL
9687: IFFALSE 9723
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9689: LD_VAR 0 1
9693: PPUSH
9694: LD_EXP 41
9698: PUSH
9699: LD_VAR 0 3
9703: ARRAY
9704: PPUSH
9705: CALL_OW 180
// k := k + 1 ;
9709: LD_ADDR_VAR 0 3
9713: PUSH
9714: LD_VAR 0 3
9718: PUSH
9719: LD_INT 1
9721: PLUS
9722: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9723: LD_VAR 0 1
9727: PPUSH
9728: LD_INT 10
9730: PPUSH
9731: CALL_OW 173
// end ;
9735: GO 9651
9737: POP
9738: POP
// ar_patrol := true ;
9739: LD_ADDR_EXP 7
9743: PUSH
9744: LD_INT 1
9746: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9747: LD_INT 10
9749: PPUSH
9750: CALL_OW 67
// for i in tmp do
9754: LD_ADDR_VAR 0 1
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: FOR_IN
9765: IFFALSE 9793
// if not HasTask ( i ) then
9767: LD_VAR 0 1
9771: PPUSH
9772: CALL_OW 314
9776: NOT
9777: IFFALSE 9791
// ComMoveToArea ( i , escape_area ) ;
9779: LD_VAR 0 1
9783: PPUSH
9784: LD_INT 10
9786: PPUSH
9787: CALL_OW 113
9791: GO 9764
9793: POP
9794: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9795: LD_ADDR_VAR 0 3
9799: PUSH
9800: LD_VAR 0 2
9804: PPUSH
9805: LD_INT 95
9807: PUSH
9808: LD_INT 10
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PPUSH
9815: CALL_OW 72
9819: ST_TO_ADDR
// if k then
9820: LD_VAR 0 3
9824: IFFALSE 9893
// for i in k do
9826: LD_ADDR_VAR 0 1
9830: PUSH
9831: LD_VAR 0 3
9835: PUSH
9836: FOR_IN
9837: IFFALSE 9891
// begin if IsInUnit ( i ) then
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 310
9848: IFFALSE 9864
// RemoveUnit ( IsInUnit ( i ) ) ;
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 310
9859: PPUSH
9860: CALL_OW 64
// RemoveUnit ( i ) ;
9864: LD_VAR 0 1
9868: PPUSH
9869: CALL_OW 64
// tmp := tmp diff i ;
9873: LD_ADDR_VAR 0 2
9877: PUSH
9878: LD_VAR 0 2
9882: PUSH
9883: LD_VAR 0 1
9887: DIFF
9888: ST_TO_ADDR
// end ;
9889: GO 9836
9891: POP
9892: POP
// until tmp = [ ] ;
9893: LD_VAR 0 2
9897: PUSH
9898: EMPTY
9899: EQUAL
9900: IFFALSE 9747
// ChangeSideFog ( 5 , 5 ) ;
9902: LD_INT 5
9904: PPUSH
9905: LD_INT 5
9907: PPUSH
9908: CALL_OW 343
// end ;
9912: PPOPN 3
9914: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9915: LD_EXP 7
9919: IFFALSE 10209
9921: GO 9923
9923: DISABLE
9924: LD_INT 0
9926: PPUSH
9927: PPUSH
9928: PPUSH
// begin uc_side := 2 ;
9929: LD_ADDR_OWVAR 20
9933: PUSH
9934: LD_INT 2
9936: ST_TO_ADDR
// uc_nation := 2 ;
9937: LD_ADDR_OWVAR 21
9941: PUSH
9942: LD_INT 2
9944: ST_TO_ADDR
// InitHc ;
9945: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9949: LD_INT 1
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 6
9957: PPUSH
9958: CALL_OW 380
// un := CreateHuman ;
9962: LD_ADDR_VAR 0 2
9966: PUSH
9967: CALL_OW 44
9971: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9972: LD_INT 14
9974: PPUSH
9975: LD_INT 1
9977: PPUSH
9978: LD_INT 1
9980: PPUSH
9981: LD_INT 27
9983: PPUSH
9984: LD_INT 98
9986: PPUSH
9987: CALL 52703 0 5
// veh := CreateVehicle ;
9991: LD_ADDR_VAR 0 3
9995: PUSH
9996: CALL_OW 45
10000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10001: LD_VAR 0 3
10005: PPUSH
10006: LD_INT 4
10008: PPUSH
10009: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10013: LD_VAR 0 3
10017: PPUSH
10018: LD_INT 179
10020: PPUSH
10021: LD_INT 135
10023: PPUSH
10024: LD_INT 0
10026: PPUSH
10027: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10031: LD_VAR 0 2
10035: PPUSH
10036: LD_VAR 0 3
10040: PPUSH
10041: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10045: LD_VAR 0 2
10049: PPUSH
10050: LD_INT 126
10052: PPUSH
10053: LD_INT 133
10055: PPUSH
10056: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10060: LD_INT 10
10062: PPUSH
10063: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10067: LD_INT 1
10069: PPUSH
10070: LD_VAR 0 3
10074: PPUSH
10075: CALL_OW 292
10079: PUSH
10080: LD_VAR 0 3
10084: PPUSH
10085: LD_INT 7
10087: PPUSH
10088: CALL_OW 296
10092: PUSH
10093: LD_INT 9
10095: LESS
10096: OR
10097: IFFALSE 10060
// ComHold ( veh ) ;
10099: LD_VAR 0 3
10103: PPUSH
10104: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10108: LD_VAR 0 2
10112: PPUSH
10113: LD_STRING D2aa-Ar1-1
10115: PPUSH
10116: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10120: LD_VAR 0 2
10124: PPUSH
10125: LD_INT 177
10127: PPUSH
10128: LD_INT 96
10130: PPUSH
10131: CALL_OW 111
// AddComExitVehicle ( un ) ;
10135: LD_VAR 0 2
10139: PPUSH
10140: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10144: LD_INT 35
10146: PPUSH
10147: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10151: LD_VAR 0 2
10155: PPUSH
10156: LD_INT 204
10158: PPUSH
10159: CALL_OW 296
10163: PUSH
10164: LD_INT 15
10166: LESS
10167: IFFALSE 10144
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10169: LD_ADDR_EXP 50
10173: PUSH
10174: LD_EXP 50
10178: PPUSH
10179: LD_INT 3
10181: PUSH
10182: LD_EXP 50
10186: PUSH
10187: LD_INT 3
10189: ARRAY
10190: PUSH
10191: LD_INT 1
10193: PLUS
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PPUSH
10199: LD_VAR 0 2
10203: PPUSH
10204: CALL 52825 0 3
10208: ST_TO_ADDR
// end ;
10209: PPOPN 3
10211: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10212: LD_INT 7
10214: PPUSH
10215: CALL_OW 255
10219: PUSH
10220: LD_INT 1
10222: EQUAL
10223: PUSH
10224: LD_INT 7
10226: PPUSH
10227: CALL_OW 301
10231: OR
10232: IFFALSE 12636
10234: GO 10236
10236: DISABLE
10237: LD_INT 0
10239: PPUSH
10240: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10241: LD_ADDR_VAR 0 1
10245: PUSH
10246: LD_EXP 36
10250: PPUSH
10251: LD_INT 21
10253: PUSH
10254: LD_INT 3
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PPUSH
10261: CALL_OW 72
10265: PUSH
10266: FOR_IN
10267: IFFALSE 10283
// SetSide ( i , 1 ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 1
10276: PPUSH
10277: CALL_OW 235
10281: GO 10266
10283: POP
10284: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 46
10292: PUSH
10293: LD_INT 41
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 50
10302: PUSH
10303: LD_INT 25
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: LD_INT 57
10312: PUSH
10313: LD_INT 75
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PUSH
10320: LD_INT 75
10322: PUSH
10323: LD_INT 89
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: PUSH
10330: LD_INT 51
10332: PUSH
10333: LD_INT 45
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: PUSH
10340: LD_INT 95
10342: PUSH
10343: LD_INT 95
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 84
10352: PUSH
10353: LD_INT 77
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 101
10362: PUSH
10363: LD_INT 76
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PUSH
10370: LD_INT 118
10372: PUSH
10373: LD_INT 81
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 139
10382: PUSH
10383: LD_INT 97
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 129
10392: PUSH
10393: LD_INT 114
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 154
10402: PUSH
10403: LD_INT 111
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: ST_TO_ADDR
// base_captured := true ;
10424: LD_ADDR_EXP 6
10428: PUSH
10429: LD_INT 1
10431: ST_TO_ADDR
// DialogueOn ;
10432: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10436: LD_EXP 21
10440: PPUSH
10441: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10445: LD_EXP 21
10449: PPUSH
10450: LD_STRING D2-JMM-1
10452: PPUSH
10453: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10457: LD_EXP 30
10461: PPUSH
10462: LD_STRING D2-Pow-1
10464: PPUSH
10465: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10469: LD_EXP 21
10473: PPUSH
10474: LD_STRING D2-JMM-2
10476: PPUSH
10477: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10481: LD_EXP 30
10485: PPUSH
10486: LD_STRING D2-Pow-2
10488: PPUSH
10489: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10493: LD_EXP 21
10497: PPUSH
10498: LD_STRING D2-JMM-3
10500: PPUSH
10501: CALL_OW 88
// DialogueOff ;
10505: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10509: LD_STRING M2
10511: PPUSH
10512: CALL_OW 337
// Wait ( 0 0$2 ) ;
10516: LD_INT 70
10518: PPUSH
10519: CALL_OW 67
// if IsOk ( Gary ) then
10523: LD_EXP 32
10527: PPUSH
10528: CALL_OW 302
10532: IFFALSE 10546
// Say ( Gary , D2a-Gary-1 ) ;
10534: LD_EXP 32
10538: PPUSH
10539: LD_STRING D2a-Gary-1
10541: PPUSH
10542: CALL_OW 88
// if IsOk ( Bobby ) then
10546: LD_EXP 24
10550: PPUSH
10551: CALL_OW 302
10555: IFFALSE 10569
// Say ( Bobby , D2a-Bobby-1 ) ;
10557: LD_EXP 24
10561: PPUSH
10562: LD_STRING D2a-Bobby-1
10564: PPUSH
10565: CALL_OW 88
// if IsOk ( Cyrus ) then
10569: LD_EXP 25
10573: PPUSH
10574: CALL_OW 302
10578: IFFALSE 10592
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10580: LD_EXP 25
10584: PPUSH
10585: LD_STRING D2a-Cyrus-1
10587: PPUSH
10588: CALL_OW 88
// if IsOk ( Lisa ) then
10592: LD_EXP 22
10596: PPUSH
10597: CALL_OW 302
10601: IFFALSE 10615
// Say ( Lisa , D2a-Lisa-1 ) ;
10603: LD_EXP 22
10607: PPUSH
10608: LD_STRING D2a-Lisa-1
10610: PPUSH
10611: CALL_OW 88
// if IsOk ( Frank ) then
10615: LD_EXP 33
10619: PPUSH
10620: CALL_OW 302
10624: IFFALSE 10638
// Say ( Frank , D2a-Frank-1 ) ;
10626: LD_EXP 33
10630: PPUSH
10631: LD_STRING D2a-Frank-1
10633: PPUSH
10634: CALL_OW 88
// if IsOk ( Cornel ) then
10638: LD_EXP 31
10642: PPUSH
10643: CALL_OW 302
10647: IFFALSE 10661
// Say ( Cornel , D2a-Corn-1 ) ;
10649: LD_EXP 31
10653: PPUSH
10654: LD_STRING D2a-Corn-1
10656: PPUSH
10657: CALL_OW 88
// if IsOk ( Donaldson ) then
10661: LD_EXP 23
10665: PPUSH
10666: CALL_OW 302
10670: IFFALSE 10684
// Say ( Donaldson , D2a-Don-1 ) ;
10672: LD_EXP 23
10676: PPUSH
10677: LD_STRING D2a-Don-1
10679: PPUSH
10680: CALL_OW 88
// if IsOk ( Brown ) then
10684: LD_EXP 27
10688: PPUSH
10689: CALL_OW 302
10693: IFFALSE 10707
// Say ( Brown , D2a-Brown-1 ) ;
10695: LD_EXP 27
10699: PPUSH
10700: LD_STRING D2a-Brown-1
10702: PPUSH
10703: CALL_OW 88
// Wait ( 0 0$30 ) ;
10707: LD_INT 1050
10709: PPUSH
10710: CALL_OW 67
// if IsOk ( Frank ) then
10714: LD_EXP 33
10718: PPUSH
10719: CALL_OW 302
10723: IFFALSE 10989
// begin DialogueOn ;
10725: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10729: LD_EXP 21
10733: PUSH
10734: LD_EXP 33
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10747: LD_EXP 33
10751: PPUSH
10752: LD_STRING D3F-Frank-1
10754: PPUSH
10755: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10759: LD_EXP 21
10763: PPUSH
10764: LD_STRING D3F-JMM-1
10766: PPUSH
10767: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10771: LD_EXP 33
10775: PPUSH
10776: LD_STRING D3F-Frank-2
10778: PPUSH
10779: CALL_OW 88
// case Query ( QFrank ) of 1 :
10783: LD_STRING QFrank
10785: PPUSH
10786: CALL_OW 97
10790: PUSH
10791: LD_INT 1
10793: DOUBLE
10794: EQUAL
10795: IFTRUE 10799
10797: GO 10822
10799: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10800: LD_EXP 21
10804: PPUSH
10805: LD_STRING D3Fa-JMM-1
10807: PPUSH
10808: CALL_OW 88
// us_scout := 1 ;
10812: LD_ADDR_EXP 8
10816: PUSH
10817: LD_INT 1
10819: ST_TO_ADDR
// end ; 2 :
10820: GO 10985
10822: LD_INT 2
10824: DOUBLE
10825: EQUAL
10826: IFTRUE 10830
10828: GO 10952
10830: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10831: LD_EXP 21
10835: PPUSH
10836: LD_STRING D3Fb-JMM-1
10838: PPUSH
10839: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10843: LD_EXP 33
10847: PPUSH
10848: LD_STRING D3Fb-Frank-1
10850: PPUSH
10851: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10855: LD_STRING QFrank2
10857: PPUSH
10858: CALL_OW 97
10862: PUSH
10863: LD_INT 1
10865: DOUBLE
10866: EQUAL
10867: IFTRUE 10871
10869: GO 10918
10871: POP
// begin us_scout := 2 ;
10872: LD_ADDR_EXP 8
10876: PUSH
10877: LD_INT 2
10879: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10880: LD_EXP 21
10884: PPUSH
10885: LD_STRING D3Fba-JMM-1
10887: PPUSH
10888: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10892: LD_EXP 33
10896: PPUSH
10897: LD_STRING D3Fba-Frank-1
10899: PPUSH
10900: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10904: LD_EXP 21
10908: PPUSH
10909: LD_STRING D3Fba-JMM-2
10911: PPUSH
10912: CALL_OW 88
// end ; 2 :
10916: GO 10950
10918: LD_INT 2
10920: DOUBLE
10921: EQUAL
10922: IFTRUE 10926
10924: GO 10949
10926: POP
// begin us_scout := 0 ;
10927: LD_ADDR_EXP 8
10931: PUSH
10932: LD_INT 0
10934: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10935: LD_EXP 21
10939: PPUSH
10940: LD_STRING D3Fbb-JMM-1
10942: PPUSH
10943: CALL_OW 88
// end ; end ;
10947: GO 10950
10949: POP
// end ; 3 :
10950: GO 10985
10952: LD_INT 3
10954: DOUBLE
10955: EQUAL
10956: IFTRUE 10960
10958: GO 10984
10960: POP
// begin us_scout := - 1 ;
10961: LD_ADDR_EXP 8
10965: PUSH
10966: LD_INT 1
10968: NEG
10969: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10970: LD_EXP 21
10974: PPUSH
10975: LD_STRING D3Fc-JMM-1
10977: PPUSH
10978: CALL_OW 88
// end ; end ;
10982: GO 10985
10984: POP
// DialogueOff ;
10985: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10989: LD_EXP 8
10993: PUSH
10994: LD_INT 1
10996: NEG
10997: PUSH
10998: LD_INT 0
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: IN
11005: IFFALSE 11009
// exit ;
11007: GO 12636
// if us_scout in [ 1 , 2 ] then
11009: LD_EXP 8
11013: PUSH
11014: LD_INT 1
11016: PUSH
11017: LD_INT 2
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: IN
11024: IFFALSE 11703
// begin if IsInUnit ( Frank ) then
11026: LD_EXP 33
11030: PPUSH
11031: CALL_OW 310
11035: IFFALSE 11046
// ComExit ( Frank ) ;
11037: LD_EXP 33
11041: PPUSH
11042: CALL 84256 0 1
// SetSide ( Frank , 4 ) ;
11046: LD_EXP 33
11050: PPUSH
11051: LD_INT 4
11053: PPUSH
11054: CALL_OW 235
// wait ( 0 0$1 ) ;
11058: LD_INT 35
11060: PPUSH
11061: CALL_OW 67
// if us_scout = 2 then
11065: LD_EXP 8
11069: PUSH
11070: LD_INT 2
11072: EQUAL
11073: IFFALSE 11441
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11075: LD_EXP 33
11079: PPUSH
11080: LD_INT 75
11082: PPUSH
11083: LD_INT 63
11085: PPUSH
11086: CALL_OW 111
// AddComHold ( Frank ) ;
11090: LD_EXP 33
11094: PPUSH
11095: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11099: LD_EXP 33
11103: PPUSH
11104: LD_INT 770
11106: PPUSH
11107: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11111: LD_EXP 33
11115: PPUSH
11116: LD_INT 100
11118: PPUSH
11119: LD_INT 75
11121: PPUSH
11122: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11126: LD_EXP 33
11130: PPUSH
11131: LD_INT 123
11133: PPUSH
11134: LD_INT 103
11136: PPUSH
11137: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11141: LD_EXP 33
11145: PPUSH
11146: LD_INT 138
11148: PPUSH
11149: LD_INT 108
11151: PPUSH
11152: CALL_OW 171
// AddComHold ( Frank ) ;
11156: LD_EXP 33
11160: PPUSH
11161: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11165: LD_INT 35
11167: PPUSH
11168: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11172: LD_EXP 33
11176: PPUSH
11177: LD_INT 138
11179: PPUSH
11180: LD_INT 108
11182: PPUSH
11183: CALL_OW 307
11187: IFFALSE 11165
// AddComMoveXY ( Frank , 125 , 132 ) ;
11189: LD_EXP 33
11193: PPUSH
11194: LD_INT 125
11196: PPUSH
11197: LD_INT 132
11199: PPUSH
11200: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11204: LD_INT 35
11206: PPUSH
11207: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11211: LD_INT 1
11213: PPUSH
11214: LD_EXP 33
11218: PPUSH
11219: CALL_OW 292
11223: PUSH
11224: LD_EXP 33
11228: PPUSH
11229: LD_INT 7
11231: PPUSH
11232: CALL_OW 296
11236: PUSH
11237: LD_INT 7
11239: LESS
11240: OR
11241: IFFALSE 11204
// DialogueOn ;
11243: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11247: LD_EXP 33
11251: PPUSH
11252: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11256: LD_INT 10
11258: PPUSH
11259: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11263: LD_EXP 21
11267: PPUSH
11268: LD_STRING D4Fa-JMM-1
11270: PPUSH
11271: CALL_OW 88
// for i in points do
11275: LD_ADDR_VAR 0 1
11279: PUSH
11280: LD_VAR 0 2
11284: PUSH
11285: FOR_IN
11286: IFFALSE 11344
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11288: LD_VAR 0 1
11292: PUSH
11293: LD_INT 1
11295: ARRAY
11296: PPUSH
11297: LD_VAR 0 1
11301: PUSH
11302: LD_INT 2
11304: ARRAY
11305: PPUSH
11306: LD_INT 1
11308: PPUSH
11309: LD_INT 20
11311: NEG
11312: PPUSH
11313: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11317: LD_VAR 0 1
11321: PUSH
11322: LD_INT 1
11324: ARRAY
11325: PPUSH
11326: LD_VAR 0 1
11330: PUSH
11331: LD_INT 2
11333: ARRAY
11334: PPUSH
11335: LD_INT 1
11337: PPUSH
11338: CALL_OW 331
// end ;
11342: GO 11285
11344: POP
11345: POP
// dwait ( 0 0$0.5 ) ;
11346: LD_INT 18
11348: PPUSH
11349: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11353: LD_INT 42
11355: PPUSH
11356: LD_INT 27
11358: PPUSH
11359: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11363: LD_EXP 33
11367: PPUSH
11368: LD_STRING D4Fa-Frank-1
11370: PPUSH
11371: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11375: LD_INT 18
11377: PPUSH
11378: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11382: LD_EXP 21
11386: PPUSH
11387: LD_STRING D4Fa-JMM-2
11389: PPUSH
11390: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11394: LD_INT 118
11396: PPUSH
11397: LD_INT 80
11399: PPUSH
11400: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11404: LD_EXP 33
11408: PPUSH
11409: LD_STRING D4Fa-Frank-2
11411: PPUSH
11412: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11416: LD_INT 10
11418: PPUSH
11419: CALL_OW 68
// DialogueOff ;
11423: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11427: LD_EXP 33
11431: PPUSH
11432: LD_INT 1
11434: PPUSH
11435: CALL_OW 235
// end else
11439: GO 11703
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11441: LD_INT 2
11443: PPUSH
11444: LD_INT 4
11446: PPUSH
11447: LD_INT 2
11449: PPUSH
11450: LD_INT 1
11452: PPUSH
11453: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11457: LD_EXP 33
11461: PPUSH
11462: LD_INT 75
11464: PPUSH
11465: LD_INT 63
11467: PPUSH
11468: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11472: LD_EXP 33
11476: PPUSH
11477: LD_INT 175
11479: PPUSH
11480: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11484: LD_EXP 33
11488: PPUSH
11489: LD_INT 102
11491: PPUSH
11492: LD_INT 76
11494: PPUSH
11495: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11499: LD_EXP 33
11503: PPUSH
11504: LD_INT 108
11506: PPUSH
11507: LD_INT 70
11509: PPUSH
11510: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11514: LD_INT 35
11516: PPUSH
11517: CALL_OW 67
// until See ( 2 , Frank ) ;
11521: LD_INT 2
11523: PPUSH
11524: LD_EXP 33
11528: PPUSH
11529: CALL_OW 292
11533: IFFALSE 11514
// ComMoveXY ( Frank , 112 , 118 ) ;
11535: LD_EXP 33
11539: PPUSH
11540: LD_INT 112
11542: PPUSH
11543: LD_INT 118
11545: PPUSH
11546: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11550: LD_EXP 33
11554: PPUSH
11555: CALL_OW 256
11559: PUSH
11560: LD_INT 750
11562: GREATEREQUAL
11563: IFFALSE 11577
// SetLives ( Frank , 700 ) ;
11565: LD_EXP 33
11569: PPUSH
11570: LD_INT 700
11572: PPUSH
11573: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11577: LD_INT 35
11579: PPUSH
11580: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11584: LD_INT 1
11586: PPUSH
11587: LD_EXP 33
11591: PPUSH
11592: CALL_OW 292
11596: PUSH
11597: LD_EXP 33
11601: PPUSH
11602: LD_INT 7
11604: PPUSH
11605: CALL_OW 296
11609: PUSH
11610: LD_INT 17
11612: LESS
11613: OR
11614: IFFALSE 11577
// DialogueOn ;
11616: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11620: LD_EXP 33
11624: PPUSH
11625: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11629: LD_EXP 33
11633: PPUSH
11634: LD_STRING D4Fb-Frank-1
11636: PPUSH
11637: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11641: LD_EXP 21
11645: PPUSH
11646: LD_STRING D4Fb-JMM-1
11648: PPUSH
11649: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11653: LD_INT 2
11655: PPUSH
11656: LD_STRING D4Fb-FSci1-1
11658: PPUSH
11659: CALL 16551 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11663: LD_EXP 33
11667: PPUSH
11668: LD_STRING D4Fb-Frank-2
11670: PPUSH
11671: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11675: LD_EXP 21
11679: PPUSH
11680: LD_STRING D4Fb-JMM-2
11682: PPUSH
11683: CALL_OW 88
// DialogueOff ;
11687: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11691: LD_EXP 33
11695: PPUSH
11696: LD_INT 1
11698: PPUSH
11699: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11703: LD_EXP 34
11707: PPUSH
11708: CALL_OW 302
11712: PUSH
11713: LD_EXP 33
11717: NOT
11718: AND
11719: IFFALSE 11867
// begin DialogueOn ;
11721: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11725: LD_EXP 21
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11743: LD_EXP 34
11747: PPUSH
11748: LD_STRING D3Y-Yam-1
11750: PPUSH
11751: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11755: LD_EXP 21
11759: PPUSH
11760: LD_STRING D3Y-JMM-1
11762: PPUSH
11763: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11767: LD_EXP 34
11771: PPUSH
11772: LD_STRING D3Y-Yam-2
11774: PPUSH
11775: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11779: LD_STRING QYamoko
11781: PPUSH
11782: CALL_OW 97
11786: PUSH
11787: LD_INT 1
11789: DOUBLE
11790: EQUAL
11791: IFTRUE 11795
11793: GO 11830
11795: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11796: LD_EXP 21
11800: PPUSH
11801: LD_STRING D3Ya-JMM-1
11803: PPUSH
11804: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11808: LD_EXP 34
11812: PPUSH
11813: LD_STRING D3Ya-Yam-1
11815: PPUSH
11816: CALL_OW 88
// us_scout := 1 ;
11820: LD_ADDR_EXP 8
11824: PUSH
11825: LD_INT 1
11827: ST_TO_ADDR
// end ; 2 :
11828: GO 11863
11830: LD_INT 2
11832: DOUBLE
11833: EQUAL
11834: IFTRUE 11838
11836: GO 11862
11838: POP
// begin us_scout := - 1 ;
11839: LD_ADDR_EXP 8
11843: PUSH
11844: LD_INT 1
11846: NEG
11847: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11848: LD_EXP 21
11852: PPUSH
11853: LD_STRING D3Yb-JMM-1
11855: PPUSH
11856: CALL_OW 88
// end ; end ;
11860: GO 11863
11862: POP
// DialogueOff ;
11863: CALL_OW 7
// end ; if Frank then
11867: LD_EXP 33
11871: IFFALSE 11875
// exit ;
11873: GO 12636
// if us_scout in [ - 1 , 0 ] then
11875: LD_EXP 8
11879: PUSH
11880: LD_INT 1
11882: NEG
11883: PUSH
11884: LD_INT 0
11886: PUSH
11887: EMPTY
11888: LIST
11889: LIST
11890: IN
11891: IFFALSE 11895
// exit ;
11893: GO 12636
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11895: LD_ADDR_EXP 8
11899: PUSH
11900: LD_INT 2
11902: PUSH
11903: LD_INT 2
11905: PUSH
11906: LD_INT 1
11908: PUSH
11909: EMPTY
11910: LIST
11911: LIST
11912: LIST
11913: PUSH
11914: LD_OWVAR 67
11918: ARRAY
11919: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11920: LD_EXP 8
11924: PUSH
11925: LD_INT 1
11927: PUSH
11928: LD_INT 2
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: IN
11935: IFFALSE 12636
// begin if IsInUnit ( Kikuchi ) then
11937: LD_EXP 34
11941: PPUSH
11942: CALL_OW 310
11946: IFFALSE 11957
// ComExitBuilding ( Kikuchi ) ;
11948: LD_EXP 34
11952: PPUSH
11953: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11957: LD_EXP 34
11961: PPUSH
11962: CALL_OW 311
11966: IFFALSE 11977
// ComExitVehicle ( Kikuchi ) ;
11968: LD_EXP 34
11972: PPUSH
11973: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11977: LD_EXP 34
11981: PPUSH
11982: LD_INT 4
11984: PPUSH
11985: CALL_OW 235
// wait ( 0 0$1 ) ;
11989: LD_INT 35
11991: PPUSH
11992: CALL_OW 67
// if us_scout = 2 then
11996: LD_EXP 8
12000: PUSH
12001: LD_INT 2
12003: EQUAL
12004: IFFALSE 12384
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12006: LD_EXP 34
12010: PPUSH
12011: LD_INT 75
12013: PPUSH
12014: LD_INT 63
12016: PPUSH
12017: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12021: LD_EXP 34
12025: PPUSH
12026: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12030: LD_EXP 34
12034: PPUSH
12035: LD_INT 770
12037: PPUSH
12038: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12042: LD_EXP 34
12046: PPUSH
12047: LD_INT 100
12049: PPUSH
12050: LD_INT 75
12052: PPUSH
12053: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12057: LD_EXP 34
12061: PPUSH
12062: LD_INT 123
12064: PPUSH
12065: LD_INT 103
12067: PPUSH
12068: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12072: LD_EXP 34
12076: PPUSH
12077: LD_INT 138
12079: PPUSH
12080: LD_INT 108
12082: PPUSH
12083: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12087: LD_EXP 34
12091: PPUSH
12092: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12096: LD_INT 35
12098: PPUSH
12099: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12103: LD_EXP 34
12107: PPUSH
12108: LD_INT 138
12110: PPUSH
12111: LD_INT 108
12113: PPUSH
12114: CALL_OW 307
12118: IFFALSE 12096
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12120: LD_EXP 34
12124: PPUSH
12125: LD_INT 125
12127: PPUSH
12128: LD_INT 132
12130: PPUSH
12131: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12135: LD_INT 35
12137: PPUSH
12138: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12142: LD_INT 1
12144: PPUSH
12145: LD_EXP 34
12149: PPUSH
12150: CALL_OW 292
12154: PUSH
12155: LD_EXP 34
12159: PPUSH
12160: LD_INT 7
12162: PPUSH
12163: CALL_OW 296
12167: PUSH
12168: LD_INT 7
12170: LESS
12171: OR
12172: IFFALSE 12135
// DialogueOn ;
12174: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12178: LD_EXP 34
12182: PPUSH
12183: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12187: LD_INT 10
12189: PPUSH
12190: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12194: LD_EXP 34
12198: PPUSH
12199: LD_STRING D4Ya-Yam-1
12201: PPUSH
12202: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12206: LD_EXP 21
12210: PPUSH
12211: LD_STRING D4Ya-JMM-1
12213: PPUSH
12214: CALL_OW 88
// for i in points do
12218: LD_ADDR_VAR 0 1
12222: PUSH
12223: LD_VAR 0 2
12227: PUSH
12228: FOR_IN
12229: IFFALSE 12287
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12231: LD_VAR 0 1
12235: PUSH
12236: LD_INT 1
12238: ARRAY
12239: PPUSH
12240: LD_VAR 0 1
12244: PUSH
12245: LD_INT 2
12247: ARRAY
12248: PPUSH
12249: LD_INT 1
12251: PPUSH
12252: LD_INT 20
12254: NEG
12255: PPUSH
12256: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12260: LD_VAR 0 1
12264: PUSH
12265: LD_INT 1
12267: ARRAY
12268: PPUSH
12269: LD_VAR 0 1
12273: PUSH
12274: LD_INT 2
12276: ARRAY
12277: PPUSH
12278: LD_INT 1
12280: PPUSH
12281: CALL_OW 331
// end ;
12285: GO 12228
12287: POP
12288: POP
// dwait ( 0 0$0.5 ) ;
12289: LD_INT 18
12291: PPUSH
12292: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12296: LD_INT 42
12298: PPUSH
12299: LD_INT 27
12301: PPUSH
12302: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12306: LD_EXP 34
12310: PPUSH
12311: LD_STRING D4Ya-Yam-2
12313: PPUSH
12314: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12318: LD_INT 18
12320: PPUSH
12321: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12325: LD_INT 118
12327: PPUSH
12328: LD_INT 80
12330: PPUSH
12331: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12335: LD_EXP 21
12339: PPUSH
12340: LD_STRING D4Ya-JMM-2
12342: PPUSH
12343: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12347: LD_EXP 34
12351: PPUSH
12352: LD_STRING D4Ya-Yam-3
12354: PPUSH
12355: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12359: LD_INT 10
12361: PPUSH
12362: CALL_OW 68
// DialogueOff ;
12366: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12370: LD_EXP 34
12374: PPUSH
12375: LD_INT 1
12377: PPUSH
12378: CALL_OW 235
// end else
12382: GO 12636
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12384: LD_INT 2
12386: PPUSH
12387: LD_INT 4
12389: PPUSH
12390: LD_INT 2
12392: PPUSH
12393: LD_INT 1
12395: PPUSH
12396: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12400: LD_EXP 34
12404: PPUSH
12405: LD_INT 75
12407: PPUSH
12408: LD_INT 63
12410: PPUSH
12411: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12415: LD_EXP 34
12419: PPUSH
12420: LD_INT 175
12422: PPUSH
12423: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12427: LD_EXP 34
12431: PPUSH
12432: LD_INT 102
12434: PPUSH
12435: LD_INT 76
12437: PPUSH
12438: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12442: LD_EXP 34
12446: PPUSH
12447: LD_INT 108
12449: PPUSH
12450: LD_INT 70
12452: PPUSH
12453: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12457: LD_INT 35
12459: PPUSH
12460: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12464: LD_INT 2
12466: PPUSH
12467: LD_EXP 34
12471: PPUSH
12472: CALL_OW 292
12476: IFFALSE 12457
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12478: LD_EXP 34
12482: PPUSH
12483: LD_INT 112
12485: PPUSH
12486: LD_INT 118
12488: PPUSH
12489: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12493: LD_EXP 34
12497: PPUSH
12498: CALL_OW 256
12502: PUSH
12503: LD_INT 750
12505: GREATEREQUAL
12506: IFFALSE 12520
// SetLives ( Kikuchi , 700 ) ;
12508: LD_EXP 34
12512: PPUSH
12513: LD_INT 700
12515: PPUSH
12516: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12520: LD_INT 35
12522: PPUSH
12523: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12527: LD_INT 1
12529: PPUSH
12530: LD_EXP 34
12534: PPUSH
12535: CALL_OW 292
12539: PUSH
12540: LD_EXP 34
12544: PPUSH
12545: LD_INT 7
12547: PPUSH
12548: CALL_OW 296
12552: PUSH
12553: LD_INT 17
12555: LESS
12556: OR
12557: IFFALSE 12520
// DialogueOn ;
12559: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12563: LD_EXP 34
12567: PPUSH
12568: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12572: LD_EXP 34
12576: PPUSH
12577: LD_STRING D4Yb-Yam-1
12579: PPUSH
12580: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12584: LD_EXP 21
12588: PPUSH
12589: LD_STRING D4Yb-JMM-1
12591: PPUSH
12592: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12596: LD_EXP 34
12600: PPUSH
12601: LD_STRING D4Yb-Yam-2
12603: PPUSH
12604: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12608: LD_EXP 21
12612: PPUSH
12613: LD_STRING D4Yb-JMM-2
12615: PPUSH
12616: CALL_OW 88
// DialogueOff ;
12620: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12624: LD_EXP 34
12628: PPUSH
12629: LD_INT 1
12631: PPUSH
12632: CALL_OW 235
// end ; end ; end ;
12636: PPOPN 2
12638: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12639: LD_EXP 6
12643: IFFALSE 13676
12645: GO 12647
12647: DISABLE
12648: LD_INT 0
12650: PPUSH
12651: PPUSH
12652: PPUSH
12653: PPUSH
// begin enable ;
12654: ENABLE
// if not seen [ 1 ] then
12655: LD_EXP 9
12659: PUSH
12660: LD_INT 1
12662: ARRAY
12663: NOT
12664: IFFALSE 12844
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12666: LD_ADDR_VAR 0 2
12670: PUSH
12671: LD_INT 22
12673: PUSH
12674: LD_INT 2
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: LD_INT 2
12683: PUSH
12684: LD_INT 25
12686: PUSH
12687: LD_INT 11
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PUSH
12694: LD_INT 33
12696: PUSH
12697: LD_INT 4
12699: PUSH
12700: EMPTY
12701: LIST
12702: LIST
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: LIST
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PPUSH
12713: CALL_OW 69
12717: ST_TO_ADDR
// if tmp then
12718: LD_VAR 0 2
12722: IFFALSE 12844
// for i in tmp do
12724: LD_ADDR_VAR 0 1
12728: PUSH
12729: LD_VAR 0 2
12733: PUSH
12734: FOR_IN
12735: IFFALSE 12842
// if See ( 1 , i ) then
12737: LD_INT 1
12739: PPUSH
12740: LD_VAR 0 1
12744: PPUSH
12745: CALL_OW 292
12749: IFFALSE 12840
// begin seen := Replace ( seen , 1 , true ) ;
12751: LD_ADDR_EXP 9
12755: PUSH
12756: LD_EXP 9
12760: PPUSH
12761: LD_INT 1
12763: PPUSH
12764: LD_INT 1
12766: PPUSH
12767: CALL_OW 1
12771: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12772: LD_INT 1
12774: PPUSH
12775: CALL 16373 0 1
12779: IFFALSE 12840
// begin DialogueOn ;
12781: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12785: LD_VAR 0 1
12789: PPUSH
12790: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12794: LD_INT 10
12796: PPUSH
12797: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12801: LD_ADDR_VAR 0 3
12805: PUSH
12806: LD_INT 1
12808: PPUSH
12809: LD_STRING D5a-Sol2-1
12811: PPUSH
12812: CALL 16551 0 2
12816: ST_TO_ADDR
// if not un then
12817: LD_VAR 0 3
12821: NOT
12822: IFFALSE 12834
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12824: LD_INT 2
12826: PPUSH
12827: LD_STRING D5a-FSol2-1
12829: PPUSH
12830: CALL 16551 0 2
// DialogueOff ;
12834: CALL_OW 7
// break ;
12838: GO 12842
// end ; end ;
12840: GO 12734
12842: POP
12843: POP
// end ; if not seen [ 2 ] then
12844: LD_EXP 9
12848: PUSH
12849: LD_INT 2
12851: ARRAY
12852: NOT
12853: IFFALSE 13078
// begin can_kamikazed := true ;
12855: LD_ADDR_EXP 10
12859: PUSH
12860: LD_INT 1
12862: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12863: LD_ADDR_VAR 0 2
12867: PUSH
12868: LD_INT 22
12870: PUSH
12871: LD_INT 2
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PUSH
12878: LD_INT 25
12880: PUSH
12881: LD_INT 17
12883: PUSH
12884: EMPTY
12885: LIST
12886: LIST
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PPUSH
12892: CALL_OW 69
12896: ST_TO_ADDR
// if tmp then
12897: LD_VAR 0 2
12901: IFFALSE 13078
// for i in tmp do
12903: LD_ADDR_VAR 0 1
12907: PUSH
12908: LD_VAR 0 2
12912: PUSH
12913: FOR_IN
12914: IFFALSE 13076
// if See ( 1 , i ) then
12916: LD_INT 1
12918: PPUSH
12919: LD_VAR 0 1
12923: PPUSH
12924: CALL_OW 292
12928: IFFALSE 13074
// begin seen := Replace ( seen , 2 , true ) ;
12930: LD_ADDR_EXP 9
12934: PUSH
12935: LD_EXP 9
12939: PPUSH
12940: LD_INT 2
12942: PPUSH
12943: LD_INT 1
12945: PPUSH
12946: CALL_OW 1
12950: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12951: LD_INT 1
12953: PPUSH
12954: CALL 16373 0 1
12958: IFFALSE 13074
// begin DialogueOn ;
12960: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12964: LD_VAR 0 1
12968: PPUSH
12969: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12973: LD_INT 10
12975: PPUSH
12976: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12980: LD_ADDR_VAR 0 3
12984: PUSH
12985: LD_INT 1
12987: PPUSH
12988: LD_STRING D5b-Sol1-1
12990: PPUSH
12991: CALL 16551 0 2
12995: ST_TO_ADDR
// if not un then
12996: LD_VAR 0 3
13000: NOT
13001: IFFALSE 13019
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13003: LD_ADDR_VAR 0 3
13007: PUSH
13008: LD_INT 2
13010: PPUSH
13011: LD_STRING D5b-FSol1-1
13013: PPUSH
13014: CALL 16551 0 2
13018: ST_TO_ADDR
// if un then
13019: LD_VAR 0 3
13023: IFFALSE 13068
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13025: LD_ADDR_VAR 0 4
13029: PUSH
13030: LD_INT 1
13032: PPUSH
13033: LD_STRING D5b-Sol2-1
13035: PPUSH
13036: LD_VAR 0 3
13040: PPUSH
13041: CALL 16777 0 3
13045: ST_TO_ADDR
// if not un2 then
13046: LD_VAR 0 4
13050: NOT
13051: IFFALSE 13068
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13053: LD_INT 2
13055: PPUSH
13056: LD_STRING D5b-FSol2-1
13058: PPUSH
13059: LD_VAR 0 3
13063: PPUSH
13064: CALL 16777 0 3
// end ; DialogueOff ;
13068: CALL_OW 7
// break ;
13072: GO 13076
// end ; end ;
13074: GO 12913
13076: POP
13077: POP
// end ; if not seen [ 3 ] then
13078: LD_EXP 9
13082: PUSH
13083: LD_INT 3
13085: ARRAY
13086: NOT
13087: IFFALSE 13261
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13089: LD_ADDR_VAR 0 2
13093: PUSH
13094: LD_INT 22
13096: PUSH
13097: LD_INT 2
13099: PUSH
13100: EMPTY
13101: LIST
13102: LIST
13103: PUSH
13104: LD_INT 33
13106: PUSH
13107: LD_INT 2
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PPUSH
13118: CALL_OW 69
13122: ST_TO_ADDR
// if tmp then
13123: LD_VAR 0 2
13127: IFFALSE 13261
// for i in tmp do
13129: LD_ADDR_VAR 0 1
13133: PUSH
13134: LD_VAR 0 2
13138: PUSH
13139: FOR_IN
13140: IFFALSE 13259
// if See ( 1 , i ) then
13142: LD_INT 1
13144: PPUSH
13145: LD_VAR 0 1
13149: PPUSH
13150: CALL_OW 292
13154: IFFALSE 13257
// begin seen := Replace ( seen , 3 , true ) ;
13156: LD_ADDR_EXP 9
13160: PUSH
13161: LD_EXP 9
13165: PPUSH
13166: LD_INT 3
13168: PPUSH
13169: LD_INT 1
13171: PPUSH
13172: CALL_OW 1
13176: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13177: LD_INT 1
13179: PPUSH
13180: CALL 16373 0 1
13184: IFFALSE 13257
// begin DialogueOn ;
13186: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13190: LD_VAR 0 1
13194: PPUSH
13195: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13199: LD_INT 10
13201: PPUSH
13202: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13206: LD_ADDR_VAR 0 3
13210: PUSH
13211: LD_INT 1
13213: PPUSH
13214: LD_STRING D8-Sol1-1
13216: PPUSH
13217: CALL 16551 0 2
13221: ST_TO_ADDR
// if not un then
13222: LD_VAR 0 3
13226: NOT
13227: IFFALSE 13239
// SayRand ( sex_female , D8-FSol1-1 ) ;
13229: LD_INT 2
13231: PPUSH
13232: LD_STRING D8-FSol1-1
13234: PPUSH
13235: CALL 16551 0 2
// Say ( JMM , D8-JMM-1 ) ;
13239: LD_EXP 21
13243: PPUSH
13244: LD_STRING D8-JMM-1
13246: PPUSH
13247: CALL_OW 88
// DialogueOff ;
13251: CALL_OW 7
// break ;
13255: GO 13259
// end ; end ;
13257: GO 13139
13259: POP
13260: POP
// end ; if not seen [ 4 ] then
13261: LD_EXP 9
13265: PUSH
13266: LD_INT 4
13268: ARRAY
13269: NOT
13270: IFFALSE 13432
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13272: LD_ADDR_VAR 0 2
13276: PUSH
13277: LD_INT 22
13279: PUSH
13280: LD_INT 2
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: PUSH
13287: LD_INT 33
13289: PUSH
13290: LD_INT 5
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: EMPTY
13298: LIST
13299: LIST
13300: PPUSH
13301: CALL_OW 69
13305: ST_TO_ADDR
// if tmp then
13306: LD_VAR 0 2
13310: IFFALSE 13432
// for i in tmp do
13312: LD_ADDR_VAR 0 1
13316: PUSH
13317: LD_VAR 0 2
13321: PUSH
13322: FOR_IN
13323: IFFALSE 13430
// if See ( 1 , i ) then
13325: LD_INT 1
13327: PPUSH
13328: LD_VAR 0 1
13332: PPUSH
13333: CALL_OW 292
13337: IFFALSE 13428
// begin seen := Replace ( seen , 4 , true ) ;
13339: LD_ADDR_EXP 9
13343: PUSH
13344: LD_EXP 9
13348: PPUSH
13349: LD_INT 4
13351: PPUSH
13352: LD_INT 1
13354: PPUSH
13355: CALL_OW 1
13359: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13360: LD_INT 1
13362: PPUSH
13363: CALL 16373 0 1
13367: IFFALSE 13428
// begin DialogueOn ;
13369: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13373: LD_VAR 0 1
13377: PPUSH
13378: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13382: LD_INT 10
13384: PPUSH
13385: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13389: LD_ADDR_VAR 0 3
13393: PUSH
13394: LD_INT 1
13396: PPUSH
13397: LD_STRING D5a-Sol1-1
13399: PPUSH
13400: CALL 16551 0 2
13404: ST_TO_ADDR
// if not un then
13405: LD_VAR 0 3
13409: NOT
13410: IFFALSE 13422
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13412: LD_INT 2
13414: PPUSH
13415: LD_STRING D5a-FSol1-1
13417: PPUSH
13418: CALL 16551 0 2
// DialogueOff ;
13422: CALL_OW 7
// break ;
13426: GO 13430
// end ; end ;
13428: GO 13322
13430: POP
13431: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13432: LD_EXP 9
13436: PUSH
13437: LD_INT 5
13439: ARRAY
13440: NOT
13441: PUSH
13442: LD_EXP 9
13446: PUSH
13447: LD_INT 3
13449: ARRAY
13450: AND
13451: IFFALSE 13625
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13453: LD_ADDR_VAR 0 2
13457: PUSH
13458: LD_INT 22
13460: PUSH
13461: LD_INT 2
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PUSH
13468: LD_INT 34
13470: PUSH
13471: LD_INT 31
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: PPUSH
13482: CALL_OW 69
13486: ST_TO_ADDR
// if tmp then
13487: LD_VAR 0 2
13491: IFFALSE 13625
// for i in tmp do
13493: LD_ADDR_VAR 0 1
13497: PUSH
13498: LD_VAR 0 2
13502: PUSH
13503: FOR_IN
13504: IFFALSE 13623
// if See ( 1 , i ) then
13506: LD_INT 1
13508: PPUSH
13509: LD_VAR 0 1
13513: PPUSH
13514: CALL_OW 292
13518: IFFALSE 13621
// begin seen := Replace ( seen , 5 , true ) ;
13520: LD_ADDR_EXP 9
13524: PUSH
13525: LD_EXP 9
13529: PPUSH
13530: LD_INT 5
13532: PPUSH
13533: LD_INT 1
13535: PPUSH
13536: CALL_OW 1
13540: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13541: LD_INT 1
13543: PPUSH
13544: CALL 16373 0 1
13548: IFFALSE 13621
// begin DialogueOn ;
13550: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13554: LD_VAR 0 1
13558: PPUSH
13559: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13563: LD_INT 10
13565: PPUSH
13566: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13570: LD_ADDR_VAR 0 3
13574: PUSH
13575: LD_INT 1
13577: PPUSH
13578: LD_STRING D8a-Sol2-1
13580: PPUSH
13581: CALL 16551 0 2
13585: ST_TO_ADDR
// if not un then
13586: LD_VAR 0 3
13590: NOT
13591: IFFALSE 13603
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13593: LD_INT 2
13595: PPUSH
13596: LD_STRING D8a-FSol2-1
13598: PPUSH
13599: CALL 16551 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13603: LD_EXP 21
13607: PPUSH
13608: LD_STRING D8a-JMM-1
13610: PPUSH
13611: CALL_OW 88
// DialogueOff ;
13615: CALL_OW 7
// break ;
13619: GO 13623
// end ; end ;
13621: GO 13503
13623: POP
13624: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13625: LD_EXP 9
13629: PUSH
13630: LD_INT 1
13632: ARRAY
13633: PUSH
13634: LD_EXP 9
13638: PUSH
13639: LD_INT 2
13641: ARRAY
13642: AND
13643: PUSH
13644: LD_EXP 9
13648: PUSH
13649: LD_INT 3
13651: ARRAY
13652: AND
13653: PUSH
13654: LD_EXP 9
13658: PUSH
13659: LD_INT 4
13661: ARRAY
13662: AND
13663: PUSH
13664: LD_EXP 9
13668: PUSH
13669: LD_INT 5
13671: ARRAY
13672: AND
13673: IFFALSE 13676
// disable ;
13675: DISABLE
// end ;
13676: PPOPN 4
13678: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13679: LD_EXP 10
13683: PUSH
13684: LD_EXP 11
13688: AND
13689: IFFALSE 13887
13691: GO 13693
13693: DISABLE
13694: LD_INT 0
13696: PPUSH
// begin DialogueOn ;
13697: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13701: LD_EXP 11
13705: PPUSH
13706: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13710: LD_ADDR_VAR 0 1
13714: PUSH
13715: LD_INT 1
13717: PPUSH
13718: LD_STRING D5c-Sol1-1
13720: PPUSH
13721: CALL 16551 0 2
13725: ST_TO_ADDR
// if not un then
13726: LD_VAR 0 1
13730: NOT
13731: IFFALSE 13749
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13733: LD_ADDR_VAR 0 1
13737: PUSH
13738: LD_INT 2
13740: PPUSH
13741: LD_STRING D5c-FSol1-1
13743: PPUSH
13744: CALL 16551 0 2
13748: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13749: LD_EXP 21
13753: PPUSH
13754: LD_STRING D5c-JMM-1
13756: PPUSH
13757: CALL_OW 88
// if IsOk ( Lisa ) then
13761: LD_EXP 22
13765: PPUSH
13766: CALL_OW 302
13770: IFFALSE 13786
// Say ( Lisa , D5d-Lisa-1 ) else
13772: LD_EXP 22
13776: PPUSH
13777: LD_STRING D5d-Lisa-1
13779: PPUSH
13780: CALL_OW 88
13784: GO 13871
// if IsOk ( Cyrus ) then
13786: LD_EXP 25
13790: PPUSH
13791: CALL_OW 302
13795: IFFALSE 13811
// Say ( Cyrus , D5d-Cyrus-1 ) else
13797: LD_EXP 25
13801: PPUSH
13802: LD_STRING D5d-Cyrus-1
13804: PPUSH
13805: CALL_OW 88
13809: GO 13871
// if IsOk ( Gary ) then
13811: LD_EXP 32
13815: PPUSH
13816: CALL_OW 302
13820: IFFALSE 13836
// Say ( Gary , D5d-Gary-1 ) else
13822: LD_EXP 32
13826: PPUSH
13827: LD_STRING D5d-Gary-1
13829: PPUSH
13830: CALL_OW 88
13834: GO 13871
// if GetSex ( un ) = sex_male then
13836: LD_VAR 0 1
13840: PPUSH
13841: CALL_OW 258
13845: PUSH
13846: LD_INT 1
13848: EQUAL
13849: IFFALSE 13865
// Say ( un , D5d-Sol1-1 ) else
13851: LD_VAR 0 1
13855: PPUSH
13856: LD_STRING D5d-Sol1-1
13858: PPUSH
13859: CALL_OW 88
13863: GO 13871
// begin DialogueOff ;
13865: CALL_OW 7
// exit ;
13869: GO 13887
// end ; Say ( JMM , D5d-JMM-1 ) ;
13871: LD_EXP 21
13875: PPUSH
13876: LD_STRING D5d-JMM-1
13878: PPUSH
13879: CALL_OW 88
// DialogueOff ;
13883: CALL_OW 7
// end ;
13887: PPOPN 1
13889: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13890: LD_INT 1
13892: PPUSH
13893: LD_INT 17
13895: PPUSH
13896: CALL_OW 294
13900: PUSH
13901: LD_INT 2
13903: GREATEREQUAL
13904: IFFALSE 14036
13906: GO 13908
13908: DISABLE
13909: LD_INT 0
13911: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13912: LD_INT 10
13914: PPUSH
13915: LD_INT 5
13917: PPUSH
13918: LD_INT 1
13920: PPUSH
13921: LD_INT 10
13923: NEG
13924: PPUSH
13925: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13929: LD_INT 10
13931: PPUSH
13932: LD_INT 5
13934: PPUSH
13935: LD_INT 1
13937: PPUSH
13938: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13942: LD_INT 10
13944: PPUSH
13945: LD_INT 5
13947: PPUSH
13948: CALL_OW 86
// DialogueOn ;
13952: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13956: LD_ADDR_VAR 0 1
13960: PUSH
13961: LD_INT 1
13963: PPUSH
13964: LD_STRING D6-Sci1-1
13966: PPUSH
13967: CALL 16551 0 2
13971: ST_TO_ADDR
// if un then
13972: LD_VAR 0 1
13976: IFFALSE 14014
// begin Say ( JMM , D6-JMM-1 ) ;
13978: LD_EXP 21
13982: PPUSH
13983: LD_STRING D6-JMM-1
13985: PPUSH
13986: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_STRING D6-Sci1-2
13997: PPUSH
13998: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14002: LD_EXP 21
14006: PPUSH
14007: LD_STRING D6-JMM-2
14009: PPUSH
14010: CALL_OW 88
// end ; DialogueOff ;
14014: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14018: LD_STRING M3
14020: PPUSH
14021: CALL_OW 337
// wait ( 0 0$30 ) ;
14025: LD_INT 1050
14027: PPUSH
14028: CALL_OW 67
// AmericanReinforcements ;
14032: CALL 2319 0 0
// end ;
14036: PPOPN 1
14038: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14039: LD_OWVAR 1
14043: PUSH
14044: LD_INT 42000
14046: GREATEREQUAL
14047: PUSH
14048: LD_INT 2
14050: PPUSH
14051: LD_INT 169
14053: PPUSH
14054: LD_INT 90
14056: PPUSH
14057: LD_INT 10
14059: PPUSH
14060: CALL 53721 0 4
14064: PUSH
14065: LD_INT 4
14067: ARRAY
14068: PUSH
14069: LD_INT 0
14071: EQUAL
14072: PUSH
14073: LD_INT 45
14075: PPUSH
14076: CALL_OW 301
14080: OR
14081: PUSH
14082: LD_INT 45
14084: PPUSH
14085: CALL_OW 255
14089: PUSH
14090: LD_INT 1
14092: EQUAL
14093: OR
14094: AND
14095: PUSH
14096: LD_INT 94
14098: PPUSH
14099: CALL_OW 301
14103: NOT
14104: AND
14105: IFFALSE 15310
14107: GO 14109
14109: DISABLE
14110: LD_INT 0
14112: PPUSH
14113: PPUSH
14114: PPUSH
14115: PPUSH
14116: PPUSH
// begin uc_side := 5 ;
14117: LD_ADDR_OWVAR 20
14121: PUSH
14122: LD_INT 5
14124: ST_TO_ADDR
// uc_nation := 2 ;
14125: LD_ADDR_OWVAR 21
14129: PUSH
14130: LD_INT 2
14132: ST_TO_ADDR
// InitHc ;
14133: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14137: LD_INT 1
14139: PPUSH
14140: LD_INT 3
14142: PPUSH
14143: LD_INT 8
14145: PPUSH
14146: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14150: LD_ADDR_OWVAR 29
14154: PUSH
14155: LD_INT 12
14157: PUSH
14158: LD_INT 12
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: ST_TO_ADDR
// hc_name := Hans Fliege ;
14165: LD_ADDR_OWVAR 26
14169: PUSH
14170: LD_STRING Hans Fliege
14172: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14173: LD_ADDR_OWVAR 33
14177: PUSH
14178: LD_STRING SecondCharsGal
14180: ST_TO_ADDR
// hc_face_number := 7 ;
14181: LD_ADDR_OWVAR 34
14185: PUSH
14186: LD_INT 7
14188: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14189: LD_ADDR_EXP 46
14193: PUSH
14194: CALL_OW 44
14198: ST_TO_ADDR
// InitHc ;
14199: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14203: LD_INT 1
14205: PPUSH
14206: LD_INT 16
14208: PPUSH
14209: LD_INT 2
14211: PPUSH
14212: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14216: LD_ADDR_OWVAR 29
14220: PUSH
14221: LD_INT 12
14223: PUSH
14224: LD_INT 12
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: ST_TO_ADDR
// hc_name :=  ;
14231: LD_ADDR_OWVAR 26
14235: PUSH
14236: LD_STRING 
14238: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14239: LD_ADDR_EXP 47
14243: PUSH
14244: CALL_OW 44
14248: ST_TO_ADDR
// InitHc ;
14249: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14253: LD_INT 35
14255: PPUSH
14256: CALL_OW 67
// until not InBattle ( 1 ) ;
14260: LD_INT 1
14262: PPUSH
14263: CALL_OW 463
14267: NOT
14268: IFFALSE 14253
// wait ( 0 0$5 ) ;
14270: LD_INT 175
14272: PPUSH
14273: CALL_OW 67
// DialogueOn ;
14277: CALL_OW 6
// InGameOn ;
14281: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14285: LD_ADDR_VAR 0 1
14289: PUSH
14290: LD_INT 22
14292: PUSH
14293: LD_INT 1
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: LD_INT 2
14302: PUSH
14303: LD_INT 25
14305: PUSH
14306: LD_INT 1
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: PUSH
14313: LD_INT 25
14315: PUSH
14316: LD_INT 2
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: PUSH
14323: LD_INT 25
14325: PUSH
14326: LD_INT 3
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 25
14335: PUSH
14336: LD_INT 4
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: LD_INT 25
14345: PUSH
14346: LD_INT 5
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: LD_INT 25
14355: PUSH
14356: LD_INT 8
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PPUSH
14376: CALL_OW 69
14380: PUSH
14381: LD_EXP 21
14385: PUSH
14386: LD_EXP 22
14390: PUSH
14391: LD_EXP 23
14395: PUSH
14396: LD_EXP 24
14400: PUSH
14401: LD_EXP 25
14405: PUSH
14406: LD_EXP 26
14410: PUSH
14411: LD_EXP 27
14415: PUSH
14416: LD_EXP 28
14420: PUSH
14421: LD_EXP 29
14425: PUSH
14426: LD_EXP 31
14430: PUSH
14431: LD_EXP 32
14435: PUSH
14436: LD_EXP 33
14440: PUSH
14441: LD_EXP 34
14445: PUSH
14446: EMPTY
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: DIFF
14461: PPUSH
14462: LD_INT 26
14464: PUSH
14465: LD_INT 1
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PPUSH
14472: CALL_OW 72
14476: PUSH
14477: LD_INT 1
14479: ARRAY
14480: ST_TO_ADDR
// if Brown then
14481: LD_EXP 27
14485: IFFALSE 14497
// un := Brown ;
14487: LD_ADDR_VAR 0 1
14491: PUSH
14492: LD_EXP 27
14496: ST_TO_ADDR
// if un then
14497: LD_VAR 0 1
14501: IFFALSE 14527
// begin Say ( un , D7-Sol1-1 ) ;
14503: LD_VAR 0 1
14507: PPUSH
14508: LD_STRING D7-Sol1-1
14510: PPUSH
14511: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14515: LD_EXP 21
14519: PPUSH
14520: LD_STRING D7-JMM-1
14522: PPUSH
14523: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14527: LD_EXP 46
14531: PPUSH
14532: LD_STRING D7-Ar1-1
14534: PPUSH
14535: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14539: LD_EXP 21
14543: PPUSH
14544: LD_STRING D7-JMM-2
14546: PPUSH
14547: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14551: LD_EXP 46
14555: PPUSH
14556: LD_STRING D7-Ar1-2
14558: PPUSH
14559: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14563: LD_EXP 21
14567: PPUSH
14568: LD_STRING D7-JMM-3
14570: PPUSH
14571: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14575: LD_EXP 46
14579: PPUSH
14580: LD_STRING D7-Ar1-3
14582: PPUSH
14583: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14587: LD_EXP 21
14591: PPUSH
14592: LD_STRING D7-JMM-4
14594: PPUSH
14595: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14599: LD_EXP 46
14603: PPUSH
14604: LD_STRING D7-Ar1-4
14606: PPUSH
14607: CALL_OW 94
// InGameOff ;
14611: CALL_OW 9
// DialogueOff ;
14615: CALL_OW 7
// case Query ( QCameras ) of 1 :
14619: LD_STRING QCameras
14621: PPUSH
14622: CALL_OW 97
14626: PUSH
14627: LD_INT 1
14629: DOUBLE
14630: EQUAL
14631: IFTRUE 14635
14633: GO 14638
14635: POP
// ; 2 :
14636: GO 14652
14638: LD_INT 2
14640: DOUBLE
14641: EQUAL
14642: IFTRUE 14646
14644: GO 14651
14646: POP
// exit ; end ;
14647: GO 15310
14649: GO 14652
14651: POP
// ChangeMissionObjectives ( MCar ) ;
14652: LD_STRING MCar
14654: PPUSH
14655: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14659: LD_INT 124
14661: PPUSH
14662: LD_INT 90
14664: PPUSH
14665: LD_INT 1
14667: PPUSH
14668: LD_INT 6
14670: NEG
14671: PPUSH
14672: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14676: LD_INT 124
14678: PPUSH
14679: LD_INT 90
14681: PPUSH
14682: LD_INT 1
14684: PPUSH
14685: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14689: LD_INT 12
14691: PPUSH
14692: LD_INT 1
14694: PPUSH
14695: CALL_OW 424
// wait ( 3 ) ;
14699: LD_INT 3
14701: PPUSH
14702: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14706: LD_INT 124
14708: PPUSH
14709: LD_INT 90
14711: PPUSH
14712: CALL_OW 86
// cargo := false ;
14716: LD_ADDR_VAR 0 3
14720: PUSH
14721: LD_INT 0
14723: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14724: LD_INT 35
14726: PPUSH
14727: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 12
14738: PPUSH
14739: LD_INT 32
14741: PUSH
14742: LD_INT 3
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: PUSH
14749: LD_INT 34
14751: PUSH
14752: LD_INT 32
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 58
14761: PUSH
14762: EMPTY
14763: LIST
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: LIST
14769: PPUSH
14770: CALL_OW 70
14774: ST_TO_ADDR
// until cargo ;
14775: LD_VAR 0 3
14779: IFFALSE 14724
// cargo := cargo [ 1 ] ;
14781: LD_ADDR_VAR 0 3
14785: PUSH
14786: LD_VAR 0 3
14790: PUSH
14791: LD_INT 1
14793: ARRAY
14794: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14795: LD_VAR 0 3
14799: PPUSH
14800: LD_INT 5
14802: PPUSH
14803: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14807: LD_INT 12
14809: PPUSH
14810: LD_INT 0
14812: PPUSH
14813: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14817: LD_EXP 46
14821: PPUSH
14822: LD_INT 11
14824: PPUSH
14825: LD_INT 0
14827: PPUSH
14828: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14832: LD_EXP 47
14836: PPUSH
14837: LD_INT 11
14839: PPUSH
14840: LD_INT 0
14842: PPUSH
14843: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14847: LD_EXP 46
14851: PUSH
14852: LD_EXP 47
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PPUSH
14861: LD_INT 12
14863: PPUSH
14864: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14868: LD_EXP 46
14872: PPUSH
14873: LD_VAR 0 3
14877: PPUSH
14878: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14882: LD_EXP 46
14886: PUSH
14887: LD_EXP 47
14891: PUSH
14892: EMPTY
14893: LIST
14894: LIST
14895: PPUSH
14896: LD_INT 209
14898: PPUSH
14899: LD_INT 178
14901: PPUSH
14902: CALL_OW 171
// escaped := 0 ;
14906: LD_ADDR_VAR 0 5
14910: PUSH
14911: LD_INT 0
14913: ST_TO_ADDR
// while ( true ) do
14914: LD_INT 1
14916: IFFALSE 15132
// begin wait ( 0 0$1 ) ;
14918: LD_INT 35
14920: PPUSH
14921: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14925: LD_EXP 46
14929: PPUSH
14930: CALL_OW 314
14934: NOT
14935: PUSH
14936: LD_EXP 47
14940: PPUSH
14941: CALL_OW 314
14945: NOT
14946: OR
14947: IFFALSE 14973
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14949: LD_EXP 46
14953: PUSH
14954: LD_EXP 47
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PPUSH
14963: LD_INT 209
14965: PPUSH
14966: LD_INT 178
14968: PPUSH
14969: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14973: LD_EXP 46
14977: PPUSH
14978: LD_INT 10
14980: PPUSH
14981: CALL_OW 308
14985: IFFALSE 15010
// begin RemoveUnit ( ar_mechanic ) ;
14987: LD_EXP 46
14991: PPUSH
14992: CALL_OW 64
// escaped := escaped + 1 ;
14996: LD_ADDR_VAR 0 5
15000: PUSH
15001: LD_VAR 0 5
15005: PUSH
15006: LD_INT 1
15008: PLUS
15009: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15010: LD_EXP 47
15014: PPUSH
15015: LD_INT 10
15017: PPUSH
15018: CALL_OW 308
15022: IFFALSE 15047
// begin RemoveUnit ( ar_mechanic_friend ) ;
15024: LD_EXP 47
15028: PPUSH
15029: CALL_OW 64
// escaped := escaped + 1 ;
15033: LD_ADDR_VAR 0 5
15037: PUSH
15038: LD_VAR 0 5
15042: PUSH
15043: LD_INT 1
15045: PLUS
15046: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15047: LD_VAR 0 3
15051: PPUSH
15052: LD_INT 10
15054: PPUSH
15055: CALL_OW 308
15059: IFFALSE 15070
// RemoveUnit ( cargo ) ;
15061: LD_VAR 0 3
15065: PPUSH
15066: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15070: LD_EXP 46
15074: PPUSH
15075: CALL_OW 305
15079: NOT
15080: PUSH
15081: LD_VAR 0 5
15085: PUSH
15086: LD_INT 2
15088: GREATEREQUAL
15089: AND
15090: IFFALSE 15094
// break ;
15092: GO 15132
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15094: LD_EXP 46
15098: PPUSH
15099: CALL_OW 305
15103: NOT
15104: PUSH
15105: LD_EXP 47
15109: PPUSH
15110: CALL_OW 305
15114: NOT
15115: AND
15116: PUSH
15117: LD_VAR 0 5
15121: PUSH
15122: LD_INT 2
15124: LESS
15125: AND
15126: IFFALSE 15130
// exit ;
15128: GO 15310
// end ;
15130: GO 14914
// wait ( 0 0$2 ) ;
15132: LD_INT 70
15134: PPUSH
15135: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15139: LD_EXP 46
15143: PPUSH
15144: LD_STRING D7a-Ar1-1
15146: PPUSH
15147: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15151: LD_ADDR_VAR 0 4
15155: PUSH
15156: LD_INT 129
15158: PUSH
15159: LD_INT 10
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: PUSH
15166: LD_INT 103
15168: PUSH
15169: LD_INT 6
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: PUSH
15176: LD_INT 148
15178: PUSH
15179: LD_INT 47
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: PUSH
15186: LD_INT 155
15188: PUSH
15189: LD_INT 16
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: ST_TO_ADDR
// if Difficulty = 1 then
15202: LD_OWVAR 67
15206: PUSH
15207: LD_INT 1
15209: EQUAL
15210: IFFALSE 15247
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15212: LD_ADDR_VAR 0 4
15216: PUSH
15217: LD_VAR 0 4
15221: PUSH
15222: LD_INT 78
15224: PUSH
15225: LD_INT 7
15227: PUSH
15228: EMPTY
15229: LIST
15230: LIST
15231: PUSH
15232: LD_INT 104
15234: PUSH
15235: LD_INT 43
15237: PUSH
15238: EMPTY
15239: LIST
15240: LIST
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: ADD
15246: ST_TO_ADDR
// for i in tmp do
15247: LD_ADDR_VAR 0 2
15251: PUSH
15252: LD_VAR 0 4
15256: PUSH
15257: FOR_IN
15258: IFFALSE 15291
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15260: LD_VAR 0 2
15264: PUSH
15265: LD_INT 1
15267: ARRAY
15268: PPUSH
15269: LD_VAR 0 2
15273: PUSH
15274: LD_INT 2
15276: ARRAY
15277: PPUSH
15278: LD_INT 1
15280: PPUSH
15281: LD_INT 9
15283: NEG
15284: PPUSH
15285: CALL_OW 330
15289: GO 15257
15291: POP
15292: POP
// SetAchievement ( ACH_FRIEND ) ;
15293: LD_STRING ACH_FRIEND
15295: PPUSH
15296: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15300: LD_INT 129
15302: PPUSH
15303: LD_INT 10
15305: PPUSH
15306: CALL_OW 84
// end ;
15310: PPOPN 5
15312: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15313: LD_EXP 15
15317: PUSH
15318: LD_INT 21000
15320: MINUS
15321: PUSH
15322: LD_OWVAR 1
15326: LESSEQUAL
15327: IFFALSE 15367
15329: GO 15331
15331: DISABLE
// begin powell_warn := true ;
15332: LD_ADDR_EXP 16
15336: PUSH
15337: LD_INT 1
15339: ST_TO_ADDR
// DialogueOn ;
15340: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15344: LD_EXP 30
15348: PPUSH
15349: LD_STRING D9-Pow-1
15351: PPUSH
15352: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15356: LD_INT 10
15358: PPUSH
15359: CALL_OW 68
// DialogueOff ;
15363: CALL_OW 7
// end ;
15367: END
// every 0 0$1 trigger game_time <= tick do
15368: LD_EXP 15
15372: PUSH
15373: LD_OWVAR 1
15377: LESSEQUAL
15378: IFFALSE 15417
15380: GO 15382
15382: DISABLE
// begin DialogueOn ;
15383: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15387: LD_EXP 30
15391: PPUSH
15392: LD_STRING D9a-Pow-1
15394: PPUSH
15395: CALL_OW 94
// dwait ( 0 0$2 ) ;
15399: LD_INT 70
15401: PPUSH
15402: CALL_OW 68
// DialogueOff ;
15406: CALL_OW 7
// YouLost ( Command ) ;
15410: LD_STRING Command
15412: PPUSH
15413: CALL_OW 104
// end ;
15417: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15418: LD_INT 22
15420: PUSH
15421: LD_INT 2
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: LD_INT 30
15430: PUSH
15431: LD_INT 1
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: EMPTY
15439: LIST
15440: LIST
15441: PPUSH
15442: CALL_OW 69
15446: PUSH
15447: LD_INT 0
15449: EQUAL
15450: PUSH
15451: LD_EXP 21
15455: PPUSH
15456: CALL_OW 302
15460: AND
15461: IFFALSE 16370
15463: GO 15465
15465: DISABLE
15466: LD_INT 0
15468: PPUSH
15469: PPUSH
15470: PPUSH
15471: PPUSH
// begin m1 := false ;
15472: LD_ADDR_VAR 0 2
15476: PUSH
15477: LD_INT 0
15479: ST_TO_ADDR
// m2 := false ;
15480: LD_ADDR_VAR 0 3
15484: PUSH
15485: LD_INT 0
15487: ST_TO_ADDR
// m3 := false ;
15488: LD_ADDR_VAR 0 4
15492: PUSH
15493: LD_INT 0
15495: ST_TO_ADDR
// if not am_veh_consturcted then
15496: LD_EXP 20
15500: NOT
15501: IFFALSE 15510
// SetAchievement ( ACH_ARABTECH ) ;
15503: LD_STRING ACH_ARABTECH
15505: PPUSH
15506: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15510: LD_OWVAR 1
15514: PUSH
15515: LD_INT 252000
15517: PUSH
15518: LD_INT 210000
15520: PUSH
15521: LD_INT 199500
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: LIST
15528: PUSH
15529: LD_OWVAR 67
15533: ARRAY
15534: LESS
15535: IFFALSE 15557
// begin m3 := true ;
15537: LD_ADDR_VAR 0 4
15541: PUSH
15542: LD_INT 1
15544: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15545: LD_STRING Time1
15547: PPUSH
15548: LD_INT 1
15550: PPUSH
15551: CALL_OW 101
// end else
15555: GO 15588
// if not powell_warn then
15557: LD_EXP 16
15561: NOT
15562: IFFALSE 15577
// AddMedal ( Time1 , - 1 ) else
15564: LD_STRING Time1
15566: PPUSH
15567: LD_INT 1
15569: NEG
15570: PPUSH
15571: CALL_OW 101
15575: GO 15588
// AddMedal ( Time1 , - 2 ) ;
15577: LD_STRING Time1
15579: PPUSH
15580: LD_INT 2
15582: NEG
15583: PPUSH
15584: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15588: LD_EXP 17
15592: PUSH
15593: LD_INT 5
15595: PUSH
15596: LD_INT 4
15598: PUSH
15599: LD_INT 3
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: LIST
15606: PUSH
15607: LD_OWVAR 67
15611: ARRAY
15612: GREATEREQUAL
15613: IFFALSE 15628
// AddMedal ( Destroy , - 2 ) else
15615: LD_STRING Destroy
15617: PPUSH
15618: LD_INT 2
15620: NEG
15621: PPUSH
15622: CALL_OW 101
15626: GO 15761
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15628: LD_INT 22
15630: PUSH
15631: LD_INT 2
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: PUSH
15638: LD_INT 21
15640: PUSH
15641: LD_INT 3
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PUSH
15648: LD_INT 50
15650: PUSH
15651: EMPTY
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: LIST
15658: PPUSH
15659: CALL_OW 69
15663: PUSH
15664: LD_INT 25
15666: GREATEREQUAL
15667: IFFALSE 15682
// AddMedal ( Destroy , - 1 ) else
15669: LD_STRING Destroy
15671: PPUSH
15672: LD_INT 1
15674: NEG
15675: PPUSH
15676: CALL_OW 101
15680: GO 15761
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15682: LD_INT 22
15684: PUSH
15685: LD_INT 2
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: LD_INT 21
15694: PUSH
15695: LD_INT 3
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: PUSH
15702: LD_INT 50
15704: PUSH
15705: EMPTY
15706: LIST
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: LIST
15712: PPUSH
15713: CALL_OW 69
15717: PUSH
15718: LD_INT 15
15720: GREATEREQUAL
15721: IFFALSE 15743
// begin m1 := true ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_INT 1
15730: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15731: LD_STRING Destroy
15733: PPUSH
15734: LD_INT 1
15736: PPUSH
15737: CALL_OW 101
// end else
15741: GO 15761
// begin m1 := true ;
15743: LD_ADDR_VAR 0 2
15747: PUSH
15748: LD_INT 1
15750: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15751: LD_STRING Destroy
15753: PPUSH
15754: LD_INT 2
15756: PPUSH
15757: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15761: LD_EXP 13
15765: PPUSH
15766: LD_STRING 11_artifact_captured
15768: PPUSH
15769: CALL_OW 39
// if artifact_get then
15773: LD_EXP 13
15777: IFFALSE 15799
// begin m2 := true ;
15779: LD_ADDR_VAR 0 3
15783: PUSH
15784: LD_INT 1
15786: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15787: LD_STRING Artefact
15789: PPUSH
15790: LD_INT 1
15792: PPUSH
15793: CALL_OW 101
// end else
15797: GO 15810
// AddMedal ( Artefact , - 1 ) ;
15799: LD_STRING Artefact
15801: PPUSH
15802: LD_INT 1
15804: NEG
15805: PPUSH
15806: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15810: LD_VAR 0 2
15814: PUSH
15815: LD_VAR 0 3
15819: AND
15820: PUSH
15821: LD_VAR 0 4
15825: AND
15826: PUSH
15827: LD_OWVAR 67
15831: PUSH
15832: LD_INT 3
15834: EQUAL
15835: AND
15836: IFFALSE 15848
// SetAchievementEX ( ACH_AMER , 11 ) ;
15838: LD_STRING ACH_AMER
15840: PPUSH
15841: LD_INT 11
15843: PPUSH
15844: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15848: LD_VAR 0 2
15852: PUSH
15853: LD_VAR 0 3
15857: AND
15858: PUSH
15859: LD_VAR 0 4
15863: AND
15864: PUSH
15865: LD_EXP 17
15869: PUSH
15870: LD_INT 0
15872: EQUAL
15873: AND
15874: IFFALSE 15890
// begin wait ( 3 ) ;
15876: LD_INT 3
15878: PPUSH
15879: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15883: LD_STRING ACH_GENERAL
15885: PPUSH
15886: CALL_OW 543
// end ; if tick <= 100 100$00 then
15890: LD_OWVAR 1
15894: PUSH
15895: LD_INT 210000
15897: LESSEQUAL
15898: IFFALSE 15914
// begin wait ( 3 ) ;
15900: LD_INT 3
15902: PPUSH
15903: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15907: LD_STRING ACH_ASPEED_11
15909: PPUSH
15910: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15914: LD_STRING MAIN
15916: PPUSH
15917: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15921: LD_ADDR_EXP 19
15925: PUSH
15926: LD_EXP 19
15930: PPUSH
15931: LD_INT 51
15933: PUSH
15934: EMPTY
15935: LIST
15936: PPUSH
15937: CALL_OW 72
15941: ST_TO_ADDR
// tmp := JMM ^ selected ;
15942: LD_ADDR_VAR 0 1
15946: PUSH
15947: LD_EXP 21
15951: PUSH
15952: LD_EXP 19
15956: ADD
15957: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15958: LD_VAR 0 1
15962: PPUSH
15963: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15967: LD_VAR 0 1
15971: PUSH
15972: LD_EXP 21
15976: PUSH
15977: LD_EXP 22
15981: PUSH
15982: LD_EXP 23
15986: PUSH
15987: LD_EXP 24
15991: PUSH
15992: LD_EXP 25
15996: PUSH
15997: LD_EXP 26
16001: PUSH
16002: LD_EXP 27
16006: PUSH
16007: LD_EXP 28
16011: PUSH
16012: LD_EXP 29
16016: PUSH
16017: LD_EXP 31
16021: PUSH
16022: LD_EXP 32
16026: PUSH
16027: LD_EXP 33
16031: PUSH
16032: LD_EXP 34
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: DIFF
16052: PPUSH
16053: LD_STRING 11c_others
16055: PPUSH
16056: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16060: LD_EXP 21
16064: PPUSH
16065: LD_EXP 3
16069: PUSH
16070: LD_STRING JMM
16072: STR
16073: PPUSH
16074: CALL_OW 38
// if Lisa then
16078: LD_EXP 22
16082: IFFALSE 16102
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16084: LD_EXP 22
16088: PPUSH
16089: LD_EXP 3
16093: PUSH
16094: LD_STRING Lisa
16096: STR
16097: PPUSH
16098: CALL_OW 38
// if Donaldson then
16102: LD_EXP 23
16106: IFFALSE 16126
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16108: LD_EXP 23
16112: PPUSH
16113: LD_EXP 3
16117: PUSH
16118: LD_STRING Donaldson
16120: STR
16121: PPUSH
16122: CALL_OW 38
// if Bobby then
16126: LD_EXP 24
16130: IFFALSE 16150
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16132: LD_EXP 24
16136: PPUSH
16137: LD_EXP 3
16141: PUSH
16142: LD_STRING Bobby
16144: STR
16145: PPUSH
16146: CALL_OW 38
// if Cyrus then
16150: LD_EXP 25
16154: IFFALSE 16174
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16156: LD_EXP 25
16160: PPUSH
16161: LD_EXP 3
16165: PUSH
16166: LD_STRING Cyrus
16168: STR
16169: PPUSH
16170: CALL_OW 38
// if Denis then
16174: LD_EXP 26
16178: IFFALSE 16198
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16180: LD_EXP 26
16184: PPUSH
16185: LD_EXP 3
16189: PUSH
16190: LD_STRING Denis
16192: STR
16193: PPUSH
16194: CALL_OW 38
// if Brown then
16198: LD_EXP 27
16202: IFFALSE 16222
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16204: LD_EXP 27
16208: PPUSH
16209: LD_EXP 3
16213: PUSH
16214: LD_STRING Brown
16216: STR
16217: PPUSH
16218: CALL_OW 38
// if Gladstone then
16222: LD_EXP 28
16226: IFFALSE 16246
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16228: LD_EXP 28
16232: PPUSH
16233: LD_EXP 3
16237: PUSH
16238: LD_STRING Gladstone
16240: STR
16241: PPUSH
16242: CALL_OW 38
// if Houten then
16246: LD_EXP 29
16250: IFFALSE 16270
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16252: LD_EXP 29
16256: PPUSH
16257: LD_EXP 3
16261: PUSH
16262: LD_STRING Houten
16264: STR
16265: PPUSH
16266: CALL_OW 38
// if Cornel then
16270: LD_EXP 31
16274: IFFALSE 16294
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16276: LD_EXP 31
16280: PPUSH
16281: LD_EXP 3
16285: PUSH
16286: LD_STRING Cornell
16288: STR
16289: PPUSH
16290: CALL_OW 38
// if Gary then
16294: LD_EXP 32
16298: IFFALSE 16318
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16300: LD_EXP 32
16304: PPUSH
16305: LD_EXP 3
16309: PUSH
16310: LD_STRING Gary
16312: STR
16313: PPUSH
16314: CALL_OW 38
// if Frank then
16318: LD_EXP 33
16322: IFFALSE 16342
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16324: LD_EXP 33
16328: PPUSH
16329: LD_EXP 3
16333: PUSH
16334: LD_STRING Frank
16336: STR
16337: PPUSH
16338: CALL_OW 38
// if Kikuchi then
16342: LD_EXP 34
16346: IFFALSE 16366
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16348: LD_EXP 34
16352: PPUSH
16353: LD_EXP 3
16357: PUSH
16358: LD_STRING Kikuchi
16360: STR
16361: PPUSH
16362: CALL_OW 38
// YouWin ;
16366: CALL_OW 103
// end ;
16370: PPOPN 4
16372: END
// export function CanSayRand ( side ) ; begin
16373: LD_INT 0
16375: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16376: LD_ADDR_VAR 0 2
16380: PUSH
16381: LD_INT 52
16383: PUSH
16384: EMPTY
16385: LIST
16386: PUSH
16387: LD_INT 22
16389: PUSH
16390: LD_VAR 0 1
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PUSH
16399: LD_INT 2
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 1
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 2
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 3
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: LD_INT 25
16434: PUSH
16435: LD_INT 4
16437: PUSH
16438: EMPTY
16439: LIST
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: LIST
16446: LIST
16447: LIST
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: LIST
16453: PPUSH
16454: CALL_OW 69
16458: PUSH
16459: LD_EXP 21
16463: PUSH
16464: LD_EXP 33
16468: PUSH
16469: LD_EXP 22
16473: PUSH
16474: LD_EXP 23
16478: PUSH
16479: LD_EXP 24
16483: PUSH
16484: LD_EXP 25
16488: PUSH
16489: LD_EXP 26
16493: PUSH
16494: LD_EXP 27
16498: PUSH
16499: LD_EXP 28
16503: PUSH
16504: LD_EXP 29
16508: PUSH
16509: LD_EXP 30
16513: PUSH
16514: LD_EXP 31
16518: PUSH
16519: LD_EXP 32
16523: PUSH
16524: LD_EXP 34
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: LIST
16533: LIST
16534: LIST
16535: LIST
16536: LIST
16537: LIST
16538: LIST
16539: LIST
16540: LIST
16541: LIST
16542: LIST
16543: LIST
16544: DIFF
16545: ST_TO_ADDR
// end ;
16546: LD_VAR 0 2
16550: RET
// export function SayRand ( sex , dial ) ; begin
16551: LD_INT 0
16553: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16554: LD_ADDR_VAR 0 3
16558: PUSH
16559: LD_INT 52
16561: PUSH
16562: EMPTY
16563: LIST
16564: PUSH
16565: LD_INT 22
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PUSH
16575: LD_INT 26
16577: PUSH
16578: LD_VAR 0 1
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: PUSH
16587: LD_INT 2
16589: PUSH
16590: LD_INT 25
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PUSH
16600: LD_INT 25
16602: PUSH
16603: LD_INT 2
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: LD_INT 25
16612: PUSH
16613: LD_INT 3
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PUSH
16620: LD_INT 25
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: LIST
16634: LIST
16635: LIST
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: LIST
16641: LIST
16642: PPUSH
16643: CALL_OW 69
16647: PUSH
16648: LD_EXP 21
16652: PUSH
16653: LD_EXP 33
16657: PUSH
16658: LD_EXP 22
16662: PUSH
16663: LD_EXP 23
16667: PUSH
16668: LD_EXP 24
16672: PUSH
16673: LD_EXP 25
16677: PUSH
16678: LD_EXP 26
16682: PUSH
16683: LD_EXP 27
16687: PUSH
16688: LD_EXP 28
16692: PUSH
16693: LD_EXP 29
16697: PUSH
16698: LD_EXP 30
16702: PUSH
16703: LD_EXP 31
16707: PUSH
16708: LD_EXP 32
16712: PUSH
16713: LD_EXP 34
16717: PUSH
16718: EMPTY
16719: LIST
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: DIFF
16734: ST_TO_ADDR
// if not result then
16735: LD_VAR 0 3
16739: NOT
16740: IFFALSE 16744
// exit ;
16742: GO 16772
// result := result [ 1 ] ;
16744: LD_ADDR_VAR 0 3
16748: PUSH
16749: LD_VAR 0 3
16753: PUSH
16754: LD_INT 1
16756: ARRAY
16757: ST_TO_ADDR
// Say ( result , dial ) ;
16758: LD_VAR 0 3
16762: PPUSH
16763: LD_VAR 0 2
16767: PPUSH
16768: CALL_OW 88
// end ;
16772: LD_VAR 0 3
16776: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16777: LD_INT 0
16779: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16780: LD_ADDR_VAR 0 4
16784: PUSH
16785: LD_INT 22
16787: PUSH
16788: LD_INT 1
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 26
16797: PUSH
16798: LD_VAR 0 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 25
16812: PUSH
16813: LD_INT 1
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 25
16822: PUSH
16823: LD_INT 2
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 25
16832: PUSH
16833: LD_INT 3
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: LD_INT 25
16842: PUSH
16843: LD_INT 4
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: PUSH
16867: LD_EXP 21
16871: PUSH
16872: LD_EXP 33
16876: PUSH
16877: LD_EXP 22
16881: PUSH
16882: LD_EXP 23
16886: PUSH
16887: LD_EXP 24
16891: PUSH
16892: LD_EXP 25
16896: PUSH
16897: LD_EXP 26
16901: PUSH
16902: LD_EXP 27
16906: PUSH
16907: LD_EXP 28
16911: PUSH
16912: LD_EXP 29
16916: PUSH
16917: LD_EXP 30
16921: PUSH
16922: LD_EXP 31
16926: PUSH
16927: LD_EXP 32
16931: PUSH
16932: LD_EXP 34
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: PUSH
16953: LD_VAR 0 3
16957: ADD
16958: DIFF
16959: ST_TO_ADDR
// if not result then
16960: LD_VAR 0 4
16964: NOT
16965: IFFALSE 16969
// exit ;
16967: GO 16997
// result := result [ 1 ] ;
16969: LD_ADDR_VAR 0 4
16973: PUSH
16974: LD_VAR 0 4
16978: PUSH
16979: LD_INT 1
16981: ARRAY
16982: ST_TO_ADDR
// Say ( result , dial ) ;
16983: LD_VAR 0 4
16987: PPUSH
16988: LD_VAR 0 2
16992: PPUSH
16993: CALL_OW 88
// end ; end_of_file
16997: LD_VAR 0 4
17001: RET
// export function CustomEvent ( event ) ; begin
17002: LD_INT 0
17004: PPUSH
// end ;
17005: LD_VAR 0 2
17009: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17010: LD_VAR 0 1
17014: PPUSH
17015: CALL_OW 255
17019: PUSH
17020: LD_INT 1
17022: EQUAL
17023: IFFALSE 17033
// artifact_get := true ;
17025: LD_ADDR_EXP 13
17029: PUSH
17030: LD_INT 1
17032: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17033: LD_VAR 0 1
17037: PPUSH
17038: CALL_OW 255
17042: PUSH
17043: LD_INT 2
17045: EQUAL
17046: IFFALSE 17064
// begin artifact_get := false ;
17048: LD_ADDR_EXP 13
17052: PUSH
17053: LD_INT 0
17055: ST_TO_ADDR
// artifact_stolen := true ;
17056: LD_ADDR_EXP 12
17060: PUSH
17061: LD_INT 1
17063: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17064: LD_ADDR_EXP 14
17068: PUSH
17069: LD_INT 1
17071: ST_TO_ADDR
// end ;
17072: PPOPN 2
17074: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17075: LD_ADDR_EXP 14
17079: PUSH
17080: LD_INT 0
17082: ST_TO_ADDR
// end ;
17083: PPOPN 2
17085: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17086: LD_VAR 0 1
17090: PUSH
17091: LD_EXP 21
17095: EQUAL
17096: IFFALSE 17107
// begin YouLost ( JMM ) ;
17098: LD_STRING JMM
17100: PPUSH
17101: CALL_OW 104
// exit ;
17105: GO 17239
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17107: LD_VAR 0 1
17111: PUSH
17112: LD_INT 22
17114: PUSH
17115: LD_INT 1
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: PUSH
17122: LD_INT 21
17124: PUSH
17125: LD_INT 1
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: PUSH
17132: LD_INT 2
17134: PUSH
17135: LD_INT 25
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: PUSH
17145: LD_INT 25
17147: PUSH
17148: LD_INT 2
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PUSH
17155: LD_INT 25
17157: PUSH
17158: LD_INT 3
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PUSH
17165: LD_INT 25
17167: PUSH
17168: LD_INT 4
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PUSH
17175: LD_INT 25
17177: PUSH
17178: LD_INT 5
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: LD_INT 25
17187: PUSH
17188: LD_INT 8
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: PPUSH
17209: CALL_OW 69
17213: IN
17214: IFFALSE 17230
// loses_counter := loses_counter + 1 ;
17216: LD_ADDR_EXP 17
17220: PUSH
17221: LD_EXP 17
17225: PUSH
17226: LD_INT 1
17228: PLUS
17229: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17230: LD_VAR 0 1
17234: PPUSH
17235: CALL 44927 0 1
// end ;
17239: PPOPN 1
17241: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17242: LD_VAR 0 1
17246: PPUSH
17247: LD_VAR 0 2
17251: PPUSH
17252: CALL 47261 0 2
// end ;
17256: PPOPN 2
17258: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 46570 0 1
// end ;
17268: PPOPN 1
17270: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17271: LD_VAR 0 1
17275: PPUSH
17276: LD_VAR 0 2
17280: PPUSH
17281: LD_VAR 0 3
17285: PPUSH
17286: LD_VAR 0 4
17290: PPUSH
17291: LD_VAR 0 5
17295: PPUSH
17296: CALL 44243 0 5
// end ;
17300: PPOPN 5
17302: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17303: LD_VAR 0 1
17307: PPUSH
17308: CALL_OW 248
17312: PUSH
17313: LD_INT 1
17315: EQUAL
17316: IFFALSE 17326
// am_veh_consturcted := true ;
17318: LD_ADDR_EXP 20
17322: PUSH
17323: LD_INT 1
17325: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17326: LD_VAR 0 1
17330: PPUSH
17331: LD_VAR 0 2
17335: PPUSH
17336: CALL 43833 0 2
// end ;
17340: PPOPN 2
17342: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17343: LD_VAR 0 1
17347: PPUSH
17348: CALL_OW 247
17352: PUSH
17353: LD_INT 2
17355: EQUAL
17356: IFFALSE 17360
// exit ;
17358: GO 17377
// if not kamikazed then
17360: LD_EXP 11
17364: NOT
17365: IFFALSE 17377
// kamikazed := unit ;
17367: LD_ADDR_EXP 11
17371: PUSH
17372: LD_VAR 0 1
17376: ST_TO_ADDR
// end ;
17377: PPOPN 1
17379: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17380: LD_INT 0
17382: PPUSH
17383: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17384: LD_VAR 0 1
17388: PPUSH
17389: LD_VAR 0 2
17393: PPUSH
17394: LD_VAR 0 3
17398: PPUSH
17399: LD_VAR 0 4
17403: PPUSH
17404: CALL 43671 0 4
// end ;
17408: PPOPN 6
17410: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17411: LD_VAR 0 1
17415: PPUSH
17416: LD_VAR 0 2
17420: PPUSH
17421: LD_VAR 0 3
17425: PPUSH
17426: CALL 43446 0 3
// end ;
17430: PPOPN 3
17432: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17433: LD_VAR 0 1
17437: PPUSH
17438: LD_VAR 0 2
17442: PPUSH
17443: CALL 44623 0 2
// end ;
17447: PPOPN 2
17449: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: LD_VAR 0 2
17459: PPUSH
17460: CALL 43140 0 2
// end ;
17464: PPOPN 2
17466: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17467: LD_VAR 0 1
17471: PPUSH
17472: LD_VAR 0 2
17476: PPUSH
17477: CALL 43331 0 2
// end ;
17481: PPOPN 2
17483: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17484: LD_VAR 0 1
17488: PPUSH
17489: CALL 46329 0 1
// end ;
17493: PPOPN 1
17495: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17496: LD_VAR 0 1
17500: PPUSH
17501: LD_VAR 0 2
17505: PPUSH
17506: CALL 47522 0 2
// end ;
17510: PPOPN 2
17512: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17513: LD_VAR 0 1
17517: PPUSH
17518: LD_VAR 0 2
17522: PPUSH
17523: LD_VAR 0 3
17527: PPUSH
17528: LD_VAR 0 4
17532: PPUSH
17533: CALL 47738 0 4
// end ;
17537: PPOPN 4
17539: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17540: LD_VAR 0 1
17544: PPUSH
17545: CALL 98365 0 1
// end ; end_of_file
17549: PPOPN 1
17551: END
// every 0 0$1 trigger game do
17552: LD_EXP 2
17556: IFFALSE 17586
17558: GO 17560
17560: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17561: LD_INT 7
17563: PUSH
17564: LD_INT 6
17566: PUSH
17567: LD_INT 4
17569: PUSH
17570: LD_INT 6
17572: PUSH
17573: EMPTY
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: PPUSH
17579: LD_INT 1750
17581: PPUSH
17582: CALL 17587 0 2
17586: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17587: LD_INT 0
17589: PPUSH
17590: PPUSH
17591: PPUSH
// if not areas then
17592: LD_VAR 0 1
17596: NOT
17597: IFFALSE 17601
// exit ;
17599: GO 17731
// repeat wait ( time ) ;
17601: LD_VAR 0 2
17605: PPUSH
17606: CALL_OW 67
// for i in areas do
17610: LD_ADDR_VAR 0 4
17614: PUSH
17615: LD_VAR 0 1
17619: PUSH
17620: FOR_IN
17621: IFFALSE 17690
// begin p := rand ( 1 , 90 ) ;
17623: LD_ADDR_VAR 0 5
17627: PUSH
17628: LD_INT 1
17630: PPUSH
17631: LD_INT 90
17633: PPUSH
17634: CALL_OW 12
17638: ST_TO_ADDR
// if Prob ( p ) then
17639: LD_VAR 0 5
17643: PPUSH
17644: CALL_OW 13
17648: IFFALSE 17688
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17650: LD_INT 2
17652: PPUSH
17653: LD_INT 5
17655: PPUSH
17656: CALL_OW 12
17660: PPUSH
17661: LD_VAR 0 4
17665: PPUSH
17666: LD_INT 1
17668: PPUSH
17669: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17673: LD_INT 735
17675: PPUSH
17676: LD_INT 1295
17678: PPUSH
17679: CALL_OW 12
17683: PPUSH
17684: CALL_OW 67
// end ; end ;
17688: GO 17620
17690: POP
17691: POP
// time := time + 0 0$3 ;
17692: LD_ADDR_VAR 0 2
17696: PUSH
17697: LD_VAR 0 2
17701: PUSH
17702: LD_INT 105
17704: PLUS
17705: ST_TO_ADDR
// if time > 6 6$00 then
17706: LD_VAR 0 2
17710: PUSH
17711: LD_INT 12600
17713: GREATER
17714: IFFALSE 17724
// time := 0 0$40 ;
17716: LD_ADDR_VAR 0 2
17720: PUSH
17721: LD_INT 1400
17723: ST_TO_ADDR
// until not game ;
17724: LD_EXP 2
17728: NOT
17729: IFFALSE 17601
// end ;
17731: LD_VAR 0 3
17735: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 ] [ Difficulty ] do
17736: LD_OWVAR 1
17740: PUSH
17741: LD_INT 84000
17743: PUSH
17744: LD_INT 73500
17746: PUSH
17747: LD_INT 63000
17749: PUSH
17750: EMPTY
17751: LIST
17752: LIST
17753: LIST
17754: PUSH
17755: LD_OWVAR 67
17759: ARRAY
17760: LESS
17761: IFFALSE 17788
17763: GO 17765
17765: DISABLE
// begin enable ;
17766: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17767: LD_INT 1
17769: PPUSH
17770: LD_INT 5
17772: PPUSH
17773: CALL_OW 12
17777: PPUSH
17778: LD_INT 7
17780: PPUSH
17781: LD_INT 1
17783: PPUSH
17784: CALL_OW 55
// end ; end_of_file
17788: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17789: LD_INT 0
17791: PPUSH
17792: PPUSH
// skirmish := false ;
17793: LD_ADDR_EXP 48
17797: PUSH
17798: LD_INT 0
17800: ST_TO_ADDR
// debug_mc := false ;
17801: LD_ADDR_EXP 49
17805: PUSH
17806: LD_INT 0
17808: ST_TO_ADDR
// mc_bases := [ ] ;
17809: LD_ADDR_EXP 50
17813: PUSH
17814: EMPTY
17815: ST_TO_ADDR
// mc_sides := [ ] ;
17816: LD_ADDR_EXP 76
17820: PUSH
17821: EMPTY
17822: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17823: LD_ADDR_EXP 51
17827: PUSH
17828: EMPTY
17829: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17830: LD_ADDR_EXP 52
17834: PUSH
17835: EMPTY
17836: ST_TO_ADDR
// mc_need_heal := [ ] ;
17837: LD_ADDR_EXP 53
17841: PUSH
17842: EMPTY
17843: ST_TO_ADDR
// mc_healers := [ ] ;
17844: LD_ADDR_EXP 54
17848: PUSH
17849: EMPTY
17850: ST_TO_ADDR
// mc_build_list := [ ] ;
17851: LD_ADDR_EXP 55
17855: PUSH
17856: EMPTY
17857: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17858: LD_ADDR_EXP 82
17862: PUSH
17863: EMPTY
17864: ST_TO_ADDR
// mc_builders := [ ] ;
17865: LD_ADDR_EXP 56
17869: PUSH
17870: EMPTY
17871: ST_TO_ADDR
// mc_construct_list := [ ] ;
17872: LD_ADDR_EXP 57
17876: PUSH
17877: EMPTY
17878: ST_TO_ADDR
// mc_turret_list := [ ] ;
17879: LD_ADDR_EXP 58
17883: PUSH
17884: EMPTY
17885: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17886: LD_ADDR_EXP 59
17890: PUSH
17891: EMPTY
17892: ST_TO_ADDR
// mc_miners := [ ] ;
17893: LD_ADDR_EXP 64
17897: PUSH
17898: EMPTY
17899: ST_TO_ADDR
// mc_mines := [ ] ;
17900: LD_ADDR_EXP 63
17904: PUSH
17905: EMPTY
17906: ST_TO_ADDR
// mc_minefields := [ ] ;
17907: LD_ADDR_EXP 65
17911: PUSH
17912: EMPTY
17913: ST_TO_ADDR
// mc_crates := [ ] ;
17914: LD_ADDR_EXP 66
17918: PUSH
17919: EMPTY
17920: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17921: LD_ADDR_EXP 67
17925: PUSH
17926: EMPTY
17927: ST_TO_ADDR
// mc_crates_area := [ ] ;
17928: LD_ADDR_EXP 68
17932: PUSH
17933: EMPTY
17934: ST_TO_ADDR
// mc_vehicles := [ ] ;
17935: LD_ADDR_EXP 69
17939: PUSH
17940: EMPTY
17941: ST_TO_ADDR
// mc_attack := [ ] ;
17942: LD_ADDR_EXP 70
17946: PUSH
17947: EMPTY
17948: ST_TO_ADDR
// mc_produce := [ ] ;
17949: LD_ADDR_EXP 71
17953: PUSH
17954: EMPTY
17955: ST_TO_ADDR
// mc_defender := [ ] ;
17956: LD_ADDR_EXP 72
17960: PUSH
17961: EMPTY
17962: ST_TO_ADDR
// mc_parking := [ ] ;
17963: LD_ADDR_EXP 74
17967: PUSH
17968: EMPTY
17969: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17970: LD_ADDR_EXP 60
17974: PUSH
17975: EMPTY
17976: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17977: LD_ADDR_EXP 62
17981: PUSH
17982: EMPTY
17983: ST_TO_ADDR
// mc_scan := [ ] ;
17984: LD_ADDR_EXP 73
17988: PUSH
17989: EMPTY
17990: ST_TO_ADDR
// mc_scan_area := [ ] ;
17991: LD_ADDR_EXP 75
17995: PUSH
17996: EMPTY
17997: ST_TO_ADDR
// mc_tech := [ ] ;
17998: LD_ADDR_EXP 77
18002: PUSH
18003: EMPTY
18004: ST_TO_ADDR
// mc_class := [ ] ;
18005: LD_ADDR_EXP 91
18009: PUSH
18010: EMPTY
18011: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18012: LD_ADDR_EXP 92
18016: PUSH
18017: EMPTY
18018: ST_TO_ADDR
// end ;
18019: LD_VAR 0 1
18023: RET
// export function MC_Kill ( base ) ; begin
18024: LD_INT 0
18026: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18027: LD_ADDR_EXP 50
18031: PUSH
18032: LD_EXP 50
18036: PPUSH
18037: LD_VAR 0 1
18041: PPUSH
18042: EMPTY
18043: PPUSH
18044: CALL_OW 1
18048: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18049: LD_ADDR_EXP 51
18053: PUSH
18054: LD_EXP 51
18058: PPUSH
18059: LD_VAR 0 1
18063: PPUSH
18064: EMPTY
18065: PPUSH
18066: CALL_OW 1
18070: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18071: LD_ADDR_EXP 52
18075: PUSH
18076: LD_EXP 52
18080: PPUSH
18081: LD_VAR 0 1
18085: PPUSH
18086: EMPTY
18087: PPUSH
18088: CALL_OW 1
18092: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18093: LD_ADDR_EXP 53
18097: PUSH
18098: LD_EXP 53
18102: PPUSH
18103: LD_VAR 0 1
18107: PPUSH
18108: EMPTY
18109: PPUSH
18110: CALL_OW 1
18114: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18115: LD_ADDR_EXP 54
18119: PUSH
18120: LD_EXP 54
18124: PPUSH
18125: LD_VAR 0 1
18129: PPUSH
18130: EMPTY
18131: PPUSH
18132: CALL_OW 1
18136: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18137: LD_ADDR_EXP 55
18141: PUSH
18142: LD_EXP 55
18146: PPUSH
18147: LD_VAR 0 1
18151: PPUSH
18152: EMPTY
18153: PPUSH
18154: CALL_OW 1
18158: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18159: LD_ADDR_EXP 56
18163: PUSH
18164: LD_EXP 56
18168: PPUSH
18169: LD_VAR 0 1
18173: PPUSH
18174: EMPTY
18175: PPUSH
18176: CALL_OW 1
18180: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18181: LD_ADDR_EXP 57
18185: PUSH
18186: LD_EXP 57
18190: PPUSH
18191: LD_VAR 0 1
18195: PPUSH
18196: EMPTY
18197: PPUSH
18198: CALL_OW 1
18202: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18203: LD_ADDR_EXP 58
18207: PUSH
18208: LD_EXP 58
18212: PPUSH
18213: LD_VAR 0 1
18217: PPUSH
18218: EMPTY
18219: PPUSH
18220: CALL_OW 1
18224: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18225: LD_ADDR_EXP 59
18229: PUSH
18230: LD_EXP 59
18234: PPUSH
18235: LD_VAR 0 1
18239: PPUSH
18240: EMPTY
18241: PPUSH
18242: CALL_OW 1
18246: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18247: LD_ADDR_EXP 60
18251: PUSH
18252: LD_EXP 60
18256: PPUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: EMPTY
18263: PPUSH
18264: CALL_OW 1
18268: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18269: LD_ADDR_EXP 61
18273: PUSH
18274: LD_EXP 61
18278: PPUSH
18279: LD_VAR 0 1
18283: PPUSH
18284: LD_INT 0
18286: PPUSH
18287: CALL_OW 1
18291: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18292: LD_ADDR_EXP 62
18296: PUSH
18297: LD_EXP 62
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: EMPTY
18308: PPUSH
18309: CALL_OW 1
18313: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18314: LD_ADDR_EXP 63
18318: PUSH
18319: LD_EXP 63
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: EMPTY
18330: PPUSH
18331: CALL_OW 1
18335: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18336: LD_ADDR_EXP 64
18340: PUSH
18341: LD_EXP 64
18345: PPUSH
18346: LD_VAR 0 1
18350: PPUSH
18351: EMPTY
18352: PPUSH
18353: CALL_OW 1
18357: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18358: LD_ADDR_EXP 65
18362: PUSH
18363: LD_EXP 65
18367: PPUSH
18368: LD_VAR 0 1
18372: PPUSH
18373: EMPTY
18374: PPUSH
18375: CALL_OW 1
18379: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18380: LD_ADDR_EXP 66
18384: PUSH
18385: LD_EXP 66
18389: PPUSH
18390: LD_VAR 0 1
18394: PPUSH
18395: EMPTY
18396: PPUSH
18397: CALL_OW 1
18401: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18402: LD_ADDR_EXP 67
18406: PUSH
18407: LD_EXP 67
18411: PPUSH
18412: LD_VAR 0 1
18416: PPUSH
18417: EMPTY
18418: PPUSH
18419: CALL_OW 1
18423: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18424: LD_ADDR_EXP 68
18428: PUSH
18429: LD_EXP 68
18433: PPUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: EMPTY
18440: PPUSH
18441: CALL_OW 1
18445: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18446: LD_ADDR_EXP 69
18450: PUSH
18451: LD_EXP 69
18455: PPUSH
18456: LD_VAR 0 1
18460: PPUSH
18461: EMPTY
18462: PPUSH
18463: CALL_OW 1
18467: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18468: LD_ADDR_EXP 70
18472: PUSH
18473: LD_EXP 70
18477: PPUSH
18478: LD_VAR 0 1
18482: PPUSH
18483: EMPTY
18484: PPUSH
18485: CALL_OW 1
18489: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18490: LD_ADDR_EXP 71
18494: PUSH
18495: LD_EXP 71
18499: PPUSH
18500: LD_VAR 0 1
18504: PPUSH
18505: EMPTY
18506: PPUSH
18507: CALL_OW 1
18511: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18512: LD_ADDR_EXP 72
18516: PUSH
18517: LD_EXP 72
18521: PPUSH
18522: LD_VAR 0 1
18526: PPUSH
18527: EMPTY
18528: PPUSH
18529: CALL_OW 1
18533: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18534: LD_ADDR_EXP 73
18538: PUSH
18539: LD_EXP 73
18543: PPUSH
18544: LD_VAR 0 1
18548: PPUSH
18549: EMPTY
18550: PPUSH
18551: CALL_OW 1
18555: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18556: LD_ADDR_EXP 74
18560: PUSH
18561: LD_EXP 74
18565: PPUSH
18566: LD_VAR 0 1
18570: PPUSH
18571: EMPTY
18572: PPUSH
18573: CALL_OW 1
18577: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18578: LD_ADDR_EXP 75
18582: PUSH
18583: LD_EXP 75
18587: PPUSH
18588: LD_VAR 0 1
18592: PPUSH
18593: EMPTY
18594: PPUSH
18595: CALL_OW 1
18599: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18600: LD_ADDR_EXP 77
18604: PUSH
18605: LD_EXP 77
18609: PPUSH
18610: LD_VAR 0 1
18614: PPUSH
18615: EMPTY
18616: PPUSH
18617: CALL_OW 1
18621: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18622: LD_ADDR_EXP 79
18626: PUSH
18627: LD_EXP 79
18631: PPUSH
18632: LD_VAR 0 1
18636: PPUSH
18637: EMPTY
18638: PPUSH
18639: CALL_OW 1
18643: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18644: LD_ADDR_EXP 80
18648: PUSH
18649: LD_EXP 80
18653: PPUSH
18654: LD_VAR 0 1
18658: PPUSH
18659: EMPTY
18660: PPUSH
18661: CALL_OW 1
18665: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18666: LD_ADDR_EXP 81
18670: PUSH
18671: LD_EXP 81
18675: PPUSH
18676: LD_VAR 0 1
18680: PPUSH
18681: EMPTY
18682: PPUSH
18683: CALL_OW 1
18687: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18688: LD_ADDR_EXP 82
18692: PUSH
18693: LD_EXP 82
18697: PPUSH
18698: LD_VAR 0 1
18702: PPUSH
18703: EMPTY
18704: PPUSH
18705: CALL_OW 1
18709: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18710: LD_ADDR_EXP 83
18714: PUSH
18715: LD_EXP 83
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: EMPTY
18726: PPUSH
18727: CALL_OW 1
18731: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18732: LD_ADDR_EXP 84
18736: PUSH
18737: LD_EXP 84
18741: PPUSH
18742: LD_VAR 0 1
18746: PPUSH
18747: EMPTY
18748: PPUSH
18749: CALL_OW 1
18753: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18754: LD_ADDR_EXP 85
18758: PUSH
18759: LD_EXP 85
18763: PPUSH
18764: LD_VAR 0 1
18768: PPUSH
18769: EMPTY
18770: PPUSH
18771: CALL_OW 1
18775: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18776: LD_ADDR_EXP 86
18780: PUSH
18781: LD_EXP 86
18785: PPUSH
18786: LD_VAR 0 1
18790: PPUSH
18791: EMPTY
18792: PPUSH
18793: CALL_OW 1
18797: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18798: LD_ADDR_EXP 87
18802: PUSH
18803: LD_EXP 87
18807: PPUSH
18808: LD_VAR 0 1
18812: PPUSH
18813: EMPTY
18814: PPUSH
18815: CALL_OW 1
18819: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18820: LD_ADDR_EXP 88
18824: PUSH
18825: LD_EXP 88
18829: PPUSH
18830: LD_VAR 0 1
18834: PPUSH
18835: EMPTY
18836: PPUSH
18837: CALL_OW 1
18841: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18842: LD_ADDR_EXP 89
18846: PUSH
18847: LD_EXP 89
18851: PPUSH
18852: LD_VAR 0 1
18856: PPUSH
18857: EMPTY
18858: PPUSH
18859: CALL_OW 1
18863: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18864: LD_ADDR_EXP 90
18868: PUSH
18869: LD_EXP 90
18873: PPUSH
18874: LD_VAR 0 1
18878: PPUSH
18879: EMPTY
18880: PPUSH
18881: CALL_OW 1
18885: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18886: LD_ADDR_EXP 91
18890: PUSH
18891: LD_EXP 91
18895: PPUSH
18896: LD_VAR 0 1
18900: PPUSH
18901: EMPTY
18902: PPUSH
18903: CALL_OW 1
18907: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18908: LD_ADDR_EXP 92
18912: PUSH
18913: LD_EXP 92
18917: PPUSH
18918: LD_VAR 0 1
18922: PPUSH
18923: LD_INT 0
18925: PPUSH
18926: CALL_OW 1
18930: ST_TO_ADDR
// end ;
18931: LD_VAR 0 2
18935: RET
// export function MC_Add ( side , units ) ; var base ; begin
18936: LD_INT 0
18938: PPUSH
18939: PPUSH
// base := mc_bases + 1 ;
18940: LD_ADDR_VAR 0 4
18944: PUSH
18945: LD_EXP 50
18949: PUSH
18950: LD_INT 1
18952: PLUS
18953: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18954: LD_ADDR_EXP 76
18958: PUSH
18959: LD_EXP 76
18963: PPUSH
18964: LD_VAR 0 4
18968: PPUSH
18969: LD_VAR 0 1
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18979: LD_ADDR_EXP 50
18983: PUSH
18984: LD_EXP 50
18988: PPUSH
18989: LD_VAR 0 4
18993: PPUSH
18994: LD_VAR 0 2
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19004: LD_ADDR_EXP 51
19008: PUSH
19009: LD_EXP 51
19013: PPUSH
19014: LD_VAR 0 4
19018: PPUSH
19019: EMPTY
19020: PPUSH
19021: CALL_OW 1
19025: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19026: LD_ADDR_EXP 52
19030: PUSH
19031: LD_EXP 52
19035: PPUSH
19036: LD_VAR 0 4
19040: PPUSH
19041: EMPTY
19042: PPUSH
19043: CALL_OW 1
19047: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19048: LD_ADDR_EXP 53
19052: PUSH
19053: LD_EXP 53
19057: PPUSH
19058: LD_VAR 0 4
19062: PPUSH
19063: EMPTY
19064: PPUSH
19065: CALL_OW 1
19069: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19070: LD_ADDR_EXP 54
19074: PUSH
19075: LD_EXP 54
19079: PPUSH
19080: LD_VAR 0 4
19084: PPUSH
19085: EMPTY
19086: PPUSH
19087: CALL_OW 1
19091: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19092: LD_ADDR_EXP 55
19096: PUSH
19097: LD_EXP 55
19101: PPUSH
19102: LD_VAR 0 4
19106: PPUSH
19107: EMPTY
19108: PPUSH
19109: CALL_OW 1
19113: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19114: LD_ADDR_EXP 56
19118: PUSH
19119: LD_EXP 56
19123: PPUSH
19124: LD_VAR 0 4
19128: PPUSH
19129: EMPTY
19130: PPUSH
19131: CALL_OW 1
19135: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19136: LD_ADDR_EXP 57
19140: PUSH
19141: LD_EXP 57
19145: PPUSH
19146: LD_VAR 0 4
19150: PPUSH
19151: EMPTY
19152: PPUSH
19153: CALL_OW 1
19157: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19158: LD_ADDR_EXP 58
19162: PUSH
19163: LD_EXP 58
19167: PPUSH
19168: LD_VAR 0 4
19172: PPUSH
19173: EMPTY
19174: PPUSH
19175: CALL_OW 1
19179: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19180: LD_ADDR_EXP 59
19184: PUSH
19185: LD_EXP 59
19189: PPUSH
19190: LD_VAR 0 4
19194: PPUSH
19195: EMPTY
19196: PPUSH
19197: CALL_OW 1
19201: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19202: LD_ADDR_EXP 60
19206: PUSH
19207: LD_EXP 60
19211: PPUSH
19212: LD_VAR 0 4
19216: PPUSH
19217: EMPTY
19218: PPUSH
19219: CALL_OW 1
19223: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19224: LD_ADDR_EXP 61
19228: PUSH
19229: LD_EXP 61
19233: PPUSH
19234: LD_VAR 0 4
19238: PPUSH
19239: LD_INT 0
19241: PPUSH
19242: CALL_OW 1
19246: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19247: LD_ADDR_EXP 62
19251: PUSH
19252: LD_EXP 62
19256: PPUSH
19257: LD_VAR 0 4
19261: PPUSH
19262: EMPTY
19263: PPUSH
19264: CALL_OW 1
19268: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19269: LD_ADDR_EXP 63
19273: PUSH
19274: LD_EXP 63
19278: PPUSH
19279: LD_VAR 0 4
19283: PPUSH
19284: EMPTY
19285: PPUSH
19286: CALL_OW 1
19290: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19291: LD_ADDR_EXP 64
19295: PUSH
19296: LD_EXP 64
19300: PPUSH
19301: LD_VAR 0 4
19305: PPUSH
19306: EMPTY
19307: PPUSH
19308: CALL_OW 1
19312: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19313: LD_ADDR_EXP 65
19317: PUSH
19318: LD_EXP 65
19322: PPUSH
19323: LD_VAR 0 4
19327: PPUSH
19328: EMPTY
19329: PPUSH
19330: CALL_OW 1
19334: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19335: LD_ADDR_EXP 66
19339: PUSH
19340: LD_EXP 66
19344: PPUSH
19345: LD_VAR 0 4
19349: PPUSH
19350: EMPTY
19351: PPUSH
19352: CALL_OW 1
19356: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19357: LD_ADDR_EXP 67
19361: PUSH
19362: LD_EXP 67
19366: PPUSH
19367: LD_VAR 0 4
19371: PPUSH
19372: EMPTY
19373: PPUSH
19374: CALL_OW 1
19378: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19379: LD_ADDR_EXP 68
19383: PUSH
19384: LD_EXP 68
19388: PPUSH
19389: LD_VAR 0 4
19393: PPUSH
19394: EMPTY
19395: PPUSH
19396: CALL_OW 1
19400: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19401: LD_ADDR_EXP 69
19405: PUSH
19406: LD_EXP 69
19410: PPUSH
19411: LD_VAR 0 4
19415: PPUSH
19416: EMPTY
19417: PPUSH
19418: CALL_OW 1
19422: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19423: LD_ADDR_EXP 70
19427: PUSH
19428: LD_EXP 70
19432: PPUSH
19433: LD_VAR 0 4
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL_OW 1
19444: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19445: LD_ADDR_EXP 71
19449: PUSH
19450: LD_EXP 71
19454: PPUSH
19455: LD_VAR 0 4
19459: PPUSH
19460: EMPTY
19461: PPUSH
19462: CALL_OW 1
19466: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19467: LD_ADDR_EXP 72
19471: PUSH
19472: LD_EXP 72
19476: PPUSH
19477: LD_VAR 0 4
19481: PPUSH
19482: EMPTY
19483: PPUSH
19484: CALL_OW 1
19488: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19489: LD_ADDR_EXP 73
19493: PUSH
19494: LD_EXP 73
19498: PPUSH
19499: LD_VAR 0 4
19503: PPUSH
19504: EMPTY
19505: PPUSH
19506: CALL_OW 1
19510: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19511: LD_ADDR_EXP 74
19515: PUSH
19516: LD_EXP 74
19520: PPUSH
19521: LD_VAR 0 4
19525: PPUSH
19526: EMPTY
19527: PPUSH
19528: CALL_OW 1
19532: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19533: LD_ADDR_EXP 75
19537: PUSH
19538: LD_EXP 75
19542: PPUSH
19543: LD_VAR 0 4
19547: PPUSH
19548: EMPTY
19549: PPUSH
19550: CALL_OW 1
19554: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19555: LD_ADDR_EXP 77
19559: PUSH
19560: LD_EXP 77
19564: PPUSH
19565: LD_VAR 0 4
19569: PPUSH
19570: EMPTY
19571: PPUSH
19572: CALL_OW 1
19576: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19577: LD_ADDR_EXP 79
19581: PUSH
19582: LD_EXP 79
19586: PPUSH
19587: LD_VAR 0 4
19591: PPUSH
19592: EMPTY
19593: PPUSH
19594: CALL_OW 1
19598: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19599: LD_ADDR_EXP 80
19603: PUSH
19604: LD_EXP 80
19608: PPUSH
19609: LD_VAR 0 4
19613: PPUSH
19614: EMPTY
19615: PPUSH
19616: CALL_OW 1
19620: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19621: LD_ADDR_EXP 81
19625: PUSH
19626: LD_EXP 81
19630: PPUSH
19631: LD_VAR 0 4
19635: PPUSH
19636: EMPTY
19637: PPUSH
19638: CALL_OW 1
19642: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19643: LD_ADDR_EXP 82
19647: PUSH
19648: LD_EXP 82
19652: PPUSH
19653: LD_VAR 0 4
19657: PPUSH
19658: EMPTY
19659: PPUSH
19660: CALL_OW 1
19664: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19665: LD_ADDR_EXP 83
19669: PUSH
19670: LD_EXP 83
19674: PPUSH
19675: LD_VAR 0 4
19679: PPUSH
19680: EMPTY
19681: PPUSH
19682: CALL_OW 1
19686: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19687: LD_ADDR_EXP 84
19691: PUSH
19692: LD_EXP 84
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: EMPTY
19703: PPUSH
19704: CALL_OW 1
19708: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19709: LD_ADDR_EXP 85
19713: PUSH
19714: LD_EXP 85
19718: PPUSH
19719: LD_VAR 0 4
19723: PPUSH
19724: EMPTY
19725: PPUSH
19726: CALL_OW 1
19730: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19731: LD_ADDR_EXP 86
19735: PUSH
19736: LD_EXP 86
19740: PPUSH
19741: LD_VAR 0 4
19745: PPUSH
19746: EMPTY
19747: PPUSH
19748: CALL_OW 1
19752: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19753: LD_ADDR_EXP 87
19757: PUSH
19758: LD_EXP 87
19762: PPUSH
19763: LD_VAR 0 4
19767: PPUSH
19768: EMPTY
19769: PPUSH
19770: CALL_OW 1
19774: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19775: LD_ADDR_EXP 88
19779: PUSH
19780: LD_EXP 88
19784: PPUSH
19785: LD_VAR 0 4
19789: PPUSH
19790: EMPTY
19791: PPUSH
19792: CALL_OW 1
19796: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19797: LD_ADDR_EXP 89
19801: PUSH
19802: LD_EXP 89
19806: PPUSH
19807: LD_VAR 0 4
19811: PPUSH
19812: EMPTY
19813: PPUSH
19814: CALL_OW 1
19818: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19819: LD_ADDR_EXP 90
19823: PUSH
19824: LD_EXP 90
19828: PPUSH
19829: LD_VAR 0 4
19833: PPUSH
19834: EMPTY
19835: PPUSH
19836: CALL_OW 1
19840: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19841: LD_ADDR_EXP 91
19845: PUSH
19846: LD_EXP 91
19850: PPUSH
19851: LD_VAR 0 4
19855: PPUSH
19856: EMPTY
19857: PPUSH
19858: CALL_OW 1
19862: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19863: LD_ADDR_EXP 92
19867: PUSH
19868: LD_EXP 92
19872: PPUSH
19873: LD_VAR 0 4
19877: PPUSH
19878: LD_INT 0
19880: PPUSH
19881: CALL_OW 1
19885: ST_TO_ADDR
// result := base ;
19886: LD_ADDR_VAR 0 3
19890: PUSH
19891: LD_VAR 0 4
19895: ST_TO_ADDR
// end ;
19896: LD_VAR 0 3
19900: RET
// export function MC_Start ( ) ; var i ; begin
19901: LD_INT 0
19903: PPUSH
19904: PPUSH
// for i = 1 to mc_bases do
19905: LD_ADDR_VAR 0 2
19909: PUSH
19910: DOUBLE
19911: LD_INT 1
19913: DEC
19914: ST_TO_ADDR
19915: LD_EXP 50
19919: PUSH
19920: FOR_TO
19921: IFFALSE 20998
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19923: LD_ADDR_EXP 50
19927: PUSH
19928: LD_EXP 50
19932: PPUSH
19933: LD_VAR 0 2
19937: PPUSH
19938: LD_EXP 50
19942: PUSH
19943: LD_VAR 0 2
19947: ARRAY
19948: PUSH
19949: LD_INT 0
19951: DIFF
19952: PPUSH
19953: CALL_OW 1
19957: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19958: LD_ADDR_EXP 51
19962: PUSH
19963: LD_EXP 51
19967: PPUSH
19968: LD_VAR 0 2
19972: PPUSH
19973: EMPTY
19974: PPUSH
19975: CALL_OW 1
19979: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19980: LD_ADDR_EXP 52
19984: PUSH
19985: LD_EXP 52
19989: PPUSH
19990: LD_VAR 0 2
19994: PPUSH
19995: EMPTY
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20002: LD_ADDR_EXP 53
20006: PUSH
20007: LD_EXP 53
20011: PPUSH
20012: LD_VAR 0 2
20016: PPUSH
20017: EMPTY
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20024: LD_ADDR_EXP 54
20028: PUSH
20029: LD_EXP 54
20033: PPUSH
20034: LD_VAR 0 2
20038: PPUSH
20039: EMPTY
20040: PUSH
20041: EMPTY
20042: PUSH
20043: EMPTY
20044: LIST
20045: LIST
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20052: LD_ADDR_EXP 55
20056: PUSH
20057: LD_EXP 55
20061: PPUSH
20062: LD_VAR 0 2
20066: PPUSH
20067: EMPTY
20068: PPUSH
20069: CALL_OW 1
20073: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20074: LD_ADDR_EXP 82
20078: PUSH
20079: LD_EXP 82
20083: PPUSH
20084: LD_VAR 0 2
20088: PPUSH
20089: EMPTY
20090: PPUSH
20091: CALL_OW 1
20095: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20096: LD_ADDR_EXP 56
20100: PUSH
20101: LD_EXP 56
20105: PPUSH
20106: LD_VAR 0 2
20110: PPUSH
20111: EMPTY
20112: PPUSH
20113: CALL_OW 1
20117: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20118: LD_ADDR_EXP 57
20122: PUSH
20123: LD_EXP 57
20127: PPUSH
20128: LD_VAR 0 2
20132: PPUSH
20133: EMPTY
20134: PPUSH
20135: CALL_OW 1
20139: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20140: LD_ADDR_EXP 58
20144: PUSH
20145: LD_EXP 58
20149: PPUSH
20150: LD_VAR 0 2
20154: PPUSH
20155: LD_EXP 50
20159: PUSH
20160: LD_VAR 0 2
20164: ARRAY
20165: PPUSH
20166: LD_INT 2
20168: PUSH
20169: LD_INT 30
20171: PUSH
20172: LD_INT 32
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: PUSH
20179: LD_INT 30
20181: PUSH
20182: LD_INT 33
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: LIST
20193: PPUSH
20194: CALL_OW 72
20198: PPUSH
20199: CALL_OW 1
20203: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20204: LD_ADDR_EXP 59
20208: PUSH
20209: LD_EXP 59
20213: PPUSH
20214: LD_VAR 0 2
20218: PPUSH
20219: LD_EXP 50
20223: PUSH
20224: LD_VAR 0 2
20228: ARRAY
20229: PPUSH
20230: LD_INT 2
20232: PUSH
20233: LD_INT 30
20235: PUSH
20236: LD_INT 32
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PUSH
20243: LD_INT 30
20245: PUSH
20246: LD_INT 31
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: LIST
20257: PUSH
20258: LD_INT 58
20260: PUSH
20261: EMPTY
20262: LIST
20263: PUSH
20264: EMPTY
20265: LIST
20266: LIST
20267: PPUSH
20268: CALL_OW 72
20272: PPUSH
20273: CALL_OW 1
20277: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20278: LD_ADDR_EXP 60
20282: PUSH
20283: LD_EXP 60
20287: PPUSH
20288: LD_VAR 0 2
20292: PPUSH
20293: EMPTY
20294: PPUSH
20295: CALL_OW 1
20299: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20300: LD_ADDR_EXP 64
20304: PUSH
20305: LD_EXP 64
20309: PPUSH
20310: LD_VAR 0 2
20314: PPUSH
20315: EMPTY
20316: PPUSH
20317: CALL_OW 1
20321: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20322: LD_ADDR_EXP 63
20326: PUSH
20327: LD_EXP 63
20331: PPUSH
20332: LD_VAR 0 2
20336: PPUSH
20337: EMPTY
20338: PPUSH
20339: CALL_OW 1
20343: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20344: LD_ADDR_EXP 65
20348: PUSH
20349: LD_EXP 65
20353: PPUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: EMPTY
20360: PPUSH
20361: CALL_OW 1
20365: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20366: LD_ADDR_EXP 66
20370: PUSH
20371: LD_EXP 66
20375: PPUSH
20376: LD_VAR 0 2
20380: PPUSH
20381: EMPTY
20382: PPUSH
20383: CALL_OW 1
20387: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20388: LD_ADDR_EXP 67
20392: PUSH
20393: LD_EXP 67
20397: PPUSH
20398: LD_VAR 0 2
20402: PPUSH
20403: EMPTY
20404: PPUSH
20405: CALL_OW 1
20409: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20410: LD_ADDR_EXP 68
20414: PUSH
20415: LD_EXP 68
20419: PPUSH
20420: LD_VAR 0 2
20424: PPUSH
20425: EMPTY
20426: PPUSH
20427: CALL_OW 1
20431: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20432: LD_ADDR_EXP 69
20436: PUSH
20437: LD_EXP 69
20441: PPUSH
20442: LD_VAR 0 2
20446: PPUSH
20447: EMPTY
20448: PPUSH
20449: CALL_OW 1
20453: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20454: LD_ADDR_EXP 70
20458: PUSH
20459: LD_EXP 70
20463: PPUSH
20464: LD_VAR 0 2
20468: PPUSH
20469: EMPTY
20470: PPUSH
20471: CALL_OW 1
20475: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20476: LD_ADDR_EXP 71
20480: PUSH
20481: LD_EXP 71
20485: PPUSH
20486: LD_VAR 0 2
20490: PPUSH
20491: EMPTY
20492: PPUSH
20493: CALL_OW 1
20497: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20498: LD_ADDR_EXP 72
20502: PUSH
20503: LD_EXP 72
20507: PPUSH
20508: LD_VAR 0 2
20512: PPUSH
20513: EMPTY
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20520: LD_ADDR_EXP 61
20524: PUSH
20525: LD_EXP 61
20529: PPUSH
20530: LD_VAR 0 2
20534: PPUSH
20535: LD_INT 0
20537: PPUSH
20538: CALL_OW 1
20542: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20543: LD_ADDR_EXP 74
20547: PUSH
20548: LD_EXP 74
20552: PPUSH
20553: LD_VAR 0 2
20557: PPUSH
20558: LD_INT 0
20560: PPUSH
20561: CALL_OW 1
20565: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20566: LD_ADDR_EXP 62
20570: PUSH
20571: LD_EXP 62
20575: PPUSH
20576: LD_VAR 0 2
20580: PPUSH
20581: EMPTY
20582: PPUSH
20583: CALL_OW 1
20587: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20588: LD_ADDR_EXP 73
20592: PUSH
20593: LD_EXP 73
20597: PPUSH
20598: LD_VAR 0 2
20602: PPUSH
20603: LD_INT 0
20605: PPUSH
20606: CALL_OW 1
20610: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20611: LD_ADDR_EXP 75
20615: PUSH
20616: LD_EXP 75
20620: PPUSH
20621: LD_VAR 0 2
20625: PPUSH
20626: EMPTY
20627: PPUSH
20628: CALL_OW 1
20632: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20633: LD_ADDR_EXP 78
20637: PUSH
20638: LD_EXP 78
20642: PPUSH
20643: LD_VAR 0 2
20647: PPUSH
20648: LD_INT 0
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20656: LD_ADDR_EXP 79
20660: PUSH
20661: LD_EXP 79
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: EMPTY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20678: LD_ADDR_EXP 80
20682: PUSH
20683: LD_EXP 80
20687: PPUSH
20688: LD_VAR 0 2
20692: PPUSH
20693: EMPTY
20694: PPUSH
20695: CALL_OW 1
20699: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20700: LD_ADDR_EXP 81
20704: PUSH
20705: LD_EXP 81
20709: PPUSH
20710: LD_VAR 0 2
20714: PPUSH
20715: EMPTY
20716: PPUSH
20717: CALL_OW 1
20721: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20722: LD_ADDR_EXP 83
20726: PUSH
20727: LD_EXP 83
20731: PPUSH
20732: LD_VAR 0 2
20736: PPUSH
20737: LD_EXP 50
20741: PUSH
20742: LD_VAR 0 2
20746: ARRAY
20747: PPUSH
20748: LD_INT 2
20750: PUSH
20751: LD_INT 30
20753: PUSH
20754: LD_INT 6
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: PUSH
20761: LD_INT 30
20763: PUSH
20764: LD_INT 7
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: PUSH
20771: LD_INT 30
20773: PUSH
20774: LD_INT 8
20776: PUSH
20777: EMPTY
20778: LIST
20779: LIST
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: PPUSH
20787: CALL_OW 72
20791: PPUSH
20792: CALL_OW 1
20796: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20797: LD_ADDR_EXP 84
20801: PUSH
20802: LD_EXP 84
20806: PPUSH
20807: LD_VAR 0 2
20811: PPUSH
20812: EMPTY
20813: PPUSH
20814: CALL_OW 1
20818: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20819: LD_ADDR_EXP 85
20823: PUSH
20824: LD_EXP 85
20828: PPUSH
20829: LD_VAR 0 2
20833: PPUSH
20834: EMPTY
20835: PPUSH
20836: CALL_OW 1
20840: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20841: LD_ADDR_EXP 86
20845: PUSH
20846: LD_EXP 86
20850: PPUSH
20851: LD_VAR 0 2
20855: PPUSH
20856: EMPTY
20857: PPUSH
20858: CALL_OW 1
20862: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20863: LD_ADDR_EXP 87
20867: PUSH
20868: LD_EXP 87
20872: PPUSH
20873: LD_VAR 0 2
20877: PPUSH
20878: EMPTY
20879: PPUSH
20880: CALL_OW 1
20884: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20885: LD_ADDR_EXP 88
20889: PUSH
20890: LD_EXP 88
20894: PPUSH
20895: LD_VAR 0 2
20899: PPUSH
20900: EMPTY
20901: PPUSH
20902: CALL_OW 1
20906: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20907: LD_ADDR_EXP 89
20911: PUSH
20912: LD_EXP 89
20916: PPUSH
20917: LD_VAR 0 2
20921: PPUSH
20922: EMPTY
20923: PPUSH
20924: CALL_OW 1
20928: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20929: LD_ADDR_EXP 90
20933: PUSH
20934: LD_EXP 90
20938: PPUSH
20939: LD_VAR 0 2
20943: PPUSH
20944: EMPTY
20945: PPUSH
20946: CALL_OW 1
20950: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20951: LD_ADDR_EXP 91
20955: PUSH
20956: LD_EXP 91
20960: PPUSH
20961: LD_VAR 0 2
20965: PPUSH
20966: EMPTY
20967: PPUSH
20968: CALL_OW 1
20972: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20973: LD_ADDR_EXP 92
20977: PUSH
20978: LD_EXP 92
20982: PPUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 0
20990: PPUSH
20991: CALL_OW 1
20995: ST_TO_ADDR
// end ;
20996: GO 19920
20998: POP
20999: POP
// MC_InitSides ( ) ;
21000: CALL 21286 0 0
// MC_InitResearch ( ) ;
21004: CALL 21025 0 0
// CustomInitMacro ( ) ;
21008: CALL 304 0 0
// skirmish := true ;
21012: LD_ADDR_EXP 48
21016: PUSH
21017: LD_INT 1
21019: ST_TO_ADDR
// end ;
21020: LD_VAR 0 1
21024: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21025: LD_INT 0
21027: PPUSH
21028: PPUSH
21029: PPUSH
21030: PPUSH
21031: PPUSH
21032: PPUSH
// if not mc_bases then
21033: LD_EXP 50
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21281
// for i = 1 to 8 do
21042: LD_ADDR_VAR 0 2
21046: PUSH
21047: DOUBLE
21048: LD_INT 1
21050: DEC
21051: ST_TO_ADDR
21052: LD_INT 8
21054: PUSH
21055: FOR_TO
21056: IFFALSE 21082
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21058: LD_ADDR_EXP 77
21062: PUSH
21063: LD_EXP 77
21067: PPUSH
21068: LD_VAR 0 2
21072: PPUSH
21073: EMPTY
21074: PPUSH
21075: CALL_OW 1
21079: ST_TO_ADDR
21080: GO 21055
21082: POP
21083: POP
// tmp := [ ] ;
21084: LD_ADDR_VAR 0 5
21088: PUSH
21089: EMPTY
21090: ST_TO_ADDR
// for i = 1 to mc_sides do
21091: LD_ADDR_VAR 0 2
21095: PUSH
21096: DOUBLE
21097: LD_INT 1
21099: DEC
21100: ST_TO_ADDR
21101: LD_EXP 76
21105: PUSH
21106: FOR_TO
21107: IFFALSE 21165
// if not mc_sides [ i ] in tmp then
21109: LD_EXP 76
21113: PUSH
21114: LD_VAR 0 2
21118: ARRAY
21119: PUSH
21120: LD_VAR 0 5
21124: IN
21125: NOT
21126: IFFALSE 21163
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21128: LD_ADDR_VAR 0 5
21132: PUSH
21133: LD_VAR 0 5
21137: PPUSH
21138: LD_VAR 0 5
21142: PUSH
21143: LD_INT 1
21145: PLUS
21146: PPUSH
21147: LD_EXP 76
21151: PUSH
21152: LD_VAR 0 2
21156: ARRAY
21157: PPUSH
21158: CALL_OW 2
21162: ST_TO_ADDR
21163: GO 21106
21165: POP
21166: POP
// if not tmp then
21167: LD_VAR 0 5
21171: NOT
21172: IFFALSE 21176
// exit ;
21174: GO 21281
// for j in tmp do
21176: LD_ADDR_VAR 0 3
21180: PUSH
21181: LD_VAR 0 5
21185: PUSH
21186: FOR_IN
21187: IFFALSE 21279
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21189: LD_ADDR_VAR 0 6
21193: PUSH
21194: LD_INT 22
21196: PUSH
21197: LD_VAR 0 3
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PPUSH
21206: CALL_OW 69
21210: ST_TO_ADDR
// if not un then
21211: LD_VAR 0 6
21215: NOT
21216: IFFALSE 21220
// continue ;
21218: GO 21186
// nation := GetNation ( un [ 1 ] ) ;
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 6
21229: PUSH
21230: LD_INT 1
21232: ARRAY
21233: PPUSH
21234: CALL_OW 248
21238: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21239: LD_ADDR_EXP 77
21243: PUSH
21244: LD_EXP 77
21248: PPUSH
21249: LD_VAR 0 3
21253: PPUSH
21254: LD_VAR 0 3
21258: PPUSH
21259: LD_VAR 0 4
21263: PPUSH
21264: LD_INT 1
21266: PPUSH
21267: CALL 47942 0 3
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// end ;
21277: GO 21186
21279: POP
21280: POP
// end ;
21281: LD_VAR 0 1
21285: RET
// export function MC_InitSides ( ) ; var i ; begin
21286: LD_INT 0
21288: PPUSH
21289: PPUSH
// if not mc_bases then
21290: LD_EXP 50
21294: NOT
21295: IFFALSE 21299
// exit ;
21297: GO 21373
// for i = 1 to mc_bases do
21299: LD_ADDR_VAR 0 2
21303: PUSH
21304: DOUBLE
21305: LD_INT 1
21307: DEC
21308: ST_TO_ADDR
21309: LD_EXP 50
21313: PUSH
21314: FOR_TO
21315: IFFALSE 21371
// if mc_bases [ i ] then
21317: LD_EXP 50
21321: PUSH
21322: LD_VAR 0 2
21326: ARRAY
21327: IFFALSE 21369
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21329: LD_ADDR_EXP 76
21333: PUSH
21334: LD_EXP 76
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: LD_EXP 50
21348: PUSH
21349: LD_VAR 0 2
21353: ARRAY
21354: PUSH
21355: LD_INT 1
21357: ARRAY
21358: PPUSH
21359: CALL_OW 255
21363: PPUSH
21364: CALL_OW 1
21368: ST_TO_ADDR
21369: GO 21314
21371: POP
21372: POP
// end ;
21373: LD_VAR 0 1
21377: RET
// every 0 0$01 trigger skirmish do
21378: LD_EXP 48
21382: IFFALSE 21536
21384: GO 21386
21386: DISABLE
// begin enable ;
21387: ENABLE
// MC_CheckBuildings ( ) ;
21388: CALL 26034 0 0
// MC_CheckPeopleLife ( ) ;
21392: CALL 26159 0 0
// RaiseSailEvent ( 100 ) ;
21396: LD_INT 100
21398: PPUSH
21399: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21403: LD_INT 103
21405: PPUSH
21406: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21410: LD_INT 104
21412: PPUSH
21413: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21417: LD_INT 105
21419: PPUSH
21420: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21424: LD_INT 106
21426: PPUSH
21427: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21431: LD_INT 107
21433: PPUSH
21434: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21438: LD_INT 108
21440: PPUSH
21441: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21445: LD_INT 109
21447: PPUSH
21448: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21452: LD_INT 110
21454: PPUSH
21455: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21459: LD_INT 111
21461: PPUSH
21462: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21466: LD_INT 112
21468: PPUSH
21469: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21473: LD_INT 113
21475: PPUSH
21476: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21480: LD_INT 120
21482: PPUSH
21483: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21487: LD_INT 121
21489: PPUSH
21490: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21494: LD_INT 122
21496: PPUSH
21497: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21501: LD_INT 123
21503: PPUSH
21504: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21508: LD_INT 124
21510: PPUSH
21511: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21515: LD_INT 125
21517: PPUSH
21518: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21522: LD_INT 126
21524: PPUSH
21525: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21529: LD_INT 200
21531: PPUSH
21532: CALL_OW 427
// end ;
21536: END
// on SailEvent ( event ) do begin if event < 100 then
21537: LD_VAR 0 1
21541: PUSH
21542: LD_INT 100
21544: LESS
21545: IFFALSE 21556
// CustomEvent ( event ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: CALL 17002 0 1
// if event = 100 then
21556: LD_VAR 0 1
21560: PUSH
21561: LD_INT 100
21563: EQUAL
21564: IFFALSE 21570
// MC_ClassManager ( ) ;
21566: CALL 21962 0 0
// if event = 101 then
21570: LD_VAR 0 1
21574: PUSH
21575: LD_INT 101
21577: EQUAL
21578: IFFALSE 21584
// MC_RepairBuildings ( ) ;
21580: CALL 26744 0 0
// if event = 102 then
21584: LD_VAR 0 1
21588: PUSH
21589: LD_INT 102
21591: EQUAL
21592: IFFALSE 21598
// MC_Heal ( ) ;
21594: CALL 27629 0 0
// if event = 103 then
21598: LD_VAR 0 1
21602: PUSH
21603: LD_INT 103
21605: EQUAL
21606: IFFALSE 21612
// MC_Build ( ) ;
21608: CALL 28051 0 0
// if event = 104 then
21612: LD_VAR 0 1
21616: PUSH
21617: LD_INT 104
21619: EQUAL
21620: IFFALSE 21626
// MC_TurretWeapon ( ) ;
21622: CALL 29664 0 0
// if event = 105 then
21626: LD_VAR 0 1
21630: PUSH
21631: LD_INT 105
21633: EQUAL
21634: IFFALSE 21640
// MC_BuildUpgrade ( ) ;
21636: CALL 29215 0 0
// if event = 106 then
21640: LD_VAR 0 1
21644: PUSH
21645: LD_INT 106
21647: EQUAL
21648: IFFALSE 21654
// MC_PlantMines ( ) ;
21650: CALL 30094 0 0
// if event = 107 then
21654: LD_VAR 0 1
21658: PUSH
21659: LD_INT 107
21661: EQUAL
21662: IFFALSE 21668
// MC_CollectCrates ( ) ;
21664: CALL 30892 0 0
// if event = 108 then
21668: LD_VAR 0 1
21672: PUSH
21673: LD_INT 108
21675: EQUAL
21676: IFFALSE 21682
// MC_LinkRemoteControl ( ) ;
21678: CALL 32668 0 0
// if event = 109 then
21682: LD_VAR 0 1
21686: PUSH
21687: LD_INT 109
21689: EQUAL
21690: IFFALSE 21696
// MC_ProduceVehicle ( ) ;
21692: CALL 32849 0 0
// if event = 110 then
21696: LD_VAR 0 1
21700: PUSH
21701: LD_INT 110
21703: EQUAL
21704: IFFALSE 21710
// MC_SendAttack ( ) ;
21706: CALL 33315 0 0
// if event = 111 then
21710: LD_VAR 0 1
21714: PUSH
21715: LD_INT 111
21717: EQUAL
21718: IFFALSE 21724
// MC_Defend ( ) ;
21720: CALL 33423 0 0
// if event = 112 then
21724: LD_VAR 0 1
21728: PUSH
21729: LD_INT 112
21731: EQUAL
21732: IFFALSE 21738
// MC_Research ( ) ;
21734: CALL 34050 0 0
// if event = 113 then
21738: LD_VAR 0 1
21742: PUSH
21743: LD_INT 113
21745: EQUAL
21746: IFFALSE 21752
// MC_MinesTrigger ( ) ;
21748: CALL 35164 0 0
// if event = 120 then
21752: LD_VAR 0 1
21756: PUSH
21757: LD_INT 120
21759: EQUAL
21760: IFFALSE 21766
// MC_RepairVehicle ( ) ;
21762: CALL 35263 0 0
// if event = 121 then
21766: LD_VAR 0 1
21770: PUSH
21771: LD_INT 121
21773: EQUAL
21774: IFFALSE 21780
// MC_TameApe ( ) ;
21776: CALL 35993 0 0
// if event = 122 then
21780: LD_VAR 0 1
21784: PUSH
21785: LD_INT 122
21787: EQUAL
21788: IFFALSE 21794
// MC_ChangeApeClass ( ) ;
21790: CALL 36822 0 0
// if event = 123 then
21794: LD_VAR 0 1
21798: PUSH
21799: LD_INT 123
21801: EQUAL
21802: IFFALSE 21808
// MC_Bazooka ( ) ;
21804: CALL 37472 0 0
// if event = 124 then
21808: LD_VAR 0 1
21812: PUSH
21813: LD_INT 124
21815: EQUAL
21816: IFFALSE 21822
// MC_TeleportExit ( ) ;
21818: CALL 37670 0 0
// if event = 125 then
21822: LD_VAR 0 1
21826: PUSH
21827: LD_INT 125
21829: EQUAL
21830: IFFALSE 21836
// MC_Deposits ( ) ;
21832: CALL 38317 0 0
// if event = 126 then
21836: LD_VAR 0 1
21840: PUSH
21841: LD_INT 126
21843: EQUAL
21844: IFFALSE 21850
// MC_RemoteDriver ( ) ;
21846: CALL 38942 0 0
// if event = 200 then
21850: LD_VAR 0 1
21854: PUSH
21855: LD_INT 200
21857: EQUAL
21858: IFFALSE 21864
// MC_Idle ( ) ;
21860: CALL 40891 0 0
// end ;
21864: PPOPN 1
21866: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21867: LD_INT 0
21869: PPUSH
21870: PPUSH
// if not mc_bases [ base ] or not tag then
21871: LD_EXP 50
21875: PUSH
21876: LD_VAR 0 1
21880: ARRAY
21881: NOT
21882: PUSH
21883: LD_VAR 0 2
21887: NOT
21888: OR
21889: IFFALSE 21893
// exit ;
21891: GO 21957
// for i in mc_bases [ base ] union mc_ape [ base ] do
21893: LD_ADDR_VAR 0 4
21897: PUSH
21898: LD_EXP 50
21902: PUSH
21903: LD_VAR 0 1
21907: ARRAY
21908: PUSH
21909: LD_EXP 79
21913: PUSH
21914: LD_VAR 0 1
21918: ARRAY
21919: UNION
21920: PUSH
21921: FOR_IN
21922: IFFALSE 21955
// if GetTag ( i ) = tag then
21924: LD_VAR 0 4
21928: PPUSH
21929: CALL_OW 110
21933: PUSH
21934: LD_VAR 0 2
21938: EQUAL
21939: IFFALSE 21953
// SetTag ( i , 0 ) ;
21941: LD_VAR 0 4
21945: PPUSH
21946: LD_INT 0
21948: PPUSH
21949: CALL_OW 109
21953: GO 21921
21955: POP
21956: POP
// end ;
21957: LD_VAR 0 3
21961: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21962: LD_INT 0
21964: PPUSH
21965: PPUSH
21966: PPUSH
21967: PPUSH
21968: PPUSH
21969: PPUSH
21970: PPUSH
21971: PPUSH
// if not mc_bases then
21972: LD_EXP 50
21976: NOT
21977: IFFALSE 21981
// exit ;
21979: GO 22439
// for i = 1 to mc_bases do
21981: LD_ADDR_VAR 0 2
21985: PUSH
21986: DOUBLE
21987: LD_INT 1
21989: DEC
21990: ST_TO_ADDR
21991: LD_EXP 50
21995: PUSH
21996: FOR_TO
21997: IFFALSE 22437
// begin tmp := MC_ClassCheckReq ( i ) ;
21999: LD_ADDR_VAR 0 4
22003: PUSH
22004: LD_VAR 0 2
22008: PPUSH
22009: CALL 22444 0 1
22013: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22014: LD_ADDR_EXP 91
22018: PUSH
22019: LD_EXP 91
22023: PPUSH
22024: LD_VAR 0 2
22028: PPUSH
22029: LD_VAR 0 4
22033: PPUSH
22034: CALL_OW 1
22038: ST_TO_ADDR
// if not tmp then
22039: LD_VAR 0 4
22043: NOT
22044: IFFALSE 22048
// continue ;
22046: GO 21996
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22048: LD_ADDR_VAR 0 6
22052: PUSH
22053: LD_EXP 50
22057: PUSH
22058: LD_VAR 0 2
22062: ARRAY
22063: PPUSH
22064: LD_INT 2
22066: PUSH
22067: LD_INT 30
22069: PUSH
22070: LD_INT 4
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PUSH
22077: LD_INT 30
22079: PUSH
22080: LD_INT 5
22082: PUSH
22083: EMPTY
22084: LIST
22085: LIST
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: LIST
22091: PPUSH
22092: CALL_OW 72
22096: PUSH
22097: LD_EXP 50
22101: PUSH
22102: LD_VAR 0 2
22106: ARRAY
22107: PPUSH
22108: LD_INT 2
22110: PUSH
22111: LD_INT 30
22113: PUSH
22114: LD_INT 0
22116: PUSH
22117: EMPTY
22118: LIST
22119: LIST
22120: PUSH
22121: LD_INT 30
22123: PUSH
22124: LD_INT 1
22126: PUSH
22127: EMPTY
22128: LIST
22129: LIST
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: LIST
22135: PPUSH
22136: CALL_OW 72
22140: PUSH
22141: LD_EXP 50
22145: PUSH
22146: LD_VAR 0 2
22150: ARRAY
22151: PPUSH
22152: LD_INT 30
22154: PUSH
22155: LD_INT 3
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: PPUSH
22162: CALL_OW 72
22166: PUSH
22167: LD_EXP 50
22171: PUSH
22172: LD_VAR 0 2
22176: ARRAY
22177: PPUSH
22178: LD_INT 2
22180: PUSH
22181: LD_INT 30
22183: PUSH
22184: LD_INT 6
22186: PUSH
22187: EMPTY
22188: LIST
22189: LIST
22190: PUSH
22191: LD_INT 30
22193: PUSH
22194: LD_INT 7
22196: PUSH
22197: EMPTY
22198: LIST
22199: LIST
22200: PUSH
22201: LD_INT 30
22203: PUSH
22204: LD_INT 8
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: PPUSH
22217: CALL_OW 72
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: LIST
22226: LIST
22227: ST_TO_ADDR
// for j = 1 to 4 do
22228: LD_ADDR_VAR 0 3
22232: PUSH
22233: DOUBLE
22234: LD_INT 1
22236: DEC
22237: ST_TO_ADDR
22238: LD_INT 4
22240: PUSH
22241: FOR_TO
22242: IFFALSE 22433
// begin if not tmp [ j ] then
22244: LD_VAR 0 4
22248: PUSH
22249: LD_VAR 0 3
22253: ARRAY
22254: NOT
22255: IFFALSE 22259
// continue ;
22257: GO 22241
// for p in tmp [ j ] do
22259: LD_ADDR_VAR 0 5
22263: PUSH
22264: LD_VAR 0 4
22268: PUSH
22269: LD_VAR 0 3
22273: ARRAY
22274: PUSH
22275: FOR_IN
22276: IFFALSE 22429
// begin if not b [ j ] then
22278: LD_VAR 0 6
22282: PUSH
22283: LD_VAR 0 3
22287: ARRAY
22288: NOT
22289: IFFALSE 22293
// break ;
22291: GO 22429
// e := 0 ;
22293: LD_ADDR_VAR 0 7
22297: PUSH
22298: LD_INT 0
22300: ST_TO_ADDR
// for k in b [ j ] do
22301: LD_ADDR_VAR 0 8
22305: PUSH
22306: LD_VAR 0 6
22310: PUSH
22311: LD_VAR 0 3
22315: ARRAY
22316: PUSH
22317: FOR_IN
22318: IFFALSE 22345
// if IsNotFull ( k ) then
22320: LD_VAR 0 8
22324: PPUSH
22325: CALL 50091 0 1
22329: IFFALSE 22343
// begin e := k ;
22331: LD_ADDR_VAR 0 7
22335: PUSH
22336: LD_VAR 0 8
22340: ST_TO_ADDR
// break ;
22341: GO 22345
// end ;
22343: GO 22317
22345: POP
22346: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22347: LD_VAR 0 7
22351: PUSH
22352: LD_VAR 0 5
22356: PPUSH
22357: LD_VAR 0 7
22361: PPUSH
22362: CALL 82511 0 2
22366: NOT
22367: AND
22368: IFFALSE 22427
// begin if IsInUnit ( p ) then
22370: LD_VAR 0 5
22374: PPUSH
22375: CALL_OW 310
22379: IFFALSE 22390
// ComExitBuilding ( p ) ;
22381: LD_VAR 0 5
22385: PPUSH
22386: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22390: LD_VAR 0 5
22394: PPUSH
22395: LD_VAR 0 7
22399: PPUSH
22400: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22404: LD_VAR 0 5
22408: PPUSH
22409: LD_VAR 0 3
22413: PPUSH
22414: CALL_OW 183
// AddComExitBuilding ( p ) ;
22418: LD_VAR 0 5
22422: PPUSH
22423: CALL_OW 182
// end ; end ;
22427: GO 22275
22429: POP
22430: POP
// end ;
22431: GO 22241
22433: POP
22434: POP
// end ;
22435: GO 21996
22437: POP
22438: POP
// end ;
22439: LD_VAR 0 1
22443: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22444: LD_INT 0
22446: PPUSH
22447: PPUSH
22448: PPUSH
22449: PPUSH
22450: PPUSH
22451: PPUSH
22452: PPUSH
22453: PPUSH
22454: PPUSH
22455: PPUSH
22456: PPUSH
22457: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22458: LD_VAR 0 1
22462: NOT
22463: PUSH
22464: LD_EXP 50
22468: PUSH
22469: LD_VAR 0 1
22473: ARRAY
22474: NOT
22475: OR
22476: PUSH
22477: LD_EXP 50
22481: PUSH
22482: LD_VAR 0 1
22486: ARRAY
22487: PPUSH
22488: LD_INT 2
22490: PUSH
22491: LD_INT 30
22493: PUSH
22494: LD_INT 0
22496: PUSH
22497: EMPTY
22498: LIST
22499: LIST
22500: PUSH
22501: LD_INT 30
22503: PUSH
22504: LD_INT 1
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: PUSH
22511: EMPTY
22512: LIST
22513: LIST
22514: LIST
22515: PPUSH
22516: CALL_OW 72
22520: NOT
22521: OR
22522: IFFALSE 22526
// exit ;
22524: GO 26029
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22526: LD_ADDR_VAR 0 4
22530: PUSH
22531: LD_EXP 50
22535: PUSH
22536: LD_VAR 0 1
22540: ARRAY
22541: PPUSH
22542: LD_INT 2
22544: PUSH
22545: LD_INT 25
22547: PUSH
22548: LD_INT 1
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: LD_INT 25
22557: PUSH
22558: LD_INT 2
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 25
22567: PUSH
22568: LD_INT 3
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: PUSH
22575: LD_INT 25
22577: PUSH
22578: LD_INT 4
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PUSH
22585: LD_INT 25
22587: PUSH
22588: LD_INT 5
22590: PUSH
22591: EMPTY
22592: LIST
22593: LIST
22594: PUSH
22595: LD_INT 25
22597: PUSH
22598: LD_INT 8
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: PUSH
22605: LD_INT 25
22607: PUSH
22608: LD_INT 9
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: LIST
22619: LIST
22620: LIST
22621: LIST
22622: LIST
22623: LIST
22624: PPUSH
22625: CALL_OW 72
22629: ST_TO_ADDR
// if not tmp then
22630: LD_VAR 0 4
22634: NOT
22635: IFFALSE 22639
// exit ;
22637: GO 26029
// for i in tmp do
22639: LD_ADDR_VAR 0 3
22643: PUSH
22644: LD_VAR 0 4
22648: PUSH
22649: FOR_IN
22650: IFFALSE 22681
// if GetTag ( i ) then
22652: LD_VAR 0 3
22656: PPUSH
22657: CALL_OW 110
22661: IFFALSE 22679
// tmp := tmp diff i ;
22663: LD_ADDR_VAR 0 4
22667: PUSH
22668: LD_VAR 0 4
22672: PUSH
22673: LD_VAR 0 3
22677: DIFF
22678: ST_TO_ADDR
22679: GO 22649
22681: POP
22682: POP
// if not tmp then
22683: LD_VAR 0 4
22687: NOT
22688: IFFALSE 22692
// exit ;
22690: GO 26029
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22692: LD_ADDR_VAR 0 5
22696: PUSH
22697: LD_EXP 50
22701: PUSH
22702: LD_VAR 0 1
22706: ARRAY
22707: PPUSH
22708: LD_INT 2
22710: PUSH
22711: LD_INT 25
22713: PUSH
22714: LD_INT 1
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: PUSH
22721: LD_INT 25
22723: PUSH
22724: LD_INT 5
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: PUSH
22731: LD_INT 25
22733: PUSH
22734: LD_INT 8
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 25
22743: PUSH
22744: LD_INT 9
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: LIST
22755: LIST
22756: LIST
22757: PPUSH
22758: CALL_OW 72
22762: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22763: LD_ADDR_VAR 0 6
22767: PUSH
22768: LD_EXP 50
22772: PUSH
22773: LD_VAR 0 1
22777: ARRAY
22778: PPUSH
22779: LD_INT 25
22781: PUSH
22782: LD_INT 2
22784: PUSH
22785: EMPTY
22786: LIST
22787: LIST
22788: PPUSH
22789: CALL_OW 72
22793: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22794: LD_ADDR_VAR 0 7
22798: PUSH
22799: LD_EXP 50
22803: PUSH
22804: LD_VAR 0 1
22808: ARRAY
22809: PPUSH
22810: LD_INT 25
22812: PUSH
22813: LD_INT 3
22815: PUSH
22816: EMPTY
22817: LIST
22818: LIST
22819: PPUSH
22820: CALL_OW 72
22824: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22825: LD_ADDR_VAR 0 8
22829: PUSH
22830: LD_EXP 50
22834: PUSH
22835: LD_VAR 0 1
22839: ARRAY
22840: PPUSH
22841: LD_INT 25
22843: PUSH
22844: LD_INT 4
22846: PUSH
22847: EMPTY
22848: LIST
22849: LIST
22850: PUSH
22851: LD_INT 24
22853: PUSH
22854: LD_INT 251
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PPUSH
22865: CALL_OW 72
22869: ST_TO_ADDR
// if mc_scan [ base ] then
22870: LD_EXP 73
22874: PUSH
22875: LD_VAR 0 1
22879: ARRAY
22880: IFFALSE 23341
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22882: LD_ADDR_EXP 92
22886: PUSH
22887: LD_EXP 92
22891: PPUSH
22892: LD_VAR 0 1
22896: PPUSH
22897: LD_INT 4
22899: PPUSH
22900: CALL_OW 1
22904: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22905: LD_ADDR_VAR 0 12
22909: PUSH
22910: LD_EXP 50
22914: PUSH
22915: LD_VAR 0 1
22919: ARRAY
22920: PPUSH
22921: LD_INT 2
22923: PUSH
22924: LD_INT 30
22926: PUSH
22927: LD_INT 4
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: PUSH
22934: LD_INT 30
22936: PUSH
22937: LD_INT 5
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: PUSH
22944: EMPTY
22945: LIST
22946: LIST
22947: LIST
22948: PPUSH
22949: CALL_OW 72
22953: ST_TO_ADDR
// if not b then
22954: LD_VAR 0 12
22958: NOT
22959: IFFALSE 22963
// exit ;
22961: GO 26029
// p := [ ] ;
22963: LD_ADDR_VAR 0 11
22967: PUSH
22968: EMPTY
22969: ST_TO_ADDR
// if sci >= 2 then
22970: LD_VAR 0 8
22974: PUSH
22975: LD_INT 2
22977: GREATEREQUAL
22978: IFFALSE 23009
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22980: LD_ADDR_VAR 0 8
22984: PUSH
22985: LD_VAR 0 8
22989: PUSH
22990: LD_INT 1
22992: ARRAY
22993: PUSH
22994: LD_VAR 0 8
22998: PUSH
22999: LD_INT 2
23001: ARRAY
23002: PUSH
23003: EMPTY
23004: LIST
23005: LIST
23006: ST_TO_ADDR
23007: GO 23070
// if sci = 1 then
23009: LD_VAR 0 8
23013: PUSH
23014: LD_INT 1
23016: EQUAL
23017: IFFALSE 23038
// sci := [ sci [ 1 ] ] else
23019: LD_ADDR_VAR 0 8
23023: PUSH
23024: LD_VAR 0 8
23028: PUSH
23029: LD_INT 1
23031: ARRAY
23032: PUSH
23033: EMPTY
23034: LIST
23035: ST_TO_ADDR
23036: GO 23070
// if sci = 0 then
23038: LD_VAR 0 8
23042: PUSH
23043: LD_INT 0
23045: EQUAL
23046: IFFALSE 23070
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23048: LD_ADDR_VAR 0 11
23052: PUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_INT 4
23060: PPUSH
23061: CALL 82374 0 2
23065: PUSH
23066: LD_INT 1
23068: ARRAY
23069: ST_TO_ADDR
// if eng > 4 then
23070: LD_VAR 0 6
23074: PUSH
23075: LD_INT 4
23077: GREATER
23078: IFFALSE 23124
// for i = eng downto 4 do
23080: LD_ADDR_VAR 0 3
23084: PUSH
23085: DOUBLE
23086: LD_VAR 0 6
23090: INC
23091: ST_TO_ADDR
23092: LD_INT 4
23094: PUSH
23095: FOR_DOWNTO
23096: IFFALSE 23122
// eng := eng diff eng [ i ] ;
23098: LD_ADDR_VAR 0 6
23102: PUSH
23103: LD_VAR 0 6
23107: PUSH
23108: LD_VAR 0 6
23112: PUSH
23113: LD_VAR 0 3
23117: ARRAY
23118: DIFF
23119: ST_TO_ADDR
23120: GO 23095
23122: POP
23123: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23124: LD_ADDR_VAR 0 4
23128: PUSH
23129: LD_VAR 0 4
23133: PUSH
23134: LD_VAR 0 5
23138: PUSH
23139: LD_VAR 0 6
23143: UNION
23144: PUSH
23145: LD_VAR 0 7
23149: UNION
23150: PUSH
23151: LD_VAR 0 8
23155: UNION
23156: DIFF
23157: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23158: LD_ADDR_VAR 0 13
23162: PUSH
23163: LD_EXP 50
23167: PUSH
23168: LD_VAR 0 1
23172: ARRAY
23173: PPUSH
23174: LD_INT 2
23176: PUSH
23177: LD_INT 30
23179: PUSH
23180: LD_INT 32
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PUSH
23187: LD_INT 30
23189: PUSH
23190: LD_INT 31
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: LIST
23201: PPUSH
23202: CALL_OW 72
23206: PUSH
23207: LD_EXP 50
23211: PUSH
23212: LD_VAR 0 1
23216: ARRAY
23217: PPUSH
23218: LD_INT 2
23220: PUSH
23221: LD_INT 30
23223: PUSH
23224: LD_INT 4
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: PUSH
23231: LD_INT 30
23233: PUSH
23234: LD_INT 5
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: LIST
23245: PPUSH
23246: CALL_OW 72
23250: PUSH
23251: LD_INT 6
23253: MUL
23254: PLUS
23255: ST_TO_ADDR
// if bcount < tmp then
23256: LD_VAR 0 13
23260: PUSH
23261: LD_VAR 0 4
23265: LESS
23266: IFFALSE 23312
// for i = tmp downto bcount do
23268: LD_ADDR_VAR 0 3
23272: PUSH
23273: DOUBLE
23274: LD_VAR 0 4
23278: INC
23279: ST_TO_ADDR
23280: LD_VAR 0 13
23284: PUSH
23285: FOR_DOWNTO
23286: IFFALSE 23310
// tmp := Delete ( tmp , tmp ) ;
23288: LD_ADDR_VAR 0 4
23292: PUSH
23293: LD_VAR 0 4
23297: PPUSH
23298: LD_VAR 0 4
23302: PPUSH
23303: CALL_OW 3
23307: ST_TO_ADDR
23308: GO 23285
23310: POP
23311: POP
// result := [ tmp , 0 , 0 , p ] ;
23312: LD_ADDR_VAR 0 2
23316: PUSH
23317: LD_VAR 0 4
23321: PUSH
23322: LD_INT 0
23324: PUSH
23325: LD_INT 0
23327: PUSH
23328: LD_VAR 0 11
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: LIST
23337: LIST
23338: ST_TO_ADDR
// exit ;
23339: GO 26029
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23341: LD_EXP 50
23345: PUSH
23346: LD_VAR 0 1
23350: ARRAY
23351: PPUSH
23352: LD_INT 2
23354: PUSH
23355: LD_INT 30
23357: PUSH
23358: LD_INT 6
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 30
23367: PUSH
23368: LD_INT 7
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: LD_INT 30
23377: PUSH
23378: LD_INT 8
23380: PUSH
23381: EMPTY
23382: LIST
23383: LIST
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: LIST
23389: LIST
23390: PPUSH
23391: CALL_OW 72
23395: NOT
23396: PUSH
23397: LD_EXP 50
23401: PUSH
23402: LD_VAR 0 1
23406: ARRAY
23407: PPUSH
23408: LD_INT 30
23410: PUSH
23411: LD_INT 3
23413: PUSH
23414: EMPTY
23415: LIST
23416: LIST
23417: PPUSH
23418: CALL_OW 72
23422: NOT
23423: AND
23424: IFFALSE 23496
// begin if eng = tmp then
23426: LD_VAR 0 6
23430: PUSH
23431: LD_VAR 0 4
23435: EQUAL
23436: IFFALSE 23440
// exit ;
23438: GO 26029
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23440: LD_ADDR_EXP 92
23444: PUSH
23445: LD_EXP 92
23449: PPUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: LD_INT 1
23457: PPUSH
23458: CALL_OW 1
23462: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23463: LD_ADDR_VAR 0 2
23467: PUSH
23468: LD_INT 0
23470: PUSH
23471: LD_VAR 0 4
23475: PUSH
23476: LD_VAR 0 6
23480: DIFF
23481: PUSH
23482: LD_INT 0
23484: PUSH
23485: LD_INT 0
23487: PUSH
23488: EMPTY
23489: LIST
23490: LIST
23491: LIST
23492: LIST
23493: ST_TO_ADDR
// exit ;
23494: GO 26029
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23496: LD_EXP 77
23500: PUSH
23501: LD_EXP 76
23505: PUSH
23506: LD_VAR 0 1
23510: ARRAY
23511: ARRAY
23512: PUSH
23513: LD_EXP 50
23517: PUSH
23518: LD_VAR 0 1
23522: ARRAY
23523: PPUSH
23524: LD_INT 2
23526: PUSH
23527: LD_INT 30
23529: PUSH
23530: LD_INT 6
23532: PUSH
23533: EMPTY
23534: LIST
23535: LIST
23536: PUSH
23537: LD_INT 30
23539: PUSH
23540: LD_INT 7
23542: PUSH
23543: EMPTY
23544: LIST
23545: LIST
23546: PUSH
23547: LD_INT 30
23549: PUSH
23550: LD_INT 8
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: LIST
23561: LIST
23562: PPUSH
23563: CALL_OW 72
23567: AND
23568: PUSH
23569: LD_EXP 50
23573: PUSH
23574: LD_VAR 0 1
23578: ARRAY
23579: PPUSH
23580: LD_INT 30
23582: PUSH
23583: LD_INT 3
23585: PUSH
23586: EMPTY
23587: LIST
23588: LIST
23589: PPUSH
23590: CALL_OW 72
23594: NOT
23595: AND
23596: IFFALSE 23810
// begin if sci >= 6 then
23598: LD_VAR 0 8
23602: PUSH
23603: LD_INT 6
23605: GREATEREQUAL
23606: IFFALSE 23610
// exit ;
23608: GO 26029
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23610: LD_ADDR_EXP 92
23614: PUSH
23615: LD_EXP 92
23619: PPUSH
23620: LD_VAR 0 1
23624: PPUSH
23625: LD_INT 2
23627: PPUSH
23628: CALL_OW 1
23632: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23633: LD_ADDR_VAR 0 9
23637: PUSH
23638: LD_VAR 0 4
23642: PUSH
23643: LD_VAR 0 8
23647: DIFF
23648: PPUSH
23649: LD_INT 4
23651: PPUSH
23652: CALL 82374 0 2
23656: ST_TO_ADDR
// p := [ ] ;
23657: LD_ADDR_VAR 0 11
23661: PUSH
23662: EMPTY
23663: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23664: LD_VAR 0 8
23668: PUSH
23669: LD_INT 6
23671: LESS
23672: PUSH
23673: LD_VAR 0 9
23677: PUSH
23678: LD_INT 6
23680: GREATER
23681: AND
23682: IFFALSE 23763
// begin for i = 1 to 6 - sci do
23684: LD_ADDR_VAR 0 3
23688: PUSH
23689: DOUBLE
23690: LD_INT 1
23692: DEC
23693: ST_TO_ADDR
23694: LD_INT 6
23696: PUSH
23697: LD_VAR 0 8
23701: MINUS
23702: PUSH
23703: FOR_TO
23704: IFFALSE 23759
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23706: LD_ADDR_VAR 0 11
23710: PUSH
23711: LD_VAR 0 11
23715: PPUSH
23716: LD_VAR 0 11
23720: PUSH
23721: LD_INT 1
23723: PLUS
23724: PPUSH
23725: LD_VAR 0 9
23729: PUSH
23730: LD_INT 1
23732: ARRAY
23733: PPUSH
23734: CALL_OW 2
23738: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23739: LD_ADDR_VAR 0 9
23743: PUSH
23744: LD_VAR 0 9
23748: PPUSH
23749: LD_INT 1
23751: PPUSH
23752: CALL_OW 3
23756: ST_TO_ADDR
// end ;
23757: GO 23703
23759: POP
23760: POP
// end else
23761: GO 23783
// if sort then
23763: LD_VAR 0 9
23767: IFFALSE 23783
// p := sort [ 1 ] ;
23769: LD_ADDR_VAR 0 11
23773: PUSH
23774: LD_VAR 0 9
23778: PUSH
23779: LD_INT 1
23781: ARRAY
23782: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23783: LD_ADDR_VAR 0 2
23787: PUSH
23788: LD_INT 0
23790: PUSH
23791: LD_INT 0
23793: PUSH
23794: LD_INT 0
23796: PUSH
23797: LD_VAR 0 11
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: LIST
23806: LIST
23807: ST_TO_ADDR
// exit ;
23808: GO 26029
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23810: LD_EXP 77
23814: PUSH
23815: LD_EXP 76
23819: PUSH
23820: LD_VAR 0 1
23824: ARRAY
23825: ARRAY
23826: PUSH
23827: LD_EXP 50
23831: PUSH
23832: LD_VAR 0 1
23836: ARRAY
23837: PPUSH
23838: LD_INT 2
23840: PUSH
23841: LD_INT 30
23843: PUSH
23844: LD_INT 6
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: PUSH
23851: LD_INT 30
23853: PUSH
23854: LD_INT 7
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PUSH
23861: LD_INT 30
23863: PUSH
23864: LD_INT 8
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: LIST
23875: LIST
23876: PPUSH
23877: CALL_OW 72
23881: AND
23882: PUSH
23883: LD_EXP 50
23887: PUSH
23888: LD_VAR 0 1
23892: ARRAY
23893: PPUSH
23894: LD_INT 30
23896: PUSH
23897: LD_INT 3
23899: PUSH
23900: EMPTY
23901: LIST
23902: LIST
23903: PPUSH
23904: CALL_OW 72
23908: AND
23909: IFFALSE 24643
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23911: LD_ADDR_EXP 92
23915: PUSH
23916: LD_EXP 92
23920: PPUSH
23921: LD_VAR 0 1
23925: PPUSH
23926: LD_INT 3
23928: PPUSH
23929: CALL_OW 1
23933: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23934: LD_ADDR_VAR 0 2
23938: PUSH
23939: LD_INT 0
23941: PUSH
23942: LD_INT 0
23944: PUSH
23945: LD_INT 0
23947: PUSH
23948: LD_INT 0
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: LIST
23955: LIST
23956: ST_TO_ADDR
// if not eng then
23957: LD_VAR 0 6
23961: NOT
23962: IFFALSE 24025
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23964: LD_ADDR_VAR 0 11
23968: PUSH
23969: LD_VAR 0 4
23973: PPUSH
23974: LD_INT 2
23976: PPUSH
23977: CALL 82374 0 2
23981: PUSH
23982: LD_INT 1
23984: ARRAY
23985: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23986: LD_ADDR_VAR 0 2
23990: PUSH
23991: LD_VAR 0 2
23995: PPUSH
23996: LD_INT 2
23998: PPUSH
23999: LD_VAR 0 11
24003: PPUSH
24004: CALL_OW 1
24008: ST_TO_ADDR
// tmp := tmp diff p ;
24009: LD_ADDR_VAR 0 4
24013: PUSH
24014: LD_VAR 0 4
24018: PUSH
24019: LD_VAR 0 11
24023: DIFF
24024: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24025: LD_VAR 0 4
24029: PUSH
24030: LD_VAR 0 8
24034: PUSH
24035: LD_INT 6
24037: LESS
24038: AND
24039: IFFALSE 24227
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24041: LD_ADDR_VAR 0 9
24045: PUSH
24046: LD_VAR 0 4
24050: PUSH
24051: LD_VAR 0 8
24055: PUSH
24056: LD_VAR 0 7
24060: UNION
24061: DIFF
24062: PPUSH
24063: LD_INT 4
24065: PPUSH
24066: CALL 82374 0 2
24070: ST_TO_ADDR
// p := [ ] ;
24071: LD_ADDR_VAR 0 11
24075: PUSH
24076: EMPTY
24077: ST_TO_ADDR
// if sort then
24078: LD_VAR 0 9
24082: IFFALSE 24198
// for i = 1 to 6 - sci do
24084: LD_ADDR_VAR 0 3
24088: PUSH
24089: DOUBLE
24090: LD_INT 1
24092: DEC
24093: ST_TO_ADDR
24094: LD_INT 6
24096: PUSH
24097: LD_VAR 0 8
24101: MINUS
24102: PUSH
24103: FOR_TO
24104: IFFALSE 24196
// begin if i = sort then
24106: LD_VAR 0 3
24110: PUSH
24111: LD_VAR 0 9
24115: EQUAL
24116: IFFALSE 24120
// break ;
24118: GO 24196
// if GetClass ( i ) = 4 then
24120: LD_VAR 0 3
24124: PPUSH
24125: CALL_OW 257
24129: PUSH
24130: LD_INT 4
24132: EQUAL
24133: IFFALSE 24137
// continue ;
24135: GO 24103
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24137: LD_ADDR_VAR 0 11
24141: PUSH
24142: LD_VAR 0 11
24146: PPUSH
24147: LD_VAR 0 11
24151: PUSH
24152: LD_INT 1
24154: PLUS
24155: PPUSH
24156: LD_VAR 0 9
24160: PUSH
24161: LD_VAR 0 3
24165: ARRAY
24166: PPUSH
24167: CALL_OW 2
24171: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24172: LD_ADDR_VAR 0 4
24176: PUSH
24177: LD_VAR 0 4
24181: PUSH
24182: LD_VAR 0 9
24186: PUSH
24187: LD_VAR 0 3
24191: ARRAY
24192: DIFF
24193: ST_TO_ADDR
// end ;
24194: GO 24103
24196: POP
24197: POP
// if p then
24198: LD_VAR 0 11
24202: IFFALSE 24227
// result := Replace ( result , 4 , p ) ;
24204: LD_ADDR_VAR 0 2
24208: PUSH
24209: LD_VAR 0 2
24213: PPUSH
24214: LD_INT 4
24216: PPUSH
24217: LD_VAR 0 11
24221: PPUSH
24222: CALL_OW 1
24226: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24227: LD_VAR 0 4
24231: PUSH
24232: LD_VAR 0 7
24236: PUSH
24237: LD_INT 6
24239: LESS
24240: AND
24241: IFFALSE 24429
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24243: LD_ADDR_VAR 0 9
24247: PUSH
24248: LD_VAR 0 4
24252: PUSH
24253: LD_VAR 0 8
24257: PUSH
24258: LD_VAR 0 7
24262: UNION
24263: DIFF
24264: PPUSH
24265: LD_INT 3
24267: PPUSH
24268: CALL 82374 0 2
24272: ST_TO_ADDR
// p := [ ] ;
24273: LD_ADDR_VAR 0 11
24277: PUSH
24278: EMPTY
24279: ST_TO_ADDR
// if sort then
24280: LD_VAR 0 9
24284: IFFALSE 24400
// for i = 1 to 6 - mech do
24286: LD_ADDR_VAR 0 3
24290: PUSH
24291: DOUBLE
24292: LD_INT 1
24294: DEC
24295: ST_TO_ADDR
24296: LD_INT 6
24298: PUSH
24299: LD_VAR 0 7
24303: MINUS
24304: PUSH
24305: FOR_TO
24306: IFFALSE 24398
// begin if i = sort then
24308: LD_VAR 0 3
24312: PUSH
24313: LD_VAR 0 9
24317: EQUAL
24318: IFFALSE 24322
// break ;
24320: GO 24398
// if GetClass ( i ) = 3 then
24322: LD_VAR 0 3
24326: PPUSH
24327: CALL_OW 257
24331: PUSH
24332: LD_INT 3
24334: EQUAL
24335: IFFALSE 24339
// continue ;
24337: GO 24305
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24339: LD_ADDR_VAR 0 11
24343: PUSH
24344: LD_VAR 0 11
24348: PPUSH
24349: LD_VAR 0 11
24353: PUSH
24354: LD_INT 1
24356: PLUS
24357: PPUSH
24358: LD_VAR 0 9
24362: PUSH
24363: LD_VAR 0 3
24367: ARRAY
24368: PPUSH
24369: CALL_OW 2
24373: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: LD_VAR 0 4
24383: PUSH
24384: LD_VAR 0 9
24388: PUSH
24389: LD_VAR 0 3
24393: ARRAY
24394: DIFF
24395: ST_TO_ADDR
// end ;
24396: GO 24305
24398: POP
24399: POP
// if p then
24400: LD_VAR 0 11
24404: IFFALSE 24429
// result := Replace ( result , 3 , p ) ;
24406: LD_ADDR_VAR 0 2
24410: PUSH
24411: LD_VAR 0 2
24415: PPUSH
24416: LD_INT 3
24418: PPUSH
24419: LD_VAR 0 11
24423: PPUSH
24424: CALL_OW 1
24428: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24429: LD_VAR 0 4
24433: PUSH
24434: LD_INT 6
24436: GREATER
24437: PUSH
24438: LD_VAR 0 6
24442: PUSH
24443: LD_INT 6
24445: LESS
24446: AND
24447: IFFALSE 24641
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24449: LD_ADDR_VAR 0 9
24453: PUSH
24454: LD_VAR 0 4
24458: PUSH
24459: LD_VAR 0 8
24463: PUSH
24464: LD_VAR 0 7
24468: UNION
24469: PUSH
24470: LD_VAR 0 6
24474: UNION
24475: DIFF
24476: PPUSH
24477: LD_INT 2
24479: PPUSH
24480: CALL 82374 0 2
24484: ST_TO_ADDR
// p := [ ] ;
24485: LD_ADDR_VAR 0 11
24489: PUSH
24490: EMPTY
24491: ST_TO_ADDR
// if sort then
24492: LD_VAR 0 9
24496: IFFALSE 24612
// for i = 1 to 6 - eng do
24498: LD_ADDR_VAR 0 3
24502: PUSH
24503: DOUBLE
24504: LD_INT 1
24506: DEC
24507: ST_TO_ADDR
24508: LD_INT 6
24510: PUSH
24511: LD_VAR 0 6
24515: MINUS
24516: PUSH
24517: FOR_TO
24518: IFFALSE 24610
// begin if i = sort then
24520: LD_VAR 0 3
24524: PUSH
24525: LD_VAR 0 9
24529: EQUAL
24530: IFFALSE 24534
// break ;
24532: GO 24610
// if GetClass ( i ) = 2 then
24534: LD_VAR 0 3
24538: PPUSH
24539: CALL_OW 257
24543: PUSH
24544: LD_INT 2
24546: EQUAL
24547: IFFALSE 24551
// continue ;
24549: GO 24517
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24551: LD_ADDR_VAR 0 11
24555: PUSH
24556: LD_VAR 0 11
24560: PPUSH
24561: LD_VAR 0 11
24565: PUSH
24566: LD_INT 1
24568: PLUS
24569: PPUSH
24570: LD_VAR 0 9
24574: PUSH
24575: LD_VAR 0 3
24579: ARRAY
24580: PPUSH
24581: CALL_OW 2
24585: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24586: LD_ADDR_VAR 0 4
24590: PUSH
24591: LD_VAR 0 4
24595: PUSH
24596: LD_VAR 0 9
24600: PUSH
24601: LD_VAR 0 3
24605: ARRAY
24606: DIFF
24607: ST_TO_ADDR
// end ;
24608: GO 24517
24610: POP
24611: POP
// if p then
24612: LD_VAR 0 11
24616: IFFALSE 24641
// result := Replace ( result , 2 , p ) ;
24618: LD_ADDR_VAR 0 2
24622: PUSH
24623: LD_VAR 0 2
24627: PPUSH
24628: LD_INT 2
24630: PPUSH
24631: LD_VAR 0 11
24635: PPUSH
24636: CALL_OW 1
24640: ST_TO_ADDR
// end ; exit ;
24641: GO 26029
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24643: LD_EXP 77
24647: PUSH
24648: LD_EXP 76
24652: PUSH
24653: LD_VAR 0 1
24657: ARRAY
24658: ARRAY
24659: NOT
24660: PUSH
24661: LD_EXP 50
24665: PUSH
24666: LD_VAR 0 1
24670: ARRAY
24671: PPUSH
24672: LD_INT 30
24674: PUSH
24675: LD_INT 3
24677: PUSH
24678: EMPTY
24679: LIST
24680: LIST
24681: PPUSH
24682: CALL_OW 72
24686: AND
24687: PUSH
24688: LD_EXP 55
24692: PUSH
24693: LD_VAR 0 1
24697: ARRAY
24698: AND
24699: IFFALSE 25307
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24701: LD_ADDR_EXP 92
24705: PUSH
24706: LD_EXP 92
24710: PPUSH
24711: LD_VAR 0 1
24715: PPUSH
24716: LD_INT 5
24718: PPUSH
24719: CALL_OW 1
24723: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24724: LD_ADDR_VAR 0 2
24728: PUSH
24729: LD_INT 0
24731: PUSH
24732: LD_INT 0
24734: PUSH
24735: LD_INT 0
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: LIST
24745: LIST
24746: ST_TO_ADDR
// if sci > 1 then
24747: LD_VAR 0 8
24751: PUSH
24752: LD_INT 1
24754: GREATER
24755: IFFALSE 24783
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24757: LD_ADDR_VAR 0 4
24761: PUSH
24762: LD_VAR 0 4
24766: PUSH
24767: LD_VAR 0 8
24771: PUSH
24772: LD_VAR 0 8
24776: PUSH
24777: LD_INT 1
24779: ARRAY
24780: DIFF
24781: DIFF
24782: ST_TO_ADDR
// if tmp and not sci then
24783: LD_VAR 0 4
24787: PUSH
24788: LD_VAR 0 8
24792: NOT
24793: AND
24794: IFFALSE 24863
// begin sort := SortBySkill ( tmp , 4 ) ;
24796: LD_ADDR_VAR 0 9
24800: PUSH
24801: LD_VAR 0 4
24805: PPUSH
24806: LD_INT 4
24808: PPUSH
24809: CALL 82374 0 2
24813: ST_TO_ADDR
// if sort then
24814: LD_VAR 0 9
24818: IFFALSE 24834
// p := sort [ 1 ] ;
24820: LD_ADDR_VAR 0 11
24824: PUSH
24825: LD_VAR 0 9
24829: PUSH
24830: LD_INT 1
24832: ARRAY
24833: ST_TO_ADDR
// if p then
24834: LD_VAR 0 11
24838: IFFALSE 24863
// result := Replace ( result , 4 , p ) ;
24840: LD_ADDR_VAR 0 2
24844: PUSH
24845: LD_VAR 0 2
24849: PPUSH
24850: LD_INT 4
24852: PPUSH
24853: LD_VAR 0 11
24857: PPUSH
24858: CALL_OW 1
24862: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24863: LD_ADDR_VAR 0 4
24867: PUSH
24868: LD_VAR 0 4
24872: PUSH
24873: LD_VAR 0 7
24877: DIFF
24878: ST_TO_ADDR
// if tmp and mech < 6 then
24879: LD_VAR 0 4
24883: PUSH
24884: LD_VAR 0 7
24888: PUSH
24889: LD_INT 6
24891: LESS
24892: AND
24893: IFFALSE 25081
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24895: LD_ADDR_VAR 0 9
24899: PUSH
24900: LD_VAR 0 4
24904: PUSH
24905: LD_VAR 0 8
24909: PUSH
24910: LD_VAR 0 7
24914: UNION
24915: DIFF
24916: PPUSH
24917: LD_INT 3
24919: PPUSH
24920: CALL 82374 0 2
24924: ST_TO_ADDR
// p := [ ] ;
24925: LD_ADDR_VAR 0 11
24929: PUSH
24930: EMPTY
24931: ST_TO_ADDR
// if sort then
24932: LD_VAR 0 9
24936: IFFALSE 25052
// for i = 1 to 6 - mech do
24938: LD_ADDR_VAR 0 3
24942: PUSH
24943: DOUBLE
24944: LD_INT 1
24946: DEC
24947: ST_TO_ADDR
24948: LD_INT 6
24950: PUSH
24951: LD_VAR 0 7
24955: MINUS
24956: PUSH
24957: FOR_TO
24958: IFFALSE 25050
// begin if i = sort then
24960: LD_VAR 0 3
24964: PUSH
24965: LD_VAR 0 9
24969: EQUAL
24970: IFFALSE 24974
// break ;
24972: GO 25050
// if GetClass ( i ) = 3 then
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 257
24983: PUSH
24984: LD_INT 3
24986: EQUAL
24987: IFFALSE 24991
// continue ;
24989: GO 24957
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24991: LD_ADDR_VAR 0 11
24995: PUSH
24996: LD_VAR 0 11
25000: PPUSH
25001: LD_VAR 0 11
25005: PUSH
25006: LD_INT 1
25008: PLUS
25009: PPUSH
25010: LD_VAR 0 9
25014: PUSH
25015: LD_VAR 0 3
25019: ARRAY
25020: PPUSH
25021: CALL_OW 2
25025: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25026: LD_ADDR_VAR 0 4
25030: PUSH
25031: LD_VAR 0 4
25035: PUSH
25036: LD_VAR 0 9
25040: PUSH
25041: LD_VAR 0 3
25045: ARRAY
25046: DIFF
25047: ST_TO_ADDR
// end ;
25048: GO 24957
25050: POP
25051: POP
// if p then
25052: LD_VAR 0 11
25056: IFFALSE 25081
// result := Replace ( result , 3 , p ) ;
25058: LD_ADDR_VAR 0 2
25062: PUSH
25063: LD_VAR 0 2
25067: PPUSH
25068: LD_INT 3
25070: PPUSH
25071: LD_VAR 0 11
25075: PPUSH
25076: CALL_OW 1
25080: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25081: LD_ADDR_VAR 0 4
25085: PUSH
25086: LD_VAR 0 4
25090: PUSH
25091: LD_VAR 0 6
25095: DIFF
25096: ST_TO_ADDR
// if tmp and eng < 6 then
25097: LD_VAR 0 4
25101: PUSH
25102: LD_VAR 0 6
25106: PUSH
25107: LD_INT 6
25109: LESS
25110: AND
25111: IFFALSE 25305
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25113: LD_ADDR_VAR 0 9
25117: PUSH
25118: LD_VAR 0 4
25122: PUSH
25123: LD_VAR 0 8
25127: PUSH
25128: LD_VAR 0 7
25132: UNION
25133: PUSH
25134: LD_VAR 0 6
25138: UNION
25139: DIFF
25140: PPUSH
25141: LD_INT 2
25143: PPUSH
25144: CALL 82374 0 2
25148: ST_TO_ADDR
// p := [ ] ;
25149: LD_ADDR_VAR 0 11
25153: PUSH
25154: EMPTY
25155: ST_TO_ADDR
// if sort then
25156: LD_VAR 0 9
25160: IFFALSE 25276
// for i = 1 to 6 - eng do
25162: LD_ADDR_VAR 0 3
25166: PUSH
25167: DOUBLE
25168: LD_INT 1
25170: DEC
25171: ST_TO_ADDR
25172: LD_INT 6
25174: PUSH
25175: LD_VAR 0 6
25179: MINUS
25180: PUSH
25181: FOR_TO
25182: IFFALSE 25274
// begin if i = sort then
25184: LD_VAR 0 3
25188: PUSH
25189: LD_VAR 0 9
25193: EQUAL
25194: IFFALSE 25198
// break ;
25196: GO 25274
// if GetClass ( i ) = 2 then
25198: LD_VAR 0 3
25202: PPUSH
25203: CALL_OW 257
25207: PUSH
25208: LD_INT 2
25210: EQUAL
25211: IFFALSE 25215
// continue ;
25213: GO 25181
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25215: LD_ADDR_VAR 0 11
25219: PUSH
25220: LD_VAR 0 11
25224: PPUSH
25225: LD_VAR 0 11
25229: PUSH
25230: LD_INT 1
25232: PLUS
25233: PPUSH
25234: LD_VAR 0 9
25238: PUSH
25239: LD_VAR 0 3
25243: ARRAY
25244: PPUSH
25245: CALL_OW 2
25249: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25250: LD_ADDR_VAR 0 4
25254: PUSH
25255: LD_VAR 0 4
25259: PUSH
25260: LD_VAR 0 9
25264: PUSH
25265: LD_VAR 0 3
25269: ARRAY
25270: DIFF
25271: ST_TO_ADDR
// end ;
25272: GO 25181
25274: POP
25275: POP
// if p then
25276: LD_VAR 0 11
25280: IFFALSE 25305
// result := Replace ( result , 2 , p ) ;
25282: LD_ADDR_VAR 0 2
25286: PUSH
25287: LD_VAR 0 2
25291: PPUSH
25292: LD_INT 2
25294: PPUSH
25295: LD_VAR 0 11
25299: PPUSH
25300: CALL_OW 1
25304: ST_TO_ADDR
// end ; exit ;
25305: GO 26029
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25307: LD_EXP 77
25311: PUSH
25312: LD_EXP 76
25316: PUSH
25317: LD_VAR 0 1
25321: ARRAY
25322: ARRAY
25323: NOT
25324: PUSH
25325: LD_EXP 50
25329: PUSH
25330: LD_VAR 0 1
25334: ARRAY
25335: PPUSH
25336: LD_INT 30
25338: PUSH
25339: LD_INT 3
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PPUSH
25346: CALL_OW 72
25350: AND
25351: PUSH
25352: LD_EXP 55
25356: PUSH
25357: LD_VAR 0 1
25361: ARRAY
25362: NOT
25363: AND
25364: IFFALSE 26029
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25366: LD_ADDR_EXP 92
25370: PUSH
25371: LD_EXP 92
25375: PPUSH
25376: LD_VAR 0 1
25380: PPUSH
25381: LD_INT 6
25383: PPUSH
25384: CALL_OW 1
25388: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25389: LD_ADDR_VAR 0 2
25393: PUSH
25394: LD_INT 0
25396: PUSH
25397: LD_INT 0
25399: PUSH
25400: LD_INT 0
25402: PUSH
25403: LD_INT 0
25405: PUSH
25406: EMPTY
25407: LIST
25408: LIST
25409: LIST
25410: LIST
25411: ST_TO_ADDR
// if sci >= 1 then
25412: LD_VAR 0 8
25416: PUSH
25417: LD_INT 1
25419: GREATEREQUAL
25420: IFFALSE 25442
// tmp := tmp diff sci [ 1 ] ;
25422: LD_ADDR_VAR 0 4
25426: PUSH
25427: LD_VAR 0 4
25431: PUSH
25432: LD_VAR 0 8
25436: PUSH
25437: LD_INT 1
25439: ARRAY
25440: DIFF
25441: ST_TO_ADDR
// if tmp and not sci then
25442: LD_VAR 0 4
25446: PUSH
25447: LD_VAR 0 8
25451: NOT
25452: AND
25453: IFFALSE 25522
// begin sort := SortBySkill ( tmp , 4 ) ;
25455: LD_ADDR_VAR 0 9
25459: PUSH
25460: LD_VAR 0 4
25464: PPUSH
25465: LD_INT 4
25467: PPUSH
25468: CALL 82374 0 2
25472: ST_TO_ADDR
// if sort then
25473: LD_VAR 0 9
25477: IFFALSE 25493
// p := sort [ 1 ] ;
25479: LD_ADDR_VAR 0 11
25483: PUSH
25484: LD_VAR 0 9
25488: PUSH
25489: LD_INT 1
25491: ARRAY
25492: ST_TO_ADDR
// if p then
25493: LD_VAR 0 11
25497: IFFALSE 25522
// result := Replace ( result , 4 , p ) ;
25499: LD_ADDR_VAR 0 2
25503: PUSH
25504: LD_VAR 0 2
25508: PPUSH
25509: LD_INT 4
25511: PPUSH
25512: LD_VAR 0 11
25516: PPUSH
25517: CALL_OW 1
25521: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25522: LD_ADDR_VAR 0 4
25526: PUSH
25527: LD_VAR 0 4
25531: PUSH
25532: LD_VAR 0 7
25536: DIFF
25537: ST_TO_ADDR
// if tmp and mech < 6 then
25538: LD_VAR 0 4
25542: PUSH
25543: LD_VAR 0 7
25547: PUSH
25548: LD_INT 6
25550: LESS
25551: AND
25552: IFFALSE 25734
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25554: LD_ADDR_VAR 0 9
25558: PUSH
25559: LD_VAR 0 4
25563: PUSH
25564: LD_VAR 0 7
25568: DIFF
25569: PPUSH
25570: LD_INT 3
25572: PPUSH
25573: CALL 82374 0 2
25577: ST_TO_ADDR
// p := [ ] ;
25578: LD_ADDR_VAR 0 11
25582: PUSH
25583: EMPTY
25584: ST_TO_ADDR
// if sort then
25585: LD_VAR 0 9
25589: IFFALSE 25705
// for i = 1 to 6 - mech do
25591: LD_ADDR_VAR 0 3
25595: PUSH
25596: DOUBLE
25597: LD_INT 1
25599: DEC
25600: ST_TO_ADDR
25601: LD_INT 6
25603: PUSH
25604: LD_VAR 0 7
25608: MINUS
25609: PUSH
25610: FOR_TO
25611: IFFALSE 25703
// begin if i = sort then
25613: LD_VAR 0 3
25617: PUSH
25618: LD_VAR 0 9
25622: EQUAL
25623: IFFALSE 25627
// break ;
25625: GO 25703
// if GetClass ( i ) = 3 then
25627: LD_VAR 0 3
25631: PPUSH
25632: CALL_OW 257
25636: PUSH
25637: LD_INT 3
25639: EQUAL
25640: IFFALSE 25644
// continue ;
25642: GO 25610
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25644: LD_ADDR_VAR 0 11
25648: PUSH
25649: LD_VAR 0 11
25653: PPUSH
25654: LD_VAR 0 11
25658: PUSH
25659: LD_INT 1
25661: PLUS
25662: PPUSH
25663: LD_VAR 0 9
25667: PUSH
25668: LD_VAR 0 3
25672: ARRAY
25673: PPUSH
25674: CALL_OW 2
25678: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25679: LD_ADDR_VAR 0 4
25683: PUSH
25684: LD_VAR 0 4
25688: PUSH
25689: LD_VAR 0 9
25693: PUSH
25694: LD_VAR 0 3
25698: ARRAY
25699: DIFF
25700: ST_TO_ADDR
// end ;
25701: GO 25610
25703: POP
25704: POP
// if p then
25705: LD_VAR 0 11
25709: IFFALSE 25734
// result := Replace ( result , 3 , p ) ;
25711: LD_ADDR_VAR 0 2
25715: PUSH
25716: LD_VAR 0 2
25720: PPUSH
25721: LD_INT 3
25723: PPUSH
25724: LD_VAR 0 11
25728: PPUSH
25729: CALL_OW 1
25733: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25734: LD_ADDR_VAR 0 4
25738: PUSH
25739: LD_VAR 0 4
25743: PUSH
25744: LD_VAR 0 6
25748: DIFF
25749: ST_TO_ADDR
// if tmp and eng < 4 then
25750: LD_VAR 0 4
25754: PUSH
25755: LD_VAR 0 6
25759: PUSH
25760: LD_INT 4
25762: LESS
25763: AND
25764: IFFALSE 25954
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25766: LD_ADDR_VAR 0 9
25770: PUSH
25771: LD_VAR 0 4
25775: PUSH
25776: LD_VAR 0 7
25780: PUSH
25781: LD_VAR 0 6
25785: UNION
25786: DIFF
25787: PPUSH
25788: LD_INT 2
25790: PPUSH
25791: CALL 82374 0 2
25795: ST_TO_ADDR
// p := [ ] ;
25796: LD_ADDR_VAR 0 11
25800: PUSH
25801: EMPTY
25802: ST_TO_ADDR
// if sort then
25803: LD_VAR 0 9
25807: IFFALSE 25923
// for i = 1 to 4 - eng do
25809: LD_ADDR_VAR 0 3
25813: PUSH
25814: DOUBLE
25815: LD_INT 1
25817: DEC
25818: ST_TO_ADDR
25819: LD_INT 4
25821: PUSH
25822: LD_VAR 0 6
25826: MINUS
25827: PUSH
25828: FOR_TO
25829: IFFALSE 25921
// begin if i = sort then
25831: LD_VAR 0 3
25835: PUSH
25836: LD_VAR 0 9
25840: EQUAL
25841: IFFALSE 25845
// break ;
25843: GO 25921
// if GetClass ( i ) = 2 then
25845: LD_VAR 0 3
25849: PPUSH
25850: CALL_OW 257
25854: PUSH
25855: LD_INT 2
25857: EQUAL
25858: IFFALSE 25862
// continue ;
25860: GO 25828
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25862: LD_ADDR_VAR 0 11
25866: PUSH
25867: LD_VAR 0 11
25871: PPUSH
25872: LD_VAR 0 11
25876: PUSH
25877: LD_INT 1
25879: PLUS
25880: PPUSH
25881: LD_VAR 0 9
25885: PUSH
25886: LD_VAR 0 3
25890: ARRAY
25891: PPUSH
25892: CALL_OW 2
25896: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25897: LD_ADDR_VAR 0 4
25901: PUSH
25902: LD_VAR 0 4
25906: PUSH
25907: LD_VAR 0 9
25911: PUSH
25912: LD_VAR 0 3
25916: ARRAY
25917: DIFF
25918: ST_TO_ADDR
// end ;
25919: GO 25828
25921: POP
25922: POP
// if p then
25923: LD_VAR 0 11
25927: IFFALSE 25952
// result := Replace ( result , 2 , p ) ;
25929: LD_ADDR_VAR 0 2
25933: PUSH
25934: LD_VAR 0 2
25938: PPUSH
25939: LD_INT 2
25941: PPUSH
25942: LD_VAR 0 11
25946: PPUSH
25947: CALL_OW 1
25951: ST_TO_ADDR
// end else
25952: GO 25998
// for i = eng downto 5 do
25954: LD_ADDR_VAR 0 3
25958: PUSH
25959: DOUBLE
25960: LD_VAR 0 6
25964: INC
25965: ST_TO_ADDR
25966: LD_INT 5
25968: PUSH
25969: FOR_DOWNTO
25970: IFFALSE 25996
// tmp := tmp union eng [ i ] ;
25972: LD_ADDR_VAR 0 4
25976: PUSH
25977: LD_VAR 0 4
25981: PUSH
25982: LD_VAR 0 6
25986: PUSH
25987: LD_VAR 0 3
25991: ARRAY
25992: UNION
25993: ST_TO_ADDR
25994: GO 25969
25996: POP
25997: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25998: LD_ADDR_VAR 0 2
26002: PUSH
26003: LD_VAR 0 2
26007: PPUSH
26008: LD_INT 1
26010: PPUSH
26011: LD_VAR 0 4
26015: PUSH
26016: LD_VAR 0 5
26020: DIFF
26021: PPUSH
26022: CALL_OW 1
26026: ST_TO_ADDR
// exit ;
26027: GO 26029
// end ; end ;
26029: LD_VAR 0 2
26033: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26034: LD_INT 0
26036: PPUSH
26037: PPUSH
26038: PPUSH
// if not mc_bases then
26039: LD_EXP 50
26043: NOT
26044: IFFALSE 26048
// exit ;
26046: GO 26154
// for i = 1 to mc_bases do
26048: LD_ADDR_VAR 0 2
26052: PUSH
26053: DOUBLE
26054: LD_INT 1
26056: DEC
26057: ST_TO_ADDR
26058: LD_EXP 50
26062: PUSH
26063: FOR_TO
26064: IFFALSE 26145
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26066: LD_ADDR_VAR 0 3
26070: PUSH
26071: LD_EXP 50
26075: PUSH
26076: LD_VAR 0 2
26080: ARRAY
26081: PPUSH
26082: LD_INT 21
26084: PUSH
26085: LD_INT 3
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 3
26094: PUSH
26095: LD_INT 24
26097: PUSH
26098: LD_INT 1000
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: EMPTY
26106: LIST
26107: LIST
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PPUSH
26113: CALL_OW 72
26117: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26118: LD_ADDR_EXP 51
26122: PUSH
26123: LD_EXP 51
26127: PPUSH
26128: LD_VAR 0 2
26132: PPUSH
26133: LD_VAR 0 3
26137: PPUSH
26138: CALL_OW 1
26142: ST_TO_ADDR
// end ;
26143: GO 26063
26145: POP
26146: POP
// RaiseSailEvent ( 101 ) ;
26147: LD_INT 101
26149: PPUSH
26150: CALL_OW 427
// end ;
26154: LD_VAR 0 1
26158: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26159: LD_INT 0
26161: PPUSH
26162: PPUSH
26163: PPUSH
26164: PPUSH
26165: PPUSH
26166: PPUSH
26167: PPUSH
// if not mc_bases then
26168: LD_EXP 50
26172: NOT
26173: IFFALSE 26177
// exit ;
26175: GO 26739
// for i = 1 to mc_bases do
26177: LD_ADDR_VAR 0 2
26181: PUSH
26182: DOUBLE
26183: LD_INT 1
26185: DEC
26186: ST_TO_ADDR
26187: LD_EXP 50
26191: PUSH
26192: FOR_TO
26193: IFFALSE 26730
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
26195: LD_ADDR_VAR 0 5
26199: PUSH
26200: LD_EXP 50
26204: PUSH
26205: LD_VAR 0 2
26209: ARRAY
26210: PUSH
26211: LD_EXP 79
26215: PUSH
26216: LD_VAR 0 2
26220: ARRAY
26221: UNION
26222: PPUSH
26223: LD_INT 21
26225: PUSH
26226: LD_INT 1
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: PUSH
26233: LD_INT 1
26235: PUSH
26236: LD_INT 3
26238: PUSH
26239: LD_INT 54
26241: PUSH
26242: EMPTY
26243: LIST
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 3
26251: PUSH
26252: LD_INT 24
26254: PUSH
26255: LD_INT 800
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: LIST
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PPUSH
26275: CALL_OW 72
26279: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26280: LD_ADDR_VAR 0 6
26284: PUSH
26285: LD_EXP 50
26289: PUSH
26290: LD_VAR 0 2
26294: ARRAY
26295: PPUSH
26296: LD_INT 21
26298: PUSH
26299: LD_INT 1
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 1
26308: PUSH
26309: LD_INT 3
26311: PUSH
26312: LD_INT 54
26314: PUSH
26315: EMPTY
26316: LIST
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 3
26324: PUSH
26325: LD_INT 24
26327: PUSH
26328: LD_INT 250
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: LIST
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PPUSH
26348: CALL_OW 72
26352: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26353: LD_ADDR_VAR 0 7
26357: PUSH
26358: LD_VAR 0 5
26362: PUSH
26363: LD_VAR 0 6
26367: DIFF
26368: ST_TO_ADDR
// if not need_heal_1 then
26369: LD_VAR 0 6
26373: NOT
26374: IFFALSE 26407
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26376: LD_ADDR_EXP 53
26380: PUSH
26381: LD_EXP 53
26385: PPUSH
26386: LD_VAR 0 2
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PPUSH
26398: EMPTY
26399: PPUSH
26400: CALL 52825 0 3
26404: ST_TO_ADDR
26405: GO 26477
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26407: LD_ADDR_EXP 53
26411: PUSH
26412: LD_EXP 53
26416: PPUSH
26417: LD_VAR 0 2
26421: PUSH
26422: LD_INT 1
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PPUSH
26429: LD_EXP 53
26433: PUSH
26434: LD_VAR 0 2
26438: ARRAY
26439: PUSH
26440: LD_INT 1
26442: ARRAY
26443: PPUSH
26444: LD_INT 3
26446: PUSH
26447: LD_INT 24
26449: PUSH
26450: LD_INT 1000
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PPUSH
26461: CALL_OW 72
26465: PUSH
26466: LD_VAR 0 6
26470: UNION
26471: PPUSH
26472: CALL 52825 0 3
26476: ST_TO_ADDR
// if not need_heal_2 then
26477: LD_VAR 0 7
26481: NOT
26482: IFFALSE 26515
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26484: LD_ADDR_EXP 53
26488: PUSH
26489: LD_EXP 53
26493: PPUSH
26494: LD_VAR 0 2
26498: PUSH
26499: LD_INT 2
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PPUSH
26506: EMPTY
26507: PPUSH
26508: CALL 52825 0 3
26512: ST_TO_ADDR
26513: GO 26547
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26515: LD_ADDR_EXP 53
26519: PUSH
26520: LD_EXP 53
26524: PPUSH
26525: LD_VAR 0 2
26529: PUSH
26530: LD_INT 2
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PPUSH
26537: LD_VAR 0 7
26541: PPUSH
26542: CALL 52825 0 3
26546: ST_TO_ADDR
// if need_heal_2 then
26547: LD_VAR 0 7
26551: IFFALSE 26712
// for j in need_heal_2 do
26553: LD_ADDR_VAR 0 3
26557: PUSH
26558: LD_VAR 0 7
26562: PUSH
26563: FOR_IN
26564: IFFALSE 26710
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26566: LD_ADDR_VAR 0 5
26570: PUSH
26571: LD_EXP 50
26575: PUSH
26576: LD_VAR 0 2
26580: ARRAY
26581: PPUSH
26582: LD_INT 2
26584: PUSH
26585: LD_INT 30
26587: PUSH
26588: LD_INT 6
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 30
26597: PUSH
26598: LD_INT 7
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 30
26607: PUSH
26608: LD_INT 8
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 30
26617: PUSH
26618: LD_INT 0
26620: PUSH
26621: EMPTY
26622: LIST
26623: LIST
26624: PUSH
26625: LD_INT 30
26627: PUSH
26628: LD_INT 1
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: PPUSH
26643: CALL_OW 72
26647: ST_TO_ADDR
// if tmp then
26648: LD_VAR 0 5
26652: IFFALSE 26708
// begin k := NearestUnitToUnit ( tmp , j ) ;
26654: LD_ADDR_VAR 0 4
26658: PUSH
26659: LD_VAR 0 5
26663: PPUSH
26664: LD_VAR 0 3
26668: PPUSH
26669: CALL_OW 74
26673: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26674: LD_VAR 0 3
26678: PPUSH
26679: LD_VAR 0 4
26683: PPUSH
26684: CALL_OW 296
26688: PUSH
26689: LD_INT 5
26691: GREATER
26692: IFFALSE 26708
// ComMoveToNearbyEntrance ( j , k ) ;
26694: LD_VAR 0 3
26698: PPUSH
26699: LD_VAR 0 4
26703: PPUSH
26704: CALL 84691 0 2
// end ; end ;
26708: GO 26563
26710: POP
26711: POP
// if not need_heal_1 and not need_heal_2 then
26712: LD_VAR 0 6
26716: NOT
26717: PUSH
26718: LD_VAR 0 7
26722: NOT
26723: AND
26724: IFFALSE 26728
// continue ;
26726: GO 26192
// end ;
26728: GO 26192
26730: POP
26731: POP
// RaiseSailEvent ( 102 ) ;
26732: LD_INT 102
26734: PPUSH
26735: CALL_OW 427
// end ;
26739: LD_VAR 0 1
26743: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26744: LD_INT 0
26746: PPUSH
26747: PPUSH
26748: PPUSH
26749: PPUSH
26750: PPUSH
26751: PPUSH
26752: PPUSH
26753: PPUSH
// if not mc_bases then
26754: LD_EXP 50
26758: NOT
26759: IFFALSE 26763
// exit ;
26761: GO 27624
// for i = 1 to mc_bases do
26763: LD_ADDR_VAR 0 2
26767: PUSH
26768: DOUBLE
26769: LD_INT 1
26771: DEC
26772: ST_TO_ADDR
26773: LD_EXP 50
26777: PUSH
26778: FOR_TO
26779: IFFALSE 27622
// begin if not mc_building_need_repair [ i ] then
26781: LD_EXP 51
26785: PUSH
26786: LD_VAR 0 2
26790: ARRAY
26791: NOT
26792: IFFALSE 26979
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
26794: LD_ADDR_VAR 0 6
26798: PUSH
26799: LD_EXP 69
26803: PUSH
26804: LD_VAR 0 2
26808: ARRAY
26809: PPUSH
26810: LD_INT 3
26812: PUSH
26813: LD_INT 24
26815: PUSH
26816: LD_INT 1000
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: PUSH
26827: LD_INT 2
26829: PUSH
26830: LD_INT 34
26832: PUSH
26833: LD_INT 13
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 34
26842: PUSH
26843: LD_INT 52
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: LD_INT 34
26852: PUSH
26853: LD_EXP 99
26857: PUSH
26858: EMPTY
26859: LIST
26860: LIST
26861: PUSH
26862: EMPTY
26863: LIST
26864: LIST
26865: LIST
26866: LIST
26867: PUSH
26868: EMPTY
26869: LIST
26870: LIST
26871: PPUSH
26872: CALL_OW 72
26876: ST_TO_ADDR
// if cranes then
26877: LD_VAR 0 6
26881: IFFALSE 26943
// for j in cranes do
26883: LD_ADDR_VAR 0 3
26887: PUSH
26888: LD_VAR 0 6
26892: PUSH
26893: FOR_IN
26894: IFFALSE 26941
// if not IsInArea ( j , mc_parking [ i ] ) then
26896: LD_VAR 0 3
26900: PPUSH
26901: LD_EXP 74
26905: PUSH
26906: LD_VAR 0 2
26910: ARRAY
26911: PPUSH
26912: CALL_OW 308
26916: NOT
26917: IFFALSE 26939
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26919: LD_VAR 0 3
26923: PPUSH
26924: LD_EXP 74
26928: PUSH
26929: LD_VAR 0 2
26933: ARRAY
26934: PPUSH
26935: CALL_OW 113
26939: GO 26893
26941: POP
26942: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26943: LD_ADDR_EXP 52
26947: PUSH
26948: LD_EXP 52
26952: PPUSH
26953: LD_VAR 0 2
26957: PPUSH
26958: EMPTY
26959: PPUSH
26960: CALL_OW 1
26964: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26965: LD_VAR 0 2
26969: PPUSH
26970: LD_INT 101
26972: PPUSH
26973: CALL 21867 0 2
// continue ;
26977: GO 26778
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26979: LD_ADDR_EXP 56
26983: PUSH
26984: LD_EXP 56
26988: PPUSH
26989: LD_VAR 0 2
26993: PPUSH
26994: EMPTY
26995: PPUSH
26996: CALL_OW 1
27000: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27001: LD_VAR 0 2
27005: PPUSH
27006: LD_INT 103
27008: PPUSH
27009: CALL 21867 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27013: LD_ADDR_VAR 0 5
27017: PUSH
27018: LD_EXP 50
27022: PUSH
27023: LD_VAR 0 2
27027: ARRAY
27028: PUSH
27029: LD_EXP 79
27033: PUSH
27034: LD_VAR 0 2
27038: ARRAY
27039: UNION
27040: PPUSH
27041: LD_INT 2
27043: PUSH
27044: LD_INT 25
27046: PUSH
27047: LD_INT 2
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 25
27056: PUSH
27057: LD_INT 16
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: LIST
27068: PUSH
27069: EMPTY
27070: LIST
27071: PPUSH
27072: CALL_OW 72
27076: PUSH
27077: LD_EXP 53
27081: PUSH
27082: LD_VAR 0 2
27086: ARRAY
27087: PUSH
27088: LD_INT 1
27090: ARRAY
27091: PUSH
27092: LD_EXP 53
27096: PUSH
27097: LD_VAR 0 2
27101: ARRAY
27102: PUSH
27103: LD_INT 2
27105: ARRAY
27106: UNION
27107: DIFF
27108: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27109: LD_ADDR_VAR 0 6
27113: PUSH
27114: LD_EXP 69
27118: PUSH
27119: LD_VAR 0 2
27123: ARRAY
27124: PPUSH
27125: LD_INT 2
27127: PUSH
27128: LD_INT 34
27130: PUSH
27131: LD_INT 13
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: LD_INT 34
27140: PUSH
27141: LD_INT 52
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 34
27150: PUSH
27151: LD_EXP 99
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: LIST
27164: LIST
27165: PPUSH
27166: CALL_OW 72
27170: ST_TO_ADDR
// if cranes then
27171: LD_VAR 0 6
27175: IFFALSE 27311
// begin for j in cranes do
27177: LD_ADDR_VAR 0 3
27181: PUSH
27182: LD_VAR 0 6
27186: PUSH
27187: FOR_IN
27188: IFFALSE 27309
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27190: LD_VAR 0 3
27194: PPUSH
27195: CALL_OW 256
27199: PUSH
27200: LD_INT 1000
27202: EQUAL
27203: PUSH
27204: LD_VAR 0 3
27208: PPUSH
27209: CALL_OW 314
27213: NOT
27214: AND
27215: IFFALSE 27249
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27217: LD_VAR 0 3
27221: PPUSH
27222: LD_EXP 51
27226: PUSH
27227: LD_VAR 0 2
27231: ARRAY
27232: PPUSH
27233: LD_VAR 0 3
27237: PPUSH
27238: CALL_OW 74
27242: PPUSH
27243: CALL_OW 130
27247: GO 27307
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27249: LD_VAR 0 3
27253: PPUSH
27254: CALL_OW 256
27258: PUSH
27259: LD_INT 500
27261: LESS
27262: PUSH
27263: LD_VAR 0 3
27267: PPUSH
27268: LD_EXP 74
27272: PUSH
27273: LD_VAR 0 2
27277: ARRAY
27278: PPUSH
27279: CALL_OW 308
27283: NOT
27284: AND
27285: IFFALSE 27307
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27287: LD_VAR 0 3
27291: PPUSH
27292: LD_EXP 74
27296: PUSH
27297: LD_VAR 0 2
27301: ARRAY
27302: PPUSH
27303: CALL_OW 113
// end ;
27307: GO 27187
27309: POP
27310: POP
// end ; if tmp > 3 then
27311: LD_VAR 0 5
27315: PUSH
27316: LD_INT 3
27318: GREATER
27319: IFFALSE 27339
// tmp := ShrinkArray ( tmp , 4 ) ;
27321: LD_ADDR_VAR 0 5
27325: PUSH
27326: LD_VAR 0 5
27330: PPUSH
27331: LD_INT 4
27333: PPUSH
27334: CALL 84183 0 2
27338: ST_TO_ADDR
// if not tmp then
27339: LD_VAR 0 5
27343: NOT
27344: IFFALSE 27348
// continue ;
27346: GO 26778
// for j in tmp do
27348: LD_ADDR_VAR 0 3
27352: PUSH
27353: LD_VAR 0 5
27357: PUSH
27358: FOR_IN
27359: IFFALSE 27618
// begin if IsInUnit ( j ) then
27361: LD_VAR 0 3
27365: PPUSH
27366: CALL_OW 310
27370: IFFALSE 27381
// ComExitBuilding ( j ) ;
27372: LD_VAR 0 3
27376: PPUSH
27377: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27381: LD_VAR 0 3
27385: PUSH
27386: LD_EXP 52
27390: PUSH
27391: LD_VAR 0 2
27395: ARRAY
27396: IN
27397: NOT
27398: IFFALSE 27456
// begin SetTag ( j , 101 ) ;
27400: LD_VAR 0 3
27404: PPUSH
27405: LD_INT 101
27407: PPUSH
27408: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27412: LD_ADDR_EXP 52
27416: PUSH
27417: LD_EXP 52
27421: PPUSH
27422: LD_VAR 0 2
27426: PUSH
27427: LD_EXP 52
27431: PUSH
27432: LD_VAR 0 2
27436: ARRAY
27437: PUSH
27438: LD_INT 1
27440: PLUS
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PPUSH
27446: LD_VAR 0 3
27450: PPUSH
27451: CALL 52825 0 3
27455: ST_TO_ADDR
// end ; wait ( 1 ) ;
27456: LD_INT 1
27458: PPUSH
27459: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27463: LD_ADDR_VAR 0 7
27467: PUSH
27468: LD_EXP 51
27472: PUSH
27473: LD_VAR 0 2
27477: ARRAY
27478: ST_TO_ADDR
// if mc_scan [ i ] then
27479: LD_EXP 73
27483: PUSH
27484: LD_VAR 0 2
27488: ARRAY
27489: IFFALSE 27551
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27491: LD_ADDR_VAR 0 7
27495: PUSH
27496: LD_EXP 51
27500: PUSH
27501: LD_VAR 0 2
27505: ARRAY
27506: PPUSH
27507: LD_INT 3
27509: PUSH
27510: LD_INT 30
27512: PUSH
27513: LD_INT 32
27515: PUSH
27516: EMPTY
27517: LIST
27518: LIST
27519: PUSH
27520: LD_INT 30
27522: PUSH
27523: LD_INT 33
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: PUSH
27530: LD_INT 30
27532: PUSH
27533: LD_INT 31
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: PPUSH
27546: CALL_OW 72
27550: ST_TO_ADDR
// if not to_repair_tmp then
27551: LD_VAR 0 7
27555: NOT
27556: IFFALSE 27560
// continue ;
27558: GO 27358
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27560: LD_ADDR_VAR 0 8
27564: PUSH
27565: LD_VAR 0 7
27569: PPUSH
27570: LD_VAR 0 3
27574: PPUSH
27575: CALL_OW 74
27579: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27580: LD_VAR 0 8
27584: PPUSH
27585: LD_INT 16
27587: PPUSH
27588: CALL 55418 0 2
27592: PUSH
27593: LD_INT 4
27595: ARRAY
27596: PUSH
27597: LD_INT 10
27599: LESS
27600: IFFALSE 27616
// ComRepairBuilding ( j , to_repair ) ;
27602: LD_VAR 0 3
27606: PPUSH
27607: LD_VAR 0 8
27611: PPUSH
27612: CALL_OW 130
// end ;
27616: GO 27358
27618: POP
27619: POP
// end ;
27620: GO 26778
27622: POP
27623: POP
// end ;
27624: LD_VAR 0 1
27628: RET
// export function MC_Heal ; var i , j , tmp ; begin
27629: LD_INT 0
27631: PPUSH
27632: PPUSH
27633: PPUSH
27634: PPUSH
// if not mc_bases then
27635: LD_EXP 50
27639: NOT
27640: IFFALSE 27644
// exit ;
27642: GO 28046
// for i = 1 to mc_bases do
27644: LD_ADDR_VAR 0 2
27648: PUSH
27649: DOUBLE
27650: LD_INT 1
27652: DEC
27653: ST_TO_ADDR
27654: LD_EXP 50
27658: PUSH
27659: FOR_TO
27660: IFFALSE 28044
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27662: LD_EXP 53
27666: PUSH
27667: LD_VAR 0 2
27671: ARRAY
27672: PUSH
27673: LD_INT 1
27675: ARRAY
27676: NOT
27677: PUSH
27678: LD_EXP 53
27682: PUSH
27683: LD_VAR 0 2
27687: ARRAY
27688: PUSH
27689: LD_INT 2
27691: ARRAY
27692: NOT
27693: AND
27694: IFFALSE 27732
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27696: LD_ADDR_EXP 54
27700: PUSH
27701: LD_EXP 54
27705: PPUSH
27706: LD_VAR 0 2
27710: PPUSH
27711: EMPTY
27712: PPUSH
27713: CALL_OW 1
27717: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27718: LD_VAR 0 2
27722: PPUSH
27723: LD_INT 102
27725: PPUSH
27726: CALL 21867 0 2
// continue ;
27730: GO 27659
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27732: LD_ADDR_VAR 0 4
27736: PUSH
27737: LD_EXP 50
27741: PUSH
27742: LD_VAR 0 2
27746: ARRAY
27747: PPUSH
27748: LD_INT 25
27750: PUSH
27751: LD_INT 4
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: PPUSH
27758: CALL_OW 72
27762: ST_TO_ADDR
// if not tmp then
27763: LD_VAR 0 4
27767: NOT
27768: IFFALSE 27772
// continue ;
27770: GO 27659
// if mc_taming [ i ] then
27772: LD_EXP 81
27776: PUSH
27777: LD_VAR 0 2
27781: ARRAY
27782: IFFALSE 27806
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27784: LD_ADDR_EXP 81
27788: PUSH
27789: LD_EXP 81
27793: PPUSH
27794: LD_VAR 0 2
27798: PPUSH
27799: EMPTY
27800: PPUSH
27801: CALL_OW 1
27805: ST_TO_ADDR
// for j in tmp do
27806: LD_ADDR_VAR 0 3
27810: PUSH
27811: LD_VAR 0 4
27815: PUSH
27816: FOR_IN
27817: IFFALSE 28040
// begin if IsInUnit ( j ) then
27819: LD_VAR 0 3
27823: PPUSH
27824: CALL_OW 310
27828: IFFALSE 27839
// ComExitBuilding ( j ) ;
27830: LD_VAR 0 3
27834: PPUSH
27835: CALL_OW 122
// if not j in mc_healers [ i ] then
27839: LD_VAR 0 3
27843: PUSH
27844: LD_EXP 54
27848: PUSH
27849: LD_VAR 0 2
27853: ARRAY
27854: IN
27855: NOT
27856: IFFALSE 27902
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27858: LD_ADDR_EXP 54
27862: PUSH
27863: LD_EXP 54
27867: PPUSH
27868: LD_VAR 0 2
27872: PUSH
27873: LD_EXP 54
27877: PUSH
27878: LD_VAR 0 2
27882: ARRAY
27883: PUSH
27884: LD_INT 1
27886: PLUS
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PPUSH
27892: LD_VAR 0 3
27896: PPUSH
27897: CALL 52825 0 3
27901: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27902: LD_VAR 0 3
27906: PPUSH
27907: CALL_OW 110
27911: PUSH
27912: LD_INT 102
27914: NONEQUAL
27915: IFFALSE 27929
// SetTag ( j , 102 ) ;
27917: LD_VAR 0 3
27921: PPUSH
27922: LD_INT 102
27924: PPUSH
27925: CALL_OW 109
// Wait ( 3 ) ;
27929: LD_INT 3
27931: PPUSH
27932: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27936: LD_EXP 53
27940: PUSH
27941: LD_VAR 0 2
27945: ARRAY
27946: PUSH
27947: LD_INT 1
27949: ARRAY
27950: IFFALSE 27982
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27952: LD_VAR 0 3
27956: PPUSH
27957: LD_EXP 53
27961: PUSH
27962: LD_VAR 0 2
27966: ARRAY
27967: PUSH
27968: LD_INT 1
27970: ARRAY
27971: PUSH
27972: LD_INT 1
27974: ARRAY
27975: PPUSH
27976: CALL_OW 128
27980: GO 28038
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27982: LD_VAR 0 3
27986: PPUSH
27987: CALL_OW 314
27991: NOT
27992: PUSH
27993: LD_EXP 53
27997: PUSH
27998: LD_VAR 0 2
28002: ARRAY
28003: PUSH
28004: LD_INT 2
28006: ARRAY
28007: AND
28008: IFFALSE 28038
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28010: LD_VAR 0 3
28014: PPUSH
28015: LD_EXP 53
28019: PUSH
28020: LD_VAR 0 2
28024: ARRAY
28025: PUSH
28026: LD_INT 2
28028: ARRAY
28029: PUSH
28030: LD_INT 1
28032: ARRAY
28033: PPUSH
28034: CALL_OW 128
// end ;
28038: GO 27816
28040: POP
28041: POP
// end ;
28042: GO 27659
28044: POP
28045: POP
// end ;
28046: LD_VAR 0 1
28050: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28051: LD_INT 0
28053: PPUSH
28054: PPUSH
28055: PPUSH
28056: PPUSH
28057: PPUSH
// if not mc_bases then
28058: LD_EXP 50
28062: NOT
28063: IFFALSE 28067
// exit ;
28065: GO 29210
// for i = 1 to mc_bases do
28067: LD_ADDR_VAR 0 2
28071: PUSH
28072: DOUBLE
28073: LD_INT 1
28075: DEC
28076: ST_TO_ADDR
28077: LD_EXP 50
28081: PUSH
28082: FOR_TO
28083: IFFALSE 29208
// begin if mc_scan [ i ] then
28085: LD_EXP 73
28089: PUSH
28090: LD_VAR 0 2
28094: ARRAY
28095: IFFALSE 28099
// continue ;
28097: GO 28082
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28099: LD_EXP 55
28103: PUSH
28104: LD_VAR 0 2
28108: ARRAY
28109: NOT
28110: PUSH
28111: LD_EXP 57
28115: PUSH
28116: LD_VAR 0 2
28120: ARRAY
28121: NOT
28122: AND
28123: PUSH
28124: LD_EXP 56
28128: PUSH
28129: LD_VAR 0 2
28133: ARRAY
28134: AND
28135: IFFALSE 28173
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28137: LD_ADDR_EXP 56
28141: PUSH
28142: LD_EXP 56
28146: PPUSH
28147: LD_VAR 0 2
28151: PPUSH
28152: EMPTY
28153: PPUSH
28154: CALL_OW 1
28158: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28159: LD_VAR 0 2
28163: PPUSH
28164: LD_INT 103
28166: PPUSH
28167: CALL 21867 0 2
// continue ;
28171: GO 28082
// end ; if mc_construct_list [ i ] then
28173: LD_EXP 57
28177: PUSH
28178: LD_VAR 0 2
28182: ARRAY
28183: IFFALSE 28403
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28185: LD_ADDR_VAR 0 4
28189: PUSH
28190: LD_EXP 50
28194: PUSH
28195: LD_VAR 0 2
28199: ARRAY
28200: PPUSH
28201: LD_INT 25
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PPUSH
28211: CALL_OW 72
28215: PUSH
28216: LD_EXP 52
28220: PUSH
28221: LD_VAR 0 2
28225: ARRAY
28226: DIFF
28227: ST_TO_ADDR
// if not tmp then
28228: LD_VAR 0 4
28232: NOT
28233: IFFALSE 28237
// continue ;
28235: GO 28082
// for j in tmp do
28237: LD_ADDR_VAR 0 3
28241: PUSH
28242: LD_VAR 0 4
28246: PUSH
28247: FOR_IN
28248: IFFALSE 28399
// begin if not mc_builders [ i ] then
28250: LD_EXP 56
28254: PUSH
28255: LD_VAR 0 2
28259: ARRAY
28260: NOT
28261: IFFALSE 28319
// begin SetTag ( j , 103 ) ;
28263: LD_VAR 0 3
28267: PPUSH
28268: LD_INT 103
28270: PPUSH
28271: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28275: LD_ADDR_EXP 56
28279: PUSH
28280: LD_EXP 56
28284: PPUSH
28285: LD_VAR 0 2
28289: PUSH
28290: LD_EXP 56
28294: PUSH
28295: LD_VAR 0 2
28299: ARRAY
28300: PUSH
28301: LD_INT 1
28303: PLUS
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PPUSH
28309: LD_VAR 0 3
28313: PPUSH
28314: CALL 52825 0 3
28318: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28319: LD_VAR 0 3
28323: PPUSH
28324: CALL_OW 310
28328: IFFALSE 28339
// ComExitBuilding ( j ) ;
28330: LD_VAR 0 3
28334: PPUSH
28335: CALL_OW 122
// wait ( 3 ) ;
28339: LD_INT 3
28341: PPUSH
28342: CALL_OW 67
// if not mc_construct_list [ i ] then
28346: LD_EXP 57
28350: PUSH
28351: LD_VAR 0 2
28355: ARRAY
28356: NOT
28357: IFFALSE 28361
// break ;
28359: GO 28399
// if not HasTask ( j ) then
28361: LD_VAR 0 3
28365: PPUSH
28366: CALL_OW 314
28370: NOT
28371: IFFALSE 28397
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28373: LD_VAR 0 3
28377: PPUSH
28378: LD_EXP 57
28382: PUSH
28383: LD_VAR 0 2
28387: ARRAY
28388: PUSH
28389: LD_INT 1
28391: ARRAY
28392: PPUSH
28393: CALL 55676 0 2
// end ;
28397: GO 28247
28399: POP
28400: POP
// end else
28401: GO 29206
// if mc_build_list [ i ] then
28403: LD_EXP 55
28407: PUSH
28408: LD_VAR 0 2
28412: ARRAY
28413: IFFALSE 29206
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28415: LD_ADDR_VAR 0 5
28419: PUSH
28420: LD_EXP 50
28424: PUSH
28425: LD_VAR 0 2
28429: ARRAY
28430: PPUSH
28431: LD_INT 2
28433: PUSH
28434: LD_INT 30
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 30
28446: PUSH
28447: LD_INT 1
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: LIST
28458: PPUSH
28459: CALL_OW 72
28463: ST_TO_ADDR
// if depot then
28464: LD_VAR 0 5
28468: IFFALSE 28486
// depot := depot [ 1 ] else
28470: LD_ADDR_VAR 0 5
28474: PUSH
28475: LD_VAR 0 5
28479: PUSH
28480: LD_INT 1
28482: ARRAY
28483: ST_TO_ADDR
28484: GO 28494
// depot := 0 ;
28486: LD_ADDR_VAR 0 5
28490: PUSH
28491: LD_INT 0
28493: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28494: LD_EXP 55
28498: PUSH
28499: LD_VAR 0 2
28503: ARRAY
28504: PUSH
28505: LD_INT 1
28507: ARRAY
28508: PUSH
28509: LD_INT 1
28511: ARRAY
28512: PPUSH
28513: CALL 55506 0 1
28517: PUSH
28518: LD_EXP 50
28522: PUSH
28523: LD_VAR 0 2
28527: ARRAY
28528: PPUSH
28529: LD_INT 2
28531: PUSH
28532: LD_INT 30
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: PUSH
28542: LD_INT 30
28544: PUSH
28545: LD_INT 3
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: LIST
28556: PPUSH
28557: CALL_OW 72
28561: NOT
28562: AND
28563: IFFALSE 28668
// begin for j = 1 to mc_build_list [ i ] do
28565: LD_ADDR_VAR 0 3
28569: PUSH
28570: DOUBLE
28571: LD_INT 1
28573: DEC
28574: ST_TO_ADDR
28575: LD_EXP 55
28579: PUSH
28580: LD_VAR 0 2
28584: ARRAY
28585: PUSH
28586: FOR_TO
28587: IFFALSE 28666
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28589: LD_EXP 55
28593: PUSH
28594: LD_VAR 0 2
28598: ARRAY
28599: PUSH
28600: LD_VAR 0 3
28604: ARRAY
28605: PUSH
28606: LD_INT 1
28608: ARRAY
28609: PUSH
28610: LD_INT 2
28612: EQUAL
28613: IFFALSE 28664
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28615: LD_ADDR_EXP 55
28619: PUSH
28620: LD_EXP 55
28624: PPUSH
28625: LD_VAR 0 2
28629: PPUSH
28630: LD_EXP 55
28634: PUSH
28635: LD_VAR 0 2
28639: ARRAY
28640: PPUSH
28641: LD_VAR 0 3
28645: PPUSH
28646: LD_INT 1
28648: PPUSH
28649: LD_INT 0
28651: PPUSH
28652: CALL 52243 0 4
28656: PPUSH
28657: CALL_OW 1
28661: ST_TO_ADDR
// break ;
28662: GO 28666
// end ;
28664: GO 28586
28666: POP
28667: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28668: LD_EXP 55
28672: PUSH
28673: LD_VAR 0 2
28677: ARRAY
28678: PUSH
28679: LD_INT 1
28681: ARRAY
28682: PUSH
28683: LD_INT 1
28685: ARRAY
28686: PUSH
28687: LD_INT 0
28689: EQUAL
28690: PUSH
28691: LD_VAR 0 5
28695: PUSH
28696: LD_VAR 0 5
28700: PPUSH
28701: LD_EXP 55
28705: PUSH
28706: LD_VAR 0 2
28710: ARRAY
28711: PUSH
28712: LD_INT 1
28714: ARRAY
28715: PUSH
28716: LD_INT 1
28718: ARRAY
28719: PPUSH
28720: LD_EXP 55
28724: PUSH
28725: LD_VAR 0 2
28729: ARRAY
28730: PUSH
28731: LD_INT 1
28733: ARRAY
28734: PUSH
28735: LD_INT 2
28737: ARRAY
28738: PPUSH
28739: LD_EXP 55
28743: PUSH
28744: LD_VAR 0 2
28748: ARRAY
28749: PUSH
28750: LD_INT 1
28752: ARRAY
28753: PUSH
28754: LD_INT 3
28756: ARRAY
28757: PPUSH
28758: LD_EXP 55
28762: PUSH
28763: LD_VAR 0 2
28767: ARRAY
28768: PUSH
28769: LD_INT 1
28771: ARRAY
28772: PUSH
28773: LD_INT 4
28775: ARRAY
28776: PPUSH
28777: CALL 60240 0 5
28781: AND
28782: OR
28783: IFFALSE 29064
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28785: LD_ADDR_VAR 0 4
28789: PUSH
28790: LD_EXP 50
28794: PUSH
28795: LD_VAR 0 2
28799: ARRAY
28800: PPUSH
28801: LD_INT 25
28803: PUSH
28804: LD_INT 2
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: PPUSH
28811: CALL_OW 72
28815: PUSH
28816: LD_EXP 52
28820: PUSH
28821: LD_VAR 0 2
28825: ARRAY
28826: DIFF
28827: ST_TO_ADDR
// if not tmp then
28828: LD_VAR 0 4
28832: NOT
28833: IFFALSE 28837
// continue ;
28835: GO 28082
// for j in tmp do
28837: LD_ADDR_VAR 0 3
28841: PUSH
28842: LD_VAR 0 4
28846: PUSH
28847: FOR_IN
28848: IFFALSE 29060
// begin if not mc_builders [ i ] then
28850: LD_EXP 56
28854: PUSH
28855: LD_VAR 0 2
28859: ARRAY
28860: NOT
28861: IFFALSE 28919
// begin SetTag ( j , 103 ) ;
28863: LD_VAR 0 3
28867: PPUSH
28868: LD_INT 103
28870: PPUSH
28871: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28875: LD_ADDR_EXP 56
28879: PUSH
28880: LD_EXP 56
28884: PPUSH
28885: LD_VAR 0 2
28889: PUSH
28890: LD_EXP 56
28894: PUSH
28895: LD_VAR 0 2
28899: ARRAY
28900: PUSH
28901: LD_INT 1
28903: PLUS
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PPUSH
28909: LD_VAR 0 3
28913: PPUSH
28914: CALL 52825 0 3
28918: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28919: LD_VAR 0 3
28923: PPUSH
28924: CALL_OW 310
28928: IFFALSE 28939
// ComExitBuilding ( j ) ;
28930: LD_VAR 0 3
28934: PPUSH
28935: CALL_OW 122
// wait ( 3 ) ;
28939: LD_INT 3
28941: PPUSH
28942: CALL_OW 67
// if not mc_build_list [ i ] then
28946: LD_EXP 55
28950: PUSH
28951: LD_VAR 0 2
28955: ARRAY
28956: NOT
28957: IFFALSE 28961
// break ;
28959: GO 29060
// if not HasTask ( j ) then
28961: LD_VAR 0 3
28965: PPUSH
28966: CALL_OW 314
28970: NOT
28971: IFFALSE 29058
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28973: LD_VAR 0 3
28977: PPUSH
28978: LD_EXP 55
28982: PUSH
28983: LD_VAR 0 2
28987: ARRAY
28988: PUSH
28989: LD_INT 1
28991: ARRAY
28992: PUSH
28993: LD_INT 1
28995: ARRAY
28996: PPUSH
28997: LD_EXP 55
29001: PUSH
29002: LD_VAR 0 2
29006: ARRAY
29007: PUSH
29008: LD_INT 1
29010: ARRAY
29011: PUSH
29012: LD_INT 2
29014: ARRAY
29015: PPUSH
29016: LD_EXP 55
29020: PUSH
29021: LD_VAR 0 2
29025: ARRAY
29026: PUSH
29027: LD_INT 1
29029: ARRAY
29030: PUSH
29031: LD_INT 3
29033: ARRAY
29034: PPUSH
29035: LD_EXP 55
29039: PUSH
29040: LD_VAR 0 2
29044: ARRAY
29045: PUSH
29046: LD_INT 1
29048: ARRAY
29049: PUSH
29050: LD_INT 4
29052: ARRAY
29053: PPUSH
29054: CALL_OW 145
// end ;
29058: GO 28847
29060: POP
29061: POP
// end else
29062: GO 29206
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29064: LD_EXP 50
29068: PUSH
29069: LD_VAR 0 2
29073: ARRAY
29074: PPUSH
29075: LD_EXP 55
29079: PUSH
29080: LD_VAR 0 2
29084: ARRAY
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: PUSH
29090: LD_INT 1
29092: ARRAY
29093: PPUSH
29094: LD_EXP 55
29098: PUSH
29099: LD_VAR 0 2
29103: ARRAY
29104: PUSH
29105: LD_INT 1
29107: ARRAY
29108: PUSH
29109: LD_INT 2
29111: ARRAY
29112: PPUSH
29113: LD_EXP 55
29117: PUSH
29118: LD_VAR 0 2
29122: ARRAY
29123: PUSH
29124: LD_INT 1
29126: ARRAY
29127: PUSH
29128: LD_INT 3
29130: ARRAY
29131: PPUSH
29132: LD_EXP 55
29136: PUSH
29137: LD_VAR 0 2
29141: ARRAY
29142: PUSH
29143: LD_INT 1
29145: ARRAY
29146: PUSH
29147: LD_INT 4
29149: ARRAY
29150: PPUSH
29151: CALL 59576 0 5
29155: NOT
29156: IFFALSE 29206
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29158: LD_ADDR_EXP 55
29162: PUSH
29163: LD_EXP 55
29167: PPUSH
29168: LD_VAR 0 2
29172: PPUSH
29173: LD_EXP 55
29177: PUSH
29178: LD_VAR 0 2
29182: ARRAY
29183: PPUSH
29184: LD_INT 1
29186: PPUSH
29187: LD_INT 1
29189: NEG
29190: PPUSH
29191: LD_INT 0
29193: PPUSH
29194: CALL 52243 0 4
29198: PPUSH
29199: CALL_OW 1
29203: ST_TO_ADDR
// continue ;
29204: GO 28082
// end ; end ; end ;
29206: GO 28082
29208: POP
29209: POP
// end ;
29210: LD_VAR 0 1
29214: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29215: LD_INT 0
29217: PPUSH
29218: PPUSH
29219: PPUSH
29220: PPUSH
29221: PPUSH
29222: PPUSH
// if not mc_bases then
29223: LD_EXP 50
29227: NOT
29228: IFFALSE 29232
// exit ;
29230: GO 29659
// for i = 1 to mc_bases do
29232: LD_ADDR_VAR 0 2
29236: PUSH
29237: DOUBLE
29238: LD_INT 1
29240: DEC
29241: ST_TO_ADDR
29242: LD_EXP 50
29246: PUSH
29247: FOR_TO
29248: IFFALSE 29657
// begin tmp := mc_build_upgrade [ i ] ;
29250: LD_ADDR_VAR 0 4
29254: PUSH
29255: LD_EXP 82
29259: PUSH
29260: LD_VAR 0 2
29264: ARRAY
29265: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29266: LD_ADDR_VAR 0 6
29270: PUSH
29271: LD_EXP 83
29275: PUSH
29276: LD_VAR 0 2
29280: ARRAY
29281: PPUSH
29282: LD_INT 2
29284: PUSH
29285: LD_INT 30
29287: PUSH
29288: LD_INT 6
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 30
29297: PUSH
29298: LD_INT 7
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: LIST
29309: PPUSH
29310: CALL_OW 72
29314: ST_TO_ADDR
// if not tmp and not lab then
29315: LD_VAR 0 4
29319: NOT
29320: PUSH
29321: LD_VAR 0 6
29325: NOT
29326: AND
29327: IFFALSE 29331
// continue ;
29329: GO 29247
// if tmp then
29331: LD_VAR 0 4
29335: IFFALSE 29455
// for j in tmp do
29337: LD_ADDR_VAR 0 3
29341: PUSH
29342: LD_VAR 0 4
29346: PUSH
29347: FOR_IN
29348: IFFALSE 29453
// begin if UpgradeCost ( j ) then
29350: LD_VAR 0 3
29354: PPUSH
29355: CALL 59236 0 1
29359: IFFALSE 29451
// begin ComUpgrade ( j ) ;
29361: LD_VAR 0 3
29365: PPUSH
29366: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29370: LD_ADDR_EXP 82
29374: PUSH
29375: LD_EXP 82
29379: PPUSH
29380: LD_VAR 0 2
29384: PPUSH
29385: LD_EXP 82
29389: PUSH
29390: LD_VAR 0 2
29394: ARRAY
29395: PUSH
29396: LD_VAR 0 3
29400: DIFF
29401: PPUSH
29402: CALL_OW 1
29406: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29407: LD_ADDR_EXP 57
29411: PUSH
29412: LD_EXP 57
29416: PPUSH
29417: LD_VAR 0 2
29421: PUSH
29422: LD_EXP 57
29426: PUSH
29427: LD_VAR 0 2
29431: ARRAY
29432: PUSH
29433: LD_INT 1
29435: PLUS
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PPUSH
29441: LD_VAR 0 3
29445: PPUSH
29446: CALL 52825 0 3
29450: ST_TO_ADDR
// end ; end ;
29451: GO 29347
29453: POP
29454: POP
// if not lab or not mc_lab_upgrade [ i ] then
29455: LD_VAR 0 6
29459: NOT
29460: PUSH
29461: LD_EXP 84
29465: PUSH
29466: LD_VAR 0 2
29470: ARRAY
29471: NOT
29472: OR
29473: IFFALSE 29477
// continue ;
29475: GO 29247
// for j in lab do
29477: LD_ADDR_VAR 0 3
29481: PUSH
29482: LD_VAR 0 6
29486: PUSH
29487: FOR_IN
29488: IFFALSE 29653
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29490: LD_VAR 0 3
29494: PPUSH
29495: CALL_OW 266
29499: PUSH
29500: LD_INT 6
29502: PUSH
29503: LD_INT 7
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: IN
29510: PUSH
29511: LD_VAR 0 3
29515: PPUSH
29516: CALL_OW 461
29520: PUSH
29521: LD_INT 1
29523: NONEQUAL
29524: AND
29525: IFFALSE 29651
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29527: LD_VAR 0 3
29531: PPUSH
29532: LD_EXP 84
29536: PUSH
29537: LD_VAR 0 2
29541: ARRAY
29542: PUSH
29543: LD_INT 1
29545: ARRAY
29546: PPUSH
29547: CALL 59441 0 2
29551: IFFALSE 29651
// begin ComCancel ( j ) ;
29553: LD_VAR 0 3
29557: PPUSH
29558: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29562: LD_VAR 0 3
29566: PPUSH
29567: LD_EXP 84
29571: PUSH
29572: LD_VAR 0 2
29576: ARRAY
29577: PUSH
29578: LD_INT 1
29580: ARRAY
29581: PPUSH
29582: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29586: LD_VAR 0 3
29590: PUSH
29591: LD_EXP 57
29595: PUSH
29596: LD_VAR 0 2
29600: ARRAY
29601: IN
29602: NOT
29603: IFFALSE 29649
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29605: LD_ADDR_EXP 57
29609: PUSH
29610: LD_EXP 57
29614: PPUSH
29615: LD_VAR 0 2
29619: PUSH
29620: LD_EXP 57
29624: PUSH
29625: LD_VAR 0 2
29629: ARRAY
29630: PUSH
29631: LD_INT 1
29633: PLUS
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PPUSH
29639: LD_VAR 0 3
29643: PPUSH
29644: CALL 52825 0 3
29648: ST_TO_ADDR
// break ;
29649: GO 29653
// end ; end ; end ;
29651: GO 29487
29653: POP
29654: POP
// end ;
29655: GO 29247
29657: POP
29658: POP
// end ;
29659: LD_VAR 0 1
29663: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29664: LD_INT 0
29666: PPUSH
29667: PPUSH
29668: PPUSH
29669: PPUSH
29670: PPUSH
29671: PPUSH
29672: PPUSH
29673: PPUSH
29674: PPUSH
// if not mc_bases then
29675: LD_EXP 50
29679: NOT
29680: IFFALSE 29684
// exit ;
29682: GO 30089
// for i = 1 to mc_bases do
29684: LD_ADDR_VAR 0 2
29688: PUSH
29689: DOUBLE
29690: LD_INT 1
29692: DEC
29693: ST_TO_ADDR
29694: LD_EXP 50
29698: PUSH
29699: FOR_TO
29700: IFFALSE 30087
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29702: LD_EXP 58
29706: PUSH
29707: LD_VAR 0 2
29711: ARRAY
29712: NOT
29713: PUSH
29714: LD_EXP 50
29718: PUSH
29719: LD_VAR 0 2
29723: ARRAY
29724: PPUSH
29725: LD_INT 30
29727: PUSH
29728: LD_INT 3
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: PPUSH
29735: CALL_OW 72
29739: NOT
29740: OR
29741: IFFALSE 29745
// continue ;
29743: GO 29699
// busy := false ;
29745: LD_ADDR_VAR 0 8
29749: PUSH
29750: LD_INT 0
29752: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29753: LD_ADDR_VAR 0 4
29757: PUSH
29758: LD_EXP 50
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PPUSH
29769: LD_INT 30
29771: PUSH
29772: LD_INT 3
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PPUSH
29779: CALL_OW 72
29783: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29784: LD_ADDR_VAR 0 6
29788: PUSH
29789: LD_EXP 58
29793: PUSH
29794: LD_VAR 0 2
29798: ARRAY
29799: PPUSH
29800: LD_INT 2
29802: PUSH
29803: LD_INT 30
29805: PUSH
29806: LD_INT 32
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 30
29815: PUSH
29816: LD_INT 33
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: LIST
29827: PPUSH
29828: CALL_OW 72
29832: ST_TO_ADDR
// if not t then
29833: LD_VAR 0 6
29837: NOT
29838: IFFALSE 29842
// continue ;
29840: GO 29699
// for j in tmp do
29842: LD_ADDR_VAR 0 3
29846: PUSH
29847: LD_VAR 0 4
29851: PUSH
29852: FOR_IN
29853: IFFALSE 29883
// if not BuildingStatus ( j ) = bs_idle then
29855: LD_VAR 0 3
29859: PPUSH
29860: CALL_OW 461
29864: PUSH
29865: LD_INT 2
29867: EQUAL
29868: NOT
29869: IFFALSE 29881
// begin busy := true ;
29871: LD_ADDR_VAR 0 8
29875: PUSH
29876: LD_INT 1
29878: ST_TO_ADDR
// break ;
29879: GO 29883
// end ;
29881: GO 29852
29883: POP
29884: POP
// if busy then
29885: LD_VAR 0 8
29889: IFFALSE 29893
// continue ;
29891: GO 29699
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29893: LD_ADDR_VAR 0 7
29897: PUSH
29898: LD_VAR 0 6
29902: PPUSH
29903: LD_INT 35
29905: PUSH
29906: LD_INT 0
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PPUSH
29913: CALL_OW 72
29917: ST_TO_ADDR
// if tw then
29918: LD_VAR 0 7
29922: IFFALSE 29999
// begin tw := tw [ 1 ] ;
29924: LD_ADDR_VAR 0 7
29928: PUSH
29929: LD_VAR 0 7
29933: PUSH
29934: LD_INT 1
29936: ARRAY
29937: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29938: LD_ADDR_VAR 0 9
29942: PUSH
29943: LD_VAR 0 7
29947: PPUSH
29948: LD_EXP 75
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: PPUSH
29959: CALL 57795 0 2
29963: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29964: LD_EXP 89
29968: PUSH
29969: LD_VAR 0 2
29973: ARRAY
29974: IFFALSE 29997
// if not weapon in mc_allowed_tower_weapons [ i ] then
29976: LD_VAR 0 9
29980: PUSH
29981: LD_EXP 89
29985: PUSH
29986: LD_VAR 0 2
29990: ARRAY
29991: IN
29992: NOT
29993: IFFALSE 29997
// continue ;
29995: GO 29699
// end else
29997: GO 30062
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29999: LD_ADDR_VAR 0 5
30003: PUSH
30004: LD_EXP 58
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: PPUSH
30015: LD_VAR 0 4
30019: PPUSH
30020: CALL 83416 0 2
30024: ST_TO_ADDR
// if not tmp2 then
30025: LD_VAR 0 5
30029: NOT
30030: IFFALSE 30034
// continue ;
30032: GO 29699
// tw := tmp2 [ 1 ] ;
30034: LD_ADDR_VAR 0 7
30038: PUSH
30039: LD_VAR 0 5
30043: PUSH
30044: LD_INT 1
30046: ARRAY
30047: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30048: LD_ADDR_VAR 0 9
30052: PUSH
30053: LD_VAR 0 5
30057: PUSH
30058: LD_INT 2
30060: ARRAY
30061: ST_TO_ADDR
// end ; if not weapon then
30062: LD_VAR 0 9
30066: NOT
30067: IFFALSE 30071
// continue ;
30069: GO 29699
// ComPlaceWeapon ( tw , weapon ) ;
30071: LD_VAR 0 7
30075: PPUSH
30076: LD_VAR 0 9
30080: PPUSH
30081: CALL_OW 148
// end ;
30085: GO 29699
30087: POP
30088: POP
// end ;
30089: LD_VAR 0 1
30093: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
30094: LD_INT 0
30096: PPUSH
30097: PPUSH
30098: PPUSH
30099: PPUSH
30100: PPUSH
30101: PPUSH
// if not mc_bases then
30102: LD_EXP 50
30106: NOT
30107: IFFALSE 30111
// exit ;
30109: GO 30887
// for i = 1 to mc_bases do
30111: LD_ADDR_VAR 0 2
30115: PUSH
30116: DOUBLE
30117: LD_INT 1
30119: DEC
30120: ST_TO_ADDR
30121: LD_EXP 50
30125: PUSH
30126: FOR_TO
30127: IFFALSE 30885
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30129: LD_EXP 63
30133: PUSH
30134: LD_VAR 0 2
30138: ARRAY
30139: NOT
30140: PUSH
30141: LD_EXP 63
30145: PUSH
30146: LD_VAR 0 2
30150: ARRAY
30151: PUSH
30152: LD_EXP 64
30156: PUSH
30157: LD_VAR 0 2
30161: ARRAY
30162: EQUAL
30163: OR
30164: PUSH
30165: LD_EXP 73
30169: PUSH
30170: LD_VAR 0 2
30174: ARRAY
30175: OR
30176: IFFALSE 30180
// continue ;
30178: GO 30126
// if mc_miners [ i ] then
30180: LD_EXP 64
30184: PUSH
30185: LD_VAR 0 2
30189: ARRAY
30190: IFFALSE 30572
// begin for j = mc_miners [ i ] downto 1 do
30192: LD_ADDR_VAR 0 3
30196: PUSH
30197: DOUBLE
30198: LD_EXP 64
30202: PUSH
30203: LD_VAR 0 2
30207: ARRAY
30208: INC
30209: ST_TO_ADDR
30210: LD_INT 1
30212: PUSH
30213: FOR_DOWNTO
30214: IFFALSE 30570
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30216: LD_EXP 64
30220: PUSH
30221: LD_VAR 0 2
30225: ARRAY
30226: PUSH
30227: LD_VAR 0 3
30231: ARRAY
30232: PPUSH
30233: CALL_OW 301
30237: PUSH
30238: LD_EXP 64
30242: PUSH
30243: LD_VAR 0 2
30247: ARRAY
30248: PUSH
30249: LD_VAR 0 3
30253: ARRAY
30254: PPUSH
30255: CALL_OW 257
30259: PUSH
30260: LD_INT 1
30262: NONEQUAL
30263: OR
30264: IFFALSE 30327
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30266: LD_ADDR_VAR 0 5
30270: PUSH
30271: LD_EXP 64
30275: PUSH
30276: LD_VAR 0 2
30280: ARRAY
30281: PUSH
30282: LD_EXP 64
30286: PUSH
30287: LD_VAR 0 2
30291: ARRAY
30292: PUSH
30293: LD_VAR 0 3
30297: ARRAY
30298: DIFF
30299: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30300: LD_ADDR_EXP 64
30304: PUSH
30305: LD_EXP 64
30309: PPUSH
30310: LD_VAR 0 2
30314: PPUSH
30315: LD_VAR 0 5
30319: PPUSH
30320: CALL_OW 1
30324: ST_TO_ADDR
// continue ;
30325: GO 30213
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30327: LD_EXP 64
30331: PUSH
30332: LD_VAR 0 2
30336: ARRAY
30337: PUSH
30338: LD_VAR 0 3
30342: ARRAY
30343: PPUSH
30344: CALL_OW 257
30348: PUSH
30349: LD_INT 1
30351: EQUAL
30352: PUSH
30353: LD_EXP 64
30357: PUSH
30358: LD_VAR 0 2
30362: ARRAY
30363: PUSH
30364: LD_VAR 0 3
30368: ARRAY
30369: PPUSH
30370: CALL_OW 459
30374: NOT
30375: AND
30376: PUSH
30377: LD_EXP 64
30381: PUSH
30382: LD_VAR 0 2
30386: ARRAY
30387: PUSH
30388: LD_VAR 0 3
30392: ARRAY
30393: PPUSH
30394: CALL_OW 314
30398: NOT
30399: AND
30400: IFFALSE 30568
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30402: LD_EXP 64
30406: PUSH
30407: LD_VAR 0 2
30411: ARRAY
30412: PUSH
30413: LD_VAR 0 3
30417: ARRAY
30418: PPUSH
30419: CALL_OW 310
30423: IFFALSE 30446
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30425: LD_EXP 64
30429: PUSH
30430: LD_VAR 0 2
30434: ARRAY
30435: PUSH
30436: LD_VAR 0 3
30440: ARRAY
30441: PPUSH
30442: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30446: LD_EXP 64
30450: PUSH
30451: LD_VAR 0 2
30455: ARRAY
30456: PUSH
30457: LD_VAR 0 3
30461: ARRAY
30462: PPUSH
30463: CALL_OW 314
30467: NOT
30468: IFFALSE 30568
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
30470: LD_EXP 64
30474: PUSH
30475: LD_VAR 0 2
30479: ARRAY
30480: PUSH
30481: LD_VAR 0 3
30485: ARRAY
30486: PPUSH
30487: LD_EXP 63
30491: PUSH
30492: LD_VAR 0 2
30496: ARRAY
30497: PUSH
30498: LD_VAR 0 3
30502: PUSH
30503: LD_EXP 63
30507: PUSH
30508: LD_VAR 0 2
30512: ARRAY
30513: MOD
30514: PUSH
30515: LD_INT 1
30517: PLUS
30518: ARRAY
30519: PUSH
30520: LD_INT 1
30522: ARRAY
30523: PPUSH
30524: LD_EXP 63
30528: PUSH
30529: LD_VAR 0 2
30533: ARRAY
30534: PUSH
30535: LD_VAR 0 3
30539: PUSH
30540: LD_EXP 63
30544: PUSH
30545: LD_VAR 0 2
30549: ARRAY
30550: MOD
30551: PUSH
30552: LD_INT 1
30554: PLUS
30555: ARRAY
30556: PUSH
30557: LD_INT 2
30559: ARRAY
30560: PPUSH
30561: LD_INT 0
30563: PPUSH
30564: CALL_OW 193
// end ; end ;
30568: GO 30213
30570: POP
30571: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30572: LD_ADDR_VAR 0 5
30576: PUSH
30577: LD_EXP 50
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: PPUSH
30588: LD_INT 2
30590: PUSH
30591: LD_INT 30
30593: PUSH
30594: LD_INT 4
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: LD_INT 30
30603: PUSH
30604: LD_INT 5
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: LD_INT 30
30613: PUSH
30614: LD_INT 32
30616: PUSH
30617: EMPTY
30618: LIST
30619: LIST
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: PPUSH
30627: CALL_OW 72
30631: ST_TO_ADDR
// if not tmp then
30632: LD_VAR 0 5
30636: NOT
30637: IFFALSE 30641
// continue ;
30639: GO 30126
// list := [ ] ;
30641: LD_ADDR_VAR 0 6
30645: PUSH
30646: EMPTY
30647: ST_TO_ADDR
// for j in tmp do
30648: LD_ADDR_VAR 0 3
30652: PUSH
30653: LD_VAR 0 5
30657: PUSH
30658: FOR_IN
30659: IFFALSE 30728
// begin for k in UnitsInside ( j ) do
30661: LD_ADDR_VAR 0 4
30665: PUSH
30666: LD_VAR 0 3
30670: PPUSH
30671: CALL_OW 313
30675: PUSH
30676: FOR_IN
30677: IFFALSE 30724
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30679: LD_VAR 0 4
30683: PPUSH
30684: CALL_OW 257
30688: PUSH
30689: LD_INT 1
30691: EQUAL
30692: PUSH
30693: LD_VAR 0 4
30697: PPUSH
30698: CALL_OW 459
30702: NOT
30703: AND
30704: IFFALSE 30722
// list := list ^ k ;
30706: LD_ADDR_VAR 0 6
30710: PUSH
30711: LD_VAR 0 6
30715: PUSH
30716: LD_VAR 0 4
30720: ADD
30721: ST_TO_ADDR
30722: GO 30676
30724: POP
30725: POP
// end ;
30726: GO 30658
30728: POP
30729: POP
// list := list diff mc_miners [ i ] ;
30730: LD_ADDR_VAR 0 6
30734: PUSH
30735: LD_VAR 0 6
30739: PUSH
30740: LD_EXP 64
30744: PUSH
30745: LD_VAR 0 2
30749: ARRAY
30750: DIFF
30751: ST_TO_ADDR
// if not list then
30752: LD_VAR 0 6
30756: NOT
30757: IFFALSE 30761
// continue ;
30759: GO 30126
// k := mc_mines [ i ] - mc_miners [ i ] ;
30761: LD_ADDR_VAR 0 4
30765: PUSH
30766: LD_EXP 63
30770: PUSH
30771: LD_VAR 0 2
30775: ARRAY
30776: PUSH
30777: LD_EXP 64
30781: PUSH
30782: LD_VAR 0 2
30786: ARRAY
30787: MINUS
30788: ST_TO_ADDR
// if k > list then
30789: LD_VAR 0 4
30793: PUSH
30794: LD_VAR 0 6
30798: GREATER
30799: IFFALSE 30811
// k := list ;
30801: LD_ADDR_VAR 0 4
30805: PUSH
30806: LD_VAR 0 6
30810: ST_TO_ADDR
// for j = 1 to k do
30811: LD_ADDR_VAR 0 3
30815: PUSH
30816: DOUBLE
30817: LD_INT 1
30819: DEC
30820: ST_TO_ADDR
30821: LD_VAR 0 4
30825: PUSH
30826: FOR_TO
30827: IFFALSE 30881
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30829: LD_ADDR_EXP 64
30833: PUSH
30834: LD_EXP 64
30838: PPUSH
30839: LD_VAR 0 2
30843: PUSH
30844: LD_EXP 64
30848: PUSH
30849: LD_VAR 0 2
30853: ARRAY
30854: PUSH
30855: LD_INT 1
30857: PLUS
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PPUSH
30863: LD_VAR 0 6
30867: PUSH
30868: LD_VAR 0 3
30872: ARRAY
30873: PPUSH
30874: CALL 52825 0 3
30878: ST_TO_ADDR
30879: GO 30826
30881: POP
30882: POP
// end ;
30883: GO 30126
30885: POP
30886: POP
// end ;
30887: LD_VAR 0 1
30891: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30892: LD_INT 0
30894: PPUSH
30895: PPUSH
30896: PPUSH
30897: PPUSH
30898: PPUSH
30899: PPUSH
30900: PPUSH
30901: PPUSH
30902: PPUSH
30903: PPUSH
// if not mc_bases then
30904: LD_EXP 50
30908: NOT
30909: IFFALSE 30913
// exit ;
30911: GO 32663
// for i = 1 to mc_bases do
30913: LD_ADDR_VAR 0 2
30917: PUSH
30918: DOUBLE
30919: LD_INT 1
30921: DEC
30922: ST_TO_ADDR
30923: LD_EXP 50
30927: PUSH
30928: FOR_TO
30929: IFFALSE 32661
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30931: LD_EXP 50
30935: PUSH
30936: LD_VAR 0 2
30940: ARRAY
30941: NOT
30942: PUSH
30943: LD_EXP 57
30947: PUSH
30948: LD_VAR 0 2
30952: ARRAY
30953: OR
30954: IFFALSE 30958
// continue ;
30956: GO 30928
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30958: LD_EXP 66
30962: PUSH
30963: LD_VAR 0 2
30967: ARRAY
30968: NOT
30969: PUSH
30970: LD_EXP 67
30974: PUSH
30975: LD_VAR 0 2
30979: ARRAY
30980: AND
30981: IFFALSE 31019
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30983: LD_ADDR_EXP 67
30987: PUSH
30988: LD_EXP 67
30992: PPUSH
30993: LD_VAR 0 2
30997: PPUSH
30998: EMPTY
30999: PPUSH
31000: CALL_OW 1
31004: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31005: LD_VAR 0 2
31009: PPUSH
31010: LD_INT 107
31012: PPUSH
31013: CALL 21867 0 2
// continue ;
31017: GO 30928
// end ; target := [ ] ;
31019: LD_ADDR_VAR 0 6
31023: PUSH
31024: EMPTY
31025: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31026: LD_ADDR_VAR 0 3
31030: PUSH
31031: DOUBLE
31032: LD_EXP 66
31036: PUSH
31037: LD_VAR 0 2
31041: ARRAY
31042: INC
31043: ST_TO_ADDR
31044: LD_INT 1
31046: PUSH
31047: FOR_DOWNTO
31048: IFFALSE 31308
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31050: LD_EXP 66
31054: PUSH
31055: LD_VAR 0 2
31059: ARRAY
31060: PUSH
31061: LD_VAR 0 3
31065: ARRAY
31066: PUSH
31067: LD_INT 2
31069: ARRAY
31070: PPUSH
31071: LD_EXP 66
31075: PUSH
31076: LD_VAR 0 2
31080: ARRAY
31081: PUSH
31082: LD_VAR 0 3
31086: ARRAY
31087: PUSH
31088: LD_INT 3
31090: ARRAY
31091: PPUSH
31092: CALL_OW 488
31096: PUSH
31097: LD_EXP 66
31101: PUSH
31102: LD_VAR 0 2
31106: ARRAY
31107: PUSH
31108: LD_VAR 0 3
31112: ARRAY
31113: PUSH
31114: LD_INT 2
31116: ARRAY
31117: PPUSH
31118: LD_EXP 66
31122: PUSH
31123: LD_VAR 0 2
31127: ARRAY
31128: PUSH
31129: LD_VAR 0 3
31133: ARRAY
31134: PUSH
31135: LD_INT 3
31137: ARRAY
31138: PPUSH
31139: CALL_OW 284
31143: PUSH
31144: LD_INT 0
31146: EQUAL
31147: AND
31148: IFFALSE 31203
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31150: LD_ADDR_VAR 0 5
31154: PUSH
31155: LD_EXP 66
31159: PUSH
31160: LD_VAR 0 2
31164: ARRAY
31165: PPUSH
31166: LD_VAR 0 3
31170: PPUSH
31171: CALL_OW 3
31175: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31176: LD_ADDR_EXP 66
31180: PUSH
31181: LD_EXP 66
31185: PPUSH
31186: LD_VAR 0 2
31190: PPUSH
31191: LD_VAR 0 5
31195: PPUSH
31196: CALL_OW 1
31200: ST_TO_ADDR
// continue ;
31201: GO 31047
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31203: LD_EXP 50
31207: PUSH
31208: LD_VAR 0 2
31212: ARRAY
31213: PUSH
31214: LD_INT 1
31216: ARRAY
31217: PPUSH
31218: CALL_OW 255
31222: PPUSH
31223: LD_EXP 66
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: PUSH
31234: LD_VAR 0 3
31238: ARRAY
31239: PUSH
31240: LD_INT 2
31242: ARRAY
31243: PPUSH
31244: LD_EXP 66
31248: PUSH
31249: LD_VAR 0 2
31253: ARRAY
31254: PUSH
31255: LD_VAR 0 3
31259: ARRAY
31260: PUSH
31261: LD_INT 3
31263: ARRAY
31264: PPUSH
31265: LD_INT 30
31267: PPUSH
31268: CALL 53721 0 4
31272: PUSH
31273: LD_INT 4
31275: ARRAY
31276: PUSH
31277: LD_INT 0
31279: EQUAL
31280: IFFALSE 31306
// begin target := mc_crates [ i ] [ j ] ;
31282: LD_ADDR_VAR 0 6
31286: PUSH
31287: LD_EXP 66
31291: PUSH
31292: LD_VAR 0 2
31296: ARRAY
31297: PUSH
31298: LD_VAR 0 3
31302: ARRAY
31303: ST_TO_ADDR
// break ;
31304: GO 31308
// end ; end ;
31306: GO 31047
31308: POP
31309: POP
// if not target then
31310: LD_VAR 0 6
31314: NOT
31315: IFFALSE 31319
// continue ;
31317: GO 30928
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31319: LD_ADDR_VAR 0 7
31323: PUSH
31324: LD_EXP 69
31328: PUSH
31329: LD_VAR 0 2
31333: ARRAY
31334: PPUSH
31335: LD_INT 2
31337: PUSH
31338: LD_INT 3
31340: PUSH
31341: LD_INT 58
31343: PUSH
31344: EMPTY
31345: LIST
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 61
31353: PUSH
31354: EMPTY
31355: LIST
31356: PUSH
31357: LD_INT 33
31359: PUSH
31360: LD_INT 5
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 33
31369: PUSH
31370: LD_INT 3
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: LD_INT 34
31389: PUSH
31390: LD_INT 32
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 34
31399: PUSH
31400: LD_INT 51
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 34
31409: PUSH
31410: LD_INT 12
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PPUSH
31427: CALL_OW 72
31431: ST_TO_ADDR
// if not cargo then
31432: LD_VAR 0 7
31436: NOT
31437: IFFALSE 32080
// begin if mc_crates_collector [ i ] < 5 then
31439: LD_EXP 67
31443: PUSH
31444: LD_VAR 0 2
31448: ARRAY
31449: PUSH
31450: LD_INT 5
31452: LESS
31453: IFFALSE 31819
// begin if mc_ape [ i ] then
31455: LD_EXP 79
31459: PUSH
31460: LD_VAR 0 2
31464: ARRAY
31465: IFFALSE 31512
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31467: LD_ADDR_VAR 0 5
31471: PUSH
31472: LD_EXP 79
31476: PUSH
31477: LD_VAR 0 2
31481: ARRAY
31482: PPUSH
31483: LD_INT 25
31485: PUSH
31486: LD_INT 16
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 24
31495: PUSH
31496: LD_INT 750
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PPUSH
31507: CALL_OW 72
31511: ST_TO_ADDR
// if not tmp then
31512: LD_VAR 0 5
31516: NOT
31517: IFFALSE 31564
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31519: LD_ADDR_VAR 0 5
31523: PUSH
31524: LD_EXP 50
31528: PUSH
31529: LD_VAR 0 2
31533: ARRAY
31534: PPUSH
31535: LD_INT 25
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 24
31547: PUSH
31548: LD_INT 750
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PPUSH
31559: CALL_OW 72
31563: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31564: LD_EXP 79
31568: PUSH
31569: LD_VAR 0 2
31573: ARRAY
31574: PUSH
31575: LD_EXP 50
31579: PUSH
31580: LD_VAR 0 2
31584: ARRAY
31585: PPUSH
31586: LD_INT 25
31588: PUSH
31589: LD_INT 2
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 24
31598: PUSH
31599: LD_INT 750
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PPUSH
31610: CALL_OW 72
31614: AND
31615: PUSH
31616: LD_VAR 0 5
31620: PUSH
31621: LD_INT 5
31623: LESS
31624: AND
31625: IFFALSE 31707
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31627: LD_ADDR_VAR 0 3
31631: PUSH
31632: LD_EXP 50
31636: PUSH
31637: LD_VAR 0 2
31641: ARRAY
31642: PPUSH
31643: LD_INT 25
31645: PUSH
31646: LD_INT 2
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 24
31655: PUSH
31656: LD_INT 750
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PPUSH
31667: CALL_OW 72
31671: PUSH
31672: FOR_IN
31673: IFFALSE 31705
// begin tmp := tmp union j ;
31675: LD_ADDR_VAR 0 5
31679: PUSH
31680: LD_VAR 0 5
31684: PUSH
31685: LD_VAR 0 3
31689: UNION
31690: ST_TO_ADDR
// if tmp >= 5 then
31691: LD_VAR 0 5
31695: PUSH
31696: LD_INT 5
31698: GREATEREQUAL
31699: IFFALSE 31703
// break ;
31701: GO 31705
// end ;
31703: GO 31672
31705: POP
31706: POP
// end ; if not tmp then
31707: LD_VAR 0 5
31711: NOT
31712: IFFALSE 31716
// continue ;
31714: GO 30928
// for j in tmp do
31716: LD_ADDR_VAR 0 3
31720: PUSH
31721: LD_VAR 0 5
31725: PUSH
31726: FOR_IN
31727: IFFALSE 31817
// if not GetTag ( j ) then
31729: LD_VAR 0 3
31733: PPUSH
31734: CALL_OW 110
31738: NOT
31739: IFFALSE 31815
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31741: LD_ADDR_EXP 67
31745: PUSH
31746: LD_EXP 67
31750: PPUSH
31751: LD_VAR 0 2
31755: PUSH
31756: LD_EXP 67
31760: PUSH
31761: LD_VAR 0 2
31765: ARRAY
31766: PUSH
31767: LD_INT 1
31769: PLUS
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PPUSH
31775: LD_VAR 0 3
31779: PPUSH
31780: CALL 52825 0 3
31784: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31785: LD_VAR 0 3
31789: PPUSH
31790: LD_INT 107
31792: PPUSH
31793: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31797: LD_EXP 67
31801: PUSH
31802: LD_VAR 0 2
31806: ARRAY
31807: PUSH
31808: LD_INT 5
31810: GREATEREQUAL
31811: IFFALSE 31815
// break ;
31813: GO 31817
// end ;
31815: GO 31726
31817: POP
31818: POP
// end ; if mc_crates_collector [ i ] and target then
31819: LD_EXP 67
31823: PUSH
31824: LD_VAR 0 2
31828: ARRAY
31829: PUSH
31830: LD_VAR 0 6
31834: AND
31835: IFFALSE 32078
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31837: LD_EXP 67
31841: PUSH
31842: LD_VAR 0 2
31846: ARRAY
31847: PUSH
31848: LD_VAR 0 6
31852: PUSH
31853: LD_INT 1
31855: ARRAY
31856: LESS
31857: IFFALSE 31877
// tmp := mc_crates_collector [ i ] else
31859: LD_ADDR_VAR 0 5
31863: PUSH
31864: LD_EXP 67
31868: PUSH
31869: LD_VAR 0 2
31873: ARRAY
31874: ST_TO_ADDR
31875: GO 31891
// tmp := target [ 1 ] ;
31877: LD_ADDR_VAR 0 5
31881: PUSH
31882: LD_VAR 0 6
31886: PUSH
31887: LD_INT 1
31889: ARRAY
31890: ST_TO_ADDR
// k := 0 ;
31891: LD_ADDR_VAR 0 4
31895: PUSH
31896: LD_INT 0
31898: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31899: LD_ADDR_VAR 0 3
31903: PUSH
31904: LD_EXP 67
31908: PUSH
31909: LD_VAR 0 2
31913: ARRAY
31914: PUSH
31915: FOR_IN
31916: IFFALSE 32076
// begin k := k + 1 ;
31918: LD_ADDR_VAR 0 4
31922: PUSH
31923: LD_VAR 0 4
31927: PUSH
31928: LD_INT 1
31930: PLUS
31931: ST_TO_ADDR
// if k > tmp then
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 5
31941: GREATER
31942: IFFALSE 31946
// break ;
31944: GO 32076
// if not GetClass ( j ) in [ 2 , 16 ] then
31946: LD_VAR 0 3
31950: PPUSH
31951: CALL_OW 257
31955: PUSH
31956: LD_INT 2
31958: PUSH
31959: LD_INT 16
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: IN
31966: NOT
31967: IFFALSE 32020
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31969: LD_ADDR_EXP 67
31973: PUSH
31974: LD_EXP 67
31978: PPUSH
31979: LD_VAR 0 2
31983: PPUSH
31984: LD_EXP 67
31988: PUSH
31989: LD_VAR 0 2
31993: ARRAY
31994: PUSH
31995: LD_VAR 0 3
31999: DIFF
32000: PPUSH
32001: CALL_OW 1
32005: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32006: LD_VAR 0 3
32010: PPUSH
32011: LD_INT 0
32013: PPUSH
32014: CALL_OW 109
// continue ;
32018: GO 31915
// end ; if IsInUnit ( j ) then
32020: LD_VAR 0 3
32024: PPUSH
32025: CALL_OW 310
32029: IFFALSE 32040
// ComExitBuilding ( j ) ;
32031: LD_VAR 0 3
32035: PPUSH
32036: CALL_OW 122
// wait ( 3 ) ;
32040: LD_INT 3
32042: PPUSH
32043: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32047: LD_VAR 0 3
32051: PPUSH
32052: LD_VAR 0 6
32056: PUSH
32057: LD_INT 2
32059: ARRAY
32060: PPUSH
32061: LD_VAR 0 6
32065: PUSH
32066: LD_INT 3
32068: ARRAY
32069: PPUSH
32070: CALL_OW 117
// end ;
32074: GO 31915
32076: POP
32077: POP
// end ; end else
32078: GO 32659
// begin for j in cargo do
32080: LD_ADDR_VAR 0 3
32084: PUSH
32085: LD_VAR 0 7
32089: PUSH
32090: FOR_IN
32091: IFFALSE 32657
// begin if GetTag ( j ) <> 0 then
32093: LD_VAR 0 3
32097: PPUSH
32098: CALL_OW 110
32102: PUSH
32103: LD_INT 0
32105: NONEQUAL
32106: IFFALSE 32110
// continue ;
32108: GO 32090
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32110: LD_VAR 0 3
32114: PPUSH
32115: CALL_OW 256
32119: PUSH
32120: LD_INT 1000
32122: LESS
32123: PUSH
32124: LD_VAR 0 3
32128: PPUSH
32129: LD_EXP 74
32133: PUSH
32134: LD_VAR 0 2
32138: ARRAY
32139: PPUSH
32140: CALL_OW 308
32144: NOT
32145: AND
32146: IFFALSE 32168
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32148: LD_VAR 0 3
32152: PPUSH
32153: LD_EXP 74
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: PPUSH
32164: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32168: LD_VAR 0 3
32172: PPUSH
32173: CALL_OW 256
32177: PUSH
32178: LD_INT 1000
32180: LESS
32181: PUSH
32182: LD_VAR 0 3
32186: PPUSH
32187: LD_EXP 74
32191: PUSH
32192: LD_VAR 0 2
32196: ARRAY
32197: PPUSH
32198: CALL_OW 308
32202: AND
32203: IFFALSE 32207
// continue ;
32205: GO 32090
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32207: LD_VAR 0 3
32211: PPUSH
32212: CALL_OW 262
32216: PUSH
32217: LD_INT 2
32219: EQUAL
32220: PUSH
32221: LD_VAR 0 3
32225: PPUSH
32226: CALL_OW 261
32230: PUSH
32231: LD_INT 15
32233: LESS
32234: AND
32235: IFFALSE 32239
// continue ;
32237: GO 32090
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32239: LD_VAR 0 3
32243: PPUSH
32244: CALL_OW 262
32248: PUSH
32249: LD_INT 1
32251: EQUAL
32252: PUSH
32253: LD_VAR 0 3
32257: PPUSH
32258: CALL_OW 261
32262: PUSH
32263: LD_INT 10
32265: LESS
32266: AND
32267: IFFALSE 32596
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32269: LD_ADDR_VAR 0 8
32273: PUSH
32274: LD_EXP 50
32278: PUSH
32279: LD_VAR 0 2
32283: ARRAY
32284: PPUSH
32285: LD_INT 2
32287: PUSH
32288: LD_INT 30
32290: PUSH
32291: LD_INT 0
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: LD_INT 30
32300: PUSH
32301: LD_INT 1
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: LIST
32312: PPUSH
32313: CALL_OW 72
32317: ST_TO_ADDR
// if not depot then
32318: LD_VAR 0 8
32322: NOT
32323: IFFALSE 32327
// continue ;
32325: GO 32090
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32327: LD_VAR 0 3
32331: PPUSH
32332: LD_VAR 0 8
32336: PPUSH
32337: LD_VAR 0 3
32341: PPUSH
32342: CALL_OW 74
32346: PPUSH
32347: CALL_OW 296
32351: PUSH
32352: LD_INT 6
32354: LESS
32355: IFFALSE 32371
// SetFuel ( j , 100 ) else
32357: LD_VAR 0 3
32361: PPUSH
32362: LD_INT 100
32364: PPUSH
32365: CALL_OW 240
32369: GO 32596
// if GetFuel ( j ) = 0 then
32371: LD_VAR 0 3
32375: PPUSH
32376: CALL_OW 261
32380: PUSH
32381: LD_INT 0
32383: EQUAL
32384: IFFALSE 32596
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32386: LD_ADDR_EXP 69
32390: PUSH
32391: LD_EXP 69
32395: PPUSH
32396: LD_VAR 0 2
32400: PPUSH
32401: LD_EXP 69
32405: PUSH
32406: LD_VAR 0 2
32410: ARRAY
32411: PUSH
32412: LD_VAR 0 3
32416: DIFF
32417: PPUSH
32418: CALL_OW 1
32422: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32423: LD_VAR 0 3
32427: PPUSH
32428: CALL_OW 263
32432: PUSH
32433: LD_INT 1
32435: EQUAL
32436: IFFALSE 32452
// ComExitVehicle ( IsInUnit ( j ) ) ;
32438: LD_VAR 0 3
32442: PPUSH
32443: CALL_OW 310
32447: PPUSH
32448: CALL_OW 121
// if GetControl ( j ) = control_remote then
32452: LD_VAR 0 3
32456: PPUSH
32457: CALL_OW 263
32461: PUSH
32462: LD_INT 2
32464: EQUAL
32465: IFFALSE 32476
// ComUnlink ( j ) ;
32467: LD_VAR 0 3
32471: PPUSH
32472: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32476: LD_ADDR_VAR 0 9
32480: PUSH
32481: LD_VAR 0 2
32485: PPUSH
32486: LD_INT 3
32488: PPUSH
32489: CALL 41971 0 2
32493: ST_TO_ADDR
// if fac then
32494: LD_VAR 0 9
32498: IFFALSE 32594
// begin for k in fac do
32500: LD_ADDR_VAR 0 4
32504: PUSH
32505: LD_VAR 0 9
32509: PUSH
32510: FOR_IN
32511: IFFALSE 32592
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32513: LD_ADDR_VAR 0 10
32517: PUSH
32518: LD_VAR 0 9
32522: PPUSH
32523: LD_VAR 0 3
32527: PPUSH
32528: CALL_OW 265
32532: PPUSH
32533: LD_VAR 0 3
32537: PPUSH
32538: CALL_OW 262
32542: PPUSH
32543: LD_VAR 0 3
32547: PPUSH
32548: CALL_OW 263
32552: PPUSH
32553: LD_VAR 0 3
32557: PPUSH
32558: CALL_OW 264
32562: PPUSH
32563: CALL 50357 0 5
32567: ST_TO_ADDR
// if components then
32568: LD_VAR 0 10
32572: IFFALSE 32590
// begin MC_InsertProduceList ( i , components ) ;
32574: LD_VAR 0 2
32578: PPUSH
32579: LD_VAR 0 10
32583: PPUSH
32584: CALL 41516 0 2
// break ;
32588: GO 32592
// end ; end ;
32590: GO 32510
32592: POP
32593: POP
// end ; continue ;
32594: GO 32090
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32596: LD_VAR 0 3
32600: PPUSH
32601: LD_INT 1
32603: PPUSH
32604: CALL_OW 289
32608: PUSH
32609: LD_INT 100
32611: LESS
32612: PUSH
32613: LD_VAR 0 3
32617: PPUSH
32618: CALL_OW 314
32622: NOT
32623: AND
32624: IFFALSE 32653
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32626: LD_VAR 0 3
32630: PPUSH
32631: LD_VAR 0 6
32635: PUSH
32636: LD_INT 2
32638: ARRAY
32639: PPUSH
32640: LD_VAR 0 6
32644: PUSH
32645: LD_INT 3
32647: ARRAY
32648: PPUSH
32649: CALL_OW 117
// break ;
32653: GO 32657
// end ;
32655: GO 32090
32657: POP
32658: POP
// end ; end ;
32659: GO 30928
32661: POP
32662: POP
// end ;
32663: LD_VAR 0 1
32667: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32668: LD_INT 0
32670: PPUSH
32671: PPUSH
32672: PPUSH
32673: PPUSH
// if not mc_bases then
32674: LD_EXP 50
32678: NOT
32679: IFFALSE 32683
// exit ;
32681: GO 32844
// for i = 1 to mc_bases do
32683: LD_ADDR_VAR 0 2
32687: PUSH
32688: DOUBLE
32689: LD_INT 1
32691: DEC
32692: ST_TO_ADDR
32693: LD_EXP 50
32697: PUSH
32698: FOR_TO
32699: IFFALSE 32842
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32701: LD_ADDR_VAR 0 4
32705: PUSH
32706: LD_EXP 69
32710: PUSH
32711: LD_VAR 0 2
32715: ARRAY
32716: PUSH
32717: LD_EXP 72
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: UNION
32728: PPUSH
32729: LD_INT 33
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PPUSH
32739: CALL_OW 72
32743: ST_TO_ADDR
// if tmp then
32744: LD_VAR 0 4
32748: IFFALSE 32840
// for j in tmp do
32750: LD_ADDR_VAR 0 3
32754: PUSH
32755: LD_VAR 0 4
32759: PUSH
32760: FOR_IN
32761: IFFALSE 32838
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32763: LD_VAR 0 3
32767: PPUSH
32768: CALL_OW 312
32772: NOT
32773: PUSH
32774: LD_VAR 0 3
32778: PPUSH
32779: CALL_OW 256
32783: PUSH
32784: LD_INT 250
32786: GREATEREQUAL
32787: AND
32788: IFFALSE 32801
// Connect ( j ) else
32790: LD_VAR 0 3
32794: PPUSH
32795: CALL 55758 0 1
32799: GO 32836
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32801: LD_VAR 0 3
32805: PPUSH
32806: CALL_OW 256
32810: PUSH
32811: LD_INT 250
32813: LESS
32814: PUSH
32815: LD_VAR 0 3
32819: PPUSH
32820: CALL_OW 312
32824: AND
32825: IFFALSE 32836
// ComUnlink ( j ) ;
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL_OW 136
32836: GO 32760
32838: POP
32839: POP
// end ;
32840: GO 32698
32842: POP
32843: POP
// end ;
32844: LD_VAR 0 1
32848: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32849: LD_INT 0
32851: PPUSH
32852: PPUSH
32853: PPUSH
32854: PPUSH
32855: PPUSH
// if not mc_bases then
32856: LD_EXP 50
32860: NOT
32861: IFFALSE 32865
// exit ;
32863: GO 33310
// for i = 1 to mc_bases do
32865: LD_ADDR_VAR 0 2
32869: PUSH
32870: DOUBLE
32871: LD_INT 1
32873: DEC
32874: ST_TO_ADDR
32875: LD_EXP 50
32879: PUSH
32880: FOR_TO
32881: IFFALSE 33308
// begin if not mc_produce [ i ] then
32883: LD_EXP 71
32887: PUSH
32888: LD_VAR 0 2
32892: ARRAY
32893: NOT
32894: IFFALSE 32898
// continue ;
32896: GO 32880
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32898: LD_ADDR_VAR 0 5
32902: PUSH
32903: LD_EXP 50
32907: PUSH
32908: LD_VAR 0 2
32912: ARRAY
32913: PPUSH
32914: LD_INT 30
32916: PUSH
32917: LD_INT 3
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PPUSH
32924: CALL_OW 72
32928: ST_TO_ADDR
// if not fac then
32929: LD_VAR 0 5
32933: NOT
32934: IFFALSE 32938
// continue ;
32936: GO 32880
// for j in fac do
32938: LD_ADDR_VAR 0 3
32942: PUSH
32943: LD_VAR 0 5
32947: PUSH
32948: FOR_IN
32949: IFFALSE 33304
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32951: LD_VAR 0 3
32955: PPUSH
32956: CALL_OW 461
32960: PUSH
32961: LD_INT 2
32963: NONEQUAL
32964: PUSH
32965: LD_VAR 0 3
32969: PPUSH
32970: LD_INT 15
32972: PPUSH
32973: CALL 55418 0 2
32977: PUSH
32978: LD_INT 4
32980: ARRAY
32981: OR
32982: IFFALSE 32986
// continue ;
32984: GO 32948
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32986: LD_VAR 0 3
32990: PPUSH
32991: LD_EXP 71
32995: PUSH
32996: LD_VAR 0 2
33000: ARRAY
33001: PUSH
33002: LD_INT 1
33004: ARRAY
33005: PUSH
33006: LD_INT 1
33008: ARRAY
33009: PPUSH
33010: LD_EXP 71
33014: PUSH
33015: LD_VAR 0 2
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PUSH
33025: LD_INT 2
33027: ARRAY
33028: PPUSH
33029: LD_EXP 71
33033: PUSH
33034: LD_VAR 0 2
33038: ARRAY
33039: PUSH
33040: LD_INT 1
33042: ARRAY
33043: PUSH
33044: LD_INT 3
33046: ARRAY
33047: PPUSH
33048: LD_EXP 71
33052: PUSH
33053: LD_VAR 0 2
33057: ARRAY
33058: PUSH
33059: LD_INT 1
33061: ARRAY
33062: PUSH
33063: LD_INT 4
33065: ARRAY
33066: PPUSH
33067: CALL_OW 448
33071: PUSH
33072: LD_VAR 0 3
33076: PPUSH
33077: LD_EXP 71
33081: PUSH
33082: LD_VAR 0 2
33086: ARRAY
33087: PUSH
33088: LD_INT 1
33090: ARRAY
33091: PUSH
33092: LD_INT 1
33094: ARRAY
33095: PUSH
33096: LD_EXP 71
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PUSH
33107: LD_INT 1
33109: ARRAY
33110: PUSH
33111: LD_INT 2
33113: ARRAY
33114: PUSH
33115: LD_EXP 71
33119: PUSH
33120: LD_VAR 0 2
33124: ARRAY
33125: PUSH
33126: LD_INT 1
33128: ARRAY
33129: PUSH
33130: LD_INT 3
33132: ARRAY
33133: PUSH
33134: LD_EXP 71
33138: PUSH
33139: LD_VAR 0 2
33143: ARRAY
33144: PUSH
33145: LD_INT 1
33147: ARRAY
33148: PUSH
33149: LD_INT 4
33151: ARRAY
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: PPUSH
33159: CALL 59089 0 2
33163: AND
33164: IFFALSE 33302
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33166: LD_VAR 0 3
33170: PPUSH
33171: LD_EXP 71
33175: PUSH
33176: LD_VAR 0 2
33180: ARRAY
33181: PUSH
33182: LD_INT 1
33184: ARRAY
33185: PUSH
33186: LD_INT 1
33188: ARRAY
33189: PPUSH
33190: LD_EXP 71
33194: PUSH
33195: LD_VAR 0 2
33199: ARRAY
33200: PUSH
33201: LD_INT 1
33203: ARRAY
33204: PUSH
33205: LD_INT 2
33207: ARRAY
33208: PPUSH
33209: LD_EXP 71
33213: PUSH
33214: LD_VAR 0 2
33218: ARRAY
33219: PUSH
33220: LD_INT 1
33222: ARRAY
33223: PUSH
33224: LD_INT 3
33226: ARRAY
33227: PPUSH
33228: LD_EXP 71
33232: PUSH
33233: LD_VAR 0 2
33237: ARRAY
33238: PUSH
33239: LD_INT 1
33241: ARRAY
33242: PUSH
33243: LD_INT 4
33245: ARRAY
33246: PPUSH
33247: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33251: LD_ADDR_VAR 0 4
33255: PUSH
33256: LD_EXP 71
33260: PUSH
33261: LD_VAR 0 2
33265: ARRAY
33266: PPUSH
33267: LD_INT 1
33269: PPUSH
33270: CALL_OW 3
33274: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33275: LD_ADDR_EXP 71
33279: PUSH
33280: LD_EXP 71
33284: PPUSH
33285: LD_VAR 0 2
33289: PPUSH
33290: LD_VAR 0 4
33294: PPUSH
33295: CALL_OW 1
33299: ST_TO_ADDR
// break ;
33300: GO 33304
// end ; end ;
33302: GO 32948
33304: POP
33305: POP
// end ;
33306: GO 32880
33308: POP
33309: POP
// end ;
33310: LD_VAR 0 1
33314: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33315: LD_INT 0
33317: PPUSH
33318: PPUSH
33319: PPUSH
// if not mc_bases then
33320: LD_EXP 50
33324: NOT
33325: IFFALSE 33329
// exit ;
33327: GO 33418
// for i = 1 to mc_bases do
33329: LD_ADDR_VAR 0 2
33333: PUSH
33334: DOUBLE
33335: LD_INT 1
33337: DEC
33338: ST_TO_ADDR
33339: LD_EXP 50
33343: PUSH
33344: FOR_TO
33345: IFFALSE 33416
// begin if mc_attack [ i ] then
33347: LD_EXP 70
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: IFFALSE 33414
// begin tmp := mc_attack [ i ] [ 1 ] ;
33359: LD_ADDR_VAR 0 3
33363: PUSH
33364: LD_EXP 70
33368: PUSH
33369: LD_VAR 0 2
33373: ARRAY
33374: PUSH
33375: LD_INT 1
33377: ARRAY
33378: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33379: LD_ADDR_EXP 70
33383: PUSH
33384: LD_EXP 70
33388: PPUSH
33389: LD_VAR 0 2
33393: PPUSH
33394: EMPTY
33395: PPUSH
33396: CALL_OW 1
33400: ST_TO_ADDR
// Attack ( tmp ) ;
33401: LD_VAR 0 3
33405: PPUSH
33406: CALL 102248 0 1
// exit ;
33410: POP
33411: POP
33412: GO 33418
// end ; end ;
33414: GO 33344
33416: POP
33417: POP
// end ;
33418: LD_VAR 0 1
33422: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33423: LD_INT 0
33425: PPUSH
33426: PPUSH
33427: PPUSH
33428: PPUSH
33429: PPUSH
33430: PPUSH
33431: PPUSH
// if not mc_bases then
33432: LD_EXP 50
33436: NOT
33437: IFFALSE 33441
// exit ;
33439: GO 34045
// for i = 1 to mc_bases do
33441: LD_ADDR_VAR 0 2
33445: PUSH
33446: DOUBLE
33447: LD_INT 1
33449: DEC
33450: ST_TO_ADDR
33451: LD_EXP 50
33455: PUSH
33456: FOR_TO
33457: IFFALSE 34043
// begin if not mc_bases [ i ] then
33459: LD_EXP 50
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: NOT
33470: IFFALSE 33474
// continue ;
33472: GO 33456
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33474: LD_ADDR_VAR 0 7
33478: PUSH
33479: LD_EXP 50
33483: PUSH
33484: LD_VAR 0 2
33488: ARRAY
33489: PUSH
33490: LD_INT 1
33492: ARRAY
33493: PPUSH
33494: CALL 49661 0 1
33498: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33499: LD_ADDR_EXP 73
33503: PUSH
33504: LD_EXP 73
33508: PPUSH
33509: LD_VAR 0 2
33513: PPUSH
33514: LD_EXP 50
33518: PUSH
33519: LD_VAR 0 2
33523: ARRAY
33524: PUSH
33525: LD_INT 1
33527: ARRAY
33528: PPUSH
33529: CALL_OW 255
33533: PPUSH
33534: LD_EXP 75
33538: PUSH
33539: LD_VAR 0 2
33543: ARRAY
33544: PPUSH
33545: CALL 49626 0 2
33549: PPUSH
33550: CALL_OW 1
33554: ST_TO_ADDR
// if not mc_scan [ i ] then
33555: LD_EXP 73
33559: PUSH
33560: LD_VAR 0 2
33564: ARRAY
33565: NOT
33566: IFFALSE 33721
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33568: LD_ADDR_VAR 0 4
33572: PUSH
33573: LD_EXP 50
33577: PUSH
33578: LD_VAR 0 2
33582: ARRAY
33583: PPUSH
33584: LD_INT 2
33586: PUSH
33587: LD_INT 25
33589: PUSH
33590: LD_INT 5
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 25
33599: PUSH
33600: LD_INT 8
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 25
33609: PUSH
33610: LD_INT 9
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: PPUSH
33623: CALL_OW 72
33627: ST_TO_ADDR
// if not tmp then
33628: LD_VAR 0 4
33632: NOT
33633: IFFALSE 33637
// continue ;
33635: GO 33456
// for j in tmp do
33637: LD_ADDR_VAR 0 3
33641: PUSH
33642: LD_VAR 0 4
33646: PUSH
33647: FOR_IN
33648: IFFALSE 33719
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33650: LD_VAR 0 3
33654: PPUSH
33655: CALL_OW 310
33659: PPUSH
33660: CALL_OW 266
33664: PUSH
33665: LD_INT 5
33667: EQUAL
33668: PUSH
33669: LD_VAR 0 3
33673: PPUSH
33674: CALL_OW 257
33678: PUSH
33679: LD_INT 1
33681: EQUAL
33682: AND
33683: PUSH
33684: LD_VAR 0 3
33688: PPUSH
33689: CALL_OW 459
33693: NOT
33694: AND
33695: PUSH
33696: LD_VAR 0 7
33700: AND
33701: IFFALSE 33717
// ComChangeProfession ( j , class ) ;
33703: LD_VAR 0 3
33707: PPUSH
33708: LD_VAR 0 7
33712: PPUSH
33713: CALL_OW 123
33717: GO 33647
33719: POP
33720: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33721: LD_EXP 73
33725: PUSH
33726: LD_VAR 0 2
33730: ARRAY
33731: PUSH
33732: LD_EXP 72
33736: PUSH
33737: LD_VAR 0 2
33741: ARRAY
33742: NOT
33743: AND
33744: PUSH
33745: LD_EXP 50
33749: PUSH
33750: LD_VAR 0 2
33754: ARRAY
33755: PPUSH
33756: LD_INT 30
33758: PUSH
33759: LD_INT 32
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PPUSH
33766: CALL_OW 72
33770: NOT
33771: AND
33772: PUSH
33773: LD_EXP 50
33777: PUSH
33778: LD_VAR 0 2
33782: ARRAY
33783: PPUSH
33784: LD_INT 2
33786: PUSH
33787: LD_INT 30
33789: PUSH
33790: LD_INT 4
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 30
33799: PUSH
33800: LD_INT 5
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: LIST
33811: PPUSH
33812: CALL_OW 72
33816: NOT
33817: AND
33818: IFFALSE 33950
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33820: LD_ADDR_VAR 0 4
33824: PUSH
33825: LD_EXP 50
33829: PUSH
33830: LD_VAR 0 2
33834: ARRAY
33835: PPUSH
33836: LD_INT 2
33838: PUSH
33839: LD_INT 25
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 25
33851: PUSH
33852: LD_INT 5
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 25
33861: PUSH
33862: LD_INT 8
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 25
33871: PUSH
33872: LD_INT 9
33874: PUSH
33875: EMPTY
33876: LIST
33877: LIST
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: PPUSH
33886: CALL_OW 72
33890: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33891: LD_ADDR_VAR 0 4
33895: PUSH
33896: LD_VAR 0 4
33900: PUSH
33901: LD_VAR 0 4
33905: PPUSH
33906: LD_INT 18
33908: PPUSH
33909: CALL 81386 0 2
33913: DIFF
33914: ST_TO_ADDR
// if tmp then
33915: LD_VAR 0 4
33919: IFFALSE 33950
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33921: LD_VAR 0 2
33925: PPUSH
33926: LD_VAR 0 4
33930: PPUSH
33931: LD_EXP 75
33935: PUSH
33936: LD_VAR 0 2
33940: ARRAY
33941: PPUSH
33942: CALL 106957 0 3
// exit ;
33946: POP
33947: POP
33948: GO 34045
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33950: LD_EXP 73
33954: PUSH
33955: LD_VAR 0 2
33959: ARRAY
33960: PUSH
33961: LD_EXP 72
33965: PUSH
33966: LD_VAR 0 2
33970: ARRAY
33971: AND
33972: IFFALSE 34041
// begin tmp := mc_defender [ i ] ;
33974: LD_ADDR_VAR 0 4
33978: PUSH
33979: LD_EXP 72
33983: PUSH
33984: LD_VAR 0 2
33988: ARRAY
33989: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
33990: LD_ADDR_EXP 72
33994: PUSH
33995: LD_EXP 72
33999: PPUSH
34000: LD_VAR 0 2
34004: PPUSH
34005: EMPTY
34006: PPUSH
34007: CALL_OW 1
34011: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
34012: LD_VAR 0 2
34016: PPUSH
34017: LD_VAR 0 4
34021: PPUSH
34022: LD_EXP 73
34026: PUSH
34027: LD_VAR 0 2
34031: ARRAY
34032: PPUSH
34033: CALL 107518 0 3
// exit ;
34037: POP
34038: POP
34039: GO 34045
// end ; end ;
34041: GO 33456
34043: POP
34044: POP
// end ;
34045: LD_VAR 0 1
34049: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34050: LD_INT 0
34052: PPUSH
34053: PPUSH
34054: PPUSH
34055: PPUSH
34056: PPUSH
34057: PPUSH
34058: PPUSH
34059: PPUSH
34060: PPUSH
34061: PPUSH
34062: PPUSH
// if not mc_bases then
34063: LD_EXP 50
34067: NOT
34068: IFFALSE 34072
// exit ;
34070: GO 35159
// for i = 1 to mc_bases do
34072: LD_ADDR_VAR 0 2
34076: PUSH
34077: DOUBLE
34078: LD_INT 1
34080: DEC
34081: ST_TO_ADDR
34082: LD_EXP 50
34086: PUSH
34087: FOR_TO
34088: IFFALSE 35157
// begin tmp := mc_lab [ i ] ;
34090: LD_ADDR_VAR 0 6
34094: PUSH
34095: LD_EXP 83
34099: PUSH
34100: LD_VAR 0 2
34104: ARRAY
34105: ST_TO_ADDR
// if not tmp then
34106: LD_VAR 0 6
34110: NOT
34111: IFFALSE 34115
// continue ;
34113: GO 34087
// idle_lab := 0 ;
34115: LD_ADDR_VAR 0 11
34119: PUSH
34120: LD_INT 0
34122: ST_TO_ADDR
// for j in tmp do
34123: LD_ADDR_VAR 0 3
34127: PUSH
34128: LD_VAR 0 6
34132: PUSH
34133: FOR_IN
34134: IFFALSE 35153
// begin researching := false ;
34136: LD_ADDR_VAR 0 10
34140: PUSH
34141: LD_INT 0
34143: ST_TO_ADDR
// side := GetSide ( j ) ;
34144: LD_ADDR_VAR 0 4
34148: PUSH
34149: LD_VAR 0 3
34153: PPUSH
34154: CALL_OW 255
34158: ST_TO_ADDR
// if not mc_tech [ side ] then
34159: LD_EXP 77
34163: PUSH
34164: LD_VAR 0 4
34168: ARRAY
34169: NOT
34170: IFFALSE 34174
// continue ;
34172: GO 34133
// if BuildingStatus ( j ) = bs_idle then
34174: LD_VAR 0 3
34178: PPUSH
34179: CALL_OW 461
34183: PUSH
34184: LD_INT 2
34186: EQUAL
34187: IFFALSE 34375
// begin if idle_lab and UnitsInside ( j ) < 6 then
34189: LD_VAR 0 11
34193: PUSH
34194: LD_VAR 0 3
34198: PPUSH
34199: CALL_OW 313
34203: PUSH
34204: LD_INT 6
34206: LESS
34207: AND
34208: IFFALSE 34279
// begin tmp2 := UnitsInside ( idle_lab ) ;
34210: LD_ADDR_VAR 0 9
34214: PUSH
34215: LD_VAR 0 11
34219: PPUSH
34220: CALL_OW 313
34224: ST_TO_ADDR
// if tmp2 then
34225: LD_VAR 0 9
34229: IFFALSE 34271
// for x in tmp2 do
34231: LD_ADDR_VAR 0 7
34235: PUSH
34236: LD_VAR 0 9
34240: PUSH
34241: FOR_IN
34242: IFFALSE 34269
// begin ComExitBuilding ( x ) ;
34244: LD_VAR 0 7
34248: PPUSH
34249: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34253: LD_VAR 0 7
34257: PPUSH
34258: LD_VAR 0 3
34262: PPUSH
34263: CALL_OW 180
// end ;
34267: GO 34241
34269: POP
34270: POP
// idle_lab := 0 ;
34271: LD_ADDR_VAR 0 11
34275: PUSH
34276: LD_INT 0
34278: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34279: LD_ADDR_VAR 0 5
34283: PUSH
34284: LD_EXP 77
34288: PUSH
34289: LD_VAR 0 4
34293: ARRAY
34294: PUSH
34295: FOR_IN
34296: IFFALSE 34356
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34298: LD_VAR 0 3
34302: PPUSH
34303: LD_VAR 0 5
34307: PPUSH
34308: CALL_OW 430
34312: PUSH
34313: LD_VAR 0 4
34317: PPUSH
34318: LD_VAR 0 5
34322: PPUSH
34323: CALL 48731 0 2
34327: AND
34328: IFFALSE 34354
// begin researching := true ;
34330: LD_ADDR_VAR 0 10
34334: PUSH
34335: LD_INT 1
34337: ST_TO_ADDR
// ComResearch ( j , t ) ;
34338: LD_VAR 0 3
34342: PPUSH
34343: LD_VAR 0 5
34347: PPUSH
34348: CALL_OW 124
// break ;
34352: GO 34356
// end ;
34354: GO 34295
34356: POP
34357: POP
// if not researching then
34358: LD_VAR 0 10
34362: NOT
34363: IFFALSE 34375
// idle_lab := j ;
34365: LD_ADDR_VAR 0 11
34369: PUSH
34370: LD_VAR 0 3
34374: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34375: LD_VAR 0 3
34379: PPUSH
34380: CALL_OW 461
34384: PUSH
34385: LD_INT 10
34387: EQUAL
34388: IFFALSE 34976
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34390: LD_EXP 79
34394: PUSH
34395: LD_VAR 0 2
34399: ARRAY
34400: NOT
34401: PUSH
34402: LD_EXP 80
34406: PUSH
34407: LD_VAR 0 2
34411: ARRAY
34412: NOT
34413: AND
34414: PUSH
34415: LD_EXP 77
34419: PUSH
34420: LD_VAR 0 4
34424: ARRAY
34425: PUSH
34426: LD_INT 1
34428: GREATER
34429: AND
34430: IFFALSE 34561
// begin ComCancel ( j ) ;
34432: LD_VAR 0 3
34436: PPUSH
34437: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34441: LD_ADDR_EXP 77
34445: PUSH
34446: LD_EXP 77
34450: PPUSH
34451: LD_VAR 0 4
34455: PPUSH
34456: LD_EXP 77
34460: PUSH
34461: LD_VAR 0 4
34465: ARRAY
34466: PPUSH
34467: LD_EXP 77
34471: PUSH
34472: LD_VAR 0 4
34476: ARRAY
34477: PUSH
34478: LD_INT 1
34480: MINUS
34481: PPUSH
34482: LD_EXP 77
34486: PUSH
34487: LD_VAR 0 4
34491: ARRAY
34492: PPUSH
34493: LD_INT 0
34495: PPUSH
34496: CALL 52243 0 4
34500: PPUSH
34501: CALL_OW 1
34505: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34506: LD_ADDR_EXP 77
34510: PUSH
34511: LD_EXP 77
34515: PPUSH
34516: LD_VAR 0 4
34520: PPUSH
34521: LD_EXP 77
34525: PUSH
34526: LD_VAR 0 4
34530: ARRAY
34531: PPUSH
34532: LD_EXP 77
34536: PUSH
34537: LD_VAR 0 4
34541: ARRAY
34542: PPUSH
34543: LD_INT 1
34545: PPUSH
34546: LD_INT 0
34548: PPUSH
34549: CALL 52243 0 4
34553: PPUSH
34554: CALL_OW 1
34558: ST_TO_ADDR
// continue ;
34559: GO 34133
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34561: LD_EXP 79
34565: PUSH
34566: LD_VAR 0 2
34570: ARRAY
34571: PUSH
34572: LD_EXP 80
34576: PUSH
34577: LD_VAR 0 2
34581: ARRAY
34582: NOT
34583: AND
34584: IFFALSE 34711
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34586: LD_ADDR_EXP 80
34590: PUSH
34591: LD_EXP 80
34595: PPUSH
34596: LD_VAR 0 2
34600: PUSH
34601: LD_EXP 80
34605: PUSH
34606: LD_VAR 0 2
34610: ARRAY
34611: PUSH
34612: LD_INT 1
34614: PLUS
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PPUSH
34620: LD_EXP 79
34624: PUSH
34625: LD_VAR 0 2
34629: ARRAY
34630: PUSH
34631: LD_INT 1
34633: ARRAY
34634: PPUSH
34635: CALL 52825 0 3
34639: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34640: LD_EXP 79
34644: PUSH
34645: LD_VAR 0 2
34649: ARRAY
34650: PUSH
34651: LD_INT 1
34653: ARRAY
34654: PPUSH
34655: LD_INT 112
34657: PPUSH
34658: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34662: LD_ADDR_VAR 0 9
34666: PUSH
34667: LD_EXP 79
34671: PUSH
34672: LD_VAR 0 2
34676: ARRAY
34677: PPUSH
34678: LD_INT 1
34680: PPUSH
34681: CALL_OW 3
34685: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34686: LD_ADDR_EXP 79
34690: PUSH
34691: LD_EXP 79
34695: PPUSH
34696: LD_VAR 0 2
34700: PPUSH
34701: LD_VAR 0 9
34705: PPUSH
34706: CALL_OW 1
34710: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34711: LD_EXP 79
34715: PUSH
34716: LD_VAR 0 2
34720: ARRAY
34721: PUSH
34722: LD_EXP 80
34726: PUSH
34727: LD_VAR 0 2
34731: ARRAY
34732: AND
34733: PUSH
34734: LD_EXP 80
34738: PUSH
34739: LD_VAR 0 2
34743: ARRAY
34744: PUSH
34745: LD_INT 1
34747: ARRAY
34748: PPUSH
34749: CALL_OW 310
34753: NOT
34754: AND
34755: PUSH
34756: LD_VAR 0 3
34760: PPUSH
34761: CALL_OW 313
34765: PUSH
34766: LD_INT 6
34768: EQUAL
34769: AND
34770: IFFALSE 34826
// begin tmp2 := UnitsInside ( j ) ;
34772: LD_ADDR_VAR 0 9
34776: PUSH
34777: LD_VAR 0 3
34781: PPUSH
34782: CALL_OW 313
34786: ST_TO_ADDR
// if tmp2 = 6 then
34787: LD_VAR 0 9
34791: PUSH
34792: LD_INT 6
34794: EQUAL
34795: IFFALSE 34826
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34797: LD_VAR 0 9
34801: PUSH
34802: LD_INT 1
34804: ARRAY
34805: PPUSH
34806: LD_INT 112
34808: PPUSH
34809: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34813: LD_VAR 0 9
34817: PUSH
34818: LD_INT 1
34820: ARRAY
34821: PPUSH
34822: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34826: LD_EXP 80
34830: PUSH
34831: LD_VAR 0 2
34835: ARRAY
34836: PUSH
34837: LD_EXP 80
34841: PUSH
34842: LD_VAR 0 2
34846: ARRAY
34847: PUSH
34848: LD_INT 1
34850: ARRAY
34851: PPUSH
34852: CALL_OW 314
34856: NOT
34857: AND
34858: PUSH
34859: LD_EXP 80
34863: PUSH
34864: LD_VAR 0 2
34868: ARRAY
34869: PUSH
34870: LD_INT 1
34872: ARRAY
34873: PPUSH
34874: CALL_OW 310
34878: NOT
34879: AND
34880: IFFALSE 34906
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34882: LD_EXP 80
34886: PUSH
34887: LD_VAR 0 2
34891: ARRAY
34892: PUSH
34893: LD_INT 1
34895: ARRAY
34896: PPUSH
34897: LD_VAR 0 3
34901: PPUSH
34902: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34906: LD_EXP 80
34910: PUSH
34911: LD_VAR 0 2
34915: ARRAY
34916: PUSH
34917: LD_INT 1
34919: ARRAY
34920: PPUSH
34921: CALL_OW 310
34925: PUSH
34926: LD_EXP 80
34930: PUSH
34931: LD_VAR 0 2
34935: ARRAY
34936: PUSH
34937: LD_INT 1
34939: ARRAY
34940: PPUSH
34941: CALL_OW 310
34945: PPUSH
34946: CALL_OW 461
34950: PUSH
34951: LD_INT 3
34953: NONEQUAL
34954: AND
34955: IFFALSE 34976
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34957: LD_EXP 80
34961: PUSH
34962: LD_VAR 0 2
34966: ARRAY
34967: PUSH
34968: LD_INT 1
34970: ARRAY
34971: PPUSH
34972: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34976: LD_VAR 0 3
34980: PPUSH
34981: CALL_OW 461
34985: PUSH
34986: LD_INT 6
34988: EQUAL
34989: PUSH
34990: LD_VAR 0 6
34994: PUSH
34995: LD_INT 1
34997: GREATER
34998: AND
34999: IFFALSE 35151
// begin sci := [ ] ;
35001: LD_ADDR_VAR 0 8
35005: PUSH
35006: EMPTY
35007: ST_TO_ADDR
// for x in ( tmp diff j ) do
35008: LD_ADDR_VAR 0 7
35012: PUSH
35013: LD_VAR 0 6
35017: PUSH
35018: LD_VAR 0 3
35022: DIFF
35023: PUSH
35024: FOR_IN
35025: IFFALSE 35077
// begin if sci = 6 then
35027: LD_VAR 0 8
35031: PUSH
35032: LD_INT 6
35034: EQUAL
35035: IFFALSE 35039
// break ;
35037: GO 35077
// if BuildingStatus ( x ) = bs_idle then
35039: LD_VAR 0 7
35043: PPUSH
35044: CALL_OW 461
35048: PUSH
35049: LD_INT 2
35051: EQUAL
35052: IFFALSE 35075
// sci := sci ^ UnitsInside ( x ) ;
35054: LD_ADDR_VAR 0 8
35058: PUSH
35059: LD_VAR 0 8
35063: PUSH
35064: LD_VAR 0 7
35068: PPUSH
35069: CALL_OW 313
35073: ADD
35074: ST_TO_ADDR
// end ;
35075: GO 35024
35077: POP
35078: POP
// if not sci then
35079: LD_VAR 0 8
35083: NOT
35084: IFFALSE 35088
// continue ;
35086: GO 34133
// for x in sci do
35088: LD_ADDR_VAR 0 7
35092: PUSH
35093: LD_VAR 0 8
35097: PUSH
35098: FOR_IN
35099: IFFALSE 35149
// if IsInUnit ( x ) and not HasTask ( x ) then
35101: LD_VAR 0 7
35105: PPUSH
35106: CALL_OW 310
35110: PUSH
35111: LD_VAR 0 7
35115: PPUSH
35116: CALL_OW 314
35120: NOT
35121: AND
35122: IFFALSE 35147
// begin ComExitBuilding ( x ) ;
35124: LD_VAR 0 7
35128: PPUSH
35129: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35133: LD_VAR 0 7
35137: PPUSH
35138: LD_VAR 0 3
35142: PPUSH
35143: CALL_OW 180
// end ;
35147: GO 35098
35149: POP
35150: POP
// end ; end ;
35151: GO 34133
35153: POP
35154: POP
// end ;
35155: GO 34087
35157: POP
35158: POP
// end ;
35159: LD_VAR 0 1
35163: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35164: LD_INT 0
35166: PPUSH
35167: PPUSH
// if not mc_bases then
35168: LD_EXP 50
35172: NOT
35173: IFFALSE 35177
// exit ;
35175: GO 35258
// for i = 1 to mc_bases do
35177: LD_ADDR_VAR 0 2
35181: PUSH
35182: DOUBLE
35183: LD_INT 1
35185: DEC
35186: ST_TO_ADDR
35187: LD_EXP 50
35191: PUSH
35192: FOR_TO
35193: IFFALSE 35256
// if mc_mines [ i ] and mc_miners [ i ] then
35195: LD_EXP 63
35199: PUSH
35200: LD_VAR 0 2
35204: ARRAY
35205: PUSH
35206: LD_EXP 64
35210: PUSH
35211: LD_VAR 0 2
35215: ARRAY
35216: AND
35217: IFFALSE 35254
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35219: LD_EXP 64
35223: PUSH
35224: LD_VAR 0 2
35228: ARRAY
35229: PUSH
35230: LD_INT 1
35232: ARRAY
35233: PPUSH
35234: CALL_OW 255
35238: PPUSH
35239: LD_EXP 63
35243: PUSH
35244: LD_VAR 0 2
35248: ARRAY
35249: PPUSH
35250: CALL 49814 0 2
35254: GO 35192
35256: POP
35257: POP
// end ;
35258: LD_VAR 0 1
35262: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35263: LD_INT 0
35265: PPUSH
35266: PPUSH
35267: PPUSH
35268: PPUSH
35269: PPUSH
35270: PPUSH
35271: PPUSH
35272: PPUSH
// if not mc_bases or not mc_parking then
35273: LD_EXP 50
35277: NOT
35278: PUSH
35279: LD_EXP 74
35283: NOT
35284: OR
35285: IFFALSE 35289
// exit ;
35287: GO 35988
// for i = 1 to mc_bases do
35289: LD_ADDR_VAR 0 2
35293: PUSH
35294: DOUBLE
35295: LD_INT 1
35297: DEC
35298: ST_TO_ADDR
35299: LD_EXP 50
35303: PUSH
35304: FOR_TO
35305: IFFALSE 35986
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35307: LD_EXP 50
35311: PUSH
35312: LD_VAR 0 2
35316: ARRAY
35317: NOT
35318: PUSH
35319: LD_EXP 74
35323: PUSH
35324: LD_VAR 0 2
35328: ARRAY
35329: NOT
35330: OR
35331: IFFALSE 35335
// continue ;
35333: GO 35304
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35335: LD_ADDR_VAR 0 5
35339: PUSH
35340: LD_EXP 50
35344: PUSH
35345: LD_VAR 0 2
35349: ARRAY
35350: PUSH
35351: LD_INT 1
35353: ARRAY
35354: PPUSH
35355: CALL_OW 255
35359: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35360: LD_ADDR_VAR 0 6
35364: PUSH
35365: LD_EXP 50
35369: PUSH
35370: LD_VAR 0 2
35374: ARRAY
35375: PPUSH
35376: LD_INT 30
35378: PUSH
35379: LD_INT 3
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PPUSH
35386: CALL_OW 72
35390: ST_TO_ADDR
// if not fac then
35391: LD_VAR 0 6
35395: NOT
35396: IFFALSE 35447
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35398: LD_ADDR_VAR 0 6
35402: PUSH
35403: LD_EXP 50
35407: PUSH
35408: LD_VAR 0 2
35412: ARRAY
35413: PPUSH
35414: LD_INT 2
35416: PUSH
35417: LD_INT 30
35419: PUSH
35420: LD_INT 0
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 30
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: LIST
35441: PPUSH
35442: CALL_OW 72
35446: ST_TO_ADDR
// if not fac then
35447: LD_VAR 0 6
35451: NOT
35452: IFFALSE 35456
// continue ;
35454: GO 35304
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35456: LD_ADDR_VAR 0 7
35460: PUSH
35461: LD_EXP 74
35465: PUSH
35466: LD_VAR 0 2
35470: ARRAY
35471: PPUSH
35472: LD_INT 22
35474: PUSH
35475: LD_VAR 0 5
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 21
35486: PUSH
35487: LD_INT 2
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 3
35496: PUSH
35497: LD_INT 24
35499: PUSH
35500: LD_INT 1000
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: LIST
35515: PPUSH
35516: CALL_OW 70
35520: ST_TO_ADDR
// for j in fac do
35521: LD_ADDR_VAR 0 3
35525: PUSH
35526: LD_VAR 0 6
35530: PUSH
35531: FOR_IN
35532: IFFALSE 35613
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35534: LD_ADDR_VAR 0 7
35538: PUSH
35539: LD_VAR 0 7
35543: PUSH
35544: LD_INT 22
35546: PUSH
35547: LD_VAR 0 5
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 91
35558: PUSH
35559: LD_VAR 0 3
35563: PUSH
35564: LD_INT 15
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 21
35574: PUSH
35575: LD_INT 2
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 3
35584: PUSH
35585: LD_INT 24
35587: PUSH
35588: LD_INT 1000
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: LIST
35603: LIST
35604: PPUSH
35605: CALL_OW 69
35609: UNION
35610: ST_TO_ADDR
35611: GO 35531
35613: POP
35614: POP
// if not vehs then
35615: LD_VAR 0 7
35619: NOT
35620: IFFALSE 35646
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35622: LD_ADDR_EXP 62
35626: PUSH
35627: LD_EXP 62
35631: PPUSH
35632: LD_VAR 0 2
35636: PPUSH
35637: EMPTY
35638: PPUSH
35639: CALL_OW 1
35643: ST_TO_ADDR
// continue ;
35644: GO 35304
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35646: LD_ADDR_VAR 0 8
35650: PUSH
35651: LD_EXP 50
35655: PUSH
35656: LD_VAR 0 2
35660: ARRAY
35661: PPUSH
35662: LD_INT 30
35664: PUSH
35665: LD_INT 3
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PPUSH
35672: CALL_OW 72
35676: ST_TO_ADDR
// if tmp then
35677: LD_VAR 0 8
35681: IFFALSE 35784
// begin for j in tmp do
35683: LD_ADDR_VAR 0 3
35687: PUSH
35688: LD_VAR 0 8
35692: PUSH
35693: FOR_IN
35694: IFFALSE 35782
// for k in UnitsInside ( j ) do
35696: LD_ADDR_VAR 0 4
35700: PUSH
35701: LD_VAR 0 3
35705: PPUSH
35706: CALL_OW 313
35710: PUSH
35711: FOR_IN
35712: IFFALSE 35778
// if k then
35714: LD_VAR 0 4
35718: IFFALSE 35776
// if not k in mc_repair_vehicle [ i ] then
35720: LD_VAR 0 4
35724: PUSH
35725: LD_EXP 62
35729: PUSH
35730: LD_VAR 0 2
35734: ARRAY
35735: IN
35736: NOT
35737: IFFALSE 35776
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35739: LD_ADDR_EXP 62
35743: PUSH
35744: LD_EXP 62
35748: PPUSH
35749: LD_VAR 0 2
35753: PPUSH
35754: LD_EXP 62
35758: PUSH
35759: LD_VAR 0 2
35763: ARRAY
35764: PUSH
35765: LD_VAR 0 4
35769: UNION
35770: PPUSH
35771: CALL_OW 1
35775: ST_TO_ADDR
35776: GO 35711
35778: POP
35779: POP
35780: GO 35693
35782: POP
35783: POP
// end ; if not mc_repair_vehicle [ i ] then
35784: LD_EXP 62
35788: PUSH
35789: LD_VAR 0 2
35793: ARRAY
35794: NOT
35795: IFFALSE 35799
// continue ;
35797: GO 35304
// for j in mc_repair_vehicle [ i ] do
35799: LD_ADDR_VAR 0 3
35803: PUSH
35804: LD_EXP 62
35808: PUSH
35809: LD_VAR 0 2
35813: ARRAY
35814: PUSH
35815: FOR_IN
35816: IFFALSE 35982
// begin if GetClass ( j ) <> 3 then
35818: LD_VAR 0 3
35822: PPUSH
35823: CALL_OW 257
35827: PUSH
35828: LD_INT 3
35830: NONEQUAL
35831: IFFALSE 35872
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35833: LD_ADDR_EXP 62
35837: PUSH
35838: LD_EXP 62
35842: PPUSH
35843: LD_VAR 0 2
35847: PPUSH
35848: LD_EXP 62
35852: PUSH
35853: LD_VAR 0 2
35857: ARRAY
35858: PUSH
35859: LD_VAR 0 3
35863: DIFF
35864: PPUSH
35865: CALL_OW 1
35869: ST_TO_ADDR
// continue ;
35870: GO 35815
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35872: LD_VAR 0 3
35876: PPUSH
35877: CALL_OW 311
35881: NOT
35882: PUSH
35883: LD_VAR 0 3
35887: PUSH
35888: LD_EXP 53
35892: PUSH
35893: LD_VAR 0 2
35897: ARRAY
35898: PUSH
35899: LD_INT 1
35901: ARRAY
35902: IN
35903: NOT
35904: AND
35905: PUSH
35906: LD_VAR 0 3
35910: PUSH
35911: LD_EXP 53
35915: PUSH
35916: LD_VAR 0 2
35920: ARRAY
35921: PUSH
35922: LD_INT 2
35924: ARRAY
35925: IN
35926: NOT
35927: AND
35928: IFFALSE 35980
// begin if IsInUnit ( j ) then
35930: LD_VAR 0 3
35934: PPUSH
35935: CALL_OW 310
35939: IFFALSE 35950
// ComExitBuilding ( j ) ;
35941: LD_VAR 0 3
35945: PPUSH
35946: CALL_OW 122
// if not HasTask ( j ) then
35950: LD_VAR 0 3
35954: PPUSH
35955: CALL_OW 314
35959: NOT
35960: IFFALSE 35980
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35962: LD_VAR 0 3
35966: PPUSH
35967: LD_VAR 0 7
35971: PUSH
35972: LD_INT 1
35974: ARRAY
35975: PPUSH
35976: CALL_OW 189
// end ; end ;
35980: GO 35815
35982: POP
35983: POP
// end ;
35984: GO 35304
35986: POP
35987: POP
// end ;
35988: LD_VAR 0 1
35992: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35993: LD_INT 0
35995: PPUSH
35996: PPUSH
35997: PPUSH
35998: PPUSH
35999: PPUSH
36000: PPUSH
36001: PPUSH
36002: PPUSH
36003: PPUSH
36004: PPUSH
36005: PPUSH
// if not mc_bases then
36006: LD_EXP 50
36010: NOT
36011: IFFALSE 36015
// exit ;
36013: GO 36817
// for i = 1 to mc_bases do
36015: LD_ADDR_VAR 0 2
36019: PUSH
36020: DOUBLE
36021: LD_INT 1
36023: DEC
36024: ST_TO_ADDR
36025: LD_EXP 50
36029: PUSH
36030: FOR_TO
36031: IFFALSE 36815
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36033: LD_EXP 78
36037: PUSH
36038: LD_VAR 0 2
36042: ARRAY
36043: NOT
36044: PUSH
36045: LD_EXP 53
36049: PUSH
36050: LD_VAR 0 2
36054: ARRAY
36055: PUSH
36056: LD_INT 1
36058: ARRAY
36059: OR
36060: PUSH
36061: LD_EXP 53
36065: PUSH
36066: LD_VAR 0 2
36070: ARRAY
36071: PUSH
36072: LD_INT 2
36074: ARRAY
36075: OR
36076: PUSH
36077: LD_EXP 76
36081: PUSH
36082: LD_VAR 0 2
36086: ARRAY
36087: PPUSH
36088: LD_INT 1
36090: PPUSH
36091: CALL_OW 325
36095: NOT
36096: OR
36097: PUSH
36098: LD_EXP 73
36102: PUSH
36103: LD_VAR 0 2
36107: ARRAY
36108: OR
36109: IFFALSE 36113
// continue ;
36111: GO 36030
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36113: LD_ADDR_VAR 0 8
36117: PUSH
36118: LD_EXP 50
36122: PUSH
36123: LD_VAR 0 2
36127: ARRAY
36128: PPUSH
36129: LD_INT 25
36131: PUSH
36132: LD_INT 4
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 50
36141: PUSH
36142: EMPTY
36143: LIST
36144: PUSH
36145: LD_INT 3
36147: PUSH
36148: LD_INT 60
36150: PUSH
36151: EMPTY
36152: LIST
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: LIST
36162: PPUSH
36163: CALL_OW 72
36167: PUSH
36168: LD_EXP 54
36172: PUSH
36173: LD_VAR 0 2
36177: ARRAY
36178: DIFF
36179: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36180: LD_ADDR_VAR 0 9
36184: PUSH
36185: LD_EXP 50
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: PPUSH
36196: LD_INT 2
36198: PUSH
36199: LD_INT 30
36201: PUSH
36202: LD_INT 0
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 30
36211: PUSH
36212: LD_INT 1
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: LIST
36223: PPUSH
36224: CALL_OW 72
36228: ST_TO_ADDR
// if not tmp or not dep then
36229: LD_VAR 0 8
36233: NOT
36234: PUSH
36235: LD_VAR 0 9
36239: NOT
36240: OR
36241: IFFALSE 36245
// continue ;
36243: GO 36030
// side := GetSide ( tmp [ 1 ] ) ;
36245: LD_ADDR_VAR 0 11
36249: PUSH
36250: LD_VAR 0 8
36254: PUSH
36255: LD_INT 1
36257: ARRAY
36258: PPUSH
36259: CALL_OW 255
36263: ST_TO_ADDR
// dep := dep [ 1 ] ;
36264: LD_ADDR_VAR 0 9
36268: PUSH
36269: LD_VAR 0 9
36273: PUSH
36274: LD_INT 1
36276: ARRAY
36277: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36278: LD_ADDR_VAR 0 7
36282: PUSH
36283: LD_EXP 78
36287: PUSH
36288: LD_VAR 0 2
36292: ARRAY
36293: PPUSH
36294: LD_INT 22
36296: PUSH
36297: LD_INT 0
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 25
36306: PUSH
36307: LD_INT 12
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PPUSH
36318: CALL_OW 70
36322: PUSH
36323: LD_INT 22
36325: PUSH
36326: LD_INT 0
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 25
36335: PUSH
36336: LD_INT 12
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 91
36345: PUSH
36346: LD_VAR 0 9
36350: PUSH
36351: LD_INT 20
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: LIST
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: LIST
36363: PPUSH
36364: CALL_OW 69
36368: UNION
36369: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36370: LD_ADDR_VAR 0 10
36374: PUSH
36375: LD_EXP 78
36379: PUSH
36380: LD_VAR 0 2
36384: ARRAY
36385: PPUSH
36386: LD_INT 81
36388: PUSH
36389: LD_VAR 0 11
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PPUSH
36398: CALL_OW 70
36402: ST_TO_ADDR
// if not apes or danger_at_area then
36403: LD_VAR 0 7
36407: NOT
36408: PUSH
36409: LD_VAR 0 10
36413: OR
36414: IFFALSE 36464
// begin if mc_taming [ i ] then
36416: LD_EXP 81
36420: PUSH
36421: LD_VAR 0 2
36425: ARRAY
36426: IFFALSE 36462
// begin MC_Reset ( i , 121 ) ;
36428: LD_VAR 0 2
36432: PPUSH
36433: LD_INT 121
36435: PPUSH
36436: CALL 21867 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36440: LD_ADDR_EXP 81
36444: PUSH
36445: LD_EXP 81
36449: PPUSH
36450: LD_VAR 0 2
36454: PPUSH
36455: EMPTY
36456: PPUSH
36457: CALL_OW 1
36461: ST_TO_ADDR
// end ; continue ;
36462: GO 36030
// end ; for j in tmp do
36464: LD_ADDR_VAR 0 3
36468: PUSH
36469: LD_VAR 0 8
36473: PUSH
36474: FOR_IN
36475: IFFALSE 36811
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36477: LD_VAR 0 3
36481: PUSH
36482: LD_EXP 81
36486: PUSH
36487: LD_VAR 0 2
36491: ARRAY
36492: IN
36493: NOT
36494: PUSH
36495: LD_EXP 81
36499: PUSH
36500: LD_VAR 0 2
36504: ARRAY
36505: PUSH
36506: LD_INT 3
36508: LESS
36509: AND
36510: IFFALSE 36568
// begin SetTag ( j , 121 ) ;
36512: LD_VAR 0 3
36516: PPUSH
36517: LD_INT 121
36519: PPUSH
36520: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36524: LD_ADDR_EXP 81
36528: PUSH
36529: LD_EXP 81
36533: PPUSH
36534: LD_VAR 0 2
36538: PUSH
36539: LD_EXP 81
36543: PUSH
36544: LD_VAR 0 2
36548: ARRAY
36549: PUSH
36550: LD_INT 1
36552: PLUS
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: PPUSH
36558: LD_VAR 0 3
36562: PPUSH
36563: CALL 52825 0 3
36567: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36568: LD_VAR 0 3
36572: PUSH
36573: LD_EXP 81
36577: PUSH
36578: LD_VAR 0 2
36582: ARRAY
36583: IN
36584: IFFALSE 36809
// begin if GetClass ( j ) <> 4 then
36586: LD_VAR 0 3
36590: PPUSH
36591: CALL_OW 257
36595: PUSH
36596: LD_INT 4
36598: NONEQUAL
36599: IFFALSE 36652
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36601: LD_ADDR_EXP 81
36605: PUSH
36606: LD_EXP 81
36610: PPUSH
36611: LD_VAR 0 2
36615: PPUSH
36616: LD_EXP 81
36620: PUSH
36621: LD_VAR 0 2
36625: ARRAY
36626: PUSH
36627: LD_VAR 0 3
36631: DIFF
36632: PPUSH
36633: CALL_OW 1
36637: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36638: LD_VAR 0 3
36642: PPUSH
36643: LD_INT 0
36645: PPUSH
36646: CALL_OW 109
// continue ;
36650: GO 36474
// end ; if IsInUnit ( j ) then
36652: LD_VAR 0 3
36656: PPUSH
36657: CALL_OW 310
36661: IFFALSE 36672
// ComExitBuilding ( j ) ;
36663: LD_VAR 0 3
36667: PPUSH
36668: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36672: LD_ADDR_VAR 0 6
36676: PUSH
36677: LD_VAR 0 7
36681: PPUSH
36682: LD_VAR 0 3
36686: PPUSH
36687: CALL_OW 74
36691: ST_TO_ADDR
// if not ape then
36692: LD_VAR 0 6
36696: NOT
36697: IFFALSE 36701
// break ;
36699: GO 36811
// x := GetX ( ape ) ;
36701: LD_ADDR_VAR 0 4
36705: PUSH
36706: LD_VAR 0 6
36710: PPUSH
36711: CALL_OW 250
36715: ST_TO_ADDR
// y := GetY ( ape ) ;
36716: LD_ADDR_VAR 0 5
36720: PUSH
36721: LD_VAR 0 6
36725: PPUSH
36726: CALL_OW 251
36730: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36731: LD_VAR 0 4
36735: PPUSH
36736: LD_VAR 0 5
36740: PPUSH
36741: CALL_OW 488
36745: NOT
36746: PUSH
36747: LD_VAR 0 11
36751: PPUSH
36752: LD_VAR 0 4
36756: PPUSH
36757: LD_VAR 0 5
36761: PPUSH
36762: LD_INT 20
36764: PPUSH
36765: CALL 53721 0 4
36769: PUSH
36770: LD_INT 4
36772: ARRAY
36773: OR
36774: IFFALSE 36778
// break ;
36776: GO 36811
// if not HasTask ( j ) then
36778: LD_VAR 0 3
36782: PPUSH
36783: CALL_OW 314
36787: NOT
36788: IFFALSE 36809
// ComTameXY ( j , x , y ) ;
36790: LD_VAR 0 3
36794: PPUSH
36795: LD_VAR 0 4
36799: PPUSH
36800: LD_VAR 0 5
36804: PPUSH
36805: CALL_OW 131
// end ; end ;
36809: GO 36474
36811: POP
36812: POP
// end ;
36813: GO 36030
36815: POP
36816: POP
// end ;
36817: LD_VAR 0 1
36821: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36822: LD_INT 0
36824: PPUSH
36825: PPUSH
36826: PPUSH
36827: PPUSH
36828: PPUSH
36829: PPUSH
36830: PPUSH
36831: PPUSH
// if not mc_bases then
36832: LD_EXP 50
36836: NOT
36837: IFFALSE 36841
// exit ;
36839: GO 37467
// for i = 1 to mc_bases do
36841: LD_ADDR_VAR 0 2
36845: PUSH
36846: DOUBLE
36847: LD_INT 1
36849: DEC
36850: ST_TO_ADDR
36851: LD_EXP 50
36855: PUSH
36856: FOR_TO
36857: IFFALSE 37465
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36859: LD_EXP 79
36863: PUSH
36864: LD_VAR 0 2
36868: ARRAY
36869: NOT
36870: PUSH
36871: LD_EXP 79
36875: PUSH
36876: LD_VAR 0 2
36880: ARRAY
36881: PPUSH
36882: LD_INT 25
36884: PUSH
36885: LD_INT 12
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PPUSH
36892: CALL_OW 72
36896: NOT
36897: OR
36898: IFFALSE 36902
// continue ;
36900: GO 36856
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36902: LD_ADDR_VAR 0 5
36906: PUSH
36907: LD_EXP 79
36911: PUSH
36912: LD_VAR 0 2
36916: ARRAY
36917: PUSH
36918: LD_INT 1
36920: ARRAY
36921: PPUSH
36922: CALL_OW 255
36926: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36927: LD_VAR 0 5
36931: PPUSH
36932: LD_INT 2
36934: PPUSH
36935: CALL_OW 325
36939: IFFALSE 37192
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36941: LD_ADDR_VAR 0 4
36945: PUSH
36946: LD_EXP 79
36950: PUSH
36951: LD_VAR 0 2
36955: ARRAY
36956: PPUSH
36957: LD_INT 25
36959: PUSH
36960: LD_INT 16
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PPUSH
36967: CALL_OW 72
36971: ST_TO_ADDR
// if tmp < 6 then
36972: LD_VAR 0 4
36976: PUSH
36977: LD_INT 6
36979: LESS
36980: IFFALSE 37192
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36982: LD_ADDR_VAR 0 6
36986: PUSH
36987: LD_EXP 50
36991: PUSH
36992: LD_VAR 0 2
36996: ARRAY
36997: PPUSH
36998: LD_INT 2
37000: PUSH
37001: LD_INT 30
37003: PUSH
37004: LD_INT 0
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 30
37013: PUSH
37014: LD_INT 1
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: LIST
37025: PPUSH
37026: CALL_OW 72
37030: ST_TO_ADDR
// if depot then
37031: LD_VAR 0 6
37035: IFFALSE 37192
// begin selected := 0 ;
37037: LD_ADDR_VAR 0 7
37041: PUSH
37042: LD_INT 0
37044: ST_TO_ADDR
// for j in depot do
37045: LD_ADDR_VAR 0 3
37049: PUSH
37050: LD_VAR 0 6
37054: PUSH
37055: FOR_IN
37056: IFFALSE 37087
// begin if UnitsInside ( j ) < 6 then
37058: LD_VAR 0 3
37062: PPUSH
37063: CALL_OW 313
37067: PUSH
37068: LD_INT 6
37070: LESS
37071: IFFALSE 37085
// begin selected := j ;
37073: LD_ADDR_VAR 0 7
37077: PUSH
37078: LD_VAR 0 3
37082: ST_TO_ADDR
// break ;
37083: GO 37087
// end ; end ;
37085: GO 37055
37087: POP
37088: POP
// if selected then
37089: LD_VAR 0 7
37093: IFFALSE 37192
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37095: LD_ADDR_VAR 0 3
37099: PUSH
37100: LD_EXP 79
37104: PUSH
37105: LD_VAR 0 2
37109: ARRAY
37110: PPUSH
37111: LD_INT 25
37113: PUSH
37114: LD_INT 12
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PPUSH
37121: CALL_OW 72
37125: PUSH
37126: FOR_IN
37127: IFFALSE 37190
// if not HasTask ( j ) then
37129: LD_VAR 0 3
37133: PPUSH
37134: CALL_OW 314
37138: NOT
37139: IFFALSE 37188
// begin if not IsInUnit ( j ) then
37141: LD_VAR 0 3
37145: PPUSH
37146: CALL_OW 310
37150: NOT
37151: IFFALSE 37167
// ComEnterUnit ( j , selected ) ;
37153: LD_VAR 0 3
37157: PPUSH
37158: LD_VAR 0 7
37162: PPUSH
37163: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37167: LD_VAR 0 3
37171: PPUSH
37172: LD_INT 16
37174: PPUSH
37175: CALL_OW 183
// AddComExitBuilding ( j ) ;
37179: LD_VAR 0 3
37183: PPUSH
37184: CALL_OW 182
// end ;
37188: GO 37126
37190: POP
37191: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37192: LD_VAR 0 5
37196: PPUSH
37197: LD_INT 11
37199: PPUSH
37200: CALL_OW 325
37204: IFFALSE 37463
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37206: LD_ADDR_VAR 0 4
37210: PUSH
37211: LD_EXP 79
37215: PUSH
37216: LD_VAR 0 2
37220: ARRAY
37221: PPUSH
37222: LD_INT 25
37224: PUSH
37225: LD_INT 16
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PPUSH
37232: CALL_OW 72
37236: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37237: LD_VAR 0 4
37241: PUSH
37242: LD_INT 6
37244: GREATEREQUAL
37245: PUSH
37246: LD_VAR 0 5
37250: PPUSH
37251: LD_INT 2
37253: PPUSH
37254: CALL_OW 325
37258: NOT
37259: OR
37260: IFFALSE 37463
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37262: LD_ADDR_VAR 0 8
37266: PUSH
37267: LD_EXP 50
37271: PUSH
37272: LD_VAR 0 2
37276: ARRAY
37277: PPUSH
37278: LD_INT 2
37280: PUSH
37281: LD_INT 30
37283: PUSH
37284: LD_INT 4
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 30
37293: PUSH
37294: LD_INT 5
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: LIST
37305: PPUSH
37306: CALL_OW 72
37310: ST_TO_ADDR
// if barracks then
37311: LD_VAR 0 8
37315: IFFALSE 37463
// begin selected := 0 ;
37317: LD_ADDR_VAR 0 7
37321: PUSH
37322: LD_INT 0
37324: ST_TO_ADDR
// for j in barracks do
37325: LD_ADDR_VAR 0 3
37329: PUSH
37330: LD_VAR 0 8
37334: PUSH
37335: FOR_IN
37336: IFFALSE 37367
// begin if UnitsInside ( j ) < 6 then
37338: LD_VAR 0 3
37342: PPUSH
37343: CALL_OW 313
37347: PUSH
37348: LD_INT 6
37350: LESS
37351: IFFALSE 37365
// begin selected := j ;
37353: LD_ADDR_VAR 0 7
37357: PUSH
37358: LD_VAR 0 3
37362: ST_TO_ADDR
// break ;
37363: GO 37367
// end ; end ;
37365: GO 37335
37367: POP
37368: POP
// if selected then
37369: LD_VAR 0 7
37373: IFFALSE 37463
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37375: LD_ADDR_VAR 0 3
37379: PUSH
37380: LD_EXP 79
37384: PUSH
37385: LD_VAR 0 2
37389: ARRAY
37390: PPUSH
37391: LD_INT 25
37393: PUSH
37394: LD_INT 12
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PPUSH
37401: CALL_OW 72
37405: PUSH
37406: FOR_IN
37407: IFFALSE 37461
// if not IsInUnit ( j ) and not HasTask ( j ) then
37409: LD_VAR 0 3
37413: PPUSH
37414: CALL_OW 310
37418: NOT
37419: PUSH
37420: LD_VAR 0 3
37424: PPUSH
37425: CALL_OW 314
37429: NOT
37430: AND
37431: IFFALSE 37459
// begin ComEnterUnit ( j , selected ) ;
37433: LD_VAR 0 3
37437: PPUSH
37438: LD_VAR 0 7
37442: PPUSH
37443: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37447: LD_VAR 0 3
37451: PPUSH
37452: LD_INT 15
37454: PPUSH
37455: CALL_OW 183
// end ;
37459: GO 37406
37461: POP
37462: POP
// end ; end ; end ; end ; end ;
37463: GO 36856
37465: POP
37466: POP
// end ;
37467: LD_VAR 0 1
37471: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37472: LD_INT 0
37474: PPUSH
37475: PPUSH
37476: PPUSH
37477: PPUSH
// if not mc_bases then
37478: LD_EXP 50
37482: NOT
37483: IFFALSE 37487
// exit ;
37485: GO 37665
// for i = 1 to mc_bases do
37487: LD_ADDR_VAR 0 2
37491: PUSH
37492: DOUBLE
37493: LD_INT 1
37495: DEC
37496: ST_TO_ADDR
37497: LD_EXP 50
37501: PUSH
37502: FOR_TO
37503: IFFALSE 37663
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37505: LD_ADDR_VAR 0 4
37509: PUSH
37510: LD_EXP 50
37514: PUSH
37515: LD_VAR 0 2
37519: ARRAY
37520: PPUSH
37521: LD_INT 25
37523: PUSH
37524: LD_INT 9
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: PPUSH
37531: CALL_OW 72
37535: ST_TO_ADDR
// if not tmp then
37536: LD_VAR 0 4
37540: NOT
37541: IFFALSE 37545
// continue ;
37543: GO 37502
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37545: LD_EXP 76
37549: PUSH
37550: LD_VAR 0 2
37554: ARRAY
37555: PPUSH
37556: LD_INT 29
37558: PPUSH
37559: CALL_OW 325
37563: NOT
37564: PUSH
37565: LD_EXP 76
37569: PUSH
37570: LD_VAR 0 2
37574: ARRAY
37575: PPUSH
37576: LD_INT 28
37578: PPUSH
37579: CALL_OW 325
37583: NOT
37584: AND
37585: IFFALSE 37589
// continue ;
37587: GO 37502
// for j in tmp do
37589: LD_ADDR_VAR 0 3
37593: PUSH
37594: LD_VAR 0 4
37598: PUSH
37599: FOR_IN
37600: IFFALSE 37659
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37602: LD_VAR 0 3
37606: PUSH
37607: LD_EXP 53
37611: PUSH
37612: LD_VAR 0 2
37616: ARRAY
37617: PUSH
37618: LD_INT 1
37620: ARRAY
37621: IN
37622: NOT
37623: PUSH
37624: LD_VAR 0 3
37628: PUSH
37629: LD_EXP 53
37633: PUSH
37634: LD_VAR 0 2
37638: ARRAY
37639: PUSH
37640: LD_INT 2
37642: ARRAY
37643: IN
37644: NOT
37645: AND
37646: IFFALSE 37657
// ComSpaceTimeShoot ( j ) ;
37648: LD_VAR 0 3
37652: PPUSH
37653: CALL 48822 0 1
37657: GO 37599
37659: POP
37660: POP
// end ;
37661: GO 37502
37663: POP
37664: POP
// end ;
37665: LD_VAR 0 1
37669: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37670: LD_INT 0
37672: PPUSH
37673: PPUSH
37674: PPUSH
37675: PPUSH
37676: PPUSH
37677: PPUSH
37678: PPUSH
37679: PPUSH
37680: PPUSH
// if not mc_bases then
37681: LD_EXP 50
37685: NOT
37686: IFFALSE 37690
// exit ;
37688: GO 38312
// for i = 1 to mc_bases do
37690: LD_ADDR_VAR 0 2
37694: PUSH
37695: DOUBLE
37696: LD_INT 1
37698: DEC
37699: ST_TO_ADDR
37700: LD_EXP 50
37704: PUSH
37705: FOR_TO
37706: IFFALSE 38310
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37708: LD_EXP 85
37712: PUSH
37713: LD_VAR 0 2
37717: ARRAY
37718: NOT
37719: PUSH
37720: LD_INT 38
37722: PPUSH
37723: LD_EXP 76
37727: PUSH
37728: LD_VAR 0 2
37732: ARRAY
37733: PPUSH
37734: CALL_OW 321
37738: PUSH
37739: LD_INT 2
37741: NONEQUAL
37742: OR
37743: IFFALSE 37747
// continue ;
37745: GO 37705
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37747: LD_ADDR_VAR 0 8
37751: PUSH
37752: LD_EXP 50
37756: PUSH
37757: LD_VAR 0 2
37761: ARRAY
37762: PPUSH
37763: LD_INT 30
37765: PUSH
37766: LD_INT 34
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PPUSH
37773: CALL_OW 72
37777: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37778: LD_ADDR_VAR 0 9
37782: PUSH
37783: LD_EXP 50
37787: PUSH
37788: LD_VAR 0 2
37792: ARRAY
37793: PPUSH
37794: LD_INT 25
37796: PUSH
37797: LD_INT 4
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PPUSH
37804: CALL_OW 72
37808: PPUSH
37809: LD_INT 0
37811: PPUSH
37812: CALL 81386 0 2
37816: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37817: LD_VAR 0 9
37821: NOT
37822: PUSH
37823: LD_VAR 0 8
37827: NOT
37828: OR
37829: PUSH
37830: LD_EXP 50
37834: PUSH
37835: LD_VAR 0 2
37839: ARRAY
37840: PPUSH
37841: LD_INT 124
37843: PPUSH
37844: CALL 81386 0 2
37848: OR
37849: IFFALSE 37853
// continue ;
37851: GO 37705
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37853: LD_EXP 86
37857: PUSH
37858: LD_VAR 0 2
37862: ARRAY
37863: PUSH
37864: LD_EXP 85
37868: PUSH
37869: LD_VAR 0 2
37873: ARRAY
37874: LESS
37875: PUSH
37876: LD_EXP 86
37880: PUSH
37881: LD_VAR 0 2
37885: ARRAY
37886: PUSH
37887: LD_VAR 0 8
37891: LESS
37892: AND
37893: IFFALSE 38308
// begin tmp := sci [ 1 ] ;
37895: LD_ADDR_VAR 0 7
37899: PUSH
37900: LD_VAR 0 9
37904: PUSH
37905: LD_INT 1
37907: ARRAY
37908: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37909: LD_VAR 0 7
37913: PPUSH
37914: LD_INT 124
37916: PPUSH
37917: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37921: LD_ADDR_VAR 0 3
37925: PUSH
37926: DOUBLE
37927: LD_EXP 85
37931: PUSH
37932: LD_VAR 0 2
37936: ARRAY
37937: INC
37938: ST_TO_ADDR
37939: LD_EXP 85
37943: PUSH
37944: LD_VAR 0 2
37948: ARRAY
37949: PUSH
37950: FOR_DOWNTO
37951: IFFALSE 38294
// begin if IsInUnit ( tmp ) then
37953: LD_VAR 0 7
37957: PPUSH
37958: CALL_OW 310
37962: IFFALSE 37973
// ComExitBuilding ( tmp ) ;
37964: LD_VAR 0 7
37968: PPUSH
37969: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37973: LD_INT 35
37975: PPUSH
37976: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37980: LD_VAR 0 7
37984: PPUSH
37985: CALL_OW 310
37989: NOT
37990: PUSH
37991: LD_VAR 0 7
37995: PPUSH
37996: CALL_OW 314
38000: NOT
38001: AND
38002: IFFALSE 37973
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38004: LD_ADDR_VAR 0 6
38008: PUSH
38009: LD_VAR 0 7
38013: PPUSH
38014: CALL_OW 250
38018: PUSH
38019: LD_VAR 0 7
38023: PPUSH
38024: CALL_OW 251
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38033: LD_INT 35
38035: PPUSH
38036: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38040: LD_ADDR_VAR 0 4
38044: PUSH
38045: LD_EXP 85
38049: PUSH
38050: LD_VAR 0 2
38054: ARRAY
38055: PUSH
38056: LD_VAR 0 3
38060: ARRAY
38061: PUSH
38062: LD_INT 1
38064: ARRAY
38065: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38066: LD_ADDR_VAR 0 5
38070: PUSH
38071: LD_EXP 85
38075: PUSH
38076: LD_VAR 0 2
38080: ARRAY
38081: PUSH
38082: LD_VAR 0 3
38086: ARRAY
38087: PUSH
38088: LD_INT 2
38090: ARRAY
38091: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38092: LD_VAR 0 7
38096: PPUSH
38097: LD_INT 10
38099: PPUSH
38100: CALL 55418 0 2
38104: PUSH
38105: LD_INT 4
38107: ARRAY
38108: IFFALSE 38146
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38110: LD_VAR 0 7
38114: PPUSH
38115: LD_VAR 0 6
38119: PUSH
38120: LD_INT 1
38122: ARRAY
38123: PPUSH
38124: LD_VAR 0 6
38128: PUSH
38129: LD_INT 2
38131: ARRAY
38132: PPUSH
38133: CALL_OW 111
// wait ( 0 0$10 ) ;
38137: LD_INT 350
38139: PPUSH
38140: CALL_OW 67
// end else
38144: GO 38172
// begin ComMoveXY ( tmp , x , y ) ;
38146: LD_VAR 0 7
38150: PPUSH
38151: LD_VAR 0 4
38155: PPUSH
38156: LD_VAR 0 5
38160: PPUSH
38161: CALL_OW 111
// wait ( 0 0$3 ) ;
38165: LD_INT 105
38167: PPUSH
38168: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38172: LD_VAR 0 7
38176: PPUSH
38177: LD_VAR 0 4
38181: PPUSH
38182: LD_VAR 0 5
38186: PPUSH
38187: CALL_OW 307
38191: IFFALSE 38033
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38193: LD_VAR 0 7
38197: PPUSH
38198: LD_VAR 0 4
38202: PPUSH
38203: LD_VAR 0 5
38207: PPUSH
38208: LD_VAR 0 8
38212: PUSH
38213: LD_VAR 0 3
38217: ARRAY
38218: PPUSH
38219: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38223: LD_INT 35
38225: PPUSH
38226: CALL_OW 67
// until not HasTask ( tmp ) ;
38230: LD_VAR 0 7
38234: PPUSH
38235: CALL_OW 314
38239: NOT
38240: IFFALSE 38223
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38242: LD_ADDR_EXP 86
38246: PUSH
38247: LD_EXP 86
38251: PPUSH
38252: LD_VAR 0 2
38256: PUSH
38257: LD_EXP 86
38261: PUSH
38262: LD_VAR 0 2
38266: ARRAY
38267: PUSH
38268: LD_INT 1
38270: PLUS
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PPUSH
38276: LD_VAR 0 8
38280: PUSH
38281: LD_VAR 0 3
38285: ARRAY
38286: PPUSH
38287: CALL 52825 0 3
38291: ST_TO_ADDR
// end ;
38292: GO 37950
38294: POP
38295: POP
// MC_Reset ( i , 124 ) ;
38296: LD_VAR 0 2
38300: PPUSH
38301: LD_INT 124
38303: PPUSH
38304: CALL 21867 0 2
// end ; end ;
38308: GO 37705
38310: POP
38311: POP
// end ;
38312: LD_VAR 0 1
38316: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38317: LD_INT 0
38319: PPUSH
38320: PPUSH
38321: PPUSH
// if not mc_bases then
38322: LD_EXP 50
38326: NOT
38327: IFFALSE 38331
// exit ;
38329: GO 38937
// for i = 1 to mc_bases do
38331: LD_ADDR_VAR 0 2
38335: PUSH
38336: DOUBLE
38337: LD_INT 1
38339: DEC
38340: ST_TO_ADDR
38341: LD_EXP 50
38345: PUSH
38346: FOR_TO
38347: IFFALSE 38935
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38349: LD_ADDR_VAR 0 3
38353: PUSH
38354: LD_EXP 50
38358: PUSH
38359: LD_VAR 0 2
38363: ARRAY
38364: PPUSH
38365: LD_INT 25
38367: PUSH
38368: LD_INT 4
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PPUSH
38375: CALL_OW 72
38379: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38380: LD_VAR 0 3
38384: NOT
38385: PUSH
38386: LD_EXP 87
38390: PUSH
38391: LD_VAR 0 2
38395: ARRAY
38396: NOT
38397: OR
38398: PUSH
38399: LD_EXP 50
38403: PUSH
38404: LD_VAR 0 2
38408: ARRAY
38409: PPUSH
38410: LD_INT 2
38412: PUSH
38413: LD_INT 30
38415: PUSH
38416: LD_INT 0
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 30
38425: PUSH
38426: LD_INT 1
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: LIST
38437: PPUSH
38438: CALL_OW 72
38442: NOT
38443: OR
38444: IFFALSE 38494
// begin if mc_deposits_finder [ i ] then
38446: LD_EXP 88
38450: PUSH
38451: LD_VAR 0 2
38455: ARRAY
38456: IFFALSE 38492
// begin MC_Reset ( i , 125 ) ;
38458: LD_VAR 0 2
38462: PPUSH
38463: LD_INT 125
38465: PPUSH
38466: CALL 21867 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38470: LD_ADDR_EXP 88
38474: PUSH
38475: LD_EXP 88
38479: PPUSH
38480: LD_VAR 0 2
38484: PPUSH
38485: EMPTY
38486: PPUSH
38487: CALL_OW 1
38491: ST_TO_ADDR
// end ; continue ;
38492: GO 38346
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38494: LD_EXP 87
38498: PUSH
38499: LD_VAR 0 2
38503: ARRAY
38504: PUSH
38505: LD_INT 1
38507: ARRAY
38508: PUSH
38509: LD_INT 3
38511: ARRAY
38512: PUSH
38513: LD_INT 1
38515: EQUAL
38516: PUSH
38517: LD_INT 20
38519: PPUSH
38520: LD_EXP 76
38524: PUSH
38525: LD_VAR 0 2
38529: ARRAY
38530: PPUSH
38531: CALL_OW 321
38535: PUSH
38536: LD_INT 2
38538: NONEQUAL
38539: AND
38540: IFFALSE 38590
// begin if mc_deposits_finder [ i ] then
38542: LD_EXP 88
38546: PUSH
38547: LD_VAR 0 2
38551: ARRAY
38552: IFFALSE 38588
// begin MC_Reset ( i , 125 ) ;
38554: LD_VAR 0 2
38558: PPUSH
38559: LD_INT 125
38561: PPUSH
38562: CALL 21867 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38566: LD_ADDR_EXP 88
38570: PUSH
38571: LD_EXP 88
38575: PPUSH
38576: LD_VAR 0 2
38580: PPUSH
38581: EMPTY
38582: PPUSH
38583: CALL_OW 1
38587: ST_TO_ADDR
// end ; continue ;
38588: GO 38346
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38590: LD_EXP 87
38594: PUSH
38595: LD_VAR 0 2
38599: ARRAY
38600: PUSH
38601: LD_INT 1
38603: ARRAY
38604: PUSH
38605: LD_INT 1
38607: ARRAY
38608: PPUSH
38609: LD_EXP 87
38613: PUSH
38614: LD_VAR 0 2
38618: ARRAY
38619: PUSH
38620: LD_INT 1
38622: ARRAY
38623: PUSH
38624: LD_INT 2
38626: ARRAY
38627: PPUSH
38628: LD_EXP 76
38632: PUSH
38633: LD_VAR 0 2
38637: ARRAY
38638: PPUSH
38639: CALL_OW 440
38643: IFFALSE 38686
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38645: LD_ADDR_EXP 87
38649: PUSH
38650: LD_EXP 87
38654: PPUSH
38655: LD_VAR 0 2
38659: PPUSH
38660: LD_EXP 87
38664: PUSH
38665: LD_VAR 0 2
38669: ARRAY
38670: PPUSH
38671: LD_INT 1
38673: PPUSH
38674: CALL_OW 3
38678: PPUSH
38679: CALL_OW 1
38683: ST_TO_ADDR
38684: GO 38933
// begin if not mc_deposits_finder [ i ] then
38686: LD_EXP 88
38690: PUSH
38691: LD_VAR 0 2
38695: ARRAY
38696: NOT
38697: IFFALSE 38749
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38699: LD_ADDR_EXP 88
38703: PUSH
38704: LD_EXP 88
38708: PPUSH
38709: LD_VAR 0 2
38713: PPUSH
38714: LD_VAR 0 3
38718: PUSH
38719: LD_INT 1
38721: ARRAY
38722: PUSH
38723: EMPTY
38724: LIST
38725: PPUSH
38726: CALL_OW 1
38730: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38731: LD_VAR 0 3
38735: PUSH
38736: LD_INT 1
38738: ARRAY
38739: PPUSH
38740: LD_INT 125
38742: PPUSH
38743: CALL_OW 109
// end else
38747: GO 38933
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38749: LD_EXP 88
38753: PUSH
38754: LD_VAR 0 2
38758: ARRAY
38759: PUSH
38760: LD_INT 1
38762: ARRAY
38763: PPUSH
38764: CALL_OW 310
38768: IFFALSE 38791
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38770: LD_EXP 88
38774: PUSH
38775: LD_VAR 0 2
38779: ARRAY
38780: PUSH
38781: LD_INT 1
38783: ARRAY
38784: PPUSH
38785: CALL_OW 122
38789: GO 38933
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38791: LD_EXP 88
38795: PUSH
38796: LD_VAR 0 2
38800: ARRAY
38801: PUSH
38802: LD_INT 1
38804: ARRAY
38805: PPUSH
38806: CALL_OW 314
38810: NOT
38811: PUSH
38812: LD_EXP 88
38816: PUSH
38817: LD_VAR 0 2
38821: ARRAY
38822: PUSH
38823: LD_INT 1
38825: ARRAY
38826: PPUSH
38827: LD_EXP 87
38831: PUSH
38832: LD_VAR 0 2
38836: ARRAY
38837: PUSH
38838: LD_INT 1
38840: ARRAY
38841: PUSH
38842: LD_INT 1
38844: ARRAY
38845: PPUSH
38846: LD_EXP 87
38850: PUSH
38851: LD_VAR 0 2
38855: ARRAY
38856: PUSH
38857: LD_INT 1
38859: ARRAY
38860: PUSH
38861: LD_INT 2
38863: ARRAY
38864: PPUSH
38865: CALL_OW 297
38869: PUSH
38870: LD_INT 6
38872: GREATER
38873: AND
38874: IFFALSE 38933
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38876: LD_EXP 88
38880: PUSH
38881: LD_VAR 0 2
38885: ARRAY
38886: PUSH
38887: LD_INT 1
38889: ARRAY
38890: PPUSH
38891: LD_EXP 87
38895: PUSH
38896: LD_VAR 0 2
38900: ARRAY
38901: PUSH
38902: LD_INT 1
38904: ARRAY
38905: PUSH
38906: LD_INT 1
38908: ARRAY
38909: PPUSH
38910: LD_EXP 87
38914: PUSH
38915: LD_VAR 0 2
38919: ARRAY
38920: PUSH
38921: LD_INT 1
38923: ARRAY
38924: PUSH
38925: LD_INT 2
38927: ARRAY
38928: PPUSH
38929: CALL_OW 111
// end ; end ; end ;
38933: GO 38346
38935: POP
38936: POP
// end ;
38937: LD_VAR 0 1
38941: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38942: LD_INT 0
38944: PPUSH
38945: PPUSH
38946: PPUSH
38947: PPUSH
38948: PPUSH
38949: PPUSH
38950: PPUSH
38951: PPUSH
38952: PPUSH
38953: PPUSH
38954: PPUSH
// if not mc_bases then
38955: LD_EXP 50
38959: NOT
38960: IFFALSE 38964
// exit ;
38962: GO 39904
// for i = 1 to mc_bases do
38964: LD_ADDR_VAR 0 2
38968: PUSH
38969: DOUBLE
38970: LD_INT 1
38972: DEC
38973: ST_TO_ADDR
38974: LD_EXP 50
38978: PUSH
38979: FOR_TO
38980: IFFALSE 39902
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38982: LD_EXP 50
38986: PUSH
38987: LD_VAR 0 2
38991: ARRAY
38992: NOT
38993: PUSH
38994: LD_EXP 73
38998: PUSH
38999: LD_VAR 0 2
39003: ARRAY
39004: OR
39005: IFFALSE 39009
// continue ;
39007: GO 38979
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39009: LD_ADDR_VAR 0 7
39013: PUSH
39014: LD_EXP 50
39018: PUSH
39019: LD_VAR 0 2
39023: ARRAY
39024: PUSH
39025: LD_INT 1
39027: ARRAY
39028: PPUSH
39029: CALL_OW 248
39033: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39034: LD_VAR 0 7
39038: PUSH
39039: LD_INT 3
39041: EQUAL
39042: PUSH
39043: LD_EXP 69
39047: PUSH
39048: LD_VAR 0 2
39052: ARRAY
39053: PUSH
39054: LD_EXP 72
39058: PUSH
39059: LD_VAR 0 2
39063: ARRAY
39064: UNION
39065: PPUSH
39066: LD_INT 33
39068: PUSH
39069: LD_INT 2
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PPUSH
39076: CALL_OW 72
39080: NOT
39081: OR
39082: IFFALSE 39086
// continue ;
39084: GO 38979
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39086: LD_ADDR_VAR 0 9
39090: PUSH
39091: LD_EXP 50
39095: PUSH
39096: LD_VAR 0 2
39100: ARRAY
39101: PPUSH
39102: LD_INT 30
39104: PUSH
39105: LD_INT 36
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PPUSH
39112: CALL_OW 72
39116: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39117: LD_ADDR_VAR 0 10
39121: PUSH
39122: LD_EXP 69
39126: PUSH
39127: LD_VAR 0 2
39131: ARRAY
39132: PPUSH
39133: LD_INT 34
39135: PUSH
39136: LD_INT 31
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PPUSH
39143: CALL_OW 72
39147: ST_TO_ADDR
// if not cts and not mcts then
39148: LD_VAR 0 9
39152: NOT
39153: PUSH
39154: LD_VAR 0 10
39158: NOT
39159: AND
39160: IFFALSE 39164
// continue ;
39162: GO 38979
// x := cts ;
39164: LD_ADDR_VAR 0 11
39168: PUSH
39169: LD_VAR 0 9
39173: ST_TO_ADDR
// if not x then
39174: LD_VAR 0 11
39178: NOT
39179: IFFALSE 39191
// x := mcts ;
39181: LD_ADDR_VAR 0 11
39185: PUSH
39186: LD_VAR 0 10
39190: ST_TO_ADDR
// if not x then
39191: LD_VAR 0 11
39195: NOT
39196: IFFALSE 39200
// continue ;
39198: GO 38979
// if mc_remote_driver [ i ] then
39200: LD_EXP 90
39204: PUSH
39205: LD_VAR 0 2
39209: ARRAY
39210: IFFALSE 39597
// for j in mc_remote_driver [ i ] do
39212: LD_ADDR_VAR 0 3
39216: PUSH
39217: LD_EXP 90
39221: PUSH
39222: LD_VAR 0 2
39226: ARRAY
39227: PUSH
39228: FOR_IN
39229: IFFALSE 39595
// begin if GetClass ( j ) <> 3 then
39231: LD_VAR 0 3
39235: PPUSH
39236: CALL_OW 257
39240: PUSH
39241: LD_INT 3
39243: NONEQUAL
39244: IFFALSE 39297
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39246: LD_ADDR_EXP 90
39250: PUSH
39251: LD_EXP 90
39255: PPUSH
39256: LD_VAR 0 2
39260: PPUSH
39261: LD_EXP 90
39265: PUSH
39266: LD_VAR 0 2
39270: ARRAY
39271: PUSH
39272: LD_VAR 0 3
39276: DIFF
39277: PPUSH
39278: CALL_OW 1
39282: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39283: LD_VAR 0 3
39287: PPUSH
39288: LD_INT 0
39290: PPUSH
39291: CALL_OW 109
// continue ;
39295: GO 39228
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39297: LD_EXP 69
39301: PUSH
39302: LD_VAR 0 2
39306: ARRAY
39307: PPUSH
39308: LD_INT 34
39310: PUSH
39311: LD_INT 31
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 58
39320: PUSH
39321: EMPTY
39322: LIST
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PPUSH
39328: CALL_OW 72
39332: PUSH
39333: LD_VAR 0 3
39337: PPUSH
39338: CALL 81474 0 1
39342: NOT
39343: AND
39344: IFFALSE 39415
// begin if IsInUnit ( j ) then
39346: LD_VAR 0 3
39350: PPUSH
39351: CALL_OW 310
39355: IFFALSE 39366
// ComExitBuilding ( j ) ;
39357: LD_VAR 0 3
39361: PPUSH
39362: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39366: LD_VAR 0 3
39370: PPUSH
39371: LD_EXP 69
39375: PUSH
39376: LD_VAR 0 2
39380: ARRAY
39381: PPUSH
39382: LD_INT 34
39384: PUSH
39385: LD_INT 31
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 58
39394: PUSH
39395: EMPTY
39396: LIST
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PPUSH
39402: CALL_OW 72
39406: PUSH
39407: LD_INT 1
39409: ARRAY
39410: PPUSH
39411: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39415: LD_VAR 0 3
39419: PPUSH
39420: CALL_OW 310
39424: NOT
39425: PUSH
39426: LD_VAR 0 3
39430: PPUSH
39431: CALL_OW 310
39435: PPUSH
39436: CALL_OW 266
39440: PUSH
39441: LD_INT 36
39443: NONEQUAL
39444: PUSH
39445: LD_VAR 0 3
39449: PPUSH
39450: CALL 81474 0 1
39454: NOT
39455: AND
39456: OR
39457: IFFALSE 39593
// begin if IsInUnit ( j ) then
39459: LD_VAR 0 3
39463: PPUSH
39464: CALL_OW 310
39468: IFFALSE 39479
// ComExitBuilding ( j ) ;
39470: LD_VAR 0 3
39474: PPUSH
39475: CALL_OW 122
// ct := 0 ;
39479: LD_ADDR_VAR 0 8
39483: PUSH
39484: LD_INT 0
39486: ST_TO_ADDR
// for k in x do
39487: LD_ADDR_VAR 0 4
39491: PUSH
39492: LD_VAR 0 11
39496: PUSH
39497: FOR_IN
39498: IFFALSE 39571
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39500: LD_VAR 0 4
39504: PPUSH
39505: CALL_OW 264
39509: PUSH
39510: LD_INT 31
39512: EQUAL
39513: PUSH
39514: LD_VAR 0 4
39518: PPUSH
39519: CALL_OW 311
39523: NOT
39524: AND
39525: PUSH
39526: LD_VAR 0 4
39530: PPUSH
39531: CALL_OW 266
39535: PUSH
39536: LD_INT 36
39538: EQUAL
39539: PUSH
39540: LD_VAR 0 4
39544: PPUSH
39545: CALL_OW 313
39549: PUSH
39550: LD_INT 3
39552: LESS
39553: AND
39554: OR
39555: IFFALSE 39569
// begin ct := k ;
39557: LD_ADDR_VAR 0 8
39561: PUSH
39562: LD_VAR 0 4
39566: ST_TO_ADDR
// break ;
39567: GO 39571
// end ;
39569: GO 39497
39571: POP
39572: POP
// if ct then
39573: LD_VAR 0 8
39577: IFFALSE 39593
// ComEnterUnit ( j , ct ) ;
39579: LD_VAR 0 3
39583: PPUSH
39584: LD_VAR 0 8
39588: PPUSH
39589: CALL_OW 120
// end ; end ;
39593: GO 39228
39595: POP
39596: POP
// places := 0 ;
39597: LD_ADDR_VAR 0 5
39601: PUSH
39602: LD_INT 0
39604: ST_TO_ADDR
// for j = 1 to x do
39605: LD_ADDR_VAR 0 3
39609: PUSH
39610: DOUBLE
39611: LD_INT 1
39613: DEC
39614: ST_TO_ADDR
39615: LD_VAR 0 11
39619: PUSH
39620: FOR_TO
39621: IFFALSE 39697
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39623: LD_VAR 0 11
39627: PUSH
39628: LD_VAR 0 3
39632: ARRAY
39633: PPUSH
39634: CALL_OW 264
39638: PUSH
39639: LD_INT 31
39641: EQUAL
39642: IFFALSE 39660
// places := places + 1 else
39644: LD_ADDR_VAR 0 5
39648: PUSH
39649: LD_VAR 0 5
39653: PUSH
39654: LD_INT 1
39656: PLUS
39657: ST_TO_ADDR
39658: GO 39695
// if GetBType ( x [ j ] ) = b_control_tower then
39660: LD_VAR 0 11
39664: PUSH
39665: LD_VAR 0 3
39669: ARRAY
39670: PPUSH
39671: CALL_OW 266
39675: PUSH
39676: LD_INT 36
39678: EQUAL
39679: IFFALSE 39695
// places := places + 3 ;
39681: LD_ADDR_VAR 0 5
39685: PUSH
39686: LD_VAR 0 5
39690: PUSH
39691: LD_INT 3
39693: PLUS
39694: ST_TO_ADDR
39695: GO 39620
39697: POP
39698: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39699: LD_VAR 0 5
39703: PUSH
39704: LD_INT 0
39706: EQUAL
39707: PUSH
39708: LD_VAR 0 5
39712: PUSH
39713: LD_EXP 90
39717: PUSH
39718: LD_VAR 0 2
39722: ARRAY
39723: LESSEQUAL
39724: OR
39725: IFFALSE 39729
// continue ;
39727: GO 38979
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39729: LD_ADDR_VAR 0 6
39733: PUSH
39734: LD_EXP 50
39738: PUSH
39739: LD_VAR 0 2
39743: ARRAY
39744: PPUSH
39745: LD_INT 25
39747: PUSH
39748: LD_INT 3
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PPUSH
39755: CALL_OW 72
39759: PUSH
39760: LD_EXP 90
39764: PUSH
39765: LD_VAR 0 2
39769: ARRAY
39770: DIFF
39771: PPUSH
39772: LD_INT 3
39774: PPUSH
39775: CALL 82374 0 2
39779: ST_TO_ADDR
// for j in tmp do
39780: LD_ADDR_VAR 0 3
39784: PUSH
39785: LD_VAR 0 6
39789: PUSH
39790: FOR_IN
39791: IFFALSE 39826
// if GetTag ( j ) > 0 then
39793: LD_VAR 0 3
39797: PPUSH
39798: CALL_OW 110
39802: PUSH
39803: LD_INT 0
39805: GREATER
39806: IFFALSE 39824
// tmp := tmp diff j ;
39808: LD_ADDR_VAR 0 6
39812: PUSH
39813: LD_VAR 0 6
39817: PUSH
39818: LD_VAR 0 3
39822: DIFF
39823: ST_TO_ADDR
39824: GO 39790
39826: POP
39827: POP
// if not tmp then
39828: LD_VAR 0 6
39832: NOT
39833: IFFALSE 39837
// continue ;
39835: GO 38979
// if places then
39837: LD_VAR 0 5
39841: IFFALSE 39900
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39843: LD_ADDR_EXP 90
39847: PUSH
39848: LD_EXP 90
39852: PPUSH
39853: LD_VAR 0 2
39857: PPUSH
39858: LD_EXP 90
39862: PUSH
39863: LD_VAR 0 2
39867: ARRAY
39868: PUSH
39869: LD_VAR 0 6
39873: PUSH
39874: LD_INT 1
39876: ARRAY
39877: UNION
39878: PPUSH
39879: CALL_OW 1
39883: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39884: LD_VAR 0 6
39888: PUSH
39889: LD_INT 1
39891: ARRAY
39892: PPUSH
39893: LD_INT 126
39895: PPUSH
39896: CALL_OW 109
// end ; end ;
39900: GO 38979
39902: POP
39903: POP
// end ;
39904: LD_VAR 0 1
39908: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39909: LD_INT 0
39911: PPUSH
39912: PPUSH
39913: PPUSH
39914: PPUSH
39915: PPUSH
39916: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39917: LD_VAR 0 1
39921: NOT
39922: PUSH
39923: LD_VAR 0 2
39927: NOT
39928: OR
39929: PUSH
39930: LD_VAR 0 3
39934: NOT
39935: OR
39936: PUSH
39937: LD_VAR 0 4
39941: PUSH
39942: LD_INT 1
39944: PUSH
39945: LD_INT 2
39947: PUSH
39948: LD_INT 3
39950: PUSH
39951: LD_INT 4
39953: PUSH
39954: LD_INT 5
39956: PUSH
39957: LD_INT 8
39959: PUSH
39960: LD_INT 9
39962: PUSH
39963: LD_INT 15
39965: PUSH
39966: LD_INT 16
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: IN
39980: NOT
39981: OR
39982: IFFALSE 39986
// exit ;
39984: GO 40886
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39986: LD_ADDR_VAR 0 2
39990: PUSH
39991: LD_VAR 0 2
39995: PPUSH
39996: LD_INT 21
39998: PUSH
39999: LD_INT 3
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 24
40008: PUSH
40009: LD_INT 250
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PPUSH
40020: CALL_OW 72
40024: ST_TO_ADDR
// case class of 1 , 15 :
40025: LD_VAR 0 4
40029: PUSH
40030: LD_INT 1
40032: DOUBLE
40033: EQUAL
40034: IFTRUE 40044
40036: LD_INT 15
40038: DOUBLE
40039: EQUAL
40040: IFTRUE 40044
40042: GO 40129
40044: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40045: LD_ADDR_VAR 0 8
40049: PUSH
40050: LD_VAR 0 2
40054: PPUSH
40055: LD_INT 2
40057: PUSH
40058: LD_INT 30
40060: PUSH
40061: LD_INT 32
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 30
40070: PUSH
40071: LD_INT 31
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: LIST
40082: PPUSH
40083: CALL_OW 72
40087: PUSH
40088: LD_VAR 0 2
40092: PPUSH
40093: LD_INT 2
40095: PUSH
40096: LD_INT 30
40098: PUSH
40099: LD_INT 4
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 30
40108: PUSH
40109: LD_INT 5
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: LIST
40120: PPUSH
40121: CALL_OW 72
40125: ADD
40126: ST_TO_ADDR
40127: GO 40375
40129: LD_INT 2
40131: DOUBLE
40132: EQUAL
40133: IFTRUE 40143
40135: LD_INT 16
40137: DOUBLE
40138: EQUAL
40139: IFTRUE 40143
40141: GO 40189
40143: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40144: LD_ADDR_VAR 0 8
40148: PUSH
40149: LD_VAR 0 2
40153: PPUSH
40154: LD_INT 2
40156: PUSH
40157: LD_INT 30
40159: PUSH
40160: LD_INT 0
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 30
40169: PUSH
40170: LD_INT 1
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: LIST
40181: PPUSH
40182: CALL_OW 72
40186: ST_TO_ADDR
40187: GO 40375
40189: LD_INT 3
40191: DOUBLE
40192: EQUAL
40193: IFTRUE 40197
40195: GO 40243
40197: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40198: LD_ADDR_VAR 0 8
40202: PUSH
40203: LD_VAR 0 2
40207: PPUSH
40208: LD_INT 2
40210: PUSH
40211: LD_INT 30
40213: PUSH
40214: LD_INT 2
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 30
40223: PUSH
40224: LD_INT 3
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: LIST
40235: PPUSH
40236: CALL_OW 72
40240: ST_TO_ADDR
40241: GO 40375
40243: LD_INT 4
40245: DOUBLE
40246: EQUAL
40247: IFTRUE 40251
40249: GO 40308
40251: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40252: LD_ADDR_VAR 0 8
40256: PUSH
40257: LD_VAR 0 2
40261: PPUSH
40262: LD_INT 2
40264: PUSH
40265: LD_INT 30
40267: PUSH
40268: LD_INT 6
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 30
40277: PUSH
40278: LD_INT 7
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 30
40287: PUSH
40288: LD_INT 8
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: LIST
40299: LIST
40300: PPUSH
40301: CALL_OW 72
40305: ST_TO_ADDR
40306: GO 40375
40308: LD_INT 5
40310: DOUBLE
40311: EQUAL
40312: IFTRUE 40328
40314: LD_INT 8
40316: DOUBLE
40317: EQUAL
40318: IFTRUE 40328
40320: LD_INT 9
40322: DOUBLE
40323: EQUAL
40324: IFTRUE 40328
40326: GO 40374
40328: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40329: LD_ADDR_VAR 0 8
40333: PUSH
40334: LD_VAR 0 2
40338: PPUSH
40339: LD_INT 2
40341: PUSH
40342: LD_INT 30
40344: PUSH
40345: LD_INT 4
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 30
40354: PUSH
40355: LD_INT 5
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: LIST
40366: PPUSH
40367: CALL_OW 72
40371: ST_TO_ADDR
40372: GO 40375
40374: POP
// if not tmp then
40375: LD_VAR 0 8
40379: NOT
40380: IFFALSE 40384
// exit ;
40382: GO 40886
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40384: LD_VAR 0 4
40388: PUSH
40389: LD_INT 1
40391: PUSH
40392: LD_INT 15
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: IN
40399: PUSH
40400: LD_EXP 59
40404: PUSH
40405: LD_VAR 0 1
40409: ARRAY
40410: AND
40411: IFFALSE 40567
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40413: LD_ADDR_VAR 0 9
40417: PUSH
40418: LD_EXP 59
40422: PUSH
40423: LD_VAR 0 1
40427: ARRAY
40428: PUSH
40429: LD_INT 1
40431: ARRAY
40432: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40433: LD_VAR 0 9
40437: PUSH
40438: LD_EXP 60
40442: PUSH
40443: LD_VAR 0 1
40447: ARRAY
40448: IN
40449: NOT
40450: IFFALSE 40565
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40452: LD_ADDR_EXP 60
40456: PUSH
40457: LD_EXP 60
40461: PPUSH
40462: LD_VAR 0 1
40466: PUSH
40467: LD_EXP 60
40471: PUSH
40472: LD_VAR 0 1
40476: ARRAY
40477: PUSH
40478: LD_INT 1
40480: PLUS
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PPUSH
40486: LD_VAR 0 9
40490: PPUSH
40491: CALL 52825 0 3
40495: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40496: LD_ADDR_EXP 59
40500: PUSH
40501: LD_EXP 59
40505: PPUSH
40506: LD_VAR 0 1
40510: PPUSH
40511: LD_EXP 59
40515: PUSH
40516: LD_VAR 0 1
40520: ARRAY
40521: PUSH
40522: LD_VAR 0 9
40526: DIFF
40527: PPUSH
40528: CALL_OW 1
40532: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40533: LD_VAR 0 3
40537: PPUSH
40538: LD_EXP 60
40542: PUSH
40543: LD_VAR 0 1
40547: ARRAY
40548: PUSH
40549: LD_EXP 60
40553: PUSH
40554: LD_VAR 0 1
40558: ARRAY
40559: ARRAY
40560: PPUSH
40561: CALL_OW 120
// end ; exit ;
40565: GO 40886
// end ; if tmp > 1 then
40567: LD_VAR 0 8
40571: PUSH
40572: LD_INT 1
40574: GREATER
40575: IFFALSE 40679
// for i = 2 to tmp do
40577: LD_ADDR_VAR 0 6
40581: PUSH
40582: DOUBLE
40583: LD_INT 2
40585: DEC
40586: ST_TO_ADDR
40587: LD_VAR 0 8
40591: PUSH
40592: FOR_TO
40593: IFFALSE 40677
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40595: LD_VAR 0 8
40599: PUSH
40600: LD_VAR 0 6
40604: ARRAY
40605: PPUSH
40606: CALL_OW 461
40610: PUSH
40611: LD_INT 6
40613: EQUAL
40614: IFFALSE 40675
// begin x := tmp [ i ] ;
40616: LD_ADDR_VAR 0 9
40620: PUSH
40621: LD_VAR 0 8
40625: PUSH
40626: LD_VAR 0 6
40630: ARRAY
40631: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40632: LD_ADDR_VAR 0 8
40636: PUSH
40637: LD_VAR 0 8
40641: PPUSH
40642: LD_VAR 0 6
40646: PPUSH
40647: CALL_OW 3
40651: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40652: LD_ADDR_VAR 0 8
40656: PUSH
40657: LD_VAR 0 8
40661: PPUSH
40662: LD_INT 1
40664: PPUSH
40665: LD_VAR 0 9
40669: PPUSH
40670: CALL_OW 2
40674: ST_TO_ADDR
// end ;
40675: GO 40592
40677: POP
40678: POP
// for i in tmp do
40679: LD_ADDR_VAR 0 6
40683: PUSH
40684: LD_VAR 0 8
40688: PUSH
40689: FOR_IN
40690: IFFALSE 40759
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40692: LD_VAR 0 6
40696: PPUSH
40697: CALL_OW 313
40701: PUSH
40702: LD_INT 6
40704: LESS
40705: PUSH
40706: LD_VAR 0 6
40710: PPUSH
40711: CALL_OW 266
40715: PUSH
40716: LD_INT 31
40718: PUSH
40719: LD_INT 32
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: IN
40726: NOT
40727: AND
40728: PUSH
40729: LD_VAR 0 6
40733: PPUSH
40734: CALL_OW 313
40738: PUSH
40739: LD_INT 0
40741: EQUAL
40742: OR
40743: IFFALSE 40757
// begin j := i ;
40745: LD_ADDR_VAR 0 7
40749: PUSH
40750: LD_VAR 0 6
40754: ST_TO_ADDR
// break ;
40755: GO 40759
// end ; end ;
40757: GO 40689
40759: POP
40760: POP
// if j then
40761: LD_VAR 0 7
40765: IFFALSE 40783
// ComEnterUnit ( unit , j ) else
40767: LD_VAR 0 3
40771: PPUSH
40772: LD_VAR 0 7
40776: PPUSH
40777: CALL_OW 120
40781: GO 40886
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40783: LD_ADDR_VAR 0 10
40787: PUSH
40788: LD_VAR 0 2
40792: PPUSH
40793: LD_INT 2
40795: PUSH
40796: LD_INT 30
40798: PUSH
40799: LD_INT 0
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 30
40808: PUSH
40809: LD_INT 1
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: LIST
40820: PPUSH
40821: CALL_OW 72
40825: ST_TO_ADDR
// if depot then
40826: LD_VAR 0 10
40830: IFFALSE 40886
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40832: LD_ADDR_VAR 0 10
40836: PUSH
40837: LD_VAR 0 10
40841: PPUSH
40842: LD_VAR 0 3
40846: PPUSH
40847: CALL_OW 74
40851: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40852: LD_VAR 0 3
40856: PPUSH
40857: LD_VAR 0 10
40861: PPUSH
40862: CALL_OW 296
40866: PUSH
40867: LD_INT 10
40869: GREATER
40870: IFFALSE 40886
// ComStandNearbyBuilding ( unit , depot ) ;
40872: LD_VAR 0 3
40876: PPUSH
40877: LD_VAR 0 10
40881: PPUSH
40882: CALL 49439 0 2
// end ; end ; end ;
40886: LD_VAR 0 5
40890: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40891: LD_INT 0
40893: PPUSH
40894: PPUSH
40895: PPUSH
40896: PPUSH
// if not mc_bases then
40897: LD_EXP 50
40901: NOT
40902: IFFALSE 40906
// exit ;
40904: GO 41145
// for i = 1 to mc_bases do
40906: LD_ADDR_VAR 0 2
40910: PUSH
40911: DOUBLE
40912: LD_INT 1
40914: DEC
40915: ST_TO_ADDR
40916: LD_EXP 50
40920: PUSH
40921: FOR_TO
40922: IFFALSE 41143
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40924: LD_ADDR_VAR 0 4
40928: PUSH
40929: LD_EXP 50
40933: PUSH
40934: LD_VAR 0 2
40938: ARRAY
40939: PPUSH
40940: LD_INT 21
40942: PUSH
40943: LD_INT 1
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PPUSH
40950: CALL_OW 72
40954: PUSH
40955: LD_EXP 79
40959: PUSH
40960: LD_VAR 0 2
40964: ARRAY
40965: UNION
40966: ST_TO_ADDR
// if not tmp then
40967: LD_VAR 0 4
40971: NOT
40972: IFFALSE 40976
// continue ;
40974: GO 40921
// for j in tmp do
40976: LD_ADDR_VAR 0 3
40980: PUSH
40981: LD_VAR 0 4
40985: PUSH
40986: FOR_IN
40987: IFFALSE 41139
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40989: LD_VAR 0 3
40993: PPUSH
40994: CALL_OW 110
40998: NOT
40999: PUSH
41000: LD_VAR 0 3
41004: PPUSH
41005: CALL_OW 314
41009: NOT
41010: AND
41011: PUSH
41012: LD_VAR 0 3
41016: PPUSH
41017: CALL_OW 311
41021: NOT
41022: AND
41023: PUSH
41024: LD_VAR 0 3
41028: PPUSH
41029: CALL_OW 310
41033: NOT
41034: AND
41035: PUSH
41036: LD_VAR 0 3
41040: PUSH
41041: LD_EXP 53
41045: PUSH
41046: LD_VAR 0 2
41050: ARRAY
41051: PUSH
41052: LD_INT 1
41054: ARRAY
41055: IN
41056: NOT
41057: AND
41058: PUSH
41059: LD_VAR 0 3
41063: PUSH
41064: LD_EXP 53
41068: PUSH
41069: LD_VAR 0 2
41073: ARRAY
41074: PUSH
41075: LD_INT 2
41077: ARRAY
41078: IN
41079: NOT
41080: AND
41081: PUSH
41082: LD_VAR 0 3
41086: PUSH
41087: LD_EXP 62
41091: PUSH
41092: LD_VAR 0 2
41096: ARRAY
41097: IN
41098: NOT
41099: AND
41100: IFFALSE 41137
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41102: LD_VAR 0 2
41106: PPUSH
41107: LD_EXP 50
41111: PUSH
41112: LD_VAR 0 2
41116: ARRAY
41117: PPUSH
41118: LD_VAR 0 3
41122: PPUSH
41123: LD_VAR 0 3
41127: PPUSH
41128: CALL_OW 257
41132: PPUSH
41133: CALL 39909 0 4
// end ;
41137: GO 40986
41139: POP
41140: POP
// end ;
41141: GO 40921
41143: POP
41144: POP
// end ;
41145: LD_VAR 0 1
41149: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41150: LD_INT 0
41152: PPUSH
41153: PPUSH
41154: PPUSH
41155: PPUSH
41156: PPUSH
41157: PPUSH
// if not mc_bases [ base ] then
41158: LD_EXP 50
41162: PUSH
41163: LD_VAR 0 1
41167: ARRAY
41168: NOT
41169: IFFALSE 41173
// exit ;
41171: GO 41355
// tmp := [ ] ;
41173: LD_ADDR_VAR 0 6
41177: PUSH
41178: EMPTY
41179: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41180: LD_ADDR_VAR 0 7
41184: PUSH
41185: LD_VAR 0 3
41189: PPUSH
41190: LD_INT 0
41192: PPUSH
41193: CALL_OW 517
41197: ST_TO_ADDR
// if not list then
41198: LD_VAR 0 7
41202: NOT
41203: IFFALSE 41207
// exit ;
41205: GO 41355
// for i = 1 to amount do
41207: LD_ADDR_VAR 0 5
41211: PUSH
41212: DOUBLE
41213: LD_INT 1
41215: DEC
41216: ST_TO_ADDR
41217: LD_VAR 0 2
41221: PUSH
41222: FOR_TO
41223: IFFALSE 41303
// begin x := rand ( 1 , list [ 1 ] ) ;
41225: LD_ADDR_VAR 0 8
41229: PUSH
41230: LD_INT 1
41232: PPUSH
41233: LD_VAR 0 7
41237: PUSH
41238: LD_INT 1
41240: ARRAY
41241: PPUSH
41242: CALL_OW 12
41246: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41247: LD_ADDR_VAR 0 6
41251: PUSH
41252: LD_VAR 0 6
41256: PPUSH
41257: LD_VAR 0 5
41261: PPUSH
41262: LD_VAR 0 7
41266: PUSH
41267: LD_INT 1
41269: ARRAY
41270: PUSH
41271: LD_VAR 0 8
41275: ARRAY
41276: PUSH
41277: LD_VAR 0 7
41281: PUSH
41282: LD_INT 2
41284: ARRAY
41285: PUSH
41286: LD_VAR 0 8
41290: ARRAY
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PPUSH
41296: CALL_OW 1
41300: ST_TO_ADDR
// end ;
41301: GO 41222
41303: POP
41304: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41305: LD_ADDR_EXP 63
41309: PUSH
41310: LD_EXP 63
41314: PPUSH
41315: LD_VAR 0 1
41319: PPUSH
41320: LD_VAR 0 6
41324: PPUSH
41325: CALL_OW 1
41329: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41330: LD_ADDR_EXP 65
41334: PUSH
41335: LD_EXP 65
41339: PPUSH
41340: LD_VAR 0 1
41344: PPUSH
41345: LD_VAR 0 3
41349: PPUSH
41350: CALL_OW 1
41354: ST_TO_ADDR
// end ;
41355: LD_VAR 0 4
41359: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41360: LD_INT 0
41362: PPUSH
// if not mc_bases [ base ] then
41363: LD_EXP 50
41367: PUSH
41368: LD_VAR 0 1
41372: ARRAY
41373: NOT
41374: IFFALSE 41378
// exit ;
41376: GO 41403
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41378: LD_ADDR_EXP 55
41382: PUSH
41383: LD_EXP 55
41387: PPUSH
41388: LD_VAR 0 1
41392: PPUSH
41393: LD_VAR 0 2
41397: PPUSH
41398: CALL_OW 1
41402: ST_TO_ADDR
// end ;
41403: LD_VAR 0 3
41407: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41408: LD_INT 0
41410: PPUSH
// if not mc_bases [ base ] then
41411: LD_EXP 50
41415: PUSH
41416: LD_VAR 0 1
41420: ARRAY
41421: NOT
41422: IFFALSE 41426
// exit ;
41424: GO 41463
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41426: LD_ADDR_EXP 55
41430: PUSH
41431: LD_EXP 55
41435: PPUSH
41436: LD_VAR 0 1
41440: PPUSH
41441: LD_EXP 55
41445: PUSH
41446: LD_VAR 0 1
41450: ARRAY
41451: PUSH
41452: LD_VAR 0 2
41456: UNION
41457: PPUSH
41458: CALL_OW 1
41462: ST_TO_ADDR
// end ;
41463: LD_VAR 0 3
41467: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41468: LD_INT 0
41470: PPUSH
// if not mc_bases [ base ] then
41471: LD_EXP 50
41475: PUSH
41476: LD_VAR 0 1
41480: ARRAY
41481: NOT
41482: IFFALSE 41486
// exit ;
41484: GO 41511
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41486: LD_ADDR_EXP 71
41490: PUSH
41491: LD_EXP 71
41495: PPUSH
41496: LD_VAR 0 1
41500: PPUSH
41501: LD_VAR 0 2
41505: PPUSH
41506: CALL_OW 1
41510: ST_TO_ADDR
// end ;
41511: LD_VAR 0 3
41515: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41516: LD_INT 0
41518: PPUSH
// if not mc_bases [ base ] then
41519: LD_EXP 50
41523: PUSH
41524: LD_VAR 0 1
41528: ARRAY
41529: NOT
41530: IFFALSE 41534
// exit ;
41532: GO 41571
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41534: LD_ADDR_EXP 71
41538: PUSH
41539: LD_EXP 71
41543: PPUSH
41544: LD_VAR 0 1
41548: PPUSH
41549: LD_EXP 71
41553: PUSH
41554: LD_VAR 0 1
41558: ARRAY
41559: PUSH
41560: LD_VAR 0 2
41564: ADD
41565: PPUSH
41566: CALL_OW 1
41570: ST_TO_ADDR
// end ;
41571: LD_VAR 0 3
41575: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41576: LD_INT 0
41578: PPUSH
// if not mc_bases [ base ] then
41579: LD_EXP 50
41583: PUSH
41584: LD_VAR 0 1
41588: ARRAY
41589: NOT
41590: IFFALSE 41594
// exit ;
41592: GO 41648
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41594: LD_ADDR_EXP 72
41598: PUSH
41599: LD_EXP 72
41603: PPUSH
41604: LD_VAR 0 1
41608: PPUSH
41609: LD_VAR 0 2
41613: PPUSH
41614: CALL_OW 1
41618: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41619: LD_ADDR_EXP 61
41623: PUSH
41624: LD_EXP 61
41628: PPUSH
41629: LD_VAR 0 1
41633: PPUSH
41634: LD_VAR 0 2
41638: PUSH
41639: LD_INT 0
41641: PLUS
41642: PPUSH
41643: CALL_OW 1
41647: ST_TO_ADDR
// end ;
41648: LD_VAR 0 3
41652: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41653: LD_INT 0
41655: PPUSH
// if not mc_bases [ base ] then
41656: LD_EXP 50
41660: PUSH
41661: LD_VAR 0 1
41665: ARRAY
41666: NOT
41667: IFFALSE 41671
// exit ;
41669: GO 41696
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41671: LD_ADDR_EXP 61
41675: PUSH
41676: LD_EXP 61
41680: PPUSH
41681: LD_VAR 0 1
41685: PPUSH
41686: LD_VAR 0 2
41690: PPUSH
41691: CALL_OW 1
41695: ST_TO_ADDR
// end ;
41696: LD_VAR 0 3
41700: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41701: LD_INT 0
41703: PPUSH
41704: PPUSH
41705: PPUSH
41706: PPUSH
// if not mc_bases [ base ] then
41707: LD_EXP 50
41711: PUSH
41712: LD_VAR 0 1
41716: ARRAY
41717: NOT
41718: IFFALSE 41722
// exit ;
41720: GO 41787
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41722: LD_ADDR_EXP 70
41726: PUSH
41727: LD_EXP 70
41731: PPUSH
41732: LD_VAR 0 1
41736: PUSH
41737: LD_EXP 70
41741: PUSH
41742: LD_VAR 0 1
41746: ARRAY
41747: PUSH
41748: LD_INT 1
41750: PLUS
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: PPUSH
41756: LD_VAR 0 1
41760: PUSH
41761: LD_VAR 0 2
41765: PUSH
41766: LD_VAR 0 3
41770: PUSH
41771: LD_VAR 0 4
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: PPUSH
41782: CALL 52825 0 3
41786: ST_TO_ADDR
// end ;
41787: LD_VAR 0 5
41791: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41792: LD_INT 0
41794: PPUSH
// if not mc_bases [ base ] then
41795: LD_EXP 50
41799: PUSH
41800: LD_VAR 0 1
41804: ARRAY
41805: NOT
41806: IFFALSE 41810
// exit ;
41808: GO 41835
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41810: LD_ADDR_EXP 87
41814: PUSH
41815: LD_EXP 87
41819: PPUSH
41820: LD_VAR 0 1
41824: PPUSH
41825: LD_VAR 0 2
41829: PPUSH
41830: CALL_OW 1
41834: ST_TO_ADDR
// end ;
41835: LD_VAR 0 3
41839: RET
// export function MC_GetMinesField ( base ) ; begin
41840: LD_INT 0
41842: PPUSH
// result := mc_mines [ base ] ;
41843: LD_ADDR_VAR 0 2
41847: PUSH
41848: LD_EXP 63
41852: PUSH
41853: LD_VAR 0 1
41857: ARRAY
41858: ST_TO_ADDR
// end ;
41859: LD_VAR 0 2
41863: RET
// export function MC_GetProduceList ( base ) ; begin
41864: LD_INT 0
41866: PPUSH
// result := mc_produce [ base ] ;
41867: LD_ADDR_VAR 0 2
41871: PUSH
41872: LD_EXP 71
41876: PUSH
41877: LD_VAR 0 1
41881: ARRAY
41882: ST_TO_ADDR
// end ;
41883: LD_VAR 0 2
41887: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41888: LD_INT 0
41890: PPUSH
41891: PPUSH
// if not mc_bases then
41892: LD_EXP 50
41896: NOT
41897: IFFALSE 41901
// exit ;
41899: GO 41966
// if mc_bases [ base ] then
41901: LD_EXP 50
41905: PUSH
41906: LD_VAR 0 1
41910: ARRAY
41911: IFFALSE 41966
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41913: LD_ADDR_VAR 0 3
41917: PUSH
41918: LD_EXP 50
41922: PUSH
41923: LD_VAR 0 1
41927: ARRAY
41928: PPUSH
41929: LD_INT 30
41931: PUSH
41932: LD_VAR 0 2
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PPUSH
41941: CALL_OW 72
41945: ST_TO_ADDR
// if result then
41946: LD_VAR 0 3
41950: IFFALSE 41966
// result := result [ 1 ] ;
41952: LD_ADDR_VAR 0 3
41956: PUSH
41957: LD_VAR 0 3
41961: PUSH
41962: LD_INT 1
41964: ARRAY
41965: ST_TO_ADDR
// end ; end ;
41966: LD_VAR 0 3
41970: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41971: LD_INT 0
41973: PPUSH
41974: PPUSH
// if not mc_bases then
41975: LD_EXP 50
41979: NOT
41980: IFFALSE 41984
// exit ;
41982: GO 42029
// if mc_bases [ base ] then
41984: LD_EXP 50
41988: PUSH
41989: LD_VAR 0 1
41993: ARRAY
41994: IFFALSE 42029
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41996: LD_ADDR_VAR 0 3
42000: PUSH
42001: LD_EXP 50
42005: PUSH
42006: LD_VAR 0 1
42010: ARRAY
42011: PPUSH
42012: LD_INT 30
42014: PUSH
42015: LD_VAR 0 2
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PPUSH
42024: CALL_OW 72
42028: ST_TO_ADDR
// end ;
42029: LD_VAR 0 3
42033: RET
// export function MC_SetTame ( base , area ) ; begin
42034: LD_INT 0
42036: PPUSH
// if not mc_bases or not base then
42037: LD_EXP 50
42041: NOT
42042: PUSH
42043: LD_VAR 0 1
42047: NOT
42048: OR
42049: IFFALSE 42053
// exit ;
42051: GO 42078
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42053: LD_ADDR_EXP 78
42057: PUSH
42058: LD_EXP 78
42062: PPUSH
42063: LD_VAR 0 1
42067: PPUSH
42068: LD_VAR 0 2
42072: PPUSH
42073: CALL_OW 1
42077: ST_TO_ADDR
// end ;
42078: LD_VAR 0 3
42082: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42083: LD_INT 0
42085: PPUSH
42086: PPUSH
// if not mc_bases or not base then
42087: LD_EXP 50
42091: NOT
42092: PUSH
42093: LD_VAR 0 1
42097: NOT
42098: OR
42099: IFFALSE 42103
// exit ;
42101: GO 42205
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42103: LD_ADDR_VAR 0 4
42107: PUSH
42108: LD_EXP 50
42112: PUSH
42113: LD_VAR 0 1
42117: ARRAY
42118: PPUSH
42119: LD_INT 30
42121: PUSH
42122: LD_VAR 0 2
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PPUSH
42131: CALL_OW 72
42135: ST_TO_ADDR
// if not tmp then
42136: LD_VAR 0 4
42140: NOT
42141: IFFALSE 42145
// exit ;
42143: GO 42205
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42145: LD_ADDR_EXP 82
42149: PUSH
42150: LD_EXP 82
42154: PPUSH
42155: LD_VAR 0 1
42159: PPUSH
42160: LD_EXP 82
42164: PUSH
42165: LD_VAR 0 1
42169: ARRAY
42170: PPUSH
42171: LD_EXP 82
42175: PUSH
42176: LD_VAR 0 1
42180: ARRAY
42181: PUSH
42182: LD_INT 1
42184: PLUS
42185: PPUSH
42186: LD_VAR 0 4
42190: PUSH
42191: LD_INT 1
42193: ARRAY
42194: PPUSH
42195: CALL_OW 2
42199: PPUSH
42200: CALL_OW 1
42204: ST_TO_ADDR
// end ;
42205: LD_VAR 0 3
42209: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42210: LD_INT 0
42212: PPUSH
42213: PPUSH
// if not mc_bases or not base or not kinds then
42214: LD_EXP 50
42218: NOT
42219: PUSH
42220: LD_VAR 0 1
42224: NOT
42225: OR
42226: PUSH
42227: LD_VAR 0 2
42231: NOT
42232: OR
42233: IFFALSE 42237
// exit ;
42235: GO 42298
// for i in kinds do
42237: LD_ADDR_VAR 0 4
42241: PUSH
42242: LD_VAR 0 2
42246: PUSH
42247: FOR_IN
42248: IFFALSE 42296
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42250: LD_ADDR_EXP 84
42254: PUSH
42255: LD_EXP 84
42259: PPUSH
42260: LD_VAR 0 1
42264: PUSH
42265: LD_EXP 84
42269: PUSH
42270: LD_VAR 0 1
42274: ARRAY
42275: PUSH
42276: LD_INT 1
42278: PLUS
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PPUSH
42284: LD_VAR 0 4
42288: PPUSH
42289: CALL 52825 0 3
42293: ST_TO_ADDR
42294: GO 42247
42296: POP
42297: POP
// end ;
42298: LD_VAR 0 3
42302: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42303: LD_INT 0
42305: PPUSH
// if not mc_bases or not base or not areas then
42306: LD_EXP 50
42310: NOT
42311: PUSH
42312: LD_VAR 0 1
42316: NOT
42317: OR
42318: PUSH
42319: LD_VAR 0 2
42323: NOT
42324: OR
42325: IFFALSE 42329
// exit ;
42327: GO 42354
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42329: LD_ADDR_EXP 68
42333: PUSH
42334: LD_EXP 68
42338: PPUSH
42339: LD_VAR 0 1
42343: PPUSH
42344: LD_VAR 0 2
42348: PPUSH
42349: CALL_OW 1
42353: ST_TO_ADDR
// end ;
42354: LD_VAR 0 3
42358: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42359: LD_INT 0
42361: PPUSH
// if not mc_bases or not base or not teleports_exit then
42362: LD_EXP 50
42366: NOT
42367: PUSH
42368: LD_VAR 0 1
42372: NOT
42373: OR
42374: PUSH
42375: LD_VAR 0 2
42379: NOT
42380: OR
42381: IFFALSE 42385
// exit ;
42383: GO 42410
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42385: LD_ADDR_EXP 85
42389: PUSH
42390: LD_EXP 85
42394: PPUSH
42395: LD_VAR 0 1
42399: PPUSH
42400: LD_VAR 0 2
42404: PPUSH
42405: CALL_OW 1
42409: ST_TO_ADDR
// end ;
42410: LD_VAR 0 3
42414: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42415: LD_INT 0
42417: PPUSH
42418: PPUSH
42419: PPUSH
// if not mc_bases or not base or not ext_list then
42420: LD_EXP 50
42424: NOT
42425: PUSH
42426: LD_VAR 0 1
42430: NOT
42431: OR
42432: PUSH
42433: LD_VAR 0 5
42437: NOT
42438: OR
42439: IFFALSE 42443
// exit ;
42441: GO 42616
// tmp := GetFacExtXYD ( x , y , d ) ;
42443: LD_ADDR_VAR 0 8
42447: PUSH
42448: LD_VAR 0 2
42452: PPUSH
42453: LD_VAR 0 3
42457: PPUSH
42458: LD_VAR 0 4
42462: PPUSH
42463: CALL 81504 0 3
42467: ST_TO_ADDR
// if not tmp then
42468: LD_VAR 0 8
42472: NOT
42473: IFFALSE 42477
// exit ;
42475: GO 42616
// for i in tmp do
42477: LD_ADDR_VAR 0 7
42481: PUSH
42482: LD_VAR 0 8
42486: PUSH
42487: FOR_IN
42488: IFFALSE 42614
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42490: LD_ADDR_EXP 55
42494: PUSH
42495: LD_EXP 55
42499: PPUSH
42500: LD_VAR 0 1
42504: PPUSH
42505: LD_EXP 55
42509: PUSH
42510: LD_VAR 0 1
42514: ARRAY
42515: PPUSH
42516: LD_EXP 55
42520: PUSH
42521: LD_VAR 0 1
42525: ARRAY
42526: PUSH
42527: LD_INT 1
42529: PLUS
42530: PPUSH
42531: LD_VAR 0 5
42535: PUSH
42536: LD_INT 1
42538: ARRAY
42539: PUSH
42540: LD_VAR 0 7
42544: PUSH
42545: LD_INT 1
42547: ARRAY
42548: PUSH
42549: LD_VAR 0 7
42553: PUSH
42554: LD_INT 2
42556: ARRAY
42557: PUSH
42558: LD_VAR 0 7
42562: PUSH
42563: LD_INT 3
42565: ARRAY
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: LIST
42571: LIST
42572: PPUSH
42573: CALL_OW 2
42577: PPUSH
42578: CALL_OW 1
42582: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42583: LD_ADDR_VAR 0 5
42587: PUSH
42588: LD_VAR 0 5
42592: PPUSH
42593: LD_INT 1
42595: PPUSH
42596: CALL_OW 3
42600: ST_TO_ADDR
// if not ext_list then
42601: LD_VAR 0 5
42605: NOT
42606: IFFALSE 42612
// exit ;
42608: POP
42609: POP
42610: GO 42616
// end ;
42612: GO 42487
42614: POP
42615: POP
// end ;
42616: LD_VAR 0 6
42620: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42621: LD_INT 0
42623: PPUSH
// if not mc_bases or not base or not weapon_list then
42624: LD_EXP 50
42628: NOT
42629: PUSH
42630: LD_VAR 0 1
42634: NOT
42635: OR
42636: PUSH
42637: LD_VAR 0 2
42641: NOT
42642: OR
42643: IFFALSE 42647
// exit ;
42645: GO 42672
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42647: LD_ADDR_EXP 89
42651: PUSH
42652: LD_EXP 89
42656: PPUSH
42657: LD_VAR 0 1
42661: PPUSH
42662: LD_VAR 0 2
42666: PPUSH
42667: CALL_OW 1
42671: ST_TO_ADDR
// end ;
42672: LD_VAR 0 3
42676: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42677: LD_INT 0
42679: PPUSH
// if not mc_bases or not base or not tech_list then
42680: LD_EXP 50
42684: NOT
42685: PUSH
42686: LD_VAR 0 1
42690: NOT
42691: OR
42692: PUSH
42693: LD_VAR 0 2
42697: NOT
42698: OR
42699: IFFALSE 42703
// exit ;
42701: GO 42728
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42703: LD_ADDR_EXP 77
42707: PUSH
42708: LD_EXP 77
42712: PPUSH
42713: LD_VAR 0 1
42717: PPUSH
42718: LD_VAR 0 2
42722: PPUSH
42723: CALL_OW 1
42727: ST_TO_ADDR
// end ;
42728: LD_VAR 0 3
42732: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42733: LD_INT 0
42735: PPUSH
// if not mc_bases or not parking_area or not base then
42736: LD_EXP 50
42740: NOT
42741: PUSH
42742: LD_VAR 0 2
42746: NOT
42747: OR
42748: PUSH
42749: LD_VAR 0 1
42753: NOT
42754: OR
42755: IFFALSE 42759
// exit ;
42757: GO 42784
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42759: LD_ADDR_EXP 74
42763: PUSH
42764: LD_EXP 74
42768: PPUSH
42769: LD_VAR 0 1
42773: PPUSH
42774: LD_VAR 0 2
42778: PPUSH
42779: CALL_OW 1
42783: ST_TO_ADDR
// end ;
42784: LD_VAR 0 3
42788: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42789: LD_INT 0
42791: PPUSH
// if not mc_bases or not base or not scan_area then
42792: LD_EXP 50
42796: NOT
42797: PUSH
42798: LD_VAR 0 1
42802: NOT
42803: OR
42804: PUSH
42805: LD_VAR 0 2
42809: NOT
42810: OR
42811: IFFALSE 42815
// exit ;
42813: GO 42840
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42815: LD_ADDR_EXP 75
42819: PUSH
42820: LD_EXP 75
42824: PPUSH
42825: LD_VAR 0 1
42829: PPUSH
42830: LD_VAR 0 2
42834: PPUSH
42835: CALL_OW 1
42839: ST_TO_ADDR
// end ;
42840: LD_VAR 0 3
42844: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42845: LD_INT 0
42847: PPUSH
42848: PPUSH
// if not mc_bases or not base then
42849: LD_EXP 50
42853: NOT
42854: PUSH
42855: LD_VAR 0 1
42859: NOT
42860: OR
42861: IFFALSE 42865
// exit ;
42863: GO 42929
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42865: LD_ADDR_VAR 0 3
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 2
42875: PUSH
42876: LD_INT 3
42878: PUSH
42879: LD_INT 4
42881: PUSH
42882: LD_INT 11
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42892: LD_ADDR_EXP 77
42896: PUSH
42897: LD_EXP 77
42901: PPUSH
42902: LD_VAR 0 1
42906: PPUSH
42907: LD_EXP 77
42911: PUSH
42912: LD_VAR 0 1
42916: ARRAY
42917: PUSH
42918: LD_VAR 0 3
42922: DIFF
42923: PPUSH
42924: CALL_OW 1
42928: ST_TO_ADDR
// end ;
42929: LD_VAR 0 2
42933: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42934: LD_INT 0
42936: PPUSH
// result := mc_vehicles [ base ] ;
42937: LD_ADDR_VAR 0 3
42941: PUSH
42942: LD_EXP 69
42946: PUSH
42947: LD_VAR 0 1
42951: ARRAY
42952: ST_TO_ADDR
// if onlyCombat then
42953: LD_VAR 0 2
42957: IFFALSE 43135
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42959: LD_ADDR_VAR 0 3
42963: PUSH
42964: LD_VAR 0 3
42968: PUSH
42969: LD_VAR 0 3
42973: PPUSH
42974: LD_INT 2
42976: PUSH
42977: LD_INT 34
42979: PUSH
42980: LD_INT 12
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 34
42989: PUSH
42990: LD_INT 51
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PUSH
42997: LD_INT 34
42999: PUSH
43000: LD_EXP 94
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: PUSH
43009: LD_INT 34
43011: PUSH
43012: LD_INT 32
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 34
43021: PUSH
43022: LD_INT 13
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 34
43031: PUSH
43032: LD_INT 52
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 34
43041: PUSH
43042: LD_EXP 99
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 34
43053: PUSH
43054: LD_INT 14
43056: PUSH
43057: EMPTY
43058: LIST
43059: LIST
43060: PUSH
43061: LD_INT 34
43063: PUSH
43064: LD_INT 53
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 34
43073: PUSH
43074: LD_EXP 93
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 34
43085: PUSH
43086: LD_INT 31
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 34
43095: PUSH
43096: LD_INT 48
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 34
43105: PUSH
43106: LD_INT 8
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: LIST
43117: LIST
43118: LIST
43119: LIST
43120: LIST
43121: LIST
43122: LIST
43123: LIST
43124: LIST
43125: LIST
43126: LIST
43127: LIST
43128: PPUSH
43129: CALL_OW 72
43133: DIFF
43134: ST_TO_ADDR
// end ; end_of_file
43135: LD_VAR 0 3
43139: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43140: LD_INT 0
43142: PPUSH
43143: PPUSH
43144: PPUSH
// if not mc_bases or not skirmish then
43145: LD_EXP 50
43149: NOT
43150: PUSH
43151: LD_EXP 48
43155: NOT
43156: OR
43157: IFFALSE 43161
// exit ;
43159: GO 43326
// for i = 1 to mc_bases do
43161: LD_ADDR_VAR 0 4
43165: PUSH
43166: DOUBLE
43167: LD_INT 1
43169: DEC
43170: ST_TO_ADDR
43171: LD_EXP 50
43175: PUSH
43176: FOR_TO
43177: IFFALSE 43324
// begin if sci in mc_bases [ i ] then
43179: LD_VAR 0 2
43183: PUSH
43184: LD_EXP 50
43188: PUSH
43189: LD_VAR 0 4
43193: ARRAY
43194: IN
43195: IFFALSE 43322
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43197: LD_ADDR_EXP 79
43201: PUSH
43202: LD_EXP 79
43206: PPUSH
43207: LD_VAR 0 4
43211: PUSH
43212: LD_EXP 79
43216: PUSH
43217: LD_VAR 0 4
43221: ARRAY
43222: PUSH
43223: LD_INT 1
43225: PLUS
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PPUSH
43231: LD_VAR 0 1
43235: PPUSH
43236: CALL 52825 0 3
43240: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43241: LD_ADDR_VAR 0 5
43245: PUSH
43246: LD_EXP 50
43250: PUSH
43251: LD_VAR 0 4
43255: ARRAY
43256: PPUSH
43257: LD_INT 2
43259: PUSH
43260: LD_INT 30
43262: PUSH
43263: LD_INT 0
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 30
43272: PUSH
43273: LD_INT 1
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: LIST
43284: PPUSH
43285: CALL_OW 72
43289: PPUSH
43290: LD_VAR 0 1
43294: PPUSH
43295: CALL_OW 74
43299: ST_TO_ADDR
// if tmp then
43300: LD_VAR 0 5
43304: IFFALSE 43320
// ComStandNearbyBuilding ( ape , tmp ) ;
43306: LD_VAR 0 1
43310: PPUSH
43311: LD_VAR 0 5
43315: PPUSH
43316: CALL 49439 0 2
// break ;
43320: GO 43324
// end ; end ;
43322: GO 43176
43324: POP
43325: POP
// end ;
43326: LD_VAR 0 3
43330: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43331: LD_INT 0
43333: PPUSH
43334: PPUSH
43335: PPUSH
// if not mc_bases or not skirmish then
43336: LD_EXP 50
43340: NOT
43341: PUSH
43342: LD_EXP 48
43346: NOT
43347: OR
43348: IFFALSE 43352
// exit ;
43350: GO 43441
// for i = 1 to mc_bases do
43352: LD_ADDR_VAR 0 4
43356: PUSH
43357: DOUBLE
43358: LD_INT 1
43360: DEC
43361: ST_TO_ADDR
43362: LD_EXP 50
43366: PUSH
43367: FOR_TO
43368: IFFALSE 43439
// begin if building in mc_busy_turret_list [ i ] then
43370: LD_VAR 0 1
43374: PUSH
43375: LD_EXP 60
43379: PUSH
43380: LD_VAR 0 4
43384: ARRAY
43385: IN
43386: IFFALSE 43437
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43388: LD_ADDR_VAR 0 5
43392: PUSH
43393: LD_EXP 60
43397: PUSH
43398: LD_VAR 0 4
43402: ARRAY
43403: PUSH
43404: LD_VAR 0 1
43408: DIFF
43409: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43410: LD_ADDR_EXP 60
43414: PUSH
43415: LD_EXP 60
43419: PPUSH
43420: LD_VAR 0 4
43424: PPUSH
43425: LD_VAR 0 5
43429: PPUSH
43430: CALL_OW 1
43434: ST_TO_ADDR
// break ;
43435: GO 43439
// end ; end ;
43437: GO 43367
43439: POP
43440: POP
// end ;
43441: LD_VAR 0 3
43445: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43446: LD_INT 0
43448: PPUSH
43449: PPUSH
43450: PPUSH
// if not mc_bases or not skirmish then
43451: LD_EXP 50
43455: NOT
43456: PUSH
43457: LD_EXP 48
43461: NOT
43462: OR
43463: IFFALSE 43467
// exit ;
43465: GO 43666
// for i = 1 to mc_bases do
43467: LD_ADDR_VAR 0 5
43471: PUSH
43472: DOUBLE
43473: LD_INT 1
43475: DEC
43476: ST_TO_ADDR
43477: LD_EXP 50
43481: PUSH
43482: FOR_TO
43483: IFFALSE 43664
// if building in mc_bases [ i ] then
43485: LD_VAR 0 1
43489: PUSH
43490: LD_EXP 50
43494: PUSH
43495: LD_VAR 0 5
43499: ARRAY
43500: IN
43501: IFFALSE 43662
// begin tmp := mc_bases [ i ] diff building ;
43503: LD_ADDR_VAR 0 6
43507: PUSH
43508: LD_EXP 50
43512: PUSH
43513: LD_VAR 0 5
43517: ARRAY
43518: PUSH
43519: LD_VAR 0 1
43523: DIFF
43524: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43525: LD_ADDR_EXP 50
43529: PUSH
43530: LD_EXP 50
43534: PPUSH
43535: LD_VAR 0 5
43539: PPUSH
43540: LD_VAR 0 6
43544: PPUSH
43545: CALL_OW 1
43549: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43550: LD_VAR 0 1
43554: PUSH
43555: LD_EXP 58
43559: PUSH
43560: LD_VAR 0 5
43564: ARRAY
43565: IN
43566: IFFALSE 43605
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43568: LD_ADDR_EXP 58
43572: PUSH
43573: LD_EXP 58
43577: PPUSH
43578: LD_VAR 0 5
43582: PPUSH
43583: LD_EXP 58
43587: PUSH
43588: LD_VAR 0 5
43592: ARRAY
43593: PUSH
43594: LD_VAR 0 1
43598: DIFF
43599: PPUSH
43600: CALL_OW 1
43604: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43605: LD_VAR 0 1
43609: PUSH
43610: LD_EXP 59
43614: PUSH
43615: LD_VAR 0 5
43619: ARRAY
43620: IN
43621: IFFALSE 43660
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43623: LD_ADDR_EXP 59
43627: PUSH
43628: LD_EXP 59
43632: PPUSH
43633: LD_VAR 0 5
43637: PPUSH
43638: LD_EXP 59
43642: PUSH
43643: LD_VAR 0 5
43647: ARRAY
43648: PUSH
43649: LD_VAR 0 1
43653: DIFF
43654: PPUSH
43655: CALL_OW 1
43659: ST_TO_ADDR
// break ;
43660: GO 43664
// end ;
43662: GO 43482
43664: POP
43665: POP
// end ;
43666: LD_VAR 0 4
43670: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43671: LD_INT 0
43673: PPUSH
43674: PPUSH
43675: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43676: LD_EXP 50
43680: NOT
43681: PUSH
43682: LD_EXP 48
43686: NOT
43687: OR
43688: PUSH
43689: LD_VAR 0 3
43693: PUSH
43694: LD_EXP 76
43698: IN
43699: NOT
43700: OR
43701: IFFALSE 43705
// exit ;
43703: GO 43828
// for i = 1 to mc_vehicles do
43705: LD_ADDR_VAR 0 6
43709: PUSH
43710: DOUBLE
43711: LD_INT 1
43713: DEC
43714: ST_TO_ADDR
43715: LD_EXP 69
43719: PUSH
43720: FOR_TO
43721: IFFALSE 43826
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43723: LD_VAR 0 2
43727: PUSH
43728: LD_EXP 69
43732: PUSH
43733: LD_VAR 0 6
43737: ARRAY
43738: IN
43739: PUSH
43740: LD_VAR 0 1
43744: PUSH
43745: LD_EXP 69
43749: PUSH
43750: LD_VAR 0 6
43754: ARRAY
43755: IN
43756: OR
43757: IFFALSE 43824
// begin tmp := mc_vehicles [ i ] diff old ;
43759: LD_ADDR_VAR 0 7
43763: PUSH
43764: LD_EXP 69
43768: PUSH
43769: LD_VAR 0 6
43773: ARRAY
43774: PUSH
43775: LD_VAR 0 2
43779: DIFF
43780: ST_TO_ADDR
// tmp := tmp diff new ;
43781: LD_ADDR_VAR 0 7
43785: PUSH
43786: LD_VAR 0 7
43790: PUSH
43791: LD_VAR 0 1
43795: DIFF
43796: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43797: LD_ADDR_EXP 69
43801: PUSH
43802: LD_EXP 69
43806: PPUSH
43807: LD_VAR 0 6
43811: PPUSH
43812: LD_VAR 0 7
43816: PPUSH
43817: CALL_OW 1
43821: ST_TO_ADDR
// break ;
43822: GO 43826
// end ;
43824: GO 43720
43826: POP
43827: POP
// end ;
43828: LD_VAR 0 5
43832: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43833: LD_INT 0
43835: PPUSH
43836: PPUSH
43837: PPUSH
43838: PPUSH
// if not mc_bases or not skirmish then
43839: LD_EXP 50
43843: NOT
43844: PUSH
43845: LD_EXP 48
43849: NOT
43850: OR
43851: IFFALSE 43855
// exit ;
43853: GO 44238
// side := GetSide ( vehicle ) ;
43855: LD_ADDR_VAR 0 5
43859: PUSH
43860: LD_VAR 0 1
43864: PPUSH
43865: CALL_OW 255
43869: ST_TO_ADDR
// for i = 1 to mc_bases do
43870: LD_ADDR_VAR 0 4
43874: PUSH
43875: DOUBLE
43876: LD_INT 1
43878: DEC
43879: ST_TO_ADDR
43880: LD_EXP 50
43884: PUSH
43885: FOR_TO
43886: IFFALSE 44236
// begin if factory in mc_bases [ i ] then
43888: LD_VAR 0 2
43892: PUSH
43893: LD_EXP 50
43897: PUSH
43898: LD_VAR 0 4
43902: ARRAY
43903: IN
43904: IFFALSE 44234
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
43906: LD_EXP 72
43910: PUSH
43911: LD_VAR 0 4
43915: ARRAY
43916: PUSH
43917: LD_EXP 61
43921: PUSH
43922: LD_VAR 0 4
43926: ARRAY
43927: LESS
43928: PUSH
43929: LD_VAR 0 1
43933: PPUSH
43934: CALL_OW 264
43938: PUSH
43939: LD_INT 31
43941: PUSH
43942: LD_INT 32
43944: PUSH
43945: LD_INT 51
43947: PUSH
43948: LD_EXP 94
43952: PUSH
43953: LD_INT 12
43955: PUSH
43956: LD_INT 30
43958: PUSH
43959: LD_EXP 93
43963: PUSH
43964: LD_INT 11
43966: PUSH
43967: LD_INT 53
43969: PUSH
43970: LD_INT 14
43972: PUSH
43973: LD_EXP 97
43977: PUSH
43978: LD_INT 29
43980: PUSH
43981: LD_EXP 95
43985: PUSH
43986: LD_INT 13
43988: PUSH
43989: LD_INT 52
43991: PUSH
43992: LD_EXP 99
43996: PUSH
43997: LD_INT 48
43999: PUSH
44000: LD_INT 8
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: LIST
44007: LIST
44008: LIST
44009: LIST
44010: LIST
44011: LIST
44012: LIST
44013: LIST
44014: LIST
44015: LIST
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: LIST
44022: IN
44023: NOT
44024: AND
44025: IFFALSE 44073
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44027: LD_ADDR_EXP 72
44031: PUSH
44032: LD_EXP 72
44036: PPUSH
44037: LD_VAR 0 4
44041: PUSH
44042: LD_EXP 72
44046: PUSH
44047: LD_VAR 0 4
44051: ARRAY
44052: PUSH
44053: LD_INT 1
44055: PLUS
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PPUSH
44061: LD_VAR 0 1
44065: PPUSH
44066: CALL 52825 0 3
44070: ST_TO_ADDR
44071: GO 44117
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44073: LD_ADDR_EXP 69
44077: PUSH
44078: LD_EXP 69
44082: PPUSH
44083: LD_VAR 0 4
44087: PUSH
44088: LD_EXP 69
44092: PUSH
44093: LD_VAR 0 4
44097: ARRAY
44098: PUSH
44099: LD_INT 1
44101: PLUS
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PPUSH
44107: LD_VAR 0 1
44111: PPUSH
44112: CALL 52825 0 3
44116: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44117: LD_VAR 0 1
44121: PPUSH
44122: CALL_OW 263
44126: PUSH
44127: LD_INT 2
44129: EQUAL
44130: IFFALSE 44150
// begin repeat wait ( 0 0$1 ) ;
44132: LD_INT 35
44134: PPUSH
44135: CALL_OW 67
// until IsControledBy ( vehicle ) ;
44139: LD_VAR 0 1
44143: PPUSH
44144: CALL_OW 312
44148: IFFALSE 44132
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44150: LD_VAR 0 1
44154: PPUSH
44155: LD_EXP 74
44159: PUSH
44160: LD_VAR 0 4
44164: ARRAY
44165: PPUSH
44166: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44170: LD_VAR 0 1
44174: PPUSH
44175: CALL_OW 263
44179: PUSH
44180: LD_INT 1
44182: NONEQUAL
44183: IFFALSE 44187
// break ;
44185: GO 44236
// repeat wait ( 0 0$1 ) ;
44187: LD_INT 35
44189: PPUSH
44190: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44194: LD_VAR 0 1
44198: PPUSH
44199: LD_EXP 74
44203: PUSH
44204: LD_VAR 0 4
44208: ARRAY
44209: PPUSH
44210: CALL_OW 308
44214: IFFALSE 44187
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44216: LD_VAR 0 1
44220: PPUSH
44221: CALL_OW 311
44225: PPUSH
44226: CALL_OW 121
// exit ;
44230: POP
44231: POP
44232: GO 44238
// end ; end ;
44234: GO 43885
44236: POP
44237: POP
// end ;
44238: LD_VAR 0 3
44242: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44243: LD_INT 0
44245: PPUSH
44246: PPUSH
44247: PPUSH
44248: PPUSH
// if not mc_bases or not skirmish then
44249: LD_EXP 50
44253: NOT
44254: PUSH
44255: LD_EXP 48
44259: NOT
44260: OR
44261: IFFALSE 44265
// exit ;
44263: GO 44618
// repeat wait ( 0 0$1 ) ;
44265: LD_INT 35
44267: PPUSH
44268: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44272: LD_VAR 0 2
44276: PPUSH
44277: LD_VAR 0 3
44281: PPUSH
44282: CALL_OW 284
44286: IFFALSE 44265
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44288: LD_VAR 0 2
44292: PPUSH
44293: LD_VAR 0 3
44297: PPUSH
44298: CALL_OW 283
44302: PUSH
44303: LD_INT 4
44305: EQUAL
44306: IFFALSE 44310
// exit ;
44308: GO 44618
// for i = 1 to mc_bases do
44310: LD_ADDR_VAR 0 7
44314: PUSH
44315: DOUBLE
44316: LD_INT 1
44318: DEC
44319: ST_TO_ADDR
44320: LD_EXP 50
44324: PUSH
44325: FOR_TO
44326: IFFALSE 44616
// begin if mc_crates_area [ i ] then
44328: LD_EXP 68
44332: PUSH
44333: LD_VAR 0 7
44337: ARRAY
44338: IFFALSE 44449
// for j in mc_crates_area [ i ] do
44340: LD_ADDR_VAR 0 8
44344: PUSH
44345: LD_EXP 68
44349: PUSH
44350: LD_VAR 0 7
44354: ARRAY
44355: PUSH
44356: FOR_IN
44357: IFFALSE 44447
// if InArea ( x , y , j ) then
44359: LD_VAR 0 2
44363: PPUSH
44364: LD_VAR 0 3
44368: PPUSH
44369: LD_VAR 0 8
44373: PPUSH
44374: CALL_OW 309
44378: IFFALSE 44445
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44380: LD_ADDR_EXP 66
44384: PUSH
44385: LD_EXP 66
44389: PPUSH
44390: LD_VAR 0 7
44394: PUSH
44395: LD_EXP 66
44399: PUSH
44400: LD_VAR 0 7
44404: ARRAY
44405: PUSH
44406: LD_INT 1
44408: PLUS
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PPUSH
44414: LD_VAR 0 4
44418: PUSH
44419: LD_VAR 0 2
44423: PUSH
44424: LD_VAR 0 3
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: LIST
44433: PPUSH
44434: CALL 52825 0 3
44438: ST_TO_ADDR
// exit ;
44439: POP
44440: POP
44441: POP
44442: POP
44443: GO 44618
// end ;
44445: GO 44356
44447: POP
44448: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44449: LD_ADDR_VAR 0 9
44453: PUSH
44454: LD_EXP 50
44458: PUSH
44459: LD_VAR 0 7
44463: ARRAY
44464: PPUSH
44465: LD_INT 2
44467: PUSH
44468: LD_INT 30
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 30
44480: PUSH
44481: LD_INT 1
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: LIST
44492: PPUSH
44493: CALL_OW 72
44497: ST_TO_ADDR
// if not depot then
44498: LD_VAR 0 9
44502: NOT
44503: IFFALSE 44507
// continue ;
44505: GO 44325
// for j in depot do
44507: LD_ADDR_VAR 0 8
44511: PUSH
44512: LD_VAR 0 9
44516: PUSH
44517: FOR_IN
44518: IFFALSE 44612
// if GetDistUnitXY ( j , x , y ) < 30 then
44520: LD_VAR 0 8
44524: PPUSH
44525: LD_VAR 0 2
44529: PPUSH
44530: LD_VAR 0 3
44534: PPUSH
44535: CALL_OW 297
44539: PUSH
44540: LD_INT 30
44542: LESS
44543: IFFALSE 44610
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44545: LD_ADDR_EXP 66
44549: PUSH
44550: LD_EXP 66
44554: PPUSH
44555: LD_VAR 0 7
44559: PUSH
44560: LD_EXP 66
44564: PUSH
44565: LD_VAR 0 7
44569: ARRAY
44570: PUSH
44571: LD_INT 1
44573: PLUS
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PPUSH
44579: LD_VAR 0 4
44583: PUSH
44584: LD_VAR 0 2
44588: PUSH
44589: LD_VAR 0 3
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: LIST
44598: PPUSH
44599: CALL 52825 0 3
44603: ST_TO_ADDR
// exit ;
44604: POP
44605: POP
44606: POP
44607: POP
44608: GO 44618
// end ;
44610: GO 44517
44612: POP
44613: POP
// end ;
44614: GO 44325
44616: POP
44617: POP
// end ;
44618: LD_VAR 0 6
44622: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44623: LD_INT 0
44625: PPUSH
44626: PPUSH
44627: PPUSH
44628: PPUSH
// if not mc_bases or not skirmish then
44629: LD_EXP 50
44633: NOT
44634: PUSH
44635: LD_EXP 48
44639: NOT
44640: OR
44641: IFFALSE 44645
// exit ;
44643: GO 44922
// side := GetSide ( lab ) ;
44645: LD_ADDR_VAR 0 4
44649: PUSH
44650: LD_VAR 0 2
44654: PPUSH
44655: CALL_OW 255
44659: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44660: LD_VAR 0 4
44664: PUSH
44665: LD_EXP 76
44669: IN
44670: NOT
44671: PUSH
44672: LD_EXP 77
44676: NOT
44677: OR
44678: PUSH
44679: LD_EXP 50
44683: NOT
44684: OR
44685: IFFALSE 44689
// exit ;
44687: GO 44922
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44689: LD_ADDR_EXP 77
44693: PUSH
44694: LD_EXP 77
44698: PPUSH
44699: LD_VAR 0 4
44703: PPUSH
44704: LD_EXP 77
44708: PUSH
44709: LD_VAR 0 4
44713: ARRAY
44714: PUSH
44715: LD_VAR 0 1
44719: DIFF
44720: PPUSH
44721: CALL_OW 1
44725: ST_TO_ADDR
// for i = 1 to mc_bases do
44726: LD_ADDR_VAR 0 5
44730: PUSH
44731: DOUBLE
44732: LD_INT 1
44734: DEC
44735: ST_TO_ADDR
44736: LD_EXP 50
44740: PUSH
44741: FOR_TO
44742: IFFALSE 44920
// begin if lab in mc_bases [ i ] then
44744: LD_VAR 0 2
44748: PUSH
44749: LD_EXP 50
44753: PUSH
44754: LD_VAR 0 5
44758: ARRAY
44759: IN
44760: IFFALSE 44918
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44762: LD_VAR 0 1
44766: PUSH
44767: LD_INT 11
44769: PUSH
44770: LD_INT 4
44772: PUSH
44773: LD_INT 3
44775: PUSH
44776: LD_INT 2
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: IN
44785: PUSH
44786: LD_EXP 80
44790: PUSH
44791: LD_VAR 0 5
44795: ARRAY
44796: AND
44797: IFFALSE 44918
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44799: LD_ADDR_VAR 0 6
44803: PUSH
44804: LD_EXP 80
44808: PUSH
44809: LD_VAR 0 5
44813: ARRAY
44814: PUSH
44815: LD_INT 1
44817: ARRAY
44818: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44819: LD_ADDR_EXP 80
44823: PUSH
44824: LD_EXP 80
44828: PPUSH
44829: LD_VAR 0 5
44833: PPUSH
44834: EMPTY
44835: PPUSH
44836: CALL_OW 1
44840: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44841: LD_VAR 0 6
44845: PPUSH
44846: LD_INT 0
44848: PPUSH
44849: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44853: LD_VAR 0 6
44857: PPUSH
44858: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44862: LD_ADDR_EXP 79
44866: PUSH
44867: LD_EXP 79
44871: PPUSH
44872: LD_VAR 0 5
44876: PPUSH
44877: LD_EXP 79
44881: PUSH
44882: LD_VAR 0 5
44886: ARRAY
44887: PPUSH
44888: LD_INT 1
44890: PPUSH
44891: LD_VAR 0 6
44895: PPUSH
44896: CALL_OW 2
44900: PPUSH
44901: CALL_OW 1
44905: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44906: LD_VAR 0 5
44910: PPUSH
44911: LD_INT 112
44913: PPUSH
44914: CALL 21867 0 2
// end ; end ; end ;
44918: GO 44741
44920: POP
44921: POP
// end ;
44922: LD_VAR 0 3
44926: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44927: LD_INT 0
44929: PPUSH
44930: PPUSH
44931: PPUSH
44932: PPUSH
44933: PPUSH
44934: PPUSH
44935: PPUSH
44936: PPUSH
// if not mc_bases or not skirmish then
44937: LD_EXP 50
44941: NOT
44942: PUSH
44943: LD_EXP 48
44947: NOT
44948: OR
44949: IFFALSE 44953
// exit ;
44951: GO 46324
// for i = 1 to mc_bases do
44953: LD_ADDR_VAR 0 3
44957: PUSH
44958: DOUBLE
44959: LD_INT 1
44961: DEC
44962: ST_TO_ADDR
44963: LD_EXP 50
44967: PUSH
44968: FOR_TO
44969: IFFALSE 46322
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44971: LD_VAR 0 1
44975: PUSH
44976: LD_EXP 50
44980: PUSH
44981: LD_VAR 0 3
44985: ARRAY
44986: IN
44987: PUSH
44988: LD_VAR 0 1
44992: PUSH
44993: LD_EXP 57
44997: PUSH
44998: LD_VAR 0 3
45002: ARRAY
45003: IN
45004: OR
45005: PUSH
45006: LD_VAR 0 1
45010: PUSH
45011: LD_EXP 72
45015: PUSH
45016: LD_VAR 0 3
45020: ARRAY
45021: IN
45022: OR
45023: PUSH
45024: LD_VAR 0 1
45028: PUSH
45029: LD_EXP 69
45033: PUSH
45034: LD_VAR 0 3
45038: ARRAY
45039: IN
45040: OR
45041: PUSH
45042: LD_VAR 0 1
45046: PUSH
45047: LD_EXP 79
45051: PUSH
45052: LD_VAR 0 3
45056: ARRAY
45057: IN
45058: OR
45059: PUSH
45060: LD_VAR 0 1
45064: PUSH
45065: LD_EXP 80
45069: PUSH
45070: LD_VAR 0 3
45074: ARRAY
45075: IN
45076: OR
45077: IFFALSE 46320
// begin if un in mc_ape [ i ] then
45079: LD_VAR 0 1
45083: PUSH
45084: LD_EXP 79
45088: PUSH
45089: LD_VAR 0 3
45093: ARRAY
45094: IN
45095: IFFALSE 45134
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45097: LD_ADDR_EXP 79
45101: PUSH
45102: LD_EXP 79
45106: PPUSH
45107: LD_VAR 0 3
45111: PPUSH
45112: LD_EXP 79
45116: PUSH
45117: LD_VAR 0 3
45121: ARRAY
45122: PUSH
45123: LD_VAR 0 1
45127: DIFF
45128: PPUSH
45129: CALL_OW 1
45133: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45134: LD_VAR 0 1
45138: PUSH
45139: LD_EXP 80
45143: PUSH
45144: LD_VAR 0 3
45148: ARRAY
45149: IN
45150: IFFALSE 45174
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45152: LD_ADDR_EXP 80
45156: PUSH
45157: LD_EXP 80
45161: PPUSH
45162: LD_VAR 0 3
45166: PPUSH
45167: EMPTY
45168: PPUSH
45169: CALL_OW 1
45173: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45174: LD_VAR 0 1
45178: PPUSH
45179: CALL_OW 247
45183: PUSH
45184: LD_INT 2
45186: EQUAL
45187: PUSH
45188: LD_VAR 0 1
45192: PPUSH
45193: CALL_OW 110
45197: PUSH
45198: LD_INT 20
45200: EQUAL
45201: PUSH
45202: LD_VAR 0 1
45206: PUSH
45207: LD_EXP 72
45211: PUSH
45212: LD_VAR 0 3
45216: ARRAY
45217: IN
45218: OR
45219: PUSH
45220: LD_VAR 0 1
45224: PPUSH
45225: CALL_OW 264
45229: PUSH
45230: LD_INT 12
45232: PUSH
45233: LD_INT 51
45235: PUSH
45236: LD_EXP 94
45240: PUSH
45241: LD_INT 32
45243: PUSH
45244: LD_INT 13
45246: PUSH
45247: LD_INT 52
45249: PUSH
45250: LD_INT 31
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: IN
45262: OR
45263: AND
45264: IFFALSE 45572
// begin if un in mc_defender [ i ] then
45266: LD_VAR 0 1
45270: PUSH
45271: LD_EXP 72
45275: PUSH
45276: LD_VAR 0 3
45280: ARRAY
45281: IN
45282: IFFALSE 45321
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45284: LD_ADDR_EXP 72
45288: PUSH
45289: LD_EXP 72
45293: PPUSH
45294: LD_VAR 0 3
45298: PPUSH
45299: LD_EXP 72
45303: PUSH
45304: LD_VAR 0 3
45308: ARRAY
45309: PUSH
45310: LD_VAR 0 1
45314: DIFF
45315: PPUSH
45316: CALL_OW 1
45320: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45321: LD_ADDR_VAR 0 8
45325: PUSH
45326: LD_VAR 0 3
45330: PPUSH
45331: LD_INT 3
45333: PPUSH
45334: CALL 41971 0 2
45338: ST_TO_ADDR
// if fac then
45339: LD_VAR 0 8
45343: IFFALSE 45572
// begin for j in fac do
45345: LD_ADDR_VAR 0 4
45349: PUSH
45350: LD_VAR 0 8
45354: PUSH
45355: FOR_IN
45356: IFFALSE 45570
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45358: LD_ADDR_VAR 0 9
45362: PUSH
45363: LD_VAR 0 8
45367: PPUSH
45368: LD_VAR 0 1
45372: PPUSH
45373: CALL_OW 265
45377: PPUSH
45378: LD_VAR 0 1
45382: PPUSH
45383: CALL_OW 262
45387: PPUSH
45388: LD_VAR 0 1
45392: PPUSH
45393: CALL_OW 263
45397: PPUSH
45398: LD_VAR 0 1
45402: PPUSH
45403: CALL_OW 264
45407: PPUSH
45408: CALL 50357 0 5
45412: ST_TO_ADDR
// if components then
45413: LD_VAR 0 9
45417: IFFALSE 45568
// begin if GetWeapon ( un ) = ar_control_tower then
45419: LD_VAR 0 1
45423: PPUSH
45424: CALL_OW 264
45428: PUSH
45429: LD_INT 31
45431: EQUAL
45432: IFFALSE 45549
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45434: LD_VAR 0 1
45438: PPUSH
45439: CALL_OW 311
45443: PPUSH
45444: LD_INT 0
45446: PPUSH
45447: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45451: LD_ADDR_EXP 90
45455: PUSH
45456: LD_EXP 90
45460: PPUSH
45461: LD_VAR 0 3
45465: PPUSH
45466: LD_EXP 90
45470: PUSH
45471: LD_VAR 0 3
45475: ARRAY
45476: PUSH
45477: LD_VAR 0 1
45481: PPUSH
45482: CALL_OW 311
45486: DIFF
45487: PPUSH
45488: CALL_OW 1
45492: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45493: LD_ADDR_VAR 0 7
45497: PUSH
45498: LD_EXP 71
45502: PUSH
45503: LD_VAR 0 3
45507: ARRAY
45508: PPUSH
45509: LD_INT 1
45511: PPUSH
45512: LD_VAR 0 9
45516: PPUSH
45517: CALL_OW 2
45521: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45522: LD_ADDR_EXP 71
45526: PUSH
45527: LD_EXP 71
45531: PPUSH
45532: LD_VAR 0 3
45536: PPUSH
45537: LD_VAR 0 7
45541: PPUSH
45542: CALL_OW 1
45546: ST_TO_ADDR
// end else
45547: GO 45566
// MC_InsertProduceList ( i , [ components ] ) ;
45549: LD_VAR 0 3
45553: PPUSH
45554: LD_VAR 0 9
45558: PUSH
45559: EMPTY
45560: LIST
45561: PPUSH
45562: CALL 41516 0 2
// break ;
45566: GO 45570
// end ; end ;
45568: GO 45355
45570: POP
45571: POP
// end ; end ; if GetType ( un ) = unit_building then
45572: LD_VAR 0 1
45576: PPUSH
45577: CALL_OW 247
45581: PUSH
45582: LD_INT 3
45584: EQUAL
45585: IFFALSE 45988
// begin btype := GetBType ( un ) ;
45587: LD_ADDR_VAR 0 5
45591: PUSH
45592: LD_VAR 0 1
45596: PPUSH
45597: CALL_OW 266
45601: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45602: LD_VAR 0 5
45606: PUSH
45607: LD_INT 29
45609: PUSH
45610: LD_INT 30
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: IN
45617: IFFALSE 45690
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45619: LD_VAR 0 1
45623: PPUSH
45624: CALL_OW 250
45628: PPUSH
45629: LD_VAR 0 1
45633: PPUSH
45634: CALL_OW 251
45638: PPUSH
45639: LD_VAR 0 1
45643: PPUSH
45644: CALL_OW 255
45648: PPUSH
45649: CALL_OW 440
45653: NOT
45654: IFFALSE 45690
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45656: LD_VAR 0 1
45660: PPUSH
45661: CALL_OW 250
45665: PPUSH
45666: LD_VAR 0 1
45670: PPUSH
45671: CALL_OW 251
45675: PPUSH
45676: LD_VAR 0 1
45680: PPUSH
45681: CALL_OW 255
45685: PPUSH
45686: CALL_OW 441
// end ; if btype = b_warehouse then
45690: LD_VAR 0 5
45694: PUSH
45695: LD_INT 1
45697: EQUAL
45698: IFFALSE 45716
// begin btype := b_depot ;
45700: LD_ADDR_VAR 0 5
45704: PUSH
45705: LD_INT 0
45707: ST_TO_ADDR
// pos := 1 ;
45708: LD_ADDR_VAR 0 6
45712: PUSH
45713: LD_INT 1
45715: ST_TO_ADDR
// end ; if btype = b_factory then
45716: LD_VAR 0 5
45720: PUSH
45721: LD_INT 3
45723: EQUAL
45724: IFFALSE 45742
// begin btype := b_workshop ;
45726: LD_ADDR_VAR 0 5
45730: PUSH
45731: LD_INT 2
45733: ST_TO_ADDR
// pos := 1 ;
45734: LD_ADDR_VAR 0 6
45738: PUSH
45739: LD_INT 1
45741: ST_TO_ADDR
// end ; if btype = b_barracks then
45742: LD_VAR 0 5
45746: PUSH
45747: LD_INT 5
45749: EQUAL
45750: IFFALSE 45760
// btype := b_armoury ;
45752: LD_ADDR_VAR 0 5
45756: PUSH
45757: LD_INT 4
45759: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45760: LD_VAR 0 5
45764: PUSH
45765: LD_INT 7
45767: PUSH
45768: LD_INT 8
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: IN
45775: IFFALSE 45785
// btype := b_lab ;
45777: LD_ADDR_VAR 0 5
45781: PUSH
45782: LD_INT 6
45784: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45785: LD_ADDR_EXP 55
45789: PUSH
45790: LD_EXP 55
45794: PPUSH
45795: LD_VAR 0 3
45799: PUSH
45800: LD_EXP 55
45804: PUSH
45805: LD_VAR 0 3
45809: ARRAY
45810: PUSH
45811: LD_INT 1
45813: PLUS
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: PPUSH
45819: LD_VAR 0 5
45823: PUSH
45824: LD_VAR 0 1
45828: PPUSH
45829: CALL_OW 250
45833: PUSH
45834: LD_VAR 0 1
45838: PPUSH
45839: CALL_OW 251
45843: PUSH
45844: LD_VAR 0 1
45848: PPUSH
45849: CALL_OW 254
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: PPUSH
45860: CALL 52825 0 3
45864: ST_TO_ADDR
// if pos = 1 then
45865: LD_VAR 0 6
45869: PUSH
45870: LD_INT 1
45872: EQUAL
45873: IFFALSE 45988
// begin tmp := mc_build_list [ i ] ;
45875: LD_ADDR_VAR 0 7
45879: PUSH
45880: LD_EXP 55
45884: PUSH
45885: LD_VAR 0 3
45889: ARRAY
45890: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45891: LD_VAR 0 7
45895: PPUSH
45896: LD_INT 2
45898: PUSH
45899: LD_INT 30
45901: PUSH
45902: LD_INT 0
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 30
45911: PUSH
45912: LD_INT 1
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: LIST
45923: PPUSH
45924: CALL_OW 72
45928: IFFALSE 45938
// pos := 2 ;
45930: LD_ADDR_VAR 0 6
45934: PUSH
45935: LD_INT 2
45937: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45938: LD_ADDR_VAR 0 7
45942: PUSH
45943: LD_VAR 0 7
45947: PPUSH
45948: LD_VAR 0 6
45952: PPUSH
45953: LD_VAR 0 7
45957: PPUSH
45958: CALL 53151 0 3
45962: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45963: LD_ADDR_EXP 55
45967: PUSH
45968: LD_EXP 55
45972: PPUSH
45973: LD_VAR 0 3
45977: PPUSH
45978: LD_VAR 0 7
45982: PPUSH
45983: CALL_OW 1
45987: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45988: LD_VAR 0 1
45992: PUSH
45993: LD_EXP 50
45997: PUSH
45998: LD_VAR 0 3
46002: ARRAY
46003: IN
46004: IFFALSE 46043
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46006: LD_ADDR_EXP 50
46010: PUSH
46011: LD_EXP 50
46015: PPUSH
46016: LD_VAR 0 3
46020: PPUSH
46021: LD_EXP 50
46025: PUSH
46026: LD_VAR 0 3
46030: ARRAY
46031: PUSH
46032: LD_VAR 0 1
46036: DIFF
46037: PPUSH
46038: CALL_OW 1
46042: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46043: LD_VAR 0 1
46047: PUSH
46048: LD_EXP 57
46052: PUSH
46053: LD_VAR 0 3
46057: ARRAY
46058: IN
46059: IFFALSE 46098
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46061: LD_ADDR_EXP 57
46065: PUSH
46066: LD_EXP 57
46070: PPUSH
46071: LD_VAR 0 3
46075: PPUSH
46076: LD_EXP 57
46080: PUSH
46081: LD_VAR 0 3
46085: ARRAY
46086: PUSH
46087: LD_VAR 0 1
46091: DIFF
46092: PPUSH
46093: CALL_OW 1
46097: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46098: LD_VAR 0 1
46102: PUSH
46103: LD_EXP 69
46107: PUSH
46108: LD_VAR 0 3
46112: ARRAY
46113: IN
46114: IFFALSE 46153
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46116: LD_ADDR_EXP 69
46120: PUSH
46121: LD_EXP 69
46125: PPUSH
46126: LD_VAR 0 3
46130: PPUSH
46131: LD_EXP 69
46135: PUSH
46136: LD_VAR 0 3
46140: ARRAY
46141: PUSH
46142: LD_VAR 0 1
46146: DIFF
46147: PPUSH
46148: CALL_OW 1
46152: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46153: LD_VAR 0 1
46157: PUSH
46158: LD_EXP 72
46162: PUSH
46163: LD_VAR 0 3
46167: ARRAY
46168: IN
46169: IFFALSE 46208
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46171: LD_ADDR_EXP 72
46175: PUSH
46176: LD_EXP 72
46180: PPUSH
46181: LD_VAR 0 3
46185: PPUSH
46186: LD_EXP 72
46190: PUSH
46191: LD_VAR 0 3
46195: ARRAY
46196: PUSH
46197: LD_VAR 0 1
46201: DIFF
46202: PPUSH
46203: CALL_OW 1
46207: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46208: LD_VAR 0 1
46212: PUSH
46213: LD_EXP 59
46217: PUSH
46218: LD_VAR 0 3
46222: ARRAY
46223: IN
46224: IFFALSE 46263
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46226: LD_ADDR_EXP 59
46230: PUSH
46231: LD_EXP 59
46235: PPUSH
46236: LD_VAR 0 3
46240: PPUSH
46241: LD_EXP 59
46245: PUSH
46246: LD_VAR 0 3
46250: ARRAY
46251: PUSH
46252: LD_VAR 0 1
46256: DIFF
46257: PPUSH
46258: CALL_OW 1
46262: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46263: LD_VAR 0 1
46267: PUSH
46268: LD_EXP 58
46272: PUSH
46273: LD_VAR 0 3
46277: ARRAY
46278: IN
46279: IFFALSE 46318
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46281: LD_ADDR_EXP 58
46285: PUSH
46286: LD_EXP 58
46290: PPUSH
46291: LD_VAR 0 3
46295: PPUSH
46296: LD_EXP 58
46300: PUSH
46301: LD_VAR 0 3
46305: ARRAY
46306: PUSH
46307: LD_VAR 0 1
46311: DIFF
46312: PPUSH
46313: CALL_OW 1
46317: ST_TO_ADDR
// end ; break ;
46318: GO 46322
// end ;
46320: GO 44968
46322: POP
46323: POP
// end ;
46324: LD_VAR 0 2
46328: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46329: LD_INT 0
46331: PPUSH
46332: PPUSH
46333: PPUSH
// if not mc_bases or not skirmish then
46334: LD_EXP 50
46338: NOT
46339: PUSH
46340: LD_EXP 48
46344: NOT
46345: OR
46346: IFFALSE 46350
// exit ;
46348: GO 46565
// for i = 1 to mc_bases do
46350: LD_ADDR_VAR 0 3
46354: PUSH
46355: DOUBLE
46356: LD_INT 1
46358: DEC
46359: ST_TO_ADDR
46360: LD_EXP 50
46364: PUSH
46365: FOR_TO
46366: IFFALSE 46563
// begin if building in mc_construct_list [ i ] then
46368: LD_VAR 0 1
46372: PUSH
46373: LD_EXP 57
46377: PUSH
46378: LD_VAR 0 3
46382: ARRAY
46383: IN
46384: IFFALSE 46561
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46386: LD_ADDR_EXP 57
46390: PUSH
46391: LD_EXP 57
46395: PPUSH
46396: LD_VAR 0 3
46400: PPUSH
46401: LD_EXP 57
46405: PUSH
46406: LD_VAR 0 3
46410: ARRAY
46411: PUSH
46412: LD_VAR 0 1
46416: DIFF
46417: PPUSH
46418: CALL_OW 1
46422: ST_TO_ADDR
// if building in mc_lab [ i ] then
46423: LD_VAR 0 1
46427: PUSH
46428: LD_EXP 83
46432: PUSH
46433: LD_VAR 0 3
46437: ARRAY
46438: IN
46439: IFFALSE 46494
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46441: LD_ADDR_EXP 84
46445: PUSH
46446: LD_EXP 84
46450: PPUSH
46451: LD_VAR 0 3
46455: PPUSH
46456: LD_EXP 84
46460: PUSH
46461: LD_VAR 0 3
46465: ARRAY
46466: PPUSH
46467: LD_INT 1
46469: PPUSH
46470: LD_EXP 84
46474: PUSH
46475: LD_VAR 0 3
46479: ARRAY
46480: PPUSH
46481: LD_INT 0
46483: PPUSH
46484: CALL 52243 0 4
46488: PPUSH
46489: CALL_OW 1
46493: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46494: LD_VAR 0 1
46498: PUSH
46499: LD_EXP 50
46503: PUSH
46504: LD_VAR 0 3
46508: ARRAY
46509: IN
46510: NOT
46511: IFFALSE 46557
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46513: LD_ADDR_EXP 50
46517: PUSH
46518: LD_EXP 50
46522: PPUSH
46523: LD_VAR 0 3
46527: PUSH
46528: LD_EXP 50
46532: PUSH
46533: LD_VAR 0 3
46537: ARRAY
46538: PUSH
46539: LD_INT 1
46541: PLUS
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PPUSH
46547: LD_VAR 0 1
46551: PPUSH
46552: CALL 52825 0 3
46556: ST_TO_ADDR
// exit ;
46557: POP
46558: POP
46559: GO 46565
// end ; end ;
46561: GO 46365
46563: POP
46564: POP
// end ;
46565: LD_VAR 0 2
46569: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46570: LD_INT 0
46572: PPUSH
46573: PPUSH
46574: PPUSH
46575: PPUSH
46576: PPUSH
46577: PPUSH
46578: PPUSH
// if not mc_bases or not skirmish then
46579: LD_EXP 50
46583: NOT
46584: PUSH
46585: LD_EXP 48
46589: NOT
46590: OR
46591: IFFALSE 46595
// exit ;
46593: GO 47256
// for i = 1 to mc_bases do
46595: LD_ADDR_VAR 0 3
46599: PUSH
46600: DOUBLE
46601: LD_INT 1
46603: DEC
46604: ST_TO_ADDR
46605: LD_EXP 50
46609: PUSH
46610: FOR_TO
46611: IFFALSE 47254
// begin if building in mc_construct_list [ i ] then
46613: LD_VAR 0 1
46617: PUSH
46618: LD_EXP 57
46622: PUSH
46623: LD_VAR 0 3
46627: ARRAY
46628: IN
46629: IFFALSE 47252
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46631: LD_ADDR_EXP 57
46635: PUSH
46636: LD_EXP 57
46640: PPUSH
46641: LD_VAR 0 3
46645: PPUSH
46646: LD_EXP 57
46650: PUSH
46651: LD_VAR 0 3
46655: ARRAY
46656: PUSH
46657: LD_VAR 0 1
46661: DIFF
46662: PPUSH
46663: CALL_OW 1
46667: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46668: LD_ADDR_EXP 50
46672: PUSH
46673: LD_EXP 50
46677: PPUSH
46678: LD_VAR 0 3
46682: PUSH
46683: LD_EXP 50
46687: PUSH
46688: LD_VAR 0 3
46692: ARRAY
46693: PUSH
46694: LD_INT 1
46696: PLUS
46697: PUSH
46698: EMPTY
46699: LIST
46700: LIST
46701: PPUSH
46702: LD_VAR 0 1
46706: PPUSH
46707: CALL 52825 0 3
46711: ST_TO_ADDR
// btype := GetBType ( building ) ;
46712: LD_ADDR_VAR 0 5
46716: PUSH
46717: LD_VAR 0 1
46721: PPUSH
46722: CALL_OW 266
46726: ST_TO_ADDR
// side := GetSide ( building ) ;
46727: LD_ADDR_VAR 0 8
46731: PUSH
46732: LD_VAR 0 1
46736: PPUSH
46737: CALL_OW 255
46741: ST_TO_ADDR
// if btype = b_lab then
46742: LD_VAR 0 5
46746: PUSH
46747: LD_INT 6
46749: EQUAL
46750: IFFALSE 46800
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46752: LD_ADDR_EXP 83
46756: PUSH
46757: LD_EXP 83
46761: PPUSH
46762: LD_VAR 0 3
46766: PUSH
46767: LD_EXP 83
46771: PUSH
46772: LD_VAR 0 3
46776: ARRAY
46777: PUSH
46778: LD_INT 1
46780: PLUS
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PPUSH
46786: LD_VAR 0 1
46790: PPUSH
46791: CALL 52825 0 3
46795: ST_TO_ADDR
// exit ;
46796: POP
46797: POP
46798: GO 47256
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46800: LD_VAR 0 5
46804: PUSH
46805: LD_INT 0
46807: PUSH
46808: LD_INT 2
46810: PUSH
46811: LD_INT 4
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: LIST
46818: IN
46819: IFFALSE 46943
// begin if btype = b_armoury then
46821: LD_VAR 0 5
46825: PUSH
46826: LD_INT 4
46828: EQUAL
46829: IFFALSE 46839
// btype := b_barracks ;
46831: LD_ADDR_VAR 0 5
46835: PUSH
46836: LD_INT 5
46838: ST_TO_ADDR
// if btype = b_depot then
46839: LD_VAR 0 5
46843: PUSH
46844: LD_INT 0
46846: EQUAL
46847: IFFALSE 46857
// btype := b_warehouse ;
46849: LD_ADDR_VAR 0 5
46853: PUSH
46854: LD_INT 1
46856: ST_TO_ADDR
// if btype = b_workshop then
46857: LD_VAR 0 5
46861: PUSH
46862: LD_INT 2
46864: EQUAL
46865: IFFALSE 46875
// btype := b_factory ;
46867: LD_ADDR_VAR 0 5
46871: PUSH
46872: LD_INT 3
46874: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46875: LD_VAR 0 5
46879: PPUSH
46880: LD_VAR 0 8
46884: PPUSH
46885: CALL_OW 323
46889: PUSH
46890: LD_INT 1
46892: EQUAL
46893: IFFALSE 46939
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46895: LD_ADDR_EXP 82
46899: PUSH
46900: LD_EXP 82
46904: PPUSH
46905: LD_VAR 0 3
46909: PUSH
46910: LD_EXP 82
46914: PUSH
46915: LD_VAR 0 3
46919: ARRAY
46920: PUSH
46921: LD_INT 1
46923: PLUS
46924: PUSH
46925: EMPTY
46926: LIST
46927: LIST
46928: PPUSH
46929: LD_VAR 0 1
46933: PPUSH
46934: CALL 52825 0 3
46938: ST_TO_ADDR
// exit ;
46939: POP
46940: POP
46941: GO 47256
// end ; if btype in [ b_bunker , b_turret ] then
46943: LD_VAR 0 5
46947: PUSH
46948: LD_INT 32
46950: PUSH
46951: LD_INT 33
46953: PUSH
46954: EMPTY
46955: LIST
46956: LIST
46957: IN
46958: IFFALSE 47248
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46960: LD_ADDR_EXP 58
46964: PUSH
46965: LD_EXP 58
46969: PPUSH
46970: LD_VAR 0 3
46974: PUSH
46975: LD_EXP 58
46979: PUSH
46980: LD_VAR 0 3
46984: ARRAY
46985: PUSH
46986: LD_INT 1
46988: PLUS
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PPUSH
46994: LD_VAR 0 1
46998: PPUSH
46999: CALL 52825 0 3
47003: ST_TO_ADDR
// if btype = b_bunker then
47004: LD_VAR 0 5
47008: PUSH
47009: LD_INT 32
47011: EQUAL
47012: IFFALSE 47248
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47014: LD_ADDR_EXP 59
47018: PUSH
47019: LD_EXP 59
47023: PPUSH
47024: LD_VAR 0 3
47028: PUSH
47029: LD_EXP 59
47033: PUSH
47034: LD_VAR 0 3
47038: ARRAY
47039: PUSH
47040: LD_INT 1
47042: PLUS
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: PPUSH
47048: LD_VAR 0 1
47052: PPUSH
47053: CALL 52825 0 3
47057: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47058: LD_ADDR_VAR 0 6
47062: PUSH
47063: LD_EXP 50
47067: PUSH
47068: LD_VAR 0 3
47072: ARRAY
47073: PPUSH
47074: LD_INT 25
47076: PUSH
47077: LD_INT 1
47079: PUSH
47080: EMPTY
47081: LIST
47082: LIST
47083: PUSH
47084: LD_INT 3
47086: PUSH
47087: LD_INT 54
47089: PUSH
47090: EMPTY
47091: LIST
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PPUSH
47101: CALL_OW 72
47105: ST_TO_ADDR
// if tmp then
47106: LD_VAR 0 6
47110: IFFALSE 47116
// exit ;
47112: POP
47113: POP
47114: GO 47256
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47116: LD_ADDR_VAR 0 6
47120: PUSH
47121: LD_EXP 50
47125: PUSH
47126: LD_VAR 0 3
47130: ARRAY
47131: PPUSH
47132: LD_INT 2
47134: PUSH
47135: LD_INT 30
47137: PUSH
47138: LD_INT 4
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 30
47147: PUSH
47148: LD_INT 5
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: LIST
47159: PPUSH
47160: CALL_OW 72
47164: ST_TO_ADDR
// if not tmp then
47165: LD_VAR 0 6
47169: NOT
47170: IFFALSE 47176
// exit ;
47172: POP
47173: POP
47174: GO 47256
// for j in tmp do
47176: LD_ADDR_VAR 0 4
47180: PUSH
47181: LD_VAR 0 6
47185: PUSH
47186: FOR_IN
47187: IFFALSE 47246
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47189: LD_ADDR_VAR 0 7
47193: PUSH
47194: LD_VAR 0 4
47198: PPUSH
47199: CALL_OW 313
47203: PPUSH
47204: LD_INT 25
47206: PUSH
47207: LD_INT 1
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: PPUSH
47214: CALL_OW 72
47218: ST_TO_ADDR
// if units then
47219: LD_VAR 0 7
47223: IFFALSE 47244
// begin ComExitBuilding ( units [ 1 ] ) ;
47225: LD_VAR 0 7
47229: PUSH
47230: LD_INT 1
47232: ARRAY
47233: PPUSH
47234: CALL_OW 122
// exit ;
47238: POP
47239: POP
47240: POP
47241: POP
47242: GO 47256
// end ; end ;
47244: GO 47186
47246: POP
47247: POP
// end ; end ; exit ;
47248: POP
47249: POP
47250: GO 47256
// end ; end ;
47252: GO 46610
47254: POP
47255: POP
// end ;
47256: LD_VAR 0 2
47260: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47261: LD_INT 0
47263: PPUSH
47264: PPUSH
47265: PPUSH
47266: PPUSH
47267: PPUSH
47268: PPUSH
47269: PPUSH
// if not mc_bases or not skirmish then
47270: LD_EXP 50
47274: NOT
47275: PUSH
47276: LD_EXP 48
47280: NOT
47281: OR
47282: IFFALSE 47286
// exit ;
47284: GO 47517
// btype := GetBType ( building ) ;
47286: LD_ADDR_VAR 0 6
47290: PUSH
47291: LD_VAR 0 1
47295: PPUSH
47296: CALL_OW 266
47300: ST_TO_ADDR
// x := GetX ( building ) ;
47301: LD_ADDR_VAR 0 7
47305: PUSH
47306: LD_VAR 0 1
47310: PPUSH
47311: CALL_OW 250
47315: ST_TO_ADDR
// y := GetY ( building ) ;
47316: LD_ADDR_VAR 0 8
47320: PUSH
47321: LD_VAR 0 1
47325: PPUSH
47326: CALL_OW 251
47330: ST_TO_ADDR
// d := GetDir ( building ) ;
47331: LD_ADDR_VAR 0 9
47335: PUSH
47336: LD_VAR 0 1
47340: PPUSH
47341: CALL_OW 254
47345: ST_TO_ADDR
// for i = 1 to mc_bases do
47346: LD_ADDR_VAR 0 4
47350: PUSH
47351: DOUBLE
47352: LD_INT 1
47354: DEC
47355: ST_TO_ADDR
47356: LD_EXP 50
47360: PUSH
47361: FOR_TO
47362: IFFALSE 47515
// begin if not mc_build_list [ i ] then
47364: LD_EXP 55
47368: PUSH
47369: LD_VAR 0 4
47373: ARRAY
47374: NOT
47375: IFFALSE 47379
// continue ;
47377: GO 47361
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
47379: LD_VAR 0 6
47383: PUSH
47384: LD_VAR 0 7
47388: PUSH
47389: LD_VAR 0 8
47393: PUSH
47394: LD_VAR 0 9
47398: PUSH
47399: EMPTY
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: PPUSH
47405: LD_EXP 55
47409: PUSH
47410: LD_VAR 0 4
47414: ARRAY
47415: PUSH
47416: LD_INT 1
47418: ARRAY
47419: PPUSH
47420: CALL 58994 0 2
47424: IFFALSE 47513
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
47426: LD_ADDR_EXP 55
47430: PUSH
47431: LD_EXP 55
47435: PPUSH
47436: LD_VAR 0 4
47440: PPUSH
47441: LD_EXP 55
47445: PUSH
47446: LD_VAR 0 4
47450: ARRAY
47451: PPUSH
47452: LD_INT 1
47454: PPUSH
47455: CALL_OW 3
47459: PPUSH
47460: CALL_OW 1
47464: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47465: LD_ADDR_EXP 57
47469: PUSH
47470: LD_EXP 57
47474: PPUSH
47475: LD_VAR 0 4
47479: PUSH
47480: LD_EXP 57
47484: PUSH
47485: LD_VAR 0 4
47489: ARRAY
47490: PUSH
47491: LD_INT 1
47493: PLUS
47494: PUSH
47495: EMPTY
47496: LIST
47497: LIST
47498: PPUSH
47499: LD_VAR 0 1
47503: PPUSH
47504: CALL 52825 0 3
47508: ST_TO_ADDR
// exit ;
47509: POP
47510: POP
47511: GO 47517
// end ; end ;
47513: GO 47361
47515: POP
47516: POP
// end ;
47517: LD_VAR 0 3
47521: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47522: LD_INT 0
47524: PPUSH
47525: PPUSH
47526: PPUSH
// if not mc_bases or not skirmish then
47527: LD_EXP 50
47531: NOT
47532: PUSH
47533: LD_EXP 48
47537: NOT
47538: OR
47539: IFFALSE 47543
// exit ;
47541: GO 47733
// for i = 1 to mc_bases do
47543: LD_ADDR_VAR 0 4
47547: PUSH
47548: DOUBLE
47549: LD_INT 1
47551: DEC
47552: ST_TO_ADDR
47553: LD_EXP 50
47557: PUSH
47558: FOR_TO
47559: IFFALSE 47646
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47561: LD_VAR 0 1
47565: PUSH
47566: LD_EXP 58
47570: PUSH
47571: LD_VAR 0 4
47575: ARRAY
47576: IN
47577: PUSH
47578: LD_VAR 0 1
47582: PUSH
47583: LD_EXP 59
47587: PUSH
47588: LD_VAR 0 4
47592: ARRAY
47593: IN
47594: NOT
47595: AND
47596: IFFALSE 47644
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47598: LD_ADDR_EXP 59
47602: PUSH
47603: LD_EXP 59
47607: PPUSH
47608: LD_VAR 0 4
47612: PUSH
47613: LD_EXP 59
47617: PUSH
47618: LD_VAR 0 4
47622: ARRAY
47623: PUSH
47624: LD_INT 1
47626: PLUS
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: PPUSH
47632: LD_VAR 0 1
47636: PPUSH
47637: CALL 52825 0 3
47641: ST_TO_ADDR
// break ;
47642: GO 47646
// end ; end ;
47644: GO 47558
47646: POP
47647: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47648: LD_VAR 0 1
47652: PPUSH
47653: CALL_OW 257
47657: PUSH
47658: LD_EXP 76
47662: IN
47663: PUSH
47664: LD_VAR 0 1
47668: PPUSH
47669: CALL_OW 266
47673: PUSH
47674: LD_INT 5
47676: EQUAL
47677: AND
47678: PUSH
47679: LD_VAR 0 2
47683: PPUSH
47684: CALL_OW 110
47688: PUSH
47689: LD_INT 18
47691: NONEQUAL
47692: AND
47693: IFFALSE 47733
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47695: LD_VAR 0 2
47699: PPUSH
47700: CALL_OW 257
47704: PUSH
47705: LD_INT 5
47707: PUSH
47708: LD_INT 8
47710: PUSH
47711: LD_INT 9
47713: PUSH
47714: EMPTY
47715: LIST
47716: LIST
47717: LIST
47718: IN
47719: IFFALSE 47733
// SetClass ( unit , 1 ) ;
47721: LD_VAR 0 2
47725: PPUSH
47726: LD_INT 1
47728: PPUSH
47729: CALL_OW 336
// end ;
47733: LD_VAR 0 3
47737: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47738: LD_INT 0
47740: PPUSH
47741: PPUSH
// if not mc_bases or not skirmish then
47742: LD_EXP 50
47746: NOT
47747: PUSH
47748: LD_EXP 48
47752: NOT
47753: OR
47754: IFFALSE 47758
// exit ;
47756: GO 47874
// if GetLives ( abandoned_vehicle ) > 250 then
47758: LD_VAR 0 2
47762: PPUSH
47763: CALL_OW 256
47767: PUSH
47768: LD_INT 250
47770: GREATER
47771: IFFALSE 47775
// exit ;
47773: GO 47874
// for i = 1 to mc_bases do
47775: LD_ADDR_VAR 0 6
47779: PUSH
47780: DOUBLE
47781: LD_INT 1
47783: DEC
47784: ST_TO_ADDR
47785: LD_EXP 50
47789: PUSH
47790: FOR_TO
47791: IFFALSE 47872
// begin if driver in mc_bases [ i ] then
47793: LD_VAR 0 1
47797: PUSH
47798: LD_EXP 50
47802: PUSH
47803: LD_VAR 0 6
47807: ARRAY
47808: IN
47809: IFFALSE 47870
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47811: LD_VAR 0 1
47815: PPUSH
47816: LD_EXP 50
47820: PUSH
47821: LD_VAR 0 6
47825: ARRAY
47826: PPUSH
47827: LD_INT 2
47829: PUSH
47830: LD_INT 30
47832: PUSH
47833: LD_INT 0
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: LD_INT 30
47842: PUSH
47843: LD_INT 1
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: PUSH
47850: EMPTY
47851: LIST
47852: LIST
47853: LIST
47854: PPUSH
47855: CALL_OW 72
47859: PUSH
47860: LD_INT 1
47862: ARRAY
47863: PPUSH
47864: CALL 84691 0 2
// break ;
47868: GO 47872
// end ; end ;
47870: GO 47790
47872: POP
47873: POP
// end ; end_of_file
47874: LD_VAR 0 5
47878: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47879: LD_INT 0
47881: PPUSH
47882: PPUSH
// if exist_mode then
47883: LD_VAR 0 2
47887: IFFALSE 47912
// unit := CreateCharacter ( prefix & ident ) else
47889: LD_ADDR_VAR 0 5
47893: PUSH
47894: LD_VAR 0 3
47898: PUSH
47899: LD_VAR 0 1
47903: STR
47904: PPUSH
47905: CALL_OW 34
47909: ST_TO_ADDR
47910: GO 47927
// unit := NewCharacter ( ident ) ;
47912: LD_ADDR_VAR 0 5
47916: PUSH
47917: LD_VAR 0 1
47921: PPUSH
47922: CALL_OW 25
47926: ST_TO_ADDR
// result := unit ;
47927: LD_ADDR_VAR 0 4
47931: PUSH
47932: LD_VAR 0 5
47936: ST_TO_ADDR
// end ;
47937: LD_VAR 0 4
47941: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47942: LD_INT 0
47944: PPUSH
47945: PPUSH
// if not side or not nation then
47946: LD_VAR 0 1
47950: NOT
47951: PUSH
47952: LD_VAR 0 2
47956: NOT
47957: OR
47958: IFFALSE 47962
// exit ;
47960: GO 48726
// case nation of nation_american :
47962: LD_VAR 0 2
47966: PUSH
47967: LD_INT 1
47969: DOUBLE
47970: EQUAL
47971: IFTRUE 47975
47973: GO 48189
47975: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
47976: LD_ADDR_VAR 0 4
47980: PUSH
47981: LD_INT 35
47983: PUSH
47984: LD_INT 45
47986: PUSH
47987: LD_INT 46
47989: PUSH
47990: LD_INT 47
47992: PUSH
47993: LD_INT 82
47995: PUSH
47996: LD_INT 83
47998: PUSH
47999: LD_INT 84
48001: PUSH
48002: LD_INT 85
48004: PUSH
48005: LD_INT 86
48007: PUSH
48008: LD_INT 1
48010: PUSH
48011: LD_INT 2
48013: PUSH
48014: LD_INT 6
48016: PUSH
48017: LD_INT 15
48019: PUSH
48020: LD_INT 16
48022: PUSH
48023: LD_INT 7
48025: PUSH
48026: LD_INT 12
48028: PUSH
48029: LD_INT 13
48031: PUSH
48032: LD_INT 10
48034: PUSH
48035: LD_INT 14
48037: PUSH
48038: LD_INT 20
48040: PUSH
48041: LD_INT 21
48043: PUSH
48044: LD_INT 22
48046: PUSH
48047: LD_INT 25
48049: PUSH
48050: LD_INT 32
48052: PUSH
48053: LD_INT 27
48055: PUSH
48056: LD_INT 36
48058: PUSH
48059: LD_INT 69
48061: PUSH
48062: LD_INT 39
48064: PUSH
48065: LD_INT 34
48067: PUSH
48068: LD_INT 40
48070: PUSH
48071: LD_INT 48
48073: PUSH
48074: LD_INT 49
48076: PUSH
48077: LD_INT 50
48079: PUSH
48080: LD_INT 51
48082: PUSH
48083: LD_INT 52
48085: PUSH
48086: LD_INT 53
48088: PUSH
48089: LD_INT 54
48091: PUSH
48092: LD_INT 55
48094: PUSH
48095: LD_INT 56
48097: PUSH
48098: LD_INT 57
48100: PUSH
48101: LD_INT 58
48103: PUSH
48104: LD_INT 59
48106: PUSH
48107: LD_INT 60
48109: PUSH
48110: LD_INT 61
48112: PUSH
48113: LD_INT 62
48115: PUSH
48116: LD_INT 80
48118: PUSH
48119: LD_INT 82
48121: PUSH
48122: LD_INT 83
48124: PUSH
48125: LD_INT 84
48127: PUSH
48128: LD_INT 85
48130: PUSH
48131: LD_INT 86
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: ST_TO_ADDR
48187: GO 48650
48189: LD_INT 2
48191: DOUBLE
48192: EQUAL
48193: IFTRUE 48197
48195: GO 48419
48197: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
48198: LD_ADDR_VAR 0 4
48202: PUSH
48203: LD_INT 35
48205: PUSH
48206: LD_INT 45
48208: PUSH
48209: LD_INT 46
48211: PUSH
48212: LD_INT 47
48214: PUSH
48215: LD_INT 82
48217: PUSH
48218: LD_INT 83
48220: PUSH
48221: LD_INT 84
48223: PUSH
48224: LD_INT 85
48226: PUSH
48227: LD_INT 87
48229: PUSH
48230: LD_INT 70
48232: PUSH
48233: LD_INT 1
48235: PUSH
48236: LD_INT 11
48238: PUSH
48239: LD_INT 3
48241: PUSH
48242: LD_INT 4
48244: PUSH
48245: LD_INT 5
48247: PUSH
48248: LD_INT 6
48250: PUSH
48251: LD_INT 15
48253: PUSH
48254: LD_INT 18
48256: PUSH
48257: LD_INT 7
48259: PUSH
48260: LD_INT 17
48262: PUSH
48263: LD_INT 8
48265: PUSH
48266: LD_INT 20
48268: PUSH
48269: LD_INT 21
48271: PUSH
48272: LD_INT 22
48274: PUSH
48275: LD_INT 72
48277: PUSH
48278: LD_INT 26
48280: PUSH
48281: LD_INT 69
48283: PUSH
48284: LD_INT 39
48286: PUSH
48287: LD_INT 40
48289: PUSH
48290: LD_INT 41
48292: PUSH
48293: LD_INT 42
48295: PUSH
48296: LD_INT 43
48298: PUSH
48299: LD_INT 48
48301: PUSH
48302: LD_INT 49
48304: PUSH
48305: LD_INT 50
48307: PUSH
48308: LD_INT 51
48310: PUSH
48311: LD_INT 52
48313: PUSH
48314: LD_INT 53
48316: PUSH
48317: LD_INT 54
48319: PUSH
48320: LD_INT 55
48322: PUSH
48323: LD_INT 56
48325: PUSH
48326: LD_INT 60
48328: PUSH
48329: LD_INT 61
48331: PUSH
48332: LD_INT 62
48334: PUSH
48335: LD_INT 66
48337: PUSH
48338: LD_INT 67
48340: PUSH
48341: LD_INT 68
48343: PUSH
48344: LD_INT 81
48346: PUSH
48347: LD_INT 82
48349: PUSH
48350: LD_INT 83
48352: PUSH
48353: LD_INT 84
48355: PUSH
48356: LD_INT 85
48358: PUSH
48359: LD_INT 87
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: ST_TO_ADDR
48417: GO 48650
48419: LD_INT 3
48421: DOUBLE
48422: EQUAL
48423: IFTRUE 48427
48425: GO 48649
48427: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48428: LD_ADDR_VAR 0 4
48432: PUSH
48433: LD_INT 46
48435: PUSH
48436: LD_INT 47
48438: PUSH
48439: LD_INT 1
48441: PUSH
48442: LD_INT 2
48444: PUSH
48445: LD_INT 82
48447: PUSH
48448: LD_INT 83
48450: PUSH
48451: LD_INT 84
48453: PUSH
48454: LD_INT 85
48456: PUSH
48457: LD_INT 86
48459: PUSH
48460: LD_INT 11
48462: PUSH
48463: LD_INT 9
48465: PUSH
48466: LD_INT 20
48468: PUSH
48469: LD_INT 19
48471: PUSH
48472: LD_INT 21
48474: PUSH
48475: LD_INT 24
48477: PUSH
48478: LD_INT 22
48480: PUSH
48481: LD_INT 25
48483: PUSH
48484: LD_INT 28
48486: PUSH
48487: LD_INT 29
48489: PUSH
48490: LD_INT 30
48492: PUSH
48493: LD_INT 31
48495: PUSH
48496: LD_INT 37
48498: PUSH
48499: LD_INT 38
48501: PUSH
48502: LD_INT 32
48504: PUSH
48505: LD_INT 27
48507: PUSH
48508: LD_INT 33
48510: PUSH
48511: LD_INT 69
48513: PUSH
48514: LD_INT 39
48516: PUSH
48517: LD_INT 34
48519: PUSH
48520: LD_INT 40
48522: PUSH
48523: LD_INT 71
48525: PUSH
48526: LD_INT 23
48528: PUSH
48529: LD_INT 44
48531: PUSH
48532: LD_INT 48
48534: PUSH
48535: LD_INT 49
48537: PUSH
48538: LD_INT 50
48540: PUSH
48541: LD_INT 51
48543: PUSH
48544: LD_INT 52
48546: PUSH
48547: LD_INT 53
48549: PUSH
48550: LD_INT 54
48552: PUSH
48553: LD_INT 55
48555: PUSH
48556: LD_INT 56
48558: PUSH
48559: LD_INT 57
48561: PUSH
48562: LD_INT 58
48564: PUSH
48565: LD_INT 59
48567: PUSH
48568: LD_INT 63
48570: PUSH
48571: LD_INT 64
48573: PUSH
48574: LD_INT 65
48576: PUSH
48577: LD_INT 82
48579: PUSH
48580: LD_INT 83
48582: PUSH
48583: LD_INT 84
48585: PUSH
48586: LD_INT 85
48588: PUSH
48589: LD_INT 86
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: LIST
48596: LIST
48597: LIST
48598: LIST
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: LIST
48604: LIST
48605: LIST
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: LIST
48614: LIST
48615: LIST
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: LIST
48621: LIST
48622: LIST
48623: LIST
48624: LIST
48625: LIST
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: LIST
48633: LIST
48634: LIST
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: LIST
48646: ST_TO_ADDR
48647: GO 48650
48649: POP
// if state > - 1 and state < 3 then
48650: LD_VAR 0 3
48654: PUSH
48655: LD_INT 1
48657: NEG
48658: GREATER
48659: PUSH
48660: LD_VAR 0 3
48664: PUSH
48665: LD_INT 3
48667: LESS
48668: AND
48669: IFFALSE 48726
// for i in result do
48671: LD_ADDR_VAR 0 5
48675: PUSH
48676: LD_VAR 0 4
48680: PUSH
48681: FOR_IN
48682: IFFALSE 48724
// if GetTech ( i , side ) <> state then
48684: LD_VAR 0 5
48688: PPUSH
48689: LD_VAR 0 1
48693: PPUSH
48694: CALL_OW 321
48698: PUSH
48699: LD_VAR 0 3
48703: NONEQUAL
48704: IFFALSE 48722
// result := result diff i ;
48706: LD_ADDR_VAR 0 4
48710: PUSH
48711: LD_VAR 0 4
48715: PUSH
48716: LD_VAR 0 5
48720: DIFF
48721: ST_TO_ADDR
48722: GO 48681
48724: POP
48725: POP
// end ;
48726: LD_VAR 0 4
48730: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48731: LD_INT 0
48733: PPUSH
48734: PPUSH
48735: PPUSH
// result := true ;
48736: LD_ADDR_VAR 0 3
48740: PUSH
48741: LD_INT 1
48743: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48744: LD_ADDR_VAR 0 5
48748: PUSH
48749: LD_VAR 0 2
48753: PPUSH
48754: CALL_OW 480
48758: ST_TO_ADDR
// if not tmp then
48759: LD_VAR 0 5
48763: NOT
48764: IFFALSE 48768
// exit ;
48766: GO 48817
// for i in tmp do
48768: LD_ADDR_VAR 0 4
48772: PUSH
48773: LD_VAR 0 5
48777: PUSH
48778: FOR_IN
48779: IFFALSE 48815
// if GetTech ( i , side ) <> state_researched then
48781: LD_VAR 0 4
48785: PPUSH
48786: LD_VAR 0 1
48790: PPUSH
48791: CALL_OW 321
48795: PUSH
48796: LD_INT 2
48798: NONEQUAL
48799: IFFALSE 48813
// begin result := false ;
48801: LD_ADDR_VAR 0 3
48805: PUSH
48806: LD_INT 0
48808: ST_TO_ADDR
// exit ;
48809: POP
48810: POP
48811: GO 48817
// end ;
48813: GO 48778
48815: POP
48816: POP
// end ;
48817: LD_VAR 0 3
48821: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48822: LD_INT 0
48824: PPUSH
48825: PPUSH
48826: PPUSH
48827: PPUSH
48828: PPUSH
48829: PPUSH
48830: PPUSH
48831: PPUSH
48832: PPUSH
48833: PPUSH
48834: PPUSH
48835: PPUSH
48836: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48837: LD_VAR 0 1
48841: NOT
48842: PUSH
48843: LD_VAR 0 1
48847: PPUSH
48848: CALL_OW 257
48852: PUSH
48853: LD_INT 9
48855: NONEQUAL
48856: OR
48857: IFFALSE 48861
// exit ;
48859: GO 49434
// side := GetSide ( unit ) ;
48861: LD_ADDR_VAR 0 9
48865: PUSH
48866: LD_VAR 0 1
48870: PPUSH
48871: CALL_OW 255
48875: ST_TO_ADDR
// tech_space := tech_spacanom ;
48876: LD_ADDR_VAR 0 12
48880: PUSH
48881: LD_INT 29
48883: ST_TO_ADDR
// tech_time := tech_taurad ;
48884: LD_ADDR_VAR 0 13
48888: PUSH
48889: LD_INT 28
48891: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48892: LD_ADDR_VAR 0 11
48896: PUSH
48897: LD_VAR 0 1
48901: PPUSH
48902: CALL_OW 310
48906: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48907: LD_VAR 0 11
48911: PPUSH
48912: CALL_OW 247
48916: PUSH
48917: LD_INT 2
48919: EQUAL
48920: IFFALSE 48924
// exit ;
48922: GO 49434
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48924: LD_ADDR_VAR 0 8
48928: PUSH
48929: LD_INT 81
48931: PUSH
48932: LD_VAR 0 9
48936: PUSH
48937: EMPTY
48938: LIST
48939: LIST
48940: PUSH
48941: LD_INT 3
48943: PUSH
48944: LD_INT 21
48946: PUSH
48947: LD_INT 3
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: EMPTY
48955: LIST
48956: LIST
48957: PUSH
48958: EMPTY
48959: LIST
48960: LIST
48961: PPUSH
48962: CALL_OW 69
48966: ST_TO_ADDR
// if not tmp then
48967: LD_VAR 0 8
48971: NOT
48972: IFFALSE 48976
// exit ;
48974: GO 49434
// if in_unit then
48976: LD_VAR 0 11
48980: IFFALSE 49004
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48982: LD_ADDR_VAR 0 10
48986: PUSH
48987: LD_VAR 0 8
48991: PPUSH
48992: LD_VAR 0 11
48996: PPUSH
48997: CALL_OW 74
49001: ST_TO_ADDR
49002: GO 49024
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49004: LD_ADDR_VAR 0 10
49008: PUSH
49009: LD_VAR 0 8
49013: PPUSH
49014: LD_VAR 0 1
49018: PPUSH
49019: CALL_OW 74
49023: ST_TO_ADDR
// if not enemy then
49024: LD_VAR 0 10
49028: NOT
49029: IFFALSE 49033
// exit ;
49031: GO 49434
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49033: LD_VAR 0 11
49037: PUSH
49038: LD_VAR 0 11
49042: PPUSH
49043: LD_VAR 0 10
49047: PPUSH
49048: CALL_OW 296
49052: PUSH
49053: LD_INT 13
49055: GREATER
49056: AND
49057: PUSH
49058: LD_VAR 0 1
49062: PPUSH
49063: LD_VAR 0 10
49067: PPUSH
49068: CALL_OW 296
49072: PUSH
49073: LD_INT 12
49075: GREATER
49076: OR
49077: IFFALSE 49081
// exit ;
49079: GO 49434
// missile := [ 1 ] ;
49081: LD_ADDR_VAR 0 14
49085: PUSH
49086: LD_INT 1
49088: PUSH
49089: EMPTY
49090: LIST
49091: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49092: LD_VAR 0 9
49096: PPUSH
49097: LD_VAR 0 12
49101: PPUSH
49102: CALL_OW 325
49106: IFFALSE 49135
// missile := Insert ( missile , missile + 1 , 2 ) ;
49108: LD_ADDR_VAR 0 14
49112: PUSH
49113: LD_VAR 0 14
49117: PPUSH
49118: LD_VAR 0 14
49122: PUSH
49123: LD_INT 1
49125: PLUS
49126: PPUSH
49127: LD_INT 2
49129: PPUSH
49130: CALL_OW 2
49134: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49135: LD_VAR 0 9
49139: PPUSH
49140: LD_VAR 0 13
49144: PPUSH
49145: CALL_OW 325
49149: PUSH
49150: LD_VAR 0 10
49154: PPUSH
49155: CALL_OW 255
49159: PPUSH
49160: LD_VAR 0 13
49164: PPUSH
49165: CALL_OW 325
49169: NOT
49170: AND
49171: IFFALSE 49200
// missile := Insert ( missile , missile + 1 , 3 ) ;
49173: LD_ADDR_VAR 0 14
49177: PUSH
49178: LD_VAR 0 14
49182: PPUSH
49183: LD_VAR 0 14
49187: PUSH
49188: LD_INT 1
49190: PLUS
49191: PPUSH
49192: LD_INT 3
49194: PPUSH
49195: CALL_OW 2
49199: ST_TO_ADDR
// if missile < 2 then
49200: LD_VAR 0 14
49204: PUSH
49205: LD_INT 2
49207: LESS
49208: IFFALSE 49212
// exit ;
49210: GO 49434
// x := GetX ( enemy ) ;
49212: LD_ADDR_VAR 0 4
49216: PUSH
49217: LD_VAR 0 10
49221: PPUSH
49222: CALL_OW 250
49226: ST_TO_ADDR
// y := GetY ( enemy ) ;
49227: LD_ADDR_VAR 0 5
49231: PUSH
49232: LD_VAR 0 10
49236: PPUSH
49237: CALL_OW 251
49241: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49242: LD_ADDR_VAR 0 6
49246: PUSH
49247: LD_VAR 0 4
49251: PUSH
49252: LD_INT 1
49254: NEG
49255: PPUSH
49256: LD_INT 1
49258: PPUSH
49259: CALL_OW 12
49263: PLUS
49264: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49265: LD_ADDR_VAR 0 7
49269: PUSH
49270: LD_VAR 0 5
49274: PUSH
49275: LD_INT 1
49277: NEG
49278: PPUSH
49279: LD_INT 1
49281: PPUSH
49282: CALL_OW 12
49286: PLUS
49287: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49288: LD_VAR 0 6
49292: PPUSH
49293: LD_VAR 0 7
49297: PPUSH
49298: CALL_OW 488
49302: NOT
49303: IFFALSE 49325
// begin _x := x ;
49305: LD_ADDR_VAR 0 6
49309: PUSH
49310: LD_VAR 0 4
49314: ST_TO_ADDR
// _y := y ;
49315: LD_ADDR_VAR 0 7
49319: PUSH
49320: LD_VAR 0 5
49324: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49325: LD_ADDR_VAR 0 3
49329: PUSH
49330: LD_INT 1
49332: PPUSH
49333: LD_VAR 0 14
49337: PPUSH
49338: CALL_OW 12
49342: ST_TO_ADDR
// case i of 1 :
49343: LD_VAR 0 3
49347: PUSH
49348: LD_INT 1
49350: DOUBLE
49351: EQUAL
49352: IFTRUE 49356
49354: GO 49373
49356: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
49357: LD_VAR 0 1
49361: PPUSH
49362: LD_VAR 0 10
49366: PPUSH
49367: CALL_OW 115
49371: GO 49434
49373: LD_INT 2
49375: DOUBLE
49376: EQUAL
49377: IFTRUE 49381
49379: GO 49403
49381: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49382: LD_VAR 0 1
49386: PPUSH
49387: LD_VAR 0 6
49391: PPUSH
49392: LD_VAR 0 7
49396: PPUSH
49397: CALL_OW 153
49401: GO 49434
49403: LD_INT 3
49405: DOUBLE
49406: EQUAL
49407: IFTRUE 49411
49409: GO 49433
49411: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49412: LD_VAR 0 1
49416: PPUSH
49417: LD_VAR 0 6
49421: PPUSH
49422: LD_VAR 0 7
49426: PPUSH
49427: CALL_OW 154
49431: GO 49434
49433: POP
// end ;
49434: LD_VAR 0 2
49438: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49439: LD_INT 0
49441: PPUSH
49442: PPUSH
49443: PPUSH
49444: PPUSH
49445: PPUSH
49446: PPUSH
// if not unit or not building then
49447: LD_VAR 0 1
49451: NOT
49452: PUSH
49453: LD_VAR 0 2
49457: NOT
49458: OR
49459: IFFALSE 49463
// exit ;
49461: GO 49621
// x := GetX ( building ) ;
49463: LD_ADDR_VAR 0 5
49467: PUSH
49468: LD_VAR 0 2
49472: PPUSH
49473: CALL_OW 250
49477: ST_TO_ADDR
// y := GetY ( building ) ;
49478: LD_ADDR_VAR 0 6
49482: PUSH
49483: LD_VAR 0 2
49487: PPUSH
49488: CALL_OW 251
49492: ST_TO_ADDR
// for i = 0 to 5 do
49493: LD_ADDR_VAR 0 4
49497: PUSH
49498: DOUBLE
49499: LD_INT 0
49501: DEC
49502: ST_TO_ADDR
49503: LD_INT 5
49505: PUSH
49506: FOR_TO
49507: IFFALSE 49619
// begin _x := ShiftX ( x , i , 3 ) ;
49509: LD_ADDR_VAR 0 7
49513: PUSH
49514: LD_VAR 0 5
49518: PPUSH
49519: LD_VAR 0 4
49523: PPUSH
49524: LD_INT 3
49526: PPUSH
49527: CALL_OW 272
49531: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49532: LD_ADDR_VAR 0 8
49536: PUSH
49537: LD_VAR 0 6
49541: PPUSH
49542: LD_VAR 0 4
49546: PPUSH
49547: LD_INT 3
49549: PPUSH
49550: CALL_OW 273
49554: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49555: LD_VAR 0 7
49559: PPUSH
49560: LD_VAR 0 8
49564: PPUSH
49565: CALL_OW 488
49569: NOT
49570: IFFALSE 49574
// continue ;
49572: GO 49506
// if HexInfo ( _x , _y ) = 0 then
49574: LD_VAR 0 7
49578: PPUSH
49579: LD_VAR 0 8
49583: PPUSH
49584: CALL_OW 428
49588: PUSH
49589: LD_INT 0
49591: EQUAL
49592: IFFALSE 49617
// begin ComMoveXY ( unit , _x , _y ) ;
49594: LD_VAR 0 1
49598: PPUSH
49599: LD_VAR 0 7
49603: PPUSH
49604: LD_VAR 0 8
49608: PPUSH
49609: CALL_OW 111
// exit ;
49613: POP
49614: POP
49615: GO 49621
// end ; end ;
49617: GO 49506
49619: POP
49620: POP
// end ;
49621: LD_VAR 0 3
49625: RET
// export function ScanBase ( side , base_area ) ; begin
49626: LD_INT 0
49628: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49629: LD_ADDR_VAR 0 3
49633: PUSH
49634: LD_VAR 0 2
49638: PPUSH
49639: LD_INT 81
49641: PUSH
49642: LD_VAR 0 1
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: PPUSH
49651: CALL_OW 70
49655: ST_TO_ADDR
// end ;
49656: LD_VAR 0 3
49660: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49661: LD_INT 0
49663: PPUSH
49664: PPUSH
49665: PPUSH
49666: PPUSH
// result := false ;
49667: LD_ADDR_VAR 0 2
49671: PUSH
49672: LD_INT 0
49674: ST_TO_ADDR
// side := GetSide ( unit ) ;
49675: LD_ADDR_VAR 0 3
49679: PUSH
49680: LD_VAR 0 1
49684: PPUSH
49685: CALL_OW 255
49689: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49690: LD_ADDR_VAR 0 4
49694: PUSH
49695: LD_VAR 0 1
49699: PPUSH
49700: CALL_OW 248
49704: ST_TO_ADDR
// case nat of 1 :
49705: LD_VAR 0 4
49709: PUSH
49710: LD_INT 1
49712: DOUBLE
49713: EQUAL
49714: IFTRUE 49718
49716: GO 49729
49718: POP
// tech := tech_lassight ; 2 :
49719: LD_ADDR_VAR 0 5
49723: PUSH
49724: LD_INT 12
49726: ST_TO_ADDR
49727: GO 49768
49729: LD_INT 2
49731: DOUBLE
49732: EQUAL
49733: IFTRUE 49737
49735: GO 49748
49737: POP
// tech := tech_mortar ; 3 :
49738: LD_ADDR_VAR 0 5
49742: PUSH
49743: LD_INT 41
49745: ST_TO_ADDR
49746: GO 49768
49748: LD_INT 3
49750: DOUBLE
49751: EQUAL
49752: IFTRUE 49756
49754: GO 49767
49756: POP
// tech := tech_bazooka ; end ;
49757: LD_ADDR_VAR 0 5
49761: PUSH
49762: LD_INT 44
49764: ST_TO_ADDR
49765: GO 49768
49767: POP
// if Researched ( side , tech ) then
49768: LD_VAR 0 3
49772: PPUSH
49773: LD_VAR 0 5
49777: PPUSH
49778: CALL_OW 325
49782: IFFALSE 49809
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
49784: LD_ADDR_VAR 0 2
49788: PUSH
49789: LD_INT 5
49791: PUSH
49792: LD_INT 8
49794: PUSH
49795: LD_INT 9
49797: PUSH
49798: EMPTY
49799: LIST
49800: LIST
49801: LIST
49802: PUSH
49803: LD_VAR 0 4
49807: ARRAY
49808: ST_TO_ADDR
// end ;
49809: LD_VAR 0 2
49813: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
49814: LD_INT 0
49816: PPUSH
49817: PPUSH
49818: PPUSH
// if not mines then
49819: LD_VAR 0 2
49823: NOT
49824: IFFALSE 49828
// exit ;
49826: GO 49972
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49828: LD_ADDR_VAR 0 5
49832: PUSH
49833: LD_INT 81
49835: PUSH
49836: LD_VAR 0 1
49840: PUSH
49841: EMPTY
49842: LIST
49843: LIST
49844: PUSH
49845: LD_INT 3
49847: PUSH
49848: LD_INT 21
49850: PUSH
49851: LD_INT 3
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: PUSH
49858: EMPTY
49859: LIST
49860: LIST
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PPUSH
49866: CALL_OW 69
49870: ST_TO_ADDR
// for i in mines do
49871: LD_ADDR_VAR 0 4
49875: PUSH
49876: LD_VAR 0 2
49880: PUSH
49881: FOR_IN
49882: IFFALSE 49970
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
49884: LD_VAR 0 4
49888: PUSH
49889: LD_INT 1
49891: ARRAY
49892: PPUSH
49893: LD_VAR 0 4
49897: PUSH
49898: LD_INT 2
49900: ARRAY
49901: PPUSH
49902: CALL_OW 458
49906: NOT
49907: IFFALSE 49911
// continue ;
49909: GO 49881
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
49911: LD_VAR 0 4
49915: PUSH
49916: LD_INT 1
49918: ARRAY
49919: PPUSH
49920: LD_VAR 0 4
49924: PUSH
49925: LD_INT 2
49927: ARRAY
49928: PPUSH
49929: CALL_OW 428
49933: PUSH
49934: LD_VAR 0 5
49938: IN
49939: IFFALSE 49968
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
49941: LD_VAR 0 4
49945: PUSH
49946: LD_INT 1
49948: ARRAY
49949: PPUSH
49950: LD_VAR 0 4
49954: PUSH
49955: LD_INT 2
49957: ARRAY
49958: PPUSH
49959: LD_VAR 0 1
49963: PPUSH
49964: CALL_OW 456
// end ;
49968: GO 49881
49970: POP
49971: POP
// end ;
49972: LD_VAR 0 3
49976: RET
// export function Count ( array ) ; var i ; begin
49977: LD_INT 0
49979: PPUSH
49980: PPUSH
// result := 0 ;
49981: LD_ADDR_VAR 0 2
49985: PUSH
49986: LD_INT 0
49988: ST_TO_ADDR
// for i in array do
49989: LD_ADDR_VAR 0 3
49993: PUSH
49994: LD_VAR 0 1
49998: PUSH
49999: FOR_IN
50000: IFFALSE 50024
// if i then
50002: LD_VAR 0 3
50006: IFFALSE 50022
// result := result + 1 ;
50008: LD_ADDR_VAR 0 2
50012: PUSH
50013: LD_VAR 0 2
50017: PUSH
50018: LD_INT 1
50020: PLUS
50021: ST_TO_ADDR
50022: GO 49999
50024: POP
50025: POP
// end ;
50026: LD_VAR 0 2
50030: RET
// export function IsEmpty ( building ) ; begin
50031: LD_INT 0
50033: PPUSH
// if not building then
50034: LD_VAR 0 1
50038: NOT
50039: IFFALSE 50043
// exit ;
50041: GO 50086
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50043: LD_ADDR_VAR 0 2
50047: PUSH
50048: LD_VAR 0 1
50052: PUSH
50053: LD_INT 22
50055: PUSH
50056: LD_VAR 0 1
50060: PPUSH
50061: CALL_OW 255
50065: PUSH
50066: EMPTY
50067: LIST
50068: LIST
50069: PUSH
50070: LD_INT 58
50072: PUSH
50073: EMPTY
50074: LIST
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: PPUSH
50080: CALL_OW 69
50084: IN
50085: ST_TO_ADDR
// end ;
50086: LD_VAR 0 2
50090: RET
// export function IsNotFull ( building ) ; begin
50091: LD_INT 0
50093: PPUSH
// if not building then
50094: LD_VAR 0 1
50098: NOT
50099: IFFALSE 50103
// exit ;
50101: GO 50122
// result := UnitsInside ( building ) < 6 ;
50103: LD_ADDR_VAR 0 2
50107: PUSH
50108: LD_VAR 0 1
50112: PPUSH
50113: CALL_OW 313
50117: PUSH
50118: LD_INT 6
50120: LESS
50121: ST_TO_ADDR
// end ;
50122: LD_VAR 0 2
50126: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50127: LD_INT 0
50129: PPUSH
50130: PPUSH
50131: PPUSH
50132: PPUSH
// tmp := [ ] ;
50133: LD_ADDR_VAR 0 3
50137: PUSH
50138: EMPTY
50139: ST_TO_ADDR
// list := [ ] ;
50140: LD_ADDR_VAR 0 5
50144: PUSH
50145: EMPTY
50146: ST_TO_ADDR
// for i = 16 to 25 do
50147: LD_ADDR_VAR 0 4
50151: PUSH
50152: DOUBLE
50153: LD_INT 16
50155: DEC
50156: ST_TO_ADDR
50157: LD_INT 25
50159: PUSH
50160: FOR_TO
50161: IFFALSE 50234
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50163: LD_ADDR_VAR 0 3
50167: PUSH
50168: LD_VAR 0 3
50172: PUSH
50173: LD_INT 22
50175: PUSH
50176: LD_VAR 0 1
50180: PPUSH
50181: CALL_OW 255
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PUSH
50190: LD_INT 91
50192: PUSH
50193: LD_VAR 0 1
50197: PUSH
50198: LD_INT 6
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: LIST
50205: PUSH
50206: LD_INT 30
50208: PUSH
50209: LD_VAR 0 4
50213: PUSH
50214: EMPTY
50215: LIST
50216: LIST
50217: PUSH
50218: EMPTY
50219: LIST
50220: LIST
50221: LIST
50222: PUSH
50223: EMPTY
50224: LIST
50225: PPUSH
50226: CALL_OW 69
50230: ADD
50231: ST_TO_ADDR
50232: GO 50160
50234: POP
50235: POP
// for i = 1 to tmp do
50236: LD_ADDR_VAR 0 4
50240: PUSH
50241: DOUBLE
50242: LD_INT 1
50244: DEC
50245: ST_TO_ADDR
50246: LD_VAR 0 3
50250: PUSH
50251: FOR_TO
50252: IFFALSE 50340
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50254: LD_ADDR_VAR 0 5
50258: PUSH
50259: LD_VAR 0 5
50263: PUSH
50264: LD_VAR 0 3
50268: PUSH
50269: LD_VAR 0 4
50273: ARRAY
50274: PPUSH
50275: CALL_OW 266
50279: PUSH
50280: LD_VAR 0 3
50284: PUSH
50285: LD_VAR 0 4
50289: ARRAY
50290: PPUSH
50291: CALL_OW 250
50295: PUSH
50296: LD_VAR 0 3
50300: PUSH
50301: LD_VAR 0 4
50305: ARRAY
50306: PPUSH
50307: CALL_OW 251
50311: PUSH
50312: LD_VAR 0 3
50316: PUSH
50317: LD_VAR 0 4
50321: ARRAY
50322: PPUSH
50323: CALL_OW 254
50327: PUSH
50328: EMPTY
50329: LIST
50330: LIST
50331: LIST
50332: LIST
50333: PUSH
50334: EMPTY
50335: LIST
50336: ADD
50337: ST_TO_ADDR
50338: GO 50251
50340: POP
50341: POP
// result := list ;
50342: LD_ADDR_VAR 0 2
50346: PUSH
50347: LD_VAR 0 5
50351: ST_TO_ADDR
// end ;
50352: LD_VAR 0 2
50356: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
50357: LD_INT 0
50359: PPUSH
50360: PPUSH
50361: PPUSH
50362: PPUSH
50363: PPUSH
50364: PPUSH
50365: PPUSH
// if not factory then
50366: LD_VAR 0 1
50370: NOT
50371: IFFALSE 50375
// exit ;
50373: GO 50968
// if control = control_apeman then
50375: LD_VAR 0 4
50379: PUSH
50380: LD_INT 5
50382: EQUAL
50383: IFFALSE 50492
// begin tmp := UnitsInside ( factory ) ;
50385: LD_ADDR_VAR 0 8
50389: PUSH
50390: LD_VAR 0 1
50394: PPUSH
50395: CALL_OW 313
50399: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50400: LD_VAR 0 8
50404: PPUSH
50405: LD_INT 25
50407: PUSH
50408: LD_INT 12
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: PPUSH
50415: CALL_OW 72
50419: NOT
50420: IFFALSE 50430
// control := control_manual ;
50422: LD_ADDR_VAR 0 4
50426: PUSH
50427: LD_INT 1
50429: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50430: LD_ADDR_VAR 0 8
50434: PUSH
50435: LD_VAR 0 1
50439: PPUSH
50440: CALL 50127 0 1
50444: ST_TO_ADDR
// if tmp then
50445: LD_VAR 0 8
50449: IFFALSE 50492
// begin for i in tmp do
50451: LD_ADDR_VAR 0 7
50455: PUSH
50456: LD_VAR 0 8
50460: PUSH
50461: FOR_IN
50462: IFFALSE 50490
// if i [ 1 ] = b_ext_radio then
50464: LD_VAR 0 7
50468: PUSH
50469: LD_INT 1
50471: ARRAY
50472: PUSH
50473: LD_INT 22
50475: EQUAL
50476: IFFALSE 50488
// begin control := control_remote ;
50478: LD_ADDR_VAR 0 4
50482: PUSH
50483: LD_INT 2
50485: ST_TO_ADDR
// break ;
50486: GO 50490
// end ;
50488: GO 50461
50490: POP
50491: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50492: LD_VAR 0 1
50496: PPUSH
50497: LD_VAR 0 2
50501: PPUSH
50502: LD_VAR 0 3
50506: PPUSH
50507: LD_VAR 0 4
50511: PPUSH
50512: LD_VAR 0 5
50516: PPUSH
50517: CALL_OW 448
50521: IFFALSE 50556
// begin result := [ chassis , engine , control , weapon ] ;
50523: LD_ADDR_VAR 0 6
50527: PUSH
50528: LD_VAR 0 2
50532: PUSH
50533: LD_VAR 0 3
50537: PUSH
50538: LD_VAR 0 4
50542: PUSH
50543: LD_VAR 0 5
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: ST_TO_ADDR
// exit ;
50554: GO 50968
// end ; _chassis := AvailableChassisList ( factory ) ;
50556: LD_ADDR_VAR 0 9
50560: PUSH
50561: LD_VAR 0 1
50565: PPUSH
50566: CALL_OW 475
50570: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50571: LD_ADDR_VAR 0 11
50575: PUSH
50576: LD_VAR 0 1
50580: PPUSH
50581: CALL_OW 476
50585: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50586: LD_ADDR_VAR 0 12
50590: PUSH
50591: LD_VAR 0 1
50595: PPUSH
50596: CALL_OW 477
50600: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50601: LD_ADDR_VAR 0 10
50605: PUSH
50606: LD_VAR 0 1
50610: PPUSH
50611: CALL_OW 478
50615: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50616: LD_VAR 0 9
50620: NOT
50621: PUSH
50622: LD_VAR 0 11
50626: NOT
50627: OR
50628: PUSH
50629: LD_VAR 0 12
50633: NOT
50634: OR
50635: PUSH
50636: LD_VAR 0 10
50640: NOT
50641: OR
50642: IFFALSE 50677
// begin result := [ chassis , engine , control , weapon ] ;
50644: LD_ADDR_VAR 0 6
50648: PUSH
50649: LD_VAR 0 2
50653: PUSH
50654: LD_VAR 0 3
50658: PUSH
50659: LD_VAR 0 4
50663: PUSH
50664: LD_VAR 0 5
50668: PUSH
50669: EMPTY
50670: LIST
50671: LIST
50672: LIST
50673: LIST
50674: ST_TO_ADDR
// exit ;
50675: GO 50968
// end ; if not chassis in _chassis then
50677: LD_VAR 0 2
50681: PUSH
50682: LD_VAR 0 9
50686: IN
50687: NOT
50688: IFFALSE 50714
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50690: LD_ADDR_VAR 0 2
50694: PUSH
50695: LD_VAR 0 9
50699: PUSH
50700: LD_INT 1
50702: PPUSH
50703: LD_VAR 0 9
50707: PPUSH
50708: CALL_OW 12
50712: ARRAY
50713: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50714: LD_VAR 0 2
50718: PPUSH
50719: LD_VAR 0 3
50723: PPUSH
50724: CALL 50973 0 2
50728: NOT
50729: IFFALSE 50788
// repeat engine := _engine [ 1 ] ;
50731: LD_ADDR_VAR 0 3
50735: PUSH
50736: LD_VAR 0 11
50740: PUSH
50741: LD_INT 1
50743: ARRAY
50744: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50745: LD_ADDR_VAR 0 11
50749: PUSH
50750: LD_VAR 0 11
50754: PPUSH
50755: LD_INT 1
50757: PPUSH
50758: CALL_OW 3
50762: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50763: LD_VAR 0 2
50767: PPUSH
50768: LD_VAR 0 3
50772: PPUSH
50773: CALL 50973 0 2
50777: PUSH
50778: LD_VAR 0 11
50782: PUSH
50783: EMPTY
50784: EQUAL
50785: OR
50786: IFFALSE 50731
// if not control in _control then
50788: LD_VAR 0 4
50792: PUSH
50793: LD_VAR 0 12
50797: IN
50798: NOT
50799: IFFALSE 50825
// control := _control [ rand ( 1 , _control ) ] ;
50801: LD_ADDR_VAR 0 4
50805: PUSH
50806: LD_VAR 0 12
50810: PUSH
50811: LD_INT 1
50813: PPUSH
50814: LD_VAR 0 12
50818: PPUSH
50819: CALL_OW 12
50823: ARRAY
50824: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
50825: LD_VAR 0 2
50829: PPUSH
50830: LD_VAR 0 5
50834: PPUSH
50835: CALL 51193 0 2
50839: NOT
50840: IFFALSE 50899
// repeat weapon := _weapon [ 1 ] ;
50842: LD_ADDR_VAR 0 5
50846: PUSH
50847: LD_VAR 0 10
50851: PUSH
50852: LD_INT 1
50854: ARRAY
50855: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
50856: LD_ADDR_VAR 0 10
50860: PUSH
50861: LD_VAR 0 10
50865: PPUSH
50866: LD_INT 1
50868: PPUSH
50869: CALL_OW 3
50873: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
50874: LD_VAR 0 2
50878: PPUSH
50879: LD_VAR 0 5
50883: PPUSH
50884: CALL 51193 0 2
50888: PUSH
50889: LD_VAR 0 10
50893: PUSH
50894: EMPTY
50895: EQUAL
50896: OR
50897: IFFALSE 50842
// result := [ ] ;
50899: LD_ADDR_VAR 0 6
50903: PUSH
50904: EMPTY
50905: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50906: LD_VAR 0 1
50910: PPUSH
50911: LD_VAR 0 2
50915: PPUSH
50916: LD_VAR 0 3
50920: PPUSH
50921: LD_VAR 0 4
50925: PPUSH
50926: LD_VAR 0 5
50930: PPUSH
50931: CALL_OW 448
50935: IFFALSE 50968
// result := [ chassis , engine , control , weapon ] ;
50937: LD_ADDR_VAR 0 6
50941: PUSH
50942: LD_VAR 0 2
50946: PUSH
50947: LD_VAR 0 3
50951: PUSH
50952: LD_VAR 0 4
50956: PUSH
50957: LD_VAR 0 5
50961: PUSH
50962: EMPTY
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: ST_TO_ADDR
// end ;
50968: LD_VAR 0 6
50972: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
50973: LD_INT 0
50975: PPUSH
// if not chassis or not engine then
50976: LD_VAR 0 1
50980: NOT
50981: PUSH
50982: LD_VAR 0 2
50986: NOT
50987: OR
50988: IFFALSE 50992
// exit ;
50990: GO 51188
// case engine of engine_solar :
50992: LD_VAR 0 2
50996: PUSH
50997: LD_INT 2
50999: DOUBLE
51000: EQUAL
51001: IFTRUE 51005
51003: GO 51043
51005: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51006: LD_ADDR_VAR 0 3
51010: PUSH
51011: LD_INT 11
51013: PUSH
51014: LD_INT 12
51016: PUSH
51017: LD_INT 13
51019: PUSH
51020: LD_INT 14
51022: PUSH
51023: LD_INT 1
51025: PUSH
51026: LD_INT 2
51028: PUSH
51029: LD_INT 3
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: ST_TO_ADDR
51041: GO 51172
51043: LD_INT 1
51045: DOUBLE
51046: EQUAL
51047: IFTRUE 51051
51049: GO 51113
51051: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51052: LD_ADDR_VAR 0 3
51056: PUSH
51057: LD_INT 11
51059: PUSH
51060: LD_INT 12
51062: PUSH
51063: LD_INT 13
51065: PUSH
51066: LD_INT 14
51068: PUSH
51069: LD_INT 1
51071: PUSH
51072: LD_INT 2
51074: PUSH
51075: LD_INT 3
51077: PUSH
51078: LD_INT 4
51080: PUSH
51081: LD_INT 5
51083: PUSH
51084: LD_INT 21
51086: PUSH
51087: LD_INT 23
51089: PUSH
51090: LD_INT 22
51092: PUSH
51093: LD_INT 24
51095: PUSH
51096: EMPTY
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: ST_TO_ADDR
51111: GO 51172
51113: LD_INT 3
51115: DOUBLE
51116: EQUAL
51117: IFTRUE 51121
51119: GO 51171
51121: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51122: LD_ADDR_VAR 0 3
51126: PUSH
51127: LD_INT 13
51129: PUSH
51130: LD_INT 14
51132: PUSH
51133: LD_INT 2
51135: PUSH
51136: LD_INT 3
51138: PUSH
51139: LD_INT 4
51141: PUSH
51142: LD_INT 5
51144: PUSH
51145: LD_INT 21
51147: PUSH
51148: LD_INT 22
51150: PUSH
51151: LD_INT 23
51153: PUSH
51154: LD_INT 24
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: ST_TO_ADDR
51169: GO 51172
51171: POP
// result := ( chassis in result ) ;
51172: LD_ADDR_VAR 0 3
51176: PUSH
51177: LD_VAR 0 1
51181: PUSH
51182: LD_VAR 0 3
51186: IN
51187: ST_TO_ADDR
// end ;
51188: LD_VAR 0 3
51192: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51193: LD_INT 0
51195: PPUSH
// if not chassis or not weapon then
51196: LD_VAR 0 1
51200: NOT
51201: PUSH
51202: LD_VAR 0 2
51206: NOT
51207: OR
51208: IFFALSE 51212
// exit ;
51210: GO 52238
// case weapon of us_machine_gun :
51212: LD_VAR 0 2
51216: PUSH
51217: LD_INT 2
51219: DOUBLE
51220: EQUAL
51221: IFTRUE 51225
51223: GO 51255
51225: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51226: LD_ADDR_VAR 0 3
51230: PUSH
51231: LD_INT 1
51233: PUSH
51234: LD_INT 2
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 4
51242: PUSH
51243: LD_INT 5
51245: PUSH
51246: EMPTY
51247: LIST
51248: LIST
51249: LIST
51250: LIST
51251: LIST
51252: ST_TO_ADDR
51253: GO 52222
51255: LD_INT 3
51257: DOUBLE
51258: EQUAL
51259: IFTRUE 51263
51261: GO 51293
51263: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51264: LD_ADDR_VAR 0 3
51268: PUSH
51269: LD_INT 1
51271: PUSH
51272: LD_INT 2
51274: PUSH
51275: LD_INT 3
51277: PUSH
51278: LD_INT 4
51280: PUSH
51281: LD_INT 5
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: LIST
51288: LIST
51289: LIST
51290: ST_TO_ADDR
51291: GO 52222
51293: LD_INT 11
51295: DOUBLE
51296: EQUAL
51297: IFTRUE 51301
51299: GO 51331
51301: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51302: LD_ADDR_VAR 0 3
51306: PUSH
51307: LD_INT 1
51309: PUSH
51310: LD_INT 2
51312: PUSH
51313: LD_INT 3
51315: PUSH
51316: LD_INT 4
51318: PUSH
51319: LD_INT 5
51321: PUSH
51322: EMPTY
51323: LIST
51324: LIST
51325: LIST
51326: LIST
51327: LIST
51328: ST_TO_ADDR
51329: GO 52222
51331: LD_INT 4
51333: DOUBLE
51334: EQUAL
51335: IFTRUE 51339
51337: GO 51365
51339: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
51340: LD_ADDR_VAR 0 3
51344: PUSH
51345: LD_INT 2
51347: PUSH
51348: LD_INT 3
51350: PUSH
51351: LD_INT 4
51353: PUSH
51354: LD_INT 5
51356: PUSH
51357: EMPTY
51358: LIST
51359: LIST
51360: LIST
51361: LIST
51362: ST_TO_ADDR
51363: GO 52222
51365: LD_INT 5
51367: DOUBLE
51368: EQUAL
51369: IFTRUE 51373
51371: GO 51399
51373: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51374: LD_ADDR_VAR 0 3
51378: PUSH
51379: LD_INT 2
51381: PUSH
51382: LD_INT 3
51384: PUSH
51385: LD_INT 4
51387: PUSH
51388: LD_INT 5
51390: PUSH
51391: EMPTY
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: ST_TO_ADDR
51397: GO 52222
51399: LD_INT 9
51401: DOUBLE
51402: EQUAL
51403: IFTRUE 51407
51405: GO 51433
51407: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51408: LD_ADDR_VAR 0 3
51412: PUSH
51413: LD_INT 2
51415: PUSH
51416: LD_INT 3
51418: PUSH
51419: LD_INT 4
51421: PUSH
51422: LD_INT 5
51424: PUSH
51425: EMPTY
51426: LIST
51427: LIST
51428: LIST
51429: LIST
51430: ST_TO_ADDR
51431: GO 52222
51433: LD_INT 7
51435: DOUBLE
51436: EQUAL
51437: IFTRUE 51441
51439: GO 51467
51441: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51442: LD_ADDR_VAR 0 3
51446: PUSH
51447: LD_INT 2
51449: PUSH
51450: LD_INT 3
51452: PUSH
51453: LD_INT 4
51455: PUSH
51456: LD_INT 5
51458: PUSH
51459: EMPTY
51460: LIST
51461: LIST
51462: LIST
51463: LIST
51464: ST_TO_ADDR
51465: GO 52222
51467: LD_INT 12
51469: DOUBLE
51470: EQUAL
51471: IFTRUE 51475
51473: GO 51501
51475: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51476: LD_ADDR_VAR 0 3
51480: PUSH
51481: LD_INT 2
51483: PUSH
51484: LD_INT 3
51486: PUSH
51487: LD_INT 4
51489: PUSH
51490: LD_INT 5
51492: PUSH
51493: EMPTY
51494: LIST
51495: LIST
51496: LIST
51497: LIST
51498: ST_TO_ADDR
51499: GO 52222
51501: LD_INT 13
51503: DOUBLE
51504: EQUAL
51505: IFTRUE 51509
51507: GO 51535
51509: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51510: LD_ADDR_VAR 0 3
51514: PUSH
51515: LD_INT 2
51517: PUSH
51518: LD_INT 3
51520: PUSH
51521: LD_INT 4
51523: PUSH
51524: LD_INT 5
51526: PUSH
51527: EMPTY
51528: LIST
51529: LIST
51530: LIST
51531: LIST
51532: ST_TO_ADDR
51533: GO 52222
51535: LD_INT 14
51537: DOUBLE
51538: EQUAL
51539: IFTRUE 51543
51541: GO 51561
51543: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51544: LD_ADDR_VAR 0 3
51548: PUSH
51549: LD_INT 4
51551: PUSH
51552: LD_INT 5
51554: PUSH
51555: EMPTY
51556: LIST
51557: LIST
51558: ST_TO_ADDR
51559: GO 52222
51561: LD_INT 6
51563: DOUBLE
51564: EQUAL
51565: IFTRUE 51569
51567: GO 51587
51569: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51570: LD_ADDR_VAR 0 3
51574: PUSH
51575: LD_INT 4
51577: PUSH
51578: LD_INT 5
51580: PUSH
51581: EMPTY
51582: LIST
51583: LIST
51584: ST_TO_ADDR
51585: GO 52222
51587: LD_INT 10
51589: DOUBLE
51590: EQUAL
51591: IFTRUE 51595
51593: GO 51613
51595: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51596: LD_ADDR_VAR 0 3
51600: PUSH
51601: LD_INT 4
51603: PUSH
51604: LD_INT 5
51606: PUSH
51607: EMPTY
51608: LIST
51609: LIST
51610: ST_TO_ADDR
51611: GO 52222
51613: LD_INT 22
51615: DOUBLE
51616: EQUAL
51617: IFTRUE 51621
51619: GO 51647
51621: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51622: LD_ADDR_VAR 0 3
51626: PUSH
51627: LD_INT 11
51629: PUSH
51630: LD_INT 12
51632: PUSH
51633: LD_INT 13
51635: PUSH
51636: LD_INT 14
51638: PUSH
51639: EMPTY
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: ST_TO_ADDR
51645: GO 52222
51647: LD_INT 23
51649: DOUBLE
51650: EQUAL
51651: IFTRUE 51655
51653: GO 51681
51655: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51656: LD_ADDR_VAR 0 3
51660: PUSH
51661: LD_INT 11
51663: PUSH
51664: LD_INT 12
51666: PUSH
51667: LD_INT 13
51669: PUSH
51670: LD_INT 14
51672: PUSH
51673: EMPTY
51674: LIST
51675: LIST
51676: LIST
51677: LIST
51678: ST_TO_ADDR
51679: GO 52222
51681: LD_INT 24
51683: DOUBLE
51684: EQUAL
51685: IFTRUE 51689
51687: GO 51715
51689: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51690: LD_ADDR_VAR 0 3
51694: PUSH
51695: LD_INT 11
51697: PUSH
51698: LD_INT 12
51700: PUSH
51701: LD_INT 13
51703: PUSH
51704: LD_INT 14
51706: PUSH
51707: EMPTY
51708: LIST
51709: LIST
51710: LIST
51711: LIST
51712: ST_TO_ADDR
51713: GO 52222
51715: LD_INT 30
51717: DOUBLE
51718: EQUAL
51719: IFTRUE 51723
51721: GO 51749
51723: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51724: LD_ADDR_VAR 0 3
51728: PUSH
51729: LD_INT 11
51731: PUSH
51732: LD_INT 12
51734: PUSH
51735: LD_INT 13
51737: PUSH
51738: LD_INT 14
51740: PUSH
51741: EMPTY
51742: LIST
51743: LIST
51744: LIST
51745: LIST
51746: ST_TO_ADDR
51747: GO 52222
51749: LD_INT 25
51751: DOUBLE
51752: EQUAL
51753: IFTRUE 51757
51755: GO 51775
51757: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51758: LD_ADDR_VAR 0 3
51762: PUSH
51763: LD_INT 13
51765: PUSH
51766: LD_INT 14
51768: PUSH
51769: EMPTY
51770: LIST
51771: LIST
51772: ST_TO_ADDR
51773: GO 52222
51775: LD_INT 27
51777: DOUBLE
51778: EQUAL
51779: IFTRUE 51783
51781: GO 51801
51783: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
51784: LD_ADDR_VAR 0 3
51788: PUSH
51789: LD_INT 13
51791: PUSH
51792: LD_INT 14
51794: PUSH
51795: EMPTY
51796: LIST
51797: LIST
51798: ST_TO_ADDR
51799: GO 52222
51801: LD_INT 28
51803: DOUBLE
51804: EQUAL
51805: IFTRUE 51809
51807: GO 51827
51809: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
51810: LD_ADDR_VAR 0 3
51814: PUSH
51815: LD_INT 13
51817: PUSH
51818: LD_INT 14
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: ST_TO_ADDR
51825: GO 52222
51827: LD_INT 29
51829: DOUBLE
51830: EQUAL
51831: IFTRUE 51835
51833: GO 51853
51835: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
51836: LD_ADDR_VAR 0 3
51840: PUSH
51841: LD_INT 13
51843: PUSH
51844: LD_INT 14
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: ST_TO_ADDR
51851: GO 52222
51853: LD_INT 31
51855: DOUBLE
51856: EQUAL
51857: IFTRUE 51861
51859: GO 51879
51861: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
51862: LD_ADDR_VAR 0 3
51866: PUSH
51867: LD_INT 13
51869: PUSH
51870: LD_INT 14
51872: PUSH
51873: EMPTY
51874: LIST
51875: LIST
51876: ST_TO_ADDR
51877: GO 52222
51879: LD_INT 26
51881: DOUBLE
51882: EQUAL
51883: IFTRUE 51887
51885: GO 51905
51887: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
51888: LD_ADDR_VAR 0 3
51892: PUSH
51893: LD_INT 13
51895: PUSH
51896: LD_INT 14
51898: PUSH
51899: EMPTY
51900: LIST
51901: LIST
51902: ST_TO_ADDR
51903: GO 52222
51905: LD_INT 42
51907: DOUBLE
51908: EQUAL
51909: IFTRUE 51913
51911: GO 51939
51913: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
51914: LD_ADDR_VAR 0 3
51918: PUSH
51919: LD_INT 21
51921: PUSH
51922: LD_INT 22
51924: PUSH
51925: LD_INT 23
51927: PUSH
51928: LD_INT 24
51930: PUSH
51931: EMPTY
51932: LIST
51933: LIST
51934: LIST
51935: LIST
51936: ST_TO_ADDR
51937: GO 52222
51939: LD_INT 43
51941: DOUBLE
51942: EQUAL
51943: IFTRUE 51947
51945: GO 51973
51947: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
51948: LD_ADDR_VAR 0 3
51952: PUSH
51953: LD_INT 21
51955: PUSH
51956: LD_INT 22
51958: PUSH
51959: LD_INT 23
51961: PUSH
51962: LD_INT 24
51964: PUSH
51965: EMPTY
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: ST_TO_ADDR
51971: GO 52222
51973: LD_INT 44
51975: DOUBLE
51976: EQUAL
51977: IFTRUE 51981
51979: GO 52007
51981: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
51982: LD_ADDR_VAR 0 3
51986: PUSH
51987: LD_INT 21
51989: PUSH
51990: LD_INT 22
51992: PUSH
51993: LD_INT 23
51995: PUSH
51996: LD_INT 24
51998: PUSH
51999: EMPTY
52000: LIST
52001: LIST
52002: LIST
52003: LIST
52004: ST_TO_ADDR
52005: GO 52222
52007: LD_INT 45
52009: DOUBLE
52010: EQUAL
52011: IFTRUE 52015
52013: GO 52041
52015: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52016: LD_ADDR_VAR 0 3
52020: PUSH
52021: LD_INT 21
52023: PUSH
52024: LD_INT 22
52026: PUSH
52027: LD_INT 23
52029: PUSH
52030: LD_INT 24
52032: PUSH
52033: EMPTY
52034: LIST
52035: LIST
52036: LIST
52037: LIST
52038: ST_TO_ADDR
52039: GO 52222
52041: LD_INT 49
52043: DOUBLE
52044: EQUAL
52045: IFTRUE 52049
52047: GO 52075
52049: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52050: LD_ADDR_VAR 0 3
52054: PUSH
52055: LD_INT 21
52057: PUSH
52058: LD_INT 22
52060: PUSH
52061: LD_INT 23
52063: PUSH
52064: LD_INT 24
52066: PUSH
52067: EMPTY
52068: LIST
52069: LIST
52070: LIST
52071: LIST
52072: ST_TO_ADDR
52073: GO 52222
52075: LD_INT 51
52077: DOUBLE
52078: EQUAL
52079: IFTRUE 52083
52081: GO 52109
52083: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52084: LD_ADDR_VAR 0 3
52088: PUSH
52089: LD_INT 21
52091: PUSH
52092: LD_INT 22
52094: PUSH
52095: LD_INT 23
52097: PUSH
52098: LD_INT 24
52100: PUSH
52101: EMPTY
52102: LIST
52103: LIST
52104: LIST
52105: LIST
52106: ST_TO_ADDR
52107: GO 52222
52109: LD_INT 52
52111: DOUBLE
52112: EQUAL
52113: IFTRUE 52117
52115: GO 52143
52117: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52118: LD_ADDR_VAR 0 3
52122: PUSH
52123: LD_INT 21
52125: PUSH
52126: LD_INT 22
52128: PUSH
52129: LD_INT 23
52131: PUSH
52132: LD_INT 24
52134: PUSH
52135: EMPTY
52136: LIST
52137: LIST
52138: LIST
52139: LIST
52140: ST_TO_ADDR
52141: GO 52222
52143: LD_INT 53
52145: DOUBLE
52146: EQUAL
52147: IFTRUE 52151
52149: GO 52169
52151: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52152: LD_ADDR_VAR 0 3
52156: PUSH
52157: LD_INT 23
52159: PUSH
52160: LD_INT 24
52162: PUSH
52163: EMPTY
52164: LIST
52165: LIST
52166: ST_TO_ADDR
52167: GO 52222
52169: LD_INT 46
52171: DOUBLE
52172: EQUAL
52173: IFTRUE 52177
52175: GO 52195
52177: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52178: LD_ADDR_VAR 0 3
52182: PUSH
52183: LD_INT 23
52185: PUSH
52186: LD_INT 24
52188: PUSH
52189: EMPTY
52190: LIST
52191: LIST
52192: ST_TO_ADDR
52193: GO 52222
52195: LD_INT 47
52197: DOUBLE
52198: EQUAL
52199: IFTRUE 52203
52201: GO 52221
52203: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52204: LD_ADDR_VAR 0 3
52208: PUSH
52209: LD_INT 23
52211: PUSH
52212: LD_INT 24
52214: PUSH
52215: EMPTY
52216: LIST
52217: LIST
52218: ST_TO_ADDR
52219: GO 52222
52221: POP
// result := ( chassis in result ) ;
52222: LD_ADDR_VAR 0 3
52226: PUSH
52227: LD_VAR 0 1
52231: PUSH
52232: LD_VAR 0 3
52236: IN
52237: ST_TO_ADDR
// end ;
52238: LD_VAR 0 3
52242: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52243: LD_INT 0
52245: PPUSH
52246: PPUSH
52247: PPUSH
52248: PPUSH
52249: PPUSH
52250: PPUSH
52251: PPUSH
// result := array ;
52252: LD_ADDR_VAR 0 5
52256: PUSH
52257: LD_VAR 0 1
52261: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52262: LD_VAR 0 1
52266: NOT
52267: PUSH
52268: LD_VAR 0 2
52272: NOT
52273: OR
52274: PUSH
52275: LD_VAR 0 3
52279: NOT
52280: OR
52281: PUSH
52282: LD_VAR 0 2
52286: PUSH
52287: LD_VAR 0 1
52291: GREATER
52292: OR
52293: PUSH
52294: LD_VAR 0 3
52298: PUSH
52299: LD_VAR 0 1
52303: GREATER
52304: OR
52305: IFFALSE 52309
// exit ;
52307: GO 52605
// if direction then
52309: LD_VAR 0 4
52313: IFFALSE 52377
// begin d := 1 ;
52315: LD_ADDR_VAR 0 9
52319: PUSH
52320: LD_INT 1
52322: ST_TO_ADDR
// if i_from > i_to then
52323: LD_VAR 0 2
52327: PUSH
52328: LD_VAR 0 3
52332: GREATER
52333: IFFALSE 52359
// length := ( array - i_from ) + i_to else
52335: LD_ADDR_VAR 0 11
52339: PUSH
52340: LD_VAR 0 1
52344: PUSH
52345: LD_VAR 0 2
52349: MINUS
52350: PUSH
52351: LD_VAR 0 3
52355: PLUS
52356: ST_TO_ADDR
52357: GO 52375
// length := i_to - i_from ;
52359: LD_ADDR_VAR 0 11
52363: PUSH
52364: LD_VAR 0 3
52368: PUSH
52369: LD_VAR 0 2
52373: MINUS
52374: ST_TO_ADDR
// end else
52375: GO 52438
// begin d := - 1 ;
52377: LD_ADDR_VAR 0 9
52381: PUSH
52382: LD_INT 1
52384: NEG
52385: ST_TO_ADDR
// if i_from > i_to then
52386: LD_VAR 0 2
52390: PUSH
52391: LD_VAR 0 3
52395: GREATER
52396: IFFALSE 52416
// length := i_from - i_to else
52398: LD_ADDR_VAR 0 11
52402: PUSH
52403: LD_VAR 0 2
52407: PUSH
52408: LD_VAR 0 3
52412: MINUS
52413: ST_TO_ADDR
52414: GO 52438
// length := ( array - i_to ) + i_from ;
52416: LD_ADDR_VAR 0 11
52420: PUSH
52421: LD_VAR 0 1
52425: PUSH
52426: LD_VAR 0 3
52430: MINUS
52431: PUSH
52432: LD_VAR 0 2
52436: PLUS
52437: ST_TO_ADDR
// end ; if not length then
52438: LD_VAR 0 11
52442: NOT
52443: IFFALSE 52447
// exit ;
52445: GO 52605
// tmp := array ;
52447: LD_ADDR_VAR 0 10
52451: PUSH
52452: LD_VAR 0 1
52456: ST_TO_ADDR
// for i = 1 to length do
52457: LD_ADDR_VAR 0 6
52461: PUSH
52462: DOUBLE
52463: LD_INT 1
52465: DEC
52466: ST_TO_ADDR
52467: LD_VAR 0 11
52471: PUSH
52472: FOR_TO
52473: IFFALSE 52593
// begin for j = 1 to array do
52475: LD_ADDR_VAR 0 7
52479: PUSH
52480: DOUBLE
52481: LD_INT 1
52483: DEC
52484: ST_TO_ADDR
52485: LD_VAR 0 1
52489: PUSH
52490: FOR_TO
52491: IFFALSE 52579
// begin k := j + d ;
52493: LD_ADDR_VAR 0 8
52497: PUSH
52498: LD_VAR 0 7
52502: PUSH
52503: LD_VAR 0 9
52507: PLUS
52508: ST_TO_ADDR
// if k > array then
52509: LD_VAR 0 8
52513: PUSH
52514: LD_VAR 0 1
52518: GREATER
52519: IFFALSE 52529
// k := 1 ;
52521: LD_ADDR_VAR 0 8
52525: PUSH
52526: LD_INT 1
52528: ST_TO_ADDR
// if not k then
52529: LD_VAR 0 8
52533: NOT
52534: IFFALSE 52546
// k := array ;
52536: LD_ADDR_VAR 0 8
52540: PUSH
52541: LD_VAR 0 1
52545: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52546: LD_ADDR_VAR 0 10
52550: PUSH
52551: LD_VAR 0 10
52555: PPUSH
52556: LD_VAR 0 8
52560: PPUSH
52561: LD_VAR 0 1
52565: PUSH
52566: LD_VAR 0 7
52570: ARRAY
52571: PPUSH
52572: CALL_OW 1
52576: ST_TO_ADDR
// end ;
52577: GO 52490
52579: POP
52580: POP
// array := tmp ;
52581: LD_ADDR_VAR 0 1
52585: PUSH
52586: LD_VAR 0 10
52590: ST_TO_ADDR
// end ;
52591: GO 52472
52593: POP
52594: POP
// result := array ;
52595: LD_ADDR_VAR 0 5
52599: PUSH
52600: LD_VAR 0 1
52604: ST_TO_ADDR
// end ;
52605: LD_VAR 0 5
52609: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52610: LD_INT 0
52612: PPUSH
52613: PPUSH
// result := 0 ;
52614: LD_ADDR_VAR 0 3
52618: PUSH
52619: LD_INT 0
52621: ST_TO_ADDR
// if not array or not value in array then
52622: LD_VAR 0 1
52626: NOT
52627: PUSH
52628: LD_VAR 0 2
52632: PUSH
52633: LD_VAR 0 1
52637: IN
52638: NOT
52639: OR
52640: IFFALSE 52644
// exit ;
52642: GO 52698
// for i = 1 to array do
52644: LD_ADDR_VAR 0 4
52648: PUSH
52649: DOUBLE
52650: LD_INT 1
52652: DEC
52653: ST_TO_ADDR
52654: LD_VAR 0 1
52658: PUSH
52659: FOR_TO
52660: IFFALSE 52696
// if value = array [ i ] then
52662: LD_VAR 0 2
52666: PUSH
52667: LD_VAR 0 1
52671: PUSH
52672: LD_VAR 0 4
52676: ARRAY
52677: EQUAL
52678: IFFALSE 52694
// begin result := i ;
52680: LD_ADDR_VAR 0 3
52684: PUSH
52685: LD_VAR 0 4
52689: ST_TO_ADDR
// exit ;
52690: POP
52691: POP
52692: GO 52698
// end ;
52694: GO 52659
52696: POP
52697: POP
// end ;
52698: LD_VAR 0 3
52702: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52703: LD_INT 0
52705: PPUSH
// vc_chassis := chassis ;
52706: LD_ADDR_OWVAR 37
52710: PUSH
52711: LD_VAR 0 1
52715: ST_TO_ADDR
// vc_engine := engine ;
52716: LD_ADDR_OWVAR 39
52720: PUSH
52721: LD_VAR 0 2
52725: ST_TO_ADDR
// vc_control := control ;
52726: LD_ADDR_OWVAR 38
52730: PUSH
52731: LD_VAR 0 3
52735: ST_TO_ADDR
// vc_weapon := weapon ;
52736: LD_ADDR_OWVAR 40
52740: PUSH
52741: LD_VAR 0 4
52745: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52746: LD_ADDR_OWVAR 41
52750: PUSH
52751: LD_VAR 0 5
52755: ST_TO_ADDR
// end ;
52756: LD_VAR 0 6
52760: RET
// export function WantPlant ( unit ) ; var task ; begin
52761: LD_INT 0
52763: PPUSH
52764: PPUSH
// result := false ;
52765: LD_ADDR_VAR 0 2
52769: PUSH
52770: LD_INT 0
52772: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
52773: LD_ADDR_VAR 0 3
52777: PUSH
52778: LD_VAR 0 1
52782: PPUSH
52783: CALL_OW 437
52787: ST_TO_ADDR
// if task then
52788: LD_VAR 0 3
52792: IFFALSE 52820
// if task [ 1 ] [ 1 ] = p then
52794: LD_VAR 0 3
52798: PUSH
52799: LD_INT 1
52801: ARRAY
52802: PUSH
52803: LD_INT 1
52805: ARRAY
52806: PUSH
52807: LD_STRING p
52809: EQUAL
52810: IFFALSE 52820
// result := true ;
52812: LD_ADDR_VAR 0 2
52816: PUSH
52817: LD_INT 1
52819: ST_TO_ADDR
// end ;
52820: LD_VAR 0 2
52824: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
52825: LD_INT 0
52827: PPUSH
52828: PPUSH
52829: PPUSH
52830: PPUSH
// if pos < 1 then
52831: LD_VAR 0 2
52835: PUSH
52836: LD_INT 1
52838: LESS
52839: IFFALSE 52843
// exit ;
52841: GO 53146
// if pos = 1 then
52843: LD_VAR 0 2
52847: PUSH
52848: LD_INT 1
52850: EQUAL
52851: IFFALSE 52884
// result := Replace ( arr , pos [ 1 ] , value ) else
52853: LD_ADDR_VAR 0 4
52857: PUSH
52858: LD_VAR 0 1
52862: PPUSH
52863: LD_VAR 0 2
52867: PUSH
52868: LD_INT 1
52870: ARRAY
52871: PPUSH
52872: LD_VAR 0 3
52876: PPUSH
52877: CALL_OW 1
52881: ST_TO_ADDR
52882: GO 53146
// begin tmp := arr ;
52884: LD_ADDR_VAR 0 6
52888: PUSH
52889: LD_VAR 0 1
52893: ST_TO_ADDR
// s_arr := [ tmp ] ;
52894: LD_ADDR_VAR 0 7
52898: PUSH
52899: LD_VAR 0 6
52903: PUSH
52904: EMPTY
52905: LIST
52906: ST_TO_ADDR
// for i = 1 to pos - 1 do
52907: LD_ADDR_VAR 0 5
52911: PUSH
52912: DOUBLE
52913: LD_INT 1
52915: DEC
52916: ST_TO_ADDR
52917: LD_VAR 0 2
52921: PUSH
52922: LD_INT 1
52924: MINUS
52925: PUSH
52926: FOR_TO
52927: IFFALSE 52972
// begin tmp := tmp [ pos [ i ] ] ;
52929: LD_ADDR_VAR 0 6
52933: PUSH
52934: LD_VAR 0 6
52938: PUSH
52939: LD_VAR 0 2
52943: PUSH
52944: LD_VAR 0 5
52948: ARRAY
52949: ARRAY
52950: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
52951: LD_ADDR_VAR 0 7
52955: PUSH
52956: LD_VAR 0 7
52960: PUSH
52961: LD_VAR 0 6
52965: PUSH
52966: EMPTY
52967: LIST
52968: ADD
52969: ST_TO_ADDR
// end ;
52970: GO 52926
52972: POP
52973: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
52974: LD_ADDR_VAR 0 6
52978: PUSH
52979: LD_VAR 0 6
52983: PPUSH
52984: LD_VAR 0 2
52988: PUSH
52989: LD_VAR 0 2
52993: ARRAY
52994: PPUSH
52995: LD_VAR 0 3
52999: PPUSH
53000: CALL_OW 1
53004: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53005: LD_ADDR_VAR 0 7
53009: PUSH
53010: LD_VAR 0 7
53014: PPUSH
53015: LD_VAR 0 7
53019: PPUSH
53020: LD_VAR 0 6
53024: PPUSH
53025: CALL_OW 1
53029: ST_TO_ADDR
// for i = s_arr downto 2 do
53030: LD_ADDR_VAR 0 5
53034: PUSH
53035: DOUBLE
53036: LD_VAR 0 7
53040: INC
53041: ST_TO_ADDR
53042: LD_INT 2
53044: PUSH
53045: FOR_DOWNTO
53046: IFFALSE 53130
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53048: LD_ADDR_VAR 0 6
53052: PUSH
53053: LD_VAR 0 7
53057: PUSH
53058: LD_VAR 0 5
53062: PUSH
53063: LD_INT 1
53065: MINUS
53066: ARRAY
53067: PPUSH
53068: LD_VAR 0 2
53072: PUSH
53073: LD_VAR 0 5
53077: PUSH
53078: LD_INT 1
53080: MINUS
53081: ARRAY
53082: PPUSH
53083: LD_VAR 0 7
53087: PUSH
53088: LD_VAR 0 5
53092: ARRAY
53093: PPUSH
53094: CALL_OW 1
53098: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53099: LD_ADDR_VAR 0 7
53103: PUSH
53104: LD_VAR 0 7
53108: PPUSH
53109: LD_VAR 0 5
53113: PUSH
53114: LD_INT 1
53116: MINUS
53117: PPUSH
53118: LD_VAR 0 6
53122: PPUSH
53123: CALL_OW 1
53127: ST_TO_ADDR
// end ;
53128: GO 53045
53130: POP
53131: POP
// result := s_arr [ 1 ] ;
53132: LD_ADDR_VAR 0 4
53136: PUSH
53137: LD_VAR 0 7
53141: PUSH
53142: LD_INT 1
53144: ARRAY
53145: ST_TO_ADDR
// end ; end ;
53146: LD_VAR 0 4
53150: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53151: LD_INT 0
53153: PPUSH
53154: PPUSH
// if not list then
53155: LD_VAR 0 1
53159: NOT
53160: IFFALSE 53164
// exit ;
53162: GO 53255
// i := list [ pos1 ] ;
53164: LD_ADDR_VAR 0 5
53168: PUSH
53169: LD_VAR 0 1
53173: PUSH
53174: LD_VAR 0 2
53178: ARRAY
53179: ST_TO_ADDR
// if not i then
53180: LD_VAR 0 5
53184: NOT
53185: IFFALSE 53189
// exit ;
53187: GO 53255
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53189: LD_ADDR_VAR 0 1
53193: PUSH
53194: LD_VAR 0 1
53198: PPUSH
53199: LD_VAR 0 2
53203: PPUSH
53204: LD_VAR 0 1
53208: PUSH
53209: LD_VAR 0 3
53213: ARRAY
53214: PPUSH
53215: CALL_OW 1
53219: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53220: LD_ADDR_VAR 0 1
53224: PUSH
53225: LD_VAR 0 1
53229: PPUSH
53230: LD_VAR 0 3
53234: PPUSH
53235: LD_VAR 0 5
53239: PPUSH
53240: CALL_OW 1
53244: ST_TO_ADDR
// result := list ;
53245: LD_ADDR_VAR 0 4
53249: PUSH
53250: LD_VAR 0 1
53254: ST_TO_ADDR
// end ;
53255: LD_VAR 0 4
53259: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53260: LD_INT 0
53262: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53263: LD_ADDR_VAR 0 5
53267: PUSH
53268: LD_VAR 0 1
53272: PPUSH
53273: CALL_OW 250
53277: PPUSH
53278: LD_VAR 0 1
53282: PPUSH
53283: CALL_OW 251
53287: PPUSH
53288: LD_VAR 0 2
53292: PPUSH
53293: LD_VAR 0 3
53297: PPUSH
53298: LD_VAR 0 4
53302: PPUSH
53303: CALL 53313 0 5
53307: ST_TO_ADDR
// end ;
53308: LD_VAR 0 5
53312: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
53313: LD_INT 0
53315: PPUSH
53316: PPUSH
53317: PPUSH
53318: PPUSH
// if not list then
53319: LD_VAR 0 3
53323: NOT
53324: IFFALSE 53328
// exit ;
53326: GO 53716
// result := [ ] ;
53328: LD_ADDR_VAR 0 6
53332: PUSH
53333: EMPTY
53334: ST_TO_ADDR
// for i in list do
53335: LD_ADDR_VAR 0 7
53339: PUSH
53340: LD_VAR 0 3
53344: PUSH
53345: FOR_IN
53346: IFFALSE 53548
// begin tmp := GetDistUnitXY ( i , x , y ) ;
53348: LD_ADDR_VAR 0 9
53352: PUSH
53353: LD_VAR 0 7
53357: PPUSH
53358: LD_VAR 0 1
53362: PPUSH
53363: LD_VAR 0 2
53367: PPUSH
53368: CALL_OW 297
53372: ST_TO_ADDR
// if not result then
53373: LD_VAR 0 6
53377: NOT
53378: IFFALSE 53404
// result := [ [ i , tmp ] ] else
53380: LD_ADDR_VAR 0 6
53384: PUSH
53385: LD_VAR 0 7
53389: PUSH
53390: LD_VAR 0 9
53394: PUSH
53395: EMPTY
53396: LIST
53397: LIST
53398: PUSH
53399: EMPTY
53400: LIST
53401: ST_TO_ADDR
53402: GO 53546
// begin if result [ result ] [ 2 ] < tmp then
53404: LD_VAR 0 6
53408: PUSH
53409: LD_VAR 0 6
53413: ARRAY
53414: PUSH
53415: LD_INT 2
53417: ARRAY
53418: PUSH
53419: LD_VAR 0 9
53423: LESS
53424: IFFALSE 53466
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53426: LD_ADDR_VAR 0 6
53430: PUSH
53431: LD_VAR 0 6
53435: PPUSH
53436: LD_VAR 0 6
53440: PUSH
53441: LD_INT 1
53443: PLUS
53444: PPUSH
53445: LD_VAR 0 7
53449: PUSH
53450: LD_VAR 0 9
53454: PUSH
53455: EMPTY
53456: LIST
53457: LIST
53458: PPUSH
53459: CALL_OW 2
53463: ST_TO_ADDR
53464: GO 53546
// for j = 1 to result do
53466: LD_ADDR_VAR 0 8
53470: PUSH
53471: DOUBLE
53472: LD_INT 1
53474: DEC
53475: ST_TO_ADDR
53476: LD_VAR 0 6
53480: PUSH
53481: FOR_TO
53482: IFFALSE 53544
// begin if tmp < result [ j ] [ 2 ] then
53484: LD_VAR 0 9
53488: PUSH
53489: LD_VAR 0 6
53493: PUSH
53494: LD_VAR 0 8
53498: ARRAY
53499: PUSH
53500: LD_INT 2
53502: ARRAY
53503: LESS
53504: IFFALSE 53542
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53506: LD_ADDR_VAR 0 6
53510: PUSH
53511: LD_VAR 0 6
53515: PPUSH
53516: LD_VAR 0 8
53520: PPUSH
53521: LD_VAR 0 7
53525: PUSH
53526: LD_VAR 0 9
53530: PUSH
53531: EMPTY
53532: LIST
53533: LIST
53534: PPUSH
53535: CALL_OW 2
53539: ST_TO_ADDR
// break ;
53540: GO 53544
// end ; end ;
53542: GO 53481
53544: POP
53545: POP
// end ; end ;
53546: GO 53345
53548: POP
53549: POP
// if result and not asc then
53550: LD_VAR 0 6
53554: PUSH
53555: LD_VAR 0 4
53559: NOT
53560: AND
53561: IFFALSE 53636
// begin tmp := result ;
53563: LD_ADDR_VAR 0 9
53567: PUSH
53568: LD_VAR 0 6
53572: ST_TO_ADDR
// for i = tmp downto 1 do
53573: LD_ADDR_VAR 0 7
53577: PUSH
53578: DOUBLE
53579: LD_VAR 0 9
53583: INC
53584: ST_TO_ADDR
53585: LD_INT 1
53587: PUSH
53588: FOR_DOWNTO
53589: IFFALSE 53634
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53591: LD_ADDR_VAR 0 6
53595: PUSH
53596: LD_VAR 0 6
53600: PPUSH
53601: LD_VAR 0 9
53605: PUSH
53606: LD_VAR 0 7
53610: MINUS
53611: PUSH
53612: LD_INT 1
53614: PLUS
53615: PPUSH
53616: LD_VAR 0 9
53620: PUSH
53621: LD_VAR 0 7
53625: ARRAY
53626: PPUSH
53627: CALL_OW 1
53631: ST_TO_ADDR
53632: GO 53588
53634: POP
53635: POP
// end ; tmp := [ ] ;
53636: LD_ADDR_VAR 0 9
53640: PUSH
53641: EMPTY
53642: ST_TO_ADDR
// if mode then
53643: LD_VAR 0 5
53647: IFFALSE 53716
// begin for i = 1 to result do
53649: LD_ADDR_VAR 0 7
53653: PUSH
53654: DOUBLE
53655: LD_INT 1
53657: DEC
53658: ST_TO_ADDR
53659: LD_VAR 0 6
53663: PUSH
53664: FOR_TO
53665: IFFALSE 53704
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53667: LD_ADDR_VAR 0 9
53671: PUSH
53672: LD_VAR 0 9
53676: PPUSH
53677: LD_VAR 0 7
53681: PPUSH
53682: LD_VAR 0 6
53686: PUSH
53687: LD_VAR 0 7
53691: ARRAY
53692: PUSH
53693: LD_INT 1
53695: ARRAY
53696: PPUSH
53697: CALL_OW 1
53701: ST_TO_ADDR
53702: GO 53664
53704: POP
53705: POP
// result := tmp ;
53706: LD_ADDR_VAR 0 6
53710: PUSH
53711: LD_VAR 0 9
53715: ST_TO_ADDR
// end ; end ;
53716: LD_VAR 0 6
53720: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53721: LD_INT 0
53723: PPUSH
53724: PPUSH
53725: PPUSH
53726: PPUSH
53727: PPUSH
53728: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53729: LD_ADDR_VAR 0 5
53733: PUSH
53734: LD_INT 0
53736: PUSH
53737: LD_INT 0
53739: PUSH
53740: LD_INT 0
53742: PUSH
53743: EMPTY
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: ST_TO_ADDR
// if not x or not y then
53751: LD_VAR 0 2
53755: NOT
53756: PUSH
53757: LD_VAR 0 3
53761: NOT
53762: OR
53763: IFFALSE 53767
// exit ;
53765: GO 55413
// if not range then
53767: LD_VAR 0 4
53771: NOT
53772: IFFALSE 53782
// range := 10 ;
53774: LD_ADDR_VAR 0 4
53778: PUSH
53779: LD_INT 10
53781: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53782: LD_ADDR_VAR 0 8
53786: PUSH
53787: LD_INT 81
53789: PUSH
53790: LD_VAR 0 1
53794: PUSH
53795: EMPTY
53796: LIST
53797: LIST
53798: PUSH
53799: LD_INT 92
53801: PUSH
53802: LD_VAR 0 2
53806: PUSH
53807: LD_VAR 0 3
53811: PUSH
53812: LD_VAR 0 4
53816: PUSH
53817: EMPTY
53818: LIST
53819: LIST
53820: LIST
53821: LIST
53822: PUSH
53823: LD_INT 3
53825: PUSH
53826: LD_INT 21
53828: PUSH
53829: LD_INT 3
53831: PUSH
53832: EMPTY
53833: LIST
53834: LIST
53835: PUSH
53836: EMPTY
53837: LIST
53838: LIST
53839: PUSH
53840: EMPTY
53841: LIST
53842: LIST
53843: LIST
53844: PPUSH
53845: CALL_OW 69
53849: ST_TO_ADDR
// if not tmp then
53850: LD_VAR 0 8
53854: NOT
53855: IFFALSE 53859
// exit ;
53857: GO 55413
// for i in tmp do
53859: LD_ADDR_VAR 0 6
53863: PUSH
53864: LD_VAR 0 8
53868: PUSH
53869: FOR_IN
53870: IFFALSE 55388
// begin points := [ 0 , 0 , 0 ] ;
53872: LD_ADDR_VAR 0 9
53876: PUSH
53877: LD_INT 0
53879: PUSH
53880: LD_INT 0
53882: PUSH
53883: LD_INT 0
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: LIST
53890: ST_TO_ADDR
// bpoints := 1 ;
53891: LD_ADDR_VAR 0 10
53895: PUSH
53896: LD_INT 1
53898: ST_TO_ADDR
// case GetType ( i ) of unit_human :
53899: LD_VAR 0 6
53903: PPUSH
53904: CALL_OW 247
53908: PUSH
53909: LD_INT 1
53911: DOUBLE
53912: EQUAL
53913: IFTRUE 53917
53915: GO 54495
53917: POP
// begin if GetClass ( i ) = 1 then
53918: LD_VAR 0 6
53922: PPUSH
53923: CALL_OW 257
53927: PUSH
53928: LD_INT 1
53930: EQUAL
53931: IFFALSE 53952
// points := [ 10 , 5 , 3 ] ;
53933: LD_ADDR_VAR 0 9
53937: PUSH
53938: LD_INT 10
53940: PUSH
53941: LD_INT 5
53943: PUSH
53944: LD_INT 3
53946: PUSH
53947: EMPTY
53948: LIST
53949: LIST
53950: LIST
53951: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
53952: LD_VAR 0 6
53956: PPUSH
53957: CALL_OW 257
53961: PUSH
53962: LD_INT 2
53964: PUSH
53965: LD_INT 3
53967: PUSH
53968: LD_INT 4
53970: PUSH
53971: EMPTY
53972: LIST
53973: LIST
53974: LIST
53975: IN
53976: IFFALSE 53997
// points := [ 3 , 2 , 1 ] ;
53978: LD_ADDR_VAR 0 9
53982: PUSH
53983: LD_INT 3
53985: PUSH
53986: LD_INT 2
53988: PUSH
53989: LD_INT 1
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: LIST
53996: ST_TO_ADDR
// if GetClass ( i ) = 5 then
53997: LD_VAR 0 6
54001: PPUSH
54002: CALL_OW 257
54006: PUSH
54007: LD_INT 5
54009: EQUAL
54010: IFFALSE 54031
// points := [ 130 , 5 , 2 ] ;
54012: LD_ADDR_VAR 0 9
54016: PUSH
54017: LD_INT 130
54019: PUSH
54020: LD_INT 5
54022: PUSH
54023: LD_INT 2
54025: PUSH
54026: EMPTY
54027: LIST
54028: LIST
54029: LIST
54030: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54031: LD_VAR 0 6
54035: PPUSH
54036: CALL_OW 257
54040: PUSH
54041: LD_INT 8
54043: EQUAL
54044: IFFALSE 54065
// points := [ 35 , 35 , 30 ] ;
54046: LD_ADDR_VAR 0 9
54050: PUSH
54051: LD_INT 35
54053: PUSH
54054: LD_INT 35
54056: PUSH
54057: LD_INT 30
54059: PUSH
54060: EMPTY
54061: LIST
54062: LIST
54063: LIST
54064: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54065: LD_VAR 0 6
54069: PPUSH
54070: CALL_OW 257
54074: PUSH
54075: LD_INT 9
54077: EQUAL
54078: IFFALSE 54099
// points := [ 20 , 55 , 40 ] ;
54080: LD_ADDR_VAR 0 9
54084: PUSH
54085: LD_INT 20
54087: PUSH
54088: LD_INT 55
54090: PUSH
54091: LD_INT 40
54093: PUSH
54094: EMPTY
54095: LIST
54096: LIST
54097: LIST
54098: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54099: LD_VAR 0 6
54103: PPUSH
54104: CALL_OW 257
54108: PUSH
54109: LD_INT 12
54111: PUSH
54112: LD_INT 16
54114: PUSH
54115: EMPTY
54116: LIST
54117: LIST
54118: IN
54119: IFFALSE 54140
// points := [ 5 , 3 , 2 ] ;
54121: LD_ADDR_VAR 0 9
54125: PUSH
54126: LD_INT 5
54128: PUSH
54129: LD_INT 3
54131: PUSH
54132: LD_INT 2
54134: PUSH
54135: EMPTY
54136: LIST
54137: LIST
54138: LIST
54139: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54140: LD_VAR 0 6
54144: PPUSH
54145: CALL_OW 257
54149: PUSH
54150: LD_INT 17
54152: EQUAL
54153: IFFALSE 54174
// points := [ 100 , 50 , 75 ] ;
54155: LD_ADDR_VAR 0 9
54159: PUSH
54160: LD_INT 100
54162: PUSH
54163: LD_INT 50
54165: PUSH
54166: LD_INT 75
54168: PUSH
54169: EMPTY
54170: LIST
54171: LIST
54172: LIST
54173: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54174: LD_VAR 0 6
54178: PPUSH
54179: CALL_OW 257
54183: PUSH
54184: LD_INT 15
54186: EQUAL
54187: IFFALSE 54208
// points := [ 10 , 5 , 3 ] ;
54189: LD_ADDR_VAR 0 9
54193: PUSH
54194: LD_INT 10
54196: PUSH
54197: LD_INT 5
54199: PUSH
54200: LD_INT 3
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: LIST
54207: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54208: LD_VAR 0 6
54212: PPUSH
54213: CALL_OW 257
54217: PUSH
54218: LD_INT 14
54220: EQUAL
54221: IFFALSE 54242
// points := [ 10 , 0 , 0 ] ;
54223: LD_ADDR_VAR 0 9
54227: PUSH
54228: LD_INT 10
54230: PUSH
54231: LD_INT 0
54233: PUSH
54234: LD_INT 0
54236: PUSH
54237: EMPTY
54238: LIST
54239: LIST
54240: LIST
54241: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54242: LD_VAR 0 6
54246: PPUSH
54247: CALL_OW 257
54251: PUSH
54252: LD_INT 11
54254: EQUAL
54255: IFFALSE 54276
// points := [ 30 , 10 , 5 ] ;
54257: LD_ADDR_VAR 0 9
54261: PUSH
54262: LD_INT 30
54264: PUSH
54265: LD_INT 10
54267: PUSH
54268: LD_INT 5
54270: PUSH
54271: EMPTY
54272: LIST
54273: LIST
54274: LIST
54275: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54276: LD_VAR 0 1
54280: PPUSH
54281: LD_INT 5
54283: PPUSH
54284: CALL_OW 321
54288: PUSH
54289: LD_INT 2
54291: EQUAL
54292: IFFALSE 54309
// bpoints := bpoints * 1.8 ;
54294: LD_ADDR_VAR 0 10
54298: PUSH
54299: LD_VAR 0 10
54303: PUSH
54304: LD_REAL  1.80000000000000E+0000
54307: MUL
54308: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
54309: LD_VAR 0 6
54313: PPUSH
54314: CALL_OW 257
54318: PUSH
54319: LD_INT 1
54321: PUSH
54322: LD_INT 2
54324: PUSH
54325: LD_INT 3
54327: PUSH
54328: LD_INT 4
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: LIST
54335: LIST
54336: IN
54337: PUSH
54338: LD_VAR 0 1
54342: PPUSH
54343: LD_INT 51
54345: PPUSH
54346: CALL_OW 321
54350: PUSH
54351: LD_INT 2
54353: EQUAL
54354: AND
54355: IFFALSE 54372
// bpoints := bpoints * 1.2 ;
54357: LD_ADDR_VAR 0 10
54361: PUSH
54362: LD_VAR 0 10
54366: PUSH
54367: LD_REAL  1.20000000000000E+0000
54370: MUL
54371: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54372: LD_VAR 0 6
54376: PPUSH
54377: CALL_OW 257
54381: PUSH
54382: LD_INT 5
54384: PUSH
54385: LD_INT 7
54387: PUSH
54388: LD_INT 9
54390: PUSH
54391: EMPTY
54392: LIST
54393: LIST
54394: LIST
54395: IN
54396: PUSH
54397: LD_VAR 0 1
54401: PPUSH
54402: LD_INT 52
54404: PPUSH
54405: CALL_OW 321
54409: PUSH
54410: LD_INT 2
54412: EQUAL
54413: AND
54414: IFFALSE 54431
// bpoints := bpoints * 1.5 ;
54416: LD_ADDR_VAR 0 10
54420: PUSH
54421: LD_VAR 0 10
54425: PUSH
54426: LD_REAL  1.50000000000000E+0000
54429: MUL
54430: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
54431: LD_VAR 0 1
54435: PPUSH
54436: LD_INT 66
54438: PPUSH
54439: CALL_OW 321
54443: PUSH
54444: LD_INT 2
54446: EQUAL
54447: IFFALSE 54464
// bpoints := bpoints * 1.1 ;
54449: LD_ADDR_VAR 0 10
54453: PUSH
54454: LD_VAR 0 10
54458: PUSH
54459: LD_REAL  1.10000000000000E+0000
54462: MUL
54463: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54464: LD_ADDR_VAR 0 10
54468: PUSH
54469: LD_VAR 0 10
54473: PUSH
54474: LD_VAR 0 6
54478: PPUSH
54479: LD_INT 1
54481: PPUSH
54482: CALL_OW 259
54486: PUSH
54487: LD_REAL  1.15000000000000E+0000
54490: MUL
54491: MUL
54492: ST_TO_ADDR
// end ; unit_vehicle :
54493: GO 55317
54495: LD_INT 2
54497: DOUBLE
54498: EQUAL
54499: IFTRUE 54503
54501: GO 55305
54503: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54504: LD_VAR 0 6
54508: PPUSH
54509: CALL_OW 264
54513: PUSH
54514: LD_INT 2
54516: PUSH
54517: LD_INT 42
54519: PUSH
54520: LD_INT 24
54522: PUSH
54523: EMPTY
54524: LIST
54525: LIST
54526: LIST
54527: IN
54528: IFFALSE 54549
// points := [ 25 , 5 , 3 ] ;
54530: LD_ADDR_VAR 0 9
54534: PUSH
54535: LD_INT 25
54537: PUSH
54538: LD_INT 5
54540: PUSH
54541: LD_INT 3
54543: PUSH
54544: EMPTY
54545: LIST
54546: LIST
54547: LIST
54548: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54549: LD_VAR 0 6
54553: PPUSH
54554: CALL_OW 264
54558: PUSH
54559: LD_INT 4
54561: PUSH
54562: LD_INT 43
54564: PUSH
54565: LD_INT 25
54567: PUSH
54568: EMPTY
54569: LIST
54570: LIST
54571: LIST
54572: IN
54573: IFFALSE 54594
// points := [ 40 , 15 , 5 ] ;
54575: LD_ADDR_VAR 0 9
54579: PUSH
54580: LD_INT 40
54582: PUSH
54583: LD_INT 15
54585: PUSH
54586: LD_INT 5
54588: PUSH
54589: EMPTY
54590: LIST
54591: LIST
54592: LIST
54593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54594: LD_VAR 0 6
54598: PPUSH
54599: CALL_OW 264
54603: PUSH
54604: LD_INT 3
54606: PUSH
54607: LD_INT 23
54609: PUSH
54610: EMPTY
54611: LIST
54612: LIST
54613: IN
54614: IFFALSE 54635
// points := [ 7 , 25 , 8 ] ;
54616: LD_ADDR_VAR 0 9
54620: PUSH
54621: LD_INT 7
54623: PUSH
54624: LD_INT 25
54626: PUSH
54627: LD_INT 8
54629: PUSH
54630: EMPTY
54631: LIST
54632: LIST
54633: LIST
54634: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54635: LD_VAR 0 6
54639: PPUSH
54640: CALL_OW 264
54644: PUSH
54645: LD_INT 5
54647: PUSH
54648: LD_INT 27
54650: PUSH
54651: LD_INT 44
54653: PUSH
54654: EMPTY
54655: LIST
54656: LIST
54657: LIST
54658: IN
54659: IFFALSE 54680
// points := [ 14 , 50 , 16 ] ;
54661: LD_ADDR_VAR 0 9
54665: PUSH
54666: LD_INT 14
54668: PUSH
54669: LD_INT 50
54671: PUSH
54672: LD_INT 16
54674: PUSH
54675: EMPTY
54676: LIST
54677: LIST
54678: LIST
54679: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54680: LD_VAR 0 6
54684: PPUSH
54685: CALL_OW 264
54689: PUSH
54690: LD_INT 6
54692: PUSH
54693: LD_INT 46
54695: PUSH
54696: EMPTY
54697: LIST
54698: LIST
54699: IN
54700: IFFALSE 54721
// points := [ 32 , 120 , 70 ] ;
54702: LD_ADDR_VAR 0 9
54706: PUSH
54707: LD_INT 32
54709: PUSH
54710: LD_INT 120
54712: PUSH
54713: LD_INT 70
54715: PUSH
54716: EMPTY
54717: LIST
54718: LIST
54719: LIST
54720: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54721: LD_VAR 0 6
54725: PPUSH
54726: CALL_OW 264
54730: PUSH
54731: LD_INT 7
54733: PUSH
54734: LD_INT 28
54736: PUSH
54737: LD_INT 45
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: LIST
54744: IN
54745: IFFALSE 54766
// points := [ 35 , 20 , 45 ] ;
54747: LD_ADDR_VAR 0 9
54751: PUSH
54752: LD_INT 35
54754: PUSH
54755: LD_INT 20
54757: PUSH
54758: LD_INT 45
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: LIST
54765: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54766: LD_VAR 0 6
54770: PPUSH
54771: CALL_OW 264
54775: PUSH
54776: LD_INT 47
54778: PUSH
54779: EMPTY
54780: LIST
54781: IN
54782: IFFALSE 54803
// points := [ 67 , 45 , 75 ] ;
54784: LD_ADDR_VAR 0 9
54788: PUSH
54789: LD_INT 67
54791: PUSH
54792: LD_INT 45
54794: PUSH
54795: LD_INT 75
54797: PUSH
54798: EMPTY
54799: LIST
54800: LIST
54801: LIST
54802: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
54803: LD_VAR 0 6
54807: PPUSH
54808: CALL_OW 264
54812: PUSH
54813: LD_INT 26
54815: PUSH
54816: EMPTY
54817: LIST
54818: IN
54819: IFFALSE 54840
// points := [ 120 , 30 , 80 ] ;
54821: LD_ADDR_VAR 0 9
54825: PUSH
54826: LD_INT 120
54828: PUSH
54829: LD_INT 30
54831: PUSH
54832: LD_INT 80
54834: PUSH
54835: EMPTY
54836: LIST
54837: LIST
54838: LIST
54839: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
54840: LD_VAR 0 6
54844: PPUSH
54845: CALL_OW 264
54849: PUSH
54850: LD_INT 22
54852: PUSH
54853: EMPTY
54854: LIST
54855: IN
54856: IFFALSE 54877
// points := [ 40 , 1 , 1 ] ;
54858: LD_ADDR_VAR 0 9
54862: PUSH
54863: LD_INT 40
54865: PUSH
54866: LD_INT 1
54868: PUSH
54869: LD_INT 1
54871: PUSH
54872: EMPTY
54873: LIST
54874: LIST
54875: LIST
54876: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
54877: LD_VAR 0 6
54881: PPUSH
54882: CALL_OW 264
54886: PUSH
54887: LD_INT 29
54889: PUSH
54890: EMPTY
54891: LIST
54892: IN
54893: IFFALSE 54914
// points := [ 70 , 200 , 400 ] ;
54895: LD_ADDR_VAR 0 9
54899: PUSH
54900: LD_INT 70
54902: PUSH
54903: LD_INT 200
54905: PUSH
54906: LD_INT 400
54908: PUSH
54909: EMPTY
54910: LIST
54911: LIST
54912: LIST
54913: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
54914: LD_VAR 0 6
54918: PPUSH
54919: CALL_OW 264
54923: PUSH
54924: LD_INT 14
54926: PUSH
54927: LD_INT 53
54929: PUSH
54930: EMPTY
54931: LIST
54932: LIST
54933: IN
54934: IFFALSE 54955
// points := [ 40 , 10 , 20 ] ;
54936: LD_ADDR_VAR 0 9
54940: PUSH
54941: LD_INT 40
54943: PUSH
54944: LD_INT 10
54946: PUSH
54947: LD_INT 20
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: LIST
54954: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
54955: LD_VAR 0 6
54959: PPUSH
54960: CALL_OW 264
54964: PUSH
54965: LD_INT 9
54967: PUSH
54968: EMPTY
54969: LIST
54970: IN
54971: IFFALSE 54992
// points := [ 5 , 70 , 20 ] ;
54973: LD_ADDR_VAR 0 9
54977: PUSH
54978: LD_INT 5
54980: PUSH
54981: LD_INT 70
54983: PUSH
54984: LD_INT 20
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: LIST
54991: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
54992: LD_VAR 0 6
54996: PPUSH
54997: CALL_OW 264
55001: PUSH
55002: LD_INT 10
55004: PUSH
55005: EMPTY
55006: LIST
55007: IN
55008: IFFALSE 55029
// points := [ 35 , 110 , 70 ] ;
55010: LD_ADDR_VAR 0 9
55014: PUSH
55015: LD_INT 35
55017: PUSH
55018: LD_INT 110
55020: PUSH
55021: LD_INT 70
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: LIST
55028: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55029: LD_VAR 0 6
55033: PPUSH
55034: CALL_OW 265
55038: PUSH
55039: LD_INT 25
55041: EQUAL
55042: IFFALSE 55063
// points := [ 80 , 65 , 100 ] ;
55044: LD_ADDR_VAR 0 9
55048: PUSH
55049: LD_INT 80
55051: PUSH
55052: LD_INT 65
55054: PUSH
55055: LD_INT 100
55057: PUSH
55058: EMPTY
55059: LIST
55060: LIST
55061: LIST
55062: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55063: LD_VAR 0 6
55067: PPUSH
55068: CALL_OW 263
55072: PUSH
55073: LD_INT 1
55075: EQUAL
55076: IFFALSE 55111
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55078: LD_ADDR_VAR 0 10
55082: PUSH
55083: LD_VAR 0 10
55087: PUSH
55088: LD_VAR 0 6
55092: PPUSH
55093: CALL_OW 311
55097: PPUSH
55098: LD_INT 3
55100: PPUSH
55101: CALL_OW 259
55105: PUSH
55106: LD_INT 4
55108: MUL
55109: MUL
55110: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55111: LD_VAR 0 6
55115: PPUSH
55116: CALL_OW 263
55120: PUSH
55121: LD_INT 2
55123: EQUAL
55124: IFFALSE 55175
// begin j := IsControledBy ( i ) ;
55126: LD_ADDR_VAR 0 7
55130: PUSH
55131: LD_VAR 0 6
55135: PPUSH
55136: CALL_OW 312
55140: ST_TO_ADDR
// if j then
55141: LD_VAR 0 7
55145: IFFALSE 55175
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55147: LD_ADDR_VAR 0 10
55151: PUSH
55152: LD_VAR 0 10
55156: PUSH
55157: LD_VAR 0 7
55161: PPUSH
55162: LD_INT 3
55164: PPUSH
55165: CALL_OW 259
55169: PUSH
55170: LD_INT 3
55172: MUL
55173: MUL
55174: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55175: LD_VAR 0 6
55179: PPUSH
55180: CALL_OW 264
55184: PUSH
55185: LD_INT 5
55187: PUSH
55188: LD_INT 6
55190: PUSH
55191: LD_INT 46
55193: PUSH
55194: LD_INT 44
55196: PUSH
55197: LD_INT 47
55199: PUSH
55200: LD_INT 45
55202: PUSH
55203: LD_INT 28
55205: PUSH
55206: LD_INT 7
55208: PUSH
55209: LD_INT 27
55211: PUSH
55212: LD_INT 29
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: LIST
55219: LIST
55220: LIST
55221: LIST
55222: LIST
55223: LIST
55224: LIST
55225: LIST
55226: IN
55227: PUSH
55228: LD_VAR 0 1
55232: PPUSH
55233: LD_INT 52
55235: PPUSH
55236: CALL_OW 321
55240: PUSH
55241: LD_INT 2
55243: EQUAL
55244: AND
55245: IFFALSE 55262
// bpoints := bpoints * 1.2 ;
55247: LD_ADDR_VAR 0 10
55251: PUSH
55252: LD_VAR 0 10
55256: PUSH
55257: LD_REAL  1.20000000000000E+0000
55260: MUL
55261: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55262: LD_VAR 0 6
55266: PPUSH
55267: CALL_OW 264
55271: PUSH
55272: LD_INT 6
55274: PUSH
55275: LD_INT 46
55277: PUSH
55278: LD_INT 47
55280: PUSH
55281: EMPTY
55282: LIST
55283: LIST
55284: LIST
55285: IN
55286: IFFALSE 55303
// bpoints := bpoints * 1.2 ;
55288: LD_ADDR_VAR 0 10
55292: PUSH
55293: LD_VAR 0 10
55297: PUSH
55298: LD_REAL  1.20000000000000E+0000
55301: MUL
55302: ST_TO_ADDR
// end ; unit_building :
55303: GO 55317
55305: LD_INT 3
55307: DOUBLE
55308: EQUAL
55309: IFTRUE 55313
55311: GO 55316
55313: POP
// ; end ;
55314: GO 55317
55316: POP
// for j = 1 to 3 do
55317: LD_ADDR_VAR 0 7
55321: PUSH
55322: DOUBLE
55323: LD_INT 1
55325: DEC
55326: ST_TO_ADDR
55327: LD_INT 3
55329: PUSH
55330: FOR_TO
55331: IFFALSE 55384
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
55333: LD_ADDR_VAR 0 5
55337: PUSH
55338: LD_VAR 0 5
55342: PPUSH
55343: LD_VAR 0 7
55347: PPUSH
55348: LD_VAR 0 5
55352: PUSH
55353: LD_VAR 0 7
55357: ARRAY
55358: PUSH
55359: LD_VAR 0 9
55363: PUSH
55364: LD_VAR 0 7
55368: ARRAY
55369: PUSH
55370: LD_VAR 0 10
55374: MUL
55375: PLUS
55376: PPUSH
55377: CALL_OW 1
55381: ST_TO_ADDR
55382: GO 55330
55384: POP
55385: POP
// end ;
55386: GO 53869
55388: POP
55389: POP
// result := Replace ( result , 4 , tmp ) ;
55390: LD_ADDR_VAR 0 5
55394: PUSH
55395: LD_VAR 0 5
55399: PPUSH
55400: LD_INT 4
55402: PPUSH
55403: LD_VAR 0 8
55407: PPUSH
55408: CALL_OW 1
55412: ST_TO_ADDR
// end ;
55413: LD_VAR 0 5
55417: RET
// export function DangerAtRange ( unit , range ) ; begin
55418: LD_INT 0
55420: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55421: LD_ADDR_VAR 0 3
55425: PUSH
55426: LD_VAR 0 1
55430: PPUSH
55431: CALL_OW 255
55435: PPUSH
55436: LD_VAR 0 1
55440: PPUSH
55441: CALL_OW 250
55445: PPUSH
55446: LD_VAR 0 1
55450: PPUSH
55451: CALL_OW 251
55455: PPUSH
55456: LD_VAR 0 2
55460: PPUSH
55461: CALL 53721 0 4
55465: ST_TO_ADDR
// end ;
55466: LD_VAR 0 3
55470: RET
// export function DangerInArea ( side , area ) ; begin
55471: LD_INT 0
55473: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55474: LD_ADDR_VAR 0 3
55478: PUSH
55479: LD_VAR 0 2
55483: PPUSH
55484: LD_INT 81
55486: PUSH
55487: LD_VAR 0 1
55491: PUSH
55492: EMPTY
55493: LIST
55494: LIST
55495: PPUSH
55496: CALL_OW 70
55500: ST_TO_ADDR
// end ;
55501: LD_VAR 0 3
55505: RET
// export function IsExtension ( b ) ; begin
55506: LD_INT 0
55508: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55509: LD_ADDR_VAR 0 2
55513: PUSH
55514: LD_VAR 0 1
55518: PUSH
55519: LD_INT 23
55521: PUSH
55522: LD_INT 20
55524: PUSH
55525: LD_INT 22
55527: PUSH
55528: LD_INT 17
55530: PUSH
55531: LD_INT 24
55533: PUSH
55534: LD_INT 21
55536: PUSH
55537: LD_INT 19
55539: PUSH
55540: LD_INT 16
55542: PUSH
55543: LD_INT 25
55545: PUSH
55546: LD_INT 18
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: LIST
55553: LIST
55554: LIST
55555: LIST
55556: LIST
55557: LIST
55558: LIST
55559: LIST
55560: IN
55561: ST_TO_ADDR
// end ;
55562: LD_VAR 0 2
55566: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
55567: LD_INT 0
55569: PPUSH
55570: PPUSH
55571: PPUSH
// result := [ ] ;
55572: LD_ADDR_VAR 0 3
55576: PUSH
55577: EMPTY
55578: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55579: LD_ADDR_VAR 0 4
55583: PUSH
55584: LD_VAR 0 2
55588: PPUSH
55589: LD_INT 21
55591: PUSH
55592: LD_INT 3
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PPUSH
55599: CALL_OW 70
55603: ST_TO_ADDR
// if not tmp then
55604: LD_VAR 0 4
55608: NOT
55609: IFFALSE 55613
// exit ;
55611: GO 55671
// for i in tmp do
55613: LD_ADDR_VAR 0 5
55617: PUSH
55618: LD_VAR 0 4
55622: PUSH
55623: FOR_IN
55624: IFFALSE 55659
// if GetBase ( i ) <> base then
55626: LD_VAR 0 5
55630: PPUSH
55631: CALL_OW 274
55635: PUSH
55636: LD_VAR 0 1
55640: NONEQUAL
55641: IFFALSE 55657
// ComLinkToBase ( base , i ) ;
55643: LD_VAR 0 1
55647: PPUSH
55648: LD_VAR 0 5
55652: PPUSH
55653: CALL_OW 169
55657: GO 55623
55659: POP
55660: POP
// result := tmp ;
55661: LD_ADDR_VAR 0 3
55665: PUSH
55666: LD_VAR 0 4
55670: ST_TO_ADDR
// end ;
55671: LD_VAR 0 3
55675: RET
// export function ComComplete ( unit , b ) ; var i ; begin
55676: LD_INT 0
55678: PPUSH
55679: PPUSH
// if BuildingStatus ( b ) = bs_build then
55680: LD_VAR 0 2
55684: PPUSH
55685: CALL_OW 461
55689: PUSH
55690: LD_INT 1
55692: EQUAL
55693: IFFALSE 55753
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55695: LD_VAR 0 1
55699: PPUSH
55700: LD_STRING h
55702: PUSH
55703: LD_VAR 0 2
55707: PPUSH
55708: CALL_OW 250
55712: PUSH
55713: LD_VAR 0 2
55717: PPUSH
55718: CALL_OW 251
55722: PUSH
55723: LD_VAR 0 2
55727: PUSH
55728: LD_INT 0
55730: PUSH
55731: LD_INT 0
55733: PUSH
55734: LD_INT 0
55736: PUSH
55737: EMPTY
55738: LIST
55739: LIST
55740: LIST
55741: LIST
55742: LIST
55743: LIST
55744: LIST
55745: PUSH
55746: EMPTY
55747: LIST
55748: PPUSH
55749: CALL_OW 446
// end ;
55753: LD_VAR 0 3
55757: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
55758: LD_INT 0
55760: PPUSH
55761: PPUSH
55762: PPUSH
55763: PPUSH
55764: PPUSH
55765: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
55766: LD_VAR 0 1
55770: NOT
55771: PUSH
55772: LD_VAR 0 1
55776: PPUSH
55777: CALL_OW 263
55781: PUSH
55782: LD_INT 2
55784: EQUAL
55785: NOT
55786: OR
55787: IFFALSE 55791
// exit ;
55789: GO 56107
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
55791: LD_ADDR_VAR 0 6
55795: PUSH
55796: LD_INT 22
55798: PUSH
55799: LD_VAR 0 1
55803: PPUSH
55804: CALL_OW 255
55808: PUSH
55809: EMPTY
55810: LIST
55811: LIST
55812: PUSH
55813: LD_INT 2
55815: PUSH
55816: LD_INT 30
55818: PUSH
55819: LD_INT 36
55821: PUSH
55822: EMPTY
55823: LIST
55824: LIST
55825: PUSH
55826: LD_INT 34
55828: PUSH
55829: LD_INT 31
55831: PUSH
55832: EMPTY
55833: LIST
55834: LIST
55835: PUSH
55836: EMPTY
55837: LIST
55838: LIST
55839: LIST
55840: PUSH
55841: EMPTY
55842: LIST
55843: LIST
55844: PPUSH
55845: CALL_OW 69
55849: ST_TO_ADDR
// if not tmp then
55850: LD_VAR 0 6
55854: NOT
55855: IFFALSE 55859
// exit ;
55857: GO 56107
// result := [ ] ;
55859: LD_ADDR_VAR 0 2
55863: PUSH
55864: EMPTY
55865: ST_TO_ADDR
// for i in tmp do
55866: LD_ADDR_VAR 0 3
55870: PUSH
55871: LD_VAR 0 6
55875: PUSH
55876: FOR_IN
55877: IFFALSE 55948
// begin t := UnitsInside ( i ) ;
55879: LD_ADDR_VAR 0 4
55883: PUSH
55884: LD_VAR 0 3
55888: PPUSH
55889: CALL_OW 313
55893: ST_TO_ADDR
// if t then
55894: LD_VAR 0 4
55898: IFFALSE 55946
// for j in t do
55900: LD_ADDR_VAR 0 7
55904: PUSH
55905: LD_VAR 0 4
55909: PUSH
55910: FOR_IN
55911: IFFALSE 55944
// result := Insert ( result , result + 1 , j ) ;
55913: LD_ADDR_VAR 0 2
55917: PUSH
55918: LD_VAR 0 2
55922: PPUSH
55923: LD_VAR 0 2
55927: PUSH
55928: LD_INT 1
55930: PLUS
55931: PPUSH
55932: LD_VAR 0 7
55936: PPUSH
55937: CALL_OW 2
55941: ST_TO_ADDR
55942: GO 55910
55944: POP
55945: POP
// end ;
55946: GO 55876
55948: POP
55949: POP
// if not result then
55950: LD_VAR 0 2
55954: NOT
55955: IFFALSE 55959
// exit ;
55957: GO 56107
// mech := result [ 1 ] ;
55959: LD_ADDR_VAR 0 5
55963: PUSH
55964: LD_VAR 0 2
55968: PUSH
55969: LD_INT 1
55971: ARRAY
55972: ST_TO_ADDR
// if result > 1 then
55973: LD_VAR 0 2
55977: PUSH
55978: LD_INT 1
55980: GREATER
55981: IFFALSE 56093
// for i = 2 to result do
55983: LD_ADDR_VAR 0 3
55987: PUSH
55988: DOUBLE
55989: LD_INT 2
55991: DEC
55992: ST_TO_ADDR
55993: LD_VAR 0 2
55997: PUSH
55998: FOR_TO
55999: IFFALSE 56091
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56001: LD_ADDR_VAR 0 4
56005: PUSH
56006: LD_VAR 0 2
56010: PUSH
56011: LD_VAR 0 3
56015: ARRAY
56016: PPUSH
56017: LD_INT 3
56019: PPUSH
56020: CALL_OW 259
56024: PUSH
56025: LD_VAR 0 2
56029: PUSH
56030: LD_VAR 0 3
56034: ARRAY
56035: PPUSH
56036: CALL_OW 432
56040: MINUS
56041: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56042: LD_VAR 0 4
56046: PUSH
56047: LD_VAR 0 5
56051: PPUSH
56052: LD_INT 3
56054: PPUSH
56055: CALL_OW 259
56059: PUSH
56060: LD_VAR 0 5
56064: PPUSH
56065: CALL_OW 432
56069: MINUS
56070: GREATEREQUAL
56071: IFFALSE 56089
// mech := result [ i ] ;
56073: LD_ADDR_VAR 0 5
56077: PUSH
56078: LD_VAR 0 2
56082: PUSH
56083: LD_VAR 0 3
56087: ARRAY
56088: ST_TO_ADDR
// end ;
56089: GO 55998
56091: POP
56092: POP
// ComLinkTo ( vehicle , mech ) ;
56093: LD_VAR 0 1
56097: PPUSH
56098: LD_VAR 0 5
56102: PPUSH
56103: CALL_OW 135
// end ;
56107: LD_VAR 0 2
56111: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56112: LD_INT 0
56114: PPUSH
56115: PPUSH
56116: PPUSH
56117: PPUSH
56118: PPUSH
56119: PPUSH
56120: PPUSH
56121: PPUSH
56122: PPUSH
56123: PPUSH
56124: PPUSH
56125: PPUSH
56126: PPUSH
// result := [ ] ;
56127: LD_ADDR_VAR 0 7
56131: PUSH
56132: EMPTY
56133: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56134: LD_VAR 0 1
56138: PPUSH
56139: CALL_OW 266
56143: PUSH
56144: LD_INT 0
56146: PUSH
56147: LD_INT 1
56149: PUSH
56150: EMPTY
56151: LIST
56152: LIST
56153: IN
56154: NOT
56155: IFFALSE 56159
// exit ;
56157: GO 57790
// if name then
56159: LD_VAR 0 3
56163: IFFALSE 56179
// SetBName ( base_dep , name ) ;
56165: LD_VAR 0 1
56169: PPUSH
56170: LD_VAR 0 3
56174: PPUSH
56175: CALL_OW 500
// base := GetBase ( base_dep ) ;
56179: LD_ADDR_VAR 0 15
56183: PUSH
56184: LD_VAR 0 1
56188: PPUSH
56189: CALL_OW 274
56193: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56194: LD_ADDR_VAR 0 16
56198: PUSH
56199: LD_VAR 0 1
56203: PPUSH
56204: CALL_OW 255
56208: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56209: LD_ADDR_VAR 0 17
56213: PUSH
56214: LD_VAR 0 1
56218: PPUSH
56219: CALL_OW 248
56223: ST_TO_ADDR
// if sources then
56224: LD_VAR 0 5
56228: IFFALSE 56275
// for i = 1 to 3 do
56230: LD_ADDR_VAR 0 8
56234: PUSH
56235: DOUBLE
56236: LD_INT 1
56238: DEC
56239: ST_TO_ADDR
56240: LD_INT 3
56242: PUSH
56243: FOR_TO
56244: IFFALSE 56273
// AddResourceType ( base , i , sources [ i ] ) ;
56246: LD_VAR 0 15
56250: PPUSH
56251: LD_VAR 0 8
56255: PPUSH
56256: LD_VAR 0 5
56260: PUSH
56261: LD_VAR 0 8
56265: ARRAY
56266: PPUSH
56267: CALL_OW 276
56271: GO 56243
56273: POP
56274: POP
// buildings := GetBaseBuildings ( base , area ) ;
56275: LD_ADDR_VAR 0 18
56279: PUSH
56280: LD_VAR 0 15
56284: PPUSH
56285: LD_VAR 0 2
56289: PPUSH
56290: CALL 55567 0 2
56294: ST_TO_ADDR
// InitHc ;
56295: CALL_OW 19
// InitUc ;
56299: CALL_OW 18
// uc_side := side ;
56303: LD_ADDR_OWVAR 20
56307: PUSH
56308: LD_VAR 0 16
56312: ST_TO_ADDR
// uc_nation := nation ;
56313: LD_ADDR_OWVAR 21
56317: PUSH
56318: LD_VAR 0 17
56322: ST_TO_ADDR
// if buildings then
56323: LD_VAR 0 18
56327: IFFALSE 57649
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
56329: LD_ADDR_VAR 0 19
56333: PUSH
56334: LD_VAR 0 18
56338: PPUSH
56339: LD_INT 2
56341: PUSH
56342: LD_INT 30
56344: PUSH
56345: LD_INT 29
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: PUSH
56352: LD_INT 30
56354: PUSH
56355: LD_INT 30
56357: PUSH
56358: EMPTY
56359: LIST
56360: LIST
56361: PUSH
56362: EMPTY
56363: LIST
56364: LIST
56365: LIST
56366: PPUSH
56367: CALL_OW 72
56371: ST_TO_ADDR
// if tmp then
56372: LD_VAR 0 19
56376: IFFALSE 56424
// for i in tmp do
56378: LD_ADDR_VAR 0 8
56382: PUSH
56383: LD_VAR 0 19
56387: PUSH
56388: FOR_IN
56389: IFFALSE 56422
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
56391: LD_VAR 0 8
56395: PPUSH
56396: CALL_OW 250
56400: PPUSH
56401: LD_VAR 0 8
56405: PPUSH
56406: CALL_OW 251
56410: PPUSH
56411: LD_VAR 0 16
56415: PPUSH
56416: CALL_OW 441
56420: GO 56388
56422: POP
56423: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
56424: LD_VAR 0 18
56428: PPUSH
56429: LD_INT 2
56431: PUSH
56432: LD_INT 30
56434: PUSH
56435: LD_INT 32
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PUSH
56442: LD_INT 30
56444: PUSH
56445: LD_INT 33
56447: PUSH
56448: EMPTY
56449: LIST
56450: LIST
56451: PUSH
56452: EMPTY
56453: LIST
56454: LIST
56455: LIST
56456: PPUSH
56457: CALL_OW 72
56461: IFFALSE 56549
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56463: LD_ADDR_VAR 0 8
56467: PUSH
56468: LD_VAR 0 18
56472: PPUSH
56473: LD_INT 2
56475: PUSH
56476: LD_INT 30
56478: PUSH
56479: LD_INT 32
56481: PUSH
56482: EMPTY
56483: LIST
56484: LIST
56485: PUSH
56486: LD_INT 30
56488: PUSH
56489: LD_INT 33
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: PUSH
56496: EMPTY
56497: LIST
56498: LIST
56499: LIST
56500: PPUSH
56501: CALL_OW 72
56505: PUSH
56506: FOR_IN
56507: IFFALSE 56547
// begin if not GetBWeapon ( i ) then
56509: LD_VAR 0 8
56513: PPUSH
56514: CALL_OW 269
56518: NOT
56519: IFFALSE 56545
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56521: LD_VAR 0 8
56525: PPUSH
56526: LD_VAR 0 8
56530: PPUSH
56531: LD_VAR 0 2
56535: PPUSH
56536: CALL 57795 0 2
56540: PPUSH
56541: CALL_OW 431
// end ;
56545: GO 56506
56547: POP
56548: POP
// end ; for i = 1 to personel do
56549: LD_ADDR_VAR 0 8
56553: PUSH
56554: DOUBLE
56555: LD_INT 1
56557: DEC
56558: ST_TO_ADDR
56559: LD_VAR 0 6
56563: PUSH
56564: FOR_TO
56565: IFFALSE 57629
// begin if i > 4 then
56567: LD_VAR 0 8
56571: PUSH
56572: LD_INT 4
56574: GREATER
56575: IFFALSE 56579
// break ;
56577: GO 57629
// case i of 1 :
56579: LD_VAR 0 8
56583: PUSH
56584: LD_INT 1
56586: DOUBLE
56587: EQUAL
56588: IFTRUE 56592
56590: GO 56672
56592: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56593: LD_ADDR_VAR 0 12
56597: PUSH
56598: LD_VAR 0 18
56602: PPUSH
56603: LD_INT 22
56605: PUSH
56606: LD_VAR 0 16
56610: PUSH
56611: EMPTY
56612: LIST
56613: LIST
56614: PUSH
56615: LD_INT 58
56617: PUSH
56618: EMPTY
56619: LIST
56620: PUSH
56621: LD_INT 2
56623: PUSH
56624: LD_INT 30
56626: PUSH
56627: LD_INT 32
56629: PUSH
56630: EMPTY
56631: LIST
56632: LIST
56633: PUSH
56634: LD_INT 30
56636: PUSH
56637: LD_INT 4
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: PUSH
56644: LD_INT 30
56646: PUSH
56647: LD_INT 5
56649: PUSH
56650: EMPTY
56651: LIST
56652: LIST
56653: PUSH
56654: EMPTY
56655: LIST
56656: LIST
56657: LIST
56658: LIST
56659: PUSH
56660: EMPTY
56661: LIST
56662: LIST
56663: LIST
56664: PPUSH
56665: CALL_OW 72
56669: ST_TO_ADDR
56670: GO 56894
56672: LD_INT 2
56674: DOUBLE
56675: EQUAL
56676: IFTRUE 56680
56678: GO 56742
56680: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56681: LD_ADDR_VAR 0 12
56685: PUSH
56686: LD_VAR 0 18
56690: PPUSH
56691: LD_INT 22
56693: PUSH
56694: LD_VAR 0 16
56698: PUSH
56699: EMPTY
56700: LIST
56701: LIST
56702: PUSH
56703: LD_INT 2
56705: PUSH
56706: LD_INT 30
56708: PUSH
56709: LD_INT 0
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: PUSH
56716: LD_INT 30
56718: PUSH
56719: LD_INT 1
56721: PUSH
56722: EMPTY
56723: LIST
56724: LIST
56725: PUSH
56726: EMPTY
56727: LIST
56728: LIST
56729: LIST
56730: PUSH
56731: EMPTY
56732: LIST
56733: LIST
56734: PPUSH
56735: CALL_OW 72
56739: ST_TO_ADDR
56740: GO 56894
56742: LD_INT 3
56744: DOUBLE
56745: EQUAL
56746: IFTRUE 56750
56748: GO 56812
56750: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
56751: LD_ADDR_VAR 0 12
56755: PUSH
56756: LD_VAR 0 18
56760: PPUSH
56761: LD_INT 22
56763: PUSH
56764: LD_VAR 0 16
56768: PUSH
56769: EMPTY
56770: LIST
56771: LIST
56772: PUSH
56773: LD_INT 2
56775: PUSH
56776: LD_INT 30
56778: PUSH
56779: LD_INT 2
56781: PUSH
56782: EMPTY
56783: LIST
56784: LIST
56785: PUSH
56786: LD_INT 30
56788: PUSH
56789: LD_INT 3
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: LIST
56800: PUSH
56801: EMPTY
56802: LIST
56803: LIST
56804: PPUSH
56805: CALL_OW 72
56809: ST_TO_ADDR
56810: GO 56894
56812: LD_INT 4
56814: DOUBLE
56815: EQUAL
56816: IFTRUE 56820
56818: GO 56893
56820: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
56821: LD_ADDR_VAR 0 12
56825: PUSH
56826: LD_VAR 0 18
56830: PPUSH
56831: LD_INT 22
56833: PUSH
56834: LD_VAR 0 16
56838: PUSH
56839: EMPTY
56840: LIST
56841: LIST
56842: PUSH
56843: LD_INT 2
56845: PUSH
56846: LD_INT 30
56848: PUSH
56849: LD_INT 6
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: PUSH
56856: LD_INT 30
56858: PUSH
56859: LD_INT 7
56861: PUSH
56862: EMPTY
56863: LIST
56864: LIST
56865: PUSH
56866: LD_INT 30
56868: PUSH
56869: LD_INT 8
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: PUSH
56876: EMPTY
56877: LIST
56878: LIST
56879: LIST
56880: LIST
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PPUSH
56886: CALL_OW 72
56890: ST_TO_ADDR
56891: GO 56894
56893: POP
// if i = 1 then
56894: LD_VAR 0 8
56898: PUSH
56899: LD_INT 1
56901: EQUAL
56902: IFFALSE 57013
// begin tmp := [ ] ;
56904: LD_ADDR_VAR 0 19
56908: PUSH
56909: EMPTY
56910: ST_TO_ADDR
// for j in f do
56911: LD_ADDR_VAR 0 9
56915: PUSH
56916: LD_VAR 0 12
56920: PUSH
56921: FOR_IN
56922: IFFALSE 56995
// if GetBType ( j ) = b_bunker then
56924: LD_VAR 0 9
56928: PPUSH
56929: CALL_OW 266
56933: PUSH
56934: LD_INT 32
56936: EQUAL
56937: IFFALSE 56964
// tmp := Insert ( tmp , 1 , j ) else
56939: LD_ADDR_VAR 0 19
56943: PUSH
56944: LD_VAR 0 19
56948: PPUSH
56949: LD_INT 1
56951: PPUSH
56952: LD_VAR 0 9
56956: PPUSH
56957: CALL_OW 2
56961: ST_TO_ADDR
56962: GO 56993
// tmp := Insert ( tmp , tmp + 1 , j ) ;
56964: LD_ADDR_VAR 0 19
56968: PUSH
56969: LD_VAR 0 19
56973: PPUSH
56974: LD_VAR 0 19
56978: PUSH
56979: LD_INT 1
56981: PLUS
56982: PPUSH
56983: LD_VAR 0 9
56987: PPUSH
56988: CALL_OW 2
56992: ST_TO_ADDR
56993: GO 56921
56995: POP
56996: POP
// if tmp then
56997: LD_VAR 0 19
57001: IFFALSE 57013
// f := tmp ;
57003: LD_ADDR_VAR 0 12
57007: PUSH
57008: LD_VAR 0 19
57012: ST_TO_ADDR
// end ; x := personel [ i ] ;
57013: LD_ADDR_VAR 0 13
57017: PUSH
57018: LD_VAR 0 6
57022: PUSH
57023: LD_VAR 0 8
57027: ARRAY
57028: ST_TO_ADDR
// if x = - 1 then
57029: LD_VAR 0 13
57033: PUSH
57034: LD_INT 1
57036: NEG
57037: EQUAL
57038: IFFALSE 57247
// begin for j in f do
57040: LD_ADDR_VAR 0 9
57044: PUSH
57045: LD_VAR 0 12
57049: PUSH
57050: FOR_IN
57051: IFFALSE 57243
// repeat InitHc ;
57053: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57057: LD_VAR 0 9
57061: PPUSH
57062: CALL_OW 266
57066: PUSH
57067: LD_INT 5
57069: EQUAL
57070: IFFALSE 57140
// begin if UnitsInside ( j ) < 3 then
57072: LD_VAR 0 9
57076: PPUSH
57077: CALL_OW 313
57081: PUSH
57082: LD_INT 3
57084: LESS
57085: IFFALSE 57121
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57087: LD_INT 0
57089: PPUSH
57090: LD_INT 5
57092: PUSH
57093: LD_INT 8
57095: PUSH
57096: LD_INT 9
57098: PUSH
57099: EMPTY
57100: LIST
57101: LIST
57102: LIST
57103: PUSH
57104: LD_VAR 0 17
57108: ARRAY
57109: PPUSH
57110: LD_VAR 0 4
57114: PPUSH
57115: CALL_OW 380
57119: GO 57138
// PrepareHuman ( false , i , skill ) ;
57121: LD_INT 0
57123: PPUSH
57124: LD_VAR 0 8
57128: PPUSH
57129: LD_VAR 0 4
57133: PPUSH
57134: CALL_OW 380
// end else
57138: GO 57157
// PrepareHuman ( false , i , skill ) ;
57140: LD_INT 0
57142: PPUSH
57143: LD_VAR 0 8
57147: PPUSH
57148: LD_VAR 0 4
57152: PPUSH
57153: CALL_OW 380
// un := CreateHuman ;
57157: LD_ADDR_VAR 0 14
57161: PUSH
57162: CALL_OW 44
57166: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57167: LD_ADDR_VAR 0 7
57171: PUSH
57172: LD_VAR 0 7
57176: PPUSH
57177: LD_INT 1
57179: PPUSH
57180: LD_VAR 0 14
57184: PPUSH
57185: CALL_OW 2
57189: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57190: LD_VAR 0 14
57194: PPUSH
57195: LD_VAR 0 9
57199: PPUSH
57200: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57204: LD_VAR 0 9
57208: PPUSH
57209: CALL_OW 313
57213: PUSH
57214: LD_INT 6
57216: EQUAL
57217: PUSH
57218: LD_VAR 0 9
57222: PPUSH
57223: CALL_OW 266
57227: PUSH
57228: LD_INT 32
57230: PUSH
57231: LD_INT 31
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: IN
57238: OR
57239: IFFALSE 57053
57241: GO 57050
57243: POP
57244: POP
// end else
57245: GO 57627
// for j = 1 to x do
57247: LD_ADDR_VAR 0 9
57251: PUSH
57252: DOUBLE
57253: LD_INT 1
57255: DEC
57256: ST_TO_ADDR
57257: LD_VAR 0 13
57261: PUSH
57262: FOR_TO
57263: IFFALSE 57625
// begin InitHc ;
57265: CALL_OW 19
// if not f then
57269: LD_VAR 0 12
57273: NOT
57274: IFFALSE 57363
// begin PrepareHuman ( false , i , skill ) ;
57276: LD_INT 0
57278: PPUSH
57279: LD_VAR 0 8
57283: PPUSH
57284: LD_VAR 0 4
57288: PPUSH
57289: CALL_OW 380
// un := CreateHuman ;
57293: LD_ADDR_VAR 0 14
57297: PUSH
57298: CALL_OW 44
57302: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57303: LD_ADDR_VAR 0 7
57307: PUSH
57308: LD_VAR 0 7
57312: PPUSH
57313: LD_INT 1
57315: PPUSH
57316: LD_VAR 0 14
57320: PPUSH
57321: CALL_OW 2
57325: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57326: LD_VAR 0 14
57330: PPUSH
57331: LD_VAR 0 1
57335: PPUSH
57336: CALL_OW 250
57340: PPUSH
57341: LD_VAR 0 1
57345: PPUSH
57346: CALL_OW 251
57350: PPUSH
57351: LD_INT 10
57353: PPUSH
57354: LD_INT 0
57356: PPUSH
57357: CALL_OW 50
// continue ;
57361: GO 57262
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
57363: LD_VAR 0 12
57367: PUSH
57368: LD_INT 1
57370: ARRAY
57371: PPUSH
57372: CALL_OW 313
57376: PUSH
57377: LD_VAR 0 12
57381: PUSH
57382: LD_INT 1
57384: ARRAY
57385: PPUSH
57386: CALL_OW 266
57390: PUSH
57391: LD_INT 32
57393: PUSH
57394: LD_INT 31
57396: PUSH
57397: EMPTY
57398: LIST
57399: LIST
57400: IN
57401: AND
57402: PUSH
57403: LD_VAR 0 12
57407: PUSH
57408: LD_INT 1
57410: ARRAY
57411: PPUSH
57412: CALL_OW 313
57416: PUSH
57417: LD_INT 6
57419: EQUAL
57420: OR
57421: IFFALSE 57441
// f := Delete ( f , 1 ) ;
57423: LD_ADDR_VAR 0 12
57427: PUSH
57428: LD_VAR 0 12
57432: PPUSH
57433: LD_INT 1
57435: PPUSH
57436: CALL_OW 3
57440: ST_TO_ADDR
// if not f then
57441: LD_VAR 0 12
57445: NOT
57446: IFFALSE 57464
// begin x := x + 2 ;
57448: LD_ADDR_VAR 0 13
57452: PUSH
57453: LD_VAR 0 13
57457: PUSH
57458: LD_INT 2
57460: PLUS
57461: ST_TO_ADDR
// continue ;
57462: GO 57262
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57464: LD_VAR 0 12
57468: PUSH
57469: LD_INT 1
57471: ARRAY
57472: PPUSH
57473: CALL_OW 266
57477: PUSH
57478: LD_INT 5
57480: EQUAL
57481: IFFALSE 57555
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57483: LD_VAR 0 12
57487: PUSH
57488: LD_INT 1
57490: ARRAY
57491: PPUSH
57492: CALL_OW 313
57496: PUSH
57497: LD_INT 3
57499: LESS
57500: IFFALSE 57536
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57502: LD_INT 0
57504: PPUSH
57505: LD_INT 5
57507: PUSH
57508: LD_INT 8
57510: PUSH
57511: LD_INT 9
57513: PUSH
57514: EMPTY
57515: LIST
57516: LIST
57517: LIST
57518: PUSH
57519: LD_VAR 0 17
57523: ARRAY
57524: PPUSH
57525: LD_VAR 0 4
57529: PPUSH
57530: CALL_OW 380
57534: GO 57553
// PrepareHuman ( false , i , skill ) ;
57536: LD_INT 0
57538: PPUSH
57539: LD_VAR 0 8
57543: PPUSH
57544: LD_VAR 0 4
57548: PPUSH
57549: CALL_OW 380
// end else
57553: GO 57572
// PrepareHuman ( false , i , skill ) ;
57555: LD_INT 0
57557: PPUSH
57558: LD_VAR 0 8
57562: PPUSH
57563: LD_VAR 0 4
57567: PPUSH
57568: CALL_OW 380
// un := CreateHuman ;
57572: LD_ADDR_VAR 0 14
57576: PUSH
57577: CALL_OW 44
57581: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57582: LD_ADDR_VAR 0 7
57586: PUSH
57587: LD_VAR 0 7
57591: PPUSH
57592: LD_INT 1
57594: PPUSH
57595: LD_VAR 0 14
57599: PPUSH
57600: CALL_OW 2
57604: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57605: LD_VAR 0 14
57609: PPUSH
57610: LD_VAR 0 12
57614: PUSH
57615: LD_INT 1
57617: ARRAY
57618: PPUSH
57619: CALL_OW 52
// end ;
57623: GO 57262
57625: POP
57626: POP
// end ;
57627: GO 56564
57629: POP
57630: POP
// result := result ^ buildings ;
57631: LD_ADDR_VAR 0 7
57635: PUSH
57636: LD_VAR 0 7
57640: PUSH
57641: LD_VAR 0 18
57645: ADD
57646: ST_TO_ADDR
// end else
57647: GO 57790
// begin for i = 1 to personel do
57649: LD_ADDR_VAR 0 8
57653: PUSH
57654: DOUBLE
57655: LD_INT 1
57657: DEC
57658: ST_TO_ADDR
57659: LD_VAR 0 6
57663: PUSH
57664: FOR_TO
57665: IFFALSE 57788
// begin if i > 4 then
57667: LD_VAR 0 8
57671: PUSH
57672: LD_INT 4
57674: GREATER
57675: IFFALSE 57679
// break ;
57677: GO 57788
// x := personel [ i ] ;
57679: LD_ADDR_VAR 0 13
57683: PUSH
57684: LD_VAR 0 6
57688: PUSH
57689: LD_VAR 0 8
57693: ARRAY
57694: ST_TO_ADDR
// if x = - 1 then
57695: LD_VAR 0 13
57699: PUSH
57700: LD_INT 1
57702: NEG
57703: EQUAL
57704: IFFALSE 57708
// continue ;
57706: GO 57664
// PrepareHuman ( false , i , skill ) ;
57708: LD_INT 0
57710: PPUSH
57711: LD_VAR 0 8
57715: PPUSH
57716: LD_VAR 0 4
57720: PPUSH
57721: CALL_OW 380
// un := CreateHuman ;
57725: LD_ADDR_VAR 0 14
57729: PUSH
57730: CALL_OW 44
57734: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57735: LD_VAR 0 14
57739: PPUSH
57740: LD_VAR 0 1
57744: PPUSH
57745: CALL_OW 250
57749: PPUSH
57750: LD_VAR 0 1
57754: PPUSH
57755: CALL_OW 251
57759: PPUSH
57760: LD_INT 10
57762: PPUSH
57763: LD_INT 0
57765: PPUSH
57766: CALL_OW 50
// result := result ^ un ;
57770: LD_ADDR_VAR 0 7
57774: PUSH
57775: LD_VAR 0 7
57779: PUSH
57780: LD_VAR 0 14
57784: ADD
57785: ST_TO_ADDR
// end ;
57786: GO 57664
57788: POP
57789: POP
// end ; end ;
57790: LD_VAR 0 7
57794: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
57795: LD_INT 0
57797: PPUSH
57798: PPUSH
57799: PPUSH
57800: PPUSH
57801: PPUSH
57802: PPUSH
57803: PPUSH
57804: PPUSH
57805: PPUSH
57806: PPUSH
57807: PPUSH
57808: PPUSH
57809: PPUSH
57810: PPUSH
57811: PPUSH
57812: PPUSH
// result := false ;
57813: LD_ADDR_VAR 0 3
57817: PUSH
57818: LD_INT 0
57820: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
57821: LD_VAR 0 1
57825: NOT
57826: PUSH
57827: LD_VAR 0 1
57831: PPUSH
57832: CALL_OW 266
57836: PUSH
57837: LD_INT 32
57839: PUSH
57840: LD_INT 33
57842: PUSH
57843: EMPTY
57844: LIST
57845: LIST
57846: IN
57847: NOT
57848: OR
57849: IFFALSE 57853
// exit ;
57851: GO 58989
// nat := GetNation ( tower ) ;
57853: LD_ADDR_VAR 0 12
57857: PUSH
57858: LD_VAR 0 1
57862: PPUSH
57863: CALL_OW 248
57867: ST_TO_ADDR
// side := GetSide ( tower ) ;
57868: LD_ADDR_VAR 0 16
57872: PUSH
57873: LD_VAR 0 1
57877: PPUSH
57878: CALL_OW 255
57882: ST_TO_ADDR
// x := GetX ( tower ) ;
57883: LD_ADDR_VAR 0 10
57887: PUSH
57888: LD_VAR 0 1
57892: PPUSH
57893: CALL_OW 250
57897: ST_TO_ADDR
// y := GetY ( tower ) ;
57898: LD_ADDR_VAR 0 11
57902: PUSH
57903: LD_VAR 0 1
57907: PPUSH
57908: CALL_OW 251
57912: ST_TO_ADDR
// if not x or not y then
57913: LD_VAR 0 10
57917: NOT
57918: PUSH
57919: LD_VAR 0 11
57923: NOT
57924: OR
57925: IFFALSE 57929
// exit ;
57927: GO 58989
// weapon := 0 ;
57929: LD_ADDR_VAR 0 18
57933: PUSH
57934: LD_INT 0
57936: ST_TO_ADDR
// fac_list := [ ] ;
57937: LD_ADDR_VAR 0 17
57941: PUSH
57942: EMPTY
57943: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
57944: LD_ADDR_VAR 0 6
57948: PUSH
57949: LD_VAR 0 1
57953: PPUSH
57954: CALL_OW 274
57958: PPUSH
57959: LD_VAR 0 2
57963: PPUSH
57964: CALL 55567 0 2
57968: PPUSH
57969: LD_INT 30
57971: PUSH
57972: LD_INT 3
57974: PUSH
57975: EMPTY
57976: LIST
57977: LIST
57978: PPUSH
57979: CALL_OW 72
57983: ST_TO_ADDR
// if not factories then
57984: LD_VAR 0 6
57988: NOT
57989: IFFALSE 57993
// exit ;
57991: GO 58989
// for i in factories do
57993: LD_ADDR_VAR 0 8
57997: PUSH
57998: LD_VAR 0 6
58002: PUSH
58003: FOR_IN
58004: IFFALSE 58029
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58006: LD_ADDR_VAR 0 17
58010: PUSH
58011: LD_VAR 0 17
58015: PUSH
58016: LD_VAR 0 8
58020: PPUSH
58021: CALL_OW 478
58025: UNION
58026: ST_TO_ADDR
58027: GO 58003
58029: POP
58030: POP
// if not fac_list then
58031: LD_VAR 0 17
58035: NOT
58036: IFFALSE 58040
// exit ;
58038: GO 58989
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58040: LD_ADDR_VAR 0 5
58044: PUSH
58045: LD_INT 4
58047: PUSH
58048: LD_INT 5
58050: PUSH
58051: LD_INT 9
58053: PUSH
58054: LD_INT 10
58056: PUSH
58057: LD_INT 6
58059: PUSH
58060: LD_INT 7
58062: PUSH
58063: LD_INT 11
58065: PUSH
58066: EMPTY
58067: LIST
58068: LIST
58069: LIST
58070: LIST
58071: LIST
58072: LIST
58073: LIST
58074: PUSH
58075: LD_INT 27
58077: PUSH
58078: LD_INT 28
58080: PUSH
58081: LD_INT 26
58083: PUSH
58084: LD_INT 30
58086: PUSH
58087: EMPTY
58088: LIST
58089: LIST
58090: LIST
58091: LIST
58092: PUSH
58093: LD_INT 43
58095: PUSH
58096: LD_INT 44
58098: PUSH
58099: LD_INT 46
58101: PUSH
58102: LD_INT 45
58104: PUSH
58105: LD_INT 47
58107: PUSH
58108: LD_INT 49
58110: PUSH
58111: EMPTY
58112: LIST
58113: LIST
58114: LIST
58115: LIST
58116: LIST
58117: LIST
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: LIST
58123: PUSH
58124: LD_VAR 0 12
58128: ARRAY
58129: ST_TO_ADDR
// for i in list do
58130: LD_ADDR_VAR 0 8
58134: PUSH
58135: LD_VAR 0 5
58139: PUSH
58140: FOR_IN
58141: IFFALSE 58174
// if not i in fac_list then
58143: LD_VAR 0 8
58147: PUSH
58148: LD_VAR 0 17
58152: IN
58153: NOT
58154: IFFALSE 58172
// list := list diff i ;
58156: LD_ADDR_VAR 0 5
58160: PUSH
58161: LD_VAR 0 5
58165: PUSH
58166: LD_VAR 0 8
58170: DIFF
58171: ST_TO_ADDR
58172: GO 58140
58174: POP
58175: POP
// if not list then
58176: LD_VAR 0 5
58180: NOT
58181: IFFALSE 58185
// exit ;
58183: GO 58989
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58185: LD_VAR 0 12
58189: PUSH
58190: LD_INT 3
58192: EQUAL
58193: PUSH
58194: LD_INT 49
58196: PUSH
58197: LD_VAR 0 5
58201: IN
58202: AND
58203: PUSH
58204: LD_INT 31
58206: PPUSH
58207: LD_VAR 0 16
58211: PPUSH
58212: CALL_OW 321
58216: PUSH
58217: LD_INT 2
58219: EQUAL
58220: AND
58221: IFFALSE 58281
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58223: LD_INT 22
58225: PUSH
58226: LD_VAR 0 16
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PUSH
58235: LD_INT 35
58237: PUSH
58238: LD_INT 49
58240: PUSH
58241: EMPTY
58242: LIST
58243: LIST
58244: PUSH
58245: LD_INT 91
58247: PUSH
58248: LD_VAR 0 1
58252: PUSH
58253: LD_INT 10
58255: PUSH
58256: EMPTY
58257: LIST
58258: LIST
58259: LIST
58260: PUSH
58261: EMPTY
58262: LIST
58263: LIST
58264: LIST
58265: PPUSH
58266: CALL_OW 69
58270: NOT
58271: IFFALSE 58281
// weapon := ru_time_lapser ;
58273: LD_ADDR_VAR 0 18
58277: PUSH
58278: LD_INT 49
58280: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
58281: LD_VAR 0 12
58285: PUSH
58286: LD_INT 1
58288: PUSH
58289: LD_INT 2
58291: PUSH
58292: EMPTY
58293: LIST
58294: LIST
58295: IN
58296: PUSH
58297: LD_INT 11
58299: PUSH
58300: LD_VAR 0 5
58304: IN
58305: PUSH
58306: LD_INT 30
58308: PUSH
58309: LD_VAR 0 5
58313: IN
58314: OR
58315: AND
58316: PUSH
58317: LD_INT 6
58319: PPUSH
58320: LD_VAR 0 16
58324: PPUSH
58325: CALL_OW 321
58329: PUSH
58330: LD_INT 2
58332: EQUAL
58333: AND
58334: IFFALSE 58499
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
58336: LD_INT 22
58338: PUSH
58339: LD_VAR 0 16
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: PUSH
58348: LD_INT 2
58350: PUSH
58351: LD_INT 35
58353: PUSH
58354: LD_INT 11
58356: PUSH
58357: EMPTY
58358: LIST
58359: LIST
58360: PUSH
58361: LD_INT 35
58363: PUSH
58364: LD_INT 30
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: LIST
58375: PUSH
58376: LD_INT 91
58378: PUSH
58379: LD_VAR 0 1
58383: PUSH
58384: LD_INT 18
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: LIST
58391: PUSH
58392: EMPTY
58393: LIST
58394: LIST
58395: LIST
58396: PPUSH
58397: CALL_OW 69
58401: NOT
58402: PUSH
58403: LD_INT 22
58405: PUSH
58406: LD_VAR 0 16
58410: PUSH
58411: EMPTY
58412: LIST
58413: LIST
58414: PUSH
58415: LD_INT 2
58417: PUSH
58418: LD_INT 30
58420: PUSH
58421: LD_INT 32
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: PUSH
58428: LD_INT 30
58430: PUSH
58431: LD_INT 33
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PUSH
58438: EMPTY
58439: LIST
58440: LIST
58441: LIST
58442: PUSH
58443: LD_INT 91
58445: PUSH
58446: LD_VAR 0 1
58450: PUSH
58451: LD_INT 12
58453: PUSH
58454: EMPTY
58455: LIST
58456: LIST
58457: LIST
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: LIST
58463: PUSH
58464: EMPTY
58465: LIST
58466: PPUSH
58467: CALL_OW 69
58471: PUSH
58472: LD_INT 2
58474: GREATER
58475: AND
58476: IFFALSE 58499
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58478: LD_ADDR_VAR 0 18
58482: PUSH
58483: LD_INT 11
58485: PUSH
58486: LD_INT 30
58488: PUSH
58489: EMPTY
58490: LIST
58491: LIST
58492: PUSH
58493: LD_VAR 0 12
58497: ARRAY
58498: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58499: LD_VAR 0 18
58503: NOT
58504: PUSH
58505: LD_INT 40
58507: PPUSH
58508: LD_VAR 0 16
58512: PPUSH
58513: CALL_OW 321
58517: PUSH
58518: LD_INT 2
58520: EQUAL
58521: AND
58522: PUSH
58523: LD_INT 7
58525: PUSH
58526: LD_VAR 0 5
58530: IN
58531: PUSH
58532: LD_INT 28
58534: PUSH
58535: LD_VAR 0 5
58539: IN
58540: OR
58541: PUSH
58542: LD_INT 45
58544: PUSH
58545: LD_VAR 0 5
58549: IN
58550: OR
58551: AND
58552: IFFALSE 58806
// begin hex := GetHexInfo ( x , y ) ;
58554: LD_ADDR_VAR 0 4
58558: PUSH
58559: LD_VAR 0 10
58563: PPUSH
58564: LD_VAR 0 11
58568: PPUSH
58569: CALL_OW 546
58573: ST_TO_ADDR
// if hex [ 1 ] then
58574: LD_VAR 0 4
58578: PUSH
58579: LD_INT 1
58581: ARRAY
58582: IFFALSE 58586
// exit ;
58584: GO 58989
// height := hex [ 2 ] ;
58586: LD_ADDR_VAR 0 15
58590: PUSH
58591: LD_VAR 0 4
58595: PUSH
58596: LD_INT 2
58598: ARRAY
58599: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58600: LD_ADDR_VAR 0 14
58604: PUSH
58605: LD_INT 0
58607: PUSH
58608: LD_INT 2
58610: PUSH
58611: LD_INT 3
58613: PUSH
58614: LD_INT 5
58616: PUSH
58617: EMPTY
58618: LIST
58619: LIST
58620: LIST
58621: LIST
58622: ST_TO_ADDR
// for i in tmp do
58623: LD_ADDR_VAR 0 8
58627: PUSH
58628: LD_VAR 0 14
58632: PUSH
58633: FOR_IN
58634: IFFALSE 58804
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58636: LD_ADDR_VAR 0 9
58640: PUSH
58641: LD_VAR 0 10
58645: PPUSH
58646: LD_VAR 0 8
58650: PPUSH
58651: LD_INT 5
58653: PPUSH
58654: CALL_OW 272
58658: PUSH
58659: LD_VAR 0 11
58663: PPUSH
58664: LD_VAR 0 8
58668: PPUSH
58669: LD_INT 5
58671: PPUSH
58672: CALL_OW 273
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58681: LD_VAR 0 9
58685: PUSH
58686: LD_INT 1
58688: ARRAY
58689: PPUSH
58690: LD_VAR 0 9
58694: PUSH
58695: LD_INT 2
58697: ARRAY
58698: PPUSH
58699: CALL_OW 488
58703: IFFALSE 58802
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58705: LD_ADDR_VAR 0 4
58709: PUSH
58710: LD_VAR 0 9
58714: PUSH
58715: LD_INT 1
58717: ARRAY
58718: PPUSH
58719: LD_VAR 0 9
58723: PUSH
58724: LD_INT 2
58726: ARRAY
58727: PPUSH
58728: CALL_OW 546
58732: ST_TO_ADDR
// if hex [ 1 ] then
58733: LD_VAR 0 4
58737: PUSH
58738: LD_INT 1
58740: ARRAY
58741: IFFALSE 58745
// continue ;
58743: GO 58633
// h := hex [ 2 ] ;
58745: LD_ADDR_VAR 0 13
58749: PUSH
58750: LD_VAR 0 4
58754: PUSH
58755: LD_INT 2
58757: ARRAY
58758: ST_TO_ADDR
// if h + 7 < height then
58759: LD_VAR 0 13
58763: PUSH
58764: LD_INT 7
58766: PLUS
58767: PUSH
58768: LD_VAR 0 15
58772: LESS
58773: IFFALSE 58802
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
58775: LD_ADDR_VAR 0 18
58779: PUSH
58780: LD_INT 7
58782: PUSH
58783: LD_INT 28
58785: PUSH
58786: LD_INT 45
58788: PUSH
58789: EMPTY
58790: LIST
58791: LIST
58792: LIST
58793: PUSH
58794: LD_VAR 0 12
58798: ARRAY
58799: ST_TO_ADDR
// break ;
58800: GO 58804
// end ; end ; end ;
58802: GO 58633
58804: POP
58805: POP
// end ; if not weapon then
58806: LD_VAR 0 18
58810: NOT
58811: IFFALSE 58871
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
58813: LD_ADDR_VAR 0 5
58817: PUSH
58818: LD_VAR 0 5
58822: PUSH
58823: LD_INT 11
58825: PUSH
58826: LD_INT 30
58828: PUSH
58829: LD_INT 49
58831: PUSH
58832: EMPTY
58833: LIST
58834: LIST
58835: LIST
58836: DIFF
58837: ST_TO_ADDR
// if not list then
58838: LD_VAR 0 5
58842: NOT
58843: IFFALSE 58847
// exit ;
58845: GO 58989
// weapon := list [ rand ( 1 , list ) ] ;
58847: LD_ADDR_VAR 0 18
58851: PUSH
58852: LD_VAR 0 5
58856: PUSH
58857: LD_INT 1
58859: PPUSH
58860: LD_VAR 0 5
58864: PPUSH
58865: CALL_OW 12
58869: ARRAY
58870: ST_TO_ADDR
// end ; if weapon then
58871: LD_VAR 0 18
58875: IFFALSE 58989
// begin tmp := CostOfWeapon ( weapon ) ;
58877: LD_ADDR_VAR 0 14
58881: PUSH
58882: LD_VAR 0 18
58886: PPUSH
58887: CALL_OW 451
58891: ST_TO_ADDR
// j := GetBase ( tower ) ;
58892: LD_ADDR_VAR 0 9
58896: PUSH
58897: LD_VAR 0 1
58901: PPUSH
58902: CALL_OW 274
58906: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
58907: LD_VAR 0 9
58911: PPUSH
58912: LD_INT 1
58914: PPUSH
58915: CALL_OW 275
58919: PUSH
58920: LD_VAR 0 14
58924: PUSH
58925: LD_INT 1
58927: ARRAY
58928: GREATEREQUAL
58929: PUSH
58930: LD_VAR 0 9
58934: PPUSH
58935: LD_INT 2
58937: PPUSH
58938: CALL_OW 275
58942: PUSH
58943: LD_VAR 0 14
58947: PUSH
58948: LD_INT 2
58950: ARRAY
58951: GREATEREQUAL
58952: AND
58953: PUSH
58954: LD_VAR 0 9
58958: PPUSH
58959: LD_INT 3
58961: PPUSH
58962: CALL_OW 275
58966: PUSH
58967: LD_VAR 0 14
58971: PUSH
58972: LD_INT 3
58974: ARRAY
58975: GREATEREQUAL
58976: AND
58977: IFFALSE 58989
// result := weapon ;
58979: LD_ADDR_VAR 0 3
58983: PUSH
58984: LD_VAR 0 18
58988: ST_TO_ADDR
// end ; end ;
58989: LD_VAR 0 3
58993: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
58994: LD_INT 0
58996: PPUSH
58997: PPUSH
// result := true ;
58998: LD_ADDR_VAR 0 3
59002: PUSH
59003: LD_INT 1
59005: ST_TO_ADDR
// if array1 = array2 then
59006: LD_VAR 0 1
59010: PUSH
59011: LD_VAR 0 2
59015: EQUAL
59016: IFFALSE 59076
// begin for i = 1 to array1 do
59018: LD_ADDR_VAR 0 4
59022: PUSH
59023: DOUBLE
59024: LD_INT 1
59026: DEC
59027: ST_TO_ADDR
59028: LD_VAR 0 1
59032: PUSH
59033: FOR_TO
59034: IFFALSE 59072
// if array1 [ i ] <> array2 [ i ] then
59036: LD_VAR 0 1
59040: PUSH
59041: LD_VAR 0 4
59045: ARRAY
59046: PUSH
59047: LD_VAR 0 2
59051: PUSH
59052: LD_VAR 0 4
59056: ARRAY
59057: NONEQUAL
59058: IFFALSE 59070
// begin result := false ;
59060: LD_ADDR_VAR 0 3
59064: PUSH
59065: LD_INT 0
59067: ST_TO_ADDR
// break ;
59068: GO 59072
// end ;
59070: GO 59033
59072: POP
59073: POP
// end else
59074: GO 59084
// result := false ;
59076: LD_ADDR_VAR 0 3
59080: PUSH
59081: LD_INT 0
59083: ST_TO_ADDR
// end ;
59084: LD_VAR 0 3
59088: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59089: LD_INT 0
59091: PPUSH
59092: PPUSH
59093: PPUSH
// pom := GetBase ( fac ) ;
59094: LD_ADDR_VAR 0 5
59098: PUSH
59099: LD_VAR 0 1
59103: PPUSH
59104: CALL_OW 274
59108: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59109: LD_ADDR_VAR 0 4
59113: PUSH
59114: LD_VAR 0 2
59118: PUSH
59119: LD_INT 1
59121: ARRAY
59122: PPUSH
59123: LD_VAR 0 2
59127: PUSH
59128: LD_INT 2
59130: ARRAY
59131: PPUSH
59132: LD_VAR 0 2
59136: PUSH
59137: LD_INT 3
59139: ARRAY
59140: PPUSH
59141: LD_VAR 0 2
59145: PUSH
59146: LD_INT 4
59148: ARRAY
59149: PPUSH
59150: CALL_OW 449
59154: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59155: LD_ADDR_VAR 0 3
59159: PUSH
59160: LD_VAR 0 5
59164: PPUSH
59165: LD_INT 1
59167: PPUSH
59168: CALL_OW 275
59172: PUSH
59173: LD_VAR 0 4
59177: PUSH
59178: LD_INT 1
59180: ARRAY
59181: GREATEREQUAL
59182: PUSH
59183: LD_VAR 0 5
59187: PPUSH
59188: LD_INT 2
59190: PPUSH
59191: CALL_OW 275
59195: PUSH
59196: LD_VAR 0 4
59200: PUSH
59201: LD_INT 2
59203: ARRAY
59204: GREATEREQUAL
59205: AND
59206: PUSH
59207: LD_VAR 0 5
59211: PPUSH
59212: LD_INT 3
59214: PPUSH
59215: CALL_OW 275
59219: PUSH
59220: LD_VAR 0 4
59224: PUSH
59225: LD_INT 3
59227: ARRAY
59228: GREATEREQUAL
59229: AND
59230: ST_TO_ADDR
// end ;
59231: LD_VAR 0 3
59235: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
59236: LD_INT 0
59238: PPUSH
59239: PPUSH
59240: PPUSH
59241: PPUSH
// pom := GetBase ( building ) ;
59242: LD_ADDR_VAR 0 3
59246: PUSH
59247: LD_VAR 0 1
59251: PPUSH
59252: CALL_OW 274
59256: ST_TO_ADDR
// if not pom then
59257: LD_VAR 0 3
59261: NOT
59262: IFFALSE 59266
// exit ;
59264: GO 59436
// btype := GetBType ( building ) ;
59266: LD_ADDR_VAR 0 5
59270: PUSH
59271: LD_VAR 0 1
59275: PPUSH
59276: CALL_OW 266
59280: ST_TO_ADDR
// if btype = b_armoury then
59281: LD_VAR 0 5
59285: PUSH
59286: LD_INT 4
59288: EQUAL
59289: IFFALSE 59299
// btype := b_barracks ;
59291: LD_ADDR_VAR 0 5
59295: PUSH
59296: LD_INT 5
59298: ST_TO_ADDR
// if btype = b_depot then
59299: LD_VAR 0 5
59303: PUSH
59304: LD_INT 0
59306: EQUAL
59307: IFFALSE 59317
// btype := b_warehouse ;
59309: LD_ADDR_VAR 0 5
59313: PUSH
59314: LD_INT 1
59316: ST_TO_ADDR
// if btype = b_workshop then
59317: LD_VAR 0 5
59321: PUSH
59322: LD_INT 2
59324: EQUAL
59325: IFFALSE 59335
// btype := b_factory ;
59327: LD_ADDR_VAR 0 5
59331: PUSH
59332: LD_INT 3
59334: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59335: LD_ADDR_VAR 0 4
59339: PUSH
59340: LD_VAR 0 5
59344: PPUSH
59345: LD_VAR 0 1
59349: PPUSH
59350: CALL_OW 248
59354: PPUSH
59355: CALL_OW 450
59359: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59360: LD_ADDR_VAR 0 2
59364: PUSH
59365: LD_VAR 0 3
59369: PPUSH
59370: LD_INT 1
59372: PPUSH
59373: CALL_OW 275
59377: PUSH
59378: LD_VAR 0 4
59382: PUSH
59383: LD_INT 1
59385: ARRAY
59386: GREATEREQUAL
59387: PUSH
59388: LD_VAR 0 3
59392: PPUSH
59393: LD_INT 2
59395: PPUSH
59396: CALL_OW 275
59400: PUSH
59401: LD_VAR 0 4
59405: PUSH
59406: LD_INT 2
59408: ARRAY
59409: GREATEREQUAL
59410: AND
59411: PUSH
59412: LD_VAR 0 3
59416: PPUSH
59417: LD_INT 3
59419: PPUSH
59420: CALL_OW 275
59424: PUSH
59425: LD_VAR 0 4
59429: PUSH
59430: LD_INT 3
59432: ARRAY
59433: GREATEREQUAL
59434: AND
59435: ST_TO_ADDR
// end ;
59436: LD_VAR 0 2
59440: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
59441: LD_INT 0
59443: PPUSH
59444: PPUSH
59445: PPUSH
// pom := GetBase ( building ) ;
59446: LD_ADDR_VAR 0 4
59450: PUSH
59451: LD_VAR 0 1
59455: PPUSH
59456: CALL_OW 274
59460: ST_TO_ADDR
// if not pom then
59461: LD_VAR 0 4
59465: NOT
59466: IFFALSE 59470
// exit ;
59468: GO 59571
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59470: LD_ADDR_VAR 0 5
59474: PUSH
59475: LD_VAR 0 2
59479: PPUSH
59480: LD_VAR 0 1
59484: PPUSH
59485: CALL_OW 248
59489: PPUSH
59490: CALL_OW 450
59494: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59495: LD_ADDR_VAR 0 3
59499: PUSH
59500: LD_VAR 0 4
59504: PPUSH
59505: LD_INT 1
59507: PPUSH
59508: CALL_OW 275
59512: PUSH
59513: LD_VAR 0 5
59517: PUSH
59518: LD_INT 1
59520: ARRAY
59521: GREATEREQUAL
59522: PUSH
59523: LD_VAR 0 4
59527: PPUSH
59528: LD_INT 2
59530: PPUSH
59531: CALL_OW 275
59535: PUSH
59536: LD_VAR 0 5
59540: PUSH
59541: LD_INT 2
59543: ARRAY
59544: GREATEREQUAL
59545: AND
59546: PUSH
59547: LD_VAR 0 4
59551: PPUSH
59552: LD_INT 3
59554: PPUSH
59555: CALL_OW 275
59559: PUSH
59560: LD_VAR 0 5
59564: PUSH
59565: LD_INT 3
59567: ARRAY
59568: GREATEREQUAL
59569: AND
59570: ST_TO_ADDR
// end ;
59571: LD_VAR 0 3
59575: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
59576: LD_INT 0
59578: PPUSH
59579: PPUSH
59580: PPUSH
59581: PPUSH
59582: PPUSH
59583: PPUSH
59584: PPUSH
59585: PPUSH
59586: PPUSH
59587: PPUSH
// result := false ;
59588: LD_ADDR_VAR 0 6
59592: PUSH
59593: LD_INT 0
59595: ST_TO_ADDR
// if not base or not btype or not x or not y then
59596: LD_VAR 0 1
59600: NOT
59601: PUSH
59602: LD_VAR 0 2
59606: NOT
59607: OR
59608: PUSH
59609: LD_VAR 0 3
59613: NOT
59614: OR
59615: PUSH
59616: LD_VAR 0 4
59620: NOT
59621: OR
59622: IFFALSE 59626
// exit ;
59624: GO 60235
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
59626: LD_ADDR_VAR 0 12
59630: PUSH
59631: LD_VAR 0 2
59635: PPUSH
59636: LD_VAR 0 3
59640: PPUSH
59641: LD_VAR 0 4
59645: PPUSH
59646: LD_VAR 0 5
59650: PPUSH
59651: LD_VAR 0 1
59655: PUSH
59656: LD_INT 1
59658: ARRAY
59659: PPUSH
59660: CALL_OW 248
59664: PPUSH
59665: LD_INT 0
59667: PPUSH
59668: CALL 61072 0 6
59672: ST_TO_ADDR
// if not hexes then
59673: LD_VAR 0 12
59677: NOT
59678: IFFALSE 59682
// exit ;
59680: GO 60235
// for i = 1 to hexes do
59682: LD_ADDR_VAR 0 7
59686: PUSH
59687: DOUBLE
59688: LD_INT 1
59690: DEC
59691: ST_TO_ADDR
59692: LD_VAR 0 12
59696: PUSH
59697: FOR_TO
59698: IFFALSE 60233
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59700: LD_ADDR_VAR 0 11
59704: PUSH
59705: LD_VAR 0 12
59709: PUSH
59710: LD_VAR 0 7
59714: ARRAY
59715: PUSH
59716: LD_INT 1
59718: ARRAY
59719: PPUSH
59720: LD_VAR 0 12
59724: PUSH
59725: LD_VAR 0 7
59729: ARRAY
59730: PUSH
59731: LD_INT 2
59733: ARRAY
59734: PPUSH
59735: CALL_OW 428
59739: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
59740: LD_VAR 0 12
59744: PUSH
59745: LD_VAR 0 7
59749: ARRAY
59750: PUSH
59751: LD_INT 1
59753: ARRAY
59754: PPUSH
59755: LD_VAR 0 12
59759: PUSH
59760: LD_VAR 0 7
59764: ARRAY
59765: PUSH
59766: LD_INT 2
59768: ARRAY
59769: PPUSH
59770: CALL_OW 351
59774: PUSH
59775: LD_VAR 0 12
59779: PUSH
59780: LD_VAR 0 7
59784: ARRAY
59785: PUSH
59786: LD_INT 1
59788: ARRAY
59789: PPUSH
59790: LD_VAR 0 12
59794: PUSH
59795: LD_VAR 0 7
59799: ARRAY
59800: PUSH
59801: LD_INT 2
59803: ARRAY
59804: PPUSH
59805: CALL_OW 488
59809: NOT
59810: OR
59811: PUSH
59812: LD_VAR 0 11
59816: PPUSH
59817: CALL_OW 247
59821: PUSH
59822: LD_INT 3
59824: EQUAL
59825: OR
59826: IFFALSE 59832
// exit ;
59828: POP
59829: POP
59830: GO 60235
// if not tmp or not tmp in base then
59832: LD_VAR 0 11
59836: NOT
59837: PUSH
59838: LD_VAR 0 11
59842: PUSH
59843: LD_VAR 0 1
59847: IN
59848: NOT
59849: OR
59850: IFFALSE 59854
// continue ;
59852: GO 59697
// result := true ;
59854: LD_ADDR_VAR 0 6
59858: PUSH
59859: LD_INT 1
59861: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
59862: LD_ADDR_VAR 0 15
59866: PUSH
59867: LD_VAR 0 1
59871: PPUSH
59872: LD_INT 22
59874: PUSH
59875: LD_VAR 0 11
59879: PPUSH
59880: CALL_OW 255
59884: PUSH
59885: EMPTY
59886: LIST
59887: LIST
59888: PUSH
59889: LD_INT 2
59891: PUSH
59892: LD_INT 30
59894: PUSH
59895: LD_INT 0
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: PUSH
59902: LD_INT 30
59904: PUSH
59905: LD_INT 1
59907: PUSH
59908: EMPTY
59909: LIST
59910: LIST
59911: PUSH
59912: EMPTY
59913: LIST
59914: LIST
59915: LIST
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: PPUSH
59921: CALL_OW 72
59925: ST_TO_ADDR
// if dep then
59926: LD_VAR 0 15
59930: IFFALSE 60066
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
59932: LD_ADDR_VAR 0 14
59936: PUSH
59937: LD_VAR 0 15
59941: PUSH
59942: LD_INT 1
59944: ARRAY
59945: PPUSH
59946: CALL_OW 250
59950: PPUSH
59951: LD_VAR 0 15
59955: PUSH
59956: LD_INT 1
59958: ARRAY
59959: PPUSH
59960: CALL_OW 254
59964: PPUSH
59965: LD_INT 5
59967: PPUSH
59968: CALL_OW 272
59972: PUSH
59973: LD_VAR 0 15
59977: PUSH
59978: LD_INT 1
59980: ARRAY
59981: PPUSH
59982: CALL_OW 251
59986: PPUSH
59987: LD_VAR 0 15
59991: PUSH
59992: LD_INT 1
59994: ARRAY
59995: PPUSH
59996: CALL_OW 254
60000: PPUSH
60001: LD_INT 5
60003: PPUSH
60004: CALL_OW 273
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
60013: LD_VAR 0 14
60017: PUSH
60018: LD_INT 1
60020: ARRAY
60021: PPUSH
60022: LD_VAR 0 14
60026: PUSH
60027: LD_INT 2
60029: ARRAY
60030: PPUSH
60031: CALL_OW 488
60035: IFFALSE 60066
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60037: LD_VAR 0 11
60041: PPUSH
60042: LD_VAR 0 14
60046: PUSH
60047: LD_INT 1
60049: ARRAY
60050: PPUSH
60051: LD_VAR 0 14
60055: PUSH
60056: LD_INT 2
60058: ARRAY
60059: PPUSH
60060: CALL_OW 111
// continue ;
60064: GO 59697
// end ; end ; r := GetDir ( tmp ) ;
60066: LD_ADDR_VAR 0 13
60070: PUSH
60071: LD_VAR 0 11
60075: PPUSH
60076: CALL_OW 254
60080: ST_TO_ADDR
// if r = 5 then
60081: LD_VAR 0 13
60085: PUSH
60086: LD_INT 5
60088: EQUAL
60089: IFFALSE 60099
// r := 0 ;
60091: LD_ADDR_VAR 0 13
60095: PUSH
60096: LD_INT 0
60098: ST_TO_ADDR
// for j = r to 5 do
60099: LD_ADDR_VAR 0 8
60103: PUSH
60104: DOUBLE
60105: LD_VAR 0 13
60109: DEC
60110: ST_TO_ADDR
60111: LD_INT 5
60113: PUSH
60114: FOR_TO
60115: IFFALSE 60229
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60117: LD_ADDR_VAR 0 9
60121: PUSH
60122: LD_VAR 0 11
60126: PPUSH
60127: CALL_OW 250
60131: PPUSH
60132: LD_VAR 0 8
60136: PPUSH
60137: LD_INT 2
60139: PPUSH
60140: CALL_OW 272
60144: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
60145: LD_ADDR_VAR 0 10
60149: PUSH
60150: LD_VAR 0 11
60154: PPUSH
60155: CALL_OW 251
60159: PPUSH
60160: LD_VAR 0 8
60164: PPUSH
60165: LD_INT 2
60167: PPUSH
60168: CALL_OW 273
60172: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
60173: LD_VAR 0 9
60177: PPUSH
60178: LD_VAR 0 10
60182: PPUSH
60183: CALL_OW 488
60187: PUSH
60188: LD_VAR 0 9
60192: PPUSH
60193: LD_VAR 0 10
60197: PPUSH
60198: CALL_OW 428
60202: NOT
60203: AND
60204: IFFALSE 60227
// begin ComMoveXY ( tmp , _x , _y ) ;
60206: LD_VAR 0 11
60210: PPUSH
60211: LD_VAR 0 9
60215: PPUSH
60216: LD_VAR 0 10
60220: PPUSH
60221: CALL_OW 111
// break ;
60225: GO 60229
// end ; end ;
60227: GO 60114
60229: POP
60230: POP
// end ;
60231: GO 59697
60233: POP
60234: POP
// end ;
60235: LD_VAR 0 6
60239: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
60240: LD_INT 0
60242: PPUSH
60243: PPUSH
60244: PPUSH
60245: PPUSH
60246: PPUSH
60247: PPUSH
60248: PPUSH
60249: PPUSH
60250: PPUSH
60251: PPUSH
// result := false ;
60252: LD_ADDR_VAR 0 6
60256: PUSH
60257: LD_INT 0
60259: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
60260: LD_VAR 0 1
60264: NOT
60265: PUSH
60266: LD_VAR 0 1
60270: PPUSH
60271: CALL_OW 266
60275: PUSH
60276: LD_INT 0
60278: PUSH
60279: LD_INT 1
60281: PUSH
60282: EMPTY
60283: LIST
60284: LIST
60285: IN
60286: NOT
60287: OR
60288: PUSH
60289: LD_VAR 0 2
60293: NOT
60294: OR
60295: PUSH
60296: LD_VAR 0 5
60300: PUSH
60301: LD_INT 0
60303: PUSH
60304: LD_INT 1
60306: PUSH
60307: LD_INT 2
60309: PUSH
60310: LD_INT 3
60312: PUSH
60313: LD_INT 4
60315: PUSH
60316: LD_INT 5
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: LIST
60323: LIST
60324: LIST
60325: LIST
60326: IN
60327: NOT
60328: OR
60329: PUSH
60330: LD_VAR 0 3
60334: PPUSH
60335: LD_VAR 0 4
60339: PPUSH
60340: CALL_OW 488
60344: NOT
60345: OR
60346: IFFALSE 60350
// exit ;
60348: GO 61067
// pom := GetBase ( depot ) ;
60350: LD_ADDR_VAR 0 10
60354: PUSH
60355: LD_VAR 0 1
60359: PPUSH
60360: CALL_OW 274
60364: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
60365: LD_ADDR_VAR 0 11
60369: PUSH
60370: LD_VAR 0 2
60374: PPUSH
60375: LD_VAR 0 1
60379: PPUSH
60380: CALL_OW 248
60384: PPUSH
60385: CALL_OW 450
60389: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
60390: LD_VAR 0 10
60394: PPUSH
60395: LD_INT 1
60397: PPUSH
60398: CALL_OW 275
60402: PUSH
60403: LD_VAR 0 11
60407: PUSH
60408: LD_INT 1
60410: ARRAY
60411: GREATEREQUAL
60412: PUSH
60413: LD_VAR 0 10
60417: PPUSH
60418: LD_INT 2
60420: PPUSH
60421: CALL_OW 275
60425: PUSH
60426: LD_VAR 0 11
60430: PUSH
60431: LD_INT 2
60433: ARRAY
60434: GREATEREQUAL
60435: AND
60436: PUSH
60437: LD_VAR 0 10
60441: PPUSH
60442: LD_INT 3
60444: PPUSH
60445: CALL_OW 275
60449: PUSH
60450: LD_VAR 0 11
60454: PUSH
60455: LD_INT 3
60457: ARRAY
60458: GREATEREQUAL
60459: AND
60460: NOT
60461: IFFALSE 60465
// exit ;
60463: GO 61067
// if GetBType ( depot ) = b_depot then
60465: LD_VAR 0 1
60469: PPUSH
60470: CALL_OW 266
60474: PUSH
60475: LD_INT 0
60477: EQUAL
60478: IFFALSE 60490
// dist := 28 else
60480: LD_ADDR_VAR 0 14
60484: PUSH
60485: LD_INT 28
60487: ST_TO_ADDR
60488: GO 60498
// dist := 36 ;
60490: LD_ADDR_VAR 0 14
60494: PUSH
60495: LD_INT 36
60497: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
60498: LD_VAR 0 1
60502: PPUSH
60503: LD_VAR 0 3
60507: PPUSH
60508: LD_VAR 0 4
60512: PPUSH
60513: CALL_OW 297
60517: PUSH
60518: LD_VAR 0 14
60522: GREATER
60523: IFFALSE 60527
// exit ;
60525: GO 61067
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
60527: LD_ADDR_VAR 0 12
60531: PUSH
60532: LD_VAR 0 2
60536: PPUSH
60537: LD_VAR 0 3
60541: PPUSH
60542: LD_VAR 0 4
60546: PPUSH
60547: LD_VAR 0 5
60551: PPUSH
60552: LD_VAR 0 1
60556: PPUSH
60557: CALL_OW 248
60561: PPUSH
60562: LD_INT 0
60564: PPUSH
60565: CALL 61072 0 6
60569: ST_TO_ADDR
// if not hexes then
60570: LD_VAR 0 12
60574: NOT
60575: IFFALSE 60579
// exit ;
60577: GO 61067
// hex := GetHexInfo ( x , y ) ;
60579: LD_ADDR_VAR 0 15
60583: PUSH
60584: LD_VAR 0 3
60588: PPUSH
60589: LD_VAR 0 4
60593: PPUSH
60594: CALL_OW 546
60598: ST_TO_ADDR
// if hex [ 1 ] then
60599: LD_VAR 0 15
60603: PUSH
60604: LD_INT 1
60606: ARRAY
60607: IFFALSE 60611
// exit ;
60609: GO 61067
// height := hex [ 2 ] ;
60611: LD_ADDR_VAR 0 13
60615: PUSH
60616: LD_VAR 0 15
60620: PUSH
60621: LD_INT 2
60623: ARRAY
60624: ST_TO_ADDR
// for i = 1 to hexes do
60625: LD_ADDR_VAR 0 7
60629: PUSH
60630: DOUBLE
60631: LD_INT 1
60633: DEC
60634: ST_TO_ADDR
60635: LD_VAR 0 12
60639: PUSH
60640: FOR_TO
60641: IFFALSE 60971
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
60643: LD_VAR 0 12
60647: PUSH
60648: LD_VAR 0 7
60652: ARRAY
60653: PUSH
60654: LD_INT 1
60656: ARRAY
60657: PPUSH
60658: LD_VAR 0 12
60662: PUSH
60663: LD_VAR 0 7
60667: ARRAY
60668: PUSH
60669: LD_INT 2
60671: ARRAY
60672: PPUSH
60673: CALL_OW 488
60677: NOT
60678: PUSH
60679: LD_VAR 0 12
60683: PUSH
60684: LD_VAR 0 7
60688: ARRAY
60689: PUSH
60690: LD_INT 1
60692: ARRAY
60693: PPUSH
60694: LD_VAR 0 12
60698: PUSH
60699: LD_VAR 0 7
60703: ARRAY
60704: PUSH
60705: LD_INT 2
60707: ARRAY
60708: PPUSH
60709: CALL_OW 428
60713: PUSH
60714: LD_INT 0
60716: GREATER
60717: OR
60718: PUSH
60719: LD_VAR 0 12
60723: PUSH
60724: LD_VAR 0 7
60728: ARRAY
60729: PUSH
60730: LD_INT 1
60732: ARRAY
60733: PPUSH
60734: LD_VAR 0 12
60738: PUSH
60739: LD_VAR 0 7
60743: ARRAY
60744: PUSH
60745: LD_INT 2
60747: ARRAY
60748: PPUSH
60749: CALL_OW 351
60753: OR
60754: IFFALSE 60760
// exit ;
60756: POP
60757: POP
60758: GO 61067
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60760: LD_ADDR_VAR 0 8
60764: PUSH
60765: LD_VAR 0 12
60769: PUSH
60770: LD_VAR 0 7
60774: ARRAY
60775: PUSH
60776: LD_INT 1
60778: ARRAY
60779: PPUSH
60780: LD_VAR 0 12
60784: PUSH
60785: LD_VAR 0 7
60789: ARRAY
60790: PUSH
60791: LD_INT 2
60793: ARRAY
60794: PPUSH
60795: CALL_OW 546
60799: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
60800: LD_VAR 0 8
60804: PUSH
60805: LD_INT 1
60807: ARRAY
60808: PUSH
60809: LD_VAR 0 8
60813: PUSH
60814: LD_INT 2
60816: ARRAY
60817: PUSH
60818: LD_VAR 0 13
60822: PUSH
60823: LD_INT 2
60825: PLUS
60826: GREATER
60827: OR
60828: PUSH
60829: LD_VAR 0 8
60833: PUSH
60834: LD_INT 2
60836: ARRAY
60837: PUSH
60838: LD_VAR 0 13
60842: PUSH
60843: LD_INT 2
60845: MINUS
60846: LESS
60847: OR
60848: PUSH
60849: LD_VAR 0 8
60853: PUSH
60854: LD_INT 3
60856: ARRAY
60857: PUSH
60858: LD_INT 0
60860: PUSH
60861: LD_INT 8
60863: PUSH
60864: LD_INT 9
60866: PUSH
60867: LD_INT 10
60869: PUSH
60870: LD_INT 11
60872: PUSH
60873: LD_INT 12
60875: PUSH
60876: LD_INT 13
60878: PUSH
60879: LD_INT 16
60881: PUSH
60882: LD_INT 17
60884: PUSH
60885: LD_INT 18
60887: PUSH
60888: LD_INT 19
60890: PUSH
60891: LD_INT 20
60893: PUSH
60894: LD_INT 21
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: LIST
60901: LIST
60902: LIST
60903: LIST
60904: LIST
60905: LIST
60906: LIST
60907: LIST
60908: LIST
60909: LIST
60910: LIST
60911: IN
60912: NOT
60913: OR
60914: PUSH
60915: LD_VAR 0 8
60919: PUSH
60920: LD_INT 5
60922: ARRAY
60923: NOT
60924: OR
60925: PUSH
60926: LD_VAR 0 8
60930: PUSH
60931: LD_INT 6
60933: ARRAY
60934: PUSH
60935: LD_INT 1
60937: PUSH
60938: LD_INT 2
60940: PUSH
60941: LD_INT 7
60943: PUSH
60944: LD_INT 9
60946: PUSH
60947: LD_INT 10
60949: PUSH
60950: LD_INT 11
60952: PUSH
60953: EMPTY
60954: LIST
60955: LIST
60956: LIST
60957: LIST
60958: LIST
60959: LIST
60960: IN
60961: NOT
60962: OR
60963: IFFALSE 60969
// exit ;
60965: POP
60966: POP
60967: GO 61067
// end ;
60969: GO 60640
60971: POP
60972: POP
// side := GetSide ( depot ) ;
60973: LD_ADDR_VAR 0 9
60977: PUSH
60978: LD_VAR 0 1
60982: PPUSH
60983: CALL_OW 255
60987: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60988: LD_VAR 0 9
60992: PPUSH
60993: LD_VAR 0 3
60997: PPUSH
60998: LD_VAR 0 4
61002: PPUSH
61003: LD_INT 20
61005: PPUSH
61006: CALL 53721 0 4
61010: PUSH
61011: LD_INT 4
61013: ARRAY
61014: IFFALSE 61018
// exit ;
61016: GO 61067
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
61018: LD_VAR 0 2
61022: PUSH
61023: LD_INT 29
61025: PUSH
61026: LD_INT 30
61028: PUSH
61029: EMPTY
61030: LIST
61031: LIST
61032: IN
61033: PUSH
61034: LD_VAR 0 3
61038: PPUSH
61039: LD_VAR 0 4
61043: PPUSH
61044: LD_VAR 0 9
61048: PPUSH
61049: CALL_OW 440
61053: NOT
61054: AND
61055: IFFALSE 61059
// exit ;
61057: GO 61067
// result := true ;
61059: LD_ADDR_VAR 0 6
61063: PUSH
61064: LD_INT 1
61066: ST_TO_ADDR
// end ;
61067: LD_VAR 0 6
61071: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
61072: LD_INT 0
61074: PPUSH
61075: PPUSH
61076: PPUSH
61077: PPUSH
61078: PPUSH
61079: PPUSH
61080: PPUSH
61081: PPUSH
61082: PPUSH
61083: PPUSH
61084: PPUSH
61085: PPUSH
61086: PPUSH
61087: PPUSH
61088: PPUSH
61089: PPUSH
61090: PPUSH
61091: PPUSH
61092: PPUSH
61093: PPUSH
61094: PPUSH
61095: PPUSH
61096: PPUSH
61097: PPUSH
61098: PPUSH
61099: PPUSH
61100: PPUSH
61101: PPUSH
61102: PPUSH
61103: PPUSH
61104: PPUSH
61105: PPUSH
61106: PPUSH
61107: PPUSH
61108: PPUSH
61109: PPUSH
61110: PPUSH
61111: PPUSH
61112: PPUSH
61113: PPUSH
61114: PPUSH
61115: PPUSH
61116: PPUSH
61117: PPUSH
61118: PPUSH
61119: PPUSH
61120: PPUSH
61121: PPUSH
61122: PPUSH
61123: PPUSH
61124: PPUSH
61125: PPUSH
61126: PPUSH
61127: PPUSH
61128: PPUSH
61129: PPUSH
61130: PPUSH
61131: PPUSH
// result = [ ] ;
61132: LD_ADDR_VAR 0 7
61136: PUSH
61137: EMPTY
61138: ST_TO_ADDR
// temp_list = [ ] ;
61139: LD_ADDR_VAR 0 9
61143: PUSH
61144: EMPTY
61145: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
61146: LD_VAR 0 4
61150: PUSH
61151: LD_INT 0
61153: PUSH
61154: LD_INT 1
61156: PUSH
61157: LD_INT 2
61159: PUSH
61160: LD_INT 3
61162: PUSH
61163: LD_INT 4
61165: PUSH
61166: LD_INT 5
61168: PUSH
61169: EMPTY
61170: LIST
61171: LIST
61172: LIST
61173: LIST
61174: LIST
61175: LIST
61176: IN
61177: NOT
61178: PUSH
61179: LD_VAR 0 1
61183: PUSH
61184: LD_INT 0
61186: PUSH
61187: LD_INT 1
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: IN
61194: PUSH
61195: LD_VAR 0 5
61199: PUSH
61200: LD_INT 1
61202: PUSH
61203: LD_INT 2
61205: PUSH
61206: LD_INT 3
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: LIST
61213: IN
61214: NOT
61215: AND
61216: OR
61217: IFFALSE 61221
// exit ;
61219: GO 79612
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
61221: LD_VAR 0 1
61225: PUSH
61226: LD_INT 6
61228: PUSH
61229: LD_INT 7
61231: PUSH
61232: LD_INT 8
61234: PUSH
61235: LD_INT 13
61237: PUSH
61238: LD_INT 12
61240: PUSH
61241: LD_INT 15
61243: PUSH
61244: LD_INT 11
61246: PUSH
61247: LD_INT 14
61249: PUSH
61250: LD_INT 10
61252: PUSH
61253: EMPTY
61254: LIST
61255: LIST
61256: LIST
61257: LIST
61258: LIST
61259: LIST
61260: LIST
61261: LIST
61262: LIST
61263: IN
61264: IFFALSE 61274
// btype = b_lab ;
61266: LD_ADDR_VAR 0 1
61270: PUSH
61271: LD_INT 6
61273: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
61274: LD_VAR 0 6
61278: PUSH
61279: LD_INT 0
61281: PUSH
61282: LD_INT 1
61284: PUSH
61285: LD_INT 2
61287: PUSH
61288: EMPTY
61289: LIST
61290: LIST
61291: LIST
61292: IN
61293: NOT
61294: PUSH
61295: LD_VAR 0 1
61299: PUSH
61300: LD_INT 0
61302: PUSH
61303: LD_INT 1
61305: PUSH
61306: LD_INT 2
61308: PUSH
61309: LD_INT 3
61311: PUSH
61312: LD_INT 6
61314: PUSH
61315: LD_INT 36
61317: PUSH
61318: LD_INT 4
61320: PUSH
61321: LD_INT 5
61323: PUSH
61324: LD_INT 31
61326: PUSH
61327: LD_INT 32
61329: PUSH
61330: LD_INT 33
61332: PUSH
61333: EMPTY
61334: LIST
61335: LIST
61336: LIST
61337: LIST
61338: LIST
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: LIST
61345: IN
61346: NOT
61347: PUSH
61348: LD_VAR 0 6
61352: PUSH
61353: LD_INT 1
61355: EQUAL
61356: AND
61357: OR
61358: PUSH
61359: LD_VAR 0 1
61363: PUSH
61364: LD_INT 2
61366: PUSH
61367: LD_INT 3
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: IN
61374: NOT
61375: PUSH
61376: LD_VAR 0 6
61380: PUSH
61381: LD_INT 2
61383: EQUAL
61384: AND
61385: OR
61386: IFFALSE 61396
// mode = 0 ;
61388: LD_ADDR_VAR 0 6
61392: PUSH
61393: LD_INT 0
61395: ST_TO_ADDR
// case mode of 0 :
61396: LD_VAR 0 6
61400: PUSH
61401: LD_INT 0
61403: DOUBLE
61404: EQUAL
61405: IFTRUE 61409
61407: GO 72862
61409: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
61410: LD_ADDR_VAR 0 11
61414: PUSH
61415: LD_INT 0
61417: PUSH
61418: LD_INT 0
61420: PUSH
61421: EMPTY
61422: LIST
61423: LIST
61424: PUSH
61425: LD_INT 0
61427: PUSH
61428: LD_INT 1
61430: NEG
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: PUSH
61436: LD_INT 1
61438: PUSH
61439: LD_INT 0
61441: PUSH
61442: EMPTY
61443: LIST
61444: LIST
61445: PUSH
61446: LD_INT 1
61448: PUSH
61449: LD_INT 1
61451: PUSH
61452: EMPTY
61453: LIST
61454: LIST
61455: PUSH
61456: LD_INT 0
61458: PUSH
61459: LD_INT 1
61461: PUSH
61462: EMPTY
61463: LIST
61464: LIST
61465: PUSH
61466: LD_INT 1
61468: NEG
61469: PUSH
61470: LD_INT 0
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: PUSH
61477: LD_INT 1
61479: NEG
61480: PUSH
61481: LD_INT 1
61483: NEG
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: PUSH
61489: LD_INT 1
61491: NEG
61492: PUSH
61493: LD_INT 2
61495: NEG
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: PUSH
61501: LD_INT 0
61503: PUSH
61504: LD_INT 2
61506: NEG
61507: PUSH
61508: EMPTY
61509: LIST
61510: LIST
61511: PUSH
61512: LD_INT 1
61514: PUSH
61515: LD_INT 1
61517: NEG
61518: PUSH
61519: EMPTY
61520: LIST
61521: LIST
61522: PUSH
61523: LD_INT 1
61525: PUSH
61526: LD_INT 2
61528: PUSH
61529: EMPTY
61530: LIST
61531: LIST
61532: PUSH
61533: LD_INT 0
61535: PUSH
61536: LD_INT 2
61538: PUSH
61539: EMPTY
61540: LIST
61541: LIST
61542: PUSH
61543: LD_INT 1
61545: NEG
61546: PUSH
61547: LD_INT 1
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: PUSH
61554: LD_INT 1
61556: PUSH
61557: LD_INT 3
61559: PUSH
61560: EMPTY
61561: LIST
61562: LIST
61563: PUSH
61564: LD_INT 0
61566: PUSH
61567: LD_INT 3
61569: PUSH
61570: EMPTY
61571: LIST
61572: LIST
61573: PUSH
61574: LD_INT 1
61576: NEG
61577: PUSH
61578: LD_INT 2
61580: PUSH
61581: EMPTY
61582: LIST
61583: LIST
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: LIST
61589: LIST
61590: LIST
61591: LIST
61592: LIST
61593: LIST
61594: LIST
61595: LIST
61596: LIST
61597: LIST
61598: LIST
61599: LIST
61600: LIST
61601: LIST
61602: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
61603: LD_ADDR_VAR 0 12
61607: PUSH
61608: LD_INT 0
61610: PUSH
61611: LD_INT 0
61613: PUSH
61614: EMPTY
61615: LIST
61616: LIST
61617: PUSH
61618: LD_INT 0
61620: PUSH
61621: LD_INT 1
61623: NEG
61624: PUSH
61625: EMPTY
61626: LIST
61627: LIST
61628: PUSH
61629: LD_INT 1
61631: PUSH
61632: LD_INT 0
61634: PUSH
61635: EMPTY
61636: LIST
61637: LIST
61638: PUSH
61639: LD_INT 1
61641: PUSH
61642: LD_INT 1
61644: PUSH
61645: EMPTY
61646: LIST
61647: LIST
61648: PUSH
61649: LD_INT 0
61651: PUSH
61652: LD_INT 1
61654: PUSH
61655: EMPTY
61656: LIST
61657: LIST
61658: PUSH
61659: LD_INT 1
61661: NEG
61662: PUSH
61663: LD_INT 0
61665: PUSH
61666: EMPTY
61667: LIST
61668: LIST
61669: PUSH
61670: LD_INT 1
61672: NEG
61673: PUSH
61674: LD_INT 1
61676: NEG
61677: PUSH
61678: EMPTY
61679: LIST
61680: LIST
61681: PUSH
61682: LD_INT 1
61684: PUSH
61685: LD_INT 1
61687: NEG
61688: PUSH
61689: EMPTY
61690: LIST
61691: LIST
61692: PUSH
61693: LD_INT 2
61695: PUSH
61696: LD_INT 0
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PUSH
61703: LD_INT 2
61705: PUSH
61706: LD_INT 1
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: LD_INT 1
61715: NEG
61716: PUSH
61717: LD_INT 1
61719: PUSH
61720: EMPTY
61721: LIST
61722: LIST
61723: PUSH
61724: LD_INT 2
61726: NEG
61727: PUSH
61728: LD_INT 0
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: PUSH
61735: LD_INT 2
61737: NEG
61738: PUSH
61739: LD_INT 1
61741: NEG
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: PUSH
61747: LD_INT 2
61749: NEG
61750: PUSH
61751: LD_INT 1
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: PUSH
61758: LD_INT 3
61760: NEG
61761: PUSH
61762: LD_INT 0
61764: PUSH
61765: EMPTY
61766: LIST
61767: LIST
61768: PUSH
61769: LD_INT 3
61771: NEG
61772: PUSH
61773: LD_INT 1
61775: NEG
61776: PUSH
61777: EMPTY
61778: LIST
61779: LIST
61780: PUSH
61781: EMPTY
61782: LIST
61783: LIST
61784: LIST
61785: LIST
61786: LIST
61787: LIST
61788: LIST
61789: LIST
61790: LIST
61791: LIST
61792: LIST
61793: LIST
61794: LIST
61795: LIST
61796: LIST
61797: LIST
61798: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
61799: LD_ADDR_VAR 0 13
61803: PUSH
61804: LD_INT 0
61806: PUSH
61807: LD_INT 0
61809: PUSH
61810: EMPTY
61811: LIST
61812: LIST
61813: PUSH
61814: LD_INT 0
61816: PUSH
61817: LD_INT 1
61819: NEG
61820: PUSH
61821: EMPTY
61822: LIST
61823: LIST
61824: PUSH
61825: LD_INT 1
61827: PUSH
61828: LD_INT 0
61830: PUSH
61831: EMPTY
61832: LIST
61833: LIST
61834: PUSH
61835: LD_INT 1
61837: PUSH
61838: LD_INT 1
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: PUSH
61845: LD_INT 0
61847: PUSH
61848: LD_INT 1
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: PUSH
61855: LD_INT 1
61857: NEG
61858: PUSH
61859: LD_INT 0
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: LD_INT 1
61868: NEG
61869: PUSH
61870: LD_INT 1
61872: NEG
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: PUSH
61878: LD_INT 1
61880: NEG
61881: PUSH
61882: LD_INT 2
61884: NEG
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: PUSH
61890: LD_INT 2
61892: PUSH
61893: LD_INT 1
61895: PUSH
61896: EMPTY
61897: LIST
61898: LIST
61899: PUSH
61900: LD_INT 2
61902: PUSH
61903: LD_INT 2
61905: PUSH
61906: EMPTY
61907: LIST
61908: LIST
61909: PUSH
61910: LD_INT 1
61912: PUSH
61913: LD_INT 2
61915: PUSH
61916: EMPTY
61917: LIST
61918: LIST
61919: PUSH
61920: LD_INT 2
61922: NEG
61923: PUSH
61924: LD_INT 1
61926: NEG
61927: PUSH
61928: EMPTY
61929: LIST
61930: LIST
61931: PUSH
61932: LD_INT 2
61934: NEG
61935: PUSH
61936: LD_INT 2
61938: NEG
61939: PUSH
61940: EMPTY
61941: LIST
61942: LIST
61943: PUSH
61944: LD_INT 2
61946: NEG
61947: PUSH
61948: LD_INT 3
61950: NEG
61951: PUSH
61952: EMPTY
61953: LIST
61954: LIST
61955: PUSH
61956: LD_INT 3
61958: NEG
61959: PUSH
61960: LD_INT 2
61962: NEG
61963: PUSH
61964: EMPTY
61965: LIST
61966: LIST
61967: PUSH
61968: LD_INT 3
61970: NEG
61971: PUSH
61972: LD_INT 3
61974: NEG
61975: PUSH
61976: EMPTY
61977: LIST
61978: LIST
61979: PUSH
61980: EMPTY
61981: LIST
61982: LIST
61983: LIST
61984: LIST
61985: LIST
61986: LIST
61987: LIST
61988: LIST
61989: LIST
61990: LIST
61991: LIST
61992: LIST
61993: LIST
61994: LIST
61995: LIST
61996: LIST
61997: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
61998: LD_ADDR_VAR 0 14
62002: PUSH
62003: LD_INT 0
62005: PUSH
62006: LD_INT 0
62008: PUSH
62009: EMPTY
62010: LIST
62011: LIST
62012: PUSH
62013: LD_INT 0
62015: PUSH
62016: LD_INT 1
62018: NEG
62019: PUSH
62020: EMPTY
62021: LIST
62022: LIST
62023: PUSH
62024: LD_INT 1
62026: PUSH
62027: LD_INT 0
62029: PUSH
62030: EMPTY
62031: LIST
62032: LIST
62033: PUSH
62034: LD_INT 1
62036: PUSH
62037: LD_INT 1
62039: PUSH
62040: EMPTY
62041: LIST
62042: LIST
62043: PUSH
62044: LD_INT 0
62046: PUSH
62047: LD_INT 1
62049: PUSH
62050: EMPTY
62051: LIST
62052: LIST
62053: PUSH
62054: LD_INT 1
62056: NEG
62057: PUSH
62058: LD_INT 0
62060: PUSH
62061: EMPTY
62062: LIST
62063: LIST
62064: PUSH
62065: LD_INT 1
62067: NEG
62068: PUSH
62069: LD_INT 1
62071: NEG
62072: PUSH
62073: EMPTY
62074: LIST
62075: LIST
62076: PUSH
62077: LD_INT 1
62079: NEG
62080: PUSH
62081: LD_INT 2
62083: NEG
62084: PUSH
62085: EMPTY
62086: LIST
62087: LIST
62088: PUSH
62089: LD_INT 0
62091: PUSH
62092: LD_INT 2
62094: NEG
62095: PUSH
62096: EMPTY
62097: LIST
62098: LIST
62099: PUSH
62100: LD_INT 1
62102: PUSH
62103: LD_INT 1
62105: NEG
62106: PUSH
62107: EMPTY
62108: LIST
62109: LIST
62110: PUSH
62111: LD_INT 1
62113: PUSH
62114: LD_INT 2
62116: PUSH
62117: EMPTY
62118: LIST
62119: LIST
62120: PUSH
62121: LD_INT 0
62123: PUSH
62124: LD_INT 2
62126: PUSH
62127: EMPTY
62128: LIST
62129: LIST
62130: PUSH
62131: LD_INT 1
62133: NEG
62134: PUSH
62135: LD_INT 1
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 1
62144: NEG
62145: PUSH
62146: LD_INT 3
62148: NEG
62149: PUSH
62150: EMPTY
62151: LIST
62152: LIST
62153: PUSH
62154: LD_INT 0
62156: PUSH
62157: LD_INT 3
62159: NEG
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: PUSH
62165: LD_INT 1
62167: PUSH
62168: LD_INT 2
62170: NEG
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: LIST
62182: LIST
62183: LIST
62184: LIST
62185: LIST
62186: LIST
62187: LIST
62188: LIST
62189: LIST
62190: LIST
62191: LIST
62192: LIST
62193: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
62194: LD_ADDR_VAR 0 15
62198: PUSH
62199: LD_INT 0
62201: PUSH
62202: LD_INT 0
62204: PUSH
62205: EMPTY
62206: LIST
62207: LIST
62208: PUSH
62209: LD_INT 0
62211: PUSH
62212: LD_INT 1
62214: NEG
62215: PUSH
62216: EMPTY
62217: LIST
62218: LIST
62219: PUSH
62220: LD_INT 1
62222: PUSH
62223: LD_INT 0
62225: PUSH
62226: EMPTY
62227: LIST
62228: LIST
62229: PUSH
62230: LD_INT 1
62232: PUSH
62233: LD_INT 1
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: PUSH
62240: LD_INT 0
62242: PUSH
62243: LD_INT 1
62245: PUSH
62246: EMPTY
62247: LIST
62248: LIST
62249: PUSH
62250: LD_INT 1
62252: NEG
62253: PUSH
62254: LD_INT 0
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: PUSH
62261: LD_INT 1
62263: NEG
62264: PUSH
62265: LD_INT 1
62267: NEG
62268: PUSH
62269: EMPTY
62270: LIST
62271: LIST
62272: PUSH
62273: LD_INT 1
62275: PUSH
62276: LD_INT 1
62278: NEG
62279: PUSH
62280: EMPTY
62281: LIST
62282: LIST
62283: PUSH
62284: LD_INT 2
62286: PUSH
62287: LD_INT 0
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: PUSH
62294: LD_INT 2
62296: PUSH
62297: LD_INT 1
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PUSH
62304: LD_INT 1
62306: NEG
62307: PUSH
62308: LD_INT 1
62310: PUSH
62311: EMPTY
62312: LIST
62313: LIST
62314: PUSH
62315: LD_INT 2
62317: NEG
62318: PUSH
62319: LD_INT 0
62321: PUSH
62322: EMPTY
62323: LIST
62324: LIST
62325: PUSH
62326: LD_INT 2
62328: NEG
62329: PUSH
62330: LD_INT 1
62332: NEG
62333: PUSH
62334: EMPTY
62335: LIST
62336: LIST
62337: PUSH
62338: LD_INT 2
62340: PUSH
62341: LD_INT 1
62343: NEG
62344: PUSH
62345: EMPTY
62346: LIST
62347: LIST
62348: PUSH
62349: LD_INT 3
62351: PUSH
62352: LD_INT 0
62354: PUSH
62355: EMPTY
62356: LIST
62357: LIST
62358: PUSH
62359: LD_INT 3
62361: PUSH
62362: LD_INT 1
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: LIST
62373: LIST
62374: LIST
62375: LIST
62376: LIST
62377: LIST
62378: LIST
62379: LIST
62380: LIST
62381: LIST
62382: LIST
62383: LIST
62384: LIST
62385: LIST
62386: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
62387: LD_ADDR_VAR 0 16
62391: PUSH
62392: LD_INT 0
62394: PUSH
62395: LD_INT 0
62397: PUSH
62398: EMPTY
62399: LIST
62400: LIST
62401: PUSH
62402: LD_INT 0
62404: PUSH
62405: LD_INT 1
62407: NEG
62408: PUSH
62409: EMPTY
62410: LIST
62411: LIST
62412: PUSH
62413: LD_INT 1
62415: PUSH
62416: LD_INT 0
62418: PUSH
62419: EMPTY
62420: LIST
62421: LIST
62422: PUSH
62423: LD_INT 1
62425: PUSH
62426: LD_INT 1
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PUSH
62433: LD_INT 0
62435: PUSH
62436: LD_INT 1
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: PUSH
62443: LD_INT 1
62445: NEG
62446: PUSH
62447: LD_INT 0
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: PUSH
62454: LD_INT 1
62456: NEG
62457: PUSH
62458: LD_INT 1
62460: NEG
62461: PUSH
62462: EMPTY
62463: LIST
62464: LIST
62465: PUSH
62466: LD_INT 1
62468: NEG
62469: PUSH
62470: LD_INT 2
62472: NEG
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PUSH
62478: LD_INT 2
62480: PUSH
62481: LD_INT 1
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 2
62490: PUSH
62491: LD_INT 2
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 1
62500: PUSH
62501: LD_INT 2
62503: PUSH
62504: EMPTY
62505: LIST
62506: LIST
62507: PUSH
62508: LD_INT 2
62510: NEG
62511: PUSH
62512: LD_INT 1
62514: NEG
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: LD_INT 2
62522: NEG
62523: PUSH
62524: LD_INT 2
62526: NEG
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PUSH
62532: LD_INT 3
62534: PUSH
62535: LD_INT 2
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: PUSH
62542: LD_INT 3
62544: PUSH
62545: LD_INT 3
62547: PUSH
62548: EMPTY
62549: LIST
62550: LIST
62551: PUSH
62552: LD_INT 2
62554: PUSH
62555: LD_INT 3
62557: PUSH
62558: EMPTY
62559: LIST
62560: LIST
62561: PUSH
62562: EMPTY
62563: LIST
62564: LIST
62565: LIST
62566: LIST
62567: LIST
62568: LIST
62569: LIST
62570: LIST
62571: LIST
62572: LIST
62573: LIST
62574: LIST
62575: LIST
62576: LIST
62577: LIST
62578: LIST
62579: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62580: LD_ADDR_VAR 0 17
62584: PUSH
62585: LD_INT 0
62587: PUSH
62588: LD_INT 0
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PUSH
62595: LD_INT 0
62597: PUSH
62598: LD_INT 1
62600: NEG
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: PUSH
62606: LD_INT 1
62608: PUSH
62609: LD_INT 0
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: PUSH
62616: LD_INT 1
62618: PUSH
62619: LD_INT 1
62621: PUSH
62622: EMPTY
62623: LIST
62624: LIST
62625: PUSH
62626: LD_INT 0
62628: PUSH
62629: LD_INT 1
62631: PUSH
62632: EMPTY
62633: LIST
62634: LIST
62635: PUSH
62636: LD_INT 1
62638: NEG
62639: PUSH
62640: LD_INT 0
62642: PUSH
62643: EMPTY
62644: LIST
62645: LIST
62646: PUSH
62647: LD_INT 1
62649: NEG
62650: PUSH
62651: LD_INT 1
62653: NEG
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 1
62661: NEG
62662: PUSH
62663: LD_INT 2
62665: NEG
62666: PUSH
62667: EMPTY
62668: LIST
62669: LIST
62670: PUSH
62671: LD_INT 0
62673: PUSH
62674: LD_INT 2
62676: NEG
62677: PUSH
62678: EMPTY
62679: LIST
62680: LIST
62681: PUSH
62682: LD_INT 1
62684: PUSH
62685: LD_INT 1
62687: NEG
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: LD_INT 2
62695: PUSH
62696: LD_INT 0
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: PUSH
62703: LD_INT 2
62705: PUSH
62706: LD_INT 1
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PUSH
62713: LD_INT 2
62715: PUSH
62716: LD_INT 2
62718: PUSH
62719: EMPTY
62720: LIST
62721: LIST
62722: PUSH
62723: LD_INT 1
62725: PUSH
62726: LD_INT 2
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 0
62735: PUSH
62736: LD_INT 2
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PUSH
62743: LD_INT 1
62745: NEG
62746: PUSH
62747: LD_INT 1
62749: PUSH
62750: EMPTY
62751: LIST
62752: LIST
62753: PUSH
62754: LD_INT 2
62756: NEG
62757: PUSH
62758: LD_INT 0
62760: PUSH
62761: EMPTY
62762: LIST
62763: LIST
62764: PUSH
62765: LD_INT 2
62767: NEG
62768: PUSH
62769: LD_INT 1
62771: NEG
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: PUSH
62777: LD_INT 2
62779: NEG
62780: PUSH
62781: LD_INT 2
62783: NEG
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: LIST
62793: LIST
62794: LIST
62795: LIST
62796: LIST
62797: LIST
62798: LIST
62799: LIST
62800: LIST
62801: LIST
62802: LIST
62803: LIST
62804: LIST
62805: LIST
62806: LIST
62807: LIST
62808: LIST
62809: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62810: LD_ADDR_VAR 0 18
62814: PUSH
62815: LD_INT 0
62817: PUSH
62818: LD_INT 0
62820: PUSH
62821: EMPTY
62822: LIST
62823: LIST
62824: PUSH
62825: LD_INT 0
62827: PUSH
62828: LD_INT 1
62830: NEG
62831: PUSH
62832: EMPTY
62833: LIST
62834: LIST
62835: PUSH
62836: LD_INT 1
62838: PUSH
62839: LD_INT 0
62841: PUSH
62842: EMPTY
62843: LIST
62844: LIST
62845: PUSH
62846: LD_INT 1
62848: PUSH
62849: LD_INT 1
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PUSH
62856: LD_INT 0
62858: PUSH
62859: LD_INT 1
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: PUSH
62866: LD_INT 1
62868: NEG
62869: PUSH
62870: LD_INT 0
62872: PUSH
62873: EMPTY
62874: LIST
62875: LIST
62876: PUSH
62877: LD_INT 1
62879: NEG
62880: PUSH
62881: LD_INT 1
62883: NEG
62884: PUSH
62885: EMPTY
62886: LIST
62887: LIST
62888: PUSH
62889: LD_INT 1
62891: NEG
62892: PUSH
62893: LD_INT 2
62895: NEG
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 0
62903: PUSH
62904: LD_INT 2
62906: NEG
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: PUSH
62912: LD_INT 1
62914: PUSH
62915: LD_INT 1
62917: NEG
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: PUSH
62923: LD_INT 2
62925: PUSH
62926: LD_INT 0
62928: PUSH
62929: EMPTY
62930: LIST
62931: LIST
62932: PUSH
62933: LD_INT 2
62935: PUSH
62936: LD_INT 1
62938: PUSH
62939: EMPTY
62940: LIST
62941: LIST
62942: PUSH
62943: LD_INT 2
62945: PUSH
62946: LD_INT 2
62948: PUSH
62949: EMPTY
62950: LIST
62951: LIST
62952: PUSH
62953: LD_INT 1
62955: PUSH
62956: LD_INT 2
62958: PUSH
62959: EMPTY
62960: LIST
62961: LIST
62962: PUSH
62963: LD_INT 0
62965: PUSH
62966: LD_INT 2
62968: PUSH
62969: EMPTY
62970: LIST
62971: LIST
62972: PUSH
62973: LD_INT 1
62975: NEG
62976: PUSH
62977: LD_INT 1
62979: PUSH
62980: EMPTY
62981: LIST
62982: LIST
62983: PUSH
62984: LD_INT 2
62986: NEG
62987: PUSH
62988: LD_INT 0
62990: PUSH
62991: EMPTY
62992: LIST
62993: LIST
62994: PUSH
62995: LD_INT 2
62997: NEG
62998: PUSH
62999: LD_INT 1
63001: NEG
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PUSH
63007: LD_INT 2
63009: NEG
63010: PUSH
63011: LD_INT 2
63013: NEG
63014: PUSH
63015: EMPTY
63016: LIST
63017: LIST
63018: PUSH
63019: EMPTY
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: LIST
63025: LIST
63026: LIST
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: LIST
63032: LIST
63033: LIST
63034: LIST
63035: LIST
63036: LIST
63037: LIST
63038: LIST
63039: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63040: LD_ADDR_VAR 0 19
63044: PUSH
63045: LD_INT 0
63047: PUSH
63048: LD_INT 0
63050: PUSH
63051: EMPTY
63052: LIST
63053: LIST
63054: PUSH
63055: LD_INT 0
63057: PUSH
63058: LD_INT 1
63060: NEG
63061: PUSH
63062: EMPTY
63063: LIST
63064: LIST
63065: PUSH
63066: LD_INT 1
63068: PUSH
63069: LD_INT 0
63071: PUSH
63072: EMPTY
63073: LIST
63074: LIST
63075: PUSH
63076: LD_INT 1
63078: PUSH
63079: LD_INT 1
63081: PUSH
63082: EMPTY
63083: LIST
63084: LIST
63085: PUSH
63086: LD_INT 0
63088: PUSH
63089: LD_INT 1
63091: PUSH
63092: EMPTY
63093: LIST
63094: LIST
63095: PUSH
63096: LD_INT 1
63098: NEG
63099: PUSH
63100: LD_INT 0
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: PUSH
63107: LD_INT 1
63109: NEG
63110: PUSH
63111: LD_INT 1
63113: NEG
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: PUSH
63119: LD_INT 1
63121: NEG
63122: PUSH
63123: LD_INT 2
63125: NEG
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: PUSH
63131: LD_INT 0
63133: PUSH
63134: LD_INT 2
63136: NEG
63137: PUSH
63138: EMPTY
63139: LIST
63140: LIST
63141: PUSH
63142: LD_INT 1
63144: PUSH
63145: LD_INT 1
63147: NEG
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: PUSH
63153: LD_INT 2
63155: PUSH
63156: LD_INT 0
63158: PUSH
63159: EMPTY
63160: LIST
63161: LIST
63162: PUSH
63163: LD_INT 2
63165: PUSH
63166: LD_INT 1
63168: PUSH
63169: EMPTY
63170: LIST
63171: LIST
63172: PUSH
63173: LD_INT 2
63175: PUSH
63176: LD_INT 2
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: LD_INT 1
63185: PUSH
63186: LD_INT 2
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 0
63195: PUSH
63196: LD_INT 2
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: LD_INT 1
63205: NEG
63206: PUSH
63207: LD_INT 1
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: PUSH
63214: LD_INT 2
63216: NEG
63217: PUSH
63218: LD_INT 0
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: PUSH
63225: LD_INT 2
63227: NEG
63228: PUSH
63229: LD_INT 1
63231: NEG
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PUSH
63237: LD_INT 2
63239: NEG
63240: PUSH
63241: LD_INT 2
63243: NEG
63244: PUSH
63245: EMPTY
63246: LIST
63247: LIST
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63270: LD_ADDR_VAR 0 20
63274: PUSH
63275: LD_INT 0
63277: PUSH
63278: LD_INT 0
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: PUSH
63285: LD_INT 0
63287: PUSH
63288: LD_INT 1
63290: NEG
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 1
63298: PUSH
63299: LD_INT 0
63301: PUSH
63302: EMPTY
63303: LIST
63304: LIST
63305: PUSH
63306: LD_INT 1
63308: PUSH
63309: LD_INT 1
63311: PUSH
63312: EMPTY
63313: LIST
63314: LIST
63315: PUSH
63316: LD_INT 0
63318: PUSH
63319: LD_INT 1
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: PUSH
63326: LD_INT 1
63328: NEG
63329: PUSH
63330: LD_INT 0
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: LD_INT 1
63339: NEG
63340: PUSH
63341: LD_INT 1
63343: NEG
63344: PUSH
63345: EMPTY
63346: LIST
63347: LIST
63348: PUSH
63349: LD_INT 1
63351: NEG
63352: PUSH
63353: LD_INT 2
63355: NEG
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: LD_INT 0
63363: PUSH
63364: LD_INT 2
63366: NEG
63367: PUSH
63368: EMPTY
63369: LIST
63370: LIST
63371: PUSH
63372: LD_INT 1
63374: PUSH
63375: LD_INT 1
63377: NEG
63378: PUSH
63379: EMPTY
63380: LIST
63381: LIST
63382: PUSH
63383: LD_INT 2
63385: PUSH
63386: LD_INT 0
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: PUSH
63393: LD_INT 2
63395: PUSH
63396: LD_INT 1
63398: PUSH
63399: EMPTY
63400: LIST
63401: LIST
63402: PUSH
63403: LD_INT 2
63405: PUSH
63406: LD_INT 2
63408: PUSH
63409: EMPTY
63410: LIST
63411: LIST
63412: PUSH
63413: LD_INT 1
63415: PUSH
63416: LD_INT 2
63418: PUSH
63419: EMPTY
63420: LIST
63421: LIST
63422: PUSH
63423: LD_INT 0
63425: PUSH
63426: LD_INT 2
63428: PUSH
63429: EMPTY
63430: LIST
63431: LIST
63432: PUSH
63433: LD_INT 1
63435: NEG
63436: PUSH
63437: LD_INT 1
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: PUSH
63444: LD_INT 2
63446: NEG
63447: PUSH
63448: LD_INT 0
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PUSH
63455: LD_INT 2
63457: NEG
63458: PUSH
63459: LD_INT 1
63461: NEG
63462: PUSH
63463: EMPTY
63464: LIST
63465: LIST
63466: PUSH
63467: LD_INT 2
63469: NEG
63470: PUSH
63471: LD_INT 2
63473: NEG
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: EMPTY
63480: LIST
63481: LIST
63482: LIST
63483: LIST
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: LIST
63491: LIST
63492: LIST
63493: LIST
63494: LIST
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63500: LD_ADDR_VAR 0 21
63504: PUSH
63505: LD_INT 0
63507: PUSH
63508: LD_INT 0
63510: PUSH
63511: EMPTY
63512: LIST
63513: LIST
63514: PUSH
63515: LD_INT 0
63517: PUSH
63518: LD_INT 1
63520: NEG
63521: PUSH
63522: EMPTY
63523: LIST
63524: LIST
63525: PUSH
63526: LD_INT 1
63528: PUSH
63529: LD_INT 0
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: PUSH
63536: LD_INT 1
63538: PUSH
63539: LD_INT 1
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: LD_INT 0
63548: PUSH
63549: LD_INT 1
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 1
63558: NEG
63559: PUSH
63560: LD_INT 0
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: LD_INT 1
63569: NEG
63570: PUSH
63571: LD_INT 1
63573: NEG
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PUSH
63579: LD_INT 1
63581: NEG
63582: PUSH
63583: LD_INT 2
63585: NEG
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 0
63593: PUSH
63594: LD_INT 2
63596: NEG
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PUSH
63602: LD_INT 1
63604: PUSH
63605: LD_INT 1
63607: NEG
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: PUSH
63613: LD_INT 2
63615: PUSH
63616: LD_INT 0
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: PUSH
63623: LD_INT 2
63625: PUSH
63626: LD_INT 1
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: PUSH
63633: LD_INT 2
63635: PUSH
63636: LD_INT 2
63638: PUSH
63639: EMPTY
63640: LIST
63641: LIST
63642: PUSH
63643: LD_INT 1
63645: PUSH
63646: LD_INT 2
63648: PUSH
63649: EMPTY
63650: LIST
63651: LIST
63652: PUSH
63653: LD_INT 0
63655: PUSH
63656: LD_INT 2
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PUSH
63663: LD_INT 1
63665: NEG
63666: PUSH
63667: LD_INT 1
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 2
63676: NEG
63677: PUSH
63678: LD_INT 0
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: PUSH
63685: LD_INT 2
63687: NEG
63688: PUSH
63689: LD_INT 1
63691: NEG
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 2
63699: NEG
63700: PUSH
63701: LD_INT 2
63703: NEG
63704: PUSH
63705: EMPTY
63706: LIST
63707: LIST
63708: PUSH
63709: EMPTY
63710: LIST
63711: LIST
63712: LIST
63713: LIST
63714: LIST
63715: LIST
63716: LIST
63717: LIST
63718: LIST
63719: LIST
63720: LIST
63721: LIST
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63730: LD_ADDR_VAR 0 22
63734: PUSH
63735: LD_INT 0
63737: PUSH
63738: LD_INT 0
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: LD_INT 0
63747: PUSH
63748: LD_INT 1
63750: NEG
63751: PUSH
63752: EMPTY
63753: LIST
63754: LIST
63755: PUSH
63756: LD_INT 1
63758: PUSH
63759: LD_INT 0
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 1
63768: PUSH
63769: LD_INT 1
63771: PUSH
63772: EMPTY
63773: LIST
63774: LIST
63775: PUSH
63776: LD_INT 0
63778: PUSH
63779: LD_INT 1
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: PUSH
63786: LD_INT 1
63788: NEG
63789: PUSH
63790: LD_INT 0
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 1
63799: NEG
63800: PUSH
63801: LD_INT 1
63803: NEG
63804: PUSH
63805: EMPTY
63806: LIST
63807: LIST
63808: PUSH
63809: LD_INT 1
63811: NEG
63812: PUSH
63813: LD_INT 2
63815: NEG
63816: PUSH
63817: EMPTY
63818: LIST
63819: LIST
63820: PUSH
63821: LD_INT 0
63823: PUSH
63824: LD_INT 2
63826: NEG
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: PUSH
63832: LD_INT 1
63834: PUSH
63835: LD_INT 1
63837: NEG
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: PUSH
63843: LD_INT 2
63845: PUSH
63846: LD_INT 0
63848: PUSH
63849: EMPTY
63850: LIST
63851: LIST
63852: PUSH
63853: LD_INT 2
63855: PUSH
63856: LD_INT 1
63858: PUSH
63859: EMPTY
63860: LIST
63861: LIST
63862: PUSH
63863: LD_INT 2
63865: PUSH
63866: LD_INT 2
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: PUSH
63873: LD_INT 1
63875: PUSH
63876: LD_INT 2
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: LD_INT 0
63885: PUSH
63886: LD_INT 2
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: LD_INT 1
63895: NEG
63896: PUSH
63897: LD_INT 1
63899: PUSH
63900: EMPTY
63901: LIST
63902: LIST
63903: PUSH
63904: LD_INT 2
63906: NEG
63907: PUSH
63908: LD_INT 0
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PUSH
63915: LD_INT 2
63917: NEG
63918: PUSH
63919: LD_INT 1
63921: NEG
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PUSH
63927: LD_INT 2
63929: NEG
63930: PUSH
63931: LD_INT 2
63933: NEG
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: EMPTY
63940: LIST
63941: LIST
63942: LIST
63943: LIST
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: LIST
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: LIST
63959: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
63960: LD_ADDR_VAR 0 23
63964: PUSH
63965: LD_INT 0
63967: PUSH
63968: LD_INT 0
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 0
63977: PUSH
63978: LD_INT 1
63980: NEG
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: LD_INT 1
63988: PUSH
63989: LD_INT 0
63991: PUSH
63992: EMPTY
63993: LIST
63994: LIST
63995: PUSH
63996: LD_INT 1
63998: PUSH
63999: LD_INT 1
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: LD_INT 0
64008: PUSH
64009: LD_INT 1
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 1
64018: NEG
64019: PUSH
64020: LD_INT 0
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 1
64029: NEG
64030: PUSH
64031: LD_INT 1
64033: NEG
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: PUSH
64039: LD_INT 1
64041: NEG
64042: PUSH
64043: LD_INT 2
64045: NEG
64046: PUSH
64047: EMPTY
64048: LIST
64049: LIST
64050: PUSH
64051: LD_INT 0
64053: PUSH
64054: LD_INT 2
64056: NEG
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: PUSH
64062: LD_INT 1
64064: PUSH
64065: LD_INT 1
64067: NEG
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 2
64075: PUSH
64076: LD_INT 0
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: PUSH
64083: LD_INT 2
64085: PUSH
64086: LD_INT 1
64088: PUSH
64089: EMPTY
64090: LIST
64091: LIST
64092: PUSH
64093: LD_INT 2
64095: PUSH
64096: LD_INT 2
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: PUSH
64103: LD_INT 1
64105: PUSH
64106: LD_INT 2
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: LD_INT 0
64115: PUSH
64116: LD_INT 2
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PUSH
64123: LD_INT 1
64125: NEG
64126: PUSH
64127: LD_INT 1
64129: PUSH
64130: EMPTY
64131: LIST
64132: LIST
64133: PUSH
64134: LD_INT 2
64136: NEG
64137: PUSH
64138: LD_INT 0
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PUSH
64145: LD_INT 2
64147: NEG
64148: PUSH
64149: LD_INT 1
64151: NEG
64152: PUSH
64153: EMPTY
64154: LIST
64155: LIST
64156: PUSH
64157: LD_INT 2
64159: NEG
64160: PUSH
64161: LD_INT 2
64163: NEG
64164: PUSH
64165: EMPTY
64166: LIST
64167: LIST
64168: PUSH
64169: LD_INT 2
64171: NEG
64172: PUSH
64173: LD_INT 3
64175: NEG
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: PUSH
64181: LD_INT 1
64183: NEG
64184: PUSH
64185: LD_INT 3
64187: NEG
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 1
64195: PUSH
64196: LD_INT 2
64198: NEG
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: PUSH
64204: LD_INT 2
64206: PUSH
64207: LD_INT 1
64209: NEG
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
64240: LD_ADDR_VAR 0 24
64244: PUSH
64245: LD_INT 0
64247: PUSH
64248: LD_INT 0
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: LD_INT 0
64257: PUSH
64258: LD_INT 1
64260: NEG
64261: PUSH
64262: EMPTY
64263: LIST
64264: LIST
64265: PUSH
64266: LD_INT 1
64268: PUSH
64269: LD_INT 0
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: PUSH
64276: LD_INT 1
64278: PUSH
64279: LD_INT 1
64281: PUSH
64282: EMPTY
64283: LIST
64284: LIST
64285: PUSH
64286: LD_INT 0
64288: PUSH
64289: LD_INT 1
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: PUSH
64296: LD_INT 1
64298: NEG
64299: PUSH
64300: LD_INT 0
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: PUSH
64307: LD_INT 1
64309: NEG
64310: PUSH
64311: LD_INT 1
64313: NEG
64314: PUSH
64315: EMPTY
64316: LIST
64317: LIST
64318: PUSH
64319: LD_INT 1
64321: NEG
64322: PUSH
64323: LD_INT 2
64325: NEG
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 0
64333: PUSH
64334: LD_INT 2
64336: NEG
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: LD_INT 1
64344: PUSH
64345: LD_INT 1
64347: NEG
64348: PUSH
64349: EMPTY
64350: LIST
64351: LIST
64352: PUSH
64353: LD_INT 2
64355: PUSH
64356: LD_INT 0
64358: PUSH
64359: EMPTY
64360: LIST
64361: LIST
64362: PUSH
64363: LD_INT 2
64365: PUSH
64366: LD_INT 1
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: PUSH
64373: LD_INT 2
64375: PUSH
64376: LD_INT 2
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: PUSH
64383: LD_INT 1
64385: PUSH
64386: LD_INT 2
64388: PUSH
64389: EMPTY
64390: LIST
64391: LIST
64392: PUSH
64393: LD_INT 0
64395: PUSH
64396: LD_INT 2
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: PUSH
64403: LD_INT 1
64405: NEG
64406: PUSH
64407: LD_INT 1
64409: PUSH
64410: EMPTY
64411: LIST
64412: LIST
64413: PUSH
64414: LD_INT 2
64416: NEG
64417: PUSH
64418: LD_INT 0
64420: PUSH
64421: EMPTY
64422: LIST
64423: LIST
64424: PUSH
64425: LD_INT 2
64427: NEG
64428: PUSH
64429: LD_INT 1
64431: NEG
64432: PUSH
64433: EMPTY
64434: LIST
64435: LIST
64436: PUSH
64437: LD_INT 2
64439: NEG
64440: PUSH
64441: LD_INT 2
64443: NEG
64444: PUSH
64445: EMPTY
64446: LIST
64447: LIST
64448: PUSH
64449: LD_INT 1
64451: PUSH
64452: LD_INT 2
64454: NEG
64455: PUSH
64456: EMPTY
64457: LIST
64458: LIST
64459: PUSH
64460: LD_INT 2
64462: PUSH
64463: LD_INT 1
64465: NEG
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: PUSH
64471: LD_INT 3
64473: PUSH
64474: LD_INT 1
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: LD_INT 3
64483: PUSH
64484: LD_INT 2
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
64516: LD_ADDR_VAR 0 25
64520: PUSH
64521: LD_INT 0
64523: PUSH
64524: LD_INT 0
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: LD_INT 0
64533: PUSH
64534: LD_INT 1
64536: NEG
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: PUSH
64542: LD_INT 1
64544: PUSH
64545: LD_INT 0
64547: PUSH
64548: EMPTY
64549: LIST
64550: LIST
64551: PUSH
64552: LD_INT 1
64554: PUSH
64555: LD_INT 1
64557: PUSH
64558: EMPTY
64559: LIST
64560: LIST
64561: PUSH
64562: LD_INT 0
64564: PUSH
64565: LD_INT 1
64567: PUSH
64568: EMPTY
64569: LIST
64570: LIST
64571: PUSH
64572: LD_INT 1
64574: NEG
64575: PUSH
64576: LD_INT 0
64578: PUSH
64579: EMPTY
64580: LIST
64581: LIST
64582: PUSH
64583: LD_INT 1
64585: NEG
64586: PUSH
64587: LD_INT 1
64589: NEG
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: LD_INT 1
64597: NEG
64598: PUSH
64599: LD_INT 2
64601: NEG
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 0
64609: PUSH
64610: LD_INT 2
64612: NEG
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: LD_INT 1
64620: PUSH
64621: LD_INT 1
64623: NEG
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: LD_INT 2
64631: PUSH
64632: LD_INT 0
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 2
64641: PUSH
64642: LD_INT 1
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 2
64651: PUSH
64652: LD_INT 2
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PUSH
64659: LD_INT 1
64661: PUSH
64662: LD_INT 2
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PUSH
64669: LD_INT 0
64671: PUSH
64672: LD_INT 2
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: PUSH
64679: LD_INT 1
64681: NEG
64682: PUSH
64683: LD_INT 1
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 2
64692: NEG
64693: PUSH
64694: LD_INT 0
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: PUSH
64701: LD_INT 2
64703: NEG
64704: PUSH
64705: LD_INT 1
64707: NEG
64708: PUSH
64709: EMPTY
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 2
64715: NEG
64716: PUSH
64717: LD_INT 2
64719: NEG
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 3
64727: PUSH
64728: LD_INT 1
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: PUSH
64735: LD_INT 3
64737: PUSH
64738: LD_INT 2
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 2
64747: PUSH
64748: LD_INT 3
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: LD_INT 1
64757: PUSH
64758: LD_INT 3
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: EMPTY
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: LIST
64787: LIST
64788: LIST
64789: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
64790: LD_ADDR_VAR 0 26
64794: PUSH
64795: LD_INT 0
64797: PUSH
64798: LD_INT 0
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 0
64807: PUSH
64808: LD_INT 1
64810: NEG
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: LD_INT 0
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 1
64828: PUSH
64829: LD_INT 1
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: PUSH
64836: LD_INT 0
64838: PUSH
64839: LD_INT 1
64841: PUSH
64842: EMPTY
64843: LIST
64844: LIST
64845: PUSH
64846: LD_INT 1
64848: NEG
64849: PUSH
64850: LD_INT 0
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 1
64859: NEG
64860: PUSH
64861: LD_INT 1
64863: NEG
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 1
64871: NEG
64872: PUSH
64873: LD_INT 2
64875: NEG
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 0
64883: PUSH
64884: LD_INT 2
64886: NEG
64887: PUSH
64888: EMPTY
64889: LIST
64890: LIST
64891: PUSH
64892: LD_INT 1
64894: PUSH
64895: LD_INT 1
64897: NEG
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 2
64905: PUSH
64906: LD_INT 0
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 2
64915: PUSH
64916: LD_INT 1
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: LD_INT 2
64925: PUSH
64926: LD_INT 2
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 1
64935: PUSH
64936: LD_INT 2
64938: PUSH
64939: EMPTY
64940: LIST
64941: LIST
64942: PUSH
64943: LD_INT 0
64945: PUSH
64946: LD_INT 2
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PUSH
64953: LD_INT 1
64955: NEG
64956: PUSH
64957: LD_INT 1
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: PUSH
64964: LD_INT 2
64966: NEG
64967: PUSH
64968: LD_INT 0
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: LD_INT 2
64977: NEG
64978: PUSH
64979: LD_INT 1
64981: NEG
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 2
64989: NEG
64990: PUSH
64991: LD_INT 2
64993: NEG
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: LD_INT 2
65001: PUSH
65002: LD_INT 3
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PUSH
65009: LD_INT 1
65011: PUSH
65012: LD_INT 3
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: LD_INT 1
65021: NEG
65022: PUSH
65023: LD_INT 2
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 2
65032: NEG
65033: PUSH
65034: LD_INT 1
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: LIST
65045: LIST
65046: LIST
65047: LIST
65048: LIST
65049: LIST
65050: LIST
65051: LIST
65052: LIST
65053: LIST
65054: LIST
65055: LIST
65056: LIST
65057: LIST
65058: LIST
65059: LIST
65060: LIST
65061: LIST
65062: LIST
65063: LIST
65064: LIST
65065: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65066: LD_ADDR_VAR 0 27
65070: PUSH
65071: LD_INT 0
65073: PUSH
65074: LD_INT 0
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PUSH
65081: LD_INT 0
65083: PUSH
65084: LD_INT 1
65086: NEG
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 1
65094: PUSH
65095: LD_INT 0
65097: PUSH
65098: EMPTY
65099: LIST
65100: LIST
65101: PUSH
65102: LD_INT 1
65104: PUSH
65105: LD_INT 1
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: LD_INT 0
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 1
65124: NEG
65125: PUSH
65126: LD_INT 0
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 1
65135: NEG
65136: PUSH
65137: LD_INT 1
65139: NEG
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 1
65147: NEG
65148: PUSH
65149: LD_INT 2
65151: NEG
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: LD_INT 0
65159: PUSH
65160: LD_INT 2
65162: NEG
65163: PUSH
65164: EMPTY
65165: LIST
65166: LIST
65167: PUSH
65168: LD_INT 1
65170: PUSH
65171: LD_INT 1
65173: NEG
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: PUSH
65179: LD_INT 2
65181: PUSH
65182: LD_INT 0
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PUSH
65189: LD_INT 2
65191: PUSH
65192: LD_INT 1
65194: PUSH
65195: EMPTY
65196: LIST
65197: LIST
65198: PUSH
65199: LD_INT 2
65201: PUSH
65202: LD_INT 2
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PUSH
65209: LD_INT 1
65211: PUSH
65212: LD_INT 2
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: PUSH
65219: LD_INT 0
65221: PUSH
65222: LD_INT 2
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PUSH
65229: LD_INT 1
65231: NEG
65232: PUSH
65233: LD_INT 1
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: LD_INT 2
65242: NEG
65243: PUSH
65244: LD_INT 0
65246: PUSH
65247: EMPTY
65248: LIST
65249: LIST
65250: PUSH
65251: LD_INT 2
65253: NEG
65254: PUSH
65255: LD_INT 1
65257: NEG
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: PUSH
65263: LD_INT 2
65265: NEG
65266: PUSH
65267: LD_INT 2
65269: NEG
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 1
65277: NEG
65278: PUSH
65279: LD_INT 2
65281: PUSH
65282: EMPTY
65283: LIST
65284: LIST
65285: PUSH
65286: LD_INT 2
65288: NEG
65289: PUSH
65290: LD_INT 1
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 3
65299: NEG
65300: PUSH
65301: LD_INT 1
65303: NEG
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 3
65311: NEG
65312: PUSH
65313: LD_INT 2
65315: NEG
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65346: LD_ADDR_VAR 0 28
65350: PUSH
65351: LD_INT 0
65353: PUSH
65354: LD_INT 0
65356: PUSH
65357: EMPTY
65358: LIST
65359: LIST
65360: PUSH
65361: LD_INT 0
65363: PUSH
65364: LD_INT 1
65366: NEG
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PUSH
65372: LD_INT 1
65374: PUSH
65375: LD_INT 0
65377: PUSH
65378: EMPTY
65379: LIST
65380: LIST
65381: PUSH
65382: LD_INT 1
65384: PUSH
65385: LD_INT 1
65387: PUSH
65388: EMPTY
65389: LIST
65390: LIST
65391: PUSH
65392: LD_INT 0
65394: PUSH
65395: LD_INT 1
65397: PUSH
65398: EMPTY
65399: LIST
65400: LIST
65401: PUSH
65402: LD_INT 1
65404: NEG
65405: PUSH
65406: LD_INT 0
65408: PUSH
65409: EMPTY
65410: LIST
65411: LIST
65412: PUSH
65413: LD_INT 1
65415: NEG
65416: PUSH
65417: LD_INT 1
65419: NEG
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: PUSH
65425: LD_INT 1
65427: NEG
65428: PUSH
65429: LD_INT 2
65431: NEG
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 0
65439: PUSH
65440: LD_INT 2
65442: NEG
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: PUSH
65451: LD_INT 1
65453: NEG
65454: PUSH
65455: EMPTY
65456: LIST
65457: LIST
65458: PUSH
65459: LD_INT 2
65461: PUSH
65462: LD_INT 0
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: PUSH
65469: LD_INT 2
65471: PUSH
65472: LD_INT 1
65474: PUSH
65475: EMPTY
65476: LIST
65477: LIST
65478: PUSH
65479: LD_INT 2
65481: PUSH
65482: LD_INT 2
65484: PUSH
65485: EMPTY
65486: LIST
65487: LIST
65488: PUSH
65489: LD_INT 1
65491: PUSH
65492: LD_INT 2
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 0
65501: PUSH
65502: LD_INT 2
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 1
65511: NEG
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PUSH
65520: LD_INT 2
65522: NEG
65523: PUSH
65524: LD_INT 0
65526: PUSH
65527: EMPTY
65528: LIST
65529: LIST
65530: PUSH
65531: LD_INT 2
65533: NEG
65534: PUSH
65535: LD_INT 1
65537: NEG
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: PUSH
65543: LD_INT 2
65545: NEG
65546: PUSH
65547: LD_INT 2
65549: NEG
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PUSH
65555: LD_INT 2
65557: NEG
65558: PUSH
65559: LD_INT 3
65561: NEG
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: PUSH
65567: LD_INT 1
65569: NEG
65570: PUSH
65571: LD_INT 3
65573: NEG
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PUSH
65579: LD_INT 3
65581: NEG
65582: PUSH
65583: LD_INT 1
65585: NEG
65586: PUSH
65587: EMPTY
65588: LIST
65589: LIST
65590: PUSH
65591: LD_INT 3
65593: NEG
65594: PUSH
65595: LD_INT 2
65597: NEG
65598: PUSH
65599: EMPTY
65600: LIST
65601: LIST
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65628: LD_ADDR_VAR 0 29
65632: PUSH
65633: LD_INT 0
65635: PUSH
65636: LD_INT 0
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: PUSH
65643: LD_INT 0
65645: PUSH
65646: LD_INT 1
65648: NEG
65649: PUSH
65650: EMPTY
65651: LIST
65652: LIST
65653: PUSH
65654: LD_INT 1
65656: PUSH
65657: LD_INT 0
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 1
65666: PUSH
65667: LD_INT 1
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 0
65676: PUSH
65677: LD_INT 1
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: PUSH
65684: LD_INT 1
65686: NEG
65687: PUSH
65688: LD_INT 0
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: LD_INT 1
65697: NEG
65698: PUSH
65699: LD_INT 1
65701: NEG
65702: PUSH
65703: EMPTY
65704: LIST
65705: LIST
65706: PUSH
65707: LD_INT 1
65709: NEG
65710: PUSH
65711: LD_INT 2
65713: NEG
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 0
65721: PUSH
65722: LD_INT 2
65724: NEG
65725: PUSH
65726: EMPTY
65727: LIST
65728: LIST
65729: PUSH
65730: LD_INT 1
65732: PUSH
65733: LD_INT 1
65735: NEG
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: LD_INT 2
65743: PUSH
65744: LD_INT 0
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: PUSH
65751: LD_INT 2
65753: PUSH
65754: LD_INT 1
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PUSH
65761: LD_INT 1
65763: PUSH
65764: LD_INT 2
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: PUSH
65771: LD_INT 0
65773: PUSH
65774: LD_INT 2
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: LD_INT 1
65783: NEG
65784: PUSH
65785: LD_INT 1
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 2
65794: NEG
65795: PUSH
65796: LD_INT 1
65798: NEG
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: PUSH
65804: LD_INT 2
65806: NEG
65807: PUSH
65808: LD_INT 2
65810: NEG
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: PUSH
65816: LD_INT 2
65818: NEG
65819: PUSH
65820: LD_INT 3
65822: NEG
65823: PUSH
65824: EMPTY
65825: LIST
65826: LIST
65827: PUSH
65828: LD_INT 2
65830: PUSH
65831: LD_INT 1
65833: NEG
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: PUSH
65839: LD_INT 3
65841: PUSH
65842: LD_INT 1
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 1
65851: PUSH
65852: LD_INT 3
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: LD_INT 1
65861: NEG
65862: PUSH
65863: LD_INT 2
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 3
65872: NEG
65873: PUSH
65874: LD_INT 2
65876: NEG
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65907: LD_ADDR_VAR 0 30
65911: PUSH
65912: LD_INT 0
65914: PUSH
65915: LD_INT 0
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 0
65924: PUSH
65925: LD_INT 1
65927: NEG
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: PUSH
65933: LD_INT 1
65935: PUSH
65936: LD_INT 0
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: PUSH
65943: LD_INT 1
65945: PUSH
65946: LD_INT 1
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: PUSH
65953: LD_INT 0
65955: PUSH
65956: LD_INT 1
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PUSH
65963: LD_INT 1
65965: NEG
65966: PUSH
65967: LD_INT 0
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 1
65976: NEG
65977: PUSH
65978: LD_INT 1
65980: NEG
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: LD_INT 1
65988: NEG
65989: PUSH
65990: LD_INT 2
65992: NEG
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PUSH
65998: LD_INT 0
66000: PUSH
66001: LD_INT 2
66003: NEG
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: LD_INT 1
66014: NEG
66015: PUSH
66016: EMPTY
66017: LIST
66018: LIST
66019: PUSH
66020: LD_INT 2
66022: PUSH
66023: LD_INT 0
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: PUSH
66030: LD_INT 2
66032: PUSH
66033: LD_INT 1
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PUSH
66040: LD_INT 2
66042: PUSH
66043: LD_INT 2
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 1
66052: PUSH
66053: LD_INT 2
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 1
66062: NEG
66063: PUSH
66064: LD_INT 1
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 2
66073: NEG
66074: PUSH
66075: LD_INT 0
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 2
66084: NEG
66085: PUSH
66086: LD_INT 1
66088: NEG
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PUSH
66094: LD_INT 1
66096: NEG
66097: PUSH
66098: LD_INT 3
66100: NEG
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 1
66108: PUSH
66109: LD_INT 2
66111: NEG
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 3
66119: PUSH
66120: LD_INT 2
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 2
66129: PUSH
66130: LD_INT 3
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 2
66139: NEG
66140: PUSH
66141: LD_INT 1
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: LD_INT 3
66150: NEG
66151: PUSH
66152: LD_INT 1
66154: NEG
66155: PUSH
66156: EMPTY
66157: LIST
66158: LIST
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66185: LD_ADDR_VAR 0 31
66189: PUSH
66190: LD_INT 0
66192: PUSH
66193: LD_INT 0
66195: PUSH
66196: EMPTY
66197: LIST
66198: LIST
66199: PUSH
66200: LD_INT 0
66202: PUSH
66203: LD_INT 1
66205: NEG
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 1
66213: PUSH
66214: LD_INT 0
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: LD_INT 1
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: PUSH
66231: LD_INT 0
66233: PUSH
66234: LD_INT 1
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 1
66243: NEG
66244: PUSH
66245: LD_INT 0
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: LD_INT 1
66254: NEG
66255: PUSH
66256: LD_INT 1
66258: NEG
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 1
66266: NEG
66267: PUSH
66268: LD_INT 2
66270: NEG
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: PUSH
66276: LD_INT 1
66278: PUSH
66279: LD_INT 1
66281: NEG
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 2
66289: PUSH
66290: LD_INT 0
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: LD_INT 2
66299: PUSH
66300: LD_INT 1
66302: PUSH
66303: EMPTY
66304: LIST
66305: LIST
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: LD_INT 2
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PUSH
66317: LD_INT 1
66319: PUSH
66320: LD_INT 2
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 0
66329: PUSH
66330: LD_INT 2
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 1
66339: NEG
66340: PUSH
66341: LD_INT 1
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 2
66350: NEG
66351: PUSH
66352: LD_INT 1
66354: NEG
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: LD_INT 2
66362: NEG
66363: PUSH
66364: LD_INT 2
66366: NEG
66367: PUSH
66368: EMPTY
66369: LIST
66370: LIST
66371: PUSH
66372: LD_INT 2
66374: NEG
66375: PUSH
66376: LD_INT 3
66378: NEG
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: PUSH
66384: LD_INT 2
66386: PUSH
66387: LD_INT 1
66389: NEG
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 3
66397: PUSH
66398: LD_INT 1
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 1
66407: PUSH
66408: LD_INT 3
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: LD_INT 1
66417: NEG
66418: PUSH
66419: LD_INT 2
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: PUSH
66426: LD_INT 3
66428: NEG
66429: PUSH
66430: LD_INT 2
66432: NEG
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66463: LD_ADDR_VAR 0 32
66467: PUSH
66468: LD_INT 0
66470: PUSH
66471: LD_INT 0
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 0
66480: PUSH
66481: LD_INT 1
66483: NEG
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 1
66491: PUSH
66492: LD_INT 0
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 1
66501: PUSH
66502: LD_INT 1
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PUSH
66509: LD_INT 0
66511: PUSH
66512: LD_INT 1
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 1
66521: NEG
66522: PUSH
66523: LD_INT 0
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: LD_INT 1
66532: NEG
66533: PUSH
66534: LD_INT 1
66536: NEG
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 1
66544: NEG
66545: PUSH
66546: LD_INT 2
66548: NEG
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 0
66556: PUSH
66557: LD_INT 2
66559: NEG
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 1
66567: PUSH
66568: LD_INT 1
66570: NEG
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 2
66578: PUSH
66579: LD_INT 1
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 2
66588: PUSH
66589: LD_INT 2
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: PUSH
66596: LD_INT 1
66598: PUSH
66599: LD_INT 2
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: PUSH
66606: LD_INT 0
66608: PUSH
66609: LD_INT 2
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: NEG
66619: PUSH
66620: LD_INT 1
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 2
66629: NEG
66630: PUSH
66631: LD_INT 0
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 2
66640: NEG
66641: PUSH
66642: LD_INT 1
66644: NEG
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 1
66652: NEG
66653: PUSH
66654: LD_INT 3
66656: NEG
66657: PUSH
66658: EMPTY
66659: LIST
66660: LIST
66661: PUSH
66662: LD_INT 1
66664: PUSH
66665: LD_INT 2
66667: NEG
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 3
66675: PUSH
66676: LD_INT 2
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 2
66685: PUSH
66686: LD_INT 3
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: PUSH
66693: LD_INT 2
66695: NEG
66696: PUSH
66697: LD_INT 1
66699: PUSH
66700: EMPTY
66701: LIST
66702: LIST
66703: PUSH
66704: LD_INT 3
66706: NEG
66707: PUSH
66708: LD_INT 1
66710: NEG
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66741: LD_ADDR_VAR 0 33
66745: PUSH
66746: LD_INT 0
66748: PUSH
66749: LD_INT 0
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 0
66758: PUSH
66759: LD_INT 1
66761: NEG
66762: PUSH
66763: EMPTY
66764: LIST
66765: LIST
66766: PUSH
66767: LD_INT 1
66769: PUSH
66770: LD_INT 0
66772: PUSH
66773: EMPTY
66774: LIST
66775: LIST
66776: PUSH
66777: LD_INT 1
66779: PUSH
66780: LD_INT 1
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 0
66789: PUSH
66790: LD_INT 1
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: PUSH
66797: LD_INT 1
66799: NEG
66800: PUSH
66801: LD_INT 0
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 1
66810: NEG
66811: PUSH
66812: LD_INT 1
66814: NEG
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 1
66822: NEG
66823: PUSH
66824: LD_INT 2
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: LD_INT 1
66837: NEG
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: PUSH
66843: LD_INT 2
66845: PUSH
66846: LD_INT 0
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: PUSH
66853: LD_INT 2
66855: PUSH
66856: LD_INT 1
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 1
66865: PUSH
66866: LD_INT 2
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 0
66875: PUSH
66876: LD_INT 2
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 1
66885: NEG
66886: PUSH
66887: LD_INT 1
66889: PUSH
66890: EMPTY
66891: LIST
66892: LIST
66893: PUSH
66894: LD_INT 2
66896: NEG
66897: PUSH
66898: LD_INT 0
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 2
66907: NEG
66908: PUSH
66909: LD_INT 1
66911: NEG
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 2
66919: NEG
66920: PUSH
66921: LD_INT 2
66923: NEG
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 2
66931: NEG
66932: PUSH
66933: LD_INT 3
66935: NEG
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 2
66943: PUSH
66944: LD_INT 1
66946: NEG
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 3
66954: PUSH
66955: LD_INT 1
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 1
66964: PUSH
66965: LD_INT 3
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: LD_INT 2
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 3
66985: NEG
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67020: LD_ADDR_VAR 0 34
67024: PUSH
67025: LD_INT 0
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: LD_INT 0
67037: PUSH
67038: LD_INT 1
67040: NEG
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PUSH
67046: LD_INT 1
67048: PUSH
67049: LD_INT 0
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 1
67058: PUSH
67059: LD_INT 1
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 1
67089: NEG
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 1
67101: NEG
67102: PUSH
67103: LD_INT 2
67105: NEG
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 0
67113: PUSH
67114: LD_INT 2
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 1
67124: PUSH
67125: LD_INT 1
67127: NEG
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: LD_INT 2
67135: PUSH
67136: LD_INT 1
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 2
67145: PUSH
67146: LD_INT 2
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 1
67155: PUSH
67156: LD_INT 2
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 1
67165: NEG
67166: PUSH
67167: LD_INT 1
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 2
67176: NEG
67177: PUSH
67178: LD_INT 0
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 2
67187: NEG
67188: PUSH
67189: LD_INT 1
67191: NEG
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 2
67199: NEG
67200: PUSH
67201: LD_INT 2
67203: NEG
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 1
67211: NEG
67212: PUSH
67213: LD_INT 3
67215: NEG
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 1
67223: PUSH
67224: LD_INT 2
67226: NEG
67227: PUSH
67228: EMPTY
67229: LIST
67230: LIST
67231: PUSH
67232: LD_INT 3
67234: PUSH
67235: LD_INT 2
67237: PUSH
67238: EMPTY
67239: LIST
67240: LIST
67241: PUSH
67242: LD_INT 2
67244: PUSH
67245: LD_INT 3
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 2
67254: NEG
67255: PUSH
67256: LD_INT 1
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 3
67265: NEG
67266: PUSH
67267: LD_INT 1
67269: NEG
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67300: LD_ADDR_VAR 0 35
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: LD_INT 0
67310: PUSH
67311: EMPTY
67312: LIST
67313: LIST
67314: PUSH
67315: LD_INT 0
67317: PUSH
67318: LD_INT 1
67320: NEG
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: LD_INT 0
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 1
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 0
67348: PUSH
67349: LD_INT 1
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: PUSH
67356: LD_INT 1
67358: NEG
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: LD_INT 1
67369: NEG
67370: PUSH
67371: LD_INT 1
67373: NEG
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: LD_INT 2
67381: PUSH
67382: LD_INT 1
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 2
67391: NEG
67392: PUSH
67393: LD_INT 1
67395: NEG
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: LIST
67405: LIST
67406: LIST
67407: LIST
67408: LIST
67409: LIST
67410: LIST
67411: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67412: LD_ADDR_VAR 0 36
67416: PUSH
67417: LD_INT 0
67419: PUSH
67420: LD_INT 0
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 0
67429: PUSH
67430: LD_INT 1
67432: NEG
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: LD_INT 0
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: PUSH
67448: LD_INT 1
67450: PUSH
67451: LD_INT 1
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: LD_INT 0
67460: PUSH
67461: LD_INT 1
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: PUSH
67468: LD_INT 1
67470: NEG
67471: PUSH
67472: LD_INT 0
67474: PUSH
67475: EMPTY
67476: LIST
67477: LIST
67478: PUSH
67479: LD_INT 1
67481: NEG
67482: PUSH
67483: LD_INT 1
67485: NEG
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 1
67493: NEG
67494: PUSH
67495: LD_INT 2
67497: NEG
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 1
67505: PUSH
67506: LD_INT 2
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67524: LD_ADDR_VAR 0 37
67528: PUSH
67529: LD_INT 0
67531: PUSH
67532: LD_INT 0
67534: PUSH
67535: EMPTY
67536: LIST
67537: LIST
67538: PUSH
67539: LD_INT 0
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: LD_INT 0
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 1
67562: PUSH
67563: LD_INT 1
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 0
67572: PUSH
67573: LD_INT 1
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PUSH
67580: LD_INT 1
67582: NEG
67583: PUSH
67584: LD_INT 0
67586: PUSH
67587: EMPTY
67588: LIST
67589: LIST
67590: PUSH
67591: LD_INT 1
67593: NEG
67594: PUSH
67595: LD_INT 1
67597: NEG
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: PUSH
67603: LD_INT 1
67605: PUSH
67606: LD_INT 1
67608: NEG
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: PUSH
67614: LD_INT 1
67616: NEG
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67636: LD_ADDR_VAR 0 38
67640: PUSH
67641: LD_INT 0
67643: PUSH
67644: LD_INT 0
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 0
67653: PUSH
67654: LD_INT 1
67656: NEG
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 1
67664: PUSH
67665: LD_INT 0
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 1
67674: PUSH
67675: LD_INT 1
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: LD_INT 1
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 1
67694: NEG
67695: PUSH
67696: LD_INT 0
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 1
67705: NEG
67706: PUSH
67707: LD_INT 1
67709: NEG
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 2
67717: PUSH
67718: LD_INT 1
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 2
67727: NEG
67728: PUSH
67729: LD_INT 1
67731: NEG
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: LIST
67747: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67748: LD_ADDR_VAR 0 39
67752: PUSH
67753: LD_INT 0
67755: PUSH
67756: LD_INT 0
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: LD_INT 0
67765: PUSH
67766: LD_INT 1
67768: NEG
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 1
67776: PUSH
67777: LD_INT 0
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: PUSH
67787: LD_INT 1
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PUSH
67794: LD_INT 0
67796: PUSH
67797: LD_INT 1
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 1
67806: NEG
67807: PUSH
67808: LD_INT 0
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 1
67817: NEG
67818: PUSH
67819: LD_INT 1
67821: NEG
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: LD_INT 1
67829: NEG
67830: PUSH
67831: LD_INT 2
67833: NEG
67834: PUSH
67835: EMPTY
67836: LIST
67837: LIST
67838: PUSH
67839: LD_INT 1
67841: PUSH
67842: LD_INT 2
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67860: LD_ADDR_VAR 0 40
67864: PUSH
67865: LD_INT 0
67867: PUSH
67868: LD_INT 0
67870: PUSH
67871: EMPTY
67872: LIST
67873: LIST
67874: PUSH
67875: LD_INT 0
67877: PUSH
67878: LD_INT 1
67880: NEG
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: LD_INT 1
67888: PUSH
67889: LD_INT 0
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 1
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 0
67908: PUSH
67909: LD_INT 1
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: LD_INT 1
67918: NEG
67919: PUSH
67920: LD_INT 0
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: LD_INT 1
67929: NEG
67930: PUSH
67931: LD_INT 1
67933: NEG
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 1
67941: PUSH
67942: LD_INT 1
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 1
67952: NEG
67953: PUSH
67954: LD_INT 1
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67972: LD_ADDR_VAR 0 41
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: LD_INT 0
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PUSH
67987: LD_INT 0
67989: PUSH
67990: LD_INT 1
67992: NEG
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 1
68000: PUSH
68001: LD_INT 0
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 1
68010: PUSH
68011: LD_INT 1
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 0
68020: PUSH
68021: LD_INT 1
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 1
68030: NEG
68031: PUSH
68032: LD_INT 0
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 1
68041: NEG
68042: PUSH
68043: LD_INT 1
68045: NEG
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: LD_INT 1
68053: NEG
68054: PUSH
68055: LD_INT 2
68057: NEG
68058: PUSH
68059: EMPTY
68060: LIST
68061: LIST
68062: PUSH
68063: LD_INT 1
68065: PUSH
68066: LD_INT 1
68068: NEG
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 2
68076: PUSH
68077: LD_INT 0
68079: PUSH
68080: EMPTY
68081: LIST
68082: LIST
68083: PUSH
68084: LD_INT 2
68086: PUSH
68087: LD_INT 1
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 2
68096: PUSH
68097: LD_INT 2
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: LD_INT 1
68106: PUSH
68107: LD_INT 2
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 1
68116: NEG
68117: PUSH
68118: LD_INT 1
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 2
68127: NEG
68128: PUSH
68129: LD_INT 0
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 2
68138: NEG
68139: PUSH
68140: LD_INT 1
68142: NEG
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 2
68150: NEG
68151: PUSH
68152: LD_INT 2
68154: NEG
68155: PUSH
68156: EMPTY
68157: LIST
68158: LIST
68159: PUSH
68160: LD_INT 2
68162: NEG
68163: PUSH
68164: LD_INT 3
68166: NEG
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 2
68174: PUSH
68175: LD_INT 1
68177: NEG
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 3
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 3
68195: PUSH
68196: LD_INT 1
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: LD_INT 3
68205: PUSH
68206: LD_INT 2
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: LD_INT 3
68215: PUSH
68216: LD_INT 3
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 2
68225: PUSH
68226: LD_INT 3
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: PUSH
68233: LD_INT 2
68235: NEG
68236: PUSH
68237: LD_INT 1
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 3
68246: NEG
68247: PUSH
68248: LD_INT 0
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 3
68257: NEG
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 3
68269: NEG
68270: PUSH
68271: LD_INT 2
68273: NEG
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 3
68281: NEG
68282: PUSH
68283: LD_INT 3
68285: NEG
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68322: LD_ADDR_VAR 0 42
68326: PUSH
68327: LD_INT 0
68329: PUSH
68330: LD_INT 0
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 0
68339: PUSH
68340: LD_INT 1
68342: NEG
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: PUSH
68348: LD_INT 1
68350: PUSH
68351: LD_INT 0
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: PUSH
68358: LD_INT 1
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 0
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 1
68380: NEG
68381: PUSH
68382: LD_INT 0
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 1
68391: NEG
68392: PUSH
68393: LD_INT 1
68395: NEG
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 1
68403: NEG
68404: PUSH
68405: LD_INT 2
68407: NEG
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: LD_INT 2
68418: NEG
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 1
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 2
68437: PUSH
68438: LD_INT 1
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: LD_INT 2
68447: PUSH
68448: LD_INT 2
68450: PUSH
68451: EMPTY
68452: LIST
68453: LIST
68454: PUSH
68455: LD_INT 1
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: LD_INT 2
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 1
68477: NEG
68478: PUSH
68479: LD_INT 1
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 2
68488: NEG
68489: PUSH
68490: LD_INT 1
68492: NEG
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 2
68500: NEG
68501: PUSH
68502: LD_INT 2
68504: NEG
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 2
68512: NEG
68513: PUSH
68514: LD_INT 3
68516: NEG
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 1
68524: NEG
68525: PUSH
68526: LD_INT 3
68528: NEG
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 0
68536: PUSH
68537: LD_INT 3
68539: NEG
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 1
68547: PUSH
68548: LD_INT 2
68550: NEG
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 3
68558: PUSH
68559: LD_INT 2
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: LD_INT 3
68568: PUSH
68569: LD_INT 3
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 2
68578: PUSH
68579: LD_INT 3
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 1
68588: PUSH
68589: LD_INT 3
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 0
68598: PUSH
68599: LD_INT 3
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: PUSH
68606: LD_INT 1
68608: NEG
68609: PUSH
68610: LD_INT 2
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 3
68619: NEG
68620: PUSH
68621: LD_INT 2
68623: NEG
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 3
68631: NEG
68632: PUSH
68633: LD_INT 3
68635: NEG
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: LIST
68652: LIST
68653: LIST
68654: LIST
68655: LIST
68656: LIST
68657: LIST
68658: LIST
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68672: LD_ADDR_VAR 0 43
68676: PUSH
68677: LD_INT 0
68679: PUSH
68680: LD_INT 0
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 0
68689: PUSH
68690: LD_INT 1
68692: NEG
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 1
68700: PUSH
68701: LD_INT 0
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 1
68710: PUSH
68711: LD_INT 1
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 0
68720: PUSH
68721: LD_INT 1
68723: PUSH
68724: EMPTY
68725: LIST
68726: LIST
68727: PUSH
68728: LD_INT 1
68730: NEG
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 1
68741: NEG
68742: PUSH
68743: LD_INT 1
68745: NEG
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 1
68753: NEG
68754: PUSH
68755: LD_INT 2
68757: NEG
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 0
68765: PUSH
68766: LD_INT 2
68768: NEG
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 1
68776: PUSH
68777: LD_INT 1
68779: NEG
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 2
68787: PUSH
68788: LD_INT 0
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 2
68797: PUSH
68798: LD_INT 1
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 1
68807: PUSH
68808: LD_INT 2
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 0
68817: PUSH
68818: LD_INT 2
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 1
68827: NEG
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 2
68838: NEG
68839: PUSH
68840: LD_INT 0
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 2
68849: NEG
68850: PUSH
68851: LD_INT 1
68853: NEG
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 1
68861: NEG
68862: PUSH
68863: LD_INT 3
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 0
68873: PUSH
68874: LD_INT 3
68876: NEG
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 1
68884: PUSH
68885: LD_INT 2
68887: NEG
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 2
68895: PUSH
68896: LD_INT 1
68898: NEG
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 3
68906: PUSH
68907: LD_INT 0
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 3
68916: PUSH
68917: LD_INT 1
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 1
68926: PUSH
68927: LD_INT 3
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 0
68936: PUSH
68937: LD_INT 3
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 1
68946: NEG
68947: PUSH
68948: LD_INT 2
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 2
68957: NEG
68958: PUSH
68959: LD_INT 1
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 3
68968: NEG
68969: PUSH
68970: LD_INT 0
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 3
68979: NEG
68980: PUSH
68981: LD_INT 1
68983: NEG
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69020: LD_ADDR_VAR 0 44
69024: PUSH
69025: LD_INT 0
69027: PUSH
69028: LD_INT 0
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 0
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 1
69048: PUSH
69049: LD_INT 0
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 1
69058: PUSH
69059: LD_INT 1
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 0
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: LD_INT 0
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 1
69089: NEG
69090: PUSH
69091: LD_INT 1
69093: NEG
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 1
69101: NEG
69102: PUSH
69103: LD_INT 2
69105: NEG
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 1
69113: PUSH
69114: LD_INT 1
69116: NEG
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 2
69124: PUSH
69125: LD_INT 0
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 2
69134: PUSH
69135: LD_INT 1
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 2
69144: PUSH
69145: LD_INT 2
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 1
69154: PUSH
69155: LD_INT 2
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 1
69164: NEG
69165: PUSH
69166: LD_INT 1
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 2
69175: NEG
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 2
69186: NEG
69187: PUSH
69188: LD_INT 1
69190: NEG
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 2
69198: NEG
69199: PUSH
69200: LD_INT 2
69202: NEG
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 2
69210: NEG
69211: PUSH
69212: LD_INT 3
69214: NEG
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 2
69222: PUSH
69223: LD_INT 1
69225: NEG
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 3
69233: PUSH
69234: LD_INT 0
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 3
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 3
69253: PUSH
69254: LD_INT 2
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: LD_INT 3
69263: PUSH
69264: LD_INT 3
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 3
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 2
69283: NEG
69284: PUSH
69285: LD_INT 1
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 3
69294: NEG
69295: PUSH
69296: LD_INT 0
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 3
69305: NEG
69306: PUSH
69307: LD_INT 1
69309: NEG
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 3
69317: NEG
69318: PUSH
69319: LD_INT 2
69321: NEG
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 3
69329: NEG
69330: PUSH
69331: LD_INT 3
69333: NEG
69334: PUSH
69335: EMPTY
69336: LIST
69337: LIST
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69370: LD_ADDR_VAR 0 45
69374: PUSH
69375: LD_INT 0
69377: PUSH
69378: LD_INT 0
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 0
69387: PUSH
69388: LD_INT 1
69390: NEG
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: LD_INT 1
69398: PUSH
69399: LD_INT 0
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 1
69408: PUSH
69409: LD_INT 1
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: PUSH
69416: LD_INT 0
69418: PUSH
69419: LD_INT 1
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 1
69428: NEG
69429: PUSH
69430: LD_INT 0
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: LD_INT 1
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: NEG
69452: PUSH
69453: LD_INT 2
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 0
69463: PUSH
69464: LD_INT 2
69466: NEG
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: LD_INT 1
69477: NEG
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: LD_INT 1
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 2
69495: PUSH
69496: LD_INT 2
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: PUSH
69503: LD_INT 1
69505: PUSH
69506: LD_INT 2
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 0
69515: PUSH
69516: LD_INT 2
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 1
69525: NEG
69526: PUSH
69527: LD_INT 1
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 2
69536: NEG
69537: PUSH
69538: LD_INT 1
69540: NEG
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: PUSH
69546: LD_INT 2
69548: NEG
69549: PUSH
69550: LD_INT 2
69552: NEG
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 2
69560: NEG
69561: PUSH
69562: LD_INT 3
69564: NEG
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 1
69572: NEG
69573: PUSH
69574: LD_INT 3
69576: NEG
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 0
69584: PUSH
69585: LD_INT 3
69587: NEG
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 1
69595: PUSH
69596: LD_INT 2
69598: NEG
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 3
69606: PUSH
69607: LD_INT 2
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 3
69616: PUSH
69617: LD_INT 3
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 2
69626: PUSH
69627: LD_INT 3
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 1
69636: PUSH
69637: LD_INT 3
69639: PUSH
69640: EMPTY
69641: LIST
69642: LIST
69643: PUSH
69644: LD_INT 0
69646: PUSH
69647: LD_INT 3
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 1
69656: NEG
69657: PUSH
69658: LD_INT 2
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 3
69667: NEG
69668: PUSH
69669: LD_INT 2
69671: NEG
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 3
69679: NEG
69680: PUSH
69681: LD_INT 3
69683: NEG
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69720: LD_ADDR_VAR 0 46
69724: PUSH
69725: LD_INT 0
69727: PUSH
69728: LD_INT 0
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 0
69737: PUSH
69738: LD_INT 1
69740: NEG
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 1
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 1
69758: PUSH
69759: LD_INT 1
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 0
69768: PUSH
69769: LD_INT 1
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 1
69778: NEG
69779: PUSH
69780: LD_INT 0
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: NEG
69790: PUSH
69791: LD_INT 1
69793: NEG
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 1
69801: NEG
69802: PUSH
69803: LD_INT 2
69805: NEG
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 0
69813: PUSH
69814: LD_INT 2
69816: NEG
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 1
69824: PUSH
69825: LD_INT 1
69827: NEG
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 2
69835: PUSH
69836: LD_INT 0
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 2
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 1
69855: PUSH
69856: LD_INT 2
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 0
69865: PUSH
69866: LD_INT 2
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 1
69875: NEG
69876: PUSH
69877: LD_INT 1
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 2
69886: NEG
69887: PUSH
69888: LD_INT 0
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 2
69897: NEG
69898: PUSH
69899: LD_INT 1
69901: NEG
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 1
69909: NEG
69910: PUSH
69911: LD_INT 3
69913: NEG
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 0
69921: PUSH
69922: LD_INT 3
69924: NEG
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 1
69932: PUSH
69933: LD_INT 2
69935: NEG
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 2
69943: PUSH
69944: LD_INT 1
69946: NEG
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 3
69954: PUSH
69955: LD_INT 0
69957: PUSH
69958: EMPTY
69959: LIST
69960: LIST
69961: PUSH
69962: LD_INT 3
69964: PUSH
69965: LD_INT 1
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: PUSH
69972: LD_INT 1
69974: PUSH
69975: LD_INT 3
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: LD_INT 3
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 1
69994: NEG
69995: PUSH
69996: LD_INT 2
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 2
70005: NEG
70006: PUSH
70007: LD_INT 1
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 3
70016: NEG
70017: PUSH
70018: LD_INT 0
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 3
70027: NEG
70028: PUSH
70029: LD_INT 1
70031: NEG
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: LIST
70055: LIST
70056: LIST
70057: LIST
70058: LIST
70059: LIST
70060: LIST
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70068: LD_ADDR_VAR 0 47
70072: PUSH
70073: LD_INT 0
70075: PUSH
70076: LD_INT 0
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 0
70085: PUSH
70086: LD_INT 1
70088: NEG
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: PUSH
70094: LD_INT 1
70096: PUSH
70097: LD_INT 0
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: LD_INT 1
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 0
70116: PUSH
70117: LD_INT 1
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: NEG
70127: PUSH
70128: LD_INT 0
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 1
70137: NEG
70138: PUSH
70139: LD_INT 1
70141: NEG
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 1
70149: NEG
70150: PUSH
70151: LD_INT 2
70153: NEG
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 0
70161: PUSH
70162: LD_INT 2
70164: NEG
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 1
70172: PUSH
70173: LD_INT 1
70175: NEG
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: NEG
70184: PUSH
70185: LD_INT 1
70187: NEG
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 2
70195: NEG
70196: PUSH
70197: LD_INT 2
70199: NEG
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
70219: LD_ADDR_VAR 0 48
70223: PUSH
70224: LD_INT 0
70226: PUSH
70227: LD_INT 0
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 0
70236: PUSH
70237: LD_INT 1
70239: NEG
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: PUSH
70245: LD_INT 1
70247: PUSH
70248: LD_INT 0
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 1
70257: PUSH
70258: LD_INT 1
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 0
70267: PUSH
70268: LD_INT 1
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: LD_INT 0
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: LD_INT 1
70288: NEG
70289: PUSH
70290: LD_INT 1
70292: NEG
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 1
70300: NEG
70301: PUSH
70302: LD_INT 2
70304: NEG
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: LD_INT 2
70315: NEG
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 1
70323: PUSH
70324: LD_INT 1
70326: NEG
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: PUSH
70332: LD_INT 2
70334: PUSH
70335: LD_INT 0
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 2
70344: PUSH
70345: LD_INT 1
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: LIST
70362: LIST
70363: LIST
70364: LIST
70365: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
70366: LD_ADDR_VAR 0 49
70370: PUSH
70371: LD_INT 0
70373: PUSH
70374: LD_INT 0
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: LD_INT 1
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: PUSH
70395: LD_INT 0
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 1
70404: PUSH
70405: LD_INT 1
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 0
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: LD_INT 1
70424: NEG
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 1
70435: NEG
70436: PUSH
70437: LD_INT 1
70439: NEG
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 1
70447: PUSH
70448: LD_INT 1
70450: NEG
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 2
70458: PUSH
70459: LD_INT 0
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 2
70468: PUSH
70469: LD_INT 1
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 2
70478: PUSH
70479: LD_INT 2
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: LD_INT 1
70488: PUSH
70489: LD_INT 2
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: LIST
70500: LIST
70501: LIST
70502: LIST
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70510: LD_ADDR_VAR 0 50
70514: PUSH
70515: LD_INT 0
70517: PUSH
70518: LD_INT 0
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 0
70527: PUSH
70528: LD_INT 1
70530: NEG
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PUSH
70536: LD_INT 1
70538: PUSH
70539: LD_INT 0
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 1
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 0
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 1
70568: NEG
70569: PUSH
70570: LD_INT 0
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: PUSH
70577: LD_INT 1
70579: NEG
70580: PUSH
70581: LD_INT 1
70583: NEG
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: LD_INT 2
70591: PUSH
70592: LD_INT 1
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 2
70601: PUSH
70602: LD_INT 2
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: PUSH
70609: LD_INT 1
70611: PUSH
70612: LD_INT 2
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 0
70621: PUSH
70622: LD_INT 2
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: NEG
70632: PUSH
70633: LD_INT 1
70635: PUSH
70636: EMPTY
70637: LIST
70638: LIST
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
70654: LD_ADDR_VAR 0 51
70658: PUSH
70659: LD_INT 0
70661: PUSH
70662: LD_INT 0
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 0
70671: PUSH
70672: LD_INT 1
70674: NEG
70675: PUSH
70676: EMPTY
70677: LIST
70678: LIST
70679: PUSH
70680: LD_INT 1
70682: PUSH
70683: LD_INT 0
70685: PUSH
70686: EMPTY
70687: LIST
70688: LIST
70689: PUSH
70690: LD_INT 1
70692: PUSH
70693: LD_INT 1
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 0
70702: PUSH
70703: LD_INT 1
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 1
70712: NEG
70713: PUSH
70714: LD_INT 0
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 1
70723: NEG
70724: PUSH
70725: LD_INT 1
70727: NEG
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 1
70735: PUSH
70736: LD_INT 2
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: LD_INT 0
70745: PUSH
70746: LD_INT 2
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: LD_INT 1
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 2
70766: NEG
70767: PUSH
70768: LD_INT 0
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 2
70777: NEG
70778: PUSH
70779: LD_INT 1
70781: NEG
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70801: LD_ADDR_VAR 0 52
70805: PUSH
70806: LD_INT 0
70808: PUSH
70809: LD_INT 0
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 0
70818: PUSH
70819: LD_INT 1
70821: NEG
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 1
70829: PUSH
70830: LD_INT 0
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 1
70839: PUSH
70840: LD_INT 1
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 0
70849: PUSH
70850: LD_INT 1
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 1
70859: NEG
70860: PUSH
70861: LD_INT 0
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 1
70870: NEG
70871: PUSH
70872: LD_INT 1
70874: NEG
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 1
70882: NEG
70883: PUSH
70884: LD_INT 2
70886: NEG
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 2
70905: NEG
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 2
70916: NEG
70917: PUSH
70918: LD_INT 1
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 2
70928: NEG
70929: PUSH
70930: LD_INT 2
70932: NEG
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70952: LD_ADDR_VAR 0 53
70956: PUSH
70957: LD_INT 0
70959: PUSH
70960: LD_INT 0
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: LD_INT 0
70969: PUSH
70970: LD_INT 1
70972: NEG
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: LD_INT 1
70980: PUSH
70981: LD_INT 0
70983: PUSH
70984: EMPTY
70985: LIST
70986: LIST
70987: PUSH
70988: LD_INT 1
70990: PUSH
70991: LD_INT 1
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 0
71000: PUSH
71001: LD_INT 1
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 1
71010: NEG
71011: PUSH
71012: LD_INT 0
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: NEG
71022: PUSH
71023: LD_INT 1
71025: NEG
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 1
71033: NEG
71034: PUSH
71035: LD_INT 2
71037: NEG
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: LD_INT 2
71048: NEG
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: LD_INT 1
71056: PUSH
71057: LD_INT 1
71059: NEG
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: LD_INT 2
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 2
71077: PUSH
71078: LD_INT 1
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 2
71087: PUSH
71088: LD_INT 2
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 1
71097: PUSH
71098: LD_INT 2
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: LD_INT 2
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: LD_INT 1
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 2
71128: NEG
71129: PUSH
71130: LD_INT 0
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 2
71139: NEG
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 2
71151: NEG
71152: PUSH
71153: LD_INT 2
71155: NEG
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: LIST
71174: LIST
71175: LIST
71176: LIST
71177: LIST
71178: LIST
71179: LIST
71180: LIST
71181: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71182: LD_ADDR_VAR 0 54
71186: PUSH
71187: LD_INT 0
71189: PUSH
71190: LD_INT 0
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 0
71199: PUSH
71200: LD_INT 1
71202: NEG
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 1
71210: PUSH
71211: LD_INT 0
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 1
71220: PUSH
71221: LD_INT 1
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: LD_INT 0
71230: PUSH
71231: LD_INT 1
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 1
71240: NEG
71241: PUSH
71242: LD_INT 0
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 1
71251: NEG
71252: PUSH
71253: LD_INT 1
71255: NEG
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 1
71263: NEG
71264: PUSH
71265: LD_INT 2
71267: NEG
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 0
71275: PUSH
71276: LD_INT 2
71278: NEG
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PUSH
71284: LD_INT 1
71286: PUSH
71287: LD_INT 1
71289: NEG
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 2
71297: PUSH
71298: LD_INT 0
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 2
71307: PUSH
71308: LD_INT 1
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 2
71317: PUSH
71318: LD_INT 2
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: LD_INT 1
71327: PUSH
71328: LD_INT 2
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: LD_INT 2
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 1
71347: NEG
71348: PUSH
71349: LD_INT 1
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 2
71358: NEG
71359: PUSH
71360: LD_INT 0
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 2
71369: NEG
71370: PUSH
71371: LD_INT 1
71373: NEG
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 2
71381: NEG
71382: PUSH
71383: LD_INT 2
71385: NEG
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: LIST
71398: LIST
71399: LIST
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71412: LD_ADDR_VAR 0 55
71416: PUSH
71417: LD_INT 0
71419: PUSH
71420: LD_INT 0
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 0
71429: PUSH
71430: LD_INT 1
71432: NEG
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 1
71440: PUSH
71441: LD_INT 0
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 1
71450: PUSH
71451: LD_INT 1
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: PUSH
71458: LD_INT 0
71460: PUSH
71461: LD_INT 1
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: LD_INT 0
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 1
71481: NEG
71482: PUSH
71483: LD_INT 1
71485: NEG
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: NEG
71494: PUSH
71495: LD_INT 2
71497: NEG
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 0
71505: PUSH
71506: LD_INT 2
71508: NEG
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 1
71516: PUSH
71517: LD_INT 1
71519: NEG
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 2
71527: PUSH
71528: LD_INT 0
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 2
71537: PUSH
71538: LD_INT 1
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 2
71547: PUSH
71548: LD_INT 2
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 1
71557: PUSH
71558: LD_INT 2
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: PUSH
71565: LD_INT 0
71567: PUSH
71568: LD_INT 2
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 1
71577: NEG
71578: PUSH
71579: LD_INT 1
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 2
71588: NEG
71589: PUSH
71590: LD_INT 0
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 2
71599: NEG
71600: PUSH
71601: LD_INT 1
71603: NEG
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 2
71611: NEG
71612: PUSH
71613: LD_INT 2
71615: NEG
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71642: LD_ADDR_VAR 0 56
71646: PUSH
71647: LD_INT 0
71649: PUSH
71650: LD_INT 0
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: LD_INT 1
71662: NEG
71663: PUSH
71664: EMPTY
71665: LIST
71666: LIST
71667: PUSH
71668: LD_INT 1
71670: PUSH
71671: LD_INT 0
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: PUSH
71678: LD_INT 1
71680: PUSH
71681: LD_INT 1
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 0
71690: PUSH
71691: LD_INT 1
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: LD_INT 1
71700: NEG
71701: PUSH
71702: LD_INT 0
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: PUSH
71709: LD_INT 1
71711: NEG
71712: PUSH
71713: LD_INT 1
71715: NEG
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PUSH
71721: LD_INT 1
71723: NEG
71724: PUSH
71725: LD_INT 2
71727: NEG
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 0
71735: PUSH
71736: LD_INT 2
71738: NEG
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 1
71746: PUSH
71747: LD_INT 1
71749: NEG
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 2
71757: PUSH
71758: LD_INT 0
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PUSH
71765: LD_INT 2
71767: PUSH
71768: LD_INT 1
71770: PUSH
71771: EMPTY
71772: LIST
71773: LIST
71774: PUSH
71775: LD_INT 2
71777: PUSH
71778: LD_INT 2
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: PUSH
71785: LD_INT 1
71787: PUSH
71788: LD_INT 2
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: LD_INT 2
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: LD_INT 1
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 2
71818: NEG
71819: PUSH
71820: LD_INT 0
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 2
71829: NEG
71830: PUSH
71831: LD_INT 1
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 2
71841: NEG
71842: PUSH
71843: LD_INT 2
71845: NEG
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: LIST
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71872: LD_ADDR_VAR 0 57
71876: PUSH
71877: LD_INT 0
71879: PUSH
71880: LD_INT 0
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 0
71889: PUSH
71890: LD_INT 1
71892: NEG
71893: PUSH
71894: EMPTY
71895: LIST
71896: LIST
71897: PUSH
71898: LD_INT 1
71900: PUSH
71901: LD_INT 0
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 1
71910: PUSH
71911: LD_INT 1
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 0
71920: PUSH
71921: LD_INT 1
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PUSH
71928: LD_INT 1
71930: NEG
71931: PUSH
71932: LD_INT 0
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 1
71941: NEG
71942: PUSH
71943: LD_INT 1
71945: NEG
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 1
71953: NEG
71954: PUSH
71955: LD_INT 2
71957: NEG
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 0
71965: PUSH
71966: LD_INT 2
71968: NEG
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: LD_INT 1
71976: PUSH
71977: LD_INT 1
71979: NEG
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 2
71987: PUSH
71988: LD_INT 0
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 2
71997: PUSH
71998: LD_INT 1
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 2
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: PUSH
72015: LD_INT 1
72017: PUSH
72018: LD_INT 2
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 0
72027: PUSH
72028: LD_INT 2
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 1
72037: NEG
72038: PUSH
72039: LD_INT 1
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 2
72048: NEG
72049: PUSH
72050: LD_INT 0
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 2
72059: NEG
72060: PUSH
72061: LD_INT 1
72063: NEG
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 2
72071: NEG
72072: PUSH
72073: LD_INT 2
72075: NEG
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72102: LD_ADDR_VAR 0 58
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: LD_INT 1
72122: NEG
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: LD_INT 1
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 1
72171: NEG
72172: PUSH
72173: LD_INT 1
72175: NEG
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 1
72183: NEG
72184: PUSH
72185: LD_INT 2
72187: NEG
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 0
72195: PUSH
72196: LD_INT 2
72198: NEG
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 1
72206: PUSH
72207: LD_INT 1
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 2
72217: PUSH
72218: LD_INT 0
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 2
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 2
72237: PUSH
72238: LD_INT 2
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 1
72247: PUSH
72248: LD_INT 2
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: LD_INT 2
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 1
72267: NEG
72268: PUSH
72269: LD_INT 1
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 2
72278: NEG
72279: PUSH
72280: LD_INT 0
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 2
72289: NEG
72290: PUSH
72291: LD_INT 1
72293: NEG
72294: PUSH
72295: EMPTY
72296: LIST
72297: LIST
72298: PUSH
72299: LD_INT 2
72301: NEG
72302: PUSH
72303: LD_INT 2
72305: NEG
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72332: LD_ADDR_VAR 0 59
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: LD_INT 0
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 0
72349: PUSH
72350: LD_INT 1
72352: NEG
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 1
72360: PUSH
72361: LD_INT 0
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 1
72370: PUSH
72371: LD_INT 1
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 0
72380: PUSH
72381: LD_INT 1
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 1
72390: NEG
72391: PUSH
72392: LD_INT 0
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: NEG
72402: PUSH
72403: LD_INT 1
72405: NEG
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72420: LD_ADDR_VAR 0 60
72424: PUSH
72425: LD_INT 0
72427: PUSH
72428: LD_INT 0
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 0
72437: PUSH
72438: LD_INT 1
72440: NEG
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 1
72448: PUSH
72449: LD_INT 0
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 1
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 0
72468: PUSH
72469: LD_INT 1
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 1
72478: NEG
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 1
72489: NEG
72490: PUSH
72491: LD_INT 1
72493: NEG
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72508: LD_ADDR_VAR 0 61
72512: PUSH
72513: LD_INT 0
72515: PUSH
72516: LD_INT 0
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 0
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: PUSH
72537: LD_INT 0
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: PUSH
72547: LD_INT 1
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 0
72556: PUSH
72557: LD_INT 1
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 1
72566: NEG
72567: PUSH
72568: LD_INT 0
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 1
72577: NEG
72578: PUSH
72579: LD_INT 1
72581: NEG
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72596: LD_ADDR_VAR 0 62
72600: PUSH
72601: LD_INT 0
72603: PUSH
72604: LD_INT 0
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 0
72613: PUSH
72614: LD_INT 1
72616: NEG
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: LD_INT 1
72624: PUSH
72625: LD_INT 0
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 1
72634: PUSH
72635: LD_INT 1
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 0
72644: PUSH
72645: LD_INT 1
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 1
72654: NEG
72655: PUSH
72656: LD_INT 0
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 1
72665: NEG
72666: PUSH
72667: LD_INT 1
72669: NEG
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: LIST
72682: LIST
72683: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72684: LD_ADDR_VAR 0 63
72688: PUSH
72689: LD_INT 0
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 0
72701: PUSH
72702: LD_INT 1
72704: NEG
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: LD_INT 1
72712: PUSH
72713: LD_INT 0
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 1
72722: PUSH
72723: LD_INT 1
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: PUSH
72730: LD_INT 0
72732: PUSH
72733: LD_INT 1
72735: PUSH
72736: EMPTY
72737: LIST
72738: LIST
72739: PUSH
72740: LD_INT 1
72742: NEG
72743: PUSH
72744: LD_INT 0
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 1
72753: NEG
72754: PUSH
72755: LD_INT 1
72757: NEG
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72772: LD_ADDR_VAR 0 64
72776: PUSH
72777: LD_INT 0
72779: PUSH
72780: LD_INT 0
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 0
72789: PUSH
72790: LD_INT 1
72792: NEG
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 1
72800: PUSH
72801: LD_INT 0
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: LD_INT 1
72810: PUSH
72811: LD_INT 1
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: LD_INT 0
72820: PUSH
72821: LD_INT 1
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PUSH
72828: LD_INT 1
72830: NEG
72831: PUSH
72832: LD_INT 0
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 1
72841: NEG
72842: PUSH
72843: LD_INT 1
72845: NEG
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: ST_TO_ADDR
// end ; 1 :
72860: GO 78757
72862: LD_INT 1
72864: DOUBLE
72865: EQUAL
72866: IFTRUE 72870
72868: GO 75493
72870: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72871: LD_ADDR_VAR 0 11
72875: PUSH
72876: LD_INT 1
72878: NEG
72879: PUSH
72880: LD_INT 3
72882: NEG
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PUSH
72888: LD_INT 0
72890: PUSH
72891: LD_INT 3
72893: NEG
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: LD_INT 2
72904: NEG
72905: PUSH
72906: EMPTY
72907: LIST
72908: LIST
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: LIST
72914: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72915: LD_ADDR_VAR 0 12
72919: PUSH
72920: LD_INT 2
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 3
72933: PUSH
72934: LD_INT 0
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 3
72943: PUSH
72944: LD_INT 1
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: LIST
72955: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72956: LD_ADDR_VAR 0 13
72960: PUSH
72961: LD_INT 3
72963: PUSH
72964: LD_INT 2
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 3
72973: PUSH
72974: LD_INT 3
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 2
72983: PUSH
72984: LD_INT 3
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: LIST
72995: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72996: LD_ADDR_VAR 0 14
73000: PUSH
73001: LD_INT 1
73003: PUSH
73004: LD_INT 3
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 0
73013: PUSH
73014: LD_INT 3
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 1
73023: NEG
73024: PUSH
73025: LD_INT 2
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: LIST
73036: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73037: LD_ADDR_VAR 0 15
73041: PUSH
73042: LD_INT 2
73044: NEG
73045: PUSH
73046: LD_INT 1
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: LD_INT 3
73055: NEG
73056: PUSH
73057: LD_INT 0
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 3
73066: NEG
73067: PUSH
73068: LD_INT 1
73070: NEG
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: LIST
73080: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73081: LD_ADDR_VAR 0 16
73085: PUSH
73086: LD_INT 2
73088: NEG
73089: PUSH
73090: LD_INT 3
73092: NEG
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 3
73100: NEG
73101: PUSH
73102: LD_INT 2
73104: NEG
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 3
73112: NEG
73113: PUSH
73114: LD_INT 3
73116: NEG
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: LIST
73126: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73127: LD_ADDR_VAR 0 17
73131: PUSH
73132: LD_INT 1
73134: NEG
73135: PUSH
73136: LD_INT 3
73138: NEG
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 0
73146: PUSH
73147: LD_INT 3
73149: NEG
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 1
73157: PUSH
73158: LD_INT 2
73160: NEG
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: LIST
73170: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73171: LD_ADDR_VAR 0 18
73175: PUSH
73176: LD_INT 2
73178: PUSH
73179: LD_INT 1
73181: NEG
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 3
73189: PUSH
73190: LD_INT 0
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 3
73199: PUSH
73200: LD_INT 1
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: LIST
73211: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73212: LD_ADDR_VAR 0 19
73216: PUSH
73217: LD_INT 3
73219: PUSH
73220: LD_INT 2
73222: PUSH
73223: EMPTY
73224: LIST
73225: LIST
73226: PUSH
73227: LD_INT 3
73229: PUSH
73230: LD_INT 3
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 2
73239: PUSH
73240: LD_INT 3
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: LIST
73251: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73252: LD_ADDR_VAR 0 20
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: LD_INT 3
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 0
73269: PUSH
73270: LD_INT 3
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: PUSH
73277: LD_INT 1
73279: NEG
73280: PUSH
73281: LD_INT 2
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: LIST
73292: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73293: LD_ADDR_VAR 0 21
73297: PUSH
73298: LD_INT 2
73300: NEG
73301: PUSH
73302: LD_INT 1
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 3
73311: NEG
73312: PUSH
73313: LD_INT 0
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 3
73322: NEG
73323: PUSH
73324: LD_INT 1
73326: NEG
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: LIST
73336: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73337: LD_ADDR_VAR 0 22
73341: PUSH
73342: LD_INT 2
73344: NEG
73345: PUSH
73346: LD_INT 3
73348: NEG
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 3
73356: NEG
73357: PUSH
73358: LD_INT 2
73360: NEG
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 3
73368: NEG
73369: PUSH
73370: LD_INT 3
73372: NEG
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: LIST
73382: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
73383: LD_ADDR_VAR 0 23
73387: PUSH
73388: LD_INT 0
73390: PUSH
73391: LD_INT 3
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 1
73401: NEG
73402: PUSH
73403: LD_INT 4
73405: NEG
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: LD_INT 3
73416: NEG
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: LIST
73426: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
73427: LD_ADDR_VAR 0 24
73431: PUSH
73432: LD_INT 3
73434: PUSH
73435: LD_INT 0
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: PUSH
73442: LD_INT 3
73444: PUSH
73445: LD_INT 1
73447: NEG
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 4
73455: PUSH
73456: LD_INT 1
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: LIST
73467: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
73468: LD_ADDR_VAR 0 25
73472: PUSH
73473: LD_INT 3
73475: PUSH
73476: LD_INT 3
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 4
73485: PUSH
73486: LD_INT 3
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 3
73495: PUSH
73496: LD_INT 4
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: LIST
73507: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
73508: LD_ADDR_VAR 0 26
73512: PUSH
73513: LD_INT 0
73515: PUSH
73516: LD_INT 3
73518: PUSH
73519: EMPTY
73520: LIST
73521: LIST
73522: PUSH
73523: LD_INT 1
73525: PUSH
73526: LD_INT 4
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PUSH
73533: LD_INT 1
73535: NEG
73536: PUSH
73537: LD_INT 3
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: LIST
73548: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
73549: LD_ADDR_VAR 0 27
73553: PUSH
73554: LD_INT 3
73556: NEG
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 3
73567: NEG
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 4
73578: NEG
73579: PUSH
73580: LD_INT 1
73582: NEG
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
73593: LD_ADDR_VAR 0 28
73597: PUSH
73598: LD_INT 3
73600: NEG
73601: PUSH
73602: LD_INT 3
73604: NEG
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: LD_INT 3
73612: NEG
73613: PUSH
73614: LD_INT 4
73616: NEG
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: PUSH
73622: LD_INT 4
73624: NEG
73625: PUSH
73626: LD_INT 3
73628: NEG
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: LIST
73638: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
73639: LD_ADDR_VAR 0 29
73643: PUSH
73644: LD_INT 1
73646: NEG
73647: PUSH
73648: LD_INT 3
73650: NEG
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 0
73658: PUSH
73659: LD_INT 3
73661: NEG
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 1
73669: PUSH
73670: LD_INT 2
73672: NEG
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: PUSH
73678: LD_INT 1
73680: NEG
73681: PUSH
73682: LD_INT 4
73684: NEG
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 0
73692: PUSH
73693: LD_INT 4
73695: NEG
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 1
73703: PUSH
73704: LD_INT 3
73706: NEG
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 1
73714: NEG
73715: PUSH
73716: LD_INT 5
73718: NEG
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 0
73726: PUSH
73727: LD_INT 5
73729: NEG
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 1
73737: PUSH
73738: LD_INT 4
73740: NEG
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: LD_INT 1
73748: NEG
73749: PUSH
73750: LD_INT 6
73752: NEG
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: LD_INT 0
73760: PUSH
73761: LD_INT 6
73763: NEG
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: LD_INT 1
73771: PUSH
73772: LD_INT 5
73774: NEG
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: LIST
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: LIST
73793: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
73794: LD_ADDR_VAR 0 30
73798: PUSH
73799: LD_INT 2
73801: PUSH
73802: LD_INT 1
73804: NEG
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: PUSH
73810: LD_INT 3
73812: PUSH
73813: LD_INT 0
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 3
73822: PUSH
73823: LD_INT 1
73825: PUSH
73826: EMPTY
73827: LIST
73828: LIST
73829: PUSH
73830: LD_INT 3
73832: PUSH
73833: LD_INT 1
73835: NEG
73836: PUSH
73837: EMPTY
73838: LIST
73839: LIST
73840: PUSH
73841: LD_INT 4
73843: PUSH
73844: LD_INT 0
73846: PUSH
73847: EMPTY
73848: LIST
73849: LIST
73850: PUSH
73851: LD_INT 4
73853: PUSH
73854: LD_INT 1
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 4
73863: PUSH
73864: LD_INT 1
73866: NEG
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 5
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 5
73884: PUSH
73885: LD_INT 1
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 5
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 6
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 6
73915: PUSH
73916: LD_INT 1
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
73937: LD_ADDR_VAR 0 31
73941: PUSH
73942: LD_INT 3
73944: PUSH
73945: LD_INT 2
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: LD_INT 3
73954: PUSH
73955: LD_INT 3
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: PUSH
73962: LD_INT 2
73964: PUSH
73965: LD_INT 3
73967: PUSH
73968: EMPTY
73969: LIST
73970: LIST
73971: PUSH
73972: LD_INT 4
73974: PUSH
73975: LD_INT 3
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: LD_INT 4
73984: PUSH
73985: LD_INT 4
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PUSH
73992: LD_INT 3
73994: PUSH
73995: LD_INT 4
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 5
74004: PUSH
74005: LD_INT 4
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 5
74014: PUSH
74015: LD_INT 5
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 4
74024: PUSH
74025: LD_INT 5
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 6
74034: PUSH
74035: LD_INT 5
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 6
74044: PUSH
74045: LD_INT 6
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 5
74054: PUSH
74055: LD_INT 6
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
74076: LD_ADDR_VAR 0 32
74080: PUSH
74081: LD_INT 1
74083: PUSH
74084: LD_INT 3
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 0
74093: PUSH
74094: LD_INT 3
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 1
74103: NEG
74104: PUSH
74105: LD_INT 2
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: LD_INT 1
74114: PUSH
74115: LD_INT 4
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 0
74124: PUSH
74125: LD_INT 4
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PUSH
74132: LD_INT 1
74134: NEG
74135: PUSH
74136: LD_INT 3
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: LD_INT 1
74145: PUSH
74146: LD_INT 5
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 0
74155: PUSH
74156: LD_INT 5
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 1
74165: NEG
74166: PUSH
74167: LD_INT 4
74169: PUSH
74170: EMPTY
74171: LIST
74172: LIST
74173: PUSH
74174: LD_INT 1
74176: PUSH
74177: LD_INT 6
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 0
74186: PUSH
74187: LD_INT 6
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PUSH
74194: LD_INT 1
74196: NEG
74197: PUSH
74198: LD_INT 5
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: LIST
74218: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
74219: LD_ADDR_VAR 0 33
74223: PUSH
74224: LD_INT 2
74226: NEG
74227: PUSH
74228: LD_INT 1
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 3
74237: NEG
74238: PUSH
74239: LD_INT 0
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 3
74248: NEG
74249: PUSH
74250: LD_INT 1
74252: NEG
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 3
74260: NEG
74261: PUSH
74262: LD_INT 1
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PUSH
74269: LD_INT 4
74271: NEG
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 4
74282: NEG
74283: PUSH
74284: LD_INT 1
74286: NEG
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 4
74294: NEG
74295: PUSH
74296: LD_INT 1
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: PUSH
74303: LD_INT 5
74305: NEG
74306: PUSH
74307: LD_INT 0
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 5
74316: NEG
74317: PUSH
74318: LD_INT 1
74320: NEG
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 5
74328: NEG
74329: PUSH
74330: LD_INT 1
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 6
74339: NEG
74340: PUSH
74341: LD_INT 0
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: PUSH
74348: LD_INT 6
74350: NEG
74351: PUSH
74352: LD_INT 1
74354: NEG
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: LIST
74364: LIST
74365: LIST
74366: LIST
74367: LIST
74368: LIST
74369: LIST
74370: LIST
74371: LIST
74372: LIST
74373: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
74374: LD_ADDR_VAR 0 34
74378: PUSH
74379: LD_INT 2
74381: NEG
74382: PUSH
74383: LD_INT 3
74385: NEG
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 3
74393: NEG
74394: PUSH
74395: LD_INT 2
74397: NEG
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 3
74405: NEG
74406: PUSH
74407: LD_INT 3
74409: NEG
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 3
74417: NEG
74418: PUSH
74419: LD_INT 4
74421: NEG
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 4
74429: NEG
74430: PUSH
74431: LD_INT 3
74433: NEG
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: LD_INT 4
74441: NEG
74442: PUSH
74443: LD_INT 4
74445: NEG
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 4
74453: NEG
74454: PUSH
74455: LD_INT 5
74457: NEG
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: PUSH
74463: LD_INT 5
74465: NEG
74466: PUSH
74467: LD_INT 4
74469: NEG
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: LD_INT 5
74477: NEG
74478: PUSH
74479: LD_INT 5
74481: NEG
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: LD_INT 5
74489: NEG
74490: PUSH
74491: LD_INT 6
74493: NEG
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 6
74501: NEG
74502: PUSH
74503: LD_INT 5
74505: NEG
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 6
74513: NEG
74514: PUSH
74515: LD_INT 6
74517: NEG
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: LIST
74533: LIST
74534: LIST
74535: LIST
74536: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
74537: LD_ADDR_VAR 0 41
74541: PUSH
74542: LD_INT 0
74544: PUSH
74545: LD_INT 2
74547: NEG
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 1
74555: NEG
74556: PUSH
74557: LD_INT 3
74559: NEG
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 1
74567: PUSH
74568: LD_INT 2
74570: NEG
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: LIST
74580: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
74581: LD_ADDR_VAR 0 42
74585: PUSH
74586: LD_INT 2
74588: PUSH
74589: LD_INT 0
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 2
74598: PUSH
74599: LD_INT 1
74601: NEG
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 3
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: LIST
74621: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
74622: LD_ADDR_VAR 0 43
74626: PUSH
74627: LD_INT 2
74629: PUSH
74630: LD_INT 2
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: PUSH
74637: LD_INT 3
74639: PUSH
74640: LD_INT 2
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: PUSH
74647: LD_INT 2
74649: PUSH
74650: LD_INT 3
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: LIST
74661: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
74662: LD_ADDR_VAR 0 44
74666: PUSH
74667: LD_INT 0
74669: PUSH
74670: LD_INT 2
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 1
74679: PUSH
74680: LD_INT 3
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 1
74689: NEG
74690: PUSH
74691: LD_INT 2
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: LIST
74702: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74703: LD_ADDR_VAR 0 45
74707: PUSH
74708: LD_INT 2
74710: NEG
74711: PUSH
74712: LD_INT 0
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 2
74721: NEG
74722: PUSH
74723: LD_INT 1
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 3
74732: NEG
74733: PUSH
74734: LD_INT 1
74736: NEG
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: LIST
74746: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
74747: LD_ADDR_VAR 0 46
74751: PUSH
74752: LD_INT 2
74754: NEG
74755: PUSH
74756: LD_INT 2
74758: NEG
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 2
74766: NEG
74767: PUSH
74768: LD_INT 3
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 3
74778: NEG
74779: PUSH
74780: LD_INT 2
74782: NEG
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: LIST
74792: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
74793: LD_ADDR_VAR 0 47
74797: PUSH
74798: LD_INT 2
74800: NEG
74801: PUSH
74802: LD_INT 3
74804: NEG
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 1
74812: NEG
74813: PUSH
74814: LD_INT 3
74816: NEG
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74826: LD_ADDR_VAR 0 48
74830: PUSH
74831: LD_INT 1
74833: PUSH
74834: LD_INT 2
74836: NEG
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 2
74844: PUSH
74845: LD_INT 1
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
74857: LD_ADDR_VAR 0 49
74861: PUSH
74862: LD_INT 3
74864: PUSH
74865: LD_INT 1
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 3
74874: PUSH
74875: LD_INT 2
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
74886: LD_ADDR_VAR 0 50
74890: PUSH
74891: LD_INT 2
74893: PUSH
74894: LD_INT 3
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 1
74903: PUSH
74904: LD_INT 3
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
74915: LD_ADDR_VAR 0 51
74919: PUSH
74920: LD_INT 1
74922: NEG
74923: PUSH
74924: LD_INT 2
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: PUSH
74931: LD_INT 2
74933: NEG
74934: PUSH
74935: LD_INT 1
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
74946: LD_ADDR_VAR 0 52
74950: PUSH
74951: LD_INT 3
74953: NEG
74954: PUSH
74955: LD_INT 1
74957: NEG
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 3
74965: NEG
74966: PUSH
74967: LD_INT 2
74969: NEG
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74979: LD_ADDR_VAR 0 53
74983: PUSH
74984: LD_INT 1
74986: NEG
74987: PUSH
74988: LD_INT 3
74990: NEG
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 0
74998: PUSH
74999: LD_INT 3
75001: NEG
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 1
75009: PUSH
75010: LD_INT 2
75012: NEG
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: LIST
75022: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75023: LD_ADDR_VAR 0 54
75027: PUSH
75028: LD_INT 2
75030: PUSH
75031: LD_INT 1
75033: NEG
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 3
75041: PUSH
75042: LD_INT 0
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 3
75051: PUSH
75052: LD_INT 1
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: LIST
75063: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75064: LD_ADDR_VAR 0 55
75068: PUSH
75069: LD_INT 3
75071: PUSH
75072: LD_INT 2
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 3
75081: PUSH
75082: LD_INT 3
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PUSH
75089: LD_INT 2
75091: PUSH
75092: LD_INT 3
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: LIST
75103: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75104: LD_ADDR_VAR 0 56
75108: PUSH
75109: LD_INT 1
75111: PUSH
75112: LD_INT 3
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 0
75121: PUSH
75122: LD_INT 3
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 1
75131: NEG
75132: PUSH
75133: LD_INT 2
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: LIST
75144: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75145: LD_ADDR_VAR 0 57
75149: PUSH
75150: LD_INT 2
75152: NEG
75153: PUSH
75154: LD_INT 1
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 3
75163: NEG
75164: PUSH
75165: LD_INT 0
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 3
75174: NEG
75175: PUSH
75176: LD_INT 1
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: LIST
75188: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75189: LD_ADDR_VAR 0 58
75193: PUSH
75194: LD_INT 2
75196: NEG
75197: PUSH
75198: LD_INT 3
75200: NEG
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 3
75208: NEG
75209: PUSH
75210: LD_INT 2
75212: NEG
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: LD_INT 3
75220: NEG
75221: PUSH
75222: LD_INT 3
75224: NEG
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: LIST
75234: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
75235: LD_ADDR_VAR 0 59
75239: PUSH
75240: LD_INT 1
75242: NEG
75243: PUSH
75244: LD_INT 2
75246: NEG
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 0
75254: PUSH
75255: LD_INT 2
75257: NEG
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: LD_INT 1
75268: NEG
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: LIST
75278: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75279: LD_ADDR_VAR 0 60
75283: PUSH
75284: LD_INT 1
75286: PUSH
75287: LD_INT 1
75289: NEG
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 2
75297: PUSH
75298: LD_INT 0
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 2
75307: PUSH
75308: LD_INT 1
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: LIST
75319: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75320: LD_ADDR_VAR 0 61
75324: PUSH
75325: LD_INT 2
75327: PUSH
75328: LD_INT 1
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 2
75337: PUSH
75338: LD_INT 2
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: LD_INT 2
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: LIST
75359: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75360: LD_ADDR_VAR 0 62
75364: PUSH
75365: LD_INT 1
75367: PUSH
75368: LD_INT 2
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 0
75377: PUSH
75378: LD_INT 2
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: LD_INT 1
75387: NEG
75388: PUSH
75389: LD_INT 1
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: LIST
75400: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75401: LD_ADDR_VAR 0 63
75405: PUSH
75406: LD_INT 1
75408: NEG
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 2
75419: NEG
75420: PUSH
75421: LD_INT 0
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 2
75430: NEG
75431: PUSH
75432: LD_INT 1
75434: NEG
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: LIST
75444: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75445: LD_ADDR_VAR 0 64
75449: PUSH
75450: LD_INT 1
75452: NEG
75453: PUSH
75454: LD_INT 2
75456: NEG
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 2
75464: NEG
75465: PUSH
75466: LD_INT 1
75468: NEG
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 2
75476: NEG
75477: PUSH
75478: LD_INT 2
75480: NEG
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: LIST
75490: ST_TO_ADDR
// end ; 2 :
75491: GO 78757
75493: LD_INT 2
75495: DOUBLE
75496: EQUAL
75497: IFTRUE 75501
75499: GO 78756
75501: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
75502: LD_ADDR_VAR 0 29
75506: PUSH
75507: LD_INT 4
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 4
75519: PUSH
75520: LD_INT 1
75522: NEG
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 5
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 5
75540: PUSH
75541: LD_INT 1
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: LD_INT 4
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 3
75560: PUSH
75561: LD_INT 0
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 3
75570: PUSH
75571: LD_INT 1
75573: NEG
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 3
75581: PUSH
75582: LD_INT 2
75584: NEG
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: PUSH
75590: LD_INT 5
75592: PUSH
75593: LD_INT 2
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 3
75602: PUSH
75603: LD_INT 3
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 3
75612: PUSH
75613: LD_INT 2
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: PUSH
75620: LD_INT 4
75622: PUSH
75623: LD_INT 3
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 4
75632: PUSH
75633: LD_INT 4
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 3
75642: PUSH
75643: LD_INT 4
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: PUSH
75650: LD_INT 2
75652: PUSH
75653: LD_INT 3
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 2
75662: PUSH
75663: LD_INT 2
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 4
75672: PUSH
75673: LD_INT 2
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 2
75682: PUSH
75683: LD_INT 4
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 0
75692: PUSH
75693: LD_INT 4
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 0
75702: PUSH
75703: LD_INT 3
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 1
75712: PUSH
75713: LD_INT 4
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: LD_INT 1
75722: PUSH
75723: LD_INT 5
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 0
75732: PUSH
75733: LD_INT 5
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 1
75742: NEG
75743: PUSH
75744: LD_INT 4
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 1
75753: NEG
75754: PUSH
75755: LD_INT 3
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 2
75764: PUSH
75765: LD_INT 5
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 2
75774: NEG
75775: PUSH
75776: LD_INT 3
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 3
75785: NEG
75786: PUSH
75787: LD_INT 0
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 3
75796: NEG
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 2
75808: NEG
75809: PUSH
75810: LD_INT 0
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 2
75819: NEG
75820: PUSH
75821: LD_INT 1
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 3
75830: NEG
75831: PUSH
75832: LD_INT 1
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 4
75841: NEG
75842: PUSH
75843: LD_INT 0
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 4
75852: NEG
75853: PUSH
75854: LD_INT 1
75856: NEG
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 4
75864: NEG
75865: PUSH
75866: LD_INT 2
75868: NEG
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 2
75876: NEG
75877: PUSH
75878: LD_INT 2
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 4
75887: NEG
75888: PUSH
75889: LD_INT 4
75891: NEG
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 4
75899: NEG
75900: PUSH
75901: LD_INT 5
75903: NEG
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: PUSH
75909: LD_INT 3
75911: NEG
75912: PUSH
75913: LD_INT 4
75915: NEG
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 3
75923: NEG
75924: PUSH
75925: LD_INT 3
75927: NEG
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 4
75935: NEG
75936: PUSH
75937: LD_INT 3
75939: NEG
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 5
75947: NEG
75948: PUSH
75949: LD_INT 4
75951: NEG
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 5
75959: NEG
75960: PUSH
75961: LD_INT 5
75963: NEG
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 3
75971: NEG
75972: PUSH
75973: LD_INT 5
75975: NEG
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 5
75983: NEG
75984: PUSH
75985: LD_INT 3
75987: NEG
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: LIST
75999: LIST
76000: LIST
76001: LIST
76002: LIST
76003: LIST
76004: LIST
76005: LIST
76006: LIST
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: LIST
76014: LIST
76015: LIST
76016: LIST
76017: LIST
76018: LIST
76019: LIST
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: LIST
76027: LIST
76028: LIST
76029: LIST
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
76040: LD_ADDR_VAR 0 30
76044: PUSH
76045: LD_INT 4
76047: PUSH
76048: LD_INT 4
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 4
76057: PUSH
76058: LD_INT 3
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 5
76067: PUSH
76068: LD_INT 4
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: LD_INT 5
76077: PUSH
76078: LD_INT 5
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 4
76087: PUSH
76088: LD_INT 5
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 3
76097: PUSH
76098: LD_INT 4
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 3
76107: PUSH
76108: LD_INT 3
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: PUSH
76115: LD_INT 5
76117: PUSH
76118: LD_INT 3
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 3
76127: PUSH
76128: LD_INT 5
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 0
76137: PUSH
76138: LD_INT 3
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 0
76147: PUSH
76148: LD_INT 2
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: LD_INT 1
76157: PUSH
76158: LD_INT 3
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 1
76167: PUSH
76168: LD_INT 4
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 0
76177: PUSH
76178: LD_INT 4
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 1
76187: NEG
76188: PUSH
76189: LD_INT 3
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 1
76198: NEG
76199: PUSH
76200: LD_INT 2
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: LD_INT 4
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 2
76219: NEG
76220: PUSH
76221: LD_INT 2
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PUSH
76228: LD_INT 4
76230: NEG
76231: PUSH
76232: LD_INT 0
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: PUSH
76239: LD_INT 4
76241: NEG
76242: PUSH
76243: LD_INT 1
76245: NEG
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 3
76253: NEG
76254: PUSH
76255: LD_INT 0
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 3
76264: NEG
76265: PUSH
76266: LD_INT 1
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 4
76275: NEG
76276: PUSH
76277: LD_INT 1
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 5
76286: NEG
76287: PUSH
76288: LD_INT 0
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: LD_INT 5
76297: NEG
76298: PUSH
76299: LD_INT 1
76301: NEG
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 5
76309: NEG
76310: PUSH
76311: LD_INT 2
76313: NEG
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 3
76321: NEG
76322: PUSH
76323: LD_INT 2
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: PUSH
76330: LD_INT 3
76332: NEG
76333: PUSH
76334: LD_INT 3
76336: NEG
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: PUSH
76342: LD_INT 3
76344: NEG
76345: PUSH
76346: LD_INT 4
76348: NEG
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 2
76356: NEG
76357: PUSH
76358: LD_INT 3
76360: NEG
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 2
76368: NEG
76369: PUSH
76370: LD_INT 2
76372: NEG
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 3
76380: NEG
76381: PUSH
76382: LD_INT 2
76384: NEG
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: LD_INT 4
76392: NEG
76393: PUSH
76394: LD_INT 3
76396: NEG
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: LD_INT 4
76404: NEG
76405: PUSH
76406: LD_INT 4
76408: NEG
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 2
76416: NEG
76417: PUSH
76418: LD_INT 4
76420: NEG
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 4
76428: NEG
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 0
76440: PUSH
76441: LD_INT 4
76443: NEG
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 0
76451: PUSH
76452: LD_INT 5
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 1
76462: PUSH
76463: LD_INT 4
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 1
76473: PUSH
76474: LD_INT 3
76476: NEG
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 0
76484: PUSH
76485: LD_INT 3
76487: NEG
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 1
76495: NEG
76496: PUSH
76497: LD_INT 4
76499: NEG
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: PUSH
76505: LD_INT 1
76507: NEG
76508: PUSH
76509: LD_INT 5
76511: NEG
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: PUSH
76517: LD_INT 2
76519: PUSH
76520: LD_INT 3
76522: NEG
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 2
76530: NEG
76531: PUSH
76532: LD_INT 5
76534: NEG
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: LIST
76560: LIST
76561: LIST
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: LIST
76579: LIST
76580: LIST
76581: LIST
76582: LIST
76583: LIST
76584: LIST
76585: LIST
76586: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
76587: LD_ADDR_VAR 0 31
76591: PUSH
76592: LD_INT 0
76594: PUSH
76595: LD_INT 4
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 0
76604: PUSH
76605: LD_INT 3
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 1
76614: PUSH
76615: LD_INT 4
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 1
76624: PUSH
76625: LD_INT 5
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: PUSH
76632: LD_INT 0
76634: PUSH
76635: LD_INT 5
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 1
76644: NEG
76645: PUSH
76646: LD_INT 4
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 1
76655: NEG
76656: PUSH
76657: LD_INT 3
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 2
76666: PUSH
76667: LD_INT 5
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 2
76676: NEG
76677: PUSH
76678: LD_INT 3
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 3
76687: NEG
76688: PUSH
76689: LD_INT 0
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: LD_INT 3
76698: NEG
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 2
76710: NEG
76711: PUSH
76712: LD_INT 0
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 2
76721: NEG
76722: PUSH
76723: LD_INT 1
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 3
76732: NEG
76733: PUSH
76734: LD_INT 1
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 4
76743: NEG
76744: PUSH
76745: LD_INT 0
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 4
76754: NEG
76755: PUSH
76756: LD_INT 1
76758: NEG
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 4
76766: NEG
76767: PUSH
76768: LD_INT 2
76770: NEG
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 2
76778: NEG
76779: PUSH
76780: LD_INT 2
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 4
76789: NEG
76790: PUSH
76791: LD_INT 4
76793: NEG
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: LD_INT 4
76801: NEG
76802: PUSH
76803: LD_INT 5
76805: NEG
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: PUSH
76811: LD_INT 3
76813: NEG
76814: PUSH
76815: LD_INT 4
76817: NEG
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 3
76825: NEG
76826: PUSH
76827: LD_INT 3
76829: NEG
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 4
76837: NEG
76838: PUSH
76839: LD_INT 3
76841: NEG
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: LD_INT 5
76849: NEG
76850: PUSH
76851: LD_INT 4
76853: NEG
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 5
76861: NEG
76862: PUSH
76863: LD_INT 5
76865: NEG
76866: PUSH
76867: EMPTY
76868: LIST
76869: LIST
76870: PUSH
76871: LD_INT 3
76873: NEG
76874: PUSH
76875: LD_INT 5
76877: NEG
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 5
76885: NEG
76886: PUSH
76887: LD_INT 3
76889: NEG
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: LD_INT 3
76900: NEG
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 0
76908: PUSH
76909: LD_INT 4
76911: NEG
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 1
76919: PUSH
76920: LD_INT 3
76922: NEG
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 1
76930: PUSH
76931: LD_INT 2
76933: NEG
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 0
76941: PUSH
76942: LD_INT 2
76944: NEG
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: LD_INT 1
76952: NEG
76953: PUSH
76954: LD_INT 3
76956: NEG
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 1
76964: NEG
76965: PUSH
76966: LD_INT 4
76968: NEG
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PUSH
76974: LD_INT 2
76976: PUSH
76977: LD_INT 2
76979: NEG
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PUSH
76985: LD_INT 2
76987: NEG
76988: PUSH
76989: LD_INT 4
76991: NEG
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: LD_INT 4
76999: PUSH
77000: LD_INT 0
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 4
77009: PUSH
77010: LD_INT 1
77012: NEG
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 5
77020: PUSH
77021: LD_INT 0
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 5
77030: PUSH
77031: LD_INT 1
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 4
77040: PUSH
77041: LD_INT 1
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 3
77050: PUSH
77051: LD_INT 0
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 3
77060: PUSH
77061: LD_INT 1
77063: NEG
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 3
77071: PUSH
77072: LD_INT 2
77074: NEG
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 5
77082: PUSH
77083: LD_INT 2
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: LIST
77096: LIST
77097: LIST
77098: LIST
77099: LIST
77100: LIST
77101: LIST
77102: LIST
77103: LIST
77104: LIST
77105: LIST
77106: LIST
77107: LIST
77108: LIST
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: LIST
77114: LIST
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: LIST
77120: LIST
77121: LIST
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
77137: LD_ADDR_VAR 0 32
77141: PUSH
77142: LD_INT 4
77144: NEG
77145: PUSH
77146: LD_INT 0
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 4
77155: NEG
77156: PUSH
77157: LD_INT 1
77159: NEG
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 3
77167: NEG
77168: PUSH
77169: LD_INT 0
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PUSH
77176: LD_INT 3
77178: NEG
77179: PUSH
77180: LD_INT 1
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 4
77189: NEG
77190: PUSH
77191: LD_INT 1
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 5
77200: NEG
77201: PUSH
77202: LD_INT 0
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 5
77211: NEG
77212: PUSH
77213: LD_INT 1
77215: NEG
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 5
77223: NEG
77224: PUSH
77225: LD_INT 2
77227: NEG
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: PUSH
77233: LD_INT 3
77235: NEG
77236: PUSH
77237: LD_INT 2
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: LD_INT 3
77246: NEG
77247: PUSH
77248: LD_INT 3
77250: NEG
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 3
77258: NEG
77259: PUSH
77260: LD_INT 4
77262: NEG
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 2
77270: NEG
77271: PUSH
77272: LD_INT 3
77274: NEG
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: PUSH
77280: LD_INT 2
77282: NEG
77283: PUSH
77284: LD_INT 2
77286: NEG
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 3
77294: NEG
77295: PUSH
77296: LD_INT 2
77298: NEG
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 4
77306: NEG
77307: PUSH
77308: LD_INT 3
77310: NEG
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 4
77318: NEG
77319: PUSH
77320: LD_INT 4
77322: NEG
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 2
77330: NEG
77331: PUSH
77332: LD_INT 4
77334: NEG
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 4
77342: NEG
77343: PUSH
77344: LD_INT 2
77346: NEG
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 0
77354: PUSH
77355: LD_INT 4
77357: NEG
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 0
77365: PUSH
77366: LD_INT 5
77368: NEG
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 1
77376: PUSH
77377: LD_INT 4
77379: NEG
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 1
77387: PUSH
77388: LD_INT 3
77390: NEG
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: LD_INT 3
77401: NEG
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 1
77409: NEG
77410: PUSH
77411: LD_INT 4
77413: NEG
77414: PUSH
77415: EMPTY
77416: LIST
77417: LIST
77418: PUSH
77419: LD_INT 1
77421: NEG
77422: PUSH
77423: LD_INT 5
77425: NEG
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 2
77433: PUSH
77434: LD_INT 3
77436: NEG
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 2
77444: NEG
77445: PUSH
77446: LD_INT 5
77448: NEG
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 3
77456: PUSH
77457: LD_INT 0
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 3
77466: PUSH
77467: LD_INT 1
77469: NEG
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 4
77477: PUSH
77478: LD_INT 0
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: PUSH
77485: LD_INT 4
77487: PUSH
77488: LD_INT 1
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 3
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 2
77507: PUSH
77508: LD_INT 0
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 2
77517: PUSH
77518: LD_INT 1
77520: NEG
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 2
77528: PUSH
77529: LD_INT 2
77531: NEG
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 4
77539: PUSH
77540: LD_INT 2
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 4
77549: PUSH
77550: LD_INT 4
77552: PUSH
77553: EMPTY
77554: LIST
77555: LIST
77556: PUSH
77557: LD_INT 4
77559: PUSH
77560: LD_INT 3
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 5
77569: PUSH
77570: LD_INT 4
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 5
77579: PUSH
77580: LD_INT 5
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 4
77589: PUSH
77590: LD_INT 5
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: LD_INT 3
77599: PUSH
77600: LD_INT 4
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 3
77609: PUSH
77610: LD_INT 3
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 5
77619: PUSH
77620: LD_INT 3
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 3
77629: PUSH
77630: LD_INT 5
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: LIST
77641: LIST
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
77684: LD_ADDR_VAR 0 33
77688: PUSH
77689: LD_INT 4
77691: NEG
77692: PUSH
77693: LD_INT 4
77695: NEG
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 4
77703: NEG
77704: PUSH
77705: LD_INT 5
77707: NEG
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: LD_INT 3
77715: NEG
77716: PUSH
77717: LD_INT 4
77719: NEG
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: PUSH
77725: LD_INT 3
77727: NEG
77728: PUSH
77729: LD_INT 3
77731: NEG
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 4
77739: NEG
77740: PUSH
77741: LD_INT 3
77743: NEG
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 5
77751: NEG
77752: PUSH
77753: LD_INT 4
77755: NEG
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 5
77763: NEG
77764: PUSH
77765: LD_INT 5
77767: NEG
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: LD_INT 3
77775: NEG
77776: PUSH
77777: LD_INT 5
77779: NEG
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PUSH
77785: LD_INT 5
77787: NEG
77788: PUSH
77789: LD_INT 3
77791: NEG
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 0
77799: PUSH
77800: LD_INT 3
77802: NEG
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 0
77810: PUSH
77811: LD_INT 4
77813: NEG
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 1
77821: PUSH
77822: LD_INT 3
77824: NEG
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: PUSH
77830: LD_INT 1
77832: PUSH
77833: LD_INT 2
77835: NEG
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 0
77843: PUSH
77844: LD_INT 2
77846: NEG
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: LD_INT 1
77854: NEG
77855: PUSH
77856: LD_INT 3
77858: NEG
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 1
77866: NEG
77867: PUSH
77868: LD_INT 4
77870: NEG
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 2
77878: PUSH
77879: LD_INT 2
77881: NEG
77882: PUSH
77883: EMPTY
77884: LIST
77885: LIST
77886: PUSH
77887: LD_INT 2
77889: NEG
77890: PUSH
77891: LD_INT 4
77893: NEG
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 4
77901: PUSH
77902: LD_INT 0
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 4
77911: PUSH
77912: LD_INT 1
77914: NEG
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 5
77922: PUSH
77923: LD_INT 0
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 5
77932: PUSH
77933: LD_INT 1
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 4
77942: PUSH
77943: LD_INT 1
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 3
77952: PUSH
77953: LD_INT 0
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 3
77962: PUSH
77963: LD_INT 1
77965: NEG
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 3
77973: PUSH
77974: LD_INT 2
77976: NEG
77977: PUSH
77978: EMPTY
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 5
77984: PUSH
77985: LD_INT 2
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: PUSH
77992: LD_INT 3
77994: PUSH
77995: LD_INT 3
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: PUSH
78002: LD_INT 3
78004: PUSH
78005: LD_INT 2
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: PUSH
78012: LD_INT 4
78014: PUSH
78015: LD_INT 3
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: LD_INT 4
78024: PUSH
78025: LD_INT 4
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 3
78034: PUSH
78035: LD_INT 4
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: LD_INT 2
78044: PUSH
78045: LD_INT 3
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: LD_INT 2
78054: PUSH
78055: LD_INT 2
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 4
78064: PUSH
78065: LD_INT 2
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 2
78074: PUSH
78075: LD_INT 4
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 0
78084: PUSH
78085: LD_INT 4
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 0
78094: PUSH
78095: LD_INT 3
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 1
78104: PUSH
78105: LD_INT 4
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 1
78114: PUSH
78115: LD_INT 5
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 0
78124: PUSH
78125: LD_INT 5
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 1
78134: NEG
78135: PUSH
78136: LD_INT 4
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 1
78145: NEG
78146: PUSH
78147: LD_INT 3
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 2
78156: PUSH
78157: LD_INT 5
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: LD_INT 2
78166: NEG
78167: PUSH
78168: LD_INT 3
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: LIST
78179: LIST
78180: LIST
78181: LIST
78182: LIST
78183: LIST
78184: LIST
78185: LIST
78186: LIST
78187: LIST
78188: LIST
78189: LIST
78190: LIST
78191: LIST
78192: LIST
78193: LIST
78194: LIST
78195: LIST
78196: LIST
78197: LIST
78198: LIST
78199: LIST
78200: LIST
78201: LIST
78202: LIST
78203: LIST
78204: LIST
78205: LIST
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
78222: LD_ADDR_VAR 0 34
78226: PUSH
78227: LD_INT 0
78229: PUSH
78230: LD_INT 4
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 0
78240: PUSH
78241: LD_INT 5
78243: NEG
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 1
78251: PUSH
78252: LD_INT 4
78254: NEG
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: LD_INT 3
78265: NEG
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 0
78273: PUSH
78274: LD_INT 3
78276: NEG
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: PUSH
78282: LD_INT 1
78284: NEG
78285: PUSH
78286: LD_INT 4
78288: NEG
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 1
78296: NEG
78297: PUSH
78298: LD_INT 5
78300: NEG
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 2
78308: PUSH
78309: LD_INT 3
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 2
78319: NEG
78320: PUSH
78321: LD_INT 5
78323: NEG
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 3
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 3
78341: PUSH
78342: LD_INT 1
78344: NEG
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 4
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 4
78362: PUSH
78363: LD_INT 1
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PUSH
78370: LD_INT 3
78372: PUSH
78373: LD_INT 1
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PUSH
78380: LD_INT 2
78382: PUSH
78383: LD_INT 0
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 2
78392: PUSH
78393: LD_INT 1
78395: NEG
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: LD_INT 2
78403: PUSH
78404: LD_INT 2
78406: NEG
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 4
78414: PUSH
78415: LD_INT 2
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 4
78424: PUSH
78425: LD_INT 4
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PUSH
78432: LD_INT 4
78434: PUSH
78435: LD_INT 3
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 5
78444: PUSH
78445: LD_INT 4
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: PUSH
78452: LD_INT 5
78454: PUSH
78455: LD_INT 5
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 4
78464: PUSH
78465: LD_INT 5
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 3
78474: PUSH
78475: LD_INT 4
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 3
78484: PUSH
78485: LD_INT 3
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 5
78494: PUSH
78495: LD_INT 3
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 3
78504: PUSH
78505: LD_INT 5
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 0
78514: PUSH
78515: LD_INT 3
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 0
78524: PUSH
78525: LD_INT 2
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: LD_INT 1
78534: PUSH
78535: LD_INT 3
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 1
78544: PUSH
78545: LD_INT 4
78547: PUSH
78548: EMPTY
78549: LIST
78550: LIST
78551: PUSH
78552: LD_INT 0
78554: PUSH
78555: LD_INT 4
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 1
78564: NEG
78565: PUSH
78566: LD_INT 3
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: LD_INT 2
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 2
78586: PUSH
78587: LD_INT 4
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 2
78596: NEG
78597: PUSH
78598: LD_INT 2
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 4
78607: NEG
78608: PUSH
78609: LD_INT 0
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 4
78618: NEG
78619: PUSH
78620: LD_INT 1
78622: NEG
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 3
78630: NEG
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 3
78641: NEG
78642: PUSH
78643: LD_INT 1
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: LD_INT 4
78652: NEG
78653: PUSH
78654: LD_INT 1
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 5
78663: NEG
78664: PUSH
78665: LD_INT 0
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PUSH
78672: LD_INT 5
78674: NEG
78675: PUSH
78676: LD_INT 1
78678: NEG
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 5
78686: NEG
78687: PUSH
78688: LD_INT 2
78690: NEG
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 3
78698: NEG
78699: PUSH
78700: LD_INT 2
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: LIST
78716: LIST
78717: LIST
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: LIST
78723: LIST
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: LIST
78753: ST_TO_ADDR
// end ; end ;
78754: GO 78757
78756: POP
// case btype of b_depot , b_warehouse :
78757: LD_VAR 0 1
78761: PUSH
78762: LD_INT 0
78764: DOUBLE
78765: EQUAL
78766: IFTRUE 78776
78768: LD_INT 1
78770: DOUBLE
78771: EQUAL
78772: IFTRUE 78776
78774: GO 78977
78776: POP
// case nation of nation_american :
78777: LD_VAR 0 5
78781: PUSH
78782: LD_INT 1
78784: DOUBLE
78785: EQUAL
78786: IFTRUE 78790
78788: GO 78846
78790: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
78791: LD_ADDR_VAR 0 9
78795: PUSH
78796: LD_VAR 0 11
78800: PUSH
78801: LD_VAR 0 12
78805: PUSH
78806: LD_VAR 0 13
78810: PUSH
78811: LD_VAR 0 14
78815: PUSH
78816: LD_VAR 0 15
78820: PUSH
78821: LD_VAR 0 16
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: PUSH
78834: LD_VAR 0 4
78838: PUSH
78839: LD_INT 1
78841: PLUS
78842: ARRAY
78843: ST_TO_ADDR
78844: GO 78975
78846: LD_INT 2
78848: DOUBLE
78849: EQUAL
78850: IFTRUE 78854
78852: GO 78910
78854: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
78855: LD_ADDR_VAR 0 9
78859: PUSH
78860: LD_VAR 0 17
78864: PUSH
78865: LD_VAR 0 18
78869: PUSH
78870: LD_VAR 0 19
78874: PUSH
78875: LD_VAR 0 20
78879: PUSH
78880: LD_VAR 0 21
78884: PUSH
78885: LD_VAR 0 22
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: PUSH
78898: LD_VAR 0 4
78902: PUSH
78903: LD_INT 1
78905: PLUS
78906: ARRAY
78907: ST_TO_ADDR
78908: GO 78975
78910: LD_INT 3
78912: DOUBLE
78913: EQUAL
78914: IFTRUE 78918
78916: GO 78974
78918: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
78919: LD_ADDR_VAR 0 9
78923: PUSH
78924: LD_VAR 0 23
78928: PUSH
78929: LD_VAR 0 24
78933: PUSH
78934: LD_VAR 0 25
78938: PUSH
78939: LD_VAR 0 26
78943: PUSH
78944: LD_VAR 0 27
78948: PUSH
78949: LD_VAR 0 28
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: LIST
78958: LIST
78959: LIST
78960: LIST
78961: PUSH
78962: LD_VAR 0 4
78966: PUSH
78967: LD_INT 1
78969: PLUS
78970: ARRAY
78971: ST_TO_ADDR
78972: GO 78975
78974: POP
78975: GO 79530
78977: LD_INT 2
78979: DOUBLE
78980: EQUAL
78981: IFTRUE 78991
78983: LD_INT 3
78985: DOUBLE
78986: EQUAL
78987: IFTRUE 78991
78989: GO 79047
78991: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
78992: LD_ADDR_VAR 0 9
78996: PUSH
78997: LD_VAR 0 29
79001: PUSH
79002: LD_VAR 0 30
79006: PUSH
79007: LD_VAR 0 31
79011: PUSH
79012: LD_VAR 0 32
79016: PUSH
79017: LD_VAR 0 33
79021: PUSH
79022: LD_VAR 0 34
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: PUSH
79035: LD_VAR 0 4
79039: PUSH
79040: LD_INT 1
79042: PLUS
79043: ARRAY
79044: ST_TO_ADDR
79045: GO 79530
79047: LD_INT 16
79049: DOUBLE
79050: EQUAL
79051: IFTRUE 79109
79053: LD_INT 17
79055: DOUBLE
79056: EQUAL
79057: IFTRUE 79109
79059: LD_INT 18
79061: DOUBLE
79062: EQUAL
79063: IFTRUE 79109
79065: LD_INT 19
79067: DOUBLE
79068: EQUAL
79069: IFTRUE 79109
79071: LD_INT 22
79073: DOUBLE
79074: EQUAL
79075: IFTRUE 79109
79077: LD_INT 20
79079: DOUBLE
79080: EQUAL
79081: IFTRUE 79109
79083: LD_INT 21
79085: DOUBLE
79086: EQUAL
79087: IFTRUE 79109
79089: LD_INT 23
79091: DOUBLE
79092: EQUAL
79093: IFTRUE 79109
79095: LD_INT 24
79097: DOUBLE
79098: EQUAL
79099: IFTRUE 79109
79101: LD_INT 25
79103: DOUBLE
79104: EQUAL
79105: IFTRUE 79109
79107: GO 79165
79109: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
79110: LD_ADDR_VAR 0 9
79114: PUSH
79115: LD_VAR 0 35
79119: PUSH
79120: LD_VAR 0 36
79124: PUSH
79125: LD_VAR 0 37
79129: PUSH
79130: LD_VAR 0 38
79134: PUSH
79135: LD_VAR 0 39
79139: PUSH
79140: LD_VAR 0 40
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: PUSH
79153: LD_VAR 0 4
79157: PUSH
79158: LD_INT 1
79160: PLUS
79161: ARRAY
79162: ST_TO_ADDR
79163: GO 79530
79165: LD_INT 6
79167: DOUBLE
79168: EQUAL
79169: IFTRUE 79221
79171: LD_INT 7
79173: DOUBLE
79174: EQUAL
79175: IFTRUE 79221
79177: LD_INT 8
79179: DOUBLE
79180: EQUAL
79181: IFTRUE 79221
79183: LD_INT 13
79185: DOUBLE
79186: EQUAL
79187: IFTRUE 79221
79189: LD_INT 12
79191: DOUBLE
79192: EQUAL
79193: IFTRUE 79221
79195: LD_INT 15
79197: DOUBLE
79198: EQUAL
79199: IFTRUE 79221
79201: LD_INT 11
79203: DOUBLE
79204: EQUAL
79205: IFTRUE 79221
79207: LD_INT 14
79209: DOUBLE
79210: EQUAL
79211: IFTRUE 79221
79213: LD_INT 10
79215: DOUBLE
79216: EQUAL
79217: IFTRUE 79221
79219: GO 79277
79221: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
79222: LD_ADDR_VAR 0 9
79226: PUSH
79227: LD_VAR 0 41
79231: PUSH
79232: LD_VAR 0 42
79236: PUSH
79237: LD_VAR 0 43
79241: PUSH
79242: LD_VAR 0 44
79246: PUSH
79247: LD_VAR 0 45
79251: PUSH
79252: LD_VAR 0 46
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: PUSH
79265: LD_VAR 0 4
79269: PUSH
79270: LD_INT 1
79272: PLUS
79273: ARRAY
79274: ST_TO_ADDR
79275: GO 79530
79277: LD_INT 36
79279: DOUBLE
79280: EQUAL
79281: IFTRUE 79285
79283: GO 79341
79285: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
79286: LD_ADDR_VAR 0 9
79290: PUSH
79291: LD_VAR 0 47
79295: PUSH
79296: LD_VAR 0 48
79300: PUSH
79301: LD_VAR 0 49
79305: PUSH
79306: LD_VAR 0 50
79310: PUSH
79311: LD_VAR 0 51
79315: PUSH
79316: LD_VAR 0 52
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: PUSH
79329: LD_VAR 0 4
79333: PUSH
79334: LD_INT 1
79336: PLUS
79337: ARRAY
79338: ST_TO_ADDR
79339: GO 79530
79341: LD_INT 4
79343: DOUBLE
79344: EQUAL
79345: IFTRUE 79367
79347: LD_INT 5
79349: DOUBLE
79350: EQUAL
79351: IFTRUE 79367
79353: LD_INT 34
79355: DOUBLE
79356: EQUAL
79357: IFTRUE 79367
79359: LD_INT 37
79361: DOUBLE
79362: EQUAL
79363: IFTRUE 79367
79365: GO 79423
79367: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
79368: LD_ADDR_VAR 0 9
79372: PUSH
79373: LD_VAR 0 53
79377: PUSH
79378: LD_VAR 0 54
79382: PUSH
79383: LD_VAR 0 55
79387: PUSH
79388: LD_VAR 0 56
79392: PUSH
79393: LD_VAR 0 57
79397: PUSH
79398: LD_VAR 0 58
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: PUSH
79411: LD_VAR 0 4
79415: PUSH
79416: LD_INT 1
79418: PLUS
79419: ARRAY
79420: ST_TO_ADDR
79421: GO 79530
79423: LD_INT 31
79425: DOUBLE
79426: EQUAL
79427: IFTRUE 79473
79429: LD_INT 32
79431: DOUBLE
79432: EQUAL
79433: IFTRUE 79473
79435: LD_INT 33
79437: DOUBLE
79438: EQUAL
79439: IFTRUE 79473
79441: LD_INT 27
79443: DOUBLE
79444: EQUAL
79445: IFTRUE 79473
79447: LD_INT 26
79449: DOUBLE
79450: EQUAL
79451: IFTRUE 79473
79453: LD_INT 28
79455: DOUBLE
79456: EQUAL
79457: IFTRUE 79473
79459: LD_INT 29
79461: DOUBLE
79462: EQUAL
79463: IFTRUE 79473
79465: LD_INT 30
79467: DOUBLE
79468: EQUAL
79469: IFTRUE 79473
79471: GO 79529
79473: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
79474: LD_ADDR_VAR 0 9
79478: PUSH
79479: LD_VAR 0 59
79483: PUSH
79484: LD_VAR 0 60
79488: PUSH
79489: LD_VAR 0 61
79493: PUSH
79494: LD_VAR 0 62
79498: PUSH
79499: LD_VAR 0 63
79503: PUSH
79504: LD_VAR 0 64
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: PUSH
79517: LD_VAR 0 4
79521: PUSH
79522: LD_INT 1
79524: PLUS
79525: ARRAY
79526: ST_TO_ADDR
79527: GO 79530
79529: POP
// temp_list2 = [ ] ;
79530: LD_ADDR_VAR 0 10
79534: PUSH
79535: EMPTY
79536: ST_TO_ADDR
// for i in temp_list do
79537: LD_ADDR_VAR 0 8
79541: PUSH
79542: LD_VAR 0 9
79546: PUSH
79547: FOR_IN
79548: IFFALSE 79600
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
79550: LD_ADDR_VAR 0 10
79554: PUSH
79555: LD_VAR 0 10
79559: PUSH
79560: LD_VAR 0 8
79564: PUSH
79565: LD_INT 1
79567: ARRAY
79568: PUSH
79569: LD_VAR 0 2
79573: PLUS
79574: PUSH
79575: LD_VAR 0 8
79579: PUSH
79580: LD_INT 2
79582: ARRAY
79583: PUSH
79584: LD_VAR 0 3
79588: PLUS
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: EMPTY
79595: LIST
79596: ADD
79597: ST_TO_ADDR
79598: GO 79547
79600: POP
79601: POP
// result = temp_list2 ;
79602: LD_ADDR_VAR 0 7
79606: PUSH
79607: LD_VAR 0 10
79611: ST_TO_ADDR
// end ;
79612: LD_VAR 0 7
79616: RET
// export function EnemyInRange ( unit , dist ) ; begin
79617: LD_INT 0
79619: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
79620: LD_ADDR_VAR 0 3
79624: PUSH
79625: LD_VAR 0 1
79629: PPUSH
79630: CALL_OW 255
79634: PPUSH
79635: LD_VAR 0 1
79639: PPUSH
79640: CALL_OW 250
79644: PPUSH
79645: LD_VAR 0 1
79649: PPUSH
79650: CALL_OW 251
79654: PPUSH
79655: LD_VAR 0 2
79659: PPUSH
79660: CALL 53721 0 4
79664: PUSH
79665: LD_INT 4
79667: ARRAY
79668: ST_TO_ADDR
// end ;
79669: LD_VAR 0 3
79673: RET
// export function PlayerSeeMe ( unit ) ; begin
79674: LD_INT 0
79676: PPUSH
// result := See ( your_side , unit ) ;
79677: LD_ADDR_VAR 0 2
79681: PUSH
79682: LD_OWVAR 2
79686: PPUSH
79687: LD_VAR 0 1
79691: PPUSH
79692: CALL_OW 292
79696: ST_TO_ADDR
// end ;
79697: LD_VAR 0 2
79701: RET
// export function ReverseDir ( unit ) ; begin
79702: LD_INT 0
79704: PPUSH
// if not unit then
79705: LD_VAR 0 1
79709: NOT
79710: IFFALSE 79714
// exit ;
79712: GO 79737
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
79714: LD_ADDR_VAR 0 2
79718: PUSH
79719: LD_VAR 0 1
79723: PPUSH
79724: CALL_OW 254
79728: PUSH
79729: LD_INT 3
79731: PLUS
79732: PUSH
79733: LD_INT 6
79735: MOD
79736: ST_TO_ADDR
// end ;
79737: LD_VAR 0 2
79741: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
79742: LD_INT 0
79744: PPUSH
79745: PPUSH
79746: PPUSH
79747: PPUSH
79748: PPUSH
// if not hexes then
79749: LD_VAR 0 2
79753: NOT
79754: IFFALSE 79758
// exit ;
79756: GO 79906
// dist := 9999 ;
79758: LD_ADDR_VAR 0 5
79762: PUSH
79763: LD_INT 9999
79765: ST_TO_ADDR
// for i = 1 to hexes do
79766: LD_ADDR_VAR 0 4
79770: PUSH
79771: DOUBLE
79772: LD_INT 1
79774: DEC
79775: ST_TO_ADDR
79776: LD_VAR 0 2
79780: PUSH
79781: FOR_TO
79782: IFFALSE 79894
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
79784: LD_VAR 0 1
79788: PPUSH
79789: LD_VAR 0 2
79793: PUSH
79794: LD_VAR 0 4
79798: ARRAY
79799: PUSH
79800: LD_INT 1
79802: ARRAY
79803: PPUSH
79804: LD_VAR 0 2
79808: PUSH
79809: LD_VAR 0 4
79813: ARRAY
79814: PUSH
79815: LD_INT 2
79817: ARRAY
79818: PPUSH
79819: CALL_OW 297
79823: PUSH
79824: LD_VAR 0 5
79828: LESS
79829: IFFALSE 79892
// begin hex := hexes [ i ] ;
79831: LD_ADDR_VAR 0 7
79835: PUSH
79836: LD_VAR 0 2
79840: PUSH
79841: LD_VAR 0 4
79845: ARRAY
79846: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79847: LD_ADDR_VAR 0 5
79851: PUSH
79852: LD_VAR 0 1
79856: PPUSH
79857: LD_VAR 0 2
79861: PUSH
79862: LD_VAR 0 4
79866: ARRAY
79867: PUSH
79868: LD_INT 1
79870: ARRAY
79871: PPUSH
79872: LD_VAR 0 2
79876: PUSH
79877: LD_VAR 0 4
79881: ARRAY
79882: PUSH
79883: LD_INT 2
79885: ARRAY
79886: PPUSH
79887: CALL_OW 297
79891: ST_TO_ADDR
// end ; end ;
79892: GO 79781
79894: POP
79895: POP
// result := hex ;
79896: LD_ADDR_VAR 0 3
79900: PUSH
79901: LD_VAR 0 7
79905: ST_TO_ADDR
// end ;
79906: LD_VAR 0 3
79910: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
79911: LD_INT 0
79913: PPUSH
79914: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79915: LD_VAR 0 1
79919: NOT
79920: PUSH
79921: LD_VAR 0 1
79925: PUSH
79926: LD_INT 21
79928: PUSH
79929: LD_INT 2
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 23
79938: PUSH
79939: LD_INT 2
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PPUSH
79950: CALL_OW 69
79954: IN
79955: NOT
79956: OR
79957: IFFALSE 79961
// exit ;
79959: GO 80008
// for i = 1 to 3 do
79961: LD_ADDR_VAR 0 3
79965: PUSH
79966: DOUBLE
79967: LD_INT 1
79969: DEC
79970: ST_TO_ADDR
79971: LD_INT 3
79973: PUSH
79974: FOR_TO
79975: IFFALSE 80006
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
79977: LD_VAR 0 1
79981: PPUSH
79982: CALL_OW 250
79986: PPUSH
79987: LD_VAR 0 1
79991: PPUSH
79992: CALL_OW 251
79996: PPUSH
79997: LD_INT 1
79999: PPUSH
80000: CALL_OW 453
80004: GO 79974
80006: POP
80007: POP
// end ;
80008: LD_VAR 0 2
80012: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
80013: LD_INT 0
80015: PPUSH
80016: PPUSH
80017: PPUSH
80018: PPUSH
80019: PPUSH
80020: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
80021: LD_VAR 0 1
80025: NOT
80026: PUSH
80027: LD_VAR 0 2
80031: NOT
80032: OR
80033: PUSH
80034: LD_VAR 0 1
80038: PPUSH
80039: CALL_OW 314
80043: OR
80044: IFFALSE 80048
// exit ;
80046: GO 80489
// x := GetX ( enemy_unit ) ;
80048: LD_ADDR_VAR 0 7
80052: PUSH
80053: LD_VAR 0 2
80057: PPUSH
80058: CALL_OW 250
80062: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
80063: LD_ADDR_VAR 0 8
80067: PUSH
80068: LD_VAR 0 2
80072: PPUSH
80073: CALL_OW 251
80077: ST_TO_ADDR
// if not x or not y then
80078: LD_VAR 0 7
80082: NOT
80083: PUSH
80084: LD_VAR 0 8
80088: NOT
80089: OR
80090: IFFALSE 80094
// exit ;
80092: GO 80489
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
80094: LD_ADDR_VAR 0 6
80098: PUSH
80099: LD_VAR 0 7
80103: PPUSH
80104: LD_INT 0
80106: PPUSH
80107: LD_INT 4
80109: PPUSH
80110: CALL_OW 272
80114: PUSH
80115: LD_VAR 0 8
80119: PPUSH
80120: LD_INT 0
80122: PPUSH
80123: LD_INT 4
80125: PPUSH
80126: CALL_OW 273
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: LD_VAR 0 7
80139: PPUSH
80140: LD_INT 1
80142: PPUSH
80143: LD_INT 4
80145: PPUSH
80146: CALL_OW 272
80150: PUSH
80151: LD_VAR 0 8
80155: PPUSH
80156: LD_INT 1
80158: PPUSH
80159: LD_INT 4
80161: PPUSH
80162: CALL_OW 273
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_VAR 0 7
80175: PPUSH
80176: LD_INT 2
80178: PPUSH
80179: LD_INT 4
80181: PPUSH
80182: CALL_OW 272
80186: PUSH
80187: LD_VAR 0 8
80191: PPUSH
80192: LD_INT 2
80194: PPUSH
80195: LD_INT 4
80197: PPUSH
80198: CALL_OW 273
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_VAR 0 7
80211: PPUSH
80212: LD_INT 3
80214: PPUSH
80215: LD_INT 4
80217: PPUSH
80218: CALL_OW 272
80222: PUSH
80223: LD_VAR 0 8
80227: PPUSH
80228: LD_INT 3
80230: PPUSH
80231: LD_INT 4
80233: PPUSH
80234: CALL_OW 273
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_VAR 0 7
80247: PPUSH
80248: LD_INT 4
80250: PPUSH
80251: LD_INT 4
80253: PPUSH
80254: CALL_OW 272
80258: PUSH
80259: LD_VAR 0 8
80263: PPUSH
80264: LD_INT 4
80266: PPUSH
80267: LD_INT 4
80269: PPUSH
80270: CALL_OW 273
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_VAR 0 7
80283: PPUSH
80284: LD_INT 5
80286: PPUSH
80287: LD_INT 4
80289: PPUSH
80290: CALL_OW 272
80294: PUSH
80295: LD_VAR 0 8
80299: PPUSH
80300: LD_INT 5
80302: PPUSH
80303: LD_INT 4
80305: PPUSH
80306: CALL_OW 273
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: LIST
80321: LIST
80322: ST_TO_ADDR
// for i = tmp downto 1 do
80323: LD_ADDR_VAR 0 4
80327: PUSH
80328: DOUBLE
80329: LD_VAR 0 6
80333: INC
80334: ST_TO_ADDR
80335: LD_INT 1
80337: PUSH
80338: FOR_DOWNTO
80339: IFFALSE 80440
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
80341: LD_VAR 0 6
80345: PUSH
80346: LD_VAR 0 4
80350: ARRAY
80351: PUSH
80352: LD_INT 1
80354: ARRAY
80355: PPUSH
80356: LD_VAR 0 6
80360: PUSH
80361: LD_VAR 0 4
80365: ARRAY
80366: PUSH
80367: LD_INT 2
80369: ARRAY
80370: PPUSH
80371: CALL_OW 488
80375: NOT
80376: PUSH
80377: LD_VAR 0 6
80381: PUSH
80382: LD_VAR 0 4
80386: ARRAY
80387: PUSH
80388: LD_INT 1
80390: ARRAY
80391: PPUSH
80392: LD_VAR 0 6
80396: PUSH
80397: LD_VAR 0 4
80401: ARRAY
80402: PUSH
80403: LD_INT 2
80405: ARRAY
80406: PPUSH
80407: CALL_OW 428
80411: PUSH
80412: LD_INT 0
80414: NONEQUAL
80415: OR
80416: IFFALSE 80438
// tmp := Delete ( tmp , i ) ;
80418: LD_ADDR_VAR 0 6
80422: PUSH
80423: LD_VAR 0 6
80427: PPUSH
80428: LD_VAR 0 4
80432: PPUSH
80433: CALL_OW 3
80437: ST_TO_ADDR
80438: GO 80338
80440: POP
80441: POP
// j := GetClosestHex ( unit , tmp ) ;
80442: LD_ADDR_VAR 0 5
80446: PUSH
80447: LD_VAR 0 1
80451: PPUSH
80452: LD_VAR 0 6
80456: PPUSH
80457: CALL 79742 0 2
80461: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
80462: LD_VAR 0 1
80466: PPUSH
80467: LD_VAR 0 5
80471: PUSH
80472: LD_INT 1
80474: ARRAY
80475: PPUSH
80476: LD_VAR 0 5
80480: PUSH
80481: LD_INT 2
80483: ARRAY
80484: PPUSH
80485: CALL_OW 111
// end ;
80489: LD_VAR 0 3
80493: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
80494: LD_INT 0
80496: PPUSH
80497: PPUSH
80498: PPUSH
// uc_side = 0 ;
80499: LD_ADDR_OWVAR 20
80503: PUSH
80504: LD_INT 0
80506: ST_TO_ADDR
// uc_nation = 0 ;
80507: LD_ADDR_OWVAR 21
80511: PUSH
80512: LD_INT 0
80514: ST_TO_ADDR
// InitHc_All ( ) ;
80515: CALL_OW 584
// InitVc ;
80519: CALL_OW 20
// if mastodonts then
80523: LD_VAR 0 6
80527: IFFALSE 80594
// for i = 1 to mastodonts do
80529: LD_ADDR_VAR 0 11
80533: PUSH
80534: DOUBLE
80535: LD_INT 1
80537: DEC
80538: ST_TO_ADDR
80539: LD_VAR 0 6
80543: PUSH
80544: FOR_TO
80545: IFFALSE 80592
// begin vc_chassis := 31 ;
80547: LD_ADDR_OWVAR 37
80551: PUSH
80552: LD_INT 31
80554: ST_TO_ADDR
// vc_control := control_rider ;
80555: LD_ADDR_OWVAR 38
80559: PUSH
80560: LD_INT 4
80562: ST_TO_ADDR
// animal := CreateVehicle ;
80563: LD_ADDR_VAR 0 12
80567: PUSH
80568: CALL_OW 45
80572: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80573: LD_VAR 0 12
80577: PPUSH
80578: LD_VAR 0 8
80582: PPUSH
80583: LD_INT 0
80585: PPUSH
80586: CALL 82782 0 3
// end ;
80590: GO 80544
80592: POP
80593: POP
// if horses then
80594: LD_VAR 0 5
80598: IFFALSE 80665
// for i = 1 to horses do
80600: LD_ADDR_VAR 0 11
80604: PUSH
80605: DOUBLE
80606: LD_INT 1
80608: DEC
80609: ST_TO_ADDR
80610: LD_VAR 0 5
80614: PUSH
80615: FOR_TO
80616: IFFALSE 80663
// begin hc_class := 21 ;
80618: LD_ADDR_OWVAR 28
80622: PUSH
80623: LD_INT 21
80625: ST_TO_ADDR
// hc_gallery :=  ;
80626: LD_ADDR_OWVAR 33
80630: PUSH
80631: LD_STRING 
80633: ST_TO_ADDR
// animal := CreateHuman ;
80634: LD_ADDR_VAR 0 12
80638: PUSH
80639: CALL_OW 44
80643: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80644: LD_VAR 0 12
80648: PPUSH
80649: LD_VAR 0 8
80653: PPUSH
80654: LD_INT 0
80656: PPUSH
80657: CALL 82782 0 3
// end ;
80661: GO 80615
80663: POP
80664: POP
// if birds then
80665: LD_VAR 0 1
80669: IFFALSE 80736
// for i = 1 to birds do
80671: LD_ADDR_VAR 0 11
80675: PUSH
80676: DOUBLE
80677: LD_INT 1
80679: DEC
80680: ST_TO_ADDR
80681: LD_VAR 0 1
80685: PUSH
80686: FOR_TO
80687: IFFALSE 80734
// begin hc_class = 18 ;
80689: LD_ADDR_OWVAR 28
80693: PUSH
80694: LD_INT 18
80696: ST_TO_ADDR
// hc_gallery =  ;
80697: LD_ADDR_OWVAR 33
80701: PUSH
80702: LD_STRING 
80704: ST_TO_ADDR
// animal := CreateHuman ;
80705: LD_ADDR_VAR 0 12
80709: PUSH
80710: CALL_OW 44
80714: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80715: LD_VAR 0 12
80719: PPUSH
80720: LD_VAR 0 8
80724: PPUSH
80725: LD_INT 0
80727: PPUSH
80728: CALL 82782 0 3
// end ;
80732: GO 80686
80734: POP
80735: POP
// if tigers then
80736: LD_VAR 0 2
80740: IFFALSE 80824
// for i = 1 to tigers do
80742: LD_ADDR_VAR 0 11
80746: PUSH
80747: DOUBLE
80748: LD_INT 1
80750: DEC
80751: ST_TO_ADDR
80752: LD_VAR 0 2
80756: PUSH
80757: FOR_TO
80758: IFFALSE 80822
// begin hc_class = class_tiger ;
80760: LD_ADDR_OWVAR 28
80764: PUSH
80765: LD_INT 14
80767: ST_TO_ADDR
// hc_gallery =  ;
80768: LD_ADDR_OWVAR 33
80772: PUSH
80773: LD_STRING 
80775: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
80776: LD_ADDR_OWVAR 35
80780: PUSH
80781: LD_INT 7
80783: NEG
80784: PPUSH
80785: LD_INT 7
80787: PPUSH
80788: CALL_OW 12
80792: ST_TO_ADDR
// animal := CreateHuman ;
80793: LD_ADDR_VAR 0 12
80797: PUSH
80798: CALL_OW 44
80802: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80803: LD_VAR 0 12
80807: PPUSH
80808: LD_VAR 0 8
80812: PPUSH
80813: LD_INT 0
80815: PPUSH
80816: CALL 82782 0 3
// end ;
80820: GO 80757
80822: POP
80823: POP
// if apemans then
80824: LD_VAR 0 3
80828: IFFALSE 80951
// for i = 1 to apemans do
80830: LD_ADDR_VAR 0 11
80834: PUSH
80835: DOUBLE
80836: LD_INT 1
80838: DEC
80839: ST_TO_ADDR
80840: LD_VAR 0 3
80844: PUSH
80845: FOR_TO
80846: IFFALSE 80949
// begin hc_class = class_apeman ;
80848: LD_ADDR_OWVAR 28
80852: PUSH
80853: LD_INT 12
80855: ST_TO_ADDR
// hc_gallery =  ;
80856: LD_ADDR_OWVAR 33
80860: PUSH
80861: LD_STRING 
80863: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
80864: LD_ADDR_OWVAR 35
80868: PUSH
80869: LD_INT 5
80871: NEG
80872: PPUSH
80873: LD_INT 5
80875: PPUSH
80876: CALL_OW 12
80880: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
80881: LD_ADDR_OWVAR 31
80885: PUSH
80886: LD_INT 1
80888: PPUSH
80889: LD_INT 3
80891: PPUSH
80892: CALL_OW 12
80896: PUSH
80897: LD_INT 1
80899: PPUSH
80900: LD_INT 3
80902: PPUSH
80903: CALL_OW 12
80907: PUSH
80908: LD_INT 0
80910: PUSH
80911: LD_INT 0
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: ST_TO_ADDR
// animal := CreateHuman ;
80920: LD_ADDR_VAR 0 12
80924: PUSH
80925: CALL_OW 44
80929: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80930: LD_VAR 0 12
80934: PPUSH
80935: LD_VAR 0 8
80939: PPUSH
80940: LD_INT 0
80942: PPUSH
80943: CALL 82782 0 3
// end ;
80947: GO 80845
80949: POP
80950: POP
// if enchidnas then
80951: LD_VAR 0 4
80955: IFFALSE 81022
// for i = 1 to enchidnas do
80957: LD_ADDR_VAR 0 11
80961: PUSH
80962: DOUBLE
80963: LD_INT 1
80965: DEC
80966: ST_TO_ADDR
80967: LD_VAR 0 4
80971: PUSH
80972: FOR_TO
80973: IFFALSE 81020
// begin hc_class = 13 ;
80975: LD_ADDR_OWVAR 28
80979: PUSH
80980: LD_INT 13
80982: ST_TO_ADDR
// hc_gallery =  ;
80983: LD_ADDR_OWVAR 33
80987: PUSH
80988: LD_STRING 
80990: ST_TO_ADDR
// animal := CreateHuman ;
80991: LD_ADDR_VAR 0 12
80995: PUSH
80996: CALL_OW 44
81000: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81001: LD_VAR 0 12
81005: PPUSH
81006: LD_VAR 0 8
81010: PPUSH
81011: LD_INT 0
81013: PPUSH
81014: CALL 82782 0 3
// end ;
81018: GO 80972
81020: POP
81021: POP
// if fishes then
81022: LD_VAR 0 7
81026: IFFALSE 81093
// for i = 1 to fishes do
81028: LD_ADDR_VAR 0 11
81032: PUSH
81033: DOUBLE
81034: LD_INT 1
81036: DEC
81037: ST_TO_ADDR
81038: LD_VAR 0 7
81042: PUSH
81043: FOR_TO
81044: IFFALSE 81091
// begin hc_class = 20 ;
81046: LD_ADDR_OWVAR 28
81050: PUSH
81051: LD_INT 20
81053: ST_TO_ADDR
// hc_gallery =  ;
81054: LD_ADDR_OWVAR 33
81058: PUSH
81059: LD_STRING 
81061: ST_TO_ADDR
// animal := CreateHuman ;
81062: LD_ADDR_VAR 0 12
81066: PUSH
81067: CALL_OW 44
81071: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
81072: LD_VAR 0 12
81076: PPUSH
81077: LD_VAR 0 9
81081: PPUSH
81082: LD_INT 0
81084: PPUSH
81085: CALL 82782 0 3
// end ;
81089: GO 81043
81091: POP
81092: POP
// end ;
81093: LD_VAR 0 10
81097: RET
// export function WantHeal ( sci , unit ) ; begin
81098: LD_INT 0
81100: PPUSH
// if GetTaskList ( sci ) > 0 then
81101: LD_VAR 0 1
81105: PPUSH
81106: CALL_OW 437
81110: PUSH
81111: LD_INT 0
81113: GREATER
81114: IFFALSE 81184
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
81116: LD_VAR 0 1
81120: PPUSH
81121: CALL_OW 437
81125: PUSH
81126: LD_INT 1
81128: ARRAY
81129: PUSH
81130: LD_INT 1
81132: ARRAY
81133: PUSH
81134: LD_STRING l
81136: EQUAL
81137: PUSH
81138: LD_VAR 0 1
81142: PPUSH
81143: CALL_OW 437
81147: PUSH
81148: LD_INT 1
81150: ARRAY
81151: PUSH
81152: LD_INT 4
81154: ARRAY
81155: PUSH
81156: LD_VAR 0 2
81160: EQUAL
81161: AND
81162: IFFALSE 81174
// result := true else
81164: LD_ADDR_VAR 0 3
81168: PUSH
81169: LD_INT 1
81171: ST_TO_ADDR
81172: GO 81182
// result := false ;
81174: LD_ADDR_VAR 0 3
81178: PUSH
81179: LD_INT 0
81181: ST_TO_ADDR
// end else
81182: GO 81192
// result := false ;
81184: LD_ADDR_VAR 0 3
81188: PUSH
81189: LD_INT 0
81191: ST_TO_ADDR
// end ;
81192: LD_VAR 0 3
81196: RET
// export function HealTarget ( sci ) ; begin
81197: LD_INT 0
81199: PPUSH
// if not sci then
81200: LD_VAR 0 1
81204: NOT
81205: IFFALSE 81209
// exit ;
81207: GO 81274
// result := 0 ;
81209: LD_ADDR_VAR 0 2
81213: PUSH
81214: LD_INT 0
81216: ST_TO_ADDR
// if GetTaskList ( sci ) then
81217: LD_VAR 0 1
81221: PPUSH
81222: CALL_OW 437
81226: IFFALSE 81274
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
81228: LD_VAR 0 1
81232: PPUSH
81233: CALL_OW 437
81237: PUSH
81238: LD_INT 1
81240: ARRAY
81241: PUSH
81242: LD_INT 1
81244: ARRAY
81245: PUSH
81246: LD_STRING l
81248: EQUAL
81249: IFFALSE 81274
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
81251: LD_ADDR_VAR 0 2
81255: PUSH
81256: LD_VAR 0 1
81260: PPUSH
81261: CALL_OW 437
81265: PUSH
81266: LD_INT 1
81268: ARRAY
81269: PUSH
81270: LD_INT 4
81272: ARRAY
81273: ST_TO_ADDR
// end ;
81274: LD_VAR 0 2
81278: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
81279: LD_INT 0
81281: PPUSH
81282: PPUSH
81283: PPUSH
81284: PPUSH
// if not base_units then
81285: LD_VAR 0 1
81289: NOT
81290: IFFALSE 81294
// exit ;
81292: GO 81381
// result := false ;
81294: LD_ADDR_VAR 0 2
81298: PUSH
81299: LD_INT 0
81301: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
81302: LD_ADDR_VAR 0 5
81306: PUSH
81307: LD_VAR 0 1
81311: PPUSH
81312: LD_INT 21
81314: PUSH
81315: LD_INT 3
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PPUSH
81322: CALL_OW 72
81326: ST_TO_ADDR
// if not tmp then
81327: LD_VAR 0 5
81331: NOT
81332: IFFALSE 81336
// exit ;
81334: GO 81381
// for i in tmp do
81336: LD_ADDR_VAR 0 3
81340: PUSH
81341: LD_VAR 0 5
81345: PUSH
81346: FOR_IN
81347: IFFALSE 81379
// begin result := EnemyInRange ( i , 22 ) ;
81349: LD_ADDR_VAR 0 2
81353: PUSH
81354: LD_VAR 0 3
81358: PPUSH
81359: LD_INT 22
81361: PPUSH
81362: CALL 79617 0 2
81366: ST_TO_ADDR
// if result then
81367: LD_VAR 0 2
81371: IFFALSE 81377
// exit ;
81373: POP
81374: POP
81375: GO 81381
// end ;
81377: GO 81346
81379: POP
81380: POP
// end ;
81381: LD_VAR 0 2
81385: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
81386: LD_INT 0
81388: PPUSH
81389: PPUSH
// if not units then
81390: LD_VAR 0 1
81394: NOT
81395: IFFALSE 81399
// exit ;
81397: GO 81469
// result := [ ] ;
81399: LD_ADDR_VAR 0 3
81403: PUSH
81404: EMPTY
81405: ST_TO_ADDR
// for i in units do
81406: LD_ADDR_VAR 0 4
81410: PUSH
81411: LD_VAR 0 1
81415: PUSH
81416: FOR_IN
81417: IFFALSE 81467
// if GetTag ( i ) = tag then
81419: LD_VAR 0 4
81423: PPUSH
81424: CALL_OW 110
81428: PUSH
81429: LD_VAR 0 2
81433: EQUAL
81434: IFFALSE 81465
// result := Insert ( result , result + 1 , i ) ;
81436: LD_ADDR_VAR 0 3
81440: PUSH
81441: LD_VAR 0 3
81445: PPUSH
81446: LD_VAR 0 3
81450: PUSH
81451: LD_INT 1
81453: PLUS
81454: PPUSH
81455: LD_VAR 0 4
81459: PPUSH
81460: CALL_OW 2
81464: ST_TO_ADDR
81465: GO 81416
81467: POP
81468: POP
// end ;
81469: LD_VAR 0 3
81473: RET
// export function IsDriver ( un ) ; begin
81474: LD_INT 0
81476: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
81477: LD_ADDR_VAR 0 2
81481: PUSH
81482: LD_VAR 0 1
81486: PUSH
81487: LD_INT 55
81489: PUSH
81490: EMPTY
81491: LIST
81492: PPUSH
81493: CALL_OW 69
81497: IN
81498: ST_TO_ADDR
// end ;
81499: LD_VAR 0 2
81503: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81504: LD_INT 0
81506: PPUSH
81507: PPUSH
// list := [ ] ;
81508: LD_ADDR_VAR 0 5
81512: PUSH
81513: EMPTY
81514: ST_TO_ADDR
// case d of 0 :
81515: LD_VAR 0 3
81519: PUSH
81520: LD_INT 0
81522: DOUBLE
81523: EQUAL
81524: IFTRUE 81528
81526: GO 81661
81528: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81529: LD_ADDR_VAR 0 5
81533: PUSH
81534: LD_VAR 0 1
81538: PUSH
81539: LD_INT 4
81541: MINUS
81542: PUSH
81543: LD_VAR 0 2
81547: PUSH
81548: LD_INT 4
81550: MINUS
81551: PUSH
81552: LD_INT 2
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: LIST
81559: PUSH
81560: LD_VAR 0 1
81564: PUSH
81565: LD_INT 3
81567: MINUS
81568: PUSH
81569: LD_VAR 0 2
81573: PUSH
81574: LD_INT 1
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: LIST
81581: PUSH
81582: LD_VAR 0 1
81586: PUSH
81587: LD_INT 4
81589: PLUS
81590: PUSH
81591: LD_VAR 0 2
81595: PUSH
81596: LD_INT 4
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: LIST
81603: PUSH
81604: LD_VAR 0 1
81608: PUSH
81609: LD_INT 3
81611: PLUS
81612: PUSH
81613: LD_VAR 0 2
81617: PUSH
81618: LD_INT 3
81620: PLUS
81621: PUSH
81622: LD_INT 5
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: LIST
81629: PUSH
81630: LD_VAR 0 1
81634: PUSH
81635: LD_VAR 0 2
81639: PUSH
81640: LD_INT 4
81642: PLUS
81643: PUSH
81644: LD_INT 0
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: LIST
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: ST_TO_ADDR
// end ; 1 :
81659: GO 82359
81661: LD_INT 1
81663: DOUBLE
81664: EQUAL
81665: IFTRUE 81669
81667: GO 81802
81669: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
81670: LD_ADDR_VAR 0 5
81674: PUSH
81675: LD_VAR 0 1
81679: PUSH
81680: LD_VAR 0 2
81684: PUSH
81685: LD_INT 4
81687: MINUS
81688: PUSH
81689: LD_INT 3
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: LIST
81696: PUSH
81697: LD_VAR 0 1
81701: PUSH
81702: LD_INT 3
81704: MINUS
81705: PUSH
81706: LD_VAR 0 2
81710: PUSH
81711: LD_INT 3
81713: MINUS
81714: PUSH
81715: LD_INT 2
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: LIST
81722: PUSH
81723: LD_VAR 0 1
81727: PUSH
81728: LD_INT 4
81730: MINUS
81731: PUSH
81732: LD_VAR 0 2
81736: PUSH
81737: LD_INT 1
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: LIST
81744: PUSH
81745: LD_VAR 0 1
81749: PUSH
81750: LD_VAR 0 2
81754: PUSH
81755: LD_INT 3
81757: PLUS
81758: PUSH
81759: LD_INT 0
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: LIST
81766: PUSH
81767: LD_VAR 0 1
81771: PUSH
81772: LD_INT 4
81774: PLUS
81775: PUSH
81776: LD_VAR 0 2
81780: PUSH
81781: LD_INT 4
81783: PLUS
81784: PUSH
81785: LD_INT 5
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: LIST
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: ST_TO_ADDR
// end ; 2 :
81800: GO 82359
81802: LD_INT 2
81804: DOUBLE
81805: EQUAL
81806: IFTRUE 81810
81808: GO 81939
81810: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
81811: LD_ADDR_VAR 0 5
81815: PUSH
81816: LD_VAR 0 1
81820: PUSH
81821: LD_VAR 0 2
81825: PUSH
81826: LD_INT 3
81828: MINUS
81829: PUSH
81830: LD_INT 3
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: LIST
81837: PUSH
81838: LD_VAR 0 1
81842: PUSH
81843: LD_INT 4
81845: PLUS
81846: PUSH
81847: LD_VAR 0 2
81851: PUSH
81852: LD_INT 4
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: LIST
81859: PUSH
81860: LD_VAR 0 1
81864: PUSH
81865: LD_VAR 0 2
81869: PUSH
81870: LD_INT 4
81872: PLUS
81873: PUSH
81874: LD_INT 0
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: LIST
81881: PUSH
81882: LD_VAR 0 1
81886: PUSH
81887: LD_INT 3
81889: MINUS
81890: PUSH
81891: LD_VAR 0 2
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: LIST
81903: PUSH
81904: LD_VAR 0 1
81908: PUSH
81909: LD_INT 4
81911: MINUS
81912: PUSH
81913: LD_VAR 0 2
81917: PUSH
81918: LD_INT 4
81920: MINUS
81921: PUSH
81922: LD_INT 2
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: LIST
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: ST_TO_ADDR
// end ; 3 :
81937: GO 82359
81939: LD_INT 3
81941: DOUBLE
81942: EQUAL
81943: IFTRUE 81947
81945: GO 82080
81947: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
81948: LD_ADDR_VAR 0 5
81952: PUSH
81953: LD_VAR 0 1
81957: PUSH
81958: LD_INT 3
81960: PLUS
81961: PUSH
81962: LD_VAR 0 2
81966: PUSH
81967: LD_INT 4
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: LIST
81974: PUSH
81975: LD_VAR 0 1
81979: PUSH
81980: LD_INT 4
81982: PLUS
81983: PUSH
81984: LD_VAR 0 2
81988: PUSH
81989: LD_INT 4
81991: PLUS
81992: PUSH
81993: LD_INT 5
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: LIST
82000: PUSH
82001: LD_VAR 0 1
82005: PUSH
82006: LD_INT 4
82008: MINUS
82009: PUSH
82010: LD_VAR 0 2
82014: PUSH
82015: LD_INT 1
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: LIST
82022: PUSH
82023: LD_VAR 0 1
82027: PUSH
82028: LD_VAR 0 2
82032: PUSH
82033: LD_INT 4
82035: MINUS
82036: PUSH
82037: LD_INT 3
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: LIST
82044: PUSH
82045: LD_VAR 0 1
82049: PUSH
82050: LD_INT 3
82052: MINUS
82053: PUSH
82054: LD_VAR 0 2
82058: PUSH
82059: LD_INT 3
82061: MINUS
82062: PUSH
82063: LD_INT 2
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: LIST
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: ST_TO_ADDR
// end ; 4 :
82078: GO 82359
82080: LD_INT 4
82082: DOUBLE
82083: EQUAL
82084: IFTRUE 82088
82086: GO 82221
82088: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
82089: LD_ADDR_VAR 0 5
82093: PUSH
82094: LD_VAR 0 1
82098: PUSH
82099: LD_VAR 0 2
82103: PUSH
82104: LD_INT 4
82106: PLUS
82107: PUSH
82108: LD_INT 0
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: LIST
82115: PUSH
82116: LD_VAR 0 1
82120: PUSH
82121: LD_INT 3
82123: PLUS
82124: PUSH
82125: LD_VAR 0 2
82129: PUSH
82130: LD_INT 3
82132: PLUS
82133: PUSH
82134: LD_INT 5
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: LIST
82141: PUSH
82142: LD_VAR 0 1
82146: PUSH
82147: LD_INT 4
82149: PLUS
82150: PUSH
82151: LD_VAR 0 2
82155: PUSH
82156: LD_INT 4
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: LIST
82163: PUSH
82164: LD_VAR 0 1
82168: PUSH
82169: LD_VAR 0 2
82173: PUSH
82174: LD_INT 3
82176: MINUS
82177: PUSH
82178: LD_INT 3
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: LIST
82185: PUSH
82186: LD_VAR 0 1
82190: PUSH
82191: LD_INT 4
82193: MINUS
82194: PUSH
82195: LD_VAR 0 2
82199: PUSH
82200: LD_INT 4
82202: MINUS
82203: PUSH
82204: LD_INT 2
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: LIST
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: ST_TO_ADDR
// end ; 5 :
82219: GO 82359
82221: LD_INT 5
82223: DOUBLE
82224: EQUAL
82225: IFTRUE 82229
82227: GO 82358
82229: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
82230: LD_ADDR_VAR 0 5
82234: PUSH
82235: LD_VAR 0 1
82239: PUSH
82240: LD_INT 4
82242: MINUS
82243: PUSH
82244: LD_VAR 0 2
82248: PUSH
82249: LD_INT 1
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: LIST
82256: PUSH
82257: LD_VAR 0 1
82261: PUSH
82262: LD_VAR 0 2
82266: PUSH
82267: LD_INT 4
82269: MINUS
82270: PUSH
82271: LD_INT 3
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: LIST
82278: PUSH
82279: LD_VAR 0 1
82283: PUSH
82284: LD_INT 4
82286: PLUS
82287: PUSH
82288: LD_VAR 0 2
82292: PUSH
82293: LD_INT 4
82295: PLUS
82296: PUSH
82297: LD_INT 5
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: LIST
82304: PUSH
82305: LD_VAR 0 1
82309: PUSH
82310: LD_INT 3
82312: PLUS
82313: PUSH
82314: LD_VAR 0 2
82318: PUSH
82319: LD_INT 4
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: LIST
82326: PUSH
82327: LD_VAR 0 1
82331: PUSH
82332: LD_VAR 0 2
82336: PUSH
82337: LD_INT 3
82339: PLUS
82340: PUSH
82341: LD_INT 0
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: LIST
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: ST_TO_ADDR
// end ; end ;
82356: GO 82359
82358: POP
// result := list ;
82359: LD_ADDR_VAR 0 4
82363: PUSH
82364: LD_VAR 0 5
82368: ST_TO_ADDR
// end ;
82369: LD_VAR 0 4
82373: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
82374: LD_INT 0
82376: PPUSH
82377: PPUSH
82378: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
82379: LD_VAR 0 1
82383: NOT
82384: PUSH
82385: LD_VAR 0 2
82389: PUSH
82390: LD_INT 1
82392: PUSH
82393: LD_INT 2
82395: PUSH
82396: LD_INT 3
82398: PUSH
82399: LD_INT 4
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: IN
82408: NOT
82409: OR
82410: IFFALSE 82414
// exit ;
82412: GO 82506
// tmp := [ ] ;
82414: LD_ADDR_VAR 0 5
82418: PUSH
82419: EMPTY
82420: ST_TO_ADDR
// for i in units do
82421: LD_ADDR_VAR 0 4
82425: PUSH
82426: LD_VAR 0 1
82430: PUSH
82431: FOR_IN
82432: IFFALSE 82475
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
82434: LD_ADDR_VAR 0 5
82438: PUSH
82439: LD_VAR 0 5
82443: PPUSH
82444: LD_VAR 0 5
82448: PUSH
82449: LD_INT 1
82451: PLUS
82452: PPUSH
82453: LD_VAR 0 4
82457: PPUSH
82458: LD_VAR 0 2
82462: PPUSH
82463: CALL_OW 259
82467: PPUSH
82468: CALL_OW 2
82472: ST_TO_ADDR
82473: GO 82431
82475: POP
82476: POP
// if not tmp then
82477: LD_VAR 0 5
82481: NOT
82482: IFFALSE 82486
// exit ;
82484: GO 82506
// result := SortListByListDesc ( units , tmp ) ;
82486: LD_ADDR_VAR 0 3
82490: PUSH
82491: LD_VAR 0 1
82495: PPUSH
82496: LD_VAR 0 5
82500: PPUSH
82501: CALL_OW 77
82505: ST_TO_ADDR
// end ;
82506: LD_VAR 0 3
82510: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82511: LD_INT 0
82513: PPUSH
82514: PPUSH
82515: PPUSH
// result := false ;
82516: LD_ADDR_VAR 0 3
82520: PUSH
82521: LD_INT 0
82523: ST_TO_ADDR
// x := GetX ( building ) ;
82524: LD_ADDR_VAR 0 4
82528: PUSH
82529: LD_VAR 0 2
82533: PPUSH
82534: CALL_OW 250
82538: ST_TO_ADDR
// y := GetY ( building ) ;
82539: LD_ADDR_VAR 0 5
82543: PUSH
82544: LD_VAR 0 2
82548: PPUSH
82549: CALL_OW 251
82553: ST_TO_ADDR
// if not building or not x or not y then
82554: LD_VAR 0 2
82558: NOT
82559: PUSH
82560: LD_VAR 0 4
82564: NOT
82565: OR
82566: PUSH
82567: LD_VAR 0 5
82571: NOT
82572: OR
82573: IFFALSE 82577
// exit ;
82575: GO 82669
// if GetTaskList ( unit ) then
82577: LD_VAR 0 1
82581: PPUSH
82582: CALL_OW 437
82586: IFFALSE 82669
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82588: LD_STRING e
82590: PUSH
82591: LD_VAR 0 1
82595: PPUSH
82596: CALL_OW 437
82600: PUSH
82601: LD_INT 1
82603: ARRAY
82604: PUSH
82605: LD_INT 1
82607: ARRAY
82608: EQUAL
82609: PUSH
82610: LD_VAR 0 4
82614: PUSH
82615: LD_VAR 0 1
82619: PPUSH
82620: CALL_OW 437
82624: PUSH
82625: LD_INT 1
82627: ARRAY
82628: PUSH
82629: LD_INT 2
82631: ARRAY
82632: EQUAL
82633: AND
82634: PUSH
82635: LD_VAR 0 5
82639: PUSH
82640: LD_VAR 0 1
82644: PPUSH
82645: CALL_OW 437
82649: PUSH
82650: LD_INT 1
82652: ARRAY
82653: PUSH
82654: LD_INT 3
82656: ARRAY
82657: EQUAL
82658: AND
82659: IFFALSE 82669
// result := true end ;
82661: LD_ADDR_VAR 0 3
82665: PUSH
82666: LD_INT 1
82668: ST_TO_ADDR
// end ;
82669: LD_VAR 0 3
82673: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
82674: LD_INT 0
82676: PPUSH
// result := false ;
82677: LD_ADDR_VAR 0 4
82681: PUSH
82682: LD_INT 0
82684: ST_TO_ADDR
// if GetTaskList ( unit ) then
82685: LD_VAR 0 1
82689: PPUSH
82690: CALL_OW 437
82694: IFFALSE 82777
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82696: LD_STRING M
82698: PUSH
82699: LD_VAR 0 1
82703: PPUSH
82704: CALL_OW 437
82708: PUSH
82709: LD_INT 1
82711: ARRAY
82712: PUSH
82713: LD_INT 1
82715: ARRAY
82716: EQUAL
82717: PUSH
82718: LD_VAR 0 2
82722: PUSH
82723: LD_VAR 0 1
82727: PPUSH
82728: CALL_OW 437
82732: PUSH
82733: LD_INT 1
82735: ARRAY
82736: PUSH
82737: LD_INT 2
82739: ARRAY
82740: EQUAL
82741: AND
82742: PUSH
82743: LD_VAR 0 3
82747: PUSH
82748: LD_VAR 0 1
82752: PPUSH
82753: CALL_OW 437
82757: PUSH
82758: LD_INT 1
82760: ARRAY
82761: PUSH
82762: LD_INT 3
82764: ARRAY
82765: EQUAL
82766: AND
82767: IFFALSE 82777
// result := true ;
82769: LD_ADDR_VAR 0 4
82773: PUSH
82774: LD_INT 1
82776: ST_TO_ADDR
// end ; end ;
82777: LD_VAR 0 4
82781: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
82782: LD_INT 0
82784: PPUSH
82785: PPUSH
82786: PPUSH
82787: PPUSH
// if not unit or not area then
82788: LD_VAR 0 1
82792: NOT
82793: PUSH
82794: LD_VAR 0 2
82798: NOT
82799: OR
82800: IFFALSE 82804
// exit ;
82802: GO 82968
// tmp := AreaToList ( area , i ) ;
82804: LD_ADDR_VAR 0 6
82808: PUSH
82809: LD_VAR 0 2
82813: PPUSH
82814: LD_VAR 0 5
82818: PPUSH
82819: CALL_OW 517
82823: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
82824: LD_ADDR_VAR 0 5
82828: PUSH
82829: DOUBLE
82830: LD_INT 1
82832: DEC
82833: ST_TO_ADDR
82834: LD_VAR 0 6
82838: PUSH
82839: LD_INT 1
82841: ARRAY
82842: PUSH
82843: FOR_TO
82844: IFFALSE 82966
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
82846: LD_ADDR_VAR 0 7
82850: PUSH
82851: LD_VAR 0 6
82855: PUSH
82856: LD_INT 1
82858: ARRAY
82859: PUSH
82860: LD_VAR 0 5
82864: ARRAY
82865: PUSH
82866: LD_VAR 0 6
82870: PUSH
82871: LD_INT 2
82873: ARRAY
82874: PUSH
82875: LD_VAR 0 5
82879: ARRAY
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
82885: LD_VAR 0 7
82889: PUSH
82890: LD_INT 1
82892: ARRAY
82893: PPUSH
82894: LD_VAR 0 7
82898: PUSH
82899: LD_INT 2
82901: ARRAY
82902: PPUSH
82903: CALL_OW 428
82907: PUSH
82908: LD_INT 0
82910: EQUAL
82911: IFFALSE 82964
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
82913: LD_VAR 0 1
82917: PPUSH
82918: LD_VAR 0 7
82922: PUSH
82923: LD_INT 1
82925: ARRAY
82926: PPUSH
82927: LD_VAR 0 7
82931: PUSH
82932: LD_INT 2
82934: ARRAY
82935: PPUSH
82936: LD_VAR 0 3
82940: PPUSH
82941: CALL_OW 48
// result := IsPlaced ( unit ) ;
82945: LD_ADDR_VAR 0 4
82949: PUSH
82950: LD_VAR 0 1
82954: PPUSH
82955: CALL_OW 305
82959: ST_TO_ADDR
// exit ;
82960: POP
82961: POP
82962: GO 82968
// end ; end ;
82964: GO 82843
82966: POP
82967: POP
// end ;
82968: LD_VAR 0 4
82972: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
82973: LD_INT 0
82975: PPUSH
82976: PPUSH
82977: PPUSH
// if not side or side > 8 then
82978: LD_VAR 0 1
82982: NOT
82983: PUSH
82984: LD_VAR 0 1
82988: PUSH
82989: LD_INT 8
82991: GREATER
82992: OR
82993: IFFALSE 82997
// exit ;
82995: GO 83184
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
82997: LD_ADDR_VAR 0 4
83001: PUSH
83002: LD_INT 22
83004: PUSH
83005: LD_VAR 0 1
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 21
83016: PUSH
83017: LD_INT 3
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PPUSH
83028: CALL_OW 69
83032: ST_TO_ADDR
// if not tmp then
83033: LD_VAR 0 4
83037: NOT
83038: IFFALSE 83042
// exit ;
83040: GO 83184
// enable_addtolog := true ;
83042: LD_ADDR_OWVAR 81
83046: PUSH
83047: LD_INT 1
83049: ST_TO_ADDR
// AddToLog ( [ ) ;
83050: LD_STRING [
83052: PPUSH
83053: CALL_OW 561
// for i in tmp do
83057: LD_ADDR_VAR 0 3
83061: PUSH
83062: LD_VAR 0 4
83066: PUSH
83067: FOR_IN
83068: IFFALSE 83175
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
83070: LD_STRING [
83072: PUSH
83073: LD_VAR 0 3
83077: PPUSH
83078: CALL_OW 266
83082: STR
83083: PUSH
83084: LD_STRING , 
83086: STR
83087: PUSH
83088: LD_VAR 0 3
83092: PPUSH
83093: CALL_OW 250
83097: STR
83098: PUSH
83099: LD_STRING , 
83101: STR
83102: PUSH
83103: LD_VAR 0 3
83107: PPUSH
83108: CALL_OW 251
83112: STR
83113: PUSH
83114: LD_STRING , 
83116: STR
83117: PUSH
83118: LD_VAR 0 3
83122: PPUSH
83123: CALL_OW 254
83127: STR
83128: PUSH
83129: LD_STRING , 
83131: STR
83132: PUSH
83133: LD_VAR 0 3
83137: PPUSH
83138: LD_INT 1
83140: PPUSH
83141: CALL_OW 268
83145: STR
83146: PUSH
83147: LD_STRING , 
83149: STR
83150: PUSH
83151: LD_VAR 0 3
83155: PPUSH
83156: LD_INT 2
83158: PPUSH
83159: CALL_OW 268
83163: STR
83164: PUSH
83165: LD_STRING ],
83167: STR
83168: PPUSH
83169: CALL_OW 561
// end ;
83173: GO 83067
83175: POP
83176: POP
// AddToLog ( ]; ) ;
83177: LD_STRING ];
83179: PPUSH
83180: CALL_OW 561
// end ;
83184: LD_VAR 0 2
83188: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
83189: LD_INT 0
83191: PPUSH
83192: PPUSH
83193: PPUSH
83194: PPUSH
83195: PPUSH
// if not area or not rate or not max then
83196: LD_VAR 0 1
83200: NOT
83201: PUSH
83202: LD_VAR 0 2
83206: NOT
83207: OR
83208: PUSH
83209: LD_VAR 0 4
83213: NOT
83214: OR
83215: IFFALSE 83219
// exit ;
83217: GO 83411
// while 1 do
83219: LD_INT 1
83221: IFFALSE 83411
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
83223: LD_ADDR_VAR 0 9
83227: PUSH
83228: LD_VAR 0 1
83232: PPUSH
83233: LD_INT 1
83235: PPUSH
83236: CALL_OW 287
83240: PUSH
83241: LD_INT 10
83243: MUL
83244: ST_TO_ADDR
// r := rate / 10 ;
83245: LD_ADDR_VAR 0 7
83249: PUSH
83250: LD_VAR 0 2
83254: PUSH
83255: LD_INT 10
83257: DIVREAL
83258: ST_TO_ADDR
// time := 1 1$00 ;
83259: LD_ADDR_VAR 0 8
83263: PUSH
83264: LD_INT 2100
83266: ST_TO_ADDR
// if amount < min then
83267: LD_VAR 0 9
83271: PUSH
83272: LD_VAR 0 3
83276: LESS
83277: IFFALSE 83295
// r := r * 2 else
83279: LD_ADDR_VAR 0 7
83283: PUSH
83284: LD_VAR 0 7
83288: PUSH
83289: LD_INT 2
83291: MUL
83292: ST_TO_ADDR
83293: GO 83321
// if amount > max then
83295: LD_VAR 0 9
83299: PUSH
83300: LD_VAR 0 4
83304: GREATER
83305: IFFALSE 83321
// r := r / 2 ;
83307: LD_ADDR_VAR 0 7
83311: PUSH
83312: LD_VAR 0 7
83316: PUSH
83317: LD_INT 2
83319: DIVREAL
83320: ST_TO_ADDR
// time := time / r ;
83321: LD_ADDR_VAR 0 8
83325: PUSH
83326: LD_VAR 0 8
83330: PUSH
83331: LD_VAR 0 7
83335: DIVREAL
83336: ST_TO_ADDR
// if time < 0 then
83337: LD_VAR 0 8
83341: PUSH
83342: LD_INT 0
83344: LESS
83345: IFFALSE 83362
// time := time * - 1 ;
83347: LD_ADDR_VAR 0 8
83351: PUSH
83352: LD_VAR 0 8
83356: PUSH
83357: LD_INT 1
83359: NEG
83360: MUL
83361: ST_TO_ADDR
// wait ( time ) ;
83362: LD_VAR 0 8
83366: PPUSH
83367: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
83371: LD_INT 35
83373: PPUSH
83374: LD_INT 875
83376: PPUSH
83377: CALL_OW 12
83381: PPUSH
83382: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
83386: LD_INT 1
83388: PPUSH
83389: LD_INT 5
83391: PPUSH
83392: CALL_OW 12
83396: PPUSH
83397: LD_VAR 0 1
83401: PPUSH
83402: LD_INT 1
83404: PPUSH
83405: CALL_OW 55
// end ;
83409: GO 83219
// end ;
83411: LD_VAR 0 5
83415: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
83416: LD_INT 0
83418: PPUSH
83419: PPUSH
83420: PPUSH
83421: PPUSH
83422: PPUSH
83423: PPUSH
83424: PPUSH
83425: PPUSH
// if not turrets or not factories then
83426: LD_VAR 0 1
83430: NOT
83431: PUSH
83432: LD_VAR 0 2
83436: NOT
83437: OR
83438: IFFALSE 83442
// exit ;
83440: GO 83749
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
83442: LD_ADDR_VAR 0 10
83446: PUSH
83447: LD_INT 5
83449: PUSH
83450: LD_INT 6
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 2
83459: PUSH
83460: LD_INT 4
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 3
83469: PUSH
83470: LD_INT 5
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: LIST
83481: PUSH
83482: LD_INT 24
83484: PUSH
83485: LD_INT 25
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: LD_INT 23
83494: PUSH
83495: LD_INT 27
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 42
83508: PUSH
83509: LD_INT 43
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 44
83518: PUSH
83519: LD_INT 46
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: LD_INT 45
83528: PUSH
83529: LD_INT 47
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: LIST
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: LIST
83545: ST_TO_ADDR
// result := [ ] ;
83546: LD_ADDR_VAR 0 3
83550: PUSH
83551: EMPTY
83552: ST_TO_ADDR
// for i in turrets do
83553: LD_ADDR_VAR 0 4
83557: PUSH
83558: LD_VAR 0 1
83562: PUSH
83563: FOR_IN
83564: IFFALSE 83747
// begin nat := GetNation ( i ) ;
83566: LD_ADDR_VAR 0 7
83570: PUSH
83571: LD_VAR 0 4
83575: PPUSH
83576: CALL_OW 248
83580: ST_TO_ADDR
// weapon := 0 ;
83581: LD_ADDR_VAR 0 8
83585: PUSH
83586: LD_INT 0
83588: ST_TO_ADDR
// if not nat then
83589: LD_VAR 0 7
83593: NOT
83594: IFFALSE 83598
// continue ;
83596: GO 83563
// for j in list [ nat ] do
83598: LD_ADDR_VAR 0 5
83602: PUSH
83603: LD_VAR 0 10
83607: PUSH
83608: LD_VAR 0 7
83612: ARRAY
83613: PUSH
83614: FOR_IN
83615: IFFALSE 83656
// if GetBWeapon ( i ) = j [ 1 ] then
83617: LD_VAR 0 4
83621: PPUSH
83622: CALL_OW 269
83626: PUSH
83627: LD_VAR 0 5
83631: PUSH
83632: LD_INT 1
83634: ARRAY
83635: EQUAL
83636: IFFALSE 83654
// begin weapon := j [ 2 ] ;
83638: LD_ADDR_VAR 0 8
83642: PUSH
83643: LD_VAR 0 5
83647: PUSH
83648: LD_INT 2
83650: ARRAY
83651: ST_TO_ADDR
// break ;
83652: GO 83656
// end ;
83654: GO 83614
83656: POP
83657: POP
// if not weapon then
83658: LD_VAR 0 8
83662: NOT
83663: IFFALSE 83667
// continue ;
83665: GO 83563
// for k in factories do
83667: LD_ADDR_VAR 0 6
83671: PUSH
83672: LD_VAR 0 2
83676: PUSH
83677: FOR_IN
83678: IFFALSE 83743
// begin weapons := AvailableWeaponList ( k ) ;
83680: LD_ADDR_VAR 0 9
83684: PUSH
83685: LD_VAR 0 6
83689: PPUSH
83690: CALL_OW 478
83694: ST_TO_ADDR
// if not weapons then
83695: LD_VAR 0 9
83699: NOT
83700: IFFALSE 83704
// continue ;
83702: GO 83677
// if weapon in weapons then
83704: LD_VAR 0 8
83708: PUSH
83709: LD_VAR 0 9
83713: IN
83714: IFFALSE 83741
// begin result := [ i , weapon ] ;
83716: LD_ADDR_VAR 0 3
83720: PUSH
83721: LD_VAR 0 4
83725: PUSH
83726: LD_VAR 0 8
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: ST_TO_ADDR
// exit ;
83735: POP
83736: POP
83737: POP
83738: POP
83739: GO 83749
// end ; end ;
83741: GO 83677
83743: POP
83744: POP
// end ;
83745: GO 83563
83747: POP
83748: POP
// end ;
83749: LD_VAR 0 3
83753: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
83754: LD_INT 0
83756: PPUSH
// if not side or side > 8 then
83757: LD_VAR 0 3
83761: NOT
83762: PUSH
83763: LD_VAR 0 3
83767: PUSH
83768: LD_INT 8
83770: GREATER
83771: OR
83772: IFFALSE 83776
// exit ;
83774: GO 83835
// if not range then
83776: LD_VAR 0 4
83780: NOT
83781: IFFALSE 83792
// range := - 12 ;
83783: LD_ADDR_VAR 0 4
83787: PUSH
83788: LD_INT 12
83790: NEG
83791: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
83792: LD_VAR 0 1
83796: PPUSH
83797: LD_VAR 0 2
83801: PPUSH
83802: LD_VAR 0 3
83806: PPUSH
83807: LD_VAR 0 4
83811: PPUSH
83812: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
83816: LD_VAR 0 1
83820: PPUSH
83821: LD_VAR 0 2
83825: PPUSH
83826: LD_VAR 0 3
83830: PPUSH
83831: CALL_OW 331
// end ;
83835: LD_VAR 0 5
83839: RET
// export function Video ( mode ) ; begin
83840: LD_INT 0
83842: PPUSH
// ingame_video = mode ;
83843: LD_ADDR_OWVAR 52
83847: PUSH
83848: LD_VAR 0 1
83852: ST_TO_ADDR
// interface_hidden = mode ;
83853: LD_ADDR_OWVAR 54
83857: PUSH
83858: LD_VAR 0 1
83862: ST_TO_ADDR
// end ;
83863: LD_VAR 0 2
83867: RET
// export function Join ( array , element ) ; begin
83868: LD_INT 0
83870: PPUSH
// result := Replace ( array , array + 1 , element ) ;
83871: LD_ADDR_VAR 0 3
83875: PUSH
83876: LD_VAR 0 1
83880: PPUSH
83881: LD_VAR 0 1
83885: PUSH
83886: LD_INT 1
83888: PLUS
83889: PPUSH
83890: LD_VAR 0 2
83894: PPUSH
83895: CALL_OW 1
83899: ST_TO_ADDR
// end ;
83900: LD_VAR 0 3
83904: RET
// export function JoinUnion ( array , element ) ; begin
83905: LD_INT 0
83907: PPUSH
// result := array union element ;
83908: LD_ADDR_VAR 0 3
83912: PUSH
83913: LD_VAR 0 1
83917: PUSH
83918: LD_VAR 0 2
83922: UNION
83923: ST_TO_ADDR
// end ;
83924: LD_VAR 0 3
83928: RET
// export function GetBehemoths ( side ) ; begin
83929: LD_INT 0
83931: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
83932: LD_ADDR_VAR 0 2
83936: PUSH
83937: LD_INT 22
83939: PUSH
83940: LD_VAR 0 1
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 31
83951: PUSH
83952: LD_INT 25
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PPUSH
83963: CALL_OW 69
83967: ST_TO_ADDR
// end ;
83968: LD_VAR 0 2
83972: RET
// export function Shuffle ( array ) ; var i , index ; begin
83973: LD_INT 0
83975: PPUSH
83976: PPUSH
83977: PPUSH
// result := [ ] ;
83978: LD_ADDR_VAR 0 2
83982: PUSH
83983: EMPTY
83984: ST_TO_ADDR
// if not array then
83985: LD_VAR 0 1
83989: NOT
83990: IFFALSE 83994
// exit ;
83992: GO 84093
// Randomize ;
83994: CALL_OW 10
// for i = array downto 1 do
83998: LD_ADDR_VAR 0 3
84002: PUSH
84003: DOUBLE
84004: LD_VAR 0 1
84008: INC
84009: ST_TO_ADDR
84010: LD_INT 1
84012: PUSH
84013: FOR_DOWNTO
84014: IFFALSE 84091
// begin index := rand ( 1 , array ) ;
84016: LD_ADDR_VAR 0 4
84020: PUSH
84021: LD_INT 1
84023: PPUSH
84024: LD_VAR 0 1
84028: PPUSH
84029: CALL_OW 12
84033: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
84034: LD_ADDR_VAR 0 2
84038: PUSH
84039: LD_VAR 0 2
84043: PPUSH
84044: LD_VAR 0 2
84048: PUSH
84049: LD_INT 1
84051: PLUS
84052: PPUSH
84053: LD_VAR 0 1
84057: PUSH
84058: LD_VAR 0 4
84062: ARRAY
84063: PPUSH
84064: CALL_OW 2
84068: ST_TO_ADDR
// array := Delete ( array , index ) ;
84069: LD_ADDR_VAR 0 1
84073: PUSH
84074: LD_VAR 0 1
84078: PPUSH
84079: LD_VAR 0 4
84083: PPUSH
84084: CALL_OW 3
84088: ST_TO_ADDR
// end ;
84089: GO 84013
84091: POP
84092: POP
// end ;
84093: LD_VAR 0 2
84097: RET
// export function GetBaseMaterials ( base ) ; begin
84098: LD_INT 0
84100: PPUSH
// result := [ 0 , 0 , 0 ] ;
84101: LD_ADDR_VAR 0 2
84105: PUSH
84106: LD_INT 0
84108: PUSH
84109: LD_INT 0
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: LIST
84119: ST_TO_ADDR
// if not base then
84120: LD_VAR 0 1
84124: NOT
84125: IFFALSE 84129
// exit ;
84127: GO 84178
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
84129: LD_ADDR_VAR 0 2
84133: PUSH
84134: LD_VAR 0 1
84138: PPUSH
84139: LD_INT 1
84141: PPUSH
84142: CALL_OW 275
84146: PUSH
84147: LD_VAR 0 1
84151: PPUSH
84152: LD_INT 2
84154: PPUSH
84155: CALL_OW 275
84159: PUSH
84160: LD_VAR 0 1
84164: PPUSH
84165: LD_INT 3
84167: PPUSH
84168: CALL_OW 275
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: LIST
84177: ST_TO_ADDR
// end ;
84178: LD_VAR 0 2
84182: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
84183: LD_INT 0
84185: PPUSH
84186: PPUSH
// result := array ;
84187: LD_ADDR_VAR 0 3
84191: PUSH
84192: LD_VAR 0 1
84196: ST_TO_ADDR
// if size > 0 then
84197: LD_VAR 0 2
84201: PUSH
84202: LD_INT 0
84204: GREATER
84205: IFFALSE 84251
// for i := array downto size do
84207: LD_ADDR_VAR 0 4
84211: PUSH
84212: DOUBLE
84213: LD_VAR 0 1
84217: INC
84218: ST_TO_ADDR
84219: LD_VAR 0 2
84223: PUSH
84224: FOR_DOWNTO
84225: IFFALSE 84249
// result := Delete ( result , result ) ;
84227: LD_ADDR_VAR 0 3
84231: PUSH
84232: LD_VAR 0 3
84236: PPUSH
84237: LD_VAR 0 3
84241: PPUSH
84242: CALL_OW 3
84246: ST_TO_ADDR
84247: GO 84224
84249: POP
84250: POP
// end ;
84251: LD_VAR 0 3
84255: RET
// export function ComExit ( unit ) ; var tmp ; begin
84256: LD_INT 0
84258: PPUSH
84259: PPUSH
// if not IsInUnit ( unit ) then
84260: LD_VAR 0 1
84264: PPUSH
84265: CALL_OW 310
84269: NOT
84270: IFFALSE 84274
// exit ;
84272: GO 84334
// tmp := IsInUnit ( unit ) ;
84274: LD_ADDR_VAR 0 3
84278: PUSH
84279: LD_VAR 0 1
84283: PPUSH
84284: CALL_OW 310
84288: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
84289: LD_VAR 0 3
84293: PPUSH
84294: CALL_OW 247
84298: PUSH
84299: LD_INT 2
84301: EQUAL
84302: IFFALSE 84315
// ComExitVehicle ( unit ) else
84304: LD_VAR 0 1
84308: PPUSH
84309: CALL_OW 121
84313: GO 84324
// ComExitBuilding ( unit ) ;
84315: LD_VAR 0 1
84319: PPUSH
84320: CALL_OW 122
// result := tmp ;
84324: LD_ADDR_VAR 0 2
84328: PUSH
84329: LD_VAR 0 3
84333: ST_TO_ADDR
// end ;
84334: LD_VAR 0 2
84338: RET
// export function ResetHc ; begin
84339: LD_INT 0
84341: PPUSH
// InitHc ;
84342: CALL_OW 19
// hc_importance := 0 ;
84346: LD_ADDR_OWVAR 32
84350: PUSH
84351: LD_INT 0
84353: ST_TO_ADDR
// end ;
84354: LD_VAR 0 1
84358: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
84359: LD_INT 0
84361: PPUSH
84362: PPUSH
84363: PPUSH
// _x := ( x1 + x2 ) div 2 ;
84364: LD_ADDR_VAR 0 6
84368: PUSH
84369: LD_VAR 0 1
84373: PUSH
84374: LD_VAR 0 3
84378: PLUS
84379: PUSH
84380: LD_INT 2
84382: DIV
84383: ST_TO_ADDR
// if _x < 0 then
84384: LD_VAR 0 6
84388: PUSH
84389: LD_INT 0
84391: LESS
84392: IFFALSE 84409
// _x := _x * - 1 ;
84394: LD_ADDR_VAR 0 6
84398: PUSH
84399: LD_VAR 0 6
84403: PUSH
84404: LD_INT 1
84406: NEG
84407: MUL
84408: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
84409: LD_ADDR_VAR 0 7
84413: PUSH
84414: LD_VAR 0 2
84418: PUSH
84419: LD_VAR 0 4
84423: PLUS
84424: PUSH
84425: LD_INT 2
84427: DIV
84428: ST_TO_ADDR
// if _y < 0 then
84429: LD_VAR 0 7
84433: PUSH
84434: LD_INT 0
84436: LESS
84437: IFFALSE 84454
// _y := _y * - 1 ;
84439: LD_ADDR_VAR 0 7
84443: PUSH
84444: LD_VAR 0 7
84448: PUSH
84449: LD_INT 1
84451: NEG
84452: MUL
84453: ST_TO_ADDR
// result := [ _x , _y ] ;
84454: LD_ADDR_VAR 0 5
84458: PUSH
84459: LD_VAR 0 6
84463: PUSH
84464: LD_VAR 0 7
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: ST_TO_ADDR
// end ;
84473: LD_VAR 0 5
84477: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
84478: LD_INT 0
84480: PPUSH
84481: PPUSH
84482: PPUSH
84483: PPUSH
// task := GetTaskList ( unit ) ;
84484: LD_ADDR_VAR 0 7
84488: PUSH
84489: LD_VAR 0 1
84493: PPUSH
84494: CALL_OW 437
84498: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
84499: LD_VAR 0 7
84503: NOT
84504: PUSH
84505: LD_VAR 0 1
84509: PPUSH
84510: LD_VAR 0 2
84514: PPUSH
84515: CALL_OW 308
84519: NOT
84520: AND
84521: IFFALSE 84525
// exit ;
84523: GO 84643
// if IsInArea ( unit , area ) then
84525: LD_VAR 0 1
84529: PPUSH
84530: LD_VAR 0 2
84534: PPUSH
84535: CALL_OW 308
84539: IFFALSE 84557
// begin ComMoveToArea ( unit , goAway ) ;
84541: LD_VAR 0 1
84545: PPUSH
84546: LD_VAR 0 3
84550: PPUSH
84551: CALL_OW 113
// exit ;
84555: GO 84643
// end ; if task [ 1 ] [ 1 ] <> M then
84557: LD_VAR 0 7
84561: PUSH
84562: LD_INT 1
84564: ARRAY
84565: PUSH
84566: LD_INT 1
84568: ARRAY
84569: PUSH
84570: LD_STRING M
84572: NONEQUAL
84573: IFFALSE 84577
// exit ;
84575: GO 84643
// x := task [ 1 ] [ 2 ] ;
84577: LD_ADDR_VAR 0 5
84581: PUSH
84582: LD_VAR 0 7
84586: PUSH
84587: LD_INT 1
84589: ARRAY
84590: PUSH
84591: LD_INT 2
84593: ARRAY
84594: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
84595: LD_ADDR_VAR 0 6
84599: PUSH
84600: LD_VAR 0 7
84604: PUSH
84605: LD_INT 1
84607: ARRAY
84608: PUSH
84609: LD_INT 3
84611: ARRAY
84612: ST_TO_ADDR
// if InArea ( x , y , area ) then
84613: LD_VAR 0 5
84617: PPUSH
84618: LD_VAR 0 6
84622: PPUSH
84623: LD_VAR 0 2
84627: PPUSH
84628: CALL_OW 309
84632: IFFALSE 84643
// ComStop ( unit ) ;
84634: LD_VAR 0 1
84638: PPUSH
84639: CALL_OW 141
// end ;
84643: LD_VAR 0 4
84647: RET
// export function Abs ( value ) ; begin
84648: LD_INT 0
84650: PPUSH
// result := value ;
84651: LD_ADDR_VAR 0 2
84655: PUSH
84656: LD_VAR 0 1
84660: ST_TO_ADDR
// if value < 0 then
84661: LD_VAR 0 1
84665: PUSH
84666: LD_INT 0
84668: LESS
84669: IFFALSE 84686
// result := value * - 1 ;
84671: LD_ADDR_VAR 0 2
84675: PUSH
84676: LD_VAR 0 1
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: MUL
84685: ST_TO_ADDR
// end ;
84686: LD_VAR 0 2
84690: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
84691: LD_INT 0
84693: PPUSH
84694: PPUSH
84695: PPUSH
84696: PPUSH
84697: PPUSH
84698: PPUSH
84699: PPUSH
84700: PPUSH
// if not unit or not building then
84701: LD_VAR 0 1
84705: NOT
84706: PUSH
84707: LD_VAR 0 2
84711: NOT
84712: OR
84713: IFFALSE 84717
// exit ;
84715: GO 84943
// x := GetX ( building ) ;
84717: LD_ADDR_VAR 0 4
84721: PUSH
84722: LD_VAR 0 2
84726: PPUSH
84727: CALL_OW 250
84731: ST_TO_ADDR
// y := GetY ( building ) ;
84732: LD_ADDR_VAR 0 6
84736: PUSH
84737: LD_VAR 0 2
84741: PPUSH
84742: CALL_OW 251
84746: ST_TO_ADDR
// d := GetDir ( building ) ;
84747: LD_ADDR_VAR 0 8
84751: PUSH
84752: LD_VAR 0 2
84756: PPUSH
84757: CALL_OW 254
84761: ST_TO_ADDR
// r := 4 ;
84762: LD_ADDR_VAR 0 9
84766: PUSH
84767: LD_INT 4
84769: ST_TO_ADDR
// for i := 1 to 5 do
84770: LD_ADDR_VAR 0 10
84774: PUSH
84775: DOUBLE
84776: LD_INT 1
84778: DEC
84779: ST_TO_ADDR
84780: LD_INT 5
84782: PUSH
84783: FOR_TO
84784: IFFALSE 84941
// begin _x := ShiftX ( x , d , r + i ) ;
84786: LD_ADDR_VAR 0 5
84790: PUSH
84791: LD_VAR 0 4
84795: PPUSH
84796: LD_VAR 0 8
84800: PPUSH
84801: LD_VAR 0 9
84805: PUSH
84806: LD_VAR 0 10
84810: PLUS
84811: PPUSH
84812: CALL_OW 272
84816: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
84817: LD_ADDR_VAR 0 7
84821: PUSH
84822: LD_VAR 0 6
84826: PPUSH
84827: LD_VAR 0 8
84831: PPUSH
84832: LD_VAR 0 9
84836: PUSH
84837: LD_VAR 0 10
84841: PLUS
84842: PPUSH
84843: CALL_OW 273
84847: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
84848: LD_VAR 0 5
84852: PPUSH
84853: LD_VAR 0 7
84857: PPUSH
84858: CALL_OW 488
84862: PUSH
84863: LD_VAR 0 5
84867: PPUSH
84868: LD_VAR 0 7
84872: PPUSH
84873: CALL_OW 428
84877: PPUSH
84878: CALL_OW 247
84882: PUSH
84883: LD_INT 3
84885: PUSH
84886: LD_INT 2
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: IN
84893: NOT
84894: AND
84895: IFFALSE 84939
// begin ComMoveXY ( unit , _x , _y ) ;
84897: LD_VAR 0 1
84901: PPUSH
84902: LD_VAR 0 5
84906: PPUSH
84907: LD_VAR 0 7
84911: PPUSH
84912: CALL_OW 111
// result := [ _x , _y ] ;
84916: LD_ADDR_VAR 0 3
84920: PUSH
84921: LD_VAR 0 5
84925: PUSH
84926: LD_VAR 0 7
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: ST_TO_ADDR
// exit ;
84935: POP
84936: POP
84937: GO 84943
// end ; end ;
84939: GO 84783
84941: POP
84942: POP
// end ; end_of_file
84943: LD_VAR 0 3
84947: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
84948: LD_INT 0
84950: PPUSH
// ar_miner := 81 ;
84951: LD_ADDR_EXP 100
84955: PUSH
84956: LD_INT 81
84958: ST_TO_ADDR
// ar_crane := 88 ;
84959: LD_ADDR_EXP 99
84963: PUSH
84964: LD_INT 88
84966: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84967: LD_ADDR_EXP 94
84971: PUSH
84972: LD_INT 89
84974: ST_TO_ADDR
// us_hack := 99 ;
84975: LD_ADDR_EXP 95
84979: PUSH
84980: LD_INT 99
84982: ST_TO_ADDR
// us_artillery := 97 ;
84983: LD_ADDR_EXP 96
84987: PUSH
84988: LD_INT 97
84990: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84991: LD_ADDR_EXP 97
84995: PUSH
84996: LD_INT 91
84998: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
84999: LD_ADDR_EXP 98
85003: PUSH
85004: LD_INT 92
85006: ST_TO_ADDR
// ru_radar := 98 ;
85007: LD_ADDR_EXP 93
85011: PUSH
85012: LD_INT 98
85014: ST_TO_ADDR
// tech_Artillery := 80 ;
85015: LD_ADDR_EXP 101
85019: PUSH
85020: LD_INT 80
85022: ST_TO_ADDR
// tech_RadMat := 81 ;
85023: LD_ADDR_EXP 102
85027: PUSH
85028: LD_INT 81
85030: ST_TO_ADDR
// tech_BasicTools := 82 ;
85031: LD_ADDR_EXP 103
85035: PUSH
85036: LD_INT 82
85038: ST_TO_ADDR
// tech_Cargo := 83 ;
85039: LD_ADDR_EXP 104
85043: PUSH
85044: LD_INT 83
85046: ST_TO_ADDR
// tech_Track := 84 ;
85047: LD_ADDR_EXP 105
85051: PUSH
85052: LD_INT 84
85054: ST_TO_ADDR
// tech_Crane := 85 ;
85055: LD_ADDR_EXP 106
85059: PUSH
85060: LD_INT 85
85062: ST_TO_ADDR
// tech_Bulldozer := 86 ;
85063: LD_ADDR_EXP 107
85067: PUSH
85068: LD_INT 86
85070: ST_TO_ADDR
// tech_Hovercraft := 87 ;
85071: LD_ADDR_EXP 108
85075: PUSH
85076: LD_INT 87
85078: ST_TO_ADDR
// end ;
85079: LD_VAR 0 1
85083: RET
// every 1 do
85084: GO 85086
85086: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85087: CALL 84948 0 0
85091: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
85092: LD_VAR 0 2
85096: PUSH
85097: LD_INT 100
85099: EQUAL
85100: IFFALSE 86049
// begin if not StreamModeActive then
85102: LD_EXP 109
85106: NOT
85107: IFFALSE 85117
// StreamModeActive := true ;
85109: LD_ADDR_EXP 109
85113: PUSH
85114: LD_INT 1
85116: ST_TO_ADDR
// if p3 = 0 then
85117: LD_VAR 0 3
85121: PUSH
85122: LD_INT 0
85124: EQUAL
85125: IFFALSE 85131
// InitStreamMode ;
85127: CALL 86207 0 0
// if p3 = 1 then
85131: LD_VAR 0 3
85135: PUSH
85136: LD_INT 1
85138: EQUAL
85139: IFFALSE 85149
// sRocket := true ;
85141: LD_ADDR_EXP 114
85145: PUSH
85146: LD_INT 1
85148: ST_TO_ADDR
// if p3 = 2 then
85149: LD_VAR 0 3
85153: PUSH
85154: LD_INT 2
85156: EQUAL
85157: IFFALSE 85167
// sSpeed := true ;
85159: LD_ADDR_EXP 113
85163: PUSH
85164: LD_INT 1
85166: ST_TO_ADDR
// if p3 = 3 then
85167: LD_VAR 0 3
85171: PUSH
85172: LD_INT 3
85174: EQUAL
85175: IFFALSE 85185
// sEngine := true ;
85177: LD_ADDR_EXP 115
85181: PUSH
85182: LD_INT 1
85184: ST_TO_ADDR
// if p3 = 4 then
85185: LD_VAR 0 3
85189: PUSH
85190: LD_INT 4
85192: EQUAL
85193: IFFALSE 85203
// sSpec := true ;
85195: LD_ADDR_EXP 112
85199: PUSH
85200: LD_INT 1
85202: ST_TO_ADDR
// if p3 = 5 then
85203: LD_VAR 0 3
85207: PUSH
85208: LD_INT 5
85210: EQUAL
85211: IFFALSE 85221
// sLevel := true ;
85213: LD_ADDR_EXP 116
85217: PUSH
85218: LD_INT 1
85220: ST_TO_ADDR
// if p3 = 6 then
85221: LD_VAR 0 3
85225: PUSH
85226: LD_INT 6
85228: EQUAL
85229: IFFALSE 85239
// sArmoury := true ;
85231: LD_ADDR_EXP 117
85235: PUSH
85236: LD_INT 1
85238: ST_TO_ADDR
// if p3 = 7 then
85239: LD_VAR 0 3
85243: PUSH
85244: LD_INT 7
85246: EQUAL
85247: IFFALSE 85257
// sRadar := true ;
85249: LD_ADDR_EXP 118
85253: PUSH
85254: LD_INT 1
85256: ST_TO_ADDR
// if p3 = 8 then
85257: LD_VAR 0 3
85261: PUSH
85262: LD_INT 8
85264: EQUAL
85265: IFFALSE 85275
// sBunker := true ;
85267: LD_ADDR_EXP 119
85271: PUSH
85272: LD_INT 1
85274: ST_TO_ADDR
// if p3 = 9 then
85275: LD_VAR 0 3
85279: PUSH
85280: LD_INT 9
85282: EQUAL
85283: IFFALSE 85293
// sHack := true ;
85285: LD_ADDR_EXP 120
85289: PUSH
85290: LD_INT 1
85292: ST_TO_ADDR
// if p3 = 10 then
85293: LD_VAR 0 3
85297: PUSH
85298: LD_INT 10
85300: EQUAL
85301: IFFALSE 85311
// sFire := true ;
85303: LD_ADDR_EXP 121
85307: PUSH
85308: LD_INT 1
85310: ST_TO_ADDR
// if p3 = 11 then
85311: LD_VAR 0 3
85315: PUSH
85316: LD_INT 11
85318: EQUAL
85319: IFFALSE 85329
// sRefresh := true ;
85321: LD_ADDR_EXP 122
85325: PUSH
85326: LD_INT 1
85328: ST_TO_ADDR
// if p3 = 12 then
85329: LD_VAR 0 3
85333: PUSH
85334: LD_INT 12
85336: EQUAL
85337: IFFALSE 85347
// sExp := true ;
85339: LD_ADDR_EXP 123
85343: PUSH
85344: LD_INT 1
85346: ST_TO_ADDR
// if p3 = 13 then
85347: LD_VAR 0 3
85351: PUSH
85352: LD_INT 13
85354: EQUAL
85355: IFFALSE 85365
// sDepot := true ;
85357: LD_ADDR_EXP 124
85361: PUSH
85362: LD_INT 1
85364: ST_TO_ADDR
// if p3 = 14 then
85365: LD_VAR 0 3
85369: PUSH
85370: LD_INT 14
85372: EQUAL
85373: IFFALSE 85383
// sFlag := true ;
85375: LD_ADDR_EXP 125
85379: PUSH
85380: LD_INT 1
85382: ST_TO_ADDR
// if p3 = 15 then
85383: LD_VAR 0 3
85387: PUSH
85388: LD_INT 15
85390: EQUAL
85391: IFFALSE 85401
// sKamikadze := true ;
85393: LD_ADDR_EXP 133
85397: PUSH
85398: LD_INT 1
85400: ST_TO_ADDR
// if p3 = 16 then
85401: LD_VAR 0 3
85405: PUSH
85406: LD_INT 16
85408: EQUAL
85409: IFFALSE 85419
// sTroll := true ;
85411: LD_ADDR_EXP 134
85415: PUSH
85416: LD_INT 1
85418: ST_TO_ADDR
// if p3 = 17 then
85419: LD_VAR 0 3
85423: PUSH
85424: LD_INT 17
85426: EQUAL
85427: IFFALSE 85437
// sSlow := true ;
85429: LD_ADDR_EXP 135
85433: PUSH
85434: LD_INT 1
85436: ST_TO_ADDR
// if p3 = 18 then
85437: LD_VAR 0 3
85441: PUSH
85442: LD_INT 18
85444: EQUAL
85445: IFFALSE 85455
// sLack := true ;
85447: LD_ADDR_EXP 136
85451: PUSH
85452: LD_INT 1
85454: ST_TO_ADDR
// if p3 = 19 then
85455: LD_VAR 0 3
85459: PUSH
85460: LD_INT 19
85462: EQUAL
85463: IFFALSE 85473
// sTank := true ;
85465: LD_ADDR_EXP 138
85469: PUSH
85470: LD_INT 1
85472: ST_TO_ADDR
// if p3 = 20 then
85473: LD_VAR 0 3
85477: PUSH
85478: LD_INT 20
85480: EQUAL
85481: IFFALSE 85491
// sRemote := true ;
85483: LD_ADDR_EXP 139
85487: PUSH
85488: LD_INT 1
85490: ST_TO_ADDR
// if p3 = 21 then
85491: LD_VAR 0 3
85495: PUSH
85496: LD_INT 21
85498: EQUAL
85499: IFFALSE 85509
// sPowell := true ;
85501: LD_ADDR_EXP 140
85505: PUSH
85506: LD_INT 1
85508: ST_TO_ADDR
// if p3 = 22 then
85509: LD_VAR 0 3
85513: PUSH
85514: LD_INT 22
85516: EQUAL
85517: IFFALSE 85527
// sTeleport := true ;
85519: LD_ADDR_EXP 143
85523: PUSH
85524: LD_INT 1
85526: ST_TO_ADDR
// if p3 = 23 then
85527: LD_VAR 0 3
85531: PUSH
85532: LD_INT 23
85534: EQUAL
85535: IFFALSE 85545
// sOilTower := true ;
85537: LD_ADDR_EXP 145
85541: PUSH
85542: LD_INT 1
85544: ST_TO_ADDR
// if p3 = 24 then
85545: LD_VAR 0 3
85549: PUSH
85550: LD_INT 24
85552: EQUAL
85553: IFFALSE 85563
// sShovel := true ;
85555: LD_ADDR_EXP 146
85559: PUSH
85560: LD_INT 1
85562: ST_TO_ADDR
// if p3 = 25 then
85563: LD_VAR 0 3
85567: PUSH
85568: LD_INT 25
85570: EQUAL
85571: IFFALSE 85581
// sSheik := true ;
85573: LD_ADDR_EXP 147
85577: PUSH
85578: LD_INT 1
85580: ST_TO_ADDR
// if p3 = 26 then
85581: LD_VAR 0 3
85585: PUSH
85586: LD_INT 26
85588: EQUAL
85589: IFFALSE 85599
// sEarthquake := true ;
85591: LD_ADDR_EXP 149
85595: PUSH
85596: LD_INT 1
85598: ST_TO_ADDR
// if p3 = 27 then
85599: LD_VAR 0 3
85603: PUSH
85604: LD_INT 27
85606: EQUAL
85607: IFFALSE 85617
// sAI := true ;
85609: LD_ADDR_EXP 150
85613: PUSH
85614: LD_INT 1
85616: ST_TO_ADDR
// if p3 = 28 then
85617: LD_VAR 0 3
85621: PUSH
85622: LD_INT 28
85624: EQUAL
85625: IFFALSE 85635
// sCargo := true ;
85627: LD_ADDR_EXP 153
85631: PUSH
85632: LD_INT 1
85634: ST_TO_ADDR
// if p3 = 29 then
85635: LD_VAR 0 3
85639: PUSH
85640: LD_INT 29
85642: EQUAL
85643: IFFALSE 85653
// sDLaser := true ;
85645: LD_ADDR_EXP 154
85649: PUSH
85650: LD_INT 1
85652: ST_TO_ADDR
// if p3 = 30 then
85653: LD_VAR 0 3
85657: PUSH
85658: LD_INT 30
85660: EQUAL
85661: IFFALSE 85671
// sExchange := true ;
85663: LD_ADDR_EXP 155
85667: PUSH
85668: LD_INT 1
85670: ST_TO_ADDR
// if p3 = 31 then
85671: LD_VAR 0 3
85675: PUSH
85676: LD_INT 31
85678: EQUAL
85679: IFFALSE 85689
// sFac := true ;
85681: LD_ADDR_EXP 156
85685: PUSH
85686: LD_INT 1
85688: ST_TO_ADDR
// if p3 = 32 then
85689: LD_VAR 0 3
85693: PUSH
85694: LD_INT 32
85696: EQUAL
85697: IFFALSE 85707
// sPower := true ;
85699: LD_ADDR_EXP 157
85703: PUSH
85704: LD_INT 1
85706: ST_TO_ADDR
// if p3 = 33 then
85707: LD_VAR 0 3
85711: PUSH
85712: LD_INT 33
85714: EQUAL
85715: IFFALSE 85725
// sRandom := true ;
85717: LD_ADDR_EXP 158
85721: PUSH
85722: LD_INT 1
85724: ST_TO_ADDR
// if p3 = 34 then
85725: LD_VAR 0 3
85729: PUSH
85730: LD_INT 34
85732: EQUAL
85733: IFFALSE 85743
// sShield := true ;
85735: LD_ADDR_EXP 159
85739: PUSH
85740: LD_INT 1
85742: ST_TO_ADDR
// if p3 = 35 then
85743: LD_VAR 0 3
85747: PUSH
85748: LD_INT 35
85750: EQUAL
85751: IFFALSE 85761
// sTime := true ;
85753: LD_ADDR_EXP 160
85757: PUSH
85758: LD_INT 1
85760: ST_TO_ADDR
// if p3 = 36 then
85761: LD_VAR 0 3
85765: PUSH
85766: LD_INT 36
85768: EQUAL
85769: IFFALSE 85779
// sTools := true ;
85771: LD_ADDR_EXP 161
85775: PUSH
85776: LD_INT 1
85778: ST_TO_ADDR
// if p3 = 101 then
85779: LD_VAR 0 3
85783: PUSH
85784: LD_INT 101
85786: EQUAL
85787: IFFALSE 85797
// sSold := true ;
85789: LD_ADDR_EXP 126
85793: PUSH
85794: LD_INT 1
85796: ST_TO_ADDR
// if p3 = 102 then
85797: LD_VAR 0 3
85801: PUSH
85802: LD_INT 102
85804: EQUAL
85805: IFFALSE 85815
// sDiff := true ;
85807: LD_ADDR_EXP 127
85811: PUSH
85812: LD_INT 1
85814: ST_TO_ADDR
// if p3 = 103 then
85815: LD_VAR 0 3
85819: PUSH
85820: LD_INT 103
85822: EQUAL
85823: IFFALSE 85833
// sFog := true ;
85825: LD_ADDR_EXP 130
85829: PUSH
85830: LD_INT 1
85832: ST_TO_ADDR
// if p3 = 104 then
85833: LD_VAR 0 3
85837: PUSH
85838: LD_INT 104
85840: EQUAL
85841: IFFALSE 85851
// sReset := true ;
85843: LD_ADDR_EXP 131
85847: PUSH
85848: LD_INT 1
85850: ST_TO_ADDR
// if p3 = 105 then
85851: LD_VAR 0 3
85855: PUSH
85856: LD_INT 105
85858: EQUAL
85859: IFFALSE 85869
// sSun := true ;
85861: LD_ADDR_EXP 132
85865: PUSH
85866: LD_INT 1
85868: ST_TO_ADDR
// if p3 = 106 then
85869: LD_VAR 0 3
85873: PUSH
85874: LD_INT 106
85876: EQUAL
85877: IFFALSE 85887
// sTiger := true ;
85879: LD_ADDR_EXP 128
85883: PUSH
85884: LD_INT 1
85886: ST_TO_ADDR
// if p3 = 107 then
85887: LD_VAR 0 3
85891: PUSH
85892: LD_INT 107
85894: EQUAL
85895: IFFALSE 85905
// sBomb := true ;
85897: LD_ADDR_EXP 129
85901: PUSH
85902: LD_INT 1
85904: ST_TO_ADDR
// if p3 = 108 then
85905: LD_VAR 0 3
85909: PUSH
85910: LD_INT 108
85912: EQUAL
85913: IFFALSE 85923
// sWound := true ;
85915: LD_ADDR_EXP 137
85919: PUSH
85920: LD_INT 1
85922: ST_TO_ADDR
// if p3 = 109 then
85923: LD_VAR 0 3
85927: PUSH
85928: LD_INT 109
85930: EQUAL
85931: IFFALSE 85941
// sBetray := true ;
85933: LD_ADDR_EXP 141
85937: PUSH
85938: LD_INT 1
85940: ST_TO_ADDR
// if p3 = 110 then
85941: LD_VAR 0 3
85945: PUSH
85946: LD_INT 110
85948: EQUAL
85949: IFFALSE 85959
// sContamin := true ;
85951: LD_ADDR_EXP 142
85955: PUSH
85956: LD_INT 1
85958: ST_TO_ADDR
// if p3 = 111 then
85959: LD_VAR 0 3
85963: PUSH
85964: LD_INT 111
85966: EQUAL
85967: IFFALSE 85977
// sOil := true ;
85969: LD_ADDR_EXP 144
85973: PUSH
85974: LD_INT 1
85976: ST_TO_ADDR
// if p3 = 112 then
85977: LD_VAR 0 3
85981: PUSH
85982: LD_INT 112
85984: EQUAL
85985: IFFALSE 85995
// sStu := true ;
85987: LD_ADDR_EXP 148
85991: PUSH
85992: LD_INT 1
85994: ST_TO_ADDR
// if p3 = 113 then
85995: LD_VAR 0 3
85999: PUSH
86000: LD_INT 113
86002: EQUAL
86003: IFFALSE 86013
// sBazooka := true ;
86005: LD_ADDR_EXP 151
86009: PUSH
86010: LD_INT 1
86012: ST_TO_ADDR
// if p3 = 114 then
86013: LD_VAR 0 3
86017: PUSH
86018: LD_INT 114
86020: EQUAL
86021: IFFALSE 86031
// sMortar := true ;
86023: LD_ADDR_EXP 152
86027: PUSH
86028: LD_INT 1
86030: ST_TO_ADDR
// if p3 = 115 then
86031: LD_VAR 0 3
86035: PUSH
86036: LD_INT 115
86038: EQUAL
86039: IFFALSE 86049
// sRanger := true ;
86041: LD_ADDR_EXP 162
86045: PUSH
86046: LD_INT 1
86048: ST_TO_ADDR
// end ; if p2 = 101 then
86049: LD_VAR 0 2
86053: PUSH
86054: LD_INT 101
86056: EQUAL
86057: IFFALSE 86185
// begin case p3 of 1 :
86059: LD_VAR 0 3
86063: PUSH
86064: LD_INT 1
86066: DOUBLE
86067: EQUAL
86068: IFTRUE 86072
86070: GO 86079
86072: POP
// hHackUnlimitedResources ; 2 :
86073: CALL 97220 0 0
86077: GO 86185
86079: LD_INT 2
86081: DOUBLE
86082: EQUAL
86083: IFTRUE 86087
86085: GO 86094
86087: POP
// hHackSetLevel10 ; 3 :
86088: CALL 97353 0 0
86092: GO 86185
86094: LD_INT 3
86096: DOUBLE
86097: EQUAL
86098: IFTRUE 86102
86100: GO 86109
86102: POP
// hHackSetLevel10YourUnits ; 4 :
86103: CALL 97438 0 0
86107: GO 86185
86109: LD_INT 4
86111: DOUBLE
86112: EQUAL
86113: IFTRUE 86117
86115: GO 86124
86117: POP
// hHackInvincible ; 5 :
86118: CALL 97886 0 0
86122: GO 86185
86124: LD_INT 5
86126: DOUBLE
86127: EQUAL
86128: IFTRUE 86132
86130: GO 86139
86132: POP
// hHackInvisible ; 6 :
86133: CALL 97997 0 0
86137: GO 86185
86139: LD_INT 6
86141: DOUBLE
86142: EQUAL
86143: IFTRUE 86147
86145: GO 86154
86147: POP
// hHackChangeYourSide ; 7 :
86148: CALL 98054 0 0
86152: GO 86185
86154: LD_INT 7
86156: DOUBLE
86157: EQUAL
86158: IFTRUE 86162
86160: GO 86169
86162: POP
// hHackChangeUnitSide ; 8 :
86163: CALL 98096 0 0
86167: GO 86185
86169: LD_INT 8
86171: DOUBLE
86172: EQUAL
86173: IFTRUE 86177
86175: GO 86184
86177: POP
// hHackFog ; end ;
86178: CALL 98197 0 0
86182: GO 86185
86184: POP
// end ; end ;
86185: PPOPN 6
86187: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
86188: GO 86190
86190: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86191: LD_STRING initStreamRollete();
86193: PPUSH
86194: CALL_OW 559
// InitStreamMode ;
86198: CALL 86207 0 0
// DefineStreamItems ( ) ;
86202: CALL 86647 0 0
// end ;
86206: END
// function InitStreamMode ; begin
86207: LD_INT 0
86209: PPUSH
// streamModeActive := false ;
86210: LD_ADDR_EXP 109
86214: PUSH
86215: LD_INT 0
86217: ST_TO_ADDR
// normalCounter := 36 ;
86218: LD_ADDR_EXP 110
86222: PUSH
86223: LD_INT 36
86225: ST_TO_ADDR
// hardcoreCounter := 16 ;
86226: LD_ADDR_EXP 111
86230: PUSH
86231: LD_INT 16
86233: ST_TO_ADDR
// sRocket := false ;
86234: LD_ADDR_EXP 114
86238: PUSH
86239: LD_INT 0
86241: ST_TO_ADDR
// sSpeed := false ;
86242: LD_ADDR_EXP 113
86246: PUSH
86247: LD_INT 0
86249: ST_TO_ADDR
// sEngine := false ;
86250: LD_ADDR_EXP 115
86254: PUSH
86255: LD_INT 0
86257: ST_TO_ADDR
// sSpec := false ;
86258: LD_ADDR_EXP 112
86262: PUSH
86263: LD_INT 0
86265: ST_TO_ADDR
// sLevel := false ;
86266: LD_ADDR_EXP 116
86270: PUSH
86271: LD_INT 0
86273: ST_TO_ADDR
// sArmoury := false ;
86274: LD_ADDR_EXP 117
86278: PUSH
86279: LD_INT 0
86281: ST_TO_ADDR
// sRadar := false ;
86282: LD_ADDR_EXP 118
86286: PUSH
86287: LD_INT 0
86289: ST_TO_ADDR
// sBunker := false ;
86290: LD_ADDR_EXP 119
86294: PUSH
86295: LD_INT 0
86297: ST_TO_ADDR
// sHack := false ;
86298: LD_ADDR_EXP 120
86302: PUSH
86303: LD_INT 0
86305: ST_TO_ADDR
// sFire := false ;
86306: LD_ADDR_EXP 121
86310: PUSH
86311: LD_INT 0
86313: ST_TO_ADDR
// sRefresh := false ;
86314: LD_ADDR_EXP 122
86318: PUSH
86319: LD_INT 0
86321: ST_TO_ADDR
// sExp := false ;
86322: LD_ADDR_EXP 123
86326: PUSH
86327: LD_INT 0
86329: ST_TO_ADDR
// sDepot := false ;
86330: LD_ADDR_EXP 124
86334: PUSH
86335: LD_INT 0
86337: ST_TO_ADDR
// sFlag := false ;
86338: LD_ADDR_EXP 125
86342: PUSH
86343: LD_INT 0
86345: ST_TO_ADDR
// sKamikadze := false ;
86346: LD_ADDR_EXP 133
86350: PUSH
86351: LD_INT 0
86353: ST_TO_ADDR
// sTroll := false ;
86354: LD_ADDR_EXP 134
86358: PUSH
86359: LD_INT 0
86361: ST_TO_ADDR
// sSlow := false ;
86362: LD_ADDR_EXP 135
86366: PUSH
86367: LD_INT 0
86369: ST_TO_ADDR
// sLack := false ;
86370: LD_ADDR_EXP 136
86374: PUSH
86375: LD_INT 0
86377: ST_TO_ADDR
// sTank := false ;
86378: LD_ADDR_EXP 138
86382: PUSH
86383: LD_INT 0
86385: ST_TO_ADDR
// sRemote := false ;
86386: LD_ADDR_EXP 139
86390: PUSH
86391: LD_INT 0
86393: ST_TO_ADDR
// sPowell := false ;
86394: LD_ADDR_EXP 140
86398: PUSH
86399: LD_INT 0
86401: ST_TO_ADDR
// sTeleport := false ;
86402: LD_ADDR_EXP 143
86406: PUSH
86407: LD_INT 0
86409: ST_TO_ADDR
// sOilTower := false ;
86410: LD_ADDR_EXP 145
86414: PUSH
86415: LD_INT 0
86417: ST_TO_ADDR
// sShovel := false ;
86418: LD_ADDR_EXP 146
86422: PUSH
86423: LD_INT 0
86425: ST_TO_ADDR
// sSheik := false ;
86426: LD_ADDR_EXP 147
86430: PUSH
86431: LD_INT 0
86433: ST_TO_ADDR
// sEarthquake := false ;
86434: LD_ADDR_EXP 149
86438: PUSH
86439: LD_INT 0
86441: ST_TO_ADDR
// sAI := false ;
86442: LD_ADDR_EXP 150
86446: PUSH
86447: LD_INT 0
86449: ST_TO_ADDR
// sCargo := false ;
86450: LD_ADDR_EXP 153
86454: PUSH
86455: LD_INT 0
86457: ST_TO_ADDR
// sDLaser := false ;
86458: LD_ADDR_EXP 154
86462: PUSH
86463: LD_INT 0
86465: ST_TO_ADDR
// sExchange := false ;
86466: LD_ADDR_EXP 155
86470: PUSH
86471: LD_INT 0
86473: ST_TO_ADDR
// sFac := false ;
86474: LD_ADDR_EXP 156
86478: PUSH
86479: LD_INT 0
86481: ST_TO_ADDR
// sPower := false ;
86482: LD_ADDR_EXP 157
86486: PUSH
86487: LD_INT 0
86489: ST_TO_ADDR
// sRandom := false ;
86490: LD_ADDR_EXP 158
86494: PUSH
86495: LD_INT 0
86497: ST_TO_ADDR
// sShield := false ;
86498: LD_ADDR_EXP 159
86502: PUSH
86503: LD_INT 0
86505: ST_TO_ADDR
// sTime := false ;
86506: LD_ADDR_EXP 160
86510: PUSH
86511: LD_INT 0
86513: ST_TO_ADDR
// sTools := false ;
86514: LD_ADDR_EXP 161
86518: PUSH
86519: LD_INT 0
86521: ST_TO_ADDR
// sSold := false ;
86522: LD_ADDR_EXP 126
86526: PUSH
86527: LD_INT 0
86529: ST_TO_ADDR
// sDiff := false ;
86530: LD_ADDR_EXP 127
86534: PUSH
86535: LD_INT 0
86537: ST_TO_ADDR
// sFog := false ;
86538: LD_ADDR_EXP 130
86542: PUSH
86543: LD_INT 0
86545: ST_TO_ADDR
// sReset := false ;
86546: LD_ADDR_EXP 131
86550: PUSH
86551: LD_INT 0
86553: ST_TO_ADDR
// sSun := false ;
86554: LD_ADDR_EXP 132
86558: PUSH
86559: LD_INT 0
86561: ST_TO_ADDR
// sTiger := false ;
86562: LD_ADDR_EXP 128
86566: PUSH
86567: LD_INT 0
86569: ST_TO_ADDR
// sBomb := false ;
86570: LD_ADDR_EXP 129
86574: PUSH
86575: LD_INT 0
86577: ST_TO_ADDR
// sWound := false ;
86578: LD_ADDR_EXP 137
86582: PUSH
86583: LD_INT 0
86585: ST_TO_ADDR
// sBetray := false ;
86586: LD_ADDR_EXP 141
86590: PUSH
86591: LD_INT 0
86593: ST_TO_ADDR
// sContamin := false ;
86594: LD_ADDR_EXP 142
86598: PUSH
86599: LD_INT 0
86601: ST_TO_ADDR
// sOil := false ;
86602: LD_ADDR_EXP 144
86606: PUSH
86607: LD_INT 0
86609: ST_TO_ADDR
// sStu := false ;
86610: LD_ADDR_EXP 148
86614: PUSH
86615: LD_INT 0
86617: ST_TO_ADDR
// sBazooka := false ;
86618: LD_ADDR_EXP 151
86622: PUSH
86623: LD_INT 0
86625: ST_TO_ADDR
// sMortar := false ;
86626: LD_ADDR_EXP 152
86630: PUSH
86631: LD_INT 0
86633: ST_TO_ADDR
// sRanger := false ;
86634: LD_ADDR_EXP 162
86638: PUSH
86639: LD_INT 0
86641: ST_TO_ADDR
// end ;
86642: LD_VAR 0 1
86646: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
86647: LD_INT 0
86649: PPUSH
86650: PPUSH
86651: PPUSH
86652: PPUSH
86653: PPUSH
// result := [ ] ;
86654: LD_ADDR_VAR 0 1
86658: PUSH
86659: EMPTY
86660: ST_TO_ADDR
// if campaign_id = 1 then
86661: LD_OWVAR 69
86665: PUSH
86666: LD_INT 1
86668: EQUAL
86669: IFFALSE 89607
// begin case mission_number of 1 :
86671: LD_OWVAR 70
86675: PUSH
86676: LD_INT 1
86678: DOUBLE
86679: EQUAL
86680: IFTRUE 86684
86682: GO 86748
86684: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
86685: LD_ADDR_VAR 0 1
86689: PUSH
86690: LD_INT 2
86692: PUSH
86693: LD_INT 4
86695: PUSH
86696: LD_INT 11
86698: PUSH
86699: LD_INT 12
86701: PUSH
86702: LD_INT 15
86704: PUSH
86705: LD_INT 16
86707: PUSH
86708: LD_INT 22
86710: PUSH
86711: LD_INT 23
86713: PUSH
86714: LD_INT 26
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 101
86730: PUSH
86731: LD_INT 102
86733: PUSH
86734: LD_INT 106
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: LIST
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: ST_TO_ADDR
86746: GO 89605
86748: LD_INT 2
86750: DOUBLE
86751: EQUAL
86752: IFTRUE 86756
86754: GO 86828
86756: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
86757: LD_ADDR_VAR 0 1
86761: PUSH
86762: LD_INT 2
86764: PUSH
86765: LD_INT 4
86767: PUSH
86768: LD_INT 11
86770: PUSH
86771: LD_INT 12
86773: PUSH
86774: LD_INT 15
86776: PUSH
86777: LD_INT 16
86779: PUSH
86780: LD_INT 22
86782: PUSH
86783: LD_INT 23
86785: PUSH
86786: LD_INT 26
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 101
86802: PUSH
86803: LD_INT 102
86805: PUSH
86806: LD_INT 105
86808: PUSH
86809: LD_INT 106
86811: PUSH
86812: LD_INT 108
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: LIST
86819: LIST
86820: LIST
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: ST_TO_ADDR
86826: GO 89605
86828: LD_INT 3
86830: DOUBLE
86831: EQUAL
86832: IFTRUE 86836
86834: GO 86912
86836: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
86837: LD_ADDR_VAR 0 1
86841: PUSH
86842: LD_INT 2
86844: PUSH
86845: LD_INT 4
86847: PUSH
86848: LD_INT 5
86850: PUSH
86851: LD_INT 11
86853: PUSH
86854: LD_INT 12
86856: PUSH
86857: LD_INT 15
86859: PUSH
86860: LD_INT 16
86862: PUSH
86863: LD_INT 22
86865: PUSH
86866: LD_INT 26
86868: PUSH
86869: LD_INT 36
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 101
86886: PUSH
86887: LD_INT 102
86889: PUSH
86890: LD_INT 105
86892: PUSH
86893: LD_INT 106
86895: PUSH
86896: LD_INT 108
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: ST_TO_ADDR
86910: GO 89605
86912: LD_INT 4
86914: DOUBLE
86915: EQUAL
86916: IFTRUE 86920
86918: GO 87004
86920: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
86921: LD_ADDR_VAR 0 1
86925: PUSH
86926: LD_INT 2
86928: PUSH
86929: LD_INT 4
86931: PUSH
86932: LD_INT 5
86934: PUSH
86935: LD_INT 8
86937: PUSH
86938: LD_INT 11
86940: PUSH
86941: LD_INT 12
86943: PUSH
86944: LD_INT 15
86946: PUSH
86947: LD_INT 16
86949: PUSH
86950: LD_INT 22
86952: PUSH
86953: LD_INT 23
86955: PUSH
86956: LD_INT 26
86958: PUSH
86959: LD_INT 36
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 101
86978: PUSH
86979: LD_INT 102
86981: PUSH
86982: LD_INT 105
86984: PUSH
86985: LD_INT 106
86987: PUSH
86988: LD_INT 108
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: ST_TO_ADDR
87002: GO 89605
87004: LD_INT 5
87006: DOUBLE
87007: EQUAL
87008: IFTRUE 87012
87010: GO 87112
87012: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
87013: LD_ADDR_VAR 0 1
87017: PUSH
87018: LD_INT 2
87020: PUSH
87021: LD_INT 4
87023: PUSH
87024: LD_INT 5
87026: PUSH
87027: LD_INT 6
87029: PUSH
87030: LD_INT 8
87032: PUSH
87033: LD_INT 11
87035: PUSH
87036: LD_INT 12
87038: PUSH
87039: LD_INT 15
87041: PUSH
87042: LD_INT 16
87044: PUSH
87045: LD_INT 22
87047: PUSH
87048: LD_INT 23
87050: PUSH
87051: LD_INT 25
87053: PUSH
87054: LD_INT 26
87056: PUSH
87057: LD_INT 36
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 101
87078: PUSH
87079: LD_INT 102
87081: PUSH
87082: LD_INT 105
87084: PUSH
87085: LD_INT 106
87087: PUSH
87088: LD_INT 108
87090: PUSH
87091: LD_INT 109
87093: PUSH
87094: LD_INT 112
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: ST_TO_ADDR
87110: GO 89605
87112: LD_INT 6
87114: DOUBLE
87115: EQUAL
87116: IFTRUE 87120
87118: GO 87240
87120: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
87121: LD_ADDR_VAR 0 1
87125: PUSH
87126: LD_INT 2
87128: PUSH
87129: LD_INT 4
87131: PUSH
87132: LD_INT 5
87134: PUSH
87135: LD_INT 6
87137: PUSH
87138: LD_INT 8
87140: PUSH
87141: LD_INT 11
87143: PUSH
87144: LD_INT 12
87146: PUSH
87147: LD_INT 15
87149: PUSH
87150: LD_INT 16
87152: PUSH
87153: LD_INT 20
87155: PUSH
87156: LD_INT 21
87158: PUSH
87159: LD_INT 22
87161: PUSH
87162: LD_INT 23
87164: PUSH
87165: LD_INT 25
87167: PUSH
87168: LD_INT 26
87170: PUSH
87171: LD_INT 30
87173: PUSH
87174: LD_INT 31
87176: PUSH
87177: LD_INT 32
87179: PUSH
87180: LD_INT 36
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: PUSH
87204: LD_INT 101
87206: PUSH
87207: LD_INT 102
87209: PUSH
87210: LD_INT 105
87212: PUSH
87213: LD_INT 106
87215: PUSH
87216: LD_INT 108
87218: PUSH
87219: LD_INT 109
87221: PUSH
87222: LD_INT 112
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: PUSH
87234: EMPTY
87235: LIST
87236: LIST
87237: ST_TO_ADDR
87238: GO 89605
87240: LD_INT 7
87242: DOUBLE
87243: EQUAL
87244: IFTRUE 87248
87246: GO 87348
87248: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
87249: LD_ADDR_VAR 0 1
87253: PUSH
87254: LD_INT 2
87256: PUSH
87257: LD_INT 4
87259: PUSH
87260: LD_INT 5
87262: PUSH
87263: LD_INT 7
87265: PUSH
87266: LD_INT 11
87268: PUSH
87269: LD_INT 12
87271: PUSH
87272: LD_INT 15
87274: PUSH
87275: LD_INT 16
87277: PUSH
87278: LD_INT 20
87280: PUSH
87281: LD_INT 21
87283: PUSH
87284: LD_INT 22
87286: PUSH
87287: LD_INT 23
87289: PUSH
87290: LD_INT 25
87292: PUSH
87293: LD_INT 26
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: LIST
87300: LIST
87301: LIST
87302: LIST
87303: LIST
87304: LIST
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: PUSH
87312: LD_INT 101
87314: PUSH
87315: LD_INT 102
87317: PUSH
87318: LD_INT 103
87320: PUSH
87321: LD_INT 105
87323: PUSH
87324: LD_INT 106
87326: PUSH
87327: LD_INT 108
87329: PUSH
87330: LD_INT 112
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: ST_TO_ADDR
87346: GO 89605
87348: LD_INT 8
87350: DOUBLE
87351: EQUAL
87352: IFTRUE 87356
87354: GO 87484
87356: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
87357: LD_ADDR_VAR 0 1
87361: PUSH
87362: LD_INT 2
87364: PUSH
87365: LD_INT 4
87367: PUSH
87368: LD_INT 5
87370: PUSH
87371: LD_INT 6
87373: PUSH
87374: LD_INT 7
87376: PUSH
87377: LD_INT 8
87379: PUSH
87380: LD_INT 11
87382: PUSH
87383: LD_INT 12
87385: PUSH
87386: LD_INT 15
87388: PUSH
87389: LD_INT 16
87391: PUSH
87392: LD_INT 20
87394: PUSH
87395: LD_INT 21
87397: PUSH
87398: LD_INT 22
87400: PUSH
87401: LD_INT 23
87403: PUSH
87404: LD_INT 25
87406: PUSH
87407: LD_INT 26
87409: PUSH
87410: LD_INT 30
87412: PUSH
87413: LD_INT 31
87415: PUSH
87416: LD_INT 32
87418: PUSH
87419: LD_INT 36
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 101
87446: PUSH
87447: LD_INT 102
87449: PUSH
87450: LD_INT 103
87452: PUSH
87453: LD_INT 105
87455: PUSH
87456: LD_INT 106
87458: PUSH
87459: LD_INT 108
87461: PUSH
87462: LD_INT 109
87464: PUSH
87465: LD_INT 112
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: ST_TO_ADDR
87482: GO 89605
87484: LD_INT 9
87486: DOUBLE
87487: EQUAL
87488: IFTRUE 87492
87490: GO 87628
87492: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
87493: LD_ADDR_VAR 0 1
87497: PUSH
87498: LD_INT 2
87500: PUSH
87501: LD_INT 4
87503: PUSH
87504: LD_INT 5
87506: PUSH
87507: LD_INT 6
87509: PUSH
87510: LD_INT 7
87512: PUSH
87513: LD_INT 8
87515: PUSH
87516: LD_INT 11
87518: PUSH
87519: LD_INT 12
87521: PUSH
87522: LD_INT 15
87524: PUSH
87525: LD_INT 16
87527: PUSH
87528: LD_INT 20
87530: PUSH
87531: LD_INT 21
87533: PUSH
87534: LD_INT 22
87536: PUSH
87537: LD_INT 23
87539: PUSH
87540: LD_INT 25
87542: PUSH
87543: LD_INT 26
87545: PUSH
87546: LD_INT 28
87548: PUSH
87549: LD_INT 30
87551: PUSH
87552: LD_INT 31
87554: PUSH
87555: LD_INT 32
87557: PUSH
87558: LD_INT 36
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: PUSH
87584: LD_INT 101
87586: PUSH
87587: LD_INT 102
87589: PUSH
87590: LD_INT 103
87592: PUSH
87593: LD_INT 105
87595: PUSH
87596: LD_INT 106
87598: PUSH
87599: LD_INT 108
87601: PUSH
87602: LD_INT 109
87604: PUSH
87605: LD_INT 112
87607: PUSH
87608: LD_INT 114
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: ST_TO_ADDR
87626: GO 89605
87628: LD_INT 10
87630: DOUBLE
87631: EQUAL
87632: IFTRUE 87636
87634: GO 87820
87636: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
87637: LD_ADDR_VAR 0 1
87641: PUSH
87642: LD_INT 2
87644: PUSH
87645: LD_INT 4
87647: PUSH
87648: LD_INT 5
87650: PUSH
87651: LD_INT 6
87653: PUSH
87654: LD_INT 7
87656: PUSH
87657: LD_INT 8
87659: PUSH
87660: LD_INT 9
87662: PUSH
87663: LD_INT 10
87665: PUSH
87666: LD_INT 11
87668: PUSH
87669: LD_INT 12
87671: PUSH
87672: LD_INT 13
87674: PUSH
87675: LD_INT 14
87677: PUSH
87678: LD_INT 15
87680: PUSH
87681: LD_INT 16
87683: PUSH
87684: LD_INT 17
87686: PUSH
87687: LD_INT 18
87689: PUSH
87690: LD_INT 19
87692: PUSH
87693: LD_INT 20
87695: PUSH
87696: LD_INT 21
87698: PUSH
87699: LD_INT 22
87701: PUSH
87702: LD_INT 23
87704: PUSH
87705: LD_INT 24
87707: PUSH
87708: LD_INT 25
87710: PUSH
87711: LD_INT 26
87713: PUSH
87714: LD_INT 28
87716: PUSH
87717: LD_INT 30
87719: PUSH
87720: LD_INT 31
87722: PUSH
87723: LD_INT 32
87725: PUSH
87726: LD_INT 36
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: PUSH
87760: LD_INT 101
87762: PUSH
87763: LD_INT 102
87765: PUSH
87766: LD_INT 103
87768: PUSH
87769: LD_INT 104
87771: PUSH
87772: LD_INT 105
87774: PUSH
87775: LD_INT 106
87777: PUSH
87778: LD_INT 107
87780: PUSH
87781: LD_INT 108
87783: PUSH
87784: LD_INT 109
87786: PUSH
87787: LD_INT 110
87789: PUSH
87790: LD_INT 111
87792: PUSH
87793: LD_INT 112
87795: PUSH
87796: LD_INT 114
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: ST_TO_ADDR
87818: GO 89605
87820: LD_INT 11
87822: DOUBLE
87823: EQUAL
87824: IFTRUE 87828
87826: GO 88020
87828: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
87829: LD_ADDR_VAR 0 1
87833: PUSH
87834: LD_INT 2
87836: PUSH
87837: LD_INT 3
87839: PUSH
87840: LD_INT 4
87842: PUSH
87843: LD_INT 5
87845: PUSH
87846: LD_INT 6
87848: PUSH
87849: LD_INT 7
87851: PUSH
87852: LD_INT 8
87854: PUSH
87855: LD_INT 9
87857: PUSH
87858: LD_INT 10
87860: PUSH
87861: LD_INT 11
87863: PUSH
87864: LD_INT 12
87866: PUSH
87867: LD_INT 13
87869: PUSH
87870: LD_INT 14
87872: PUSH
87873: LD_INT 15
87875: PUSH
87876: LD_INT 16
87878: PUSH
87879: LD_INT 17
87881: PUSH
87882: LD_INT 18
87884: PUSH
87885: LD_INT 19
87887: PUSH
87888: LD_INT 20
87890: PUSH
87891: LD_INT 21
87893: PUSH
87894: LD_INT 22
87896: PUSH
87897: LD_INT 23
87899: PUSH
87900: LD_INT 24
87902: PUSH
87903: LD_INT 25
87905: PUSH
87906: LD_INT 26
87908: PUSH
87909: LD_INT 28
87911: PUSH
87912: LD_INT 30
87914: PUSH
87915: LD_INT 31
87917: PUSH
87918: LD_INT 32
87920: PUSH
87921: LD_INT 34
87923: PUSH
87924: LD_INT 36
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: LIST
87943: LIST
87944: LIST
87945: LIST
87946: LIST
87947: LIST
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: PUSH
87960: LD_INT 101
87962: PUSH
87963: LD_INT 102
87965: PUSH
87966: LD_INT 103
87968: PUSH
87969: LD_INT 104
87971: PUSH
87972: LD_INT 105
87974: PUSH
87975: LD_INT 106
87977: PUSH
87978: LD_INT 107
87980: PUSH
87981: LD_INT 108
87983: PUSH
87984: LD_INT 109
87986: PUSH
87987: LD_INT 110
87989: PUSH
87990: LD_INT 111
87992: PUSH
87993: LD_INT 112
87995: PUSH
87996: LD_INT 114
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: ST_TO_ADDR
88018: GO 89605
88020: LD_INT 12
88022: DOUBLE
88023: EQUAL
88024: IFTRUE 88028
88026: GO 88236
88028: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
88029: LD_ADDR_VAR 0 1
88033: PUSH
88034: LD_INT 1
88036: PUSH
88037: LD_INT 2
88039: PUSH
88040: LD_INT 3
88042: PUSH
88043: LD_INT 4
88045: PUSH
88046: LD_INT 5
88048: PUSH
88049: LD_INT 6
88051: PUSH
88052: LD_INT 7
88054: PUSH
88055: LD_INT 8
88057: PUSH
88058: LD_INT 9
88060: PUSH
88061: LD_INT 10
88063: PUSH
88064: LD_INT 11
88066: PUSH
88067: LD_INT 12
88069: PUSH
88070: LD_INT 13
88072: PUSH
88073: LD_INT 14
88075: PUSH
88076: LD_INT 15
88078: PUSH
88079: LD_INT 16
88081: PUSH
88082: LD_INT 17
88084: PUSH
88085: LD_INT 18
88087: PUSH
88088: LD_INT 19
88090: PUSH
88091: LD_INT 20
88093: PUSH
88094: LD_INT 21
88096: PUSH
88097: LD_INT 22
88099: PUSH
88100: LD_INT 23
88102: PUSH
88103: LD_INT 24
88105: PUSH
88106: LD_INT 25
88108: PUSH
88109: LD_INT 26
88111: PUSH
88112: LD_INT 27
88114: PUSH
88115: LD_INT 28
88117: PUSH
88118: LD_INT 30
88120: PUSH
88121: LD_INT 31
88123: PUSH
88124: LD_INT 32
88126: PUSH
88127: LD_INT 33
88129: PUSH
88130: LD_INT 34
88132: PUSH
88133: LD_INT 36
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 101
88174: PUSH
88175: LD_INT 102
88177: PUSH
88178: LD_INT 103
88180: PUSH
88181: LD_INT 104
88183: PUSH
88184: LD_INT 105
88186: PUSH
88187: LD_INT 106
88189: PUSH
88190: LD_INT 107
88192: PUSH
88193: LD_INT 108
88195: PUSH
88196: LD_INT 109
88198: PUSH
88199: LD_INT 110
88201: PUSH
88202: LD_INT 111
88204: PUSH
88205: LD_INT 112
88207: PUSH
88208: LD_INT 113
88210: PUSH
88211: LD_INT 114
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: PUSH
88230: EMPTY
88231: LIST
88232: LIST
88233: ST_TO_ADDR
88234: GO 89605
88236: LD_INT 13
88238: DOUBLE
88239: EQUAL
88240: IFTRUE 88244
88242: GO 88440
88244: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
88245: LD_ADDR_VAR 0 1
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: LD_INT 2
88255: PUSH
88256: LD_INT 3
88258: PUSH
88259: LD_INT 4
88261: PUSH
88262: LD_INT 5
88264: PUSH
88265: LD_INT 8
88267: PUSH
88268: LD_INT 9
88270: PUSH
88271: LD_INT 10
88273: PUSH
88274: LD_INT 11
88276: PUSH
88277: LD_INT 12
88279: PUSH
88280: LD_INT 14
88282: PUSH
88283: LD_INT 15
88285: PUSH
88286: LD_INT 16
88288: PUSH
88289: LD_INT 17
88291: PUSH
88292: LD_INT 18
88294: PUSH
88295: LD_INT 19
88297: PUSH
88298: LD_INT 20
88300: PUSH
88301: LD_INT 21
88303: PUSH
88304: LD_INT 22
88306: PUSH
88307: LD_INT 23
88309: PUSH
88310: LD_INT 24
88312: PUSH
88313: LD_INT 25
88315: PUSH
88316: LD_INT 26
88318: PUSH
88319: LD_INT 27
88321: PUSH
88322: LD_INT 28
88324: PUSH
88325: LD_INT 30
88327: PUSH
88328: LD_INT 31
88330: PUSH
88331: LD_INT 32
88333: PUSH
88334: LD_INT 33
88336: PUSH
88337: LD_INT 34
88339: PUSH
88340: LD_INT 36
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: LIST
88353: LIST
88354: LIST
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: PUSH
88376: LD_INT 101
88378: PUSH
88379: LD_INT 102
88381: PUSH
88382: LD_INT 103
88384: PUSH
88385: LD_INT 104
88387: PUSH
88388: LD_INT 105
88390: PUSH
88391: LD_INT 106
88393: PUSH
88394: LD_INT 107
88396: PUSH
88397: LD_INT 108
88399: PUSH
88400: LD_INT 109
88402: PUSH
88403: LD_INT 110
88405: PUSH
88406: LD_INT 111
88408: PUSH
88409: LD_INT 112
88411: PUSH
88412: LD_INT 113
88414: PUSH
88415: LD_INT 114
88417: PUSH
88418: EMPTY
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: ST_TO_ADDR
88438: GO 89605
88440: LD_INT 14
88442: DOUBLE
88443: EQUAL
88444: IFTRUE 88448
88446: GO 88660
88448: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
88449: LD_ADDR_VAR 0 1
88453: PUSH
88454: LD_INT 1
88456: PUSH
88457: LD_INT 2
88459: PUSH
88460: LD_INT 3
88462: PUSH
88463: LD_INT 4
88465: PUSH
88466: LD_INT 5
88468: PUSH
88469: LD_INT 6
88471: PUSH
88472: LD_INT 7
88474: PUSH
88475: LD_INT 8
88477: PUSH
88478: LD_INT 9
88480: PUSH
88481: LD_INT 10
88483: PUSH
88484: LD_INT 11
88486: PUSH
88487: LD_INT 12
88489: PUSH
88490: LD_INT 13
88492: PUSH
88493: LD_INT 14
88495: PUSH
88496: LD_INT 15
88498: PUSH
88499: LD_INT 16
88501: PUSH
88502: LD_INT 17
88504: PUSH
88505: LD_INT 18
88507: PUSH
88508: LD_INT 19
88510: PUSH
88511: LD_INT 20
88513: PUSH
88514: LD_INT 21
88516: PUSH
88517: LD_INT 22
88519: PUSH
88520: LD_INT 23
88522: PUSH
88523: LD_INT 24
88525: PUSH
88526: LD_INT 25
88528: PUSH
88529: LD_INT 26
88531: PUSH
88532: LD_INT 27
88534: PUSH
88535: LD_INT 28
88537: PUSH
88538: LD_INT 29
88540: PUSH
88541: LD_INT 30
88543: PUSH
88544: LD_INT 31
88546: PUSH
88547: LD_INT 32
88549: PUSH
88550: LD_INT 33
88552: PUSH
88553: LD_INT 34
88555: PUSH
88556: LD_INT 36
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 101
88598: PUSH
88599: LD_INT 102
88601: PUSH
88602: LD_INT 103
88604: PUSH
88605: LD_INT 104
88607: PUSH
88608: LD_INT 105
88610: PUSH
88611: LD_INT 106
88613: PUSH
88614: LD_INT 107
88616: PUSH
88617: LD_INT 108
88619: PUSH
88620: LD_INT 109
88622: PUSH
88623: LD_INT 110
88625: PUSH
88626: LD_INT 111
88628: PUSH
88629: LD_INT 112
88631: PUSH
88632: LD_INT 113
88634: PUSH
88635: LD_INT 114
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: ST_TO_ADDR
88658: GO 89605
88660: LD_INT 15
88662: DOUBLE
88663: EQUAL
88664: IFTRUE 88668
88666: GO 88880
88668: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
88669: LD_ADDR_VAR 0 1
88673: PUSH
88674: LD_INT 1
88676: PUSH
88677: LD_INT 2
88679: PUSH
88680: LD_INT 3
88682: PUSH
88683: LD_INT 4
88685: PUSH
88686: LD_INT 5
88688: PUSH
88689: LD_INT 6
88691: PUSH
88692: LD_INT 7
88694: PUSH
88695: LD_INT 8
88697: PUSH
88698: LD_INT 9
88700: PUSH
88701: LD_INT 10
88703: PUSH
88704: LD_INT 11
88706: PUSH
88707: LD_INT 12
88709: PUSH
88710: LD_INT 13
88712: PUSH
88713: LD_INT 14
88715: PUSH
88716: LD_INT 15
88718: PUSH
88719: LD_INT 16
88721: PUSH
88722: LD_INT 17
88724: PUSH
88725: LD_INT 18
88727: PUSH
88728: LD_INT 19
88730: PUSH
88731: LD_INT 20
88733: PUSH
88734: LD_INT 21
88736: PUSH
88737: LD_INT 22
88739: PUSH
88740: LD_INT 23
88742: PUSH
88743: LD_INT 24
88745: PUSH
88746: LD_INT 25
88748: PUSH
88749: LD_INT 26
88751: PUSH
88752: LD_INT 27
88754: PUSH
88755: LD_INT 28
88757: PUSH
88758: LD_INT 29
88760: PUSH
88761: LD_INT 30
88763: PUSH
88764: LD_INT 31
88766: PUSH
88767: LD_INT 32
88769: PUSH
88770: LD_INT 33
88772: PUSH
88773: LD_INT 34
88775: PUSH
88776: LD_INT 36
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: PUSH
88816: LD_INT 101
88818: PUSH
88819: LD_INT 102
88821: PUSH
88822: LD_INT 103
88824: PUSH
88825: LD_INT 104
88827: PUSH
88828: LD_INT 105
88830: PUSH
88831: LD_INT 106
88833: PUSH
88834: LD_INT 107
88836: PUSH
88837: LD_INT 108
88839: PUSH
88840: LD_INT 109
88842: PUSH
88843: LD_INT 110
88845: PUSH
88846: LD_INT 111
88848: PUSH
88849: LD_INT 112
88851: PUSH
88852: LD_INT 113
88854: PUSH
88855: LD_INT 114
88857: PUSH
88858: EMPTY
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: ST_TO_ADDR
88878: GO 89605
88880: LD_INT 16
88882: DOUBLE
88883: EQUAL
88884: IFTRUE 88888
88886: GO 89012
88888: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
88889: LD_ADDR_VAR 0 1
88893: PUSH
88894: LD_INT 2
88896: PUSH
88897: LD_INT 4
88899: PUSH
88900: LD_INT 5
88902: PUSH
88903: LD_INT 7
88905: PUSH
88906: LD_INT 11
88908: PUSH
88909: LD_INT 12
88911: PUSH
88912: LD_INT 15
88914: PUSH
88915: LD_INT 16
88917: PUSH
88918: LD_INT 20
88920: PUSH
88921: LD_INT 21
88923: PUSH
88924: LD_INT 22
88926: PUSH
88927: LD_INT 23
88929: PUSH
88930: LD_INT 25
88932: PUSH
88933: LD_INT 26
88935: PUSH
88936: LD_INT 30
88938: PUSH
88939: LD_INT 31
88941: PUSH
88942: LD_INT 32
88944: PUSH
88945: LD_INT 33
88947: PUSH
88948: LD_INT 34
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 101
88974: PUSH
88975: LD_INT 102
88977: PUSH
88978: LD_INT 103
88980: PUSH
88981: LD_INT 106
88983: PUSH
88984: LD_INT 108
88986: PUSH
88987: LD_INT 112
88989: PUSH
88990: LD_INT 113
88992: PUSH
88993: LD_INT 114
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: ST_TO_ADDR
89010: GO 89605
89012: LD_INT 17
89014: DOUBLE
89015: EQUAL
89016: IFTRUE 89020
89018: GO 89232
89020: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
89021: LD_ADDR_VAR 0 1
89025: PUSH
89026: LD_INT 1
89028: PUSH
89029: LD_INT 2
89031: PUSH
89032: LD_INT 3
89034: PUSH
89035: LD_INT 4
89037: PUSH
89038: LD_INT 5
89040: PUSH
89041: LD_INT 6
89043: PUSH
89044: LD_INT 7
89046: PUSH
89047: LD_INT 8
89049: PUSH
89050: LD_INT 9
89052: PUSH
89053: LD_INT 10
89055: PUSH
89056: LD_INT 11
89058: PUSH
89059: LD_INT 12
89061: PUSH
89062: LD_INT 13
89064: PUSH
89065: LD_INT 14
89067: PUSH
89068: LD_INT 15
89070: PUSH
89071: LD_INT 16
89073: PUSH
89074: LD_INT 17
89076: PUSH
89077: LD_INT 18
89079: PUSH
89080: LD_INT 19
89082: PUSH
89083: LD_INT 20
89085: PUSH
89086: LD_INT 21
89088: PUSH
89089: LD_INT 22
89091: PUSH
89092: LD_INT 23
89094: PUSH
89095: LD_INT 24
89097: PUSH
89098: LD_INT 25
89100: PUSH
89101: LD_INT 26
89103: PUSH
89104: LD_INT 27
89106: PUSH
89107: LD_INT 28
89109: PUSH
89110: LD_INT 29
89112: PUSH
89113: LD_INT 30
89115: PUSH
89116: LD_INT 31
89118: PUSH
89119: LD_INT 32
89121: PUSH
89122: LD_INT 33
89124: PUSH
89125: LD_INT 34
89127: PUSH
89128: LD_INT 36
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 101
89170: PUSH
89171: LD_INT 102
89173: PUSH
89174: LD_INT 103
89176: PUSH
89177: LD_INT 104
89179: PUSH
89180: LD_INT 105
89182: PUSH
89183: LD_INT 106
89185: PUSH
89186: LD_INT 107
89188: PUSH
89189: LD_INT 108
89191: PUSH
89192: LD_INT 109
89194: PUSH
89195: LD_INT 110
89197: PUSH
89198: LD_INT 111
89200: PUSH
89201: LD_INT 112
89203: PUSH
89204: LD_INT 113
89206: PUSH
89207: LD_INT 114
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: ST_TO_ADDR
89230: GO 89605
89232: LD_INT 18
89234: DOUBLE
89235: EQUAL
89236: IFTRUE 89240
89238: GO 89376
89240: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
89241: LD_ADDR_VAR 0 1
89245: PUSH
89246: LD_INT 2
89248: PUSH
89249: LD_INT 4
89251: PUSH
89252: LD_INT 5
89254: PUSH
89255: LD_INT 7
89257: PUSH
89258: LD_INT 11
89260: PUSH
89261: LD_INT 12
89263: PUSH
89264: LD_INT 15
89266: PUSH
89267: LD_INT 16
89269: PUSH
89270: LD_INT 20
89272: PUSH
89273: LD_INT 21
89275: PUSH
89276: LD_INT 22
89278: PUSH
89279: LD_INT 23
89281: PUSH
89282: LD_INT 25
89284: PUSH
89285: LD_INT 26
89287: PUSH
89288: LD_INT 30
89290: PUSH
89291: LD_INT 31
89293: PUSH
89294: LD_INT 32
89296: PUSH
89297: LD_INT 33
89299: PUSH
89300: LD_INT 34
89302: PUSH
89303: LD_INT 35
89305: PUSH
89306: LD_INT 36
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: PUSH
89332: LD_INT 101
89334: PUSH
89335: LD_INT 102
89337: PUSH
89338: LD_INT 103
89340: PUSH
89341: LD_INT 106
89343: PUSH
89344: LD_INT 108
89346: PUSH
89347: LD_INT 112
89349: PUSH
89350: LD_INT 113
89352: PUSH
89353: LD_INT 114
89355: PUSH
89356: LD_INT 115
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: ST_TO_ADDR
89374: GO 89605
89376: LD_INT 19
89378: DOUBLE
89379: EQUAL
89380: IFTRUE 89384
89382: GO 89604
89384: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
89385: LD_ADDR_VAR 0 1
89389: PUSH
89390: LD_INT 1
89392: PUSH
89393: LD_INT 2
89395: PUSH
89396: LD_INT 3
89398: PUSH
89399: LD_INT 4
89401: PUSH
89402: LD_INT 5
89404: PUSH
89405: LD_INT 6
89407: PUSH
89408: LD_INT 7
89410: PUSH
89411: LD_INT 8
89413: PUSH
89414: LD_INT 9
89416: PUSH
89417: LD_INT 10
89419: PUSH
89420: LD_INT 11
89422: PUSH
89423: LD_INT 12
89425: PUSH
89426: LD_INT 13
89428: PUSH
89429: LD_INT 14
89431: PUSH
89432: LD_INT 15
89434: PUSH
89435: LD_INT 16
89437: PUSH
89438: LD_INT 17
89440: PUSH
89441: LD_INT 18
89443: PUSH
89444: LD_INT 19
89446: PUSH
89447: LD_INT 20
89449: PUSH
89450: LD_INT 21
89452: PUSH
89453: LD_INT 22
89455: PUSH
89456: LD_INT 23
89458: PUSH
89459: LD_INT 24
89461: PUSH
89462: LD_INT 25
89464: PUSH
89465: LD_INT 26
89467: PUSH
89468: LD_INT 27
89470: PUSH
89471: LD_INT 28
89473: PUSH
89474: LD_INT 29
89476: PUSH
89477: LD_INT 30
89479: PUSH
89480: LD_INT 31
89482: PUSH
89483: LD_INT 32
89485: PUSH
89486: LD_INT 33
89488: PUSH
89489: LD_INT 34
89491: PUSH
89492: LD_INT 35
89494: PUSH
89495: LD_INT 36
89497: PUSH
89498: EMPTY
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 101
89538: PUSH
89539: LD_INT 102
89541: PUSH
89542: LD_INT 103
89544: PUSH
89545: LD_INT 104
89547: PUSH
89548: LD_INT 105
89550: PUSH
89551: LD_INT 106
89553: PUSH
89554: LD_INT 107
89556: PUSH
89557: LD_INT 108
89559: PUSH
89560: LD_INT 109
89562: PUSH
89563: LD_INT 110
89565: PUSH
89566: LD_INT 111
89568: PUSH
89569: LD_INT 112
89571: PUSH
89572: LD_INT 113
89574: PUSH
89575: LD_INT 114
89577: PUSH
89578: LD_INT 115
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: ST_TO_ADDR
89602: GO 89605
89604: POP
// end else
89605: GO 89824
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
89607: LD_ADDR_VAR 0 1
89611: PUSH
89612: LD_INT 1
89614: PUSH
89615: LD_INT 2
89617: PUSH
89618: LD_INT 3
89620: PUSH
89621: LD_INT 4
89623: PUSH
89624: LD_INT 5
89626: PUSH
89627: LD_INT 6
89629: PUSH
89630: LD_INT 7
89632: PUSH
89633: LD_INT 8
89635: PUSH
89636: LD_INT 9
89638: PUSH
89639: LD_INT 10
89641: PUSH
89642: LD_INT 11
89644: PUSH
89645: LD_INT 12
89647: PUSH
89648: LD_INT 13
89650: PUSH
89651: LD_INT 14
89653: PUSH
89654: LD_INT 15
89656: PUSH
89657: LD_INT 16
89659: PUSH
89660: LD_INT 17
89662: PUSH
89663: LD_INT 18
89665: PUSH
89666: LD_INT 19
89668: PUSH
89669: LD_INT 20
89671: PUSH
89672: LD_INT 21
89674: PUSH
89675: LD_INT 22
89677: PUSH
89678: LD_INT 23
89680: PUSH
89681: LD_INT 24
89683: PUSH
89684: LD_INT 25
89686: PUSH
89687: LD_INT 26
89689: PUSH
89690: LD_INT 27
89692: PUSH
89693: LD_INT 28
89695: PUSH
89696: LD_INT 29
89698: PUSH
89699: LD_INT 30
89701: PUSH
89702: LD_INT 31
89704: PUSH
89705: LD_INT 32
89707: PUSH
89708: LD_INT 33
89710: PUSH
89711: LD_INT 34
89713: PUSH
89714: LD_INT 35
89716: PUSH
89717: LD_INT 36
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: LIST
89744: LIST
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 101
89760: PUSH
89761: LD_INT 102
89763: PUSH
89764: LD_INT 103
89766: PUSH
89767: LD_INT 104
89769: PUSH
89770: LD_INT 105
89772: PUSH
89773: LD_INT 106
89775: PUSH
89776: LD_INT 107
89778: PUSH
89779: LD_INT 108
89781: PUSH
89782: LD_INT 109
89784: PUSH
89785: LD_INT 110
89787: PUSH
89788: LD_INT 111
89790: PUSH
89791: LD_INT 112
89793: PUSH
89794: LD_INT 113
89796: PUSH
89797: LD_INT 114
89799: PUSH
89800: LD_INT 115
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: ST_TO_ADDR
// if result then
89824: LD_VAR 0 1
89828: IFFALSE 90117
// begin normal :=  ;
89830: LD_ADDR_VAR 0 3
89834: PUSH
89835: LD_STRING 
89837: ST_TO_ADDR
// hardcore :=  ;
89838: LD_ADDR_VAR 0 4
89842: PUSH
89843: LD_STRING 
89845: ST_TO_ADDR
// for i = 1 to normalCounter do
89846: LD_ADDR_VAR 0 5
89850: PUSH
89851: DOUBLE
89852: LD_INT 1
89854: DEC
89855: ST_TO_ADDR
89856: LD_EXP 110
89860: PUSH
89861: FOR_TO
89862: IFFALSE 89963
// begin tmp := 0 ;
89864: LD_ADDR_VAR 0 2
89868: PUSH
89869: LD_STRING 0
89871: ST_TO_ADDR
// if result [ 1 ] then
89872: LD_VAR 0 1
89876: PUSH
89877: LD_INT 1
89879: ARRAY
89880: IFFALSE 89945
// if result [ 1 ] [ 1 ] = i then
89882: LD_VAR 0 1
89886: PUSH
89887: LD_INT 1
89889: ARRAY
89890: PUSH
89891: LD_INT 1
89893: ARRAY
89894: PUSH
89895: LD_VAR 0 5
89899: EQUAL
89900: IFFALSE 89945
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89902: LD_ADDR_VAR 0 1
89906: PUSH
89907: LD_VAR 0 1
89911: PPUSH
89912: LD_INT 1
89914: PPUSH
89915: LD_VAR 0 1
89919: PUSH
89920: LD_INT 1
89922: ARRAY
89923: PPUSH
89924: LD_INT 1
89926: PPUSH
89927: CALL_OW 3
89931: PPUSH
89932: CALL_OW 1
89936: ST_TO_ADDR
// tmp := 1 ;
89937: LD_ADDR_VAR 0 2
89941: PUSH
89942: LD_STRING 1
89944: ST_TO_ADDR
// end ; normal := normal & tmp ;
89945: LD_ADDR_VAR 0 3
89949: PUSH
89950: LD_VAR 0 3
89954: PUSH
89955: LD_VAR 0 2
89959: STR
89960: ST_TO_ADDR
// end ;
89961: GO 89861
89963: POP
89964: POP
// for i = 1 to hardcoreCounter do
89965: LD_ADDR_VAR 0 5
89969: PUSH
89970: DOUBLE
89971: LD_INT 1
89973: DEC
89974: ST_TO_ADDR
89975: LD_EXP 111
89979: PUSH
89980: FOR_TO
89981: IFFALSE 90086
// begin tmp := 0 ;
89983: LD_ADDR_VAR 0 2
89987: PUSH
89988: LD_STRING 0
89990: ST_TO_ADDR
// if result [ 2 ] then
89991: LD_VAR 0 1
89995: PUSH
89996: LD_INT 2
89998: ARRAY
89999: IFFALSE 90068
// if result [ 2 ] [ 1 ] = 100 + i then
90001: LD_VAR 0 1
90005: PUSH
90006: LD_INT 2
90008: ARRAY
90009: PUSH
90010: LD_INT 1
90012: ARRAY
90013: PUSH
90014: LD_INT 100
90016: PUSH
90017: LD_VAR 0 5
90021: PLUS
90022: EQUAL
90023: IFFALSE 90068
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90025: LD_ADDR_VAR 0 1
90029: PUSH
90030: LD_VAR 0 1
90034: PPUSH
90035: LD_INT 2
90037: PPUSH
90038: LD_VAR 0 1
90042: PUSH
90043: LD_INT 2
90045: ARRAY
90046: PPUSH
90047: LD_INT 1
90049: PPUSH
90050: CALL_OW 3
90054: PPUSH
90055: CALL_OW 1
90059: ST_TO_ADDR
// tmp := 1 ;
90060: LD_ADDR_VAR 0 2
90064: PUSH
90065: LD_STRING 1
90067: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90068: LD_ADDR_VAR 0 4
90072: PUSH
90073: LD_VAR 0 4
90077: PUSH
90078: LD_VAR 0 2
90082: STR
90083: ST_TO_ADDR
// end ;
90084: GO 89980
90086: POP
90087: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90088: LD_STRING getStreamItemsFromMission("
90090: PUSH
90091: LD_VAR 0 3
90095: STR
90096: PUSH
90097: LD_STRING ","
90099: STR
90100: PUSH
90101: LD_VAR 0 4
90105: STR
90106: PUSH
90107: LD_STRING ")
90109: STR
90110: PPUSH
90111: CALL_OW 559
// end else
90115: GO 90124
// ToLua ( getStreamItemsFromMission("","") ) ;
90117: LD_STRING getStreamItemsFromMission("","")
90119: PPUSH
90120: CALL_OW 559
// end ;
90124: LD_VAR 0 1
90128: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90129: LD_EXP 109
90133: PUSH
90134: LD_EXP 114
90138: AND
90139: IFFALSE 90263
90141: GO 90143
90143: DISABLE
90144: LD_INT 0
90146: PPUSH
90147: PPUSH
// begin enable ;
90148: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90149: LD_ADDR_VAR 0 2
90153: PUSH
90154: LD_INT 22
90156: PUSH
90157: LD_OWVAR 2
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 2
90168: PUSH
90169: LD_INT 34
90171: PUSH
90172: LD_INT 7
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 34
90181: PUSH
90182: LD_INT 45
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 34
90191: PUSH
90192: LD_INT 28
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PUSH
90199: LD_INT 34
90201: PUSH
90202: LD_INT 47
90204: PUSH
90205: EMPTY
90206: LIST
90207: LIST
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PPUSH
90220: CALL_OW 69
90224: ST_TO_ADDR
// if not tmp then
90225: LD_VAR 0 2
90229: NOT
90230: IFFALSE 90234
// exit ;
90232: GO 90263
// for i in tmp do
90234: LD_ADDR_VAR 0 1
90238: PUSH
90239: LD_VAR 0 2
90243: PUSH
90244: FOR_IN
90245: IFFALSE 90261
// begin SetLives ( i , 0 ) ;
90247: LD_VAR 0 1
90251: PPUSH
90252: LD_INT 0
90254: PPUSH
90255: CALL_OW 234
// end ;
90259: GO 90244
90261: POP
90262: POP
// end ;
90263: PPOPN 2
90265: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90266: LD_EXP 109
90270: PUSH
90271: LD_EXP 115
90275: AND
90276: IFFALSE 90360
90278: GO 90280
90280: DISABLE
90281: LD_INT 0
90283: PPUSH
90284: PPUSH
// begin enable ;
90285: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90286: LD_ADDR_VAR 0 2
90290: PUSH
90291: LD_INT 22
90293: PUSH
90294: LD_OWVAR 2
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 32
90305: PUSH
90306: LD_INT 3
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: EMPTY
90314: LIST
90315: LIST
90316: PPUSH
90317: CALL_OW 69
90321: ST_TO_ADDR
// if not tmp then
90322: LD_VAR 0 2
90326: NOT
90327: IFFALSE 90331
// exit ;
90329: GO 90360
// for i in tmp do
90331: LD_ADDR_VAR 0 1
90335: PUSH
90336: LD_VAR 0 2
90340: PUSH
90341: FOR_IN
90342: IFFALSE 90358
// begin SetLives ( i , 0 ) ;
90344: LD_VAR 0 1
90348: PPUSH
90349: LD_INT 0
90351: PPUSH
90352: CALL_OW 234
// end ;
90356: GO 90341
90358: POP
90359: POP
// end ;
90360: PPOPN 2
90362: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
90363: LD_EXP 109
90367: PUSH
90368: LD_EXP 112
90372: AND
90373: IFFALSE 90466
90375: GO 90377
90377: DISABLE
90378: LD_INT 0
90380: PPUSH
// begin enable ;
90381: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90382: LD_ADDR_VAR 0 1
90386: PUSH
90387: LD_INT 22
90389: PUSH
90390: LD_OWVAR 2
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 2
90401: PUSH
90402: LD_INT 25
90404: PUSH
90405: LD_INT 5
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 25
90414: PUSH
90415: LD_INT 9
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 25
90424: PUSH
90425: LD_INT 8
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PPUSH
90442: CALL_OW 69
90446: PUSH
90447: FOR_IN
90448: IFFALSE 90464
// begin SetClass ( i , 1 ) ;
90450: LD_VAR 0 1
90454: PPUSH
90455: LD_INT 1
90457: PPUSH
90458: CALL_OW 336
// end ;
90462: GO 90447
90464: POP
90465: POP
// end ;
90466: PPOPN 1
90468: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90469: LD_EXP 109
90473: PUSH
90474: LD_EXP 113
90478: AND
90479: PUSH
90480: LD_OWVAR 65
90484: PUSH
90485: LD_INT 7
90487: LESS
90488: AND
90489: IFFALSE 90503
90491: GO 90493
90493: DISABLE
// begin enable ;
90494: ENABLE
// game_speed := 7 ;
90495: LD_ADDR_OWVAR 65
90499: PUSH
90500: LD_INT 7
90502: ST_TO_ADDR
// end ;
90503: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90504: LD_EXP 109
90508: PUSH
90509: LD_EXP 116
90513: AND
90514: IFFALSE 90716
90516: GO 90518
90518: DISABLE
90519: LD_INT 0
90521: PPUSH
90522: PPUSH
90523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90524: LD_ADDR_VAR 0 3
90528: PUSH
90529: LD_INT 81
90531: PUSH
90532: LD_OWVAR 2
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PUSH
90541: LD_INT 21
90543: PUSH
90544: LD_INT 1
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PPUSH
90555: CALL_OW 69
90559: ST_TO_ADDR
// if not tmp then
90560: LD_VAR 0 3
90564: NOT
90565: IFFALSE 90569
// exit ;
90567: GO 90716
// if tmp > 5 then
90569: LD_VAR 0 3
90573: PUSH
90574: LD_INT 5
90576: GREATER
90577: IFFALSE 90589
// k := 5 else
90579: LD_ADDR_VAR 0 2
90583: PUSH
90584: LD_INT 5
90586: ST_TO_ADDR
90587: GO 90599
// k := tmp ;
90589: LD_ADDR_VAR 0 2
90593: PUSH
90594: LD_VAR 0 3
90598: ST_TO_ADDR
// for i := 1 to k do
90599: LD_ADDR_VAR 0 1
90603: PUSH
90604: DOUBLE
90605: LD_INT 1
90607: DEC
90608: ST_TO_ADDR
90609: LD_VAR 0 2
90613: PUSH
90614: FOR_TO
90615: IFFALSE 90714
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
90617: LD_VAR 0 3
90621: PUSH
90622: LD_VAR 0 1
90626: ARRAY
90627: PPUSH
90628: LD_VAR 0 1
90632: PUSH
90633: LD_INT 4
90635: MOD
90636: PUSH
90637: LD_INT 1
90639: PLUS
90640: PPUSH
90641: CALL_OW 259
90645: PUSH
90646: LD_INT 10
90648: LESS
90649: IFFALSE 90712
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
90651: LD_VAR 0 3
90655: PUSH
90656: LD_VAR 0 1
90660: ARRAY
90661: PPUSH
90662: LD_VAR 0 1
90666: PUSH
90667: LD_INT 4
90669: MOD
90670: PUSH
90671: LD_INT 1
90673: PLUS
90674: PPUSH
90675: LD_VAR 0 3
90679: PUSH
90680: LD_VAR 0 1
90684: ARRAY
90685: PPUSH
90686: LD_VAR 0 1
90690: PUSH
90691: LD_INT 4
90693: MOD
90694: PUSH
90695: LD_INT 1
90697: PLUS
90698: PPUSH
90699: CALL_OW 259
90703: PUSH
90704: LD_INT 1
90706: PLUS
90707: PPUSH
90708: CALL_OW 237
90712: GO 90614
90714: POP
90715: POP
// end ;
90716: PPOPN 3
90718: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
90719: LD_EXP 109
90723: PUSH
90724: LD_EXP 117
90728: AND
90729: IFFALSE 90749
90731: GO 90733
90733: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
90734: LD_INT 4
90736: PPUSH
90737: LD_OWVAR 2
90741: PPUSH
90742: LD_INT 0
90744: PPUSH
90745: CALL_OW 324
90749: END
// every 0 0$1 trigger StreamModeActive and sShovel do
90750: LD_EXP 109
90754: PUSH
90755: LD_EXP 146
90759: AND
90760: IFFALSE 90780
90762: GO 90764
90764: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
90765: LD_INT 19
90767: PPUSH
90768: LD_OWVAR 2
90772: PPUSH
90773: LD_INT 0
90775: PPUSH
90776: CALL_OW 324
90780: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
90781: LD_EXP 109
90785: PUSH
90786: LD_EXP 118
90790: AND
90791: IFFALSE 90893
90793: GO 90795
90795: DISABLE
90796: LD_INT 0
90798: PPUSH
90799: PPUSH
// begin enable ;
90800: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
90801: LD_ADDR_VAR 0 2
90805: PUSH
90806: LD_INT 22
90808: PUSH
90809: LD_OWVAR 2
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 2
90820: PUSH
90821: LD_INT 34
90823: PUSH
90824: LD_INT 11
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 34
90833: PUSH
90834: LD_INT 30
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: LIST
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PPUSH
90850: CALL_OW 69
90854: ST_TO_ADDR
// if not tmp then
90855: LD_VAR 0 2
90859: NOT
90860: IFFALSE 90864
// exit ;
90862: GO 90893
// for i in tmp do
90864: LD_ADDR_VAR 0 1
90868: PUSH
90869: LD_VAR 0 2
90873: PUSH
90874: FOR_IN
90875: IFFALSE 90891
// begin SetLives ( i , 0 ) ;
90877: LD_VAR 0 1
90881: PPUSH
90882: LD_INT 0
90884: PPUSH
90885: CALL_OW 234
// end ;
90889: GO 90874
90891: POP
90892: POP
// end ;
90893: PPOPN 2
90895: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90896: LD_EXP 109
90900: PUSH
90901: LD_EXP 119
90905: AND
90906: IFFALSE 90926
90908: GO 90910
90910: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90911: LD_INT 32
90913: PPUSH
90914: LD_OWVAR 2
90918: PPUSH
90919: LD_INT 0
90921: PPUSH
90922: CALL_OW 324
90926: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90927: LD_EXP 109
90931: PUSH
90932: LD_EXP 120
90936: AND
90937: IFFALSE 91118
90939: GO 90941
90941: DISABLE
90942: LD_INT 0
90944: PPUSH
90945: PPUSH
90946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90947: LD_ADDR_VAR 0 2
90951: PUSH
90952: LD_INT 22
90954: PUSH
90955: LD_OWVAR 2
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: PUSH
90964: LD_INT 33
90966: PUSH
90967: LD_INT 3
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PPUSH
90978: CALL_OW 69
90982: ST_TO_ADDR
// if not tmp then
90983: LD_VAR 0 2
90987: NOT
90988: IFFALSE 90992
// exit ;
90990: GO 91118
// side := 0 ;
90992: LD_ADDR_VAR 0 3
90996: PUSH
90997: LD_INT 0
90999: ST_TO_ADDR
// for i := 1 to 8 do
91000: LD_ADDR_VAR 0 1
91004: PUSH
91005: DOUBLE
91006: LD_INT 1
91008: DEC
91009: ST_TO_ADDR
91010: LD_INT 8
91012: PUSH
91013: FOR_TO
91014: IFFALSE 91062
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
91016: LD_OWVAR 2
91020: PUSH
91021: LD_VAR 0 1
91025: NONEQUAL
91026: PUSH
91027: LD_OWVAR 2
91031: PPUSH
91032: LD_VAR 0 1
91036: PPUSH
91037: CALL_OW 81
91041: PUSH
91042: LD_INT 2
91044: EQUAL
91045: AND
91046: IFFALSE 91060
// begin side := i ;
91048: LD_ADDR_VAR 0 3
91052: PUSH
91053: LD_VAR 0 1
91057: ST_TO_ADDR
// break ;
91058: GO 91062
// end ;
91060: GO 91013
91062: POP
91063: POP
// if not side then
91064: LD_VAR 0 3
91068: NOT
91069: IFFALSE 91073
// exit ;
91071: GO 91118
// for i := 1 to tmp do
91073: LD_ADDR_VAR 0 1
91077: PUSH
91078: DOUBLE
91079: LD_INT 1
91081: DEC
91082: ST_TO_ADDR
91083: LD_VAR 0 2
91087: PUSH
91088: FOR_TO
91089: IFFALSE 91116
// if Prob ( 60 ) then
91091: LD_INT 60
91093: PPUSH
91094: CALL_OW 13
91098: IFFALSE 91114
// SetSide ( i , side ) ;
91100: LD_VAR 0 1
91104: PPUSH
91105: LD_VAR 0 3
91109: PPUSH
91110: CALL_OW 235
91114: GO 91088
91116: POP
91117: POP
// end ;
91118: PPOPN 3
91120: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91121: LD_EXP 109
91125: PUSH
91126: LD_EXP 122
91130: AND
91131: IFFALSE 91250
91133: GO 91135
91135: DISABLE
91136: LD_INT 0
91138: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91139: LD_ADDR_VAR 0 1
91143: PUSH
91144: LD_INT 22
91146: PUSH
91147: LD_OWVAR 2
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PUSH
91156: LD_INT 21
91158: PUSH
91159: LD_INT 1
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: LD_INT 3
91168: PUSH
91169: LD_INT 23
91171: PUSH
91172: LD_INT 0
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: LIST
91187: PPUSH
91188: CALL_OW 69
91192: PUSH
91193: FOR_IN
91194: IFFALSE 91248
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
91196: LD_VAR 0 1
91200: PPUSH
91201: CALL_OW 257
91205: PUSH
91206: LD_INT 1
91208: PUSH
91209: LD_INT 2
91211: PUSH
91212: LD_INT 3
91214: PUSH
91215: LD_INT 4
91217: PUSH
91218: EMPTY
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: IN
91224: IFFALSE 91246
// SetClass ( un , rand ( 1 , 4 ) ) ;
91226: LD_VAR 0 1
91230: PPUSH
91231: LD_INT 1
91233: PPUSH
91234: LD_INT 4
91236: PPUSH
91237: CALL_OW 12
91241: PPUSH
91242: CALL_OW 336
91246: GO 91193
91248: POP
91249: POP
// end ;
91250: PPOPN 1
91252: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91253: LD_EXP 109
91257: PUSH
91258: LD_EXP 121
91262: AND
91263: IFFALSE 91342
91265: GO 91267
91267: DISABLE
91268: LD_INT 0
91270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91271: LD_ADDR_VAR 0 1
91275: PUSH
91276: LD_INT 22
91278: PUSH
91279: LD_OWVAR 2
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 21
91290: PUSH
91291: LD_INT 3
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PPUSH
91302: CALL_OW 69
91306: ST_TO_ADDR
// if not tmp then
91307: LD_VAR 0 1
91311: NOT
91312: IFFALSE 91316
// exit ;
91314: GO 91342
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91316: LD_VAR 0 1
91320: PUSH
91321: LD_INT 1
91323: PPUSH
91324: LD_VAR 0 1
91328: PPUSH
91329: CALL_OW 12
91333: ARRAY
91334: PPUSH
91335: LD_INT 100
91337: PPUSH
91338: CALL_OW 234
// end ;
91342: PPOPN 1
91344: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
91345: LD_EXP 109
91349: PUSH
91350: LD_EXP 123
91354: AND
91355: IFFALSE 91453
91357: GO 91359
91359: DISABLE
91360: LD_INT 0
91362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91363: LD_ADDR_VAR 0 1
91367: PUSH
91368: LD_INT 22
91370: PUSH
91371: LD_OWVAR 2
91375: PUSH
91376: EMPTY
91377: LIST
91378: LIST
91379: PUSH
91380: LD_INT 21
91382: PUSH
91383: LD_INT 1
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PPUSH
91394: CALL_OW 69
91398: ST_TO_ADDR
// if not tmp then
91399: LD_VAR 0 1
91403: NOT
91404: IFFALSE 91408
// exit ;
91406: GO 91453
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91408: LD_VAR 0 1
91412: PUSH
91413: LD_INT 1
91415: PPUSH
91416: LD_VAR 0 1
91420: PPUSH
91421: CALL_OW 12
91425: ARRAY
91426: PPUSH
91427: LD_INT 1
91429: PPUSH
91430: LD_INT 4
91432: PPUSH
91433: CALL_OW 12
91437: PPUSH
91438: LD_INT 3000
91440: PPUSH
91441: LD_INT 9000
91443: PPUSH
91444: CALL_OW 12
91448: PPUSH
91449: CALL_OW 492
// end ;
91453: PPOPN 1
91455: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91456: LD_EXP 109
91460: PUSH
91461: LD_EXP 124
91465: AND
91466: IFFALSE 91486
91468: GO 91470
91470: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91471: LD_INT 1
91473: PPUSH
91474: LD_OWVAR 2
91478: PPUSH
91479: LD_INT 0
91481: PPUSH
91482: CALL_OW 324
91486: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91487: LD_EXP 109
91491: PUSH
91492: LD_EXP 125
91496: AND
91497: IFFALSE 91580
91499: GO 91501
91501: DISABLE
91502: LD_INT 0
91504: PPUSH
91505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91506: LD_ADDR_VAR 0 2
91510: PUSH
91511: LD_INT 22
91513: PUSH
91514: LD_OWVAR 2
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 21
91525: PUSH
91526: LD_INT 3
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PPUSH
91537: CALL_OW 69
91541: ST_TO_ADDR
// if not tmp then
91542: LD_VAR 0 2
91546: NOT
91547: IFFALSE 91551
// exit ;
91549: GO 91580
// for i in tmp do
91551: LD_ADDR_VAR 0 1
91555: PUSH
91556: LD_VAR 0 2
91560: PUSH
91561: FOR_IN
91562: IFFALSE 91578
// SetBLevel ( i , 10 ) ;
91564: LD_VAR 0 1
91568: PPUSH
91569: LD_INT 10
91571: PPUSH
91572: CALL_OW 241
91576: GO 91561
91578: POP
91579: POP
// end ;
91580: PPOPN 2
91582: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91583: LD_EXP 109
91587: PUSH
91588: LD_EXP 126
91592: AND
91593: IFFALSE 91704
91595: GO 91597
91597: DISABLE
91598: LD_INT 0
91600: PPUSH
91601: PPUSH
91602: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91603: LD_ADDR_VAR 0 3
91607: PUSH
91608: LD_INT 22
91610: PUSH
91611: LD_OWVAR 2
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 25
91622: PUSH
91623: LD_INT 1
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PPUSH
91634: CALL_OW 69
91638: ST_TO_ADDR
// if not tmp then
91639: LD_VAR 0 3
91643: NOT
91644: IFFALSE 91648
// exit ;
91646: GO 91704
// un := tmp [ rand ( 1 , tmp ) ] ;
91648: LD_ADDR_VAR 0 2
91652: PUSH
91653: LD_VAR 0 3
91657: PUSH
91658: LD_INT 1
91660: PPUSH
91661: LD_VAR 0 3
91665: PPUSH
91666: CALL_OW 12
91670: ARRAY
91671: ST_TO_ADDR
// if Crawls ( un ) then
91672: LD_VAR 0 2
91676: PPUSH
91677: CALL_OW 318
91681: IFFALSE 91692
// ComWalk ( un ) ;
91683: LD_VAR 0 2
91687: PPUSH
91688: CALL_OW 138
// SetClass ( un , class_sniper ) ;
91692: LD_VAR 0 2
91696: PPUSH
91697: LD_INT 5
91699: PPUSH
91700: CALL_OW 336
// end ;
91704: PPOPN 3
91706: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
91707: LD_EXP 109
91711: PUSH
91712: LD_EXP 127
91716: AND
91717: PUSH
91718: LD_OWVAR 67
91722: PUSH
91723: LD_INT 3
91725: LESS
91726: AND
91727: IFFALSE 91746
91729: GO 91731
91731: DISABLE
// Difficulty := Difficulty + 1 ;
91732: LD_ADDR_OWVAR 67
91736: PUSH
91737: LD_OWVAR 67
91741: PUSH
91742: LD_INT 1
91744: PLUS
91745: ST_TO_ADDR
91746: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
91747: LD_EXP 109
91751: PUSH
91752: LD_EXP 128
91756: AND
91757: IFFALSE 91860
91759: GO 91761
91761: DISABLE
91762: LD_INT 0
91764: PPUSH
// begin for i := 1 to 5 do
91765: LD_ADDR_VAR 0 1
91769: PUSH
91770: DOUBLE
91771: LD_INT 1
91773: DEC
91774: ST_TO_ADDR
91775: LD_INT 5
91777: PUSH
91778: FOR_TO
91779: IFFALSE 91858
// begin uc_nation := nation_nature ;
91781: LD_ADDR_OWVAR 21
91785: PUSH
91786: LD_INT 0
91788: ST_TO_ADDR
// uc_side := 0 ;
91789: LD_ADDR_OWVAR 20
91793: PUSH
91794: LD_INT 0
91796: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91797: LD_ADDR_OWVAR 29
91801: PUSH
91802: LD_INT 12
91804: PUSH
91805: LD_INT 12
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: ST_TO_ADDR
// hc_agressivity := 20 ;
91812: LD_ADDR_OWVAR 35
91816: PUSH
91817: LD_INT 20
91819: ST_TO_ADDR
// hc_class := class_tiger ;
91820: LD_ADDR_OWVAR 28
91824: PUSH
91825: LD_INT 14
91827: ST_TO_ADDR
// hc_gallery :=  ;
91828: LD_ADDR_OWVAR 33
91832: PUSH
91833: LD_STRING 
91835: ST_TO_ADDR
// hc_name :=  ;
91836: LD_ADDR_OWVAR 26
91840: PUSH
91841: LD_STRING 
91843: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91844: CALL_OW 44
91848: PPUSH
91849: LD_INT 0
91851: PPUSH
91852: CALL_OW 51
// end ;
91856: GO 91778
91858: POP
91859: POP
// end ;
91860: PPOPN 1
91862: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91863: LD_EXP 109
91867: PUSH
91868: LD_EXP 129
91872: AND
91873: IFFALSE 91882
91875: GO 91877
91877: DISABLE
// StreamSibBomb ;
91878: CALL 91883 0 0
91882: END
// export function StreamSibBomb ; var i , x , y ; begin
91883: LD_INT 0
91885: PPUSH
91886: PPUSH
91887: PPUSH
91888: PPUSH
// result := false ;
91889: LD_ADDR_VAR 0 1
91893: PUSH
91894: LD_INT 0
91896: ST_TO_ADDR
// for i := 1 to 16 do
91897: LD_ADDR_VAR 0 2
91901: PUSH
91902: DOUBLE
91903: LD_INT 1
91905: DEC
91906: ST_TO_ADDR
91907: LD_INT 16
91909: PUSH
91910: FOR_TO
91911: IFFALSE 92110
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91913: LD_ADDR_VAR 0 3
91917: PUSH
91918: LD_INT 10
91920: PUSH
91921: LD_INT 20
91923: PUSH
91924: LD_INT 30
91926: PUSH
91927: LD_INT 40
91929: PUSH
91930: LD_INT 50
91932: PUSH
91933: LD_INT 60
91935: PUSH
91936: LD_INT 70
91938: PUSH
91939: LD_INT 80
91941: PUSH
91942: LD_INT 90
91944: PUSH
91945: LD_INT 100
91947: PUSH
91948: LD_INT 110
91950: PUSH
91951: LD_INT 120
91953: PUSH
91954: LD_INT 130
91956: PUSH
91957: LD_INT 140
91959: PUSH
91960: LD_INT 150
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: PUSH
91980: LD_INT 1
91982: PPUSH
91983: LD_INT 15
91985: PPUSH
91986: CALL_OW 12
91990: ARRAY
91991: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91992: LD_ADDR_VAR 0 4
91996: PUSH
91997: LD_INT 10
91999: PUSH
92000: LD_INT 20
92002: PUSH
92003: LD_INT 30
92005: PUSH
92006: LD_INT 40
92008: PUSH
92009: LD_INT 50
92011: PUSH
92012: LD_INT 60
92014: PUSH
92015: LD_INT 70
92017: PUSH
92018: LD_INT 80
92020: PUSH
92021: LD_INT 90
92023: PUSH
92024: LD_INT 100
92026: PUSH
92027: LD_INT 110
92029: PUSH
92030: LD_INT 120
92032: PUSH
92033: LD_INT 130
92035: PUSH
92036: LD_INT 140
92038: PUSH
92039: LD_INT 150
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: PUSH
92059: LD_INT 1
92061: PPUSH
92062: LD_INT 15
92064: PPUSH
92065: CALL_OW 12
92069: ARRAY
92070: ST_TO_ADDR
// if ValidHex ( x , y ) then
92071: LD_VAR 0 3
92075: PPUSH
92076: LD_VAR 0 4
92080: PPUSH
92081: CALL_OW 488
92085: IFFALSE 92108
// begin result := [ x , y ] ;
92087: LD_ADDR_VAR 0 1
92091: PUSH
92092: LD_VAR 0 3
92096: PUSH
92097: LD_VAR 0 4
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: ST_TO_ADDR
// break ;
92106: GO 92110
// end ; end ;
92108: GO 91910
92110: POP
92111: POP
// if result then
92112: LD_VAR 0 1
92116: IFFALSE 92176
// begin ToLua ( playSibBomb() ) ;
92118: LD_STRING playSibBomb()
92120: PPUSH
92121: CALL_OW 559
// wait ( 0 0$14 ) ;
92125: LD_INT 490
92127: PPUSH
92128: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92132: LD_VAR 0 1
92136: PUSH
92137: LD_INT 1
92139: ARRAY
92140: PPUSH
92141: LD_VAR 0 1
92145: PUSH
92146: LD_INT 2
92148: ARRAY
92149: PPUSH
92150: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92154: LD_VAR 0 1
92158: PUSH
92159: LD_INT 1
92161: ARRAY
92162: PPUSH
92163: LD_VAR 0 1
92167: PUSH
92168: LD_INT 2
92170: ARRAY
92171: PPUSH
92172: CALL_OW 429
// end ; end ;
92176: LD_VAR 0 1
92180: RET
// every 0 0$1 trigger StreamModeActive and sReset do
92181: LD_EXP 109
92185: PUSH
92186: LD_EXP 131
92190: AND
92191: IFFALSE 92203
92193: GO 92195
92195: DISABLE
// YouLost (  ) ;
92196: LD_STRING 
92198: PPUSH
92199: CALL_OW 104
92203: END
// every 0 0$1 trigger StreamModeActive and sFog do
92204: LD_EXP 109
92208: PUSH
92209: LD_EXP 130
92213: AND
92214: IFFALSE 92228
92216: GO 92218
92218: DISABLE
// FogOff ( your_side ) ;
92219: LD_OWVAR 2
92223: PPUSH
92224: CALL_OW 344
92228: END
// every 0 0$1 trigger StreamModeActive and sSun do
92229: LD_EXP 109
92233: PUSH
92234: LD_EXP 132
92238: AND
92239: IFFALSE 92267
92241: GO 92243
92243: DISABLE
// begin solar_recharge_percent := 0 ;
92244: LD_ADDR_OWVAR 79
92248: PUSH
92249: LD_INT 0
92251: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92252: LD_INT 10500
92254: PPUSH
92255: CALL_OW 67
// solar_recharge_percent := 100 ;
92259: LD_ADDR_OWVAR 79
92263: PUSH
92264: LD_INT 100
92266: ST_TO_ADDR
// end ;
92267: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92268: LD_EXP 109
92272: PUSH
92273: LD_EXP 133
92277: AND
92278: IFFALSE 92517
92280: GO 92282
92282: DISABLE
92283: LD_INT 0
92285: PPUSH
92286: PPUSH
92287: PPUSH
// begin tmp := [ ] ;
92288: LD_ADDR_VAR 0 3
92292: PUSH
92293: EMPTY
92294: ST_TO_ADDR
// for i := 1 to 6 do
92295: LD_ADDR_VAR 0 1
92299: PUSH
92300: DOUBLE
92301: LD_INT 1
92303: DEC
92304: ST_TO_ADDR
92305: LD_INT 6
92307: PUSH
92308: FOR_TO
92309: IFFALSE 92414
// begin uc_nation := nation_nature ;
92311: LD_ADDR_OWVAR 21
92315: PUSH
92316: LD_INT 0
92318: ST_TO_ADDR
// uc_side := 0 ;
92319: LD_ADDR_OWVAR 20
92323: PUSH
92324: LD_INT 0
92326: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92327: LD_ADDR_OWVAR 29
92331: PUSH
92332: LD_INT 12
92334: PUSH
92335: LD_INT 12
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: ST_TO_ADDR
// hc_agressivity := 20 ;
92342: LD_ADDR_OWVAR 35
92346: PUSH
92347: LD_INT 20
92349: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
92350: LD_ADDR_OWVAR 28
92354: PUSH
92355: LD_INT 17
92357: ST_TO_ADDR
// hc_gallery :=  ;
92358: LD_ADDR_OWVAR 33
92362: PUSH
92363: LD_STRING 
92365: ST_TO_ADDR
// hc_name :=  ;
92366: LD_ADDR_OWVAR 26
92370: PUSH
92371: LD_STRING 
92373: ST_TO_ADDR
// un := CreateHuman ;
92374: LD_ADDR_VAR 0 2
92378: PUSH
92379: CALL_OW 44
92383: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92384: LD_VAR 0 2
92388: PPUSH
92389: LD_INT 1
92391: PPUSH
92392: CALL_OW 51
// tmp := tmp ^ un ;
92396: LD_ADDR_VAR 0 3
92400: PUSH
92401: LD_VAR 0 3
92405: PUSH
92406: LD_VAR 0 2
92410: ADD
92411: ST_TO_ADDR
// end ;
92412: GO 92308
92414: POP
92415: POP
// repeat wait ( 0 0$1 ) ;
92416: LD_INT 35
92418: PPUSH
92419: CALL_OW 67
// for un in tmp do
92423: LD_ADDR_VAR 0 2
92427: PUSH
92428: LD_VAR 0 3
92432: PUSH
92433: FOR_IN
92434: IFFALSE 92508
// begin if IsDead ( un ) then
92436: LD_VAR 0 2
92440: PPUSH
92441: CALL_OW 301
92445: IFFALSE 92465
// begin tmp := tmp diff un ;
92447: LD_ADDR_VAR 0 3
92451: PUSH
92452: LD_VAR 0 3
92456: PUSH
92457: LD_VAR 0 2
92461: DIFF
92462: ST_TO_ADDR
// continue ;
92463: GO 92433
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92465: LD_VAR 0 2
92469: PPUSH
92470: LD_INT 3
92472: PUSH
92473: LD_INT 22
92475: PUSH
92476: LD_INT 0
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PPUSH
92487: CALL_OW 69
92491: PPUSH
92492: LD_VAR 0 2
92496: PPUSH
92497: CALL_OW 74
92501: PPUSH
92502: CALL_OW 115
// end ;
92506: GO 92433
92508: POP
92509: POP
// until not tmp ;
92510: LD_VAR 0 3
92514: NOT
92515: IFFALSE 92416
// end ;
92517: PPOPN 3
92519: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92520: LD_EXP 109
92524: PUSH
92525: LD_EXP 134
92529: AND
92530: IFFALSE 92584
92532: GO 92534
92534: DISABLE
// begin ToLua ( displayTroll(); ) ;
92535: LD_STRING displayTroll();
92537: PPUSH
92538: CALL_OW 559
// wait ( 3 3$00 ) ;
92542: LD_INT 6300
92544: PPUSH
92545: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92549: LD_STRING hideTroll();
92551: PPUSH
92552: CALL_OW 559
// wait ( 1 1$00 ) ;
92556: LD_INT 2100
92558: PPUSH
92559: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92563: LD_STRING displayTroll();
92565: PPUSH
92566: CALL_OW 559
// wait ( 1 1$00 ) ;
92570: LD_INT 2100
92572: PPUSH
92573: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92577: LD_STRING hideTroll();
92579: PPUSH
92580: CALL_OW 559
// end ;
92584: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92585: LD_EXP 109
92589: PUSH
92590: LD_EXP 135
92594: AND
92595: IFFALSE 92658
92597: GO 92599
92599: DISABLE
92600: LD_INT 0
92602: PPUSH
// begin p := 0 ;
92603: LD_ADDR_VAR 0 1
92607: PUSH
92608: LD_INT 0
92610: ST_TO_ADDR
// repeat game_speed := 1 ;
92611: LD_ADDR_OWVAR 65
92615: PUSH
92616: LD_INT 1
92618: ST_TO_ADDR
// wait ( 0 0$1 ) ;
92619: LD_INT 35
92621: PPUSH
92622: CALL_OW 67
// p := p + 1 ;
92626: LD_ADDR_VAR 0 1
92630: PUSH
92631: LD_VAR 0 1
92635: PUSH
92636: LD_INT 1
92638: PLUS
92639: ST_TO_ADDR
// until p >= 60 ;
92640: LD_VAR 0 1
92644: PUSH
92645: LD_INT 60
92647: GREATEREQUAL
92648: IFFALSE 92611
// game_speed := 4 ;
92650: LD_ADDR_OWVAR 65
92654: PUSH
92655: LD_INT 4
92657: ST_TO_ADDR
// end ;
92658: PPOPN 1
92660: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
92661: LD_EXP 109
92665: PUSH
92666: LD_EXP 136
92670: AND
92671: IFFALSE 92817
92673: GO 92675
92675: DISABLE
92676: LD_INT 0
92678: PPUSH
92679: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92680: LD_ADDR_VAR 0 1
92684: PUSH
92685: LD_INT 22
92687: PUSH
92688: LD_OWVAR 2
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 2
92699: PUSH
92700: LD_INT 30
92702: PUSH
92703: LD_INT 0
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 30
92712: PUSH
92713: LD_INT 1
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: LIST
92724: PUSH
92725: EMPTY
92726: LIST
92727: LIST
92728: PPUSH
92729: CALL_OW 69
92733: ST_TO_ADDR
// if not depot then
92734: LD_VAR 0 1
92738: NOT
92739: IFFALSE 92743
// exit ;
92741: GO 92817
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
92743: LD_ADDR_VAR 0 2
92747: PUSH
92748: LD_VAR 0 1
92752: PUSH
92753: LD_INT 1
92755: PPUSH
92756: LD_VAR 0 1
92760: PPUSH
92761: CALL_OW 12
92765: ARRAY
92766: PPUSH
92767: CALL_OW 274
92771: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
92772: LD_VAR 0 2
92776: PPUSH
92777: LD_INT 1
92779: PPUSH
92780: LD_INT 0
92782: PPUSH
92783: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
92787: LD_VAR 0 2
92791: PPUSH
92792: LD_INT 2
92794: PPUSH
92795: LD_INT 0
92797: PPUSH
92798: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
92802: LD_VAR 0 2
92806: PPUSH
92807: LD_INT 3
92809: PPUSH
92810: LD_INT 0
92812: PPUSH
92813: CALL_OW 277
// end ;
92817: PPOPN 2
92819: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
92820: LD_EXP 109
92824: PUSH
92825: LD_EXP 137
92829: AND
92830: IFFALSE 92927
92832: GO 92834
92834: DISABLE
92835: LD_INT 0
92837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92838: LD_ADDR_VAR 0 1
92842: PUSH
92843: LD_INT 22
92845: PUSH
92846: LD_OWVAR 2
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 21
92857: PUSH
92858: LD_INT 1
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 3
92867: PUSH
92868: LD_INT 23
92870: PUSH
92871: LD_INT 0
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: LIST
92886: PPUSH
92887: CALL_OW 69
92891: ST_TO_ADDR
// if not tmp then
92892: LD_VAR 0 1
92896: NOT
92897: IFFALSE 92901
// exit ;
92899: GO 92927
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92901: LD_VAR 0 1
92905: PUSH
92906: LD_INT 1
92908: PPUSH
92909: LD_VAR 0 1
92913: PPUSH
92914: CALL_OW 12
92918: ARRAY
92919: PPUSH
92920: LD_INT 200
92922: PPUSH
92923: CALL_OW 234
// end ;
92927: PPOPN 1
92929: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92930: LD_EXP 109
92934: PUSH
92935: LD_EXP 138
92939: AND
92940: IFFALSE 93019
92942: GO 92944
92944: DISABLE
92945: LD_INT 0
92947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92948: LD_ADDR_VAR 0 1
92952: PUSH
92953: LD_INT 22
92955: PUSH
92956: LD_OWVAR 2
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 21
92967: PUSH
92968: LD_INT 2
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PPUSH
92979: CALL_OW 69
92983: ST_TO_ADDR
// if not tmp then
92984: LD_VAR 0 1
92988: NOT
92989: IFFALSE 92993
// exit ;
92991: GO 93019
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92993: LD_VAR 0 1
92997: PUSH
92998: LD_INT 1
93000: PPUSH
93001: LD_VAR 0 1
93005: PPUSH
93006: CALL_OW 12
93010: ARRAY
93011: PPUSH
93012: LD_INT 60
93014: PPUSH
93015: CALL_OW 234
// end ;
93019: PPOPN 1
93021: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
93022: LD_EXP 109
93026: PUSH
93027: LD_EXP 139
93031: AND
93032: IFFALSE 93131
93034: GO 93036
93036: DISABLE
93037: LD_INT 0
93039: PPUSH
93040: PPUSH
// begin enable ;
93041: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
93042: LD_ADDR_VAR 0 1
93046: PUSH
93047: LD_INT 22
93049: PUSH
93050: LD_OWVAR 2
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: PUSH
93059: LD_INT 61
93061: PUSH
93062: EMPTY
93063: LIST
93064: PUSH
93065: LD_INT 33
93067: PUSH
93068: LD_INT 2
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: LIST
93079: PPUSH
93080: CALL_OW 69
93084: ST_TO_ADDR
// if not tmp then
93085: LD_VAR 0 1
93089: NOT
93090: IFFALSE 93094
// exit ;
93092: GO 93131
// for i in tmp do
93094: LD_ADDR_VAR 0 2
93098: PUSH
93099: LD_VAR 0 1
93103: PUSH
93104: FOR_IN
93105: IFFALSE 93129
// if IsControledBy ( i ) then
93107: LD_VAR 0 2
93111: PPUSH
93112: CALL_OW 312
93116: IFFALSE 93127
// ComUnlink ( i ) ;
93118: LD_VAR 0 2
93122: PPUSH
93123: CALL_OW 136
93127: GO 93104
93129: POP
93130: POP
// end ;
93131: PPOPN 2
93133: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93134: LD_EXP 109
93138: PUSH
93139: LD_EXP 140
93143: AND
93144: IFFALSE 93284
93146: GO 93148
93148: DISABLE
93149: LD_INT 0
93151: PPUSH
93152: PPUSH
// begin ToLua ( displayPowell(); ) ;
93153: LD_STRING displayPowell();
93155: PPUSH
93156: CALL_OW 559
// uc_side := 0 ;
93160: LD_ADDR_OWVAR 20
93164: PUSH
93165: LD_INT 0
93167: ST_TO_ADDR
// uc_nation := 2 ;
93168: LD_ADDR_OWVAR 21
93172: PUSH
93173: LD_INT 2
93175: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
93176: LD_ADDR_OWVAR 37
93180: PUSH
93181: LD_INT 14
93183: ST_TO_ADDR
// vc_engine := engine_siberite ;
93184: LD_ADDR_OWVAR 39
93188: PUSH
93189: LD_INT 3
93191: ST_TO_ADDR
// vc_control := control_apeman ;
93192: LD_ADDR_OWVAR 38
93196: PUSH
93197: LD_INT 5
93199: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
93200: LD_ADDR_OWVAR 40
93204: PUSH
93205: LD_INT 29
93207: ST_TO_ADDR
// un := CreateVehicle ;
93208: LD_ADDR_VAR 0 2
93212: PUSH
93213: CALL_OW 45
93217: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93218: LD_VAR 0 2
93222: PPUSH
93223: LD_INT 1
93225: PPUSH
93226: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93230: LD_INT 35
93232: PPUSH
93233: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93237: LD_VAR 0 2
93241: PPUSH
93242: LD_INT 22
93244: PUSH
93245: LD_OWVAR 2
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PPUSH
93254: CALL_OW 69
93258: PPUSH
93259: LD_VAR 0 2
93263: PPUSH
93264: CALL_OW 74
93268: PPUSH
93269: CALL_OW 115
// until IsDead ( un ) ;
93273: LD_VAR 0 2
93277: PPUSH
93278: CALL_OW 301
93282: IFFALSE 93230
// end ;
93284: PPOPN 2
93286: END
// every 0 0$1 trigger StreamModeActive and sStu do
93287: LD_EXP 109
93291: PUSH
93292: LD_EXP 148
93296: AND
93297: IFFALSE 93313
93299: GO 93301
93301: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93302: LD_STRING displayStucuk();
93304: PPUSH
93305: CALL_OW 559
// ResetFog ;
93309: CALL_OW 335
// end ;
93313: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93314: LD_EXP 109
93318: PUSH
93319: LD_EXP 141
93323: AND
93324: IFFALSE 93465
93326: GO 93328
93328: DISABLE
93329: LD_INT 0
93331: PPUSH
93332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93333: LD_ADDR_VAR 0 2
93337: PUSH
93338: LD_INT 22
93340: PUSH
93341: LD_OWVAR 2
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 21
93352: PUSH
93353: LD_INT 1
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PPUSH
93364: CALL_OW 69
93368: ST_TO_ADDR
// if not tmp then
93369: LD_VAR 0 2
93373: NOT
93374: IFFALSE 93378
// exit ;
93376: GO 93465
// un := tmp [ rand ( 1 , tmp ) ] ;
93378: LD_ADDR_VAR 0 1
93382: PUSH
93383: LD_VAR 0 2
93387: PUSH
93388: LD_INT 1
93390: PPUSH
93391: LD_VAR 0 2
93395: PPUSH
93396: CALL_OW 12
93400: ARRAY
93401: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93402: LD_VAR 0 1
93406: PPUSH
93407: LD_INT 0
93409: PPUSH
93410: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93414: LD_VAR 0 1
93418: PPUSH
93419: LD_OWVAR 3
93423: PUSH
93424: LD_VAR 0 1
93428: DIFF
93429: PPUSH
93430: LD_VAR 0 1
93434: PPUSH
93435: CALL_OW 74
93439: PPUSH
93440: CALL_OW 115
// wait ( 0 0$20 ) ;
93444: LD_INT 700
93446: PPUSH
93447: CALL_OW 67
// SetSide ( un , your_side ) ;
93451: LD_VAR 0 1
93455: PPUSH
93456: LD_OWVAR 2
93460: PPUSH
93461: CALL_OW 235
// end ;
93465: PPOPN 2
93467: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93468: LD_EXP 109
93472: PUSH
93473: LD_EXP 142
93477: AND
93478: IFFALSE 93584
93480: GO 93482
93482: DISABLE
93483: LD_INT 0
93485: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93486: LD_ADDR_VAR 0 1
93490: PUSH
93491: LD_INT 22
93493: PUSH
93494: LD_OWVAR 2
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 2
93505: PUSH
93506: LD_INT 30
93508: PUSH
93509: LD_INT 0
93511: PUSH
93512: EMPTY
93513: LIST
93514: LIST
93515: PUSH
93516: LD_INT 30
93518: PUSH
93519: LD_INT 1
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: LIST
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PPUSH
93535: CALL_OW 69
93539: ST_TO_ADDR
// if not depot then
93540: LD_VAR 0 1
93544: NOT
93545: IFFALSE 93549
// exit ;
93547: GO 93584
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93549: LD_VAR 0 1
93553: PUSH
93554: LD_INT 1
93556: ARRAY
93557: PPUSH
93558: CALL_OW 250
93562: PPUSH
93563: LD_VAR 0 1
93567: PUSH
93568: LD_INT 1
93570: ARRAY
93571: PPUSH
93572: CALL_OW 251
93576: PPUSH
93577: LD_INT 70
93579: PPUSH
93580: CALL_OW 495
// end ;
93584: PPOPN 1
93586: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93587: LD_EXP 109
93591: PUSH
93592: LD_EXP 143
93596: AND
93597: IFFALSE 93808
93599: GO 93601
93601: DISABLE
93602: LD_INT 0
93604: PPUSH
93605: PPUSH
93606: PPUSH
93607: PPUSH
93608: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93609: LD_ADDR_VAR 0 5
93613: PUSH
93614: LD_INT 22
93616: PUSH
93617: LD_OWVAR 2
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: LD_INT 21
93628: PUSH
93629: LD_INT 1
93631: PUSH
93632: EMPTY
93633: LIST
93634: LIST
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PPUSH
93640: CALL_OW 69
93644: ST_TO_ADDR
// if not tmp then
93645: LD_VAR 0 5
93649: NOT
93650: IFFALSE 93654
// exit ;
93652: GO 93808
// for i in tmp do
93654: LD_ADDR_VAR 0 1
93658: PUSH
93659: LD_VAR 0 5
93663: PUSH
93664: FOR_IN
93665: IFFALSE 93806
// begin d := rand ( 0 , 5 ) ;
93667: LD_ADDR_VAR 0 4
93671: PUSH
93672: LD_INT 0
93674: PPUSH
93675: LD_INT 5
93677: PPUSH
93678: CALL_OW 12
93682: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
93683: LD_ADDR_VAR 0 2
93687: PUSH
93688: LD_VAR 0 1
93692: PPUSH
93693: CALL_OW 250
93697: PPUSH
93698: LD_VAR 0 4
93702: PPUSH
93703: LD_INT 3
93705: PPUSH
93706: LD_INT 12
93708: PPUSH
93709: CALL_OW 12
93713: PPUSH
93714: CALL_OW 272
93718: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
93719: LD_ADDR_VAR 0 3
93723: PUSH
93724: LD_VAR 0 1
93728: PPUSH
93729: CALL_OW 251
93733: PPUSH
93734: LD_VAR 0 4
93738: PPUSH
93739: LD_INT 3
93741: PPUSH
93742: LD_INT 12
93744: PPUSH
93745: CALL_OW 12
93749: PPUSH
93750: CALL_OW 273
93754: ST_TO_ADDR
// if ValidHex ( x , y ) then
93755: LD_VAR 0 2
93759: PPUSH
93760: LD_VAR 0 3
93764: PPUSH
93765: CALL_OW 488
93769: IFFALSE 93804
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
93771: LD_VAR 0 1
93775: PPUSH
93776: LD_VAR 0 2
93780: PPUSH
93781: LD_VAR 0 3
93785: PPUSH
93786: LD_INT 3
93788: PPUSH
93789: LD_INT 6
93791: PPUSH
93792: CALL_OW 12
93796: PPUSH
93797: LD_INT 1
93799: PPUSH
93800: CALL_OW 483
// end ;
93804: GO 93664
93806: POP
93807: POP
// end ;
93808: PPOPN 5
93810: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
93811: LD_EXP 109
93815: PUSH
93816: LD_EXP 144
93820: AND
93821: IFFALSE 93915
93823: GO 93825
93825: DISABLE
93826: LD_INT 0
93828: PPUSH
93829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93830: LD_ADDR_VAR 0 2
93834: PUSH
93835: LD_INT 22
93837: PUSH
93838: LD_OWVAR 2
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: LD_INT 32
93849: PUSH
93850: LD_INT 1
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: LD_INT 21
93859: PUSH
93860: LD_INT 2
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: LIST
93871: PPUSH
93872: CALL_OW 69
93876: ST_TO_ADDR
// if not tmp then
93877: LD_VAR 0 2
93881: NOT
93882: IFFALSE 93886
// exit ;
93884: GO 93915
// for i in tmp do
93886: LD_ADDR_VAR 0 1
93890: PUSH
93891: LD_VAR 0 2
93895: PUSH
93896: FOR_IN
93897: IFFALSE 93913
// SetFuel ( i , 0 ) ;
93899: LD_VAR 0 1
93903: PPUSH
93904: LD_INT 0
93906: PPUSH
93907: CALL_OW 240
93911: GO 93896
93913: POP
93914: POP
// end ;
93915: PPOPN 2
93917: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93918: LD_EXP 109
93922: PUSH
93923: LD_EXP 145
93927: AND
93928: IFFALSE 93994
93930: GO 93932
93932: DISABLE
93933: LD_INT 0
93935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93936: LD_ADDR_VAR 0 1
93940: PUSH
93941: LD_INT 22
93943: PUSH
93944: LD_OWVAR 2
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 30
93955: PUSH
93956: LD_INT 29
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PPUSH
93967: CALL_OW 69
93971: ST_TO_ADDR
// if not tmp then
93972: LD_VAR 0 1
93976: NOT
93977: IFFALSE 93981
// exit ;
93979: GO 93994
// DestroyUnit ( tmp [ 1 ] ) ;
93981: LD_VAR 0 1
93985: PUSH
93986: LD_INT 1
93988: ARRAY
93989: PPUSH
93990: CALL_OW 65
// end ;
93994: PPOPN 1
93996: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93997: LD_EXP 109
94001: PUSH
94002: LD_EXP 147
94006: AND
94007: IFFALSE 94136
94009: GO 94011
94011: DISABLE
94012: LD_INT 0
94014: PPUSH
// begin uc_side := 0 ;
94015: LD_ADDR_OWVAR 20
94019: PUSH
94020: LD_INT 0
94022: ST_TO_ADDR
// uc_nation := nation_arabian ;
94023: LD_ADDR_OWVAR 21
94027: PUSH
94028: LD_INT 2
94030: ST_TO_ADDR
// hc_gallery :=  ;
94031: LD_ADDR_OWVAR 33
94035: PUSH
94036: LD_STRING 
94038: ST_TO_ADDR
// hc_name :=  ;
94039: LD_ADDR_OWVAR 26
94043: PUSH
94044: LD_STRING 
94046: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
94047: LD_INT 1
94049: PPUSH
94050: LD_INT 11
94052: PPUSH
94053: LD_INT 10
94055: PPUSH
94056: CALL_OW 380
// un := CreateHuman ;
94060: LD_ADDR_VAR 0 1
94064: PUSH
94065: CALL_OW 44
94069: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94070: LD_VAR 0 1
94074: PPUSH
94075: LD_INT 1
94077: PPUSH
94078: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94082: LD_INT 35
94084: PPUSH
94085: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94089: LD_VAR 0 1
94093: PPUSH
94094: LD_INT 22
94096: PUSH
94097: LD_OWVAR 2
94101: PUSH
94102: EMPTY
94103: LIST
94104: LIST
94105: PPUSH
94106: CALL_OW 69
94110: PPUSH
94111: LD_VAR 0 1
94115: PPUSH
94116: CALL_OW 74
94120: PPUSH
94121: CALL_OW 115
// until IsDead ( un ) ;
94125: LD_VAR 0 1
94129: PPUSH
94130: CALL_OW 301
94134: IFFALSE 94082
// end ;
94136: PPOPN 1
94138: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94139: LD_EXP 109
94143: PUSH
94144: LD_EXP 149
94148: AND
94149: IFFALSE 94161
94151: GO 94153
94153: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94154: LD_STRING earthquake(getX(game), 0, 32)
94156: PPUSH
94157: CALL_OW 559
94161: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94162: LD_EXP 109
94166: PUSH
94167: LD_EXP 150
94171: AND
94172: IFFALSE 94263
94174: GO 94176
94176: DISABLE
94177: LD_INT 0
94179: PPUSH
// begin enable ;
94180: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
94181: LD_ADDR_VAR 0 1
94185: PUSH
94186: LD_INT 22
94188: PUSH
94189: LD_OWVAR 2
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 21
94200: PUSH
94201: LD_INT 2
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 33
94210: PUSH
94211: LD_INT 3
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: LIST
94222: PPUSH
94223: CALL_OW 69
94227: ST_TO_ADDR
// if not tmp then
94228: LD_VAR 0 1
94232: NOT
94233: IFFALSE 94237
// exit ;
94235: GO 94263
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94237: LD_VAR 0 1
94241: PUSH
94242: LD_INT 1
94244: PPUSH
94245: LD_VAR 0 1
94249: PPUSH
94250: CALL_OW 12
94254: ARRAY
94255: PPUSH
94256: LD_INT 1
94258: PPUSH
94259: CALL_OW 234
// end ;
94263: PPOPN 1
94265: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94266: LD_EXP 109
94270: PUSH
94271: LD_EXP 151
94275: AND
94276: IFFALSE 94417
94278: GO 94280
94280: DISABLE
94281: LD_INT 0
94283: PPUSH
94284: PPUSH
94285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94286: LD_ADDR_VAR 0 3
94290: PUSH
94291: LD_INT 22
94293: PUSH
94294: LD_OWVAR 2
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: PUSH
94303: LD_INT 25
94305: PUSH
94306: LD_INT 1
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PPUSH
94317: CALL_OW 69
94321: ST_TO_ADDR
// if not tmp then
94322: LD_VAR 0 3
94326: NOT
94327: IFFALSE 94331
// exit ;
94329: GO 94417
// un := tmp [ rand ( 1 , tmp ) ] ;
94331: LD_ADDR_VAR 0 2
94335: PUSH
94336: LD_VAR 0 3
94340: PUSH
94341: LD_INT 1
94343: PPUSH
94344: LD_VAR 0 3
94348: PPUSH
94349: CALL_OW 12
94353: ARRAY
94354: ST_TO_ADDR
// if Crawls ( un ) then
94355: LD_VAR 0 2
94359: PPUSH
94360: CALL_OW 318
94364: IFFALSE 94375
// ComWalk ( un ) ;
94366: LD_VAR 0 2
94370: PPUSH
94371: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94375: LD_VAR 0 2
94379: PPUSH
94380: LD_INT 9
94382: PPUSH
94383: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94387: LD_INT 28
94389: PPUSH
94390: LD_OWVAR 2
94394: PPUSH
94395: LD_INT 2
94397: PPUSH
94398: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94402: LD_INT 29
94404: PPUSH
94405: LD_OWVAR 2
94409: PPUSH
94410: LD_INT 2
94412: PPUSH
94413: CALL_OW 322
// end ;
94417: PPOPN 3
94419: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94420: LD_EXP 109
94424: PUSH
94425: LD_EXP 152
94429: AND
94430: IFFALSE 94541
94432: GO 94434
94434: DISABLE
94435: LD_INT 0
94437: PPUSH
94438: PPUSH
94439: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94440: LD_ADDR_VAR 0 3
94444: PUSH
94445: LD_INT 22
94447: PUSH
94448: LD_OWVAR 2
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 25
94459: PUSH
94460: LD_INT 1
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: PPUSH
94471: CALL_OW 69
94475: ST_TO_ADDR
// if not tmp then
94476: LD_VAR 0 3
94480: NOT
94481: IFFALSE 94485
// exit ;
94483: GO 94541
// un := tmp [ rand ( 1 , tmp ) ] ;
94485: LD_ADDR_VAR 0 2
94489: PUSH
94490: LD_VAR 0 3
94494: PUSH
94495: LD_INT 1
94497: PPUSH
94498: LD_VAR 0 3
94502: PPUSH
94503: CALL_OW 12
94507: ARRAY
94508: ST_TO_ADDR
// if Crawls ( un ) then
94509: LD_VAR 0 2
94513: PPUSH
94514: CALL_OW 318
94518: IFFALSE 94529
// ComWalk ( un ) ;
94520: LD_VAR 0 2
94524: PPUSH
94525: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94529: LD_VAR 0 2
94533: PPUSH
94534: LD_INT 8
94536: PPUSH
94537: CALL_OW 336
// end ;
94541: PPOPN 3
94543: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94544: LD_EXP 109
94548: PUSH
94549: LD_EXP 153
94553: AND
94554: IFFALSE 94698
94556: GO 94558
94558: DISABLE
94559: LD_INT 0
94561: PPUSH
94562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94563: LD_ADDR_VAR 0 2
94567: PUSH
94568: LD_INT 22
94570: PUSH
94571: LD_OWVAR 2
94575: PUSH
94576: EMPTY
94577: LIST
94578: LIST
94579: PUSH
94580: LD_INT 21
94582: PUSH
94583: LD_INT 2
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PUSH
94590: LD_INT 2
94592: PUSH
94593: LD_INT 34
94595: PUSH
94596: LD_INT 12
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 34
94605: PUSH
94606: LD_INT 51
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 34
94615: PUSH
94616: LD_INT 32
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: PUSH
94629: EMPTY
94630: LIST
94631: LIST
94632: LIST
94633: PPUSH
94634: CALL_OW 69
94638: ST_TO_ADDR
// if not tmp then
94639: LD_VAR 0 2
94643: NOT
94644: IFFALSE 94648
// exit ;
94646: GO 94698
// for i in tmp do
94648: LD_ADDR_VAR 0 1
94652: PUSH
94653: LD_VAR 0 2
94657: PUSH
94658: FOR_IN
94659: IFFALSE 94696
// if GetCargo ( i , mat_artifact ) = 0 then
94661: LD_VAR 0 1
94665: PPUSH
94666: LD_INT 4
94668: PPUSH
94669: CALL_OW 289
94673: PUSH
94674: LD_INT 0
94676: EQUAL
94677: IFFALSE 94694
// SetCargo ( i , mat_siberit , 100 ) ;
94679: LD_VAR 0 1
94683: PPUSH
94684: LD_INT 3
94686: PPUSH
94687: LD_INT 100
94689: PPUSH
94690: CALL_OW 290
94694: GO 94658
94696: POP
94697: POP
// end ;
94698: PPOPN 2
94700: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
94701: LD_EXP 109
94705: PUSH
94706: LD_EXP 154
94710: AND
94711: IFFALSE 94894
94713: GO 94715
94715: DISABLE
94716: LD_INT 0
94718: PPUSH
94719: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
94720: LD_ADDR_VAR 0 2
94724: PUSH
94725: LD_INT 22
94727: PUSH
94728: LD_OWVAR 2
94732: PUSH
94733: EMPTY
94734: LIST
94735: LIST
94736: PPUSH
94737: CALL_OW 69
94741: ST_TO_ADDR
// if not tmp then
94742: LD_VAR 0 2
94746: NOT
94747: IFFALSE 94751
// exit ;
94749: GO 94894
// for i := 1 to 2 do
94751: LD_ADDR_VAR 0 1
94755: PUSH
94756: DOUBLE
94757: LD_INT 1
94759: DEC
94760: ST_TO_ADDR
94761: LD_INT 2
94763: PUSH
94764: FOR_TO
94765: IFFALSE 94892
// begin uc_side := your_side ;
94767: LD_ADDR_OWVAR 20
94771: PUSH
94772: LD_OWVAR 2
94776: ST_TO_ADDR
// uc_nation := nation_american ;
94777: LD_ADDR_OWVAR 21
94781: PUSH
94782: LD_INT 1
94784: ST_TO_ADDR
// vc_chassis := us_morphling ;
94785: LD_ADDR_OWVAR 37
94789: PUSH
94790: LD_INT 5
94792: ST_TO_ADDR
// vc_engine := engine_siberite ;
94793: LD_ADDR_OWVAR 39
94797: PUSH
94798: LD_INT 3
94800: ST_TO_ADDR
// vc_control := control_computer ;
94801: LD_ADDR_OWVAR 38
94805: PUSH
94806: LD_INT 3
94808: ST_TO_ADDR
// vc_weapon := us_double_laser ;
94809: LD_ADDR_OWVAR 40
94813: PUSH
94814: LD_INT 10
94816: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
94817: LD_VAR 0 2
94821: PUSH
94822: LD_INT 1
94824: ARRAY
94825: PPUSH
94826: CALL_OW 310
94830: NOT
94831: IFFALSE 94878
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94833: CALL_OW 45
94837: PPUSH
94838: LD_VAR 0 2
94842: PUSH
94843: LD_INT 1
94845: ARRAY
94846: PPUSH
94847: CALL_OW 250
94851: PPUSH
94852: LD_VAR 0 2
94856: PUSH
94857: LD_INT 1
94859: ARRAY
94860: PPUSH
94861: CALL_OW 251
94865: PPUSH
94866: LD_INT 12
94868: PPUSH
94869: LD_INT 1
94871: PPUSH
94872: CALL_OW 50
94876: GO 94890
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94878: CALL_OW 45
94882: PPUSH
94883: LD_INT 1
94885: PPUSH
94886: CALL_OW 51
// end ;
94890: GO 94764
94892: POP
94893: POP
// end ;
94894: PPOPN 2
94896: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94897: LD_EXP 109
94901: PUSH
94902: LD_EXP 155
94906: AND
94907: IFFALSE 95129
94909: GO 94911
94911: DISABLE
94912: LD_INT 0
94914: PPUSH
94915: PPUSH
94916: PPUSH
94917: PPUSH
94918: PPUSH
94919: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94920: LD_ADDR_VAR 0 6
94924: PUSH
94925: LD_INT 22
94927: PUSH
94928: LD_OWVAR 2
94932: PUSH
94933: EMPTY
94934: LIST
94935: LIST
94936: PUSH
94937: LD_INT 21
94939: PUSH
94940: LD_INT 1
94942: PUSH
94943: EMPTY
94944: LIST
94945: LIST
94946: PUSH
94947: LD_INT 3
94949: PUSH
94950: LD_INT 23
94952: PUSH
94953: LD_INT 0
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: PUSH
94960: EMPTY
94961: LIST
94962: LIST
94963: PUSH
94964: EMPTY
94965: LIST
94966: LIST
94967: LIST
94968: PPUSH
94969: CALL_OW 69
94973: ST_TO_ADDR
// if not tmp then
94974: LD_VAR 0 6
94978: NOT
94979: IFFALSE 94983
// exit ;
94981: GO 95129
// s1 := rand ( 1 , 4 ) ;
94983: LD_ADDR_VAR 0 2
94987: PUSH
94988: LD_INT 1
94990: PPUSH
94991: LD_INT 4
94993: PPUSH
94994: CALL_OW 12
94998: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94999: LD_ADDR_VAR 0 4
95003: PUSH
95004: LD_VAR 0 6
95008: PUSH
95009: LD_INT 1
95011: ARRAY
95012: PPUSH
95013: LD_VAR 0 2
95017: PPUSH
95018: CALL_OW 259
95022: ST_TO_ADDR
// if s1 = 1 then
95023: LD_VAR 0 2
95027: PUSH
95028: LD_INT 1
95030: EQUAL
95031: IFFALSE 95051
// s2 := rand ( 2 , 4 ) else
95033: LD_ADDR_VAR 0 3
95037: PUSH
95038: LD_INT 2
95040: PPUSH
95041: LD_INT 4
95043: PPUSH
95044: CALL_OW 12
95048: ST_TO_ADDR
95049: GO 95059
// s2 := 1 ;
95051: LD_ADDR_VAR 0 3
95055: PUSH
95056: LD_INT 1
95058: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
95059: LD_ADDR_VAR 0 5
95063: PUSH
95064: LD_VAR 0 6
95068: PUSH
95069: LD_INT 1
95071: ARRAY
95072: PPUSH
95073: LD_VAR 0 3
95077: PPUSH
95078: CALL_OW 259
95082: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95083: LD_VAR 0 6
95087: PUSH
95088: LD_INT 1
95090: ARRAY
95091: PPUSH
95092: LD_VAR 0 2
95096: PPUSH
95097: LD_VAR 0 5
95101: PPUSH
95102: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95106: LD_VAR 0 6
95110: PUSH
95111: LD_INT 1
95113: ARRAY
95114: PPUSH
95115: LD_VAR 0 3
95119: PPUSH
95120: LD_VAR 0 4
95124: PPUSH
95125: CALL_OW 237
// end ;
95129: PPOPN 6
95131: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95132: LD_EXP 109
95136: PUSH
95137: LD_EXP 156
95141: AND
95142: IFFALSE 95221
95144: GO 95146
95146: DISABLE
95147: LD_INT 0
95149: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95150: LD_ADDR_VAR 0 1
95154: PUSH
95155: LD_INT 22
95157: PUSH
95158: LD_OWVAR 2
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 30
95169: PUSH
95170: LD_INT 3
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: PPUSH
95181: CALL_OW 69
95185: ST_TO_ADDR
// if not tmp then
95186: LD_VAR 0 1
95190: NOT
95191: IFFALSE 95195
// exit ;
95193: GO 95221
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95195: LD_VAR 0 1
95199: PUSH
95200: LD_INT 1
95202: PPUSH
95203: LD_VAR 0 1
95207: PPUSH
95208: CALL_OW 12
95212: ARRAY
95213: PPUSH
95214: LD_INT 1
95216: PPUSH
95217: CALL_OW 234
// end ;
95221: PPOPN 1
95223: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
95224: LD_EXP 109
95228: PUSH
95229: LD_EXP 157
95233: AND
95234: IFFALSE 95346
95236: GO 95238
95238: DISABLE
95239: LD_INT 0
95241: PPUSH
95242: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
95243: LD_ADDR_VAR 0 2
95247: PUSH
95248: LD_INT 22
95250: PUSH
95251: LD_OWVAR 2
95255: PUSH
95256: EMPTY
95257: LIST
95258: LIST
95259: PUSH
95260: LD_INT 2
95262: PUSH
95263: LD_INT 30
95265: PUSH
95266: LD_INT 27
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 30
95275: PUSH
95276: LD_INT 26
95278: PUSH
95279: EMPTY
95280: LIST
95281: LIST
95282: PUSH
95283: LD_INT 30
95285: PUSH
95286: LD_INT 28
95288: PUSH
95289: EMPTY
95290: LIST
95291: LIST
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PPUSH
95303: CALL_OW 69
95307: ST_TO_ADDR
// if not tmp then
95308: LD_VAR 0 2
95312: NOT
95313: IFFALSE 95317
// exit ;
95315: GO 95346
// for i in tmp do
95317: LD_ADDR_VAR 0 1
95321: PUSH
95322: LD_VAR 0 2
95326: PUSH
95327: FOR_IN
95328: IFFALSE 95344
// SetLives ( i , 1 ) ;
95330: LD_VAR 0 1
95334: PPUSH
95335: LD_INT 1
95337: PPUSH
95338: CALL_OW 234
95342: GO 95327
95344: POP
95345: POP
// end ;
95346: PPOPN 2
95348: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
95349: LD_EXP 109
95353: PUSH
95354: LD_EXP 158
95358: AND
95359: IFFALSE 95633
95361: GO 95363
95363: DISABLE
95364: LD_INT 0
95366: PPUSH
95367: PPUSH
95368: PPUSH
// begin i := rand ( 1 , 7 ) ;
95369: LD_ADDR_VAR 0 1
95373: PUSH
95374: LD_INT 1
95376: PPUSH
95377: LD_INT 7
95379: PPUSH
95380: CALL_OW 12
95384: ST_TO_ADDR
// case i of 1 :
95385: LD_VAR 0 1
95389: PUSH
95390: LD_INT 1
95392: DOUBLE
95393: EQUAL
95394: IFTRUE 95398
95396: GO 95408
95398: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95399: LD_STRING earthquake(getX(game), 0, 32)
95401: PPUSH
95402: CALL_OW 559
95406: GO 95633
95408: LD_INT 2
95410: DOUBLE
95411: EQUAL
95412: IFTRUE 95416
95414: GO 95430
95416: POP
// begin ToLua ( displayStucuk(); ) ;
95417: LD_STRING displayStucuk();
95419: PPUSH
95420: CALL_OW 559
// ResetFog ;
95424: CALL_OW 335
// end ; 3 :
95428: GO 95633
95430: LD_INT 3
95432: DOUBLE
95433: EQUAL
95434: IFTRUE 95438
95436: GO 95542
95438: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95439: LD_ADDR_VAR 0 2
95443: PUSH
95444: LD_INT 22
95446: PUSH
95447: LD_OWVAR 2
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PUSH
95456: LD_INT 25
95458: PUSH
95459: LD_INT 1
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PPUSH
95470: CALL_OW 69
95474: ST_TO_ADDR
// if not tmp then
95475: LD_VAR 0 2
95479: NOT
95480: IFFALSE 95484
// exit ;
95482: GO 95633
// un := tmp [ rand ( 1 , tmp ) ] ;
95484: LD_ADDR_VAR 0 3
95488: PUSH
95489: LD_VAR 0 2
95493: PUSH
95494: LD_INT 1
95496: PPUSH
95497: LD_VAR 0 2
95501: PPUSH
95502: CALL_OW 12
95506: ARRAY
95507: ST_TO_ADDR
// if Crawls ( un ) then
95508: LD_VAR 0 3
95512: PPUSH
95513: CALL_OW 318
95517: IFFALSE 95528
// ComWalk ( un ) ;
95519: LD_VAR 0 3
95523: PPUSH
95524: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95528: LD_VAR 0 3
95532: PPUSH
95533: LD_INT 8
95535: PPUSH
95536: CALL_OW 336
// end ; 4 :
95540: GO 95633
95542: LD_INT 4
95544: DOUBLE
95545: EQUAL
95546: IFTRUE 95550
95548: GO 95611
95550: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95551: LD_ADDR_VAR 0 2
95555: PUSH
95556: LD_INT 22
95558: PUSH
95559: LD_OWVAR 2
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 30
95570: PUSH
95571: LD_INT 29
95573: PUSH
95574: EMPTY
95575: LIST
95576: LIST
95577: PUSH
95578: EMPTY
95579: LIST
95580: LIST
95581: PPUSH
95582: CALL_OW 69
95586: ST_TO_ADDR
// if not tmp then
95587: LD_VAR 0 2
95591: NOT
95592: IFFALSE 95596
// exit ;
95594: GO 95633
// DestroyUnit ( tmp [ 1 ] ) ;
95596: LD_VAR 0 2
95600: PUSH
95601: LD_INT 1
95603: ARRAY
95604: PPUSH
95605: CALL_OW 65
// end ; 5 .. 7 :
95609: GO 95633
95611: LD_INT 5
95613: DOUBLE
95614: GREATEREQUAL
95615: IFFALSE 95623
95617: LD_INT 7
95619: DOUBLE
95620: LESSEQUAL
95621: IFTRUE 95625
95623: GO 95632
95625: POP
// StreamSibBomb ; end ;
95626: CALL 91883 0 0
95630: GO 95633
95632: POP
// end ;
95633: PPOPN 3
95635: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
95636: LD_EXP 109
95640: PUSH
95641: LD_EXP 159
95645: AND
95646: IFFALSE 95802
95648: GO 95650
95650: DISABLE
95651: LD_INT 0
95653: PPUSH
95654: PPUSH
95655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
95656: LD_ADDR_VAR 0 2
95660: PUSH
95661: LD_INT 81
95663: PUSH
95664: LD_OWVAR 2
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: LD_INT 2
95675: PUSH
95676: LD_INT 21
95678: PUSH
95679: LD_INT 1
95681: PUSH
95682: EMPTY
95683: LIST
95684: LIST
95685: PUSH
95686: LD_INT 21
95688: PUSH
95689: LD_INT 2
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: LIST
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PPUSH
95705: CALL_OW 69
95709: ST_TO_ADDR
// if not tmp then
95710: LD_VAR 0 2
95714: NOT
95715: IFFALSE 95719
// exit ;
95717: GO 95802
// p := 0 ;
95719: LD_ADDR_VAR 0 3
95723: PUSH
95724: LD_INT 0
95726: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95727: LD_INT 35
95729: PPUSH
95730: CALL_OW 67
// p := p + 1 ;
95734: LD_ADDR_VAR 0 3
95738: PUSH
95739: LD_VAR 0 3
95743: PUSH
95744: LD_INT 1
95746: PLUS
95747: ST_TO_ADDR
// for i in tmp do
95748: LD_ADDR_VAR 0 1
95752: PUSH
95753: LD_VAR 0 2
95757: PUSH
95758: FOR_IN
95759: IFFALSE 95790
// if GetLives ( i ) < 1000 then
95761: LD_VAR 0 1
95765: PPUSH
95766: CALL_OW 256
95770: PUSH
95771: LD_INT 1000
95773: LESS
95774: IFFALSE 95788
// SetLives ( i , 1000 ) ;
95776: LD_VAR 0 1
95780: PPUSH
95781: LD_INT 1000
95783: PPUSH
95784: CALL_OW 234
95788: GO 95758
95790: POP
95791: POP
// until p > 20 ;
95792: LD_VAR 0 3
95796: PUSH
95797: LD_INT 20
95799: GREATER
95800: IFFALSE 95727
// end ;
95802: PPOPN 3
95804: END
// every 0 0$1 trigger StreamModeActive and sTime do
95805: LD_EXP 109
95809: PUSH
95810: LD_EXP 160
95814: AND
95815: IFFALSE 95850
95817: GO 95819
95819: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
95820: LD_INT 28
95822: PPUSH
95823: LD_OWVAR 2
95827: PPUSH
95828: LD_INT 2
95830: PPUSH
95831: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95835: LD_INT 30
95837: PPUSH
95838: LD_OWVAR 2
95842: PPUSH
95843: LD_INT 2
95845: PPUSH
95846: CALL_OW 322
// end ;
95850: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95851: LD_EXP 109
95855: PUSH
95856: LD_EXP 161
95860: AND
95861: IFFALSE 95982
95863: GO 95865
95865: DISABLE
95866: LD_INT 0
95868: PPUSH
95869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95870: LD_ADDR_VAR 0 2
95874: PUSH
95875: LD_INT 22
95877: PUSH
95878: LD_OWVAR 2
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 21
95889: PUSH
95890: LD_INT 1
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 3
95899: PUSH
95900: LD_INT 23
95902: PUSH
95903: LD_INT 0
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: LIST
95918: PPUSH
95919: CALL_OW 69
95923: ST_TO_ADDR
// if not tmp then
95924: LD_VAR 0 2
95928: NOT
95929: IFFALSE 95933
// exit ;
95931: GO 95982
// for i in tmp do
95933: LD_ADDR_VAR 0 1
95937: PUSH
95938: LD_VAR 0 2
95942: PUSH
95943: FOR_IN
95944: IFFALSE 95980
// begin if Crawls ( i ) then
95946: LD_VAR 0 1
95950: PPUSH
95951: CALL_OW 318
95955: IFFALSE 95966
// ComWalk ( i ) ;
95957: LD_VAR 0 1
95961: PPUSH
95962: CALL_OW 138
// SetClass ( i , 2 ) ;
95966: LD_VAR 0 1
95970: PPUSH
95971: LD_INT 2
95973: PPUSH
95974: CALL_OW 336
// end ;
95978: GO 95943
95980: POP
95981: POP
// end ;
95982: PPOPN 2
95984: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95985: LD_EXP 109
95989: PUSH
95990: LD_EXP 162
95994: AND
95995: IFFALSE 96276
95997: GO 95999
95999: DISABLE
96000: LD_INT 0
96002: PPUSH
96003: PPUSH
96004: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
96005: LD_OWVAR 2
96009: PPUSH
96010: LD_INT 9
96012: PPUSH
96013: LD_INT 1
96015: PPUSH
96016: LD_INT 1
96018: PPUSH
96019: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
96023: LD_INT 9
96025: PPUSH
96026: LD_OWVAR 2
96030: PPUSH
96031: CALL_OW 343
// uc_side := 9 ;
96035: LD_ADDR_OWVAR 20
96039: PUSH
96040: LD_INT 9
96042: ST_TO_ADDR
// uc_nation := 2 ;
96043: LD_ADDR_OWVAR 21
96047: PUSH
96048: LD_INT 2
96050: ST_TO_ADDR
// hc_name := Dark Warrior ;
96051: LD_ADDR_OWVAR 26
96055: PUSH
96056: LD_STRING Dark Warrior
96058: ST_TO_ADDR
// hc_gallery :=  ;
96059: LD_ADDR_OWVAR 33
96063: PUSH
96064: LD_STRING 
96066: ST_TO_ADDR
// hc_noskilllimit := true ;
96067: LD_ADDR_OWVAR 76
96071: PUSH
96072: LD_INT 1
96074: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
96075: LD_ADDR_OWVAR 31
96079: PUSH
96080: LD_INT 30
96082: PUSH
96083: LD_INT 30
96085: PUSH
96086: LD_INT 30
96088: PUSH
96089: LD_INT 30
96091: PUSH
96092: EMPTY
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: ST_TO_ADDR
// un := CreateHuman ;
96098: LD_ADDR_VAR 0 3
96102: PUSH
96103: CALL_OW 44
96107: ST_TO_ADDR
// hc_noskilllimit := false ;
96108: LD_ADDR_OWVAR 76
96112: PUSH
96113: LD_INT 0
96115: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96116: LD_VAR 0 3
96120: PPUSH
96121: LD_INT 1
96123: PPUSH
96124: CALL_OW 51
// p := 0 ;
96128: LD_ADDR_VAR 0 2
96132: PUSH
96133: LD_INT 0
96135: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96136: LD_INT 35
96138: PPUSH
96139: CALL_OW 67
// p := p + 1 ;
96143: LD_ADDR_VAR 0 2
96147: PUSH
96148: LD_VAR 0 2
96152: PUSH
96153: LD_INT 1
96155: PLUS
96156: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96157: LD_VAR 0 3
96161: PPUSH
96162: CALL_OW 256
96166: PUSH
96167: LD_INT 1000
96169: LESS
96170: IFFALSE 96184
// SetLives ( un , 1000 ) ;
96172: LD_VAR 0 3
96176: PPUSH
96177: LD_INT 1000
96179: PPUSH
96180: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
96184: LD_VAR 0 3
96188: PPUSH
96189: LD_INT 81
96191: PUSH
96192: LD_OWVAR 2
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: LD_INT 91
96203: PUSH
96204: LD_VAR 0 3
96208: PUSH
96209: LD_INT 30
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: LIST
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PPUSH
96221: CALL_OW 69
96225: PPUSH
96226: LD_VAR 0 3
96230: PPUSH
96231: CALL_OW 74
96235: PPUSH
96236: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
96240: LD_VAR 0 2
96244: PUSH
96245: LD_INT 60
96247: GREATER
96248: PUSH
96249: LD_VAR 0 3
96253: PPUSH
96254: CALL_OW 301
96258: OR
96259: IFFALSE 96136
// if un then
96261: LD_VAR 0 3
96265: IFFALSE 96276
// RemoveUnit ( un ) ;
96267: LD_VAR 0 3
96271: PPUSH
96272: CALL_OW 64
// end ;
96276: PPOPN 3
96278: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96279: LD_INT 0
96281: PPUSH
// case cmd of 301 :
96282: LD_VAR 0 1
96286: PUSH
96287: LD_INT 301
96289: DOUBLE
96290: EQUAL
96291: IFTRUE 96295
96293: GO 96327
96295: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96296: LD_VAR 0 6
96300: PPUSH
96301: LD_VAR 0 7
96305: PPUSH
96306: LD_VAR 0 8
96310: PPUSH
96311: LD_VAR 0 4
96315: PPUSH
96316: LD_VAR 0 5
96320: PPUSH
96321: CALL 97528 0 5
96325: GO 96448
96327: LD_INT 302
96329: DOUBLE
96330: EQUAL
96331: IFTRUE 96335
96333: GO 96372
96335: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
96336: LD_VAR 0 6
96340: PPUSH
96341: LD_VAR 0 7
96345: PPUSH
96346: LD_VAR 0 8
96350: PPUSH
96351: LD_VAR 0 9
96355: PPUSH
96356: LD_VAR 0 4
96360: PPUSH
96361: LD_VAR 0 5
96365: PPUSH
96366: CALL 97619 0 6
96370: GO 96448
96372: LD_INT 303
96374: DOUBLE
96375: EQUAL
96376: IFTRUE 96380
96378: GO 96417
96380: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
96381: LD_VAR 0 6
96385: PPUSH
96386: LD_VAR 0 7
96390: PPUSH
96391: LD_VAR 0 8
96395: PPUSH
96396: LD_VAR 0 9
96400: PPUSH
96401: LD_VAR 0 4
96405: PPUSH
96406: LD_VAR 0 5
96410: PPUSH
96411: CALL 96453 0 6
96415: GO 96448
96417: LD_INT 304
96419: DOUBLE
96420: EQUAL
96421: IFTRUE 96425
96423: GO 96447
96425: POP
// hHackTeleport ( unit , x , y ) ; end ;
96426: LD_VAR 0 2
96430: PPUSH
96431: LD_VAR 0 4
96435: PPUSH
96436: LD_VAR 0 5
96440: PPUSH
96441: CALL 98212 0 3
96445: GO 96448
96447: POP
// end ;
96448: LD_VAR 0 12
96452: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
96453: LD_INT 0
96455: PPUSH
96456: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
96457: LD_VAR 0 1
96461: PUSH
96462: LD_INT 1
96464: LESS
96465: PUSH
96466: LD_VAR 0 1
96470: PUSH
96471: LD_INT 3
96473: GREATER
96474: OR
96475: PUSH
96476: LD_VAR 0 5
96480: PPUSH
96481: LD_VAR 0 6
96485: PPUSH
96486: CALL_OW 428
96490: OR
96491: IFFALSE 96495
// exit ;
96493: GO 97215
// uc_side := your_side ;
96495: LD_ADDR_OWVAR 20
96499: PUSH
96500: LD_OWVAR 2
96504: ST_TO_ADDR
// uc_nation := nation ;
96505: LD_ADDR_OWVAR 21
96509: PUSH
96510: LD_VAR 0 1
96514: ST_TO_ADDR
// bc_level = 1 ;
96515: LD_ADDR_OWVAR 43
96519: PUSH
96520: LD_INT 1
96522: ST_TO_ADDR
// case btype of 1 :
96523: LD_VAR 0 2
96527: PUSH
96528: LD_INT 1
96530: DOUBLE
96531: EQUAL
96532: IFTRUE 96536
96534: GO 96547
96536: POP
// bc_type := b_depot ; 2 :
96537: LD_ADDR_OWVAR 42
96541: PUSH
96542: LD_INT 0
96544: ST_TO_ADDR
96545: GO 97159
96547: LD_INT 2
96549: DOUBLE
96550: EQUAL
96551: IFTRUE 96555
96553: GO 96566
96555: POP
// bc_type := b_warehouse ; 3 :
96556: LD_ADDR_OWVAR 42
96560: PUSH
96561: LD_INT 1
96563: ST_TO_ADDR
96564: GO 97159
96566: LD_INT 3
96568: DOUBLE
96569: EQUAL
96570: IFTRUE 96574
96572: GO 96585
96574: POP
// bc_type := b_lab ; 4 .. 9 :
96575: LD_ADDR_OWVAR 42
96579: PUSH
96580: LD_INT 6
96582: ST_TO_ADDR
96583: GO 97159
96585: LD_INT 4
96587: DOUBLE
96588: GREATEREQUAL
96589: IFFALSE 96597
96591: LD_INT 9
96593: DOUBLE
96594: LESSEQUAL
96595: IFTRUE 96599
96597: GO 96651
96599: POP
// begin bc_type := b_lab_half ;
96600: LD_ADDR_OWVAR 42
96604: PUSH
96605: LD_INT 7
96607: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
96608: LD_ADDR_OWVAR 44
96612: PUSH
96613: LD_INT 10
96615: PUSH
96616: LD_INT 11
96618: PUSH
96619: LD_INT 12
96621: PUSH
96622: LD_INT 15
96624: PUSH
96625: LD_INT 14
96627: PUSH
96628: LD_INT 13
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: PUSH
96639: LD_VAR 0 2
96643: PUSH
96644: LD_INT 3
96646: MINUS
96647: ARRAY
96648: ST_TO_ADDR
// end ; 10 .. 13 :
96649: GO 97159
96651: LD_INT 10
96653: DOUBLE
96654: GREATEREQUAL
96655: IFFALSE 96663
96657: LD_INT 13
96659: DOUBLE
96660: LESSEQUAL
96661: IFTRUE 96665
96663: GO 96742
96665: POP
// begin bc_type := b_lab_full ;
96666: LD_ADDR_OWVAR 42
96670: PUSH
96671: LD_INT 8
96673: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
96674: LD_ADDR_OWVAR 44
96678: PUSH
96679: LD_INT 10
96681: PUSH
96682: LD_INT 12
96684: PUSH
96685: LD_INT 14
96687: PUSH
96688: LD_INT 13
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: PUSH
96697: LD_VAR 0 2
96701: PUSH
96702: LD_INT 9
96704: MINUS
96705: ARRAY
96706: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
96707: LD_ADDR_OWVAR 45
96711: PUSH
96712: LD_INT 11
96714: PUSH
96715: LD_INT 15
96717: PUSH
96718: LD_INT 12
96720: PUSH
96721: LD_INT 15
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: PUSH
96730: LD_VAR 0 2
96734: PUSH
96735: LD_INT 9
96737: MINUS
96738: ARRAY
96739: ST_TO_ADDR
// end ; 14 :
96740: GO 97159
96742: LD_INT 14
96744: DOUBLE
96745: EQUAL
96746: IFTRUE 96750
96748: GO 96761
96750: POP
// bc_type := b_workshop ; 15 :
96751: LD_ADDR_OWVAR 42
96755: PUSH
96756: LD_INT 2
96758: ST_TO_ADDR
96759: GO 97159
96761: LD_INT 15
96763: DOUBLE
96764: EQUAL
96765: IFTRUE 96769
96767: GO 96780
96769: POP
// bc_type := b_factory ; 16 :
96770: LD_ADDR_OWVAR 42
96774: PUSH
96775: LD_INT 3
96777: ST_TO_ADDR
96778: GO 97159
96780: LD_INT 16
96782: DOUBLE
96783: EQUAL
96784: IFTRUE 96788
96786: GO 96799
96788: POP
// bc_type := b_ext_gun ; 17 :
96789: LD_ADDR_OWVAR 42
96793: PUSH
96794: LD_INT 17
96796: ST_TO_ADDR
96797: GO 97159
96799: LD_INT 17
96801: DOUBLE
96802: EQUAL
96803: IFTRUE 96807
96805: GO 96835
96807: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
96808: LD_ADDR_OWVAR 42
96812: PUSH
96813: LD_INT 19
96815: PUSH
96816: LD_INT 23
96818: PUSH
96819: LD_INT 19
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: LIST
96826: PUSH
96827: LD_VAR 0 1
96831: ARRAY
96832: ST_TO_ADDR
96833: GO 97159
96835: LD_INT 18
96837: DOUBLE
96838: EQUAL
96839: IFTRUE 96843
96841: GO 96854
96843: POP
// bc_type := b_ext_radar ; 19 :
96844: LD_ADDR_OWVAR 42
96848: PUSH
96849: LD_INT 20
96851: ST_TO_ADDR
96852: GO 97159
96854: LD_INT 19
96856: DOUBLE
96857: EQUAL
96858: IFTRUE 96862
96860: GO 96873
96862: POP
// bc_type := b_ext_radio ; 20 :
96863: LD_ADDR_OWVAR 42
96867: PUSH
96868: LD_INT 22
96870: ST_TO_ADDR
96871: GO 97159
96873: LD_INT 20
96875: DOUBLE
96876: EQUAL
96877: IFTRUE 96881
96879: GO 96892
96881: POP
// bc_type := b_ext_siberium ; 21 :
96882: LD_ADDR_OWVAR 42
96886: PUSH
96887: LD_INT 21
96889: ST_TO_ADDR
96890: GO 97159
96892: LD_INT 21
96894: DOUBLE
96895: EQUAL
96896: IFTRUE 96900
96898: GO 96911
96900: POP
// bc_type := b_ext_computer ; 22 :
96901: LD_ADDR_OWVAR 42
96905: PUSH
96906: LD_INT 24
96908: ST_TO_ADDR
96909: GO 97159
96911: LD_INT 22
96913: DOUBLE
96914: EQUAL
96915: IFTRUE 96919
96917: GO 96930
96919: POP
// bc_type := b_ext_track ; 23 :
96920: LD_ADDR_OWVAR 42
96924: PUSH
96925: LD_INT 16
96927: ST_TO_ADDR
96928: GO 97159
96930: LD_INT 23
96932: DOUBLE
96933: EQUAL
96934: IFTRUE 96938
96936: GO 96949
96938: POP
// bc_type := b_ext_laser ; 24 :
96939: LD_ADDR_OWVAR 42
96943: PUSH
96944: LD_INT 25
96946: ST_TO_ADDR
96947: GO 97159
96949: LD_INT 24
96951: DOUBLE
96952: EQUAL
96953: IFTRUE 96957
96955: GO 96968
96957: POP
// bc_type := b_control_tower ; 25 :
96958: LD_ADDR_OWVAR 42
96962: PUSH
96963: LD_INT 36
96965: ST_TO_ADDR
96966: GO 97159
96968: LD_INT 25
96970: DOUBLE
96971: EQUAL
96972: IFTRUE 96976
96974: GO 96987
96976: POP
// bc_type := b_breastwork ; 26 :
96977: LD_ADDR_OWVAR 42
96981: PUSH
96982: LD_INT 31
96984: ST_TO_ADDR
96985: GO 97159
96987: LD_INT 26
96989: DOUBLE
96990: EQUAL
96991: IFTRUE 96995
96993: GO 97006
96995: POP
// bc_type := b_bunker ; 27 :
96996: LD_ADDR_OWVAR 42
97000: PUSH
97001: LD_INT 32
97003: ST_TO_ADDR
97004: GO 97159
97006: LD_INT 27
97008: DOUBLE
97009: EQUAL
97010: IFTRUE 97014
97012: GO 97025
97014: POP
// bc_type := b_turret ; 28 :
97015: LD_ADDR_OWVAR 42
97019: PUSH
97020: LD_INT 33
97022: ST_TO_ADDR
97023: GO 97159
97025: LD_INT 28
97027: DOUBLE
97028: EQUAL
97029: IFTRUE 97033
97031: GO 97044
97033: POP
// bc_type := b_armoury ; 29 :
97034: LD_ADDR_OWVAR 42
97038: PUSH
97039: LD_INT 4
97041: ST_TO_ADDR
97042: GO 97159
97044: LD_INT 29
97046: DOUBLE
97047: EQUAL
97048: IFTRUE 97052
97050: GO 97063
97052: POP
// bc_type := b_barracks ; 30 :
97053: LD_ADDR_OWVAR 42
97057: PUSH
97058: LD_INT 5
97060: ST_TO_ADDR
97061: GO 97159
97063: LD_INT 30
97065: DOUBLE
97066: EQUAL
97067: IFTRUE 97071
97069: GO 97082
97071: POP
// bc_type := b_solar_power ; 31 :
97072: LD_ADDR_OWVAR 42
97076: PUSH
97077: LD_INT 27
97079: ST_TO_ADDR
97080: GO 97159
97082: LD_INT 31
97084: DOUBLE
97085: EQUAL
97086: IFTRUE 97090
97088: GO 97101
97090: POP
// bc_type := b_oil_power ; 32 :
97091: LD_ADDR_OWVAR 42
97095: PUSH
97096: LD_INT 26
97098: ST_TO_ADDR
97099: GO 97159
97101: LD_INT 32
97103: DOUBLE
97104: EQUAL
97105: IFTRUE 97109
97107: GO 97120
97109: POP
// bc_type := b_siberite_power ; 33 :
97110: LD_ADDR_OWVAR 42
97114: PUSH
97115: LD_INT 28
97117: ST_TO_ADDR
97118: GO 97159
97120: LD_INT 33
97122: DOUBLE
97123: EQUAL
97124: IFTRUE 97128
97126: GO 97139
97128: POP
// bc_type := b_oil_mine ; 34 :
97129: LD_ADDR_OWVAR 42
97133: PUSH
97134: LD_INT 29
97136: ST_TO_ADDR
97137: GO 97159
97139: LD_INT 34
97141: DOUBLE
97142: EQUAL
97143: IFTRUE 97147
97145: GO 97158
97147: POP
// bc_type := b_siberite_mine ; end ;
97148: LD_ADDR_OWVAR 42
97152: PUSH
97153: LD_INT 30
97155: ST_TO_ADDR
97156: GO 97159
97158: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97159: LD_ADDR_VAR 0 8
97163: PUSH
97164: LD_VAR 0 5
97168: PPUSH
97169: LD_VAR 0 6
97173: PPUSH
97174: LD_VAR 0 3
97178: PPUSH
97179: CALL_OW 47
97183: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97184: LD_OWVAR 42
97188: PUSH
97189: LD_INT 32
97191: PUSH
97192: LD_INT 33
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: IN
97199: IFFALSE 97215
// PlaceWeaponTurret ( b , weapon ) ;
97201: LD_VAR 0 8
97205: PPUSH
97206: LD_VAR 0 4
97210: PPUSH
97211: CALL_OW 431
// end ;
97215: LD_VAR 0 7
97219: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97220: LD_INT 0
97222: PPUSH
97223: PPUSH
97224: PPUSH
97225: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97226: LD_ADDR_VAR 0 4
97230: PUSH
97231: LD_INT 22
97233: PUSH
97234: LD_OWVAR 2
97238: PUSH
97239: EMPTY
97240: LIST
97241: LIST
97242: PUSH
97243: LD_INT 2
97245: PUSH
97246: LD_INT 30
97248: PUSH
97249: LD_INT 0
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: LD_INT 30
97258: PUSH
97259: LD_INT 1
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: EMPTY
97267: LIST
97268: LIST
97269: LIST
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PPUSH
97275: CALL_OW 69
97279: ST_TO_ADDR
// if not tmp then
97280: LD_VAR 0 4
97284: NOT
97285: IFFALSE 97289
// exit ;
97287: GO 97348
// for i in tmp do
97289: LD_ADDR_VAR 0 2
97293: PUSH
97294: LD_VAR 0 4
97298: PUSH
97299: FOR_IN
97300: IFFALSE 97346
// for j = 1 to 3 do
97302: LD_ADDR_VAR 0 3
97306: PUSH
97307: DOUBLE
97308: LD_INT 1
97310: DEC
97311: ST_TO_ADDR
97312: LD_INT 3
97314: PUSH
97315: FOR_TO
97316: IFFALSE 97342
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
97318: LD_VAR 0 2
97322: PPUSH
97323: CALL_OW 274
97327: PPUSH
97328: LD_VAR 0 3
97332: PPUSH
97333: LD_INT 99999
97335: PPUSH
97336: CALL_OW 277
97340: GO 97315
97342: POP
97343: POP
97344: GO 97299
97346: POP
97347: POP
// end ;
97348: LD_VAR 0 1
97352: RET
// export function hHackSetLevel10 ; var i , j ; begin
97353: LD_INT 0
97355: PPUSH
97356: PPUSH
97357: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97358: LD_ADDR_VAR 0 2
97362: PUSH
97363: LD_INT 21
97365: PUSH
97366: LD_INT 1
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PPUSH
97373: CALL_OW 69
97377: PUSH
97378: FOR_IN
97379: IFFALSE 97431
// if IsSelected ( i ) then
97381: LD_VAR 0 2
97385: PPUSH
97386: CALL_OW 306
97390: IFFALSE 97429
// begin for j := 1 to 4 do
97392: LD_ADDR_VAR 0 3
97396: PUSH
97397: DOUBLE
97398: LD_INT 1
97400: DEC
97401: ST_TO_ADDR
97402: LD_INT 4
97404: PUSH
97405: FOR_TO
97406: IFFALSE 97427
// SetSkill ( i , j , 10 ) ;
97408: LD_VAR 0 2
97412: PPUSH
97413: LD_VAR 0 3
97417: PPUSH
97418: LD_INT 10
97420: PPUSH
97421: CALL_OW 237
97425: GO 97405
97427: POP
97428: POP
// end ;
97429: GO 97378
97431: POP
97432: POP
// end ;
97433: LD_VAR 0 1
97437: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
97438: LD_INT 0
97440: PPUSH
97441: PPUSH
97442: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
97443: LD_ADDR_VAR 0 2
97447: PUSH
97448: LD_INT 22
97450: PUSH
97451: LD_OWVAR 2
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: LD_INT 21
97462: PUSH
97463: LD_INT 1
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: EMPTY
97471: LIST
97472: LIST
97473: PPUSH
97474: CALL_OW 69
97478: PUSH
97479: FOR_IN
97480: IFFALSE 97521
// begin for j := 1 to 4 do
97482: LD_ADDR_VAR 0 3
97486: PUSH
97487: DOUBLE
97488: LD_INT 1
97490: DEC
97491: ST_TO_ADDR
97492: LD_INT 4
97494: PUSH
97495: FOR_TO
97496: IFFALSE 97517
// SetSkill ( i , j , 10 ) ;
97498: LD_VAR 0 2
97502: PPUSH
97503: LD_VAR 0 3
97507: PPUSH
97508: LD_INT 10
97510: PPUSH
97511: CALL_OW 237
97515: GO 97495
97517: POP
97518: POP
// end ;
97519: GO 97479
97521: POP
97522: POP
// end ;
97523: LD_VAR 0 1
97527: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
97528: LD_INT 0
97530: PPUSH
// uc_side := your_side ;
97531: LD_ADDR_OWVAR 20
97535: PUSH
97536: LD_OWVAR 2
97540: ST_TO_ADDR
// uc_nation := nation ;
97541: LD_ADDR_OWVAR 21
97545: PUSH
97546: LD_VAR 0 1
97550: ST_TO_ADDR
// InitHc ;
97551: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
97555: LD_INT 0
97557: PPUSH
97558: LD_VAR 0 2
97562: PPUSH
97563: LD_VAR 0 3
97567: PPUSH
97568: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
97572: LD_VAR 0 4
97576: PPUSH
97577: LD_VAR 0 5
97581: PPUSH
97582: CALL_OW 428
97586: PUSH
97587: LD_INT 0
97589: EQUAL
97590: IFFALSE 97614
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
97592: CALL_OW 44
97596: PPUSH
97597: LD_VAR 0 4
97601: PPUSH
97602: LD_VAR 0 5
97606: PPUSH
97607: LD_INT 1
97609: PPUSH
97610: CALL_OW 48
// end ;
97614: LD_VAR 0 6
97618: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
97619: LD_INT 0
97621: PPUSH
97622: PPUSH
// uc_side := your_side ;
97623: LD_ADDR_OWVAR 20
97627: PUSH
97628: LD_OWVAR 2
97632: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
97633: LD_VAR 0 1
97637: PUSH
97638: LD_INT 1
97640: PUSH
97641: LD_INT 2
97643: PUSH
97644: LD_INT 3
97646: PUSH
97647: LD_INT 4
97649: PUSH
97650: LD_INT 5
97652: PUSH
97653: EMPTY
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: IN
97660: IFFALSE 97672
// uc_nation := nation_american else
97662: LD_ADDR_OWVAR 21
97666: PUSH
97667: LD_INT 1
97669: ST_TO_ADDR
97670: GO 97715
// if chassis in [ 11 , 12 , 13 , 14 ] then
97672: LD_VAR 0 1
97676: PUSH
97677: LD_INT 11
97679: PUSH
97680: LD_INT 12
97682: PUSH
97683: LD_INT 13
97685: PUSH
97686: LD_INT 14
97688: PUSH
97689: EMPTY
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: IN
97695: IFFALSE 97707
// uc_nation := nation_arabian else
97697: LD_ADDR_OWVAR 21
97701: PUSH
97702: LD_INT 2
97704: ST_TO_ADDR
97705: GO 97715
// uc_nation := nation_russian ;
97707: LD_ADDR_OWVAR 21
97711: PUSH
97712: LD_INT 3
97714: ST_TO_ADDR
// vc_chassis := chassis ;
97715: LD_ADDR_OWVAR 37
97719: PUSH
97720: LD_VAR 0 1
97724: ST_TO_ADDR
// vc_engine := engine ;
97725: LD_ADDR_OWVAR 39
97729: PUSH
97730: LD_VAR 0 2
97734: ST_TO_ADDR
// vc_control := control ;
97735: LD_ADDR_OWVAR 38
97739: PUSH
97740: LD_VAR 0 3
97744: ST_TO_ADDR
// vc_weapon := weapon ;
97745: LD_ADDR_OWVAR 40
97749: PUSH
97750: LD_VAR 0 4
97754: ST_TO_ADDR
// un := CreateVehicle ;
97755: LD_ADDR_VAR 0 8
97759: PUSH
97760: CALL_OW 45
97764: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
97765: LD_VAR 0 8
97769: PPUSH
97770: LD_INT 0
97772: PPUSH
97773: LD_INT 5
97775: PPUSH
97776: CALL_OW 12
97780: PPUSH
97781: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
97785: LD_VAR 0 8
97789: PPUSH
97790: LD_VAR 0 5
97794: PPUSH
97795: LD_VAR 0 6
97799: PPUSH
97800: LD_INT 1
97802: PPUSH
97803: CALL_OW 48
// end ;
97807: LD_VAR 0 7
97811: RET
// export hInvincible ; every 1 do
97812: GO 97814
97814: DISABLE
// hInvincible := [ ] ;
97815: LD_ADDR_EXP 163
97819: PUSH
97820: EMPTY
97821: ST_TO_ADDR
97822: END
// every 10 do var i ;
97823: GO 97825
97825: DISABLE
97826: LD_INT 0
97828: PPUSH
// begin enable ;
97829: ENABLE
// if not hInvincible then
97830: LD_EXP 163
97834: NOT
97835: IFFALSE 97839
// exit ;
97837: GO 97883
// for i in hInvincible do
97839: LD_ADDR_VAR 0 1
97843: PUSH
97844: LD_EXP 163
97848: PUSH
97849: FOR_IN
97850: IFFALSE 97881
// if GetLives ( i ) < 1000 then
97852: LD_VAR 0 1
97856: PPUSH
97857: CALL_OW 256
97861: PUSH
97862: LD_INT 1000
97864: LESS
97865: IFFALSE 97879
// SetLives ( i , 1000 ) ;
97867: LD_VAR 0 1
97871: PPUSH
97872: LD_INT 1000
97874: PPUSH
97875: CALL_OW 234
97879: GO 97849
97881: POP
97882: POP
// end ;
97883: PPOPN 1
97885: END
// export function hHackInvincible ; var i ; begin
97886: LD_INT 0
97888: PPUSH
97889: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97890: LD_ADDR_VAR 0 2
97894: PUSH
97895: LD_INT 2
97897: PUSH
97898: LD_INT 21
97900: PUSH
97901: LD_INT 1
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PUSH
97908: LD_INT 21
97910: PUSH
97911: LD_INT 2
97913: PUSH
97914: EMPTY
97915: LIST
97916: LIST
97917: PUSH
97918: EMPTY
97919: LIST
97920: LIST
97921: LIST
97922: PPUSH
97923: CALL_OW 69
97927: PUSH
97928: FOR_IN
97929: IFFALSE 97990
// if IsSelected ( i ) then
97931: LD_VAR 0 2
97935: PPUSH
97936: CALL_OW 306
97940: IFFALSE 97988
// begin if i in hInvincible then
97942: LD_VAR 0 2
97946: PUSH
97947: LD_EXP 163
97951: IN
97952: IFFALSE 97972
// hInvincible := hInvincible diff i else
97954: LD_ADDR_EXP 163
97958: PUSH
97959: LD_EXP 163
97963: PUSH
97964: LD_VAR 0 2
97968: DIFF
97969: ST_TO_ADDR
97970: GO 97988
// hInvincible := hInvincible union i ;
97972: LD_ADDR_EXP 163
97976: PUSH
97977: LD_EXP 163
97981: PUSH
97982: LD_VAR 0 2
97986: UNION
97987: ST_TO_ADDR
// end ;
97988: GO 97928
97990: POP
97991: POP
// end ;
97992: LD_VAR 0 1
97996: RET
// export function hHackInvisible ; var i , j ; begin
97997: LD_INT 0
97999: PPUSH
98000: PPUSH
98001: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98002: LD_ADDR_VAR 0 2
98006: PUSH
98007: LD_INT 21
98009: PUSH
98010: LD_INT 1
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PPUSH
98017: CALL_OW 69
98021: PUSH
98022: FOR_IN
98023: IFFALSE 98047
// if IsSelected ( i ) then
98025: LD_VAR 0 2
98029: PPUSH
98030: CALL_OW 306
98034: IFFALSE 98045
// ComForceInvisible ( i ) ;
98036: LD_VAR 0 2
98040: PPUSH
98041: CALL_OW 496
98045: GO 98022
98047: POP
98048: POP
// end ;
98049: LD_VAR 0 1
98053: RET
// export function hHackChangeYourSide ; begin
98054: LD_INT 0
98056: PPUSH
// if your_side = 8 then
98057: LD_OWVAR 2
98061: PUSH
98062: LD_INT 8
98064: EQUAL
98065: IFFALSE 98077
// your_side := 0 else
98067: LD_ADDR_OWVAR 2
98071: PUSH
98072: LD_INT 0
98074: ST_TO_ADDR
98075: GO 98091
// your_side := your_side + 1 ;
98077: LD_ADDR_OWVAR 2
98081: PUSH
98082: LD_OWVAR 2
98086: PUSH
98087: LD_INT 1
98089: PLUS
98090: ST_TO_ADDR
// end ;
98091: LD_VAR 0 1
98095: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98096: LD_INT 0
98098: PPUSH
98099: PPUSH
98100: PPUSH
// for i in all_units do
98101: LD_ADDR_VAR 0 2
98105: PUSH
98106: LD_OWVAR 3
98110: PUSH
98111: FOR_IN
98112: IFFALSE 98190
// if IsSelected ( i ) then
98114: LD_VAR 0 2
98118: PPUSH
98119: CALL_OW 306
98123: IFFALSE 98188
// begin j := GetSide ( i ) ;
98125: LD_ADDR_VAR 0 3
98129: PUSH
98130: LD_VAR 0 2
98134: PPUSH
98135: CALL_OW 255
98139: ST_TO_ADDR
// if j = 8 then
98140: LD_VAR 0 3
98144: PUSH
98145: LD_INT 8
98147: EQUAL
98148: IFFALSE 98160
// j := 0 else
98150: LD_ADDR_VAR 0 3
98154: PUSH
98155: LD_INT 0
98157: ST_TO_ADDR
98158: GO 98174
// j := j + 1 ;
98160: LD_ADDR_VAR 0 3
98164: PUSH
98165: LD_VAR 0 3
98169: PUSH
98170: LD_INT 1
98172: PLUS
98173: ST_TO_ADDR
// SetSide ( i , j ) ;
98174: LD_VAR 0 2
98178: PPUSH
98179: LD_VAR 0 3
98183: PPUSH
98184: CALL_OW 235
// end ;
98188: GO 98111
98190: POP
98191: POP
// end ;
98192: LD_VAR 0 1
98196: RET
// export function hHackFog ; begin
98197: LD_INT 0
98199: PPUSH
// FogOff ( true ) ;
98200: LD_INT 1
98202: PPUSH
98203: CALL_OW 344
// end ;
98207: LD_VAR 0 1
98211: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98212: LD_INT 0
98214: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98215: LD_VAR 0 1
98219: PPUSH
98220: LD_VAR 0 2
98224: PPUSH
98225: LD_VAR 0 3
98229: PPUSH
98230: LD_INT 1
98232: PPUSH
98233: LD_INT 1
98235: PPUSH
98236: CALL_OW 483
// CenterOnXY ( x , y ) ;
98240: LD_VAR 0 2
98244: PPUSH
98245: LD_VAR 0 3
98249: PPUSH
98250: CALL_OW 84
// end ; end_of_file
98254: LD_VAR 0 4
98258: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98259: LD_INT 0
98261: PPUSH
98262: PPUSH
98263: PPUSH
98264: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98265: LD_VAR 0 1
98269: PPUSH
98270: CALL_OW 264
98274: PUSH
98275: LD_EXP 97
98279: EQUAL
98280: IFFALSE 98352
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98282: LD_INT 68
98284: PPUSH
98285: LD_VAR 0 1
98289: PPUSH
98290: CALL_OW 255
98294: PPUSH
98295: CALL_OW 321
98299: PUSH
98300: LD_INT 2
98302: EQUAL
98303: IFFALSE 98315
// eff := 70 else
98305: LD_ADDR_VAR 0 4
98309: PUSH
98310: LD_INT 70
98312: ST_TO_ADDR
98313: GO 98323
// eff := 30 ;
98315: LD_ADDR_VAR 0 4
98319: PUSH
98320: LD_INT 30
98322: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98323: LD_VAR 0 1
98327: PPUSH
98328: CALL_OW 250
98332: PPUSH
98333: LD_VAR 0 1
98337: PPUSH
98338: CALL_OW 251
98342: PPUSH
98343: LD_VAR 0 4
98347: PPUSH
98348: CALL_OW 495
// end ; end ;
98352: LD_VAR 0 2
98356: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98357: LD_INT 0
98359: PPUSH
// end ;
98360: LD_VAR 0 4
98364: RET
// export function SOS_Command ( cmd ) ; begin
98365: LD_INT 0
98367: PPUSH
// end ;
98368: LD_VAR 0 2
98372: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
98373: LD_INT 0
98375: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
98376: LD_VAR 0 1
98380: PUSH
98381: LD_INT 250
98383: EQUAL
98384: PUSH
98385: LD_VAR 0 2
98389: PPUSH
98390: CALL_OW 264
98394: PUSH
98395: LD_EXP 100
98399: EQUAL
98400: AND
98401: IFFALSE 98422
// MinerPlaceMine ( unit , x , y ) ;
98403: LD_VAR 0 2
98407: PPUSH
98408: LD_VAR 0 4
98412: PPUSH
98413: LD_VAR 0 5
98417: PPUSH
98418: CALL 100763 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
98422: LD_VAR 0 1
98426: PUSH
98427: LD_INT 251
98429: EQUAL
98430: PUSH
98431: LD_VAR 0 2
98435: PPUSH
98436: CALL_OW 264
98440: PUSH
98441: LD_EXP 100
98445: EQUAL
98446: AND
98447: IFFALSE 98468
// MinerDetonateMine ( unit , x , y ) ;
98449: LD_VAR 0 2
98453: PPUSH
98454: LD_VAR 0 4
98458: PPUSH
98459: LD_VAR 0 5
98463: PPUSH
98464: CALL 101040 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
98468: LD_VAR 0 1
98472: PUSH
98473: LD_INT 252
98475: EQUAL
98476: PUSH
98477: LD_VAR 0 2
98481: PPUSH
98482: CALL_OW 264
98486: PUSH
98487: LD_EXP 100
98491: EQUAL
98492: AND
98493: IFFALSE 98514
// MinerCreateMinefield ( unit , x , y ) ;
98495: LD_VAR 0 2
98499: PPUSH
98500: LD_VAR 0 4
98504: PPUSH
98505: LD_VAR 0 5
98509: PPUSH
98510: CALL 101457 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
98514: LD_VAR 0 1
98518: PUSH
98519: LD_INT 253
98521: EQUAL
98522: PUSH
98523: LD_VAR 0 2
98527: PPUSH
98528: CALL_OW 257
98532: PUSH
98533: LD_INT 5
98535: EQUAL
98536: AND
98537: IFFALSE 98558
// ComBinocular ( unit , x , y ) ;
98539: LD_VAR 0 2
98543: PPUSH
98544: LD_VAR 0 4
98548: PPUSH
98549: LD_VAR 0 5
98553: PPUSH
98554: CALL 101828 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
98558: LD_VAR 0 1
98562: PUSH
98563: LD_INT 254
98565: EQUAL
98566: PUSH
98567: LD_VAR 0 2
98571: PPUSH
98572: CALL_OW 264
98576: PUSH
98577: LD_EXP 95
98581: EQUAL
98582: AND
98583: PUSH
98584: LD_VAR 0 3
98588: PPUSH
98589: CALL_OW 263
98593: PUSH
98594: LD_INT 3
98596: EQUAL
98597: AND
98598: IFFALSE 98614
// HackDestroyVehicle ( unit , selectedUnit ) ;
98600: LD_VAR 0 2
98604: PPUSH
98605: LD_VAR 0 3
98609: PPUSH
98610: CALL 100123 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98614: LD_VAR 0 1
98618: PUSH
98619: LD_INT 255
98621: EQUAL
98622: PUSH
98623: LD_VAR 0 2
98627: PPUSH
98628: CALL_OW 264
98632: PUSH
98633: LD_INT 14
98635: PUSH
98636: LD_INT 53
98638: PUSH
98639: EMPTY
98640: LIST
98641: LIST
98642: IN
98643: AND
98644: PUSH
98645: LD_VAR 0 4
98649: PPUSH
98650: LD_VAR 0 5
98654: PPUSH
98655: CALL_OW 488
98659: AND
98660: IFFALSE 98684
// CutTreeXYR ( unit , x , y , 12 ) ;
98662: LD_VAR 0 2
98666: PPUSH
98667: LD_VAR 0 4
98671: PPUSH
98672: LD_VAR 0 5
98676: PPUSH
98677: LD_INT 12
98679: PPUSH
98680: CALL 98689 0 4
// end ;
98684: LD_VAR 0 6
98688: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98689: LD_INT 0
98691: PPUSH
98692: PPUSH
98693: PPUSH
98694: PPUSH
98695: PPUSH
98696: PPUSH
98697: PPUSH
98698: PPUSH
98699: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98700: LD_VAR 0 1
98704: NOT
98705: PUSH
98706: LD_VAR 0 2
98710: PPUSH
98711: LD_VAR 0 3
98715: PPUSH
98716: CALL_OW 488
98720: NOT
98721: OR
98722: PUSH
98723: LD_VAR 0 4
98727: NOT
98728: OR
98729: IFFALSE 98733
// exit ;
98731: GO 99073
// list := [ ] ;
98733: LD_ADDR_VAR 0 13
98737: PUSH
98738: EMPTY
98739: ST_TO_ADDR
// if x - r < 0 then
98740: LD_VAR 0 2
98744: PUSH
98745: LD_VAR 0 4
98749: MINUS
98750: PUSH
98751: LD_INT 0
98753: LESS
98754: IFFALSE 98766
// min_x := 0 else
98756: LD_ADDR_VAR 0 7
98760: PUSH
98761: LD_INT 0
98763: ST_TO_ADDR
98764: GO 98782
// min_x := x - r ;
98766: LD_ADDR_VAR 0 7
98770: PUSH
98771: LD_VAR 0 2
98775: PUSH
98776: LD_VAR 0 4
98780: MINUS
98781: ST_TO_ADDR
// if y - r < 0 then
98782: LD_VAR 0 3
98786: PUSH
98787: LD_VAR 0 4
98791: MINUS
98792: PUSH
98793: LD_INT 0
98795: LESS
98796: IFFALSE 98808
// min_y := 0 else
98798: LD_ADDR_VAR 0 8
98802: PUSH
98803: LD_INT 0
98805: ST_TO_ADDR
98806: GO 98824
// min_y := y - r ;
98808: LD_ADDR_VAR 0 8
98812: PUSH
98813: LD_VAR 0 3
98817: PUSH
98818: LD_VAR 0 4
98822: MINUS
98823: ST_TO_ADDR
// max_x := x + r ;
98824: LD_ADDR_VAR 0 9
98828: PUSH
98829: LD_VAR 0 2
98833: PUSH
98834: LD_VAR 0 4
98838: PLUS
98839: ST_TO_ADDR
// max_y := y + r ;
98840: LD_ADDR_VAR 0 10
98844: PUSH
98845: LD_VAR 0 3
98849: PUSH
98850: LD_VAR 0 4
98854: PLUS
98855: ST_TO_ADDR
// for _x = min_x to max_x do
98856: LD_ADDR_VAR 0 11
98860: PUSH
98861: DOUBLE
98862: LD_VAR 0 7
98866: DEC
98867: ST_TO_ADDR
98868: LD_VAR 0 9
98872: PUSH
98873: FOR_TO
98874: IFFALSE 98991
// for _y = min_y to max_y do
98876: LD_ADDR_VAR 0 12
98880: PUSH
98881: DOUBLE
98882: LD_VAR 0 8
98886: DEC
98887: ST_TO_ADDR
98888: LD_VAR 0 10
98892: PUSH
98893: FOR_TO
98894: IFFALSE 98987
// begin if not ValidHex ( _x , _y ) then
98896: LD_VAR 0 11
98900: PPUSH
98901: LD_VAR 0 12
98905: PPUSH
98906: CALL_OW 488
98910: NOT
98911: IFFALSE 98915
// continue ;
98913: GO 98893
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98915: LD_VAR 0 11
98919: PPUSH
98920: LD_VAR 0 12
98924: PPUSH
98925: CALL_OW 351
98929: PUSH
98930: LD_VAR 0 11
98934: PPUSH
98935: LD_VAR 0 12
98939: PPUSH
98940: CALL_OW 554
98944: AND
98945: IFFALSE 98985
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98947: LD_ADDR_VAR 0 13
98951: PUSH
98952: LD_VAR 0 13
98956: PPUSH
98957: LD_VAR 0 13
98961: PUSH
98962: LD_INT 1
98964: PLUS
98965: PPUSH
98966: LD_VAR 0 11
98970: PUSH
98971: LD_VAR 0 12
98975: PUSH
98976: EMPTY
98977: LIST
98978: LIST
98979: PPUSH
98980: CALL_OW 2
98984: ST_TO_ADDR
// end ;
98985: GO 98893
98987: POP
98988: POP
98989: GO 98873
98991: POP
98992: POP
// if not list then
98993: LD_VAR 0 13
98997: NOT
98998: IFFALSE 99002
// exit ;
99000: GO 99073
// for i in list do
99002: LD_ADDR_VAR 0 6
99006: PUSH
99007: LD_VAR 0 13
99011: PUSH
99012: FOR_IN
99013: IFFALSE 99071
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
99015: LD_VAR 0 1
99019: PPUSH
99020: LD_STRING M
99022: PUSH
99023: LD_VAR 0 6
99027: PUSH
99028: LD_INT 1
99030: ARRAY
99031: PUSH
99032: LD_VAR 0 6
99036: PUSH
99037: LD_INT 2
99039: ARRAY
99040: PUSH
99041: LD_INT 0
99043: PUSH
99044: LD_INT 0
99046: PUSH
99047: LD_INT 0
99049: PUSH
99050: LD_INT 0
99052: PUSH
99053: EMPTY
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: PUSH
99062: EMPTY
99063: LIST
99064: PPUSH
99065: CALL_OW 447
99069: GO 99012
99071: POP
99072: POP
// end ;
99073: LD_VAR 0 5
99077: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
99078: LD_EXP 164
99082: NOT
99083: IFFALSE 99133
99085: GO 99087
99087: DISABLE
// begin initHack := true ;
99088: LD_ADDR_EXP 164
99092: PUSH
99093: LD_INT 1
99095: ST_TO_ADDR
// hackTanks := [ ] ;
99096: LD_ADDR_EXP 165
99100: PUSH
99101: EMPTY
99102: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
99103: LD_ADDR_EXP 166
99107: PUSH
99108: EMPTY
99109: ST_TO_ADDR
// hackLimit := 3 ;
99110: LD_ADDR_EXP 167
99114: PUSH
99115: LD_INT 3
99117: ST_TO_ADDR
// hackDist := 12 ;
99118: LD_ADDR_EXP 168
99122: PUSH
99123: LD_INT 12
99125: ST_TO_ADDR
// hackCounter := [ ] ;
99126: LD_ADDR_EXP 169
99130: PUSH
99131: EMPTY
99132: ST_TO_ADDR
// end ;
99133: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
99134: LD_EXP 164
99138: PUSH
99139: LD_INT 34
99141: PUSH
99142: LD_EXP 95
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: PPUSH
99151: CALL_OW 69
99155: AND
99156: IFFALSE 99411
99158: GO 99160
99160: DISABLE
99161: LD_INT 0
99163: PPUSH
99164: PPUSH
// begin enable ;
99165: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
99166: LD_ADDR_VAR 0 1
99170: PUSH
99171: LD_INT 34
99173: PUSH
99174: LD_EXP 95
99178: PUSH
99179: EMPTY
99180: LIST
99181: LIST
99182: PPUSH
99183: CALL_OW 69
99187: PUSH
99188: FOR_IN
99189: IFFALSE 99409
// begin if not i in hackTanks then
99191: LD_VAR 0 1
99195: PUSH
99196: LD_EXP 165
99200: IN
99201: NOT
99202: IFFALSE 99285
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
99204: LD_ADDR_EXP 165
99208: PUSH
99209: LD_EXP 165
99213: PPUSH
99214: LD_EXP 165
99218: PUSH
99219: LD_INT 1
99221: PLUS
99222: PPUSH
99223: LD_VAR 0 1
99227: PPUSH
99228: CALL_OW 1
99232: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
99233: LD_ADDR_EXP 166
99237: PUSH
99238: LD_EXP 166
99242: PPUSH
99243: LD_EXP 166
99247: PUSH
99248: LD_INT 1
99250: PLUS
99251: PPUSH
99252: EMPTY
99253: PPUSH
99254: CALL_OW 1
99258: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
99259: LD_ADDR_EXP 169
99263: PUSH
99264: LD_EXP 169
99268: PPUSH
99269: LD_EXP 169
99273: PUSH
99274: LD_INT 1
99276: PLUS
99277: PPUSH
99278: EMPTY
99279: PPUSH
99280: CALL_OW 1
99284: ST_TO_ADDR
// end ; if not IsOk ( i ) then
99285: LD_VAR 0 1
99289: PPUSH
99290: CALL_OW 302
99294: NOT
99295: IFFALSE 99308
// begin HackUnlinkAll ( i ) ;
99297: LD_VAR 0 1
99301: PPUSH
99302: CALL 99414 0 1
// continue ;
99306: GO 99188
// end ; HackCheckCapturedStatus ( i ) ;
99308: LD_VAR 0 1
99312: PPUSH
99313: CALL 99857 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
99317: LD_ADDR_VAR 0 2
99321: PUSH
99322: LD_INT 81
99324: PUSH
99325: LD_VAR 0 1
99329: PPUSH
99330: CALL_OW 255
99334: PUSH
99335: EMPTY
99336: LIST
99337: LIST
99338: PUSH
99339: LD_INT 33
99341: PUSH
99342: LD_INT 3
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: PUSH
99349: LD_INT 91
99351: PUSH
99352: LD_VAR 0 1
99356: PUSH
99357: LD_EXP 168
99361: PUSH
99362: EMPTY
99363: LIST
99364: LIST
99365: LIST
99366: PUSH
99367: LD_INT 50
99369: PUSH
99370: EMPTY
99371: LIST
99372: PUSH
99373: EMPTY
99374: LIST
99375: LIST
99376: LIST
99377: LIST
99378: PPUSH
99379: CALL_OW 69
99383: ST_TO_ADDR
// if not tmp then
99384: LD_VAR 0 2
99388: NOT
99389: IFFALSE 99393
// continue ;
99391: GO 99188
// HackLink ( i , tmp ) ;
99393: LD_VAR 0 1
99397: PPUSH
99398: LD_VAR 0 2
99402: PPUSH
99403: CALL 99550 0 2
// end ;
99407: GO 99188
99409: POP
99410: POP
// end ;
99411: PPOPN 2
99413: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
99414: LD_INT 0
99416: PPUSH
99417: PPUSH
99418: PPUSH
// if not hack in hackTanks then
99419: LD_VAR 0 1
99423: PUSH
99424: LD_EXP 165
99428: IN
99429: NOT
99430: IFFALSE 99434
// exit ;
99432: GO 99545
// index := GetElementIndex ( hackTanks , hack ) ;
99434: LD_ADDR_VAR 0 4
99438: PUSH
99439: LD_EXP 165
99443: PPUSH
99444: LD_VAR 0 1
99448: PPUSH
99449: CALL 52610 0 2
99453: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
99454: LD_EXP 166
99458: PUSH
99459: LD_VAR 0 4
99463: ARRAY
99464: IFFALSE 99545
// begin for i in hackTanksCaptured [ index ] do
99466: LD_ADDR_VAR 0 3
99470: PUSH
99471: LD_EXP 166
99475: PUSH
99476: LD_VAR 0 4
99480: ARRAY
99481: PUSH
99482: FOR_IN
99483: IFFALSE 99509
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
99485: LD_VAR 0 3
99489: PUSH
99490: LD_INT 1
99492: ARRAY
99493: PPUSH
99494: LD_VAR 0 3
99498: PUSH
99499: LD_INT 2
99501: ARRAY
99502: PPUSH
99503: CALL_OW 235
99507: GO 99482
99509: POP
99510: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
99511: LD_ADDR_EXP 166
99515: PUSH
99516: LD_EXP 166
99520: PPUSH
99521: LD_VAR 0 4
99525: PPUSH
99526: EMPTY
99527: PPUSH
99528: CALL_OW 1
99532: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
99533: LD_VAR 0 1
99537: PPUSH
99538: LD_INT 0
99540: PPUSH
99541: CALL_OW 505
// end ; end ;
99545: LD_VAR 0 2
99549: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
99550: LD_INT 0
99552: PPUSH
99553: PPUSH
99554: PPUSH
// if not hack in hackTanks or not vehicles then
99555: LD_VAR 0 1
99559: PUSH
99560: LD_EXP 165
99564: IN
99565: NOT
99566: PUSH
99567: LD_VAR 0 2
99571: NOT
99572: OR
99573: IFFALSE 99577
// exit ;
99575: GO 99852
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
99577: LD_ADDR_VAR 0 2
99581: PUSH
99582: LD_VAR 0 1
99586: PPUSH
99587: LD_VAR 0 2
99591: PPUSH
99592: LD_INT 1
99594: PPUSH
99595: LD_INT 1
99597: PPUSH
99598: CALL 53260 0 4
99602: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
99603: LD_ADDR_VAR 0 5
99607: PUSH
99608: LD_EXP 165
99612: PPUSH
99613: LD_VAR 0 1
99617: PPUSH
99618: CALL 52610 0 2
99622: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
99623: LD_EXP 166
99627: PUSH
99628: LD_VAR 0 5
99632: ARRAY
99633: PUSH
99634: LD_EXP 167
99638: LESS
99639: IFFALSE 99828
// begin for i := 1 to vehicles do
99641: LD_ADDR_VAR 0 4
99645: PUSH
99646: DOUBLE
99647: LD_INT 1
99649: DEC
99650: ST_TO_ADDR
99651: LD_VAR 0 2
99655: PUSH
99656: FOR_TO
99657: IFFALSE 99826
// begin if hackTanksCaptured [ index ] = hackLimit then
99659: LD_EXP 166
99663: PUSH
99664: LD_VAR 0 5
99668: ARRAY
99669: PUSH
99670: LD_EXP 167
99674: EQUAL
99675: IFFALSE 99679
// break ;
99677: GO 99826
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
99679: LD_ADDR_EXP 169
99683: PUSH
99684: LD_EXP 169
99688: PPUSH
99689: LD_VAR 0 5
99693: PPUSH
99694: LD_EXP 169
99698: PUSH
99699: LD_VAR 0 5
99703: ARRAY
99704: PUSH
99705: LD_INT 1
99707: PLUS
99708: PPUSH
99709: CALL_OW 1
99713: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
99714: LD_ADDR_EXP 166
99718: PUSH
99719: LD_EXP 166
99723: PPUSH
99724: LD_VAR 0 5
99728: PUSH
99729: LD_EXP 166
99733: PUSH
99734: LD_VAR 0 5
99738: ARRAY
99739: PUSH
99740: LD_INT 1
99742: PLUS
99743: PUSH
99744: EMPTY
99745: LIST
99746: LIST
99747: PPUSH
99748: LD_VAR 0 2
99752: PUSH
99753: LD_VAR 0 4
99757: ARRAY
99758: PUSH
99759: LD_VAR 0 2
99763: PUSH
99764: LD_VAR 0 4
99768: ARRAY
99769: PPUSH
99770: CALL_OW 255
99774: PUSH
99775: EMPTY
99776: LIST
99777: LIST
99778: PPUSH
99779: CALL 52825 0 3
99783: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99784: LD_VAR 0 2
99788: PUSH
99789: LD_VAR 0 4
99793: ARRAY
99794: PPUSH
99795: LD_VAR 0 1
99799: PPUSH
99800: CALL_OW 255
99804: PPUSH
99805: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99809: LD_VAR 0 2
99813: PUSH
99814: LD_VAR 0 4
99818: ARRAY
99819: PPUSH
99820: CALL_OW 141
// end ;
99824: GO 99656
99826: POP
99827: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99828: LD_VAR 0 1
99832: PPUSH
99833: LD_EXP 166
99837: PUSH
99838: LD_VAR 0 5
99842: ARRAY
99843: PUSH
99844: LD_INT 0
99846: PLUS
99847: PPUSH
99848: CALL_OW 505
// end ;
99852: LD_VAR 0 3
99856: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99857: LD_INT 0
99859: PPUSH
99860: PPUSH
99861: PPUSH
99862: PPUSH
// if not hack in hackTanks then
99863: LD_VAR 0 1
99867: PUSH
99868: LD_EXP 165
99872: IN
99873: NOT
99874: IFFALSE 99878
// exit ;
99876: GO 100118
// index := GetElementIndex ( hackTanks , hack ) ;
99878: LD_ADDR_VAR 0 4
99882: PUSH
99883: LD_EXP 165
99887: PPUSH
99888: LD_VAR 0 1
99892: PPUSH
99893: CALL 52610 0 2
99897: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99898: LD_ADDR_VAR 0 3
99902: PUSH
99903: DOUBLE
99904: LD_EXP 166
99908: PUSH
99909: LD_VAR 0 4
99913: ARRAY
99914: INC
99915: ST_TO_ADDR
99916: LD_INT 1
99918: PUSH
99919: FOR_DOWNTO
99920: IFFALSE 100092
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99922: LD_ADDR_VAR 0 5
99926: PUSH
99927: LD_EXP 166
99931: PUSH
99932: LD_VAR 0 4
99936: ARRAY
99937: PUSH
99938: LD_VAR 0 3
99942: ARRAY
99943: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99944: LD_VAR 0 5
99948: PUSH
99949: LD_INT 1
99951: ARRAY
99952: PPUSH
99953: CALL_OW 302
99957: NOT
99958: PUSH
99959: LD_VAR 0 5
99963: PUSH
99964: LD_INT 1
99966: ARRAY
99967: PPUSH
99968: CALL_OW 255
99972: PUSH
99973: LD_VAR 0 1
99977: PPUSH
99978: CALL_OW 255
99982: NONEQUAL
99983: OR
99984: IFFALSE 100090
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99986: LD_VAR 0 5
99990: PUSH
99991: LD_INT 1
99993: ARRAY
99994: PPUSH
99995: CALL_OW 305
99999: PUSH
100000: LD_VAR 0 5
100004: PUSH
100005: LD_INT 1
100007: ARRAY
100008: PPUSH
100009: CALL_OW 255
100013: PUSH
100014: LD_VAR 0 1
100018: PPUSH
100019: CALL_OW 255
100023: EQUAL
100024: AND
100025: IFFALSE 100049
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
100027: LD_VAR 0 5
100031: PUSH
100032: LD_INT 1
100034: ARRAY
100035: PPUSH
100036: LD_VAR 0 5
100040: PUSH
100041: LD_INT 2
100043: ARRAY
100044: PPUSH
100045: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
100049: LD_ADDR_EXP 166
100053: PUSH
100054: LD_EXP 166
100058: PPUSH
100059: LD_VAR 0 4
100063: PPUSH
100064: LD_EXP 166
100068: PUSH
100069: LD_VAR 0 4
100073: ARRAY
100074: PPUSH
100075: LD_VAR 0 3
100079: PPUSH
100080: CALL_OW 3
100084: PPUSH
100085: CALL_OW 1
100089: ST_TO_ADDR
// end ; end ;
100090: GO 99919
100092: POP
100093: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100094: LD_VAR 0 1
100098: PPUSH
100099: LD_EXP 166
100103: PUSH
100104: LD_VAR 0 4
100108: ARRAY
100109: PUSH
100110: LD_INT 0
100112: PLUS
100113: PPUSH
100114: CALL_OW 505
// end ;
100118: LD_VAR 0 2
100122: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
100123: LD_INT 0
100125: PPUSH
100126: PPUSH
100127: PPUSH
100128: PPUSH
// if not hack in hackTanks then
100129: LD_VAR 0 1
100133: PUSH
100134: LD_EXP 165
100138: IN
100139: NOT
100140: IFFALSE 100144
// exit ;
100142: GO 100229
// index := GetElementIndex ( hackTanks , hack ) ;
100144: LD_ADDR_VAR 0 5
100148: PUSH
100149: LD_EXP 165
100153: PPUSH
100154: LD_VAR 0 1
100158: PPUSH
100159: CALL 52610 0 2
100163: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
100164: LD_ADDR_VAR 0 4
100168: PUSH
100169: DOUBLE
100170: LD_INT 1
100172: DEC
100173: ST_TO_ADDR
100174: LD_EXP 166
100178: PUSH
100179: LD_VAR 0 5
100183: ARRAY
100184: PUSH
100185: FOR_TO
100186: IFFALSE 100227
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
100188: LD_EXP 166
100192: PUSH
100193: LD_VAR 0 5
100197: ARRAY
100198: PUSH
100199: LD_VAR 0 4
100203: ARRAY
100204: PUSH
100205: LD_INT 1
100207: ARRAY
100208: PUSH
100209: LD_VAR 0 2
100213: EQUAL
100214: IFFALSE 100225
// KillUnit ( vehicle ) ;
100216: LD_VAR 0 2
100220: PPUSH
100221: CALL_OW 66
100225: GO 100185
100227: POP
100228: POP
// end ;
100229: LD_VAR 0 3
100233: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
100234: LD_EXP 170
100238: NOT
100239: IFFALSE 100274
100241: GO 100243
100243: DISABLE
// begin initMiner := true ;
100244: LD_ADDR_EXP 170
100248: PUSH
100249: LD_INT 1
100251: ST_TO_ADDR
// minersList := [ ] ;
100252: LD_ADDR_EXP 171
100256: PUSH
100257: EMPTY
100258: ST_TO_ADDR
// minerMinesList := [ ] ;
100259: LD_ADDR_EXP 172
100263: PUSH
100264: EMPTY
100265: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
100266: LD_ADDR_EXP 173
100270: PUSH
100271: LD_INT 5
100273: ST_TO_ADDR
// end ;
100274: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
100275: LD_EXP 170
100279: PUSH
100280: LD_INT 34
100282: PUSH
100283: LD_EXP 100
100287: PUSH
100288: EMPTY
100289: LIST
100290: LIST
100291: PPUSH
100292: CALL_OW 69
100296: AND
100297: IFFALSE 100760
100299: GO 100301
100301: DISABLE
100302: LD_INT 0
100304: PPUSH
100305: PPUSH
100306: PPUSH
100307: PPUSH
// begin enable ;
100308: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
100309: LD_ADDR_VAR 0 1
100313: PUSH
100314: LD_INT 34
100316: PUSH
100317: LD_EXP 100
100321: PUSH
100322: EMPTY
100323: LIST
100324: LIST
100325: PPUSH
100326: CALL_OW 69
100330: PUSH
100331: FOR_IN
100332: IFFALSE 100404
// begin if not i in minersList then
100334: LD_VAR 0 1
100338: PUSH
100339: LD_EXP 171
100343: IN
100344: NOT
100345: IFFALSE 100402
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
100347: LD_ADDR_EXP 171
100351: PUSH
100352: LD_EXP 171
100356: PPUSH
100357: LD_EXP 171
100361: PUSH
100362: LD_INT 1
100364: PLUS
100365: PPUSH
100366: LD_VAR 0 1
100370: PPUSH
100371: CALL_OW 1
100375: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
100376: LD_ADDR_EXP 172
100380: PUSH
100381: LD_EXP 172
100385: PPUSH
100386: LD_EXP 172
100390: PUSH
100391: LD_INT 1
100393: PLUS
100394: PPUSH
100395: EMPTY
100396: PPUSH
100397: CALL_OW 1
100401: ST_TO_ADDR
// end end ;
100402: GO 100331
100404: POP
100405: POP
// for i := minerMinesList downto 1 do
100406: LD_ADDR_VAR 0 1
100410: PUSH
100411: DOUBLE
100412: LD_EXP 172
100416: INC
100417: ST_TO_ADDR
100418: LD_INT 1
100420: PUSH
100421: FOR_DOWNTO
100422: IFFALSE 100758
// begin if IsLive ( minersList [ i ] ) then
100424: LD_EXP 171
100428: PUSH
100429: LD_VAR 0 1
100433: ARRAY
100434: PPUSH
100435: CALL_OW 300
100439: IFFALSE 100467
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
100441: LD_EXP 171
100445: PUSH
100446: LD_VAR 0 1
100450: ARRAY
100451: PPUSH
100452: LD_EXP 172
100456: PUSH
100457: LD_VAR 0 1
100461: ARRAY
100462: PPUSH
100463: CALL_OW 505
// if not minerMinesList [ i ] then
100467: LD_EXP 172
100471: PUSH
100472: LD_VAR 0 1
100476: ARRAY
100477: NOT
100478: IFFALSE 100482
// continue ;
100480: GO 100421
// for j := minerMinesList [ i ] downto 1 do
100482: LD_ADDR_VAR 0 2
100486: PUSH
100487: DOUBLE
100488: LD_EXP 172
100492: PUSH
100493: LD_VAR 0 1
100497: ARRAY
100498: INC
100499: ST_TO_ADDR
100500: LD_INT 1
100502: PUSH
100503: FOR_DOWNTO
100504: IFFALSE 100754
// begin side := GetSide ( minersList [ i ] ) ;
100506: LD_ADDR_VAR 0 3
100510: PUSH
100511: LD_EXP 171
100515: PUSH
100516: LD_VAR 0 1
100520: ARRAY
100521: PPUSH
100522: CALL_OW 255
100526: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
100527: LD_ADDR_VAR 0 4
100531: PUSH
100532: LD_EXP 172
100536: PUSH
100537: LD_VAR 0 1
100541: ARRAY
100542: PUSH
100543: LD_VAR 0 2
100547: ARRAY
100548: PUSH
100549: LD_INT 1
100551: ARRAY
100552: PPUSH
100553: LD_EXP 172
100557: PUSH
100558: LD_VAR 0 1
100562: ARRAY
100563: PUSH
100564: LD_VAR 0 2
100568: ARRAY
100569: PUSH
100570: LD_INT 2
100572: ARRAY
100573: PPUSH
100574: CALL_OW 428
100578: ST_TO_ADDR
// if not tmp then
100579: LD_VAR 0 4
100583: NOT
100584: IFFALSE 100588
// continue ;
100586: GO 100503
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
100588: LD_VAR 0 4
100592: PUSH
100593: LD_INT 81
100595: PUSH
100596: LD_VAR 0 3
100600: PUSH
100601: EMPTY
100602: LIST
100603: LIST
100604: PPUSH
100605: CALL_OW 69
100609: IN
100610: PUSH
100611: LD_EXP 172
100615: PUSH
100616: LD_VAR 0 1
100620: ARRAY
100621: PUSH
100622: LD_VAR 0 2
100626: ARRAY
100627: PUSH
100628: LD_INT 1
100630: ARRAY
100631: PPUSH
100632: LD_EXP 172
100636: PUSH
100637: LD_VAR 0 1
100641: ARRAY
100642: PUSH
100643: LD_VAR 0 2
100647: ARRAY
100648: PUSH
100649: LD_INT 2
100651: ARRAY
100652: PPUSH
100653: CALL_OW 458
100657: AND
100658: IFFALSE 100752
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
100660: LD_EXP 172
100664: PUSH
100665: LD_VAR 0 1
100669: ARRAY
100670: PUSH
100671: LD_VAR 0 2
100675: ARRAY
100676: PUSH
100677: LD_INT 1
100679: ARRAY
100680: PPUSH
100681: LD_EXP 172
100685: PUSH
100686: LD_VAR 0 1
100690: ARRAY
100691: PUSH
100692: LD_VAR 0 2
100696: ARRAY
100697: PUSH
100698: LD_INT 2
100700: ARRAY
100701: PPUSH
100702: LD_VAR 0 3
100706: PPUSH
100707: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
100711: LD_ADDR_EXP 172
100715: PUSH
100716: LD_EXP 172
100720: PPUSH
100721: LD_VAR 0 1
100725: PPUSH
100726: LD_EXP 172
100730: PUSH
100731: LD_VAR 0 1
100735: ARRAY
100736: PPUSH
100737: LD_VAR 0 2
100741: PPUSH
100742: CALL_OW 3
100746: PPUSH
100747: CALL_OW 1
100751: ST_TO_ADDR
// end ; end ;
100752: GO 100503
100754: POP
100755: POP
// end ;
100756: GO 100421
100758: POP
100759: POP
// end ;
100760: PPOPN 4
100762: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
100763: LD_INT 0
100765: PPUSH
100766: PPUSH
// result := false ;
100767: LD_ADDR_VAR 0 4
100771: PUSH
100772: LD_INT 0
100774: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
100775: LD_VAR 0 1
100779: PPUSH
100780: CALL_OW 264
100784: PUSH
100785: LD_EXP 100
100789: EQUAL
100790: NOT
100791: IFFALSE 100795
// exit ;
100793: GO 101035
// index := GetElementIndex ( minersList , unit ) ;
100795: LD_ADDR_VAR 0 5
100799: PUSH
100800: LD_EXP 171
100804: PPUSH
100805: LD_VAR 0 1
100809: PPUSH
100810: CALL 52610 0 2
100814: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100815: LD_EXP 172
100819: PUSH
100820: LD_VAR 0 5
100824: ARRAY
100825: PUSH
100826: LD_EXP 173
100830: GREATEREQUAL
100831: IFFALSE 100835
// exit ;
100833: GO 101035
// ComMoveXY ( unit , x , y ) ;
100835: LD_VAR 0 1
100839: PPUSH
100840: LD_VAR 0 2
100844: PPUSH
100845: LD_VAR 0 3
100849: PPUSH
100850: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100854: LD_INT 35
100856: PPUSH
100857: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100861: LD_VAR 0 1
100865: PPUSH
100866: LD_VAR 0 2
100870: PPUSH
100871: LD_VAR 0 3
100875: PPUSH
100876: CALL 82674 0 3
100880: NOT
100881: PUSH
100882: LD_VAR 0 1
100886: PPUSH
100887: CALL_OW 314
100891: AND
100892: IFFALSE 100896
// exit ;
100894: GO 101035
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100896: LD_VAR 0 2
100900: PPUSH
100901: LD_VAR 0 3
100905: PPUSH
100906: CALL_OW 428
100910: PUSH
100911: LD_VAR 0 1
100915: EQUAL
100916: PUSH
100917: LD_VAR 0 1
100921: PPUSH
100922: CALL_OW 314
100926: NOT
100927: AND
100928: IFFALSE 100854
// PlaySoundXY ( x , y , PlantMine ) ;
100930: LD_VAR 0 2
100934: PPUSH
100935: LD_VAR 0 3
100939: PPUSH
100940: LD_STRING PlantMine
100942: PPUSH
100943: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100947: LD_VAR 0 2
100951: PPUSH
100952: LD_VAR 0 3
100956: PPUSH
100957: LD_VAR 0 1
100961: PPUSH
100962: CALL_OW 255
100966: PPUSH
100967: LD_INT 0
100969: PPUSH
100970: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
100974: LD_ADDR_EXP 172
100978: PUSH
100979: LD_EXP 172
100983: PPUSH
100984: LD_VAR 0 5
100988: PUSH
100989: LD_EXP 172
100993: PUSH
100994: LD_VAR 0 5
100998: ARRAY
100999: PUSH
101000: LD_INT 1
101002: PLUS
101003: PUSH
101004: EMPTY
101005: LIST
101006: LIST
101007: PPUSH
101008: LD_VAR 0 2
101012: PUSH
101013: LD_VAR 0 3
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PPUSH
101022: CALL 52825 0 3
101026: ST_TO_ADDR
// result := true ;
101027: LD_ADDR_VAR 0 4
101031: PUSH
101032: LD_INT 1
101034: ST_TO_ADDR
// end ;
101035: LD_VAR 0 4
101039: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
101040: LD_INT 0
101042: PPUSH
101043: PPUSH
101044: PPUSH
// if not unit in minersList then
101045: LD_VAR 0 1
101049: PUSH
101050: LD_EXP 171
101054: IN
101055: NOT
101056: IFFALSE 101060
// exit ;
101058: GO 101452
// index := GetElementIndex ( minersList , unit ) ;
101060: LD_ADDR_VAR 0 6
101064: PUSH
101065: LD_EXP 171
101069: PPUSH
101070: LD_VAR 0 1
101074: PPUSH
101075: CALL 52610 0 2
101079: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
101080: LD_ADDR_VAR 0 5
101084: PUSH
101085: DOUBLE
101086: LD_EXP 172
101090: PUSH
101091: LD_VAR 0 6
101095: ARRAY
101096: INC
101097: ST_TO_ADDR
101098: LD_INT 1
101100: PUSH
101101: FOR_DOWNTO
101102: IFFALSE 101263
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
101104: LD_EXP 172
101108: PUSH
101109: LD_VAR 0 6
101113: ARRAY
101114: PUSH
101115: LD_VAR 0 5
101119: ARRAY
101120: PUSH
101121: LD_INT 1
101123: ARRAY
101124: PUSH
101125: LD_VAR 0 2
101129: EQUAL
101130: PUSH
101131: LD_EXP 172
101135: PUSH
101136: LD_VAR 0 6
101140: ARRAY
101141: PUSH
101142: LD_VAR 0 5
101146: ARRAY
101147: PUSH
101148: LD_INT 2
101150: ARRAY
101151: PUSH
101152: LD_VAR 0 3
101156: EQUAL
101157: AND
101158: IFFALSE 101261
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101160: LD_EXP 172
101164: PUSH
101165: LD_VAR 0 6
101169: ARRAY
101170: PUSH
101171: LD_VAR 0 5
101175: ARRAY
101176: PUSH
101177: LD_INT 1
101179: ARRAY
101180: PPUSH
101181: LD_EXP 172
101185: PUSH
101186: LD_VAR 0 6
101190: ARRAY
101191: PUSH
101192: LD_VAR 0 5
101196: ARRAY
101197: PUSH
101198: LD_INT 2
101200: ARRAY
101201: PPUSH
101202: LD_VAR 0 1
101206: PPUSH
101207: CALL_OW 255
101211: PPUSH
101212: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101216: LD_ADDR_EXP 172
101220: PUSH
101221: LD_EXP 172
101225: PPUSH
101226: LD_VAR 0 6
101230: PPUSH
101231: LD_EXP 172
101235: PUSH
101236: LD_VAR 0 6
101240: ARRAY
101241: PPUSH
101242: LD_VAR 0 5
101246: PPUSH
101247: CALL_OW 3
101251: PPUSH
101252: CALL_OW 1
101256: ST_TO_ADDR
// exit ;
101257: POP
101258: POP
101259: GO 101452
// end ; end ;
101261: GO 101101
101263: POP
101264: POP
// for i := minerMinesList [ index ] downto 1 do
101265: LD_ADDR_VAR 0 5
101269: PUSH
101270: DOUBLE
101271: LD_EXP 172
101275: PUSH
101276: LD_VAR 0 6
101280: ARRAY
101281: INC
101282: ST_TO_ADDR
101283: LD_INT 1
101285: PUSH
101286: FOR_DOWNTO
101287: IFFALSE 101450
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
101289: LD_EXP 172
101293: PUSH
101294: LD_VAR 0 6
101298: ARRAY
101299: PUSH
101300: LD_VAR 0 5
101304: ARRAY
101305: PUSH
101306: LD_INT 1
101308: ARRAY
101309: PPUSH
101310: LD_EXP 172
101314: PUSH
101315: LD_VAR 0 6
101319: ARRAY
101320: PUSH
101321: LD_VAR 0 5
101325: ARRAY
101326: PUSH
101327: LD_INT 2
101329: ARRAY
101330: PPUSH
101331: LD_VAR 0 2
101335: PPUSH
101336: LD_VAR 0 3
101340: PPUSH
101341: CALL_OW 298
101345: PUSH
101346: LD_INT 6
101348: LESS
101349: IFFALSE 101448
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101351: LD_EXP 172
101355: PUSH
101356: LD_VAR 0 6
101360: ARRAY
101361: PUSH
101362: LD_VAR 0 5
101366: ARRAY
101367: PUSH
101368: LD_INT 1
101370: ARRAY
101371: PPUSH
101372: LD_EXP 172
101376: PUSH
101377: LD_VAR 0 6
101381: ARRAY
101382: PUSH
101383: LD_VAR 0 5
101387: ARRAY
101388: PUSH
101389: LD_INT 2
101391: ARRAY
101392: PPUSH
101393: LD_VAR 0 1
101397: PPUSH
101398: CALL_OW 255
101402: PPUSH
101403: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101407: LD_ADDR_EXP 172
101411: PUSH
101412: LD_EXP 172
101416: PPUSH
101417: LD_VAR 0 6
101421: PPUSH
101422: LD_EXP 172
101426: PUSH
101427: LD_VAR 0 6
101431: ARRAY
101432: PPUSH
101433: LD_VAR 0 5
101437: PPUSH
101438: CALL_OW 3
101442: PPUSH
101443: CALL_OW 1
101447: ST_TO_ADDR
// end ; end ;
101448: GO 101286
101450: POP
101451: POP
// end ;
101452: LD_VAR 0 4
101456: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
101457: LD_INT 0
101459: PPUSH
101460: PPUSH
101461: PPUSH
101462: PPUSH
101463: PPUSH
101464: PPUSH
101465: PPUSH
101466: PPUSH
101467: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
101468: LD_VAR 0 1
101472: PPUSH
101473: CALL_OW 264
101477: PUSH
101478: LD_EXP 100
101482: EQUAL
101483: NOT
101484: PUSH
101485: LD_VAR 0 1
101489: PUSH
101490: LD_EXP 171
101494: IN
101495: NOT
101496: OR
101497: IFFALSE 101501
// exit ;
101499: GO 101823
// index := GetElementIndex ( minersList , unit ) ;
101501: LD_ADDR_VAR 0 6
101505: PUSH
101506: LD_EXP 171
101510: PPUSH
101511: LD_VAR 0 1
101515: PPUSH
101516: CALL 52610 0 2
101520: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
101521: LD_ADDR_VAR 0 8
101525: PUSH
101526: LD_EXP 173
101530: PUSH
101531: LD_EXP 172
101535: PUSH
101536: LD_VAR 0 6
101540: ARRAY
101541: MINUS
101542: ST_TO_ADDR
// if not minesFreeAmount then
101543: LD_VAR 0 8
101547: NOT
101548: IFFALSE 101552
// exit ;
101550: GO 101823
// tmp := [ ] ;
101552: LD_ADDR_VAR 0 7
101556: PUSH
101557: EMPTY
101558: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
101559: LD_ADDR_VAR 0 5
101563: PUSH
101564: DOUBLE
101565: LD_INT 1
101567: DEC
101568: ST_TO_ADDR
101569: LD_VAR 0 8
101573: PUSH
101574: FOR_TO
101575: IFFALSE 101770
// begin _d := rand ( 0 , 5 ) ;
101577: LD_ADDR_VAR 0 11
101581: PUSH
101582: LD_INT 0
101584: PPUSH
101585: LD_INT 5
101587: PPUSH
101588: CALL_OW 12
101592: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
101593: LD_ADDR_VAR 0 12
101597: PUSH
101598: LD_INT 2
101600: PPUSH
101601: LD_INT 6
101603: PPUSH
101604: CALL_OW 12
101608: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
101609: LD_ADDR_VAR 0 9
101613: PUSH
101614: LD_VAR 0 2
101618: PPUSH
101619: LD_VAR 0 11
101623: PPUSH
101624: LD_VAR 0 12
101628: PPUSH
101629: CALL_OW 272
101633: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
101634: LD_ADDR_VAR 0 10
101638: PUSH
101639: LD_VAR 0 3
101643: PPUSH
101644: LD_VAR 0 11
101648: PPUSH
101649: LD_VAR 0 12
101653: PPUSH
101654: CALL_OW 273
101658: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
101659: LD_VAR 0 9
101663: PPUSH
101664: LD_VAR 0 10
101668: PPUSH
101669: CALL_OW 488
101673: PUSH
101674: LD_VAR 0 9
101678: PUSH
101679: LD_VAR 0 10
101683: PUSH
101684: EMPTY
101685: LIST
101686: LIST
101687: PUSH
101688: LD_VAR 0 7
101692: IN
101693: NOT
101694: AND
101695: PUSH
101696: LD_VAR 0 9
101700: PPUSH
101701: LD_VAR 0 10
101705: PPUSH
101706: CALL_OW 458
101710: NOT
101711: AND
101712: IFFALSE 101754
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
101714: LD_ADDR_VAR 0 7
101718: PUSH
101719: LD_VAR 0 7
101723: PPUSH
101724: LD_VAR 0 7
101728: PUSH
101729: LD_INT 1
101731: PLUS
101732: PPUSH
101733: LD_VAR 0 9
101737: PUSH
101738: LD_VAR 0 10
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: PPUSH
101747: CALL_OW 1
101751: ST_TO_ADDR
101752: GO 101768
// i := i - 1 ;
101754: LD_ADDR_VAR 0 5
101758: PUSH
101759: LD_VAR 0 5
101763: PUSH
101764: LD_INT 1
101766: MINUS
101767: ST_TO_ADDR
// end ;
101768: GO 101574
101770: POP
101771: POP
// for i in tmp do
101772: LD_ADDR_VAR 0 5
101776: PUSH
101777: LD_VAR 0 7
101781: PUSH
101782: FOR_IN
101783: IFFALSE 101821
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
101785: LD_VAR 0 1
101789: PPUSH
101790: LD_VAR 0 5
101794: PUSH
101795: LD_INT 1
101797: ARRAY
101798: PPUSH
101799: LD_VAR 0 5
101803: PUSH
101804: LD_INT 2
101806: ARRAY
101807: PPUSH
101808: CALL 100763 0 3
101812: NOT
101813: IFFALSE 101819
// exit ;
101815: POP
101816: POP
101817: GO 101823
101819: GO 101782
101821: POP
101822: POP
// end ;
101823: LD_VAR 0 4
101827: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101828: LD_INT 0
101830: PPUSH
101831: PPUSH
101832: PPUSH
101833: PPUSH
101834: PPUSH
101835: PPUSH
101836: PPUSH
// if not GetClass ( unit ) = class_sniper then
101837: LD_VAR 0 1
101841: PPUSH
101842: CALL_OW 257
101846: PUSH
101847: LD_INT 5
101849: EQUAL
101850: NOT
101851: IFFALSE 101855
// exit ;
101853: GO 102243
// dist := 8 ;
101855: LD_ADDR_VAR 0 5
101859: PUSH
101860: LD_INT 8
101862: ST_TO_ADDR
// viewRange := 12 ;
101863: LD_ADDR_VAR 0 7
101867: PUSH
101868: LD_INT 12
101870: ST_TO_ADDR
// side := GetSide ( unit ) ;
101871: LD_ADDR_VAR 0 6
101875: PUSH
101876: LD_VAR 0 1
101880: PPUSH
101881: CALL_OW 255
101885: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101886: LD_INT 61
101888: PPUSH
101889: LD_VAR 0 6
101893: PPUSH
101894: CALL_OW 321
101898: PUSH
101899: LD_INT 2
101901: EQUAL
101902: IFFALSE 101912
// viewRange := 16 ;
101904: LD_ADDR_VAR 0 7
101908: PUSH
101909: LD_INT 16
101911: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101912: LD_VAR 0 1
101916: PPUSH
101917: LD_VAR 0 2
101921: PPUSH
101922: LD_VAR 0 3
101926: PPUSH
101927: CALL_OW 297
101931: PUSH
101932: LD_VAR 0 5
101936: GREATER
101937: IFFALSE 102016
// begin ComMoveXY ( unit , x , y ) ;
101939: LD_VAR 0 1
101943: PPUSH
101944: LD_VAR 0 2
101948: PPUSH
101949: LD_VAR 0 3
101953: PPUSH
101954: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101958: LD_INT 35
101960: PPUSH
101961: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
101965: LD_VAR 0 1
101969: PPUSH
101970: LD_VAR 0 2
101974: PPUSH
101975: LD_VAR 0 3
101979: PPUSH
101980: CALL 82674 0 3
101984: NOT
101985: IFFALSE 101989
// exit ;
101987: GO 102243
// until GetDistUnitXY ( unit , x , y ) < dist ;
101989: LD_VAR 0 1
101993: PPUSH
101994: LD_VAR 0 2
101998: PPUSH
101999: LD_VAR 0 3
102003: PPUSH
102004: CALL_OW 297
102008: PUSH
102009: LD_VAR 0 5
102013: LESS
102014: IFFALSE 101958
// end ; ComTurnXY ( unit , x , y ) ;
102016: LD_VAR 0 1
102020: PPUSH
102021: LD_VAR 0 2
102025: PPUSH
102026: LD_VAR 0 3
102030: PPUSH
102031: CALL_OW 118
// wait ( 5 ) ;
102035: LD_INT 5
102037: PPUSH
102038: CALL_OW 67
// _d := GetDir ( unit ) ;
102042: LD_ADDR_VAR 0 10
102046: PUSH
102047: LD_VAR 0 1
102051: PPUSH
102052: CALL_OW 254
102056: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
102057: LD_ADDR_VAR 0 8
102061: PUSH
102062: LD_VAR 0 1
102066: PPUSH
102067: CALL_OW 250
102071: PPUSH
102072: LD_VAR 0 10
102076: PPUSH
102077: LD_VAR 0 5
102081: PPUSH
102082: CALL_OW 272
102086: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
102087: LD_ADDR_VAR 0 9
102091: PUSH
102092: LD_VAR 0 1
102096: PPUSH
102097: CALL_OW 251
102101: PPUSH
102102: LD_VAR 0 10
102106: PPUSH
102107: LD_VAR 0 5
102111: PPUSH
102112: CALL_OW 273
102116: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102117: LD_VAR 0 8
102121: PPUSH
102122: LD_VAR 0 9
102126: PPUSH
102127: CALL_OW 488
102131: NOT
102132: IFFALSE 102136
// exit ;
102134: GO 102243
// ComAnimCustom ( unit , 1 ) ;
102136: LD_VAR 0 1
102140: PPUSH
102141: LD_INT 1
102143: PPUSH
102144: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
102148: LD_VAR 0 8
102152: PPUSH
102153: LD_VAR 0 9
102157: PPUSH
102158: LD_VAR 0 6
102162: PPUSH
102163: LD_VAR 0 7
102167: PPUSH
102168: CALL_OW 330
// repeat wait ( 1 ) ;
102172: LD_INT 1
102174: PPUSH
102175: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
102179: LD_VAR 0 1
102183: PPUSH
102184: CALL_OW 316
102188: PUSH
102189: LD_VAR 0 1
102193: PPUSH
102194: CALL_OW 314
102198: OR
102199: PUSH
102200: LD_VAR 0 1
102204: PPUSH
102205: CALL_OW 302
102209: NOT
102210: OR
102211: PUSH
102212: LD_VAR 0 1
102216: PPUSH
102217: CALL_OW 301
102221: OR
102222: IFFALSE 102172
// RemoveSeeing ( _x , _y , side ) ;
102224: LD_VAR 0 8
102228: PPUSH
102229: LD_VAR 0 9
102233: PPUSH
102234: LD_VAR 0 6
102238: PPUSH
102239: CALL_OW 331
// end ; end_of_file
102243: LD_VAR 0 4
102247: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
102248: LD_INT 0
102250: PPUSH
102251: PPUSH
102252: PPUSH
102253: PPUSH
102254: PPUSH
102255: PPUSH
102256: PPUSH
102257: PPUSH
102258: PPUSH
102259: PPUSH
102260: PPUSH
102261: PPUSH
102262: PPUSH
102263: PPUSH
102264: PPUSH
102265: PPUSH
102266: PPUSH
102267: PPUSH
102268: PPUSH
102269: PPUSH
102270: PPUSH
102271: PPUSH
102272: PPUSH
102273: PPUSH
102274: PPUSH
102275: PPUSH
102276: PPUSH
102277: PPUSH
102278: PPUSH
102279: PPUSH
102280: PPUSH
102281: PPUSH
102282: PPUSH
102283: PPUSH
// if not list then
102284: LD_VAR 0 1
102288: NOT
102289: IFFALSE 102293
// exit ;
102291: GO 106952
// base := list [ 1 ] ;
102293: LD_ADDR_VAR 0 3
102297: PUSH
102298: LD_VAR 0 1
102302: PUSH
102303: LD_INT 1
102305: ARRAY
102306: ST_TO_ADDR
// group := list [ 2 ] ;
102307: LD_ADDR_VAR 0 4
102311: PUSH
102312: LD_VAR 0 1
102316: PUSH
102317: LD_INT 2
102319: ARRAY
102320: ST_TO_ADDR
// path := list [ 3 ] ;
102321: LD_ADDR_VAR 0 5
102325: PUSH
102326: LD_VAR 0 1
102330: PUSH
102331: LD_INT 3
102333: ARRAY
102334: ST_TO_ADDR
// flags := list [ 4 ] ;
102335: LD_ADDR_VAR 0 6
102339: PUSH
102340: LD_VAR 0 1
102344: PUSH
102345: LD_INT 4
102347: ARRAY
102348: ST_TO_ADDR
// mined := [ ] ;
102349: LD_ADDR_VAR 0 27
102353: PUSH
102354: EMPTY
102355: ST_TO_ADDR
// bombed := [ ] ;
102356: LD_ADDR_VAR 0 28
102360: PUSH
102361: EMPTY
102362: ST_TO_ADDR
// healers := [ ] ;
102363: LD_ADDR_VAR 0 31
102367: PUSH
102368: EMPTY
102369: ST_TO_ADDR
// to_heal := [ ] ;
102370: LD_ADDR_VAR 0 30
102374: PUSH
102375: EMPTY
102376: ST_TO_ADDR
// repairs := [ ] ;
102377: LD_ADDR_VAR 0 33
102381: PUSH
102382: EMPTY
102383: ST_TO_ADDR
// to_repair := [ ] ;
102384: LD_ADDR_VAR 0 32
102388: PUSH
102389: EMPTY
102390: ST_TO_ADDR
// if not group or not path then
102391: LD_VAR 0 4
102395: NOT
102396: PUSH
102397: LD_VAR 0 5
102401: NOT
102402: OR
102403: IFFALSE 102407
// exit ;
102405: GO 106952
// side := GetSide ( group [ 1 ] ) ;
102407: LD_ADDR_VAR 0 35
102411: PUSH
102412: LD_VAR 0 4
102416: PUSH
102417: LD_INT 1
102419: ARRAY
102420: PPUSH
102421: CALL_OW 255
102425: ST_TO_ADDR
// if flags then
102426: LD_VAR 0 6
102430: IFFALSE 102574
// begin f_ignore_area := flags [ 1 ] ;
102432: LD_ADDR_VAR 0 17
102436: PUSH
102437: LD_VAR 0 6
102441: PUSH
102442: LD_INT 1
102444: ARRAY
102445: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
102446: LD_ADDR_VAR 0 18
102450: PUSH
102451: LD_VAR 0 6
102455: PUSH
102456: LD_INT 2
102458: ARRAY
102459: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
102460: LD_ADDR_VAR 0 19
102464: PUSH
102465: LD_VAR 0 6
102469: PUSH
102470: LD_INT 3
102472: ARRAY
102473: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
102474: LD_ADDR_VAR 0 20
102478: PUSH
102479: LD_VAR 0 6
102483: PUSH
102484: LD_INT 4
102486: ARRAY
102487: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
102488: LD_ADDR_VAR 0 21
102492: PUSH
102493: LD_VAR 0 6
102497: PUSH
102498: LD_INT 5
102500: ARRAY
102501: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
102502: LD_ADDR_VAR 0 22
102506: PUSH
102507: LD_VAR 0 6
102511: PUSH
102512: LD_INT 6
102514: ARRAY
102515: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
102516: LD_ADDR_VAR 0 23
102520: PUSH
102521: LD_VAR 0 6
102525: PUSH
102526: LD_INT 7
102528: ARRAY
102529: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
102530: LD_ADDR_VAR 0 24
102534: PUSH
102535: LD_VAR 0 6
102539: PUSH
102540: LD_INT 8
102542: ARRAY
102543: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
102544: LD_ADDR_VAR 0 25
102548: PUSH
102549: LD_VAR 0 6
102553: PUSH
102554: LD_INT 9
102556: ARRAY
102557: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
102558: LD_ADDR_VAR 0 26
102562: PUSH
102563: LD_VAR 0 6
102567: PUSH
102568: LD_INT 10
102570: ARRAY
102571: ST_TO_ADDR
// end else
102572: GO 102654
// begin f_ignore_area := false ;
102574: LD_ADDR_VAR 0 17
102578: PUSH
102579: LD_INT 0
102581: ST_TO_ADDR
// f_capture := false ;
102582: LD_ADDR_VAR 0 18
102586: PUSH
102587: LD_INT 0
102589: ST_TO_ADDR
// f_ignore_civ := false ;
102590: LD_ADDR_VAR 0 19
102594: PUSH
102595: LD_INT 0
102597: ST_TO_ADDR
// f_murder := false ;
102598: LD_ADDR_VAR 0 20
102602: PUSH
102603: LD_INT 0
102605: ST_TO_ADDR
// f_mines := false ;
102606: LD_ADDR_VAR 0 21
102610: PUSH
102611: LD_INT 0
102613: ST_TO_ADDR
// f_repair := false ;
102614: LD_ADDR_VAR 0 22
102618: PUSH
102619: LD_INT 0
102621: ST_TO_ADDR
// f_heal := false ;
102622: LD_ADDR_VAR 0 23
102626: PUSH
102627: LD_INT 0
102629: ST_TO_ADDR
// f_spacetime := false ;
102630: LD_ADDR_VAR 0 24
102634: PUSH
102635: LD_INT 0
102637: ST_TO_ADDR
// f_attack_depot := false ;
102638: LD_ADDR_VAR 0 25
102642: PUSH
102643: LD_INT 0
102645: ST_TO_ADDR
// f_crawl := false ;
102646: LD_ADDR_VAR 0 26
102650: PUSH
102651: LD_INT 0
102653: ST_TO_ADDR
// end ; if f_heal then
102654: LD_VAR 0 23
102658: IFFALSE 102685
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
102660: LD_ADDR_VAR 0 31
102664: PUSH
102665: LD_VAR 0 4
102669: PPUSH
102670: LD_INT 25
102672: PUSH
102673: LD_INT 4
102675: PUSH
102676: EMPTY
102677: LIST
102678: LIST
102679: PPUSH
102680: CALL_OW 72
102684: ST_TO_ADDR
// if f_repair then
102685: LD_VAR 0 22
102689: IFFALSE 102716
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
102691: LD_ADDR_VAR 0 33
102695: PUSH
102696: LD_VAR 0 4
102700: PPUSH
102701: LD_INT 25
102703: PUSH
102704: LD_INT 3
102706: PUSH
102707: EMPTY
102708: LIST
102709: LIST
102710: PPUSH
102711: CALL_OW 72
102715: ST_TO_ADDR
// units_path := [ ] ;
102716: LD_ADDR_VAR 0 16
102720: PUSH
102721: EMPTY
102722: ST_TO_ADDR
// for i = 1 to group do
102723: LD_ADDR_VAR 0 7
102727: PUSH
102728: DOUBLE
102729: LD_INT 1
102731: DEC
102732: ST_TO_ADDR
102733: LD_VAR 0 4
102737: PUSH
102738: FOR_TO
102739: IFFALSE 102768
// units_path := Replace ( units_path , i , path ) ;
102741: LD_ADDR_VAR 0 16
102745: PUSH
102746: LD_VAR 0 16
102750: PPUSH
102751: LD_VAR 0 7
102755: PPUSH
102756: LD_VAR 0 5
102760: PPUSH
102761: CALL_OW 1
102765: ST_TO_ADDR
102766: GO 102738
102768: POP
102769: POP
// repeat for i = group downto 1 do
102770: LD_ADDR_VAR 0 7
102774: PUSH
102775: DOUBLE
102776: LD_VAR 0 4
102780: INC
102781: ST_TO_ADDR
102782: LD_INT 1
102784: PUSH
102785: FOR_DOWNTO
102786: IFFALSE 106908
// begin wait ( 5 ) ;
102788: LD_INT 5
102790: PPUSH
102791: CALL_OW 67
// tmp := [ ] ;
102795: LD_ADDR_VAR 0 14
102799: PUSH
102800: EMPTY
102801: ST_TO_ADDR
// attacking := false ;
102802: LD_ADDR_VAR 0 29
102806: PUSH
102807: LD_INT 0
102809: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102810: LD_VAR 0 4
102814: PUSH
102815: LD_VAR 0 7
102819: ARRAY
102820: PPUSH
102821: CALL_OW 301
102825: PUSH
102826: LD_VAR 0 4
102830: PUSH
102831: LD_VAR 0 7
102835: ARRAY
102836: NOT
102837: OR
102838: IFFALSE 102947
// begin if GetType ( group [ i ] ) = unit_human then
102840: LD_VAR 0 4
102844: PUSH
102845: LD_VAR 0 7
102849: ARRAY
102850: PPUSH
102851: CALL_OW 247
102855: PUSH
102856: LD_INT 1
102858: EQUAL
102859: IFFALSE 102905
// begin to_heal := to_heal diff group [ i ] ;
102861: LD_ADDR_VAR 0 30
102865: PUSH
102866: LD_VAR 0 30
102870: PUSH
102871: LD_VAR 0 4
102875: PUSH
102876: LD_VAR 0 7
102880: ARRAY
102881: DIFF
102882: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102883: LD_ADDR_VAR 0 31
102887: PUSH
102888: LD_VAR 0 31
102892: PUSH
102893: LD_VAR 0 4
102897: PUSH
102898: LD_VAR 0 7
102902: ARRAY
102903: DIFF
102904: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102905: LD_ADDR_VAR 0 4
102909: PUSH
102910: LD_VAR 0 4
102914: PPUSH
102915: LD_VAR 0 7
102919: PPUSH
102920: CALL_OW 3
102924: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102925: LD_ADDR_VAR 0 16
102929: PUSH
102930: LD_VAR 0 16
102934: PPUSH
102935: LD_VAR 0 7
102939: PPUSH
102940: CALL_OW 3
102944: ST_TO_ADDR
// continue ;
102945: GO 102785
// end ; if f_repair then
102947: LD_VAR 0 22
102951: IFFALSE 103440
// begin if GetType ( group [ i ] ) = unit_vehicle then
102953: LD_VAR 0 4
102957: PUSH
102958: LD_VAR 0 7
102962: ARRAY
102963: PPUSH
102964: CALL_OW 247
102968: PUSH
102969: LD_INT 2
102971: EQUAL
102972: IFFALSE 103162
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102974: LD_VAR 0 4
102978: PUSH
102979: LD_VAR 0 7
102983: ARRAY
102984: PPUSH
102985: CALL_OW 256
102989: PUSH
102990: LD_INT 700
102992: LESS
102993: PUSH
102994: LD_VAR 0 4
102998: PUSH
102999: LD_VAR 0 7
103003: ARRAY
103004: PUSH
103005: LD_VAR 0 32
103009: IN
103010: NOT
103011: AND
103012: IFFALSE 103036
// to_repair := to_repair union group [ i ] ;
103014: LD_ADDR_VAR 0 32
103018: PUSH
103019: LD_VAR 0 32
103023: PUSH
103024: LD_VAR 0 4
103028: PUSH
103029: LD_VAR 0 7
103033: ARRAY
103034: UNION
103035: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
103036: LD_VAR 0 4
103040: PUSH
103041: LD_VAR 0 7
103045: ARRAY
103046: PPUSH
103047: CALL_OW 256
103051: PUSH
103052: LD_INT 1000
103054: EQUAL
103055: PUSH
103056: LD_VAR 0 4
103060: PUSH
103061: LD_VAR 0 7
103065: ARRAY
103066: PUSH
103067: LD_VAR 0 32
103071: IN
103072: AND
103073: IFFALSE 103097
// to_repair := to_repair diff group [ i ] ;
103075: LD_ADDR_VAR 0 32
103079: PUSH
103080: LD_VAR 0 32
103084: PUSH
103085: LD_VAR 0 4
103089: PUSH
103090: LD_VAR 0 7
103094: ARRAY
103095: DIFF
103096: ST_TO_ADDR
// if group [ i ] in to_repair then
103097: LD_VAR 0 4
103101: PUSH
103102: LD_VAR 0 7
103106: ARRAY
103107: PUSH
103108: LD_VAR 0 32
103112: IN
103113: IFFALSE 103160
// begin if not IsInArea ( group [ i ] , f_repair ) then
103115: LD_VAR 0 4
103119: PUSH
103120: LD_VAR 0 7
103124: ARRAY
103125: PPUSH
103126: LD_VAR 0 22
103130: PPUSH
103131: CALL_OW 308
103135: NOT
103136: IFFALSE 103158
// ComMoveToArea ( group [ i ] , f_repair ) ;
103138: LD_VAR 0 4
103142: PUSH
103143: LD_VAR 0 7
103147: ARRAY
103148: PPUSH
103149: LD_VAR 0 22
103153: PPUSH
103154: CALL_OW 113
// continue ;
103158: GO 102785
// end ; end else
103160: GO 103440
// if group [ i ] in repairs then
103162: LD_VAR 0 4
103166: PUSH
103167: LD_VAR 0 7
103171: ARRAY
103172: PUSH
103173: LD_VAR 0 33
103177: IN
103178: IFFALSE 103440
// begin if IsInUnit ( group [ i ] ) then
103180: LD_VAR 0 4
103184: PUSH
103185: LD_VAR 0 7
103189: ARRAY
103190: PPUSH
103191: CALL_OW 310
103195: IFFALSE 103263
// begin z := IsInUnit ( group [ i ] ) ;
103197: LD_ADDR_VAR 0 13
103201: PUSH
103202: LD_VAR 0 4
103206: PUSH
103207: LD_VAR 0 7
103211: ARRAY
103212: PPUSH
103213: CALL_OW 310
103217: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
103218: LD_VAR 0 13
103222: PUSH
103223: LD_VAR 0 32
103227: IN
103228: PUSH
103229: LD_VAR 0 13
103233: PPUSH
103234: LD_VAR 0 22
103238: PPUSH
103239: CALL_OW 308
103243: AND
103244: IFFALSE 103261
// ComExitVehicle ( group [ i ] ) ;
103246: LD_VAR 0 4
103250: PUSH
103251: LD_VAR 0 7
103255: ARRAY
103256: PPUSH
103257: CALL_OW 121
// end else
103261: GO 103440
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
103263: LD_ADDR_VAR 0 13
103267: PUSH
103268: LD_VAR 0 4
103272: PPUSH
103273: LD_INT 95
103275: PUSH
103276: LD_VAR 0 22
103280: PUSH
103281: EMPTY
103282: LIST
103283: LIST
103284: PUSH
103285: LD_INT 58
103287: PUSH
103288: EMPTY
103289: LIST
103290: PUSH
103291: EMPTY
103292: LIST
103293: LIST
103294: PPUSH
103295: CALL_OW 72
103299: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
103300: LD_VAR 0 4
103304: PUSH
103305: LD_VAR 0 7
103309: ARRAY
103310: PPUSH
103311: CALL_OW 314
103315: NOT
103316: IFFALSE 103438
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
103318: LD_ADDR_VAR 0 10
103322: PUSH
103323: LD_VAR 0 13
103327: PPUSH
103328: LD_VAR 0 4
103332: PUSH
103333: LD_VAR 0 7
103337: ARRAY
103338: PPUSH
103339: CALL_OW 74
103343: ST_TO_ADDR
// if not x then
103344: LD_VAR 0 10
103348: NOT
103349: IFFALSE 103353
// continue ;
103351: GO 102785
// if GetLives ( x ) < 1000 then
103353: LD_VAR 0 10
103357: PPUSH
103358: CALL_OW 256
103362: PUSH
103363: LD_INT 1000
103365: LESS
103366: IFFALSE 103390
// ComRepairVehicle ( group [ i ] , x ) else
103368: LD_VAR 0 4
103372: PUSH
103373: LD_VAR 0 7
103377: ARRAY
103378: PPUSH
103379: LD_VAR 0 10
103383: PPUSH
103384: CALL_OW 129
103388: GO 103438
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
103390: LD_VAR 0 23
103394: PUSH
103395: LD_VAR 0 4
103399: PUSH
103400: LD_VAR 0 7
103404: ARRAY
103405: PPUSH
103406: CALL_OW 256
103410: PUSH
103411: LD_INT 1000
103413: LESS
103414: AND
103415: NOT
103416: IFFALSE 103438
// ComEnterUnit ( group [ i ] , x ) ;
103418: LD_VAR 0 4
103422: PUSH
103423: LD_VAR 0 7
103427: ARRAY
103428: PPUSH
103429: LD_VAR 0 10
103433: PPUSH
103434: CALL_OW 120
// end ; continue ;
103438: GO 102785
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
103440: LD_VAR 0 23
103444: PUSH
103445: LD_VAR 0 4
103449: PUSH
103450: LD_VAR 0 7
103454: ARRAY
103455: PPUSH
103456: CALL_OW 247
103460: PUSH
103461: LD_INT 1
103463: EQUAL
103464: AND
103465: IFFALSE 103943
// begin if group [ i ] in healers then
103467: LD_VAR 0 4
103471: PUSH
103472: LD_VAR 0 7
103476: ARRAY
103477: PUSH
103478: LD_VAR 0 31
103482: IN
103483: IFFALSE 103756
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
103485: LD_VAR 0 4
103489: PUSH
103490: LD_VAR 0 7
103494: ARRAY
103495: PPUSH
103496: LD_VAR 0 23
103500: PPUSH
103501: CALL_OW 308
103505: NOT
103506: PUSH
103507: LD_VAR 0 4
103511: PUSH
103512: LD_VAR 0 7
103516: ARRAY
103517: PPUSH
103518: CALL_OW 314
103522: NOT
103523: AND
103524: IFFALSE 103548
// ComMoveToArea ( group [ i ] , f_heal ) else
103526: LD_VAR 0 4
103530: PUSH
103531: LD_VAR 0 7
103535: ARRAY
103536: PPUSH
103537: LD_VAR 0 23
103541: PPUSH
103542: CALL_OW 113
103546: GO 103754
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
103548: LD_VAR 0 4
103552: PUSH
103553: LD_VAR 0 7
103557: ARRAY
103558: PPUSH
103559: CALL 81197 0 1
103563: PPUSH
103564: CALL_OW 256
103568: PUSH
103569: LD_INT 1000
103571: EQUAL
103572: IFFALSE 103591
// ComStop ( group [ i ] ) else
103574: LD_VAR 0 4
103578: PUSH
103579: LD_VAR 0 7
103583: ARRAY
103584: PPUSH
103585: CALL_OW 141
103589: GO 103754
// if not HasTask ( group [ i ] ) and to_heal then
103591: LD_VAR 0 4
103595: PUSH
103596: LD_VAR 0 7
103600: ARRAY
103601: PPUSH
103602: CALL_OW 314
103606: NOT
103607: PUSH
103608: LD_VAR 0 30
103612: AND
103613: IFFALSE 103754
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
103615: LD_ADDR_VAR 0 13
103619: PUSH
103620: LD_VAR 0 30
103624: PPUSH
103625: LD_INT 3
103627: PUSH
103628: LD_INT 54
103630: PUSH
103631: EMPTY
103632: LIST
103633: PUSH
103634: EMPTY
103635: LIST
103636: LIST
103637: PPUSH
103638: CALL_OW 72
103642: PPUSH
103643: LD_VAR 0 4
103647: PUSH
103648: LD_VAR 0 7
103652: ARRAY
103653: PPUSH
103654: CALL_OW 74
103658: ST_TO_ADDR
// if z then
103659: LD_VAR 0 13
103663: IFFALSE 103754
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
103665: LD_INT 91
103667: PUSH
103668: LD_VAR 0 13
103672: PUSH
103673: LD_INT 10
103675: PUSH
103676: EMPTY
103677: LIST
103678: LIST
103679: LIST
103680: PUSH
103681: LD_INT 81
103683: PUSH
103684: LD_VAR 0 13
103688: PPUSH
103689: CALL_OW 255
103693: PUSH
103694: EMPTY
103695: LIST
103696: LIST
103697: PUSH
103698: EMPTY
103699: LIST
103700: LIST
103701: PPUSH
103702: CALL_OW 69
103706: PUSH
103707: LD_INT 0
103709: EQUAL
103710: IFFALSE 103734
// ComHeal ( group [ i ] , z ) else
103712: LD_VAR 0 4
103716: PUSH
103717: LD_VAR 0 7
103721: ARRAY
103722: PPUSH
103723: LD_VAR 0 13
103727: PPUSH
103728: CALL_OW 128
103732: GO 103754
// ComMoveToArea ( group [ i ] , f_heal ) ;
103734: LD_VAR 0 4
103738: PUSH
103739: LD_VAR 0 7
103743: ARRAY
103744: PPUSH
103745: LD_VAR 0 23
103749: PPUSH
103750: CALL_OW 113
// end ; continue ;
103754: GO 102785
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103756: LD_VAR 0 4
103760: PUSH
103761: LD_VAR 0 7
103765: ARRAY
103766: PPUSH
103767: CALL_OW 256
103771: PUSH
103772: LD_INT 700
103774: LESS
103775: PUSH
103776: LD_VAR 0 4
103780: PUSH
103781: LD_VAR 0 7
103785: ARRAY
103786: PUSH
103787: LD_VAR 0 30
103791: IN
103792: NOT
103793: AND
103794: IFFALSE 103818
// to_heal := to_heal union group [ i ] ;
103796: LD_ADDR_VAR 0 30
103800: PUSH
103801: LD_VAR 0 30
103805: PUSH
103806: LD_VAR 0 4
103810: PUSH
103811: LD_VAR 0 7
103815: ARRAY
103816: UNION
103817: ST_TO_ADDR
// if group [ i ] in to_heal then
103818: LD_VAR 0 4
103822: PUSH
103823: LD_VAR 0 7
103827: ARRAY
103828: PUSH
103829: LD_VAR 0 30
103833: IN
103834: IFFALSE 103943
// begin if GetLives ( group [ i ] ) = 1000 then
103836: LD_VAR 0 4
103840: PUSH
103841: LD_VAR 0 7
103845: ARRAY
103846: PPUSH
103847: CALL_OW 256
103851: PUSH
103852: LD_INT 1000
103854: EQUAL
103855: IFFALSE 103881
// to_heal := to_heal diff group [ i ] else
103857: LD_ADDR_VAR 0 30
103861: PUSH
103862: LD_VAR 0 30
103866: PUSH
103867: LD_VAR 0 4
103871: PUSH
103872: LD_VAR 0 7
103876: ARRAY
103877: DIFF
103878: ST_TO_ADDR
103879: GO 103943
// begin if not IsInArea ( group [ i ] , to_heal ) then
103881: LD_VAR 0 4
103885: PUSH
103886: LD_VAR 0 7
103890: ARRAY
103891: PPUSH
103892: LD_VAR 0 30
103896: PPUSH
103897: CALL_OW 308
103901: NOT
103902: IFFALSE 103926
// ComMoveToArea ( group [ i ] , f_heal ) else
103904: LD_VAR 0 4
103908: PUSH
103909: LD_VAR 0 7
103913: ARRAY
103914: PPUSH
103915: LD_VAR 0 23
103919: PPUSH
103920: CALL_OW 113
103924: GO 103941
// ComHold ( group [ i ] ) ;
103926: LD_VAR 0 4
103930: PUSH
103931: LD_VAR 0 7
103935: ARRAY
103936: PPUSH
103937: CALL_OW 140
// continue ;
103941: GO 102785
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103943: LD_VAR 0 4
103947: PUSH
103948: LD_VAR 0 7
103952: ARRAY
103953: PPUSH
103954: LD_INT 10
103956: PPUSH
103957: CALL 79617 0 2
103961: NOT
103962: PUSH
103963: LD_VAR 0 16
103967: PUSH
103968: LD_VAR 0 7
103972: ARRAY
103973: PUSH
103974: EMPTY
103975: EQUAL
103976: NOT
103977: AND
103978: IFFALSE 104244
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103980: LD_VAR 0 4
103984: PUSH
103985: LD_VAR 0 7
103989: ARRAY
103990: PPUSH
103991: CALL_OW 262
103995: PUSH
103996: LD_INT 1
103998: PUSH
103999: LD_INT 2
104001: PUSH
104002: EMPTY
104003: LIST
104004: LIST
104005: IN
104006: IFFALSE 104047
// if GetFuel ( group [ i ] ) < 10 then
104008: LD_VAR 0 4
104012: PUSH
104013: LD_VAR 0 7
104017: ARRAY
104018: PPUSH
104019: CALL_OW 261
104023: PUSH
104024: LD_INT 10
104026: LESS
104027: IFFALSE 104047
// SetFuel ( group [ i ] , 12 ) ;
104029: LD_VAR 0 4
104033: PUSH
104034: LD_VAR 0 7
104038: ARRAY
104039: PPUSH
104040: LD_INT 12
104042: PPUSH
104043: CALL_OW 240
// if units_path [ i ] then
104047: LD_VAR 0 16
104051: PUSH
104052: LD_VAR 0 7
104056: ARRAY
104057: IFFALSE 104242
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
104059: LD_VAR 0 4
104063: PUSH
104064: LD_VAR 0 7
104068: ARRAY
104069: PPUSH
104070: LD_VAR 0 16
104074: PUSH
104075: LD_VAR 0 7
104079: ARRAY
104080: PUSH
104081: LD_INT 1
104083: ARRAY
104084: PUSH
104085: LD_INT 1
104087: ARRAY
104088: PPUSH
104089: LD_VAR 0 16
104093: PUSH
104094: LD_VAR 0 7
104098: ARRAY
104099: PUSH
104100: LD_INT 1
104102: ARRAY
104103: PUSH
104104: LD_INT 2
104106: ARRAY
104107: PPUSH
104108: CALL_OW 297
104112: PUSH
104113: LD_INT 6
104115: GREATER
104116: IFFALSE 104191
// begin if not HasTask ( group [ i ] ) then
104118: LD_VAR 0 4
104122: PUSH
104123: LD_VAR 0 7
104127: ARRAY
104128: PPUSH
104129: CALL_OW 314
104133: NOT
104134: IFFALSE 104189
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
104136: LD_VAR 0 4
104140: PUSH
104141: LD_VAR 0 7
104145: ARRAY
104146: PPUSH
104147: LD_VAR 0 16
104151: PUSH
104152: LD_VAR 0 7
104156: ARRAY
104157: PUSH
104158: LD_INT 1
104160: ARRAY
104161: PUSH
104162: LD_INT 1
104164: ARRAY
104165: PPUSH
104166: LD_VAR 0 16
104170: PUSH
104171: LD_VAR 0 7
104175: ARRAY
104176: PUSH
104177: LD_INT 1
104179: ARRAY
104180: PUSH
104181: LD_INT 2
104183: ARRAY
104184: PPUSH
104185: CALL_OW 114
// end else
104189: GO 104242
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
104191: LD_ADDR_VAR 0 15
104195: PUSH
104196: LD_VAR 0 16
104200: PUSH
104201: LD_VAR 0 7
104205: ARRAY
104206: PPUSH
104207: LD_INT 1
104209: PPUSH
104210: CALL_OW 3
104214: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
104215: LD_ADDR_VAR 0 16
104219: PUSH
104220: LD_VAR 0 16
104224: PPUSH
104225: LD_VAR 0 7
104229: PPUSH
104230: LD_VAR 0 15
104234: PPUSH
104235: CALL_OW 1
104239: ST_TO_ADDR
// continue ;
104240: GO 102785
// end ; end ; end else
104242: GO 106906
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
104244: LD_ADDR_VAR 0 14
104248: PUSH
104249: LD_INT 81
104251: PUSH
104252: LD_VAR 0 4
104256: PUSH
104257: LD_VAR 0 7
104261: ARRAY
104262: PPUSH
104263: CALL_OW 255
104267: PUSH
104268: EMPTY
104269: LIST
104270: LIST
104271: PPUSH
104272: CALL_OW 69
104276: ST_TO_ADDR
// if not tmp then
104277: LD_VAR 0 14
104281: NOT
104282: IFFALSE 104286
// continue ;
104284: GO 102785
// if f_ignore_area then
104286: LD_VAR 0 17
104290: IFFALSE 104378
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
104292: LD_ADDR_VAR 0 15
104296: PUSH
104297: LD_VAR 0 14
104301: PPUSH
104302: LD_INT 3
104304: PUSH
104305: LD_INT 92
104307: PUSH
104308: LD_VAR 0 17
104312: PUSH
104313: LD_INT 1
104315: ARRAY
104316: PUSH
104317: LD_VAR 0 17
104321: PUSH
104322: LD_INT 2
104324: ARRAY
104325: PUSH
104326: LD_VAR 0 17
104330: PUSH
104331: LD_INT 3
104333: ARRAY
104334: PUSH
104335: EMPTY
104336: LIST
104337: LIST
104338: LIST
104339: LIST
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: PPUSH
104345: CALL_OW 72
104349: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104350: LD_VAR 0 14
104354: PUSH
104355: LD_VAR 0 15
104359: DIFF
104360: IFFALSE 104378
// tmp := tmp diff tmp2 ;
104362: LD_ADDR_VAR 0 14
104366: PUSH
104367: LD_VAR 0 14
104371: PUSH
104372: LD_VAR 0 15
104376: DIFF
104377: ST_TO_ADDR
// end ; if not f_murder then
104378: LD_VAR 0 20
104382: NOT
104383: IFFALSE 104441
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
104385: LD_ADDR_VAR 0 15
104389: PUSH
104390: LD_VAR 0 14
104394: PPUSH
104395: LD_INT 3
104397: PUSH
104398: LD_INT 50
104400: PUSH
104401: EMPTY
104402: LIST
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PPUSH
104408: CALL_OW 72
104412: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104413: LD_VAR 0 14
104417: PUSH
104418: LD_VAR 0 15
104422: DIFF
104423: IFFALSE 104441
// tmp := tmp diff tmp2 ;
104425: LD_ADDR_VAR 0 14
104429: PUSH
104430: LD_VAR 0 14
104434: PUSH
104435: LD_VAR 0 15
104439: DIFF
104440: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
104441: LD_ADDR_VAR 0 14
104445: PUSH
104446: LD_VAR 0 4
104450: PUSH
104451: LD_VAR 0 7
104455: ARRAY
104456: PPUSH
104457: LD_VAR 0 14
104461: PPUSH
104462: LD_INT 1
104464: PPUSH
104465: LD_INT 1
104467: PPUSH
104468: CALL 53260 0 4
104472: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
104473: LD_VAR 0 4
104477: PUSH
104478: LD_VAR 0 7
104482: ARRAY
104483: PPUSH
104484: CALL_OW 257
104488: PUSH
104489: LD_INT 1
104491: EQUAL
104492: IFFALSE 104940
// begin if WantPlant ( group [ i ] ) then
104494: LD_VAR 0 4
104498: PUSH
104499: LD_VAR 0 7
104503: ARRAY
104504: PPUSH
104505: CALL 52761 0 1
104509: IFFALSE 104513
// continue ;
104511: GO 102785
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
104513: LD_VAR 0 18
104517: PUSH
104518: LD_VAR 0 4
104522: PUSH
104523: LD_VAR 0 7
104527: ARRAY
104528: PPUSH
104529: CALL_OW 310
104533: NOT
104534: AND
104535: PUSH
104536: LD_VAR 0 14
104540: PUSH
104541: LD_INT 1
104543: ARRAY
104544: PUSH
104545: LD_VAR 0 14
104549: PPUSH
104550: LD_INT 21
104552: PUSH
104553: LD_INT 2
104555: PUSH
104556: EMPTY
104557: LIST
104558: LIST
104559: PUSH
104560: LD_INT 58
104562: PUSH
104563: EMPTY
104564: LIST
104565: PUSH
104566: EMPTY
104567: LIST
104568: LIST
104569: PPUSH
104570: CALL_OW 72
104574: IN
104575: AND
104576: IFFALSE 104612
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
104578: LD_VAR 0 4
104582: PUSH
104583: LD_VAR 0 7
104587: ARRAY
104588: PPUSH
104589: LD_VAR 0 14
104593: PUSH
104594: LD_INT 1
104596: ARRAY
104597: PPUSH
104598: CALL_OW 120
// attacking := true ;
104602: LD_ADDR_VAR 0 29
104606: PUSH
104607: LD_INT 1
104609: ST_TO_ADDR
// continue ;
104610: GO 102785
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
104612: LD_VAR 0 26
104616: PUSH
104617: LD_VAR 0 4
104621: PUSH
104622: LD_VAR 0 7
104626: ARRAY
104627: PPUSH
104628: CALL_OW 257
104632: PUSH
104633: LD_INT 1
104635: EQUAL
104636: AND
104637: PUSH
104638: LD_VAR 0 4
104642: PUSH
104643: LD_VAR 0 7
104647: ARRAY
104648: PPUSH
104649: CALL_OW 256
104653: PUSH
104654: LD_INT 800
104656: LESS
104657: AND
104658: PUSH
104659: LD_VAR 0 4
104663: PUSH
104664: LD_VAR 0 7
104668: ARRAY
104669: PPUSH
104670: CALL_OW 318
104674: NOT
104675: AND
104676: IFFALSE 104693
// ComCrawl ( group [ i ] ) ;
104678: LD_VAR 0 4
104682: PUSH
104683: LD_VAR 0 7
104687: ARRAY
104688: PPUSH
104689: CALL_OW 137
// if f_mines then
104693: LD_VAR 0 21
104697: IFFALSE 104940
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
104699: LD_VAR 0 14
104703: PUSH
104704: LD_INT 1
104706: ARRAY
104707: PPUSH
104708: CALL_OW 247
104712: PUSH
104713: LD_INT 3
104715: EQUAL
104716: PUSH
104717: LD_VAR 0 14
104721: PUSH
104722: LD_INT 1
104724: ARRAY
104725: PUSH
104726: LD_VAR 0 27
104730: IN
104731: NOT
104732: AND
104733: IFFALSE 104940
// begin x := GetX ( tmp [ 1 ] ) ;
104735: LD_ADDR_VAR 0 10
104739: PUSH
104740: LD_VAR 0 14
104744: PUSH
104745: LD_INT 1
104747: ARRAY
104748: PPUSH
104749: CALL_OW 250
104753: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104754: LD_ADDR_VAR 0 11
104758: PUSH
104759: LD_VAR 0 14
104763: PUSH
104764: LD_INT 1
104766: ARRAY
104767: PPUSH
104768: CALL_OW 251
104772: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104773: LD_ADDR_VAR 0 12
104777: PUSH
104778: LD_VAR 0 4
104782: PUSH
104783: LD_VAR 0 7
104787: ARRAY
104788: PPUSH
104789: CALL 79702 0 1
104793: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104794: LD_VAR 0 4
104798: PUSH
104799: LD_VAR 0 7
104803: ARRAY
104804: PPUSH
104805: LD_VAR 0 10
104809: PPUSH
104810: LD_VAR 0 11
104814: PPUSH
104815: LD_VAR 0 14
104819: PUSH
104820: LD_INT 1
104822: ARRAY
104823: PPUSH
104824: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104828: LD_VAR 0 4
104832: PUSH
104833: LD_VAR 0 7
104837: ARRAY
104838: PPUSH
104839: LD_VAR 0 10
104843: PPUSH
104844: LD_VAR 0 12
104848: PPUSH
104849: LD_INT 7
104851: PPUSH
104852: CALL_OW 272
104856: PPUSH
104857: LD_VAR 0 11
104861: PPUSH
104862: LD_VAR 0 12
104866: PPUSH
104867: LD_INT 7
104869: PPUSH
104870: CALL_OW 273
104874: PPUSH
104875: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104879: LD_VAR 0 4
104883: PUSH
104884: LD_VAR 0 7
104888: ARRAY
104889: PPUSH
104890: LD_INT 71
104892: PPUSH
104893: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104897: LD_ADDR_VAR 0 27
104901: PUSH
104902: LD_VAR 0 27
104906: PPUSH
104907: LD_VAR 0 27
104911: PUSH
104912: LD_INT 1
104914: PLUS
104915: PPUSH
104916: LD_VAR 0 14
104920: PUSH
104921: LD_INT 1
104923: ARRAY
104924: PPUSH
104925: CALL_OW 1
104929: ST_TO_ADDR
// attacking := true ;
104930: LD_ADDR_VAR 0 29
104934: PUSH
104935: LD_INT 1
104937: ST_TO_ADDR
// continue ;
104938: GO 102785
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104940: LD_VAR 0 4
104944: PUSH
104945: LD_VAR 0 7
104949: ARRAY
104950: PPUSH
104951: CALL_OW 257
104955: PUSH
104956: LD_INT 17
104958: EQUAL
104959: PUSH
104960: LD_VAR 0 4
104964: PUSH
104965: LD_VAR 0 7
104969: ARRAY
104970: PPUSH
104971: CALL_OW 110
104975: PUSH
104976: LD_INT 71
104978: EQUAL
104979: NOT
104980: AND
104981: IFFALSE 105127
// begin attacking := false ;
104983: LD_ADDR_VAR 0 29
104987: PUSH
104988: LD_INT 0
104990: ST_TO_ADDR
// k := 5 ;
104991: LD_ADDR_VAR 0 9
104995: PUSH
104996: LD_INT 5
104998: ST_TO_ADDR
// if tmp < k then
104999: LD_VAR 0 14
105003: PUSH
105004: LD_VAR 0 9
105008: LESS
105009: IFFALSE 105021
// k := tmp ;
105011: LD_ADDR_VAR 0 9
105015: PUSH
105016: LD_VAR 0 14
105020: ST_TO_ADDR
// for j = 1 to k do
105021: LD_ADDR_VAR 0 8
105025: PUSH
105026: DOUBLE
105027: LD_INT 1
105029: DEC
105030: ST_TO_ADDR
105031: LD_VAR 0 9
105035: PUSH
105036: FOR_TO
105037: IFFALSE 105125
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
105039: LD_VAR 0 14
105043: PUSH
105044: LD_VAR 0 8
105048: ARRAY
105049: PUSH
105050: LD_VAR 0 14
105054: PPUSH
105055: LD_INT 58
105057: PUSH
105058: EMPTY
105059: LIST
105060: PPUSH
105061: CALL_OW 72
105065: IN
105066: NOT
105067: IFFALSE 105123
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105069: LD_VAR 0 4
105073: PUSH
105074: LD_VAR 0 7
105078: ARRAY
105079: PPUSH
105080: LD_VAR 0 14
105084: PUSH
105085: LD_VAR 0 8
105089: ARRAY
105090: PPUSH
105091: CALL_OW 115
// attacking := true ;
105095: LD_ADDR_VAR 0 29
105099: PUSH
105100: LD_INT 1
105102: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
105103: LD_VAR 0 4
105107: PUSH
105108: LD_VAR 0 7
105112: ARRAY
105113: PPUSH
105114: LD_INT 71
105116: PPUSH
105117: CALL_OW 109
// continue ;
105121: GO 105036
// end ; end ;
105123: GO 105036
105125: POP
105126: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
105127: LD_VAR 0 4
105131: PUSH
105132: LD_VAR 0 7
105136: ARRAY
105137: PPUSH
105138: CALL_OW 257
105142: PUSH
105143: LD_INT 8
105145: EQUAL
105146: PUSH
105147: LD_VAR 0 4
105151: PUSH
105152: LD_VAR 0 7
105156: ARRAY
105157: PPUSH
105158: CALL_OW 264
105162: PUSH
105163: LD_INT 28
105165: PUSH
105166: LD_INT 45
105168: PUSH
105169: LD_INT 7
105171: PUSH
105172: LD_INT 47
105174: PUSH
105175: EMPTY
105176: LIST
105177: LIST
105178: LIST
105179: LIST
105180: IN
105181: OR
105182: IFFALSE 105438
// begin attacking := false ;
105184: LD_ADDR_VAR 0 29
105188: PUSH
105189: LD_INT 0
105191: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
105192: LD_VAR 0 14
105196: PUSH
105197: LD_INT 1
105199: ARRAY
105200: PPUSH
105201: CALL_OW 266
105205: PUSH
105206: LD_INT 32
105208: PUSH
105209: LD_INT 31
105211: PUSH
105212: LD_INT 33
105214: PUSH
105215: LD_INT 4
105217: PUSH
105218: LD_INT 5
105220: PUSH
105221: EMPTY
105222: LIST
105223: LIST
105224: LIST
105225: LIST
105226: LIST
105227: IN
105228: IFFALSE 105414
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
105230: LD_ADDR_VAR 0 9
105234: PUSH
105235: LD_VAR 0 14
105239: PUSH
105240: LD_INT 1
105242: ARRAY
105243: PPUSH
105244: CALL_OW 266
105248: PPUSH
105249: LD_VAR 0 14
105253: PUSH
105254: LD_INT 1
105256: ARRAY
105257: PPUSH
105258: CALL_OW 250
105262: PPUSH
105263: LD_VAR 0 14
105267: PUSH
105268: LD_INT 1
105270: ARRAY
105271: PPUSH
105272: CALL_OW 251
105276: PPUSH
105277: LD_VAR 0 14
105281: PUSH
105282: LD_INT 1
105284: ARRAY
105285: PPUSH
105286: CALL_OW 254
105290: PPUSH
105291: LD_VAR 0 14
105295: PUSH
105296: LD_INT 1
105298: ARRAY
105299: PPUSH
105300: CALL_OW 248
105304: PPUSH
105305: LD_INT 0
105307: PPUSH
105308: CALL 61072 0 6
105312: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
105313: LD_ADDR_VAR 0 8
105317: PUSH
105318: LD_VAR 0 4
105322: PUSH
105323: LD_VAR 0 7
105327: ARRAY
105328: PPUSH
105329: LD_VAR 0 9
105333: PPUSH
105334: CALL 79742 0 2
105338: ST_TO_ADDR
// if j then
105339: LD_VAR 0 8
105343: IFFALSE 105412
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
105345: LD_VAR 0 8
105349: PUSH
105350: LD_INT 1
105352: ARRAY
105353: PPUSH
105354: LD_VAR 0 8
105358: PUSH
105359: LD_INT 2
105361: ARRAY
105362: PPUSH
105363: CALL_OW 488
105367: IFFALSE 105412
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
105369: LD_VAR 0 4
105373: PUSH
105374: LD_VAR 0 7
105378: ARRAY
105379: PPUSH
105380: LD_VAR 0 8
105384: PUSH
105385: LD_INT 1
105387: ARRAY
105388: PPUSH
105389: LD_VAR 0 8
105393: PUSH
105394: LD_INT 2
105396: ARRAY
105397: PPUSH
105398: CALL_OW 116
// attacking := true ;
105402: LD_ADDR_VAR 0 29
105406: PUSH
105407: LD_INT 1
105409: ST_TO_ADDR
// continue ;
105410: GO 102785
// end ; end else
105412: GO 105438
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105414: LD_VAR 0 4
105418: PUSH
105419: LD_VAR 0 7
105423: ARRAY
105424: PPUSH
105425: LD_VAR 0 14
105429: PUSH
105430: LD_INT 1
105432: ARRAY
105433: PPUSH
105434: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
105438: LD_VAR 0 4
105442: PUSH
105443: LD_VAR 0 7
105447: ARRAY
105448: PPUSH
105449: CALL_OW 265
105453: PUSH
105454: LD_INT 11
105456: EQUAL
105457: IFFALSE 105735
// begin k := 10 ;
105459: LD_ADDR_VAR 0 9
105463: PUSH
105464: LD_INT 10
105466: ST_TO_ADDR
// x := 0 ;
105467: LD_ADDR_VAR 0 10
105471: PUSH
105472: LD_INT 0
105474: ST_TO_ADDR
// if tmp < k then
105475: LD_VAR 0 14
105479: PUSH
105480: LD_VAR 0 9
105484: LESS
105485: IFFALSE 105497
// k := tmp ;
105487: LD_ADDR_VAR 0 9
105491: PUSH
105492: LD_VAR 0 14
105496: ST_TO_ADDR
// for j = k downto 1 do
105497: LD_ADDR_VAR 0 8
105501: PUSH
105502: DOUBLE
105503: LD_VAR 0 9
105507: INC
105508: ST_TO_ADDR
105509: LD_INT 1
105511: PUSH
105512: FOR_DOWNTO
105513: IFFALSE 105588
// begin if GetType ( tmp [ j ] ) = unit_human then
105515: LD_VAR 0 14
105519: PUSH
105520: LD_VAR 0 8
105524: ARRAY
105525: PPUSH
105526: CALL_OW 247
105530: PUSH
105531: LD_INT 1
105533: EQUAL
105534: IFFALSE 105586
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
105536: LD_VAR 0 4
105540: PUSH
105541: LD_VAR 0 7
105545: ARRAY
105546: PPUSH
105547: LD_VAR 0 14
105551: PUSH
105552: LD_VAR 0 8
105556: ARRAY
105557: PPUSH
105558: CALL 80013 0 2
// x := tmp [ j ] ;
105562: LD_ADDR_VAR 0 10
105566: PUSH
105567: LD_VAR 0 14
105571: PUSH
105572: LD_VAR 0 8
105576: ARRAY
105577: ST_TO_ADDR
// attacking := true ;
105578: LD_ADDR_VAR 0 29
105582: PUSH
105583: LD_INT 1
105585: ST_TO_ADDR
// end ; end ;
105586: GO 105512
105588: POP
105589: POP
// if not x then
105590: LD_VAR 0 10
105594: NOT
105595: IFFALSE 105735
// begin attacking := true ;
105597: LD_ADDR_VAR 0 29
105601: PUSH
105602: LD_INT 1
105604: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
105605: LD_VAR 0 4
105609: PUSH
105610: LD_VAR 0 7
105614: ARRAY
105615: PPUSH
105616: CALL_OW 250
105620: PPUSH
105621: LD_VAR 0 4
105625: PUSH
105626: LD_VAR 0 7
105630: ARRAY
105631: PPUSH
105632: CALL_OW 251
105636: PPUSH
105637: CALL_OW 546
105641: PUSH
105642: LD_INT 2
105644: ARRAY
105645: PUSH
105646: LD_VAR 0 14
105650: PUSH
105651: LD_INT 1
105653: ARRAY
105654: PPUSH
105655: CALL_OW 250
105659: PPUSH
105660: LD_VAR 0 14
105664: PUSH
105665: LD_INT 1
105667: ARRAY
105668: PPUSH
105669: CALL_OW 251
105673: PPUSH
105674: CALL_OW 546
105678: PUSH
105679: LD_INT 2
105681: ARRAY
105682: EQUAL
105683: IFFALSE 105711
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
105685: LD_VAR 0 4
105689: PUSH
105690: LD_VAR 0 7
105694: ARRAY
105695: PPUSH
105696: LD_VAR 0 14
105700: PUSH
105701: LD_INT 1
105703: ARRAY
105704: PPUSH
105705: CALL 80013 0 2
105709: GO 105735
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105711: LD_VAR 0 4
105715: PUSH
105716: LD_VAR 0 7
105720: ARRAY
105721: PPUSH
105722: LD_VAR 0 14
105726: PUSH
105727: LD_INT 1
105729: ARRAY
105730: PPUSH
105731: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
105735: LD_VAR 0 4
105739: PUSH
105740: LD_VAR 0 7
105744: ARRAY
105745: PPUSH
105746: CALL_OW 264
105750: PUSH
105751: LD_INT 29
105753: EQUAL
105754: IFFALSE 106120
// begin if WantsToAttack ( group [ i ] ) in bombed then
105756: LD_VAR 0 4
105760: PUSH
105761: LD_VAR 0 7
105765: ARRAY
105766: PPUSH
105767: CALL_OW 319
105771: PUSH
105772: LD_VAR 0 28
105776: IN
105777: IFFALSE 105781
// continue ;
105779: GO 102785
// k := 8 ;
105781: LD_ADDR_VAR 0 9
105785: PUSH
105786: LD_INT 8
105788: ST_TO_ADDR
// x := 0 ;
105789: LD_ADDR_VAR 0 10
105793: PUSH
105794: LD_INT 0
105796: ST_TO_ADDR
// if tmp < k then
105797: LD_VAR 0 14
105801: PUSH
105802: LD_VAR 0 9
105806: LESS
105807: IFFALSE 105819
// k := tmp ;
105809: LD_ADDR_VAR 0 9
105813: PUSH
105814: LD_VAR 0 14
105818: ST_TO_ADDR
// for j = 1 to k do
105819: LD_ADDR_VAR 0 8
105823: PUSH
105824: DOUBLE
105825: LD_INT 1
105827: DEC
105828: ST_TO_ADDR
105829: LD_VAR 0 9
105833: PUSH
105834: FOR_TO
105835: IFFALSE 105967
// begin if GetType ( tmp [ j ] ) = unit_building then
105837: LD_VAR 0 14
105841: PUSH
105842: LD_VAR 0 8
105846: ARRAY
105847: PPUSH
105848: CALL_OW 247
105852: PUSH
105853: LD_INT 3
105855: EQUAL
105856: IFFALSE 105965
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105858: LD_VAR 0 14
105862: PUSH
105863: LD_VAR 0 8
105867: ARRAY
105868: PUSH
105869: LD_VAR 0 28
105873: IN
105874: NOT
105875: PUSH
105876: LD_VAR 0 14
105880: PUSH
105881: LD_VAR 0 8
105885: ARRAY
105886: PPUSH
105887: CALL_OW 313
105891: AND
105892: IFFALSE 105965
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105894: LD_VAR 0 4
105898: PUSH
105899: LD_VAR 0 7
105903: ARRAY
105904: PPUSH
105905: LD_VAR 0 14
105909: PUSH
105910: LD_VAR 0 8
105914: ARRAY
105915: PPUSH
105916: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105920: LD_ADDR_VAR 0 28
105924: PUSH
105925: LD_VAR 0 28
105929: PPUSH
105930: LD_VAR 0 28
105934: PUSH
105935: LD_INT 1
105937: PLUS
105938: PPUSH
105939: LD_VAR 0 14
105943: PUSH
105944: LD_VAR 0 8
105948: ARRAY
105949: PPUSH
105950: CALL_OW 1
105954: ST_TO_ADDR
// attacking := true ;
105955: LD_ADDR_VAR 0 29
105959: PUSH
105960: LD_INT 1
105962: ST_TO_ADDR
// break ;
105963: GO 105967
// end ; end ;
105965: GO 105834
105967: POP
105968: POP
// if not attacking and f_attack_depot then
105969: LD_VAR 0 29
105973: NOT
105974: PUSH
105975: LD_VAR 0 25
105979: AND
105980: IFFALSE 106075
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105982: LD_ADDR_VAR 0 13
105986: PUSH
105987: LD_VAR 0 14
105991: PPUSH
105992: LD_INT 2
105994: PUSH
105995: LD_INT 30
105997: PUSH
105998: LD_INT 0
106000: PUSH
106001: EMPTY
106002: LIST
106003: LIST
106004: PUSH
106005: LD_INT 30
106007: PUSH
106008: LD_INT 1
106010: PUSH
106011: EMPTY
106012: LIST
106013: LIST
106014: PUSH
106015: EMPTY
106016: LIST
106017: LIST
106018: LIST
106019: PPUSH
106020: CALL_OW 72
106024: ST_TO_ADDR
// if z then
106025: LD_VAR 0 13
106029: IFFALSE 106075
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
106031: LD_VAR 0 4
106035: PUSH
106036: LD_VAR 0 7
106040: ARRAY
106041: PPUSH
106042: LD_VAR 0 13
106046: PPUSH
106047: LD_VAR 0 4
106051: PUSH
106052: LD_VAR 0 7
106056: ARRAY
106057: PPUSH
106058: CALL_OW 74
106062: PPUSH
106063: CALL_OW 115
// attacking := true ;
106067: LD_ADDR_VAR 0 29
106071: PUSH
106072: LD_INT 1
106074: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
106075: LD_VAR 0 4
106079: PUSH
106080: LD_VAR 0 7
106084: ARRAY
106085: PPUSH
106086: CALL_OW 256
106090: PUSH
106091: LD_INT 500
106093: LESS
106094: IFFALSE 106120
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106096: LD_VAR 0 4
106100: PUSH
106101: LD_VAR 0 7
106105: ARRAY
106106: PPUSH
106107: LD_VAR 0 14
106111: PUSH
106112: LD_INT 1
106114: ARRAY
106115: PPUSH
106116: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
106120: LD_VAR 0 4
106124: PUSH
106125: LD_VAR 0 7
106129: ARRAY
106130: PPUSH
106131: CALL_OW 264
106135: PUSH
106136: LD_INT 49
106138: EQUAL
106139: IFFALSE 106260
// begin if not HasTask ( group [ i ] ) then
106141: LD_VAR 0 4
106145: PUSH
106146: LD_VAR 0 7
106150: ARRAY
106151: PPUSH
106152: CALL_OW 314
106156: NOT
106157: IFFALSE 106260
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
106159: LD_ADDR_VAR 0 9
106163: PUSH
106164: LD_INT 81
106166: PUSH
106167: LD_VAR 0 4
106171: PUSH
106172: LD_VAR 0 7
106176: ARRAY
106177: PPUSH
106178: CALL_OW 255
106182: PUSH
106183: EMPTY
106184: LIST
106185: LIST
106186: PPUSH
106187: CALL_OW 69
106191: PPUSH
106192: LD_VAR 0 4
106196: PUSH
106197: LD_VAR 0 7
106201: ARRAY
106202: PPUSH
106203: CALL_OW 74
106207: ST_TO_ADDR
// if k then
106208: LD_VAR 0 9
106212: IFFALSE 106260
// if GetDistUnits ( group [ i ] , k ) > 10 then
106214: LD_VAR 0 4
106218: PUSH
106219: LD_VAR 0 7
106223: ARRAY
106224: PPUSH
106225: LD_VAR 0 9
106229: PPUSH
106230: CALL_OW 296
106234: PUSH
106235: LD_INT 10
106237: GREATER
106238: IFFALSE 106260
// ComMoveUnit ( group [ i ] , k ) ;
106240: LD_VAR 0 4
106244: PUSH
106245: LD_VAR 0 7
106249: ARRAY
106250: PPUSH
106251: LD_VAR 0 9
106255: PPUSH
106256: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
106260: LD_VAR 0 4
106264: PUSH
106265: LD_VAR 0 7
106269: ARRAY
106270: PPUSH
106271: CALL_OW 256
106275: PUSH
106276: LD_INT 250
106278: LESS
106279: PUSH
106280: LD_VAR 0 4
106284: PUSH
106285: LD_VAR 0 7
106289: ARRAY
106290: PUSH
106291: LD_INT 21
106293: PUSH
106294: LD_INT 2
106296: PUSH
106297: EMPTY
106298: LIST
106299: LIST
106300: PUSH
106301: LD_INT 23
106303: PUSH
106304: LD_INT 2
106306: PUSH
106307: EMPTY
106308: LIST
106309: LIST
106310: PUSH
106311: EMPTY
106312: LIST
106313: LIST
106314: PPUSH
106315: CALL_OW 69
106319: IN
106320: AND
106321: IFFALSE 106446
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
106323: LD_ADDR_VAR 0 9
106327: PUSH
106328: LD_OWVAR 3
106332: PUSH
106333: LD_VAR 0 4
106337: PUSH
106338: LD_VAR 0 7
106342: ARRAY
106343: DIFF
106344: PPUSH
106345: LD_VAR 0 4
106349: PUSH
106350: LD_VAR 0 7
106354: ARRAY
106355: PPUSH
106356: CALL_OW 74
106360: ST_TO_ADDR
// if not k then
106361: LD_VAR 0 9
106365: NOT
106366: IFFALSE 106370
// continue ;
106368: GO 102785
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
106370: LD_VAR 0 9
106374: PUSH
106375: LD_INT 81
106377: PUSH
106378: LD_VAR 0 4
106382: PUSH
106383: LD_VAR 0 7
106387: ARRAY
106388: PPUSH
106389: CALL_OW 255
106393: PUSH
106394: EMPTY
106395: LIST
106396: LIST
106397: PPUSH
106398: CALL_OW 69
106402: IN
106403: PUSH
106404: LD_VAR 0 9
106408: PPUSH
106409: LD_VAR 0 4
106413: PUSH
106414: LD_VAR 0 7
106418: ARRAY
106419: PPUSH
106420: CALL_OW 296
106424: PUSH
106425: LD_INT 5
106427: LESS
106428: AND
106429: IFFALSE 106446
// ComAutodestruct ( group [ i ] ) ;
106431: LD_VAR 0 4
106435: PUSH
106436: LD_VAR 0 7
106440: ARRAY
106441: PPUSH
106442: CALL 79911 0 1
// end ; if f_attack_depot then
106446: LD_VAR 0 25
106450: IFFALSE 106562
// begin k := 6 ;
106452: LD_ADDR_VAR 0 9
106456: PUSH
106457: LD_INT 6
106459: ST_TO_ADDR
// if tmp < k then
106460: LD_VAR 0 14
106464: PUSH
106465: LD_VAR 0 9
106469: LESS
106470: IFFALSE 106482
// k := tmp ;
106472: LD_ADDR_VAR 0 9
106476: PUSH
106477: LD_VAR 0 14
106481: ST_TO_ADDR
// for j = 1 to k do
106482: LD_ADDR_VAR 0 8
106486: PUSH
106487: DOUBLE
106488: LD_INT 1
106490: DEC
106491: ST_TO_ADDR
106492: LD_VAR 0 9
106496: PUSH
106497: FOR_TO
106498: IFFALSE 106560
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
106500: LD_VAR 0 8
106504: PPUSH
106505: CALL_OW 266
106509: PUSH
106510: LD_INT 0
106512: PUSH
106513: LD_INT 1
106515: PUSH
106516: EMPTY
106517: LIST
106518: LIST
106519: IN
106520: IFFALSE 106558
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106522: LD_VAR 0 4
106526: PUSH
106527: LD_VAR 0 7
106531: ARRAY
106532: PPUSH
106533: LD_VAR 0 14
106537: PUSH
106538: LD_VAR 0 8
106542: ARRAY
106543: PPUSH
106544: CALL_OW 115
// attacking := true ;
106548: LD_ADDR_VAR 0 29
106552: PUSH
106553: LD_INT 1
106555: ST_TO_ADDR
// break ;
106556: GO 106560
// end ;
106558: GO 106497
106560: POP
106561: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
106562: LD_VAR 0 4
106566: PUSH
106567: LD_VAR 0 7
106571: ARRAY
106572: PPUSH
106573: CALL_OW 302
106577: PUSH
106578: LD_VAR 0 29
106582: NOT
106583: AND
106584: IFFALSE 106906
// begin if GetTag ( group [ i ] ) = 71 then
106586: LD_VAR 0 4
106590: PUSH
106591: LD_VAR 0 7
106595: ARRAY
106596: PPUSH
106597: CALL_OW 110
106601: PUSH
106602: LD_INT 71
106604: EQUAL
106605: IFFALSE 106646
// begin if HasTask ( group [ i ] ) then
106607: LD_VAR 0 4
106611: PUSH
106612: LD_VAR 0 7
106616: ARRAY
106617: PPUSH
106618: CALL_OW 314
106622: IFFALSE 106628
// continue else
106624: GO 102785
106626: GO 106646
// SetTag ( group [ i ] , 0 ) ;
106628: LD_VAR 0 4
106632: PUSH
106633: LD_VAR 0 7
106637: ARRAY
106638: PPUSH
106639: LD_INT 0
106641: PPUSH
106642: CALL_OW 109
// end ; k := 8 ;
106646: LD_ADDR_VAR 0 9
106650: PUSH
106651: LD_INT 8
106653: ST_TO_ADDR
// x := 0 ;
106654: LD_ADDR_VAR 0 10
106658: PUSH
106659: LD_INT 0
106661: ST_TO_ADDR
// if tmp < k then
106662: LD_VAR 0 14
106666: PUSH
106667: LD_VAR 0 9
106671: LESS
106672: IFFALSE 106684
// k := tmp ;
106674: LD_ADDR_VAR 0 9
106678: PUSH
106679: LD_VAR 0 14
106683: ST_TO_ADDR
// for j = 1 to k do
106684: LD_ADDR_VAR 0 8
106688: PUSH
106689: DOUBLE
106690: LD_INT 1
106692: DEC
106693: ST_TO_ADDR
106694: LD_VAR 0 9
106698: PUSH
106699: FOR_TO
106700: IFFALSE 106798
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
106702: LD_VAR 0 14
106706: PUSH
106707: LD_VAR 0 8
106711: ARRAY
106712: PPUSH
106713: CALL_OW 247
106717: PUSH
106718: LD_INT 1
106720: EQUAL
106721: PUSH
106722: LD_VAR 0 14
106726: PUSH
106727: LD_VAR 0 8
106731: ARRAY
106732: PPUSH
106733: CALL_OW 256
106737: PUSH
106738: LD_INT 250
106740: LESS
106741: PUSH
106742: LD_VAR 0 20
106746: AND
106747: PUSH
106748: LD_VAR 0 20
106752: NOT
106753: PUSH
106754: LD_VAR 0 14
106758: PUSH
106759: LD_VAR 0 8
106763: ARRAY
106764: PPUSH
106765: CALL_OW 256
106769: PUSH
106770: LD_INT 250
106772: GREATEREQUAL
106773: AND
106774: OR
106775: AND
106776: IFFALSE 106796
// begin x := tmp [ j ] ;
106778: LD_ADDR_VAR 0 10
106782: PUSH
106783: LD_VAR 0 14
106787: PUSH
106788: LD_VAR 0 8
106792: ARRAY
106793: ST_TO_ADDR
// break ;
106794: GO 106798
// end ;
106796: GO 106699
106798: POP
106799: POP
// if x then
106800: LD_VAR 0 10
106804: IFFALSE 106828
// ComAttackUnit ( group [ i ] , x ) else
106806: LD_VAR 0 4
106810: PUSH
106811: LD_VAR 0 7
106815: ARRAY
106816: PPUSH
106817: LD_VAR 0 10
106821: PPUSH
106822: CALL_OW 115
106826: GO 106852
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106828: LD_VAR 0 4
106832: PUSH
106833: LD_VAR 0 7
106837: ARRAY
106838: PPUSH
106839: LD_VAR 0 14
106843: PUSH
106844: LD_INT 1
106846: ARRAY
106847: PPUSH
106848: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106852: LD_VAR 0 4
106856: PUSH
106857: LD_VAR 0 7
106861: ARRAY
106862: PPUSH
106863: CALL_OW 314
106867: NOT
106868: IFFALSE 106906
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106870: LD_VAR 0 4
106874: PUSH
106875: LD_VAR 0 7
106879: ARRAY
106880: PPUSH
106881: LD_VAR 0 14
106885: PPUSH
106886: LD_VAR 0 4
106890: PUSH
106891: LD_VAR 0 7
106895: ARRAY
106896: PPUSH
106897: CALL_OW 74
106901: PPUSH
106902: CALL_OW 115
// end ; end ; end ;
106906: GO 102785
106908: POP
106909: POP
// wait ( 0 0$2 ) ;
106910: LD_INT 70
106912: PPUSH
106913: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106917: LD_VAR 0 4
106921: NOT
106922: PUSH
106923: LD_VAR 0 4
106927: PUSH
106928: EMPTY
106929: EQUAL
106930: OR
106931: PUSH
106932: LD_INT 81
106934: PUSH
106935: LD_VAR 0 35
106939: PUSH
106940: EMPTY
106941: LIST
106942: LIST
106943: PPUSH
106944: CALL_OW 69
106948: NOT
106949: OR
106950: IFFALSE 102770
// end ;
106952: LD_VAR 0 2
106956: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
106957: LD_INT 0
106959: PPUSH
106960: PPUSH
106961: PPUSH
106962: PPUSH
106963: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
106964: LD_VAR 0 1
106968: NOT
106969: PUSH
106970: LD_EXP 50
106974: PUSH
106975: LD_VAR 0 1
106979: ARRAY
106980: NOT
106981: OR
106982: PUSH
106983: LD_VAR 0 2
106987: NOT
106988: OR
106989: PUSH
106990: LD_VAR 0 3
106994: NOT
106995: OR
106996: IFFALSE 107000
// exit ;
106998: GO 107513
// side := mc_sides [ base ] ;
107000: LD_ADDR_VAR 0 6
107004: PUSH
107005: LD_EXP 76
107009: PUSH
107010: LD_VAR 0 1
107014: ARRAY
107015: ST_TO_ADDR
// if not side then
107016: LD_VAR 0 6
107020: NOT
107021: IFFALSE 107025
// exit ;
107023: GO 107513
// for i in solds do
107025: LD_ADDR_VAR 0 7
107029: PUSH
107030: LD_VAR 0 2
107034: PUSH
107035: FOR_IN
107036: IFFALSE 107097
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
107038: LD_VAR 0 7
107042: PPUSH
107043: CALL_OW 310
107047: PPUSH
107048: CALL_OW 266
107052: PUSH
107053: LD_INT 32
107055: PUSH
107056: LD_INT 31
107058: PUSH
107059: EMPTY
107060: LIST
107061: LIST
107062: IN
107063: IFFALSE 107083
// solds := solds diff i else
107065: LD_ADDR_VAR 0 2
107069: PUSH
107070: LD_VAR 0 2
107074: PUSH
107075: LD_VAR 0 7
107079: DIFF
107080: ST_TO_ADDR
107081: GO 107095
// SetTag ( i , 18 ) ;
107083: LD_VAR 0 7
107087: PPUSH
107088: LD_INT 18
107090: PPUSH
107091: CALL_OW 109
107095: GO 107035
107097: POP
107098: POP
// if not solds then
107099: LD_VAR 0 2
107103: NOT
107104: IFFALSE 107108
// exit ;
107106: GO 107513
// repeat wait ( 0 0$2 ) ;
107108: LD_INT 70
107110: PPUSH
107111: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
107115: LD_ADDR_VAR 0 5
107119: PUSH
107120: LD_VAR 0 6
107124: PPUSH
107125: LD_VAR 0 3
107129: PPUSH
107130: CALL 49626 0 2
107134: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107135: LD_EXP 50
107139: PUSH
107140: LD_VAR 0 1
107144: ARRAY
107145: NOT
107146: PUSH
107147: LD_EXP 50
107151: PUSH
107152: LD_VAR 0 1
107156: ARRAY
107157: PUSH
107158: EMPTY
107159: EQUAL
107160: OR
107161: IFFALSE 107198
// begin for i in solds do
107163: LD_ADDR_VAR 0 7
107167: PUSH
107168: LD_VAR 0 2
107172: PUSH
107173: FOR_IN
107174: IFFALSE 107187
// ComStop ( i ) ;
107176: LD_VAR 0 7
107180: PPUSH
107181: CALL_OW 141
107185: GO 107173
107187: POP
107188: POP
// solds := [ ] ;
107189: LD_ADDR_VAR 0 2
107193: PUSH
107194: EMPTY
107195: ST_TO_ADDR
// exit ;
107196: GO 107513
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
107198: LD_VAR 0 5
107202: NOT
107203: PUSH
107204: LD_VAR 0 5
107208: PUSH
107209: LD_INT 3
107211: GREATER
107212: OR
107213: PUSH
107214: LD_EXP 72
107218: PUSH
107219: LD_VAR 0 1
107223: ARRAY
107224: OR
107225: IFFALSE 107266
// begin for i in solds do
107227: LD_ADDR_VAR 0 7
107231: PUSH
107232: LD_VAR 0 2
107236: PUSH
107237: FOR_IN
107238: IFFALSE 107262
// if HasTask ( i ) then
107240: LD_VAR 0 7
107244: PPUSH
107245: CALL_OW 314
107249: IFFALSE 107260
// ComStop ( i ) ;
107251: LD_VAR 0 7
107255: PPUSH
107256: CALL_OW 141
107260: GO 107237
107262: POP
107263: POP
// break ;
107264: GO 107501
// end ; for i in solds do
107266: LD_ADDR_VAR 0 7
107270: PUSH
107271: LD_VAR 0 2
107275: PUSH
107276: FOR_IN
107277: IFFALSE 107493
// begin if IsInUnit ( i ) then
107279: LD_VAR 0 7
107283: PPUSH
107284: CALL_OW 310
107288: IFFALSE 107299
// ComExitBuilding ( i ) ;
107290: LD_VAR 0 7
107294: PPUSH
107295: CALL_OW 122
// if GetLives ( i ) > 333 then
107299: LD_VAR 0 7
107303: PPUSH
107304: CALL_OW 256
107308: PUSH
107309: LD_INT 333
107311: GREATER
107312: IFFALSE 107340
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107314: LD_VAR 0 7
107318: PPUSH
107319: LD_VAR 0 5
107323: PPUSH
107324: LD_VAR 0 7
107328: PPUSH
107329: CALL_OW 74
107333: PPUSH
107334: CALL_OW 115
107338: GO 107491
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
107340: LD_ADDR_VAR 0 8
107344: PUSH
107345: LD_EXP 50
107349: PUSH
107350: LD_VAR 0 1
107354: ARRAY
107355: PPUSH
107356: LD_INT 2
107358: PUSH
107359: LD_INT 30
107361: PUSH
107362: LD_INT 0
107364: PUSH
107365: EMPTY
107366: LIST
107367: LIST
107368: PUSH
107369: LD_INT 30
107371: PUSH
107372: LD_INT 1
107374: PUSH
107375: EMPTY
107376: LIST
107377: LIST
107378: PUSH
107379: LD_INT 30
107381: PUSH
107382: LD_INT 6
107384: PUSH
107385: EMPTY
107386: LIST
107387: LIST
107388: PUSH
107389: EMPTY
107390: LIST
107391: LIST
107392: LIST
107393: LIST
107394: PPUSH
107395: CALL_OW 72
107399: PPUSH
107400: LD_VAR 0 7
107404: PPUSH
107405: CALL_OW 74
107409: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
107410: LD_VAR 0 7
107414: PPUSH
107415: LD_VAR 0 8
107419: PPUSH
107420: CALL_OW 250
107424: PPUSH
107425: LD_INT 3
107427: PPUSH
107428: LD_INT 5
107430: PPUSH
107431: CALL_OW 272
107435: PPUSH
107436: LD_VAR 0 8
107440: PPUSH
107441: CALL_OW 251
107445: PPUSH
107446: LD_INT 3
107448: PPUSH
107449: LD_INT 5
107451: PPUSH
107452: CALL_OW 273
107456: PPUSH
107457: CALL_OW 111
// SetTag ( i , 0 ) ;
107461: LD_VAR 0 7
107465: PPUSH
107466: LD_INT 0
107468: PPUSH
107469: CALL_OW 109
// solds := solds diff i ;
107473: LD_ADDR_VAR 0 2
107477: PUSH
107478: LD_VAR 0 2
107482: PUSH
107483: LD_VAR 0 7
107487: DIFF
107488: ST_TO_ADDR
// continue ;
107489: GO 107276
// end ; end ;
107491: GO 107276
107493: POP
107494: POP
// until solds ;
107495: LD_VAR 0 2
107499: IFFALSE 107108
// MC_Reset ( base , 18 ) ;
107501: LD_VAR 0 1
107505: PPUSH
107506: LD_INT 18
107508: PPUSH
107509: CALL 21867 0 2
// end ;
107513: LD_VAR 0 4
107517: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
107518: LD_INT 0
107520: PPUSH
107521: PPUSH
107522: PPUSH
107523: PPUSH
107524: PPUSH
107525: PPUSH
107526: PPUSH
107527: PPUSH
107528: PPUSH
107529: PPUSH
107530: PPUSH
107531: PPUSH
107532: PPUSH
107533: PPUSH
107534: PPUSH
107535: PPUSH
107536: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
107537: LD_ADDR_VAR 0 13
107541: PUSH
107542: LD_EXP 50
107546: PUSH
107547: LD_VAR 0 1
107551: ARRAY
107552: PPUSH
107553: LD_INT 25
107555: PUSH
107556: LD_INT 3
107558: PUSH
107559: EMPTY
107560: LIST
107561: LIST
107562: PPUSH
107563: CALL_OW 72
107567: ST_TO_ADDR
// if mc_remote_driver [ base ] then
107568: LD_EXP 90
107572: PUSH
107573: LD_VAR 0 1
107577: ARRAY
107578: IFFALSE 107602
// mechs := mechs diff mc_remote_driver [ base ] ;
107580: LD_ADDR_VAR 0 13
107584: PUSH
107585: LD_VAR 0 13
107589: PUSH
107590: LD_EXP 90
107594: PUSH
107595: LD_VAR 0 1
107599: ARRAY
107600: DIFF
107601: ST_TO_ADDR
// for i in mechs do
107602: LD_ADDR_VAR 0 5
107606: PUSH
107607: LD_VAR 0 13
107611: PUSH
107612: FOR_IN
107613: IFFALSE 107648
// if GetTag ( i ) > 0 then
107615: LD_VAR 0 5
107619: PPUSH
107620: CALL_OW 110
107624: PUSH
107625: LD_INT 0
107627: GREATER
107628: IFFALSE 107646
// mechs := mechs diff i ;
107630: LD_ADDR_VAR 0 13
107634: PUSH
107635: LD_VAR 0 13
107639: PUSH
107640: LD_VAR 0 5
107644: DIFF
107645: ST_TO_ADDR
107646: GO 107612
107648: POP
107649: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
107650: LD_ADDR_VAR 0 9
107654: PUSH
107655: LD_EXP 50
107659: PUSH
107660: LD_VAR 0 1
107664: ARRAY
107665: PPUSH
107666: LD_INT 2
107668: PUSH
107669: LD_INT 25
107671: PUSH
107672: LD_INT 1
107674: PUSH
107675: EMPTY
107676: LIST
107677: LIST
107678: PUSH
107679: LD_INT 25
107681: PUSH
107682: LD_INT 5
107684: PUSH
107685: EMPTY
107686: LIST
107687: LIST
107688: PUSH
107689: LD_INT 25
107691: PUSH
107692: LD_INT 8
107694: PUSH
107695: EMPTY
107696: LIST
107697: LIST
107698: PUSH
107699: LD_INT 25
107701: PUSH
107702: LD_INT 9
107704: PUSH
107705: EMPTY
107706: LIST
107707: LIST
107708: PUSH
107709: EMPTY
107710: LIST
107711: LIST
107712: LIST
107713: LIST
107714: LIST
107715: PPUSH
107716: CALL_OW 72
107720: ST_TO_ADDR
// if not defenders and not solds then
107721: LD_VAR 0 2
107725: NOT
107726: PUSH
107727: LD_VAR 0 9
107731: NOT
107732: AND
107733: IFFALSE 107737
// exit ;
107735: GO 109427
// depot_under_attack := false ;
107737: LD_ADDR_VAR 0 17
107741: PUSH
107742: LD_INT 0
107744: ST_TO_ADDR
// sold_defenders := [ ] ;
107745: LD_ADDR_VAR 0 18
107749: PUSH
107750: EMPTY
107751: ST_TO_ADDR
// if mechs then
107752: LD_VAR 0 13
107756: IFFALSE 107909
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
107758: LD_ADDR_VAR 0 5
107762: PUSH
107763: LD_VAR 0 2
107767: PPUSH
107768: LD_INT 21
107770: PUSH
107771: LD_INT 2
107773: PUSH
107774: EMPTY
107775: LIST
107776: LIST
107777: PPUSH
107778: CALL_OW 72
107782: PUSH
107783: FOR_IN
107784: IFFALSE 107907
// begin if GetTag ( i ) <> 20 then
107786: LD_VAR 0 5
107790: PPUSH
107791: CALL_OW 110
107795: PUSH
107796: LD_INT 20
107798: NONEQUAL
107799: IFFALSE 107813
// SetTag ( i , 20 ) ;
107801: LD_VAR 0 5
107805: PPUSH
107806: LD_INT 20
107808: PPUSH
107809: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
107813: LD_VAR 0 5
107817: PPUSH
107818: CALL_OW 263
107822: PUSH
107823: LD_INT 1
107825: EQUAL
107826: PUSH
107827: LD_VAR 0 5
107831: PPUSH
107832: CALL_OW 311
107836: NOT
107837: AND
107838: IFFALSE 107905
// begin un := mechs [ 1 ] ;
107840: LD_ADDR_VAR 0 11
107844: PUSH
107845: LD_VAR 0 13
107849: PUSH
107850: LD_INT 1
107852: ARRAY
107853: ST_TO_ADDR
// ComExit ( un ) ;
107854: LD_VAR 0 11
107858: PPUSH
107859: CALL 84256 0 1
// AddComEnterUnit ( un , i ) ;
107863: LD_VAR 0 11
107867: PPUSH
107868: LD_VAR 0 5
107872: PPUSH
107873: CALL_OW 180
// SetTag ( un , 19 ) ;
107877: LD_VAR 0 11
107881: PPUSH
107882: LD_INT 19
107884: PPUSH
107885: CALL_OW 109
// mechs := mechs diff un ;
107889: LD_ADDR_VAR 0 13
107893: PUSH
107894: LD_VAR 0 13
107898: PUSH
107899: LD_VAR 0 11
107903: DIFF
107904: ST_TO_ADDR
// end ; end ;
107905: GO 107783
107907: POP
107908: POP
// if solds then
107909: LD_VAR 0 9
107913: IFFALSE 107972
// for i in solds do
107915: LD_ADDR_VAR 0 5
107919: PUSH
107920: LD_VAR 0 9
107924: PUSH
107925: FOR_IN
107926: IFFALSE 107970
// if not GetTag ( i ) then
107928: LD_VAR 0 5
107932: PPUSH
107933: CALL_OW 110
107937: NOT
107938: IFFALSE 107968
// begin defenders := defenders union i ;
107940: LD_ADDR_VAR 0 2
107944: PUSH
107945: LD_VAR 0 2
107949: PUSH
107950: LD_VAR 0 5
107954: UNION
107955: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107956: LD_VAR 0 5
107960: PPUSH
107961: LD_INT 18
107963: PPUSH
107964: CALL_OW 109
// end ;
107968: GO 107925
107970: POP
107971: POP
// repeat wait ( 0 0$2 ) ;
107972: LD_INT 70
107974: PPUSH
107975: CALL_OW 67
// enemy := mc_scan [ base ] ;
107979: LD_ADDR_VAR 0 3
107983: PUSH
107984: LD_EXP 73
107988: PUSH
107989: LD_VAR 0 1
107993: ARRAY
107994: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107995: LD_EXP 50
107999: PUSH
108000: LD_VAR 0 1
108004: ARRAY
108005: NOT
108006: PUSH
108007: LD_EXP 50
108011: PUSH
108012: LD_VAR 0 1
108016: ARRAY
108017: PUSH
108018: EMPTY
108019: EQUAL
108020: OR
108021: IFFALSE 108058
// begin for i in defenders do
108023: LD_ADDR_VAR 0 5
108027: PUSH
108028: LD_VAR 0 2
108032: PUSH
108033: FOR_IN
108034: IFFALSE 108047
// ComStop ( i ) ;
108036: LD_VAR 0 5
108040: PPUSH
108041: CALL_OW 141
108045: GO 108033
108047: POP
108048: POP
// defenders := [ ] ;
108049: LD_ADDR_VAR 0 2
108053: PUSH
108054: EMPTY
108055: ST_TO_ADDR
// exit ;
108056: GO 109427
// end ; for i in defenders do
108058: LD_ADDR_VAR 0 5
108062: PUSH
108063: LD_VAR 0 2
108067: PUSH
108068: FOR_IN
108069: IFFALSE 108887
// begin e := NearestUnitToUnit ( enemy , i ) ;
108071: LD_ADDR_VAR 0 14
108075: PUSH
108076: LD_VAR 0 3
108080: PPUSH
108081: LD_VAR 0 5
108085: PPUSH
108086: CALL_OW 74
108090: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108091: LD_ADDR_VAR 0 8
108095: PUSH
108096: LD_EXP 50
108100: PUSH
108101: LD_VAR 0 1
108105: ARRAY
108106: PPUSH
108107: LD_INT 2
108109: PUSH
108110: LD_INT 30
108112: PUSH
108113: LD_INT 0
108115: PUSH
108116: EMPTY
108117: LIST
108118: LIST
108119: PUSH
108120: LD_INT 30
108122: PUSH
108123: LD_INT 1
108125: PUSH
108126: EMPTY
108127: LIST
108128: LIST
108129: PUSH
108130: EMPTY
108131: LIST
108132: LIST
108133: LIST
108134: PPUSH
108135: CALL_OW 72
108139: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
108140: LD_ADDR_VAR 0 17
108144: PUSH
108145: LD_VAR 0 8
108149: NOT
108150: PUSH
108151: LD_VAR 0 8
108155: PPUSH
108156: LD_INT 3
108158: PUSH
108159: LD_INT 24
108161: PUSH
108162: LD_INT 600
108164: PUSH
108165: EMPTY
108166: LIST
108167: LIST
108168: PUSH
108169: EMPTY
108170: LIST
108171: LIST
108172: PPUSH
108173: CALL_OW 72
108177: OR
108178: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
108179: LD_VAR 0 5
108183: PPUSH
108184: CALL_OW 247
108188: PUSH
108189: LD_INT 2
108191: DOUBLE
108192: EQUAL
108193: IFTRUE 108197
108195: GO 108593
108197: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
108198: LD_VAR 0 5
108202: PPUSH
108203: CALL_OW 256
108207: PUSH
108208: LD_INT 650
108210: GREATER
108211: PUSH
108212: LD_VAR 0 5
108216: PPUSH
108217: LD_VAR 0 14
108221: PPUSH
108222: CALL_OW 296
108226: PUSH
108227: LD_INT 40
108229: LESS
108230: PUSH
108231: LD_VAR 0 14
108235: PPUSH
108236: LD_EXP 75
108240: PUSH
108241: LD_VAR 0 1
108245: ARRAY
108246: PPUSH
108247: CALL_OW 308
108251: OR
108252: AND
108253: IFFALSE 108375
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
108255: LD_VAR 0 5
108259: PPUSH
108260: CALL_OW 262
108264: PUSH
108265: LD_INT 1
108267: EQUAL
108268: PUSH
108269: LD_VAR 0 5
108273: PPUSH
108274: CALL_OW 261
108278: PUSH
108279: LD_INT 30
108281: LESS
108282: AND
108283: PUSH
108284: LD_VAR 0 8
108288: AND
108289: IFFALSE 108359
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
108291: LD_VAR 0 5
108295: PPUSH
108296: LD_VAR 0 8
108300: PPUSH
108301: LD_VAR 0 5
108305: PPUSH
108306: CALL_OW 74
108310: PPUSH
108311: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
108315: LD_VAR 0 5
108319: PPUSH
108320: LD_VAR 0 8
108324: PPUSH
108325: LD_VAR 0 5
108329: PPUSH
108330: CALL_OW 74
108334: PPUSH
108335: CALL_OW 296
108339: PUSH
108340: LD_INT 6
108342: LESS
108343: IFFALSE 108357
// SetFuel ( i , 100 ) ;
108345: LD_VAR 0 5
108349: PPUSH
108350: LD_INT 100
108352: PPUSH
108353: CALL_OW 240
// end else
108357: GO 108373
// ComAttackUnit ( i , e ) ;
108359: LD_VAR 0 5
108363: PPUSH
108364: LD_VAR 0 14
108368: PPUSH
108369: CALL_OW 115
// end else
108373: GO 108476
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
108375: LD_VAR 0 14
108379: PPUSH
108380: LD_EXP 75
108384: PUSH
108385: LD_VAR 0 1
108389: ARRAY
108390: PPUSH
108391: CALL_OW 308
108395: NOT
108396: PUSH
108397: LD_VAR 0 5
108401: PPUSH
108402: LD_VAR 0 14
108406: PPUSH
108407: CALL_OW 296
108411: PUSH
108412: LD_INT 40
108414: GREATEREQUAL
108415: AND
108416: PUSH
108417: LD_VAR 0 5
108421: PPUSH
108422: CALL_OW 256
108426: PUSH
108427: LD_INT 650
108429: LESSEQUAL
108430: OR
108431: PUSH
108432: LD_VAR 0 5
108436: PPUSH
108437: LD_EXP 74
108441: PUSH
108442: LD_VAR 0 1
108446: ARRAY
108447: PPUSH
108448: CALL_OW 308
108452: NOT
108453: AND
108454: IFFALSE 108476
// ComMoveToArea ( i , mc_parking [ base ] ) ;
108456: LD_VAR 0 5
108460: PPUSH
108461: LD_EXP 74
108465: PUSH
108466: LD_VAR 0 1
108470: ARRAY
108471: PPUSH
108472: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
108476: LD_VAR 0 5
108480: PPUSH
108481: CALL_OW 256
108485: PUSH
108486: LD_INT 998
108488: LESS
108489: PUSH
108490: LD_VAR 0 5
108494: PPUSH
108495: CALL_OW 263
108499: PUSH
108500: LD_INT 1
108502: EQUAL
108503: AND
108504: PUSH
108505: LD_VAR 0 5
108509: PPUSH
108510: CALL_OW 311
108514: AND
108515: PUSH
108516: LD_VAR 0 5
108520: PPUSH
108521: LD_EXP 74
108525: PUSH
108526: LD_VAR 0 1
108530: ARRAY
108531: PPUSH
108532: CALL_OW 308
108536: AND
108537: IFFALSE 108591
// begin mech := IsDrivenBy ( i ) ;
108539: LD_ADDR_VAR 0 10
108543: PUSH
108544: LD_VAR 0 5
108548: PPUSH
108549: CALL_OW 311
108553: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
108554: LD_VAR 0 10
108558: PPUSH
108559: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
108563: LD_VAR 0 10
108567: PPUSH
108568: LD_VAR 0 5
108572: PPUSH
108573: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
108577: LD_VAR 0 10
108581: PPUSH
108582: LD_VAR 0 5
108586: PPUSH
108587: CALL_OW 180
// end ; end ; unit_human :
108591: GO 108858
108593: LD_INT 1
108595: DOUBLE
108596: EQUAL
108597: IFTRUE 108601
108599: GO 108857
108601: POP
// begin b := IsInUnit ( i ) ;
108602: LD_ADDR_VAR 0 19
108606: PUSH
108607: LD_VAR 0 5
108611: PPUSH
108612: CALL_OW 310
108616: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
108617: LD_ADDR_VAR 0 20
108621: PUSH
108622: LD_VAR 0 19
108626: NOT
108627: PUSH
108628: LD_VAR 0 19
108632: PPUSH
108633: CALL_OW 266
108637: PUSH
108638: LD_INT 32
108640: PUSH
108641: LD_INT 31
108643: PUSH
108644: EMPTY
108645: LIST
108646: LIST
108647: IN
108648: OR
108649: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
108650: LD_VAR 0 17
108654: PUSH
108655: LD_VAR 0 2
108659: PPUSH
108660: LD_INT 21
108662: PUSH
108663: LD_INT 2
108665: PUSH
108666: EMPTY
108667: LIST
108668: LIST
108669: PPUSH
108670: CALL_OW 72
108674: PUSH
108675: LD_INT 1
108677: LESSEQUAL
108678: OR
108679: PUSH
108680: LD_VAR 0 20
108684: AND
108685: PUSH
108686: LD_VAR 0 5
108690: PUSH
108691: LD_VAR 0 18
108695: IN
108696: NOT
108697: AND
108698: IFFALSE 108791
// begin if b then
108700: LD_VAR 0 19
108704: IFFALSE 108753
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
108706: LD_VAR 0 19
108710: PPUSH
108711: LD_VAR 0 3
108715: PPUSH
108716: LD_VAR 0 19
108720: PPUSH
108721: CALL_OW 74
108725: PPUSH
108726: CALL_OW 296
108730: PUSH
108731: LD_INT 10
108733: LESS
108734: PUSH
108735: LD_VAR 0 19
108739: PPUSH
108740: CALL_OW 461
108744: PUSH
108745: LD_INT 7
108747: NONEQUAL
108748: AND
108749: IFFALSE 108753
// continue ;
108751: GO 108068
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108753: LD_ADDR_VAR 0 18
108757: PUSH
108758: LD_VAR 0 18
108762: PPUSH
108763: LD_VAR 0 18
108767: PUSH
108768: LD_INT 1
108770: PLUS
108771: PPUSH
108772: LD_VAR 0 5
108776: PPUSH
108777: CALL_OW 1
108781: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108782: LD_VAR 0 5
108786: PPUSH
108787: CALL_OW 122
// end ; if sold_defenders then
108791: LD_VAR 0 18
108795: IFFALSE 108855
// if i in sold_defenders then
108797: LD_VAR 0 5
108801: PUSH
108802: LD_VAR 0 18
108806: IN
108807: IFFALSE 108855
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108809: LD_VAR 0 5
108813: PPUSH
108814: CALL_OW 314
108818: NOT
108819: PUSH
108820: LD_VAR 0 5
108824: PPUSH
108825: LD_VAR 0 14
108829: PPUSH
108830: CALL_OW 296
108834: PUSH
108835: LD_INT 30
108837: LESS
108838: AND
108839: IFFALSE 108855
// ComAttackUnit ( i , e ) ;
108841: LD_VAR 0 5
108845: PPUSH
108846: LD_VAR 0 14
108850: PPUSH
108851: CALL_OW 115
// end ; end ; end ;
108855: GO 108858
108857: POP
// if IsDead ( i ) then
108858: LD_VAR 0 5
108862: PPUSH
108863: CALL_OW 301
108867: IFFALSE 108885
// defenders := defenders diff i ;
108869: LD_ADDR_VAR 0 2
108873: PUSH
108874: LD_VAR 0 2
108878: PUSH
108879: LD_VAR 0 5
108883: DIFF
108884: ST_TO_ADDR
// end ;
108885: GO 108068
108887: POP
108888: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108889: LD_VAR 0 3
108893: NOT
108894: PUSH
108895: LD_VAR 0 2
108899: NOT
108900: OR
108901: PUSH
108902: LD_EXP 50
108906: PUSH
108907: LD_VAR 0 1
108911: ARRAY
108912: NOT
108913: OR
108914: IFFALSE 107972
// MC_Reset ( base , 18 ) ;
108916: LD_VAR 0 1
108920: PPUSH
108921: LD_INT 18
108923: PPUSH
108924: CALL 21867 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108928: LD_ADDR_VAR 0 2
108932: PUSH
108933: LD_VAR 0 2
108937: PUSH
108938: LD_VAR 0 2
108942: PPUSH
108943: LD_INT 2
108945: PUSH
108946: LD_INT 25
108948: PUSH
108949: LD_INT 1
108951: PUSH
108952: EMPTY
108953: LIST
108954: LIST
108955: PUSH
108956: LD_INT 25
108958: PUSH
108959: LD_INT 5
108961: PUSH
108962: EMPTY
108963: LIST
108964: LIST
108965: PUSH
108966: LD_INT 25
108968: PUSH
108969: LD_INT 8
108971: PUSH
108972: EMPTY
108973: LIST
108974: LIST
108975: PUSH
108976: LD_INT 25
108978: PUSH
108979: LD_INT 9
108981: PUSH
108982: EMPTY
108983: LIST
108984: LIST
108985: PUSH
108986: EMPTY
108987: LIST
108988: LIST
108989: LIST
108990: LIST
108991: LIST
108992: PPUSH
108993: CALL_OW 72
108997: DIFF
108998: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108999: LD_VAR 0 3
109003: NOT
109004: PUSH
109005: LD_VAR 0 2
109009: PPUSH
109010: LD_INT 21
109012: PUSH
109013: LD_INT 2
109015: PUSH
109016: EMPTY
109017: LIST
109018: LIST
109019: PPUSH
109020: CALL_OW 72
109024: AND
109025: IFFALSE 109363
// begin tmp := FilterByTag ( defenders , 19 ) ;
109027: LD_ADDR_VAR 0 12
109031: PUSH
109032: LD_VAR 0 2
109036: PPUSH
109037: LD_INT 19
109039: PPUSH
109040: CALL 81386 0 2
109044: ST_TO_ADDR
// if tmp then
109045: LD_VAR 0 12
109049: IFFALSE 109119
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
109051: LD_ADDR_VAR 0 12
109055: PUSH
109056: LD_VAR 0 12
109060: PPUSH
109061: LD_INT 25
109063: PUSH
109064: LD_INT 3
109066: PUSH
109067: EMPTY
109068: LIST
109069: LIST
109070: PPUSH
109071: CALL_OW 72
109075: ST_TO_ADDR
// if tmp then
109076: LD_VAR 0 12
109080: IFFALSE 109119
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
109082: LD_ADDR_EXP 62
109086: PUSH
109087: LD_EXP 62
109091: PPUSH
109092: LD_VAR 0 1
109096: PPUSH
109097: LD_EXP 62
109101: PUSH
109102: LD_VAR 0 1
109106: ARRAY
109107: PUSH
109108: LD_VAR 0 12
109112: UNION
109113: PPUSH
109114: CALL_OW 1
109118: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
109119: LD_VAR 0 1
109123: PPUSH
109124: LD_INT 19
109126: PPUSH
109127: CALL 21867 0 2
// repeat wait ( 0 0$1 ) ;
109131: LD_INT 35
109133: PPUSH
109134: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109138: LD_EXP 50
109142: PUSH
109143: LD_VAR 0 1
109147: ARRAY
109148: NOT
109149: PUSH
109150: LD_EXP 50
109154: PUSH
109155: LD_VAR 0 1
109159: ARRAY
109160: PUSH
109161: EMPTY
109162: EQUAL
109163: OR
109164: IFFALSE 109201
// begin for i in defenders do
109166: LD_ADDR_VAR 0 5
109170: PUSH
109171: LD_VAR 0 2
109175: PUSH
109176: FOR_IN
109177: IFFALSE 109190
// ComStop ( i ) ;
109179: LD_VAR 0 5
109183: PPUSH
109184: CALL_OW 141
109188: GO 109176
109190: POP
109191: POP
// defenders := [ ] ;
109192: LD_ADDR_VAR 0 2
109196: PUSH
109197: EMPTY
109198: ST_TO_ADDR
// exit ;
109199: GO 109427
// end ; for i in defenders do
109201: LD_ADDR_VAR 0 5
109205: PUSH
109206: LD_VAR 0 2
109210: PUSH
109211: FOR_IN
109212: IFFALSE 109301
// begin if not IsInArea ( i , mc_parking [ base ] ) then
109214: LD_VAR 0 5
109218: PPUSH
109219: LD_EXP 74
109223: PUSH
109224: LD_VAR 0 1
109228: ARRAY
109229: PPUSH
109230: CALL_OW 308
109234: NOT
109235: IFFALSE 109259
// ComMoveToArea ( i , mc_parking [ base ] ) else
109237: LD_VAR 0 5
109241: PPUSH
109242: LD_EXP 74
109246: PUSH
109247: LD_VAR 0 1
109251: ARRAY
109252: PPUSH
109253: CALL_OW 113
109257: GO 109299
// if GetControl ( i ) = control_manual then
109259: LD_VAR 0 5
109263: PPUSH
109264: CALL_OW 263
109268: PUSH
109269: LD_INT 1
109271: EQUAL
109272: IFFALSE 109299
// if IsDrivenBy ( i ) then
109274: LD_VAR 0 5
109278: PPUSH
109279: CALL_OW 311
109283: IFFALSE 109299
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
109285: LD_VAR 0 5
109289: PPUSH
109290: CALL_OW 311
109294: PPUSH
109295: CALL_OW 121
// end ;
109299: GO 109211
109301: POP
109302: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
109303: LD_VAR 0 2
109307: PPUSH
109308: LD_INT 95
109310: PUSH
109311: LD_EXP 74
109315: PUSH
109316: LD_VAR 0 1
109320: ARRAY
109321: PUSH
109322: EMPTY
109323: LIST
109324: LIST
109325: PPUSH
109326: CALL_OW 72
109330: PUSH
109331: LD_VAR 0 2
109335: EQUAL
109336: PUSH
109337: LD_EXP 73
109341: PUSH
109342: LD_VAR 0 1
109346: ARRAY
109347: OR
109348: PUSH
109349: LD_EXP 50
109353: PUSH
109354: LD_VAR 0 1
109358: ARRAY
109359: NOT
109360: OR
109361: IFFALSE 109131
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
109363: LD_ADDR_EXP 72
109367: PUSH
109368: LD_EXP 72
109372: PPUSH
109373: LD_VAR 0 1
109377: PPUSH
109378: LD_VAR 0 2
109382: PPUSH
109383: LD_INT 21
109385: PUSH
109386: LD_INT 2
109388: PUSH
109389: EMPTY
109390: LIST
109391: LIST
109392: PPUSH
109393: CALL_OW 72
109397: PPUSH
109398: CALL_OW 1
109402: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
109403: LD_VAR 0 1
109407: PPUSH
109408: LD_INT 19
109410: PPUSH
109411: CALL 21867 0 2
// MC_Reset ( base , 20 ) ;
109415: LD_VAR 0 1
109419: PPUSH
109420: LD_INT 20
109422: PPUSH
109423: CALL 21867 0 2
// end ; end_of_file
109427: LD_VAR 0 4
109431: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
109432: LD_VAR 0 1
109436: PUSH
109437: LD_INT 200
109439: DOUBLE
109440: GREATEREQUAL
109441: IFFALSE 109449
109443: LD_INT 299
109445: DOUBLE
109446: LESSEQUAL
109447: IFTRUE 109451
109449: GO 109483
109451: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
109452: LD_VAR 0 1
109456: PPUSH
109457: LD_VAR 0 2
109461: PPUSH
109462: LD_VAR 0 3
109466: PPUSH
109467: LD_VAR 0 4
109471: PPUSH
109472: LD_VAR 0 5
109476: PPUSH
109477: CALL 98373 0 5
109481: GO 109560
109483: LD_INT 300
109485: DOUBLE
109486: GREATEREQUAL
109487: IFFALSE 109495
109489: LD_INT 399
109491: DOUBLE
109492: LESSEQUAL
109493: IFTRUE 109497
109495: GO 109559
109497: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
109498: LD_VAR 0 1
109502: PPUSH
109503: LD_VAR 0 2
109507: PPUSH
109508: LD_VAR 0 3
109512: PPUSH
109513: LD_VAR 0 4
109517: PPUSH
109518: LD_VAR 0 5
109522: PPUSH
109523: LD_VAR 0 6
109527: PPUSH
109528: LD_VAR 0 7
109532: PPUSH
109533: LD_VAR 0 8
109537: PPUSH
109538: LD_VAR 0 9
109542: PPUSH
109543: LD_VAR 0 10
109547: PPUSH
109548: LD_VAR 0 11
109552: PPUSH
109553: CALL 96279 0 11
109557: GO 109560
109559: POP
// end ;
109560: PPOPN 11
109562: END
